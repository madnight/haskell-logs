00:00:43 <etaoinshrdlu> But if read fails that will give you an error, you should probably use readMaybe instead.
00:01:20 <favetelinguis> ok ty, will look into that
00:04:05 <etaoinshrdlu> Glad I could help even though I'm quite new to haskell aswell :)
00:04:16 <Mokosha_> MP2E, adding a type signature doesn't help
00:04:47 <Mokosha_> changing the functional dependency from a -> b to b -> a with a type signature does
00:05:00 <Mokosha_> which doesn't really make sense to me
00:08:20 <MP2E> looks like thebnq was right! it couldn't unify a0 with v2 and the functional dependency allowed it to use DidThing2 to determine that a0 is v2
00:08:32 <MP2E> though it is a bit strange to me too that the other way around doesn't work.. hmm
00:10:28 * hackagebot hspec-meta 1.12.4 - A version of Hspec which is used to test Hspec itself  http://hackage.haskell.org/package/hspec-meta-1.12.4 (SimonHengel)
00:10:28 * hackagebot hspec 1.12.4 - A Testing Framework for Haskell  http://hackage.haskell.org/package/hspec-1.12.4 (SimonHengel)
00:16:23 <kqr> does anyone know if providing a random number generator to sortBy will create a decent shuffle or if it will be horribly biased toward the current order of elements?
00:16:52 <kqr> (I know that the type signature prohibits this, but imagine unsafePerformIO or something similar)
00:17:07 <Hijiri> you don't need unsafePerformIO
00:17:17 <Hijiri> you can make it take a StdGen
00:17:51 <Hijiri> the problem is I don't think it would work with sortBy, you would need a custom sort function
00:17:59 <Hijiri> because sortBy doesn't keep any state from the previous sorts
00:18:34 <kqr> yeah, hence the unsafePerformIO ;)
00:18:44 <Hijiri> I don't think it would be hard to make a sortState or something like that
00:18:57 <kqr> but I'm still not convinced it would provide a decent shuffle
00:19:18 <Hijiri> I think it should be decent enough
00:19:44 <Hijiri> Either way I don't think it's worth infecting your code with unsafePerformIO, you should use State or StateT
00:21:27 <Hijiri> I wonder if there's already some sort of monadic sort function out there that would make this easy
00:21:58 <nshepperd> sorting with a RNG is known to produce a biased shuffle
00:24:28 <Hijiri> couldn't you implement random permuting without sortBy?
00:25:06 <kqr> nshepperd, that's what I expected. thanks
00:27:30 <nshepperd> http://bost.ocks.org/mike/shuffle/compare.html demonstrates nicely
00:32:01 <kqr> oh
00:32:02 <kqr> neat illustration
00:32:58 <kqr> ah sort by random order was clever
00:34:56 <mememeffs> ]Hey so a bit of an abstract question i guess, if im sending the bytes of a png or jpeg image through a tcp connection how do i determine how many bytes or bits can be ( hexidecimal value = to 0) for the image to still be readable for an os?
00:40:15 <kqr> you try with different numbers of bits and bytes
00:40:21 <kqr> and see when it stops working!
00:50:24 * hackagebot hzulip 1.1.0.1 - A haskell wrapper for the Zulip API.  http://hackage.haskell.org/package/hzulip-1.1.0.1 (yamadapc)
01:01:24 <prinsen> Im writing a JS interpreter, and has a store of objects in the State. I do al lot of updates and accesses by their id (Int). What would be the fastest data structure?
01:32:16 <roelof> Is there a problem with the haskell beginners mailing list. I send about 15 minutes ago a message and it still not on the list ?
01:39:00 <roelof> Is there a problem with the haskell beginners mailing list. I send about 15 minutes ago a message and it still not on the list ?
01:39:20 <Kinnison> Are you sure (a) it was delivered to the list and (b) that you were properly subscribed?
01:39:30 <Kinnison> Mailing lists can sometimes take a while to sort stuff out
01:40:26 * hackagebot hzulip 1.1.0.2 - A haskell wrapper for the Zulip API.  http://hackage.haskell.org/package/hzulip-1.1.0.2 (yamadapc)
01:40:28 * hackagebot hzulip 1.1.0.3 - A haskell wrapper for the Zulip API.  http://hackage.haskell.org/package/hzulip-1.1.0.3 (yamadapc)
01:40:51 <roelof> Kinnison:  a) Im not sure , I did not see my message on the list. b) yes, I m properly subscribed. I did recieve the welcome message
01:42:16 <Kinnison> No idea then, sorry
01:43:52 <roelof> Kinnison:  NP , thanks for the help
01:45:26 * hackagebot hzulip 1.1.0.4 - A haskell wrapper for the Zulip API.  http://hackage.haskell.org/package/hzulip-1.1.0.4 (yamadapc)
02:00:26 * hackagebot hzulip 1.1.0.5 - A haskell wrapper for the Zulip API.  http://hackage.haskell.org/package/hzulip-1.1.0.5 (yamadapc)
02:12:41 <Kerry-Ann23>  High Quality photos and videos http://tny.de/patJ2
02:25:27 * hackagebot hlint 1.9.12 - Source code suggestions  http://hackage.haskell.org/package/hlint-1.9.12 (NeilMitchell)
02:33:46 <trap_exit> is quantum mechanics lazy?
02:33:55 <trap_exit> i.e. do things _not happen_ until you observe them?
02:41:37 <albertid> Hi, would anyone know if I can combine Behaviors in reactive-banana? As in :: (a -> b -> c) -> Behavior a -> Behavior b -> Behavior c
02:44:39 <supki> albertid: is Behavior an instance of Applicative?
02:45:14 <albertid> supki, yep
02:45:28 <supki> then liftA2
02:45:32 <supki> :t liftA2
02:45:33 <lambdabot> Applicative f => (a -> b -> c) -> f a -> f b -> f c
02:46:28 <albertid> ah nice, thank you
02:46:33 <wei2912> is it possible to use quickcheck just to test for a specific case?
03:20:27 * oscar`
03:23:40 <kamila> Hi, I am a beginner struggling with parallel stuff, could sb help me?
03:25:05 <ClaudiusMaximus> kamila: just ask your real question ("don't ask to ask")
03:25:18 <kamila> ClaudiusMaximus: Yeah, sorry :D
03:25:22 <kamila> I would like to run several (pure) computations on the same input and I want to get any (i.e.) the first result. I have seen the `compete` idiom on https://www.haskell.org/haskellwiki/Timing_out_computations , but it doesn't quite work.
03:26:21 <kamila> Specifically, it seems to me that it picks one of the threads and runs it until completion (so if one of the computations is long, I get to wait instead of getting the results from the faster one).
03:26:49 <Twey> kamila: You can use amb or unamb
03:27:24 <dv-> kamila: seems like what you want is waitAny from asnyc
03:27:28 <Twey> unamb is deterministic, and assumes that your computations all return the same result eventually
03:27:33 <dramforever> kamila: I guess this is happening:
03:27:52 <dramforever> 1. some thread puts a thunk into a mvar
03:27:56 <kamila> My computations are deterministic (I am trying various strategies to factor a large integer).
03:28:00 <Twey> amb is a bit evil, and yes, would be better to use waitAny
03:28:07 <Twey> kamila: Then unamb is fine
03:28:14 <dramforever> 2. compete takes from the mvar, and evaluates it
03:28:35 <dramforever> maybe you are not actually doing the work in the worker threads
03:28:49 <Twey> kamila: result = factor1 x `unamb` factor2 x `unamb` factor3 x
03:30:24 <kamila> Twey: OK, I'll try unamb, thanks a lot!
03:30:42 <kamila> dramforever: The functions work when I test them in ghci O:-)
03:30:53 <kamila> dramforever: Also, yes, I have no clue about monads.
03:31:08 <kamila> dramforever: (haven't gotten to that part yet...)
03:31:19 <dramforever> kamila: no, nothing about monads
03:31:31 <kamila> dramforever: Well, about when stuff gets evaluated, I mean.
03:32:37 <dramforever> hmmmm...
03:33:23 <ClaudiusMaximus> kamila: http://chimera.labs.oreilly.com/books/1230000000929/ch02.html#sec_par-eval-whnf might help
03:33:36 <dramforever> Haskell beginners often misuse these expressions: "monad", "referential transparency", "lazy evaluating"
03:33:36 <kamila> ClaudiusMaximus: Thanks!
03:35:17 <Fuuzetsu> reading the whole book is worth-while
03:35:25 <kamila> dramforever: I think that might be the case :D I don't get evaluation yet. But as soon as I break RSA for homework, I'll look into that :D
03:37:22 <dramforever> I'm not sure if it's right to ask here, but I'd like to know about the software used to produce the figures in http://haskell.org/arrows
03:40:01 <Fuuzetsu> hm, I think it predates diagrams
03:40:29 <Fuuzetsu> oh actually, diagrams dates back to 2008 so maybe that
03:41:08 <Fuuzetsu> ping Cale , he made those I think
03:41:41 <dramforever> should I /msg Cale ?
03:41:55 <Fuuzetsu> if you want; he'll probably see this when he's on; you could @tell him
03:41:58 <Twey> IIRC it was TeX/PGF or something similar
03:42:57 <dramforever> @help tell
03:42:57 <lambdabot> tell <nick> <message>. When <nick> shows activity, tell them <message>.
03:43:54 <ClaudiusMaximus> Fuuzetsu: pretty sure the arrows page predates 2008 - a version from 2003 has images (but they weren't archived - they look about the right dimensions though) in the archive.org wayback machine
03:44:24 <dramforever> @tell Cale dramforever wants to know what software was used to produce the figures in http://haskell.org/arrows . However dramforever does not come to irc often, so please use @tell . thanks
03:44:24 <lambdabot> Consider it noted.
03:45:10 <dramforever> hmmm...
03:46:09 * dramforever was influenced by haskell and likes to put spaces *around* periods
03:49:54 <wei2912> does anyone have a good intro on monads and arrows?
03:52:40 <Polarina> wei2912, it'll probably be simpler for you to try to use one of the common monads (Reader, Writer, State, etc.) and go on from there.
03:53:41 <Polarina> wei2912, monads are like a generalization of a generalization, and as a result, near impossible to understand without seeing them in use.
03:53:42 <Fuuzetsu> dramforever: some folk here swallow up their spaces around operators
03:53:50 <Fuuzetsu> heretics I say
03:53:58 <dramforever> yeah!!! I know
03:54:05 <dramforever> It sucks to see:
03:54:08 <dramforever> a=1
03:54:10 <dramforever> b=2
03:54:18 <dramforever> print(a+b/2)
03:54:29 <wei2912> Polarina: alright, thanks. what about arrows?
03:54:33 <benmachine> I think x^2 is ok
03:54:34 <Fuuzetsu> well, more like a.=b^..c.~a
03:54:45 <dramforever> is that lens?
03:54:49 <benmachine> and 2*x depending on my mood
03:54:54 <Fuuzetsu> some random vomit of, yes
03:55:06 <Polarina> wei2912, start with monads and get a good feel for them. Then do the same with arrows, find uses of them and play with them.
03:55:27 <wei2912> Polarina: alright, thanks!
03:55:36 <Polarina> wei2912, you're welcome.
03:55:51 <Fuuzetsu> Polarina: what do monads generalise here?
03:55:57 <Fuuzetsu> (except monoids in 2-category)
03:56:41 <Polarina> Fuuzetsu, my lack of a proper vocabulary results in some abuse of terms. :(
03:56:51 <Fuuzetsu> well, I'm asking what you meant
03:56:58 <Fuuzetsu> also what I said is not quite accurate either ;)
03:57:34 <Polarina> I meant that monads are a form of generalization, and not easy to understand their purpose without seeing them in use for some specialized tasks.
03:58:58 <Polarina> Monads are like programmable semicolons. Useless at first, but very devious.
04:00:25 <Fuuzetsu> I wouldn't say they are useless at first ;P
04:00:26 <moriarty> wow 1422 people on haskell
04:00:31 <moriarty> i wonder how many are just noob lurkers
04:00:59 <Polarina> Fuuzetsu, :)
04:01:17 <exio4> Fuuzetsu: they are useless because they are really complicated and like burritos
04:01:33 <dramforever> hmm...why not just use existing ones
04:02:03 <dramforever> I often have something like ReaderT MyEnv (StateT MyState IO)
04:02:26 <dramforever> It's not complicated if you do not go into the inner details
04:03:54 <exio4> I really think monads are just like what someone would call a "design pattern", the difference in HS is that you can abstract it easily compared to other langs, and also use it easily
04:04:25 <dramforever> yep
04:04:34 <exio4> and well, it has a name that came from mathematics, so it is really hard, crazy and weird, isn't it? because it is math!
04:04:48 <Fuuzetsu> let's not discuss this for Nth time
04:04:52 * moriarty farts
04:05:05 <moriarty> are there any haskell traders here?
04:05:50 <dramforever> for example Reader and ReaderT solves the problem when we pass a value around like this
04:06:19 <dramforever> void func1(foo x, int i, int j) { func2(x, i); func3(x, j) }
04:06:58 <dramforever> object oriented programming solves this a bit
04:07:34 <Keeper> http://pastebin.com/tuvxS6n5 how can I express a for() loop like this?
04:08:32 <Keeper> Say I want to print a string N times (N being the length of an array).
04:08:42 <benmachine> Keeper: you want to put (length characters) in parentheses
04:08:56 <benmachine> then you will get a program that compiles, although I'm not sure if it's what you want
04:09:08 <zwer> you also don't need let in let characters
04:09:48 <ClaudiusMaximus> Keeper: replicateM count (putStrLn string) -- possibly the most idiomatic way
04:10:02 <ClaudiusMaximus> oops replicateM_ would be better
04:10:06 <Keeper> Is that from Control.Monad?
04:10:10 <ClaudiusMaximus> yes
04:10:11 <dramforever> yep, iirc
04:10:22 <jchmrt> Keeper: also why do you have a list of strings as characters?
04:10:32 <Fuuzetsu> there's forM if you really want to keep the spirit of ugly programs
04:11:05 <Keeper> Generally, the program has to output the XOR of each two pairs of characters in the array. For example: a ^ c, f ^ d etc.
04:11:39 <dramforever> Fuuzetsu: forM (chunkify data) $ \chunk -> processChunk chunk
04:12:47 <dramforever> I heard that it's better to use map/foldr/foldl... than to hand-code a loop
04:13:03 <zwer> @pl \chunk -> processChunk chunk
04:13:04 <lambdabot> processChunk
04:13:10 <dramforever> well...
04:13:25 <dramforever> that's a placeholder for chunk-processing-code
04:13:56 <dramforever> People say these funcs are faster
04:14:09 <dramforever> but shouldn't hand-coded special stuff be faster?
04:14:18 <Fuuzetsu> depends
04:14:27 <Fuuzetsu> if it gets fused then it might not be
04:14:41 <dramforever> What does "fused" mean
04:14:45 <Fuuzetsu> but it's often worthwhile to have inner loops with strict args &c
04:15:22 <Fuuzetsu> list fusion
04:15:22 <exio4> converting things like "foldr f d . map g . map h" to "foldr (f . g . h) d"
04:15:35 <dramforever> for example: insertation sort:
04:15:42 <Fuuzetsu> insertion*
04:15:49 <dramforever> oh...
04:15:56 <dramforever> oops
04:16:14 <Keeper> This is how the program looks like in C: http://pastebin.com/ETkESm8b. Simply laid, would it be 'easy' to rewrite it in Haskell?
04:16:15 <dramforever> isort [] = []
04:16:16 <dramforever> isort (x:xs) = insert x (isort xs) -- bad
04:17:29 <dramforever> isort = foldr insert [] -- good
04:17:32 <Fuuzetsu> Keeper: you could translate it pretty closely
04:18:36 <dramforever> Keeper: I'm not sure, but it seems that you need zipWith
04:18:47 <lpaste> Keeper pasted “Haskell” at http://lpaste.net/4445343829133885440
04:19:05 <dramforever> oh not zipped
04:19:37 <dramforever> 12 Data.Bits..^. 12
04:19:39 <dramforever> > 12 Data.Bits..^. 12
04:19:41 <lambdabot>  Not in scope: ‘Data.Bits..^.’
04:19:41 <lambdabot>  Perhaps you meant one of these:
04:19:41 <lambdabot>    ‘Data.Bits..&.’ (imported from Data.Bits),
04:19:41 <lambdabot>    ‘Data.Bits..|.’ (imported from Data.Bits)
04:19:52 <Fuuzetsu> :t ord
04:19:53 <lambdabot> Char -> Int
04:19:56 <Fuuzetsu> :t (^)
04:19:56 <lambdabot> (Num a, Integral b) => a -> b -> a
04:20:04 <dramforever> > 2 ^ 5
04:20:05 <lambdabot>  32
04:20:13 <Fuuzetsu> :t chr
04:20:14 <lambdabot> Int -> Char
04:20:17 <Fuuzetsu> ;P
04:20:31 <dramforever> ha!
04:20:36 <dramforever> > 12 `xor` 12
04:20:37 <lambdabot>  0
04:20:41 <dramforever> > 12 `xor` 55
04:20:43 <lambdabot>  59
04:21:03 <ClaudiusMaximus> Keeper: mapM_ putStrLn [ [toEnum (fromEnum a `xor` fromEnum b)] | (a:bs) <- tails "abcdef", b <- bs ]
04:21:34 <Fuuzetsu> ClaudiusMaximus: is that bs shaadowing intended
04:21:47 <ClaudiusMaximus> Fuuzetsu: what shadowing?
04:21:48 <Fuuzetsu> hm
04:21:49 <dramforever> > [ [toEnum (fromEnum a `xor`  fromEnum b)] | (a:bs) <- tails "abcdef", b <- bs ]
04:21:51 <lambdabot>  [[*Exception: Prelude.Enum.().toEnum: bad argument
04:21:58 <dramforever> ouch
04:22:00 <Fuuzetsu> (a:bs) <- …, b <- bs
04:22:12 <Keeper> Main.hs:1:1: Parse error: naked expression at top level
04:22:13 <dramforever> > [ [ord a `xor` ord b)] | (a:bs) <- tails "abcdef", b <- bs ]
04:22:14 <lambdabot>  <hint>:1:21: parse error on input ‘)’
04:22:22 <dramforever> > [ ord a `xor` ord b | (a:bs) <- tails "abcdef", b <- bs ]
04:22:24 <lambdabot>  [3,2,5,4,7,1,6,7,4,7,6,5,1,2,3]
04:22:27 <ClaudiusMaximus> Fuuzetsu: that's not shadowing, it's binding bs to the tail of the lists, then drawing from it
04:22:45 <Fuuzetsu> ClaudiusMaximus: oh, I read it the wrong way
04:22:53 <Fuuzetsu> I tend to read right to left ;P
04:22:57 <Fuuzetsu> Haskelll that is
04:23:23 <dramforever> Keeper: if you want byte operations maybe you want Wordd8
04:23:28 <dramforever>  Word8
04:23:32 <ClaudiusMaximus> the toEnum works there because putStrLn takes [Char]
04:23:49 <Keeper> Meaning there is no integrated XOR operator in Haskell?
04:24:03 <dramforever> why there should be
04:24:03 <ClaudiusMaximus> Keeper: there's `xor` in Data.Bits
04:24:41 <dramforever> ClaudiusMaximus: I think Keeper thinks that ^ should be primitive
04:25:14 <dramforever> actually, (+) isn't integrated, in a way
04:25:18 <Fuuzetsu> maybe in a language where everything is a number
04:25:22 <dramforever> even numbers aren't integrated
04:25:50 <dramforever> well, I mean even [numbers aren't integrated]
04:26:01 <dramforever> not [even numbers] aren't integrated
04:28:27 <det> Is there any benefit to having groups of functions in type classes, rather than 1 class per function, other than keeping function signatures short ?
04:28:51 <rai> what does it mean exactly when LYAH talks about lists being non-deterministic values?
04:29:13 <Fuuzetsu> dramforever: depends how we're looking at (+) not being integrated
04:29:29 <dramforever> (+) is not primitive, in a way
04:29:40 <Fuuzetsu> +# is though and actual instances build upon it
04:29:48 <dramforever> yep
04:29:55 <Fuuzetsu> (+#) :: Int# -> Int# -> Int#
04:29:56 <Fuuzetsu> (+#) = let x = x in x
04:32:07 <ChristianS> i want to call an external program from haskell and collect its stdout. what's the best way to do that?
04:32:11 <ClaudiusMaximus> det: some classes group related functions and make sense (like Ord - you can define optimized implementations for < if you like, otherwise defining compare is enough), others make a bit less sense (like Num)
04:34:16 <ClaudiusMaximus> ChristianS: maybe http://hackage.haskell.org/package/process-1.2.0.0/docs/System-Process.html#v:readProcess or something else from that library
04:34:17 <dramforever> ChristianS: System.Process
04:34:45 <det> ClaudiusMaximus, Thanks
04:34:55 <ChristianS> ClaudiusMaximus, dramforever: i'll check it out, thanks
04:35:42 <Haskellfant> Hi I need some help understanding and fixing a type error. I'm trying to write an evaluator for a simple scheme but when trying to implement addition I'm getting type errors http://lpaste.net/113974
04:36:09 <zwer> > let (^) = xor in 10 ^ 2
04:36:11 <lambdabot>  8
04:37:31 <dramforever> Haskellfant: change to this
04:37:54 <dramforever> binOp :: (forall a. Num a => a -> a -> a) -> LispVal -> LispVal -> LispVal
04:38:04 <dramforever> And prepend this line to your source file:
04:38:04 <ClaudiusMaximus> Haskellfant: binOp calls op at two different types, which isn't allowed - you could use -XRankNTypes to make op polymorphic like dramforever suggests
04:38:16 <dramforever> {-# LANGUAGE RankNTypes #-}
04:40:19 <ClaudiusMaximus> Haskellfant: your original type is equivalent to binOp :: forall a . Num a => (a -> a -> a) -> LispVal -> LispVal -> LispVal
04:40:32 * hackagebot yesod-bin 1.4.0.6 - The yesod helper executable.  http://hackage.haskell.org/package/yesod-bin-1.4.0.6 (MichaelSnoyman)
04:41:14 <Haskellfant> hm let me think about that for a minute :)
04:41:37 <dramforever> Haskellfant: Does it work now?
04:41:42 <Haskellfant> yep
04:42:01 <Haskellfant> I only need to understand why :)
04:42:15 <dramforever> before changing
04:42:31 <dramforever> you say your function can acccept a op on any number
04:42:49 <Haskellfant> ah right
04:42:51 <Haskellfant> now I got it
04:42:52 <Haskellfant> thx
04:42:59 <dramforever> Yeah
04:43:11 <ClaudiusMaximus> Haskellfant: in the original version, 'a' is determined by the caller of binOp, in the RankNTypes version binOp determines 'a' so the operator must work for any Num
04:43:18 <dramforever> You make me remember the first time I actually made use of RankNTypes
04:43:27 <Haskellfant> hehe
05:01:39 <dbushenko> hi all!
05:01:45 <dbushenko> does anyone use scotty?
05:04:54 <notdan> dbushenko: I do
05:05:07 <dbushenko> wow!
05:05:26 <dbushenko> may be you could give me an example of how to add session to the application on scotty?
05:05:34 <dbushenko> I'm totally stuck with that...
05:08:06 <dbushenko> notdan, ?
05:08:33 <hsk8> Quote from LYAH:
05:08:37 <hsk8> "Let's start with the first line. It says class Monad m where. But wait, didn't we say that monads are just beefed up applicative functors? Shouldn't there be a class constraint in there along the lines of class (Applicative m) = > Monad m where so that a type has to be an applicative functor first before it can be made a monad? Well, there should, but when Haskell was made, it hadn't occured to people that applicative functors are a good fit for
05:08:37 <hsk8> Haskell so they weren't in there. But rest assured, every monad is an applicative functor, even if the Monad class declaration doesn't say so."
05:08:58 <MP2E> note that that paragraph will be obsolete as of 7.10
05:09:03 <MP2E> Applicative *is* now a superclass of Monad.
05:09:18 <notdan> dbushenko: hm, let's see
05:09:30 <ClaudiusMaximus> https://www.haskell.org/haskellwiki/Functor-Applicative-Monad_Proposal
05:09:35 <MP2E> ^ yes
05:10:02 <hsk8> MP2E: but right now it isn't, so my question is, since he said "But rest assured, every monad is an applicative functor, even if the Monad class declaration doesn't say so."
05:10:08 <hsk8> What makes it an applicative functor?
05:10:11 <hsk8> prior to 7.10
05:10:56 <MP2E> you can implement <*> as 'liftM2 id' and you can implement pure as return
05:11:04 <MP2E> bam, there's your applicative
05:11:15 <notdan> dbushenko: so, you can use Spock, or you can try using cookies with wai-session
05:11:37 <hsk8> ok thx
05:11:49 <dbushenko> notdan, may be you could show an example? I'm really stuck with that
05:11:52 <MP2E> http://www.reddit.com/r/haskell/comments/2lompe/where_do_the_applicative_laws_come_from/clws90h
05:12:03 <MP2E> here's a deeper look on the differences between Applicative and Monad
05:12:22 <hsk8> MP2E: so in practice, it so happens that all the supplied Monads (and all/most 3rd party Monads) are also made instances of Applicative?
05:12:33 <hsk8> MP2E: even though technically they don't need to be?
05:13:12 <MP2E> Yep exactly! In Category Theory, every Monad isn't necessarily an Applicative, but because of some inherent properties of Haskell, every Monad just happens to have a corresponding Applicative instance
05:14:10 <hsk8> Nice, thanks
05:14:23 <MP2E> np :)
05:14:32 <hsk8> When is 7.10 due?
05:14:36 <hsk8> it's only 7.8.x now
05:14:39 <hsk8> in the haskell platform
05:14:53 <notdan> dbushenko: I haven't used sessions in my scotty apps, but I think Spock has a nice implementation of sessions
05:14:56 <MP2E> the branch gets frozen from master in about 2 weeks (little bit less now actually)
05:15:02 <notdan> dbushenko: https://github.com/agrafix/Spock
05:15:02 <MP2E> not sure when it'll actually be released
05:15:10 <MP2E> probably a few months after that
05:15:13 <MP2E> maybe late december? :)
05:15:13 <hsk8> ok
05:15:17 <hsk8> cool
05:15:25 <dbushenko> ok thanks
05:30:49 <vanila> good morning
05:41:15 <hsk8> what is >>= more often called, the bind function, or the shove function?
05:41:25 <hsk8> since it's used to shove a monadic value into a func
05:41:31 <vanila> lol
05:41:33 <hsk8> i like shove
05:41:40 <vanila> it even looks like a shovel
05:41:44 <hsk8> :D
05:42:05 <hsk8> http://adit.io/posts/2013-04-17-functors,_applicatives,_and_monads_in_pictures.html
05:42:09 <hsk8> search "shove"
05:42:27 <hsk8> he also calls it shove here: https://www.youtube.com/watch?v=ZhuHCtR3xq8
05:43:02 <greg_f> hey guys
05:43:50 <vanila> hey
05:44:39 <k00mi> hsk8: bind is more common
05:45:01 <hsk8> ok
05:45:53 <greg_f> I want to split a string something like: split "." "test1.test" => ["test1", "test2"] what is the best choice?
05:49:19 <vanila> greg_f, I don't know about best but I might use readp
05:49:42 <vanila> actually that may not work well, a PEG would be best
05:49:57 <greg_f> Does haskell have a buitin function?
05:49:59 <supki> :t Data.Text.splitOn
05:50:00 <lambdabot> Data.Text.Internal.Text -> Data.Text.Internal.Text -> [Data.Text.Internal.Text]
05:50:38 <greg_f> supki: thanks
05:52:01 <indiagreen> greg_f: if you need it for String, you might also use splitOn from package split, which is in Haskell Platform
06:03:52 <edoardu> !lista
06:03:52 <monochrom> edoardu: http://hackage.haskell.org/packages/archive/pkg-list.html
06:17:28 <NikolajK> is it easy to see that we can know that the only type term of the type (a,b)->(b,a) is the swap function.
06:17:32 <NikolajK> ?
06:18:12 <NikolajK> I see that'll be hard to figure some other term - but how can e.g. a good compiler formally derive that this is the only term. how to get stuff for free?
06:20:58 <wei2912> NikolajK: what do you mean? :P
06:22:21 <wei2912> NikolajK: to figure out if the only function with the type signature (a, b) -> (b, a), we do a search using hoogle
06:22:39 <wei2912> NikolajK: the compiler does not search for all functions with the type signature (a, b) -> (b, a)
06:23:24 <wei2912> also, swap is not guaranteed to be the only function with that type signature.
06:23:30 <wei2912> the compiler will not infer anything like that
06:23:40 <NikolajK> wei2912: yeah, I was using "compiler" very vaguely here, just to mean the bunch of clever algorithms which can compute and compare information derived from the type
06:24:01 <NikolajK> wei2912: okay, apart from undefined it should be, right?
06:24:11 <wei2912> NikolajK: i think you're confused, the compiler doesn't do anything like that
06:24:20 <wei2912> NikolajK: are you asking about how the compiler infers the type of a function?
06:24:25 <NikolajK> no
06:24:30 <NikolajK> forget that I said compiler
06:24:35 <wei2912> alright
06:24:54 <NikolajK> the question is just how the functions of type (a, b) -> (b, a) can be derived
06:25:07 <isBEKaml> is haskell.org down?
06:25:15 <NikolajK> since there are not many and the "theorems for free" things, as I understand, is supposed to do that
06:25:21 <exio4> NikolajK: something like djinn?
06:25:30 <NikolajK> isBEKaml: no
06:25:39 <benzrf> @djinn (a, b) -> (b, a)
06:25:39 <lambdabot> f (a, b) = (b, a)
06:25:45 <vanila> whatd o you mean "of type"?
06:25:53 <benzrf> :t \(a, b) -> (b, a)
06:25:54 <lambdabot> (t1, t) -> (t, t1)
06:25:57 <benzrf> aw
06:25:58 <vanila> (a, b) -> (b, a) could be implement easily by intuitionistic proof search since its a logical tautology
06:26:04 <vanila> djinn does this
06:26:12 <isBEKaml> weird, ping timed out on me
06:26:17 <NikolajK> yeah, is that easy
06:26:25 <benzrf> isup.me/haskell.org
06:26:25 <NikolajK> ?
06:26:45 <vanila> in what respect?
06:26:49 <benzrf> hm... and yet i cannot load it
06:26:51 <benzrf> :|
06:27:00 <isBEKaml> benzrf: exactly
06:27:32 <benzrf> oh i see
06:27:36 <benzrf> cloudflare error page
06:27:42 <benzrf> isup.me registers that as bein up
06:28:17 <isBEKaml> hmm
06:30:11 <McManiaC> general question, i want to keep a connection open and just send (length prefixed) messages over it – using Handle i can just read the first 1-2 bytes for the length and then X bytes to get the next message… can I do the same with a TLS encrypted message or is TLS designed in a way that would make this impossible?  the "tls" library seems to only be able to return a strict bytestring, not a lazy one (which i'd need)
06:30:29 <McManiaC> TLS encrypted connection*
06:39:59 <lericson> why does GHCi list all the loaded modules? seem so strange!
06:40:06 <lericson> *TeslaTrasselTrace Graphics.Plot Numeric.GSL Numeric.LinearAlgebra GP MultiPlot Frame Opts OptsStyle Histogram Graph Plot3D Graph3D Plot2D Graph2D Graphics.Gnuplot.Plot.TwoDimensional LineSpec Numeric.LinearAlgebra.Data>
06:40:10 <lericson> :|
06:40:22 <Fuuzetsu> you can change your prompt
06:40:32 <Fuuzetsu> or import with :m +Module.Name which will stop that
06:41:25 <lericson> istm that :m +M.N does add to the prompt
06:41:32 <lericson> it just seems like an odd default for a REPL
06:42:53 <Fuuzetsu> then something is wrong
06:43:07 <Fuuzetsu> by default if you :load a module you shouldn't be getting everything that loads in prompt
06:43:10 <Fuuzetsu> at least I don't
06:43:19 <lericson> Prelude> :m +System.FilePath
06:43:19 <lericson> Prelude System.FilePath>
06:43:21 <lericson> this is what i mean
06:43:40 <lericson> i think you're referring to the secondary imports implied by my import
06:43:43 <Fuuzetsu> oh wait, it does
06:43:49 <Fuuzetsu> hm, what was the one that didn't…
06:44:44 <Fuuzetsu> anyway I'm wrong about :m +…
06:45:02 <Fuuzetsu> maybe someone else can helpl
06:45:03 <Fuuzetsu> help*
06:45:04 * Fuuzetsu → bed
07:04:25 <roelof> what do I do wrong here  ? (http://lpaste.net/113980)
07:04:44 <nakal> on FreeBSD there seems to be a race condition when forking processes (affects xmonad not reacting to hotkeys). can anyone tell why this happens? It seems that SIGALRM kills the child process for some reason.
07:05:37 * hackagebot keystore 0.7.0.0 - Managing stores of secret things  http://hackage.haskell.org/package/keystore-0.7.0.0 (ChrisDornan)
07:05:54 <nakal> it's documented as a bug in xmonad, but I think it might actually be ghc causing this.
07:07:37 <nakal> more here: https://code.google.com/p/xmonad/issues/detail?id=576
07:22:04 <phaazon> he
07:22:06 <phaazon> hey
07:22:31 <phaazon> I’ve been wondering, I have a constructor in a GADT :
07:22:52 <phaazon> Foo :: a -> a -> G (V2 a)
07:23:12 <roelof> no one who can help me as a beginner ?
07:23:29 <phaazon> when pattern matching this type, I’d like to be able to put a constraint on a (I can on V2 a, but maybe not on a? any idea?)
07:23:32 <phaazon> roelof: ask
07:23:44 <roelof> what do I do wrong here  ? (http://lpaste.net/113980)
07:24:00 <phaazon> roelof: main is a monadic function
07:24:06 <phaazon> its type is IO ()
07:24:19 <zwer> not a function
07:24:21 <roelof> phaazon:  that I know
07:24:29 <phaazon> value, yeah, sorry
07:24:35 <wei2912> @check (\ xs -> reverse xs == xs)
07:24:37 <lambdabot>  +++ OK, passed 100 tests.
07:24:41 <wei2912> any idea why this happens? :P
07:24:53 <phaazon> roelof: then, just print your value :)
07:25:04 <phaazon> main = print (last2 [1,2,3])
07:25:32 <nshepperd> Foo :: (Show a) => a -> a -> G (V2 a)
07:25:37 <nshepperd> does that work?
07:25:49 <nshepperd> well, it obviously won't if V2 is a type family
07:26:05 <phaazon> nshepperd: I don’t want that
07:26:06 <nakal> weird op precedence?
07:26:17 <phaazon> I don’t want to put the constraint in the ctor
07:27:03 <roelof> phaazon:  oke, no more syntax errors but now this error : Non-exhaustive patterns in function last2
07:27:18 <roelof> so I have to use a guarded solution
07:27:23 <roelof> I think
07:27:55 <phaazon> nope
07:28:02 <HeladoDeBrownie> roelof, what is last2 supposed to do?
07:28:10 <phaazon> the issue is that if you pass empty list to last2
07:28:14 <nshepperd> oh, you want 'functionThatMatches :: (Show a) => G (V2 a) -> blah' sort of thing?
07:28:32 <phaazon> you’ll get nothing since you haven’t provided the implementation
07:28:43 <phaazon> nshepperd: hm
07:28:50 <roelof> HeladoDeBrownie:  I try to make the first of 99 haskell problems and I have to find the last item in a list
07:28:51 <HeladoDeBrownie> "nothing" meaning the program crashes
07:29:01 <phaazon> no
07:29:05 <phaazon> it means it doesn’t compile
07:29:13 <phaazon> or does it?
07:29:27 <phaazon> I don’t remember, I always put my ghc not to compile in that case
07:29:40 <phaazon> but in your case roelof
07:29:51 <phaazon> last2 is incorrect
07:30:03 <HeladoDeBrownie> phaazon, a program can compile while there are non-exhaustive cases in it
07:30:04 <phaazon> you have to handle two cases: (x:xs) and []
07:30:08 <roelof> I have to find out how to deal with a empty list
07:30:18 <phaazon> HeladoDeBrownie: I think it’s a shame
07:30:40 <phaazon> roelof: that’s an interesting exercise actually
07:30:42 <HeladoDeBrownie> roelof, seems like using the already-defined last for that goes against the point. Got a link to the problem?
07:30:45 <phaazon> you have two ways to go
07:30:49 <phaazon> go filfthy
07:30:53 <phaazon> and use exceptions
07:30:57 <phaazon> or use dependent type
07:31:04 <phaazon> last2 :: [a] -> Maybe a
07:31:06 <roelof> phaazon:  yep, a empty list [] has no  answers and (x:xs) has
07:31:09 <HeladoDeBrownie> Never mind, found it
07:31:15 <phaazon> roelof: with my last2 it has
07:32:30 <phaazon> @let last2 :: [a] -> Maybe a; last2 [] = Nothing; last2 (x:[]) = Just x; last2 (_:xs) = last2 xs
07:32:31 <lambdabot>  Defined.
07:32:38 <roelof> phaazon:  or use pattern matching
07:32:40 <phaazon> > last2 [1,2,3,243]
07:32:42 <lambdabot>  Just 243
07:32:45 <phaazon> > last2 []
07:32:47 <lambdabot>  Nothing
07:33:06 <nakal> @check (\ xs -> (reverse xs) == xs)
07:33:08 <lambdabot>  +++ OK, passed 100 tests.
07:34:34 <wei2912> nakal: :P
07:34:34 <adamse> _t reverse
07:34:38 <adamse> :t reverse
07:34:38 <wei2912> :t reverse
07:34:39 <lambdabot> [a] -> [a]
07:34:39 <lambdabot> [a] -> [a]
07:34:43 <roelof> phaazon:  can pattern matching do the job like this example :  http://lpaste.net/113983
07:35:09 <zwer> @check (\xs -> null xs || head xs == ())
07:35:11 <lambdabot>  +++ OK, passed 100 tests.
07:35:26 <HeladoDeBrownie> roelof, that looks like a fine implementation for a function of that type
07:35:33 <HeladoDeBrownie> (However the type is somewhat objectionable :P)
07:35:45 <phaazon> roelof: looks okay but the type is, to me, wrong
07:35:47 <zwer> I think it creates a list of () by default. not that this proved it
07:35:50 <phaazon> Prelude is not really safe ;)
07:35:52 <wei2912> yeh, it does
07:36:10 <zwer> @check (\xs -> null xs || head xs == 1)
07:36:11 <lambdabot>  *** Failed! Falsifiable (after 6 tests and 2 shrinks):
07:36:11 <lambdabot>  [0]
07:36:14 <wei2912> since only () can satisfy the type ()
07:36:27 <phaazon> > tail []
07:36:28 <lambdabot>  *Exception: Prelude.tail: empty list
07:36:36 <roelof> phaazon:  oke, thanks, I have to read about maybe in that book to understand what it does
07:36:55 <phaazon> roelof: it’s really simple, it’s a list restricted :)
07:37:16 <phaazon> data List a = [] | Cons x (List a)
07:37:21 <joneshf-laptop> has there been any work to annotate the "missing" type variables in type classes?
07:37:21 <phaazon> data Maybe a = Nothing | Just x
07:37:25 <joneshf-laptop> or would that even work?
07:37:27 * wei2912 wonders why people don't recommend the Haskell wikibook often
07:37:34 <wei2912> reading through it, it seems really clear
07:37:40 <joneshf-laptop> i'm looking at the (->) instance for Contravariant
07:37:45 <joneshf-laptop> you have to newtype wrap it
07:38:00 <phaazon> ((->) r)  you mean
07:38:00 <joneshf-laptop> because the type variables are backwards for the instance
07:38:09 <joneshf-laptop> phaazon, sorry, yes
07:38:25 <phaazon> @src (->) contramap
07:38:25 <lambdabot> Source not found. BOB says:  You seem to have forgotten your passwd, enter another!
07:38:40 <phaazon> well I guess it’s (. f) or something like that
07:39:08 <joneshf-laptop> some kind of syntax like: instance Contravariant ({e} -> a) where ...
07:39:20 <joneshf-laptop> so you're saying which one is being parameterized over
07:39:41 <joneshf-laptop> or would this just lead to ambiguity?
07:39:46 <phaazon> yeah it would
07:40:10 <phaazon> it would make you able to write several instances for a same tye
07:40:12 <phaazon> type*
07:40:22 <phaazon> and the compiler wouldn’t know which one to pick
07:40:39 * hackagebot hspec-meta 2.0.0 - A version of Hspec which is used to test Hspec itself  http://hackage.haskell.org/package/hspec-meta-2.0.0 (SimonHengel)
07:40:41 <phaazon> (i.e. you could have {a} -> b and a -> {b})
07:40:42 <HeladoDeBrownie> Isn't that already a problem when you have multiple instances in scope?
07:40:47 <HeladoDeBrownie> (or *would* have)
07:40:59 <phaazon> it is, but I think orphan instances are rare
07:41:11 <phaazon> even though they do exist
07:41:16 <HeladoDeBrownie> So in other words this creates more *stylistic* ambiguity than existed before
07:41:40 <joneshf-laptop> hmm, i guess it gets worse with mptcs as well
07:41:51 <joneshf-laptop> well that was a short excursion
07:42:18 <HeladoDeBrownie> Back to newtypes then I suppose
07:43:15 <phaazon> :)
07:43:29 <roelof> phaazon:  oke, I changed it to http://lpaste.net/113985 but when I do print(last2 []) I see a error message
07:44:27 <phaazon> you have a ;
07:44:37 <phaazon> furthermore
07:45:03 <phaazon> you should put main :: IO ()
07:47:45 <phaazon> edwardk: imagine I have an instance: instance (GLSL a) => GLSL (V2 a) where… ; is there a way to to infer (GLSL a) using (GLSL (V2 a)) in any possible way? my GLSL compiler is like : compile :: (GLSL a) => E b f a -> Either CompileError String, and V2 :: E b f a -> E b f a -> E b f (V2 a)
07:52:26 <roelof> phaazon:  still when I do main = do print(last2 []) I see this error message : No instance for (Show a0) arising from a use of print
07:52:54 <roelof> phaazon:  The type variable a0 is ambiguous
07:52:56 <osa1> do we have any libs for reading Word16/32/36s from big-endian byte strings? (e.g. it should convert endianness if necessary)
07:54:18 <phaazon> roelof: that’s normal
07:54:28 <phaazon> try with
07:54:38 <phaazon> main = print $ last2 ([] :: [Int])
07:55:24 <Polarina> osa1, binary and cereal
07:55:52 <roelof> phaazon:  last question what does the $ mean.
07:56:08 <phaazon> roelof: it’s a function application
07:56:15 <phaazon> it’s a redundant operator
07:56:20 <phaazon> f $ b = f b
07:56:35 <phaazon> but it has a very low precedence
07:56:44 <phaazon> so that you can use other operators and emulate parens
07:57:45 <roelof> oke, one last problem with this solution . It's working only with int. When I do last2 ["a", "b"] it fails
07:57:56 <roelof> so type a is not well
08:01:23 <roelof> phaazon:  found it. This does the trick : main = print $ last2 (["a","b","c"] )
08:03:22 <phaazon> ["a","b"] == "ab"
08:03:28 <phaazon> got to go, see you
08:03:45 <indiagreen> phaazon: you meant ['a','b']
08:04:15 <recursion-ninja> Hey guys, which cryto packages would be best to use for encrypting a file with CBC AES? Some seem to have a nice API with typeclass abstractions but no CBC mode option, others seem to offer various encryption modes but don't appear to have decent abstractions... Have any of you had success with a crypto package?
08:04:23 <indiagreen> roelof: you don't need parens around the list
08:06:23 <roelof> indiagreen:  parens around a list ???
08:08:08 <indiagreen> “last2 (["a","b","c"])”
08:08:31 <indiagreen> just “last2 ["a","b","c"]” is fine
08:09:00 <roelof> indiagreen:  oke, thanks for the remarks
08:10:09 <roelof> everyone thanks. tomorrow I will try to do the next assignment of 99 haskell problems. Finding the item before the last item
08:10:44 <roelof> Can I use a sort of or then like [] or [x] ?
08:12:09 <roelof> and try some test frameworks
08:13:27 <dramforever> let slowThing = last . init in slowThing [1,2,3,4,5]
08:13:33 <dramforever> > let slowThing = last . init in slowThing [1,2,3,4,5]
08:13:34 <lambdabot>  4
08:13:57 <dramforever> oops, sorry
08:14:04 <HeladoDeBrownie> roelof, yes, you can even write [x, y] to match a list of length two
08:14:17 <dramforever> sorry for trying that out
08:14:23 <HeladoDeBrownie> roelof, or equivalently, (x:y:[])
08:14:44 <dramforever> [x, y] is equivalent to (x:y:[]) in both patterns and expressions
08:15:01 <dramforever> let [a,b,3,4,c] = [1,2,3,4,5] in (a,b,c)
08:15:03 <dramforever> > let [a,b,3,4,c] = [1,2,3,4,5] in (a,b,c)
08:15:05 <lambdabot>  (1,2,5)
08:17:23 <roelof> Again thanks all and have a good evening
08:33:37 <hsk8> Someone here has the paper LYAH?
08:33:46 <hsk8> and has read about monads?
08:34:34 <HeladoDeBrownie> hsk8, it's available for reading online as well, in case you weren't aware
08:34:36 <HeladoDeBrownie> @where lyah
08:34:36 <lambdabot> http://www.learnyouahaskell.com/
08:34:41 <HeladoDeBrownie> hsk8, did you have a question about Monad?
08:35:05 <hsk8> Yeah a question
08:35:22 <hsk8> Ok I'll refer to the online one
08:38:34 <hsk8> Is one fundamental difference between this:
08:38:35 <hsk8> return (0,0) >>= landLeft 1 >>= landRight 4 >>= landLeft (-1) >>= landRight (-2)
08:38:36 <hsk8> and the routine function that starts with this:
08:38:37 <hsk8> routine = case landLeft 1 (0,0) of
08:38:38 <hsk8> that the latter stops at Nothing, but the >>= chain doesn't stop at Nothing?
08:38:49 <hsk8> just search for those things, and the website will take you to it:
08:38:53 <hsk8> http://learnyouahaskell.com/a-fistful-of-monads
08:39:00 <HeladoDeBrownie> I'm not sure how to compare those two pieces of code, especially since one is a complete expression and the other is not
08:39:19 <hsk8> HeladoDeBrownie: yeah the latter is just the beginning of that func. didn't wanna paste it all
08:39:34 <HeladoDeBrownie> Ah, I see
08:40:09 <HeladoDeBrownie> Well if you're using the (>>=) defined over Maybe then you will indeed end up with Nothing if the left side is Nothing
08:40:11 <k00mi> hsk8: no, their behaviour is equivalent
08:40:14 <HeladoDeBrownie> So in that sense it does short cuircuit
08:40:38 <HeladoDeBrownie> The two things written in LYAH are equivalent, as the text implies
08:40:41 * hackagebot github-types 0.1.0.5 - Type definitions for objects used by the GitHub v3 API  http://hackage.haskell.org/package/github-types-0.1.0.5 (wereHamster)
08:40:52 <HeladoDeBrownie> In fact, if you expand the definition of (>>=) for Maybe, you will get something like the routine defined there
08:41:31 <hsk8> HeladoDeBrownie, k00mi, are you sure? The result will the same for sure. But it seems to me that >>= doesn't stop at Nothing. It will still have to go through all the other >>= (and become Nothing) all the way through.
08:41:44 <hsk8> so the Nothing will have to pass through all the >>=
08:41:47 <hsk8> it seems to me
08:41:55 <HeladoDeBrownie> hsk8, nope, it doesn't have to compute anything it doesn't use. That's part of the nature of lazy evaluation.
08:41:59 <dramforever> not really
08:42:07 <dramforever> > Nothing >>= undefined
08:42:08 <lambdabot>  Nothing
08:42:11 <k00mi> hsk8: "Nothing >>= f" does not evaluate f
08:42:15 <dramforever> see, it short circuits
08:42:33 <HeladoDeBrownie> If Nothing >>= undefined had not short circuited, evaluating undefined would have led to an error
08:42:33 <dramforever> > Just 2 >>= undefined
08:42:35 <lambdabot>  *Exception: Prelude.undefined
08:42:49 <dramforever> this one "long circuited"
08:45:03 <hsk8> But this is how it's defined:
08:45:04 <hsk8> Nothing >>= f = Nothing
08:45:06 <greymalkin> Can I get some feedback on my first Monad ever? http://pastebin.com/nL79EB39
08:45:15 <hsk8> So let's say we have: Nothing >>= func1 >>= func2
08:45:29 <hsk8> First, Nothing >>= func1 will give me Nothing
08:45:47 <hsk8> But how does the thing short-circuit there? It seems to me that Nothing >>= func2 would still have to compute
08:45:55 <hsk8> resulting in Nothing again
08:45:58 <hsk8> but it still computes
08:45:59 <hsk8> right?
08:46:13 <greymalkin> hsk8: The (>>=) function computes, yes
08:46:26 <dramforever> hmm...
08:46:27 <greymalkin> But func1 and func2 never compute
08:46:43 <hsk8> I know but >>= computes
08:46:55 <hsk8> so how can it be equivalen to the case stuff?
08:46:57 <hsk8> i don't see it
08:47:03 <hsk8> I see that it will always give the same result
08:47:08 <hsk8> but it computes differently it seems to me
08:47:15 <hsk8> the case short circuits at nothing
08:47:18 <hsk8> but >>= doesn't
08:47:21 <k00mi> greymalkin: did you check if the monad laws hold for that?
08:47:23 <HeladoDeBrownie> How are your notions of "equivalent" and "giving the same result" different?
08:47:34 <HeladoDeBrownie> To me, giving the same result *is* equivalence
08:47:40 <dramforever> well...
08:48:00 <dramforever> hmmm...
08:48:01 <hsk8> HeladoDeBrownie: well isn't short circuiting at Nothing faster than having to go through a zillion Nothings (a zillion >>=)
08:48:02 <greymalkin> k00mi: It compiles (a warning about not being an Applicative) -- it feels like a derrivation of the Maybe monad.
08:48:15 <HeladoDeBrownie> hsk8, if it's speed you care about, try benchmarking
08:48:28 <dramforever> greymalkin: you'd better add an instance for Applicative
08:48:30 <hsk8> that's not the point here...
08:48:56 <dramforever> otherwise it going to fail in ghc 7.10
08:48:58 <k00mi> greymalkin: compiling does not mean the laws hold, but indeed it is exactly Maybe with different names
08:49:50 <dramforever> greymalkin: do equation reasoning. unleash the algebra you learnt in school
08:50:32 <dramforever> and prove that the laws hold
08:51:35 <HeladoDeBrownie> hsk8, also, I'm not guaranteeing the compiler will always do this, but a >>= b >>= c = (a >>= b) >>= c = a >>= (b >>= c), so an optimization could avoid evaluating most of the (>>=)
08:51:46 <HeladoDeBrownie> hsk8, in reality I know little of what optimizations GHC applies and when
08:51:52 <HeladoDeBrownie> Others in here may know
08:53:20 <hsk8> okay
08:53:20 <k00mi> HeladoDeBrownie: that equivalence doesn't even typecheck
08:53:34 <HeladoDeBrownie> k00mi, sorry, you're right
08:53:37 <HeladoDeBrownie> I was thinking of (>>)
08:53:52 <HeladoDeBrownie> hsk8, ignore that then
08:53:58 <dramforever> hsk8: don't
08:54:09 <dramforever>  m >>= (\x -> k x >>= h)  ==  (m >>= k) >>= h
08:54:27 <dramforever> specifically, you want a rewrite from the right side to the left
08:54:31 <HeladoDeBrownie> Yes, that's basically what I was trying to get at
08:55:05 <hsk8> yeah that first thing is basically the do notation isn't it?
08:55:23 <HeladoDeBrownie> (I find it easier to think about (>=>), too bad that's not a method :P)
08:55:30 <dramforever> hsk8: yep
08:55:41 * hackagebot yesod-core 1.4.3.1 - Creation of type-safe, RESTful web applications.  http://hackage.haskell.org/package/yesod-core-1.4.3.1 (MichaelSnoyman)
08:56:04 <dramforever> I think that monad law is equivlant to: a >=> (b >=> c) = (a >=> b) >=> c
08:56:12 <hsk8> dramforever: that first dude obviously shortcircuits at Nothing, doesn't it? Even if we chain many of them. But the short circuiting is not obvious from the second form, is it?
08:56:27 <dramforever> let me see...
08:56:30 <hsk8> so short circuiting results essentially from MONAD LAWS.
08:56:30 <dramforever> wait a min
08:56:32 <hsk8> doesn't it
08:56:48 <hsk8> the compiler may be able to use the fact that it's a MONAD to optimize the >>= chain
08:56:56 <dramforever> what does "do { x <- a; b; y <- c; d }" translate into?
08:57:05 <HeladoDeBrownie> hsk8, right, that's exactly the sort of thing we're talking about. It can use the Monad laws
08:57:10 <hsk8> cool
08:57:15 <Iceland_jack> @undo do { x <- a; b; y <- c; d }
08:57:15 <lambdabot> a >>= \ x -> b >> c >>= \ y -> d
08:57:18 <greymalkin> dramforever: MonadBool appears to follow the monad laws.
08:57:28 <dramforever> hsk8: ha!
08:57:38 <dramforever> although >>= is infixl 1
08:57:39 <indiagreen> I think it was asked somewhere whether GHC relies on monad laws anywhere and the answer was that it doesn't
08:58:02 <HeladoDeBrownie> indiagreen, we can write rewrite rules based on them
08:58:20 <dramforever> hsk8: do notation uses it like right-associative
08:58:27 <hsk8> yes
08:58:28 <dramforever> hsk8: It does short circuit
08:58:32 <hsk8> So my question is basically this:
08:58:56 <dramforever> do short circuits, a >>= b >>= c >>= d... does not
08:59:25 <hsk8> Could
08:59:26 <hsk8> Nothing >>= func1 >>= func2 >>= func3
08:59:27 <hsk8> be faster than
08:59:27 <hsk8> Nothing >>= func1 >>= func2 >>= func3 >>= ... >>= func99999999
08:59:35 <hsk8> (because of no short circuits)
08:59:41 <hsk8> that's what i'm wondering about
08:59:47 <HeladoDeBrownie> Hmm, well (>>=) left-associates, so I think so
09:00:03 <dramforever> > foldl Nothing (>>=) (replicate 10 return)
09:00:04 <lambdabot>  Couldn't match expected type ‘(m a -> (a -> m b) -> m b)
09:00:04 <lambdabot>                                -> (a1 -> m0 a1) -> m a -> (a -> m b) -> m b’
09:00:04 <lambdabot>              with actual type ‘Data.Maybe.Maybe a0’
09:00:24 <dramforever> > foldl (>>=) Nothing (replicate 10 return)
09:00:26 <lambdabot>  Nothing
09:00:29 <dramforever> > foldl (>>=) Nothing (replicate 100 return)
09:00:31 <lambdabot>  Nothing
09:00:31 <HeladoDeBrownie> Or, duh, I'm still thinking of (>>) -_- (>>=) would *have* to left-associate
09:00:35 <dramforever> > foldl (>>=) Nothing (replicate 1000 return)
09:00:37 <lambdabot>  Nothing
09:00:42 <dramforever> > foldl (>>=) Nothing (replicate 10000 return)
09:00:44 <lambdabot>  Nothing
09:00:53 <dramforever> huh? no significant delay?
09:00:58 <indiagreen> HeladoDeBrownie: we can, but at least in 2011 dons said that GHC doesn't make assumptions about the laws (http://stackoverflow.com/a/6399711/615030)
09:01:11 <HeladoDeBrownie> indiagreen, my mistake. Why can't we?
09:01:28 <hsk8> dramforever: strange..
09:01:34 <dramforever> no
09:01:39 <dramforever> 10000 is just too small
09:01:47 <k00mi> hsk8: there is nothing that will guarantee you short-circuiting will happen, but that said, I just did a small trivial test and the core was optimized to short-circuit
09:02:00 <nshepperd> it's probably good that ghc doesn't try to use the monad laws
09:02:18 <HeladoDeBrownie> indiagreen, never mind, I misread as "we can't"
09:02:26 <nshepperd> because what is efficient depends on the specific data structure you are trying to compose
09:02:30 <hsk8> k00mi: but how would it short circuit...
09:02:30 <dramforever> it turns out that at least in ghci foldl (>>=) Nothing (repeat return) seems to keep running forever
09:02:39 <hsk8> heh
09:04:21 <dramforever> compiling that with -O2 doesn't make it terminate either
09:04:30 <dramforever> but, consider this
09:04:38 <hsk8> did you try million, ten million, or hundred million repetitions?
09:04:49 <dramforever> repeat == infinite repetitions
09:05:05 <HeladoDeBrownie> I think k00mi's test was probably better than checking tons of repetitions
09:05:19 <HeladoDeBrownie> i.e., check the core
09:05:19 <dramforever> k00mi: how?
09:05:24 <dramforever> what did you do?
09:05:55 <dramforever> I typed "main = print $ foldl (>>=) Nothing (repeat return)" into a file and compiled with -O2
09:06:07 <dramforever> no use. still seems to loop forever
09:06:44 <k00mi> I read a number from stdin and did a couple of tests on it, then printed the result
09:07:13 <k00mi> it's trivial and likely says nothing about more complex examples
09:08:05 <k00mi> the result was that if one expression evaluated to Nothing, that was printed directly
09:08:21 <dramforever> maybe foldl is the problem
09:08:34 <k00mi> indeed, foldl can't short-circuit
09:11:22 <k00mi> looking at the core is really the only way to be sure, anything else is just speculation
09:12:32 <dramforever> How can I make ghc annotate less? I think there's a flag for that
09:12:39 <dramforever> the core is just too verbose
09:12:40 <greymalkin> k00mi: How does one "look at the core"?
09:13:01 <dramforever> greymalkin: compile with flag -ddump-simpl
09:13:11 <dramforever> maybe touch source file first
09:13:18 <indiagreen> greymalkin: or use the ghc-core tool from hackage
09:13:24 <dramforever> because ghc will not recompile just because of that
09:14:13 <k00mi> dramforever: I don't know the flags, I use ghc-core
09:14:23 <greymalkin> By the way, is there a simple command-line way to get documentation of a function?
09:17:29 <greymalkin> I'm getting tired of the round trip to google just to check what module functions are in (like getArgs -- which I use occasionally, but not enough to always remember where it lives)
09:17:42 <dramforever> hackage.haskell.org
09:17:46 <dramforever> saves a bit of time
09:17:55 <dramforever> and http://haskell.org/hoogle
09:18:10 <dramforever> saves time finding funcs
09:18:20 <indiagreen> greymalkin: having added a search shortcut in browser for hoogle/hayoo saves me a ton of time
09:21:33 <hsk8> dramforever: https://pastee.org/pfvrh
09:21:33 <hsk8> passToBoom 1000000 Nothing takes a while
09:21:34 <hsk8> passToBoom 10000000 Nothing takes much longer (around 10 times longer i guess, didn't measure it)
09:21:44 <hsk8> i just ran it in GHCi though
09:21:56 <chirpsalot> greymalkin: you can add hoogle to ghci.
09:22:16 <chirpsalot> https://www.haskell.org/haskellwiki/Hoogle#GHCi_Integration
09:24:52 <benzrf> hsk8: sounds linear
09:24:54 <benzrf> good fr u
09:27:00 <hsk8> dramforever: it runs much faster compiled with O2, but it's still doesn't short circuit. increasing that number increaes the time taken
09:27:13 <hsk8> so interesting. it's not able to apply monad laws to optimize it further
09:27:43 <hsk8> the Nothing passes through as Nothing a gazillion times, and that takes time
09:28:50 <StoneToad> hsk8: ghci doesnt do any optimization does it?
09:29:39 <hsk8> no, that's why i tried compiling it too
09:29:45 <hsk8> with ghc
09:30:52 <StoneToad> greymalkin: note that the first step of chirpsalot's link is installing a hoogle cmdline interface, I think that is actually an exact answer to your question
09:31:24 <greymalkin> Yeah, I'm installing it now :)
09:31:51 * StoneToad is also installing it :D
09:32:32 <StoneToad> how do I find out if I'm in a directory setup as a cabal sandbox?
09:32:55 <k00mi> hsk8: that's nowhere close to "m >>= f >>= g >>= ..." though
09:33:04 <StoneToad> oh, nm, I'm guessing this cabal.sandbox.config file is a smoking gun
09:33:08 <greymalkin> ls -a | grep .cabal-sandbox
09:33:15 <hsk8> k00mi: that's what it does doesn't it?
09:33:19 <StoneToad> yea, I also have that directory as I'm noticing it now
09:33:31 <hsk8> k00mi: i'm passing Nothing through the >>=
09:34:53 <k00mi> hsk8: in real code you often have a fixed number of binds, which is much easier to optimize than a fold
09:35:17 <k00mi> and you're code does much more than just chain >>=
09:35:33 <hsk8> okay
09:35:40 <hsk8> fuck this. i'll stop worrying for now :D
09:35:47 <hsk8> just continue reading lyah
09:36:37 <k00mi> hsk8: like I said before, if you ever are in a situation where you really care, look at the optimized core (GHC's intermediate representation)
09:38:19 <hsk8> okay
09:40:14 <hsk8> k00mi: can you elaborate on what the optimized core is?
09:41:39 <k00mi> hsk8: ghc translates your code into a simpler intermediate representation called "core"
09:41:55 <kwstas> hello there! Is there a more idiomatic way to write an expression like: \x -> x >= 0 && x <max? I tried to use applicatives and I ended up to this: \x -> and $ [(>=0), (<max)] <*> pure x, which I think it's way too complicated to use and understand after a week or so :D
09:42:04 <hsk8> k00mi: which is also Haskell code?
09:42:24 <k00mi> hsk8: most of the high-level optimizations are done on this representation, so by telling ghc to show the result to you you can see what optimizations were applied
09:42:56 <k00mi> hsk8: no, it's not haskell, it's much simpler but has lots of annotations and so on
09:43:04 <hsk8> interesting
09:43:07 <hsk8> ok, i'll keep that in mind
09:43:08 <hsk8> thanks
09:43:49 <k00mi> hsk8: the ghc-core tool on hackage removes some of the annotations and generally makes things easier to read
09:44:00 <hsk8> ok
09:44:05 <hsk8> good to know
09:49:58 <HeladoDeBrownie> kwstas, liftA (&&) (>= 0) (< max)
09:50:28 <HeladoDeBrownie> kwstas, s/liftA/fmap/, rather
09:50:31 <HeladoDeBrownie> Either will work
09:50:53 <HeladoDeBrownie> Wait I wrote that wrong
09:51:03 <HeladoDeBrownie> Oh duh
09:51:06 <HeladoDeBrownie> liftA2*
09:51:12 <lericson> is there anything like python's pydoc for haskell? i notice there is an HTML documentation index
09:51:18 <HeladoDeBrownie> kwstas, liftA2 (&&) (>= 0) (< 10)
09:51:26 <HeladoDeBrownie> I had a major brainfart in the middle of trying to impart that answer :P
09:52:11 <HeladoDeBrownie> lericson, I don't know what pydoc is, but there's Haddock
09:52:20 <kwstas> HeladoDeBrownie: Haha! thanks a lot!!! perfect!
09:53:01 <lericson> HeladoDeBrownie: basically /bin/man for python
09:53:09 <HeladoDeBrownie> kwstas, although your original with the lambda is okay as well
09:53:52 <kwstas> HeladoDeBrownie: yeah I know it was right, but your is elegant too ;)
09:54:00 <kwstas> *yours
09:57:28 <hooplahoops> Hey guys, is the identity function strict in its first argument? Clearly f(⊥) = ⊥, but I don't expect it to evaluate the result
09:58:17 <hooplahoops> So if we discarded the result, we wouldn't loop. But if we translated to call-by-value, it would loop?
10:00:44 * hackagebot rethinkdb-client-driver 0.0.4 - Client driver for RethinkDB  http://hackage.haskell.org/package/rethinkdb-client-driver-0.0.4 (wereHamster)
10:07:34 <HeladoDeBrownie> hooplahoops, id ⊥ = ⊥ is what it means to be strict, so yes.
10:08:35 <HeladoDeBrownie> hooplahoops, whenever id ⊥ gets evaluated, ⊥ gets evaluated. Of course, you can avoid evaluating ⊥ by avoiding evaluating id ⊥.
10:10:00 <hooplahoops> HeladoDeBrownie: yeah that makes sense. I was thinking about 'let x = f(⊥) in e' (not using 'x' in 'e'), but I suppose let bindings themselves are lazy
10:10:05 <hooplahoops> Thanks!
10:10:25 <HeladoDeBrownie> hooplahoops, that's correct.
10:10:39 <zwer> > let x = id undefined in 1
10:10:41 <lambdabot>  1
10:10:52 <zwer> you can force evaluation with seq, though
10:11:02 <zwer> > let x = id undefined in seq x 1
10:11:04 <lambdabot>  *Exception: Prelude.undefined
10:11:15 <hooplahoops> Right, cool :)
10:12:12 <HeladoDeBrownie> Doesn't seq not actually force evaluation? Sure, seq ⊥ x = ⊥, but it could evaluate x first, have that turn out to be ⊥, and then not bother evaluating the other parameter.
10:12:48 <zwer> seq x y = y
10:13:13 <zwer> while also evaluating x
10:13:20 <zwer> (when y is evaluated)
10:13:23 <HeladoDeBrownie> That doesn't sound right. Here, I'll look it up.
10:13:32 <zwer> > seq 1 2
10:13:34 <lambdabot>  2
10:13:40 <zwer> > seq undefined 2
10:13:42 <lambdabot>  *Exception: Prelude.undefined
10:13:48 <HeladoDeBrownie> Hmm, well this says that the first argument does get evaluated. http://hackage.haskell.org/package/base-4.7.0.1/docs/Prelude.html#v:seq
10:14:54 <HeladoDeBrownie> Although that might just be what that particular implementation does. The Report, I think, doesn't give as strong guarantees. I'll check that then.
10:15:16 <HeladoDeBrownie> https://www.haskell.org/onlinereport/haskell2010/haskellch6.html#x13-1260006.2
10:16:02 <HeladoDeBrownie> So then an implementation of seq applied as (seq a b) could perfectly well evaluate b first, discover it's ⊥, then skip evaluating a.
10:19:12 <saep> > seq (error "foo") (error "bar")
10:19:13 <lambdabot>  *Exception: foo
10:19:16 <HeladoDeBrownie> This seems to expound further: https://www.haskell.org/haskellwiki/Seq
10:19:19 <zwer> the evaluation of first argument is still forced, is it not?
10:19:33 <joshy> why is haskell slower at reading files thab python? i did not expect that
10:19:34 <HeladoDeBrownie> zwer, not according to the semantics presented in the Report. GHC's may very well do that every time though.
10:20:13 <HeladoDeBrownie> zwer, imagine you have costlyErroneousComputation and cheapErroneousComputation and you write: seq costlyErroneousComputation cheapErroneousComputation
10:20:40 <HeladoDeBrownie> The implementation of seq could decide to evaluate the cheap one first (not that it would necessarily know it's cheap), get bottom, and then just return bottom because it would've been bottom anyway
10:22:19 <HeladoDeBrownie> According to the above linked article, it's somewhat unusual not to simply evaluate the first argument first, but the Report does allow for it
10:23:34 <SvenskFisk> Hey guys, I'm having a lot of trouble trying to get a recursive function to work. I'm working on implementing Go (the game) in Haskell, but I can't seem to figure out how to write the function that finds the strings (groups of connected stones) on the board. What I have works if the stones are connected in a line or l-shape, but if they're in a square formation I start to get duplicates, and if it's a
10:23:40 <SvenskFisk> 3x3 square it just runs forever (or maybe just for a very long time, haven't left it that long though). The full source code is here ( http://lpaste.net/113992 ) if anyone wants to help out. The problem as far as I can tell is that the function will reach the same square by two different paths, ex. (1,1) -> (2,1) -> (2,2), and (1,1) -> (1,2) -> (2,2), so (2,2) gets counted twice, any help would be much
10:23:46 <SvenskFisk>  appreciated, sorry for the wall of text
10:25:52 <joshy> is it normal  that haskell is slower at reading a file than python?
10:26:08 <indiagreen> joshy: how are you reading it?
10:26:20 <joshy> readFile
10:26:30 <indiagreen> and what are you doing later with it?
10:27:22 <joshy> reversing all the lines, then printing them
10:28:33 <v> @pl length . filter ((==1). fst)
10:28:33 <lambdabot> length . filter ((1 ==) . fst)
10:29:39 <v> f x =length . filter ((x ==) . fst)
10:29:42 <v> @pl f x =length . filter ((x ==) . fst)
10:29:42 <lambdabot> f = (length .) . filter . (. fst) . (==)
10:31:02 <indiagreen> joshy: https://www.haskell.org/haskellwiki/Performance/Strings
10:31:53 <indiagreen> I think you would get much better performance if you either use Text instead of String, or conduit/pipes instead of lazy IO
10:32:01 <indiagreen> but I have to check
10:36:53 <joshy> but am i not using string like i should, where it is basically translated to a loop
10:37:44 <dfeuer_> Anyone want to talk about the "until" function?
10:42:18 <zwer> what version of python?
10:43:02 <recursion-ninja> Hey guys, which cryto packages would be best to use for encrypting a file with CBC AES? Some seem to have a nice API with typeclass abstractions but no CBC mode option, others seem to offer various encryption modes but don't appear to have decent abstractions... Have any of you had success with a crypto package?
10:45:33 <fds4345> Is there an identity lens in `lens` ?
10:45:37 <zwer> IIRC python 2.x will read a file as a sequence of bytes unless specified otherwise, so that is not really a fair comparison.
10:45:38 <edwardk> id
10:45:47 <edwardk> > 5^.id
10:45:49 <lambdabot>  5
10:45:59 <supki> recursion-ninja: i'd use cipher-aes
10:46:30 <edwardk> it acts as an identity prism, iso, lens, traversal, setter, getter, fold, equality ...
10:46:52 <dfeuer_> edwardk, do you think there's any strictness analysis advantage to redefining `until` to make it explicitly strict in its third argument?
10:47:07 <dfeuer_> It's already strict, but I don't know if GHC knows that.
10:47:08 <edwardk> :t until
10:47:09 <lambdabot> (a -> Bool) -> (a -> a) -> a -> a
10:47:31 <dfeuer_> The change could replace infinite loops with exceptions.
10:47:35 <edwardk> heh, i've never actually used it
10:47:41 <dfeuer_> But I believe otherwise preserves semantics.
10:47:50 <edwardk> TIL it existed ;)
10:47:59 <dfeuer_> TIL?
10:48:04 <edwardk> today i learned
10:48:07 <dfeuer_> Ah.
10:48:16 <dfeuer_> It's actually in GHC.Base, of all places.
10:48:28 <edwardk> interesting
10:48:38 <edwardk> you'd need to sound out wider than just me to get an answer on that
10:48:43 <edwardk> what you said sounds plausible at least
10:48:53 <dfeuer_> What list should I ask on?
10:49:24 <Cale> dfeuer_: Why wouldn't GHC know?
10:49:46 <dfeuer_> Cale, it might; but I don't know if it would. It's a bit of a weird situation.
10:50:08 * dfeuer_ goes to try asking GHC....
10:50:22 <dfeuer_> I don't know why I didn't think of that before.
10:50:34 <Cale> @src until
10:50:34 <lambdabot> until p f x | p x       = x
10:50:34 <lambdabot>             | otherwise = until p f (f x)
10:50:45 * hackagebot gitson 0.4.1 - A document store library for Git + JSON.  http://hackage.haskell.org/package/gitson-0.4.1 (myfreeweb)
10:51:02 <dfeuer_> (That source isn't actually the same as GHC has, but it may be close enough)
10:51:32 <Cale> Actually, that's a bit funny. It might not be strict in the third argument.
10:51:58 <dfeuer_> Cale, it may not ever force its third argument, but if it doesn't, it loops forever.
10:52:20 <dfeuer_> So I don't know the technical term for that. "Might as well be strict in it"?
10:52:33 <Cale> oh, perhaps it really is strict, that's interesting
10:52:49 <Cale> A function is strict if f _|_ = _|_
10:52:59 <dfeuer_> Ah. Yes, then it is.
10:53:10 <dfeuer_> Let's see if I can get GHC to tell me if it recognizes that.
10:54:40 <Cale> (e.g. id is strict even though it doesn't case on its argument)
10:54:50 <dfeuer_> Cale, the strictness analysis info comes out different, but I don't really know how to read it.
10:54:53 <edwardk> > until (const True) succ undefined
10:54:55 <lambdabot>  *Exception: Prelude.undefined
10:55:11 <edwardk> > until (const False) succ undefined
10:55:16 <lambdabot>  mueval: ExitFailure 1
10:55:27 <edwardk> so the only difference is you get the different bottom
10:55:39 <dfeuer_> Yes.
10:56:04 <dfeuer_> A *better* bottom, in that case.
10:57:48 <dfeuer_> The question remains of whether letting GHC know this actually helps its analysis in any real situation.
11:05:07 <fds4345> edwardk: thx
11:08:31 <recursion-ninja> supki: Thanks for your input, I think cipher-aes will work nicely
11:09:35 <edwardk> dfeuer_: is until being used in any serious situations?
11:09:50 <edwardk> dfeuer_: anyways, it strikes me as an improvement, shoot the libraries list, i'd say +1
11:10:01 <dfeuer_> edwardk, I have no idea. There are two ways to make the change.
11:11:27 <dfeuer_> Changing go gives what looks like more precise analysis, but I think could lead to double-forcing; changing the outer function gives less precise analysis, but won't double-force more than one thing evr.
11:11:33 <indiagreen> joshy: okay, I made a file consisting of 100k random lines with lengths from 1 to 1000 (48MB in total) and reversed each line in it using “ordinary functions”, Text, and conduits. The simple “unlines . map reverse . lines” solution took 3.40s; the Text solution – 2.81s; the conduit solution – 1.43s. Turns out that strings aren't that bad after all. Also, if you assume everything is ASCII and use bytestring instead, you get
11:11:33 <indiagreen> 0.13s, which gives you speed of 370MB/s.
11:12:17 <edwardk> `double forcing' here only happens on the first iteration and doens't change the answer
11:12:43 <edwardk> no?
11:13:05 <edwardk> or do you mean changing the loop so it forces every iteration
11:13:15 * edwardk may have misparsed you
11:13:52 <dfeuer_> edwardk, yeah, those are the two ways to do it.
11:16:09 <sinelaw> can something that does a long foldl' be easily parallelized?
11:17:46 <dfeuer_> sinelaw, it depends.
11:19:17 <sinelaw> dfeuer_, actually, correction: scanl
11:20:22 <dfeuer_> sinelaw, I don't think you're terribly likely to be able to parallelize that well at all.
11:20:23 <dmj`> jle`: ping
11:21:19 <sinelaw> dfeuer_, if I split the inputs into "take 100" and "slip 100", will it evaluate it twice?
11:21:23 <sinelaw> *skip
11:24:48 <ClaudiusMaximus> sinelaw: if the operation is associative and commutative, scan over an array can be parallelized - roughly, combine elements in increasing powers of two apart https://en.wikipedia.org/wiki/Prefix_sum#Parallel_algorithm
11:25:17 <sinelaw> ClaudiusMaximus, it isn't. but even just processing the list as two halfs would help
11:25:47 * hackagebot tidal 0.4.17 - Pattern language for improvised music  http://hackage.haskell.org/package/tidal-0.4.17 (AlexMcLean)
11:26:11 <sinelaw> I can probably change the scan into a map, but the resulting output needs to be pasted in the right order
11:26:35 <sinelaw> come to think of it, I probably *should* change it into a map... at the cost of some feature, just to make it faster
11:29:41 <indiagreen> joshy: oh, and it also turns out that readFile in Data.Text is being clever about using current locale and stuff, so you can get both correct handling of UTF-8 and 3× better speed (64MB/s) by combining bytestring and text. Text version: http://lpaste.net/114000, text + bytestring version: http://lpaste.net/114002. Since String is just a linked list, it's probably always going to be slower than Text.
11:35:47 * hackagebot json-autotype 0.2.3.0 - Automatic type declaration for JSON input data  http://hackage.haskell.org/package/json-autotype-0.2.3.0 (MichalGajda)
11:40:38 <miasma> heh, did anyone see this :D http://www.quora.com/Why-did-Google-go-with-Java-instead-of-Haskell
11:40:45 <miasma> "For another, has anyone ever scaled Haskell up to thousands of machines and thousands of requests per second? Does it work well? Are there unexpected problems? It's probably not impossible, but it *is* risky."
11:41:25 <dmj`> "For another, Haskell *is* hard to learn, and that is an extra burden"
11:42:01 <capisce> google has never been very innovative programming language wise
11:42:16 <miasma> does haskell support enterprise javabeans?
11:42:16 <capisce> gwt, angular.js, go, dart, etc all seemed pretty meh to me
11:42:23 <hpc> also, android apps are sure not going to be written in haskell
11:42:42 <capisce> and their list of official in-house languages is very conservative
11:42:57 <kadoban> I'm not even sure of the premise of the question. Are they talking about in the context of android?
11:43:17 <capisce> java, c++, python
11:43:30 <exio4> I think android going for java was "what is the hyped thing right now?"; "Java"; "ok, so lets use it"
11:43:34 <capisce> and naturally javascript for web stuff
11:43:42 <dmj`> I heard using C++'s multiple inheritance at google is borderline a fireable offense
11:43:52 <simpson> dmj`: False.
11:43:52 <capisce> I do like the look of Swift from Apple, and Rust from Mozilla
11:43:55 <hpc> haha
11:43:58 <orbital> if you have a record type and config file (read with Data.ConfigFile) that _may_ contain new and improved values for the members of the record, what would be a good way to iterate over the record members and selectively "update" it from the config file? Is this a good time to start learning Lens?
11:44:10 <orbital> pardon for butting in
11:44:20 <simpson> Android picked Java prior to being acquired by Google. It has more to do with programming by contract than anything else.
11:44:38 <capisce> simpson: that's probably not the vector they wanted to innovate in
11:44:38 <hpc> orbital: not butting in, this is just what happens when nerds get bored ;)
11:44:39 <dmj`> simpson: do you work google?
11:44:43 <dmj`> for*
11:44:49 <simpson> dmj`: Sure, why not.
11:44:57 <dmj`> is that a yes?
11:44:59 <orbital> calling GWT "meh" is a rather kind thing to say
11:45:12 <simpson> capisce: There is this strange perception that Googlers are better than normal computer scientists. I'm not sure why.
11:45:25 <dmj`> simpson: probably because of the interview process
11:45:36 <sinelaw> "flop" is a better word
11:45:37 <orbital> GWT: the tool for exchanging bits of soul for money
11:45:40 <hpc> orbital: so your record type consists of some fields that can update in real time and some that do not?
11:45:52 * hpc would personally go for "reload the config wholesale"
11:45:57 <orbital> hpc: nope, it's just an application config
11:46:20 <hpc> i don't think you need lenses for this
11:46:21 <simpson> dmj`: To be honest, Google's interview isn't tougher than any other interview.
11:46:39 <orbital> what I mean is, I'd rather avoid setting each field explicitly and instead prefer to iterate somehow
11:46:48 <miasma> it's quite frustating to argue about type theory or defend haskell when people reduce the questions into "does google or other big companies use haskell? no. thus, it must suck. i don't want to hear about your ivory tower nonsense"
11:46:57 <capisce> indeed
11:47:32 <dmj`> simpson: how long have you worked at google?
11:47:43 <simpson> dmj`: Couple years.
11:48:31 <NikolajK> how much research is there being done at google - what is the feel of such a department, do you know?
11:48:40 <simpson> research.google.com
11:48:54 <simpson> Alternatively: Yes.
11:49:15 <dmj`> simpson: are you the guy who wrote the quora response?
11:49:27 <NikolajK> what was the response?
11:49:30 <dmj`> http://www.quora.com/Why-did-Google-go-with-Java-instead-of-Haskell
11:49:38 <simpson> Nope! I don't do Quora. Also I normally don't talk about Google, mostly because I'm really tired of people thinking that Google is special.
11:50:47 * hackagebot xml-to-json-fast 1.0.0 - Fast, light converter of xml to json capable of handling huge xml files  http://hackage.haskell.org/package/xml-to-json-fast-1.0.0 (NoamLewis)
11:50:53 <dmj`> simpson: do you work on search?
11:51:06 <dmj`> are you an SRE
11:53:36 <simpson> dmj`: I worked on technical infrastructure as an SRE.
12:11:39 <joe9> program: http://codepad.org/l5Wuym4n , output: http://codepad.org/8zKvSRbk . I do not understand why I get Lines 21 and 22. I am probably not doing something right somewhere. I cannot figure out where.
12:11:46 <joe9> can anyone please comment?
12:12:13 <joe9> I understand that the program might be a bit tricky.
12:14:04 <dreams> ugh, I suck at reading Haskell written by others. you could also replace "suck" by "hate".
12:14:38 <lericson> @hoogle Num a => a -> Int
12:14:42 <lambdabot> Data.Generics.Schemes gdepth :: GenericQ Int
12:14:42 <lambdabot> Data.Generics.Schemes glength :: GenericQ Int
12:14:42 <lambdabot> Data.Generics.Schemes gnodecount :: GenericQ Int
12:14:58 <lericson> I just want to make an Int out of something
12:17:07 <joe9> dreams: sorry about that. adding ContT to the mix does not help either.
12:17:43 <dreams> joe9: no its not your problem. No need to say sorry.
12:19:10 <dreams> joe9: maybe its that 100 lines of Haskell is equivalent to 500 in imperative ones. So few pages does a lot.
12:20:24 <dreams> I tend to read Haskell eagerly to ease the reasoning.
12:25:25 <joe9> dreams: that is the same problem I have. I am trying to understand/replicate the code from this  http://codepad.org/XAVWoTWK
12:25:42 <joe9> and inspite of my best efforts and rewriting the code to something that I can understand.
12:25:52 <joe9> and, still I do not understand how it works.
12:27:49 <razzi> To define an Arbitrary instance for a binary search tree type `BST a`, how can I constrain `a` to also be an instance of Arbitrary? See http://lpaste.net/114004
12:28:37 <dmj`> Arbitrary a => Arbitrary (BST a) ?
12:28:39 <dreams> joe9: yeah I tried to re-write a parser. Terrible experience. I guess its a matter of getting used to it.
12:28:55 <dfeuer_> edwardk, since you're the big fan of coercions, I'm wondering if some functions in Data.Sequence might benefit from such. It's very hard to see what might be important because there's so much polymorphic recursion about, but the Element type looks very coercion friendly.
12:29:13 <edwardk> i'm not a big fan, but i'm starting to see how they can be used more at least ;)
12:30:08 <dfeuer_> I'm less clear about whether the Element type is one that gets hit by the polymorphic recursion at all--I think probably not.
12:30:16 <dreams> joe9: well good to know, I thought I was stupid.
12:30:19 <edwardk> also there is a pain point that that package has a wide support profile
12:30:29 <razzi> @dmj` That type checks! Thanks, I'll see if that does what I need
12:30:29 <lambdabot> Unknown command, try @list
12:30:39 <edwardk> and that fingertree is maintained by ross who pretty much ignores anything ghc specific as long as he possibly can
12:30:45 <dfeuer_> edwardk, that's what CPP is for. It already uses CPP to broaden support.
12:30:48 <dmj`> razzi: cool ;)
12:30:49 * hackagebot fast-tagsoup 1.0.6 - Fast parser for tagsoup package  http://hackage.haskell.org/package/fast-tagsoup-1.0.6 (VladimirShabanov)
12:31:03 <edwardk> dfeuer_: just pointing out that you have maintainers to convince, not me =P
12:31:14 <dreams> joe9: some say you must get a black belt in Type-foo to read programs.
12:31:14 <dfeuer_> edwardk, just as a matter of principle, or because he likes some other implementation?
12:31:33 <edwardk> more principle i think
12:31:59 <joe9> dreams: reading and understanding forth code is worse.
12:32:15 <edwardk> anyways, trying to find where you fmap Elem in/out in Data.Sequence
12:32:16 <dreams> joe9: I guess J tops them.
12:32:18 <edwardk> not sure where it helps
12:32:34 <joe9> dreams: haskell is a lot better than any other language out there, imho.
12:32:56 <dfeuer_> edwardk, well, one obvious fact is that foldMap=coerce and foldl=coerce  but I don't know if that helps or not.
12:33:01 <sinelaw> except zulu
12:33:02 <dreams> joe9: depends, I would not want to write low-level stuff in Haskell.
12:33:23 <edwardk> :t foldl
12:33:25 <lambdabot> (b -> a -> b) -> b -> [a] -> b
12:33:32 <edwardk> heh look at that
12:33:41 <dreams> joe9: but the more I get used to Haskell the more I like it :)
12:33:43 <edwardk> :t coerce
12:33:44 <lambdabot> (Contravariant f, Functor f) => f a -> f b
12:33:50 <dfeuer_> Wrong coerce.
12:33:51 <edwardk> :t Data.Coercible.coerce foldl
12:33:52 <lambdabot> Not in scope: ‘Data.Coercible.coerce’
12:33:57 <edwardk> :t Data.Coerce.coerce foldl
12:33:58 <lambdabot> GHC.Types.Coercible ((b1 -> a -> b1) -> b1 -> [a] -> b1) b => b
12:34:37 <edwardk> yeah the foldl observation there is basically the same as the transducer trick for a newtype, makes sense
12:35:20 <dfeuer_> Like I said, though, I don't know if there's enough polymorphism going on around Element to make that have any effect at all.
12:35:24 <edwardk> so far all i see is one pair of eta-reductions in foldl on Elem
12:35:31 <edwardk> i don't think it effectively matters
12:35:50 <bitemyapp> chrisdone: how do I use ghci-ng with a cabal project? I'd rather not make it "the" ghci if at all possible and adding the paths to things manually is yuck.
12:47:26 <sinelaw> except zulu
12:50:49 * hackagebot rethinkdb-client-driver 0.0.5 - Client driver for RethinkDB  http://hackage.haskell.org/package/rethinkdb-client-driver-0.0.5 (wereHamster)
12:51:51 <adarc> ooo nice, i've always wanted to test out rethinkdb
12:52:08 <Pamelloes> If I have a type A { parent :: Maybe A, children :: [A] } how do I create a parent and child instance that correctly refer to each other?
12:52:33 <freeman42> :t [1,2,3] ++ 4
12:52:34 <lambdabot> (Num [a], Num a) => [a]
12:52:39 <freeman42> magic ^^
12:53:10 <Zekka> Pamelloes: There's a few ways to do this but are you sure you want to?
12:53:37 <Zekka> I don't usually like introducing cyclic structures like that unless I have to
12:53:50 <Pamelloes> I'm creating a tree that needs to be traversible upwards and downwards...
12:53:58 <Zekka> Hold up, I'll pastebin a way of doing this
12:54:23 <Pamelloes> Unless do you have an alternate solution for traversing up and down a tree?
12:54:54 <Zekka> Pamelloes: Other than keeping the tree around and holding onto indices into the tree instead of elements? No
12:55:15 <saep> Zippers!
12:55:55 <saep> http://learnyouahaskell.com/zippers
12:56:01 <Pamelloes> Hm, that's actually an interesting idea. Right now I have a type for defining the tree and a type for defining a path through the tree. I could probably get by using the path instead of the tree itself.
12:56:24 <benzrf> i g2g
12:56:55 <Zekka> Pamelloes: For posterity, here's how you do it: http://lpaste.net/114007
12:57:20 <Zekka> Bindings in the same block (where/let, etc.) are generally allowed to be mutually recursive, so you can do that
12:57:46 <Zekka> oh, and the pattern-match is redundant here, come to think of it
12:57:53 <Pamelloes> Alright, thanks :)
12:58:02 <Zekka> but you ought to get the point anyway, for where child1, child2 and child3 might be different in some way
12:58:29 <Zekka> Pamelloes: You may run into problems, mind, if you alter a tree node
12:58:30 <Pamelloes> From a performance perspective, would it be better to implement a tree as you just notated vs just managing indices?
12:58:40 <Pamelloes> hm... that's a good point.
12:58:50 <Zekka> Pamelloes: Go read saep's link, IIRC it's pretty good!
12:59:06 <Zekka> If you change a tree node though, the children will still point to the old one
12:59:18 <Zekka> That is, if you use this mutually recursive style
12:59:21 <Pamelloes> My mind is starting to hurt trying to wrap my mind on how to manage all the updates D:
12:59:59 <Zekka> Pamelloes: Zippers are a pretty good pattern for this kind of thing, there's also a library called lens which is designed around neat nested updates
13:00:30 <Pamelloes> Alright, I will do some reading -- hopefully I can figure this out.
13:06:29 <malllle> how can i: BS.foldl (\x y -> x + y) 0 b -- b bytestring and x,y should be Word16?
13:08:47 <Zekka> malllle: Convert the bytestring into a collection of Word16s first?
13:09:03 <Zekka> I don't know offhand what the performance characteristics are like of this but it seems like the most obvious approach
13:10:23 <Zekka> malllle: Of course, I'm not sure you need both of them to be Word16s
13:10:37 <Zekka> You only need the accumulator to be a Word16 unless I'm mistaken?
13:11:26 <malllle> but BS.foldl wants Word8
13:11:33 <Zekka> :t BS.foldl
13:11:34 <lambdabot> (a -> Word8 -> a) -> a -> BSC.ByteString -> a
13:11:44 <Zekka> It wants y to be a Word8, but it doesn't care what x is
13:12:17 <Zekka> You can, for instance, write (Word16 -> Word8 -> Word16) -> Word16 -> BS.ByteString -> Word16, yes?
13:12:48 <malllle> but how would this work if i want to add 2bytewise?
13:13:11 <Zekka> :t BS.foldl (\x y -> x + fromIntegral y) (0 :: Word16)
13:13:12 <lambdabot> BSC.ByteString -> Word16
13:13:37 <Zekka> malllle: This will convert each to a Word16 as you fold over the bytestring and add them to a Word16 sum
13:13:51 <Zekka> > BS.foldl (\x y -> x + fromIntegral y) (0 :: Word16) "depending on what extensions are active, this will work"
13:13:53 <lambdabot>  Couldn't match expected type ‘Data.ByteString.Internal.ByteString’
13:13:53 <lambdabot>              with actual type ‘[GHC.Types.Char]’
13:14:46 <Zekka> > BS.foldl (\x y -> x + fromIntegral y) (0 :: Word16) (pack "I wonder if this is imported by default")
13:14:48 <lambdabot>  Not in scope: ‘pack’
13:14:48 <lambdabot>  Perhaps you meant one of these:
13:14:48 <lambdabot>    ‘BS.pack’ (imported from Data.ByteString),
13:14:48 <lambdabot>    ‘BSL.pack’ (imported from Data.ByteString.Lazy),
13:14:48 <lambdabot>    ‘BSLC.pack’ (imported from Data.ByteString.Lazy.Char8)
13:14:55 <Zekka> > BS.foldl (\x y -> x + fromIntegral y) (0 :: Word16) (BSLC.pack "I wonder if this is imported by default")
13:14:57 <lambdabot>  Couldn't match expected type ‘Data.ByteString.Internal.ByteString’
13:14:57 <lambdabot>              with actual type ‘Data.ByteString.Lazy.Internal.ByteString’
13:14:57 <lambdabot>  NB: ‘Data.ByteString.Internal.ByteString’
13:14:57 <lambdabot>        is defined in ‘Data.ByteString.Internal’
13:14:58 <lambdabot>      ‘Data.ByteString.Lazy.Internal.ByteString’
13:15:00 <Zekka> oh, I will just stop
13:15:24 <Zekka> malllle: You probably understand the gist of what I'm writing even though I'm running into plenty of silly technicalities
13:16:59 <malllle> Zekka: thx but Data.ByteString.foldl (\x y -> x + fromIntegral y) (0::Word16) (pack [1,1,1,1]) should not give me 4
13:17:23 <malllle> i wanna add there: 00010001 + 00010001
13:17:24 <Zekka> malllle: Then I'm not understanding what you want. What should it give you?
13:17:40 <Zekka> Wait, why would it add that with that input?
13:17:59 <Zekka> Those are 1s, not 17s.
13:18:33 <malllle> i wanna interpret to adjacent word8 as one word16 and add that to the next word16 and so on
13:18:41 <malllle> *two
13:18:48 <Zekka> Oh, OK. Let me look a little bit, there are some hacky ways to do that but I don't know a correct one right offhand
13:19:24 <malllle> thank you very much
13:20:26 <Zekka> malllle: I can't find a more obviously correct way to do this than to unpack it into a list of word8s and turn each pair of word8s into a word16
13:20:39 <Comet-> help
13:20:51 <Zekka> Comet-: What's up?
13:24:36 <malllle> Zekka: can you give me an example for that?
13:24:55 <Zekka> malllle: Yeah, I'll pastebin a possible implementation
13:25:16 <Zekka> There may be a better way but I don't know personally what it is (and I hope if someone here would have known they'd have chipped in)
13:27:08 <Zekka> http://lpaste.net/114009 <- malllle: Here's a version
13:28:46 <malllle> Zekka: ah i see, thx and sorry for stealing your time by being imprecise
13:29:01 <jle`> dmj`: sup
13:31:29 <SwashBuckla> does haskell have a gofmt equivalent?
13:32:13 <Zekka> SwashBuckla: I think haskell-src-exts does it but I hvaen't personally used it
13:32:18 <simpson> SwashBuckla: Nope, there is no single canonical source representation.
13:32:24 <Zekka> http://stackoverflow.com/questions/6870148/is-there-a-haskell-code-formatter <- some other ones are listed here
13:32:34 <dmj`> jle`: tick bro
13:32:35 <Zekka> Simpson is correct although prettyprinters can at least make your source uniform
13:32:44 <SwashBuckla> that's one think I like about go-lang
13:32:52 <dmj`> jle`: amazon's dynamo db json has got to be the worst ever
13:33:01 <SwashBuckla> end all debates about formatting: use gofmt
13:33:04 <koala_man> with parsec, how would I write a function 'runOnFailure parser action' that tries 'parser' and runs a (non-parsing) action if it fails? with 'runOnFailure parser action = parser <|> (action >> fail "failed") it will add an unwanted error message
13:33:05 <dmj`> jle`: I have arch. questions
13:33:50 <josiah14> how do I place a typeclass restriction when defining a new data type
13:34:24 <josiah14> for example, I want to do something like 'data (Num a) => NewType a = NewType [a]
13:34:36 <dmj`> josiah14: one way is through existential quantification
13:35:04 <josiah14> dmj`: I'm not sure what you mean by that
13:35:09 <dmj`> data Person = forall a. Show a => Person { a :: name, age :: Int }
13:35:17 <jle`> dmj`: yeah? hope i know enough to be able to help :P
13:36:17 <dmj`> josiah14: data Person = forall a. Show a => Person { name :: a, age :: Int }
13:36:25 <dmj`> I had name and 'a' flip flopped
13:36:42 <dmj`> jle`: you know more than me so whatev :P
13:37:16 <josiah14> dmj`: I'm experimenting with that in GHCi right now.  I'll let you know if I still have questions in a moment
13:38:18 <josiah14> does this reqire the -XExistentialQuantification flag to be on when compiling?
13:38:37 <dmj`> yes
13:39:00 <josiah14> how do I run ghci with that tag?
13:39:23 <josiah14> oh, think I got it
13:39:28 <dmj`> :set -XExistentialQuantification
13:41:13 <josiah14> I can't use deriving with such data types, then, it appears
13:42:54 <josiah14> what does the compiler mean when it suggests I use a standalone deriving declaration instead
13:43:16 <josiah14> I just tried data vector = forall a. Num a => Vector [a] deriving (Show)
13:43:41 <josiah14> Vector should be capitalized everywhere there, typo
13:43:54 <Iceland_jack> josiah14: You shouldn't use an existential there
13:44:22 <Iceland_jack> Rather do:
13:44:22 <Iceland_jack>     data Vector a = Vector [a] deriving Show
13:44:22 <Iceland_jack> and use a 'Num a => Vector a -> ...' constraint at use sites
13:45:05 <dreams> Why does classes only have type signature? without an implementation
13:45:09 <josiah14> so you mean, restrict a to the Num typeclass in the type definitions for functions that expect or return a Vector?
13:45:24 <monochrom> because instances are the places where you write implementations.
13:45:24 <dmj`> dreams: you can do default implementations in classes
13:45:37 <dreams> dmj`: So what is the difference?
13:45:41 <Iceland_jack> josiah14: Yes
13:45:50 <dmj`> dreams: Monoid has a default implementation for mconcat = mfoldr mappend mempty
13:45:56 <dmj`> er foldr
13:46:00 <josiah14> Iceland_jack: thanks for the help
13:46:41 <josiah14> dmj`: thank you also.  never knew about existential types
13:47:28 <Cale> dreams: You can think of a type class as a predicate which may be true or false of any given type. The class declaration says what things must be provided in order to make the predicate true. The instances provide the things required in order to make the predicate true of a particular type.
13:47:54 <Cale> dreams: Type classes are used to restrict the types over which type variables range.
13:48:06 <Iceland_jack> josiah14: Alternatively you can use GADTs like this:
13:48:06 <Iceland_jack>     data Vector a where
13:48:06 <Iceland_jack>       Vector :: Num a => [a] -> Vector a
13:48:22 <dreams> dmj`: ah. hmm, but there is another concept which is overriding implementations?
13:48:23 <Iceland_jack> But that's more difficult to work with, for example trying to define a Functor instance
13:48:40 <Cale> dreams: For example, it wouldn't make sense for sort to have a type like [a] -> [a], because although we would like to be able to sort many different types of lists, not all element types have implementations of the comparison operations we need
13:49:03 <Cale> dreams: So, there's a class Ord which defines operations such as (<) and compare which can be used to do order comparison
13:49:16 <Cale> dreams: and then sort gets the type  (Ord a) => [a] -> [a]
13:49:24 <josiah14> Iceland_jack: that is helpful as well
13:49:50 <Cale> that says "for types a for which there is an instance of the Ord type class, this takes a list of values of type a, and produces another such list"
13:49:58 <josiah14> i interpret that as, I can explicitly supply the type definition for the type constructor that way
13:50:04 <dreams> Cale: ah, so if I wanted to sort colors, I have to provide an instance for the Ord type class, or just derive.
13:50:10 <Cale> yeah
13:50:19 <dmj`> dreams: I don't recommend that, if you want a custom instance I'd use a newtype
13:50:22 <dreams> And I thought it was about overriding.
13:50:51 <Cale> dreams: Well, you might think of the operations that the Ord class defines as being "overloaded"
13:51:13 <dreams> overloaded or implemented
13:51:26 <josiah14> well, there is also the issue that i can't use deriving if it's not a Haskell-98 type
13:51:27 <dreams> dmj`: don't recommend what?
13:51:52 <dreams> josiah14: deriving is a GHC extension as far as I know.
13:52:08 <dreams> Not sure if its Haskell
13:52:40 <mauke> deriving is standard haskell
13:52:42 <josiah14> well, so then, what would I do if I wanted Vector to derive from the typeclass 'Show' or 'Ord'
13:52:52 <mauke> you don't derive from typeclasses
13:52:55 <josiah14> I can't do that if it's not a Haskell-98 datatype, it seems
13:53:21 <dreams> Cale: what if you provide an implementation in the typeclass? it seems useless to me who can use it?
13:53:21 <Cale> dreams: Well, compare for example, being a method of the Ord type class, will be implemented separately for each type for which there's an instance.
13:53:31 <josiah14> so I can't make my custom datatypes printable in GHCi?
13:53:42 <Cale> Implementations inside the type class are default implementations which get used if the instance doesn't specify one
13:53:52 <dmj`> dreams: don't recommend making different instances of the same type in different modules, causes orphan instances
13:53:55 <mauke> josiah14: why not?
13:54:05 <Cale> They just help to make the instances shorter in cases where you have an obvious relationship between the methods.
13:54:12 <josiah14> that's what deriving does for you in haskell, mauke
13:54:18 <dreams> Cale: ah.
13:54:28 <mauke> josiah14: not really
13:54:29 <josiah14> if I want my datatype to be printable, it has to derive from Show
13:54:35 <mauke> 'deriving' is sugar for an instance declaration
13:54:44 <josiah14> ah, okay
13:54:45 <mauke> I already told you: you can't derive from classes
13:55:00 <mauke> 'deriving' derives a class instance from a type
13:55:03 <Cale> For example, in the class Eq, there are (==) and (/=), and then default implementations  x == y = not (x /= y)  as well as  x /= y = not (x == y)
13:55:10 <josiah14> so I would just have to explicitly provide instance definitions for everything I would want to normally 'derive' from
13:55:11 <dreams> dmj`: so have a 1 module and shove all the instances there?
13:55:24 <josiah14> sorry, I'm coming straight off the LYAHFGG book
13:55:51 * hackagebot pandoc 1.12.4.2 - Conversion between markup formats  http://hackage.haskell.org/package/pandoc-1.12.4.2 (JohnMacFarlane)
13:55:52 <Cale> If an instance failed to define either of these methods, then there would be an infinite loop there, but typically any instance will define one or the other.
13:56:03 <dmj`> dreams: you can spread it out, just don't create two instances of the same typeclass on the same type
13:56:04 <dreams> Cale: ah I see. So if I have Color and made an empty instance, it would automatically use the Ord == and /= implementation?
13:56:19 <Cale> The Eq default implementation
13:56:40 <Cale> Which is cyclic, so using the definition would result in an infinite loop (so don't do that)
13:56:52 <Cale> But what you can do instead is just to define (==)
13:56:58 <dreams> sorry Eq
13:57:08 <Cale> and then you automatically get x /= y = not (x == y) without having to write that
13:57:34 <Cale> Of course, Eq is derivable and you'll usually just derive it, but this applies in many other cases
13:57:47 <Cale> (and only a handful of classes are derivable)
13:57:48 <dreams> How is it cyclic I don't get it?
13:57:54 <Cale> Well, if you have:
13:57:59 <Cale> x == y = not (x /= y)
13:58:05 <Cale> x /= y = not (x == y)
13:58:13 <dmilith> is it practical to write code in haskell WITHOUT using monads and whole idea behind them?
13:58:34 <jeltsch> dmilith: Sure!
13:58:44 <Cale> dmilith: sure, though you will probably use some things which happen to be monads regardless
13:58:57 <Cale> dmilith: You can't write a complete program without using IO actions.
13:59:04 <jeltsch> There are many things that do not readily fit the monad structure.
13:59:15 <cdk> dmilith: Monads exist to remove boilerplate on the part of the programmer (not the monad implementer), so you can, just expect a lot more typing
13:59:17 <Cale> dmilith: and IO happens to be a monad
13:59:18 <jeltsch> I/O is an exception, of course.
13:59:23 <Tehnix> What is the recommended GUI framework to use? They all look so outdated ._.
13:59:33 <dmilith> I found it to be major issue for programmers from imperative world. That's why I'm asking
13:59:45 <jeltsch> Tehnix: Gtk2Hs shouldn’t be outdated.
13:59:55 <Cale> dmilith: It shouldn't be a major issue for anyone, it's really not a big deal
14:00:04 <Tehnix> well, design/webpage-wise
14:00:11 <Cale> dmilith: Monad is just a pattern which shows up in a lot of libraries, so we abstract over it
14:00:14 <Tehnix> jeltsch: also, doesn't it rely on X11 on OS X?
14:00:31 <dreams> Cale: ah now I get you.
14:00:37 <Cale> dmilith: It's a pattern which is hard to understand if you're unfamiliar with the examples, but once you see a handful of the examples, it's really not a big deal.
14:00:51 * hackagebot either 4.3.2 - An either monad transformer  http://hackage.haskell.org/package/either-4.3.2 (EdwardKmett)
14:00:52 <jeltsch> Tehnix: Gtk2Hs is a Haskell wrapper around GTK+. AFAIK, GTK+ has different backends, also a Windows one, for example.
14:01:15 <Cale> dmilith: The only reason we do this is to save writing a bunch of definitions out over and over in each of these similarly-structured libraries
14:01:28 <jeltsch> Tehnix: And it definitely does not need OS X. I am using it on Linux.
14:01:33 <Cale> (pretty much the reason for most abstractions -- to save on typing out the same code repeatedly)
14:01:51 <dmilith> yea
14:01:56 <Tehnix> jeltsch: no no, I know it's cross platform. Was referring to it using X11 on OS X specifically though
14:02:19 <jeltsch> Tehnix: I don’t get it.
14:02:48 <jeltsch> In what way does GTK+ use X11 and OS X “specifically”?
14:02:57 <josiah14> Cool, that was helpful
14:03:04 <josiah14> thanks, all
14:03:26 <Cale> dmilith: The big thing which is probably weird about Haskell for imperative programmers (well, there are lots, but one of them) is not so much that IO is a monad, but that there is a type of IO actions at all.
14:03:48 <Tehnix> jeltsch: For example, to run GTK+, you need to install XQuartz. When you run gtk-demo, it opens X11 http://cl.ly/image/0k1d1N0v3U3p
14:03:48 <jeltsch> cale, dmilith: Exactly!
14:04:14 <jeltsch> Tehnix: Isn’t there a native OS X backend? Hmm, maybe not …
14:04:16 <Cale> dmilith: The fact that we have these first class descriptions of effectful things which could be executed.
14:04:16 <dreams> Cale: can it be an applicative functor?
14:04:31 <Cale> dreams: IO? Every monad is an applicative functor in a natural way.
14:05:08 <dreams> Cale: hmm, I thought its more than that. i.e. the reverse is not true.
14:05:14 <Tehnix> jeltsch: I don't think so, and X11 was something they stopped having on OS X since....around 10.7 or smth. So, IIRC, the user has to install XQuartz. Don't think there is much of a problem on Windows though
14:05:27 <Cale> dreams: Not every applicative functor is a monad, that is correct.
14:05:34 <cdk> dreams: every banana is a fruit, but of course every fruit is not a banana
14:05:38 <jeltsch> Tehnix: That’s said. :-(
14:05:43 <Tehnix> Yeah :(
14:06:43 <jeltsch> Tehnix: But Gtk2Hs seems to be the most mature Haskell GUI library to me, though. Another option might be wxHaskell.
14:06:45 <dmilith> Cale: I walk through asm, C, C++, Java then Scala, node, and I'm on step called Haskell. A huge step for imperative mind ;]
14:07:31 <jeltsch> dmilith: But it’s definitely worth it! :-)
14:07:51 <dmilith> i wouldn't be here :}
14:07:52 <Tehnix> jeltsch: Unfortunately, wxHaskell (or, specifically wxWidgets) has some problems with Quicktime atm on 64-bit OS X (which is the only version atm) :/... There are some workarounds though, but haven't managed to get them working. Might stick to gtk+ or look into qt
14:07:56 <dreams> The most confusing thing I heard is that functions are functors, what?!
14:08:19 <jeltsch> dmilith: I have been working with functional languages that are not pure (Scala, F#), and I always enjoy working with my pure Haskell again. :-)
14:09:00 <jeltsch> dreams: Functions and functors are two different things.
14:09:27 <jeltsch> In Haskell, a functor is a type constructor with a map operation (called fmap).
14:09:32 <jeltsch> @hoogle Functor
14:09:33 <lambdabot> Prelude class Functor f
14:09:33 <lambdabot> Data.Functor class Functor f
14:09:33 <lambdabot> Control.Monad class Functor f
14:09:33 <dreams> jeltsch: I know what a functor is to some extent. But I read I think in LYAH that functions are functors.
14:09:42 <Iceland_jack> dreams: ((->) r) is a Functor
14:09:47 <dmilith> scala changed my way of thinking, but as a hybrid.. I could always do some imperative tricks ;]
14:10:17 <jeltsch> dreams: Hmm, I cannot believe this. Where did they say that?
14:10:27 <jedai> dreams: more precisely, (a ->) is an instance of the Functor typeclass
14:10:32 <dreams> jeltsch: let me look it up.
14:10:51 * hackagebot github 0.13 - Access to the Github API, v3.  http://hackage.haskell.org/package/github-0.13 (cesar_nataren)
14:10:54 <jedai> dreams: fmap is then simply composition of functions
14:11:03 <Cale> Well, you can still do imperative programming in Haskell as well. Haskell makes a pretty good imperative language if you just want to write everything as IO actions actually. But you probably won't want to, because Haskell makes it really obvious what the benefits of not doing so are.
14:11:22 <jeltsch> jedai, dreams: fmap is not a composition of functors. It is application of a functor to a function.
14:11:37 <jedai> dreams: it makes perfect sense if you consider (a -> b) as encoding a dictionary with keys of type a and values of type b
14:12:15 <jedai> jeltsch: composition of functions, not functors, and only for the (r ->) instance of Functor
14:12:16 <dreams> jedai: look up "How are functions functors?" in http://learnyouahaskell.com/functors-applicative-functors-and-monoids
14:12:39 <jeltsch> jedai: Ah, okay, that’s right.
14:13:03 <dreams> jeltsch*
14:13:27 <lynnard> let var = expensive_fun a in (fun1 var) + (fun2 var) VERSUS (fun1 $ expensive_fun a) + (fun2 $ expensive_fun a), does it make a performance difference?
14:13:28 <dreams> jeltsch: so function are functors?!
14:13:36 <jedai> dreams: right, it's talking about what I'm describing here (r ->) is a Functor instance
14:13:50 <lynnard> in other words does 'let' expression actually causes haskell to save the variable for reuse?
14:14:23 <lynnard> anyone?
14:14:33 <silver> dreams, most are not
14:14:34 <jedai> dreams: did you see mypost : "it makes perfect sense if you consider (r -> a) as encoding a dictionary with keys of type r and values of type a
14:14:36 <tac_> lynnard: let introduces a variable into a local scope
14:14:45 <Cale> dreams, jedai: That's really unfortunate wording btw. It's not functions which are functors.
14:14:52 <tac_> lynnard: If another variable of the same name already exists, it is *shadowed* inside that let block
14:14:52 <jeltsch> dreams: Functions are values, and thus cannot be functors (which are type constructors). But for every type r, the type constructor (->) r is a functor (an instance of the Functor class).
14:14:57 <Cale> It's the type constructor (->) e which is a functor for each type e.
14:15:06 <jedai> Cale: right
14:15:30 <lynnard> tac_: I suppose I didn't ask clearly enough. I'm trying to investigate the performance benefit of 'let'
14:15:32 <dreams> jedai: yes.
14:15:52 <jedai> Cale: it's exactly the same thing as (Map r) being a Functor instances
14:15:54 <dreams> eh, its a but confusing to think of (->) as being a constructor.
14:16:05 <tac_> lynnard: naively, it should just allow you to allocate memory that gets deallocated when you exit the block
14:16:07 <jeltsch> lynnard: Most Haskell implementations cache the results of expressions that are bound to a variable (e.g., via let). But this is nothing that the Haskell standard requires.
14:16:25 <tac_> lynnard: although GHC is magical, and will futz around with your code, so who knows how it will actually end up looking
14:16:36 <jedai> dreams: sure, most language treat function specially, even when they consider that function is a value type
14:16:43 <jeltsch> dreams: (->) is not a constructor in the sense of “data constructor”; it is a type constructor.
14:16:50 <lynnard> jeltsch: so does that imply that whenever I want to cache a result I should use 'let'?
14:17:10 <jeltsch> lynnard: You can use let expressions or where clauses.
14:17:28 <dreams> jeltsch: so you'd have data (->) = ?
14:17:28 <lynnard> jeltsch: although from a strictly functional programming point of view there should be no difference from repeating the same expression twice
14:17:45 <jeltsch> lynnard: But since expression evaluation is side-effect-free, it does not matter for the result if you cache or not. It is “just” a matter of performance.
14:18:18 <lynnard> jeltsch: of course, but I do care about performance
14:18:18 <jedai> dreams: data (->) a b = ...
14:18:33 <dreams> jedai: any idea how ... is defined?
14:18:47 <jeltsch> dreams: (->) is not an algebraic data type, so it is not defined via data.
14:18:55 <dreams> oh
14:18:59 <jedai> dreams: a -> b is a type, -> is a type constructor because you have to pass it two arguments to get a type
14:19:02 <lynnard> jeltsch: this actually causes more implication as if I'd want my program to run faster wouldn't I have to rely on such assumptions - which are in no part of Haskell specification
14:19:03 <tac_> lynnard: like I said, you can probably just assume at the let binding, a thunk will be allocated for you, and nothing more
14:19:16 <jeltsch> dreams: (->) is built-in and a bit special.
14:19:21 <dreams> I thought its literally an algebraic data type
14:19:24 <dreams> ah ok
14:19:29 <tac_> dreams: -> is the most magical of types. It is defined by lambda abstraction
14:19:54 <tac_> dreams: If t is an expression of type B (that might depend on a : A), then \a -> t has type A -> B
14:19:57 <tac_> That is the rule, more or less
14:20:14 <jeltsch> lynnard: You can practically rely on let-bindings preventing double computation. The compiler might implement things differently, but it should not make things worse.
14:20:29 <dreams> tac_: interesting.
14:21:06 <jeltsch> tac_: Well, (->) is predefined by the language; it is the values of (->) that are defined by λ-abstraction.
14:21:19 <tac_> dreams: Have you seen the formal rules for the simply typed lambda calculus?
14:21:21 <Cale> With one easy exception: if the things defined by a let are type class polymorphic, then they're secretly functions and will be recomputed at each use.
14:21:34 <saep> lynnard: If your program is slow: Profile it, see what is taking so long and optimize there. Don't think too much about it beforehand.
14:21:35 <tac_> jeltsch: right. Arrow types are freely generated over the other types
14:21:38 <Cale> (because they get applied to the type class dictionary, and the results are not memoised)
14:21:47 <dreams> tac_: not really.
14:21:57 <tac_> Cale: Didn't that change at some point?
14:22:10 <Cale> tac_: If that's changed, I wasn't made aware of it :)
14:22:12 <tac_> I know Haskell changed from ML's way at one point in history
14:22:18 <dreams> tac_: where do I access that?
14:22:21 <tac_> And it was an obscure breaking change
14:22:27 <Cale> I'd be quite surprised if it did change
14:22:54 <tac_> dreams: If you can get a copy of Pierce's Types and Programming Language, it's a fabulous book that explains the details. Let me see if I can find a free resource that lists the rules
14:23:02 <dreams> tac_: I do have it.
14:23:19 <dreams> tac_: ML threw me off
14:23:43 <tac_> page 103 lists the rules
14:23:55 * dreams opens page 103
14:24:28 <tac_> It's written in derivation and turnstyle notation, but aside from the funny way of writing it, it's exactly what Haskell is doing (modulo, a slight variation)
14:24:58 <tac_> The rule T-ABS tells you how to introduce function types. (And the answer is with lambdas)
14:25:01 <dreams> tac_: wow wait, are you saying (->) is a literal interpretation of this in Haskell?
14:25:21 <tac_> Haskell's core calculus is very close to System F, which is presented in chapter 20
14:25:40 <tac_> but the ideas for Simply Typed LC are all the same in System F
14:28:53 <tac_> dreams: Everything to the left of the turnstyle (the |- symbol) is the names and types of the in-scope variables
14:30:03 <tac_> So the T-abs rule tells you that "If you have a bunch of variables in scope... but also x : T_1, and you can define t_2 with type T_2, then \x:T_1. t2 has type T_1 -> T_2"
14:31:11 <qsuscs> could i do a “int main() {return 0;}” in haskell?
14:31:20 <dreams> tac_: t2 is a variable?
14:31:38 <dreams> a term.
14:31:41 <tac_> It's a term, yep
14:31:50 <dfeuer_> Cale, if any one of several GHC extensions is enabled, let bindings stop being generalized.
14:32:00 <tac_> If t2 were, say, x, then \x:A -> x would have type A -> A
14:32:01 <jxv> qsucscs, "main = return ()"
14:32:02 <dfeuer_> (Well, sometimes)
14:32:03 <tac_> but I gotta run!
14:32:37 <dreams> tac_: thanks. later.
14:32:44 <Cale> dfeuer_: That doesn't change when you give explicit polymorphic type signatures.
14:32:52 <dfeuer_> True.
14:41:24 <indiagreen> I've used standalone deriving to make a Read instance for Data.Aeson.Value. It works for Bool – «read "Bool True" :: Value» returns «Bool True» – but it doesn't work for Number («read "Number 8"» throws a “no parse” exception). Is there something obvious I'm missing?
14:42:48 <indiagreen> Nevermind, found the culprit. The Read instance for Scientific doesn't like leading spaces.
14:50:52 * hackagebot purescript 0.6.0.2 - PureScript Programming Language Compiler  http://hackage.haskell.org/package/purescript-0.6.0.2 (PhilFreeman)
15:04:58 <nschoe> Hey I have a field in my postgresql table of type 'text'. In it I must add a MD5Digest (from pureMD5 library). I saw that MD5Digest is an instance of Serialize, but when I use decodeUtf8 . encode  I got the error " Cannot decode byte '\xb0': Data.Text.Internal.Encoding.decodeUtf8: Invalid UTF-8 stream"
15:05:12 <nschoe> Any idea how I an add that MD5Digest to my table ?
15:06:14 <Axman6> I'm confused why you'll need UTF-8
15:06:28 <Axman6> can you share the code?
15:09:05 <RchrdB> nschoe: the output from MD5 will be a bytestring containing random-looking bytes. Almost cetainly you want to store that as a bytea in postgresql; it's not text.
15:10:17 <nschoe> RchrdB, ah thanks ! so I can just run 'encode' from Serialize and set the type to 'byte' in postgresql ?
15:10:29 <RchrdB> I expect so!
15:11:00 <nschoe> Axman6, I just thought md5 hashes were UTF8
15:11:13 <nschoe> RchrdB, will try that right now, thank you
15:11:34 <RchrdB> No, cryptographic hashes outputs are fixed-size strings of random-looking bytes.
15:12:03 <Aquana> aren't type classes more about properties of functions than properties of types?
15:12:14 <Maxdamantus> or, strings of random-looking bits.
15:12:25 <Maxdamantus> but the length is usually divisible by 8, conveniently.
15:12:45 <RchrdB> The only time a cryptographic hash will output a valid utf-8 byte stream is either by sheer (unlikely) coincidence, or if you're using an interface to the cryptographic hash function that encodes its output as an ASCII string of base64 or base16 digits for you.
15:13:27 <RchrdB> Ideally they shouldn't do that, because that's a pain in the backside if you want to use them for any of the many algorithms that involve feeding the output from one hash into another hash. ;P
15:13:39 <nschoe> Ah ok thanks. Actually, that was stupid to think it was UTF8, now that I think about it. Thanks guys
15:14:06 <Maxdamantus> Aquana: type classes don't need to involve functions.
15:15:12 <RchrdB> Maxdamantus: yeah, I just don't want to cause confusion because of the fact that Haskell doesn't have a commonly-used "bit-string" type. :)
15:15:25 <torpet> how can i apply a filter to a structure like [[1,2,3], [2,3,7],...]
15:15:36 <torpet> via map i would just do map.map
15:16:17 <hunt> Hey guys how do i update the dependencies in my cabal build after theyre added?
15:16:18 <Maxdamantus> > (filter . filter) (>2) [[1,2,3], [2,3,7]]
15:16:19 <lambdabot>  Couldn't match type ‘[a]’ with ‘GHC.Types.Bool’
15:16:19 <lambdabot>  Expected type: (a -> GHC.Types.Bool) -> [a] -> GHC.Types.Bool
15:16:19 <lambdabot>    Actual type: (a -> GHC.Types.Bool) -> [a] -> [a]
15:17:06 <Welkin> hunt: what do you mean?
15:17:20 <shiona> > filter (any (==2)) [[1,2,3],[4,5,6]]
15:17:22 <Maxdamantus> > (map . filter) (>2) [[1,2,3], [2,3,7]]
15:17:22 <lambdabot>  [[1,2,3]]
15:17:23 <Welkin> I believe you need to remove the old packages and install the new ones
15:17:23 <lambdabot>  [[3],[3,7]]
15:17:30 <Welkin> then recompile everything that depends on it
15:17:32 <hunt> Welkin: i did my cabal init but the file ive worked on hasnt been imported by main so i dont think its dependencies were included in the package build
15:17:50 <Welkin> in your .cabal?
15:17:53 <hunt> yes
15:18:02 <Welkin> you have to add them yourself to the list of dependencies
15:18:13 <hunt> Welkin: yikes... how do i avoid compatibility errors
15:18:25 <RchrdB> torpet: there are a couple of ways depending on whether you want to drop elements from the nested lists, or whether you want to drop whole nested lists or whatever. shiona and Maxdamantus gave a couple of examples.
15:18:42 <sinelaw> given a type class A, how can I say that "all monads are A?" I can't get the instance declaration to compile...
15:18:44 <torpet> i want to drop elements inside nested lists, i guess Maxdamantus way was correct
15:19:18 <Welkin> hunt: by using a sandbox
15:19:56 <Welkin> if there are problems, cabal will let you know when you run `cabal install --only-dependencies`
15:20:15 <hunt> Welkin: im in a sandbox, is there any way to automatically have the sandbox write the installed dependencies to the .cabal?
15:20:24 <Welkin> I'm not sure
15:20:32 <Welkin> I've just added them myself
15:20:39 <Welkin> I am not an expert with cabal though
15:20:41 <hunt> ok, as long as theyre listed in the .sandbox i suppose thats fine
15:20:47 <hunt> people should add that to cabal though
15:20:56 <hunt> i would be willing to if i knew where to start
15:21:20 <Maxdamantus> sinelaw: instance Monad m => A m
15:21:29 <sinelaw> Maxdamantus, doesn't compile
15:22:08 <hexagoxel> hunt: use "cabal freeze" output as base?
15:22:10 <sinelaw> First it complains about FlexibleInstances; if I enable that, it wants UndecidableInstances which seems wrong
15:22:10 <Maxdamantus> sinelaw: if the class has members you need to provide correct definitions of them.
15:22:17 <hexagoxel> ah wait, no
15:22:32 <hunt> hexagoxel: what is cabal freeze?
15:22:49 <Welkin> it lists your dependencies
15:22:55 <hexagoxel> it can track the exact versions of the dependencies
15:23:20 <sinelaw> Maxdamantus, I did
15:23:31 <hexagoxel> so you have reproducible builds when switching environments, for example
15:23:39 <Maxdamantus> sinelaw: yeah, okay, so you can't in standard Haskell.
15:23:52 <sinelaw> why UndecidableInstances?
15:24:32 <hunt> is there anyway to compile with an action other than 'main' as the starting point?
15:24:59 <Thooms> main = myAction
15:25:06 <hexagoxel> hunt: maybe `cabal sandbox hc-pkg list`
15:25:13 <Thooms> :'
15:25:30 <Maxdamantus> sinelaw: probably because it would require extra restrictions to prevent you from creating loops.
15:25:45 <Maxdamantus> sinelaw: eg, instance A m => B m; instance B m => A m
15:26:03 <sinelaw> hm
15:26:31 <nschoe> RchrdB, hi back, I have just tried it, now I have the error "incomplete multibyte character", any idea what's failed ?
15:27:02 <RchrdB> nschoe: "multibyte character" sounds like something is still trying to interpret your bytes as unicode text somewhere.
15:27:22 <nschoe> Ho really ? ... damn
15:27:45 <Cale> Maxdamantus: Even in extended Haskell, such an instance is a bad idea
15:28:30 <nschoe> RchrdB, so I changed the type in my table as 'bytea' and in Haskell it is a ByteString. I then simply used Data.Serialize.encode on the MD5Digest to transform it into a ByteString, is this the correct way ?
15:29:00 <Cale> Note that instance selection is done without considering the type class constraints on the instances, because classes are open, so there's no way to know for certain that a type is *not* an instance of a class.
15:29:08 <RchrdB> nschoe: I'm afraid that I'm not familiar with Data.Serialize, sorry.
15:29:11 <Cale> (until building the final program)
15:30:12 <nschoe> RchrdB, ah ok, no problems. Just to check : in my db, if I have a 'bytea' type, I have to use ByteString in Haskell, right ?
15:30:21 <Cale> So when you write something like  instance (Monad m) => A m, it looks like  instance A m  to the process of instance selection.
15:30:24 <RchrdB> nschoe: I believe so, yes.
15:30:30 <Cale> (i.e. it always applies)
15:30:38 <RchrdB> nschoe: oh, obvious quesiton: are you sure that the table has been altered?
15:31:19 <nschoe> RchrdB, I delete it and re-created it, and "\d " gives me "hash     | bytea   | not null" so yes it has been altered
15:31:58 <RchrdB> nschoe: what library are you using for postgres, please? I'd like to try this.
15:32:21 <nschoe> RchrdB, postgresql-simple
15:32:30 <RchrdB> Ta.
15:32:56 <nschoe> RchrdB, truth is, I'm not very familiar with postgresql (be it in general or in Haskell), so I'm not sure how to use this stuff
15:33:45 <Maxdamantus> Cale: so is that to do with flexible instances, or undecidable instances?
15:34:45 <Cale> Well, Overlapping instances will make the instance sort of work
15:35:13 <Cale> (flexible and undecidable aren't enough)
15:40:01 <dfeuer_> OverlappingInstances strikes me as extremely shady.
15:40:22 <dfeuer_> Largely because it has a huge list of rules, most of which I don't understand.
15:44:33 <nschoe> RchrdB, I just confirmed the error came from the hash. I just modified my code to add Data.ByteString.empty in place of the hash, and it worked. The entry was added successfully yo the DB. So I'll have to check about Serialize, amybe the error comes from here
15:45:03 <RchrdB> nschoe: ah, k. One question, why are you calling Data.Serialize.encode at all?
15:46:08 <RchrdB> given that the hash's output is a bytestring, you must be calling it like (Data.Serialize.encode :: ByteString -> ByteString) in context. Perhaps you might save some time and space by replacing that function with (id :: ByteString -> ByteString)? :)
15:46:47 <nschoe> RchrdB, I use pureMD5 library to compute the hash, and the md5 function, md5 :: md5 :: ByteString -> MD5Digest
15:46:54 <nschoe> So the output I have is MD5Digest, not ByteString.
15:47:22 <nschoe> I thought I had to conver the MD5Digest to actualyByteString in order to add it to the table, in the 'bytea' column
15:47:29 <RchrdB> Oh I see.
15:48:42 <nschoe> RchrdB, I'm trying right now without the conversion
15:49:21 <RchrdB> nschoe: never mind, sorry, I was assuming that you might have a hash function with a type like (ByteString -> ByteString).
15:49:35 <nschoe> Nah of course it doesn't work : no instance of FromField
15:49:58 <nschoe> RchrdB, no problems. I think I'll sleep on it, maybe will appear more clearly tomorrow :-)
15:50:06 <nschoe> RchrdB, Thanks for you help !
15:50:22 <RchrdB> No problem, sorry for driving you up *counts* 3 or 4 blind alleys. ;)
15:50:54 * hackagebot bytestring 0.10.4.1 - Fast, compact, strict and lazy byte strings with a list interface  http://hackage.haskell.org/package/bytestring-0.10.4.1 (DuncanCoutts)
15:56:50 <nschoe> RchrdB, that made me improve, so that's still good to take :)
15:57:02 <Tokenizer> I just installed EclipseFP for Haskell (on Max OSX), Although I already had Haskell installed and ghci configured it downloaded another /Library/Haskel folder with ghci in it ... Personally I don't like duplicate frameworks, does anyone know if this normal or it can be elivated to use the same fraemwork
15:57:32 <RchrdB> nschoe: ah actually, the pureMD5's Binary and Serialize instances both return exactly the 128-bit bytestring that I would expect. :)
15:58:14 <nschoe> RchrdB, ah ? So... why doesn't it work when I try to add them into the database ?
15:59:48 <nschoe> RchrdB, ah ! I'm *stupid* I think, I have just read : "Wrap binary data for use as a bytea value." from the postgresql-simple documentation !
16:01:47 <RchrdB> nschoe: good question, don't know, I'm only just looking at postgresql-simple now :)
16:02:33 <RchrdB> nschoe: btw, how are you doing your DDL?
16:03:40 <nschoe> RchrdB, what's a DDL ?
16:04:15 <RchrdB> SQL term. "DML" = "Data Manipulation Language" = SELECTs, INSERTs, UPDATEs, DELETE statements.
16:04:33 <RchrdB> "DDL" = "Data Definition Language" = "CREATE TABLE ..." statements and anything else that works like them.
16:05:20 <Gurkenglas> http://pastebin.com/rXthxcue how do I do nested where clauses?
16:05:52 <nschoe> RchrdB, ah thanks for the info. Actually I have a .sh file "psql -f sql/init.sql" and a init.sql file in which I have a CREATE TABLE IF NOT EXISTS
16:06:00 <nschoe> RchrdB, why ? Is that bad practise ?
16:06:39 <RchrdB> I have no idea. People have ALL KINDS of practices around how they manage RDBMS tables.
16:06:46 <nschoe> RchrdB, to be honest I come from the world of MySQL and PhpMyAdmin when it comes to Databases, so I'm training myself to use Postgresql and use it in command line. It is a step :-)
16:07:01 <Welkin> RchrdB: are you the same Richard Bird who created lhs?
16:07:08 <RchrdB> Welkin: no, very no
16:07:11 <RchrdB> Barrell, not Bird
16:07:14 <Welkin> haha
16:07:28 <RchrdB> I may have to start going by my middle name on IRC >:|
16:07:46 <Welkin> Gurkenglas: indent the second where clause further
16:08:12 <Welkin> the where clause must be indented further right than the lines to which it applies
16:08:34 <Gurkenglas> Hmkay thx
16:08:55 <Welkin> "triplicate" begine at the "t"
16:15:02 <nschoe> RchrdB, going with the Binary (to wrap for bytea use) and Serialize.encode (to get a BS)  worked !
16:16:14 <RchrdB> Good.
16:16:59 <nschoe> RchrdB, thanks for you help :-)
16:17:04 <RchrdB> No worries.
16:17:05 <nschoe> Gotta go now, see you .
16:17:10 <Gurkenglas> http://pastebin.com/n8sMt5CQ <- It complains that I gave intersperse a String rather than a char in the first argument, and a list of Strings rather than a list of chars in the second argument. ???
16:18:19 <Welkin> look at the types
16:18:29 <Welkin> :t intersperse
16:18:30 <lambdabot> a -> [a] -> [a]
16:18:38 <Welkin> :t intersperse '\n'
16:18:39 <lambdabot> [Char] -> [Char]
16:18:42 <Welkin> :t intersperse "\n"
16:18:43 <lambdabot> [[Char]] -> [[Char]]
16:18:48 <Welkin> you gave it a string
16:18:50 <Welkin> not a character
16:19:08 <Gurkenglas> Indeed. And it complains about that.
16:19:12 <Welkin> characters are wrapped in single quotes
16:19:23 <Gurkenglas> I was intending to give it a string.
16:19:23 <Welkin> strings in double quotes
16:19:52 <Welkin> no, you want to give it a character
16:19:54 <Welkin> not a string
16:20:01 <Welkin> it is expecting a character
16:20:07 <Gurkenglas> But I can only intersperse a list of strings with a string
16:20:26 <Gurkenglas> and sierpinskys is a list of lists of strings
16:20:37 <u-ou> :t either
16:20:38 <lambdabot> (a -> c) -> (b -> c) -> Either a b -> c
16:21:38 <Welkin> in the second argument it is expecting [String]
16:21:57 <Gurkenglas> No, it is expecting String
16:22:24 <Gurkenglas> (!!) is expecting [String] in its first argument because of that
16:24:42 <Gurkenglas> Maybe this is a failure of the typechecker? Let's see if replacing intersperse with (intersperse :: String -> [String] -> ...oh, [String]. I'm missing a concat.
16:26:45 <hunt> could someone tell me what the '|
16:26:50 <hunt> could someone tell me what the '|' means in class Monad m => Stream s m t | s -> t
16:27:11 <hunt> and whats the function of -> in a class definition?
16:27:22 <Welkin> "->" can be read as "to"
16:27:34 <Gurkenglas> (Yes, yes, the typechecker is never wrong most of the time. But trying to prove it wrong still rapidly leads to enlightenment.)
16:27:37 <RchrdB> hunt: functional dependency.
16:27:39 <Wolfgang> It means that the type t is uniquely determined by the type s
16:27:56 <hunt> uniquely determined?
16:28:29 <Adeon> if 's' is some type, then 't' must be some specific type that depends on 's'
16:28:33 <Adeon> as opposed to be chosen freely
16:28:41 <Adeon> or hmm
16:28:47 <hunt> why does haskell need to know that? how does that impact the code
16:28:57 <merijn> I recommend the GHC user guide for examples
16:29:14 <merijn> And/or one of the many functional dependency papers explaining the problem
16:29:50 <Wolfgang> The classic example is multiplication with a matrix and vector
16:29:56 <hunt> "There should be more documentation, but there isn't (yet). Yell if you need it. "
16:30:21 <HeladoDeBrownie> hunt, it avoids ambiguity. You force there to be one instance for a given type s rather than potentially many.
16:31:04 <hunt> ohso instead of the number of possiblle insances being s * m * t its just s * m?
16:31:12 <HeladoDeBrownie> hunt, exactly.
16:31:12 <hunt> what does that allow us to do?
16:31:20 <Wolfgang> right
16:31:34 <merijn> hunt: Below that it has a bunch more examples, also the paper linked there gives a pretty good explanation
16:31:34 <hunt> i cant see the benefits though
16:31:40 <Wolfgang> prevents for example, you creating an instance of matrix vector int
16:31:59 <Wolfgang> for multiplication
16:32:18 <Wolfgang> a matrix multiplied a vector is always a vector
16:32:55 <hunt> what would a reasonable matrix type look like?
16:32:56 <Wolfgang> https://www.haskell.org/haskellwiki/Functional_dependencies
16:33:00 <hunt> ty
16:33:03 <Wolfgang> This is a better explanation
16:33:26 <hunt> yea that looks good, thanks for finding it for me
16:35:46 <Gurkenglas> "Couldn't match expected type `[Char]' with actual type `Int'
16:35:46 <Gurkenglas>     In the first argument of `div', namely `x'"
16:35:55 <Gurkenglas> Why would div expect a [Char]?
16:37:33 <merijn> Gurkenglas: It doesn't
16:37:35 <hunt> ive never read haskell papers before
16:37:38 <hunt> are they worth reading?
16:37:59 <merijn> "expected type" equals "what you gave me" "actual type" is "what it should be"
16:38:01 <hunt> any more than just reading specific tutorials on how things have been implemented
16:38:23 <Axman6> pretty much anything by SPJ is worth reading and very accessibly
16:38:26 <Axman6> s/y/e
16:38:44 <Wolfgang> hunt: sometimes. best if you know what you are looking for before reading rather than just picking up stuff at random
16:39:06 <merijn> hunt: There's a significant number of haskell papers which are 1) accessible/readable with some haskell experience 2) explain problem and solution in-depth and 3) are a lot more reliable than most half-assed blog posts :)
16:39:15 <hunt> also do people here use language extensions very frequently?
16:39:15 <Gurkenglas> ...the ghc designers need some trout slapping.
16:39:22 <benzrf> wwwhy
16:39:26 <benzrf> hunt: yes
16:39:38 <hunt> merijn: although usually im just looking to get the job done and not as curious about the theory
16:40:02 <merijn> hunt: At some point people start doing that, yes. I've reached the point where I'm comfortable having files start with 8 lines of LANGUAGE pragma's :p
16:40:32 <hunt> merijn: does it improve things dramatically?
16:40:38 <Wolfgang> pragmas are pretty normal after a while
16:40:56 <Wolfgang> I use GeneralizedNewtypeDeriving and BangPatterns
16:41:03 <Wolfgang> all the time
16:41:04 <hunt> my issue is that it seems like theyre not as developed and so  not as reliable
16:41:08 <merijn> hunt: "It depends", there's a fair number of extensions which make haskell's type system a lot more expressive
16:41:21 <Axman6> most extensions are quite simple
16:41:28 <Gurkenglas> http://pastebin.com/8KN4CusU <- then how can it think x to be a [Char]?
16:41:34 <bitemyapp> I have a Producer (Either e a) and a fold that works on (Producer a) for some pipes code.
16:41:35 <merijn> hunt: I like enforcing invariants in the type system, so I don't have to think about it
16:41:44 <benzrf> papers are really just professional blog posts
16:41:57 <bitemyapp> how do I fmap my Pipes fold over the first Producer's Either? my attempts to use fmap are confounding me.
16:41:59 <hunt> merijn: invariants as in things that are guarenteed to succeed?
16:42:21 <merijn> hunt: invariants as in "properties which must always be true"
16:42:29 <Wolfgang> benzrf: lol. Pretty sure some authors would bite you if they read that
16:42:35 <merijn> hunt: A simple invariant would be "this list is never empty"
16:42:45 <hunt> merijn: yea ok
16:42:55 <merijn> bitemyapp: Don't, you can use fmap to change the output of a producer
16:43:05 <HeladoDeBrownie> bitemyapp, what is the goal in mind? fmap on a Proxy only affects the final result of the whole computation afaik, not any of the elements produced or consumed
16:43:10 <merijn> bitemyapp: You probably want to write "Pipe (Either e a) a m r"
16:43:21 <merijn> bitemyapp: Which silently drops Left
16:43:37 <bitemyapp> merijn: probably. I was hoping to do so without writing a separate function for it though.
16:43:39 <Gurkenglas> Like, using Natural to gurantee that you never deal with negative numbers?
16:43:51 <Axman6> Gurkenglas: your usage of pad doesn't match its definition; you're giving (div x 3600) in a position where you clearly expect to be passing a string
16:43:53 <merijn> bitemyapp: You might be able to, but I dunno how
16:44:29 <HeladoDeBrownie> bitemyapp, try emailing Tekmo, I've found him to be pretty responsive and he may have it elsewhere even if it's not in the pipes package
16:44:32 <simonator`> hi. do STArrays not support multiple dimensions?
16:44:59 <Gurkenglas> Indeed. So it thought (div x 3600) should be a string, so it thought x would be a string without checking whether String is an Integral as required by div. :I
16:45:26 <HeladoDeBrownie> simonator`, the index type can be a tuple
16:45:28 <Axman6> right; Strings could be Integrals though (GHC doesn't know that doesn't make sense)
16:45:48 <simonator`> Gurkenglas: why would you assume that Strings are Integrals? :)
16:45:57 <merijn> bitemyapp: "filterM :: Monad m => (a -> m Bool) -> Pipe a a m r" and "mapM :: Monad m => (a -> m b) -> Pipe a b m r"
16:46:18 <Wolfgang> hunt: if you are interested in extensions and other things you may not know about Haskell, I recommend this: http://dev.stephendiehl.com/hask/
16:46:21 <Gurkenglas> simonator`, I know they aren't, I'm just said that ghc doesn't immediately notice, but perpetuates the error
16:46:21 <merijn> bitemyapp: You could do "mapM fromLeft . filterM isLeft" or something horrific like that
16:46:29 <simonator`> HeladoDeBrownie: but I'd like it to be an STArray...
16:46:46 <hunt> Wolfgang: ill save that for later
16:46:50 <HeladoDeBrownie> simonator`, yes? You can do "multi-dimensional" STArray. Just choose a tuple for i.
16:46:54 <Gurkenglas> But then it did think that x is an Int, and that div wants a [Char], and merijn lied in <merijn> "expected type" equals "what you gave me" "actual type" is "what it should be"
16:47:17 <simonator`> HeladoDeBrownie: ohh!
16:47:26 <merijn> Gurkenglas: The problem is that "it depends in which direction it's inferring"
16:47:40 <bitemyapp> merijn: I was trying to avoid having to do something that horrifying.
16:47:50 <bitemyapp> merijn: I had started to write that but REALLY did not want to.
16:47:54 <Gurkenglas> merijn, you mean that that stops it from showing the collision at the right place?
16:47:55 <hunt> for parsec parsing a string between quotations, I would ideally like to use "between" but i dont think between can take a "many char", so im wondering if theres a way to do this that *does* use between
16:48:13 <merijn> Gurkenglas: And since almost none of your intermediate expressions have type annotations, GHC is bending your expressions in ridiculous shapes trying to make them fit
16:48:38 <Gurkenglas> Can you have type annotations in where expressions?
16:49:02 <Axman6> yes
16:49:06 <merijn> bitemyapp: Well, the other solution is compose with "forever $ await >>= \case Left _ -> return (); Right x -> yield x"
16:49:39 <Gurkenglas> (It still feels like the typechecker shouldn't accept that a div can output a String and go for div's arguments)
16:50:01 <merijn> Gurkenglas: The thing is, someone could write a Num instance for String and then div would work
16:50:19 <merijn> Gurkenglas: You're asking the compiler to prove "no one ever wrote a String instance for Num anywhere"
16:50:21 <Gurkenglas> But then it should first check whether such a one exists
16:50:31 <merijn> Which is not even true, for example, see acme-php
16:50:54 <merijn> Gurkenglas: That's not the way inference works, it first infers everything THEN sees if the right classes exist
16:50:56 <Gurkenglas> After all it does so eventually, because it still complains if I try to use div with a string argument.
16:51:12 <joelteon> hmm
16:51:13 <Gurkenglas> Yes, and then things like this happen :D
16:51:21 <joelteon> so cabal knows cpphs is in scope but it's not using it
16:51:29 <Gurkenglas> Why wouldnt it check the classes first?
16:51:29 <simonator`> HeladoDeBrownie: so if I do ST s (STArray s (Int, Int) (Int, Int), it complains that (Int, Int) does not have instance Num. this is the type parameter i I assume you speak of.
16:51:30 <joelteon> why would it say "Using cpphs found at" etc. if it's not going to use it
16:51:42 <geekosaur> haskell uses the same rules as it would if you were compiling a library, not different rules in this case
16:52:02 <geekosaur> and in the case of a library, the necessary assertion is "nobody ever has or ever will provide such an instance"
16:52:10 <joelteon> do I have to specify the c preprocessor myself
16:53:38 <simonator`> HeladoDeBrownie: ah, I misunderstood the parameters. :) only one of them needs to be (Int, Int)
16:54:03 <stephenmac7> I have a question: I have a list of values which I would like to insert into an html document with Text.Pandoc.Walk.walk (http://hackage.haskell.org/package/pandoc-types-1.12.4.1/docs/Text-Pandoc-Walk.html) but don't know how to remove the head of the values when they are used
16:57:46 <HeladoDeBrownie> simonator`, was afk, but yep, seems like you got it
17:05:24 <SvenskFi1k> Hey guys, anyone mind telling me if this is normal? My cpu temp spikes to over 100° playing a game of chess (rMBP late-2013) : http://cl.ly/3F2o3t3t3C2x
17:06:00 <geekosaur> why are you asking in here
17:06:11 <SvenskFi1k> Damn, thought I joined #apple
17:06:13 <SvenskFi1k> Ignore me
17:06:17 <SvenskFi1k> Sorry
17:07:39 <Fuuzetsu> it's OK, it's normal behaviour anyway, late 2013 is way past the end of life so you should buy a new machine
17:10:57 * hackagebot ShellCheck 0.3.5 - Shell script analysis tool  http://hackage.haskell.org/package/ShellCheck-0.3.5 (vidarhol)
17:11:58 <indiagreen> Fuuzetsu: I don't think late 2013 is EOL, otherwise it wouldn't have got the OS X update
17:12:46 <merijn> indiagreen: Fuuzetsu is trolling
17:12:53 <Fuuzetsu> ``trolling''
17:12:54 <indiagreen> merjin: I know
17:13:02 <indiagreen> * merijn
17:13:03 <indiagreen> sorry
17:13:09 <Fuuzetsu> pretty sure some iPads that were still in warranty are no longer eligible for updates
17:13:45 <merijn> Fuuzetsu: I have colleagues installing Yosemite without difficulty on 2006 MacBooks and getting pretty solid performance
17:14:24 <merijn> Support goes back further than that. I think only PPC and the first generation after that is EOL.
17:17:26 <begriffs> How do I define this type? It's meant to contain a sql query plus the values that fill in "?" parameters. type CompleteQuery = (Query, ToRow a)
17:18:22 <begriffs> This also fails: type CompleteQuery = ToRow a => (Query, a)
17:18:46 <Fuuzetsu> type CompleteQuery a = (Query, ToRow a)? You're not giving enough info.
17:19:18 <geekosaur> do you really want a `type` there? vs. a `data` (and, if you want it to bring a constraint into scope, possibly a GADT)?
17:19:49 <Fuuzetsu> would you bring in GADTs just for the existential constraint? I always wonder
17:19:54 <begriffs> The reason I'm doing this is to treat it as a monoid and have query transformers to add where clauses and limits. So it might be nice if could mix the a's.
17:20:02 <merijn> Any volunteers care to proofread some documentation for me?
17:20:10 <Fuuzetsu> ya sure
17:20:24 <geekosaur> not like data does anything sane with them, and type doesn't work well with constraints either thanks to scoping
17:20:40 <merijn> Fuuzetsu: https://phabricator.haskell.org/D442 the flags.xml/using.xml/glasgow_exts.xml diffs
17:20:53 <merijn> (I don't think docs are auto build yet :\)
17:21:14 <Fuuzetsu> IIRC they will be uploaded somewhere starting soon
17:22:55 <begriffs> Fuuzetsu: it complains about the argument saying it should have kind * but actually has kind Constraint.
17:23:04 <merijn> Fuuzetsu: Yeah, but I dunno whether that will be before the 7.10 code freeze and I wanna sneak this in before then :p
17:29:31 <torpet> im having a list like [1,2,3] which i want to multiplay with another list [3,4,5], but the returning list should result in [3,4,4,5,5,5]
17:29:36 <torpet> how can i achieve that?
17:29:58 <HeladoDeBrownie> torpet, what do you mean by "multiplay"?
17:29:59 <exio4> "multiplay"?
17:29:59 <Gurkenglas> http://pastebin.com/fUdRSGqj <- How is this pattern match nonexhaustive?
17:30:08 <torpet> *multiply
17:30:14 <HeladoDeBrownie> torpet, what do you mean by "multiply"?
17:30:33 <HeladoDeBrownie> Oh, I think I see the pattern now.
17:30:36 <torpet> 1*3, 2 times value 4 in new list list, 3 times value 5 in new list
17:30:56 <HeladoDeBrownie> @type replicate
17:30:57 <lambdabot> Int -> a -> [a]
17:30:57 <simonator`> is there a way to get an MArray's size, or should I have saved it alongside?
17:30:59 <HeladoDeBrownie> That will help.
17:31:12 <simonator`> or rather, its range, I mean.
17:31:18 <HeladoDeBrownie> I think you can do this with replicate, zipWith, and concat.
17:31:21 <Gurkenglas> > concat $ zipWith replicate [1,2,3] [3,4,5]
17:31:23 <lambdabot>  [3,4,4,5,5,5]
17:31:32 <HeladoDeBrownie> Yep, just so. :)
17:32:40 <HeladoDeBrownie> Gurkenglas, because of a typo countCHange
17:33:07 <Gurkenglas> Ah. :s
17:35:08 <hunt> is there a lookup function on [(a,b)]?
17:35:13 <hunt> that already exists
17:35:14 <HeladoDeBrownie> @type lookup
17:35:15 <lambdabot> Eq a => a -> [(a, b)] -> Maybe b
17:35:20 <HeladoDeBrownie> Prelude.lookup
17:35:22 <hunt> perfect thanks
17:35:32 <hunt> i just assumed it wouldnt be there
17:35:35 <hunt> shouldve checked
17:37:02 <simonator`> my experience with the standard library is that it usually is there. if not in some obvious way, then by combination of some abstract or generic functions :)
17:37:27 <Gurkenglas> http://hackage.haskell.org/package/base-4.7.0.1/docs/Data-Foldable.html <- There is no tree listed under the instances of Foldable?
17:38:57 <Fuuzetsu> merijn: left comments on Phabricator, mostly just some nitpicks or clarifications so feel free to ignore them
17:40:43 <stephenmac7> Maybe I should ask in a different way: how could I maintain a state while walking a pandoc data structure?
17:40:50 <pjdelport> Gurkenglas: The list there only includes the instances defined in base (or that are visible to Haddock at the time of generation, presumably)
17:41:24 <stephenmac7> The only way I can think of is re-writing Text.Pandoc.Walk in continuation passing style, which is hardly a good solution
17:41:30 <pjdelport> Gurkenglas: Other packages and types will list their foldable instance under their types, where defined. So Data.Tree's instance is listed under http://hackage.haskell.org/package/containers-0.5.5.1/docs/Data-Tree.html for example.
17:42:57 <indiagreen> stephenmac7: what about using walkM?
17:42:59 <Fuuzetsu> pjdelport: Gurkenglas: Haddock will only show the things that are ‘in scope’ at generation time, if the module with the instance was somehow imported (by proxy or whatever) then it would show up
17:43:07 <Fuuzetsu> but base doesn't import containers or we'd have problems ;)
17:43:11 <stephenmac7> indiagreen: How would that work?
17:43:26 <indiagreen> I don't know, you could use it with State monad or something if you want state
17:43:47 <simonator`> if I use MArray's mapArray, I'll always get a copy, right? is there a way I can run an ST-action for each index in an MArray? (E.g. for updating that array in that cell) currently I'm doing a forM_ across [(0,0), (0,1), ..., (1,0), (1,1), ...]
17:43:57 <stephenmac7> indiagreen: Basically, I have a list which needs to be inserted in order into the structure
17:44:12 <simonator`> and this feels unsatisfying because I'm creating some big lists every time I map.
17:44:18 <stephenmac7> I'm not exactly a haskell pro, so I'm not sure how to make the parts fit together
17:45:15 <simonator`> I suppose I could just solve it recursively without creating lists.
17:45:58 <merijn> Fuuzetsu: ok, thanks!
17:46:52 <indiagreen> stephenmac7: well, you just use State [a] as your monad, and do “modify tail” after each update, so your function would be “walkM (\x -> do {x' <- gets head; modify tail; return x'})”
17:47:30 <hunt> i have defined around 15 functions of the form x u -> u {appId = x}
17:47:34 <stephenmac7> indiagreen: Let me try it. I'll come back if it doesn't work :). Thanks
17:47:38 <hunt> is there a way to generalize this in some way
17:47:48 <Fuuzetsu> lens
17:47:57 <hunt> god damnit
17:48:03 <Fuuzetsu> ;P
17:48:21 <Hijiri> I've still yet to learn lens
17:48:26 <hunt> me too
17:48:34 <hunt> im going to put it off and accept this bloat
17:48:35 <Fuuzetsu> that's just u & appId .~ x
17:48:46 <Fuuzetsu> (for lens appId)
17:49:06 <hunt> Fuuzetsu: dont i have to define lenses for every field too?
17:49:11 <torpet> http://lpaste.net/3754356378018250752
17:49:18 <Fuuzetsu> there's TemplateHaskell that does it for you
17:49:27 <Fuuzetsu> makeLenses 'YourType and you're done
17:49:35 <Fuuzetsu> or ''YourType, don't remember
17:49:44 <merijn> Double quote
17:49:44 <torpet> 65:53: Couldn't match type ‘Integer’ with ‘Int’
17:51:06 <torpet> ?
17:51:20 <lpsmith> begriffs, if you want to treat it as a monoid,  you might try   type CompleteQuery = (Query, [Action])
17:51:31 <merijn> torpet: Those two types are not the same
17:51:42 <torpet> i know, but i dont get where the conversion is taking palce
17:51:48 <kadoban> torpet: They're different types. Int is like 32 bit or 64 bit plain machine integer type, I forget which. Integer is infinite size
17:52:00 <torpet> kadoban: http://lpaste.net/3754356378018250752
17:52:08 <torpet> i dont see where this is happening
17:52:09 <merijn> torpet: !! wants an Int
17:52:30 <merijn> torpet: oh, hmm, that's probably not it
17:52:42 <merijn> torpet: Include the full error + lines numbers
17:52:43 <lpsmith> begriffs, there is a ToField instance for Action,  you can just pass a list of Actions (the result of toRow) as the parameters of a query
17:53:08 <kadoban> There's usually generalized versions of the prelude operators/functions that take int, but I don't know what that one is called.
17:53:11 <lpsmith> i.e.    query conn sql params == query conn sql (toRow params)
17:53:42 <torpet> merijn:
17:53:43 <torpet> http://lpaste.net/2031457975536713728
17:54:16 <lpsmith> of course, you _might_ want to use a Difference List of params instead, for more efficent concatination
17:54:28 <merijn> torpet: Oh!
17:54:30 <merijn> :t replicate
17:54:31 <lambdabot> Int -> a -> [a]
17:54:44 <kadoban> Ah, yeah that must be it
17:55:24 <kadoban> torpet: When I can't find the problem, I just throw more type annotations on too, like if you annotode toValue', that would narrow it down for you usually. Just FYI.
17:55:30 <merijn> torpet: replicate takes Int as first argument, since you're passing an item from the list you pass to toValue as value for replicate, it infers "toValue :: [Int] -> Int -> ?" (whatever it's result is)
17:56:00 <merijn> torpet: And then it complains that on line 65 you call toValue with 'xs :: [Integer]'
17:57:58 <torpet> so what am i supposed to do?
17:58:10 <merijn> torpet: Easiest is probably
17:58:10 <torpet> i get that replicate wants an Int
17:58:14 <merijn> :t fromIntegral
17:58:15 <lambdabot> (Num b, Integral a) => a -> b
17:58:27 <merijn> :t fromIntegral :: Integer -> Int
17:58:28 <lambdabot> Integer -> Int
17:58:43 <merijn> torpet: Although, be aware of potential overflow problems
17:58:55 <merijn> > maxBound :: Int
17:58:57 <lambdabot>  9223372036854775807
17:59:06 <torpet> merijn: thx, im using very small values
17:59:17 <merijn> > 9223372036854775817 :: Int -- whoops
17:59:19 <lambdabot>  -9223372036854775799
17:59:54 <merijn> torpet: Alternatively, use a list of Int as input to your function, instead of [Integer] :)
18:00:42 <Gurkenglas> How do I quicken this? http://pastebin.com/rRdk8mwS
18:01:37 <Gurkenglas> (Nevermind the fromJust, an artifact from the interfacing with the codewars site)
18:03:56 <torpet> i cant fix the problem
18:04:23 <Gurkenglas> (Hmm, maybe I could memoize chooseMove...)
18:05:35 <merijn> torpet: just replace "replicate (xs!!n)" with "replicate (fromIntegral (xs!!n))"
18:07:55 <Gurkenglas> Every data structure that does not rely on function is memoized, right?
18:08:00 <Gurkenglas> *functions
18:08:07 <merijn> uh
18:08:12 <merijn> What does that even mean?
18:08:39 <hunt> midentity or something?
18:08:39 <hunt> whats the identity monad called again?
18:08:50 <merijn> hunt: Identity? :D
18:09:17 <hunt> hmmm... but im looking for a value somehow not a type
18:09:19 <merijn> > return 'c' :: Identity Char
18:09:20 <Gurkenglas> If I make some data definition that doesn't use functions anywhere, and reference the same part of it twice, it won't compute it twice, right?
18:09:21 <lambdabot>  Identity {runIdentity = 'c'}
18:09:23 <hunt> oh right return
18:09:40 <michaelt> Identity has a 'Show' instance now, nice.
18:10:04 <merijn> Gurkenglas: If you do "let x = ?? in (x, x)" it will only compute x once, yes
18:11:43 <hunt> isnt there an identity function as well
18:11:47 <hunt> a -> a
18:11:49 <merijn> :t id
18:11:50 <lambdabot> a -> a
18:11:52 <Gurkenglas> I'm planning to memoize the chooseMove in http://pastebin.com/rRdk8mwS cause apparently the code is not fast enough for codewars. I'm planning to make a... huh. Simply a tree of the outputs of chooseMove to an ascending list. (ascending because the order of the state is irrelevant)
18:11:52 <hunt> oh right
18:11:55 <hunt> im rusty
18:12:00 <hunt> sorry about all the simple questions
18:12:00 <merijn> hunt: Also, hoogle
18:12:04 <merijn> @hoogle a -> a
18:12:06 <lambdabot> Prelude id :: a -> a
18:12:06 <lambdabot> Data.Function id :: a -> a
18:12:06 <lambdabot> GHC.Exts breakpoint :: a -> a
18:12:13 <hunt> nice ill go there first
18:12:19 <merijn> Hoogle is always your friend :)
18:12:32 <hunt> true
18:26:06 <hunt> is it possible to export everything in a module? (..) doesnt seem to work, perhaps some other way?
18:26:27 <indiagreen> hunt: just don't write the export list
18:26:32 <indiagreen> “module Module where”
18:26:34 <hunt> ahhh
18:26:37 <hunt> thanks
18:27:36 <crobbins> hunt: something else you might run into, if you are trying to export all names imported from another module, you can do something like `module MyModule ( module SomeImport ) where`
18:27:55 <crobbins> that may not be the exact syntax, but it's something close to that
18:28:23 <Gurkenglas> Does some library provide a function that takes a list and returns the permutation that sorts it?
18:28:42 <dramforever> > sort [5,2,3,1,4]
18:28:44 <lambdabot>  [1,2,3,4,5]
18:28:52 <Gurkenglas> Yeah, but now the ordering is lost.
18:28:58 <dramforever> ?
18:29:17 <dramforever> Gurkenglas: what do you mean by "lost"
18:29:20 <merijn> Gurkenglas: What do you mean "the ordering is lost"?
18:29:43 <nshepperd> > map snd . sort $ zip [5.2,3,1,4] [0..]
18:29:45 <lambdabot>  [2,1,3,0]
18:29:54 <Gurkenglas> Thanks
18:30:01 <begriffs> lpsmith: cool, I'll give that a try
18:30:18 <Gurkenglas> (Brilliant! Shoulda thought of that myself)
18:30:20 <Gurkenglas> But let me explain myself
18:30:26 <dramforever> wait a min...
18:30:33 <dramforever> oh
18:31:03 <Gurkenglas> I have a game state [Int] where changing the order of the ints changes the winning strategy only by that same permutation
18:31:16 <hunt> crobbins: thanks
18:31:23 <hunt> crobbins: that probably will be helpful
18:31:50 <Gurkenglas> So I wanted to save the first move of the winning strategy to each state only for the lists in ascending order; then for the lookup order the list, find the winning move, and invert the permutation that the sorter did to get the winning move for the actual state
18:33:11 <Gurkenglas> (Oh. Couldn't have thought of that myself as I wasn't aware that (Ord a => (a,b)) is an instance of Ord)
18:33:42 <Gurkenglas> (... it's probably ((Ord a,Ord b) => (a,b)) with lexicographic ordering)
18:34:00 <nshepperd> yeah that
18:34:10 <dramforever> > (1, const) < (2, const)
18:34:11 <lambdabot>  No instance for (GHC.Classes.Ord (a0 -> b0 -> a0))
18:34:11 <lambdabot>    arising from a use of ‘GHC.Classes.<’
18:35:13 <barrucadu> Is this a bug? it seems that annotations can't appear until after the module declaration (and, by experimentation, after all imports): http://lpaste.net/1127446150903758848
18:35:50 <barrucadu> Even if it's the intended behaviour, it's not mentioned in the documentation
18:36:55 <nshepperd> hmm, if you want to invert the permutation, I guess sorting it twice shoud work
18:37:22 <Gurkenglas> nshepperd is stealing my insights before I have them!
18:37:37 <lpaste> dramforever pasted “What's a negative occurrence?” at http://lpaste.net/114015
18:37:52 <nshepperd> soory :]
18:37:57 <lpaste> dramforever revised “What's a negative occurrence?”: “No title” at http://lpaste.net/114015
18:38:00 <hunt> hey guys in parsec is there a function that runs the parser and returns the final state?
18:38:37 <dramforever> so what's a negative occurrence?
18:39:22 <dramforever> hunt: maybe you can return the result along with the state
18:39:52 <nshepperd> > let inversep = map snd . sort . flip zip [0..] in inversep (inversep [5, 2, 3, 1, 4])
18:39:53 <lambdabot>  [4,1,2,0,3]
18:39:56 <hunt> dramforever: im just going to end with getState unless theres a function for it
18:40:50 <dramforever> hunt: parsec docs say that runParserT is the most general way to run a parser
18:40:53 <merijn> barrucadu: I'm not sure, have you checked Trac whether someone has reported this?
18:41:10 <dramforever> and it does not return the final state
18:41:13 <michaelt> dramforever: P is in a negative position in (P -> Void)
18:41:49 <dramforever> michaelt: Is there any clear "tutorial"ish explaination for this?
18:42:16 <int-e> barrucadu: I suspect that's intentional; the annotation is an expression, and expressions generally make little sense before imports. It's not documented well, I think; {-# ANN #-} pragmas are treated as toplevel declarations (that's how they appear in ghc's parser).
18:42:27 <michaelt> hm, maybe google 'strictly positive functor' ; let me think
18:43:02 <merijn> Documentation improvement patches welcome ;)
18:44:18 <michaelt> dramforever: here's a not too helpful discussion in luqui's answer http://stackoverflow.com/questions/2583337/strictly-positive-in-agda
18:44:41 <dramforever> hmm...agda question tagged haskell
18:44:54 <Fuuzetsu> you need positivity checking for termination
18:44:55 <dramforever> people are not only misusing haskell
18:45:05 <dramforever> they are even misusing the word "haskell"
18:45:05 <Fuuzetsu> you can derive ⊥ otherwise
18:45:49 <Fuuzetsu> http://oxij.org/note/BrutalDepTypes/ search for Curry's Paradox
18:47:02 <dramforever> Fuuzetsu: but nothing for --no-positivity-check
18:47:11 <zack__> So I'm using Network.CGI and I can't figure out how to receive a file. ( sent using an html form's file input type) any ideas?
18:48:29 <Fuuzetsu> dramforever: ?
18:48:37 <Fuuzetsu> maybe I should read up
18:49:08 <gcganley> is there any 'defacto' haskell .emacs.d configuration? akin to emacs-live for clojure
18:49:31 <Welkin> gcganley: just enable haskell-mode
18:49:33 <dramforever> Fuuzetsu: no explaination
18:49:41 <Welkin> and whatever other haskell plugins you like
18:49:58 <Fuuzetsu> dramforever: the link I posted shows code which *is* the explanation
18:50:00 <dramforever> so any advice on them?
18:50:35 <dramforever> Fuuzetsu: well, I posted some code which is *also* the explaination, in your opinion
18:50:39 <gcganley> Welkin: ok, i didnt know if there was a repository everyone was using, so haskell-mode is all i need for haskell integration? just curious about how complete it is
18:50:47 <Welkin> yes
18:50:51 <Fuuzetsu> dramforever: sure but in Haskell you can just undefined :: Void
18:51:00 <dramforever> hm...
18:51:00 <Welkin> search melpa or marmalade for others
18:51:03 <Welkin> just search "haskell"
18:51:23 <gcganley> Welkin: ok thanks
18:51:27 <dramforever> Fuuzetsu: Void with no recursion, in a way
18:51:31 <Welkin> there is also hlint
18:51:59 <gcganley> Welkin: I thought that was a command line util, are there emacs bindings?
18:52:02 <dramforever> well, It's okay. I think I can accept the "negative occurrence" thing now
18:52:23 <Welkin> there is a package that runs your code through hlint and autocompiles as you type
18:52:35 <Welkin> to notify you of errors or warnings
18:52:51 <Welkin> I haven't used it
18:52:53 <Fuuzetsu> dramforever: I'm just not sure what answer you're after
18:52:56 <Welkin> although I did install it
18:53:02 <Welkin> I'd like to play with it some more though
18:53:06 <merijn> The only way to re-export something imported in a module is an explicit export list, no?
18:53:23 <dramforever> Fuuzetsu: A on the left side of a function arrow is negative
18:53:38 <dmwit> merijn: No; you can also export an entire module.
18:53:41 <dmwit> oh
18:53:50 <dmwit> merijn: Sorry, I misunderstood the question. That sounds right.
18:53:52 <dramforever> my opinion: because a function "needs" it's argument
18:53:56 <Welkin> merijn: I believe so, or `import Data.Text as Import` for module Import
18:53:59 <Welkin> that seems to work too
18:54:00 <merijn> dmwit: That sucks donkey balls :\
18:54:10 <Welkin> including it in the namespace
18:54:18 <dmwit> merijn: Perhaps your complaint is that with an explicit export list, you have to write every binding in the module in your explicit list.
18:54:20 <Fuuzetsu> dramforever: it just means you have a type like this (P -> a) -> P, with P in negative position (to the left of an arrow)
18:54:28 <Fuuzetsu> why that's bad is demonstrated by your own snippet
18:54:29 <merijn> dmwit: Correct
18:54:31 <dmwit> merijn: In which case let me introduce you to the magic that is "module Foo (module Foo) where ...".
18:54:41 <merijn> dmwit: I know that
18:54:41 <dmwit> merijn: The Devs Thought Of Everything
18:54:49 <dramforever> Fuuzetsu: yep, that' about what I'm thinking
18:54:58 <Fuuzetsu> that's about all there is to it
18:55:06 <merijn> dmwit: The problem is: I have a module with like 40-50 exports and now I need to explicitly list all of them to re-export a single name from another module
18:55:15 <dmwit> merijn: no
18:55:27 <dmwit> merijn: module Foo (module Foo) where behaves *exactly* the same as module Foo where.
18:55:46 <merijn> dmwit: Ah, it does? :D
18:55:51 <dmwit> merijn: So just module Foo (module Foo, nameFromOtherModule) where, and you're done.
18:55:51 <Fuuzetsu> not with package imports!
18:59:17 <stephenmac7> indiagreen: Are you still there?
18:59:25 <indiagreen> yep
18:59:31 <merijn> Man, will this whole new record field thing be going into 7.10? Finding unique field names is really hard :(
18:59:40 <stephenmac7> Okay, so I'm close, but can't iron out this last error.
19:00:01 <dramforever> merijn: well, try to use prefixes
19:00:02 <indiagreen> paste your code then
19:00:11 <int-e> > [1..] >>= replicateM ['a'..'z']
19:00:13 <lambdabot>  Couldn't match expected type ‘GHC.Types.Int’
19:00:13 <lambdabot>              with actual type ‘[GHC.Types.Char]’
19:00:21 <int-e> > [1..] >>= (`replicateM` ['a'..'z'])
19:00:23 <lambdabot>  ["a","b","c","d","e","f","g","h","i","j","k","l","m","n","o","p","q","r","s"...
19:00:37 <dmwit> > [1..] >>= (`replicateM` "abc")
19:00:39 <lambdabot>  ["a","b","c","aa","ab","ac","ba","bb","bc","ca","cb","cc","aaa","aab","aac",...
19:00:57 <dramforever> data GameState = GameState { gsFoo :: Foo, gsBar :: Bar }
19:01:00 <int-e> seems easy enough ;-)
19:01:11 <dmwit> You know what's better than prefixes chosen by the library author? Prefixes chosen by the library user.
19:01:31 <stephenmac7> indiagreen: Here it is: http://lpaste.net/114017 the relevant lines are 157-169
19:01:41 <dmwit> import qualified Merijn's.Magic.Module (GameState(..)) as MMM
19:01:43 <int-e> dmwit: fine, as long as you don't name your types T...
19:01:54 <stephenmac7> This is the error: http://lpaste.net/114019
19:02:43 <dmwit> int-e: I'm put in mind of that TNG moment when Picard shouts something like, "The line must be drawn HERE! This far, and no farther!".
19:03:18 <dramforever> stephenmac7: change >> to >>+
19:03:20 <dramforever> stephenmac7: change >> to >>=
19:03:34 <dramforever> sorry, >>= is the right one
19:03:34 <Gurkenglas> How do I add a type annotation to a where clause definition?
19:03:38 <int-e> dmwit: that sounds about right.
19:03:43 <dramforever> Gurkenglas:
19:03:48 <dramforever> x = y
19:03:53 <dramforever>   where y :: Int
19:03:56 <geekosaur> Gurkenglas, sane way you do at the top level. indentation must match
19:03:59 <dramforever>        y = 33
19:04:00 <stephenmac7> dramforever: But return . Str . unpack $ begin `append` thisSingle `append` end isn't a function is it?
19:04:13 <Gurkenglas> kthx. I'll assume dram wanted another whitespace there
19:04:19 <dramforever> yeah
19:04:32 <dramforever> the irc prompt and my nick isn't the same length
19:05:12 <stephenmac7> indiagreen: Sorry, it's a bit messy. I'm new to haskell, as you can probably tell.
19:05:24 <stephenmac7> I'm also new to actually having to think while programming :P
19:05:49 <texasmynsted> What module(s) should I look at for distributed computing over the Internet?  I see the actor module, and I have used akka in scala, but I wonder if that is the best approach.
19:06:02 * hackagebot system-fileio 0.3.15 - Consistent filesystem interaction across GHC versions  http://hackage.haskell.org/package/system-fileio-0.3.15 (JohnMillikin)
19:06:09 <dmwit> texasmynsted: Cloud Haskell
19:06:10 <zack__> Does anyone know a way to receive files that are sent using an Http post request? I'm not seeing a way to do it using Network.CGI
19:06:26 <dmwit> ?wiki CloudHaskell
19:06:26 <lambdabot> http://www.haskell.org/haskellwiki/CloudHaskell
19:06:59 <indiagreen> stephenmac7: $ has lower priority than >>
19:07:17 <indiagreen> take “return . Str . unpack $ begin `append` thisSingle `append` end” in parens
19:07:23 <merijn> stephenmac7: My recommendation: Break up those insane lines
19:07:24 <indiagreen> s/take/put/
19:07:51 <stephenmac7> merijn: I don't understand the whitespace rules in haskell so I always get errors when I try
19:07:55 <dmwit> zack__: Huh. I would have expected getBody or getBodyFPS to work for that.
19:07:59 <dmwit> zack__: What goes wrong?
19:08:03 <merijn> stephenmac7: I don't mean "linewrap"
19:08:14 <merijn> stephenmac7: I mean: Define local stuff in where clause and use that
19:08:31 <Gurkenglas> https://www.fpcomplete.com/user/Gurkenglas/misc <- Why does it want Enum and Num instances of (Int,Int)?
19:08:34 <merijn> stephenmac7: There's too much stuff going on, making it hard to see what every piece is doing
19:08:41 <zack__> I figured it was getMultifps
19:08:43 <texasmynsted> hmm.  reading about cloudhaskell
19:08:46 <zack__> I'll give  body a try
19:08:49 <texasmynsted> https://haskell-distributed.github.io/tutorials/1ch.html
19:09:10 <merijn> stephenmac7: Also, a good explanation of whitespace rules: https://en.wikibooks.org/wiki/Haskell/Indentation
19:09:12 <Gurkenglas> (Can other people write stuff into that in real time, like on google docs?)
19:09:28 <dmwit> Gurkenglas: map snd (zip list [0..]) is something like [0..].
19:09:36 <dmwit> Gurkenglas: You ask for this to have type [(Int, Int)].
19:09:58 <dmwit> Gurkenglas: For this to work, you must have 0 :: (Int, Int) (hence the Num requirement) and you must be able to do enumFrom (hence the Enum requirement).
19:10:42 <dmwit> Gurkenglas: Perhaps you do not want to have the "map snd" part at all...?
19:10:46 <Gurkenglas> I ask for (zip list [0..]) to have type [(Int, Int)], yes. Why does that mean 0 must have type (Int, Int)?
19:10:56 <stephenmac7> indiagreen: So, it surprisingly works.
19:10:59 <Gurkenglas> Oh, yes. I'm stupid.
19:11:14 <stephenmac7> I'm not sure I completely understand why though
19:11:32 <stephenmac7> I have a hard time keeping all those pieces in my brain at the same time.
19:12:01 <dramforever> We all have. when in doubt put ( ) aroung them
19:12:12 <dramforever> around
19:13:36 <stephenmac7> dramforever: No, I'm saying the whole concept
19:13:44 <dramforever> oh
19:13:50 <dramforever> > succ (1,2)
19:13:51 <lambdabot>  No instance for (GHC.Show.Show t1)
19:13:51 <lambdabot>    arising from a use of ‘M663847509222912949413613.show_M6638475092229129494...
19:13:51 <lambdabot>  The type variable ‘t1’ is ambiguous
19:13:51 <lambdabot>  Note: there are several potential instances:
19:13:51 <lambdabot>    instance [safe] GHC.Show.Show
19:13:56 <stephenmac7> Functional programming doesn't fit neatly inside my head
19:14:33 <dmwit> Is understanding functional programming a goal of yours?
19:14:38 * indiagreen wonders whether to say that “Detatch” should be “Detach” or not
19:14:56 <dmwit> I ask because it is perfectly possible to use the imperative fragment of Haskell if all you want is the beautiful type system.
19:15:24 <dramforever> IMO monads can make clean code
19:15:29 <dramforever> if used wisely
19:15:31 <indiagreen> dmwit: it's harder when you also want to use libraries which were designed around functional concepts
19:15:38 <dmwit> Very hard, yes.
19:15:52 <stephenmac7> dmwit: Yes, but that's the thing. It's not the functional as much as it is the types.
19:16:02 <Fuuzetsu> I think it's pretty easy to write imperative programs if you want to
19:16:17 <Fuuzetsu> because you only worry about the imperative bit you're writing, not the imperative bits of everything you use
19:16:22 <dmwit> I think it's not so hard to pick libraries which are not designed around functional concepts, though.
19:16:38 <dramforever> hmm...Why there's special notation for monads and arrows, but nothing for applicatives?
19:16:59 <dramforever> why idiom brackets didn't go into ghc?
19:16:59 <indiagreen> dramforever: there's applicative do in GHC 7.10
19:17:03 <dramforever> ?
19:17:04 <Fuuzetsu> because applicatives came in later and no one implemented such a thing yet; soon though
19:17:04 <dmwit> dramforever: It's coming to a GHC near you soon.
19:17:16 <stephenmac7> dmwit: Well, if I wanted imperative programming I would be using something else
19:17:27 <dramforever> where can I read about it
19:17:33 * dmwit nods agreeably towards stephenmac7
19:17:37 <indiagreen> https://ghc.haskell.org/trac/ghc/wiki/ApplicativeDo
19:17:46 <stephenmac7> It's really thinking about the types, especially if they have a name that doesn't include -> but happen to be functions
19:17:47 <dramforever> wow
19:17:49 <stephenmac7> Like the State monad
19:17:50 <dmwit> In that case, let's cram your head full until it's big enough to fit functional programming. ;-)
19:18:11 <dmwit> ah, State(T)
19:18:27 <dmwit> It's a shame that it has to be so overengineered to fit in well with the Haskell ecosystem.
19:18:28 <indiagreen> stephenmac7: I think you can use State without really knowing it's a function
19:18:41 <dmwit> The idea itself is pretty simple, if you can get past all the syntax noise required.
19:18:43 <dramforever> stephenmac7: get , put and modify
19:19:21 <dmwit> I have a nice blog post about it bookmarked somewhere around here, if you're interested.
19:20:04 <stephenmac7> dramforever: But that's the issue. I wrote the above code, knowing a bit of background about State, but I can't visualize the operations
19:20:16 <dramforever> visualize/
19:20:17 <dramforever> ?
19:20:31 <stephenmac7> Like, completely understand the flow of values
19:20:46 <dmwit> Yes, State is easier to use when you understand it.
19:20:53 <dramforever> well...
19:21:00 <dmwit> Have you implemented the monad operations for it yourself, by the way?
19:21:08 <stephenmac7> Or, even worse, the applicative instance of ((->) r)
19:21:11 <dramforever> how do you understand those imperative stuff, anyway
19:21:13 <dmwit> Or for the simplified types that don't have newtype noise and Identity in the way?
19:21:51 <dramforever> stephenmac7: do you understand assignment in imperative languages?
19:21:59 <stephenmac7> Yes
19:22:13 <dramforever> then how come you don't understand State(T)
19:22:24 <dmwit> Because they're implemented completely differently under the hood?
19:22:36 <stephenmac7> Imperative seems easier to understand because you can tuck away information or state without having to worry about them
19:22:53 <dramforever> stephenmac7: in haskell you do the same
19:23:06 <Gurkenglas> https://www.fpcomplete.com/user/Gurkenglas/misc It said the drawing would be neat! Why isn't it neat :(
19:23:08 <dmwit> stephenmac7: You might like http://goodmath.scientopia.org/2007/01/29/more-monads-stateful-programming/
19:23:19 <dmwit> stephenmac7: I also found the All About Monads explanation of State pretty good.
19:23:19 <stephenmac7> So, in this example, I could just pass in a mutable list and not have to worry about how to make it bubble back up to the calling function
19:23:24 <dmwit> ?where AAM
19:23:25 <lambdabot> http://www.haskell.org/haskellwiki/All_About_Monads
19:23:56 <dramforever> stephenmac7: it bubbles if the caller is also in the same State
19:24:11 <stephenmac7> dramforever: But that's hidden from you
19:24:12 <dramforever> so it's like a explicit "globe"
19:24:38 <Gurkenglas> Oh wait, I think I need to commit before anyone clicking the link sees the changes.
19:24:45 <dramforever> stephenmac7: hidden??
19:24:56 <stephenmac7> In an imperative language, I mean
19:25:23 <dramforever> hm...
19:26:02 <merijn> stephenmac7: oh, I have homework for learning to understand State :)
19:26:02 <dramforever> stephenmac7: why you like hidden stuff?
19:26:03 * hackagebot nagios-check 0.1.0.0 - Package for writing monitoring plugins  http://hackage.haskell.org/package/nagios-check-0.1.0.0 (fractalcat)
19:26:52 <merijn> stephenmac7: If you wanna understand State, implement the following things: https://gist.github.com/merijn/098106abd45c940dab09
19:26:53 <stephenmac7> dramforever: I know it's bad, which is why I've been trying so hard to understand this stuff (and making a useless madlib application)
19:27:17 <dramforever> stephenmac7: return rather than modifying the original
19:27:29 <stephenmac7> Exactly
19:27:36 <stephenmac7> merijn: I'll try it
19:27:41 <Gurkenglas> https://www.fpcomplete.com/user/Gurkenglas/misc <- There. Start the thing and explain it. (Why is it showing me a "thumbs up, restart, stop" icon row instead of "thumbs up, play"? stop does nothing, restart... does nothing? Did I break it with a nonhalting program?
19:27:50 <dramforever> we construct a state from the initial state, and it also provides a result
19:28:22 <stephenmac7> But it's not state as much as it is having everything packaged into one or a few values in every line of code.
19:28:45 <stephenmac7> Maybe I should take the advice to break things down further... maybe add explicit type definitions on more than top level functions
19:29:21 <dmwit> Gurkenglas: Uh, did you maybe mean "putStr" instead of "print"?
19:32:14 <dramforever> stephenmac7: I'm having trouble understanding "it's not state as much as it is"
19:32:33 <dramforever> I'm not a native English speaker
19:32:46 <stephenmac7> dramforever: I never would have guessed
19:33:06 <dramforever> anyway, what do you mean by that?
19:33:29 <HeladoDeBrownie> dramforever, "It's not X as much as it is Y" could also be phrased as "It's more Y than X"
19:33:30 <dramforever> shouldn't it be "just as much as it is"
19:33:46 <Gurkenglas> Ah, yes.
19:34:26 <dramforever> so the "having everything..." part is also part of the "not as much as"
19:34:34 <dramforever> oh
19:34:40 <Gurkenglas> Thanks, that's better. Now what's with the stop icon not disappearing?
19:35:00 <dramforever> hmm...learnt some English from #haskell...
19:36:01 <dramforever> stephenmac7: how about this: the State monad *models* states
19:37:33 <dramforever> likewise, Except models exceptions, Cont models continuations
19:42:16 <stephenmac7> Sorry, got delayed. The trouble I'm having is not understanding state specifically but just keeping the complex types sorted out.
19:42:22 <stephenmac7> dramforever: Sorry about the wait
19:42:30 <dramforever> it's okay
19:42:49 <stephenmac7> Then thinking at the same time about the transformations being applied
19:43:13 <dramforever> stephenmac7: don't do that
19:43:24 <dramforever> think about MonadState m => m a, etc
19:43:44 <dramforever> stephenmac7: hey how about this:
19:43:59 <dramforever> @unmtll StateT S (ReaderT R IO)
19:43:59 <lambdabot> Plugin `unmtl' failed with: `StateT S (ReaderT R IO)' is not applied to enough arguments, giving `/\A. S -> (ReaderT R IO) (A, S)'
19:44:08 <dramforever> @unmtl StateT S (ReaderT R IO)
19:44:08 <lambdabot> Plugin `unmtl' failed with: `StateT S (ReaderT R IO)' is not applied to enough arguments, giving `/\A. S -> (ReaderT R IO) (A, S)'
19:44:11 <dramforever> @unmtl StateT S (ReaderT R IO) a
19:44:11 <lambdabot> S -> (ReaderT R IO) (a, S)
19:44:25 <dramforever> stephenmac7: unmtl is great
19:44:55 <int-e> @unmtl ReaderT R IO (a, S)
19:44:55 <lambdabot> R -> IO (a, S)
19:45:44 <stephenmac7> dramforever: That's cool.
19:46:06 <dramforever> it shows the underlying function
19:47:58 <sshine> @unmtl ReaderT R IO
19:47:59 <lambdabot> Plugin `unmtl' failed with: `ReaderT R IO' is not applied to enough arguments, giving `/\A. R -> IO A'
19:48:06 <sshine> @unmtl ReaderT R IO a
19:48:07 <lambdabot> R -> IO a
19:48:24 <sshine> neat :)
19:49:28 <stephenmac7> merijn: Should Functor apply the function to the state or the value?
19:49:38 <sshine> stephenmac7, value.
19:50:46 <sshine> stephenmac7, since both Monad and Functor are parameterized over the type that corresponds to 'the return value', that's the way it has to be.
19:51:13 <stephenmac7> Got it
19:51:43 <sshine> so  'StateT st (ReaderT env IO) a'  is really  'st -> env -> IO (a, st)'  :)
19:51:58 <merijn> stephenmac7: If you look at the type of fmap in the comments, you'll see that applying it to the state won't typecheck :)
19:51:59 <sshine> wait...
19:52:16 <merijn> @unmtl StateT st (ReaderT env IO) a
19:52:16 <lambdabot> st -> (ReaderT env IO) (a, st)
19:52:30 <merijn> ah, boo
19:52:31 <stephenmac7> Why does that tuple have to be backwards?
19:52:38 <merijn> unmtl only does one layer
19:52:46 <sshine> merijn, yeah, so I composed the two layers.
19:52:51 <sshine> stephenmac7, backwards?
19:52:53 <merijn> stephenmac7: Define "backwards"?
19:53:11 <stephenmac7> data MyState s a = MyState (s -> (a, s)) seems like it should be data MyState s a = MyState (s -> (s, a))
19:53:14 <sshine> stephenmac7, it doesn't really matter if it's (a, st) or (st, a)... it's just a convention.
19:53:39 <dramforever> whenever we have something like (a, b), half will say it's backwards
19:53:50 <benzrf> it *has* seemed backwards to me tbh
19:54:01 <sshine> stephenmac7, ah. MyState s a is necessary because we want to define the instance Monad (MyState s).
19:54:09 <geekosaur> isn't that because of 2-tuple Functor instance?
19:54:18 <dramforever> tbh I use monads because they works lol
19:54:46 <dramforever> they work
19:54:55 <sshine> geekosaur, are you saying (st, a) is not used because it collides with the 2-tuple Functor instance?
19:54:58 <stephenmac7> How do you run something in the irc?
19:55:06 <dramforever> > 1+1
19:55:07 <lambdabot>  2
19:55:12 <dramforever> @eval 1+1
19:55:18 <stephenmac7> > fmap (+5) (1, 2)
19:55:19 <lambdabot>  (1,7)
19:55:45 <dramforever> > ("sss",1) >> ("xxx", 2)
19:55:47 <lambdabot>  Could not deduce (GHC.Base.Monad ((,) [GHC.Types.Char]))
19:55:47 <lambdabot>    arising from a use of ‘GHC.Base.>>’
19:55:47 <lambdabot>  from the context (GHC.Num.Num b)
19:55:47 <lambdabot>    bound by the inferred type of
19:55:47 <lambdabot>             it :: GHC.Num.Num b => ([GHC.Types.Char], b)
19:55:56 <dramforever> oops
19:56:49 <sshine> > "dramfor" ++ concat (repeat "ever")
19:56:51 <lambdabot>  "dramforevereverevereverevereverevereverevereverevereverevereverevereverever...
19:57:09 <int-e> sshine: concat . repeat = cycle, btw.
19:57:28 <Axman6> but cycle is more efficient
19:57:36 <sshine> int-e, right :) I had "cycle" in my head at some point in the last minute. not sure why I didn't act on it.
19:57:48 <Axman6> because you get a constant space cyclic datastructure
19:57:53 <dramforever> > let dram = Nothing in (dram `forever`)
19:57:54 <lambdabot>  Nothing
19:58:11 <dramforever> > ("dram" `forever`)
19:58:15 <lambdabot>  mueval-core: Time limit exceeded
19:58:37 <benzrf> > let (!!!!) = forever in (Nothing !!!!)
19:58:39 <lambdabot>  Nothing
19:58:41 <benzrf>   huh
19:58:48 <benzrf> oh it must have suffixsyntax enabled
19:59:05 <dramforever> wait that's against haskell98, iirc
19:59:06 <Fuuzetsu> isn't it called postfix something
19:59:35 <int-e> dramforever: yes it is, but it's *usually* a harmless extension, so it's enabled.
19:59:48 <int-e> yes, PostfixOperators
20:00:34 <dramforever> > (+1) `id` 2
20:00:35 <lambdabot>  3
20:01:34 <stephenmac7> Still working on it...
20:01:38 <dramforever> @src cycle
20:01:38 <lambdabot> cycle [] = undefined
20:01:38 <lambdabot> cycle xs = xs' where xs' = xs ++ xs'
20:01:46 <dramforever> ???
20:01:48 <int-e> > snd $ runWriter $ forever (tell "dram")
20:01:49 <lambdabot>  "dramdramdramdramdramdramdramdramdramdramdramdramdramdramdramdramdramdramdra...
20:02:00 <dramforever> !!!!! why???
20:02:09 <int-e> dramforever: what is the question?
20:02:36 <dramforever> that cycle seems to be equivlant to concat . repeat
20:02:52 <sshine> dramforever, snd . runWriter = execWriter
20:02:58 <stephenmac7> Is (<*>) (MyState fUnwrapped) (MyState vUnwrapped) = MyState (\s -> let (f, s) = fUnwrapped s in let (a, nst) = vUnwrapped s in (f a, nst)) right for applicative?
20:03:01 <hunt> can you use boolean operations in case statements, or is it only pattern matching?
20:03:51 <dramforever> :t fix . (++)
20:03:52 <lambdabot> [a] -> [a]
20:04:03 <dramforever> (fix . (++)) "dram"
20:04:06 <dramforever> > (fix . (++)) "dram"
20:04:08 <lambdabot>  "dramdramdramdramdramdramdramdramdramdramdramdramdramdramdramdramdramdramdra...
20:04:12 <dramforever> hmm...
20:04:16 <int-e> concat (repeat xs) = concat (xs:repeat xs) = xs ++ concat (repeat xs), and cycle xs = xs ++ cycle xs <-- this shows coinductively that  concat (repeat xs) = cycle xs, if xs is a non-empty list.
20:04:36 <dramforever> > (fix . (++)) []
20:04:37 <Tokenizer> can someone please help with this basic example.... i don't understand how to implement the function on lines 13/14 of this paste..  My issue is understanding what the signature asks .... http://pastie.org/private/dyjv0srsgocwhjemznkia
20:04:40 <lambdabot>  mueval-core: Time limit exceeded
20:05:00 <stephenmac7> merijn: Would the above be right?
20:05:03 <sshine> stephenmac7, isn't MyState f <*> MyState v = MyState (\s -> (f v, s)) sufficient?
20:05:15 <sshine> stephenmac7, whoops. no.
20:06:34 <merijn> stephenmac7: Lemme check
20:06:46 <merijn> stephenmac7: FYI, you can define operators infix like sshine's example
20:06:55 <stephenmac7> merijn: Yeah, I fixed that
20:06:56 <int-e> Tokenizer: hmm, let's start slowly. how many arguments does extend have?
20:07:10 <Tokenizer> well in what i want 3
20:07:11 <merijn> stephenmac7: The shadowing of 's' is confusing, but I think it looks right, yeah
20:07:26 <Tokenizer> int-e: but in the definition i see none...
20:07:29 <merijn> stephenmac7: oh, actually
20:07:31 <merijn> stephenmac7: You have a bug :)
20:07:43 <stephenmac7> What is it?
20:07:52 <merijn> stephenmac7: Ponder the following, what is wrong with "let (f, s) = fUnwrapped s"? :)
20:08:01 <int-e> Tokenizer: (State -> Symbol -> [State]) -> (State -> String -> [State]) is the same type as  (State -> Symbol -> [State]) -> State -> String -> [State]
20:08:23 <stephenmac7> merijn: I'm not seeing anything
20:08:29 <sshine> stephenmac7, MyState m <*> MyState v = MyState $ \s -> let (f, s') = m s; (a, s'') = v s' in (f a, s'')  -- I think.
20:08:36 <stephenmac7> MyState app <*> MyState v = MyState (\s -> let (f, s) = app s in let (a, s) = v s in (f a, s)) might be easier to read
20:08:38 <int-e> Tokenizer: so you have three arguments right there, a step function, an initial state, and a string (I'd prefer to write [Symbol] there)
20:09:12 <merijn> stephenmac7: Next clue
20:09:17 <merijn> > let x = x in x
20:09:21 <lambdabot>  mueval-core: Time limit exceeded
20:09:24 <int-e> Tokenizer: Now if you pattern match on that list of symbols, that should give you a good place to start.
20:09:40 <stephenmac7> merijn: Ah, so I can't shadow it like that?
20:09:53 <sshine> Haskell is pretty wicked in that it lets you refer to the variable you're defining :P
20:10:12 <merijn> stephenmac7: No, it's passing it's own result as argument to fUnwrapped (yes, you can do that in haskell)
20:10:22 <merijn> sshine: You can do some pretty neat tricks with that, though
20:10:38 <dramforever> It's literally a "feedback" loop
20:10:40 <merijn> Like efficient updates in a data structure
20:10:52 <sshine> merijn, or the fibonacci one-liner.
20:11:10 <Tokenizer> int-e: what's actually throwing me off is the actual line "extend =" .... where are the arguments on the left of equal sign?
20:11:22 <stephenmac7> merijn: So, it's shadowed within the definition?
20:11:22 <adarc> i'm trying to get better at writing interpreters/dsl's etc.. anyone have any books/references they recommend? i'm trying to write a little interpreter for some code challenge right now.. without parsec etc.. i figure the best thing to do first is to define the grammar/ops/etc entirely within haskell then do a few test cases etc.. after that implement the actual parser.
20:11:28 <merijn> stephenmac7: The quotes are the usual way to avoid shadowing like that
20:11:49 <stephenmac7> So MyState app <*> MyState v = MyState $ \s -> let (f, s') = app s in let (a, s'') = v s' in (f a, s'')
20:11:59 <int-e> Tokenizer: oh, there are none, but I would expect that you're allowed to add them yourself
20:12:21 <merijn> stephenmac7: Right
20:12:44 <merijn> stephenmac7: You only need one let/in, but that's a syntactic detail
20:12:45 <int-e> Tokenizer: if not, you can write something like  extend = extend' where extend' step st syms = ...  but that looks silly.
20:13:01 <stephenmac7> merijn: How would I simplify it?
20:13:21 <stephenmac7> > let f = 5; g = 6 in (f, g)
20:13:23 <lambdabot>  (5,6)
20:13:24 <Tokenizer> int-e: let me have a crack at it and show you
20:13:49 <merijn> stephenmac7: Right, just having both binding with one let is more common (on separate lines)
20:13:53 <benzrf> Tokenizer
20:13:55 <benzrf> why not
20:14:00 <benzrf> Tolkeinizer
20:14:17 <sshine> Tolkienizer
20:14:51 <benzrf> er
20:14:51 <benzrf> yes
20:15:19 <stephenmac7> Having trouble with the monad instance
20:15:31 <sshine> of MyState s?
20:15:35 <stephenmac7> Yes
20:15:42 <stephenmac7> I don't want the answer though
20:16:51 <stephenmac7> Would it be  MyState v >>= MyState f = (\s -> let (a, s') = v s in (f a, s'))
20:17:01 <benzrf> stephenmac7: does it type check
20:17:16 <merijn> You right hand side of >>= is wrong
20:17:34 <merijn> stephenmac7: Take another look at the expanded type of >>= in the gist :)
20:17:34 <int-e> MyState f <-- also wrong
20:17:44 <sshine> :t (>>=)
20:17:45 <lambdabot> Monad m => m a -> (a -> m b) -> m b
20:17:51 <merijn> int-e: That is the right hand side of >>=, is it not? :)
20:17:59 <int-e> stephenmac7: It's probably best to try it out in ghc.
20:18:28 <int-e> merijn: ... I don't know. I'd call it the right argument. The right-hand side of the equation is also wrong, so I wasn't sure.
20:18:43 <sshine> stephenmac7, f is used to generate, say, v'
20:18:53 <merijn> int-e: Well, sure, with the wrong right argument the correct right-hand side is hard to achieve ;)
20:18:59 <sshine> stephenmac7, sorry, MyState v' :)
20:19:11 <PCChris> @pl diagonal w h = sqrt $ w * w + h * h
20:19:11 <lambdabot> diagonal = (sqrt .) . (. join (*)) . (+) . join (*)
20:19:21 <int-e> merijn: no matter what you do on the left-hand side, it will be wrong :)
20:19:24 <sshine> PCChris, much better.
20:19:28 <int-e> merijn: anyway.
20:19:38 <int-e> merijn: I think we now know what we meant :)
20:20:09 <alexchandel1> A879395E-CA86-4701-94DA-FCDC996E5B66-27031-00000F55E82170E4
20:20:31 <benzrf> sqrt . join (liftA2 (+)) (join (*)
20:20:33 <benzrf> :t sqrt . join (liftA2 (+)) (join (*)
20:20:34 <lambdabot>     parse error (possibly incorrect indentation or mismatched brackets)
20:20:36 <benzrf> shit
20:20:40 <benzrf> :t sqrt . join (liftA2 (+)) (join (*))
20:20:41 <lambdabot> Floating a => a -> a
20:20:48 <benzrf> oh. wait
20:22:02 <stephenmac7> How about MyState v >>= f = (\s -> let (a, s') = v s in f a s')
20:22:13 <sshine> is there something arrowy for \f x -> f x x?
20:22:18 <alexchandel1> @pl diagonal w h = sqrt $ w * w + h * h
20:22:19 <lambdabot> diagonal = (sqrt .) . (. join (*)) . (+) . join (*)
20:22:30 <sshine> @pl \f x -> f x x
20:22:31 <lambdabot> join
20:22:33 <int-e> stephenmac7: you should make a small haskell file and ask ghci
20:23:00 <int-e> stephenmac7: which would tell you that f a is not a function, hence f a s' failes.
20:23:06 <int-e> *fails
20:23:44 <PCChris> :t (sqrt .)
20:23:45 <lambdabot> Floating c => (a -> c) -> a -> c
20:25:08 <alexchandel1> :t .
20:25:09 <lambdabot> parse error on input ‘.’
20:25:10 <benzrf> sleep
20:25:12 <benzrf> bye
20:25:18 <alexchandel1> :t (.)
20:25:19 <lambdabot> (b -> c) -> (a -> b) -> a -> c
20:26:05 * hackagebot file-command-qq 0.1.0.0 - Quasiquoter for system commands involving filepaths  http://hackage.haskell.org/package/file-command-qq-0.1.0.0 (JonathanFischoff)
20:26:40 <stephenmac7> merijn: How's http://lpaste.net/114026
20:27:20 <stephenmac7> It typechecks at least
20:27:21 <PCChris> :t map
20:27:22 <lambdabot> (a -> b) -> [a] -> [b]
20:27:31 <PCChris> :t fmap
20:27:32 <lambdabot> Functor f => (a -> b) -> f a -> f b
20:28:27 <Tokenizer> int-e: no luck ... don't get the brackets and the pattern matchining ... between what I want to achieve (at the end of the file comment) and what the signature is, I'm stumped.... here is my try:   http://pastie.org/private/90uo7nllfhanhe08kkng
20:28:30 <int-e> stephenmac7: looks correct
20:28:44 <stephenmac7> Why that was so hard, I have no idea
20:29:54 <int-e> Tokenizer: hmm. You can't pattern match on the first argument, it's just a function; all you can do is give it a name. To pattern match on a list, use (x:xs)
20:30:21 <int-e> Tokenizer: and [] for the empty list.
20:30:31 <stephenmac7> Every time I write something in haskell I end up with so many haddock tabs in my browser...
20:30:34 <PCChris> > map (+1) [1, 2, 3]
20:30:36 <lambdabot>  [2,3,4]
20:31:33 <Tokenizer> int-e: but i don't want to hardcode the first argument function, I want it to be any function of that type
20:31:50 <int-e> Tokenizer: something like http://lpaste.net/114028
20:31:56 <PCChris> @djinn f (a, b) -> a
20:31:57 <lambdabot> -- f cannot be realized.
20:31:59 <int-e> Tokenizer: that's what you get
20:32:28 <PCChris> @djinn (a, b) -> c -> (b, c)
20:32:28 <lambdabot> f (_, a) b = (a, b)
20:32:30 <int-e> > let foo f = f 32 in (foo (*42), foo (+23))
20:32:31 <lambdabot>  (1344,55)
20:33:57 <merijn> stephenmac7: Looks ok to me :)
20:34:14 <stephenmac7> Good, but why was that so hard for me?
20:34:23 <merijn> stephenmac7: Also "why that was so hard, I have no idea" <- it's not very obvious what's going on until you actually do it :)
20:34:23 <stephenmac7> It shouldn't have been
20:34:25 <int-e> Tokenizer: that f there is not hard-coded, it's just a name for the function being passed in (multiplication by 42; adding 23)
20:34:48 <merijn> stephenmac7: I think everyone struggles like at least an hour or so trying to do that for the first time. It's not as obvious as it seems in hindsight :)
20:35:01 <stephenmac7> I see.
20:35:13 <Axman6> stephenmac7: because you're not used to the APIs, as with all languages the more you use libraries the less you need to reference their docs
20:35:15 <merijn> stephenmac7: Which is why it's good practice, afterwards you go "huh, that wasn't so hard" and it helps you truly understand what State is doing :)
20:35:20 <stephenmac7> Well, thanks. I hope next time I write something I'll be a little faster.
20:35:31 <PCChris> @pl f (_, a) b = (a, b)
20:35:31 <lambdabot> f = (,) . snd
20:35:41 <merijn> stephenmac7: For fun you could try Reader or Writer next :p
20:35:53 <stephenmac7> merijn: Please, no.
20:36:00 <int-e> stephenmac7: just wait until you get to write a monad instance for Cont ...
20:36:04 <Axman6> @. pl djinn ((a, b) -> c -> (b, c)
20:36:04 <lambdabot> Cannot parse command
20:36:09 <Axman6> @. pl djinn (a, b) -> c -> (b, c)
20:36:09 <lambdabot> f = (,) . snd
20:36:16 <int-e> @unmtl Cont r a
20:36:16 <lambdabot> (a -> r) -> r
20:36:16 <stephenmac7> int-e: What is Cont for anyway?
20:36:22 <adarc> i think i should start out with a bool expression tree
20:36:31 <adarc> boolean
20:36:37 <stephenmac7> I get what continuations are but, a monad?
20:36:41 <int-e> stephenmac7: it's the mother of all universal monads, more or less.
20:37:01 <Fuuzetsu> bold claim
20:37:12 <hunt> so how do i get the exact versions that i should list in my cabal dependencies?
20:37:32 <Fuuzetsu> by making sure it always works with latest versions instead of dicking around with bounds
20:37:57 <hunt> Fuuzetsu: well, im not going to maintain it sadly
20:38:02 <hunt> Fuuzetsu: since its a 2 file project
20:38:09 <Fuuzetsu> seems easy to maintain
20:38:16 <hunt> Fuuzetsu: i dont want to dedicate time to it
20:38:21 <hunt> Fuuzetsu: but yes probably
20:38:25 <PCChris> @. pl djinn (a -> b) -> (c -> d) -> (a, c) -> (b, d)
20:38:25 <lambdabot> f = flip flip snd . (ap .) . flip flip fst . ((.) .) . flip . (((.) . (,)) .)
20:38:27 <hunt> Fuuzetsu: point is im not going to
20:38:32 <Fuuzetsu> write it so it's unlikely to break within next few years and just give generous bounds
20:38:39 <hunt> its probably not going to go on hackage anyways
20:38:46 <Hijiri> you can compose lambdabot commands?
20:38:50 <hunt> Fuuzetsu: how do i know if it is unlikely to break or not?
20:39:04 <hunt> im not up to date on whats volatile
20:39:12 <Fuuzetsu> hunt: use common APIs rather than something from .Internal &c &c
20:39:23 <Hijiri> @. pl let banana = 5
20:39:24 <lambdabot> Defined.
20:39:30 <hunt> Fuuzetsu: oh good ok all im using is base directory container and parsec, sounds good?
20:39:34 <stephenmac7> I don't quite understand transformers either
20:39:44 <PCChris> @dginn (a -> b) -> (c -> d) -> (a, c) -> (b, d)
20:39:45 <lambdabot> f a b (c, d) = (a c, b d)
20:39:45 <michaelt> why not just use the 'bounds' from cabal init
20:39:48 <Hijiri> @. djinn let banana = 6
20:39:48 <lambdabot> Cannot parse command
20:39:49 <lambdabot> Djinn> Cannot parse command
20:39:49 <lambdabot> Djinn> Cannot parse command
20:39:49 <lambdabot> Djinn> Cannot parse command
20:39:53 <hunt> and trasnformers
20:39:56 <Fuuzetsu> hunt: sure, I think parsec changes sometimes but the others are unlikely to break any time soon unless you're using already-deprecated stuff
20:40:04 <merijn> stephenmac7: Actually, it's not hard to generalise my previous State example to the state transformer
20:40:16 <hunt> Fuuzetsu: i think im using mostly modern things, its not a particularly obscure or far reaching project
20:40:31 <Fuuzetsu> if I were you I'd just set bound on base like >4 and leave others without
20:40:33 <hunt> im going to put it on git and ask for some code review in a sec if anyones willing
20:40:40 <Tokenizer> int-e: thanks .... worked now trying to understand what you did to get the concept
20:40:44 <alexchandel1> @pl (a -> b) -> (c -> d) -> (a, c) -> (b, d)
20:40:44 <lambdabot> (line 1, column 6):
20:40:44 <lambdabot> unexpected '>'
20:40:44 <lambdabot> expecting operator
20:40:54 <Fuuzetsu> maybe lower bound on recent parsec too
20:41:03 <alexchandel1> @pl f a b (c, d) = (a c, b d)
20:41:03 <lambdabot> f = flip flip snd . (ap .) . flip flip fst . ((.) .) . flip . (((.) . (,)) .)
20:41:51 <Axman6> pl needs more Data.Arrow
20:42:46 <dfeuer_> hunt, avoid an upper bound on base even if Cabal suggests it, if you want to be even vaguely future-proof.
20:42:48 <stephenmac7> merijn: I'll do it later. Tomorrow possibly
20:42:49 <edwardk> no, no it doesn't
20:43:06 <merijn> stephenmac7: Consider this one: https://gist.github.com/merijn/098106abd45c940dab09#file-mystatet-hs
20:43:16 <dfeuer_> I didn't even know Data.Arrow existed.
20:43:43 <Axman6> @hoogle first
20:43:44 <sshine> Axman6, pl definitely needs more arrows.
20:43:44 <lambdabot> Control.Arrow first :: Arrow a => a b c -> a (b, d) (c, d)
20:43:44 <lambdabot> Text.PrettyPrint.HughesPJ first :: Doc -> Doc -> Doc
20:43:44 <lambdabot> package first-class-patterns
20:43:48 <stephenmac7> merijn: It's a bit late at the moment. Can't do it now.
20:43:52 <Axman6> Control.Arrow even
20:43:56 <stephenmac7> Will you be here tomorrow?
20:44:03 <merijn> dfeuer_: Go proofread D442 so I don't have any embarassing typo's in there! :p
20:44:03 <phaskell> D442: Add -fdefer-typed-holes flag which defers hole errors to runtime. - https://phabricator.haskell.org/D442
20:44:16 <Fuuzetsu> >typo's
20:44:21 <merijn> stephenmac7: Most likely :p But if not, someone else should be able to answer questions about it
20:44:22 <dfeuer_> merijn, you mean like "embarrassing typos"?
20:44:30 <stephenmac7> Okay, thanks for the help
20:44:34 <merijn> Fuuzetsu: I blame English >.>
20:45:01 <merijn> Fuuzetsu: In Dutch it'd be wrong to not have an apostrophe there, so I have two conflicting instincts
20:45:09 <merijn> Same for photo's and video's >.<
20:45:11 <dfeuer_> English spelling is pretty terrible. That's what you get when you mix French and German.
20:45:29 <dfeuer_> merijn, what's the apostrophe mean in Dutch?
20:45:43 <merijn> dfeuer_: Plural or possessive
20:46:51 <merijn> dfeuer_: The point is that the pronounciation of vowels is determined by whether they're at the end of a syllable or not. So "video" has a long o sound, but "videos" would have a short one (because of the 's' now ending the syllable), which is wrong. So the ' indicates that difference
20:47:13 <merijn> To me, photos reads like the last syllable is "toss" >.>
20:47:26 <merijn> rather than "toes"
20:47:26 <dfeuer_> In English it's used for possessive and for contractions. It's not used for the possessive "its". It's sometimes used to pluralize numbers (e.g., 1940's).
20:47:42 <dfeuer_> Interesting, merijn.
20:47:52 <merijn> I know all that, but unless I'm proofreading they tend to slip in
20:48:00 <Gurkenglas> I wonder what language elements it would take to make a pl with the output growing no more than linearly with the output.
20:48:07 <Gurkenglas> *with the input
20:48:31 <merijn> dfeuer_: Especially for words that I use in Dutch too (i.e. video == video and photo == foto and typo = typo), therefore it's easier for my reflexes to trip me up
20:48:41 <dfeuer_> *nod*
20:48:44 <Fuuzetsu> yes, basically English sucks
20:49:04 <dfeuer_> merijn, I think your commit message needs to be reorganized, if that's what you're asking about.
20:49:25 <merijn> dfeuer_: I wanted to know about the documentation changes in flags.xml/using.xml/glasgow_exts.xml
20:49:50 <dfeuer_> It's hard to understand and includes irrelevancies like "... this flag is a no-op".... well, actually, it's just on by default.
20:50:00 <dfeuer_> Oh, let me look at that.
20:50:06 <merijn> dfeuer_: No, it's a no-op by default
20:50:16 <merijn> dfeuer_: Because by default there are never any typed-holes warnings
20:50:37 <dfeuer_> Oh, I see.
20:50:45 <dfeuer_> It's still hard to read.
20:50:48 <merijn> (because without -fdefer-typed-holes they're errors, not warnings)
20:50:51 <nitrix> :t return ()
20:50:52 <lambdabot> Monad m => m ()
20:51:17 <dfeuer_> :t return . return
20:51:18 <lambdabot> (Monad m1, Monad m) => a -> m (m1 a)
20:51:24 <dfeuer_> :t return . return . return
20:51:25 <lambdabot> (Monad m2, Monad m1, Monad m) => a -> m (m1 (m2 a))
20:51:50 <dfeuer_> Wow, merijn, you had to hit a lot of files in that patch.
20:52:00 <dfeuer_> :t join . return
20:52:01 <lambdabot> Monad m => m a -> m a
20:52:09 <dfeuer_> :t join . join . return . return
20:52:10 <lambdabot> Monad m => m a -> m a
20:53:00 <merijn> dfeuer_: The majority is adding test cases
20:53:33 <dfeuer_> merijn, you have  a number mismatch in lines 8386 and 8387 (placeholders/an expression)
20:54:24 <dfeuer_> The first sentence has an awkward phrase ("an always enabled feature"). Yes, that's important, but it doesn't have to be a parenthetical in the first sentence. Stick it somewhere else where it fits better.
20:55:53 <dfeuer_> merijn, it should be "with terms that are not defined at the top level" or something similar. Definitely "that" rather than "which".
20:56:06 <dfeuer_> "allow to check" does not parse.
20:56:10 <hunt> is there a prelude function that could get me the last x elements of a list
20:56:39 <dfeuer_> Contractions (such as "you're") are not usually used in formal prose, including documentation.
20:56:52 <Hijiri> reverse . take n?
20:57:04 <dfeuer_> Yuck.
20:57:10 <dfeuer_> No.
20:57:11 <sshine> Hijiri, take n . reverse, you mean?
20:57:15 <Hijiri> yeah, sorry
20:57:25 <dfeuer_> Or reverse . take n . reverse even, but these are all awful.
20:57:26 <sshine> and that'd be reverse . take n . reverse :P
20:57:32 <Hijiri> oh, right
20:57:33 <sshine> hehe
20:57:35 <sshine> I agree.
20:57:52 <dfeuer_> Look in ghc/compiler/util/Util.hs or something and search for "Joachim Breitner".
20:58:02 <dfeuer_> Let me find it....
20:58:15 <sshine> dfeuer_, that's a good name for this function.
20:58:26 <dfeuer_> sshine, what?
20:58:35 <sshine> dfeuer_, I mean, take the Joachim Breitner of a list... ;)
20:58:41 <dfeuer_> Ha.
20:59:14 <PCChris> > return 5 :: (IO Int)
20:59:15 <lambdabot>  <IO Int>
20:59:41 <hunt> ok ill just go with the reverse strat, kinda heavy though isnt it
20:59:52 <sshine> > return 5 >> putStr . show
20:59:54 <lambdabot>  <() -> IO ()>
21:00:01 <sshine> whoops.
21:00:04 <sshine> > return 5 >>= putStr . show
21:00:06 <lambdabot>  <IO ()>
21:00:10 <alexchandel1> > (5 :: (IO Int)) >> (6 :: (IO Int))
21:00:11 <lambdabot>  No instance for (GHC.Num.Num (GHC.Types.IO GHC.Types.Int))
21:00:11 <lambdabot>    arising from the literal ‘5’
21:00:17 <dfeuer_> Oh, sshine, I got that confused. That's dropTail. hunt is looking to take from the end.
21:00:38 <dfeuer_> dropTail is a rather pretty thing though: https://ghc.haskell.org/trac/ghc/browser/ghc/compiler/utils/Util.lhs
21:01:46 <alexchandel1> > (return 5 :: (IO Int)) >> (return 6 :: (IO Int))
21:01:47 <lambdabot>  <IO Int>
21:01:52 <sshine> hunt, alternatively, takeEnd n xs = drop (length xs - n) xs
21:02:21 <dfeuer_> sshine, you should do it using the dropList function from the file I linked to, I think.
21:02:46 <dfeuer_> takeEnd n xs = dropList (drop n xs) xs
21:02:51 <dfeuer_> I think that works.
21:03:04 <PCChris> > (return 5 :: (IO Int)) >> (return 6 :: (IO Int)) >>= print
21:03:06 <lambdabot>  <IO ()>
21:04:37 <sshine> PCChris, 6.
21:05:00 <hunt> tbh i want to see this but im just going with the reverse method for now for the sake of time esp since these are small lists anyways
21:05:18 <hunt> also i dont imagine extracting from that file would be totally ok
21:05:26 <hunt> or that its in an available library on cabal
21:05:32 <hunt> or ait
21:05:33 <hunt> idk
21:05:35 <hunt> it dm
21:05:53 <dfeuer_> @def takeEnd n lst = let {dropList (_:xs) (_:ys) = dropList xs ys; dropList _ xs = xs} in dropList (drop n lst)
21:05:54 <lambdabot>  Defined.
21:06:06 <dfeuer_> > takeEnd 4 [1,2,3,4,5]
21:06:07 <lambdabot>  No instance for (Data.Typeable.Internal.Typeable t10)
21:06:07 <lambdabot>    arising from a use of ‘M291721491588295011116671.show_M2917214915882950111...
21:06:07 <lambdabot>  The type variable ‘t10’ is ambiguous
21:06:07 <lambdabot>  Note: there are several potential instances:
21:06:07 <lambdabot>    instance Data.Typeable.Internal.Typeable Data.Dynamic.Dynamic
21:06:14 <dfeuer_> Uh .... what?
21:06:26 <dfeuer_> > takeEnd 4 [1,2,3,4,5::Int]
21:06:28 <lambdabot>  No instance for (Data.Typeable.Internal.Typeable t10)
21:06:28 <lambdabot>    arising from a use of ‘M876729960504713676816729.show_M8767299605047136768...
21:06:28 <lambdabot>  The type variable ‘t10’ is ambiguous
21:06:28 <lambdabot>  Note: there are several potential instances:
21:06:28 <lambdabot>    instance Data.Typeable.Internal.Typeable Data.Dynamic.Dynamic
21:06:39 <dfeuer_> What is it talking about?
21:07:09 <dfeuer_> Oh, I goofed something up, didn't I?
21:07:12 <c_wraith> :t takeEnd
21:07:13 <lambdabot> Int -> [t] -> [t1] -> [t1]
21:07:15 <PCChris> sshine: lol
21:07:20 <dfeuer_> Yeah, that's all wrong.
21:07:24 <dfeuer_> @undef
21:07:24 <lambdabot> Undefined.
21:07:28 <c_wraith> dfeuer_: not enough arguments, so it's trying to print the type
21:07:40 <dfeuer_> @def takeEnd n lst = let {dropList (_:xs) (_:ys) = dropList xs ys; dropList _ xs = xs} in dropList (drop n lst) lst
21:07:42 <lambdabot>  Defined.
21:07:50 <dfeuer_> > takeEnd 4 [1,2,3,4,5]
21:07:51 <lambdabot>  [2,3,4,5]
21:07:54 <dfeuer_> There we go.
21:08:01 <dfeuer_> > takeEnd 4 [1,2]
21:08:03 <lambdabot>  [1,2]
21:08:13 <c_wraith> is that notably better than zipWith const ?
21:08:33 <dfeuer_> c_wraith, as I have not considered zipWith const in this context, I really couldn't say.
21:08:50 <hunt> whats a good license
21:09:00 <c_wraith> dfeuer_: that's the standard quick implementation of that.  (well, with a drop)
21:09:01 <hunt> if i want this thing to be completely and utterly open
21:09:02 <PCChris> :t (>>=)
21:09:03 <lambdabot> Monad m => m a -> (a -> m b) -> m b
21:09:13 <c_wraith> hunt: MIT
21:09:13 <dfeuer_> c_wraith, I see now. That makes a lot of sense.
21:09:13 <Axman6> MIT or BSD3
21:09:24 <dfeuer_> Or CC-by-SA, I think.
21:09:26 <hunt> i dont know if i dig someone republishing this as their own
21:09:31 <Axman6> or do as the SQLite guys have and explicitly say it's in the public domain
21:09:34 <hunt> do those lisences protect against that?
21:09:39 <dfeuer_> hunt, then use CC-by-SA. It does.
21:09:45 <Axman6> I think they both cover attribution
21:09:54 <hunt> ill check
21:09:58 <dfeuer_> I don't know. I seem to remember MIT and BSD being *extremely* loose.
21:10:27 <c_wraith> BSD3 requires the copyright statement be included with any distribution
21:10:30 <dfeuer_> *G*P*L* are all way too restrictive to be able to work with a lot of other open source projects, so steer clear.
21:10:30 <c_wraith> MIT is looser
21:10:42 <dfeuer_> Ah.
21:11:02 <hunt> is it automatically copyrighted?
21:11:05 <hunt> can i just say this year
21:11:16 <dfeuer_> In the U.S., it's copyrighted as soon as you publish it.
21:11:22 <dfeuer_> Automagically.
21:11:27 <hunt> sexy
21:11:31 <Axman6> how do they do it!
21:11:39 <hunt> and for copyright holder is my full name good
21:11:43 <dfeuer_> But for certain purposes you need to "register" a copyright.
21:11:47 <merijn> dfeuer_: In any of the 130 countries that signed the Berne convention copyright is automatic
21:11:51 <dfeuer_> But you probably don't want to bother.
21:11:53 <alexchandel3> :t (>>=)
21:11:54 <lambdabot> Monad m => m a -> (a -> m b) -> m b
21:11:55 <dfeuer_> merijn, ah, interesting.
21:12:09 <alexchandel3> :t (>>)
21:12:10 <lambdabot> Monad m => m a -> m b -> m b
21:12:18 <merijn> And you never need to register a copyright, although having it explicitly registered can make it easier to "prove" you own the copyright
21:12:22 <hunt> sweet
21:12:24 <hunt> its done
21:12:44 <merijn> hunt: Anyway, BSD/MIT both do not allow the original copyright notice to be stripped
21:12:53 <merijn> Neither does GPL for that matter
21:12:58 <dfeuer_> merijn, in the U.S., I believe it opens up the door to more serious prosecutions and such. But it's only really done by people who write books, big-time software packages, etc.
21:13:03 <Hodapp> dfeuer_: You don't even need to publish it in the US for it to be copyrighted.
21:13:04 <hunt> would anyone have interest in me putting this on cabal? its a small cli that lists your installed steam games or their ids, or converts an installed  steam id to a game name
21:13:04 <Hodapp> It just is.
21:13:26 <merijn> The difference is that BSD/MIT permit distribution under a different license (i.e. relicensing), but that does not permit stripping the copyright notice
21:13:37 <dfeuer_> Hodapp, copyright doesn't make any sense for something that's kept private....
21:13:45 <Tokenizer> if i have a function that returns a list ..... and myself i have an argument list (with elements denoted here by e)..... how can I in one line says   x = concatenate(results_of_myfunction_calls(e))
21:14:04 <merijn> hunt: i.e. I can take your BSD code and include it in a bundle of GPL code, distributing the entire bundle as GPL. IF (and only if) I include your original copyright notice
21:14:28 <Axman6> Tokenizer: that question is quite unclear
21:14:37 <hunt> merijn: as long as my copyright is included im satisfied, ive currently gone with the MIT lisence
21:14:38 <c_wraith> Tokenizer: sounds like concatMap does what you want - applies a function that returns a list to a list of arguments, then concatenates the result lists
21:14:54 <PCChris> :t print
21:14:55 <lambdabot> Show a => a -> IO ()
21:14:57 <hunt> awkward
21:15:00 <Gurkenglas> > concat (map (\x->[1..x]) [5,3,6])
21:15:02 <lambdabot>  [1,2,3,4,5,1,2,3,1,2,3,4,5,6]
21:15:04 <hunt> so i have developed this project in a sandbox
21:15:10 <merijn> Actually, I may have something interesting
21:15:11 <hunt> and when i cabal install it installs it into the snadbox
21:15:18 <hunt> how do i cabal install the executable to my computer
21:15:20 <Gurkenglas> > concatMap (\x->[1..x]) [5,3,6]
21:15:21 <lambdabot>  [1,2,3,4,5,1,2,3,1,2,3,4,5,6]
21:15:21 <Hodapp> dfeuer_: Sure it does, since "private" covers quite a lot of things.
21:15:24 <Gurkenglas> @src concatMap
21:15:25 <lambdabot> concatMap f = foldr ((++) . f) []
21:15:35 <merijn> I gave a talk on copyright at university, since I thought it was important people understand the what and how, I still have my slides for those, lemme put them online
21:15:46 <Gurkenglas> (... I was hoping for "(concat . map)" there)
21:16:15 <Axman6> using foldl means more optimisation rules can be fired
21:16:33 <Axman6> like the build/fold rule (should've said foldr before)
21:16:37 <Hodapp> dfeuer_: If I give you a draft of a book I'm working on, but have shown to no one else, I haven't automatically turned copyright over to you.
21:16:46 <merijn> hunt, dfeuer_: http://files.inconsistent.nl/slides.pdf
21:16:49 <hunt> can anyone locate for me or assist me in finding out how i can cabal install my project to my bin legitimately
21:16:58 <hunt> thanks merijn
21:17:56 <dfeuer_> Axman6, that def of concatMap isn't actually fully optimizabel.
21:19:27 <dfeuer_> Axman6, that's a "good consumer" but not a "good producer". The simplest way to write a "perfect" concatMap is concatMap f xs = [y | x <- xs, y <- f x]
21:20:23 <dfeuer_> But you could also write it out with build and foldr and all that nastiness if you like.
21:23:21 <dfeuer_> merijn, interesting stuff, but the slideshow format is a bit worky outside a lecture.
21:23:38 <hunt> anyways, last call, anyone know how to cabal-install my package and the executable into the bin properly?
21:23:40 <merijn> dfeuer_: Sure, maybe I should write a prose version of it
21:23:59 <merijn> hunt: If you're in your package directory, just run "cabal install" in there
21:24:00 <dfeuer_> merijn, did you catch all my crazy comments about your documentation?
21:24:08 <merijn> dfeuer_: Most, yeah
21:24:11 <hunt> merijn: i do but it installs into my sandbox
21:24:16 <merijn> hunt: oh
21:24:20 <hunt> merijn: anyway to get it to break out of the sandbox?
21:24:36 <hunt> pretty silly that it just installed itself into its sandbox
21:24:37 <merijn> hunt: "rm -r .cabal-sandbox .cabal.sandbox.config"
21:24:47 <hunt> i have to destroy the sanbox D:??!
21:25:04 <merijn> dfeuer_: But unlike this (for now) fictional article, I already had these slides :)
21:25:27 <merijn> hunt: Did you just want the executable?
21:25:34 <hunt> merijn: yea
21:25:54 <merijn> hunt: It should be somewhere in the .cabal-sandbox folder
21:25:57 <hunt> ah ha
21:25:59 <merijn> hunt: You can just copy it out
21:26:01 <hunt> --ignore-sandbox
21:26:05 <hunt> !!!
21:26:07 <hunt> i can use that
21:26:08 <dfeuer_> merijn, you think the ACM and IEEE are evil (which they may be), although ACM at least is *less* evil than some. I think slides are evil.
21:26:10 <hunt> thats useful
21:26:22 <dfeuer_> Unless the slides are photos.
21:31:04 <merijn> dfeuer_: That must be making it difficult to visit presentations :)
21:31:07 * hackagebot yesod-test 1.4.1 - integration testing for WAI/Yesod Applications  http://hackage.haskell.org/package/yesod-test-1.4.1 (MichaelSnoyman)
21:31:51 <dfeuer_> merijn, graphs are okay too, and charts. But more than a few words tends to be too many for slides.
22:11:08 * hackagebot file-command-qq 0.1.0.1 - Quasiquoter for system commands involving filepaths  http://hackage.haskell.org/package/file-command-qq-0.1.0.1 (JonathanFischoff)
22:11:10 * hackagebot hask 0 - Categories  http://hackage.haskell.org/package/hask-0 (EdwardKmett)
22:11:46 <solatis> how good is haskell's memoization? good enough that i can just rely on it without thinking too much about it, or are there edge-cases i should be aware of?
22:12:04 <Axman6> there is none unless you specify there should be some
22:12:15 <solatis> ok got it
22:12:38 <Axman6> in theory you can memoise many functions, but it is not done because it's usually not a good idea
22:13:03 <Axman6> of course, you can't memoise functions which take arbitrary functions as arguments
22:13:31 <solatis> so explicitly writing your code to not rely on memoization is usually the better approach, if not too much of an effort?
22:14:01 <Axman6> not sure what you mean
22:14:42 <solatis> ok, to explain: i have a tree-like structure (Text.XML.Document) and need to perform certain lookups inside this structure
22:14:47 <solatis> these lookups can be expensive
22:15:07 <solatis> and some lookups are repeated more than once
22:15:25 <solatis> (like, 'get a certain <div id='foo' />')
22:16:07 <solatis> i can make it explicit that such a lookup is only performed once, by actually performing it exactly once and sharing the results between the functions that need it
22:16:09 * hackagebot file-command-qq 0.1.0.2 - Quasiquoter for system commands involving filepaths  http://hackage.haskell.org/package/file-command-qq-0.1.0.2 (JonathanFischoff)
22:16:28 <solatis> *or* i can call such a lookup function multiple times, and rely on memoization to only perform the lookup once
22:20:45 <solatis> i think i'm just going to rely on memoization at first, since i think it will make my code most elegant
22:20:56 <trap_exit> those that claim haskell's type system to be lacking -- what are they looking for?
22:21:09 * hackagebot file-command-qq 0.1.0.3 - Quasiquoter for system commands involving filepaths  http://hackage.haskell.org/package/file-command-qq-0.1.0.3 (JonathanFischoff)
22:21:11 <solatis> trap_exit: Om
22:21:23 <solatis> :)
22:21:50 <trap_exit> Om ?
22:21:53 <trap_exit> the react in clojure library ?
22:22:28 <solatis> i believe that was that haskell derivative language used internally at some UK bank
22:22:59 <trap_exit> fuck those guys
22:23:03 <trap_exit> with a strict haskell
22:23:04 <merijn> solatis: Are you thinking of Mu? Which is lennart's compiler/language at standard chartered
22:23:05 <trap_exit> and not releasing it ot the world
22:23:09 <solatis> oh
22:23:11 <solatis> yes
22:23:13 <solatis> Mu
22:23:14 <trap_exit> yeah, I think it's Mu
22:23:19 <solatis> don't know hwere I got Om from
22:23:21 <Axman6> trap_exit: see Desciple
22:23:25 <trap_exit> clojure + react = Om
22:23:39 <Axman6> (not quite Haskell, but strict and with some very cool features)
22:23:46 <solatis> those names these kids gives their languages these days...
22:24:10 <trap_exit> it's harder and harder to search
22:24:12 <trap_exit> Go, Mu
22:24:18 <trap_exit> if I create a labngautge, I'm goign to name it XXX
22:24:21 <trap_exit> good luck finding info on it
22:24:21 <merijn> trap_exit: That's also rather harsh, considering the amount of work Lennart contributed to haskell. And you might wanna watch out considering he's in the channel occasionally
22:24:27 <solatis> i'm going to name it 'print'
22:25:20 <trap_exit> merijn: I'm not criizing him in particular (I have no idea who he is); I'm venting my anger towards the general direction of the entire managemnet team that decided to not release the language
22:25:37 <solatis> it's a bank
22:25:47 <solatis> they probably consider it as a part of their IP
22:25:56 <solatis> and a competitive advantage
22:26:09 * hackagebot file-command-qq 0.1.0.4 - Quasiquoter for system commands involving filepaths  http://hackage.haskell.org/package/file-command-qq-0.1.0.4 (JonathanFischoff)
22:26:22 <Welkin> does anyone know how to parse json?
22:26:25 <indiagreen> solatis: what you're saying doesn't make them look less... evil
22:26:34 <merijn> Plenty of companies don't release their software, what makes not releasing a compiler worse than anything else
22:26:48 <indiagreen> Welkin: use aeson
22:26:52 <merijn> indiagreen: What does evil have to do with it?
22:26:56 <Welkin> I know about aeson
22:27:00 <Welkin> I am having trouble with it
22:27:06 <Welkin> I cannot get any json to parse
22:27:26 <solatis> indiagreen: if people aren't allowed to make their own language derivatives without releasing the source code, we're gonna have a bad time
22:27:38 <trap_exit> besides the fact it's something I want?
22:27:39 <trap_exit> not much else
22:28:03 <solatis> Welkin: please provide a test case and paste it on lpaste.net/new/haskell
22:28:10 <indiagreen> solatis: yes. However, I admit occasionally thinking “how dare you not release it” on the gut level
22:28:38 <solatis> indiagreen: then you should convince our overlords to relicense the Haskell IP
22:28:49 <solatis> this is true freedom
22:28:51 <indiagreen> and “they use <not releasing it> to get competitive advantage” does nothing to alleviate this feeling
22:28:53 <Welkin> I am using yesod and parsing a POST request
22:29:16 <Welkin> the functions available are parseJsonBody and requireJsonBody
22:29:26 <Welkin> the proper one to use is parseJsonBody
22:29:30 <merijn> indiagreen: Unlike, every other company that writes in house software and uses that as competitive advantage?
22:29:34 <trap_exit> i woiuld argue that releeasing a langauge is l;ess risky and generates more good will then releaising optimized libraries (i.e. janestreet)
22:30:14 <solatis> i think we should actually be glad that there's a company out there embracing haskell like those guys are -- and all people here do is wining that they should release the language
22:30:20 <Welkin> it expects a (FromJson a) => Result a0
22:30:20 <merijn> Anyway, back to netflix, this is not a very constructive conversation :)
22:30:29 <solatis> this is actually great for haskell, and functional programming in general
22:30:40 <trap_exit> wining is good,
22:30:44 <trap_exit> musch better than whining
22:30:56 <solatis> sorry, english is not my native language :)
22:31:06 <solatis> i sometimes make mistakes like that.
22:34:17 <Welkin> so how do I use parseJsonBody?
22:34:25 <Welkin> (from yesod)
22:34:32 <Welkin> http://hackage.haskell.org/package/yesod-core-1.4.3/docs/Yesod-Core-Json.html
22:35:24 <pharpend> you just write a FromJSON instance for your type
22:35:29 <Welkin> I did
22:35:47 <pharpend> and then run parseJsonBody, which would give you HandlerT app IO a
22:35:53 <pharpend> (presumably)
22:37:11 <Welkin> I tried that
22:37:21 <pharpend> post your code will ya
22:37:31 <Welkin> I need to provide a type for parseJsonBody (:: Handler MyType)
22:37:52 <Welkin> that gives me the error that it is expecting Handler (Result a)
22:38:00 <Welkin> so I change it to that, and it stops complainging
22:38:03 <pharpend> parseJSONbody needs Handler (Result MyType)
22:38:06 <Welkin> but then the parsing fails
22:38:06 <pharpend> yeah
22:38:12 <pharpend> oh hmm
22:38:14 <pharpend> lemme see the code
22:39:22 <Welkin> http://lpaste.net/114030
22:39:50 <DTSCode> the haskell bot is lambdabot right?
22:39:57 <merijn> yeah
22:40:16 <DTSCode> wheres the source code?
22:40:31 <sivteck> @version
22:40:31 <lambdabot> lambdabot 5.0-int-e
22:40:31 <lambdabot> git clone git://github.com/int-e/lambdabot.git
22:40:31 <geekosaur> @version
22:40:31 <lambdabot> lambdabot 5.0-int-e
22:40:32 <lambdabot> git clone git://github.com/int-e/lambdabot.git
22:40:33 <Welkin> I can view my POST data in my browser, so I know it is proper json
22:40:44 <DTSCode> ty
22:44:19 <adas> is there a way  to determine in what order to build the transformer stack?
22:44:41 <dramforever> adas: according to what do you want
22:44:49 <dramforever> and unmtl might help
22:45:06 <dramforever> @unmtl ExceptT E (StateT S IO) a
22:45:06 <lambdabot> ExceptT E (StateT S IO) a
22:45:10 <dramforever> ouch
22:45:15 <dramforever> @unmtl ErrorT E (StateT S IO) a
22:45:15 <lambdabot> (StateT S IO) (Either E a)
22:45:27 <dramforever> @unmtl (StateT S IO) (Either E a)
22:45:27 <lambdabot> (StateT S IO) (Either E a)
22:45:32 <dramforever> ???
22:45:39 <dramforever> @unmtl StateT S IO (Either E a)
22:45:39 <lambdabot> S -> IO ((Either E a), S)
22:45:42 <dramforever> yep
22:46:12 <adas> what does the output of unmtl exactly say?
22:46:20 <dramforever> the underlying function
22:46:24 <ThreeOfEight> Is there a good, idiomatic way of chaining computations that yield Maybe while giving a fixed return value for the Nothing case?
22:46:25 <dramforever> @unmtl Reader R a
22:46:26 <lambdabot> R -> a
22:46:29 <jle`> it unrolls the type synonym
22:46:41 <jle`> Reader R a is just a type synonym for (R -> a)
22:46:44 <dramforever> well, newtype, not type synontm
22:46:49 <dramforever> synonym
22:46:49 <jle`> ah yeah, newtype.
22:47:11 <jle`> StateT S IO (Either E a) is just a newtype wrapper over a S -> IO ((Either E a), S)
22:47:14 <ThreeOfEight> At the moment, I have case a of {Nothing -> b; Just x -> case f x of {Nothing -> g x; Just y -> h x y}}
22:47:19 <dramforever> ThreeOfEight: your problem have two parts
22:47:22 <dramforever> 1. Chaining
22:47:25 <dramforever> 2. default value
22:47:48 <ThreeOfEight> Are you sure?
22:47:55 <dramforever> > fromMaybe 1 Nothing
22:47:56 <lambdabot>  1
22:47:59 <dramforever> > fromMaybe 1 (Just 2)
22:48:00 <lambdabot>  2
22:48:08 <adas> jle`: oh .. so it removes teh type synonyms and shows the actual underlying types?
22:48:11 <dramforever> fromMaybe is from Data.Maybe
22:48:13 <jle`> adas: yeah.
22:48:17 <int-e> ... all I wanted is an EitherT monad transformer, why am I getting the comonad package?
22:48:19 <jle`> it sort of takes the magic out of things
22:48:19 <dramforever> and for chaining
22:48:23 <ThreeOfEight> dramforever: I know fromMaybe, but that doesn't really help me here, does it?
22:48:29 <dramforever> ?
22:48:32 <jle`> int-e: presumably to provide instances ;)
22:48:39 <dramforever> ThreeOfEight: try this
22:48:42 <ThreeOfEight> I don't want a default value for every Maybe-yielding operation
22:48:44 <jle`> it's the edwardk way
22:48:58 <ThreeOfEight> As soon as I get a Nothing, I want the chain to stop and return some value
22:49:02 <dramforever> so
22:49:08 <ThreeOfEight> that may depend on the previous obtained Just values
22:49:10 <dramforever> let me see...
22:49:11 <edwardk> int-e: because if i don't pick someone to include the other then nothing works together
22:49:14 <int-e> jle`: probably, but this is crazy nevertheless. I could've written my own instance in the meantime.
22:49:31 <edwardk> int-e: and frankly my code needs to work with itself or it doesn't work for _me_.
22:49:32 <dramforever> do { x <- Nothing; y <- Just 2; return (x+y)}
22:49:39 <dramforever> > do { x <- Nothing; y <- Just 2; return (x+y)}
22:49:40 <lambdabot>  Nothing
22:49:46 <dramforever> > do { x <- Just 5; y <- Just 2; return (x+y)}
22:49:48 <lambdabot>  Just 7
22:49:51 <ThreeOfEight> I considered transforming the Maybe to an Either
22:49:55 <dramforever> no
22:49:55 <Hijiri> so why not fromMaybe default (bunch of things done with Maybe Monad instance)
22:49:59 <dramforever> you don't have to
22:50:15 <dramforever> ThreeOfEight: Maybe works
22:50:24 <dramforever> > do { x <- Nothing; y <- Just 2; return (x+y)}
22:50:25 <lambdabot>  Nothing
22:50:29 <dramforever> > do { x <- Just 2; y <- Just 2; return (x+y)}
22:50:31 <lambdabot>  Just 4
22:50:33 <solatis> interesting that memoization is not a core haskell language feature! i always thought it was..
22:50:45 <Hijiri> there's sharing
22:51:04 <edwardk> solatis: http://community.haskell.org/~simonmar/papers/weak.pdf <- there are lots of ways to do it
22:51:08 <dramforever> ThreeOfEight: how is the maybe monad?
22:51:20 <edwardk> solatis: so what we do is provide you with all the tools you need to do it however you want for the particular application you have
22:51:26 <solatis> edwardk: i'm now going to use http://hackage.haskell.org/package/monad-memo i think
22:51:40 <solatis> yeah i understand
22:52:05 <edwardk> standardizing on one way when there are lots of points with very valid trade-offs in the design space is something we generally avoid ;)
22:52:17 <ThreeOfEight> dramforever: the Maybe monad gives me no information on /when/ it failed
22:52:25 <ThreeOfEight> maybe I should explain my use case a bit better
22:52:32 <ThreeOfEight> I am using Data.Heap
22:52:43 <solatis> i understand. i have been a c++ developer for 10 years, i know sometimes you just have to leave certain features out of the core language because you cannot make everyone happy.
22:52:47 <ThreeOfEight> and there is a view function, which returns Maybe (a, a Heap)
22:53:18 <ThreeOfEight> I now want to do a three-way branch on whether the heap has 0, 1, or ≥ 1 elements
22:53:25 <edwardk> solatis: well what they did was bake the things into the core language that had to be there to support all the ways you could do it, then left it as a library thing to implement the right strategy for each purpose
22:53:26 <ThreeOfEight> if it's 0, I return []
22:53:30 <solatis> c++ 'concepts' (which are similar to typeclasses) were supposed to reach it in c++11, but apparently it's going to be in c++18, because the committee couldn't agree on which Concepts to include in the language :)
22:53:30 <Welkin> pharpend: any luck?
22:53:38 <ThreeOfEight> if it's 1, I return [f x] (where x is the sole element)
22:53:40 <edwardk> most folks can actually get away with 'memoizing' with simple lazy structures
22:53:47 <edwardk> e.g. luke palmer's package
22:53:50 <ThreeOfEight> and if it's ≥ 2 (sorry, I meant ≥ 2), I recurse
22:53:58 <edwardk> http://lukepalmer.wordpress.com/2008/10/14/data-memocombinators/
22:54:11 <edwardk> or conal's http://hackage.haskell.org/package/MemoTrie
22:54:14 <edwardk> etc.
22:54:15 <ThreeOfEight> I don't see how I can achieve that with the Maybe monad and default values
22:54:15 <dramforever> ThreeOfEight: why I feel that your case looks like a fold
22:54:22 <edwardk> or even my representable-tries
22:54:23 <solatis> for me it's about caching certain DOM traversals/lookups
22:54:28 <ThreeOfEight> a fold on what?
22:54:36 <dramforever> on the heap
22:54:57 <ThreeOfEight> not really; I take out two elements from the heap and insert one back in in every step
22:55:05 <int-e> But ok. In the end I've got what I wanted:  forall b. EitherT (f b) (Cont b) a  is a free monad, with  liftFree x = EitherT (cont (\cnt -> cnt (Left (fmap (cnt . Right) x)))).
22:55:33 <dramforever> ThreeOfEight: can you paste your whole function? http://lpaste.net/new/haskell
22:55:35 <ThreeOfEight> I'm implementing the differencing heuristic for approximating the 2-way set partition problem
22:55:54 <DTSCode> so how would i build lambdabot ?
22:55:54 <dramforever> well, just pasting the useful parts
22:56:02 <wei2912> DTSCode: what?
22:56:21 <DTSCode> i git cloned the source, and was wondering how do i build it?
22:56:26 <Hijiri> cabal install?
22:56:44 <edwardk> solatis: well concepts had a few other problems, too as i recall
22:56:54 <dramforever> hmm...
22:56:54 <DTSCode> in $Source/lambabot?
22:56:55 <edwardk> e.g. http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2893.pdf
22:57:48 <dramforever> ThreeOfEight: maybe you need view patterns
22:58:02 <solatis> edwardk: i recall the discussion was mainly about including only the *minimal* concepts (like, only 10 different ones) or include a *lot* of concept (+- 80)
22:58:10 <int-e> DTSCode: something like  cabal sandbox init; cabal sandbox add-source lambdabot-*/ lambdabot/; cabal install lambdabot
22:58:16 <dramforever> > let f (tail -> x) = x in f [1,2,3,4,5]
22:58:17 <lambdabot>  [2,3,4,5]
22:58:17 <solatis> at least, that's what i was told at the BoostCon last year
22:58:22 <DTSCode> ty int-e
22:58:54 <int-e> DTSCode: there are several packages, so a plain  cabal install  will be harder. (cabal install lambdabot-*/ lambdabot/  probably works, but I prefer doing it all in a sandbox)
22:59:17 <DTSCode> oh ok
22:59:58 <int-e> DTSCode: finally to run the thing in the sandbox, cabal exec .cabal-sandbox/bin/lambdabot  should do the trick.
23:00:27 <DTSCode> ok. can i message you if i have any more issues?
23:01:11 * hackagebot json-python 0.4.0.0 - Call python inline from haskell  http://hackage.haskell.org/package/json-python-0.4.0.0 (russell91)
23:04:18 <Welkin> pharpend: are you still here?
23:04:19 <int-e> DTSCode: Sure, I may take a while to answer though.
23:05:04 <DTSCode> ok. thanks in advance!
23:06:11 * hackagebot json-python 0.4.0.1 - Call python inline from haskell  http://hackage.haskell.org/package/json-python-0.4.0.1 (russell91)
23:06:25 <int-e> Fuuzetsu: http://lpaste.net/114031  is what I had in mind with my bold claim about Cont.
23:10:26 <pharpend> Welkin: just reconnected
23:11:15 <Welkin> okay
23:11:17 <Welkin> I figured it out
23:11:26 <Welkin> the haskell code is fine
23:11:32 <Welkin> it is a problem with my ajax query
23:11:51 <Welkin> apparently I was sending the post data as text instead of proper json
23:16:11 * hackagebot libjenkins 0.6.0 - Jenkins API interface  http://hackage.haskell.org/package/libjenkins-0.6.0 (MatveyAksenov)
23:16:13 * hackagebot highlighting-kate 0.5.10 - Syntax highlighting  http://hackage.haskell.org/package/highlighting-kate-0.5.10 (JohnMacFarlane)
23:19:00 <pharpend> Welkin: what did I say i was going to do?
23:19:56 <pharpend> Welkin: you shouldn't use bottoms in your code
23:20:36 <ThreeOfEight> Is there a pre-defined function for turning Maybe b into Either a b?
23:20:44 <ThreeOfEight> I cannot seem to find one with Hoogle.
23:20:48 <pharpend> no, but it's trivial to write one
23:21:00 <pharpend> myFunction (Just b) = Right b
23:21:04 <jle`> ThreeOfEight: no, but their should be
23:21:07 <jle`> *there
23:21:09 <jle`> :)
23:21:16 <ThreeOfEight> pharpend: I am perfectly aware of that, but thanks. ^^
23:21:18 <pharpend> myFunction Nothing = Left whateverYouWantHere
23:21:24 <jle`> :t maybe Left Just
23:21:25 <lambdabot>     Couldn't match type ‘Maybe a’ with ‘a1 -> Either a1 b’
23:21:25 <lambdabot>     Expected type: a -> a1 -> Either a1 b
23:21:25 <lambdabot>       Actual type: a -> Maybe a
23:21:26 <jle`> er
23:21:28 <dramforever> ouch!
23:21:31 <jle`> :t maybe Left Right
23:21:32 <lambdabot>     Couldn't match type ‘Either a0 a’ with ‘a1 -> Either a1 b’
23:21:32 <lambdabot>     Expected type: a -> a1 -> Either a1 b
23:21:32 <lambdabot>       Actual type: a -> Either a0 a
23:21:40 <jle`> >_> you know what i mean.
23:21:47 * dramforever kept typing GHC when he actually meant GPS
23:21:48 <ThreeOfEight> I think you mean maybeToEither x = maybe (Left x) Right
23:21:50 <jle`> :t maybe (Left "hey") Right
23:21:51 <lambdabot> Maybe b -> Either [Char] b
23:21:58 <ThreeOfEight> that is what I have right now
23:22:06 <ThreeOfEight> I just thought there ought to be something like this in Data.Either or Data.maybe
23:22:09 <ThreeOfEight> But apparently not
23:22:09 <jle`> ikr.
23:22:20 <pharpend> ThreeOfEight: there might be something in transformers
23:22:23 <jle`> also what would be nice would be an Either e a -> Maybe a
23:22:34 <ThreeOfEight> similarly, Either a a -> a
23:22:34 <pharpend> ThreeOfEight: so, you might have EitherT Maybe a
23:22:56 <jle`> i haven't run into a case for Either a a -> a yet but i guess so
23:23:10 <ThreeOfEight> jle`: same problem that I described before
23:23:13 <pharpend> ThreeOfEight: Might I suggest writing a package to do this
23:23:20 <pharpend> ThreeOfEight: it would take about ten minutes
23:23:38 <ThreeOfEight> I want to chain computations that yield Maybe
23:23:42 <jle`> yeah, but...adding yet another utility package subject to bitrot might not be the best solution
23:23:49 <pharpend> ThreeOfEight: use Maybe's monad instance
23:23:56 <ThreeOfEight> pharpend: no, that doesn't work
23:24:14 <ThreeOfEight> I'll privmsg you the code ^^
23:24:16 <pharpend> > Just 1 >>= \a -> Just (a + 1) >>= \b -> Just (b + 1)
23:24:18 <lambdabot>  Just 3
23:24:26 <ThreeOfEight> (it's an assignment for students, so I don't want to post it on the channel)
23:24:31 <pharpend> ThreeOfEight: ah
23:27:14 <bergmark> ThreeOfEight: i think that function doesn't meet the fairbairn threshold
23:27:35 <biinui> what are these packages that hackagebot mentions? is this random?
23:27:38 <ThreeOfEight> possibly
23:28:07 <ThreeOfEight> but it is arguably just as reasonable a function as maybeTolist
23:28:09 <bergmark> biinui: uploads to hackage, and new revisions of old versions too i think
23:28:46 <biinui> bergmark: cool thanks.
23:29:06 <ThreeOfEight> jle`: unless I can think of a few more useful functions like that, it is probably overkill to turn it into a package
23:29:11 <jle`> i don't know, i think it's nice to have a canonical version of it, like maybeToList
23:29:16 <bergmark> ThreeOfEight: i hate that name, headMay (from safe) is so much clearer :-), but it actually solves a problem; head is unsafe
23:29:20 <jle`> yeah, i don't even think utility packages are really a good idea
23:29:44 <jle`> bergmark: it's a useful natural transformation :)
23:30:00 <bergmark> oops i was thinking of listToMaybe
23:30:16 <solatis> ok, i give up -- memoization seems most appropriate in recursive functions, and what i'm trying to do probably doesn't justify memoization
23:30:36 <jle`> eitherToMaybe and maybeToEither...both would be nice natural transformations
23:30:45 <jle`> and i think we could always use some more natural transformations :)
23:30:51 <solatis> i can wrap things in a MonadMemo, but then i end up with 5 different MonadMemo's in my code
23:30:56 <jle`> (maybeToEither e), that is.
23:32:01 <jle`> natural transformations are among the more useful things you can do with types in haskell so having canonical ones laying around i think would be nice
23:34:00 <jle`> and if we keep the naming conventions then it wouldn't be too tricky either
23:37:02 <jle`> :t id ||| id
23:37:03 <lambdabot> Either a a -> a
23:37:51 <ThreeOfEight> ooh dear, Arrows >_>
23:37:52 <kadoban> :t (|||)
23:37:53 <lambdabot> ArrowChoice a => a b d -> a c d -> a (Either b c) d
23:38:05 <ThreeOfEight> I just cannot wrap my head around those
23:38:08 <jle`> this actually doesn't really have anything to do with the idea of Arrows, it's rather misplaced i think.
23:38:27 <jle`> this is just the normal destructor/church encoding of Either
23:38:51 <jle`> there isn't any reason why it should depend on or be related to Arrow
23:38:54 <jle`> v.v
23:39:02 <jle`> none of its methods involve anything Arrow
23:39:44 <pharpend> :t id
23:39:45 <lambdabot> a -> a
23:39:54 <jle`> ArrowChoice is actually a pretty useful idea, but the usage of it in this case here is a degenerate/abusive use case, i feel.
23:40:13 <jle`> :t (|||) `asAppliedTo` (undefined :: a -> b)
23:40:14 <lambdabot> (a -> b) -> (c -> b) -> Either a c -> b
23:40:21 <jle`> that might be a bit easier to understnad :)
23:40:39 <sinelaw> Hello. doctest is complaining that something isn't what it expects, but the two outputs are identical.
23:41:03 <jle`> sinelaw: does their Eq instance yield True when compared with (==)?
23:41:33 <sinelaw> hmm.
23:41:33 <jle`> Show is not necessarily surjective
23:41:57 <jle`> oh that's the wrong word
23:42:09 <sinelaw> commutative?
23:42:14 <sinelaw> injective?
23:42:25 <sinelaw> never mind. I found the problem: the function was returning IO something
23:42:31 <jle`> two different things can Show into the same output
23:42:33 <sinelaw> changed it to not do IO
23:42:47 <sinelaw> thanks, you pointed me in the right direction
23:43:02 <jle`> np
23:43:28 <jle`> ThreeOfEight: Arrows aside, we'll focus on the (->) instance
23:43:36 <jle`> (|||) is to Either what `maybe` is to Maybe
23:43:53 <jle`> actually there is literallya  function called `either` >_>
23:43:57 <jle`> i totally forgot about that.
23:44:00 <jle`> :t either
23:44:01 <lambdabot> (a -> c) -> (b -> c) -> Either a b -> c
23:44:05 <bergmark> :-)
23:44:20 <ThreeOfEight> jle`: yes, I know that one
23:44:38 <ThreeOfEight> I have ‘stripEither = either id id’ in my code already.
23:44:40 <jle`> so (|||) in this case is the same thing
23:44:51 <jle`> except infix
23:44:55 <bergmark> but (+++) isn't anywhere else i think?
23:45:48 <jle`> :t (+++) `asAppliedTo` (undefined :: a -> b)
23:45:49 <lambdabot> (a -> b) -> (b' -> c') -> Either a b' -> Either b c'
23:46:11 <jle`> it's bimap
23:46:15 <jle`> :t bimap
23:46:15 <lambdabot> Bifunctor p => (a -> b) -> (c -> d) -> p a c -> p b d
23:46:23 <ThreeOfEight> Bifunctors are awesome.
23:47:42 <jle`> (a -> c) -> (b -> d) -> Either a b -> Either c d...generalize over Either and you get bimap, generalize over (->) and you get (+++)
23:53:56 <jle`> which reminds me of how many variations of (.) there are in base/common libraries
23:54:10 <jle`> because there are so many things you can generalize over, heh.
23:54:25 <jle`> there are probably at least twenty (.)'s.
23:54:32 <jle`> i pulled that number from nowhere, don't quote me
23:54:45 <jle`> :)
23:54:52 <int-e> the internet said ...
23:55:09 <jle`> collecting them all and putting them down might be fun.
23:56:49 <trap_exit> 8 more minutes
23:56:54 <trap_exit> until monday
23:57:33 <bergmark> already monday here, it's pretty nice i have to say
