00:04:57 <glguy> dwat3r: Are you sure you want nonblocking?
00:11:34 --- topic: 'http://www.haskell.org/ | Paste code/errors: http://lpaste.net/new/haskell | Logs: http://tunes.org/~nef/logs/haskell/?C=M;O=D http://ircbrowse.net/day/haskell/today?mode=recent | Administrative issues: #haskell-ops | Hackage status? http://status.haskell.org'
00:11:34 --- topic: set by glguy on [Thu Sep 25 17:55:19 2014]
00:15:31 <trap_exit> what are good boopks on staying calm and staying focused even under deadlines / stress
00:18:24 <Cale> trap_exit: "Calculus" by Michael Spivak. No wait, that's a good introduction to mathematical analysis.
00:18:56 <trap_exit> Cale: indeed
00:19:04 <trap_exit> wtf does it have to do with poise under pressure?
00:19:09 <Cale> trap_exit: (probably you intended this question for #haskell-blah in any case)
00:19:20 <Cale> I'm just joking around, I have no real suggestions
00:19:22 <dwat3r> glguy: i don't know, i looked at example codes written in C with libssh2, and they all contained this command. Basically the idea of this little program is to run a command in the remote shell, then get the results. then repeat.
00:19:29 <trap_exit> I did not, but it does belong in -blah
00:21:17 <glguy> dwat3r: I think you're diving into the wrong code
00:21:25 <glguy> Check out the higher level interface of http://hackage.haskell.org/package/libssh2-0.2.0.3/docs/Network-SSH-Client-LibSSH2.html
00:25:16 <glguy> dwat3r: when I try to use that library in what seems like a resaonable way I get the same error code as you, sshd reports
00:25:16 <glguy> Packet integrity error (4 bytes remaining) at ../session.c:2163
00:25:16 <glguy> Disconnecting: Packet integrity error.
00:26:46 <dwat3r> glguy: wow.
00:34:34 <trap_exit> can type class members have variable arity
00:34:42 <trap_exit> or do all instances of a type class functino have to have the same arity?
00:34:55 <trap_exit> i.e. can I define a "foo" which is "Int -> Bool" and "String -> String -> Bool" ?
00:36:49 <ski> > let x = 2 in printf "%s = %d" "x + x" (x + x) :: String
00:36:51 <lambdabot>  "x + x = 4"
00:36:56 * hackagebot twitch 0.1.1.0 - A high level file watcher DSL  http://hackage.haskell.org/package/twitch-0.1.1.0 (JonathanFischoff)
00:37:35 <trap_exit> ?
00:39:51 <ski> what do you think the arity of `printf' is ?
00:43:20 <trap_exit> oh shit
00:43:22 <trap_exit> how the fuck does printf work?
00:43:29 <trap_exit> ski: that is brilliant
00:44:26 <trap_exit> @src printf
00:44:26 <lambdabot> Source not found. The more you drive -- the dumber you get.
00:44:30 <trap_exit> how does printf work?
00:45:10 <Hafydd> :t printf
00:45:11 <lambdabot> PrintfType r => String -> r
00:45:31 <Hafydd> It uses typeclasses, as you can see.
00:46:11 <ski> it's sortof a kludge
00:55:57 <marvimias> :t print
00:55:58 <lambdabot> Show a => a -> IO ()
01:03:43 <ThreeOfEight> Transfusion: it's called polyvariadic functions
01:03:49 <ThreeOfEight> oh, sorry
01:04:02 <ThreeOfEight> wrong ping. Wanted to ping trap_exit.
01:04:23 <ThreeOfEight> I use that sometimes, e.g. for HLists.
01:41:58 * hackagebot yesod-bin 1.4.0.7 - The yesod helper executable.  http://hackage.haskell.org/package/yesod-bin-1.4.0.7 (MichaelSnoyman)
02:01:59 * hackagebot libgraph 1.3 - Store and manipulate data in a graph.  http://hackage.haskell.org/package/libgraph-1.3 (faddegon)
02:02:00 <javjarfer> Hi all! Anyone knows if Haskell has any syntax to take a list of functions as argument? Something like this [(Int -> Int -> Int)].
02:03:13 <supki> :t [(+), (-), (*)]
02:03:14 <lambdabot> Num a => [a -> a -> a]
02:05:28 <Hafydd> javjarfer: it's the same syntax as for a list of any other type.
02:05:29 <javjarfer> Come on... Just removing the parenthesis... Thanks you...
02:06:13 <javjarfer> Thanks I have just used with successful results
02:06:47 <javjarfer> Awesome like always
02:07:20 <bergmark> @type [(+), (-)] :: Num a => [(a -> a -> a)]
02:07:21 <lambdabot> Num a => [a -> a -> a]
02:07:25 <bergmark> parens are fine
02:21:59 * hackagebot rest-gen 0.16.1.2 - Documentation and client generation from rest definition.  http://hackage.haskell.org/package/rest-gen-0.16.1.2 (AdamBergmark)
02:27:00 * hackagebot animalcase 0.1.0.2 - Convert camelCase to snake_case and vice versa  http://hackage.haskell.org/package/animalcase-0.1.0.2 (ibotty)
02:35:03 <solatis> woa, compiling with or without optimization really makes a huge difference for ghc
02:35:23 <solatis> as in, it made the difference of my crawler architecture being CPU bound to being I/O bound
02:52:01 * hackagebot ses-html 0.2.0.2 - Send HTML formatted emails using Amazon's SES REST API with blaze  http://hackage.haskell.org/package/ses-html-0.2.0.2 (DavidJohnson)
03:15:08 <meme> @undo do x <- getChar ; putChar x
03:15:08 <lambdabot> getChar >>= \ x -> putChar x
03:15:30 <meme> @undo do x <- getChar ; putChar x ; print x
03:15:30 <lambdabot> getChar >>= \ x -> putChar x >> print x
03:16:03 <pavonia> @@ @pl @undo do x <- getChar ; putChar x ; print x
03:16:03 <lambdabot>  liftM2 (>>) putChar print =<< getChar
03:16:43 <meme> @undo do let x = x + 1; print x
03:16:44 <lambdabot> <unknown>.hs: 1: 26:Parse error: EOF
03:16:46 <solatis> pavonia: what did you just do?
03:16:57 <solatis> (no pun intended)
03:16:59 <meme> @undo do let x = x + 1; print x
03:16:59 <lambdabot> <unknown>.hs: 1: 26:Parse error: EOF
03:17:05 <meme> @undo do let x = x + 1 ; print x
03:17:05 <lambdabot> <unknown>.hs: 1: 27:Parse error: EOF
03:17:21 <pavonia> solatis: Combined undo and pointfree
03:18:10 <solatis> hmz
03:18:27 <solatis> @help pl
03:18:27 <lambdabot> pointless <expr>. Play with pointfree code.
03:19:01 <meme> @undo do x <- getChar ; putChar x ; print x
03:19:01 <lambdabot> getChar >>= \ x -> putChar x >> print x
03:19:19 <meme> @undo do let x = 1 ; x <- getChar ; putChar x ; print x
03:19:19 <lambdabot> <unknown>.hs: 1: 18:Parse error: <-
03:19:45 <meme> @undo do let x = 1
03:19:45 <lambdabot> <unknown>.hs: 1: 13:Parse error: Last statement in a do-block must be an expression
03:19:54 <meme> @undo do let x = 1 ; print x
03:19:54 <lambdabot> <unknown>.hs: 1: 23:Parse error: EOF
03:20:51 <pavonia> @undo do let { x = 1 }; print x
03:20:52 <lambdabot> let { x = 1} in print x
03:21:20 <pavonia> Without braces it's ambiguous
03:27:14 <meme> @undo do print x
03:27:14 <lambdabot> print x
03:27:24 <meme> @undo do let x = x + 1
03:27:24 <lambdabot> <unknown>.hs: 1: 17:Parse error: Last statement in a do-block must be an expression
03:27:37 <meme> @undo do let x = x + 1; print 3
03:27:37 <lambdabot> <unknown>.hs: 1: 26:Parse error: EOF
03:27:44 <meme> @undo let x = x + 1; print 3
03:27:44 <lambdabot> <unknown>.hs: 1: 23:Parse error: EOF
03:28:07 <bor0> @undo do { let {x = 1}; print x }
03:28:07 <lambdabot> let { x = 1} in print x
03:28:07 <meme> pavonia: are you talking to me?
03:28:20 <pavonia> Yes
03:28:42 <meme> ho! sorry! I am new to Haskell and to this IRC
03:28:58 <bor0> @undo do { x <- readFile "test.hs" ; let {y = 1} ; print (x, y) }
03:28:58 <lambdabot> readFile "test.hs" >>= \ x -> let { y = 1} in print (x, y)
03:29:22 <meme> I thought that all lambda bot commands like @undo were not visible to you guys. SORRY?
03:30:16 <MP2E> you can '/query lambdabot' to use it privately.
03:30:32 <zar_> =]
03:31:18 <meme> thanks MP2E
03:32:50 <meme> ok, let me put my first public question here!
03:34:00 <meme> if otherwise is the same as True, why does Haskell accept "otherwise -> ..." in a case expression when the tested expression does not compute into a Bool?
03:34:26 <Rembane> Maybe it works as a catch-all-expression? I'm guessing wildly.
03:34:32 <meme> I thought that the natural thing was to give a type error!!
03:34:57 <Taneb> meme, because it's being used as a pattern, rather than an expression
03:34:58 <pavonia> otherwise is a variable here, it matches to anything
03:35:02 <meme> and instead of using "otherwise -> ... " the right thing would be using "_ -> ..."
03:36:09 <pavonia> > case "foo" of { "bar" -> error "something's wrong"; otherwise -> reverse otherwise }
03:36:10 <lambdabot>  "oof"
03:36:11 <zariuq> I have wondered why we use otherwise with guards rather than True. As both work.
03:36:15 <meme> in that case, that's a BAD choice for Haskell, because is a point of confusion
03:36:56 <pavonia> What choice is bad?
03:37:22 <meme> having diferent semantics for "otherwise" depending where it is used
03:37:51 <zariuq> :o ahh, in some cases having otherwise as a variable is convenient!  Cool :D
03:38:09 <pavonia> It's not spacial about otherwise, it can be donne with any legal variable name
03:38:28 <bergmark> meme: with that reasoning allowing `1' to be both a pattern and a number is a point of confusion
03:38:57 <zariuq> So using 'otherwise' as the variable name is just a Haskell custom.
03:39:18 <meme> yes I now understand that, but then otherwise should also have been just a variable name in guards, and instead of it, people should have been using True in guards. It would be more succint and cleaner
03:39:58 <meme> This is what Erlang does: using True -> ...
03:40:03 <pavonia> It is a variable name in guards
03:40:16 <pavonia> Guards are simply expressions of type Bool
03:40:47 <meme> well ... but a variable name that is bound to True in guards, but bound to anything in case. That's a BAD choice!
03:41:22 <pavonia> No, that makes perfectly sense
03:41:55 <bergmark> meme: i'd argue that using otherwise in a pattern is bad because it causes name shadowing, an ghc will warn you about that with -Wall
03:44:08 <meme> bergmark: nice to know about -Wall, but my personnel taste if for a language to be clean of "subtleties", instead of requiring typing commandline options to detect such "subtleties"
03:44:40 <bergmark> -Wall should be the default
03:44:48 <bergmark> in practice most people seem to use it
03:45:43 <pavonia> meme: What if you decide to use x as a pattern variable in a case, and someone later decides to define x = True? Would it be bad to allow the definition of x too? Or the use of x as a pattern variable?
03:53:35 <meme> echo
04:04:07 <kgadek> hi, anyone here interested in implementation of typecheckers? I have few questions
04:04:27 <kgadek> (actually both theory and implementation, I try to understand few concepts)
04:06:22 <pavonia> What questions?
04:06:59 <kgadek> I try to understand a part of HM(X) regarding the introduction of existential quantification on constraints
04:07:52 <kgadek> I found Sulzmann's papers (and Odersky's, et al) on that topic very interesting but I don't see how exists works
04:10:46 <kgadek> I suppose that some simple example of how solving constraints work with existentialism introduced would allow me to understand what's what
04:25:50 <Drezil> o/ anyone knows some simple datatypes like Maybe and Either with Functor/Applicative/Monad-Instance? I wanted to have an exercise for a lecture where students should define such a thing after seeing the stuff for Maybe, Either and List...
04:27:07 <codygman> Cale: Thanks, I'll do that at lunch or after work
04:30:53 <ClaudiusMaximus> Drezil: Reader:  (->) r  ; Writer: Monoid w => (,) w
04:32:03 <Drezil> ClaudiusMaximus: thx
04:47:05 * hackagebot repo-based-blog 0.0.1 - Blogging module using blaze html for markup  http://hackage.haskell.org/package/repo-based-blog-0.0.1 (saep)
04:47:10 <wakalabis> hi, guys.. I was reading an article by Graham Hutton (Programming with effects)
04:47:20 <wakalabis> ( http://www.cs.nott.ac.uk/~gmh/monads )
04:48:34 <wakalabis> There is an exercise asking you to show a datatype is monadic
04:48:53 <wakalabis> by implementing Monad type class
04:49:04 <wakalabis> the type is: data Expr a = Var a | Val Int | Add (Expr a) (Expr a)
04:49:39 <wakalabis> Any clues on how to implement (>>=) ?
04:50:19 <wakalabis> (Var a) >>= f = f a
04:50:54 <wakalabis> but what about (Val n) >>= f ? (Val n) is no related to type a
04:51:16 <saep> wakalabis: What is the type of (>>=) in your case?
04:51:19 <lieven> Nothing in the Maybe monad isn't related to type a either
04:51:41 <hyPiRion> wakalabis: (Val n) >>= f = Val n -- It works the same as the maybe monad/either monad
04:52:54 <wakalabis> saep: (>>=) :: Expr a -> (a -> Expr b) -> Expr b
04:53:24 <wakalabis> hyPiRion: doh... That makes sense
04:54:39 <wakalabis> hyPiRion: I can't figure out a useful interpretation for this monad, though
04:58:23 <hyPiRion> wakalabis: I can think of one. If you have Expr String, then you can make a function replaceVars :: Env -> String -> Expr Int. Now you can replace all variables by their actual values by doing myExpr >>= replaceVars myEnv
04:59:21 <wakalabis> hyPiRion: Like a reader!! yes! thanks
05:00:23 <hyPiRion> np :)
05:06:33 <Armel`> Hi, do anyone of you guys know a Haskell library to perfom program slicing (on binary files)? Thanks!
05:12:06 * hackagebot c2hs 0.19.1 - C->Haskell FFI tool that gives some cross-language type safety  http://hackage.haskell.org/package/c2hs-0.19.1 (IanRoss)
05:24:49 <blizzyschool> I have a question. What exactly does '\\' do?
05:25:28 <indiagreen> lets you have a backslash in a string
05:25:32 <exio4> > '\\'
05:25:33 <lambdabot>  '\\'
05:25:34 <exio4> character
05:25:47 <indiagreen> ah, in single quotes
05:25:50 <indiagreen> character then, yep
05:26:28 <blizzyschool> whoops, sorry. I meant to say
05:26:31 <blizzyschool> what does \\ do.
05:26:53 <indiagreen> > map (:[]) "abc\\def"
05:26:54 <saep> > [1,2,3,4] \\ [2,3]
05:26:55 <lambdabot>  ["a","b","c","\\","d","e","f"]
05:26:55 <lambdabot>  [1,4]
05:27:13 <osfameron> @src (\\)
05:27:13 <lambdabot> (\\) = foldl (flip delete)
05:27:32 <blizzyschool> oh ok. so it compares foo to bar and returns the characters matched.
05:27:48 <blizzyschool> so "ab" \\ "a" would return "b".
05:28:11 <saep> > [1,2,2,2,3,3,3,4] \\ [2,3]
05:28:13 <lambdabot>  [1,2,2,3,3,4]
05:28:35 <blizzyschool> thanks everyone.
05:29:02 <indiagreen> it returns the 1st list with all elements from the 2nd list removed (well, the 1st occurrence of an element removed)
05:29:38 <osfameron> > [1,2,3,4] \\ [2,2]
05:29:39 <lambdabot>  [1,3,4]
05:30:09 <osfameron> ah, so by comparison, not by position
05:31:49 <blizzyschool> thxs again everyone.
06:07:53 <arianvp_> I wanna build a game in haskell. what FRP to use?
06:07:55 <arianvp_> elerea?
06:17:09 * hackagebot stm-containers 0.2.1 - Containers for STM  http://hackage.haskell.org/package/stm-containers-0.2.1 (NikitaVolkov)
06:18:03 <Armel`> Hi, do anyone of you guys know a Haskell library to perfom program slicing (on binary files)? Thanks!
06:19:18 <osfameron> Armel`: you asked that before.  what does it mean?
06:19:44 <da-x> Is there a serialization & de-serialization library between algebric data types and human-editable-text (e.g. YAML) that can also utilize Data.Generic or Data.Data + Data.Typeable to avoid boilerplate? I know there's some for JSON, but I'd rather have something that looks more like a .cabal file
06:23:02 <c_wraith> da-x: isn't the YAML data model a superset of JSON, such that all you need is a different renderer to convert a JSON ADT to YAML?
06:23:14 <c_wraith> da-x: that implies the other direction could be problematic, though
06:23:48 <sopvop> unlike json yaml is stringly typed
06:24:05 <osfameron> in theory, even the *syntax* is a superset of json (though I've never actually seen any evidence of a YAML module correctly reading and writing JSON...)
06:24:33 <bergmark> da-x: the yaml package uses aeson so presumably you can use aeson's generics with it
06:25:29 <da-x> okay - perhaps XML can also be an in-between format
06:26:10 <da-x> but I'll try Aeson first
06:26:26 <benzrf> damn wreq looks super nice
06:29:06 <benzrf> this fancy typeclass garbage reminds me of fast food
06:29:14 <benzrf> it is delicious but bad for you ;)
06:31:06 <sopvop> why not http-streams?
06:32:52 <benzrf> sopvop: never heard of i  t
06:33:10 <sopvop> http://hackage.haskell.org/package/http-streams
06:34:17 <benzrf> hmmmmmmmmmm
06:34:24 <benzrf> how do we know that return is a ntrf?
06:34:43 <benzrf> is it covered by the monad laws?
06:34:46 <benzrf> or parametricity
06:35:12 <augur> ben__: ntrf?
06:35:29 <augur> er
06:35:36 <augur> benzrf: ntrf?
06:38:23 <arianvp_> arianvp
06:38:41 <augur> arianvp_: arianvp yourself!
06:38:53 <arianvp_> why thank you
06:39:12 <arianvp_> why are there so many FRP libs .-.
06:39:29 <Fuuzetsu> make your own to conquer them all
06:39:36 <arianvp_> I find it hard enough to make choices in my daily life. "What do I eat today?"  now I gotta choose an FRP lib as well?
06:39:44 <arianvp_> http://xkcd.com/927/
06:39:52 <Fuuzetsu> you can solve the first by eating the same thing always
06:40:37 <rom1504> and wearing the same shirt everyday
06:41:09 <Armel`> osfameron: Program slicing is a source code (or binary) minimalisation which only keep statements leading to a specified behavior. You can find an example with C source code on https://en.wikipedia.org/wiki/Program_slicing
06:41:52 <arianvp_> okay. so Soylent it is
06:41:54 <arianvp_> now FRP
06:41:59 <da-x> bergmark: cool, it worked.
06:42:02 <mikeplus64> @hackage soylent
06:42:02 <lambdabot> http://hackage.haskell.org/package/soylent
06:42:12 <mikeplus64> :)
06:42:58 <da-x> is there a instances-typeclass-based putStrLn implementation that I can import from somewhere so I don't have to know whether I am passing String, ByteString, Text...?
06:46:51 <mikeplus64> da-x: i'd be surprised if it wasn't in http://hackage.haskell.org/package/classy-prelude-0.10.2/docs/ClassyPrelude.html
06:47:14 <osfameron> Armel`: so what would it look like in haskell, as a binary?  is this just analysing the haskell core level?  or compiled code for a given platform?  (at which point, not specifically about haskell code?)
06:47:17 <kadoban> da-x: putStrLn . fromString ?
06:47:39 <kadoban> Oh...hmm, no.
06:48:15 <mikeplus64> da-x: yeah it's there, ctrl f "IOData"
06:48:25 <k00mi> arianvp: yampa and elerea seem to be the most "battle proven" for games
06:48:42 <k00mi> meaning, people have actually used these to write games
06:49:29 <k00mi> arianvp: you should also take a look at helm if you haven't yet
06:50:31 <mikeplus64> i haven't found frp to pull its weight honestly
06:50:37 <Armel`> osfameron: I'd like to do it in Haskell but not on Haskell source code or compiled code. (I'm targeting ARM or PowerPC binary code or disambled code)
06:50:44 <da-x> mikeplus64: good, I'll use that
06:51:15 <Pip> Hi anyway to colorize ghci ?
06:52:00 <osfameron> Armel`: ok!  I can't help, but I think I now understand what you want :-)  so hopefully someone else may have some suggestions with that additional info
06:53:51 <Pip> This channel was down just now, wasn't it?
06:54:31 <osfameron> don't think so.  perhaps you were netsplit
06:54:37 <Pip> Oh
06:55:00 <Pip> osfameron, How to make ghci interact prompt have colors?
06:55:25 <osfameron> I have no idea
06:55:46 <osfameron> but googling brings up https://www.haskell.org/haskellwiki/GHCi_in_colour
06:56:18 <da-x> mikeplus64: hmm, it fails build
06:56:45 <mads-> I do a lot of bash work both at work and for my studies. Would it be possible making a haskell script where I like do something with the first argument, pipe stuff in and such? Is this something there has been done before?
06:57:10 * hackagebot apiary 1.1.1 - Simple and type safe web framework that can be automatically generate API documentation.  http://hackage.haskell.org/package/apiary-1.1.1 (HirotomoMoriwaki)
06:57:12 * hackagebot apiary-helics 1.1.2 - helics support for apiary web framework.  http://hackage.haskell.org/package/apiary-helics-1.1.2 (HirotomoMoriwaki)
06:59:09 <mauketwork> mads-: I'm not sure I understand because what you're asking sounds trivial
06:59:29 <mauketwork> command line arguments: getArgs
06:59:39 <mauketwork> reading from stdin: getContents, getLine, etc.
07:02:11 * hackagebot Cascade 0.1.0.0 - Playing with reified categorical composition  http://hackage.haskell.org/package/Cascade-0.1.0.0 (NoahEasterly)
07:29:15 <mmmm> Can anyone reccomend a good textbook about concurrent programming? (which isn't Simon Marlow's book)
07:29:50 <Denommus> yesterday I explained FRP to my boss, and he got pretty excited about the concept
07:34:47 <benzrf> how is it going Denommus
07:35:44 <Denommus> benzrf: fine
07:45:28 <ThreeOfEight> What's the best way to write a polymorphic QuickCheck test that can easily be specialised?
07:45:53 <ThreeOfEight> For example, I have a QuickCheck test of type ‘ Foo a => Property’
07:46:11 <ThreeOfEight> how do I now test this for a = Bool, a = Integer, etc.?
07:46:25 <mauketwork> that doesn't look like a valid type
07:46:28 <ThreeOfEight> My current approach is to define the test with an additional phantom variable of type ‘a’
07:47:01 <ThreeOfEight> and then cal it with ‘prop (undefined :: Bool)’
07:47:05 <ThreeOfEight> *call
07:47:46 <ThreeOfEight> mauketwork: Why should it not be a valid type?
07:47:51 <ThreeOfEight> > read ""
07:47:53 <lambdabot>  *Exception: Prelude.read: no parse
07:47:56 <ThreeOfEight> er
07:47:59 <ThreeOfEight> :t read ""
07:48:00 <lambdabot> Read a => a
07:48:06 <mauketwork> because a only occurs in a class constraint
07:48:16 <ThreeOfEight> See this example.
07:51:03 <mauketwork> that has a on the right side of =>
07:51:35 <fds4345> Failed to install auto-update-0.1.2
07:52:00 <fds4345> gives no useful information even with cabal install -v3
07:52:13 * hackagebot hs-mesos 0.20.2.0 -   http://hackage.haskell.org/package/hs-mesos-0.20.2.0 (IanDuncan)
07:52:29 <fds4345> i think the download may e failing anyone got an idea?
07:55:28 <phaazon> today I made a neural network project (multilayer perceptron)
07:55:45 <phaazon> it was really interesting, and I’d like to know more about that kind of algorithm
07:56:06 <phaazon> for instance, I used a tangent sigmoïd
07:56:13 <phaazon> how such a function is picked up?
07:56:29 <phaazon> is there a way to apply that to, for instance, path finding?
07:57:13 * hackagebot hspec-wai 0.6.0 - Experimental Hspec support for testing WAI applications (depends on hspec2!)  http://hackage.haskell.org/package/hspec-wai-0.6.0 (SimonHengel)
08:02:52 <texasmynsted> hmm.  Might be worth creating a new VM just to check this out.  https://github.com/begriffs/haskell-vim-now
08:06:06 <alpounet> phaazon: the coursera courses about neural nets are decent, if you want to learn more
08:08:55 <phaazon> alpounet: yeah, I’ll have a look then
08:11:12 <sshine> 1) why is Numeric.showHex :: (Integral a, Show a) => a -> ShowS and not simply (Integral a, Show a) => a -> String?
08:12:18 <ThreeOfEight> sshine: efficiency
08:12:38 <sshine> ThreeOfEight, can you elaborate?
08:13:08 <ThreeOfEight> https://www.haskell.org/tutorial/stdclasses.html
08:13:19 <ThreeOfEight> Section 8.3
08:15:14 <sshine> ThreeOfEight, ah. thanks :)
08:21:01 <sshine> it seems that the naming of ReadP is inspired by the class ReadS... what can ReadP do that ReadS can't?
08:21:25 <sshine> is it simply that ReadP has a Monad instance?
08:21:36 <Schluri> @pl kkp1 (x:y:xs) z = kkp1 (sortBy (comparing Down) (xs++[x-y])) ([x,y,x-y]:z)
08:21:39 <lambdabot> kkp1 = fix (flip ap tail . (. head) . flip flip tail . (ap .) . flip flip head . ((.) .) . flip ap (((:) .) . liftM2 (.) (:) (ap (:) . flip flip [] . ((:) .) . (-))) . ((ap . ((flip . ((.) .)) .)) .) . (. ((((sortBy (comparing Down) .) . flip (++)) .) . flip flip [] . ((:) .) . (-))) . (.) . (.))
08:21:40 <lambdabot> optimization suspended, use @pl-resume to continue.
08:21:56 <Schluri> @pl-resume
08:21:59 <lambdabot> kkp1 = fix ((`ap` tail) . (. head) . flip flip tail . (ap .) . flip flip head . ((.) .) . (`ap` (((:) .) . liftM2 (.) (:) (ap (:) . flip flip [] . ((:) .) . (-)))) . (liftM2 (flip . ((.) .)) .) . (. ((((sortBy (comparing Down) .) . flip (++)) .) . flip flip [] . ((:) .) . (-))) . (.) . (.))
08:22:08 <sshine> getting better and better
08:22:14 * hackagebot hspec-wai-json 0.6.0 - Testing JSON APIs with hspec-wai  http://hackage.haskell.org/package/hspec-wai-json-0.6.0 (SimonHengel)
08:22:31 <albeit> :t Down
08:22:32 <lambdabot> a -> Down a
08:25:15 <sshine> Schluri, what are you doing, exactly?
08:25:54 <Schluri> sshine just tried out the pointfree thingy for fun
08:26:03 <Schluri> or are you asking about the line i posted
08:27:28 <albeit> > let kkp1 (x:y:xs) z = kkp1 (sortBy (comparing Down) (xs++[x-y])) ([x,y,x-y]:z) in kkp1 [5,3,9,5] 7
08:27:29 <lambdabot>  No instance for (GHC.Classes.Ord t0) arising from a use of ‘kkp1’
08:27:29 <lambdabot>  The type variable ‘t0’ is ambiguous
08:27:29 <lambdabot>  Note: there are several potential instances:
08:27:29 <lambdabot>    instance GHC.Real.Integral a => GHC.Classes.Ord (GHC.Real.Ratio a)
08:27:29 <lambdabot>      -- Defined in ‘base:GHC.Real’
08:27:52 <albeit> > let kkp1 (x:y:xs) z = kkp1 (sortBy (comparing Down) (xs++[x-y])) ([x,y,x-y]:z) in kkp1 ([5,3,9,5] :: [Int]) (7 :: Int)
08:27:54 <lambdabot>  Couldn't match expected type ‘[[GHC.Types.Int]]’
08:27:54 <lambdabot>              with actual type ‘GHC.Types.Int’
08:28:28 <albeit> > let kkp1 (x:y:xs) z = kkp1 (sortBy (comparing Down) (xs++[x-y])) ([x,y,x-y]:z) in kkp1 ([5,3,9,5] :: [Int]) ([7] :: [Int])
08:28:30 <lambdabot>  Couldn't match type ‘GHC.Types.Int’ with ‘[GHC.Types.Int]’
08:28:30 <lambdabot>  Expected type: [[GHC.Types.Int]]
08:28:30 <lambdabot>    Actual type: [GHC.Types.Int]
08:28:36 <albeit> Okay I'll stop
08:28:40 <Schluri> :D
08:28:45 <Schluri> it's a helper function
08:29:04 <Schluri> and is mssing th basecase too
08:54:27 <tattsun> Hi.
08:56:18 <Schluri> hi
08:58:10 <sshine> Schluri, yes, I was asking about the function. :)
08:58:55 <Schluri> sshine: I'm implementing the Kk-algorithm right now
08:59:03 <Schluri> or am tryin to at least
08:59:52 <tattsun> is there anyone who knows scotty well?
09:03:52 <alpounet> tattsun: i've used it quite intensively this year. generally you can just ask your question directly, no need to ask if anyone knows about some package you're using :)
09:04:42 <tattsun> thanks :)
09:05:53 <tattsun> i'm just developping web tool using scotty, and i wanna lift ActionM to ScottyM.
09:06:44 <Schluri> does anyone know which sorting algoritm the sort function uses ?
09:07:31 <adamse> Schluri: http://hackage.haskell.org/package/base-4.7.0.1/docs/src/Data-List.html#sort
09:07:32 <alpounet> tattsun: i'm pretty sure you don't actually want that, but the only way to confirm is to describe why you'd like to do that, i.e what is it that you're trying to do that requires this?
09:07:52 <glguy_> Schluri: It's a kind of merge sort
09:08:15 <tattsun> i wanna do like that -> https://gist.github.com/tattsun/ff0d8b86a25c1f4e39a3
09:08:55 <Schluri> thx
09:10:09 <tattsun> if i can't do this, i must to write many 'getCookies' in 'get' sections.
09:13:37 <codygman> Can you use otherwise in case? I'm getting a shadowing error with code like this: case x of { "val" -> Just Val; otherwise -> Nothing }
09:15:49 <glguy_> codygman: otherwise = True. In your case you want to write::   _ -> Nothing
09:16:08 <glguy_> you use otherwise in guards like this     x | something -> a   | otherwise -> b
09:16:45 <glguy_> What you're doing is shadowing the old definition of otherwise with a new one where the value is set to that of x
09:17:53 <Schluri> @pl \x y -> snd x == snd y
09:17:54 <lambdabot> (. snd) . (==) . snd
09:18:10 <Schluri> @pl \x y -> geq snd x  snd y
09:18:11 <lambdabot> flip (geq snd) snd
09:18:26 <glguy_> :t (==) `on` snd
09:18:27 <lambdabot> Eq b => (a, b) -> (a, b) -> Bool
09:19:10 <albeit> :t (on)
09:19:11 <lambdabot> (b -> b -> c) -> (a -> b) -> a -> a -> c
09:21:12 <codygman> glguy_: When I use "_ -> Nothing" I get unmatched pattern errors. I thought _ should match everything.
09:21:33 <glguy_> It does, so you've done something else funny
09:21:37 <codygman> glguy_: Nevermind, I misread!
09:22:00 <codygman> I should have known I was right with "_ -> Nothing" to begin with, lol.
09:22:04 <codygman> thank you
09:40:29 <favetelinguis> why is it that reverse (reverse xs) = reverse xs does not hold?
09:41:12 <indiagreen> favetelinguis: did you mean “reverse (reverse xs) = xs”, maybe?
09:41:13 <glguy_> favetelinguis: presumably you meant:    reverse (reverse xs) == xs   ?
09:41:26 <Denommus> which library should I use to just open an window, draw some circles and accept some keyboard input?
09:41:28 <Denommus> sdl2?
09:41:42 <indiagreen> Denommus: probably gloss
09:41:43 <glguy_> favetelinguis: In the case that xs is an infinite list you can't reverse it
09:41:44 <favetelinguis> no it is a question in the edx haskell course and i dont get it
09:42:00 <glguy_> (reverse (reverse [1,2]), reverse [2,1])
09:42:02 <favetelinguis> https://courses.edx.org/courses/DelftX/FP101x/3T2014/courseware/5240e299c3604e319986d1d8b3459a5a/3a8c73ffafa6463ba8e44b57e6f49041/
09:42:05 <glguy_> > (reverse (reverse [1,2]), reverse [2,1])
09:42:06 <lambdabot>  ([1,2],[1,2])
09:42:18 <glguy_> > (reverse (reverse [1,2]), reverse [1,2]) -- whoops :)
09:42:19 <favetelinguis> not sure if you have acces without being signed up
09:42:19 <lambdabot>  ([1,2],[2,1])
09:42:32 <glguy_> favetelinguis: It should be pretty obvious why it doesn't hold
09:42:52 <favetelinguis> It obv is not obv
09:43:09 <glguy_> favetelinguis: I just showed you an example where it doesn't hold
09:43:22 <favetelinguis> oo sorry yes hehe it is obv
09:43:31 <favetelinguis> to tired been staring at the screen all day
09:48:14 <Denommus> indiagreen: why does gloss assume so much about my program?
09:49:59 <ReinH> Also reverse . reverse = id is false
09:50:24 <indiagreen> Denommus: I think it's been designed for people who care about drawing/animation more than about having control over each and every aspect of their programs' behavior
09:50:46 <indiagreen> or have I misinterpreted you?
09:50:54 <triliyn> ReinH: are you referring to the fact that reverse . reverse turns infinite lists into bottom?
09:51:01 <ReinH> Yes.
09:51:33 <triliyn> So it is one of those things that is frustratingly close to true
09:51:45 <Denommus> indiagreen: no, you didn't misinterpreted me, but they even bind the arrow keys to something
09:51:47 <ReinH> (It's true for all finite and partial lists)
09:52:31 <ReinH> Denommus: it's opinionated software :) Perhaps you would prefer SDL2 or GLFW3 bindings?
09:52:35 <indiagreen> Denommus: they don't if you use Game interface
09:52:40 <indiagreen> https://hackage.haskell.org/package/gloss-1.8.2.2/docs/Graphics-Gloss-Interface-IO-Game.html
09:52:44 <indiagreen> “This game mode lets you manage your own input. Pressing ESC will not abort the program. You also don't get automatic pan and zoom controls like with displayInWindow.”
09:56:03 <Denommus> indiagreen: thanks, I will check it out
10:11:56 <_Vi> How do I add ability to my program to evaluate strings like "x+sin(t)*6+0.3" to Double values, without bloating up the program with fat dependencies to big frameworks?
10:13:38 <dfeuer_> Ping edwardk.
10:15:06 * dfeuer_ eats a head of Cale.
10:20:52 <alpounet> _Vi: you want to write your own code to do that? if yes: 1/ create an ADT that lets you represent that kind of expressions 2/ (but invertible with 3/) write a parser that takes a string and produces a value of that type corresponding to the computation described by the string (or throw an error if it's malformed) 3/ write a function that takes your ADT and evaluates it to a Double
10:23:48 <blume> Heya. I have a function that maps some State -> [State], because there are multiple ways of continuing it. I need to do multiple steps of this until the State meets a special condition and in the end, give back all the steps that led to it. My problem is that every step will do something like [] -> [[]] and so forth. Could you give me a hint on how to structure this? Do I probably need the State Monad?
10:29:25 <_Vi> alpounet, I want to use some existing library, but a small one.
10:31:06 <alpounet> _Vi: something like https://hackage.haskell.org/package/hascal ?
10:32:20 <_Vi> Maybe... It depends only on "numbers".
10:32:30 <koala_man> blume: it's a breadth first search where you want to find the list of states leading up to a solution?
10:36:23 <blume> koala_man: yes, thanks for the name. also, i want to find the shortest list leading to a solution
10:38:19 <blume> so i guess i can just build an infinite tree and traverse it while using Writer to log the steps?
10:47:20 * hackagebot apiary-helics 1.1.3 - helics support for apiary web framework.  http://hackage.haskell.org/package/apiary-helics-1.1.3 (HirotomoMoriwaki)
10:51:22 <amf> how do i "break out" of something in IO? e.g. i want just the value from Data.Time.Clock.gettCurrentTime
10:51:58 <athan> Has anyone messed with options parsers other than optparse-applicative? I'm trying to implement different "modes" of my application, that can be declared with a short option, I'm not sure if this is possible / practical in optparse-applicative
10:52:04 <ion> do { time <- getCurrentTime; {- do something with time -} }
10:52:05 <cdk> amf: that would defeat all the safety benefits of monadic IO. ie, you don't
10:52:16 <athan> amf: You cannot! You can slip-in though
10:52:55 <ion> a_function_from_UTCTime_to_something_else <$> getCurrentTime
10:53:49 <amf> hmm.. ok. i guess ill have to reorganize a little to handle that in the io portion of my code. thanks!
10:57:50 <eacameron> is anyone interested in working on mysql package with me to make it support concurrency at the C level? As of now, it uses the single-threaded C library.
10:58:30 <eacameron> apparently bos started working on an all-haskell binding to MySQL which never saw the light of day
10:59:20 <sshine> aren't there more popular DBMSes that support concurrency?
11:00:12 <sshine> (not saying the library wouldn't be a great addition - I've used mysql myself a lot - just thinking that the shift in technology I presume Haskell to be a part of doesn't have to involve mysql)
11:01:55 <eacameron> sshine: I am pretty sure ODBC for mysql has the same problem
11:02:10 <eacameron> sshine: I don't know of any other backends for mysql
11:03:08 <eacameron> sshine: mostly I get, "Why are you using MySQL?" to which I respond "As much as I don't prefer it, my company has thousands of GB of MySQL dbs and hundreds of programs depending on it..."
11:05:33 <sshine> eacameron, right :)
11:05:36 <mhall> hey, does anyone know in the wiki article for process calculi, is "interaction point" just a synonym for channel?
11:06:06 <edofic> anyone here using scotty? i'm trying to proxy a http request with it but i have some problems (this is what i got https://gist.github.com/edofic/25caf86b64ecdb01f58d)
11:17:21 * hackagebot domplate 0.1 - A simple templating library using HTML5 as its template  language.  http://hackage.haskell.org/package/domplate-0.1 (AntonEkblad)
11:21:16 <blackhorse> Is there haskell ghci on the phone?
11:22:43 <blackhorse> I'm thinking in worst case to assemble a lambdabot and a server myself so that I can use my phone's IRC client to access it
11:23:36 <saep> blackhorse: ssh to a computer with ghci?
11:24:53 <blackhorse> saep: yes I guess that is one option
11:33:56 <Denommus> uh
11:34:07 <Denommus> where can I find examples with the sdl2 library?
11:39:13 <Polarina> Denommus, here are some examples for sdl2: https://github.com/palf/haskellSDL2Examples
11:39:40 <Polarina> Denommus, here's a real program using them: https://github.com/ekmett/quine
11:47:33 <Normangorman> could someone explain what's wrong with this code? "yearDifference = (flip mod 365) . diffDays"
11:47:44 <Normangorman> I can't understand the error message i'm being shown, but the types seem to  line up.
11:48:11 <Normangorman> diffDays :: Day -> Day -> Integer
11:48:46 <cdk> Normangorman: yearDifference x = (`mod` 365) . diffDays x
11:49:48 <Normangorman> thanks :). why the need for the trailing x?
11:50:13 <monochrom> let's say (flip mod 365) :: Integer -> Integer. in order for (flip mod 365) . diffDays to have types line up, diffDays :: Day -> Integer. contradiction.
11:50:14 <cdk> you can't compose (b -> c) with (a -> a -> b)
11:51:09 <blume> i think one could do (flip mod 365 .) . diffDays
11:51:23 <monochrom> yes
11:52:54 <Normangorman> ok, right.
11:53:48 <jle`> Normangorman: just check the types to make sure they work out :)
11:53:55 <jle`> the types never lie
12:08:33 <chrisdone> ocharles: fun. i spent half an hour on a naive html dsl and it's not far off blaze http://chrisdone.com/html-vs-blaze.png
12:10:34 <chrisdone> and in this case: http://lpaste.net/4609628175041822720 (roughly 38MB of html output) it's 100ms faster at completing, so it's pretty good at I/O bound stuff too
12:11:45 <chrisdone> dumbest data type ever:
12:11:46 <chrisdone> newtype Html a = Html {runHtml :: (Builder -> Builder -> Builder,a)}
12:12:17 * chrisdone . o O ( and it's a proper monad )
12:13:22 <ToTheInternet> i want to sort a list of type [(String,Int)] on the second element of the tuple from largest to smallest. The following code sorts from smallest to largest. I could just reverse the result but i'm wondering if there is a better way to do it (afaik reverse has square complexity):  sortBy (compare `on` snd) list
12:14:17 <mauke> reverse is linear
12:14:26 <mauke> sortBy (flip (comparing snd))
12:14:59 <ToTheInternet> mauke: nice. thanks
12:17:50 <ocharles> chrisdone: awesome! That doesn't surprise me, but its great to see that hypothesis mostly confirmed
12:18:44 <chrisdone> ah, a small tweak and i got it down to 5ms.
12:18:49 <chrisdone> (updated screenie)
12:19:24 <chrisdone> ocharles: yeah! iirc your hypothesis being that you can get pretty competitive on this task with little effort these days?
12:19:59 <ocharles> chrisdone: and be a real monad
12:20:08 <chrisdone> right
12:21:00 <mauke> did you mean: real madrid
12:21:45 <chrisdone> https://www.youtube.com/watch?v=-DSVDcw6iW8 a real monad and a real hero
12:21:59 <monochrom> Real Monad'Or = royal monad of gold :)
12:25:59 <chrisdone> ocharles: i'm hesitantly feeling out the foo_ convention for tag/attr names. i don't like the H.style/A.style convention for reading/writing, but unqualified leads to import fiddlage. atm i can use style_ for both a tag or an attribute, which is good…
12:26:00 <chrisdone> ocharles: also, rather than H.div_ ! A.class_ "foo" ! A.id "bar" $ H.p "hi"
12:26:00 <chrisdone> ocharles: i write: with div_ [class_ "foo",id_ "bar"] (p_ "hi")
12:26:20 <chrisdone> ocharles: it's not beautiful, but it does scratch a bunch of itches i have with blaze
12:26:58 <chrisdone> (namely: the qualification madness, inconsistency of id/class_/head, and difficult to edit !-way of doing attributes)
12:27:12 <chrisdone> i also found with blaze i often want to write e.g.
12:27:37 <chrisdone> div [ class_ "disabled" | disabled] … but that's hard to do naturally
12:27:55 <chrisdone> with mine i can just write, well, with div_ [ class_ "disabled" | disabled ] …
12:29:09 <ocharles> chrisdone: that is nice, but I'm not sure particularly common :)
12:29:25 <ski> chrisdone : hm, with what monoid operation ?
12:29:25 <ocharles> I quite liked having lenses into elements
12:29:28 <chrisdone> personally speaking i can find examples all over
12:29:37 <ocharles> Fair enough
12:29:44 <chrisdone> ocharles: that's also nice
12:29:52 <chrisdone> ski: sec
12:30:27 <lpaste> chrisdone pasted “Monad/Monoid instances” at http://lpaste.net/114311
12:30:44 <jfischoff> jonsterling: Playing with vinyl-new. I’m making a `RecAllWithKey (f :: u -> *) (rs :: [u]) (ck :: u -> Constraint) (cv :: * -> Constraint) :: Constraint` to traverse both the record field codes and their ‘evaluation’. Feel free to correct my terminology and approach.
12:30:44 <fresheyeball_> hello haskell peoples
12:31:01 <chrisdone> ski: unless i did something daft that should be a pretty obvious way to write the instance
12:31:49 <chrisdone> ski: i found that replacing mconcat (map f ) with mapM_ f in my benchmarks dropped the bigtable benchmark from 7ms to 5ms. could've been a system fluke that criterion can't account for, tho
12:32:24 <chrisdone> i'll put it down to a fluke for now… but these are promising results
12:32:29 <fresheyeball_> I have a question, when would one use <+> ?
12:33:04 <jfischoff> fresheyeball_: where is it defined?
12:34:40 <JagaJaga> Hello! Do smone knows how to put POSIXTime into bytestring?
12:35:09 <chrisdone> i believe the thyme package might have that
12:35:20 <monochrom> I would use <+> when I knew that it would help solve my problem.
12:35:26 <chrisdone> JagaJaga: wait, you just want to print it as an integer?
12:35:27 <jfischoff> JagaJaga: convert it to double and then save it as bytestring?
12:35:43 <JagaJaga> chrisdone: no, I need to send it over network.
12:35:47 <jfischoff> chrisdone: I think it is NomonialDiffTime or something
12:35:50 <JagaJaga> jfischoff: oh! gonna try.
12:36:29 <jfischoff> JagaJaga: fromRational . toRational, or if you want a Int then use floor I guess
12:36:41 <chrisdone> i used
12:36:51 <chrisdone> S8.pack (show (nominalDiffToMilli diff)) where nominalDiffToMilli i = round (i * 1000)
12:36:58 <chrisdone> (had a similar use-case the other day)
12:37:11 <chrisdone> the `show` call is nasty, but was fast enough for my use-case…
12:37:27 <ski> chrisdone : hmm .. you propagate `mempty's in `Monad Html' .. i suppose that corresponds to
12:37:28 <JagaJaga> chrisdone: S8?
12:37:37 <ski>   instance (Default rho,Monoid a) => Monoid (rho -> a)
12:37:40 <ski>     where
12:37:41 <chrisdone> JagaJaga: Data.ByteString.Char8
12:37:45 <JagaJaga> chrisdone: thx.
12:37:46 <ski>     mempty _ = point
12:37:55 <chrisdone> umm
12:37:56 <ski>     (f `mappend` g) _ = f def <> g def
12:38:56 <chrisdone> ski: you mean to avoid the passing and concat'ing of the mempty?
12:39:36 <chrisdone> so it would be… (Html (\_ _  -> g <> f')) or something?
12:39:38 <ski> no, i'm just pondering how you were combining `Builder -> Builder -> Builder's -- i wasn't talking about performance atm
12:39:44 <chrisdone> ah, i see
12:39:59 <chrisdone> makeElement name = \m' ->
12:39:59 <chrisdone>     Html ((\attr m -> "<" <> name <> attr <> ">" <> m <> renderHtml m' <> "</" <>
12:39:59 <chrisdone>                         name <> ">")
12:39:59 <chrisdone>           ,())
12:40:01 <jfischoff> JagaJaga: Data.Binary will be more efficent: Data.Binary.encode $ floor time
12:40:10 <ski> (s/point/def/)
12:40:15 <shaykha`> @monad
12:40:16 <lambdabot> Unknown command, try @list
12:40:16 <jfischoff> or not floor if you need more precision
12:40:19 <JagaJaga> jfischoff: thx.
12:40:20 <shaykha`> @list
12:40:20 <lambdabot> What module?  Try @listmodules for some ideas.
12:40:30 <shaykha`> @listmodules
12:40:30 <lambdabot> activity base bf check compose dice dict djinn dummy elite eval filter free fresh haddock help hoogle instances irc karma localtime metar more oeis offlineRC pl pointful poll pretty quote search slap source spell system tell ticker todo topic type undo unlambda unmtl version where
12:40:32 <chrisdone> ski: that's how the monoids are used
12:40:54 <shaykha`> @hoogle
12:40:54 <lambdabot> No query entered
12:40:54 <lambdabot> Try --help for command line options
12:41:17 <phaazon> https://www.reddit.com/r/haskell/comments/2mbea2/abstracting_shader_introducing_the_ash_library_wip/ for interested ones ;)
12:41:23 * ski would just write `Html (\attr m -> ..attr..m..,())' ..
12:42:53 <ski> chrisdone : oh, just noticed that you don't get the unit laws
12:43:59 <ski> chrisdone : so .. the question is then whether your `Monad Html' still satisfies *its* unit laws ..
12:44:01 <chrisdone> ski: my monad is broke? D:
12:44:44 <ski> chrisdone : ah, fails `forall a k. return a >>= k = k a' :)
12:44:45 <chrisdone> afaict it's basically State
12:45:15 <ski> well, perhaps `Html' is (intended as) a quotient type ?
12:45:35 <ski> (though i'm not sure that would make much difference)
12:48:02 <ski> chrisdone : `(\a -> Html (foo a,bar a)) a' isn't equal to `Html (\_ _ -> mempty,a) >>= \a -> Html (foo a,bar a)', which is `Html (\_ _ -> mempty,bar a)', since `foo a' isn
12:48:12 <ski> 't necessarily `\_ _ -> mempty'
12:51:21 <chrisdone> ski: why is foo using a here?
12:51:22 <ski> so in `do x <- return a; frob x', `frob a' will get its `attr' and `m' reset to `mempty', while `frob a' won't do that
12:52:05 <Denommus> why does gloss have a separate function for stepping and for event handling?
12:52:05 <ski> chrisdone : concievably, in a function of shape `\a -> Html (...,...)', both pair components could possibly depend on `a'
12:52:29 <ski> and since the right argument of `(>>=)' has type `a -> Html b' ...
12:53:17 <ski> perhaps in none of your exported operations, the left `...' component depends on `a' (which `a' ?)
12:53:28 <chrisdone> they don't
12:53:30 <ski> (if so, then perhaps you could use an applicative ?)
12:53:34 <chrisdone> λ> renderHtml (do x <- return (); with p_ [class_ "x"] (toHtml (show x)))
12:53:34 <chrisdone> "<p class=\"x\">()</p>"
12:53:53 <chrisdone> attributes are set by nesting these (Builder -> Builder -> Builder) functions
13:00:24 <chrisdone> ski: are you saying the return function is wrong?
13:01:09 <ski> i'm not quite sure what the resetting of `attr' and `m' with `mempty' is supposed to achieve
13:01:37 <ski> i'm just noticing that `return' and `(>>=)' together, as defined, fails one monad unit law (and i think probably the other as well)
13:02:25 * hackagebot rethinkdb-client-driver 0.0.9 - Client driver for RethinkDB  http://hackage.haskell.org/package/rethinkdb-client-driver-0.0.9 (wereHamster)
13:02:29 <lpaste> chrisdone pasted “with” at http://lpaste.net/114313
13:02:58 <lpaste> chrisdone annotated “with” with “makeElement” at http://lpaste.net/114313#a114315
13:03:43 <JagaJaga> how to view instances of the class? Without hoogle or smth like that?
13:04:34 <chrisdone> ski: the Html constructor itself isn't exposed, it's not possible to have a user-supplied function in the left tuple
13:04:43 <ski> ok
13:05:10 <chrisdone> did you get my /notice?
13:05:31 <chrisdone> i sent you the full code in PM
13:06:41 <ski> still,
13:06:42 <ski>    return a >>= \x -> Html (f,g x)  =  Html (\_ _ -> mempty,g a)  ≠  Html (f,g a)  =  (\x -> Html (f,g x)) a
13:08:01 <ski> (assuming ⌜f  ≠  \_ _ -> mempty⌝, obviously)
13:09:05 <chrisdone> i'm not sure how to read that…
13:09:29 <ski> generally, `f' can't be expected to always be `\_ _ -> mempty', can it ?
13:09:59 <ski> so, apart from the cases where it actually is that, the above chain with an inequality in the middle holds
13:10:42 <ski> (btw, is `Monoid Builder' concatenation for `Data.Text.Lazy' ?)
13:10:48 <chrisdone> yup
13:11:48 <JagaJaga> chrisdone: maybe some ideas how to get posixtime FROM bytestring? :)
13:12:09 <chrisdone> ski:  i think i'm finding this hard to read because you're using a constructor that will never be exported so it's like considering cases that never happen
13:12:16 <ski> anyway, the above chain is a counterexample to the monad unit law ⌜∀ a k. return a >>= k = k a⌝
13:12:39 <ski> chrisdone : yeah, hence i asked about quotients :)
13:13:16 <ski> (quotient types being one common case for wanting an abstract data type (subtypes being another common case, these two are often combined as well))
13:13:17 <chrisdone> ski: i think it'd be better to consider the laws in relation to the operations provided?
13:13:47 <chrisdone> e.g. if i condense this api down to the monad instance and a couple combinators?
13:13:55 <ski> chrisdone : i don't know which operations are public
13:13:58 <chrisdone> sec
13:15:25 <jfischoff> ski: what is a quotient type?
13:15:48 <jfischoff> actually anyone what is a quotient type?
13:16:19 <Tene> "In type theory, a quotient type is an algebraic data type that represents a type whose equality relation has been redefined by a given equivalence relation such that the elements of the type are partitioned into a set of equivalence classes the cardinality of which is less than or equal to the cardinality of the base type. Just as product types and sum types are analogous to the cartesian product and disjoint sum of abstract algebraic ...
13:16:25 <Tene> ... structures, quotient types reflect the concept of set-theoretic quotients, sets whose elements are surjectively partitioned into equivalence classes by a given equivalence relation on the set." -- http://en.wikipedia.org/wiki/Quotient_type
13:16:45 * jfischoff nods
13:16:55 <sshine> sounds like quotient groups from algebra.
13:17:11 <ReinH> yep
13:17:12 <jfischoff> yes sounds like … quotients :p
13:17:22 <ski> chrisdone> :t makeElement
13:17:26 <ReinH> http://en.wikipedia.org/wiki/Quotient_category
13:18:25 <lpaste> chrisdone pasted “API” at http://lpaste.net/114316
13:18:37 <chrisdone> ski: here's the complete API
13:18:49 <chrisdone> oh, sec, i'll add the types
13:19:21 <ski> jfischoff : e.g. when you implement a rational number by *any* representant fraction `n :% d' of it, and define `(n0 :% d0) == (n1 :% d1) = n0 * d1 == n1 * d0' (and carefully make sure that none of your exported operations (in addition to `(==)') can distinguish between different representations `n :% d' of a rational number)
13:19:28 <lpaste> chrisdone revised “API”: “Add types” at http://lpaste.net/114316
13:19:47 <success> > (flip . flip) (1) 14 6
13:19:48 <lambdabot>  Could not deduce (GHC.Num.Num (b0 -> a0 -> c))
13:19:48 <lambdabot>    arising from the ambiguity check for ‘e_11146’
13:19:48 <lambdabot>  from the context (GHC.Num.Num (b -> a -> c),
13:19:48 <lambdabot>                    GHC.Num.Num b,
13:19:48 <lambdabot>                    GHC.Num.Num a)
13:19:54 <success> > (flip . flip) (-) 14 6
13:19:55 <lambdabot>  8
13:20:03 <jfischoff> ski: I see
13:20:15 <ski> jfischoff : or when you implement set or bags or finite maps in terms of search trees, and make sure that the balancing/association, and various extra bookkeeping info in the tree can't leak out through the exported operations
13:20:31 * jfischoff nods
13:21:19 <chrisdone> nod
13:21:49 <ski> jfischoff : otoh, if you define a type of search trees, but only export operations which produce (maintain) balanced trees (for some notion of "balanced"), you're effectively modelling a subtype (by hiding implementations behind an ADT)
13:22:02 <orbital> so with Haste, who does the web servings? Or does it work with any framework?
13:22:31 <ski> jfischoff : so in both cases, one can employ an Abstract Data Type to *encode* a quotient type or a subtype (or a quotient type of a subtype, as would normally be the case in the balanced search tree case)
13:22:56 <JagaJaga> chrisdone: re: maybe some ideas how to get posixtime FROM bytestring? :) Can't get it by myself
13:23:34 <ski> jfischoff : a dependently typed language could possibly have (more or less) direct support for subtypes ior quotient types, so that one wouldn't have to rely on not screwing up the implementation behind the ADT in some way ..
13:23:45 * jfischoff nods
13:24:01 <chrisdone> JagaJaga: attoparsec can do that, or https://hackage.haskell.org/package/bytestring-0.10.4.1/docs/Data-ByteString-Char8.html#g:23
13:24:16 <JagaJaga> chrisdone: oh!
13:24:39 <chrisdone> ski: this reminds me of size-type-safe vectors in haskell
13:25:23 <chrisdone> while opaquely the size is safe, there's nothing in haskell stopping you from badly implementing map or `second'
13:25:43 <chrisdone> or even cons
13:26:28 <chrisdone> cons :: a -> List a n -> List a (S n)
13:26:28 <chrisdone> cons a (Cons x n xs) = Cons a (S n) (Cons x n xs)
13:26:28 <chrisdone> you can swap the x and the a and it still compiles, but it's now a bad implementation:
13:26:28 <chrisdone> cons x (Cons a n xs) = Cons a (S n) (Cons x n xs)
13:26:43 <chrisdone> as the `n` and the `a` aren't associated
13:26:57 <ski> chrisdone : *nod*, interesting
13:27:38 <ski> so i suppose this also applies to some ways of faking indexed inductive families, as well
13:28:06 <chrisdone> example?
13:28:31 <ski> your case above ?
13:29:11 <chrisdone> ah i didn't know they had a name
13:30:01 <chrisdone> i had patted myself on the back for being unable to write the two commented-out `second` implementations here: http://lpaste.net/92328#line22
13:30:09 <chrisdone> only to realise the problem above, hehe =)
13:30:24 <ski> `data List (a : Set) : Nat → Set where Nil : List a Zero; Cons : a → (n : Nat) → List a n → List a (Succ n)', in Agda
13:31:21 <chrisdone> does that suffer from the same issue?
13:31:45 <chrisdone> looks pretty much like my gadt
13:31:49 <ski> no, since `n' here must be a `Nat', as opposed to any (concrete) type
13:32:43 <chrisdone> that part's true  -- i could constraint kind my gadt perhaps
13:33:02 <chrisdone> can it handle the `cons'/`second' issue?
13:33:32 <chrisdone> oh wait
13:33:42 <chrisdone> what's the funny business with (a : Set) : Nat -> Set
13:33:53 <chrisdone> does that associate the `a' with the n somehow?
13:35:29 <ski> chrisdone : with `DataKinds' in GHC, you can write `data Nat = Zero | Succ Nat; data List (a :: *) :: Nat -> Set where Nil :: List a Zero; Cons :: a -> List a n -> List a (Succ n)' (where `n' is implicitly `forall'ed on `Cons' .. i think you could alternatively add an explicit `forall (n :: Nat). ' there)
13:35:54 <streblo> can i use haskell to write ios apps?
13:36:23 <ski> chrisdone : then you can't accidentally use any other thing than `Nat's for the second argument of `List' .. however, now `Cons' only has two args
13:36:28 <glguy> List (a : Set) : Nat -> Set   -- means that List : Set -> Nat -> Set, but also that the (a : Set) is a parameter
13:36:32 <glguy> while the Nat is an index
13:36:54 <ChristianS> what's the best way to parse a string as a number? read?
13:37:05 <glguy> since the a is a parameter it can be anything in all the constructors, so it's bound to a name at the top
13:37:07 <benzrf> glguy: parameter?
13:37:09 <benzrf> index?
13:37:09 <benzrf> wut?
13:37:17 <glguy> since is an "index" it can be specific to the constructor
13:37:21 <chrisdone> oh i see
13:37:25 <ReinH> streblo: Possibly https://github.com/ghc-ios https://ghc.haskell.org/trac/ghc/wiki/Building/CrossCompiling/iOS  https://www.haskell.org/haskellwiki/IPhone
13:37:26 <glguy> benzrf: It's an Agda thing
13:37:41 <JagaJaga> streblo: https://www.haskell.org/haskellwiki/IPhone
13:37:42 <chrisdone> ski: right, i've used DataKinds like that before. i meant when i said constraint kinds, sorry
13:38:03 <ReinH> :t Data.Text.readMaybe - ChristianS
13:38:05 <lambdabot> Not in scope: ‘Data.Text.readMaybe’
13:38:05 <lambdabot> Not in scope: data constructor ‘ChristianS’
13:38:10 <ReinH> haha woops
13:38:22 <ski> chrisdone : if you want three, you could perhaps do `data Nat = Zero | Succ Nat; data NatIs :: Nat -> * where IsZero :: NatIs Zero; IsSucc :: NatIs n -> NatIs (Succ n); data List (a :: *) :: Nat -> Set where Nil :: List a Zero; Cons :: a -> NatIs n -> List a n -> List a (Succ n)'
13:38:23 <chrisdone> ski: it's true that you can't put just any old thing where the `n` slot is
13:38:33 <ReinH> ChristianS: if you are using Text or ByteString (which you probably should be) then there are better options as well
13:39:14 <chrisdone> ski: but the bigger problem is that i can implement effectively 1 : [2] = [2,1] because the 'a' and the 'n' aren't associated
13:39:24 <ski> chrisdone : and btw, if it's not obvious, when i said `data List (a :: *) :: Nat -> Set' i could just as well have said `data List :: * -> Nat -> *' or `data List (a :: *) (n :: Nat) :: *' (possibly omitting the last ` :: *')
13:39:56 <chrisdone> right, but the a is used so you name it, sure
13:40:03 <ski> i just prefer to write it like this, clearly separating parameters from indices
13:40:26 <ski> (catholic from presbyterian formal type arguments)
13:40:42 <ski> (in Agda, you have to write it in that style)
13:40:45 <chrisdone> glguy: do you see what i'm getting at here?
13:40:58 <chrisdone> i feel i'm not making myself clear…
13:41:09 <ChristianS> ReinH: hmm, in this case i get the input from System.Process (readProcess) which returns String, not sure if there is a Text equivalent
13:41:28 <ski> ChristianS : you can use `reads' to catch failure (and ambiguity, if any)
13:41:40 <glguy> chrisdone: I need to read up to the original question. I just saw the conversation when it was talking about the Agda syntax
13:42:16 <ReinH> ChristianS: then readMaybe or reads would be good
13:42:40 <chrisdone> second :: List a (S (S n)) -> (a,n)
13:42:40 <chrisdone> second (Cons _ _ (Cons a n _)) = (a,n)                 -- type checks because the n matches up, good
13:42:40 <chrisdone> -- second (Cons a n _) = (a,n)                         -- cannot type check: this is good
13:42:40 <chrisdone> -- second (Cons _ _ (Cons _ _ (Cons a n _))) = (a,n)   -- cannot type check: this is good
13:42:43 <chrisdone> but, you *can* write:
13:42:46 <ChristianS> ski, ReinH ok, thanks
13:42:46 <chrisdone> second (Cons a _ (Cons _ n _)) = (a,n)                 -- type checks, this is bad
13:43:03 <ski> chrisdone : i was assuming your code had `List :: * -> * -> *'
13:43:04 <chrisdone> glguy: ski: maybe it's impossible to ensure that the element and its index are always related. or is it easy?
13:44:01 <L8D> chrisdone: zip [0..] ?
13:44:24 <L8D> speaking of indexes, what data structure should I use for random access?
13:44:25 <chrisdone> ski: it is, but the `n` is constrained in the type: List a (S (S n)) -> (a,n), so if the `n` in S n is a nat, then the latter n must also be. it's true that the `n' could be () because its kind is *, but that's an orthogonal issue (perhaps)
13:44:27 <ski> ChristianS : you may want to consider whether to allow any initial and trailing whitespace in the string or not. `lex' can be used to discard any trailing whitspace, checking that there's not more junk at the end
13:45:00 <L8D> :t (`zip` [0..])
13:45:01 <exio4> L8D: I would use an array
13:45:01 <lambdabot> (Num b, Enum b) => [a] -> [(a, b)]
13:45:21 <chrisdone> ski: i mean specifically, if the `n' in (S (S n)) is Z, then the latter n must be Z, so i can't (reasonably) accidentally put the wrong `n` in my `second' implementation. not so for the `a'
13:45:38 <ski> chrisdone : what's the point of `second' ?
13:46:04 <chrisdone> ski: it's just a type-safe second (x:y:_) = y. we can focus on `cons' if you prefer, it has the same issue
13:47:04 <ski> as long as you don't make the element type dependent on the index, you can similarly make `!' extract the wrong element in Agda
13:47:14 <chrisdone> cons :: a -> List a n -> List a (S n)
13:47:14 <chrisdone> cons a (Cons x n xs) = Cons a (S n) (Cons x n xs)
13:47:14 <chrisdone>                ^                 ^          ^     these n's must match up. that's good, but
13:47:14 <chrisdone>      ^       ^              ^             ^       these a's and x's can be swapped, yielding a wrong impementation despite what the types promise. that's bad
13:47:27 * hackagebot bert 1.2.2.3 - BERT implementation  http://hackage.haskell.org/package/bert-1.2.2.3 (RomanCheplyaka)
13:47:37 <ski> (though to catch against such, you could probably state and prove one or two theorems which ensures the correct element is extracted)
13:47:39 <chrisdone> ski: right -- so this can be solved in agda
13:47:57 <ski> chrisdone : rather -- you can make the same mistake in Agda :)
13:48:09 <chrisdone> sure =p
13:48:19 <hsk8> Can someone explain to me deferred computations? They appeared in LYAH in the context of foldl vs. foldl'.
13:48:20 <hsk8> What I don't get is this:
13:48:22 <hsk8> --
13:48:23 <hsk8> factorial :: Integer -> Integer
13:48:25 <hsk8> factorial 0 = 1
13:48:26 <hsk8> factorial n = n * factorial (n - 1)
13:48:27 <hsk8> --
13:48:28 <hsk8> Why is factorial of some huge number not a deferred computation that gets stuck because of a too large stack? No matter how large number I supply, I don't get a stack overflow. Why not?
13:48:42 <glguy> chrisdone: You'd have to wrap the elements somehow so they were something like a (Tagged n a)
13:49:01 <chrisdone> glguy: right, that makes sense
13:49:02 <glguy> chrisdone: and then hide the constructor so that bad tagged list elements were never made
13:49:18 <Cale> hsk8: Well, you probably run out of heap space before you run out of stack space?
13:49:48 <Cale> Well, also there's not much in the way of stack space required there
13:49:50 <chrisdone> glguy: actually that's quite a nice solution, no special magic required
13:49:55 <Cale> It's just space used to evaluate n
13:50:03 <ski> chrisdone : hm, and i think the same applies to `cons' in Agda, as well (though perhaps there's less incentive to try to define it in the first place. i'm not sure, it depends on erasure i think)
13:50:33 <Cale> Well, no, that's not true, the multiplications eventually use the stack
13:51:17 <hsk8> Cale: what do you mean "eventually"?
13:51:51 <ski>      factorial 4
13:51:52 <Cale> factorial 5 for instance will become 5 * factorial (5 - 1), at which point (*) needs to pattern match its second argument, so this pattern match waits on the stack
13:51:59 <Cale> and then factorial (5 - 1) is evaluated
13:52:06 <ski>   =  4 * factorial (4 - 1)
13:52:07 <chrisdone> ski: i only thought about this as in agda you get that feeling of programs mostly writing themselves based on the type-signature, or preventing you from writing the wrong implementation. i was feeling a bit of that warm feeling with this typed vector in haskell, but only so far of course =)
13:52:10 <ski>   =  4 * factorial 3
13:52:18 <ski>   =  4 * (3 * factorial (3 - 1))
13:52:22 <ski>   =  4 * (3 * factorial 2)
13:52:28 <ski>   =  4 * (3 * (2 * factorial (2 - 1)))
13:52:30 <ski>   =  4 * (3 * (2 * factorial 1))
13:52:38 <ski>   =  4 * (3 * (2 * (1 * factorial (1 - 1))))
13:52:42 <ski>   =  4 * (3 * (2 * (1 * factorial 0)))
13:52:45 <ski>   =  4 * (3 * (2 * (1 * 1)))
13:52:48 <ski>   =  4 * (3 * (2 * 1))
13:52:48 <hsk8> Yes, but why did Cale say "eventually"? Isn't the stack being loaded on the fly, from the beginning?
13:52:49 <Cale> When I initially said "eventually", the evaluation in my head looked like what ski is typing
13:52:51 <ski>   =  4 * (3 * 2)
13:52:54 <ski>   =  4 * 6
13:52:56 <ski>   =  24
13:53:57 <ski> hsk8 : the nested multiplications `4 * (3 * (...))' here represent your stack growing with "deferred" multiplications, which will only happen once the remaining recursive calls after the current point has returned their answer
13:54:13 <chrisdone> http://bm380.user.srcf.net/cgi-bin/stepeval.cgi?expr=foldl+%28*%29+1+%5B1%2C2%2C3%2C4%2C5%5D
13:54:15 <Cale> It's important to realise that the stack is not a call stack
13:54:25 <ski> hsk8 : you can see in the trace above that the multiplications are all saved-up and only performed at the end, after reaching the base case
13:54:51 <Cale> It's a stack which you can think of as consisting of case expressions (in this case, mostly the case expressions internal to the implementation of (*))
13:55:05 <ski> hsk8 : this happens because `*' is *strict* : meaning it requires to know *now* the values of both operands, before being able to return
13:55:09 <Cale> case expressions who are waiting for their scrutinee to be sufficiently evaluated to match a pattern
13:55:49 <ski> hsk8 : if we had used a *non*-strict operation, like e.g. the list constructor `:' instead of `:', then this wouldn't have happened
13:55:58 <ski> er, instead of `*'
13:56:24 <ski> chrisdone : *grin*
13:56:31 <chrisdone> =p
13:57:33 <Cale> Yeah, in the stepeval version using foldl, for instance, the stack would be mostly unused up until the point where multiplication begins
13:58:15 * chrisdone would love a generalized implementation of stepeval 
13:58:58 <ski> hsk8 : my trace corresponds more or less to <http://bm380.user.srcf.net/cgi-bin/stepeval.cgi?expr=foldr+%28%2A%29+1+%5B1%2C2%2C3%2C4%2C5%5D>
13:59:08 <hsk8> thanks i'll look at this!
13:59:10 <chrisdone> i think you could have a nice inventing-on-principle style of "write code → see expansion"
13:59:11 <hsk8> cool
13:59:24 * ski idly wonders why <http://bm380.user.srcf.net/cgi-bin/stepeval.cgi?expr=foldl%27+%28%2A%29+1+%5B1%2C2%2C3%2C4%2C5%5D> seems to get stuck
13:59:41 <chrisdone> seems that foldl' is not in its prelude
14:00:07 <chrisdone> (so it just stops expanding)
14:00:47 <benmachine> I remember that
14:01:00 <Denommus> I don't understand how I could take, say, a event from SDL or Gloss and produce a Netwire Wire out of it
14:01:41 <texasmynsted> This is a real question and not war bait…   Anybody have an accessible paper/link/video/anything that can speaks to how "design patterns" are a result of a language's failure to materialize an abstraction?
14:02:27 * hackagebot zlib-lens 0.1 - Lenses for zlib  http://hackage.haskell.org/package/zlib-lens-0.1 (EricMertens)
14:02:29 * hackagebot lens-aeson 1.0.0.3 - Law-abiding lenses for aeson  http://hackage.haskell.org/package/lens-aeson-1.0.0.3 (EricMertens)
14:02:32 * hackagebot tasty-quickcheck 0.8.3.1 - QuickCheck support for the Tasty test framework.  http://hackage.haskell.org/package/tasty-quickcheck-0.8.3.1 (RomanCheplyaka)
14:03:23 <Cale> hsk8: But yeah, the main thing with factorial is that you're probably not applying the factorial function to numbers large enough to run out the entire stack
14:04:01 <benmachine> if you did, wouldn't the giant Integer be more of a concern anyway
14:04:41 <Cale> Right
14:04:48 <monochrom> immovable integer vs unstoppable stack
14:04:59 <Cale> The memory usage for the Integer becomes a problem well before your stack space does
14:05:09 <chrisdone> monochrom: is that commutative?
14:05:19 <Hodapp> could a Turing machine make an integer so large not even it could increment it?
14:05:19 <ski> hsk8 : do you want an example of what can happen if you use a nonstrict operation instead of a strict one, around the recursive call ?
14:05:31 <monochrom> I don't know. it's like Alien vs Predator
14:05:35 <benmachine> Hodapp: nope
14:05:42 <benmachine> it couldn't.
14:05:43 <geekosaur> texasmynsted, I don't think so, because it's only true for simplistic views of "design pattern".
14:05:43 <juri_> when i am profiling, how do i extend the length of the displayed string in the 'call graph'?
14:06:06 <monochrom> "no matter who wins, the program crashes" :)
14:06:17 <geekosaur> or, put otherwise: what is the difference between a design pattern and an API?
14:06:48 <Hodapp> An API is expressed as abstractions within the language, not as a pile of buzzwords?
14:07:26 <bennofs> juri_: try +RTS --help  . There is an option there, don't remember it's name
14:07:30 <Cale> Design patterns are a measure of the failure of the language to capture abstractions that we want to use to understand the code.
14:07:54 <benmachine> * chrisdone would love a generalized implementation of stepeval ← generalized? "correct" would be a start :P
14:08:02 <chrisdone> 3.14159 is a design pattern, pi is abstraction =p
14:08:09 <chrisdone> benmachine: =)
14:08:10 <bennofs> juri_: juri_: ah, it's -L50 (for length 50)
14:09:09 <hsk8> ski: sure
14:09:17 <geekosaur> monads are arguably a design pattern.
14:09:23 <hsk8> ski: is it possible to make that factorial strict somehow?
14:09:34 <hsk8> hmm..
14:09:49 <hsk8> maybe the stack overflow problem is a very rare problem that i shouldn't worry about?
14:09:56 <hsk8> but could it happen when dealing with big data?
14:09:57 <Cale> geekosaur: Well, they would be, except we have a type class to capture them :)
14:10:10 <Cale> geekosaur: They were before the introduction of the Monad class
14:10:11 <geekosaur> some design patterns express shortcomings in a language. some express ways to use features in a language.
14:10:20 <chrisdone> Monad axioms:
14:10:20 <chrisdone> Kleisli composition forms
14:10:20 <chrisdone> a category.
14:10:23 <geekosaur> there is a certain abstract commonality between these two
14:10:26 <chrisdone> ^_^ monad haiku from the wiki
14:10:30 <Cale> geekosaur: There were some bits of GHC for a long time which used the monad design pattern without using the type class
14:11:44 <monochrom> I suggest this working definition: a design pattern is a macro that people expand by hand.
14:12:00 <chrisdone> monochrom: works for me
14:12:25 <chrisdone> not abstracting because you can't
14:12:46 <solrize> @pl op1 xs ys = [[x*y | x<-xs] | y<-ys]
14:12:47 <lambdabot> op1 = flip flip [] . ((:) .) . (<-) . (| y) . return . (x *) . ((y | x) <-)
14:13:03 <chrisdone> even
14:13:03 <chrisdone> do exists <- doesFileExist "…"
14:13:03 <chrisdone>    if exists
14:13:03 <chrisdone>       then …
14:13:07 <chrisdone>       else …
14:13:11 <chrisdone> is a pattern
14:13:16 <chrisdone> (also s/if/case)
14:13:19 <solrize> @pl op2 xs ys = map (\y->[x*y | x<-xs]) ys
14:13:19 <lambdabot> op2 = map . flip flip [] . (((:) . (x *)) .) . flip ((<-) . (| x))
14:13:21 <chrisdone> somewhat mitigated by lambda case now
14:13:24 <monochrom> some macros can be rewritten as functions in the language, some other macros can't. this depends on the language.
14:15:08 <monochrom> and now I pull this trick: in practice, why do people hand-expand a given macro? then the answer is inevitably: they can't rewrite it as a function and just call the function.
14:15:18 <phaazon> hey, I’m looking for that link with all Haskell-related online papers
14:15:23 <Hodapp> And some "high-level" languages are high enough level to know better.
14:15:42 <monochrom> so in practice we obtain: a design pattern (a macro that people in practice bother to hand-expand) cannot be an API.
14:15:59 * monochrom is a master of setting up and deducing tautologies!
14:16:12 <Hodapp> monochrom: But tautologies are tautologies.
14:16:16 <chrisdone> ski: how do we write a proof in terms of my combinators that my Html monad satisfies the monad laws?
14:16:53 <monochrom> you can also deduce: the language doesn't allow you to turn a macro into a function, so this language has a shortcoming.
14:17:08 * chrisdone tries some equational reasoning
14:17:16 <monochrom> perhaps s/a macro/this macro/
14:18:27 <Pamelloes> If I have an infinite [Bool] that consists of an arbitrary combination of True and False before ending in [False..]. Is there any way to remove all of the Falses at the end of the list?
14:18:46 <solrize> @pl op2 = map . flip (map . (*))
14:18:46 <lambdabot> op2 = map . flip (map . (*))
14:19:40 <blume> lambdabot said  op1 = flip flip [] . ((:) .) . (<-) . (| y) . return . (x *) . ((y | x) <-)
14:19:41 <joshc> Pamelloes: what does [False..] mean? an infinite list of False?
14:19:41 <kadoban> Pamelloes: How would you know when to stop?
14:19:46 <shiona> @unpl map . flip (map . (*))
14:19:46 <lambdabot> (\ f -> map (\ c -> map ((*) c) f))
14:19:52 <blume> what do the pipes mean in that context?
14:20:22 <blume> can't see any list comprehension
14:20:26 <Hodapp> Yes, that definition poses some difficulty.
14:20:46 <Hodapp> How could you discern that you have hit the last True in that list?
14:20:49 <solrize> given lists [1,2,3]  [1,5,10,20]   op xs ys is supposed to be the outer product [[1,2,3],[5,10,15],[10,20,30],[20,40,60]]
14:21:17 <Hodapp> There certainly *is* a last True, if that arbitrary combination is finite.
14:21:41 <monochrom> Pamelloes: if you also tell me how many True's there are, then I know how to remove all the infinitely many False's
14:22:08 <success> are facebook games html5?
14:22:28 <monochrom> if you don't tell me, then I don't have a constructive proof that there are only finitely many True's in the list, therefore your task is uncomputable.
14:23:39 <statusfailed> maybe dumb question- how do I get "round" to give me an Int32 that hasn't been wrapped around to a negative value?
14:23:44 <Pamelloes> joshc: Exactly monochrom: The ideal situation would be not knowing at all.
14:23:49 <statusfailed> > round (2^32 - 1) :: Int32
14:23:50 <lambdabot>  -1
14:24:03 <statusfailed> > round (2^31 - 1) :: Int32
14:24:05 <monochrom> that is not ideal. that is dystopia. to be able to compute the uncomputable.
14:24:05 <statusfailed> I meant that
14:24:05 <lambdabot>  2147483647
14:24:17 <Pamelloes> Hm...
14:24:32 <Pamelloes> I was hoping there would be some way to detect when you reach an infinite list
14:24:47 <Pamelloes> Through black magic or something...
14:24:50 <JagaJaga> @hoogle Int -> Word
14:24:50 <lambdabot> Data.Set elemAt :: Int -> Set a -> a
14:24:50 <lambdabot> Prelude (!!) :: [a] -> Int -> a
14:24:50 <lambdabot> Data.List (!!) :: [a] -> Int -> a
14:24:55 <monochrom> some infinite lists may be detectable. but not all.
14:25:06 <JagaJaga> @hoogle Integer -> Word
14:25:06 <lambdabot> Prelude fromInteger :: Num a => Integer -> a
14:25:07 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
14:25:07 <lambdabot> Control.OldException throwDyn :: Typeable exception => exception -> b
14:25:16 <JagaJaga> :(
14:25:36 <kadoban> Pamelloes: What would you be using this for anyway? You can maybe find some extra information that can tell you when you quit.
14:25:39 <statusfailed> @hoogle Double -> Int32
14:25:39 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
14:25:39 <lambdabot> Control.OldException throwDyn :: Typeable exception => exception -> b
14:25:39 <lambdabot> Control.DeepSeq ($!!) :: NFData a => (a -> b) -> a -> b
14:25:57 <haasn> Pamelloes: what about [True] ++ replicate (2^2^2^ageOfTheUniverse^GrahamsNumber^TREE(3)^A_A_A_A_A_A_A(10)(10)(10)(10)(10)...) False ++ [True] ++ repeat False
14:26:01 <josephleon> total noob starting haskell (coming from php, ruby and python) is the best start "Learn you a haskell"?
14:26:41 <ski> josephleon : probably depends on person and background. try it and see if you like it ?
14:26:56 * ski learned from "Haskell: The Craft of Functional Programming"
14:27:09 <blume> mhhh Graham's Number... *rubs belly*
14:27:10 <josephleon> @ski ok ill take a look at that, thanks
14:27:10 <lambdabot> Maybe you meant: wiki src ask
14:27:14 <worldsayshi> Greetings; I’m trying to understand the lens package: How can I apply two prisms “in sequence”? How do I get (Just 5) from (Left (Left 5))  ?
14:27:35 <monochrom> I am fine with using backdoors to detect cycles in a list. well, see, that is an indirect way to give me a constructive proof that the True's are finitely many. that is good. but not all infinite lists are eventually cyclic.
14:27:57 <statusfailed> worldsayshi: might be remembering wrong, (myThing ^? _Left . _Left)
14:28:17 <ski> monochrom : .. but it's not extensional
14:28:19 <Pamelloes> I'm working on parsing data from a finite [Bool] list. However, to parse the data, more Bools might be needed than those provided. Any additional Bools needed are assumed to be False.
14:28:32 <statusfailed> worldsayshi: seems to work?
14:29:10 <Pamelloes> My plan was to represent this as aBoolList++[False..], but I need to be able to get back to the original list from the new list.
14:29:24 <statusfailed> > (Left (Left 5)) ^? _Left . _Left
14:29:26 <lambdabot>  Just 5
14:29:47 <ski> Pamelloes : perhaps you could make a type representing eventually cyclic lists, if those are all that you care about ?
14:29:59 <monochrom> I don't know why you need more Bools. but this inspires me a similar trick along a different axis: have more possibilities than Bool.
14:30:17 <worldsayshi> statusfailed: Ah, yeah. That worked. Thanks. Hmm, I’ll get back to my non-trivial example and try again..
14:30:32 <WigglesMcMuffin> in a function definition of the form 'someFunc (x:xs) = ...' what exactly does the (x:xs) do, does that mean give me the first element as x, and the rest as xs?
14:31:07 <monochrom> data Three = T | F | M. have the list be xs++(repeat M). in xs, only T and F occur. then you just have to look for the first M.
14:31:55 <ski> hm, hsk8 left ..
14:32:12 <ski> `map Just xs ++ repeat Nothing'
14:32:19 <statusfailed> worldsayshi: :)
14:32:28 <kadoban> WigglesMcMuffin: Yep
14:32:29 * hackagebot trace 0.1.0.2 - A monad transformer for tracing provenience of errors  http://hackage.haskell.org/package/trace-0.1.0.2 (JonSterling)
14:32:29 <statusfailed> worldsayshi: feel free to post it if you need help
14:32:40 <monochrom> data Dragon a = Nil | Cons a (Dragon a) | Here_be_dragons
14:32:50 <kadoban> Nice
14:32:58 <WigglesMcMuffin> Kadoban: Thanks :)
14:33:03 <vanila> hahaha
14:33:11 <Pamelloes> monochrom, that's actually a really interesting idea. By implementing it as Eq, could I make it so that Three would function exactly like a Bool?
14:33:30 <monochrom> http://www.vex.net/~trebla/photo/unorganized/dragon.jpg
14:33:36 <ski> Pamelloes : where does your infinite, eventually-constantly-`False' list come from ?
14:33:45 <WigglesMcMuffin> Kadoban: I'm not new to programming, or even really "functional paradigm" (a la python and ruby), but the concise syntax on the other hand
14:33:47 <Pamelloes> User input/a file.
14:34:08 <monochrom> a file is finite
14:34:30 <monochrom> user input may be infinite, but you don't have to worry about that case
14:34:42 <Pamelloes> Exactly, the list would be: finiteList++[False..]
14:34:47 <ski> is `/dev/random' finite ?
14:34:54 <monochrom> (i.e., if the user chooses to never stop, then you will never start anyway)
14:35:18 <monochrom> /dev/random is a pretended file, not a file
14:35:21 <zmbmartin> Is it possible with doctest to approximately equal so -> 4233453.467303546 or 4233453.467303547 are true
14:35:44 <Pip> What is a singleton tuple?
14:35:47 <monochrom> alternatively, /dev/random is user input. if it doesn't stop, you have nothing to do anyway
14:35:47 <ski> WigglesMcMuffin : this is known as "pattern-matching" and "definition-by-cases"
14:36:19 <ski> Pip : a type with one (total) element ?
14:36:19 <Pamelloes> I have code processing the user input that into various "statements". Once the provided input is fully processed, False is used to complete any incomplete statements.
14:36:42 <Pip> ski, Can you give me an example?
14:36:45 * monochrom should make another picture that says: "Ikea dragon syas: there is no infinite list" :)
14:37:23 <ski> Pip : e.g. given `data Nat = Zero | Succ Nat' and `data NatIs :: Nat -> * where IsZero :: NatIs Zero; IsSucc :: NatIs n -> NatIs (Succ n)', `NatIs n' is a singleton type (for any particular `Nat' `n')
14:38:02 <Pip> ski, I started to learn Haskell today, maybe you you can give me a simple example?
14:38:04 <ski> Pip : a simpler example is `()' or `data Unit = Unit' or `data Loop = Looping Loop'
14:38:25 <ski> Pip : oh, sorry. i thought i recognized you
14:38:31 <Pip> You don't
14:38:31 <worldsayshi> statusfailed: I found my problem. :) I used a prism for retrieving from a Map type. (fromList [("foo",5)]) ^? at "foo" . I expected this to yield (Just 5) but it gave me (Just (Just 5)). Adding a _Just prism fixed it.
14:38:44 <Pip> (1) --> singleton tuple?
14:39:19 <joshc> Pip: where did you run across this term?
14:39:22 <ski> (yeah, i was thinking of someone else on another channel, with the same nick as you, and mistakenly thinking you were them, and that you had been in #haskell for some while)
14:39:27 <benmachine> there are no one-tuples
14:39:35 <Pip> joshc, I'm ready a book
14:39:37 <ski> Pip : so, any type which has one value
14:39:39 <Pip> *reading
14:40:23 <ski> Pip : if Haskell supported interval (sub)types, then the interval from `7' to `7' (inclusive) would be a singleton type, containing exactly one value (`7')
14:40:43 <joshc> benmachine: well, not as defined by the language, but it's possible to define your own. or use OneTuple, for example.
14:41:20 <ski> Pip : a singleton tuple, if Haskell had any such thing, wouldn't be a singleton type, since it would have as many elements as the (single) component type in the unituple had
14:41:35 <ski> Pip : do you know C ?
14:42:28 <Pamelloes> Thoughts on creating a type RBool=True|False|Repeat deriving (Show)? Is overriding Bool a really bad idea?
14:42:50 <ski> Pip : if C allowed it, `struct singleton {};' would make `struct singleton' a singleton type (with no fields), whose sole value could be written as `{}' (possibly ith `(struct singleton)' before it)
14:43:37 <ski> Pip : similarly, the *zero*-tuple type `()' of tuples have *no* fields is a singleton type in Haskell. it's sole value is also written `()'
14:44:11 <texasmynsted> "Cale Design patterns are a measure of the failure of the language to capture abstractions that we want to use to understand the code"  Yes. exactly "monochrom … a design pattern is a macro that people expand by hand." because the language fails to provide a way to materialize the essence of the macro.
14:44:31 <Cale> texasmynsted: right
14:45:02 <texasmynsted> Darn had to step away for a while…. still catching up on scrollback
14:45:03 <ski> Pip : when `void' is used in C to represent "no (interesting) result" for a function, you can think of it basically as (implicitly) returning the sole (uninteresting) value of the singleton type `void'. however, there's no actual syntax to write this (conceptual) value in C
14:45:24 <ski> Pip : also, `void' as used in `void *' is completely different, as i imagine you're aware
14:46:22 <ski> Pamelloes : that's not really overriding `Bool', though you'll need to hide the `True' and `False' from `Prelude' to not clash with your data constructors
14:47:17 <ski> Pamelloes : anyway, i don't think `[False,Repeat,True,Repeat,True]' would be very sensible, no ?
14:47:29 <Pamelloes> That's true...
14:47:33 <HeladoDeBrownie> Pamelloes, depending on your use case you could use Maybe Bool, where Nothing denotes whatever that thing that isn't True or False is
14:48:34 <ski> Pamelloes : perhaps you can use `([Bool],Bool)', the `Bool' in the right component representing whether the corresponding possibly infinite list either terminates (is finite), or (conceptually) continues with infinitely many `False's after the initial elements of the list in the left component
14:48:38 <texasmynsted> Heh, now I am mixing up channels <sigh>
14:48:41 <monochrom> hmm, it is not clear whether C's void stands for "a value uninteresting and unspeakable" or "no value". it may be just philosophy, for either way is consistent with the axioms.
14:48:50 <HeladoDeBrownie> Oh, I must have missed the context.
14:48:55 <Pamelloes> Can you define a type's values as equalling another type? e.g False and Repeat are equivalent to Prelude.False, and True is equivalent to Prelude.True?
14:49:20 <ski> Pamelloes : no, there's no subtyping in Haskell
14:49:48 <ski> Pamelloes : you could say `data RBool = ABool Bool | Repeat' if you really wanted to, though
14:50:24 <steffen> Hi :) When I have a function of type: Monad m => whatever -> Form a m whatever. Can I make use of the Monad m? Why is it in the type anyway? I understand Monads and monadic functions of such a type: Monad m => a -> m a, but I don't see the use of having a monad in a type without it being the return type. Can someone please explain or point me to a resource where I can read up on that? Or just a keyword which I can search for. Thanks!
14:50:48 <HeladoDeBrownie> steffen, you can make use of the general Monad interface but not of the other features of the type m.
14:51:06 <monochrom> actually, the axioms may incline to "no value". you can't even pass it to another function.
14:51:17 <HeladoDeBrownie> steffen, what you actually do with it would depend in part on what this Form type is
14:51:18 <Pamelloes> Hm...
14:51:29 <ski> steffen : perhaps `Form a' is a monad transformer, which which case `Form a m' is a monad, and you can also use `lift' to lift actions in the `m' monad into the `Form a m' monad
14:51:49 <monochrom> if "void f(void)" then "f(f())" is a type error. existence of an unspeakable value would allow it.
14:52:10 <HeladoDeBrownie> (Monad m) => Form a m looks wrong to be a transformer, the parameters would need to be flipped
14:52:22 <steffen> ski: Thanks, but in the case of monad transformers I understand it, then it kind of falls in the Monad m => a -> m a category
14:52:27 <ski> monochrom : granted
14:52:30 * hackagebot smtps-gmail 1.3.0 - Gmail SMTP Client  http://hackage.haskell.org/package/smtps-gmail-1.3.0 (EnzoHaussecker)
14:52:59 <ski> monochrom : however, depending on what you mean by "no value", it could mean the same as "a value uninteresting and unspeakable"
14:53:16 <phaazon> http://phaazon.blogspot.co.uk/2014/11/foreword-abstracting-what-shaders-are.html is it me, or my Haskell sources have pretty bad hilighting ? (hilight.js)
14:53:23 <ski> monochrom : another interpretation would be (more or less) "an unboxed empty tuple/struct"
14:53:44 <steffen> HeladoDeBrownie: Can you maybe give me any example or something to read up on? I don't really understand what you mean by "make use of the general Monad interface"
14:54:08 <monochrom> well, it is now "uninteresting, unspeakable, unassignable, impassible". the list of impossibilities may yet grow further. it's now time to bring out the Occam razor...
14:54:37 <ski> monochrom : yet another would be an empty type, which could be an appropriate return type for `longjmp'
14:54:56 <HeladoDeBrownie> steffen, I think you'd probably come across the idea in introductory reading (e.g., LYAH) that when all you know about a type is that it has a specific instance, you can't do any operations on that type besides those permitted by that class
14:55:31 <ski> monochrom : how about `void f(int n) { return f(n + 1); }' ?
14:55:58 <monochrom> is that even allowed?
14:56:00 <HeladoDeBrownie> steffen, e.g., say you had (Monad m) => m a. You could pass this around to functions taking any type, or you could use any of the Monad methods with it as appropriate, but you can't, e.g., use Monoid with it even when some of the specific types passed in might have such an instance.
14:56:14 <ski> steffen : should i take that to mean that `Form a' isn't a monad transformer ?
14:56:41 * ski notes HeladoDeBrownie's point
14:56:53 <monochrom> yikes, it's allowed.
14:57:01 <ski> steffen : anyway, you probably have to tell us more about `Form'
14:57:08 <ski> monochrom : in standard C ?
14:57:14 <monochrom> I don't know yet.
14:57:17 <steffen> HeladoDeBrownie: ahh, it's slowly starting to make sense now
14:57:38 <monochrom> is "gcc -ansi" good enough?
14:57:50 <steffen> ski: http://hackage.haskell.org/package/digestive-functors-0.7.1.1/docs/Text-Digestive-Form-Internal.html#t:FormTree
14:58:06 <c74d> How often is profiling used in Haskell?
14:58:49 <c74d> Or more specifically, profiling-enabled variants of libraries?
14:59:30 <Pamelloes> If I define using Eq that a==b, can I implement a function that has a separate case for a and b?
14:59:57 <ski> steffen : looks fun
14:59:59 <monochrom> yes, pattern matching does not have to use ==
15:00:01 <steffen> ski: Its not so much about this explicit example, I'm trying to understand the idea behind it. But what HeladoDeBrownie already wrote helps a bit
15:00:11 <steffen> ski: mhm.. :)
15:00:44 <monochrom> will digestive functors eat my keyboard?
15:01:06 <benmachine> no, but they are pleasant when dipped in tea
15:01:06 <Pamelloes> only if you make them applicative.
15:01:26 <MP2E> digestive functors only eat their applicative meal
15:01:27 <ski> perhaps they'll eat fungi
15:01:45 <monochrom> :)
15:02:25 <ski> Pamelloes : please clarify your question
15:02:58 <monochrom> if Functor were renamed to Mappable, then Applicative would be renamed to Applicable
15:03:06 <Pip> ski, today's learning on Haskell is over
15:03:28 <monochrom> now, Monad, I don't know whether you like Bindable or Joinable more, or something else
15:03:34 <Pip> I will study singleton thing after a sleep
15:03:54 <steffen> HeladoDeBrownie: So if (just speculating it may not make sense in the case of Form) m in: Monad m => a -> Form x m a would be of type State, I could use get and put within this function?
15:04:03 <adarc> is there a netflix for journals, ie, i want to spend $8/month and read every publication in the journal of functional programming.. 8|
15:04:42 <HeladoDeBrownie> steffen, you could not, because the function operates over *any arbitrary* m given only that it has a Monad instance. You don't know it's State in that function.
15:04:42 <steffen> HeladoDeBrownie: ofc (State a b)
15:05:07 <kadoban> adarc: You can usually go to any local library/university and get access to most journals for free, even as a non-student. It might take some work though.
15:05:13 <monochrom> adarc: there is ACM membership. it's yearly but it may come down to $8/month
15:05:18 <Pamelloes> ski: data T=A|B|C ; instance Eq T where _ == _ = True ; Can I define a function f :: T -> Bool ; f A = True ; f B = False ; f c = error "C is not allowed" ?
15:05:40 <koala_man> I proxy through my old uni account
15:05:56 <adarc> whoa really monochrom .. nice
15:06:11 <adarc> kadoban: ya when i was at uni years ago i had access to *..
15:06:12 <steffen> HeladoDeBrownie: Ahh okay, but if it would be a -> From x (State b c) a, then I could? Or am I still on the wrong track here... ?
15:06:15 <adarc> i'll check out the ACM stuff
15:06:17 <monochrom> ACM membership is good enough for downloading all ICFP and SIGPLAN papers.
15:06:23 <adarc> nice!
15:06:30 <HeladoDeBrownie> steffen, that's right, once you know a concrete type you can use any operation defined over that type on it.
15:06:33 <monochrom> but doesn't cover JFP
15:06:38 <adarc> thanks monochrom
15:06:41 <petrus> I have downloaded the hoggle data bases tar file "hoogle.tar.gz" from Hackage. How can I build a simple local hoogle db file using these?
15:07:41 <monochrom> adarc: are you a student? if so, there is a cheaper student fee.
15:08:08 <steffen> HeladoDeBrownie: mhm I would really understand it, if Form would be a monad transformer, but it is not, and still i could call get and put in this example... strange
15:08:25 <ski> Pip : ok
15:08:44 <fds4345> MultiParameterTypeClasses are making my life miserable.
15:08:46 <HeladoDeBrownie> steffen, if you posted some code (including whatever this Form type is) we might be able to figure it out
15:09:25 <Pip> ski, Thank you all the same
15:09:29 <ski> yw
15:09:40 <c74d> Is always installing profiling-enabled libraries recommended? How much storage space would that cost me?
15:09:52 <ski> Pip : ooc, where did you run into the term "singleton type" ?
15:09:56 <fds4345> I have some MPTCs and the solution to all problems seems to be more MPTCs
15:10:19 <fds4345> To link all the types together. Its insane
15:10:39 <Pip> ski, http://learnyouahaskell.com/starting-out#tuples
15:10:49 <Pip> search "singleton"
15:11:35 <steffen> HeladoDeBrownie: Well that is !very! nice of you, I don't yet have good code to show, but eventually I'll be back with a code example the next time we meet here. I got2go but I am very glad that you took your time already to help me :) <3
15:11:41 <ski> Pip : hm, i think when they said "singleton tuple" there, they meant what i called "unituple", iow a tuple with only one component (compare with a C struct with only one member field)
15:12:03 <HeladoDeBrownie> No problem, have fun
15:12:11 <monochrom> fds4345: MPTCs correspond well to relational databases. when you are design a relational database, do you also find yourself creating more tables?
15:12:22 <ski> (while a "singleton list" usually just means a list which happens to have a single element, e.g. `[3]' (which is distinct from `3', unlike e.g. Matlab))
15:12:26 <Pip> ski, (1) is totally legal
15:12:39 <HeladoDeBrownie> (1) evaluates to the same thing as 1
15:12:45 <ski> Pip : yes, but it's not a unituple in Haskell., it's the same as `1'
15:13:00 <ski> Pip : just like `(2 + 3)' is the same as `2 + 3'
15:13:16 <Pip> gotcha
15:13:30 <Pip> I don't know how to use `' pair
15:13:34 <ski> monochrom : someone on ##c said it wasn't legal standard C
15:13:44 <monochrom> that is good to hear.
15:13:46 <Pip> But for the singleton part, I got it
15:14:19 <monochrom> "unspeakable, unassignable, impassible, but returnable" would be too much madness :)
15:14:20 <ski> Pip : oh, i just use those to quote Haskell snippets i'm talking about. they're not part of the actuall Haskell code/expressions/whatever
15:14:50 <ski> monochrom : so much for having some fun :/
15:15:06 <Pip> Ah, I see
15:15:25 <ski> (i suppose `struct foo {void u;};' is also illegal)
15:15:32 <Pip> Anyway, I've finished reading the chapter 1
15:15:44 <ski> (oh, and `void u[10];')
15:17:11 <fds4345> monochrom: I don't think I create too many. But I have 2 MPTCs and the only way to make the type system happy seems to be to create even more
15:17:57 <ski> Pip : anyway, good luck with the rest !
15:17:59 <monochrom> to normalize a relational database, you also create more tables. (and fewer columns per table)
15:18:16 <monochrom> do you remember your 4th normal form, the theoretical ideal? :)
15:18:17 <fds4345> Is it a common pattern to store lists of functions?
15:18:30 <ski> fds4345 : it happens sometimes
15:18:37 <monochrom> not seen everywhere, but not uncommon either
15:18:42 <EvanR> imagining pracitioners everywhere balking at normal form
15:18:50 <fds4345> monochrom: I see the relationship (no pun intended)
15:18:54 <ski> monochrom : hm, i remember reading about higher forms :)
15:18:56 <monochrom> :)
15:19:06 <ski> (also, 1NF is silly !)
15:19:38 <EvanR> we only use CSV normal form
15:19:55 <ski> Codd-S???-V??? normal form ?
15:20:19 <benmachine> codd-separated values
15:20:29 <monochrom> Codd-Seeks-Vendetta
15:20:56 <fds4345> The viable alaternative to MPTCs looks to be closures.. So storing lots of functions. This is unfortunate since functions and closures aren't as serializable as data objects with associated behaviour
15:21:43 <ski> @remember ErrettBishop Mathematics is common sense
15:21:43 <lambdabot> Done.
15:21:46 <Pamelloes> How do I find the instance implementation of a type in Prelude?
15:21:50 <ski> @remember ErrettBishop Do not ask whether a statement is true until you know what it means
15:21:50 <lambdabot> Done.
15:22:00 <ski> @remember ErrettBishop A proof is any completely convincing argument
15:22:00 <lambdabot> Good to know.
15:22:07 <ski> @remember ErrettBishop Meaningful distinctions deserve to be preserved
15:22:07 <lambdabot> Good to know.
15:23:01 <monochrom> great, next Wednesday we will learn much mathematic philosophy in Haskell Weekly News!
15:23:18 <EvanR> fds4345: you can hide / expose data objects with clojures
15:23:45 <EvanR> or hide the data object, and expose the serialization
15:23:53 <EvanR> good old oop
15:23:54 <monochrom> (@forget will not undo that. the editor looks in logs. you will have to erase logs the NSA way...)
15:24:03 <fds4345> EvanR: how
15:24:50 <EvanR> fds4345: by providing the data object to the constructor that provides the record of functions, views
15:25:15 <Denommus> I wish there was a specific channel about FRP
15:25:31 <EvanR> in this way you can also have your views satisfy one type while hiding implementations that involve other types
15:25:41 <EvanR> different types
15:25:44 <ski> @remember ErrettBishop In the words of Kronecker, the positive integers were created by God. Kronecker would have expressed it even better if he had said that the positive integers were created by God for the benefit of man (and other finite beings). Mathematics belongs to man, not to God. [...] When a man proves a positive integer to exist, he should show how to find it. If God has mathematics of his own that needs to be done, let him do it himself.
15:25:45 <lambdabot> Okay.
15:26:25 <ski> @remember ErrettBishop We are not contending that idealistic mathematics is worthless from the constructive point of view. This would be as silly as contending that unrigorous mathematics is worthless from the classical point of view. Every theorem proved with idealistic methods presents a challenge: to find a constructive version, and to give it a constructive proof.
15:26:25 <lambdabot> Done.
15:26:46 <monochrom> I'm glad that Kronecker said "positive integers" so we don't have to argue "is 0 included or not?"
15:28:17 <ski> @quote JacquesHadamard
15:28:18 <lambdabot> JacquesHadamard says: The shortest path between two truths in the real domain passes through the complex domain.
15:28:39 <chrisdone> ski: i think i have a proof that my monad satisfies the unit law, gimmie a minute
15:29:06 <fds4345> EvanR: Dont follow
15:30:19 <EvanR> fds4345: by closures i thought you meant records containing values or functions that came from a constructor function with things in scope that would be inaccessible with just that record
15:31:25 <EvanR> fds4345: its a plausible way to have wildly different types satisfy some uniformly typed interface
15:31:35 <EvanR> i can get a lpaste
15:32:06 <ski> @remember HermannWeyl Brouwer, that is the revolution!
15:32:06 <lambdabot> Done.
15:36:03 <ski> @remember Brouwer "Does every real number have a decimal expansion?" (1921)
15:36:03 <lambdabot> Nice!
15:36:32 <fds4345> EvanR: I meant that instead of keeping a data object with different types of stuff inside of it that entails polymorphism, hide the polymorphism by storing functions of type (a -> b m) in a list / map. These functions are closures over stuff that was in scope when they were added to the map, which could have different types.
15:37:20 <EvanR> fds4345: thats essentially the same thing as what im saying only with a record instead of a list or map
15:38:34 <fds4345> Ah. Right, then the record contains functions which aren't serializable. The closed over variables aren't viewable either.
15:38:55 <fds4345> I mean serializa as in, like, JSON
15:39:46 <EvanR> fds4345: http://lpaste.net/114326
15:40:14 <EvanR> fds4345: well, you would need to serialize the functions, depending on how you decide to restore
15:40:32 <EvanR> the functions can be reconstituted on deserialization
15:41:22 <EvanR> fds4345: uhg. you would NOT need to serialize functions
15:41:47 <ski> @remember DavidHilbert We must not believe those, who today, with philosophical bearing and deliberative tone, prophesy the fall of culture and accept the _ignorabimus_ ("Ignoramus et ignorabimus","We do not know, we shall not know"). For us there is no _ignorabimus_, and in my opinion none whatever in natural science. In opposition to the foolish _ignorabimus_ our slogan shall be: _Wir müssen wissen — wir werden wissen!_ ("We must know — we wil
15:41:47 <lambdabot> I will remember.
15:42:11 <simpson> Alas, brave Hilbert.
15:42:34 <EvanR> ski: cut off
15:43:39 <lpaste> chrisdone pasted “Proof for unit in Html (ski)” at http://lpaste.net/114327
15:43:46 <ski> EvanR : fixed it
15:44:18 <chrisdone> ski: is that followable or too wacky? you can skip the mechanical steps and go right to the last part of each section =3
15:44:44 <fds4345> EvanR: wouldn't it complicate things if poke needed to have type `Bool -> m ICoolImplementation`
15:45:59 <EvanR> fds4345: for a particular m, it shouldnt be a big deal
15:46:08 <EvanR> though thats not really the point of this pattern
15:47:00 <chrisdone> ski: these are the only combinators provided by the library, so that should be a complete proof for this law, i think. what do you think?
15:47:54 <EvanR> ICoolImplementation 4 "cool" (fmap mkImpl getC) for example
15:49:52 <fds4345> it may still be an issue... I'm not sure you can compose this data structure without a concrete m
15:51:39 <EvanR> well its an interface, i didnt think of any way to compose it
15:51:57 <Denommus> anyone experienced in Netwire?
15:52:01 <EvanR> you would define the interface, and define operations that use it
15:52:40 <EvanR> you can parameterize the interface type, like with forall m
15:53:12 <EvanR> though you of course need to match up the m's when you use it
15:58:44 <chrisdone> it'd be neat to have a tool that'd expand an expression step by step to aid equational reasoning
15:58:55 <chrisdone> benmachine: like stepeval =3
15:59:16 <benmachine> chrisdone: neat is what it would be indeed
16:00:17 <chrisdone> gsoc?
16:00:29 <EvanR> like this? http://chrisuehlinger.com/LambdaBubblePop/
16:01:27 <chrisdone> haha wow they improved it
16:01:28 <chrisdone> awesome
16:03:57 <ski> chrisdone : the proofs steps looks ok to me. however, i didn't follow the `Html ()' reasoning for `makeElement' and `with'
16:04:41 <ski> chrisdone : what do you mean by "1) It cannot be provided with more input now.  2) It cannot be provided with more attributes now" ?
16:06:02 <ski> chrisdone : another potential trouble would be infinitely nested applications of your operations .. but i'm not sure that matters here
16:06:54 <chrisdone> ski: i mean that the only means of injecting one of the Builder arguments, either for putting attributes in or for adding children to a parent must be done via those two functions. so the fact that `makeElement n a' ignores any further input is correct, its type is already Html (), you can't call makeElement (makeElement n a) "more" to add more content. likewise for `with'
16:07:40 <chrisdone> ski: does that make sense?
16:07:51 <ski> chrisdone : what is an example of a term of type `Html a', with `a' distinct from `()' ?
16:08:13 <chrisdone> ski: return 123?
16:08:15 <mungojelly> .ui mi cilre fi la .xaskel. poi sambau zi'e noi melbi
16:08:27 <ski> hmm
16:09:20 <chrisdone> λ> renderHtml (return "hello" >>= p_)
16:09:20 <chrisdone> "<p>hello</p>"
16:09:22 <chrisdone> ^ this is fine
16:09:35 <chrisdone> equivalent to: λ> renderHtml (p_ "hello") => "<p>hello</p>"
16:09:50 <ski> i still don't understand how 1) and 2) follows from `makeElement n a :: Html ()' and `with :: (Html () -> Html ()) -> [Attr] -> Html () -> Html ()'
16:10:19 <chrisdone> because the `a' is the input
16:10:52 <chrisdone> p_ :: Html () -> Html () -- this accepts input. p_ (undefined :: Html ()) :: Html () -- now it doesn't
16:11:11 <ski> contrarywise, since `with' can be passed a `Html ()', and since `makeElement n a' has that type, it seems to me that you can "add more content" with `with'
16:11:23 <ski> so there must be something i'm missing/misunderstanding
16:11:34 <chrisdone> right, i'm just "content" or "children". let's use "children"
16:11:49 <ski> hm
16:12:26 <Denommus> for those who understand Netwire
16:12:34 <chrisdone> p_ -- can accept children, p_ "x" -- can't, p_ -- can accept attributes and children, with p_ [] -- can accept just children, with p_ [] "woot" -- now it's a complete Html a
16:12:37 <ski> oh, you're thinking of the `Html () -> Html ()' as "accepting input" ?
16:12:38 <Denommus> I'm struggling to understand how to tell it that an event has "happened"
16:12:51 <chrisdone> ski: right. similar to the classic `html' package's combinators
16:12:59 <Denommus> I have a value of type Event every step
16:13:02 <ski> i thought the two function arguments in the internally hidden function were the "inputs"
16:13:06 <Denommus> I mean, Event a
16:13:12 <Denommus> so it's either an Event a or NoEvent
16:13:46 <chrisdone> ski: that's right. it's just that children are provided by that argument in the type-sig you just wrote, and attributes are provided via with. they both internally use that internal function
16:13:55 <Denommus> now, I want to create a Wire s e m a0 (Event a) from it so I can use it
16:13:55 <ski> mungojelly : translate from lojban ?
16:14:13 <chrisdone> ski: but nobody can come and just write Html (\haha i'minurmonad -> wreaking'havoc)
16:14:22 <Denommus> but how do I "trigger" the event to Netwire?
16:14:37 <mungojelly> ski: "I'm happily learning Haskell (the programming language) which is beautiful." The Lojban is unambiguous that it's Haskell that's beautiful, of course. :D
16:14:58 <chrisdone> hi mungojelly =)
16:15:14 <ski> chrisdone : i don't see why `with f attrs0 (with g attrs1 h)' wouldn't be possible
16:15:18 <mungojelly> I'm reading Learn You a Haskell so I joined here because it recommended here. So far the only Haskell I've written is some XMonad configuration. :)
16:16:31 <ski> mungojelly : welcome :)
16:16:49 <chrisdone> ski: that's entirely possible, yeah. but it should be:
16:16:50 <chrisdone> λ> renderHtml (with div_ [class_ "header"] (with img_ [class_"logo"] mempty))
16:16:50 <chrisdone> "<div class=\"header\"><img class=\"logo\"></img></div>"
16:16:53 <ski> if you have any (more or less Haskell-related) question, just ask
16:17:29 <chrisdone> ski: but the `with` applies to the `div_`, not to the (with img_ …)
16:17:37 <chrisdone> is that what you're thinking it does?
16:17:55 <mungojelly> ski: Thanks, I will. I've found it easy enough so far. It doesn't seem like it's difficult for simple things, so I think what people mean by it's a hard language is just they're scared of even being near concepts they don't understand.
16:18:26 <ski> chrisdone : hm. how about `renderHtml (with div_ [class_ "header"] (with img_ [class_"logo"] =<< return mempty)' ?
16:18:51 <chrisdone> λ> renderHtml (with div_ [class_ "header"] (with img_ [class_"logo"] =<< return mempty))
16:18:51 <chrisdone> "<div class=\"header\"><img class=\"logo\"></img></div>"
16:19:02 <chrisdone> looks good
16:20:07 <chrisdone> (well, apart from img_ should be self-closing tag with no children, but that's a matter of defining img_ properly)
16:21:22 <davesque> is there a better channel to ask category theory questions than here?
16:21:25 <chrisdone> ski: i appreciate your inquisitiveness, btw =) this is the first time i did any equational reasoning on a real project. not much, but somewhat rewarding
16:23:10 <chrisdone> i'm pondering what kind of mtl monad it's like
16:23:26 <ski> chrisdone : hm. and `with (with div_ [class_ "header"]) [class_ "footer"] mempty' vs. `with ((with div_ [class_ "header"] =<<) . return) [class_ "footer"] mempty' ?
16:24:13 <ski> (both wrapped in `renderHtml', naturally)
16:25:39 <ski> mungojelly : it sure is a beautiful language (though not *that* small, if you also include the most common extensions)
16:26:27 <ski> mungojelly : it also has several quite advanced (comparatively speaking) features not that commonly seen in other programming languages
16:27:39 <ski> mungojelly : and some people also find it fun (ior useful) to introduce/encode various abstractions to express concepts or to encode (and commonly statically check) some invariants
16:27:40 <mungojelly> ski: Like this fancy type inference? I've been planning sometime to look up again the name of the type inference algorithm it uses and learn how it works. What I hear is that it's moderately complicated but works well.
16:27:51 <ski> Hindley-Milner
16:28:02 <batchm> if I go the sandbox route and only install packages locally is there anything I can do to avoid recompiling all the libraries for each project? if two projects use the same gtk2hs version, for example, there is no technical reason why it would have to be compiled two times
16:28:24 <Welkin> you can use shared sandboxes
16:28:52 <mungojelly> Basically the reason I'm here is that I had a moment of epiphany about types like a week ago. I'd always thought of type checking as an annoyance, as something that worked against me not for me. But suddenly somehow it became clear, I saw the light.
16:29:05 <ski> mungojelly : might i interest you in checking out "Polymorphic Type Inference" by Michael I. Schwartzbach in 1995-03 at <http://web.cecs.pdx.edu/~antoy/Courses/TPFLP/lectures/TYPE/typeinf.p(s|df)> ?
16:29:30 <davesque> i’m reading about he degenerate category 3 which could have objects A, B, C and arrows f : A -> B, g: B -> C, and g . f : A -> C…can there not also be a category which simply has two arrows — f : A -> B, and g : A -> C?  does that even make sense?  i’m pretty new to this stuff by the way.
16:29:44 <benmachine> davesque: sure
16:29:51 <benmachine> there are lots of categories
16:29:59 <benmachine> davesque: don't forget the identities, as well
16:30:02 <batchm> Welkin how well will that work? projects are completely unrelated and each one has some libraries that the other one doesn't use
16:30:08 <davesque> benmachine: right identities ommittedd
16:30:12 <davesque> ommitted
16:30:17 <benmachine> omitted :P
16:30:29 <davesque> argh…omitted :)
16:30:34 <ski> mungojelly : you do know about BNF syntax for specifying grammars, yes ?
16:31:20 <mungojelly> ski: yup, sure, i can read it anyway, i've never actually written one
16:31:33 <kadoban> batchm: That doesn't necessarily matter, as long as they share a parent directory or something...but it's not ideal.
16:31:35 <davesque> benmachine: so it seems like they mostly use that example when talking about 3 because it illustrates all the categorical axioms most clearly
16:32:13 <batchm> kadoban yeah.. i wish there was an option to cache object files to avoid recompilation
16:32:49 <ski> mungojelly : i think that paper is quite easy-going, as far as papers on type system stuff go. if you have trouble understanding any part, try asking in here
16:33:39 <mungojelly> ski: OK thanks, it looks like I should be able to get through it! :)
16:33:46 <kadoban> batchm: You can do things like set up the shared stuff, copy the sandbox over, and then have them separate I guess. Also not ideal though really...
16:33:46 <benmachine> davesque: perhaps
16:35:19 <ski> mungojelly : i assume you know at least a few other languages ? but perhaps not another functional programming language ?
16:35:24 <ski> mungojelly : i can also recommend attempting to read at least the initial parts of "On Understanding Types, Data Abstraction, and Polymorphism" by Luca Cardelli,Peter Wegner in 1985-12 at <http://lucacardelli.name/Papers/OnUnderstanding.A4.pdf>
16:36:36 <chrisdone> ski: took me a moment to figure out what this was supposed to mean but it seems that in the latter case the second parameters are ignored. i'm not sure how i feel about that
16:37:34 <mungojelly> ski: I speak some Scheme. I was in the middle of saying something vaguely in Scheme when I had my epiphany. I sorta reinvented type checking accidentally.
16:37:58 <mungojelly> I thought to myself, I need something that'll go around after me every time I use this data structure and make sure it's always properly formed. And then I was like-- Ohhhhhhhhhhh.
16:38:56 <ski> chrisdone : i'm not either (since i don't really understand what `with' is supposed to mean), but that's the kind of counter-example i thought i saw to your handwavy reasoning about "1) It cannot be provided with more input now.  2) It cannot be provided with more attributes now:  ...  and there `makeElement n a' cannot be passed to with." (and in the latter `with' case)
16:39:26 <ski> mungojelly : ok, Scheme is good. tried any SICP (or at least watching some SICP videoes) ?
16:40:19 <batchm> kadoban can you just copy paste say gtk2hs directory from one sandbox to another? that wouldn't be so bad
16:40:25 <chrisdone> ski: the notion that someone would nest with's never occured to me
16:40:28 <batchm> copy*
16:40:32 <mungojelly> ski: Yeah, that and Knuth are how I know everything I know about programming pretty much. :)
16:40:54 <ski> mungojelly : type inference (Hindley-Milner) was introduced in the ML language (which has SML,OCaml,F#,Alice ML as main descendents today)
16:40:59 <kadoban> batchm: I think you'd have to get all of the dependencies too, and maybe some kind of metadata too, not really sure.
16:41:17 <ski> Haskell got it from ML (via Miranda, and perhaps Hope ?)
16:41:25 <batchm> hmm yes, forgot about dependencies
16:43:14 <derekv> slightly off topic, I'm looking for a word to describe an entity which has no existence apart from it's description (description is identity).  Like a rectangle, or a string.  As apposed to say, an entity which describes something that exists independently of it's description (eg, "things that are rectangular")
16:45:37 <ski> chrisdone : can `with :: (Html () -> Html ()) -> [Attr] -> Html () -> Html ()' do anything (or anything important) that `with_ :: [Attr] -> Html () -> Html (); with_ = with id' can't do ? (note that `with f attrs h  =  with_ attrs (f h)  =  with id attrs (f h)')
16:45:40 <chrisdone> ski: if i change the monad instance to use the arguments,
16:46:40 <ski> mungojelly : if you have any uni lib nearby (or are prepared to buy it yourself), then TaPL is a nice and good introduction to type systems
16:46:44 <ski> @where TaPL
16:46:44 <lambdabot> http://www.cis.upenn.edu/~bcpierce/tapl/
16:48:00 <chrisdone> ski: i think the difference is with is supposed to be "with this parent use these attributes and these children": with thisParent theseAttributes theseChildren
16:48:29 <chrisdone> with the >>= method as: Html ((\attr inner -> g attr inner <> f' attr inner) ,b)
16:48:29 <chrisdone> i get:
16:48:29 <chrisdone> λ> with (\inner -> do p_ =<< return inner; p_ "y") [class_ "x"] mempty
16:48:29 <chrisdone> "<p class=\"x\"></p><p class=\"x\">y</p>"
16:49:07 <chrisdone> which… i'm not sure how i feel about that
16:49:47 <ski> chrisdone : hm, i just realized my parenthetical comment answered my own question ;)
16:50:54 <chrisdone> yeah -- you could just have `with attrs children', but the use-case is to express <parent attrs>children</parent>
16:51:10 <chrisdone> because p_ "foo" is convenient and with p_ [class_ "logo"] "foo" is also convenient
16:51:10 <ski> chrisdone : btw, if you uncomment the signature on `with', the inferred one should tell you (derivable from free theorem, i expect) that `with f attrs h = with id attrs (f h)' (so you could define `with' in terms of `with_' (as well as the other way around), so they're equal in strength)
16:51:51 <chrisdone> right
16:52:19 <phaazon> @hoogle (a -> b -> c) -> z a -> z b -> z c
16:52:20 <lambdabot> Control.Monad liftM2 :: Monad m => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
16:52:20 <lambdabot> Control.Applicative liftA2 :: Applicative f => (a -> b -> c) -> f a -> f b -> f c
16:52:20 <lambdabot> Data.IntMap.Strict intersectionWith :: (a -> b -> c) -> IntMap a -> IntMap b -> IntMap c
16:52:33 <phaazon> hm
16:52:38 <chrisdone> ski: let me see…
16:53:13 <chrisdone> ski: right
16:53:40 <phaazon> I thought I’d need to create a Zip typeclass
16:53:50 <phaazon> but it’s actually Applicative I guess
16:54:28 <ski> `Applicative' ftw !
16:55:04 <hakujin> is there some way to have cabal default to using -j during installs?
16:55:09 <chrisdone> yeah, with id attrs (f h) = with f attrs h
16:55:58 <chrisdone> ski: this style is just more convenient
16:56:00 <davesque> hakujin: this used to work --cabal-install-arg="-j$cpus"
16:56:39 <davesque> hakujin: where $cpus is set to the number of cores to use
16:56:58 <chrisdone> ski: (as in html one tends to read the tag before the attributes)
16:57:09 <davesque> hakujin: i’m guessing it still work on the latest version of cabal but i haven’t used cabal in a while :)
16:57:35 <lpaste> chrisdone pasted “monad instance” at http://lpaste.net/114331
16:58:07 <chrisdone> ski: does this remind you of a reader monad?
16:58:17 <ski> chrisdone : so .. i suppose `(with id [class_ "footer"] . with div_ [class_ "header"]) mempty' vs. `(with id [class_ "footer"] . (with div_ [class_ "header"] =<<) . return) mempty' would also display a discrepancy
16:58:47 <chrisdone> those are the same with this updated monad instance
16:59:11 <ski> chrisdone : *nod*, since they're equal in power, you can just as well use whichever is most convenient, if you're going to use any one of them
16:59:20 <chrisdone> right
17:00:30 <chrisdone> i wonder whether the `inner` actually needs to be passed in the >>=?
17:01:30 <ski> chrisdone : looks more like (for use for an output monad) pointwise defined monoid (which i suppose you could say is the environment monad)
17:01:33 <chrisdone> ski: fortunately it has zero effect on the benchmarks
17:02:48 <ski> chrisdone : hm, how does `with (\inner -> do p_ =<< return inner; p_ "y") [class_ "x"] mempty' compare to `with (\inner -> do p_ inner; p_ "y") [class_ "x"] mempty' ?
17:02:51 <chrisdone> ski: right. `with' is like 'local'
17:03:10 <athan> is there a way to create unlabeled options in optparse-applicative? By leaving out `short` and `long`, additional arguments are flagged as unrecognized :/
17:03:29 <chrisdone> those two are teh same
17:03:41 <Nazar> hey
17:03:43 <Nazar> hi
17:03:52 <chrisdone> hi =)
17:04:01 <Nazar> i'm nazar
17:04:17 <chrisdone> λ> with (\inner -> do p_ =<< return inner; p_ "y") [class_ "x"] mempty
17:04:17 <chrisdone> "<p class=\"x\"></p><p class=\"x\">y</p>"
17:04:17 <chrisdone> λ> with (\inner -> do p_ inner; p_ "y") [class_ "x"] mempty
17:04:17 <chrisdone> "<p class=\"x\"></p><p class=\"x\">y</p>"
17:04:47 <Nazar> are u trying to hack this room
17:04:57 <ski> chrisdone : hmm .. i don't see how `with' is like `local'. `local' doesn't have any corresponding (pre-applied) form
17:05:17 <ski> hello Nazar
17:05:18 <Nazar> is this room about haskell ?
17:05:20 <ski> yes
17:05:32 <Nazar> so no c++ ?
17:05:48 <ski> you can try `/join ##c++' for C++ ?
17:05:49 <benzrf> Nazar: i mean, you could try
17:06:05 <Nazar> '/join ##c++
17:06:17 <Enigmagic> smh
17:06:18 <shaykha> without the quote
17:06:24 <Nazar> ah
17:06:26 <Nazar> ok
17:06:33 <shaykha> though apparently it's a little full
17:07:41 <Nazar> no one's there
17:07:43 <ski> chrisdone : ok
17:08:32 <yunxing> Hi, is there any documentation/books that can let me understand how Haskell derive the type for something like '(.).(.)'. I know how to do it manually (it actually puzzled for a long time) but I just want to see what are the steps for a machine to do that.
17:08:36 <chrisdone> ski: ok? =)
17:08:36 <Nazar> could u name some good software written in haskel ?
17:08:37 <seancorfield> I'm a bit surprised to see three times as many people in #haskell as in ##c++
17:08:45 <ski> /join ##c++
17:08:53 <ski> Nazar : try typing that, exactly ^
17:08:53 <chrisdone> ski: i guess writer + censor is more corresponding
17:09:13 <ski> chrisdone : mm, `censor' maybe
17:09:33 <Dodek> yunxing: http://en.wikipedia.org/wiki/Hindley%E2%80%93Milner_type_system
17:09:51 <ski> Nazar : iow, you probably mistyped, and ended up in the wrong channel (or maybe wrong network ?)
17:10:09 <yunxing> Dodek: thanks for the pointer, I will take a look.
17:10:19 <Nazar> nope
17:11:11 <ski> yunxing : tried "Polymorphic Type Inference" by Michael I. Schwartzbach in 1995-03 at <http://web.cecs.pdx.edu/~antoy/Courses/TPFLP/lectures/TYPE/typeinf.p(s|df)> yet ?
17:12:21 <ski> Nazar : well, i didn't see you join ##c++ yet ..
17:12:49 <Darwin226> Is it possible to write a function repeatM :: Monad m => m a -> m [a] so that it works in any sensible way?
17:13:16 <Darwin226> I tried with "let repeatM ma = do { a <- ma; (a :) <$> repeatM ma }"
17:13:29 <ski> Darwin226 : you can write `repeatInterleaveIO :: m a -> m [a]' ..
17:13:36 <Darwin226> and that seems to fit the signature but I can't do stuff like take 5 <$> repeatM getLine
17:13:56 <Darwin226> ski: I don't get it
17:14:28 <ski> your suggested `repeatM' would work for some monads, but possibly now for the ones you wanted to use it for
17:14:32 <solirc> zmbmartin: sadly no
17:15:02 <Darwin226> ski: Where would it work though?
17:15:48 <Darwin226> ski: I'm actually having trouble understanding what's preventing me to use lazyness here
17:16:54 <ski> Darwin226 : in `(rho ->)',`Reader rho',`(omega,)',`Writer omega',partially in `State sigma',and i think also in `Lazy.ST s'
17:17:41 <ski> no, actually scratch the two last ones
17:17:57 <Darwin226> ski: The fact that you just named monads of the top of your head that you know would work with my definition is blowing my mind...
17:18:15 <Darwin226> ski: How man. How...
17:18:27 <ski> Darwin226 : do you know the `Maybe' monad ? the `Either epsilon' monad ?
17:18:38 <Darwin226> ski: Yeah. Sure
17:19:02 <josephle> the list of commonly used monads is not that large :)
17:19:22 <ToTheInternet> i have a BIG list of strings (several MB in size). Say "foo" `elem` list is true, how can I get n preceding and m subsequent elements from the list (for all occurences of "foo" in list)?
17:19:26 <Darwin226> josephle: The filtering of that list is the part that baffles me :D
17:19:44 <ski> Darwin226 : consider what `repeatM' must do for either of those. it must check for each time the argument action is executed whether it aborts with `Nothing'/`Left' or continues with `Just',`Right'
17:20:31 <ski> Darwin226 : so, `repeatM' will return `Nothing' / `Left ...' in case one of these invocations yield a `Nothing' or a `Left'
17:20:31 <Darwin226> ski: Oh! You're right! It doesn't make sense to expect it to lazily work since in the end it might turn out to be Nothing
17:21:19 <ski> Darwin226 : only if *all* (infinitely many) yield a `Just' / `Right' can `repeatM' return an infinite list (wrapped inside a `Just' / `Right') -- but this is uncomputable
17:21:45 <Darwin226> ski: Why doesn't it work for IO though?
17:22:05 <ski> Darwin226 : now, in this particular case, all the invoked actions will give the same result. but your `repeatM' doesn't know that, it will check and check and check and ...
17:22:37 <ski> Darwin226 : also, if you had used e.g. `StateT s Maybe' or `StateT s (Either e)' instead, then you could get different results on each invocation
17:23:23 <ski> Darwin226 : well, `IO' basically (roughly) includes the functionality of `State', so it's the same problem as with `State s'
17:23:41 <Darwin226> ski: What do you mean they'll give the same result? The behavior of "take 5 <$> repeatM getLine" that I expected is me having to input 5 lines and then getting a list of string wrapped in an IO monad
17:23:47 <batchm> this appears to work for IO.. but I am unsure whether it is a safe use of unsafeInterleaveIO
17:23:55 <batchm> repeatIO a = liftA2 (:) a (unsafeInterleaveIO $ repeatIO a)
17:24:40 <ski> Darwin226 : with `State s', you'll get an infinitely many finite pieces of pipeline that passes on the current state to the next action, and then you get an infinitely long pipeline that's supposed to transfer back the "final result" (*after* the "last" action finishes) -- but since it's infinitely long, nothing arrives
17:25:51 <Darwin226> ski: So basically I can't bind it until the whole pipeline is assembled
17:26:48 <ski> Darwin226 : this is because the result from the first executed action is passed *on* into the computation for the recursive call instead of "returned on the spot as the first result" (as would be the case with `Writer o') -- this is because `(a :) <$>' will conceptually add a `return (a : ...)' to the (nonexisting) *end* of the whole computation
17:28:08 <ski> Darwin226 : the conceptual behaviour of `take 5 <$> repeatM getLine' is to : (a) first read in an infinite number of lines; then (b) `take' the first `5' of those, ignoring (discarding) the rest
17:28:33 <monochrom> @hoogle repeatM
17:28:34 <lambdabot> No results found
17:28:50 <ski> Darwin226 : `f <$> action' will (in general) "perform all the actions of `action'" before post-processing the result value with `f'
17:29:31 <monochrom> is this true? repeatM x = sequence (repeat x)
17:29:41 <ski> for some monads, it actually won't always "perform all the actions of `action'" -- but that's special properties of those monads, you can't expect that in general
17:30:46 <Darwin226> ski: So tell me if I go it: In the signature m a -> m [a], the list part might as well be lazy, but the m wrapping over it needs to be fully constructed before I can fmap
17:30:57 <randomNick> In write yourself a scheme, ch2 exercise 7, they use a function named "parseDecimal", but I can't find a reference to it in the book or hoogle.
17:30:58 <randomNick> http://en.wikibooks.org/wiki/Write_Yourself_a_Scheme_in_48_Hours/Answers#Exercise_7
17:31:04 <monochrom> > evalState (take 5 <$> sequence (repeat get)) ()
17:31:06 <lambdabot>  [(),(),(),(),()]
17:31:08 <monochrom> :)
17:31:08 <ski> Darwin226 : sometimes we (sloppily) say that a monad where executing `f <$> action' will execute (the whole of) `action' is a "strict monad" .. but i think this is, strictly speaking, inappropriate terminology
17:31:13 <randomNick> Has anyone else came across this? Am I missing something?
17:31:19 <ski> monochrom : yes
17:31:53 <ski> Darwin226 : well, say "traversed" instead of "constructed", and i think you're closer
17:31:54 <monochrom> very few people know that Control.Monad.State redirects to Control.Monad.State.Lazy as opposed to Strict
17:32:31 * monochrom pulls out unsafeInterleaveIO for the IO case...
17:32:42 <ski> monochrom : ah, nice. i was pondering strict vs. lazy `ST', but didn't consider `State' :)
17:33:06 <monochrom> oh, ST.Lazy is even more weird. I still don't know its real rules.
17:33:30 <Darwin226> Very interesting stuff. Thanks for answering my question
17:33:31 <batchm> monochrom I mentioned a couple of minutes ago. is that a safe use of unsafeInterleaveIO?
17:33:37 <batchm> repeatIO a = liftA2 (:) a (unsafeInterleaveIO $ repeatIO a)
17:33:51 <monochrom> I don't know. it probably depends on what is "a"
17:34:08 <monochrom> ST.Lazy: http://lpaste.net/63925
17:35:23 <ski> Darwin226 : see what monochrom said, which contradicts what i said about `State' (it works ("partially", as i said initially, so i suppose i was right there) in `Lazy.State' because it's not strict in the pair of the result value and the final state. this means that it is able to "return early" each result element of the list. however the final state is still dead)
17:35:37 <monochrom> how about I just show examples of naughty uses of unsafeInterleaveIO: http://lpaste.net/77374
17:36:07 <ski> monochrom : istr you had some fun lpastes with `ST.Lazy' ?
17:36:13 <monochrom> Control.Monad.State.Strict will hang on repeatM get
17:36:17 <Darwin226> ski: Yeah. I think I understood that. At least on some level.
17:36:32 <monochrom> yes, a few lines above
17:40:42 <ski> batchm : what is an unsafe use of `unsafeInterleaveIO' ?
17:41:27 <batchm> no fucking clue! but it has a scary name
17:41:38 <batchm> and there is probably a reason for it
17:41:40 <ski> (otoh, `unsafeInterleaveST' really *is* unsafe (in the sense of breaking equational reasoning. not, i think, in the sense of possibly causing UB by itself))
17:42:53 <ski> batchm : it's hard to reason about. but then concurrency (scheduling and interleaving of threads, race conditions) in `IO' is also hard to reason about, so that's not by itself a reason for warranting `unsafe' in the name, imho
17:43:37 <haasn> safeUnsafeInterleaveIO
17:43:59 <Cale> Well, if you do something like v <- unsafeInterleaveIO (readIORef r), then the result can depend on the point at which v gets evaluated, which might change based on optimisations.
17:45:56 <ski> one could argue that to be able to *gainfully* (to which extent ?) be able to reason about `unsafeInterleaveIO', one must reach into forcing thunks and evaluation order (so operational semantics, rather than denotational semantics, or reasoning by axiomatic semantics), and that this is what constitutes the unsafeness, since those operational details aren't stable under equational reasoning
17:47:50 <EvanR> can unsafeInterleaveIO cause an exception to occur from pure code?
17:48:06 <exio4> unsafeInterleaveIO is how "lazy IO" worksw
17:48:28 <exio4> works *
17:49:14 <EvanR> it basically lets you do IO in pure code then
17:49:21 <ski> EvanR : probably, but so can `throw'
17:49:32 <EvanR> :t throw
17:49:33 <lambdabot> Exception e => e -> a
17:50:28 <batchm> what is your opinion of this? it is more of a case against lazy IO in general than just explicit use of unsafeInterleaveIO (
17:50:43 <ski> EvanR : operationally speaking, yes (in GHC). however what i'm claiming is that one could (denotationally, so to speak) blame this on `IO', thereby avoiding breakage of equational reasoning. whether this is *useful* is another question
17:50:50 <batchm> http://stackoverflow.com/questions/13263692/when-is-unsafeinterleaveio-unsafe    among other things:   "Modern sentiment about Lazy IO  ...is that Lazy IO is dangerous and a bad idea 99% of the time."
17:51:19 <monochrom> I am inclined against lazy I/O in general
17:51:23 <EvanR> amen
17:52:23 <EvanR> not totally orthogonal here is the inability to describe IO exceptions, or whatever throw does, in the type of pure code
17:52:27 <ski> batchm : i dispute the "dangerous", but think the "bad idea" is probably right
17:52:52 <EvanR> IO is dangerous
17:52:57 <EvanR> launchMissiles
17:52:58 <batchm> how is this true? "Remember that unsafeInterleaveIO is really just unsafePerformIO with a different type."
17:53:03 <ski> (of course, it also depends on what you include under "unsafe" or "dangerous")
17:53:56 <ski> batchm : it's clear that lazy I/O is hard to control, and hard to control failure modes for. perhaps in some cases you don't need that control. but in the cases where you do ..
17:54:21 <Luke> is there a recommended clean way to parse a number that's a string with Aeson? Like "123.45" (in correct JSON it shouldn't be quoted but it is)
17:54:37 <EvanR> in this channel i have noticed the unsafe family being ordered by "actually unsafe, dangerous, bad idea" in this increasing order: unsafeInterleaveIO, unsafePerformIO, and unsafeCoerce
17:55:01 <batchm> the only time that lazy IO ever bit me was when trying to write to the same file I previously readFile from. and there's an easy fix for that
17:55:02 <ski> EvanR : yes, `mapException' is also strange
17:55:10 <batchm> that was actually his example
17:55:39 <EvanR> Luke: hmm. try to parse it as a number
17:55:52 <Luke> I am. failing aeson parse
17:56:22 <EvanR> use a newtype on the number type you want and make a new fromJSON instance
17:56:34 <ski> batchm : presumably the mean that `unsafeInterleaveIO' is `return . unsafePerformIO' with a different type (though you probably also need `NOINLINE' pragmas and perhaps `unsafeDupablePerformIO' or something to pull it off)
17:56:54 <exio4> batchm: you can run IO-actions from pure code, that is what unsafePerformIO does
17:56:58 <exio4> http://dpaste.com/1NF7EKG
17:57:26 <ski> EvanR : well, `unsafePerformIO' implements `unsafeCoerce'
17:57:53 <exio4> how? using pointers hack or something clever?
17:58:00 <EvanR> ski: it does? despite that unsafeCoerce gets the rap as the most unsafe thing
17:58:01 <ski> EvanR : but with restricting to value polymorphism uses, i agree
17:58:55 <batchm> exio4 hmm, well I wouldn't say you are running them from pure functions. you are running them from IO block, that includes pure functions
17:59:26 <ski> EvanR : this is why the ML's have value restriction in the first place. to avoid being able to implement `unsafeCoerce', given polymorphism and they `Ref' construction. if you had had an `IO' monad for effects, that wouldn't be needed :)
17:59:41 <EvanR> batchm: you can basically do IO side-effects from evaluating pure expressions
17:59:42 <monochrom> unsafePerformIO lets you set up global variables. unsafeInterleaveIO doesn't.
17:59:58 <batchm> EvanR sure. but only when calling those functions in an IO block
18:00:06 <monochrom> the type matters. the different type weakens the power.
18:00:15 <EvanR> batchm: no
18:00:30 <batchm> EvanR how so?
18:00:30 <EvanR> they can be deeply nested inside the pure program
18:00:53 <ski> batchm : i think you should really only use `unsafePerformIO act' when `act' is conceptually equal to `return x' for some `x' (in which case the former call will return `x') -- otherwise treat it as UB
18:01:01 <monochrom> "unsafeInterleaveIO is unsafePerformIO with a different type" is of the same calibre as "a single-edged sword is a double-edged sword minus one edge".
18:01:29 <ski> batchm : the module-level-scope `IORef's is a problem that we perhaps should have a better solution for
18:01:32 <monochrom> tautological and obtuse
18:02:08 <EvanR> hehe, add proper global variables to haskell
18:02:15 <EvanR> and perhaps a goto
18:03:11 <batchm> EvanR but the initial call to a pure function had to come from an IO block.. so I don't see what is the big deal.. at least not to the extent for comparing it to unsafePerformIO
18:03:20 <ski> EvanR : define `topRef :: IORef a; topRef = unsafePerformIO (newIORef undefined)', then `unsafeCoerce :: a -> b; unsafeCoerce a = unsafePerformIO (writeIORef topRef a >> readIORef topRef)'
18:03:24 <batchm> s/for/of
18:03:46 <EvanR> batchm: thats not very valuable to say, given that no haskell anything can be evaluateed, as far as i know, with ghc, except in some possibly implicit "IO do block"
18:04:14 <trap_exit> let action = "defining a type class for which only one Instance is implemented". Question: is "action" good practice or "pedantic" ?
18:04:19 <EvanR> when you in ghci trying to evaluate a function thats not IO, you arent thinking that you are running IO, you are just looking at the printout of the result
18:04:23 <trap_exit> ANSWER ME! :-)
18:04:33 <EvanR> and you usually dont expect IO side effects
18:04:50 <EvanR> "all pure code is really just IO" is missing a point
18:05:07 <ski> batchm : the point is that we like being able to reason about and refactor our code (including the `IO'-less code, as well as the `IO'-ful code), using equational reasoning. using `unsafePerformIO' on an action that's not conceptually equal to `return x' for some `x' destroys that
18:05:20 <monochrom> trap_exit: it is neither. it is premature generalization.
18:05:30 <ski> (batchm : and when i say "we", i mean both we humans, and we compilers)
18:05:39 <batchm> I can see how this can take you by surprise in ghci, sure, because the IO block (sorta) is implicit
18:05:51 <Welkin> a compiler is not  being
18:05:53 <Welkin> it is a machine
18:06:12 <trap_exit> monochrom: that sounds about right
18:06:25 <ski> still compilers reason ("analyze") and refactor ("transform","improve/optimize") code
18:06:31 <chrisdone> nice, just shaved a ms from 6.67ms => 5.22ms (quoth criteron) by replacing a use of T.foldr with a custom T.break loop
18:06:38 <EvanR> batchm: your remark makes not much sense. "you can only use it always"
18:06:38 <chrisdone> wanna see?
18:06:51 <ToTheInternet> Hi. I was wondering if the following expression is evaluated in a lazy manner? namely, if [word] `existing` freq is not null, does map still evaluate the other arguments? someFunc (listToMaybe . dropWhile null $ map (`existing` freq) [[word], (edits1 word), (edits2 word)])
18:07:37 * hackagebot lens 4.6 - Lenses, Folds and Traversals  http://hackage.haskell.org/package/lens-4.6 (EricMertens)
18:07:46 <batchm> EvanR can you provide an example where this would be an issue? because I am not seeing it
18:07:46 <exio4> batchm: a function "f ∷ Int → Int" can now "have side-effects", if you use unsafeInterleaveIO, that is
18:07:47 <ski> monochrom : .. how about defining a type class for which one one instance can be implemented ?
18:08:13 <batchm> outside of calling "x + y" or similar in ghci and getting an effect when you didn't expect it
18:08:26 <EvanR> batchm: im saying going to length of making "unsafePerformIO only works in a do block" a true statement makes it vacuous
18:08:53 <EvanR> unsafePerformIO lets you do IO ... anywhere you want
18:08:56 <batchm> not sure why you're talking about unsafePerformIO.. the topic is unsafeInterleaveIO
18:08:58 <Welkin> ToTheInternet: you can test it yourself
18:09:00 <EvanR> thats not on "only" situation
18:09:15 <monochrom> that is criminal knowingly generalizing in vain.
18:09:29 <ski> torpet : it does not, because `listToMaybe' only looks at most one element of the list
18:09:46 <ski> monochrom : consider `class Foo' (no parameters) :)
18:10:06 <monochrom> how is Foo used?
18:10:38 <ToTheInternet> Welkin: i don't know how
18:10:49 <lpaste> chrisdone pasted “escapeMarkupEntities: T.foldr vs T.break” at http://lpaste.net/114332
18:10:50 <c74d> <http://haskell.org> is down?
18:10:56 <ski> exio4 : you can't define such an `f' at the module-global scope, without using `unsafePerformIO' or similar
18:10:59 <monochrom> "unsafePerformIO is like Digital Copy. it lets you watch the movie anywhere you want" :)
18:11:00 <ToTheInternet> ski: i assume your answer was meant for me
18:11:12 <ski> ToTheInternet : err, sorry, yes
18:11:22 <ski> torpet : sorry, ENICK
18:11:41 <exio4> ski: I meant if the parameter was "unsafeinterleaved" :P
18:12:10 <Welkin> ToTheInternet: try this
18:12:11 <EvanR> ski: would you say a global IORef, or TVar, or whatever is conceptually equal to return x for some x
18:12:32 <Welkin> > dropWhile null . map (++ [1]) $ [[], [3], undefined]
18:12:33 <lambdabot>  [[1],[3,1],*Exception: Prelude.undefined
18:12:36 <Welkin> so yes
18:13:00 <ToTheInternet> oh. :(
18:13:12 <monochrom> yeah, www.haskell.org looks down
18:13:32 <monochrom> the web server has a Friday evening date
18:13:42 <ToTheInternet> Welkin: this is not good, because (edits2 word) takes long and should only be evaluated when needed
18:13:46 <ski> exio4 : the point is that you need to execute `unsafeInterleaveIO ...' in an `IO'-action context to be able to do that. at which point i'm going to blame the execution of that `unsafeInterleaveIO ...' call for (a bit delayed) doing some I/O (cf. the situation with `forkIO') ;)
18:14:05 <ToTheInternet> Welkin: any way to make it lazy?
18:14:08 <monochrom> now, someone will yell at me "it is not a being, it is a machine, even just a program"
18:14:31 <monochrom> but I know that my compiler loves me only
18:14:33 <EvanR> machines are non-beings
18:14:36 <EvanR> they dont be
18:15:29 <exio4> ski: but any code that does actually anything, will end living in an IO-action
18:15:31 <ToTheInternet> > dropWhile null . map (++ [1]) $ [[], [3], [4]]
18:15:33 <lambdabot>  [[1],[3,1],[4,1]]
18:15:59 <ski> EvanR : i'd be prone to say no, because `IORef's have identity. declaring two separate `IORef Int's at module toplevel, you can distinguish them by `(==)', so they're not equal even though their bodies seem identical
18:16:01 <batchm> the difference between unsafePerformIO vs unsafeInterleaveIO is that the caller knows that pure function can trigger an effect.. because he is using unsafeInterleaveIO, either explicitly or by using built in lazy IO
18:16:07 <EvanR> exio4: a lot can be accomplished without IO
18:16:09 <batchm> with unsafePerformIO there is no way to tell
18:16:33 <monochrom> malloc'ed pointers want to be free
18:16:37 <Welkin> the origin of the word "robot" is a slavic word for "slave" or "servitude"
18:16:55 <EvanR> ski: ok, so the rub is some outside force needs to provide a unique name to the x
18:17:04 <EvanR> which isnt referentially transparent
18:17:06 <merijn> oh, we're discussing unsafe IO functions? Did anyone mention accursedUnutterablePerformIO yet? :p
18:17:29 <ski> @wiki Top level mutable state
18:17:29 <lambdabot> http://www.haskell.org/haskellwiki/Top_level_mutable_state
18:17:52 <exio4> EvanR: the only thing that the runtime will "run" is the main
18:17:53 <Welkin> ToTheInternet: that depends
18:17:56 <ski> (try <https://web.archive.org/web/20140703132612/http://www.haskell.org/haskellwiki/Top_level_mutable_state>, since <http://www.haskell.org> seems like it's down for the moment)
18:18:05 <ski> EvanR : see that ^, if you haven't already
18:18:14 <Welkin> ToTheInternet: do you need to map the functions over the entire list to determine whether they need to be dropped?
18:18:18 <EvanR> exio4: ignore haskells style for a minute and think about systems that dont even support IO
18:18:42 <ToTheInternet> > listToMaybe . dropWhile null . map (++ [1]) $ [[], [3], undefined]
18:18:43 <lambdabot>  Just [1]
18:19:09 <ToTheInternet> no exception, listToMaybe seems to make it lazy? (what ski said)
18:19:12 <ski> exio4 : yes, the the side-effects performed by `unsafePerformIO' isn't "anchored" anywhere to the "chain" of `IO'-actions that's rooted in `main'
18:19:12 <exio4> EvanR: wasn't the dicussion about Haskell?
18:19:33 <merijn> ToTheInternet: Nothing is "made" lazy, everything is always lazy unless made strict
18:19:40 <ski> exio4 : not so with `unsafeInterleaveIO'. this makes a difference
18:19:59 <EvanR> exio4: i dont care, "a lot can be accomplished without IO", also im dismissing "meh all your pure code is IO code"
18:20:15 <ToTheInternet> merijn: i see. so not using ListToMaybe makes it strict
18:20:26 <merijn> exio4: More simply, unsafeInterleaveIO is guaranteed to run only once due to it's original IO (i.e. not getting inlined anywhere, etc.)
18:20:46 <Welkin> no, everything is lazy in haskell unless explicitly specified not to be
18:20:47 <merijn> exio4: GHC can happily inline and duplicate unsafePerformIO, causing the IO to happen multiple times
18:20:48 <exio4> ah, didn't know about that
18:21:23 <merijn> exio4: So unsafeInterleavIO only lets you lie about *when* the IO happens, not whether it happens at all
18:21:40 <ToTheInternet> Welkin: in my modified example you posted, it seems to be lazy, right? undefined is not evaluated.
18:21:41 <exio4> (that unsafeInterleaveIO wouldn't allow IO actions running two times)
18:22:31 <centrinia> Is there a language extension has something like [[ f, a1, a2 ]] as syntactic sugar for  pure f <*> a1 <*> a2 ?
18:22:41 <merijn> ToTheInternet: Why would not using listToMaybe make it strict?
18:22:51 <merijn> centrinia: You could use quasiquotes for that
18:22:55 <merijn> centrinia: Also, checkout she
18:23:08 <merijn> @hackage she
18:23:09 <lambdabot> http://hackage.haskell.org/package/she
18:23:26 <ski> monochrom : "how is Foo used?" -- i'm not quite sure. perhaps like `foo :: (Foo => ...) -> ...', maybe via some magic (perchance cf. `Data.Reflection')
18:24:08 <chrisdone> Welkin: re 'robot' being a slavic word for slave; ironically, "slave" comes from "slavic"… the Slavs know a thing or two about being slaves before the middle ages
18:24:15 <Welkin> centrinia: Data.Foldable.asum
18:24:32 <Welkin> :t asum
18:24:33 <lambdabot>     Not in scope: ‘asum’
18:24:33 <lambdabot>     Perhaps you meant one of these:
18:24:33 <lambdabot>       ‘F.asum’ (imported from Data.Foldable),
18:24:39 <Welkin> :t Data.Foldable.asum
18:24:40 <ski> merijn : good points
18:24:40 <lambdabot> (Foldable t, Alternative f) => t (f a) -> f a
18:24:50 <ToTheInt1rnet> merijn: these are the 2 examples that made me think that. i guess my wording is just wrong?
18:24:52 <ski> @karma+ merijn
18:24:52 <lambdabot> merijn's karma raised to 32.
18:24:54 <merijn> chrisdone: Does/will ghci-ng generate ctag files?
18:24:57 <ToTheInt1rnet> > dropWhile null . map (++ [1]) $ [[], [3], undefined]
18:24:58 <lambdabot>  [[1],[3,1],*Exception: Prelude.undefined
18:25:04 <ToTheInt1rnet> > listToMaybe . dropWhile null . map (++ [1]) $ [[], [3], undefined]
18:25:05 <lambdabot>  Just [1]
18:25:18 <merijn> ToTheInt1rnet: Running an expression in lambdabot/ghci *implicitly* prints the result
18:25:35 <merijn> ToTheInt1rnet: Without listToMaybe, the result includes "undefined" so the print function crashes when it reaches that
18:26:09 <merijn> ToTheInt1rnet: This has nothing to do with laziness, but with lambdabot/ghci implicitly forcing the entire computation when printing
18:26:19 <chrisdone> merijn: i didn't write anything for that -- how's the existing ghci ctags support?
18:26:46 <ToTheInt1rnet> merijn: i'm not sure i fully understand. with listToMaybe, undefined ++ [1] is not evaluated, is it?
18:26:50 <merijn> ToTheInt1rnet: (How could it print a list without the implicitly evaluating it?)
18:26:50 <ski> @hackage applicative-quoters  -- centrinia
18:26:51 <lambdabot> http://hackage.haskell.org/package/applicative-quoters  -- centrinia
18:27:22 <centrinia> Hmm.
18:27:30 <batchm> > listToMaybe (undefined ++ [1])
18:27:31 <lambdabot>  *Exception: Prelude.undefined
18:27:38 <merijn> chrisdone: Well, tbh I don't really care about ctags per se, just the ability to jump to/show a definition
18:27:47 <batchm> > listToMaybe ([1] ++ undefined)
18:27:48 <lambdabot>  Just 1
18:28:01 <EvanR> accursedUnutterablePerformIO, accursedUnutterablePerformIO, what happens when i say it once more
18:28:12 <ski> don't !
18:28:16 <merijn> chrisdone: hdevtools can do that right now, but only for cabal based projects, so it's no use for GHC (where I need it most :))
18:28:32 <merijn> ToTheInt1rnet: The result of listToMaybe doesn't need to evaluate "undefined ++ [1]", so it doesn't
18:28:58 <ski> it'll form a bubble of lower than zero-point energy vacuum that'll spread and engulf the universe (or at least the `IO' part of it)
18:28:58 <chrisdone> merijn: i have jump to def in emacs via ghci-ng, at any rate via :loc-at, so probably when i add unix domain socket support it can be used from vim
18:29:04 <chrisdone> merijn: are you able to load GHC into ghci?
18:29:09 <ToTheInt1rnet> merijn: so that's why i said that listToMaybe made it lazy, which is bad wording i guess
18:29:24 <merijn> ToTheInt1rnet: listToMaybe only looks at the first item in the list, therefore it only evaluates the first item in the list.
18:29:30 <EvanR> hahaha
18:29:34 <merijn> chrisdone: What do you mean by "load GHC into vim"?
18:29:36 <chrisdone> ski: in short: cthulhu f'tag'n
18:29:53 <chrisdone> merijn: i didn't say those words ( ͡° ͜ʖ ͡°)
18:30:12 <ToTheInt1rnet> merijn: got it :)
18:30:15 * ski . o O ( <https://en.wikipedia.org/wiki/Blum-Blum-Shub> -- IA IA ! )
18:30:20 <batchm> listToMaybe is what head should have been
18:30:38 <EvanR> lol aUPIO (IO m) = case m realWorld# of (# _, r #) -> r
18:30:39 <Welkin> there is a safeHead I believe
18:30:42 <Welkin> that does the same thing
18:30:43 <merijn> chrisdone: oh, I can't read :D
18:30:54 <merijn> chrisdone: Lemme try :p
18:30:58 * centrinia . o O ( http://en.wikipedia.org/wiki/Lenstra%E2%80%93Lenstra%E2%80%93Lov%C3%A1sz_lattice_basis_reduction_algorithm )
18:31:20 <chrisdone> =)
18:31:28 <merijn> chrisdone: ugh, "fatal error: 'dist/build/autogen/cabal_macros.h' file not found"
18:31:37 <chrisdone> merijn: that's an easy one to fix
18:31:38 <chrisdone> umm
18:31:53 <merijn> oh, that might be me
18:31:53 <chrisdone> :set -optP-include -optPdist/build/autogen/cabal_macros.h
18:31:59 <chrisdone> oh
18:32:03 <chrisdone> the file not found. yeah
18:32:17 <chrisdone> cabal configure?
18:32:19 <merijn> chrisdone: I had that option, that's why it failed :p
18:32:28 <merijn> chrisdone: Eh, ghc doesn't have a cabal, does it?
18:32:30 * chrisdone . o O ( can ghc be cabal configured? )
18:32:42 <merijn> Nope
18:33:08 <merijn> Seems it's unable to find header files
18:33:22 <chrisdone> try :set -I or w/e?
18:34:26 <merijn> I needed to specify "-optP-include -optPcompiler/HsVersions.h"
18:34:34 <chrisdone> not too bad
18:34:42 <merijn> It seems a bit inconvenient if I need to specify all header files explicitly :\
18:34:54 <chrisdone> stick 'em in a .ghci file
18:35:02 <chrisdone> or are they static flags?
18:35:12 <chrisdone> i think only dynamic flags can be specified in .ghci
18:35:20 <merijn> No idea
18:35:25 <chrisdone> anyhoo
18:35:30 <chrisdone> run :set +c and load a module
18:35:41 <chrisdone> it should say something about generating info for n modules
18:35:48 <merijn> Additionally I have .ghci disabled outside $HOME
18:36:20 <merijn> chrisdone: That's a ghci-ng option?
18:36:23 <chrisdone> yeah
18:36:38 <chrisdone> c for 'collect info'
18:36:50 <merijn> I haven't bothered installing it yet, I was just curious ;)
18:37:06 <chrisdone> (°¬°)
18:37:26 <chrisdone> but yeah, if ghci can load it then probably ghci-ng can generate info for it
18:37:59 <merijn> chrisdone: I'm keeping a close eye on it, since a more portable/reliable replacement for hdevtools would be nice. (Currently hdevtools is linked to a different cabal, so it;s ability to introspect my cabal settings is limited)
18:38:28 <chrisdone> right
18:38:41 <chrisdone> i had similar issues with ghc-server… pinned to a specific cabal
18:38:56 <chrisdone> cabal repl + ghci-ng = winrar
18:40:19 <mkscrg> noticed something weird with DatatypeContexts today. code compiled with cabal seems to have that extension enabled implicitly
18:40:23 <mkscrg> anybody know about that?
18:40:36 <mkscrg> e.g.
18:43:28 <merijn> mkscrg: cabal defaults to Haskell98
18:43:36 <merijn> mkscrg: DatatypeContext were part of Haskell98
18:43:44 <merijn> GHC defaults to haskell2010
18:43:58 <merijn> DatatypeContexts were removed from haskell2010 on account of being dumb
18:44:04 <mkscrg> merijn: aha! that makes a lot of sense
18:44:19 <mkscrg> thanks
18:44:31 <merijn> mkscrg: Add "Default-Language:     Haskell2010"
18:44:35 <merijn> To your cabal file
18:44:42 <mkscrg> will do
19:17:40 * hackagebot trace 0.1.0.3 - A monad transformer for tracing provenience of errors  http://hackage.haskell.org/package/trace-0.1.0.3 (JonSterling)
19:35:19 <trap_exit> what is the cabal equiv of "make clean" ? I need to clean up a repo before puttig it in git
19:35:41 <exio4> cabal clean?
19:36:32 <trap_exit> hmm
19:36:45 <trap_exit> is there a way of phrasing that answer that does not make me look like an idiot? :-)
19:36:56 <trap_exit> like maybe somethign that takes atleast 2 lines
19:37:35 <trap_exit> #!/bin/bash
19:37:36 <trap_exit> cabal clean
19:37:42 <trap_exit> there we go :-)
19:38:48 <Javran> remember to chmod +x
19:39:45 <trap_exit> touch clean.sh; echo "#!/bin/bash" >> clean.sh; echo "cabal clean" >> clean.sh; chmod 755 clean.sh; ./clean.sh
19:39:49 <trap_exit> okay, much happier now :-)
19:47:56 <Javran> trap_exit: but that command isn't idempotent
19:48:26 <trap_exit> Javran: so you're suggesting preprending it with "rm -rf clean.sh" ?
19:48:39 <Javran> trap_exit: Maybe
19:49:06 <trap_exit> Just Ok or Nothing ?
19:49:24 <Javran> Just Ok
20:00:37 <hakujin> haskell.org struggling for anyone else?
20:02:02 <trap_exit> nope
20:02:05 <trap_exit> not using it right now
20:02:18 <trap_exit> haskell.org is both running rile and struggling until I try to cabal install
20:05:25 <hakujin> is there an existing version of IO (Maybe a) -> IO (Maybe a) -> IO (Maybe a), acting like mplus or <|> but doesn't evaluate the second IO action if the first is Just?
20:05:39 <hakujin> the implementation is trivial but I don't know if I'm reinventing the wheel
20:06:52 <trap_exit> so it's like a short circuit "or" ?
20:06:58 <hakujin> basically yep
20:07:20 <simpson> :t liftM2 (<|>)
20:07:21 <lambdabot> (Monad m, Alternative f) => m (f a) -> m (f a) -> m (f a)
20:07:22 <trap_exit> so it's like "fmap >>"
20:07:31 <trap_exit> nm, "fmap >>" is wrong
20:08:31 <simpson> hakujin: ^^^ That's exactly what you want, right?
20:09:33 <hakujin> simpson: the types are correct but if you check the output, the second IO action is evaluated for side effects before the alternative instance can be resolved
20:09:50 <hakujin> so the final return type is correct but the side effects aren't
20:09:54 <simpson> @src liftM2
20:09:54 <lambdabot> liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
20:09:59 <fresheyeball> hey folks
20:10:02 <simpson> Ah.
20:10:37 <fresheyeball> I am still a noob (after 4 months) and have a simple question
20:10:54 <fresheyeball> what is a practice use for <+> ?
20:10:57 <fresheyeball> arrowplus
20:11:06 <fresheyeball> I understand <<< and >>>>
20:11:17 <fresheyeball> but thats it in Control.Arrow so far
20:11:28 <kadoban> :t (<+>)
20:11:29 <lambdabot>     Ambiguous occurrence ‘<+>’
20:11:29 <lambdabot>     It could refer to either ‘Control.Arrow.<+>’,
20:11:29 <lambdabot>                              imported from ‘Control.Arrow’ at /home/lambda/.lambdabot/State/L.hs:42:1-20
20:11:41 <kadoban> :t Control.Arrow.(<+>)
20:11:42 <lambdabot> Not in scope: data constructor ‘Control.Arrow’
20:11:42 <lambdabot>     Ambiguous occurrence ‘<+>’
20:11:42 <lambdabot>     It could refer to either ‘Control.Arrow.<+>’,
20:11:55 * kadoban gives up
20:11:55 <simpson> :t (Control.Arrow.<+>)
20:11:56 <lambdabot> ArrowPlus a => a b c -> a b c -> a b c
20:12:10 <kadoban> Oh
20:12:31 <fresheyeball> its a monoid on arrows
20:12:50 <simpson> I think that you understand it, then.
20:13:01 <fresheyeball> I promise I don't
20:13:32 <fresheyeball> knowing that its a monoid on arrows tells me nothing about when it appropriate to use
20:13:44 <fresheyeball> and little about its actual definition
20:14:58 <voutasaurus> ...Wouldn't that be dependent on the type of the arrow?
20:15:09 <fresheyeball> sure
20:15:16 <fresheyeball> ok
20:15:24 <fresheyeball> I'd didn't know there where types of arrows
20:16:20 <voutasaurus> I could be wrong here, but arrow is a typeclass right?
20:16:28 <mungojelly> well i don't know what arrows are at all so i guess you've got me beat
20:16:39 <waynr> can anyone explain the difference between identifiers that start with '$' and those that start with '@' in Alex files?
20:16:45 <mungojelly> "<+>" is very difficult to search for, both google and bing failed on it completely :/
20:17:19 <athan> fresheyeball: o/
20:17:43 <simpson> Yes. Arrow is a typeclass.
20:17:45 <waynr> what i have determined from reading the alex docs is that they are macros, but I haven't figured out the difference between them yet
20:17:49 <fresheyeball> its in here http://hackage.haskell.org/package/base-4.7.0.1/docs/src/Control-Arrow.html#%3C%2B%3E
20:17:55 <voutasaurus> oh. hold up. it taks three arguments so the a is the + function.
20:17:56 <fresheyeball> its got an instance as well
20:18:01 <fresheyeball> MonadPlus
20:18:18 <fresheyeball> (<+>) takes 2 arguments
20:18:34 <fresheyeball> athan? are you the athan I know?
20:18:39 <athan> fresheyeball: check this out: https://www.haskell.org/haskellwiki/HXT
20:18:48 <athan> fresheyeball: No, the other one :P
20:19:04 <voutasaurus> oh sorry i got confused with the a b c
20:19:11 <fresheyeball> I've got no idea how many haskelling athans there are
20:19:19 <fresheyeball> :P
20:19:33 <athan> fresheyeball: When viewed as list-indexed functions `a -> [a]`, <+> becomes union
20:19:43 <athan> fresheyeball: Yeah we're a bunch of clones
20:20:19 <athan> fresheyeball: Where the arrows are the `a -> [a]` functions themselves
20:21:23 <fresheyeball> crap hoogle is down
20:23:12 <athan> fresheyeball: I've been disappointed by the type inference on arrows before too, though
20:23:39 <fresheyeball> what is an example of an `a -> [a]` function?
20:24:00 <fresheyeball> append x xs = [x] ++ xs ?
20:24:01 <athan> fresheyeball: querying
20:24:07 <fresheyeball> ok
20:24:19 <athan> it's like a more general maybe, too
20:24:51 <newsham> apprendre x xs = [x] ++ xs
20:24:52 <athan> with hxt, `a -> [a]` represents a possibly empty query (also with possibly multiple results)
20:25:01 <newsham> oops wrong channel
20:25:06 <fresheyeball> ok
20:25:25 <athan> <+> is like a boolean `or`
20:25:30 <athan> or like a union of the results
20:25:43 <fresheyeball> so lets say we have `query <+> query`
20:25:43 <athan> fresheyeball: composition is like boolean `and`
20:26:00 <newsham> > return 1 :: [Int]   -- example of   Int -> [Int]
20:26:02 <lambdabot>  [1]
20:26:03 <athan> (the arrows can also be seen as filters)
20:26:41 <athan> :t isA
20:26:42 <lambdabot>     Not in scope: ‘isA’
20:26:42 <lambdabot>     Perhaps you meant ‘iso’ (imported from Control.Lens)
20:26:50 <fresheyeball> can I see a concrete example?
20:27:04 <athan> @let isA p x = if (p x) then [x] else []
20:27:05 <lambdabot>  Defined.
20:27:15 <newsham> ?type repeat
20:27:16 <lambdabot> a -> [a]
20:27:19 <newsham> ?type replicate
20:27:20 <lambdabot> Int -> a -> [a]
20:27:26 <newsham> some others that can do a -> [a]
20:27:46 <athan> @let f <+> g x = f x ++ g x
20:27:46 <lambdabot>  Parse failed: Parse error in pattern: g
20:27:48 <newsham> > replicate 5 "x"
20:27:49 <lambdabot>  ["x","x","x","x","x"]
20:27:54 <athan> @let f <+> g = \x -> f x ++ g x
20:27:56 <lambdabot>  Defined.
20:28:37 <athan> @let f >>> g = \x -> fmap g $ f x
20:28:38 <lambdabot>  Defined.
20:29:49 <athan> fresheyeball: > (isA (>5)) >>> (isA (<=20)) $ 8
20:30:17 <athan> > (isA (>5)) >>> (isA (<=20)) $ 8
20:30:18 <athan> :S
20:30:18 <athan> (isA (>5)) >>> (isA (<=20)) $ 8
20:30:19 <lambdabot>  Ambiguous occurrence ‘>>>’
20:30:19 <lambdabot>  It could refer to either ‘L.>>>’, defined at L.hs:184:3
20:30:19 <lambdabot>                        or ‘Control.Category.>>>’,
20:30:19 <lambdabot>                           imported from ‘Control.Arrow’ at L.hs:42:1-20
20:30:19 <lambdabot>                           (and originally defined in ‘base:Control.Category’)
20:30:31 <athan> internet borked?
20:30:40 * athan is testing the lines
20:30:42 <newsham> you reused an already used name (>>>)
20:30:51 <athan> awwwww
20:31:15 <athan> (isA (>5)) <+> (isA (<=20)) $ 8
20:31:16 <athan> > (isA (>5)) <+> (isA (<=20)) $ 8
20:31:17 <lambdabot>  Ambiguous occurrence ‘<+>’
20:31:17 <lambdabot>  It could refer to either ‘L.<+>’, defined at L.hs:183:3
20:31:17 <lambdabot>                        or ‘Control.Arrow.<+>’,
20:31:17 <lambdabot>                           imported from ‘Control.Arrow’ at L.hs:42:1-20
20:31:17 <lambdabot>                        or ‘Text.PrettyPrint.HughesPJ.<+>’,
20:31:22 <athan> >:S
20:31:28 <geekosaur> heh
20:31:40 <athan> fresheyeball: You get the idea, right?
20:31:45 <fresheyeball> I don't understand
20:32:24 <athan> fresheyeball: What are you trying to understand?
20:33:53 <fresheyeball> hang on
20:33:55 <fresheyeball> I am re-reading
20:35:13 <fresheyeball> ok
20:35:54 <athan> o.o
20:36:33 <fresheyeball> ((isA (>5)) <+> (isA (<=20)) $ 8) == [8]
20:36:35 <fresheyeball> ??
20:37:03 <athan> yep!
20:37:11 <fresheyeball> ok
20:37:15 <athan> fresheyeball: What would -3 or 21 be?
20:37:26 <fresheyeball> []
20:37:32 <athan> think again!
20:37:38 <fresheyeball> ok sec
20:37:40 <athan> remember this is union
20:37:42 <athan> <+>
20:38:27 <athan> @unset >>>
20:38:28 <lambdabot> Unknown command, try @list
20:38:30 <athan> shoot
20:38:46 <fresheyeball> [-3] or [21]
20:38:51 <athan> yep!
20:38:54 <fresheyeball> ok
20:39:10 <fresheyeball> so its a weird fucked up conditional thingy
20:39:17 <athan> yep, exactly
20:39:29 <athan> just wait until you see the binary logical operators
20:39:33 <athan> :t when
20:39:34 <lambdabot> Monad m => Bool -> m () -> m ()
20:39:37 <athan> erm
20:39:51 <athan> :t Control.Arrow.ArrowIf.guards
20:39:52 <lambdabot> Not in scope: ‘Control.Arrow.ArrowIf.guards’
20:39:58 <athan> shoot
20:40:05 <fresheyeball> so wait a sec
20:40:07 <fresheyeball> in the last example
20:40:21 <athan> fresheyeball: What stuff are you trying to learn?
20:40:25 <athan> oh hm?
20:40:28 <fresheyeball> where a single arguments is applied to two a -> [a]
20:40:43 <fresheyeball> the <+> is doing ++ on the results
20:40:53 <athan> yep
20:41:12 <fresheyeball> (f <+> g = \x -> f x ++ g x)
20:41:18 <fresheyeball> what is this an instance of?
20:41:34 <fresheyeball> is that
20:41:48 <fresheyeball> instance ArrowPlus [] ?
20:43:55 <fresheyeball> oh wait
20:44:10 <fresheyeball> how is <+> a conditional thingy? Isn't it more like `on`?
20:44:40 <fresheyeball> or is using it as a conditional, just an example usage?
20:45:40 <athan> o.o
20:45:40 <athan> monoid?
20:45:40 <athan> that's where arrowif get's 1/2 it's power
20:45:40 <athan> gets*
20:45:41 <athan> @hoogle a -> [a]
20:45:44 <lambdabot> Prelude repeat :: a -> [a]
20:45:44 <lambdabot> Data.List repeat :: a -> [a]
20:45:44 <lambdabot> Test.QuickCheck.Arbitrary shrinkNothing :: a -> [a]
20:45:45 <athan> fresheyeball: instance Monoid b => Monoid (a -> b) -- Defined in Data.Monoid
20:46:03 <Blizzy> could anyone explain the 'sortBy' and 'comparing' in sortme = sortBy (comparing (map toLower))?
20:47:17 <athan> fresheyeball: It's not like on. `on` works with both boolean "predicates" (functions of :: a -> Bool) and lists. <+> is more general
20:47:33 <fresheyeball> :t on
20:47:33 <athan> <+> _should_ be seen as the union of two functions
20:47:34 <lambdabot> (b -> b -> c) -> (a -> b) -> a -> a -> c
20:47:48 <athan> fresheyeball: That's also the K combinator
20:47:50 <athan> by bad
20:47:52 <athan> my*
20:48:22 <athan> actually holy butts, you might be (*pfff*) ... on .... to something here
20:49:48 <athan> fresheyeball: The crazy part is that `const` makes an identity for that
20:49:51 <athan> er shoot
20:50:02 <athan> not the K combinator, K is const. S is on.
20:50:53 <AnalogFile> haskell.org is definitively down
20:51:39 <gamegoblin> Anyone have issues with ghc after updating to OS X Yosemite?
20:52:27 <fresheyeball> so <+> is associative but not commutative right?
20:52:31 <AnalogFile> not yet updated to Yosemite
20:52:44 * hackagebot stripe-haskell 0.1.0.6 - Stripe API for Haskell  http://hackage.haskell.org/package/stripe-haskell-0.1.0.6 (DavidJohnson)
20:53:35 <athan> fresheyeball: Technically, yep
20:57:02 <voutasaurus> so <+> doesn't have to be a union like operator. it can be a concatenation like operator. which is actually how you used it athan.
20:58:16 <athan> voutasaurus: ? Can you show me the path to your knowledge? :)
20:59:09 <Kaidelong> When we have IORef t for some unboxed t, does it still behave as a reference?
20:59:41 <Kaidelong> or will there there actually be some copy-on-write semantics going on?
21:05:20 <solrize> > let op1 xs ys = [[x*y | x<-xs] | y<-ys]
21:05:22 <lambdabot>  not an expression: ‘let op1 xs ys = [[x*y | x<-xs] | y<-ys]’
21:05:42 <solrize> let op1 xs ys = [[x*y | x<-xs] | y<-ys] in op [1,2,3] [1,5,10,20]
21:05:54 <solrize> > let op1 xs ys = [[x*y | x<-xs] | y<-ys] in op1  [1,2,3] [1,5,10,20]
21:05:55 <lambdabot>  [[1,2,3],[5,10,15],[10,20,30],[20,40,60]]
21:06:21 <solrize> let op2 = map . flip (map . (*)) in op2 [1,2,3] [1,5,10,20]
21:06:28 <solrize> > let op2 = map . flip (map . (*)) in op2 [1,2,3] [1,5,10,20]
21:06:29 <lambdabot>  [[1,2,3],[5,10,15],[10,20,30],[20,40,60]]
21:06:47 <solrize> so how does an opponent of listcomps write that function ?
21:08:15 <solrize> @pl let op1 xs ys = [[x*y | x<-xs] | y<-ys] in op1  [1,2,3] [1,5,10,20]
21:08:15 <lambdabot> [[x * y | x <- [1, 2, 3]] | y <- [1, 5, 10, 20]]
21:08:32 <solrize> @pl let op1 xs ys = [[x*y | x<-xs] | y<-ys]
21:08:32 <lambdabot> (line 1, column 40):
21:08:32 <lambdabot> unexpected end of input
21:08:32 <lambdabot> expecting variable, "(", operator, ";" or "in"
21:08:39 <solrize> @pl  op1 xs ys = [[x*y | x<-xs] | y<-ys]
21:08:39 <lambdabot> op1 = flip flip [] . ((:) .) . (<-) . (| y) . return . (x *) . ((y | x) <-)
21:09:01 <solrize> :t (<-)
21:09:02 <lambdabot> parse error on input ‘<-’
21:12:49 <vanila> > do b <- [1,5,10,20] ; return (map (b*) [1,2,3])
21:12:51 <lambdabot>  [[1,2,3],[5,10,15],[10,20,30],[20,40,60]]
21:13:59 <athan> :t ((y | x) <-)
21:14:00 <lambdabot> parse error on input ‘|’
21:14:16 <athan> solrize: wut
21:15:06 <solrize> athan that was @pl output. i think it doesn't really know about listcomps
21:16:22 <solrize> @pl op3 xs ys = map (\y->map (y*) xs) ys
21:16:22 <lambdabot> op3 = map . flip (map . (*))
21:17:21 <athan> ahh makes sense
21:24:00 <AnalogFile> I'm wondering what they are doing on the servers. site keeps going up and down like a yo-yo
21:38:14 <ski> @undo op1 xs ys = [[x*y | x<-xs] | y<-ys]
21:38:15 <lambdabot> op1 xs ys = concatMap (\ y -> [concatMap (\ x -> [x * y]) xs]) ys;
21:38:24 <ski> i wonder why it adds a `;'
21:52:22 <jle`> @undo op1 xs ys = do y <- ys; x <- xs; [x*y]
21:52:22 <lambdabot> op1 xs ys = ys >>= \ y -> xs >>= \ x -> [x * y];
21:52:36 <jle`> there it is again :o
21:53:58 <jle`> hm;
21:57:47 * hackagebot stripe-haskell 0.1.1.0 - Stripe API for Haskell  http://hackage.haskell.org/package/stripe-haskell-0.1.1.0 (DavidJohnson)
21:58:16 <dmj`> Fuuzetsu: ping
21:59:11 <ski> jle` : it hinders composing with `pl' ..
22:07:47 * hackagebot netwire-input 0.0.3 - Input handling abstractions for netwire  http://hackage.haskell.org/package/netwire-input-0.0.3 (Mokosha)
22:09:31 <sshine> I would like to 'mapM f xs' where 'f x = do { ys <- get; case ys of y:ys' -> put ys'; return (f x y) }'. i.e. use a State as a kind of stream of inputs...
22:09:41 <sshine> but I'm thinking maybe there's a better monad to do this than State?
22:10:30 <sshine> err, modulo the error in that code.
22:14:54 <ski> @hackage monad-supply
22:14:54 <lambdabot> http://hackage.haskell.org/package/monad-supply
22:22:40 <rhodesd> Is there a way to tell GHC to preserve type synonyms when emitting error messages?
22:24:04 <sshine> ski, excellent, thanks :)
22:33:18 <davidthomas> Is there any actual difference in denotation between "variadic" and "polyvariadic"?
22:35:11 <mgsloan> I imagine someone could try to make the distinction that "polyvariadic" means the arguments are polymorphic in some way, rather than having a variadic function where the arguments are monomorphic
22:36:20 <mgsloan> Seems a bit of an abuse, though, as in that case you'd probably be better off with a function taking a list, at least in the case of a variadic function with monomorphic arguments
22:39:21 * ski can't remember hearing "polyvariadic" before
22:39:40 <davidthomas> mgsloan: In google searches, the biggest difference I seem to be finding is "variadic when you're talking about C, polyvariadic when you're talking about Haskell"
22:39:56 <davidthomas> but no references to either mention the other :-P
22:40:31 <ski> .. then there's also stuff like "polyvariant" (but that's another thing)
22:40:59 <mgsloan> Yeah, maybe it's just "polyvariadic" because it's varaidic functions implemented via polymorphism, rather than an explicit language feature
22:41:02 <mgsloan> dunno
23:30:23 <Fuuzetsu> @tell dmj` pong
23:30:24 <lambdabot> Consider it noted.
23:46:05 <trap_exit> does haskell have any ffi for calling python code / readinpython pickled data ?
