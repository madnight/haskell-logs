00:12:01 <merijn> Dongyancai: I recommend reading the docs more carefully next time :)
00:12:04 <merijn> Dongyancai: "Entries in the call stack correspond to SCC annotations, so it is a good idea to use -fprof-auto or -fprof-auto-calls to add SCC annotations automatically."
00:35:34 <Dongyancai> merijn: I have added the SCC and modified the code as http://lpaste.net/113628 referring https://www.haskell.org/ghc/docs/6.12.1/html/users_guide/profiling.html#id3003735 , but it still not working. Is there any examples? I only got the API itself and no any code using it.
00:39:24 <merijn> Dongyancai: Careful, that's the 6.12 docs, those are pretty ancient!
00:40:27 <merijn> Dongyancai: tbh, I haven't used stack traces before, perhaps you need to specify runtime options to get output, but I'm not sure
00:43:20 <merijn> Try compiling with "-rtsopts" and running with "+RTS -xc", although that's random guessing on my side. I need to run soon, so I dunno exactly how to do this
00:45:54 <Dongyancai> merijn, thank you, another one gave me an URL of a japanese blog, and it works.
00:46:45 <Hijiri> I was surprised how many japanese blog posts about haskell there are
00:48:02 <Hijiri> but maybe that's something I should have expected with a language like Haskell that's fairly popular, at least as far as FP goes
00:48:32 <merijn> Hijiri: I had to unfollow some haskellers I was following on twitter because all the non-haskell tweets were filling my timeline with Japanese >.>
00:48:54 <merijn> So there seems to be at least some fairly active haskellers in Japan
00:48:58 <merijn> Anyway, bedtime
00:49:03 <L8D> merijn: why not learn japanese?
00:51:06 <merijn> L8D: Because Japanese grammar is obscenely tricky and there's more practical (to me) languages I'm already desperately struggling to learn :p
00:51:32 <DrSkyLizard> L8D: because its impossible to learn it just from reading tweets
00:51:39 <L8D> ha
00:51:41 <L8D> haha
00:51:46 <L8D> ahahaha
00:51:51 <L8D> ok
00:51:56 <Hijiri> you have to read japanese programming blogs too
00:52:56 <pharaun> i keep on trying to learn japanese
00:53:03 <pharaun> i keep on sucking
00:53:03 <merijn> Technically speaking Chinese would probably be more practical, considering there's a billion Chinese speakers. But since, unlike Japanese, Chinese is tonal, I as a Western barbarian can't actually pronounce anything right
00:53:11 <L8D> pharaun: take a month off for a trip to japan
00:53:14 <pharaun> tonal is a non-issue
00:53:17 <L8D> you'll learn it in a few days
00:53:19 <pharaun> L8D: won't help
00:53:41 <pharaun> its not the spoken language that i have a issue with, its the written one :)
00:54:01 <pharaun> and i've spent 2 week in tokyo, i knew enough to get round but yesh
00:54:05 <L8D> then learn chinese first
00:54:14 <L8D> chinese simplified
00:54:24 <DrSkyLizard> to be able to read you need to know to write?
00:54:30 <pharaun> basically
00:54:33 <Hijiri> sort of
00:54:41 <Hijiri> kanji are easier to read than write
00:54:47 <pharaun> you can read better than write, or vice verse
00:54:51 <pharaun> but yeah
00:55:00 <pharaun> i managed to memorize ~1k kanji
00:55:03 <pharaun> then fell over
00:55:05 <Hijiri> for reading you just have to memorize the general shape, but to write you need to know the strokes
00:55:09 <pharaun> (reading & write)
00:55:10 <Hijiri> it helps if you know the radicals
00:55:13 <pharaun> ya
00:55:18 <pharaun> radicals really helped
00:55:42 <Hijiri> I'm actually pretty bad at writing, but I think I would have a good way to use Anki to practice writing
00:55:58 <Hijiri> If I have the answer be the character, but I have to write it down on paper to compare with the screen
00:56:03 <pharaun> L8D: anyway for a little bit more context, i'm deaf :) so unless i get over that hill to being able to actually read the words, being in japan won't help
00:56:25 <L8D> O.O
00:56:41 <pharaun> yes deaf people exists :)
00:56:46 <Hijiri> I find that kanji and vocab stick more if I read some material with the things I memorized in it
00:56:55 <L8D> no I'm trying to imagine learning foreign languages being deaf
00:57:01 <Hijiri> otherwise I have to keep it fresh with anki
00:57:02 <pharaun> Hijiri: ya that's my issue, i couldn't figure that part out
00:57:07 <pharaun> and got burnt out on anki
00:57:16 <Hijiri> yeah, I haven't done anki in months
00:57:24 <Hijiri> I don't want to face all the cards piled up
00:57:26 <pharaun> L8D: just like a hearing person, who ignores the verbal component
00:57:29 <pharaun> Hijiri: haha yes
00:57:34 <pharaun> that was my problem precisely
00:59:16 <Hijiri> You could try setting up a smaller deck that just consists of words you find that you don't know
00:59:23 <Hijiri> then you already have a context associated with it
01:01:51 <inf-groupoid> Is there no "instance Monoid a => Alternative (Either a)" ?
01:03:17 <pharaun> Hijiri: yeah, i'm so rusty now that i would have to restart basically >_<
01:03:54 <Hijiri> you might be surprised how quickly words can come back with a little bit of memory-jogging
01:04:19 <Hijiri> you might have to do the card a couple times, but it won't take as long as the first
01:04:52 <Hijiri> also maybe this is the wrong channel
01:12:04 <Dongyancai> Another question, is there a way to dump the process of graph reduction? Not necessary visualized.
01:17:34 <inf-groupoid> How much is the overhead of using Data.Seq vs. using regular lists?
01:20:32 <inf-groupoid> I am write yet another toy lambda calculus implementation. Previously I used de Bruijn indices, but I want to avoid the overhead of shifting by -1 and 1 all the time. Using de Bruijn levels seems like a viable alternative, but managing contexts then requires using a container that lets me append elements to its rear (hence Data.Seq).
01:22:11 <kqr> regular lists are rarely the correct choice
01:22:44 <kqr> other than when you consume one element at a time lazily and don't need an element more than once
01:23:33 <inf-groupoid> writing* (oh, God, did I really say "I am write"?)
01:24:04 <inf-groupoid> kqr: Is Data.Seq a much better choice, then?
01:27:28 <inf-groupoid> kqr: Errr, Data.Sequence.
01:38:46 <jle`> inf-groupoid: i think it has something to do with the Alternative laws and the behavior of `empty`
01:38:53 <jle`> inf-groupoid: empty <|> x = empty
01:39:12 <jle`> that's a part of the laws of Alternative, giving it a right seminearring structure
01:39:19 <jle`> but with your Monoidy Alternative instance, this isn't the case.
01:39:35 <inf-groupoid> Wait, empty <|> x = empty???
01:39:38 <jle`> oh wait.  do you mean to just use it as a "default item"
01:39:44 <jle`> er sorry, empty <|> x = x
01:39:47 <jle`> um
01:39:50 <jle`> which one did i mean to say
01:40:00 <jle`> ...
01:40:02 <jle`> sorry, it's late, heh.
01:40:12 <inf-groupoid> I just checked, and Either's Applicative instance doesn't depend on Monoid.
01:40:18 <inf-groupoid> Which I guess is the real problem. :-|
01:40:27 <jle`> well, that's not really a problem
01:40:41 <jle`> because Monoid a => Alternative (Either a) still works
01:40:45 <inf-groupoid> Oh.
01:40:47 <jle`> because it is guarunteed to be an Applicative
01:41:08 <jle`> (Either a) is an Applicative, so Monoid a => Either a is, of course, also an Applicative
01:41:16 <jle`> sorry, i was thinking about the MonadPlus laws earlier.
01:41:21 <inf-groupoid> AAh.
01:41:45 <inf-groupoid> Does MonadPlus have any laws besides "it must be both a valid Monad and an Alternative"?
01:42:19 <jle`> it's contested, but it's supposed to form a right seminearring with (>>=) and (<|>)
01:42:29 <jle`> so with Alternative, you have empty <|> x = x, x <|> empty = x
01:42:35 <jle`> and the associative laws
01:42:44 <jle`> with MonadPlus, you have to consider (>>=).
01:42:53 <jle`> it's supposed to "distribute" over (<|>)
01:43:28 <jle`> um
01:43:41 <inf-groupoid> I find it "obvious" how <*> is a "product" and has to "distribute" over <|>. But not so with >>=.
01:44:22 <jle`> i guess one of the problems with Alternative Either a is that there is no unique `empty`
01:44:33 <jle`> Left "hello" <|> empty = Left "hello"
01:44:33 <inf-groupoid> Hence the Monoid instance requirement.
01:44:38 <jle`> but we are defining empty as Left ""
01:44:49 <jle`> er, wait.
01:44:50 <inf-groupoid> empty = Left mempty
01:45:23 <inf-groupoid> Also, Left a <|> Left b = Left $ a `mappend` b
01:45:50 <jle`> well, that just won't do
01:45:56 <jle`> empty <|> Left "hello" = ?
01:46:00 <jle`> Left "hello" <|> empty = ?
01:46:10 <jle`> in both cases, they should be Left "hello", right?
01:46:13 <inf-groupoid> For String, mempty = ""
01:46:16 <jle`> yes
01:46:20 <inf-groupoid> And mappend = (++)
01:46:29 <jle`> oh, ah.
01:46:43 <jle`> ...i remember this breaking somwehere >_>  sorry for rambling
01:48:23 <jle`> hm. maybe it doesn't break
01:51:34 <inf-groupoid> It's just a generalization of Alternative Maybe.
01:51:44 <inf-groupoid> Maybe being isomorphic to Either (), of course.
01:52:32 <inf-groupoid> jle`: So the only possible source of trouble I can identify is the Applicative instance.
01:52:45 <jle`> what trouble in the Applicative instance?
01:53:20 <inf-groupoid> "instance Applicative (Either a)"
01:53:35 <jle`> yeah, so there's an Applicative instance for (Either a) of all a's
01:53:44 <jle`> every Alternative has to have an Applicative instance
01:53:53 <jle`> so of course, every Monoid e => (Either e) has an Applicative instance
01:54:41 <inf-groupoid> Mmm... I vaguely remember there being something funny about how errors are "propagated" by <*>.
01:55:29 <DrSkyLizard>  Is there a way to determine the time complexity (Big-O) of an algorithm? I should be able to give it any function that implements an algorithm (possibly with certain restrictions) and it should output the best, worst, average time complexity and possibly other useful information
01:55:30 <inf-groupoid> > Left "a" <*> Left "b"
01:55:32 <lambdabot>  Left "a"
01:56:23 <inf-groupoid> jle`: Left "a" <*> (Left "b" <|> Left "c") -- this should show how <*> fails to distribute over <|> in the absence of a Monoid requirement for "instance Applicative (Either a)".
01:56:45 <jle`> i don't think that (<*>) distributing over (<|>) is an Alternative law
01:56:54 <inf-groupoid> No? :-O
01:57:08 <jle`> the only laws are the monoidal laws, empty <|> x = x, x <|> empty = x, and (x <|> y) <|> z = x <|> (y <|> z)
01:57:51 <jle`> so i guess i don't really see why such an instance wouldn't work
01:58:20 <jle`> it does sort of break the semantics of Either, though
01:58:26 <jle`> in that the first failure is the final result
01:58:43 <inf-groupoid> If Alternative is a seminearring, and <|> is the addition of that seminearring, what exactly is the product in that seminearring?
01:58:51 <jle`> i mean, the semantics/meaning of the Applicative instance
01:58:53 <inf-groupoid> The only valid candidate I can think of is <*>.
01:58:58 <jle`> i meant to say that MonadPlus is the Seminearring, sorry
01:59:00 <jle`> not Alternative
01:59:03 <inf-groupoid> Oh.
01:59:05 <jle`> the product is (>>=)
01:00:26 <jle`> (x <|> y) >>= f = (x >>= f) <|> (y >>= f)
01:00:36 <jle`> and empty >>= f = empty
01:00:53 <jle`> the idea is that...choosing between a different paths and proceeding from there
01:01:01 <jle`> would be the same as proceeding from all of the paths and chosing from the results
01:01:08 <inf-groupoid> Makes sense.
01:02:13 <jle`> i do have to go now, sorry if i only made ethings more confusing :)
01:02:15 <jle`> but good luck on your journey
01:02:23 <inf-groupoid> jle`: Thanks!
01:45:51 * hackagebot language-c 0.4.7 - Analysis and generation of C code  http://hackage.haskell.org/package/language-c-0.4.7 (BenediktHuber)
02:08:50 <ozgura> Hi. I know unsafe* functions are frowned upon, but is there a way to use unsafeInterleaveIO on a (MonadIO m => m a)?
02:09:14 <ozgura> i.e. I want unsafeInterleaveMonadIO :: MonadIO m => m a -> m a
02:31:03 <lpaste> gartilion pasted “isInfixOf Text not compatible with [Char] (String)” at http://lpaste.net/113633
02:32:14 <gartilion> ^ I don't understand why I get that error message. I copied it from the docs http://hackage.haskell.org/package/base-4.7.0.1/docs/Data-List.html#v:isInfixOf
02:32:32 <Maxdamantus> gartilion: that's Data.List.isInfixOf
02:32:43 <Maxdamantus> gartilion: not Data.Text.isInfixOf
02:33:06 <Maxdamantus> :t Data.Text.isInfixOf
02:33:07 <lambdabot> Data.Text.Internal.Text -> Data.Text.Internal.Text -> Bool
02:33:18 <Maxdamantus> :t Data.List.isInfixOf
02:33:20 <lambdabot> Eq a => [a] -> [a] -> Bool
02:33:27 <gartilion> Ah, thanks Maxdamantus. Not paying enough attention, sorry!
02:35:59 <rai> is there a shorthand for filter (\xs -> length xs == n)
02:36:12 <rai> without lambda
02:37:01 <isocliff_> @type filter (\xs -> length xs == n)
02:37:02 <lambdabot>     Couldn't match expected type ‘Int’ with actual type ‘Expr’
02:37:03 <lambdabot>     In the second argument of ‘(==)’, namely ‘n’
02:37:03 <lambdabot>     In the expression: length xs == n
02:37:12 <isocliff_> its incorrect syntax
02:37:39 <Maxdamantus> Looks correct to me.
02:37:40 <isocliff_> filter filters members of a list with the predicate
02:38:10 <isocliff_> filter (\xs -> length xs == 3) "cat"
02:38:14 <isocliff_> > filter (\xs -> length xs == 3) "cat"
02:38:16 <lambdabot>  Couldn't match type ‘GHC.Types.Char’ with ‘[a]’
02:38:16 <lambdabot>  Expected type: [[a]]
02:38:16 <lambdabot>    Actual type: [GHC.Types.Char]
02:38:52 <Maxdamantus> > filter (\xs -> length xs == 3) ["cat", "dog", "aardvark"]
02:38:54 <lambdabot>  ["cat","dog"]
02:39:53 <Maxdamantus> > filter ((== 3) . length) ["cat", "dog", "aardvark"]
02:39:54 <lambdabot>  ["cat","dog"]
02:40:48 <isocliff_> looks like the best translation you could get right there then
02:51:15 <rai> Maxdamantus: of course. thanks!
03:16:26 <myfreeweb> what's the best http client library... that doesn't use lens?
03:16:44 <joe9> I am trying to fix this warning: http://codepad.org/bTwqHufw . I think I should add applicative's pure method to the "pause" monad. I am trying to understand what Applicative is. I understand how monad works but not applicative. http://www.haskellforall.com/2012/09/the-functor-design-pattern.html I am reading this article to figure out what applicative is.
03:16:57 <joe9> myfreeweb: conduit?
03:17:37 <joe9> I read the function "map" used in the article. I wonder how this map is different from the prelude.map that we use use to map a function to all elements of a list.
03:18:10 <joe9> myfreeweb: I used http-conduit and it worked well. but, I had https requests though.
03:19:33 <myfreeweb> I need https too, of course. I'm not sure I want conduit as a dep either
03:22:09 <L8D> @pl (>>= id)
03:22:09 <lambdabot> join
03:22:13 <L8D> yay
03:22:23 <supki> myfreeweb: http-client + http-client-tls
03:32:10 <myfreeweb> thanks
03:56:09 <myfreeweb> what does the int do in RequestBodyBuilder Int64 Builder ?
03:56:18 <myfreeweb> in http-client
03:57:07 <Hermit> RequestBodyBuilder sounds like you want a personal trainer :P
03:57:57 <myfreeweb> lol
04:00:47 <joe9> http://adit.io/posts/2013-04-17-functors,_applicatives,_and_monads_in_pictures.html is awesome.
04:04:34 <rai> joe9: cool. thanks
04:15:27 <Erraunt> exit
04:19:52 <joe9> I added my first functor definition (fmap) http://codepad.org/xRCPc2cJ I added the lines 23 - 30, Could anyone please comment on whether I did the correct manner or not?
04:24:30 <Hermit> joe9: why fmap = fmapPause ?  looks like a useless separation
04:24:34 <dibblego> joe9: lgtm
04:24:51 <dibblego> Hermit: that is often done for inlining
04:25:19 <Hermit> dibblego: shouldn't that be accompanied by an INLINE pragma?
04:25:26 <joe9> dibblego: thanks.
04:25:31 <benmachine> it's also occasionally sensible to use monomorphic versions of polymorphic functions
04:25:42 <benmachine> to check that you and the compiler agree on what functor is in use
04:25:49 <joe9> Hermit, it is harder to debug when I have the definition directly as fmap.
04:27:08 <benmachine> joe9: observation: PauseResult is a functor, then Pause is just the composition of the State s functor and the PauseResult s functor
04:27:24 <benmachine> so you can define fmap that way too
04:27:56 <benmachine> actually it probably wouldn't be easier in this case
04:28:53 <benmachine> something like fmap f = Pause . runState . fmap (fmap f) . State . runPause
04:29:06 <joe9> benmachine: I just learnt what a function is from here http://adit.io/posts/2013-04-17-functors,_applicatives,_and_monads_in_pictures.html
04:29:46 <joe9> benmachine: sorry, I meant functor.
04:29:54 <joe9> s/function/functor/
04:30:47 <benmachine> joe9: feel free to ignore what I said if you haven't met some of the ingredients yet
04:33:07 <joe9> benmachine: I think I get it. Thanks a lot. That is cool to reuse the State functionality.
04:34:09 <benmachine> joe9: I think it's good to be able to see things like this and say "oh, this must be a functor, because it's just these other functors glued together", but you don't then need to actually use the implementation I suggested
04:34:53 <benmachine> I guess that's up to you what you think is clearest
04:37:56 <joe9> benmachine: From what I understand until now, a functor is a typeclass with the fmap method.
04:38:06 <benmachine> yes
04:38:12 <joe9> When you use the word "functor", What do you mean?
04:38:12 <benmachine> well, wait
04:38:14 <benmachine> hm
04:38:31 <benmachine> when I say "type T is a functor" I mean "there exists, or could exist, an instance of Functor for T"
04:38:37 <joe9> so, any type for which I define fmap and add to the instance Functor is a functor.
04:38:51 <joe9> oh, ok. makes sense.
04:38:51 <benmachine> Functor is a typeclass with the fmap method
04:38:57 <benmachine> a functor is a member of that typeclass
04:39:19 <joe9> oh, Functor vs functor. did not know that there was a difference.
04:39:19 <benmachine> just as people will say e.g. "Maybe is a monad"
04:39:39 <hape01> map do work with lists, where fmap works with much more than lists
04:39:44 <benmachine> people will not typically say "Integer is a show" but maybe they should :P
04:41:09 <joe9> ok, thanks.
04:41:41 <benmachine> I guess it's because Functor and Monad are type classes invented to capture the behaviour of existing concepts of functors and monads
04:51:03 * hackagebot ede 0.2.3.1 - Templating language with similar syntax and features to Liquid or Jinja2.  http://hackage.haskell.org/package/ede-0.2.3.1 (BrendanHay)
04:53:21 <kifla> Hello
04:54:11 <kifla> hi can i see how many ending zeroes does a factorial of a number has without using recursion or higher order functions
04:57:03 <Saizan> kifla: unlikely, but why these restrictions?
04:57:05 <darth_lumbergh> is life worth living without recursion and higher-order functions?
04:58:20 <kifla> it for my friend
04:58:28 <kifla> he is learning haskell in class
04:58:35 <kifla> and that is one of the tasks for homework
04:58:49 <kifla> and they still didn't learn recursions nor higher order functions
04:58:58 <hape01> darth_lumbergh: :)
05:00:30 <darth_lumbergh> I'd pre-calculate all the factorials in a given range, and generate code for a big lookup table
05:00:31 <hape01> darth_lumbergh: real life is chaos :)
05:00:37 <darth_lumbergh> well, only for troll value
05:01:02 <indiagreen> well, you can do it for, say, factorials of all numbers less than Int or something
05:02:22 <indiagreen> kifla: did they learn list comprehensions?
05:03:31 <joe9> benmachine: any hints on how I can define <*> on the Pause, please?
05:03:45 <joe9>  http://codepad.org/9b8ykvwh is my attempt.
05:03:58 <kifla> yes they did
05:04:05 <joe9> but, I cannot runPause on both pf and the (Pause s a).
05:04:12 <indiagreen> kifla: cool then, it's the same as having map and filter
05:04:29 <kifla> but they did not learn map nor filter
05:04:55 <indiagreen> but list comprehensions let you do anything you can do with map and filter without using map or filter
05:05:07 <kifla> oh yeah
05:05:11 <kifla> thanks
05:05:40 <indiagreen> anyway, I got 2 options for you – either compute the factorial dumbly, reverse it, and then count zeroes... or employ de Polignac's formula
05:08:28 <indiagreen> (the latter is just “count the number of times 5 is contained in factorial's prime factorisation”, which should be easy if your friend isn't all that bad at math)
05:18:42 <prinsen> What is a good solution to a case clause you know will never happend, like matcing the result from a parser only returning a certain set of characrers
05:19:00 <vanila> error "My head exploded!"
05:19:36 <darth_lumbergh> industrial practice is to write a comment -- this should never happen!
05:20:04 <darth_lumbergh> ..which, of course, guarantees that it'll happen in production
05:20:29 <prinsen> :)
05:20:40 <jedai> prinsen: Also emits an error like suggested by vanilla, though "panic" is often the term used for these cases that should never happen (it is therefore troubling to find many reports of them happening all over the place)
05:27:16 <nshepperd> otherwise -> error "Bob's fault! I didn't write this code."
05:42:17 <myfreeweb> why does my TVar not persist between test requests in hspec? everything works fine in manual testing... it's a scotty app
05:46:34 <solirc> myfreeweb: Are those separate spec items?
05:47:18 <solirc> If yes, a new app is created for each spec item, so that they are not interdependent.
05:48:03 <solirc> myfreeweb: You can try work around this, but it will break stuff like --match and --rerun
05:48:24 <solirc> myfreeweb: You are using hspec-wai, I assume?
05:50:02 <d1323> hello
05:50:25 <d1323> should I cabal install gtk or gtk3?
05:50:36 <solirc> myfreeweb: If you really want to do this, use `beforeAll` instead of `with`
05:50:51 <d1323> are haskell bindings for gtk3 usable and reliable already?
05:50:51 <myfreeweb> yeah, hspec-wai
05:51:02 <myfreeweb> that even happens inside of one "it"
05:52:01 <myfreeweb> I don't use "with"
05:52:26 <myfreeweb> just `let app = mkApp` inside of the spec
05:52:39 <myfreeweb> before all `describe`s
06:13:29 <myfreeweb> wait, I'm not using hspec-wai
06:15:22 <joe9> This is my first applicative and functor definitions: http://codepad.org/RpaGxvlp to get rid of the warning about using applicative to define monad. The monad standalone definition is the commented lines 23-28.
06:15:27 <joe9> Any feedback, please?
06:16:49 <vanila> it looks very good
06:20:21 <joe9> vanila: do you think I am doing the correct thing in the definitions of >>= and applicativeJoin.
06:20:45 <joe9> I have a vague feeling that they both might be doing different things.
06:20:58 <joe9> I understand the difference between <*> and >>=
06:21:25 <vanila> let me think about that
06:21:25 <joe9> but, from a program flow perspective, I am not certain about it yet.
06:22:24 <vanila> :t \mf ma -> (mf >>= \f -> ma >>= f)
06:22:25 <lambdabot> Monad m => m (a -> m b) -> m a -> m b
06:22:25 <vanila> so it's this
06:22:30 <vanila> no that's wrong
06:23:43 <joe9> vanila: I think line 53 should change to Suspend ..
06:23:46 <vanila> :t \mf ma -> mf >>= \f -> ma >>= \a -> return (f a)
06:23:47 <lambdabot> Monad m => m (a -> b) -> m a -> m b
06:23:55 <joe9>  http://codepad.org/40pzrpsl
06:24:54 <joe9> vanial ^^
06:26:03 <vanila> it's hard to substitute the definition of >>= in to that, to try to prove them equal
07:06:17 <mdeland>  /statusbar window add usercount
07:33:52 <mbuffett> Hey does anyone know how I can start ghci through System.Process? I'm trying runInteractiveCommand "ghci", but nothing happens
07:39:52 <chrisdone> @where lpaste
07:39:53 <lambdabot> http://lpaste.net/new/haskell
07:39:58 <chrisdone> mbuffett: paste =)
07:47:38 <solirc> myfreeweb: If you don't get it running, post me a gist with a minimal example in #hspec and I'll look at it tomorrow (that is 10h from now)
07:53:03 <yukko> data Map' a b = Map' (Map a (Either (Map' a b) b)) is there an easier way to do this? (Map is from Data.Map)
07:55:12 <mbuffett> Right now I have this : http://lpaste.net/113640. It doesn't do anything though, I assumed it would start up ghci. I've also tried runCommand "ghci" and that doesn't work either.
07:56:12 <yukko> mbuffett does runInteractiveCommand know about $PATH?
07:56:48 <Fuuzetsu> edwardk: sure is a lot of modules in gl
07:56:51 <mbuffett> I don't know, maybe it doesn't, but wouldn't it print out an error then?
07:56:56 <benzrf> look like a map tree yukko
07:56:59 <edwardk> Fuuzetsu: hah
07:57:01 <edwardk> Fuuzetsu: its a big spec =)
07:57:06 <benzrf> what sort of data are you storeing
07:57:08 <Fuuzetsu> I hope you generated those
07:57:29 <yukko> benzrf mapping from String to [String]
07:57:36 <yukko> er wait just String to String
07:57:41 <edwardk> Fuuzetsu: i just sat down and started typing. ;)  ok ok, they are generated
07:57:42 <yukko> but it needs to be recursive
07:57:47 <PeterJ> Does Template Haskell support splicing infix operators? For example, is there any way to make '[| a $(.+.) b |]' work, having '(.+.) :: Exp' and 'infixl 6 .+.' ?
07:57:59 <indiagreen> mbuffett: does «readProcess "ghci" [] "2+3\n:q"» work for you?
07:58:13 <mbuffett> I'll try it out, give me a second
07:58:14 <edwardk> the generator is the few .hs files in the top level directory Setup.hs constructs almost all the modules from those and the xml specification from khronos
07:58:16 <Fuuzetsu> edwardk: I would not put it past you…
07:58:29 <edwardk> its based on Polarina's bindings
07:58:35 <edwardk> this has just been mangled to work a bit more like the OpenGL package than opengl-wrangler
08:00:45 <mbuffett> The "2+3\n:q" part is put in while ghci is starting up, and then ghci exits immediately. I tried it with a blank string too and it just says "leaving ghci" at the first prompt.
08:01:04 <mbuffett> (Without typing in :q)
08:01:29 <indiagreen> mbuffett: ah, so you want to start GHCi and interact with it?
08:01:55 <mbuffett> Exactly, while also allowing the user to interact with it
08:03:08 <myfreeweb> solirc: oh, I've just realized what exactly I've been doing... storing {an action that returns the app} in a let, not the app itself
08:03:42 <hsam> #yesod
08:11:31 <Ouyang> anyone that is above the skill level of begginner with haskell taking/looking at edx's functional programming course on edx?
08:12:51 <wei2912> Ouyang: just curious, why? i'm taking that course too
08:13:23 <Ouyang> .desktop  http://a.pomf.se/inifng.png
08:13:43 <Ouyang> wei2912: despite not having a need for it, I just want to toy around with it so I have something to do in calculus
08:13:57 <wei2912> Ouyang: heh
08:14:26 <Ouyang> wait this is the wrong channel wei, I meant that I was looking into the course and seeing if anyone had any opinions on how good it was
08:14:40 <Ouyang> (my response to your question was about knightos lol)
08:14:49 <wei2912> lol
08:15:06 <wei2912> Ouyang: looks quite fine to me. content is accurate as far as i know, i don't know much though
08:16:09 <Fuuzetsu> Ouyang: you missed the desktop thread by a long stretch
08:16:26 <Ouyang> Fuuzetsu: ?
08:16:58 <Fuuzetsu> re: rice posted 3 minutes ago
08:17:58 <Ouyang> I was just in the wrong weechat buffer, I posed a knightos question in the other and thought I was in it when wei responded.
08:18:37 <Fuuzetsu> OK; anyway, I don't know about the edx course so can't help there, sorry.
08:18:59 <narendraj9> I am taking the course too but have no idea about this desktop thread. What's going on in here?
08:19:46 <Ouyang> it was me being a fool, don't worry I don't mean to take this off topic.
08:21:01 <madjestic> Ouyang: thanks for the reference
08:22:01 <Ouyang> I do like the book the course uses though, Programming in Haskell, I like that method better than LYAH or RWH
08:25:37 <narendraj9> Ouyang: I like the forums. Some haskell experts are active there, e.g. http://www.andres-loeh.de/
08:26:49 <narendraj9> Or I should say experienced Haskellers.
08:29:12 <madjestic> Ouyang: oh, I just noticed the TUDelft logo.  Cheers to Delft!
08:30:08 <madjestic> I am not used to international course material, made by Dutch
08:33:11 <Ouyang> I was looking at some Delft programs for international students, they were reccomending another dutch uni that had haskell camps over the summer
08:33:53 <jesyspa> I seem to recall Utrecht having some.
08:34:41 <jesyspa> Ouyang: http://www.utrechtsummerschool.nl/courses/science/applied-functional-programming-in-haskell , by any chance?
08:35:23 <indiagreen> @tell mbuffet here's a paste which shows how to interact with GHCi in a *very* bad way – http://lpaste.net/113642; if you want it to be nicer, you'll have to parse GHCi's output (i.e. instead of “timeout after 100ms” you might want “wait until GHCi prompt appears”, etc.), so all in all, I suggest you not to try to interact with GHCi directly and instead use something like hint or mueval
08:35:23 <lambdabot> Consider it noted.
08:35:25 <Ouyang> yeah jesyspa
08:49:47 <nits> hi
08:50:01 <nits> Newbee haskell programmer
08:50:09 <nits> started with haskell today
08:50:24 <nits> so far it looked great :D
08:52:43 <nits> What are good resource for learning haskell?
08:53:11 <Fuuzetsu> https://github.com/bitemyapp/learnhaskell has links
08:55:42 <dsfox> nits: what resources for learning other programming languages have you liked in the past?
08:58:08 <nits> dsfox: I prefer web tutorials
09:00:18 <narendraj9> nits:  https://www.fpcomplete.com/school
09:07:53 <SwashBuckla> is there a safe !! which returns a Maybe a?
09:08:08 <SwashBuckla> :t (!!)
09:08:09 <lambdabot> [a] -> Int -> a
09:08:26 <SwashBuckla> I want [a] -> Int -> Maybe a
09:08:28 <monochrom> not in standard libs
09:08:45 <benzrf> @let xs !!! i = preview (ix i) xs
09:08:48 <lambdabot>  Defined.
09:08:51 <benzrf> ( ͡° ͜ʖ ͡°)
09:09:03 <exio4> @type (!!!)
09:09:04 <lambdabot> Ixed t => t -> Index t -> Maybe (IxValue t)
09:09:31 <benzrf> actually i bet that's already defined somewhere
09:09:32 <SwashBuckla> :t Ixed
09:09:33 <lambdabot> Not in scope: data constructor ‘Ixed’
09:09:41 <SwashBuckla> :t preview
09:09:42 <lambdabot> MonadReader s m => Getting (First a) s a -> m (Maybe a)
09:09:49 <jhance> SwashBuckla: Shouldn't really be using lists for random-access anyway
09:09:50 <monochrom> it may be somewhere in the lens lib
09:10:16 <monochrom> or yeah, it may be of insufficient professional interest
09:10:23 <ClaudiusMaximus> SwashBuckla: http://hackage.haskell.org/packages/archive/Safe/latest/doc/html/Safe.html#v:atMay
09:10:32 <Dykam> is it possible to have a function of a class return it's own instance?
09:10:47 <Dykam> class X y where foo :: y
09:11:17 <jhance> Dykam: Why not? Data.Default does this for example
09:11:27 <Dykam> I'll look there then
09:11:31 <Dykam> can't figure out how
09:11:37 <indiagreen> look at Bounded
09:11:37 <monochrom> @type maxBound
09:11:39 <lambdabot> Bounded a => a
09:11:41 <jhance> Dykam: Its not any different than a normal class?
09:11:43 <monochrom> is an example
09:12:02 <ClaudiusMaximus> SwashBuckla: oops, Safe is deprecated, use safe instead
09:12:11 <Dykam> jhance, well, foo = ???
09:12:25 <SwashBuckla> ClaudiusMaximus: what is the difference between safe and Safe?
09:12:35 <jhance> Dykam: Obviously the definition of foo would go in the instance...
09:12:46 <jhance> instance X Int where foo = 0
09:13:06 <Dykam> oh I see
09:13:06 <ClaudiusMaximus> SwashBuckla: i don't know, check the hackage pages for details i guess
09:13:26 <Dykam> at least, I see my thinking error
09:13:55 <SwashBuckla> I think I could name atMay better... e.g. safeIndex
09:14:15 <SwashBuckla> maybeIndex
09:14:28 <SwashBuckla> :t atMay
09:14:29 <lambdabot> Not in scope: ‘atMay’
09:14:43 <jhance> SwashBuckla: I think !? would be good
09:14:45 <SwashBuckla> I did not type ���!
09:14:49 <ClaudiusMaximus> and add genericAtMay or whatever that takes an Integer for when you have stupidly long lists :)
09:14:53 <SwashBuckla> !? is okay, yeah
09:17:23 <SwashBuckla> if you have UnicodeSyntax on,
09:17:23 <SwashBuckla> 17:10 < Dykam> oh I see
09:17:29 <SwashBuckla> oops
09:17:31 <Dykam> lol
09:17:40 <SwashBuckla> if you have UnicodeSyntax on, ‽
09:17:46 <SwashBuckla> (that's what I mwant to say
09:17:53 <SwashBuckla> )
09:18:00 <benzrf> ⸘
09:18:01 <SwashBuckla> but that's pretty terrible
09:18:02 <nshepperd> the vector lib has '(!?) :: Vector v a => v a -> Int -> Maybe a'
09:18:50 <jhance> In that case, !!? to match !?
09:19:00 <nshepperd> which is basically the same thing, except it makes better sense to do random access on vectors than lists
09:20:53 <benzrf> > "osidjfoi" !!! 3
09:20:55 <lambdabot>  Just 'd'
09:20:57 <benzrf> > "osidjfoi" !!! -3
09:20:59 <lambdabot>  Precedence parsing error
09:20:59 <lambdabot>      cannot mix ‘L.!!!’ [infixl 9] and prefix `-' [infixl 6] in the same infi...
09:21:03 <benzrf> > "osidjfoi" !!! (-3)
09:21:05 <lambdabot>  Nothing
09:24:52 <Phillemann> Is there an extension that allows "type Foo = Integral a => a -> Int"?
09:27:45 <indiagreen> Phillemann: RankNTypes
09:31:20 * hackagebot linear 1.11.3 - Linear Algebra  http://hackage.haskell.org/package/linear-1.11.3 (EdwardKmett)
09:37:10 <ReinH> Phillemann: (If you try it, the error will suggest the extension for you)
09:38:24 <joneshf-laptop> how can i express taking a percentage of a list? like the first 30% or so?
09:38:50 <joneshf-laptop> take30 [1..10] == [1,2,3]
09:38:51 <joneshf-laptop> or so
09:38:52 <Zekka> joneshf-laptop: Find the length and take a percentage of htat?
09:39:02 <joneshf-laptop> right, but how can i get the types to line up?
09:39:07 <SrPx> DO you guys think purely functional data structures will ever be as fast as imperactive structures?
09:39:17 <Zekka> joneshf-laptop: What do you mean getting the types to line up?
09:39:43 <Zekka> Wouldn't this work? takePerc :: (Floating f) => f -> [a] -> [a]
09:39:44 <vanila> SrPx, no
09:39:48 <joneshf-laptop> the naive way of `take30 xs = take (0.3 * length xs) xs` doesn't work
09:39:56 <SrPx> vanila: why
09:40:04 <joneshf-laptop> @hoogle takePerc
09:40:06 <vanila> for some algorithms mutation is faster
09:40:06 <lambdabot> No results found
09:40:13 <Zekka> joneshf-laptop: You need to convert length xs ou ofb eing an integer and then floor the result of the multiplication back in
09:40:35 <Zekka> Haskell doesn't know how to multiply a floating-point and integrel number innately and it doesn't know what it means to take a floating number of elements out of a list
09:40:42 <Zekka> integral*
09:41:40 <ReinH> SrPx: purely functional data structures are generally log n slower than mutable structures
09:41:51 <joneshf-laptop> Zekka, sure, but i can't figure out the numeric hierarchy
09:42:19 <benmachine> log n is not so big a deal really
09:42:20 <tommd> Zekka: Surely you can take 2.3 numbers from a list by simply taking 0.3 times the third element.
09:42:20 <SrPx> Can't parallelism help here? Isn't it one of the benefits of FP?
09:42:25 <Zekka> joneshf-laptop: fromIntegral takes an Integral and turns it into a Num
09:42:26 <ReinH> benmachine: yep!
09:42:41 <SrPx> 10~20x slower is a big deal to me
09:42:42 <ij> SrPx, But wouldn't mutable algorithms be the same amount faster?
09:42:51 <ij> if parallel
09:42:57 <ReinH> SrPx: No. The upper bound on complexity for an immutable structure is an extra log n over a mutable structure. This is a theoretical result.
09:43:13 <Zekka> floor, ceiling, round, and truncate turn a RealFrac into an Integral
09:43:15 <ReinH> SrPx: why do you think log n implies 10-20x slower?
09:43:40 <ReinH> The good news is that any mutable structure can be replaced with an immutable structure by paying *at most* log n extra
09:44:00 <Zekka> I guess you probably wan a RealFrac, not a Floating type, but Double and Float are realfracs so you'd be fine
09:44:09 <SrPx> ReinH: approx the log of 10000 and 10000000 which is what fits in our memory nowadays
09:44:12 <ReinH> This is actually a surprisingly good result
09:44:22 <jhance> SrPx: You know that isn't how asymptotics work right
09:44:40 <SrPx> jhance: hm elaborate?
09:45:07 <jhance> SrPx: There could be any constant factor on that log, and that log might not be base 10, it can be any base, because all logs are the same asymptotically
09:45:27 <benmachine> jhance: sure, but none of that changes the scaling behaviour
09:45:46 <jhance> benmachine: Of course it doesn't. Thats why you can't just "approx" the log of large numbers and say thats the scalar multiple
09:45:46 <benmachine> I mean, kx gets 10 times bigger if x gets 10 times bigger, no matter what k is
09:45:55 <ReinH> benmachine: sure, but if the constant factor on the immutable structure is 30x that of the mutable structure...
09:46:18 <jhance> benmachine: What is actually happening here is that in order for the time of the operation to double, you have to square the input size
09:46:23 <luite> ReinH: 10-20x can be a realistic number in some situations, not because of the actual value of the log for the maximum data size, but because log factors often imply indirection and worse locality
09:46:41 <ReinH> luite: that's true
09:47:03 <SrPx> jhance: honestly whenever you see an algorithm with a log(n) added you can expect it to be from 5~40x slower to an identical, same constant algorithm without the log(n), and you will be correct for any practical purposes in the universe you live in
09:47:41 <jhance> SrPx: There is a reason we don't bring the real world into algorithm complexities, thouhg.
09:47:41 <ReinH> "an identical, same constant algorithm" isn't a thing that exists though
09:48:06 <SrPx> it just works in practice
09:48:12 <jhance> SrPx: You are saying mathematical nonsense here.
09:48:20 <simpson> SrPx: Hm. Do you have an example of such a pair of algorithms?
09:48:32 * SrPx sighs
09:48:37 <jhance> If you could bound it by 40x, then it would be the same complexity as the original algorithm.
09:49:00 <jhance> Feel free to use your "general rule" but don't use it as if its something that means anything in a theoretical context
09:49:05 <simpson> Since we're talking about "in practice" and "the universe you live in", I'd love to see an example.
09:49:43 <ReinH> jhance: well, you can bound it by, say, 200 under the assumption that the algorithm will either complete before the heat death of the universe or take less memory than the universe has states ;)
09:49:50 <vanila> SrPx, if different algorithms have diffferent complexity, then when you make 'n' very large (e.g. huge imput) the difference in speed will be 9999999x or 999999999x you can make the difference as much as you like
09:49:55 <jhance> ReinH: In that case we can just say everything is O(1) :P
09:50:06 <ReinH> jhance: :)
09:50:23 <SrPx> simpson: any algorithm, really. They do not have to have the same constant, the point is that the difference will be around 5~40x times a specific constant. If you think that is wrong to make a few tests and you will understand. I'm not talking about theory at all
09:50:38 <ReinH> jhance: (note that *in practice*, there can be a difference of over 200x in performance of different algorithms ;)
09:50:43 <benmachine> I guess the lesson is that for n of sizes that come up in practice, it's easy for the asymptotic factor to be dominated by constant factors
09:50:53 <jhance> SrPx: Times a specific constant? 40 times a specific constant is isomorphic to specific constants...
09:50:56 <vanila> SrPx, example is that multiplying numbers is O(n) but factoring O(exp(n)) (sort of) - so you can make a crypto system where it's easy to encode but impossible to decode (by making the numbers really highe)
09:50:58 <Zekka> I think what benmachine said is what SrPx is getting at
09:51:02 <benmachine> in constant vs. log n terms
09:51:11 <ReinH> benmachine: well, when that factor is log n, yeah
09:51:12 <benmachine> Zekka: oh, I think I'm disagreeing with them :P
09:51:25 <Zekka> Oh, really? Then I'm pretty puzzled!
09:51:29 <simpson> SrPx: Okay. I pick left-leaning red-black tree search. >:3
09:51:56 <simpson> SrPx: The mutable version and immutable version are the same. Therefore they perform the same. My logic is backed up by experimental results.
09:52:28 <jhance> simpson: Not if I run them on two different computers, cause you know, we are in this universe or whatever
09:52:41 <benmachine> Zekka: I guess I'm saying that I don't really think of log-time algorithms as invariably slower than constant-time ones, even though of course they always are for large enough n
09:52:43 <ReinH> simpson: big O does not imply "performs the same" ;)
09:53:00 <benmachine> ReinH: okay, but being identical does
09:53:04 <jhance> (not even big theta does)
09:53:10 <ReinH> benmachine: ok :)
09:53:17 <simpson> ReinH: I specifically picked search since it is *the exact same code* to search through an immutable and mutable left-leaning red-black tree.
09:53:23 <ReinH> simpson: :)
09:53:24 <Zekka> benmachine: I tend to agree. I've run into some languages that like defining separate types for small structures that have poor asymptotic performance but very good performance for small data
09:53:26 <jhance> I mean, given any two algorithms, I can always say that there exists f(x) such that both are in O(f(x))
09:53:37 <simpson> If you let somebody pick your cherries, don't be surprised when they go for the biggest and juciest ones.
09:53:38 <vanila> if you have two algorithms with different complexity then you can just make the input large enough so that one takes any amount longer than the other
09:53:39 <Zekka> stuff like "map that should probably not have more than 256 things in it"
09:53:40 <ReinH> simpson: This entire conversation is about well-actuallying one another, so I felt like I had to ;)
09:54:00 <benmachine> Zekka: that's not a bad choice, although it does hurt composability a little
09:54:14 <simpson> ReinH: Ah. :3
09:54:34 <Zekka> benmachine: How so? I can't actually remember which language but IIRC itw as a JVM language where both map types were treated as the same type
09:54:45 <benmachine> Zekka: ah, okay then, I was assuming they'd be distinct
09:54:50 <Dykam> Is it possible to call the default implementation of a class explicitly?
09:54:50 <Zekka> So you could write the same programs with either so long as you were careful about not picking a configuration that would make algos slow
09:54:52 <SrPx> jhance: I have no idea what you just said, but what I said is that log(n) can be taken as a constant smaller than 40 or 50 for any practical purposes. If that seriously doesn't hold for you, you are probably sending your computers to black holes before collecting the results so my bad?
09:54:56 <vanila> it's impossible to have a rule of the form "algorithm A takes around c times more time than algorithm B"
09:55:11 <jhance> SrPx: No, it cannot. The base could very well be base 1.00001
09:55:18 <vanila> SrPx, log(n) diverges to infinity
09:55:19 <SrPx> jhance: I mean log2 !
09:55:19 <Zekka> You're right in that you could inadvertently write code that, when used by others in ways you didn't intend, makes things very slow
09:55:26 <Zekka> benmachine: I think it might have been Scala by the way but I'm not actually sure
09:55:32 <ReinH> SrPx isn't really wrong. All else being equal, an extra log_2 n factor does translate into something like 5-40x overhead for the sort of data people actually work with in the real world.
09:55:33 <jhance> SrPx: log2 and log1.00001 have the same asymptotic behavior.
09:55:55 <ReinH> It's not a ridiculous statement and I wish people wouldn't keep treating it as if it were.
09:56:00 <ReinH> That's not very nice.
09:56:02 <Dykam> like, class X x where foo = id; data Y = Y; instance X Y where foo = foo_from_x
09:56:17 <Zekka> ReinH: AFAIK that's also what Benmachine is saying, although he's speaking more generally
09:56:19 <SrPx> jhance: asymptotic behavior is completely meaningless in practice unless you are seriously sending your computers to black hoels
09:56:25 <benmachine> I think there is a miscommunication here where there is a nonsense statement and a sensible statement and they sound very similar
09:56:28 <jhance> It -is- a ridiculous behavior because we aren't necessarily only tacking on a log n to the actual performance
09:56:37 <jhance> we are tacking on a log n to the upper bound for the complexity of the algorithm
09:56:41 <vanila> SrPx, asymptotic behavior is a useful practical measure, I gave an example of its application in cryptography earlier
09:56:42 <Zekka> I think benmachine's also potentially right on that front
09:56:52 <jhance> which could very well be k log n, for any k we want
09:57:03 <ReinH> SrPx: Asymptotics *are* very useful.
09:57:09 <ReinH> They tell me whether I'm climbing the right hill.
09:57:37 <benmachine> asymptotics are overwhelmingly less ignorable when you're choosing between, say, n^2 and n^3, to be fair
09:57:39 <ReinH> If I know I can get O(n log n) but I can prove that the algorithm I'm writing will only get me O(n^2)
09:57:41 <benmachine> or polynomial and exponential
09:57:49 <ReinH> Then asymptotics let me know I'm building the wrong thing
09:57:51 <ReinH> This is very useful
09:58:06 * SrPx cries
09:58:26 <indiagreen> SrPx: just in case, is your actual question by any chance “how do you guys live with the fact that Haskell can't ever be less than 5–40× slower than C for some purposes?”
09:58:40 <SrPx> tl;dr I'm talking about X, you are disputing what I said about Y and counter-disputing your statement about Z
09:58:49 <jhance> (which is a good thing, not a bad thing, because its an upper bound not a lower bound)
09:59:07 <ReinH> SrPx: I am responding directly to your "asymptotic behavior is completely meaningless in practice"
09:59:11 <vanila> SrPx, maybe you're actually mistaken though?
09:59:26 <jhance> tl;dr you think that f = g log n and f in O(h(n)) and g in O(h(n) log n) are the same thing
09:59:49 <jhance> because the theoretical result refers to the latter while you are using the former
09:59:59 <vanila> this is in no way a bad thing, just an opportunity to learn
10:00:02 <Zekka> I don't even think you need to get as theoreetical as ReinH -- datasets where asymptotic behavior actually matters actually exist, afaik
10:00:11 <SrPx> indiagreen: my actual question is: can we do something about it? Because yes, I find it sad that I have to fear writing purely functional code because I know it will be 5~40 slower than C.
10:00:17 <Dykam> is it possible to call the default implementation of foo here? e.g. class X x where foo = id; data Y = Y; instance X Y where foo = default_foo
10:00:24 <jhance> SrPx: Again, its an upper bound, now a lower bound. Upper bounds are good things.
10:00:42 <benmachine> ok so if we want to talk, how fast are functional programs vs. imperative programs
10:00:48 <jhance> SrPx: Its saying that this is the worst we can do if we are absolutely perfect, not that correspondingly fast solutions do not exist
10:01:01 <ReinH> Dykam: no, there isn't a "default implementation"
10:01:04 <Zekka> See the "small map data structure" examle I mentioned earlier - if my map abruptly becomes slow as molasses with more than a few thousand elements but it's fast for a small number, then if I pick another map it's because I thought I would have enough elements for the non-constant factor to matter
10:01:12 <SrPx> I have the impression that random array access isn't actually O(1) in a physical sense, so that is what makes the advantage of those languages
10:01:14 <benmachine> then, well, you can write an imperative interpreter for a functional language with zero overhead, so obviously it's always *possible* to match functional with imperative
10:01:19 <Dykam> ReinH, quite clearly there is?
10:01:45 <SrPx> If you consider that light has to travel all the way through a memory buffer to get the information then it is actually O(N), isn't it? :p
10:01:50 <Dykam> https://www.haskell.org/ghc/docs/7.2.1/html/users_guide/type-class-extensions.html section 7.6.1.4
10:01:59 <vanila> array access is probably limited by word size
10:02:04 <jhance> good thing we don't consider that
10:02:04 <vanila> so it's OK to model it as O(1)
10:02:06 <Zekka> benmachine: You can come up with all kinds of clever technicalities! Why not write a Haskell program that interprets a bunch of data into a huge honking IO action that does the tas imperatively?
10:02:07 <benmachine> but, for example, using advanced datastructures like finger trees, balanced binary trees, etc. is just so much easier in a sophisticated language than a low-level one
10:02:16 <ReinH> Dykam: Please get `class X x where foo = id' to parse and let me now how that goes :)
10:02:23 <Zekka> ("Haskell is my macroing system!")
10:02:26 <hakujin> SrPx: what is your problem domain? There are lots of ways to get very good perf from Haskell. This is not a topic of despair.
10:02:31 <vanila> even though in a theoretical model with arbitrarily long words and arrays you couldn't do it in O(1)
10:02:36 <benmachine> that I generally expect that a functional program that I spent N days writing will outperform a C program that I spent the same amount of time on :)
10:02:48 <Dykam> ReinH, I left out foo :: x -> x
10:02:53 <Dykam> ReinH, but other than that it works fine
10:03:07 <jhance> you can also drop down to ST if you need a mutable structure as well, for whatever reason, although the performance benefits are usually not enough to justify this
10:03:27 <SrPx> hakujin: my last attempt was a graph library for a school assignment, I got the best performance of the class on javascript, but my best attempts at haskell topped at most 40x slower than javascript :( and at that point I was actually using mutable arrays and all that. this is not the point though
10:03:35 <wz1000> Why do multituples exist? Is there any reason why (a,b,c) isn't sugar for (a,(b,c)) or (a,(b,(c,())))?
10:03:39 <ReinH> Dykam: Fair enough. Then `instance X Y' should apply the defaults
10:04:03 <hiptobecubic> benmachine, forall N?
10:04:07 <Dykam> Well yeah, but I mean, suppose I am defining foo in instance X Y, can I refer to the default implementation as part of it?
10:04:11 <jhance> SrPx: Maybe mutable arrays are not the best way to implement Graphs? Of course, your definition of the best way to implement a graph will depend on what operations you want to do with them and whether you want to prefer sparse or dense graphs
10:04:20 <zq> how to make multiline integer literal in haskell
10:04:20 <ReinH> Dykam: not afaik
10:04:22 <zq> ?
10:04:23 <Dykam> like, instance X Int where foo x = x * default_foo
10:04:24 <benmachine> hiptobecubic: yes insofar as I will get bored of writing the C program and stop long before I've written it well enough to outperform the Haskell one
10:04:27 <wz1000> In addition to being elegant, it would simplify making tuples instances of typeclasses.
10:04:28 <Dykam> hmm ok
10:04:42 <hiptobecubic> benmachine, :)  I guess you can count that if no one is paying you
10:04:47 <Zekka> This kind of sounds like either a laziness gotcha or maybe an incorrect algorithm choice to me, right offhand
10:04:59 <Zekka> that is, SrPx's problem
10:05:03 <ReinH> Dykam: you can refer to it from another definition though, iinm: instance X Int where bar x = x * foo
10:05:11 <Zekka> But I'm not that good at optimizing Haskell so I don't trust myself
10:05:12 <Dykam> right
10:05:15 <Dykam> I know that
10:05:21 <benmachine> hiptobecubic: moreover, the C standard library is pants, so there's all sorts of like, serious algorithms research that I'm probably just not clever enough to reinvent
10:05:29 <ReinH> Dykam: ok
10:05:30 <benmachine> too much stuff missing by default
10:05:46 <benmachine> although I could admittedly probably find an implementation of it by someone else if I searched for long enough
10:05:59 <zq> okay, but are you clever enough to break a really long integer literal across multiple lines?
10:06:00 <ReinH> zq: there is no such thing as a multiline integer literal in Haskell
10:06:22 <Zekka> You could use quasiquotes though, or define a function that splices multiple integers into a complete literal
10:06:33 <zq> > 2^88 + 2^8 + 0x3b
10:06:34 <Zekka> er, that's an incorrect term
10:06:35 <lambdabot>  309485009821345068724781371
10:06:47 <zq> not long enough
10:06:54 <zq> > 2^680 + 2^8 + 0x8d
10:06:54 <benmachine> ReinH: there SORT of is, it involves x * 10^y + z :P
10:06:56 <Zekka> @let (,!) x y = 1000 * x + y
10:06:56 <lambdabot>  5016456510113118655434598811035278955030765345404790744303017523831112055108...
10:06:56 <lambdabot>  Parse failed: Parse error: )
10:07:02 <Zekka> @let x ,! y = 1000 * x + y
10:07:03 <lambdabot>  Parse failed: Parse error: !
10:07:05 <Zekka> hm
10:07:09 <Zekka> @let dot x y = 1000 * x + y
10:07:11 <benmachine> Zekka: bang patterns, sry
10:07:12 <lambdabot>  Defined.
10:07:23 <zq> so suppose i would like to include that monstrosity and still respect the 80-column rule
10:07:26 <Zekka> Here's an example that only handles the ccase for three digits
10:07:27 <Cale> wz1000: That has definitely been considered. There is a difference between (a,b,c) and (a,(b,(c,()))) but only in terms of strictness. Whether that difference is important enough to care about is another thing.
10:07:32 <ReinH> benmachine: I was about to suggest that, but it is not an integer literal :p
10:07:43 <Zekka> zq: Why not just write the expression?
10:08:04 <Zekka> > 1234 `dot` (567 `dot` 890)
10:08:07 <lambdabot>  1801890
10:08:10 <zq> Zekka: because the one i actually do want i don't possess the expression for
10:08:14 <Zekka> hm, I did not do that right
10:08:37 <ReinH> wz1000: (And between (a,b,c) and (a,(b,c)) as well)
10:08:37 <Cale> ReinH: that's a good point, I wonder if we should allow string gaps inside numeric literals as well ;)
10:08:59 <jonasss> Hi, is it a good idea to "cache" function calls like in javascript? like if you have an apple and you have to use isRed multiple times on it, should you do a where red = isRed apple, and use red instead? Or isn't this common practice in haskell
10:09:03 <Zekka> zq: If you did it correctly annd not a silly way like I did I think you could implement a function which does what I'm describing
10:09:06 <benmachine> > 1234 `dot` 567 `dot` 890
10:09:07 <ReinH> Cale: allowing `_' specifically is nice to break up longer literals: 15123454 vs 15_123_454
10:09:08 <lambdabot>  1234567890
10:09:16 <Cale> jonasss: It can certainly be a good idea
10:09:19 <zq> :t dot
10:09:21 <lambdabot> Num a => a -> a -> a
10:09:24 <Zekka> benmachine: Yeah, I got my assoiativity backwards
10:09:31 <Zekka> The other thing you could do is use quasiquotes
10:09:37 <jhance> I dunno isRed sounds like a O(1) op so I would be lazy and not care
10:09:39 <zq> ah well
10:09:41 <jonasss> even is it just a getter? :p
10:09:50 <Zekka> jonasss: A lot of the time you can handle this with laziness
10:09:53 <jonasss> yeah well they are mostly just getters thats why i don't know :p
10:10:05 <Zekka> For instance, this caches isRed for a massive list of elements, calculating it only as necessary
10:10:08 <ReinH> jonasss: GHC will share the result if it's given a name like red, but not if it's repeatedly written as `isRed apple'
10:10:11 <Zekka> map isRed [oh my god, so many things!]
10:10:16 <benmachine> if they are getters, then it's unclear which will be better
10:10:25 <Zekka> ReinH's description of the behavior is correct afaik, alhtough getters are not very expensive
10:10:38 <benmachine> my advice is: wait for your code to be too slow, then profile it, then make it better
10:10:39 <ReinH> jonasss: but for a trivial function, it may not be worthwhile
10:10:49 <Zekka> For something nontrivial I think doing it the way I've suggested is a very good idea
10:11:00 <benmachine> don't worry about the difference for performance reasons until you know that either way round is actually slow enough to matter
10:11:52 <jonasss> the reason why i ask because i was just doing it out of habit because i always do it in JS, but anyways thanks, i'll just call the getter since it isn't really worth caching i guess :p
10:11:56 <Zekka> jonasss: Don't worry about the cost of mapping over huge structures, etc.
10:12:13 <jonasss> ok thanks (y)
10:12:15 <Zekka> when possible you should generally favor that because it's pretty cheap given that Haskell's lazy
10:12:17 <ReinH> Well, worry about it, but worry about it in a way that makes sense for Haskell/GHC ;)
10:12:42 <ReinH> it's not free, is it, just cheaper in some cases due to laziness
10:12:51 <Zekka> Yeah, and it's not cheaper in all cases either
10:13:05 <Zekka> for a structure that's intermittently changed you may want to build your own cache
10:13:10 <ReinH> And this shifts the complexity to reasoning about laziness
10:13:17 <Zekka> because just relying on laziness will get your cache cleared every time anything changes
10:13:28 <ReinH> So you still need to worry, because you always need to worry about laziness ;)
10:13:36 <Zekka> (I forget, are ropes a good structure to deal with this? My gut inclination is that they probably are.)
10:13:55 <ReinH> Zekka: At least I know edwardk uses them
10:15:04 <Zekka> Part of the problem with using caching is that it's kind of hard to implement a ache in Hsakell where you aren't already explicitly worrying about sequencing effectful operations on your structure
10:15:20 <Zekka> In pure-land you can't do it exactly hte way you'd do it in Javascript -- without breaking the rules you can't really hide it
10:17:56 <indiagreen> SrPx: there are lots of things to fear. You should fear GC (because it's currently stop-the-world and can introduce random delays); you should fear purely functional data structures; you should fear not being able to use assembler inserts; you should fear that some library doesn't exist in Haskell when it exists in other language; you should fear that Haskell isn't supported on some platform which you need; you should fear that there's
10:17:57 <indiagreen> a bug in GHC which doesn't let you do something you want. All these fears are valid. However, there are also workarounds for pretty much everything – to take data structures, your possibilities are (say, if you're using Haskell in production and you *need* performance and you're already invested in Haskell): use strictness / unboxing to improve performance • use a different (more complex) data structure and/or algorithm • use
10:17:57 <indiagreen> immutable arrays • use immutable vectors (which sometimes have the same performance as mutable vectors if you only keep one copy of a vector at all times) • use ST and mutable data structures • use a data structure / algorithm which uses dirty tricks under the hood but was already written by somebody else and so you don't have to worry about it • write performance-critical bits in C and link to them. People who *live in this
10:17:57 <indiagreen> universe* do all of those things – when they have to – and in practice they actually most often *don't* have to go to the last “writing this part in C” level, because applying previous solutions turns out to be enough for their purposes. TL;DR there are workarounds for everything so don't be sad
10:18:23 <indiagreen> hm-m-m, this turned out to be a bit longer than I intended, sorry
10:18:32 <Zekka> indiagreen: I thought it was a copypaste for a second!
10:18:48 <Zekka> which you can take as a compliment because it looked pretty prepared
10:19:08 <Cale> I think people fear purely functional data structures a lot more than they ought to usually.
10:19:28 <hiptobecubic> Cale, I think most people have never really thought about them, though.
10:19:45 <hiptobecubic> Certainly not in the context of a language that assumes immutability
10:20:26 <hiptobecubic> that's why people are scared and make the "it copies every time!?" argument over and over and over
10:20:30 <jhance> Luckily you don't need to know how to write a finger tree to use one
10:21:13 <indiagreen> some people (e.g. me) have fear of not being *able* to do something, even if it's never needed. I remember being very upset about GHC-compiled programs parsing “+RTS” command-line arguments, because it meant you couldn't write an “echo” program
10:21:38 <ReinH> indiagreen: good points, most of the crypto code in Haskell, for example, is a relatively thin wrapper around the FFI
10:22:28 <ReinH> indiagreen: (you can call foo -- +RTS though, right)
10:22:36 <benmachine> indiagreen: there were much better reasons to be upset about that, it turned out :P they're turned off by default now, I believe
10:22:37 <jhance> indiagreen: Write program, don't place in path, make shell script or alias from prog -> prog --
10:22:57 <SrPx> indiagreen: I see...
10:22:58 <Cale> or you can build with -rtsopts=none
10:23:07 <indiagreen> I know, I know, it was several years ago and I already came to terms with “write a shell script” as a workaround
10:23:18 <jhance> that or don't write echo
10:23:24 <ReinH> SrPx: The log n upper bound on immutable structures is actually a very *good* result for Haskell!
10:23:26 <indiagreen> jhance: that too
10:23:27 <ReinH> It could be much worse
10:23:47 <jhance> Technically speaking n^100 is also an upper bound on immutable structures.
10:23:50 <SrPx> ReinH: I do not doubt that, it wouldn't even be practical without it (to use purely functional data structures)
10:23:56 <jhance> Lets go hide our children now
10:24:06 <ReinH> jhance: :p
10:24:25 <SrPx> I just think there is still some way to improve on that... particularly, I don't see why a compiler couldn't enable mutability on specific locations that aren't used anymore, for example
10:24:41 <jhance> SrPx: Its an _upper bound_ not the _lower bound_
10:24:45 <ReinH> SrPx: and for things like maps, the log base is high enough that it's basically constant time
10:24:53 <ReinH> tries, etc
10:25:12 <benmachine> SrPx: in theory, it could, but really there are lower-hanging optimisation fruit to pick
10:25:13 <ReinH> SrPx: We can improve on it. It's an upper bound.
10:25:25 <jhance> SrPx: Saying that log n is an upper bound in no way implies that we can't enable mutability on specific locations that aren't used anymore (which we can do, its called unsafeThaw)
10:26:49 <benmachine> functional programming is in part borne of the realisation that certain styles of programming, though fast, are intractable for reasoning about
10:27:07 <benmachine> and hence actually slow because you give up performance for legibility because it was the only way you could fix that weird bug
10:27:52 <benmachine> much of the idea behind Haskell is that you can write code that you can convince yourself is correct *and* compile down to something fast
10:27:58 <benmachine> e.g. using stream fusion
10:28:34 <ReinH> SrPx: and remember that the most common way of achieving this log n factor is replacing an *amortized* constant time structure like a hashtable with a log n structure with a large base like a trie.
10:28:38 <benmachine> so you don't reach theoretical perfect speed, perhaps, but because you have much better tools for abstraction you're able to use better algorithms more frequently
10:29:36 <SrPx> benmachine: I still think purely functional compilation has much to improve, as much as Haskell does a great job of cutting inefficiencies, it doesn't do much in the matter of actually changing the algorithm.
10:30:05 <benmachine> SrPx: oh, sure, perhaps, but changing the algorithm is WAY hairier than it sounds
10:30:27 <SrPx> benmachine: if I implement a naive `fib` in haskell and ask GHC what `fib 100` is, I'd totally want it to give me the answer, but it isn't smart enough to replace my naive implementation by something better. This is something I find frustrating.
10:30:48 <SrPx> I know... it is undecidable, after all.
10:30:51 <Zekka> What do you think of how GHC uses identities (rewrite rules) to replace certain common ineffiiencies with improvements?
10:30:52 <vanila> SrPx, it's too hard to do optimizations like that
10:31:01 <benmachine> SrPx: sure, but it does at least give you the tools that writing something better yourself is easy
10:31:26 <benmachine> SrPx: cf. http://en.wikibooks.org/wiki/Algorithm_Implementation/Mathematics/Fibonacci_Number_Program#Closed-form_version
10:31:45 <exio4> I don't really think randomly changing algorithms with different asymp complexities would be a good thing
10:32:01 <ReinH> SrPx: super compilation is a hard problem everywhere, not just here...
10:32:01 <exio4> I think you'd be basically relying too much in the compiler
10:32:27 <jhance> SrPx: Why do you expect the compiler to change the algorithm?
10:32:34 <SrPx> vanila: hard or impossible, that is the point. Sometime someone will be able to develop a great compiler that does that kind of stuff. So the information is out there somewhere. Maybe it is as few as 100 lines of code. That is something else that I find mind blowing. It is like anytime someone could dig up a alien compiler from a random string generator that would change the world.
10:32:42 <jhance> SrPx: You are the programmer, its your job to get the algorithm right
10:32:47 <bennofs> > let fibs = 0 : 1 : zipWith (+) fibs (drop 1 fibs) in fibs !! 100
10:32:50 <lambdabot>  354224848179261915075
10:33:00 <benmachine> jhance: "you are the programmer, it's your job to get the types right"
10:33:02 <SrPx> jhance: I do not and will never agree with that...
10:33:07 <SrPx> benmachine: thanks
10:33:08 <cdk> SrPx: I think you're asking too much of a programming language to be able to write poor code and have it automatically be replaced by better code. Sounds like a futuristic program writing AI, not anything I'd call a compiler.
10:33:22 <jhance> benmachine: It is your job to get the types right. Its the compilers job to babysit you and check they are right, not to make your types right.
10:33:34 <Zekka> I think the best Haskell can do is include hofs that generally work towards making you do the right thing
10:33:39 <SrPx> jhance: maybe you are a genius but I'm really dumb and limited, with a human mind even... I need types... I need things easy. Sorry.
10:33:55 <jhance> SrPx: I also like types. I don't know what your point is
10:34:01 <benmachine> cdk: I think writing "poor" (readable) code and having it replaced with better (faster) code is exactly what I want GHC to do
10:34:03 * ReinH sighs
10:34:04 <bennofs> I think this will only be possible by having DSL that you can optimize, not by trying to optimize all code using the same rules
10:34:12 <ReinH> Maybe we should take this to #haskell-blah
10:34:17 <ReinH> It hasn't been about haskell for a while now
10:34:33 <benmachine> I think stream fusion is already a bit like supercompilation
10:34:34 <ReinH> I've seen a few other actual questions get buried
10:34:35 <jhance> There is a difference between replacing code with other code that does the same thing and changing the underlying algorithm
10:34:42 <benmachine> and I want to see more like that
10:34:47 <jhance> for example, stream fusion, is not in the latter category
10:35:03 <benmachine> I think ReinH is right
10:35:43 <SrPx> jhance: sometimes you *just* want the answer. "Haskell, tell me the answer of `let fib x = ... in fib 1000`." There is not a reason GHC shouldn't feel free to do the trick, if it just could...
10:35:43 <mbuffett1> Is there any way to start up ghci from a haskell program and have access to stdin from within the haskell program? I've tried runCommand, runInteractiveCommand, runInteractiveProcess, and readProcess, and none of them have worked so far
10:35:50 <tromp> adding memoization is also something the compiler could do
10:36:01 <indiagreen> mbuffett1: you haven't got my @tell, have you
10:36:05 <ReinH> SrPx: (On a practical note, mathematica is great for things like that)
10:36:20 <benmachine> mbuffett1: in what way not worked?
10:36:41 <jhance> SrPx: No, there is a very good reason for it to not do the trick. Its the compilers job to compile what you wrote, not to attempt to interpret it for you, because then the chances that something goes wrong become higher. Moving to #haskell-blah
10:36:45 <mbuffett1> indiagreen : Sorry, new to irc, what's that and how do I get it?
10:36:48 <k00mi> tromp: it's also a pessimization in many cases
10:37:07 <SrPx> I'm jsut saying, I find it amazing that humans can easily convert a naive fib into a good fib and not a single compiler in the world can. I just wish there was some kind of intelligence research that involved that kind of thing, making computers write better algorithms based in naive/brute force applications. The programer's job would then be to write the right questions, not how to compute then. I'm in haskell-blah btw, sorry
10:37:08 <vanila> SrPx, tat's a realy cool think to think about :) I think there is a lot of compiler technologies which has never been used in real compiler yet too
10:37:25 <indiagreen> mbuffett1: it would've been automatic if you logged as “mbuffett” and not “mbuffett1” – anyway, “@tell mbuffet here's a paste which shows how to interact with GHCi in a *very* bad way – http://lpaste.net/113642; if you want it to be nicer, you'll have to parse GHCi's output (i.e. instead of “timeout after 100ms” you might want “wait until GHCi prompt appears”, etc.), so all in all, I suggest you not to try to
10:37:25 <indiagreen> interact with GHCi directly and instead use something like hint or mueval”
10:37:49 <k00mi> tromp: and deciding if it is or is not is an undecidable problem, which is why compilers usually don't do it
10:37:53 <ReinH> mbuffett1: getLine works for me in ghci
10:38:22 <ReinH> SrPx: Are you familiar with research into super compilation?
10:38:49 <benmachine> ReinH: follow your own advice and ask that in #-blah :P
10:38:51 <ReinH> SrPx: moving as well
10:38:52 <SrPx> ReinH: yes :(
10:38:54 <ReinH> benmachine: :p
10:39:29 <mbuffett1> Great, thanks indiagreen. How did you learn about haskell? Any specific tutorials or books you'd recommend?
10:41:45 <ReinH> mbuffett1: for books, look at the Haskell section of http://reinh.com/notes/posts/2014-07-25-recommended-reading-material.html
10:42:07 <ReinH> mbuffett1: I would recommend the 2011 edition of Thompson's book and Richard Bird's new Haskell book when it comes out later this month.
10:42:59 <MP2E> keep meaning to get Bird's new book
10:43:00 <MP2E> it looks great
10:43:54 <c_wraith> bird's new book is already out in electronic form. I've been reading it.  It's solid, but paper would be better.
10:46:36 <mbuffett1> ReinH: Sounds good, I'll check out their book later this month, thanks
10:56:24 * hackagebot ghc-mod 5.2.1.0 - Happy Haskell Programming  http://hackage.haskell.org/package/ghc-mod-5.2.1.0 (DanielG)
11:06:01 <progred> In the lambda calculus (λx.x (λx.y)) (λz.z) reduces to λx.y, which makes sense to me. However my textbook says that (λx.(x λx.y)) (λz.z) also reduces to λx.y, while to me it seems like it should reduce to (x λx.y).
11:06:27 <progred> Any idea what I'm doing wrong?
11:07:38 <vanila> (λx.x (λx.y)) (λz.z) |> (λz.z) (λx.y) |> (λx.y)
11:08:37 <progred> @vanilla I understand that what about (λx.(x λx.y)) (λz.z)?
11:08:37 <lambdabot> Unknown command, try @list
11:08:49 <tromp> (λx.x (λx.y)) is the same as (λx.(x λx.y))
11:09:16 <vanila> yeah, x (λx.y)  is the same as  x λx.y
11:09:31 <vanila> just the brackets there are not needed
11:09:42 <progred> why isn't (λx.(x λx.y)) reduced to (x λx.y))?
11:10:20 <tromp> there's no redex; nothing that can be reduced
11:11:15 <progred> Thanks!
11:18:35 <sigvatr> hi can i compile haskell stuff on windows for linux
11:18:37 <sigvatr> cross compiling?
11:19:25 <Zekka> sigvatr: I don't know offhand how although I think it's possible
11:20:28 <foreignFunction> sigvatr: https://ghc.haskell.org/trac/ghc/wiki/Building/CrossCompiling
11:20:41 <geekosaur> I rhink the only cross compiling that currently works is via llvm?
11:20:51 <mbuffett1> Is haskell open source? If so, how do I find the source for something, say System.Process?
11:21:15 <vanila> mbuffett1, yes GHC is you can find the module on hackage and then click "source"
11:21:28 <vanila> https://hackage.haskell.org/package/process-1.0.1.1/docs/src/System-Process.html
11:21:38 <indiagreen> mbuffett1: hoogle/hayoo System.Process, then there's a button in the upper right corner of every doc page labelled “source”
11:21:53 <indiagreen> as well as a link next to every function/type/etc.
11:21:58 <mbuffett1> Perfect, thanks vanila/indiagreen
11:25:03 <indiagreen> sigvatr: I've never heard of it being possible for Windows → Linux
11:25:24 <indiagreen> I think there's only iOS/ARM cross-compilation for now
11:25:43 <MP2E> Linux -> Windows might work via mingw64
11:25:49 <MP2E> however beware: Template Haskell will not work
11:25:57 <MP2E> in fact, I'd be surprised if it did
11:26:27 <MP2E> needs to be reworked for cross compilation
11:33:29 <lpaste> xendo pasted “pattern matching” at http://lpaste.net/113649
11:33:43 <xendo> Hey guys, I have a question about this code.
11:34:10 <indiagreen> ask away
11:34:34 <xendo> when I try to pattern match in parseErrorMessage, I pass the error, "Error Int"
11:35:07 <xendo> parseErrorMessage err (x:y:zs) = LogMessage err (read y) (unwords zs)
11:35:18 <xendo> so if i just try to drop the x from the pattern match
11:35:31 <xendo> it gets the Int part of Error Int
11:35:56 <xendo> when the first element of the list xs should be the y in the pattern match
11:36:02 <xendo> ....I'm sorry, that's really unclear
11:36:14 <xendo> I'll try to rephrase and ask again in a bit
11:37:31 <xendo> omg...while putting in comments, I just realized my mistake. Ignore me, I'm gonna go back to my corner haha
11:37:43 <monochrom> :)
11:38:00 <MP2E> 'rubber duck' programming is a good method. That is, speaking your problem aloud until the solution comes to you
11:38:26 <MP2E> happens to me a lot too
11:38:36 <monochrom> this is a good method. but only for people who work hard clarifying their questions.
11:38:46 <MP2E> fair enough :)
11:38:47 <AntPao> !list
11:38:47 <monochrom> AntPao: http://hackage.haskell.org/packages/archive/pkg-list.html
11:40:37 <JonReed> What is the difference between "Text.Parsec" and "Text.ParserCombinators.Parsec". Which one should I use?
11:41:01 <indiagreen> the former
11:41:14 <indiagreen> as the latter remains only for backwards compatibility
11:41:23 <JonReed> Ok
11:59:04 <jr_> What is normal order reduction?
12:01:05 <monochrom> it does this: when confronted with "expr1 expr2", reduce expr1 first until it is a lambda, then plug in expr2. do not reduce expr2 before.
12:01:38 <jr_> monochrom: So what can that be used for? Can you please show me a simple example?
12:03:43 <monochrom> ((\x y -> x) (\a -> a) (\b -> b)) ((\c d -> d) s t)
12:04:00 <monochrom> -> (\a -> a) ((\c d -> d) s t)
12:04:07 <monochrom> -> (\c d -> d) s t
12:05:47 <merijn> monochrom: Well, you're skipping "\y -> (\a -> a)" there, no?
12:05:51 <orbital_> hi
12:05:58 <monochrom> yes
12:06:57 <orbital_> a beginner plays with Spock and encounters "Couldn't match type ‘Data.Text.Internal.Lazy.Text’ with ‘Data.Text.Internal.Text’". What's his remedy?
12:07:36 <merijn> orbital_: Don't use lazy Text with libraries that want strict text :)
12:08:04 <monochrom> hire Spock, the Vulcan, to fix it :)
12:08:11 <merijn> orbital_: There's two implementations of Text, a lazy one and strict, as you can see the first module name has Lazy in it and the second doesn't, so you're inadvertently mixing them :)
12:08:11 <orbital_> :-D
12:08:37 <merijn> orbital_: Likely the fix is "import the other one" and your code should work, unless you're unlucky and mixing two libraries wanting different versions
12:09:11 <orbital_> http://pastebin.com/mVVZPG7t
12:09:16 <merijn> orbital_: i.e. if your code current imports "Data.Text" try "import Data.Text.Lazy" or vice versa
12:09:40 <orbital_> (trying to adapt an example from scotty tutorial)
12:09:46 <merijn> Ah, looks like you're in the unlucky other case
12:09:52 <merijn> Can you pastebin the error too?
12:13:13 <orbital_> http://pastebin.com/jinagDgg
12:13:23 <orbital_> added the error
12:13:45 <orbital_> the line counts don't match, but it's the line with 'renderHtml'
12:15:33 <merijn> orbital_: Right, so "S.html" wants a strict Text, but "renderHtml" from Blaze is returning a lazy text, so you need to convert
12:15:42 <merijn> orbital_: You'll want Data.Text.Lazy.toStrict
12:15:50 <merijn> :t Data.Text.Lazy.toStrict
12:15:53 <lambdabot> Data.Text.Internal.Lazy.Text -> Data.Text.Internal.Text
12:16:05 <orbital_> merijn: thanks!
12:16:18 <mbuffett1> Hey guys, I'm trying to make Go (the game, not the language) in Haskell, and I'm having trouble with getting the player's intended move. Haskell complains about the type being IO, but I thought that binding with <- took care of the IO thing. I'm a bit over my head, the code is here : http://lpaste.net/113650. The error I get is on line 47, GHC complains about the type being of IO Piece instead of Piece.
12:16:24 <mbuffett1>  Any help appreciated
12:16:36 <merijn> orbital_: You always have to be a bit careful to check which "type" of Text/ByteString functions want
12:17:03 <merijn> mbuffett1: It helps to include error messages :)
12:17:07 <indiagreen> mbuffett1: shouldn't it be “playerGameLoop :: Game -> IO String”?
12:17:23 <codygman> I'm using dom selector like this: queryT [jq| input[name="inputAttributeName"] |] and was wondering if I can use variables within the quasiquoting.
12:17:48 <mbuffett1> Oh do I have to add IO whenever part of a function uses anything related to IO?
12:17:57 <merijn> codygman: Lucky you, if I remember correctly I recently read a blogpost about exactly this
12:18:06 <indiagreen> mbuffett1: you do
12:18:19 <merijn> codygman: Not entirely sure if it's what you meant, but: http://www.well-typed.com/blog/2014/10/quasi-quoting-dsls/
12:18:32 <indiagreen> which is why you might want to keep as many things as possible IO-free
12:18:58 <codygman> merijn: Thanks in any case, I'm sure it'll be useful :
12:20:08 <mbuffett1> Thanks, so if I have like a chain of four or five functions and the very last one uses IO, all four before it have to include IO too?
12:20:36 <merijn> mbuffett1: Design clue: You may want to design a function "Game -> PlayerMove -> Game" and then have an IO loop that prompts for player input, calls that function with the current Game and the move it just read and then recurses
12:21:31 <merijn> mbuffett1: i.e. "gameLoop :: Game -> IO (); gameLoop game = do { move <- readPlayerMove; gameLoop (updateFun game move) }"
12:24:16 <mbuffett1> That does look better than what I have right now, the updateFun wouldn't have to have IO in it's type signature right?
12:25:17 <merijn> mbuffett1: Correct, updateFun would be my "Game -> PlayerMove -> Game" type
12:26:22 <merijn> mbuffett1: So yes, the answer to "if I have a chain of four/five functions and the last uses IO means they all have to be IO?" is yes, but the even realer answer "well, you should me trying to move the IO outside of those functions" :)
12:26:27 * hackagebot half 0.2 - Half-precision floating-point  http://hackage.haskell.org/package/half-0.2 (EdwardKmett)
12:26:31 <merijn> s/me/be
12:28:25 <mbuffett1> Great, I'll try that out and I'll probably be back with more beginner questions later haha. Haskell's definitely the hardest language I've tried to learn, but it also has the most helpful community I've seen, so thanks for helping a beginner out.
12:29:44 <merijn> mbuffett1: I don't think it's fundamentally harder than other languages, it's just the for the first time since learning your first language your learning something that's wildly different from the languages you knew :)
12:30:37 <mbuffett1> Hey merijn, I'm an idiot and forgot to copy your design clue advice before exiting irc, would you mind pasting it?
12:31:48 <merijn> mbuffett1: http://ircbrowse.net/day/haskell/today :)
12:34:19 <xendo> how often are trees used in Haskell?
12:34:29 <mauke> 3 every second
12:34:42 <merijn> xendo: Depends on the problem domain
12:34:43 <xendo> (just starting to learn them now, and the basic explanation I got was somewhat confusing)
12:34:44 <ij> how often are trees used in software at all, is probably a good question as well.
12:34:55 <merijn> Trees are used tons
12:35:15 <xendo> okay, I *think* I'm getting it
12:35:16 <mauke> have you ever used files?
12:35:21 <mauke> and directories?
12:35:29 <xendo> good point mauke
12:35:38 <merijn> Compilers (they're called Abstract Syntax *Trees* for a reason), HTML DOM, file system
12:36:33 <MP2E> making games would probably require the use of trees as well
12:37:45 <LadyAurora> trees are so 1980
12:38:01 <orbital_> merijn: that worked like a charm. Could Hoogle have found that? I tried hoogling for "Data.Text.Internal.Lazy.Text -> Data.Text.Text" and got nowhere.
12:39:53 <merijn> @hoogle Data.Text.Internal.Lazy.Text -> Data.Text.Internal.Text
12:39:55 <lambdabot> Parse error:
12:39:55 <lambdabot>   Data.Text.Internal.Lazy.Text -> Data.Text.Internal.Text
12:39:55 <lambdabot>        ^
12:40:00 <merijn> heh, odd
12:40:02 <orbital_> yep
12:40:20 <merijn> orbital_: Might just be one of those stupid things you just need to remember
12:40:55 <orbital_> i had to remember so many stupid things that i forgot most of them
12:41:42 <orbital_> merijn: but I can live with that :)
12:44:54 <orbital_> an offtopic emacs question: has anyone been able to get autocomplete to recognize ido-style inputs? i.e., once autocompletion starts on 'f', typing 'b' matches candidate 'foobar'
12:45:53 <Kototama> hi, i got this error when installing wreq http://paste2.org/UAZOpEwO any ideA?
12:46:27 <LadyAurora> orbital_: no, but if I wanted that I'd use ac-helm
12:46:28 * hackagebot sifflet-lib 2.2.1 - Library of modules shared by sifflet and its  tests and its exporters.  http://hackage.haskell.org/package/sifflet-lib-2.2.1 (GregoryWeber)
12:46:30 * hackagebot sifflet 2.2.1 - A simple, visual, functional programming language.  http://hackage.haskell.org/package/sifflet-2.2.1 (GregoryWeber)
12:46:57 <LadyAurora> assuming that by "autocomplete" you mean auto-complete and not company
12:47:12 <orbital_> LadyAurora: yes, auto-complete
12:47:15 <orbital_> sorry
12:49:12 <m_m> Hi. I have a small problem with set created from list (Set.fromList). I would like to multiply all values in my set. So i thought that foldl (*) mySet shoud be ok. It isn't. I can't use folds on sets  ?
12:49:54 <LadyAurora> Data.Foldable.foldl?
12:50:03 <LadyAurora> disclaimer: I don't know Haskell
12:50:30 <mauke> that looks like it's missing a base case
12:50:39 <orbital_> LadyAurora: thanks, i'll check out ac-helm
12:51:28 * hackagebot EqualitySolver 0.1.0.1 - A theory solver for conjunctions of literals in the theory of uninterpreted functions with equality  http://hackage.haskell.org/package/EqualitySolver-0.1.0.1 (dillonhuff)
12:57:20 <LadyAurora> orbital_: at any rate, surely an Emacs channel would be a better place to ask this question?
13:01:28 * hackagebot EqualitySolver 0.1.0.2 - A theory solver for conjunctions of literals in the theory of uninterpreted functions with equality  http://hackage.haskell.org/package/EqualitySolver-0.1.0.2 (dillonhuff)
13:01:30 * hackagebot safe-access 0.2.0.0 - A simple environment to control access to data  http://hackage.haskell.org/package/safe-access-0.2.0.0 (thoferon)
13:01:41 <orbital_> LadyAurora: one would think so, but to date i have not had a single question answered there. Odd.
13:02:16 <orbital_> that makes asking here infinitely more fruitful :)
13:04:37 <TPC> hi, I need help with a class assignment involving quickcheck and doubles, the assignment involves comparing two doubles and seeing if they are the same, the assignment said to check if they are within 0.001 of each other to account for rounding errors
13:04:45 <TPC> (I hope that line wasn't so long that it got cut)
13:04:48 <LadyAurora> tbf I'd try emacs.SE or /r/emacs
13:05:16 <TPC> however I find that for some inputs that quickcheck generates the numbers to be compared are very large, and some of these fails the test
13:05:44 <LadyAurora> I want a Haskell assignment
13:06:26 <TPC> I'm thinking that the numbers are so large that double doesn't have high enough precision to accurately store them them to 0.001 precision
13:06:46 <LadyAurora> atm I'm struggling with physics
13:07:04 <TPC> so I'm thinking I should round them to a certain amount of significant digits instead, is there a standard function that can do this?
13:07:07 <LadyAurora> Why the hell do I even need physics for.
13:07:18 <TPC> and do you agree with my assessment or am I likely doing something wrong?
13:08:17 <LadyAurora> TPC: I'd compare the difference in ULPs, not the absolute difference
13:10:48 <TPC> LadyAurora, ok, I'll google that, thanks
13:11:21 <LadyAurora> crap, I'm helping people?
13:11:32 <LadyAurora> I think I need to see my doctor.
13:12:03 <benzrf> LadyAurora: you said you want a haskell assignment
13:12:42 <LadyAurora> yes
13:12:50 <benzrf> have you already implemented a lisp
13:13:35 <LadyAurora> a lithp?
13:15:00 <benzrf> heh heh
13:16:29 * hackagebot fixed 0.1 - Signed 15.16 precision fixed point arithmetic  http://hackage.haskell.org/package/fixed-0.1 (EdwardKmett)
13:17:32 <merijn> hah
13:17:57 <merijn> Apparently the type checkers error reporting has a class of erros called "utterly wrong" :)
13:18:14 <benzrf> merijn: such as
13:19:59 <recursion-ninja> I'm trying to install the regex-pcre libray via cabal and the package fails to install because thereis the -Werror flag passed to GHC and the package generates a warning "-fglasgow-exts is depreciated". How can I turn off the -Werror when installing via cabal
13:20:18 <thsig> hey guys, I'm trying to install unix-time-0.3.4, running into this error:
13:20:21 <lpaste> thsig pasted “No title” at http://lpaste.net/113651
13:21:35 <merijn> benzrf: I dunno, I don't understand half this code :D
13:21:49 <thsig> heh ok
13:21:59 <merijn> recursion-ninja: By running "cabal get" and editing the cabal file
13:22:10 <thsig> I'm trying to get started with stackage and yesod, just following the vanilla instructions
13:22:16 <merijn> recursion-ninja: Although that sounds like a package that's not being maintained very well
13:22:17 <thsig> doing this on OSX, wonder if that's relevant
13:22:25 <merijn> -fglasgow-exts has been deprecated for a while now
13:22:26 <recursion-ninja> merijn: grr... that's what I didn't want to do...
13:22:34 <merijn> Like, several years
13:22:58 <merijn> thsig: Just a heads up, there's a #yesod channel on freenode :)
13:23:27 <merijn> thsig: OSX instructions should be pretty much identical to linux instructions for the majority
13:23:32 <recursion-ninja> merijn: the most recent version of regex-base give me the same warning, could it be something with my GCH version?
13:23:56 <merijn> recursion-ninja: -fglasgow-exts has been deprecated by GHC for a few years
13:24:06 <merijn> recursion-ninja: So any GHC since then emits a warning
13:24:32 <merijn> recursion-ninja: If the package author was...unwise enough to add -Werror to their compilation flags *and* not update their code, then it will keep erroring
13:24:42 <recursion-ninja> merijn: I hatecabal hell
13:24:52 <recursion-ninja> merijn: That seems to be the case...
13:24:53 <merijn> recursion-ninja: What does cabal hell have to do with this?
13:25:11 <recursion-ninja> I can't resolve dependancies because of the package error
13:25:13 <LadyAurora> cabal hell
13:25:20 <LadyAurora> please make it a real command
13:25:32 <merijn> recursion-ninja: You're trying to use a package which 1) seems to have been abandonned by the author and 2) the author wrote the package description in a brittle and future incompatible wya
13:25:37 <recursion-ninja> LadyAurora: haha
13:25:42 <merijn> recursion-ninja: How are any of those things cabal's fault?
13:26:29 * hackagebot fixed 0.1.0.1 - Signed 15.16 precision fixed point arithmetic  http://hackage.haskell.org/package/fixed-0.1.0.1 (EdwardKmett)
13:29:08 <thsig> merjin: Thanks! I'll check that out
13:29:44 <pharaun> seems like its worth it taking over ownership of that package if you depend on it or see if there's more modern regex packages?
13:29:50 <recursion-ninja> merijn: I fetched the package, unpacked it, removed -Werror, and everything went fine
13:30:02 <recursion-ninja> merijn: Dumb package manitainer...
13:30:31 <pharaun> recursion-ninja: well it was valid a long time ago, and you can always take ownership and upkeep that package you know :)
13:32:15 <joe9>  /ping johnw
13:34:24 <LadyAurora> who killed preflex?
13:35:24 <merijn> LadyAurora: It was hosted on mauke's desktop and disappeared when that machine died
13:36:36 <pharaun> who is preflex
13:36:41 <merijn> pharaun: Bot
13:36:54 <pharaun> ah
13:41:04 <Wingsorc> is it not possible to compose two functions, the first one taking two bools to one and the second one a bool to another bool?
13:41:41 <merijn> "Is it possible?", sure, is it possible with whatever approach you were trying? Maybe...
13:42:37 <fread2282> is n-argument (.) possible in haskell?
13:42:45 <merijn> Sure
13:42:48 <DTSCode> where is the gmp library for haskell? i have not been able to find it
13:42:54 <merijn> It's horrifically ugly, but still
13:43:00 <merijn> DTSCode: What do you mean?
13:43:36 <DTSCode> merijn, ./configure is telling me i need libgmp
13:43:55 <Wingsorc> I have the function not :: Bool -> Bool and and :: Bool -> Bool -> Bool. nand = not . and  seems not to work
13:43:56 <qsuscs> why does this fail? http://pastie.org/private/sw8tsrwdnuiuvvfylhcbya
13:44:02 <merijn> Right, you'll have to install that. A better question is: Why are you trying to compile GHC?
13:44:03 <fread2282> DTSCode: are you building GHC from source?
13:44:28 <merijn> Wingsorc: Because one you give and one argument it's still a function
13:44:38 <DTSCode> im not trying to install it. i downloaded the 7.4 binaries package
13:44:39 <merijn> Wingsorc: You'll want "nand x = not . and x"
13:44:46 <Saizan> DTSCode: that libgmp is a C library
13:44:52 <DTSCode> http://paste.ubuntu.com/8794146/
13:44:58 <DTSCode> Saizan, how do i fix that then?
13:45:07 <bernalex> how can I check if the program was started with something via stdin?
13:45:19 <bernalex> i.e. I want to check if the user did "echo lol | program"
13:45:33 <Wingsorc> merijn: so I can compose only functions of type a->a ?
13:45:39 <Wingsorc> withouth additional arguments
13:45:42 <merijn> bernalex: You mean "I want to check if it's talking to a terminal?"
13:45:56 <merijn> Wingsorc: (.) can only compose functions of a single argument, yes
13:46:11 <ryantm> bernalex, stdin is a handle you can read: https://hackage.haskell.org/package/base-4.5.0.0/docs/System-IO.html
13:46:22 <Saizan> DTSCode: apt-get install libgmp-dev
13:46:23 <merijn> Wingsorc: Are you expecting it to magically guess how many arguments you wanted it to use?
13:46:30 <bernalex> merijn: right. so I have a repl function. and when my program starts, I enter the repl. in the repl the user can communicate with the program using STDIN. what I want to check now is if someone did "echo baa | program", so that there is something "inside" STDIN already.
13:46:33 <merijn> ryantm: That's not really his question, though
13:46:53 <fread2282> DTSCode: did you download the right (64bit probably) version? if you're installing 32bit, do you have the 32bit support libs installed?
13:47:00 <bernalex> basically: cs <- getContents ; case cs of [] -> repl ; _ -> run (words cs)
13:47:07 <bernalex> but I can't use getContents here, obviously
13:47:11 <Wingsorc> merijn: I thougth if I add bool->bool->bool to the resulting functions it could infer that I want to use two arguments
13:47:18 <merijn> bernalex: Why?
13:47:22 <DTSCode> it says that its already installed Saizan. and yes fread2282 i got the 64 bit
13:47:30 <bernalex> merijn: well it will hang when trying to evaluate it if there is nothing in it
13:47:56 <bernalex> "case cs of []", I believe would freeze the program trying to figure out what getContents returned.
13:48:17 <merijn> bernalex: I think you really want to use something like haskelline if you want to do something REPL like
13:49:00 <bernalex> merijn: see http://lpaste.net/3745923772373270528
13:49:08 <bernalex> merijn: the repl works fine.
13:49:26 <bernalex> the specific problem is this
13:49:35 <benmachine> bernalex: I don't think it's possible to distinguish between having something piped in and people just typing really quickly
13:49:51 <merijn> benmachine: Yes it is
13:49:59 <bernalex> the user can start it with args: program foo bar bar. then the "run" is used. if the user starts it with no args -- repl is used. however, the user may run it with *one* arg.
13:50:07 <merijn> benmachine: But "checking whether input is there" is a completely silly way of doing it
13:50:15 <benmachine> merijn: oh, right, yes
13:50:18 <merijn> You need to check whether stdin is a tty
13:50:18 <benmachine> I meant with that check
13:50:25 <bernalex> if the user does program ONE_ARG. then the program needs to figure out, OK, did it pass something in via a pipe or no? and then if it did, use run, if not start the repl.
13:50:48 <thsig> merijn: Figured this out. There was a nonexistent folder in my PATH, worked after I cleaned it out. This put me on the trail: https://github.com/ghcjs/ghcjs/issues/143#issuecomment-55239767
13:50:58 <benmachine> bernalex: this sounds weird and confusing
13:51:08 <bernalex> benmachine: what is weird about it?
13:51:39 <fread2282> DTSCode: are you sure you want 7.4? it's behind the current release by 2 versions
13:51:48 <merijn> bernalex: http://hackage.haskell.org/package/unix-2.7.0.1/docs/System-Posix-Terminal.html#queryTerminal
13:51:53 <benmachine> bernalex: I expect programs to behave the same way when I pipe stuff into them as if I type stuff into them, more or less
13:52:09 <bernalex> ./program -- start the repl. echo blah blah blah | ./program -- run the program on that input. echo blah blah | ./program -foo  -- run the program with "foo blah blah blah...". ./program -foo -- start the repl.
13:52:10 <benmachine> unless they're explicitly interactive programs, in which case I expect it to basically not be useful to pipe stuff into them
13:52:12 <DTSCode> fread2282, i dont want it, but the program im trying to compile only works with that
13:52:20 <bernalex> benmachine: well this program is "special". :-]
13:52:25 <bernalex> merijn: I'll have a peek, thanks.
13:52:28 <benmachine> bernalex: ah, there's your problem :P
13:52:35 <DTSCode> and i didnt write it, and dont know haskell well enough to fix it
13:52:38 <bernalex> benmachine: it makes sense, trust me :-P
13:52:52 <bernalex> merijn: not found
13:52:56 <bernalex> i.e. 404
13:53:06 <merijn> bernalex: http://hackage.haskell.org/package/unix-2.7.0.1/docs/System-Posix-Terminal.html then
13:53:11 <bernalex> 404
13:53:13 <benmachine> bernalex: not for me
13:53:17 <bernalex> If you’re seeing this page, we’ve moved the Hackage server to a new machine/IP address. You should see the DNS changes soon. If you need to you can always contact us, otherwise we’ll be back online shortly!
13:53:18 <benmachine> make sure you're copying it correctly
13:53:25 <benmachine> ah
13:53:25 <benmachine> weird
13:53:31 <bernalex> copying what? I'm not *copying* the URL lol.
13:53:31 <merijn> bernalex: Your ISPs DNS sucks :p
13:53:36 <bernalex> merijn: I'm using tor.
13:53:41 <benmachine> you have super stale DNS, I guess
13:53:44 <benmachine> or something
13:53:50 <merijn> bernalex: Well, looks like you're boned for the next 24-48 hours
13:54:08 <benmachine> you could add an entry in /etc/hosts or something
13:54:12 <merijn> However long the DNS takes to propagate to your tor connection
13:54:27 <benmachine> if it helps, hackage.haskell.org resolves to 104.130.241.19 from here
13:54:29 <bernalex> merijn: yeah or you know... not use tor...
13:54:48 <bernalex> merijn: this function looks very useful. thanks.
13:54:57 <recliner_> can someone explain to me what is going on with this basic fold? http://lpaste.net/113654
13:55:17 <bernalex> merijn: what is the sane way of obtaining STDIN's FD here though?
13:55:58 <geekosaur> System.Posix.IO.stdInput
13:56:42 <fread2282> dTSCode: try libgmp3c2
13:56:45 <bernalex> geekosaur: thanks, I'll try it out
13:58:42 <fread2282> dTSCode: wget -c launchpadlibrarian.net/70575439/libgmp3c2_4.3.2%2Bdfsg-2ubuntu1_amd64.deb && dpkg -i libgmp3c2_4.3.2*.deb             if it's not in the ubunto repos
13:59:01 <fread2282> *ubuntu
14:01:30 * hackagebot FirstOrderTheory 0.1.0.4 - Grammar and typeclass for first order theories  http://hackage.haskell.org/package/FirstOrderTheory-0.1.0.4 (dillonhuff)
14:01:32 * hackagebot DifferenceLogic 0.1.0.2 - A theory solver for conjunctions of literals in difference logic  http://hackage.haskell.org/package/DifferenceLogic-0.1.0.2 (dillonhuff)
14:01:34 * hackagebot fixed 0.2 - Signed 15.16 precision fixed point arithmetic  http://hackage.haskell.org/package/fixed-0.2 (EdwardKmett)
14:19:52 <m_m> Is there anything wront with this trace ? http://lpaste.net/3697708602652360704
14:20:40 <merijn> m_m: Yes, traceShow requires it's argument to be a Show instance and your type signature doesn't guarantee 'a' is a show instance
14:21:06 <m_m> ok how about trace ("x: " ++ show) ? I have the same error
14:21:18 <m_m> * show x
14:22:18 <m_m> int this example http://en.wikibooks.org/wiki/Haskell/Debugging i dont have Show in type sygnature.
14:23:39 <merijn> m_m: That example us using "Int" as type
14:23:48 <merijn> m_m: Int *is* an instance of Show
14:24:10 <merijn> m_m: You're using "Integral a => a -> a -> a" and not all instances of Integral are guaranteed to be an instance of Show
14:24:33 <merijn> You need to either pick a specific type or add "(Show a, Integral a) => a -> a -> a"
14:26:51 <m_m> merijn: I see now. Thank you !
14:27:59 <thsig> About cabal sandboxes: should I have a system-wide sandbox and then project-specific ones, or just project-specific ones? Just wondering what the workflow around them usually looks like.
14:41:26 <sccrstud92> is the carrier object of an initial F-algebra always the codomain of an initial object in the original category?
14:41:31 * hackagebot profunctors 4.3.2 - Profunctors  http://hackage.haskell.org/package/profunctors-4.3.2 (EdwardKmett)
14:43:21 <Cale> sccrstud92: "Codomain of an initial object"?
14:43:45 <sccrstud92> Cale: the result of F(0)
14:43:55 <sccrstud92> where 0 is an initial object in the original category
14:44:14 <Cale> uh, no.
14:44:26 <Cale> In fact, this is almost never the case.
14:44:37 <Cale> Do you have an example of that happening?
14:44:54 <Cale> I suppose it might happen if F is a constant functor
14:45:04 <sccrstud92> no, i just assumed that was most common
14:45:12 <sccrstud92> isnt that the case for the Identity functor?
14:47:43 <Cale> Well, in that case, your initial algebra is indeed the initial object, given that exists, I suppose.
14:47:55 <Cale> That's sort of a weird case to consider
14:49:54 <Cale> The usual first example for F-algebras to consider is what happens with the polynomial functor FX = 1 + X
14:50:01 <Cale> i.e. F = Maybe
14:50:09 <sccrstud92> okay
14:50:45 <Cale> So, an F-algebra here consists of an object A together with a map  a: 1+A -> A
14:51:09 <sccrstud92> so in haskell A is some type
14:51:12 <Cale> yeah
14:51:19 <Cale> Let's actually use Haskell notation
14:51:19 <sccrstud92> and a :: Maybe A -> A
14:51:25 <Cale> yep
14:51:32 * hackagebot fixed 0.2.1 - Signed 15.16 precision fixed point arithmetic  http://hackage.haskell.org/package/fixed-0.2.1 (EdwardKmett)
14:51:32 <sccrstud92> sounds good
14:51:56 <Cale> So, we can determine a uniquely if we know what a Nothing is, and what a . Just is
14:52:06 <Cale> Agreed?
14:52:27 <sccrstud92> im not sure if i know what you mean
14:52:33 <sccrstud92> so you mean we can pattern match?
14:52:37 <sccrstud92> on the constructors?
14:52:40 <Cale> Like, given an arbitrary function a :: Maybe a -> a
14:52:41 <Cale> we
14:52:43 <Cale> er
14:52:46 <Cale> Like, given an arbitrary function a :: Maybe A -> A
14:52:56 <Cale> If I tell you what a Nothing is
14:53:06 <Cale> and I tell you which function  a . Just  is
14:53:20 <Cale> then you can put those pieces back together to get a
14:53:46 <sccrstud92> 1 -> B and A -> B becomes 1 + A -> B
14:53:48 <sccrstud92> ?
14:53:52 <Cale> yes
14:53:56 <sccrstud92> yeah agreed
14:54:27 <Cale> Okay, so let's consider what it would mean for some Maybe algebra to be initial
14:54:58 <sccrstud92> maps uniquely to any other Maybe algebra?
14:55:11 <Cale> Let's call our supposed initial Maybe algebra N, and its structure map n :: Maybe N -> N
14:55:20 <sccrstud92> okay
14:55:30 <Cale> So, yeah, for any other Maybe-algebra A with a :: Maybe A -> A
14:56:23 <Cale> There needs to be a unique map f :: N -> A, such that f . n = a . fmap f
14:57:41 <Cale> Both f . n and a . fmap f are functions of type Maybe N -> A
14:57:52 <sccrstud92> so reducing then applying f is the same as applyning fmap f then reducting
14:57:54 <Cale> let's apply them to Nothing and Just x and simplify a little
14:57:57 <sccrstud92> reducing*
14:58:15 <Cale> So first of all we know that f (n Nothing) = a (fmap f Nothing)
14:58:23 <Cale> But fmap f Nothing = Nothing
14:58:31 <Cale> So f (n Nothing) = a Nothing
14:58:58 <sccrstud92> so f . n = a in the Nothing case
14:59:04 <Cale> uh
14:59:10 <Cale> That's a type error
14:59:26 <Cale> (Note that the type of Nothing is different on each side here)
14:59:36 <sccrstud92> oh i see
14:59:52 <sccrstud92> one is fmapped
14:59:54 <sccrstud92> okay
15:00:00 <Cale> and then we also have
15:00:15 <Cale> f (n (Just x)) = a (fmap f (Just x))
15:00:28 <Cale> f (n (Just x)) = a (Just (f x))
15:01:10 <sccrstud92> uh huh
15:01:36 <Cale> All right, now let's make this all a little more concrete
15:01:48 <Cale> N is actually going to be the natural numbers
15:01:58 <Cale> data N = Z | S N
15:02:06 <sccrstud92> mhm
15:02:09 <Cale> and n will be the map
15:02:15 <Cale> n Nothing = Z
15:02:20 <Cale> n (Just x) = S x
15:02:44 <Cale> So, by the stuff we did above, we need to have:
15:02:50 <Cale> f (n Nothing) = a Nothing
15:02:54 <Cale> f Z = a Nothing
15:02:58 <Cale> and:
15:03:09 <Cale> f (n (Just x)) = a (Just (f x))
15:03:24 <Cale> f (S x) = a (Just (f x))
15:03:42 <Cale> So, together, these give us a recursive definition of f on the natural numbers.
15:03:56 <wswiss> @pl \a -> a
15:03:56 <lambdabot> id
15:03:59 <Cale> and indeed, there's a unique such f
15:04:34 <Cale> Does that make sense?
15:04:51 <hexagoxel_> default smart constructor naming is `fooBar` for type `FooBar`? or `makeFooBar`?
15:05:13 <jle`> i've seen both
15:05:23 <Cale> Sometimes also mkFooBar
15:05:33 <jle`> ah yes. mk more often than make
15:05:34 <Cale> Whatever makes sense for yu
15:05:36 <Cale> you*
15:05:51 <Cale> There might also be an even better name
15:06:08 <sccrstud92> so what turned out to be the initial Maybe algebra?
15:06:16 <Cale> sccrstud92: The natural numbers
15:06:25 <Cale> sccrstud92: Together with the n that I gave
15:08:11 <wswiss> @pl (\s -> p s >>= (\(s',x) -> q (f x) s'))
15:08:11 <lambdabot> (uncurry (flip (q . f)) =<<) . p
15:08:43 <sccrstud92> Cale: so its (N, maybe Z S)
15:08:50 <Cale> yes
15:08:52 * hexagoxel_ tries to figure out what convention the project uses
15:10:00 <sccrstud92> Cale: can you construct an initial algebra for Maybe for any carrier object?
15:10:09 <sccrstud92> carrier type*
15:10:25 <wswiss> @pl \s -> either (p s) (const $ q s) Right
15:10:25 <lambdabot> flip (liftM2 either p (const . q)) Right
15:10:28 <Cale> hm?
15:10:39 <Cale> There's only one initial algebra of Maybe up to isomorphism
15:11:01 <Cale> (in general, initial objects are unique up to isomorphism)
15:11:03 <sccrstud92> Cale: is that true for all functors?
15:11:08 <Cale> yes
15:11:29 <Cale> In any category, the initial object if it exists is unique up to unique isomorphism
15:11:41 <sccrstud92> right
15:12:45 <wswiss> @pl \s -> left (const $ q s) (p s)
15:12:45 <lambdabot> ap (left . const . q) p
15:12:51 <sccrstud92> so in ur example, both Maybe and N have the same number of constructors
15:12:54 <sccrstud92> is that important?
15:13:17 <sccrstud92> or did you just pick that because it was easy
15:13:35 <Cale> That is actually pretty relevant
15:13:59 <sccrstud92> how so
15:14:09 <Cale> In the case of polynomial functors, you always get an initial algebra by taking a sort of fixed point
15:14:54 <wswiss> @pl \e -> P $ const $ Left e
15:14:54 <lambdabot> P . const . Left
15:16:07 <sccrstud92> Cale: by polynomial functors you mean functors defined with algebraic data types?
15:16:09 <wswiss> @pl \x -> P $ Right $ (flip (,)) x
15:16:09 <lambdabot> P . Right . flip (,)
15:16:24 <Cale> kinda, I mean sums of products specifically
15:16:43 <sccrstud92> what other kinds of functors are there in haskell?
15:17:06 <sccrstud92> off the top of my head it seems like everything is a sum of product
15:17:08 <Cale> Stuff involving function types and recursion of various sorts
15:17:12 <sccrstud92> sum or product*
15:17:17 <Cale> What are lists?
15:17:42 <sccrstud92> Y X = 1 + X * Y
15:17:58 <Cale> Y X = 1 + X * Y X
15:17:59 <sccrstud92> Y X = 1 + X * Y X
15:18:09 <sccrstud92> oops =)
15:18:29 <Cale> So, that involves recursion as well
15:18:41 <Cale> Not just sums and products
15:18:47 <sccrstud92> hmm okay
15:21:23 <jrib> does anyone know of some equivalent for python's os.path.expanduser (expands ~ and ~user in paths)?  I can't find anything in System.FilePath; best I could find was glob from HSH but it does more
15:21:32 <nshepperd> [A] = 1/(1-A) hmmm
15:21:36 <Cale> and in fact, the lists-of-X type itself can be thought of as the initial algebra for the functor FY = 1 + X * Y
15:21:59 <Cale> nshepperd: yep
15:22:11 <Cale> nshepperd: and 1/(1-A) = 1 + A + A^2 + A^3 + ...
15:24:34 <merijn> ugh
15:24:40 <merijn> Singletons needs cleaner haddock
15:24:47 <merijn> It's impossible to find the things I care about
15:25:16 <benmachine> Cale: I showed that to one of my lecturers once and he looked at me like I'd done some sort of dark and evil magic
15:25:50 <merijn> btw
15:26:11 <Cale> benmachine: heh
15:26:23 <merijn> Well, I was going to ask whether people thought that using singletons just to repurpose their Sing data family and SingI class was overkill
15:26:42 <merijn> But considering the compile for singletons just failed on my machine, I guess I might as well just define my own versions...
15:26:43 <Cale> benmachine: Also, the derivative of x^3 = x*x*x is 3*x^2 because there are three ways to delete an x and each way results in x^2 :)
15:26:53 <Cale> i.e. it's 1*x*x + x*1*x + x*x*1
15:27:34 <merijn> Out of curiosity, does singletons build for anyone else on 7.8.3?
15:27:42 <benmachine> Cale: that actually sounds substantially less crazy than Taylor-expanding a fraction of types whose denominator involves subtraction
15:29:01 <tiqs> are there any articles on parsing indentation-based languages with parsec?
15:32:18 <merijn> Argh
15:32:28 <merijn> Why can't haskell have indexed records? :(
15:32:41 <tiqs> cause ur face
15:32:45 <Rembane> We got it for our sins.
15:41:07 <tac_> @faq Can Haskell have indexed records?
15:41:08 <lambdabot> http://www.haskell.org/haskellwiki/FAQ
15:41:12 <tac_> hmmmm
15:41:33 * hackagebot binary-list 0.4.0.0 - Lists of length a power of two.  http://hackage.haskell.org/package/binary-list-0.4.0.0 (DanielDiaz)
15:41:35 <tac_> I missed that change in the lambdabot patch notes
15:42:01 <merijn> tac_: Also, the answer is not "yes"
15:46:33 * hackagebot sdl2 1.2.0 - Low-level bindings to SDL2  http://hackage.haskell.org/package/sdl2-1.2.0 (Polarina)
15:49:53 <merijn> Does anyone know if it's possible to demote a kind to it's corresponding type? i.e., how to demote the kind Bool to the type Bool?
15:50:50 <jxv> merijn, like a const for types?
15:51:07 <jxv> idk, just curious too
15:51:24 <merijn> huh?
15:51:33 <jxv> :t const
15:51:35 <lambdabot> a -> b -> a
15:51:40 <jxv> :t seq
15:51:41 <merijn> I don't understand what you mean by "const for types"?
15:51:42 <lambdabot> a -> b -> b
15:52:01 <jxv> Then, I don't what you mean either.
15:52:18 <merijn> I don't see how that's related? "const for types" is trivial to implement
15:52:39 <jxv> or like "K -> Bool" to "* -> Bool"?
15:52:58 <merijn> jxv: I want a way to convert "Bool :: BOX" (kind Bool of sort BOX) to "Bool :: *" (type Bool of kind *)
15:53:40 <merijn> So "Bool -> *" where the resulting * is "Bool"
15:53:41 <nshepperd> what are indexed records
15:53:58 <merijn> nshepperd: Record where the number/type of fields depends on a type parameter
15:55:16 <nshepperd> like GADTs?
15:55:44 <merijn> nshepperd: Yes, except that GADTs can't share fields between differently typed constructors
16:00:22 <nshepperd> hmm
16:01:41 <nshepperd> I assume "data Foo a = A { bar :: a } | B { bar :: a, qux :: b }" isn't helpful
16:02:05 <merijn> nshepperd: That's not a GADT
16:02:15 <merijn> nshepperd: So I have no way to statically guarantee anything
16:04:38 <nshepperd> you can't do the same thing in a GADTy way?
16:05:04 <merijn> No
16:05:10 <merijn> GHC can't handle that
16:06:57 <nshepperd> oh, it complains about "common field bar, but different result types"
16:07:04 <nshepperd> that's a shame
16:23:09 <gamegoblin> Is there a haskell equivalent to getting the unix epoch? i.e. the number of seconds since 1970?
16:23:26 <gamegoblin> just some IO Int
16:23:39 <sbrg> getClockTime
16:23:44 <sbrg> System.Time
16:23:56 <sbrg> iirc
16:24:31 <sbrg> wait, that's old, maybe
16:24:44 <gamegoblin> Says it’s deprecated, yeah
16:25:46 <sbrg> gamegoblin: https://www.haskell.org/ghc/docs/latest/html/libraries/time-1.4.2/Data-Time-Clock-POSIX.html
16:26:15 <gamegoblin> thanks
16:28:34 <pharpend> Hey guys
16:29:16 <pharpend> There's some missing functionality in a library (time, to be specific). I patched the code with the functionality. How do I tell cabal "instead of the time in hackage, use the time that I wrote"
16:29:43 <pharpend> IIRC, I just have to put the directory somewhere, but googling has revealed no results
16:30:08 <Cale> You can install a newer version of time locally that you wrote yourself
16:30:30 <pharpend> Cale: Yes
16:30:34 <Cale> If it's not selecting that one, possibly it's due to an upper bound constraint on another package.
16:30:57 <pharaun> using cabal sandbox?
16:30:59 <pharpend> Cale: I vaguely remember something where you put it in dist/build or something?
16:31:29 <Cale> btw, what was missing from time?
16:31:38 <pharpend> Eq and Ord instances for ZonedTime
16:31:41 <pharpend> trivial additions
16:31:44 <pharpend> but nonetheless annoying
16:31:52 <pharpend> you know what, I could just put the instances in my code for the time beild
16:31:54 <pharpend> *being
16:32:07 <pharaun> I wonder how Time stacked up to like JodaTime, been pondering bout looking into contributing stuff to it
16:32:12 <jle`> is foo :: State s () basically guarunteed to be a no-op
16:32:29 <pharpend> pharaun: I am
16:32:31 <jle`> or maybe put `bottom` into the state
16:32:37 <edwardk> jle`: if it doesn't know s?
16:32:44 <jle`> yeah, foo :: forall s. State s ()
16:32:49 <jle`> sry
16:32:54 <edwardk> jle`: it could destroy or force the state thats about it
16:33:02 <jle`> ah yeah.
16:33:12 <jle`> because everything is seq-able
16:33:15 <simpson> Also launching missiles.
16:33:18 <edwardk> so other than bottoms or seq, yes
16:33:29 <jle`> can't we have Seq be a typeclass
16:33:38 <pharpend> Cale: I submitted a patch, but who knows when (or if) it'll be merged
16:34:10 <edwardk> jle`: it used to be. but then we got data type contexts to make that make sense, and they were bad
16:34:43 <joe9> Can someone please give  a few examples explaining delimited continuations. Even if the examples here https://www.fpcomplete.com/user/jwiegley/understanding-continuations are written using delimited continuations, then that would help.
16:34:52 <jle`> i see
16:35:03 <merijn> edwardk: Not just that
16:35:26 <merijn> edwardk: I heard the main argument against a Seq dataclass was that adding strictness deep inside a function meant adjusting all types for Seq'ability
16:35:29 <jle`> can we make Bottomable be a typeclass too
16:35:54 <edwardk> merijn: yeah that was the argument hughes' students put forth at the time as mentioned by the "History of Haskell" paper
16:36:34 <jle`> just only allow recursion for functions marked as Bottomable
16:36:53 <jle`> kind of like how you need Monad m => to do do notation
16:36:56 <edwardk> jle`: you're trying to make haskell total, that isn't going to happen =P
16:38:08 <simpson> Just like "fetch."
16:38:35 <jle`> fetch is going to happen
16:39:04 <indiagreen> what's fetch
16:40:05 <edwardk> thats so fetch
16:40:32 <merijn> indiagreen: A Mean Girls reference :)
16:41:34 <merijn> ugh, so singletons-1.0 doesn't install for me (in fact, it panics GHC), but a friend with an identical system (same dependency versions, same OS version, same GHC version) *can* compile it. I'm lost :\
16:41:44 <edwardk> indiagreen: https://www.youtube.com/watch?v=jjt9Qx9MBPk&t=20s
16:41:52 <simon> in 'type Transducer a b = forall r . (r -> a -> r) -> (r -> b -> r)
16:41:54 <hiptobecubic> A surprisingly good movie, i'd say.
16:41:58 <simon> what does the 'forall r' do?
16:42:01 <hiptobecubic> From before she went completely off the rails
16:45:05 <merijn> simon: Makes it polymorphic
16:45:34 <simon> I feel weird, remembering the "fetch" reference, but not remembering which teen movie it came from, as if I'd seen an overwhelming amount of them.
16:45:38 <merijn> simon: So it only has to work for one specific 'a' and 'b', but all possible 'r'
16:45:47 <pharpend> simon: I recommend you change your nick, or else people around here will think you are an expert.
16:46:15 <pharpend> sshine: not to imply that you aren't an expert, but, yeah
16:46:18 <sshine> pharpend, I registered 'sshine' for when people on #haskell say that (or rather, when the say "Wow, are you Simon <X>??" for some impressive X)
16:46:20 <Welkin> when performing user authentication in a web app, is it better to use a third-party system (OpenID, etc.) or roll your own?
16:46:26 <pharpend> sshine: haha
16:46:41 <edwardk> sshine: hah
16:46:43 <Welkin> rolling my own is a pain for me, but what about users?
16:46:51 <sshine> pharpend, I've had "simon" for 10+ years, though, and I only have the problem on #haskell, so I'm sort of sticking to it. :)
16:46:55 <Welkin> how many people actually use OpenID or similar services?
16:47:05 <Welkin> I don't use any of them
16:47:16 <pharpend> Welkin: if you are talking about yesod, rolling your own isn't too bad, just don't use yesod-auth, it's a pain
16:47:31 <Welkin> really? what is wrong with yesod-auth?
16:47:31 <pharpend> Welkin: I would even go so far as to say that rolling your own is easier
16:47:45 <Welkin> I have always had a rough time with user auth
16:47:46 <sshine> Welkin, do you mean in terms of what's neater to implement or what's better from a UX POV?
16:47:53 <pharpend> Welkin: try using it, you'll see. It's like Yesod's normal type tetris but just 50x worse
16:47:53 <Welkin> my least favorite part of building websites
16:48:08 <Welkin> sshine: both
16:48:21 <pharpend> Welkin: >least favorite part; As if to imply that any part of web development is enjoyable.
16:48:28 <Welkin> security is always a pain
16:48:38 <Welkin> pharpend: it is, at least in haskell
16:48:57 <pharpend> Yesod is, IMO, by far and away the best web framework out there. But, it's still a pain
16:49:00 <Welkin> I love building CRUD apps and desiging the layout of the page, adding user interaction through js
16:49:11 <sshine> pharpend, I prefer Snap.
16:49:11 * pharpend segfaults
16:49:32 <Welkin> it's fun in haskell to build CRUD apps
16:49:33 <pharpend> sshine: snap isn't too bad
16:49:35 <Welkin> not so in other languages
16:49:45 <sshine> Welkin, I agree. I also don't mind making them in Java. :)
16:49:47 <Welkin> well, at least with yesod and all of its nice built-in features
16:50:03 <pharpend> Rails breaks like every hour or two
16:50:26 <pharpend> Every java app I've seen is painfully slow
16:50:27 <sshine> pharpend, you mean the application server dies?
16:50:29 <joe9> Anyone who understands "delimited continuations" and could write a few examples to illustrate, please?
16:50:39 <pharpend> sshine: no, they push out api-breaking changes to Rails
16:50:52 <pharpend> sshine: also, no tco in ruby, no type safety, etc
16:51:13 <sshine> pharpend, I had a course last year where we built app servers in Java. we got some pretty decent throughput.
16:51:29 <pharpend> edwardk: what is pdpc? I googled it and got Process Decision Program Chart, but I don't imagine that's what you're referring to
16:51:32 <Welkin> so what is a clean, easy solution to implement user authentication? I don't know anything about the existing third-oparty providers or have experience using them.
16:52:07 <pharpend> Welkin: >clean, easy solution; > user authentication; > unicorns; >flying pigs ;
16:52:22 <Welkin> and when would it be advantageous to implement my own? if ever?
16:52:50 <pharpend> Welkin: if you are storing confidential data (Credit Card Numbers, for instance), do it yourself
16:53:02 <trap_exit> so insted of doing squats daily, I started doing them every other day
16:53:03 <Welkin> well, I am using stripe for payments
16:53:09 <trap_exit> and within a week, my set repeition # tripled
16:53:10 <Welkin> so I can store the data on their servers I believe
16:53:14 <Welkin> and access it with a token
16:53:19 <trap_exit> I can now do 3 sets, each of 6 reps, each with 2 * 85 pounds
16:53:29 <trap_exit> wrong channel, manet fo #fitness
16:53:31 <pharpend> Welkin: otherwise, it's probably easier for everyone to use openid
16:53:31 <trap_exit> sorry
16:53:42 <pharpend> trap_exit: I was about to yell at you to take this to #haskell-blah
16:54:09 <trap_exit> pharpend: use webchat, finger memory puts #haskell, instead of #fitness for the channel; sorry
16:54:19 <trap_exit> sometimes, I talk about ebola stuff here too by accident
16:54:41 * pharpend slaps trap_exit for talking about ebola
16:55:09 * pharpend unless s?he is yelling at people who are perpetuating the fear
16:55:12 <trap_exit> at this rate, skin contact will soon be enough to transmit
16:55:41 <pharpend> okay, fine, I'll happily discuss this in #-blah
17:01:17 <merijn> Is there a way to silence "Defined but not used" warnings resulting from TH splices?
17:02:36 <pharpend> merijn: look in the man-page for ghc
17:02:46 <orbital_> ugh.. why isn't there a way to navigate up the package in hackage
17:02:49 <pharpend> I imagine it's like -fno-warn-defined-unused or something
17:02:53 <pharpend> orbital_: there is
17:03:00 <orbital_> pharpend: oh?
17:03:08 <pharpend> orbital_: I think you press "contents" in the top right corner"
17:03:14 <pharpend> s/er"/er
17:03:28 <orbital_> ah.
17:03:34 <merijn> pharpend: Right, but that would silence *all* of them
17:03:46 <orbital_> pharpend: thanks
17:03:47 <merijn> pharpend: I want to silence *only* those produced by template splices
17:04:15 <orbital_> so many things that could have been clickable... *grumble*
17:04:51 <geekosaur> you could file a bug/enhancement request
17:05:24 <merijn> geekosaur: Right, but I was first asking to see if there was already a solution before doing that
17:05:33 <geekosaur> https://github.com/haskell/haddock/issues
17:05:36 <orbital_> geekosaur: i will, once i evolve past the wide-eyed newcomer
17:05:37 <geekosaur> sorry I meant orbital_
17:14:25 <pharpend> hmm
17:17:11 <TallerGhostWalt> Is there a story behind the decision to use (::) and not (:) for type sigs?
17:20:59 <merijn> TallerGhostWalt: :: is to verbose as list constructor
17:23:10 <TallerGhostWalt> merijn: but aren't type definitions used more than list definitions?
17:23:32 <merijn> TallerGhostWalt: You only need one :: per type annotation, but frequently many : for a list
17:24:32 <TallerGhostWalt> merijn: right but I need lots of :: for a record and seldom go past (x:xs) notation for a list.  obviously this isn't important! Just reading some elm code and got curious
17:25:36 <merijn> gah
17:25:50 <merijn> Why can't haskell be properly dependently typed? :(
17:26:43 <merijn> I have a problem to which, I fear, the answer is "you're screwed" :\
17:27:37 <geekosaur> we didn't need compile tme type checking anyway >.>
17:28:06 <merijn> I have a GADT "data Socket :: SocketType -> * where ..." and I have SingI instances for all values of SocketType, but when I have a function "foo :: Socket sock -> Blah" and I try to use "singByProxy" on the "Socket sock" value it complains that it can't find an instance for "SingI sock" :\
17:28:23 <merijn> Even though, logically it should clearly be able to figure that out
17:29:32 <merijn> Can I somehow avoid this mess?
17:33:32 <dfeuer> merijn, I *think* the answer is no.
17:33:46 <merijn> ugh
17:33:57 <merijn> That means I just refactored to using singletons for nothing
17:34:29 <merijn> As I will still need explicit conversio functions via a custom GADT, rather than being able to use "fromSing . singByProxy"
17:34:50 <dfeuer> merijn, I could be wrong though.
17:35:03 <dfeuer> Is SocketType a closed kind?
17:35:21 <merijn> dfeuer: Yeah, it's just a lifted simple ADT
17:35:49 <dfeuer> Hmmm.....
17:35:55 <merijn> dfeuer: I never know where to ask these questions :\ I almost never get answers here, but I don't really know any better places for advanced issues like these :\
17:36:08 <dfeuer> Haaaahahaha.
17:36:34 <dfeuer> I'm not the right one for that. BUt certainly you have a problem for now because the evidence doesn't show up until you open the constructor.
17:36:37 * hackagebot Proper 0.5.2.0 - An implementation of propositional logic in Haskell  http://hackage.haskell.org/package/Proper-0.5.2.0 (dillonhuff)
17:36:55 <merijn> oh, wait!
17:36:59 <merijn> Idea!
17:37:07 <dfeuer> Oh?
17:37:38 <merijn> awww
17:37:40 <merijn> bummer
17:38:10 <merijn> I figured it was maybe because I didn't pattern match and just had a variable match, thus not getting the GADT info out, but apparently that wasn't the issue
17:38:33 <dfeuer> merijn, can you paste the code?
17:38:57 <dfeuer> Oh wait, I see ... Yech.
17:39:05 <merijn> dfeuer: Not really, it's like 1k LOC over 20 or so files
17:39:13 <merijn> Extracting the relevant bits is not really doable
17:39:23 <dfeuer> merijn, one trick I've seen is making the function a member of a class.
17:39:31 <dfeuer> I don't know if that helps here.
17:39:35 <dfeuer> But it might.
17:40:42 <dfeuer> merijn, you may or may not get some inspiration from http://stackoverflow.com/questions/26641559/closed-type-families-and-strange-function-types
17:45:15 * dfeuer wonders if merijn had any new insspirations.
17:46:54 <merijn> not from that
17:47:11 <merijn> I'm gonna try refactoring to move the reification elsewhere
17:49:38 <jr_> can anyone give me an example of foldr (++) that I could run in ghci? I'm trying to get a handle on it
17:50:01 <vanila> :t foldr (++)
17:50:02 <dfeuer> jr_, yeah.
17:50:03 <lambdabot> [a] -> [[a]] -> [a]
17:50:12 <vanila> > foldr (++) [] (words "foo bar baz")
17:50:14 <lambdabot>  "foobarbaz"
17:50:46 <vanila> > foldr (flip (++)) [] (words "foo bar baz")
17:50:48 <lambdabot>  "bazbarfoo"
17:50:53 <jr_> I just tried to run that and it didn''t work
17:50:55 <jr_> hmm
17:51:00 <dfeuer> > foldr (++) [1000,2000] [[1,2],[3,4],[5,6,7]]
17:51:03 <lambdabot>  [1,2,3,4,5,6,7,1000,2000]
17:51:08 <jr_> oh wait
17:51:09 <jr_> i got it
17:51:12 <jr_> hmm
17:51:49 <jr_> so it folds elements from one list into a single list?
17:51:54 <jr_> or of two lists
17:51:57 <jr_> also
17:52:11 <dfeuer> jr_, foldr (++) [] = concat
17:52:15 <jr_> thanks
17:52:36 <dfeuer> foldr (++) xs ys = concat ys ++ xs
17:52:46 <jle`> > foldr (++) ["hello"] ["how","are","you"]
17:52:48 <lambdabot>  Couldn't match type ‘GHC.Types.Char’ with ‘[GHC.Types.Char]’
17:52:48 <lambdabot>  Expected type: [[GHC.Types.Char]]
17:52:48 <lambdabot>    Actual type: [GHC.Types.Char]Couldn't match type ‘GHC.Types.Char’ with ‘[G...
17:52:48 <lambdabot>  Expected type: [[GHC.Types.Char]]
17:52:48 <lambdabot>    Actual type: [GHC.Types.Char]Couldn't match type ‘GHC.Types.Char’ with ‘[G...
17:53:04 <dfeuer> Ho ho ho.
17:53:12 <indiagreen> > foldr (++) "hello" ["how","are","you"]
17:53:13 <dfeuer> Merry Fishmas!
17:53:15 <lambdabot>  "howareyouhello"
17:53:24 <jle`> oh yeah.
17:53:46 <jle`> jr_: do you know that a list like [1,2,3] is just (1:2:3:[]) ?
17:54:01 <jle`> a list like [] is [], "hi" is 'h':'i':[], etc.
17:54:05 <jr_> yes
17:54:11 <dfeuer> jr_, I suggest you think more about how foldr works and less about how foldr (++) works.
17:54:18 <jr_> thanks
17:54:24 <jle`> `foldr f x`  basically goes in and replaces every (:) with f
17:54:30 <jle`> and [] with x
17:54:42 <jle`> ["hi","there"] = "hi":"there":[]
17:54:48 <dfeuer> And replaces [] with x
17:54:56 <jle`> foldr (++) "!" ["hi","there"] =    "hi" ++ there ++ "!"
17:55:07 <jle`> [1,2,3] = 1:2:3:[]
17:55:16 <jle`> foldr (+) 0 [1,2,3] =    1 + 2 + 3 + 0
17:55:32 <jle`> so it just replaces every (:) with the function, and the [] at the end with x
17:55:53 <dfeuer> But you don't want to add that way, except under special circumstances
17:56:38 * hackagebot yi-emacs-colours 0.1.0.0 - Simple mapping from colour names used in emacs to Color  http://hackage.haskell.org/package/yi-emacs-colours-0.1.0.0 (MateuszKowalczyk)
17:58:08 <jle`> well i'm glad i know that that package exists now
18:01:38 * hackagebot yi-emacs-colours 0.1.0.1 - Simple mapping from colour names used in emacs to Color  http://hackage.haskell.org/package/yi-emacs-colours-0.1.0.1 (MateuszKowalczyk)
18:01:40 * hackagebot gl 0.3 - Complete OpenGL raw bindings  http://hackage.haskell.org/package/gl-0.3 (Polarina)
18:02:42 <jr_> so I am having a hard time trying to figure out why foldr (++) on strings works, but (+) doesn't.
18:03:50 <geekosaur> I don't understand the question
18:04:47 <jr_> geekosaur: foldr (++) "6" ["3","4","5"]
18:04:48 <jr_> works
18:04:49 <jr_> but
18:05:01 <jr_> foldr (+) "1" ["3","4","5"]
18:05:02 <jr_> doesnt
18:05:11 <geekosaur> why would it? strings aren't instances of Num
18:05:31 <geekosaur> > foldr (+) 1 [3, 4, 5]
18:05:33 <lambdabot>  13
18:05:54 <geekosaur> > "3" + "4"
18:05:56 <lambdabot>  No instance for (GHC.Num.Num [GHC.Types.Char])
18:05:56 <lambdabot>    arising from a use of ‘GHC.Num.+’
18:05:59 <jr_> geekosaur: why is ++ reserved only for num?
18:06:06 <geekosaur> :t (+)
18:06:07 <lambdabot> Num a => a -> a -> a
18:06:16 <jr_> thanks
18:06:25 <jr_> Can I use lamdabot?
18:06:42 <geekosaur> yes, although if you're going to be doing a lot of stuff it's better to use /query
18:06:48 <joneshf-laptop> what's a good neural network library
18:06:58 <jr_> geekosaur: I didn't mean constantly. Just in case though
18:06:59 <jr_> thanks
18:07:01 <joneshf-laptop> something that has feedforward backprop
18:07:57 <geekosaur> anyway some languages use + to combine anything, Haskell took the path that + is defined on numbers, and there are other combining operators for other things... and then there is the general case that is + i some languages, which Haskell calls the Monoid typeclass
18:08:24 <geekosaur> one reason we don't glom it all on + is that numbers can be monoids in two different ways: (0, +) and (1, *)
18:08:31 <tac_> > 1 <> 2
18:08:33 <lambdabot>  No instance for (GHC.Show.Show a0)
18:08:33 <lambdabot>    arising from a use of ‘M666178753633742492513935.show_M6661787536337424925...
18:08:33 <lambdabot>  The type variable ‘a0’ is ambiguous
18:08:33 <lambdabot>  Note: there are several potential instances:
18:08:33 <lambdabot>    instance [safe] GHC.Show.Show
18:08:34 <geekosaur> so there are two Monoid instances (Sum and Product)
18:08:36 <tac_> oh yeah, whoops
18:08:44 <tac_> > Sum 2 <> Sum 3
18:08:46 <lambdabot>  Sum {getSum = 5}
18:09:27 <geekosaur> and <> is the monoid combining operator, as tac_ just showed
18:09:39 <prinsen> Parsec problem: to parse a multi line comment i have do { string "/*"; optionMaybe mlcc; string "*/" }. However, as a comment can include *, mlcc becomes to greedy and "steals" the * from the last string "*/". Is this solvable by adding a try deep inside mlcc on char '*'? Because try . optionMaybe does obviously not work
18:09:40 <tac_> > "hello " <> "world!"
18:09:46 <lambdabot>  "hello world!"
18:10:09 <tac_> > Just "hello" <> Just "world"
18:10:14 <lambdabot>  Just "helloworld"
18:11:25 <jr_> why isn't foldr (-) 3 [3,6], 6? It seems to me that the f gets applied to the first element, then the result is applied to ever element to the right. So if 3-3 is 0, then 6-0 = 6
18:11:26 <sbrg> so, anyone here familiar with the graphviz package?
18:11:33 <sbrg> Because it is incredibly convoluted to start using
18:11:43 <indiagreen> prinsen: you can change the char-grabbing parser inside “mlcc” from e.g. “anyChar” to “notFollowedBy "*/" >> anyChar”
18:12:08 <sbrg> > foldr (-) a [b,c] :: Expr
18:12:10 <lambdabot>  b - (c - a)
18:12:10 <indiagreen> ouch, add “string” after “notFollowedBy”
18:12:26 <sbrg> > foldr (-) 3 [3,6] :: Expr
18:12:28 <lambdabot>  3 - (6 - 3)
18:12:33 <sbrg> ^ jr_
18:12:34 <geekosaur> foldr is notionally taking a list and replacing : with the operator
18:12:37 <jr_> thanks sbrg
18:13:00 <tac_> jr_: foldr takes your list written out as a : b : c : ... : [] and replaces all the :'s with the function and [] with the final value
18:13:16 <geekosaur> although the one that starts with a seed value (see foldr1 for the other) works as tac_ said
18:13:24 <tac_> so foldr (-) 3 [3, 6] would be 3 : 6 : [] replacing : and [] as I just mentioned above, giving 3 - 6 - 3
18:13:46 <tac_> err but the thing to remember here is parens :X
18:13:55 <tac_> 3 - (6 - (3))
18:14:11 <jr_> I was about to say lol
18:14:16 <tac_> since : is right associative, the parens lean towards the left
18:14:27 <tac_> and they stick around when you substitute in the function and final value
18:14:56 <jr_> Why doesn't foldr (-) 3 [3,6] :: Expr give the result that lambdabot does? I just get a type constructor error
18:15:11 <tac_> See also Cale's nice diagrams on the matter in this SO post: http://stackoverflow.com/questions/13280159/haskell-foldl-and-foldr
18:18:34 <sbrg> jr_: it's lambdabot magic
18:18:44 <sbrg> You can download the library as well, I don't remember its name though
18:18:47 <jr_> so foldl (-) 3 [3,6] is (((3)-3) -6 )?
18:19:06 <jr_> sbrg: Well I think it would be useless until I actually am capable of handling haskell in a competent manner
18:19:25 <indiagreen> sbrg: simple-reflect
18:19:28 <sbrg> ^
18:19:56 <sbrg> > foldl (-) 1 [2,3] :: Expr -- jr_
18:19:59 <lambdabot>  1 - 2 - 3
18:20:15 <tac_> > foldl (-) 3 [3,6]
18:20:17 <lambdabot>  -6
18:20:21 <tac_> looks right to me
18:21:05 <jr_> thanks
18:21:45 <sbrg> jr_: if you look at both expressions above, you can see the pattern -- tac_ already explained how to think of foldr
18:21:57 <sbrg> and as you can see by looking at lambdabot's output for foldl, understanding it is easy as well
18:22:07 <sbrg> that is, you just take the operator and put it between all the elements.
18:22:35 <jr_> thanks guys, really appreciate it. looking at the link nwo
18:24:35 <athan> Is HXT main purpose XML queries, and not tree manipulation? Wrapping a node in another seems pretty strange in HXT, but very natural in Blaze.
18:26:58 <jr_> so one last time, srbaker  or tac_ : in the link you provided, in the diagram, what is z?
18:27:03 <jr_> just the nth element?
18:27:58 <tac_> jr_: z is the initial value you provide
18:28:13 <dfeuer> "Some day we'll find it, a stable connection, the gamers, the lamers, and me..."
18:28:14 <jle`> jr_: it's not quite magic, but the `Expr` type comes from a library
18:28:24 <jle`> just like many types
18:28:36 <jle`> so if you installed the library then you should be able to use it
18:28:42 <jle`> not all types come built-in :)
18:29:20 <dfeuer> I submitted a patch yesterday to add an Alt type to Data.Monoid, as it appears everyone thinks that a good idea.
18:31:57 <kadoban> I'm a bit confused on the differences in...expressive power between applicative and monad (and to a lesser extent arrow and friends). Can anyone suggest some reading or execises that might help clear it up? I understand the types relatively well I think, just don't have a good handle on what one can solve that others can't, and etc.
18:33:14 <jle`> kadoban: the main idea is that Monad allows you to chose the structure of the result of the function, based on the value "inside" the function
18:33:17 <dfeuer> kadoban, Applicative is less powerful than Monad, and therefore more general.
18:33:30 <jle`> kadoban: you might know that Functor/fmap must preserve the structure of the object
18:33:36 <jle`> it can't turn a Just into a Nothing, and vice versa
18:34:09 <jle`> only in Monad can you "choose" if you turn something into a Just or Nothing, from the value inside.
18:34:24 <lifter> Anyone ever find themselves in a situation where you have a module that keeps getting longer and longer, and when you try to break it up you only seem to run into circular import issues?
18:34:24 <kadoban> Ahh, right that helps I think
18:34:29 <MP2E> If you combine 2 applicatives into one the two computations you combine cannot effect each other, in other words, you can think of Applicative as modeling a potentially parallel computation
18:34:31 <dfeuer> Applicative pure is basically the same as Monad return.
18:34:33 <MP2E> Monads can be threaded
18:34:44 <MP2E> so monads represent a computation that can only be done in series
18:34:54 <jle`> for example, a function like (a -> Maybe a).  like...
18:35:05 <jle`> @def halveMaybe x = if even x then Just (x `div` 2) else Nothing
18:35:08 <lambdabot>  Defined.
18:35:12 <jle`> :t halveMaybe
18:35:13 <dfeuer> Applicative <*> takes an action producing a function and an action producing a value, and makes an action producing that function applied to thaht value.
18:35:14 <lambdabot> Integral a => a -> Maybe a
18:35:25 <jle`> halveMaybe determines "what structure of `Maybe`" you will have, after applying it to an `a`
18:36:33 <kadoban> Okay thanks, I think those examples all help :)
18:37:54 <kadoban> I think a lot of the problem is I've read some of the...theory and kind of abstact stuff, but I find it hard to gain intuition about it from that, or come up with a model of what's possible without seeing a bunch of examples...and most of the applicatives I know are also monads...which is somewhat unhelpful
18:38:04 <kadoban> So some concete helps :)
18:39:23 <dfeuer> kadoban, I really like ZipList as an intuitive example.
18:39:40 <dfeuer> It has its oddities, but I think it expresses the concept really well.
18:40:06 <kadoban> Ah, yeah? Anything specific I should read up on it in that context, or just play around with it?
18:40:29 <dfeuer> kadoban, just look at how it's defined in Control.Applicative.
18:40:54 <kadoban> Thanks, I'll check it out
18:44:53 <xendo> does anyone here use smuxi?
18:51:53 <jle`> kadoban: it might help to go through Control.Monad and imagine which ones can be implemented/generalized for all applicatives
18:52:14 <jle`> for example, sequence_ :: Monad m => [m a] -> m ()
18:52:30 <kadoban> Ahh, that sounds like a good idea too, thanks.
18:52:46 <jle`> none of the items in the list you are sequencing can "depend on" the results of the last item
18:52:53 <jle`> all of the items are their own self-contained little things
18:53:00 <jle`> they can't branch on the result of the previous item
18:53:13 <dfeuer> Yes, jle`, but that doesn't point out the distinction between Applicative and Monoid too well.
18:53:27 <jle`> because you are sequencing w/out branching (sructure-wise) based on results, it can be totally Applicative
18:53:49 <kadoban> Right
18:53:50 <jle`> oh, wasn't he asking about Applicative and Monad?
18:54:06 <jle`> i think it helped me to look at certain problems, and saying, 'can this problem be solved with only Applicative?'
18:54:24 <jle`> and Control.Monad has a lot of such problems (solved using Monad combinators)
18:54:26 <dfeuer> jle`, what I mean is that sequence_ operates on Applicative via the "forgetful" *> operation.
18:54:36 <mietek> Why is Haste so broken.
18:55:16 <dfeuer> So sequence_ doesn't give much of a sense of what makes Applicative *powerful*.
18:55:31 <dfeuer> Unless, of course, I'm missing something due to extreme lack of sleep.
18:55:39 <jle`> that's just one example, becuase i didn't want to give away the interesting ones :P
18:55:49 <kadoban> Hehe
18:55:49 <dfeuer> Ahhhhh....
18:55:54 <dfeuer> OK, then!
18:56:42 <jle`> btw, for a cheat sheet, most of the Control.Monad functions that are generalizable to Control.Applicative are actually done and written out between Data.Traversable and Data.Foldable
18:57:04 <kadoban> Heh, cool. That'll help
19:00:28 <sbrg> dot and graphviz are like magic
19:04:46 <gamegoblin> Can anyone think of a clever way to turn a Maybe (Maybe a) into a Maybe a? Where Nothing -> Nothing, Just Nothing -> Nothing, and Just (Just a) -> Just a?
19:05:11 <gamegoblin> besides just doing that pattern match itself, of course. I was wondering if there was some functor magic to be had.
19:05:14 <jle`> how about join
19:05:24 <gamegoblin> :t join
19:05:26 <lambdabot> Monad m => m (m a) -> m a
19:05:39 <gamegoblin> > join (Just Nothing)
19:05:41 <lambdabot>  Nothing
19:05:42 <jle`> also `fromMaybe Nothing`
19:05:51 <gamegoblin> > join Nothing
19:05:54 <lambdabot>  Nothing
19:05:57 <gamegoblin> > join (Just (Just 5))
19:05:59 <lambdabot>  Just 5
19:06:02 <gamegoblin> perfect
19:06:04 <jle`> join "sqashes" two layers of Monad into one
19:06:08 <jle`> :t fromMaybe Nothing
19:06:09 <lambdabot> Maybe (Maybe a) -> Maybe a
19:06:44 <gamegoblin> I’m doing a `timeout` on a function that returns a maybe, hence the maybe maybe
19:07:08 <jle`> i haven't actually encountered `join` much in real life
19:07:17 <mietek> https://github.com/valderman/haste-compiler/issues/257
19:07:26 <jle`> usually when i think i need `join`, it could have been written better with (>>=)/(=<<) or do notation
19:08:30 <jle`> with Maybe i like using `fromMaybe Nothing` unless there is an obvious reason to make it more generic
19:08:35 <jle`> that last thing is just taste though
19:09:08 <jle`> but's the same reason why i'd use `map` over `fmap`, `concat` over `join`
19:09:15 <jle`> sometimes you just aren't "thinking" in a monadic context.
19:09:42 <jle`> i use (:[]) over `pure`/`return` in a lot of cases too, when code around it isn't really applicatively/monady in nature
19:09:45 <gamegoblin> particularly ugly, I’m actuallyd doing a liftM join since it’s actually an IO (Maybe (Maybe a))
19:09:55 <gamegoblin> Since timeout (IO a) -> IO (Maybe a)
19:10:02 <gamegoblin> and my `a` is already a Maybe
19:10:15 <jle`> usually if you get an IO (Maybe (Maybe a)), you might have been able to do (>>=) in the first place
19:10:29 <jle`> ah, i see
19:11:06 <jle`> that's (>>=) for MaybeT IO
19:11:26 <gamegoblin> Ah yeah. I feel like introducing MaybeT into things just muddles the matter. It’s only 5 lines of code.
19:11:29 <jle`> but ther emight be a way to use (>>=) here too without the newtype wrapper, huh.
19:13:50 <lifter> (Please forgive me for asking again.) Anyone ever find themselves in a situation where you have a module that keeps getting longer and longer, and when you try to break it up you only seem to run into circular import issues?
19:14:33 <gamegoblin> lifter: try to draw out a tree of your functional dependencies, that should help you organize
19:15:11 <lifter> gamegoblin: What do you mean by functional dependencies?
19:15:23 <gamegoblin> lifter: what relies on what
19:15:27 <lifter> ok
19:15:41 <gamegoblin> lifter: i.e. if you have a function which calls 3 other functions, you could say it depends on those three functions
19:15:43 <edwardk_> pharpend: pdpc was the old parent company over freenode
19:16:14 <lifter> gamegoblin: right, yeah, I didn't think to try drawing out a diagram, that would certainly help
19:19:43 <edwardk_> pharpend: i threw money at them at various points
19:20:17 <indiagreen> is there a way to make :t expand type synonyms?
19:21:18 <gfixler> indiagreen: I don't think :t works on types - it tells you the type of things
19:21:23 <gfixler> indiagreen: but you can try :i
19:21:34 <gfixler> Prelude> :i String
19:21:34 <gfixler> type String = [Char]    -- Defined in GHC.Base
19:22:24 <indiagreen> yep, :t doesn't work on types, but I thought there could be some command (maybe “:type!” or whatever) which would expand types of things before displaying them
19:22:54 <indiagreen> by the way, “:kind!” can be used to expand types, but it's still a 2-step operation
19:23:08 <trap_exit> now that I'm familair with most haskell features (but not all the numerous extensions)
19:23:12 <trap_exit> how do I go from writing haskell to writing idiomatic haskell?
19:23:26 <trap_exit> is there more to idiomatic haskell than list comprehensions + point-less style ?
19:23:38 <gfixler> trap_exit: have you looked at hlint?
19:23:39 <trap_exit> i.e. setting up the functions so that currying is as useful as possible
19:23:46 <trap_exit> no
19:23:48 <trap_exit> perhaps I should install it
19:24:03 <gfixler> I write a version of sum using a fold, with [] = [], and a recursive second pattern
19:24:07 <gfixler> and it suggested using fold
19:24:15 <gfixler> then suggested removing the xs from both sides
19:24:22 <gfixler> then simplified the fold futher
19:24:27 <gfixler> then finally told me to just use sum :)
19:24:38 <trap_exit> so it went from > 3 lines to 3 chars?
19:24:42 <gfixler> yep
19:24:52 <gfixler> in stages - it made me laugh
19:24:54 <trap_exit> no one knows it yet
19:24:59 <trap_exit> but hlint is skynet in training
19:25:02 <gfixler> hehe
19:25:13 <trap_exit> it learns from code that humans write, under the guise of helping us
19:25:28 <trap_exit> but one day ... hlint is going to write it's own code, hijack our autonomous uber-google cars, and take over the world
19:25:39 <gfixler> this was just announced: http://neilmitchell.blogspot.it/2014/10/hlint-now-spots-bad-unsafeperformio.html
19:25:50 <gfixler> so it keeps getting smarter
19:26:06 <gfixler> at a recent meetup, my friend had written a nicer version of recursion than mine
19:26:20 <gfixler> I had an if, and he had a foo && <recursion>
19:26:31 <gfixler> I asked what made him think of that nicer way - "hlint"
19:26:40 <gfixler> so I've started using it
19:26:47 <trap_exit> cabal installing hlint right now
19:26:52 <trap_exit> i'm afriad to see what it has to say
19:26:56 <gfixler> :)
19:26:59 <gfixler> do you use vim or emacs?
19:27:06 <trap_exit> i've noticed that ghc is rather slow on my mac mini
19:27:06 <trap_exit> emacs
19:27:13 <trap_exit> it seems like ghc + not a ssd = slow
19:27:21 <gfixler> my friend informs he that he hooked it up through flycheck
19:27:37 <gfixler> emacs + flycheck + hlint, IIRC
19:27:43 <trap_exit> is hlint universally agreed upon?
19:27:45 <trap_exit> or is it just some random guys's tylhes ?
19:27:47 <trap_exit> *styles*
19:27:56 <gfixler> that I don't know
19:28:21 <indiagreen> ...as if any community can possibly have a universally agreed upon style
19:28:26 <gfixler> hehe
19:28:29 <kadoban> Nothing in style is universal. It's still a good tool though.
19:28:36 <gfixler> we tried, and then we had 2 new agreed upon styles
19:28:45 <geekosaur> heh
19:28:59 <gfixler> so far it just seems to notice pretty obviously nice things
19:29:04 <gfixler> like not reimplementing fold on your own
19:29:08 <trap_exit> how do I disable camelcase in hlint?
19:29:12 <trap_exit> i_like_my_underscores
19:29:18 <trap_exit> IDoNotLikeCamelCase
19:29:22 <geekosaur> ob http://xkcd.com/927/
19:30:08 <gfixler> geekosaur: this is what actually excited me about haskell early on
19:30:18 <gfixler> "based on math!? I can be *provably* correct for once?"
19:30:37 <gfixler> if my implementation is provably correct, and yours isn't, I win, game over
19:31:17 <kadoban> trap_exit: CamelCase is pretty consistent in Haskell though. Since types have to be capitalized too, I'm not sure how you'd avoid it completely in a reasonable way
19:31:34 <indiagreen> trap_exit: if you're using Emacs, I suggest glasses-mode
19:32:50 <indiagreen> otherwise, you might ju-ust become Universally™ disliked for your underscore habits
19:33:58 <geekosaur> well, but there are multiple maths. consider geometry for an example... euclidian is neither less nor more correct than hyperbolic
19:34:47 <indiagreen> geekosaur: you can call any set of axioms and correct theorems derivable from them “a math”
19:35:09 <geekosaur> and if you implement ZF set theory, is your program incorrect because it didn't implement category theory?
19:35:45 <geekosaur> (same general "family" if you will, but category theory is muuuuuch more abstract)
20:01:09 <dfeuer> Is there any real difference between Maybe and First?
20:08:06 <indiagreen> > Just "a" <> Just "b"
20:08:08 <lambdabot>  Just "ab"
20:08:18 <indiagreen> > First (Just "a") <> First (Just "b")
20:08:20 <lambdabot>  First {getFirst = Just "a"}
20:08:27 <indiagreen> dfeuer: ^
20:08:58 <dfeuer> indiagreen, yes, those would appear to be isomorphic in the extreme.
20:09:38 <indiagreen> they are isomorphic types, sure, given that First is a newtype wrapper over Maybe
20:09:48 <indiagreen> but they have different instances
20:10:14 <dfeuer> I must be missing something.
20:10:47 <dfeuer> Oh, now I see.
20:10:51 <indiagreen> it's the same as the difference between Sum and Product
20:10:56 <dfeuer> Er ... no I don't.
20:11:32 <dfeuer> I must've misread something.
20:12:03 <dfeuer> Oh..... I see it now. Weird.
20:12:29 <indiagreen> it's useful when you have a function which depends on Monoid instance to do its job
20:12:40 <indiagreen> e.g. Writer monad
20:12:44 <indiagreen> or lenses
20:12:56 <dfeuer> indiagreen, First a is actually isomorphic to  Alt (Maybe a), where Alt is expected to appear in 7.10.
20:13:15 <dfeuer> I got a bit mixed up :P
20:14:47 <indiagreen> a-ha, nice, didn't know about Alt
20:15:12 <dolio> It doesn't exist yet, so that's not surprising.
20:15:15 <L8D> @src forever
20:15:15 <lambdabot> Source not found.
20:15:20 <L8D> :t forever
20:15:22 <lambdabot> Monad m => m a -> m b
20:15:34 <dfeuer> indiagreen, it's actually in some of Edward Kmett's libraries.
20:15:34 <L8D> :t sequence . repeat
20:15:36 <lambdabot> Monad m => m a -> m [a]
20:15:40 <dfeuer> And also some others, I think.
20:15:51 <indiagreen> dolio: well, but there appears to be some discussion on Haskell-cafe already
20:15:55 <L8D> > forever Nothing
20:15:57 <lambdabot>  Nothing
20:16:05 <L8D> > forever $ Just 1
20:16:09 <lambdabot>  mueval-core: Time limit exceeded
20:16:14 <dolio> It's easy to miss things on haskell-cafe.
20:16:32 <dfeuer> The fact that everyone already defines the same thing themselves made the proposal fairly well-received on the libraries list...
20:16:33 <L8D> I don't get it
20:16:49 <L8D> does someone mind explaining to me what 'forever' is really supposed to do?
20:17:01 <dolio> forever m = m >> forever m
20:17:03 <L8D> I get that you can use it to run some IO forever
20:17:12 <dfeuer> IO, or not.
20:17:24 <L8D> but when it comes to IO, when would it ever end?
20:17:43 <kadoban> never?
20:17:53 <dolio> When an exception is thrown, or exit is called.
20:17:57 <L8D> ah
20:18:06 <L8D> that's what I was looking for
20:18:12 <dolio> But running forever is also a well defined thing in IO.
20:18:27 <dolio> But not in Maybe.
20:18:27 <L8D> but with non-IO monads what use does it have?
20:19:02 <dolio> Depends on the monad.
20:19:37 <L8D> could you show me an example of using forever with Maybe?
20:19:39 <jle`> L8D: it was really invented for IO, but because it can be written purely in terms of Monad methods, it "might as well" be generalized to Monad m
20:19:46 <L8D> or a list or whatever
20:19:48 <dolio> No, it's useless with Maybe.
20:20:02 <L8D> jle`: so is it useless except for IO?
20:20:46 <jle`> not necessarily
20:21:12 <L8D> that's what I'm having trouble getting.
20:21:21 <L8D> what is it useful for outside of IO?
20:21:44 <jle`> you can't really show that it is impossible to be useful, though.  just that you can onyl think of one use :)
20:21:53 <jle`> > take 10 $ execWriter (forever (tell "a"))
20:21:55 <lambdabot>  "aaaaaaaaaa"
20:22:11 <L8D> :t tell
20:22:12 <lambdabot> MonadWriter w m => w -> m ()
20:22:34 <L8D> :t execWriter
20:22:35 <lambdabot> Writer w a -> w
20:22:43 <jle`> > take 10 $ execState (forever (modify (++ "a")) ""
20:22:45 <lambdabot>  <hint>:1:50:
20:22:46 <lambdabot>      parse error (possibly incorrect indentation or mismatched brackets)
20:22:49 <jle`> > take 10 $ execState (forever (modify (++ "a"))) ""
20:22:53 <lambdabot>  mueval-core: Time limit exceeded
20:22:58 <jle`> ah, i see.
20:23:04 <dolio> Prepend.
20:23:08 <L8D> ^
20:23:11 <jle`> L8D: have you seen the 'Writer' type before?
20:23:14 <jle`> it comes up in LYAH
20:24:02 * L8D goes to read
20:25:39 <jle`> > forever []
20:25:41 <lambdabot>  []
20:25:56 <L8D> > take 10 $ forever 10
20:25:58 <lambdabot>  No instance for (GHC.Num.Num [a0]) arising from the literal ‘10’
20:25:58 <L8D> derp
20:26:02 <L8D> > take 10 $ forever [10]
20:26:06 <lambdabot>  mueval-core: Time limit exceeded
20:26:42 <dolio> You need a monad where the same action can independently stop based on previous actions.
20:26:48 <dolio> Lists and Maybe are not that.
20:26:56 <L8D> wait...
20:27:05 <L8D> what's the difference between join and flatten?
20:27:13 <jle`> what is flatten?
20:27:26 <trap_exit> flatten is like recursive join
20:27:26 <L8D> derp... "concat" ?
20:27:31 <trap_exit> well, flatten is like recursie concat
20:27:35 <L8D> well wait
20:27:41 <trap_exit> well, that's not accurate either
20:27:46 <trap_exit> i'm goign to shut up
20:27:48 <jle`> concat is join for lists
20:27:49 <trap_exit> @src flatten
20:27:50 <lambdabot> Source not found. My brain just exploded
20:27:51 <trap_exit> @src join
20:27:51 <lambdabot> join x = x >>= id
20:27:52 <jle`> just like `map` and `fmap`
20:27:59 <jle`> map is `fmap` for lists
20:28:05 <L8D> when it comes to lists, mconcat = join ?
20:28:15 <trap_exit> >flatten [1, 2, [3, 4, 5]]
20:28:24 <trap_exit> > flatten [1, 2, [3, 4, 5]]
20:28:25 <L8D> is this true for all monadic monoids?
20:28:26 <lambdabot>  Couldn't match expected type ‘Data.Tree.Tree a’
20:28:26 <lambdabot>              with actual type ‘[[t0]]’
20:28:32 * trap_exit kicks lambdabot
20:28:36 <jle`> mconcat?
20:28:52 <jle`> hm
20:28:54 <L8D> > mconcat [[1, 2, 3, 4], [1, 2, 3, 4]]
20:28:56 <lambdabot>  [1,2,3,4,1,2,3,4]
20:28:57 <jle`> interesting coincidence
20:28:59 <trap_exit> damn, I was thinking about flatten in scheme -- I have no idea wtf flatten means in haskell
20:29:02 <L8D> > join [[1, 2, 3, 4], [1, 2, 3, 4]]
20:29:04 <lambdabot>  [1,2,3,4,1,2,3,4]
20:29:17 <jle`> prove that it satisfies the laws :)
20:29:19 <L8D> trap_exit: I think flatten is for Trees
20:29:33 <L8D> jle`: is there already a proof though?
20:29:39 <trap_exit> L8D so it's like tree -> list ?
20:29:46 <jle`> well, what fun is that? ;)
20:29:46 <L8D> :t flatten
20:29:48 <lambdabot> Tree a -> [a]
20:30:08 <L8D> jle`: I never graduated high school...
20:30:12 * L8D cries in a corner
20:30:34 * L8D believes he can never learn all the fancy math stuff and understand idris
20:30:57 <jle`> what does that have anything to do with it?
20:30:59 <jle`> :)
20:31:01 * L8D still uses haskell in hope
20:31:33 <L8D> jle`: I don't know how to write proofs nor do I know where to start learning outside of uni
20:33:26 <trap_exit> L8D: damn, is your haskell self taught? that is impressive
20:33:48 <trap_exit> L8D: jle` is a great teacher; taught me all about monands
20:33:56 <L8D> trap_exit: tell me where I can learn this fancy math stuff!
20:34:04 <L8D> jle`: teach me this fancy math stuff!
20:34:20 <jle`> it's not really fancy math...it's just...thinking...
20:34:58 <jle`> try showing that (f . id) = f, for example.
20:35:00 <jle`> @src id
20:35:00 <lambdabot> id x = x
20:35:02 <jle`> @src (.)
20:35:03 <lambdabot> (f . g) x = f (g x)
20:35:25 <L8D> I mean... I'm just using the term "fancy math stuff" to describe the stuff you need to do when writing proofs and papers and whateer
20:35:31 <jle`> it's not really something that is taught.
20:35:38 <jle`> you just kind of play around
20:35:53 <jle`> (f . id) x = f (id x)
20:35:54 <L8D> but I don't know the boundaries and assumptions I can make
20:35:54 <jle`> = f x
20:36:10 <jle`> so (f . id) x = f x
20:36:20 <jle`> (f . id) = x
20:36:22 <jle`> er
20:36:24 <jle`> = f
20:36:33 <jle`> see? just playing with puzzle pieces
20:36:48 <jle`> you make up the boundaries and assumptions yourself
20:36:55 <L8D> @src join
20:36:56 <lambdabot> join x = x >>= id
20:36:58 <jle`> if you're talking about Monads, you have the monad laws
20:37:01 <L8D> @src mconcat
20:37:01 <lambdabot> Source not found. Do you think like you type?
20:37:06 <jle`> but you're talking about "monadic monads"...
20:37:10 <jle`> what does that mean, exactly?
20:37:18 <L8D> monadic monoids
20:37:24 <L8D> monoids that are monads
20:37:36 <L8D> which I guess is also monoids which are functors?
20:37:43 <jle`> you have to be a bit clearer here.  no haskell Monoid instances are Monad/Functor instances
20:37:51 <jle`> [a] is a Monoid, but not a Monad
20:37:51 <L8D> but...
20:38:03 <L8D> [1] >>= enumFrom
20:38:06 <L8D> > [1] >>= enumFrom
20:38:08 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
20:38:23 <L8D> so list is not a monad?
20:38:32 <jle`> [] is a Monad
20:38:44 <L8D> oooh I see what you mean
20:38:54 <L8D> isn't [] a monoid though?
20:38:57 <jle`> it helps to use exact language, so you can know wha tyou can know
20:39:12 <jle`> [a] is a monoid
20:39:37 <L8D> so what is a term describe what I'm talking about?
20:40:18 <jle`> brb, sorry ><
20:40:23 <L8D> these are the things I'm unfamiliar with
20:41:46 <L8D> (Monad m, Monoid a) => m a
20:41:56 <L8D> @djinn (Monad m, Monoid a) => m a
20:41:57 <lambdabot> Error: Class not found: Monoid
20:42:12 <L8D> @djinn (Monad m, Data.Monoid.Monoid a) => m a
20:42:13 <lambdabot> Error: Class not found: Data.Monoid.Monoid
20:43:22 <MP2E> Well, a Monad *is* a monoid in the context of endofunctors, heh
20:43:31 <MP2E> is that what you are thinking of maybe?
20:43:49 <Welkin> not maybe
20:44:12 <L8D> MP2E: in the *category* of endofunctors
20:44:17 <MP2E> Right.
20:45:13 <Welkin> so, Either?
20:45:35 <L8D> > (Right 10) `mconcat` (Left 0)
20:45:37 <lambdabot>  Couldn't match expected type ‘[Data.Either.Either a1 b1 -> t]’
20:45:37 <lambdabot>              with actual type ‘Data.Either.Either a0 b0’
20:46:06 <L8D> Either isn't a monoid
20:46:22 <simpson> > Right 10 <|> Left 0 -- it's an Alternative, amongst other things
20:46:24 <lambdabot>  No instance for (GHC.Show.Show a0)
20:46:24 <lambdabot>    arising from a use of ‘M13105813014329689216895.show_M13105813014329689216...
20:46:24 <lambdabot>  The type variable ‘a0’ is ambiguous
20:46:24 <lambdabot>  Note: there are several potential instances:
20:46:24 <lambdabot>    instance [safe] GHC.Show.Show
20:46:44 <codygman> I feel like I'm doing something bad here, but at the same time if I understand correctly this is safe code: http://lpaste.net/113662
20:46:46 <simpson> > Right (10 :: Int) <|> Left 0 -- damn you DMR
20:46:48 <lambdabot>  No instance for (GHC.Show.Show a0)
20:46:48 <lambdabot>    arising from a use of ‘M343261567649263192616920.show_M3432615676492631926...
20:46:48 <lambdabot>  The type variable ‘a0’ is ambiguous
20:46:48 <lambdabot>  Note: there are several potential instances:
20:46:48 <lambdabot>    instance [safe] GHC.Show.Show
20:47:03 <L8D> Right (10 :: Int) <|> Left (0 :: Int)
20:47:05 <L8D> > Right (10 :: Int) <|> Left (0 :: Int)
20:47:07 <lambdabot>  No instance for (Control.Monad.Trans.Error.Error GHC.Types.Int)
20:47:08 <lambdabot>    arising from a use of ‘Control.Applicative.<|>’
20:52:46 <jle`> L8D: btw, you might want to say what you really mean by `mconcat`
20:53:02 <jle`> because as you have it now, it only works on lists...not all monads or what you are thinking.
20:53:31 <jle`> there's F.fold , which generalizes it to all Foldables
20:53:34 <jle`> :t F.fold
20:53:36 <lambdabot> (Monoid m, Foldable t) => t m -> m
20:54:01 <jle`> but saying "all monoidy monads, mconcat = join" might not make too much sense
20:55:39 <jle`> you might be able to say " for all Monad m that are also Foldable m, and Monoid (m a), join = F.fold "
20:56:20 <L8D> so I couldn't prove it?
20:56:30 <L8D> what about sets or maps?
20:56:42 <jle`> > F.fold (Just (Just "hi"))
20:56:42 <L8D> aren't those monoidy monads?
20:56:44 <lambdabot>  Just "hi"
20:56:50 <jle`> > join (Just (Just "hi"))
20:56:52 <lambdabot>  Just "hi"
20:56:54 <jle`> :o
20:57:30 <jle`> sets or maps aren't monads, heh
20:57:35 <L8D> oh
20:57:40 <L8D> so dissapoint
20:57:47 <jle`> or well, not Monads, at least
20:58:43 <NemesisD> any of you folks use nix for haskell dev?
20:59:23 <L8D> NemesisD: nixos?
20:59:38 <NemesisD> L8D: yeah
21:00:09 <kadoban> It sounds neat, but I haven't had a need to yet.
21:00:21 <kadoban> Just using cabal sandboxes has so far been acceptable
21:00:21 <NemesisD> or i guess not nixos necessarily. i'm readding ocharles' post about how he uses nix for dev. he shows how to build a nix package for a haskell package. i don't understand the point though
21:00:44 <NemesisD> hes specifying the dependencies of attoparsec for example in the nix file. isn't this the job of cabal
21:16:50 <jedws> isn't the point that cabal does a pretty poor job of that?
21:18:01 <kadoban> NemesisD: nix is a package manager, kind of a replacement for cabal, no? So kind of makes sense they'd be doing similar things.
21:18:34 <jedws> cabal has several serious shortcomings
21:20:04 <jedws> for a for a great discussion on what a post-cabal world might look like, see the annex talk http://www.youtube.com/watch?v=JjYAnBhF2JU
21:28:12 <trap_exit> has anyone here been banned for rick rolling with youtuber links?
21:50:36 <fread2282> http://packdeps.haskellers.com/reverse/array is pretty long, isn't vector supposed to be better than array?
21:51:05 <fread2282> and includes things like Cabal binary and ad
21:51:55 <merijn> array is also significantly older than vector, afaik
21:52:08 <merijn> And why upgrading a working package to another library if you don't need the speed?
21:57:02 <fread2282> merijn: true, but e.g. text uses array
22:00:33 <merijn> fread2282: Yes, but have you checked for what? Are you sure that vector is better for whatever Text is doing?
22:00:51 <merijn> Considering Text is maintained by bos, I assume he knows what he's doing :)
22:02:06 <Axman6> does Text use Array? I'd be extremely surprised if it didn't use very low level byte arrays
22:03:20 <Axman6> fread2282: Array has many advantages over Vector, not least of which is the ability to use any type which imp-lements Ix as indices
22:04:17 <merijn> Axman6: It depends on Array, but Data.Text.Array is exposing ByteArray#, so
22:04:27 <jane_> hello?
22:04:35 <merijn> I think it only casually borrows some stuff from array
22:04:55 <merijn> jane_: Hello!
22:05:21 <jane_> What is the topic?
22:05:33 <Axman6> Haskell
22:05:46 <jane_> Of course, but what is current discussion about?
22:05:58 <Axman6> the array package
22:06:34 <fread2282> oh, it doesn't
22:06:51 <fread2282> it has it's own Array type (!) in Data.Text.Array
22:08:51 <Axman6> yeah not sure what the purpose of that module is
22:08:55 <fread2282> Axman6: but shouldn't any sane instance of Ix be ~ a bounded Integer?
22:10:27 <Axman6> not necessarilly. I think Ix a => Ix (Maybe a) might be an instance
22:11:00 <Axman6> @instances Ix
22:11:00 <lambdabot> Couldn't find class `Ix'. Try @instances-importing
22:11:09 <Axman6> @instances-importing Data.Array Ix
22:11:11 <lambdabot> (), (a, b), (a1, a2, a3), (a1, a2, a3, a4), Bool, Char, Int, Integer, Ordering
22:11:48 * hackagebot fixtime 1.5 - Some fixes to the time package  http://hackage.haskell.org/package/fixtime-1.5 (pharpend)
22:12:10 <fread2282> Axman6: it's not, and wouldn't that just be a (Ix a + 1) bounded Integer?
22:16:48 * hackagebot fixtime 1.5.0.1 - Some fixes to the time package  http://hackage.haskell.org/package/fixtime-1.5.0.1 (pharpend)
22:19:02 <fread2282> also, due to array making you specify bounds, I think it must
22:19:31 <fread2282> (at least relative to the lower bound)
22:23:20 <fread2282> rangeSize :: (a, a) -> Int     yep      rangeSize (lowerBound, index) ~ Int index relative to lowerBound
22:30:24 <fread2282> and it's probably doing a subtract to get an Int index anyways
22:30:46 <Axman6> sure
22:42:56 <fread2282> It would be trivial to make a wrapper on top of a Int interface that uses Enum, but doing that by default of as the only option is relying on the compiler to save you work in the common case
22:43:05 <fread2282> *or
22:43:32 <fread2282> that is, I don't want needless substacts when I'm using an Int-indexed vector/array
22:43:39 <fread2282> *subtracts
22:55:41 <edwardk_> now with actually somewhat useful haddocks! http://ekmett.github.io/gl/Graphics-GL-Raw-Extension-EXT-CopyTexture.html http://ekmett.github.io/gl/Graphics-GL-Raw-Extension-NV-HalfFloat.html
22:57:32 <merijn> edwardk_: Who are you and what did you do with edwardk? ;)
22:59:07 <edwardk> i chained him in the basement and made him work on opengl
22:59:08 <simpson> Wow, that's pretty good.
22:59:26 <merijn> The quine stuff looked neat
22:59:27 <simpson> All that's missing are the rationale/question sections.
22:59:38 <simpson> (Which shouldn't be in haddock but are really important for some extensions.)
23:00:19 <edwardk> the documentation stuff we won't be able to get, but we do hyperlink to the specification for the extension when the specification exists
23:00:20 <edwardk> if you click on the link above the extension flag it'll go to khronos
23:00:55 <edwardk> e.g. where it says "checks that ... is available"
23:01:19 <edwardk> when there is a known manual page we link to those as well
23:01:37 <edwardk> we're missing some cleanup to make it so we catch a few 'catch-all' pages in the manual though
23:07:11 <simpson> Yep: http://ekmett.github.io/gl/Graphics-GL-Raw-Extension-NV-TextureRectangle.html
23:07:22 <simpson> Links to https://cvs.khronos.org/svn/repos/ogl/trunk/doc/registry/public/specs/NV/texture_rectangle.txt
23:07:48 <simpson> Which has such gems as "Should anything be said about performance? No."
23:08:34 <edwardk> simpson: if we can get the enums linked back to what groups reference them, better scraping off the man pages to know what to link to, and a few other things in the manual for this should actually be almost usable
23:09:06 <edwardk> pretty happy with the ratio of time invested to quality improvement
23:09:18 <edwardk> been hacking on the docs for ~3-4 hours now
23:09:31 <dfeuer> Hi people.
23:09:35 <simpson> Nice. Hacking on docs is always arduous, but it's definitely paying off.
23:10:28 <dfeuer> edwardk, now that you've got a minion working on that graphics stuff, do you think you could take a peek at D417?
23:10:29 <phaskell> D417: Improve Applicative and Monad instances in Base - https://phabricator.haskell.org/D417
23:11:03 <edwardk> i think i'm going to take a peek at the back of my eyelids
23:11:36 <jle`> b 17
23:11:50 <dfeuer> Eyelids?
23:11:54 <dfeuer> No eyelids for you!
23:12:19 <dfeuer> Good night.
23:12:33 <dfeuer> jle`, how would you like to take a peek?
23:14:39 <jle`> at eyelids?
23:15:19 <assia_t> Is there any way of writing a function (say `putStrLn`) that could take any `String-ish` type?
23:19:55 <merijn> assia_t: How would you qualify "a String-ish type"?
23:20:08 <joneshf-laptop> :t print -- assia_t
23:20:10 <lambdabot> Show a => a -> IO ()
23:20:16 <assia_t> Text, ByteString, Lazy ByteString, String, whatever
23:20:38 <dfeuer> Yeah, Show is one version of "stringish", but there are also classes for pretty-printable things.
23:20:41 <dfeuer> And serializable things.
23:20:44 <dfeuer> And and and and.
23:20:53 <assia_t> joneshf-laptop: That prints strings with quotes around them.
23:21:20 <Cale> assia_t: I think the answer is pretty much "no", though you could make your own type class for it.
23:21:34 <assia_t> Cale: Ok! Thanks
23:21:38 <dfeuer> Cale, there are pretty-printing packages on Hackage.
23:21:42 <joneshf-laptop> isn't thre already a type class for that?
23:21:52 <nkar> is it okay to have a separate datatype representing all options?  for example, data Opt1 = Opt1; data Opt2 = Opt2; data All = All instead of using the first two and a list?  so far, I've been doing the latter, but it makes working with the "all" case harder.  you don't know what's inside the list until you map over it.  I guess the answer is "it depends," but I'd be glad to hear your thoughts on this.
23:21:54 <Cale> There is the opposite
23:22:01 <Cale> :t fromString
23:22:02 <lambdabot>     Not in scope: ‘fromString’
23:22:03 <lambdabot>     Perhaps you meant one of these:
23:22:03 <lambdabot>       ‘BSLC.fromStrict’ (imported from Data.ByteString.Lazy.Char8),
23:22:06 <Cale> er
23:22:08 <assia_t> :info IsString
23:22:18 <assia_t> ^^
23:22:25 <assia_t> Data.String
23:22:33 <Cale> right
23:22:40 <Cale> :t Data.String.fromString
23:22:41 <lambdabot> Data.String.IsString a => String -> a
23:22:55 <Cale> But there's no corresponding toString
23:23:51 <Cale> nkar: I don't completely understand your question
23:24:28 <merijn> Advanced (a few mini-Olegs?) type-hacker question. Given a GADT record "data Foo :: MyKind -> * where Foo :: { blah :: MyKind, bar :: Int } -> Foo k", what's the easiest way to construct Foo, such that the phantom parameter 'k' always matches the value inside the 'blah' field?
23:24:58 <nkar> Cale: I'll provide another example in a second
23:25:23 <merijn> I tried using singletons, so that I could use fromSing, but GHC isn't smart enough to infer the a SingI instance exists
23:25:27 <Cale> merijn: uh, is that even valid?
23:26:03 <merijn> Cale: Sure, why not?
23:26:17 <merijn> MyKind being a DataKinds lifted type, obviously
23:26:24 <Cale> In order to be the type of a record field, doesn't something need to be of kind *
23:26:24 <Cale> ?
23:26:31 <Cale> oh
23:27:15 <merijn> Cale: Right, so I'm trying to enforce that the type parameter reflects the value inside the field. Which is...tricky :\
23:27:38 <merijn> Relying on programmers to always specify matching type + field when constructing seems error prone
23:30:10 <Cale> Well, you could definitely use singletons anyway
23:30:44 <Cale> I think that's really the only thing you can do -- at least as far as I know. If it can't infer, it's just inconvenient.
23:31:36 <merijn> Cale: Eh, how would I use singletons here?
23:32:24 <merijn> I tried using singletons, but they can't do what I need, because GHC isn't smart enough to see that all types of kind MyKind are SingI instances
23:32:52 <Cale> Don't use SingI, just use Sing
23:32:52 <merijn> So I would still be specifying value and type seperately, which means they may become inconsistent
23:33:01 <Cale> Let me try
23:40:33 <Cale> merijn: wait, SingI does work
23:41:43 <Cale> http://lpaste.net/113670
23:42:24 <emmanueloga> Hi. In code needing to do something for all coordinates in (width, height), I can see that people usually use list comprehensions since haskell doesn't have forEach or any other loops. E.g.: https://github.com/snkkid/LazyFooHaskell/blob/master/lesson31/lesson31.hs#L100
23:43:03 <Cale> emmanueloga: Haskell has lots of different sorts of loops, they're mostly library functions
23:43:12 <Cale> :t forM
23:43:13 <lambdabot> Monad m => [a] -> (a -> m b) -> m [b]
23:43:26 <emmanueloga> My question is: does the compiler *really* allocate that list of tuples, or does it just perform the iteration, since it *could* realize (I think) the list is not really being used anywhere else.
23:44:18 <Cale> It may or may not allocate the list, but even if it does allocate it, each entry is immediately garbage assuming that you don't hold a reference to the whole list and use it somewhere else
23:44:36 <Cale> So it can still run in O(1) space even if it does the allocations
23:44:55 <Cale> But there are lots of rewrite rules for combining operations which produce lists and operations that consume them
23:45:11 <Cale> So, it might be that your lists don't actually get allocated at all
23:45:53 <Cale> emmanueloga: btw, consider using guards
23:46:27 <emmanueloga> how so?
23:46:27 <Cale> emmanueloga: let flipAxis | flipBoth `intersect` flags == flipBoth = ...
23:46:47 <Cale> emmanueloga:              | Horizontal `elem` flags = ...
23:46:51 <Cale> etc.
23:46:57 <emmanueloga> ah, instead of the nested if
23:47:35 <merijn> Cale: hmm, let me try that
23:47:57 <nkar> Cale: imagine that you need to define a datatype corresponding to a checkbox.  a user may select option1, option2, both, or none.  I usually define data Opt = Opt1 | Opt2 and use a list to represent the "both" case.  I've been doing so because, if I need to add another option, I can just add another value constructor and a handler function, which I map over the list of options.  But it makes working with the "both" case harder because
23:47:58 <nkar> map handles value constructors one by one.  It would be much easier to work with just data Opt = Opt1 | Opt2 | Both, but it doesn't generalize well (when you need more options).  So I wonder whether it's a good idea or not.
23:48:06 <emmanueloga> txs
23:48:24 <fread2282> github has free stuff for students https://education.github.com/pack including private travis and github accounts and digitalocean credit
23:48:32 <merijn> nkar: A better way might be to model that as an Array/Vector of booleans?
23:48:53 <Cale> Or as a function Opt -> Bool?
23:49:55 <nkar> merijn, Cale: could you elaborate?
23:50:35 <Cale> nkar: Well, you have an assignment to each of the options, a decision about whether or not it's checked, right?
23:50:50 <Cale> i.e. you have a function from the type of options to Bool
23:51:39 <Cale> an array is just another way of recording a function on a finite domain
23:51:50 <Cale> So our suggestions are actually pretty similar
23:52:19 <fread2282> nkar: on a finite enumerable domain, (a -> b) ~ Map a b
23:52:30 <nkar> you mean an array of type [(Opt,Bool)], right?
23:52:36 <solatis> :t Control.Monad.STM.atomically
23:52:38 <Cale> That's not an array type
23:52:38 <lambdabot> GHC.Conc.Sync.STM a -> IO a
23:52:40 <fread2282> nkar: yep
23:52:46 <Cale> I mean like Array Opt Bool
23:52:59 <solatis> i understand that function is the official way to 'lift' an STM monad to an IO monad?
23:53:06 <Cale> Arrays are not the same thing as lists
23:53:11 <nkar> well, the internals are different, but the usage is similar, no?
23:53:26 <fread2282> nvm
23:53:28 <Cale> Or you could use Map Opt Bool
23:53:52 <Cale> But I was originally just suggesting Opt -> Bool
23:54:02 <Cale> because that's about as representation-agnostic as it gets
23:54:48 <DTSCode> im trying to install ghc, and am getting these errors http://paste.ubuntu.com/8794146/ does that mean i need gmp version 3?
23:54:52 <nkar> Cale: okay, thank you
23:55:11 <Cale> nkar: Lists have the ugliness that the same entry can be listed many times
23:55:39 <Cale> DTSCode: make sure that libgmp3 is installed
23:55:41 <nkar> good point!
23:55:43 <merijn> solatis: That question doesn't make sense?
23:55:50 <Cale> DTSCode: Do you have a libgmp3c2 package?
23:55:54 <DTSCode> Cale, how would i do that?
23:56:02 <DTSCode> let me see
23:56:02 <joneshf-laptop> nkar, Cale i'm trying to follow along at home (and it's late so bear with me), how does this answer the question?
23:56:11 <Cale> Also, that's a really old version of GHC that you're attempting to install
23:56:18 <Cale> Are you sure that's the one you want?
23:56:19 <joneshf-laptop> nkar, Cale or do i not understand the question
23:56:22 <fread2282> nkar: Array Opt Bool is [Bool] where we use fromEnum to decide what element to look at
23:56:22 <DTSCode> i know. i need it for a project
23:56:56 <DTSCode> Cale, i dont have that package
23:56:56 <solatis> merijn: yeah nevermind i was nonsense
23:57:19 <DTSCode> also, the project (geordi (specifically the clang branch)) requires that version
23:58:47 <Cale> joneshf-laptop: I dunno! I figured if it didn't answer it then nkar would explain more about what he's trying to do. I thought the question was about how best to represent a choice of a subset of the elements of a type.
23:59:00 <Cale> nkar: Oh, also, don't forget about Set Opt
23:59:02 <fread2282> nkar: also Array uses an array instead of a singly linked list
23:59:07 <Cale> Data.Set is also pretty useful
23:59:40 <joneshf-laptop> Cale, heh, alright, then it's probably too late for me :D
