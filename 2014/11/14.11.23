00:07:27 <haskellquestion> is there a better way of doing this? data DataType = DataType Int Int Int                                     getColumn (DataType a b c) = b                          someMethod = getColumn $ somethingThatGivesDataType
00:07:45 <haskellquestion> seems kinda weird to need a method just to pattern match a value out of a data type
00:08:21 <dhrosa> yes there is
00:08:30 * hackagebot brainfuck-tut 0.5.1.2 - A simple BF interpreter.  http://hackage.haskell.org/package/brainfuck-tut-0.5.1.2 (alcabrera)
00:08:30 * hackagebot brainfuck-tut 0.5.1.3 - A simple BF interpreter.  http://hackage.haskell.org/package/brainfuck-tut-0.5.1.3 (alcabrera)
00:08:51 <dhrosa> haskellquestion: you can name each of the parameters, which then provides you a function to extract those params
00:09:02 <jfeltz> haskellquestion: record syntax
00:09:08 <haskellquestion> ok thanks i'll look into it!
00:09:28 <dhrosa> I derped and forgot the name, yeah record syntax :p
00:11:07 <Hijiri> wait
00:11:10 <Hijiri> hacker news has comments
00:11:13 <haskellquestion> hooray it works
00:11:13 <Hijiri> how did I never notice this
00:19:13 <codygman> Does printing out a value affect it's laziness? I'm getting an error without a print statement and I think it has to do with laziness.
00:20:30 <vanila> when you print something out it is forced completely
00:20:37 <vanila> including any computations needed to result in that value
00:21:10 <codygman> vanila: Thanks... though I commented it out and can't reproduce the error... weird
00:45:33 <Zyxoas> > scanl (+) 0 [1..5]
00:45:35 <lambdabot>  [0,1,3,6,10,15]
00:59:51 <svteoi> clojure or haskell ?
01:00:50 <Hijiri> what channel do you think you're in?
01:02:00 <Yuras> @help bf
01:02:00 <lambdabot> bf <expr>. Evaluate a brainf*ck expression
01:03:44 <svteoi> I have developed an algorythm
01:03:44 <thungsten> bf ">>.>---.+++++++..+++.>>.<-.<.+++.------.--------.>>+.>++."
01:04:04 <thungsten> > bf ">>.>---.+++++++..+++.>>.<-.<.+++.------.--------.>>+.>++."
01:04:06 <lambdabot>  Not in scope: ‘bf’
01:04:06 <lambdabot>  Perhaps you meant one of these:
01:04:06 <lambdabot>    ‘b’ (imported from Debug.SimpleReflect),
01:04:06 <lambdabot>    ‘f’ (imported from Debug.SimpleReflect)
01:04:16 <svteoi> 90% of the people who were gonna say haskell would get nullified
01:04:27 <svteoi> so it ballances out the outcome
01:04:56 <svteoi> ps. clojure is weighted by .15
01:05:03 <vanila> clojure is cool
01:05:04 <wz1000> Do folds in general offer any performance differencr compared to explicit recursion?
01:05:09 <svteoi> hm
01:05:22 <Yuras> @bf >>.>---.+++++++..+++.>>.<-.<.+++.------.--------.>>+.>++.
01:05:22 <lambdabot>  Done.
01:05:35 <svteoi> > bf ">>.>---.+++++++..+++.>>.<-.<.+++.------.--------.>>+.>++."
01:05:36 <lambdabot>  Not in scope: ‘bf’
01:05:36 <lambdabot>  Perhaps you meant one of these:
01:05:36 <lambdabot>    ‘b’ (imported from Debug.SimpleReflect),
01:05:36 <lambdabot>    ‘f’ (imported from Debug.SimpleReflect)
01:06:13 <svteoi> haskell is surely faster then clojure
01:06:26 <svteoi> as clojure compiles in jvm
01:06:26 <vanila> yes
01:06:59 <svteoi> I guess clojure is better off compared with scala
01:07:14 <vanila> scala is too complex, its scary
01:07:17 <vanila> i prefer simple
01:07:29 <wz1000> svteoi: http://benchmarksgame.alioth.debian.org/u32/benchmark.php?test=all&lang=ghc&lang2=clojure&data=u32
01:09:18 <wz1000> BTW, anyone know why k-nucleotide's and regex-dna's haskell implementation is extremely slow compared to the rest.
01:10:08 <vanila> can I see the code?
01:10:30 <vanila> http://benchmarksgame.alioth.debian.org/u32/benchmark.php?test=knucleotide&lang=ghc&data=u32
01:11:55 <zett_zelett> Quick question: https://www.haskell.org/haskellwiki/Yi#Trivia says that Y I is the most recursive acronym. Just learning about the Y combinator, is I supposed to denote the identity in this joke?
01:12:08 <vanila> the code doesnt look good for the benchmark thing
01:12:26 <vanila> zett_zelett, I guess so, Y I = I (Y I) = Y I
01:12:34 <zett_zelett> Ah, thx.
01:12:58 <marvin-hh> wz1000: Haskell's hashmap is slow, for example.
01:13:45 <marvin-hh> wz1000: but that's part of the benchmark; GHC's implementation of a Hashmap is just not as fast as it is in other languages.
01:13:59 <wz1000> Even mandlebrot is relatively slower than the other programs
01:13:59 <vanila> lets write a faster versiopn
01:14:28 <vanila> http://benchmarksgame.alioth.debian.org/u32/performance.php?test=mandelbrot haskell is very bad at mandelbrot
01:14:39 <marvin-hh> wz1000: and, if you look at that program, you also immediately see why Haskell isn't as high-level as people want you to believe.
01:15:24 <marvin-hh> wz1000: it's a huge pile of code, which is much, much shorter when done in a language with a better library and/or compiler.
01:16:00 <vanila>         coords = [T 1 0 y (fromIntegral y * m - 1) | y <- [0..w-1]]
01:16:06 <vanila> that looks bad
01:16:23 <marvin-hh> vanila: did you profile it?
01:16:39 <marvin-hh> vanila: it might be that the whole list is eliminated.
01:17:22 <marvin-hh> Anyway, that's another issue; to predict whether a given program is going to be highly efficient, you need to know which compiler you are working with, and even which version.
01:18:13 <wz1000> marvin-hh: Its GHC 7.8.2
01:18:53 <marvin-hh> wz1000: I don't think you quite understood my point.
01:19:03 <merijn> marvin-hh: The same goes for C/C++, though
01:19:11 <marvin-hh> merijn: to a much lesser degree.
01:19:15 <merijn> Hell, that's not even sufficient
01:19:25 <merijn> You need to know the exact architecture you're compiling for
01:20:17 <wz1000> marvin-hh: Oh, you're talking about the standard library?
01:20:27 <vanila> erlang is the best at k-nucleotide
01:20:40 <marvin-hh> wz1000: a combination of standard library and the compiler.
01:20:48 <vanila> wiat i read it wrong, erlang is worst
01:21:17 <vanila> http://benchmarksgame.alioth.debian.org/u64/benchmark.php?test=fasta&lang=all&data=u64
01:21:26 <vanila> why is haskell almost winning at fasta, but losing at k-nucleotide
01:21:53 <vanila> http://benchmarksgame.alioth.debian.org/u64/program.php?test=fasta&lang=ghc&id=2
01:22:02 <vanila> except for using CStrings the code looks much better
01:22:10 <marvin-hh> merijn: can you give a concrete example of that?
01:23:20 <marvin-hh> merijn: and while you can always try to write assembly for some stuff, almost nobody does that anymore.
01:23:40 <marvin-hh> Exactly, because what C++ compilers do is so predictable and fairly optimal.
01:23:56 <merijn> marvin-hh: Needed to rewrite some code because ivybridge architecture is different from sandybridge and I was getting a pipeline stall in my inner loop
01:24:11 <merijn> marvin-hh: What C++ compilers do is dark unpredictable voodoo :)
01:24:41 <marvin-hh> merijn: what exactly did you do? Did you just remove the old code or did you add CPU detection code?
01:24:44 <merijn> Why? Because some obscure voodoo code layout thing somehow messed with the branch predictors accuracy, etc.
01:25:09 <merijn> marvin-hh: Remove the old code, because the cluster is moving to ivybridge anyway
01:25:14 <marvin-hh> merijn: and additionally, where do you work that you even need to care about such optimizations?
01:25:22 <wz1000> Wait, ruby and clojure are faster than Haskell at k-nucleotide.
01:25:49 <MP2E> o.O
01:26:00 <merijn> marvin-hh: Doing a internship on graph processing at Oracle Labs. Turns out your inner loop matters if it's run for billions of vertices :)
01:26:30 <marvin-hh> merijn: oh, if you are an intern, then you are cheap :)
01:26:55 <merijn> Not particularly :p
01:27:36 <marvin-hh> merijn: if you get paid a decent amount, it's called a job.
01:27:43 <marvin-hh> merijn: or you are a freelancer.
01:27:47 <wz1000> And PHP and Python beat haskell at regex-dna
01:27:53 <marvin-hh> But then you would be "freelancing".
01:28:10 <vanila> we should improve the haskellsolutions :)
01:28:14 <marvin-hh> merijn: but why aren't they using their precious Java for this?
01:29:01 <merijn> marvin-hh: There's a parallel java implementation, but that's not nearly as fast as the C++ one, obviously
01:29:28 <marvin-hh> merijn: I don't agree with the obviously part.
01:29:44 <merijn> marvin-hh: JVM is pretty limited
01:30:11 <merijn> For one, it doesn't support 64bit array indices, which is a problem since our CSR (compressed sparse row) representation is bigger than that
01:30:37 <merijn> Anyway, this is considerably off-topic here, so if you wanna continue let's move it to PM :)
01:33:36 <wz1000> Wat. http://benchmarksgame.alioth.debian.org/u32/benchmark.php?test=threadring&lang=all&data=u32 Read the code..
02:07:59 <droidboi> In ghci, after import Data.Set (Set). and import qualified Data.Set as Set, I try to evaluate "empty" and I get "Not in scope: `empty'" and "Perhaps you meant `Set.empty' (imported from Data.Set)". What am I not doing so that I can use Set functions unqualified?
02:10:58 <ChristianS> droidboi: you could write just "import Data.Set", but do don't want that since it collides with Prelude functions
02:11:18 <ChristianS> droidboi: just write Set.empty, nothing wrong with that
02:13:29 * hackagebot yaml 0.8.10 - Support for parsing and rendering YAML documents.  http://hackage.haskell.org/package/yaml-0.8.10 (MichaelSnoyman)
02:14:57 <droidboi> ChristianS: OK. Doing just import Data.Set does allow an unqualified empty. At least I know that now. I got no problem with using Set.empty. Thanks
02:15:23 <droidboi> just playing with Data.Set for a bit
02:15:47 <wdanilo> Hello! I've got a fancy question to you today :) What should I use - StateT s (EitherT err m) a    or   EitherT err (StateT s m) a ? Is there any performance difference when throwing "left" ? I assume thre is and that faster version should be  "StateT s (EitherT err m) a " - because Either is the "outermost" monad (after running the transformers) - am I right?
02:18:29 * hackagebot yesod-core 1.4.4.2 - Creation of type-safe, RESTful web applications.  http://hackage.haskell.org/package/yesod-core-1.4.4.2 (MichaelSnoyman)
02:22:58 <mreh> * Missing C libraries: crypto, ssl
02:23:04 <mreh> any ideas what they might be on ubuntu?
02:25:30 <mreh> mreh: libssl-dev
02:25:33 <mreh> thanks
02:29:20 <lb5tr> hi guys, I'm trying to create condintional arrow, meaning cond :: (ITrans a b, ITrans a, b) -> (Bool, a) -> ITrans a b
02:29:46 <lb5tr> lets assume i have 2 different computation paths d and e, d,e :: ITrans a b
02:30:27 <lb5tr> I'm at the point where I'm creating an arrow that returns an arrow (ITrans a (Itrans a b)), and i have a problem while 'unpacking
02:30:34 <lb5tr> this argument
02:30:50 <lb5tr> i don't know if that makes any sense to you
02:31:11 <lb5tr> problem is, cond have to also be an arrow (arr $ cond (f1,f2) True)
02:36:48 <droidboi> I did import Data.Set and tried splitRoot and got "Not in scope: `splitRoot'". Any ideas why that is?
02:38:00 <droidboi> I did split[Tab] and splitRoot didn't appear as possibility
02:38:29 * hackagebot yesod-core 1.4.4.3 - Creation of type-safe, RESTful web applications.  http://hackage.haskell.org/package/yesod-core-1.4.4.3 (MichaelSnoyman)
02:38:31 * hackagebot resourcet 1.1.3 - Deterministic allocation and freeing of scarce resources.  http://hackage.haskell.org/package/resourcet-1.1.3 (MichaelSnoyman)
02:38:41 <droidboi> Only split splitAt splitMember
02:39:10 <geekosaur> it's not in the version you have installed. note that upgrading the containers package is risky at best
02:52:22 <xificurC> if I have e.g. data Foo = A Int | B Int and func :: [Foo] -> Int how can I pattern match func for a list of A's?
02:53:06 <xificurC> e.g. for a list of As sum the numbers, for list of Bs multiply them
02:55:06 <Freundlich> A list of Foos can have either A or B for each element. Maybe you want to use A [Int] | B [Int]?
02:57:24 <xificurC> Freundlich: no, following my simplified example for list of just As sum, list of just Bs product, otherwise fail
03:07:02 <sivteck> xificurC, use Sum Int and Product Int ?
03:07:24 <sivteck> > mconcat $ map Sum [1,2,3,4,5]
03:07:26 <lambdabot>  Sum {getSum = 15}
03:08:17 <xificurC> sivteck: this was just a simplified example of a different problem. I guess I'll show what I'm trying to do, I just didn't want to bore you with the details
03:09:25 <xificurC> I'm going through this https://en.wikibooks.org/wiki/Write_Yourself_a_Scheme_in_48_Hours/Evaluation,_Part_1 and at the end the author defines numericBinop that works with numbers, strings and singleton lists
03:10:01 <xificurC> I wanted to change numericBinop so that it only works with Number's and wanted to drop the helper function unpackNum entirely
03:55:10 <trap_exit_> what is the easiest way to setup distributed haskell? I feel like I need to (1) boot up multiple Digitla ocean instances (2) isntall ghc (3) setup authentication, (4) run distributed haskell
03:55:22 <trap_exit_> instead, I'd prefer to have a places where I just choose how many machines, and distributed haskell is setup already for me
03:56:40 <mreh> trap_exit_ Digital Ocean snapshots?
03:57:03 <trap_exit_> you mean write a script which uses digital ocean API ?
03:57:16 <mreh> could do
03:57:35 <mreh> http://docs.ansible.com/digital_ocean_module.html
03:57:44 <mreh> I would try ansible
03:58:29 <mreh> doesn't look like there's an option for the snapshot to build the new droplet with though
04:15:25 <trap_exit> this is somewhat OT, but please forgive me:
04:15:33 <trap_exit> what is simplest machine I can get to support a cluster of http://www.phoronix.com/scan.php?page=news_item&px=MTgzNjY ?
04:18:33 * hackagebot is 0.2 - Pattern predicates using TH  http://hackage.haskell.org/package/is-0.2 (vlopez)
04:18:50 <codygman> The ability haskell gives you to tear apart your entire programs architecture and change it totally, refactor once, and things just work... is addictive.
04:21:02 <kvanb> codeburg: heard that like 5 times this month in this channel already
04:22:31 <MP2E> lol
04:23:36 <trap_exit> codygman: details
04:26:59 * mreh remembers when this channel used to be ~400 nicks
04:27:54 <aristid_> mreh: when was that?
04:28:42 <mreh> aristid_ when a dollar could buy you a tank of gasoline
04:28:55 <mreh> 5 years?
04:29:08 <mreh> probably a bit more
04:29:14 <codygman> trap_exit: lol. It isn't that much really, just a continued history of: Oh, I should change my getInputs function to take an ADT instead of a Bool, then compile, fix all the errors listed, recompile... and.. nothing went wrong. Or, "I should rewrite this function. *writes type signature*. Write a flurry of code without type checking/testing/anything. compile... it.. just... works.
04:29:21 <aristid_> mreh: all i recall is thinking at some point that 800 people was a lot
04:30:22 <aristid_> number of users has been exploding, but activity is pretty flat: http://ircbrowse.net/haskell
04:43:34 * hackagebot chesshs 0.2.0 - Simple library for validating chess moves and parsing PGN files  http://hackage.haskell.org/package/chesshs-0.2.0 (ArnoVanLumig)
04:44:19 <Peaker_> I just realized that "Idiom brackets", when nested, become "Monad brackets", and if have a light-weight syntax (e.g: !foo instead of [[foo]] when precedence is clear anyway) could be pretty useful in "do" notation in general, and not just for Applicative
04:44:57 <bitraten> hi, I have some problem with catching exceptions and laziness (i think) https://gist.github.com/bitraten/e0ef766955b59bf462e3
04:47:04 <benmachine> Peaker: I do not follow
04:51:39 <codygman> I need to retry a function 5 times and move to my next action on success, or if all 5 fail throw an error. Is there an easy way to do this?
04:52:03 <benmachine> codygman: depends how easy you want
04:52:17 <benmachine> the direct recursion works pretty well
04:53:07 <Kaligule> bitraten: I didn't even know there is something like Errorhandling in Haskell
04:53:26 <gds> Use lists? Something like takeWhile failure $ map apply $ repeat 5 action
04:54:08 <gds> where "failure" could be "== Nothing" if you're using the maybe monad, or whatever...
04:54:28 <gds> and "apply" is whatever is appropriate for making your action go.
04:55:14 <codygman> benmachine: Alright, I thought that might way might be easiest. Thanks
04:58:35 * hackagebot http-client 0.4.5 - An HTTP client engine, intended as a base layer for more user-friendly packages.  http://hackage.haskell.org/package/http-client-0.4.5 (MichaelSnoyman)
05:02:16 <Confusionist> There's probably a better way to do this then with a lambda: map (\(a, b) -> (2*a, b)) [(1, "something"), (2, "whatever"), (3, "foo")]
05:02:58 <Confusionist> I would expect something like mapFst
05:03:27 <Confusionist> But importing Data.Graph.Inductive.Query.Monad seems a bit silly for my purposes
05:04:59 <bennofs> > (mapped._2 *~ 2) [(1,"something"), (2,"whatever"), (3, "foo")] -- using lens
05:05:01 <lambdabot>  Could not deduce (GHC.Num.Num [GHC.Types.Char])
05:05:01 <lambdabot>    arising from a use of ‘Control.Lens.Setter.*~’
05:05:01 <lambdabot>  from the context (GHC.Num.Num t)
05:05:01 <lambdabot>    bound by the inferred type of
05:05:01 <lambdabot>             it :: GHC.Num.Num t => [(t, [GHC.Types.Char])]
05:05:03 <y> first (2*)?
05:05:05 <bennofs> > (mapped._1 *~ 2) [(1,"something"), (2,"whatever"), (3, "foo")] -- using lens
05:05:06 <lambdabot>  [(2,"something"),(4,"whatever"),(6,"foo")]
05:05:23 <bennofs> > map (first (*2)) [(1,"something"), (2,"whatever"), (3, "foo")] -- using Control.Arrow.first
05:05:24 <lambdabot>  [(2,"something"),(4,"whatever"),(6,"foo")]
05:14:17 <Confusionist> Arrow version seems nicer... I'll have to figure out how to make that work with a 3-tuple though
05:14:35 <Confusionist> Haven't used Arrows before and type signatures don't immediately make sense
05:15:30 <y> the type signatures make more sense if you move from prefix to ("fake") infix (a b c → b `a` c)
05:24:25 <Confusionist> Simplest solution: use structure (a, (b, c)) instead of (a, b, c). 2nd and 3rd components belong together anyway
05:25:01 <y> isomorphic structures to the rescue?
05:32:24 <kcc> How does the Eq instance for Text compare texts? Does it use NKC, NFD or something else?
05:32:52 <kcc> NFC I mean
05:36:14 <alpounet> kcc: https://github.com/bos/text/blob/master/Data/Text.hs#L318
05:36:49 <indiagreen> kcc: it just compares 2 arrays, nothing more (and “pack”ing doesn't do normalisation either, only replaces invalid codepoints)
05:37:20 <kcc> So looks like I have to use the text-icu package
05:39:04 <fds4345> hello
05:39:22 <fds4345> can anyone tell me why this attoparsec parser always returns a Partial?
05:39:24 <fds4345> many ((takeWhile (notInClass " \"")) <* A8.skipSpace)
05:40:50 <fds4345> actually, this also returns partial: many $ takeWhile $ notInClass " \""
05:41:13 <bergmark> fds4345: use parseOnly if you want to parse all of the input
05:41:49 <fds4345> shoulda RTFM... Note: Because this parser does not fail, do not use it with combinators such as many, because such parsers loop until a failure occurs
05:41:54 <fds4345> thx
05:42:37 <bergmark> kcc: i use a newtype over NFC normalized Text
05:44:57 <kcc> The text-icu package is not making me confident... Almost every function uses unsafePerformIO
05:46:23 <bergmark> kcc: we use it in production, don't think it has caused any issues
05:47:01 <torpet> I am writing a function for a rose tree, in which each node has an embedded function
05:47:19 <torpet> Now I am trying for a given Integer to find the function which maximizes this Integer input
05:47:20 <torpet> http://lpaste.net/509185166262927360
05:47:54 <torpet> More or less my function is finished, but I don't know what to return when current f(x) is _not_ larger than the previous ones
05:48:37 * hackagebot barecheck 0.2.0.2 - QuickCheck implementations for common types  http://hackage.haskell.org/package/barecheck-0.2.0.2 (OmariNorman)
05:49:26 <Phillemann> Hm, Parsec's home page (on hackage) is down.
05:49:43 <Phillemann> Is there sort of a "reference tutorial" on parsec?
05:54:45 <Haskellfant> what happens if I an exception gets thrown during resource acquisition using bracket? will release still be executed? as far as I understand it it the exception will be thrown as soon as mask is over or restore is called, so in the case of bracket it will be thrown when calling restore (thing a), but am I right?
05:58:37 * hackagebot rainbow 0.20.0.2 - Print text to terminal with colors and effects  http://hackage.haskell.org/package/rainbow-0.20.0.2 (OmariNorman)
05:58:39 * hackagebot rainbow-tests 0.20.0.2 - Tests and QuickCheck generators to accompany rainbow.  http://hackage.haskell.org/package/rainbow-tests-0.20.0.2 (OmariNorman)
05:59:14 <Gurkenglas> Are there any papers on making djinn work on recursive data structures?
06:02:20 <hexagoxel> Gurkenglas: do you want actually pattern-matching capability or just allowing recursive data structures?
06:02:54 <Gurkenglas> What do you mean by pattern-matching capability?
06:02:55 <trap_exit> RWH says to use parsec ... but RWH is outdated. What should I use for parsing?
06:03:09 <Haskellfant> parsec or atto-parsec
06:03:26 <Haskellfant> parsec has better error messages and is afaik a bit more powerful, but slower
06:05:14 <trap_exit> hmm, what features does atto-parsec lack ?
06:07:02 <Phillemann> There's also trifecta, not sure when to use that.
06:08:02 <Haskellfant> there is a small comparision in attoparsec http://hackage.haskell.org/package/attoparsec-0.12.1.2/docs/Data-Attoparsec-ByteString.html
06:08:04 <hexagoxel> Gurkenglas: like.. djinn can implement fromMaybe by pattern-matching on the Maybe. do you want the same for a recursive data type, or would it be sufficient to allow recursive definitions (i.e. construction but not deconstruction)?
06:08:11 <Haskellfant> not sure if it's missing anything
06:08:21 <Haskellfant> I recall having read that but I don't think I've ever encountered it
06:08:35 <Haskellfant> well according to this it can't be used as a monad transformer
06:09:34 <Gurkenglas> hexagoxel, the former.
06:11:55 <Gurkenglas> (Hmm. If a type signature allows multiple implementations, maybe it should output a respective recursive structure of implementations...)
06:12:17 <hexagoxel> Gurkenglas: my estimate is that pattern-matching on recursive data types is not compatible with djinn's approach, but i cannot give references
06:12:56 <Gurkenglas> :t unfoldr --, for example, seems like something that Djinn should be able to produce
06:12:57 <hexagoxel> reasoning: with a recursive data structure, you could reach an ininite amount of types
06:12:57 <lambdabot> (b -> Maybe (a, b)) -> b -> [a]
06:14:19 <hexagoxel> e.g. data RecTuple a = A a | B (RecTuple (a,a))
06:15:02 <hexagoxel> and you want the query RecTuple a -> ((a,a),(a,a)) to work
06:15:52 <Gurkenglas> Sure, that is one of the queries that sounds simple to solve.
06:20:34 <hexagoxel> djinn's current approach is to pattern-match by default (which terminates because non-rescursive)
06:21:37 <hexagoxel> but i think it is not possible to decide if pattern matching on a recursive data structure will give a desired type at some point
06:21:48 <kqr> what's the easiest way to map a function over a 2-tuple?
06:21:56 <Fuuzetsu> :t (***)
06:21:57 <lambdabot> Arrow a => a b c -> a b' c' -> a (b, b') (c, c')
06:22:06 <hpc> :t (&&&) -- also
06:22:06 <lambdabot> Arrow a => a b c -> a b c' -> a b (c, c')
06:22:17 <hpc> (f *** g) (a,b) = (f a, g b)
06:23:38 * hackagebot rosa 0.1.1.0 - Query the namecoin blockchain  http://hackage.haskell.org/package/rosa-0.1.1.0 (rnhmjoj)
06:23:53 <kqr> and something like join (***) f (a,b) === (f a, f b)?
06:23:58 <hexagoxel> and djinn's main property (as i understand it) is termination
06:26:54 <kqr> hpc, that was weird. I thought `both` would be roughly the same as `join (***)` but one type errored and the other didn't
06:30:56 <trap_exit> so I'm reading https://www.fpcomplete.com/school/starting-with-haskell/libraries-and-frameworks/text-manipulation/attoparsec ... and I don't understand <|> ... in "a <|> b" ... if "a" consumes inputs, and then fails, is "b" tried ?
06:32:48 <bergmark> trap_exit: yes attoparsec always backtracks
06:33:21 <trap_exit> bergmark:hmm, so "a <|> b // atto-parsec" is always like "(try a) <|> b // parsec" ?
06:33:27 <trap_exit> if so, why did they make this change?
06:33:39 * hackagebot semi-iso 0.4.0.0 - Weakened partial isomorphisms that work with lenses.  http://hackage.haskell.org/package/semi-iso-0.4.0.0 (pawel834)
06:33:41 * hackagebot syntax 0.2.0.0 - Abstract syntax descriptions for parsing and pretty-printing.  http://hackage.haskell.org/package/syntax-0.2.0.0 (pawel834)
06:33:43 * hackagebot syntax-attoparsec 0.2.0.0 - Syntax instances for Attoparsec.  http://hackage.haskell.org/package/syntax-attoparsec-0.2.0.0 (pawel834)
06:34:42 <bergmark> trap_exit: i don't know, perhaps because it can be hard to reason about when backtracking occurs in parsec
06:35:43 <trap_exit> https://www.haskell.org/pipermail/haskell-cafe/2013-March/107004.html
06:35:44 <trap_exit> hmm
06:35:50 <trap_exit> where is Brian O Sullivan?
06:35:52 <trap_exit> he is the author of atto-parsec
06:36:01 <trap_exit> we need to call him to court to answer for his design decisions
06:36:09 <Gurkenglas> hexagoxel, aren't the "grammars definable through recursive types" (making up associations and hoping my meaning is clear) context-free? The word problem shouldn't be a problem.
06:36:12 <geekosaur> mailing list
06:38:17 <trap_exit> http://stackoverflow.com/questions/19208231/attoparsec-or-parsec-in-haskell is useful
06:38:21 <trap_exit> I think I'm going to go with parsec
06:38:35 <fraytormenta34> hmmm
06:38:39 * hackagebot syntax-pretty 0.2.0.0 - Syntax instance for pretty, the pretty printing library.  http://hackage.haskell.org/package/syntax-pretty-0.2.0.0 (pawel834)
06:38:41 * hackagebot syntax-example 0.3.0.0 - Example application using syntax, a library for abstract syntax descriptions.  http://hackage.haskell.org/package/syntax-example-0.3.0.0 (pawel834)
06:41:02 * geekosaur eyes PPDP announcement, remembers why he got into Haskell in the first place. someday....
06:42:44 <fds4345> anyone got a preferred way to do typed exceptions?
06:45:17 <trap_exit> ooh
06:45:19 <trap_exit> I would like to know too
06:45:23 <trap_exit> I fucking hate the fact that errors are strings
06:45:27 <trap_exit> so I can only display them and die
06:45:37 <trap_exit> instead, typed exceptions ... which I could then pattern match on ... would be awesome
06:45:49 <fds4345> maybe the Exceptions package?
06:46:24 <fds4345> i think im going to try using Either instead
06:53:17 <hexagoxel> Gurkenglas: i don't know
07:21:26 <hcore> so i've noticed in haskell most of the time a function that takes a list is defined as f (x:xs)
07:21:42 <hcore> but if for example i wanted the full list and not to break it into a head and tail i would do f [x]
07:21:55 <dhrosa> you'd just do f x
07:22:00 <hcore> so why do we have the parentheses instead of square brackets?
07:22:05 <marchelzo_> f xs might be stylistically better
07:22:24 <marchelzo_> (x:xs) and [x] are both pattern matches
07:22:32 <wei2912> [x] means a single element list
07:22:40 <wei2912> (think of it)
07:23:08 <hcore> whoops yeah
07:23:14 <wei2912> > let f [x] = x in f [3, 2, 4, 5, 6]
07:23:16 <lambdabot>  *Exception: <interactive>:3:5-13: Non-exhaustive patterns in function f
07:23:17 <wei2912> > let f [x] = x in f [3]
07:23:19 <lambdabot>  3
07:23:20 <wei2912> ^^
07:23:20 <marchelzo_> (x:xs) :: [a] means "match something of type a cons'd with a list of a"
07:23:21 <hcore> i suppose i meant why we have (x:xs) instead of [x:xs]
07:23:38 <wei2912> because [x:xs] doesn't make much sense
07:23:41 * hackagebot rainbox 0.8.0.0 - Two-dimensional box pretty printing, with colors  http://hackage.haskell.org/package/rainbox-0.8.0.0 (OmariNorman)
07:23:46 <wei2912> it's like pattern matching a list in a list
07:23:48 <marchelzo_> that would be a [[a]] with length 1
07:24:08 <wei2912> > let f [x:xs] = x in f [[1, 2, 3]]
07:24:10 <lambdabot>  1
07:24:56 <wei2912> > let f x:xs = x in f [[1, 2, 3]]
07:24:57 <lambdabot>  <hint>:1:5: Parse error in pattern: f
07:25:05 <wei2912> hmm
07:25:08 <hcore> ok so then it is defining a tuple containing x and xs, both of which are lists?
07:25:20 <wei2912> anyways
07:25:23 <wei2912> hcore: no, it's not a tuple
07:26:02 <bananagram> it's only a tuple if there's a comma in it or if it's empty
07:26:19 <bananagram> otherwise it just denotes order of operations
07:26:42 <wei2912> ^^
07:26:46 <wei2912> that's what the parenthesis does
07:26:55 <wei2912> i think you may be confused
07:26:56 <hcore> ahh
07:26:58 <hcore> i see now
07:27:11 <hcore> lol i totally was
07:27:54 <hcore> i felt that i needed to define the type for the function's input but i dont and now i see that parentheses in most cases are just to clarify order of operations
07:28:07 <hcore> as per your failed compiling thing above wei2912
07:28:21 <wei2912> yes.
07:28:36 <hcore> thanks!
07:28:41 * hackagebot buildwrapper 0.8.11 - A library and an executable that provide an easy API for a Haskell IDE  http://hackage.haskell.org/package/buildwrapper-0.8.11 (JeanPhilippeMoresmau)
07:29:56 <favetelinguis> Trying to implement fold over monads http://lpaste.net/114858, but get an error that is new to me, what am i missing?
07:30:45 <dhrosa> you're pasing a b as the first argument to f
07:30:52 <dhrosa> but f's first argument is an a
07:31:02 <dhrosa> so the compiler is confused because that implies a must be b
07:32:44 <favetelinguis> aa obv :) how lng does it take to start finding these obv error, haskell is confusing at first
07:33:06 <dhrosa> favetelinguis: the error in line 6 means that you said a and b are different types, but a ~ b means they're the same type
07:33:41 * hackagebot scion-browser 0.4.0 - Command-line interface for browsing and searching packages documentation  http://hackage.haskell.org/package/scion-browser-0.4.0 (JeanPhilippeMoresmau)
07:34:19 <dhrosa> favetelinguis: then line 11-13 tell you why the compiler thinks the first argument of f is an a (from the type signature), and lines 15-18 tells you that it thinks it should be a b (from the argument you pass to f)
07:34:42 <dhrosa> so now the compiler can't tell if the arg is supposed to be an a or a b
07:35:50 <favetelinguis> ok thanks alot
07:38:49 <ChristianS> is there a Char equivalent for Data.Text.isInfixOf that checks whether a text contains just a specific Char?
07:39:33 <ChristianS> ah, i can use T.any
07:39:36 <geekosaur> elem?
07:39:37 <marchelzo_> maybe Data.Text.elem
07:39:49 <favetelinguis> dhrosa: so i fixed the error but it does not behave like foldr, should this not be the same as foldr for monads?
07:40:53 <ChristianS> i don't think there is a Data.Text.elem
07:42:48 <marchelzo_> ChristianS: http://hackage.haskell.org/package/text-0.4/docs/Data-Text.html#v:elem
07:43:40 <geekosaur> 0.4 is ancient though
07:43:59 <geekosaur> no elem in 0.11.3.1 whose docs I'm looking at
07:44:16 <ChristianS> yes they seem to have removed it, i wonder why?
07:44:18 <marchelzo_> That's weird. I wonder why they would remove something like that
07:44:34 <ChristianS> anyway, T.any(==mychar) should work as well
07:44:38 <geekosaur> and now that I think about it, I think I vaguely recall they deprecated it because supporting it was more expensive than its worth
07:45:09 <marchelzo_> Expensive how?
07:48:53 <geekosaur> mm, I think the idea was that T.any can fuse but elem can be used in ways that have to allow for not fusing?
07:50:50 <Peaker> benmachine, I thought it might be nice to have syntax sugar like:  do! { foo !bar !(hippie buzz) } -> do { b <- bar ; h <- hippie buzz ; foo b h }   <-- this is pretty similar to idiom brackets, so far, right?
07:51:30 <geekosaur> or, actually the same or similar but described differently, T.any does not externally expose individual "elements" of a Text whereas T.elem does
07:51:40 <geekosaur> something like that
07:52:26 <geekosaur> Peaker, I am not sure stealing ! for that is a good idea. STArray comes to mind as a place where that syntax is gonna conflict rather badly
07:54:14 <Peaker> geekosaur, sure, the syntax isn't well-designed yet :)
07:54:42 <Peaker> but it takes away one of the few pain points Haskell IO still has as opposed to imperative programming languages -- while still retaining predictable execution order
07:55:45 <Peaker> if you have something like:  foo !(bar !baz)   then you need a Monad. If you only have:   foo !bar !baz !quux   only needs Applicative (and I'm pretty sure it's equivalent to idiom bracket syntax)
07:57:17 <nshepperd> that would be 'join $ foo <$> bar <*> baz <*> quux'
07:57:34 <nshepperd> assuming foo :: things -> m a
07:58:42 * hackagebot webdriver 0.6.0.2 - a Haskell client for the Selenium WebDriver protocol  http://hackage.haskell.org/package/webdriver-0.6.0.2 (AdamCurtis)
07:58:44 * hackagebot scion-browser 0.4.1 - Command-line interface for browsing and searching packages documentation  http://hackage.haskell.org/package/scion-browser-0.4.1 (JeanPhilippeMoresmau)
08:03:24 <nshepperd> that would be convenient syntax sugar I guess, for writing imperative-style code
08:28:39 <wz1000> What is the inhabitant of 'Void -> a'?
08:28:43 * hackagebot call 0.1 - The call game engine  http://hackage.haskell.org/package/call-0.1 (FumiakiKinoshita)
08:31:45 <wz1000> Well, mathematically, it can only have one inhabitant, but aren't all functions 'const x', where x :: a of this type? Why does it mathematically have 1 inhabitant instead of a inhabitants?
08:32:33 <wz1000> Why are '1 -> a' and '0 -> a' isomorphic?
08:32:48 <wz1000> s/are/are not/g
08:33:43 * hackagebot cond 0.4.1.1 - Basic conditional and boolean operators with monadic variants.  http://hackage.haskell.org/package/cond-0.4.1.1 (AdamCurtis)
08:33:49 <nshepperd> if you represent a function as a relation (a->b = a set of pairs ⊂ a×b) then the inhabitant of Void -> a must be the empty set {}
08:34:05 <jrslepak> shouldn't 'const x' be 'Unit -> a' not 'Void -> a'?
08:34:05 <nshepperd> since Void × a is empty for all a
08:37:40 <nshepperd> of course, if you can construct values of some concrete type A, then you can write const x, const y, const z :: Void -> A
08:37:59 <nshepperd> but they are all 'really the same function'
08:38:06 <wz1000> Mathematically, it should have one inhabitant(because a^0 = 1), and logically it should have a or 0 inhabitants. Why does this discrepancy exist.
08:38:22 <nshepperd> because you can never observe the difference by applying the function
08:39:51 <nshepperd> note that Void -> Void is also inhabited
08:39:54 <Yaah> hey
08:40:12 <Yaah> how is everyone
08:40:30 <nshepperd> by id, obviously
08:40:35 <wz1000> nshepperd: The inhabitants of () -> a are const x, const y, const x...
08:40:55 <k00mi> wz1000: no
08:41:13 <exio4> x has to be ∷ a
08:41:13 <nshepperd> I thought you were talking about Void
08:41:14 <k00mi> wz1000: 'const x' has the type of 'x', which is a concrete type
08:41:22 <k00mi> it's not polymorphic
08:41:39 <opqdonut> const x surely has the type of something -> type of x
08:41:41 <wz1000> I meant const x where x :: a
08:41:43 <opqdonut> :t const True
08:41:44 <lambdabot> b -> Bool
08:42:06 <opqdonut> and the only reason you can say "const True :: Void -> Bool" in haskell is that Void is actually inhabited (by _|_)
08:42:11 <dfeuer> BOOM
08:42:13 <dfeuer> Haaaaaaa
08:42:16 <Yaah> hmm...
08:42:25 <dfeuer> I think I found the laziness problem. How stupid is that?
08:43:13 <nshepperd> opqdonut: no, i'm pretty sure you could write that, even without bottom
08:43:24 <dfeuer> This was Someone Else's mistake.
08:43:39 <nshepperd> i mean, the general type of const True is forall a. a -> Bool
08:43:48 <Yaah> hmm...
08:43:59 <opqdonut> nshepperd: yeah you're actually right, I was confused
08:45:24 <opqdonut> it's kind of cool actually how Void collapses const True and const False to the same function...
08:45:48 <dfeuer> Whyyyyyyyyyyyyyyy
08:45:57 <opqdonut> I'd never thought of that
08:46:08 <wz1000> opqdonut: How?
08:46:51 <opqdonut> wz1000: well there's two arguments, one is that there is only one (mathematical function) Void->Bool, namely the empty function
08:46:59 <k00mi> wz1000: for 'const x' to have type 'b -> a' you would need a value of type 'forall a. a', which you don't have (assuming totality)
08:47:11 <opqdonut> the other argument is that const True and const False are the same extensionally – you can't observe their difference
08:47:31 <wz1000> opqdonut: Oh, I get it. Nice
08:47:33 <nshepperd> k00mi: I think a is supposed to be free here, not universally quantified
08:47:39 <opqdonut> yes
08:47:57 <k00mi> wz1000: the implementation of the function 'Void -> a' depends on how Void is represented
08:48:11 <k00mi> nshepperd: I don't think so
08:49:12 <wei2912> @src const
08:49:12 <lambdabot> const x _ = x
08:51:16 <haskellquestion> hi is there a built-in list type that has O(1) access to elements? like an array in c
08:51:27 <wei2912> there is, i think
08:51:38 <wei2912> Data.Array
08:51:47 <haskellquestion> ok thanks i'll check it out
08:52:18 <nshepperd> in the curry-howard isomorphism, Void -> A is the assertion "False implies A"
08:52:33 <nshepperd> which might have multiple proofs
08:53:02 <nshepperd> but there is also the trivial one from contradiction
08:55:29 <nshepperd> but the function (forall a. Void -> a) means "False implies anything" which is basically the quodlibet axiom
08:56:15 <nshepperd> so it presumably has only one proof, consisting of quoting the axiom
08:56:44 <nshepperd> to  be really handwavey...
08:58:44 * hackagebot yesod-core 1.4.4.4 - Creation of type-safe, RESTful web applications.  http://hackage.haskell.org/package/yesod-core-1.4.4.4 (MichaelSnoyman)
09:01:41 <kcc> Is it possible to put lens inside a container such as Map?
09:02:28 <kcc> Problems arise because GHC cannot deduce the functor instance for (a -> f b) -> s -> f t
09:05:13 <pharpend> kcc: ask edwardk when he wakes up
09:05:37 <pharpend> kcc: the secret is, nobody actually understands how lenses work, we all just pretend we do so edwardk doesn't yell at us
09:06:57 <simpson> kcc: Yes, you can do it, but the types are a little tricky.
09:07:33 <simpson> kcc: https://hackage.haskell.org/package/lens-4.6/docs/Control-Lens-Lens.html#t:ALens
09:07:34 <kcc> So I think I need to write out the full type, and then move the Functor to the front?
09:08:00 <simpson> kcc: ^^^ you just need to use ALens.
09:08:40 <kcc> simpson: Ah thanks! I never knew there is ALens. The lens library is large
09:08:45 * hackagebot hasql 0.2.1 - A minimalistic general high level API for relational databases  http://hackage.haskell.org/package/hasql-0.2.1 (NikitaVolkov)
09:10:23 <simpson> kcc: ALens and friends are almost never needed; the only uses are to provide rank-1 lenses and to store lenses in containers.
09:10:35 <torpet> I am having a list of functions and single input value.
09:10:44 <torpet> How can I find the function which outputs the max value?
09:10:54 <torpet> max(f1 input, f2 input, f3 input)
09:13:23 <jmcarthur> :t maximumBy . flip id
09:13:24 <lambdabot>     Occurs check: cannot construct the infinite type:
09:13:24 <lambdabot>       a1 ~ a -> a1 -> Ordering
09:13:24 <lambdabot>     Expected type: a1 -> a -> a1 -> Ordering
09:13:29 <jmcarthur> oh woops
09:13:59 <kcc> > maximum $ sequence [(+1),(+2)] 42
09:14:00 <lambdabot>  44
09:14:01 <jmcarthur> :t maximumBy . comparing . flip id
09:14:02 <lambdabot> Ord a1 => a -> [a -> a1] -> a -> a1
09:14:10 <jmcarthur> hmm
09:14:12 <jmcarthur> being too clever
09:14:30 <jmcarthur> ah, no, that's it
09:14:44 <jmcarthur> i forgot the goal was to return the function, by the time i fixed it :)
09:15:57 <jmcarthur> note, however, that my solution will apply most functions to the same input twice
09:16:11 <jmcarthur> that could be fixed:
09:17:09 <jmcarthur> :t map fst . maximumBy (comparing snd) . map . (id &&&) . flip id
09:17:10 <lambdabot>     Couldn't match type ‘(a1, a0)’ with ‘[(b, b0)]’
09:17:10 <lambdabot>     Expected type: [(b, b0)] -> a0
09:17:10 <lambdabot>       Actual type: (a1, a0) -> a0
09:17:37 <jmcarthur> :t \input -> map fst . maximumBy (comparing snd) . map (id &&& ($ input))
09:17:38 <lambdabot>     Couldn't match type ‘(a1, a0)’ with ‘[(b, b0)]’
09:17:38 <lambdabot>     Expected type: [(b, b0)] -> a0
09:17:38 <lambdabot>       Actual type: (a1, a0) -> a0
09:17:51 <jmcarthur> :t fst . maximumBy (comparing snd) . map . (id &&&) . flip id
09:17:52 <lambdabot>     Couldn't match type ‘[a -> c'0] -> [(a -> c'0, c'0)]’
09:17:52 <lambdabot>                   with ‘[(c, a0)]’
09:17:52 <lambdabot>     Expected type: ((a -> c'0) -> (a -> c'0, c'0)) -> [(c, a0)]
09:18:02 <jmcarthur> three strikes and i'm out
09:18:29 * jmcarthur deserves it for being overly point free
09:19:54 <kcc> sequence is nice, ((->) r) is nice
09:19:57 <bitraten> hi, I have some problem with catching exceptions and laziness (i think) https://gist.github.com/bitraten/e0ef766955b59bf462e3
09:21:03 <jmcarthur> kcc: the question was to find the function, not the result
09:22:15 <kcc> :t (maximum .) . sequence
09:22:16 <lambdabot> Ord c => [a -> c] -> a -> c
09:23:21 <indiagreen> jmcarthur: you were close
09:23:33 <indiagreen> :t fmap (fst . maximumBy (comparing snd)) . map . (id &&&) . flip id
09:23:34 <lambdabot> Ord a1 => a -> [a -> a1] -> a -> a1
09:25:33 <simpson> :t \a fs -> maximum $ map ($ a) fs
09:25:34 <lambdabot> Ord a => a1 -> [a1 -> a] -> a
09:25:42 <simpson> Sometimes simpler is smaller.
09:26:00 <simpson> Ah, the function is desired.
09:26:02 <jmcarthur> indiagreen: yeah... i just don't like flooding the channel while i try to get it right, so i tend to give up after three tries
09:26:30 <simpson> (&&&) is probably a good part of the answer.
09:27:17 <hiptobecubic> Is there a nicer way to do this? It seems like such an obvious use case for Aeson. http://vpaste.net/WooH6
09:27:50 <hiptobecubic> extracting value from "{foo: {bar: value}}"
09:28:29 <kcc> try lens
09:28:42 <hiptobecubic> I expected something like  `o .: "foo" .: "bar"` or similar. I realize that it could fail at any point along the chain of (.:) but surely someone has thought about this?
09:30:02 <hiptobecubic> kcc, I'm not anti-lens and yes it can solve a huge array of "dig through this structure" problems, but is that how Aeson was envisioned? "Wait for lens to be written and then use it"
09:32:04 <kcc> hiptobecubic: There are bindings, not sure if this is what you want  https://hackage.haskell.org/package/lens-aeson-1.0.0.3/docs/Data-Aeson-Lens.html
09:32:24 <torpet> thanks guys, i wrote a reverse map function :D
09:33:08 <gregnwosu> question: can you use data type declaration instead of class declarations, whats the difference?
09:33:16 <kcc> > "{\"foo\": {\"bar\": 42}}" ^? key "foo" . key "bar"
09:33:17 <lambdabot>  Not in scope: ‘key’
09:33:17 <lambdabot>  Perhaps you meant one of these:
09:33:17 <lambdabot>    ‘IM.keys’ (imported from Data.IntMap),
09:33:17 <lambdabot>    ‘M.keys’ (imported from Data.Map)Not in scope: ‘key’
09:33:17 <lambdabot>  Perhaps you meant one of these:
09:33:36 <kcc> import Data.Aeson.Lens
09:33:53 <kcc> > "{\"foo\": {\"bar\": 42}}" ^? key "foo" . key "bar"
09:33:54 <lambdabot>  Not in scope: ‘key’
09:33:54 <lambdabot>  Perhaps you meant one of these:
09:33:54 <lambdabot>    ‘IM.keys’ (imported from Data.IntMap),
09:33:54 <lambdabot>    ‘M.keys’ (imported from Data.Map)Not in scope: ‘key’
09:33:54 <lambdabot>  Perhaps you meant one of these:
09:34:00 <torpet> Hm how can i "extract" the function again after I've found the maximum?
09:34:30 <torpet> because thats what i want to return
09:34:52 <jmcarthur> gregnwosu: you must see some similarity between the two. could you provide an example? e.g. "here is a data type and here is what i perceive to be a type class that represents the same idea. is there actually a difference?"
09:35:27 <gregnwosu> jmcarthur: ok
09:37:45 <wz1000> @where lyah
09:37:45 <lambdabot> http://www.learnyouahaskell.com/
09:37:52 <gregnwosu> data Num = Num {(+)::Num->Num->Num, (-):: ....etc}
09:38:14 <gregnwosu> its kinda the same no
09:38:21 <gregnwosu> or am i missing some sublety
09:38:48 <jmcarthur> gregnwosu: ah! the dictionary encoding of type classes.
09:38:58 <jmcarthur> gregnwosu: so that's similar to what ghc actually does under the hood, in fact
09:39:44 <jmcarthur> gregnwosu: the biggest difference is that an instance can be inferred by the compiler after type inference, but the same cannot be done for a record
09:39:57 <gregnwosu> jmcarthur: aha
09:40:04 <jmcarthur> gregnwosu: there can, in fact, be multiple records for the same type, but only one instance
09:40:14 <jmcarthur> (for a given type class, that is)
09:40:41 <gregnwosu> only one typeclass instance?
09:40:48 <jmcarthur> gregnwosu: also, some of the fancier extensions of ghc only work for type classes, such as associated types, etc.
09:41:01 <jmcarthur> gregnwosu: each type can have a maximum of one Num instance, for example
09:41:13 <jmcarthur> gregnwosu: but with the record encoding, there could be many such values
09:41:49 <gregnwosu> jmcarthur: yes, indeed
09:42:32 <jmcarthur> gregnwosu: to have multiple Num instances for the same type, you must go through the boilerplate of distinguishing via newtypes. if you have multiple values of the record encoding, you distinguish "for free" via the always-mandatory boilerplate of explicitly giving the value to use (passing as an argument)
09:43:49 <jmcarthur> gregnwosu: another difference is that the record encoding might require type extensions for some things that type classes support without type extensions. for example, try encoding Functor as a record. you will end up using Rank2Types/RankNTypes
09:44:37 <gregnwosu> jmcarthur: sounds like i dont want to go there, and im surprised for a type class as "simple" as functor
09:44:38 <jmcarthur> i'll just give that example to you:     data Functor f = Functor { fmap :: forall a b. (a -> b) -> f a -> f b }
09:44:52 <jmcarthur> gregnwosu: the forall bit requires the extension
09:45:15 <gregnwosu> the forall bit means that all the types dont have to match the same way in a signature no?
09:46:02 <jmcarthur> it means that the function stored in the record is polymorphic in those type arguments. they are universally quantified. note that they are *bound* there, instead of on the left hand side of the declaration
09:47:16 <gregnwosu> jmcarthur: yeah , what you just said  ;-) , i actually think i get it , but dont know the jargon so well
09:50:06 <gregnwosu> thanks all
09:52:43 <daishi> so i dont understand why i can't do this: http://lpaste.net/114862
09:52:52 <daishi> do i need to just use zipwith?
09:53:04 <daishi> but i thought i could append an array to another array without using anything else
09:53:10 <daishi> ++ doesn't do it for me either
09:53:48 <mauke> the error message means: sum takes a list
09:53:52 <mauke> last2 is not a list
09:53:57 <mauke> thus 'sum last2' is an error
09:55:06 <geekosaur> daishi, you might think about what "sum last2 fibs" means
09:55:15 <geekosaur> vs. what you actually want to say there
09:56:49 <daishi> ok so in my mind last2 produces a list of the last 2 elements in an array that it was given
09:57:06 <mauke> only when applied to an argument
09:57:09 <jacereda> hi
09:57:15 <mauke> by itself it's simply a function
09:57:22 <mauke> and you're calling 'sum list2'
09:57:23 <mauke> er
09:57:25 <mauke> last2
09:57:35 <daishi> but isn't last2 fibs giving it
09:57:36 <daishi> ohh
09:57:41 <triliyn> daishi: function application in haskell is left associative, which means "sum last2 fibs" parses as "(sum last2) fibs"
09:59:04 <daishi> ok so now
09:59:12 <jacereda> I'm seeing some disagreement between haskell's isSpace and golang's IsSpace...  for instance, char \x85 is a space according to Go and isn't according to Haskell
09:59:22 <jacereda> anyone knows which one is 'right'?
09:59:38 <daishi> in ghci i can do sum (last2 [0,1,2]) and get 3
09:59:52 <daishi> but when i use parentheses to clarify the expression in my source file it doesnt work
09:59:56 <Clint> jacereda: \x85 in which character encoding?
10:00:00 <mauke> Clint: none
10:00:02 <daishi> fibs = 0:1:sum (last2 fibs)
10:00:06 <jacereda> clint: utf16
10:00:17 <daishi> shouldn't that evaluate to sum [0,1] ?
10:00:20 <mauke> jacereda: wtf
10:00:26 <Clint> there is no \x85 in utf16
10:00:27 <Hijiri> fibs is supposed to be infinite, right?
10:00:31 <Hijiri> how could you get to the last 2
10:00:33 <daishi> correct
10:00:35 <daishi> ohh
10:00:47 <Jello_Raptor> Huh, everything in LYAHFGG from Functors through Monads seems to short circuit my head. Is there any other resource people reccomend to help understand them? I want to work up to actually understandng Monadic composition, and Control.Lens .
10:00:50 <daishi> ohhhhhhhhhh
10:00:58 <Hijiri> you have to pretend that fibs is already the infinite list you're trying to define
10:01:15 <hpc> Jello_Raptor: there's the wikibook and RWH
10:01:21 <haskellquestion> how would i call a function like this in a do-block? i'm getting an error: | cmd == ',' = do { c <- getChar; S.update tapePos (ord c) ts; execCode tapePos ts nextPos cs }
10:01:27 <haskellquestion> S.update is the sequence update method
10:01:29 <mauke> Jello_Raptor: focus on Functor at first
10:01:33 <Jello_Raptor> hpc, RWH? real world haskell?
10:01:34 <mauke> that's the easiest one
10:01:46 <hpc> and yeah, the order of comprehension is very linear
10:01:48 <jacereda> Clint: there is according to http://www.fileformat.info/info/charset/UTF-16/list.htm
10:01:53 <hpc> learn Functor, then Applicative, then Monad
10:01:56 <kranius> hello #haskell
10:01:56 <hpc> or you'll go nuts
10:01:57 <Hijiri> Jello_Raptor: https://github.com/bitemyapp/learnhaskell
10:02:08 <Jello_Raptor> mauke: I get the impressions functor => applicative => applicative functot => monad => lens
10:02:14 <Jello_Raptor> is the correct order
10:02:22 <hpc> applicative is the same as applicative functor
10:02:28 <mauke> Jello_Raptor: "Applicative" is the name of the type class for applicative functors
10:02:28 <Hijiri> lens is sort of not part of that order
10:02:40 <mauke> because ApplicativeFunctor is too damn long
10:02:42 <Hijiri> but you will want a good understanding of common typeclasses if you want to understand lens
10:02:47 <Hijiri> (and some uncommon ones too)
10:03:07 <mauke> lens makes interesting use of functors and applicatives
10:03:59 <hpc> lens also uses other stuff you should know too
10:04:17 <Clint> jacereda: ah, http://www.unicode.org/charts/PDF/U0080.pdf
10:04:24 <hpc> it's a relatively involved package to get into
10:04:29 <torpet> given multipe functions and a single input value, how can i find the function that produces the maximum value?
10:05:01 <mauke> maximumBy (comparing ($ x))?
10:05:31 <jacereda> so, anyone knows why NEXT LINE (NEL, U+0085) isn't considered a space in Haskell?
10:06:07 <simpson> :t \x -> maximumBy (comparing ($ x)) -- I think mauke wins!
10:06:08 <lambdabot> Ord a => a1 -> [a1 -> a] -> a1 -> a
10:06:28 <hpc> jacereda: it's defined that way by unicode
10:06:38 <mauke> jacereda: might be a change in some version of unicode
10:06:38 <jmcarthur> i gave that solution long ago. it apparently was passed up
10:06:39 <torpet> mauke: Hm I don't really understand your code
10:06:53 <torpet> maximumBy is maximum just with a custom function right?
10:06:59 <jmcarthur> :t maximumBy . comparing . flip id
10:07:00 <lambdabot> Ord a1 => a -> [a -> a1] -> a -> a1
10:07:09 <mauke> I see perl made \x85 whitespace in 2002
10:07:15 <torpet> But where does the input parameter come into play?
10:07:23 <jacereda> mauke: so Go is probably right?
10:07:30 <HeladoDeBrownie> torpet, the output of (.) is a function
10:07:32 <jmcarthur> torpet: the input parameter is the x in mauke's version
10:07:34 <hpc> i wouldn't take standards hints from perl
10:07:44 <HeladoDeBrownie> @type (.)
10:07:45 <lambdabot> (b -> c) -> (a -> b) -> a -> c
10:07:48 <mauke> hpc: I would
10:07:53 <mauke> hpc: perl has excellent unicode support
10:08:04 <jacereda> hpc: well, if perl and go agree chances are it's right
10:08:08 <Clint> and yet it's not a space character in unicode
10:09:09 <jmcarthur> jacereda: it may be a space in some de facto standard, but the *actual* standard says it's not a space
10:09:32 <jmcarthur> jacereda: so it boils down to some bikeshedding about what kind of standard we should be following
10:09:46 <mauke> interesting
10:09:48 <torpet> mauke: And comparing is the list of functions?
10:10:08 <hpc> my guess is that perl and go's changes come from "some idiot put \x85 in a piece of text" happening to someone who posts bugs
10:10:12 <simpson> :t comparing -- torpet
10:10:13 <lambdabot> Ord a => (b -> a) -> b -> b -> Ordering
10:11:00 <jacereda> http://en.wikipedia.org/wiki/Whitespace_character seems to imply it's a whitespace character
10:11:03 <jmcarthur> i personally would rather follow the unicode standard, since it's at least well documented, even if it's "worse" than the de facto standard
10:11:38 <jmcarthur> jacereda: that table classifies it as other/control, not seperator/space
10:12:20 <jacereda> jmcarthur: the table title says 'Whitespace[a](Unicode character property WSpace=Y)'
10:12:38 <mauke>  0085          ; White_Space # Cc       <control-0085>
10:13:11 <statusfailed> is there a standard library function for k-permutations of a list?
10:13:44 <jmcarthur> jacereda: ah, so it's a matter of category vs. property
10:14:16 <jacereda> yes, the problem here seems to be defining what isSpace means
10:14:31 <jmcarthur> (it seems silly to have both properties and categories, in my opinion, but this is beside the point)
10:15:47 <jacereda> jmcarthur: unicode is overcomplicated, but you know, simplicity takes effort
10:15:53 <jmcarthur> jacereda: well, it looks like the isSpace documentation says "space", not "whitespace", so although it may be worth further clarifying, it does seem to lean toward the "category", especially since it explicitly lists some control characters it also matches
10:16:00 <Clint> http://hackage.haskell.org/package/base-4.7.0.1/docs/src/GHC-Unicode.html#isSpace
10:16:44 <jmcarthur> iswspace... meh
10:16:45 <jacereda> jmcarthur: those control characters are already matched by iswspace
10:16:54 <jacereda> jmcarthur: it's just an optimization
10:17:22 <mauke> "category" is a property
10:17:28 <mauke> interesting
10:18:11 <jmcarthur> jacereda: i'm really talking about the documentation itself. it distinguishes the "control" characters supported from the "space" characters. since those control characters are technically "whitespace" characters, that leads me to believe it's talking about the category "space" and not the property "whitespace"
10:19:47 <jacereda> in qt: QChar::isSpace() -> Returns true if the character is a separator character (Separator_* categories or certain code points from Other_Control category); otherwise returns false.
10:19:51 <jacereda> damn
10:20:08 <jacereda> it's more complex than that it seems
10:20:37 <hughfdjackson> :| this seems like a very basic Q
10:20:50 <hughfdjackson> is there a common, safe version of (!!)?
10:20:54 <jacereda> in java: isSpace is deprecated and suggest isWhitespace as a replacement
10:21:07 <hughfdjackson> my hoogle for [a] -> Int -> Maybe a isnt' coming up with the much :/
10:21:20 <mauke> hughfdjackson: listToMaybe . drop n
10:21:33 <mauke> pfft, java can't even handle unicode
10:21:41 <hughfdjackson> mauke: cheers :D
10:21:41 <mauke> same problem as C: its char type is too small
10:21:47 <jmcarthur> but i don't really know how iswspace works, and the w probably stands for "white", so it's really confusing
10:22:02 <arianvp__> 'chars' shouldnt be used for  character points in C though
10:22:05 <jacereda> jmcarthur: the 'w' stands for wide
10:22:05 <mauke> jmcarthur: in what language?
10:22:06 <Clint> wide, not white
10:22:16 <arianvp__> just like you don't use  ByteString.Char8 in haskell
10:22:37 <mauke> arianvp__: right, same as in java
10:22:47 <arianvp__> Java is just horrible. UTF16? wut
10:23:34 <jmcarthur> mauke: isSpace uses iswspace under the hood. it's a foreign function, so i assume it's some common C one
10:23:45 <mauke> ok, yeah. wide character then
10:23:47 * hackagebot synt 0.1.0 - Similar code analysis.  http://hackage.haskell.org/package/synt-0.1.0 (brentlintner)
10:24:15 <mauke> (wchar_t, which is a library type in C but built into the language in C++! yay)
10:32:59 <ChristianS> is it possible to check in a pattern guard if a lookup function returns Just something (rathern than Nothing)?
10:33:09 <wei2912> pattern match?
10:33:48 * hackagebot webdriver 0.6.0.3 - a Haskell client for the Selenium WebDriver protocol  http://hackage.haskell.org/package/webdriver-0.6.0.3 (AdamCurtis)
10:34:24 <ChristianS> wei2912: that's the <- syntax? i'll have to try it...
10:34:36 <wei2912> ChristianS: no
10:34:49 <mauke> ChristianS: the <- syntax is pattern guards
10:35:12 <wei2912> ChristianS: what're you trying to do?
10:36:08 <isocliff> > "\\"
10:36:09 <lambdabot>  "\\"
10:36:10 <ChristianS> wei2912: | Just value <- Map.lookup key mymap  -- not sure if that is the right syntax?
10:36:18 <isocliff> can someone tell me how to get a single backslash?
10:36:39 <mauke> isocliff: what do you mean by "get"?
10:36:48 <HeladoDeBrownie> isocliff, you wrote it above
10:36:51 <wei2912> ChristianS: i think that works, but i was referring to pattern matching with a case statement
10:37:03 <isocliff> I want a string with a single backslash
10:37:08 <HeladoDeBrownie> isocliff, what lambdabot prints is a Haskell-code-like representation. putStrLn and such will print a single backslash
10:37:10 <wei2912> ChristianS: https://www.haskell.org/haskellwiki/Pattern_guard - should work
10:37:15 <HeladoDeBrownie> isocliff, so what you wrote is correct
10:37:22 <isocliff> oh okay, gotcha, thanks
10:37:26 <wei2912> > putStrLn "\\"
10:37:28 <lambdabot>  <IO ()>
10:37:31 <wei2912> whoops
10:37:34 <mauke> > length "\\"
10:37:36 <lambdabot>  1
10:37:48 <wei2912> well, write a program that runs that
10:37:49 <ChristianS> wei2912: ah, ok, i thin i prefer the pattern guard over case since i find it more elegant
10:37:51 <isocliff> aha, yes
10:37:54 <mauke> > text "\\"
10:37:56 <lambdabot>  \
10:38:05 <isocliff> nice
10:38:13 <wei2912> ChristianS: yeh, i find it more elegant too. i wasn't aware of pattern guards
10:38:31 <wei2912> @src putStrLn
10:38:31 <lambdabot> putStrLn s = do putStr s; putChar '\n'
10:38:39 <wei2912> @src putStr
10:38:39 <lambdabot> putStr s = hPutStr stdout s
10:38:47 <wei2912> @src hPutStr
10:38:47 <lambdabot> Source not found.
10:38:52 <wei2912> :P
10:42:54 <sinelaw> Quasimodo!
10:43:30 <mauke> easymodo
10:46:40 <sinelaw> anyone here familiar with imperative type variables as used by SML 90?
10:49:38 <dfeuer> sinelaw, imperative type variables? I'm passingly familiar with SML, but I've  never heard of those.
10:50:28 <sinelaw> dfeuer, in versions of SML from before 97
10:50:38 <dfeuer> Oh.
10:50:43 <sinelaw> SML 90 basically, and it was further complicated in SML/NJ
10:51:04 <dfeuer> Did SML/NJ do away with them in '97, or no?
10:51:23 <sinelaw> not sure.
10:51:56 <sinelaw> don't think so, not sure SML/NJ was modified after SML 97 came out
10:52:00 <sinelaw> I don't know
10:52:39 <sinelaw> this page isn't clear about it: http://www.smlnj.org/doc/Conversion/types.html
11:11:05 <daishi> hey are there any good haskell video series out there? i've been watching the one from erik meijer but was wondering if there are others
11:15:10 <SvenskFi1k> Is there any way to use something like ioResult <- someIOFunction after 'where'? Or would I have to use 'do'?
11:15:15 <haskellquestion> how would i call a function like this in a do-block? i'm getting an error: | cmd == ',' = do { c <- getChar; S.update tapePos (ord c) ts; execCode tapePos ts nextPos cs }
11:15:29 <haskellquestion> that's a snippet of a guard. s.update is just a data.sequence function
11:15:53 <HeladoDeBrownie> SvenskFi1k, that's part of do syntax, yes.
11:16:06 <mauke> haskellquestion: S.update returns a new Seq
11:16:13 <mauke> it doesn't modify ts
11:16:18 <HeladoDeBrownie> SvenskFi1k, if you wanted to define something in a where clause that relied on a previous binding in a do expression, try using let inside the do instead.
11:16:24 <haskellquestion> ohhhh right
11:16:25 <haskellquestion> got it
11:16:26 <haskellquestion> thanks
11:16:30 <edwardk> @tell kcc you can also use "ReifiedLens" which has the benefit of retaining performance after going through the Map, unlike ALens, which has to go through 'cloneLens' to become a real lens again
11:16:30 <lambdabot> Consider it noted.
11:16:55 <HeladoDeBrownie> SvenskFi1k, woops, I might have got what you wanted backwards
11:17:21 <HeladoDeBrownie> SvenskFi1k, why do you want to use that syntax outside of a do block?
11:18:49 * hackagebot amazonka-cloudsearch 0.0.1 - Amazon CloudSearch SDK.  http://hackage.haskell.org/package/amazonka-cloudsearch-0.0.1 (BrendanHay)
11:18:51 * hackagebot amazonka-cloudsearch-domains 0.0.1 - Amazon CloudSearch Domain SDK.  http://hackage.haskell.org/package/amazonka-cloudsearch-domains-0.0.1 (BrendanHay)
11:18:53 * hackagebot amazonka-cloudtrail 0.0.1 - Amazon CloudTrail SDK.  http://hackage.haskell.org/package/amazonka-cloudtrail-0.0.1 (BrendanHay)
11:18:55 * hackagebot amazonka-cloudwatch 0.0.1 - Amazon CloudWatch SDK.  http://hackage.haskell.org/package/amazonka-cloudwatch-0.0.1 (BrendanHay)
11:18:57 * hackagebot amazonka-cloudwatch-logs 0.0.1 - Amazon CloudWatch Logs SDK.  http://hackage.haskell.org/package/amazonka-cloudwatch-logs-0.0.1 (BrendanHay)
11:19:24 <sinelaw> ooh
11:21:08 <lcf80> hello. I have a question about quikcheck
11:21:20 <sinelaw> ask.
11:21:26 <sinelaw> and hello to you too
11:21:41 <lcf80> having example broken function like that
11:21:43 <lcf80> let badElem x xs = if length xs == 6 then False else elem x xs
11:22:15 <lcf80> and test defined as
11:22:16 <lcf80> let test = \x xs -> badElem x xs == elem x xs
11:22:30 <lcf80> when I run quickcheck
11:22:32 <lcf80> quickCheck (test :: Eq a => a -> [a] -> Bool)
11:22:50 <lcf80> I don't get any specific values, that made test fail, only something like that
11:22:59 <lcf80> [(),(),(),(),(),()]
11:23:08 <merijn> That is the value that made it fail
11:23:22 <sinelaw> lcf80, that's a very good value to make it fail.
11:23:29 <sinelaw> it contains the minimum information
11:23:33 <merijn> :t ()
11:23:34 <lambdabot> ()
11:23:37 <mauke> > elem () [(),(),(),(),(),()]
11:23:39 <lambdabot>  True
11:23:46 <lcf80> ahh, okay :D
11:23:51 <lcf80> now I see this :)
11:23:59 <mauke> > let let badElem x xs = if length xs == 6 then False else elem x xs in badElem () [(),(),(),(),(),()]
11:23:59 * hackagebot amazonka-codedeploy 0.0.1 - Amazon CodeDeploy SDK.  http://hackage.haskell.org/package/amazonka-codedeploy-0.0.1 (BrendanHay)
11:24:01 <lambdabot>  <hint>:1:101:
11:24:01 <lambdabot>      parse error (possibly incorrect indentation or mismatched brackets)
11:24:01 <lcf80> sigh @ myself :)
11:24:01 * hackagebot amazonka-cognito-identity 0.0.1 - Amazon Cognito Identity SDK.  http://hackage.haskell.org/package/amazonka-cognito-identity-0.0.1 (BrendanHay)
11:24:03 * hackagebot amazonka-cognito-sync 0.0.1 - Amazon Cognito Sync SDK.  http://hackage.haskell.org/package/amazonka-cognito-sync-0.0.1 (BrendanHay)
11:24:05 * hackagebot amazonka-config 0.0.1 - Amazon Config SDK.  http://hackage.haskell.org/package/amazonka-config-0.0.1 (BrendanHay)
11:24:07 * hackagebot amazonka-datapipeline 0.0.1 - Amazon Data Pipeline SDK.  http://hackage.haskell.org/package/amazonka-datapipeline-0.0.1 (BrendanHay)
11:24:12 <mauke> > let badElem x xs = if length xs == 6 then False else elem x xs in badElem () [(),(),(),(),(),()]
11:24:14 <lambdabot>  False
11:24:29 <mauke> but in general you want to test your functions at other types than ()
11:24:29 <lcf80> yeah, yeah, I just didn't get that "()"
11:24:33 <lcf80> was looking somewhat magical
11:24:36 <mauke> like Int
11:25:08 <lcf80> mauke - I didn't need to narrow the type of it, so
11:25:25 <lcf80> it just stayed at the same level as original elem :)
11:25:55 <lcf80> it just didn't match the result I saw on some other pages, where some Ints were usually displayed in results of failed test
11:26:05 <lcf80> but now it's clear, so it's OK :)
11:29:09 * hackagebot amazonka-directconnect 0.0.1 - Amazon Direct Connect SDK.  http://hackage.haskell.org/package/amazonka-directconnect-0.0.1 (BrendanHay)
11:29:11 * hackagebot amazonka-dynamodb 0.0.1 - Amazon DynamoDB SDK.  http://hackage.haskell.org/package/amazonka-dynamodb-0.0.1 (BrendanHay)
11:29:13 * hackagebot amazonka-ec2 0.0.1 - Amazon Elastic Compute Cloud SDK.  http://hackage.haskell.org/package/amazonka-ec2-0.0.1 (BrendanHay)
11:29:15 * hackagebot amazonka-elasticache 0.0.1 - Amazon ElastiCache SDK.  http://hackage.haskell.org/package/amazonka-elasticache-0.0.1 (BrendanHay)
11:29:17 * hackagebot amazonka-elasticbeanstalk 0.0.1 - Amazon Elastic Beanstalk SDK.  http://hackage.haskell.org/package/amazonka-elasticbeanstalk-0.0.1 (BrendanHay)
11:34:19 * hackagebot amazonka-elastictranscoder 0.0.1 - Amazon Elastic Transcoder SDK.  http://hackage.haskell.org/package/amazonka-elastictranscoder-0.0.1 (BrendanHay)
11:34:21 * hackagebot amazonka-elb 0.0.1 - Amazon Elastic Load Balancing SDK.  http://hackage.haskell.org/package/amazonka-elb-0.0.1 (BrendanHay)
11:34:23 * hackagebot amazonka-emr 0.0.1 - Amazon Elastic MapReduce SDK.  http://hackage.haskell.org/package/amazonka-emr-0.0.1 (BrendanHay)
11:34:26 * hackagebot amazonka-iam 0.0.1 - Amazon Identity and Access Management SDK.  http://hackage.haskell.org/package/amazonka-iam-0.0.1 (BrendanHay)
11:34:27 * hackagebot amazonka-importexport 0.0.1 - Amazon Import/Export SDK.  http://hackage.haskell.org/package/amazonka-importexport-0.0.1 (BrendanHay)
11:34:45 <chrisdone> dude likes amazon
11:34:53 <hiptobecubic> apparently
11:35:28 <hiptobecubic> Oh hey, i was just reading your page about not whining about lack of tools for web development in haskell
11:37:14 <newcomer> Hello everyone. I'm trying to learn Haskell through a MOOC on edx. Anyway, here's a little code that doesn't compile. Here's the code and the error --> http://pastebin.com/n816qt8B . Any help?
11:37:59 <mauke> newcomer: broken indentation
11:38:00 <sinelaw> tabs
11:38:16 <newcomer> I see.
11:38:29 <mauke> also, I recommend starting a new line after "do"
11:38:33 <newcomer> so what's recommended for tabs? 4 spaces?
11:38:40 <mauke> 1) don't use tabs
11:38:56 <mauke> 2) haskell syntax is based on making things line up with other things, not indentation levels
11:38:59 <mauke> 3) yes
11:39:30 * hackagebot amazonka-kinesis 0.0.1 - Amazon Kinesis SDK.  http://hackage.haskell.org/package/amazonka-kinesis-0.0.1 (BrendanHay)
11:39:32 * hackagebot amazonka-kms 0.0.1 - Amazon Key Management Service SDK.  http://hackage.haskell.org/package/amazonka-kms-0.0.1 (BrendanHay)
11:39:34 * hackagebot amazonka-lambda 0.0.1 - Amazon Lambda SDK.  http://hackage.haskell.org/package/amazonka-lambda-0.0.1 (BrendanHay)
11:39:35 <mauke> :-)
11:39:36 * hackagebot amazonka-opsworks 0.0.1 - Amazon OpsWorks SDK.  http://hackage.haskell.org/package/amazonka-opsworks-0.0.1 (BrendanHay)
11:39:37 <hiptobecubic> Alright here we go!
11:39:38 * hackagebot amazonka-rds 0.0.1 - Amazon Relational Database Service SDK.  http://hackage.haskell.org/package/amazonka-rds-0.0.1 (BrendanHay)
11:39:45 <hiptobecubic> Aww :(
11:39:48 <bernalex> lots of haskellers use 2 spaces for indent levels. I prefer this myself.
11:40:11 <newcomer> mauke, OK, great. Thanks for help.
11:40:11 <bernalex> newcomer: FFR please use https://lpaste.net instead. it's quite a bit better than pastebin.
11:40:41 <newcomer> bernalex, Will do, thanks.
11:40:46 <mauke> pastebin.com is the php of pastebins
11:41:09 <L8D> ^
11:41:40 <Gurkenglas> How gets decided what gets into the haskell libraries?
11:41:47 <Hijiri> which libraries?
11:42:03 <Gurkenglas> I'm thinking Data.List and/or Control.Monad
11:42:04 <bernalex> Gurkenglas: if you mean the core libraries: we discuss and vote on what we like.
11:42:36 <bernalex> Gurkenglas: those are part of "base", which is the core libraries distributed with GHC. we decide what to do by discussing and voting on what we like.
11:42:51 <Gurkenglas> I saw unfoldr and thought it might be useful to "lift" (?) it to monads
11:42:53 <Gurkenglas> :t unfoldr
11:42:53 <lambdabot> (b -> Maybe (a, b)) -> b -> [a]
11:43:09 <Gurkenglas> Monad m => (b -> m (a, b)) -> b -> mm a
11:44:00 <Gurkenglas> Where mm would be a recursive data structure that contains an m of (a, mm a)
11:44:04 <merijn> @hackage monad-loops
11:44:04 <lambdabot> http://hackage.haskell.org/package/monad-loops
11:44:40 * hackagebot amazonka-redshift 0.0.1 - Amazon Redshift SDK.  http://hackage.haskell.org/package/amazonka-redshift-0.0.1 (BrendanHay)
11:44:42 * hackagebot amazonka-route53 0.0.1 - Amazon Route 53 SDK.  http://hackage.haskell.org/package/amazonka-route53-0.0.1 (BrendanHay)
11:44:42 <merijn> monad-loops has like 8 different monadic unfolds
11:44:44 * hackagebot amazonka-route53-domains 0.0.1 - Amazon Route 53 Domains SDK.  http://hackage.haskell.org/package/amazonka-route53-domains-0.0.1 (BrendanHay)
11:44:46 * hackagebot amazonka-s3 0.0.1 - Amazon Simple Storage Service SDK.  http://hackage.haskell.org/package/amazonka-s3-0.0.1 (BrendanHay)
11:44:48 * hackagebot amazonka-sdb 0.0.1 - Amazon SimpleDB SDK.  http://hackage.haskell.org/package/amazonka-sdb-0.0.1 (BrendanHay)
11:44:54 <Gurkenglas> Very good! Nevermind then everyone.
11:45:38 <bernalex> unfoldr probably belongs in Foldable by now
11:49:50 * hackagebot amazonka-ses 0.0.1 - Amazon Simple Email Service SDK.  http://hackage.haskell.org/package/amazonka-ses-0.0.1 (BrendanHay)
11:49:52 * hackagebot amazonka-sns 0.0.1 - Amazon Simple Notification Service SDK.  http://hackage.haskell.org/package/amazonka-sns-0.0.1 (BrendanHay)
11:49:54 * hackagebot amazonka-sqs 0.0.1 - Amazon Simple Queue Service SDK.  http://hackage.haskell.org/package/amazonka-sqs-0.0.1 (BrendanHay)
11:49:56 * hackagebot amazonka-storagegateway 0.0.1 - Amazon Storage Gateway SDK.  http://hackage.haskell.org/package/amazonka-storagegateway-0.0.1 (BrendanHay)
11:49:58 * hackagebot amazonka-sts 0.0.1 - Amazon Security Token Service SDK.  http://hackage.haskell.org/package/amazonka-sts-0.0.1 (BrendanHay)
11:50:18 <Yuu_chan> Hello! I have yet another strange "what if" question about typing. Is it possible (with some extensions maybe) to use type classes in first-class way, e.g. to write a function with an arbitrary constraint: foo :: (c a, c b) => (forall d. c d => d -> e) -> (a, b) -> (e, e)
11:50:34 <chrisdone> yeah
11:50:42 <chrisdone> @hackage traverse-with-class
11:50:42 <lambdabot> http://hackage.haskell.org/package/traverse-with-class
11:50:59 <chrisdone> check out the gtraverse function
11:51:13 <chrisdone> you pass in the class context to use as an implicit parameter
11:51:35 <Yuu_chan> сhrisdone: yay, thanks
11:52:52 <Yuu_chan> ConstraintKinds is that one extension, right?
11:53:49 <chrisdone> just ImplicitParams should do the trick afaik
11:53:53 <chrisdone> you have to use Proxy
11:54:01 <chrisdone> e.g. …
11:55:00 * hackagebot amazonka-support 0.0.1 - Amazon Support SDK.  http://hackage.haskell.org/package/amazonka-support-0.0.1 (BrendanHay)
11:55:02 * hackagebot amazonka-swf 0.0.1 - Amazon Simple Workflow Service SDK.  http://hackage.haskell.org/package/amazonka-swf-0.0.1 (BrendanHay)
11:55:04 * hackagebot amazonka 0.0.1 - Comprehensive Amazon Web Services SDK  http://hackage.haskell.org/package/amazonka-0.0.1 (BrendanHay)
11:55:06 * hackagebot amazonka-core 0.0.1 - Core functionality, serialisation primitives, and data types for the Amazonka Amazon Web Services SDKs.  http://hackage.haskell.org/package/amazonka-core-0.0.1 (BrendanHay)
11:55:08 * hackagebot synt 0.1.1 - Similar code analysis.  http://hackage.haskell.org/package/synt-0.1.1 (brentlintner)
11:56:23 <chrisdone> Prelude Data.Generics.Traversable Data.Proxy Control.Applicative> let ?c = Proxy :: Proxy Num in gtraverse (pure . (*2)) [1..5]
11:56:23 <chrisdone> [2,4,6,8,10]
11:59:46 <chrisdone> it's a very neat way to generically traverse over a data structure with whatever class instances you need
11:59:50 <Gurkenglas> merijn, I meant that the Maybe should be abstracted away into a monad
12:00:08 <merijn> Gurkenglas: MaybeT?
12:00:10 * hackagebot synt 0.1.2 - Similar code analysis.  http://hackage.haskell.org/package/synt-0.1.2 (brentlintner)
12:00:46 <Gurkenglas> I meant the Maybe in the unfoldr :I
12:00:57 <Gurkenglas> <Gurkenglas> Monad m => (b -> m (a, b)) -> b -> mm a
12:01:54 <Gurkenglas> mm of Maybe would be a list, mm of [] would be a tree
12:02:43 <Gurkenglas> (unfolding a function that gives you a list of possible successive states of a game would give you the tree of possible states)
12:05:00 <Gurkenglas> Could I express it via Monad m => (b -> m (a, b)) -> b -> Recurse m a                           type Recurse m a = m (a, Recurse m a)
12:05:13 <joncol> What's the difference between >>= and >> (for Monads)?
12:05:19 <Gurkenglas> :t (>>=)
12:05:20 <lambdabot> Monad m => m a -> (a -> m b) -> m b
12:05:21 <Gurkenglas> :t (>>)
12:05:22 <lambdabot> Monad m => m a -> m b -> m b
12:05:54 <Hijiri> @src (>>)
12:05:54 <lambdabot> m >> k = m >>= \_ -> k
12:06:29 <HeladoDeBrownie> joncol, x >> y = x >>= \_ -> y
12:06:32 <Hijiri> m >> k is like m >>= const k
12:06:55 <Hijiri> it ignores the value input to the function and just gives you the second monadic value
12:06:56 <joncol> Perfect, thanks
12:07:29 <HeladoDeBrownie> Hijiri, careful, it doesn't "just" give you the second value. It has the "effect" of both.
12:08:31 <Hijiri> sorry, that's more correct
12:11:17 <HeladoDeBrownie> To be fair, the type can easily be witnessed by flip const as well :P
12:11:52 <HeladoDeBrownie> @type flip const
12:11:53 <lambdabot> b -> c -> c
12:13:51 * hackagebot extended-categories 0.2.0 - Extended Categories  http://hackage.haskell.org/package/extended-categories-0.2.0 (ian_mi)
12:15:24 <newcomer> OK, I replaced tabs with spaces in my text editor. Does this code follows the recommendations concerning indentation and whitespaces? http://lpaste.net/114873
12:15:27 <haskellquestion> im trying to use hLint but it keeps saying no files found. i'm cd'd in to the direction and there's an hs file in here.. anyone have an idea on why it isn't being detected? running the command like this hlint . --report
12:15:56 <haskellquestion> newcomer: i think most people use 4 spaces not 3.. not sure sure though
12:16:35 <haskellquestion> oh all your lines are 4 except for the return one and that's the only one i looked at lol
12:16:50 <bitonic> has development on snap stalled?  I remember that they wanted to move to io-streams quite a while ago, but it seems to still use enumerator
12:17:32 <newcomer> haskellquestion, yes, just realized that. My bad.
12:18:30 <newcomer> mauke, Does that look good?
12:18:41 <newcomer> http://lpaste.net/114873
12:22:59 <chrisdone> hm, interesting…
12:23:14 <chrisdone> λ> div_ "hi"
12:23:14 <chrisdone> <div>hi</div>
12:23:14 <chrisdone> λ> div_ [class_ "foo"] "hi"
12:23:14 <chrisdone> <div class="foo">hi</div>
12:23:32 <chrisdone> ^ gadt + type family re-implementation of lucid i'm messing with
12:23:48 <chrisdone> λ> container_ [class_ "bar"] "sup"
12:23:48 <chrisdone> <div class="container bar">sup</div>
12:24:53 <chrisdone> gets rid of `with' but manages to retain attribute composability
12:27:58 <torpet_> Could somebody help me with endless recursion? http://lpaste.net/4002815318354296832
12:28:09 <torpet_> tmax doesn't stop when feeded with certain input parameters
12:28:42 <imalsogreg> chrisdone: Tangentially related to both lucid and hindent, I tried for a while to find a way to turn haskell-src-exts adt into html, with a div for each node and class set to the node's constructor
12:29:27 <chrisdone> imalsogreg: ja?
12:29:30 <imalsogreg> chrisdone: But got stuck.
12:29:59 <imalsogreg> chrisdone: Yah. The intention was to make a test report using tasty. Tasty would mark up the adt to show you invidivual tests' coverage.
12:30:48 <imalsogreg> chrisdone: Seemed like the kind of thing you would be interested, but I didn't get very far :/
12:31:57 <biscarch> bitonic: nope. There have just been some things taking up maintainers time (such as moving countries). The 1.0 will use io-streams and the 0.14 was an intermediary release that was fairly recent.
12:33:28 <imalsogreg> chrisdone: Thought that maybe hindent could be shoehorned into doing this?
12:33:29 <chrisdone> imalsogreg: hmm
12:33:59 <imalsogreg> chrisdone: But I quickly ended up falling into something that looked like I'd be writing every constructor's case by hand.
12:34:03 <imalsogreg> https://github.com/imalsogreg/tasty-hpc/blob/master/src/HIndent/Styles/Html.hs
12:34:57 <chrisdone> imalsogreg: seems like you need a way to handle things like operators and strings that would contain < and >
12:35:23 <chrisdone> imalsogreg: maybe you could have an Extender for QOp and for Lit to escape them
12:35:31 <imalsogreg> chrisdone: Oh, you mean escaping those? Yah
12:35:32 <newcomer> For some reason the following code waits for input before printing "Enter a string: ". After getting input from user it prints "Enter a string: ". http://lpaste.net/114877
12:35:35 <chrisdone> imalsogreg: and then just have a catch all extender for the rest of node types to wrap them up
12:35:57 <chrisdone> imalsogreg: http://hackage.haskell.org/package/hindent-3.9.1/docs/HIndent-Types.html#v:CatchAll
12:36:08 <Hijiri> newcomer: it's because of output bufferig
12:36:19 <Hijiri> if you use a terminal this is an issue for most languages
12:36:33 <Hijiri> call hFlush stdout manually after you have what you want to print buffered
12:36:44 <Hijiri> Alternatively, you can set buffering mode to NoBuffering
12:36:57 <imalsogreg> chrisdone: Ooh
12:36:59 <Hijiri> but no buffering is slower
12:37:19 <haskellquestion> hey guys this is the program you helped me with a ton yesterday. let me know if there are any suggestions/refactorings/improvements i can make. thanks! http://codereview.stackexchange.com/questions/70674/brainfuck-interpreter-in-haskell-40-lines
12:37:21 <Hijiri> http://hackage.haskell.org/package/base-4.7.0.1/docs/System-IO.html#v:hFlush
12:37:32 <chrisdone> imalsogreg: you can provide something like (CatchAll (\a -> write ("<div class='" <> typeOf a <> "'>); prettyNoExt a; write "</div>"))
12:38:11 <newcomer> Hijiri, Got it.
12:38:15 <newcomer> Thanks
12:38:59 <Hijiri> np
12:39:05 <imalsogreg> chrisdone: prettyNoExt a, from the name, it sounds like this doesn't have the extender recursing into a?
12:39:30 <chrisdone> imalsogreg: it means don't call any extenders for this node, but do so for children of this node
12:39:31 <imalsogreg> chrisdone: rereading your blogpost, I see that much of what you're telling me now was covered there, haha sorry :)
12:39:45 <chrisdone> http://hackage.haskell.org/package/hindent-3.9.1/docs/HIndent-Pretty.html#v:prettyNoExt
12:40:07 <chrisdone> imalsogreg: np =)
12:40:50 <imalsogreg> chrisdone: Ok, this looks pretty promising I think, thanks!
12:41:16 <chrisdone> imalsogreg: welcome. let me know if it works, i'd hoped for a use-case like this to work ;)
12:42:00 <imalsogreg> chrisdone: I'll let you know in a few months (finishing my degree will keep me boring until then). But when I do get to it I'll be sure to let you know.
12:42:09 <chrisdone> haha, ok
12:58:25 <sinelaw> language-ecamscript doesn't have special syntax for "undefined"
12:58:32 <sinelaw> *language-ecmascript
13:00:41 <chrisdone> why would it?
13:05:13 <sinelaw> chrisdone, this seems to imply that it's part of the language https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/undefined
13:05:29 <sinelaw> didn't yet check actual ES3
13:06:47 <chrisdone> i don't remember any syntactical distinction between undefined and any other variable
13:06:56 <sinelaw> they have some for null
13:07:25 <chrisdone> they do?
13:07:28 <zeusnet> Helo
13:08:04 <sinelaw> in language-ecmascript yes
13:08:33 <sinelaw> http://hackage.haskell.org/package/language-ecmascript-0.16.2/docs/src/Language-ECMAScript3-Syntax.html#Expression
13:08:40 <chrisdone> > (function(undefined){ console.log(undefined) })(123)
13:08:40 <chrisdone> 123
13:08:41 <chrisdone> > (function(null){ console.log(null) })(123)
13:08:41 <chrisdone> SyntaxError: Unexpected token null
13:08:41 <lambdabot>  <hint>:1:30: parse error on input ‘.’
13:08:42 <lambdabot>  <hint>:1:25: parse error on input ‘.’
13:08:43 <chrisdone> ^there's one difference
13:08:55 <zeusnet> 123
13:09:36 <sinelaw> where did you run that
13:10:12 <sinelaw> and yes, undefined can be overwritten in non-strict mode
13:10:17 <sinelaw> so maybe that's the reason
13:10:24 <sinelaw> (or shadowed)
13:11:46 <sinelaw> chrisdone, yeah, looks like ES3 doesn't define "undefined" as a literal
13:12:02 <sinelaw> a.k.a. "the awful parts"
13:12:55 * sinelaw barfs
13:13:07 <mreh> it's a shame happstack's routing combinators can't be used in do notation
13:13:24 <mreh> dir "hello" $ path $ \subject -> ok $ (sayHello subject)
13:13:56 <mreh> instead of do { dir "hello"; subject <- path; ok $ (sayHello subject) }
13:14:49 <mreh> seems more natural to me
13:17:07 <Hijiri> what does do { dir "hello"; ok $ sayHello "aaa"; subject <- path; ok $ sayHello subject } mean?
13:18:00 <heaumer> !summon Azel
13:19:08 <mreh> Hijiri, any request to /hello returns "Hello, aaa"
13:19:23 <mreh> probably
13:19:44 <stevejb> hello, I trying to write write a function which samples random numbers, filters them, and returns when N of those numbers match the condition. For example,
13:19:49 <stevejb> y <- runRandT  (liftM (take 10) $  liftM (filter ( < 0.3)) $ sequence $ replicate 10000 (getRandomR (0,1))) gen
13:19:57 <chrisdone> any people familiar with ghcjs?
13:20:07 <stevejb> however, how do I make this an infinite list so I am sure that I get enough samples to match the condition
13:20:15 <stevejb> (meaning, not use sequence here)
13:20:28 <chrisdone> i can't get this trivial ffi example to work D: http://lpaste.net/439709169692442624
13:20:46 <chrisdone> it always prints 1=null
13:20:51 <Hijiri> It seems less natural with do notation
13:21:03 <Hijiri> with do notation the "effect" seems to be setting a bunch of environment
13:21:20 <Hijiri> which also makes it harder to keep track of
13:22:05 <mreh> Hijiri, hmm, yes
13:23:41 <Guybrush_T> Hi guys! i would appreaciate some help with this: i have two lists a and b and would like to do ~ the following: map (funcname ca cb) (zip a b) where ca and cb are the element pairs of (zip a b)
13:24:06 <ion> zipWith funcname a b
13:24:28 <Guybrush_T> sounds easy, ill check it out thanks
13:26:26 <sinelaw> Guybrush_T, which really is the same as: map (\(ca,cb) -> funcname ca cb) (zip a b)
13:26:47 <sinelaw> Guybrush_T, also, when I can't find something built-in that does what I want, I always check hoogle
13:27:16 <sinelaw> @hoogle (a -> a -> b) -> [a] -> [a] -> [b]
13:27:17 <lambdabot> Prelude zipWith :: (a -> b -> c) -> [a] -> [b] -> [c]
13:27:17 <lambdabot> Data.List zipWith :: (a -> b -> c) -> [a] -> [b] -> [c]
13:27:17 <lambdabot> Data.List deleteFirstsBy :: (a -> a -> Bool) -> [a] -> [a] -> [a]
13:31:38 <Guybrush_T> sinelaw, thanks for the hint, i knew hoogle already and used it before but in this case i didn't really know how to work this, it was a little much going on at once =)
13:32:44 <sinelaw> Guybrush_T, well you want something that takes a function that combines two elements (a -> b -> c), and also takes the two lists [a] and [b] and returns a list of combined eleements, [c]
13:32:55 <sinelaw> hence (a -> b -> c) -> [a] -> [b] -> c
13:32:59 <sinelaw> oops, [c] at the end.
13:34:02 <Guybrush_T> sinelaw, kinda, i have to admint that i left out a function param, so it actually is: (map (\(ca,cb) -> funcn f ca cb) (zip a b))
13:34:26 <lpaste> mettekou pasted “'nub' on infinite list of tuples of random 'Int's” at http://lpaste.net/2080061448955887616
13:34:28 <mettekou> Could anyone how to remove duplicates from my infinite list? The Dl.sort happens after taking a finite number (5) of elements, so that isn't the problem. That means it must be Dl.nub, which seems logical: you cannot remove duplicates before knowing what every element in the list is, unless it is sorted. But if I would use Dl.nub after take, I might end up with less tuples than I want.
13:34:37 <mettekou> tell me **
13:35:00 <sinelaw> Guybrush_T, but then due to currying "funcn f" is a function of the right type, so you can treat it as one element
13:36:10 <Guybrush_T> sinelaw, you are right of course
13:38:54 * hackagebot bloodhound 0.4.0.1 - ElasticSearch client library for Haskell  http://hackage.haskell.org/package/bloodhound-0.4.0.1 (bitemyapp)
13:45:46 <hiptobecubic> simpleHttp doesn't do https :(
13:46:38 <Guybrush_T> sinelaw, about that: when i have functions f1 (Int -> Int) and f2 (Int -> Int -> Int) and expect a function (Int -> Int) to be returned i can do this: >> ... = (f1 1) << but how do i get this to work? >> ... = (f1 1 (f2)) << so the free variable will be inserted into f2?!
13:47:15 <Guybrush_T> ah dammit i got f1 and f2 confused, just exchange them
13:47:19 <sinelaw> Guybrush_T, not sure what you mean
13:47:23 <sinelaw> apparently so
13:49:54 <Guybrush_T> sinelaw, do you know what i mean or not? it's hard for me to describe
13:50:07 <sinelaw> you're trying to compose f1 and f2?
13:50:19 <sinelaw> input --> f1 --> f2 --> output?
13:51:31 <sinelaw> Guybrush_T, if so, then:
13:51:44 <sinelaw> @src (.)
13:51:44 <lambdabot> (f . g) x = f (g x)
13:52:06 <sinelaw> in other words, you want f2 (f1 x) which is the same as f2 . f1
13:52:21 <sinelaw> (f2 . f1) x
13:55:23 <Guybrush_T> myfunc :: (Int -> Int) -> (Int -> Int -> Int) -> (Int -> Int)
13:55:34 <Guybrush_T> with that i can do this right? myfunc f1 f2 = f2 1
13:57:00 <Guybrush_T> but this doesn't work: myfunc f1 f2 = f2 1 (f1)
13:57:30 <shiona> sounds correct
13:58:53 <Guybrush_T> so if the returned function is f(x) = y and i want: y = f2(1,f1(x))
13:59:06 <Guybrush_T> how would i need to format that in haskell
14:00:22 <Gurkenglas> f2 1 (f1 x)?
14:00:37 <Gurkenglas> @djinn (a -> a) -> (a -> a -> a) -> (a -> a)
14:00:37 <lambdabot> f a b c = b c (a c)
14:01:01 <shiona> Guybrush_T: I believe "myfunc f1 f2 = f2 1 . f1" would be suitable
14:01:39 <Gurkenglas> @pl \c -> b c (a c)
14:01:39 <lambdabot> ap b a
14:01:50 <Guybrush_T> siona, with that . thing, i really need to look more into that i don't understand it completely
14:02:01 <Gurkenglas> @src (.)
14:02:02 <lambdabot> (f . g) x = f (g x)
14:02:21 <Guybrush_T> but why don't i need it when i do this => myfunc f1 f2 = f2 1
14:02:38 <Guybrush_T> x just gets inserted after the 1
14:02:52 <shiona> Guybrush_T: I know exactly what you mean. I still don't get it completely myself
14:03:23 <Guybrush_T> hmm ok
14:03:24 <Gurkenglas> f2 has the type (a -> a -> a), which is syntactic sugar for (a -> (a -> a))
14:03:36 <Gurkenglas> It takes an a and returns a function of type (a -> a)
14:03:56 <Gurkenglas> so (f2 1) is one of those.
14:04:36 <Gurkenglas> ((f2 x y) is syntactic sugar for ((f2 x) y)
14:04:43 <Gurkenglas> *((f2 x y) is syntactic sugar for ((f2 x) y))
14:04:48 <Gurkenglas> Forgot a ) there at the end
14:05:07 <monochrom> first you can write "myfunc f1 f2 x = f2 1 (f1 x)
14:05:29 <Guybrush_T> i understand, so what i wrote is basically ((f2 1) _) and haskell puts the x in there
14:05:31 <monochrom> then you can mechanically rewrite that as "myfunc f1 f2 = f2 1 . f1
14:06:46 <Gurkenglas> Yep. myfunc f1 f2 is supposed to return a function of type (Int -> Int) in your definition, so it expects a function of that type on the right side. (f2 1) has exactly that type.
14:10:32 <hunz_> hello. how can i get [(1, 1, 1), (-1, 1, 1), (1, -1, 1), (-1, -1, 1), (1, -1, -1), (-1, -1, -1), (1, 1,- 1), (-1,1,-1)] out of (1,1,1) without brute forcing by hand?
14:10:43 <hunz_> with any integer of course
14:11:22 <Guybrush_T> Gurkenglas, it works like that, but i still have to read up on that "dot" thing. do you know how that is called in haskell so i can look it up?
14:12:33 <Gurkenglas> It's called function composition and often used in mathematics
14:13:12 <Gurkenglas> Usually it's written with a circle as in http://en.wikipedia.org/wiki/Function_composition
14:13:51 <monochrom> the . operator is simply, mechanically defined by "(f . g) x = f (g x)"
14:13:55 * hackagebot Chart 1.3.2 - A library for generating 2D Charts and Plots  http://hackage.haskell.org/package/Chart-1.3.2 (TimDocker)
14:13:57 * hackagebot Chart-cairo 1.3.2 - Cairo backend for Charts.  http://hackage.haskell.org/package/Chart-cairo-1.3.2 (TimDocker)
14:13:59 * hackagebot Chart-gtk 1.3.2 - Utility functions for using the chart library with GTK  http://hackage.haskell.org/package/Chart-gtk-1.3.2 (TimDocker)
14:14:01 * hackagebot Chart-diagrams 1.3.2 - Diagrams backend for Charts.  http://hackage.haskell.org/package/Chart-diagrams-1.3.2 (TimDocker)
14:14:03 * hackagebot Chart-simple 1.3.2 - A wrapper for the chart library to assist with basic plots (Deprecated - use the Easy module instead)  http://hackage.haskell.org/package/Chart-simple-1.3.2 (TimDocker)
14:14:38 <sinelaw> Guybrush_T, it is just a function like any other function.
14:14:51 <sinelaw> Guybrush_T, let's call it "compose"
14:14:52 <Guybrush_T> ah i know function composition from math, i guess that in this case it's only necessary because the x gets inserted on the right side, right?
14:15:06 <sinelaw> Guybrush_T, then: compose f g x = f (g x)
14:15:43 <Guybrush_T> got it, thanks for all the help!
14:16:19 <indiagreen> > let (a,b,c) = (1,2,3) in liftM3 (,,) [a,-a] [b,-b] [c,-c] -- hunz_
14:16:21 <lambdabot>  [(1,2,3),(1,2,-3),(1,-2,3),(1,-2,-3),(-1,2,3),(-1,2,-3),(-1,-2,3),(-1,-2,-3)]
14:17:06 <hunz_> indiagreen: Wow, thank you.
14:17:50 <hunz_> what does the (,,) function do?
14:17:56 <indiagreen> > (,,) 1 2 3
14:17:58 <lambdabot>  (1,2,3)
14:17:59 <hunz_> >:t (,,)
14:18:07 <indiagreen> :t (,,)
14:18:07 <sinelaw> :t (,,)
14:18:07 <hunz_> ah
14:18:08 <lambdabot> a -> b -> c -> (a, b, c)
14:18:08 <lambdabot> a -> b -> c -> (a, b, c)
14:18:13 <sinelaw> O_o
14:18:36 <Gurkenglas> "O_o"?
14:18:36 <indiagreen> also, if it wasn't a tuple you'd be able to do it in a generic way:
14:18:38 <indiagreen> > mapM (\x -> [x,-x]) [1,2,3]
14:19:03 <Gurkenglas> Where'd lambdabot go D:
14:19:07 <hunz_> i may would have come to the lambda solution, but unfortunately it's a tuple
14:19:09 <hunz_> thank you
14:20:10 <sinelaw> Gurkenglas, \(_o)/
14:20:41 <sinelaw> @seen lambdabot
14:20:41 <lambdabot> 14MbDA80T
14:20:56 <Gurkenglas> >mapM (\x -> [x,-x]) [1,2,3]
14:21:00 <Gurkenglas> > 2+2
14:21:01 <lambdabot>  4
14:21:20 <Gurkenglas> > map (\x -> [x,-x]) [1,2,3]
14:21:22 <lambdabot>  [[1,-1],[2,-2],[3,-3]]
14:21:29 <Gurkenglas> :t mapM
14:21:30 <lambdabot> Monad m => (a -> m b) -> [a] -> m [b]
14:22:13 <Gurkenglas> > filterM (const [True, False]) "123"
14:22:14 <lambdabot>  ["123","12","13","1","23","2","3",""]
14:22:57 <Gurkenglas> > forM [1,2,3] (\x -> [x,-x])
14:22:58 <lambdabot>  [[1,2,3],[1,2,-3],[1,-2,3],[1,-2,-3],[-1,2,3],[-1,2,-3],[-1,-2,3],[-1,-2,-3]]
14:23:19 <Gurkenglas> @define mapM = flip forM
14:23:21 <lambdabot>  Defined.
14:23:28 <Gurkenglas> >mapM (\x -> [x,-x]) [1,2,3]
14:23:43 <Gurkenglas> arghmbl. I give up.
14:23:56 <sinelaw> (ノಠ益ಠ)ノ彡┻━┻
14:24:35 <sinelaw> lambdabot doesn't seem to like mapM
14:24:49 <Gurkenglas> Oh wait.
14:24:59 <Gurkenglas> @define map = const
14:25:00 <lambdabot>  Defined.
14:25:06 <Gurkenglas> > map (\x -> [x,-x]) [1,2,3]
14:25:07 <lambdabot>  Ambiguous occurrence ‘map’
14:25:07 <lambdabot>  It could refer to either ‘L.map’, defined at L.hs:158:1
14:25:07 <lambdabot>                        or ‘GHC.Base.map’,
14:25:07 <lambdabot>                           imported from ‘Data.List’ at L.hs:91:1-16
14:25:07 <lambdabot>                           (and originally defined in ‘base:GHC.Base’)
14:25:12 <Gurkenglas> Nope, that's not it.
14:25:31 <sinelaw> you ruined map
14:26:20 <Gurkenglas> http://www.youtube.com/watch?v=gRup3mJCmm4
14:27:22 <sinelaw> ಠ_ಠ
14:28:02 <sinelaw> @undefine map
14:28:02 <lambdabot> There's currently no way to undefine just one thing.  Say @undefine (with no extra words) to undefine everything.
14:28:07 <sinelaw> @undefine
14:28:07 <lambdabot> Undefined.
14:28:15 <sinelaw> > map id [1,2]
14:28:16 <Gurkenglas> All is lost.
14:28:17 <lambdabot>  [1,2]
14:28:29 <Gurkenglas> Except for all of it.
14:28:38 <sinelaw> > mapM (\x -> [x,-x]) [1,2,3]
14:28:40 <lambdabot>  [[1,2,3],[1,2,-3],[1,-2,3],[1,-2,-3],[-1,2,3],[-1,2,-3],[-1,-2,3],[-1,-2,-3]]
14:28:43 <sinelaw> TA DA
14:28:43 <Gurkenglas> You what
14:29:12 <oleo> lol
14:29:40 <Gurkenglas> > print "Something"
14:29:41 <lambdabot>  <IO ()>
14:29:51 <Gurkenglas> How on earth would you get it to do nothing?
14:30:07 <Gurkenglas> > do Nothing
14:30:09 <lambdabot>  Nothing
14:30:31 <sinelaw> @define mapM = mapM
14:30:31 <lambdabot>  .L.hs:152:8:
14:30:31 <lambdabot>      Ambiguous occurrence ‘mapM’
14:30:32 <lambdabot>      It could refer to either ‘L.mapM’, defined at .L.hs:152:1
14:30:32 <lambdabot>                            or ‘Control.Monad.Writer.mapM’,
14:30:32 <lambdabot>                               imported from ‘Control.Monad.Writer’ at .L.hs:6...
14:30:42 <sinelaw> @define mapM = let stuck = stuck in stuck
14:30:44 <lambdabot>  Defined.
14:30:47 <sinelaw> > mapM (\x -> [x,-x]) [1,2,3]
14:30:49 <lambdabot>  Ambiguous occurrence ‘mapM’
14:30:49 <lambdabot>  It could refer to either ‘L.mapM’, defined at L.hs:152:1
14:30:49 <lambdabot>                        or ‘Control.Monad.mapM’,
14:30:49 <lambdabot>                           imported from ‘Control.Monad.Writer’ at L.hs:60:1-27
14:30:49 <lambdabot>                           (and originally defined in ‘base:Control.Monad’)
14:30:55 <sinelaw> never mind.
14:30:57 <sinelaw> @undefine
14:30:57 <lambdabot> Undefined.
14:31:23 <Gurkenglas> Someone look through the logs for what they did to mapM.
14:32:31 <torpet_> could someone eplain me why this magic reverse map works? http://lpaste.net/6846725980665413632
14:33:32 <sinelaw> Gurkenglas, @tell me if you find out, i'm off
14:34:53 <Gurkenglas> pam listoffunctions argument = map g listoffunctions where g function = function argument
14:35:11 <Gurkenglas> (Named some variables after their type signatures.)
14:35:17 <Gurkenglas> How would you now name g?
14:35:40 <Gurkenglas> (The author might have done well to add a type signature for g.)
14:52:39 <Welkin> should I install pandoc in a sandbox?
14:52:48 <Gurkenglas> torpet_, still there?
14:52:50 <Welkin> it looks like it has a lot of dependencies
14:53:30 <torpet_> Gurkenglas: I'm here again
14:54:50 <torpet_> I think I understand , thanks.
15:09:06 <rodlogic> As an experiment, is it possible to implement poly-variadic functions with closed type families? I basically want haskell to infer  that 'fn "arg1" "arg2"' has type fn :: Poly String where Poly is a type family that evaluates to fn :: String -> String
15:10:45 <merijn> rodlogic: Yes, it should be
15:10:55 <merijn> rodlogic: I think I have something along those lines, lemme check
15:11:27 <merijn> I'm assuming you're missing a return argument in that 'fn' type?
15:12:05 <rodlogic> merijn: humm, not 100% yet, but that is a good start
15:12:10 <merijn> rodlogic: Can you be a bit more concrete on what you have and what you'd want to infer?
15:12:16 <prinsen> I have an AST, is there any shortcut to extracting all values of type Foo from the AST?
15:13:41 <indiagreen> yes, generics
15:14:24 <indiagreen> hopefully you won't forget about having used this shortcut when you update your AST and it turns out that in some cases you shouldn't extract some values
15:14:24 <rodlogic> merijn: consider for instance a function that concatenates Strings. I would like to be able to have 'concat "str1" "str2"' and have it return "str1str2". And of course the same concat "str1" "str2" "str3" return the concatenation of that
15:15:20 <merijn> rodlogic: You can do something like that
15:15:20 <rodlogic> merijn: so the args and return are of the same type
15:15:32 <prinsen> indiagreen: Can you express rules such as any Foo value that isnot a child of a Boo node?
15:15:51 <merijn> rodlogic: Oh, wait you're just looking for an automatic fold for Endo?
15:16:12 <merijn> Why even bother with type families for this?
15:17:25 <rodlogic> merijn: I want to understand how to use (closed) type families
15:18:15 <merijn> rodlogic: I don't think this particular use case is a good one, though. I have some neat closed type families tricks, though :)
15:18:32 <rodlogic> merijn: can you show me :-)
15:18:34 <merijn> rodlogic: First of, my favourite: https://gist.github.com/merijn/6130082
15:18:59 <merijn> rodlogic: More custom constraints: https://gist.github.com/merijn/39dc86e345e87276c523
15:19:46 <merijn> rodlogic: The problem with your initial question is that you want the behaviour to dependent on the type and type families don't let you do that
15:19:59 <indiagreen> prinsen: I think you can write a generic traversal with “children” from Data.Generics.Uniplate, i.e. if you have “data AST = Foo AST | Boo AST AST | Bar AST AST | Quix Int”, you can write a recursive function which would treat Boo specially (just stop traversing and return empty list), and for all other values it would extract list of children of type AST (using “children”) and process them recursively
15:20:25 <rodlogic> merijn: interesting tricks ...
15:20:38 <merijn> rodlogic: Type families can only help you write more elaborate types. The sorta behaviour you want requires a typeclass to implement the specific behaviour (although you can then use closed type families to actually write signatures for your class)
15:21:21 <merijn> rodlogic: Another trick I've used (I don't have a minimal example for that) is ana generalised "apply" function
15:22:00 <rodlogic> merijn: this is what it looks like with type classes: http://lpaste.net/114885
15:22:02 <merijn> rodlogic: Basically, I wanted to import FFI functions and use them in a "general" setting without special casing for different types, so I wrote a typeclass based generic "apply" function and a type family to statically guarantee safety
15:22:38 <merijn> rodlogic: Right, but you can't eliminate that typeclass
15:23:01 <prinsen> indiagreen: thanks I will check it out
15:23:13 <indiagreen> prinsen: I'll write an example for you, a sec
15:23:32 <merijn> rodlogic: A less minimal example of what I've done in the past
15:23:43 <merijn> rodlogic: I had a "pattern" (heterogeneous list) https://github.com/merijn/SNet2.0/blob/master/SNet/Pattern.hs
15:23:56 <merijn> rodlogic: And wanted to call it with an arbitrary function that matched the type of the pattern
15:24:20 <merijn> rodlogic: https://github.com/merijn/SNet2.0/blob/master/SNet/Task.hs#L73-L79
15:24:53 <wyager> Hello. I am using http://hackage.haskell.org/package/messagepack-0.2.1/docs/Data-MessagePack.html (which is excellently minimal). The only thing it exposes is a Serialize instance. I would like to deserialize from a network connection (i.e. a Handle). Is there a standardized way to use Serialize’s `decode` function on a Handle?
15:24:58 <merijn> rodlogic: That is the general GADT based apply function, the type family unwraps the type from the pattern into a function type which means that passing a function of the "wrong type" to apply will statically error
15:25:51 <rodlogic> merijn: interesting. My type foo there is quite weak
15:25:51 <merijn> rodlogic: Does that make sense?
15:26:02 <rodlogic> merijn: Let me digest it
15:26:15 <merijn> rodlogic: Lemme simplify
15:26:22 <merijn> rodlogic: https://gist.github.com/merijn/dc00bc7cebd6df012c5e <- simple heterogeneous list
15:26:39 <merijn> rodlogic: It caries a type level list of types indicating the type of each element
15:26:57 <merijn> So far so good?
15:26:59 <rodlogic> yes
15:27:16 <merijn> So I want to apply a function that consumes all elements in the list
15:27:35 <merijn> And produces an IO (), but it could be whatever
15:27:58 <merijn> rodlogic: If you ignore the complex pattern junk, this function: https://github.com/merijn/SNet2.0/blob/master/SNet/Task.hs#L77-L79
15:28:20 <merijn> rodlogic: Is just partially applying one element at a time and recursing
15:28:41 <merijn> (rec ! h) is extra the value to apply, but you can just ignore that
15:29:08 <merijn> rodlogic: So now I have a problem: How do I convince GHC that the function I'm applying arguments to matches the arguments of my HList?
15:29:36 <merijn> rodlogic: I know all the types in the list, so I need to restrict the input function to apply to match all of them
15:30:05 <merijn> rodlogic: That's where https://github.com/merijn/SNet2.0/blob/master/SNet/Task.hs#L73-L75 comes in
15:30:25 <merijn> rodlogic: It takes a type level list of types and returns a function type in the obvious recursive way
15:30:35 <merijn> Still making sense?
15:31:11 <merijn> rodlogic: Suppose I have "HList [Int, Bool, Char]" then "BoxFun [Int, Bool, Char]" expands into "Int -> Bool -> Char -> IO ()"
15:31:58 <merijn> rodlogic: GHC can then statically see that every type in my argument function lines up witht the types in my HList, so it's perfectly happy to compile that
15:32:00 <rodlogic> merijn: right, from a type to a type
15:32:00 <prinsen> indiagreen: My AST isn't a single type, if that matters
15:32:08 <haskellquestion> hey merijn: i finished that brainfuck interpreter you were helping me with yesterday. here's  the code if you want to check it out http://codereview.stackexchange.com/questions/70674/brainfuck-interpreter-in-haskell
15:32:57 <wyager> Anyone? This has to be a pretty common problem. I want to `decode` a Serialize (or Binary) object from a Handle.
15:33:07 <merijn> rodlogic: So the way the type family helps here is that it lets the type of my second argument to apply depend on the first argument in non-trivial ways
15:33:50 <merijn> rodlogic: Normally you can only express "these types are the same" by using the same type variable. I can now express arbitrarily complex relations between function arguments on the type level
15:34:07 <rodlogic> merijn: so based on Pattern [Int, Bool, Char] you expand BoxFun to Int -> Bool -> Char -> IO ()
15:34:10 <merijn> rodlogic: However, I cannot have the behaviour of the function itself depend on the types
15:34:15 <merijn> rodlogic: Right
15:34:19 <Zemyla> Is there a package for Haskell that works with an Amazon EC2 instance? I want to get started with Haskell, and this is the easiest platform to use it on.
15:34:44 <merijn> rodlogic: And then it basically becomes a matter of checking the recursive call against the recursive matching of HList/Pattern, which ends up lining up perfectly fine
15:35:15 <rodlogic> merijn: I see. very instructive.
15:35:56 <merijn> rodlogic: The other thing you can do in neat ways is writing arbitrarily complex constraints, like my Restrict constraint which allows "all types except () or Int"
15:36:30 <merijn> Although that one has some rough edges, i.e. it doesn't place nice with overloaded literals like numeric literals, OverloadedStrings/OverloadedLists
15:37:03 <merijn> rodlogic: I actually have more complicated tricks I'm using myself right now that I plan to write up "At Some Point (TM)"
15:38:16 <rodlogic> merijn: I was hoping that GHC would be smart enough to go backwards on a close type family, i.e. if I give concat "a1" "a2" it would infer a type concat :: String -> String -> String and then to concat :: Components String
15:38:51 <merijn> I don't think it can do that, no
15:39:04 <rodlogic> merijn: assuming that type family Components a where Component String :: String ; Component (String -> Component String) = String -> Component String
15:39:11 <rodlogic> merijn: or something like that
15:39:15 <merijn> haskellquestion: btw, why do you have a guard + if/then/else on the first line of prevBracketIndex?
15:39:17 <rodlogic> merijn: ok
15:39:24 <merijn> haskellquestion: Why not make a more elaborate guard instead? :)
15:39:49 <rodlogic> merijn: so the best I can do is cleanup the type used in the polyvariadic type class in my example above?
15:39:59 <haskellquestion> merijn: i was actually torn between whether to do that or not. i figured adding another guard would have more repetition so i just went with the if expression
15:39:59 <merijn> rodlogic: Yeah
15:40:00 <rodlogic> merijn: using a type family?
15:40:11 <indiagreen> prinsen: sorry, apparently I don't know how to do it myself
15:40:20 <merijn> rodlogic: You will have to keep the type class for the polymorphic dispatch
15:40:30 <indiagreen> for whatever reason “childrenBi” traverses deeper than I want
15:40:42 <merijn> rodlogic: The only thing type families can do for you here is have a safer/restricted type
15:41:05 <rodlogic> merijn: that was great, thanks! Let me experiment with it a bit
15:41:11 <merijn> haskellquestion: Fun fact, where clauses scope over all guards, so you could move the condition into a where clause and use that in your guards
15:41:26 <haskellquestion> oh that's a good iea
15:41:28 <haskellquestion> idea*
15:43:01 <Welkin> wow does pandoc take a long time to build
15:43:09 <wyager> It is very complex
15:43:18 <rom1504> Welkin: yes
15:44:10 <merijn> It's not the complexity
15:44:41 <merijn> There's a bug that affects a couple of pandoc's dependencies that blows up GHCs memory consumption and causes the compilation to take ages
15:44:53 <merijn> Pretty sure it's not fixed yet in 7.8
15:45:30 <merijn> And when i say ages, I mean, "when I build a profiled version of pandoc on my old laptop it was barely usable for like 45 minutes"
15:48:16 <Zemyla> Do you need to already have Haskell to compile Haskell?
15:48:29 <merijn> Yes
15:48:43 <merijn> Same way you need to have a C compiler to compile gcc/clang
15:49:14 <marchelzo_> it
15:49:19 <marchelzo_> it's magic*
15:49:22 <ij> If we lost all the binaries, we couldn't compile it any more, right?
15:49:52 <Hijiri> there's a boostrapped ghc compilation package I think
15:50:00 <merijn> ij: Probably not a problem unless we also lost all C compilers
15:50:07 <Zemyla> Well, there are old versions of Haskell that were compiled from C, so you could compile those, then compile the earliest Haskell from that, and so on.
15:50:22 <lcf80> asm is not that bad ;)
15:50:24 <merijn> ij: The very first haskell compilers were written in C, so we'd have to bootstrap all the way from there if we're unlucky
15:50:35 <athan> Hey guys, how is this not an exhaustive pattern? http://lpaste.net/114886
15:50:52 <glguy> If something happened that caused the world to lose all the copies of GHC, the world probably has some significantly worse immediate problems to figure out
15:50:55 <merijn> athan: Line 2, typo
15:50:59 <Hijiri> I thought the very first haskell compilers were done in an ML?
15:51:12 <merijn> Hijiri: I don't think so?
15:51:15 <athan> merijn: Thank you :)
15:51:19 <merijn> Ask augustss when he's here :)
15:51:56 <merijn> Even if it was, we'd have Hugs
15:52:09 <merijn> We could hopefully bootstrap an old GHC from Hugs
15:52:14 <luite> hbc was written in lml yeah
15:52:48 <rom1504> if we lost all binaries, we would probably lost all sources too
15:52:51 <luite> hmm, where is that source snapshot
15:53:13 <dfeuer> merijn, it'd probably be easier to lose Hugs than GHC, by a lot.
15:53:40 <merijn> Anyway, let's consider this "exceedingly unlikely" :p
15:53:50 <rom1504> except if it's a virus specifically written to erase all ghc binaries all over the world
15:54:01 <rom1504> and just that
15:54:02 <glguy> ooh, or aliens
15:54:28 <rom1504> yeah maybe alien would write this virus :p
15:55:18 <Zemyla> So how do you build Haskell for a new system? Cross-compilation?
15:55:52 <rom1504> *architecture
15:56:04 <merijn> Zemyla: Painful slow bootstrapping process and/or cross-compilation, yes
15:56:34 <giogadi> to anyone that has experience with c2hs: is there a way to get cabal to call c2hs with some additional #defines?
15:56:35 <merijn> Zemyla: Unless you mean "new computer" rather than "new architecture" when you say "new system"
15:56:36 <luite> Zemyla: ghc can produce unregisterised code, which is a translation to really slow but portable C
15:57:01 <nshepperd> compile it by hand!
15:57:01 <Zemyla> Yeah, I meant new architecture.
15:57:04 <merijn> luite: I thought that one has bitrotted a bit?
15:57:34 <merijn> Zemyla: There's a bunch of work on making GHC more cross-compile friendly, such as the ARM work
15:57:44 <dcoutts> giogadi: you typically use a local custom .h file with extra defines and includes
15:57:51 <merijn> Zemyla: But on the whole it's about as painful as porting gcc/clang to a new architecture
15:58:06 <merijn> Which is to say "rather painful" :p
15:58:12 <giogadi> dcoutts: that's......pretty obviously the right way to go. Dunno why it didn't occur to me. Thanks!!
15:58:40 <Zemyla> So there's no Haskell implementation for Android yet.
15:58:48 <lcf80> hm
15:58:52 <merijn> Zemyla: Most android phones are ARM
15:58:58 <lcf80> Keera Studios are doing game on Android
15:59:04 <merijn> Zemyla: (Some) ARM is currently tier 2
15:59:06 <lcf80> currently in beta - in Haskell, ofc
15:59:34 <merijn> Zemyla: That is, it works, but not all features (e.g. ghci) work yet
15:59:59 <Zemyla> Well, ghci would need to be ported to use an Android window rather than the command line.
16:00:00 <merijn> More help in testing, documenting and bug hunting for ARM cross-compilation is always welcome ;)
16:00:21 <Zemyla> But yeah, I'm not the person to ask. I'm just now learning Haskell.
16:00:29 <merijn> Zemyla: See: https://ghc.haskell.org/trac/ghc/wiki/Platforms
16:02:20 <luite> merijn: hmm, i'm not sure. the -fvia-C backend is not very usable anymore in general, but it might be enough to bootstrap ghc. new targets tend to use llvm nowadays, rather than starting with C, so i guess it'd be easier for some rot to go unnoticed
16:02:23 <dfeuer> luite, how does the unregisterized code deal with the difference between C and Haskell semantics for int/Int overflow? Does it cast everything to unsigned for arithmetic or to signed only for comparison?
16:03:15 <dfeuer> So much fun -fvia-c must have.
16:03:19 <indiagreen> Zemyla: there are terminal emulators for Android, so this isn't necessary
16:03:26 <merijn> luite: -fvia-C is broken enough that it doesn't ship in the default build of GHC
16:03:50 <merijn> dfeuer: Which C semantics for int overflow?
16:04:09 <dfeuer> merijn, exactly. There aren't any.
16:05:12 <dfeuer> It's unspecified behavior, and compilers can (and sometimes do) unroll loops on the assumption that it doesn't occur.
16:05:47 <ihatehex> I wish I had an x:xs function for lines
16:06:02 <ihatehex> as in the kinds at grocery stores and rides at amusement parks
16:07:23 <jmcarthur> you mean you wish the lines were stacks instead of queues?
16:07:30 <jmcarthur> seems frustrating
16:09:14 <jmcarthur> dfeuer: isn't it only undefined in C for *signed* integers?
16:09:48 <jmcarthur> dfeuer: maybe the trick is to just use unsigned integers to emulate signed integers (where possible?)
16:10:09 <dfeuer> jmcarthur, exactly. So you'd have to use unsigned for all arithmetic, but cast back to signed for comparisons. Fun dance.
16:10:22 <dfeuer> Not a huge deal, I guess.
16:10:31 <dfeuer> But C makes it so easy to make mistakes....
16:14:41 <nshepperd> it sure leaves a lot of stuff 'implementation defined'
16:14:56 <merijn> nshepperd: This is not implementation defined, it's undefined
16:14:59 <merijn> They are not the same
16:15:14 <nshepperd> well yeah, undefined is even worse
16:15:19 <nshepperd> just saying
16:15:20 <merijn> Implementation defined that the implementation must 1) specify what it does and 2) consistently do that
16:21:53 <mettekou> Does anyone know how to change cabal's dist directory from the *.cabal file?
16:22:12 <merijn> mettekou: Pretty sure you can't
16:23:11 <mettekou> merijn: I would really like to generate my Haddock documentation in doc instead of dist/doc, though. Do you know of another way to achieve this?
16:23:45 <glguy> symlink?
16:24:52 <dfeuer> mettekou, submit a patch upstream.
16:25:13 <mettekou> dfeuer: Oh, haha. :P
16:25:57 <mettekou> glguy: I guess that would work nicely without ticking off people who like the defaults.
16:26:03 <dfeuer> mettekou, I wasn't actually joking.
16:26:04 <merijn> dfeuer: Can you proofread https://gist.github.com/merijn/c01405e6c5a78a1c4ccb ?
16:26:22 <dfeuer> merijn, yes, but not right now.
16:26:30 <merijn> dfeuer: ok
16:29:50 <merijn> Anyone else with an interested in hacking GHC, proofread that too :p
16:41:19 <Welkin> merijn: are you using pandoc to convert it?
16:44:00 * hackagebot pipes 4.1.4 - Compositional pipelines  http://hackage.haskell.org/package/pipes-4.1.4 (GabrielGonzalez)
16:44:29 <tranma> \o/ pipes!
16:48:27 <merijn> Welkin: To convert what?
17:01:37 <Gurkenglas> What's the list of packages lambdabot understands?
17:02:03 <yukko> is there a way to make binaries produced by ghc smaller short of using less code?
17:02:25 <yukko> my project has a 40MB binary and it's getting a bit silly
17:03:45 <Welkin> merijn: to convert your guide into html or epub
17:04:04 <Welkin> yukko: what is the problem?
17:04:07 <Welkin> just gzip it
17:04:19 <Welkin> if you are talking about distribution
17:05:27 <yukko> well, it just seems a bit silly to me, that the binary is absolutely huge - can't I get it to use shared libraries or something?
17:05:42 <yukko> we're talking like 1500 lines of code here, tops
17:05:55 <yukko> not something that should be 40MB
17:07:30 <yukko> it's not really a serious problem but I am a bit concerned about it
17:07:43 <mal_> Any quick way to create a massive matrix of ints?
17:09:13 <Gurkenglas> mal_, I hear repeat (repeat 0) is pretty massive
17:11:02 <griotspeak> hello
17:11:07 <Gurkenglas> hello
17:11:29 <Jello_Raptor> hmm
17:11:41 <griotspeak> I am starting Haskell : the craft of functional programming and have an issue in chapter 3
17:11:59 <Gurkenglas> link?
17:12:04 <griotspeak> when I try to run the props for QuickCheck, I receive
17:12:06 <griotspeak> ok
17:12:20 <griotspeak> http://www.haskellcraft.com/craft3e/Home.html
17:12:31 <Zemyla> @pl \x y z -> ((x z) (y z))
17:12:31 <lambdabot> ap
17:13:02 <griotspeak> I receive this error "No instance for (Show (Bool -> Bool -> Bool))"
17:13:06 <mal_> Hmmm. I guess I really want a massive finite matrix of random ints.
17:14:13 <lpaste> griotspeak pasted “printErrorChapter3” at http://lpaste.net/114888
17:14:17 <Zemyla> @pl \x y -> x
17:14:17 <lambdabot> const
17:14:19 <Gurkenglas> Random as in IO-random or simply random enough that there are no obvious patterns for your code to run up against?
17:14:42 <Jello_Raptor> I've got a computation (conversion of a parse tree) that i'm using a state monad for, but certain sub portions of the computation require other state that is gained at the start and lost at the end. I want to use a StateT to store that working set, and wrap it around a State for the truly global data. But I'm not sure how I'd step into and out of such a computation. While still threading the State through the sub computation.
17:15:20 <Gurkenglas> griotspeak, print can't print functions. Did you forget a $ after your print?
17:15:23 <Jello_Raptor> The RWH chapter on monad transofrmers isn't helping with that specific case.
17:15:28 <haasn> :t runStateT
17:15:29 <lambdabot> StateT s m a -> s -> m (a, s)
17:15:29 <haasn> :t lift
17:15:30 <lambdabot> (MonadTrans t, Monad m) => m a -> t m a
17:15:37 <haasn> Those are the two key functions
17:16:00 <griotspeak> i didnt really write much of what is in the function but I will check
17:16:09 <indiagreen> mal_: quickly as in “without much typing” or “CPU-quickly”?
17:16:14 <indiagreen> if the former: replicateM 10 $ replicateM 10 $ randomRIO (1,100)
17:16:27 <indiagreen> s/10/1000/
17:16:49 <indiagreen> if the latter – use some mersenne-twister package, don't remember which already
17:16:55 <Jello_Raptor> ahh, so I'g have to "do { s <- get; (a, ns) <- runStateT subComp s; put ns ; return a } ?
17:17:16 <Gurkenglas> Oh wait. I should have looked more closely at the error. griotspeak, how did you assign a value to "it"?
17:17:29 <Jello_Raptor> and within the subcomp, I can use lift to get to the global state monad.
17:17:33 <Gurkenglas> mal_, <Gurkenglas> Random as in IO-random or simply random enough that there are no obvious patterns for your code to run up against?
17:17:49 <griotspeak> hm
17:17:51 <griotspeak> I didn't
17:18:07 <haasn> Jello_Raptor: If you're getting the stat at the start and setting the state at the end, why are you using a second layer in the first place?
17:18:22 <yukko> you do not need IO to have a good random number generator - the functions that take a seed and give you a random number in System.Random are pure
17:18:22 <haasn> As far as I can tell that's redundant
17:18:33 <Clint> griotspeak: you wrote some quickcheck properties and are trying to test them?
17:18:36 <haasn> :t randoms
17:18:37 <lambdabot> (Random a, RandomGen g) => g -> [a]
17:18:39 <lpaste> griotspeak pasted “Ch3Context” at http://lpaste.net/114891
17:19:01 * hackagebot radian 0.0.3 - A floating-point wrapper for measurements that use radians.  http://hackage.haskell.org/package/radian-0.0.3 (TonyMorris)
17:19:05 <griotspeak> This is an example just before the exercises
17:19:12 <griotspeak> so I didn't write this code
17:19:52 <haasn> :t map randoms . unfoldr (Just . System.Random.split)
17:19:53 <lambdabot> (Random a1, RandomGen a) => a -> [[a1]]
17:20:00 <griotspeak> I am told to run it to see what it outputs but the book doesn't expect it to fail
17:20:16 <Jello_Raptor> haasn: *facepalm* right, that state will just stay in the submonad so it just becomes "do { a <- evalStateT subComp subCompInitialState ; return a }" or
17:20:25 <Welkin> griotspeak: the error is straight forward
17:20:32 <haasn> Jello_Raptor: Sure
17:20:44 <Welkin> griotspeak: it says that it doesn't know how to print a function (Bool -> Bool -> Bool)
17:20:46 <haasn> Also, a caveat that always applies when dealing with State(T): Do you really need it?
17:20:47 <griotspeak> Yeah, on the face of it, I get that I can't print functions. I saw that
17:21:00 <griotspeak> I just don't understand how I am asking it to print a function
17:22:06 <Jello_Raptor> haasn: it's better than storing a few types of working set in the global State that will go unused most of the time and nead to be cleaned out. At least I think so? I'm a novice, and have no handle on proper Haskell code style.
17:22:12 <yukko> haasn what's wrong with State?
17:22:30 <Clint> griotspeak: i think your book might be obsolescent, but the immediate problem is that you aren't applying any arguments to the functions so ghci is trying to print the functions
17:23:00 <griotspeak> heh. well that is awkward. thanks
17:23:10 <Clint> griotspeak: if you did "prop_myNot True" or "prop_myNot False" you would get a different reaction
17:23:20 <haasn> Jello_Raptor: Do you understand how to pass state without using State?
17:23:42 <haasn> yukko: That it often makes code uglier and harder to read/modify/debug/whatever than just passing stuff directly
17:23:58 <haasn> Same caveat applies to Reader instead of just using a function
17:24:12 <griotspeak> Thanks, I
17:24:20 <yukko> I'm not really sure about that, I think it's about as simple as direct recursion
17:24:41 <Jello_Raptor> haasn: yup, basically hand it off as a parameter through function calls. *shudders to recall OCaml in college*
17:25:41 <Clint> griotspeak: and then if you actually want to run the property through quickcheck, you can do "quickCheck prompt_myNot"
17:25:50 <Clint> er
17:25:51 <Clint> prop_
17:26:17 <griotspeak> ah
17:26:36 <griotspeak> That was it.
17:26:46 <griotspeak> Thank you
17:27:00 <griotspeak> All my fault.
17:27:30 <Jello_Raptor> haasn: In this case though, the state is complicated, and managing the threading of state myself seems like it'l make things much more complicated. Especially when the state is one of these complicated Nested record syntax based structures that I'm using lenses to root around in.
17:27:49 <haasn> Fair enough
17:27:53 <haasn> State + lenses is a cute combination
17:27:58 * haasn has some history of abusing that himself
17:32:07 <Jello_Raptor> haasn: oh? how? also I'm planning to add a " Lens' s a -> (a -> a) -> MyMonad a" function that will allow me to use the lens to update inside the state of the state monad. Is there an idiom for this already?
17:32:41 <haasn> Jello_Raptor: Yep, see (%=)
17:32:46 <haasn> :t (%=)
17:32:47 <lambdabot> (MonadState s m, Profunctor p) => Setting p s s a b -> p a b -> m ()
17:33:10 <haasn> Jello_Raptor: Here's an example of lens+state in action: https://github.com/ekmett/lens/blob/master/examples/Pong.hs
17:36:36 <Jello_Raptor> haasn, oh cool, and can I just put that through 'lift' in a subcomp to have it modify the global state monad rather than working set stateT? They should both be instances of MonadState.
17:36:54 <haasn> Jello_Raptor: yep, see also ‘zoom’ fwiw
17:36:56 <haasn> :t zoom
17:36:57 <lambdabot> (Zoom m n s t, Control.Lens.Internal.Zoom.Zoomed n ~ Control.Lens.Internal.Zoom.Zoomed m) => LensLike' (Control.Lens.Internal.Zoom.Zoomed m c) t s -> m c -> n c
17:37:08 <haasn> These type signatures are getting out of hand..
17:37:16 <Jello_Raptor> also the 'profunctor' stuff in that type signature is over my head
17:37:16 <haasn> Basically it lets you zoom in on a sub-state
17:37:20 <Jello_Raptor> mhmm
17:37:25 <vanila> I looked at the Pong example and I think you gain nothing by using Lens in that code
17:37:26 <haasn> You can think of any Profunctor p as (->)
17:37:51 <haasn> So ‘p a b’ is really just (a -> b)
17:37:59 <haasn> But it could also be (i -> a -> b) for indexed stuff
17:38:18 <haasn> That's the only reason the profunctor stuff is in there, really
17:38:22 <Jello_Raptor> ahh
17:38:33 <haasn> (Also something something isomorphisms)
17:38:57 <Jello_Raptor> I think I get it, but I'm not sure I do. Is there something that dissects the typing of Control.Lens for mere humans?
17:39:02 * hackagebot radian 0.0.4 - A floating-point wrapper for measurements that use radians.  http://hackage.haskell.org/package/radian-0.0.4 (TonyMorris)
17:39:04 * hackagebot barecheck 0.2.0.4 - QuickCheck implementations for common types  http://hackage.haskell.org/package/barecheck-0.2.0.4 (OmariNorman)
17:39:05 <haasn> Yep, the lens documentation
17:39:16 <haasn> http://hackage.haskell.org/package/lens-4.6/docs/Control-Lens-Zoom.html#v:zoom
17:39:23 <haasn> Check out the bottom of that doc
17:42:10 <Gurkenglas> http://www.cs.virginia.edu/~wh5a/personal/Transformers.pdf page 4 says "Map.lookup is defined to work within any monad by simply calling the monads fail
17:42:10 <Gurkenglas> function"
17:42:22 <Gurkenglas> :t M.lookup
17:42:23 <lambdabot> Ord k => k -> M.Map k a -> Maybe a
17:42:34 <Gurkenglas> lambdabot apparently says elsewise.
17:43:40 <mmmm> Gurkenglas: That paper is 8 years old
17:44:10 <Gurkenglas> I got there from http://hackage.haskell.org/package/pipes-4.1.4/src/src/Pipes/Tutorial.hs <- "* the paper \"Monad Transformers - Step by Step\","
17:44:26 <vanila> Monad Transformers - Step by Step  is a very good paper
17:44:56 <mmmm> Gurkenglas: http://hackage.haskell.org/package/containers-0.1.0.0/docs/src/Data-Map.html#lookup
17:45:01 <Gurkenglas> Which I looked up because of * hackagebot pipes 4.1.4 - Compositional pipelines  http://hackage.haskell.org/package/pipes-4.1.4 (GabrielGonzalez) and the subsequent \o/ing
17:45:21 <Gurkenglas> So lambdabot is wrong?
17:45:30 <mmmm> No it's a great paper don't get me wrong but there's a few things which have changed
17:45:38 <mmmm> no - that's the version of the library from 2007
17:46:03 <Gurkenglas> fail has fallen out of favor since then, I take it?
17:46:37 <mmmm> using fail is very unidiomatic
17:47:32 <mmmm> for most monads fail = error
17:47:44 <mmmm> as there's not a sensible definition for it
17:48:11 <mmmm> it's much better to explitly handle cases where you might call fail
17:48:21 <yukko> fail defaults to runtime exceptions, and avoiding them is like the entire point of strong static type systems like Haskell's
17:48:28 <yukko> I don't know why it was introduced like that to begin with
17:48:56 <vanila> only some monads h ave a sensible fail, [], Either String and Maybe have it but IO and State and stuff don't..
17:49:03 * hackagebot nagios-check 0.2.0 - Package for writing monitoring plugins  http://hackage.haskell.org/package/nagios-check-0.2.0 (fractalcat)
17:49:04 <vanila> so fail is broken in half the monads
17:49:05 * hackagebot coordinate 0.0.18 - A representation of latitude and longitude  http://hackage.haskell.org/package/coordinate-0.0.18 (TonyMorris)
17:49:25 <vanila> it should be its own typeclass
17:49:29 <vanila> this was a bad design decision and I think they are removing 'fail'
17:51:25 <benzrf> monadplus
17:51:51 <benzrf> yukko: fail is in Monad so that the class can override the behavior of failed pattern matches in do blocks
17:52:21 <benzrf> @undo x:xs <- thing; done
17:52:21 <lambdabot> <unknown>.hs: 1: 6:Parse error: <-
17:52:21 <benzrf> @undo do {x:xs <- thing; done}
17:52:21 <lambdabot> thing >>= \ a -> case a of { x : xs -> done; _ -> fail ""}
17:52:22 <yukko> what does Monad have to do with failed pattern matches?
17:52:32 <vanila> Basically it was a mistake of the past
17:53:01 <shergill> what was the motivation for introducing fail?
17:53:14 <mmmm> failed pattern matches in do notation
17:54:06 <shergill> interesting
18:00:17 <haasn> It's actually still useful for that
18:00:25 <haasn> Not quite as useful as list comprehensions though. List comprehensions are the best thing ever
18:06:16 <Zemyla> Hmm, why is it the V combinator can't be implemented in Haskell?
18:06:27 <benzrf> @undo do {a:xs <- thing; done}
18:06:27 <lambdabot> thing >>= \ b -> case b of { a : xs -> done; _ -> fail ""}
18:06:30 <benzrf> hmm
18:06:37 <benzrf> @undo do {b:xs <- thing; done}
18:06:38 <lambdabot> thing >>= \ a -> case a of { b : xs -> done; _ -> fail ""}
18:06:40 <benzrf> ah
18:06:55 <vanila> Zemyla, what is it?
18:07:07 <mal_> Hmmm. Okay. How can I create a matrix ([[Int]]) that is like 1Kish by 1Kish and filled with random values?
18:07:21 <Zemyla> It's the one from unlambda. `vx = v.
18:07:30 <vanila> ah
18:07:33 <Zemyla> It gives me an infinite type error.
18:07:36 <vanila> yes
18:08:00 <Zemyla> And when I try to construct it from s and k, it gives me the same error.
18:08:13 <vanila> Are you implementing unlambda
18:09:36 <Zemyla> Yeah, I figured I'd give it a try, since its type facility would let me look in on the results of stuff and have a pretty good guess as to what they are.
18:09:56 <vanila> How are you modelling it?
18:11:16 <Zemyla> let i x = x; let k x y = x; let s x y z = ((x z) (y z))
18:11:20 <vanila> oh
18:11:30 <vanila> but haskell is type lambda calculus, and unlambda is untyped
18:11:39 <vanila> so a lot of valid unlambda programs would be rejected
18:11:45 <vanila> so you need to model it using a data type of some kind
18:11:55 <Zemyla> And there's no possible type for v?
18:12:11 <vanila> that's right, just the equation for V requires it have an infinite type
18:12:17 <vanila> but haskell disallows infinite types
18:13:52 <vanila> An idea might be to start with a model of untyped lambda calculus e.g.  data L = L (L -> L)   and then interpret the combinators into it like k = L (\x -> L (\y -> x))
18:14:13 <merijn> vanila: You can get infinite types via newtype wrapping
18:14:34 <merijn> For example, Mu
18:16:11 <merijn> newtype Mu f = Mu { runMu :: f (Mu f) }
18:18:21 <fread2282> is there a library I should use for Vec (List with Nat type level length)?
18:20:56 <trap_exit> is there a way to write a DList out to file without first going through a List ?
18:21:24 <vanila> no
18:22:45 <haasn> merijn: newtype L = L (L -> L) is the same thing
18:22:57 <fread2282> is there any to do open GADTs in haskell?
18:22:58 <haasn> L ≅ L → L is the “type system” underpinning the LC
18:23:01 <haasn> In fact, the fundamental idea
18:23:04 <haasn> Everything is a function
18:23:15 <vanila> fread2282, no but typeclasses may be useful
18:23:19 <vanila> for open worlds
18:25:44 <merijn> fread2282: That's a nonsensical question
18:25:50 <merijn> fread2282: GADTs are closed by definition
18:26:02 <merijn> fread2282: Although you may be looking for data families?
18:26:51 <merijn> trap_exit: No, but the entire point of DList is that converting to List is cheap
18:27:05 <merijn> trap_exit: See http://h2.jaguarpaw.co.uk/posts/demystifying-dlist/
18:27:17 <trap_exit> I am suffering the X Y problem.
18:27:25 <trap_exit> How do I write out a large amount of stremaing data to file?
18:27:33 <trap_exit> I was thinking storing it in a DList, but maybe that is the wrong way to go
18:27:42 <merijn> trap_exit: Pipes/conduits
18:27:56 <merijn> trap_exit: Those are libraries designed for streaming data processing
18:28:47 <prinsen> Is it possible to step over a function call in GHCI?
18:29:00 <merijn> trap_exit: Streaming data from/to files is like the hello world of pipes :p
18:29:04 * hackagebot lens-family-core 1.2.0 - Haskell 98 Lens Families  http://hackage.haskell.org/package/lens-family-core-1.2.0 (RussellOConnor)
18:29:06 * hackagebot lens-family 1.2.0 - Lens Families  http://hackage.haskell.org/package/lens-family-1.2.0 (RussellOConnor)
18:29:10 <prinsen> General: how do I trace down calls to error in my code
18:29:30 <merijn> prinsen: In general: calls to error are extremely hard to track down, so avoid using error
18:29:33 <trap_exit> https://www.haskell.org/haskellwiki/Pipes ?
18:30:09 <merijn> trap_exit: Pretty much, see: http://hackage.haskell.org/package/pipes-4.1.3/docs/Pipes-Tutorial.html
18:30:39 <haskellquestion> i'm having trouble understanding folds. for example, this sample from learn you a haskell: "findKey key = foldr (\(k,v) acc -> if key == k then Just v else acc) Nothing" all folds go through the entire list, right? isn't that a waste if it is found in the first element and the list is thousands of elements long?
18:31:10 <merijn> haskellquestion: You forget that haskell is lazy
18:31:19 <merijn> @src foldr
18:31:19 <lambdabot> foldr f z []     = z
18:31:19 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
18:31:24 <prinsen> merijn: What would you suggest instead?
18:31:47 <prinsen> merijn: I want a trace to point of failure
18:31:51 <merijn> prinsen: If you leave an incomplete pattern, GHC will automatically throw an error that lists the line number
18:31:53 <haskellquestion> well i mean i know it's lazy but still if you were to just type the command findKey "john" phoneBook  into the console would it not go through the entire list?
18:31:56 <fread2282> there was a cool web "laziness visualizer" where you clicked bubbles to "evaluate" thunks some time back, anyone have a link?
18:32:13 <haskellquestion> i'm saying if you don't use pattern matcing
18:32:13 <merijn> haskellquestion: Consider your foldr and the source I just had lambdabot show
18:32:15 <haskellquestion> matching*
18:32:18 <vanila> haskellquestion, it doesn't have to go though the whole list
18:32:20 <merijn> Let's expand it one step
18:32:44 <merijn> "foldr (\(k, v) acc -> if key == k then Just v else acc) Nothing"
18:32:52 <merijn> Rewrite according to definition of foldr and we get
18:33:28 <merijn> Eh, let's pretend I wrote "[1,2]" after that, or something
18:34:10 <prinsen> merijn: As you might know im writing a ECMA interpeter. in several places in the code i call jsThrow typeError. right now typeError = error "typeError". Is there any way to get GHC to give me the stack trace?
18:34:17 <merijn> (\(k, v) acc -> if key == k then Just v else acc) Nothing ((1,'a') : [(2,'b')])
18:34:24 <haskellquestion> wait, merijn did you write lyah? your name is pretty similar to the author
18:34:37 <merijn> No
18:34:41 <haskellquestion> oh ok hehe
18:34:44 <benzrf> haskellquestion: certainly not
18:34:52 <benzrf> haskellquestion: the authors nick is BONUS
18:34:57 <merijn> Then if we apply the lambda
18:35:05 <benzrf> miran merijn <- no
18:35:38 <merijn> "if key == 1 then Just v else (foldr {-lambda here -} Nothing [(2,'b')])"
18:35:54 <merijn> See how the recursive foldr call has been moved into the else clause?
18:36:06 <merijn> We never need to evaluate it if "key == 1"
18:36:34 <haskellquestion> ok give me a couple minutes to read that all over
18:36:54 <merijn> prinsen: GHC can generate stack traces, but I've never tried and it's a bit tricky still
18:37:12 <merijn> prinsen: Wouldn't you want your own stack trace, rather than a haskell stack trace, though?
18:37:13 <haasn> FSVO “stack”
18:37:30 <merijn> haskellquestion: I made some typos in that, but the large picture still holds
18:37:42 <haskellquestion> where's the typo?
18:37:49 <numberten> anyone know where I can find the implementation of ToJSON a => ToJSON (Maybe a)
18:38:03 <fread2282> is there any way to generalize the pattern where a function takes a helper function a -> b and also has a variant a -> Just b that returns Nothing iff the helper does?
18:38:28 <merijn> fread2282: Something along the lines of maybe?
18:38:29 <merijn> :t maybe
18:38:30 <lambdabot> b -> (a -> b) -> Maybe a -> b
18:38:42 <numberten> found it http://hackage.haskell.org/package/aeson-0.1.0.0/docs/src/Data-Aeson-Types.html :)
18:38:53 <fread2282> so f :: (a -> b) -> Foo a b -> Foo a b        and  f' :: (a -> Maybe b) -> Foo a b -> Maybe (Foo a b)
18:38:58 <merijn> haskellquestion: I added "Nothing" to the expansion of foldr
18:39:13 <merijn> haskellquestion: Nothing should only have gone into the recursive call :)
18:39:29 <fread2282> merijn: I don't think that will work
18:39:56 <merijn> fread2282: That looks to specific to exist
18:40:12 <merijn> fread2282: Unless "Foo a" is Traversable, then you can use
18:40:13 <merijn> :t forM
18:40:14 <lambdabot> Monad m => [a] -> (a -> m b) -> m [b]
18:40:17 <merijn> eh
18:40:19 <merijn> :t T.forM
18:40:20 <lambdabot> (Traversable t, Monad m) => t a -> (a -> m b) -> m (t b)
18:40:33 <merijn> Actually, no
18:40:34 <nobody__> hi, have any Haskellers considered what the result of a set-theoretic basis for computing would be (in contrast to Haskell)?
18:40:35 <merijn> Still not
18:40:50 <nobody__> [in contrast to Haskell and its category theory basis]
18:41:02 <merijn> nobody__: Haskell doesn't have a category theory basis
18:41:06 <fread2282> merijn: it is, but f needs more context than Traversable gives
18:41:13 <merijn> nobody__: There's some CT concepts that were stolen after the fact
18:41:17 <nobody__> not basis rather but influence
18:41:18 <vanila> nobody__, I don't think sets are good for computation
18:41:23 <nobody__> https://www.cl.cam.ac.uk/techreports/UCAM-CL-TR-271.pdf
18:41:24 <merijn> nobody__: Haskell's basis is System F_omega
18:41:36 <haskellquestion> merijn: ok i looked over all the code but i'm still not convinced.. sorry lol. i know it would work that way with pattern matching but assuming you just typed "findKey "betty" phoneBook" into the console wouldn't it need to go through the entire list? unless there is some sort of compiler bias towards fetching you a value instead of a Nothing..
18:41:39 <nobody__> yes, CT may not be the basis but it has exerted a huge influence
18:41:47 <merijn> nobody__: Which is a rather traditional lambda calculus on the lambda cube axis
18:41:51 <merijn> nobody__: I disagree
18:41:54 <nobody__> and has “saved Haskell’s ass” so to speak
18:42:17 <merijn> nobody__: People overstate the importance of CT
18:42:20 <nobody__> if it weren’t for monads and their ilk Haskell would have died an untimely death
18:42:26 <MP2E> diagree
18:42:26 <merijn> nobody__: Why did it safe haskell's ass?
18:42:29 <MP2E> disagree*
18:42:34 <nobody__> IO
18:42:39 <merijn> nobody__: So?
18:42:39 <MP2E> IO does not need monads
18:42:46 <merijn> nobody__: Monads were added after Haskell 1.4
18:42:51 <nobody__> nope, but it has them and Haskell has them
18:42:53 <benzrf> indeed
18:42:56 <Zer000> hey guys how can I split a long expression into multiple lines?
18:42:58 <merijn> nobody__: Also, there's uniqueness types
18:43:06 <merijn> nobody__: Clean is purely functional using uniqueness types
18:43:07 <vanila> Zer000, you can just use newlines but careful to get the indentation right
18:43:08 <benzrf> although to be fair IO blew before that afaik
18:43:14 <vanila> paste the code if you'd like hepl
18:43:19 <merijn> benzrf: Sure, but monads are not even the only solution
18:43:39 <nobody__> yes, but since they have been introduced, many related concepts have also been brought in
18:43:41 <merijn> haskellquestion: Why would it need to go through the entire list?
18:43:46 <merijn> "many"
18:43:47 <nobody__> and now they are leaking into other “mainstream” languages
18:43:49 <benzrf> merijn: yeah
18:43:53 <merijn> You mean 2 or so?
18:44:00 <nobody__> all of typeclassopedia
18:44:02 <nobody__> like 15 or so
18:44:03 <merijn> We've got Functor and what? Category? That's barely used
18:44:07 <prinsen> merijn: To much code to modify
18:44:07 <haskellquestion> merijn: because foldr goes through the entire list and if we're not pattern matching it doesn't know what value it needs to stop for
18:44:29 <merijn> haskellquestion: "foldr goes through the entire list" <- why do you believe this?
18:44:37 <cdk> haskellquestion: here's a simpler example of foldr short-circuiting: all = foldr (&&) True :: [Bool] -> Bool. This function will only evaluate the list until it reaches a False, or the end of the list.
18:44:41 <merijn> haskellquestion: You seem to have the wrong intuition. By default haskell does nothing
18:44:42 <dibblego> haskellquestion: foldr does not "go through the entire list"  it does constructor replacement http://functionaltalks.org/2013/06/19/tony-morris-explain-list-folds-to-yourself/
18:44:50 <haskellquestion> ahh so many dings i must really be ignorant lol
18:44:56 <merijn> haskellquestion: Pattern matching is what forces evaluation to happen
18:45:22 <nobody__> anyway, would there be any benefit to bringing in some Set Theory ?
18:45:29 <nobody__> [see: https://www.cl.cam.ac.uk/techreports/UCAM-CL-TR-271.pdf]
18:45:39 <dibblego> the expression (foldr f z list) will replace every occurrence of (:) with (f) and any occurrence of [] with (z) in (list)
18:45:46 <vanila> nobody__, i don't think so
18:45:53 <merijn> haskellquestion: When you try to pattern match the result of foldr it will try to evaluate "f x (foldr f z xs)"
18:46:02 <merijn> haskellquestion: Where 'x' is the first list item
18:46:14 <haskellquestion> ok well i'm just talking about the example when you're in ghci and type something like 'findKey "betty" phoneBook' how would it know to stop at a value as opposed to a Nothing?
18:46:21 <merijn> haskellquestion: Now, what does 'f x (foldr f z xs)' do? It tries to inspect the result of 'f'
18:46:39 <merijn> haskellquestion: You only have to inspect the recursive call IFF 'f' inspects it
18:47:13 <nobody__> vanila: why not?
18:47:15 <merijn> haskellquestion: Since the 'f' in findKey only inspects the recursive argument if the first element is NOT the key, the recursion is only evaluated when it needs to be (i.e. the key doesn't match)
18:47:34 <vanila> sets don't have good computational structure
18:47:46 <merijn> nobody__: If you accept argument from authority it's because according to Harper Homotopy Type Theory subsumes both Set and type theory
18:48:45 <merijn> haskellquestion: It doesn't need to "know" when to stop, the lambda inside findKey decides when to stop/continue
18:49:03 <haskellquestion> ok let me think about this one sec..
18:49:14 <Zemyla> So I'm trying to figure out monads.
18:49:22 <merijn> haskellquestion: Try the following
18:49:29 <benzrf> Zemyla: they're just collapsable functors!
18:49:33 <merijn> haskellquestion: Write out the source for foldr and findKey
18:49:51 <nobody__> merijn: do you think that means that future mathematicians will gravitate to HoTT (and the other disciplines will wane as the old guard dies off)?
18:50:03 <merijn> haskellquestion: Grab a piece of paper, and manually rewrite the left handside with the right hand side repeatedly
18:50:08 <yukko> enabling shared libraries in cabal made my executable 500KB, down from 40MB...
18:50:10 <merijn> nobody__: Probably not
18:50:14 <yukko> pretty cool
18:50:25 <Zemyla> Yeah, I'm having a bit of a time with monads because my functional programming background is mostly in Scheme, and then Perl.
18:50:26 <merijn> yukko: You still need to ship all the libraries if you want it to work...
18:50:35 <vanila> > 100*(40*1024*1024)/(500*1024)
18:50:36 <lambdabot>  8192.0
18:50:38 <numberten> does anyone know the rule for the (Maybe a) implementation of parseJson that returns Just (Nothing)
18:50:45 <vanila> 8000% better
18:50:49 <merijn> Zemyla: Standard advice: "don't learn monads"
18:51:20 <Zemyla> Don't I need to if I'm going to use, for instance, any kind of IO?
18:51:21 <merijn> Zemyla: Learn typeclasses, play around/use different implementations of the Monad class (i.e., Maybe, Either a, State s, (,) e, Reader)
18:51:28 <nobody__> merijn: that’s a shame. standardization should be achievable. But then again Hilbert’s system & Gödel’s encodings didn’t become ubiquitous either
18:51:46 <vanila> Zemyla, it's not hard to do IO, you just use do notation like this:   do print "X" ; print "Y" ; x <- readLine ; print x
18:51:48 <vanila> stuff like that
18:51:51 <vanila> you don't need to know any math
18:51:52 <merijn> nobody__: Name one mathematical discipline that has ever successfully died out after a new basis for math :)
18:52:18 <simpson> merijn: Naive set theory?
18:52:23 <merijn> Zemyla: My point is "monads are just two function with a set of simple laws" there is nothing more to learn than that
18:52:28 <Welkin> merijn: New Math
18:52:38 <merijn> Zemyla: And that doesn't actually tell you all that much
18:52:50 <merijn> Zemyla: What does tell you a lot is seeing how different instances behave
18:52:50 <numberten> null it seems :)
18:53:00 <Zemyla> Yeah, I'm currently at the "monads are like burritos" stage, and it doesn't really help me that much.
18:53:03 <merijn> Zemyla: Therefore, your focus should be on studying instances and their behaviour
18:53:16 <nobody__> Zemyla: probably best to think of Monad as an interface
18:53:21 <merijn> Zemyla: There's only one monad tutorial worth reading
18:53:26 <dibblego> Zemyla: I recommend not using any metaphors, whether playful or serious, when studying this subject.
18:53:31 <merijn> @google you could've invented monads and maybe you already have
18:53:33 <lambdabot> http://blog.sigfpe.com/2006/08/you-could-have-invented-monads-and.html
18:53:33 <lambdabot> Title: A Neighborhood of Infinity: You Could Have Invented Monads! (And Maybe You Al...
18:53:45 <Welkin> just learn how to use `>>=`
18:53:50 <merijn> That and Wadler's original "Monads for Functional Programming" paper
18:53:55 <merijn> Which is very readable
18:53:57 <Welkin> and how do-notation de-sugars to >>=
18:54:08 <merijn> Anyway
18:54:11 * merijn &
18:55:59 <nobody__> lambdabot: who created your logic?
18:57:11 <Welkin> nobody__: https://github.com/mokus0/lambdabot
18:57:33 <nobody__> Welkin: ahh, thx!
18:58:07 <benzrf> Zemyla: learn join, not bind
18:58:14 <benzrf> Zemyla: bind is really just fmap and join in one
18:58:19 <benzrf> join is the part you wanna know about
18:58:36 <benzrf> it's the monoid operation ppl talk about when they say that monads are monoids in a category of endofunctors
18:58:53 <benzrf> not that you have to know what that means :-)
18:59:05 * hackagebot barecheck 0.2.0.6 - QuickCheck implementations for common types  http://hackage.haskell.org/package/barecheck-0.2.0.6 (OmariNorman)
19:00:11 <isocliff> nobody__: I believe its this one that is used here, actually https://github.com/int-e/lambdabot
19:02:16 <Zemyla> So let me see if I've got this correct.
19:03:11 <Zemyla> Imagine I'm trying to write a function that parses a packet into two integers, a string, and another integer.
19:04:09 * hackagebot rainbow 0.20.0.4 - Print text to terminal with colors and effects  http://hackage.haskell.org/package/rainbow-0.20.0.4 (OmariNorman)
19:04:10 * hackagebot rainbow-tests 0.20.0.4 - Tests and QuickCheck generators to accompany rainbow.  http://hackage.haskell.org/package/rainbow-tests-0.20.0.4 (OmariNorman)
19:04:28 <Zemyla> I basically have a Parse a = (a, String) that contains what was taken off the front of the packet and what was left afterwards.
19:04:49 <Zemyla> So parseInt '50300 Silly' would become (50300, 'Silly').
19:04:53 <HeladoDeBrownie> Zemyla, consider if the parse fails
19:05:05 <Zemyla> Well, yeah, if the parse fails, it would return Nothing, like a maybe.
19:05:12 <HeladoDeBrownie> Good
19:05:17 <HeladoDeBrownie> So the type must change
19:05:33 <haskellquestion> huh, so foldr starts from the left? that's kinda confusing
19:06:04 <dibblego> haskellquestion: No, it doesn't start anywhere. It does constructor replacement. The video above answers all of these questions.
19:06:10 <HeladoDeBrownie> haskellquestion, it depends on what you mean by "starts from the left". The simple way to explain foldr f x, however, is to say it replaces (:) with f and [] with x.
19:06:17 <Zemyla> And then all the parsed things get appended together in a tuple (and of course it returns nothing if there's still something left).
19:06:20 <haskellquestion> well i just mean this:
19:06:36 <Zemyla> foldr is called foldr because it's right-associative.
19:06:42 <nobody__> dibblego: videos are low density information transfer
19:07:00 <dibblego> nobody__: the video is a comprehensive explanation of the facts at hand
19:07:02 <Zemyla> foldr (/) [1,2,3] is 1 / (2 / 3).
19:07:15 <Zemyla> Or thereabouts.
19:07:15 <haskellquestion> findKey key ((k,v):xs) = if key == k then Just v else findKey key xs    AND    phoneBook = [("betty","555-2938"),("bonnie","452-2928"),("betty","867-5309")    WITH findKey "betty" phoneBook will return "555-2938"
19:07:36 <haskellquestion> based on the name foldr one would intuitively assume it would give 867-5309
19:07:42 <nobody__> dibblego: maybe so but nobody wants to waste minutes of their life watching something that they could read instaed
19:07:57 <nobody__> [and i say that as ‘nobody’]
19:08:01 <dibblego> ugh
19:08:21 <dibblego> this material, along with appropriate instruction, provides a comprehensive understanding of foldr https://github.com/NICTA/course
19:08:37 <Zemyla> But yeah, so the parser result is just a monad, right?
19:08:39 <Zer000> so I made haskell generate some equations, I want to take this list and print one equation per line on my console, but I can't figure out how to keep calling putStrLn (no loops!)
19:08:45 <Zer000> should I just make a giant string?
19:08:51 <haskellquestion> no i understand now i just thought that was kinda weird
19:08:59 <vanila> loop = do thing ; loop
19:09:04 <HeladoDeBrownie> Zemyla, there is a Monad instance for Maybe. That only matters if you use the Monad methods with it though.
19:09:22 <vanila> or mapM print equations
19:09:28 <HeladoDeBrownie> Zemyla, there are also Monad instances for many common parser types.
19:09:41 <Zemyla> I mean since it passes the remaining string of the packet all the way to the end.
19:10:01 <HeladoDeBrownie> Zemyla, that sounds kind of vague, but just from that description I wouldn't assume Monad was involved.
19:10:01 <Zer000> vanila, so mapM would iterate? over IO actions and execute them?
19:10:11 <cdk> haskellquestion: It's not possible to traverse a standard haskell list "from the right". That's clear from the definition of []: data [] a = [] | a : [a]
19:10:12 <vanila> yeah
19:10:29 <Zer000> vanila, cool, thanks. btw in your first example what does the naked "loop" word do?
19:10:44 <Zer000> oh it's part of the do notation?
19:10:45 <vanila> it does 'thing' over and over again
19:10:46 <cdk> haskellquestion: association of the reducing operation is much more natural way to think of it.
19:10:50 <dibblego> > head $ foldr (:) [] [1..] -- if this "started at the right", it would not terminate
19:10:52 <lambdabot>  1
19:11:18 <gcganley> are there any multi-monitor xmonad users here?
19:11:27 <hiptobecubic> gcganley, indeed there are
19:11:32 <dibblego> gcganley: Yes.
19:11:58 <gcganley> ok my xrandr.sh script which runs when i run i3 and works fine there doesnt work for xmonad
19:12:15 <HeladoDeBrownie> Zemyla, what I want to get at is basically: Don't fixate too much on Monad. If it makes for a natural solution to your problem, fine, but it's not the end-all of solutions to problems.
19:12:15 <gcganley> it only runs xrandr with the correct parems
19:12:25 <hiptobecubic> gcganley, that's not a very useful description of the problem
19:12:37 <Zemyla> Okay, then.
19:12:43 <hiptobecubic> gcganley, where is the script, what do you expect it to do, what does it actually do?
19:12:52 <gcganley> ok, i try to run xrandr and the screen goes blank and then comes back
19:13:13 <gcganley> ill get the script on gist one sec
19:13:30 <haskellquestion> anyone have a link to that laziness visualizer that was being discussed earlier?
19:14:11 <Zemyla> Anyways, are characters in Haskell Unicode, or bytes?
19:14:24 <rola> nobody__, http://www.andrew.cmu.edu/user/awodey/preprints/stcsFinal.pdf
19:14:29 <reeelkkkip_> i'd like to make a program that detects if a user is a  nigger then the program won't work
19:14:35 <reeelkkkip_> just to give them a taste of their own medicine
19:14:47 <HeladoDeBrownie> Zemyla, Char represents Unicode code points.
19:14:51 <reeelkkkip_> is it possible to make a program like that?
19:14:51 --- mode: ChanServ set +o dibblego
19:14:54 --- mode: dibblego set +b *!*42b075c0@*.66.176.117.192
19:15:00 --- kick: reeelkkkip_ was kicked by dibblego (reeelkkkip_)
19:15:01 <HeladoDeBrownie> Zemyla, for proper Unicode support, see the Text type in Data.Text.
19:15:29 <nobody__> roja: thx!
19:15:33 <gcganley> ok it was my fault i checked my screen names and they changed :/
19:15:40 <gcganley> sorry
19:15:57 <Zemyla> Okay, so an array of bytes is not the same as a string.
19:16:00 <hiptobecubic> gcganley, :)
19:16:01 <HeladoDeBrownie> Zemyla, correct.
19:16:06 <numberten> is there a fn :: Word64 -> Int64 ? it seems like there would be, but no luck with hoogle
19:16:37 <HeladoDeBrownie> Zemyla, if an array of bytes is what you want, Data.ByteString might interest you.
19:17:15 <gcganley> hiptobecubic: are there any extenstion/configuration must haves? im new to tiling wm for the most part
19:17:51 <Zemyla> Well, I would be reading an array of bytes from the network socket, and converting them to (say) little-endian int32s.
19:18:01 <gcganley> @hoogle Word64 -> Int64
19:18:03 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
19:18:03 <lambdabot> Control.OldException throwDyn :: Typeable exception => exception -> b
19:18:03 <lambdabot> Control.DeepSeq ($!!) :: NFData a => (a -> b) -> a -> b
19:18:05 <hiptobecubic> gcganley, xmonad-contrib is pretty huge. I would probably just search github for xmonad.hs files
19:18:57 <haskellquestion> what is the word he keeps saying in that fold vimeo video someone linked? conta list? cont list?
19:19:07 <hiptobecubic> gcganley, and try things out if they sound interesting. It's kind of like vim, your config grows around you and other people's won't fit right
19:20:16 <haskellquestion> oh probably cons list
19:20:20 <Gentmen> I'm working on Typeclassopedia's exercises. Can you please give me a hint for making a Functor that satisfies the second law, but *not* the first?
19:23:26 <roconnor> Gentmen: IIRC one of those two cases is impossible.
19:23:56 <roconnor> I forget which one is impossible though.
19:24:33 <kadoban> Presumably not the one they ask you to do in the exercises :)
19:24:51 <roconnor> heh
19:24:54 <roconnor> good point
19:25:52 <gcganley> hiptobecubic: are the configuration files just a lot of combinators strung together? is there a tutorial you would recomend?
19:26:59 <hiptobecubic> gcganley, the configuration file *is* xmonad
19:27:46 <kadoban> Gentmen: I'm no expert, but think about a type where if you do something twice, it's the same as doing it once...but not the same as doing it never. If that makes any sense.
19:28:06 <hiptobecubic> gcganley, XMonad itself is pretty much just a library and your config is a haskell program that uses it
19:28:26 <kadoban> Gentmen: Since it's just an excercise, keep in mind that it doesn't have to be useful or sane, it just has to technically true.
19:29:05 <Gentmen> :kaboban - thanks. let me think about that
19:30:08 <Zemyla> @pl \f x -> f (f x)
19:30:08 <lambdabot> join (.)
19:30:41 <gcganley> :t join
19:30:42 <lambdabot> Monad m => m (m a) -> m a
19:30:53 <gcganley> :t join (.)
19:30:54 <lambdabot> (c -> c) -> c -> c
19:31:01 <Zemyla> :t .
19:31:02 <lambdabot> parse error on input ‘.’
19:31:05 <Zemyla> :t (.)
19:31:06 <lambdabot> (b -> c) -> (a -> b) -> a -> c
19:32:37 <Zemyla> @pl \x -> (sin x) + (cos x)
19:32:37 <lambdabot> liftM2 (+) sin cos
19:32:57 <numberten> if you have a bunch of functions that you want to combine with >> and they all take some shared initial value, like foo a b c s = a s >> b s >> c s
19:33:02 <gcganley> :t liftM2
19:33:03 <lambdabot> Monad m => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
19:33:04 <numberten> is there a good way to factor out the s?
19:33:10 <gcganley> :t sin
19:33:12 <lambdabot> Floating a => a -> a
19:33:12 <abhillman> Hi! Supposing I have some variable. I can get its type by running ":t varName" -- is there a way to know which typeclasses a variable or a variable's type implements
19:35:14 <kadoban> Gentmen: Another hint: there's a relatively straightforward way to make an evil Functor instance for Maybe that satisfies that excerise, if narrowing it down helps. (You'd have to make your own copy of Maybe with a different name to actually implement it of course)
19:44:27 <solidworks> hey
19:44:55 <solidworks> could someone help me with a ftp
19:46:08 <solidworks> looking for ftp help
19:46:31 <vanila> solidworks, what is the problem?
19:47:10 <solidworks> no problem just unable to get acces to an ftp site
19:47:30 <solidworks> you up to the task?
19:48:11 <kadoban> Not that #haskell is very strict on topic, but...is that a haskell question at all, or just in general?
19:49:05 <lpaste> hiptobecubic pasted “Bad https POST with http-client-tls” at http://lpaste.net/114895
19:49:52 <hiptobecubic> Can anyone see why I'm getting a borked pipe there? The request works fine in Postman and python
19:52:34 <leonguan> Hey!!guys I am new here
19:52:53 <kadoban> Welcome
19:54:10 * hackagebot diophantine 0.2.1.0 - A quadratic diophantine equation solving library.  http://hackage.haskell.org/package/diophantine-0.2.1.0 (joejev)
19:55:31 <hiptobecubic> I assume it's because the other end closes the connection prematurely, but I don't understand why
19:56:56 <wyager> Is there a standardized message-passing protocol? Right now I’m sending data over TCP, but I’d rather not deal with sending message lengths and such before sending the data itself
19:57:27 <xcthulhu> ZMQ is an option
19:57:28 <simpson> wyager: There are several such protocols.
19:57:45 <simpson> wyager: When you say "message passing" are you talking about messages between objects, or just strings?
19:57:47 <marchelzo_> What is the best library if I want to solve sudoku puzzles in parallell? Like I have ps :: [Puzzle] and I want to map solve ps, and have them solved concurrently. I know there are several options, not sure which is the best for sucha a simple case.
19:57:55 <wyager> simpson: What are a few for which there exist implementations in many languages, including Haskell? Also, just ByteStrings.
19:58:25 <wyager> I’m serializing with Messagepack already, so I don’t need to worry about objects
19:58:31 <simpson> wyager: Length-prefixed strings, netstrings, bencoding.
19:58:47 <simpson> Oh, I was asking about whether you needed something like AMP, or perhaps CapTP.
19:59:10 * hackagebot google-drive 0.2.0 - Google Drive API access  http://hackage.haskell.org/package/google-drive-0.2.0 (PatrickBrisbin)
19:59:18 <hiptobecubic> marchelzo_, http://hackage.haskell.org/package/parallel-3.1.0.1/docs/Control-Parallel-Strategies.html
19:59:19 <wyager> I just need to send strings between machines, reasonably quickly
19:59:32 <simpson> wyager: bencoding or netstrings.
19:59:34 <marchelzo_> hiptobecubic: thanks
20:00:07 <vanila> wyager, you could use UDP
20:00:25 <wyager> vanila: Looking for something more abstracted than UDP or TCP
20:00:34 <wyager> I don’t want to have to deal with length encodings or whatever
20:00:44 <simpson> wyager: Use TCP.
20:00:51 <vanila> you don't have to deal with length
20:00:53 <wyager> Simpson: I still have to send the length
20:00:53 <marchelzo_> hiptobecubic: do I need to compile with special flags to get concurrency?
20:00:55 <wyager> Yes, I do
20:00:55 <vanila> just let a TCP library do it
20:01:07 <simpson> wyager: http://en.wikipedia.org/wiki/Netstring
20:01:15 <vanila> Why do you?
20:01:16 <simpson> wyager: netstrings include length.
20:01:21 <wyager> otherwise how am I supposed to read the correct length bytestring for using the Serialize and/or Binary library?
20:01:28 <wyager> Thanks, simpson. Looking at it
20:01:47 <wyager> There is not good support for deserializing from a handle with Cereal or Binary
20:02:00 <simpson> vanila: Always assume, when using TCP, that you will send and receive exactly one byte at a time.
20:02:02 <wyager> (That’s directed @ vanila )
20:02:19 <simpson> Always assume, when using UDP, that you will not receive any packets and that every outgoing packet is dropped by your kernel.
20:02:50 <hiptobecubic> marchelzo_, yes.https://www.haskell.org/haskellwiki/Parallelism
20:02:51 <vanila> that makes UDP sound bad
20:03:17 <simpson> vanila: Yes, UDP is usually not the right choice.
20:03:22 <kadoban> Also assume with UDP that any packets you do receive will be out of order
20:04:10 * hackagebot geodetic 0.1.4 - Geodetic calculations  http://hackage.haskell.org/package/geodetic-0.1.4 (TonyMorris)
20:04:14 <wyager> Simpson: I don’t think the Haskell bencode or netstrings library actually deal with sending or receiving data. I want a library that exposes something like (ByteString -> IO ()) and (IO (Maybe ByteString))
20:04:29 <wyager> Someone mentioned ZMQ. That looks like what I want
20:04:30 <kadoban> Using UDP often results in horrible reliability, and/or reimplementing many parts of TCP...badly.
20:04:36 <simpson> wyager: Oh! Well, I wasn't gonna presume that I knew anything about your actual transport situation.
20:04:51 <simpson> ZMQ is often *not* what you want, but who am I to tell you what you want?
20:05:15 <wyager> simpson: I just want something that keeps a persistent connection between hosts and *exposes functionality to send or recieve an entire message*
20:05:33 <wyager> Ideally including features like keep-alive and timeout
20:05:35 <hiptobecubic> that sounds exactly like zmq doesn it?
20:05:37 <hiptobecubic> doesn't*
20:06:01 <vanila> could anyone just give me a hint about how TCP doesn't solve that?
20:06:10 <Gentmen> dibblego: hi - I liked your typelevel talk at lambdajam. is there currently a "winner" in the type-level versus extempore fork? (if I'm off-topic and it's inappropriate, I'll stop talking scala here)
20:06:11 <simpson> wyager: So you want a TCP client and TCP server.
20:06:18 <wyager> Vanila: Because you can’t send and receive arbitrary-length chunked messages over TCP
20:06:21 <wyager> it does nothing of the sort
20:06:36 <wyager> TCP exposes a stream interface
20:06:47 <simpson> conduit and pipe libraries both have stuff for setting up the servers, and there's cereal and binary instances for ByteString...
20:06:56 <dibblego> Gentmen: I did not do a talk on typelevel. I recommend against using anything related to typelevel. The Scalaz project has no affiliation to typelevel (I am aware of claims to the contrary  they are false).
20:07:06 <wyager> I don’t want a stream interface, I want a message interface
20:07:24 <dibblego> Gentmen: I did a talk on Scalaz though.
20:07:33 <hiptobecubic> I'm sure this is an easy problem, I just don't know enough about http-client to know what's going on here. It works with curl :/
20:07:36 <wyager> hiptobecubic: Yes, ZMQ might be the right thing
20:07:56 <vanila> I guess I don't understand, sorry
20:08:04 <Gentmen> :dibblego my mistake for mixing them up, sorry. I was there in person - your type parametricity presentation (I read) was educational as well
20:08:14 <geekosaur> you need an additional layer over TP to implement a concept of distinct messages
20:08:20 <wyager> vanila: If you had to send a bunch of messages over TCP, where the mesages had indeterminate lengths, how would you do it?
20:08:21 <dibblego> Gentmen: do you mean in Chicago, or Brisbane?
20:08:24 <geekosaur> *TCP
20:08:26 <wyager> geekosaur: Precisely
20:08:29 <Gentmen> :dibblego chicago
20:09:16 <dibblego> Gentmen: unfortunately, the Scalaz project has suffered some major problems since that time. However, they are currently being addressed.
20:09:20 <vanila> wyager, I would either write the length of the message then the binary data, or escape the contents and end it with a special stop character
20:09:24 <geekosaur> and mau need multiple reads to collect an entire message; a given sent "chunk" is not necessarilyreceived as a single distinct "chunk", it may be spread over multiple packets (read() returns) or multiple consecutive messqges may be received in a single read()
20:09:39 <dibblego> Gentmen: I did a talk specifically on Parametricity at LambdaJam, Brisbane.
20:09:50 <wyager> vanila: Yes, I did the message length thing. That is annoying to deal with. It also doesn’t make it easy to do things like keep-alive and timeout
20:10:13 <Gentmen> dibblego: Ah. I read the powerpoint slides - I didn't know what type parametricity was until I read it
20:10:23 <Gentmen> :dibblego *slides
20:10:27 <wyager> It’s easy to timeout the entire connection, and it’s easy to timeout individual sub-parts of the connection, but the first isn’t good for big transfers and the second isn’t good for persistent connections
20:10:36 <wyager> The second one is also slow
20:10:41 <geekosaur> and yes, you lose control of retransmission/detecting that a message was lost/etc.
20:11:12 <geekosaur> which is why NFS was UDP only for so long; it took a while for networks to become reliable enought hat TCP's retries didn't completely murder NFS throughput
20:11:46 <geekosaur> especially with large packets (NFS using 4K originally)
20:12:18 <dibblego> Gentmen: many people believe that parametricity is an essential property of software development. Without it, the limitations are unacceptable.
20:13:22 <geekosaur> another example of TCP not being appropriate is streaming media; it's better to drop a frame than to freeze the stream while TCP retransmits
20:13:29 <Gentmen> dibblego: your talk (and FP in general) has influnced me. I work in a 70% java/ 30% scala code-base. Recently had an argument with a co-worker to use an enum over String - thought about your example where a String input means an exponential # of inputs - restrictions are good, i.e. types - as I interpretted
20:13:31 <simpson> Especially when multicasting.
20:14:09 <dibblego> Gentmen: right, you will encounter an argument that e.g. the type (a -> a) is "more complicated" than (Int -> Int)  when in fact, the opposite is true
20:14:27 <marchelzo_> hiptobecubic: sorry if this is a stupid question, but how do I know how many threads I should specify when I run the binary? One thread per puzzle that I'm solving, or?
20:14:48 <dibblego> Gentmen: I work on software teams that wouldn't work at all if that belief were continued to be held. The software we write would be impossible.
20:14:59 <wyager> I misread dibblego’s comments and thought he kept addressing us as “Gentlemen”
20:15:12 <Gentmen> dibblego: why? is correctness a strong requirement/necessity of your type of SW?
20:15:41 <dibblego> Gentmen: not more than anyone else, but code readability and maintainability is a requirement
20:15:47 <hiptobecubic> marchelzo_, for a problem like this one you probably want to do round robin with as many cores as you have
20:16:00 <hiptobecubic> marchelzo_, maybe chunked instead of 1 by 1
20:16:08 <dibblego> Gentmen: specifically, the ability to build larger programs from smaller ones, then repeat higher and higher is a requirement and without parametricity, this is impossible.
20:16:34 <marchelzo_> hiptobecubic: heh, how do I do that? All I did was I compiled with -threaded and ran with +RTS -N8
20:17:11 <Gentmen> dibblego: that particular property, building large systems without fear of changes breaking them, was echoed loud and clear (I heard) from Don Stewart in this excellent interview - https://www.youtube.com/watch?v=4YfkwfZ7AV4
20:17:51 <marchelzo_> ah, didn't see the part about -Nn saying n should be # of cores on your machine
20:19:32 <marchelzo_> and does this work for making sure they are evaluted in parallel: withStrategy (evalList rpar) (map solveSudoku puzzles)?
20:20:05 <bananagram> :t (/)
20:20:05 <lambdabot> Fractional a => a -> a -> a
20:21:16 <marchelzo_> ok, it worked. finished already. That whole procecess plus the time to run it and it still finished before the non-parallel one :) thanks hiptobecubic
20:21:23 <hiptobecubic> marchelzo_, if you leave the number off it will automagically take the number of cores on your machine
20:21:36 <marchelzo_> hiptobecubic: oh, that's good to know. thanks
20:21:53 <hiptobecubic> there's also "numCapabilities" to figure it out in-program
20:22:03 <hiptobecubic> I don't remember where that is though, so search for it on hoogle
20:33:00 <Zer000> I want my show function to be polymorphic, but I also want it to truncate floating points to a few decimal places. I am using fromInteger in my isInt function and it forces show to have a RealFrac context
20:38:57 <trap_exit> is there something like haskell-src-exts ... but also doing type inference?
20:39:07 <trap_exit> i.e. I want something that can parse *.hs files and also do type inference on the *.hs file
20:59:18 <Pamelloes> I have an algebraic data type with five different types. Each type is an [Int] followed by varying other parts. Is there a way to easily pattern match against all five data types to get the [Int]?
20:59:56 <jle`> do you mean five different constructors?
21:00:00 <dibblego> Pamelloes: I think you mean, a data type with five different constructors, each with a [Int]?
21:00:09 <Pamelloes> Yes, I meant constructors
21:00:17 <Pamelloes> Sorry about my terminology :/
21:00:20 <dibblego> you could remove the [Int] from each constructor, then pair that data type with a [Int]
21:00:32 <Pamelloes> ...
21:00:47 <Pamelloes> I can't believe I never thought of that
21:00:57 <dibblego> data T = X A [Int] | Y B [Int] | Z C [Int] can be refactored to data T = X A | Y B | Z C then ([Int], T)
21:01:32 <jle`> or even data TI = TI T [Int]
21:01:54 <Pamelloes> or type TI ([Int],T)
21:02:05 <Pamelloes> *TI=([Int],T)
21:02:37 <Pamelloes> Would it be better to define a new type or rename a tuple?
21:04:53 <HeladoDeBrownie> Pamelloes, one thing to consider is a trade off between verbosity and descriptivity. If you think it's descriptive enough, go for the tuple. Otherwise, you could use fields to make it descriptive: type T' = T' { foo :: [Int], bar :: T } (where obviously foo and bar should instead be something *actually* descriptive :)
21:05:03 <HeladoDeBrownie> descriptiveness*
21:05:22 <HeladoDeBrownie> s/type/data/
21:05:54 <HeladoDeBrownie> Those aren't the only options but either one would be reasonable
21:06:21 <HeladoDeBrownie> dibblego, do you know your op hat is still on?
21:06:32 <dibblego> HeladoDeBrownie:
21:06:33 <dibblego> thanks
21:06:37 --- mode: dibblego set -o dibblego
21:06:58 <Pamelloes> HeladoDeBrownie: Thanks! That actually helps a lot.
21:07:14 <HeladoDeBrownie> No problem
21:07:21 <jle`> Pamelloes: btw, this hints at why they are called Algebraic Data Types :)
21:07:36 <jle`> by doig this you are taking advantage of maths
21:07:49 <Pamelloes> I am?
21:07:50 <jle`> if you think of different constructors as +, and two fields on the same constructor as *
21:08:09 <jle`> you could think of T = (A*[Int]) + (B*[Int]) + (C*[Int])
21:08:22 <jle`> but we know from maths that multiplication distributes over addition
21:08:25 <jle`> so we can "refactor" that
21:08:31 <jle`> to be T = (A + B + C)*[Int]
21:08:46 <Pamelloes> Ah, I see!
21:09:07 <pharpend___> How's everyone doing?
21:09:11 <jle`> math is power!
21:09:32 <Pamelloes> Though as far as I am aware, (which really isn't that far) there isn't a nice syntax for such a refactor.
21:09:32 <jle`> that's how i am doing.
21:09:38 <Pamelloes> Woo, math!
21:09:49 <jle`> Pamelloes: basically, you're calling T = A + B + C
21:09:54 <jle`> so TI = T * [Int]
21:10:05 <jle`> which is equivalent to the original formulation
21:10:31 <Pamelloes> Right. But that takes two lines and I prefer one line to two.
21:10:35 <Pamelloes> As a matter of course.
21:10:41 <jle`> ah, yes
21:15:07 <Pamelloes> Is there a way to refer to a tuple of an arbitrary length?
21:15:23 <Axman6> depends what you mean by refer
21:15:49 <carter> i all it an array
21:15:53 <carter> * call
21:16:05 <carter> or a static sized het list
21:16:05 <Axman6> that's not a tuple
21:16:11 <Axman6> that is
21:16:16 <carter> same diff
21:16:31 <carter> my static sized het lists totally use an array
21:16:38 <carter> or could
21:16:42 <carter> would make it faster
21:16:45 <carter> should do that
21:16:54 <carter> or sequence
21:16:55 <carter> or whatever
21:17:09 <Pamelloes> On second thought, that wasn't what I meant to ask. Is it possible to refer to any function that evaluates an arbitrary amount of inputs of a to b?
21:17:25 <carter> ....
21:17:29 <Axman6> like a .. a ->  b?
21:17:37 <Pamelloes> I was thinking of varying inputs as varying tuples, but then I realized I was making it too complicated
21:17:41 <carter> [a] -> b
21:17:43 <Axman6> where the number of a's is arbitrary?
21:17:46 <Pamelloes> yeah
21:17:49 <carter> [a] -> b
21:17:56 <Axman6> sounds like a list to me too
21:18:09 <carter> or Vector a -> b
21:18:12 <carter> or Sequence a -> b
21:18:20 <carter> latter two only work for finite sequences
21:18:27 <Pamelloes> So if I have function 1  (a->b) and a function 2 (a->a->b), can I make a type that includes both functions?
21:18:37 <carter> KINDA
21:19:17 <Pamelloes> Basically, I have a bunch of functions of the type (a->a->b) where the amount of 'a's varies, and it would be really useful to refer to them collectively
21:19:33 <carter> Pamelloes: thats called a type class :)
21:19:44 <Axman6> Pamelloes: what do the functions do?
21:19:47 <carter> that too
21:19:49 <Axman6> is there some pattern?
21:19:51 <carter> Axman6: printf
21:19:54 <carter> obvs :)
21:20:00 <carter> :t printF
21:20:01 <lambdabot>     Not in scope: ‘printF’
21:20:01 <lambdabot>     Perhaps you meant one of these:
21:20:01 <lambdabot>       ‘print’ (imported from Prelude),
21:20:02 <carter> :t printf
21:20:03 <lambdabot> PrintfType r => String -> r
21:20:26 <carter> printf fits the billl
21:20:57 <Axman6> I'm not sure it does...
21:21:00 <Pamelloes> Well, the functions are actually of type (a->a) and (a->a->a), etc. and I want to be able to nest them in a tree-like fashion.
21:21:09 <carter> merijn: nest how
21:21:12 <carter> woops
21:21:19 <carter> on tha tnote
21:21:20 <carter> night all
21:21:27 <Pamelloes> night!
21:21:47 <kadoban> Pamelloes: What do the functions do? And what would nesting them in a tree mean?
21:23:39 <Pamelloes> The functions perform various basic transformations (such as addition, subtraction, etc.) I'm trying to create more complicated transformations by nesting simpler ones.
21:23:39 <haasn> ([a] -> a) can be useful
21:24:12 <Pamelloes> This could easily be accomplished by function composition, but I'm trying to abstract it to work with an arbitrary combination determined from a file
21:25:50 <carter> Pamelloes: you want an AST
21:26:02 <Pamelloes> What's that?
21:26:05 <carter> @google  AST
21:26:07 <lambdabot> http://www.ast.org/
21:26:07 <lambdabot> Title: Association of Surgical Technologists
21:26:11 <carter> @google  AST comptuer science
21:26:12 <lambdabot> http://en.wikipedia.org/wiki/AST
21:26:12 <lambdabot> Title: AST - Wikipedia, the free encyclopedia
21:26:29 <carter> @google cartesian closed category data type
21:26:31 <lambdabot> http://www.cse.chalmers.se/~peterd/papers/Philadelphia2008.pdf
21:26:31 <lambdabot> Title: The Interpretation of Intuitionistic Type Theory in Locally Cartesian Closed ...
21:26:37 <carter> erp
21:26:51 <Pamelloes> Abstract syntax tree?
21:29:40 <carter> yes
21:29:42 <lpaste> hiptobecubic annotated “Bad https POST with http-client-tls” with “Bad https POST with http-client-tls (annotation)” at http://lpaste.net/114895#a114900
21:29:50 <hiptobecubic> Another try, same error.
21:31:00 <hiptobecubic> What I don't understand is why it works with curl. If it were the remote end hanging up early you'd expect every client to suffer. Instead, curl gets an in-band "You made an invalid request" response
21:37:15 <Zemyla> How much evaluation does GHC do at compile time?
21:38:34 <c_wraith> Zemyla: basically none.
21:39:03 <Zemyla> Even though it knows the difference between pure functions and ones with side effects?
21:39:20 <jle`> Zemyla: it's hard to predict how long it'll take an evaluation to take
21:39:28 <jle`> there's a famous problem in theoretical computer science about it
21:39:42 <Lutin> In a sense the evaluation is at compile time and execution is what happens at run-time
21:39:45 <HeladoDeBrownie> Evaluation can also diverge, and people don't like it when compilation takes infinite amounts of time
21:39:53 <jle`> @google halting problem
21:39:53 <lambdabot> http://en.wikipedia.org/wiki/Halting_problem
21:39:53 <lambdabot> Title: Halting problem - Wikipedia, the free encyclopedia
21:40:01 <Zemyla> Is there a flag you can use to try and evaluate everything at compile time?
21:40:04 <c_wraith> people are so picky about compilation taking infinite time
21:40:12 <Lutin> But in some cause as HeladoDeBrownie mentioned there's a tradeoff
21:40:58 <Lutin> s/cause/case/
21:41:26 <vanila> Zemyla, There's a different compiler called Supero which evaluates as much as it can at compile time
21:41:53 <vanila> Zemyla, it studies the code carefully and tries to work things out about it so it knows which parts it can evalute and which to leave alone
21:43:09 <Zemyla> So if I had, for instance, a function called compileBrainfuck that was String->String->String, and said maybe inc = compileBrainfuck ",+.", would it turn inc into the corresponding function?
21:43:12 <jle`> yeah, you really can't try to evaluate everything
21:43:32 <jle`> Zemyla: what if the string contained a brainfuck program that never terminated?
21:43:40 <jle`> er
21:43:47 <jle`> wait, that's not what i meant :)
21:44:06 <vanila> Zemyla, it would be possible for a compile to optimize away the interpretation step
21:44:14 <vanila> compiler*
21:44:15 <vanila> by inlining
21:44:19 <vanila> but I doubt GHC does this
21:44:21 <jle`> you can't in general "evaluate everything", though
21:44:33 <jle`> what about something like myVar = 1 + myVar
21:44:35 <vanila> one thing you can do is write this at the top levle so the evaluation is done once at runtime
21:44:42 <Pamelloes> If you inline everything, can
21:44:43 <vanila> and then the result will be reused after that
21:44:49 <Pamelloes> t't that lead to an exponential growth in program size?
21:45:21 <Lutin> It would inline the interpretation, not necessary the evaluation of the BF program
21:46:47 <Lutin> I do wonder what the maximum evaluation depth would be
21:47:08 <Lutin> Most likely same as stack size
21:49:44 <Lutin> I probably shouldn't comment much, not very knowledgeable in GHC internals
21:50:25 <Pamelloes> I'm pretty sure evaluation depth is infinite.
21:51:17 <Lutin> Ideally, but we don't have infinite resources :)
21:52:36 <Welkin> there is a finite amount of matter in the universe
21:52:44 <Welkin> but there could be an infinite number of universes
21:53:27 <Pamelloes> Ultimately, there is some limit on evaluation depth. But the limit is a function of RAM and not a function of stack size.
21:53:39 <Zer000> Can someone please look at this program I wrote? It's supposed to print different equations but it prints the same one a bunch of times before going to the next one. It also complains about a stack space overflow and I don't know what that is
21:54:01 <Pamelloes> Which means, for all intensive purposes, there is no easily determinable maximum level of evaluation.
21:54:04 <Welkin> that's ironic
21:54:15 * hackagebot prefix-units 0.1.0.2 - A basic library for SI/binary prefix units  http://hackage.haskell.org/package/prefix-units-0.1.0.2 (IustinPop)
21:54:16 * hackagebot yesod 1.4.1 - Creation of type-safe, RESTful web applications.  http://hackage.haskell.org/package/yesod-1.4.1 (MichaelSnoyman)
21:54:18 * hackagebot yesod-form 1.4.1.1 - Form handling support for Yesod Web Framework  http://hackage.haskell.org/package/yesod-form-1.4.1.1 (MichaelSnoyman)
21:54:21 <vanila> intensive purposes?
21:54:21 <Welkin> Zer000: you are probably building up too many thunks
21:55:31 <Zer000> Welkin, hmm ok. Is it possible to have a memory leak of thunks?
21:55:38 <Pamelloes> hat awkward moment when you evaluate "foldr (\x y->x+y) 0 [1,2..10000000000]" to test for maximum evaluation level.
21:55:47 <Welkin> Zer000: yes
21:55:57 <Pamelloes> It won't stop :/
21:56:10 <Lutin> Pamelloes: Well that's a time-bound process
21:56:19 <Hijiri> what about nonintensive purposes?
21:56:27 <jle`> vanila: only intensive purposes.  purposes that aren't intense don't apply
21:56:38 <Welkin> "for all intents and purposes" is what Pamelloes meant, I assume
21:56:53 <Pamelloes> my computer is crashing...
21:57:00 <Welkin> Ctrl + C
21:57:02 <Pamelloes> I seem to have run out of ram
21:57:05 <Welkin> or Ctrl + X
21:57:09 <Pamelloes> ctrl+c wasn't working
21:57:36 <Zer000> holy shit I never posted a link! http://lpaste.net/114901
21:57:51 <Hijiri> sometimes I get ram issues
21:57:55 <Pamelloes> My computer just allocated swap, so I'm doing fine now.
21:58:05 <Hijiri> for some reason my computer won't use swap
21:58:05 <jle`> Zer000: what version of GHC are you using?
21:58:15 <Lutin> Do you have it setup? :P
21:58:19 <Hijiri> yes
21:58:22 <Hijiri> it's 2% filled
21:58:34 <Hijiri> but it stays more or less that level even when I run out of ram
21:58:42 <Zer000> jle`, 7.6.3
21:58:50 <Welkin> can functions begin with a "_"?
21:58:54 <Welkin> I thought they could not
21:59:10 <jle`> Welkin: one way to find out :D
21:59:18 <int-e> > let _a = 32 in _a
21:59:19 <lambdabot>  32
21:59:28 <jle`> Zer000: ah.  7.8+ releases the "stack" limit
22:00:02 <Welkin> Zer000: use the convention showResults instead of show_results for function naming
22:00:07 <jle`> Welkin: variables that start with _ are actually treated specially by the compiler and hlint, etc.
22:00:13 <jle`> with respect to warnings
22:00:21 <Zer000> jle`, i'm not worried about the stack thing as much as I am about duplicate output. Like I said the desired output is a different function on every line. I spent a few hours trying to debug (btw how do you even debug without print statements!?)
22:00:41 <jle`> it'll suppress "variable/function named but not used" warnings
22:00:47 <Pamelloes> Looks like the maximum recursion level is somewhere between 1000000 and 10000000000 levels. For my computer...
22:01:14 <Welkin> Zer000: use Debug.trace
22:01:53 <Lutin> jle`: Ah, using our own stack now?
22:02:10 <jle`> hm?
22:02:25 <Lutin> In regards to releasing the stack space limit
22:02:33 <Lutin> It's in heap now?
22:03:42 <jle`> oh
22:03:47 <jle`> it was never on the actual hardware stack
22:03:59 <jle`> i don't think it was...
22:04:05 <Zer000> Welkin, looks like print statements are back on the menu. Yesss
22:04:15 <Welkin> it's on a stack in a parallel universe
22:04:21 <Lutin> Yeah I could that that being prohibitive
22:04:24 <Welkin> it communicates with the system using gravity
22:05:53 <Welkin> that was just absurb earlier when firefox was using over 5 GB of memory
22:05:57 <Welkin> I only have 4 GB
22:06:01 <Welkin> it must have been using swap too
22:06:19 <Welkin> I guess leaving it running for a few weeks might do that
22:06:28 <Welkin> absurd*
22:12:44 <zomg> Gilgameshkun: at work we do all sorts of crazy things with editing styles live, as long as you're doing something that makes sense it generally works :P
22:12:47 <zomg> errrr
22:12:55 <zomg> so much for jumping between windows in tmux...
22:12:56 <zomg> lol
22:15:48 <NemesisD> anyone have experience with the machines library?
22:16:54 <trap_exit> is there something like haskell-src-exts ... but also does type checking?
22:19:15 * hackagebot persistent-mongoDB 2.1.2 - Backend for the persistent library using mongoDB.  http://hackage.haskell.org/package/persistent-mongoDB-2.1.2 (MichaelSnoyman)
22:21:28 <Zer000> omw my error was a + where a minus should be. I had to double check every single equation
22:39:26 <Zer000> "Use `+RTS -Ksize -RTS' to increase it." how exactly do I use it?
22:42:03 <jle`> Zer000: is using ghc 7.8 an option
22:42:05 <jle`> ?
22:43:31 <Zer000> jle`, I'm on Ubuntu, how do I get it?
22:44:00 <Welkin> 14.04? 14.10?
22:44:19 <Welkin> I don't know if ghc 7.8 is in the apt repo
22:44:48 <Zer000> 14.10
22:45:27 <Welkin> check the ubuntu repo
22:45:32 <Welkin> see what is available
22:46:19 <Welkin> if not, you can get the generic linux binary for debian 7 from the haskell platform site
22:46:32 <Welkin> also check the ghc website
22:47:19 <Lutin> ccheck out http://haskell-lang.org
22:47:26 <jle`> Zer000: just download it from the ghc website and run the install :)
22:47:31 <jle`> the binary
22:47:33 <Lutin> would paste the full length but for some reason an app is taking up my entire screen
22:47:52 <Zer000> ok! thanks
22:48:28 <Lutin> http://haskell-lang.org/downloads/linux
22:49:03 <Zer000> thanks for that
22:49:46 <jle`> Zer000: if you upgrade then the behavior specified by the flags is default
22:50:05 <jle`> so it's not really a "fix", but it pushes the problem off for later :)
22:50:35 <Zer000> right. suppose I do this and my little program just eats all my ram, it's supposed to be cpu bound so what should I look for?
22:52:02 <Welkin> does anyone know of a good/easy/reliable way to convert from traditional chinese to simplified?
22:52:41 <Welkin> the crappy converter on mac only lets you convert 1024 characters at a time -- who the hell set *that* arbitrary limit?
22:56:14 <jle`> Zer000: hard to tell without looking at code :)
23:01:50 <Zemyla> Huh, I managed to utterly kill my Haskell interpreter.
23:04:00 <relrod> 0/5
23:04:03 <relrod> grr
23:06:57 <Zemyla> Typing 'unsafeCoerce "115t"' in ghci brings it down with an internal error.
23:07:14 <jle`> well...can't say it didn't warn you
23:07:25 <glguy> What did you expect it to do?
23:07:40 <jle`> it's almost as if it's unsafe ;)
23:07:56 <Lutin> Even I'm not sure what "115t" should coerce to
23:08:13 <glguy> You can also kill GHCi by unplugging your computer
23:08:13 <jle`> i think from defaulting rules it tries to coerce it into ()
23:08:26 <Lutin> Yeah sounds about right
23:11:32 <Zemyla> Well, yes, but it shouldn't crash the interpreter.
23:12:48 <Zemyla> Do you know what stg_ap_v_ret is?
23:15:27 <vanila> unsafeCoerce should crash the interpreter
23:16:35 <pavonia> Well, not always
23:16:52 <Lutin> It's what happens when you try to unsafeCoerce a non-bottom value to something determined to be bottom
23:17:11 <Lutin> which is what b must be in `unsafeCoerce :: String -> b`
23:17:28 <Zemyla> Yes, but shouldn't something catch that error before it brings the whole thing down?
23:19:16 <Lutin> ghc-7.4.1 used to return `runTimeError "Impossible case alternative"`
23:19:39 <vanila> Zemyla, no
23:19:47 <dhrosa> that's why it's unsafe
23:19:53 <vanila> it's similar to a NULL pointer derefence in C or something
23:20:00 <vanila> it breaks type safety so it's totally bad
23:20:42 <Lutin> Possibly it could return a runTimeError and still 'crash' in the sense that it would quit unrecoverably
23:20:55 <Lutin> But unsafeCoerce isn't meant to be friendly
23:21:59 <vanila> any program that uses unsafeCoerce should also have a rigorous justification that the use is safe
23:25:05 <Lutin> and in most cases it should be reserved for cases where the problem cannot be solved in -any- other way
23:26:05 <Cale> Zemyla: Types only exist at compile time in Haskell.
23:35:06 <Ralith> Zemyla: why should something catch an error when you've promised that there will never be an error?
23:35:56 <Zemyla> True.
23:36:21 <Zemyla> I suppose I shouldn't be surprised.
23:37:22 <droidboi> ! Just (+3) <*> Just 2 == Just 5
23:37:44 <vanila> > Just (+3) <*> Just 2
23:37:46 <lambdabot>  Just 5
23:38:34 <droidboi> >  Just (+3) <*> Just 2
23:38:36 <lambdabot>  Just 5
23:38:54 <droidboi> >  Just (+3) <*> Just 2 == Just 5
23:38:55 <lambdabot>  Precedence parsing error
23:38:56 <lambdabot>      cannot mix ‘Control.Applicative.<*>’ [infixl 4] and ‘GHC.Classes.==’ [in...
23:39:16 <droidboi> > (Just (+3) <*> Just 2) == Just 5
23:39:17 <lambdabot>  True
23:39:18 * hackagebot linear 1.15.3 - Linear Algebra  http://hackage.haskell.org/package/linear-1.15.3 (EdwardKmett)
23:40:32 <droidboi> Why does "Just (+3) <*> Just 2 == Just 5" without brackets give an error? Shouldn't left-associativity apply and it just work?
23:41:09 <rola> which brakets
23:41:24 <numberten> is there a cabal build command for making static executables
23:41:34 <droidboi> here (Just (+3) <*> Just 2 and here) == Just 5
23:41:44 <droidboi> > (Just (+3) <*> Just 2) == Just 5
23:41:46 <lambdabot>  True
23:41:55 <droidboi> > Just (+3) <*> Just 2 == Just 5
23:41:56 <lambdabot>  Precedence parsing error
23:41:56 <lambdabot>      cannot mix ‘Control.Applicative.<*>’ [infixl 4] and ‘GHC.Classes.==’ [in...
23:41:56 <rola> :i (<*>)
23:42:33 <Zemyla> :t (<*>)
23:42:34 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
23:42:44 <Lutin> What happened to :i
23:42:49 <Lutin> :info (<*>)
23:42:52 <rola> infixl 4 <*>
23:42:54 <Lutin> huh
23:43:04 <rola> infix 4 ==
23:43:11 <Lutin> yep
23:43:47 <droidboi> Lutin: Are you saying "Yep", as in you think it should work?
23:43:58 <Lutin> No it shouldn't
23:44:32 <Lutin> I mean maybe if the precedences were different, but not currently
23:46:36 <Lutin> Even though only one of the associations makes sense
23:47:52 <Haskellfant> What are some example use cases for arrows (apart from using the tuple stuff on normal functions)? I don't see them used very much
23:48:11 <Zemyla> :t ->
23:48:12 <lambdabot> parse error on input ‘->’
23:48:17 <Zemyla> :t (->)
23:48:18 <lambdabot> parse error on input ‘->’
23:48:41 <Lutin> (->) is a type constructor not a data constructor
23:48:44 <Lutin> :k (->)
23:48:45 <lambdabot> * -> * -> *
23:48:47 <Haskellfant> :i (->)
23:49:48 <droidboi> Lutin: I think I get it. Even though only one association makes sense, it's not going to assume anything
23:49:50 <Lutin> @info (==)
23:49:50 <lambdabot> (==)
23:49:55 <Lutin> hmm
23:50:02 <Lutin> I don't remember what it was or if it was removed
23:50:13 <droidboi> > Just 5 == Just (+3) <*> Just 2
23:50:14 <lambdabot>  Precedence parsing error
23:50:14 <lambdabot>      cannot mix ‘GHC.Classes.==’ [infix 4] and ‘Control.Applicative.<*>’ [inf...
23:50:20 <droidboi> exactly
23:51:41 <droidboi> it not going to assume (Just 5 == Just (+3)) <*> Just 2
23:51:51 <droidboi> which makes no sense anyway
23:52:00 <Lutin> infix association happens before types are taken into account
23:53:35 <droidboi> Lutin: Are you quoting from somewhere?
23:53:56 <droidboi> Like the Haskell report
23:53:59 <Lutin> I could probably find one if you'd like
23:54:17 <droidboi> No need
23:54:52 <droidboi> A bit beyond what I was after at the moment. I think I know enough for now thanks
23:56:27 <Lutin> It's more just that parsing happens before type related things
23:56:35 <droidboi> It's just that I don't fully understand what "infix association happens before types are taken into account"
23:56:51 <droidboi> Lutin: :o) OK
23:58:42 <Lutin> If you want the nitty gritty of what the expression parsing is:
23:58:52 <droidboi> this is a case of "same precedence", with an "infix" and an "infixl"
23:58:56 <Lutin> and that was a fail paste
23:59:15 <Lutin> more just same precendence
23:59:19 * hackagebot wai-throttler 0.1.0.3 - Wai middleware for request throttling  http://hackage.haskell.org/package/wai-throttler-0.1.0.3 (mkulkin)
23:59:51 <Lutin> It's also a side effect of only having 10 precendence values
