00:05:55 <calvinx> `cabal update` followed by `cabal install cabal-install` solves the problem.
00:06:45 <calvinx> at least on my mac. repeating this on linux - let’s hope that works too.
00:09:14 <calvinx> nope. no luck. same error
00:10:40 <calvinx> I think I will try with haskell-platform
00:10:45 * hackagebot jobqueue 0.1.4 - A job queue library  http://hackage.haskell.org/package/jobqueue-0.1.4 (ikehara)
00:10:45 * hackagebot rethinkdb-client-driver 0.0.7 - Client driver for RethinkDB  http://hackage.haskell.org/package/rethinkdb-client-driver-0.0.7 (wereHamster)
00:20:41 * hackagebot tkhs 0.3.0 - Simple Presentation Utility  http://hackage.haskell.org/package/tkhs-0.3.0 (YusakuHashimoto)
00:25:18 <dmbaturin> Is there a quick way to view all inferred type signatures in a module?
00:25:31 <Fuuzetsu> :browse Module.Name
00:26:16 <dmbaturin> Thanks!
00:26:56 <sgronblo> Did anyone try that haskforce thing for Intellij?
00:27:17 <Fuuzetsu> I made a thing a while back which inserts missing type signatures but I forgot what happened to it and even what editor it was for
00:29:14 <sgronblo> haskforce does that too apparently http://carymrobbins.github.io/intellij-haskforce/
00:29:55 <Fuuzetsu> well, that was more of a remark regarding the :browse thing
00:34:49 <Phillemann> sgronblo: I've been using it for about 2 weeks now. It works pretty well. What I miss most is the lack of automatic indentation.
00:35:47 <Fuuzetsu> That alone would make me abandon it
00:35:58 <pharpend_> speaking of indentation, y'all should try hindent
00:36:00 <pharpend_> it's awesome
00:36:45 <pharpend_> https://github.com/chrisdone/hindent
00:37:11 <Phillemann> Currently, I'm using just stylish-haskell, but that just indents import statements.
00:37:47 <pharpend_> hindent makes your code pretty
00:37:53 <pharpend_> and takes like 90% of the indentation work away
00:38:02 <pharpend_> you just have to write a valid AST, and it pretty-prints it
00:38:07 <pharpend_> there are still bugs being worked out
00:38:23 <pharpend_> but I use it (and contribute). I highly recommend it
00:38:58 <sgronblo> Phillemann: ah interesting. i wish i had the opportunity to try it too. what does the indentation do? does it keep the indentation or go to the first column on a new line?
00:39:37 <sgronblo> I'm not so keen on using vim for static languages
00:39:53 <sgronblo> its ok for dynamic because theres not a lot of automatic checking you can do anyway
00:40:28 <sivteck> for vim, this mostly works https://github.com/raichoo/haskell-vim
00:40:34 <kadoban> syntastic makes that nice in vim for me, that and neocomplete are pretty nice
00:40:36 <Phillemann> sgronblo: I'm not sure what it does. Sometimes it keeps the indentation ;)
00:40:39 <xtreak> I defined a function let errorFunction a b c = a ++ b + c . But  a list can't be added to a number right? If the function is valid how can I use it ?
00:41:52 <Phillemann> pharpend_: hindent-0.9 gives me a compilation error. Is it buildable with ghc-7.6?
00:41:57 <hyPiRion> ah, the magics of Num
00:42:11 <sgronblo> yeah it can be "nice" in vim, but nowadays i'd rather emulate vim keybindings in a real IDE than try to make vim act as a real IDE.
00:42:17 <hyPiRion> :t (\a b c -> a ++ b + c)
00:42:18 <lambdabot> Num [a] => [a] -> [a] -> [a] -> [a]
00:42:26 <sgronblo> there are too many manual things to mess around with to make vim work well as an IDE
00:42:29 <pharpend_> Phillemann: i doubt it. 0.9 is ancient. The current version is 3.9.1
00:42:42 <kadoban> sgronblo: I used to try to do that, but then you end up learning a new IDE for every language, and it's crap.
00:43:08 <hyPiRion> xtreak: The problem here is that Num is a typeclass (+ is implemented for both doubles and ints, for example), and so you can hypothetically implement it for lists
00:43:08 <kadoban> Never found an IDE that worked well for much more than one language
00:43:32 <hyPiRion> xtreak: of course that probably makes no sense, but that's why it typechecks.
00:43:37 <pharpend_> Phillemann: the lead developer is a bit too lenient with dependency constraints IMO
00:44:20 <pharpend_> Phillemann: would you post the error you are getting
00:45:19 <raichoo> sgronblo: Hopefully neovim will change that.
00:46:24 <xtreak> hyPiRion : So this function is of no use but hypothetically these functions can exist?
00:46:47 <tdammers> making vim emulate an IDE is stupid
00:46:53 <tdammers> it's not an IDE, it's a text editor
00:46:58 <tdammers> if you want an IDE, use an IDE
00:47:01 <tdammers> if you want vim, use vim
00:47:09 <pharpend_> is leksah dead nowadays?
00:47:13 <pharpend_> I can never get it to compile
00:47:28 <pharpend_> there's also that editor written in haskell
00:47:33 <tdammers> yi?
00:47:36 <pharpend_> yeah
00:47:38 <pharpend_> yi
00:47:58 <kadoban> tdammers: Define "making vim emulate an IDE"? I don't see what's wrong with using nice plugins in vim myself. *shrug*
00:48:07 <sgronblo> kadoban: Intellij seems to work for most of the languages I have to care about for the moment
00:48:34 <raichoo> kadoban: +1
00:48:45 <tdammers> well... being language-aware, for exmaple, is not vim's strong suit
00:48:54 <sgronblo> tdammers: I think you will find many people attempting to use vim as an IDE
00:49:01 <sgronblo> anyway where do you draw the line?
00:49:03 <tdammers> sgronblo: I know, and I don't get that
00:49:04 <sgronblo> project.vim?
00:49:16 <tdammers> much earlier, really
00:49:22 <kadoban> sgronblo: Is it me or does that not support haskell?
00:49:23 <tdammers> ftplugin, tag files, that's about all I use
00:49:29 <sgronblo> which plugins can you add before you are considered as using vim like an IDE
00:50:14 <tdammers> nothing else has bothered me enough to become a problem worth solving yet
00:50:21 <hyPiRion> xtreak: Unless you have implemented + for lists (that doesn't seem to happen), it is of no use. So yes, they can exist hypothetically, which is why it typechecks.
00:50:42 * hackagebot battlenet 0.1.0.0 - API client for Battle.Net  http://hackage.haskell.org/package/battlenet-0.1.0.0 (teozkr)
00:50:54 <sgronblo> tdammers: you dont want automatic syntax checking in your editor?
00:51:08 <tdammers> sgronblo: not desperately enough
00:51:33 <kadoban> What's desperate about adding a simple-to-use plugin?
00:52:04 <sgronblo> tdammers: did you work in eclipse or intellij?
00:52:25 <tdammers> sgronblo: I've used VisualStudio, Eclipse, Netbeans...
00:52:35 <tdammers> found them all somewhat horrible
00:52:50 <sgronblo> hmm, why so horrible?
00:53:25 <tdammers> slow, most of all
00:53:46 <tdammers> somewhat obscure, too
00:54:03 <kadoban> visual studio is one of the few things i used to like about windows as a dev environment. Of course I really only used C++ when that was true...
00:54:05 <tdammers> too much IDE-specific magic...
00:54:24 <tdammers> fucking up source control in general
00:54:44 <sgronblo> you dont have to use source control through the IDE
00:54:51 <tdammers> of course not
00:54:52 <sgronblo> i still use git through the command line
00:55:04 <pharpend_> magit is really nice
00:55:07 <shiona> kadoban: I wish someone would come up with a way of creating even closely as efficient go-to-def for anything that runs on linux
00:55:07 <pharpend_> (emacs thing)
00:55:12 <sgronblo> because i cant be bothered to learn how the IDE will present the ui or dumb it down for me
00:55:32 <tdammers> I did enjoy the various refactoring tools for C#
00:55:37 <tdammers> that was kinda nice to have
00:55:58 <kadoban> shiona: Yeah, I don't really have a solution to that one in my toolset, I just kind of learned to do without I guess. Would be nice sometimes though.
00:56:00 <tdammers> but these days, I'm either working in PHP or Python or JS, where automatic refactoring is pretty useless anyway
00:56:09 <tdammers> or I'm using Haskell, where refactoring is moslty a no-brainer
00:56:44 <sgronblo> but there are some things i really want to have when editing a static language, refactoring, quick jump to type, find usages, automatic error checking on the fly with auto correct suggestions, auto generation of code. i find adding all of these to vim to be too much work.
00:56:55 <sgronblo> but adding idea-vim to intellij is just a plugin install away
00:56:55 <shiona> I worked on some graphics firmware for android. It was hell trying to find the functions from the 10G+ source tree
00:57:42 <Phillemann> pharpend_: Interesting, since I just did cabal install hindent. This is the error: http://ideone.com/LS78rq
00:58:10 <pharpend_> Phillemann: run cabal update, and then do that again
00:58:15 <shiona> I was totally baffled that eclipse go-to-def was actually a little better than what vim plugins had to offer, although still taking gigabits of memory and five minutes of freezing for a def search was not really that acceptable
00:58:21 <Phillemann> pharpend_: Already did, same result.
00:58:35 <pharpend_> Phillemann: see https://github.com/chrisdone/hindent/issues/23
00:58:55 <tdammers> re on-the-fly things: I prefer not to sacrifice any snappines
00:59:20 <Welkin> snappyfish!
00:59:26 <pharpend_> Phillemann: try "cabal install "hindent==3.9.1"
01:00:19 <tdammers> I like it how my editor starts up in a matter of milliseconds, and gives me consistent snappiness
01:00:30 <tdammers> I'm willing to sacrifice quite a bit of comfort for that
01:00:37 <tdammers> so yeah
01:01:03 <Phillemann> pharpend_: I think I have to finally update ghc: http://ideone.com/dgvwba
01:01:15 <Phillemann> Which I tried before, but it was kind of a pain here on kubuntu.
01:01:53 <dmbaturin> Phillemann: Perhaps it's easier to update the whole distro to the new version.
01:02:11 <dmbaturin> (Well, unless your is already the latest)
01:02:21 <pharpend_> Phillemann: looks like it
01:02:31 <pharpend_> Phillemann: I'm on Gentoo, I completely understand.
01:03:29 <dmbaturin> pharpend_: Hhm, I'd imagine it should be easy on gentoo, since it's source based and ebuilds usually include bootstrapping procedure.
01:03:43 <sgronblo> tdammers: I only start my IDE like once every few days on average, so I prefer to optimize for other cases
01:03:48 <pharpend_> Phillemann: I used to use Arch Linux, but things would break left and right. With Gentoo, that problem goes away, because nothing works in the first place
01:04:00 <Phillemann> pharpend_: I've used Gentoo for about 5-8 years.
01:04:15 <sgronblo> I also use to keep the same vim session going for a long time
01:04:33 <piskrist> I think it's a little difficult to maintain the haskell packages in gentoo
01:04:38 <pharpend_> dmbaturin: source based package management is just a really bad idea
01:04:42 <piskrist> as lot of things probably need to be bumped together
01:04:49 <Fuuzetsu> obligatory NixOS/nix plug
01:04:55 <pharpend_> dmbaturin: i would switch over to a binary distro, but there aren't any decent binary distros as it stands
01:04:57 <piskrist> not that I have looked into it properly yet
01:05:01 <pharpend_> I haven't had a chance to look into nix
01:05:10 <pharpend_> Gentoo is just a disaster, though
01:05:19 <Fuuzetsu> I moved to NixOS from Gentoo if that helps
01:05:22 <piskrist> pharpend_: your moms a disaster
01:05:31 <pharpend_> piskrist: cancer tends to do that to you
01:05:36 <Fuuzetsu> sick burns everywhere
01:05:38 <Phillemann> I've tried nixos last week
01:05:51 <dmbaturin> I'm on fedora now. Works pretty much fine, and I can't stand current versions of mainstream DEs anyway, so I don't care about gnome3 by default.
01:05:54 <Phillemann> It has absolutely no documentation.
01:06:08 <pharpend_> That would be a dealbreaker for me
01:06:09 <Fuuzetsu> Phillemann: NixOS manual and NixOS wiki?
01:06:17 <pharpend_> I will probably switch back to arch pretty soon
01:06:18 <Phillemann> Fuuzetsu: Yes, I've looked at both.
01:06:22 <pharpend_> because gentoo is driving me nuts
01:06:23 <Fuuzetsu> It is documentation
01:06:36 <Phillemann> Fuuzetsu: Absolutely minimal documentation, in my opinion. :)
01:06:44 <Fuuzetsu> yes, but it is unfair to say there isn't any
01:06:45 <Phillemann> The wiki hats lots of "This needs to be written" in it.
01:06:48 <Fuuzetsu> I agree it's not enough
01:06:59 <dmbaturin> Arguably better than absolutely no documentation.
01:07:02 <Fuuzetsu> the recommended way to go is to ask a ton in #nixos
01:07:16 <Fuuzetsu> at least by my recommendation
01:07:17 <Phillemann> I think a distribution that different from other distributions needs good documentation.
01:07:39 <Fuuzetsu> I often find that things actually are documented, just not easy to find
01:08:59 <Phillemann> I really, _really_ like the concept of nixos though. Reading the original thesis/paper about it, all I could think was "Wow, this solves a _lot_ of problems!"
01:09:08 <Fuuzetsu> Phillemann: by the way if you could post on the mailing list what docs you'd like to see or couldn't find we might be able to fill in the gaps
01:09:19 <Fuuzetsu> we had people do this already, it helps us a lot
01:09:45 <Fuuzetsu> my own first e-mail was basically full of questions ;)
01:10:00 <Phillemann> Fuuzetsu: I still have the VM with nixos and want to explore it further. :)
01:10:23 <Fuuzetsu> Cool, make sure to make noise when you can't find something and maybe something can be arranged
01:10:24 <Phillemann> This is getting pretty off-topic, though.
01:10:32 <Fuuzetsu> I think we're about done ;P
01:10:34 <dmbaturin> What should I read if I want to learn about implementing persistent datastructures?
01:10:34 <Phillemann> Not sure how often this happens here. :>
01:10:44 <Fuuzetsu> It's ok, nix comes up regularly
01:10:52 <Fuuzetsu> whenever someone cries about broken packages at least
01:10:54 <Fuuzetsu> so regularly
01:10:59 <Phillemann> Hehe
01:24:37 <Gatis> Hi
01:24:39 <Gatis> What is haskell?
01:24:46 <mauke> a programming language
01:25:23 <pharpend_> Gatis: Have you ever programmed before? Or did you just stumble on this channel by happenstance?
01:25:30 <Gatis> Yes
01:25:46 <Gatis> I know C#
01:26:06 <pharpend_> Haskell is a bit closer to F# than C#, but nonetheless very different than either one
01:26:23 <Fuuzetsu> they both have a # in the name so it's OK to compare them!
01:26:42 <MP2E> lol
01:26:56 <tdammers> for most people, Haskell is radically different from any programming language they've ever seen
01:26:59 * pharpend_ shakes his head at Fuuzetsu in disapproval
01:27:13 <Fuuzetsu> head.shake()
01:27:15 <haasn> Fuuzetsu: haskell and sk both have sk in their name, so it's OK to compare them too
01:27:24 <Fuuzetsu> yep
01:27:28 <haasn> but comparing haskell and C is just wrong
01:27:37 <Fuuzetsu> correct
01:27:37 <pharpend_> Oh, I thought he was making a joke about the H looking like a #
01:27:55 <Fuuzetsu> no
01:27:58 <mauke> haskell has as in it, which is the assembler
01:28:03 <Gatis> Why you choose haskell
01:28:04 <pharpend_> clearly
01:28:06 <Fuuzetsu> pharpend_: you should start worrying about your fonts
01:28:12 <pharpend_> Fuuzetsu: haha
01:28:50 <pharpend_> Gatis: Haskell is very strongly typed, and doesn't have things like variables or loops, which sounds restrictive, but actually ends up leading to much better code
01:28:50 <mauke> Gatis: I got into it because of pugs, the perl6 interpreter written in haskell (back then)
01:28:55 <ibotty> hello, what's the prefered way to represent kind-tuples _not_ of kind (*,*), but e.g. (Symbol,*)?
01:29:20 <Gatis> mauke, your nickname in my native language is rude word
01:29:27 <mauke> well, "got into" as in "I installed ghc and then failed to compile pugs because ld ran out of memory"
01:29:39 <pharpend_> Gatis: what's your native language? greek?
01:29:45 <Gatis> latvian
01:29:46 <MP2E> I got in to Haskell because I was tired of arbitrary segfaults and writing C code that looked perfect to me and compiled, but then did something entirely different
01:29:51 <ibotty> is there a standard type somewhere (i singletons
01:29:54 <ibotty> i
01:29:57 <woky> Hi, will the list xs be traversed twice in this function? positions x xs = [i (x', i) <- zip xs [0 .. n], x == x'] where n = length xs - 1
01:30:03 <ibotty> i did not find it in singletons...)
01:30:17 <woky> i.e. once by length and once by zip?
01:30:19 <mauke> Gatis: it's also the name of an island, two different diseases, smelly feet, and some kind of soup (the latter all in german)
01:30:22 <haasn> ibotty: What's wrong with '("foo", Bar) ?
01:30:28 <Welkin> woky: the compiler will often optimize your code so it traverses once
01:30:34 * pharpend_ translates mauke from Latvian into English, chuckles
01:30:35 <Fuuzetsu> woky: the best way to find out is to spit out and read Core
01:30:36 <Gatis> mauke, in my language it means prostitute
01:30:43 <mauke> awesome
01:30:43 <AlecTaylor> hi
01:30:47 <woky> Welkin, i see, i was hoping for that answer  =)
01:30:58 * pharpend_ should probably go to bed
01:30:58 <ibotty> haasn: i always get something along the lines of (,) expecting kind (*,*)
01:31:01 <mauke> woky: it'll probably be traversed twice
01:31:04 <Welkin> woky: I don't know under why circumstances that would be untrue though
01:31:08 <ibotty> i can whip up another experiment shortly
01:31:10 <Gatis> Anyway
01:31:16 <woky> i was hoping for some magic to happen TBH
01:31:16 <Welkin> which*
01:31:35 <AlecTaylor> !books
01:31:37 <woky> ... since it's used in so many Haskell examples
01:31:46 <AlecTaylor> Aren't there channel triggers?
01:31:51 * AlecTaylor wants his bots
01:31:53 <pharpend_> AlecTaylor: our bot isn't a supybot
01:31:56 <haasn> ibotty: (,) and '(,) are not the same thing
01:31:56 <mauke> woky: just remove n
01:31:59 <Welkin> for example: map (+3) . filter (<5)
01:32:00 <pharpend_> @@ AlecTaylor @where lyah
01:32:00 <lambdabot>  AlecTaylor http://www.learnyouahaskell.com/
01:32:05 <Welkin> that would traverse once I believe
01:32:13 <Gatis> Who else is bored?
01:32:20 <Welkin> even though it looks like it would run through it twice
01:32:21 <haasn> ibotty: '(,) :: k -> k' -> (k,k')
01:32:23 <AlecTaylor> pharpend_: Hmm
01:32:27 <AlecTaylor> @@ AlecTaylor @where books
01:32:27 <lambdabot>  AlecTaylor See `LYAH',`RWH',`YAHT',`HR',`wikibook',`non-haskell-books'
01:32:30 <ibotty> ic. thanks haasn
01:32:34 <haasn> ibotty: (,) :: * -> * -> *
01:32:38 <pharpend_> @where hr
01:32:38 <lambdabot> "The Haskell Road to Logic, Maths and Programming", by Kees Doets,Jan van Eijck, at <http://homepages.cwi.nl/~jve/HR/>
01:32:38 <AlecTaylor> @@ AlecTaylor @where RWH
01:32:38 <lambdabot>  AlecTaylor http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
01:32:39 <woky> mauke, oh, good point thanks, this is actually example from Paul Graham's book which bothered me (runtime complexity-wise)
01:32:46 <pharpend_> @where yahr
01:32:46 <lambdabot> I know nothing about yahr.
01:32:51 <pharpend_> @where yaht
01:32:51 <lambdabot> "Yet Another Haskell Tutorial", Hal Daume III,<http://www.cs.utah.edu/~hal/htut/>,<http://en.wikibooks.org/wiki/Haskell/YAHT>,<http://hal3.name/docs/daume02yaht.p(df|s)>,<http://darcs.haskell.org/yaht/yaht.p(df|s)>
01:32:52 <ibotty> i thought it was clear from context that i meant the kind.
01:32:59 <ibotty> thank you haasn
01:33:09 <mauke> woky: O(n + n) = O(n)
01:33:10 <AlecTaylor> @@ AlecTaylor @where YAHT
01:33:10 <lambdabot>  AlecTaylor "Yet Another Haskell Tutorial", Hal Daume III,<http://www.cs.utah.edu/~hal/htut/>,<http://en.wikibooks.org/wiki/Haskell/YAHT>,<http://hal3.name/docs/daume02yaht.p(df|s)>,<http://darcs.haskell.org/yaht/yaht.p(df|s)>
01:33:12 <AlecTaylor> @@ AlecTaylor @where HR
01:33:12 <lambdabot>  AlecTaylor "The Haskell Road to Logic, Maths and Programming", by Kees Doets,Jan van Eijck, at <http://homepages.cwi.nl/~jve/HR/>
01:33:18 <mauke> runtime complexity not affected :-)
01:33:25 <Welkin> woky: list comprehensions are not idiomatic haskell
01:33:26 <woky> mauke, but 2n > n  still holds
01:33:27 <haasn> ibotty: Nope, this can't be inferred from context alone since (,) and '(,) are both valid in certain contexts
01:33:40 <AlecTaylor> mauke: Add 100 :P
01:33:49 <Welkin> use map, filter, etc instead
01:33:49 <haasn> They're on the same syntactic layer, which is why we use ' to distinguish between types and promoted constructors
01:33:51 <woky> mauke, but you're right, i don't want to argue ;)
01:34:09 <pharpend_> AlecTaylor: LYAH is probably the best book
01:34:23 <ibotty> that's what i figured out by your explanation. let's see whether i will work out.
01:34:27 <pharpend_> AlecTaylor: bitemyapp has a nice tutorial on his GitHub page - https://github.com/bitemyapp/learnhaskell
01:34:56 <ibotty> and: another question, is there any type-level map (as in Data.Map) somewhere?
01:35:00 <Welkin> using haskell is certainly the best way to learning it, though
01:35:16 <Welkin> and reading *a lot* of other people's (well-written) source code
01:35:23 <AlecTaylor> THanks pharpend_
01:37:41 <ibotty> for my use case, it ought to behave like ['(Symbol,*)] with appropriate total `lookup :: KnownSymbol n => n -> Map ((n,t)':xs) -> t` but of course not only for the head tuple of the list.
01:38:33 <ibotty> i guess there should be a few somewhere in hlist/vinyl etc. but i did not find an implementation that is separate enough.
01:38:45 <ibotty> (or looked the wrong way)
01:42:50 <ThreeOfEight> Does anybody happen to know where I can find an implementation of maximum matching in undirected unweighted graphs in Haskell?
02:09:26 <absence> is there a bug in cabal that prevents --reinstall and --dependencies-only at the same time? it says the libs are already installed, and that i need to specify --reinstall :p
02:12:26 <calvinx> nothing worked until I went with Stackage.
02:12:41 <calvinx> Thank goodness for Stackage. Saved me buckets of time.
02:32:39 <Gurkenglas> @djinn [c] -> (c -> b -> Maybe (a, b)) -> b -> [a]
02:32:40 <lambdabot> Error: Undefined type []
02:33:12 <rydgel> @pl \w ws = filter (\x -> sort x == sort w) ws
02:33:12 <lambdabot> (line 1, column 7):
02:33:12 <lambdabot> unexpected "="
02:33:12 <lambdabot> expecting pattern or "->"
02:33:25 <rydgel> @pl \w ws -> filter (\x -> sort x == sort w) ws
02:33:26 <lambdabot> filter . (. sort) . (==) . sort
02:33:38 <Gurkenglas> Hmm, how difficult might it be to have lambdabot djinn types with [] in them
02:33:48 <Gurkenglas> I see you too are doing codewars.
02:34:54 <Gurkenglas> Isn't \w -> filter (((sort w) ==) . sort) enough?
02:37:49 <rydgel> I just removed ws, cause the point-free version what kind of unreadable for me. But I wanted to see it for curiosity
02:40:02 <exio4> Gurkenglas: djinn doesn't do recursive types
02:40:18 <ThreeOfEight> What about filter . on (==) sort?
02:42:05 <Gurkenglas> ThreeOfEight, that won't sort w (length ws) times?
02:42:09 <Gurkenglas> @djinn (a->Bool) -> (a->b) -> (a->b) -> a->b
02:42:09 <lambdabot> f a b c d =
02:42:09 <lambdabot>     case a d of
02:42:09 <lambdabot>     False -> b d
02:42:09 <lambdabot>     True -> c d
02:42:12 <Gurkenglas> Awesome.
02:43:23 <ThreeOfEight> Gurkenglas: I could never wrap my head around that in Haskell
02:43:26 <ThreeOfEight> but I don't think so, no
02:45:12 <Gurkenglas> On second readthrough, yeh me neither
02:46:37 <ThreeOfEight> Gurkenglas: okay, apparently it does
02:46:49 <Gurkenglas> You tested it? Weird.
02:47:18 <Gurkenglas> Do \w -> filter (((sort w) ==) . sort) too.
02:50:12 <ThreeOfEight> Gurkenglas: http://lpaste.net/114086
02:50:47 * hackagebot tasty-html 0.4 - Render tasty output to HTML  http://hackage.haskell.org/package/tasty-html-0.4 (jdnavarro)
02:52:24 <ThreeOfEight> okay, just updated it
02:52:26 <ThreeOfEight> this is very strange
02:52:42 <ThreeOfEight> I cannot make any sense of this
02:52:59 <ThreeOfEight> your function (I called it h) doesn't output ‘sort’ at all when compiled with GHC -O3
02:53:31 <ThreeOfEight> maybe trace doesn't work reliably with -O3
02:54:36 <ThreeOfEight> okay, GHC without optimisation makes more sense: f and g sort six times, h sorts four times.
02:57:01 <absence> when heap profiling i get a graph that increases over time called ARR_WORDS, and it disappears if i replace scanl with Control.Foldl.scan. a web search suggests ARR_WORDS is used for things like bytestring, text, unboxed arrays. am i seeing this because scanl isn't forcing the intermediate calculations, and they index into a vector?
02:57:48 <ThreeOfEight> Gurkenglas: ah, this one works, too, and only sorts w once: filter . equals sort . sort
03:12:59 <bjornars1> i feel that the existence of @pl is bad for the haskell community at large :P
03:14:24 <nmvictor> hi guys
03:14:34 <ThreeOfEight> I make a point of only using the output of @pl if it is something simple
03:14:54 <ThreeOfEight> good heuristic for that: few occurrences of parentheses, ., and ap
03:15:30 <ThreeOfEight> especially things like (. f) always really throw me off
03:16:37 <tdammers> better heuristic: if reading it makes you trip more, then it's not a good way of writing it
03:16:55 <exio4> @pl \x y -> x y (x y)
03:16:56 <lambdabot> join ap
03:20:48 * hackagebot hspec2 0.6.0 - Alpha version of Hspec 2.0  http://hackage.haskell.org/package/hspec2-0.6.0 (SimonHengel)
03:24:04 <imsc> hello.. i am very new to haskell but i know how to manage python/python libraries very will.. as of now i am struggling to install haskell and it's packages in custom path for pandoc tool.. Can somebody please help how to manage haskell packages
03:24:06 <imsc> ?
03:24:23 <imsc> *python/perl*
03:25:19 <imsc> i have done the initial home work of downloading the source of haskell and installed ghc build
03:25:55 <ThreeOfEight> I don't really see what you mean by ‘custom path’ and what it has to do with pandoc.
03:26:07 <ThreeOfEight> But normally, you just instal packages with cabal
03:26:12 <ThreeOfEight> (cabal install <packagename>)
03:26:13 <imsc> sorry.. it's custom installation
03:26:13 <nkar> imsc: what errors are you getting?
03:26:29 <ThreeOfEight> and that will instal stuff into your home directory, if I recall correctly
03:26:37 <imsc> yes
03:26:46 <ThreeOfEight> if you want to build something and not kill your global Haskell installation, you can use cabal sandbox
03:26:46 <imsc> it installs in home directory
03:26:56 <imsc> ohh
03:27:19 <ThreeOfEight> ‘cabal sandbox init’ in some directory
03:27:34 <ThreeOfEight> then all subsequent cabal commands in that directory will refer to the sandbox, not your global cabal
03:27:35 <imsc> the problem is if i build haskell, cabal, by default it installs in home directory
03:27:42 <imsc> which i don't want
03:27:51 <imsc> ok
03:28:10 <ThreeOfEight> What do you mean, ‘build Haskell’?
03:28:19 <ThreeOfEight> Are you trying to build Haskell Platform yourself?
03:28:30 <imsc> yes
03:28:34 <imsc> from source
03:28:46 <imsc> and it's libraries
03:30:21 <ThreeOfEight> Hm, I've never done that. It is a lot less painful to just use a ready-made build of Haskell Platform.
03:30:44 <ThreeOfEight> but if I am not mistaken, you already need an installation of GHC and some packages to build it
03:30:49 <ThreeOfEight> it has to be bootstrapped somehow
03:31:03 <ThreeOfEight> but I don't think I can help you with that, I know nothing about that process.
03:31:14 <imsc> hmm
03:31:16 <imsc> I use module environment  and maintain different versions of tools say for eg: /<nfs_path>/python/python/<version>/<platforms>  /<nfs_path>perl/perl/<version>/<platforms>
03:31:19 <MP2E> yeah building the haskell platform 'from source' actually means you just grab every library included in the haskell platform and GHC and build them one after the other
03:31:30 <MP2E> building the platform just packages those things
03:31:34 <MP2E> for other people to use
03:31:43 <MP2E> so in other words, for personal use, there is no point to compile the platform
03:31:52 <MP2E> it's just compiling the libraries that consist of the platform anyway :P
03:32:22 <imsc> hmm
03:32:34 <MP2E> not to say there isn't a point of compiling GHC yourself and your libraries yourself
03:32:39 <MP2E> just not necessarily the platform itself :P
03:32:56 <imsc> MP2E: hehehe
03:34:07 <imsc> i just wanted a little hint on installing and maintaining haskell and it's packages, which is required to build pandoc tool (installation in non standard path)
03:35:10 <imsc> have already installed ghc and cabal, but haskell-platform is not complete yet :)
03:35:16 <MP2E> Well, the platform is a good way to get up and running quickly. You can also build GHC and cabal from source too. Either way, you'd want to make a sandbox and install pandoc in there
03:35:23 <MP2E> ah
03:36:21 <MP2E> http://coldwa.st/e/blog/2013-08-20-Cabal-sandbox.html
03:36:39 <MP2E> ^ covers sandboxes pretty well
03:37:54 <imsc> wow
03:37:57 <imsc> :)
03:38:02 <imsc> exactly i wanted this
03:39:30 <imsc> MP2E: so this is exactly liike installing python libraries.. https://docs.python.org/2/install/ ?
03:43:35 <nmvictor> just getting my hands dirty on this FP language. I am trying to install ghc-mod in/from Cabal in Linux and I get the error: http://pastebin.com/buv4TpE
03:44:19 <clrnd> nmvictor, lpaste.net
03:46:31 <ThreeOfEight> This paste has been removed?
03:47:15 <nmvictor> just getting my hands dirty on this FP language. I am trying to install ghc-mod in/from Cabal in Linux and I get the error: http://lpaste.net/114088
03:47:19 <nmvictor> clrnd: ^
03:48:08 <ThreeOfEight> nmvictor: you have to provide the happy executable
03:48:19 <ThreeOfEight> it's probably in ~/.cabal/bin/
03:48:28 <ThreeOfEight> try adding ~/.cabal/bin/ to your path
03:48:40 <ThreeOfEight> or create a symbolic link to happy somewhere in your path
03:48:50 <MP2E> imsc: yep, pretty similar to python's way of installing packages
03:53:07 <nmvictor> ThreeOfEight: thanks, let me try that
03:56:23 <nmvictor> therealklanni: it seems to have install Configuring happy-1.19.4...
03:57:25 <nmvictor> but this line still begs for another verison: how do i get another version: cabal: The program happy version >=1.17 is required but it could not be found.
03:57:28 <nmvictor> Failed to install haskell-src-exts-1.16.0.1
03:57:57 <nmvictor> ThreeOfEight: * please read my submission ^^
03:59:00 <ThreeOfEight> I think it still can't find it
03:59:27 <ThreeOfEight> if it instals happy-1.19.4, that means the happy executable will land in your ~/.cabal/bin
03:59:36 <ThreeOfEight> (or in your sandbox, if you build inside a sandbox)
03:59:50 <ThreeOfEight> if it then complains about not finding happy >= 1.17, it's simply not in your path
03:59:54 <ThreeOfEight> What exactly did you do?
04:01:25 <nmvictor> ThreeOfEight: cabal install happy :)
04:01:36 <nmvictor> thats all i did
04:02:37 <nmvictor> ThreeOfEight: do i need to restart or reload anything ?
04:02:42 <ThreeOfEight> happy was probably already installed
04:02:51 <ThreeOfEight> I told you want you have to do: put ~/.cabal/bin in your path
04:03:09 <ThreeOfEight> or ln -s -T ~/.cabal/bin/happy /usr/bin/happy or something like that
04:03:12 <ThreeOfEight> the former is probably preferable
04:03:19 <mettekou> In Haskell, is there a bias towards sum types (encoding information in more data/value constructors) or product types (adding more fields for extra information) for solving problems? E. g.:
04:03:21 <lpaste> mettekou pasted “Product versus sum” at http://lpaste.net/3890810989410516992
04:05:46 <ThreeOfEight> mettekou: I think something like data CellType = Masked | Flagged | Clicked, data Cell = Cell CellType Int would be easier to handle
04:05:59 <dcoutts_> mettekou: depends on the details of the problem. There is certainly a bias to try and only encode the things that are possible, excluding the things that are impossible.
04:06:01 <ThreeOfEight> er, plus a Bool
04:06:14 <ocharles> Does anyone know how to use CPP macros to define compile time strings? I want to do apiPrefix = "#API_PREFIX", but that gives me a string literally containing that
04:06:23 <ocharles> Can you cause macro expansion in strings?
04:06:30 <ThreeOfEight> also I'd prefer the 3-constructor solution to the 5-constructor solution in your code
04:06:38 <ocharles> i guess I could = #API_PREFIX, and require quotes in the macro
04:07:14 <ThreeOfEight> otherwise, you might have unnecessary case distinctions in pattern matching in many places in your code
04:07:15 <dcoutts_> ocharles: I think this stuff is quite tricky to do portably too, since we're using cpp in "traditional" mode
04:07:22 <ThreeOfEight> but it really is a matter of personal taste
04:07:32 <ocharles> doh, macros don't have a leading hash
04:07:36 <exio4> I wouldn't use Bool though
04:07:41 <ocharles> apiPrefix = API_PREFIX at least does the job for now
04:07:42 <clrnd> mettekou, well the Bool doesn't provide the same info the word Mine does
04:07:56 <ocharles> dcoutts_: not a huge problem - it's for private code that I'm compiling with GHCJS
04:08:01 <dcoutts_> 'k
04:08:57 <mettekou> clrnd: Yeah, but that would mean introducing a type that is isomorphic to Bool (2 constructors, Mine and NoMine), for clarity purposes only.
04:09:40 <clrnd> mettekou, that's up to you, I do that all the time e.g. "type Name = Text"
04:09:51 <clrnd> (not the same ofc)
04:10:40 <nmvictor> ThreeOfEight: Thanks alot! That seems to work, though it still compiling stuff
04:11:17 <ThreeOfEight> it will probably take a while, yes :)
04:12:53 <nmvictor> ThreeOfEight: Can I do GUI programming with Haskell?whats a lib your would recommend  and how does Haskell GUI compare to C++ Qt or Java Swing?
04:13:56 <ThreeOfEight> nmvictor: it is certainly possible, but I've never tried it myself
04:14:10 <ThreeOfEight> I don't know anything about it
04:14:21 <ThreeOfEight> but from what I've heard, it's a huge PITA
04:14:35 <ThreeOfEight> You may want to have a look at this: https://www.haskell.org/haskellwiki/WxHaskell
04:15:06 <ThreeOfEight> My only experience with wxwidgets so far is when I tried to build it a few times and failed miserably
04:16:38 <nmvictor> ThreeOfEight: ooh, ok,I've read alot about the language and now it seems to fail on the GUI side, so what is it SO good at? what would make me ditch C++ or Java  infavor of Haskell?
04:17:49 <ThreeOfEight> If I had to give just one reason, it would be conciseness.
04:17:50 <dramforever> huh? why seems to fail?
04:18:11 <ThreeOfEight> And, personally, I don't do much GUI programming anyway
04:18:26 <dramforever> IO () can be passed around much easily than function ptrs
04:18:45 <ThreeOfEight> I use Haskell mainly for discrete computations (graph stuff, algebra, logic)
04:18:50 <ThreeOfEight> and it works great for that
04:19:27 <ThreeOfEight> And as I said, I don't really know much about GUI programming in Haskell. Also, stuff gets improved all the time.
04:19:32 <tdammers> for me, the biggest advantage is strong compile-time guarantees without sacrificing expressiveness or performance (much)
04:19:44 <ThreeOfEight> As I recall, programming GUIs in C++ isn't very nice either.
04:19:58 <tdammers> IMO, the GUI problem remains unsolved
04:20:08 <ThreeOfEight> The last time I had moderately pleasant GUI programming experiences was in C# and Delphi
04:20:14 <ThreeOfEight> (may it rest in peace)
04:20:59 <nmvictor> dramforever: experience mentioned by ThreeOfEight  is enough to tell the novice me that Haskell is failing on the GUI side and that attempts to make a GUI with the language would be almost futile, I would eventually had to got with a mature language for GUI.
04:21:26 <dramforever> hmm...
04:21:33 <dramforever> yeah I agree
04:21:48 <ThreeOfEight> nmvictor: I don't /have/ any experience with it. ^^
04:22:01 <ThreeOfEight> I just /heard/ that it is supposedly a huge pain, but that is highly subjective.
04:22:23 <ThreeOfEight> That said, I think there's a good chance it is true.
04:22:26 <nmvictor> ThreeOfEight: and thats all it takes to tell :)
04:24:05 <AlecTaylor> Darn, only just realised logging wasn't enabled. Can someone scroll up and send me the last two replies to my username? - Thanks
04:25:13 <ibotty> (10:29:44 AM) AlecTaylor: @@ AlecTaylor @where HR
04:25:13 <ibotty> (10:29:44 AM) lambdabot:  AlecTaylor "The Haskell Road to Logic, Maths and Programming", by Kees Doets,Jan van Eijck, at <http://homepages.cwi.nl/~jve/HR/>
04:25:13 <ibotty> (10:30:41 AM) pharpend_: AlecTaylor: LYAH is probably the best book
04:25:13 <ibotty> (10:30:59 AM) pharpend_: AlecTaylor: bitemyapp has a nice tutorial on his GitHub page - https://github.com/bitemyapp/learnhaskell
04:25:37 <AlecTaylor> Thanks
04:25:38 <ibotty> don't know whether that's what you wanted
04:25:52 <AlecTaylor> Yeah, those last two lines
04:29:49 <augur> oh wow another bot?
04:30:05 <augur> oh, ibotty is not a bot just a person quoting things
04:30:06 <augur> haha
04:30:21 <dramforever> hmm...
04:30:43 <ibotty> must kill all humans... :P
04:30:58 <ibotty> (just kidding if it's not obvious)
04:31:59 <AlecTaylor> Too late, DoD is at your door :3
04:32:49 <chrisdone> AlecTaylor: http://ircbrowse.net/day/haskell/today?id=19430583&timestamp=1415698241#t1415698241
04:33:58 <dramforever> what does https://www.haskell.org/haskellwiki/Emacs/Unicode_symbols do?
04:35:51 * hackagebot Unixutils 1.52 - A crude interface between Haskell and Unix-like operating systems  http://hackage.haskell.org/package/Unixutils-1.52 (DavidFox)
04:36:00 <bitonic> dramforever: it makes emacs show -> as → and so on
04:36:02 <ibotty> chrisdone: i'd really like ircbrowse without all the "somebotty joined", "somebotty left" messages. is that possible now? and if not, what do you think about adding that filter?
04:36:23 <bitonic> dramforever: I wouldn’t recommend it.  but if you really must have pretty symbols :P
04:36:24 <dramforever> bitonic: I have haskell-mode installed. How do I enable it?
04:36:32 <AlecTaylor> Thanks chrisdone
04:36:38 <dramforever> I'd like to try how it looks
04:36:52 <bitonic> dramforever: “Haskell-mode has included this feature for a long time now, so you probably just need to (setq haskell-font-lock-symbols t) in your .emacs to use this feature.”  I remember it being something like that
04:36:55 <chrisdone> ibotty: it's possible, but some work i didn't feel like doing yet
04:37:18 <bitonic> dramforever: the problem with that font locking is that you end up indent things wrong
04:37:25 <bitonic> since things that are two characters show up as two
04:37:26 <dramforever> hmmm
04:37:27 <ibotty> i meant, possible to use now (adding a parameter or similar). but thanks for your effort either way :)
04:37:47 <bitonic> dramforever: ∷ instead of ::, ⇒ instead of =>, → instead of ->
04:38:54 <chrisdone> ibotty: i'd need to generate separate indexes which exclude joins/parts
04:39:16 <etandel> is there any name for types with kind * -> *? Like "Maybe is a __ type."
04:39:18 <dramforever> bitonic: how about haskell-interactive-mode
04:39:43 <bitonic> dramforever: that’s very useful.  it let’s you load haskell projects easily, jump to errors, stuff like that.  highly recommended
04:40:06 <mauke> etandel: not specifically for * -> * but there's "parameterized type" and "type constructor"
04:40:06 <dramforever> I opened a file, M-x haskell-interactive-mode
04:40:27 <etandel> mauke: thanks
04:40:30 <dramforever> And ends up with two windows
04:40:35 <dramforever> ended
04:41:02 <bitonic> dramforever: sure.  one of them, presumably, is a GHCi session with your file loaded
04:41:10 <chrisdone> etandel: sometimes people call them type functions, too
04:41:45 <bitonic> dramforever: actually, I realised I’m talking about ’interactive-haskell-mode’.  not sure if they’re the same these days.  chrisdone probably knows :P
04:42:02 <bitonic> etandel: I like “type former”
04:43:39 <chrisdone> dramforever: https://github.com/haskell/haskell-mode/wiki/Haskell-Interactive-Mode-Setup
04:44:22 <bitonic> dramforever: for me with a recent haskell-mode things work super smoothly just make sure you have ‘(add-hook 'haskell-mode-hook 'interactive-haskell-mode)’ in your emacs init
04:44:56 <bitonic> chrisdone: thanks a lot for that by the way
04:46:03 <mads-> Would it be easy to set up a socket or something between two computers using haskell?
04:46:17 <dramforever> mads-: Network or Network.Socket
04:46:27 <dramforever> Proabably enough
04:47:11 <dramforever> Well, if just "connect to xx.xxx.xx.xx port xx and send xxx and recieve" it's proabably enough
04:47:30 <etaoinshrdlu> @help
04:47:30 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
04:47:47 <etaoinshrdlu> @list
04:47:48 <lambdabot> What module?  Try @listmodules for some ideas.
04:47:51 <mads-> dramforever: thanks
04:47:57 <dramforever> etaoinshrdlu: don't do it here
04:48:11 <dramforever> try /msg lambdabot @listmodules
04:48:12 <etaoinshrdlu> dramforever: Sorry
04:48:20 <etaoinshrdlu> dramforever: I'm really new to irc
04:48:53 <dramforever> I'm not "old", either
04:50:08 <etaoinshrdlu> What do you mean? :)
04:50:19 <dramforever> etaoinshrdlu: pretty new
04:50:23 <dramforever> jokingly
04:50:33 <dramforever> maybe I've made a wrong joke
04:51:02 <etaoinshrdlu> English is not my first language so I got confused :P
04:51:08 <dramforever> Mee too
04:51:10 <etaoinshrdlu> Haha
04:51:16 <dramforever> Maybe I shouldn't have done that
04:51:23 <dramforever> oops
04:51:25 <dramforever> Me too
04:56:35 <Tokenizer> hi, i have the following code (http://pastie.org/private/la1vwljftu98ruuhm0g). I keep getting the error:     parse error on input ‘results’  <-- line 7
04:57:15 <chrisdone> the decls in a let need to line up
04:57:42 <chrisdone> you've got
04:57:43 <chrisdone>   a2 =
04:57:43 <chrisdone>  result =
04:57:47 <chrisdone> it should be
04:57:48 <chrisdone> a2 =
04:57:50 <chrisdone> results =
04:58:16 <chrisdone> your code there generally looks like you don't care how your code is formatted; haskell's layout-sensitive mode does care
04:58:17 <Tokenizer> thanks
04:58:27 <chrisdone> if you don't want to bother you can use the { } and ; style
04:58:53 <chrisdone> let { a2 =
04:58:54 <chrisdone> … ;
04:58:54 <chrisdone> result = … } in { sdf
04:58:54 <chrisdone>  }
04:59:05 <chrisdone> would be accepted
04:59:41 <chrisdone> no one would want to read your code but if you don't care about that… ;-)
04:59:52 <dramforever> YEAH!
05:00:22 <dramforever> I saw someone who has a *really* uncomfortable programming style
05:00:26 <dramforever> well, coding style
05:00:56 <dramforever> for example: he *insists* on *no* spaces around operators
05:01:08 <dramforever> a = 0 -- bad
05:01:14 <dramforever> a=0 --good
05:01:24 <dramforever> a=0--best
05:01:29 <MP2E> heh
05:01:39 <dramforever> That was in *his* opinion
05:01:54 <dramforever> And when I ask him to change, he says:
05:02:02 <troydm> some ppl have shit tastes
05:02:05 <dramforever> "Nobody else will read my code"
05:02:11 <dramforever> for example:
05:02:28 <dramforever> bad comment -- Initializes the result array
05:02:44 <dramforever> so called "good" comment -- init-result-array
05:02:58 <dramforever> (I'm gonna add "so called" in case it confuses people)
05:02:59 <sivteck> > foldl(+)0[1,2,3,4,5,6,7] --bestest
05:03:00 <lambdabot>  28
05:03:09 <dramforever> well...
05:03:20 <dramforever> Agda might make him feel weird
05:03:33 <dramforever> specifically, the agda lexer
05:04:07 <shiona> does he redefine all functions as operators so he isn't forced to leave a spaces between parameters?
05:04:19 <dramforever> shiona: he codes python
05:04:49 <dramforever> those examples are haskellized in order to stay on topic here
05:04:55 <shiona> ah
05:06:55 <dramforever> real example code: template.render(origins=origin(path)[:-1],urllikes=path[:-2],files=os.listdir(origin(path))
05:07:18 <dramforever> that's not the whole line, just a part of it
05:08:40 <dramforever> Hey, I still don;t get how to use haskell-interactive-mode
05:08:43 <dramforever> don't
05:09:13 <dramforever> I cannot edit the buffer if I M-x haskell-interactive-mode
05:09:19 <chrisdone> lol
05:09:25 <chrisdone> that changes the major mode to be a repl
05:09:35 <chrisdone> so you'd be changing your current buffer into a prompt
05:09:43 <dramforever> how am I supposed to use it?
05:09:54 <chrisdone> Mx- interactive-haskell-mode to enable the minor mode
05:10:03 <chrisdone> then C-c c-l to load files or whatever
05:10:20 <dramforever> huh? no such command here
05:10:38 <dramforever> maybe try upgrading haskell-mode
05:10:50 <chrisdone> use the git version =)
05:11:07 <dramforever> I'll see in list-packages first
05:12:05 <dramforever> hmm...just 13.7
05:12:07 <dramforever> no more
05:12:36 <rydgel> @pl \n -> map (\x -> intersperse ' ' $ map convert x) (pascal n)
05:12:36 <lambdabot> map (intersperse ' ' . map convert) . pascal
05:13:06 <gcganley> :t pascal
05:13:07 <lambdabot> Not in scope: ‘pascal’
05:13:41 <dramforever> @pl fix
05:13:41 <lambdabot> fix
05:13:50 <dramforever> @pl \f -> let x = f x in x
05:13:50 <lambdabot> fix
05:13:55 <dramforever> woww
05:14:30 <gcganley> @unpl fix
05:14:30 <lambdabot> fix
05:14:31 <dramforever> @pl let x = show (1 + x) ++ show x in x
05:14:31 <lambdabot> fix (ap ((++) . show . (1 +)) show)
05:14:54 <dramforever> let x = "xxxx" ++ x in x
05:15:09 <dramforever> @pl \a -> let x = a ++ x in x
05:15:09 <lambdabot> fix . (++)
05:15:50 <gcganley> :t fix
05:15:51 <lambdabot> (a -> a) -> a
05:18:24 <dramforever> chrisdone: I'll try melpa first
05:18:44 <exio4> > fix ('x':)
05:18:46 <lambdabot>  "xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx...
05:19:22 <BoR0> :t ('x':)
05:19:23 <lambdabot> [Char] -> [Char]
05:19:35 <BoR0> :t (:)
05:19:36 <lambdabot> a -> [a] -> [a]
05:20:42 <dramforever> chrisdone: thanks, it works
05:20:53 * hackagebot postgresql-binary 0.2.1 - Encoders and decoders for the PostgreSQL's binary format  http://hackage.haskell.org/package/postgresql-binary-0.2.1 (NikitaVolkov)
05:21:27 <chrisdone> dramforever: cool
05:24:35 <dramforever> in "structured-haskell-mode" readme it says "Turn off haskell-indentation-modes."
05:24:43 <dramforever> How am I supposed to do it
05:26:11 <gcganley> dramforever: do you have haskell-indentation-mode configured in your .emacs file?
05:26:36 <dramforever> oh
05:26:45 <dramforever> gcganley: I thought it was on by default
05:26:54 <dramforever> turned out it was configured
05:27:30 <dramforever> gcganley: thanks for the hint
05:27:33 <gcganley> dramforever: lol nope, i've been configureing my .emacs file for the last 2 hours, trust me haskell-mode isnt the easiest to configure
05:27:53 <gcganley> thats a lie im just bad at it
05:28:03 <bitonic> gcganley: my haskell-mode configuration is like 3 lines and things seem fine here
05:28:07 <dramforever> gcganley: I'm trying to try shm
05:28:17 <etandel> maybe it would be easier if you just used vim. =P
05:28:23 <gcganley> bitonic: im sorta anal about key combination
05:28:24 <etandel> (JK let us not start a editor war)
05:28:29 <bitonic> gcganley: the only mild annoyance is that you have to make sure that each project loads fine, but that’s more of a cabal/GHCi issue than haskell-mode
05:28:31 <dramforever> hmmm...
05:28:50 <gcganley> bitonic: mine is like 20 lines
05:29:05 <dramforever> mine is like some wtf
05:29:10 <gcganley> bitonic: I use both vim and emacs.
05:31:57 <clrnd> hey guys, I have this "EitherT bla blah IO" I use to compose my actions, usually with mapM, and I may want to run them in parallel, is this easy/doable?
05:32:18 <dramforever> I hate it when I have to vim ~/.emacs or emacs ~/.vimrc
05:32:23 <Tehnix> A little confused on function composition. Isn't `f (g x)` the same as `f.g x`?
05:32:31 <dramforever> Tehnix: no
05:32:41 <dramforever> f . g x = f . (g x)
05:32:51 <dramforever> function application has the highest precs
05:33:02 <dramforever> precedence
05:33:07 <gcganley> dramforever: i vim my .emacs all the time when im over ssh. i hate using emacs over terminal
05:33:33 <tdammers> gcganley: blasphemy!
05:33:38 <tdammers> gcganley: you have to pick a side!
05:34:06 <gcganley> tdammers: why not both?!?!?!
05:34:18 <detrumi> Tehnix: You probably want (f . g) x
05:34:40 <BoR0> Tehnix, or f $ g x
05:34:44 <Tehnix> detrumi, dramforever: Ahhh, was about to ask if it was that instead
05:34:51 <Tehnix> Then it did little to remove my parens :(
05:35:14 <detrumi> BoR0: or even f . g $ x, but that's really ugly
05:35:31 <tdammers> stallman raymond something something mumble mumble
05:36:48 <gcganley> rms shall live forever
05:37:05 <gcganley> although i think hes a bit crazy
05:38:11 <tdammers> he's not crazy, he's unconventional, honest, stubborn, and socially awkward
05:38:19 <beaky> hello
05:38:23 <gcganley> hey
05:38:34 <beaky> what module should i use to work with bit vectors
05:38:45 <gcganley> vector? i havent used ti
05:38:49 <beaky> (or bitsets, bit arrays, i.e. colections of bits :D)
05:38:55 <gcganley> has really nice stream fusion
05:39:50 <gcganley> but i've never used it
05:39:52 <dramforever> beaky: UArray
05:40:02 <dramforever> UArray Int Bool
05:40:25 <dramforever> I've forgotted which module it's in, but it should have came with your compiler
05:40:56 <gcganley> does anyone in here use anything but GHC?
05:41:00 <gcganley> im really interested
05:41:27 <beaky> i am a ghc user :D
05:41:46 <tdammers> ghc uses me
05:41:48 <beaky> glorious haskell compiler
05:42:26 <bel3atar> how's <*> called?
05:42:33 <clrnd> ap
05:42:34 <beaky> i think its called ap
05:42:36 <gcganley> ap
05:42:41 <detrumi> Might use UHC in the future for research, but haven't really used it yet
05:43:28 <beaky> btw what are good uses for <*>
05:43:35 <dramforever> beaky: like this:
05:43:46 <beaky> (mostly i use it after using <$>)
05:43:47 <dramforever> > (+) <$> Just 2 <*> Just 3
05:43:48 <lambdabot>  Just 5
05:43:50 <dramforever> > (+) <$> Just 2 <*> Nothing
05:43:52 <lambdabot>  Nothing
05:43:58 <gcganley> the magical world of applicative
05:44:02 <dramforever> yep
05:44:15 <beaky> wont it be neater to use do notation
05:44:22 <dramforever> beaky: huh?
05:44:32 <dramforever> not really, imo
05:45:21 <gcganley> move the stuff around with \n and it makes it look really pretty
05:45:52 <dramforever> beaky: It's just like powered function application
05:45:54 <beaky> > do { let a = Just 2; let b = Nothing; x <- a; y <- b; return x+y; }
05:45:55 <lambdabot>  <hint>:1:41: parse error on input ‘<-’
05:46:00 <beaky> damn :(
05:46:05 <detrumi> Isn't it just like list comprehension?
05:46:49 * dramforever always presses "up" when he wants to re-type an expression for lambdabot to eval
05:47:01 <dramforever> but for other people's expressions...
05:47:38 <dramforever> beaky: how clean is this:
05:47:54 <beaky> let a = Just 2 in let b = Nothing in a>>=\x->b>>=\y->return x+y;
05:47:57 <beaky> >let a = Just 2 in let b = Nothing in a>>=\x->b>>=\y->return x+y;
05:47:57 <dramforever> > do { a <- Just 2; b <- Nothing; return (a+b) }
05:47:59 <lambdabot>  Nothing
05:48:11 <beaky> hmm right the aplicative notaiton is more consice
05:48:12 <dramforever> how clean is that?
05:48:34 <dramforever> and applicatives are more general than monads
05:48:44 <detrumi> That's true
05:49:19 <dramforever> :t (\x -> do { x' <- x; x'' <- x'; x''' <- x''; x'''})
05:49:20 <lambdabot> Monad m => m (m (m (m b))) -> m b
05:49:29 <beaky> monad has lots of sugar notation :D from <$> to do notation to monad comp :D
05:49:37 <dramforever> yep
05:49:41 <dramforever> wait
05:49:48 <dramforever> <$> is just an operator
05:49:53 <beaky> oh right
05:49:59 <beaky> <$> is basicaly fmap
05:50:14 <dramforever> let (<!#@@@@>) = (>) in 1 <!#@@@@> 2
05:50:16 <dramforever> > let (<!#@@@@>) = (>) in 1 <!#@@@@> 2
05:50:18 <lambdabot>  False
05:50:21 <dramforever> > let (<!#@@@@>) = (>) in 1 <!#@@@@> -1
05:50:22 <lambdabot>  Precedence parsing error
05:50:23 <lambdabot>      cannot mix ‘<!#@@@@>’ [infixl 9] and prefix `-' [infixl 6] in the same i...
05:50:30 <dramforever> > let (<!#@@@@>) = (>) in 1 <!#@@@@> (-1) -- oops
05:50:31 <lambdabot>  True
05:50:40 <dramforever> > -- oops
05:50:41 <lambdabot>  not an expression: ‘-- oops’
06:04:23 <ocharles> Does anyone know if XML trees have any type of more general underlying structure? They don't seem to fit into 'Cofree []' - at least not in the sense that they are correct by construction
06:05:17 <ocharles> E.g., 'Text "Hello" :< [ return (Text "World") ] ::Cofree [] Node ' doesn't seem to make any sense
06:05:55 * hackagebot creatur 5.7.2 - Framework for artificial life experiments.  http://hackage.haskell.org/package/creatur-5.7.2 (AmyDeBuitleir)
06:05:56 <bitonic> ocharles: those beautiful XML schemas are types.  you can probably study what a valid schema is
06:06:35 <ocharles> edwardk: I feel like your ears might perk up at the mention of "cofree" :)
06:06:44 <edwardk> =P
06:06:46 <ocharles> bitonic: not quite following what you mean
06:07:08 <ocharles> I'm looking for "always syntactically valid", not necessarily semantically valid
06:07:56 <bitonic> ocharles: oh, OK.  then it should be easier.  I was referring to stuff like <http://homepages.inf.ed.ac.uk/wadler/topics/xml.html#xml-essence>
06:08:14 <edwardk> xml is just an annoying structure to capture because of the single element top level thing, uniqueness of attributes, occasional relevance of attribute order due to non-compliant sax parsers, etc.
06:08:20 <bitonic> although I was a bit ironic because I’ve always found those things hard to stomach
06:08:44 <ocharles> I'm willing to loosen the requirement on attribute uniqueness, but the single top level element always screws things up
06:09:15 <ocharles> I have a HTML DSL right now, but it doesn't have a nice notion of monoid or identity, so I feel I'm making life harder for myself. I was hoping if it was already something more general, then I might get identity for free
06:09:25 <ocharles> monoidal combination*
06:09:48 <Tokenizer> what's wrong with such code --> ([(2,"asdfasdf")]!!0).snd .... For instance how can I get the second element of a the first element of a list of tuples?
06:10:01 <bitonic> ocharles: I think those Wadler papers might be of some inspiration, but I just looked at them a long time ago
06:10:14 <ocharles> Cool, I haven't seen these (though I know Wadler loves XML :))
06:10:36 <ocharles> I'm trying to represent my DSL with things like `div :: HTML` rather than the more traditional `div :: HTML -> HTML`, which so far has felt quite liberating
06:10:41 <mauke> Tokenizer: snd (... !! 0)
06:10:43 <pantsman> a Wadler paper! About XML! http://media.giphy.com/media/AQOpT2cYxqsjS/giphy.gif
06:10:57 <mauke> as for what's wrong: a tuple is not a function, and . is function composition
06:10:58 <ocharles> I was hoping that substituting the children under an element would correspond to (>>=), or maybe (=>>)
06:11:58 <exio4> Tokenizer: you can use "snd (head [...])", but, do you really need to do it that way? pattern matching is probably what you need
06:12:23 <exio4> > snd (head [(1,2), (3,4), (5,6)])
06:12:25 <lambdabot>  2
06:17:55 <chrisdone> ocharles: sick of blaze?
06:18:16 <ocharles> chrisdone: not necessarily, but I don't like that blaze isn't a real monad
06:18:43 <ocharles> blaze is also building a deep embedding, but that's costly in ghcjs - what I have right now just lenses directly into the virtual-dom ffi
06:19:09 <ocharles> I could go down the blaze path and use a strict state monad or something, probably
06:20:24 * chrisdone thinks the blaze folks cursed themselves with that monad choice
06:22:21 <ocharles> it's nice syntax, it's just dumb that it's not a real monad
06:22:30 <ocharles> but apparently using anything else was significantly slower when it was invented
06:23:08 <bernalex> hm. I have a function that takes two args. what's a neat way to apply it to a list of args like this: if the list has five members [1..5], I want to call f 1 2, f 2 3, f 3 4 and f 4 5.
06:23:09 <ocharles> https://gist.github.com/ocharles/018f26ddcd9ba4a45d6b is how my DSL looks
06:23:46 <mauke> bernalex: ap zip tail
06:23:47 <ocharles> bernalex: zipWith (uncurry f) xs (tail xs)?
06:23:51 <ClaudiusMaximus> bernalex: zipWith f list (tail list)
06:23:59 <ocharles> oh wait, no need to uncurry
06:25:45 <bernalex> mauke: that's pretyt cool
06:25:50 <bernalex> ClaudiusMaximus: yeah that's what I do now
06:26:07 <michaelt> > zipWith (+) `ap` tail $ [1..5]
06:26:08 <lambdabot>  [3,5,7,9]
06:26:25 <chrisdone> ocharles: looks like a nightmare to edit =)
06:26:30 <ocharles> > zipWith f `ap` tail $ [a,b,c,d,e]
06:26:32 <lambdabot>  No instance for (GHC.Show.Show c0)
06:26:32 <lambdabot>    arising from a use of ‘M89785040897856389817779.show_M89785040897856389817...
06:26:32 <lambdabot>  The type variable ‘c0’ is ambiguous
06:26:32 <lambdabot>  Note: there are several potential instances:
06:26:32 <lambdabot>    instance [safe] GHC.Show.Show
06:26:34 <ocharles> bah
06:26:37 <ocharles> chrisdone: it's not so bad
06:26:38 <bernalex> michaelt: that's cool too
06:26:39 * chrisdone . o O (  such is haskell  )
06:26:49 <ocharles> chrisdone: of course, hindent is a disaster on it though :)
06:27:19 <ocharles> chrisdone: I'm half tempted to use a sexp quasiquoter and backtick haskell values back in
06:27:41 <chrisdone> =p
06:27:54 <mauke> > zipWith f `ap` tail $ [a,b,c,d,e] :: [Expr]
06:27:56 <lambdabot>  [f a b,f b c,f c d,f d e]
06:28:23 <ocharles> ah, thanks mauke
06:28:50 <michaelt> > zipWith (+) `ap` tail $ [a,b,c,d,e] :: [Expr]
06:28:51 <lambdabot>  [a + b,b + c,c + d,d + e]
06:29:07 <chrisdone> ocharles: i think that's a good example of what i call nonce style. sort of, the mixture of the hierarchy and operators forcing you to manually come up with a way of formatting code that has nothing to do with any regular rules
06:29:25 <chrisdone> haskell seems particularly good at making people do that
06:29:32 <ocharles> chrisdone: yea
06:29:58 <chrisdone> hmm, i wonder whether a sexp quoter could be generalised so you could just use it whenever you need a clean DSL
06:33:38 <tdammers> chrisdone: if you can live with < > instead of ( ), and hiding Prelude, it can even be done as an eDSL, I guess
06:33:42 <beaky> is it bad to use underscored variable names
06:34:07 <beaky> e.g. f _1 _2 _3 = g _3 _2 _1
06:34:20 <chrisdone> yeah
06:34:29 <chrisdone> _foo used to mean "unused"
06:34:39 <chrisdone> but people started using _foo for anything. go nuts
06:35:03 <BoR0> is it not convenient to prepend _ to records?
06:35:16 <BoR0> I've seen many examples that do that
06:35:20 <tdammers> lens kind of calls dibs on leading _
06:35:33 <tdammers> at least for the TH deriving
06:36:02 <chrisdone> yeah, prime has always been the way of saying "like but not the same as"
06:36:30 <chrisdone> conventions get old
06:37:39 <chrisdone> ocharles: i'm not fully happy with blaze either. the monad thing is a mild annoyance, but being able to edit it in a regular way is definitely something i'd like to improve
06:38:11 <michaelt> doesnt _XTypeHoles have some new use for underscored variables?
06:38:39 <michaelt> -XTypeHoles rather
06:39:07 <chrisdone> it does
06:39:22 <nshepperd> sometimes I use _leadingUnderscores for record syntax accessors
06:40:34 <nshepperd> just to stop ghc-mod from yelling "you shadowed a variable" at me, whenever I want to use the field name as a variable
06:41:06 <chrisdone> just wait till name shadowing bites you
06:42:49 <chrisdone> ocharles: we're fiddling with something like
06:42:52 <nshepperd> it would be cool if ghc could turn off the shadowing warning for cases where the types of the two variables don't unify
06:43:09 <chrisdone> build "div" (do attr "x" "blah"; …)
06:43:43 <beaky> is there something like a function (a,b,c,d) -> a -> b -> c -> d
06:43:43 <chrisdone> much easier to edit in a regular way. the stringiness can be lathered in names if one likes that sort of thing
06:43:47 <beaky> to unravel a tuple
06:44:14 <beaky> or at least a function to take a function a -> b -> c -> d -> e and tuplify its arguments to (a,b,c,d) -> e
06:44:22 <bitonic> nshepperd: RecordWildCards does just that without warning you
06:45:11 <nshepperd> that way, it wouldn't complain so much, but you still wouldn't get in trouble for using the wrong variable. either it would warn you about shadowing, or it would throw a type error
06:46:09 <nshepperd> beaky: (,,,) is that function!
06:46:33 <beaky> :t (,,,)
06:46:34 <lambdabot> a -> b -> c -> d -> (a, b, c, d)
06:46:44 <nshepperd> well, almost
06:47:05 <beaky> i found this http://stackoverflow.com/questions/7220953/does-haskell-have-variadic-functions-tuples but maybe (,,,) works too?
06:47:10 <chrisdone> ocharles: i wonder whether you could mitigate qualification pain with record wildcards
06:47:19 <nshepperd> oh you want uncurry4 maybe
06:47:23 <nshepperd> :t uncurry4
06:47:23 <lambdabot>     Not in scope: ‘uncurry4’
06:47:24 <lambdabot>     Perhaps you meant ‘uncurry’ (imported from Data.Tuple)
06:47:35 <nshepperd> aww
06:48:34 <nshepperd> uncurry4 = \f (a,b,c,d) -> f a b c d
06:49:17 <chrisdone> ocharles: ooooo. i just had a horrific idea
06:49:34 <chrisdone> ocharles: implicit params for names =p
06:49:43 <beaky> >(+) <$> (1,2,3) <*> (4,5,6)
06:49:51 <nshepperd> yeah I think (,,,) is the reverse to what you want
06:49:53 <beaky> > (+) <$> (1,2,3) <*> (4,5,6)
06:49:55 <lambdabot>  No instance for (GHC.Show.Show t1)
06:49:55 <lambdabot>    arising from a use of ‘M393045181438176283818740.show_M3930451814381762838...
06:49:55 <lambdabot>  The type variable ‘t1’ is ambiguous
06:49:55 <lambdabot>  Note: there are several potential instances:
06:49:55 <lambdabot>    instance [safe] GHC.Show.Show
06:50:12 <albeit> > (+) <$> (1,2,3) <*> (4,5,6) :: (Int, Int, Int)
06:50:13 <lambdabot>  No instance for (GHC.Base.Functor
06:50:13 <lambdabot>                     ((,,) GHC.Types.Int GHC.Types.Int))
06:50:13 <lambdabot>    arising from a use of ‘Data.Functor.<$>’No instance for (Control.Applicati...
06:50:13 <lambdabot>                     ((,,) GHC.Types.Int GHC.Types.Int))
06:50:13 <lambdabot>    arising from a use of ‘Control.Applicative.<*>’
06:50:26 <beaky> hmm how do i add tuples like that
06:51:11 <nshepperd> tuples aren't really fixed-length lists
06:51:45 <chrisdone> ocharles: (?html (do ?head …) (do ?p "Hello!"; ?p (?strong "yo)))
06:51:51 <osa1> any ideas how to catch timeout exceptions thrown by network's connect function http://hackage.haskell.org/package/network-2.6.0.2/docs/Network-Socket.html#v:connect
06:52:03 <chrisdone> ocharles: someone out there must've done such a thing =p
06:55:28 <chrisdone> (the whole H.span / A.span stuff is icky)
06:55:57 <bitonic> osa1: catching IOError should work
06:56:13 <osa1> bitonic: how do I know it'a timeout error and not something else?
06:56:44 <bitonic> osa1: good question.  I don’t know.  if you give me a quick testcase I can try to find out
06:57:34 <michaelt> osa1: you can pattern match on the error they are defining
06:58:18 <osa1> no details about the exception thrown in case of a timeout are specified in docs so I think there's no safe way to catch that exception.
06:58:32 <osa1> bitonic: what are you going to do to find out?
06:58:53 <mauke> what exactly this exception is
06:59:09 <mauke> which then leads to being able to check for it
06:59:21 <bitonic> osa1: run it and see what kind of exception it is.  but you’re probably right, I’d think there is no fine grained control over the exceptions thrown by those socket function
06:59:31 <osa1> you can't extend IOException, can you? there isn't an IOException about timeouts so it has to use some existing IOException
06:59:53 <mauke> it could throw a non-IOException
07:00:20 <osa1> is this possible? how do I know type of thrown exception?
07:00:35 <osa1> so really I think IO functions in libs are horrible most of the time
07:00:44 <osa1> for example this particular function has worst type possible
07:00:53 <chrisdone> catch … (\((SomeException e) :: SomeException) -> print (typeOf e))
07:01:10 <mauke> don't need the type annotation
07:01:15 <osa1> I'd expect this to at least have something like IO ConnectStatus where data ConnectStatus = Successful | TimedOut | ConnectionError etc.
07:01:40 <bitonic> osa1: well, I’d guess it just uses ‘throwErrno’.  Network.Socket is pretty low level
07:02:01 <bitonic> osa1: do what chrisdone said to find out what exception type it is
07:02:25 <osa1> bitonic: I don't think this is about being low-level. native version signal those cases in some way or another but Haskell wrapper doesn't.
07:02:37 <osa1> so in a sense haskell version is even worse than native version
07:02:49 <mauke> yes, that matches my experience
07:02:56 <bitonic> osa1: you can use getErrno if that’s the case.  but yes, you’re right.
07:03:44 <bitonic> by using getErrno you’re forced to break various abstractions, and it’s super fragile.  and I’m not even sure it would work
07:03:50 <osa1> yeah
07:04:12 <michaelt>  TimeExpired is one of the constructors of the IOErrorType field IOException
07:04:35 <michaelt> field *of* IOException
07:04:41 <osa1> michaelt: how do you see constructors of IOErrorType? it's kept abstract
07:05:40 <michaelt> Oh is it abstract, hm. I see them by seeing them.
07:05:43 <osa1> michaelt: what field? http://hackage.haskell.org/package/base-4.7.0.1/docs/Control-Exception-Base.html#t:IOException I can't see any fields here
07:06:00 <osa1> so really this is no solution
07:06:25 <osa1> I think there's something really broken but people just don't care and this makes me sad. IO functions in libs are horribly broken.
07:06:28 <michaelt> osa1:   IOErrorType(..)  maybe the haddocks arent printing it?
07:07:08 <michaelt> oh wait, is it a ghc thing only
07:08:27 <michaelt> GHC.IO.Exception exposes the constructors. Of course maybe the timeout error isnt using this
07:09:47 <michaelt> man, these error/exception modules are a madhouse of indirection
07:10:40 <michaelt> osa1: but how did you know you were dealing with a timeout error?
07:11:39 <osa1> michaelt: it prints the reason when my program crashes. I guess show instance of IOErrorType
07:11:55 <osa1> michaelt: so really, I know I can somehow catch that.
07:12:00 <michaelt> oh, ok so you can match on it
07:12:22 <mauke> did you do what chrisdone suggested?
07:12:35 <osa1> michaelt: like I said, the point is not that. the point is that 1) types are horrible 2) docs are horrible 3) even native version of this function is better than haskell binding
07:12:49 <osa1> let me see what he said
07:13:05 <DrSkyLizard> Any ideas why I get errors on this code: http://ideone.com/WRZAz3 ?
07:13:17 <michaelt> I think you are supposed to write something more sensible on top of this nonsense, but maybe you're right it hasnt been arranged adequately to do that
07:14:00 <mauke> DrSkyLizard: your showResult type signature is wrong
07:14:06 <osa1> michaelt: it's not possible to write anything safe using that functions because errors are not specified anywhere. it may change at any point or you may left some errors behind because you may not realize it while testing or reading the source
07:14:11 <bitonic> osa1: agreed.  what are you trying to do?  maybe there are already some higher level functions dealing with reconnects and such
07:14:41 <michaelt> mauke: wasnt that just to get the type of the error. osa1 is looking for a field buried inside
07:14:50 <osa1> bitonic: I'm trying to write a stable program :)
07:14:58 <mauke> michaelt: so what is the type?
07:15:16 <bitonic> osa1: sure, but what is the issue you’re dealing with specifically?
07:15:17 <osa1> bitonic: I want to at least log most exceptions, especially the ones realted with networking
07:15:32 <osa1> bitonic: no specific issues. I'm just frustrated by horrible IO functions in libs
07:15:35 <bitonic> osa1: ok, if it’s just logging log all IOErrors
07:15:39 <DrSkyLizard> mauke: how come? I have a list of element types Num and Ord and return a String
07:15:58 <michaelt> mauke IOErrorType is one of the fields of IOException
07:15:58 <mauke> DrSkyLizard: see the error message
07:15:58 <osa1> bitonic: sometimes I call a handler, sometimes I log. if it's a timeout I call a handler, for other I want to log
07:16:07 <osa1> bitonic: so catch-all won't work
07:16:19 <mauke> michaelt: what's a field?
07:16:32 <michaelt> mauke: it's a record type
07:16:34 <mauke> also, what's the exception type?
07:16:47 <michaelt> mauke: I'm not following.
07:16:59 <bitonic> osa1: OK.  you can hack it (show the exception and match on the string) ore give up that granularity.  agreed that it’s stupid.
07:17:01 <michaelt> chrisdone's device would print "IOException"
07:17:09 <mauke> michaelt: how do you know?
07:17:21 <michaelt> I read the definiton
07:17:27 <mauke> of what?
07:17:45 <michaelt> but maybe i'm looking at a different line in the transcript above?
07:17:45 <DrSkyLizard> mauke: ah, showResult :: (Num a, Ord a, Show a) => [a] -> String
07:17:52 <bitonic> osa1: this is assuming that timeouts are logged through opaque IOErrors (I’m fairly confident that that’s the case).  if you give me a SockAddr that times out I can find out, I can’t think of anything right now :P
07:19:06 <osa1> could it be possible to update `network` package for better error/exception reporting?
07:19:29 <albeit> osa1: Go ahead! ;)
07:19:31 <bitonic> osa1: I think asking the “libraries” mailing list is probably the best place to ask
07:19:53 <bitonic> osa1: the only argument against it I can think of is discourage the use of exceptions as control flow devices
07:19:56 <osa1> bitonic: oh, I didn't know we have "libraries". where do I subscribe to that?
07:20:13 <michaelt> osa1: I was going to say, it sounds like you should take the issues up with tibbe https://github.com/haskell/network/issues
07:20:21 <bitonic> osa1: <https://www.haskell.org/mailman/listinfo/libraries>
07:20:25 <osa1> thanks
07:20:34 <bitonic> oh, the GitHub seems active as well.
07:20:52 <bitonic> osa1: <https://github.com/haskell/network/issues/62>
07:21:06 <michaelt> tibbe is extremely responsive in my experience
07:21:47 <bitonic> what singpolyma says is true though, you’d break a lot of code using IOError to handle… IOErrors
07:22:12 <michaelt> bitonic: oh indeed, it looks like that went nowhere though .
07:22:17 <bitonic> if we had subtyping for Typeable or something ehe
07:22:58 <bitonic> osa1: just stop writing those kind of programs and go back to lazy fibonacci lists!
07:23:10 <osa1> hehe
07:23:32 <bitonic> unless they’re generated with some fibonacci servers using lazy io
07:24:11 <mauke> I've found it far easier to write correct programs that interact with the OS in C or Perl than in Haskell
07:24:39 <ocharles> chrisdone: D:
07:24:45 <osa1> mauke: any reasons for that other than having horrible wrappers?
07:24:58 <EvanR> the kinds of exceptions that are thrown arent really documented
07:25:15 <chrisdone> ocharles: =p
07:25:40 <bitonic> I wouldn’t go as far.  but I also think that fine grained exception catching is almost never a good thing… I’d prefer a module where you get back ‘Maybe ErrorCode’ or something
07:25:45 <mauke> osa1: haskell/ghc insists on hiding the outside world from you
07:26:09 <bitonic> because it’s a cold and desolate place
07:26:29 <mauke> e.g. you can't get argv[0] because getProgName is documented to strip everything up to the last /
07:26:33 <mauke> for "portability"
07:26:44 <EvanR> the equivalent of Either ErrorCode Something is exactly what C libs give you
07:27:10 <mauke> errno is mapped to exceptions
07:27:20 <bitonic> EvanR: right.  I think we’d at least ought to have a module that exposes functions that work that way, and not go straight to exceptions
07:27:23 <mauke> but the available exception types are much coarser than what errno supports
07:28:06 <chrisdone> with the unix package you can get more immediate communication with the os
07:28:23 <chrisdone> but then pay for it by not being portable
07:28:42 <EvanR> windows has a unix layer ;)
07:28:56 <EvanR> taking care of the only non unix platform haskell supports at all
07:28:58 <mauke> errno is portable
07:29:31 <michaelt>  one of the fields of IOException is:  ioe_errno    :: Maybe CInt,     -- errno leading to this error, if any.
07:30:22 <mauke> there's no select() equivalent
07:30:49 <michaelt> God knows whether they stick to the implicit promise in "errno leading to this error, if any."
07:31:16 <mauke> yes, if it comes from a FFI function
07:31:36 <clrnd> how does Ruby's Raptor compare to Warp?
07:31:44 <mauke> http://hackage.haskell.org/package/base-4.7.0.1/docs/Foreign-C-Error.html#v:throwErrnoIfMinus1 and friends
07:32:10 <bitonic> “Disrupting the Ruby web server scene in 13 days”
07:32:13 <bitonic> is this a parody?
07:32:34 <chrisdone> a parodgy of Mozilla?
07:33:05 <bitonic> I didn’t know fancy marketing entered the micro benchmarks scene
07:33:25 <chrisdone> presumably raptor is written in c
07:33:28 <bitonic> (I’m referring to googling “ruby raptor”, which lead me to <http://www.rubyraptor.org/>)
07:33:30 <chrisdone> @quote ruby benchmarks
07:33:30 <lambdabot> No quotes for this person. Just what do you think you're doing Dave?
07:33:33 <EvanR> mauke: could be a good idea for a library
07:33:36 <chrisdone> @quote ruby
07:33:36 <lambdabot> dons says: [talking about killer haskell apps] yeah, they want a browser and an OS kernel to go along with all the ruby, python, erlang and perl browsers and kernels
07:33:47 <chrisdone> lambdabot: forget it (￣ー￣)
07:33:54 <bitonic> I mean that webpage is… weird
07:34:26 <bitonic> I know what it looks like, those advertisements for the new Mac gadget where things are 4x faster than the previous things
07:34:41 <clrnd> there's a post in HN discussing the implementation details
07:35:17 <chrisdone> that page does look like a parody
07:35:36 <chrisdone> new Ruby Snail, 4x faster than other snails
07:35:47 <bitonic> clrnd: it’s just a bit strange that they’re creating that kind of hype for a webserver.  that said, maybe it’s the best web server ever
07:35:55 <clrnd> jajaja
07:36:19 <pantsman> at first I assumed someone had figured out how to make Ruby fast, then I got to the bit where it says "actually we wrote C++"
07:36:29 <clrnd> bitonic, no idea, I just read it uses lot's of locks and manual memory management and felt a cold chill
07:36:46 <tdammers> pantsman: that's pretty much in line with the golden rule of writing performant PHP
07:37:12 <tdammers> which is, "don't write PHP, offload everything to the underlying C libraries"
07:37:20 <pantsman> tdammers: do people not notice the irony that "progress" in their lang community involves replacing $lang with highly optimised C++?
07:37:31 <bitonic> clrnd: oh right, this <http://www.rubyraptor.org/how-we-made-raptor-up-to-4x-faster-than-unicorn-and-up-to-2x-faster-than-puma-torquebox/>.  it’s a bit long :P
07:37:38 <tdammers> pantsman: probably not, no
07:37:49 <clrnd> that article is actually a nice read about web servers!
07:38:12 <pantsman> and after heartbleed etc, people *still* think it's cool to write stuff in memory-unsafe languages to squeeze out more perf
07:38:49 <bitonic> clrnd: I’ll read it if I have the time.  shame about the super marketing tone of the whole operation
07:39:21 <tdammers> I've said the same thing before, elsewhere: the predominant attitude is still "make it work, worry about security issues as they arise"; heartbleed and friends are just the beginning, we're about to experience a whole new world of pain unless this attitude gets fixed
07:39:24 <clrnd> absolutely. it got me interested in Warp anyway
07:40:12 <tdammers> dialogs like "your code is vulnerable; you can't do X here" - "but I *have* to do X, because features!"
07:40:50 <michaelt> clrnd: http://www.yesodweb.com/blog/2011/03/preliminary-warp-cross-language-benchmarks
07:41:12 <clrnd> michaelt, are you snoyman?
07:41:34 <michaelt> ha, no
07:41:34 <clrnd> well I said it beacuse I was reading that Warp PDF, but that link is also by him
07:41:46 <clrnd> http://steve.vinoski.net/pdf/IC-Warp_a_Haskell_Web_Server.pdf
07:42:25 <pantsman> I wonder if there are any benchmarks more recent than 2011?
07:43:20 <chrisdone> http://www.yesodweb.com/blog/2012/10/measuring-warp
07:45:22 <michaelt> oh here's a comparison warp v. tornado http://lbolla.info/blog/2012/09/02/tornado-vs-warp-vs-yesod with code
07:45:28 <clrnd> what is mighty?
07:45:57 <tdammers> if raw performance is your only metric, then something odd is at hand
07:46:12 <sivteck> @hackage mighttpd
07:46:12 <lambdabot> http://hackage.haskell.org/package/mighttpd
07:46:18 <chrisdone> there was a big improvement to warp in 2014 but i don't see benchmarks
07:46:50 <chrisdone> http://www.yesodweb.com/blog/2014/02/new-warp
07:47:08 <michaelt> tdammers: I was thinking clrnd 's other metric was "degree of high-levelness of the language" or something like that
07:47:20 <tdammers> michaelt: yeah, that makes somewhat more sense
07:47:40 <tdammers> also, scalability, features vs. what you need, security, particular performance characteristics, ...
07:48:54 <clrnd> oh I just wanted to compare design decisions
07:50:17 <bitonic> clrnd: from a skim it doesn’t look like they’re doing anything groundbreaking.  evented io with an event loop per thread, low level optimizations (HTTP parser in C, good behaved memory allocation)
07:51:03 <clrnd> so event loops per thread aren't new? I suspected it :P
07:51:28 <bitonic> clrnd: well that’s the most surprising thing I guess
07:51:44 <bitonic> usually you use one.  I don’t know if people did it before
07:53:03 <EvanR> theres no end to the ruby "app server" reinventing
07:53:32 <EvanR> no one bothered with fcgi because "fcgi is slow"
07:53:39 <beaky> how do i apply a function to all tuple members
07:54:16 <detrumi> beaky: You create functions for each tuple size
07:54:24 <detrumi> Or rather, there's not really a way
07:55:10 <EvanR> use something besides a tuple
07:58:47 <bergmark> beaky: you can do this with generics, but you should think twice about using a tuple here
08:00:06 <ThreeOfEight> you can do it with lenses
08:00:35 <ThreeOfEight> > over each (+1) (1,2,3)
08:00:37 <lambdabot>  (2,3,4)
08:00:45 <ThreeOfEight> only works up to 9 components though
08:01:03 <ThreeOfEight> because there is no Each instance for tuples with more components
08:01:43 <ThreeOfEight> but, yes, whatever you're doing, beaky, you can probably do it better another way
08:07:46 <asayers_> bitonic: looks like warp uses one event loop per capability: http://www.yesodweb.com/blog/2012/11/warp-posa
08:09:29 <bitonic> asayers_: oh, cool.  didn’t know they added that.
08:10:33 <clrnd> asayers_, that's the link I was looking for!
08:11:04 <asayers_> yeah, it took me a while to track it down too
08:11:39 <beaky> > let (x:xs) = [0..] in x
08:11:41 <lambdabot>  0
08:11:46 <beaky> :D
08:12:08 <bitonic> clrnd: he also says “Many have hit upon the idea of creating N event-driven processes to utilize N cores…”, so I’m clearly behind :P
08:12:32 <clrnd> jaja :D
08:16:00 * hackagebot yesod-dsl 0.1.1.21 - DSL for generating Yesod subsite to manage an RDBMS;  http://hackage.haskell.org/package/yesod-dsl-0.1.1.21 (TeroLaitinen)
08:17:16 <juloji> any francophones around?
08:18:04 <juloji> friend is trying to learn haskell but en francais
08:19:16 <michaelt> there is haskell-fr of course, but I don't know if folks are ever conscious there.
08:20:03 <tdammers> juloji: how does one learn a programming language in a natural language?
08:20:03 <zomg> ring ring ring ring, francophone
08:20:11 <zomg> *to the tune of bananaphone*
08:20:18 <juloji> michaelt: thanks, yeah 1500 vs 18 ;)
08:20:37 <michaelt> well, they're all on here yes
08:21:09 <juloji> aapparemment
08:21:30 <juloji> il est bien la
08:21:33 <bitonic> juloji: tell them about OCaml :P
08:22:03 <juloji> you raskells, scala is king
08:22:28 <cdk> @hoogle minBy
08:22:28 <juloji> but my friend wants to learn haskell - math head
08:22:29 <lambdabot> No results found
08:22:40 <cdk> @hoogle Ord b => (a -> b)
08:22:40 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
08:22:41 <lambdabot> Prelude ($) :: (a -> b) -> a -> b
08:22:41 <lambdabot> Data.Function ($) :: (a -> b) -> a -> b
08:22:45 <cdk> @hoogle Ord b => (a -> b) -> a -> a -> a
08:22:45 <lambdabot> Data.Ord comparing :: Ord a => (b -> a) -> b -> b -> Ordering
08:22:46 <lambdabot> Data.Function on :: (b -> b -> c) -> (a -> b) -> a -> a -> c
08:22:46 <lambdabot> Prelude maybe :: b -> (a -> b) -> Maybe a -> b
08:23:15 <bitonic> juloji: it’s tough without knowing English.  most of the resources are in English
08:23:33 <tdammers> most of the identifiers are derived from English, too
08:23:50 <sivteck> hrm
08:23:52 <michaelt> what about Apprendre Haskell vous fera le plus grand bien !
08:24:00 <sivteck> will google translate help? ;d
08:24:07 <EvanR> keywords in english is nothing new in programming languages
08:24:22 <EvanR> docs only in english is bad
08:24:23 <tdammers> indeed
08:24:27 <tdammers> well
08:24:43 <tdammers> I have a hard time imagining how people learn programming without knowing any English
08:24:45 <juloji> found LYaH in french
08:24:47 <michaelt> juloji suggested the friend isn't a programmer
08:24:59 <EvanR> learn gods language: english
08:25:03 <tdammers> haha
08:25:11 <michaelt> there ought to be Prelude.Fr and so on.
08:25:16 <clrnd> lol
08:25:22 <EvanR> Prelude.Eo
08:25:27 <tdammers> "By God, if English is good nuff f'r me, it oughtta be good nuff f'r any'un!"
08:25:28 <clrnd> cabeza :: [a] -> a
08:25:32 <biglama> juloji: i'm french, but still a beginner at haskell
08:25:39 <juloji> EvanR: that is not true, everyone knows god is french
08:26:26 <michaelt> biglama: and you're not in #haskell-fr helping juloji's friend ...
08:27:34 <biglama> michaelt: well, I'm not sure he would want *my* help :p
08:28:22 <michaelt> biglama: just kidding; sounds like he or she might though.
08:28:52 <juloji> well cool, maybe haskell-fr will wake up at so,e point
08:29:21 <chrisdone> i write in american english spelling
08:29:23 <biglama> 21 people, that's not much
08:29:28 <chrisdone> just because that's the programming standard
08:30:02 <chrisdone> if you learn music most of the words are italian
08:30:06 <chrisdone> no big deal
08:30:23 <clrnd> haskell.es has 3 people, that's not reassuring
08:30:29 <bitonic> chrisdone: I never realized that in 18 years of living in Italy
08:30:43 <chrisdone> bitonic: never realised what?
08:31:03 <bitonic> the music bit
08:31:22 <clrnd> but haskell is scotish ...
08:31:23 <EvanR> data MusicBit = Music | MoreMusic
08:31:24 <clrnd> oi
08:31:38 <juloji> alright, well, french probably is not happening but can he create a chess game or checkers in haskell?
08:32:15 <michaelt> a French prelude might be a good idea just so we could then rip off the expressions and use them for Data.ByteString, Data.Vector and just import the french without qualifying ....
08:32:27 <juloji> he is fairly strong in math and chess
08:32:55 <juloji> I told him just learn the basics but he needs a goal
08:33:13 <tdammers> import Prélude
08:33:20 <tdammers> hmm, not quite
08:33:23 <biglama> at the moment, i'm trying to make mathematecal drawings with the diagrams library
08:33:25 <tdammers> importez Prélude
08:33:29 <juloji> so checkers in haskell I assume is pretty trivial
08:33:34 <biglama> it may be interested
08:33:43 <EvanR> typesafe checkers?
08:33:52 <beaky> whats the difference between *** and &&&
08:34:19 <biglama> s/it/he/
08:34:27 <prophile> :t (***)
08:34:28 <lambdabot> Arrow a => a b c -> a b' c' -> a (b, b') (c, c')
08:34:31 <prophile> :t (&&&)
08:34:32 <lambdabot> Arrow a => a b c -> a b c' -> a b (c, c')
08:34:34 <prophile> ^
08:34:35 <bernalex> beaky: well they do different things
08:34:44 <bernalex> as demonstrated by the typesigs ^
08:34:51 <michaelt> > show &&& (+1) $ 4
08:34:53 <lambdabot>  ("4",5)
08:35:09 <prophile> a &&& b = arr (\x -> (x, x)) >>> (a *** b)
08:35:34 <beaky> &&& and *** are quite confusing :D
08:35:34 <zort> Why does lambdabot not like longer-than-two tuples?:
08:35:34 <zort> @pl \(_,_,_) -> 3
08:35:34 <lambdabot> (line 1, column 7):
08:35:35 <lambdabot> unexpected "_"
08:35:35 <lambdabot> ambiguous use of a non associative operator
08:36:07 <beaky> (not really confusing just hard to imagine a nice use for them :D)
08:36:08 <bernalex> zort: that smiley looks like hitler
08:36:20 <chrisdone> a french prelude would be just another way to keep the frenchies in their isolation. i'd prefer they joined the wider community personally
08:36:37 <zort> I was actually just typing a question mark and a colon
08:36:40 <bernalex> beaky: I use join (***) a lot (aka "both")
08:36:46 <michaelt> chrisdone: I guess youre against North Korean Prelude too?
08:36:54 <chrisdone> north koreean prelude is best prelude
08:36:55 <bernalex> zort: I meant the tuple
08:37:05 <vanila> How about no prelude at all?
08:37:12 <vanila> then people can import whatever they like
08:37:30 <Iceland_jack> People already can
08:37:32 <chrisdone> there's a whole french subcommunity of haskellers that keep to themselves. it's nice and all but feels like missing out
08:37:33 <michaelt> import qualified Prelude as Prelude.Imperialist
08:37:40 <aloiscochard> vanila: you can do that I think
08:37:51 <aloiscochard> Prelude.fundamentalist
08:37:59 <sivteck> Prelude.Nihilistic
08:38:02 <chrisdone> comparatively there are a bunch of russian haskellers who'll venture across into algoville
08:39:44 <juloji> great opportunity to learn english AND haskell
08:40:18 <chrisdone> maybe once china becomes the new world power we'll all be learning chinese =)
08:42:07 <juloji> aloiscochard: loves scala
08:43:05 <aloiscochard> juloji: pardon?
08:43:30 <juloji> no need to deny it
08:43:53 <juloji> you have been seen on the other side, praising the dark side
08:45:56 <juloji> anyway I am writing under my friend's account, forgive him my transgressions
08:46:22 <aloiscochard> hahaha
08:46:36 <juloji> going back to my place, see you all on #scala
08:46:42 <aloiscochard> juloji: shut! don't telll others ;-)
08:46:43 <aloiscochard> see you there
08:46:57 <clrnd> so how do I go about parallelizing a monad transformer?
08:47:10 <clrnd> EitherT
08:47:43 <juloji> A+ tout le monde
08:49:42 <clrnd> monad-parallel doesn't provide an obvious path
08:49:49 <clrnd> (AFAIK)
08:50:07 <bitonic> clrnd: you run it and parallelize the IO actions, then execute the pure Either computation.  you can be helped by <http://hackage.haskell.org/package/monad-control-0.2.0.3/docs/Control-Monad-Trans-Control.html>
08:50:40 <clrnd> bitonic I may love you
08:50:41 <beaky> cani convert any where clause into let expresion
08:50:44 <swook> I love bitonic too
08:51:05 <bitonic> swook: oh hi lol
08:51:22 <carter> NemesisD: OH HAI
08:51:56 <NemesisD> carter: Hey
08:52:48 <bitonic> clrnd: you can probably be helped by something like <http://hackage.haskell.org/package/async>
08:53:07 <bitonic> maybe you can even build some nice combinator combining the two.  maybe it exists already
08:54:40 <clrnd> mapConcurrently damn
08:56:57 <bitonic> clrnd: that code is hard to write on your own, because exceptions.  so using async is much much better
08:58:35 <beaky> how do i exclude a imported function from module
08:58:50 <clrnd> ok gotta try that later
08:59:18 <beaky> oh i should use import Module hiding f
09:00:43 <bitonic> beaky: you should.  add some parens
09:06:02 * hackagebot mangopay 1.10 - Bindings to the MangoPay API  http://hackage.haskell.org/package/mangopay-1.10 (FelipeLessa)
09:06:04 * hackagebot yesod-mangopay 1.10 - Yesod library for MangoPay API access  http://hackage.haskell.org/package/yesod-mangopay-1.10 (FelipeLessa)
09:20:12 <hsk8> Read the first Monad chapter in LYAH. Turns out that Monads, just like Functors and Applicatives, are not that complicated!
09:20:19 <hsk8> Just scary words that's all.
09:21:50 <dagle> hsk8: "A monad is just a monoid in the category of endofunctors, what's the problem?"
09:22:08 <hsk8> Well, that's chinese to me...
09:22:18 <hsk8> Who said that
09:22:43 <josephle> I believe it came from here: http://james-iry.blogspot.com/2009/05/brief-incomplete-and-mostly-wrong.html
09:22:45 <dagle> I don't know if it was Philip Wadler that said it first but he tends to repeat it.
09:23:12 <josephle> although someone else may have said it first
09:23:36 <hsk8> Hehe
09:23:38 <dagle> hsk8: It's a joke trying to "explain" it by making it worse. :)
09:23:43 <hsk8> :D
09:23:52 <Iceland_jack> I wouldn't mind if that joke went away :)
09:24:35 <josephle> Iceland_jack: to be fair, understanding why that explanation is true is a pretty fun exercise
09:24:42 <sivteck> @quote copumpkin endofunctors
09:24:42 <lambdabot> copumpkin says: a monad is just a lax functor from a terminal bicategory, duh. fuck that monoid in category of endofunctors shit
09:25:12 <dagle> Last time I made it (really made it), I had to explain monads, monoids and functors for 1 hour.
09:25:20 <Iceland_jack> Sure, it's pretty unrelated to programming in Haskell
09:25:22 <dagle> made it = that joke.
09:25:42 <Iceland_jack> It gives people the impression that it's more difficult than it is, the Lisp communities did similar things
09:26:11 <EvanR> theres no end to the dissolving the lisp jargon
09:26:58 <sivteck> Functors in hask are endofunctors right?
09:27:17 <dagle> Pfft, you just have to just have to jump in, with a current-continuation.
09:28:36 <benmachine> sivteck: anything that you can define an instance of the typeclass Functor is an endofunctor
09:30:22 <sivteck> ok (i was reading http://www1.eafit.edu.co/asicard/pubs/cain-screen.pdf )
09:30:27 <benmachine> there are many other phenomena in Haskell that you might want to describe with functors, with varying amounts of usefulness
09:30:51 <stepkut> if I have a function, foo :: ExpQ -> ExpQ , is there a way to use it like, [foo| someExpr |] instead of $(foo [| someExpr |])
09:31:03 * hackagebot snaplet-postgresql-simple 0.6 - postgresql-simple snaplet for the Snap Framework  http://hackage.haskell.org/package/snaplet-postgresql-simple-0.6 (DougBeardsley)
09:31:49 <benmachine> stepkut: [foo| blah |] looks like a quasiquote, which I think is not what you want
09:34:07 <stepkut> benmachine: it sort of is. Normally for things like [jmacro| blah |], etc, the DSL in the QQ is something other than Haskell. In this case my quasiquoted language has the same syntax has Haskell. But I need to apply a few transformations to it. $(foo [| e |]), works .. but is uglier than [foo| |]
09:34:38 <benmachine> stepkut: consider parsing it with say, haskell-src-exts?
09:35:19 <benmachine> stepkut: I think similar things have been done with this package I maintain http://hackage.haskell.org/package/haskell-src-meta but honestly it only kinda works
09:35:22 <stepkut> benmachine: right.. I could use haskell-src-exts+haskell-src-meta to get back to TH.. which is a bit too crazy :)
09:35:34 <benmachine> it depends what your transformations are, I guess
09:35:40 <benmachine> you could use HSE and then go straight to TH
09:35:54 <bitonic> stepkut: ideally you’d be able to use the ‘e’ default quasi-quoter.  I don’t think you can though
09:36:00 <benmachine> if your transformations are significant enough that you wouldn't be using the straight HSE -> TH conversion much anyway
09:36:22 <bitonic> stepkut: I think it’s some special form rather than a defined quasi-quoter that you can reuse
09:36:28 <stepkut> benmachine: how do you go straight from HSE to TH? Don't you need HSM to bridge the gap?
09:36:52 <benmachine> stepkut: well, I mean, if you're not turning case expressions into case expressions or ifs into ifs, HSM doesn't really save you work
09:37:01 <stepkut> bitonic: right.. it would be nice if the parser was exposed so it could be reused :-/. Anyway I will suffer with $(foo [| e |]) I guess
09:37:02 <benmachine> stepkut: hence it depends how radical your transformations are
09:37:35 <bitonic> stepkut: the other option is to define a quasi-quoter that generates $(foo [| … |])
09:37:47 <bitonic> except that you cant
09:37:50 <stepkut> benmachine: it's not a matter of saving work.. it is the fact that HSE and TH use completely different types for representing the syntax tree and HSM provides the function to convert between those types?
09:38:21 <bitonic> going through haskell-src-exts seems like a bad idea
09:38:29 <stepkut> bitonic: yeah.. seems like 'except you can't do that' is the motto of TH
09:38:52 <bitonic> stepkut: well, that limitation kinda makes sense though, if you want to stage TH nicely
09:38:52 <benmachine> stepkut: right, but you only need that function if you're preserving most of the syntax
09:39:38 <benmachine> if your DSL is only superficially like Haskell or if you perform radical enough transformations, then writing your transformations as HSE -> TH is just as easy as writing them HSE -> HSE and then using HSE -> TH from HSM
09:40:04 <stepkut> benmachine: what I am trying to do is transform a do block to transform 'do x <- f' into 'do x <- autoLift f'
09:40:15 <bitonic> that seems long winded and fragile, considering that the alternative is typing a few more characters
09:41:01 <benmachine> stepkut: oh right, fair enough
09:41:03 * hackagebot creatur 5.7.3 - Framework for artificial life experiments.  http://hackage.haskell.org/package/creatur-5.7.3 (AmyDeBuitleir)
09:41:51 <stepkut> bitonic: perhaps. The problem is this test suite already exits with hundreds of tests like the ones in here, https://github.com/dmjio/stripe-haskell/blob/master/tests/Test/Transfer.hs
09:42:10 <texasmynsted> would somebody point me to the right place for learning how module loading works?
09:42:14 <texasmynsted> when I run runhaskell bob_test.hs, I get the error Could not find module `Bob'
09:42:26 <texasmynsted> I have a file called bob.hs https://gist.github.com/mmynsted/54c994fbca14563336b2
09:42:26 <bitonic> stepkut: I meant using haskell-src-exts
09:42:36 <mauke> texasmynsted: call it Bob.hs
09:42:40 <texasmynsted> and a file called bob_test.hs https://gist.github.com/mmynsted/3d453a1da98aee291920
09:42:46 <stepkut> in those tests it is assumed that all the functions like, createRecipientByBank, are monadic. But in the new version of the code, they are just pure functions and you need to call another function to actually invoke them
09:42:47 <texasmynsted> whaaat?
09:42:54 <texasmynsted> It cares about the case of the name of the file?
09:42:56 <texasmynsted> Ok
09:42:59 <texasmynsted> I can try that
09:43:06 <mauke> depends on the file system
09:43:18 <stepkut> but changing almost every, a <- f, to a <- stripe f, seems very noisy
09:43:27 <texasmynsted> but the name is defined in the module declaration in the file
09:43:34 <bitonic> stepkut: I’d rather to that than TH
09:43:37 <stepkut> so I can either use rebindable syntax, or I can use TH
09:43:54 <glguy> texasmynsted: When you write "import Bob" it looks for a file "Bob.hs"
09:44:15 <lucs> How about this when ":set +m" is active?: "A multi-line input is terminated with an empty line *or a trailing blank*"
09:44:56 <texasmynsted> heh.  That fixed it.  Thank you.  I did not expect that
09:45:00 <lucs> Would that make sense?
09:46:04 <mauke> texasmynsted: are you new to linux(?)?
09:46:07 <stepkut> bitonic: what I'd really like to do is be able to defined a operator like, do x <-s f, but I don't think that is possible
09:46:14 <texasmynsted> nope.
09:46:52 <stepkut> with TH maybe
09:47:12 <texasmynsted> It seems to me it should be able to search the local haskell files for the correct module name regardless of file name
09:47:24 <texasmynsted> Like module Foo inside a file name bar.hs
09:47:24 <bitonic> stepkut: nope.  I’d be careful in deciding the interface for those things and then refactor everything with explicit lifting
09:47:29 <bitonic> gotta go, good luck!
09:47:58 <texasmynsted> whatever
09:49:38 <favetelinguis> so I have realized that im totatly lost when it comes to how foldr and foldl works in a recursive way. Look at this code http://lpaste.net/114103, and please tell me how it expands, no mather how i try to get it to the way i have described i dont get it right
09:50:57 <glguy> > foldl (\ x y -> 10 * x + y) 0 [a,b,c,d]
09:50:58 <lambdabot>  10 * (10 * (10 * (10 * 0 + a) + b) + c) + d
09:51:00 <glguy> favetelinguis: ^
09:51:30 <favetelinguis> magic :)
09:53:03 <favetelinguis> > 1 + 4
09:53:04 <lambdabot>  5
09:54:52 <L8D> :t pure
09:54:53 <lambdabot> Applicative f => a -> f a
09:54:57 <L8D> :t return
09:54:58 <lambdabot> Monad m => a -> m a
09:55:09 <chrisdone> :t point
09:55:10 <lambdabot>     Not in scope: ‘point’
09:55:10 <lambdabot>     Perhaps you meant ‘print’ (imported from Prelude)
09:55:29 <chrisdone> =(
09:55:46 <L8D> :t return
09:55:47 <lambdabot> Monad m => a -> m a
09:55:49 <L8D> whoops
09:55:58 <chrisdone>  :t point
09:55:58 <chrisdone> Pointed p => a -> p a
09:56:00 <chrisdone> =)
09:56:09 <L8D> oh hey it's chrisdone !
09:56:16 <chrisdone> oh hey it's er
09:56:18 <chrisdone> you =)
09:56:28 <L8D> I think I remember people mentioning you as some kind of haskell celeb on christmas day
09:56:40 <L8D> I was reading through the logs for lols
09:56:50 <chrisdone> lol cheeky devils
09:56:55 <L8D> are you a celeb in the haskell community?
09:57:00 <chrisdone> nope
09:57:39 <chrisdone> Pointed and Copointed are nice classes
09:57:58 <L8D> so in the cases that a constructor is an applicative, monad and pointed would pure = return = point ?
09:58:16 <L8D> (at least morally)
09:58:35 <Fuuzetsu> chrisdone is all the celebs in one
09:58:38 <chrisdone> i think ish, but point doesn't require a functor
09:58:39 <__jim__> for some reason I thought pointed wasn't really used anymore, is that not the case?
09:58:55 <ReinH> __jim__: pointed doesn't have much going for it
09:59:18 <chrisdone> naysayer!
09:59:46 * ReinH shrugs
09:59:59 <chrisdone> it's good for when you don't want to impose monad/functor constraints
10:00:13 <chrisdone> e.g. Set
10:00:30 <ReinH> It doesn't have any laws.
10:00:36 <ReinH> Cats and dogs living together.
10:01:01 <ReinH> At least Buildable has laws https://www.fpcomplete.com/user/gbaz/building-up-to-a-point-via-adjunctions
10:01:11 <ReinH> And adjunctions. Yay adjunctions.
10:01:52 <__jim__> I see I have more reading to do lol
10:02:18 <ReinH> L8D: yes, pure, return and point are supposed to be equivalent
10:02:50 <ReinH> it's morally {Pointed,Functor} < Applicative < Monad
10:02:56 <L8D> is it just me or is using Haskell through only do-blocks and mvars still better than using ruby?
10:03:08 <Fuuzetsu> most things are better than using ruby
10:03:11 <ReinH> L8D: Haskell is my favorite imperative language
10:03:37 <L8D> I don't get why people are still using those silly scripting languages and no one has offered a good explanation
10:03:50 <L8D> I can understand using Clojure or Scala
10:03:51 <Fuuzetsu> we need to start using words like dynamic
10:03:57 <L8D> I can understand using JavaScript...
10:04:00 <mauke> perl is fun :-)
10:04:05 <glguy> #haskell is the wrong channel for figuring out the merits of other language
10:04:13 <dv-> python is pretty nice
10:04:19 <mauke> dv-: incorrect
10:04:30 <mauke> python is, in fact, concentrated satan
10:04:36 <L8D> dv-: why should I ever use python over Haskell outside of cases where I cannot compile Haskell properly?
10:04:47 <mauke> wanna continue in #haskell-blah?
10:04:50 <clrnd> dv-, not sure about that, isn't it the only modern language without decent concurrency?
10:04:58 <dv-> python has more libraries
10:05:12 <Fuuzetsu> I can easily generate more libraries than Python has
10:05:13 <L8D> Haskell has higher quality libraries
10:05:13 <ReinH> #haskell-blah, please
10:05:22 * clrnd is a full time python programmer and actually likes the language (sometimes)
10:05:51 <favetelinguis> How come if a fold needs to get the the last element in the list before it start to evaluate that foldr works on infinit list? You can newer reach the final element there, but foldl could just start with the first element in the list and use the accumulator with that?
10:05:59 <kadoban> clrnd: Concurrency is rarely decent. Python has concurrency anyway.
10:06:04 * hackagebot battlenet 0.1.0.1 - API client for Battle.Net  http://hackage.haskell.org/package/battlenet-0.1.0.1 (teozkr)
10:06:06 <EvanR> favetelinguis: it doesnt
10:06:06 * hackagebot battlenet-yesod 0.1.0.1 - Yesod integration for the battlenet package  http://hackage.haskell.org/package/battlenet-yesod-0.1.0.1 (teozkr)
10:06:31 <ReinH> @src foldr
10:06:31 <lambdabot> foldr f z []     = z
10:06:31 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
10:06:51 <ReinH> favetelinguis: foldr does not need to get the last element of the list before it starts to evaluate.
10:06:58 <EvanR> @src foldl
10:06:58 <lambdabot> foldl f z []     = z
10:06:58 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
10:07:32 <L8D> favetelinguis: fold does not however actually get to evaluate anything when working on infinite lists
10:07:44 <L8D> finished evaluating*
10:07:45 <albeit> ReinH: Something just clicked about foldr/foldl after you just said that... thanks!
10:07:56 <L8D> favetelinguis: there is scanl and scanr
10:08:02 <ReinH> favetelinguis: consider the case of head (foldr (:) 0 [1,2])
10:08:07 <ReinH> @src head
10:08:07 <lambdabot> head (x:_) = x
10:08:07 <lambdabot> head []    = undefined
10:08:14 <L8D> > take 10 (scanl (+) [1..])
10:08:15 <lambdabot>  Couldn't match expected type ‘[a]’
10:08:15 <lambdabot>              with actual type ‘[[t0]] -> [[t0]]’
10:08:23 <L8D> > take 10 (scanl (+) 1 [1..])
10:08:25 <lambdabot>  [1,2,4,7,11,16,22,29,37,46]
10:08:28 <ReinH> head (foldr (:) 0 [1,2]) needs to evaluate enough of foldr to produce a (:) constructor:
10:08:48 <L8D> ReinH: touche
10:08:53 <ReinH> head (1 : foldr (:) 0 [2])
10:09:09 <ReinH> now by the definition of head, the tail of the list is never evaluated
10:09:12 <Denommus> is there any GUI library with a good DSL for creating the layouts?
10:09:31 <ReinH> albeit: :)
10:09:49 <favetelinguis> phew, thanks to late to get this now
10:09:54 <favetelinguis> will try again tomorrow
10:09:56 <ReinH> > head (foldr (:) 0 [1,2])
10:09:58 <lambdabot>  No instance for (GHC.Show.Show a0)
10:09:59 <lambdabot>    arising from a use of ‘M658522845748449128223694.show_M6585228457484491282...
10:09:59 <lambdabot>  The type variable ‘a0’ is ambiguous
10:09:59 <lambdabot>  Note: there are several potential instances:
10:09:59 <lambdabot>    instance [safe] GHC.Show.Show
10:10:38 <ReinH> woops
10:10:40 <ReinH> > head (foldr (:) [] [1,2])
10:10:42 <lambdabot>  1
10:12:27 <crobbins-afk> chrisdone: is there a way to use ghci-ng's loc-at command to get source spans for library code?  for instance, if i `cabal get base` and want to jump to the source of putStrLn
10:12:53 <beaky> must main always be type IO ()
10:13:04 <Fuuzetsu> IO a
10:16:05 * hackagebot pugixml 0.2.0 - pugixml binding.  http://hackage.haskell.org/package/pugixml-0.2.0 (HirotomoMoriwaki)
10:16:17 <chrisdone> crobbins: it needs to be able to load the code in, i think it'd require additional work to make it aware of library meta data
10:16:55 <crobbins> chrisdone: ah ok, thanks!
10:17:48 <ReinH> crobbins: you can use codex for that https://hackage.haskell.org/package/codex
10:18:53 <crobbins> thanks ReinH, when i'm using vim i love codex, but for this task i'm working on an IDE plugin
10:19:07 <crobbins> i very well might leverage codex for a lot of it, particularly downloading the library source
10:26:49 <narendraj9> > foldr (\x y -> x * 10 ^(y `div` 10 + 1) + y) 0 [1,2,3,4]
10:26:54 <lambdabot>  mueval: ExitFailure 1
10:27:27 <narendraj9> Why isn't it terminating?
10:28:00 <narendraj9> > foldr (\x y -> x * 10 ^((y*10) `div` 10) + y) 0 [1,2,3,4]
10:28:03 <EvanR> > 10 ^ 1000000
10:28:05 <lambdabot>  mueval: ExitFailure 1
10:28:05 <lambdabot>  1000000000000000000000000000000000000000000000000000000000000000000000000000...
10:28:06 <mauke> > foldr (\x y -> x * 10 ^(y `div` 10 + 1) + y) 0 [1,2,3,4] :: Expr
10:28:11 <lambdabot>  mueval-core: Time limit exceeded
10:29:40 <narendraj9> > foldr (\x y -> x * 10 ^((y*10) `div` 10) + y) 0 [1,2]
10:29:42 <lambdabot>  102
10:29:42 <ReinH> Can you just replace it with 0?
10:30:02 <ReinH> Oh, precedence
10:30:25 <narendraj9> > foldr (\x y -> x * 10 ^((y*10) `div` 10) + y) 0 [1]
10:30:26 <lambdabot>  1
10:30:46 <Denommus> why are we folding so much?
10:31:10 <narendraj9> It's easy to do it with foldl. I was trying to find a foldr version.
10:31:25 <ReinH> narendraj9: foldr is the wrong choice.
10:31:31 <narendraj9> Nothign serious here.
10:31:33 <ReinH> you want foldl'
10:32:23 <narendraj9> ReinH: Yes. But still what would be a foldr version.
10:32:33 <ReinH> What you have, it's just too inefficient to work.
10:33:13 <glguy> > foldr (\x rec acc -> rec (acc * 10 + x)) id [1,2,3,4] 0
10:33:14 <lambdabot>  1234
10:33:35 <narendraj9> glguy: wow!
10:33:48 <mada> glguy++
10:34:37 <glguy> that's just the foldl version using foldl implemented with foldr
10:35:02 <ReinH> Oh, that's what you were trying to do
10:35:07 <phaazon> hm… https://github.com/phaazon/ash/blob/master/src/Ash.hs#L26 I got this EDSL type (E). Is there a way I can compile it using a typeclass or somekind of similar idea?
10:36:03 <narendraj9> glguy: This always confuses me. I spend so much time with Read World Haskell's question about this conversion. Don't get it yet.
10:36:13 <narendraj9> *spent
10:36:35 <k0ral> could someone help me on this: http://lpaste.net/114112
10:36:37 <ReinH> phaazon: "compile it using a typeclass"?
10:36:54 <glguy> narendraj9: I haven't seen RWH's explanation, but this is how I tried to show it: https://www.reddit.com/r/haskell/comments/2892a9/someone_asked_me_to_derive_foldl_from_foldr_is/ci8yp1b
10:37:26 <k0ral> basically, GHC complains about an ambiguous type, but as the function doesn't use that ambiguous type, I expected it wouldn't hurt
10:37:27 <phaazon> ReinH: yeah, well
10:37:33 <phaazon> compile it to String for instance
10:37:33 <chrisdone> reinh: yeah, some laws are always desirable
10:37:49 <phaazon> I don’t see how to handle the lambda and app, for instance
10:37:51 <phaazon> (:$)
10:38:16 <narendraj9> glguy: Thanks! :-)
10:38:48 <phaazon> ReinH: or for instance, V2
10:39:25 <phaazon> well nevermind, I think I know right now
10:45:39 <chrisdone> reinh: i think similar to Default, there're some classes that are plain useful and someone needs to come up with a way to make them lawful. as said in the post, the attempts to lawify in this case excludes one set of types or excludes another set
10:47:33 <chrisdone> Buildable1's `singleton' method seems redundant
10:47:45 <chrisdone> as “fromNEL :: NEL a -> f a” seems sufficient
10:50:18 <chrisdone> otherwise you might as well add cosingleton :: f a -> a to Foldable1
10:51:38 <chrisdone> analogous to listToMaybe
10:52:00 <chrisdone> (or extract)
10:53:24 <favetelinguis> foldr is a homomorphism over lists but am i correct to say that foldl is not a homomorphism over lists
10:55:04 <ReinH> favetelinguis: what does it mean to be a list homomorphism?
10:56:01 <favetelinguis> that is preserve the structure of the list
10:56:09 <johnw>  the algebraic structure
10:56:16 <ReinH> favetelinguis: and what structure is that?
10:56:43 <johnw> foldr is not a homomorphism over lists either, it can result in a non-list
10:57:41 <favetelinguis> im thinking about it as a list is defined as a:b:c:[] and any foldr would be for example a+b+c+b+0 they are the same
10:57:49 <favetelinguis> but foldl would not look like this
10:58:25 <ReinH> johnw: A list homomorphism is a function h for which exists a binary operator <+> such that h (xs ++ ys) = h xs <+> h ys
10:58:30 <ReinH> (see https://www.cs.auckland.ac.nz/research/groups/CDMTCS/researchreports/005thirdht.pdf)
10:59:05 <ReinH> neither foldl nor foldr are list homomorphisms
10:59:21 <johnw> ReinH: will read! thanks
11:00:07 <ReinH> but a function h is a list homomorphism if it can be expressed as *both* a foldl and a foldr: f = foldr (<<) e; f = foldl (>>) e; for some (<<) and (>>)
11:00:17 <ReinH> That's the "third list homomorphism theorem"
11:00:31 <ReinH> I said h and then f, sorry
11:01:01 <ReinH> johnw: Bird uses list homomorphisms all the time in divide-and-conquer type optimizations :)
11:02:07 <favetelinguis> so / is the obv function that is not a list homomorphism
11:02:07 <ReinH> foldr constructs a *Church encoding* of a list (johnw will now correct me with the name I can't rememb er)
11:02:09 <ReinH> foldl does not
11:04:20 <josephle> I believe church encoding is right (johnw can now correct both of us :P)
11:04:34 <johnw> Boehm-Berarducci :)
11:04:47 <johnw> as long as Oleg isn't around, Church is understood
11:08:14 <ReinH> foldr f z replaces the constructors of the list (cons and empty) with f and z respectively.
11:11:07 * hackagebot highlighting-kate 0.5.11 - Syntax highlighting  http://hackage.haskell.org/package/highlighting-kate-0.5.11 (JohnMacFarlane)
11:14:11 <ReinH> favetelinguis: So you were right about there being a connection between foldr and lists, wrong about its name. ;)
11:18:50 <__jim__> 41
11:18:56 <__jim__> my bad, wrong buffer
11:19:01 <sinelaw> 42, anyway
11:19:06 <__jim__> good catch
11:19:23 <sinelaw> off by one. story of my life
11:19:54 <johnw> lol
11:20:06 <monochrom> switching between 0-based indexing and 1-based indexing causes a lot of off-by-1 errors :)
11:21:07 * hackagebot cassava-streams 0.1.1.0 - io-streams interface for the cassava CSV library.  http://hackage.haskell.org/package/cassava-streams-0.1.1.0 (PeterJones)
11:22:09 <sbrg> Anyone remember an article(or series of articles) where someone goes into some detail wrt analyzing core output? What I'm looking for specifically are the flags he used to remove some of the extraneous content in the output, which cleaned it up and made it easier to read and understand.
11:23:12 <sivteck> this one? http://blog.ezyang.com/2011/04/tracing-the-compilation-of-hello-factorial/
11:23:42 <sbrg> sivteck: I think so, yes. Thanks.
11:25:12 <snyp> ok i am back to learning haskell after 2 months... everytime i see these functions, which usually deal with monads, my brain sort of starts right from the basic and doesn't get satisfied until it creates the whole chain or whatever mentally . Is this how you learn it, or do you deliberately supress that urge?
11:25:41 <sinelaw> snyp, example?
11:25:43 <mauke> monads are a red herring
11:25:57 <mauke> (this is not where the magic is)
11:26:19 <snyp> sinelaw: StateMonad for example.
11:26:37 <snyp> State
11:26:41 <sinelaw> snyp, skip it
11:26:41 <snyp> also, Reader
11:26:50 <snyp> sinelaw: Writer is simple
11:26:57 <snyp> sinelaw: OK
11:27:07 <sinelaw> I learnt about all of those long after starting
11:27:15 <sinelaw> snyp, you can write a lot of code without them
11:27:23 <snyp> sinelaw: ah
11:27:29 <vanila> snyp, I look at monad stuff in two ways: Primarily as a programming language in its own right, and secondly how its implemented and interfaces with haskell
11:27:34 <merijn> snyp: I have a bunch of fairly doable homework exercises I give people to understand the State monad
11:27:53 <snyp> merijn: do you have a url?
11:28:09 <JordiGH> I suppose someone has proposed keyword arguments and has had this proposal rejected? I rather miss these from OCaml. Why aren't they in Haskell?
11:28:10 <merijn> snyp: Try and implement the following: https://gist.github.com/merijn/098106abd45c940dab09
11:28:13 <vanila> so in list monad  a <- [x,y,z]  would be thought of as letting a be a value taken from that list nondeterministically
11:28:23 <snyp> merijn: ok
11:29:49 <snyp> vanila: yeah
11:30:19 <snyp> and there's no function a is being funneled to.
11:30:26 <merijn> snyp: But yeah, as others point out it's not that useful to "learn" monads, they're a pattern that keeps reoccurring and it requires using and trying many of those patterns before you get an intuition
11:30:33 <snyp> merijn: yeah
11:30:44 <snyp> i'm sort of reaching that conclusion
11:31:02 <merijn> snyp: There is a function it is being funneled into, I also recommend beginners to avoid do-notation and manually use >>= and >> to see what's going on
11:31:03 <fizbin> :t aside
11:31:04 <lambdabot> (Choice p, Applicative f) => APrism s t a b -> p (e, a) (f (e, b)) -> p (e, s) (f (e, t))
11:31:10 <erisco> data X = X1 (A -> (Q, X)) | X2 R    --  I am seeing a pattern like this and am wondering if it is captured by an existing abstraction
11:31:11 <vanila> of course it's sugar for  [x,y,z] >>= \a -> ...
11:31:15 <mauke> JordiGH: someone has implemented keyword args as a library
11:31:15 <vanila> it's a syntax error on its own
11:31:17 <snyp> merijn: ah.
11:31:23 <merijn> snyp: I recommend reading https://en.wikibooks.org/wiki/Haskell/do_Notation
11:31:32 <merijn> snyp: It explains how to translate do-notation
11:31:36 <JordiGH> mauke: Oh? Do you know where?
11:31:37 <vanila> but you can give it meaning on its own when you think about it as part of some new PL
11:31:47 <mauke> @hackage hlist
11:31:47 <lambdabot> http://hackage.haskell.org/package/hlist
11:32:02 <merijn> snyp: Which is what's hiding the function in "a <- [x,y,z]" if you rewrite it without do notation you'll immediately see where said function is hiding :)
11:32:12 <erisco> the concept is a computation which does some work on data A, then pauses looking for additional information of type A indicated by Q, and repeats until the result R is obtained
11:32:27 <albeit> erisco: I'd be interested in that too, but can't help
11:33:13 <merijn> snyp: Do notation is very nice and readable, but until you know how to rewrite the code *without* do notation, I believe it can just add to the confusion of not understanding what's going on.
11:33:14 <JordiGH> mauke: Nu? This? http://hackage.haskell.org/package/HList
11:34:02 <mauke> JordiGH: http://okmij.org/ftp/Haskell/types.html#HList
11:34:10 <mauke> trying to find good documentation for it
11:34:27 <snyp> i know about the do notation, merijn.
11:34:29 <snyp> merijn: i have read that. actually i got frustrated with haskell and spent the whole october reading Real World Ocaml. :| ahaha.
11:35:00 <JordiGH> mauke: That's not quite the same, is it? It's not going to provide you with a simple syntax for naming the arguments.
11:35:27 <JordiGH> mauke: I suppose it's an attempt to do something like heterogenous hashmaps from dynamic languages.
11:35:35 <erisco> albeit, why would you be interested?
11:35:40 <JordiGH> Dynamically typed, I mean.
11:35:44 <snyp> ocaml is way simpler. but my interests lie in programming languages and i still think learning haskell would make me learn a lot of other theory.
11:35:51 <albeit> erisco: Sounds interesting and useful
11:36:03 <snyp> and haskell seems to have a bigger community...
11:36:08 <snyp> so i'm back
11:36:40 <johnw> snyp: if you're into OCaml and theory, you might like http://www.cis.upenn.edu/~bcpierce/sf/current/index.html
11:36:59 <JordiGH> If you're just in it for the theory, learn SML.
11:36:59 <mauke> JordiGH: http://hackage.haskell.org/package/HList-0.3.4.1/docs/Data-HList-Keyword.html#g:4
11:37:06 <zomg> My only frustration with Haskell (and FP langs in general) is the people who live in the fairyland of PL theory, and think that real world projects have some resembalance of that fairyland
11:37:10 <zomg> :D
11:37:30 <vanila> im stuck on one of the SF problems :/
11:37:43 <ReinH> zomg: You might be surprised by the amount of fairyland PL theory that can go into real world Haskell projects.
11:38:04 <zomg> Oh for sure, I'm sure when it comes to Haskell there is applicability
11:38:09 <snyp> johnw: that's on my reading list.
11:38:26 <zomg> but when you're talking about something else and then you have the helpful people piping in with suggestions that would never work =)
11:38:29 <snyp> thanks for the helpful advice guys. appreciate it.
11:38:36 <k0ral> Hello, could someone please help me on http://lpaste.net/114112 ?
11:38:39 <zomg> like.. let's make javascript devs learn haskell, I'm sure it won't take long at all
11:39:39 <JordiGH> mauke: idgi, kwapply?
11:39:46 <zomg> although to be honest no matter what it is you'll get the helpful advice you never asked for
11:39:48 <JordiGH> Is that I should be looking for?
11:39:54 <zomg> so probably not just FP related =)
11:40:11 <mauke> JordiGH: kwapply is for calling keyword functions
11:40:15 <JordiGH> Still looks like a far cry from somefunction ~namedarg1:arg1 ~namedarg2:arg2 of OCaml.
11:40:45 <josephle> erisco: your datatype looks like one of the internal datatypes of attoparsec
11:40:54 <mauke> kwapply somefunction (NamedArg1 .*. arg1 .*. NamedArg2 .*. arg2 .*. HNil)
11:41:14 <JordiGH> Yuck.
11:41:28 <JordiGH> any luck getting actual named arguments into Haskell?
11:41:50 <indiagreen> k0ral: how is GHC supposed to choose which “n” should it choose when checking the constraints?
11:42:08 <JordiGH> mauke: Also, my names have to be types?
11:42:12 <JordiGH> Double yuck.
11:42:14 <bitonic> I think the fastest way to named argument is anonymous records
11:42:19 <bitonic> *named arguments
11:42:33 <bitonic> JordiGH: it’s no that bad with TypeLits
11:42:37 <mauke> JordiGH: no, they can't be types
11:42:46 <vanila> I think you should import Control.Eff.State.Lazy
11:42:56 <fizbin> :t second
11:42:57 <lambdabot> Arrow a => a b c -> a (d, b) (d, c)
11:43:14 <JordiGH> mauke: Oh, I couldn't puzzle out what you were showing me. I thought NamedArg1 was a type name. I don't know much Haskell, what else besides types can be uppercase?
11:43:56 <JordiGH> bitonic: Hm, I didn't know records could be anonymous. That could work too, if I don't mind not having default values for unnamed arguments.
11:44:05 <mauke> JordiGH: ... I'm no longer interested
11:44:09 <josephle> erisco: I wonder if you can abstract that into a continuation
11:44:12 <JordiGH> mauke: Alright.
11:44:17 <ReinH> I'm sad that arrow stole "first" and "second" from bifunctor.
11:44:39 <k0ral> indiagreen: n isn't used, why should GHC have to choose anything in the first place ?
11:44:39 <erisco> josephle, I will look at that. I had only looked at continuations briefly and many moons ago ;)
11:45:16 <bitonic> JordiGH: they’re not.  but I’d think about named arguments as a record argument, at least in Haskell.  so either you define a record, or find some way to cheaply have anonymous records in Haskell, but there is no satisfactory solution imo
11:45:27 <ReinH> erisco: yeah, sounds like Cont or ContT to me...
11:46:08 * hackagebot Referees 0.0.0 - A utility for computing distributions of material to review among reviewers.  http://hackage.haskell.org/package/Referees-0.0.0 (PabloCouto)
11:46:24 <bitonic> JordiGH: in general I find that I almost never need anonymous named arguments.  I often have the need to pass some configuration around but that can be codified in a record.  it’s not ideal but I don’t find it too bad
11:47:27 <fragamus> the flattening in a monad looks something like this: T(T(X))-> T(X)     but... it never seems to me like two levels of "wrapping" ever exists to be flattened in any of the monads I know about
11:47:33 <bitonic> JordiGH: for a lesson on how you can mess up named argument, you can look at the named implicits in Agda
11:47:40 <bitonic> which work but in a surprising way :P
11:48:14 <JordiGH> bitonic: I'm just used to them from Python and Perl and I am happy with them in OCaml.
11:48:24 <bitonic> JordiGH: how do they work in OCaml?
11:48:53 <JordiGH> And I hate having to deduce what a particular type is by looking at the type annotation of a function. It feels like a lot of work that a simple one-word explanation can save me.
11:49:00 <bitonic> JordiGH: but I think the short answer is not to try to program like you do in Python/Perl/OCaml, because Haskell is going to make it awkward.  at least with respect to named args
11:49:00 <JordiGH> Er, what a particular argument is supposed to be.
11:49:21 <JordiGH> bitonic: Well, OCaml and Haskell are both ML-derived, they're pretty close in many ways.
11:49:28 <Iceland_jack> fragamus: What about 'concat :: [[a]] -> [a]'?
11:49:36 <clrnd> JordiGH, the type tell's you what is it and also enforces it, it's pretty rad!
11:49:42 <bitonic> JordiGH: they’re quite different in how they handle records and such
11:50:04 <JordiGH> clrnd: If I just see (a -> b) that doesn't tell me diddly squat other than "generic function".
11:50:05 <fragamus> Iceland_jack: ok lemme look at bind operator for list monad...
11:50:07 <bitonic> JordiGH: and record are a source of awkwardness for many new and old Haskell users, but that’s the current situation
11:50:14 <JordiGH> clrnd: and typically it's not just any old function.
11:50:59 <bitonic> JordiGH: I don’t understand what you mean with “having to deduce what a particular type is by looking at the type annotation of a function”
11:51:34 <clrnd> JordiGH, "Traversable t => (a -> b) -> t a -> t b" actually tells a LOT
11:51:42 <JordiGH> bitonic: In Python I can do ?foo and get a docstring that lists the function and the named parameters and the documentation if it exists, but I always get at least what the arguments are called.
11:51:48 <favetelinguis> ReinH: Well i got that from the haskell course on edx, check it out day 6 lecture 2. might be me who missunderstood him
11:52:08 <JordiGH> bitonic: In Haskell I gotta decipher what "Traversable t => (a -> b) -> t a -> t b"  means instead of just being told what it is.
11:52:14 <clrnd> I think it depends, also "a -> b" is telling you it is not a lot of things :P
11:53:00 <JordiGH> bitonic: And I also have to remember in what order foldr or foldl accept their arguments and fight dyslexia.
11:53:04 <bitonic> JordiGH: you can easily document specific args in haddock
11:53:10 <fragamus> Iceland_jack:              m >>= k             = foldr ((++) . k) [] m
11:53:22 <JordiGH> bitonic: Yeah, but people recommend *not* documenting in Haskell. It's a cultural thing.
11:53:40 <bitonic> JordiGH: been here for 5 years and I’ve never heard that
11:53:47 <Iceland_jack> fragamus: Bind for lists is just 'concatMap' flipped
11:53:49 <bitonic> JordiGH: in any case, it’s ortogonal to implicit arguments
11:53:52 <JordiGH> bitonic: Named arguments are kind of a minimalist forced documentation. In Haskell instead this corresponds to types, but I find it a poor substitute.
11:53:56 <clrnd> JordiGH, that's not true, libraries document their arguments all the time
11:53:59 <Iceland_jack> > concatMap (\x -> [x, x+10]) [1,2,3]
11:54:00 <lambdabot>  [1,11,2,12,3,13]
11:54:08 <Iceland_jack> > [1,2,3] >>= (\x -> [x, x+10])
11:54:09 <lambdabot>  [1,11,2,12,3,13]
11:54:10 <kadoban> JordiGH: You really don't have to remember...look it up, the type tells you directly once you understand what the function does. And if you get it wrong, the error will tell you...
11:54:25 <JordiGH> Okay, thanks guys.
11:55:02 <fragamus> Iceland_jack: ok... when I am just using monads and not thinking too hard, it seems like my functions are receiving unwrapped values and emitting wrapped values
11:55:09 <clrnd> usually in Python I get things like "foo(something, option, magic, error='Lol')"
11:55:47 <fragamus> Iceland_jack: i'm adept at using them, but i can't reconcile my experience with the theory
11:56:36 <Iceland_jack> fragamus: I'm not sure what the issue is but 'join' isn't used very often in practice if that helps
11:56:45 <erisco> :t Cont -- why is this import not working =\
11:56:46 <lambdabot>     Not in scope: data constructor ‘Cont’
11:56:46 <lambdabot>     Perhaps you meant one of these:
11:56:46 <lambdabot>       ‘Const’ (imported from Control.Lens),
11:56:48 <ReinH> favetelinguis: yeah, foldr is not a list homomorphism. In foldr f z, if f and z are the binary operation and identity element of a monoid, then it is a *monoid homomorphism*, a.k.a. monoid morphism.
11:57:34 <erisco> :t runCont
11:57:35 <lambdabot> Cont r a -> (a -> r) -> r
11:57:36 <fragamus> yeah so you are saying that I described a kind of flattening that isn't used much
11:57:43 <erisco> :s
11:58:23 <Fuuzetsu> Iceland_jack: there is no issue with join, it's just that Monad is defined with >>= instead so that's what people are taught and use…
11:58:33 <fragamus> i see
11:58:38 <erisco> :t return 5 :: Cont Int Int
11:58:39 <lambdabot> Cont Int Int
11:58:50 <Fuuzetsu> I doubt it'd be different if join was the default anyway but it'd probably see slightly more use
11:58:50 * erisco frowns at lambdabot
11:59:01 <monochrom> named arguments benefit readers greatly. however, for writers, its burden is no less than looking up types.
11:59:26 <Iceland_jack> Fuuzetsu: You have to pick a formulation, the one we currently have is fine
11:59:48 <Fuuzetsu> sure, I'm not proposing to change it
11:59:56 <Iceland_jack> I haven't read the backlog so I may be missing some context
12:00:09 <monochrom> whereas you argue that the writer has to always look up types to use library functions correctly, the writer also has to always look up exact spellings of argument names.
12:00:11 <Fuuzetsu> I read even less backlog
12:01:43 <nerium> How would you define cons? http://imgur.com/uUPLYt6
12:01:53 <monochrom> especially if you cite dylexia, spellings of argument names is only going to be worse than types
12:02:07 <Iceland_jack> nerium: data List a = Nil | Cons a (List a)
12:02:29 <nerium> So if List(A) = [[1], [2]], would = cons(1, [2]) ?
12:02:31 <Iceland_jack> nerium: You're a Chalmers student :)
12:02:37 <nerium> Iceland_jack: Yes
12:02:47 <Iceland_jack> [1] would be (Const 1 Nil)
12:02:50 <nerium> I dont get how they’ve specified cons
12:02:56 <Iceland_jack> *Cons
12:03:13 <Iceland_jack> [[1],[2]] would be (Cons (Cons 1 Nil) (Cons (Cons 2 Nil) Nil))
12:03:45 <Iceland_jack> Replacing the Cons with (:) and Nil with [] you'd get:
12:03:45 <Iceland_jack> > ((:) ((:) 1 []) ((:) ((:) 2 []) []))
12:03:47 <lambdabot>  [[1],[2]]
12:03:55 <fragamus> Iceland_jack: thanks I think you helped me
12:04:46 <monochrom> nerium, I wonder what is the context of that excerpt
12:04:46 <nerium> Iceland_jack: So what would a and as be? in terms of [[1], [2]]?
12:05:02 <Iceland_jack> nerium: 'a' would be [1], 'as' would be [[2]]
12:05:21 <Iceland_jack> > let a = [1]; as = [[2]] in a:as
12:05:23 <lambdabot>  [[1],[2]]
12:05:25 <nerium> That was my initial tought, you just pop one element
12:05:28 <kadoban> nerium: Looking at lists of lists to understand lists seems kind of confusing.
12:06:08 <nerium> Iceland_jack: Is that also applable to simple lists like [1,2,3] ?
12:06:16 <Iceland_jack> nerium: Yes
12:06:28 <Iceland_jack> nerium: Recall that [1,2,3] in Haskell is sugar for (1:2:3:[])
12:06:42 <Iceland_jack> where (:) is right-associative:
12:06:42 <Iceland_jack>     1:2:3:[] == 1:(2:(3:[]))
12:06:55 <nerium> Iceland_jack: Hehe, I havent use Haskel in 5 years
12:06:58 <Iceland_jack> > 1:(2:(3:[]))
12:06:59 <lambdabot>  [1,2,3]
12:07:08 <nerium> but that makes sense
12:07:28 <Iceland_jack> nerium: I suggest starting off with one-dimensional lists, seeing how they compare to the Haskell definition (and enjoy Models of Computation) :)
12:07:40 <indiagreen> k0ral: if “n” is completely unused, you can remove the constraints from your type signature. If “n” isn't completely unused – i.e. you want to call some method inside of your function which requires a constraint – then GHC doesn't know what instance of this method to choose, simple as that. (I can't say exactly why GHC wants “n” to be unambiguous even if all constraints mentioning “n” aren't needed, but I think it's
12:07:40 <indiagreen> because implementing it otherwise would be harder yet completely pointless.)
12:07:46 <nerium> Iceland_jack: Hehe, thanks
12:08:18 <Iceland_jack> nerium: You can define lists with lambdabot:
12:08:18 <Iceland_jack> @let data List a = Nil | Cons a (List a) deriving Show
12:08:19 <lambdabot>  Defined.
12:08:35 <Iceland_jack> > L.Cons 1 Nil     -- [1]
12:08:37 <lambdabot>  Cons 1 Nil
12:08:42 <Iceland_jack> > L.Cons 2 Nil     -- [2]
12:08:43 <lambdabot>  Cons 2 Nil
12:09:29 <Iceland_jack> A list of length 2:
12:09:29 <Iceland_jack> > L.cons 10 (L.Cons 20 Nil)
12:09:30 <lambdabot>  Not in scope: ‘L.cons’
12:09:31 <lambdabot>  Perhaps you meant one of these:
12:09:31 <lambdabot>    ‘BSL.cons’ (imported from Data.ByteString.Lazy),
12:09:31 <lambdabot>    ‘BS.cons’ (imported from Data.ByteString)
12:09:42 <Iceland_jack> > L.Cons 10 (L.Cons 20 Nil)
12:09:43 <lambdabot>  Cons 10 (Cons 20 Nil)
12:10:01 <Iceland_jack> And of length 3 etc.:
12:10:01 <Iceland_jack> > L.Cons 10 (L.Cons 20 (L.Cons 30 Nil))
12:10:02 <lambdabot>  Cons 10 (Cons 20 (Cons 30 Nil))
12:11:05 <fragamus> Iceland_jack: so with    >>=   it works differently from join in that each function is receiving an unwrapped argument and emitting a wrapped one
12:11:29 <Iceland_jack> fragamus: I'm not sure what you're asking, (>>=) and join are different functions but they can be defined in terms of each other
12:12:15 <Iceland_jack> fragamus: Does this clear things up?
12:12:15 <Iceland_jack> > join [[1,2], [3,4]]
12:12:16 <lambdabot>  [1,2,3,4]
12:12:19 <Iceland_jack> > [[1,2], [3,4]] >>= id
12:12:21 <lambdabot>  [1,2,3,4]
12:13:08 <fragamus> yes
12:13:50 <Iceland_jack> fragamus: Same with Maybe:
12:13:51 <Iceland_jack> > join (Just (Just 'a'))
12:13:52 <lambdabot>  Just 'a'
12:13:57 <Iceland_jack> > Just (Just 'a') >>= id
12:13:59 <lambdabot>  Just 'a'
12:17:11 <clrnd> can I have mapM for Applicative?
12:17:17 <benzrf> :t T.sequenceA
12:17:18 <lambdabot> (Traversable t, Applicative f) => t (f a) -> f (t a)
12:17:22 <clrnd> yay
12:17:30 <benzrf> clrnd: not only is it for applicative, it's generalized!
12:17:50 <benzrf> > T.sequenceA (Just [1, 2, 3])
12:17:52 <lambdabot>  [Just 1,Just 2,Just 3]
12:17:56 <benzrf> > T.sequenceA Nothing
12:17:58 <lambdabot>  No instance for (GHC.Show.Show (f0 (Data.Maybe.Maybe a0)))
12:17:58 <lambdabot>    arising from a use of ‘M609264725612566628626278.show_M6092647256125666286...
12:17:58 <lambdabot>  The type variables ‘f0’, ‘a0’ are ambiguous
12:17:58 <lambdabot>  Note: there are several potential instances:
12:17:58 <lambdabot>    instance [safe] GHC.Show.Show a =>
12:18:02 <benzrf> wait. crpa
12:18:11 <benzrf> > T.sequenceA Nothing :: [Maybe Int]
12:18:12 <lambdabot>  [Nothing]
12:18:32 <Iceland_jack> clrnd: You want 'traverse'
12:18:34 <Iceland_jack> :t traverse
12:18:36 <lambdabot> (Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)
12:18:54 <clrnd> yeah I found it on the docs
12:19:04 <clrnd> thanks
12:19:29 <Iceland_jack> No problem, you may be interested in the flipped version 'for':
12:19:29 <Iceland_jack> @ty T.for
12:19:30 <lambdabot> (Traversable t, Applicative f) => t a -> (a -> f b) -> f (t b)
12:20:06 <k0ral> indiagreen: I don't see how I could remove the reference to "n", also removing the Typeable constraint doesn't fix anything
12:21:14 <Iceland_jack> > F.for_ [1..100] print
12:21:15 <lambdabot>  <IO ()>
12:21:25 <davidthomas> Is there a package that enumerates spoken languages?
12:21:29 <clrnd> nice!
12:21:39 <EvanR> mmm Typeable
12:21:45 <davidthomas> basically, a parsed version of http://www.iana.org/assignments/language-subtag-registry/language-subtag-registry or something to parse it?
12:21:52 <clrnd> I wasn't familiar with Date.Traverse, didn't know it was in base
12:22:00 <clrnd> versable*
12:22:16 <erisco> ReinH, josephle I have now spent some time reading on continuations and although I do not fully understand them yet, they seem to be apart from the pattern I am looking for
12:22:23 <Iceland_jack> clrnd: 'for' is in Traversable but you need Data.Foldable if you want 'for_'
12:22:32 <clrnd> oh
12:22:33 <ReinH> erisco: ok :)
12:23:01 <erisco> ReinH, I was hoping you would have more to say to the contrary
12:24:16 <ReinH> erisco: maybe if I knew more about your problem :)
12:24:33 <ratzes> does anybody know a comprehensive resource on the behavior of inlinable vs inline?
12:24:44 <fragamus> inits =<< "flooble"
12:24:51 <fragamus> > inits =<< "flooble"
12:24:53 <lambdabot>  Couldn't match type ‘GHC.Types.Char’ with ‘[a]’
12:24:53 <lambdabot>  Expected type: [[a]]
12:24:53 <lambdabot>    Actual type: [GHC.Types.Char]
12:25:00 <erisco> the particular problem is not that relevant. I have accurately described the data type I would use to implement the pattern
12:25:08 <erisco> I am having difficulty seeing it as a continuation
12:25:10 <fragamus> > "flooble" >>= inits
12:25:12 <lambdabot>  Couldn't match type ‘[a]’ with ‘GHC.Types.Char’
12:25:12 <lambdabot>  Expected type: GHC.Types.Char -> [[a]]
12:25:12 <lambdabot>    Actual type: [a] -> [[a]]
12:25:32 <Iceland_jack> fragamus: Look at the type of (>>= inits)
12:25:53 <fragamus> :t (>>= inits
12:25:54 <lambdabot>     parse error (possibly incorrect indentation or mismatched brackets)
12:25:58 <fragamus> :t >>= inits
12:25:59 <lambdabot> parse error on input ‘>>=’
12:26:07 <Iceland_jack> :t (>>= inits)
12:26:08 <lambdabot> [[a]] -> [[a]]
12:26:16 <Iceland_jack> So (>>= inits) takes a list of lists
12:26:26 <Iceland_jack> > ["hello", "world!"] >>= inits
12:26:28 <lambdabot>  ["","h","he","hel","hell","hello","","w","wo","wor","worl","world","world!"]
12:26:32 <lynnard> Anyone using pidgin here? Haskell code constantly gets turned into smileys like :)
12:26:37 <lynnard> anyway to disable this?
12:27:00 <fragamus> > inits "flooble"
12:27:02 <lambdabot>  ["","f","fl","flo","floo","floob","floobl","flooble"]
12:27:17 <fragamus> > (inits >>= tails) "flooble"
12:27:19 <lambdabot>  Couldn't match expected type ‘[GHC.Types.Char] -> t’
12:27:19 <lambdabot>              with actual type ‘[[a1]]’Couldn't match expected type ‘[[a1]]’
12:27:19 <lambdabot>              with actual type ‘[a0] -> [[a0]]’
12:27:43 <fragamus> > (inits >=> tails) "flooble"
12:27:45 <lambdabot>  ["","f","","fl","l","","flo","lo","o","","floo","loo","oo","o","","floob","l...
12:27:46 <davidthomas> lynnard: ... use finch?
12:28:03 <lynnard> davidthomas: well I still want to see pictures sometimes
12:28:43 <davidthomas> lynnard: yeah, don't use finch then :-P
12:28:49 <josephle> ReinH: <erisco> data X = X1 (A -> (Q, X)) | X2 R    --  I am seeing a pattern like this and am wondering if it is captured by an existing abstraction
12:29:39 <fragamus> > (inits "flooble") >>= tails
12:29:41 <lambdabot>  ["","f","","fl","l","","flo","lo","o","","floo","loo","oo","o","","floob","l...
12:29:53 <fragamus> :t  (inits "flooble")
12:29:54 <lambdabot> [[Char]]
12:29:56 <lynnard> ok seems to find the solution now :P
12:29:56 <fizbin> :t minimumOf
12:29:57 <lambdabot> Ord a => Getting (Endo (Endo (Maybe a))) s a -> s -> Maybe a
12:30:13 <erisco> newtype X = X (A -> Either (Q, X) R)  -- this is less desirable but if it helps fit the continuation pattern then it is a possible compromise
12:30:19 <ratzes> does anybody know a resource on the nitty gritty details of inlinable vs inline?
12:31:32 <fragamus> :t  (\x-> [x,x+10])
12:31:33 <lambdabot> Num t => t -> [t]
12:32:00 <fragamus> > (\x-> [x,x+10]) [1,2,3]
12:32:02 <lambdabot>  No instance for (GHC.Show.Show t0)
12:32:02 <lambdabot>    arising from a use of ‘M42875125429309643826826.show_M42875125429309643826...
12:32:02 <lambdabot>  The type variable ‘t0’ is ambiguous
12:32:02 <lambdabot>  Note: there are several potential instances:
12:32:02 <lambdabot>    instance [safe] GHC.Show.Show
12:32:21 <k0ral> Why wasn't "(Monoid e, Member (Exc e) r) => Eff r" made an instance of MonadPlus ?
12:32:21 <fragamus> > (\x-> [x,x+10]) 7
12:32:23 <lambdabot>  [7,17]
12:32:37 <k0ral> (I'm talking about Eff from extensible-effects)
12:32:46 <erisco> :t mapM [id,(+10)]
12:32:47 <lambdabot>     Couldn't match expected type ‘a -> m b’
12:32:47 <lambdabot>                 with actual type ‘[a0 -> a0]’
12:32:47 <lambdabot>     In the first argument of ‘mapM’, namely ‘[id, (+ 10)]’
12:32:55 <erisco> :t mapM (4) [id,(+10)]
12:32:56 <lambdabot> (Num ((a -> a) -> m b), Num a, Monad m) => m [b]
12:32:58 <erisco> -.-
12:33:02 <erisco> :t mapM ($) [id,(+10)]
12:33:03 <lambdabot> Num a => a -> [a]
12:33:09 <fragamus> > ((\x-> [x,x+10]) 7) >>= ((\x-> [x,x+10]) 7)
12:33:11 <lambdabot>  Couldn't match expected type ‘a0 -> [b]’ with actual type ‘[t0]’
12:33:18 <fragamus> > ((\x-> [x,x+10]) 7) >>= ((\x-> [x,x+10]))
12:33:20 <lambdabot>  [7,17,17,27]
12:34:32 <fragamus> :t (>>= (\x-> [x,x+10]))
12:34:34 <lambdabot> Num b => [b] -> [b]
12:35:46 <Iceland_jack> fragamus: Note that this is the same as mapping and the concatting the result
12:35:48 <Iceland_jack> :t map (\x -> [x, x+10]) [1,2,3]
12:35:49 <lambdabot> Num t => [[t]]
12:35:50 <Iceland_jack> > map (\x -> [x, x+10]) [1,2,3]
12:35:52 <lambdabot>  [[1,11],[2,12],[3,13]]
12:35:55 <Iceland_jack> > concat (map (\x -> [x, x+10]) [1,2,3])
12:35:56 <lambdabot>  [1,11,2,12,3,13]
12:36:10 * hackagebot HDBC-odbc 2.4.0.0 - ODBC driver for HDBC  http://hackage.haskell.org/package/HDBC-odbc-2.4.0.0 (anton_dessiatov)
12:36:18 <fragamus> :t ((\x-> [x,x+10]) >>= (\x-> [x,x+10]))
12:36:19 <lambdabot>     Couldn't match expected type ‘t0 -> [t0]’ with actual type ‘[b]’
12:36:20 <lambdabot>     The lambda expression ‘\ x -> ...’ has one argument,
12:36:20 <lambdabot>     but its type ‘[b]’ has none
12:36:23 <Iceland_jack> fragamus: Then consider that 'map is fmap' and that 'concat is join'
12:36:35 <fragamus> :t ((\x-> [x,x+10]) >=> (\x-> [x,x+10]))
12:36:36 <lambdabot> Num c => c -> [c]
12:37:04 <fragamus> I think this kliesli style is easier to grasp
12:37:12 <Iceland_jack> > let f x = [x,x+10] in (f >=> f) 5
12:37:14 <lambdabot>  [5,15,15,25]
12:37:35 <Iceland_jack> > let f x = [x,x+10] in (f >=> f >=> f >=> f) 10
12:37:36 <lambdabot>  [10,20,20,30,20,30,30,40,20,30,30,40,30,40,40,50]
12:38:02 <fragamus> :t ((\x-> [x,x+10]) >=> (\x-> [x,x+10]))
12:38:03 <lambdabot> Num c => c -> [c]
12:38:20 <fragamus> :t (\x-> [x,x+10])
12:38:20 <Iceland_jack> You can also PM lambdabot with questions
12:38:21 <lambdabot> Num t => t -> [t]
12:38:36 <fragamus> feeling flooded?
12:38:56 <Iceland_jack> Somewhat
12:39:10 <fragamus> sorry
12:40:29 <Iceland_jack> It's no problem
12:43:59 <merijn> Peaker: I need your help on libraries@ with my final push to push bracket fix through before 7.10 :p
12:45:34 <Peaker> merijn: oh, I thought I'd have to eventually write it! Thanks!
12:45:41 <Peaker> merijn: cool :)
12:47:04 <merijn> Peaker: I'm on a patching streak anyway :p
12:48:54 <merijn> I hope to push through my literate haskell change before 7.10, although that one requires a bit more bikeshedding, so I hope I can make the code freeze :\
12:50:46 <RyanGlScott> Is there a flag like -ddump-splices that shows you what code is generated from deriving statements?
12:51:30 <merijn> There should be a -ddump-deriv or whatever
12:51:58 <bitonic> RyanGlScott: ‘man ghc‘ lists all the flags including -ddump-deriv
12:53:25 <RyanGlScott> bitonic: Wow, I managed to grep "ddump-deriving", but not "deriving". Thank you.
12:55:31 <bitonic> RyanGlScott: you can press / while in the pager and you get this nice incremental search :)
12:56:20 <RyanGlScott> bitonic: As is usually the case, most of my problems wouldn't exist if I would have just RTFM.
12:58:45 <fragamus> > (inits >=> tails) "flooble"
12:58:47 <lambdabot>  ["","f","","fl","l","","flo","lo","o","","floo","loo","oo","o","","floob","l...
12:58:56 <EvanR> "requires a bit more bikeshedding"
12:59:00 <EvanR> haha
13:00:14 <ratzes> does anybody know any comprehensive material on inlinable vs inline?
13:00:16 <erisco> mauke, yes it did
13:00:26 <merijn> EvanR: Yeah, I created a ticket and got a bunch more comments and one of them was actually pretty decent
13:01:02 <merijn> EvanR: My initial proposals Foo.md.lhs was shutdown as it leads to ambiguity with name resolution, but "Foo.lhs.md" would work fine
13:01:20 <merijn> Well, probably
13:01:27 <merijn> Hence the need for more bikeshedding
13:02:10 <lpaste> lambdabot annotated “No title” with “test” at http://lpaste.net/7004432012928876544#a114129
13:04:54 <dmj`> hey guys
13:05:30 <dmj`> there was a post on haskell reddit a while ago that detailed different evaluation patterns in haskell, starting from vanilla functions to GADTs, does anybody know what I'm talking about?
13:06:00 <dmj`> I can't find it anymore, was wondering if someone knew what it was called
13:07:29 <benzrf> vanila functoins
13:07:39 <dmj`> I just made that up
13:08:04 <dmj`> oh, i get it
13:08:25 <mauke> @where evolution
13:08:25 <lambdabot> http://www.willamette.edu/~fruehr/haskell/evolution.html
13:08:56 <dmj`> mauke: this one was recent, mentioned GADTs
13:08:57 <erisco> in a continued effort to understand continuations... the gist appears to be much what this function does  \f x -> f . foldr ($) x
13:09:08 <erisco> :t \f x -> f . foldr ($) x
13:09:09 <lambdabot> (b -> c) -> b -> [b -> b] -> c
13:09:41 <erisco> i.e. you do some operations on the argument ([b -> b]), then you pass in some b, then you map b to c
13:09:55 <dmj`> and type families
13:10:30 <EvanR> what ever happened to n+k patterns?
13:11:02 <erisco> otherwise I am missing what is actually going on
13:11:09 <ChristianS> EvanR: they were never popular and haskell 2010 got rid of them
13:11:11 * hackagebot TBit 0.4.2.0 - Utilities for condensed matter physics tight binding calculations.  http://hackage.haskell.org/package/TBit-0.4.2.0 (danielsmw)
13:12:55 <erisco> am I correct in my assessment? what is the continuation monad specially capable of? i.e. is it just a monad instance because it can be or are there real uses?
13:13:47 <josephle> erisco: I'm certain that your original datatype is in fact a continuation, but whether or not it fits the continuation monad is a separate matter
13:14:21 <thsig> Hey guys, am I correct in assuming that Data.Vector is the recommended array implementation?
13:14:23 <erisco> josephle, then what is 'r' and 'a' in newtype Cont r a = Cont { runCont :: ((a -> r) -> r) } ?
13:14:32 <thsig> when performance is important, e.g.
13:16:43 <thsig> I was looking into the asymptotic complexity of the "standard" data structures
13:16:49 <thsig> http://hackage.haskell.org/package/vector-0.7.0.1/docs/Data-Vector-Generic.html#g:15
13:17:11 <thsig> looks like single-element updates are O(n) in the length of the vector
13:17:20 <EvanR> performance of what is important
13:17:45 <EvanR> updating an immutable vector requires making a copy
13:17:53 <thsig> whereas Bagwell's "ideal hash trees" (as implemented in clojure) are O(log_32 n)
13:18:23 <thsig> on the other hand, reads are O(log_32 n) too, compared to the O(1) complexity in vector
13:18:27 <bitonic> thsig: your hash trees are very different from vector’s arrays.  they do different things and perform differently
13:18:28 <thsig> so there's a tradeoff, for sure
13:18:36 <EvanR> vectors are also simpler
13:19:19 <EvanR> thsig: for something with saner updating, you could use Map or IntMap
13:19:23 <EvanR> or something else
13:19:29 <bitonic> or mutable vectors
13:19:30 <clrnd> how can I use async-lifted's Concurrently?
13:19:34 <clrnd> I don't know kinds
13:19:36 <EvanR> you wouldnt want to use Vector for an algorithm that needs updating
13:19:44 <EvanR> yeah theres straightup mutable vectors
13:19:47 <clrnd> (I think)
13:20:08 <thsig> EvanR: Ok, I see. I'm just trying to get a feel for the data structures people are using in Haskell and what their respective use cases are.
13:20:35 <EvanR> for operating only on the ends of a list, there is Data.Sequence
13:20:50 <EvanR> which is ostensibly the use case for clojure vectors
13:21:56 <merijn> EvanR: n+k was removed in Haskell2010
13:22:09 <merijn> They're now only available as a GHC extension
13:22:26 <EvanR> at some point we all switched to haskell 2010?
13:22:47 <thsig> EvanR: True. They're also used a lot for updates. But again, they're log(n)/log(n) for update/read, similarly to Data.Map (I assume)
13:22:58 <merijn> EvanR: Haskell2010 has been the GHC default for a while now
13:23:14 <merijn> EvanR: If you want Haskell98 you need to explicitly specify so
13:23:23 <EvanR> thsig: update by index? weird
13:23:48 <thsig> so I guess in Haskell one would choose Data.Map for the "lots of updates on a persistent vector" use case that clojure folks would use the built-in vectors for
13:24:17 <EvanR> im still curious how or why youd use that for that in clojure
13:24:17 <merijn> thsig: IntMap would be faster
13:24:21 <bitonic> thsig: by the way, we have hash trees as well, in unordered-containers
13:24:22 <thsig> EvanR: I haven't used clojure in production - maybe update by index isn't something people do much in reality
13:24:27 <merijn> thsig: Or vector/repa
13:24:43 <merijn> thsig: They do for some algorithms, but that's what we have mutable vectors for
13:25:04 <EvanR> thsig: well, a dictionary from ints to whatever, thats one thing. but a vector exposes itself more like an array
13:25:11 <bitonic> thsig: in fact what you have in unordered-containers uses the same structure that clojure uses, HAMTs – if my clojure knowledge is up-to-date.  so you have exactly the same structure, when it makes sense
13:25:14 <ratzes> does anybody know the trade off between inlinable and inline?
13:25:38 <thsig> bitonic: Yeah, HAMTs is indeed what the clojure ones are.
13:25:55 <thsig> ok, very interesting
13:26:04 <thsig> thanks for the answers, guys!
13:26:09 <thsig> I'll keep looking around
13:26:20 <EvanR> IntMap is probably more popular than unordered containers
13:26:24 <thsig> just glad to see that there's been a lot of solid work on high-performance data structures in Haskell with lots of options out there
13:26:44 <ratzes> IntMap is amazing
13:26:57 <dmj`> intmap++
13:27:19 <bitemyapp> bitonic: not exactly the same
13:27:30 <bitemyapp> bitonic: unordered-containers is log16, Clojure HAMTs are log32
13:27:48 <bitemyapp> bitonic: smallArray# in GHC 7.10 will speed them up a bunch and the Hashable typeclass needs a do-over.
13:28:03 <bitemyapp> I have been trying to recruit Clojurians familiar with the HAMT implementation to do some fix-up work.
13:28:11 <erisco> josephle, are you still certain?
13:28:14 <josephle> hmm
13:28:32 <bitonic> bitemyapp: cool, thanks for the info.
13:28:34 <bitemyapp> thsig: update by index of what?
13:28:40 <bitemyapp> thsig: I use Clojure and Datomic in production.
13:28:51 <erisco> :t Identity
13:28:53 <lambdabot> a -> Identity a
13:29:30 <thsig> bitemyapp: I initially asked because I saw that the update operation here (http://hackage.haskell.org/package/vector-0.7.0.1/docs/Data-Vector-Generic.html#g:15) is O(n) in the length of the vector, which made me wonder
13:29:32 <erisco> > (*2) $ runIdentity (Identity 5 >>= return . (+1))
13:29:34 <lambdabot>  12
13:29:42 <thsig> bitemyapp: because I'm more used to the clojure data structures
13:29:44 <erisco> I don't get how this is not nearly exactly the Cont monad
13:30:06 <thsig> bitemyapp: just trying to get a feel for the data structure landscape in Haskell
13:30:11 <erisco> it looks exactly like Identity to me but with a map built
13:30:16 <erisco> a map built in
13:31:24 <thsig> bitemyapp: do you think Haskell + Datomic could be a good match?
13:31:29 <bitemyapp> don't use Datomic.
13:31:33 <bitemyapp> like, really, don't.
13:31:35 <bitemyapp> with any language.
13:31:44 <bitemyapp> add history to PostgreSQL.
13:31:46 <thsig> hah
13:31:52 <EvanR> bitemyapp: guess what im using
13:32:01 <bitemyapp> trust me, I wish there was a nice immutable database but it doesn't yet exist.
13:32:08 <bitonic> bitemyapp: care to elaborate?  I only barely read stuff about datomic
13:32:13 <bitemyapp> bitonic: no.
13:32:18 <bitonic> although it’s a bit off topic here
13:32:20 <EvanR> heh
13:32:23 <bitonic> bitemyapp: …okay
13:32:24 <bitemyapp> Don't use Datomic.
13:32:32 <thsig> bitemyapp: Now you're making me really curious!
13:32:36 <bitemyapp> the support is bad, they move slowly, it's poorly implemented.
13:32:55 <bitemyapp> it's also quite slow if you're not within their ideal use-case which is...not often the case.
13:33:16 <bitemyapp> It's also closed-source so you can't fix anything and they're a pain about fixing things even if you offer to pay them.
13:33:22 <bitemyapp> just don't use it. Adding history to PostgreSQL is much more manageable.
13:34:04 <bitemyapp> thsig: update by index of vector isn't terribly common, if you're updating by an index usually you have a map.
13:34:20 <josephle> erisco: the problem with translating to Cont is where to put your intermediate state Q
13:34:23 <bitemyapp> usually you're mapping or reducing a vector.
13:34:24 <thsig> bitemyapp: Wow, I've got to admit that's rather surprising. Then again, the only prod users I've been hearing and reading about it from are the Relevance/Cognitect folks.
13:34:37 <bitemyapp> thsig: yeah...don't listen to what they say.
13:34:43 <josephle> erisco: although it seems your Q isn't used in future computations...
13:35:13 <bitemyapp> thsig: a lot of the problem is that between being closed-source and their poor shepherding of the product is that you'll be stranded if there's something wrong.
13:35:19 <erisco> josephle, no it is not used in future computations. It informs the caller what information the callee is looking for
13:35:21 <bitemyapp> thsig: and you just have to hope they're in a mood to fix your problem
13:36:21 <erisco> josephle, at least that is what I am using it for
13:37:06 <josephle> hmm, I'm not sure if intermediate results are possible in the Cont monad
13:37:25 <erisco> the structure seems different, though again I am not understanding how the Cont monad is used properly
13:37:34 <bitonic> bitemyapp, thsig: there is nothing particularly wrong with updating a vector, but then you’d want a… mutable vector.  Haskell has got great support for manipulating those in pure code
13:37:37 <thsig> bitemyapp: You say it's not that well implemented... How is that surfacing?
13:37:59 <bitemyapp> I don't really want to talk about it.
13:38:11 <bitemyapp> and instead get back to working on the REST API I wrote for wrapping Datomic :P
13:39:04 <natschil> Hello. I have a source file that I need to load into ghci. I have another source file that contains a large list of Integers. For some reason, whenever I load one into ghci (using :load), the definitions from the other one are erased. How do I prevent this from happening?
13:39:42 <thsig> bitemyapp: Good man!
13:40:49 <EvanR> bitemyapp: were using it in production, and coming up is a discussion on how to "properly" store a list of things in the database, which im not looking forward to
13:46:13 * hackagebot definitive-parser 2.1 - A parser combinator library for the Definitive framework  http://hackage.haskell.org/package/definitive-parser-2.1 (MarcCoiffier)
13:46:15 * hackagebot definitive-base 2.3 - The base modules of the Definitive framework.  http://hackage.haskell.org/package/definitive-base-2.3 (MarcCoiffier)
13:46:34 <nitrix> Hi, is there a cleaner way to write this? http://ideone.com/a4TVmP
13:46:38 <nitrix> I'm new to haskell.
13:47:50 <nitrix> Resources are specifiers to locate Blocks, the function tries to obtain the first block it can from the list of resources, otherwise yields Nothing.
13:48:20 <cdk> nitrix: something like: fmap (find isJust) $ mapM obtainBlock
13:48:32 <Peaker> cdk: that's missing short-circuiting
13:48:37 <Peaker> cdk: it would obtainBlock on everything
13:48:41 <bitonic> nitrix: that looks OK.  I’d leave it like this.  easy to read.  you could use MaybeT and msum.
13:48:42 <cdk> Peaker: true, hmm
13:49:21 <bitonic> nitrix: but as Peaker says you’d have to make sure that it shourt circuits if you’re not sure, and it’d be pretty error prone. I tend to write that kind of code explicitly
13:49:58 <Peaker> cdk, nitrix: You could use http://hackage.haskell.org/package/monad-loops-0.3.0.2/docs/Control-Monad-Loops.html#v:firstM  <-- perhaps copy that combinator instead of depending on the whole thing?
13:50:10 <nitrix> bitonic: Is it explicit enough in its current form?
13:50:58 <bitonic> nitrix: but if you relly must, ‘obtainAnyBlock = runMaybeT . mconcat . map (MaybeT . obtainBlock)’ or something like that
13:51:22 <bitonic> nitrix: I think that form is good, again it’s very easy to read and does the job
13:51:33 <bitonic> which is a quality many programs lack :P
13:51:33 <Peaker> MaybeT has a Monoid instance?
13:51:47 <bitonic> Peaker nitrix: sorry, meant to use msum
13:52:12 <bitonic> ‘obtainAnyBlock = runMaybeT . msum . map (MaybeT . obtainBlock)’
13:52:40 <Peaker> msum on MaybeT short-circuits, I'd hope :)
13:53:08 <bitonic> Peaker: I happen to know it does, but in the general case this is why I write this kind of IO code explicitely.  because there’s always a lingering doubt that it won’t
13:53:12 <sinelaw> @src msum
13:53:13 <lambdabot> msum = foldr mplus mzero
13:53:23 <bitonic> ReinH merijn: which relates to the <*> vs ap discussion yesterday :P
13:54:08 <ReinH> if msum doesn't short circuit, there is a bug with the instance's implementation of MonadPlus
13:54:30 <ReinH> I don't code defensively around everything that could possible be buggy.
13:54:58 <bitonic> ReinH: well, this is a matter of taste, but I find reading that kind of code harder to read, because you have to think more about these issues
13:55:05 <ReinH> mzero >>= k = mzero is a law of MonadPlus
13:55:29 <ReinH> I expect instances of typeclasses to be law abiding
13:55:34 <ReinH> and I use the typeclasses based on their laws
13:55:46 <ReinH> It really isn't that difficult
13:55:50 <bitonic> ReinH: sure, this is a readability/ease of understanding issue, at least for me.  I find it easier to work with explicit code where there is that kind of subtlety
13:56:01 <ReinH> But there isn't any subtlety, is what I'm saying
13:56:08 <ReinH> The instances either abide the laws or they are broken
13:56:16 <ReinH> And there aren't that many broken instances
13:56:20 <nitrix> It gets really terse with msum. I've never used a MonadPlus before.
13:56:50 <bitonic> ReinH: no, you don’t understand – *I* find it easier to read.  I find that I can’t internalize the laws so much that they become more immediate than the explicit form (at least in cases like these)
13:56:52 <ReinH> I can't write Haskell wondering if every abstraction I use might secretly be buggy
13:57:39 <ReinH> bitonic: Ok, then perhaps don't phrase it in terms of what *I* must or mustn't do.
13:58:28 <bitonic> ReinH: oh I didn’t mean that.  it just came to mind that writing explicit Applicative code is a similar instance (although there the issue is more serious)
13:58:48 <ReinH> bitonic: ok :)
13:59:08 <nitrix> Okay, so nothing wrong with this code?
13:59:24 <nitrix> Idiomatic, although, not exactly terse enough for the pedants?
13:59:44 <bitonic> nitrix: nope.  if you like msum use that though :).  at the beginning when learning Haskell that kind of stuff is what get you excited eheh
14:00:03 <bitonic> like point-free programming.  but most people get over that soon lol
14:00:13 <bitonic> MonadPlus stays with you.
14:00:56 <ReinH> nitrix: that's a totally reasonable way to write that code
14:01:01 <ReinH> It's very easy to read
14:01:24 <nitrix> Well, writing recursive functions requires a reasonable effort already. I'll go one step at a time.
14:01:47 <nitrix> Been doing procedural programming for 8 years, habbits are hard to change.
14:02:24 <nitrix> I used to see recursive functions as catastophic stack time bombs.
14:02:28 <bitonic> nitrix: MaybeT is really nifty, look it up when you get to monad transformers.  I use it all the time
14:02:30 <ReinH> you could use this if it seems readable to you: obtainAnyBlock (x:xs) = obtainBlock x >>= maybe return (obtainAnyBlock xs)
14:02:54 <ReinH> but the explicit version is totally fine
14:04:30 <EvanR> nitrix: have you ever used a system with tail call optimization
14:04:50 <nitrix> EvanR: Yes, but they were solely optimizations, not something you could rely on.
14:05:15 <exio4> it wasn't scheme then ;P
14:05:20 <EvanR> i know in scheme it was advertised as something that was to be relied on
14:05:31 <bitonic> nitrix: well, the MaybeT version hides the recursion nicely :)
14:05:36 <nitrix> Haha, no it wasn't scheme :)
14:05:54 <exio4> (a (complaint) scheme implementation HAS to support TCO)
14:05:56 <nitrix> bitonic: Interesting, I'll keep learning myself a haskell then.
14:07:30 <EvanR> nitrix: just saying, whatever you learned about recursive functions there, you will need to suspend when thinking about recursive haskell code
14:07:36 <EvanR> cuz its lazy
14:08:19 <EvanR> it seems a lot easier to write recursive code in haskell, to me
14:08:22 <EvanR> dont know why
14:09:46 <josephle> erisco: okay, so the Cont monad might not quite be what you want
14:10:08 <nitrix> It seems recursive functions in haskell are almost always done with lists.
14:10:14 <luite> if you learn laziness first, then you can use that knowledge to think about recursion and tail call optimization (which GHC does) properly
14:10:34 <josephle> erisco: intuitively, the Cont monad provides you a way to construct a call stack
14:10:35 <luite> otherwise it's too easy to confuse things
14:10:53 <erisco> josephle, I don't see how
14:11:05 <nitrix> I wonder if GHC is actually clever enough to lazily call the functions to obtain one item at a time, rather than actually building the list and processing it.
14:11:07 <erisco> I just see simple function composition
14:11:23 <linman32> hi, i'm using emacs w/ haskell-mode and when i try to lookup type, it says "Cannot guess type"
14:11:44 <linman32> command is C-c C-t
14:11:52 <EvanR> nitrix: nah, maybe the examples use lists as a common data structure but you might use numbers, maybes, maps, or whatever a recursive case will need
14:11:57 * ReinH bites his tongue
14:12:09 <luite> nitrix: usually laziness would already do that for you (depending on how you evaluate the list, if you first only calculate the length then the elements will remain thunks at first)
14:12:18 <josephle> ReinH, feel free to correct my poor understanding of Cont
14:12:33 <erisco> josephle, well, function composition is not precisely what I see, but I don't see something incredibly useful
14:12:36 <erisco> so I am missing the point no doubt
14:12:53 <ReinH> josephle:  No no, that was regarding "GHC does tail call optimization", which is... more or less correct
14:13:03 <josephle> oh, ok
14:13:41 <luite> nitrix: but GHC has some optimizations to combine multiple passes over a list (fusion through rewrite rules) or remove unnecessary laziness (demand analysis)
14:13:47 <ReinH> To the extent that Haskell has "tail calls", GHC will optimize them via lazy evaluation because they are left-most outermost redexes
14:14:02 <bitonic> nitrix: in that msum example the list will be consumed incrementally – the whole list need not to be in memory all at once, just one element at a time
14:14:08 <luite> ReinH: it's completely correct, just think operationally enough :p
14:14:11 <ReinH> however, GHC doesn't have any facility to specially detect and optimize tail position recursion
14:14:11 <josephle> erisco, so r is the type you want to 'return' after executing the stack
14:14:15 <ReinH> luite: :p
14:14:26 <josephle> erisco, and (>>=) just keeps adding functions onto the stack
14:14:35 <josephle> but you're right in a sense that it's "just composition"
14:15:00 <luite> ReinH: it's actually the other way around, it has the facilities to detect non-tail calls
14:15:17 <ReinH> luite: which facilities are you referring to?
14:15:35 <erisco> josephle, what I put together with Identity looks like the same thing to be
14:15:36 <erisco> to me*
14:15:41 <luite> it's tail call optimization, it doesn't matter whether the call is recursive or not
14:16:02 <ReinH> luite: it's lazy evaluation ;)
14:16:07 <EvanR> what is tail position in haskell anyway?
14:16:19 <ReinH> EvanR: exactly why I don't like talking about TCO in Haskell
14:16:24 <ReinH> left-most outermost position
14:16:31 <ReinH> is what's actually being referred to
14:16:40 <Hijiri> TCO in Haskell is just a special case of graph reduction isn't it? If I know anything
14:16:41 <ReinH> EvanR: http://en.wikipedia.org/wiki/Evaluation_strategy#Normal_order
14:16:46 <erisco> josephle, but then again, I don't have any examples which are not just fmap
14:16:47 <ReinH> Hijiri: yes
14:16:57 <erisco> i.e. I keep doing  return x >>= return . f
14:17:01 <ReinH> it just happens that "tail calls" are in corner position
14:17:13 <tripped> hey all, I have a newbie question about a typeclass declaration
14:17:20 <EvanR> @src foldl
14:17:20 <lambdabot> foldl f z []     = z
14:17:20 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
14:17:20 <tripped> In this declaration: class Monad m => Enqueue q m a | q -> a where ...
14:17:29 <tripped> what does the '| q -> a' part mean? :P
14:17:30 <EvanR> so that foldl case is "tail recursive" ?
14:17:36 <ReinH> EvanR: "yes".
14:17:39 <bitonic> tripped: it’s a “functional dependency”
14:17:42 <josephle> erisco, the magic is in callCC, which allows you to break out of your "composition" like an imperative return statement
14:17:45 <EvanR> "ok"
14:18:03 <erisco> :t callCC
14:18:04 <lambdabot> MonadCont m => ((a -> m b) -> m a) -> m a
14:18:06 <EvanR> exactly what is the optimization?
14:18:12 <ReinH> EvanR: http://stackoverflow.com/questions/24370549/foldleft-v-foldright-does-it-matter/24370977#24370977
14:18:24 <bitemyapp> GHC implements TCO to make stack-free jumps.
14:18:39 <ReinH> EvanR: there's no special optimization, per se, just the action of lazy evaluation
14:18:54 <ReinH> bitemyapp: GHC uses TCO *internally* in a specific case.
14:19:04 <bitemyapp> so insofar as people care about not consuming stack, if you a write a recursive function with a strict accumulator and the call in the tail position, it'll TCO it.
14:19:11 <tripped> bitonic: ah, so it means that the queue type (q) determines the type of a?
14:19:12 <ReinH> bitonic: No. No it will not.
14:19:13 * ReinH sighs
14:19:17 <ReinH> er bitemyapp
14:19:20 <luite> ReinH: it's baked into the GHC/STG formalism, everything that's a non-tail call goes through a Case, which carries an environment in STG. everything else can be called without any environment by just setting the parameters and jumping to the entry point
14:19:26 <josephle> erisco: but I do agree that your original type is probably common enough to warrant some sort of generalization
14:19:36 <ReinH> GHC *does not do* tail call elimination optimizations
14:19:40 <bitemyapp> ReinH: don't argue with me, argue with dons: http://www.reddit.com/comments/6xnk5/ive_got_two_weeks_of_vacation_coming_up_should_i/c055b9w
14:19:44 <bitemyapp> ReinH: because he disagrees :)
14:19:57 * bitemyapp dusts off his hands and goes back to the salt mines
14:20:00 <bitonic> ReinH: what are you referring to?
14:20:12 <merijn> bitemyapp, ReinH: The discussion of TCO in GHC is pointless as *every* call is a tail-call in Haskell
14:20:24 <ReinH> merijn: yes.
14:20:25 <merijn> Therefore every call is just a jump
14:20:27 <ReinH> Exactly
14:20:58 <bitonic> ReinH: that ‘map’ will produce a list that will be lazily consumed – was that the thing you were disagreeing on?
14:21:13 <ReinH> bitonic: sorry, wasn't actually directed at you :(
14:21:30 <luite> merijn: but that's oversimplifying a bit eh, since you do get stack overflows if you're not careful
14:21:39 <bitonic> ReinH: oh, OK.  go on with the TCO bickering :P
14:21:43 <merijn> luite: The stack overflow is orthogonal to TCO or not
14:21:45 <ReinH> luite: stack overflows are not "call stack" overflows
14:21:53 <bitemyapp> bitonic: producing a list implies eagerness that isn't there.
14:21:55 <merijn> The confusion comes from the following: Stack overflow comes from excessive laziness
14:22:04 <ReinH> stack overflows are pattern matching stack overflows
14:22:10 <merijn> Excessive laziness is *not* solved by tail-calling
14:22:40 <merijn> However, solving excessive laziness often requires restructuring to a tail-call
14:22:52 <ReinH> @where lazy
14:22:52 <lambdabot> http://www.vex.net/~trebla/haskell/lazy.xhtml
14:22:52 <merijn> This does not mean that tail-calling prevents stack overflows
14:22:58 <merijn> Strictness prevents stack overflows
14:23:03 <luite> merijn: that's not always true, i can stack overflow with just unboxed types if i want :)
14:23:04 <bitemyapp> I don't think anybody's saying that.
14:23:20 <EvanR> ReinH: the specifics of this operation would be nice as some sort of blog, tutorial, infographic, or something to help people writing real programs
14:23:31 <merijn> luite: I don't see how that contradicts anything I said?
14:23:35 <SoleSoul> Hi, Sorry to bother you guys. I have to lines in main, one works and the other doesn't, and I don't know why. The first is "temps <- getLine", the second is "unless (n == 0) $ temps <- getLine". The second causes
14:23:35 <ReinH> EvanR: see that link :)
14:23:46 <SoleSoul> ... causes "Parse error in pattern: n == 0"
14:23:46 <bitemyapp> SoleSoul: lpaste.net the program?
14:23:48 <EvanR> ive been using haskell for years and i still feel like im training a wilf animal with respect to "stack" usage
14:23:55 <EvanR> wild
14:24:00 <merijn> EvanR: It's simple
14:24:01 <ReinH> :t unless
14:24:02 <lambdabot> Monad m => Bool -> m () -> m ()
14:24:06 <bitonic> SoleSoul: ‘temps <- getLine’ on it’s own is invalid
14:24:07 <merijn> EvanR: GHC uses a pattern matching stack
14:24:14 <luite> merijn: you said that stack overflows come from excessive laziness
14:24:18 <merijn> EvanR: It will push 1 stack frame per pattern match
14:24:28 <luite> and i disagree... its something that can cause them, but not the only thing
14:24:35 <ReinH> SoleSoul: foo $ x <- bar is not valid do notation syntax
14:24:37 <merijn> luite: ok, from excessively nested case matches which usually come from excessive laziness
14:24:45 <lpaste> SoleSoul pasted “codingame” at http://lpaste.net/114130
14:25:16 <merijn> EvanR: So stack overflows arise if you push too many pattern matches on the pattern stack before evaluating
14:25:23 <bitonic> SoleSoul: you probably want something like ’temps <- if n == 0 then <something> else getLine’
14:25:30 <ReinH> SoleSoul: syntax error aside, what do you expect to happen if temps is not bound?
14:25:49 <EvanR> merijn: what counts as evaluating here
14:26:05 <ReinH> EvanR: pattern matching
14:26:05 <SoleSoul> I want to read into temps if n is not zero. If n is zero, I don't use temps.
14:26:11 <merijn> EvanR: For example, foldl pushes one match per list item, so if the list is too long, you overflow the pattern stack, since (+) can't return until both sides of the function have been "pattern matched"
14:26:18 <ReinH> @src head
14:26:18 <lambdabot> head (x:_) = x
14:26:18 <lambdabot> head []    = undefined
14:26:19 <merijn> EvanR: Reducing a thunk to WHNF
14:26:24 <luite> ReinH: yeah i disagree, since that "pattern match" stack is actually quite close to a call stack. with GHC's calling convention, a non-tail position is something in the scrutinee of a case, the other positions are tail positions. this matches up quite well with taill calls in other languages if you think of pattern matching on a lazy value as a call
14:26:29 <ReinH> evaluation of head evaluates the list to the first constructor
14:26:49 <bitonic> SoleSoul: you don’t encode this logic in your program.  you need to branch and then get temps and do something with it
14:26:58 <bitonic> SoleSoul: you can’t “extract” temps out of that branch though
14:27:02 <merijn> EvanR: If you've been haskell for years, I recommend learning Core, it clarifies a lot :)
14:27:06 <ReinH> luite: I suppose you can mangle the definition of "call" enough to get it to fit, yes ;)
14:27:09 <merijn> EvanR: And Core is really simple
14:27:25 <bitonic> SoleSoul: in your case, just put the ’temps <- getLine’ in the ’n == 0’ branch of the ’if’
14:27:26 <EvanR> ok
14:27:37 <merijn> EvanR: Core basically only has: constructors, function application, let/in, case and primitive types :p
14:28:06 <merijn> EvanR: See also http://research.microsoft.com/apps/pubs/default.aspx?id=67083 which I found the best intro to Core
14:28:16 <EvanR> whats the nature of this pattern matching stack
14:28:18 <ReinH> SoleSoul: you don't need to branch at all
14:28:28 <merijn> EvanR: It's an implementation detail
14:28:33 <SoleSoul> I'm trying to understand
14:28:34 <ReinH> This is lazy IO, so temps will only be evaluated if it is used
14:29:21 <luite> ReinH: like i said, you have to think operationally :) a thunk is then just a zero argument function that returns the WHNF reduced result
14:29:27 <SoleSoul> bitonic: can't I do it without an 'else'?
14:29:34 <bitonic> SoleSoul ReinH: again, I think that’s uselessly subtle.  I’d just put ’temps’ in the right branch.
14:29:37 <merijn> EvanR: Basically, the paper I just linked described a minimal, lazy language called Core (it's stripped down, but is essentially the same as GHC internal representation) and explains how one would compile Core to a "standard" CPU (in terms of C/asm translation)
14:29:49 <EvanR> alright
14:30:01 <bitonic> SoleSoul: you already have an ‘else‘.
14:30:04 <merijn> EvanR: Translating haskell to Core is pretty straightforward too
14:30:12 <ReinH> bitonic: ok :)
14:30:19 <EvanR> i read "implementation of function programming languages" and when i was done i felt like i knew zero about haskell and ghc
14:30:21 <ReinH> bitonic: I think I'm wrong about when readFile evaluates as well
14:30:27 <luite> ReinH: but i think it's quite useful to think of code that way, you only build up stack if you build recursive calls in the 'negative' position of a case
14:30:28 <merijn> EvanR: (Well, straighforward if you don't have to implement it and get all the corner cases right :) )
14:30:45 <bitonic> ReinH: whatever readFile does, I hope you see my point of being needlessly subtle
14:31:04 <ReinH> luite: yes, and you can use () -> a to simulate a lazy `a' in a strict language ;)
14:31:08 <ReinH> bitonic: yes, I do.
14:31:11 <merijn> EvanR: The pattern stack is an implementation detail, and that paper explains pretty well what you use it for and a few possible ways to implement it
14:31:33 <SoleSoul> bitonic: I use 'unless' because I don't want an 'else'. Trying to understand your meaning
14:32:04 <ReinH> luite: in Haskell, "constants" really are nullary functions. In strict languages, they are not. ;)
14:32:08 <EvanR> merijn: that link leads to a .ps.gz
14:32:17 <EvanR> ill find the pdf somewhere
14:32:38 <merijn> EvanR: Google Scholar should find it
14:32:57 <bitonic> SoleSoul: at some point in that ’main’, you branch based on whether ’n == 0’.  if it is, you also have to gather some data (temps).  so you need two branches, as you already have.  I don’t understand what you mean when you say “you don’t want ’else’”
14:33:22 <EvanR> if constants are "nullary functions" which are thunks to compute whnf, then that leaves the question of what regular functions are
14:33:28 <EvanR> 1-ary constants? lol
14:33:36 <SoleSoul> bitonic: The if is ok. A few lines above that there is an 'unless'
14:33:43 <exio4> is there anything that isn't constant?
14:33:58 <SoleSoul> bitonic: line 19
14:34:09 <SoleSoul> that's my confusion
14:34:36 <bitonic> SoleSoul: first, do you see why that’s syntactically invalid?  every ’x <- blah’ must be in a do-block, and ’temps <- getLine’ isn’t
14:34:48 <bitonic> moreover, it can’t be the last line of a do-block
14:35:32 <luite> EvanR: unless the constant is defined by some recursive procedure, i think it's easy to ignore that, things where for which you know that the recursion depth is bounded by some small constant are uninteresting (for fixing stack overflows at least)
14:35:40 <SoleSoul> bitonic: I think I understand that a do block can contain binding statements like 'temps <- getLine' but can't contain an 'unless' statement. Is that true?
14:35:47 <ReinH> EvanR: I'm talking about denotational semantics, not operational semantics :)
14:36:24 <bitonic> SoleSoul: it can contain ’unless’ statements – unless is a simple function, not syntax.  but then you use ’temps <- getLine’ as the second argument of ’unless’, where you’re out of the original do-block
14:37:26 <SoleSoul> bitonic: ah, unless is pure, and <- is binding which must be in a do block. Is that it?
14:37:59 <bitonic> SoleSoul: I’m not sure what you mean with “unless is pure” here, but yes, <- must appear in a do block.
14:38:19 <joelteon> unless is pure, just like (+) is pure
14:38:24 <bitonic> I think at the source of the confusion is the fact that you think that ’temps <- getLine’ is in the original do-block, while it isn’t
14:38:59 <luite> ReinH: with the "reducing a thunk is a call" it's also (in my opinion, but perhaps because i've implemented it this way) easier to factor in the other source of stack growth, update frames
14:39:15 <SoleSoul> that's what I want
14:39:25 <Hijiri> what's impure about <-
14:39:34 <SoleSoul> but I understand from your explanation that it isn't
14:39:43 <EvanR> whats an update frame
14:39:44 <Hijiri> <- is just syntactic sugar for something else that's pure
14:39:51 <bitonic> SoleSoul: but you can’t have that binding as an argument of a function or in a branch then.  either it’s in the original do-block or it isn’t.
14:40:12 <SoleSoul> Please don't ask about this pure/impure statement from me. I probably confused impure and do notation.
14:41:02 <Hijiri> If you have do {foo <- thing; x}, that's just syntactic sugar for thing >>= \foo -> x
14:41:21 <SoleSoul> bitonic: so binding can't happen conditionally?
14:41:38 <SoleSoul> (in one do block)
14:42:17 <bitonic> SoleSoul: I’m not sure what that means, but binding follows the scoping rules that you’d expect.  let’s say that you can’t do, like in an imperative language, ’int temps = 0; if (n == 0) { temps = scanf(…) }’
14:42:22 <luite> EvanR: if you apply a function g to some argument, like f x = g (x+1), and it's not on the lhs of a case (in core), then it's always a tail call (still this thing should raise a warning flag, but it won't grow the stack due to this call!)
14:43:07 <luite> EvanR: but if you have f x = x, then if x is a shared thunk, some let-bound value that's used by multiple things, then it will only be computed once
14:43:55 <SoleSoul> bitonic: that's exactly what I'm struggling with. To translate this logic to a functional language. I had no problem with the 'putStrLn $ show $ foldl choose 10001 $ map read $ words temps' because it's conceptually simpler but I'd really like to understand how to express this imperative logic here.
14:44:24 <Hijiri> is it really imperative logic?
14:44:34 <bitonic> SoleSoul: so, when do you want to read ‘temps’?  only when ‘n == 0’?
14:44:54 <SoleSoul> bitonic: yes, because if n == 0 then the read will fail
14:45:24 <ReinH> SoleSoul: There are two issues here. One is a syntax error. The other is that you can't operate in Haskell in a situation where a binding might or might not exist conditionally. The binding needs to either always exist or never exist.
14:45:26 <bitonic> SoleSoul: OK.  then I don’t understand your reluctance in putting it into the ’n == 0’ branch that you already have – it is exactly what you want, isn’t it?
14:45:53 <luite> EvanR: so operationally, reducing x is something like: reduceX x = case thunkStatus x of AlreadyReduced x' -> x'  NotYetReduced -> case realReduceX x of x' -> updateThunk x x' >> return x
14:46:24 <ReinH> SoleSoul: so `do { unless bool $ name <- computation; stuff that may use name }' doesn't make sense structurally
14:46:28 <bitonic> SoleSoul: if you’re not convinced why the current code doesn’t work, I still think that the confusion comes from the fact that you see the whole of ‘main’ as a big do-block, while the second argument of ’unless’ is some expression in itself
14:46:48 <SoleSoul> bitonic: I understood :)
14:47:04 <SoleSoul> I mean, I fixed it
14:47:07 <EvanR> luite: are you answering the question about update frames?
14:47:27 <lpaste> SoleSoul pasted “fixed” at http://lpaste.net/114131
14:48:01 <EvanR> if so, then i think i get it, you want to eliminate indirection to already evaluated values
14:48:05 <luite> EvanR: yep, the actual reduce call is now done on the lhs of a Case (it's never expressed in core like this though), so it needs to do a non-tail call to reduce, then overwrite the shared thunk x so it won't have to be computed again later, and then return it
14:48:05 <bitonic> SoleSoul: yep, that works
14:48:30 <SoleSoul> bitonic: when you said 'branch' it sounded like something important
14:48:38 <SoleSoul> more than a simple 'if' in C
14:48:42 <EvanR> luite: and i gather, work in a context of concurrency
14:48:50 <bitonic> SoleSoul: well, they are called branches :P
14:48:51 <luite> EvanR: for thunks that are used only once (as decided by the demand analysis), GHC does not push this update frame
14:49:13 <luite> EvanR: sometimes that can make the difference between constant stack and a stack overflow
14:49:18 <bitonic> SoleSoul: both in C and in Haskell
14:49:26 <SoleSoul> ReinH: I'm still reading your messages trying to keep up with both of you
14:49:46 <ReinH> SoleSoul: so your solution is the only real option: create a branch where the binding always exists and one where the binding never exists
14:49:49 <SoleSoul> bitonic: but in C I can 'branch' and come back
14:50:05 <luite> EvanR: for concurrency you're probably thinking of black holes
14:50:16 <luite> EvanR: which is overwriting the thunk at the start of the evaluation
14:50:28 <ReinH> SoleSoul: you can do other things after the if/then/else block
14:50:40 <luite> EvanR: you only need to overwrite shared thunks obviously
14:50:44 <bitonic> SoleSoul: in Haskell you can too, but you can’t have bindings defined in the branch to leak out
14:50:53 <bitonic> unless you explicitly return some value
14:51:17 <luite> EvanR: but GHC usually does not do this immediately, since there's some overhead in that, which is typically greater than the amount of duplicate work that can be avoided
14:51:55 <EvanR> that part is intresting
14:52:01 <bitonic> SoleSoul: gotta go, good luck with Haskell :)
14:52:05 <SoleSoul> bitonic: from the branch statement/function?
14:52:12 <SoleSoul> bitonic: thank you :)
14:52:13 <luite> EvanR: but it's important that the black holed thunks do not leak memory, so the actual blackholing does happen just before entering the GC
14:52:40 <SoleSoul> ReinH: couldn't reply to both of you at the same time but thanks for your explanations.
14:52:46 <ReinH> SoleSoul: sure :)
14:53:19 <luite> EvanR: it also happens when you explicitly request it, unsafePerformIO = unsafeDuplicatePerformIO (noDuplicate >> m)  is an example
14:54:00 <luite> EvanR: noDuplicate traverses the stack and actually performs blackholing so other threads cannot accidentally duplicate the IO action
15:00:42 <bitonic> luite: aha, noDuplicate is actually exported by GHC.IO!  I didn’t know it existed
15:02:14 <bitonic> obviously hidden haddock module.  I’d prefer a big disclaimer and haddock docs
15:06:13 <luite> GHCJS does eager blackholing, overwriting thunks with a black hole immediately, so noDuplicate is a no-op there (the reason is that GHCJS doesn't know when the JS GC is going to run, and this avoids unnecessary copying / promotion in a generational GC)
15:06:52 <Evilsparza> what would be the best method to split an arbitrary number of coins with positive arbitrary values amongst 2 different purses as equal as possible?
15:07:06 <Evilsparza> I'm currently using a greedy algorithm which works fine but gets really inefficient for bigger lists
15:07:22 <luite> Evilsparza: sounds like a dynamic programming problem
15:10:14 <luite> Evilsparza: you can do those nicely in Haskell by using laziness for your table of partial solutions
15:11:33 <Evilsparza> luite, great, I'll have a look
15:11:57 <Evilsparza> another unrelated question: how can I install Data.List.Tree ?
15:12:05 <Evilsparza> I can't seem to find it for the life of me in cabal
15:12:48 <luite> Evilsparza: if the coin values are integral and bounded (or you can scale them to be integral) then you can do it in constant memory
15:13:36 <EvanR> .oO(coin value is a repeating decimal)
15:14:31 <felixn> anyone ever return a parsec stream from parsec?  it sounds really fun ... :)  I'm running a preprocessor over my source, and I have the ability to do so, so why not?!
15:15:13 <Peaker> Evilsparza: https://hackage.haskell.org/package/ListTree-0.2.1/docs/Data-List-Tree.html <-- it's in the ListTree package?
15:15:28 <Peaker> felixn: how do you handle source positions?
15:16:49 <Peaker> Evilsparza: I think the coin problem is equivalent to subset sum, which is NPC ?
15:17:22 <luite> Evilsparza: using laziness for your table (or something like data-memocombinators to do it implicitly) will make it easy to experiment and to get nice speedups, but you use more memory and risk overflowing the stack, so you'd want a bottom up DP implementation for actual use
15:17:59 <felixn> Peaker: how is it currently handled?  does parsec not stream internally?
15:19:00 <body> hello,i updated my xmonad.hs config file and after i recompiled it .. i got this errors: https://bpaste.net/show/e86c2b38fe83 , everything was working like a charm before, version i'm using is xmonad 0.11, what could cause this ?
15:19:42 <Welkin> it can't find the modules
15:19:48 <Peaker> felixn: it does - but if you generate a new parsec stream, I think you somehow need to generate the new positions
15:19:48 <Welkin> they must have changed in the new version
15:20:10 <Welkin> body: just use the new config provided by the updated version
15:20:25 <Welkin> I don't use xmonad, so I can't tell you anything more specific than that
15:20:46 <ReinH> Peaker: Pretty sure it reduces to the knapsack problem?
15:20:48 <felixn> Peaker: my preprocessor just strips comments from the source, so I was thinking I could just skip over the comments, and resume the position from the last non comment char
15:21:09 <felixn> Peaker: err wait, it would be better to leave it where it was
15:21:11 <body> Welkin: uhm, what do you actually mean by using the new config provided in the updated version ?
15:21:54 <Welkin> oh, I thought you updated it
15:22:05 <michaelt> body did you install xmonad-contrib?
15:22:06 <body> Welkin: yes, i made the update
15:22:10 <Peaker> ReinH: which is NPC?
15:22:28 <ReinH> Peaker: Right. As long as it isn't bin packing we're OK ;)
15:22:43 <luite> Peaker: when stated with coins it's clear that it's amenable to the quasi-polynomial time solution to subset sum with dynamic programming
15:22:53 <Welkin> body: the errors are obvious
15:22:57 <body> michaelt: let me check, but i had everything installed,
15:23:00 <Welkin> it can't find the modules specified
15:23:02 <Peaker> ReinH: well, subset sum, knapsack, this coin division problem - are probably all NPC, equivalent up to polynomial conversions
15:23:14 <Welkin> I don't know about xmonad, so that is where my knowledge ends
15:23:23 <luite> Peaker: that's why i mentioned bounded and integral coin values as a requirement
15:23:25 <Peaker> luite: what does the "quasi" refer to?
15:23:58 <michaelt> body, the errors suggest it knows about xmonad-0.11 but some of the modules missing are from xmonad-contrib
15:24:07 <body> Welkin: yea, i understand , the wierd thing is the last time i compiled it it worked like a charm , and now i only changed a variable, and i got all those errors huh
15:24:20 <body> michaelt: i'm building xmonad-contrib again
15:24:22 <body> :)
15:25:02 <luite> Peaker: that it's polynomial time only with respect to a more restricted definition of the problem size
15:25:05 <body> michaelt: fuch yea, how the *%^&* my xmonad-contrib gone away i can't understand
15:25:12 <body> Welkin: fixed :)
15:25:25 <michaelt> body ghc-pkg list will tell you what you have installed .... ghc-pkg list xmonad-contrib will tell you about the package
15:25:36 <michaelt> ah good, body
15:26:22 <luite> Peaker: here it means that if you encode each input with unary encoding, like 11111 for a nickel, then your DP algorithm can solve it in a polynomial number of steps
15:26:28 <body> thank you michaelt :)
15:26:34 <luite> with respect to the number of ones used
15:26:48 <body> i was troubleshooting this for 3-4 hours without result doh :D
15:29:39 <luite> Peaker: urk, looks like i meant pseudo-polynomial time... not sure what's the exact difference
15:29:49 <Peaker> I read that wiki in the mean time :)
15:31:58 <luite> Peaker: at the other end of the spectrum you also have polynomial time depending on the computational model being used. linear programming is not known to have an algorithm that runs in polynomial time on a turing machine for example
15:33:17 <luite> but if you use a register machine and count instructions, then there are polynomial time solutions
15:35:37 <luite> and it's related to the same problem, namely whether your machine can work on operands of unbounded size in a single step
15:37:13 <benmachine> surely it can work on them in log time
15:37:26 <benmachine> which is, like, BASICALLY the same
15:37:55 <vanila> isn't it more that real computers have finite memory
15:38:45 <samba1> data A = B { foo :: Int } | C { foo :: Int , bar :: String } | D { foo :: Int , baz :: Bool }
15:38:56 <samba1> is there a good way of doing this without repeating the foo part in each constructor record definition? Anything of type A will guaranteed have a foo field of type Int, and others will have more.
15:39:01 <EvanR> gross
15:39:19 <bitemyapp> samba1: you really don't want to define record accessors in a sum.
15:39:25 <bitemyapp> samba1: split out the products.
15:39:31 <vanila> data A = B | C String | D Bool
15:39:34 <vanila> then use (Int, A)
15:39:38 <bitemyapp> samba1: you're creating partial functions that will fail at runtime.
15:39:43 <bitemyapp> that is Bad Mojo (™)
15:40:09 <EvanR> the lambda fairy will leave coal in your MVars
15:40:29 <luite> benmachine: right, but you can only go from linear to log if you're working with bits or similar, which is explicitly disallowed in the pseudo-polynomial time setting
15:40:45 <Peaker> samba1: data C = C { bar :: String } ; data D = D { baz :: Bool } ; data BCD = BCD_B | BCD_C C | BCD_D D ; data A = A { foo :: Int, bcd :: BCD }
15:40:50 <Peaker> Haskell records are cumbersome!
15:41:21 <luite> benmachine: and when that appears in the exponent of something, then you suddenly get your exponential blowup back, for free :0
15:41:31 <benmachine> eep
15:42:12 <luite> but not for the coin problem, that's well behaved!
15:43:36 <ReinH> Something something Vinyl
15:43:59 <samba1> it's nicer to pattern match when it's top-level, though.
15:44:32 <EvanR> eh
15:44:50 <EvanR> maybe you want to use Maybes then
15:45:35 <michaelt> (Int,A) is already present once A is defined as vanila recommended ...,
15:46:24 <michaelt> then you can say foolens = _1 and you already have a lens on the Int position.
15:47:10 <edwardk> if you foolens once, shame on you. foolens twice, shame on me.
15:47:27 <michaelt> indeed.
16:07:23 <haasn> do we have a foo lens yet?
16:09:09 <snyp> How is liftM different from fmap ?
16:09:23 <hpc> in type only
16:09:26 <snyp> ah
16:09:28 <snyp> ok
16:09:41 <snyp> so there are functors that are not monads?
16:09:46 <hpc> yes
16:09:48 <snyp> ah
16:09:51 <snyp> thanks
16:09:53 <Gurkenglas> What's the difference between "type Lens s t a b = forall f . Functor f => Optic (->) f s t a b" and "type Lens s t a b = Functor f => Optic (->) f s t a b"?
16:09:56 <hpc> an example is Set
16:10:20 <EvanR> why cant set be a monad, something to do with the Ord constraint?
16:10:25 <hpc> yep
16:10:39 <snyp> hpc: Set is a monad right?
16:10:42 <EvanR> what about unordered containers, i guess the same problem with Hashable constraint
16:11:28 <hpc> yeah
16:11:37 <hpc> the main issue is that you can't construct a Set a forall a
16:11:58 <hpc> if you define an indexed monad class it's quite easy
16:12:11 <hpc> in Set's case, indexed by Ord
16:12:20 <snyp> aha
16:13:01 <snyp> thank hpc
16:13:22 <hpc> you should work out the laws yourself as an exercise
16:13:36 <snyp> hpc: which ones? monad laws?
16:13:42 <hpc> yeah
16:13:45 <hpc> for Set
16:13:55 <snyp> hmmm. all right
16:14:02 <hpc> it's interesting because duplicate values get deduped
16:14:27 <snyp> i see
16:15:22 <snyp> hpc: is Data.Set instanced as a Monad in the standard library?
16:15:27 <hpc> no
16:15:29 <hpc> it can't be
16:15:30 <snyp> ah
16:15:47 <snyp> hpc: coz of that Ord restriction?
16:15:58 <EvanR> how does functor work then
16:16:21 <hpc> it... also doesn't
16:16:26 <EvanR> k
16:16:28 <hpc> i was wrong when i pointed that out earlier, good catch
16:16:58 <hpc> but there's an unsafe function that acts like fmap
16:17:03 <snyp> oh yeah EvanR mentioned it. sorry didn't  notice it
16:17:05 <bitonic> EvanR: the closest you can get to fmap is ‘mapMonotonic’
16:17:07 <EvanR> next up, a correct example of a functor which is not a monad ;)
16:17:23 <snyp> i was only following hpc's messages
16:17:35 <hpc> yeah, racking my brain for an example
16:17:49 <bitonic> EvanR: Const
16:17:56 <hpc> gah, that's it
16:18:03 <EvanR> any functor can trivially be made into a monad?
16:18:07 <hpc> Const is a Functor that isn't Applicative
16:18:10 * snyp doesn't no about Const
16:18:14 <snyp> *know
16:18:26 <bitonic> EvanR: I also have other examples – in general things where you can’t impose a specific flow when composing actions
16:18:29 <hpc> oh, ZipList is also Applicative but not Monad
16:18:33 <bitonic> Const is a bit contrived
16:18:49 <josephle> now to find a functor that is not applicative? :P
16:18:58 <hpc> josephle: that's Const
16:19:05 <hpc> you can't write pure
16:19:19 <ReinH> A multidimensional array is an applicative but not a monad
16:19:35 <snyp> i read somewhere a while ago all Monads must be Applicative too?
16:19:41 <hpc> yes
16:19:58 <hpc> specifically, the correct class definition should be
16:20:04 <hpc> class Applicative m => Monad m where ...
16:20:09 <snyp> hpc: oh sorry, you were saying the other way around
16:20:20 <josephle> interesting, but (Const m) is applicative if m is a monoid
16:20:21 <snyp> All monads are applicative, but not vice versa
16:20:25 <bitonic> EvanR: this is another useful example (ignore that Monad instance :P) <https://github.com/bitonic/tog/blob/master/src/Term/Types.hs#L432>.
16:20:54 <bitonic> I need to traverse things, and I can succeed, fail, or collect some information.
16:20:56 <edwardk> Gurkenglas: the forall is just being explicit
16:21:26 <bitonic> EvanR: the crucial bit is that <*> can collect information from both argument, while ap can’t
16:22:00 <EvanR> HMMM
16:22:03 <Gurkenglas> Is there an (unfoldrM :: Monad m => (b -> m (a, b)) -> b -> Recurse m a)? Recurse Maybe would make a list, Recurse [] a tree...
16:22:21 <Iceland_jack> > isJust (ap (Just undefined) (Just undefined))
16:22:23 <lambdabot>  True
16:22:45 <snyp> thanks again. bbl.
16:22:59 <ReinH> bitonic: eh?
16:23:22 <bitonic> EvanR: because it needs the argument from the first to compute the second
16:23:43 <bitonic> ReinH: what’s the question?
16:23:54 <ReinH> bitonic: what is this case where <*> and ap have different behavior?
16:24:13 <bitonic> ReinH: well, let’s clarify first
16:24:22 <benmachine> Gurkenglas: so, like, data Recurse m a = R (m (a, Recurse m a))? seems like a reasonable thing but I don't know where to find it
16:24:27 <Iceland_jack> ReinH: They no doubt meant that ‘ap’ can't inspect both arguments for Monadic instances
16:24:30 <benmachine> mumble mumble coalgebra
16:24:49 <benmachine> mumble mumble anamorphism, I dunno
16:24:51 <bitonic> ReinH:  yesterday I was talking about them having different operational behaviour for valid monad instances – which means that if I replace <*> with ap certain programs won’t work
16:25:16 <bitonic> ReinH: today I was saying how that Applicative *cannot* have a valid Monad instance with ‘ap’ preserving the semantics of ‘<*>’
16:25:25 <bitonic> (I was saying to EvanR)
16:25:35 <ReinH> (Which I argued should be considered a bug, and will actually be one in 7.10)
16:25:42 <bitonic> ReinH: it won’t
16:25:53 <bitonic> there’s nothing buggy about that
16:26:10 <benmachine> hpc: specifically Const Void is a functor that is not applicative
16:26:12 <bitonic> it’ll always be the case, as long as ‘ap’ is defined in terms of bind
16:26:16 <Gurkenglas> Interestingly, Recurse would be foldable x)
16:26:19 <benmachine> hpc: on account of how Void is not a monoid
16:26:36 <ReinH> bitonic: The AMP has instance Applicative m where pure = return; (<*>) = ap
16:26:40 <Gurkenglas> *Recurse m
16:27:07 <bitonic> ReinH: that’s not the point.  there can be valid instances of Applicative and Monad where the scenario I mentioned happens
16:27:29 <ReinH> And I'm saying that while both are valid per se, they are not valid together.
16:27:44 <bitonic> ReinH: yes, they are
16:27:52 <bitonic> wait let me give you a concrete example
16:27:58 <benmachine> bitonic: I believe it's a law that (<*>) = ap if both are defined
16:28:16 <benmachine> bitonic: I think many Haskellers would certainly regard it as extremely surprising if a type had incompatible instances like that
16:28:36 <benmachine> because we often consider (<*>) = ap a valid equation
16:28:37 <ReinH> Per the AMP, "liftM and liftA are fmap. The liftM* are liftA*, <*> is ap."
16:28:41 <benmachine> and really it ought to be
16:28:42 <ReinH> They are intended to be the same
16:28:45 <ReinH> If they are not the same, that will be a bug
16:29:05 <bitonic> ReinH: consider ‘(,) <$> writeToDB key value <*> readFromDB key’, using some ‘Request :: * -> *’ applicative.
16:29:18 <bitonic> now, this applicative in the above example can fire off both requests at once
16:29:30 <benmachine> so, as in the case of ZipList, we deliberately choose not to provide a Monad instance when it would not be compatible with the Monad
16:29:33 <benmachine> er
16:29:35 <benmachine> with the Applicative
16:29:54 <ReinH> Any Monad can give rise to two different applicative instances
16:29:56 <ReinH> I'm not doubting that
16:30:16 <ReinH> (at least 2)
16:30:28 <benmachine> ReinH: I bet those two are not necessarily distinct
16:30:43 <benmachine> but that's possibly needless pedantry :P
16:30:45 <ReinH> benmachine: Not always. They are the same for Identity, for instance.
16:31:13 <benmachine> hmm
16:31:22 <benmachine> certainly on total terms, they are also the same for Maybe
16:31:53 <benmachine> and they are the same for functions, right?
16:31:57 <bitonic> ReinH: I guess that now that I look at it that wouldn’t respect the laws.  I wonder what we should do in those cases
16:32:15 <ReinH> bitonic: :)
16:32:20 <EvanR> luite: reading this tagless stackless etc g machine paper, it reminds me of all the hub-bub about java, javascript, JIT technology
16:32:22 <benmachine> bitonic: newtypes! newtypes solve all problems
16:32:41 <ReinH> benmachine: Except for the "my monad is lawless" problem ;)
16:33:00 <jfischoff> Could haskell report include a specification for how haskell types are laid out in memory?
16:33:01 <bitonic> benmachine: right, but that is pretty inconvenient.  I’m confused because I’ve met code by pretty good people (see the facebook library thing by simonmar) that have this difference
16:33:22 <ReinH> bitonic: And it'll be interesting to see how he updates that code for 7.10 :)
16:33:29 <jfischoff> Perhaps users could specify it to some degree
16:33:32 <benmachine> bitonic: I agree it's inconvenient, I don't have a non-silly answer
16:34:04 <benmachine> bitonic: one approach you could take is to not specify in your semantics for your database engine whether the requests are dealt with in sequence or in parallel
16:34:10 <benmachine> bitonic: and then call it an optimisation
16:34:11 <bitonic> what was that library called?
16:34:19 <bitonic> I want to verify that that’s the case
16:34:35 <benmachine> I don't remember but I think I do remember the same as you
16:34:54 <ReinH> bitonic: Haxl?
16:35:03 <benmachine> e.g. that he was also interested in do-notation that used only Applicative when it could get away with it, so that some things could be transparently parallelised
16:35:14 <bitonic> EvanR: in any case, my point still stand – the interesting Applicative instance for that useful type does not extend to a Monad instance
16:35:17 <bitonic> ReinH: danke
16:35:41 <EvanR> i wasnt paying attention to this discussion
16:36:06 <bitonic> ReinH, benmachine: right, this is what I’m talking about <https://github.com/facebook/Haxl/blob/master/Haxl/Core/Monad.hs>
16:36:12 <benmachine> ReinH and EvanR should between them decide who has primary claim to five-letter names with capitals at both ends
16:36:17 <EvanR> though i should have been because i still dont know why a functor couldnt be upgraded to applicative / monad
16:36:26 <bitonic> benmachine: agreed.  it’s messing me up
16:36:38 <luite> EvanR: a JIT for Haskell could be quite effective, with much more high level information available (all unfoldings, types, rules) it could do much better than a JS or JVM JIT. if i wasn't sidetracked by some other compiler project i'd probably be working on that :)
16:36:39 <merijn> Anyone got any recommendations for papers on (implementing) extensible effects?
16:36:44 <EvanR> actually i get confused by ReinH because the first five letters of my last name are rineH
16:37:11 <bitonic> ReinH, benmachine: I guess he should at least mention that the Applicative/Monad instance is broken, if what you’re saying is correct
16:37:16 <merijn> luite: Not to mention that inlining the billion indirect jumps in compiled haskell would be superfast
16:37:46 <benmachine> EvanR: surely it's more natural to ask, why should it be possible, than why shouldn't?
16:37:52 <benmachine> things aren't possible unless they are :P
16:37:57 <alphonse23_> anybody know how to open a file in linux and allow it to update automatically
16:38:20 <EvanR> benmachine: yeah ill think about it on the ride home
16:38:22 <benmachine> EvanR: but Const Void is a trivial example of a functor that cannot be applicative: there are no values of type f a
16:38:34 <EvanR> what is Const anyway
16:38:42 <bitonic> EvanR: another useful example: optparse-applicative
16:38:44 <benmachine> Const a b = MkC a
16:38:58 <benmachine> so a value of type Const Char Integer, say, is just a Char
16:39:05 <benmachine> (packaged in a constructor)
16:39:32 <benmachine> so there are no (non-bottom) values of type Const Void ()
16:39:48 <benmachine> in particular there's nothing that really works for 'pure ()'
16:39:56 <benmachine> so you can't do Applicative
16:40:08 <josephle> ah, but if (Monoid a) => Const a b you can use mempty. okay, now it makes sense
16:40:19 <benmachine> but Functor is easy: you map the (a -> b) over all the a's by not doing anything, because there aren't any
16:40:44 <benmachine> josephle: right, that's why I'm picking Void, because it's the only type I'm confident isn't a Monoid
16:40:50 <benmachine> because there's no candidate for mempty
16:41:00 <ReinH> benmachine: Void is a monoid if you consider bottoms ;)
16:41:13 <ReinH> _|_ is a perfectly cromulent mempty
16:41:17 <benmachine> ReinH: if you consider bottoms you'd be surprised at the number of things which aren't Monads
16:41:22 <prophile> Maybe isn't a monoid
16:41:22 <ReinH> benmachine: ;)
16:41:29 <prophile> that's a type you can be sure about
16:41:32 <EvanR> fuck _|_
16:41:40 <benmachine> prophile: er, surely it is
16:41:48 <merijn> benmachine: No
16:41:50 <prophile> Maybe a might be, but Maybe isn't
16:41:51 <merijn> benmachine: Wrong kind
16:41:54 <prophile> :)
16:41:58 <benmachine> oh, that's silly :P
16:42:07 <luite> merijn: right, but you need to specialize everything, which is terribly difficult offline. low level tracing can take out some of the indirections, but i think a multi-level approach is needed for it to really scale, with a higher threshold to schedule specialization and inlining
16:42:12 <josephle> :k Const
16:42:13 <lambdabot> * -> * -> *
16:42:15 <benmachine> Maybe is not a type, it's a type constructor
16:42:16 <EvanR> so whats fmap for Const a
16:42:27 <prophile> it's a type of kind * -> *
16:42:31 <merijn> luite: If you have some good references on JIT like this, lemme know
16:42:34 <benmachine> EvanR: fmap f (MkC x) = MkC x
16:42:39 <EvanR> k
16:42:50 <benmachine> EvanR: notice that MkC x when x :: Char, say, can be Const Char whatever
16:43:00 <benmachine> Const Char Bool or Const Char String
16:43:12 <benmachine> so it typechecks easily
16:43:28 <benmachine> prophile: I disagree, types are attributes of values
16:43:30 <merijn> If you don't, I'll settle for papers on the theory and implementation of extensible effects :p
16:43:40 <benmachine> if you can't write it on the right hand side of :: then it isn't a type
16:43:42 <luite> merijn: and with the number of cores still increasing all the time, it might be better to spend some idle time (or unused memory bandwidth) on speculative optimization instead :)
16:44:15 <merijn> I wanna read up on "how to JIT", I just don't know where to start :p
16:45:02 <prophile> benmachine: in Haskell terms, they are types
16:45:12 <prophile> besides which, you can put Maybe on the RHS of ::
16:45:16 <prophile> you just have to put another type after it
16:45:17 <prophile> :P
16:45:24 <benmachine> prophile: *if you can't give it as the right-hand side of a ::
16:45:45 <benmachine> I disagree about "in Haskell terms"
16:45:54 <prophile> https://www.haskell.org/onlinereport/haskell2010/haskellch4.html#x10-970004.6
16:45:57 <benmachine> I would argue that * is the kind of types, while * -> * is a kind of type constructors
16:46:01 <josephle> in other kinding systems, * == Type :P
16:46:20 <ReinH> benmachine: type constructors are of kind k :)
16:46:30 <benmachine> ReinH: I said "a" not "the" :P
16:48:03 <luite> merijn: hmm, not sure if there's a canonical reference for that, the 2006 edition of the dragon book covers JIT compilation, but i don't really know in how much depth since i don't have it myself
16:48:17 <benmachine> prophile: I read your link and don't see where it disagrees with me
16:48:45 <prophile> ah, that's because I actually scrolled up then linked you to the wrong anchor
16:49:06 <prophile> https://www.haskell.org/onlinereport/haskell2010/haskellch4.html#x10-640004.1.1
16:49:11 <prophile> apologies
16:49:23 <prophile> "κ1 → κ2 is the kind of types that take a type of kind κ1 and return a type of kind κ2"
16:49:30 <prophile> types, not type constructors
16:49:39 <benmachine> I see
16:50:17 * benmachine shrug
16:50:38 <benmachine> I think my convention is clearer, even if it is nonstandard
16:50:46 <prophile> I wouldn't entirely disagree
16:51:20 * hackagebot win-hp-path 0.1.0 - Work with multiple Haskell Platform versions on Windows  http://hackage.haskell.org/package/win-hp-path-0.1.0 (YitzGale)
16:51:35 <josephle> one could argue that that Maybe isn't a well-formed type :P
16:51:52 <josephle> if the definition of well-formedness is having kind *
16:51:57 <benmachine> eh, there's nothing ill-formed about it as such
16:52:02 <benmachine> it's perfectly good at what it is
16:52:06 <prophile> you could Maybe argue that but it would be rather unkind to do so
16:52:07 <benmachine> just isn't a type of values
16:52:43 <benmachine> I guess I'm happy if instead of saying "type" I say "type of values" but I'm not sure I like that expression
16:52:56 <benmachine> basically my objection is, well, if Maybe is a type, then what is it the type *of*
16:54:16 <glguy> The haskell2010 link says "Maybe and IO are unary type constructors, and treated as types with kind ∗→∗."
16:54:55 <bitonic> I think it’s fair to the existing literature to call only things of kind * tyeps
16:54:56 <bitonic> *types
16:59:12 <edwardk> i personally tend to avoid the 'types are only kind *' viewpoint -- that kinda thinking precluded 'constructor classes' from entering the haskell lexicon until much later
16:59:50 <edwardk> kinds, types having kinds, and * and # just happening to be inhabited kinds gives a useful way to talk about the concepts we use
16:59:57 <edwardk> there isn't anything special about *
17:00:12 <bitonic> edwardk: there is.  things that inhabit * are inhabited by values
17:00:22 <edwardk> # is also inhabited by values
17:00:28 <edwardk> Constraint is inhabited by dictionaries
17:00:58 <bitonic> edwardk: # is inhabited by things inhabited by unboxed types – so I’ll call that unboxed type
17:01:31 <edwardk> you're welcome to do so, i'm merely explaining why i don't go in for the 'type constructor' vocabulary
17:01:45 <bitonic> edwardk: right, I think it’s just habit – I’m explaining my habit
17:01:46 <edwardk> i find that it holds people back from understanding other kinds
17:02:10 <bitonic> edwardk: so how do you distinguished unhabited things from non-unhabited things?
17:02:35 <edwardk> i'll talk about types inhabited by whatever
17:03:12 <bitonic> edwardk: I find that awkward because I often want to talk about inhabited things.  but again I’m probably influenced by literature I’ve read that talks about types that way
17:03:50 <edwardk> i write alarmingly few things 'grounded' in * these days, now that kind polymorphism is around
17:04:11 <bitonic> ehe.  fair enough
17:05:33 <edwardk> distinguishing it to the point of penalizing the discussion of other kinds just strikes me as counter-productive and leads to folks who are afraid of the exotic stuff, i understand the historical context, but its like all things -- we have to wait for the generation that thought of a thing a given way to die before there is progress ;)
17:06:21 * hackagebot stm-queue-extras 0.1.0.0 - Extra queue utilities for STM  http://hackage.haskell.org/package/stm-queue-extras-0.1.0.0 (JonSterling)
17:06:22 <josephle> when I learned about kinds (i.e. f-omega), the distinction between types and type constructors was probably more reasonable
17:06:34 <bitonic> edwardk: but I don’t think it hampers progress.  I just call all the other things “type formers” or “type functions” if they do something interesting.  but you’ve surely done more type-level hacking in Haskell than me
17:08:05 <bitonic> I guess in dependent types it really makes little sense to distinguish “kinded” things from normal functions and the rest, so that kind of terminology can never arise, and I tend to follow that
17:08:49 <edwardk> in the dependent type setting i follow the same vocabulary. =)
17:09:15 <bitonic> edwardk: so you call ‘Bool -> Set‘ a type?
17:09:43 <josephle> funny, I lose the distinction when it comes to dependent types
17:10:04 <edwardk> sure
17:10:06 <josephle> because I do think 'Bool -> Set' is a type
17:10:21 <bitonic> edwardk: OK.  that just feels weird to me
17:11:48 <edwardk> making up a second name feels weird to me, so we're even ;)
17:11:49 <josephle> bitonic, you just need to go up the hierarchy of type universes!
17:12:47 <bitonic> josephle: I don’t see how that helps
17:15:10 <josephle> in agda, (Bool -> Set) is in the universe Set1 if I'm getting my dependent types correct
17:15:19 <bitonic> josephle: sure
17:15:44 <josephle> so I see Bool -> Set as a type, but in a higher universe
17:15:45 <bitonic> still, I’m going to call types things that inhabit Set – what you’re talking about I call universes
17:16:56 <josephle> fair enough
17:21:21 * hackagebot data-carousel 0.1.0.0 - A rotating sequence data structure  http://hackage.haskell.org/package/data-carousel-0.1.0.0 (JonSterling)
17:21:23 * hackagebot log-domain 0.9.1 - Log-domain arithmetic  http://hackage.haskell.org/package/log-domain-0.9.1 (EdwardKmett)
17:21:57 <jroesch___> josephle: I think that is an important understanding to take away, System FC is constrained in such a way that you have these distinctions, but when you move to CoC or MLTT they all fall away.
17:22:33 <bitonic> jroesch___: I’m not sure who you’re talking to :P
17:22:59 <bitonic> oh sorry
17:23:04 * bitonic is very tired
17:23:20 <josephle> and in System F-Omega where we have dependent kinds, these distinctions seem to matter more
17:24:02 <sshine> MLTT?
17:24:04 <jroesch___> I was referencing whether you talk about them as types, kinds, sorts, etc
17:24:16 <jroesch___> Martin Lof Type Theory
17:24:19 <sshine> ah.
17:24:24 <josephle> is \x:k.x a type or type constructor?
17:24:37 <bitonic> jroesch___: right, they all fall away but you’re still left with types and universes
17:24:38 <josephle> jroesch___: I see what you mean
17:24:57 <jroesch___> I was referencing whether you talk about them as types, kinds, sorts, ect
17:25:24 <jroesch___> ^stupid irc cloud
17:25:37 <bitonic> that’s a lot of underscores
17:27:13 <josephle> I call (Bool -> Set) a type in the universe Set1, but bitonic thinks only things in Set should be called types
17:27:23 <josephle> bitonic: hopefully I'm not misrepresenting your position
17:27:51 <bitonic> josephle: I think that things that *inhabit* Set should be called types.  Set itself is a universe.  Things that inhabit Bool -> Set are type functions
17:28:02 <bitonic> type functions from Bool in this case
17:28:27 <bitonic> Bool -> Set itself is an indexed universe
17:28:39 <bitonic> of indexed family or something :P
17:29:03 <bitonic> I guess those are often called indexed types though.  what a mess
17:29:23 <josephle> naming things is hard
17:29:29 <bitonic> not worth talking about, people usually get this stuff across :P
17:31:22 * hackagebot win-hp-path 0.1.1 - Work with multiple Haskell Platform versions on Windows  http://hackage.haskell.org/package/win-hp-path-0.1.1 (YitzGale)
17:40:26 <zinfandel> hi, I've got a small question about cabal-install
17:41:34 <zinfandel> It feels strange. When I install something into somebox and cabal warns me that some packages (which are outside that somebox) might broke
17:41:49 <zinfandel> So that I have to do --force-reinstalls
17:42:16 <zinfandel> But is it actually true?
17:42:56 <zinfandel> From my understanding when I install something into somebox nothing gets changed in my ~/.cabal/, and therefore the packages installed there can't break
17:43:30 <edrahil> This is truly vexatious -- an explanation would be much appreciated. http://lpaste.net/114132 allEvenGood works correctly; allEvenBad is bad; allEvenBad [1,2,3] => True
17:44:09 <edrahil> (I'm not interested in better ways of writing this; I'm just experimenting with the Maybe monad.)
17:44:32 <edrahil> only difference is the "return"
17:44:42 <josephle> \msg lambdabot > isJust $ forM_ xs $ \x -> return $ if even x then Just () else Nothing
17:44:45 <josephle> oops
17:45:25 <josephle> > isJust $ forM_ [1,2,3] $ \x -> return $ if even x then Just () else Nothing
17:45:27 <lambdabot>  True
17:45:50 <josephle> > forM_ [1,2,3] $ \x -> return $ if even x then Just () else Nothing
17:45:51 <lambdabot>  No instance for (GHC.Show.Show (m0 ()))
17:45:51 <lambdabot>    arising from a use of ‘M60846473252493632182924.show_M60846473252493632182...
17:45:51 <lambdabot>  The type variable ‘m0’ is ambiguous
17:45:51 <lambdabot>  Note: there are several potential instances:
17:45:51 <lambdabot>    instance [safe] GHC.Show.Show a =>
17:46:03 <josephle> hmm
17:46:44 <Welkin> > forM_ [1,2,3] $ \x -> return $ if even x then Just x else Nothing
17:46:46 <lambdabot>  No instance for (GHC.Show.Show (m0 ()))
17:46:46 <lambdabot>    arising from a use of ‘M62662078218990541942984.show_M62662078218990541942...
17:46:46 <lambdabot>  The type variable ‘m0’ is ambiguous
17:46:46 <lambdabot>  Note: there are several potential instances:
17:46:47 <lambdabot>    instance [safe] GHC.Show.Show a =>
17:47:17 <Welkin> > forM_ [Just 1,Just 2,Just 3] $ \x -> return $ if even x then Just x else Nothing
17:47:20 <lambdabot>  Could not deduce (GHC.Num.Num a0) arising from the literal ‘1’
17:47:22 <lambdabot>  from the context (GHC.Base.Monad m)
17:47:24 <lambdabot>    bound by the inferred type of it :: GHC.Base.Monad m => m ()
17:47:26 <lambdabot>    at Top level
17:47:28 <lambdabot>  The type variable ‘a0’ is ambiguous
17:48:05 <Welkin> :t forM_
17:48:06 <lambdabot> Monad m => [a] -> (a -> m b) -> m ()
17:48:13 <josephle> > return Nothing :: Maybe ()
17:48:15 <lambdabot>  Couldn't match expected type ‘()’
17:48:15 <lambdabot>              with actual type ‘Data.Maybe.Maybe a0’
17:48:20 <josephle> > return Nothing :: Maybe (Maybe ())
17:48:22 <lambdabot>  Just Nothing
17:48:24 <josephle> there we go
17:48:50 <josephle> edrahil: return $ if even x then Just () else Nothing will aways return a Just
17:49:14 <josephle> > return $ if even 2 then Just () else Nothing :: Maybe (Maybe Int)
17:49:15 <lambdabot>  Couldn't match type ‘Data.Maybe.Maybe GHC.Types.Int’ with ‘()’
17:49:15 <lambdabot>  Expected type: Data.Maybe.Maybe ()
17:49:15 <lambdabot>    Actual type: Data.Maybe.Maybe (Data.Maybe.Maybe GHC.Types.Int)
17:49:20 <josephle> > return $ if even 2 then Just () else Nothing :: Maybe (Maybe ())
17:49:21 <lambdabot>  Couldn't match type ‘Data.Maybe.Maybe ()’ with ‘()’
17:49:21 <lambdabot>  Expected type: Data.Maybe.Maybe ()
17:49:21 <lambdabot>    Actual type: Data.Maybe.Maybe (Data.Maybe.Maybe ())
17:49:44 <edrahil> josephle: but the type doesn't match; 'result' must have type Maybe ()
17:50:00 <edrahil> Not Maybe (Maybe ())
17:50:17 <josephle> > return $ if even 2 then Just () else Nothing :: Maybe ()
17:50:19 <lambdabot>  No instance for (GHC.Show.Show (m0 (Data.Maybe.Maybe ())))
17:50:19 <lambdabot>    arising from a use of ‘M1828807190161565293212.show_M1828807190161565293212’
17:50:19 <lambdabot>  The type variable ‘m0’ is ambiguous
17:50:19 <lambdabot>  Note: there are several potential instances:
17:50:19 <lambdabot>    instance [safe] GHC.Show.Show a =>
17:50:23 <josephle> hmm
17:50:29 <merijn> edrahil: isJust makes baby jesus cry :<
17:50:40 <merijn> josephle: You're fucking up the scope of :: :)
17:50:50 <josephle> merijn: that explains it
17:51:20 <edrahil> merijn: I had result /= Nothing before, but lpaste complained and suggested isJust
17:51:23 <Welkin> who is this "jesus"?
17:51:28 <Welkin> some kind of celebrity?
17:51:30 <Welkin> a meme?
17:52:13 <edrahil> could someone explain it? scope of :: ?
17:52:15 <merijn> edrahil: Instead of /= use case
17:52:27 <josephle> > (return $ if even 2 then Just () else Nothing) :: Maybe (Maybe ())
17:52:29 <lambdabot>  Just (Just ())
17:52:29 <merijn> "case result of Nothing -> False; _ -> True"
17:52:34 <josephle> > (return $ if even 1 then Just () else Nothing) :: Maybe (Maybe ())
17:52:36 <lambdabot>  Just Nothing
17:52:48 <merijn> edrahil: :: has the lowest possible precedence
17:52:54 <edrahil> oh the pasted code doesn't have fucked up ::, right?
17:52:59 <Welkin> lower than $?
17:53:03 <Welkin> I thought $ was lowest
17:53:03 <josephle> nah, just my code
17:53:07 <edrahil> k
17:53:07 <merijn> edrahil: No, just the example of josephle
17:53:09 <josephle> apparently not
17:53:38 <edrahil> so does anyone understand this yet?
17:55:28 <merijn> edrahil: What inputs are you giving it?
17:56:30 <josephle> > forM_ [1,2,3] (\x -> return $ Nothing) :: Maybe ()
17:56:31 <lambdabot>  Just ()
17:56:43 <edrahil> merijn: [1,2,3] is sufficient to show the problem
17:57:01 <edrahil> confirm allEvenGood works with [2,4,6] or whatever
17:57:08 <josephle> edrahil, see my last example. (\x -> return $ ...) will always give a Just
17:57:27 <josephle> and then forM_ will see all these Justs, and evaluate to Just ()
17:58:21 <edrahil> josephle: but it's impossible for the type to be Maybe (Maybe ()); I wrote the type explicitly as Maybe ()
17:58:47 <josephle> edrahil: forM_ [1,2,3] (\x -> return $ Nothing) *is* of type Maybe ()
17:59:03 <josephle> but (\x -> return $ Nothing) is type Maybe (Maybe ())
18:01:26 <merijn> edrahil: What problem?
18:01:46 <merijn> edrahil: Your code does exactly what it should, afaict
18:02:57 <ReinH> Erm. forM_ will always return ()
18:03:03 <ReinH> So I don't see how either of them should work.
18:03:07 <structuralist> Maybe comes from the adjunction to the category of pointed types, right? (Roughly)
18:03:25 <ReinH> structuralist: I think so.
18:03:30 <structuralist> ("the adjunction" = free/forgetful)
18:03:38 <structuralist> what's the equivalent for Either e?
18:04:21 <athan> is there a function that takes a `f :: a -> c` and a `g :: b -> c` and creates a `f <+> g :: (a | b) -> c`, where the pattern match just uses the f or g implementation?
18:04:38 <structuralist> athan: like either?
18:04:47 <structuralist> :t either
18:04:48 <lambdabot> (a -> c) -> (b -> c) -> Either a b -> c
18:05:32 <structuralist> data Either a b = Left a | Right b
18:05:33 <athan> structuralist: I think so, I'm just wondering if theres a way to hoist the accepted value into it's Left or Right
18:05:34 <ReinH> Oh, haha, is this fail? Like, literally, is fail being called?
18:06:00 <structuralist> athan: not sure what you mean
18:06:04 <edrahil> Is there something special about the Maybe monad? I'm accustomed to code inside a "do" ending in "return foo". But with the Maybe monad it's all fucked up.
18:06:18 <structuralist> edrahil: no
18:06:25 <edrahil> This paste originally had a "do" block, and adding it now still has the problem
18:06:47 <merijn> edrahil: You're inserting something into Maybe (by using return), which translates to "wrapping it in a Just"
18:06:55 <merijn> edrahil: Then you proceed to check "isJust"
18:07:06 <athan> structuralist: where I can still do `f <+> g $ (x :: a)` or `f <+> g $ (y :: b)`
18:07:07 <merijn> edrahil: What would it possibly do, other than always return True?
18:07:11 <athan> without Left or Right
18:07:14 <ReinH> merijn: and yet it doesn't.
18:07:22 <merijn> ReinH: Doesn't?
18:07:28 <structuralist> athan: that would be ill-typed
18:07:49 <athan> gross :v
18:07:55 <structuralist> athan: though maybe you want something like row polymorphism
18:07:57 <merijn> :t forM_
18:07:58 <lambdabot> Monad m => [a] -> (a -> m b) -> m ()
18:08:05 <ReinH> > map allEvenGood [[1,2],[2,4]]
18:08:05 <ReinH> [False,True]
18:08:06 <lambdabot>  Not in scope: ‘allEvenGood’
18:08:16 <ReinH> merijn: it actually works o_O
18:08:41 <edrahil> I'm trying to understand the general case. "do ... return foo" is what I'm used to. Now I have a case where that's fucked. Suddenly I'm not supposed to say "do .. return foo".
18:08:42 <merijn> oh
18:08:44 <merijn> I see how
18:09:00 <ReinH> hahaha
18:09:05 <ReinH> sequence_ is naughty
18:09:12 <merijn> Nothing short-circuits the forM due to sequence
18:09:20 <athan> structuralist: Row polymorphism works with records / n-ary products, right?
18:09:22 <ReinH> merijn: indeed
18:09:24 <ReinH> lmao
18:09:54 <structuralist> athan: that's one thing; PureScript uses it for extensible effects also
18:09:55 <ReinH> > sequence_ [Nothing, Just ()]
18:09:57 <lambdabot>  Nothing
18:10:06 <merijn> And the return is inserting is creating "Maybe (Maybe ())", but that just gets discarded
18:10:12 <merijn> ReinH: No
18:10:21 <merijn> > sequence_ [Nothing, Just (Just ())]
18:10:23 <lambdabot>  Nothing
18:10:30 <structuralist> athan: this might be a rabbithole though; I'm not sure what you're doing
18:10:37 <merijn> And it typechecks because of forM
18:10:37 <ReinH> merijn: Er?
18:10:41 <merijn> eh, forM_
18:10:45 <ReinH> merijn: I'm talking about the good version
18:10:58 <Welkin> > sequence [Nothing, Just (Just ())]
18:10:58 <merijn> ReinH: Well, mine is what the "bad" version is doing
18:10:59 <lambdabot>  Nothing
18:11:01 <athan> structuralist: I'm making a type checker and signature lang for javascript :x
18:11:02 <josephle> merijn: yep...a series of unfortunate coincidences in allEvenBad
18:11:12 <athan> structuralist: Just stapling it together really
18:11:13 <structuralist> athan: gross :P
18:11:17 <athan> hahaha
18:11:26 <ReinH> merijn: no, I think it's...
18:11:31 <merijn> ReinH: It is
18:11:32 <structuralist> athan: in that case you might want to look at finally-tagless
18:11:35 <merijn> Think about it
18:11:36 <ReinH> > sequence_ [Just Nothing, Just (Just ())]
18:11:37 <lambdabot>  Just ()
18:11:41 <ReinH> that's what the return is doing
18:11:50 <athan> huh, I'll check it out. Thanks structuralist
18:11:59 <merijn> hmmm
18:12:00 <structuralist> athan: http://okmij.org/ftp/tagless-final/
18:12:06 <structuralist> you're welcome :)
18:12:07 <athan> So, what exactly is an adjoint...?
18:12:18 <athan> structuralist: Awesome, thanks :)
18:12:19 <ReinH> merijn: allEvenBad always returns True
18:12:23 <athan> I know what a functor is
18:12:26 <athan> and monoids, etc.
18:12:28 <merijn> ReinH: Right, that's what I said...
18:12:38 <merijn> Why were people telling me it wasn't working then?
18:12:46 <merijn> I should learn not to second guess myself
18:12:47 <ReinH> merijn: sequence_ [Nothing, Just (Just ()] would give False
18:12:48 <structuralist> athan: being adjoing is a relation that can exist between two functors going back and forth between two (possibly the same) categories
18:12:51 <structuralist> adjoint*
18:13:11 <josephle> I think edrahil wants to understand why allEvenBad doesn't act like allEvenGood?
18:13:16 <ReinH> merijn: the return makes it, e.g., sequence_ [Just Nothing, Just (Just ())]
18:13:26 <athan> structuralist: an isomorphic natural transformation?
18:13:28 <athan> :S
18:13:35 <structuralist> athan: there are equivalent ways to formulate it but the clearest way I think is an isomorphism between Hom(FX,Y) and Hom(X,GY)
18:13:36 <ReinH> allEvenBad always sticks a Just in, so there's no Nothing to short circuit the forM_
18:13:44 <ReinH> allEvenBad does not, so a Nothing will short circuit the forM_
18:13:45 <edrahil> I don't understand how Maybe (Maybe ()) can even exist here since 'result' is explicitly 'Maybe ()'. Is forM_ inferring some invisible type that's discarded?
18:13:53 <athan> ahh awesome
18:14:03 <ReinH> edrahil: forM_ discards the Maybe (Maybe ()) type and gives a Maybe ()
18:14:04 <structuralist> athan: which is natural in X and Y (doesn't use their structure, just the structure of the functors, intuitively)
18:14:06 <ReinH> :t forM_
18:14:07 <lambdabot> Monad m => [a] -> (a -> m b) -> m ()
18:14:19 <ReinH> edrahil: m b there is Maybe (Maybe ())
18:14:21 <juri_> why does my compile fail when i add -Wall?
18:14:22 <ReinH> m () there is Maybe ()
18:14:32 <athan> structuralist: oh!!! i see, so naturality is kinda like parametricity?
18:14:41 <structuralist> athan: for example, currying: Hom(A*B,C) ~ Hom(A,C^B)
18:14:46 <structuralist> athan: yes! very related
18:14:47 <ReinH> edrahil: forM_ throws away your Maybe (Maybe ())
18:14:50 <athan> ahh wow
18:15:18 <structuralist> athan: notice that composing those two functors gives you the state monad
18:15:29 <athan> wait...
18:15:30 <ReinH> juri_: did you add -Wall or -Werror?
18:15:39 <juri_> -Wall.
18:15:50 <edrahil> OK so "return Nothing" puts the Nothing in the Maybe monad. But Nothing is already in the Maybe monad, so we have two Maybe monads. Is that about right?
18:15:53 <ReinH> structuralist: (you only get internal homs in a CCC)
18:16:03 <athan> structuralist: Holy crap
18:16:04 <structuralist> trying not to be too pedantic here :P
18:16:07 <juri_> the same exact ghc invocation without -Wall compiles.
18:16:11 <ReinH> edrahil: let's look specifically at this:
18:16:12 <ReinH> forM_ xs $ \x -> return $ if even x then Just () else Nothing
18:16:16 <ReinH> now replace return with Just
18:16:23 <ReinH> forM_ xs $ \x -> Just $ if even x then Just () else Nothing
18:16:23 * hackagebot log-domain 0.9.2 - Log-domain arithmetic  http://hackage.haskell.org/package/log-domain-0.9.2 (EdwardKmett)
18:16:39 <structuralist> athan: any adjunction gives rise to a monad like this
18:16:59 <athan> how so?
18:17:01 <ReinH> forM_ will be creating a list full of Just values and then sequencing that list, giving a final value of Just () because all the members are Just values
18:17:29 <gcganley> :t forM_
18:17:30 <lambdabot> Monad m => [a] -> (a -> m b) -> m ()
18:17:38 <structuralist> athan: check out ddarius' article here (Calculating Monads with Category Theory): https://www.haskell.org/wikiupload/8/85/TMR-Issue13.pdf
18:17:39 <athan> you mean a state monad? structuralist^
18:17:51 <gcganley> :t mapM_
18:17:52 <lambdabot> Monad m => (a -> m b) -> [a] -> m ()
18:17:53 <athan> alright I'll check it out, thanks :)
18:17:54 <structuralist> athan: no, the state monad specifically comes from currying
18:17:57 <Javran> https://hackage.haskell.org/package/adjunctions-0.9.0.1/docs/Data-Functor-Adjunction.html
18:18:00 <ReinH> > let xs = [1,2,3] in forM_ xs $ \x -> Just $ if even x then Just () else Nothing
18:18:02 <lambdabot>  Just ()
18:18:08 <structuralist> athan: the continuation monad comes from flip
18:18:11 <athan> that's what I was thinking
18:18:14 <athan> oh wow
18:18:17 <athan> that's redicuous
18:18:29 <ReinH> structuralist: see also: Yoneda
18:18:42 <structuralist> ReinH: ?
18:18:58 <ReinH> structuralist: continuations are a yoneda embedding
18:19:12 <Javran> wow there're some instances like "Adjunction w m => Adjunction (EnvT e w) (ReaderT e m)" so adjunction gives rise to not only a monad and a corresponsing comonad?
18:19:19 <ReinH> edrahil: let's look at the list you are creating:
18:19:21 <ReinH> > let xs = [1,2,3] in (flip map) xs $ \x -> Just $ if even x then Just () else Nothing
18:19:22 <lambdabot>  [Just Nothing,Just (Just ()),Just Nothing]
18:19:33 <ReinH> edrahil: notice how ever element is a Just constructor?
18:19:37 <ReinH> *every
18:19:43 <ReinH> merijn: That's what I was getting at before
18:20:02 <ReinH> > sequence_ [Just Nothing, Just (Just ()), Just Nothing]
18:20:03 <lambdabot>  Just ()
18:20:08 <ReinH> Now, without the extra Just:
18:20:16 <ReinH> > sequence_ [Nothing, (Just ()), Nothing]
18:20:17 <lambdabot>  Nothing
18:20:25 <edwardk> Javran: that one is a consequence of the (,) e -| (->) e adjunction
18:20:26 <ReinH> forM_ calls sequence_ on the mapped values
18:20:27 <merijn> ReinH: That's exactly what I was saying before I was told "but it doesn't work like that"
18:20:36 <merijn> ReinH: So people were telling me the wrong thing
18:20:44 <ReinH> merijn: I didn't tell you that...
18:20:47 <structuralist> athan: Hask(A,R^B) ~ Hask^op(A^R,B)
18:21:01 <edrahil> ReinH: I think I understand now, but I want to find a way so this will never happen again. How do I make it more type-safe so that types other than Maybe () will be rejected?
18:21:24 * hackagebot log-domain 0.9.2.1 - Log-domain arithmetic  http://hackage.haskell.org/package/log-domain-0.9.2.1 (EdwardKmett)
18:21:25 <edrahil> This was the hardest bug ever for me; I want it out of my life for good.
18:21:28 <solatis> hmmm, why would anyone want a non-lazy haskell?
18:21:30 <ReinH> edrahil: don't use the version that throws away the intermediate type
18:21:33 <structuralist> ReinH: I need still need to come to grips with that
18:21:46 * solatis is reading about Mu at Standard Chartered, which is a strict, non-lazy dialect of Haskell
18:22:03 <Javran> edwardk: ah I see
18:22:17 <lritter> where do i go to when i need general advice on functional programming, notably how to deal with impure concepts
18:22:31 <sshine> lritter, here doesn't seem like a bad place...
18:22:34 <HeladoDeBrownie> lritter, if you ask specific questions, here is fine
18:22:34 <gcganley> lritter: here
18:22:34 <edrahil> ReinH: so a fold with forM (without underscore) or some such?
18:22:38 <lritter> okay
18:22:41 <structuralist> lritter: I've found this place incredibly helpful :)
18:23:01 <gcganley> lritter: any questions?
18:23:05 <ReinH> edrahil: In this case, I would probably start by not writing such convoluted way of testing for even-ness ;)
18:23:09 <sshine> lritter, you could try #ocaml or #sml, but this channel is very active.
18:23:11 <edwardk> lritter: this place works well, if you are uncomfortable there is also #haskell-beginners
18:23:25 <structuralist> lritter: also recommend Thinking Functionally with Haskell (by Richard Bird) if you want a comprehensive introduction
18:23:30 <sshine> lritter, or even #haskell-blah if you're afraid it'll go off a tangent :)
18:23:34 <lritter> i'm currently implementing a visual functional language using flow nodes, which is at times a bit new to me because i come from a purely imperative discipline, but i see the appeal
18:23:41 <ReinH> structuralist: +1 great book
18:23:48 <structuralist> is there a #haskell-math for mathematical tangents?
18:23:51 <edrahil> ReinH: I hate it when people take example code for real code. This was a simplified case of more complex code with the Maybe monad.
18:23:58 * structuralist thinks there should be
18:24:07 <edrahil> I'm learning the Maybe monad.
18:24:07 <ReinH> structuralist: there's ##category-theory, which is essentially #haskell-math
18:24:11 <structuralist> haha
18:24:14 <lritter> i have the pure functional side all down, but i struggle with the impure part, particularly elegant ways to deal with state machines and hardware resources like GL objects
18:24:17 <edrahil> Fuck other ways of calculating all evens.
18:24:19 <benzrf> ReinH: i thought it was #categorytheory
18:24:25 <ReinH> edrahil: Yes, I understand, but I can't give you better recommendations
18:24:30 <ReinH> ##categorytheory, sorry
18:24:37 <lritter> in fact, i'm really hoping that functional thinking helps to make better use of stateful things as well
18:25:11 <ReinH> edrahil: It's hard to know which parts of this code are essential and which aren't, so giving advice on changing it is difficult.
18:25:27 <lritter> in this particular instance, i understand that state creation can simply be described as holding the result of a computation in a symbol
18:25:30 <ReinH> Since none of it is essential per se
18:25:44 <gcganley> lritter: is this UI updateing at a fix rate?
18:25:56 <structuralist> I'm still trying to figure out what adjunction is behind the Either e monad
18:26:21 <ReinH> edwardk: ^
18:26:24 <structuralist> is it like pointed but with a generalized instead of global element?
18:26:32 <edwardk> structuralist: the key here is you are stuck thinking of the adjunction as being one that goes to and from something like hask
18:26:40 <edrahil> Is it possible to write a stricter forM_ where the intermediate type is explicit? That's really what I wish for; it would have averted this extremely difficult bug.
18:26:49 <lritter> gcganley, the IDE itself is written in Lua, but the graphical language that i'm implementing starts from a pure functional context
18:26:58 <edwardk> structuralist: go to/from the kleisli category
18:27:21 <lritter> gcganley, the first user application that i want to go for is people being able to interact with GL within that noodly system
18:27:21 <edrahil> Looking over monadic code, it's very hard to spot a superflous "return" that complies correctly but fucks everything up.
18:27:22 <ReinH> edrahil: no. You are depending on that behavior.
18:27:32 <gcganley> lritter: are we talking by 'graphical language' you mean a DSL, just trying to understand what you're up to
18:27:42 <ReinH> edrahil: it is when you write code that is designed to throw away superfluous returns ;)
18:27:48 <ReinH> Perhaps you really want sequence . map f
18:27:54 <structuralist> edwardk: is that necessarily the best way to look at it though?
18:28:00 <edwardk> sequence . map f = traverse
18:28:05 <ReinH> perhaps you really want traverse.
18:28:06 <gcganley> :t sequence . map f
18:28:08 <lambdabot> (FromExpr (m a), Show a1, Monad m) => [a1] -> m [a]
18:28:12 <edwardk> structuralist: : it is an adjunction that is always guaranteed to exist
18:28:15 <structuralist> edwardk: certainly other monads are easier (for me) to understand in terms of other adjunctions
18:28:20 <gcganley> ew
18:28:21 <structuralist> e.g. state, cont, maybe
18:28:24 <gcganley> :t traverse
18:28:25 <lambdabot> (Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)
18:28:27 <edwardk> structuralist: sure, those are nice ones =)
18:28:57 <ReinH> structuralist: if you don't like that one, try the Eilenberg-Moore category ;)
18:29:36 <edwardk> note 'Either e' is an annoying monad to think about in terms of adjunctions, but 'Either' the functor from Hask * Hask -> Hask -- is very nice to think about as adjoint to the diagonal functor from Hask -> Hask * Hask
18:30:05 <structuralist> edwardk: so do you think my hypothesis (that it's like maybe with the category of pointed types, except with generalized elements E -> A instead of global elements 1 -> A) is wrong? it's nice enough to satisfy me if true...
18:30:31 <edwardk> the problem is the structure that you'd like to have (a coexponential) to get a story like (->) e -| (->) e doesn't and can't exist in Hask.
18:31:04 <edwardk> so you're stuck with the 'uninformative' adjunction that just holds for all monads
18:31:04 <structuralist> I'm fine with not internalizing everything in Hask
18:31:42 <structuralist> edwardk: would be very interested in proofs of what can/can't exist in Hask
18:31:49 <gcganley> edwardk: i really dont like to think all the cat-theory subjects you talk about in here start with 'co' but you're consistently proving me wrong
18:32:15 * structuralist wonders what a co-category is
18:32:17 <edwardk> gcganley: i tend to pipe up when the co- topics come up lest they just go unanswered
18:32:33 <gcganley> whats a co-arrow?
18:32:47 <gcganley> lets go deep down the rabbit hole
18:33:00 <ReinH> gcganley: A co-arrow is an arrow.
18:33:09 <ReinH> or did you mean Arrow?
18:33:10 <gcganley> ReinH: damn...
18:33:10 <benzrf> a co-arrow would be an arrow in the opposite category
18:33:15 <benzrf> so just an arrow
18:33:28 <benzrf> but w/ a flipped type
18:34:26 <edwardk> structuralist: internal co-categories actually pop up occasionally
18:34:42 <ReinH> in Set^op
18:35:17 <gcganley> are there any other haskell shells other than hell and shelly?
18:35:44 <structuralist> edwardk: wha. where??
18:35:44 <I3MNIX> .close
18:36:03 <edwardk> http://ncatlab.org/nlab/show/cocategory
18:36:19 <benzrf> jesus what
18:36:24 * hackagebot win-hp-path 0.1.2 - Work with multiple Haskell Platform versions on Windows  http://hackage.haskell.org/package/win-hp-path-0.1.2 (YitzGale)
18:36:32 <structuralist> edwardk: oh, you didn't mean in programming... did you?
18:36:35 <ReinH> Oh. A comonad in the bicategory of cospans in C. Of course.
18:36:43 <edwardk> @google Lumsdaine cocategories
18:36:46 <lambdabot> http://www.tac.mta.ca/tac/volumes/25/9/25-09.ps
18:37:00 <edwardk> thats the right paper to start from definitionally anyways
18:37:09 <gcganley> edwardk: is nlab the goto site for category-theory?
18:37:27 <edwardk> gcganley: it is where i go to feel insignificant ;)
18:37:29 <ReinH> It's the goto site for explanations of category theory that you won't understand.
18:37:41 <ReinH> Where by "you" I pretty much mean everyone.
18:37:42 <structuralist> gcganley: for category theorists
18:38:04 <structuralist> gcganley: my other goto is #haskell :P
18:38:14 <gcganley> edwardk: how could the godly edward kmett feel insignificant!
18:39:18 <ReinH> impostor syndrome
18:39:56 <gcganley> why is impostor syndrome pop up all the time in programmers....
18:40:04 <gcganley> s/is/does/g
18:40:06 <MP2E> I'm so glad I discovered that was a thing. I used to think I was the only one that would think that >_> it took a good 2-3 years of hacking before I was comfortable calling myself a programmer
18:41:39 <ReinH> gcganley: it pops up all the time in people, and programmers ⊂ people
18:42:43 <gcganley> ReinH: im not doubting that im just saying it seems to be more vocalized, maybe i just have a small sample set but thats what my experience is
18:43:08 <ReinH> gcganley: yeah, I know what you mean. Unsure myself.
18:43:24 <gcganley> ReinH: also things like depression and OCD
18:43:33 <gcganley> ReinH: maybe we're just broken people
18:44:00 <ReinH> And now this is off topic... and rather depressing.
18:44:10 <gcganley> woops
18:44:30 <gcganley> sorry
18:44:42 <sshine> reverse Dunning-Kruger effect
18:46:32 <structuralist> intuition confirmed!
18:46:34 <structuralist> http://oleksandrmanzyuk.files.wordpress.com/2012/02/calc-mts-with-cat-th1.pdf
18:47:02 <structuralist> adjunction underlying Either e is adjunction to the coslice category e/Hask
18:47:43 <gcganley> is there a 'how to' read cat-theory notation for programmers?
18:48:16 <structuralist> gcganley: I recommend Awodey's Category Theory if you're familiar with basic proof-based math, or Lawvere's Conceptual Mathematics if you're new
18:49:10 <ReinH> gcganley: http://reinh.com/notes/posts/2014-07-25-recommended-reading-material.html might help
18:49:15 <gcganley> yeah my highest math class is the one im taking now, calc 1
18:49:36 <ReinH> gcganley: Conceptual Mathematics is great :)
18:50:26 <gcganley> ReinH: I would LOVE to learn that sort of thing, i just dont have the ground work layed... yet
18:50:41 <gcganley> ReinH: and this list is absolutly amazing
18:52:27 <structuralist> gcganley: Conceptual Mathematics is (apparently) based on an experimental course for high-schoolers
18:53:19 <structuralist> "Mac Lane can be used as a forcing function to read Awodey and Awodey can be used as a forcing function to read Lawvere." lol
18:53:28 <gcganley> structuralist: my highschool offers programming courses if they had conceptual math i would just die
18:53:41 <structuralist> gcganley: it's really friendly, try it
18:54:54 <dramforever> high school beginners' programming courses teach really slowly and is very easy to follow, imo
18:54:57 <structuralist> ... though you have a point, high school math education is a disaster
18:55:57 <structuralist> ReinH: have you looked at Abstract Algebra: Chapter 0? (or something like that)
18:57:04 <gcganley> my IT classes where a week at a time every 2 weeks so I learned alot in 2 years
18:57:17 <gcganley> the other two years was cisco routing
18:57:48 <gcganley> which the only programming thing i learned was dykstras spf
19:04:22 <ReinH> structuralist: I don't think so
19:05:04 <structuralist> ReinH: I think you'll find it to your tastes
19:05:14 <ReinH> structuralist: cool
19:06:11 <gcganley> :t _Pure
19:06:12 <lambdabot>     Found hole ‘_Pure’ with type: t
19:06:12 <lambdabot>     Where: ‘t’ is a rigid type variable bound by
19:06:12 <lambdabot>                the inferred type of it :: t at Top level
19:09:33 <gcganley> ReinH: is it known the company you work for or is that hush
19:09:44 <ReinH> gcganley: Pivotcloud
19:17:06 <lritter> sorry for pinging out
19:17:19 <lritter> had a 24h disconnect then the modem decided to freeze
19:17:29 <lritter> now our nice conversational flow is all ruined ;)
19:17:32 <carter> ReinH: hai
19:17:37 <ReinH> carter: o/
19:17:52 <carter> ReinH: does the product actually make sense now?
19:18:00 <ReinH> Sure it does.
19:18:06 <carter> it iddn't in february
19:18:08 <lritter> so, basically this is what i'm working on: http://i.imgur.com/vVGpuTC.png
19:18:16 <carter> though the executive team is different now right?
19:18:39 <lritter> this is a sheet explaining how i support first class functions
19:18:48 <structuralist> lritter: that's cute, where can I find out more about it?
19:19:02 <lritter> structuralist, the repo for it is here https://bitbucket.org/duangle/liminal_lua
19:19:34 <lritter> structuralist, but i don't have much visual material... i post a lot on twitter https://twitter.com/paniq
19:19:58 <dramforever> What's this Noodles thing?
19:20:04 <dramforever> I'm interested
19:20:16 <carter> lritter: that looks sweett
19:20:25 <carter> plz say it works on mac
19:20:32 <lritter> i used to already have a full code generator, but then i realized i'd rather start from an interpreter, and then do the code generation *in* that system
19:20:39 <dramforever> plz say it works on linux
19:20:42 <lritter> carter, i work on linux but it occasionally works on a mac
19:20:48 <carter> neat
19:20:55 <dramforever> where can I get it?
19:21:01 <lritter> currently i do linux stuff only, and there are two contributors who occasionally fix the codebase
19:21:08 <lritter> dramforever, see bitbucket link above
19:21:55 <lritter> the long term goal is to provide all basic functional programming concepts in a visual environment, with the goal of programming games and gameplay with it
19:22:08 <carter> lritter: have you seen lamdu?
19:22:38 <carter> ReinH: rumor has it you've been saying theres no TCO or stack again?
19:22:43 <lritter> carter, in fact, yes i did
19:22:45 <ReinH> carter: *sigh*
19:22:56 <ReinH> carter: there's TCO and a stack.
19:22:58 <carter> yes
19:23:00 <carter> :)
19:23:10 <ReinH> I never said there wasn't a stack.
19:23:15 <lritter> my original interpreter started out from lisp/scheme like concepts tho
19:23:18 <carter> theres actually two stacks
19:23:24 <carter> but that doesn't matter for this discussion :)
19:23:26 <Welkin> ReinH: I have been on the landing page for your company for minutes now and I have no idea what they do
19:23:29 * carter ducks
19:23:37 <carter> Welkin: i know rihgt? :)
19:23:59 <carter> the second stack is an implementation detail of a details though
19:24:10 <lritter> so, the issue i'm currently tackling is how to deal with stateful resources, like an allocated ffi object, or a GL object
19:24:14 <gcganley> ReinH: I was going to make a terrible pun about Rein clouds and then my internet cut out. i think comcast is trying to tell me to stfu
19:24:23 <carter> gcganley: no, keep at it
19:24:24 <carter> :)
19:24:24 <lritter> i understand that creation is as simple as storing the result of a function in a symbol
19:24:35 <carter> lritter: have you seen stable pointers/ stable names?
19:24:38 <lritter> but i wonder how to deal with freeing and reallocating objects
19:24:42 <structuralist> gcganley: I lol'd
19:24:45 <carter> hrmmm
19:25:14 <lritter> especially in groups; and how functional programming treats state machines
19:25:48 <lritter> i've read the monad wikipedia article, so i know the basics of monadic flow, but i'm not sure i grok what e.g. IO is doing internally
19:26:00 <dmbaturin> I'd like to see a real life example of a purely FSM implementation too.
19:26:09 <lritter> i also wondered if monads are generally a good way to build and unpack structs
19:26:55 <dramforever> I'm not sure, but I feel that in haskell monads are not as containers as computations
19:27:00 <structuralist> dmbaturin: by "real life" do you mean used in production for something or just working?
19:27:11 <carter> lritter: some of your engineering issues do sound to be questions folks who hang on #haskell-game  can help you figure out
19:27:19 <carter> lritter: or at least, theres a new opengl binding WIP
19:27:21 <dramforever> (learnt that "not as...as" here. Tell me if I'm using it wrong)
19:27:22 <carter> @hackage gl
19:27:22 <lambdabot> http://hackage.haskell.org/package/gl
19:27:25 <dmbaturin> structuralist: Just working and doing some more or less meaningful work.
19:27:30 <carter> well, opengl_raw analogue
19:27:30 <Gurkenglas> I have the feeling that a specialization of the IO monad that allows access to a specified amount of random access memory would be useful. Does my thinking that point out a specific failure in thinking?
19:27:49 <Welkin> I often caught myself thinking of the Flying Spaghetti Monster in my digital design courses whenever I saw FSM in the notes or on a board somewhere
19:28:01 <dramforever> me too
19:28:02 <gcganley> doesnt kmett have gl bindings?
19:28:03 <structuralist> dmbaturin: there's a really neat way of doing state machines using anamorphisms (unfolds)
19:28:08 <carter> gcganley: i just linked em
19:28:08 <gcganley> oh i see youve linked them
19:28:11 <lritter> carter, is it a 1:1 purely I/O based mapping or does it provide some sort of convenience layers
19:28:12 <carter> :)
19:28:29 <carter> lritter: ummm, ask edwardk  and others on #haskell-game
19:28:42 <structuralist> dmbaturin: I have an example but it's not finite :)
19:28:46 <lritter> carter, alright
19:28:55 <gcganley> how well populated are those haskell irc offshoots?
19:29:01 <carter> gcganley: some are pretty big
19:29:04 <gcganley> like #haskell-math and #haskell-game
19:29:05 <lritter> well actually it's not really GL in particular that i am bothered with, but rather the principles of dealing with impure stuff.
19:29:13 <dmbaturin> structuralist: What do you mean? It has infinite number of states?
19:29:15 <carter> gcganley: haskell-math isn't active, numerical-haskell IS active
19:29:26 <structuralist> dmbaturin: yeah
19:29:33 <lritter> i'm still in the process of designing this visual language; so far i take the abstract concepts and translate them to visual form
19:29:35 <dmbaturin> structuralist: Interesting. Where do I find it?
19:29:39 <gcganley> carter: are they the samething in priniciple
19:29:43 <carter> gcganley: true
19:29:46 <carter> i just run the latter
19:29:51 <structuralist> dmbaturin: https://github.com/structuralist/LoA
19:30:57 <structuralist> dmbaturin: the basic concept is that a coalgebra c :: S -> F S can be thought of as specifying a system with internal (unobservable) state S and external observables F
19:31:16 <gcganley> structuralist: lol kittychat
19:31:46 <dramforever> hmm.. looks like "hg clone -r b664273a455c http://hg.libsdl.org/SDL <dir>" is taking forever...
19:31:51 <structuralist> oh god don't all jump on there at once
19:32:00 <carter> gcganley: eg, the numerical channel has 55-65 people at any given time
19:32:23 <dramforever> well, #haskell has > 1k at any given time
19:32:39 <carter> dramforever: true, but numericals < 1 year old i think
19:32:54 <dramforever> well...
19:33:00 <carter> :)
19:33:15 <carter> dramforever: its actually one of the 5 biggest math channels on freenode afaict
19:33:42 <gcganley> carter: what is the biggest? #math lol
19:33:57 <dramforever> hmm, maybe
19:34:04 <dramforever> 775 people there now
19:34:12 <dramforever> well, 776
19:34:38 <dramforever> hmm.. ##math not #math
19:34:48 <carter> gcganley:  math, crypto, physics, econometrics, algorithms, science, not-math, neuroscience, #numerical-haskell
19:35:36 <dramforever> Wow, just saw this:
19:35:53 <dramforever> Someone translated "Python vs Haskell"
19:36:03 <carter> from what to what
19:36:10 <dramforever> English -> Chinese
19:36:11 <gcganley> dramforever: and?
19:36:28 <carter> gcganley:  math, crypto, physics, econometrics, algorithms, science, not-math, neuroscience, #numerical-haskell
19:36:33 <dramforever> under "Haskell can automatically infer types of your functions" (approximately)
19:36:34 <carter> gcganley: so top 10 on freenode
19:36:50 <dramforever> he/she noted: I'm not sure, but I don't believe it
19:36:57 <dramforever> well...
19:37:13 <carter> its a fun channel to lurk and lurn
19:37:14 <carter> on
19:37:23 <dramforever> It turns out that some people are afraid of haskell
19:38:53 <gcganley> dramforever: i was terrified to learn haskell. i was so scared from the lore c++ people give it
19:39:03 <dfeuer_> What's a .hsc file?
19:39:10 <dmbaturin> dramforever: If someone told me about type inference before I've seen it and without telling the details, I might not believe too. :)
19:39:12 <gcganley> .hsc is a core dump
19:39:19 <dramforever> huh??
19:39:23 <gcganley> let me look up a good article on core
19:39:30 <dramforever> no!
19:39:31 <carter> nope
19:39:37 <dfeuer_> gcganley, that's not true.
19:39:38 <carter> gcganley: dramforever  its a haskell c file
19:39:41 <carter> @google hsc haskell
19:39:42 <lambdabot> https://www.haskell.org/ghc/docs/7.8.2/html/users_guide/hsc2hs.html
19:39:46 <dramforever> NO! hsc2hs
19:39:47 <slack1256> ^this
19:39:52 <dramforever> yep hsc2hs
19:39:56 <vanila> carter, sorry that's wrong about TCO - the notion of tail position isn't transferrable to a lazy language
19:40:00 <gcganley> i thought hsc was core...
19:40:03 <gcganley> i guess im wrong
19:40:04 <carter> vanila: tell that to my compiler
19:40:05 <carter> :)
19:40:10 <gcganley> what file extention is core?
19:40:24 <dramforever> no file extension, i think
19:40:28 <carter> vanila: i can tell you with confidences, the GHC does tail calls
19:40:33 <structuralist> does anyone know of (the impossibility of) a way to do slice categories in Haskell?
19:40:36 <dramforever> yeah
19:40:37 <dfeuer_> carter, I'm hoping in a bit you'll be able to help me get over the first hump or so to getting fibon to compile.
19:40:39 <gcganley> so does tail calls
19:40:41 <slack1256> Mmm is true what they say; ask something maybe they won't answer, but tell the wrong answer and they will correct you.
19:40:49 <vanila> it will only do that to strict functions
19:40:53 <carter> no
19:41:05 <carter> a tail call is saying "function calls in tail positions are a jump"
19:41:13 <carter> thats a tail call
19:41:14 <dmbaturin> structuralist: I'm not sure I understand the concept of coalgebra. Suppose we have a ring of NxN matrices over R, what would be its coalgebra?
19:41:32 <dramforever> call func; ret -> jmp func
19:41:41 <dramforever> that's what I think tail call is
19:41:43 <vanila> function calls in haskell aren't implemented using jumps
19:41:54 <dramforever> hmm...
19:41:58 <dramforever> why?
19:41:59 <structuralist> structuralist: I'm talking about the notion of coalgebra for an endofunctor, which is just a morphism S -> FS for any object S
19:42:02 <structuralist> er
19:42:07 <carter> vanila: convince me that you're not wrong
19:42:11 <structuralist> dmbaturin, not myself
19:42:20 <carter> i shoudl be doing work, but i'll read the code gen to check
19:42:22 <dramforever> vanila: how can ghc make machine code, then
19:42:22 <carter> brb
19:42:41 <vanila> dramforever, it compiles to STG push/enter model which is easily translated into assembly
19:42:47 <structuralist> dmbaturin: in that code the endofunctor is Representation'
19:42:54 <carter> dramforever: ie its a jump :)
19:42:55 <dfeuer_> vanila, but in the end, you need ... jumps.
19:43:29 <carter> yup, we use JUMPs in the NCG
19:43:30 <carter> https://github.com/ghc/ghc/blob/master/compiler/nativeGen/X86/Instr.hs#L307-L316
19:43:31 <Javran> dramforever: I googled and found that Python vs Haskell translation, and that footnote lol
19:43:33 <ttuegel> in some sense, function calls in a lazy language are always tail calls: they "always" immediately return a thunk ;)
19:43:40 <carter> ttuegel: true!
19:43:44 <ttuegel> thus allocating no stack frames
19:43:44 <dramforever> Javran: !
19:43:47 <structuralist> dmbaturin: see http://ncatlab.org/nlab/show/coalgebra+for+an+endofunctor or http://en.wikipedia.org/wiki/F-coalgebra
19:43:55 <luite> vanila: GHC uses eval/apply, not push/enter
19:43:56 <carter> ttuegel: every fun call in haskel is in tail position after core
19:43:56 <dramforever> you can read Chinese??
19:43:58 <edwardk> gcganley: gl is coming along pretty nicely
19:44:04 <vanila> luite++ thanks for the correction
19:44:07 <dramforever> Javran: You can read Chinese?
19:44:08 <Javran> dramforever: I'm Chinese actually
19:44:12 <dramforever> oh
19:44:18 <gcganley> edwardk: what got you into gl?
19:44:29 <luite> vanila: also i disagree with you about tail calls, and with carters last remark :p
19:45:25 <dramforever> wow
19:45:39 <carter> luite: true
19:45:49 <carter> i think that last one was just me enjoying aggreing with ttuegel
19:45:50 <carter> :)
19:45:56 <carter> 'cause ttuegel  is AWESOME
19:46:00 * carter is tired
19:47:03 <luite> carter: i'd say that everything being a tail position only happens after cps transformation, but since the stack is explicit then, it's not particularly useful to just focus on the call instructions there
19:47:11 <carter> true
19:47:11 <carter> :)
19:47:17 <carter> every call in cps is a tail call
19:48:14 <gcganley> if only clojure had proper tail call optimizations
19:51:54 <dramforever> More on "afraid of haskell", here someone posted with title "Category theory is the foundation" and content "Who learnt it?"
19:52:04 <dramforever> http://tieba.baidu.com/p/1260550261 -- Chinese
19:52:28 <edwardk> @tell gcganley used to do gamedev/demoscene stuff 15 years ago. dusted things off a little while back for a project, anyways that rekindled the graphics bug a bit, and I looked around at the state of haskell game dev and decided to do what i could to shore it up a bit
19:52:28 <lambdabot> Consider it noted.
19:54:25 <blizzy> anyone think they can explain foldl and foldr?
19:55:43 <dramforever> foldr f z list replaces all (:)'s in list with f and [] with z
19:56:26 <dramforever> foldr (+) 0 (1:2:3:4:5:[]) = 1+(2+(3+(4+(5+0))))
19:56:35 <yukko> also foldr has f be right-associative, and foldl makes it left-associative
19:56:56 <yukko> so foldl would be (((((1 + 2) + 3) + 4) + 5) + 0)
19:56:58 <merijn> edwardk: ping?
19:57:05 <edwardk> pong
19:57:05 <dramforever> hey, how about http://foldl.com and http://foldr.com
19:57:45 <merijn> edwardk: As core library czar and person most likely to respond to me bugging them, what's your stance on making bracket's cleanup uninterruptible?
19:57:48 <blizzy> so foldl foo+bar+baz would be (foo+bar)+baz
19:58:07 <yukko> well, foldl needs a zero element
19:58:10 <edwardk> merijn: i'd personally punt that one out to the libraries list for broader discussion
19:58:14 <yukko> but yes
19:58:23 <merijn> edwardk: I did
19:58:27 <blizzy> what does the 0 element do?
19:58:29 <edwardk> and?
19:58:34 <dramforever> @src foldl
19:58:34 <lambdabot> foldl f z []     = z
19:58:34 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
19:58:37 <dramforever> @src foldr
19:58:38 <lambdabot> foldr f z []     = z
19:58:38 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
19:58:50 <merijn> edwardk: The first time there was 1 vague objection and 1 objection that didn't believe there was an issue
19:58:52 <dramforever> I feel that this explains foldl and foldr best
19:58:59 <edwardk> if it was ambiguous, put an email to the core libraries committee together, asking for a judgment on it
19:59:13 <dmbaturin> structuralist: Ah, interesting. I'm not very familiar (or very not familiar) with the category theory jargon, first time I see the F-algebra concept.
19:59:20 <yukko> well, the function that foldl takes has two arguments, one of them is the next element to work on, and one of them is the "accumulator", in the initial call to f, the accumulator has to be something, so we use the zero value for that
19:59:51 <edwardk> core-libraries-committee@haskell.org -- throw in the reasoning behind it, and a summary of the objections, and that'll get you an actual final decision on it
19:59:52 <dramforever> foldl f z list stuffs all elements in list into z with function f
19:59:57 <yukko> there is also a function called foldl1 which uses the first element of the list for that, but that restricts you to having an f :: a -> a -> a
20:00:06 <merijn> edwardk: ok, cheers :)
20:00:10 <dramforever> > M.insert
20:00:11 <lambdabot>  No instance for (Data.Typeable.Internal.Typeable a0)
20:00:11 <lambdabot>    arising from a use of ‘M56168193719434162708009.show_M56168193719434162708...
20:00:11 <lambdabot>  The type variable ‘a0’ is ambiguous
20:00:11 <lambdabot>  Note: there are several potential instances:
20:00:11 <lambdabot>    instance Data.Typeable.Internal.Typeable Data.Dynamic.Dynamic
20:00:20 <edwardk> merijn: i'm personally not too attached to it going either way
20:00:26 <merijn> Whoo, my proposal queue keeps growing >.>
20:00:48 <dramforever> > foldl Data.Set.insert Data.Set.empty [1,2,3,4,(5 :: Int)]
20:00:49 <lambdabot>  Not in scope: ‘Data.Set.insert’
20:00:50 <lambdabot>  Perhaps you meant ‘Data.List.insert’ (imported from Data.List)Not in scope: ...
20:01:28 * hackagebot trace 0.1.0.0 - A monad transformer for tracing provenience of errors  http://hackage.haskell.org/package/trace-0.1.0.0 (JonSterling)
20:01:32 <Javran> monoid is more neat if you doesn't care about how elements are combined together.
20:01:35 <blizzy> thanks for the help everyone. LYAH explains it with a picture, which helps.
20:02:07 <dramforever> hmm..iirc wikipedia has a pretty neat explaination, too
20:02:33 <yukko> blizzy I don't know if this is helpful at all, but another name for folding is reduction/reduce, probably because people often use folds to reduce a list into a single element (like folding + on a list of numbers)
20:03:06 <dramforever> > foldr Data.List.Insert [] [3,6,1,5,3,2,6,8,6,9]
20:03:08 <lambdabot>  Not in scope: data constructor ‘Data.List.Insert’
20:03:12 <dramforever> > foldr Data.List.insert [] [3,6,1,5,3,2,6,8,6,9]
20:03:13 <lambdabot>  [1,2,3,3,5,6,6,6,8,9]
20:03:27 <dramforever> insertio sort
20:03:28 <blizzy> thanks, yukko.
20:03:33 <dramforever> insertion
20:04:38 <Javran> > getSum $ mconcat $ map Sum [1,2,3,4,5]
20:04:40 <lambdabot>  15
20:04:52 <dramforever> ? 1 :: Sum Int
20:04:54 <dramforever> > 1 :: Sum Int
20:04:55 <lambdabot>  Sum {getSum = 1}
20:05:06 <dramforever>  > getSum $ mconcat [1,2,3,4,5]
20:05:21 <dramforever> huh?
20:05:30 <Pamelloes> So I'm thinking of storing hierarchical data in a Map with a hierarchical key. Is this a decent approach?
20:05:31 <dramforever> lambdabot, you still there?
20:05:34 <dramforever>  > getSum $ mconcat [1,2,3,4,(5 :: Sum Int)]
20:07:22 <Javran> > getProduct $ mconcat $ map Product [1,2,3,4,5]
20:07:24 <lambdabot>  120
20:07:51 <Javran> I feel these wrappers are a little verbose
20:12:48 <Javran> :t foldMap
20:12:49 <lambdabot> (Monoid m, Foldable t) => (a -> m) -> t a -> m
20:13:13 <Javran> > getSum $ foldMap Sum [1..5]
20:13:14 <lambdabot>  15
20:15:29 <zq> @hoogle Word32 -> ByteString
20:15:30 <lambdabot> Data.ByteString.Lazy unfoldr :: (a -> Maybe (Word8, a)) -> a -> ByteString
20:15:31 <lambdabot> Data.ByteString unfoldr :: (a -> Maybe (Word8, a)) -> a -> ByteString
20:15:31 <lambdabot> Data.ByteString.Lazy.Char8 unfoldr :: (a -> Maybe (Char, a)) -> a -> ByteString
20:15:34 <zq> no
20:16:06 <L8D> !hoogle unfold
20:16:11 <L8D> @hoogle unfold
20:16:11 <lambdabot> Data.List unfoldr :: (b -> Maybe (a, b)) -> b -> [a]
20:16:11 <lambdabot> package unfoldable
20:16:11 <lambdabot> Data.Tree unfoldForest :: (b -> (a, [b])) -> [b] -> Forest a
20:19:45 <sebastiankg> does anyone here use EclipseFP?
20:21:29 * hackagebot hoist-error 0.1.0.0 - Some convenience facilities for hoisting errors into a monad  http://hackage.haskell.org/package/hoist-error-0.1.0.0 (JonSterling)
20:32:32 <vanila> What is the notion of a tail call for (the lazy part of) haskell?
20:32:52 <merijn> vanila: What do you mean?
20:33:02 <vanila> e.g. in this:   go n = id (go (n-1))  what is the tail call?
20:33:32 <merijn> vanila: Both the call to id and the call to go are tail calls
20:34:31 <merijn> This is more obvious when you look at Core and know CPS, since core's pattern matching is essential CPS and in CPS all calls are tail calls
20:36:35 <vanila> so this is a different notion of tail call than scheme
20:37:06 <merijn> no
20:37:15 <vanila> in scheme only id is a tail call
20:37:19 <merijn> A tail call is essentially a "jump"
20:37:42 <merijn> i.e. instead of "call -> stuff -> return" you do "call -> stuff"
20:38:32 <merijn> vanila: Scheme's problem is that due to side effects they need to maintain ordering and things like function call stacks
20:38:49 <merijn> vanila: Haskell has no call stack
20:39:13 <Welkin> how does haskell manage it then?
20:39:17 <vanila> scheme gives a simple syntactic definition of tail position and says that calls in those positions will be optimized
20:39:28 <Welkin> I am only familiar with the call stack model used by C
20:39:32 <vanila> is there a similar syntactic definition of tail position for haskell?
20:39:44 <merijn> vanila: Right, but due to the way haskell is compiled *all* function calls are optimised to be tail calls
20:39:52 <vanila> I see
20:40:10 <merijn> Welkin: If you want the nitty-gritty details, I recommend the STG paper on how to compile Core
20:40:22 <blizzy> may someone explain this line?
20:40:23 <blizzy> sqrtSums = length (takeWhile (<1000) (scanl1 (+) (map sqrt [1..]))) + 1
20:40:38 <vanila> so it's not doing tail call optimization: A specific thing where you mark off tail calls and implement them differently. Haskell is just implemented in such a way that certain types of recursive loops work
20:40:45 <jle`> blizzy: what part are you having problems with?
20:41:01 <blizzy> scan1 (+) part.
20:41:16 <jle`> do you know what scanl1 does?
20:41:34 <jle`> > scanl1 (+) [1,10,100,1000]
20:41:36 <lambdabot>  [1,11,111,1111]
20:41:43 <jle`> > scanl1 (+) [1,2,3,4]
20:41:44 <lambdabot>  [1,3,6,10]
20:41:50 <blizzy> it's like foldl1, yet returns how it got there.
20:41:59 <merijn> Welkin, vanila: The way haskell works is as follows. Whenever you try to pattern match an expression, you evaluate it until you encounter a constructor, now before we can do this, we may need to do another pattern match. So we push a match on the pattern stack and merrily go on our way
20:41:59 <jle`> hooray!
20:42:09 <jle`> :D
20:42:09 <blizzy> hooray?
20:42:16 <jle`> so you understand?
20:42:21 <blizzy> yes.
20:42:29 <jle`> so what's the part you're having problems with?
20:42:48 <lpaste> structuralist pasted “Coslice categories?” at http://lpaste.net/114140
20:42:53 <jle`> > scaml1 (+) (map sqrt [1..])
20:42:55 <lambdabot>  Not in scope: ‘scaml1’
20:42:55 <lambdabot>  Perhaps you meant one of these:
20:42:55 <lambdabot>    ‘scanl1’ (imported from Data.List),
20:42:55 <lambdabot>    ‘BSC.scanl1’ (imported from Data.ByteString.Char8),
20:42:55 <lambdabot>    ‘Seq.scanl1’ (imported from Data.Sequence)
20:42:57 <jle`> > scanl1 (+) (map sqrt [1..])
20:42:58 <lambdabot>  [1.0,2.414213562373095,4.146264369941973,6.146264369941973,8.382332347441762...
20:43:09 * structuralist is stuck
20:43:22 <merijn> Welkin, vanila: Consider the expression "let f x y = y x in case f (1+2) Just of Nothing -> 1; Just x -> x"
20:44:36 <blizzy> hmm. let me try to walk through this. while 1000 is more than the length, an array is made from 1 to Infinity. Next, map is applied to the array, only making it have squareroots.
20:44:51 <merijn> Welkin, vanila: We put allocate thunks for the expression "1+2" and one for Just, and then we "jump" to 'f', we never need to return to "before" f, so no need to manage any stack
20:45:05 <blizzy> I'm confused of what happens next.
20:45:07 <jle`> blizzy: it might help to pull things out and name them
20:45:13 <jle`> i think you might have things in reverse order
20:45:23 <jle`> let's call sqrts = map sqrt [1..]
20:45:27 <jle`> > map sqrt [1..]
20:45:28 <lambdabot>  [1.0,1.4142135623730951,1.7320508075688772,2.0,2.23606797749979,2.4494897427...
20:45:37 <Welkin> merijn: aren't you still managing a pattern stack?
20:45:41 <merijn> Evaluating 'f' results in 'Just' applied to the thunk of "1+2", that is all we need to solve our match, so we stop and jump to the "Just x" case where we return 'x'
20:45:50 <jle`> so then the function is length (takeWhile (<1000) (scanl (+) sqrts)) + 1
20:45:58 <merijn> Welkin: Yes, but the pattern stack is not correlated to the number of function calls
20:46:05 <Welkin> okay
20:46:06 <jle`> and we can call cumulativesumsofsqrts = scanl (+) sqrts
20:46:07 <blizzy> so while the length < 1000, it keeps going?
20:46:21 <jle`> and our function is length (takeWhile (<1000) cumulativesumofsqrts) + 1
20:46:31 <jle`> s/function/value
20:46:41 <merijn> Welkin: So you can overflow the pattern stack (foldl (+) 0 is the usual example), but infinite recursion does not necessarily overflow the stack
20:46:56 <jle`> and we can say allcumulativesumofsqrtslessthan1000 = takeWhile (<1000) cumulativesumofsqrts
20:47:02 <Welkin> I see
20:47:11 <jle`> and so our value is length allcumulativesumsofsqrtslessthan1000 + 1
20:47:12 <merijn> Welkin: Because if our infinite recursion only uses 1 pattern match per iteration it has constant pattern stack usage, regardless of how nested our calls are :)
20:47:16 <Welkin> so are all thunks stored on this stack?
20:47:31 <jle`> and we can call numberofcumulativesumsofsqrtslessthan1000 = length allcumulativesumsofsqrtslessthan1000 + 1
20:47:34 <jle`> er, w/out the +1
20:47:46 <merijn> Welkin: The stack stores the pattern to match and which code path correspons to it
20:47:48 <jle`> and so sqrtSums = numberofcumulativesumsofsqrtslessthan1000 + 1
20:47:52 <merijn> Welkin: thunks are allocated on the heap
20:47:57 <Welkin> okay
20:48:07 <blizzy> ok then. thank you very much, jle`.
20:48:19 <jle`> blizzy: the neat thing about haskell is that you can pull anything out this way
20:48:25 <jle`> and name any sub-part
20:48:29 <jle`> without changing the meaning of the program
20:48:52 <jle`> haskell evaluation is just evaluation by subsitutition
20:49:02 <merijn> Welkin: For more details, the STG paper I mentioned earlier discusses (simplified) Core (a minimal lazy language that Haskell compiles to as internal representation) and then explains how to compile Core to C/asm. So if you like that kind of low-level reading it is well worth the read.
20:49:17 <jle`> (5 * 2) + 3 is identical semantically to let x = 5 * 2 in x + 3
20:49:17 <vanila> what im getting from the fast curry paper is that tail calls are performed when the full number of args are passed
20:49:54 <merijn> vanila: The fast curry paper describes an optimisation in the way thunks are entered
20:50:11 <merijn> Or, rather, a trade-off in how thunks are entered, I guess
20:50:40 <Welkin> merijn: I found this: http://www.scs.stanford.edu/11au-cs240h/notes/ghc-slides.html
20:50:46 <vanila> this is done by a dynamic check, inspecting the value
20:51:27 <vanila> I guess it's just a semantics thing, some people mean something else by TCO than what it means to me
20:52:01 <jle`> blizzy: one way that might help is to look at it in point-free form
20:52:15 <jle`> in this case it might be insightful
20:52:19 <merijn> Welkin: I was referring to this paper: http://research.microsoft.com/apps/pubs/default.aspx?id=67083
20:52:25 <blizzy> jle`, I have one question that I am confused on.
20:52:43 <blizzy> takeWhile is comparing 1000 to the length of the array?
20:52:45 <jle`> sqrtSums = (succ . length . takeWhile (<1000) . scanl1 (+) . map sqrt) [1..]
20:52:57 <blizzy> I was thinking about why they didn't use that.
20:52:59 <blizzy> lol.
20:52:59 <ReinH> vanila: that paper talks about a tail call optimization in GHC's runtime system, not a TCO  *of* Haskell expressions.
20:53:00 <jle`> blizzy: no, the takeWhile doesn't have anything to do with the length of the list
20:53:09 <jle`> so in that form, you can read it like this:
20:53:14 <jle`> take [1..]
20:53:17 <jle`> map sqrt to all the values
20:53:22 <merijn> Welkin: Those slides are good for the high level overview, but they don't seem to really cover how to turn Core into ASM
20:53:23 <blizzy> so, what is takeWhile doing?
20:53:31 <jle`> get the cumulative sum of that.  take them as long as the items are less than (<1000)
20:53:36 <jle`> take the length of that
20:53:40 <jle`> and add one to that number
20:53:41 <ReinH> vanila: at least, if it's the paper I think it is
20:53:45 <merijn> Welkin: Whereas the one I'm describing ignores the high level "Haskell -> Core" steps and focusses on "Core -> Cmm/ASM"
20:53:49 <vanila> How to make a fast curry
20:54:02 <jle`> blizzy: takeWhile is taking all of the items of that given list as long as the values are less than (<1000)
20:54:07 <L8D> @hoogle takeUntil
20:54:08 <lambdabot> No results found
20:54:10 <jle`> > takeWhile (< 3) [1,2,5,7,9]
20:54:12 <lambdabot>  [1,2]
20:54:12 * L8D cries inside
20:54:25 <jle`> > takeWhile (< 8) [1,2,5,7,9]
20:54:27 <lambdabot>  [1,2,5,7]
20:54:32 <blizzy> so, it compares each value in the array to the 1000.
20:54:37 <blizzy> and if it's more than 1000, it stops.
20:54:40 <jle`> blizzy: yup
20:54:47 <blizzy> ok. thank you very very much, jle`.
20:54:48 <L8D> takeUntil = takeWhile . (not .)
20:54:50 <jle`> btw, it's a list, not an array
20:54:52 <merijn> L8D: "takeUntil f" is just "takeWhile (not . f)"
20:54:59 <blizzy> thxs jle`.
20:55:11 <zwer> :t takeUntil
20:55:12 <lambdabot> Not in scope: ‘takeUntil’
20:55:16 <blizzy> and I thought learning Go was hard. :L
20:55:18 <Welkin> I never thought about how it works underneath
20:55:19 <L8D> merijn: I'm well aware
20:55:22 <vanila> https://www.haskell.org/pipermail/haskell-cafe/2009-March/058607.html
20:55:23 <L8D> blizzy: go is easy
20:55:24 <Welkin> this is interesting though
20:55:26 <Welkin> thanks merijn
20:55:29 <centrinia> @pl \f -> takeWhile (not . f)
20:55:29 <lambdabot> takeWhile . (not .)
20:55:30 <blizzy> I'm learning Go atm too.
20:55:31 <L8D> blizzy: do you know why?
20:55:31 <vanila> this says "tail recursion is not that useful of a concept in a lazy language like Haskell"
20:55:47 <blizzy> well, I guess because Go is similar to other languages?
20:56:30 * hackagebot conduit 1.2.2.2 - Streaming data processing library.  http://hackage.haskell.org/package/conduit-1.2.2.2 (MichaelSnoyman)
20:56:32 * hackagebot conduit-extra 1.1.4.2 - Batteries included conduit: adapters for common libraries.  http://hackage.haskell.org/package/conduit-extra-1.1.4.2 (MichaelSnoyman)
20:56:37 <ReinH> Guarded recursion is important, but so is lazy evaluation.
20:57:00 <L8D> @let takeUntil = takeUntil . (not .)
20:57:01 <lambdabot>  Defined.
20:57:15 <L8D> > takeUntil (>10) [0...]
20:57:17 <lambdabot>  A section must be enclosed in parentheses thus: (0 ...)
20:57:18 <L8D> > takeUntil (>10) [0..]
20:57:18 <vanila> it kind of feels like a PR thing, people want to say haskell has TCO so it sounds good - but it's not even needed because the concept doesn't apply
20:57:23 <lambdabot>  mueval: ExitFailure 1
20:57:39 <L8D> omg
20:57:58 <blizzy> so, um, why is Go easy again, L8D?
20:58:07 <Welkin> blizzy: why bother with Go at all?
20:58:15 <L8D> blizzy: go was founded on princibles that say "be simple"
20:58:22 <kadoban> vanila: A similar concept applies. You can generate an iterative procedure from a recursive function, which is what's usually desired...at least that's what I used to use "TCO" (incorrectly) as a shorthand for.
20:58:23 <blizzy> because I plan to be a Full Stack Web Dev.
20:58:31 <blizzy> and Go is backend and seems to be great.
20:58:38 <ReinH> vanila: to the extent that Haskell has tail calls, it also has TCO
20:58:40 <Welkin> it's not great
20:58:44 <L8D> blizzy: in rebellion of the common notion of complexity that languages like C++, Java, Scala, etc hold
20:58:49 <Welkin> it is just marketing hype
20:58:49 <blizzy> it seems GOod to me.
20:58:52 <merijn> blizzy: "Full Stack Web Dev", my condolences :D
20:58:53 <blizzy> bad joke was bad.
20:59:13 <L8D> merijn: can I have some condolences?
20:59:15 <vanila> kadoban, I feel like thismay be why there's no consensus - haskell people say TCO to mean something different from its usual meaning
20:59:15 <blizzy> thxs, merijn.
20:59:30 <L8D> merijn: http://l8d.github.io/portfolio/
20:59:46 <ReinH> vanila: Right, this is my problem with talking about TCO in Haskell as well, but it seems like everyone wants to talk about "tail calls"
21:00:03 <Welkin> I have yet to play with Haskell -> js projects, but I'll need to soon
21:00:05 <ReinH> and "Haskell has TCO" is more accurate than "Haskel doesn't have TCO" without having to get into the specifics
21:00:06 <L8D> merijn: but my previous question was why takeUntil isn't implemented anywhere?
21:00:18 <L8D> Welkin: just use haste
21:00:19 <Welkin> otherwise I'll have to continue writing js
21:00:29 <L8D> Welkin: don't even experiment with PureScript or Fay
21:00:40 <L8D> Welkin: just jump straight to Haste
21:01:00 <Welkin> I also want to use haskell for ios development
21:01:11 <Welkin> I just can't use other languages now -- it is frustrating
21:01:28 <L8D> isn't there GHC iOS?
21:01:39 <Welkin> does it support ios 8?
21:01:47 <merijn> L8D: Tier 2 support, yes
21:01:47 <prinsen> It cant do TH :(
21:01:56 <merijn> If you wanna make it better, help out! ;)
21:02:06 <merijn> prinsen: Luite's TH changes should improve that situation
21:02:25 <prinsen> merijn: Hows progress of TH for cross compiling?
21:02:25 <L8D> if it let's me do lazy evaluation and tco then I'm in!
21:02:51 <prinsen> merijn: Im writing a huge TH library, would be awsome to time it with cross compilation support
21:03:36 <merijn> prinsen: luite is trying to improve it for ghcjs, last I heard he thinks the same approach should be usable for other cross-compilers
21:04:31 <prinsen> Can anyone give their opinion on the following code
21:04:34 <lpaste> prinsen pasted “SubType” at http://lpaste.net/114143
21:04:38 <Welkin> is this it? https://github.com/ghc-ios/ghc-ios-scripts
21:06:41 <prinsen> Its used for representing types in ECMA-262, which I represent by nested Eithers. This class make it easy to work them
21:08:36 <HeladoDeBrownie> prinsen, I thought its "types" were basically just cases of a data type? Where does subtyping show up?
21:09:14 <L8D> prinsen: your function names are not very descriptive
21:09:22 <Hijiri> Go could be simpler
21:09:25 <Hijiri> it could be unlambda
21:09:42 <L8D> is unlambda simple?
21:09:45 <Hijiri> yes
21:09:50 <prinsen> HeladoDeBrownie: It does not have subtyping
21:10:23 <Hijiri> unlambda only has s and k combinators + function application
21:10:55 <tromp_> blc is simpler
21:10:58 <prinsen> HeladoDeBrownie: But the spec often asks to pass a Object to as function for a parameter with type (Number + ... + Object +..), and then its just easier to write (inj o)
21:11:20 <prinsen> L8D: inj and prj?
21:11:32 <L8D> prinsen: yes
21:11:40 <L8D> prinsen: you need more documentation
21:12:00 <L8D> prinsen: I'd recommend a read through the haddock manual and following that notation for documentation comments
21:12:10 <prinsen> good tip
21:13:01 <prinsen> It's pretty powerful though. inj lets you convert say a (Number + String) to a (Undefined + Number + Null + String + Object)
21:13:14 <L8D> prinsen: you can use the obscure names as long as they a) can't be confused with something else, b) are used consistently and c) are documented properlu
21:13:48 <prinsen> L8D: Inject and project, thought they were good :), but docs are alwasys good
21:46:32 * hackagebot conduit-combinators 0.3.0.4 - Commonly used conduit functions, for both chunked and unchunked data  http://hackage.haskell.org/package/conduit-combinators-0.3.0.4 (MichaelSloan)
21:47:27 <dfeuer_> Am I missing something, or is (<*) = const for (Either e)?
21:47:52 <dfeuer_> Except, I suppose, stricter?
21:49:00 <vanila> > Right "X" <* Right "Y"
21:49:01 <lambdabot>  Right "X"
21:49:04 <vanila> > Left "X" <* Left "Y"
21:49:06 <lambdabot>  Left "X"
21:49:11 <dfeuer_> No, I'm wrong.
21:49:31 <dfeuer_> Knew that had to be off.
21:49:34 <johnw> you could say that <* executes the "effects" of the right-hand side, but ignores the value
21:50:17 <dfeuer_> johnw, oh, so that if th eright hand side is lefty, it's lefty.
21:50:19 <dfeuer_> OK.
21:50:54 <Axman6> > Right "X" <* Left "Y"
21:50:56 <lambdabot>  Left "Y"
21:51:41 <Axman6> it's liftA2 const no?
21:52:31 <dfeuer_> I think so.
21:52:36 <dfeuer_> I think that's always so.
21:55:44 <dfeuer_> Ping hvr.
21:55:44 <jle`> liftA2 f (Right x) (Right y) = Right (f x y)
21:56:30 <jle`> liftA2 _ (Right _) (Left e) = Left e
21:56:39 <jle`> liftA2 _ e1 _ = e1
21:57:05 <jle`> ...was hoping that might provide some sort of insight but i am not sure where i am going anymore
21:57:14 <dfeuer_> Heh.
21:57:30 <dfeuer_> I'm kind of half asleep.
21:57:34 <jTT_> hey, does anyone know if there is a new bloodhound version out? My colleague imported v0.4.0.0 but I can’t seem to find that and he’s unavailable
21:57:39 <dfeuer_> I was hoping to ask hvr about his coercion allergy.
21:58:01 <dfeuer_> But I may not be awake if/when he shows.
21:58:17 <dfeuer_> I didn't exactly sleep last night.
21:58:54 <jle`> @check \x y -> ((x :: Either Int Int) <* y == x)
21:58:56 <lambdabot>  Precedence parsing error
21:58:56 <lambdabot>  cannot mix ‘Control.Applicative.<*’ [infixl 4] and ‘GHC.Classes.==’ [infix 4...
22:08:22 <samus> so what kind of fun stuff is coming in 7.10?
22:09:11 <adas> lightquake: i think applicative constraint will be placed on monad
22:09:37 <MP2E> lots of fun stuff
22:09:47 <MP2E> Do notation will desugar to Applicative when Monad is not needed
22:10:09 <Axman6> that's the Haxl stuff right?
22:10:21 <Axman6> well, from Haxl anyway
22:11:24 <lightquake> oh neat, what else?
22:17:06 <td123> lightquake: have you seen: https://www.haskell.org/pipermail/ghc-devs/2014-October/006518.html and https://ghc.haskell.org/trac/ghc/wiki/Status/GHC-7.10.1 ?
22:19:31 <lightquake> td123: i hadn't, thanks :)
22:24:01 <jle`> can we have an Applyable typeclass
22:24:26 <jle`> and overload function application (space)
22:24:56 <jle`> hm
22:25:02 <Iceland_jack> jle`: Yes please :)
22:25:12 <jle`> or can we just overload space to be (<*>)
22:25:24 <Iceland_jack> http://www.stroustrup.com/whitespace98.pdf
22:25:30 <jle`> and make all function literals overloaded...hmmm... ok
22:25:47 <benzrf> bye
22:26:59 <Axman6> jle`: I suspect that's an extremely bad idea
22:28:42 <jle`> nah
22:29:27 <jle`> (\f x -> f x) :: Applicative f => f (a -> b) -> f a -> f b
22:30:35 <Axman6> and automatically wrap everything in Identity?
22:30:52 <Axman6> if it's not already in an Applicative
22:31:09 <nitrix> Anyone knows the name of this symbol? Ƞ
22:31:36 <Axman6> eta?
22:32:15 <nitrix> What is its meaning in mathematics?
22:32:42 <jle`> it's just a letter
22:32:47 <jle`> so it depends on the context
22:33:09 <nitrix> "Mathematics, η-conversion, see lambda calculus"
22:33:19 <nitrix> I think it's the one I'm interested in.
22:33:40 <L8D> why do people think that Haskell is so extreme?
22:33:41 <nitrix> "In category theory, the unit of an adjunction or monad is usually denoted η."
22:33:50 <Axman6> http://en.wikipedia.org/wiki/Lambda_calculus#.CE.B7-conversion
22:33:51 <phaskell> B7: Diff 127 - https://phabricator.haskell.org/B7
22:33:52 <nitrix> Or actually, I think this is it. Makes more sense now.
22:34:11 <nitrix> L8D: Who thinks that?
22:34:15 <johnw> η in that context is what we Haskellers call "pure"
22:34:37 <L8D> nitrix: my coworkers
22:34:59 <nitrix> L8D: Maybe it's time to change job.
22:35:00 <L8D> the person giving a presentation at my meetup last night
22:35:38 <lightquake> what's so extreme about it?
22:35:39 <L8D> I've met many people who think that Haskell is something "extreme" and only suitable for acedemia
22:35:54 <nitrix> I had my manager on my back when I wrote "is not referentially transparent" in the documentation for an API.
22:35:55 <L8D> academia*
22:35:56 * lightquake is imagining someone riding a lambda-shaped skateboard while doing some sick ollies off a half-pipe or something
22:36:04 <jle`> probably bad PR
22:36:52 <L8D> like... do any of you guys think that Scheme is suitable for doing systems programming or distributed programming or web servers or whatnot?
22:37:03 <L8D> the stuff we use Haskell for
22:37:06 <nitrix> L8D: Good then, it helps you distinguish those that actually know more than the average on programming.
22:37:24 <L8D> that's the point of view they have for Haskell
22:37:36 <merijn> L8D: People have done all those things
22:37:40 <L8D> JavaScripters are so naive
22:37:41 <nitrix> L8D: People think learning/creating a language is just a different set of libraries and different syntax.
22:37:51 <merijn> L8D: Well, perhaps not in Scheme, but in Lisp
22:38:00 <merijn> L8D: Consider the LispMachine, for example
22:38:10 <L8D> merijn: I mean in the current day in age
22:38:30 <nitrix> L8D: So I'm not surprised they're confused when it comes to Haskell and actually having to learn new things.
22:38:36 <L8D> merijn: would you ever consider using Common Lisp or Scheme for something like that?
22:38:39 <L8D> I assume not
22:38:57 <L8D> Of course there is Clojure, but then again, of course there is Scala
22:39:15 <lightquake> i don't consider non-statically-typed languages suitable for doing Real Work
22:39:27 <lightquake> the fact that my day job involves using a non-statically-typed language to do Real Work annoys me
22:39:30 <sujeet> a proper noun, i guess
22:39:39 <Yarou> sounds like Blub to me
22:39:44 <nitrix> I've seen people write anything in any language. You're fallen in a common trap and makes your argument invalid to me.
22:39:44 <sujeet> real work is relative
22:39:47 <L8D> WTF IS BLUB?!
22:39:53 <L8D> I KEEP HEARING IT IN THIS CHANNEL
22:39:55 <sujeet> i do real work with weak types all day
22:39:57 <lightquake> blub is an essay by paul graham
22:39:57 <nitrix> Careful because there's a lot that wont pay attention to you either if you go that route.
22:40:07 <lightquake> about a hypothetical language, called blub
22:40:21 <L8D> can someone point me to the paper?
22:40:27 <keko-2> http://www.paulgraham.com/avg.html
22:40:29 <lightquake> whenever a blub programmer looks at a langauge that lacks feature X that blub has, they go 'wtf how can you survive without X'
22:40:41 <lightquake> when they look at a language with feature X blub *doesn't* have, they go 'why would you ever need X'
22:40:52 <L8D> ah
22:41:04 <lightquake> he then goes on to conclude that lisp is the most powerful language because ?????
22:41:33 <merijn> L8D: I wouldn't, but then I'm a type afficionado :)
22:41:47 <mauke> (lisp is blub)
22:41:48 <merijn> L8D: Blub refers to an essy by Paul Graham
22:42:06 <merijn> L8D: See http://www.paulgraham.com/avg.html
22:42:13 <L8D> also what about the people who get intimidated by Haskell and refuse to learn it because they think they're too dumn?
22:42:17 <lightquake> more specifically: because a good chunk of the code he wrote for some program  uses macros. other languages have macros. therefore it would be very difficult to write that program in other languages
22:42:18 <merijn> L8D: And also http://c2.com/cgi/wiki?BlubParadox
22:42:25 <lightquake> er, other languages *don't* have macros
22:42:46 <Geekingfrog> Hello all. Total noob here. I'm having an issue with ghci.
22:43:01 <Geekingfrog> (with import Data.List.Split): let test x = splitOneOf " -" $ map toLower x
22:43:01 <lightquake> mauke: all languages are blub!
22:43:03 <Geekingfrog> this works
22:43:13 <Geekingfrog> let t = splitOneOf " -" $ map toLower
22:43:15 <L8D> lightquake: FORTH has "macros"
22:43:17 <Geekingfrog> this doesn't
22:43:18 <L8D> FORTH has metaprogramming
22:43:26 <lightquake> L8D: yes. i also think that paul graham is a total lisp weenie
22:43:29 <Yarou> L8D, that's actually a good point. one does not need to fully understand category theory to be productive in haskell
22:43:32 <lightquake> and i don't like him :V
22:43:38 <Yarou> much like i don't understand SVMs completely, but i still know when to use them
22:44:04 <merijn> Geekingfrog: You've fallen into the trap that, while overtime ghci has started resembling 'real haskell' more and more, things typed into ghci and things typed in a source file are not the same
22:44:06 <L8D> "But category theory is simple once you understand it!"
22:44:17 <lightquake> Geekingfrog: that evaluates as `let t = splitOneOf " -" (map toLower)`
22:44:21 <L8D> People just get scared by "theory" in there
22:44:25 <mauke> Geekingfrog: did you mean . instead of $?
22:44:31 <merijn> Geekingfrog: Also your use of $ is wrong yeah
22:44:38 <MP2E> I know with my friends they thought that Haskell was intimidating or 'too hard' because of the fact that it is purely functional, and they can't imagine a way to reason about effects in a purely functional langauge, therefore it can't happen
22:44:43 <MP2E> which of course is wrong :P
22:44:52 <L8D> Like... you could just explain it as if category theory was just a specification of interfaces for different types
22:45:05 <merijn> L8D: Despite category theory being simple (and at the same time not simple), category theory is essentially useless for learning haskell
22:45:11 <L8D> not some abstract mathematical concept
22:45:21 <merijn> I don't know where this, incredibly persistent, meme has come from
22:45:30 <lightquake> category theory's simple! you got some objects and some arrows. boom.
22:45:39 <L8D> https://github.com/fantasyland/fantasy-land
22:45:42 <jle`> bada bing bada boom
22:45:47 <L8D> all you need to know about category theory
22:45:55 <merijn> Most of the people involved with haskell development barely now category theory and haskell was certainly not founded on it
22:46:08 <lightquake> merijn: it fits the 'haskell is a useless academic language' and 'haskell is complicated and i (think i) know haskell therefore i'm smart' and 'haskell is complicated therefore i can't learn it' memes
22:46:36 <merijn> We basically pay Wadler in paper citations for smuggling complicated CT terminology out of math papers and bootlegging second hand abstractions :)
22:47:04 <L8D> Wadler: would you like your payment in gold or milk?
22:47:19 <Yarou> some people like being human compilers lightquake
22:47:32 <merijn> I honestly wish everyone who's not a mathematician would shut up about category theory's relation to haskell, and I say this as someone trying to learn category theory >.<
22:47:46 <lightquake> merijn: psst, wanna buy some epis
22:47:49 <L8D> merijn: what's there to learn?
22:48:00 <merijn> L8D: 80+ pages of Awodey book
22:48:30 <Iceland_jack> merijn: Fully agree
22:48:32 <Yxven> merijn people recommended I applied comonads, yonedas and coyonedas to my first haskell program. All of which are only explained with terms from category theory
22:48:34 <monochrom> enthusiastic vocal minority is more influential than hands-on silent majority. enthusiastic vocal minority talk about category theory all day enthusiastically and is why people mistake that haskell is about category theory
22:48:40 <L8D> merijn: but you already know what Functors and Monads and Monoids and Applicatives and Comonads do
22:48:44 <Geekingfrog> how would I remove parentethis from this: projectNameFromString str = intercalate "-" (splitOneOf " -" (map toLower str)) ???
22:48:57 <mauke> Geekingfrog: lots of $
22:49:04 <Geekingfrog> and get rid of the named argument str
22:49:11 <merijn> L8D: Do you know what adjuncts are? Cartesian closed categories?
22:49:23 <Iceland_jack> Geekingfrog:
22:49:23 <Iceland_jack> :t intercalate "-" . splitOneOf " -" . map toLower
22:49:24 <lambdabot> [Char] -> [Char]
22:49:33 <merijn> L8D: Turing categories, eh, let's see what other fancy things came up at OPLSS...
22:49:34 <mauke> Geekingfrog: lots of .
22:49:35 <Geekingfrog> indeed it works when coming from a file
22:49:36 <monochrom> this is why I am wary of any enthusiastic community. it is bound to have wrong priorities.
22:49:38 <L8D> merijn: that's that the part of category theory that's relevant to learning Haskell
22:49:46 <L8D> that's not the part*
22:49:55 <nitrix> merijn: Is there any requirement prior to reading it?
22:50:12 <nitrix> merijn: I might do an impulsive purchase.
22:50:44 <merijn> L8D: Haskell's functor, monad, applicative and monoid are not really related to category theory's versions
22:50:46 <lightquake> isn't half the point of category theory that you can do it without knowing anything else? ;)
22:50:51 <merijn> nitrix: It's still a bit mathy
22:51:02 <lightquake> it's foundations!
22:51:09 <L8D> merijn: then what do we call that collection of type classes?
22:51:23 <Geekingfrog> Iceland_jack, it works thanks
22:51:27 <lightquake> though for awodey's thing, i think knowing some basic group theory/ring theory/topology is really useful to understand his examples
22:51:28 <merijn> nitrix: A lot of examples are based on partial orders, etc and other stuff that I haven't used in years
22:51:37 <merijn> L8D: "haskell"
22:52:12 <merijn> L8D: Functor's are merely endofunctors, such a boring part of CT they're barely a footnote. Monads have little to do with the CT version, I'm not even sure Applicative is a thing in CT?
22:52:17 <merijn> And monoids are algebra, not CT
22:52:21 <L8D> merijn: but you can apply that knowledge to places outside of Haskell pretty easily
22:52:44 <L8D> like with my example
22:52:49 <L8D> or in Scala or Clojure
22:53:33 <lightquake> the other day I was messing around with rust and discovered that it has the moral equivalent of Either and Either's bind
22:53:35 <lightquake> i was so happy
22:55:58 <sujeet> wtf learnyouahaskell.com? "Here's a problem that combines tuples and list comprehensions: which right triangle that has integers for all sides and all sides equal to or smaller than 10 has a perimeter of 24? First, let's try generating all triangles with sides equal to or smaller than 10:" > let triangles = [ (a,b,c) | c <- [1..10], b <- [1..10], a <- [1..10] ]
22:56:45 <sujeet> that's clearly just a set of triples of integers between 1 and 10, and not the set of integer-valued sides of a triangle between 1 and 10
22:56:59 <sujeet> e.g. (1,2,4) is not a triangle!
22:57:26 <Geekingfrog> read on
22:57:27 <belst> sure it is
22:57:33 <kadoban> sujeet: It's a pretty straightforward representation of one.
22:57:39 <peddie> sujeet: it's not a right triangle, but it's a triangle
22:57:41 <Geekingfrog> it builds the solution in small steps
22:57:46 <ThreeOfEight> (1,2,4) violates the triangle inequality
22:57:49 <sujeet> exactly
22:57:51 <kadoban> Oh
22:57:54 <kadoban> Yeah...
22:57:56 <sujeet> 1,2,4 cannot be a triangle
22:57:56 <peddie> oh, no, you're totally right :)
22:58:16 <Geekingfrog> yeah, calling that triangles is a bit presomptuous
22:58:27 <ThreeOfEight> but the restriction that a² + b² = c² solves that problem
22:58:35 <lightquake> yeah
22:58:51 <sujeet> i was wondering if there was a clever way of saying "sum of any two of a,b,c < the other"
22:59:17 <L8D> merijn: how about "algebraic data types and categories" ?
22:59:19 <sujeet> #haskell question, what's the most elegant way to define 'triangles' properly?
22:59:37 <merijn> L8D: How do ADTs relate to categories?
23:00:01 <merijn> L8D: ADT have a way more simple and concrete basis in algebra
23:00:02 <L8D> I mean using that term to describe the collection of type classes in Haskell
23:00:18 <sujeet> zeroth-order: let triangles = [ (a,b,c) | c <- [1..10], b <- [1..10], a <- [1..10], a + b > c, a + c > b, b + c > a ]
23:00:24 <L8D> categories as in Functors and Monads and types as in Monoids and Setoids
23:00:32 <ThreeOfEight> sujeet: well, you can define it as a set of three points.
23:01:13 <sujeet> i'm fine with the side-length representation
23:03:13 <jedai> sujeet: you can simply generate sides in the order of their length then you only have one verification to do
23:04:09 <jedai> > let triangles = [ (a,b,c) | c <- [1..10], b <- [c+1..10], a <- [b+1..10], b + c > a ] in triangles
23:04:11 <lambdabot>  [(4,3,2),(5,4,2),(6,5,2),(7,6,2),(8,7,2),(9,8,2),(10,9,2),(5,4,3),(6,4,3),(6...
23:04:15 <sujeet> jedai, oh you mean e.g. b <- [1..c]
23:04:24 <ThreeOfEight> I suggest triangles maxLen = [(a,b,c) | a <- [0..maxLen], b <- [a..maxLen], c <- [b..a+b]]
23:04:33 <lightquake> let a, b, c be integers >= 0. then a+b, a+c, b+c will be valid triangle side lengths
23:04:36 <sujeet> ThreeOfEight, best one
23:04:38 <ThreeOfEight> jedai: why c+1?
23:04:52 <ThreeOfEight> that way, you do not generated isosceles triangles
23:04:56 <ThreeOfEight> *generate
23:05:01 <jedai> ThreeOfEight: because I'm not really awake... no coffee yet
23:05:09 <sujeet> yes ThreeOfEight's soln is the obvious one
23:05:10 <ThreeOfEight> I almost made the same mistake though ;)
23:05:11 <sujeet> no predicates required
23:05:16 <bergmark> :r
23:05:22 <ThreeOfEight> yes, and the triangle equations trivially hold
23:05:23 <bergmark> this is not ghci!
23:05:30 <sujeet> *nod*
23:05:38 <ThreeOfEight> I also generate only one permutation of the sides
23:05:43 <jedai> obvious maybe not, but the best nonetheless
23:05:54 <ThreeOfEight> which will probably be preferable in most circumstances
23:07:04 <lightquake> so if a, b, c >= 0 then a+b, a+c, b+c are valid triangle side-lengths, and if you let x=a+b, y=a+c, z=b+c, then a=(x+y-z)/2 and similar for b and c
23:07:20 <lightquake> so you can nicely represent all valid triangles using triples of nonnegative reals
23:07:25 <lightquake> :)
23:07:40 <solatis> hmm, ok, so, I have a Text which *might* contain a year (that is, 4 consecutive numbers) in it -- what is the most performant way to get these numbers out of there? Just throw a regex at it?
23:07:48 <solatis> (i have grown to want to avoid regexes)
23:09:11 <lightquake> (exercise: construct a nice mapping from valid triangles (including degenerate ones) to triples of *arbitrary* reals)
23:10:42 <jedai> solatis: see decimal in Data?Text?Read
23:12:18 <jedai> lightquake: but didn't you give the solution just before ?
23:12:32 <lightquake> jedai: mine only works for triples of nonnegative reals
23:13:35 <jedai> lightquake: well the mapping is from valid triangles to triple of arbitrary reals so that would not be a problem. The inverse would be though...
23:13:49 <lightquake> well yeah, i meant bijection :P
23:13:58 <jle`> who says we were talking about triangles in euclidean space anyway
23:14:03 <solatis> jedai: i wasn't aware that Data.Text.Read could be used for pattern matching? For example, if my text is "(2014)", I want to get "2014", but when my text is "(11 November 2014)", I also want "2014"
23:14:06 <jedai> lightquake: ok, that is more interesting :)
23:14:13 <solatis> i don't think Data.Text.Read is suitable for that?
23:14:35 <jedai> solatis: Ah no, i=I didn't understand "contain" like that
23:14:36 <jle`> solatis: you might be able to use parsers
23:14:45 <lightquake> jle`: triangles in any metric space!
23:15:01 <solatis> jle`: yeah i was thinking about writing a very, very small mini-parser for this
23:15:19 <jle`> solatis: i mean, using parser combinator libraries
23:15:26 <solatis> but using regexes might be more convenient then after all
23:15:31 <jedai> seems to me like regex are really the simplest way....
23:15:54 <jle`> "replicateM 4 digit"
23:15:56 <solatis> yeah writing a custom parser for this seems overkill, when the regex is ([0-9][4])
23:16:09 <jle`> there's your parser
23:16:18 <jedai> jle`: no, there might be garbage before and or after
23:16:36 <jle`> ah
23:17:13 <jedai> not that you can't do it with a parser
23:17:33 <tolt> Does anyone have any good resources on replacing nodes of a tree efficiently?
23:17:35 <jedai> it just seems to me as a perfect exemple of regex application
23:17:51 <solatis> well i think this settles it -- unless the regex becomes a performance bottleneck, it seems like the most elegant way
23:18:01 <jedai> tolt: what do you mean ? is your tree immutable ?
23:18:05 <solatis>       let match = text =~~ "([0-9][4])" :: Maybe String
23:18:18 <solatis> that's pretty readable
23:19:11 <tolt> jedai: No. The idea is that I want to have some process that can force an event in the tree and then have the tree just redo a portion of the tree depending on what changes
23:19:22 <jedai> "(\d{4})"
23:19:55 <solatis> jedai: you win
23:20:05 <solatis> now where's that email validation regex
23:20:42 <solatis> oh wait
23:20:44 <solatis> i forget
23:20:48 <solatis> this is a regex
23:20:57 <solatis> of course it must be "(\\d{4})"
23:21:06 <jedai> right
23:21:11 <solatis> because jedai's solution was too readable
23:21:43 <jedai> that's the problem of using standard strings for regex (you have to escape the \
23:22:25 <jedai> I think there might be a quasiquoter for this floating around but I don't remember where and that might be overkill for just one regex...
23:26:20 <solatis> jedai: i'm afraid we're heading deep into the over-engineering cave here...
23:26:41 <merijn> solatis: Ooh! My favourite place!
23:26:56 <jedai> solatis: sure ! :) Just a remark on why Perl's regex are still the best around ;-)
23:27:24 <solatis> hehe
23:29:30 <solatis> i'm using regex-tdfa, which uses posix regexes tho
23:29:48 <solatis> but i do think that haskell does a great job making the code (almost) as elegant as perl
23:30:05 <wei2912> perl is more elegant than haskell? :P
23:30:23 <solatis> well
23:30:39 <solatis> you can't beat perl's integration with regexes
23:32:07 <wei2912> true
23:32:18 <tolt> Does anyone know if there's a way to watch something like a tvar?
23:32:23 <tolt> watch for modification
23:35:35 <merijn> tolt: What sort of modification?
23:36:16 <tolt> merijn: like onChange :: TVar a -> IO () -> IO ()
23:36:35 <tolt> that would monitor a tvar for a change and run a function when it changes
23:36:36 <merijn> tolt: You could use two TVar and use one to signal change
23:37:31 <tolt> Yeah. That's what I was kind of thinking.
23:37:58 <merijn> tolt: Alternatively, if you're ok with an Eq constraint on 'a'
23:39:13 <merijn> "onChange tvar action = do { oldVal <- readTVarIO tvar; atomically $ readTVar tvar >>= check . (/=oldVal); action }"
23:42:31 <guest_123> Is there a way to execute a list of non-interacting ST actions concurrently, like parList, but for ST?
23:45:12 <solatis> hmm
23:45:15 <solatis> http://hackage.haskell.org/package/text-icu-0.7.0.0/docs/Data-Text-ICU-Regex.html
23:45:24 <solatis> "Note: The functions in this module are not thread safe. For thread safe use, see clone below, or use the pure functions in Data.Text.ICU."
23:45:44 <solatis> that makes for a pretty bad regex library
23:46:09 <solatis> i assume they probably mean "it's not safe to share compiled Regex patterns between threads" ?
23:48:03 <mrenaud> Hey, State monad question. If I have two data types, say A and B, is there an idiomatic way of putting them both in the state monad?
23:48:41 <mrenaud> My original thought is State (A,B), but that makes accessing them annoying and you're tied to this decision
23:48:45 <johnw>  State (A, B)
23:48:55 <solatis> that was also my first thought
23:48:57 <johnw> if you use the lens library to access them, it's not annoying
23:49:30 <mrenaud> For example? And if I wanted to add another type C, how much would need to be changed in the code that uses this monad?
23:50:26 <edwardk> mrenaud: my usual approach is to let lens derive HasA, HasB, HasC classes for A, B and C
23:50:49 <edwardk> then work with (MonadState s m, HasA s, HasB s) => m a
23:50:54 <mrenaud> I'm not familiar with lens
23:50:59 <mrenaud> I'll look into that
23:51:03 <Tehnix> Does anyone know if there ever was found a fix for ´hSetBuffering stdin NoBuffering` not working in Windows CMD?
23:51:07 <edwardk> when I need to add C to my state I work with (MonadState s m, HasA s, HasB s, HasC s) => ...
23:51:15 <edwardk> and just the parts of the code that need to care about C get affected
23:51:31 <edwardk> in the end at the top level i have to make some data type with the parts i'm using but that change is localized
23:51:40 <DTSCode> what exactly is hackage?
23:51:49 <edwardk> DTSCode: CPAN for haskell
23:51:53 <mrenaud> Is there a way to combine (MonadState s m, HasA s, HasB s, HasC s) into one constraint? Like (MyMonadState s m)?
23:52:11 <DTSCode> is CPAN the perl package manager?
23:52:27 <solatis> hackage is not a package manager, it's a package repository
23:52:31 <edwardk> mrenaud sure, type MyMonadState s m = (MonadState s m, HasA s, HasB s, HasC s)  -- if you have LANGUAGE ConstraintKinds turned on
23:52:44 <DTSCode> like boost then?
23:52:52 <solatis> nah
23:52:52 <edwardk> otherwise you need to use
23:52:54 <edwardk>  class (MonadState s m, HasA s, HasB s, HasC s)  => MyMonadState s m
23:52:59 <edwardk> instance (MonadState s m, HasA s, HasB s, HasC s)  => MyMonadState s m
23:53:07 <edwardk> er probably with a fundep
23:53:09 <mrenaud> edwardk: Thanks, is ConstraintKinds considered "safe"?
23:53:11 <edwardk>  class (MonadState s m, HasA s, HasB s, HasC s)  => MyMonadState s m | m -> s
23:53:13 <edwardk> yes
23:53:22 <edwardk> ConstraintKinds don't let you do anything hinky
23:53:33 <solatis> haskell has package hosting (hackage) and package management (cabal? nix?) decoupled
23:53:35 <mrenaud> Gotcha
23:53:45 <DTSCode> ah
23:53:51 <edwardk> the alternative version requires you to turn on UndecidableInstances and all sorts of other scary sounding stuff, but uses them safely
23:54:14 <mrenaud> I think I'll stick with the ConstraintKinds extension :P
23:54:57 <edwardk> well the benefit of the second version is a.) it works on older GHCs, b.) it doesn't require your _users_ to turn on an extension, c.) it can be partially applied which can matter in some circumstances
23:55:06 <edwardk> the benefit of the constraint kinds version is it is less scary
23:55:29 <edwardk> i mention both for completeness
23:55:29 <merijn> The downside of ConstraintKinds is that it requires all users to turn it on
23:55:34 <edwardk> yep
23:55:46 <merijn> Unless you do my hacky "class that has a ConstraintKind constraint" thing
23:56:02 <edwardk> merijn: which thing?
23:56:19 <mrenaud> Is it that big of an issue to require users to turn on an extension?
23:56:36 <merijn> edwardk: Well, it's literately just defining an empty class with my ConstraintKind as class constraint and then an identical instance
23:56:41 <edwardk> mrenaud: its more that its an annoying cost paid by all users where the other is an annoying cost paid once by you the library author
23:56:57 <merijn> mrenaud: If you import it into 10 modules and need to enable it in all 10 it becomes annoying
23:57:15 <nshepperd> another option is to use ST and STRefs instead of State
23:57:19 <edwardk> class p => Id p; instance p => Id p -- ?
23:57:28 <merijn> edwardk: Like this: http://lpaste.net/114150
23:57:42 <nshepperd> which would let you create a ST s C cell on the fly
23:58:01 <nshepperd> er, STRef s C
23:58:02 <edwardk> oh its a bit different than i was expecting
23:58:24 <edwardk> i thought you were going for class f a => Foo f a; instance f a => Foo f a
23:58:53 <merijn> edwardk: I didn't bother trying to generalise beyond this
23:59:14 <merijn> I only have a like 5 ConstraintKinds I use, so I just define one for each
23:59:22 <merijn> Works just fine, though :)
