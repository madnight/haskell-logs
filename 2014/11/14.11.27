00:05:32 * hackagebot lhs2html 0.99999 - Compile lhs in bird style to md, html, hs.  http://hackage.haskell.org/package/lhs2html-0.99999 (JulianFleischer)
00:08:54 * hackagebot hspec 2.1.0 - A Testing Framework for Haskell  http://hackage.haskell.org/package/hspec-2.1.0 (SoenkeHahn)
00:08:54 * hackagebot lhs2html 0.99999 - Compile lhs in bird style to md, html, hs.  http://hackage.haskell.org/package/lhs2html-0.99999 (JulianFleischer)
00:43:42 <gfixler> I misheard something months ago, and thought Data.Map wasn't all that efficient
00:43:53 <gfixler> #haskell set me straight - it was some particular use case that isn't
00:44:03 <gfixler> I thought maps were rarely used, but #haskell told me they're often used
00:44:21 <gfixler> and now I see Edward Kmett in a talk from 2 months ago mentioning how Data.Map is like a performance benchmark
00:44:26 <gfixler> very tuned
00:44:30 <Cale> yes
00:44:38 <gfixler> it's like I misheard it the most possible
00:44:41 <Cale> It's so well tuned that it's frustrating to try to beat it
00:44:55 <gfixler> Cale, I think you were the one I misheard :)
00:45:01 <Cale> haha
00:45:30 <gfixler> https://www.youtube.com/watch?v=6nh6LpcXGsI
00:45:36 <gfixler> this is the talk I'm watching ^^
00:48:17 <Cale> gfixler: I might've mentioned that whether unordered-containers or containers is faster is a bit of a toss-up.
00:49:34 <gfixler> Cale: http://ircbrowse.net/browse/haskell?id=18633226&timestamp=1405997735
00:50:20 <gfixler> http://ircbrowse.net/browse/haskell?id=18633249&timestamp=1405997831#t1405997831
00:50:33 <gfixler> I think I took that sentence way out of context
01:01:13 <ddellacosta> is it possible to write dropWhile using foldr?  Seems like the answer is no, but I feel like maybe I'm missing something
01:02:32 <ddellacosta> nevermind, found this: https://www.haskell.org/wikiupload/1/14/TMR-Issue6.pdf
01:09:59 <gfixler> ddellacosta: I like the solution on page 7: const dropWhile foldr
01:11:08 <ddellacosta> gfixler: ha, I didn't even dig into it yet, because I saw the reference to the earlier Graham Hutton paper (http://www.cs.nott.ac.uk/~gmh/fold.pdf) and starting digging into that.
01:11:24 <ddellacosta> gfixler: that's pretty sneaky though
01:11:24 <gfixler> this is good timing - been looking into folds more in depth lately
01:11:57 <ddellacosta> yeah, there's a lot more there than I realized at first (as always seems to be the case the deeper I get into Haskell...)
01:12:27 <gfixler> I was just complaining in here yesterday that #haskell keeps pulling the rug out from under my feet
01:12:44 <ddellacosta> haha
01:13:00 <gfixler> like last night, when everyone told me that getLine isn't a function
01:13:09 <wei2912> wait, what
01:13:16 <ddellacosta> gfixler: btw, dunno if you already know about it or figured it out from the second link I pasted, but Graham Hutton has a *ton* of fold-related papers it seems: www.cs.nott.ac.uk/~gmh/bib.html
01:13:20 <wei2912> :t getLine
01:13:21 <lambdabot> IO String
01:13:24 <wei2912> dang
01:13:31 <wei2912> then again, it makes sense
01:13:45 <gfixler> and all functions - even getLine - are pure
01:13:54 <gfixler> because it's the *runtime* that's actually being impure, not Haskell
01:14:10 <gfixler> getLine doesn't get anything - it creates code that can
01:14:48 <ddellacosta> gfixler: creates code = compiler creates code when it sees that (roughly speaking)?
01:15:02 <gfixler> ddellacosta: I don't really know - I'm still reeling
01:15:13 <gfixler> something about getLine is fully beta-reduced already
01:15:16 <ddellacosta> yeah, I'm trying to wrap my head around that, kind of mindboggling
01:15:50 <lpaste> wei2912 pasted “site.hs” at http://lpaste.net/115179
01:16:07 <gfixler> lpaste is such a tattle-tale
01:16:22 <wei2912> i got https://travis-ci.org/wei2912/blog_src/builds/42284855 when i tried to compile src/site.hs
01:17:48 <wei2912> hmm
01:18:56 <wei2912> any ideas about this problem?
01:19:13 <wei2912> seems to be something to do with OverloadedStrings, unfortunately i don't know much about it, since i just took the code from Hakyll
01:31:24 <Welkin> how can I use Aeson to get proper JSON that I can write to an external file?
01:31:38 <Welkin> it seems to escape the text
01:31:45 <Welkin> when using `encode`
01:31:55 <tdammers> it produces valid JSON, what exactly do you want?
01:32:28 <Welkin> all of the quotation marks are escaped
01:32:37 <tdammers> example?
01:32:55 <tdammers> are you maybe using show on the bytestring it outputs?
01:33:04 <tdammers> (or print, same thing)
01:33:08 <Welkin> ah
01:33:12 <Welkin> yes, print must be the problem
01:33:20 <Welkin> so I'll have to open a file handle for output
01:33:38 <tdammers> well, you could just use putStr instead of print
01:33:51 * hackagebot snap-error-collector 1.1.0 - Collect errors in batches and dispatch them  http://hackage.haskell.org/package/snap-error-collector-1.1.0 (OliverCharles)
01:33:58 <tdammers> but it has to be the putStr from ByteString, because that's what encode gives you
01:34:22 <tdammers> plain print (for String I/O) typechecks, but it doesn't do what you want
01:34:36 <tdammers> it uses the show instance for ByteString to make a String, and then prints that
01:34:43 <tdammers> > print "Hello!"
01:34:44 <lambdabot>  <IO ()>
01:34:51 <tdammers> oh f* me
01:34:55 <tdammers> :D
01:35:00 <Welkin> heh
01:35:14 <Welkin> I see
01:35:36 <Welkin> the differences between ByteString/String/Text always cause me trouble
01:35:49 <tdammers> it's pretty simple, really
01:35:51 <Welkin> with all of their functions having similar names
01:36:02 <Welkin> I just need to remember which I am using
01:36:27 <tdammers> String: linked list of characters; Text: "array" of characters; ByteString: "array" of bytes
01:36:33 <Welkin> perfect
01:36:34 <tdammers> ByteStrings aren't strings at all
01:36:39 <Welkin> it works beautifully now
01:36:41 <tdammers> the name is a bit unfortunate
01:36:51 <tdammers> ok then, cheers
01:37:17 <Welkin> Text is really an array of characters?
01:37:44 <tdammers> internally, pretty much, yes
01:37:50 <tdammers> or rather, conceptually it is
01:37:58 <tdammers> internally it uses something like utf-16 IIRC
01:38:27 <tdammers> but it doesn't expose this implementation detail; it could be implemented as an array of 32-bit characters without changing its interface
01:38:48 <Welkin> the way I understand Text is that it is an efficient version of String
01:38:56 <tdammers> sort of, yes, but not quite
01:39:02 <Welkin> and then ByteString is for binary blobs
01:39:34 <tdammers> String is really just an alias for [Char], which means that anything that works on a list also works on a String - because Strings *are* lists
01:39:42 <tdammers> and yes, ByteString is for binary data
01:40:08 <tdammers> there is no type alias for the byte equivalent of String, which would be [Word8] or some such
01:40:54 <tdammers> but other than that, we're talking two orthogonal concerns: the type of your element (Char vs. Word8 a.k.a. "byte"), and the structure of your container (linked list vs. tightly-packed array)
01:42:07 <tdammers> oh, and Text is usually more efficient that String, but there are a few cases where String is (theoretically) superior, and even a few things that String can do but Text can't, at leasts not as easily
01:42:21 <tdammers> take 10 . repeat $ 'a'>
01:42:29 <tdammers> > take 10 . repeat $ 'a'
01:42:30 <lambdabot>  "aaaaaaaaaa"
01:42:39 <tdammers> Text can't easily do that
01:44:42 <Fuuzetsu> :t T.take
01:44:43 <Welkin> I see, yes
01:44:43 <lambdabot>     Not in scope: ‘T.take’
01:44:43 <lambdabot>     Perhaps you meant ‘BS.take’ (imported from Data.ByteString)
01:44:52 <Fuuzetsu> it *can*
01:44:52 <Welkin> because of the nature of lists
01:45:11 <Fuuzetsu> well, you can't do repeat I guess
01:45:26 <Fuuzetsu> you'd' just replicate 10
01:48:52 * hackagebot reflection-without-remorse 0.9.3 - Efficient free and operational monads.  http://hackage.haskell.org/package/reflection-without-remorse-0.9.3 (AtzeVanDerPloeg)
01:58:52 * hackagebot safe-access 0.2.1.0 - A simple environment to control access to data  http://hackage.haskell.org/package/safe-access-0.2.1.0 (thoferon)
02:26:28 <makalu> is there a library for sequences that have fast indexing and consing (like VLists)? Vector has fast indexing but O(n) cons
02:28:29 <Ralith> makalu: Data.Sequence
02:29:50 <makalu> nice. It even uses the cool finger trees thing. Thanks.
03:20:13 <Zol_> -buffer 3482
03:23:56 * hackagebot populate-setup-exe-cache 1.0 - Empty Cabal package  http://hackage.haskell.org/package/populate-setup-exe-cache-1.0 (mietek)
03:24:09 <mietek> woop
03:25:46 <Znerol> Lots of guys in here !
03:26:07 <Znerol> ...and Girls
03:28:17 <bitonic> is it possible to specialize entire packages?  I'd like to be able to say "whenever you encounter constraint `C a', specialize for a = this, that, ...'
03:33:09 <bananu7> :bitonic isn't that FlexibleContexts?
03:33:33 <bitonic> bananu7: no, I want to automatically apply the SPECIALIZE pragma to functions
03:33:56 * hackagebot extensible-effects 1.7.2.1 - An Alternative to Monad Transformers  http://hackage.haskell.org/package/extensible-effects-1.7.2.1 (shergill)
03:53:57 * hackagebot compdata 0.8 - Compositional Data Types  http://hackage.haskell.org/package/compdata-0.8 (PatrickBahr)
03:53:59 * hackagebot freetype-simple 0.1.0.1 - Single line text rendering for OpenGL ES  http://hackage.haskell.org/package/freetype-simple-0.1.0.1 (capsjac)
04:03:57 * hackagebot opengles 0.7.0 - OpenGL ES 2.0 and 3.0 with EGL 1.4  http://hackage.haskell.org/package/opengles-0.7.0 (capsjac)
04:22:05 <droidboi> > let x = 2
04:22:06 <lambdabot>  not an expression: ‘let x = 2’
04:22:22 <droidboi> > let x = 2 in x
04:22:24 <lambdabot>  2
04:22:35 <droidboi> > let x = x in x
04:22:39 <lambdabot>  mueval-core: Time limit exceeded
04:24:09 <indigo945> poor bot :(
04:25:36 <bananu7> lol
04:27:04 <Iceland_jack> :t let x = x in x :: Zen
04:27:05 <lambdabot> Zen
04:27:38 <sivteck> ;o
04:28:58 * hackagebot uberlast 0.0 - Generate overloaded lenses from plain data declaration  http://hackage.haskell.org/package/uberlast-0.0 (FumiakiKinoshita)
04:50:26 <darkf> how do I hoist a StateT m a into a WriterT b (StateT m) a?
04:51:22 <darkf> well, StateT s m
04:51:36 <darkf> or more generally, how do I hoist a monad transformer into another monad transformer? :)
04:51:54 <darkf> not sure if 'hoist' is the right verb here, maybe 'lift'
04:52:54 <darkf> ah, actually lift is exactly what I wanted... I swear I tried it before; nevermind. I feel silly.
04:53:38 <bitonic> darkf: host is usually used when you turn non-transformer things into transformer things, e.g. `Maybe a -> MaybeT a'
04:54:43 <darkf> yeah, and lifting from a base monad [transformer] into a higher one. I should probably actually implement a monad transformer to see how they are done.
04:54:48 <SwashBuckla> :t lift
04:54:49 <lambdabot> (MonadTrans t, Monad m) => m a -> t m a
04:54:54 <bitonic> darkf: you should
04:54:59 <SwashBuckla> :t fmap
04:55:00 <lambdabot> Functor f => (a -> b) -> f a -> f b
04:55:05 <SwashBuckla> :t liftM
04:55:06 <lambdabot> Monad m => (a1 -> r) -> m a1 -> m r
05:05:26 <aloiscochard> hey I'm looking for the following sementic:
05:05:27 <aloiscochard> foo a b f = if ((isJust a) || (isJust b)) then Just (f a b) else Nothing
05:05:39 <aloiscochard> while ideally abstraction on the arity as well
05:05:53 <aloiscochard> I was recommende to use cobind, but that fail fast... what am I missing?
05:07:40 <tdammers> so f takes Maybe's itself?
05:08:27 <t4nk655> Hey guys, I'm installing a package using a cabal sandbox, and during the build, I get this error:     Data.DList: Can't be safely imported! The module itself isn't safe. after which everthing fails.
05:08:38 <t4nk655> Is that referring to this? https://downloads.haskell.org/~ghc/7.4.2/docs/html/users_guide/safe-haskell.html
05:09:17 <t4nk655> To clarify, the error is "Data.DList: Can't be safely imported! The module itself isn't safe."
05:09:53 <mauketwork> yes
05:11:06 <t4nk655> Hmm, okay, any ideas? This is the package I'm looking at. https://hackage.haskell.org/package/copilot
05:11:49 <t4nk655> (Data.DList is an dependency)
05:14:28 <aloiscochard> tdammers: that's right!
05:16:23 <Zol__> I am confused! A function that takes a function with multiple arguments can have the type (a -> b), (.) is an example of a function which takes a function with arbitrary length of arguments, but if I make a function like f x y z = x y z, the type will be ( a -> b -> c) -> a -> b -> c, why not just (a -> b) -> a -> b ?
05:17:38 <alpounet> Zol__: because it wouldn't account for the third argument
05:18:28 <alpounet> you can view it as (a -> b) -> a -> b, except that 'b' has a particular shape: it must itself be a function type. hence 'b' becoming 'b -> c'
05:19:27 <Zol__> alpounet: Ok, so from a very high view, any function that takes an input could be said to have the type a -> b, if it isn't more specific than that?
05:20:27 <droidboi> why can't people who understand monads explain monads
05:20:33 <alpounet> Zol__: a function necessarily looks like (a -> b), for some types a and b
05:21:04 <mauketwork> droidboi: because there's nothing to it
05:21:37 <alpounet> Zol__: it really all boils down to this. If something is constrained to be a function, it _necessarily_ has a type like this. If that function takes several arguments, then the 'b' will itself be a function type
05:21:37 <droidboi> mauketwork: hahaha
05:22:30 <t4nk655> Is there anything that can be done to get around unclean package dependencies?
05:22:47 <t4nk655> ^^ Unsafe dependencies
05:23:02 <Zol__> alpounet: Right, because of partially applied functions?
05:23:04 <droidboi> mauketwork: no seriously
05:23:55 <mauketwork> I think that's the real problem
05:24:02 <mauketwork> people expect some kind of big explanation
05:24:10 <mauketwork> or revelation
05:24:20 <mauketwork> but monads are too simple
05:24:23 <t4nk655> join #archlinux
05:24:33 <t4nk655> Ahh, whoops :P
05:25:10 <droidboi> for a start, the word itself, for almost every living human is meaningless
05:25:17 <alpounet> Zol__: Looking at f x y z = x y z, what we can see is that: 1/ f must be a function that can accept 3 arguments, hence f :: a -> b -> c -> d. we also see that the first argument needs to be able to take 2 arguments, so 'a' must actually be (b -> c -> d). replacing 'a' by that in the type we gave to f gives f :: (b -> c -> d) -> b -> c -> d.
05:25:32 <alpounet> err, forgot to type 2/ and 3/ in there =)
05:25:34 <mauketwork> droidboi: that's a good thing
05:26:28 <Zol__> alpounet: Aaah!
05:26:37 <mauketwork> if we called it "rodent typewriter", people would make weird assumptions about it
05:26:45 <alpounet> Zol__: the definition of f doesn't force any other unification in the types, so here's the final type you get :)
05:27:10 <Zol__> alpounet: Aha, I thought that unification was the term used for determining the types
05:27:41 <dredozubov> http://lpaste.net/115187 i've seen this errors and still i can't get a sense of them again. Can someone have a look?
05:27:56 <droidboi> mauketwork: if it were, but it isn't
05:28:23 <alpounet> Zol__: unification is at the heart of type checkers yes, that's basically about seeing what types every bit of the definitions imply, and then trying to make them all work together
05:28:52 <mauketwork> dredozubov: looks like you're using a lazy bytestring where a strict bytestring is expected
05:29:22 <Zol__> alpounet: Ok, thanks! I will give another stab at this.
05:30:26 <alpounet> Zol__: yeah, just toy around with some random functions like your f from above, trying to guess the types and then verifying your guess against ghci with :t
05:30:33 <droidboi> mauketwork but my question was "why can't people who understand monads explain monads". Is there an answer?
05:31:01 <mauketwork> droidboi: I think your question is wrong
05:31:30 <droidboi> Saying "its so simple" is not an answer
05:31:50 <mauketwork> I disagree
05:31:55 <droidboi> maybe to you
05:32:05 <alpounet> droidboi: putting aside the original (mathematical) definition, from a haskell perspective it's a class of types that implement 'return' and '(>>=)' such that the monad laws hold. that's what monads _are_
05:32:39 <indigo945> but that's a little like saying that a car is a box with engines, and gears, and wheels
05:32:43 <alpounet> explaining how widely they apply to concrete problems and what concrete monads may look like is another thing
05:32:47 <indigo945> technically it's true, but knowing that you still couldn't drive one
05:32:56 <indiagreen> indigo945++
05:33:11 <exio4> no, it is like saying a vehicle is a thing that lets you move between places, monads are abstract
05:33:22 <mauketwork> monad is more abstract than car. maybe "vehicle"
05:33:30 <dredozubov> mauketwork: it is working, if i remove the concat part(line 24). Isn't OverloadedStrings supposed to infer right ByteString type?
05:33:34 <alpounet> they represent a common concept
05:33:46 <mauketwork> but no matter how many vehicle tutorials you read, you still won't know how to drive a car
05:34:02 <mauketwork> dredozubov: you imported the wrong concat, it seems
05:34:04 <alpounet> the laws tell us something about how _any_ monad behaves
05:34:13 <mauketwork> dredozubov: try import Data.ByteString.Lazy (concat)
05:34:36 <alpounet> but any concrete monads will have some specifics
05:34:37 <dredozubov> mauketwork: oh, you're right
05:34:46 <alpounet> and you can't just paint a concrete picture of monads in general
05:34:46 <dredozubov> i've stuck for 10 minutes :(
05:34:52 <dredozubov> i've been stuck*
05:35:00 <dredozubov> mauketwork: thanks
05:35:05 <mauketwork> no problem
05:35:07 <chrisdone> i think it's easy to explain monads
05:35:15 <chrisdone> it's just very hard to convince the audience that the explanation is complete
05:35:20 <chrisdone> due to the reputation
05:35:27 <alpounet> yeah, exactly
05:36:06 <alpounet> although I consider http://blog.sigfpe.com/2006/08/you-could-have-invented-monads-and.html to be a decent article to read, unlike hundreds of others
05:37:06 <indigo945> i guess it's also due to an expectation on what "explain" means. i agree that they are abstract, like vehicles - that's a good analogy - but people still expect to get an explanation that instructs them to drive them
05:37:21 <indigo945> because without knowing what monads are, you might think that they're really more like cars and not like vehicles
05:37:25 <indigo945> maybe that's the problem
05:37:44 <chrisdone> as someone who just entered the discussion, i've no idea what this vehicles stuff is about but i don't expect it's too useful
05:38:08 <wei2912> lol
05:38:12 <chrisdone> if you explain the Num class you just say what the types should be and some laws
05:38:16 <mauketwork> vehicles is a greek hero
05:38:26 <chrisdone> you don't have to say "it's kind of like painting a floor" or some odd analogy
05:38:35 <alpounet> indigo945: the problem is that if you focus too much on precise monads, say IO, then you'll be explaining how to use IO, not what monads are about
05:39:02 <indiagreen> another problem is that giving people the laws doesn't give them the intuition
05:39:04 <dredozubov> indigo945: i don't really like car-vehicle analogy, it implies subtyping
05:39:18 <chrisdone> alpounet: the 'are about' thing has a negative effect, i think
05:39:31 <indiagreen> so they wouldn't be able to see that IO and other problems can be solved with monads, even if they know about the concept
05:39:37 <chrisdone> what are numbers about? or applicatives?
05:39:44 <chrisdone> why do they have to be "about" something?
05:39:44 <indigo945> alpounet: i agree, but what i'm saying is that you have clashing expectations here
05:40:00 <indigo945> alpounet: as somebody who understands monads, you know there isn't much to understand
05:40:15 <BoR0> monads, just like monoids, are an algebraic structure that depend on some laws. it's like an API, and when you do :t to find out that something implements a Monad, and you see its type signature then it's like you've read 80% of the API reference manual
05:40:16 <alpounet> indiagreen: actually Dan Piponi has some "pictures" that illustrate the monad laws, very nice.
05:40:21 <indigo945> alpounet: but when you're learning them, you don't know that, so you would really want to understand IO, not monads
05:40:24 <chrisdone> ime understanding haskell monads is just understanding type-classes properly
05:40:27 <alpounet> it's burried in a talk that may be a bit harsh for beginners though
05:40:47 <sivteck> asking specific questions after trying to understand them helps ;/
05:40:47 <indigo945> alpounet: so when somebody explains monads to you, you might be left dumbfounded and think that you just been given the wrong explanation
05:40:55 <chrisdone> many newbies try to understand what this abstraction is without understanding enough of the type system
05:42:47 <alpounet> indigo945: yeah. on the other hand, you don't need to understand monads to use IO. i think the decent haskell books we have don't try to explain monads before IO. it's just that for some reason there's all this fuss about monads on the internet
05:42:59 <alpounet> so everyone imagines they are a huge thing to understand
05:43:49 <chrisdone> it's hard to avoid the Monad class when writing IO in compile errors
05:43:56 <clrnd> a great mind opener for me was when I was told do notation is only sugar
05:43:59 <chrisdone> and all your looping constructs and such
05:44:01 * hackagebot acme-strtok 0.1.0.2 - A Haskell port of the C/PHP strtok function  http://hackage.haskell.org/package/acme-strtok-0.1.0.2 (eberlm)
05:45:30 <alpounet> chrisdone: right, but the text can pretend they're IO speific and then expose the lie a bit later =)
05:45:35 <clrnd> I wish haskell tutorial didn't use do-notation
05:46:33 <droidboi> I'm only saying that for something so simple (like >>= and return), why has such simplicity caused so much confusion and perception of complexity
05:47:05 <chrisdone> droidboi: because of people saying stuff like you're saying now
05:47:21 <droidboi> :)
05:47:25 <chrisdone> actually a hundred people will be learning haskell right now with a book and not complaining about it at all
05:47:31 <droidboi> I don't think so
05:47:34 <clrnd> the word 'return' is kind of diabolic too
05:47:44 <chrisdone> droidboi: based on what experience?
05:48:30 <alpounet> droidboi: do you feel the Show or Functor typeclasses cause as many problems as Monad?
05:49:12 <droidboi> for example, show does not show
05:49:42 <alpounet> hm?
05:50:02 <droidboi> another horrible use of English to call a function that "does not show"
05:50:03 <chrisdone> arrows and applicatives are more WTF'y than monads are
05:50:15 <chrisdone> but you don't need arrows or applicatives to do somethnig basic like IO
05:50:25 <chrisdone> so you can go without them for a long time while you learn the language
05:50:37 <exio4> monads are simple, they just have too much evil marketing
05:50:42 <bitonic> how much time have we spent discussing about the alleged confusion that monads cause :P?
05:51:02 <droidboi> hopefully lots
05:51:08 <bitonic> too much
05:51:48 <mauketwork> I wish to file a complaint: print() doesn't print in any language
05:51:59 <BoR0> mauketwork, that's exactly what I was thinking :D
05:52:12 <clrnd> :P
05:52:28 <BoR0> or exit() doesn't close the door.
05:53:06 <droidboi> functions that don't do what they say - like show - is stupid
05:53:21 <BoR0> droidboi, it's relative. what do *you* want/expect show to be doing?
05:53:22 <bitonic> droidboi: what should `show' do?
05:53:24 <mauketwork> besides, shouldn't it be exi()?
05:53:38 <ion> unsafeShow
05:53:40 <clrnd> droidboi, are you against all languages in the history of human kind then?
05:53:43 <droidboi> "show" should show
05:53:45 <mauketwork> and why is exit not the opposite of init
05:53:48 <clrnd> i always disliked `yield`
05:53:50 <bitonic> droidboi: what does show mean?
05:53:53 <mauketwork> droidboi: what
05:54:00 <sivteck> > show cat
05:54:01 <lambdabot>  No instance for (Data.Typeable.Internal.Typeable
05:54:02 <lambdabot>                     Text.PrettyPrint.HughesPJ.Doc)
05:54:02 <lambdabot>    arising from a use of ‘GHC.Show.show’
05:54:04 <sivteck> ;o
05:54:16 <indigo945> mauketwork: print prints in Matlab
05:54:18 * chrisdone bows out of this discussion
05:54:31 <droidboi> show creates a string - no more
05:54:35 <mauketwork> :ha
05:54:46 <bitonic> droidboi: that's what `show' does in Haskell
05:54:48 <bitonic> :t show
05:54:49 <lambdabot> Show a => a -> String
05:54:49 <droidboi> call it createString
05:55:09 <mauketwork> droidboi: why?
05:55:10 <indiagreen> it's too long to type and compromises have to be made
05:55:28 <indiagreen> also, yeah, it's called “toString” or “stringify” or something in other languages, I think
05:55:39 <droidboi> mauketwork because it doesn't show me it
05:55:41 <bitonic> droidboi: I think `show' is concise informative.  but this is terminology.  criticising Haskell on that ground seems silly
05:55:44 <mauketwork> droidboi: yes, it does
05:56:00 <BoR0> I agree with bitonic. the same argument can be made for any language in the world
05:56:04 <capisce> also consider the name of the dual, 'read'
05:56:10 <davidstone> "Everyone else did it wrong, too!"
05:56:15 <capisce> maybe it should be called "write"?
05:56:24 <hpc> what's it writing to?
05:56:26 <davidstone> Just because other people got it wrong doesn't mean it's any less wrong here
05:56:28 <droidboi> mauketwork It cannot
05:56:32 <mauketwork> droidboi: yes, it does
05:56:35 <lieven> Common Lisp looks good in comparison. At least noone has any notion what SUBLIS, LDIFF, TERPRI or similar should do. Languages should have meaningless strings as standard library identifiers
05:56:58 <davidstone> lieven: How about cons and cars
05:56:59 <mauketwork> lieven: I'll RPLACD your face
05:57:02 <capisce> hpc: to a string, like read reads from a string
05:57:09 <ion> CADDADADAR
05:57:20 <hpc> lieven: let's rename read and show to "gloobldorp" and "breepledorp"
05:57:20 <BoR0> davidstone, who's got what wrong? naming stuff is relative.
05:57:25 <hpc> :D
05:57:32 <alpounet> > let yazeyazye = show in yazeyazye [1..5] -- droidboi there you go, no a priori with that name right?
05:57:34 <lambdabot>  "[1,2,3,4,5]"
05:58:03 <lieven> hpc: looks workable to me :)
05:58:14 <davidstone> BoR0: <BoR0> I agree with bitonic. the same argument can be made for any language in the world <clrnd> droidboi, are you against all languages in the history of human kind then?
05:58:36 <davidstone> The argument you are both making is, "Well, you can criticize names in Haskell, but other languages aren't perfect either"
05:58:49 <davidstone> That may be true, but it's irrelevant information as to whether he has grounds to criticize the names in Haskell
05:59:15 <droidboi> alpounet everyone knows show isn't doing the printing
05:59:15 <bitonic> davidstone: no, my argument is that `show' is a good name, but even if you don't like it criticising is a pretty superficial way to criticise a language
05:59:19 <mauketwork> davidstone: my main problem is that he can't explain what's wrong with 'show'
05:59:37 <mauketwork> so we're talking in circles
05:59:42 <davidstone> I feel like I understand what he's explaining
05:59:43 <lieven> the argument is that once names are chosen, they have inertia and can't be changed easily
05:59:46 <bitonic> davidstone: if `show' was a clearly bad name, I'd agree with him
05:59:57 <droidboi> or am I wrong?
06:00:04 <davidstone> He's saying that show is converting something to a format that it can be displayed in, rather than doing the displaying
06:00:04 <lieven> like unix creat and other weird system calls
06:00:11 <mauketwork> droidboi: you're not even wrong
06:00:15 <alpounet> to be honest, 99.999% of people just learn the name and move on to funnier things
06:00:34 <droidboi> mauketwork Nice one
06:00:57 <mauketwork> davidstone: that's your interpretation, but so far I see no explanation of what he thinks "show" should mean/do
06:00:59 <droidboi> using an old cliche
06:01:21 <BoR0> davidstone, what I said before, is that naming stuff is relative i.e. it depends on one's own experience. printf and scanf might be familiar for me, but this doesn't imply so for any other programmer and doesn't necesarrily make printf and scanf bad names. the argument that followed is that this is used in any other language. can you think of a word that will make sense to the whole world?
06:02:27 <indigo945> if read is called read, show should be called write
06:03:06 <mauketwork> yeah, but read should not be called read :-)
06:03:18 <droidboi> show should be called toString
06:03:23 <droidboi> like Scala
06:03:29 <mauketwork> droidboi: this isn't Java
06:03:38 <davidstone> That's what C++ does, too
06:03:40 <davidstone> std::to_string
06:03:40 <droidboi> I know
06:03:43 <wei2912> lol
06:03:48 <davidstone> I think that name makes sense
06:03:53 <wei2912> show also makes sense
06:04:02 <mauketwork> davidstone: it's less declarative
06:04:03 <alpounet> guys this discussion is going nowhere, let's just make room for actual questions
06:04:09 <mauketwork> hmm
06:04:16 <mauketwork> I guess I could say the same about show
06:04:17 <indigo945> so read would be called fromString, which makes fromIntegral that much more intuitive
06:04:21 <mauketwork> objection retracted
06:04:25 <bitonic> droidboi: I actually like `toString', but `show' is allright.  in any case, what's your point?  are you saying that `show' prevents people from learning Haskell easily?
06:04:35 <clrnd> why isn't it called "imprimir" ? why does it have to be in english?
06:04:45 <droidboi> everybody - mauketwork says "Haskell isn't Java"
06:04:59 <wei2912> yeh it isn't
06:05:05 <wei2912> not news to me
06:05:11 <droidboi> nothing new there
06:05:25 <bitonic> droidboi: actually, I think I agree with you on `toString' -- it's better than `show'.  the thing is that it really doesn't matter
06:05:49 <clrnd> this reminds me of the class IsString
06:06:00 <mauketwork> ah, now I see
06:06:10 <droidboi> bitonic: I agree with you too
06:06:19 <mauketwork> I don't think show should be called toString, but toString is a better name
06:06:42 <droidboi> bitonic: and I agree with me
06:07:47 <bitonic> great.  everybody wins.  now we can move on!
06:08:23 <mauketwork> I disagree with myself from 5 minutes before
06:09:27 <davidstone> Heh
06:09:38 <davidstone> A new message just arrived in a conversation in gmail. My options? Show, ignore
06:09:45 <davidstone> I chose "show"
06:10:20 <droidboi> bitonic: There are many things which prevent me (subset of people) from leaning Haskell. And I would like to eradicate such things
06:10:36 <BoR0> davidstone, what about "ignore"? is it like ignoring a person on IRC? :)
06:10:43 <bitonic> droidboi: and you think that `show' being named like it is is one such thing?
06:11:06 <wei2912> droidboi: just get used to it
06:11:09 <droidboi> as it doesn't show, yeah
06:11:10 <mauketwork> but now you're changing what "haskell" is
06:11:22 <mauketwork> droidboi: you still haven't explained what you mean by "show"
06:11:37 <sivteck> showThisStuffAsString
06:11:37 <droidboi> show means show
06:11:46 <bitonic> droidboi: well, that's definitely not my experience.  it's the first time I hear confusion about `show'.  sorry it's confusing you :P
06:11:51 <mauketwork> droidboi: that's not an explanation
06:12:02 <ion> tautology means tautology
06:12:12 <mauketwork> oxymoron means oxymoron
06:12:29 <droidboi> mauketwork show does a toString
06:12:36 <mauketwork> droidboi: irrelevant
06:12:47 <mauketwork> define the english word "show"
06:13:01 <droidboi> make visible
06:13:04 <BoR0> let me toString you something
06:13:31 <indiagreen> let me <$> you something
06:13:32 <tdammers> droidboi: "toString", conceptually, converts something to string - which, for something that is a string already, should be an identity
06:13:51 <droidboi> "what does show mean"? Who doesn't know what show means?
06:13:52 <mauketwork> the way ghci uses show, "make visible" is pretty close, actually
06:14:03 * hackagebot acme-strtok 0.1.0.3 - A Haskell port of the C/PHP strtok function  http://hackage.haskell.org/package/acme-strtok-0.1.0.3 (eberlm)
06:14:25 <indiagreen> droidboi: what, in your opinion, is the quality of a good name for a function in a programming language?
06:15:11 <tdammers> the definition of the English word "show" is only tangentially relevant anyway
06:15:14 <droidboi> FYI: I love Haskell
06:15:36 <int-e> > nub [1,2,1,3,1,2,1,4]
06:15:38 <lambdabot>  [1,2,3,4]
06:16:30 <mauketwork> droidboi: I don't know what *you* mean when you say "show doesn't show, because show means show"
06:17:05 <BoR0> while we're here, why can't fromString = read be eta-reduced? e.g. read fromString x = read x works fine
06:17:10 <droidboi> indiagreen: I feel that question moot
06:17:27 <mauketwork> BoR0: monomorphism restriction?
06:17:41 <droidboi> show implies vision
06:17:47 <BoR0> mauketwork, I'll have to read on that. thanks
06:17:54 <tdammers> droidboi: no, it doesn't, really. It's just a label.
06:18:14 <indiagreen> droidboi: it's not moot. If you're optimising, you should at least know what you're optimising for. I could say that “show” isn't “melodical”, for instance, but it wouldn't matter, right?
06:18:15 <mauketwork> BoR0: 1) add a parameter or 2) add a type signature or 3) disable the restriction
06:18:21 <int-e> "print" doesn't print anything either, as a rule.
06:18:44 <mauketwork> does anyone know if 'show' was designed for the REPL?
06:18:49 <mauketwork> because the name makes a lot of sense there
06:19:03 <bitonic> sigh.  who cares
06:19:14 <droidboi> so, for the first time in my life, show DOESN'T mean seeing something?
06:19:18 <mauketwork> bitonic: I do. duh
06:19:28 <int-e> droidboi: anyway surely Haskell has bigger warts than the name "show" (which is evocatve and still short)
06:19:33 <mauketwork> droidboi: show never means see
06:19:42 <mgsloan> show means "show me the code!" :)
06:19:48 <mgsloan> ideally
06:19:51 <chrisdone> oh god, i went for a shower and a meal and come back and you guys are still talking about 'show'
06:19:59 <chrisdone> come on
06:20:16 <mgsloan> such bike, very shed
06:20:27 <ion> That was a quick shower and a meal.
06:20:44 <indiagreen> so, if your complaint is that “show” in Haskell doesn't mean what it means in English, I'd like you to elaborate that a) it's beneficial for names in Haskell to mean the same as they would mean in English, and b) that this is more important than other qualities “show” has and other more English-friendly names don't.
06:20:45 <int-e> Ok. Let's show some faith and shed the bike...
06:21:29 <mauketwork> you should also consider huffmanization
06:21:31 <droidboi> show is really toString - and it does nothing to further the cause of Haskell.
06:21:36 <mauketwork> e.g. 'show' and 'read' have the same length
06:22:17 <bitonic> mauketwork: so, in the Haskell 1.0 report, that `Show' is called `Text'
06:22:40 <bitonic> `show' doesn't seem to exist, but `readsPrec' and `showsPrec' do, in the same `Text' typeclass
06:22:41 <int-e> droidboi: I think you're mistaking familiarity for sensibility. You're *used* to "toString" having that meaning, but as others have pointed out, "toString" should be the identity on strings.
06:22:45 <droidboi> The clue is in the definition show :: Show a => a -> String
06:22:56 <bitonic> ah no, `show' exists in terms of `showsPrec'
06:23:03 <bitonic> so no, it wasn't designed with a REPL in mind
06:23:50 <mgsloan> No, it was, that's why there's showsPrec so that the repl will parse it properly..
06:24:06 <mgsloan> (by getting precedences right)
06:24:35 <mgsloan> (when you copy and paste show results in the repl)
06:24:45 <bitonic> mgsloan: I'd say that's a general parsing/pretty-printing facility
06:25:28 <mgsloan> Fair 'nough, but traditionally "Show" attempts to output valid code for constructing the value
06:25:33 <bitonic> I always include that kind of precedence handling when I write parsers/pretty-printers for languages, even if I have no REPL
06:25:57 <bitonic> mgsloan: sure, it just has nothing to do with a REPL.  anyway, I like to bikeshed as much as anyone else but this discussion is a waste of time :P
06:26:07 <mgsloan> agreed
06:26:41 <droidboi> int-e Hi. Not sure what you mean.
06:32:17 <droidboi> indiagreen: I'm not sure I understand your (a) and (b). "it's beneficial for names in Haskell to mean the same as they would mean in English" surely that is true
06:34:03 * hackagebot heap 1.0.1 - Heaps in Haskell  http://hackage.haskell.org/package/heap-1.0.1 (eberlm)
06:34:05 * hackagebot alarmclock 0.2.0.1 - Wake up and perform an action at a certain time.  http://hackage.haskell.org/package/alarmclock-0.2.0.1 (dcturner)
06:34:16 <favetelinguis> I just cant figure out how to make this Sudoku solver work, im partally there but now I need some sort of backtracking so i dont get stuck on a single wrong try. I would be very glad for any help i can get to get this working. http://lpaste.net/115191
06:39:04 * hackagebot alarmclock 0.2.0.2 - Wake up and perform an action at a certain time.  http://hackage.haskell.org/package/alarmclock-0.2.0.2 (dcturner)
06:43:01 <clrnd> this alarmclock pkg seems what the guy that wanted to threadDelay for an hour needed
06:49:05 * hackagebot graph-matchings 0.1.0.0 - An implementation of algorithms for matchings in graphs  http://hackage.haskell.org/package/graph-matchings-0.1.0.0 (eberlm)
06:49:07 * hackagebot hasql-postgres 0.7.1 - A "PostgreSQL" backend for the "hasql" library  http://hackage.haskell.org/package/hasql-postgres-0.7.1 (NikitaVolkov)
06:56:00 <statusfailed> are there any good examples of how to use and write Traversals? (from lens)
07:03:35 <nshepperd> Traversal looks like (Applicative f) => (a -> f b) -> s -> f t
07:05:06 <nshepperd> so I guess it's something like 'traverseSecond f (x,y) = (\z -> (x,z)) <$> f y'
07:05:21 <nshepperd> for the traversal looking at the second of a pair
07:14:02 <k00mi> nshepperd: that's just a Lens, the point of a Traversal is that it can have multiple targets
07:15:52 <Cale> Well, every Lens is also a Traversal
07:16:28 <k00mi> true, but it's a bad example if the goal is to explain Traversals
07:16:35 <Cale> yeah
07:17:30 <nshepperd> true
07:17:49 <k00mi> a better example would be: traverseBoth f (x,y) = (,) <$> f x <*> f y
07:18:55 * Cale remembers a joke about a pure mathematician teaching young kids what a triangle was, and starting off with the cases where all three vertices are equal, and then where two vertices are equal, and then where they're distinct, but collinear...
07:20:10 <assia_t> Hey... I'm sorry... I'm stuck with a very boring problem...
07:20:47 <assia_t> How come `fromIntegral (PortNum $ fromIntegral (read "6379" :: Int)) :: Int` evaluate to 60184?
07:20:57 <assia_t> and not 6379?
07:21:56 <Cale> because network byte order is different
07:22:01 <Cale> You're not meant to do that
07:22:08 <mauketwork> don't use the PortNum constructor
07:22:15 <Cale> Just use 6379 as a port number
07:22:25 <Cale> It's an instance of Num, so you can just use a numeric literal
07:22:38 <mauketwork> fromInteger (read xyz) if it's coming from a string
07:22:45 <Cale> yeah
07:23:15 <assia_t> I see
07:23:23 <assia_t> Yeah... That makes sense. Thanks.
07:34:05 <PhineasRex> I cannot for the life of me figure out how to make an AccelGroup using gtk2hs.
07:34:19 <PhineasRex> It doesn't seem to have any constructors.
07:38:11 <PhineasRex> menuGetAccelGroup, uiManagerGetAccelGroup return AccelGroups if those item1s already have an AccelGroup.
07:38:52 <PhineasRex> Is anybody familiar enough with the gtk library to know how to instantiate an AccelGroup?
07:42:56 <ClaudiusMaximus> PhineasRex: looks like a missing binding to me? maybe file a bug for gtk2hs  https://developer.gnome.org/gtk3/stable/gtk3-Keyboard-Accelerators.html#gtk-accel-group-new exists but isn't available from haskell
07:43:42 <PhineasRex> Hmm, okay. I figured I was just missing something.
07:44:47 <ClaudiusMaximus> PhineasRex: looks like the bug tracker is here https://github.com/gtk2hs/gtk2hs/issues
07:45:29 <PhineasRex> ClaudiusMaximus: Thanks.
07:59:08 * hackagebot hspec2 0.6.1 - Alpha version of Hspec 2.0  http://hackage.haskell.org/package/hspec2-0.6.1 (SimonHengel)
08:03:25 <kess> hi, anybody have experience with parsec?
08:03:45 <bitonic> kess: I suggest you ask your question directly
08:04:47 <kess> ok, is there a construction similar to (p <|> q) which does q even if p consumed input before failing? (i.e. does backtracking?)
08:05:35 <mmmm> try
08:05:37 <bitonic> kess: try p <|> q
08:06:11 <mmmm> You have to be careful to not lose error information though
08:06:21 <bitonic> be aware that various aspects of parsec don't really work so well if you backtrack a lot.  if you are backtracking to parse tokens, I suggest you tokenize first, and then parse the tokens.
08:07:14 <kess> hmm
08:07:22 <kess> I'm pretty sure I need backtracking
08:07:25 <kess> I'm doing NLP stuff
08:07:41 <recursion-ninja> Could anybody recommend a good email library which I can authenticate with so that Microsoft's (Hotmail,Live,etc) service won't autodelete the email as spam
08:07:45 <bitonic> kess: sure, mine was just a guess based on my previous mistakes :)
08:08:35 <kess> but thanks for the advice :)
08:09:13 <bitonic> kess: the comment on parsec and backtracking still stands though, you'll get worse error messages and of course worse performance
08:13:34 <wei2912> http://blog.sigfpe.com/2006/08/you-could-have-invented-monads-and.html - what does "unit * f" mean?
08:16:54 <hpc> wei2912: he defines (*) at the start of that paragraph
08:16:59 <hpc> and wants you to find unit
08:17:09 <hpc> such that the equality holds
08:17:23 <wei2912> hpc: hmm, i must have skipped the definition of (*)
08:20:29 <wei2912> hpc: thanks for your help!
08:28:00 <ozgura> does anyone know a good source to learn about trifecta?
08:28:29 <ozgura> I am tempted to port a parsec parser to trifecta to see how the error messages improve (or not)
08:28:37 <ozgura> but I am finding it difficult
08:28:54 <ozgura> it has next to no documentation on hackage!
08:30:18 <aloiscochard> ozgura: I suppose you might have tried that http://packdeps.haskellers.com/reverse/trifecta
08:31:12 <ozgura> I didn't, at least not exactly. However I found pieces of code written using trifecta and tried to decipher them
08:31:19 <ozgura> Not very helpful so far
08:31:25 <ozgura> thanks for the idea though!
08:31:34 <ozgura> I will look through these too
08:31:39 <pantsman> I'm sure it's not a great example, but I ported my crappy scheme interpreter (from Write Yourself A Scheme) to trifecta
08:31:53 <pantsman> https://github.com/bmjames/wyas/blob/master/lib/WYAS/REPL.hs
08:33:06 <ozgura> pantsman: thanks!
08:33:25 <ozgura> from a quick look, it looks like you don't make use of the .Token module though
08:33:34 <ozgura> I was interested in that more than anything
08:34:14 <pantsman> no, you're right, it doesn't use token parsing
08:34:15 <ozgura> and specifically the use of CommentStyle + IdentifierStyle
08:34:54 <pantsman> ozgura: I also know of https://github.com/puffnfresh/language-scala
08:35:07 <pantsman> but I don't recall if that uses the stuff you are interested in
08:35:32 <pantsman> it does seem to use IdentifierStyle
08:36:08 <ozgura> pantsman: couldn't find how they handle comments
08:36:55 <pantsman> no, can't find it either, maybe he didn't implement it yet
08:37:51 <ozgura> parsec makes this very easy: http://hackage.haskell.org/package/parsec-3.1.7/docs/Text-ParserCombinators-Parsec-Token.html#t:GenLanguageDef
08:38:25 <wei2912> hi, i have some questions on a travis build, but i think this channel will be more suited for answering it
08:38:39 <wei2912> https://travis-ci.org/wei2912/blog_src/builds/42321560 - i've been getting this error
08:39:18 <ozgura> I was hoping trifecta would have a similar interface. It seems to have similar stuff, but I couldn't get them to work.
08:39:31 <wei2912> even though my files at https://github.com/wei2912/blog_src/tree/master/src have "{-# LANGUAGE OverloadedStrings #-}" at the top and my build script at https://github.com/wei2912/blog_src/blob/master/scripts/build.sh doesn't disable GHC extensions
08:39:38 <wei2912> interestingly, running my build script locally works
08:39:41 <wei2912> does anyone have an idea why?
08:41:36 <wei2912> just to confirm
08:41:52 <wei2912> "no implicit conversion of Symbol into String" - means the OverloadedStrigs extension isn't enabled, right?
08:43:42 <ozgura> wei2912: that doesn't sound like a haskell error message to me
08:43:49 <ozgura> I am not sure though, maybe it is
08:43:54 <wei2912> hmm.
08:44:08 <wei2912> ohh
08:44:10 * hackagebot passwords 0.1.0.5 - Password generation/validation library  http://hackage.haskell.org/package/passwords-0.1.0.5 (mkulkin)
08:44:19 <ozgura> "An error occurred while compiling the build script"
08:44:22 <wei2912> precisely
08:45:06 <wei2912> why is a build script being compiled? :P
08:45:31 <ozgura> I don't know, haven't used travis myself
08:45:44 <ozgura> it seems to suggest you to use a linter, have you tried that?
08:46:16 <wei2912> ozgura: yes, passed flawlessly
08:53:35 <wei2912> ozgura: thanks for the help
08:54:11 * hackagebot uhc-light 1.1.7.3 - Part of UHC packaged as cabal/hackage installable library  http://hackage.haskell.org/package/uhc-light-1.1.7.3 (AtzeDijkstra)
08:55:56 <ozgura> wei2912: no problem
08:58:27 <bitonic> why isn't there an instance `instance (Monoid b) => Monoid (Either a b)'?  with `mempty = Right mempty', and `mappend' similar to the one for Maybe?
08:59:42 <wei2912> ozgura: problem appears to be with my travis config. something to do with encrypted files, i think
09:22:22 <dutchie> are there higher order boolean combinators? so i can do something like `(all isUpper <&&> not null) . filter isAlpha` and keep things nice and point-free
09:22:56 <dutchie> (i appreciate that it's straightforward to write, just wondered if they were in the standard library anywhere already)
09:23:22 <hpc> @pl \f g b -> (f b) && (g b)
09:23:23 <lambdabot> liftM2 (&&)
09:24:08 <hpc> liftM2 (&&) (all isUpper) (not . null) . filter isAlpha
09:24:30 <hpc> or something like that
09:24:32 <dutchie> aha i was just trying to think of how to use liftM2 or something
09:25:24 * FireFly would define (<&&>) = liftM2 (&&) locally
09:25:34 <dutchie> exactly what i'm doing
09:32:38 <benzrf> >liftM2
09:32:42 <benzrf> >not liftA2
09:35:13 <FireFly> Good point
09:35:38 <FireFly> Hm, does infix application work with banana brackets?
09:37:50 <hiptobecubic> banana brackets?
09:37:59 <hiptobecubic> are those parentheses?
09:39:06 <FireFly> Oh, I probably meant idiom brackets
09:39:19 <FireFly> IIRC proposed sugar for f <$> x <*> y
09:39:39 <hiptobecubic> ?
09:40:14 <FireFly> https://personal.cis.strath.ac.uk/conor.mcbride/pub/she/idiom.html
09:40:33 <FireFly> ...which also mentions the infix thing explicitly, so never mind
09:41:10 <FireFly> I think dutchie's code could've been  (| all isUpper && not null |)  with that proposed syntax, then
09:42:14 <hiptobecubic> (% %) looks awful
09:49:59 <lpaste> Exio4 pasted “different number of arguments” at http://lpaste.net/115211
09:50:10 <exio4> is there any reason so that the last two don't work?
09:54:34 <clrnd_> exio4, https://www.haskell.org/pipermail/haskell-cafe/2009-March/058456.html
09:54:38 <clrnd_> thats all i know
09:55:13 <exio4> ah, ok
09:59:30 <bernalex> is there a builtin function for 60.22 = 22, 355.67 = 67, and so on?
10:01:08 <ThreeOfEight> for what type?
10:01:25 <bernalex> doesn't really matter
10:01:26 <clrnd_> :t properFraction
10:01:27 <lambdabot> (RealFrac a, Integral b) => a -> (b, a)
10:01:35 <clrnd_> that's almost there :P
10:01:41 <ThreeOfEight> well,floating points are problematic
10:01:43 <clrnd_> > properfraction 60.22
10:01:44 <bernalex> ThreeOfEight: something that's an instance of ReadMaybe.
10:01:45 <ThreeOfEight> because of rounding
10:01:46 <lambdabot>  Not in scope: ‘properfraction’
10:01:46 <lambdabot>  Perhaps you meant ‘properFraction’ (imported from Prelude)
10:01:51 <bernalex> ThreeOfEight: yeah
10:01:52 <clrnd_> > properFraction 60.22
10:01:55 <lambdabot>  (60,0.21999999999999886)
10:02:02 <exio4> > snd . properFraction $ 42.1337
10:02:06 <lambdabot>  0.1336999999999975
10:02:07 <bernalex> ThreeOfEight: well I guess I *should* be parsing properly
10:02:20 <bernalex> ThreeOfEight: I was just curious really
10:02:53 <ThreeOfEight> yeah, that's the problem: the question of how many decimal places a floating point number "has" is ill-defined
10:02:56 <ThreeOfEight> due to rounding
10:03:17 <ThreeOfEight> with Rationals, you don't have that problem, but you instead have the problem that you can have infinitely many decimal places
10:24:15 * hackagebot postgresql-orm 0.3.1 - An ORM (Object Relational Mapping) and migrations DSL for PostgreSQL.  http://hackage.haskell.org/package/postgresql-orm-0.3.1 (AmitLevy)
10:47:08 <adimit> Given I'm using GLFW-b and OpenGLRaw, does anybody know how do I interface with GLEW? Hackage doesn't seem to have bindings…
10:47:23 <adimit> (I could of course just go the C-route, but I'd rather keep FFI to a minimum.)
11:14:16 * hackagebot amazonka-autoscaling 0.0.5 - Amazon Auto Scaling SDK.  http://hackage.haskell.org/package/amazonka-autoscaling-0.0.5 (BrendanHay)
11:14:18 * hackagebot amazonka-cloudformation 0.0.5 - Amazon CloudFormation SDK.  http://hackage.haskell.org/package/amazonka-cloudformation-0.0.5 (BrendanHay)
11:14:20 * hackagebot amazonka-cloudfront 0.0.5 - Amazon CloudFront SDK.  http://hackage.haskell.org/package/amazonka-cloudfront-0.0.5 (BrendanHay)
11:14:22 * hackagebot amazonka-cloudsearch 0.0.5 - Amazon CloudSearch SDK.  http://hackage.haskell.org/package/amazonka-cloudsearch-0.0.5 (BrendanHay)
11:14:24 * hackagebot amazonka-cloudsearch-domains 0.0.5 - Amazon CloudSearch Domain SDK.  http://hackage.haskell.org/package/amazonka-cloudsearch-domains-0.0.5 (BrendanHay)
11:14:32 <yyttr3> When defining the arrows of a Category can the arrows have different operations on the objects so long as they compose?
11:16:15 <simpson> yyttr3: Sure.
11:16:16 <yyttr3> I'm trying to define groups as a Category by saying that a group contains two objects, where inverse is a arrow from object A to object B and * is a arrow from A to A or B to B?
11:17:28 <simpson> yyttr3: You only have to fulfill three laws: f . id = id . f = f, and f . (g . h) = (f . g) . h
11:18:53 <yyttr3> simpson: Alright, thank you
11:19:26 * hackagebot amazonka-cloudtrail 0.0.5 - Amazon CloudTrail SDK.  http://hackage.haskell.org/package/amazonka-cloudtrail-0.0.5 (BrendanHay)
11:19:28 * hackagebot amazonka-cloudwatch 0.0.5 - Amazon CloudWatch SDK.  http://hackage.haskell.org/package/amazonka-cloudwatch-0.0.5 (BrendanHay)
11:19:30 * hackagebot amazonka-cloudwatch-logs 0.0.5 - Amazon CloudWatch Logs SDK.  http://hackage.haskell.org/package/amazonka-cloudwatch-logs-0.0.5 (BrendanHay)
11:19:32 * hackagebot amazonka-codedeploy 0.0.5 - Amazon CodeDeploy SDK.  http://hackage.haskell.org/package/amazonka-codedeploy-0.0.5 (BrendanHay)
11:19:34 * hackagebot amazonka-cognito-identity 0.0.5 - Amazon Cognito Identity SDK.  http://hackage.haskell.org/package/amazonka-cognito-identity-0.0.5 (BrendanHay)
11:24:15 <juanpablo__> Is there any way I can get the error function to kill the parent thread as well as itself?
11:24:36 * hackagebot amazonka-cognito-sync 0.0.5 - Amazon Cognito Sync SDK.  http://hackage.haskell.org/package/amazonka-cognito-sync-0.0.5 (BrendanHay)
11:24:39 * hackagebot amazonka-config 0.0.5 - Amazon Config SDK.  http://hackage.haskell.org/package/amazonka-config-0.0.5 (BrendanHay)
11:24:41 * hackagebot amazonka-datapipeline 0.0.5 - Amazon Data Pipeline SDK.  http://hackage.haskell.org/package/amazonka-datapipeline-0.0.5 (BrendanHay)
11:24:43 * hackagebot amazonka-directconnect 0.0.5 - Amazon Direct Connect SDK.  http://hackage.haskell.org/package/amazonka-directconnect-0.0.5 (BrendanHay)
11:24:45 * hackagebot amazonka-dynamodb 0.0.5 - Amazon DynamoDB SDK.  http://hackage.haskell.org/package/amazonka-dynamodb-0.0.5 (BrendanHay)
11:26:09 <benzrf> oh
11:29:47 * hackagebot amazonka-ec2 0.0.5 - Amazon Elastic Compute Cloud SDK.  http://hackage.haskell.org/package/amazonka-ec2-0.0.5 (BrendanHay)
11:29:49 * hackagebot amazonka-elasticache 0.0.5 - Amazon ElastiCache SDK.  http://hackage.haskell.org/package/amazonka-elasticache-0.0.5 (BrendanHay)
11:29:51 * hackagebot amazonka-elasticbeanstalk 0.0.5 - Amazon Elastic Beanstalk SDK.  http://hackage.haskell.org/package/amazonka-elasticbeanstalk-0.0.5 (BrendanHay)
11:29:53 * hackagebot amazonka-elastictranscoder 0.0.5 - Amazon Elastic Transcoder SDK.  http://hackage.haskell.org/package/amazonka-elastictranscoder-0.0.5 (BrendanHay)
11:29:55 * hackagebot amazonka-elb 0.0.5 - Amazon Elastic Load Balancing SDK.  http://hackage.haskell.org/package/amazonka-elb-0.0.5 (BrendanHay)
11:34:57 * hackagebot amazonka-emr 0.0.5 - Amazon Elastic MapReduce SDK.  http://hackage.haskell.org/package/amazonka-emr-0.0.5 (BrendanHay)
11:34:59 * hackagebot amazonka-iam 0.0.5 - Amazon Identity and Access Management SDK.  http://hackage.haskell.org/package/amazonka-iam-0.0.5 (BrendanHay)
11:35:01 * hackagebot amazonka-importexport 0.0.5 - Amazon Import/Export SDK.  http://hackage.haskell.org/package/amazonka-importexport-0.0.5 (BrendanHay)
11:35:03 * hackagebot amazonka-kinesis 0.0.5 - Amazon Kinesis SDK.  http://hackage.haskell.org/package/amazonka-kinesis-0.0.5 (BrendanHay)
11:35:05 * hackagebot amazonka-kms 0.0.5 - Amazon Key Management Service SDK.  http://hackage.haskell.org/package/amazonka-kms-0.0.5 (BrendanHay)
11:36:29 <maybefbi> how do i hide the normal prelude and import basic-/classy-prelude ?
11:37:15 <mauke> import Prelude ()  -- I guess?
11:37:46 <maybefbi> mauke, ok thanks. can i do it from the .cabal file?
11:37:48 <simpson> {-# LANGUAGE NoImplicitPrelude #-} does it, doesn't it?
11:38:02 <monochrom> no, not in the .cabal file
11:38:13 <maybefbi> ok
11:38:25 <simpson> You can set language options in a .cabal file, IIRC.
11:38:45 <maybefbi> ok
11:38:58 <maybefbi> thanks. got more info here: https://www.haskell.org/haskellwiki/No_import_of_Prelude
11:39:11 <maybefbi> searched with the words you mentioned
11:40:07 * hackagebot amazonka-lambda 0.0.5 - Amazon Lambda SDK.  http://hackage.haskell.org/package/amazonka-lambda-0.0.5 (BrendanHay)
11:40:09 * hackagebot amazonka-opsworks 0.0.5 - Amazon OpsWorks SDK.  http://hackage.haskell.org/package/amazonka-opsworks-0.0.5 (BrendanHay)
11:40:11 * hackagebot amazonka-rds 0.0.5 - Amazon Relational Database Service SDK.  http://hackage.haskell.org/package/amazonka-rds-0.0.5 (BrendanHay)
11:40:13 * hackagebot amazonka-redshift 0.0.5 - Amazon Redshift SDK.  http://hackage.haskell.org/package/amazonka-redshift-0.0.5 (BrendanHay)
11:40:15 * hackagebot amazonka-route53 0.0.5 - Amazon Route 53 SDK.  http://hackage.haskell.org/package/amazonka-route53-0.0.5 (BrendanHay)
11:41:50 <robertlavigne> Hey, I'm giving a presentation on Haskell in a Programming Languages class and was wondering if anyone has some short examples of Cool Haskell features.
11:43:08 <mauke> :t fmap fix return
11:43:11 <lambdabot> b -> b
11:43:59 <simpson> > fmap fix return 42
11:44:00 <lambdabot>  42
11:44:18 <monochrom> "cool" is subjective. my cool feature is that "(\x -> x + x) (f 5)" and "f 5 + f 5" do the same thing. this is false in many other languages. but for most people, 50% thinks it's trivial, and the other 50% thinks it's an obstacle.
11:44:47 <monochrom> http://www.vex.net/~trebla/haskell/prerequisite.xhtml#leibniz
11:45:17 * hackagebot amazonka-route53-domains 0.0.5 - Amazon Route 53 Domains SDK.  http://hackage.haskell.org/package/amazonka-route53-domains-0.0.5 (BrendanHay)
11:45:19 * hackagebot amazonka-s3 0.0.5 - Amazon Simple Storage Service SDK.  http://hackage.haskell.org/package/amazonka-s3-0.0.5 (BrendanHay)
11:45:21 * hackagebot amazonka-sdb 0.0.5 - Amazon SimpleDB SDK.  http://hackage.haskell.org/package/amazonka-sdb-0.0.5 (BrendanHay)
11:45:23 * hackagebot amazonka-ses 0.0.5 - Amazon Simple Email Service SDK.  http://hackage.haskell.org/package/amazonka-ses-0.0.5 (BrendanHay)
11:45:25 * hackagebot amazonka-sns 0.0.5 - Amazon Simple Notification Service SDK.  http://hackage.haskell.org/package/amazonka-sns-0.0.5 (BrendanHay)
11:46:13 <robertlavigne> Thank for the suggestions. I realize it is subjective, but I was curious what people who use the language a lot find as Haskells major benifits over other language choices.
11:46:55 <looking_glass> robertlavigne: It's going to also depend on their viewpoint. What do they already know? If they know say Ocaml the knowledge you'd present may be more incremental. If it's a bunch of C programmers you may sound like a crazy person if you start going on about infinitie data structures and monads.
11:46:57 <clrnd> robertlavigne, well .... it's a long list
11:47:09 <clrnd> yeah, what's your audience?
11:47:23 <Hijiri> I can write some code and if it compiles it will be at least very close to what I intended
11:47:48 <robertlavigne> Mostly Java/C++ 3rd year uni students, who know a bit of scheme
11:48:45 <clrnd> robertlavigne, haskell is another paradigm altogether, do you know the language btw?
11:49:37 <robertlavigne> Ive learned the basics and can write it, but wouldnt consider myself proficient.
11:50:15 <clrnd> for example when I learned monads, this was a mind melter for me http://lukepalmer.wordpress.com/2008/08/10/mindfuck-the-reverse-state-monad/
11:50:27 * hackagebot amazonka-sqs 0.0.5 - Amazon Simple Queue Service SDK.  http://hackage.haskell.org/package/amazonka-sqs-0.0.5 (BrendanHay)
11:50:29 * hackagebot amazonka-storagegateway 0.0.5 - Amazon Storage Gateway SDK.  http://hackage.haskell.org/package/amazonka-storagegateway-0.0.5 (BrendanHay)
11:50:31 * hackagebot amazonka-sts 0.0.5 - Amazon Security Token Service SDK.  http://hackage.haskell.org/package/amazonka-sts-0.0.5 (BrendanHay)
11:50:33 * hackagebot amazonka-support 0.0.5 - Amazon Support SDK.  http://hackage.haskell.org/package/amazonka-support-0.0.5 (BrendanHay)
11:50:35 * hackagebot amazonka-swf 0.0.5 - Amazon Simple Workflow Service SDK.  http://hackage.haskell.org/package/amazonka-swf-0.0.5 (BrendanHay)
11:54:34 <clrnd> I guest I'd show them some cool workings on lists :P (I did that for a python meeting in some univ)
11:55:22 <robertlavigne> Yeah I have some list comprehension stuff, and the classic 3 line "quick sort"
11:56:02 <looking_glass> robertlavigne: For that audience it's going to depend on how much they know and what kind of Java, C++, and Scheme they were taught. If they're familiar with Java generics, you can point out that Java generics were influenced by research done on Haskell typeclasses by Philip Wadler. If they're familiar with C++ templates, you can point out that Haskell type classes avoid peppering C++ code with ad hoc static asserts at every poin
11:56:02 <looking_glass> template instatiation and instead are done at definition. For both, you can point out the brevity that Hindley-Milner provides in code while not sacrificing type safety. If they know scheme (and don't hate it for being "weird"), you could mention template haskell for syntactic abstraction, although my knowledge of template haskell is very superficial. Someone else here may be able to comment more on that.
11:56:11 <clrnd> robertlavigne, oh I also showed quicksort, and then the Continuation Monad tail recursive verison
11:56:14 <monochrom> Haskell has no "null". this is a cool feature to me too. (likewise, a hinderance to other people.) http://www.infoq.com/presentations/Null-References-The-Billion-Dollar-Mistake-Tony-Hoare
11:56:18 <robertlavigne> I dont think ill go to deep into monads, since there a bit of a charlie foxtrot to explain
11:57:29 <clrnd> it was just for flash, because I predicted they'd say it was not tail recursive ;)
11:57:57 <monochrom> to design an API for stacks, in Java and C++ you have "pop" return null when the stack is empty. in Haskell you have "pop" return Nothing when the stack is empty.
11:58:53 <monochrom> they are different. assume that this is a stack of T's. null still has type T. Nothing has type Maybe T, not T alone. this makes a difference.
11:59:39 <simpson> But Haskell isn't total~
12:00:14 <monochrom> if pop's return type is simply T, you will forget to check for null. if pop's return type is Maybe T, you cannot forget to check for Nothing, the compiler will remind you.
12:00:26 <monochrom> no I am not going for totality.
12:01:01 <robertlavigne> interesting. Thanks for that.
12:01:03 <monochrom> I am going for "express yourself correctly" and "note to self"
12:01:22 <dutchie> ‘fromString’ is not a (visible) method of class ‘IsString’ what's going on here?
12:01:42 <clrnd> it's a private method.... wait so this was #java after all
12:02:57 <geekosaur> dutchie, show code, but my guess is you need to import Data.String
12:03:19 <dutchie> nope, got an import for that
12:03:39 <dutchie> oh wait
12:03:54 <dutchie> i have `import Data.String (IsString)`
12:04:02 <clrnd> lol
12:04:03 <dutchie> i should have `IsString(..)` or similar
12:07:15 <monochrom> simpson: I am also going for "assume-guarantee", which does not require totality. "head" is partial, "head []" is bad. presumably, someone may also specify "pop" to be like "head". but even so, here is my point. suppose there is an expression "f (head [])" and I am the author of f. then only "head []" has a problem, but that is not my problem. I am the author of f, I don't need to check for "null", it can't happen. either f is not called, or f is calle
12:07:15 <monochrom> d with real data.
12:07:53 <monochrom> in Java and C++, both "head []" and "f" have problems. the author of f still has to check for null, which is a chore.
12:09:09 <spng453> Can I force strictness in a let statement?
12:09:35 <monochrom> with extension BangPatterns you can easily.
12:09:47 <monochrom> without that extension, you can with extra code.
12:09:51 <spng453> And what would the syntax for that be?
12:10:01 <spng453> I am using BangPatterns elsewhere in the file
12:10:10 <kadoban> monochrom: I'm not sure that's really sound reasoning. In C++ if your interface constraints are "don't pass me partial functions", then it's exactly the same when you're writing f.
12:10:12 <monochrom> "let !x = 4+5 in x*2" or "let x = 4+5 in seq x (x*2)"
12:10:27 <spng453> Ah, that works
12:10:27 <spng453> thanks
12:12:02 <spng453> Wait, GHC is giving me an error for that code
12:12:32 <kadoban> spng453: The first require a language extension. BangPatterns IIRC
12:12:42 <spng453> I enabled that
12:12:57 <spng453> It's {-# LANGUAGE BangPatterns #-}, right?
12:13:09 <kadoban> I think so.
12:13:30 <spng453> http://lpaste.net/2866551466447863808 Then why is GHC disliking this?
12:14:05 <kadoban> spng453: language pragmas have to go at the start of the file, before the imports and the module decs and whatever.
12:14:13 <spng453> Dang, I always do that
12:21:05 <yyttr3> Does the monomorphism restriction have anything to do with Categorical monomorphism? I might be missing something but I don't yet see the connction.
12:22:21 <FreeFull> yyttr3: It's to do with a type you'd expect to be polymorphic being intentionally inferred to be monomorphic
12:22:32 <FreeFull> Because the people who wrote the spec thought it was a good idea for performance reasons
12:22:39 <Schluri> @pl s xs=  [nNr x xs|x<-xs]
12:22:39 <lambdabot> s = return . ((<-) =<< (| x) . nNr x)
12:22:53 <Schluri> so that works too holy hell
12:23:24 <FireFly> I don't think @pl does comprehensions
12:23:35 <FireFly> I think it mistakenly took your | and <- for operators
12:24:07 <FreeFull> Yeah, (<-) isn't usually a valid thing to have in your code
12:24:19 * hackagebot httpd-shed 0.4.0.3 - A simple web-server with an interact style API  http://hackage.haskell.org/package/httpd-shed-0.4.0.3 (AndyGill)
12:25:03 <FireFly> @pl s xs = map (flip nNr xs)
12:25:04 <lambdabot> s = map . flip nNr
12:25:11 <FireFly> I guess?
12:34:19 * hackagebot extra 1.0 - Extra functions I use.  http://hackage.haskell.org/package/extra-1.0 (NeilMitchell)
12:43:01 <ReinH> What is (<-)?
12:43:04 <ReinH> :t (<-)
12:43:05 <lambdabot> parse error on input ‘<-’
12:43:11 <ReinH> That shouldn't be valid syntax.
12:43:23 <ReinH> <- is syntax, not an operator.
12:44:56 <lpaste> Deca pasted “Why am I getting a parse error for where in this?” at http://lpaste.net/115214
12:45:15 <mauke> Deca: missing =
12:46:16 <deca_> Thanks! Why didn'
12:46:18 <deca_> t
12:46:36 <deca_> it pick up that the equals is missing in the guard instead of the where?
12:46:58 <lispy> because otherwise False could have been an expression
12:47:04 <FireFly> ReinH: exactly, @pl's parser is lousy I guess
12:47:04 <mauke> it saw you write the guard 'otherwise False where'
12:47:11 <mauke> and 'where' is an error at that point
12:47:26 <deca_> oh
12:47:50 <mauke> you can get rid of the guards by writing 'first == last && isPalindrome ys'
12:47:58 <ReinH> FireFly: yeah, interesting
12:48:26 <mauke> and you can get rid of everything by writing 'isPalindrome xs = xs == myReverse xs'
12:49:59 <deca_> I could if I could understand that. Still quite new at this.
12:51:20 <deca_> Ok that makes sense now!
12:51:56 <mauke> "xs is a palindrome if it is equal to its reverse"
12:52:08 <deca_> yeah I get it now
12:54:59 <tippenein> Can anyone explain or point to somewhere describing why sortBy (flip compare) is faster than reverse $ sort   I have a naive idea why this might be the case, but if anyone knows exactly, I'm curious
12:55:51 <dschoepe> tippenein: the first one only traverses the list as often as sort does, whereas the second approach does one more traversal compared to just sorting
12:57:10 <tippenein> 2 O n log n instead of O n log n?
12:57:31 <mauke> I don't think O() will help you
12:57:34 <ReinH> tippenein: complexity is the same
12:57:42 <ReinH> runtime is different
12:58:34 <ReinH> O(2n log n) = O(n log n)
12:58:55 <ReinH> but operationally, the former sorts in one pass while the latter requires 2 passes.
12:58:55 <mauke> reverse is O(n)
12:59:24 <tippenein> ah, right. sort and sortBy are the same, not reverse
12:59:43 <texasmynsted> What is the name for complexity of a sort operation?
12:59:55 <ReinH> "loglinear"
13:00:09 <ReinH> or http://en.wikipedia.org/wiki/Timecomplexity#Linearithmictime
13:00:29 <ReinH> (assuming that complexity is O(n log n))
13:00:41 <ReinH> (Not all sorts are loglinear, ofc)
13:01:03 <texasmynsted> So there must be a name then?  Maybe simply complexity?
13:01:21 <ReinH> Well, there are various ways of measuring complexity
13:01:25 <ReinH> Big O is one of them
13:01:37 <Welkin> Big O is also a mecha anime series
13:01:43 <ReinH> Also http://en.wikipedia.org/wiki/Asymptoticcomputationalcomplexity
13:01:55 <ReinH> So you might hear "asymptotic" thrown around
13:01:59 <Welkin> I knew of that Big O before I learning the computer science version
13:02:03 <ReinH> Welkin: :)
13:02:13 <Welkin> learned*
13:02:25 <davean> "On the order of"
13:02:40 <FireFly> ReinH: I think you accidentally a bunch of underscores
13:02:44 <texasmynsted> http://bigocheatsheet.com/
13:02:47 <ReinH> oh crap, I did
13:02:49 <ReinH> \unlatex
13:02:58 <ReinH> http://en.wikipedia.org/wiki/Asymptotic_computational_complexity
13:03:02 <ReinH> http://en.wikipedia.org/wiki/Time_complexity#Linearithmic_time
13:03:07 <ReinH> FireFly: thanks
13:03:17 <texasmynsted> heh ok
13:03:19 <texasmynsted> ty
13:03:37 <tippenein> I guess I understand everything but (flip compare). How does that accomplish sorting
13:04:02 <ReinH> tippenein: what would flip (<) do?
13:04:59 <mauke> tippenein: do you understand sortBy compare?
13:06:24 <tippenein> compare is just the operator for an Ordering ? and I'm not sure about flip (<)
13:07:27 <tippenein> looks like flip (<) just compares backwards
13:07:36 <ReinH> tippenein: right, which is what flip compare does as well
13:07:37 <tippenein> Prelude Data.List> (flip (<)) 1 2
13:07:39 <tippenein> False
13:07:39 <ReinH> it compares backwards
13:07:49 <ReinH> > compare 1 2
13:07:51 <lambdabot>  LT
13:07:53 <ReinH> > flip compare 1 2
13:07:55 <lambdabot>  GT
13:08:32 <ReinH> so you are using a comparison that returns the opposite of a normal comparison
13:08:57 <ReinH> which gives a sort that sorts in the opposite order
13:11:59 <saep> @src flip
13:11:59 <lambdabot> flip f x y = f y x
13:15:27 <Denommus> @src mapM_
13:15:27 <lambdabot> mapM_ f as = sequence_ (map f as)
13:15:34 <Denommus> @src sequence_
13:15:34 <lambdabot> sequence_ ms = foldr (>>) (return ()) ms
13:21:03 <Denommus> I didn't know about @src
13:22:50 <FireFly> @src blarg
13:22:51 <lambdabot> Source not found. You type like i drive.
13:23:00 <FireFly> It also provides insults for free
13:23:56 <osfameron> yeah, it's an odd characteristic for #haskell (which is otherwise amazingly polite)
13:24:21 * hackagebot shake 0.14.2 - Build system library, like Make, but more accurate dependencies.  http://hackage.haskell.org/package/shake-0.14.2 (NeilMitchell)
13:30:19 <Schluri> @pl groupY x = groupBy  (geq `on` snd)  (sortBy(comparing snd) x)
13:30:20 <lambdabot> groupY = groupBy (geq `on` snd) . sortBy (comparing snd)
13:30:27 <Schluri> the fuck i had that D:
13:32:22 <Peaker> I like:   groupOn = groupBy ((==) `on`)   sortOn = sortBy . comparing
13:32:32 <sinelaw> Peaker, hey
13:32:34 <Peaker> groupOn snd . sortOn snd
13:32:36 <Peaker> sinelaw, hey
13:34:40 <sinelaw> given some tree-like data structure, does the runtime really reuse the values if I hold "copies" of various tree nodes in some other structure?
13:34:56 <sinelaw> e.g. Tree a -> Map a (Tree a)
13:35:24 <sinelaw> the map having as elements some nodes from the original tree
13:35:42 <mauke> how do you make your "copies"?
13:35:44 <sinelaw> I assume the runtime reuses the values and doesn't have to store them twice?
13:35:58 <sinelaw> mauke, not really copies.
13:36:04 <lispy> You'll have to be more precise
13:36:11 <sinelaw> ok. example:
13:36:17 <lispy> GHC doesn't do common subexpression elimination, for instance
13:36:37 <sinelaw> f n@(Node a) = (n, a)
13:36:58 <sinelaw> or something of the sort, recursively over a data struct of nodes
13:37:02 <mauke> that allocates a (,) node
13:37:05 <lispy> If you did let x = <somecomputation in (x,x), then the tuple really has pointers to x and only one copy of x needs to exist in the heap
13:37:06 <sinelaw> should really be (Node a l r) or so
13:37:13 <sinelaw> mauke, but is "n" reused?
13:37:16 <mauke> yes
13:37:19 <sinelaw> ok
13:37:46 <lispy> are you familiar with call by name?
13:37:58 <sinelaw> not in Haskell. :)
13:38:21 <lispy> Well, it's not what Haskell does, so that's good? :)
13:38:56 <lispy> Anyway, the point I wanted to make is that you can think of expressions as templates. Values get bound to their arguments and that instantiates the template.
13:39:52 <lispy> Laziness allows you to share 'updates' in the bindings (the updates here correspond to normalizing expressions)
13:40:03 <lispy> How does this relate to your question?
13:40:03 <sinelaw> I know a bit about graph reduction. so generally in GHC reusing a function parameter inside the result reuses the same graph node?
13:40:36 <lispy> Well, that sharing is what you get all over the place that allows the 'copies' (as you referred to them) to be the same value in the heap
13:40:55 <sinelaw> ok thanks
13:40:57 <lispy> sinelaw: yea, that's one way to put it
13:42:12 <sinelaw> cool.
13:42:36 <lispy> call by name vs. call by need comes up because the template instantiation without shared updates corresponds to call by name. Add the sharing and you have call by need.
13:58:43 <lwm> :t (<*>)
13:58:44 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
13:58:52 <lwm> can someone explain that type signature to me
13:59:22 * hackagebot argparser 0.3.4 - Command line parsing framework for console applications  http://hackage.haskell.org/package/argparser-0.3.4 (sbergot)
13:59:26 <mauke> what's the first part that you don't understand?
14:01:00 <lwm> f (a -> b)
14:01:11 <lwm> what is that?
14:01:50 <monochrom> f could be Maybe, for example. the whole thing could be "Maybe (a -> b) -> Maybe a -> Maybe b", for a special case.
14:01:51 <mauke> a type
14:02:02 <mauke> f is a parameterized type
14:02:09 <mauke> it gets (a -> b) as an argument
14:02:15 <mauke> a -> b is the type of a function
14:03:34 <maybefbi> classyprelude promised me i won't have to qualify my import statements. but when i decided to work with Data.Map. turns out classyprelude doesn't have adjust or insert of the Map. so I imported Data.Map without qualifying it, and then Data.Map.member collides with ClassyPrelude.member. is there anyway to escape from qualified modules?
14:03:59 <lwm> mauke, monochrom: ok, thanks, trying to work out an example of its usage
14:04:25 <mauke> > Just sqrt <*> Just 2
14:04:26 <lambdabot>  Just 1.4142135623730951
14:04:47 <Haskellfant> how does hspec compare to hunit? I don't really see the differences except for different syntax
14:04:50 <lwm> ahhhhhhhh
14:04:53 <mauke> > [map toUpper, length] <*> ["ab", "cdefg"]
14:04:54 <lambdabot>  Couldn't match type ‘GHC.Types.Int’ with ‘[GHC.Types.Char]’
14:04:54 <lambdabot>  Expected type: [GHC.Types.Char] -> [GHC.Types.Char]
14:04:54 <lambdabot>    Actual type: [GHC.Types.Char] -> GHC.Types.Int
14:04:55 <lwm> mauke: nice one
14:04:59 <Peaker> maybefbi, import Data.Map (adjust, insert)
14:04:59 <mauke> oh, right
14:05:03 <mauke> > [map toUpper, show . length] <*> ["ab", "cdefg"]
14:05:04 <lambdabot>  ["AB","CDEFG","2","5"]
14:05:17 <maybefbi> Peaker, oh right i forgot
14:05:27 <Peaker> importing everything unqualified is terrible :(  Python got that part right and made the syntax for that:  from foo import *  <-- this feels naughty! because it is!
14:05:43 <sinelaw> does Data.Map.Lazy somehow magically use IntMap when k = Int?
14:06:00 <maybefbi> Peaker, qualifying (+) seems silly too.
14:06:04 <mauke> sinelaw: no, it can't
14:06:24 <sinelaw> didn't think so :(
14:06:28 <Peaker> It should! with type families
14:06:42 <mauke> type families can do that, yes. but not parameterized types
14:06:43 <sinelaw> template specialization
14:07:57 <Peaker> at least with Lens' "at" we can abstract over IntMap vs. Map and others -- a big chunk of the Data.[Int]Map API is covered by "at"
14:08:48 <sinelaw> is IntMap signficantly better for small maps?
14:09:12 <shachaf> Better for what?
14:09:36 <lispy> regular maps have improved so much, is IntMap ever a win these days? (Serious question, I've not benchmarked it or anything)
14:10:08 <AleksejsHome> I know that in haskell there is prefix and infix notation. But is there a postfix notation?
14:10:09 <sinelaw> shachaf, speed I guess.
14:10:25 <mauke> there's fake postfix via sections
14:10:29 <Iceland_jack> AleksejsHome: Yes
14:10:31 <mauke> (foo `bar`)
14:10:40 <shachaf> Data structures don't have speeds.
14:10:50 <sinelaw> yes they do.
14:10:52 <Iceland_jack> ghci> :set -XPostfixOperators
14:10:52 <Iceland_jack> ghci> let (!) n = product [1..n]
14:10:52 <Iceland_jack> ghci|
14:10:55 <Iceland_jack> ghci> (7 !)
14:10:58 <Iceland_jack> 5040
14:11:08 <mauke> sinelaw: I am disappoint
14:11:10 <shachaf> That fake postfix notation is a GHC extension for functions that return a non-function value, though.
14:11:17 <AleksejsHome> Iceland_jack: nice!
14:11:24 <sinelaw> just like bicycles
14:11:26 <shachaf> The Report specifies that (x `f`) is \y -> f x y
14:11:28 <sinelaw> mauke, ?
14:11:36 <tippenein> I appreciate the nudge in the right direction ReinH
14:11:44 <AleksejsHome> -XPostfixOperators is what I was looking for, thanks!
14:12:40 <sinelaw> shachaf, implementations of data structures have different performances
14:12:48 <sinelaw> or rather, perform differently.
14:13:20 <mauke> data structures don't have speeds
14:14:00 <mauke> the interesting parts of an implementation are the operations
14:14:25 <sinelaw> That's nitpicking. what good is a data structure that you don't ever operate on?
14:14:37 <shachaf> operate :: DataStructure a => a -> a
14:15:00 <sinelaw> or do also operations not have speeds?
14:15:07 <sinelaw> asks me
14:15:48 <mauke> sinelaw: what's faster, ["foo", "bar", "baz"] or Just 42?
14:16:19 <tempay> data structures can have multiple operations, each of which can have different speeds
14:16:24 <sinelaw> mauke, I think my question regarding IntMap vs. Map was pretty clear
14:16:25 <shachaf> Specifying the operation you're talking about is a good start.
14:16:40 <shachaf> I don't think it was clear.
14:16:42 <juanpablo__> If I have a ThreadId, how can I check if the thread is alive or not?
14:16:46 <sinelaw> it was clear to myself.
14:16:56 <shachaf> But you're not asking yourself.
14:17:10 <sinelaw> I like a challenge.
14:17:10 <shachaf> Maybe the operation you're talking about is computing the size of a map.
14:17:29 <shachaf> That's documented as O(n) for IntMap and O(1) for Map.
14:17:31 <tempay> juanpablo: http://stackoverflow.com/questions/9475392/is-there-a-way-in-haskell-to-query-thread-state-using-threadid-after-a-forkio
14:17:36 <shachaf> Oh, well, enjoy your challenge, then.
14:17:45 <sinelaw> ok, now seriously. I meant to ask if lookup / insert on IntMap are better than on Map
14:17:52 <sinelaw> shachaf, was kidding.
14:18:04 <Peaker> Why wouldn't IntMap do O(1) size?
14:18:09 <mauke> shachaf: that doesn't tell you which is faster, though :-)
14:18:10 <sinelaw> specifically for when the map is "small" as in, up to 100 elements.
14:18:53 <Peaker> mauke, it hints about it very very strongly :)
14:19:06 <monochrom> I'm pretty sure Map and IntMap have the same asymptotic costs and different constant-multiplier costs, and IntMap's constant multiplers are lower.
14:19:21 <shachaf> Map and IntMap are completely different data structures.
14:19:57 <mauke> would you rather wait 1 year or n milliseconds?
14:20:11 <shachaf> One is a balanced binary tree and the other is a radix tree.
14:20:21 <sinelaw> shachaf, ok, I was under the impression that IntMap is the "generally more time-efficient" map for when your keys are Ints
14:20:22 <Peaker> monochrom, I thought IntMap used something like a radix-tree (with prefix compression), so it could potentially be faster than O(logN)
14:20:43 <shachaf> Peaker: Map uses Ints at the branches to do the balancing, so it gets the size for free.
14:20:51 <shachaf> IntMap doesn't, so it doesn't.
14:21:08 <Peaker> shachaf, but it could keep a single Int at the root, it's so cheap and makes size O(1), why not do it?
14:21:09 <shachaf> You could probably keep track of the size yourself easily enough.
14:21:59 <ThreeOfEight> I wonder if there is an easier/better way to do this: https://gist.github.com/3of8/8f0c258965e417ba1741
14:22:04 <sinelaw> let me ask this question differently.
14:22:31 <sinelaw> what are the advantages of IntMap when is "small"?
14:22:35 <monochrom> on second thought, since Int is bounded, IntMap operations must be O(1) :)
14:22:36 <shachaf> Peaker: Probably the answer is that it costs some performance. I don't know if it's significant.
14:24:13 <blicero> ThreeOfEight cant you do it with arrows?
14:24:17 <Peaker> monochrom, for IntegerMap, you'd get O(size(Integer)) for the operations
14:24:39 <ThreeOfEight> blicero: what exactly?
14:25:38 <suvash> hi people, does anybody have a working snippet of http basic auth request/response that i could try and study. (possibly using http conduit)
14:26:02 <suvash> i'm just beginning and this is starting to get frustrating :(
14:27:00 <blicero> ThreeOfEight not sure, it looks like code dealing with function application to tuples and you'd typically use Control.Arrow for that stuff, maybe you've already tried it and it didnt work out?
14:27:17 <ThreeOfEight> I have very little familiarity with arrows
14:27:49 <trap_exit> how do I "import GHC" as in https://www.haskell.org/haskellwiki/GHC/As_a_library ?
14:27:50 <trap_exit> it claims that is' hidden
14:27:57 <trap_exit> It is a member of the hidden package ‘ghc-7.8.3’.
14:27:59 <trap_exit> how do I import it?
14:28:24 <bitonic> blicero: you can try to search for a ping/pong app using, say, warp
14:28:26 <trap_exit> dear internet, please stop your turkey eating and help me :-)
14:28:31 <bitonic> sorry, I meant suvash
14:28:56 <ThreeOfEight> In the easiest case, unravel has the type (a -> (b,c)) -> (a -> b, a -> c)
14:29:05 <ThreeOfEight> I can't find anything for that on Hoogle
14:29:10 <blicero> ThreeOfEight see if the functions 'first' and 'second' from control.arrow do what you need
14:29:21 <suvash> bitonic: warp you mentioned. i'm assuming that a lib then.
14:29:22 <ThreeOfEight> and for the more general case, I'm not sure this is possible without type families
14:29:34 <bitonic> suvash: `warp' is a library, yes
14:29:54 <ThreeOfEight> blicero: I know first and second, but I don't really see how I could use them here
14:30:09 <Peaker> ThreeOfEight, you could generalize it to Functor:  Functor f => f (a, b) -> (f a, f b)
14:30:14 <bitonic> trap_exit: are you compiling with `-package ghc'?
14:30:22 <bitonic> (as that wiki page says)
14:30:38 <trap_exit> bitonic: nope
14:30:40 <trap_exit> bitonic: that fixed it :-)
14:30:59 <trap_exit> bitonic: tell whoever you're eating with to give you an extra slice of turkey for helping someone on the inetneret :-)
14:31:19 <bitonic> trap_exit: I don't live in that place ehe
14:31:32 <bitonic> just ate a lot though
14:31:39 <trap_exit> bitonic: I live in the US, and I don't celebrate thanksgiving
14:32:23 <suvash> bitonic: this is some of what i have right now. i meant a http request using basic auth, wasn't clear before i guess.
14:32:29 <suvash> bitonic: https://gist.github.com/suvash/4e51cea5f0a2b9c8d63b
14:32:40 <trap_exit> what restauranst are open on thanksgiving
14:32:41 <trap_exit> I am hungry
14:32:53 <monochrom> Canadian restaurants
14:33:02 <trap_exit> how about asian restaurants ?
14:33:25 <monochrom> yes too, but Canada is closer than Asia
14:33:42 <monochrom> unless you are already in Alaska
14:33:47 <bitonic> here in Rome the restaurant I went to was open
14:34:01 <ThreeOfEight> Peaker: that seems to lead to a lot of ambiguous instances
14:34:21 <monochrom> but wait, even if you're in Alaska, Canada is still closer. so s/Alaska/Hawaii/
14:35:00 <ThreeOfEight> :r
14:35:03 <bitonic> suvash: oh, OK.  let's see
14:35:08 <ThreeOfEight> whoops
14:36:01 <bitonic> suvash: so you're trying to issue an HTTP request
14:36:28 <suvash> bitonic: yeah, kinda dumb. but that's it. only that it's using basic auth as well.
14:36:50 <bitonic> suvash: that looks OK.  what's not working?
14:37:40 <suvash> bitonic: `Couldn't match expected type ‘m Request’ with actual type ‘Request’ …`
14:37:41 <Schluri> @pl foo xs = foo1 xs xs
14:37:41 <lambdabot> foo = join foo1
14:38:53 <bitonic> suvash: oh, I see.  `parseUrl' is monadic
14:39:17 <bitonic> you're passing it as an argument, but it has the wrong type -- `m Request' instead of `Request' (where `m' indicates some monad)
14:39:26 <Schluri> can someone help me express this in pointfree: foo xs=  [foo1 x $delete x xs|x<-xs]
14:39:29 <suvash> bitonic: yeah ! hence the fromJust ?
14:39:43 <bitonic> suvash: `fromJust' is the wrong type
14:39:45 <bitonic> :t fromJust
14:39:45 <lambdabot> Maybe a -> a
14:40:15 <bitonic> oh sorry.
14:40:17 <bitonic> MonadThrow m
14:40:20 <bitonic> so yeah, it should be fine!
14:40:27 <bitonic> let's see..
14:41:32 <monochrom> @pl \xs -> map (\x -> foo1 x (delete x xs)) xs
14:41:32 <lambdabot> map =<< ap foo1 . flip delete
14:41:33 <bitonic> right, it's the opposite problem -- I read the error too quickly.  that computation `applyBasicAuth ...' is not monadic, but you are making it so
14:41:43 <monochrom> it is better off not pointfree
14:42:11 <Schluri> thats what i thought anyway
14:42:30 <bitonic> suvash: if you bind that request with a `let' it should work
14:43:50 <suvash> bitonic: hmm.. not sure how exactly you mean. ` let request <- ................ ` ?
14:44:16 <bitonic> suvash: `let request = ...'
14:44:29 <suvash> ah, lemme try then
14:47:25 <Schluri> @pl nNeighbor x xs = (x,minimumBy(comparing (distanceOfPoints x))xs)
14:47:25 <lambdabot> nNeighbor = liftM2 (.) (,) (minimumBy . comparing . distanceOfPoints)
14:47:37 <ymasn> hi, I'm in the process of learning Haskell, i know SML, Lisp, Scala etc already and alot of the tutorial material I'm finding on google is a bit too basic. Any tips?
14:47:55 <AleksejsHome> @where lyah
14:47:55 <lambdabot> http://www.learnyouahaskell.com/
14:47:58 <Schluri> !
14:48:26 <shachaf> ymasn: You might like the Gentle Introduction.
14:48:37 <shachaf> @where tutorial
14:48:37 <lambdabot> http://www.haskell.org/tutorial/
14:48:45 <untseac> Hey
14:48:51 <sinelaw> ymasn, http://science.raphael.poss.name/haskell-for-ocaml-programmers.html
14:49:23 <sinelaw> ymasn, and this -> http://dev.stephendiehl.com/hask/
14:49:40 <ymasn> AleksejsHome: tried that one, but i quit reading it, too much stuff i already know
14:49:44 <ymasn> shachaf: thanks
14:49:48 <ymasn> sinelaw: thanks
14:49:53 <Schluri> well skip ahead i guess....
14:50:21 <Schluri> @pl distanceOfPoints (x,y) (a,b) =abs (x- a) + abs(y-b)
14:50:21 <lambdabot> distanceOfPoints = uncurry (flip flip snd . (ap .) . flip flip fst . ((.) .) . (. ((abs .) . (-))) . flip . (((.) . (+) . abs) .) . (-))
14:50:26 <Schluri> ok bo
14:50:28 <Schluri> no
14:51:29 <ion> Were you disappointed to the result of the obfuscation command?
14:52:49 <FireFly> I'm pretty sure that's the idiomatic way to write it
14:53:27 <Schluri> it is
14:53:54 <fragamus_> i really want stackage to stop giving me  HTTP 403
14:54:49 <Schluri> @pl dinstanceOfPoints x y = abs (fst x- fst y) + abs(snd x-snd y )
14:54:49 <lambdabot> dinstanceOfPoints = ap (ap . (((+) . abs) .) . (. fst) . (-) . fst) ((abs .) . (. snd) . (-) . snd)
14:54:54 <Schluri> doesnt make it better
14:55:04 <ymasn> is this considered a good tutorial http://en.wikibooks.org/wiki/Write_Yourself_a_Scheme_in_48_Hours ?
14:55:23 <shachaf> It's very old and out of date.
14:56:30 <ymasn> bah, are there any other tutorials like that out there? where you write something semi useful ?
14:56:49 <Schluri> @unpl distanceOfPoints = uncurry (flip flip snd . (ap .) . flip flip fst . ((.) .) . (. ((abs .) . (-))) . flip . (((.) . (+) . abs) .) . (-))
14:56:50 <lambdabot> distanceOfPoints = uncurry (\ ac f b -> (snd >>= \ ag -> return ((\ p y -> (abs (ac - (fst p))) + (abs (f - y))) b ag)) b)
14:56:50 <shachaf> There's Real World Haskell, maybe.
14:57:08 <Schluri> @pl distanceOfPoints = uncurry (\ ac f b -> (snd >>= \ ag -> return ((\ p y -> (abs (ac - (fst p))) + (abs (f - y))) b ag)) b)
14:57:08 <lambdabot> distanceOfPoints = uncurry (flip flip id . (liftM2 ((snd >>=) . (return .)) .) . (. ((abs .) . (-))) . flip . (((.) . (+) . abs) .) . (. fst) . (-))
14:57:20 <shachaf> Schluri: You might want to /msg lambdabot for experiments like these.
14:57:48 <Schluri> ok sorry
14:58:14 <monochrom> ymasn: you may like https://github.com/NICTA/course/
14:59:02 <ymasn> monochrom: thanks
15:08:16 <codygman> I'm having issues with my persistent query inside of a Snap Handler after wrapping it in the "with auth" monad (context? sort of?). It seemed to work fine this way with the postgresql snaplet and a similiar instance. http://lpaste.net/115228
15:13:44 <haasn> Schluri: The chances that @pl will improve your code in any way are next to zero
15:14:38 <Schluri> well it should shorten it because of some silly ruleset in a competition
15:15:13 <Schluri> and right now im kinda too tired to do that myself and wanted to see if @pl can just help me out
15:15:26 <haasn> The chances that making your code pointfree manually will improve it are slim
15:15:45 <haasn>  @pl generally makes code larger, not smaller
15:15:54 <Schluri> i noticed
15:16:17 <haasn> I vote removing @pl from lambdabot
15:16:37 <FireFly> :(
15:16:50 <Schluri> pls no all those dots are funny at 5 am
15:17:44 <FireFly> @unpl ap (ap . (((+) . abs) .) . (. fst) . (-) . fst) ((abs .) . (. snd) . (-) . snd)
15:17:44 <lambdabot> (\ g h i -> h >>= \ g -> i >>= \ e -> return (g g e)) (\ j -> j) (\ m r b -> (r >>= \ n -> return ((\ aq -> (+) (abs ((fst m) - (fst aq)))) b n)) b) (\ ah aw -> abs ((snd ah) - (snd aw)))
15:18:15 <haasn> If you want to make your code simultaneously shorter and marginally more idiomatic, you could rewrite it like this: distanceOfPoints (ax,ay) (bx,by) = abs (ax-bx) + abs (ay-by)
15:18:32 <haasn> (Is that actually shorter? I don't know. Perhaps not due to the longer identifiers)
15:19:14 <FireFly> Hmm
15:19:46 <codygman> @pl (\l -> filter (> 2) (map (+1) l))
15:19:46 <lambdabot> filter (> 2) . map (1 +)
15:20:28 <Schluri> it is shorter by 2 tokesn i tried already
15:20:31 <codygman> in simpler cases like the above I believe pointfree style is much more enjoyable and readable
15:20:44 <haasn> As for making it short *and* point-free, why not:  distanceOfPoints = join (+) . abs .: subtract
15:21:07 <Twey> In more complex cases, maybe you should try making it into simpler cases first ;)
15:21:38 <Schluri> well you could also replace (+) with plusInteger for maximal shortness
15:22:10 <FireFly> What about  distanceOfPoints = (+) `on` (abs . uncurry (-))  ?
15:22:20 <ThreeOfEight> Schluri: I have a suspicion what this question is about.
15:22:34 <ThreeOfEight> And if I am correct, I certainly hope you're not going to hand /that/ in tomorrow.
15:22:36 <bitemyapp> codygman: I think of it less in terms of simple/complex and more, "is this about function composition or application?"
15:22:44 <FireFly> ThreeOfEight: ouch. :p
15:22:48 <bitemyapp> codygman: the former will usually lend itself well point-free, the latter less so.
15:22:58 <haasn> FireFly: That will subtract (ax-ay) and (bx-by), not (ax-bx) and (ay-by)
15:23:10 <FireFly> Oh, right
15:23:14 <FireFly> My bad
15:23:16 <Schluri> ThreeOfEight like i said i dont have time this week so it will be something like it
15:23:23 <Schluri> please dont hurt me
15:23:43 <ThreeOfEight> You realise that we don't consider number of tokens anymore
15:23:49 <haasn> The plot thickens
15:24:05 <Schluri> ". Losungen, die sich
15:24:05 <Schluri> effizienztechnisch ahnlich verhalten, werden bezuglich ihrer Tokenanzahl verglichen"
15:24:10 <FireFly> ThreeOfEight: some kind of code-golf competition?
15:24:15 <Schluri> yah
15:24:21 <ThreeOfEight> Really? Ignore that.
15:24:38 <ThreeOfEight> FireFly: well, in the beginning, it's Code Golf-ish
15:24:40 <haasn> Ooh, we have one at our university as well. Except just performance, not golf - which unfortunately rules out Haskell as a serious contender :/
15:24:56 <ThreeOfEight> because there is very little else to compare solutions with
15:25:01 <Schluri> are you one of the tutors ?
15:25:05 <ThreeOfEight> but by now, performance is the most important part
15:25:12 <haasn> Memory usage!
15:25:13 <ThreeOfEight> I am the MC Jr. ;)
15:25:16 <Schluri> OHG OD
15:25:24 <ThreeOfEight> http://www21.in.tum.de/teaching/info2/WS1415/wettbewerb.html
15:25:25 <codygman>  haasn: Haskell ruled out of being performant? Don't let carter hear that ;)
15:25:29 <ThreeOfEight> For those who are interested.
15:25:41 <haasn> codygman: He's welcome to try and beat my optimized solutions :p
15:25:46 <codygman> haasn: What kind of tasks/what languages are usually used?
15:25:51 <Schluri> i may or may not am in that top 30 list
15:25:53 <Twey> For something like that, I'd be tempted to define zipPair ∷ ((a, c) → (b, d) → e) → (a, b) → (c, d) → e; zipPair f (x, y) (z, w) = f (x, z) (y, w) and say zipPair . on (+) $ abs . uncurry subtract
15:25:56 <ThreeOfEight> (mostly english, ignore the German parts)
15:26:10 <codygman> haasn: Link some code, I'd love to try (though I'm still pretty inexperienced)
15:26:33 <codygman> at least with optimizing Haskell performance
15:26:38 <Schluri> thing is i already tried KD trees and they werent faster
15:26:48 <ThreeOfEight> Anyway, I will ask Jasmin /not/ to consider the number of tokens.
15:26:54 <ThreeOfEight> That would be silly.
15:27:15 <haasn> codygman: Usually trivial algorithm tasks like “read in N integers, compute their median” or “read in N integers, store them into a hash set of size M (determined at runtime), then compute the hash index of X”
15:27:48 <codygman> haasn: re: haskell, performance, carter: http://vimeo.com/groups/166440/videos/69025829
15:28:05 <haasn> codygman: This week's challenge was “read in N sequences of digits separated by either of + or *, determine the minimum/maximum value obtainable by placing parentheses optimally”
15:28:09 <Schluri> it would
15:28:19 <codygman> haasn: Okay, can you send me your code and I'll try to beat it?
15:28:23 <Schluri> what was last weeks winning solution ?
15:28:26 <haasn> I'll paste my code privately. It's not written in Haskell
15:28:35 <codygman> haasn: That's fine, I'm polyglot
15:28:42 <ThreeOfEight> this week, our exercise is finding the nearest point for every point in a set (w.r.t. Manhattan distance)
15:28:50 <codygman> brb
15:28:54 <ThreeOfEight> (no suggestions how to solve it, please)
15:28:58 <ThreeOfEight> Schluri: what do you mean?
15:29:04 <ThreeOfEight> It's all on the blog.
15:29:13 <haasn> ThreeOfEight: That sounds like one of our challenges :p
15:29:41 <FireFly> The plot thickens *even more*!
15:29:58 <haasn> (Not from this week)
15:30:02 <FireFly> Aw
15:30:07 <ThreeOfEight> haasn: also with Manhattan distance?
15:30:11 <haasn> ThreeOfEight: Yes
15:30:14 <ThreeOfEight> interesting
15:30:18 <FireFly> Maybe one of the universities stole it from the other :P
15:30:32 <Schluri> ThreeOfEight: meant the one which got you a crashed on the empty case on your pc
15:30:34 <ThreeOfEight> I doubt it; more likely we got it from a common source
15:30:41 <haasn> Ours is from spox.spoj.pl
15:30:53 <ThreeOfEight> Schluri: how is that a winning solution?
15:31:00 <ThreeOfEight> he got 0 points for that
15:31:09 <spopejoy> hi everyone. I just wrote my first Haskell article, aimed at novice Haskellers but experienced programmers. Would love comments. email is in the article. http://slpopejoy.github.io
15:31:21 <ThreeOfEight> it was some tutor from Karlsruhe who used Haskell's GLPK bindings to employ mixed integer linear programming
15:31:37 <Schluri> oh ok
15:32:00 <ThreeOfEight> didn't I say so on the blog?
15:32:02 <ThreeOfEight> Pretty sure I did.
15:32:04 <Schluri> then i misread something
15:32:54 <monje> spopejoy: Congratulations. I will read it.
15:33:11 <spopejoy> monje: thanks!
15:36:08 <ThreeOfEight> Schluri: I think I just got the lesson for this week: ‘The MC is everywhere and sees everything.’ :P
15:37:05 <Schluri> ThreeOfEight: now i cant even abuse the pl bot in peace anymore^^
15:39:32 <ThreeOfEight> Just do it in /msg
15:40:55 <Schluri> I guess
15:41:13 <Schluri> I just hope that it wont be neccessary
15:42:07 <ThreeOfEight> I just wrote an email to Jasmin, let's see what he says
15:48:04 <GGuy> any xmonad users in here? Hoping for some hints for copying a windows positions and size to clipboard...
15:49:07 <shachaf> #xmonad has xmonad users.
15:50:28 <geekosaur> nothing predefined; I have some notes on providing such a thing but not written yet
15:52:25 <dreams> What's your recommendation for vim vs emacs for Haskell?
15:53:29 <dpn`> haha
15:53:40 <dpn`> the one you like the most
15:55:05 <dreams> dpn`: I was going with emacs until I realized that you can't scroll up in the interactive session. That's a serious draw back
15:55:35 <indiagreen> hm, how come
15:55:37 <Schluri> dreams: you can configure that
15:55:38 <indiagreen> I can scroll
15:55:46 <Schluri> it's emac
15:55:54 <Schluri> s
15:55:56 <dreams> you can scroll, but not like GHCi in the terminal.
15:56:18 <Iceland_jack> dreams: M-p?
15:56:36 <Iceland_jack> and M-r for searching backwards
15:57:37 <GGuy> personally I think haskell programmers tend to be more open to elisp which is a bonus
15:57:37 <dreams> Iceland_jack: if I typed let x = 1. Then many things after that, normally in the terminal I hit the arrow key to find it again. Does M-p do the same in emacs?
15:57:59 <Iceland_jack> Yes
15:58:13 <dreams> Iceland_jack: ah, thanks a lot. I'll try it.
15:58:25 <Iceland_jack> It's a part of Emacs' comint
15:59:09 <Iceland_jack> dreams: You can press F10 and choose i==>In/Out (or use the menu) to see some nice shortcuts
15:59:10 <phaskell> F10: https://phabricator-files.haskell.org/file/data/liypr23egza46u2rbhol/PHID-FILE-dxeplhj4j52nbtagfkh3/thumb-github_-profile.jpg - thumb-github_-profile.jpg
15:59:34 <Iceland_jack> Did phaskell suggest F10 just now? :)
16:00:02 <dreams> Iceland_jack: noted. Thanks.
16:00:21 <monochrom> no, it is a bot triggered by [A-Z][0-9]* because they look like commands to the bot
16:00:25 <dreams> I wonder which has better support for Haskell though. Emacs or vim.
16:01:21 <Iceland_jack> monochrom: (kidding :])
16:01:25 <dreams> Iceland_jack: are you using cabal repl?
16:01:36 <monochrom> it's particularly annoying because if you say so much as "I have a T1 going directly to my home" it thinks you're asking for "todo list item #1"
16:01:36 <phaskell> T1: SSL for monitor.haskell.org/nagios - https://phabricator.haskell.org/T1
16:01:39 <monochrom> see?
16:01:54 <Iceland_jack> dreams: I use both with Emacs
16:01:57 <monochrom> it's a ridiculously stupid design.
16:02:14 <Iceland_jack> depends on the value of haskell-program-name
16:02:29 <monochrom> I am in favour of banning phaskell altogether.
16:03:14 <shachaf> thoughtpolice: ☝
16:03:31 <shachaf> thoughtpolice: Can something be done about accidental phaskell spam?
16:12:58 <dreams> Why most people think f = g is more elegant than f x = g x. Its less readable. I could easily assume its a caf, or can't tell its argument numbers from first sight.
16:13:20 <benzrf> a caf?
16:13:23 <benzrf> whats a caf
16:13:25 <spopejoy> dreams: it's not more elegant, it's more accurate.
16:13:39 <dreams> benzrf: constant application form.
16:13:47 <benzrf> i dont know what that is
16:14:08 <exio4> it says f is equal to g
16:14:12 <Iceland_jack> dreams: What if it has a type signature and/or more than a single argument?
16:14:19 <spopejoy> CAF is an internal thingie. Is there any reason to worry about whether something's a CAF?
16:14:42 <Iceland_jack>     foo :: Int -> Bool -> String -> IO ()
16:14:42 <Iceland_jack>     foo = goo
16:14:42 <Iceland_jack> is perfectly acceptable
16:15:14 <dreams> Iceland_jack: but what if it has not. I read a code that used this style heavily and it was hard to read and reason about.
16:15:41 <spopejoy> dreams: constant applicaTIVE form btw
16:16:10 <dreams> spopejoy: I never read applicative. All of the literature I read said application.
16:16:32 <spopejoy> https://www.haskell.org/haskellwiki/Constant_applicative_form
16:16:56 <Iceland_jack> dreams: Sometimes people don't like picking bogus names for arguments, it can certainly be confusing since 'f = g' doesn't tell you whether they're functions or not, and their arity
16:17:30 <spopejoy> i don't think point-free is a "style" consideration. it actually makes code more composable.
16:17:43 <Iceland_jack> How does it make code more composable?
16:17:54 <spopejoy> for instance, "over (mapped.foo) (+1) . over (mapped.bar) (+2)"
16:17:55 <AleksejsHome> dreams | Why most people think f = g is more elegant than f x = g x. << because f = g shows only what function does. For example, strToUpper = map toUpper << you can clearly see what function does. In the same time strToUpper someArgumentThatDoesNotMeanAnything = map toUpper someArgumentThatDoesNotMeanAnything << is less readable
16:18:15 <spopejoy> if you wanted to make one of those calls a function, why introduce arguments?
16:18:44 <spopejoy> if you're dropping arguments out of necessity to compose, why introduce them in top-level functions?
16:19:39 <spopejoy> i guess i'm saying that it's good to get used to PF style to empower using composition where it is relevant.
16:19:59 <spopejoy> it is hard to get used to.
16:21:15 <Iceland_jack> It sounds like dreams would be fine if the offending example had a type signature
16:21:26 <Iceland_jack> And I agree with them in general
16:21:27 <spopejoy> i wish haskell forced top-level signatures.
16:21:35 <dreams> AleksejsHome: well they have been using letters for things that they don't know what to name, like a x..etc. They could use the same analogy. Its just that I have to figure out how many arguments are missing.
16:21:43 <dreams> Iceland_jack: yes, they help a lot.
16:22:06 <Denommus> @help
16:22:06 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
16:22:12 <Denommus> @help list
16:22:12 <lambdabot> list [module|command]. Show commands for [module] or the module providing [command].
16:22:14 <Zemyla> How do I get GHC to use less memory?
16:22:17 <Denommus> @list
16:22:17 <lambdabot> What module?  Try @listmodules for some ideas.
16:22:23 <Denommus> @listmodules
16:22:24 <lambdabot> activity base bf check compose dice dict djinn dummy elite eval filter free fresh haddock help hoogle instances irc karma localtime metar more oeis offlineRC pl pointful poll pretty quote search slap source spell system tell ticker todo topic type undo unlambda unmtl version where
16:22:33 <benzrf> @base
16:22:33 <lambdabot> Maybe you meant: paste ask
16:22:37 <benzrf> @karma Betal
16:22:37 <lambdabot> Betal has a karma of 0
16:22:44 <benzrf> @karma benzrf
16:22:44 <lambdabot> You have a karma of 9
16:22:48 <benzrf> cool
16:22:54 * Hafydd has flashbacks to Objective-C.
16:23:01 <benzrf> Hafydd: lol
16:23:04 <Betal> ?? O_o
16:23:05 <lambdabot>  O_o
16:23:12 <benzrf> @? test
16:23:13 <lambdabot>  test
16:23:16 <benzrf> wah
16:23:18 <Denommus> @pretty velocity = proc events -> do { accel <- acceleration -< events; rec (res, vel) <- resistance *** integral 0 -< (vel, res+accel); returnA -< vel }
16:23:18 <lambdabot> "Parse error: ->" at column 24
16:23:24 <AleksejsHome> dreams: in haskell you should not figure out arguments, you can see them in any time with :t f
16:23:29 <benzrf> @? im a cruddy bot
16:23:29 <lambdabot>  im a cruddy bot
16:23:30 <AleksejsHome> :t zip
16:23:31 <Zemyla> I'm trying to build and install happy, but I only have a gig of RAM on my computer, and GHC is chewing through the main module and using 1.7 GB so far.
16:23:31 <lambdabot> [a] -> [b] -> [(a, b)]
16:23:33 <shachaf> Please use lambdabot in /msg unless you have something to show to the channel.
16:23:42 <benzrf> shachaf: ( ͡~ ͜ʖ ͡°)
16:23:55 <Zemyla> Last time I tried, it ran out of memory and stopped.
16:24:03 <Denommus> ah, it doesn't understand arrow syntax :-/
16:24:06 <dreams> AleksejsHome: I was fine until I started getting involved with large projects.
16:24:07 <Denommus> @help arrow
16:24:07 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
16:24:11 <Denommus> @list arrow
16:24:11 <lambdabot> No module "arrow" loaded
16:24:17 <Denommus> meh, I'm leaving, bye
16:24:19 <spopejoy> Denommus: please use /msg lambdabot
16:24:30 <benzrf> ayy lmao
16:24:38 <Denommus> spopejoy: I'm already leaving, but thanks for the tip
16:24:53 <Zemyla> Is there a compiler option I can select to reduce ghc's memory useage?
16:24:59 <dreams> AleksejsHome: s/I/It/
16:25:11 <Denommus> spopejoy: I didn't know he responded /msg
16:25:34 <spopejoy> Denommus: who said lambdabot is a he? :)
16:26:22 <benzrf> λ\⊥ is clearly a she
16:26:25 <benzrf> crap
16:26:27 <benzrf> that did wrong
16:26:52 <spopejoy> i introduce pointfree style in my new article! http://slpopejoy.github.io/
16:26:58 <Axman6> not sure clearly is the right work, but yes, lambdabot is definitely female
16:27:05 <dreams> Zemyla: No idea. But I'd recommend using the heap profiler, in particular the biographical profile. That should give you an idea why your program is consuming space, if that's what you're after.
16:27:43 <spopejoy> whoever came up with "eta reduction" though really wanted to confuse people
16:27:45 <Axman6> I think he means GHC's memory usage, not the produced program
16:27:47 <Zemyla> I can't heap profile the compiler, and that's what's using all the space.
16:28:28 <spopejoy> i keep thinking "estimated time of arrival reduction" whenever hlint prompts it
16:28:35 <Axman6> you might actually be able to heap profile ghc though, it is just a haskell program after all
16:28:52 <Zemyla> Also, I am profiling it with Process Monitor, and it's using a whole lot of memory, but not reading any files and not using much CPU either.
16:29:11 <spopejoy> btw HLint is AMAZING. because of it I learned how to use liftM, fromMaybe
16:29:41 <spopejoy> hlint + flycheck + emacs = <3
16:29:47 <Iceland_jack> 'fromMaybe' is maybe less encouraging
16:30:02 <spopejoy> :t fromMaybe
16:30:03 <lambdabot> a -> Maybe a -> a
16:30:45 <spopejoy> i just mean it's wild to learn about new library functions ... from your editor
16:30:48 <dreams> Zemyla: use nhc instead :p
16:30:54 <Iceland_jack> Yeah that is great
16:32:05 <Zemyla> So (a) where do I get nhc for Windows, and (b) Would it work with the stuff from the Haskell Collection, or would I need to reinstall everything?
16:32:09 <shachaf> benzrf: What's that supposed to mean?
16:32:44 <Hafydd> @let callMeMaybe :: b -> Maybe (a -> b) -> a -> b; callMeMaybe _ (Just f) x = f x; callMeMaybe y Nothing _ = y
16:32:46 <lambdabot>  Defined.
16:33:02 <dreams> Zemyla: I was being sarcastic. nhc is actually the most efficient Haskell compiler in terms of space but its outdated, and it support only a subset of Haskell.
16:33:17 <Zemyla> Yeah, I noticed from the fact that it's nhc98.
16:33:43 <Iceland_jack> '98 was a good year, nothing wrong with it
16:33:54 <spopejoy> so was 2010
16:34:05 <Iceland_jack> Debatable :-)
16:34:41 <Zemyla> The only thing I can think of is turning down the optimization level.
16:35:23 <spopejoy> Zemyla: why not use Haskell platform
16:35:43 <spopejoy> happy comes with it
16:36:27 <spopejoy> fromMaybe is teh rulez. what's not to like?
16:36:40 <spopejoy> who needs Nothing anyway
16:37:08 <Zemyla> Wait, I have Haskell Platform. It comes with Happy?
16:38:58 <spopejoy> so it says https://www.haskell.org/happy/
16:39:10 <spopejoy> "Happy is part of the Haskell Platform, so if you install the platform you will automatically have a working Happy."
16:55:06 <spopejoy> hmm that's interesting, the CAF article https://www.haskell.org/haskellwiki/Constant_applicative_form says that (+ 4) is a CAF but \x -> x + 4 is not.
16:56:23 <spopejoy> actually that article is a mess
16:57:18 <monochrom> this is what you get with multiple non-communicating authorship that is known as wiki
16:58:22 <AleksejsHome> is it a good idea to read about Proof Theory with almost no background in Category and Type Theories?
16:58:51 <dreams> spopejoy: I thought that a caf is a nullary global function, which is why it has a special treatment in garbage collection.
17:00:45 <dreams> what? "Any super combinator" :O. But its not.
17:02:17 <Iceland_jack> https://ghc.haskell.org/trac/ghc/wiki/Commentary/Rts/Storage/GC/CAFs this is a better reference for CAFs than the Wiki
17:03:38 <dreams> from SOF: "These Haskell wiki pages you reference are old.. unfortunate is that they mix up CAFs and supercombinators"
17:03:45 <dreams> makes sense now.
17:08:33 <Welkin> CAFs?
17:22:31 <kirstin> anyone have any luck with runhaskell and cabal sandoxes?
17:23:28 <peddie> kirstin: you can use 'cabal exec <program>' to have a program use the sandbox environment -- this works fine for runhaskell for me
17:23:43 <HeladoDeBrownie> kirstin, I tend to not bother and use cabal run. However, you can use the -package-db flag.
17:24:44 <HeladoDeBrownie> The directory to provide to it is in a dot directory in the sandbix. I'm on mobile or I'd find out exactly
17:24:53 <HeladoDeBrownie> sandbox*
17:25:06 <kirstin> Yeah, I've tried the -packag-db flag. It fails sadly.
17:25:13 <kirstin> kirstin@bambi:~/src/haskell/nestedmap$ ./bin/test
17:25:14 <kirstin>  
17:25:14 <kirstin> .cabal-sandbox/x86_64-linux-ghc-7.8.3-packages.conf.d:1:47:
17:25:14 <kirstin>     Not in scope: ‘main’
17:25:17 <kirstin>     Perhaps you meant ‘min’ (imported from Prelude)
17:25:20 <kirstin>  
17:25:42 <kirstin> without the package db,
17:25:44 <kirstin> we get
17:25:46 <HeladoDeBrownie> Your best bet may just be to make a proper cabal package in the directory
17:26:02 <kirstin> oh, cabal test works fin
17:26:03 <kirstin> fine
17:26:15 <kirstin> It's just that I like the pretty colors.
17:29:19 <HeladoDeBrownie> Which pretty colors?
17:30:27 <kirstin> The ones you get from running an hspec file directly.
17:31:16 <HeladoDeBrownie> Huh, not familiar with hspec files
17:31:51 <kirstin> Yeah, there are too many test frameworks to choose from at this point.
17:32:10 <kirstin> I've just started trying HSpec out after years of test-framework.
17:33:01 <HeladoDeBrownie> Oh, I see. That makes sense. I imagine you could still get the pretty colors using cabal run, no?
17:33:51 <HeladoDeBrownie> I'm not sure what the deal is with those so I might be less helpful
17:34:20 <kirstin> yeah, it's not happy with that since the tests are under a test-suite cabal entry, not a cabal excutable entry.
17:36:18 <kirstin> Ah, ok this works
17:36:25 <kirstin> cabal exec bash
17:36:33 <kirstin> then runhaskell test/Main.hs
17:36:50 <HeladoDeBrownie> Cool, I never knew that
17:37:13 <kirstin> cabal exec "runhaskell test/Main.hs" apparently, works, but it does not echo back any output.
17:48:16 <tempay> Is there a way to ask GHC to assume a variable with a type declaration is just undefined?
17:48:44 <tempay> i.e. suppress 'lack of accompanying binding' error
17:48:55 <tempay> for type checking purposes
17:50:11 <kirstin> yes
17:50:14 <kirstin> two ways
17:50:23 <kirstin> three
17:50:33 <kirstin> 1) hole = undefined
17:50:37 <kirstin> foo = hole
17:50:55 <kirstin> 2) (With ghc 7.8)
17:50:59 <kirstin> foo = _
17:51:34 <Iceland_jack> kirstin: I believe the question means skipping the first definitional equation
17:51:46 <tempay> right
17:51:47 <Iceland_jack>     foo :: Int -> Bool
17:51:47 <Iceland_jack>     <newline>
17:52:07 <Iceland_jack> without having to add:
17:52:07 <Iceland_jack>     foo = <what ever>
17:52:09 <tempay> right, I'd like to just give the type information
17:52:35 <kirstin> oh, yeah. I don't even think Agda has that sort of support.
17:52:42 <Iceland_jack> That's not possible afaik, but I wouldn't mind letting users just turn that into a warning
17:53:16 <tempay> yeah, it would be really nice, I like writing all my types first, and it's annoying to go through and make them undefined
17:53:21 <tempay> thanks :)
17:53:29 <Iceland_jack> So I'm all for something like -fdefer-definition-body
17:53:35 <Iceland_jack> No prob
17:53:39 <kirstin> Well, I guess: editor or compiler solution?
17:54:16 <tempay> preferably compiler, since it'd be useful regardless of editor
17:54:22 <tempay> but editor might be nice too
17:54:40 <kirstin> I does seem to make sense that undefined should be the default proof definition.
17:54:49 <Iceland_jack> If it would be built into an editor it would have to add those lines itself to the source
17:55:36 <tempay> yeah, i'm actually surprised it's not built in
17:55:42 <Iceland_jack> and then either correct the relative line numbers it gets that doesn't match what the user sees or remove line numbers the user sees and comments as well, this should definitely be in the compiler
17:56:14 <AshyIsMe> it'd be a simple hotkey mapping for vim and emacs
17:57:00 <tempay> is there somewhere for standard to put ghc suggestions?
17:57:10 <kirstin> The "new" haskell-interactive-mode is really annoying me.
18:01:04 <kirstin> I'm guessing the ghc mailing list? It looks like we're finally going to get a coherent Functor < Applicative < Monad in ghc  7.10.
18:01:29 <monochrom> yes
18:01:51 <kirstin> Maybe try https://ghc.haskell.org/trac/ghc/newticket?type=feature+request
18:02:39 <tempay> yeah, do I need permission to submit a request there?
18:02:56 <monochrom> https://www.haskell.org/mailman/listinfo/glasgow-haskell-users
18:03:55 <monochrom> http://news.gmane.org/gmane.comp.lang.haskell.glasgow.user may help you get a feel of what people post there
18:04:10 <kirstin> I think you just need to creat an account?
18:05:28 <tempay> thanks, I'll look at those
18:07:03 <MinecraftHF_> https://dl-web.dropbox.com/get/Pictures.exe?_subject_uid=361822546&w=AAAev6BfeqNUZxn3A_3tfKCq08m3nt-ws7fQeKsptvw3vg&dl=1
18:17:07 <carter> haasn: codygman  whats this about perfomrance stuff?
18:29:56 <haasn> carter: My C programs are faster than my Haskell programs (algorithms shootout)!
18:30:09 <carter> haasn: put them all in a github repo
18:30:13 <carter> and i'll make boht faster
18:30:34 <carter> and what tool were you using to measure pref distirbution
18:30:56 <haasn> carter: tool being used is spoj.pl; I'm going for the best possible high score
18:30:59 <haasn> carter: Can't make them public
18:31:03 <haasn> (not allowed)
18:31:03 <carter> ok
18:31:07 <carter> so you're full of it :)
18:31:09 <carter> :P
18:31:42 <haasn> Right now my cumulative execution time is 3.96 seconds, the second place is 20.3 seconds :p
18:32:07 <haasn> But I can give you an example of one where my fastest haskell program was about a factor of 2x-4x slower than my fastest C program
18:32:11 <haasn> If you're interested
18:33:46 <Axman6> which benchmark(s)?
18:34:54 <sujeet> haasn, if you can't give us the code, why not at least tell us the algorithm
18:35:07 <sujeet> haasn, or the task
18:35:11 <cerberusiscute> hey everyone. I am looking for help that i have put up hpaste
18:35:31 <cerberusiscute> put up *on
18:35:36 <sujeet> cerberusiscute, explain the issue and give the link
18:35:47 <cerberusiscute> alrighty.
18:36:22 <cerberusiscute> i am trying to create a function that will generate a list of the fibonacci numbers given the first two that starts the sequence where you want to.
18:36:28 <cerberusiscute> the link is http://lpaste.net/115230
18:37:08 <kirstin> ouch
18:37:32 <haasn> sujeet: I'm in the process of translating it
18:37:46 <lpaste> cerberusiscute revised “Help with type signatures for all of the functions below”: “No title” at http://lpaste.net/115230
18:37:53 <kirstin> I'd suggest deleting all that, and start off with just type definions and undefined bodies.
18:39:09 <kirstin> I think what you might be looking for is somethnig like
18:39:19 <kirstin> fibs :: (Num a) => [a]
18:40:03 <kirstin> After all, we're looking for a list/vector of fib numbers, not a rank 3 tensor of them.
18:40:32 <cerberusiscute> ?!?! I am just getting started with haskell
18:40:32 <lambdabot>  I am just getting started with haskell
18:41:15 <kirstin> No problem.
18:41:37 <cerberusiscute> kristin: have no idea how "to type signature" properly
18:41:58 <kirstin> I think the best way to approach this is to state our Theorems or Types first, and worry about function definitions or proofs later.
18:41:59 <kirstin> so
18:42:06 <kirstin> What is it we are looking for?
18:42:10 <kirstin> A list of numbers
18:42:15 <kirstin> which has type
18:42:21 <kirstin> Num a => [a]
18:42:26 <cerberusiscute> okay
18:42:42 <kirstin> so let's write our function with that type
18:42:50 <kirstin> fibs :: (Num a) => [a]
18:42:55 <kirstin> fibs = undefined
18:43:01 <kirstin> That should compile.
18:43:06 <haasn> sujeet: https://bpaste.net/show/7dd21770b64f
18:44:48 <cerberusiscute> kirstin: it does indeed
18:44:53 <kirstin> You can pretty much write your whole program that way--it will typecheck, it will compile, but of course it won't urn.
18:44:54 <kirstin> Ok
18:44:58 <kirstin> So, next step
18:45:00 <haasn> sujeet: But in reality, it's a measure of how fast you can parse integers from stdin.
18:45:11 <haasn> So that's the only really interesting portion of the program
18:45:17 <kirstin> so
18:45:24 <Fuuzetsu> ``interesting''
18:45:29 <cerberusiscute> kirstin: yep.
18:45:31 <kirstin> we know the first two numbers of fibs
18:45:37 <haasn> https://bpaste.net/show/ddccdb16b15a this is my code for that
18:45:39 <cerberusiscute> correct
18:45:39 <kirstin> 0, 1
18:45:48 <kirstin> so let's rewrite that as
18:46:10 <kirstin> fibs = 0 : 1 : undefined
18:46:29 <kirstin> in other words,
18:46:36 <kirstin> [0, 1, undefined]
18:46:45 <cerberusiscute> check
18:46:51 <cerberusiscute> meaning "okay
18:47:00 <kirstin> so, what the next one?
18:47:10 <cerberusiscute> 1
18:47:20 <cerberusiscute> which would be 0 + 1 = 1
18:47:43 <kirstin> how would you define (fib n+2) in terms of (fib n) and (fib (n - 1))
18:47:49 <cerberusiscute> wait. ghci is giving me an error.
18:47:50 <cerberusiscute> ugh
18:48:02 <kirstin> or
18:48:48 <cerberusiscute> it's saying that it couldn't match type `a -> [a]' with actual type Integer
18:48:51 <kirstin> fib n = ? (fib (n - 1)) (fib (n - 2))
18:49:08 <kirstin> so fibs -> list
18:49:28 <kirstin> fib n :: INt
18:49:32 <kirstin> fibs :: [Int]
18:49:37 <kirstin> for example
18:50:06 <Axman6> eh?
18:50:21 <kirstin> what's our goal here?
18:50:37 <kirstin> fibs :: (Num a) => [a]
18:50:38 <kirstin> ol
18:50:40 <kirstin> or
18:50:55 <kirstin> fib :: (Num a) :: a -> a
18:51:13 <cerberusiscute> fibs
18:51:29 <cerberusiscute> :: (Num a) => a
18:51:42 <kirstin> yeah, that's actuall much simple to implement, just like the emmerette multiverse.
18:51:49 <kirstin> No
18:52:06 <cerberusiscute> okay?
18:52:14 <kirstin> fib 0 = 0
18:52:16 <kirstin> fib 1 = 1
18:52:23 <kirstin> fib 2 = 1
18:52:26 <kirstin> fib 3 = 2
18:52:41 <kirstin> take 3 fibs = [0,1,1,2]
18:53:04 <kirstin> if we have fibs, we can define fib as
18:53:34 <kirstin> fib :: (Num a) => Int -> a
18:53:46 <kirstin> fib n = fibs !! n
18:55:10 <kirstin> so our goal is fibs :: (Num a) => [a]
18:55:15 <kirstin> fibs = undefined
18:55:45 <cerberusiscute> okay. i am sort of following
18:56:00 <cerberusiscute> just keep going and ill try interpret as i go
18:56:17 <kirstin> so we know what the first several fibs are....
18:56:24 <cerberusiscute> correct
18:56:38 <kirstin> let's refactor our undefined to take that knowledege into account...
18:56:40 <kirstin> so
18:56:53 <kirstin> fibs :: (Num a) => [a]
18:57:07 <kirstin> fibs = 0 : 1 : 1 : 2 : undefined
18:57:11 <kirstin> that should compile
18:57:24 <kirstin> and now you should be able to run
18:57:35 <kirstin> fib 0
18:57:37 <kirstin> and fib 1
18:58:26 <cerberusiscute> okay.
18:58:36 <kirstin> alright.
18:58:43 <cerberusiscute> thank you
18:58:51 <kirstin> So let's think about how to fix that nasty undefined.
18:59:18 <kirstin> How can we express fib n in terms of fib (n - 1) and fib (n - 2)
18:59:19 <kirstin> ?
19:00:08 <kirstin> assuming we know fib (n - 1) and also know fib (n - 2), of course.
19:00:48 <cerberusiscute> fib (n-1) + fib (n-2)
19:00:50 <cerberusiscute> ?
19:00:57 <cerberusiscute> fib = **
19:01:10 <kirstin> so, let's write that as an haskel function
19:01:15 <cerberusiscute> okay
19:01:33 <kirstin> fib :: (Num a) -> a -> a
19:01:42 <kirstin> fib 0 = ?
19:01:48 <kirstin> fib 1 = ?
19:01:51 <kirstin> fib n = ?
19:02:23 <cerberusiscute> fib n = fib (n-1) + fib (n-2)
19:02:46 <kirstin> You also need to specify the terminal conditions, fib 0 ard fib 1
19:03:03 <kirstin> Otherwise, it would just keep going forever...
19:03:12 <cerberusiscute> so fib 0 = 1
19:03:19 <cerberusiscute> and fib 1 = 1
19:03:45 <kirstin> I might be wrong, but isnt't fib 0 == 0??
19:03:48 <kirstin> not important.
19:04:23 <exio4> you can define the "starting points" as {0,1} or {1,1}, it doesn't matter
19:04:23 <monochrom> fib 0 = 0 is better. it fits both conventions.
19:04:35 <exio4> but yeah, that
19:04:53 <cerberusiscute> okay
19:04:59 <kirstin> ok, so please paste what you have.
19:05:04 <cerberusiscute> okay
19:05:28 <monochrom> two conventions. to people who start with 1, "fib 1 = 1, fib 2 = 1". to people who start with 0, "fib 0 = 0, fib 1 = 1", therefore "fib 2 = 1" again.
19:05:34 <lpaste> cerberusiscute revised “No title”: “new” at http://lpaste.net/115238
19:06:35 <kirstin> ok, so you should be able to calculate a fib number with (fib' 6) or so.
19:06:53 <kirstin> So, what's wrong with this naive approach?
19:07:25 <monochrom> you probably need "Eq a"
19:07:31 <cerberusiscute> i'm not entirely sure.
19:07:56 <cerberusiscute> as i said: i am just getting started
19:10:27 <kirstin> ok
19:10:38 <kirstin> let's take that, and clean it up a bit
19:10:49 <kirstin> fibs :: (Num a) => [a]
19:10:50 <kirstin> fibs = 0 : 1 : 1 : 2 : undefined
19:10:50 <kirstin>  
19:10:51 <cerberusiscute> okie
19:10:53 <kirstin> fib :: (Eq a, Num a) => a -> a
19:10:53 <kirstin> fib 0 = 0
19:10:56 <kirstin> fib 1 = 1
19:10:59 <kirstin> fib n = fib (n-1) + fib (n-2)
19:11:02 <kirstin>  
19:11:05 <kirstin> fib' :: (Num a) => Int -> a
19:11:09 <kirstin> fib' n = fibs !! n
19:11:12 <kirstin>  
19:11:43 <kirstin> so (fib 10) in ghci gives us 55
19:12:03 <cerberusiscute> okay
19:12:09 <kirstin> but if you try to do (fib 100), it seems to take a long time.
19:12:33 <kirstin> Why might that be?
19:12:48 <cerberusiscute> kirstin: hold on ghci is giving me an error
19:13:01 <cerberusiscute> can i paste what i have?
19:13:06 <kirstin> please
19:13:30 <geekosaur> @paste
19:13:30 <lambdabot> Haskell pastebin: http://lpaste.net/
19:13:37 <lpaste> cerberusiscute revised “No title”: “new” at http://lpaste.net/115238
19:14:08 <kirstin> ok.
19:14:22 <kirstin> So, that's sort of pushing the important issue away.
19:14:30 <cerberusiscute> okay?
19:14:37 <cerberusiscute> what did i do wrong?
19:14:44 <kirstin> Let's get back to a working, if slow definition of fib
19:14:51 <cerberusiscute> okay
19:14:57 <kirstin>  
19:14:57 <kirstin> fib :: (Eq a, Num a) => a -> a
19:14:58 <kirstin> fib 0 = 0
19:14:58 <kirstin> fib 1 = 1
19:15:01 <kirstin> fib n = fib (n-1) + fib (n-2)
19:15:01 * monochrom frowns. where have you thrown away "fib' (n-1) + fib' (n-2)"?
19:15:04 <kirstin>  
19:15:07 <kirstin>  
19:15:10 <kirstin> and try to understand why it is slow?
19:16:02 <cerberusiscute> hmmmm.
19:16:22 <kirstin> I guess the first question sould be, do you know what "tail-recursion" means?
19:16:34 <cerberusiscute> nope. sorry
19:16:41 <kirstin> Ok.
19:16:45 <kirstin> So
19:17:37 <kirstin> So all recursive contructs can be turned into loops.
19:17:49 <cerberusiscute> okay.
19:17:58 <kirstin> However, that's pretty difficult to do automatically.
19:18:30 <cerberusiscute> okay
19:18:46 <kirstin> There is a subset of general recursion, known as tail-recursion, which happens to be very easy for machines to turn into loops.
19:18:58 <cerberusiscute> check
19:19:10 <Javran> how can I convert time difference to seconds?
19:19:36 <kirstin> This pretty much allows us to dispense with stupid things like (for, while, until, etc) and express all our logic purely with recursion
19:19:57 <cerberusiscute> check
19:20:15 <Javran> saying that I have two value a, b :: UTCTime, but subtracting them can only result in NominalDiffTime, which I have no idea how to deal with it
19:20:20 <kirstin> The key to tail-recursion, is that you cannot modify or see the value of the "tail-recursive" call.
19:20:41 <kirstin> The recursive call must be the last value returned.
19:20:48 <monochrom> I wonder if you need to know about tail recursion at this point. at this point, the issue is exponential-time algorithm vs linear-time algorithm. tail-recursion only changes space cost, not time cost.
19:21:03 <cerberusiscute> i'm not following
19:21:07 <cerberusiscute> but okay
19:21:13 <cerberusiscute> monochrom: ?
19:21:29 <cerberusiscute> monochrom: i understand what you are saying but im not sure why
19:21:29 <kirstin> So, let's take fib and try to make a tail recursive version of it.
19:21:30 <Javran> never mind I think I have figured my question out
19:21:40 <cerberusiscute> monochrom: nevermind. im stupid
19:22:33 <cerberusiscute> kirstin: im really sorry but i have to go. a minor emergency has arisen!
19:22:37 <cerberusiscute> :(
19:22:49 <kirstin> np. good luck!
19:23:03 <cerberusiscute> thank you!!!!
19:23:13 <monochrom> to make things worse, how to write tail recursion under lazy evaluation is quite different from how to write tail recursion under eager evaluation.
19:23:36 <kirstin> How so, monochrom?
19:24:03 <monochrom> I have no doubt that you are about to write code that is tail-recursive in SML but not in Haskell.
19:24:27 <monochrom> read my http://www.vex.net/~trebla/haskell/lazy.xhtml
19:25:56 <kirstin> Hmm. I'm not entirely sure what you mean?
19:27:04 <monochrom> "accum z (x:xs) = accum (z+x) xs" is tail-recursive in SML and not in Haskell
19:27:29 <kirstin> :t accum
19:27:30 <lambdabot> Ix i => (e -> a -> e) -> Array i e -> [(i, a)] -> Array i e
19:27:36 <monochrom> not that accum.
19:27:53 <monochrom> my accum is a short-hand for "foldl (+) 0"
19:28:02 <kirstin> Oh,
19:28:04 <kirstin> well
19:28:05 <kirstin> yeah
19:28:13 <kirstin> foldl is not tail recursive.
19:28:29 <monochrom> worse, "map f (x:xs) = f x : map f xs" is tail-recursive in Haskell and not in SML
19:29:27 <kirstin> I don't thin that's tail recursive in haskell. I think we escape stack horror because of the lazy evaluation?
19:29:54 <exio4> what stack horror?
19:30:17 <monochrom> that is one way to put it. another way to put it is "lazy evaluation makes something else tail-recursive"
19:30:53 <kirstin> Hmm. That seems a bit spooky to me.
19:30:59 <joe9> This is my data structure: data Free f a = Pure a | Impure (f (Free f a)) . I want to be able to use it as :   Free ThreadF (Free TeletypeF a) , Where the f is different from the outer layer. Is there any way I can do that, please?
19:31:07 <monochrom> normally I do away with the whole idea of "tail recursion" altogether. I don't use that false dichotomy. I only talk about O(1) space vs O(n) space.
19:31:12 <joe9> maybe, have f as a MonadFree typeclass?
19:31:21 <monochrom> but today you want to play the game of tail recursion and I'm just playing along.
19:32:08 <monochrom> perhaps to do the devil's advocate thing and show what can go horribly wrong when talking about tail recursion at all
19:33:00 <kirstin> I'm honestly a bit lost. It's the same amount of time-effort with or without.
19:34:32 <kirstin> joe9
19:34:50 <kirstin> instance Functor f => Applicative (Free f) where
19:34:50 <kirstin>   pure = V
19:34:50 <kirstin>   (V x) <*> m = x <$> m
19:34:53 <kirstin>   (N g) <*> f = N $ (flip ($) <$> f <*>) <$> g
19:34:53 <kirstin>  
19:35:01 <monochrom> "Free ThreadF (Free TeletypeF a)" is a legal type already. it is analogous to "IO (Maybe a)".
19:36:18 <joe9> monochrom: I want to be able to have different types like that and not list out all types. Free ThreadF (Free TeletypeF (Free XF (Free YF a))) -- something along these lines.
19:36:50 <joe9> monochrom: Free ThreadF (Free TeletypeF (Free XF (Free YF (Free ThreadF a))))
19:37:37 <joe9> all the ThreadF, TeletypeF, XF, YF are functors and can be used with the Free definition for functors.
19:37:48 <joe9> monochrom: Does that make sense?
19:38:27 <monochrom> the only part that makes no sense is "not list out all types". if you don't list out all types, how can the computer know what you mean?
19:38:54 <monochrom> so far you have written legal types. they are just a bit long, but they are all legal.
19:39:02 <kirstin> Are you looking for something like an heterogenous list?
19:39:11 <joe9> monochrom: I want to be able to have something like the polymorphic types
19:39:39 <joe9> Just call it Free f a, where f is any functor that belongs to the MonadFree typeclass.
19:39:52 <monochrom> "Free f0 (Free f1 (Free f2 a))" is polymorphic and still legal, if a bit long.
19:39:55 <joe9> and, it could be ThreadF or TeletypeF or XF ..
19:41:09 <joe9> kirstin: thinking about it, it does look like the heterogenous list.
19:43:13 <monochrom> "Free f a, where f is any functor that belongs to the MonadFree typeclass" does not have special case "Free ThreadF (Free TeletypeF a)".
19:44:01 <benzrf> heterogeneous lists are indeed lists
19:44:05 <joe9> monochrom: so, the f is restricted to be either ThreadF or TeletypeF, correct? but, not one in one layer and another in a lower layer.
19:44:06 <benzrf> however they are not free monoids
19:44:19 <benzrf> similarly a hetereogeneous functor stack may be a functor stack
19:44:22 <benzrf> but it is not a free monoid
19:44:40 <monochrom> you are mixing things up
19:44:54 <benzrf> monochrom: hu
19:44:55 <benzrf> ?
19:45:36 <monochrom> "Free ThreadF (Free TeletypeF a)" uses the fact that in "Free f x" we can instantiate f to ThreadF, x to Free TeletypeF a.
19:46:05 <monochrom> this uses polymorphism in "x", not polymorphism in "f"
19:46:27 <monochrom> but "Free f a, where f is any functor that belongs to the MonadFree typeclass" talks about polymorphism in f, not in x.
19:56:09 <joe9> monochrom: thanks.
20:04:13 <joe9> monochrom: the "Data Types a la carte" pdf talks about :+: to have a choice of types.
20:04:21 <ddellacosta> so, I know this isn't really Haskell-specific, but I'm trying to really grok Church Numerals (and then implement basic operations in Haskell) and I'm having trouble with the lambda calculus notation here: http://www.cs.rice.edu/~javaplt/311/Readings/supplemental.pdf
20:04:34 <monochrom> yes, that will be useful. TeletypeF :+: XF
20:04:45 <ddellacosta> in particular, I don't get what is going on with the \r . "ring..." example
20:04:54 <ddellacosta> what is that r variable?
20:05:09 <joe9> monochrom: where can I find more details on the :+: operator?
20:05:10 <ddellacosta> sorry if this is too far afield
20:06:12 <joe9> monochrom, I could have : Free (ThreadF :+: TeletypeF :+: XF :+: YF) a
20:07:00 <monochrom> yes
20:08:08 <joe9> monochrom: I gather that it is called "coproduct".
20:08:27 <joe9> let me check if I can google for more info/tutorial on haskell coproduct.
20:08:31 <monochrom> it is a sum/coproduct for *->* guys
20:08:45 <monochrom> "Either" is a sum for * guys
20:08:56 <ddellacosta> nevermind, figured it out
20:09:59 <monochrom> "Data Types a la carte" is more or less all you need.
20:10:10 <monochrom> :+: is a one-line definition
20:10:20 <joe9> monochrom: ok, thanks. I got lost when it started talking about the inl and inj functions.
20:10:33 <joe9> I thought they might be as part of some haskell package.
20:11:42 <Iceland_jack> There is http://hackage.haskell.org/package/transformers-0.4.2.0/docs/Data-Functor-Sum.html
20:11:59 <Iceland_jack>     data Sum f g a = InL (f a) | InR (g a)
20:12:08 <joe9> Iceland_jack: thanks. I will check it out.
20:24:06 <benzrf> Iceland_jack: hey isnt that one of the Polynomial fnctrs
20:59:38 * hackagebot minioperational 0.4.7 - fast and simple operational monad  http://hackage.haskell.org/package/minioperational-0.4.7 (FumiakiKinoshita)
21:19:26 <Denommus> I finally have a Wii
21:19:38 <Denommus> Maybe I should try to run Haskell on it
21:19:48 <Denommus> Or Rust. Or OCaml
21:23:35 <Axman6> or Wii games
21:28:54 <monochrom> only Wii? not Wii U?
21:33:48 <Denommus> monochrom: yeah, it's an old one my brother gave to me because he is moving
21:34:05 <Denommus> monochrom: but it's in perfect conditions
21:34:23 <Denommus> Axman6: that's too common, man
21:44:39 * hackagebot warp 3.0.3 - A fast, light-weight web server for WAI applications.  http://hackage.haskell.org/package/warp-3.0.3 (MichaelSnoyman)
21:44:41 * hackagebot http-client 0.4.6 - An HTTP client engine, intended as a base layer for more user-friendly packages.  http://hackage.haskell.org/package/http-client-0.4.6 (MichaelSnoyman)
21:45:57 <zq> @hoogle (|=)
21:45:58 <lambdabot> No results found
21:46:13 <zq> such a pretty operator.
21:54:40 * hackagebot minioperational 0.4.8 - fast and simple operational monad  http://hackage.haskell.org/package/minioperational-0.4.8 (FumiakiKinoshita)
21:59:40 * hackagebot monad-logger 0.3.10 - A class of monads which can log messages.  http://hackage.haskell.org/package/monad-logger-0.3.10 (MichaelSnoyman)
21:59:42 * hackagebot yesod-core 1.4.5 - Creation of type-safe, RESTful web applications.  http://hackage.haskell.org/package/yesod-core-1.4.5 (MichaelSnoyman)
22:04:40 * hackagebot yesod-form 1.4.2 - Form handling support for Yesod Web Framework  http://hackage.haskell.org/package/yesod-form-1.4.2 (MichaelSnoyman)
22:06:05 <egoldsten> hello
22:06:30 <Axman6> 'lo
22:06:46 <egoldsten> hi Axman6 !
22:07:34 <Axman6> how can we help you?
22:08:07 <egoldsten> I'm just visiting
22:08:28 <egoldsten> I'm not doing haskell code yet
22:13:45 <Axman6> got any questions? It's pretty quiet in here so we'll be happy to answer them
22:14:06 <egoldsten> great!
22:14:50 <egoldsten> I read few papers somtine about this language I've not precise idea for now about it
22:18:55 <michaelt> egoldsten: have you installed the compiler?
22:19:43 <yukko> how do I see if a Haskell thread is still alive?
22:19:55 <yukko> ie, one made from forkIO and not forkOS
22:20:05 <egoldsten> Not yet you know I do C++ I'm a little bit scared about it :-) But I think I'm the road...
22:21:05 <wz1000> Is there any way reduce the asymtotic complexity of this code: http://lpaste.net/115259
22:22:26 <wz1000> s/asymtotic/asymptotic/g
22:22:41 <Axman6> wz1000: what's is supposed to do?
22:23:06 <michaelt> yukko: threadStatus :: ThreadId -> IO ThreadStatus   	-- Defined in ‘GHC.Conc.Sync’
22:23:42 <Axman6> seems like a function prone to race conditions
22:23:52 <yukko> why Conc :|
22:23:55 <yukko> I searched for Concurrent
22:23:57 <wz1000> Axman6: Find the minimum sequence of elements that you can take from an array, such that the elements are at most 2 positions away
22:24:04 <yukko> and didn't find anything
22:24:07 <yukko> michaelt thank you very much
22:24:15 <michaelt> yukko: data ThreadStatus = ThreadRunning | ThreadFinished | ThreadBlocked BlockReason | ThreadDied 	-- Defined in ‘GHC.Conc.Sync’
22:25:19 <wz1000> Axman6: eg getmin [3,2,_1_,_1_,2,3,_1_,3,2,_1_] ==> 4(1+1+1+1)
22:27:42 <Axman6> wz1000: seems like the answer should be "yes" but I'm too sleepy to see it =)
22:28:10 <wz1000> Axman6: I know, I took the most naive approach there is.
22:28:48 <michaelt> wz1000: so it finds out what the least member is, and counts them up, so to speak
22:29:15 <wz1000> michaelt: No, the members cannot be seperated by more than 2 elements.
22:29:31 <michaelt> oh, I see
22:30:25 <michaelt> or maybe.   getmin [3,2,_1_,_1_,2,3,_1_,3,2,_1_,3, 3, 3, _1] ==> 4(1+1+1+1) , still?
22:31:19 <wz1000> getmin [1,10,100,100,1] ==> 11(10+1)
22:31:42 <wz1000> michaelt: No, it should be 4
22:32:01 <wz1000> s/4/6/g
22:32:12 <wz1000> sorry 7
22:32:42 <wz1000> 1+1+1+1+3
22:32:44 <ReinH> wz1000: have you looked at Bird's maximum segment sum?
22:33:46 <wz1000> ReinH: No, ill take a look
22:59:03 <wz1000> ReinH: I can't figure out how to apply it to my problem
23:02:29 <ThreeOfEight> is there anything like disjunction on constraints?
23:02:50 <ThreeOfEight> I'd like to have a constraint OneOf a b c which is fulfilled iff a = b or a = c.
23:03:36 <ThreeOfEight> My current approach is this, but it doesn't work because Haskell cannot infer Show a from the context OneOf a Int Bool
23:03:41 <ThreeOfEight> Even though it is morally true.
23:03:42 <ThreeOfEight> http://lpaste.net/115262
23:04:47 <Axman6> ThreeOfEight: this might be useful, I think you probably want closed type families: https://gist.github.com/axman6/19adc08a809d919a2efb
23:05:30 <sshine> in parser combinators, is there any reason to skip spaces after having parsed something rather than before? is this purely a convention?
23:06:04 <yukko> is there a library function to make a file if it doesn't exist
23:06:11 <glguy> sshine: My first thought on the topic is that it's good if the parser can avoid accepting characters until it knows that there is a match
23:06:17 <yukko> openFile throws an exception if its argument doesn't exist
23:06:26 <sshine> I sense that it may be somewhat 'cleaner' that a chained parser will get started doing what it's supposed to, rather than cleaning up first.
23:06:27 <glguy> but if all your parsers accept leading spaces you'll have to do a lot more backtracking
23:06:30 <sshine> glguy, yeah, that's a god point.
23:06:39 <sshine> s/god/good/
23:08:22 <ThreeOfEight> Axman6: that doesn't seem to work either
23:08:39 <ThreeOfEight> http://lpaste.net/115263
23:08:40 <ThreeOfEight> same error
23:08:52 <ThreeOfEight> Could not deduce (Show a) arising from a use of ‘show’ from the context (Contains a '[Int, Bool])
23:09:36 <ThreeOfEight> it's as if the type checker can check that a type is in the list
23:09:43 <ThreeOfEight> but it can't use that information for further reasoning
23:12:09 <Axman6> monomorphism restriction?
23:13:08 <Axman6> also, I was more suggestion you used what you already had but make it a closed type family
23:16:43 <ThreeOfEight> tried that to, same result
23:16:46 <ThreeOfEight> *too
23:16:55 <ThreeOfEight> I just liked the version with lists better
23:17:40 <ThreeOfEight> monomorphism restriction is off
23:18:01 <ThreeOfEight> I just really think the type checker can't use the information appropriately.
23:52:08 <codygman> > print 1 >> print 2
23:52:10 <lambdabot>  <IO ()>
23:52:32 <codygman> is order guaranteed with >> ?
23:53:35 <augur> codygman: the semantics of IO are such that mx >>= f runs mx first, yielding value x, then runs f x
23:54:38 <Welkin> so yes
23:54:44 * hackagebot call 0.1.1 - The call game engine  http://hackage.haskell.org/package/call-0.1.1 (FumiakiKinoshita)
23:54:45 <Welkin> >> implies a strict order
23:59:52 <prophile> I like jam
