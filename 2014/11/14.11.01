00:08:42 * hackagebot barcodes-code128 0.1.0 - Generate Code 128 barcodes as PDFs  http://hackage.haskell.org/package/barcodes-code128-0.1.0 (dchristiansen)
00:08:42 * hackagebot filestore 0.6.0.4 - Interface for versioning file stores.  http://hackage.haskell.org/package/filestore-0.6.0.4 (JohnMacFarlane)
00:28:39 * hackagebot hails 0.11.2.0 - Multi-app web platform framework  http://hackage.haskell.org/package/hails-0.11.2.0 (DeianStefan)
00:58:07 <hager> what is the difference between isPrefixOf and `isPrefixOf`  ?? after adding ( ` ) operator
01:00:02 <carter> infix notation
01:00:12 <carter> >  (+1) `fmap` [1,2]
01:00:14 <lambdabot>  [2,3]
01:08:30 <pjdelport> hager: f x y == x `f` y
01:09:07 <pjdelport> hager: You can think of () for operators as doing the reverse, so a + b == (+) a b
01:10:40 <hager> pjdelport:  got it, thank you :)
02:31:07 <insitu> hager: it turns a binary function into an infix binary operator
02:33:52 * hackagebot hspec 1.12.2 - A Testing Framework for Haskell  http://hackage.haskell.org/package/hspec-1.12.2 (SimonHengel)
02:33:55 * hackagebot hspec-meta 1.12.2 - A version of Hspec which is used to test Hspec itself  http://hackage.haskell.org/package/hspec-meta-1.12.2 (SimonHengel)
02:40:23 <trap_exit> I need a word, which describes "deer in headlight" ... like you're lookinga at a big spaghetti non-ahskell code, and you freeze
02:40:24 <trap_exit> what's that word
02:42:38 <tv1> trap_exit: paralysis?
02:43:45 <trap_exit> exacrly
02:43:47 <trap_exit> bing bing bing
02:44:12 <trap_exit> do scores <- state__get; state__put $ map.alter scores tv1 (+1)
03:01:29 <jonass> what is the haskell shorthand of false? i want to do like filter (\xy -> !inBounds xy b)
03:03:12 <narendraj9> > not
03:03:14 <lambdabot>  <Bool -> Bool>
03:03:45 <jonass> ok thanks :D
03:03:46 <narendraj9> > not True
03:03:48 <lambdabot>  False
03:04:19 <jonass> > not not True
03:04:20 <lambdabot>  Couldn't match expected type ‚ÄòGHC.Types.Bool -> t‚Äô
03:04:21 <lambdabot>              with actual type ‚ÄòGHC.Types.Bool‚ÄôCouldn't match expected type ‚ÄòG...
03:04:21 <lambdabot>              with actual type ‚ÄòGHC.Types.Bool -> GHC.Types.Bool‚Äô
03:04:31 <jonass> > not $ not True
03:04:32 <lambdabot>  True
03:04:38 <jonass> hehe cool bot
03:12:19 <trap_exit> not $ not
03:12:24 <trap_exit> > not $ not
03:12:26 <lambdabot>  Couldn't match expected type ‚ÄòGHC.Types.Bool‚Äô
03:12:26 <lambdabot>              with actual type ‚ÄòGHC.Types.Bool -> GHC.Types.Bool‚Äô
03:13:53 <trap_exit> on a scale of 0 to 10
03:45:23 <jonass> > cycle 5
03:45:25 <lambdabot>  No instance for (GHC.Show.Show a0)
03:45:25 <lambdabot>    arising from a use of ‚ÄòM15702841589996667805912.show_M15702841589996667805...
03:45:25 <lambdabot>  The type variable ‚Äòa0‚Äô is ambiguous
03:45:25 <lambdabot>  Note: there are several potential instances:
03:45:25 <lambdabot>    instance [safe] GHC.Show.Show
03:45:30 <jonass> > cycle "5"
03:45:32 <lambdabot>  "555555555555555555555555555555555555555555555555555555555555555555555555555...
03:46:47 <aristid> jonass: you can query lambdabot btw :)
03:49:51 <jonass> ok sorry hehe :p
03:50:07 <statusfailed> What's the signed equivalent of Word32 ?
03:50:14 <statusfailed> is it ... Int?
03:50:39 <statusfailed> oh, Int32
03:51:47 <aristid> Data.Word & Data.Int :)
03:52:01 <aristid> unfortunately there's no unsigned equivalent for Integer:D
03:52:15 <Adeon> there is Natural but it's not in base
03:52:58 <statusfailed> that's ok, I just need to output signed 32 bit ints :)
04:19:51 <edlinde> is it possible to write an algaebraic solver in Haskell?
04:19:51 <edlinde> one that can solve linear equations
04:19:52 <edlinde> just simplifying expressions
04:19:57 <edlinde> and solving for x etc
04:21:01 <lpsmith> edlinde, yes
04:21:26 <edlinde> lpsmith: is there a package?
04:21:45 <Johannes13> I can write map (+1) [1..5]
04:21:54 <lpsmith> You could use a linear algebra package if you care only about linear equations
04:22:00 <Johannes13> but how could I write map (-5) [1..5]?
04:22:01 <lpsmith> there's hmatrix
04:22:29 <lpsmith> though i've never used it,  and I know a couple people that are less than satisfied with it
04:22:46 <edlinde> lpsmith: so it doesn‚Äôt work at times?
04:22:47 <lpsmith> ekmett has something too,  I think
04:22:57 <Zyxoas> Johannes13 : you need to use the subtract function.
04:23:07 <lpsmith> I think the issue has more to do with the interface
04:23:13 <edlinde> wondering how easy or hard it is to solve things like:   2x + 4 = 9
04:23:13 <Johannes13> meh.
04:23:17 <edlinde> simple stuff like that
04:23:28 <Johannes13> haskell is very concise. But not for (-)
04:23:33 <lpsmith> edlinde,  what are you looking for, exactly?
04:24:14 <lpsmith> I mean,  you do realize that gaussian elimination on matrices solves systems of linear equations?
04:24:22 <edlinde> lpsmith: well I saw this app that claimed to solve simple algebra.. like the one I posted.. but it didn‚Äôt really work
04:24:34 <prinsen> In some code, I recall seeing a line with just 'type Typ', referring to it as an abstract type. What does this mean?
04:24:44 <edlinde> lpsmith: yeah but here there is just one equation and one unknown
04:24:52 <edlinde> do you really need to do a gaussian elimination?
04:25:31 <Zyxoas> Johannes13 : the issue is that - is trying to do two entirely different things. one is subtraction, the other is negation. A lot of people aren't happy that Haskell uses - for negation and would rather prefer if you used the `negate` function always.
04:25:57 <lpsmith> well,  no,  because one equation in one unknown would typically require enough pre-processing to get it into a form that's amenable to gaussian elimination that there isn't much point at that stage
04:25:59 <lpsmith> ok
04:26:00 <Johannes13> why not a different operator?
04:26:23 <edlinde> yeah
04:26:27 <lpsmith> so are you looking for something that lists out possible steps inbetween, or just shows you the answer?
04:26:38 <edlinde> possible steps would be cool
04:26:46 <sivteck> > map ((-) 5) [1..5]
04:26:48 <lambdabot>  [4,3,2,1,0]
04:26:59 <edlinde> this app called Photo Math or something claimed to do it.. I tested it and it sucked :)
04:27:00 <sivteck> > map (flip (-) 5) [1..5]
04:27:02 <lambdabot>  [-4,-3,-2,-1,0]
04:27:30 <edlinde> I remember I had written an expression evaluator in Haskell.. was fun
04:27:37 <Zyxoas> That's right, sivteck. Hacky, but it works too.
04:27:42 <lpsmith> edlinde, I don't know of a package for that per se,  but it should be pretty simple to write one yourself...
04:27:44 <Johannes13> > let grains = (/2) . (2**) in grains 64 - 1
04:27:45 <edlinde> wasn‚Äôt sure if there is already a good solver in Haskell
04:27:46 <lambdabot>  9.223372036854776e18
04:28:04 <lpsmith> if all you care about is a single linear equation in one unknown
04:28:04 <edlinde> lpsmith: yeah I was thinking about it too .. but wondering where to start
04:28:15 <edlinde> yep
04:28:26 <Johannes13> I love point free style.
04:28:38 <edlinde> I mean for a system of linear equations there is always the guassian elimination
04:28:58 <lpsmith> Well,  data Exp = Const Rational | X | Add Exp Exp | Mult Exp Exp    looks like a pretty minimal start
04:29:00 <edlinde> for a single linear you first have to find a way to simplify the expression
04:29:41 <lpsmith> start by writing out an ADT for your expressions,  keep it simple at first,  then write a solve function
04:29:49 <Johannes13> btw, I recently thought about the following scenario: I want to read some Information from the user and construct some data, e.g. Person.
04:30:00 <edlinde> interesting that its not been done yet
04:30:04 <edlinde> :)
04:30:09 <edlinde> maybe its too easy
04:30:15 <lpsmith> it probably has been, but I'm not aware of anything on hackage
04:30:18 <edlinde> might not be worth solving
04:30:38 <lpsmith> well, there is docon,  but I've not really used it,  for symbolic maths
04:30:47 <lpsmith> It may have bitrotted
04:31:07 <Johannes13> but if the user enters some stupid stuff (that does not validate), I want to abort with an error message. So I decided that I use Either String.
04:31:16 <edlinde> ok
04:31:26 <Zyxoas> Sounds good so far...
04:31:36 <Johannes13> So the type of my "function" is IO (Either String Person)
04:32:02 <Zyxoas> That's the function for getting the name? Yes.
04:32:25 <lpsmith> I dunno if anybody else has a fairly generic symbolic CAS that could do what you want.
04:32:35 <Johannes13> after each input I have to branch if the input was valid or not. Usually I'd use Monads for that, but I already use the IO Monad
04:33:05 <Zyxoas> You use monads to branch? üò±
04:33:24 <bbg889> hello. what is the name of this standard function? foo lst = [x | x <- [0 .. pred (length lst)]]
04:33:55 <lpsmith> edlinde, you could make the exercise more interesting maybe by trying to find a number of different solutions...
04:34:05 <Johannes13> well, ask for the name of the person, validate it (e.g. not too long), ask for the zip code (validate it), and if 1 validation fails, don't ask useless questions
04:34:33 <edlinde> lpsmith: what do you mean by finding a number of different solutions?
04:34:43 <edlinde> are you talking about complex solutions?
04:34:44 <Zyxoas> bbg889 : That looks bizarre, but it is possible to do with a zip.
04:35:22 <Zyxoas> Johannes13 : sounds like something a simple case statement can do, no?
04:36:15 <Johannes13> I'll write some example code...
04:37:16 <lpsmith> edlinde, I don't know exactly,  just don't stop after you have the first solution.   Try to find a different solver,  in algorithmic terms.   Try to express the same algorithm differently,  e.g. using generics and traversables or whatever.    Sometimes finding a good means of expression can suggest other algorithms,  and analyzing enough algorithms can sometimes suggest a means of expression.
04:37:58 <edlinde> ok will see how it goes
04:39:35 <lpsmith> edlinde, for simple algebraic stuff,  I've thought about trying to do something that shows one or preferably more step-by-step solutions
04:39:48 <lpsmith> I did teach some remedial math at a community college once.
04:40:01 <lpsmith> That inspired that line of thought
04:40:05 <edlinde> cool
04:40:16 <edlinde> then maybe we should get together and build this thing?
04:40:19 <edlinde> what say you?
04:40:34 <edlinde> I ofcourse cannot work on this thing full time.. but it would be useful
04:40:42 <lpsmith> ehh,  I haven't taught math in a long time,  and I have enough side projects as it is.
04:40:45 <edlinde> I just am not sure about how to make it more
04:40:57 <edlinde> ‚Äò‚Äúeducational‚Äù than ‚Äúcheating"
04:41:15 <edlinde> yeah me too.. :)
04:41:33 <lpsmith> But maybe you should find a solution or two and then put it up as a gist and then ping the channel and/or /r/haskell
04:41:48 <edlinde> ok
04:42:30 <lpsmith> edlinde,  well my idea was to use it to generate detailed answers for worksheets
04:42:49 <edlinde> is it easy to do that?
04:43:10 <lpsmith> I dunno,  I think I spent maybe 30 minutes actually trying to code something up
04:43:19 <edlinde> :) ok
04:43:35 <lpsmith> didn't get that far,  but I think I was aiming higher than a simple linear equation
04:44:42 <lpsmith> I ended up spending far more time on some materials to teach D4, the symmetry group of the square
04:44:43 <phaskell> D4: Add support for faster copies via Intel Extended REP-MOVSB - https://phabricator.haskell.org/D4
04:45:14 <lpsmith> odd... :)
04:46:07 <lpsmith> Under the guess that teaching D4 could be useful for getting a grasp on what an algebraic law is,  and the difference between associativity and commutativity
04:46:45 <lpsmith> unfortunately,  I didn't get anything usable before I moved on to something else.
04:51:46 <isocliff_> Can someone help me understand what I'm not getting about the State monad? http://lpaste.net/6273424606304927744
04:51:58 <isocliff_> @type execState
04:51:59 <lambdabot> State s a -> s -> s
04:52:45 <isocliff_> And yet, ghc doesn't seem to accept my simple example that should be consistent with this type signature
04:55:12 <ion> isocliff: The type signature of scribs claims it is a function from Int to Int.
04:56:35 <isocliff_> ion, and execState says it wants a State s a {-State Int String-} -> Int -> {- and it returns an -} Int
04:57:25 <isocliff_> Ive also tried compiling the same function with type Int -> String
04:57:29 <ion> execState :: State Int String -> Int -> Int
04:57:29 <isocliff_> also doesn't work
04:57:33 <ion> execState scribble :: Int -> Int
04:57:37 <ion> execState scribble 2 :: Int
04:57:55 <isocliff_> right, that seems perfectly logical to me
04:58:00 <isocliff_> so why doesn't ghc accept it?
04:58:03 <ion> What is the type of scribs?
04:58:06 <jonass> i want to become a haskell boss hehe but i still need to learn alot ^^
04:58:29 <isocliff_> oh yeah, right
04:59:14 <isocliff_> thanks :) whoops
05:00:13 <isocliff_> So one more general question
05:00:25 <isocliff_> Also typeclassopedia says that "Something of type State s a represents a stateful computation which produces an a but can access and modify the state of type s along the way."
05:00:57 <isocliff_> So whats the function that takes a (State Int String) and returns a String?
05:01:16 <benzrf> isocliff_: runState
05:01:23 <benzrf> but you also need to give it an Int so that it has a state to start with
05:01:26 <benzrf> :t runState
05:01:27 <lambdabot> State s a -> s -> (a, s)
05:01:39 <isocliff_> right, right
05:01:50 <isocliff_> alright awesome, big help, thanks
05:02:11 <lpaste> Johannes13 pasted ‚Äú2 Monads in 1?‚Äù at http://lpaste.net/113571
05:03:48 <Johannes13> I hope I demonstraded my point with that. If I use the (Either String) Monad, I can write short and simple code.
05:04:24 <Johannes13> but I also need the IO monad to do interaction.
05:04:31 <exio4> Johannes13: did you take a look at monad transformers? I think they're what you want
05:04:40 <Johannes13> exio4, no, not yet.
05:05:14 <Johannes13> ok, I'll google a bit.
05:05:31 <benzrf> Johannes13: looks lke youve independently discovered the motivation for them :-)
05:05:48 <Johannes13> that's good, I suppose.
05:05:56 <isocliff_> johannes13, I recently found this tutorial on them to be pretty good: http://www.cs.virginia.edu/~wh5a/personal/Transformers.pdf
05:06:10 <Johannes13> "With monads providing such useful general-purpose functionalities, we might like to use the capabilities of several monads at once. For instance, a function could use both I/O and Maybe exception handling. A type like IO (Maybe a) could work, but that forces us to do pattern matching within the do blocks to extract values, and monads are supposed to work without that."
05:06:29 <Johannes13> ehhm, yes, that looks exactly what I was looking for.
05:21:59 <jonass> can sombody help me with random numbers because i still don't get it, i made a lpaste to demonstrate what i want
05:22:00 <jonass> http://lpaste.net/4221585834127654912
05:24:41 <adamse> jonass: so random numbers using System.Random requires a generator to generate random numbers
05:25:25 <adamse> to get a generator you either need to be in IO and use get/newStdGen or use randomIO
05:25:40 <adamse> or pass the generator as an argument to your function
05:26:20 <jonass> i guess i need to use mkStdGen Seed, because i have a seed that i need to use, but than i'm stuck
05:27:46 <jonass> hmm wait a second
05:32:58 <adamse> i updated your paste with some code
05:39:08 <makalu> does anyone know of a good paper about linear types? Preferably less theoretical (I don't want to read that book about linear logic :).
05:40:18 <jonass> thanks @adamse, i'm trying to keep it simple right now, just make a list of random tuples, but the randomR doesnt seem to work, any ideas? http://lpaste.net/1145414739292061696
05:50:00 <benzrf> makalu: ) you dropped this
05:51:32 <jonass> nvm got id :p
05:51:33 <jonass> it
06:21:43 <prinsen> Is there a version of >> that evaluates both actions and returns the value of the first?
06:22:20 <exio4> prinsen: <*?
06:22:24 <sipa> flip (>>)
06:22:30 <sipa> :t flip (>>)
06:22:31 <lambdabot> Monad m => m b -> m a -> m b
06:22:40 <sipa> :t (<*)
06:22:42 <lambdabot> Applicative f => f a -> f b -> f a
06:22:55 <ClaudiusMaximus> depends which order you want to evaluate the actions in
06:22:56 <exio4> flip (>>) doesn't run them in the "right" order
06:23:09 <exio4> (if he wants the same order as the actual >>)
06:23:18 <sipa> right
06:23:57 <sipa> :t (\a b -> a >>= \x -> (b >> return a))
06:23:58 <lambdabot> Monad m => m a -> m a1 -> m (m a)
06:24:06 <sipa> :t (\a b -> a >>= \x -> (b >> return x))
06:24:07 <lambdabot> Monad m => m b -> m a -> m b
06:24:12 <sipa> @pl (\a b -> a >>= \x -> (b >> return x))
06:24:13 <lambdabot> (. ((. return) . (>>))) . (>>=)
06:24:17 * hackagebot hsc3-server 0.9.1 - SuperCollider server resource management and synchronization.  http://hackage.haskell.org/package/hsc3-server-0.9.1 (StefanKersten)
06:24:25 <chrisdone> @quote stereo
06:24:25 <lambdabot> geheimdienst says: data Stereoloid = BanachTyvski | CoBanachTyvski
06:24:34 <prinsen> thanks all, <* works
06:24:45 <Tokenizer> hi, how do I define a data type with a single type variable ‚Äúfoo‚Äù, and a value constructor with single parameter which is a list of  ‚Äúfoo‚Äù  ‚Äî> my attempt is this ‚Äî> data Token foo = Token [foo]
06:25:27 <sipa> looks right
06:28:08 <AleksejsHome> Hi, does lambdabot have something like @pl . @undo ?
06:29:11 <chrisdone> there some arcane compose syntax
06:29:17 * hackagebot osdkeys 0.0 - Show keys pressed with an on-screen display (Linux only)  http://hackage.haskell.org/package/osdkeys-0.0 (ChrisDone)
06:29:34 <hexagoxel> @@ @pl @undo do {a<-b; return a}
06:29:34 <lambdabot>  b
06:29:40 <hexagoxel> AleksejsHome: ^
06:30:02 <chrisdone> ah, i typed out "@@ @pl @undo a" but wasn't sure it was valid
06:30:07 <chrisdone> go me
06:34:18 * hackagebot hsc3-server 0.9.2 - SuperCollider server resource management and synchronization.  http://hackage.haskell.org/package/hsc3-server-0.9.2 (StefanKersten)
06:34:57 <AleksejsHome> hexagoxel: thanks!
06:36:42 <Tokenizer> hi, i‚Äôm trying to understand how create a set using an array notation, when i start with the above code, I get the error (below the dashed lines in GHCHI) .. http://pastie.org/private/1hqqflseq7xfdvrkrlhuw
06:39:20 <RabbitHS> Can anyone figure out why the following code doesn't compile? http://ideone.com/6szDc8
06:43:49 <indiagreen> RabbitHS: don't use tabs.
06:44:15 <indiagreen> or if you do use tabs, never use them for alignment.
06:45:11 <Thooms> Tokenizer: add deriving Show after the declaration of Set
06:45:23 <Thooms> data Set a = Set [a] deriving Show
06:45:37 <Tokenizer> Thanks Thooms
06:45:45 <Thooms> np
06:45:48 <Tokenizer> trying to implement my own show now
06:45:57 <Tokenizer> so it‚Äôs doesn‚Äôt jsut print whatever
06:46:11 <Tokenizer> how can I do something like this
06:46:19 <RabbitHS> indiagreen: I've tried with spaces instead of tabs and I get the same error http://paste.kde.org/pz7hr0eyi
06:46:44 <RabbitHS> indiagreen: how to use the layout rule then in this example?
06:46:49 <indiagreen> RabbitHS: seems like a different error to me
06:47:05 <RabbitHS> indiagreen: that's the error ghci gives, the one on ideone is from ghc
06:47:17 <zwer> RabbitHS remove ::Int (put it at the end of line if haskell can't figure out the type by itself). also put everything in parenthesis after putStrLn or use $
06:47:43 <Tokenizer> http://pastie.org/private/vjox1e5cyrw7mbyhdx5fa
06:47:54 <RabbitHS> indiagreen: I've changed the code on ideone to use spaces also, refresh the page
06:48:17 <Thooms> Tokenizer: show x is supposed to return a String
06:48:52 <indiagreen> RabbitHS: http://lpaste.net/113577
06:48:59 <Thooms> so "{" ++ "Foo" ++ concatMap show ++ "}" should work
06:49:29 <Thooms> (don't forget to add the Show constraint on a)
06:49:42 <exio4> :t concatMap show
06:49:43 <lambdabot> Show a => [a] -> [Char]
06:50:21 <RabbitHS> indiagreen:  zwer  Thank you!
06:50:41 <Tokenizer> Thooms: tried this ‚Ä¶ let me remove Foo and put the right Keyword, ‚ÄúSet‚Äù ‚Ä¶. http://pastie.org/private/kvmj2u9efyeqlvdxk41l5w
06:50:47 <indiagreen> RabbitHS: the tabs variant was wrong not because GHC hates tabs or something, but simply because the ‚Äúinput <- getLine‚Äù line was indented with ‚Äúdice = do‚Äù, and the rest of the lines were indented with tabs
06:52:01 <Thooms> exio4 is right Tokenizer, that would certainly be something like show Set l = "{" ++ (concatMap show l) ++ "}"
06:52:54 <Tokenizer> Thooms: but it gives error‚Ä¶
06:53:24 <Tokenizer> http://pastie.org/9689557
06:55:00 <Thooms> Tokenizer: one moment
06:56:04 <ClaudiusMaximus> Tokenizer: show (Set a) = ...
06:56:52 <Tokenizer> Same
06:57:10 <Thooms> instance Show a => Show (Set a) where show (Set l) = "{" ++ (concatMap show l) ++ "}"
06:57:13 <Thooms> Tokenizer: ^
06:57:42 <ClaudiusMaximus> Tokenizer: oh woops, i fixed a different bug (didn't read the error message properly)
06:58:15 <Tokenizer> Thooms: works
06:58:46 <Thooms> k
06:59:25 <Tokenizer> may i just try to read this and see if i get this right? so thi sis Show of type a (whose a‚Äôs are themselves Set‚Äôs of type a (different a) ‚Ä¶ is defined as ?
06:59:47 <Tokenizer> basically can‚Äôt read that out in my head
06:59:56 <Gurkenglas> I told fpcomplete to print an infinite list and it wont terminate. Halp
07:00:02 <Thooms> that's the other way around Tokenizer
07:00:23 <Thooms> you're defining how to "show" a Set a (where a is itself showable)
07:00:43 <Thooms> (Show a => ... is a constraint on a, which is the type parameter of your Set type)
07:02:39 <Thooms> perhaps someone can correct me on that, but you can think of all that as a kind of interfacing (like in Java)
07:03:02 <Tokenizer> thanks‚Ä¶. also the ‚Äú=>‚Äù vs ‚Äú->‚Äù ‚Ä¶. For instance what does the following mean? ‚Ä¶‚Ä¶. intersection :: Eq a => Set a -> Set a -> Set a
07:04:08 <Thooms> "Eq a =>" is a constraint on the rest of the expression
07:04:20 <Tokenizer> Thooms: what you said is more like generics (or writing a method that takes a type or any types that extend it) ‚Ä¶ yes i get it
07:05:02 <Thooms> and "Set a -> Set a -> Set a" is a function taking to sets in parameters, and returning one (juste like the -> notation in mathematics)
07:06:49 <Thooms> (you may be interested in reading about curryfication Tokenizer)
07:12:51 <DrSkyLizard> Does anyone know why youtube-dl doesn't delete the .mp4 files after they are converted to the audio format I want?
07:13:07 <DrSkyLizard> It should do this by default, I have the latest version available on the website
07:14:27 <DrSkyLizard> unless -k, --keep-video                 keeps the video file on disk after the post-processing; the video is erased by default
07:14:31 <DrSkyLizard> which I don't use
07:14:46 <DrSkyLizard> sorry, wrong channel
07:22:03 <Tokenizer> putting the whole thing together (the previous discussion about sets), I tried to write the following intersect function‚Ä¶ Getting this error: http://pastie.org/private/pbn2wjlos83ie5tebsqwq
07:23:52 <ClaudiusMaximus> Tokenizer: your type annotation is wrong  setIntersectHelper :: ((Set a) -> (Set a) -> Bool) -> Set a -> Set a -> Set a
07:24:26 <ClaudiusMaximus> Tokenizer: try leaving it off and seeing what type is inferred
07:26:07 <Tokenizer> ClaudiusMaximus: thanks changed to this: http://pastie.org/private/tkdvvetdwrszpcod91gw  <‚Äî works
07:26:32 <ion> Do i know a James Fratelli from here? He emailed me about Haskell but i don‚Äôt recognize the name.
07:27:12 <joe9> johnw: you around?
07:27:47 <happy0> 'loes. so i have a libray on hackage that i doubt anyone would be interested in. yet it allegedly has 79 downloads. what might be the source of these downloads? :P are there mirror sites or something?
07:28:09 <Thooms> ion: same here
07:28:18 <Thooms> dunno any James Fratelli
07:28:31 <joe9> Does anyone have any secrets to ease the writing of a data definition? I have a tree like data structure that I am struggling to get compiled. Just want to check when you are about to code a complicated data structure, are there any rules to make it easy?
07:29:38 <Thooms> joe9: that often comes from the raw definition I think
07:30:06 <Thooms> "a tree is either a leaf, or a node that have n subtrees"
07:30:36 <Thooms> -> data Tree a = Leaf a | Node a [Tree a]
07:30:51 <Tokenizer> Sorry one last question, in the paste I made .. how do i make the ‚Äúconcatmap show l‚Äù line print ‚Äúcomma‚Äù separated items?   http://pastie.org/private/tkdvvetdwrszpcod91gw
07:31:58 <Thooms> Tokenizer: concat . intersperse "," . map show
07:32:00 <ClaudiusMaximus> > intercalate "," . map show $ [1,2,3]  -- intercalate is in Data.List
07:32:03 <lambdabot>  "1,2,3"
07:32:29 <joe9> Thooms: thanks.
07:33:12 <Thooms> (intersperse ',')*
07:33:27 <Tokenizer> Thooms, without a library
07:33:48 <Thooms> intersperse is in Data.List as well as intercalate
07:34:00 <ClaudiusMaximus> @src unwords
07:34:00 <lambdabot> unwords [] = ""
07:34:00 <lambdabot> unwords ws = foldr1 (\w s -> w ++ ' ':s) ws
07:34:54 <ClaudiusMaximus> something like that with ',' instead of ' ' - but you might be better implementing it recursively instead of using foldr1 for understanding purposes
07:39:46 <kuznero> Hi All!
07:39:56 <kuznero> Why is this a valid list: [1,[2,3],4]?
07:40:22 <ryantm> It's not.
07:40:22 <kuribas> kuznero: If you have a num instance for list maybe...
07:40:43 <kuznero> [1,[2,3],4] :: (Num [t], Num t) => [[t]]
07:40:45 <kuribas> oh, that wouldn't work...
07:40:48 <kuznero> This is what I got from GHCi
07:41:07 <kuznero> That is very unintuitive
07:41:34 <Zekka> kuribas: Close, but you still can't get a heterogenous list like this
07:41:47 <ion> @let instance Num a => Num [a] where fromInteger x = [fromInteger x]
07:41:49 <lambdabot>  .L.hs:169:10: Warning:
07:41:49 <lambdabot>      No explicit implementation for
07:41:50 <lambdabot>        ‚Äò+‚Äô, ‚Äò*‚Äô, ‚Äòabs‚Äô, ‚Äòsignum‚Äô, and (either ‚Äònegate‚Äô or ‚Äò-‚Äô)
07:41:50 <lambdabot>      In the instance declaration for ‚ÄòNum [a]‚Äô
07:41:50 <lambdabot>  
07:41:57 <ion> > [1,[2,3],4]
07:41:59 <lambdabot>  No instance for (GHC.Show.Show t0)
07:41:59 <lambdabot>    arising from a use of ‚ÄòM27487754624478385599354.show_M27487754624478385599...
07:41:59 <lambdabot>  The type variable ‚Äòt0‚Äô is ambiguous
07:41:59 <lambdabot>  Note: there are several potential instances:
07:41:59 <lambdabot>    instance [safe] GHC.Show.Show
07:42:09 <ion> > [1,[2,3],4] :: [[Integer]]
07:42:09 <Zekka> data Nummy = forall n. Num n => Nummy n
07:42:11 <lambdabot>  No instance for (GHC.Num.Num [GHC.Integer.Type.Integer])
07:42:11 <lambdabot>    arising from the literal ‚Äò1‚Äô
07:42:23 <Zekka> AFAIK you need to use existentials like the above
07:42:24 <ion> Uh. Never mind then.
07:42:45 <Zekka> Because a (Num [t], Num t) => [[t]] still can only contain one type
07:42:52 <Zekka> You can expand it to i.e. [[Integer]]
07:43:28 <kuznero> I still don't get it, sorry... So type inference system pretends that t is [t] somehow?
07:43:30 <Zekka> But that doesn't allow bare integers -- you could only write things like [[1], [2, 3], [4]], etc
07:43:46 <Zekka> kuribas: No, the typeinference system can only substitute one thing in for t
07:43:54 <kuribas> Zekka, yeah right.
07:44:17 <Zekka> (Num [t], Num t) => [[t]] is a list of lists of numeric type t, where the lists are somehow numeric
07:44:32 <kuribas> :t [1,[2,3],4]
07:44:32 <kuznero> I see
07:44:33 <lambdabot> (Num [t], Num t) => [[t]]
07:44:50 <kuznero> yes, ok... but just from looking into the value it seemed very strange!
07:44:51 <kuznero> Thanks!
07:44:56 <Zekka> Wait, what?
07:44:57 <indiagreen> ion: it's just some lambdabot's glitch
07:45:00 <kuribas> :t 1 :: (Num t) => [t]
07:45:01 <indiagreen> it works in GHCi
07:45:02 <lambdabot>     Could not deduce (Num [t1]) arising from the literal ‚Äò1‚Äô
07:45:02 <lambdabot>     from the context (Num t)
07:45:02 <lambdabot>       bound by the inferred type of it :: Num t => [t] at Top level
07:45:17 <Zekka> I don't actually understand how that has a definte type
07:45:23 <kuribas> :t 1 :: (Num t, Num [t]) => [t]
07:45:24 <lambdabot> (Num [t], Num t) => [t]
07:45:44 <Zekka> Oh, wait a sec, I get it
07:45:57 <kuribas> So basicly 1 is a list...
07:45:58 <Zekka> It's using the Num instance to turn the literals into lists
07:46:05 <Zekka> Yeah, it's using fromInteger
07:46:07 <kuribas> :t 1 :: (Num [t]) => [t]
07:46:10 <lambdabot> Num [t] => [t]
07:46:24 <Zekka> > show (1 :: [Integer])
07:46:26 <lambdabot>  No instance for (GHC.Num.Num [GHC.Integer.Type.Integer])
07:46:26 <lambdabot>    arising from the literal ‚Äò1‚Äô
07:46:41 <kuribas> :t Nothing :: (Num  Int) => [t
07:46:43 <lambdabot>     parse error (possibly incorrect indentation or mismatched brackets)
07:46:48 <kuznero> still confusing :)
07:46:53 <kuribas> :t Nothing :: (Maybe Int) => Maybe Int
07:46:54 <lambdabot>     Expected a constraint, but ‚ÄòMaybe Int‚Äô has kind ‚Äò*‚Äô
07:46:54 <lambdabot>     In an expression type signature: Maybe Int => Maybe Int
07:46:54 <lambdabot>     In the expression: Nothing :: Maybe Int => Maybe Int
07:47:06 <Zekka> I think it's possible your Num instance was somehow incorrect
07:47:22 <Zekka> but it's still willing to suppose that if Num [t] exists for some [t] then it would have that type
07:47:49 <Zekka> @let class Snowflake
07:47:50 <lambdabot>  .L.hs:153:1:
07:47:51 <lambdabot>      No parameters for class ‚ÄòSnowflake‚Äô
07:47:51 <lambdabot>      (Use NullaryTypeClasses to allow no-parameter classes)
07:47:51 <lambdabot>      In the class declaration for ‚ÄòSnowflake‚Äô
07:47:53 <kuribas> kuznero: Thing of the constant 1 as (fromInteger 1).  fromInteger can be anything based on the class definition.
07:47:57 <Zekka> @let class Snowflake a where
07:48:00 <lambdabot>  Defined.
07:48:11 <Zekka> :t 1 :: (Snowflake t => t)
07:48:13 <lambdabot>     Could not deduce (Num t1) arising from the literal ‚Äò1‚Äô
07:48:13 <lambdabot>     from the context (Snowflake t)
07:48:13 <lambdabot>       bound by the inferred type of it :: Snowflake t => t at Top level
07:48:19 <Zekka> er, d'oh
07:48:23 <Zekka> that's not overloaded
07:48:25 <kuribas> :t 1 :: (Num (Maybe Int)) => Maybe Int
07:48:26 <lambdabot>     No instance for (Num (Maybe Int))
07:48:26 <lambdabot>       arising from an expression type signature
07:48:26 <lambdabot>     In the expression: 1 :: Num (Maybe Int) => Maybe Int
07:48:29 <Zekka> I'm half-asleep!
07:48:46 <Zekka> @let x = x :: a
07:48:47 <lambdabot>  .L.hs:154:5:
07:48:47 <lambdabot>      Ambiguous occurrence ‚Äòx‚Äô
07:48:47 <lambdabot>      It could refer to either ‚ÄòL.x‚Äô, defined at .L.hs:154:1
07:48:47 <lambdabot>                            or ‚ÄòDebug.SimpleReflect.x‚Äô,
07:48:47 <lambdabot>                               imported from ‚ÄòDebug.SimpleReflect‚Äô at .L.hs:11...
07:49:38 <kuribas> :t 1 :: (Num (Maybe t)) => Maybe t
07:49:39 <lambdabot> Num (Maybe t) => Maybe t
07:51:04 <kuribas> :t 1 :: (Num (Maybe (Maybe (Maybe (Maybe (Maybe (Maybe t))))))) => (Maybe (Maybe (Maybe (Maybe (Maybe (Maybe t))))))
07:51:05 <lambdabot> Num (Maybe (Maybe (Maybe (Maybe (Maybe (Maybe t)))))) => Maybe (Maybe (Maybe (Maybe (Maybe (Maybe t)))))
07:51:42 <zwer> > 1 :: Maybe Int
07:51:43 <lambdabot>  No instance for (GHC.Num.Num (Data.Maybe.Maybe GHC.Types.Int))
07:51:44 <lambdabot>    arising from the literal ‚Äò1‚Äô
07:52:35 <kuribas> zwer: you need a type variable
08:05:27 <JonReed> Hi haskellers, a newbie here. How can I deal with an ambiguous variable without making a function? E.g. I have "let r = randomRIO(1, 10)" randomRIO has type of IO a. I want R to be the type "IO int"
08:06:26 <JonReed> Otherwise the compiler complains that the variable is ambiguous.
08:07:06 <JonReed> I know how to solve it by explicitly making another function with a singnature "randInt :: IO Int"
08:07:22 <JonReed> randInt = randomRIO(1,10)
08:07:40 <ion> let { r = randomRIO (1, 10) :: IO Int }, or let { r :: IO Int; r = randomRIO (1,10) }, or let { r = randomRIO (1, 10 :: Int) }, or‚Ä¶
08:07:55 <ion> randInt is not a function.
08:08:20 <athan> Isn't hxt's arrowif, arrowexec, etc. modules more general than rose tree filtration? Why aren't they in their own package? Just a fragment of history?
08:08:48 <JonReed> ion: thx!
08:15:22 <JonReed> ion: You've said that randInt is not a function. How should I call it?
08:16:30 <ion> It is an IO action and also a value. (Every IO action is a value, every function is also a value.) A value is a function iff its type signature is a -> b for some a and b.
08:17:06 <ManyQs> Hi guys. Question: How do I get TemplateHaskell to work in GHCi
08:17:38 <JonReed> ion: Ok thanks, it makes sense.
08:18:29 <ManyQs> I tried :set -XTemplateHaskell, but it doesn't seem to work properly
08:19:03 <indiagreen> ManyQs: what do you mean by ‚Äúwork properly‚Äù?
08:25:43 <eacameron> What does this error mean? "The operator of a section must have lower precedence than that of the operand"
08:26:08 <eacameron> My section looks like this `(distDir</>"x86"</>)`
08:26:42 <ahf> 14
08:29:29 <indiagreen> TIL: you can use ‚ÄúmakeLenses‚Äù in GHCi if you use it in a ‚Äú:{ :}‚Äù block right after the datatype declaration
08:29:45 <NightRa> With System.Process, how can I change the working directory and then execute a command?
08:30:02 <eacameron> so I have to do ((distDir</>"x86")</>)? Shouldn't right-associativity be enough?
08:30:24 <athan> ManyQs: I'm not sure if ghci is the best idea for templatehaskell. There's a requirement for module encapsulation in order to compile it and use the result, or observe it with -ddump-splices, if I remember correctly
08:31:08 <indiagreen> athan: ManyQs just wanted to use makeLenses in GHCi, that's all
08:31:28 <indiagreen> which works since it's in a different module
08:31:33 <athan> ManyQs: By module encapsulation I mean you have to throw all the code using TH in it's own module, then include it into a different module B. You can then put B in exposed-modules pragma in your cabal file to `cabal repl` and view the results in a ghci :)
08:31:37 <athan> oh really?
08:31:50 <athan> shoot
08:32:04 <JonReed> :t System.Directory.setCurrentDirectory
08:32:06 <lambdabot> FilePath -> IO ()
08:34:43 <ManyQs> athan: I will have to look into exposed-modules pragma, but from indiagreen, he shared the answer http://stackoverflow.com/questions/18395816/how-do-i-make-lenses-from-a-record-in-ghci/25392121#25392121 about how to make it work
08:35:37 <JonReed> NightRa: System.Directory.setCurrentDirectory "/home/jon/" ; r <- System.Process.createProcess (proc "ls" [])
08:35:52 <athan> ManyQs: (:
09:10:20 <xuinkrbin> The Haskell IRC channel has a reputation for generally being "Troll resistant", a rather impressive trait if I may be so bold. How do Y'All pull that off? Is it a sort of unwritten rule of "Look past any apparent flamebait?" Are You Zen Masters connected to a morphine drip?
09:11:46 <indiagreen> xuinkrbin: never been in other IRC channels, so can't really compare, but #haskell's behavior looks totally normal to me and not exceptional or zen or anything
09:13:39 <Cale> xuinkrbin: Well, I can't speak for everyone, but as a general rule, if I can provide someone with useful information even in response to a question I suspect might be a troll, I generally will.
09:14:49 <Cale> The idea being that others might still benefit, and even people who are trolling can sometimes be coerced into learning something.
09:16:25 <xuinkrbin> indiagreen: Perhaps My view was distorted by reports of the "xQuasar incident"?
09:17:49 <Cale> xuinkrbin: Well, every troll is a bit different
09:18:10 <Cale> xuinkrbin: Some of our older and more amusing trolls we just made into bot commands
09:18:20 <Cale> @keal
09:18:20 <xuinkrbin> Cale: That makes sense. I have tried doing so in other forums before but ... well ... as Friends will tell You ... I can sometimes turn into a Self imploding PR problem. Only a problem for Myself though; not Anyone Else. I am definitely very, very cautious when it comes to Others.
09:18:20 <lambdabot> i use an 8088
09:18:33 <wei2912> Cale: haha
09:18:33 <xuinkrbin> What is an "8088"?
09:18:42 <Cale> hehe, a very old CPU
09:18:46 <Cale> by Intel
09:18:50 <hpc> mostly we just drown the trolls in niceness
09:18:50 <Cale> @keal
09:18:51 <lambdabot> i still dont understand how gci is supposed to do anything other than mathematics
09:19:01 <Cale> hehe
09:19:06 <Cale> @protontorpedo
09:19:06 <lambdabot> can haskell do same stuff as J2EE but nicer?
09:19:19 <wei2912> wow
09:19:34 <Cale> ^^ this guy asked very broad questions like that for years apparently without actually learning anything
09:19:41 <Cale> @protontorpedo
09:19:42 <lambdabot> can haskell do data transfer from box to box over sockets?
09:19:47 <mbuffett> Hey guys, I have a data type called Piece, and a data type Square which is of type Maybe Piece. How do I create a list of empty squares? I tried take 10 [repeat Nothing], but then GHC doesn't know that it's a list of Squares, how would I do that?
09:20:03 <davean> I prefer my data transfered over socks
09:20:16 <benmachine> mbuffett: so you have, type Square = Maybe Piece?
09:20:17 <Cale> mbuffett: take 10 (repeat Nothing) ?
09:20:22 <mbuffett> Yeah
09:20:25 <xuinkrbin> Davean: I prefer to wear socks. ;-)
09:20:34 <benmachine> oh, Cale is right and I feel silly for not spotting that
09:20:45 <mbuffett> Oh, what's the difference?
09:20:51 <mbuffett> Why parentheses?
09:20:52 <Cale> mbuffett: The square brakets make it a list with one element
09:21:02 <Cale> [x] is a list with one element which is x
09:21:07 <mbuffett> Oh okay, thanks!
09:21:14 <Cale> brackets*
09:22:02 <mbuffett> It worked, thanks Cale
09:22:36 <Cale> no problem :)
09:22:53 <zereraz> does haskell have no side effects?
09:23:11 <zereraz> or it has but it helps manage them properly?
09:23:22 <davean> zereraz: A distate for impurity can be a pretty debilitating side affect
09:24:09 <zereraz> davean: yes
09:25:03 <davean> zereraz: So, haskell has "no side effects" technically, but it doesn't really look or seem that way in practice because well, we want some and the design goes a long way to emulate side effects
09:25:26 <Cale> zereraz: Haskell has ways to represent effects. It separates descriptions of effects from the evaluation of functions and other values.
09:25:30 <zereraz> davean: how do I introduce side effects if I wanted to?
09:25:49 <davean> you don't "introduce them", you model them. A monad handles it nicely
09:26:06 <davean> zereraz: So, do you want to just know how to do what you want to do, or the concepts here?
09:26:15 <zereraz> Cale: what effects are you talking about?
09:26:17 <Cale> zereraz: There's a parametric datatype, values of type IO t are descriptions of things which could be done (actions with effects) in order to produce a value of type t
09:26:17 <davean> zereraz: they're rather different answers and I'd be happy to go into either
09:26:31 <Cale> zereraz: Those effects can include anything that your computer is capable of
09:26:40 <zereraz> davean: I am curious that if someone wants to introduce a sideeffect that how would one go about it?
09:27:01 <Cale> Things like terminal I/O, network I/O, disk I/O, OpenGL or other graphics, ...
09:27:20 <davean> zereraz: well, if you ACTUALLY want to introduce sid effects you need to use unsafeSomething
09:27:30 <zereraz> Cale: understood
09:27:39 <davean> zereraz: in actuallity haskell programs end up a lot more like iteration of input and output
09:27:53 <Cale> Anyway, the important distinction is that there's a clear separation between *evaluation* which means converting expressions to values (generally for the purposes of pattern matching on the resulting data structures)
09:28:06 <zereraz> won't IO monad prevent side effects for input and output
09:28:08 <Cale> and *execution* which means carrying out the effects described by IO action values
09:28:08 <davean> zereraz: a very old version of haskell looked like that actually with you reading in a list and outputing a list of actions
09:28:28 <Cale> Evaluation does not cause execution to occur
09:28:34 <davean> zereraz: do you know what a continuation is?
09:28:45 <zereraz> davean: nope
09:28:55 <davean> ok, sad. That might have helped here
09:28:56 <zereraz> Cale: lazy evalation
09:29:04 <Cale> But as part of execution, evaluation of which IO actions you're dealing with will typically happen (but it has no effect other than making your CPU warmer)
09:29:14 <zereraz> davean: what is it?
09:29:34 <Cale> zereraz: This is a completely separate concern from the order in which evaluation occurs
09:29:44 <davean> zereraz: Probably as hard to explain as explain this without it if you don't already know it http://en.wikipedia.org/wiki/Continuation
09:29:47 <Cale> (which is what lazy evaluation refers to)
09:29:55 <zereraz> davean: thanks
09:29:58 <davean> zereraz: It just would have been a convinient thing to refer to if you had known it
09:30:12 <Cale> zereraz: It's also different from the fact that this IO datatype happens to be a monad
09:30:26 <Cale> That IO is a monad just implies some stuff about what its library API contains
09:30:56 <zereraz> Cale: ok
09:31:14 <Cale> and is not as big a deal as the fact that IO actions are themselves values, and evaluating IO actions does not cause the effects they describe to occur, so they can be safely passed around and combined, and only executed once they're ready :)
09:31:17 <davean> zereraz: You can think of side effects as iteration in haskell, and most monads are actually implimented that way
09:31:27 <Cale> davean: hm?
09:31:31 <Cale> iteration?
09:31:54 <davean> Cale: get input, perform function, send output, continue to next bit
09:32:01 <Cale> uh
09:32:14 <davean> input -> (output, next function)
09:32:15 <Cale> I mean, IO does describe actions which do input and output...
09:32:30 <Cale> But that doesn't mean that it has to be staggered like that
09:32:59 <Cale> You can do input and output in whatever order you like. IO is an abstract data type for describing what is to occur.
09:33:09 <zereraz> so in a way if we use monads haskell prevents us from having sideeffects in our program?
09:33:17 <davean> Cale: have you looked down the stack to IO's implimentation?
09:33:19 <Cale> zereraz: It really has nothing to do with monads
09:33:30 <Cale> zereraz: Monad is pretty much just a distraction here
09:33:31 <davean> zereraz: I just described an implimentation *without* monads
09:33:42 <davean> zereraz: monads are just an easy way to WORK with the implimentation
09:33:43 <zereraz> davean: yeah a tuple
09:33:47 <Cale> davean: There are a bunch of possible implementations of IO
09:34:02 <zereraz> my main question is that is this considered an side effect or not?
09:34:18 <Cale> zereraz: Is what considered a side effect?
09:34:22 <zereraz> input->(output, next function) is this side effect?
09:34:29 <davean> zereraz: It models them
09:34:29 <Cale> no?
09:34:34 <davean> output being the "side effect"
09:34:37 * hackagebot monad-resumption 0.1.1.3 - Resumption and reactive resumption monads for Haskell.  http://hackage.haskell.org/package/monad-resumption-0.1.1.3 (IanGraves)
09:34:48 <Cale> I honestly don't really know what davean is talking about :/
09:35:24 <Cale> IO actions are abstract values which represent things that may have effects, and could be done to produce a result of some type
09:35:32 <Cale> For example, getLine :: IO String
09:35:43 <Cale> represents the action of getting a line of text from the user on the terminal
09:35:59 <Cale> and will produce a String as its result
09:36:08 <davean> Cale: I asked if he wanted to know how to do the thing he wanted, or the theory.
09:36:11 <zereraz> let me say what I think a side effect is, it is when some change in program produces an undesired change ? like global variables
09:36:19 <zereraz> I am unsure
09:36:35 <davean> zereraz: Ah, so ... no
09:36:38 <indiagreen> zereraz: would you agree that a side effect is anything which function does but which isn't documented in its type? Like, in C there's function ‚Äúsin‚Äù, and it claims to take a double and give a double, but I could create another function called ‚Äúevilsin‚Äù which would take a double and give a double and would also delete all your files without you knowing ‚Äì and that'd be a side effect
09:36:52 <davean> zereraz: a "side affect" is something done besides the direct result of a function.
09:37:03 <Cale> "side effect"
09:37:29 <Cale> zereraz: I don't think it's so useful to try to formalise what side effects are
09:37:30 <zereraz> indiagreen: understood
09:37:56 <zereraz> ok main thing is I got this part
09:37:58 <zereraz> thanks
09:38:23 <zereraz> so what side effects can input and output have in other langauges that haskell prevents in its IO
09:38:31 <Cale> hm?
09:38:35 <Cale> IO describes effects
09:38:48 <Cale> Evaluation of IO actions does not have any visible effects
09:38:53 <Cale> But execution of them does
09:39:12 <zereraz> but aren't the IO functions meant to produce that effect
09:39:15 <davean> zereraz: input and output *are* side effects because they're not things returned by the function.
09:39:18 <Cale> Let's stop using the word "side effect"
09:39:20 <zereraz> so how will it lead to a side effect
09:39:25 <davean> zereraz: They produce it, they don't do it.
09:39:29 <davean> zereraz: they ask for it to be done
09:39:38 * hackagebot cabal2nix 1.71 - Convert Cabal files into Nix build instructions  http://hackage.haskell.org/package/cabal2nix-1.71 (PeterSimons)
09:39:41 <zereraz> oh
09:39:48 <Cale> uh
09:39:50 <davean> So, you return a request for it to happen
09:39:50 <zereraz> so anything not done by a function
09:40:02 <zereraz> all on its own?
09:40:07 <davean> zereraz: You return it to the RTS (runtime) and the RTS actually does it
09:40:41 <Cale> :S
09:40:45 <davean> which I think is the part Cale wasn't getting that I was talking about
09:41:38 <indiagreen> zereraz: there are some side effects which Haskell makes explicit, and some that remain implicit. For instance, in Haskell a function can't do IO without having to say ‚ÄúIO‚Äù in its type, but it still can throw exceptions, take time to be executed, consume memory, heat your CPU, and stuff like that. You can easily imagine a language which eliminates even more side effects, by e.g. requiring each function to ask for additional memory
09:41:39 <indiagreen> explicitly
09:41:56 <Cale> In a compiled program, you can imagine that what happens is that the IO action called main is executed by the RTS -- it will evaluate it, and match on which things it says to do, and then carry out those steps.
09:42:06 <sivteck> different people have different interpretation of these things. Can you point me to a paper/documentation that describes this? :S
09:42:34 <Cale> There are many possible implementations of IO though
09:42:42 <sivteck> in GHC?
09:42:44 <Cale> and that actually isn't the one which is used in GHC
09:42:54 <zereraz> hmm
09:42:54 <Cale> GHC does some very hacky stuff
09:43:02 <Cale> which just involves using impure functions internally
09:43:34 <indiagreen> zereraz: like, in Haskell a function can create a 1GB array for some internal computation, but in some language for embedded systems you can make it a requirement that allocating lots of memory can't be done without putting ‚ÄúImAMemoryHog‚Äù in the type of that function, and that'd be an additional eliminated effect
09:44:00 <zereraz> ooh
09:44:01 <zereraz> ok
09:44:10 <Cale> It uses something like  newtype IO a = IO (State# RealWorld -> (# State# RealWorld, a #))
09:44:20 <zereraz> so haskell has side effects but it lets you make them explicit if you want
09:44:21 <Cale> Where State# RealWorld is a 0-bit-wide type
09:44:29 <zereraz> so it lets you manage them better
09:44:39 <Cale> which only exists to hijack the evaluator's dependency analysis to keep the effects in order
09:44:45 <indiagreen> no, not ‚Äúif you want‚Äù
09:44:58 <indiagreen> you have to make some effects like IO explicit
09:45:07 <Cale> Here, let me just explain from the beginning without so much interruption
09:45:15 * indiagreen shuts up
09:45:30 <Cale> In Haskell, evaluation has no effects (or side effects)
09:45:50 <Cale> Evaluation refers to the process of converting expressions into values
09:46:00 <zereraz> got till here
09:46:36 <Cale> Instead, what we have is a datatype for representing every sort of effects that you might want to have occur in a program.
09:47:08 <Cale> Evaluating values of that datatype won't cause the effects to occur, any more than opening /bin/ls in a hex editor will cause a list of files to be printed to the screen
09:47:32 <matthew-> so I have a question about Martin-Lof type theory. Is there anyone here who's read the Nordstrom/Petterson/Smith book and has it to hand?
09:47:36 <Cale> Executing IO action values is what causes their effects to occur, and it's separate
09:47:50 <Cale> In a compiled Haskell program, the IO action called main will be executed.
09:48:19 <Cale> There are many operations for combining and composing IO action values in various ways
09:48:55 <zereraz> what is an action?
09:49:14 <zereraz> action is what performs effects?
09:49:16 <Cale> zereraz: You can think of it as a value which represents an executable program
09:49:31 <zereraz> oh
09:49:47 <zereraz> got it till here
09:49:50 <Cale> zereraz: For example, getLine :: IO String  is an action which if executed will get a line of text from the user
09:50:09 <zereraz> but isn't getLine a function?
09:50:12 <Cale> no
09:50:21 <zereraz> ok
09:50:26 <Cale> Its type is not of the form A -> B
09:50:31 <Cale> for types A and B
09:50:51 <Cale> Only values whose type looks like A -> B for some types A and B are called functions
09:50:58 <zereraz> got it!
09:51:24 <Cale> and in particular, you can't apply getLine to an argument
09:51:58 <zereraz> yup
09:52:02 <Cale> We can combine IO actions together using what's called do-notation
09:52:10 <zereraz> I know that
09:52:23 <zereraz> its syntactic sugar
09:52:24 <Cale> There's a function called putStrLn :: String -> IO ()
09:52:27 <zereraz> for >>= and >>
09:52:39 <Cale> which given some String, produces the IO action for printing that string to the terminal
09:53:25 <Cale> *Evaluating* an expression like  putStrLn "hello"  won't actually cause "hello" to get printed, it just does some work internally to simplify the IO action value
09:53:39 <Cale> It's just executing that resulting IO action which will cause the message to be printed
09:54:10 <zereraz> when does evaluation happen? on compilation?
09:54:18 <TropicalAudio_> huh, so, the tryhaskell is a bit misleading in that sens
09:54:23 <Cale> It happens at runtime, primarily
09:54:28 <zereraz> oh
09:54:37 <zereraz> is haskell dynamic scoping?
09:54:44 <Cale> Though it could happen partly during compilation
09:54:53 <Cale> no, Haskell is statically scoped
09:54:56 <zereraz> ok
09:55:19 <matthew-> gah, got a few more pages on. I have more questions. Really no Martin-Lof Type Theory experts in here?
09:55:32 <Cale> matthew-: Sorry about that, I'll have a look at your question :)
09:55:38 <zereraz> so on putting the value to expression i.e evaluation, we do not execute
09:55:41 <Cale> Oh, no, I don't have that book
09:56:03 <Cale> zereraz: That's right
09:56:26 <zereraz> Cale: haskell calls an action that does it internally
09:57:22 <Cale> zereraz: Yeah, you can imagine that there's some part of the runtime system which is picking apart the already evaluated IO action values and carrying out the steps they describe to execute them.
09:57:46 <GeorgiG> does anyone one why http://lpaste.net/113582 gives me "28:46: parse error on input `='"
09:58:03 <luite> zereraz: no only lexical scopes in plain Haskell, but the ImplicitParameters extension allows dynamically scoped variables (it's not used that much)
09:58:08 <Cale> That's probably the most useful mental model of what's taking place anyway, even if it's not 100% true, it's pretty indistinguishable from the much hackier stuff which is really going on with GHC compiled code :)
09:58:19 <zereraz> so if someone says that haskell does not have side effects, then I say , no it does but it separates them
09:58:33 <Cale> zereraz: Well, there's that word "side" again
09:58:53 <Cale> zereraz: It might be best to say that Haskell doesn't have side effects, but it does have effects.
09:59:00 <happy0> zereraz: i think you were accurate when you said that it makes them explicit =p
09:59:25 <happy0> ehh, subtleties aside, of course ;x
09:59:26 <Cale> IO actions primarily exist to describe effects, and executing them is primarily intended to cause those effects to occur
09:59:48 <Cale> So, calling them "side effects" at that point is a little odd, because they're the centre of attention for that process.
09:59:58 <zereraz> understood!!
10:00:12 <zereraz> we want them to happen
10:00:17 <zereraz> so how can they be side effects
10:00:22 <zereraz> they are the desired effects
10:00:35 <Cale> Of course, sometimes side effects are desired too
10:00:47 <GeorgiG> hello, can anyone help me with an error that I'm having?
10:01:02 <GeorgiG> why  does http://lpaste.net/113582 give me "28:46: parse error on input `='"
10:01:05 <Cale> In many other languages, you often make use of side effects which cause other things to occur besides computing the result during expression evaluation
10:01:45 <Cale> But in Haskell, we're just picky about that, and you're required to separate the description of your effects from the evaluation of expressions.
10:02:00 <Cale> GeorgiG: I'll have a look
10:02:08 <Cale> GeorgiG: because tabs
10:02:23 <Cale> GeorgiG: Configure your text editor to replace tabs with spaces automatically
10:02:34 <Cale> GeorgiG: If you're using vim, that's :set expandtab
10:02:46 <zereraz> I came here because someone ridiculed on quora that "haskell people pretend that sideeffects are evil, when in fact side effects are what make programs work."
10:02:52 <Cale> Almost any respectable text editor will have that feature though
10:03:30 <Cale> zereraz: Right, well, some people have only been introduced to a very academic fragment of Haskell which doesn't include much in the way of I/O
10:04:06 <Cale> zereraz: So, I think that contributes to the impression that Haskell doesn't have much in the way of capacity for describing effects, which is sad, because it's actually really good at it.
10:04:09 <zereraz> Cale: the thing that person means by "side effects" are our effects?
10:04:13 <Cale> yes
10:04:35 <zereraz> I totally agree
10:04:42 <zereraz> should I reply or let it be?
10:04:47 <GeorgiG> <Cale> I'm using Sublime, I'll try to find it there
10:05:01 <GeorgiG> <Cale> but what does the error mean?
10:05:20 <zereraz> GeorgiG: for sublime go to view->indentation
10:05:49 <Cale> GeorgiG: Look at how the code appears on the lpaste page
10:06:16 <Cale> GeorgiG: The definition of base64number is indented too far and doesn't line up with (a:b:c:d:e:f)
10:06:38 <Cale> because tabs by fiat mean "align to the next multiple of 8 columns"
10:07:22 <Cale> and if your editor displays them differently from that (which many editors do), then you'll end up with discrepancies between what your code looks like on your screen, and what the compiler thinks it is
10:07:35 <Cale> The best solution is generally agreed to be "don't use tabs"
10:07:54 <GeorgiG> <Cale> oooh, I see
10:08:10 <Cale> Because it's indented further, the definition of base64number is being treated as a continuation of the expression on the previous line
10:08:19 <chrisdone> they should bring back that ghc bug that deletes your files
10:08:20 <zereraz> Cale: thanks for explaining all this in detail!
10:08:36 <chrisdone> "I see tabs! Don't worry, I took care of it‚Ä¶"
10:08:41 <Cale> haha
10:09:02 <Cale> I wouldn't go quite that far, but I do think tab characters should just be a straight out lexical error
10:09:22 <GeorgiG> <Cale> then how do you indent things
10:09:38 <Cale> GeorgiG: By having my editor insert spaces when I press tab
10:10:07 <GeorgiG> <Cale> Thanks
10:10:10 <luite> does anyone here run emacs with ghc-mod on a remote system? my current setup is rather inadequate, with my local ghc-mod trying to pull the files in over sshfs
10:10:25 <GeorgiG> <zereraz> Thanks
10:10:38 <Cale> zereraz: No problem!
10:11:01 <Cale> zereraz: You might like this short article I wrote https://www.haskell.org/haskellwiki/Introduction_to_IO
10:11:33 <zereraz> Cale: I will read it right now!
10:12:10 <Cale> It pretty much says what we already went over, but there are a few examples there
10:12:35 <zereraz> Cale: revision!
10:26:43 <monochrom> zereraz: also see my http://www.vex.net/~trebla/haskell/IO.xhtml
10:27:17 <zereraz> monochrom: will read right after I finish that one :)
10:35:23 <zereraz> Cale: I read it, its quite well written. For referentially transparent any expression can be replaced with another expression with equal value right?
10:38:44 <notdan> Yep, that sounds like referential transparency
10:40:00 <zereraz> notdan: great :)
10:43:19 <statusbot> Maintenance update: We're beginning the Hackage migration to a new server, primarily preparatory work. The server is still available at this time. -- http://status.haskell.org
10:54:19 <JonReed> Is there any difference between "liftA" and "fmap"?
10:54:23 <JonReed> :t fmap
10:54:25 <lambdabot> Functor f => (a -> b) -> f a -> f b
10:54:28 <JonReed> t: liftA
10:54:36 <JonReed> :t liftA
10:54:37 <lambdabot> Applicative f => (a -> b) -> f a -> f b
10:57:01 <JonReed> If "liftA" and "fmap" do the same thing, then why isn't there only one of those functions in the standard library?
10:57:49 <simpson> JonReed: History!
11:12:12 <nshepperd> that _is_ odd. there was ever a time where Applicative didn't have a Functor constraint?
11:14:19 <Saizan> nope
11:14:50 <Saizan> but you can use liftA for your Functor instance if you define Applicative first :)
11:15:36 <HeladoDeBrownie> Then does that mean the answer isn't actually "history"?
11:15:46 <Hijiri> I think so
11:16:03 <HeladoDeBrownie> Though, I can see that being argued for liftM.
11:16:16 <barrucadu> I guess it might be history because liftA being analogous to liftM, which is there for historical reasons
11:16:16 <HeladoDeBrownie> that answer*
11:16:29 <Cale> liftM isn't *just* there for historical reasons
11:16:31 <HeladoDeBrownie> That's a good point.
11:17:01 <Cale> It makes writing the Functor instance trivial if you can implement the Monad operations
11:22:42 <dibblego> I think that is somewhat debatable (makes writing the Functor trivial). For example, instance Monad m => Monad (Writer w) then to write the Functor, you cannot using liftM or liftA
11:24:29 <deech> What's a good way of exposing an API where availiablity of functions depends on the platform?
11:33:34 <tsenart> hello there, haskell newbie here. would anyone help me figure out some custom JSON parsing code? http://lpaste.net/5062060596938145792
11:34:14 <tsenart> it currently doesn't work as it recurses forever on Objects and Arrays
11:34:23 <tsenart> I'm not sure how to fix it
11:36:02 <benmachine> tsenart: put Object o and Array a in parentheses
11:37:21 <tsenart> benmachine: that doesn't type check
11:42:15 <benmachine> tsenart: that's true, hm.
11:45:56 <dibblego> ynToBool (Object o) = Object (fmap ynToBool a) -- just a guess, not familiar with aeson
11:47:53 <tsenart> dibblego: yes!
11:47:56 <tsenart> that worked
11:48:10 <dibblego> oh great, glad it worked
11:48:11 <tsenart> now let me think a bit on why
11:48:28 <dibblego> I am not sure of the type of (a) but knowing that could probably help understand why it works :)
11:49:12 <tsenart> dibblego: Array is a type aliases to Vector Value
11:49:34 <tsenart> Object is a type aliases to HashMap Text Value
11:50:17 <tsenart> type Object = HashMap Text Value
11:50:26 <tsenart> type Array = Vector Value
11:51:10 <tsenart> dibblego: I don't understand destructuring of type aliases in pattern matching clauses
11:51:30 <tsenart> what is (Object o) in this case?
11:51:36 <benmachine> with type aliases you can just imagine replacing the LHS with the RHS
11:52:06 <benmachine> you can imagine this is all done before the program is compiled
11:52:07 <tsenart> benmachine: so, (Object o) == (HashMap Text Value o) ?
11:52:18 <benmachine> tsenart: in types, yes
11:52:29 <benmachine> er
11:52:33 <tsenart> how did that even compile before?
11:52:37 <benmachine> I guess
11:53:00 <alpounet> tsenart: the 'o' held by an Object *is* a HashMap Text Value
11:53:12 <alpounet> Object is one of the constructors of 'Value'
11:53:30 <tsenart> alpounet: that was my intuition
11:53:33 <alpounet> and the field it holds is a hashmap from field names (of type Text) to arbitrary JSON values (Value)
11:53:53 <alpounet> so when you pattern match on the Object constructor
11:54:02 <alpounet> f (Object o) = ... -- there, o is a HashMap
11:54:28 <tsenart> alpounet: right
11:54:51 <alpounet> i haven't looked at your lpaste yet though
11:54:52 <alpounet> let me take a look
11:55:23 <alpounet> oh ok I see
11:55:25 <tsenart> alpounet: I still don't understand why `ynToBool (Object o) = Object (fmap ynToBool o)` works and `ynToBool (Object o) = fmap ynToBool Object o` recurses forever
11:56:10 <alpounet> tsenart: the latter gets parsed as: (fmap ynToBool Object) o
11:56:29 <alpounet> which Functor instance do you think it's using?
11:56:55 <tsenart> HashMap?
11:57:13 <tsenart> but, Object by itself is just the constructor
11:57:20 <tsenart> when not specifying the type params
11:57:30 <alpounet> tsenart: fmap :: Functor f => (a -> b) -> f a -> f b. what is 'f' here? unify the types by hand to try to figure that out
11:57:37 <alpounet> yes, exactly tsenart
11:57:57 <alpounet> keep going, you're not far from figuring it out
11:58:20 <tsenart> alpounet: thanks for your help :)
11:58:30 <tsenart> benmachine: yours too!
11:59:50 <kqr> does anyone happen to know how I can get a numerical id out of a Key with persist? I need it to perform a second lookup using raw sql
12:01:41 <tsenart> alpounet: http://lpaste.net/5062060596938145792
12:02:12 <titusg> how can a foldr work on an infinite list, as it says on wiki that it "may" do?
12:02:42 <alpounet> tsenart: looks much better :)
12:03:02 <Cale> > foldr (\x xs -> x : 10*x : xs) [] [1..]
12:03:04 <lambdabot>  [1,10,2,20,3,30,4,40,5,50,6,60,7,70,8,80,9,90,10,100,11,110,12,120,13,130,14...
12:03:10 <dibblego> titusg: I have answered that question in a talk. https://vimeo.com/64673035
12:03:12 <Cale> titusg: are you just looking for examples?
12:03:27 <Cale> @src foldr
12:03:27 <lambdabot> foldr f z []     = z
12:03:27 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
12:03:36 <titusg> yes, hopefully to get a more general understanding, but thx
12:03:41 <Cale> ^^ you can see here that in the nonempty list case, foldr immediately passes control to f
12:03:57 <dibblego> Cale: I think it is a common question motivated by an incorrect intution that "foldr starts from the right" when "there is no right [since infinite]"
12:04:08 <Cale> and only if and when f needs its second argument will the foldr continue
12:04:11 <Cale> @src foldl
12:04:12 <lambdabot> foldl f z []     = z
12:04:12 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
12:04:25 <Cale> ^^ by contrast, foldl only passes control to itself until it reaches the end of the list
12:04:32 <dibblego> titusg: foldr does constructor replacement, and in no particular order (though it does *associate* to the right)
12:04:40 <statusbot> Maintenance update: The new server has been synchronized. The primary hackage server will go down soon. -- http://status.haskell.org
12:04:43 <kqr> Cale, that's a pretty good way of looking at it, thanks
12:05:30 <titusg> makes sense, thanks
12:06:39 <kqr> btw about my question earlier, i figured it out. a Key is a PersistField which means I can call toPersistValue on it :)
12:08:18 <besenwesen> when i have a foo :: Int -> String -> Type, i can do: something = foo <$> [1,2] <*> ["a"]. How would i abstract over [1,2], so that the result is of type [Int] -> Type?
12:08:50 <kqr> besenwesen, something ints = foo <$> ints <*> ["a"]
12:09:02 <besenwesen> *_*
12:09:16 <statusbot> Maintenance update: The hackage server has gone down. There is a maintenance page in place; the new DNS entry should propagate soon. -- http://status.haskell.org
12:09:26 <besenwesen> thank kqr
12:09:30 <besenwesen> +s
12:09:40 <kqr> no problem
12:09:40 <besenwesen> seems kinda obvious now
12:09:57 <kqr> haha yeah
12:10:00 <kqr> functions are king :)
12:10:41 <kqr> where is the local documentation?
12:10:49 <kqr> i figured now that hackage is down is as good a time as any to ask...
12:12:15 <dibblego> hmm that appears to have only just occurred ó I pushed a package just 2 minutes ago
12:12:45 <kqr> dibblego, yeah it's a maintenance thing, it started just now
12:13:03 <jmcarthur> besenwesen: alternatively:    flip (liftA2 foo ["a"])
12:13:10 <dibblego> oh right, just got in
12:13:14 <jmcarthur> err
12:13:23 <jmcarthur> besenwesen: alternatively:    flip (liftA2 foo) ["a"]
12:13:27 <jmcarthur> is what i meant
12:13:31 <kqr> yeah that looks better
12:13:48 <kqr> but also more unreadable :>
12:14:05 <kqr> or i guess it's not that bad
12:14:10 <besenwesen> is there any thing like <$> that maps a bunch of functions over just *one* argument? with <$>, i‚Äôll always have to put it in a monad
12:14:14 <kqr> in any case, I decided to recommend functions for a reason
12:14:19 <dibblego> besenwesen: sequence
12:14:23 <jmcarthur> or   (flip.liftA2) foo ["a"]   or   liftA2 foo `flip` ["a"]
12:14:40 <dibblego> > sequence [(+1), (*2)] 7
12:14:42 <lambdabot>  [8,14]
12:14:52 <jmcarthur> besenwesen: i don't understand the question. (<$>) only requires Functor, not Applicative or Monad
12:15:27 <besenwesen> sorry, right, should‚Äôve said functior. what i meant was with <$> i had to map the arguments in a list, even when there‚Äôs only one
12:15:30 <jmcarthur> besenwesen: you mean you want   Applicative f => f (a -> b) -> a -> f b   ?
12:15:40 <kqr> besenwesen, i think you want what dibblego suggested
12:15:59 <besenwesen> yes, right. i searched that signature on hoogle. just looking into sequence
12:16:29 <kqr> sequence is very magical
12:16:41 <dibblego> jmcarthur: s/Applicative/Traversable
12:16:56 <jmcarthur> dibblego: actually i only mean Functor
12:17:01 <dibblego> ok
12:17:01 <statusbot> Maintenance update: The new server has been started, and the DNS entries have been propagated. Although the DNS TTL is very low, you may want to clear your DNS cache as well. -- http://status.haskell.org
12:17:07 <jmcarthur> :t \fs x -> fmap ($x) fs
12:17:09 <lambdabot> Functor f => f (a -> b) -> a -> f b
12:17:40 <jmcarthur> > (\fs x -> fmap ($x) fs) [(+1), (*2)] 7
12:17:42 <lambdabot>  [8,14]
12:18:15 <dibblego> you can also use Data.Distributive#distribute
12:19:39 <jmcarthur> :t fmap . id
12:19:41 <lambdabot> Functor f => (a -> b) -> f a -> f b
12:19:45 <jmcarthur> err...
12:19:47 <jmcarthur> duh
12:19:55 * hackagebot semigroupoids-syntax 0.0.1 - RebindableSyntax using the semigroupoids package  http://hackage.haskell.org/package/semigroupoids-syntax-0.0.1 (TonyMorris)
12:20:11 <jmcarthur> :t fmap . flip id
12:20:12 <lambdabot> Functor f => a -> f (a -> b) -> f b
12:20:13 <thoughtpolice> OK, good. the DNS changes seem to already be moving out quite quickly
12:21:06 <arielsanflo> saludos
12:21:11 <arielsanflo> y buen dia a todos
12:21:19 <besenwesen> cool. i only just got to know sequence yesterday. i hadn‚Äôt realized  (-> r) are monads too.
12:21:39 <arielsanflo> hello
12:21:42 <besenwesen> seems weird still calling it ¬´sequence¬ª in this case
12:21:45 <arielsanflo> i am from colombia
12:21:55 <dibblego> besenwesen: it is often called the "reader monad"
12:22:00 <dibblego> hello arielsanflo
12:22:11 <arielsanflo> help tutorial in spanish the haskell
12:22:20 <arielsanflo> is new in haskell
12:22:25 <benzrf> :t execWriterT
12:22:26 <lambdabot> Monad m => WriterT w m a -> m w
12:22:27 <benzrf> hm
12:22:31 <arielsanflo> my english is soo
12:22:33 <benzrf> :t execWriter
12:22:35 <lambdabot> Writer w a -> w
12:22:36 <arielsanflo> so so
12:22:50 <benzrf> arielsanflo: i don't know
12:23:00 <benzrf> arielsanflo: have you tried googling?
12:24:38 <arielsanflo> yes
12:24:46 <arielsanflo> googling
12:25:31 <arielsanflo> only found in Spanish think haskell .pdf
12:26:57 <srhb_> arielsanflo: http://aprendehaskell.es/ perhaps?
12:27:30 <arielsanflo> fine thanks
12:27:36 <arielsanflo> muchas gracias
12:27:46 <srhb_> You're welcome.
12:27:50 <kqr> I have a value m (f a) and a function a -> m (f a), is there a way to apply the latter to the former?
12:28:10 <kqr> whoops
12:28:23 <kqr> m (f a) -> (a -> m (f b)) -> m (f b)
12:28:26 <kqr> is what i'm interested in
12:29:25 <fread2282> kqr: what are f and m?
12:29:27 <dibblego> kqr: you can for (m a -> (a -> m (f b)) -> m (f b))
12:30:08 <dibblego> given (Applicative m, Monad f, Traversable f) ‚áí
12:32:09 <kqr> fread2282, m is HandlerT something something and f is Maybe
12:32:20 <kqr> dibblego, that sounds good
12:32:44 <dibblego> @type \f -> fmap join . traverse f
12:32:46 <lambdabot> (Traversable m, Applicative f, Monad m) => (a1 -> f (m a)) -> m a1 -> f (m a)
12:33:34 <dibblego> @type /msg lambdabot @pl \x -> fmap join . traverse f $ x
12:33:35 <lambdabot> parse error on input ‚Äò/‚Äô
12:33:37 <dibblego> oops
12:33:48 <dibblego> you want to flip that
12:34:56 <mm_freak> hi there‚Ä¶  i'm using emacs haskell-mode with indent-mode (not indentation-mode)
12:35:34 <kqr> dibblego, I think my f is traversable so I like the for solution
12:35:37 <mm_freak> i just updated to 24.4.1, and now emacs auto-indents when i press enter‚Ä¶  this is extremely annoying‚Ä¶  does anyone know how to fix this?
12:38:34 <mm_freak> the auto-indentation is basically the only reason why i don't use haskell-mode's indentation-mode‚Ä¶  i want to press TAB to indent
12:38:38 <kqr> does anyone know how you can convince persistent that the integer you have is actually a Key for a model?
12:38:56 <Welkin> what do you mean?
12:38:59 <Welkin> in a query?
12:39:04 <jle`> kqr: i think you need to wrap it in the constructor?
12:39:33 <Welkin> for a book ID, it would be BookId (which is just Key Book)
12:40:50 <kqr> Welkin, but is there a function Int -> BookId? I haven't found one (and BookId isn't it, it seems)
12:41:34 <srhb_> mm_freak: Isn't it just because electric-indent is on by default now?
12:42:20 <srhb_> mm_freak: ie. try M-x electric-indent-mode and see if that helps
12:45:01 <chrisdone> yeah, swapping the meaning of keys by default in emacs was an annoying decision
12:45:22 <chrisdone> it's trivial to just enable the minor mode, they've messed up everyone's mojo with that
12:45:37 <Welkin> when I first started using emacs I didn't have electric-indent/pair
12:45:56 <Welkin> it took me a while to figure out how to add them and now I can't use emacs without them
12:47:06 <benzrf> > sequence (Just [1])
12:47:09 <lambdabot>  Couldn't match expected type ‚Äò[m a]‚Äô
12:47:09 <lambdabot>              with actual type ‚ÄòData.Maybe.Maybe [t0]‚Äô
12:47:15 <benzrf> > T.sequenceA (Just [1])
12:47:17 <lambdabot>  [Just 1]
12:47:20 <benzrf> cool.
12:47:23 <chrisdone> T???
12:47:25 <benzrf> > T.sequenceA (Just [1, 2, 3])
12:47:27 <lambdabot>  [Just 1,Just 2,Just 3]
12:47:34 <chrisdone> @quote confusion
12:47:35 <lambdabot> ciaranm says: a confusion is just the categorical dual of a fusion, which is just a fusoid in the category of brainofunctors
12:47:41 <benzrf> kek
12:47:42 <DTSCode> can someone help me with this? im trying to build the clang branch of haskell http://paste.ubuntu.com/8778689/
12:47:46 <mm_freak> srhb_: it seems like every time i update emacs i have to work around new highhandedness
12:47:51 <mm_freak> almost feels like windows
12:47:56 <mm_freak> thanks for the pointer!
12:47:57 <benzrf> highhandedness?
12:48:10 <srhb_> mm_freak: Yeah, it's annoying.
12:48:49 * chrisdone generally puts off updating emacs until weekends
12:49:01 * chrisdone generally puts off updating anything
12:49:23 <chrisdone> one day soon i'll switch to NixOS
12:49:53 <mm_freak> chrisdone: i am on NixOS, and it doesn't help, because i don't want to downgrade
12:50:22 <gilligan_> hm.. i should start using nix
12:50:33 <gilligan_> (just nix, not nixos for now)
12:50:52 <adarc> nix life.. > *
12:50:53 <adarc> ;f
12:51:06 <mm_freak> gilligan_: go ahead, in most cases you can install it with a single command
12:51:09 <chrisdone> mm_freak: at least you can easily downgrade if the new version is too annoying to update to at the this moment in time
12:52:16 <qsuscs> almost, GHC, almost. http://lpaste.net/2851510800214917120
12:52:25 <qsuscs> (okay, technically correct)
12:52:57 <mm_freak> chrisdone: one nice feature is to upgrade everything, and if anything breaks, go back and upgrade everything except the broken stuff
12:53:06 <DTSCode> anyone?
12:53:10 <mm_freak> but it doesn't help if you actually want to upgrade exactly that stuff =)
12:53:13 <chrisdone> mm_freak: right
12:53:24 <chrisdone> it's like git but for your packages =)
12:53:48 <chrisdone> "merge from upstream failed? okay, i'll just cherry-pick some commits"
12:54:28 <mm_freak> qsuscs: if that would return the correct number, it could be a serious security issue =)
12:55:09 <qsuscs> hm, someone just gave me this example in rust, is there something similar for the graphemes in haskell? http://is.gd/H9ef6z
12:55:14 <chrisdone> i wonder if there's a zalgo entry on SCP
12:56:16 <mm_freak> chrisdone: git makes my brain explode
12:56:57 <mm_freak> qsuscs: i'm not sure i understand what i'm looking at
12:57:06 <indiagreen> qsuscs: I think there's something in text-icu
12:57:10 <chrisdone> git explode --section cerebral-cortex~2 -i --ours
12:57:12 <qsuscs> mm_freak: do you know what zalgo is?
12:57:20 <mm_freak> nope
12:57:34 <chrisdone> @google parsing html regexes stackoverflow
12:57:37 <lambdabot> http://stackoverflow.com/questions/1732348/regex-match-open-tags-except-xhtml-self-contained-tags
12:57:37 <lambdabot> Title: html - RegEx match open tags except XHTML self-contained tags - Stack Overflow
12:57:48 <chrisdone> mm_freak: see above ^
12:57:52 <qsuscs> mm_freak: do you know what a diacritic is?
12:58:16 <mm_freak> qsuscs: like a combining character?
12:58:40 <qsuscs> mm_freak: yeah, like the trema (‚Äúdots‚Äù) on the √§, or the cedille on the √ß, etc.
12:58:44 <mm_freak> if yes, i probably know what it is, just not what it's called =)
12:58:56 <benzrf> tfw my compose key can't compose functions
12:58:56 <mm_freak> in kcharselect they are called "combining diacritical marks"
12:59:23 <qsuscs> mm_freak: zalgo is just a whole lot of them, so the text becomes unreadably, and the lines above and beneath get fscked up as well usually (my rendering is broken, luckily)
13:00:11 <chrisdone> zalgo is the meme which employes them for lovecraftian atmosphere
13:00:15 <qsuscs> mm_freak: and in unicode, when really doing composed charactes (‚Äú√§‚Äù is usually just the latin-1 ‚Äúlatin small letter a with diaresis‚Äù or what it‚Äôs called) it‚Äôs 'a' 'diaresis'
13:00:33 <qsuscs> mm_freak: so, technically, they _are_ two different characters, they are just displayed together
13:00:41 <mm_freak> chrisdone: haha nice
13:01:37 <mm_freak> qsuscs: yeah, i understand that
13:02:19 <qsuscs> mm_freak: so something like ‚Äú√§‚Äù is one grapheme, can be composed of two characters (that one is not, it‚Äôs really just one) and several bytes, depending on the UTF variant
13:02:51 <qsuscs> haskell‚Äôs length seems to return the number of characters, and i wonder whether there is a function that returns the number of graphemes
13:03:29 <mm_freak> qsuscs: i'm familiar with all of that, but it doesn't explain what i'm looking at in that paste‚Ä¶  the URL displays lots of unicode garbage, while the page itself renders fine
13:03:53 <mm_freak> qsuscs: you could filter out the combining characters by unicode category
13:04:11 <mm_freak> but beware that this may be a security risk
13:04:36 <qsuscs> why that?
13:05:35 <benzrf> ¬®
13:05:41 <mm_freak> qsuscs: example application: an echo server that reverses every line before it sends it back
13:05:51 <mm_freak> naturally you would put a length constraint on the lines
13:06:08 <Welkin> that isn't restful
13:06:14 <Welkin> you would post that information
13:06:17 <benzrf> i'm not tireddd
13:06:20 <Welkin> so there won't be a constraint
13:06:33 <Welkin> a get should only be used to retrieve data
13:06:44 <xplat> Welkin: who said it was an HTTP server?
13:06:48 <mm_freak> Welkin: what?
13:06:52 <benzrf> Welkin is not responding to mm_freak
13:06:59 <mm_freak> Welkin: echo is not an HTTP-based protocol
13:06:59 <benzrf> no wait
13:07:00 <benzrf> derrrp
13:07:05 * benzrf retreats
13:07:28 <Welkin> okay
13:07:41 <Welkin> I thought you were talking about http
13:08:07 <xplat> a constraint on the number of codepoints in a line also implicitly constrains the number of bytes in the line
13:08:18 <xplat> a constraint on the number of graphemes does not
13:08:19 <mm_freak> Welkin: i could be talking about HTTP itself, for example the headers
13:08:50 <mm_freak> you would want a length and count constraint on HTTP headers, but those are not unicode anyway, so you can just count bytes and lines
13:08:50 <xplat> because unicode graphemes can contain an arbitrary number of codepoints
13:14:24 <mm_freak> thanks for your help, srhb_
13:16:39 <qsuscs> mm_fr‚Ä¶ argh.
13:16:49 <qsuscs> gonna say it anyway.
13:17:17 <qsuscs> i wouldn‚Äôt write a program (especially not an echo server) that reverses a string in the first place http://www.vidarholen.net/contents/blog/?p=324
13:17:38 <qsuscs> especially not given my haskell skills ‚Ä¶ or my skills in any language you know (although, does german count?)
13:19:09 <indiagreen> qsuscs: http://lpaste.net/113588
13:19:18 <lpaste> arielsanflo pasted ‚Äúlist is ascending  polymorphic‚Äù at http://lpaste.net/113589
13:19:40 <lpaste> elmo_ pasted ‚Äúcabal version magic?‚Äù at http://lpaste.net/113590
13:20:06 <qsuscs> indiagreen: thanks, already stumpled upon Data.Text.ICU, but had no idea how to use it
13:20:10 <elmo_> hi, can any one help me figure out why the cabal version has not changed even after installing a newer version?
13:20:23 <srhb_> elmo_: are you calling the new cabal?
13:20:29 <arielsanflo> another way to check that the list is up
13:20:32 <srhb_> (ie. check your PATH variable)
13:20:58 <elmo_> srhb_: is there a different way to call the new cabal?
13:20:58 <arielsanflo> i am from colombia
13:21:00 <srhb_> New cabal-install, which I'm assuming is what we're talking about
13:21:10 <arielsanflo> no canal in spanish
13:21:15 <arielsanflo> the haskell
13:21:24 <srhb_> elmo_: if you installed it with cabal install cabal-install, it would be in ~/.cabal/bin normally
13:21:39 <elmo_> srhb_: could you please look at the lpaste i posted above?
13:21:49 <elmo_> srhb_: elmo_ pasted ‚Äúcabal version magic?‚Äù at http://lpaste.net/113590
13:22:24 <srhb_> elmo_: I don't know where cabal installs stuff on windows. But once you find the right executable, you'll get the right version. You're just still running the old one.
13:23:05 <elmo_> shouldnt theold one be gone once the new one is installed?
13:23:11 <srhb_> elmo_: No.
13:23:32 <elmo_> why would it install in a new place? and is there some command to link to the new version?
13:23:56 <srhb_> elmo_: Generally you just put the new location in front of the PATH variable
13:24:01 <srhb_> That's where cabal installs all binaries anyway
13:24:03 <srhb_> So you want that.
13:24:34 <srhb_> It installs in a new place because it's a cabal-installed thing. Which is separate from all other things.
13:24:47 <srhb_> Anyway, the solution is as I stated.
13:25:10 <elmo_> normally i expected that doing cabal install would do everything for me, so will I have to keep looking for a new location everytime cabal-install is cabal installed?
13:25:43 <srhb_> elmo_: No, the location is the same every time.
13:25:50 <srhb_> elmo_: It's just different from the globally installed one
13:26:02 <srhb_> and your expectations are wrong. :)
13:26:11 <elmo_> if the location is the same why would i have to change the PATH?
13:26:35 <srhb_> Because I assume it's not on your PATH yet.
13:26:38 <srhb_> Is it?
13:27:02 <elmo_> then how did the initial cabal work?
13:27:33 <srhb_> The initial cabal did not get installed in the same way.
13:27:34 <geekosaur> your initial cabal was probably in /usr/bin or /usr/local/bin. if you use it to update itself, it does a local install not a system-overwriting install (~/.cabal/bin)
13:27:40 <srhb_> And its binary is not in the same location
13:28:32 <elmo_> geekosaur: im on windows
13:28:38 <srhb_> elmo_: search for cabal.exe then
13:28:44 <geekosaur> same usually applies, just with different paths
13:28:51 <srhb_> elmo_: When you find the right one, put its directory on your PATH
13:28:51 <geekosaur> I couldn't tell you what they are on win
13:28:53 <srhb_> Done.
13:29:09 <elmo_> i see a strong correlation between accelerated hair loss and my continued use of cabal on windows
13:29:19 <srhb_> elmo_: This issue is exactly the same on Linux
13:29:30 <srhb_> elmo_: The system doesn't magically know where to look for cabal-installed binaries
13:30:25 <elmo_> srhb_: if it is an allowed possibility, then the haskell platform installer should have put the new location in the path already.
13:30:33 <srhb_> elmo_: No.
13:30:48 <srhb_> I seriously don't want random installers changing my PATH environment variable
13:31:13 <srhb_> Anyway, I don't have time to debate it. You've got the solution. :)
13:31:30 <lpaste> arielsanflo pasted ‚Äúlist is ascending  polymorphic‚Äù at http://lpaste.net/113591
13:32:04 <arielsanflo> help
13:32:07 <arielsanflo> error
13:32:27 <srhb_> arielsanflo: c<= (head col) is the same as the entire if-then-else
13:32:31 <rgr> srhb_: +1 . Installers adding to PATH would really really really suck.
13:33:04 <srhb_> Woops, no.
13:34:04 <jle`> arielsanflo: you might want to pattern match on (c1:c2:col)
13:34:49 <elmo_> srhb_: The haskell platform installer already changed the path environment variable, all I am saying is that it change it once well enough so that the user shouldnt have to do it manually later.
13:35:20 <srhb_> elmo_: OK, then I don't know how Windows works, I guess. No change in PATH here.
13:35:30 <arielsanflo> another way to check if a list is ascending help
13:35:34 <arielsanflo> paste please
13:35:46 <srhb_> arielsanflo: What do you mean, another way?
13:36:02 <elmo_> rgr: so would you consider it usable to install the haskell platform and then when you go to a terminal and type ghci it doesnt work? on windows, all installers update the path
13:36:22 <srhb_> > let foo = [1,2,3,4] in foo == sort foo
13:36:23 <lambdabot>  True
13:36:24 <monochrom> arielsanflo: chk [] = True; chk [x] = True; chk (x0:x1:xs) = x0 <= x1 && chk (x1:xs)
13:37:16 <arielsanflo> fine thanks
13:37:36 <monochrom> another way is to reverse the list and check descending :)
13:40:01 <arielsanflo> fine thanks
13:40:27 <monochrom> it seems to me the conventions are: a windows installer puts stuff in its dedicated directory, then append your PATH; a linux installer puts stuff in /usr/local/bin, and does not need to change your PATH. there are windows users who prefer the linux convention, and linux users who prefer the windows convention.
13:41:18 <tdammers> this has got to be one of the best compiler errors ever:
13:41:19 <monochrom> and another group of user preferring: put stuff in dedicated directory, then add symlinks in /usr/local/bin
13:41:20 <tdammers>     Can't make a derived instance of `MonadTrans JST'
13:41:22 <tdammers>       (even with cunning newtype deriving):
13:42:57 <Guest79574> monochrom: And then there's the stubborn "I'll pick my own prefix and manually manage my path" crowd on *nix ;)
13:43:52 <monochrom> I happen to be one of them. but when I install haskell platform on windows, I don't mind the windows convention.
13:44:10 <benzrf> ArrowApply is basically exponent objects?
13:44:42 <merijn> benzrf: afaik arrowapply is basically monad
13:45:02 <benzrf> oh..
13:45:13 <monochrom> I am not one of those anal people who routinely ditch common fonts on the slight pretext of "the letter t has one pixel that annoys me"
13:45:21 <elmo_> but on windows, the platforminstaller already changes the path.  would it be wrong to add the default location of the cabal install path also? or provide the choice to change the default location of cabal installed stuff in the installer and then do the right thing with the path so it "Just works"
13:45:31 <merijn> benzrf: iirc the initial arrow paper considers ArrowApply rather uninteresting as they're equivalent to Monad
13:45:38 <monochrom> elmo_, IIRC, it already does
13:45:45 <arielsanflo> bye fine
13:45:48 <arielsanflo> thanks
13:45:52 <merijn> Last I tried the platform on windows it put cabal in my path
13:45:59 <elmo_> those who wish to customize should have an option to do so, but i guess the majority are newbies like me
13:46:01 <merijn> Granted, this is a year or more ago
13:47:01 <elmo_> monochrom: it did not.  specifically this wass unexpected elmo_ pasted ‚Äúcabal version magic?‚Äù at http://lpaste.net/113590
13:48:03 <monochrom> do you mind showing %path% ?
13:48:45 <monochrom> or you can analyse it yourself. it may help.
13:55:37 <chrisdone> what are you hacking on tonight, monochrom?
13:56:02 <rodlogic> is "go a b | a `seq` b `seq` False = undefined" the same as "go' !a !b = undefined"?
13:57:20 <monochrom> tonight I have nothing to hack. but have you read my email about haskell-process.el !
13:57:29 <rodlogic> humm, I guess go will never hit undefined (assuming there is catch all go _ _ = ...
13:58:49 <monochrom> yes
14:00:27 <gilligan_> so I suppose there should be some nix users in here right ? One of few good intro level texts on using nix for haskell development is this blog article by olliver charles : https://ocharles.org.uk/blog/posts/2014-02-04-how-i-develop-with-nixos.html -- is that how you approach this as well and are any parts of this already outdated by now ?
14:01:40 <rodlogic> monochrom: see this http://lpaste.net/113596  it seems a convoluted way of saying go !a [] = return ()  right?
14:02:24 <fread2282> gilligan_: http://fuuzetsu.co.uk/blog/posts/2014-06-28-My-experience-with-NixOS.html may alse be useful, it's more recent and more complete
14:02:46 <monochrom> depending on why the author seqs b, they may or may not be the same.
14:03:04 <monochrom> nevermind, you're right
14:03:11 <gilligan_> fread2282, thanks
14:03:20 <monochrom> this code is probably written before bang pattern existed
14:03:26 <rodlogic> this is in the GHC code base and it was prob done before BangPatterns were in place
14:03:32 <rodlogic> yes, exactly.
14:03:33 <monochrom> yeah
14:03:48 <rodlogic> I just need a confirmation that I can replace that with go !a [] = return ()
14:04:21 <chrisdone> bang patterns are awesome
14:04:33 <monochrom> but "go a [] = a `seq` return ()" is Haskell98
14:04:36 <chrisdone> down with seq
14:04:49 <monochrom> OTOH it is fragile to possible future changes
14:05:13 <chrisdone> monochrom: is `seq` actually part of haskell 98?
14:05:34 <monochrom> "go a b | a `seq` b `seq` False = undefined" is the kind of line of code that you just write and never have to worry about it again ever
14:05:38 <monochrom> yes
14:05:39 <benzrf> hmmmmmmmmmmmmmmmmmm........
14:05:56 <merijn> chrisdone: Ola!
14:06:02 <benzrf> is there any case where something written with pure can't be rewritten to use fmap and no pure?
14:06:13 <merijn> chrisdone: I thought about our "ghci-ng using tcp sockets" discussion from earlier
14:06:21 <chrisdone> merijn: oh yeah?
14:06:27 <monochrom> it is also probably John Hughes's contribution
14:06:35 <merijn> chrisdone: I've changed my mind from "this is mildly undesirable" to "this is the most insanely huge security issue ever"
14:07:13 <merijn> chrisdone: There is *no* way to shield a local TCP socket from other local users, which means "ghci-ng" listening on a TCP socket allows arbitrary code execution by *any* user on the system
14:07:14 <chrisdone> merijn: over named pipes?
14:07:21 <chrisdone> true
14:07:47 <merijn> chrisdone: I'm okay with named pipes, and I checked and windows does support named pipes, so I think that's the only reasonable approach to take
14:08:17 <chrisdone> so SLIME/Swank uses tcp sockets
14:08:22 <elmo_> monochrom: i sent you my path in a priv message
14:08:33 <chrisdone> are they basically just unscrupulous insecure programmers?
14:08:54 <merijn> chrisdone: yeah
14:09:24 <chrisdone> i'm okay with named pipes as long as i also have the option to somehow connect to a remote instance
14:09:27 <merijn> chrisdone: I only realised this when I wanted to forward a tmux socket over TCP so I could use SSH forwarding and talked to some of the OpenBSD guys working on it and they were like "oh god, no"
14:09:57 <merijn> chrisdone: Depends, are you okay with requiring something like SSH for that?
14:10:05 <chrisdone> i mean, obviously local users isn't a worry
14:10:12 <chrisdone> for me
14:10:18 <chrisdone> i don't know what people are using your machines
14:10:38 <fragamus> :t fmap
14:10:38 <fragamus> :t map
14:10:39 <merijn> chrisdone: Well, I work on cluster head nodes which are shared by tons of people
14:10:39 <lambdabot> (a -> b) -> [a] -> [b]
14:10:40 <lambdabot> Functor f => (a -> b) -> f a -> f b
14:10:40 <chrisdone> what is the case they made against that?
14:10:50 <chrisdone> merijn: what's a cluster head node?
14:11:11 <merijn> chrisdone: Most cluster have a head node where you SSH into, develop on and launch jobs from
14:11:59 <chrisdone> merijn: so it's a machine that you connect to and develop inside of?
14:12:08 <merijn> chrisdone: At uni those are shared with basically any other staff member/students and I don't think opening myself up to having any of them run code as me is desirable
14:12:42 <chrisdone> so you wouldn't want to listen on a port, no
14:12:55 <chrisdone> that's like some old school time sharing stuff
14:12:59 <chrisdone> people are still doing that?
14:13:11 <chrisdone> weird‚Ä¶
14:13:12 <merijn> chrisdone: What else would you do?
14:13:24 <Fuuzetsu> gilligan_: both those posts are a bit dated now
14:13:34 <Fuuzetsu> feel free to ask stuff in #nixos a ton
14:14:04 <chrisdone> merijn: just work on my laptop?
14:14:50 <merijn> chrisdone: That's not an option, because I don't have the relevant software installed. i.e. cluster management libraries, high speed networking libraries, non-free software (like ICC, etc.)
14:14:52 <chrisdone> merijn: or in a VM? i don't get why you have to do that
14:15:20 <chrisdone> i see, that's pretty restrictive
14:15:57 <chrisdone> so you can't connect into a remote ghci instance?
14:16:02 <chrisdone> by any means?
14:16:14 <chrisdone> i wonder whether named pipes can be forwarded over ssh
14:16:31 <merijn> chrisdone: Well, I could, but I don't see why I'd want to? The cluster machines is *much* beefier than my laptop
14:16:45 <luite> i want remote ghc-mod :(
14:16:57 <merijn> chrisdone: SSH allows forwarding unix sockets (and maybe named pipes?) but only since OpenSSH 6.7, which is basically installed nowhere
14:17:24 <merijn> Most systems I SSH into are on 6.0 or 6.2 at best
14:17:28 <gilligan_> chrisdone, http://www.quora.com/How-do-you-forward-UDP-packets-through-an-SSH-tunnel
14:17:46 <gilligan_> chrisdone, not exactly beautiful though
14:18:04 <merijn> chrisdone: UDP is not named pipes
14:18:06 <merijn> eh
14:18:09 <chrisdone> luite: have you tried ghci-ng? =3
14:18:10 <merijn> s/chrisdone/gilligan_
14:18:32 <chrisdone> gilligan_: how does that relate to named pipes?
14:18:53 <gilligan_> chrisdone / merijn : meeh, sorry. please ignore
14:19:01 <luite> chrisdone: hehe not yet. btw would it help ghci-ng if the ghc-bin package was available as a lib or merged into the ghc lib?
14:19:03 <chrisdone> gilligan_: <3
14:19:28 <chrisdone> luite: no idea, i'm not familiar with that package
14:19:55 <luite> chrisdone: it contains the ghci bits and command line parser for ghc (the /ghc subdir in the git repo)
14:20:10 <m_m> hi. Could you tell me what is wrong with this 'let' ? http://lpaste.net/5868482282045571072
14:20:50 <chrisdone> luite: perhaps. i'm technically patching the contents of ghc/
14:20:57 <gilligan_> chrisdone, perhaps worth trying if this actually works ssh user@targethost 'cat > inbound_namedpipe' < outbound_namedpipe &
14:21:09 <geekosaur> x m_m: is not a list and generateList already is one
14:21:20 <bennofs> chrisdone: can't you just forward stdin / stdout over UDP? Is the problem with that that the interactive program already outputs to stdout/stderr and reads from stdin and you need a separate channel?
14:21:30 <geekosaur> so x ++ [generateList y] has two type errors, at least
14:21:40 <merijn> m_m: You probably wanted "x : generateList y"
14:21:50 <luite> chrisdone: it's not really designed to be used as a lib, but i'd like to starty by making it available. then only the parts that need to be changed need to be copied into ghci-ng/ghc-mod/ghcjs, instead of everything
14:22:37 <merijn> chrisdone: Anyway, the way I plan to solve forwarding for tmux is the following: tmux has a command mode where it connects to a local unix socket, so I will just ssh to remote host, run tmux in command mode, which will cause it to relay stdin/stdout to the relevant unix socket
14:22:43 <gilligan_> Fuuzetsu, thanks. I guess i am looking for a good starting point. Some working basics to get started quickly without having to invest too much time on research initially. The article i mentioned seems nice but probably a lot as changed since
14:23:03 <m_m> merijn: I woul like to generate list from number. Ex 999 -> [9,9,9]
14:23:11 <merijn> chrisdone: That way I can just write to/read from the ssh process' stdin/stdout to gain access to the unix socket on the otherside
14:23:40 <tdammers> m_m: you mean, split an integer into its decimal digits?
14:23:49 <m_m> yes
14:24:14 <luite> chrisdone: and hopefully with a few iterations it's modular enough to be able to pull most of the GHC-version-specific bits out of the library, instead of __GLASGOW_HASKELL__ checks in all the packages
14:24:55 <tdammers> > let splitDigits x = if x < 10 then [x] else splitDigits (x `div` 10) ++ [x `mod` 10] in splitDigits 999
14:24:57 <lambdabot>  [9,9,9]
14:25:03 * hackagebot ariadne 0.1.2.3 - Go-to-definition for Haskell  http://hackage.haskell.org/package/ariadne-0.1.2.3 (RomanCheplyaka)
14:25:06 <m_m> merijn: I've got an error with '=' in line 5.
14:25:57 <merijn> m_m: Are you using tabs? Also, if you don't paste the error you leave use to guess what's wrong :)
14:26:52 <geekosaur> that's usually indentation
14:27:03 <m_m> merijn: Error: parse error on input ‚Äò=‚Äô
14:27:06 <intrados> I've used `cabal sandbox add-source foo`. Is there a way to confirm that my package was built with the local version of foo? It isn't acting like it.
14:27:56 <AleksejsHome> m_m: map (\x -> read [x] :: Int) $ show 999
14:27:57 <AleksejsHome> > map (\x -> read [x] :: Int) $ show 999
14:27:58 <lambdabot>  [9,9,9]
14:28:26 <chrisdone> merijn: one nice thing about sockets is multiple connections. e.g. emacs can connect in to run a repl command, and flycheck can connect to load something and get compile errors. is that possible with domain sockets?
14:29:14 <monochrom> it should be "unix domain sockets", because the other one is "internet domain sockets"
14:29:57 <chrisdone> monochrom: leave me alone i have tired fingers =p
14:30:21 <monochrom> :)
14:30:56 <chrisdone> okay so perhaps i do e.g. listenOn (UnixSocket "ghci-ng-1")
14:31:48 <chrisdone> and then emacs or flycheck or vim can connect, send a command, get a reply, and d/c
14:32:16 <chrisdone> if ghci-ng-1 is in use it'll use ghci-ng-2. or some other uniquness scheme (perhaps ghci-ng-project-name)
14:32:16 <luite> chrisdone: i mostly use jump to next error, show type at point, sometimes expand-case/pattern with ghc-mod, is that implemented in the ghci-ng emacs scripts?
14:32:55 <chrisdone> luite: jump to error is supported in regular ghci. type at point is in ghci-ng with some elisp support
14:33:05 <chrisdone> i didn't implement expand-case/pattern yet
14:33:12 <bennofs> chrisdone: hmm, aren't unix domain sockets regular files? I think hdevtools uses unix domain sockets already
14:33:49 <bennofs> chrisdone: hdevtools puts the socket as a .hdevtools.sock file in the project root
14:33:59 <geekosaur> what do you mean by regular files?
14:34:05 <geekosaur> you can't just open() them
14:34:27 <luite> chrisdone: and does ghci-ng work on 7.9 yet?
14:34:56 <bennofs> geekosaur: oh, I just meant "you have to supply a file path to create them and you can list them with ls"
14:35:13 <chrisdone> luite: i tend to just develop on released ghc versions
14:35:15 <AleksejsHome> I have a problem: timeNow = fmap ((!!3) . words . show) getClockTime - it takes hh:mm:ss from current datetime. And I save it in RWS state: {stack <- get; put $ [(timeNow, foo)] ++ stack}. The problem is that when I try to print out stack, for each entry it shows the time when it's printed out, not the time the entry is saved. I know this is because Haskell is lazy and so on, but how to save time the right
14:35:16 <AleksejsHome> way?
14:35:27 <geekosaur> well, even then it's iffy because you can have a dead socket
14:35:56 <geekosaur> it's created by bind(), if the process that did so exited then the socket node is not reusable and can only be removed
14:36:11 <merijn> bennofs: unix domain sockets are visible in the filesystem, but they are not regular files
14:36:16 <chrisdone> geekosaur: or replaced on re-run?
14:36:25 <geekosaur> no, the bind fails if it exists
14:36:38 <chrisdone> ah
14:36:44 <geekosaur> unless someone changed that on e.g. linux which is not impossible but also not portable
14:36:55 <geekosaur> (which would make it par for linux...)
14:36:58 <bennofs> Yeah, that was the problem with hdevtools. when it crashed, the node was still there and you couldn't restart it
14:37:47 <chrisdone> bennofs: that's not bad, the placing i mean
14:38:04 <chrisdone> a .ghci-ng.sock file would be good
14:38:29 <chrisdone> easy to locate for connecting to
14:38:42 <chrisdone> that's certainly the downside of internet ports
14:40:04 * chrisdone makes a test program
14:41:01 <monochrom> if you want to use an internet domain socket, I have an idea. during binding, you can specify "accessible from 127.0.0.1 only"
14:41:33 <monochrom> that should be as good as unix domain socket in terms of "don't let another computer connect"
14:41:41 <AleksejsHome> anyone?
14:41:54 <bennofs> monochrom: the problem is that another user with less privileges could connect
14:42:05 <bennofs> monochrom: one the same computer
14:42:13 <monochrom> yes, that's true.
14:42:16 <chrisdone> monochrom: i suggested the same to merijn but he complained he's using a shared computer at uni
14:42:46 <geekosaur> AleksejsHome, if you used = then you are storing an IO action. how actual code?
14:42:47 <geekosaur> @paste
14:42:48 <lambdabot> Haskell pastebin: http://lpaste.net/
14:43:12 * monochrom did not learn from history and suggests the refinement of "when somethings connects, ask identd about who is connecting"... :)
14:43:51 <monochrom> the road to hell is paved with well-intended identd! :)
14:43:55 <chrisdone> monochrom: hm. true -- is there a downside to using identd?
14:44:02 <luite> chrisdone: bah ;) i have to work with 7.9 now or i run the risk of running into trouble later with ghcjs. the backpack/PackageKey changes already broke my hack for TH dependencies :(
14:44:06 <geekosaur> it's not trustworthy
14:44:35 <geekosaur> and, if the shared machine isn't already running an identd, you can't start one...
14:44:42 <chrisdone> bleh
14:44:49 <monochrom> yes. minor downside: not always installed. major downside: what geekosaur said. history has shown that it disappoints. thus the "did not learn from history" :)
14:46:24 <monochrom> unix-domain socket is a good way to go. it is still a socket, you use it like a socket.
14:46:48 <monochrom> you probably just need to install enough exception/signal handlers to remember to remove it
14:47:31 <geekosaur> try to bind() it, if it fails then try to connect() on it, if it fails then remove it and bind()
14:47:56 <AleksejsHome> geekosaur: something like that http://vpaste.net/FVaR9
14:48:38 <geekosaur> ok, so timeNow is an IO action, you want the *result* of the action
14:48:45 <merijn> monochrom: chrisdone's objection against unix sockets was lack of windows support
14:49:11 <geekosaur> `now <- timeNow` and then store `now` in the state
14:49:24 <geekosaur> (probably need to liftIO it)
14:49:32 <merijn> monochrom: At which point I suggested named pipes, I don't object to ghci-ng *also* supporting tcp, as long as I can use something with sane amounts of security on *nix :)
14:50:52 <lpaste> chrisdone pasted ‚ÄúUnix domain socket server‚Äù at http://lpaste.net/113599
14:51:03 <lpaste> chrisdone annotated ‚ÄúUnix domain socket server‚Äù with ‚ÄúClient‚Äù at http://lpaste.net/113599#a113600
14:51:07 <chrisdone> easy enough
14:53:14 <bennofs> Hmm, named pipes on Windows seem to work more like unix domain sockets on linux than like named pipes (FIFO) on linux
14:53:25 <chrisdone> heh
14:53:42 <chrisdone> i wonder what the Service constructor is?
14:53:55 <chrisdone> in PortID
14:54:03 <chrisdone> what's that for?
14:54:16 <chrisdone> must be obvious because nobody deemed it worth of documentation
14:54:57 <chrisdone> ahh it's just a string name for a port. ftp = 21
14:55:00 <chrisdone> probably
14:55:17 <bennofs> chrisdone: -- Service Name eg "ftp" says the source :)
14:55:19 <merijn> chrisdone: It uses /etc/services
14:55:51 <merijn> chrisdone: That holds a database of string to number mappings
14:57:28 <chrisdone> this is fine, so i'll have ghci-ng instead of reading from haskeline directly it can read from a Chan Command, and then haskeline will read in lines, parse them into commands and send them to the ghci handler which'll return a response. and likewise the domain socket will accept Commands encoded as JSON, line-separated and forward it onto the chan
14:57:41 <chrisdone> anything involving the ghc api will be single-threaded and synchronous
14:58:04 <chrisdone> other things (like asking for a type or goto-definition) can be multi-threaded as the data is pure
15:00:06 <chrisdone> so you can talk to ghci-ng in the repl
15:00:07 <chrisdone> or echo ":t sort" | nc localhost -U .ghc-ng.sock
15:00:33 <chrisdone> merijn: how's that for a slice of fried gold?
15:01:00 <chrisdone> https://www.youtube.com/watch?v=HQ9nE3_Yn3E
15:01:24 <merijn> netcat supports unix sockets now?
15:01:46 <merijn> oh, indeed it does
15:01:48 <merijn> Neat!
15:02:10 <monochrom> named pipes is also a good option. at some point I can't tell the difference :)
15:02:28 <monochrom> I am also ignorant of what windows doesn't have :)
15:02:31 <bennofs> monochrom: you can't have multiple clients as easy with named pipes (linux)
15:04:47 <chrisdone> right, the multiple clients is a biggy for me
15:06:13 <chrisdone> flycheck is a very well put together UI, but is marred by the fact all of its drivers must be a commandline (as opposed to just an elisp function that returns some error messages), its author said it's too hard to just add support for this because the whole lib expects to call a process
15:06:27 <chrisdone> anyway, now i can probably just make it call netcat
15:09:49 <simon> I'm making an interpreter for an imperative language and I'm trying to figure out the most idiomatic use of reader/state monads: when a variable is updated, it seems I want to use a state, but when the body of a procedure is executed and I want a wiped scope (except parameters), I'd have to run a new state given parts of the old state (e.g. no vtable, same ftable). is there a better structure?
15:12:55 <simpson> simon: What I've done before is exactly that: When entering a procedure/method/object, stash the current scope and provide a new scope.
15:13:41 * tdammers nods
15:13:43 <tdammers> same here
15:14:04 <tdammers> it helps to separate variable values from name bindings
15:14:19 <tdammers> keep the values around, but stash the bindings
15:14:48 <simpson> I really would like to, at some point, investigate using the objective package on Hackage, but I'm still working on grokking it.
15:14:55 <simpson> @hackage objective -- this one.
15:14:55 <lambdabot> http://hackage.haskell.org/package/objective -- this one.
15:19:29 <tsenart> hello folks. haskell newbie here. would anyone be able to help me with this parseMarkets function? I'm hitting the type checking error displayed in the comment above its definition: http://lpaste.net/113601
15:19:34 <mbuffett> Hey guys, how do I avoid having functions in my code that I can't tell where they come from? In Python I have to explicitly import a function or class, but in Haskell it will import all functions at the top-level when I import a library, and I'd like to be able to tell at a glance where a function came from. How do I accomplish this?
15:20:14 <dibblego> mbuffett: I tend to list functions in the import list for this reason (and a couple of other reasons too)
15:20:45 <merijn> tsenart: Your use of >>= makes no sense :)
15:20:47 <merijn> :t (>>=)
15:20:49 <lambdabot> Monad m => m a -> (a -> m b) -> m b
15:20:54 <dibblego> but if someone else hasn't, and you are not sure where a function has come from 1. try hoogle and hayoo to find their module 2. load the source file and use :info
15:20:59 <merijn> tsenart: Note that 'm' is the same in all cases
15:21:17 <dmj`> tsenart: fromJSON doesn't return Either String Value
15:21:18 <dmj`> fromJSON :: FromJSON a => Value -> Result a
15:21:19 <mbuffett> Sounds good, haskell tells me that it's a redundant import if I try that though, because I have it as a dependency in my .cabal file
15:21:22 <tsenart> so I can't compose two different mondas?
15:21:23 <merijn> tsenart: fromJSON returns a Result, but parseData returns Either, which doesn't match :)
15:21:25 <tsenart> monads'
15:21:57 <tsenart> how do I compose two different monads?
15:21:57 <merijn> tsenart: Not in this way, no
15:22:13 <merijn> tsenart: In this case I would either pattern match or use
15:22:14 <merijn> :t either
15:22:16 <lambdabot> (a -> c) -> (b -> c) -> Either a b -> c
15:23:49 <merijn> tsenart: Or like this: http://lpaste.net/113601
15:24:41 <tsenart> merijn: cool, thanks for the help
15:26:03 <simon> simpson, and you'd "stash" this scope by 'runState (eval body) scopedEnv' or by maintaining a stack within the same state?
15:26:30 <merijn> mbuffett: You can do explicit imports like python's in haskell too
15:26:57 <merijn> mbuffett: "import Control.Monad (forever)" only imports the forever function (and any typeclass instances, because typeclass instances are global)
15:27:02 <mbuffett> Is there a way to stop haskell from warning me that it's a redundant import?
15:27:12 <dibblego> mbuffett: why not delete it?
15:27:39 <mbuffett> Delete the dependency in the .cabal file?
15:27:56 <dibblego> no, delete the redundant import
15:27:57 <merijn> mbuffett: You haven't pasted any code or errors, so people can only guess what you mean
15:28:11 <mbuffett> Sorry, I'll paste what I have in a second
15:28:17 <chrisdone> i comment out an import if ghc is bugging me about it
15:28:21 <chrisdone> i usually want it later
15:29:26 <simpson> simon: Or similar, yeah. I use EitherT and a bracket, but anything like that will work.
15:29:42 <simon> simpson, a bracket?
15:29:57 <simon> simpson, yeah, it will work. just wasn't sure if it was as idiomatic as possible. :)
15:30:00 <merijn> :t bracket
15:30:01 <lambdabot> IO a -> (a -> IO b) -> (a -> IO c) -> IO c
15:30:27 <monochrom> delete the flag that requests warnings :)
15:30:52 <mbuffett> http://lpaste.net/113605
15:31:18 <absence> is there a way to "try" a monadplus computation to detect failure without failing the whole thing?
15:31:36 <dibblego> mbuffett: just delete line 1. I am not sure how the .cabal file is relevant here.
15:32:00 <dibblego> absence: there is a way of doing that with applicative, which is implemented in the validation package
15:32:19 <mbuffett> But I'm trying to make it explicit where each function comes from, it's not a huge issue but it would be nice to know where everything is coming from, and to not get functions I don't want
15:33:01 <dibblego> mbuffett: but watchDir has not been used, so why would anyone care where it came from in that source file?
15:33:27 <monochrom> you need to use watchDir for real if you want it to be non-redundant.
15:34:03 <chrisdone> simpson: does your language need to be able to have references to undefined variables?
15:34:19 <absence> dibblego: what's it called?
15:34:25 <chrisdone> simpson: which will throw an exception at runtime if referenced?
15:34:33 <simpson> chrisdone: Well, *my* language actually has static names and static namespaces.
15:34:53 <simpson> chrisdone: But we're still working on efficient models of computation for it, and the current compiler's kind of half-assed. Doesn't even rename stuff properly.
15:36:01 <chrisdone> simpson: i see. because you could use a HOAS representation and avoid carrying around environments, let haskell do that for you. if it's just an interpreter, that is
15:36:08 <simpson> What I'd like to do, eventually, is read in my AST, put it into a free monad and use the bound package to rename names, put it into a cofree comonad and do optimization and type analysis, and then put it into objective and just have a bunch of objects swimming in Haskell.
15:36:19 <chrisdone> oh god
15:36:22 <chrisdone> ok good luck to you
15:36:25 <simpson> And honestly most of my time is spent being sad that RPython exists.
15:37:09 <chrisdone> freecakebanancopotato
15:37:37 <dibblego> absence: AccValidation (accumulating validation)
15:37:40 <simpson> Well, I mean, it's easy to have a Fix AST, and then that can be made into Free AST a, which is great for doing free variable binding.
15:37:58 <simpson> And then you can pull it back into Fix AST, and then Cofree AST a, which is great for annotating and optimizing.
15:43:35 <arielsanflo> haskell-es canal?
15:44:23 <arielsanflo> how intro #haskell-es
15:44:51 <absence> dibblego: hmm.. couldn't figure out that one, but it seems "liftM Just theComputation `mplus` return Nothing" does the trick :)
15:45:04 <dibblego> absence: ok
15:46:10 <merijn> Ok, so I know cabal is making haddock generate hoogle text files, but I have no clue where those are ending up on my system?
15:46:37 <simpson> arielsanflo: Lo siento; no hay #haskell-es.
15:47:09 <arielsanflo> ups
15:48:35 <qsuscs> arielsanflo: pero hay #haskell.es; por entrarlo, debes ingresar ‚Äú/join #haskell.es‚Äù en tu cliente IRC
15:49:41 <woffordrk> #join leiningen
15:49:55 <arielsanflo> fine thanks
15:50:09 * hackagebot gl 0.1 - Complete OpenGL raw bindings  http://hackage.haskell.org/package/gl-0.1 (EdwardKmett)
15:52:12 <Thule> Hi guys. I have a question concerning the definition of primitive recursion. The code on this page: http://lpaste.net/113606 is NOT primitive recursive right?
15:52:57 <merijn> Thule: Can you clarify what you mean with "not primitive recursive"?
15:53:07 <Thule> Is it primitive recursive or not? :)
15:53:15 <Thule> the compilepoly function
15:54:44 <merijn> "Primitve recursive" is a class of functions, considering compilePoly is just using structural recursion (and structural recursion is just a subset of primitive recursive functions, iirc) I would say "yet it is"
15:56:14 <Thule> hmm.. I thought it was general recursion, because it recurses over 2 Poly (compilePoly p1 and compilePoly p2)
15:56:43 <monochrom> that does not violate the requirements of primitive recursion
15:57:07 <Thule> so a function can be both general recursive and primitive recursive?
15:58:12 <monochrom> that is a strange question. it is the same question as "can a geometric shape be both a quadrilateral and a square?" but anyway the answer is yes.
15:59:29 <Thule> monochrom it is because my function of compilePoly has to be primitive recursive, and I am trying to understand whether it is or not. I thought it was NOT because it recurses over 2 poly. Like the zip function iterates over 2 lists
16:00:15 <monochrom> how many times you mention compilePoly does not matter. what kind of parameters you give does. focus on the parameters.
16:00:55 <Thule> Ahh. So because I only get 1 parameter it is still primitive, whereas zip gets 2
16:01:10 <monochrom> no, not the number of parameters. what kind.
16:02:12 <monochrom> compilePoly (PMul p1 p2) = .... compilePoly (PAdd (PMul p1 p2) (PMul p1 p2)) ... is not primitive
16:02:53 <Thule> how come? I cannot see the reason.
16:03:20 <monochrom> recursive call has "bigger" parameters
16:03:58 <monochrom> I am too lazy to detail the exact requirements. please refer to your course material and instructor.
16:04:15 <Thule> bigger parameters.. ok. Thank you
16:05:10 * hackagebot EqualitySolver 0.1.0.0 - A theory solver for conjunctions of literals in the theory of uninterpreted functions with equality  http://hackage.haskell.org/package/EqualitySolver-0.1.0.0 (dillonhuff)
16:05:10 <marchelzo_> i have a reallt naive and possibly stupid question. Is there a way to make 64 bit ghc out put 32bit executables / object code?
16:05:16 <marchelzo_> s/reallt/really
16:05:47 <pingu> marchelzo_: what you're asking for is GHC cross compilation
16:05:53 <merijn> marchelzo_: It's neither naive nor stupid, but I fear the answer is "probably not without quite some hassle"
16:06:06 <pingu> I'm not sure if it can, but this will probably tell you https://ghc.haskell.org/trac/ghc/wiki/CrossCompilation
16:06:13 <merijn> marchelzo_: People are working on cross-compilation in GHC, but I don't think it's ready for primetime yet
16:07:13 <marchelzo_> well the main problem that I want to solve is that when I try to compile, I get this: http://lpaste.net/113609
16:07:40 <marchelzo_> I'm assuming it's because of 32 bit / 64 bit incompatibilities
16:09:34 <pingu> marchelzo_: urgh, it's like whatever is doing your assembly is getting the wrong kind. I'm not sure what drives that. You may get more help from ghc-dev if you can reproduce with the 'official' installation instructions (whatever they are) on HEAD.
16:10:08 <pingu> marchelzo_: basically, could be a bug, ask for help from GHC devs *after* you make sure you aren't getting your GHC from somewhere weird and doing something wrong.
16:10:25 <pingu> marchelzo_: how did you get that ghc installed?
16:10:32 <marchelzo_> pingu, if it helps, I am using the FFI to call Haskell from C, and I am trying to link to a 32 bit library
16:10:55 <marchelzo_> it's from Haskell Platform
16:11:04 <pingu> oh, so it only breaks when using an external linker?
16:11:41 <pingu> well then if you're producing 64 bit code and try to link with a 32 bit linker, I don't see that going well.
16:12:52 <pingu> marchelzo_: so you'll want to build your main driving program as 64 bit if your haskell symbols are exported as 64
16:13:01 <pingu> alternately yeah, build your haskell bits as 32 bit
16:14:13 <marchelzo_> I think the problem is that the library is 32 bit and I don't how to get a 64 bit version of it
16:14:31 <pingu> well yes, if you don't know how to get a 64 bit version of it that's a probem
16:14:35 <marchelzo_> because when I generated 64 bit code, the linker said that it was skipping the library because it was incompatible
16:15:26 <pingu> you could possibly use tricks like nspluggin did
16:15:30 <pingu> *nsplugin
16:15:38 <pingu> and wrap the 32 bit plugin with IPC
16:15:47 <pingu> 32 bit library
16:15:50 <pingu> but thats kind of nasty ;)
16:17:55 <marchelzo_> hmm
16:18:23 <pingu> or yeah, install a 386 GHC and you should be fine so long as you never have to mix in a 64 bit library
16:18:42 <pingu> marchelzo_: https://ghc.haskell.org/trac/ghc/wiki/Building/Compiling32on64
16:18:57 <naiyte> noob here: what would be the function signature for a function that has a function parameter? e.g., 'coolFunc f x = f x' where f is a function
16:19:02 <naiyte> Arbitrary example, I know
16:19:14 <naiyte> But I'm not sure how to specify that it's supposed to a function in the signature
16:19:16 <pingu> (arg1 -> result)
16:19:25 <merijn> naiyte: Well, that depends on the type of 'x' and whatever coolFunc is supposed to return :)
16:19:43 <merijn> naiyte: Suppose 'x' is a Char, then one potential type would be
16:19:57 <pingu> naiyte: try opening up GHCI
16:19:59 <merijn> naiyte: "coolFunc :: (Char -> Bool) -> Char -> Bool"
16:20:20 <pingu> and entering: let coolFunc f x = f x
16:20:23 <pingu> then :t coolFunc
16:20:29 <pingu> and ghci will tell you
16:20:43 <merijn> naiyte: But this would also be valid: "coolFunc :: (Char -> b) -> Char -> b" or even "coolFunc :: (a -> b) -> a -> b"
16:21:05 <naiyte> Awesome, that helps a lot. Thanks merijn and pingu!
16:21:09 <merijn> naiyte: Note that your coolFunc happens to just be 'id :: a -> a' :)
16:21:17 <naiyte> Yeah, I think I see that now
16:21:21 <pingu> merijn: ??
16:21:24 <pingu> don't you mean ($)?
16:21:30 <merijn> pingu: ($) is id too
16:21:40 <jle`> yeah but it can't unify with (a -> a) i think
16:21:44 <merijn> > (+) 1 `id` 2
16:21:46 <lambdabot>  3
16:21:47 <jle`> it can only unify with ($)
16:21:50 <merijn> > (+) 1 $ 2
16:21:52 <lambdabot>  3
16:22:00 <pingu> merijn: id is more general
16:22:01 <pingu> I'd think
16:22:03 <merijn> Sure, it's a type-restricted id
16:22:04 <pingu> hence ($) can't unify
16:22:17 <pingu> merijn: you could think of a lot of functions as a type restricted id ;)
16:22:20 <jle`> :t let coolFunc f x = f x; coolFunc :: (a -> a) in coolFunc
16:22:21 <lambdabot>     Couldn't match expected type ‚Äòt1 -> t0‚Äô with actual type ‚Äòa1‚Äô
16:22:21 <lambdabot>       ‚Äòa1‚Äô is a rigid type variable bound by
16:22:21 <lambdabot>            the type signature for coolFunc :: a1 -> a1 at <interactive>:1:37
16:22:38 <jle`> ~
16:22:51 <jle`> coolFunc isnot id :: a -> a, it's id :: (a -> b) -> (a -> b) :)
16:22:54 <merijn> :t let coolFunc :: (a -> b) -> a -> b; coolFunc = id in coolFunc
16:22:55 <lambdabot> (a -> b) -> a -> b
16:23:46 <merijn> > let coolFunc :: (a -> b) -> a -> b; coolFunc = id in coolFunc even 1
16:23:48 <lambdabot>  False
16:24:10 <jle`> yeah, so coolFunc is id :: (a -> b) -> (a -> b), not id :: a -> a
16:24:22 <jle`> or maybe i am going about this backwards
16:24:47 <merijn> jle`: I said coolFunc was id, I didn't say id was coolFunc
16:24:47 <pingu> jle`: how would you go about this forwards?
16:25:03 <jle`> "Note that your coolFunc happens to just be 'id :: a -> a' :)"
16:25:29 <jle`> but maybe i am approaching this from a backwards direction
16:25:56 <jle`> in any case it's probably not worth discussing v.v
16:26:23 <pingu> yeah, coolFunc has identity issues anyway.
16:26:52 <naiyte> Yeah, it was a bad example
16:29:48 <Casium> Hey everyone, just wondering, seeing as Haskell is supposed to be good with multicore programming and stuff, would it be easy enough to write (for example) a 2D game engine in it, and would there be any speed benefits as a result of doing so?
16:31:15 <pingu> Casium: games generally have latency/GC requirements ahead of raw parallel speed
16:31:40 <pingu> so I'd say that haskell can probably do it but certainly not designed for it, or even the pest choice in terms of performance
16:31:56 <merijn> I think haskell would be decent as language for 2D games that are not very latency sensitive (i.e. no twitch platformers)
16:32:19 <pingu> Casium: rust might be interesting if latency is an issue.
16:32:43 <Casium> ah right, thanks for your reply :)
16:32:43 <merijn> So it depends on the kind of game you plan to make. Also doing game development in haskell might not be the easiest place to start if you're not already comfortable with hacking haskell :)
16:32:47 <Casium> rust..?
16:32:59 <merijn> Rust seems pretty cool, but it's still rather unstable
16:33:29 <pingu> Casium: rust is starting to become more stable, it's taken a lot of inspiration from haskell and built by mozilla.
16:33:41 <naiyte> John Carmack had some interesting things to say about the benefits of functional programming for games. Apparently he rewrote Wolfenstein in Haskell (or part of it at least). I think he was more leaning towards how functional paradigms could be used in C++ to improve their engines, though
16:33:43 <merijn> Well, I wouldn't call Rust haskell inspired
16:34:05 <merijn> Rust, unlike most other new languages just doesn't ignore the past 4 decades of static type research :p
16:34:09 <Casium> pingu: thanks for you replies
16:34:42 <exio4> merijn: research? that is some thing that can't be used by average programmers, you need a phd for that thing!
16:34:52 <Casium> was just wondering as I've fallen in love with haskell, and am trying to find some interesting uses for it
16:35:32 <jle`> Casium: check out #haskell-game :)
16:35:34 <merijn> Casium: This may be an interesting presentation: www.cs.princeton.edu/~dpw/popl/06/Tim-POPL.ppt
16:35:39 <jle`> ther eare a lot of people building games with haskell
16:35:47 <pingu> Casium: certainly a 2D engine would be neat and useable. I think that you should be able to overcome any noticeable latency issues with a bit of smarts.
16:35:49 <jle`> and there's that big game studio that recently switched to haskell i think
16:35:51 <merijn> Casium: Tim Sweeney (from Epic Games) talks about "the next mainstream programming language"
16:38:12 <Casium> thank you all for replies :)
16:39:30 <jle`> Casium: the hardest part about modern haskell game development i think is that it's hard to really find good tutorials already laid out, and the ecosystem/toolkit support is a bit of a jungle at the moment.  but i don't think there is anything inherent about haskell that makes it bad for 2d game dev.  in fact, i think in many ways, it makes it even better/easier/more flexible
16:40:43 <jle`> i happen to find haskell as one of the ideal *languages* of game development.  now we just make the ecosystem there to make it the ideal *platform*/ecosystem as well :)
16:40:49 <JonReed> http://youtu.be/1PhArSujR_A?t=3m16s
16:40:58 <JonReed> John Carmack talking about Haskell
16:40:59 <Casium> hmmmm, yeah, I haven't been able to find a whole lot about it online haha, and all the stuff that I have found has been pretty difficult to follow, especiall with my primitvie knowledge of the language :(
16:41:39 <Casium> But I will definitely be looking much more into it, it seems like an interesting challenge..
16:42:12 <naiyte> So I don't typically like to ask for help on homework, but I'm really stuck on this one. (Tired so my brain is not at 100%.) Could anybody give me a hint or a nudge in the right direction on this? http://lpaste.net/113611
16:42:35 <jle`> Casium: you'll get there :)  what do you normally program?
16:43:30 <jle`> just think about how long it took you to know enough about programming oringally to program a game in your first programming language
16:43:34 <jle`> and then look at how you are now
16:43:38 <jle`> that always makes me feel better
16:43:51 <JonReed> In 3D there's cuboid code that can be looked at
16:43:52 <JonReed> https://github.com/pedromartins/cuboid
16:43:58 <JonReed> https://www.youtube.com/watch?v=T3xXebIr8AM&list=PLxj9UAX4Em-Lz5btngxMVZxf_B44GETVz
16:44:35 <JonReed> Here's the explanation of the code.
16:44:40 <merijn> naiyte: Pretty sure the base case works, but consider the following: What is foldl doing and what's the type of "listApply f tail"?
16:45:02 <monochrom> naiyte: I have two hints. it seems foldr is more appropriate than foldl. you will need more than one foldr. it is either two foldr's or one map one foldr.
16:46:08 <naiyte> Ah yes, I think I see where you two are going
16:46:15 <JonReed> Sry, it was part 2. Here's the first lecture on haskell deconstructed explaining how cuboid code works. https://www.youtube.com/watch?v=T3xXebIr8AM
16:46:22 <naiyte> Let me give it another shot with those two tips, and I'll report back. :) Thank you
16:46:40 <monochrom> or two levels of recursion, if you write your own recursions rather than use map, foldr, etc
16:48:06 <naiyte> So is using `((head):tail)` as a parameter valid for a nested list?
16:48:37 <merijn> naiyte: Yes
16:48:48 <merijn> naiyte: But what does that mean for the type of head? :)
16:49:03 <naiyte> It means head is a list?
16:49:38 <JonReed> It would be great if Haskell would have a site like pyvideo.org, where there would be all Haskell videos and lectures for people to search and learn from. Right now videos are painfully hard to find, despite that there are enoug of them on youtube and vimeo
16:49:39 <merijn> naiyte: Correct
16:50:35 <exio4> has anyone used https://github.com/osa1/hsSDL2-ttf/? rendering utf8 text (under windows) doesn't seem to work properly (fwiw, it works under linux)
16:50:54 <Casium> jle`: sorry, i went for washing. I have written a little bit of C/C++, Java and Python mostly, but I'm doing Haskell for a uni course, and I think it's an awesome language haha
16:56:48 <d34df00d> Hi!
16:57:35 <d34df00d> Imagine I have a function mapping an aminoacid to its weight:
16:57:42 <d34df00d> https://bpaste.net/show/58631a6e93db
16:58:06 <d34df00d> What's the best way for me to just get the list of all possible values of this function?
16:58:26 <haasn> data Amino = G | A ... | W deriving Enum
16:58:32 <haasn> map aminoWeight [G..W]
16:58:35 <Erraunt> Hi. I am wondering how hard is it to implement algorithms which need array data structure in haskell ?
16:58:41 <merijn> haasn: Better yet, Enum+Bounded
16:58:44 <haasn> Or that.
16:58:51 <haasn> map aminoWeight [minBound..maxBound]
16:58:52 <d34df00d> Oh, great, thanks for the hint!
16:58:55 <merijn> And then "map aminoWeight [minBound .. maxBound]"
16:59:18 <merijn> Erraunt: Well, there's several highly optimised array/vector libraries for haskell
16:59:41 <merijn> Erraunt: So I would say "not that hard"
16:59:57 <merijn> Erraunt: vector and repa are good starting places, also #numerical-haskell
17:00:04 <naiyte> merijn, monochrom, does this look like I'm more on the right track? Added it to the bottom here: http://lpaste.net/edit/113611 (Run foldr on the inner list and then map f to each of those resultant vals)
17:00:37 <naiyte> Er, just saved it
17:01:12 <naiyte> http://lpaste.net/113611 I mean, not the edit link
17:01:23 <Erraunt> merijn: how does that work with the immutability principle? I am wondering would it be possible to use haskell in coding algorithmic coding competitions
17:01:36 <merijn> naiyte: Do you need the recursive listApply? :)
17:02:44 <merijn> Erraunt: Haskell values are immutable, but that doesn't mean you can have an immutable datatype that is a reference to a "mutable memory location"
17:03:05 <merijn> Erraunt: Of course, reading from/writing to a mutable memory location is a side-effect, which requires you to be in IO
17:03:38 <merijn> Erraunt: Have a look at, for example "Control.Concurrent.MVar" (although repa/vector are far more efficient internally)
17:03:40 <yesthisisuser> why is that required for a coding competition though?
17:04:54 <yesthisisuser> isn't the objective usually to write an algorithm that produces a correct answer efficiently?
17:05:13 <merijn> Erraunt: There's also immutable vectors, but they're rather slow if you update frequently (you either need to copy the entire vector *or* have a bunch of "update" object that you traverse to get to the base array"
17:06:11 <Erraunt> merijn: ok, thanks.
17:13:55 <rs0> merijn: isn't there a HAMT-based implementation of an immutable persistent vector, like in Clojure?
17:14:09 <merijn> I have no clue what that means
17:14:17 <merijn> Also, what does persistent mean in this context?
17:14:35 <rs0> meaning you can cheaply create altered copies of a given vector
17:14:44 <rs0> through the use of structural sharing internally
17:14:55 <rs0> you don't have to copy the entire thing
17:15:00 <rs0> https://en.wikipedia.org/wiki/Hash_array_mapped_trie
17:15:43 <merijn> rs0: Right, that's what I was referring too, but that's still slow
17:16:02 <merijn> If you want high performance vector operations you want mutable vectors anyway
17:16:43 <rs0> actually that doesn't sound like what you were describing at all
17:17:12 <rs0> copying the entire vector is a naive implementation. adding on "update" objects is less naive, but it's WAY slower and it sort of accumulates garbage indefinitely
17:17:50 <merijn> How would you do "structural sharing" without creating an update object indirection?
17:18:11 <hakujin> rs0, merijn: looks like this is what you want? https://hackage.haskell.org/package/persistent-vector-0.1.0.1
17:18:38 <rs0> hakujin: yup, that's the stuff
17:19:13 <naiyte> merijin and monochrom: I think I figured it out! Thanks for the tips, very helpful. :)
17:28:18 <naiyte> listApply f xs = map (\x -> foldr f 0 x) xs
17:29:00 <naiyte> Er, at least it works if the func isn't something like (*). Is there a better way to handle the first element for foldr?
17:29:13 <naiyte> The examples used (-) and (+) which give the right answers
17:29:41 <Hijiri> you could add another parameter for passing in the first element
17:29:51 <Hijiri> then you can choose 1 for multiplication, etc
17:29:59 <naiyte> Good idea, thanks
17:30:02 <Hijiri> but then it will just be mapping foldr
17:30:31 <Hijiri> is that what you're going for?
17:31:07 <naiyte> xs is a nested list, so it's folding each sublist
17:31:21 <naiyte> [[1,2],[3,4] -> [3,7]
17:31:40 <naiyte> Er, if that was called with (+). i.e., listApply (+) [[1,2],[3,4]]
17:36:48 <vixlur> naiyte: you can use foldr1 (let listApply f = map (foldr1 f)) if sublist cant be empty
17:39:04 <naiyte> That works better, thanks vixlur
17:42:17 <rcharles> can someone tell me the difference between Data.Text and Data.ByteString.Char8. Also why don't we have a standard, more efficient way of representing Strings in Haskell?
17:43:00 <geekosaur> the latter is (a) rather fake (b) supports exactly bytes (octets), whereas Text supports Unicode
17:43:08 <merijn> rcharles: Data.ByteString.Char8 is pure and utter evil and using it is equal to asking satan to abduct your children
17:43:21 <geekosaur> and definitions of efficiency differ; String can fuse away completely
17:43:27 <merijn> rcharles: Data.Text *is* the standard efficient way of representing String
17:43:30 <geekosaur> which ends up being far more efficient
17:44:12 <merijn> s
17:44:13 <rcharles> merijn: lol
17:44:30 <rcharles> geekosaur: I am not sure what you mean
17:45:58 <rcharles> most of the books I have read about Haskell more-or-less tell you to stay away from String for anything but the most simple of tasks
17:46:02 <geekosaur> if it fuses away, you never have an actual String, you have a sort of pipeline of functions operating on a stream of characters
17:46:53 <rcharles> but those stream of characters are each contained as an element in a link list. no?
17:47:14 <geekosaur> but if you're working in ghc or compiling without optimization, or doing things that defeat fusion (mostly, sharing) then fusion doesn't happen
17:47:16 <geekosaur> nope
17:47:25 <geekosaur> each character si generated and consumed without ever creating a list
17:47:30 <xplat> geekosaur: ghci you mean
17:47:33 <geekosaur> which is why it's a string
17:47:36 <geekosaur> yes, that was a typo
17:47:38 <geekosaur> ghci
17:47:43 <geekosaur> and, whic is why it is a stream
17:48:04 <geekosaur> (ugh, I should back out and let people who can type what they are thinking answer...)
17:48:12 <xplat> there's also some fusion that can happen for bytestrings and texts though
17:49:12 <rcharles> geekosaur: I see where you are coming from. I was unaware of that though
17:51:08 <prinsen> If I'm parsing Strings in parsec, but the result of all productions are just the matched strings, is there any convenience function?
17:51:46 <prinsen> Instead of doing do { s1 <- string "first"; s2 <- string "second"; return $ s1++s2 }
17:54:57 <merijn> prinsen: Applicative :)
17:55:08 <merijn> or liftM2 in this case
17:57:01 <prinsen> the monomorphismrestriction is a pain in the as when writing parsers
17:57:43 <rcharles> prinsen: you can try - (++) <$> string "foo" <*> string "bar"
17:59:01 <prinsen> Sure but i was looking for some parsec magic that works with longer productions aswell :)
17:59:05 <zwer> or functionally the same (but IMO nicer looking): liftA2 (++) (string "foo") (string "bar")
18:00:04 <zwer> prinsen will work with more arguments, just add more <*>s. and there are liftAN up to some N number (can't recall off hand)
18:00:28 <Belahzur> is parsec hard to learn?
18:00:56 <rcharles> prinsen: I do not think parsec offers such a convenience function
18:01:13 <Belahzur> i am new to haskell (for the 3rd time) :)
18:02:01 <rcharles> Belahzur: I know what you mean. this is about my tenth time returning to the language. Something about it keeps me coming back
18:02:01 <merijn> Belahzur: I don't think so
18:02:34 <merijn> Belahzur: Real World Haskell has a chapter on haskell, the code snippets are out of date (so don't expect them to work), but the high level explanation is still accurate
18:02:52 <prinsen> Belahzur: I had never used it before and found it quite easy
18:04:04 <rs0> any news on the proposed second edition of real world haskell?
18:07:38 <Belahzur> by the way, I asked in haskell-beginners and there seems to be a lack of concensus whether to, as a beginner, install haskell platform or bare ghc (to avoid cabal hell? or something). anyone else has some thoughts on that
18:08:49 <benzrf> ghc!!!!!
18:09:10 <Belahzur> haha
18:09:19 <merijn> I'd say platform
18:09:28 <merijn> Hell, I just install platform myself
18:09:34 <merijn> Actually, I guess it depends on your OS
18:09:43 <benzrf> that is because you are apparently a pleb, merijn
18:09:44 <silver> sandboxes solve cabal hell
18:09:48 <merijn> A lot of linux distro's seem to like to cripple the platform installation in weird ways
18:11:29 <fluffynukeit> hi all.  Is there any haskell library that provides low level FFI bindings to GTK?  I want to create a window and get back a Ptr GtkWidget to pass to other FFI calls.
18:12:09 <fluffynukeit> the gtk haskell package wraps everything in Haskell data types, and I don't see any way to get to the underlying pointers, hence my question
18:12:23 <Belahzur> if I got it right from reading that guide with sandboxed each projects downloads its own libraries, which is incompatible with haskell platform way which is shipping ghc with a lot of libraries?
18:12:51 <Belahzur> and this is worthwhile? it makes compiling slower though, no?
18:15:49 <merijn> Anyone run into issues with cabal not installing dependencies for tests into a sandbox?
18:16:50 <hexagoxel_> with install --enable-tests --only-dependencies?
18:17:10 <merijn> hexagoxel_: Yeah
18:19:08 <prinsen> Is there any interest for code review? Im writing a ECMA-262 interpreter as my first large haskell library and would love feedback
18:27:25 <rfn> :t nextRandom
18:27:26 <lambdabot> Not in scope: ‚ÄònextRandom‚Äô
18:27:41 <rfn> :t Data.UUID.V4.nextRandom
18:27:42 <lambdabot> Not in scope: ‚ÄòData.UUID.V4.nextRandom‚Äô
18:33:46 <merijn> ugh, debugging daemons sucks >.<
18:35:19 * hackagebot half 0.1 - Half-precision floating-point  http://hackage.haskell.org/package/half-0.1 (EdwardKmett)
18:36:06 <pharaun> anyone here familiar with esqueleto ? - http://lpaste.net/113616 - I'm attempting to add case_ support to it
18:36:12 <pharaun> and types are giving me a headache
18:36:17 <pharaun> i feel like i am missing something?
19:05:05 <merijn> Does trace print to stdout or stderr?
19:12:58 <ij> Can I get the fd of a handle? I know it has one.
19:13:01 <gamegoblin> merijn: stderr
19:13:53 <gamegoblin> ij: yes you can
19:13:54 <merijn> ij: Yes, but it closes and flushes the handle
19:13:55 <ij> handleToFd, nvm.
19:14:02 <gamegoblin> @hoogle Handle -> Fd
19:14:02 <merijn> So using the handle afterwards is an error
19:14:05 <lambdabot> System.Posix.IO.ByteString handleToFd :: Handle -> IO Fd
19:14:05 <lambdabot> System.Posix.IO handleToFd :: Handle -> IO Fd
19:14:05 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
19:14:39 <ij> Why.. is that?
19:15:19 <merijn> ij: Otherwise you can have one part of the code using a Handle and the other and Fd resulting in weird race conditions and interactions with buffering, etc.
19:15:22 * hackagebot half 0.1.1 - Half-precision floating-point  http://hackage.haskell.org/package/half-0.1.1 (EdwardKmett)
19:15:24 * hackagebot gl 0.2 - Complete OpenGL raw bindings  http://hackage.haskell.org/package/gl-0.2 (EdwardKmett)
19:15:45 <ij> But I know what I'm doing.
19:15:54 <ij> Should I coerce then?
19:16:12 <ij> Oh, but that'll execute the closing too, right?
19:18:05 <merijn> ij: No, coerce will just segfault your program...
19:18:18 <merijn> You use both a Handle and it's Fd in a safe way
19:19:17 <ij> And that is?
19:19:33 <merijn> eh
19:19:35 <merijn> *can't*
19:20:46 <ij> So I can't just get the fd without making it useless?
19:22:03 <merijn> Wut
19:22:16 <merijn> The *Handle* is useless afterwards
19:22:52 <ij> Oh, sorry. I thought it didn't dup it.
19:22:54 <ij> Thanks.
19:24:58 <ij> The source of the function doesn't seem to be doing that, though. Maybe I am mistaken.
19:26:05 <merijn> Doesn't seem to be doing what?
19:28:42 <ij> Sorry, never mind.
19:39:47 <avp> can someone explain how the "nondeterminism" works when using filterM, e.g. to create a powerset function?
19:40:00 <avp> powerset filterM (const [True, False])
19:44:22 <uncleBabbage> LIST
19:45:24 * hackagebot orgmode-parse 0.0.2.0 - A parser and writer for org-mode flavored documents.  http://hackage.haskell.org/package/orgmode-parse-0.0.2.0 (ParnellSpringmeyer)
19:50:24 * hackagebot orgmode-parse 0.0.2.1 - A parser and writer for org-mode flavored documents.  http://hackage.haskell.org/package/orgmode-parse-0.0.2.1 (ParnellSpringmeyer)
19:54:58 <bananagram> :t fmap
19:54:59 <lambdabot> Functor f => (a -> b) -> f a -> f b
19:55:08 <bananagram> :t fmap . fmap
19:55:09 <lambdabot> (Functor f1, Functor f) => (a -> b) -> f (f1 a) -> f (f1 b)
19:55:37 <bananagram> :t fmap . fmap . fmap
19:55:38 <lambdabot> (Functor f2, Functor f1, Functor f) => (a -> b) -> f (f1 (f2 a)) -> f (f1 (f2 b))
19:55:57 <bananagram> I hope I have to use fmap fmap fmap someday
19:57:36 <joneshf-laptop> :t fmap `fmap` fmap `fmap` fmap -- bananagram
19:57:37 <lambdabot> (Functor f2, Functor f1, Functor f) => (a -> b) -> f (f1 (f2 a)) -> f (f1 (f2 b))
19:59:01 <rfn> :t bracket_
19:59:02 <lambdabot> IO a -> IO b -> IO c -> IO c
19:59:10 <rfn> :t bracket
19:59:11 <lambdabot> IO a -> (a -> IO b) -> (a -> IO c) -> IO c
20:00:15 <bananagram> wait, how does fmap fmap fmap work? fmap isn't an (f a), is it?
20:00:27 <merijn> It is
20:00:29 <pharaun> would be fantastic if i could get help on - http://lpaste.net/113616
20:00:30 <pharaun> :\
20:00:32 <jle`> bananagram: or is it? ;D
20:00:35 <jle`> :t fmap
20:00:36 <merijn> Or rather "(->) r" is a Functor
20:00:36 <lambdabot> Functor f => (a -> b) -> f a -> f b
20:00:41 <pharaun> its doing some advanced type magic that i don't get
20:00:45 <jle`> looks like one to me :)
20:00:55 <bananagram> oh, I see
20:01:08 <pyon> @hoogle Functor f => f (a -> b) -> a -> f b
20:01:10 <lambdabot> Prelude fmap :: Functor f => (a -> b) -> f a -> f b
20:01:11 <lambdabot> Data.Functor fmap :: Functor f => (a -> b) -> f a -> f b
20:01:11 <lambdabot> Control.Monad fmap :: Functor f => (a -> b) -> f a -> f b
20:01:14 <jle`> :t fmap fmap
20:01:15 <lambdabot> (Functor f1, Functor f) => f (a -> b) -> f (f1 a -> f1 b)
20:02:20 <jle`> :t \ff x -> fmap ($ x) ff
20:02:22 <lambdabot> Functor f => f (a -> b) -> a -> f b
20:02:44 <pyon> jle`: I was looking for a nice infix function.
20:02:45 <pyon> But anyway.
20:03:40 <rfn> :t const
20:03:42 <lambdabot> a -> b -> a
20:04:38 <rfn> :t const id
20:04:39 <lambdabot> b -> a -> a
20:04:43 <pyon> There should be a function like Parsec's choice combinator in Control.Applicative, for arbitrary Alternative instances. :-|
20:05:00 <jle`> something like asum ?
20:05:08 <pyon> Oh.
20:05:16 <pyon> @type asum
20:05:17 <lambdabot>     Not in scope: ‚Äòasum‚Äô
20:05:17 <lambdabot>     Perhaps you meant one of these:
20:05:18 <lambdabot>       ‚ÄòF.asum‚Äô (imported from Data.Foldable),
20:05:23 <L8D> would "inverse functors" be a good decription of applicatives?
20:05:32 <pyon> jle`: That one?
20:05:41 <jle`> L8D: in what way are they inverse functors?
20:05:45 <jle`> :t F.asum
20:05:45 <Hijiri> wouldn't "inverse functors" be more like contravariant functors?
20:05:46 <lambdabot> (Foldable t, Alternative f) => t (f a) -> f a
20:06:01 <L8D> jle`: functors would functions and return new data
20:06:11 <L8D> jle`: applicatives would take data and return functions
20:06:22 <L8D> or something like that
20:06:24 <jle`> i can't really parse that first sentence
20:06:29 <jle`> sorry
20:06:48 <L8D> actually idk if my understanding of applicatives is accurate
20:06:48 <pyon> jle`: It happens to work for me, because I'm using Maybe. But, are there any Alterantives that aren't Foldable?
20:07:01 <jle`> pyon: what are you doing?
20:07:08 <jle`> what is choice, again?
20:07:54 <benzrf> L8D: applicative is just an interface for functors whose contexts are monoidal
20:07:59 <pyon> jle`: Tries out a bunch of alternatives/parsers, until either one succeeds, or there are no more alternatives to be tried.
20:08:18 <jle`> isn't that what asum does?
20:08:20 <L8D> :t ap
20:08:21 <lambdabot> Monad m => m (a -> b) -> m a -> m b
20:08:30 <pyon> jle`: Basically, choice [a1..an] is shorthand for a1 <|> ... <|> an
20:08:37 <pyon> jle`: Yes.
20:08:38 <jle`> > F.asum [Nothing, Just 7, Just 9]
20:08:40 <lambdabot>  Just 7
20:08:51 <jle`> asum = foldr (<|>) empty
20:09:03 <jle`> are you using Maybe as your alternative container?
20:09:18 <pyon> Wait, wait.
20:09:20 <pyon> I misread.
20:09:30 <pyon> The Foldable instance is on a different type constructor.
20:09:33 <pyon> My bad!
20:09:42 <pyon> It is generalizing the list!
20:10:06 <rfn> :t status200
20:10:07 <lambdabot> Not in scope: ‚Äòstatus200‚Äô
20:10:11 <pyon> jle`: Thanks!
20:10:20 <jle`> np!
20:11:10 <pyon> I'm doing something like "eval (TmApp tm1 tm2) = asum [ flip TmApp tm2 <$> eval tm1, TmApp tm1 <$> eval tm2, (something_huge_here) ]
20:11:21 <jle`> asum could just as well have been in Control.Applicative, but it isn't, for some reason
20:11:22 <pyon> (Yes, I'm implementing yet another lambda calculus.)
20:11:43 <pyon> Ah!
20:12:29 <jle`> :t asum `asAppliedTo` []
20:12:31 <lambdabot>     Not in scope: ‚Äòasum‚Äô
20:12:31 <lambdabot>     Perhaps you meant one of these:
20:12:31 <lambdabot>       ‚ÄòF.asum‚Äô (imported from Data.Foldable),
20:12:37 <jle`> :t F.asum `asAppliedTo` []
20:12:38 <lambdabot> Alternative f => [f a] -> f a
20:12:46 <jle`> there we go
20:12:50 <pyon> Yeah!
20:13:07 <pyon> @hoogle asAppliedTo
20:13:09 <lambdabot> No results found
20:13:18 <pyon> It's lambdabot-specific? :-O
20:13:21 <jle`> oh it's just a lambdabot trick we use
20:13:25 <pyon> Ah!
20:13:32 <pyon> Cute trick. :-)
20:13:43 <jle`> asAppliedTo :: (a -> b) -> a -> (a -> b); asAppliedTo f _ = f
20:13:45 <L8D> :t asAppliedTo
20:13:46 <lambdabot> (a -> b) -> a -> a -> b
20:14:10 <L8D> why not const?
20:14:14 <L8D> :t const
20:14:16 <lambdabot> a -> b -> a
20:14:19 <jle`> because we can't say anything about the types
20:14:27 <jle`> :t F.asum `const` "hello world"
20:14:29 <lambdabot> (Foldable t, Alternative f) => t (f a) -> f a
20:14:35 <jle`> oh
20:14:40 <jle`> well yeah, it's `const`, you're right
20:14:44 <jle`> but with a constrained type signature
20:14:49 <L8D> yes
20:15:30 <merijn> argh
20:15:37 <rfn> :t >>
20:15:38 <lambdabot> parse error on input ‚Äò>>‚Äô
20:15:42 <rfn> :t >>=
20:15:43 <lambdabot> parse error on input ‚Äò>>=‚Äô
20:15:45 <L8D> :t (>>)
20:15:47 <lambdabot> Monad m => m a -> m b -> m b
20:15:47 <L8D> :t (>>=)
20:15:48 <lambdabot> Monad m => m a -> (a -> m b) -> m b
20:16:00 <merijn> I just realised why hdevtools is messing up my cabal config, it's linked to ghc's cabal instead of the newer cabal I have installed >.<
20:16:02 <rfn> L8D: Thanks!
20:16:38 <merijn> bollocks :\
20:17:23 <L8D> :t Nothing >> Just 1 @ rfn
20:17:24 <lambdabot> parse error on input ‚Äò@‚Äô
20:17:28 <L8D> :t Nothing >> Just 1
20:17:29 <lambdabot> Num b => Maybe b
20:17:37 <L8D> :t Just "foo" >> Just 1
20:17:39 <lambdabot> Num b => Maybe b
20:17:41 <L8D> derp
20:17:54 <L8D> > (Nothing >> Just 1, Just "foo" >> Just 1)
20:17:56 <lambdabot>  (Nothing,Just 1)
20:17:58 <L8D> rfn: ^
20:20:36 <rfn> L8D: Cool!  Thanks
20:21:22 <dreams> what are types (i.e type Cost = B) desugared to?
20:21:25 <jle`> i like using (*>) in situations like these
20:21:51 <L8D> dreams: they are type synonyms
20:22:13 <L8D> dreams: so in the rest of that namespace, whenever you reference Cost, it desugars to B
20:22:20 <L8D> in type declarations
20:22:42 <dreams> L8D: I meant compiler-wise.
20:23:31 <L8D> dreams: type Foo = Bar declares a type synonym
20:23:42 <dreams> wait, B is a constructor. so they're desugared to Packs I guess.
20:23:42 <L8D> dreams: data Foo = Bar declares an enum-style type in most cases
20:23:54 <jle`> it's not really syntactic sugar
20:24:15 <L8D> dreams: newtype is for wrapping existing types to put your own type instances on it
20:24:24 <trap_exit> gentlemen, I have evidence that the end of the world is near
20:24:37 <trap_exit> (1) today, I went inside a Microsoft Store
20:24:41 <trap_exit> (2) I wanted to buy a microsoft product
20:24:47 <trap_exit> and (3), worst of all, it was all sold out
20:24:51 <dreams> L8D: to be honest, I never used newtype.
20:24:53 <trap_exit> I want my MS Band :-/
20:25:04 <merijn> trap_exit: You missed -blah by 5 letters >.>
20:25:17 <dreams> L8D: you can also wrap existing types with "type" no?
20:25:25 <trap_exit> merijn: :-)
20:25:42 <L8D> dreams: type is for direct synonyms, but nettype creates a new, seperate type
20:25:58 <L8D> dreams: in most cases, newtype Foo = Foo Int is the same as data Foo = Foo Int
20:26:03 <dreams> L8D: like data
20:26:05 <EponymicCycloid> Haskell has ruined me. Whenever I try to learn a new language, I can‚Äôt help but thinking ‚ÄúWow, Haskell does this so much better.‚Äù. Case in point: Scala. I feel cramped by the type system, and any cool language features like pattern matching are implemented in an awful, obtuse way.
20:26:06 <dreams> ah
20:26:07 <trap_exit> types --> interchangeable, like aliasses
20:26:10 <trap_exit> newtype = new actua types
20:26:36 <trap_exit> EponymicCycloid: yeah, I need someone to port Haskell, in a sctrict manner, to JVM to get all the JVm libraries
20:26:38 <EponymicCycloid> Newtype prevents you from conflating two similar types
20:26:41 <trap_exit> that, however, is not scala
20:27:01 <dreams> L8D: hang on, a type is just a constructor isn't it?
20:27:06 <L8D> although I forgot why newtype isn't a subset of data
20:27:20 <L8D> dreams: sort of
20:27:23 <EponymicCycloid> dreams: type is not a constructor. It‚Äôs a syntactic alias
20:27:24 <jle`> dreams: are you familiar with `typedef` or `#DEFINE` from C/cpp?
20:27:29 <EponymicCycloid> newtype makes a constructor
20:27:30 <L8D> it depends on what you mean by "constructor"
20:27:36 <dreams> jle`: yes
20:27:40 <L8D> EponymicCycloid: he's talking about types, not the type keyword
20:27:41 <benzrf> L8D: newtype has verrrrrry subtle semantic differences from data
20:27:44 <EponymicCycloid> Oh, ok
20:27:53 <L8D> benzrf: and those are?
20:27:57 <dreams> wow, sorry did not mean to make this storm. let me read.
20:28:06 <jle`> dreams: `type X = B` is a bit like `typedef B X`
20:28:20 <Polyatomic> EponymicCycloid: That is one hell of a nick you have there man ...
20:28:24 <jle`> or like #DEFINE X B   ... if we restrict to be only in typesignatures
20:28:31 <trap_exit> jle`++
20:28:32 <jle`> oh, did i get typedef backwards
20:28:43 <jle`> it's nothing magical, it's basically a lexical alias
20:28:51 <EponymicCycloid> Polyatomic: I picked two random words from /usr/share/dict until I got a pair I liked
20:28:59 <L8D> jle`: can they be exported? I forgot
20:28:59 <Polyatomic> nice
20:29:02 <jle`> it's as if you do a big ctrl+f on your program and replaced X with B
20:29:08 <jle`> L8D: yeah
20:29:21 <L8D> weird, purescript doesn't allow for exporting type synonyms
20:29:45 <jle`> L8D: ever used `String` ?
20:29:51 <jle`> it's a type synonym exported by Prelude
20:30:14 <benzrf> L8D: this;
20:30:21 <dreams> jle`: [Char]?
20:30:34 <benzrf> @let data DataVersion = DataVersion String deriving Show
20:30:36 <jle`> yeah, String is a synonym for [Char]
20:30:37 <yukko> how do I get parsec to fail if it can't parse the whole string?
20:30:37 <lambdabot>  Defined.
20:30:49 <benzrf> @let newtype NTVersion = NTVersion String deriving Show
20:30:50 <jle`> it's like doing a typedef
20:30:51 <lambdabot>  Defined.
20:31:07 <jle`> or #DEFINE String [Char]
20:31:07 <yukko> I must be doing something wrong but I can't tell what, I don't have any parser that ends with try or a parser that will succeed on the empty string
20:31:09 <benzrf> > case undefined of DataVersion _ -> "it works!"; _ -> "huh?"
20:31:11 <lambdabot>  "*Exception: Prelude.undefined
20:31:12 <dreams> jle`: are you familiar with Pack{0,1} representation?
20:31:18 <benzrf> > case undefined of NTVersion _ -> "it works!"; _ -> "huh?"
20:31:19 <jle`> nope :'(
20:31:20 <lambdabot>  "it works!"
20:31:30 <benzrf> L8D: that's the only denotational difference.
20:31:52 <dreams> jle`: ah nevermind then.
20:32:09 <benzrf> to be clear, pulling a value out of a newtype into the wrapped type will *ALWAYS* work
20:32:19 <benzrf> even if that value is bottom
20:32:33 <yukko> http://lpaste.net/113622 this is my code so far if anyone wants to look at it
20:32:46 <nshepperd> I think the main interesting difference between newtype and data is that wrapping/unwrapping has zero runtime cost, so you can sprinkle newtypes around without worring about performance
20:32:48 <benzrf> this has to be the case so that implementations can desugar newtypes into the types they wrap
20:33:09 <EponymicCycloid> fascinating
20:33:34 <dreams> nshepperd: you mean that newtype is more efficient than data?
20:33:35 <benzrf> if it were possible for a match out of a newtype to fail, implementations would have to treat matching-out as an actual thing that can't just be erased without changing the meaning
20:33:40 <benzrf> dreams: not in the standard, no
20:33:54 <dreams> in GHC?
20:34:05 <benzrf> dreams: but the denotational semantics in the standard are specifically designed to minimize the difficulty in implementing them as being just the type they wrap
20:34:39 <benzrf> dreams: if you have a value of type Sum Int and you look at what's actually stored in memory for it at runtime, it'll be literally exactly the same sequence of bits as if you used Int
20:34:58 <benzrf> ...in ghc
20:35:24 <dreams> benzrf: by type Sum Int you mean type Sum = Int?
20:35:41 <benzrf> i mean the newtype from Data.Monoid
20:35:46 <nshepperd> the haskell report requires the constructor to have no runtime representation
20:35:48 <dreams> ah
20:35:56 <benzrf> newtype Sum a = Sum {getSum :: a}
20:35:59 <benzrf> nshepperd: oh, really?
20:36:07 <clinton> When I use an explicit import list with Aeson I get the following error, even when "Object" is in that import list: "Not in scope: data constructor `Object'"
20:36:11 <benzrf> i didnt realize the report covered the notion of a runtime representation
20:36:18 <benzrf> i thought it was purely denotational semantics??
20:36:40 <clinton> there is no error if I import the whole module (i.e. without an import list). Why is this the case?
20:37:05 <dreams> benzrf: ah, I'm guessing its thrown away after typechecking.
20:37:21 <geekosaur> importing just Object imports the *type*, not the constructors. try Object(..)
20:37:37 <geekosaur> which tells it to also import all constructors
20:38:49 <dreams> Just a blind guess.
20:39:42 <clinton> thanks geekosaur!
20:40:01 <nshepperd> benzrf: 'The constructor N in an expression coerces a value from type t to type (T u1 ... uk). Using N in a pattern coerces a value from type (T u1 ... uk) to type t. These coercions may be implemented without execution time overhead; newtype does not change the underlying representation of an object.'
20:40:10 <joneshf-laptop> having some issues with parsec, https://gist.github.com/joneshf/2c1926721ba7b3099eb5 can anyone see where i'm going wrong?
20:40:38 <nshepperd> where we have 'newtype cx => T u1 ... uk = N t'
20:40:51 <joneshf-laptop> the data file is actually 1484 lines with a newline at the end
20:42:24 <nshepperd> dreams: so yeah, the newtype constructor is basically thrown away after type checking
20:43:59 <jle`> is map Sum the same as map id then
20:44:00 <tabemann> there's actually a difference semantically between newtype and data for newtype Foo = Foo Bar and data Foo = Foo Bar
20:44:11 <jle`> but doesn't `map id` have a cost
20:44:21 <geekosaur> joneshf-laptop, I think you need to have a detection of when the file ends, otherwise it just gets an error at EOF? also it seems to me this will fail in bad ways if some input has fewer columns than you expected
20:45:20 <joneshf-laptop> geekosaur, like: `many parseYeast <* eof` ?
20:45:24 <nshepperd> jle`: I think 'map Sum' would have the same cost as 'map unsafeCoerce'
20:45:35 <joneshf-laptop> geekosaur, that doesn't seem to help, or do you mean some other way?
20:45:42 <asayers> joneshf-laptop: shouldn't "parseYeast" consume a newline?
20:45:57 <nshepperd> which is probably the same as 'map id', since you have to provide *some* function
20:46:18 <jle`> nshepperd: yeah. so it's not actually free then, is it
20:46:56 <nshepperd> although, if map is inlined, then ghc might realise it's just doing no-ops and cancel the map completely
20:47:18 <jle`> one would hope :)
20:48:29 <geekosaur> I think that would be too simple, yes. I suspect that parseYeast must match either eof and return something to end the parse, or a line and return a record. (Just/Nothing, presumably) but its been a while.
20:48:41 <geekosaur> except come to think of it that's not right either
20:48:48 <geekosaur> at least if you want to use many
20:50:19 <merijn> jle`, nshepperd: "map Sum" does indeed have a cost, which is why the work on a safe "coerce" function and roles has been going on in 7.8
20:57:21 <joneshf-laptop> geekosaur, ah, you were right, i didn't have hte number of columns correct
20:58:31 <aspidites> anyone else having issues with ghc-mod + syntastic + vim? i'm getting errors about not being able to find the version string
21:04:44 <benzrf> bye
21:05:35 <aspidites> nvm, recompiled all plugins and everything is fine now
21:05:50 <ij> I have this: (fdToHandle . read . head <$>) . takeExactMay 1 <$> getArgs. It's IO (Maybe (IO Handle)). Can I 1. make it more better looking? 2. make it IO (Maybe Handle)?
21:13:49 <merijn> :t \x -> x >>= T.sequence
21:13:50 <lambdabot> (Traversable t, Monad m) => m (t (m a)) -> m (t a)
21:14:13 <merijn> :t \x -> x >>= T.sequence :: IO (Maybe (IO Int)) -> IO (Maybe Int)
21:14:15 <lambdabot>     No instance for (Traversable IO) arising from a use of ‚ÄòT.sequence‚Äô
21:14:15 <lambdabot>     In the second argument of ‚Äò(>>=)‚Äô, namely ‚ÄòT.sequence‚Äô
21:14:15 <lambdabot>     In the expression:
21:14:21 <merijn> hmm
21:14:28 <merijn> oh
21:14:38 <merijn> :t (\x -> x >>= T.sequence) :: IO (Maybe (IO Int)) -> IO (Maybe Int)
21:14:39 <lambdabot> IO (Maybe (IO Int)) -> IO (Maybe Int)
21:15:13 <merijn> But "fdToHandle . read" <- that looks ridiculously brittle
21:17:13 <ij> That's ok, only I will run it.
21:17:39 <ij> Isers won't get to it.
21:17:49 <shelf> any ghc-mod users around?
21:20:30 * hackagebot nagios-perfdata 0.2.1 - Parse Nagios performance data.  http://hackage.haskell.org/package/nagios-perfdata-0.2.1 (fractalcat)
21:25:30 * hackagebot rethinkdb 1.15.2.0 - A driver for RethinkDB 1.15  http://hackage.haskell.org/package/rethinkdb-1.15.2.0 (EtienneLaurin)
21:28:58 <bananagram> :t (->)
21:28:59 <lambdabot> parse error on input ‚Äò->‚Äô
21:29:16 <bananagram> :k (->)
21:29:17 <lambdabot> * -> * -> *
21:29:38 <johnny934759> :t 4
21:29:39 <lambdabot> Num a => a
21:35:31 * hackagebot limp 0.3.2.0 - representation of Integer Linear Programs  http://hackage.haskell.org/package/limp-0.3.2.0 (amosrobinson)
21:40:31 * hackagebot limp-cbc 0.3.2.0 - bindings for integer linear programming solver Coin/CBC  http://hackage.haskell.org/package/limp-cbc-0.3.2.0 (amosrobinson)
21:48:58 <yukko> how do I compose monadic functions that return ie IO Int with ones that take an IO ()?
21:49:15 <mgaut72> yukko: void
21:49:17 <mgaut72> :t void
21:49:18 <lambdabot> Functor f => f a -> f ()
21:49:18 <yukko> returnsUnit $ do returnsInt; return () seems a bit silly
21:49:20 <yukko> ohhh
21:49:24 <yukko> thank you!
21:49:47 <dfeuer> yukko, more generally:
21:49:52 <dfeuer> :t (<$)
21:49:53 <lambdabot> Functor f => a -> f b -> f a
21:49:58 <Cale> It's a bit unfortunate that there are functions which take an IO () when they don't care about the result type of the action
21:50:12 <dfeuer> Cale, I beg to differ.
21:50:18 <Cale> If something doesn't care about the result type of the action, it should accept an action of arbitrary type
21:50:26 <dfeuer> I disagree.
21:50:31 <yukko> Cale yeah that makes sense to me too
21:50:42 <yukko> dfeuer why do you disagree?
21:50:56 <simpson> :t bracket -- I like bracket's type in this regard
21:50:57 <lambdabot> IO a -> (a -> IO b) -> (a -> IO c) -> IO c
21:51:05 <Cale> yes
21:51:08 <Cale> :t forkIO
21:51:10 <lambdabot> Not in scope: ‚ÄòforkIO‚Äô
21:51:17 <Cale> :t Control.Concurrent.forkIO
21:51:18 <lambdabot> IO () -> IO GHC.Conc.Sync.ThreadId
21:51:21 <Cale> ^^ this sucks
21:51:22 <dfeuer> Because usually if you're performing an action, you want to do something with the result. If you're not, that should be made explicit with void, (>>), (*>), (<$), etc.
21:52:03 <dfeuer> Also, forcing a polymorphic result requires seq, which is always kind of icky.
21:52:09 <Cale> what?
21:52:30 <dfeuer> where? when? why?
21:52:30 <ReinH> "forcing a polymorphic result requires seq, which is always kind of icky." eh?
21:52:30 <Cale> Who said anything about evaluation? :)
21:52:46 <dfeuer> Cale, we don't know what the function is doing with its ().
21:53:14 <Cale> The options are the same regarding evaluation anyway
21:53:26 <dfeuer> ?
21:53:38 <Cale> I guess using () means that the thing could explicitly case to pattern match on the ()
21:53:44 <Cale> rather than using seq
21:53:47 <Cale> if it cared?
21:53:49 <dfeuer> foo () = blah
21:53:52 <Cale> But it probably doesn't care
21:54:10 <Cale> and evaluating a () rarely is important
21:54:37 <Cale> Unless it's something constructed out of seqs and pars
21:55:11 <Cale> and if evaluating it is important, then applying void explicitly will avoid evaluating the result :P
21:55:23 <dfeuer> Seriously, WTF is this about: https://phabricator.haskell.org/harbormaster/build/1587/
21:55:36 <yukko> I wish the IO functions in Haskell's standard libraries were IO (Either Error a) or something
21:55:42 <dfeuer> Hah. True, Cale.
21:55:45 <yukko> I don't like exceptions very much
21:56:13 <Cale> Control.Exception is so underappreciated though :/
21:56:24 <mietek> Is hsc2hs expected to compile with GHC 7.8.3?
21:56:26 <yukko> I think that if if something can fail then that possibility should be reflected in the type system
21:56:33 <Cale> dfeuer: Looks like a failure running the parser generator
21:57:24 <Cale> dfeuer: At least, that's what shift/reduce and reduce/reduce conflicts refer to
21:57:31 <dfeuer> Cale, oooookay...... I didn't touch any of those.
21:58:11 <Cale> yukko: Yeah, that's sort of why it's underappreciated, because we all like compile time failures a whole lot more than runtime ones
21:58:49 <Cale> But it really is a nice exception system :)
21:59:00 <dfeuer> I made the default definitions of foldr1 and foldl1 in the Foldable class lazer, and added an Alt type to Data.Monoid.
21:59:13 <dfeuer> There is just no way any of that should affect anything in a parser generator.
21:59:15 <Cale> It's just that types and forcing your users to deal with the exceptional cases is usually a better plan.
21:59:51 <hamishmack> @tell fluffynekeit Try using unWindow from Graphics.UI.Gtk.Types
21:59:51 <lambdabot> Consider it noted.
22:00:31 <Cale> dfeuer: I have no idea if those parser generator messages are actually an indication of failure
22:00:33 * hackagebot vty-ui 1.8 - An interactive terminal user interface library for Vty  http://hackage.haskell.org/package/vty-ui-1.8 (JonathanDaugherty)
22:00:48 <Cale> dfeuer: But I don't see anything else...
22:01:12 <Cale> dfeuer: That looks pretty early in the build, did you try building it yourself?
22:01:18 <dfeuer> I'm trying that now.
22:03:14 <Cale> dfeuer: Those are more like warnings that the grammar as specified is ambiguous. I'd kind of expect that Happy just makes a particular arbitrary choice in those cases rather than failing completely.
22:03:57 <dfeuer> Cale, well, *something* is making validation fail there. If you look at my patch, I think it'll be fairly clear that it's not my fault.
22:04:21 <Cale> I don't know how to phabricator
22:05:16 <Cale> but yeah, that definitely looks like it shouldn't be affecting GHC's ability to configure :P
22:05:50 <dfeuer> Cale, uh ... I guess I did do something wrong.
22:05:53 <dfeuer> Hmmmmm.
22:06:09 <dfeuer> And the error just came out in the wrong spot on Phab or something.
22:06:54 <dfeuer> Cale, a missing comma.
22:07:17 <Cale> oh
22:07:23 <Cale> yeah, I see
22:07:30 <Cale> after Last(..)
22:07:37 <dfeuer> Yup.
22:07:45 <Cale> But yeah, wtf, why doesn't it report the error sensibly
22:08:28 <dfeuer> Oh, it reports it about as well as it ever does locally, but for some reason it did something strange up on Phab.
22:12:31 <jle`> yukko: it doesn't really work out too well for concurrency that way, i think
22:12:59 <yukko> jle` really?
22:13:13 <jle`> yeah, i think you lose a lot of expressiveness
22:13:33 <jle`> hm
22:13:37 <jle`> i can't think of a specific example right now
22:14:07 <jle`> but i think like...there should really be a semantic difference between "errors" and runtime exceptions
22:14:22 <jle`> like there is now
22:14:47 <Cale> It's a little bit unfortunate in some ways that it's possible to catch the exceptions thrown by 'error' at all
22:14:47 <yukko> what's the difference exactly?
22:15:30 <Cale> Those really ought to be in their own separate class in many ways from exceptions that are thrown as part of execution of an IO action
22:15:59 <Cale> But I suppose it doesn't do much harm to have that capacity as a last resort
22:16:27 <jle`> "errors" is i guess a general term for unexpected input/outputs...like listToMaybe might "error", in a first-class way, by returning a Nothing.  it's determined by the semantics of the function
22:16:40 <jle`> a runtime exception a tool that GHC runtime gives you to write more expressive programs
22:16:46 <jle`> it's a message-passing system
22:16:51 <jle`> with dynamic channels
22:17:18 <jle`> and the tools for working with this IO runtime system feature is in Control.Exception
22:17:39 <jle`> just like GHC IO runtime gives you a way to print to sdtdout with functions like putStrLn.
22:17:40 <yukko> why couldn't you implement a message passing system on top of having explicit errors (ie, having them in the type system)
22:17:56 <merijn> yukko: Because there's no notion of concurrency then
22:18:12 <gfixler> is there an interesting reason that so many tuple instances in the Prelude are implemented out to 'o' elements?
22:18:40 <yukko> I'm not really sure what the relationship is between concurrency and failure
22:18:46 <jle`> gfixler: i think it's in the Report
22:19:00 <Cale> yukko: There's a certain extent to which you don't want to be responsible for dealing with *every* possible exceptional case, because some of them are quite rare and only the most defensive possible programmer will worry about them, while others who are writing something more quickly, or even just an average program won't want to handle those.
22:19:01 <jle`> yukko: IO failure can happen in concurrent settings
22:19:23 <Cale> and turning a proper IO exception into a fromJust is also a travesty :)
22:19:48 <jle`> and being able to work with them in meaningful ways is tricky, and one solution is to implement IO exceptions as runtime exceptions
22:20:13 <jle`> it's tricky in the way that you proposed earlier, IO (Either Error a)
22:20:25 <Cale> :t try
22:20:26 <lambdabot> Exception e => IO a -> IO (Either e a)
22:20:37 <Cale> ^^ note that this exists :)
22:20:43 <yukko> that is nice and I like it
22:20:46 <jle`> :)
22:21:07 <jle`> going backwards is a bit less powerful
22:21:16 <yukko> but it is not obvious from reading the types that certain functions can fail, and if they can, the type of exception they will throw
22:21:33 <Cale> Yeah, it would be nice to be able to get more information about that
22:21:48 <jle`> yea,h that's a big deal
22:22:06 <jle`> you know, java has that ;)
22:22:40 <yukko> that's neat!
22:22:47 <jle`> (but not really, i am half trolling)
22:23:04 <yukko> ohh I actually believed you
22:23:17 <Cale> yukko: He's only *half* trolling :)
22:23:23 <L8D> wait...
22:23:26 <Cale> Java does have checked exceptions
22:23:27 <yukko> lol
22:23:31 <yukko> ah okay
22:23:33 <L8D> how would you catch errors outside of IO?
22:23:42 <L8D> > try (1 / 0)
22:23:44 <lambdabot>  No instance for (Data.Typeable.Internal.Typeable e0)
22:23:44 <lambdabot>    arising from a use of ‚ÄòM79640312395445608727286.show_M79640312395445608727...
22:23:44 <lambdabot>  The type variable ‚Äòe0‚Äô is ambiguous
22:23:44 <lambdabot>  Note: there are several potential instances:
22:23:44 <lambdabot>    instance Data.Typeable.Internal.Typeable Data.Dynamic.Dynamic
22:23:50 <L8D> derp
22:24:00 <L8D> > try (return $ 1 / 0)
22:24:02 <lambdabot>  No instance for (Data.Typeable.Internal.Typeable e0)
22:24:02 <lambdabot>    arising from a use of ‚ÄòM229987114326676050127298.show_M2299871143266760501...
22:24:02 <lambdabot>  The type variable ‚Äòe0‚Äô is ambiguous
22:24:02 <lambdabot>  Note: there are several potential instances:
22:24:02 <lambdabot>    instance Data.Typeable.Internal.Typeable Data.Dynamic.Dynamic
22:24:04 <Cale> L8D: You wouldn't
22:24:07 <yukko> lol
22:24:14 <yukko> how to make lambdabot print a billion lines
22:24:26 <L8D> yukko: there are better ways
22:24:34 <yukko> someone showed me a funny one the other day
22:25:03 <Cale> ghci> try (evaluate (1/0)) :: IO (Either ArithException Rational)
22:25:03 <Cale> Left Ratio has zero denominator
22:25:07 <L8D> > show . show . show . show . show . show . show $ "\
22:25:09 <lambdabot>  <hint>:1:52:
22:25:09 <lambdabot>      unexpected end-of-file in string/character literal at end of input
22:25:10 <L8D> wgoops
22:25:17 <L8D> > show . show . show . show . show . show . show $ "\"hehe\""
22:25:19 <lambdabot>  "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\...
22:25:25 <int-e> > fix show
22:25:25 <L8D> -.-
22:25:27 <lambdabot>  "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\...
22:25:32 <Cale> > fix error
22:25:34 <lambdabot>  "*Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *Ex...
22:25:41 <L8D> :t fix
22:25:42 <lambdabot> (a -> a) -> a
22:25:51 <L8D> > fix i
22:25:52 <lambdabot>  Couldn't match expected type ‚Äòa -> a‚Äô
22:25:53 <lambdabot>              with actual type ‚ÄòDebug.SimpleReflect.Expr.Expr‚Äô
22:25:57 <L8D> > fix id
22:26:01 <lambdabot>  mueval-core: Time limit exceeded
22:26:04 <int-e> > fix fail
22:26:06 <lambdabot>  ""
22:26:10 <L8D> I don't get it
22:26:15 <L8D> what does fix do?
22:26:20 <int-e> @src fix
22:26:20 <Cale> It finds the least-defined fixed point of a function
22:26:20 <lambdabot> fix f = let x = f x in x
22:26:42 <Cale> If the function you give it sends _|_ to _|_, then _|_ will be what you get
22:26:58 <L8D> > fix Just
22:26:59 <lambdabot>  Occurs check: cannot construct the infinite type:
22:27:00 <lambdabot>    a ~ Data.Maybe.Maybe a
22:27:00 <lambdabot>  Expected type: a -> a
22:27:00 <lambdabot>    Actual type: a -> Data.Maybe.Maybe a
22:27:03 <Cale> But otherwise, you may get a more defined fixed point
22:27:07 <Cale> > fix (1:)
22:27:09 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
22:27:22 <L8D> oooooh
22:27:29 <Cale> > fix (\fac n -> if n == 0 then 1 else n * fac (n-1)) 10
22:27:30 <L8D> is there any practical use for fix?
22:27:31 <lambdabot>  3628800
22:27:37 <Cale> Implementing recursion
22:27:39 <int-e> > fix f :: Expr
22:27:40 <lambdabot>  f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f...
22:27:57 <L8D> could you show me an example of a real-world use?
22:28:16 <Cale> ^^ well, there I showed a factorial implementation :P
22:28:24 <L8D> ooooh it's like a y combinator
22:28:27 <int-e> > fix ((0:) . scanl (+) 1) -- does this count?
22:28:29 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
22:28:29 <Cale> It's exactly like that
22:28:51 <L8D> why don't you guys say "it's the y combinator"
22:28:59 <Cale> The Y combinator is an example of a fixed point combinator, it does the same, but usually it's written in an untyped language
22:29:04 <gfixler> that's all the y combinator is?
22:29:26 <Cale> If you try to write the Y combinator in Haskell, you need to do a bunch of newtype wrapping and unwrapping to get it to typecheck
22:29:41 <Cale> data Rec a = In { out :: Rec a -> a }
22:29:41 <Cale> y :: (a -> a) -> a
22:29:41 <Cale> y = \f -> (\x -> f (out x x)) (In (\x -> f (out x x)))
22:29:46 <Cale> ^^ that'll work though
22:29:58 <L8D> :t In
22:29:59 <lambdabot> f (Mu f) -> Mu f
22:30:10 <Cale> I think the In in lambdabot is a bit different
22:30:10 <L8D> :i Mu
22:30:16 <gfixler> L8D: wikipedia has "Y combinator" link to "Fixed-point combinator"
22:30:16 <Cale> :t InR
22:30:17 <lambdabot> (Rec a -> a) -> Rec a
22:30:22 <int-e> :t out
22:30:22 <Cale> ^^ this is the appropriate one
22:30:23 <lambdabot> Mu f -> f (Mu f)
22:30:28 <Cale> :t outR
22:30:29 <lambdabot> Rec a -> Rec a -> a
22:30:34 <int-e> :t \f -> (\x -> f (out x x)) (In (\x -> f (out x x)))
22:30:35 <lambdabot>     Occurs check: cannot construct the infinite type: f ~ (->) (Mu f)
22:30:35 <lambdabot>     Expected type: Mu f -> Mu ((->) (Mu f))
22:30:35 <lambdabot>       Actual type: f (Mu f)
22:30:38 <Cale> no
22:30:42 <Cale> use InR and outR
22:30:45 <int-e> oh.
22:30:52 <Cale> In and out are for Mu
22:30:57 <Cale> rather than Rec
22:31:00 <jle`> L8D: it doesn't make sense to catch IO runtime exceptions out of IO
22:31:03 <int-e> that was silly.
22:31:15 <jle`> L8D: if your errors are Either/Maybe, then you can pattern match
22:31:26 <Cale> :t \f -> (\x -> f (outR x x)) (InR (\x -> f (outR x x)))
22:31:27 <lambdabot> (a -> a) -> a
22:31:41 <L8D> jle`: how could I wrap something that have errors into an Either or Maybe?
22:31:46 <L8D> like (/_
22:31:49 <Cale> > (\f -> (\x -> f (outR x x)) (InR (\x -> f (outR x x)))) (\fac n -> if n == 0 then 1 else n * fac (n-1)) 10
22:31:49 <L8D> I mean (/)
22:31:51 <lambdabot>  3628800
22:31:51 <jle`> something that has erors...
22:32:03 <L8D> jle`: errors as in "error "foo"" or undefined
22:32:08 <jle`> > let headMaybe (x:xs) = Just x; headMaybe [] = Nothing
22:32:09 <lambdabot>  not an expression: ‚Äòlet headMaybe (x:xs) = Just x; headMaybe [] = Nothing‚Äô
22:32:14 <jle`> oh
22:32:41 <Cale> L8D: Well, you can't do it from pure code
22:32:48 <jle`> as in, things that, when evaluated in IO, can potentially trigger a runtime exception
22:32:56 <Cale> L8D: But it's theoretically possible to catch the exception from IO
22:33:15 <Cale> see my example above, or I guess I can re-paste
22:33:20 <L8D> but what if I want to isolate the catch instead of doing a catch on a big operation
22:33:22 <Cale> ghci> try (evaluate (1/0)) :: IO (Either ArithException Rational)
22:33:22 <Cale> Left Ratio has zero denominator
22:33:37 <jle`> in the semantics of what runtime exceptions and evaluation are supposed to represent, it is impossible
22:33:53 <jle`> that's like asking "how do i catch a nonterminating function w/out IO"
22:34:04 <Cale> Using Control.Exception.evaluate in order to sequence the evaluation appropriately so that it happens within the try or catch or handle or whatever is important.
22:34:16 <jle`> how do i "catch" something like foo x = foo (x - 1)
22:34:40 <jle`> however...if you want to break semantics...there are some ways.
22:34:50 <Cale> Yeah, the semantics usually treats exceptions as being "the same" as an infinite loop
22:34:52 <jle`> if you want to throw away the meaning of what exceptions/IO are supposed to mean
22:35:00 <jle`> there's the `spoon` library
22:35:02 <jle`> :)
22:35:17 <Cale> You spoony bard!
22:36:04 <Cale> http://i2.kym-cdn.com/entries/icons/original/000/006/385/Spoony_Bard.jpg :D
22:37:08 <jle`> :O
22:39:58 <free_beard> hi, i'm trying to follow this https://www.fpcomplete.com/school/advanced-haskell/building-a-file-hosting-service-in-yesod/part%202, the problem i have is that at compile time, i get not in scope: 'handleGET' from mkYesodDispatch "App" resourcesApp
22:40:24 <free_beard> any ideea why i would get that?
22:42:54 <xpika> is there a ghc option that applies unsafe coerce to everything?
22:43:18 <dfeuer> If I'm declaring an instance for a class and I want it to have all the defaults, I can omit the "where", right?
22:43:30 <int-e> dfeuer: yes
22:43:38 <dfeuer> Thanks, int-e.
22:43:55 <c_wraith> xpika: that sounds like something that'd remove any usefulness Haskell has.
22:43:58 <luite> xpika: -fdefer-type-errors ?
22:44:22 <xpika> luite: i'll try that
22:45:50 <luite> xpika: not quite what you wanted, but perhaps what you need
22:46:04 <luite> at least it'll let you run the program before fixing all type errors
22:47:06 <xpika> luite: nope.
22:47:42 <Cale> free_beard: hm
22:47:53 <xpika> c_wraith: is any the same as all ?
22:48:32 <c_wraith> xpika: in this particular case - they mean more or less the same thing.
22:48:55 <xpika> c_wraith: you would still get nice lambda syntax.
22:49:36 <c_wraith> xpika: but way too much complexity to manage without the compiler having your back.
22:50:21 <xpika> c_wraith: some languages compilers dont even have type checkers (javascript). not everyone minds.
22:50:58 <Cale> xpika: Yeah, but also ignoring the type errors in those systems usually doesn't result in arbitrary code execution
22:51:08 <Cale> (like you'd get with unsafeCoerce)
22:51:33 <c_wraith> xpika: also, Haskell uses a lot more abstraction than javascript. It's easy, because the compiler makes sure you get it right.
22:52:02 <c_wraith> xpika: when the compiler doesn't back you up anymore, there are a lot of nice things that become infeasible to do in real code.
22:52:20 <jle`> even the simplest tasks become nightmares
22:52:24 <Cale> Oh, also note that if you unsafeCoerce everything, you'll have a lot of trouble using anything that involves type classes
22:52:37 <Cale> because everything will become ambiguous
22:52:39 <rfn> :t lookup
22:52:40 <lambdabot> Eq a => a -> [(a, b)] -> Maybe b
22:53:11 <jle`> haskell libraries are designed to have the compiler hold your hand the entire time
22:53:26 <jle`> a lot of haskell libraries become meaningless or unusable
22:53:48 <jle`> also...i really hope that nobody uses haskell for the syntax..
22:53:53 <jle`> *just for the syntax
22:54:15 <Cale> QuickCheck won't work, but that'll be the least of your concerns...
22:54:20 <Cale> 1 + 1 will be ambiguous
22:54:42 <jle`> any do notation would be completely indecipherable...errors, too
22:54:47 <Cale> In some sense, it already is ambiguous
22:55:05 <Cale> But if you put an implicit unsafeCoerce around it, it would be impossible to resolve that ambiguity
22:55:19 <xpika> Cale: (print :: Int -> IO ()) (unsafeCoerce (+1) 1)
22:55:36 <xpika> Cale: => 2
22:55:54 <c_wraith> xpika: that only works because of defaulting
22:56:25 <jle`> xpika: i think you mised an unsafeCoerce
22:56:44 <jle`> (unsafeCoerce (print :: Int -> IO ())) -> (unsafeCoerce (+1) 1)
22:56:47 <jle`> ;)
22:56:54 <jle`> um, i hve an extra arrow there
22:57:22 <Cale> ghci> unsafeCoerce print (unsafeCoerce (unsafeCoerce (+) (unsafeCoerce 1) (unsafeCoerce 1)))
22:57:22 <Cale> ()
22:57:45 <c_wraith> well, it didn't execute arbitrary code!
22:57:52 <Cale> Thankfully!
22:58:06 <Cale> In some cases it might do
22:58:22 <c_wraith> yeah, it's just a bit of luck
22:58:34 <xpika> jle`: unsafeCoerce (print :: Int -> IO ()) (unsafeCoerce (+1) (unsafeCoerce 1))
22:58:51 <xpika> jle`: => 2
22:58:54 <c_wraith> xpika: you still left a bunch out.  Cale's version is more correct.
22:59:07 <Cale> Even I left one out
22:59:38 <xpika> c_wraith: it really only needs to be on the application of functions. not to just values.
23:00:40 <Cale> unsafeCoerce (print :: ByteString -> IO ()) (unsafeCoerce (unsafeCoerce (+) (unsafeCoerce 1) (unsafeCoerce 1)))
23:00:43 <Cale> try that ;)
23:01:05 <jle`> xpika: the version i had was (unsafeCoerce (print :: Int -> IO ()))
23:01:41 <jle`> anyways...if you use haskell for a little bit in the real world, it's pretty difficult to get by without typechecking
23:01:48 <Cale> btw, it's also a fluke that this version with Int does anything sensible at all
23:01:49 <jle`> and even so, it would be impossible to have any guaruntees that anything will work
23:02:00 <Cale> Because it's defaulting to Integer
23:02:17 <Cale> So, the fact that you're getting 2 is pure luck of similarity of representation
23:02:21 <xpika> Cale: that wouldn't work even without unsafeCoerce
23:02:21 <Cale> and can't be relied on
23:02:34 <jle`> oh.  haha, i didn't even realize that.
23:02:45 <jle`> it's defaulting as an Int, so it's an Int in the GHC memory representation
23:02:50 <jle`> in binary
23:02:55 <DTSCode> hello... how would i install ghc 7.4 with cabal on ubuntu?
23:02:57 <jle`> er, an Integer
23:03:05 <jle`> and then it's being coerced to be read as an Int in binary
23:03:15 <jle`> even though they aren't guarunteed to have the same representation
23:04:07 <c_wraith> yeah, it'd fail *horribly* if the two numbers being added together were sufficient to overflow Int, since they'll be defaulting to Integer
23:04:26 <Cale> Yeah, you're lucking out that the first constructor of Integer has the same shape as the only constructor of Int
23:04:34 <Cale> data Int = GHC.Types.I# GHC.Prim.Int#
23:04:42 <Cale> data Integer
23:04:42 <Cale>   = integer-gmp:GHC.Integer.Type.S# GHC.Prim.Int#
23:04:42 <Cale>   | integer-gmp:GHC.Integer.Type.J# GHC.Prim.Int# GHC.Prim.ByteArray#
23:04:53 <jle`> but people are used to overflowing in C all the time.  some people don't mind overflows!
23:05:02 <jle`> ;)
23:05:09 <c_wraith> jle`: but it'd make it use the wrong constructor.  Way worse than just an overflow..
23:05:12 <jle`> who needs computer security anyway
23:05:34 <jle`> buffer overflows...they're aight.
23:05:42 <xpika> jle`: unsafeCoerce (print :: Bool -> IO ()) True
23:06:00 <xpika> jle`:  => True
23:06:02 <Cale> xpika: My point about the above is that what happens is *way* crazier than what usually happens in a dynamically typed language when you mix up some types.
23:06:20 <Cale> (did you try it? It starts printing out some arbitrary part of memory)
23:07:06 <Cale> Or you might just immediately get a segfault
23:07:09 <Cale> depending
23:07:10 <xpika> Cale: box all the types?
23:07:29 <xpika> Cale: raise an exception on mismatch
23:08:01 <jle`> you mean, tag all values with their types at runtime?
23:08:25 <xpika> jle`: yep
23:08:40 <Cale> Maybe you just want Dynamic/Typeable?
23:08:40 <xpika> jle`: box and tag
23:08:45 <Cale> :t cast
23:08:46 <lambdabot> (Typeable b, Typeable a) => a -> Maybe b
23:08:52 <Cale> :t toDynamic
23:08:53 <lambdabot>     Not in scope: ‚ÄòtoDynamic‚Äô
23:08:53 <lambdabot>     Perhaps you meant ‚Äò_Dynamic‚Äô (imported from Data.Dynamic.Lens)
23:09:00 <Cale> oh, not imported
23:09:02 <jle`> maybe xpika wants it implicit in the language
23:09:03 <Cale> :t toDyn
23:09:04 <lambdabot> Typeable a => a -> Dynamic
23:09:07 <Cale> ah, right
23:09:11 <Cale> :t fromDyn
23:09:12 <lambdabot> Typeable a => Dynamic -> a -> a
23:09:26 <joneshf-laptop> where do you find documentation for hmatrix?
23:09:40 <joneshf-laptop> hackage doesn't seem to have anything in the modules i've looked in
23:09:45 <Cale> http://hackage.haskell.org/package/hmatrix
23:09:49 <Cale> er
23:09:54 <Cale> oh
23:09:58 <jle`> still, it robs 99% of the usefulness of haskell.  and also, many of the abstractions that haskell libraries rely on would no longer work or be usable or be impossibly complex
23:10:37 <Cale> joneshf-laptop: If you go back as far as 0.15.2.1, then the docs are there
23:10:52 <Cale> I don't understand what's going on with hackage's doc generation
23:10:57 <xpika> jle`: be that as it may. it might come in handy.
23:11:21 <joneshf-laptop> Cale, thanks
23:11:23 <Cale> xpika: You'd be better off just designing and implementing a different language
23:11:40 <Cale> for all the trouble it would cause :P
23:11:42 <jle`> -fdefertypeerrors has some use cases for debugging
23:11:54 <jle`> i think SPJ was a big advocate for it
23:11:54 <Cale> Yeah, -fdefer-type-errors is okay
23:11:58 <jle`> s/debugging/prototypes
23:12:04 <Cale> But that's not really at all the same thing :)
23:12:05 <jle`> prototying
23:12:08 <jle`> yeah
23:12:22 <jle`> for having "tagged boxes", we have Data.Dynamic
23:12:25 <jle`> and Data.Typeable
23:12:39 <jle`> so you could really implement the same algorithms you would do in a dynamic language in javascript if you wanted
23:12:50 <xpika> jle`: might be good as a teaching tool as well. so people can learn to code without writing type signatures.
23:12:50 <jle`> but it's just not implicit in the language
23:13:21 <Cale> People can already learn that in ordinary Haskell
23:13:36 <Cale> The compiler will infer practically all of your type signatures
23:14:01 <c_wraith> Except it'll also tell you when your code is broken
23:14:18 <c_wraith> Which is more useful than making you wait until runtime to find out something's not right.
23:19:40 <xpika> Cale: practically is where is the problem is
23:19:41 <xpika> Prelude Unsafe.Coerce> let g f x y = (max :: Int -> Int -> Int ) (unsafeCoerce f x) (unsafeCoerce f y) in g length "a"
23:19:44 <xpika> [1,2]
23:20:26 <xpika> evaluates to 2
23:20:50 <xpika> otherwise you need to know rank n types.
23:21:00 <c_wraith> xpika: think for a second about why you have to put the type signature on max.  (It matters)
23:21:13 <xpika> so teaching could be hindered
23:22:06 <DTSCode> anyone?
23:23:44 <xpika> c_wraith: otherwise the type resolves to :: Ord a => a
23:24:02 <xpika> somewhere you need something which is num specific
23:24:21 <c_wraith> xpika: And what are the consequences of choosing the wrong max?
23:24:22 <Dongyancai> Hello, I'm trying to use Debug.Trace.traceStack, but I don't know how to enable it. The code and compile command is at http://lpaste.net/113627, is there any wrong?
23:24:39 <xpika> c_wraith: no idea
23:24:48 <xpika> c_wraith: oh
23:24:53 <c_wraith> xpika: potentially arbitrary code execution
23:25:14 <xpika> c_wraith: so types would be boxed.
23:25:25 <xpika> c_wraith: tagged i mean
23:25:40 <c_wraith> xpika: So..  you're destroying performance for the sake of making the language harder to use?
23:25:47 <xpika> c_wraith: admitantly you won't be able to use standard prelude.
23:26:01 <c_wraith> xpika: you wouldn't be able to use classes in general
23:26:17 <xpika> c_wraith: easier in some areas
23:26:28 <c_wraith> xpika: I know of no such areas.
23:26:40 <xpika> ok the last example
23:27:04 <xpika> c_wraith: without the unsafeCoerce
23:27:16 <xpika> c_wraith: requires knowledge of RankNTypes
23:27:47 <xpika> > let g f x y = max (f x) (f y)in g length "a" [9]
23:27:48 <lambdabot>  No instance for (GHC.Num.Num GHC.Types.Char)
23:27:48 <lambdabot>    arising from the literal ‚Äò9‚Äô
23:28:13 <xpika> > let g f x y = max (f x) (f y); g::(forall e.[e]->Int) -> [a] -> [b] -> Int in g length "a" [9]
23:28:15 <lambdabot>  1
23:28:32 <xpika> so people would not need to learn that
23:28:57 <c_wraith> xpika: Yes they would.  They just wouldn't need to learn a tiny bit of syntax.
23:29:08 <c_wraith> xpika: they'd still need to understand that they were passing polymorphic functions around
23:29:12 <xpika> c_wraith: that was my point
23:29:19 <c_wraith> xpika: but the compiler wouldn't be able to help them out when they get it wrong
23:29:19 <xpika> c_wraith: the forall. syntax
23:29:36 <xpika> c_wraith: granted
23:30:49 <xpika> c_wraith: there is the trade off
23:31:35 <xpika> c_wraith: maybe there could be a flag -XUnsafeCoerce
23:31:58 <c_wraith> xpika: you need to understand.  100% of programmers get things wrong all the time.  Optimizing for the few cases when they do everything perfectly the first time makes no sense.
23:32:33 <c_wraith> xpika: you have to work in the real world.  Optimize for the case where programmers make mistakes, and make it as easy to fix them as possible.
23:32:45 <rfn> :t ($)
23:32:46 <lambdabot> (a -> b) -> a -> b
23:33:05 <c_wraith> :t id `asTypeOf` ($)
23:33:06 <lambdabot> (a -> b) -> a -> b
23:34:12 <nshepperd> Haskell seems like almost the least useful language to turn off type safety in
23:34:21 <c_wraith> I agree
23:34:34 <c_wraith> Well, no.  Agda/Idris/Coq/etc would be worse
23:34:37 <xpika> c_wraith: I'm not trying target the "whole world". just a part that want haskell syntax without its type system.
23:34:49 <nshepperd> yes, why I put "almost" :p
23:37:48 <Dongyancai> Hello, I'm trying to use Debug.Trace.traceStack, but I don't know how to enable it. The code and compile command is at http://lpaste.net/113627, please tell me what is wrong on my code and commands?
23:38:14 <xpika> you have to admit. haskell has some pretty cool syntax compared to most languages. function sections for instance.
23:38:54 <ddellacosta> so, if one wanted to leverage the space optimizations that in-place manipulation of arrays provides you for a sorting algorithm, for example, how would one begin to approach that in Haskell?
23:39:36 <jle`> by using arrays with in-place manipulation
23:39:50 <ddellacosta> jle`: d'oh
23:41:03 <ddellacosta> jle`: like, say, using Data.Array.ST (having just googled mutable arrays in Haskell"
23:41:05 <ddellacosta> )
23:41:10 <ddellacosta> ?
23:41:22 <augur> :t asTypeOf
23:41:23 <lambdabot> a -> a -> a
23:41:34 <xpika> > ((+) . (+1)) 1 2
23:41:36 <lambdabot>  4
23:41:36 <merijn> ddellacosta: Or vector, or repa or one of the god knows how many highly optimised libraries for that :)
23:41:43 <augur> whats the use case for asTypeOf
23:41:52 <ddellacosta> merijn: okay, sorry I didn't google harder beforehand!  Will go poke around some more
23:41:55 * ddellacosta looks sheepish
23:41:57 <merijn> augur: "I don't know how this specialised"
23:42:12 <augur> mer?
23:42:13 <augur> merijn: ?
23:42:17 <merijn> augur: Also, alternative to Proxy
23:42:26 <augur> hm
23:42:32 <merijn> > minBound `asTypeOf` 'c'
23:42:34 <lambdabot>  '\NUL'
23:43:56 <merijn> augur: That way you can use it as an alternative to type annotations without needing scopedtypevariables
23:49:01 <joneshf-laptop> hmm, how can i take some portion of a list that is a percentage of its length?
23:49:14 <joneshf-laptop> like if i want 1/4 of the list i'd like to say `takeQuarter xs = take (0.25 * length xs) xs`, but the types dont line up
23:49:58 <augur> joneshf-laptop: obviously you need to do some conversions
23:50:05 <augur> :t Int -> Float
23:50:06 <lambdabot> parse error on input ‚Äò->‚Äô
23:50:10 <augur> whoops
23:50:14 <augur> @hoogle Int -> Float
23:50:16 <lambdabot> Data.Set elemAt :: Int -> Set a -> a
23:50:16 <joneshf-laptop> right, but i can't find the proper ones
23:50:16 <lambdabot> Prelude (!!) :: [a] -> Int -> a
23:50:16 <lambdabot> Data.List (!!) :: [a] -> Int -> a
23:50:41 <augur> i dont know if float is even a type
23:50:42 <augur> lol
23:50:50 <joneshf-laptop> it is
23:50:57 <augur> @hoogle Num a => a -> Float
23:50:58 <lambdabot> Prelude abs :: Num a => a -> a
23:50:58 <lambdabot> Prelude negate :: Num a => a -> a
23:50:58 <lambdabot> Prelude signum :: Num a => a -> a
23:51:35 <augur> aha
23:51:38 <augur> :t fromInteger
23:51:39 <lambdabot> Num a => Integer -> a
23:51:40 <augur> :t toInteger
23:51:41 <lambdabot> Integral a => a -> Integer
23:52:04 <augur> :t round
23:52:05 <lambdabot> (RealFrac a, Integral b) => a -> b
23:52:10 <augur> those should be sufficient, joneshf-laptop
23:59:51 <Dongyancai> Hello, I'm trying to use Debug.Trace.traceStack, but I don't know how to enable it. The code and compile command is at http://lpaste.net/113627, please tell me what is wrong on my code and commands?
