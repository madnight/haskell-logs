00:05:40 <LordBrain> hey, i am sure a thousand solutions already exist, but i wrote this little bash program wrapper around runghc so that i could do some quick haskell on the the command line. I figure I might as well share it, so i put it on github: https://github.com/jimcrayne/hk
00:06:45 <LordBrain> i think it makes just regular haskell as useful as perl5 for that kind of purpose.
00:06:58 <LordBrain> i suppose without regular expressions tho
00:07:22 <gambogi> anyone here wrangled with scotty recently?
00:09:46 <LordBrain> anyway, patches, fixes, welcome
00:29:52 * hackagebot ekg 0.4.0.5 - Remote monitoring of processes  http://hackage.haskell.org/package/ekg-0.4.0.5 (JohanTibell)
00:37:01 <ab9rf> the idea of using haskell as a shell makes me a bit wiggy
00:41:08 <moop> haskell shell? hash?
00:58:11 <jle`> i think chrisdone released something similar
01:51:26 <dkbrk> LordBrain: this may also be of use: http://www.joachim-breitner.de/blog/156-Haskell_on_the_Command_Line
02:33:46 <basedsiren> yo are there any haskell IDEs? and if so are they good?
02:34:22 <vixlur> emacs and vim arent good enough?
02:34:55 <basedsiren> just asking
02:35:20 <dkbrk> basedsiren: check out ghc-mod http://www.mew.org/~kazu/proj/ghc-mod/en/
02:35:24 <basedsiren> i prefer sublime, so i guess im a heathen
02:35:55 <dkbrk> sublime has ghc-mod integration
02:36:14 <basedsiren> well i mean in terms of vim vs emacs
02:40:03 <Haskellfant> there is leksah or something with a similar name
02:49:57 * hackagebot bitmaps 0.2.6.3 - Bitmap library  http://hackage.haskell.org/package/bitmaps-0.2.6.3 (ByronJohnson)
02:49:59 * hackagebot ghcjs-dom 0.1.1.1 - DOM library that supports both GHCJS and WebKitGTK  http://hackage.haskell.org/package/ghcjs-dom-0.1.1.1 (HamishMackenzie)
02:51:21 <basedsiren> yo i forgot how to compile, hwo do i do it?
02:54:13 <makalu> which emacs package had M-C-l for loading a file in ghci?
02:54:29 <slomo> are async exceptions masked inside unsafePerformIO or will i have to do that myself (or alternatively handle exceptions happening at any point)?
02:55:56 <slomo> basically i'm allocating some memory with mallocBytes inside unsafePerformIO and don't want to leak that if something interrupts in the middle
02:56:50 <makalu> I think I remembered the keybinding incorrectly
03:00:14 <Haskellfant> makalu: haskell-mode uses C-l C-l
03:00:31 <Haskellfant> not sure if anybody really uses anything but haskell-mode
03:00:47 <makalu> it was "C-c C-l". This https://github.com/serras/emacs-haskell-tutorial/blob/master/tutorial.md describes how to define that binding but it starts some kind of "project". I remember there was a possibility to just load a file in ghci. Does anyone know how to do that?
03:01:09 <makalu> Haskellfant: C-l C-l doesn't do anything for me :(
03:01:17 <Haskellfant> oh right C-c C-l
03:01:25 <Haskellfant> I just type whatever my fingers tell me so :)
03:01:38 <Haskellfant> just hit enter a few times and your file will get loaded
03:02:40 <makalu> oh, I had to put (interactive-haskell-mode) in the hook
03:03:05 <makalu> but what's with that project stuff? There used to be no "projects"
03:04:20 <makalu> maybe I used inf-haskell-mode
03:04:54 <makalu> no, even that has it
03:05:06 <Haskellfant> I think it got in there at some point
03:05:13 <Haskellfant> you can have multiple ghci sessions open
03:05:21 <Haskellfant> and then decide in which one you want to load your files
03:05:33 <makalu> why?
03:06:24 <makalu> sorry, inf-haskell-mode still works in the old way (I forgot to disable interactive-haskell-mode), I'll use that while it's still there
03:29:58 * hackagebot elevator 0.1.2 - Immediately lifts to a desired level  http://hackage.haskell.org/package/elevator-0.1.2 (FumiakiKinoshita)
03:30:00 * hackagebot vcswrapper 0.1.1 - Wrapper for source code management systems  http://hackage.haskell.org/package/vcswrapper-0.1.1 (HamishMackenzie)
03:30:11 <ChristianS> a question to the vim users here: which haskell mode do you use, the default or http://projects.haskell.org/haskellmode-vim/ or https://github.com/begriffs/haskell-vim-now ? or anything else?
03:34:23 <batbird> hi, can I just dump the result of an expression?
03:34:50 <mauke> > 1 + 2
03:34:52 <lambdabot>  3
03:34:52 <mauke> like this?
03:35:06 <batbird> > getSomeWeirdResult input
03:35:07 <lambdabot>  Not in scope: ‘getSomeWeirdResult’Not in scope: ‘input’
03:35:19 <batbird> assume that those are defined but not instances of Show.
03:35:34 <mauke> then no
03:35:57 <batbird> haskell sucks, php is better
03:36:27 <mauke> obviously
03:40:00 <jle`> what would the "result" even be
03:40:19 <jle`> :o
03:40:40 <Haskellfant> just print some pointer, that's obviously extremely useful!
03:45:38 <chrisdone> you guys joke but it sucks that ghci can't just print anything
03:46:24 <chrisdone> its purpose of a REPL is read-eval-PRINT-loop, not read-eval-complain-loop. its job is to print your data structures and it sucks at it half of the time
03:47:00 <chrisdone> which is what i'm working on improving =)
03:47:22 <vixlur> haskell is not magic, when you want to print something, you must tell that this thing can be printed
03:47:23 <chrisdone> i don't think you *should* need an instance of anything, that leaves you at the author's whim to be able to debug anything reasonably
03:47:29 <apo> chrisdone: improve your stats thing first!
03:47:43 <chrisdone> apo: i have fingers in many pies =p
03:47:57 <apo> more than ten?
03:48:37 <apo> should I be worried, or these all your own fingers?
03:48:52 <chrisdone> italians have twenty fingers
03:49:01 <chrisdone> ten on the hand, ten on the foot
03:51:45 <rom1504> and twenty on the pizza
03:51:58 <chrisdone> buon apetito
03:54:59 * hackagebot vcsgui 0.1.1.0 - GUI library for source code management systems  http://hackage.haskell.org/package/vcsgui-0.1.1.0 (HamishMackenzie)
04:02:29 <makalu> I want to apply a pure function to a list concurrently. I used async's mapConcurrently. But of course the threads immediately return a list of thunks that the main thread will then evaluate. I tried using deepseq but it didn't change anything.
04:03:50 <makalu> I compiled with threaded, I print out getNumCapabilites and it's more than one. Is it possible that all the lightweight threads are mapped to the same physical core?
04:05:37 <makalu> the documentation of deepseq hints that I'm looking at the right place "It is also useful in parallel programs, to ensure pending work does not migrate to the wrong thread"
04:06:11 <chrisdone> are you using +RTS -N<number of cores> when running the program?
04:06:44 <makalu> I used -with-rtsopts=-N in cabal
04:07:01 <makalu> and if getNumCapabilities returns >1 then it should already be working?
04:09:49 <makalu> I see that my program has multiple threads in top but only one core is at 100%
04:12:00 <chrisdone> makalu: where is your strictness being introduced?
04:12:22 <shachaf> deepSeq is usually the wrong answer
04:12:38 <makalu> interesting, the core that is at 100% changes
04:12:45 <shachaf> (Which is to say that it's proposed as an answer way more often than it's actually appropriate.)
04:13:30 <chrisdone> shachaf: i was thinking the same… usually the strictness is in the wrong place so people throw the deepseq hammer at it
04:14:09 <makalu> I never use strictness except in data fields. So it's very probable that I'm doing something wrong.
04:14:21 <shachaf> makalu: That's probably just the kernel moving your thread around, nothing to do with Haskell specifically.
04:14:37 <makalu> every thread gets a list, calculates the values and applies force to each value basically
04:14:54 <shachaf> makalu: Have you shown your code yet?
04:15:07 <makalu> no
04:15:12 <chrisdone> mapConcurrently :: Traversable t => (a -> IO b) -> t a -> IO (t b)
04:15:27 <chrisdone> what is the type of `b' in your case?
04:16:19 <chrisdone> and how are you introducing strictness on it?
04:16:53 <shachaf> b doesn't have a type. :-)
04:16:54 <chrisdone> if you're doing return (seq x x), for example, then mapConcurrently will not be strict in the elements of the `t'
04:17:11 <chrisdone> shachaf: ho ho ho
04:19:10 <makalu> chrisdone: yes, I'm basically applying seq to each list element. That means I create a thunk that calls seq?
04:20:08 <shachaf> makalu: I think showing your code would make this significantly easier.
04:21:05 <chrisdone> > let x = error "forced" in return (seq x x) >> return () :: Maybe ()
04:21:07 <lambdabot>  Just ()
04:22:03 <chrisdone> makalu: pretty much. you're making a data structure full of thunks, i expect
04:22:28 <Black0range> Howdy ladies! How / Where could one find the source code for the diffrent haskell libraries?
04:23:10 <chrisdone> makalu: you need to make the strictness of `b' dependent upon the strictness of IO, so e.g.
04:23:13 <chrisdone> > let x = error "forced" in (return $! x) >> return () :: Maybe ()
04:23:14 <lambdabot>  *Exception: forced
04:23:27 <makalu> I added 'evaluate' from Control.Exception to the seq, it works now
04:23:59 <makalu> chrisdone: thank you for explaining
04:24:07 <chrisdone> makalu: welcome =)
04:26:20 <makalu> chrisdone: also, thank you for your work on haskell-mode
04:26:30 <chrisdone> =3
04:26:38 <makalu> <3
04:27:02 <Black0range> Anyone? :(
04:27:02 <chrisdone> Black0range: on hackage?
04:27:21 <Black0range> Both those and the one that comes with haskell
04:27:56 <chrisdone> the ones that come with ghc are in ghc's git repo
04:28:21 <chrisdone> well, some are
04:28:54 <chrisdone> you can find a bunch on https://github.com/ghc/ but also https://github.com/haskell
04:30:00 * hackagebot scrobble 0.2.1.1 - Scrobbling server.  http://hackage.haskell.org/package/scrobble-0.2.1.1 (ChrisDone)
04:31:30 <Black0range> ah thanks
04:31:43 <Black0range> These files are like mazes! :)
04:44:31 <Aruro> > let ptwo x = take 2 $ x:ptwo x
04:44:33 <lambdabot>  not an expression: ‘let ptwo x = take 2 $ x:ptwo x’
04:45:53 <Aruro> > let f x = x*x
04:45:54 <lambdabot>  not an expression: ‘let f x = x*x’
04:46:13 <Aruro> hm
04:46:56 <JohnnyBravo> http://lpaste.net/5567000746374725632 What's wrong?
04:48:08 <Aruro> looks like o is not char
04:48:14 <Aruro> o is a third word
04:48:20 <Aruro> it needs to be a char
04:48:50 <JohnnyBravo> so, it would be s!!2 instead?
04:48:55 <Aruro> xs!!2 is a second word
04:49:01 <Aruro> which has type [Char]
04:49:13 <Aruro> you need to dig deeper
04:49:31 <Aruro> like o = (xs!!2)!!1
04:49:35 <Aruro> something like this
04:49:47 <Aruro> > "123"!!1
04:49:48 <lambdabot>  '2'
04:49:58 <JohnnyBravo> oh
04:50:01 * hackagebot frisby 0.2 - Linear time composable parser for PEG grammars  http://hackage.haskell.org/package/frisby-0.2 (ChrisDone)
04:50:07 <Aruro> yes string is not Char
04:50:14 <Aruro> string is [Char]
04:50:23 <Aruro> collection of chars
04:50:30 <Aruro> :t String
04:50:31 <lambdabot> Not in scope: data constructor ‘String’
04:50:55 <Aruro> :i String
04:51:23 <Aruro> so you need to add extra !! to get o to be just symbol, Char
04:51:42 <Aruro> > words "what is wrong here"
04:51:43 <lambdabot>  ["what","is","wrong","here"]
04:51:58 <Aruro> > (words "what is wrong here")!!2
04:52:00 <lambdabot>  "wrong"
04:52:07 <Aruro> > (words "what is wrong here")!!2!!1
04:52:08 <lambdabot>  'r'
04:52:26 <JohnnyBravo> that would be !!2!!0 instead, no?
04:52:40 <Aruro> first letter yes
04:52:46 <Aruro> first letter of second word
04:52:51 <Aruro> > (words "what is wrong here")!!2!!0
04:52:52 <lambdabot>  'w'
04:52:59 <JohnnyBravo> alright
04:53:02 <Aruro> actually third in my case
04:53:07 <Aruro> > (words "what is wrong here")!!1!!0
04:53:10 <lambdabot>  'i'
04:53:14 <Aruro> that would be second
04:53:32 <Aruro> list index starts from zero
04:53:47 <Aruro> so you need to substract one from naive index
04:55:01 * hackagebot jsaddle 0.2.0.2 - High level interface for webkit-javascriptcore  http://hackage.haskell.org/package/jsaddle-0.2.0.2 (HamishMackenzie)
04:55:14 <Aruro> actually compiler told you that he got the problem with just O
04:55:25 <Aruro> o variable
05:16:39 <bitonic> edwardk: is there any reason why `magnify' shouldn't work for StateT too -- by changing the state temporarily and restoring the old one afterwards, instead of putting it back with a lens?
05:17:01 <bitonic> basically doing what `mapStateT' does, but without changing the result and the monad
05:45:03 * hackagebot yesod-form 1.4.3 - Form handling support for Yesod Web Framework  http://hackage.haskell.org/package/yesod-form-1.4.3 (MichaelSnoyman)
06:06:02 <Aruro> why ghci complains on following ---  let ptwo x = foldr (*) 1 $ take 2 $ x:ptwo x
06:06:11 <Aruro> tells can not construct infinite type
06:06:23 <paolino> hello , cabal has stopped updating with a cabal: Codec.Compression.Zlib: premature end of compressed stream. From google I couldn't see where the error is coming from. Anyone has the answer ?
06:06:42 <Aruro> if functions ptwo is broken into two than its fine
06:06:43 <paolino> :t foldr
06:06:44 <lambdabot> (a -> b -> b) -> b -> [a] -> b
06:07:02 <paolino> :t foldr (*)
06:07:05 <lambdabot> Num b => b -> [b] -> b
06:07:18 <Aruro> so?
06:07:40 <Aruro> take 2 does not give Num u want to say?
06:08:05 <paolino> b /= [b] I guess,but I'm surely rusty
06:08:13 <indigo945> there's a 1 in there
06:08:17 <indigo945> :t foldr (*) 1
06:08:18 <lambdabot> Num b => [b] -> b
06:08:26 <indigo945> the type checks out afaics
06:09:04 <indiagreen> maybe it should be “[x, ptwo x]”?
06:09:12 <indiagreen> since ptwo returns a number
06:09:25 <indiagreen> can't do “x : ptwo x”, can you
06:09:41 <indiagreen> Aruro: was ptwo meant to return a number or a list?
06:09:49 <indigo945> :t ptwo x = x:ptwo x
06:09:50 <lambdabot> parse error on input ‘=’
06:09:57 <indigo945> :let ptwo x = x:ptwo x
06:10:10 <indiagreen> :t let ptwo x = x : ptwo x in ptwo
06:10:11 <lambdabot> a -> [a]
06:10:49 <paolino> foldr (*) can't return [b]
06:11:14 <indigo945> :t let ptwo x = x:ptwo x in ptwo
06:11:14 <lambdabot> a -> [a]
06:11:27 <paolino> :t scanl
06:11:28 <lambdabot> (b -> a -> b) -> b -> [a] -> [b]
06:13:30 <indiagreen> paolino: about cabal – have you tried that thing on yan han's blog? where ne says removing all files in “~/.cabal/packages/hackage.haskell.org” helped nem
06:14:19 <indiagreen> when I was having it, tho, I had to install a newer version of cabal (I think – it was long ago)
06:14:50 <paolino> indiagreen, I would like to avoid that, not very haskelly
06:15:04 * hackagebot hills 0.1.0.1 - Generate STL models from SRTM elevation data.  http://hackage.haskell.org/package/hills-0.1.0.1 (djf)
06:16:47 <paolino> my system should be up to date, it's arch linux
06:17:27 <paolino> cabal-install version 1.18.0.2
06:17:27 <paolino> using version 1.18.1.2 of the Cabal library
06:18:42 <indiagreen> doesn't seem up-to-date, there's 1.20 in the repo
06:19:12 <paolino> right
06:22:11 <paolino> ok, I rm -rf 'em
06:23:47 <kcc> Is there a Haskell package that allows me to encrypt/decrypt some message for transmission over an untrusted channel (e.g. Internet), but without using SSL/TLS? I control both endpoints and would like to use a pre-shared key.
06:23:51 <Bubblegum> Could someone give me a push regarding the function profit? the vague algorithm is included in the text. http://lpaste.net/115372
06:26:09 <mm_freak_> hi there…  perhaps someone here knows…
06:26:28 <mm_freak_> let F :: * -> *, let A :: F Int, let x = A
06:26:35 <mm_freak_> normally x :: F Int
06:26:58 <mm_freak_> is there a way to construct x such that x :: forall a. F a?  that should be safe, since pattern-matching will refine the type anyway
06:27:38 <Cale> No, that wouldn't be type safe. You mean x :: exists a. F a
06:28:00 <mm_freak_> no, actually forall…  why would it be unsafe?
06:28:19 <Cale> Because then I can specialise to x :: F Char
06:28:33 <Cale> and pattern matching will get me Char ~ Int
06:28:44 <mm_freak_> you're right =/
06:30:01 <mm_freak_> the idea was the following:  newtype TiMap k = TiMap (forall a. (Ord (k a)) => Map (k a) Dynamic)
06:30:18 <mm_freak_> with:  tiLookup :: (Ord (k a)) => k a -> TiMap k -> Maybe a
06:30:35 <mm_freak_> you can write tiLookup and tiSingleton, but you can't /use/ tiSingleton
06:31:19 <mm_freak_> tiSingleton :: (forall a. (Ord (k a)) => (k a, a)) -> TiMap k -> TiMap k
06:31:38 <mm_freak_> is there anything like that that works?
06:32:01 <mm_freak_> i need a type-safe heterogenous map, where the key determines the element type
06:32:18 <mm_freak_> (ideally without singletons)
06:36:15 <Cale> mm_freak_: There are a couple packages on hackage like that
06:36:22 <Cale> http://hackage.haskell.org/package/hetero-map-0.21/docs/HeteroMap-Map.html
06:36:27 <Cale> http://hackage.haskell.org/package/HMap
06:38:05 <Aruro> sorry was away
06:38:13 <Aruro> are you still here indiagreen?
06:38:31 <Aruro> i was trying to make a recursive definition for function f x = x*x
06:39:15 <Aruro> if you put like this  let ptwo x = foldr (*) 1 $ take 2 $ x:ptwo x
06:39:35 <Aruro> then ghci complains, but if you remove fodlr to another function
06:39:38 <Aruro> than its possible
06:39:51 <paolino> scanl ?
06:39:56 <Aruro> i dont get why in one expression it complains a lot
06:40:20 <Aruro> let me see
06:40:23 <mm_freak_> Cale: thanks, but neither of them are really what i need
06:40:27 <paolino> foldr (*) is not returning a list
06:41:21 <Aruro> yes but the definition of ptwo written above should return just number
06:41:22 <Aruro> not list
06:41:35 <Aruro> so compiler can not figure that out?
06:41:54 <paolino> then x:ptwo is wrong
06:42:20 <paolino> x:[ptwo x] is a list
06:43:02 <indiagreen> Aruro: it would be easier for you to understand what's going wrong if you wrote type signatures for all functions
06:43:25 <Aruro> if i do like this let ptwo x = take 2 $ x:ptwo x , then define let power2 x = foldr (*) 1 $ ptwo x , than it works
06:43:54 <indiagreen> because now ptwo returns a list
06:44:02 <Aruro> yes
06:44:06 <indiagreen> and power2 returns a number
06:44:09 <Aruro> polimorphic list
06:44:27 <Aruro> so inference in one line is not working somehow?
06:45:02 <indiagreen> no, in one line you want a function to return a list and a number at once, it seems
06:45:10 <Aruro> hm
06:45:23 <indiagreen> > Aruro: was ptwo meant to return a number or a list?
06:45:24 <lambdabot>  <hint>:1:52:
06:45:24 <lambdabot>      parse error (possibly incorrect indentation or mismatched brackets)
06:45:26 <Aruro> i see it as just number
06:45:31 <Aruro> number
06:45:37 <Aruro> in original one line form number
06:45:41 <indiagreen> yep
06:45:45 <Aruro> just emulate function f x = x*x
06:46:12 <Aruro> so where is catch?
06:46:13 <phaskell> No symbol 'catch' found anywhere.
06:46:22 <mm_freak_> Aruro: i second indiagreen's suggestion…  writing type signatures is important in haskell, despite type inference
06:46:36 <mm_freak_> they are documentation for you and help the compiler to generate much more useful error messages
06:46:46 <mauke> T42
06:46:46 <phaskell> T42: Move wiki to a new server (with DNS). - https://phabricator.haskell.org/T42
06:46:56 --- mode: ChanServ set +o mauke
06:46:57 --- kick: phaskell was kicked by mauke (phaskell)
06:46:57 <indiagreen> Aruro: am I understanding correctly that “foldr (*) 1 $ take 2 $ x:ptwo x” is basically “x * ptwo x”?
06:47:16 <Aruro> no
06:47:19 <Aruro> its just x*x
06:47:41 <indiagreen> okay, then what is the role of “ptwo x” in “x:ptwo x”?
06:47:42 <Aruro> whole foldr emulates x*x
06:47:52 <Aruro> it creates infinite list
06:47:56 <Aruro> to have recusion
06:47:56 <indiagreen> ah
06:48:01 <indiagreen> so ptwo should return a list?
06:48:13 <Aruro> no ptwo is just number
06:48:26 <Aruro> but then there is list of this numbers inside function
06:48:36 <indiagreen> “ptwo x” is a number, “x:ptwo x” is an infinite list?
06:48:39 <Aruro> itself function returns number
06:48:46 <Aruro> yes
06:48:50 <indiagreen> we-ell
06:48:51 <Aruro> exactly
06:48:53 <osa1> somehow my IOArray of Word8 allocates huge amounts of memory. I'm wondering if it's using Int internally.
06:48:57 --- mode: mauke set -o mauke
06:49:00 <indiagreen> it doesn't exactly work this way
06:49:20 <Aruro> mm freak pointed out good thing maybe if i will support definition with type declaration it will work
06:49:22 <Aruro> lets see
06:49:44 <Aruro> in this case ptwo x:: Int -> Int
06:49:51 <indiagreen> “x:ptwo x” actually means “take x and prepend it to the list – namely, «ptwo x»”
06:49:53 <mm_freak_> Aruro: if it doesn't work without, it most likely won't work with it, but you will get a much more useful error message
06:50:05 * hackagebot yesod-core 1.4.6 - Creation of type-safe, RESTful web applications.  http://hackage.haskell.org/package/yesod-core-1.4.6 (MichaelSnoyman)
06:50:13 <mm_freak_> osa1: IOArray allocates an array of references to lazily evaluated values
06:50:17 <ClaudiusMaximus> osa1: IOUArray might use less memory, but it's unboxed so doesn't support lazy self-reference
06:50:22 <mm_freak_> osa1: if you need a dense array, you need IOUArray
06:50:23 <Aruro> yes but then i do foldr on that list
06:50:30 <Aruro> getting back number out of it
06:50:36 <osa1> mm_freak_: aha, that should be it. thanks.
06:50:43 <paolino> :t (:)
06:50:44 <lambdabot> a -> [a] -> [a]
06:50:48 <osa1> hm, which lib has that?
06:51:06 <osa1> ah right, found it
06:51:25 <mm_freak_> osa1: btw, in most cases you probably want to use the 'vector' library over the 'array' library
06:51:29 <indiagreen> wait, do you want an infinite list of “x”s?
06:51:57 <Aruro> yes
06:51:59 <Aruro> exactly
06:52:03 <Aruro> thats why i have take
06:52:04 <Aruro> there
06:52:08 <osa1> amazing, it finally allocates sensible amounts
06:52:10 <indiagreen> aha, it's clearer now
06:52:25 <indiagreen> okay, now, can you explain why “x:ptwo x” should return an infinite list of “x”s?
06:52:28 <Aruro> i wanted to write simple square function x*x using recursion
06:52:33 <osa1> mm_freak_: I just need a byte buffer with write/(unsafe)read operations
06:52:46 <Aruro> because it is recursive it calls itself again
06:52:52 <mm_freak_> osa1: there are at least four ways to get one in haskell =)
06:53:00 <Aruro> then you will have x:x:x:ptwo x
06:53:06 <Aruro> till infinity
06:53:20 <Aruro> there is no even empty list element there it seems
06:53:20 <osa1> mm_freak_: can you list?
06:53:44 <indiagreen> I agree that if you simply said “let ptwo x = x : ptwo x”, then ptwo would return an infinite list
06:54:09 <indiagreen> (and in fact this function already exists and is called “repeat”)
06:54:27 <mm_freak_> osa1: the array library (that you're currently using), the vector library, the primitive library and the Foreign.* modules
06:54:46 <indiagreen> however, you're saying “let ptwo x = foldr (*) 1 $ take 2 $ x:ptwo x”, so you're definining a rather different ptwo
06:54:51 <mm_freak_> vector is based on primitive, so you would probably use that one in most cases
06:54:52 <indiagreen> *defining
06:55:22 <mm_freak_> the array library is really mostly a historical relic
06:55:56 <indiagreen> so, this appears to be some sort of confusion, because in general you want ptwo to return a number scared, but in some other place you want it to return an infinite list, and it clearly can't do both
06:57:25 <Aruro> yes confusion i agree
06:57:30 <Aruro> i dot see where is problem
06:57:34 <Aruro> look at this code http://lpaste.net/115375
06:57:43 <Aruro> it will work perfectly in ghci
06:57:56 <Aruro> but if you compose them into one it brakes :)
06:58:07 <Aruro> so this function is not possible to unite for some reason
06:58:08 <indiagreen> because you haven't “composed” them
06:58:19 <Aruro> so why it is not possible?
06:58:25 <Aruro> that is the real question :)
06:58:31 <indiagreen> in your paste you say: “ptwo x = take 2 $ x:ptwo x”
06:58:39 <Aruro> yes
06:58:41 <indiagreen> please tell me what “ptwo 3” would return
06:58:50 <Aruro> [3,3]
06:58:53 <Aruro> clearly
06:59:00 <Aruro> its polimorphic
06:59:01 <indiagreen> yep
06:59:08 <indiagreen> and then in “power2 x = foldr (*) 1 $ ptwo x”
06:59:10 <Aruro> it will return also ["123","123"]
06:59:18 <indiagreen> let's say I'm evaluating “power2 3”
06:59:28 <indiagreen> “x” would be substituted for “3”
06:59:29 <Aruro> yes
06:59:38 <indiagreen> then “ptwo x” would be evaluated to [3, 3]
06:59:54 <indiagreen> then “foldr (*) 1” would take [3, 3] and make 9 out of it
06:59:58 <indiagreen> and that's the result
07:00:00 <indiagreen> right?
07:00:04 <Aruro> yes excatly
07:00:12 <Aruro> but it is exactly same in composition :)
07:00:17 <indiagreen> not exactly
07:00:23 <Aruro> i think, or at least i see it like that
07:00:31 <Aruro> where is difference?
07:00:45 <Aruro> functional language functions have to be composable
07:00:49 <indiagreen> (pasting the 2nd definition again: “let ptwo x = foldr (*) 1 $ take 2 $ x:ptwo x”)
07:00:49 <wei2912> okay
07:00:55 <wei2912> think of this
07:00:57 <Aruro> yes
07:01:05 <Aruro> one line composition
07:01:12 <wei2912> what does `ptwo x` return?
07:01:19 <wei2912> err, where x =
07:01:19 <indiagreen> can you start evaluating “ptwo 3” in the same way as I showed you?
07:01:20 <wei2912> err, where x = 3
07:01:22 <wei2912> ^^
07:01:23 <indiagreen> out loud
07:01:27 <Aruro> it will return 9
07:01:35 <indiagreen> no, follow your definition
07:01:38 <Aruro> because it will fold inside following list [3,3]
07:01:58 <Aruro> it will have take 2 $ 3:3
07:02:02 <wei2912> Aruro: evaluate step by step
07:02:10 <Aruro> what is wrong in my understanding?
07:02:18 <wei2912> your definition of ptwo has changed
07:02:32 <Aruro> you want to say it will not wait infinite list?
07:02:40 <Aruro> will apply foldr immediately?
07:02:41 <indiagreen> okay, I'll start evaluating it and you'll see what the problem is
07:02:52 <Aruro> i think i got it now
07:02:56 <Aruro> foldr will get inside list
07:02:57 <indiagreen> tell
07:02:58 <Aruro> right?
07:03:11 <Aruro> or maybe not :) but something like that
07:03:26 <paolino> ptwo 3 is 9 or [3,3] cannot be both
07:03:28 <Aruro> it will be nested foldrs which we dont have
07:03:36 <Aruro> now i see
07:03:48 <Aruro> while in decomposed state its only nested 3's
07:04:08 <Aruro> so recursion grabbed the flodr part too
07:04:31 <Aruro> thus composition of recursive function is not same as non recursive ones :)
07:05:09 <Aruro> my logicl is valid?
07:05:23 <wei2912> always evaluate the code before you think of anything else and assume supposed laws
07:06:01 <Aruro> it will be nice to have recursion range
07:06:18 <Aruro> that i am able how far recursion propagates in a given line
07:06:20 <mm_freak_> Aruro: try to think really simple…  haskell is all about saying, meaning and interpreting
07:06:24 <mm_freak_> Aruro: in haskell "x = y" means "when i say x, i mean y"
07:06:40 <Aruro> yes that is clear
07:06:51 <Aruro> i think we understood this example now
07:07:08 <chrisdone> wei2912: very Knuthic advice
07:07:19 <mm_freak_> Aruro: the point is that recursion is nothing special in haskell, and you shouldn't even bother thinking about it too much
07:07:24 <paolino> recursion is only definition reuse , there is nothing magic
07:07:37 <Aruro> only question remains is there a way to write recursive ptwo giving you number squared in one line?
07:07:38 <nshepperd> well, you can't just paste in the body of a recursive function that needs to use its own name, that  much is true
07:07:50 <mm_freak_> foldr (*) 1 (x:xs) = x * foldr (*) 1 xs
07:07:54 <mm_freak_> that's because foldr is defined that way
07:08:06 <mm_freak_> don't try to figure out "recursion"…  just look at the definition
07:08:41 <Aruro> yes, we did that i think
07:09:36 <nshepperd> but you can instead do something like "power2 x = let ptwo' = take 2 (x : ptwo') in foldr (*) 1 ptwo'
07:09:47 <wei2912> chrisdone: i'll take that as a compilment
07:09:55 <wei2912> chrisdone: too bad i haven't read TAOCP :(
07:10:00 <mm_freak_> Aruro: what is it that you're trying to write anyway?
07:10:00 <wei2912> thanks, anyways
07:10:08 <Aruro> nshepperd let me think about that
07:10:13 <nshepperd> if you really want to use that sort of 'recursive' definition
07:10:20 <Aruro> i was trying to write f x = x*x , using recursion
07:10:31 <mm_freak_> why?
07:10:38 <Aruro> because i want :)
07:10:40 <wei2912> just because you can
07:10:43 <wei2912> for sciece!
07:10:48 <mm_freak_> f x = const (x*x) f
07:10:48 <mm_freak_> there
07:10:52 <Aruro> exactly :)
07:10:58 <wei2912> science, even
07:11:16 <Aruro> no u used trick
07:11:25 <Aruro> you already have x*x there
07:11:33 <Aruro> not valid for our investigation
07:11:53 <Aruro> shepperd wrote something different
07:12:01 <mm_freak_> Aruro: you're trying to write /f/ recursively, and that's your mistake
07:12:10 <Aruro> not mistake man
07:12:11 <mm_freak_> Aruro: try instead to write (*) recursively in terms of (+)
07:12:12 <Aruro> i want it
07:12:27 <wei2912> mm_freak_++
07:12:35 <Aruro> ok plus idea is better
07:13:05 <exio4> and then define + in terms of "succ"!
07:13:21 <Aruro> shepperd you basically managed to combine our two functions from here http://lpaste.net/115375
07:13:22 <Aruro> using let
07:13:27 <paolino> Aruro, foldr1 (*) [x,x] is not different from x*x, so both cheating
07:13:42 <Aruro> i assume its fine but thechnically it is still two blocks
07:14:00 <Aruro> why its not different?
07:14:07 <Aruro> i think it is
07:14:10 <wei2912> nope
07:14:14 <paolino> :t fix
07:14:16 <lambdabot> (a -> a) -> a
07:14:18 <wei2912> you still use the multiplication operator
07:14:20 <Aruro> with foldr you can have x to power of n
07:14:26 <Aruro> while * will not give you that
07:14:27 <mm_freak_> if you want to use recursion, you should have something to use it for in the first place…  combining a given multiplication function and a given number to find the square of that number really doesn't need and doesn't want recursion
07:14:41 <wei2912> recursion should be only used when you need recursion
07:14:51 <Aruro> o we got it :)
07:14:57 <wei2912> don't attempt to use your new-learnt tools everywhere without knowing how and where to use it
07:15:09 <indiagreen> I disagree
07:15:20 <Aruro> im trying to understand the how if you did not notice
07:15:21 <mm_freak_> you can shoehorn recursion to solve a non-recursive problem, but the result will be neither pretty nor useful, nor will you have learned anything of value except how to waste your time =)
07:15:29 <Aruro> and that composition example is really good
07:15:30 <Aruro> i think
07:15:32 <indiagreen> do attempt to apply new-learned tools to everything, otherwise you will never learn how and where to use them
07:15:34 <Aruro> should be used in teaching
07:15:55 <wei2912> indiagreen: as long as you don't use it in production code, i guess it's fine
07:16:15 <indiagreen> Aruro: were you going to use pwto in production code? Answer honestly.
07:16:21 <indiagreen> *ptwo
07:16:27 <paolino> > fix (x:)
07:16:29 <lambdabot>  [x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x...
07:16:30 <wei2912> i don't think so
07:16:30 <Aruro> im not interested in that
07:16:37 <indiagreen> ah 'kay then
07:16:43 <Aruro> i dont do production at the moment just thinking
07:16:45 <wei2912> if he is...
07:17:09 <Aruro> we had nice talk here yesterday about recursion
07:17:15 <Aruro> fix was mentioned at the end
07:17:23 <mm_freak_> Aruro: anyway, writing (*) in terms of (+) is really a useful exercise, both for arithmetic and for recursion =)
07:17:41 <Aruro> ok let me think about it :)
07:17:43 <mm_freak_> and also performance, because there are plenty of ways to do it wrong =)
07:17:46 <paolino> but don't use it in production
07:18:29 <mm_freak_> if you add left-shifts to the mix, you can actually end up with a (*) that has quite decent performance
07:18:38 <mm_freak_> oh, and i should mentioned that i'm talking about (*) for Integer =)
07:18:43 <wei2912> > let x `multiply` y = sum $ replicate y x in 3 `multiply` 2
07:18:45 <lambdabot>  6
07:19:04 <wei2912> i guess that's technically using (+)
07:19:11 <wei2912> :P
07:19:42 <mm_freak_> wei2912: be fair…  don't spoil ;)
07:20:08 <Aruro> maan
07:20:12 <Aruro> im working on it :D
07:20:12 <wei2912> mm_freak_: it's not with recursions, so it's fine :D
07:20:17 <wei2912> s/s//
07:20:40 <mm_freak_> Aruro: don't use lists for solving it
07:20:47 <paolino> sum and replicate are recursive
07:20:58 <wei2912> paolino: as in, directly
07:21:04 <Aruro> its a constrain or suggestion?
07:21:08 <wei2912> constraint
07:21:19 <wei2912> just pretend lists never existed in your life
07:21:28 <paolino> so haskell
07:22:37 <mm_freak_> Aruro: from me it's just a suggestion, because it will make you think about your good old arithmetic laws =)
07:23:04 <mm_freak_> Aruro: feel free to regard it as a constraint…  i would suggest to do so
07:23:31 <Aruro> k
07:24:02 <mm_freak_> Aruro: if you don't know how to do it, recall two facts from school:
07:24:15 <mm_freak_> 1. x*y = (1 + x - 1)*y
07:24:21 <mm_freak_> 2. the distributive law
07:24:49 <wei2912> another hint
07:24:56 <mm_freak_> don't give more hints =)
07:25:00 <Aruro> yes
07:25:03 <wei2912> no hints for you!
07:25:03 <wei2912> :D
07:25:06 <Aruro> no hints let me think :D
07:35:58 <brrrrian> hello
07:39:20 <wei2912> Aruro: how's it going? :)
07:39:34 <Aruro> i need guards :D
07:39:45 <Aruro> working out my math
07:40:40 <brrrrian> I have a large binary protocol (representing a file or network packets etc), and I've written a body of code to handle the serialization using Data.Binary.  At the highest level, it exposes a bunch of data types 'data A = A { field1 .. .fieldN }' and a function to put/get one of these msgs that can be expressed by the protocol.
07:40:42 <mm_freak_> Aruro: did you apply the distributive law?
07:40:59 <oiio> any idea why when i use getLine i can't use backspace and arrow keys because they start putting this characters ^? etc
07:41:14 <mm_freak_> oiio: you might be in binary mode for stdin
07:41:15 <brrrrian> I have implemented version 1.0, and am having trouble trying to envision the best way to include support for version 2.0 of the protocol.
07:41:24 <mm_freak_> :t hSetBinaryMode
07:41:26 <lambdabot> Not in scope: ‘hSetBinaryMode’
07:41:30 <mm_freak_> :t System.IO.hSetBinaryMode
07:41:32 <lambdabot> GHC.IO.Handle.Types.Handle -> Bool -> IO ()
07:41:40 <mm_freak_> oiio: see above
07:41:43 <brrrrian> Version 2.0 has changed about 50% of the protocol.  So I am not sure how to properly handle this abstraction.
07:41:57 <oiio> mm_freak_: ok
07:42:06 <brrrrian> e.g. if I should create a typeclass
07:42:29 <mm_freak_> brrrrian: depends on where you choose the version
07:42:37 <mm_freak_> at session init?  statically?  …?
07:42:57 <brrrrian> mm_freak_: the version is determined at session init
07:43:11 <mm_freak_> brrrrian: do the types differ?
07:43:17 <brrrrian> mm_freak_: which types?
07:43:44 <mm_freak_> brrrrian: the "bunch of data types" you wrote =)
07:44:46 <brrrrian> mm_freak_: yes the wire protocol changes quite a bit... lets say roughly 50% of it is common
07:45:25 <mm_freak_> brrrrian: then i suggest writing entirely independent types and functions and share functionality only where it makes sense
07:45:40 <mm_freak_> brrrrian: after you've done that write a more abstract type that abstracts over the protocol
07:45:42 <brrrrian> I am thinking a typeclass that would have a get/put interface.. and then Protocol1.0 instance / Protocol2.0 instance and then have those share common code... but I'm not sure if this is a good approach
07:46:16 <oiio> mm_freak_: nope i get ^? and [OD
07:46:53 <paolino> oiio, I use haskeline for better editing
07:47:53 <brrrrian> mm_freak_: I suppose I am trying to understand how I would even go about creating that abstract type that abstracts over the protocol.  I have been searching projects on hackage for a good example of how to do this, but haven't found one yet.
07:48:31 <oiio> paolino: isn't there something simpler?
07:49:37 <paolino> haskeline is haskell IIRC so you should be able to take what you need from there
07:51:37 <mm_freak_> oiio: the run-time system for your operating system might not support fancy line reading…  what paolino said
07:51:50 <mm_freak_> oiio: getLine isn't for interactive applications anyway
07:51:57 <paolino> and it's in the haskell platform so it's available for every platform
07:52:10 <mm_freak_> brrrrian: first step is to create one of the protocol handlers
07:52:13 <oiio> mm_freak_: os x
07:53:52 <brrrrian> mm_freak_: I've written the 1.0 version and have confidence in doing the same for 2.0.  I thought I would study up on how to handle abstraction properly up front before having to scrap/merge stuff if I duplicated the current approach for 2.0
07:54:28 <mm_freak_> in general you should not write type classes unless you're reflecting a kind of standard API with some laws
07:54:49 <mm_freak_> most unified APIs should be based on a type, not a class
07:55:09 * hackagebot ltk 0.14.0.2 - Leksah tool kit  http://hackage.haskell.org/package/ltk-0.14.0.2 (HamishMackenzie)
07:55:26 <paolino> type families chould help
07:55:43 <paolino> *should
07:57:34 <paolino> rm all packages for a cabal bug is resulting in a holiday on irc with this atom based netbook involved in cabal reinstall all
07:57:38 <mm_freak_> in general whenever you're inclined to write a class, ask yourself:  "is anyone else going to write an instance and will they benefit from functionality for free when they do it?"
07:57:42 <mm_freak_> if no, don't write a class
07:58:18 <mm_freak_> example:  many unrelated people will want to write Monad instances, and in return they get mapM and foldM
07:58:25 <paolino> right
07:58:39 <Aruro> ok after lost of painful arithmetical mistakes i got this ugly version
07:58:57 <mm_freak_> many people will want to write Foldable and/or Monoid instances, and they will get foldMap for free from doing it
07:58:59 <mm_freak_> etc.
07:59:20 <mm_freak_> well…  semi-for-free =)
07:59:30 <Aruro> ptwo' x = let pt x = if x/=0 then x+pt (x-1) else 0 in x*(x-1)/2+pt x
07:59:46 <Aruro> ugly but does the job
07:59:57 <Aruro> i dont know if i used distributive law
08:00:06 <mm_freak_> Aruro: you used it
08:00:41 <Aruro> is that what you had in mind?
08:00:47 <Aruro> or you have something more neat?
08:01:01 <mm_freak_> Aruro: well, not quite…  i thought you would write a generic multiplication function
08:01:17 <paolino> without (*)
08:01:17 <Aruro> yes that is easier
08:01:25 <Aruro> or wait
08:01:28 <mm_freak_> Aruro: it's the same thing =)
08:01:45 <Aruro> its easy to write x to power n using recursion
08:01:50 <Aruro> because you have two arguments
08:02:00 <Aruro> fixed power it more complicated
08:02:09 <mm_freak_> Aruro: that's because you use the exponential law:  x^(y + 1) = x * x^y
08:02:19 <mm_freak_> almost the exact same thing holds for multiplication
08:02:32 <Aruro> so how you would write it?
08:02:38 <Aruro> share the wisdom
08:03:02 <Aruro> my version i dislike because of if and formula present in it
08:03:02 <mm_freak_> Aruro: the distributive law states:  (a + b)*x = a*x + b*x
08:03:15 <Aruro> k
08:03:15 <mm_freak_> Aruro: now you want to multiply x and y
08:03:24 <Aruro> yes
08:03:28 <mm_freak_> first note that x = 1 + x - 1
08:03:34 <Aruro> yes
08:03:52 <mm_freak_> x * y = (1 + x - 1)*y
08:04:00 <mm_freak_> of course (+) is associative
08:04:04 <mm_freak_> x * y = (1 + (x - 1))*y
08:04:16 <mm_freak_> now apply the distributive law:
08:04:16 <Aruro> agree
08:04:24 <mm_freak_> x * y = 1*y + (x - 1)*y
08:04:38 <batbird> sum( zipWith (\a -> \b -> abs(a*b+3*b-a)) (concat matrix1) (concat matrix2) ) <-- apparently, that's incredibly slow (35 times slower than just returning a number). Is it a consequence of using haskell or is that line badly designed?
08:04:39 <Aruro> but then you need two argument function
08:04:46 <mm_freak_> and then note that 0*y = 0
08:04:58 <mm_freak_> well, (*) /is/ a two-argument function =)
08:04:58 <Aruro> or not?
08:05:08 * hackagebot ghc-pkg-lib 0.2.1 - Provide library support for ghc-pkg information  http://hackage.haskell.org/package/ghc-pkg-lib-0.2.1 (JeanPhilippeMoresmau)
08:05:11 * hackagebot semi-iso 0.5.0.0 - Weakened partial isomorphisms that work with lenses.  http://hackage.haskell.org/package/semi-iso-0.5.0.0 (pawel834)
08:05:14 * hackagebot syntax 0.3.0.0 - Syntax descriptions for unified parsing and pretty-printing.  http://hackage.haskell.org/package/syntax-0.3.0.0 (pawel834)
08:05:15 <Aruro> well ok so how would it look in final version?
08:05:15 * hackagebot syntax-attoparsec 0.3.0.0 - Syntax instances for Attoparsec.  http://hackage.haskell.org/package/syntax-attoparsec-0.3.0.0 (pawel834)
08:05:16 * hackagebot syntax-printer 0.1.0.0 - Text and ByteString printers for 'syntax'.  http://hackage.haskell.org/package/syntax-printer-0.1.0.0 (pawel834)
08:05:34 <mm_freak_> i would recurse on the right value (y)
08:05:52 <mm_freak_> first apply the laws:
08:06:10 <mm_freak_> x * y = x*(y - 1 + 1)
08:06:21 <mm_freak_> = x*(y - 1) + 1*x
08:06:29 <Aruro> ok but how it will actually look? you will need end check no?
08:06:39 <mm_freak_> this is your recursive part
08:06:55 <mm_freak_> x * y | y > 0 = x*(y - 1) + x
08:07:08 <mm_freak_> and the base part is:  x*0 = x
08:07:25 <Aruro> hm
08:07:28 <Aruro> ok
08:07:32 <Aruro> sounds nice :)
08:07:37 <Aruro> still it is slightly different
08:07:41 <Aruro> from one argument analog
08:07:43 <mm_freak_> then since it's Integer you need one additional clause
08:08:01 <mm_freak_> x * y | y < 0 = -(x * (-y))
08:08:31 <Aruro> ok i agree its nice :) but second argument serves a variable
08:08:36 <Aruro> a parameter
08:08:49 <Aruro> which is more difficult in case of only one variable thats why you need let block
08:08:55 <mm_freak_> it doesn't matter on which value you recurse, but now observe the following:
08:09:51 <mm_freak_> (x *) = go  where go 0 = 0;  go y = x + go (y - 1)
08:10:17 <mm_freak_> this looks an awful lot like what you wrote, just much simpler =)
08:10:19 * hackagebot syntax-example 0.4.0.0 - Example application using syntax, a library for abstract syntax descriptions.  http://hackage.haskell.org/package/syntax-example-0.4.0.0 (pawel834)
08:10:21 * hackagebot syntax-example-json 0.2.0.0 - Example JSON parser/pretty-printer.  http://hackage.haskell.org/package/syntax-example-json-0.2.0.0 (pawel834)
08:10:31 <mm_freak_> (left out the negation part for the sake of simplicity)
08:10:46 <Aruro> its better than my version
08:10:54 <Aruro> it has no formulas and let blocks
08:11:00 <Aruro> but problem again is double arguments
08:11:15 <mm_freak_> why is that a problem?  you need the multiplication function anyway
08:11:22 <mm_freak_> what you wrote is basically just what i wrote =)
08:11:24 <Aruro> i already notices its easier to use recursion with many arguments checking against some of them as parameters
08:11:32 <Aruro> no its different
08:11:38 <Aruro> yours is more general function
08:11:58 <Aruro> mine uses internal variable to store reminder
08:12:07 <Denommus> Hi
08:12:14 <mm_freak_> that's not how you would write it anyway
08:12:26 <mm_freak_> hi Denommus
08:12:37 <Aruro> in last line you used cyring?
08:12:40 <Aruro> curying?
08:12:54 <mm_freak_> Aruro: i used currying in the first line
08:12:58 <mm_freak_> everything else is fully applied
08:13:11 <Aruro> here (x*) = go
08:13:14 <mm_freak_> yeah
08:13:23 <mm_freak_> x * y = go y
08:13:28 <mm_freak_> so (x *) = go
08:13:41 <Aruro> yes
08:13:55 <mm_freak_> that's the reason why i destruct the second argument =)
08:14:20 <mm_freak_> but this function is going to be horribly inefficient at run-time
08:14:37 <mm_freak_> (unless the compiler magically figures out how to rewrite it to be efficient, which is unlikely)
08:15:07 <Aruro> can you put you result in lpaste? :)
08:15:09 * hackagebot leksah 0.14.2.0 - Haskell IDE written in Haskell  http://hackage.haskell.org/package/leksah-0.14.2.0 (HamishMackenzie)
08:15:13 <Aruro> i wanna reflect on it :)
08:15:19 <Aruro> your*
08:15:43 <mm_freak_> i have no result so far…  i wrote it here in my IRC client =)
08:16:00 <Aruro> yeah i wanted to copy it out
08:16:07 <Aruro> thought you have it
08:16:40 <mm_freak_> mult :: Integer -> Integer -> Integer
08:16:52 <mm_freak_> mult x y | y < 0 = -(mult x (-y))
08:17:20 <mm_freak_> mult x y0 = go y0  where go 0 = 0;  go y = x + go (y - 1)
08:17:23 <mm_freak_> that should work
08:17:47 <Aruro> you skipped y>0 clause
08:17:56 <FireFly> That's the second line
08:17:57 <mm_freak_> it's not needed
08:18:08 <mm_freak_> at that point y can only be positive
08:18:15 <FireFly> er, the  mult x y0  case, that is
08:18:25 <mm_freak_> the first line makes sure it is never negative, and the first clause of 'go' makes sure it's not 0
08:18:49 <Aruro> okok looks nice :)
08:18:54 <Aruro> im gonna think about it now :)
08:19:21 <mm_freak_> the next step will be to make it efficient (as far as you could call this algorithm efficient)
08:20:02 <paolino> batbird, returning a number in the zip ?
08:21:13 <Aruro> ok it is working and is nice :)
08:21:26 <Aruro> only thing i dont like is two arguments :)
08:21:33 <paolino> 3 hours to get hakyll compiled
08:21:34 <mm_freak_> Aruro: run this program:  main = mapM_ (mult 2) [0..]
08:21:50 <Aruro> can we be crazy and go back to our topic of writing one argument recursion function for x*x ?
08:21:54 <mm_freak_> Aruro: it will print the nonnegative even integers, but will get slower and slower as it goes on
08:22:13 <Aruro> why mapM
08:22:17 <Aruro> not just map?
08:22:33 <mm_freak_> Aruro: to print each on its own line
08:22:43 <Aruro> k
08:22:47 <paolino> mh
08:22:58 <Aruro> you seem to have skills, can you write same what i wrote with just one argument?
08:23:01 <mm_freak_> Aruro: square x = go x  in go 0 = 0;  go y = x + (y - 1)
08:23:09 <mm_freak_> it's the same thing
08:23:09 <Aruro> aha
08:23:21 <mm_freak_> hence:  square x = mult x x
08:23:23 <mm_freak_> it makes sense that it's the same thing
08:23:28 <brrrrian> mm_freak_: thanks... I think I can see how to do it the basic way with types and functions e.g. handling the version differences in a function rather than trying to create some fancy abstraction mechanism.  This is probably the best approach given my current experience.. I was just wondering if there was an idiomatic / better way to do this.
08:23:35 <Aruro> wait
08:24:03 <Aruro> what is last definition square x?
08:24:17 <Aruro> there is no recursion there
08:24:34 <mm_freak_> Aruro: you can do square in a different way, if you really want to write a recursive version that isn't multiplication =)
08:24:42 <Aruro> yes i want
08:24:47 <Aruro> and only ONE argument
08:25:04 <Aruro> if it will not use internal storage i will be happy  :)
08:25:07 <mm_freak_> observe the following:  0^2 = 0
08:25:09 <batbird> paolino: zip returns a list
08:25:36 <mm_freak_> 1^2 = (0 + 1)^2 = 0^2 + 2*0*1 + 1^2
08:25:50 <mm_freak_> 2^2 = (1 + 1)^2 = 1^2 + 2*1*1 + 1^2
08:25:56 <mm_freak_> 3^2 = (2 + 1)^2 = 2^2 + 2*2*1 + 1^2
08:25:58 <mm_freak_> etc.
08:26:07 <paolino> batbird, I couldn't understand your statement
08:26:26 <mm_freak_> Aruro: you can compute squares using only doubling and addition, if you keep track of the square root as you go
08:26:56 <Aruro> yes that is true
08:26:56 <mm_freak_> > map fst $ iterate (\(x, r) -> (x + 2*r + 1, r + 1)) (0, 0)
08:26:58 <lambdabot>  [0,1,4,9,16,25,36,49,64,81,100,121,144,169,196,225,256,289,324,361,400,441,4...
08:27:05 <Aruro> you want to do like fibbonaci
08:27:12 <mm_freak_> exactly
08:27:18 <mm_freak_> i'll leave writing this as an exercise for you =)
08:27:20 <Aruro> yes good point
08:27:26 <Aruro> :D
08:27:50 <Aruro> wait a minute :)
08:28:00 <Aruro> will it be recursion up?
08:28:10 <mm_freak_> "up"?
08:28:30 <Aruro> like f n = n+ f (n-1)
08:28:42 <Aruro> recurses up based on lower cases
08:28:57 <mm_freak_> similar, but you need two arguments
08:29:03 <mm_freak_> well, you could do it with one by using laziness
08:29:09 <mm_freak_> but that's going to be even less efficient =)
08:29:12 <Aruro> i want only one yes :)
08:29:18 <Aruro> i want just idea
08:29:23 <Aruro> dont care about efficiency
08:29:25 <Aruro> at all
08:29:38 <mm_freak_> it will require a lot of thinking about data dependencies
08:29:45 <mm_freak_> i suggest doing the two-arguments version first
08:30:04 <dmbaturin> What is the latex name of the ++ symbol?
08:30:12 <Aruro> so you suggesting basically to compute square based on previous squares
08:30:30 <dreams> @free help
08:30:32 <lambdabot> Extra stuff at end of line in retrieved type "Not in scope: \226\128\152help\226\128\153\n"
08:30:39 <dreams> how do you use @free?
08:30:47 <FireFly> @free a -> a
08:30:48 <lambdabot> Extra stuff at end of line
08:30:50 <FireFly> :(
08:30:52 <FireFly> @help free
08:30:53 <lambdabot> free <ident>. Generate theorems for free
08:31:08 <HeladoDeBrownie> @free fmap
08:31:09 <lambdabot> Extra stuff at end of line in retrieved type "Functor f => (a -> b) -> f a -> f b"
08:31:12 <dreams> ...
08:31:13 <HeladoDeBrownie> o_0
08:31:18 <HeladoDeBrownie> I think it's broken
08:31:26 <HeladoDeBrownie> @free map
08:31:28 <lambdabot> g . h = k . f => $map g . map h = map k . $map f
08:31:29 <HeladoDeBrownie> Oh
08:31:35 <dmbaturin> @free "a -> b -> a"
08:31:36 <lambdabot> Pattern match failure in do expression at src/Lambdabot/Plugin/Haskell/Free/FreeTheorem.hs:54:21-35
08:31:49 <mm_freak_> Aruro: i just verified that you can do it with just one argument without relying on laziness
08:31:57 <mm_freak_> Aruro: just try it
08:32:01 <Aruro> mm your iterate version is not recursion
08:32:03 <Aruro> you made it?
08:32:20 <mm_freak_> dmbaturin: in latex (and in general) i prefer (<>), which is \diamond
08:32:23 <Aruro> using binom formula?
08:32:43 <Aruro> let me see
08:33:15 <mm_freak_> Aruro: it is recursion…  the recursion is in the 'iterate' and 'map' functions
08:33:28 <mm_freak_> Aruro: and yes, it's the binomial formula
08:33:42 <mm_freak_> (x + y)^2 = x^2 + 2*x*y + y^2
08:33:53 <mm_freak_> (x + 1)^2 = x^2 + 2*x + 1
08:34:01 <Aruro> yes
08:34:07 <Aruro> ok i will think now
08:39:59 <Aruro> ok to be completely in line with replacing * we need to say that 2*x = x + x
08:44:26 <orion> Hi. Does anyone know what could be going wrong here?: http://lpaste.net/7762715489834369024
08:44:33 <mm_freak_> Aruro: you know what…  define this:  data Nat = Zero | Succ Nat
08:44:59 <mm_freak_> Aruro: then you can really start from scratch (and also get rid of those annoying negative numbers)
08:45:07 <orion> yesod init is crashing. :(
08:45:08 <mm_freak_> you first need to define addition
08:45:54 <Aruro> actually binom formula translate directly into recursion
08:47:02 <Aruro> look at this beauty http://lpaste.net/115380
08:47:11 <Aruro> maan took us so long to write this
08:47:14 <mm_freak_> Aruro: i can see that you like doing this sort of thing…  i highly recommend defining Nat as above…  then you will get absolutely nothing for free, and you will start building everything from the ground up =)
08:47:25 <Aruro> :)
08:48:04 <Aruro> i regard binom realisation as a success of our one parameter recursive definition
08:48:40 <Aruro> really nice and uses only + as you wanted initially
08:48:53 <mm_freak_> Aruro: but you still didn't define (+) yourself =)
08:49:02 <Aruro> yes that is next step :D
08:49:15 <mm_freak_> Aruro: but really don't do it for Integer
08:49:17 <mm_freak_> do it for Nat
08:49:23 <mm_freak_> do you understand the type?
08:49:38 <Aruro> but isnt it looking like a list?
08:50:00 <mm_freak_> the natural numbers are isomorphic to the list of unit values
08:50:02 <Aruro> Null | List a ?
08:50:13 <Aruro> yes
08:50:15 <mm_freak_> 0 ~ [];  1 ~ [()];  2 ~ [(), ()];  etc.
08:50:43 <Aruro> ture actually i lost your line of thought why you want a new type?
08:50:48 <Aruro> true*
08:50:59 <mm_freak_> Nat is the type-theoretic version of the peano axioms…  it gives you exactly the natural numbers (disregarding a subtlety that isn't interesting right now)
08:51:13 <Aruro> initially i just wondered about recursive definition of simple functions
08:52:00 <Aruro> actually i kinda got enlighment
08:52:06 <Aruro> after you mentioned binom
08:52:10 <mm_freak_> you can also run amok and define this:  data EfficientNat = One EfficientNat | Zero EfficientNat | Zeroes
08:52:19 <Aruro> because any binom like looking formula is already a recursion
08:52:26 <Aruro> interesting
08:52:36 <mm_freak_> this is 5:  One (Zero (One Zeroes))
08:53:00 <Aruro> recursive? :)
08:53:24 <mm_freak_> it's just a digital version of Nat =)
08:53:30 <FireFly> ...000101
08:53:39 <mm_freak_> it's isomorphic to [Bool] (while Nat is isomorphic to [()])
08:54:05 <Aruro> so what we learned here is that any formula which defines a successor is basically a recursion
08:54:22 <mm_freak_> the digital Nat doesn't define successors
08:54:27 <mm_freak_> it defines sequences of bits
08:54:28 <Aruro> im getting lost with piano axioms here :)
08:54:36 <Aruro> aaa
08:54:38 <Aruro> interesting
08:55:15 <ziggystar> Hi. I have a problem with cabal and tests. I'm using Hunit and have written a file that runs a TestList with one failing test. When I do `cabal test` it says 1 of 1 suites (1 of 1 cases) passed. But when I check the log file it correctly reports the failed test.
08:55:24 <Aruro> but EfficientNat present on both sides am i correct that its again a list recursive type?
08:55:53 <mm_freak_> ziggystar: is your test suite exiting with a status of 1 when tests fail?
08:56:05 <mm_freak_> (or any non-zero status)
08:56:29 <ziggystar> It exits with 0, just checked.
08:56:40 <ziggystar> I'm using runTTest (or similar).
08:56:43 <mm_freak_> Aruro: a natural number can be thought of as an infinite sequence of bits that becomes all zeroes at some point
08:56:54 <mm_freak_> Aruro: five is 101
08:56:59 <mm_freak_> which is …000000000101
08:57:31 <mm_freak_> now just flip the digits around, so that the least significant digit is on the left side
08:57:36 <mm_freak_> 101000000000000000…
08:57:47 <Aruro> yes that is binary system , clear :)
08:57:50 <ziggystar> Hmmm, so cabal is only using the exit code with exitcode-stdio-1.0? Seems plausible, but how does it know how many tests were executed?
08:57:58 <mm_freak_> then define a more readable type:  data BinaryNat = O BinaryNat | I BinaryNat | Zeroes
08:58:09 <mm_freak_> I (O (I Zeroes))
08:58:34 <mm_freak_> this is 1, followed by 0, followed by 1, followed by an infinite sequence of zeroes
08:58:52 <Aruro> you see you came back to list :)
08:59:01 <mm_freak_> ziggystar: you probably shouldn't use HUnit directly these days…  i suggest looking into tasty
08:59:02 <Aruro> if you remember two hours ago you said no lists :)
08:59:14 <ziggystar> Ok, thanks for the tip.
08:59:29 <EvanR> Aruro: its not isomorphic list of bits
08:59:41 <Aruro> well it is list
08:59:43 <Aruro> anyway
08:59:51 <EvanR> well its a data typ
08:59:53 <mm_freak_> Aruro: the problem is that there is no difference between "natural number" and "list of units" or "list of binary digits"
09:00:03 <Aruro> yes
09:00:24 <Aruro> ok you wanted to expand our definition of power function by going amok with new types
09:00:38 <Aruro> how does it help in the end? we will be forces to work with lists
09:00:41 <Aruro> actually
09:00:44 <mm_freak_> Aruro: don't view every recursive type as a list type and look at it as an enlightenment that natural numbers and lists are very closely related =)
09:01:00 <Aruro> that enlightment i had yes :) :D
09:01:17 <Aruro> kinda follows from reality
09:01:17 <EvanR> nevermind im wrong
09:01:42 <EvanR> i was thinking of infinite sequence of bits that does not have a limit of zero, which you can have with mm_freak_'s version
09:02:14 <Aruro> nevertheless can we say that any polynom can be written using recursion?
09:02:21 <Aruro> ala binom ?
09:03:09 <mm_freak_> Aruro: it's all just addition in the end
09:03:18 <Aruro> true
09:03:23 <mm_freak_> Aruro: try to write addition for Nat, then you will see how all other operations will follow from it
09:04:03 <Aruro> do you remember the start of todays talk?
09:04:18 <Aruro> it was about composition inside recursion
09:04:26 <mm_freak_> i came later
09:04:31 <EvanR> addition is repeated succ
09:04:35 <Aruro> so its clear you can compose recursive functions to make polinom
09:04:52 <EvanR> (for unary numbers)
09:04:57 <Aruro> but can you write polinomial function in ONE argument single function
09:05:05 <Aruro> if so
09:05:09 <mm_freak_> don't worry, the obsession about recursion goes away at some point and you will find yourself trying to avoid explicit recursion as much as you can =)
09:05:18 <Aruro> haah :D
09:05:30 <mm_freak_> you will fall in love with Foldable and Traversable
09:05:55 <mm_freak_> then you will fall in love with the recursion-schemes library just to figure out that you would never actually use it =)
09:06:02 <Aruro> actually in solving Project Euler problem 17
09:06:06 <mm_freak_> finally you will discover Free
09:06:12 <mm_freak_> and then you will have The Grand Tool
09:06:24 <mm_freak_> at least you will think that
09:06:28 <mm_freak_> until you discover FreeT
09:06:36 <mm_freak_> then you will have The Grander Tool
09:07:09 <Aruro> i wrote 2 versions one with recursion and other without, recursion was not shorter but code was a bit more readable
09:07:22 <Aruro> and what is this Grander Tool?
09:07:27 <mm_freak_> FreeT =)
09:07:53 <mm_freak_> i'm just joking, nevermind…  don't look up what FreeT is now =)
09:07:59 <Aruro> lol :D
09:08:04 <Aruro> nono i dont
09:08:10 <indiagreen> the most important question is, tho
09:08:20 <indiagreen> can you write “x*x” with FreeT?
09:08:25 <Aruro> anyway what is argument against explicit recursion?
09:08:33 <Aruro> haah yes! indiegreen is right :)
09:09:14 <EvanR> FreeT - generalized abstract nonsense ;)
09:09:22 <mm_freak> indiagreen: you can construct a Free-based writer monad and 'tell' the square ;)
09:09:47 <mm_freak> one:  tell [()]
09:09:56 <mm_freak> two:  tell [()] >> tell [()]
09:10:37 <indiagreen> Aruro: explicit recursion is pretty imperative, “if this do this, if that do that, if something else do something else”, and often it falls into one of already existing patterns
09:10:49 <indiagreen> e.g. “do one thing if the list is empty, do the other if it isn't”
09:11:05 <carter> i like explcit recursion when i've not discovered the right abstraction
09:11:08 <indiagreen> and when there's a pattern, it's better not to reimplement it each time
09:11:11 <mm_freak> it's not imperative, it's just noisy and very often hides important algebraic properties
09:11:31 <mm_freak> sometimes it's appropriate, but in most cases combinator style is what you want
09:11:42 <carter> unless you've not discovered the right combinators yet : )
09:14:01 <mm_freak> that's the evolution of a haskell programmer:  1. you write a type and write all functions ad hoc, 2. you write the type and discover common patterns, 3. you write the type and then the combinators and only then the actual functions 4. you start with the combinators and define your types in terms of them =)
09:15:21 <indiagreen> mm_freak: can you elaborate on #4?
09:16:49 <mm_freak> indiagreen: when i define a data structure i often start by thinking about the supported options for construction and destruction
09:17:42 <mm_freak> indiagreen: also every data structure has a form with a name that i always forget…  not "church encoding", but the other one
09:17:56 <mm_freak> type List a = forall r. (a -> r -> r) -> r -> r
09:19:11 <Taneb> CPS encoding?
09:19:37 <mm_freak> scott encoding
09:20:29 <benmachine> no I think the one you said is church
09:20:43 <benmachine> scott is forall r. (a -> List a -> r) -> r -> r
09:21:11 <mm_freak> hmm, possibly
09:21:35 <mm_freak> i read a note that "church encoding" is really the wrong term, because of types
09:21:47 <mm_freak> not sure…  i just use it =)
09:21:53 <carter> having the operations you wanna do, push back on what the types can be
09:21:56 <benmachine> oh, shrug, I don't know about that
09:21:57 <carter> is a nice engineering tool
09:22:15 <carter> i've had that actually result in some really nice design discovery that blew my mind
09:23:25 <mm_freak> i usually use this encoding only to force-right-associate =)
09:23:49 <carter> mm_freak: well, thats because you're doing a stream composition lib right?
09:23:56 <mm_freak> newtype Collection a = Collection { collect :: forall r. (Monoid r) => (a -> r) -> r -> r }
09:24:08 <mm_freak> carter: i'm doing this a lot, not just in fuse
09:24:13 <carter> oh?
09:24:19 <carter> whats an example thats a  bit richer?
09:24:34 <carter> i've some stuff where i'm vey very very leary of doing that sort of free construction shaped api
09:24:48 <mm_freak> carter: in most cases i just use FT (from 'free')
09:24:54 <carter> @hackage free
09:24:56 <lambdabot> http://hackage.haskell.org/package/free
09:25:08 <carter> http://hackage.haskell.org/package/free-4.9/docs/Control-Monad-Trans-Free.html ?
09:25:14 <carter> freeT?
09:25:18 <mm_freak> FT
09:25:23 <carter> which moduel
09:25:25 <mm_freak> Control.Monad.Trans.Free.Church
09:25:43 <carter> http://hackage.haskell.org/package/free-4.9/docs/Control-Monad-Trans-Free-Church.html
09:25:44 <carter> ahh
09:26:03 <mm_freak> construct your action using FT, then convert to FreeT to interpret it
09:26:20 <carter> ahh
09:26:29 <carter> g2g, but whats a good example of that?
09:27:04 <mm_freak> carter: http://hub.darcs.net/ertes-ag/wires/browse/Control/Wire/Model.hs
09:42:16 <Gurkenglas> Can I use the diagrams package on fpcomplete?
09:42:39 <mm_freak> bye, people
09:50:44 <Gurkenglas> What IDE do you use for Haskell?
09:51:08 <bitonic> Gurkenglas: emacs + haskell-mode
09:51:26 <quantum-mechanic> are there any vim plugins ?
09:51:44 <bitonic> wouldn't know.  I think ghc-mod works with vim.
09:51:49 <saep> quantum-mechanic: Of course there are.
09:51:50 <quantum-mechanic> that does indentation
09:52:09 <quantum-mechanic> currently im using youcompleteme for tab completion
09:52:47 <quantum-mechanic> but it will be nice to use something more specific for haskell libs
09:53:46 <sivteck> quantum-mechanic, this works™ https://github.com/raichoo/haskell-vim
09:54:34 <saep> quantum-mechanic: Take a look at ghcmod-vim neco-ghc syntastic vim2hs(heavy)/hasksyn(lightweight)/haskellmode-vim(don't know)
09:57:10 <Gurkenglas> Am I recommended to use emacs for haskell-mode if I'm on Windows and have never used emacs?
09:57:17 <Gurkenglas> --mode
09:57:49 <shiona_> Gurkenglas: what kind of alternatives are you considering?
09:58:21 <hiptobecubic> quantum-mechanic, ycm works well with neco-ghc
09:59:05 <Gurkenglas> fpcomplete.com as I've done up to now, because it's useful when I want to continue working from the university workstations
09:59:35 <sivteck> Gurkenglas, consider learning vim or emacs, it will be worth it.
10:00:00 <hiptobecubic> (assuming you are going to be doing a lot of text editing)
10:00:23 <sivteck> yep :)
10:02:21 <oliffia> anyone know offhand what ghci uses for its "shell" library?
10:02:41 <sivteck> Gurkenglas, there's also a shiny plugin for intellij http://www.jetbrains.com/idea/download/ <http://carymrobbins.github.io/intellij-haskforce/>
10:10:13 * hackagebot music-dynamics-literal 1.8 - Overloaded dynamics literals.  http://hackage.haskell.org/package/music-dynamics-literal-1.8 (HansHoglund)
10:10:15 * hackagebot music-pitch-literal 1.8 - Overloaded pitch literals.  http://hackage.haskell.org/package/music-pitch-literal-1.8 (HansHoglund)
10:10:17 * hackagebot abcnotation 1.8 - Haskell representation and parser for ABC notation.  http://hackage.haskell.org/package/abcnotation-1.8 (HansHoglund)
10:10:19 * hackagebot musicxml2 1.8 - A representation of the MusicXML format.  http://hackage.haskell.org/package/musicxml2-1.8 (HansHoglund)
10:10:21 * hackagebot lilypond 1.8 - Bindings to Lilypond  http://hackage.haskell.org/package/lilypond-1.8 (HansHoglund)
10:15:24 * hackagebot music-score 1.8 - Musical score and part representation.  http://hackage.haskell.org/package/music-score-1.8 (HansHoglund)
10:15:26 * hackagebot music-pitch 1.8 - Musical pitch representation.  http://hackage.haskell.org/package/music-pitch-1.8 (HansHoglund)
10:15:28 * hackagebot music-dynamics 1.8 - Abstract representation of musical dynamics.  http://hackage.haskell.org/package/music-dynamics-1.8 (HansHoglund)
10:15:31 * hackagebot music-articulation 1.8 - Abstract representation of musical articulation.  http://hackage.haskell.org/package/music-articulation-1.8 (HansHoglund)
10:15:32 * hackagebot music-parts 1.8 - Musical instruments, parts and playing techniques.  http://hackage.haskell.org/package/music-parts-1.8 (HansHoglund)
10:17:53 <uman> Hi, I'm learning Haskell and I wrote the following program: main = do {contents <- getContents; putStrLn $ show $ length $ filter (=='\n') contents;}
10:18:16 <uman> This runs about 5-6 times slower than "wc -l" . Any ideas how one would write an efficient word count program in haskell?
10:19:03 <marchelzo_> uman: Data.ByteString
10:19:57 <marchelzo_> Or Data.Text depending on the input
10:20:10 <uman> marchelzo_: these are a lot quicker than String ?
10:20:19 <marchelzo_> Yes
10:20:40 * hackagebot music-preludes 1.8 - Some useful preludes for the Music Suite.  http://hackage.haskell.org/package/music-preludes-1.8 (HansHoglund)
10:20:40 * hackagebot music-graphics 1.8 - Diagrams-based visualization of musical data structures.  http://hackage.haskell.org/package/music-graphics-1.8 (HansHoglund)
10:20:40 * hackagebot music-sibelius 1.8 - Interaction with Sibelius.  http://hackage.haskell.org/package/music-sibelius-1.8 (HansHoglund)
10:20:41 * hackagebot music-suite 1.8 - A set of libraries for composition, analysis and manipulation of music.  http://hackage.haskell.org/package/music-suite-1.8 (HansHoglund)
10:24:33 <Gurkenglas> "If you have
10:24:33 <Gurkenglas>   never used Emacs before, you should follow the tutorial at this
10:24:33 <Gurkenglas>   point (select Emacs Tutorial from the Help menu), since Emacs is
10:24:33 <Gurkenglas>   quite different from ordinary Windows applications in many respects." <- Uh oh. I can see it coming, some GUI that wasn't changed since the 1980s because the userbase is used to it
10:24:40 <Gurkenglas> Soz for those \ns.
10:25:31 <hiptobecubic> If you want a fancy gui that feels "modern" in exchange for not leveraging any of the benefits of editors that have been continuously refined for 20 years, then there are lots of choices other than vim and emacs.
10:26:38 <hiptobecubic> sublime text has a big following these days, for example.
10:28:33 <Peaker> emacs isn't being "refined". It's piling useful (and somewhat brittle) hacks one upon another
10:28:45 <systemfault> I was surprised by how good the combination of IntelliJ IDEA + Haskforce plugin is.
10:29:09 <systemfault> If you care:  http://carymrobbins.github.io/intellij-haskforce/
10:30:19 <oliffia> i used emacs for years before switching to sublime, no regrets
10:30:32 <uman> marchelzo_: thanks, rewrote my program to use ByteString and now it's twice as fast as "wc -l" :)
10:31:04 <Peaker> lots of stuff exists, tons of it doesn't quite work out of the box and that's sad cause I don't know of anything better :(
10:31:08 <chrisdone> Peaker: and sadly no one has improved upon it
10:31:59 <Peaker> Sublime had a great innovation -- multiple cursors, but for some reason it was never taken to its logical conclusion (being applied project-wide instead of file-wide). Also it doesn't support stuff you'd do in emacs macros like searching
10:32:16 <chrisdone> emacs has set the benchmark for extensibility
10:32:26 <Peaker> Sublime isn't good enough for the avid emacs user, I think :(  though it is nice in many ways
10:32:30 <chrisdone> every new editor since doesn't learn from emacs and starts from ed plus bestles and whistles
10:32:44 <chrisdone> er, bells. (bestles = bells + whistles)
10:32:54 <fuzzyhorns> what is the difference between contracts and types?
10:33:19 <Peaker> fuzzyhorns, I think contracts are like quick-check properties you specify about your API.. More like laws than like types
10:33:37 <fuzzyhorns> Peaker: that makes sense
10:33:50 <fuzzyhorns> Peaker: up to the laws vs types bit, i dont quite follow that ;)
10:33:51 <chrisdone> contracts are polished version of assert()
10:34:13 <chrisdone> a runtime check in mzscheme, although spj is trying to bring it to compile time, hence liquid haskell
10:34:18 <fuzzyhorns> chrisdone: which is different from a type how, in you estimation?
10:34:42 <Peaker> contracts are one abstraction level above asserts, because they inject the asserts to all relevant code automatically
10:35:19 <Peaker> and they are better documentation than asserts, since they appear as abstract laws rather than a bunch of concrete-case asserts
10:35:27 <fuzzyhorns> also what is difference between static checking and dynamic checking? http://stackoverflow.com/questions/5965144/comparing-design-by-contract-to-type-systems
10:35:30 <chrisdone> a type typically tells you the set of values valid for a domain, a contract tends to describe how values should interact
10:35:32 <fuzzyhorns> Peaker: ahhh ok
10:35:47 <fuzzyhorns> chrisdone: hmm
10:35:55 <fuzzyhorns> chrisdone: the contracts i have seen seem to do the latter
10:36:04 <Peaker> fuzzyhorns, "static" is stuff that happens on the source code itself, as analysis before running it.  dynamic is stuff that happens at runtime in the customer site, at 2AM
10:36:05 <fuzzyhorns> i was looking at this chrisdone: http://egonschiele.github.io/contracts.ruby/
10:36:40 <fuzzyhorns> Peaker: haha ok
10:36:46 <chrisdone> oh, in ruby, then yeah, it's more clear cut, just a polished assert()
10:36:50 <fuzzyhorns> Peaker: i was asking to make sure i understood the table here: http://stackoverflow.com/questions/5965144/comparing-design-by-contract-to-type-systems
10:36:57 <Peaker> fuzzyhorns, so static checking is verifying it for all possible things that could happen.  dynamic checking is injecting code to crash at 2AM if the promise is violated
10:37:15 <Peaker> naturally static is harder and sometimes more restrictive
10:37:52 <fuzzyhorns> chrisdone: just reading through that, i am unsure how it applies in "a type typically tells you the set of values valid for a domain, a contract tends to describe how values should interact"
10:38:00 <fuzzyhorns> reading through that ruby code, i mean
10:38:22 <chrisdone> i was talking in a static sense. in ruby it's just some assert() calls
10:38:31 <fuzzyhorns> ahh ok
10:38:46 <chrisdone> some runtime code: if blah blah condition now met then throw error
10:39:13 <Peaker> fuzzyhorns, usually a type is a restriction on the set of values a single subexpression or variable can hold.  A contract usually specifies a law about relationships between different values of different expressions or variables
10:39:17 <chrisdone> in ATS you can have a function specify constraints like {a: int | a >= 0}
10:39:30 <chrisdone> so it will accept any integer which is greater than zero
10:39:39 <Peaker> fuzzyhorns, in more advanced type systems, this distinction is blurred and types can restrict arbitrary things like contracts can
10:39:57 <fuzzyhorns> Peaker: hmm, confusing, what has a ssystem like that?
10:40:03 <chrisdone> agda, idris, ats
10:40:12 <fuzzyhorns> gotcha, havent heard of ats
10:40:17 <fuzzyhorns> heard of agda and idris
10:40:27 <fuzzyhorns> seen a little idris but not much agda yet
10:40:55 <fuzzyhorns> so a dynamic language, can it really even do type checking, or just contracts?
10:41:11 <fuzzyhorns> i mean the table shows it can i guess lol
10:41:16 <Peaker> fuzzyhorns, a contract can say something like:  self.length == length(self.items)   whereas the type of "self.length" and "self.items" don't tell you this.  In Agda, you could have a value of type: l == length items  which proves, statically, this exact contract
10:41:17 <chrisdone> it's a little blurry when it's static, as you can move it all in the type system rather than considering it an orthogonal check
10:42:56 <chrisdone> i like that table
10:43:14 <chrisdone> i tend to think of contracts as the dynamic check thing and not a compile-time thing
10:43:52 <oliffia> is there a command to ask cabal if the current package needs to be rebuilt?
10:45:39 <orion> Hi, does anyone know why `yesod init' crashes on FreeBSD?: http://lpaste.net/7762715489834369024
10:52:34 <fuzzyhorns> yeah given everywhere I look design by contract talks about pre and post conditions, your explanations all make sense
10:53:04 <fuzzyhorns> i still find it hard to see where that shifts from pre and post conditions to types though :c
10:54:48 <fuzzyhorns> http://cstheory.stackexchange.com/questions/5228/relationship-between-contracts-and-dependent-typing
10:54:51 <fuzzyhorns> also interesting
10:55:09 <chrisdone> well for example:
10:55:11 <chrisdone> fun {i : int | i >= 0} succ (i : int i) : int (i + 1) =
10:55:11 <chrisdone>   i + 1
10:55:19 <chrisdone> this is an ATS function that accepts and int and returns an int
10:55:27 <sinelaw> how do I get my haskell-mode to hint about types of methods from all packages in the sandbox (and not just base?)
10:55:29 <chrisdone> but the pre-condition is: i must be >=0
10:55:43 <chrisdone> and the post-condition is: the result of succ i must be i + 1
10:55:55 <chrisdone> that's a static, compile-time condition. no runtime checks
10:56:33 <chrisdone> sinelaw: 'hinting'?
10:56:53 <sinelaw> chrisdone, when it tells you in the bottom what the type of the current symbol is
10:56:55 <fuzzyhorns> ok, so in that table, complex properties | theorem proving      | contract checking
10:57:17 <fuzzyhorns> but what is the difference between simple properties  | static type checking | dynamic type checking ?
10:57:27 <fuzzyhorns> literally just compile vs runtime?
10:57:29 <chrisdone> sinelaw: oh, that just uses ghci's :t so it will work for whatever simple is in scope when you have loaded your module in (with -fbyte-code)
10:57:36 <chrisdone> s/simple/symbol
10:58:43 <chrisdone> fuzzyhorns: sure. some encourage thinking of a dynamic type system as a static type system with only one type
10:59:13 <fuzzyhorns> chrisdone: ive heard something like that for untyped, but not dynamic :)
10:59:19 <fuzzyhorns> but i guess you mean those are the same?
10:59:35 <chrisdone> what would be an example of untyped?
10:59:47 <fuzzyhorns> an untyped lambda calculus i mean
10:59:54 <fuzzyhorns> ive heard it described as unityped :)
11:00:24 <chrisdone> right, lambda calculus has only abstractions and constants
11:01:26 <chrisdone> just simple substitution
11:02:51 <chrisdone> well it's easy to define a dynamic type in a static language
11:03:16 <chrisdone> data T = Int Int | String String | Fun (T -> T)
11:03:28 <monochrom> people can really make a big fuss and write multiple blogs on "a point is not a circle" vs "a point is a circle of radius 0", "untyped" vs "one type"
11:04:53 <xelxebar> you guys script with haskell much? runhaskell in your shabang and all that.
11:04:59 <chrisdone> yup
11:05:48 <monochrom> I prefer to compile it. faster start up.
11:05:58 <sinelaw> chrisdone, but but but
11:06:17 <sinelaw> chrisdone, how do I make it "just work" (TM) with in the context of whatever cabal I'm working on?
11:06:19 <chrisdone> i have a ~/Scripts dir with all my haskell scripts
11:06:33 <monochrom> if I compile my scripts, do you still consider it scripting?
11:06:37 <chrisdone> sinelaw: i'm saying it should Just Work™, but you have to load your module in
11:07:00 <chrisdone> monochrom: how many hairs makes a bald head?
11:07:46 <monochrom> now you will hear me say 'people can make a big fuss and write multiple blogs on "it counts as scripting" vs "it doesn't count as scripting"'
11:07:57 <chrisdone> sinelaw: if you're not getting the 'hint' after hitting SPC after an identifier, then that identifier hasn't been imported by your currently loaded module, or you're using -fobject-code instead of -fbyte-code
11:08:34 <xelxebar> monochrom: fair enough. you could chock the compile/runhaskell choice up to preference.
11:08:45 <xelxebar> I'm thinking more for systems maintenance etc
11:09:06 <chrisdone> sinelaw: as the feature literally sends :t <foo> to GHCi and prints the result
11:09:13 <EvanR> so scripting means not compiling, which is a funny distinction in the first place
11:09:15 <sinelaw> hmm
11:09:33 <chrisdone> i consider a script something that i don't plan on maintaining
11:09:54 <chrisdone> as soon as something is worth maintaining i make a cabal file and promote it to a proper program/library
11:10:01 <monochrom> I run some irc bots in efnet. they generate daily log files, i.e., one log file for one day. the log directory becomes cluttered very quickly. one year means 365 files. unwieldly.
11:10:21 <chrisdone> the fact that sysadmins write 'scripts' to achieve critical tasks is their own problem =)
11:10:38 <xelxebar> Thinking about trying to hack together a new init in haskell just for shits and giggles.
11:10:43 <EvanR> many scripts are proper programs
11:10:53 <monochrom> so I wrote a program in Haskell to merge the log files. one file for one month for the current year. one file for one year for past years. this program is a cron job run daily.
11:11:35 <monochrom> I think this counts as system maintenance, though the system is a tiny one: daily log files.
11:11:35 <EvanR> script is a funny word for program
11:11:36 <johnw> monochrom: can I have a copy of that program?  I need it too
11:11:41 <xelxebar> That's nice!
11:11:41 <chrisdone> here's a script i wrote to show the github position of a username: https://gist.github.com/chrisdone/d541c65b049eb5220811
11:11:41 <EvanR> say it enough times and it makes no sense
11:12:46 <chrisdone> chris@retina:~$ runhaskell ~/Scripts/GithubPosition.hs chrisdone
11:12:47 <chrisdone> #129
11:12:48 <chrisdone> =3
11:13:10 <Johannes13> hey, I decided to write a small IRC bot in haskell. I know the IRC Protocol well enough, and I already wrote IRC bots in other languages.
11:13:11 <xelxebar> EvanR: semantic satiation?
11:13:17 <johnw> chrisdone: that paulmillr list was last updated in Aug
11:13:36 <EvanR> xelxebar: i think for all scripts you could replace the word script with program and scripting with programming
11:13:47 <Johannes13> So I doing something famillar in a new language so I learn haskell sounds like a good idea.
11:13:48 <EvanR> and no one would notice
11:14:35 <Johannes13> But for IRC I need global state. I need to store the users in a channel, and access that later.
11:14:36 <chrisdone> johnw: my script's even older!
11:15:13 <hpc> Johannes13: you can simulate global state with local state
11:15:23 <Johannes13> So I'm not exactly sure how I should model my bot.
11:15:36 <chrisdone> keylogger script: https://gist.github.com/chrisdone/c51f7699ddb6642e7ce3
11:15:48 <hpc> for instance, in C, you might declare a struct in main and just pass it everywhere
11:15:56 <chrisdone> hackage docs script: https://gist.github.com/chrisdone/cc254ac371ba74ffc7db
11:15:56 <chrisdone> etc
11:16:30 <Johannes13> sure. But in the end, if I want to add functionality, I want to install some "hooks", functions that get called on certain conditions.
11:16:32 <EvanR> Johannes13: theres no a good reason for global variables in this case
11:17:13 <monochrom> johnw: http://www.vex.net/~trebla/tmp/mergelogs/
11:17:18 <EvanR> Johannes13: hooks are functions, so you can add them to a collection during runtime
11:17:24 <EvanR> functions are first class values
11:17:26 <johnw> monochrom: thanks!
11:17:41 <johnw> i've been meaning to write that script for ages
11:17:50 <Johannes13> EvanR, with global state I mean something like a structure that can be accessed/changed by my hooks.
11:17:54 <johnw> ZNC also gives no option for log naming, and uses daily
11:18:09 <johnw> I want to aggregate not only dailies into yearlies, but xz as I append too
11:18:09 <EvanR> Johannes13: yeah, that doesnt sound global
11:18:10 <Johannes13> I know, I could probably use StateT and IO
11:19:22 <EvanR> or ReaderT and IO
11:19:34 <hpc> ReaderT (IORef YourState) IO
11:19:57 <hpc> :t gets
11:19:58 <lambdabot> MonadState s m => (s -> a) -> m a
11:20:02 <hpc> :t modify
11:20:04 <lambdabot> MonadState s m => (s -> s) -> m ()
11:20:22 <EvanR> or ReaderT BunchOfRefsAndOrVars IO
11:20:27 <hpc> if you use gets and modify, it'll read very closely to a C-like
11:20:29 <Johannes13> ok, first problem: YourState probably need to store some extra stuff.
11:21:08 <chrisdone> i wrote this script to dumb a status for all my git projects: https://gist.github.com/chrisdone/5c0f797026794d7033bc
11:21:37 <EvanR> making the reader environment a record of various things lets you decide what is read only, read-write, and write-only
11:22:01 <Johannes13> ok, basic flow: input -> stream -> filter -> action
11:22:03 <chrisdone> output looks like: http://lpaste.net/949372194016722944
11:22:27 <Johannes13> ofc, I can duplicate the stream to filter for other things
11:22:54 <EvanR> Johannes13: your bot will react to a stream of messages right, rather than stream of bytes
11:23:05 <EvanR> ignoring some messages, reacting to others
11:23:33 <Johannes13> and I can add transformer (e.g. PRIVMSG gets translated to a channel message or private message, which in turn are maybe translated to a CTCP)
11:24:12 <hseg> Anyone have an elegant pointfreeification of \(z,y) (a,b) -> (f z a, g y b) ?
11:24:27 <johnw> @pl  \(z,y) (a,b) -> (f z a, g y b)
11:24:28 <lambdabot> uncurry (flip flip snd . (ap .) . flip flip fst . ((.) .) . (. g) . flip . (((.) . (,)) .) . f)
11:25:24 <hseg> *elegant*. Not .-soup
11:25:34 <johnw> probably not
11:25:47 <johnw> any reason it needs to be point-free?  you're definition makes the most sense
11:25:50 <chrisdone> hseg: i'm not sure i'd even like a point-free version of that
11:26:17 <hseg> It looks like it should be f *** g . transpose, for some value of transpose.
11:26:35 <hseg> Point-free is just b/c I don't like points personally.
11:26:43 <hpc> @pl \(f, g) (a, b) -> (f a, g b)
11:26:44 <lambdabot> uncurry (flip flip snd . (ap .) . flip flip fst . ((.) .) . flip . (((.) . (,)) .))
11:26:48 <hpc> eugh
11:26:59 <hseg> Right. Maybe lens has something?
11:27:06 <hpc> let that be (^^^)
11:27:21 <hpc> then do (f, g) ^^^ (z, y) ^^^ (a, b)
11:27:29 <hpc> lens probably has it too
11:29:30 <joseph07>  I have an application with a library portion for storage essentially (record :: Entry -> IO () and queryRange :: LocalTime -> LocalTime -> IO Journal). I
11:29:33 <joseph07>                   want to change the way it's implemented so that it uses one file handle for all time. Is there a way to do that without the module leaking its state into
11:29:36 <joseph07>                   all the modules that use those functions?
11:29:43 <joseph07> sorry that was a poorly planned paste
11:30:28 <mszep> quick question: if a module doesn't export a function I need, is there any way to force import it, short of copying and editing the source code?
11:30:49 <hseg> OK, so the question is how to transpose a pair of pairs.
11:30:55 <chrisdone> hseg: i think more like uncurry f *** uncurry g . transpose where bitranpose :: (z,y) -> (a,b) -> ((z,a),(y,b))
11:31:17 <hseg> Yeah.
11:31:22 <chrisdone> or transpose :: ((z,y),(a,b)) -> ((z,a),(y,b))
11:32:57 <hseg> > ((fst.fst&&&fst.snd)&&&(snd.fst&&&snd.snd)) ((1,2),(3,4))
11:33:06 <lambdabot>  ((1,3),(2,4))
11:33:12 <ion> cdaddaaddar
11:33:16 <systemfault> That's scary.
11:33:18 <chrisdone> lol yeah. pretty icky
11:33:25 <hseg> Hm. That works... but is icky.
11:34:06 <ion> Why not f ((a,b),(c,d)) = ((a,c),(b,d))?
11:34:50 <ReinH> ion: too elegant, I guess.
11:35:08 <chrisdone> hseg: you must like Factor ;)
11:35:22 <hseg> ion: b/c that's too much of a special case. Again, I'll live with that if I have to, I just hoped someone had written a traversal of tuples or sth that allows for more compact expressions of that.
11:35:35 <chrisdone> there's _1, _2, etc
11:35:58 <chrisdone> like…
11:36:05 <chrisdone> :t _1
11:36:08 <lambdabot> (Field1 s t a b, Functor f) => (a -> f b) -> s -> f t
11:36:09 <hseg> chrisdone: Forth is interesting at times, but a pain to work with
11:36:17 * chrisdone chuckles
11:36:26 <chrisdone> i wrote that :t as if it would be useful
11:36:38 <hseg> Never useful with lens.
11:36:38 <chrisdone> let's try this…
11:36:48 <chrisdone> :t (,) <$> _1 <*> _2
11:36:52 <lambdabot> (Field1 s t a b, Field2 s1 t1 a b, Functor f) => (a -> f b) -> (s -> f t, s1 -> f t1)
11:36:58 <FireFly> :t _1 `asAppliedTo` (1,2)
11:37:00 <lambdabot>     Couldn't match expected type ‘a -> f b’ with actual type ‘(t0, t1)’
11:37:00 <lambdabot>     In the second argument of ‘asAppliedTo’, namely ‘(1, 2)’
11:37:00 <lambdabot>     In the expression: _1 `asAppliedTo` (1, 2)
11:37:28 <FireFly> Right
11:37:28 <chrisdone> :t over ((,) <$> _1 <*> _2)
11:37:33 <lambdabot>     Couldn't match type ‘(s0 -> Identity t0, s1 -> Identity t1)’
11:37:33 <lambdabot>                   with ‘s -> Identity t’
11:37:33 <lambdabot>     Expected type: Setting (->) s t a b
11:37:38 <ReinH> :t runGetter $ (,) <$> Getter _1 <*> Getter _2
11:37:40 <lambdabot> (Contravariant f, Field1 s s a1 a1, Field2 s s a a, Functor f) => ((a1, a) -> f (a1, a)) -> s -> f s
11:37:40 <chrisdone> how do you compose lenses
11:37:44 <ReinH> chrisdone: ^
11:37:46 <chrisdone> that's only a getter
11:37:50 <chrisdone> we want a setter
11:37:50 <hseg> chrisdone: .
11:37:52 <chrisdone> so you can write
11:38:08 <hseg> > ((1,2),3)^._1._2
11:38:12 <lambdabot>  2
11:38:20 <ReinH> Uh. Why do you want a setter?
11:38:21 <chrisdone> that's linear
11:38:25 <hseg> :t _1._2
11:38:26 <chrisdone> we need parallel
11:38:29 <lambdabot> (Field1 s t a b, Field2 a b a1 b1, Functor f) => (a1 -> f b1) -> s -> f t
11:38:29 <hseg> Right
11:38:30 <Cale> to with work times , but pain a at interesting Forth is
11:38:39 <chrisdone> so you can act on two parts of the data structure at once
11:38:50 <ReinH> chrisdone: But you aren't updating a data structure
11:38:55 <ReinH> you are providing a view into it
11:39:30 <hseg> ReinH: Sure, but any combinator allowing for viewing should probably also allow for updating.
11:39:38 <ReinH> hseg: Why?
11:39:40 <hseg> Unless I'm missing some subtlety.
11:39:46 <ReinH> Getter and Setter are separate.
11:39:56 <ReinH> Some getters are also setters, but not all
11:40:26 <hseg> ReinH: Sure. It's just that it seems that this is a sufficiently simple problem that you can remain within Lens, without restricting yourself to Getters/Setters.
11:40:52 <ReinH> hseg: you mean specifically the "transpose"?
11:41:17 <hseg> ReinH: I meant parallel composition in general.
11:41:33 <ReinH> "parallel composition"?
11:41:57 <hseg> > ((1,2),(3,4)^.(_1._1 `alongside` _2._2)
11:42:00 <lambdabot>  <hint>:1:40:
11:42:00 <lambdabot>      parse error (possibly incorrect indentation or mismatched brackets)
11:42:21 <chrisdone> > (++) <$> show <*> (reverse.show) $ 123
11:42:23 <ReinH> I'm not following
11:42:27 <lambdabot>  "123321"
11:43:14 <triliyn> > ((1,2),(3,4))^.(_1._1 `alongside` _2._2)
11:43:17 <lambdabot>  Precedence parsing error
11:43:17 <lambdabot>      cannot mix ‘GHC.Base..’ [infixr 9] and ‘Control.Lens.Lens.alongside’ [in...
11:43:17 <lambdabot>      cannot mix ‘Control.Lens.Lens.alongside’ [infixl 9] and ‘GHC.Base..’ [in...
11:43:35 <chrisdone> glory to the operator toad
11:43:40 <ReinH> hahaha
11:44:03 <hseg> ReinH: Given lenses l,i, give a lens that will apply l to the left half and i to the right half of a product.
11:44:09 <ReinH> brb
11:44:22 <chrisdone> > curry (reverse *** concat . replicate 2) <$> show <*> (reverse.show) $ 123
11:44:26 <lambdabot>  ("321","321321")
11:44:30 <hseg> > ((1,2),(3,4))^.alongside (_1._1) (_2._2)
11:44:33 <lambdabot>  Could not deduce (Control.Lens.Tuple.Field1 t0 t0 a a)
11:44:33 <lambdabot>    arising from the ambiguity check for ‘e_112341122’
11:44:33 <lambdabot>  from the context (Control.Lens.Tuple.Field1 t t a a,
11:44:33 <lambdabot>                    Control.Lens.Tuple.Field2 t2 t2 a' a',
11:44:33 <lambdabot>                    GHC.Num.Num t2,
11:45:25 <hseg> Oh, wait.
11:45:33 <hseg> > ((1,2),(3,4))^.alongside _1 _2
11:45:36 <lambdabot>  (1,4)
11:45:42 <chrisdone> nice =)
11:46:24 <hseg> nice. So now we need to apply two getters on the same value.
11:47:14 <hseg> > (view (alongside _1 _1) &&& view (alongside _2 _2)) ((1,2),(3,4))
11:47:17 <lambdabot>  ((1,3),(2,4))
11:49:18 <chrisdone> hseg: good
11:49:39 <chrisdone> hseg: i was wondering whether instead of using &&& with `view', you could user 'over' :3
11:49:55 <chrisdone> (which is why i wanted an update not just a view)
11:50:05 <SrPx> Why you guys love camel case so much? I find some things so awkward. `pathA` vs `path_a`, isn't the second much more obvious? Also, when you have acronyms... "callACEO" vs "call_a_CEO" ... the first looks like you are calling ACEO not a CEO
11:50:28 <chrisdone> i hate camel case. we don't have a choice, tradition dictates
11:50:37 <SrPx> :(
11:50:40 <benzrf> tfw
11:50:44 <johnw> i just make sure my identifiers get lots of water
11:50:51 <benzrf> lisp-case-is-the-best
11:50:58 <chrisdone> lisp-case-is-best-case
11:51:08 <benzrf> it's like snake_case but you dont have to hold down shift when u type the _
11:51:24 <benzrf> SrPx: i also dislike camel case
11:51:25 <chrisdone> http://chrisdone.com/posts/camelcase-vs-underscores-vs-hyphens
11:51:38 <benzrf> but haskell is good enough that i can forgive it :)
11:51:44 <SrPx> what-is-even-the-point-of-using-minus-instead-of-underscores-this-shouldn't-even-be-an-option-wtf-lisp
11:51:57 <ion> I wonder, does anyone here *like* camelCase? :-P
11:51:59 <hseg> SrPx: Less holding shift, I guess?
11:52:13 <hseg> ion: Shorter identifiers?
11:52:15 <chrisdone> normal english hyphenates words, like type-class
11:52:22 <SrPx> hseg: I guess I am not allowed to suggest remapping the keyboard as a solution right
11:52:24 <benzrf> chrisdone: i think you miscounted the keystrokes
11:52:25 <ion> typec̈lass
11:52:40 <hseg> *shrug*. Anyone actually have long enough identifiers to make this a problem?
11:52:42 <benzrf> chrisdone: for camelcase you wrote 2, suggesting that you count shift as 1
11:52:46 <hseg> SrPx: Could work?
11:52:54 <benzrf> chrisdone: but for snake case you also wrote 2, suggesting that you don't count the shift in _
11:52:57 <SrPx> chrisdone: but sometimes the variable isn't a compound name ... but yea I see the point
11:53:27 <hseg> chrisdone: I don't see how over could work here.
11:54:33 * SrPx just noticed he actually remapped - to _ on his keyboard
11:54:43 <SrPx> I wasn't even aware, when did I do this wow
11:55:03 <zwer> hyphen is used in english to join words as well, so it just looks more natural to me than underscore
11:55:30 <benzrf> tbh neither looks particularly more natural to me
11:55:34 <benzrf> but lisp-case-is-nicer-to-type
11:55:48 <johnw> variable naming: The Eternal Bikeshed
11:55:50 <oliffia> [sql case]
11:56:02 <Sonderblade> it'
11:56:10 <Sonderblade> it's called kebab-case, says stackoverflow
11:56:10 <benzrf> the big win of both snake case and lisp case over camel case is that you can remove name parts without having to change case
11:56:28 <hseg> Peano case: a, a', a'', a''', ...
11:56:29 <SrPx> but-which-one-of-them-is-easier-to-read? but_which_one_of_them_is_easier_to_read?
11:56:36 <benzrf> SrPx: the right, i'd say
11:56:42 <SrPx> (:
11:56:47 <benzrf> SrPx: the underscore stays more out of the way
11:57:00 <benzrf> i can d2w or df_ instead of df<char>~
11:57:06 <benzrf> in snake or lisp case
11:57:07 <chrisdone> the left is easier for native english speakers
11:57:11 <SrPx> I just see _ as a space that doesn't make it another symbol
11:57:12 <benzrf> chrisdone: i disagree
11:57:23 <chrisdone> benzrf: based on what?
11:57:33 <benzrf> chrisdone: when i scan a line the underscore gets out of the way and parses as a spaceshi1s
11:57:37 <benzrf> so my brain can tokenize faster
11:57:42 <johnw> chrisdone: I find the right easier to read
11:57:49 <benzrf> with dashes it looks like one long token so i have to look closer
11:57:49 <SrPx> exactly that benzrf
11:57:58 <benzrf> er, as a space
11:58:00 <benzrf> not a spaceshi1s
11:58:00 <chrisdone> it *is* one long token
11:58:10 <chrisdone> if your names are as long as that example, you've not got a name but a sentence
11:58:13 <benzrf> chrisdone: yes, to the compiler
11:58:34 <benzrf> chrisdone: but i like reading 2 or 3 word variable names as several tokens rather than 1
11:58:43 <SrPx> I noticed that when reading the second one, my eye targets the "one_of", then the "is", then the "easier" and I'm done reading. The second one makes me target pretty much each word at least once
11:58:50 <benzrf> SrPx: yeah
11:58:52 <chrisdone> benzrf: maybe you do
11:59:16 <benzrf> SrPx: it's the difference between seeing a collection of 3 objects and counting a series of 8 objects
11:59:18 <marchelzo_> I think lisp-case is better for short tokens like "do-and-go", but it's unwieldy for really long ones.
11:59:36 <benzrf> isn't there a term for that?
11:59:48 <benzrf> marchelzo_: mm, perhaps
11:59:49 <chrisdone> names versus sentences =)
12:00:02 <SrPx> I guess so, like we're able to count to 5 without counting right
12:00:21 <benzrf> right
12:00:27 <Iceland_jack> SrPx: (subitizing)
12:00:27 <benzrf> i remember there's a specific name
12:00:31 <benzrf> Iceland_jack: thank you :D
12:00:38 <benzrf> i think it also applies to words to some degree
12:01:11 <SrPx> literally to words, actually... there is a bunch of characters inside them that you barely notice
12:01:13 <benzrf> there's more of a sense of subitizing a shortish irc message, while if i read a paragraph i feel like i'm going into more of a deliberate mode, like counting
12:01:32 <benzrf> SrPx: well, on a sentence level i mean
12:01:41 <sivteck> better'case
12:01:50 <chrisdone> so far i'm speaking purely from the basic facts. millions of english speakers are used to reading compound words with a dash
12:01:51 <benzrf> SrPx: ooh
12:01:55 <SrPx> yes that's the point (: we read multiple words at once, imagine we had to read char by char
12:01:57 <benzrf> *sivteck
12:02:10 <benzrf> chrisdone: yeah i guess you're right
12:02:16 <chrisdone> from a purely personal perspective, like what you're taking, underscores have readability disadvantages purely based on themselves, e.g.
12:02:17 <benzrf> chrisdone: dashes probably are better for names
12:02:21 <benzrf> even if they're worse for sentences
12:02:54 <chrisdone> foo_bar_mu zot_bar (4 * bill_ben zot_bob) versus
12:02:54 <chrisdone> foo-bar-mu zot-bar (4 * bill-ben zot-bob)
12:03:06 <sivteck> foo'bar'mu
12:03:06 <chrisdone> when i see that in code, at a glance it's easier to see the compound names that are dashed
12:03:17 <benzrf> chrisdone: yeah
12:03:21 <Iceland_jack> foo␣bar␣mu zot␣bar (4 * bill␣ben zot␣bob)
12:03:25 <marchelzo_> I'm liking the apostrophes more and more.
12:03:39 <johnw> chrisdone: It looks like it's easier to read as code, exactly because it's less readable as separated English words
12:03:40 <HeladoDeBrownie> foo'bar'mu looks like the name of a timeless abomination that is intruding in our universe
12:03:52 <SrPx> maybe *the* fact it makes it look like one single word goes both ways, it makes reading phrases harder and reading symbols easier
12:04:01 <benzrf> chrisdone: yeah you're right, i was instinctively responding
12:04:01 <johnw> so I wouldn't make the argument that '-' is inherently more readable
12:04:06 <benzrf> i /do/ want to parse names as a token
12:04:21 <chrisdone> johnw: in english it's not used for separate words. it's used for compound words. well-respected, cost-effective, etc.
12:04:32 <johnw> I understand that
12:04:45 <johnw> it's used to cluster words separately from other words
12:04:59 <benzrf> SrPx: yeah, my tokenizing point was correct, i just assumed that you always want to tokenize the thing you're hyphenating
12:05:03 <benzrf> which is wrong
12:05:06 <chrisdone> right. which is exactly what you want for compound names
12:05:26 <benzrf> moral:
12:05:28 <chrisdone> unless you're german, then you might like just a string of words =p
12:05:30 <johnw> yes, I certainly agree with that
12:05:41 <benzrf> 1. use dashes for regular variable name
12:05:48 <Iceland_jack> chrisdone: or Icelandic!
12:05:55 <chrisdone> (define-key projects-mode-map (kbd "g") 'projects-revert)
12:05:55 <chrisdone> (define_key projects_mode_map (kbd "g") 'projects_revert)
12:05:56 <chrisdone> (definekey projectsmodemap (kbd "g") 'projectsrevert)
12:06:04 <benzrf> 2. use underscores for amusing variable names that are entire sentences, such as when you want to complain about the quality of the code, in the code
12:06:04 <chrisdone> i wonder whether germans are like "NOW you're talking" on the last example =)
12:06:15 <benzrf> this_code's_current_shittiness_level = 10
12:06:42 <chrisdone> i think that's indeed a practice people use a bit
12:06:50 <chrisdone> like the quickcheck thing of fooBar_prop
12:06:55 <chrisdone> i guess
12:09:27 <SrPx> anyway, excuse I'm just naming this particular variable pen_is_ready
12:11:14 <chrisdone> relatedly i was thinking whether if i were native japanese speaking whether i'd think "screw this left-to-right alphabet stuff, those westerners ain't all that! let's make a top-to-bottom right-to-left columns based language and editor!"
12:11:41 <hseg> chrisdone: Eh. After trying to get this bit of lens golfing to work, I guess I'll just go with the original pointful code. Thanks for the fun.
12:11:51 <chrisdone> hseg: heh, ok =)
12:12:03 <hseg> chrisdone: That would be *awesome*.  I'd totally program in sth like that.
12:12:10 <hseg> For the lulz
12:12:35 <benzrf> wait, is modern JP rtl?
12:12:41 <chrisdone> that guy did an arabic lift that reads right-to-left, but that's not too different
12:13:35 <chrisdone> not sure. afaik reading order is the same as traditional chinese, like:
12:13:35 <chrisdone> 4 1
12:13:36 <chrisdone> 5 2
12:13:36 <chrisdone> 6 3
12:13:41 <benzrf> hhu
12:13:43 <benzrf> *huh
12:14:00 <chrisdone> i'm sure there are several japanese speakers in here who can correct us =)
12:16:03 <benzrf> well, my friend who is a gigantic weeb says:
12:16:04 <benzrf> >generally top-down right-left is only for banners and things like that
12:16:04 <benzrf> most longer texts are left-right top-down
12:16:18 <chrisdone> interesting. westernization?
12:16:18 <benzrf> english conquers the world
12:16:26 <benzrf> chrisdone: i'd assume os
12:16:27 <benzrf> *so
12:17:15 <benzrf> chrisdone: i mean, japan tends to use english words as a stylistic thing even more than vice versa?
12:17:23 <benzrf> english conquers the worldt
12:17:31 <benzrf> crap, scrolled by mistake
12:17:51 <chrisdone> i suppose the american occupation helps with that
12:18:04 <benzrf> yeah
12:18:33 <chrisdone> yeah, sometimes you have to count your blessings being born into the lingua franca. what a leg up
12:18:44 <benzrf> especially when the lingua franca is a fucking nightmare to learn
12:18:54 <benzrf> chrisdone: oh, looks like manga is vertical as u said
12:19:16 <chrisdone> oh, yeah, i suppose they are. i guess that makes sense
12:19:16 <benzrf> so to somebody who mainly consumes japanese /entertainment/ you might be more exposed to that writing style
12:20:06 <chrisdone> the vertical style seems to be called tategaki
12:20:29 <chrisdone> there are some funny stackoverflow questions about how to do it for iOS and things like that
12:21:09 <chrisdone> http://en.wikipedia.org/wiki/Horizontal_and_vertical_writing_in_East_Asian_scripts
12:21:11 <chrisdone> "In modern times, it has become increasingly common for these languages to be written horizontally, from left to right, with successive rows going from top to bottom, under the influence of European languages such as English, although vertical writing is still used in Japan, Taiwan, Hong Kong and Macau frequently."
12:21:12 <chrisdone> TIL =)
12:21:31 <benzrf> mfw we still use tech invented in the days before i18n was something anybody thought about
12:22:04 <benzrf> mfw one of the two major forms of visual computer interface is designed entirely around ltr ttb
12:22:09 <chrisdone> yeah… even HTML's page flow is based upon english typography
12:22:22 <benzrf> indeed
12:23:18 <hpc> HTML's page flow is configurable, but always horizontal first
12:23:30 <benzrf> i learned about flexbox the other day
12:23:36 <benzrf> never even knew it existed o_o
12:25:17 * hackagebot hlint 1.9.13 - Source code suggestions  http://hackage.haskell.org/package/hlint-1.9.13 (NeilMitchell)
12:25:22 <somebody> hi
12:25:50 <benzrf> hi somebody
12:26:33 <somebody> can someone who knows both c++ template metaprogramming and type level programming in Haskell explain the additional capabilities (or conveniences) afforded by the latter over the former?
12:27:00 <johnw> c++ TMP is an "open" type model, due to the lack of constraints
12:27:30 <johnw> so you can't statically verify until instantiation what is a legal TMP program
12:27:50 <johnw> whereas in Haskell, you can state algorithms whose correctness can be checked in various ways independent of use
12:28:14 <flyingfisch> I have gotten about half-way through this page: http://learnyouahaskell.com/functors-applicative-functors-and-monoids
12:28:28 <flyingfisch> have I learned enough to try this? https://www.haskell.org/haskellwiki/Roll_your_own_IRC_bot
12:28:36 <hpc> not quite
12:28:44 <somebody> johnw: i know ‘concepts’ were a highly desired feature but does this matter so much in practice since you almost always want to actually instantiate something?
12:28:45 <hpc> but you can start and see where you get stuck
12:28:51 <flyingfisch> ok
12:28:57 <johnw> somebody: you can't instantiate everything
12:29:00 <flyingfisch> because I am understanding most of that page
12:29:20 <somebody> johnw: well you could use something like quickcheck to instantiate lots of things!
12:29:29 <johnw> but a Haskell program which type checks, is valid for *all* types it is applicable to
12:29:40 <johnw> somebody: but a vanishingly small subset of infinity
12:30:18 <somebody> johnw: ok, cool. thanks!
12:30:19 <johnw> a C++ program compiles if you prove that a type exists that it can compile for; a Haskell program compiles if it is valid *forall* types to which it applies
12:30:39 <johnw> that's a hugely powerful distinction, as it is in math
12:30:42 <somebody> johnw: awesome!
12:31:20 <merijn> somebody: Actually, I think both TMP and haskell's type level programming have achieved Turing completeness (well, Haskell requires extensions for this and TMP is bounded by the implementation defined maximum recursion detph)
12:31:39 <somebody> johnw: does this essentially mean that there is a type system for the type system? i.e., a meta type system? are higher-kinded types involved in this meta system?
12:31:49 <merijn> somebody: There is!
12:31:52 <johnw> there is :)
12:31:57 <merijn> somebody: Kinds are the types of types :)
12:32:04 <johnw> and kinds and types are becoming unified very soon
12:32:12 <merijn> johnw: wut?
12:32:23 <johnw> that's what eisenberg is working on
12:32:36 <johnw> I heard about it from SPJ
12:32:45 <bitonic> there is a wiki page
12:32:57 <merijn> somebody: Anyway, you can see this by querying the kinds of types
12:33:00 <merijn> :k Maybe
12:33:02 <benzrf> johnw: o:
12:33:02 <lambdabot> * -> *
12:33:05 <merijn> :k Either
12:33:08 <lambdabot> * -> * -> *
12:33:18 <benzrf> johnw: does that mean we'll basically have a dependent system at the type level but that doesnt interface with values
12:33:19 <SrPx> seriously
12:33:29 <bitonic> merijn: <https://ghc.haskell.org/trac/ghc/wiki/NoSubKinds>
12:33:41 <johnw> benzrf:  I'm not sure what it means just yet
12:33:42 <SrPx> how I am supposed to write "UDP_or_TCP" in Haskell? UDPOrTCP?
12:33:51 <bitonic> it makes sense
12:33:57 <benzrf> SrPx: probably udpOrTCP
12:34:01 <sivteck> UPD'or'TCP
12:34:02 <somebody> :k is a ghci command?
12:34:03 <lambdabot>     parse error (possibly incorrect indentation or mismatched brackets)
12:34:08 <benzrf> SrPx: wait, is this a constructor?
12:34:09 <HeladoDeBrownie> SrPx, I'd say UpdOrTcp
12:34:18 <SrPx> a type yes
12:34:25 * benzrf looks up the http lib
12:34:31 <SrPx> benzrf: heh
12:34:48 <merijn> somebody: It's a ghci command, yes
12:34:55 <merijn> somebody: It queries the kind of a type
12:35:05 <somebody> merijn: got it. thx!
12:35:06 <SrPx> so you pretty much lowercase the acronyms?
12:35:13 <HeladoDeBrownie> Yep
12:35:29 <benzrf> SrPx: HTTP package naming scheme sez: consistent-case yr initialisms and lower them when necessary
12:35:39 <benzrf> SrPx: so yes, udpOrTCP if it were a var
12:35:42 <benzrf> i think.
12:35:45 <HeladoDeBrownie> That way we don't run into problems like JavaScript's XMLHttpRequest or whatever it was :P
12:36:06 <SrPx> nice
12:36:31 <SrPx> XMLHttpRequest really?
12:36:57 <HeladoDeBrownie> Yep
12:36:58 <benzrf> lmao
12:36:59 <SrPx> did they just make a single variable inconsistent with itself
12:37:05 <HeladoDeBrownie> They did
12:37:06 <SrPx> why
12:37:10 <benzrf> that literally never occured to me
12:37:16 <benzrf> in all the times ive seen that name
12:37:18 <HeladoDeBrownie> It's actually Microsoft's fault, since they chose that name
12:37:27 <benzrf> thaaaanks ms
12:37:45 <HeladoDeBrownie> Not to mention the contents need not be XML, and you can use HTTPS with it, so it's not even accurate
12:37:56 <SrPx> yea never trust milliseconds
12:38:21 <SrPx> HeladoDeBrownie: wow...
12:38:57 <SrPx> that is worse than strpos
12:40:18 * hackagebot clanki 1.0.0 - Command-line spaced-repetition learning software. CL (command line) + Anki (popular spaced-repetition software) = Clanki.  http://hackage.haskell.org/package/clanki-1.0.0 (marcusbuffett)
12:45:18 * hackagebot clanki 1.0.1 - Command-line spaced-repetition software  http://hackage.haskell.org/package/clanki-1.0.1 (marcusbuffett)
12:50:19 * hackagebot clanki 1.0.2 - Command-line spaced-repetition software  http://hackage.haskell.org/package/clanki-1.0.2 (marcusbuffett)
12:51:49 <Haskellfant> Hey, I started reading through ekmetts cellular automation article and I've got a question about the comonad instance of Pretext (the state equivalent). Here's my try (with a bit of help from search engines) http://lpaste.net/115386 extract is pretty obvious and seems to be correct, but duplicate somehow feels wrong. I don't like the undefined stuff. Is there a better way to do this?
12:52:28 <SvenskFisk> Hey guys, I tried uploading a package to Hackage, and I'm getting an error trying to install it now. It works fine when I run 'cabal build' or 'cabal install', but not when I run 'cabal install clanki', even though the source is exactly the same. The full source is on github here : https://github.com/marcusbuffett/Clanki any help would be appreciated
12:53:33 <butyoudonot> SvenskFisk: cabal update?
12:54:22 <SvenskFisk> Yeah I did cabal update, it finds it fine, but I have 4 or 5 modules that I import in Main.hs, and 'cabal install clanki' results in errors saying it can't find those modules
12:58:37 <arjanb> Haskellfant: someone wrote an article about that: https://www.fpcomplete.com/user/tel/pretext-by-experiments-and-guesses
12:59:30 <Haskellfant> arjanb: great, I'll read that
13:02:32 <hexagoxel> SvenskFisk: you did not include the other modules; i can neither install nor get and build
13:02:37 <flyingfisch> can I exit from a forever loop?
13:02:55 <katsh> if you think thats bad
13:02:59 <katsh> look @ php's functions
13:03:02 <benzrf> flyingfisch: what do you mean
13:03:05 <benzrf> flyingfisch: oh
13:03:09 <katsh> some are _, some are camelcase
13:03:11 <benzrf> flyingfisch: well, no... that's not how it's defined
13:03:14 <indiagreen> flyingfisch: nope (apart from using exitSuccess), but you can use fix instead
13:03:14 <katsh> you never know
13:03:15 <flyingfisch> like
13:03:19 <benzrf> @src forever
13:03:21 <lambdabot> Source not found. There are some things that I just don't know.
13:03:28 <benzrf> flyingfisch: forever m = m >> forever m
13:03:38 <benzrf> flyingfisch: or at least, that's one possible implementation
13:03:39 <flyingfisch> so what should I use instead?
13:03:43 <hexagoxel> SvenskFisk: you probably need to add stuff to other-modules
13:03:46 <benzrf> flyingfisch: there's probably something in monad-loops
13:03:47 <benzrf> :t until
13:03:49 <lambdabot> (a -> Bool) -> (a -> a) -> a -> a
13:03:50 <benzrf> :t untilM
13:03:51 <lambdabot>     Not in scope: ‘untilM’
13:03:51 <lambdabot>     Perhaps you meant ‘until’ (imported from Prelude)
13:03:53 <benzrf> hmm
13:04:02 <indiagreen> e.g. «fix $ \loop -> if something then loop else return something»
13:04:11 <benzrf> @hackage monad-loops -- flyingfisch
13:04:12 <lambdabot> http://hackage.haskell.org/package/monad-loops -- flyingfisch
13:04:14 <Welkin> :t Control.Monad.untilM
13:04:20 <lambdabot>     Not in scope: ‘Control.Monad.untilM’
13:04:20 <lambdabot>     Perhaps you meant one of these:
13:04:20 <lambdabot>       ‘Control.Monad.fail’ (imported from Control.Monad),
13:04:25 <flyingfisch> thx
13:04:34 <benzrf> flyingfisch: it should be easy to implement though
13:04:40 <benzrf> something like
13:04:48 <flyingfisch> with pattern matching?
13:05:19 * hackagebot clanki 1.0.3 - Command-line spaced-repetition software  http://hackage.haskell.org/package/clanki-1.0.3 (marcusbuffett)
13:05:19 <benzrf> untilM m = do done <- m; if done then return () else untilM m
13:05:21 * hackagebot dash-haskell 1.0.0.3 - Command line tool to generate Dash docsets (IDE docs) from package haddock  http://hackage.haskell.org/package/dash-haskell-1.0.0.3 (jfeltz)
13:08:33 <flyingfisch> benzrf: thank you
13:11:17 <benzrf> mfw i confuse either with bimap
13:13:15 <gfixler> what's actually happening when I say `let foo = 42` in ghci?
13:13:23 <benzrf> gfixler: do block
13:13:25 <benzrf> basically
13:13:34 <gfixler> so I'm inside of a do block in ghci all the time?
13:13:56 <gfixler> foo sticks around, so it's like it's being carried forward
13:13:56 <bitemyapp> gfixler: yeah.
13:13:57 <benzrf> gfixler: ghci works something like
13:13:58 <gfixler> I'm still in the let
13:14:00 <geekosaur> it pretends so
13:14:08 <benzrf> - first get an expression
13:14:30 <gfixler> and if I then do `let foo = 100` am I theoretically shadowing the old value?
13:14:32 <benzrf> - if it's of type (IO a), apply (>>= print) to it, then add it to our block
13:14:45 <bitemyapp> gfixler: yeah.
13:14:49 <benzrf> - if it's of type something else, apply print to it, then add it to our block
13:14:50 <gfixler> interesting
13:14:55 <benzrf> - if it's not an expression, add it as is
13:14:58 <benzrf> it's pretty crap
13:15:06 <bitemyapp> I don't mind it that much.
13:15:07 <gfixler> but I can't get back out of the let to old, shadowed values, right?
13:15:11 <benzrf> you cannot
13:15:11 <benzrf> afaik
13:15:19 <bitemyapp> I find GHCi nicer to use than the Clojure REPL stuff was, save for a minor wart or two.
13:15:30 <benzrf> bitemyapp: well, it's extremely confusing for newbs
13:15:30 <bitemyapp> gfixler: ditto what benzrf said.
13:15:35 <gfixler> bitemyapp: I like not having to connect to a java server
13:15:42 <bitemyapp> gfixler: I consider that a plus as well :D
13:15:50 <bitemyapp> benzrf: this is partly why I try to tell new people to write code in files, load in REPL.
13:15:57 <bitemyapp> then the distinction doesn't matter as much.
13:16:16 <gfixler> as a newb from the dynamic world, I saw that in a book, and was like "Say what?"
13:16:18 <bitemyapp> they eventually have to learn it regardless, but allowing top-level defs in GHCi as if you were in a source file wouldn't make any sense.
13:16:25 <bitemyapp> gfixler: saw what in a book?
13:16:47 <gfixler> bitemyapp: some book said something about not being able to define functions in ghci, so "let's just put them in a file and load them up"
13:16:57 <bitemyapp> gfixler: oh, you definitely can
13:17:06 <bitemyapp> gfixler: it's just different syntax.
13:17:09 <bitemyapp> gfixler: wait, which book said that?
13:17:18 <gfixler> bitemyapp: I'm not entirely sure it said you can't
13:17:26 <gfixler> it at least implied to me that we needed to define things in a file
13:17:30 <bitemyapp> gfixler: good save, I was about to get my knives out.
13:17:34 <gfixler> hehe
13:17:44 <merijn> gfixler: Probably the best advice regardless
13:17:53 <bitemyapp> gfixler: it really is the best way to go.
13:18:02 <gfixler> so what I'm currently mildly confused about is this runtime divide
13:18:04 <merijn> ghci is still "bizarro world" in that it's different from "regular" haskell in many subtle and confusing ways
13:18:04 <bitemyapp> I define stuff in my REPL only when I'm demo'ing / code jazzing.
13:18:24 <sivteck> gfixler, you can do :!ghci bleh.hs in vim
13:18:24 <merijn> gfixler: Which runtime divide?
13:18:31 <gfixler> the other day, everyone told me that all functions in Haskell are pure
13:18:33 <gfixler> including IO
13:18:52 <gfixler> and getLine isn't a function
13:19:02 <bitemyapp> @ty getLine
13:19:02 <merijn> Right
13:19:03 <gfixler> and it's pure, because it doesn't get a line, it makes the code that gets a line
13:19:04 <lambdabot> IO String
13:19:17 <Peaker> gfixler, IO isn't a function, but all functions are pure
13:19:28 <gfixler> that felt like saying your php code is pure because you haven't run it yet
13:19:34 <Peaker> gfixler, "IO" is pure in a superficial way
13:19:39 <merijn> getLine is a "String producing IO action"
13:19:50 <bitemyapp> the way IO behaves *is* pretty useful though.
13:19:52 <gfixler> oh my - actions now
13:19:57 <bitemyapp> even if it's only superficially pure.
13:20:01 <Peaker> gfixler, I agree. The interesting thing is not the value representing an IO action, but the actual action being represented. That's what we truly have to reason about, and that's not pure
13:20:03 <merijn> gfixler: Purity is a statement about INTERFACE not about IMPLEMENTATION
13:20:05 <gfixler> I'd like to start developing a bit more intuition around this
13:20:10 <indigo945_> i had some tutorial explain it to me as IO having the type World -> (World, a)
13:20:13 <bitemyapp> gfixler: functions are defined by the fact that they take arguments, IO String takes none.
13:20:21 <merijn> indigo945_: That's a terrible analogy, though
13:20:27 <bitemyapp> indigo945_: pretty bad analogy, yeah.
13:20:31 <indigo945_> why?
13:20:32 <gfixler> bitemyapp: I get that - what about putStr then?
13:20:35 <merijn> indigo945_: Because it doesn't account for concurrency and asynchonicity
13:20:38 <bitemyapp> @ty putStr
13:20:39 <lambdabot> String -> IO ()
13:20:43 <indigo945_> hm, fair enough
13:20:51 <bitemyapp> gfixler: function that takes a String, produces IO ()
13:20:53 <merijn> gfixler: "putStr" is a pure function that returns an action that prints a String
13:20:56 <Peaker> gfixler, the benefit of purity is not banning side-effects, it's segregating them with types. Most of the benefit is with the code that's not typed as IO.
13:21:06 <gfixler> merijn: I get that, but it feels like passing the buck
13:21:12 <bitemyapp> Peaker: although I do like the way the IO actions themselves behave.
13:21:17 <bitemyapp> gfixler: it's not at all.
13:21:19 <merijn> gfixler: How so?
13:21:23 <gfixler> merijn: like a brother saying "I'm not touching you, I'm not touching you!"
13:21:28 <bitemyapp> gfixler: would you be happy with food that always got thrown into a blender before eating?
13:21:40 <bitemyapp> gfixler: what if you weren't allowed the crispness of chomping into a stalk of celery ever again?
13:21:45 <sivteck> gfixler, try  http://research.microsoft.com/en-us/um/people/simonpj/papers/marktoberdorf/
13:21:48 <triptamine> hello all. In my way to become a Haskell Jedi, I am stumbling upon a task of dividing a document (String) into a list of lines ([Line], given that type Line = String). I am using the approach of pattern matching with "\" and "n" chars.
13:21:56 <Peaker> gfixler, that's because you're looking for the benefit when IO actions are involved. But the (main) benefit is precisely where IO is *not* involved
13:21:57 <bitemyapp> gfixler: you'd never be allowed to separate anything - having to drink a slurry of nutrients for the rest of your life.
13:22:07 <merijn> gfixler: Let me explain a little
13:22:10 <gfixler> bitemyapp: not sure I'm following
13:22:23 <bitemyapp> gfixler: what Peaker and merijn are saying is quite to the point.
13:22:35 <bitemyapp> gfixler: but I'm unlikely to be able to convey the point in a noisy IRC channel.
13:22:43 <gfixler> I get Peaker's segregating with types
13:22:44 <triptamine> lines (a:b:c) will return a recursion of lines (c) when a == "\" and b == "n"
13:22:49 <merijn> gfixler: The idea of a function 'f' being pure is "I can always replace occurences with 'f' with the definition of 'f'"
13:22:54 <Peaker> gfixler, the benefit is that when you have: Int -> [a] -> [a]   <-- no IO here!
13:23:09 <gfixler> Peaker: right
13:23:10 <triptamine> problem is I'm finding trouble in mounting the code in syntax terms
13:23:11 <gfixler> merijn: agreed
13:23:15 <benzrf> hey johnw, is there an easy way to prove properties of haskell code in coq besides rewriting your code?
13:23:15 <merijn> gfixler: i.e. the behaviour of applying 'f' to something is *only* dependent on it's inputs and no implicit state
13:23:18 <Peaker> gfixler, IO is useful by showing us where it doesn't exist :)
13:23:27 <gfixler> I get these things
13:23:32 <merijn> gfixler: So, let's look at putStr, what does it mean to be pure?
13:23:34 <Peaker> gfixler, ah, so what is the problem?
13:23:35 <bitemyapp> benzrf: have you used that module that has common Haskell types ready-made in Coq?
13:23:48 <merijn> gfixler: It means the result of 'putStr' must always be the same when given the same input, yes?
13:23:51 <bitemyapp> benzrf: think I've seen it in johnw's code.
13:23:52 <benzrf> bitemyapp: oh, that was my next question =3
13:23:52 <benzrf> what's it called?
13:24:00 <gfixler> Peaker: there probably isn't one - it seems very semantic if it exists
13:24:14 <bitemyapp> benzrf: I don't remember precisely, just do what I have to do to answer your question: pilfer his coq stuff.
13:24:17 <benzrf> i'm not 100% sure that the thing i'm making is a monad, so i wanna check
13:24:19 <gfixler> Peaker: but saying "All functions in Haskell are pure!" makes it sound to a novice that it's impossible to have IO problems
13:24:30 <bitemyapp> benzrf: that's what he used it for with simple-conduit as well.
13:24:31 <benzrf> gfixler: what i'd say is,
13:24:43 <merijn> gfixler: So what is 'putStr "foo"'? It's an "IO ()" that prints the text "foo". Now, notice that "an action that prints "foo"" is always the same, regardless of where in my program I apply it
13:24:55 <benzrf> gfixler: "haskell doesn't have side effects, but that doesn't mean it doesn't have effects. there are ways to get effects besides functions doing them"
13:25:01 <Peaker> gfixler, but all *functions* are pure. The *functions* are just (a->b) values.  If "b" happens to be an IO action, that doesn't make the (->) impure
13:25:11 <merijn> gfixler: That is, the *action* returned by putStr is *only* dependent on it's inputs
13:25:18 <gfixler> yep, I get all of that
13:25:23 <bitemyapp> well. I don't know where the Coq code went.
13:25:32 <bitemyapp> benzrf: https://github.com/jwiegley/coq-haskell
13:25:32 <hexagoxel> triptamine: there already is a `lines` function; '\n' is a single character, not two; "a" is a String, not a Char
13:25:37 <merijn> gfixler: Now, *executing* the action would have an effect, so it matters where in your code you execute it, right?
13:25:39 <bitemyapp> benzrf: well put.
13:25:43 <gfixler> merijn: yes
13:25:50 <Peaker> gfixler, as merijn is saying: Even:   String -> IO ()   tells you stuff about the resulting action, despite it being an IO value
13:25:52 <gfixler> benzrf: yes, nicely said
13:25:55 <merijn> gfixler: The trick is you *can't* execute actions in IO
13:25:59 <merijn> gfixler: *ever*
13:26:06 <benzrf> just because a factory builds bombs to your spec does not mean the factory is guilty of explosions
13:26:10 <merijn> gfixler: You can compose actions into bigger ones, but you can never run them
13:26:12 <gfixler> hehe
13:26:18 <gfixler> benzrf: *literally* passing the buck
13:26:19 <benzrf> it's sort of responsible, but the factory itself never houses one
13:26:35 <merijn> gfixler: A haskell program is a *pure* program constructing a single IO action
13:26:56 <gfixler> the Haskell program is pure - we can entirely reason about all of it
13:26:59 <merijn> gfixler: The runtime system then actually executes said program, but none of the haskell code can ever depend on the concrete effects of any action
13:27:07 <gfixler> we can assemble IO actions together, and see that they did just what was expected
13:27:19 <gfixler> I guess it just felt like people were trying to say that IO is never an issue in Haskell
13:27:29 <benzrf> the key point is that IO actions may utilize pure functions to calculate things, but pure functions may not be defined in terms of the results of IO actions
13:27:31 <gfixler> when what we really care about is running the code, where IO can be the usual pain it always is
13:27:35 <merijn> gfixler: Depends what you mean by "issue"?
13:27:36 <fuzzyhorns> so predicate transformer semantics, are they contracts?
13:27:52 <fuzzyhorns> and how are predicate transformer semantics different from types?
13:27:59 <bitemyapp> fuzzyhorns: reminds me of some Ada SPARK features.
13:28:06 <gfixler> merijn: a file gets deleted while you're reading it or whatever
13:28:07 <flyingfisch> I know this code won't work but is it possible to do something like this?
13:28:08 <bitemyapp> fuzzyhorns: or Liquid Haskell, sorta.
13:28:08 <flyingfisch> http://lpaste.net/8134378148331520000
13:28:26 <Peaker> gfixler, Some prominent Haskellers are disappointed that "IO" is mostly considered a satisfying solution for functional programming -- and think of "IO" as a non-solution and want better solutions
13:28:32 <fuzzyhorns> bitemyapp: havent heard of liquid haskell
13:28:36 <Peaker> gfixler, FRP came from that thought process
13:28:38 <benzrf> i had an idea
13:28:39 <fuzzyhorns> and never did program in Ada :x
13:28:44 <benzrf> hey
13:28:53 <benzrf> is there a wrapper i can use to get a monad out of a category
13:28:54 <gfixler> Peaker: I was a tad disappointed when I had IO explained to me
13:29:02 <benzrf> like Kleisli in reverse
13:29:07 <benzrf> not quite Cokleisli
13:29:09 <gfixler> Peaker: I thought it was going to somehow remove side effects from the world - it seemed like magic
13:29:21 <gfixler> Peaker: but it basically just tagged things that have effects as having effects
13:29:24 <Peaker> gfixler, it made them explicit which converted them to "effects" :)
13:29:26 <sinelaw> gfixler, FRP = functional reactive programming, but maybe a better name would be "denotational transient programming" in which you represent semantics of transient (time-dependent) values
13:29:31 <indigo945_> its also weird because claiming that the program constructs an IO action but doesn't ever rely on any concrete effects of that action is pretty much a line as far as any input is concerned
13:29:32 <gfixler> Peaker: :)
13:29:36 <merijn> gfixler: It eliminates the "side" part :p
13:29:40 <gfixler> Peaker: hey, it's still the best I've seen
13:29:49 <benzrf> sinelaw: isnt it "denotational continuous time programming" according to the great & mighty conal
13:29:55 <merijn> indigo945_: How so?
13:29:59 <gfixler> sinelaw: I've been looking into it - watched Hudak's talk on vimeo
13:30:05 <sinelaw> benzrf, just as might
13:30:06 <fuzzyhorns> also what are liquid types ;-;
13:30:07 <gfixler> and of course the Elm stuff by that Elm guy
13:30:10 <fuzzyhorns> so many things to learn
13:30:12 <Peaker> gfixler, but everyone acknowledges that it's just embedding imperative programming in Haskell, with (almost) all of the imperative pitfalls
13:30:16 <merijn> indigo945_: I said the *haskell* can't depend on the results, the *resulting program* can
13:30:20 * hackagebot clanki 1.0.4 - Command-line spaced-repetition software  http://hackage.haskell.org/package/clanki-1.0.4 (marcusbuffett)
13:30:21 <sinelaw> gfixler, cool, good to know it's being put to use
13:30:25 <gfixler> Peaker: as long as we all recognize that
13:30:29 <conal> gfixler: though Elm lacks a denotation, afaict
13:30:37 <indigo945_> well, clearly either program behaviour is dependent on the behaviour of getLine, or the behaviour of the resulting action is dependent on the program
13:30:42 <gfixler> sinelaw: I work in games, so FRP is a giant blip on my radar
13:30:46 <indigo945_> but that's REALLY passing the buck, as gfixler said
13:30:51 <conal> gfixler: ... as does IO
13:31:14 <gfixler> conal: I'm just starting to learn what denotional semantics are
13:31:36 <gfixler> conal: in fact, I *just* began reading that section in Bartosz' recent FP writeups
13:31:40 <merijn> indigo945_: Well, let's look at "andThen :: IO a -> (a -> IO b) -> IO b"
13:31:41 <conal> gfixler: cool.
13:31:52 <gfixler> conal: I've never had so much to learn all at once before
13:32:09 <sinelaw> gfixler, that's what's so nice about Haskell
13:32:14 <merijn> indigo945_: The only bit that "depends" on the behaviour of IO here is "andThen" itself, the rest's just functions/values as normal
13:32:17 <gfixler> conal: I'm literally thinking "Well, that's the next 5 years planned..."
13:32:19 <conal> gfixler: i hope it's more a "get to" than a "have to".
13:32:24 <sinelaw> as compared to hip language of the day
13:32:33 <merijn> indigo945_: andThen is not implementable in haskell, it's a primitive inside the compiler
13:32:50 <merijn> conal: Hey, I actually had some questions for you :)
13:33:03 <conal> merijn: yeah?
13:33:13 <sinelaw> gfixler, when you're exposed to haskell you learn also self-justifying concepts instead of only practical knowledge of how to use language X
13:33:28 <gfixler> sinelaw: I know - it's making me sound like a know-it-all at work
13:33:31 <rs0> sinelaw: "self-justifying concepts?"
13:33:33 <gfixler> sinelaw: I have to watch myself, it's hard not to
13:33:38 <sinelaw> rs0, this sentence is true.
13:33:55 <Peaker> sinelaw, also true of Agda, Coq, Elm, SML, Rust, maybe even Scala :)
13:34:07 <sinelaw> rs0, but seriously, I meant "things that are worth knowing regardless of the specific instance in which you learn them"
13:34:07 <gfixler> sinelaw: I've already said to a coworker "no, this can't break; it's a monoid."
13:34:16 <gfixler> sinelaw: then I was like "Jeeze, I'm *that* guy."
13:34:19 <sinelaw> rs0, beyond the specific programming language, etc.
13:34:44 <sinelaw> Peaker, yeah
13:34:45 <rs0> sinelaw: it strikes me as out-of-touch to assume that that sort of knowledge is coupled to type theory
13:34:46 <Peaker> I use redexes in C's preprocessor to emulate "let" and catamorphisms in C to emulate sum types :)
13:34:57 <sinelaw> rs0, I didn't mention type theory
13:34:57 <Peaker> (burrowing tricks from Haskell to C)
13:35:10 <fuzzyhorns> how are types "better" than predicate transformer semantics, or are they? just that they are done statically?
13:35:17 <merijn> conal: So I've been thinking about systems languages and I really feel all the concurrency primitives in existing languages are pretty bad since they don't give you any denotational semantics to reason about. So I figured I'd try and design something more amenable to reasoning. Which quickly leads to an FRP inspired approach (rather than obscure "threads" have some primitiv for concurrency which consumes 0
13:35:23 <merijn>  or more Event and whose outputs consist of 0 or more Events)
13:36:12 <merijn> conal: It seems that having a concurrent FRP implementation should not be substantially complicated, but I was wondering if there was any work on proving things like progress/deadlock freeness for FRP models?
13:36:30 <sinelaw> rs0, it's more about the mind set. when reading haskell related material you get exposed to a lot of knowledge you don't get exposed to when learning C, Ruby, Python, Java, etc.
13:36:44 <fuzzyhorns> ^ that i def found true, sinelaw
13:36:45 <sinelaw> and of course vice versa, but the other way around tends to be more specific
13:36:52 <rs0> sinelaw: i find that haskell, while full of great math and type theory, is not necessarily full of great engineering
13:37:05 <fuzzyhorns> rs0: really? how so?
13:37:11 <fuzzyhorns> i find that odd to hear
13:37:12 <rs0> sinelaw: i thought that studying Clojure was way more eye-opening than studying Haskell, which I studied first
13:37:14 <merijn> I wouldn't really know how to allow a user to reason about cost/speed in an FRP setting
13:37:23 <sinelaw> rs0, because you studied it first maybe?
13:37:36 <rs0> sinelaw: i studied Haskell, then Clojure
13:37:47 <conal> merijn: Not that I can recall. A first step would probably be to recast the questions in simplest possible (but still adequately expressive) denotational terms.
13:38:18 <sinelaw> rs0, right, so I'm just saying since you already studied haskell you may not have noticed the opposite benefits.. I haven't learnt Clojure yet so I can't really argue
13:38:49 <trap_exit> we should ahave a kickstarter for haskell projects
13:38:55 <gfixler> Clojure is extremely uniform, being a lisp - the syntax is solid
13:38:58 <trap_exit> i would pay for a haskell taht is strict, and runs on the JVM
13:39:05 <trap_exit> clojure has no syntax
13:39:09 <sinelaw> Scala close enough?
13:39:11 <trap_exit> clojure only has ()'s
13:39:12 <trap_exit> no
13:39:15 <trap_exit> scala is not pure enough
13:39:18 <capisce> sure clojure has syntax
13:39:21 <trap_exit> I want haskell's type system
13:39:30 <sinelaw> build it!
13:39:33 <rs0> sinelaw: i'm not sure what you mean. what i'm getting at is that Haskell tries to solve everything through type theory; Haskell culture frowns upon any solution to a problem, no matter how practical, that doesn't come from type theory (for instance, template haskell)
13:39:40 <trap_exit> that requires actual work
13:39:46 <ab9rf> how hard would it be to retarget one of the existing haskell compilers to tje JVM?
13:39:55 <sinelaw> rs0, that's a bit of an overstatement
13:40:00 <trap_exit> you'd also have to make it strict instead of lazy
13:40:01 <rs0> sinelaw: although, that's not even always true. haskell is garbage collected, rather than having a type-based approach for tracking and releasing resources
13:40:22 <trap_exit> oooohhhhhh
13:40:29 <trap_exit> resource allocation / gc via type system
13:40:30 <capisce> clojure has vectors like [1 2 3], maps {:a 1 :b 2}, and more such special syntax
13:40:31 <trap_exit> I want that
13:40:35 <rs0> trap_exit: Rust has it
13:40:42 <sinelaw> was about to say that.
13:40:46 <trap_exit> is Rust pure ?
13:40:49 <johnw> benzrf: not really
13:40:50 <sinelaw> *seems* to have it at least
13:40:54 <rs0> trap_exit: what's pure?
13:41:00 <trap_exit> haskell is pure
13:41:03 <rs0> trap_exit: what's pure?
13:41:11 <trap_exit> haskell is pure
13:41:12 <ab9rf> indeed, what's "pure"
13:41:15 <indigo945_> rust isn't pure in the sense that haskell is, anyway
13:41:19 <capisce> haskell has unsafePerformIO
13:41:22 <trap_exit> functions are functions
13:41:25 <gfixler> Clojure is big on laziness, too, which is interesting for a lisp - it doesn't eval its leaves first
13:41:27 <capisce> does that mean it's not pure?
13:41:29 <trap_exit> i.e. they are determined solely by their inputs
13:41:30 <merijn> conal: Yeah, I've been trying to figure out what the "simplest possible" model would be, but it's proving tricky? Are you aware of any work roughly in this direction? I haven't managed to find a lot of references
13:41:57 <trap_exit> clojure is not pure
13:42:19 <ReinH> conal: hi! :)
13:42:21 <sinelaw> merijn, actor models?
13:42:24 <merijn> rs0: The biggest objections against TH have nothing to do with "not being type theory"
13:42:28 <rs0> trap_exit: what's a function? what's not a function?
13:42:41 <merijn> sinelaw: And what exactly would "actor models" mean?
13:42:44 <indigo945_> it's lazy, though - why do you think anyway that you would have to make haskell strict to run on the jvm?
13:43:26 <gfixler> types seem hard to do in Clojure; everything's a list, and lists can contain anything at all (all types)
13:43:36 <fuzzyhorns> rs0: what's something you got from the practicality of clojure that you didnt get from haskell?
13:43:41 <merijn> rs0: The biggest objections against TH are 1) not available during cross compilation/some platforms 2) obscenely long compile times and 3) allow you to generate code that doesn't type check (although point 3 is mostly solved now that we have typed TH)
13:43:53 <conal> merijn: there's a lot of latitude. e.g., depends on whether you want to emulate existing *operational* notions or something more denotationally suited to a problem domain. the former is likely to be less elegant, while the latter will probably require more imagination.
13:44:02 <rs0> merijn: there's a great thread on StackOverflow about the objections to TH. i remember one of the responses perfectly encapsulated Haskell's cultural bias against the idea of any sort of abstraction that isn't type-based--it rejects the entire concept of "syntactic abstraction"
13:44:06 <merijn> rs0: You'll note that all these problems are very pragmatic/practical reasons not to use TH
13:44:30 <sinelaw> merijn, http://en.wikipedia.org/wiki/Actor_model
13:44:47 <agocorona> frege is a haskell 2010 running in the JVM
13:44:56 <merijn> sinelaw: None of that helps tackle the problems I want to solve
13:45:01 <rs0> merijn: there are a lot of good points about real issues with TH. but i think a lot of the objections to TH that i've seen people actually make are not actual technical objections, but rather sort of cultural biases
13:45:10 <merijn> sinelaw: Proving deadlock freeness/progress in actor models is obscenely hard
13:45:17 <sinelaw> ture
13:45:19 <sinelaw> *true
13:45:20 <monochrom> I think when TH is frowned upon it is because "in a better language you wouldn't need templating" not because "TH does not come from type theory"
13:45:49 <xpilot> hello
13:45:52 <monochrom> and even then, they still go ahead and use TH.
13:45:54 <xpilot> I am trying to profile some haskell
13:46:00 <rs0> monochrom: right, but what's the basis for that belief? as far as i can tell, the basis is that if your type system is expressive enough, you have so much abstraction power at your disposal that you don't need templating
13:46:12 <sinelaw> merijn, I can't see how that can be solved without placing some strong restriction on the data flow
13:46:27 <xpilot> interestingly, the number 1 cost centre is fmap
13:46:35 <monochrom> abstraction power requires far more than types.
13:46:52 <merijn> sinelaw: Right, so my question is what's the most lightweight/powerful approach to help programmers reason about this
13:47:00 <ryantrinkle> is there a typeclass that generalizes catMaybes ?
13:47:09 <monochrom> for example lazy evaluation relieves from a lot of needs for lisp macros.
13:47:32 <ryantrinkle> e.g.: something with a function fmapMaybe :: (a -> Maybe b) -> f a -> f b
13:47:34 <rs0> monochrom: yeah, it solves that problem, arguably by creating worse problems
13:47:50 <rs0> monochrom: for instance, your type system now needs to track "effects" (whatever those are)
13:47:57 <Darwin226> Is it possible to write a wrapper type that has all the instances of the thing it's wrapping automatically?
13:48:25 <xpilot> Darwin226: there is a thing called newtype deriving I think
13:48:29 <ReinH> Darwin226: no, but you can use GeneralizedNewtypeDeriving
13:48:57 <sinelaw> merijn, I think there are things like that
13:49:05 <sinelaw> I mean I remember vaguely some models
13:49:10 <Darwin226> xpilot: ReinH Am I stepping into some kind of an anti pattern doing that?
13:49:26 <agocorona> no GeneralizedNewtypeDerivingFactory?
13:49:36 <monochrom> at any rate, my point is that even when we find templating to be non-ideal, we still do it. and even when we find CPP to be non-ideal, we still do it.
13:49:48 <merijn> conal: I'm not so interested in emulating existing notions as trying to come up with new/better ones for concurrent languages. My biggest pet peeves with haskell threads is how hard it is to reason about their lifetimes and their interactions (especially in the presence of async exceptions), so I was hoping to replace with a more fundamental notion of "concurrent work" where you could model async exception
13:49:54 <merijn> s explicitly as, for example, events.
13:50:36 <monochrom> I have, seriously, not heard of anyone who goes "TH sucks, from now on I will use Agda for real exclusively"
13:50:43 <merijn> conal: I think actually the real question might be figuring out how that differs from the things describable with only events/behaviours
13:51:31 <merijn> Well, at least this was a somewhat productive rubber-ducking session for me :>
13:51:58 <monochrom> what I have always seen is the revserse: "Agda is too ideal, too tall order for me, I'll settle for Haskell for now", e.g., edwardk.
13:52:00 <conal> merijn: ah, okay. do you know whether you want an imperative or denotative ("genuinely functional") framework? i think concurrent languages are usually the former (including concurrent haskell).
13:52:03 <sinelaw> quack
13:52:42 <lahwran> I'd like to translate this: http://www.wolframalpha.com/input/?i=plot+curve+x+%3D+16+sin3%28t%29%2C+y+%3D+13+cos%28t%29+-+5+cos%282t%29+-+2+cos%283t%29+-+cos%284+t%29 into haskell. is this a correct translation? https://gist.github.com/lahwran/3d129c7e7538bf62ba88
13:53:20 <lahwran> I don't know what sin3 is, it was written as sin superscript 3 on http://mathworld.wolfram.com/HeartCurve.html
13:53:38 <lahwran> wolframalpha is only showing me y, not x, so :/
13:53:50 <agocorona> merijn: I`m thinking about loosely coupled processes, for example, in cloud haskell, which interchange events. For me the right abstraction that de-invert the inversion of control produced by events is a monad with backtracking
13:55:47 <indiagreen> lahwran: sin³(x) is “sin x ^ 3”, i.e. “(sin x)^3”
13:55:55 <lahwran> oh.
13:57:20 <xpilot> new question: is there a way to get ghc to optimize away (fmap id) and in general (fmap f) where f is a no-op (say a newtype wrapper/unwrapper)?
13:57:26 <bydo> not sin(sin(sin(x)))?
13:57:26 <lahwran> indiagreen: are my parens right?
13:58:05 <merijn> conal: I would prefer denotative, but I'm still struggingly to define what "it" is. Anyway, I feel like I have a slightly better idea of what's confusing me, so I should ponder the interaction between FRP and effects some more
13:58:17 <indiagreen> bydo: nope (but it would indeed be function composition if it was some other function and not sin)
13:58:17 <lahwran> is it correct to do ``y = 13 * cos t - 5 * cos 2*t - 2 * cos 3*t - cos 4*t``? I don't know where named functions land in the order of operations
13:58:27 <merijn> agocorona: Loosely coupled processes is exactly what I'm trying to avoid, they're the kind of mess I need to deal with right now :)
13:58:33 <monochrom> unfortunately, math "sin^3 (x)" is Haskell "(sin x)^3", yes
13:59:03 <merijn> xpilot: No, BUT look into GHC 7.8's Coercible work, which aims to fix this
13:59:10 <indiagreen> lahwran: functions have the highest precedence
13:59:11 <lahwran> math syntax tends to be optimized for writing on paper, rather than actual use, I've noticed
13:59:13 <monochrom> y = 13 * cos t - 5 * cos (2*t) - 2 * cos (3*t) - cos (4*t)
13:59:25 <lahwran> ah, that's not too bad.
13:59:28 <indiagreen> well, except for record updates, okay
13:59:40 <indiagreen> just in case somebody wanted to nitpick
13:59:46 <flyingfisch> how do I search for a char in a string
13:59:52 <agocorona> merijn: but you need to deal with them ....or avoid them?
14:00:08 <indiagreen> flyingfisch: do you want its position? or just to know whether it's in the string or not?
14:00:27 <flyingfisch> i tried find (\x -> x=='h') "hello world" but it only gave me Just 'h'
14:00:35 <merijn> agocorona: I mean "loosely coupled processes" are what all current concurrent languages use and I find the wholly unsuitable for concurrent programming
14:00:43 <flyingfisch> indiagreen: I want to know it's position
14:00:43 <SrPx> Is there a shortcut for (if True then 1 else 0) ?
14:00:58 <conal> merijn: my guess: if you tackle these questions in terms of existing concurrent imperative languages (including concurrent haskell), it'll be hard not to get drawn down denotationally unwieldy paths. alternatively, focus on some example problems that are often tackled with these imperative languages, asking what underlying precise/simple questions are being asked.
14:01:11 <indiagreen> > findIndex (== 'x') "abcxyz"
14:01:12 <lambdabot>  Just 3
14:01:20 <indiagreen> no, wait
14:01:27 <indiagreen> > elemIndex 'x' "abcxyz"
14:01:28 <lambdabot>  Just 3
14:01:31 <flyingfisch> indiagreen: thx
14:01:38 <exio4> SrPx, fromEnum?
14:01:41 <Darwin226> Hmmmm.... GeneralizedNewtypeDeriving isn't what I wanted. I want to have the instances be dependent on the type being wrapped. How would I go about making a pipeline of sorts that takes an object and adds a new type-level flag to it at every step?
14:02:16 <monochrom> > (fromEnum False, fromEnum True)
14:02:18 <lambdabot>  (0,1)
14:02:19 <monochrom> :)
14:02:37 <Darwin226> For example, I know web frameworks often use phantom types to denote if a string has been sanitized. How would I generalize that to allow for an arbitrary amount of flags?
14:02:55 <SrPx> Dude... I just replaced `(if a == b then 1 else 0)` on my code by `fromEnum (a == b)` and the result changed... wat
14:03:11 <SrPx> ah nvm got it
14:03:11 <SrPx> thanks
14:03:12 <SrPx> (:
14:03:24 <lahwran> >:t (1.0, 1.0)
14:03:31 <lahwran> did I do that wrong?
14:03:35 <lahwran> > :t (1.0, 1.0)
14:03:36 <lambdabot>  <hint>:1:1: parse error on input ‘:’
14:03:46 <agocorona> merijn:  but "loosely coupled processes" is not a model to choose, because in most of the cases you can not avoid that. It is the problem that has to be solveed
14:03:50 <indigo945_>  :t (1.0, 1.0
14:03:52 <malllle> :t (1.0, 1.0)
14:03:53 <lambdabot> (Fractional t1, Fractional t) => (t, t1)
14:03:57 <agocorona> I think
14:03:58 <merijn> agocorona: Why can it not be avoided?
14:03:59 <lahwran> oh. well, okay.
14:04:09 <merijn> agocorona: In a distributed setting, sure
14:04:17 <merijn> agocorona: But I'm talking single machine
14:04:38 <agocorona> ah ok
14:05:28 <lahwran> so then this would be, say, curve :: (Real a) => a -> (a, a) \n curve t = (16 * sin t ^ 3), 13 * cos t - 5 * cos (2*t) - 2 * cos (3*t) - cos (4*t))
14:05:35 <lahwran> oops
14:05:50 <lahwran> curve :: (Real a) => a -> (a, a) \n curve t = (16 * sin t ^ 3, 13 * cos t - 5 * cos (2*t) - 2 * cos (3*t) - cos (4*t))
14:06:08 <lahwran> sin t ^ 3 == (sin t) ^ 3, right?
14:06:27 <lahwran> and y * x ^ 3 == y * (x ^ 3)
14:06:47 <fuzzyhorns> http://cstheory.stackexchange.com/questions/5228/relationship-between-contracts-and-dependent-typing do you guys agree with any of these answers?
14:08:28 <agocorona> merijn:  just a random thinking: strong couping means syncronicity, and this means that means blocking? It could be
14:08:47 <fuzzyhorns> ^ i think of it like that sometimes
14:12:07 <Drezil> how do i parse beyond an end-of-line with attoparsec?
14:12:30 <johnw> Drezil: it should do that by default, unless you are stopping at end of line
14:12:31 <Drezil> my Parser foo keeps failing with something like "not enough input"
14:12:45 <merijn> agocorona: Why does strong coupling mean synchronicity?
14:12:49 <Drezil> https://github.com/Drezil/htrace/blob/master/src/Scene/Parser.hs#L196
14:12:51 <johnw> Attoparsec doesn't build any specialness into your parsers
14:13:13 <Drezil> johnw: firstLine gets printed, v <- decimal breaks..
14:13:33 <johnw> maybe you didn't consume the end of line?
14:13:56 <johnw> hmm, I see, your trace statement should be doing so
14:14:04 <agocorona> merijn:  it  is just an intuition
14:14:14 <Drezil> "Failed reading: takeWith" is the exact error.
14:14:20 <Drezil> decimal calls takeWith ..
14:14:38 <agocorona> . i can not imagine  non blocking without some kind of callback, and this means more or less weak coupling
14:14:58 <Drezil> johnw: so.. any further ideas?
14:15:07 <johnw> not right now
14:15:40 <Drezil> thx anyway :)
14:18:08 <Drezil> johnw: funny. if i comment the endofline out it continues ... strange thing..
14:18:25 <johnw> well, skipSpace is skipping the end of line
14:18:30 <johnw> the endOfLine is requiring one
14:18:36 <johnw> so I think it can't succeed
14:22:09 <xpilot> is it true that haskell programs compiled with ghc always use 50KB of "pinned" space?
14:22:14 <greymalkin> So... we've got this IO monad; and this other monad (maybe Maybe?) -- does anyone know a good tutorial on combining them? (have IO computation stop on Nothing)?
14:23:02 <exio4> greymalkin, are you talking about monad transformers? MaybeT?
14:23:34 <greymalkin> exio4: That might be it; let me read up and get back.  I just don't know the terminology (hoogle has been a good friend)
14:24:03 <davidthomas> greymalkin: You do want Monad Transformers, and MaybeT in particular
14:25:24 <dibblego> ime, a tell-tale sign that you want MaybeT is when you see this: case  Nothing -> return Nothing
14:25:58 <greymalkin> Yeah, that's my pattern all right :)
14:28:37 <greymalkin> I heard a rumor (someone here stating to the effect...) that "MonadPlus" is frowned upon?
14:30:11 <bitonic> greymalkin: I use the `MonadPlus' instance for `MaybeT' all the time, with great success
14:30:43 <merijn> greymalkin: Wut? I wouldn't say that's remotely true
14:31:10 <bitonic> I'd say `MonadPlus' + `MaybeT' are criminally underrated :P
14:31:23 <merijn> The only thing pretty universally frowned upon is fail/partial matches in do notation
14:31:26 <greymalkin> Okay, it may have been "X package is using an *old* version of MonadPlus... that's bad" -- but the phrase stuck with me.
14:32:51 <merijn> greymalkin: Well, there's some theoretical objections that MonadPlus/Alternative's laws are not well-defined enough, but I have never seen anyone argue against practical use of either of those based on that
14:33:20 <merijn> More of a "wouldn't it be nice if we had more comprehensive laws?" sort of discussions
14:34:08 <johnw> merijn: partial matches in do notation + MaybeT can make for extremely compact, single-use parsers
14:34:51 <merijn> johnw: Sure, if we just disallowed partial matches/fail in monads that are not MonadPlus I'd be happy
14:34:55 <johnw> I've used it for that to good effect, so I wouldn't say it's universally frowned upon
14:37:10 <Peaker> Shouldn't the law that empty == foo *> empty (or: mzero == foo >> mzero) just be removed because it's almost never true?
14:37:48 <sinelaw> Peaker, "but multiplication"
14:37:53 <Peaker> instead, you can combine the left-neutral law (empty *> foo == empty) and associativity to eliminate everything in right of the first empty, and you're golden?
14:38:04 <Peaker> sinelaw, not following that
14:38:40 <merijn> Peaker: Pretty sure "mzero == foo >> mzero" modulo side-effects
14:38:50 <merijn> Peaker: The effects of foo do happen
14:39:08 <Peaker> merijn, "modulu side-effects" isn't very well-defined though?
14:39:23 <sinelaw> Peaker, sorry, confused >> with <>
14:39:47 <Peaker> merijn, associativity plus left-identity law gives you everything you need, I think?
14:39:50 <merijn> Peaker: It's a redundant law if your Monad instance obeys the monad law
14:40:04 <merijn> Anyway, time to go be social
14:42:38 <dkbrk> Can someone help me with this cabal error: http://pastebin.com/bWFJ526G
14:44:57 <Peaker> dkbrk, what does ghc-pkg list Cabal say?
14:46:04 <dkbrk> It says I have broken packages. But this is in a clean sandbox, so that shouldn't matter, should it?
14:46:35 <Peaker> hmm.. I think global packages still come from outside the sandbox? I'm not sure
14:48:03 <zuserm> There was a proposal to add sugar (:: Int) for (\x -> x :: Int). Does anyone remember what the name of the proposal was and if there are current plans to get it into GHC?
14:50:18 <capisce> zuserm: when would it be needed instead of id?
14:50:22 * hackagebot clanki 1.0.5 - Command-line spaced-repetition software  http://hackage.haskell.org/package/clanki-1.0.5 (marcusbuffett)
14:50:53 <greymalkin> To follow up. Yes, monad transformers are what I want.
14:51:15 <zuserm> capisce: you can use it to specialize types and as a proxy
14:52:03 <Ferdirand> mhh, so ListT (Writer blah) is not a proper monad ?
14:53:45 <marchelzo_> How can I compile a .c file to object code with ghc? It says -std=c11 is invalid even though I passed it as "-optc -std=c11".
14:58:03 <capisce> zuserm: you could do (id :: Id Int), with an appropriately defined Id
15:01:41 <monochrom> marchelzo_: I just tried "ghc -v -optc -std=c11 -c b.c" and it was successful. I used -v there to see how gcc is called up, and it did include -std=c11 in gcc's command line. I conclude that your problem is elsewhere.
15:05:05 <marchelzo_> monochrom: it seems I didn't have to pass -c to gcc as well. It's working now. thanks. :)
15:06:14 <Peaker> Ferdirand, it should be, but the ListT in transformers is broken
15:11:58 <arianvp__> .-. I wrote over 300 lines of haskell code today
15:12:05 <arianvp__> this is probably groundbreaking for me .-.
15:12:15 <bitonic> what was that module that provided instances of common IO functions lifted into MonadIO?
15:12:27 <kadoban> Is that a unibrow?
15:12:33 <bitonic> oh, lifted-base
15:12:44 <arianvp__> I see it as someone who is upside down and confused
15:12:51 <bitonic> ahhh no that's with MonadBase
15:14:33 <hexagoxel> arianvp__: task for tomorrow: refactor these 300 lines into more idiommatic 100 lines :D
15:15:14 <arianvp__> instead of --TODO I now use _TODO.  as soon as I do "cabal repl" I get TODO's _with_ types!
15:15:35 <arianvp__> ICalendar.hs:  Found hole ‘_TODO’ with type: DateTime -> Minute
15:16:08 <Black0range> hey guys, noobie question. how do i convert a "Just a" to a?
15:16:20 <arianvp__> BlackOrange.  you could pattern match on it
15:16:44 <malllle> and should
15:16:52 <Peaker> Black0range, case foo of Just x -> ... x is an "a" ... Nothing -> ... need to handle this case too ...
15:16:58 <arianvp__> there is a function    fromJust :: Maybe a -> a
15:17:10 <arianvp__> but it will crash if you give it a Nothing. I tend to avoid partial functions
15:17:19 <timpani> let (Just x) = ja
15:17:30 <malllle> isn't fromJust a perfect codesmell metric? :)
15:18:06 <benzrf> indeed
15:18:08 <arianvp__> I've seen students write stuff like this :   if isJust a then let b  = fromJust a;
15:18:12 <arianvp__> :(
15:18:17 <benzrf> damn
15:18:22 <benzrf> arianvp__: students of what
15:18:40 <arianvp__> benzrf: Introduction to functional programming
15:18:50 <benzrf> arianvp__: are you a teacher or a student in it?
15:18:58 <arianvp__> benzrf: Was a student in it
15:19:02 <benzrf> eek
15:19:11 <benzrf> that line of codesoup
15:19:14 <benzrf> *code
15:19:34 <benzrf> that's like
15:19:41 <Black0range> hmm where do i find this fromJust? :)
15:19:53 <kadoban> Data.Maybe
15:19:57 <arianvp__> BlackOrange: In the  Data.Maybe module if you insist
15:20:08 <benzrf> from that one line of code i can sense
15:20:11 <benzrf> i can sense a great crime
15:20:18 <benzrf> against a student's mind
15:20:37 <arianvp__> Use with caution.  We're not responsible if you end up in a ⊥ of a pit
15:20:44 <benzrf> arianvp__: heh heh heh
15:21:04 <benzrf> i can just feel the years of erosion of independent thought & emphasis of memorization
15:21:07 <benzrf> leading up to the moment
15:21:14 <benzrf> where one would write if isJust a then let b  = fromJust a;
15:21:41 <arianvp__> I guess pattern matching can feel alien when you start?
15:21:41 <benzrf> or, yknow, maybe they just dont care about the class
15:21:47 <arianvp__> or that
15:22:00 <arianvp__> which is a pitty. it's freakin haskell!
15:22:18 <Black0range> regarding that thing why wont this compile? http://lpaste.net/115396
15:22:27 <monochrom> the lack of pattern matching in earlier languages is very poisoning.
15:22:39 <benzrf> lately ive been getting super pretentious about the school system and the mistreatment of math
15:22:47 <benzrf> i hope this isnt TOO cringeworthy down the line
15:23:11 <flyingfisch> why does this give me a parse error? http://lpaste.net/115399
15:23:42 <benzrf> flyingfisch: you need to parenthesize your list match
15:23:47 <monochrom> (ident:irccmd:chan:command:message)
15:24:00 <benzrf> flyingfisch: also you dont need a do there
15:24:04 <monochrom> actually even that is wrong
15:24:11 <benzrf> monochrom: well
15:24:15 <benzrf> monochrom: not necessarily.
15:24:24 <benzrf> monochrom: if that's the result of words, then that's correct
15:24:27 <arianvp__> BlackOrange:  read . head stack should be   (read . head $ stack)
15:24:30 <monochrom> I think you're going for [ident, irccmd, chan, command, message]
15:24:43 <arianvp__> BlackOrange: Also check if you can work away that isJust with pattern matching :)
15:24:44 <benzrf> monochrom: look:
15:24:56 <monochrom> well I also see how "message" is used. it's meant to be String not [String].
15:25:00 <benzrf> monochrom: oh
15:25:01 <benzrf> kk
15:25:06 <Black0range> arianvp_ never mind the stack part. The operator part is complaining
15:25:14 <flyingfisch> nvr
15:25:14 <flyingfisch> forgot parentheses
15:25:47 <Black0range> waaait i'm retarded
15:25:58 <simpson> Relax.
15:26:04 <flyingfisch> benzrf: ok
15:27:31 <benzrf> Black0range: please don't use slurs :(
15:27:40 <arianvp__> BlackOrange:   (fromJust operator) 1 2    :: Int
15:27:49 <arianvp__> but calcRPS takes [Int] as second argument
15:27:57 <Black0range> shhh
15:28:06 <flyingfisch> monochrom: message is a list of strings ;)
15:28:20 <monochrom> then you just need parentheses
15:28:45 <flyingfisch> because I am feeding words ircline into it
15:28:52 <benzrf> monochrom: toldyou!
15:29:33 <flyingfisch> monochrom: which I also said ;)
15:29:36 <ion> black0range: https://www.haskell.org/haskellwiki/Pattern_guard
15:29:42 <flyingfisch> (06:22:53 PM) flyingfisch: nvr
15:29:44 <flyingfisch> (06:22:59 PM) flyingfisch: forgot parentheses
15:30:05 <ion>   | Just x <- operator = …  | otherwise = …
15:30:12 <flyingfisch> ;)
15:31:11 <shachaf> Maybe | = would be reasonable syntax, instead of "otherwise".
15:31:38 <Peaker> Maybe   | True =     is nicer than otherwise
15:32:02 <shachaf> Maybe.
15:32:11 <shachaf> But True is the identity of ",", after all.
15:33:11 <ion> Great butts fart alike. 2013-10-05 00:54:27 +0300  ion     I wouldn’t mind “… | = …” being sugar for “… | True = …” and otherwise not having existed.
15:34:33 <arianvp__> That moment you turned O(n^2) code into O(n*log n)
15:34:35 <arianvp__> \m/
15:34:49 <athan> Is there a common way to handle ambiguous type variables?
15:35:01 <arianvp__> athan: In what sense?
15:35:02 <athan> lol
15:35:17 <athan> arianvp_: I've got this error, here one sec:
15:35:23 * hackagebot adblock2privoxy 1.2.5 - Convert adblock config files to privoxy format  http://hackage.haskell.org/package/adblock2privoxy-1.2.5 (zubr)
15:35:31 <greymalkin> Can I ask for an example of how, in practice, a function gets itself stuck in a monad (applicative functor) (f (a -> b)) -- reading the section on LYAH and it doesn't seem particularly useful to define <*>
15:35:54 <Fuuzetsu> > (,) <$> pure 1 <*> pure 2
15:35:55 <lambdabot>  No instance for (GHC.Show.Show (f0 (a1, a0)))
15:35:55 <lambdabot>    arising from a use of ‘M65791850229046879747469.show_M65791850229046879747...
15:35:55 <lambdabot>  The type variables ‘f0’, ‘a0’, ‘a1’ are ambiguous
15:35:55 <lambdabot>  Note: there are several potential instances:
15:35:55 <lambdabot>    instance [safe] GHC.Show.Show a =>
15:36:10 <Fuuzetsu> eh
15:36:12 <arianvp__> ehh wut
15:36:17 <athan> arianvp_: http://lpaste.net/115400
15:36:18 <Black0range> what does *** Exception: test.hs:(8,1)-(13,48): Non-exhaustive patterns in function calcRPS mean?
15:36:22 <kirill_> > :t pure
15:36:23 <lambdabot>  <hint>:1:1: parse error on input ‘:’
15:36:29 <benzrf> :t pure
15:36:30 <lambdabot> Applicative f => a -> f a
15:36:30 <Fuuzetsu> > pure (,) <$> pure 1 <*> pure 2
15:36:31 <dibblego> greymalkin: remember first, that all haskell functions take one argument, then consider what it would mean to map a function :: (A -> B -> C) over a functor (f) such that you'd have f (B -> C)
15:36:31 <lambdabot>  No instance for (GHC.Show.Show (f0 (b0 -> (a0, b0))))
15:36:31 <lambdabot>    arising from a use of ‘M90008078459939807187511.show_M90008078459939807187...
15:36:31 <lambdabot>  The type variables ‘f0’, ‘a0’, ‘b0’ are ambiguous
15:36:31 <lambdabot>  Note: there are several potential instances:
15:36:32 <lambdabot>    instance [safe] GHC.Show.Show a =>
15:36:32 <arianvp__> BlackOrange: it means you missed a case.  Are you handling the Nothing case?
15:36:37 <Fuuzetsu> ok I have the dumb today
15:36:39 * Fuuzetsu goes away
15:36:45 <benzrf> Fuuzetsu: pleb!
15:37:14 <benzrf> :t Pair
15:37:14 <lambdabot> a -> b -> ZipPair a b 'Both
15:37:16 <benzrf> hm
15:37:36 <Black0range> arianvp__ i would like to believe so yes http://lpaste.net/115396
15:38:05 <arianvp__> an the case that   the second parameter is empty?
15:38:13 <shachaf> Phrases like "stuck in a monad" are most likely going to lead to bad intuition.
15:38:16 <arianvp__> calcRPS [] []  will crash for example
15:38:49 <dibblego> greymalkin: also, what shachaf said is important and true  it is not helpful to think of "being stuck in a monad"
15:39:37 <monochrom> I have an artificial example. [sin, cos, tan] <*> [0.1]
15:39:49 <arianvp__> greymalkin: functions are first class citiztens. we can just box them up in containers
15:40:01 <arianvp__> > [(+1), (+2), (+3)] <*> [4,5,6]
15:40:02 <lambdabot>  [5,6,7,6,7,8,7,8,9]
15:40:20 <arianvp__> monochrom: Great minds think alike. hehe
15:40:39 <Iceland_jack> And great doors think ajar
15:40:54 <monochrom> although, "(++) <$> getLine <*> getLine" which is "((++) <$> getLine) <*> getLine" is more commonly used.
15:41:20 <monochrom> note how the part ((++) <$> getLine) has type IO (String -> String)
15:41:33 <arianvp__> which by the way is the same as
15:41:38 <arianvp__> pure (++) <*> getLine
15:42:19 <arianvp__> just mess around with this stuff in GHCi.
15:42:38 <greymalkin> Okay, I guess my code just spends so much time unboxing before re-boxing that I haven't been able to get into that level of abstraction.
15:42:46 <athan> arianvp__ :( did you see anything with that lpaste?
15:43:15 <shachaf> Words like "unboxing" and "re-boxing" are also probably unhelpful for your intuition. :-)
15:43:15 <arianvp__> athan: Try adding an explicit type-signature
15:43:27 <athan> :S alright I'll give it a go
15:43:30 <athan> thanks :)
15:43:37 * greymalkin weeps.
15:44:18 <benzrf> to be honest
15:44:20 <greymalkin> so... are there any words I *can* use for applicative functors which are not unintuitive?
15:44:22 <benzrf> to be perfectly hones
15:44:44 <benzrf> i've recently come to the conclusion that the categorical definitions of functors and monads are actually the best, intuition wise
15:44:55 <monochrom> do you mean you want a name for <*>? you can call it "ap"
15:45:12 <benzrf> monads-as-functor-monoids is better than any other intuition i've ever had for monads
15:45:33 <monochrom> it is one way to generalize "application", afterall
15:45:35 <arianvp__> I've never had this intuition. lol
15:46:01 <arianvp__> (I do have an intuition about monads. but not as monoids in the category of endofunctors)
15:46:04 <benzrf> arianvp__: join is a monoid operation, of course!
15:46:11 <benzrf> arianvp__: just look at it!
15:46:20 <arianvp__> m x m -> m
15:46:24 <arianvp__> .-. okay fine
15:46:24 <benzrf> indeed!
15:46:39 <athan> monoidal nesting?
15:46:41 <benzrf> but seriously
15:46:46 <athan> (that's how I see functors right now :S)
15:47:10 <benzrf> once you grok monads as monoidal operations on nested "contexts", it all becomes totally clear maan
15:47:12 <arianvp__> athan: I'm not familiar with the library. but maybe add an explicit  type signature to that empty list?
15:47:22 <arianvp__> that's the only thing I can see go wrong there
15:47:40 <athan> arianvp__: It's really nice for sql. Yeah, I'm not too sure. Thank you :)
15:47:52 <athan> lol
15:47:57 <monochrom> it seems pretty common human nature to: whenever you learn a more advanced, abstract, general thing, you think it is the best intuition for a previous, more basic, more concrete thing you learned long ago.
15:48:20 <lautrec> wittgenstein's ladder ^
15:48:30 <arianvp__> benzrf:  But in my head. monoids arent really about flattening nested stuff
15:48:37 <arianvp__> they're about combining adjacent things
15:49:40 <monochrom> when left unchecked, this inevitably leads to: advocating for the education system to teach category theory first, then universal algebra, then rings and fields, then ordered fields, then the complex numbers, then the real numbers, then the rational numbers, then the integers, then finally the natural numbers and how to add.
15:50:03 <arianvp__> bottom up. woohoo
15:50:13 <monochrom> and I forgot to put Cayley numbers there somewhere.
15:50:33 <benzrf> arianvp__: er, no
15:50:40 <benzrf> arianvp__: that's what applicatives are about
15:50:51 <benzrf> arianvp__: applicatives are external join, monads are internal join
15:50:57 <benzrf> :t liftA2 (,)
15:50:58 <lambdabot> Applicative f => f a -> f b -> f (a, b)
15:51:03 <arianvp__> yes in that context. But I mean
15:51:17 <arianvp__> if I have the  Monoid  (Int,+,0)
15:51:46 <benzrf> oh MONOIDS
15:51:50 <benzrf> sorry i read that as monads :\
15:51:58 <benzrf> arianvp__: yes, but they're adjacent in another sense
15:52:06 <benzrf> they're adjacent vertically instead of horizontally
15:52:51 <benzrf> bbiab pie (⊙ω⊙)
15:53:27 <arianvp__> :t pure () ** undefined :: f b
15:53:28 <lambdabot>     Couldn't match type ‘b1’ with ‘()’
15:53:29 <lambdabot>       ‘b1’ is a rigid type variable bound by
15:53:29 <lambdabot>            an expression type signature: f1 b1 at <interactive>:1:1
15:53:54 <arianvp__> > let fa ** fb = liftA2(,)
15:53:55 <lambdabot>  not an expression: ‘let fa ** fb = liftA2(,)’
15:54:37 <arianvp__> oh  pure () is an identity in the sense that   ((),b) == b and  (a,()) == a ?
15:54:47 <jle`> yes
15:55:00 <jle`> there is some juggling you need to do
15:55:11 <jle`> but it's an identity in the spirit of what it's supposed to represent
15:56:01 <monochrom> ** is already taken. think up another symbol
15:56:12 <arianvp__> :t **
15:56:12 <lambdabot> parse error on input ‘**’
15:56:23 <arianvp__> .-.
15:56:26 <lautrec> :t (**)
15:56:27 <lambdabot> Floating a => a -> a -> a
15:56:29 <arianvp__> oh
15:56:38 <lautrec> :)
15:56:55 <arianvp__> > let fa <**> fb = (,) <$> fa <*>> fb
15:56:56 <lambdabot>  not an expression: ‘let fa <**> fb = (,) <$> fa <*>> fb’
15:57:05 <monochrom> try @let
15:57:15 <arianvp__> @let fa <**> b = (,) <$> fa <*> fb
15:57:16 <lambdabot>  .L.hs:181:28:
15:57:16 <lambdabot>      Not in scope: ‘fb’
15:57:16 <lambdabot>      Perhaps you meant one of these:
15:57:16 <lambdabot>        ‘b’ (line 181), ‘fa’ (line 181),
15:57:16 <lambdabot>        ‘f’ (imported from Debug.SimpleReflect)
15:57:20 <arianvp__> ugh
15:57:23 <monochrom> :)
15:57:25 <arianvp__> typing etc.
15:57:50 <lautrec> lol "line 181"
15:59:07 <oldmanmike> Newbie question: Where did my typing go wrong? http://pastebin.com/m3uNfdx1
16:00:30 <shachaf> :t randomRs
16:00:31 <lambdabot> (Random a, RandomGen g) => (a, a) -> g -> [a]
16:00:37 <shachaf> oldmanmike: randomRs can give you all lists of all sorts of things.
16:00:59 <shachaf> Integers, Chars, Bools, etc.
16:01:12 <shachaf> You haven't specified which one you want so GHC doesn't know what to give you.
16:01:21 <benzrf> the thing about Haskellfant
16:01:22 <benzrf> *haskell
16:01:27 <arianvp__> No instance for (Num a0) arising from the literal ‘1’
16:01:29 <arianvp__> wat
16:01:30 <benzrf> the really cool really nice thing about Haskellfant
16:01:33 <benzrf> ugh, haskell!!
16:01:39 <arianvp__> are you on a phone?
16:01:45 <benzrf> no, i press tab compulsively
16:01:54 <Profpatsch> Is \x -> (unlines . lines) x == x the same as (unlines . lines) >>= (==) the same as liftM2 (==) (unlines . lines) id ?
16:02:11 <benzrf> is how the intersection of purity and typedness allow you to do mathematical reasoning about the... "capabilities" of code
16:02:24 <benzrf> like free theorems, informaion theory, stuff
16:02:38 <shachaf> No, the middle one is more confusing.
16:03:11 <arianvp__> I'm trying to combine domain driven design and haskell
16:03:22 <arianvp__> it's nice. types give intents.
16:04:07 <Profpatsch> shachaf: Do they not produce the same result?
16:05:01 <shachaf> They do.
16:05:03 <Profpatsch> I’m just playing around with the reader monad.
16:05:21 <Profpatsch> Of course >>= (==) is just bad code and not really readable.
16:05:47 <arianvp__> I'm reimplementing some old code that used Reader monads for lexical scoping
16:05:51 <arianvp__> it was neat
16:06:00 <arianvp__> but now I'm using catamorphisms and F-algebras .-.
16:06:02 <Profpatsch> The first one would be the one you should use in production.
16:06:19 <arianvp__> But yeh.  whenever I use reader I use the newtype-wrapped version
16:06:27 <arianvp__> unwrapped it's just gonna hurt you
16:06:29 <Profpatsch> arianvp__: It got even more complex? :)
16:06:52 <lautrec> why not the liftM2 one?
16:07:38 <Profpatsch> lautrec: It’s exactly as long as the lambda one. :D
16:08:04 <Profpatsch> So why add another level of abstraction?
16:08:25 <arianvp__> Profpatsch:: nah this approach is nice. I have an algebra for generating machine code, an algebra for interpreting code
16:08:31 <lautrec> fair enough
16:08:32 <arianvp__> the fold stays the same. you just swap out the algebras
16:08:34 <arianvp__> kinda nice
16:09:23 <arianvp__> But yeh. that's for an entirely pure language... :/ dont know how practical it will be once the interpreter needs to do side-effects
16:09:36 <arianvp__> which was easier with just the  RWS monad stack
16:25:06 <Gurkenglas> I now have emacs 24.3.1 running. How do I install haskell-mode?
16:33:31 <marchelzo_> Gurkenglas: Look up marmalade or MELPA, install one of them, M-x list-packages, C-s haskell-mode, i x
16:44:25 <Gurkenglas> https://github.com/haskell/haskell-mode said package.el came with emacs, how come those are needed?
16:45:16 <dkbrk> gurkenglas: you need to set the package repository in your .emacs
16:46:13 <dkbrk> melpa should get you started: http://melpa.org/#/getting-started
16:47:14 <Gurkenglas> Where is my .emacs file and why is nothing before the .?
16:48:03 <indiagreen> usually it's ~/.emacs
16:48:10 <indiagreen> the dot means it's hidden
16:48:31 <Gurkenglas> ~ means the home directory in linux, right? Where is that on windows?
16:49:24 <dkbrk> http://stackoverflow.com/questions/189490/where-can-i-find-my-emacs-file-for-emacs-running-on-windows
16:49:29 <skynet> hi
16:49:53 <Guest15107> I need help please
16:49:58 <pikhq_> Gurkenglas: The analogous dir is %UserProfile% on Windows.
16:50:02 * Gurkenglas slaps himself for forgetting to google
16:50:28 <indiagreen> Guest15107: “don't ask to ask, just ask”
16:50:41 <indiagreen> what do you need help with?
16:50:51 <Guest15107> yes, I'll do a pastebin with my issue
16:51:06 <FireFly> Paste on lpaste (see topic)
16:51:12 <indiagreen> @where lpaste
16:51:12 <lambdabot> http://lpaste.net/
16:52:33 <Guest15107> http://pastebin.com/6Dk53vD2
16:53:09 <dkbrk> you need a deriving (Show)
16:53:49 <Guest15107> to print, yes
16:53:58 <Guest15107> to use* print, sorry
16:54:29 <dkbrk> data Direccion = N | S | E | O deriving (Show)
16:55:26 * hackagebot github 0.13.1 - Access to the Github API, v3.  http://hackage.haskell.org/package/github-0.13.1 (cesar_nataren)
16:55:54 <Gurkenglas> Ah. "C-x C-f ~/.emacs". That should have been easier to find out x)
16:56:17 <Guest15107> added, but it returns another one
16:56:20 <Guest15107> http://lpaste.net/115404
16:57:39 <Gurkenglas> And the .emacs file was in %appdata%.
16:58:20 <monochrom> hmm, emacs and windows :)
16:58:53 <marchelzo_> Gurkenglas: yes. it's annoying
16:59:10 <marchelzo_> I don't know why ~ doesn't expand to %UserProfile%
16:59:23 <Gurkenglas> I don't know why you all feeded my fear of impending 20-year old GUI. This feels pretty straightforward by clicking through the menu, and remembering the shortcuts from there.
16:59:28 <Gurkenglas> *fed
16:59:44 <dkbrk> Guest15107: I think you'll have to manually create an instance of Show for (Robot -> Punto)
17:00:10 <marchelzo_> emacs is decent in that regard (letting you click on most things)
17:00:22 <ion> dkbrk: You mean (IRadar a)?
17:00:35 <Guest15107> dkbrk, where can I learn to do that? :P
17:01:02 <ion> What’s the definition of IRadar?
17:01:24 <Guest15107> An Instruction
17:01:50 <marchelzo_> Guest15107: instance show Foo where { show x = ... }
17:02:10 <dkbrk> Guest15107: read the chater in learn you a haskell http://learnyouahaskell.com/making-our-own-types-and-typeclasses
17:02:16 <marchelzo_> show needs to take something of the type for which you're defining a Show instance and return a string
17:03:01 <Guest15107> yes, I can't do anything with IRadar or Radar
17:03:19 <Guest15107> I'll show you some examples of a program loaded to R1
17:04:12 <Guest15107> http://lpaste.net/115405
17:04:30 <monochrom> Who designed the types Programa and Instr?
17:05:02 <Guest15107> The damn professor, monochrom
17:05:22 <monochrom> ok. is it super important that you can print them?
17:05:28 <Guest15107> (and I'm not sure of that)
17:06:30 <Guest15107> monochrom, I have to defend my code (like some kind of thesis, I think)
17:06:59 <tempay> > pure 1
17:07:01 <lambdabot>  No instance for (GHC.Show.Show (f0 a0))
17:07:01 <lambdabot>    arising from a use of ‘M88791381966346707798877.show_M88791381966346707798...
17:07:01 <lambdabot>  The type variables ‘f0’, ‘a0’ are ambiguous
17:07:01 <lambdabot>  Note: there are several potential instances:
17:07:01 <lambdabot>    instance [safe] GHC.Show.Show a =>
17:07:08 <Guest15107> and yes, I have to show them that my code works and the only way is to use print
17:07:18 <tempay> weird, that just prints 1 in my ghci..
17:08:52 <benzrf> tempay: that's because it defaults to IO
17:08:58 <benzrf> tempay: then it runs the IO action because ghci is lame
17:09:13 <tempay> benzrf: oooh. thanks
17:09:30 <Hafydd> Is that really a consequence of ghci being lame?
17:10:10 <dkbrk> I think it's more that ghci does some magic so that it's more DWIM
17:10:27 * hackagebot simple-smt 0.3.0 - A simple way to interact with an SMT solver process.  http://hackage.haskell.org/package/simple-smt-0.3.0 (IavorDiatchki)
17:14:05 <carter> darthdeus: ping
17:14:53 <benzrf> DWIM is garbage
17:16:20 <Guest15107> the error appears when I add this: deriving (Show) here: Radar (Robot->Punto)
17:28:52 <tempay> zip = liftA2 (,)
17:29:06 <tempay> why did i not know about this language before a month ago
17:29:10 <monochrom> @type liftA2 (,)
17:29:11 <lambdabot> Applicative f => f a -> f b -> f (a, b)
17:29:20 <monochrom> there is a problem.
17:29:36 <monochrom> > zip ['a', 'b'] [True, False]
17:29:37 <lambdabot>  [('a',True),('b',False)]
17:29:43 <monochrom> this is not going to be:
17:29:54 <monochrom> > liftA2 (,) ['a', 'b'] [True, False]
17:29:55 <lambdabot>  [('a',True),('a',False),('b',True),('b',False)]
17:31:05 <benzrf> tempay: zip = runZipList $ liftA2 (,) <$> ZipList <*> ZipList
17:31:06 <benzrf> :p
17:31:07 <benzrf> er
17:31:13 <benzrf> tempay: zip = runZipList . (liftA2 (,) <$> ZipList <*> ZipList)
17:31:28 <monochrom> oh, that is more true
17:33:22 <monochrom> @type ZipList
17:33:23 <lambdabot> [a] -> ZipList a
17:33:33 <monochrom> @type runZipList . (liftA2 (,) <$> ZipList <*> ZipList)
17:33:34 <lambdabot>     Not in scope: ‘runZipList’
17:33:34 <lambdabot>     Perhaps you meant ‘getZipList’ (imported from Control.Applicative)
17:33:43 <monochrom> @type (liftA2 (,) <$> ZipList <*> ZipList)
17:33:44 <lambdabot> [b] -> ZipList (b, b)
17:34:01 <monochrom> that may be not what you had in mind :)
17:34:22 <Gurkenglas> > (liftA2 (,) <$> ZipList <*> ZipList) [2,5,3]
17:34:23 <lambdabot>  ZipList {getZipList = [(2,2),(5,5),(3,3)]}
17:36:22 <jle`> perhaps the point was that liftA2 (,) *could* have been zip ;D
17:36:37 <jle`> had the language design decided to go with the other applicative as the default
17:36:55 <jle`> in another universe with very badly planned instances, this could have been the case
17:37:00 <dkbrk> It's a good example of the type not uniquely identifying the semantics
17:38:05 <monochrom> I like alternative universes
17:38:17 <trap_exit> imagine an universe
17:38:18 <jle`> all noncommutative applicative instances also have "reversed" instances too
17:38:20 <trap_exit> wher ehaskell was invented instead of C
17:38:33 <jle`> like State, IO, etc.
17:38:35 <trap_exit> imagine an universe where P = NP
17:38:42 <StoneCypher> no
17:39:51 <jle`> i don't have to, i already live in one
17:40:14 <jle`> :D
17:40:50 <trap_exit> if P = NP, it's likely we would have already found a proof for it
17:40:53 <trap_exit> therefore, P != NP
17:42:46 <StoneCypher> trap_exit: yeah, that's also why there's no cure for cancer, why black swans don't exist, and why fermat's little theorem was impossible until recently
17:43:04 <cecietcela> Proof that P = NP: Let P = NP. Proof is trivial.
17:43:07 <trap_exit> StoneCypher++
17:43:24 <trap_exit> cecietcela--
17:43:25 <darthdeus> carter: huh? sorry i'm half afk
17:43:39 <cecietcela> #yolo
17:43:43 <carter> darthdeus: whats you ghc --info stuff
17:43:53 <carter> darthdeus: saw the cabal ticket
17:43:58 <darthdeus> carter: which one?
17:44:01 <carter> i use gcc for cpp and clang for cc
17:44:06 <carter> the cabal mac one
17:44:08 <carter> that i created
17:44:19 <darthdeus> can you link? it's 3am here and i'm super confused :P
17:44:31 <carter> darthdeus: you commented on github in the past 24 hours
17:44:50 <trap_exit> if it's 3am
17:44:50 <carter> https://github.com/haskell/cabal/issues/1790#issuecomment-64932688
17:44:52 <trap_exit> the solution is "sleep"
17:44:55 <carter> that too
17:45:14 <darthdeus> oh that one
17:45:21 <darthdeus> yeah i fixed that by simply using http://ghcformacosx.github.io/
17:45:28 * hackagebot Haggressive 0.1.0.0 - Aggression analysis for Tweets on Twitter  http://hackage.haskell.org/package/Haggressive-0.1.0.0 (Pold87)
17:45:31 <darthdeus> which doesn't require me to compile anything and "just works (tm)"
17:47:33 <carter> darthdeus:  thats what i suggest folks do :)
17:50:28 * hackagebot Haggressive 0.1.0.1 - Aggression analysis for Tweets on Twitter  http://hackage.haskell.org/package/Haggressive-0.1.0.1 (Pold87)
17:53:57 <joshsz> ok, maybe esoteric, anyone know where `shouldBe` gets defined in Hspec? I've grepped its source and can't find its definition anywhere
17:54:36 <indiagreen> http://hackage.haskell.org/package/hspec-expectations-0.6.1/docs/src/Test-Hspec-Expectations.html#shouldBe
17:54:54 <indiagreen> which is an alias for
17:54:55 <indiagreen> http://hackage.haskell.org/package/HUnit-1.2.5.2/docs/Test-HUnit-Base.html#v:-64--63--61-
17:55:01 <darthdeus> carter: initially i tried to compile GHc because i was too lazy to setup emacs paths for the ghc app
17:55:06 <darthdeus> but now i guess that laziness is gone :D
17:55:10 <joshsz> indiagreen: well that was quick, thanks!
17:55:22 <indiagreen> next time you can use Hayoo
17:55:28 * hackagebot Haggressive 0.1.0.2 - Aggression analysis for Tweets on Twitter  http://hackage.haskell.org/package/Haggressive-0.1.0.2 (Pold87)
17:55:36 <indiagreen> I just hayoo-ed “shouldBe”
17:55:58 <joshsz> hayoo?
17:56:03 <indiagreen> @where hayoo
17:56:03 <lambdabot> http://holumbus.fh-wedel.de/hayoo/hayoo.html – See also Hoogle: http://haskell.org/hoogle
17:56:11 <indiagreen> it's a search engine for functions
17:56:21 <indiagreen> Hoogle is better when you're searching by type
17:56:27 <joshsz> aha, cool, I've used hoogle, just not hayoo. Thanks!
17:56:30 <indiagreen> Hayoo – when you're searching by name or module
17:56:38 <indiagreen> I recommend adding a search shortcut to the browser
17:57:07 <joshsz> yeah good idea
17:58:31 <Guest15107> monochrom, I don't need to print everything. Just the result of my last function that returns the winner (R1 or R2)
17:59:35 <monochrom> then you only need the Robot type to have "deriving Show". you don't need to print anything else.
17:59:46 <Guest15107> yup :)
18:00:05 <Guest15107> well I'll try the entire script. I hope it works :S
18:00:19 <Guest15107> wanna see it? Is a "game"
18:00:34 <monochrom> no
18:00:40 <Guest15107> o'right
18:00:55 <Guest15107> however, thanks for your help
18:05:27 <Welkin> the only problem with hoogle is that it only includes whatever comes with the haskell platform
18:05:36 <Welkin> so I cannot search, for example, Parsec functions
18:05:59 <indiagreen> Welkin: http://fpcomplete.com/hoogle
18:06:20 <indiagreen> searches all of Stackage, I think
18:06:48 <indiagreen> also you can set up local Hoogle, of course
18:06:52 <geekosaur> un, platform contains parsec. standard hoogle only searches things that come with *ghc*
18:07:03 <Welkin> I haven't done that yet
18:07:05 <Welkin> okay
18:07:21 <Welkin> It gets tiresome manually searching for functions in my local documentation
18:07:27 <Welkin> guessing which module they might be in
18:07:48 <geekosaur> @where hayoo
18:07:48 <lambdabot> http://holumbus.fh-wedel.de/hayoo/hayoo.html – See also Hoogle: http://haskell.org/hoogle
18:08:06 <geekosaur> hmmm
18:09:02 <Welkin> I haven't used hayoo very much
18:09:03 <geekosaur> @where+ hayoo http://hayoo.fh-wedel.de/ -- See also Hoogle: http://haskell.org/hoogle http://fpcomplete.com/hoogle
18:09:04 <lambdabot> Okay.
18:09:08 <Welkin> only when hoogle was down
18:09:13 <systemfault> The haskell search engine "names" are so damn lame :/ (But so damn useful)
18:09:15 <geekosaur> thought I updated that once
18:09:21 <Welkin> I didn't know hayoo was more extensive
18:09:21 <geekosaur> @where hoogle
18:09:22 <lambdabot> http://haskell.org/hoogle – See also Hayoo, which searches more packages: http://holumbus.fh-wedel.de/hayoo/hayoo.html
18:10:17 <geekosaur> @where+ hoogle http://haskell.org/hoogle http://fpcomplete.com/hoogle – See also Hayoo, which searches more packages: http://hayoo.fh-wedel.de/
18:10:17 <lambdabot> I will remember.
18:10:29 * hackagebot Haggressive 0.1.0.4 - Aggression analysis for Tweets on Twitter  http://hackage.haskell.org/package/Haggressive-0.1.0.4 (Pold87)
18:16:43 <joshsz> is there a way in hunit to check a type expectation?
18:17:08 <joshsz> or hspec, since that's what I'm actually using
18:19:11 <indiagreen> can you elaborate?
18:20:18 <superfunc> Does anyone know where blaze-html will look for css files ?
18:20:50 <jle`> systemfault: lame?!! :O
18:23:26 <joshsz> indiagreen: I think I might have found the path, using Selector in hspec as mentioned in http://hspec.github.io/expectations.html to match.. I'm trying to test Parsec and assert that I return a Left ParseError from a test
18:24:02 <joshsz> if anyone knows of a good open-source example of testing parsec though that would be awesome :)
18:24:14 <joshsz> rather, testing code that uses parsec
18:24:56 <indiagreen> ah, but it's not a type expectation, it's a... constructor expectation, I guess
18:25:03 <indiagreen> so you can just say “xs `shouldSatisfy` isLeft”
18:25:14 <joshsz> yeah, oh yeah that's true
18:25:16 <indiagreen> (isLeft is in Data.Either starting from GHC 7.8)
18:25:59 <joshsz> right yeah that's much simpler, thanks
18:30:14 <indiagreen> joshsz: if you have lots of parser testing to do, you can define your own combinators to make your life easier
18:30:15 <gcganley> has anyone used scotty, and what has been your experience with it
18:30:21 <indiagreen> see http://hackage.haskell.org/package/hspec-attoparsec/docs/Test-Hspec-Attoparsec.html
18:30:40 <joshsz> indiagreen: yeah, I was looking at that, I'm sure I'll get there, I'm still pretty much a noob ;)
18:30:44 <indiagreen> this one is for attoparsec, but you can do the same thing for parsec, it should be easy
18:31:57 <joshsz> I've got this crazy side-project to try to write a ruby vm in haskell.. mostly because of the awesome name 'raskell' ;) but it's going to take knowing parsec inside and out because ruby is notoriously insane to parse
18:33:10 <indiagreen> just in case, you know that there's also a Haskell interpreter for iOS called “Raskell”, right
18:33:26 <joshsz> ha, did not, oh well :)
18:33:38 <indiagreen> I really hope I haven't killed your motivation now
18:33:59 <joshsz> nah, the name is fun but mostly I want to do the project
18:34:13 <gcganley> joshsz: i would guess you know ruby well?
18:34:31 <joshsz> there's another ruby/haskell raskell that is trying to do a ffi thing I think but that didn't deter me either :)
18:34:40 <joshsz> gcganley: yeah I'm a rubyist by day
18:35:18 <gcganley> joshsz: my gf's brother wants to learn ruby. i am a haskeller (obviosly) what tutorials should i read to get the basics of ruby
18:35:57 <Fuuzetsu> why not git him to learn Haskell instead?
18:36:01 <Fuuzetsu> get him*
18:36:10 <jle`> there's the pickaxe
18:36:18 <jle`> that's how i learned ruby all those years ago
18:36:31 <joshsz> gcganley: hm, good question, most of the tutorials I point people to are for new programmers, like http://ruby.railstutorial.org/ or http://railsforzombies.org/...
18:36:48 <gcganley> Fuuzetsu: he wants to edit a specific code base. i may teach him haskell...
18:36:54 <joshsz> The pickaxe is good but it's a little dry. I learned on the poignant guide http://mislav.uniqpath.com/poignant-guide/
18:37:22 <jle`> poignant was a bit too poignant for me but i guess that's a matter of taste
18:37:28 <systemfault> jle`: You could write another one and call it.. "Hing" or "Hask Hask Go!" :P
18:37:28 <joshsz> hehe
18:37:49 <jle`> Hask Jeeves
18:38:33 <systemfault> Haha
18:39:55 <joshsz> gcganley: yeah the pickaxe is probably the best for current programmers https://pragprog.com/book/ruby/programming-ruby
18:42:11 <Welkin> is there a function like `lines` that splits at a specified character?
18:42:56 <indiagreen> yes, in split package which is in the platform
18:43:00 <indiagreen> @hackage split
18:43:00 <lambdabot> http://hackage.haskell.org/package/split
18:43:39 <indiagreen> in particular, you can use linesBy
18:44:19 <Welkin> thank you
18:45:17 <joshsz> gcganley: oh and you know, I've been learning haskell using exercism, it's a good idea to use that for ruby too, it helps you get the language's style
18:45:24 <joshsz> http://exercism.io/
18:48:51 <fuzzyhorns> im confused that https://www.haskell.org/haskellwiki/Abstract_data_type says Integer and Float are abstract data types, but http://functionspace.org/topic/253/What-is-the-difference-between-abstract-data-type-and-concrete-data-- says they are concrete data types
18:51:05 <geekosaur> I think they're using different definitions of abstract
18:51:23 <benzrf> fuzzyhorns: i've never heard of this distinction
18:51:46 <fuzzyhorns> benzrf: i generally trust haskellwiki
18:52:16 <fuzzyhorns> which has a stub on concrete data type: https://www.haskell.org/haskellwiki/Concrete_data_type
18:52:19 <geekosaur> specifically: the haskellwiki page uses abstract to mean the actual implementation is hidden, the functionspace page uses it to mean that the type can be constructed from other types. terminology often varies...
18:52:41 <fuzzyhorns> language is so ambiguous, annoying lol
18:54:01 <fuzzyhorns> "Arrays, lists and trees are concrete data types whereas stacks, queues and heaps are abstract data types."
18:55:46 <Welkin> `concat . intersperse "; " . linesBy (== '/')` is certainly useful
18:59:38 <zbod> hello. what is the most stable Haskell module to work with IRC?
18:59:53 <Fuuzetsu> good question
19:01:51 <solirc> zbod: I used `irc` before.  Can't say it's stable or complete...
19:01:57 <solirc> zbod: https://github.com/wimdu/alonzo
19:02:49 <Welkin> irc game bots are the best
19:04:54 <Taneb> zbod, there is also http://hackage.haskell.org/package/irc-conduit
19:05:09 <Taneb> Which has irc as a dependency, it seems
19:12:33 <joshsz> heh.. actually there's no yacc to parsec translator is there? ;)
19:13:14 <geekosaur> that would be difficult since real yacc parsers include C code
19:13:20 <Clint> joshsz: happy is closer
19:13:56 <joshsz> geekosaur: yeah ;)
19:14:01 <joshsz> Clint: interesting, I'll look, thanks!
19:14:51 <geekosaur> and yes, happy is a parser generator similar to yacc, rather than a parser combinator library
19:16:47 <joshsz> ruby's parse.y is about 12k lines, that's no big deal ;)
19:43:57 <benzrf> jesus fcking christiansen`
19:43:58 <benzrf> *christ
19:44:02 <benzrf> and i thought the perl6 grammar was ba
19:44:03 <benzrf> d
19:45:23 <Welkin> benzrf: you saw php?
19:45:29 <benzrf> oh, this is in basically C
19:45:31 <benzrf> while that's perl
19:45:46 <benzrf> ok it's probably worse if it's in that much more expressive a language and it takes half as many lines
19:45:57 <Welkin> jesus fucking christiansen` <-- I'll have to remember that one
19:46:12 <NemesisD> I've been having some problems with haskell-mode. i can reload the process just fine but my prompt in interactive haskell doesn't let me enter anything. anyone else seen that happen?
19:46:12 <benzrf> im a compulsive tab completer x_x
19:47:18 <benzrf> >mfw an html document that's partially documentation explaining haskell's grammar is nearly 10x shorter than the perl6 grammar
19:47:30 <benzrf> well. to be fair, the "perl6 grammar" i'm talking about is really code
19:48:20 <Welkin> the Main module does not need to be called Main (and thus Main.hs), does it?
19:48:35 <Welkin> I have always used that setup, but now I need something more flexible
19:48:45 <Fuuzetsu> It needs to be called Main but doesn't need to be called Main.hs
19:49:56 <geekosaur> there is -main-is
19:51:40 <monochrom> note that "module Main" is not the same as omitting it. if you want to be explicit, "module Main(main)"
19:52:30 <monochrom> this is because "module Main" leads to dead code you won't really use, they are still generated because you export everything.
19:52:52 <Denommus> hm, anywhere knows how I could desugar the arrow syntax?
19:54:39 <Denommus> ah, arrowp
19:57:22 <Denommus> damn, can't install arrowp :-/
19:58:28 <dmwit> Denommus: -ddump-splices or something like that
19:58:44 <dmwit> Denommus: Browse through GHC's manual entries on the -ddump flags and I'm sure you'll find the right one if that's not it.
20:00:37 <Welkin> Parsec can only work with String, right?
20:00:51 <Welkin> if I want to work with Text or ByteString I need to use Attoparsec?
20:01:20 <Welkin> I cannot tell if it is slow or fast, but it parses a 111k entry dictionary into json in about 5-7 seconds
20:01:27 <Welkin> using String
20:02:47 <Denommus> dmwit: what if I'm compiling with cabal?
20:05:45 <mauke> Welkin: no
20:06:30 <mauke> :t Text.Parsec.Prim.runParser
20:06:30 <lambdabot> Text.Parsec.Prim.Stream s Identity t => Text.Parsec.Prim.Parsec s u a -> u -> Text.Parsec.Pos.SourceName -> s -> Either Text.Parsec.Error.ParseError a
20:07:17 <Welkin> heh
20:07:20 <Welkin> I should have noticed
20:07:27 <Welkin> I've been staring at the documentation all night
20:07:47 <Welkin> would using Text over String be significantly faster?
20:08:02 <bitemyapp> Welkin: usually is. Not always, but usually.
20:08:09 <Welkin> also, is there any difference between HashMap and Map besides the time complexity on searches/insertions?
20:08:40 <Welkin> is Map is O(log n) and HashMap is O(1)?
20:08:53 <benzrf> Welkin: isn't it more like
20:08:55 <benzrf> O(1ish)
20:09:08 <Welkin> Map seems fast enough for me though
20:09:26 <Welkin> when is it time to switch from a naive version of a data structure to a faster one?
20:10:18 <Welkin> also, what is the downside of using on over the other (i.e. HashMap vs Map)?
20:10:22 <Welkin> one over*
20:11:22 <simpson> HashMap requires Hashable, not just Ord.
20:11:32 <simpson> log n is smaller than you think, BTW!
20:11:44 <Welkin> yes, log n is good
20:13:20 <benzrf> log n is nuts
20:13:25 <Welkin> my dataset is 111k, so log 111k is ~16.7
20:13:49 <benzrf> logarithmic growth is crazy small
20:17:13 <systemfault> What is the usual "conf" file format for haskell programs?
20:17:59 <Clint> there isn't one
20:21:30 <flyingfisch> well, it's probably horribly coded, but I managed to get a working IRC bot that responds to "test"
20:21:31 <flyingfisch> https://github.com/flyingfisch/haskell-fischbot
20:21:53 <bitemyapp> flyingfisch: I actually needed an example of an IRC bot, so this is good. Thank you.
20:22:11 <bitemyapp> flyingfisch: also you should add a .gitignore so you don't check in compiler artifacts.
20:22:25 <bitemyapp> https://github.com/github/gitignore/blob/master/Haskell.gitignore is good
20:22:46 <flyingfisch> bitemyapp: note that this is the first thing I have ever coded in Haskell, I don't even know what a Monad is yet ;)
20:23:02 <flyingfisch> bitemyapp: ok thank you will add it
20:23:48 <zenguine> is there a reason why there isn't an instance (Monoid m) => Alternative (Const m) in the standard libraries?
20:25:38 <shachaf> It seems like a pretty odd instance.
20:26:10 <zenguine> seems like it could do the same thing as the applicative instance
20:26:17 <zenguine> maybe there are laws that it wouldn't follow?
20:26:18 <flyingfisch> bitemyapp: ok, artifacts should be gone now ;)
20:26:24 <zenguine> but the laws for alternative seem shaky anyways
20:26:35 <zenguine> I guess I don't really understand its essence
20:26:36 <flyingfisch> woops one stayed
20:26:40 <shachaf> Yes, there aren't really laws connecting Alternative to Applicative.
20:26:47 <zenguine> like.. some and many don't really seem to do anythig useful outside of parsers
20:26:53 <zenguine> they just loop on most instances it seems
20:27:09 <shachaf> Yes.
20:28:32 <capncanuck> is there a smart way of writting `isFilled`? with Control.Lens? http://pastebin.com/e5zyiwB4
20:28:36 <capncanuck> smarter*
20:29:26 <capncanuck> asking b/c I might have to add more fields to Options
20:29:34 <shachaf> There's the question of whether you should be writing this function in the first place.
20:30:05 <shachaf> If all your fields are :: Maybe Int, you could make a traversal for all the fields and maybe use that somehow.
20:30:11 <zenguine> isFilled (Options (Just _) (Just _) (Just _)) = True; isFilled _ = False
20:30:21 <zenguine> but I agree with shachaf about whether its worth writing in the first place
20:30:49 <shachaf> Bool is somewhat suspicious.
20:31:05 <capncanuck> how do i make a traversal?
20:31:24 <zenguine> you should be able to derive it
20:31:32 <shachaf> zenguine: Really? How?
20:31:50 <zenguine> {-# Language DeriveTraversable #-}
20:31:52 <zenguine> I think
20:31:57 <zenguine> well
20:32:01 <shachaf> You can't make that type Traversable
20:32:04 <zenguine> your data type would need to be parametized
20:32:17 <zenguine> yeah
20:32:18 <shachaf> You can make a traversal (e.g. foo f (Options x y z) = Options <$> f x <*> f y <*> f z) but that's not the same thing.
20:34:32 <lwm> what do people use to do string formatting besides '++'
20:34:44 <capncanuck> Text.Printf
20:34:53 <benzrf> capncanuck: arent libraries more common >.>
20:35:03 <benzrf> er, *other libraries
20:35:19 <capncanuck> idk, that's what I use
20:35:45 <marchelzo_> good 'ol printf
20:35:53 <marchelzo_> s/'ol/ol'/
20:38:31 <zenguine> I like Text.PrettyPrint
20:38:38 <zenguine> if you need more
20:39:53 <lwm> cool, I am checking out p
20:39:59 <lwm> Printf*
20:53:28 <Welkin> hm
20:53:50 <Welkin> How can I find the intersection of a Map and a Set and produce those values as a Map?
20:54:18 <Welkin> I'm looking for Set a -> Map a b-> Map a b
21:01:49 <putputlaw> Welkin, you're probably looking for some sort of "filter by keys" function: (a -> Bool) -> Map a b -> Map a b
21:02:08 <ReinH> Welkin: Data.Map.intersection could probably be used
21:04:10 <Welkin> I overlooked intersection
21:04:17 <Welkin> but perhaps I could convert my Set to a Map?
21:04:33 <Welkin> the values would be () though
21:04:51 <putputlaw> Data.Map.filter does the job, no?
21:06:30 <putputlaw> if I understand your problem correctly, you just have to think a little about what predicate (a -> Bool) to use
21:07:06 <Welkin> ah
21:07:09 <Welkin> that sounds good
21:07:20 <Welkin> there is also Mf.fromSet
21:08:17 <Welkin> M.fromSet
21:23:14 <crocket> Is it possible to use haskell libraries in python or other languages?
21:23:47 <Welkin> crocket: why would you do that?
21:24:00 <crocket> Welkin, Interoperation
21:24:02 <crocket> Code reuse
21:24:05 <Welkin> you can certainly execute a binary from python
21:24:37 <crocket> I'm sad haskell is not used to write system libraries and kernels.
21:24:57 <geekosaur> https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/ffi-ghc.html#ffi-library
21:25:19 <geekosaur> "kernels" --- consider garbage collection
21:25:22 <kadoban> crocket: Most languages, including haskell and python have an interface to C. You can write a small shim and hook haskell to python that way.
21:25:43 <tac_> I don't think Haskell brings much to low-level code
21:26:14 <crocket> Is there a functional language for low-level code?
21:26:20 <cosmicexplorer> lisp all the way down
21:26:22 <tac_> There are lots of research-grade languages
21:26:59 <crocket> Is any of them becoming useful for building things?
21:27:07 <Javran> hmm, I feed a haskell program with tons of command line arguments, and it causes this error "runghc: /usr/bin/ghc: rawSystem: runInteractiveProcess: exec: resource exhausted (Argument list too long)", not sure what could have gone wrong?
21:27:32 <crocket> Javran, Did you give too many arguments?
21:27:45 <danclien> crocket: There's Mirage OS which is completely written in Ocaml. – openmirage.org
21:27:46 <tac_> I'm not really aware of any successful low level languages based on a type theory
21:28:19 <tac_> The book Advanced Types and Programming Languages describes a bunch of theoretical languages designed for various low-level tasks
21:28:20 <Javran> crocket: yes, at least 1000 I think
21:28:22 <simpson> You can't avoid your page of assembly which boots the machine.
21:28:40 <danclien> (For some value of "completely".)
21:28:43 <Javran> crocket: piped from a "find" command
21:28:48 <simpson> You *can* avoid the small pile of statically-linked C, but only by picking some other language.
21:28:51 <crocket> Javran, too many arguments.
21:29:00 <kadoban> Javran: It sounds like you diagnosed your own problem... Use some other way to input that data instead of command line arguments?
21:29:22 <simpson> Javran: Instead of xargs, use find's -exec
21:29:26 <Javran> sure, I think make a file path list beforehand would do
21:29:35 <crocket> Javran, Why don't you pipe serialized data into standard input?
21:29:41 <crocket> Or a network socket?
21:30:22 <Javran> simpson: but I need to accumulate some info from each file
21:30:39 <simpson> Javran: Then read a file list from stdin, and pipe directly from find?
21:31:15 <simpson> Javran: (Note that if you can batch, and you just don't want to incant once per file, GNU find also has -exec + which will batch optimally while avoiding the arg limit.)
21:32:12 <Javran> it looks like "runghc foo.hs `find <something>`"
21:32:39 <Javran> or "find <something> | xargs runghc foo.hs"
21:33:24 <Javran> I wanna collect some info from each file, and merge them together, not perform the same action on all the files
21:34:10 <crocket> hm....
21:34:12 <crocket> Ocaml?
21:34:18 <crocket> Is it good for parallel programming?
21:37:21 <Javran> simpson: ah, I see what you meant
21:38:34 <Javran> simpson: "-exec ;" and "-exec {} +" have totally different semantics
21:45:33 <crocket> Well...
21:45:45 <crocket> Mirage OS is really a library OS that runs on Xen.
21:45:51 <crocket> not really useful for users.
21:48:06 <simpson> Javran: Right.
21:50:38 * hackagebot markdown 0.1.13 - Convert Markdown to HTML, with XSS protection  http://hackage.haskell.org/package/markdown-0.1.13 (MichaelSnoyman)
22:04:38 <ab9rf> i saw an article a while back on a haskell-based OS of sorts
22:05:00 <Welkin> there is one I believe
22:05:17 <Welkin> https://www.haskell.org/haskellwiki/Applications_and_libraries/Operating_system
22:05:19 <Welkin> House?
22:05:43 <ab9rf> don't remember the specifics, it was something i glanced at one morning while i was sick
22:05:55 <ab9rf> might have been delusional at the time
22:07:28 <liyang> ab9rf: http://www.metasepi.org/ had been attempting to implement BSD drivers using (A)JHC, but they're switching to ATS now.
22:10:32 <ab9rf> house doesn't look familiar so that wasn't it
22:16:18 <ab9rf> i can never remember anything i read when i'm sick
22:16:43 <Welkin> why not?
22:17:11 <Welkin> did it fry your brain?
22:17:18 <Welkin> were you abducted by malicious aliens?
22:26:00 * hackagebot markdown 0.1.13 - Convert Markdown to HTML, with XSS protection  http://hackage.haskell.org/package/markdown-0.1.13 (MichaelSnoyman)
22:26:00 * hackagebot minioperational 0.4.8.1 - fast and simple operational monad  http://hackage.haskell.org/package/minioperational-0.4.8.1 (FumiakiKinoshita)
22:33:07 <solatis> hmmm a haskell operating system.. could we convince microsoft to do that for their next generation OS?
22:33:39 <solatis> of all the "big OS vendors" out there, they have the biggest stake in haskell anyway
22:34:22 <davidthomas> solatis: Seems... unlikely :-P
22:34:37 <solatis> unlikely is an optimistic assertion i think
22:37:18 <wei2912> solatis: haha
22:43:27 <haasn> solatis: Given Microsoft's notorious history concerning OS design I don't think it would be very well received either way :p
22:45:48 <crocket> huh
22:45:55 <crocket> OS design
22:46:30 <crocket> Does haskell provide parallelism?
22:46:36 <dmj`> yes
22:46:46 <crocket> Does it provide concurrency?
22:46:50 <dmj`> yes
22:46:50 <crocket> Does it provide lightweight threads?
22:46:52 <dmj`> yes
22:46:56 <crocket> yes
22:47:12 <putputlaw> does it blend?
22:47:14 <systemfault> Does it provide an infinite supply of extra-cheese pizza? :/
22:47:16 <dmj`> yes
22:47:17 <dmj`> yes
22:47:27 <code_pod> Hungry
22:48:00 <dmj`> crocket: http://chimera.labs.oreilly.com/books/1230000000929/index.html
22:48:32 <crocket> dmj`, Why do I need a separate book for that?
22:49:46 <dmj`> crocket: you don't
22:49:53 <dmj`> crocket: but the author wrote the GHC runtime system, it's a very good resource.
22:50:31 <crocket> Is haskell good for GUI programming?
22:50:35 <crocket> Or web programming?
22:50:43 <dmj`> it's very good for web programming
22:51:55 <solatis> i'd say backend-programming rather than frontend
22:52:13 <solatis> i wouldn't call haskell very good for web programming, given the competition out there
22:52:28 <kadoban> I don't like it at all for GUI programming, none of the frameworks seem all that good. For web, it depends what you mean.
22:52:49 <solatis> if by web you mean 'server-side', haskell is good
22:53:00 <solatis> if by web you mean 'web browser', haskell is bad
22:53:46 <crocket> solatis, ghcjs
22:54:08 <solatis> crocket: just because you can compile against javascript doesn't make it a good choice
22:54:14 <crocket> ok
22:55:34 <crocket> I like how haskell separate actual I/O operations.
22:55:40 <solatis> i can also compile c++ code to javascript, that doesn't make it a good choice for web programming either
22:55:44 <systemfault> Some haskell-ressembling languages like purescript or fay are better for the browser.
22:55:49 <crocket> C++ is a terrible language.
22:56:05 <crocket> PureScript doesn't seem to separate I/O operations.
22:56:15 <solatis> now let's don't get into "language X is terrible, language Y is amazing" debates
22:56:31 <sivteck> no, language X is awesome
22:56:52 <code_pod> no no no, language XX is awesom
22:56:57 <crocket> Without separating I/O operations, I'd have to create mocks for each unit test, which is a lot of work.
22:57:05 <dmj`> crocket: For building rest apis, handling json, html templating, backend concurrency, haskell is great. For writing single page web applications not so sure.
22:57:11 <danclien> crocket: PureScript uses the Eff monad for its effect system.
22:57:44 <systemfault> And Fay has the "Fay" monad for IO
22:57:49 <crocket> danclien, Does it mean I can separate AJAX calls?
22:58:04 <dmj`> I think fay bindings to mithril.js would be a good frontend SPA solution for haskell
22:58:11 <danclien> crocket: AJAX calls would be in Eff.
22:58:32 <crocket> Mocking makes me puke.
22:59:00 <danclien> Regardless, even without perfect I/O separation (e.g. Scala), you can still write in a style that doesn't require mocks.
22:59:08 <crocket> danclien, how?
22:59:27 <danclien> crocket: Don't have any side effects in any of your functions.
22:59:28 <solatis> crocket: start out by writing your tests before the actual code
22:59:50 <crocket> danclien, AJAX calls are side effects.
22:59:51 <solatis> you will suddenly feel the urge to write mock-free code
23:00:04 <crocket> solatis, In javascript, that was impossible.
23:00:17 <danclien> crocket: Yes. Just don't do AJAX calls in the middle of your codebase.
23:00:33 <crocket> danclien, how?
23:00:55 <solatis> crocket: by designing your application to not do ajax calls in the middle of your codebase
23:00:55 * hackagebot objective 0.6 - Extensible objects  http://hackage.haskell.org/package/objective-0.6 (FumiakiKinoshita)
23:01:07 <solatis> IO is linked together at a very high level
23:01:09 <crocket> solatis, that sounds wishful.
23:01:16 <solatis> no it doesn't
23:01:24 <crocket> I haven't done it yet.
23:01:34 <crocket> I'm preparing to escape java/javascript stack.
23:01:42 <danclien> crocket: What solatis said. :)
23:01:44 <solatis> the only thing that haskell adds is making it more convenient to do IO at a high level
23:01:59 <crocket> solatis, That's very helpful.
23:02:01 <solatis> or rather, makes it more *in*convenient to do it in the middle of your codebase
23:02:23 <solatis> because that would mean you would have to wrap every function inside the IO monad, *or* do performUnsafeIO
23:02:24 <crocket> solatis, javascript makes it very inconvenient to cause side effects at the end.
23:02:48 <solatis> you can design applications in purescript just like you do in haskell
23:02:53 <danclien> crocket: I think it's more "JavaScript makes it easy to have side effects anywhere."
23:03:01 <solatis> yeah exactly
23:03:10 <solatis> haskell makes it hard to have side effects everywhere
23:03:15 <solatis> javascript just doesn't care
23:03:17 <crocket> https://gist.github.com/robotlolita/c7fc47ff766ac0a83494 is what it takes to cause side effects at the end in javascript, which would make peer javascript developers want to kill me.
23:03:57 <solatis> huh what is that code
23:04:00 <crocket> If I make an impromptu I/O interpreter in javascript, fellow programmers will try to kill me.
23:04:35 <crocket> solatis, That is what it takes to cause side effects at the end in javascript.
23:04:37 <crocket> That's one way.
23:04:37 <danclien> crocket: That looks somewhat like a free monadic DSL which isn't the only way to do side effects at the ends.
23:04:42 <solatis> your problem is that you do I/O inside the interpreter
23:05:07 <crocket> It's hard for me to think of a way to separate I/O in javascript.
23:05:12 <crocket> At least it'll take weeks.
23:05:18 <danclien> crocket: Give an example of something you want to do?
23:05:34 <danclien> Probably not as complex as you think, just foreign. :)
23:05:47 <crocket> danclien, I just want to make AJAX calls without mocking such calls in unit tests.
23:05:55 * hackagebot data-filepath 2.0.0.0 - A type safe file path data structure  http://hackage.haskell.org/package/data-filepath-2.0.0.0 (domdere)
23:06:09 <crocket> danclien, I guess you'd have to mimic haskell constructs in scala.
23:06:20 <solatis> crocket: then don't make ajax calls, silly
23:06:27 <crocket> solatis, As if that was possible.
23:06:29 <danclien> Not really. You only need to move side effects to the beginning/end of your app.
23:06:43 <crocket> danclien, Can you do it easily in js?
23:06:51 <solatis> yes, you just separate *all* the IO from the libraries that *use* IO
23:07:00 <danclien> Depends on what your app is.
23:07:00 <solatis> yes of course you can in javascript
23:07:14 <crocket> You sound like a genius.
23:07:22 <solatis> but if you're using a library like Backbone.js, all hope is lost of course
23:07:22 <danclien> Much easier if it's something like a web API. More difficult if it's an interactive drawing app or video game.
23:07:22 <crocket> An average js programmer would be confused.
23:07:37 <solatis> that is true
23:07:46 <solatis> and the most important thing is to write code that other people can work with
23:07:57 <solatis> so i would recommend sticking to the conventions of your language of choice over anything
23:08:09 <crocket> solatis, Which is mocking every unit test.
23:08:12 <crocket> puke
23:08:22 <solatis> javascript derivatives make mocking very easy
23:08:34 <crocket> solatis, Yet, it adds a lot of manual work.
23:08:52 <crocket> Do you not hate manual labor?
23:08:57 <danclien> I'll disagree with solatis on the "stick with the conventions of the langauge" with a "it depends." :)
23:09:10 <StoneCypher> after all that time was spent talking about how nice #haskell is
23:09:37 <crocket> If I used fay or purescript, would it be easy to separate I/O?
23:10:17 <danclien> crocket: PureScript enforces a separation of I/O. I think Fay does too.
23:10:21 <dmj`> crocket: fay yes, since you share haskell types. purescript yes, since there's also a seperation
23:10:43 <crocket> Javascript === an alias of PukeScript.
23:11:16 <StoneCypher> crocket: language zealotry isn't generally desirable
23:12:02 <danclien> I actually like JavaScript. :P
23:12:07 <crocket> StoneCypher, I really don't like javascript after having used it for months.
23:12:20 <crocket> node.js fails to make it bearable.
23:12:43 <StoneCypher> crocket: language zealotry isn't generally desirable
23:13:12 <crocket> StoneCypher, Why not?
23:14:16 <simpson> Because it hurts people's feelings.
23:14:20 <StoneCypher> hardly
23:14:22 <StoneCypher> it's just boring
23:15:27 <crocket> StoneCypher, But, you accept that javascript sucks.
23:15:37 <sivteck> take it to #haskell-blah
23:15:50 <StoneCypher> crocket: i have no intention of engaging you on language zealotry
23:16:33 <crocket> Whut
23:16:51 <crocket> StoneCypher, You ban me for whining about javascript?
23:16:54 <crocket> That's fantastic.
23:16:59 <crocket> That's worse than language zealotry
23:17:05 <simpson> crocket: Relax.
23:17:07 <Welkin> no one was banned
23:17:14 <simpson> This isn't the venue for it.
23:17:24 <Welkin> the point is to keep the channel on topic and away from harmful conversations
23:17:37 <StoneCypher> i never said anything about banning me you and i don't want to engage with you
23:17:42 <Welkin> the focus here is to learn/teach/share haskell
23:17:44 <dibblego> Please stop, or take it to privmsg
23:17:58 <StoneCypher> i did.  he keeps coming back here because he wants attention
23:18:37 <crocket> woo
23:20:09 <dibblego> Thanks.
23:20:22 <simpson> Sure.
23:20:42 <solatis> like i said at the beginning, please don't go into debates about "language X sucks, language Y is awesome" -- it never adds any value to a discussion
23:20:48 <wei2912> also
23:20:59 <wei2912> do not infer that someone is going to kick/ban you till he actually does
23:21:23 <simpson> solatis: The alternative is to fail to consider that Language Y might be *objectively bad*.
23:21:39 <solatis> let's just say that i do not think #haskell is the place to discuss that
23:21:40 <simpson> It's important to have these discussions, but this isn't the venue for it.
23:21:53 <wei2912> yes.
23:21:57 <solatis> right, we are on the same page
23:29:32 <crocket> Does this channel have an immune system?
23:29:57 <shiona_> what's that?
23:30:17 <moop> what is this language Y that everyone is talking about?
23:30:30 <crocket> A system that repels things that don't seem to belong in the system.
23:30:48 <benzrf> crocket: no, we attract them
23:30:51 <shiona_> crocket: I guess it does, so called channel operators
23:30:53 <benzrf> @where troll
23:30:56 * hackagebot objective 0.6.1 - Extensible objects  http://hackage.haskell.org/package/objective-0.6.1 (FumiakiKinoshita)
23:31:03 <Welkin> language Y is the future
23:31:09 <benzrf> hmmm
23:31:10 <Welkin> haven't you heard?
23:31:15 <StoneCypher> there is an actual y language from the 80s
23:31:21 <wei2912> :P
23:31:56 <benzrf> @ping
23:31:56 <lambdabot> pong
23:32:00 <benzrf> @where troll
23:32:03 <benzrf> huuh
23:32:22 <moop> StoneCypher: after the craze of c i'm surprised when there is no language named ater a letter
23:32:31 <StoneCypher> benzrf: didn't you just get yelled at for that
23:32:36 <benzrf> idk
23:49:42 <solatis> the prefered type to use for a number is usually Integer eh, if correctness is more important than performance?
23:50:05 <simpson> solatis: It depends. There are certainly times when Word16 is the correct thing.
23:50:54 <solatis> yeah, basicly, i don't ever want to have to deal with the risks of overflows or imprecise floating point comparisons, etc
23:51:16 <solatis> basicly, i don't want leaky abstractions
23:51:50 <simpson> They aren't abstractions if they leak this much. :3
23:52:00 <simpson> When you ask for an Int, you know exactly how non-abstract it's gonna be.
23:52:12 <solatis> that is true
23:52:54 <solatis> i think https://www.haskell.org/tutorial/numbers.html is what i should read
23:53:25 <solatis> it might make more sense to invent some new, bounded, type for what i want
23:55:05 <merijn> solatis: Use Integer, yes
23:55:35 <merijn> solatis: Also, Integer is pretty fast, not as fast as Int, but it's not slow either
23:55:48 <solatis> yeah the wikibooks documentation suggests it's a lot slower
23:55:51 <benzrf> bye
23:56:10 <solatis> ""Integer" is an arbitrary precision type: it will hold any number no matter how big, up to the limit of your machine's memory…. This means you never have arithmetic overflows. On the other hand it also means your arithmetic is relatively slow."
23:56:18 <solatis> that's what the wiki says about Integer right now
23:56:27 <merijn> solatis: "relatively slow" compared to Int
23:56:30 <solatis> yeah
23:56:39 <merijn> solatis: But considering lots of Int operatins are 1-2 cycles...
23:56:58 <solatis> besides, if you're never comparing integers (like I am) ... :)
23:57:01 <merijn> solatis: "much slower" for Integer still means "probably only a few cycles" at least for small values
23:57:08 <solatis> it's mostly just for assignment of a primary key, etc
23:57:21 <solatis> yeah, GHC uses GMP for Integer, right?
23:57:23 <merijn> For REALLY large (like 100s of digits) it'll obviously be slower
23:57:24 <merijn> Yeah
23:57:29 <solatis> yeah GMP is insane
23:58:05 <solatis> okay, then i know enough
23:58:16 <solatis> use Integer, unless profiling shows it's a bottleneck
23:58:33 <merijn> Or you have semantic reasons not to :)
23:58:46 <merijn> Like a network protocol that specifies a value to be Int16 or something
