00:10:14 * hackagebot github-post-receive 1.2.0.1 - GitHub webhooks library  http://hackage.haskell.org/package/github-post-receive-1.2.0.1 (ShoheiYasutake)
00:10:14 * hackagebot keystore 0.6.3.1 - Managing stores of secret things  http://hackage.haskell.org/package/keystore-0.6.3.1 (ChrisDornan)
00:27:39 <dmwit> Anybody know of a variant of permutations which has the type `Eq a => [a] -> [[a]]` or similar?
00:28:01 <dmwit> (And which does not produce duplicate results when the input has duplicate entries.)
00:29:32 <indiagreen> dmwit: there's one in multiset-comb
00:29:50 <dmwit> Great, thanks!
00:31:15 <indiagreen> dmwit: as well as combinat, apparently
00:32:19 <indiagreen> (permuteMultiset in Math.Combinat.Permutations)
00:33:36 <dmwit> I trust the author of multiset-comb, I'll go with that.
00:36:36 <dmwit> Oh, man, it also implements "splits" which I wrote myself already.
01:27:29 <ddd1970> ciao
01:27:35 <ddd1970> !list
01:27:36 <monochrom> ddd1970: http://lpaste.net/browse
01:35:12 * hackagebot api-tools 0.5.1 - DSL for generating API boilerplate and docs  http://hackage.haskell.org/package/api-tools-0.5.1 (AdamGundry)
01:40:25 <cellopin> Any idea why myfunc is not in scope? http://lpaste.net/113885
01:40:55 <flux> cellopin, let myfunc _ = []
01:41:23 <flux> you're actually doing the same as: let x + y = x - y   which would redefine the + operator. but you're doing it to the subtraction operator.
01:41:46 <flux> you cannot pattern match only negative numbers, which appears to be what you want to do, without pattern guards.
01:41:48 <cellopin> I am pattern matching negative numbers
01:41:52 <cellopin> oh
01:42:31 <cellopin>  Thanks flux
01:42:46 <flux> cellopin, good luck :)
01:57:31 <Miaesma> Hey. I'm messing around with procedural content generation, and i'm considering learning Haskell for that purpose. Do you think it'd be a better fit than the java and python that i've been running before?
01:58:06 <wei2912> Miaesma: no, how would we know what is a better fit for you?
01:59:44 <bernalex> hm. I'm importing Text/ByteString/etc to get haddock strings working. but GHC will then warn that they are redundant imports (they are only used for comments). is there a way to silence this message that makes sense?
01:59:47 <Miaesma> I'm thinking more about whether functional programming would be better suited than imperative programming for the purposes of writing PCG algorithms (mainly considering development time)
02:00:00 <wei2912> Miaesma: well, depends on you, i guess
02:00:46 <wei2912> Miaesma: if you have a lot of time, i'd say just give haskell a try before choosing which language
02:00:58 <wei2912> Miaesma: if you don't, you should go with what you already know
02:02:54 <ClaudiusMaximus> bernalex: maybe -XCPP and #ifdef HADDOCK around the imports (or whatever the correct macro is) but that might create more problems than it solves
02:04:57 <bernalex> ClaudiusMaximus: I'll try ifdef first. thanks.
02:14:46 <emmanueloga> Q: say you wrote your code using the type system as much as possible to return errors with Maybe, Either values or custom ones, and such. I was wondering if there's any tools/techniques to make sure you are not missing any exception handlers, possibly for code that you did not write your self (e.g. cabal packages)
02:15:02 <emmanueloga> I may be wrong but it seems like the compiler can't help there.
02:16:40 <bernalex> ClaudiusMaximus: for some reason my searches don't reveal anything useful: where in .cabal do I put -cpp?
02:16:48 <bernalex> ClaudiusMaximus: I assume I need -cpp to process the ifdefs
02:17:32 <ClaudiusMaximus> bernalex: not sure, never needed to do it myself
02:18:12 <bernalex> ClaudiusMaximus: hm. I'll have to look around some more. the warnings are really annoying because they come at the top of the linter, so you could conceivably lose sight of a more worrying warning because of them.
02:18:22 <bernalex> ClaudiusMaximus: i.e. if I open *any* file in the project, those warnings come up.
02:20:46 <ClaudiusMaximus> bernalex: extensions: CPP  in the .cabal file, going from https://www.haskell.org/cabal/users-guide/developing-packages.html#modules-and-preprocessors
02:21:44 <bernalex> ClaudiusMaximus: oh. thanks.
02:22:28 <bernalex> ClaudiusMaximus: I always kind of wondered why the pragmas section was called "*other*-extensions"
02:23:26 <ClaudiusMaximus> bernalex: probably wise to put {-# LANGUAGE CPP #-} in the source files that need it too, so you can load it without invoking cabal
02:23:41 <bernalex> ClaudiusMaximus: ah. ofc! there's a pragma for it. thanks.
02:24:40 <ClaudiusMaximus> bernalex: and i think the correct macro is __HADDOCK__ but i still haven't found a definitive source
02:24:48 <bernalex> ClaudiusMaximus: thanks I'll give it a go
02:28:12 <Th30n> anyone knows of any good articles about creating a fuzzy logic expert system in haskell (or functional language)?
02:28:26 <Thooms> I know this is not the main topic here, but is there anyone that knows a bit about SVMs ?
02:30:14 * hackagebot hlint 1.9.11 - Source code suggestions  http://hackage.haskell.org/package/hlint-1.9.11 (NeilMitchell)
02:37:33 <bernalex> ClaudiusMaximus: worked well BTW
02:37:42 <ClaudiusMaximus> bernalex: cool
02:37:49 <bernalex> beans
03:04:26 <qsuscs> argh
03:04:47 <qsuscs> i’ve been learning haskell for the past few weeks, now in school again, where we are “taught” object pascal
03:05:27 <qsuscs> “you don’t have to care about that value here, it’s set in the other part” “but a function is only dep… oh, imperative.”
03:05:50 <wei2912> only dep-what?
03:08:08 <qsuscs> the result of a function is only dependent on its parameters, not on some other state
03:10:49 <wei2912> qsuscs: haha
03:23:30 <naudiz> can you recommend a guide on point-free programming?
03:23:54 <Iceland_jack> What would a guide like that provide?
03:24:41 <naudiz> I'm not sure but I'd like to have a better understanding on writing point-free code
03:26:14 <Iceland_jack> (Writing pointfree code is a fun exercise but if other people will read your code you should be a bit conservative)
03:26:37 <Iceland_jack> That being said, the idea is fairly simple and asking "@pl" gets you a long way
03:27:20 <Iceland_jack> naudiz: Let's say you have the following code:
03:27:20 <Iceland_jack> > concat (map (\x -> replicate x x) [1,3,5])
03:27:21 <lambdabot>  [1,3,3,3,5,5,5,5,5]
03:27:35 <naudiz> isn't haskell all about fun? ;)
03:27:56 <Iceland_jack> Haskell is very serious
03:28:03 <Iceland_jack> @pl \x -> replicate x x
03:28:03 <lambdabot> join replicate
03:28:29 <Iceland_jack> So you can use 'join replicate' in lieu of '\x -> replicate x x'
03:28:29 <Iceland_jack> > concat (map (join replicate) [1,3,5])
03:28:31 <lambdabot>  [1,3,3,3,5,5,5,5,5]
03:28:41 <BoR0> @src join
03:28:41 <lambdabot> join x = x >>= id
03:28:52 <bsmt> i know some of those words
03:28:53 <Iceland_jack> In this case:
03:28:53 <Iceland_jack>     join f x = f x x
03:29:14 <Iceland_jack> So if you ever see some function applied to the same argument (of the same type) twice, you can apply join to it
03:29:18 <Iceland_jack> > join (+) 15
03:29:20 <lambdabot>  30
03:29:33 <Iceland_jack> There is still a "point" there, namely [1,3,5]
03:29:49 <BoR0> > join (*) 10 -- square?
03:29:50 <lambdabot>  100
03:29:57 <Iceland_jack> Yes
03:30:00 <BoR0> @src join
03:30:00 <lambdabot> join x = x >>= id
03:30:04 <BoR0> whoops, I meant
03:30:05 <BoR0> :t join
03:30:06 <lambdabot> Monad m => m (m a) -> m a
03:30:16 <Iceland_jack> :t join :: (r -> r -> a) -> (r -> a)
03:30:17 <lambdabot> (r -> r -> a) -> r -> a
03:30:19 <Iceland_jack> If you defined it as:
03:30:19 <Iceland_jack>     multiply xs = concat (map (join replicate) xs)
03:30:26 <Iceland_jack> we want to get rid of the point "xs"
03:31:02 <naudiz> Iceland_jack: thanks for your explanation. I'll spam lambdabot with lots of code in the future
03:31:03 <BoR0> aha, m is (-> r) in that case. I see it.
03:31:21 <Iceland_jack> naudiz: One way to do that is:
03:31:22 <Iceland_jack>       \xs -> concat (map (join replicate) xs)
03:31:22 <Iceland_jack>     = \xs -> (concat . map (join replicate)) xs
03:31:22 <Iceland_jack>     = concat . map (join replicate)
03:31:43 <BoR0> @src (.)
03:31:44 <lambdabot> (f . g) x = f (g x)
03:31:49 <Iceland_jack> Another is:
03:31:49 <Iceland_jack>       \xs -> concat (map (join replicate)) xs
03:31:49 <Iceland_jack>     = \xs -> concatMap (join replicate) xs
03:31:49 <Iceland_jack>     = concatMap (join replicate)
03:31:51 <BoR0> interesting.
03:32:04 <BoR0> I can't believe how many hidden facts does such a simple definition of (.) hold
03:32:22 <BoR0> (f . g) x = f (g x) -- you can move the inner x to being outer
03:32:31 <BoR0> (as shown by Iceland_jack)
03:32:45 <Iceland_jack> BoR0:
03:32:46 <Iceland_jack> > (reverse >>= (==)) "abba"
03:32:47 <lambdabot>  True
03:33:10 <Iceland_jack> This can be fun, but often illegible
03:33:32 <Iceland_jack> I use it sparingly
03:34:55 <Iceland_jack>       (reverse >>= (==)) xs
03:34:56 <Iceland_jack>     = reverse xs == xs
03:35:09 <Iceland_jack> Not very clear from context
03:35:23 <Iceland_jack> > mapM(flip(!!))[2,13,17,0,4,3,12,0,3,10,15,13,0,6,13,0,16,13,0,5,18,14,5,11,5,15,0,10,8,9,5,0,16,7,8,15,1,1,1,1,1,1]" .Yaceghiklmnorstux"
03:35:24 <Iceland_jack>  
03:35:25 <lambdabot>  "You can also go to exremes like this......"
03:35:44 <BoR0> :D
03:35:46 <Iceland_jack> Better correct the grammar:
03:35:46 <Iceland_jack>  
03:35:47 <Iceland_jack> > mapM(flip(!!))[2,13,17,0,4,3,12,0,3,10,15,13,0,6,13,0,16,13,0,5,18,16,14,5,11,5,15,0,10,8,9,5,0,16,7,8,15,1,1,1,1,1,1]" .Yaceghiklmnorstux"
03:35:48 <lambdabot>  "You can also go to extremes like this......"
03:36:02 <naudiz> but I cuess writing code like this is a good exercise
03:38:25 <naudiz> s/cuess/guess
03:40:59 <edvo> does anyone know how to do a hostname validation with HsOpenSSL easily?
03:44:42 <sagittarian> > let isPrime n = let bound = floor (sqrt n) in any (divides n) [2..bound] in isPrime 5
03:44:43 <lambdabot>  Not in scope: ‘divides’
03:45:36 <sagittarian> > let isPrime n = let divides x = (== 0) . (mod x); bound = floor (sqrt n) in any (divides n) [2..bound] in isPrime 5
03:45:37 <lambdabot>  No instance for (GHC.Real.RealFrac a0)
03:45:37 <lambdabot>    arising from a use of ‘isPrime’
03:45:37 <lambdabot>  The type variable ‘a0’ is ambiguous
03:45:37 <lambdabot>  Note: there are several potential instances:
03:45:37 <lambdabot>    instance GHC.Real.RealFrac GHC.Types.Double
03:45:49 <sagittarian> can anyone explain what the problem is here?
03:46:45 <ClaudiusMaximus> needs more fromIntegral inside the sqrt
03:46:59 <sagittarian> @type sqrt
03:47:00 <lambdabot> Floating a => a -> a
03:47:11 <sagittarian> @type floor . sqrt
03:47:12 <lambdabot> (RealFrac b, Integral c, Floating b) => b -> c
03:47:23 <sagittarian> floor provides an integral
03:47:29 <sagittarian> anyway, that doesn't fix it
03:47:46 <sagittarian> > let isPrime n = let divides x = (== 0) . (mod x); bound = fromIntegral (floor (sqrt n)) in any (divides n) [2..bound] in isPrime 5
03:47:47 <lambdabot>  No instance for (GHC.Real.RealFrac a0)
03:47:47 <lambdabot>    arising from a use of ‘isPrime’
03:47:47 <lambdabot>  The type variable ‘a0’ is ambiguous
03:47:47 <lambdabot>  Note: there are several potential instances:
03:47:47 <lambdabot>    instance GHC.Real.RealFrac GHC.Types.Double
03:48:03 <ClaudiusMaximus> sagittarian: but sqrt takes a Floating, mod takes an Integral, there's no type that's both, so error
03:48:24 <sagittarian> ah on the literal
03:48:31 <sagittarian> okay thanks
03:48:31 <ClaudiusMaximus> > let isPrime n = let divides x = (== 0) . (mod x); bound = floor (sqrt (fromIntegral n)) in any (divides n) [2..bound] in isPrime 5
03:48:32 <lambdabot>  False
03:48:43 <sagittarian> thanks ClaudiusMaximus
03:49:00 <ClaudiusMaximus> needs (`mod` x) i think
03:49:10 <MP2E> heh 5 is a prime number though :P
03:49:11 <MP2E> ah yeah
03:50:17 * hackagebot peyotls 0.1.6.1 - Pretty Easy YOshikuni-made TLS library  http://hackage.haskell.org/package/peyotls-0.1.6.1 (YoshikuniJujo)
03:50:18 <ClaudiusMaximus> might be better to use round instead of floor, as i imagine it might be possible for sqrt(large square n) to return slightly less than the integral square root
03:50:36 <absence> if i have a list of musical notes (including the start time and length) and a means to generate waveform data, what is a sensible and functional way to mix it down to a single long waveform? mapping the generator to each element and prepend/append the right amount of zero data (i.e. [Note] -> [[Sample]]) and then summing the waveform data from each note "vertically" seems very functional, but not too sensible :)
03:50:40 <ClaudiusMaximus> due to the usual floating point rounding error issues
03:51:25 <absence> there would be a lot of unnecessary 0+0+0+0, a bit like representing a sparse matrix using a dense data structure
03:53:35 <ClaudiusMaximus> absence: maybe use a mutable vector to accumulate the notes (perhaps in ST) - or maybe map over a list of sample indices and pull all the currrently sounding notes (assuming your notes have a  Time -> Sample  representation)
03:54:03 <sagittarian> > let isPrime n = let divides x = (== 0) . (mod x); bound = floor (sqrt (fromIntegral n)) in not (any (divides n) [2..bound]) in isPrime 5
03:54:04 <lambdabot>  True
03:54:56 <ClaudiusMaximus> ah yes, mod x is correct, what was i thinking
03:56:28 <ClaudiusMaximus> @check \x -> ((^2) . floor . sqrt . fromIntegral) x == x
03:56:30 <lambdabot>  *** Failed! Falsifiable (after 4 tests):
03:56:30 <lambdabot>  -1
03:56:42 <ClaudiusMaximus> @check \x -> x < 0 || ((^2) . floor . sqrt . fromIntegral) x == x
03:56:43 <lambdabot>  *** Failed! Falsifiable (after 3 tests):
03:56:43 <lambdabot>  2
03:57:25 <ClaudiusMaximus> @check \x -> ((^2) . floor . sqrt . fromIntegral) (x^2) == (x^2)
03:57:26 <lambdabot>  +++ OK, passed 100 tests.
04:01:11 <absence> ClaudiusMaximus: good ideas, thanks!
04:02:34 <absence> i've never explored mutability in haskell, so maybe this is an excuse to try it and figure out what ST really is about :)
04:03:29 <ClaudiusMaximus> absence: the second approach has the advantage that you don't need to keep the whole thing in memory at once
04:07:15 <absence> ClaudiusMaximus: yes, and is the "cleaner" functional way of doing it i guess
04:09:56 <absence> ClaudiusMaximus: if performance was really important, a combination of the methods that uses a list of shorter mutable vectors (similar to bytestring etc) is a possible compromise
04:10:27 <kvanb_> fryguybob: hey
04:10:46 <kvanb_> will your hardware transactional memory work on a Macbook Pro October 2013
04:12:02 <ClaudiusMaximus> absence: you could sort all notes by start time, and step through time keeping track of sounding notes, is a third method that might work ok with causal synths (with recursive filters etc)
04:15:01 <absence> ClaudiusMaximus: that's how i would have done it in an imperative language, but i want to explore what pros and cons a more functional solution would give
04:16:38 <absence> ClaudiusMaximus: causality is definitely worth keeping in mind regardless
04:21:30 <joe9> I understand that a monad states how functions are joined/composed/combined together. On a similar note, What are algebraic effects?
04:27:41 <Gurkenglas> http://pastebin.com/YkqRDfuh <- It gives my a parse error on my first guard. What did I do wrong?
04:27:46 <Gurkenglas> *me
04:28:42 <alphamarc> Hi everyone, I am slowly trying to show my coworkers the beauty of FP in Haskell. And one of them wants some data on performance vs other languages. Any idea where I could find some ressources on that ?
04:30:41 <ChristianS> alphamarc: there is http://benchmarksgame.alioth.debian.org/
04:31:44 <ClaudiusMaximus> Gurkenglas: the guards need to be aligned to the right of the start of check
04:31:52 <alphamarc> Sweet thanks :)
04:32:52 <Gurkenglas> http://learnyouahaskell.com/syntax-in-functions said I could even put them all in a line :I
04:33:16 <Gurkenglas> but thx that worked
04:35:19 * hackagebot conduit 1.2.2.1 - Streaming data processing library.  http://hackage.haskell.org/package/conduit-1.2.2.1 (MichaelSnoyman)
04:43:08 <bitonic> is there any sort of guide on how to work with type-level naturals?  I would have expected something basic like this to work: <http://lpaste.net/113887>
04:44:18 <Iceland_jack> bitonic: When could (==) return False?
04:44:30 <Iceland_jack> Its type is:
04:44:30 <Iceland_jack>     (==) :: SNat n -> SNat n -> Bool
04:44:35 <bitonic> basically I'd love to work with type-level naturals just like if they were unary numbers but I'd like to have a smart constraint solver for them (which I think GHC does?)
04:44:57 <Iceland_jack> There is already a way to check for equality of type-level natural numbers
04:45:10 <bitonic> Iceland_jack: I don't understand the question -- my problem is that that code doesn't type check
04:45:19 * hackagebot kyotocabinet 0.1.3 - Mid level bindings to Kyoto Cabinet  http://hackage.haskell.org/package/kyotocabinet-0.1.3 (YurasShumovich)
04:46:03 <Iceland_jack> bitonic: The implementation should be:
04:46:04 <Iceland_jack>     instance Eq (SNat n) where
04:46:04 <Iceland_jack>       _ == _ = True
04:46:04 <Iceland_jack> :)
04:46:04 <bitonic> Iceland_jack: and in general they're much more awkward to use thatn lifted unary numbers
04:46:30 <bitonic> Iceland_jack: right right, but that's not the point, for example if I define Fin I can't check equality
04:46:41 <Iceland_jack> you can use (~)
04:47:02 <bitonic> Iceland_jack: coercions?  how would I use them in this case?
04:47:10 <Iceland_jack> (~) is not a coercion
04:47:17 <Iceland_jack> it's propositional equality
04:47:41 <bitonic> oh, you mean :~:
04:47:54 <Iceland_jack> No I meant "equality constraint" rather
04:47:59 <bitonic> so how would I use it here?
04:48:14 <y> > let f ∷ (Num a, Num b, a ~ b) => a → b → a; f = (+) in f 2 3
04:48:15 <lambdabot>  5
04:48:36 <Iceland_jack> It depends how you want to use it, GHC.TypeLits already provides convenience functions for testing equality of naturals
04:48:43 <Iceland_jack> like 'sameNat'
04:49:24 <bitonic> Iceland_jack: wait, so you do mean ~, I thought those were called coercions in system fc
04:49:36 <Iceland_jack> https://www.haskell.org/ghc/docs/7.4.2/html/users_guide/equality-constraints.html
04:49:38 <bitonic> anyhow, it's annoying that pattern matching definition doesn't work
04:49:50 <Iceland_jack> bitonic: pattern matching does work, it's the recursive call that fails
04:50:04 <bitonic> pattern matching *definition*
04:50:10 <bitonic> but yeah
04:50:37 <bitonic> if I have to resort to proving those equations explicitly it's super annoying
04:50:45 <bitonic> I mean I'd much rather use normal unary numbers
04:51:03 <Iceland_jack> Yes
04:51:11 <bitonic> but I was under the impression that GHC had some smarter ring solver for built-in naturals
04:51:53 <Iceland_jack> It's in the works
04:52:05 <bitonic> that'd be so great
04:52:17 <bitonic> for the time being I'll just insert unsafeCoerce ehe
04:53:05 <Iceland_jack> If you wanted to define instances like that you'd still need to show that the predecessor is an instance of Eq
04:53:34 <bitonic> Iceland_jack: with unary numbers everything goes smoothly in that definition
04:53:38 <bitonic> that Eq instance is polymorphic on the Nat
04:53:54 <bitonic> the problem is that it can't prove that the two matched numbers are not indexed by the same Nat
04:53:58 <bitonic> (with the built in Nat)
04:57:06 <Iceland_jack> The solver fails you here and unsafeCoerce would work for other instances
04:58:11 <bitonic> Iceland_jack: but in the current state, will it prove stuff like ((n + m) + k) = (n + (m + k))?
04:58:31 <bitonic> I mostly need associativity
04:59:00 <bitonic> if built-in nats don't give me that, I'll just keep using unaries for the time beieng
04:59:01 <Iceland_jack> In 7.8 it shouldn't
04:59:53 <bitonic> Iceland_jack: what about HEAD?
04:59:59 <Iceland_jack> I'm not sure about HEAD
05:00:26 <bitonic> mhm.  I might compile and see
05:00:29 <Iceland_jack> but 7.8 isn't aware of injectivity of (+ n) and many other properties that make it annoying to work with
05:01:20 <bitonic> I mean it shouldn't be too hard to have a nice solver for those equations, should it?
05:02:34 <Iceland_jack> Well the design and implementation of type-level naturals with some basic solving was added in 7.8 so keep in mind that it's a very recent addition
05:50:21 <insitu> I have troubles understanding lens behaviour (specifically trying to use that for wreq library)
05:51:07 <insitu> I am trying to set a cookie using : let opts = def & cookie "authenticator" .~ ck; getWith opts "..."
05:51:28 <insitu> but the cookie is not set in the cookies of the options for request
05:52:49 <osa1> any ideas how is PortNum from network package working? I found this weird: show (PortNum 123) == "31488"
05:53:13 <ClaudiusMaximus> osa1: use its Num instance, not the constructor
05:53:34 <osa1> is this realted with endianness?
05:53:38 <osa1> related*
05:53:39 <ClaudiusMaximus> osa1: yeah
05:53:49 <osa1> it should still work though
05:55:26 <ClaudiusMaximus> osa1: use (123 :: PortNumber) instead of (PortNum 123)
05:56:56 <ClaudiusMaximus> osa1: http://hackage.haskell.org/package/network-2.6.0.2/docs/src/Network-Socket-Types.html#PortNumber has the gory endianness conversion details
05:57:24 <osa1> ClaudiusMaximus: thanks
06:05:08 <osa1> can I split a doctest line into multiple lines?
06:05:22 <osa1> I tried ghci style :{ :} but did'nt work
06:10:16 <masse> Hmm.. interesting. If I add -prof -auto-all to build flags, the run time changes considerably
06:10:27 <masse> Without profiling one run takes ~11 seconds
06:10:31 <masse> With profiling ~1 second
06:15:52 <nyuszika7h> osa1: https://github.com/sol/doctest#multi-line-input says it should work
06:16:15 <osa1> uh... SockAddrInet also makes some conversions
06:16:34 <osa1> I'm passing it big-endien 32bits and it's printing 1.1.168.192
06:16:51 <osa1> but documentation says "network byte order"
06:18:40 <dword> whoami
06:18:50 <hc> you're dword sir
06:19:06 <osa1> should I pass IP in big-endian or small-endian order to SockAddrInet?
06:19:27 <dword> hc: thanks
06:26:09 <zipper> What does this sign mean ".:"
06:27:22 <kuribas> zipper: isn't that multi arity composition?
06:27:36 <zipper> kuribas: I don't know.
06:27:53 <zipper> kuribas: I'm asking I saw it used with applicative functors
06:28:05 <zipper> with <$> and with <*>
06:28:31 <k00mi> zipper: from what module is it imported?
06:28:51 <zipper> in this example https://www.fpcomplete.com/school/starting-with-haskell/libraries-and-frameworks/text-manipulation/json
06:29:04 <kuribas> https://hackage.haskell.org/package/pointless-fun-1.1.0.1/docs/Data-Function-Pointless.html
06:29:17 <zipper> in the FromJSON instance of Person
06:29:19 <barrucadu> .: is from Aeson
06:29:29 <Phillemann> pointless-fun, nice
06:29:35 <zipper> barrucadu: What does it mean?
06:30:03 <k00mi> zipper: http://hackage.haskell.org/package/aeson-0.8.0.2/docs/Data-Aeson.html#g:14
06:30:06 <barrucadu> a .: "foo" - extract the field named "foo" from the object a, if it exists
06:32:50 <hexagoxel> there are tons of (.:) in use, see http://hayoo.fh-wedel.de/?query=%28.%3A%29
06:33:25 <hexagoxel> one specific one with functors: http://hackage.haskell.org/package/functors-0.1/docs/Data-Functor-Syntax.html
06:43:05 <spatials> newbie, debian, ghci, is there a way to clear history without going to ~/.ghc/ghci_history?
06:45:23 <chirpsalot> spatials: you could set history to store less?
06:47:05 <spatials> chirpsalot: no just clear it?
06:47:48 <spatials> chirpsalot: no some command I've not found?
06:53:29 <chirpsalot> I don't think there is a way. Why would you want to, anyway?
06:54:24 <spatials> Being a newbie there is a lot of crap:)
06:54:57 <chirpsalot> Don't hit up? :P
06:57:15 <zipper> Satan in the building y'all
06:57:41 <oleo> haiiiilllll!
06:57:44 <oleo> lol
06:59:53 <Phillemann> Is there no function V2 a -> V3 a in linear?
07:00:21 <Phillemann> Oh, wait, it's not needed. Sorry. :)
07:01:41 <zipper> How do I get the type a out of a Either String a. This question is in relation to aeson's eitherDecode.
07:02:03 <chirpsalot> zipper: pattern match?
07:03:14 <zipper> chirpsalot: Let me try implement that
07:04:30 <zipper> I am wondering how to pattern match on a String vs a list of another type.
07:04:41 <zipper> Like in my case the a is type [Market]
07:04:44 <chirpsalot> (Either left right)
07:05:06 <chirpsalot> Wait.
07:05:16 <chirpsalot> (Left blah)
07:05:21 <chirpsalot> And (Right blah)
07:07:53 <Copenragen> Working on writing a function that does this: skips "ABCD" == ["ABCD", "BD", "C", "D"], where the output is the list then every 2nd element...every nth element. I have this: http://lpaste.net/113892 but its ugly and it uses head. Would love some feedback. Can someone take a look?
07:09:14 <chirpsalot> > reverse . inits "ABCD"
07:09:16 <lambdabot>  Couldn't match expected type ‘a -> [a1]’
07:09:16 <lambdabot>              with actual type ‘[[GHC.Types.Char]]’
07:09:22 <chirpsalot> > (reverse . inits) "ABCD"
07:09:24 <lambdabot>  ["ABCD","ABC","AB","A",""]
07:09:44 <chirpsalot> Oh, other way, I guess.
07:11:17 <chirpsalot> > (map reverse . reverse . tail . inits . reverse) "ABCD"
07:11:18 <lambdabot>  ["ABCD","BCD","CD","D"]
07:11:19 <Copenragen> chirpsalot Not sure how that helps. I need every 2nd, then 3rd....
07:11:34 <chirpsalot> Oh, For some reason I didn't notice that.
07:11:58 <Copenragen> The way I approached was to first define the "nth" function
07:12:05 <Copenragen> which is obviously the crux of it
07:12:19 <Copenragen> but ive implemented it incorrectly and unsafely
07:12:28 <Copenragen> crashes on certain inputs bc I use head :(
07:12:32 <chirpsalot> Hmmmm.
07:13:27 <ij> I saw "init `fmap` io (hGetLine h)" and I think "io $ init <$> hGL h" is better. Can you make anything eles of it?
07:14:07 <ij> I think that the flow of data makes more sense in the 2nd ver.
07:14:14 <pavonia> Copenragen: I'd try to rewrite nth such that the first position in the list is always an element to be added to the resulting list
07:15:05 <Copenragen> pavonia hmm. trying to understand what you're saying
07:16:07 <Copenragen> pavonia you mean like nth (x:xs) = ....?
07:16:09 <pavonia> Such that nth [] _ = []; nth (x : xs) n = x : nth (drop n xs) n
07:16:12 <zipper> chirpsalot: Ok so power went out and I went offline. You were saying?
07:16:28 <Zyxoas> > putStrLn ":-/"
07:16:30 <lambdabot>  <IO ()>
07:17:03 <pavonia> > let nth [] _ = []; nth (x : xs) n = x : nth (drop n xs) n in map (nth "abcdef") [1,2,3,4]
07:17:05 <lambdabot>  ["ace","ad","ae","af"]
07:17:29 <pavonia> > let nth [] _ = []; nth (x : xs) n = x : nth (drop (n-1) xs) n in map (nth "abcdef") [1,2,3,4]
07:17:30 <lambdabot>  ["abcdef","ace","ad","ae"]
07:17:49 <pavonia> Yeah, that
07:18:38 <chirpsalot> let nths xs z = filter (\(x, y) -> x `mod` z == 0)) xs
07:18:41 <chirpsalot> > let nths xs z = filter (\(x, y) -> x `mod` z == 0)) xs
07:18:42 <lambdabot>  <hint>:1:51: parse error on input ‘)’
07:19:10 <Copenragen> pavonia that is not the function im looking for... i dont think
07:19:10 <chirpsalot> > let nths xs z = filter (\(x, y) -> x `mod` z == 0) xs
07:19:12 <lambdabot>  not an expression: ‘let nths xs z = filter (\(x, y) -> x `mod` z == 0) xs’
07:19:39 <Copenragen> nth "ABCD" 2 should be "BD"
07:19:44 <pavonia> Copenragen: True, but it's only a helper function to be used with skips
07:19:45 <chirpsalot> ... Why does that work in my GHCI?
07:19:52 <Copenragen> nth "ABCD" 3 should be "C"
07:20:09 <Hijiri> @let nths xs z = filter (\(x, y) -> x `mod` z == 0) xs
07:20:11 <lambdabot>  Defined.
07:20:25 <Hijiri> lambdabot isn't ghci, you need to do a special let thing
07:20:32 <Hijiri> > is just for evaluating expressions
07:20:33 <lambdabot>  Not in scope: ‘is’
07:20:33 <lambdabot>  Perhaps you meant one of these:
07:20:33 <lambdabot>    ‘id’ (imported from Data.Function),
07:20:33 <lambdabot>    ‘C.id’ (imported from Control.Category),
07:20:33 <lambdabot>    ‘s’ (imported from Debug.SimpleReflect)Not in scope: ‘just’Not in scope: ‘...
07:20:39 <chirpsalot> Hijiri: Oh.
07:21:02 <chirpsalot> > map nths "ABCD" [0..]
07:21:03 <lambdabot>  Couldn't match expected type ‘[t1] -> t’
07:21:04 <lambdabot>              with actual type ‘[a0 -> [(a0, t0)]]’Couldn't match type ‘GHC.Ty...
07:21:04 <lambdabot>  Expected type: [[(a0, t0)]]
07:21:04 <lambdabot>    Actual type: [GHC.Types.Char]
07:21:18 <chirpsalot> > map (nths "ABCD") [0..]
07:21:20 <lambdabot>  Couldn't match type ‘GHC.Types.Char’ with ‘(a, t)’
07:21:20 <lambdabot>  Expected type: [(a, t)]
07:21:20 <lambdabot>    Actual type: [GHC.Types.Char]
07:21:59 <Copenragen> pavonia not an issue of it being used as a helper
07:22:06 <Copenragen> its still not right
07:22:22 <pavonia> One second
07:22:22 <Copenragen> nth (x : xs) n = x : nth (drop (n-1) xs) n doesn't look right
07:22:39 <Aquana> aren't type classes more about properties of functions than properties of types?
07:24:11 <tlbakh> quick question; how do you find eric meijer's course on functional programming at edX?
07:24:40 <chirpsalot> @let nths xs z = map snd . filter (\(x, y) -> x `mod` z == 0) $ zip [0..] xs
07:24:41 <lambdabot>  .L.hs:156:1: Warning:
07:24:41 <lambdabot>      Pattern match(es) are overlapped
07:24:41 <lambdabot>      In an equation for ‘nths’: nths xs z = ...
07:24:41 <lambdabot>  
07:24:41 <lambdabot>  <no location info>:
07:25:01 <chirpsalot> > map (nths ['A', 'B', 'C', 'D']) [1..4]
07:25:03 <lambdabot>  Couldn't match expected type ‘(a, t)’
07:25:03 <lambdabot>              with actual type ‘GHC.Types.Char’Couldn't match expected type ‘(...
07:25:03 <lambdabot>              with actual type ‘GHC.Types.Char’Couldn't match expected type ‘(...
07:25:03 <lambdabot>              with actual type ‘GHC.Types.Char’Couldn't match expected type ‘(...
07:25:03 <lambdabot>              with actual type ‘GHC.Types.Char’
07:25:37 <chirpsalot> Errr, how do you make it forget the previous definition?
07:25:44 <chirpsalot> @let nths' xs z = map snd . filter (\(x, y) -> x `mod` z == 0) $ zip [0..] xs
07:25:46 <lambdabot>  Defined.
07:25:55 <chirpsalot> > map (nths' "ABCD") [1..4]
07:25:57 <lambdabot>  ["ABCD","AC","AD","A"]
07:26:21 <chirpsalot> Copenragen: I did it, and I totally didn't fumble at all >_<. Sorry about the lambdabot spam.
07:26:30 <chirpsalot> ...
07:26:33 <chirpsalot> I am one off.
07:26:34 <Copenragen> chirpsalot should be ["ABCD", "BD", "C", "D"]
07:26:37 <Copenragen> yup
07:26:40 <pavonia> Copenragen: If you want to cheat, here a complete skips function that uses this version of nth: http://lpaste.net/113894
07:26:44 <chirpsalot> AGGGGH.
07:26:49 <chirpsalot> Copenragen: well, easy fix :P.
07:27:11 <Copenragen> more interested to hear how you guys are thinking about this then getting the answer :)
07:27:22 <Copenragen> How should/do you approach this?
07:27:34 <Copenragen> thanks pavonia
07:28:15 <chirpsalot> @let nths'' xs z = map snd . filter (\(x, y) -> x `mod` z == 0) $ zip [1..] xs
07:28:16 <Copenragen> pavonia tails?
07:28:16 <lambdabot>  Defined.
07:28:20 <chirpsalot> > map (nths' "ABCD") [1..4]
07:28:21 <Copenragen> tail?
07:28:22 <lambdabot>  ["ABCD","AC","AD","A"]
07:28:27 <chirpsalot> > map (nths'' "ABCD") [1..4]
07:28:28 <lambdabot>  ["ABCD","BD","C","D"]
07:28:33 <chirpsalot> Yay?
07:28:42 <Copenragen> looks good :)
07:28:59 <Copenragen> > map (nths'' "HELLO!") [1..6]
07:29:00 <lambdabot>  ["HELLO!","EL!","L!","L","O","!"]
07:29:09 <chirpsalot> Now I am never going to use lambdabot again, lest I embarrass myself any further :P.
07:29:19 <Copenragen> haha all good
07:29:33 <pavonia> > tails "abcde"
07:29:34 <lambdabot>  ["abcde","bcde","cde","de","e",""]
07:29:41 <Copenragen> pavonia ah ok
07:29:48 <Copenragen> i think i need Data.List or something
07:30:00 <pavonia> Right
07:30:00 <Copenragen> your solution looks a lot simpler
07:30:03 <Copenragen> i think...
07:30:10 <Copenragen> so i want to try to break that down for a minute
07:30:17 * Copenragen takes a closer look
07:30:58 <Copenragen> interesting
07:31:11 <Copenragen> tails is cool :)
07:32:18 <pavonia> Okay, I have to go. See you!
07:33:28 <edwardk> @tell insitu the cookie thing is because 'cookie' is a traversal. you can have _many_ cookies with the same name if you think about it. the protocol doesn't stop that. so the library lets you get them all. to set a cookie that isn't there you need to grab the cookie jar and edit it. traversals when set only change the things that are already there. -- re
07:33:29 <edwardk> PortNum, PortNum being endian swapped has been around forever. =(
07:33:29 <lambdabot> Consider it noted.
07:34:18 <lpaste> kadoban pasted “skips” at http://lpaste.net/113896
07:34:27 <kadoban> Copenragen: ^ that's my attempt
07:34:34 <kadoban> Not as short as the others though, heh.
07:35:24 <Copenragen> kadoban thank you!
07:38:33 <gilligan-> Can someone explain to me why this cabal file isn't syntactically correct ? cabal check fails with ``cabal: ghci-ng.cabal:32: Parse of field 'default-extensions' failed.``  :  http://lpaste.net/113897
07:39:14 <kadoban> gilligan-: I'm guessing because your build-depends is as indented as the things under default-extensions
07:40:24 <dcoutts_> gilligan-: right, as kadoban says, the build-depends looks like it's part of the default-extensions field
07:40:28 <dcoutts_> and it'll be parsed as such
07:40:45 <gilligan-> meeh its an indentation fail indeed
07:40:48 <gilligan-> i just realized
07:40:51 <gilligan-> thank you guys
07:43:21 <zennist> I'm trying to figure out what happens when we compose functions of type a->b->c
07:43:41 <zennist> take 'const' for example
07:43:47 <zennist> of type a->b->a
07:44:18 <zennist> If I compose it with another function, that function should be one that can make use the type b->a right?
07:44:23 <EvanR> :t (\a -> \b -> c) . (\d -> \e -> f)
07:44:24 <lambdabot>     No instance for (FromExpr a0) arising from a use of ‘f’
07:44:25 <lambdabot>     The type variable ‘a0’ is ambiguous
07:44:25 <lambdabot>     Note: there are several potential instances:
07:44:53 <Iceland_jack> zennist: Do you mean (undefined :: a -> b -> a) . f?
07:44:55 <clrnd> soooo anyone knows of a library that displays dates graphically on a terminal? this is ridiculously specific
07:45:05 <clrnd> like unix's cal
07:45:33 <Iceland_jack> zennist: Keep in mind that (x -> y -> z) is the same as (x -> (y -> z))
07:45:43 <EvanR> clrnd: you could shell exec cal
07:45:57 <zennist> Iceland_jack: yes, if f is of the type c->a->b
07:46:44 <zennist> Iceland_jack: I'm in the impression that ($4) . const 5 should work
07:46:46 <zennist> but no
07:46:53 <zennist> my type-foo is still pretty bad
07:46:59 <Iceland_jack> Ah okay, let's cover that example
07:47:00 <zipper> Could I get help with the function loadData in https://gist.github.com/urbanslug/54b1cd58c82a27539f71
07:47:06 <zipper> It's the very last function
07:47:21 <Iceland_jack> For simplicity let's say that ($ 4) has type '(Int -> b) -> b'
07:47:41 <Splike> pl \x y -> x y
07:47:49 <bolmar> :t flip (.) const
07:47:50 <lambdabot> ((b -> a) -> c) -> a -> c
07:47:54 <zennist> Iceland_jack: yes
07:48:29 <Iceland_jack> Since (.) has type:
07:48:29 <Iceland_jack>     (b -> c) -> (a -> b) -> (a -> c)
07:48:29 <Iceland_jack> applying it to ($ 4) will unify the type '(Int -> b) -> b' with 'b -> c'
07:48:49 <zennist> Iceland_jack: of course
07:48:49 <Splike> :t (\xs -> zip xs (tail xs))
07:48:50 <lambdabot> [b] -> [(b, b)]
07:49:20 <trap_exit> http://erlang.org/pipermail/erlang-questions/2011-May/058768.html <-- this is fasicnating -- is there a writeup of this from a haskell view ?
07:49:34 <Iceland_jack> So:
07:49:34 <Iceland_jack>     (.) :: (b -> c) -> (a -> b) -> (a -> c)
07:49:34 <Iceland_jack>     (.) :: ((Int -> x) -> x) -> (a -> (Int -> x)) -> (a -> x)
07:49:37 <Splike> @pl (\xs -> zip xs (tail xs))
07:49:38 <lambdabot> ap zip tail
07:49:40 <trap_exit> especially since all haskell functions ar epure, why do we have modules?
07:49:49 <trap_exit> why not just a global k/v of names -> haskell functions
07:50:05 <clrnd> EvanR, well no, I wanted to display text inside some day's, some numbers, etc, nervermind then
07:50:11 <clrnd> days*
07:50:31 <zennist> Iceland_jack: ((+4) . const 5) 6
07:50:37 <zennist> Iceland_jack: this works
07:50:42 <zennist> but (+4) . const 5 6 not
07:50:49 <Iceland_jack> Yes those are different things
07:51:03 <zennist> in the second case what is the evaluation flow there ..?
07:51:15 <Iceland_jack> One is '(const 5 6) + 4', the other is (+ 4) . (const 5 6)
07:51:28 <Iceland_jack> 'const 5 6' is not a function, so that won't type check
07:52:08 <zennist> I see , so . has a pretty low precedence
07:52:21 <EvanR> :i (.)
07:52:24 <Iceland_jack> Actually it has a very high precedence
07:52:34 <Iceland_jack> But function application goes first
07:52:56 <zennist> Iceland_jack: so I totally see my problem now. (($4).const) 5 works
07:53:14 <Iceland_jack> Okay cool
07:58:46 <zennist> how can I have a function f such that (g.f) a b is same as g b
07:59:04 <zennist> dropping the first parameter
07:59:09 <zennist> essentially
07:59:28 <dword> 5
08:00:00 <nyuszika7h> !ping
08:00:02 <nyuszika7h> !hoogle (***)
08:00:12 <nyuszika7h> what's up with lambdabot
08:00:22 <nyuszika7h> oh wait it's @
08:00:34 <zennist> I always always stumble when dealing with a composition that's going to receive two parameters
08:00:41 <nyuszika7h> it should reply without prefix in PM >_>
08:00:54 <zennist> if someone can give me a hint on that it would be really great...
08:01:59 <Splike> @pl \x = iterate (\a -> (a + x / a) / 2) 1.0
08:01:59 <lambdabot> (line 1, column 4):
08:01:59 <Iceland_jack> zennist: Try expanding the definition of (.)
08:01:59 <lambdabot> unexpected "="
08:01:59 <lambdabot> expecting operator, pattern or "->"
08:02:13 <Splike> @pl \x -> iterate (\a -> (a + x / a) / 2) 1.0
08:02:13 <lambdabot> (. 0) . flip iterate 1 . flip flip 2 . ((/) .) . ap (+) . (/)
08:02:19 <Splike> what the....
08:03:00 <Iceland_jack> Basically you can't pick an "f" such that it works for every "g"
08:03:05 <Iceland_jack> Ther reverse is possible though
08:03:21 <zennist> Iceland_jack: I've got a solution now
08:03:48 <zennist> to make (g.f) a b same as g b we can just have (const g) a b
08:03:55 <zennist> I suppose I was pretty slow
08:04:21 <Splike> :t   (. 0) . flip iterate 1 . flip flip 2 . ((/) .) . ap (+) . (/)
08:04:22 <lambdabot>     Couldn't match type ‘[a1]’ with ‘b0 -> c’
08:04:22 <lambdabot>     Expected type: (a1 -> a1) -> a1 -> b0 -> c
08:04:22 <lambdabot>       Actual type: (a1 -> a1) -> a1 -> [a1]
08:12:58 <absence> is there a simple way to sum a [ZipList Int]?
08:15:20 <dmj`> :t \zl -> sum . getZipList $ zl
08:15:21 <lambdabot> Num c => ZipList c -> c
08:15:52 <ClaudiusMaximus> absence: if it were ZipList (Sum Int) , and if ZipList has the obvious monoid instance, you could use  mconcat
08:16:29 <dmj`> :t \zs -> let f = sum . getZipList in map f (zs :: [ZipList Int])
08:16:30 <lambdabot> [ZipList Int] -> [Int]
08:16:37 <ClaudiusMaximus> absence: would be mconcat :: [ZipList (Sum Int)] -> ZipList (Sum Int)
08:16:47 <dmj`> :t \zs -> let f = sum . getZipList in sum $ map f (zs :: [ZipList Int])
08:16:48 <lambdabot> [ZipList Int] -> Int
08:17:49 <absence> note that i don't want to sum together each ZipList individually, but element-wise
08:18:50 <absence> so [ZipList [a,b,c],ZipList [d,e,f]] would become ZipList [a+d,b+e,c+f]
08:18:59 <dmj`> oh
08:19:36 <Iceland_jack> > (+) <$> ZipList [a,b,c] <*> ZipList [d,e,f]
08:19:38 <lambdabot>  ZipList {getZipList = [a + d,b + e,c + f]}
08:20:05 <Iceland_jack> or:
08:20:05 <Iceland_jack> > liftA2 (+) (ZipList [a,b,c]) (ZipList [d,e,f])
08:20:07 <lambdabot>  ZipList {getZipList = [a + d,b + e,c + f]}
08:20:12 <Splike> @pl all (p x) (f x)
08:20:12 <lambdabot> all (p x) (f x)
08:21:01 <geekosaur> if you want it to remove points, you need to tell it which to remove
08:21:10 <absence> Iceland_jack: that's the right idea, the trouble is that the length of [ZipList Int] isn't known :)
08:21:10 <geekosaur> @pl \p f x -> all (p x) (f x)
08:21:10 <lambdabot> liftM2 all
08:21:20 <dmj`> absence: there's no way to zip them w/o first knowing how many to zip
08:22:36 <absence> dmj`: what D: and here i thought i finally discovered a use for ZipList
08:23:33 <dmj`> absence: what is your use case? Maybe there's another way to view the problem
08:23:44 <dmj`> :t zipWith
08:23:45 <lambdabot> (a -> b -> c) -> [a] -> [b] -> [c]
08:24:18 <dmj`> maybe there is a way to do it, I just don't know...
08:25:43 <absence> dmj`: basically [[Int]] -> [Int], only in the way described above (element-wise sum) rather than the obvious way
08:26:09 <Splike> @pl \n -> n * n <= p
08:26:09 <lambdabot> (<= p) . join (*)
08:27:05 <Iceland_jack> absence: And what should happen if one list is shorter?
08:27:21 <Iceland_jack> You don't want truncation? (which is what ZipList and zipWith would result in)
08:27:21 <Splike> @pl \n -> n**2
08:27:21 <lambdabot> (** 2)
08:27:39 <absence> Iceland_jack: doesn't matter, they'll be equal
08:27:44 <absence> equal length
08:27:50 <dmj`> absence: that means you'd need a function that had the same amount of parameters as the list size in order to sum them
08:28:03 <dmj`> as the amount of lists, not the list size
08:28:17 <exio4> that sounds like foldr (zipWith sum
08:28:33 <dmj`> exio4: zipWith has a hard constraint of two lists
08:28:37 <exio4> that sounds like foldr (zipWith sum) (repeat 0) ***
08:28:38 <dmj`> he has n many lists
08:28:49 <exio4> @type foldr (zipWith sum) (repeat 0)
08:28:50 <lambdabot> (Num (b -> b), Num b) => [[[b -> b]]] -> [b]
08:29:00 <absence> exio4: i guess it would be zipWith (+)
08:29:05 <exio4> @type foldr (zipWith (+)) (repeat 0)
08:29:06 <lambdabot> Num b => [[b]] -> [b]
08:29:07 <exio4> yeah :P
08:29:16 <Iceland_jack> > foldr (liftA2 (+)) (pure 0) [ZipList [a,b,c],ZipList [d,e,f]]
08:29:18 <lambdabot>  ZipList {getZipList = [a + (d + 0),b + (e + 0),c + (f + 0)]}
08:29:53 <Iceland_jack> 'pure' for ZipLists is basically repeat
08:29:55 <Iceland_jack> > pure 0 :: ZipList Int
08:29:56 <lambdabot>  ZipList {getZipList = [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0...
08:30:27 <absence> > foldr (zipWith (+)) (repeat 0) (replicate 3 [1,2,3])
08:30:29 <lambdabot>  [3,6,9]
08:30:32 <Iceland_jack> Without the base case:
08:30:33 <Iceland_jack> > foldr1 (liftA2 (+)) [ZipList [a,b,c],ZipList [d,e,f]]
08:30:34 <lambdabot>  ZipList {getZipList = [a + d,b + e,c + f]}
08:30:58 <absence> Iceland_jack: number of lists isn't known at compile-time
08:31:14 <Iceland_jack> Well then they get truncated to the length of the shortest list
08:31:34 <absence> Iceland_jack: not that number. the "2" in liftA2
08:31:42 <absence> Iceland_jack: it won't be 2
08:32:01 <exio4> "liftA2 (+)" with ZipList is "zipWith (+)"
08:32:06 <Iceland_jack> That doesn't specify the number or the length of the lists
08:32:18 <absence> oooh
08:32:27 <Iceland_jack> > foldr1 (liftA2 (+)) (replicate 5 (ZipList [a,b,c]))
08:32:28 <absence> ok i follow
08:32:28 <lambdabot>  ZipList {getZipList = [a + (a + (a + (a + a))),b + (b + (b + (b + b))),c + (...
08:33:49 <absence> nice trick with the foldr1 too
08:42:01 <nick_cannon> Can someone please explain why I am getting the error I that I am on line 48. http://lpaste.net/3574657244161114112
08:43:41 <absence> thanks, worked like a charm :)
08:45:23 <absence> nick_cannon: i think the parameters in the type signature are in the wrong order
08:46:19 <nick_cannon> absence: so it should be addLayer (Sandwich y) x ?
08:46:35 <nick_cannon> absence: wow...thank you
08:46:38 <nick_cannon> I would have never guessed
08:46:47 <absence> nick_cannon: yes, or addLayar :: Layer -> Sandwich -> Sandwich
08:46:53 <absence> if you prefer the other order
08:47:35 <nick_cannon> absence: thanks a bunch
08:49:39 <EvanR> tried to look up information on "HBC, haskell B compiler" and found not much
08:49:56 <dcoutts_> it's pretty old stuff
09:03:21 <supersym> \q
09:12:55 <Schluri> @pl  (\x -> if even x then div x 2 else pred x `div` negate 2)
09:12:55 <lambdabot> ap (liftM2 if' even (flip div 2)) ((`div` -2) . pred)
09:14:59 <nick_cannon> absence: I fixed the ordering to be addLayer (Sandwich y) x = Sandwich (x:y) ; How do I actually call this function? I'm trying to make the case where there is no sandwich and I create a new one. But first I want to figure ot how to execute the first case.
09:15:00 <deech> I currently have a .cabal file generated using `autoconf`. Is there a way of getting cabal to run `autoconf` for me if a .cabal file doesn't exist?
09:23:33 <dcoutts_> deech: no, technically speaking it violates the cabal spec. Cabal tools have to start from a .cabal file. Cabal packages can use autoconf as part of the configure phase, but not to generate the .cabal file to start with
09:24:00 <dcoutts_> (it'd be like an configure.ac file itself being generated by autoconf)
09:29:12 <youssefkababe> Hi
09:29:59 <youssefkababe> Does anybody know how to install Haskell in Ubuntu?
09:30:28 <Lowl3v3l> youssefkababe, well you can simply install ghc and leksah via apt-get
09:31:46 <sivteck> youssefkababe, https://github.com/bitemyapp/learnhaskell#ubuntu (PPA for ghc 7.8.3)
09:33:01 <youssefkababe> Okay thank you guys
09:33:22 <deech> dcoutts_: That sounds good. The use case is that I'm writing C bindings and autoconf already has the command line string that specifies the included libs. Would be nice to get them in the `ghc-Options` section somehow.
09:33:44 <dcoutts_> deech: oh that's easy then
09:34:16 <dcoutts_> deech: see the Cabal use guide on the autoconf build type, about running an external configure and getting info out
09:34:27 <dcoutts_> erm. autoconf/configure
09:34:36 <deech> Ah, great! Thanks!
09:34:56 <dcoutts_> deech: the trick is that the ./configure generates a particular file with a particular format, and that build info is merged in to the build
09:35:30 <deech> Neat. I'll look at it.
09:35:40 <nick_cannon> absence: I don't mean to nag, you there?
09:36:36 <ij> Does bracket eat exceptions unreported?
09:36:43 <ij> s/unreported/for dinner
09:39:30 <joneshf-laptop> edwardk, in bifunctors, some of the haddock comments appear to reference other functions. Is that intended? https://github.com/ekmett/bifunctors/blob/master/src/Data/Biapplicative.hs#L37 for instance
09:39:49 <ij> It shouldn't, but the line I'm suspicious about is failing verbosely in ghci, but not from the binary.
09:40:18 <edwardk> a '*>' b ≡ 'const' 'id' '<$>' a '<*>' b -- cause those things to link to the standard library functions
09:40:33 <edwardk> that way if someone doesn't know what 'id' is they can find out ;)
09:40:54 <edwardk> i do it for consistency
09:41:36 <joneshf-laptop> edwardk, sorry, i meant the function is (*>>), but the doc is for (*>)
09:41:43 <edwardk> it also makes it show up as highlighting anything that is a known name from elsewhere leaving the local names that are just placeholders to be in block, creating a visual contrast in the haddocks
09:41:44 <edwardk> oh
09:41:45 <edwardk> that
09:41:48 <edwardk> that's a bug =)
09:41:51 <joneshf-laptop> k
09:42:14 <joneshf-laptop> want a pr, or will you take care of it yourself?
09:42:25 <edwardk> go for it
09:42:31 <edwardk> if you wait on me you may wait a while ;)
09:43:03 <edwardk> if you see a documentation bug, etc. in pretty much anything i write just feel free to hit me with a PR.
09:44:07 <merijn> joneshf-laptop: Don't do it! Before you know it you wake up and are magically a maintainer on his packages! :p
09:44:54 <absence> nick_cannon: not sure what you mean. you want an empty Sandwich?
09:45:46 <joneshf-laptop> merijn, might not have to worry about it, can't get it to build in a sandbox so i'll leave it to someone else
09:45:48 <absence> shouldn't passing --extra-lib-dirs to cabal result in a similar -L to gcc?
09:46:15 <dcoutts_> absence: yes
09:46:23 <absence> oh nm, it's gcc -c
09:46:36 <dcoutts_> no, -L is right
09:46:53 <dcoutts_> gcc -c just means compile without linking
09:47:58 <absence> dcoutts_: yes, i was looking for -L flags in a -c command line
09:50:32 <absence> can i make cabal keep the temp .c file it uses to figure out if a library is installed?
09:52:49 <dcoutts_> absence: the .c file is totally trivial, just #includes the .h files and has a main
09:53:45 <absence> dcoutts_: yes. i want that main :)
09:53:47 <nick_cannon> How do I make a case for if a function that is supposed to take two arugments, is only given one?
09:54:05 <dcoutts_> absence: int main(void) { return 0; }
09:54:31 <clrnd> nick_cannon, the second argument could be a Maybe something
09:54:33 <absence> dcoutts_: ah, so it doesn't actually call anything from the libs
09:54:48 <dcoutts_> absence: no, just tries to link
09:54:56 <clrnd> this way also it's explicit that it's optional
09:57:38 <nick_cannon> clrnd: hmm..maybe I should add some context to the scenario. I am adding a new layer to a data type "Sandwich", when the sandwich hasn't been created. I do however have a function that creates a sandwich.
09:58:44 <absence> nick_cannon: create the empty sandwich first, then add a layer to it?
09:58:47 <EvanR> unsafeMakeSandwich :: IO Sandwich
09:58:59 <clrnd> nick_cannon, what do you mean by "layer"?
09:59:10 <clrnd> jaja
09:59:10 <nick_cannon> clrnd: Like turkey then cheese then tomato
09:59:12 <nick_cannon> layers
09:59:17 <clrnd> oh lol
09:59:17 <michaelt> unsafeMakeSandwich = return (Layers Nothing Nothing Nothing Nothing)
09:59:19 <nick_cannon> haha
09:59:33 <nick_cannon> hm
09:59:40 <clrnd> Maybes for all
09:59:45 <nick_cannon> Can someone please explain why I am getting the erhttp://lpaste.net/3574657244161114112
09:59:51 <nick_cannon> http://lpaste.net/3574657244161114112
09:59:54 <nick_cannon> crap, there is the code
09:59:56 <absence> nick_cannon: addLayar turkey (bareSandwich)
09:59:58 <nick_cannon> ignore he broken function at the bottom
10:00:11 <absence> uh, never mind the parenthesis :)
10:00:19 <EvanR> data Sandwich = BreadL Meat Sandwich | BreadR Cheese Sandwich
10:00:22 <EvanR> infinite sandwich
10:00:28 <absence> assuming bareSandwich makes a new sandwich
10:00:54 <clrnd> JAJAJA
10:01:01 <benzrf> EvanR: your doing it wrong
10:01:05 <benzrf> you may mean:
10:01:16 <benzrf> data Sandwich = Bread Sandwich | Meat Sandwich | Cheese Sandwich
10:01:20 <nick_cannon> Guys. I posted the core code. So I don't leave you to guess
10:01:26 <nick_cannon> Should have done that sooner, I suppose
10:01:27 <nick_cannon> Sorry
10:01:27 <nick_cannon> lol
10:01:33 <benzrf> no w8
10:01:33 <benzrf> hmm
10:01:52 <EvanR> benzrf: same thing but mine can customize the type of meat and type of cheese, and i made it so you cant have just bread
10:01:59 <clrnd> nick_cannon, and what do you need ...
10:02:05 <EvanR> for a similar reason i said you cant have an empty sandwich
10:02:15 <EvanR> just bread is an "empty sandwich" too ;)
10:02:34 <nick_cannon> clrnd: addLayer (Sandwich y) x = Sandwich (x:y) this is my functon in which I can add layers to an existing sandwich
10:02:44 <michaelt> addLayer :: Sandwich -> Layer -> Sandwich has swapped the parameters
10:02:45 <nick_cannon> I'm trying to figure out how to add layers to the sandwich when it hasn't been created
10:02:52 <nick_cannon> which means creating a sandwich and such
10:03:45 <clrnd> nick_cannon, oh, and how should it's signature look like? makeLayer :: Layer -> Sandwich ?
10:04:01 <nick_cannon> clrnd: Sandwich -> Layer -> Sandwich
10:04:25 * michaelt thinks this need sexier types; make icky sandwiches unrepresentable. 
10:04:28 <clrnd> but you said the sandwich wasn't yet created
10:04:48 <nick_cannon> clrnd: That is just one case, the other is that the sandwich has been created
10:05:01 <michaelt> the inferred type will be addLayer :: Layer -> Sandwich -> Sandwich
10:05:12 <clrnd>  Maybe Sandwich -> Layer -> Sandwich :P
10:05:48 <EvanR> sandwich complete, able to build any computable sandwich
10:06:00 <clrnd> EvanR, lold
10:06:14 <nick_cannon> clrnd: so should I make a seperate function?
10:06:15 <EvanR> is it lunch yet
10:06:19 <exio4> where do you order turing-complete sandwich?
10:06:20 <clrnd> dressing combinator, recursive sandwiches
10:07:00 <clrnd> nick_cannon, I'd do it like this: addLayer (Just s) l = Sandwich (x:y)
10:07:05 <clrnd> worng paste
10:07:08 <nick_cannon> EvanR: you will eat when I am damn well and ready
10:07:12 <nick_cannon> lol
10:07:29 <clrnd> addLayer (Just (Sandwich ls)) l = Sandwich (l:ls)
10:07:40 <clrnd> addLayer Nothing l = Sandwich [l]
10:07:53 <Schluri> @pl reachable [] _ _= False
10:07:53 <lambdabot> (line 1, column 14):
10:07:53 <Schluri> reachable xs y z 	= elem (y,z) xs || 	or [reachable (delete t xs) (snd t) z|t<-[x| x<-xs , fst x == y ]]
10:07:53 <lambdabot> unexpected '_'
10:07:53 <lambdabot> expecting variable, "(", operator or end of input
10:08:01 <absence> nick_cannon: or just create the sandwich separately, then use addLayer on the empty sandwich
10:08:11 <Schluri> @pl reachable xs y z 	= elem (y,z) xs || 	or [reachable (delete t xs) (snd t) z|t<-[x| x<-xs , fst x == y ]]
10:08:15 <lambdabot> reachable = fix (ap (ap . ((ap . ((||) .)) .) . flip (flip . (elem .) . (,))) . (((or .) .) .) . flip flip [] . ((flip . ((flip . ((:) .)) .)) .) . flip ap ((. (return . (fst x ==))) . (:) . ((x | x) <-)) . (((.) . flip . ((<-) .)) .) . flip flip t . (flip .) . (((|) .) .) . flip flip (snd t) . (. delete t))
10:08:15 <lambdabot> optimization suspended, use @pl-resume to continue.
10:08:26 <Schluri> @pl-resume
10:08:29 <lambdabot> reachable = fix (ap (ap . (liftM2 (||) .) . flip (flip . (elem .) . (,))) . (((or .) .) .) . flip flip [] . ((flip . ((flip . ((:) .)) .)) .) . (`ap` ((. (return . (fst x ==))) . (:) . ((x | x) <-))) . (((.) . flip . ((<-) .)) .) . flip flip t . ((flip . ((|) .)) .) . flip flip (snd t) . (. delete t))
10:08:32 <clrnd> should Sandwich form a Monoid together with Cola?
10:08:52 <exio4> with Drink
10:08:57 <nick_cannon> lol
10:09:17 <nick_cannon> clrnd:  Couldn't match expected type `Sandwich' with actual type `Maybe t0'
10:09:29 <nick_cannon> I made: addLayer Nothing x = Sanwich [x]
10:09:51 <michaelt> addLayer Nothing x = x
10:10:03 <clrnd> nick_cannon, your signature should be 'Maybe Sandwich -> Layer -> Sandwich'
10:10:32 * hackagebot charade 0.1.1.2 - Rapid prototyping websites with Snap and Heist  http://hackage.haskell.org/package/charade-0.1.1.2 (DougBeardsley)
10:10:36 <michaelt> addLayer Nothing s = s; addLayer (Just l) (Sandwich ls) = Sandwich (l:ls)
10:10:37 <EvanR> instance Monoid Sandwich where mempty = Just Bread, mappend s1 s2 = put contents of s1 inside s2 and discard the bread ;)
10:11:23 <clrnd> michaelt, that's giving back a layer on Nothing case
10:11:45 <michaelt> oh let me see, maybe I wasn't understanding
10:11:51 <clrnd> I may be confused
10:12:03 <chirpsalot> Tasty Haskell?
10:12:23 <EvanR> infinite sandwiches are high in calories
10:12:31 <clrnd> nick_cannon, http://lpaste.net/3574657244161114112
10:12:32 <absence> nick_cannon: addLayer (newSandwich Rye) (Cheese Cheddar)
10:12:37 <michaelt> clrnd: Oh i was working with the reverse order of parameters. There's some confusion around.  Is it a Maybe Sandwich?
10:12:53 <clrnd> michaelt, I think it is
10:12:55 <michaelt> Oh ok
10:12:59 <nick_cannon> absence: I realize that much. But I can't write that as the function can I?
10:13:18 <absence> nick_cannon: what do you mean "write that as the function"?
10:13:39 <clrnd> addLayer may be a fixpoint in a recursive sandwich
10:13:49 <EvanR> flip Pancake, fold Omelet
10:14:04 <nick_cannon> absence: nvm...I need a break
10:14:10 <saep> Ingredients are finite, so there must be a fix point.
10:14:18 <nick_cannon> I'm really confused now... thanks for your interpretation clrnd
10:14:21 <nick_cannon> Lol
10:14:25 <nick_cannon> I'll be back in 5
10:14:28 <saep> Assuming we don't leave earth.
10:15:01 <clrnd> nick_cannon, no problem, don't give up!
10:15:17 <josephle> lift saep -- too late
10:16:05 <nick_cannon> clrnd: No problem. I just need to train....https://www.youtube.com/watch?v=27F46WPVJBs
10:16:06 <absence> if i have a lib that works directly with files (via functions that take Handle), is there a way to trick it into using bytestrings instead?
10:17:08 <EvanR> absence: unsafeCoerce
10:17:11 * EvanR hides
10:17:28 <ReinH> EvanR... wouldn't actually work?
10:17:28 <michaelt> absence: what functions does it use?  there is always Data.ByteString.readFile :: FilePath -> IO ByteString etc
10:17:57 <ReinH> you can't magically unsafeCoerce a Handle into a ByteString
10:18:03 <michaelt> it would probably return something to do with the first Char
10:18:31 <EvanR> i was thinking coerce readFile into readFile, which returns a String or ByteString respectively
10:18:34 <michaelt> absence: oh wait, you want the file names to be ByteStrings?  I thought the file contents
10:18:35 <EvanR> and so that wouldnt work either
10:18:38 <ReinH> absence: Haskellers are generally not fond of "tricking" our code into doing things. We spend a lot of effort into preventing our code from tricking us...
10:19:34 <absence> ReinH: i didn't mean tricking in a bad way, more like an extra layer of abstraction that lets a function that e.g reads from a Handle read from a bytestring instead
10:20:15 <merijn> *nix only solution okay?
10:20:19 <ReinH> absence: You can just have two functions, one that reads from a Handle and calls the other, which takes a ByteString
10:20:20 <michaelt> what is the type you are thinking of, for 'reading the ByteString'? absence
10:20:51 <ReinH> ofc you have to consider opening/closing the handle as well
10:20:53 <merijn> absence: Are you okay with a *nix only solution? I imagine you can port it to windows, but it's non-trivial
10:21:10 <absence> ReinH: the third-party library does only have functions that take Handle
10:21:13 <michaelt> merijn seems to have divined absence 's meaning
10:21:19 <ReinH> absence: ah
10:21:20 <absence> merijn: i don't have unix
10:21:54 <merijn> Actually, I guess you can do it the ghetto way on windows if you don't care about security
10:22:12 <merijn> My idea was "open a pipe, write bytestring to pipe, hand library handle to pipe"
10:22:19 <merijn> But I dunno if windows supports pipes
10:22:36 <chirpsalot> merijn: in theory it does.
10:22:39 <ReinH> merijn: yeah, that would certainly work (on *nix)
10:22:47 <merijn> The even more ghetto (super insecure!) solution is: open a socket, write bytestring to socket and hand library the handle to the socket :p
10:22:58 <asayers_> absence: You could just ask the library maintainer to expose the internal functions you need. Likelihood is they consume ByteStrings under the hood already.
10:23:01 <ReinH> Windows theoretically has pipes http://msdn.microsoft.com/en-us/library/windows/desktop/aa365590(v=vs.85).aspx
10:23:02 <exio4> that sounds really hacky
10:23:16 <merijn> ReinH: Windows has named pipes, but I dunno how they work
10:23:20 <EvanR> change the library, either by asking the author or forking it
10:23:21 <ReinH> merijn: me neither
10:23:25 <EvanR> its probably easy
10:23:36 <ReinH> EvanR: +1
10:23:41 <ReinH> And then submit your changes back
10:24:06 <absence> asayers_: ouch. digging in the internals, and the handle is handed off to FFI
10:24:13 <ReinH> Seems weird for a library to base its public interface around handles anyway
10:24:20 <ReinH> absence: ouch indeed
10:24:23 <asayers_> oh, ok...
10:24:25 <michaelt> haha
10:24:38 <ReinH> absence: then pretty much your only option will be creating a handle via a named pipe or other OS mechanism
10:24:44 <ReinH> :/
10:25:41 <ReinH> I mean, worst case scenario you could write a temporary file, but that's pretty much a terrible idea.
10:26:19 <absence> ReinH: writing directly to a file doesn't fit very well with the rest of the pipes-based code
10:26:38 <ReinH> absence: argh :)
10:26:48 <ReinH> The library you're using makes me sad
10:27:31 <absence> ReinH: it's hsndfile. not sure if the underlying libsndfile forces the design or not
10:29:47 <exio4> is there a name for something like "(Functor f, Monoid (f m)) => f m"?
10:29:57 <absence> ReinH: i guess i'll just prepend a hardcoded header to the raw data for now and figure out something less stupid later ;p
10:30:33 * hackagebot entropy 0.3.4.1 - A platform independent entropy source  http://hackage.haskell.org/package/entropy-0.3.4.1 (ThomasDuBuisson)
10:31:48 <ReinH> absence: ugh
10:31:59 <asayers_> absence: looks like the C lib doesn't force the design: http://www.mega-nerd.com/libsndfile/api.html#open_virtual
10:32:19 <ReinH> exio4: `fold`able?
10:32:37 <lpaste> chirpsalot pasted “No title” at http://lpaste.net/1775568716008783872
10:32:58 <chirpsalot> I was looking at http://chimera.labs.oreilly.com/books/1230000000929/ch02.html#sec_par-eval-whnf and seq confuses me.
10:33:42 <chirpsalot> Why does WHNF stuff behave differently with the polymorphic literals?
10:33:50 <exio4> ReinH: heh, probably, didn't think about foldable
10:34:09 <ReinH> :t fold
10:34:10 <lambdabot> (Monoid m, Foldable t) => t m -> m
10:34:12 <ReinH> :)
10:35:33 * hackagebot h2048 0.2.0.1 - a haskell implementation of Game 2048  http://hackage.haskell.org/package/h2048-0.2.0.1 (javran)
10:35:48 <josephle> chrispalot: it seems z isn't defined in your first example?
10:36:05 <josephle> chirpsalot ^
10:36:16 <chirpsalot> josephle: oh, I forgot to add it in the paste.
10:36:25 <chirpsalot> It was the same thing.
10:36:30 <josephle> hmmm
10:36:32 <chirpsalot> (there were a few lines that I cut out)
10:36:55 <josephle> when I do your first example in ghci, I get "z = (_,_)". Maybe I just have a different version of ghc
10:37:01 <lpaste> chirpsalot revised “No title”: “No title” at http://lpaste.net/1775568716008783872
10:37:12 <chirpsalot> josephle: what version?
10:37:23 <chirpsalot> I'm on 7.8.3
10:37:32 <josephle> yeah, I have 7.6.3
10:38:05 <chirpsalot> I'll try that, one sec.
10:38:09 <theanalyst> hi, what would be a good (pref. free) book to start learning haskell
10:38:53 <albeit> On 7.8.3 I get the same as chirpsalot
10:39:07 <albeit> (Actually 7.8.2)
10:39:31 <chirpsalot> Strange. It seems the parallelism and concurrency book is aware of this, because they put the type signatures explicitly.
10:40:01 <absence> asayers_: nice
10:40:16 <nick_cannon> What if I wanted to make a function of type func :: Bool
10:40:20 <nick_cannon> How would I do that?
10:40:26 <nick_cannon> Or of func :: Int
10:40:29 <exio4> that is a constant
10:40:30 <nick_cannon> any type
10:41:03 <danneu> theanalyst: here are the 3 resources i've been using https://github.com/bitemyapp/learnhaskell#yorgey-course---do-this-first-this-is-the-primary-way-i-recommend-being-introduced-to-haskell
10:41:17 <jle`> nick_cannon: on ghci, or in source code?
10:41:35 <theanalyst> danneu: thanks
10:41:50 <danneu> theanalyst: there are two free books in that paragraph
10:42:00 <nick_cannon> jle`: source
10:42:08 <jle`> foo :: Int
10:42:09 <jle`> foo = 5
10:42:26 <nick_cannon> jle`: thanks
10:42:31 <jle`> are you following some sort of introductory course/guide by any chance?
10:45:14 <nick_cannon> jle`: yes
10:45:46 <jle`> coo :D
10:46:23 <chirpsalot> josephle: I get the same thing with 7.6.3...
10:46:35 <josephle> weird
10:47:06 <jaspervdj> asayers_: feel free to head over, can you bring beer and perhaps nachos?
10:47:54 <simpson> Ooh, nachos.
10:51:37 <chirpsalot> josephle: I'm going to check 7.4.2. I don't believe you :P
10:51:52 <josephle> well, maybe I just have a weird 7.6.3
10:51:54 <josephle> or something
10:52:06 <chirpsalot> josephle: any extensions or anything enabled in ghci?
10:52:25 <josephle> not that I know of
10:52:37 <chirpsalot> Very strange.
10:52:54 <josephle> anyway, I got myself 7.8.3 and can reproduce your original question
10:53:23 <chirpsalot> josephle: wooo. I'm not crazy. Now the real question is why that happens.
10:56:06 <lpaste> chirpsalot revised “No title”: “No title” at http://lpaste.net/1775568716008783872
10:56:37 <chirpsalot> I guess that's why. ghci doesn't know what the type of the parameters are, and maybe they're more data structures that could be displayed?
10:57:12 <chirpsalot> Though, that doesn't make sense either. Oh well, I guess it doesn't matter.
10:57:39 <albeit> I'm pretty curious about the answer, hopefully someone knows...
10:58:13 <albeit> Basically, why does forcing a type on a tuple cause it to be evaluated to its tuple form?
10:58:21 <josephle> well, the difference I see is that 7.6.3 thinks "z :: (Integer, Integer)" while 7.8.3 has the more general "(Num t1, Num t) => (t, t1)"
10:59:42 <albeit> Interesting, the same evaluation happens with lists as it does with tuples
11:00:34 <michi7x7> The type of the reader Monad is (->) r and operates on the respective last arguments, right? Could one make it operate on the first arguments by changing the type to (-> r) ?
11:01:03 <albeit> So when the values are known to be a typeclass instead of a type the data structure isnt evaluated?
11:01:46 <jle`> michi7x7: even if you allowed operator sections at the type level, you can't really make that into a Functor
11:01:52 <jle`> or into anything that would follow the Monad laws
11:01:58 <jle`> what would `return` even do?
11:02:23 <jle`> hm. i guess `return` would be \_ r -> r
11:02:32 <jle`> but you can't make it a Functor :O
11:02:37 <michi7x7> jle`: just like the ordinary Reader-monad ... const
11:02:50 <michi7x7> yeah
11:03:01 <jle`> in this case it'd be flip const, but i think you could break a few laws with this
11:03:04 <jle`> what would `fmap` be?
11:03:18 <jle`> what would (>>=) be?
11:03:54 <jle`> wait, no, it can't be (\_ r -> r) >_> that's the wrong type
11:04:00 <jle`> sorry.
11:04:05 <michi7x7> I was just wondering, because most functions take the static argument first (e.g. IO) and you could use this for the withXYZ-functions
11:04:24 <jle`> return :: (a -> r) -> (r -> r) ...?
11:05:13 <jle`> (>>=) :: (a -> r) -> (a -> (b -> r)) -> (b -> r) ...?
11:05:23 <jle`> i'm not sure you can make much sense out of that
11:05:28 <jle`> where would that final (b -> r) come from?
11:05:34 * hackagebot roman-numerals 0.5.1.5 - Parsing and pretty printing of Roman numerals  http://hackage.haskell.org/package/roman-numerals-0.5.1.5 (RoelVanDijk)
11:06:02 <michi7x7> usually you would do withFile "abc" $ \f -> hPutStr f "abc" ... with the reader operating on the first argument, this could become withFile "abc" $ hPutStr "abc" ... but this would only work in Monad context and does not make any sense like this
11:06:37 <michi7x7> this is also probably the biggest rule you'd brake
11:06:41 <michi7x7> *break
11:07:09 <jle`> what are the types of the things you are using there in the second example...?
11:08:18 <michi7x7> hPutStr :: FileHandle -> String -> IO () ... so I'd violate currying
11:09:22 <SrPx> Does anyone have access to the paper: "Comparison of Deforestation Techniques for Functional Programs and for Tree Transducers" ?
11:12:52 <Fuco> cabal gives me "cabal: Unknown build tool chs", why is that? I have c2hs installed and it's on my path
11:13:56 <predator117> SrPx: did you try google scholar?
11:14:56 <predator117> SrPx: found it on citeseer - http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.10.9265
11:15:09 <predator117> on the right under cached there is a pdf button
11:15:43 <dfeuer> What is the Eq1 class for? When is it better to use that instead of Eq?
11:16:37 <SrPx> predator117: oh I completely missed that, sorry!
11:16:41 <SrPx> and thanks
11:19:40 <statusfailed> > exp (0 :+ pi)
11:19:42 <lambdabot>  (-1.0) :+ 1.2246467991473532e-16
11:19:49 <statusfailed> Euler was wrong!
11:19:55 <Javran> is it possible to access the random seed in a RandT ?
11:20:13 <statusfailed> all hail the mathematical beauty of 1.2246467991473532e-16
11:20:35 * hackagebot yesod-auth-oauth2 0.0.11 - Library to authenticate with OAuth 2.0 for Yesod web applications.  http://hackage.haskell.org/package/yesod-auth-oauth2-0.0.11 (PatrickBrisbin)
11:20:39 <statusfailed> but in seriousness, that seems large?
11:21:11 <Javran> statusfailed: why 1.2246467991473532e-16 is large?
11:21:23 <monochrom> what is "large"?
11:22:45 <dfeuer> 10^(-16) < 8^(-16) = 2^(-3*16) = 2^(-48), so it's certainly not terrible
11:22:46 <statusfailed> large is "big enough to reasonably cause problems" I guess?
11:22:56 <statusfailed> on GHC 7.4 it came out as e-08
11:23:00 <statusfailed> which is _definitely_ large
11:23:13 <statusfailed> well :p
11:23:20 <statusfailed> larger
11:23:25 <Javran> in the other day I find that `floor $ logBase 10 1000 + 1` returns 3
11:23:26 <michi7x7> > exp (0 :+ pi) :: Complex Float
11:23:27 <lambdabot>  (-1.0) :+ (-8.742278e-8)
11:23:33 <michi7x7> _this_ is large
11:23:34 <dfeuer> We can only approximate pi so well.
11:23:55 <dfeuer> > logBase 10 1000 + 1
11:23:57 <lambdabot>  3.9999999999999996
11:23:59 <michi7x7> > pi :: Double
11:24:01 <lambdabot>  3.141592653589793
11:24:13 <Javran> dfeuer: so close to 4, but rounded to 3
11:24:15 <dfeuer> Javran, don't take floors of floating points and you won't have those sorts of problems.
11:24:42 <exio4> > sin π
11:24:43 <lambdabot>  Not in scope: ‘π’
11:24:46 <dfeuer> Seriously, you can't expect floating point to be sane.
11:24:53 <exio4> > sin pi
11:24:55 <lambdabot>  1.2246467991473532e-16
11:24:57 <dfeuer> Well, sane, maybe, but certainly not exact.
11:25:08 <oleo> how do you match multiples of pi when they are given only to some precision ?
11:25:30 <Javran> dfeuer: yeah, dealing with precisions surely leads to headaches
11:25:52 <dfeuer> oleo, you can only approximate.
11:25:56 <michi7x7> > fromRational (logBase 10 1000 + 1) :: Integer
11:25:57 <lambdabot>  No instance for (GHC.Real.Fractional GHC.Integer.Type.Integer)
11:25:57 <lambdabot>    arising from a use of ‘GHC.Real.fromRational’No instance for (GHC.Float.Fl...
11:25:57 <lambdabot>    arising from a use of ‘GHC.Float.logBase’
11:26:27 <dfeuer> oleo, you could alternatively use a type that precisely represents more/other things.
11:26:47 <dfeuer> I believe there are symbolic calculation libraries around.
11:26:56 <oleo> well i had a try but not go so far.....
11:27:03 <Javran> I'll better stick with `length . show` instead of doing mathematics
11:29:00 <dfeuer> Javran, if what you need is length . show, yeah. If you need something else, then no,
11:29:01 <dfeuer> .
11:32:33 <statusfailed> dfeuer: well i guess youre right, i just figured the e-08 value was a lot bigger than floaterror ive seen before
11:33:01 <statusfailed> didnt even consider yhe inaccuracy of pi
11:33:20 <statusfailed> i am satisfied :)
11:33:32 <tristanp> i need advice on whether i should learn haskell or not, anyone have a sec to listen? i can tell you what my goals are and see if it seems like a good idea
11:33:47 <tac_> sure tristanp
11:33:48 <wayne> tristanp: you don't have to ask to ask
11:33:57 <michi7x7> statusfailed: there is a Data.FixedPoint package you could try though
11:34:02 <statusfailed> tristanp: beware sample bias
11:34:03 <benmachine> eh, doesn't hurt to give an introduction if your question is long
11:34:16 <statusfailed> :D
11:34:31 <benmachine> what statusfailed says is true, if you ask #haskell if they think learning Haskell is a good idea, they will probably say yes
11:34:35 <benmachine> but in fairness that is actually true
11:35:24 <statusfailed> but do tell us your goals if you like
11:36:19 <michi7x7> > snd (5 `div` 0, "Haskell is love")
11:36:21 <lambdabot>  "Haskell is love"
11:37:58 <tristanp> I know JavaScript and ruby, write angular app for day job. I want to learn a functional language because it would provide a different way to look at programming and also because they appeal to my aesthetic sensibilities. i'm basically torn on which functional language to 'start' with
11:38:46 <tristanp> i've considered lisp, haskell and clojure, and looked into each a bit, but really don't have the wherewithal to choose
11:41:02 <Yxven> I chose Haskell because it is the purest functional language that I'm aware of
11:41:52 <UnrealQuester> haskell made programming fun again
11:41:56 <Yxven> but I don't know enough about the others to comment
11:42:05 <statusfailed> tristanp: i would say thats afine set of reasons. that haskell in the only candidate with static typing is even better i think
11:42:07 <Iceland_jack> tristanp: What UnrealQuester said
11:42:10 <Lowl3v3l> tristanp, well those aren't the only ones you might want to consider. But if it's only your desire to learn functional programming you should pick the one that feeld most natural to you. Maybe also consider Ocaml( a bit like C+ and my favorite Teaching-Language Racket( which is a lisp dialect)
11:42:15 <Yxven> I think haskell's best feature is the inferred typing which I don't think either of those have
11:42:26 <chirpsalot> Yxven: let me introduce you to nothing :). It is a language with absolutely no side effects.
11:43:00 <albeit> tristanp: Yep, what UnrealQuester said. it "made programming fun" (again)
11:43:21 <statusfailed> thirding the fun
11:44:02 <Lowl3v3l> i like functional programming in general... although i prefer Lisp for everyday-usage( Common Lisp and Racket and even if java needed some clojure)
11:44:26 <Lowl3v3l> i landed on haskell bc. a lot of maths is easier to implement in haskell than in lisp due to lazyness
11:44:27 <exio4> proglang ( https://www.coursera.org/course/proglang ) was really amazing when I took it
11:44:35 <benmachine> OCaml is what I use for a day job
11:44:48 <statusfailed> but also for me, types in haskell made me really a lotclearer about programming in geberal
11:44:49 <benmachine> it's got a lot of type inference
11:44:57 <benmachine> it's a very well-designed language, but Haskell is purer
11:45:08 <benmachine> Haskell is, I think, deeper as well
11:45:19 <benmachine> that's one beautiful thing about it, there are many layers
11:45:34 <benmachine> even once you're good enough to write serious programs to solve real problems, there's still more to learn
11:45:36 * hackagebot terminal-size 0.3.0 - Get terminal window height and width  http://hackage.haskell.org/package/terminal-size-0.3.0 (MatveyAksenov)
11:45:38 <benmachine> seemingly always more to learn
11:45:52 <exio4> that is what makes it so beautiful
11:46:35 <Lowl3v3l> although i  believe haskell is extremely well designed... to fit my style it lacks those epic macros that make lisp so beautiful.
11:47:00 <boxmein> total beginner here, how do I handle hGetChar failing due to end of Handle data, GHC 7.6.4
11:47:04 <boxmein> 7.6.3**
11:48:12 <boxmein> well, by total beginner I mean I'm writing a horrifying web server for the fun of it, in Haskell, but the point remains
11:48:12 <michi7x7> boxmein: check for EOF before reading the char?
11:48:33 <boxmein> michi7x7: hmm. methinks of race conditions, but then again I can't figure out any
11:50:05 <dreams> What do you guys think of the tutorial "Monadic Parser Combinators" by Hutton?
11:50:19 <michi7x7> boxmein: well, you can always catch the exception (bracket, catch, ...) but I believe checking first is a little more beautiful
11:50:40 <boxmein> michi7x7: sigh... I can't figure out a way to beautifully apply hIsEOF
11:51:01 <sivteck> dreams, do you mean http://www.cs.nott.ac.uk/~gmh//pearl.pdf ?
11:51:20 <statusfailed> tristanp: so i think in summary thats a "yes"
11:51:57 <tristanp> yes, thank you for the comments
11:52:09 <Cale> boxmein: You might just want to catch the exception
11:52:22 <benmachine> boxmein: I have always been annoyed by how this is not easier
11:52:33 <boxmein> Probably, except I'm no good at that either, I kinda wasted a while trying to find a catch function that worked
11:52:41 <benmachine> it's such an obvious thing to want to do but the standard library makes you jump through hoops
11:52:43 <dreams> sivteck: no. http://www.cs.nott.ac.uk/~gmh/monparsing.pdf
11:52:53 <Cale> You want to use Control.Exception stuff, e.g. try or catch from there
11:52:57 <benmachine> try is good
11:53:04 <Cale> :t Control.Exception.try
11:53:06 <lambdabot> Exception e => IO a -> IO (Either e a)
11:53:10 <Cale> :t Control.Exception.catch
11:53:11 <lambdabot> Exception e => IO a -> (e -> IO a) -> IO a
11:53:28 <dfeuer> statusfailed, if you calculate exp piminus, exp pi, and exp piplus, where piminus are pi shifted by one ulp, you'll see that the imaginary component of exp piminus is negative and that for exp piplus is positive, and that for exp pi is just about between them.
11:53:47 <dfeuer> I would say that's doing pretty well.
11:53:54 <Noinia> Hmm
11:54:08 <benmachine> boxmein: try (hGetLine h) :: IO (Either IOException String)
11:54:31 <benmachine> boxmein: one tricky thing about exceptions is you do sometimes need explicit annotations, e.g. if all you do with them is print them
11:54:38 <lpaste> Cale pasted “Fine grained IO errors.” at http://lpaste.net/113906
11:54:58 <Noinia> cabal build crashes with a ``[1]    70799 trace trap  cabal build'' when trying to build my software. Anwyone an idea what I can do to track down what the problem is?
11:55:20 <sivteck> dreams, ah, i have not read it, but the one i linked helped me understand alot of basic stuff after implementing it in valid haskell. (i am a newbie)
11:55:21 <Cale> ^^ that code might be of use to you, you can match against (EndOfFile e) in your handler and only catch end of file exceptions
11:55:33 <monochrom> boxmein: have you read my http://www.vex.net/~trebla/haskell/exception-tutorial.xhtml ?
11:55:34 <Cale> Don't ask me why this isn't part of the IO exception library already
11:55:42 <boxmein> monochrom: I have not
11:55:51 <Cale> Probably it's mostly my own laziness in not submitting proposals for stuff
11:56:10 <boxmein> benmachine: so that just types hGetLine's response as an Either exception/string?
11:56:18 <Cale> edwardk: ^^ feel free to steal the code I just pasted and put it somewhere in base, lol
11:56:24 <boxmein> benmachine: stupid question, I know
11:56:36 <benmachine> boxmein: the 'try' is important
11:56:58 <boxmein> benmachine: lol, I read that as part of your sentence, didn't consider it part of the code line
11:57:05 <monochrom> the "try" there is a function name, not an English suggestion :)
11:57:07 <benmachine> boxmein: oh, yeah, my bad, heh
11:57:08 <dreams> sivteck: the one I liked has a lambda expression parser.
11:57:09 <benmachine> :t try
11:57:10 <lambdabot> Exception e => IO a -> IO (Either e a)
11:57:34 <benmachine> 'try' turns an IO action that might throw an exception into one which might return an error value in Left
11:58:03 <nick_cannon> So I have a data type that is a list of other types. How do I specify data inside of the list that is within this type?
11:58:06 <dreams> sivteck: s/liked/linked/
11:59:25 <monochrom> nick_cannon: I think we need a concrete example
11:59:39 <Cale> nick_cannon: You are using words in a way which is very confusing to the point that I don't know how to respond to your question :)
11:59:56 <nick_cannon> monochrom Cale: one moment please. Yeah I tend to do that...
12:00:31 <nick_cannon> monochrom: http://lpaste.net/113907
12:00:33 <nick_cannon> Cale ^
12:00:53 <monochrom> what is Layer? is it important?
12:00:53 <Cale> nick_cannon: Okay, so this is not a list of types, it's a list of Layers :)
12:01:10 <nick_cannon> Cale: Layer is a type
12:01:11 <tristanp> i can investigate types with :type something, but how do i do that for functions like +, -, /. :type + is a parse error
12:01:18 <Cale> nick_cannon: Yes, a single type
12:01:24 <clrnd> tristanp, :t (+)
12:01:25 <Cale> nick_cannon: and its values are not types
12:01:27 <nick_cannon> Cale: that contains other types.
12:01:27 <Cale> (presumably)
12:01:29 <nick_cannon> yeah
12:01:31 <tristanp> clrnd: thanks
12:01:36 <monochrom> perhaps you're asking how to define Layer. to do this, write a separate line "data Layer = ..."
12:01:43 <boxmein> Cale: The catch approach worked fine, and left me out of a lot of typing :P
12:01:46 <Cale> values and types are two different things in Haskell :)
12:01:53 <nick_cannon> Cale: oh,
12:01:55 <Cale> boxmein: cool :)
12:01:59 <benmachine> tristanp: :i + also works
12:02:05 <boxmein> Plus, my exception handling is un-sophisticated enough so that I don't need to actually know the details of the exception
12:02:10 <lucs> tristanp: Actually, +, -, etc. are operators, not functions, hence the different :t invocation.
12:02:16 <nick_cannon> Cale: http://lpaste.net/6901585993074212864
12:02:21 <Cale> nick_cannon: Types are compile-time-only things, values are things which are around at runtime
12:02:24 <dfeuer> Cale is here. Maybe he can explain the purpose of Eq1.
12:02:26 <boxmein> "if EOF error then the value is a null character"
12:02:27 <boxmein> lol
12:02:42 <clrnd> nick_cannon, you already had this working before
12:02:44 <tristanp> lucs: oh, my understanding was that they were functions with some exception made for the notation where you can feed two arguments on either side
12:02:49 <nick_cannon> clrnd: this is something else now
12:02:51 <nick_cannon> lol
12:02:54 <clrnd> haha
12:02:55 <nick_cannon> similiar though
12:02:58 <clrnd> what is it?
12:03:01 <nick_cannon> Okay
12:03:03 <sivteck> dreams, it's seems like it's level 2 ;p, thanks for the link!
12:03:07 <michi7x7> boxmein: don't forget that Haskell is lazy, so normally you could just read the whole string and operate on it like an endless stream. Haskell should do the buffering for you
12:03:15 <lucs> tristanp: Hopefully, someone more knowledgeable than me will answer that :/
12:03:19 <nick_cannon> clrnd: so now I want to detect if meat is in the sandwich and return true if it does
12:03:20 <monochrom> nick_cannon: so far this looks like valid code. what is the question?
12:03:29 <nick_cannon> monochrom: ^
12:04:11 <clrnd> nick_cannon, that's a good question, it can be done with pattern matching, but generally ...
12:04:26 <Cale> nick_cannon: Okay. I might just write something like: hasMeat (Sandwich ls) = not . null $ [m | Meat m <- ls]
12:04:34 <monochrom> has_meat (Sandwich xs) = any is_meat xs where ...
12:04:37 <clrnd> I mean you could do isMeat Meat = True ; isMeat _ = False
12:04:46 <nick_cannon> hm
12:04:54 <monochrom> is_meat (Meat _) = True; is_meat _ = False
12:04:56 <nick_cannon> thanks, I'm going to look into it a bit more
12:05:27 <Cale> monochrom: underscores_are_so_gauche
12:06:03 <Cale> :D
12:06:06 <monochrom> I can use ' in place of _ if you like
12:06:17 <monochrom> has'meat (Sandwich xs) = any is'meat xs
12:06:19 <shiona_> letMe_mixThemALL'TOGETHER
12:06:21 <Cale> hehe
12:06:28 <clrnd> ouch my eyes
12:06:33 <monochrom> Oleg does that, afterall
12:07:06 <Cale> I must say, I've always been slightly jealous of lispers' and Agda folks' ability to use hyphens
12:07:38 <clrnd> tree-cons, tree-search, tree-smurf
12:07:50 <edwardk> Cale: true that
12:07:51 <clrnd> MIT scheme even uses them instead of modules
12:07:52 <geekosaur> as if haskell doesn't already have enough problems with -
12:08:02 <clrnd> > -1
12:08:04 <lambdabot>  -1
12:08:08 <geekosaur> (unary minus, urgh)
12:08:14 <clrnd> > -1 + 7
12:08:15 <sivteck> > (-) 1
12:08:16 <lambdabot>  can't find file: L.hs
12:08:16 <lambdabot>  6
12:08:27 <michi7x7> :t ❤
12:08:28 <lambdabot> parse error on input ‘❤’
12:08:29 <clrnd> Lol.hs ?
12:08:33 <michi7x7> :t (❤)
12:08:34 <lambdabot> Not in scope: ‘❤’
12:08:35 <monochrom> caml case is easy to misread and misspell when you have acronyms, e.g., TDDDecorate
12:09:25 <monochrom> TDD_decorate is perfectly clear what's going on and how many D's there are
12:09:38 <kadoban> monochrom: TddDecorate
12:09:45 <exio4> @let (♥) = ($)
12:09:46 <lambdabot>  Defined.
12:10:19 <dreams> > head ♥ [1..]
12:10:20 <lambdabot>  1
12:11:27 <S11001001> monochrom: caml case is called match...with
12:11:35 <monochrom> haha
12:11:53 <S11001001> :}
12:11:53 <Cale> geekosaur: Well, I think the compromises made surrounding unary minus in Haskell are pretty fair actually.
12:12:23 <michi7x7> > negate 3 + 4
12:12:25 <lambdabot>  1
12:12:34 <Cale> geekosaur: It's mildly unfortunate that you don't get right sections of (-), but it's certainly nice to be able to write polynomials in the usual way.
12:12:39 <michi7x7> nobody uses unary minus :)
12:13:38 <nick_cannon> Can anyone explain to me what $ does in haskell?
12:13:48 <monochrom> . has a closer problem. Data.List, f.g, and [True..False]
12:13:49 <joelteon> it adds parentheses that you can't see
12:13:58 <Cale> nick_cannon: It's defined as  f $ x = f x
12:14:10 <Cale> nick_cannon: But $ is set to have really low precedence
12:14:11 <kadoban> nick_cannon: It's function application, just with low precedence.
12:14:37 <Cale> nick_cannon: So it behaves somewhat like the stuff to the left and right are parenthesised
12:14:40 <clrnd> it's a macro ... not
12:14:43 <monochrom> IQ question: in "Data.List", "f.g", and "[True..False]", one of them is different from the other two. which one?
12:14:54 <michi7x7> nick_cannon: f $ g x == f (g x)
12:14:54 <Cale> You'll see things like f . g . h $ k x
12:15:05 <Cale> and that means f (g (h (k x)))
12:15:07 <yunxing> Hi, just wondering why Monoid needs to have an identity function? It looks like most of its support (fold, writerMonad)can be done by using the first element as starting element
12:15:19 <clrnd> nick_cannon, haskell 'groups left', so f a b c == (((f a) b) c)
12:15:26 <FireFly> monochrom: Data.List, because the other two are expressions?
12:15:28 <Cale> Or leaving the composition in, it means (f . g . h) (k x)
12:15:31 <exio4> yunxing: if it doesn't have an identity, then it is a semigroup
12:15:47 <monochrom> no, [True..False] is not an expression. it is a syntax error.
12:15:48 <nick_cannon> thanks guys
12:15:58 <FireFly> oh
12:16:02 <FireFly> Hmm
12:16:03 <monochrom> the other two are not syntax errors.
12:16:17 <dreams> Cale: I thought its right associative?
12:16:28 <kadoban> yunxing: That's just what a monoid is. If you're asking why things require a monoid...IIRC there isn't a Semigroup typeclass built in (yet?)
12:16:30 <benmachine> on the other hand, (True..False) is not a syntax error, I believe
12:16:33 <Cale> dreams: The associativity doesn't matter if there's only one $ in the expression
12:16:41 <monochrom> "True.." is parsed as "from module True, operator dot". but then "[ <operator here> <constant here" ]" is a syntax error.
12:16:59 <monochrom> you have to write [True .. False] for the expression
12:17:23 <FireFly> I see
12:17:40 <yunxing> exio4: kaboban: I see, so I guess in theory a Semigroup typeclass should also be good for something like WriterMonad.
12:17:41 <dreams> Cale: if you have e $ e $ e..  it would start from the last e $ e right?
12:17:42 <Cale> > [True .. False]
12:17:43 <lambdabot>  []
12:18:07 <dreams> > [True..True]
12:18:07 <Cale> dreams: I'm not sure what you mean by "start from", but the right associativity means that you get e $ (e $ e)
12:18:08 <lambdabot>  A section must be enclosed in parentheses thus: (True.. True)Not in scope: ‘...
12:18:12 <boxmein> okay, another stupid question.
12:18:18 <boxmein> I have a Handle which is a listen socket
12:18:36 <Cale> dreams: Which is really unfortunate for a whole bunch of reasons, but it's kind of what we're stuck with, and some people rely on it.
12:18:53 <boxmein> I read a line from the handle, but then I want to pass the handle on to another function, which is kinda decided by the first line. But I also want the function itself to read the handle's first line when hGetLine is used
12:19:05 <dreams> Cale: yes, so in e $ (e $ e). (e $ e) is reduced first.
12:19:09 <Cale> no
12:19:17 <Cale> Haskell evaluation isn't strict
12:19:20 <boxmein> so hSeek h AbsoluteSeek 0 is the function, ...however hSeek is an illegal operation on a socket
12:19:25 <dreams> Cale: I don't mean evaluate.
12:19:31 <kadoban> yunxing: Actually I think that requires a Monoid, as it is now. Because doesn't it start with 'empty' as the log? But yes you could conceivably do the same thing with semigroup, if you forced the user of the API to give you the initial value.
12:19:41 <Cale> It's lazy, which means that the outermost reducible subexpression is reduced first.
12:19:49 <dreams> Cale: just reduce
12:19:59 <Cale> The first $ is reduced first
12:20:06 <dreams> Cale: ah
12:20:06 <Cale> It's applied to e and (e $ e)
12:21:03 <yunxing> kaboban: can I just use the first element it encounters as initial value?
12:21:07 <clrnd> mmm I need to get the current week, any one knows a shortcut?
12:21:36 <monochrom> Cale: it's a pity school math has to merge parsing and evaluation into the same thing
12:22:22 <kadoban> yunxing: I'm not sure. I guess you could, but if no value is ever set, I guess you'd have undefined or error or something, which isn't ideal probably.
12:22:30 <clrnd> not the current week, but the week of a particular date
12:22:40 <Cale> monochrom: Yeah, I didn't really get that from my school education, but a lot of people seem to be equally confused about it.
12:22:54 <Cale> monochrom: So I assume that's how they teach things somewhere.
12:22:56 <monochrom> hrm, no Haskell Weekly News this week!
12:22:56 <kadoban> yunxing: Because logging nothing isn't really an error in any way, so that'd be a bit off.
12:23:19 <clrnd> maybe it was to hard to get the current week in haskell
12:23:22 <yunxing> kadoban: Makes sense. Yeah I agree we still need an identity value for that case
12:23:22 <Cale> monochrom: At least when I was in school, nobody would evaluate 0 * (1 + 2 + ... + 1000) by doing the sum first :P
12:24:09 <josephle> "lazy" evaluation!
12:24:12 <exio4> Cale: we are all lazy? :P
12:24:50 <Cale> monochrom: It should just be called Haskell Sporadic News
12:24:54 <burp> I wonder how if compilers optimize this in like C/C++
12:25:06 <burp> how/if
12:25:35 <Cale> Interestingly, even Haskell won't typically optimise that
12:26:02 <sivteck> > 0 * Infinity
12:26:03 <lambdabot>  Not in scope: data constructor ‘Infinity’
12:26:09 <monochrom> I only know that gcc -O2 optimizes this into "L1: jmp L1": while (x > 0) { x *= 2; i++ }
12:26:16 <burp> well, that 0 * Infinity is another thing
12:26:19 <Zekka> > read "Infinity" :: Float
12:26:20 <lambdabot>  Infinity
12:26:26 <Zekka> (to further baffle you!)
12:26:34 <sivteck> ;o
12:26:38 <burp> it must be NaN, no?
12:26:51 <burp> > 0 * (1/0)
12:26:53 <lambdabot>  NaN
12:27:15 <Zekka> > read "NaN" :: Float
12:27:16 <lambdabot>  NaN
12:27:19 <Zekka> > NaN
12:27:20 <lambdabot>  Not in scope: data constructor ‘NaN’
12:27:22 <Zekka> BAFFLING!
12:27:33 <monochrom> Haskell probably can't optimize 0*x to 0 because of the expectation 0*⊥ ≠ 0
12:27:55 <geekosaur> arguably the read is the one that's wrong, since NaN is not a single value in IEEE754
12:27:58 <monochrom> or rather, Haskell compilers
12:28:11 <Zekka> monochrom: Don't forget how that breaks evil Num instances
12:28:13 <geekosaur> it's any invalid bit sequence, and may carry information about what caused the NaN
12:28:58 <Cale> monochrom: Well, yeah, but is that a reasonable expectation for something like Integer? I'm not sure.
12:29:03 <Zekka> geekosaur: I tend to feel like Show/Read symmetry is the important thing here, but using notation that resembles constructors when constructors aren't defined is silly
12:29:20 <Zekka> Cale: Isn't "error "oh my god, kill me"" still an Integer?
12:29:28 <Zekka> AFAIK Monochrom's point still stands
12:29:45 <Cale> Zekka: yes, but 0 * error "oh my god, kill me"  could still be 0.
12:29:58 <Zekka> Cale: It depends on the implementation of *, doesn't it?
12:30:01 <Cale> Yes
12:30:21 <Cale> But moreso it depends on the semantics we want (*) to have
12:30:31 <Cale> It's just a somewhat arbitrary decision
12:30:45 <Cale> I'm a bit curious whether we shouldn't make it the other way around.
12:30:52 <kadoban> Is that kind of thing well specified in haskell? Is it guaranteed to be ⊥?
12:30:52 <monochrom> yeah, implementations are written by humans. humans have control.
12:31:02 <Zekka> kadoban: I don't know if Num specifies any laws for this case
12:31:28 <monochrom> http://www.vex.net/~trebla/humour/tautologies.html #1 :)
12:32:49 <monochrom> kadoban, no. it's why I used the weaker word "expectation". some people want it, and they're influential, but not influential enough to get it written down.
12:33:04 <kadoban> Ahh
12:39:37 <edlinde> does anyone know of a linear algebra library written in Haskell?
12:39:55 <edlinde> or at least having datatypes defined for matrices, vectors etc?
12:39:56 <dmj`> https://hackage.haskell.org/package/linear
12:40:08 <Zekka> edlinde: From what I can recall, dmj`'s recommendation is very good
12:40:12 <chirpsalot> josephle: weird. Even GHC 7.4.2 gives me the same behaviour. I wonder why yours is different.
12:41:02 <edlinde> has anyone heard of Breeze?
12:41:29 <edlinde> Its used as a LA library in Apache Spark
12:42:10 <josephle> chirpsalot: I'll just chalk it up to my ghc 7.6.3 probably not having a standard configuration
12:42:17 <edlinde> I am thinking of writing something in Haskell that will also have the ability to parallelize matrix computations
12:42:22 <edlinde> like on a large cluster
12:42:38 <edlinde> not sure if someone in the Haskell community would be willing to help me out? :)
12:44:41 <Furby> http://raw.pro-chan.com/Raw/t/674_1382207920
12:45:19 <sivteck> @where ops -- ^
12:45:19 <lambdabot> arjanb bos byorgey Cale conal copumpkin dcoutts dibblego dmhouse dolio dons edwardk elliott geekosaur glguy Heffalump Igloo jmcarthur johnw kosmikus Lemmih monochrom nyc Philippa Pseudonym quicksilver roconnor Saizan shachaf shapr sjanssen ski sorear SyntaxPolice xerox
12:45:23 --- mode: ChanServ set +o monochrom
12:45:27 --- mode: monochrom set +b *!*@gateway/web/freenode/ip.94.71.195.193
12:45:27 --- kick: Furby was kicked by monochrom (Furby)
12:45:36 <EvanR> rofl
12:45:49 <edlinde> crazy
12:45:59 <kadoban> Great, that idiot again. I'm sure he'll be by most of the other channels I'm in shortly...
12:47:02 <k00mi> edlinde: http://hackage.haskell.org/package/repa
12:47:14 --- mode: monochrom set -o monochrom
12:48:00 <edlinde> k00mi: are you saying that Linear.Matrix uses repa?
12:48:18 <edlinde> just wondering how they come up with the definition of the Matrix type?
12:48:57 <edwardk> linear has no repa dependency
12:49:05 <edlinde> ok
12:49:20 <edwardk> its also not suitable to 'large scale' calculations
12:49:20 <edlinde> so I don’t think they can handle very large matrices yeah?
12:49:27 <k00mi> edlinde: no, that was in response to "I am thinking of writing something in Haskell that will also have the ability to parallelize matrix computations"
12:49:27 <edlinde> ok
12:49:33 <edwardk> it is really handy for small things, like 4x4 matrices and like that comes up in games
12:49:42 <edlinde> I see
12:50:32 <edwardk> its also nice in that you can use it for things like dual quaternions just by using a quaternion over a dual number type. any of the monomorphic matrix packages break down on that sort of thing
12:50:37 <edlinde> I was thinking that a Matrix type could be made into a monoid or monadic type
12:51:09 <edlinde> hmm dunno what a dual quarternion is :)
12:51:16 <marvin-hh> edlinde: do you have an actual problem to solve?
12:51:24 <edwardk> the problem is matrices are more 'category' like, you have the m and n parameters that have to match up
12:51:34 <EvanR> matrix monad?
12:51:42 <marvin-hh> edlinde: to me it sounds like you just want to play around with Haskell.
12:51:42 <lorettOrangina> matrix monad ?
12:52:01 <EvanR> dejua vu, must be a glitch in the system
12:52:03 <monochrom> Neo could be said to have been trapped in the Matrix monad :)
12:52:21 <edlinde> marvin-hh: nah I have read Haskell and written some basic stuff.. but never actually done a project in it
12:52:46 <EvanR> when he defeated agent smith, he must have used a unsafeCoerce on him
12:52:51 <edlinde> I like the idea that you can have cool operators like  (!*!) to imply a matrix multiplication
12:52:51 <EvanR> setting up the terrible sequels
12:53:08 <edwardk> monochrom: if so then they'd have had a much more compelling ending for the first movie, where he escaped the matrix to just wind up in the matrix. after all if its possible to simulate the universe within the universe it is infinitely more likely that we're in a simulation than the top level
12:53:20 <edlinde> edwardk: I haven’t read about Category
12:54:02 <edwardk> http://xkcd.com/566/ comes to mind
12:54:18 <edlinde> edwardk: when I read about Monoids.. I wondered if it can be applied to matrix algebra?
12:54:22 <monochrom> fortunately, after he escaped, he was still doing exactly what the Matrix planned for him.
12:54:26 <edlinde> like needing an id and operations
12:55:00 <EvanR> square matrices of a certain size have several possible Monoid instances
12:55:08 <edwardk> edlinde: categories are the right generalization of a monoid to cover the notion of matrix multiplication needing the # of dimensions in the vector space to match on each side
12:55:16 <marvin-hh> edlinde: ok, so the first project you want to do is beating the state of the art matrix multiplication algorithms on a cluster?
12:55:34 <vanila> matrices are just linear transformations
12:55:37 <edwardk> anyways fast matrix multiplication in haskell is pretty much carter's bailiwick over on #numerical-haskell
12:55:44 <vanila> so they form a category naturally
12:56:35 <edwardk> marvin-hh: well, he can throw himself at the problem, and probably learn something along the way
12:57:22 <edwardk> even if he doesn't get there, there is repa, 'what a category is', linear, lens, all these little ratholes to fall down along the way that are useful to later exploration
12:57:51 <edlinde> edwardk: are there good docs to understand a category?
12:58:15 <edlinde> I was only thinking up to the point that if I can think of a matrix in terms of a Monoid… I can get some operations for free
12:58:34 <edwardk> edlinde: category theory is a pretty broad topic, that said if you are starting from scratch you might want to start with something like lavwere and shanuel's "Conceptual Mathematics"
12:58:43 <EvanR> for opengl stuff you can just say you are dealing with 4x4 matrixes
12:58:46 <edwardk> that has the benefit that it offers a ton of drill
12:58:52 <EvanR> to make it easier
12:59:22 <edlinde> hmm category theory is quite involved as I understand it :)
12:59:37 <edwardk> evanr: we used to anyways, then folks started throwing quaternions in, dual quaternions for animation, plucker space for line winding information, NURBS...
12:59:50 <vanila> its just function composition
12:59:56 <frihd> I think HLearn 's README has a pretty table about what you get from some algebraic structures (for Machine Learning)
13:00:03 <frihd> https://github.com/mikeizbicki/HLearn/
13:00:09 <edwardk> edlinde: it is a deep well, the Conceptual Mathematics book I mentioned is a good starting point in terms of 'getting an idea of what some of the primitives are'
13:00:26 <malc_> edwardk: wtf is dual quaternion?
13:00:28 <edwardk> vanila: categories mostly bear little resemblance to functions in my experience
13:01:12 <edwardk> malc: take the usual quaternion rules, add another symbol lets call it e such that e /= 0, but ee=0
13:01:18 <vanila> edwardk, well a matrix represents a linear transform (a function), and matrix mult just represents function composition
13:01:57 <monochrom> oh, the infinitestimal kind of "dual"
13:01:58 <vanila> if someone thinks category sounds hard, then it's a good way to look at it to make it easy to understand
13:02:17 <DanielDiaz> is it possible to have a type for bytes (like Word8), but that is actually a byte big in memory (not Word in disguise)?
13:02:17 <edwardk> vanila: linear is based on that notion, that every vector space is free and so is isomorphic to (e -> r) for some basis e and field r, but i was referring to 'category theory' in general so 'it' was a very ambiguous antecedent
13:02:49 <vanila> that's not really what im getting at
13:03:23 <malc_> edwardk: and how that answers my question? ;)
13:03:36 <edwardk> malc_: they are useful for modeling rigid body motions, just like normal quaternions are useful for modeling rotations
13:04:11 <clrnd> hey guys I think I can do this with an extension but you tell me
13:04:21 <EvanR> i have a question, in pure script they seemed to have replaced Monoid with two other classes, Semigroup and Category. But I could not see the connection, or generalization
13:04:21 <edwardk> malc_: some bone systems use them.
13:04:26 <edwardk> e.g. http://www.seas.upenn.edu/~ladislav/dq/index.html
13:04:54 <malc_> edwardk: erm.. normal quaternions are 'orrible for modeling rotations, sure compostion is fine, but application is inefficient
13:04:56 <edwardk> Semigroup and category don't replace monoid. Semigroup is logically a superclass of Monoid
13:04:57 <malc_> thanks for the lionk
13:05:07 <clrnd> let [y, m, d] = map (fromIntegral . read) $ split "-" s :: Num a => [a]
13:05:18 <clrnd> I need to pass it like that to a fromGregorian :: Integer -> Int -> Int
13:05:35 <edwardk> Category is what you get when you 'oidify' a Monoid, they for some reason didn't call it a Monoidoid
13:05:36 <clrnd> fromGregorian y m d
13:05:37 <EvanR> edwardk: well, then what do you do when you would have used a Monoid and you now have a Semigroup?
13:05:59 <edwardk> EvanR: if you have a thing that is only a Semigroup and not a Monoid it is probably because it doesn't have a unit
13:06:09 <edlinde> what does it mean to “oidify"?
13:06:11 <malc_> edwardk: hah.. i think i've seen those images while trying to decipher sotc
13:06:12 <clrnd> it works in GHCi but doesn't typecheck
13:06:30 <EvanR> edwardk: the scenario would be, it did have a unit and then purescript took away the Monoid class
13:06:32 <edwardk> consider instance Ord a => Semigroup (Max a) where Max a <> Max b = Max (max a b)
13:06:48 <edwardk> EvanR: well, to be honest having _no_ Monoid class strikes me as a wrong idea
13:07:00 <EvanR> it seemed like that replaced it with something else
13:07:03 <edlinde> so I am just wondering how say someone implements the actual data shipment strategies for matrix computations on a massive cluster.. when you use Haskell?
13:07:05 <EvanR> they
13:07:39 <edlinde> are they written in MPI maybe? And the Haskell matrix library just acts as a wrapper on top?
13:07:50 <edwardk> edlinde: the real answer is nobody has bothered to do that in haskell =P
13:07:52 <nick_cannon> So now I am trying to go through my sandwich and find the price of each item. This is how far I have gotten, but I can't figure out (again) how to adress the layers: http://lpaste.net/8681362746240925696
13:08:03 <edlinde> okie
13:08:29 <edlinde> maybe there are no advantages of wriiting such a library in Haskell?
13:08:49 <edlinde> when there are already languages like R, Matlab etc around?
13:08:50 <edlinde> :)
13:09:00 <nick_cannon> clrnd: Want to step in again? :p
13:09:10 <clrnd> nick_cannon, ofc
13:09:14 <nick_cannon> :) thanks
13:09:21 <nick_cannon> Did you see the link?
13:09:48 <dcoutts_> edlinde: sounds like a task for cloud haskell
13:10:05 <edlinde> dcoutts_: whats that?
13:10:12 <frihd> edlinde: dcoutts_ did you have a look at hailstorm?
13:10:28 <albeit> nick_cannon: Instead of returning -1 for an item that doesn't exist, maybe consider returning a (Maybe Int)
13:10:33 <edlinde> aha similar to Erlang
13:10:52 <nick_cannon> albeit: good advice. I just make it Maybe Int?
13:10:54 <clrnd> nick_cannon, ugh sorry, gotta go like right now :(
13:10:59 <nick_cannon> clrnd: dang. Okay
13:11:01 <albeit> nick_cannon: So instead of checking for -1s later, you can catMaybe
13:11:02 <nick_cannon> thanks anyway
13:11:03 <clrnd> the guys will certainly help you
13:11:09 <clrnd> cya!
13:11:11 <nick_cannon> thanks again!
13:11:13 <nick_cannon> ciao
13:11:34 <dcoutts_> edlinde: right, a nicer high level way of writing programs to run across a cluster
13:11:59 <nick_cannon> albeit: until I solve the priceSandwich issue, I'm going to leave it -1
13:11:59 <edlinde> ok
13:12:01 <dcoutts_> edlinde: avoiding low level networking details
13:12:03 <nick_cannon> then work on reolving that other issue
13:13:03 <albeit> nick_cannon: Sure. What's specifically not working?
13:13:42 <albeit> nick_cannon: Well I guess on thing is of type :: Int, but null returns Bool, so that won't compile
13:13:46 <nick_cannon> albeit: thanks. I cannot seem to be able to traverse the items in a given sandwich and grab their prices. I have the mechanisms in which you would use to gather the prices. But not the mechanism of traversing the sandwich
13:13:57 <nick_cannon> ah
13:15:33 <albeit> nick_cannon: Instead of a list comprehension for priceSandwich, consider a simple map ("map lookup' x"), which will give you :: Int
13:15:52 <nick_cannon> hmm
13:15:57 <nick_cannon> let me try that
13:15:58 <nick_cannon> thanks
13:16:15 <albeit> nick_cannon: I'm assuming you then want to "filter" out any -1 prices, and then "sum" the resulting list
13:16:30 <nick_cannon> albeit: yes
13:16:52 <nick_cannon> albeit: so sum (map lookup' (x))?
13:17:51 <albeit> nick_cannon: Sure, but you still need to worry about the -1 prices. And no need for parentheses are x.
13:18:02 <albeit> *around x
13:18:34 <nick_cannon> albeit: what about 0? for now anyway
13:19:04 <albeit> nick_cannon: 0? Not sure what you mean... if you ignore -1s, its effectively the same as making them 0
13:19:35 <nick_cannon> albeit: right
13:19:40 <albeit> :t mapMaybe
13:19:41 <lambdabot> (a -> Maybe b) -> [a] -> [b]
13:19:54 <nick_cannon> Oh wait
13:19:58 <nick_cannon> there is such thing as mapMaybe?
13:19:59 <EvanR> ok nevermind, they simply omitted Monoid from the purelude, but i found a library which expanded on it
13:20:22 <albeit> nick_cannon: Indeed! Part of Data.Maybe
13:20:25 <EvanR> curious most of the semigroups i happened to run into in haskell are also monoids
13:20:32 <nick_cannon> albeit: I keep getting this error     Couldn't match expected type `[Layer]' with actual type `Sandwich'
13:20:39 * hackagebot bits 0.4 - Various bit twiddling and bitwise serialization primitives  http://hackage.haskell.org/package/bits-0.4 (EdwardKmett)
13:20:44 <nick_cannon> albeit: I will look into that instead of using 0, then
13:21:22 <albeit> nick_cannon: I'm not sure what your Sandwich is defined as... mind posting that? It must not be "type Sandwich = [Layer]" at least
13:21:45 <nick_cannon> albeit: one moment
13:22:19 <nick_cannon> albeit: http://lpaste.net/3743006682125434880
13:22:20 <EvanR> Sandwich = [Tastey]
13:22:29 <nick_cannon> lol
13:22:49 <EvanR> :([]) `asAppliedTo` Sandwich
13:23:01 <EvanR> dangit, (:[])
13:23:14 <nick_cannon> EvanR: in the autonomous function?
13:23:46 <EvanR> autonomous functions, ghc doesnt have this yet
13:23:52 <EvanR> that would be scary
13:23:57 <albeit> nick_cannon: In priceSandwich, your "x" variable is a datatype Sandwich, with a constructor Sandwich that takes [Layer]. You're trying to map over "Sandwich [Layer]", but you can't do that. You could pattern match x on Sandwich's constructor though
13:24:47 <nick_cannon> albeit: with something like [m | Layer m <- x]?
13:26:05 <albeit> nick_cannon: No, more like how you pattern match a Database to ((x,z):xs) in look, you can pattern match a Sandwich to its constructor
13:26:27 <nick_cannon> albeit: ah
13:29:51 <nick_cannon> albeit: I'm kinda struggling with this
13:30:26 <corni_> hey, is there an equivalent like [1..], but not for the natural numbers, but for Z?
13:30:51 <structuralist> can someone help me understand why this is happening? adding a bang pattern in an unexpected place makes things faster: https://github.com/structuralist/parconc-examples/commits/master
13:31:16 <albeit> nick_cannon: For example, if you pattern matching with "foo :: Layer -> a", you could do "foo (Bread breadKind) = ...; foo (Cheese cheeseKind) = ..."
13:31:17 <structuralist> based on simon marlow's book: http://chimera.labs.oreilly.com/books/1230000000929/ch04.html
13:31:33 <nick_cannon> ohhh
13:31:36 <nick_cannon> oh wow okay
13:31:45 <Haskellfant> corni_: [-3..] is working fine for me
13:32:14 <Haskellfant> or do you want a list of all Integers?
13:32:42 <corni_> Haskellfant: yes, but i see that maybe my thinking is flawed, as e have single-linked lists
13:32:49 <corni_> Haskellfant: and there is no head for such a list
13:33:18 <corni_> Haskellfant: and something like [1,-1,2,-2,...] might be more appropriate, but I think i can construct such a list
13:34:20 <structuralist> corni_: or maybe something like the type U here: http://blog.sigfpe.com/2006/12/evaluating-cellular-automata-is.html
13:34:34 <structuralist> don't know what you're doing though
13:35:49 <Haskellfant> ([0..] ++ [-1,-2..]) would also be a list of all integers, but it really depends on what you want
13:36:12 <Cale> Haskellfant: no it wouldn't...
13:36:19 <corni_> structuralist: thanks, I think i really need them interleaved
13:36:22 <nick_cannon> albeit: So I made functions isSomething for each type in Layer. They return bools
13:36:22 <Cale> Haskellfant: -1 doesn't belong to that list
13:36:43 <Cale> > 0 : [1..] >>= (\x -> [x,-x])
13:36:45 <lambdabot>  [0,0,1,-1,2,-2,3,-3,4,-4,5,-5,6,-6,7,-7,8,-8,9,-9,10,-10,11,-11,12,-12,13,-1...
13:36:57 <Cale> oh, precedence :P
13:37:02 <Haskellfant> Cale: oh, ok
13:37:04 <Cale> > 0 : ([1..] >>= \x -> [x,-x])
13:37:05 <lambdabot>  [0,1,-1,2,-2,3,-3,4,-4,5,-5,6,-6,7,-7,8,-8,9,-9,10,-10,11,-11,12,-12,13,-13,...
13:37:29 <albeit> nick_cannon: Oh I meant that just as an example, instead of "priceSandwich x = ...", "priceSandwich (Sandwich x)" would result in x being :: [Layer]
13:38:05 <albeit> How you're dealing with the Layers in look and lookup' is fine
13:40:21 <albeit> nick_cannon: Right now "x :: Sandwich" in priceSandwich, but you want "x :: [Layer]". Sandwich is both a type name and a constructor, and when you pattern match on the constructor Sandwich, you can "extract" the inner [Layer]
13:40:49 <ReinH> yummy yummy sandwich
13:41:09 <SrPx> What is a good name for a function that takes a source file and reads it into your runtime, inside a REPL?
13:43:12 <albeit> nick_cannon: Let me know if I'm confusing you... just trying to lead you to the answers yourself, may be doing more harm than good ;)
13:43:49 <albeit> > data Foo = Foo Int
13:43:51 <lambdabot>  <hint>:1:1: parse error on input ‘data’
13:44:09 <nick_cannon> albeit: Yeah I think I need another break xD
13:44:09 <structuralist> SrPx: hint calls it "interpret": http://hackage.haskell.org/package/hint-0.4.2.1/docs/Language-Haskell-Interpreter.html (if I understood correctly)
13:44:26 <albeit> > let x = Just 5
13:44:27 <lambdabot>  not an expression: ‘let x = Just 5’
13:44:39 <SrPx> structuralist: I see... I don't like this name, though, it is used for a function that actually reads the code and outputs the result :(
13:44:53 <SrPx> (the one specifially is used inside the REPL and doesn't output anything, just returns a reference)
13:45:46 <structuralist> SrPx: there's also "eval" in there
13:46:52 <SrPx> ditto
13:47:15 <albeit> nick_cannon: The "The connection with constructors" section of this might help http://en.wikibooks.org/wiki/Haskell/Pattern_matching
13:47:33 <S11001001> > [1,2] ^. to show
13:47:34 <lambdabot>  "[1,2]"
13:47:45 <S11001001> I'm going to rewrite every simple function call into this syntax
13:47:59 <albeit> nick_cannon: It may be helpful to give you data constructors different names than the datatypes themselves... instead of "data Sandwich = Sandwich [Layer]", "data Sandwich = SandwichBuilder [Layer]" would be clearer at first
13:49:03 <S11001001> > [1,2] ^. (show ^. ((^.) ^. to))
13:49:05 <lambdabot>  Couldn't match type ‘GHC.Base.String’
13:49:05 <lambdabot>                with ‘[t0]
13:49:05 <lambdabot>                      -> Control.Applicative.Const (a -> GHC.Base.String) [t0]’
13:49:05 <lambdabot>  Expected type: Control.Lens.Getter.Getting
13:49:05 <lambdabot>                   (Control.Lens.Getter.Getting
13:49:08 <S11001001> eh
13:49:37 <lorettOrangina> eh
13:49:47 <S11001001> needs more 'to'
13:50:07 <lorettOrangina> ^.^
13:50:43 <S11001001> > (show ^. to to) ^. to ([1,2] ^. to (^.))
13:50:45 <lambdabot>  "[1,2]"
13:50:49 <S11001001> yes!
13:51:44 <EvanR> > zip [1, 2, 3] [1, 2]
13:51:46 <lambdabot>  [(1,1),(2,2)]
13:51:54 <EvanR> > zip [1, 2] [1, 2, 3]
13:51:55 <lambdabot>  [(1,1),(2,2)]
13:52:21 <sivteck> > (show^.to to)^.to([1,2]^.to(^.))
13:52:22 <lambdabot>  "[1,2]"
13:55:37 <nvp_> anyone familiar with Apache Spark?
14:03:38 <merijn> nvp_: I know it's slow, but other than that, no :)
14:04:26 <chirpsalot> merijn: "Lightning-fast cluster computing"
14:05:01 <merijn> chirpsalot: Yeah, for particularly slow lightning :p
14:05:21 <EvanR> each computation takes time equivalent to a wav file of a spark snapping
14:05:41 <chirpsalot> merijn: well maybe the Cherenkov radiation is fast!
14:05:56 <merijn> nvp_: Especially if you were planning to use GraphX
14:06:47 <EvanR> @src (++)
14:06:47 <lambdabot> []     ++ ys = ys
14:06:47 <lambdabot> (x:xs) ++ ys = x : (xs ++ ys)
14:06:47 <lambdabot> -- OR
14:06:47 <lambdabot> xs ++ ys = foldr (:) ys xs
14:08:56 <nick_cannon> albeit: I'm burnt out. Spinning my wheels to no avail. Can I use a life line?
14:09:47 <albeit> Sure
14:09:52 <nick_cannon> Thank you
14:11:01 <albeit> nick_cannon: priceSandwich (Sandwich layers) = sum (filter (> 0) (map lookup' layers))
14:11:45 <albeit> nick_cannon: Or a bit cleaner, " = sum . filter (> 0) $ map lookup' layers"
14:12:17 <nick_cannon> omg
14:12:22 <nick_cannon> makes me so mad
14:12:25 <nick_cannon> I was so close...
14:12:27 <nick_cannon> omg
14:12:34 * nick_cannon spirit is broken
14:12:53 <nick_cannon> This paradigm of programming...soooo frustrating
14:12:54 <nick_cannon> lol
14:12:57 <albeit> nick_cannon: Yeah, it can be rough at first cause missing a parantheses can spit out an error that is hard to understand, even though the basic structure is right
14:12:58 <ReinH> nick_cannon: It can help to break it down into subproblems that you then attack individually
14:12:58 <monochrom> you know, I wonder why non-existent ingredients are marked as price "-1", when later you will have to check for them and, effectively, replace them by 0.
14:13:19 <ReinH> nick_cannon: And then you will have to think about the types along the way, which is good practice.
14:13:20 <albeit> monochrom: He said he's planning on switching to Maybe
14:13:22 <monochrom> you may as well mark them as price "0" and so later you just sum.
14:13:32 <albeit> monochrom: Or that ;)
14:13:38 <monochrom> sure, and later consider Nothing to be 0 anyway?
14:13:59 <ReinH> sum . catMaybes :)
14:14:09 <nick_cannon> ReinH: I'll have to take your advice
14:14:14 <nick_cannon> That's kinda what I have been doing
14:14:16 <nick_cannon> but
14:14:22 <nick_cannon> obviously not well enough
14:14:45 <ReinH> nick_cannon: Richard Bird's new book is a wonderful introduction to this kind of thinking http://www.amazon.com/Thinking-Functionally-Haskell-Richard-Bird-ebook/dp/B00O0RKGTO/ref=sr_1_1?ie=UTF8&qid=1415384687&sr=8-1&keywords=richard+bird
14:14:50 <ReinH> "Thinking Functionally", as it were.
14:15:21 <ReinH> nick_cannon: you can also read this soduku solution to get a taste http://www.cs.tufts.edu/~nr/cs257/archive/richard-bird/sudoku.pdf
14:15:27 <nick_cannon> ReinH: Thanks. I have about 10 books to order over the holiday now :D
14:15:42 <ReinH> nick_cannon: literally the first few pages walk you through deconstructing this sort of problem :)
14:15:53 <ReinH> nick_cannon: I would recommend bumping this one to the top of that list ;)
14:16:04 <ReinH> I really can't recommend it highly enough
14:16:32 <ReinH> Also now I'm not tempted to try to write a similar book 10% as well..
14:16:37 <monochrom> this decision has to be made early: if a sandwich contains non-existent ingredient, should the whole sandwich be considered invalid, or should the non-existent ingredient be free?
14:16:43 <albeit> ReinH: Is it targeted to beginners, or good for beginner-intermediate too?
14:16:46 <ReinH> monochrom: ha :)
14:17:14 <monochrom> this is not an implementational decision or coding style decision that you can postpone to later and even then keep changing.,
14:17:15 <ReinH> albeit: it starts at beginner but if you're willing to stick with it I think a lot of haskell developers will get something out of it
14:17:31 <monochrom> this is a specification-level decision. it is about the nature of the problem itself.
14:17:46 <ReinH> What is the denotation of a sandwich...
14:17:59 <EvanR> (:[]) Sandwich
14:18:07 <nick_cannon> monochrom: They are free because they wont be added. The situation cannot occur in which there is an item that is not in my database of items
14:18:23 <nick_cannon> that is added that is not in*
14:18:29 <monochrom> then their prices are simply 0
14:18:33 <nick_cannon> si
14:18:53 <ReinH> yep
14:19:10 <ReinH> -1 is not a good substitute for 0 when you want to sum things ;)
14:19:23 <nick_cannon> ReinH: haha yeah
14:25:49 <nvp> how is it slow when apache spark holds the open-source record for sorting 100 TB data the fastest?
14:26:54 <merijn> nvp: "open-source record" <- well there you go
14:27:08 <monochrom> and 0 is not a good substitute for 1 when multiplying things
14:27:33 <merijn> GraphLab is supposedly "the fastest graph processing framework" (it's an order of magnitude faster than Apache Spark's GraphX)
14:28:09 <monochrom> it is unsettling to see that human intuition thinks product [] = 0 just because of "emptiness"
14:28:32 <EvanR> > product []
14:28:33 <lambdabot>  1
14:28:44 <EvanR> product [] = 1 because lambdabot ;)
14:28:50 <merijn> But the truth is that GraphLab still sucks, performance-wise. You can do orders of magnitude better than GraphLab. The same goes for Apache Spark
14:30:48 <merijn> nvp: FWIW, our internal benchmarks concluded that the only positives (if your generous and consider them positive) of Apache Spark are: Java and runs easily on Hadoop
14:31:11 <merijn> But Hadoop isn't that great to begin with either
14:31:26 <nvp> I see. why do you think the authors chose to use Scala for Spark?
14:31:33 <benmachine> monochrom: I don't think that's unsettling at all, it's wrong but that's not the same thing
14:31:46 <merijn> nvp: Ease of implementation
14:31:49 <benmachine> the issue of what product [] should be and why is a little bit subtle
14:32:05 <benmachine> or at least does require that you sit down and think about it
14:32:23 <nvp> merijn: by "our" who does that refer to?
14:33:05 <merijn> nvp: My group within Oracle Labs
14:34:40 <nvp> merijn: so what's the real value proposition offered by Databricks (the company that is commercializing Spark) if it's not all that great? Also, do you plan to release the benchmarks you conducted? It would be great to see some numbers.
14:35:49 <merijn> nvp: There's a paper in the pipeline with numbers comparing our stuff with GraphLab (and we're now redoing GraphX benchmarks with Spark, because reviewers were asking for it).
14:36:09 <merijn> nvp: The realu value proposition is "everyone wants hadoop, even with cluster sizes where it doesn't make sense"
14:36:45 <merijn> Hadoop, being essentially Google's MapReduce, is a good design IF you have a huge cluster (like 200+ nodes)
14:36:59 <merijn> Most companies have cluster that are sub 100 nodes, and Hadoop makes little sense there
14:37:38 <merijn> Something more traditional like MPI or whatever will be much faster
14:37:52 <nvp> merijn: Am I guessing correctly that you are a researcher? Can I read more about the work you've done in this area?
14:39:57 <merijn> nvp: I'm doing an internship here as part of my phd, but I'm only tangentially in the cluster/HPC field, so I haven't done much here other than visit a ton of talks ;)
14:41:27 <Ferdirand> yesterday i was helping a high school student who was tasked with setting up a hadoop cluster on 6 raspberry pi's
14:41:33 <Ferdirand> the pain
14:42:52 <nvp> merijn: thanks for the view points. I have more reading to do.
14:45:13 <lericson> @hoogle mplot
14:45:13 <lambdabot> No results found
14:45:40 <nick_cannon> How do I make a type an instance of the class Eq?
14:45:42 <josephle> Ferdirand: that is such a devilish project!
14:45:42 <lericson> what is a good way to plot a 3d curve? i basically just want to shell it out to gnuplot anyway
14:46:27 <EvanR> nick_cannon: you can see examples in many of the hackage package source code
14:46:52 <nick_cannon> alright
14:47:01 <EvanR> a basic instance would start like
14:47:08 <EvanR> instance Eq Sandwich where
14:47:29 <nick_cannon> thanks
14:47:33 <lorettOrangina> sandwich ?
14:47:41 <nick_cannon> lorettOrangina: We like sandwiches a lot
14:48:00 <EvanR> you can use type variables, if you also have constraints for them
14:48:01 <lorettOrangina> I can tell :D
14:48:07 <nick_cannon> :D
14:48:37 <EvanR> instance Eq a => Eq (Sandwich, a) where
14:49:43 <lorettOrangina> @hoogle partition
14:49:43 <lambdabot> Data.List partition :: (a -> Bool) -> [a] -> ([a], [a])
14:49:43 <lambdabot> Data.Text partition :: (Char -> Bool) -> Text -> (Text, Text)
14:49:43 <lambdabot> Data.Text.Lazy partition :: (Char -> Bool) -> Text -> (Text, Text)
14:53:50 <EvanR> im writing a toy lisp interpreter, and i have the choice to eval the arguments before applying the function call, or pass the arguments in unevaluated, i.e. lazy
14:54:01 <EvanR> and i think its going to be lazy either way because haskell
14:54:03 <EvanR> what do i do
14:54:37 <EvanR> seq?
14:54:44 <simpson> EvanR: Haskell merely lets you specify what the order of evaluation will be.
14:54:50 <cojy> EvanR: why would it be lazy if you evaluate them?
14:55:06 <josephle> I believe lisp is call-by-name, which isn't quite lazy
14:55:16 <cojy> no it's call-by-value josephle
14:55:18 <EvanR> im trying to get it to be strict
14:55:50 <cojy> EvanR: have you hit an example where you have issues yet?
14:56:05 <EvanR> heres the relevant case, (L ps r e) -> eval (mkBindings ps r (map (eval context) xs) ++ context) e
14:56:18 <EvanR> eval will happen first, rather than the map eval
14:56:38 <EvanR> cojy: no, but i expect some stuff will not crash due to strictness when i think it will
14:56:56 <EvanR> seems like a bad way to model strictness
14:58:27 <simpson> Ah, no monadic sequencing. seq would work.
14:58:44 <EvanR> where do i put it?
14:59:02 <cojy> seq might not be enough, what about preventing memoization?
14:59:07 <simpson> f `seq` g where f = map (eval context) xs; g = eval ((mkBindings ps r f) ++ context) e
14:59:29 <simpson> Anyway, I'm not super-great with seq usage. I normally use this-then-that monad logic.
14:59:56 <EvanR> how does that work? for curiousities sake
14:59:59 <nick_cannon> Do I need to do something special in order to use Eq? I am getting this error:  Ambiguous occurrence `Eq'
15:00:02 <nick_cannon>     It could refer to either `Main.Eq', defined at main.hs:89:7
15:00:21 <monochrom> nick_cannon: show unabridged actual code.
15:00:26 <simpson> EvanR: https://www.haskell.org/haskellwiki/Seq
15:00:36 <EvanR> i mean, the monad logic
15:00:51 <nick_cannon> monochrom: http://lpaste.net/5782611566377566208
15:01:04 <kadoban_> nick_cannon: You can't define your own Eq typeclass...there already is one.
15:01:09 <monochrom> delete lines 1-5
15:01:11 <nick_cannon> oh
15:01:12 <nick_cannon> lol
15:01:35 <simpson> EvanR: In the type of (>>=), all of the effects prior to the effect being bound must be completed before the bound effect can be started, because of data dependencies.
15:01:53 <simpson> Of course, not *all* monads do this! But many do, and many of them explicitly comment on how this can be trusted.
15:02:05 <simpson> (Tardis is a great example of a monad that doesn't do this.)
15:02:08 <EvanR> i didnt know about that
15:02:37 <monochrom> simpson: http://lpaste.net/41790/
15:02:53 <simpson> monochrom: Sure!
15:03:07 <monochrom> and I still have trouble explaining http://lpaste.net/63925
15:03:23 <EvanR> as far as (map f xs) `seq` foo goes, doesnt that just have the effect of WHNF, so map only does like the first case?
15:03:32 <monochrom> but at least "sprinkle sprinkle little stars, how I wonder when you are" is a cute title
15:03:56 <simpson> EvanR: _|_ `seq` b = _|_, that's the rule. Also a `seq` b = b.
15:04:06 <EvanR> interesting
15:04:21 <EvanR> reading the guide, again
15:04:23 <simpson> It *is* legal to evaluate b and then a, and then return b, and an implementation might do that...
15:04:35 <simpson> ...but since your b value depends on a, that's not really a problem, right?
15:05:05 <EvanR> yeah i would like for a to crash before i ever see b's result anywhere
15:05:14 <EvanR> or lock up or what have you
15:06:27 <simpson> seq promises that, if a would be _|_ when evaluated, seq will also be _|_. That should be sufficient, right?
15:06:39 <EvanR> erg wait
15:06:50 <EvanR> so if a is map succ [1, 2, undefined]
15:07:17 <EvanR> and then the third thing is never used by the rest of the program
15:07:33 <mietek> Did anyone ever see a problem such as:
15:07:35 <EvanR> a `seq` rest of program will crash
15:07:39 <mietek>        Loading package text-icu-0.7.0.0 ...
15:07:39 <mietek>        <no location info>:
15:07:39 <mietek>            <command line>: can't load .so/.DLL for: /app/.halcyon/sandbox/lib/x86_64-linux-ghc-7.8.3/text-icu-0.7.0.0/libHStext-icu-0.7.0.0-ghc7.8.3.so (/app/.halcyon/sandbox/lib/x86_64-linux-ghc-7.8.3/text-icu-0.7.0.0/libHStext-icu-0.7.0.0-ghc7.8.3.so: undefined symbol: _ZTVN10__cxxabiv120__si_class_type_infoE)
15:08:02 <mietek> Could it be that using text-icu requires an extra -lstdc++?
15:08:15 <EvanR> > (map succ [1, 2, undefined]) `seq` "booya"
15:08:17 <lambdabot>  "booya"
15:08:21 <EvanR> :(
15:08:53 <shiona_> EvanR: seq will only force weak head normal form (The top most type constructor), so a `seq` "booya" will force a to 1 : thunk
15:09:04 <shiona_> Or that's how I've understood it
15:09:11 <EvanR> me too, so im not surprised
15:09:22 <monochrom> even thunk:thunk and not even bothering to resolve the 1
15:09:31 <shiona_> monochrom: oh, good point
15:09:39 <EvanR> > let a = map succ [1, 2, undefined] in a `seq` a !! 1
15:09:40 <lambdabot>  3
15:09:48 <simpson> > let a = map succ [1, 2, error "3"]; b = map succ a in head b
15:09:50 <lambdabot>  3
15:09:58 <simpson> > let a = map succ [1, 2, error "3"]; b = map succ a in a `seq` head b
15:09:59 <lambdabot>  3
15:10:17 <simpson> Okay, now I'm a little confused. I feel like seq doesn't work as documented.
15:10:24 <EvanR> not exactly lisp semantics
15:10:39 <simpson> EvanR: Disregard me; clearly I have no idea how things work.
15:11:04 <exio4> > let a = map succ [undefined, 1, 2] in a `seq` (a !! 2)
15:11:06 <lambdabot>  3
15:11:23 <EvanR> seq would cause the a to go only to whnf, so maybe i need deep seq
15:11:48 <monochrom> you may like the stuff in Control.DeepSeq
15:12:36 <Korsakoff> Hey guys, got a question again. I have 2 Lists, 1 List  [(String, Int)] and 1 List [String], and I want the word from [String]-List, which has the highest Int Value in my [(String, Int)] List
15:14:40 <EvanR> > map succ [undefined, 2] `deepseq` "booya"
15:14:42 <lambdabot>  Not in scope: ‘deepseq’
15:15:12 <ReinH> deepseq is usually like swatting a fly with a shotgun, but...
15:15:13 <hyPiRion> Korsakoff: Convert the [(String, Int)] to a map, then do lookups on it
15:15:39 <EvanR> and now i get what NFData means ;)
15:15:43 * hackagebot rethinkdb-client-driver 0.0.3 - Client driver for RethinkDB  http://hackage.haskell.org/package/rethinkdb-client-driver-0.0.3 (wereHamster)
15:16:56 <EvanR> ReinH: which is how it feels when i go write code in a strict language, im like why are you going to evaluate all that now!
15:17:20 <EvanR> aint nobody got time for that
15:17:23 <merijn> EvanR: I think your problem is not strictness at all
15:17:52 <merijn> EvanR: Your problem is that you're thinking in a way where you directly embed your interpreter's behaviour in Haskell, which is not necessarily sensible
15:18:11 <EvanR> well im implementing the interpreter in haskell
15:18:17 <merijn> Just because you're writing an interpreter for a strict language in lazy haskell, doesn't mean you need strictness at all
15:18:18 <merijn> So?
15:18:26 <EvanR> head scratch
15:18:50 <merijn> Unless you're doing an embedding (i.e. representing lisp objects directly as haskell things), the laziness of haskell is not relevant at all
15:18:56 <EvanR> so youre saying im not going to be able to tell the difference
15:19:17 <dreams> How do I fix this error http://lpaste.net/113913
15:19:28 <merijn> EvanR: Well, you still need to implement strict semantics for your interpreter, but that has nothing to do with strictness of your interpreters implementation
15:20:02 <joehillen> what's the extension that let's you do foo@{..}?
15:20:08 <merijn> EvanR: Like, what are the datatypes your language uses? (It was a lispy thing, right?)
15:20:34 <EvanR> theres only data E = Y I | S [E] | ... other nonsense
15:20:36 <kadoban_> dreams: You can't make a (Parser a) an instance of Monad, given the kind of it. It's saying you need to make Parser an instance of Monad.
15:20:40 <EvanR> I = String
15:20:53 <monochrom> dreams: it should be "instance Monad Parser where". and later, since you're doing an instance on a type synonym, you will need to turn on an extension, but the compiler will suggest it.
15:21:05 <kadoban_> dreams: (Maybe a) isn't a Monad. Maybe is a Monad.
15:21:21 <dreams> Ah ok thanks
15:21:48 <monochrom> actually I wonder if turning on an extension is enough
15:21:49 <EvanR> merijn: if i interpret this code ((lambda (x y) x) '(2 bomb)), i dare say it will be 2 not crash the way i have it
15:22:01 <vanila> @hoogle Char -> [Bool]
15:22:02 <lambdabot> Data.Char isAlpha :: Char -> Bool
15:22:02 <lambdabot> Data.Char isAlphaNum :: Char -> Bool
15:22:02 <lambdabot> Data.Char isAscii :: Char -> Bool
15:22:02 <dreams> monochrom: I think I should also change it to a type
15:22:11 <dreams> I mean data
15:22:12 <vanila> How I get the bits of a char as a list?
15:22:15 <merijn> EvanR: Well, then the way you have it is wrong ;)
15:22:24 <EvanR> \o/
15:22:46 <EvanR> er
15:22:53 <EvanR> ((lambda (x y) x) 2 bomb)
15:23:09 <merijn> EvanR: Suppose your example code there has type "[Expr]" in your interpreter
15:23:24 <EvanR> that code has type E
15:23:49 <EvanR> S [a b c]
15:23:50 <monochrom> the extension allows things like "instance Show (Parser a)" but not "instance Monad Parser"
15:23:59 <EvanR> c is bomb
15:24:19 <merijn> EvanR: You need "eval :: E -> IO E" (or "eval :: E -> Interp E")
15:24:31 <monochrom> it is simpler to use a newtype than to hack type synonyms
15:24:34 <EvanR> why IO?
15:24:51 <merijn> EvanR: Well, it's lisp right? You can have side effects in arbitrary expressions
15:25:03 <EvanR> i dont have any facility for side effects
15:25:10 <EvanR> it just evaluates to a result
15:25:19 <merijn> Then first "eval '(lambda (x y) x)'" then "eval '2'" then "eval 'bomb'" and only then try to evaluate the application
15:25:24 <merijn> EvanR: You do have side effects
15:25:32 <merijn> EvanR: You just told me "bomb" crashes
15:25:42 <EvanR> i have crashing and freezing yeah, just like haskell
15:25:59 <merijn> EvanR: You need "eval bomb" to return an error before you try to apply the lambda
15:26:07 <EvanR> bomb would be something like (lambda x. x x) (lambda x. x x)
15:26:11 <monochrom> I don't think it's healthy to debate on "is ⊥ an effect or not" at this point.
15:26:18 <merijn> monochrom: Ok, sure
15:26:28 <merijn> monochrom: But I don't have the terminology to explain what I mean :)
15:26:37 <merijn> monochrom: Feel free to take over :p
15:26:41 <EvanR> i need to eval bomb at all is what im trying to do
15:26:52 <EvanR> i think deepseq is all i can really do
15:26:58 <merijn> EvanR: Right, but what does that have to do with seq?
15:27:07 <monochrom> I think it's more healthy to point out: in previous discussion, we already saw that one way to enforce order is by going monadic and coding up >>= to do it for you. so what merijn is saying now is exactly that.
15:27:09 <merijn> What's your implementation of eval?
15:27:39 * merijn suspects EvanR is directly embedding
15:27:46 <monochrom> and it is pointful to go monadic right now. you have a context to pass around and read every so often. you could use Reader for that.
15:27:51 <EvanR> for the S case, it evaluates the first element and then does this
15:27:57 <EvanR> (L ps r e) -> eval (mkBindings ps r (map (eval context) xs) ++ context) e
15:28:02 <merijn> Which, incidentally is a terrible thing to for your first language implementation, for exactly this problem
15:28:52 <EvanR> so i told it to eval the arguments but if they dont get used i dont get bomb
15:28:59 <EvanR> so ok monadic style would solve it
15:29:05 <EvanR> instead of map, sequence
15:29:10 <EvanR> or mapM
15:29:31 <EvanR> but what monad? context is just an accidental candidate
15:29:34 <EvanR> Identity
15:29:46 <EvanR> seems silly
15:30:05 <merijn> What's wrong with Reader for example?
15:30:24 <EvanR> its not doing anything with the context here
15:30:31 <ReinH> > sortBy (comparing (Down . snd)) . catMaybes . map (\x -> fmap (x,) (lookup x [("a",1),("b",2),("c",3)])) $ ["a","b"] -- Korsakoff
15:30:33 <lambdabot>  [("b",2),("a",1)]
15:30:35 <structuralist> can someone help me understand why this is happening? adding a bang pattern in an unexpected place makes things much faster: https://github.com/structuralist/parconc-examples
15:31:04 <ReinH> structuralist: can you link to something a bit more specific please?
15:31:14 <ReinH> structuralist: (you can click on line numbers to link directly to them)
15:31:16 <JagaJaga> Hello! I have just this thing `data Tree a = Leaf {height :: Int} | Node {value :: a, height :: Int, left :: Tree a, right :: Tree a}` I want height of Leaf to be constant. How to do it? The only solution I've created is https://gist.github.com/7f494f57ee0fe42363eb
15:31:16 <structuralist> ReinH: did you see the README?
15:31:18 <EvanR> it just happens i have a context, but i just randomly added that instead of doing a quoted, capture avoiding substitution, so it seems like your suggestion shouldnt rely on using a Reader
15:31:36 <structuralist> ReinH: I tried to set it up to be readable
15:31:52 <ReinH> structuralist: Ah.
15:32:05 <structuralist> here's the bang pattern: https://github.com/structuralist/parconc-examples/blob/master/fwsparse/fwsparse1.hs#L29
15:32:41 <simpson> EvanR: do { args <- mapM (eval context) xs; eval ((mkBindings ps r args xs) ++ context) e
15:32:55 <simpson> That doesn't even have to specify, yet, which monad you're using.
15:33:25 <EvanR> and also it seems like, from what i just learned, the Reader implementation is specifically made to be stricty even if it doesnt need to be, if i for example implemented as just partialling the context like im doing
15:33:49 <ReinH> JagaJaga: https://www.haskell.org/haskellwiki/Smart_constructors
15:33:57 <EvanR> simpson: alright, so in the end i would pick identity
15:34:15 <JagaJaga> ReinH: oh!
15:34:22 <jfischoff_> structuralist: The Vertex type is really an Int
15:34:35 <jfischoff_> the bang might allow it get unpacked
15:34:59 <EvanR> definitely learning some things today
15:35:12 <EvanR> :t runIdentity
15:35:13 <lambdabot> Identity a -> a
15:35:22 <structuralist> jfischoff_ how would I test that hypothesis?
15:35:35 <jfischoff_> remove the bang look at the core
15:35:40 <jfischoff_> add the bang look at the core
15:36:04 <simpson> EvanR: For today, sure. For tomorrow, who knows?
15:36:05 <jfischoff_> are you familiar with https://hackage.haskell.org/package/ghc-core ?
15:36:22 <monochrom> hmm, sometimes >>= is not enough
15:36:33 <jfischoff_> anyway looking at the difference between the two versions cores will give you the answer
15:36:38 <structuralist> jfischoff_: I actually used it here but I'm not good at reading core
15:36:44 <ReinH> structuralist: hmmm... as an aside, any reason you're using foldr inside shortmap instead of foldl'?
15:36:47 <jfischoff_> yes it's wierd
15:36:56 <simpson> EvanR: FWIW I've been running with RWST: Anything immutable/global/configured to read from, a log of non-fatal or informative stuff (profiling, metrics), and the current frame (perhaps a handler stack?)
15:37:04 <structuralist> ReinH: I just adapted Simon Marlow's code from his book
15:37:04 <jfischoff_> the pattern matches everywhere are for sequencing for instance
15:37:08 <simpson> RWST: It's what languages crave.
15:37:09 <ReinH> structuralist: Ah.
15:37:22 <jfischoff_> structuralist: The trick is to copy it and rewrite with better names
15:37:30 <EvanR> simpson: nah im just doing research
15:37:35 <EvanR> going for minimal
15:37:50 <jfischoff_> and to ignore the case statements mostly :p
15:37:50 <simpson> EvanR: Oh. Why not do IO then?
15:38:10 <simpson> You'll probably evaluate I/O effects in IO, right?
15:38:20 <EvanR> there arent any
15:38:30 <jfischoff_> structuralist: if you paste the two cores I can tell you what is going on most likely
15:38:44 <EvanR> i am intrigued to see if Identity monad will do it
15:38:57 <monochrom> > runReader (let m = ($) <$> ask <*> m in m) (\_ -> 0)
15:38:58 <lambdabot>  0
15:40:53 <EvanR> > runIdentity $ do{ hmm <- mapM (fmap succ) [1, 2, undefined]; return (hmm !! 1)}
15:40:54 <lambdabot>  No instance for (GHC.Show.Show a0)
15:40:54 <lambdabot>    arising from a use of ‘M552446911634139658817963.show_M5524469116341396588...
15:40:54 <lambdabot>  The type variable ‘a0’ is ambiguous
15:40:54 <lambdabot>  Note: there are several potential instances:
15:40:54 <lambdabot>    instance [safe] GHC.Show.Show
15:40:54 * ReinH is interested to know why making the *index* strict improves performance
15:41:31 <ReinH> Oh, hmm, boxing/unboxing overhead?
15:41:41 <jfischoff_> that was my total guess
15:41:43 <structuralist> I know right?
15:42:09 <structuralist> jfischoff_: is there a way to diff core modulo variable names?
15:42:21 <simpson> > runIdentity $ do { a <- mapM (fmap succ) ['a', 'b', error "c"]; return (a !! 1) }
15:42:22 <lambdabot>  Couldn't match expected type ‘Data.Functor.Identity.Identity a’
15:42:22 <lambdabot>              with actual type ‘GHC.Types.Char’Couldn't match expected type ‘D...
15:42:22 <lambdabot>              with actual type ‘GHC.Types.Char’
15:42:29 <jfischoff_> I don't know of anything
15:42:36 <jfischoff_> just paste them
15:42:51 <simpson> Blah, clearly not in the Haskell mindset today.
15:43:16 <EvanR> just tried that
15:43:23 <simpson> Success?
15:43:35 <EvanR> see above
15:44:02 <merijn> Identity doesn't really work, it doesn't keep context
15:44:22 <ReinH> jfischoff_: Well, the key is stored unboxed in an IntMap, that's the main speedup you get from using an IntMap over a Map, iirc
15:44:35 <merijn> ReinH: No
15:44:43 <ReinH> merijn: No to the second half, right?
15:44:51 <merijn> ReinH: IntMap uses patriciatrees which are asymptotically faster for lookups
15:44:56 <merijn> It has nothing to do with unboxing
15:44:57 <ReinH> Ah. Great.
15:45:04 <ReinH> Forget I said that stupid thing.
15:45:10 <ReinH> Still, the keys *are* unboxed.
15:45:22 <jfischoff_> we need the core
15:45:25 <ReinH> So wrapping them in a thunk requires boxing/unboxing overhead
15:45:27 <merijn> The real speed is that the max complexity for IntMap is O(max(n,W)) where W is word size in bits and n is the values
15:45:41 <ReinH> merijn: yep, what I said was stupid, please ignore
15:46:08 <nick_cannon> I'm trying to compare two sandwiches for equality...and it kind of works. But I think it's just comparing to see if they are just sandwiches and not the ingredients in them
15:46:18 <nick_cannon> Can someone look at my code and tell me what I'm doing wrong?
15:46:37 <ReinH> nick_cannon: Do you want to do something different than the structural equality you get from the derived instance?
15:46:56 <nick_cannon> ReinH: yes
15:47:21 <ReinH> jfischoff_: Yes, but preferably the core run with the arguments that make it much smaller and easier to read that I can never rememeber...
15:47:25 <Mokosha_> :t curry id
15:47:26 <lambdabot> a -> b -> (a, b)
15:47:35 <ReinH> :t (,) -- :)
15:47:36 <lambdabot> a -> b -> (a, b)
15:47:49 <Mokosha_> zz thanks
15:48:05 <merijn> > (1,,2) 'a' -- whooo! TupleSections!
15:48:07 <lambdabot>  (1,'a',2)
15:48:13 <ReinH> Yay TupleSections
15:48:14 <lpaste> structuralist pasted “fwsparse1 core -- slow” at http://lpaste.net/113918
15:48:19 <lpaste> structuralist pasted “fwsparse1 core -- fast” at http://lpaste.net/113919
15:48:26 <merijn> > (1,,2,,3) 'a' True -- whooo! TupleSections!
15:48:27 <lambdabot>  (1,'a',2,True,3)
15:48:46 <lpaste> structuralist pasted “fwsparse1 core -- slow” at http://lpaste.net/113920
15:49:06 <nick_cannon> > t
15:49:08 <lambdabot>  t
15:49:09 <structuralist> hmm
15:49:14 <nick_cannon> > I'm a stupid head
15:49:15 <lambdabot>  Not in scope: data constructor ‘I'm’Not in scope: ‘stupid’
15:49:20 <structuralist> sorry for the duplicate, got an error page
15:49:20 <nick_cannon> oh... :(
15:49:36 <EvanR> I'm not in scope, stupid
15:49:39 <EvanR> the bot is learning
15:49:40 <nick_cannon> > "I'm a stupid head"
15:49:41 <lambdabot>  "I'm a stupid head"
15:49:44 <nick_cannon> HA!
15:49:49 <nick_cannon> take that technology!
15:50:11 <nick_cannon> EvanR: lol
15:50:56 <ReinH> jfischoff_: important stuff starts at line 214...
15:51:15 <Poutsa> hello
15:52:05 <Poutsa> Hello I made this  http://tinyurl.com/pq4fpj8
15:52:41 <ReinH> ^ spam
15:52:55 <Poutsa> its not spam
15:52:58 <ReinH> Yes. It is.
15:53:01 <Poutsa> I am not a bot
15:53:08 <Poutsa> no
15:53:08 <structuralist> jfischoff_ ReinH: it seems to be replacing . with zi and zm, or am I crazy?
15:53:22 --- mode: ChanServ set +o monochrom
15:53:26 --- mode: monochrom set +b *!*@gateway/web/freenode/ip.94.71.144.126
15:53:26 --- kick: Poutsa was kicked by monochrom (Poutsa)
15:53:28 <ReinH> Poutsa: Not arguing with you. Informing other people.
15:53:31 <ReinH> Thanks
15:53:36 --- mode: monochrom set -o monochrom
15:54:59 <ReinH> jfischoff_: Dunno, I am barely conversational with core...
15:55:10 <structuralist> or maybe zm is _
15:55:12 <structuralist> or -
15:55:21 <structuralist> I used -fext-core
15:56:09 <ReinH> structuralist: I recommend https://hackage.haskell.org/package/ghc-core for core diving btw
15:56:39 <ReinH> Wait, does ghc-core work with 7.8?
15:56:50 <ReinH> I guess I should try it before recommending it.
15:57:30 <structuralist> oh yeah http://stackoverflow.com/questions/6121146/reading-ghc-core
15:57:36 <structuralist> "z encoding"
15:57:38 --- mode: ChanServ set +o monochrom
15:57:40 --- mode: monochrom set +b *!*@gateway/web/freenode/ip.94.71.*
15:58:15 <EvanR> what do i have to install to get Control.Monad.Identity
15:58:15 --- mode: monochrom set -bb *!*@gateway/web/freenode/ip.94.71.144.126 *!*@gateway/web/freenode/ip.94.71.195.193
15:58:18 <ReinH> -ddump-simpl and -dsuppress-coercions were the options I was looking for, I think
15:58:25 --- mode: monochrom set -o monochrom
15:58:50 <ReinH> @hoogle Control.Monad.Identity
15:58:50 <lambdabot> Control.Monad.Identity module Control.Monad.Identity
15:58:50 <lambdabot> Control.Monad.Trans.Identity module Control.Monad.Trans.Identity
15:58:50 <lambdabot> Control.Monad.Trans.Identity IdentityT :: m a -> IdentityT m a
15:58:56 <ReinH> Oh. Thanks hoogle. :/
15:59:03 <ReinH> EvanR: mtl
15:59:48 <EvanR> woo all the transformers
16:03:23 * monochrom is ban-happy. may I ban all of webchat now? :)
16:03:23 <merijn> ReinH: What where you hoping for? >.>
16:03:28 <merijn> No :(
16:03:32 <monochrom> :)
16:03:48 <merijn> Else I'll need to put in effort to bypass the firewall :(
16:03:58 <simpson> TBH it's very strange that a channel of this size doesn't require registered nicks.
16:04:42 <Yxven> I hate forcing registered  nicks
16:05:02 <merijn> simpson: Registered nicks prevent first time newbies from asking questions
16:05:25 <merijn> There's very little spam, so it's a drastic measure that stops curious beginners from accessing the most valuable haskell resource
16:08:22 <EvanR> hehe
16:08:57 <EvanR> evaluate (S [L ["a","b"] "" (Y "a"),Q (Y "$"),S [L ["x"] "" (S [Y "x",Y "x"]),L ["x"] "" (S [Y "x",Y "x"])]])
16:09:02 <EvanR> Y "$"
16:09:28 <EvanR> evaluate (S [L ["x"] "" (S [Y "x",Y "x"]),L ["x"] "" (S [Y "x",Y "x"])])
16:09:29 <EvanR> freeze
16:10:44 <EvanR> using Identity http://lpaste.net/113921
16:15:00 <jfischoff_> structuralist: was afk, back
16:16:29 <jfischoff_> structuralist: what command did you use to produce this core?
16:17:36 <EvanR> is there some issue with using deepseq? i know its not considered good practice, but are there liabilities
16:18:27 <merijn> EvanR: It easy to make linear algorithms quadratic or worse using deepseq
16:19:36 <EvanR> i did this (map succ [1, 2, undefined]) `deepseq` "booya" and curiously i got "*** Exception: undefined, note the quote from the booya
16:19:47 <EvanR> VERY interesting
16:20:15 <EvanR> merijn: example?
16:20:32 <structuralist> jfischoff_: ghc -O2 -threaded -rtsopts -fforce-recomp fwsparse1.hs -fext-core
16:21:18 <merijn> EvanR: suppose 'f :: a -> [a] -> [a]' (or any other recursive datatype) and suppose 'f' deepseq's both arguments
16:21:32 <merijn> EvanR: Now "foldr f x" is quadratic
16:21:59 <merijn> EvanR: Because *every* application of 'f' traverses the entire list in the 2nd argument
16:22:30 <merijn> See also "Schlemiel the Painter"-algorithm
16:22:49 <jfischoff_> structuralist: use ghc-core instead, it produces more readable core
16:23:06 <EvanR> merijn: moral of the story, dont deepseq both your arguments?
16:23:15 <EvanR> hmm never mind
16:23:29 <merijn> EvanR: Don't deepseq until the end of your computation
16:23:47 <merijn> in other words, if you use deepseq in internal computations you're probably screwing up
16:24:05 <EvanR> i got my bomb example to act like eager
16:24:45 <EvanR> http://lpaste.net/113921
16:24:56 <EvanR> args `deepseq` eval context' e
16:25:12 <EvanR> lazyiness is so much easier ;)
16:25:58 <merijn> I would've gone with the monadic approach
16:26:09 <EvanR> Reader [(I,E)] ?
16:26:34 <EvanR> are you sure THAT would work?
16:26:58 <EvanR> seems just as lazy as Identity
16:27:20 <merijn> https://wiki.ittc.ku.edu/lambda_wiki/images/e/e3/Modular-interpreters.pdf
16:27:32 <merijn> THat's more generic than what you need, but maybe it provides inspiration
16:27:47 <merijn> The problem with Identity isn't laziness
16:27:51 <merijn> It's that there's no "abort"
16:27:57 <merijn> You need some form of context
16:28:01 <merijn> Laziness is not relevant
16:28:16 <EvanR> what you say confuses me
16:28:34 <merijn> I guess abort isn't relevant here
16:28:51 <merijn> Within your implementation you need sequencing, not strictness
16:29:21 <merijn> You need to ensure that "eval arg1" happens before "eval (apply fun arg1)"
16:29:49 <EvanR> well the property im trying to get is eager evaluation of all arguments before applying a function, and the convenient test i have is to use a bomb expression in a position that is not used in the body
16:30:05 <EvanR> so im not sure if strictness or what is the word for that
16:30:51 <EvanR> where happens means, is evaluated
16:30:59 <sbrg> what was the name of the library that lets us do :: Expr, again?
16:31:16 <merijn> EvanR: Eager evaluation == "I evaluate arguments before the result of applying a function to it"
16:31:39 <ReinH> EvanR: http://en.wikipedia.org/wiki/Evaluation_strategy#Call_by_value
16:31:44 <merijn> sbrg: simple-reflect ?
16:32:32 <EvanR> so yeah, call by value, its just i never really "got" the point of these names, despite knowing what they are referring to
16:33:07 <EvanR> whats the equivalent in haskell
16:33:30 <lpaste> structuralist pasted “fwsparse1 slow core” at http://lpaste.net/113923
16:33:35 <lpaste> structuralist pasted “fwsparse1 fast core” at http://lpaste.net/113924
16:33:46 <jfischoff_> much better
16:33:53 <structuralist> yeah
16:33:56 <EvanR> call by need
16:34:05 <structuralist> I can see there's some unboxing in the fast version already
16:34:49 <josephle> EvanR: what can I say? People like tradition
16:35:05 <sbrg> merijn: yeah, that was it
16:35:07 <sbrg> thanks
16:36:24 <sbrg> think that's gonna be useful for explaining foldr vs foldl and such to my students
16:39:03 <EvanR> what do you call the call-by-whatever for strict ML?
16:39:24 <monochrom> that's still call-by-value
16:43:45 <EvanR> > (if true then undefined else undefined) `seq` 0
16:43:46 <lambdabot>  Not in scope: ‘true’
16:43:51 <EvanR> > (if True then undefined else undefined) `seq` 0
16:43:52 <lambdabot>  *Exception: Prelude.undefined
16:43:58 <josephle> there's also call-by-name
16:44:17 <josephle> I believe it's generally used now as a teaching tool
16:44:17 <monochrom> the more interesting one is (if undefined then () else ())
16:44:45 <EvanR> > (if undefined then () else ()) `seq` 0
16:44:46 <lambdabot>  *Exception: Prelude.undefined
16:45:00 <EvanR> exciting
16:45:12 <EvanR> basically if is not lazy
16:45:39 <EvanR> which is funny because thats the only thing thats lazy (after && and ||) in other languages
16:46:12 <monochrom> oh, if you're talking about that, then it's (if True then () else undefined)
16:46:23 <EvanR> ah right
16:49:07 <benmachine> being lazy in the *condition* of if is not straightforward
16:51:08 <EvanR> > (if (head [False]) then undefined else undefined) `seq` 0
16:51:09 <lambdabot>  *Exception: Prelude.undefined
16:51:12 <EvanR> yurp
16:52:33 <josephle> the question is essentially: what do you think should be the WHNF of a ternary operator?
16:52:49 <monochrom> spoon can help laziness in the condition of "if" :)
16:54:16 <ReinH> josephle: "evaluate just enough to detect a bottom", which means evaluate the condition and the matching branch?
16:54:18 <EvanR> if a then b else c, the head is obviously `if'
16:54:21 <EvanR> ;)
16:54:52 <benmachine> if you want to be lazy in the condition you have to check that the branches are equal
16:54:57 <benmachine> check/hope
16:56:00 <EvanR> @src cond
16:56:00 <lambdabot> Source not found. Are you on drugs?
16:57:02 <monochrom> cond behaves like if. strict on the condition. strict in the chosen branch, in fact equals it. non-strict in the discarded branch
16:57:52 <ReinH> This is called "joint strictness" by http://en.wikibooks.org/wiki/Haskell/Denotational_semantics and, as far as I can tell, only that article.
16:57:58 <EvanR> just making sure its possible to write functions like this normally
16:59:07 <ReinH> Ok, a few other references to "joint strictness"
16:59:18 <indiagreen> you can probably use something like lub to merge the branches and be able to output the partial value before you even check the condition
17:00:26 <EvanR> indiagreen: lub?
17:00:45 <indiagreen> @hackage lub
17:00:45 <lambdabot> http://hackage.haskell.org/package/lub
17:00:48 <indiagreen> a-ha
17:00:56 <indiagreen> in fact, there's condL in that package
17:01:12 <indiagreen> http://conal.net/blog/posts/lazier-functional-programming-part-2
17:01:30 <indiagreen> “cond [2,3,5] [1,3] ⊥ ≡ ([2,3,5] ⊓ [1,3]) ⊔ ⊥ ≡ ⊥ : 3 : ⊥”
17:01:54 <ReinH> indiagreen: but you need the whole lattice structure
17:02:40 <ReinH> Ah, you meant lub the package, not lub the function.
17:03:13 <monochrom> we do have enough of the whole lattice structure to support 2-ary lub
17:03:45 <ReinH> monochrom: I meant you need both lub and glb, but indiagreen meant the package lub
17:03:57 <monochrom> we just don't have 0-ary lub (i.e., top) and probably a lot of infinitary lubs
17:05:47 <EvanR> condL a b = const (a `glb` b) `lub` (\ c -> if c then a else b)
17:06:16 <EvanR> uh huh
17:06:42 <sagittarian> the condition of an if statement is not generally lazy in any language
17:06:51 <sagittarian> oh oops
17:07:21 <monochrom> EvanR: it is best understood by trying these 3 cases: c=True, c=False, c=bottom
17:08:39 <monochrom> unless you say, you're already stuck at figuring out glb and lub :)
17:10:01 <benmachine> monochrom: 0-ary lub is bottom, we don't have 0-ary glb
17:10:37 <EvanR> glb and lub give the arguments or bottom
17:10:56 <EvanR> man i had it with bottom
17:11:01 <EvanR> go away
17:11:19 <benmachine> glb gives bottom because sometimes that's the only lower bound, so it's also the greatest
17:11:37 <benmachine> lub shouldn't give bottom unless both arguments are bottom
17:12:05 <monochrom> I had lub and glb swapped
17:12:10 <benmachine> bottom is not often an upper bound
17:12:20 <EvanR> flatLub = unamb, so thats the trick
17:13:34 <yukko> what is the difference between Float and Double
17:14:13 <ReinH> yukko: https://www.haskell.org/haskellwiki/Performance/Floating_point
17:15:01 <ReinH> Float is single precisoin, Double is... double.
17:15:10 <ReinH> But there are other things to consider as mentioned in that link
17:15:37 <yukko> single precision?
17:15:56 <benmachine> Float is 32-bit Double is 64-bit
17:16:01 <yukko> ahh
17:16:03 <ReinH> 32-bit vs. yes. http://en.wikipedia.org/wiki/Single-precision_floating-point_format
17:16:05 <yukko> thank you
17:16:17 <monochrom> Float truncates more.
17:16:25 <ReinH> which means even more floating point errors
17:16:35 <benmachine> 1 + 8 + 23 vs. 1 + ...I forget
17:16:49 <benmachine> also I forget which is the 8 and which is the 23
17:16:57 <benmachine> presumably the 8 is the exponent and the 23 is the mantissa
17:17:04 <ReinH> 11 + 52?
17:17:12 <benmachine> sure, why not
17:17:27 <koala_man> why is it called "single" anyways. does it refer to a single machine word on a 32bit arch, or is it just to differentiate it from double?
17:17:34 <ReinH> and yes, 8/11 is exponent, 23/52 is fraction
17:17:38 <EvanR> its half of double
17:17:47 <EvanR> cut it in half, then double it
17:17:52 <koala_man> every x is half a double x
17:18:00 <ReinH> a.k.a. mantissa a.k.a significand
17:18:07 <EvanR> it makes a lot of sense
17:18:19 <monochrom> yes, it is only because if 64 is double, then 32 is single
17:18:24 <ReinH> Well, that's kind of a backwards answer...
17:18:36 <EvanR> haha
17:18:47 <ReinH> It's called single by http://en.wikipedia.org/wiki/IEEE_754-1985
17:19:05 <monochrom> you could imagine, historically, 32 existed first and didn't need an adjective. then someone did 64, so now they needed two adjectives.
17:19:19 <ReinH> heh
17:19:32 <EvanR> could have been half and single
17:19:32 <ReinH> precision floating point -> {single,double} precision floating point
17:19:40 <EvanR> but 16 is half i heard
17:19:44 <ReinH> "I'm using precision floating point numbers"
17:19:59 <EvanR> 8 is quarter precision
17:20:43 <monochrom> it's similar to Wendy's hamburgers. if they had only one kind, it needn't an adjective. but one day they introduced one more kind. now you have to say "classic single" and "class double".
17:20:52 <ReinH> Significand? More like signifiCANT... I'll show myself out.
17:22:08 <monochrom> significand is spelt right.
17:22:16 <ReinH> I know. Thus the joke.
17:22:22 <monochrom> ok haha
17:22:33 <EvanR> significor
17:22:38 <ReinH> I appreciate your pity laugh
17:22:46 <monochrom> :)
17:23:43 <ReinH> EvanR: I get it.
17:23:58 <monochrom> Skeletor and Skeletand
17:24:02 <ReinH> hahaha
17:24:30 <kwantam> Skeletxor wishes to have a word.
17:24:45 <EvanR> skelenand
17:24:49 <ReinH> Skeletna... damn
17:25:01 <koala_man> monochrom: I bet you're right, though there doesn't appear to have been a published version with no qualifiers, so it might have been an internal thing
17:25:24 <EvanR> 32nd precision is isomorphic to Bool
17:27:30 <eacameron1> does anyone know of a way to build a haskell library that can be used by a C++ program on Windows?
17:28:23 <EvanR> eacameron: https://www.haskell.org/haskellwiki/Calling_Haskell_from_C
17:28:36 <EvanR> "Now compile your C code with ghc (!), passing the Haskell objects on the command line:"
17:28:52 <EvanR> C++ programs can interface with C code
17:29:14 <eacameron> EvanR: yeah...am I expected to build my massive Visual Studio project with GHC??
17:30:21 <EvanR> no typically want to statically link anything having to do with haskell, so you want to get some .o file and link this in your solution or whatever
17:30:42 <monochrom> https://groups.google.com/d/msg/haskell-cafe/1eV4-QO9Iko/eA7Sn96VWN0J :)
17:31:00 <ReinH> eacameron: You can export your Haskell functions and compile a dll
17:31:12 <ReinH> eacameron: e.g., http://neilmitchell.blogspot.com/2011/10/calling-haskell-from-r.html
17:31:33 <ReinH> Not sure how up-to-date that is but we do basically that
17:31:41 <koala_man> huh. IEEE754-1985 specifies that even when a system is entirely double-based, it shall be able to specify that a result be rounded to single precision before being stored as a double
17:32:00 <eacameron> ReinH: Interesting. Thanks.
17:32:03 <EvanR> standards are great
17:32:15 <eacameron> Is this accurate? That GHC just compiles to C on Windows? https://www.haskell.org/haskellwiki/GHC/FAQ#Linking_with_Visual_Studio_C.2B.2B_Code
17:32:19 <ReinH> koala_man: that's some nice precision you got there. Would be a shame if something were to... happen to it...
17:32:24 <koala_man> haha
17:32:35 <RevBayes> haha
17:32:45 <RevBayes> #haskell is funny
17:32:55 <monochrom> it is important for reproducing the same answers when you use code written for single precision
17:32:56 <dolio> Lots of systems compute everything to greater than double precision.
17:33:05 <dolio> So you really want that.
17:33:31 <koala_man> monochrom: is that always the case when the intermediate calculations are done as doubles?
17:33:44 <EvanR> > pi :: Double
17:33:46 <lambdabot>  3.141592653589793
17:33:47 <dreams> GHC says that something will become an error in GHC 7.1.0. but mine is 7.8.3 :O..
17:33:49 <EvanR> > pi :: Float
17:33:50 <lambdabot>  3.1415927
17:34:04 <ReinH> eacameron: looks accurate.
17:34:08 <monochrom> no. the standard doesn't say you must truncate or you must not truncate. it says you must offer the programmer the option.
17:35:01 <ReinH> eacameron: so you compile your haskell library into a DLL and Bob's your uncle.
17:35:15 <dolio> It's actually a problem in GHC.
17:35:37 <dolio> You get nondeterministic results on 32-bit x86, unless you enable a flag that tells GHC to use SSE.
17:36:10 <ReinH> eacameron: I don't know the nuts and bolts of this process because I was supposed to work on our windows build system and then they told me not to ;)
17:36:15 <ReinH> But I know we actually do it
17:37:01 <EvanR> i still like the idea of building your massive visual studio project with ghc (!) (??)
17:37:29 <eacameron> EvanR: sometimes I wish I could....
17:37:29 <EvanR> next version of ghc will be able to read your mail
17:38:00 <ReinH> "It looks like you're trying to write a function with foldl. Would you like some help with that? 1) use fold' 2) use foldr"
17:38:42 <monochrom> will GHC delete spams in my mail?
17:38:49 <koala_man> monochrom: I mean is extending -> double op -> truncating always bit identical to a single op, even for things like sqrt?
17:39:10 <rom1504> monochrom: GHC will also make you coffee
17:39:21 <monochrom> I think yes
17:40:04 <eacameron> By the time it's installed the dependencies, GHC will make your coffee cold.
17:40:38 <ReinH> no, lens will do that
17:40:52 <ReinH> but GHC will help
17:41:22 <eacameron> ReinH: "It appears you're trying to writing an FRP-based MMORPG with UDP-based messaging and WebGL. There's an abstraction for that."
17:42:22 <koala_man> monochrom: ah, it doesn't matter. It specifically states that the truncated result "cannot suffer more than one rounding error", so it's not the same as extending, operating and truncating
17:44:01 <stian_> @pl k x y = filter ( not . (`elem` x)) y
17:44:01 <lambdabot> k = filter . (not .) . flip elem
17:44:56 <indiagreen> stian_: can't you use `notElem` here
17:46:33 <stian_> indiagreen: Didnt’ know about that function, indeed I can. Thanks
17:53:38 <dreams> is MonadZero no longer in the library?
17:54:02 <ReinH> notElem: preventing you from writing (not .) . flip elem since... whenever...
17:54:49 <dreams> oh its MonadPlus
17:58:58 <Cale> dreams: Yeah, its removal is one of the sadder mistakes made in Haskell 98. Hopefully it can come back at some point.
17:59:31 <Cale> At least people have stopped using Monad/fail as if it were MonadZero/mzero.
18:00:48 <stian_> Trying to install lambdabot, complains about module Network.URI
18:15:25 <Fuuzetsu> Network.URI was split out from network package in network 2.6
18:15:31 <Fuuzetsu> it is now in network-uri package
18:17:28 <ReinH> stian_: does lambdabot have an upper bound on network in its cabal file?
18:17:55 <ReinH> try cabal configure --constraint="network < 2.6", I think that's the option
18:31:59 <dreams> I'm a bit stuck. http://lpaste.net/113927  Trying to test >>== and return, but can't tell where to supply argument for (item >>= \x -> return x)
18:32:30 <dreams> (item >>= \x -> return x) "something" yields a type error
18:34:26 <comerijn> dreams: Ah
18:34:45 <comerijn> dreams: You'll want to write "runParser (Parser f) = f"
18:35:07 <comerijn> dreams: That will have type "Parser a -> String -> [(a,String)]"
18:35:37 <exio4> what about using record syntax?
18:35:43 <edwardk> you can just swap to newtype Parser a = Parser { runParser :: String -> [(a,String)] }
18:35:44 <edwardk>  
18:35:44 <comerijn> dreams: Remember that "(item >>= \x -> return x)" is a value of type "Parser", *not* a function
18:36:18 <comerijn> Yeah, I decided not mentioning record syntax until the fundamental confusion was gone would be simpler :)
18:36:25 <edwardk> fair
18:36:36 <comerijn> dreams: And applying non-function values to other values is a type error, hence the complaint
18:36:40 * edwardk backs off to avoid too many cooks in the kitchen
18:36:43 <dreams> comerijn: let me try and absorb what you said
18:37:26 <comerijn> dreams: oh, you even already have a "parse" function which you're using inside your implementation of >>=
18:38:05 <dreams> yes I just used it instead
18:39:11 <dreams> merijn: nice thanks
18:39:23 <merijn> Note that exio4 and edwardk are correct, it's common to define newtypes using record syntax so you can just use the field accessor as a "run" function, but that's a minor detail
18:39:36 <merijn> (i.e. you'd write it as edwardk suggested)
18:40:13 <dreams> what do you mean by " use the field accessor as a "run" function"
18:40:40 <merijn> With edwardk's notation you'd use "runParser" like your current "parse" function
18:40:41 <edwardk> newtype Parser a = Parser { runParser :: String -> [(a,String)] } -- would make a function runParser :: Parser a -> String -> [(a, String)]
18:40:49 <edwardk> it is what you wrote separately as 'parse'
18:40:52 <merijn> "runX" is a common idiom for naming "unwrap" accessors of newtypes
18:41:10 <edwardk> newtype Parser a = Parser { parse :: String -> [(a,String)] } -- would get you what you have without a separate definition
18:41:11 <dreams> oh nice
18:41:36 <merijn> dreams: FYI, I would probably use either "String -> Maybe (a, String)" or "String -> Either MyError (a, String)" as types for Parser :)
18:41:42 <edwardk> why does that work? data Foo = Foo { bar :: Int, baz :: Double } -- gives you two functions bar :: Foo -> Int   and baz :: Foo -> Double
18:41:48 <edwardk> those are field accessors
18:42:19 <edwardk> well there is also a reason to play with the list of successes parser, it is sort of classic, going back to the mid 80s due to wadler ;)
18:42:39 <dreams> edwardk: Ah I see
18:42:52 <dreams> merijn: I am following a tutorial. trying to get the basic idea first.
18:42:58 <merijn> edwardk: Sure, I just personally find it more confusing. I'm not saying the list approach is wrong :)
18:43:10 <dreams> by Hutton
18:43:14 <merijn> dreams: In that case, just leave it like that :)
18:43:53 <merijn> I like parser combinators as intro FP tool, too bad the professor at uni shot it down when I wanted to do parser combinators for our ocaml class
18:44:43 <Welkin> should I use UTCTime or ZonedTime ?
18:44:52 <Welkin> is there any advantage to using ZonedTime?
18:44:56 <merijn> Welkin: "It depends"
18:45:03 <Welkin> this is to store a "date of purchase"
18:45:17 <dreams> merijn: its an intro to parsing for me. I wonder how does that compare to the imperative approach.
18:45:29 <merijn> Welkin: You should use UTCTime internally in your program and use ZonedTime for displaying to users
18:45:46 <Welkin> sounds good, thanks
18:46:21 <merijn> dreams: The imperative world either 1) writes hand written parsers recursive descent parser (i.e. parser combinators but ugly) 2) hand-written optimised parsers (WAAAAAY uglier) or 3) parser generators
18:46:40 <merijn> Approach 3 leaves you in a maze of shift/reduce conflicts, all alike
18:47:03 <merijn> I wouldn't recommend any of them as fun, unlike parser combinators :p
18:47:25 <riceNbeans> the evil servers must be stopped
18:48:04 <dreams> merijn: I will try them anyway, just to appreciate parser combinators in Haskell :p
18:49:34 <edwardk> dreams: the dragon book still haunts my dreams. ;)
18:51:02 * jfeltz fears.
18:52:02 <stepkut`> what is the easiest way to get keydown/keyup events in Linux+Haskell. Seems excessive to use SDL.. but even things like ncurses don't seem to have keydown vs keyup
18:52:22 <edwardk> sdl2 is pretty easy for that sort of thing =P
18:52:39 <jfeltz> what does xev use?
18:52:44 <edwardk> https://github.com/ekmett/quine/blob/master/src/Quine/Input.hs#L48
18:52:51 <exio4> stepkut`: SDL is really easy to use, and under linux, really easy to setup
18:53:42 <vanila> edwardk, love the escher reference
18:53:44 <edwardk> i bother to track both keycodes and scancodes so i can have somethings take semantic content from the key, and others take positional information (WASD, etc.)
18:53:51 <vanila> just came across quine earlier today
18:55:04 <edwardk> i'm currently hacking it up to switch from running shader toys to having a coherent pipeline
18:55:27 <edwardk> so its about to enter an unuseful phase of its lifecycle in terms of actually running it to get output
19:06:38 <dreams> When I run (parse (do x <- item; return x) "hello") in GHCi I get this exception http://lpaste.net/113928
19:07:16 <dreams> Is it using GHC.Base.>>= instead of the Parser' one?
19:09:21 <geekosaur> I see no line 20 in there
19:09:44 <dreams> line 20 is (instance Monad Parser where)
19:10:13 <dreams> which is 14
19:10:19 <ReinH> dreams: Oh. Yes. I submitted an issue for that. I guess they didn't fix it yet.
19:10:30 <ReinH> dreams: needs RebindableSyntax iirc?
19:11:03 <dreams> ReinH: RebindableSyntax is an extension?
19:11:13 <ReinH> yes
19:11:16 <exio4> why are you hiding (>>=)?
19:11:18 <geekosaur> I am confused. if Monad is not also being redefined (I do not see it there, nor it being excluded from Prelude), doesn't it require the standard ones?
19:11:50 <ReinH> Oh, this isn't NICTA?
19:12:53 <dreams> exio4: I thought ghci would complain for "Ambiguous occurrence". I just tried it, it doesn't. It did for return though.
19:13:04 <Welkin> what is the best way to retrieve data from environment variables to be used in config files?
19:13:07 <geekosaur> indentation
19:13:15 <Welkin> is it possible? for example, in yesod's settings.yml
19:13:25 <geekosaur> your return and (>>=) are not inside the instance declaration
19:13:41 <geekosaur> because they are at the same indentation level as the instance declaration, which ends the where clause
19:14:09 <geekosaur> so you are redefining both at the top level instead of providing instance definitions for them
19:14:28 <dreams> geekosaur: how should they be indented? two spaces?
19:14:57 <geekosaur> any amount that's more than the start of the word "instance"
19:15:02 <geekosaur> 2 or 4 spaces is common
19:15:07 <geekosaur> tabs are a bad idea
19:15:09 <dreams> let test
19:16:25 <dreams> geekosaur: weird, now it says: ‘return’ is not a (visible) method of class ‘Monad’
19:16:38 <geekosaur> yes, because you're still hiding it
19:16:59 <geekosaur> which you wre doing because you misunderstood the error that was caused by bad indentation
19:17:20 <dreams> geekosaur: awesome, it works. I though its going to clash when you don't hide it
19:17:31 <geekosaur> you should only hide those if you are also hiding Monad (which I think requires a more restrictive import)
19:17:43 <dreams> ah I see, it was complaining about Ambiguous occurrence because they were top-level functions
19:17:45 <geekosaur> no, because you are providing instance specific definitions of the class methods
19:17:58 <geekosaur> so you need the class methods in scope to provide the instance
19:18:17 <geekosaur> and yes, because of the missing indentation you were hiding the class ones
19:18:20 <dreams> geekosaur: great thanks.
19:23:07 <Korsakoff> anyone here who can tell me why this is giving me an error?
19:23:11 <Korsakoff> maximumBy (comparing snd) ( filter (\(x,_) -> any (==x) ["a","b"]) [("a",1),("b",2),("c",3)])
19:23:22 <Korsakoff> > maximumBy (comparing snd) ( filter (\(x,_) -> any (==x) ["a","b"]) [("a",1),("b",2),("c",3)])
19:23:24 <lambdabot>  ("b",2)
19:28:05 <stepkut`> exio4: yeah -- my code is currently using SDL, but the SDL library I was using has not been updated to 7.8.3 it seems, so I figured it was time to check if I should use something else anyway
19:28:57 <Yxven1> the high level bindings for sdl2 should be released soon
19:29:22 <Yxven1>  the low level bindings should be complete and in good shape
19:56:07 <dmj`> is anyone here from kansas city
20:00:54 * hackagebot 3dmodels 0.3.0 - 3D model parsers  http://hackage.haskell.org/package/3dmodels-0.3.0 (capsjac)
20:01:35 <prinsen> I have a problem, maybe related to impredicative types. I have a type JavaScriptM a = forall m. (Monad m) => ExceptT T m a. I have a data Object with a field objectCall :: JavaScriptM (), so far so good. However, if I try to write a lens to that field, it blows up. It says it cant match JavaScriptM () with JavaScriptT m0 ()
20:02:33 <emmanueloga> hey. If anybody feels like it could you point out the un idiomatic parts / eyesores in this snippet: https://gist.github.com/EmmanuelOga/dbc3310b899afdbdda0d  txs! (this is like, my 3rd haskell "program" or something like that :-)
20:05:23 <merijn> emmanueloga: "read s" is always an eyesore :)
20:05:35 <merijn> I recommend Text.Read.readMaybe
20:05:45 <merijn> :t Text.Read.readMaybe
20:05:46 <lambdabot> Read a => String -> Maybe a
20:07:42 <emmanueloga> ah, somebody told me about that one recently, txs!
20:12:07 <emmanueloga> btw, I already caught a couple of LYAH typos... too bad I can't see a way to report them.
20:14:42 <emmanueloga> anybody knows who this Lipovača guy is? he seems a bit of a mysterious figure :) Doesn't seem to have much of a presence online.
20:16:35 <Welkin> does anyone use stripe in here?
20:16:51 <Welkin> what is the different between the "stripe" and "stripe-haskell" packages on hackage?
20:17:08 <merijn> emmanueloga: He was active on here for a fairly long time, but he mostly disappeared shortly after LYAH
20:17:15 <merijn> emmanueloga: I think he's busy with work these days
20:18:30 <joelteon> Welkin: which do you like better?
20:19:11 <Welkin> one is older, while the other was recently added
20:19:52 <Welkin> stripe-haskell seems to have more documentation
20:20:32 <Welkin> is dmj` also dmjio?
20:21:32 <Welkin> joelteon: while you are here, is there a way to customize the templates for yesod-auth?
20:23:30 <joelteon> i'll check
20:23:54 <joelteon> Welkin: #yesod
20:34:07 <Welkin> well... stripe-haskell depends on base=4.7.*
20:34:31 <joelteon> that's ridiculous
20:34:41 <Welkin> oh
20:34:45 <Welkin> I have 4.7 anyway
20:34:58 <Welkin> but it still won't resolve the dependencies
20:37:37 <dmj`> Welkin: ping
20:37:43 <Welkin> it looks like random could be the issue?
20:37:53 <Welkin> dmj`: are you dmjio?
20:37:56 <dmj`> yea
20:38:06 <Welkin> I'm having trouble with stripe-haskell
20:38:15 <Welkin> resolving deps
20:38:48 <dmj`> are you using a sandbox
20:38:51 <Welkin> yes
20:39:09 <dmj`> did you run cabal update
20:39:09 <Welkin> I think random is the problem, but wouldn't cabal just update it is that were the issue?
20:39:23 <Welkin> unless another package that yesod depends on requires that lower version of random
20:40:08 <Welkin> updating now
20:40:19 <dmj`> it installs fine into a fresh sandbox for me
20:40:51 <Welkin> it's not a fresh sandbox
20:41:09 <Welkin> it has yesod and lots of yesod extensions isntalled
20:41:27 <Welkin> yeah, random is the issue
20:41:41 <Welkin> rejecting: stripe-haskell-0.1.0.4 (conflict: hspec =>
20:41:41 <Welkin> random==1.0.1.1/installed-b44..., stripe-haskell => random>=1.1)
20:41:54 <prinsen> I have a problem, maybe related to impredicative types. I have a type JavaScriptM a = forall m. (Monad m) => ExceptT T m a. I have a data Object with a field objectCall :: Maybe (JavaScriptM ()), so far so good. However, if I try to assign a value of Just (JavaScriptM ()) to that field, i get the error: Can't match JavaScriptT m1 () with JavaScriptM () in the first argument of Just.
20:42:16 <dmj`> Welkin: I can lower the upper bound
20:42:20 <dmj`> give me a sec
20:43:03 <Welkin> dmj`: also, why does base need to be exactly 4.7.*?
20:43:11 <Welkin> isn't that too restrictive?
20:44:51 <dmj`> yes
20:45:33 <dmj`> give me a sec
20:55:32 <dfeuer_> prinsen, why do you think impredicative types are involved?
20:56:25 <dfeuer_> Also, prinsen, you should use lpaste or gist or something to show the code.
20:57:20 <texasmynsted> If I want to do a lot of string/text manipulation, would I use the Data.Text module, or something else?  Specifically, reading files and strings and transforming the text based on a "template".  The kind of thing somebody might use sed or M4 to do, but in this case using haskell.
20:58:44 <dfeuer_> texasmynsted, I'm no expert, but you almost certainly want to use that module, and probably want to pair it with some other, more specialized ones.
20:59:25 <texasmynsted> ok, such as?
21:00:26 <dfeuer_> texasmynsted, like all sorts of parsing libraries built on top of that.
21:00:51 <texasmynsted> How about for template processing?  Is there something that people typically use for that/
21:01:14 <dfeuer_> Like I said, I don't know much at all about such things, but check out conduit and pipes-parse and probably also attoparsec.
21:02:18 <texasmynsted> I saw this.  This was a little surprising.  http://honza.ca/2012/10/haskell-strings
21:02:33 <texasmynsted> Ok, I will check the modules you mentioned.
21:03:34 <texasmynsted> Is there some place that I should be looking?  Just entering what I expect I would need in Hoogle, is seemly the slow way.
21:04:05 <texasmynsted> Don't get me wrong Hoogle is a miracle in goodness.
21:04:41 <dfeuer_> texasmynsted, like I said, I'm not the expert around here, but you definitely want to get real familiar with Hackage.
21:05:09 <dfeuer_> Browse through packages by category, see what looks interesting/popular/well-maintained...
21:05:29 * texasmynsted checks hackage
21:06:03 <Welkin> dmj`: any updates?
21:07:06 <dmj`> wait for it
21:08:12 <Welkin> okay
21:09:48 <dmj`> Welkin: cabal update and try now
21:10:56 * hackagebot stripe-haskell 0.1.0.5 - Stripe API for Haskell  http://hackage.haskell.org/package/stripe-haskell-0.1.0.5 (DavidJohnson)
21:11:07 <Welkin> your docs are not online for the new version
21:11:14 <dmj`> I'm uploading them now
21:11:17 <Welkin> oh
21:11:42 <Welkin> does base need to be restricted to such a degree?
21:12:12 <dmj`> Welkin: are you using 7.6.3?
21:12:44 <texasmynsted> wow…  I mean wow, there are sooooo many modules.
21:13:02 <Welkin> 7.8.3
21:13:34 <dmj`> then you're fine
21:13:36 <dmj`> docs are up
21:14:04 <Welkin> thanks
21:14:10 <dmj`> does it work?
21:14:48 <Welkin> installing now
21:15:22 <Welkin> dmj`: how does your package compare to the other stripe library?
21:16:03 <dmj`> It supports the entire api
21:16:05 <dmj`> http://www.reddit.com/r/haskell/comments/2klxr5/ann_stripehaskell_100_api_coverage_for_stripe/
21:16:10 <Welkin> are there any fundamental differences?
21:16:15 <dmj`> see my posts under ocharles
21:16:52 <Welkin> ocharles is everywhere I look
21:17:20 <charlie> hi
21:17:26 <dmj`> where hs-stripe ends, stripe-haskell adds, "Invoices, InvoiceItems, Refunds, Recipients, Transfers, Events, Disputes, Application Fees, Application Fee Refunds, Balance, and Account API calls"
21:17:27 <Welkin> ah!
21:17:38 <Welkin> charlie, the evil twin of ocharles!
21:17:54 <Welkin> okay
21:18:10 <Welkin> thanks for the help
21:18:17 <Ouyang> cabal is satan how do I overcome cabal
21:18:20 <Welkin> it looks lik the docs are a bit more fleshed out as well
21:18:33 <dmj`> Welkin: stepkut is currently making a backend agonstic version of the code, so it will change, there will be a stripe-http-streams, stripe-pipes, etc
21:19:13 <Welkin> what does that mean for me as a user?
21:19:50 <dmj`> Welkin: it means you won't have to have both http-conduits and http-streams installed, which lessens your dependency load, lowering your chances of cabal hell
21:20:01 <Welkin> that sounds good
21:20:06 <dmj`> so if you want to use yesod and stripe you can install stripe-conduit
21:20:19 <Welkin> I see now
21:20:29 <Ouyang> would anyone be interested in the idea of cabal stress relievers?
21:21:31 <joelteon> like a squeezable stress cabal?
21:21:35 <Ouyang> yes
21:21:47 <Ouyang> caball
21:21:51 <dmj`> Welkin: the stripe-core package will "purify" stripe so request creation is pure, and response parsing is pure, only IO is abstracted out and implemented in terms of other backends, which is for sending the StripeRequest object, it also removes all Monads too... so that will be a bigger change
21:23:18 <ReinH> Woo looks like we're doing another haskell cast this month.
21:23:32 <Welkin> dmj`: what is the timeline for that release?
21:23:48 <joelteon> Ouyang: what would it look like
21:23:52 <ReinH> dmj`: That seems nice. I might try that with my docker library.
21:24:05 <Welkin> Ouyang: Ouyang Feng!
21:24:15 <Ouyang> Welkin: ?
21:24:22 <Welkin> didn't get the reference?
21:24:25 <Ouyang> joelteon: idk, probably the devil
21:24:30 <Ouyang> Welkin: nope sorry
21:24:55 <Welkin> from shen diao xia lu
21:25:00 <dmj`> Welkin: it's close, stepkut has a fork, we just need to rewrite the tests in terms of the new api
21:25:50 <Ouyang> not a big consumer of chinese entertainment.  I mostly just sit in my room and cry about grub and cabal
21:25:53 <dmj`> ReinH: nice! docker library sounds cool
21:25:54 <Welkin> Ouyang Feng is the guy who goes "crazy" and forgets his name, thus becoming Ouyang Feng
21:26:41 <ReinH> dmj`: there already is one but I don't like it
21:27:09 <ReinH> dmj`: right now mine is a relatively thin wrapper on top of wreq, with conduit for some streaming endpoints
21:27:30 <ReinH> I'm going to write one for fleet as well
21:28:09 <joelteon> cabal is my friend
21:28:23 <dmj`> ReinH: hmmmmm :D very cool, is Docker api all json?
21:28:23 <joelteon> if you use a different package manager for dependency resolution, cabal becomes much nicer
21:29:38 <ReinH> dmj`: yep
21:29:55 <ReinH> joelteon: cabal is not my friend right now
21:31:51 <Ouyang> joelteon what do you mean?
21:32:23 <joelteon> Ouyang: cabal is only my package builder
21:32:25 <Ouyang> Im on arch right now... I tried to switch to nix but it seemed like a whole new problem to me.  with channels, expressions, and nixpkgs and all that
21:32:26 <Welkin> I think he means using Stackage instead of Hackage
21:32:35 <joelteon> no
21:32:39 <joelteon> nix
21:32:43 <Welkin> oh, nix as well
21:32:48 <Welkin> I have yet to try that out
21:33:02 <Ouyang> nix made me want to punch a wall
21:33:18 <Welkin> I'm using osx right now
21:34:33 <Ouyang> I really dig how pacman seems to work for everything
21:34:39 <Ouyang> then I got into yesod
21:34:44 <Ouyang> and oh boy that is fun
21:35:00 <Ouyang> cabal : error 1
21:35:16 <Ouyang> I love the Haskell language, im only starting out.  But cabal seems like a nightmare
21:35:57 * hackagebot hakaru 0.1.4 - A probabilistic programming embedded DSL  http://hackage.haskell.org/package/hakaru-0.1.4 (pravnar)
21:36:24 <Welkin> cabal isn't too bad
21:36:29 <Welkin> as long as you use sandboxes
21:36:42 <Welkin> you can diagnose the problem pretty easily
21:41:52 <Ouyang> diagnosisng is easy yeah, but from my experience for using it for a month, it takes a long time to sort stuff out
23:41:01 * hackagebot hzulip 1.0.0.0 - A haskell wrapper for the Zulip API.  http://hackage.haskell.org/package/hzulip-1.0.0.0 (yamadapc)
23:49:17 <dfeuer_> Slow tonight.
