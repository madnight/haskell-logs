00:04:38 <merijn> oh, bolllocks
00:04:53 <merijn> That moment you realise that case-insensitive filesystems screw over your pretty code >.>
00:06:31 <johnw> haha
00:06:39 <johnw> I have the opposite moment
00:06:50 <johnw> when I've failed to account to case-sensitivity, because my own FS is not
00:07:53 <merijn> I thought scanning a directory for all valid haskell modules was easy, but I forgot to account for the fact that filenames aren't necessarily valid module names :(
00:08:14 <johnw> btw, find-conduit can help you with filesystem scanning
00:08:28 <johnw> since it was designed to do it, using arbitrary predicates, and to do it *fast*
00:08:46 <merijn> johnw: Eh, I don't think I can get find-conduit and dependencies into the GHC tree :)
00:08:50 <johnw> oh, haha
00:10:54 <merijn> johnw: Did you see my new cool thing for 7.10? :D
00:11:01 <johnw> what was it again?
00:11:09 <merijn> -fdefer-typed-holes :)
00:11:23 <johnw> ooh, does that turn _ into like undefined?
00:11:34 <merijn> Yeah :)
00:11:38 <johnw> THANK YOU
00:11:42 <johnw> omg, I've wanted that so bad
00:11:50 <merijn> johnw: It's basically -fdefer-type-errors but for holes only :)
00:12:16 <johnw> oh, I get it
00:12:19 <johnw> I've wanted it many times
00:12:34 <merijn> johnw: You can also disable the hole warnings now (in case you use syntastic for error highlighting in vim, like me)
00:13:29 <johnw> good night, merijn
00:13:51 <merijn> Night!
00:18:56 * hackagebot linear 1.15.2 - Linear Algebra  http://hackage.haskell.org/package/linear-1.15.2 (EdwardKmett)
00:20:38 <kqr> is there a sort of "monadic fold" which allows the accumulator and combining function to be working within a monad? I'm guessing it'd look something like (a -> m b -> m b) -> m b -> t a -> m b
00:20:58 <jle`> :t foldM
00:20:59 <lambdabot> Monad m => (a -> b -> m a) -> a -> [b] -> m a
00:21:11 <jle`> :t T.traverse
00:21:12 <lambdabot> (Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)
00:21:25 <jle`> oh
00:21:45 <kqr> foldM sounds like it
00:21:55 <jle`> yeah, you'll just need to `bind`
00:22:03 <kqr> bind?
00:22:22 <jle`> to make the types match up
00:22:35 <jle`> (=<<) etc.
00:22:54 <kqr> but I think the foldM type is exactly what I want already
00:23:00 <jle`> ah, ok :)
00:23:07 <jle`> hooray!
00:23:09 <kqr> \o/
00:23:28 <kqr> I just arrived at work so I can't try yet though
00:23:35 <kqr> just a little something I was thinking about on the train
00:26:26 <Welkin> kqr do you program in haskell at work?
00:26:34 <kqr> unfortunately no
00:26:53 <kqr> ...at least not yet
00:27:02 <kqr> *evil laugh*
00:28:44 <kqr> boss always jokingly asks if we should switch to haskell
00:28:53 <kqr> but I think we have way too much invested into our current stack to throw it all away
00:29:01 <kqr> besides, we're still having to maintain the old stack we used
00:29:05 <kqr> I don't want to maintain three stacks
00:29:28 <kqr> two is bad enough
00:29:36 <tdammers> kqr: depends
00:29:57 <tdammers> kqr: I'd rather split my time between three stacks of which two are shitty, than maintaining two shitty stack full-time
00:30:14 <tdammers> *stacks
00:31:17 <kqr> sure
00:31:35 <kqr> but i'd have to maintain two shitty stacks full-time while trying to build something with the decent stack
00:31:51 <kqr> cutting on the shitty stack maintaining isn't financially viable at the time
00:33:27 <sgronblo> friend of mine was at an interview recently where he asked the interviewer if engineers had a free choice in languages when starting new projects, the joke was "sure, as long as you dont do it in something crazy like haskell"
00:37:11 <tdammers> kqr: "isn't financially viable" is bullshit. apologist management lingo for "we need to meet profit goals for this quarter, fuck long-term thinking"
00:37:28 <tdammers> or even just "I want you to work for free"
00:37:39 <kqr> tdammers, nah, i'm sure boss would be all over it if I presented it nicely to him
00:37:49 <kqr> tdammers, he's trusting his engineers to do the engineer bit to 100%
00:37:51 <tdammers> thing is, a shitty stack is a liability
00:37:58 <tdammers> but you know that
00:38:19 <kqr> yeah, the current stack isn't shitty
00:38:24 <kqr> just... suboptimal
00:38:27 <tdammers> oh, ok
00:38:36 <tdammers> then make it evolve into something less suboptimal
00:38:37 <kqr> we have lots of things to improve around it besides the language
00:38:51 <tdammers> in the grand scheme of things, language is mostly irrelevant
00:38:55 <tdammers> unless the language is PHP
00:39:00 <kqr> haha yeah
00:39:15 <kqr> php is the old shitty stack we still have to poke at sometimes but mostly leave alone
00:39:21 <kqr> the new stack is a python/django thing
00:39:31 <kqr> s/new/current/
00:39:33 <tdammers> I call that shitty too, but hey
00:39:52 * tdammers dislikes fat monolithic frameworks
00:40:28 <kqr> i dislike them too
00:40:49 <kqr> I recently found out that that's the only kind of framework some people know
00:41:13 <tdammers> even flask is way too heavy IMO, but it's the best I could find so far, at least as long as "must be in a mainstream language" is a requirement
00:41:19 <solatis> kqr: otherwise it's called a 'library'
00:41:21 <solatis> or LISP
00:41:23 <solatis> :)
00:41:25 <tdammers> haha
00:41:36 <tdammers> but yeah, I guess I dislike frameworks in general
00:41:47 <kqr> I've been experimenting with yesod
00:41:50 <tdammers> just give me a bunch of libraries for all the subtasks, with sane integration points
00:42:02 <solatis> anyway, as someone who has been at both ends of the discussion, every organisation has to cope with code rot / liabilities
00:42:03 <kqr> which is split into database stuff (persistent and esqueleto) and such
00:42:09 <kqr> my friend kept referring to all of that as "yesod"
00:42:10 <tdammers> yesod is interesting
00:42:12 <kqr> bugged me a lot
00:42:28 <kqr> i was like "no yesod doesn't do anything with the database"
00:42:31 <kqr> he didn't understand :(
00:42:34 <tdammers> but I would only use it if someone bought me a suitable dev workstation for it
00:42:51 <solatis> i thought 'persistent' was part of the yesod stack too?
00:42:58 <Welkin> yesod is nice
00:43:09 <tdammers> solatis: well, there are a lot of projects that started out as yesod spinoffs
00:43:14 <chrisdone> persistent is just a database that yesod scaffolds use
00:43:34 <solatis> don't say anything bad about yesod, what that guy has done is nothing short of amazing
00:43:40 <tdammers> or were built to support yesod, but are generalized and isolated enough to be libraries in their own right
00:43:53 <tdammers> and yes, it's amazing, but not my cup of tea
00:44:25 <chrisdone> tdammers: what, the scaffold?
00:44:33 <solatis> no, yesod in general
00:44:39 <tdammers> the scaffold especially, yes, but yesod in general
00:44:48 <tdammers> feels too magical, and too heavyweight for my taste
00:44:58 <tdammers> I'm not saying it's bad, it just doesn't fit my style
00:45:01 <solatis> well once you realise it's all the product of one man's imagination
00:45:22 <solatis> i have deep respect for the guy
00:45:23 * tdammers nods
00:45:25 <tdammers> absolutely
00:45:27 <solatis> too bad he's only one man
00:45:33 <solatis> lots of gnarly edge cases
00:45:53 <solatis> cannot use the persistent library, for example, because of edge-case bugs i ran into
00:46:06 <solatis> and it's just too complex a beast for me to contribute patches / fix bugs for
00:46:43 <tdammers> indeed, the complexity is kind of a turnoff
00:47:22 <kqr> tdammers, I also have trouble with magical heavyweight things. unfortunately i've found out they are great for Getting Things Done™
00:47:37 <solatis> yep, especially in the javascript and python world
00:47:47 <solatis> choose a framework, stick with it, and keep shipping code
00:48:04 <solatis> and when your framework gets outdated, jump ship and get a new job
00:48:05 <kqr> tdammers, as long as your doing normal things which the framework is intended for, you get a lot of stuff done with minimal effort
00:48:15 <kqr> you're*
00:48:17 <tdammers> kqr: they're great for getting standard things done fast and in a "80% correct, good enough, ship it" fashion
00:48:21 <chrisdone> i've written haskell apps in cgi, snap, scotty and yesod. they all pretty much do the same thing with varying degrees of convenience
00:48:28 <tdammers> that's not what interests me a lot though
00:48:56 <solatis> tdammers: no, they're great in the sense that they cover 80% of the use cases
00:49:01 <solatis> you belong to the other 20%
00:49:17 <kqr> i don't think a person belongs anywhere in those ratios
00:49:18 <chrisdone> the trick is not to "drink the koolaid" for one particular thing and just use the bits that you like
00:49:18 <tdammers> I would argue that they only really cover about 20% out-of-the-box
00:49:19 <kqr> projects do
00:49:44 <kqr> depends on the project. some projects will be 98% covered, some projects will be 2% covered
00:49:47 <kqr> and anything in between
00:49:56 <solatis> anyone has ever had a journey into the scala ecosystem?
00:50:00 <tdammers> for another 60% or so, the extra effort required to get something good enough roughly balances out against the time and effort you win on the parts that the framework covers
00:50:07 <solatis> they are the epithome of a 'big framework'
00:50:08 <kqr> and knowing requirements beforehand is difficult as ever
00:50:30 <solatis> the company pushing scala a lot, Typesafe, has made a HUUUUGE framework/ecosystem
00:50:37 <solatis> the Play Framework
00:50:39 <solatis> google it
00:50:39 <tdammers> and for the most interesting 20%, what the framework does for you isn't really a lot, and for the rest, the framework gets in your way more than it helps you
00:50:41 <solatis> it's insane
00:50:41 <tdammers> so
00:50:59 <solatis> https://www.playframework.com/
00:51:13 <solatis> don't forget that the whole thing includes:
00:51:17 <solatis>  - a build system
00:51:25 <solatis>  - a database
00:51:41 <solatis>  - a command-line interface for the build system (as in, interpreter)
00:51:48 <solatis>  - and oh yeah, they provide a web framework too
00:51:56 <Welkin> I avoid any language that runs on the JVM
00:52:34 <solatis> Welkin: at the company i used to work for, the JVM was 'the language' -- as in, you could choose any language you like, if only it compiles to the JVM
00:52:50 <solatis> so i could use clojure and other people could use scala
00:52:54 <solatis> everyone happy
00:53:02 <solatis> (i've grown to hate scala)
00:56:36 <sgronblo> tdammers: dont forget there is a new PHP nowadays called Hack which sounds like it has the potential to be better than python or ruby
00:57:31 <Welkin> that is just facebook's DSL for manipulating php
00:57:50 <Welkin> and it is easy to be better than python or ruby -- they are not good to begin with
00:58:49 <tdammers> sgronblo: isn't Hack just PHP with type annotations and a bit of metaprogramming?
00:59:44 <sgronblo> solatis: play framework includes a database and a build system?
01:00:03 <sgronblo> tdammers: i heard it also magnifies the functional parts
01:00:04 <solatis> sgronblo: well not literally, it just forces you onto one
01:00:17 <solatis> which happens to also be built by typesafe
01:00:25 <tdammers> sgronblo: PHP has functional parts? :P
01:00:27 <solatis> play framework requires the play activator
01:00:38 <solatis> play activator = skynet
01:00:59 <sinelaw> hi. How does one encode URIs in hamlet/shakespear?
01:01:17 <sgronblo> tdammers: yeah it has lambdas and map and filter
01:01:25 <sgronblo> though its all done in a pretty horrible way
01:01:32 <tdammers> so just like plain PHP then
01:01:45 <sgronblo> tdammers: no thats what plain PHP has
01:01:50 <tdammers> yeah
01:02:16 <sgronblo> well i havent used hack but i just remember hearing that they made it better in some functional programmerish way
01:02:44 <tdammers> it's just that I'm wondering - Hack is supposed to be a "better PHP", which kind of suggests that there are good parts in PHP that are worth keeping
01:02:45 <solatis> php nowadays is actually a pretty decent language, assuming there's a decent developer working with it
01:03:10 <solatis> similarily to perl being aweful but nowadays is a decent language
01:03:23 <sgronblo> Welkin: yeah thats kind of my point. many people hate on PHP (including me, ruby and python programmers) but i think if you add a decent type checker to PHP you immediately jump past both python and ruby
01:03:35 <tdammers> solatis: I used to think that, but the problem is, if you're a decent developer doing nontrivial shit and trying to make things correct, PHP is going to drive you up the wall
01:03:45 <sgronblo> nothing that cant be type checked is decent :)
01:03:45 <tdammers> there's broken abstractions everywhere
01:03:58 <solatis> sgronblo: https://code.facebook.com/posts/1505962329687926/flow-a-new-static-type-checker-for-javascript/
01:04:02 <solatis> like that ?
01:04:03 <solatis> :)
01:04:10 <sgronblo> solatis: yeah like that
01:04:13 <solatis> if it can be done for js, it can be done for php
01:04:23 <solatis> and if there's one company that can do it, it's probably facebook
01:04:32 <tdammers> edge cases, inconsistencies, arbitrary limitations that don't make sense, security fuckups that make half the API unusable, insane defaults, ...
01:04:35 <solatis> heck, they probably already have
01:04:49 <sgronblo> well microsoft already made a pretty decent attempt with typescript i feel
01:04:58 <solatis> tdammers: there are edge cases and inconsistencies in every language, even haskell
01:05:14 <tdammers> solatis: yeah, but PHP is a league of its own
01:05:45 <sgronblo> i dont think anybody here really is saying php is a good language
01:06:25 <sgronblo> one point id like to make though is that id rather have type checking and php crazyness versus python cleanliness and no typechecking for a bigger project at least
01:06:26 <solatis> the longer i developer code, the more hatred i get towards language wars
01:06:34 <tdammers> I run into edge cases and limitations all the time, and usually it's a sign that I'm thinking in a direction that doesn't align with the unifying vision behind the language, and that I should probably take a step back and rethink my approach in a more idiomatic way
01:06:49 <tdammers> and generally, this works well
01:07:07 <tdammers> except in PHP
01:07:08 <solatis> tdammers: well a pet peeve for haskell for me is 'Just 1' and 'Just -1'
01:07:15 <tdammers> yeah, but that's a nuisance
01:07:22 <solatis> no, it's an inconsistency
01:07:29 <tdammers> sure
01:07:34 <tdammers> it is
01:07:41 <tdammers> but it's not a show stopper
01:07:47 <BoR0> what's wrong with Just -1?
01:07:54 <int-e> > Just -1
01:07:55 <lambdabot>  No instance for (Data.Typeable.Internal.Typeable a0)
01:07:55 <lambdabot>    arising from a use of ‘M157308766554717695324705.show_M1573087665547176953...
01:07:55 <lambdabot>  The type variable ‘a0’ is ambiguous
01:07:55 <lambdabot>  Note: there are several potential instances:
01:07:55 <lambdabot>    instance Data.Typeable.Internal.Typeable Data.Dynamic.Dynamic
01:07:58 <solatis> BoR0: it compiles to 'Just - 1'
01:08:01 <tdammers> it doesn't cause Haskell to lack a crucial abstraction tool
01:08:08 <BoR0> > Just (-1)
01:08:10 <lambdabot>  Just (-1)
01:08:11 <pantsman> it was also deliberate, unlike a lot of PHP problems which are totally accidental because the implementation is the spec
01:08:19 <int-e> ok, that's an awful error, but the point is that it's (-) Just 1
01:08:46 <solatis> well it's just a rough edge case in a language that's otherwise very consistent
01:10:15 <tdammers> exactly
01:10:26 <int-e> a related complaint here is that there are no negative literals. -345 :: Int  is (negatge (fromInteger 345))
01:10:28 <tdammers> the thing is, PHP hardly does anything right at all
01:10:46 <Welkin> php isn't even a programming language
01:10:50 <Welkin> or it didn't start off that way
01:10:52 <usr> ^
01:10:53 <usr> it's not
01:10:55 <Welkin> Personla Home Page
01:11:01 <Welkin> Personal*
01:11:07 <Welkin> it was created as a templating engine
01:11:21 <tdammers> and it sucks the most at being a template language
01:11:27 <solatis> no, personal homepage preprocessor :)
01:11:30 <usr> hahahaha
01:12:02 <sgronblo> i think we are wasting our time fighting php in here
01:12:11 <sgronblo> nobody will get upset about it
01:12:13 <usr> php or haskell which is beter?
01:12:26 <sgronblo> PHP because Facebook was made with it!
01:12:29 <tdammers> usr: php, obviously. my boss uses it, so it must be good right?
01:12:48 <usr> lol
01:13:04 <sgronblo> also PHP is better for people who want to get shit done
01:13:24 <int-e> sgronblo: and s... is what they get?
01:13:31 <tdammers> sgronblo: emphasis on "shit"
01:14:23 <ZenFox> hey all
01:14:57 <sgronblo> well you cant call facebook shit, at least not technologically
01:15:12 <sgronblo> though i guess a lot of its true magic is not thanks to php any more
01:15:41 <tdammers> the facebook argument pretty much boils down to "facebook is what it is right now *despite* PHP"
01:16:19 <solatis> sgronblo: you're forgetting that facebook also made haxl :)
01:16:26 <tdammers> or, put differently: the biggest PHP user in the world had to write their own compiler, runtime, and a meta-language, just to keep PHP usable for their stuff
01:16:28 <tdammers> go figure
01:16:35 <BoR0> haha
01:16:35 <solatis> nah
01:16:42 <sgronblo> solatis: I'm just parroting arguments that PHP defenders would say on reddit or hacker news
01:16:48 <ZenFox> i am new to haskell. tell me some good resources get started with haskel
01:16:49 <tdammers> yeah I know
01:17:00 <tdammers> ZenFox: learn you a haskell is good
01:17:04 <tdammers> @where lyah
01:17:04 <solatis> ZenFox: #haskell-beginners :)
01:17:04 <lambdabot> http://www.learnyouahaskell.com/
01:17:23 <solatis> ZenFox: real world haskell is another good one
01:17:26 <wei2912> ZenFox: you should go to #haskell-beginners
01:17:27 <solatis> @where rwh
01:17:27 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
01:17:30 <wei2912> ZenFox: there's also the haskell wikibook
01:17:53 <wei2912> (does lambdabot have a link to that?)
01:18:08 <solatis> @where wiki
01:18:08 <lambdabot> I know nothing about wiki.
01:18:09 <tdammers> rwh is a bit dated, but great if you have some other programming experience already
01:18:09 <bitonic> I've been using this type for a bit: `data Collect m a = OK a | Collect m', with a Functor instance and a `instance Monoid m => Applicative (Collect m) where', where the Applicative instance short-circuits Collect (like Either), but if <*> has two Collects it `mappend's the contents and returns a new Collect.  is this kind of structure somewhere in some library already?
01:18:34 <solatis> i consider rhw the 'getting things done quickly' tutorial book
01:18:37 <tdammers> oh, and if you're a somewhat experienced programmer with a bit of fp clue, try "write yourself a scheme in 48 hours"
01:18:40 <tdammers> @where scheme
01:18:40 <lambdabot> https://en.wikibooks.org/wiki/Write_Yourself_a_Scheme_in_48_Hours
01:19:06 <pavonia> @where wikibook
01:19:06 <lambdabot> http://en.wikibooks.org/wiki/Haskell
01:19:10 <tdammers> but if you don't know any programming  languages yet, and you don't know what functional programming is about, then it's probably too steep
01:22:04 <supki_> bitonic: it's usually called Validation and one of implementations is in the either package
01:27:02 <bitonic> supki_: perfect!  thanks
01:28:12 <Welkin> eh, I used Write Youtself a Scheme
01:28:23 <Welkin> I found it was not written well
01:28:45 <Welkin> I'd recommend just reading LYAH and RWH
01:29:13 <Welkin> and working on a simple project using yesod, snap, etc.
01:30:20 <sgronblo> I have been trying to learn Haskell (not very actively though) for years before touching Yesod
01:30:55 <Welkin> the yesod book is helpful actually
01:31:03 <Welkin> for clarifying how certain things can be used
01:31:20 <Welkin> I believe there is a beginner-friendly snap tutorial series as well
01:32:08 <tdammers> speaking of web stuff; I really like scotty...
01:33:38 <nezt> What text editor do most of you guys use? emacs?
01:33:51 <Welkin> I use emacs
01:33:52 <bitonic> what about `data Collect err m = Fail err | Collect m', where you have `instance (Monoid m) => Monoid (Collect err m) where; mempty = Collect mempty; mappend = <<short circuit Fail, mappend Collects>>'?
01:33:53 * Kinnison uses both vim and emacs for haskell code
01:34:15 <bitonic> actually, that might  just be the monoid instance for Either...
01:34:40 <bitonic> ah no, it doesn't have an instance like that
01:35:11 <Hijiri> I recommend doing CIS 194 like in https://github.com/bitemyapp/learnhaskell over either lyah or rwh
01:35:33 <Welkin> Hijiri: I used all three when starting out
01:35:50 <Welkin> The only one I actually finished though was LYAH
01:35:55 <Hijiri> I found that lyah wasn't working very well and then did CIS 194
01:36:11 <Hijiri> lyah doesn't explain FP concepts very well and doesn't have many exercises
01:36:24 <Hijiri> note that Haskell is my first functional language
01:36:30 <Welkin> mine too
01:41:23 <kqr> tdammers, interesting that you like scotty
01:41:30 <kqr> tdammers, i've never found a place for microframeworks
01:42:15 <kqr> tdammers, they're somewhere in between REST API frameworks and full-blown frameworks that help you with models, database, authentication and such
01:44:14 <kqr> tdammers, (and rendering of views and such I guess is one of the big parts of a full-blown web framework as opposed to a simple REST API)
01:47:43 <Welkin> I made the mistake of using a microframework and then adding on auth, orm, etc.
01:47:46 <Welkin> that was a huge mess
01:48:01 <Welkin> it was in python too, so it was an even bigger mess
01:48:18 <Welkin> so yeah
01:48:28 <Welkin> microframeworks are only good for REST APIs
01:48:36 <Welkin> that serve JSON
01:49:12 <osfameron> the best microframeworks are scalable beyond that
01:49:53 <solatis> geez i was afk for one hour and we're still having the microframework vs monolithic framework discussion? :)
01:52:00 <kqr> Welkin, there are libraries specialised for making REST services
01:52:00 <XyMa> hi, i'm working on a web spider with wreq and HXT, but cann't handle page with GBK encdoing correct, anyone has some advice?
01:52:07 <kqr> Welkin, which do it better than microframeworks in my opinion
01:52:21 <kqr> Welkin, I only know of liberator in clojure, but there ought to be something for other languages too
01:52:56 <solatis> XyMa: can you provide the url?
01:52:57 <trap_exit> when programming at night, and drawing out diagrams on paper, what is a good small desk lamp to illuminate the paper ?
01:53:01 <XyMa> i try'd iconv, but cannot install on my window box with 64bit haskell platform
01:53:08 <solatis> encoding-type can be provided in <meta /> tags or in http header
01:53:17 <tdammers> I think "microframework" is a misnomer
01:53:23 <kqr> trap_exit, a red one
01:53:30 <tdammers> I consider Scotty a web application library, nothing more
01:53:40 <solatis> XyMa: iconv should only be last resort, and not your responsibility -- anything that comes out of hxt should be properly (re)encoded
01:53:47 <tdammers> it provides web server bindings, routing, and some HTTP convenience
01:53:49 <tdammers> that's it
01:53:55 <tdammers> and that's all I need from it
01:54:08 <trap_exit> kqr: amazon link? embedding a referal link is fair game
01:54:17 <solatis> tdammers: i consider the 'microframework' vs 'macroframework' to be comparable to a microkernel and its monolithic counterpart
01:54:22 <kqr> trap_exit, I don't have anything specific in mind
01:54:32 <kqr> trap_exit, i'm just recommending red because it's nice to the eyes in darkness
01:54:38 <tdammers> solatis: I think the comparison is kind of pointless
01:54:48 <solatis> 'microframework', in my opinion, should be full of modules, and the modules (ideally) be able to be used without the entire ecosystem
01:54:51 <tdammers> "microframework" isn't even a thing IMO
01:54:57 <trap_exit> kqr: ar eyou serious? red rather than white led light?
01:54:59 <trap_exit> this makes no sense
01:55:11 <sinelaw> "nanoframework"
01:55:14 <tdammers> scotty isn't a framework. it's just server bindings
01:55:25 <solatis> sinelaw: a.k.a. 'libraries'
01:55:26 <sinelaw> what's wrong with "library"
01:55:27 <tdammers> it doesn't do templates, nor persistence, nor model-anything
01:55:31 <sinelaw> solatis, exactly!
01:55:31 <tdammers> it's just a library
01:55:41 <trap_exit> microframework is liek permenant alpha
01:55:41 <tdammers> and that's great
01:55:43 <solatis> that's what my point was one hour ago already people
01:55:46 <solatis> we're repeating ourselves
01:55:48 <trap_exit> no one can critize you because 'it's a microframework'
01:55:48 <tdammers> so yeah
01:56:05 <tdammers> *actual* microframeworks are too much already IMO
01:56:13 <tdammers> e.g. flask
01:56:27 <XyMa> http://www.taobao.com/, the largest c2c site of china
01:56:36 <tdammers> way too many assumptions already, and too restrictive solutions to problems the designers thought I may or may not run into
01:56:40 <solatis> trap_exit: calling something a framework rather than a library is similar to calling my website a startup :)
01:57:09 <solatis> nowadays everyone with a website calls it a 'startup'
01:57:13 <solatis> now that grinds my gears
01:57:17 <trap_exit> solatis: your websit ehas higher chance of success than 3 MBAs getting together looking for the engineer willing to code up their brilliant idea
01:57:26 <trap_exit> solatis: just saw such a posting on email list earlier today
01:58:30 <solatis> that's what engineers like to think -- as someone who actually had a startup with a succesful exit, trust me, you need the MBAs too
01:59:23 <trap_exit> solatis: yeah, the google, facebook, instagram, wahtsapp, tesla, spacex, solarcity, yahoo, vmware, oracle, microsoft founding teams were all MBA based
01:59:45 <trap_exit> not to mention SUN microsystems, cisco, and who else
01:59:58 <solatis> well i'm just saying, they have their value
02:00:02 <solatis> but they come into play later
02:00:21 <tdammers> I guess a lot depends on what your goals are and how you define "success"
02:00:32 <solatis> well my startup was active in the enterprise sector
02:00:52 <solatis> you really need MBA's there to actually sell something
02:01:05 <trap_exit> if by MBA, you mean sales, then yes
02:01:10 <trap_exit> for enterprise, you do need sales people
02:01:23 <sgronblo> solatis: haha yeah, yesterdays webmaster is todays startup CEO almost
02:01:26 <solatis> marketing and sales and business development and the whole shebang
02:01:49 <trap_exit> yes
02:01:51 <solatis> sgronblo: no, no, 'founder' :)
02:01:53 <trap_exit> so taht makes them good employees
02:02:14 <solatis> yeah i actually partnered up with an MBA which turned out to be great
02:02:20 <solatis> he got me out of my mancave
02:02:29 <solatis> and we actually managed to sell stuff :)
02:03:28 <solatis> anyway, it's easy for engineers to trivialize the role of the 'business people', and for them it's vice versa -- they have a "you're just the developer" attitude
02:03:36 <sgronblo> solatis: right well usually its founder and CEO at the same time
02:03:56 <solatis> sgronblo: until you get funding, and then the VCs take over and you are lost :)
02:03:59 * hackagebot clay 0.10 - CSS preprocessor as embedded Haskell.  http://hackage.haskell.org/package/clay-0.10 (SebastiaanVisser)
02:08:03 <trap_exit> no no
02:08:06 <trap_exit> that's when the VCs provide their value
02:08:16 <trap_exit> by replacing the founder with professional management team
02:08:26 <sgronblo> but the only point of having a startup is robbing money from investors isnt it?
02:08:35 <silver> professional or not
02:08:36 <trap_exit> and the foundrs should be grateful for the equity they get
02:09:08 <trap_exit> vcs have done great things by kicking out founders -- look at Steve Jobs vs =John Sculley for example
02:09:28 <trap_exit> we would aghve never had pixar without the brilliance of those VCs
02:09:40 <silver> lol
02:09:47 <BoR0> why does Prelude contain partial functions (e.g. tail)
02:10:25 <silver> BoR0, so user can supply their arguments to them
02:11:16 <BoR0> I meant partial in the sense that it's undefined for some values
02:11:26 <BoR0> maybe it's not what they are called :)
02:11:32 <silver> oh right
02:12:02 * geekosaur tempted to just point to haskell-cafe archives; this has been discussed to death and beyond before
02:13:55 <mat10> ^nice, thanks you
02:17:34 <trap_exit> hmm
02:17:41 <trap_exit> i need a good desk lamp
02:17:47 <trap_exit> so that when codin ghaskell, I write type signatures on paper
02:17:50 <trap_exit> but then, I don't want a blinding light
02:18:35 <solatis> wait, what
02:18:44 <solatis> you write haskell code on paper?
02:18:50 <trap_exit> do you not sketch out haskell type signatuers
02:18:51 <trap_exit> before coding?
02:18:58 <tdammers> trap_exit: I do, but not on paper
02:19:00 <trap_exit> i sketch out type signatures then I code in emacs
02:19:01 <solatis> yes, i do
02:19:06 <solatis> foo :: bar
02:19:10 <solatis> foo = undefined
02:19:11 <solatis> done
02:19:16 <tdammers> ^
02:19:35 <trap_exit> by type signature, I mean the
02:19:39 <trap_exit> foo :: .... -> ....
02:19:39 <trap_exit> part
02:19:54 <solatis> yes i know
02:20:00 <solatis> but why not put it in code?
02:20:11 <solatis> then you can immediately get feedback on whether things work as intended
02:20:21 <solatis> (or, in other words, if it compiles)
02:20:39 <BoR0> why not start with foo = undefined (without specifying the type signature) and then use the compiler to derive the signature
02:20:50 <Hijiri> it's zen
02:20:52 <trap_exit> -Wall -Werror
02:20:53 <Hijiri> code without coding
02:21:15 <solatis>                 mapTuple :: (a -> b) -> (a, a) -> (b, b)
02:21:17 <solatis>                 mapTuple = undefined
02:21:25 <solatis> that's what part of my code looks like now
02:21:37 <solatis> compiler is happy
02:21:41 <solatis> or at least, ghci
02:21:46 <solatis> which is embedded in emacs
02:21:57 <solatis> which does have -Wall but not -Werror
02:22:21 <solatis> anyway
02:22:29 <solatis> whatever floats your boat, i guess
02:22:34 <solatis> dijkstra would agree with you, tho :)
02:23:05 <solatis> i believe i recall him saying that nowadays, because you don't have punch cards anymore, you don't have to think anymore when writing code
02:23:17 <solatis> and coding becomes trial & error instead of thinking
02:23:25 <solatis> or was that don knuth?
02:25:14 <ghorn_> do people here mostly use the cmdargs package for argument parsing?
02:25:14 <mat10> anyone good with haskore, im try to read the tutorial but .
02:25:40 <ghorn_> i'm not the biggest fan of the Data/Typeable approach
02:25:42 <solatis> ghorn_: i use optparse-applicative
02:27:20 <ghorn_> solatis: this looks pretty nice
02:28:27 <ghorn_> solatis: i was hoping to not write my own parser though
02:28:49 <ghorn_> solatis: maybe there is a fundamental tradeoff between the two approaches
02:29:31 <solatis> ghorn_: i think "not writing your own parser" would mean less memory efficient
02:29:46 <solatis> but it's mostly a matter of taste
02:30:27 <ghorn_> my dream would be something like cmdargs using GHC.Generics instead of Data/Typeable
02:30:34 <ghorn_> so you would get compile time errors instead of runtime
02:51:58 <ambrozyk> hi, do you know of any reasonable ways to wrap a value in a Ptr when using FFI?
02:52:37 <Yuras> wrap?
02:52:47 <ambrozyk> I mean, I do: newStablePtr val  and then castStablePtrtoPtr, which gives me a Ptr ()
02:53:08 <ambrozyk> this is exactly what I need, but the address it returns is always 0x63... :)
02:53:22 <ambrozyk> * 0x0000000000000063
02:53:33 <Yuras> ambrozyk: probably the same haskell object?
02:53:45 <Yuras> the address is not a real address
02:54:03 <Yuras> it is only guaranteed to be > 0 IIRC
02:55:10 <ambrozyk> hmm. I than want to use it as an argument to poke, so I guess this isn't the right way
02:55:10 <Yuras> so you should never dereference it dirrectly, only cast back to stableptr and deref it
02:56:45 <Yuras> ambrozyk: what is the goal? probably there is other way to acheive
02:58:59 <ambrozyk> I have a C code that passes me a pointer to a  blind handle, which in haskell is of type Ptr (Ptr ()). now, I have an object that I want to write to this handle
02:59:47 <Yuras> poke is ok here
03:00:15 <Yuras> just make sure you peek it in haskell land, cast to stableptr and deref
03:00:43 <Yuras> there is no good way to deref it from C land
03:01:11 <ambrozyk> the problem is getting a valid address of the haskell value that I want to write to the handle
03:02:08 <Yuras> ambrozyk: you can't. but the is stable correspondence between the "address" in stableptr and haskell value
03:02:47 <Yuras> you are getting the same address probably it is reused
03:03:17 <Yuras> err "probably because it is reused"
03:03:59 <ambrozyk> Yuras: thanks alot, I'll try to figure it out :)
03:04:30 <ambrozyk> Yuras++
03:11:10 <favetelinguis> is it even possible to use haskell type constructors in this way? http://lpaste.net/114612
03:12:18 <alpounet> favetelinguis: in "data Sudoku = Sudoku { ... }", the second "Sudoku" is called a value constructor, not a type constructor. and yes, it's a function
03:12:43 <alpounet> so this bit is valid, and your type error probably comes from somewhere else
03:12:47 <ambrozyk> Yuras: wrapping the value in IORef seems to have solved the problem
03:13:04 <ClaudiusMaximus> favetelinguis: i think your maps are wrong - should be more like Sudoku . map (map ...) . lines
03:13:45 <Yuras> ambrozyk: that sounds very strange for me :)
03:14:18 <alpounet> ClaudiusMaximus: yeah that or changing lines into "map words . lines", smth like that.
03:14:28 <ambrozyk> sure is strange :)
03:14:43 <Yuras> ambrozyk: could you @lpaste it please?
03:14:49 <Yuras> @lpaste
03:14:49 <lambdabot> Haskell pastebin: http://lpaste.net/
03:15:48 <ambrozyk> Yuras: I would have to rewrite it in order to paste it, so right now I'm afraid not
03:15:53 <favetelinguis> ClaudiusMaximus: yes that did the trick, thanks
03:16:10 <Yuras> ok, np
03:32:25 <dfeuer> seafood, you're happy that cabal hell exists?
03:40:15 <seafood> dfeuer: No, that Stackage exists.
03:40:33 <stefan_1_|Work> does anyone know if there are any haskell meetups in berlin? or where to find out about this kind of stuff?
03:42:19 <seafood> stefan_1_|Work: I don’t live in Berlin but perhaps this? http://www.meetup.com/berlinhug/
03:42:49 <cjheath> This maybe: www.meetup.com/berlinhug/
03:43:09 <cjheath> (I just googled “haskell berlin” for what it’s worth
03:43:29 <stefan_1_|Work> hmm i should probably have tried that but thanks :)
03:43:53 <cjheath> :)
03:44:40 <seafood> Looks like you just missed out meeting Michael Snoyman. That would have been a good talk.
03:49:03 * hackagebot is 0.1 - Pattern predicates using TH  http://hackage.haskell.org/package/is-0.1 (vlopez)
03:55:42 <Guest-1648> hey everybody
03:56:36 <Kaligule> hey
04:05:53 <dud> Hi, how can I typeset Haskell expression evaluation (reductions) similar to the pythagoras example here: http://en.wikibooks.org/wiki/Haskell/Graph_reduction
04:06:33 <dud> And is there a way to generate such steps automatically?
04:08:32 <dud> I'd be rather interested in the "style" Richard Bird is using in his new "Thinking Functionally in Haskell" book. He mentions that the proof format was invented by Wim Feijen.
04:09:21 <dud> Actually it's "Thinking Functionally *with* Haskell", sorry.
04:10:49 <adamse> dud: in Latex you could probably approximate that style with the align environment from amsmath
04:12:24 <adamse> (meaning the style from the wikibook)
04:13:42 <staffehn_> Hi, can someone recommand a specific text editor for haskell programming under Linux? I'd like to use a graphical editor that doesn't have strange keybindings and I'm specifically trying to find one which gets the syntag highlighting right. Which really annoys me about many haskell highlightings is that "as" gets special syntax even when used outside an import...
04:14:29 <joneshf-laptop> so the composition of two monads isn't necessarily a monad, but what is it?
04:14:35 <joneshf-laptop> is it still a functor at least?
04:14:42 <joneshf-laptop> still an applicative?
04:15:52 <adamse> joneshf-laptop: afaik functors are composable
04:16:53 <joneshf-laptop> so do we just go with the strongest thing then and say tis still applicative?
04:18:42 <adamse> joneshf-laptop: if you compose two applicatives f, g: does it still follow the applicative laws?
04:20:12 <Kaligule> staffehn_: I was in a similar situation some time ago. I decided to learn Emacs. Emacs is great and I don't regret it, but it might not be the right decision for you.
04:20:51 <Kaligule> staffehn_: Did you have a look at Atom (githubs very young Editor) or Sublime Text?
04:27:19 <staffehn_> Kaligule: I dont like how Sublimetext highlights every | when I define an opetator like &|& that then is made up out of multiple colors, and the highlighting of qualified identifiers is also quite colorful/strange. Ill take a look at Atom, which one I hadn't heard of before.
04:28:25 <ClaudiusMaximus> staffehn_: i use geany, but it has that 'as' highlighting issue you mentioned (at least in the ancient version in debian stable)
04:31:40 <adamse> staffehn_: Leksah or Yi might have better haskell highlightning than other editors
04:31:47 <adamse> but I'm not sure
04:31:56 <t4nk582> @pl (\xs -> dropWhile (== head xs) xs)
04:31:56 <lambdabot> dropWhile =<< (==) . head
04:32:12 <staffehn_> Kaligule: Does at least emacs get the highlighting right?
04:34:16 <staffehn_> adamse: I'll try them, well.. I read, that Leksah is not useful for short haskell scripting, but now I'm curious about If they do that highlighting right.
04:35:57 <adamse> joneshf-laptop: the composition of functors and applicatives is actually defined in transformers: Jag
04:36:03 <adamse> joneshf-laptop: http://hackage.haskell.org/package/transformers-0.2.2.0/docs/Data-Functor-Compose.html
04:45:23 <iLike> Hi there :)
04:46:18 <michaelt> hi there iLike
04:46:41 <iLike> I'm wondering when I should use point-free style.
04:48:00 <michaelt> When it makes things clearer?
04:48:12 <iLike> http://lpaste.net/5384069001087287296
04:48:25 <iLike> consider that example, I'd say check2 is better. Right?
04:50:18 <michaelt> iLike: well, I think everyone would prefer the simpler one there...
04:51:19 <iLike> michaelt, that's what I figured, yea.
04:53:02 <michaelt> iLike: if it were check2 t  = checkTime t && checkDate t then check2 = liftA2 (&&) checkTime checkDate  wouldn't be so bad, I think.
04:54:13 <michaelt> iLike: needless to say there are a hundred views about this.
04:54:25 <iLike> That would require my checkDate function to accept a DateTime rather than a Date, which imo would be rather strange.. :P
04:54:47 <michaelt> iLike: yes, I was just giving an example of a not-too-horrible pointfree-ism
04:55:21 <iLike> well yea, but for a beginner haskeller this is way more readable, I didn't know about liftA2 for example
04:55:30 <iLike> michaelt, point taken and appreciated :)
04:56:27 <michaelt> iLike: experimenting with point free forms of expression is certainly good, though. It is just a strain to read such expressions in libraries etc.
04:57:00 <iLike> michaelt, yep it is. Why do people do it though? Is the compiler able to optimize code like that better or..?
04:57:58 <michaelt> iLike: the compiler's inlining machinery responds to eta-reduced definitions. The ins and outs of it are a little complicated.
04:59:24 <iLike> That's from lambda calculus right?
05:01:46 <michaelt> iLike: it just means writing f x = g . h x instead of f x y = g (h x y)
05:03:01 <iLike> michaelt, and how would the compiler benefit from that? At the lowest level both functions would still need to be executed right?
05:05:37 <michaelt> well inlining a definition allows all sorts of further optimizations. suppose there is a rule that h (k x) = x then I would want h to come next to k as soon as possible
05:06:25 <michaelt> iLike: I'm by no means an expert on these topics! So dont take my word for anything.
05:07:01 <iLike> michaelt, I'm reading the haskell wiki on category theory & conversions & reductions and it makes sense indeed
05:07:29 <iLike> Pretty ingenious
05:07:38 <michaelt> I'm just trying to write a library based on rewrite rules, so I'm trying to figure some of this inlining business out. I probably shouldn't have mentioned it.
05:08:29 <alpounet> iLike: whenever you think it makes your code more readable
05:08:42 <iLike> michaelt, why not? It's very interesting :) I'm following a course on compiler construction atm so these things are always nice
05:09:40 <iLike> alpounet, yea, but what's considered readable? I mean, experienced haskellers might be able to read haskell way more easy than begginers
05:10:16 <michaelt> iLike: (. flip f) . is always a bad sign
05:10:43 <michaelt> @pl check2 t d = checkTime t && checkDate d
05:10:43 <lambdabot> check2 = (. checkDate) . (&&) . checkTime
05:10:45 <iLike> michaelt, well yeah, that might be taking it too far haha
05:11:02 <iLike> That's ugly
05:11:13 <michaelt> hah, check that out, pointfree has a somewhat more readable definition
05:11:27 <alpounet> iLike: well, no need to overthink this. first, you obviously need to be able to understand your code if you come back to it in a few days/weeks/months/years. second, ideally you also would like "anyone else" to be able to understand it, but you can't measure that, you'll have to trust your instict here
05:11:29 <joneshf-laptop> iLike, that's subjective
05:11:51 <iLike> I think I'll just stick with "check = checkTime t && checkDate d" :P
05:12:14 <iLike> alpounet, yeah that makes sense, thanks :)
05:12:27 <michaelt> yes. but like I said, fiddling with pointfree expressions of things frequently gives you a ton of insight.
05:12:51 <alpounet> iLike: right, this seems obvious enough to be considered "readable". that doesn't keep you from trying to express it in more intricate ways though, for science :p
05:12:59 <michaelt> you just don't want to make anyone read them ...
05:13:50 <alpounet> (but you preferably should keep obscure bits of code to yourself and publish clean code)
05:14:04 <iLike> alpounet, yep haha :)
05:14:28 <markand> hello
05:14:48 <iLike> Anyway, thanks for your insights. I g2g :)
05:19:28 <petercommand> what does monolithic array mean?
05:19:53 <robstewartuk> hi, we're having an interesting discussion about adding tests to the rdf4h library, here https://github.com/robstewart57/rdf4h/issues/12#issuecomment-63373886 . The question is: our test files are 6Mb. Is there a standard practise for pulling in test data only when tests are to be run?
05:20:16 <robstewartuk> cordawyn says "Running cabal test would raise an exception and say something like "Missing data files for W3C test suite. Please run xyz to fetch them, then launch cabal test again." "
05:20:37 <robstewartuk> I know that some people package tests in a separate cabal project.
05:20:38 <michaelt> oh, hi markand
05:20:43 <markand> hello :-)
05:20:53 <clrnd> petercommand, ehm, a pretty big one?
05:21:00 <robstewartuk> I.e. foo for the library, and foo-tests for the tests. Each in a separate repo. Thoughts?
05:21:33 <petercommand> clrnd: oh, i see
05:21:59 <clrnd> just guessing, it depends on the context
05:24:04 <petercommand> clrnd: the text is about haskell array, i think that should be the correct meaning in the context
05:24:09 <petercommand> clrnd: https://www.haskell.org/tutorial/arrays.html
05:26:17 <trap_exit> suppose I have been using bhaskell for 6+ months ... but I find no use for ghci, am I doing something wrong?
05:26:24 <trap_exit> or are tehre haskell experts who basically never use ghci ?
05:29:12 <mmachenry> I am reading up on writing servers in Haskell and I've read something a little confusing. "Since the new IO manager is single-threaded, Haskell network programs cannot
05:29:13 <mmachenry> realize the potential of a multi-core processor even if the +RTS -Nx command line
05:29:13 <mmachenry> option is specified."
05:29:13 <BoR0> @pl (\(x, y) -> Test x y)
05:29:13 <lambdabot> uncurry Test
05:29:33 <saep> trap_exit: ghci is just a tool. If you don't need it, you don't use it.
05:29:43 <mmachenry> Does this mean that Haskell network servers cannot parallelize the work done in their connections?
05:29:53 <saep> trap_exit: There isn't really a generally applicable work flow that experts have.
05:29:58 <trap_exit> so "not using ghci" vs "using ghci" is not like "using notepad" vs "using vim" ?
05:29:59 <clrnd> trap_exit, I'm sure most emacs masters don't use ghci (directly)
05:30:50 <trap_exit> emacs users don't use anything directly
05:30:51 <clrnd> mmachenry, that sounds weird, care to share the source?
05:30:54 <trap_exit> there's always an elisp intermediate layer
05:30:59 <mmachenry> http://themonadreader.files.wordpress.com/2011/10/issue19.pdf
05:31:16 <clrnd> page 9
05:31:57 <bitraten> hi, can i redefine instance declarations of GHC.Base?
05:33:17 <mmachenry> clrnd: This might, actually, mean just system calls  IO based on the conclusion paragraph.
05:33:30 <saep> trap_exit: I don't use ghci to test if my program compiles, I just press a button in vim. So I have 1 use case less for ghci. I would not know how to debug functions without ghci either.
05:33:52 <clrnd> mmachenry, http://www.aosabook.org/en/posa/warp.html
05:34:38 <trap_exit> saep: hmm, what do you use ghci for?
05:34:42 <trap_exit> I can't find any cases for using ghci
05:34:49 <trap_exit> oh, debugging functions
05:34:52 <trap_exit> hmm
05:34:56 <clrnd> I remember WAI uses threads, and "Parallel and Concurrent Programming in Haskell" has lot's of examples of the performance of threads distributed among cores
05:34:57 <trap_exit> i've never had to debug my code
05:35:58 <clrnd> ohhhh, "To fully take advantage of user threads, we should avoid
05:35:59 <clrnd> issuing system calls as much as possible."
05:36:45 <clrnd> that Warp article I linekd even talks about system calls :P
05:37:28 <saep> trap_exit: If my parsec parser doesn't do what i expect, I fire up ghci and play around with the subparsers, for example.
05:37:45 <saep> That's still debugging, though.
05:39:26 <saep> Also, if a test module fails that is part of a long-running test suite, it is convenient to fire up ghci just for that module and fix the test(s) there.
05:42:19 <trap_exit> saep: hmm, I tend to test the mini pieces along the way
05:42:34 <trap_exit> saep : I'm also using haste, so I cna't 'run' my code without compiling it + firing up the client
05:42:43 <Phillemann> With an extension, is something like this possible (assuming "foo :: String"): case foo of ("x ":suffix) -> putStrLn suffix ...
05:44:52 <Phillemann> (I assume it's not in Haskell98)
05:48:40 <clrnd> Phillemann, well, you can `case foo of { ('x':' ':suffix) -> etc }`
05:48:41 <clrnd> :P
05:49:27 <Phillemann> Ah yes, great ;)
05:49:46 <clrnd> but no idea of what you want, it's not pattern matching on constructors
05:49:49 <ChristianS> Phillemann: you could also check stripPrefix (might be more practical for longer prefixes)
05:50:30 <clrnd> `"x ":xs` would match ["x ", "lol"]
05:53:09 <trap_exit> are haskell patterns more powerful than erlang patterns -- because in haskell guards, you can only use erlang builtins -- whereas in haskell, any expr thwihc evals to Bool is okay?
05:55:23 <nshepperd> I think  `case foo of ("x " ++ suffix) -> ...` would be it, but doesn't really exist
05:56:14 <angerman> I need to write some very simple data exchange mechanism over the network, where should I look?
05:56:25 <nshepperd> but with ViewPatterns you could do `case foo of (splitAt 2 -> ("x ", suffix)) -> ...`
05:57:43 <clrnd> angerman, something like cloud haskell?
05:58:43 <angerman> clrnd: not sure. Might be though. What I want is to run a small service, that receive binaryblobs, and sends back binaryblobs in response
06:01:00 <clrnd> angerman, your own protocol? Network.Sockets
06:02:04 <angerman> clrnd: yep. nothing too fancy. Basically Client - send binary data as .so -> server -> evaluate -> return result a serialized data -> Client.
06:04:30 <clrnd> angerman, also network-simple which is ... simpler
06:08:00 <angerman> clrnd: cloud haskell does look nice through.
06:08:10 <angerman> clrnd: i'll look into network-simple as well. thanks.
06:08:23 <clrnd> no problem :)
06:08:53 <angerman> for cloud haskell, I basically compile the logic into the node and then use the node through rpc?
06:09:07 <setrecall> Hi. Does anyone know how to convert this pseudocode to Haskell?: http://lpaste.net/2141368782801600512
06:10:22 <hugomg> setrecall: what part of the conversion are you having trouble with?
06:11:18 <setrecall> hugomg: I wanted to try and use tail recursion with an accumulator.
06:11:38 <setrecall> But two things are tripping me up: the first is the base case for recursion.
06:11:59 <setrecall> The second is how to feed the accumulator back in to the function.
06:13:45 <hugomg> for the first question: your variables are "output" "t" and "e", so these will be the arguments to our tail-recursive function
06:13:58 <hugomg> go output t e = ...
06:14:09 <clrnd> angerman, afaik yes, it handles connections "silently"
06:14:16 <hugomg> the base case is when e >= (ceil(d/64) -1)
06:14:34 <hugomg> and the recursive case is when e is less than that
06:14:53 <danilo2_> hello! Could anyone explain to me why haskell complains that rthese type family instances are in conflict? type instance TraveralMorph base [a] = [TraveralMorph base a]    AND   type instance TraveralMorph base String = String    AND    type instance TraveralMorph base Char   = Char  ? They are not though ... :(
06:15:11 <hugomg> finally, the way to pass the accumulator values is that you have a root function that calls "go" with the initial values
06:15:29 <hugomg> f a b c d = go [] (zeros ! 64) 0
06:15:48 <hugomg> and all the recursive calls of go you set the parameters appropriately
06:18:17 <hugomg> that said, after you figure out how to write this with tail recursion, I'd encourage you to try writing it using foldl'. That will end up more structured and more similar to the original pseudocode
06:19:06 <orion> hugomg: Just by looking at the pseudocode, what properties does it have that allows it to be written using foldl'?
06:19:09 * hackagebot twitter-feed 0.1.1.2 - Client for fetching Twitter timeline via Oauth  http://hackage.haskell.org/package/twitter-feed-0.1.1.2 (jsl)
06:23:01 <fds4345> is (!) O(n) ?
06:23:08 <cinimod> I am thinking of using https://hackage.haskell.org/package/cipher-aes
06:23:24 <cinimod> Anyone know how I tell if it using aes-ni?
06:23:56 <slomo> fds4345: the one on (normal) lists is, yes
06:24:34 <geekosaur> (!!) is lists, (!) is arrays, arrays are not linked lists
06:25:33 <hugomg> orion: for-loops = folds/maps; for-loop with an accumulator = foldl'
06:25:42 <geekosaur> array (!) is O(1) with a comparatively large constant because it does bounds checking
06:26:46 <hugomg> just make the 0..ceil into a list of indices so that its a for-each loop instead of a numerical for loop
06:26:56 <slomo> geekosaur: oops, indeed
06:28:03 <setrecall> hugomg: Thank you!
06:29:02 <SvenskFisk> Hey guys, ghc-mod keeps telling me that it fails to parse build-depends in this file : http://lpaste.net/114625, and I can't find what the problem is, any ideas?
06:30:01 <Lutin`> hugomg: I have a feeling by zeros[64] he meant 64-byte array initialized to zero
06:30:08 <Lutin`> But he'll figure that out ;)
06:30:32 <SvenskFisk> Never mind, apparently you can't do time-1.2.0, it has to be time == 1.2.0
06:31:02 <Lutin`> SvenskFisk: Glad we could help
06:31:04 <Lutin`> :P
06:41:35 <renxX_> I have a Binary tree defined as
06:41:36 <renxX_> data BinaryTree a = Empty | Branch a (BinaryTree a) (BinaryTree a) deriving (Show, Read, Eq)
06:41:59 <renxX_> occurs :: Eq a => a -> BinaryTree a -> Bool
06:41:59 <renxX_> occurs x Empty = False
06:41:59 <renxX_> occurs x (Branch a left right)
06:41:59 <renxX_>     | x /= a = (occurs a left) || (occurs a right)
06:41:59 <renxX_>     | x == a = True
06:42:57 <renxX_> And im writing occurs function, but it alwasy returns false, except for when element which im lookin is in root branch
06:43:28 <n4x> renxX_: "occurs a"
06:44:10 * hackagebot nats-queue 0.1.1.0 - Haskell API for NATS messaging system  http://hackage.haskell.org/package/nats-queue-0.1.1.0 (ondrap)
06:44:45 <renxX_> what do you mean by that
06:44:48 <Lutin`> renxX_: What he's saying is you mean `| x /= a = (occurs x left) || (occurs x right)`
06:45:31 <Lutin`> `occurs x` instead of `occurs a`
06:47:01 <renxX_> thank you
06:50:03 <frm> hi all, i have problems accessing www.haskell.org. i receive 523 HTTP responses. is this the correct channel to discuss about it, or should i send a message to #haskell-ops?
06:50:26 <SvenskFisk> Currently I have this code : http://lpaste.net/114627 is there any way to combine the second two lines?
06:56:35 <jkarni1> frm: http://www.reddit.com/r/haskell/comments/2moz6b/note_the_primary_wwwhaskellorg_server_is_going/
06:57:14 <filius`> Svenskfisk: something like this:  doesFileExist "thing" >>= \x -> if x then ... else ... ?
06:57:36 <clrnd> SvenskFisk, I can't come up with a good trick, but it'd be a trick anyway
06:57:49 <clrnd> it depends on what you wanna do maybe
06:58:36 <filius`> oh, I think I get it wrong ...
06:59:07 <clrnd> filius`, thats just unsugaring do notation :P
06:59:32 <clrnd> you could LambdaCase and avoid a binding ...
07:00:05 <frm> jkarni1 thanks for the link, i was not aware of it
07:01:32 <lpaste> cdk pasted “for codygman” at http://lpaste.net/114629
07:02:21 <VhscZbGdf> STAFF BROUGHT YOU THIS NOW NETWORK-WIDE MESSAGE. emlow Natch mandu simpson patrykn Freemason mizu_no_oto fabe barrucadu keltvek nkhodyunya NightRa eevar frm ggreg Thhethssmuz zalami notdan u-ou d3lxa belst suvash_away ventonegro RchrdB roo mgaare Number2 Dashkal abh jonsterling swook mami mirsal albertid otto_s hegge m4farrel spaceshi1s agundry path[l] jroesch kirjs______
07:02:21 <VhscZbGdf> STAFF BROUGHT YOU THIS NOW NETWORK-WIDE MESSAGE. samrat tomprince dgonyeo kav mno2_ vimpire Reiser ZioCrocifisso Hodapp dagle qxjit KitC albel727 dmwit mendez _flow_ fractalcat theDon iota_ XyMa` Axman6 SparkySparkyBoom dolio reactormonk seancorfield haasn dowski__ eikke bbastian- arnihr_ ckey` int-e Paprikachu marr carlosgaldino meandi sajith jix codehero jlewis mrpantou1l
07:02:21 <VhscZbGdf> STAFF BROUGHT YOU THIS NOW NETWORK-WIDE MESSAGE. spacebug milessabin manfoo7`` hyPiRion David dpn` qr42 ryanakca falafel SuperTux88 cjay estewei_off WzC mecalopolis AlainODea_ Hugglesworth liyang manfoo7 Reyu PatrickRobotham inr larrytheliquid__ Vbitz mjo seliopou S11001001 ido qz dsfox zpconn__________ pks Ferdirand sea-gull javjarfer krakrjak juhp shutdown_-h_now conehead qzz
07:02:21 <VhscZbGdf> STAFF BROUGHT YOU THIS NOW NETWORK-WIDE MESSAGE. vlatkoB_ folone c_wraith brandonw Mokosha spookley machineslearn sprang stefan_1_|Work ndeine edon Fusxfaranto benbangert McManiaC shelf rossberg Scorchin Kabaka Walther_ jzelinskie Razz mada amf kosmikus torpet wormphlegm mero arianvp_ Jello_Raptor ninegrid ThePhoeron murgaan_ Fubar^_ lpsmith Sornaensis dan64 Yawgmoth acharles l
07:02:21 <VhscZbGdf> STAFF BROUGHT YOU THIS NOW NETWORK-WIDE MESSAGE. seagreen- fikusz davean tdammers Clint besenwesen Rutger` AshyIsMe Quashie a3gis hongminhee ens dino_joel elfangor ttuegel elij sujeet davidstone Cerise hebz0rl koala_man xandaros bartavelle Artpicre albeit_ gargawel tomku asm89 bgyss pantsman iron_houzi Phillemann liamgoodacre LordDeath Nervkind1 fall` fumieval hackagebot reneko
07:02:21 <VhscZbGdf> STAFF BROUGHT YOU THIS NOW NETWORK-WIDE MESSAGE. dispersed zymurgy CoverSlide cyphase TrafficMan jackhill andbroby spion keaml RevJohnnyHealey ernst japesinator AntiSpamMeta abc56889 conal agumonkey mystor Laney kaiza sbahra DanToml Adios mrowe_away ggherdov tromp__ vikraman clog adimit marvimias idnar govg _br_ mthvedt boris`` comboy_ MMuse_____ majoh theorbtwo anttih banyan
07:02:39 <Fuuzetsu> isn't that nice
07:02:51 <clrnd> lovely I'd say
07:02:56 <sujeet> lol
07:03:00 <ij> I didn't get mentioned, yay!
07:03:23 <ij> Does haskell have runtime overhead? Or a runtime even?
07:03:48 <clrnd> put like this, nicknames look like some nordic language
07:03:50 <ventonegro> ij: even C has a runtime
07:03:58 <vVNNPAhxO> STAFF BROUGHT YOU THIS NOW NETWORK-WIDE MESSAGE. thetallguy codehero rufs teeteewhy mendez Kabaka przembot s4msung marr peropaal mthvedt m4farrel ClaudiusMaximus nafis felixsch tomaw renzhi wagle HugoDaniel fnordbert Adeon angelicstrike geal prosper_ dav1d sriprasanna geekosaur anry amontez raphie int-e joehh badi`` machineslearn sorind ioanel stepkut`` S11001001 lucs jrslep
07:03:58 <vVNNPAhxO> STAFF BROUGHT YOU THIS NOW NETWORK-WIDE MESSAGE. fyolnish petersr dmwit lycide jlamothe yumike SuperTux88 ephemeron besenwesen zalami mechairo` ido andbroby Bane^ hebz0rl bonobo simonnn_ Fubar^_ alethea glaebhoerl_ vladan funrep_ hiredman fling sbahra kakos julienXX Hafydd xophmeister petermw ahf iota_ SvenskFisk relrod eyem jang eristic kalz joedevivo kloeri mach augur_
07:03:58 <vVNNPAhxO> STAFF BROUGHT YOU THIS NOW NETWORK-WIDE MESSAGE. aristid Chousuke omefire1 tlevine CoverSlide mankyKitty deavid Rufflewind dfeuer sinopeus tomboy65 koniiiik shintah FofG eagleflo noctux haroldwu tg owlglass2 lyxia robstewartuk iteratee alang mikeizbicki fikusz Matrixman_217 arj yano Quashie Takle_ cyanoacry Tiktalik bel3atar anttih ahihi zxtx tech2 Natch dflemstr jlewis so
07:03:59 <vVNNPAhxO> STAFF BROUGHT YOU THIS NOW NETWORK-WIDE MESSAGE. luzie lukaramu joefiorini_ liff mkster drewdavis therealklanni gidogeek vsayer_ comboy_ akurilin sbrg zph connerb Starfire guampa keko-2 zoglesby murgaan_ hvr sclv Gonzih fryguybob ruukasu Philonous KitC Transfusion phischu bergmark greymalkin hopnotch NikolajK moop milli` _5kg majoh christiansen` Oxyd TheOnionKnight qwandor
07:03:59 <vVNNPAhxO> STAFF BROUGHT YOU THIS NOW NETWORK-WIDE MESSAGE. naudiz jlyndon agumonkey ivan` levi akahn pyrtsa monochrom TallerGhostWalt SaBer_ shergill periodic fractalcat Vbitz ousado Willis mkoskar ft seanparsons aupo fergusnoble stelleg wjm lispy totte fds4345 paperManu hamishmack dreixel _ikke_ mceier zennist tdammers diginet nathanic kaiza s_e Paprikachu Maxdamantus mathemancer m
07:04:06 <clrnd> @where ops
07:04:07 <lambdabot> arjanb bos byorgey Cale conal copumpkin dcoutts dibblego dmhouse dolio dons edwardk elliott geekosaur glguy Heffalump Igloo jmcarthur johnw kosmikus Lemmih monochrom nyc Philippa Pseudonym quicksilver roconnor Saizan shachaf shapr sjanssen ski sorear SyntaxPolice xerox
07:04:12 --- mode: ChanServ set +o geekosaur
07:04:23 <Lutin`> clrnd: They can't do anything
07:04:23 <ij> can't ban that really, different IP addrs and nicks.
07:04:24 <augur_> lolwut
07:04:33 --- mode: geekosaur set -o geekosaur
07:04:46 <clrnd> so we are scrwed? we are all gonna die?
07:04:51 <ij> No.
07:04:54 <notdan> it's all going to be fine
07:04:56 <Lutin`> And I'm disappointed, it's not actually network-wide
07:05:03 <Lutin`> scrub spammers
07:05:26 <augur_> that was the worst spam ive seen ever
07:05:39 <augur_> there wasnt even a message or anything
07:05:46 <augur_> just massive pinging
07:05:48 <NikolajK> someone called my name?
07:05:55 <xandaros> spam
07:05:56 <dagle> NikolajK: Spambot did
07:06:02 <NikolajK> Hi Spambot
07:06:05 <Lutin`> They probably just want the attention and to make everyone talk about it
07:06:15 <Lutin`> just ignore it and go on with life
07:06:16 <arj> so they succeeded....
07:06:42 <ventonegro> the terrorists won again
07:06:43 <dagle> You mean that we are part of the conspiracy atm?
07:06:54 <clrnd> am I a terrorist?
07:06:56 <NikolajK> "A country of which nothing is known but the name"
07:07:19 <NikolajK> (is a great article)
07:07:26 <jkarni1> anyone know if there's a way of getting HPC reports for a test while still not including the library src dir in the cabal hs-src-dirs for the test?
07:15:13 <sexypussy19> mmmmmmmmmmmmmmm
07:16:21 <ocramz> oioi room
07:17:18 <ocramz> emacs experts around? I’d like to assign C-c C-l to “cabal repl” rather than ghci, where can I do that?
07:17:46 <ocramz> in order to load into a specific sandbox
07:18:03 <ocramz> any help appreciated
07:18:55 <Fuuzetsu> depending on your haskell-mode version and setup, (setq haskell-program-name "cabal repl")
07:19:05 <Fuuzetsu> make sure to M-x cd to top level of the project
07:19:33 <Fuuzetsu> but I think new versions of Haskell mode have better support out of the box for such stuff
07:21:25 <ocramz> hm, thanks
07:21:42 <Fuuzetsu> s/Haskell mode/haskell-mode/
07:21:51 <ocramz> yesyes
07:21:55 <Fuuzetsu> ;)
07:26:45 <ocramz> hm no, I still get the same error
07:26:55 <ocramz> sandbox-local packages are not visible
07:27:41 <ocramz> Fuuzetsu: how did you configure your system? I mean, I have managed to have a sandbox working with all the stuff I need, and I’ve already verified that it works (ghci from command line)
07:28:05 <ocramz> that *they work
07:28:47 <meretrix> ocramz: With the newest haskell-mode and using interactive-mode (not inferior mode), local sandboxes just work for me.
07:28:52 <meretrix> No configuring necessary for me.
07:29:08 <meretrix> It runs cabal repl be default I think.
07:30:09 <ocramz> meretrix: is interactive-mode in Melpa?
07:30:47 <meretrix> ocramz: I don't know what that is.
07:30:56 <meretrix> I have the following line in my .emacs:
07:30:56 <ocramz> the package manager for emacs
07:30:58 <meretrix> (add-hook 'haskell-mode-hook 'interactive-haskell-mode)
07:31:07 <ocramz> oh ok
07:31:12 <meretrix> ocramz: It's just part of haskell-mode.
07:32:13 <meretrix> Say I have "data Data = A | B | C | D | E String deriving (Eq)".  I could write "d in [A,B]", but I can't write "d in [D,E _]".  Is there any way to do that without have to pattern match "D" and "E _" separately?
07:32:20 <ocramz> meretrix: thanks, I’m trying it out
07:32:37 <ocramz> cool handle though, if you know Latin :D
07:32:52 <meretrix> heheh :)
07:33:20 <HeladoDeBrownie> meretrix, those don't look like complete expressions. "in" is usually part of "let"
07:34:04 <HeladoDeBrownie> meretrix, if that is indeed part of a "let" expression, the problem would be you're writing a pattern where an expression is expected
07:34:45 <meretrix> HeladoDeBrownie: Oops I meant to write `elem`.
07:34:47 <JordiGH> I'm probably going to regret asking, but... is there a simpler way to say "print each element of this list in one line"? I don't like thinking about the difference between map and mapM and mapM_. Can I pretend monads don't exist? http://codepad.org/J4mUYEvw
07:34:54 <meretrix> Confusing Haskell with kdb+/q...
07:35:04 <HeladoDeBrownie> meretrix, actually that's the syntax for holes, do you get an error saying there's a hole?
07:35:20 <HeladoDeBrownie> ("that" meaning the "_" in that expression)
07:35:39 <meretrix> HeladoDeBrownie: Yes, it treats it as a hole.
07:35:51 * JordiGH really wishes Haskell had for-loops like OCaml does.
07:35:53 <HeladoDeBrownie> meretrix, so what is it you're trying to do?
07:35:59 <meretrix> But I really just want to match any "E".
07:36:19 <HeladoDeBrownie> meretrix, well, how? You're using a specific list
07:36:43 <HeladoDeBrownie> meretrix, can you describe the problem at a slightly higher level? Maybe you have the syntax wrong for what you want
07:37:13 <Fuuzetsu> ocramz: I use nix so I just use ghci inside a nix-shell but in the past I used to call out to ‘cabal repl’
07:38:12 <meretrix> HeladoDeBrownie: I want to write "if (d `elem` [D, E s]) then foo else bar" for all values of "s".
07:38:28 <HeladoDeBrownie> meretrix, where are you getting the list from?
07:38:34 <HeladoDeBrownie> meretrix, is that just an example list?
07:38:41 <meretrix> HeladoDeBrownie: It's hardcoded.
07:38:54 <dramforever> for all values of s?
07:39:04 <HeladoDeBrownie> meretrix, ah, I see, you want to ask whether *any* value with the E constructor is in the list
07:39:07 <meretrix> I could pattern match, "case d of D -> foo; E _ -> foo; _ -> bar"..
07:39:11 <dramforever> yep
07:39:17 <meretrix> Yeah.
07:39:25 <HeladoDeBrownie> meretrix, yes, pattern matching is what you'd do
07:39:28 <meretrix> But I don't want to have to write "foo" many times.
07:39:36 <sbrg> Anyone happen to remember the actual name of a series of articles that are about writing a simple game AI in haskell, based on some scheme book or some such?
07:39:55 <dramforever> meretrix: what's the problem of that?
07:40:06 <meretrix> I'm lazy. :)
07:40:15 <HeladoDeBrownie> meretrix, try writing it out how you'd write it with case and post it, maybe we can help you make it look nicer
07:40:18 <dramforever> you just typed "foo" many, many times
07:40:30 <dramforever> I think you are misunderstanding `elem`
07:40:33 <hugomg> JordiGH: if you don't like thinking, use Hoogle and it will tell you what function to use :)
07:40:43 <HeladoDeBrownie> But yeah, elem is not what you'd use for that
07:40:44 <dramforever> it's just a function. period.
07:40:45 <HeladoDeBrownie> @type any
07:40:46 <lambdabot> (a -> Bool) -> [a] -> Bool
07:40:49 <HeladoDeBrownie> That's more like it
07:40:54 <tdammers> @hoogle which function should I use?
07:40:56 <lambdabot> Parse error:
07:40:56 <lambdabot>   which function should I use?
07:40:56 <lambdabot>                               ^
07:40:58 <HeladoDeBrownie> elem is just a special case of any anyway
07:41:00 <dramforever> lol
07:41:07 <tdammers> it doesn't work
07:41:11 <dramforever> :t elem
07:41:12 <lambdabot> Eq a => a -> [a] -> Bool
07:41:12 <JordiGH> hugomg: I still have to draw arrow diagrams in order to understand how to print stuff. Can't this be avoided? Is there a way to pretend that monads don't exist? OCaml mostly succeeds in pretending monads don't exist.
07:41:17 <tdammers> send me teh codez plz
07:41:37 <ocramz> Fuuzetsu: thanks, but no time for OS reinstall fun right now ;)
07:41:54 <EvanR> JordiGH: you can use Debug.Trace (trace) to print out stuff for debugging
07:42:07 <JordiGH> hugomg: Is mapM_ printStrLn... really the easiest way to print out each element of a list?
07:42:11 <tdammers> JordiGH: you can kind of pretend monads don't exist, and just stick with IO as a type that represents imperative programs
07:42:23 <tdammers> (IO a, actually, but hey)
07:42:41 <JordiGH> That makes me think, ok, it's a monad, 'cause it's got a capital M at the end, and uh, that underscore means, uh, it's throwing out the monadic value? What was that again?
07:42:46 <hugomg> yeah, mapM_ is the way to go. There is also forM_ which is similar
07:42:52 <dramforever> :t forM
07:42:53 <lambdabot> Monad m => [a] -> (a -> m b) -> m [b]
07:42:56 <dramforever> :t mapM_
07:42:56 <lambdabot> Monad m => (a -> m b) -> [a] -> m ()
07:42:57 <dramforever> :t mapM
07:42:58 <EvanR> :t forM_ print
07:42:58 <lambdabot> Monad m => (a -> m b) -> [a] -> m [b]
07:42:59 <lambdabot>     Couldn't match expected type ‘[a]’ with actual type ‘a0 -> IO ()’
07:42:59 <lambdabot>     Probable cause: ‘print’ is applied to too few arguments
07:42:59 <lambdabot>     In the first argument of ‘forM_’, namely ‘print’
07:43:04 <nshepperd> JordiGH: putStr . unlines . map show
07:43:21 <JordiGH> tdammers: So how would I write this function pretending monads don't exist? Is there a way to do this without using a function with the word "monad" in its name or its abbreviation?
07:43:27 <JordiGH> nshepperd: Ah, let me see...
07:43:31 <EvanR> JordiGH: not print is putStrLn . show
07:43:33 <EvanR> note*
07:43:34 <hugomg> yes, in Control.Monad, the M at the end means that its a function workinf on Monad and the _ means that you are throwing away the values (so you just care about the errects)
07:43:45 <tdammers> JordiGH: you could do the iteration by hand
07:43:53 <dramforever> just mind-replace M to IO
07:43:58 <JordiGH> hugomg: I don't want to have to remember what a monadic value is or why I would want to keep it or throw it.
07:44:10 <JordiGH> I think EvanR has my solution, let me see...
07:44:19 <dramforever> you have to want to, that's haskell
07:44:20 <hugomg> you don't need to remember, you get a type error when you forget :)
07:44:23 <JordiGH> I mean, nshepperd.
07:44:38 <dramforever> hugomg: lol that's true
07:44:39 <JordiGH> lol
07:44:44 <tdammers> > let printList xs = if null xs then return () else do { putStrLn (head xs); printList (tail xs) } in printList [ "foo", "bar", "baz" ]
07:44:45 <lambdabot>  <IO ()>
07:44:52 <dramforever> well, you get a warning too, sometimes
07:45:12 <EvanR> JordiGH: for something that does forM without the M, use for ;)
07:45:14 <EvanR> :t for
07:45:14 <lambdabot>     Not in scope: ‘for’
07:45:15 <lambdabot>     Perhaps you meant one of these:
07:45:15 <lambdabot>       ‘T.for’ (imported from Data.Traversable),
07:45:19 <nshepperd> it's silly to not want to learn this stuff though
07:45:19 <EvanR> :t T.for
07:45:19 <lambdabot> (Traversable t, Applicative f) => t a -> (a -> f b) -> f (t b)
07:45:31 <dramforever> with -Wall, do {-...-}  mapM print blah {-...-} gives a warning about the non-ignored result
07:45:35 <nshepperd> programming only gives you as much power as you reach for
07:45:39 <tdammers> JordiGH: forM_ pretty much just abstracts over the iteration in a monad
07:45:45 <Fuuzetsu> ocramz: nix is a package manager, not an OS, so it can run on your existing distro ;)
07:45:47 <dramforever> mapM -> mapM_ will make it disappear
07:45:49 <tdammers> JordiGH: and "Monad" is just an abstraction that happens to apply here
07:46:01 <JordiGH> tdammers: It's got "monad" in its name, this is not an abstraction.
07:46:11 <dramforever> JordiGH:
07:46:23 <dramforever> JordiGH: do you -Wall?
07:46:41 <JordiGH> nshepperd: It's not silly to want to actually accomplish things instead of reading about monads.
07:47:14 <dramforever> JordiGH: what do you want to accomplish?
07:47:15 <EvanR> JordiGH: for is more abstract
07:47:16 <JordiGH> OCaml is proof that it's possible to have a functional language with almost invisible monads.
07:47:21 <clrnd> JordiGH, no need to read about monads, just assume the M in forM means "Monkeys"
07:47:22 <JordiGH> dramforever: I want to accomplish FizzBuzz.
07:47:38 <EvanR> ocaml lets you do IO/effects anywhere you want
07:47:41 <dramforever> huh? can you give more details, please
07:47:44 <wei2912> in parsec, how do i do an optional parse?
07:47:49 <JordiGH> dramforever: http://codepad.org/J4mUYEvw
07:47:53 <wei2912> err
07:48:00 <dramforever> :t Text.Parsec.optional
07:48:00 <lambdabot> Text.Parsec.Prim.Stream s m t => Text.Parsec.Prim.ParsecT s u m a -> Text.Parsec.Prim.ParsecT s u m ()
07:48:02 <tdammers> JordiGH: the reason OCaml gets away without explicit monads is because it allows side effects
07:48:02 <wei2912> i mean, consume something if it exists, otherwise don't\
07:48:15 <JordiGH> tdammers: Any programming language allows side effects.
07:48:15 <clrnd> wei2912, try, but they'll hit me for this
07:48:20 <clrnd> I mean, the funciton `try`
07:48:25 <tdammers> JordiGH: no. Haskell doesn't.
07:48:27 <wei2912> clrnd: haha
07:48:32 <wei2912> dramforever: thanks
07:48:32 <n4x> JordiGH: Haskell allows effects, not side-effects!
07:48:35 <hugomg> JordiGH: monads are a price we pay for lazyness. Its really neat that our lists are automatically streams with O(1) space usage but the price we pay for that is that we need purity to stay sane, hance monads
07:48:38 <tdammers> (unsafePerformIO notwithstanding)
07:48:39 <JordiGH> tdammers: You're telling me it's my imagination that this Haskell program just printed out lines?
07:48:41 <dramforever> wei2912: wait...
07:48:45 <EvanR> JordiGH: you can rename the forM_ function to forEach ;)
07:48:47 <dramforever> it does not return the result
07:48:51 <clrnd> JordiGH, hey this works right? so what's the problem?
07:48:53 <tdammers> JordiGH: the Haskell program didn't. Feeding it to the Haskell runtime did.
07:49:14 <JordiGH> Okay, guys, never mind, I obviously don't fit in here.
07:49:16 <JordiGH> Goodbye.
07:49:17 <zwer> ocaml "solves" this the same way most languages do,unrestricted use of IO  everywhere
07:49:22 <hugomg> Also, Ocaml also uses monads a lot for things like Option of Lwt. Its just that monads are more ubiquitous in Haskell because typeclasses makes them easy to use
07:49:27 <clrnd> JordiGH, waiiit
07:49:31 <dramforever> oh no
07:49:32 <clrnd> :(
07:49:46 <EvanR> youre complaining about the function you are using having a type with something you dont know in it, is this an issue every time that happens?
07:49:48 <tdammers> maybe he's right
07:49:48 <dramforever> I guess I could /query him/her back
07:50:01 <nshepperd> success~
07:50:04 <tdammers> s/query/summon/
07:50:18 <clrnd> lol I use functions I have no freaking idea what their names/types imply all the time, taht's the cool thing about haskell
07:50:36 <clrnd> if it type checks, it's probably okay :D
07:50:45 <EvanR> if it boots up its perfect
07:51:06 <tdammers> and if it doesn't, the compiler tells you what to do!
07:51:46 <hugomg> well, you can also do lots of "guardrail programming" in Ocaml.  But they don't have type classes and their stdlib is sad :(
07:52:05 <bjhaid> how do I un import a function, I am trying to redefine ^ and want to remove it from the load path so I can use my definition
07:52:22 <hugomg> its "import Module hidinf (foo)" iirc
07:52:24 <tdammers> import Whatever.Namespace hiding ( (^) )
07:52:26 <clrnd> the last time I tried ocaml I ended up programming in F# ... pretty fun
07:52:26 <hugomg> *hiding
07:52:35 <dramforever> Q. How to change a program that uses strict bytestrings into one that uses Lazy bytestrings?
07:52:35 <dramforever> A. Change the type of bit that uses the result, then follow the compiler
07:53:06 <tdammers> dramforever: or just change the relevant import, and then follow the compiler
07:53:24 <dramforever> well, not if you imported both
07:53:30 <tdammers> obviously
07:53:45 <dramforever> change a bit and everything will change
07:53:54 <dramforever> well, must change
07:54:15 <tdammers> I have this little string-convert lib around... you just slap the `s` function on anything string-like, and it'll magically convert it to whatever other string type the other end wants :P
07:57:58 <wei2912> is there an easy way to read a hexadecimal, octal or binary number in haskell?
07:59:15 <bitonic> > read "0xA" :: Int
07:59:16 <lambdabot>  10
07:59:31 <bitonic> wei2912: ^^
07:59:35 <indiagreen> > read "0o10" :: Int
07:59:36 <lambdabot>  8
07:59:48 <indiagreen> > read "0b10" :: Int
07:59:50 <lambdabot>  *Exception: Prelude.read: no parse
07:59:53 <tdammers> awww
07:59:56 <indiagreen> darn, I thought they added it
08:00:10 <EvanR> > 0xA1
08:00:12 <lambdabot>  161
08:00:13 <bitonic> yeah, that's what I was wondering
08:00:15 <EvanR> > 0oA1
08:00:16 <lambdabot>  Not in scope: ‘oA1’
08:00:37 <EvanR> > 0OA1
08:00:38 <lambdabot>  Not in scope: data constructor ‘OA1’
08:00:55 <wei2912> bitonic: thanks
08:01:00 <EvanR> > 0o31
08:01:02 <lambdabot>  25
08:01:10 <EvanR> > 0b111
08:01:11 <lambdabot>  Not in scope: ‘b111’
08:01:14 <HeladoDeBrownie> wei2912, for use cases beyond what read covers, I might suggest writing a parsec parser. E.g., if you only want to accept numbers in one particular base without any of the odd markings.
08:01:33 <HeladoDeBrownie> wei2912, actually, you could just operate on the string directly
08:01:44 <wei2912> HeladoDeBrownie: hmm
08:01:53 <EvanR> though you have to handle invalid strings yourself if you do it directly
08:02:45 <HeladoDeBrownie> I usually jump to suggesting parsec because if you formulate things in terms of it then it's easier to change things up when you decide you want more power than you thought
08:03:10 <HeladoDeBrownie> But in this case you can iterate over a list of Char, check if it's a digit, and if so add its value to some accumulator
08:03:25 <benzrf> review me code please https://gist.github.com/benzrf/94ef45a81685d71e1114
08:05:46 <wei2912> benzrf: smells worse than me *ducks*
08:07:10 <indiagreen> benzrf: comments are really helpful when you want -people who have no idea what you're trying to do- to understand your code
08:07:15 <indiagreen> and generally good things and stuff
08:07:20 <wei2912> <<<<<<<<<---------- one of them
08:07:30 <benzrf> :I
08:07:50 <benzrf> i never got in the habbit
08:08:02 <wei2912> is there some function that allows me to read in a string with a base? :P
08:08:07 <EvanR> "it should be obvious whats going on" ;)
08:08:21 <HeladoDeBrownie> wei2912, not in base, afair, it's possible you can find it on Hackage
08:08:37 <HeladoDeBrownie> Er, not in the base *package*, sorry for the ambiguity :P
08:08:41 <wei2912> haha
08:09:07 <EvanR> wei2912: i see some functions in package "numeric"
08:09:21 <clrnd> wei2912, did a parser for octal in parsec a while ago: https://github.com/alvare/dson-parsec/blob/master/Data/Dson/Octal.hs
08:09:30 <indiagreen> wei2912: readInt/readDec/readOct/readHex
08:09:32 <clrnd> I did*
08:09:45 <clrnd> (in case you wanted to go at it with parsec)
08:09:54 <wei2912> indiagreen: where did those come from?
08:09:56 <EvanR> > readHex "abcd"
08:09:58 <lambdabot>  [(43981,"")]
08:10:07 <indiagreen> wei2912: Numeric
08:10:11 <HeladoDeBrownie> Huh, so it is in base. My mistake
08:10:12 <wei2912> ahh, thanks
08:10:13 <indiagreen> http://hackage.haskell.org/package/base-4.7.0.1/docs/Numeric.html
08:10:18 <wei2912> thanks indiagreen EvanR clrnd
08:10:38 <EvanR> > readHex "abXcd"
08:10:39 <lambdabot>  [(171,"Xcd")]
08:10:44 <wei2912> clrnd: reading your parsec code, i'm following Write Yourself a Scheme in 24h
08:11:03 <clrnd> wei2912, I learnt a lot from that one too :)
08:11:10 <clrnd> it was 48hs back then
08:11:16 <indiagreen> benzrf: I got into the habit by treating all code I write as Potentially The Most Downloaded Library On Hackage
08:11:35 <indiagreen> which made me want to emulate other libraries
08:11:42 <indiagreen> which usually have haddocks and what-not
08:12:24 <tdammers> wei2912: is that the digest version of "Write Yourself A Scheme in 48 Hours"?
08:12:33 <wei2912> tdammers: err, i mean 48 hours
08:13:09 <tdammers> ;)
08:13:12 <n4x> the next version will be "writing yourself a scheme in 12 hours", I guess
08:13:31 <wei2912> "Writing Yourself a Scheme in a minute"
08:13:40 <dramforever> Well, people are misunderstanding mfix
08:13:41 <wei2912> employ an infinite number of monkeys to type
08:13:43 <wei2912> ???
08:13:44 <wei2912> profit!
08:13:50 <EvanR> "a scheme" does this imply that it satisfies whatever holy standard scheme has?
08:13:57 <RevJohnnyHealey> "Write Yourself a Scheme in Scheme"
08:14:00 <wei2912> damn
08:14:01 <clrnd> lol
08:14:14 * hackagebot vector-fftw 0.1.3.2 - A binding to the fftw library for one-dimensional vectors.  http://hackage.haskell.org/package/vector-fftw-0.1.3.2 (JudahJacobson)
08:14:26 <dramforever> they are supposed to be used like mfix (\~(a,b,c...) -> do .... return (a,b,c...) )
08:14:30 <EvanR> i figured it was colloquially like scheme, but then i was told scheme has a strict definition
08:14:38 <n4x> "Write Yourself in Scheme"
08:15:03 <dramforever> "Write Yourself"
08:15:06 <dramforever> "Write
08:15:07 <dramforever> "
08:15:15 <n4x> ""
08:15:22 <tdammers> Paul Graham implemented himself in Common Lisp, so why not
08:15:31 <dramforever> > head ""
08:15:32 <lambdabot>  *Exception: Prelude.head: empty list
08:15:43 <EvanR> _|_
08:15:52 <tdammers> Write "Write this sentence in Scheme" in Scheme
08:15:54 <dramforever> there isn't even a head for the tutorial, why read it
08:16:35 <will_> hi, i have a question about list monad. suppose i can have: :{ do x <- action; y <- action; return x + y :} ...how can i generalize this so that i can perform arbitrary number of "actions" in the do block?
08:16:52 <will_> and still return with x1+ x2+x3+.....xn
08:17:03 <dramforever> > let action = [1,2,3,4,5] in replicateM 5 action
08:17:05 <lambdabot>  [[1,1,1,1,1],[1,1,1,1,2],[1,1,1,1,3],[1,1,1,1,4],[1,1,1,1,5],[1,1,1,2,1],[1,...
08:17:06 <zwer> will_ sequence
08:17:21 <dramforever> > let action = [1,2,3,4,5] in map sum (replicateM 5 action)
08:17:22 <lambdabot>  [5,6,7,8,9,6,7,8,9,10,7,8,9,10,11,8,9,10,11,12,9,10,11,12,13,6,7,8,9,10,7,8,...
08:17:30 <dramforever> will_: how is that?
08:17:52 <will_> dramforever zwer wow..
08:18:21 <dramforever> the list monad is actually magical
08:18:32 <dramforever> nearly magical
08:18:58 <dramforever> they confuse people very much when used with functions that takes monad
08:19:00 <dramforever> monads
08:19:03 <will_> dramforever indeed! thanks
08:19:15 <clrnd> mod <$> [1..5] <*> [7..5]
08:19:18 <dramforever> you are welcome
08:19:19 <clrnd> > mod <$> [1..5] <*> [7..5]
08:19:21 <lambdabot>  []
08:19:27 <clrnd> > mod <$> [1..5] <*> [5..7]
08:19:29 <lambdabot>  [1,1,1,2,2,2,3,3,3,4,4,4,0,5,5]
08:20:30 <iLike> If I add an instance declaration for a certain class (Show in this case), can I define it for multiple classes at the same time? Like: instance Show Hour, Minute, Second where show = func ?
08:20:41 <iLike> multiple types*
08:21:01 <dramforever> iLike: what's func like?
08:21:01 <benzrf> iLike: what would thta even mean
08:21:14 <ij> clrnd, Wow, that's pretty cool.
08:21:33 <benzrf> the coolest is:
08:21:43 <benzrf> > fix$scanl(+)0.(1:)
08:21:45 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
08:21:45 <iLike> Well they're all newtype's of type Int
08:22:19 <dramforever> haha benzrf, pidgin is replacing (1:) with (1<smiling face>
08:22:28 <benzrf> mfw
08:22:30 <iLike> So every show is something like, show (Second s) = paddDigit s
08:22:46 <iLike> where paddDigit :: Int -> String
08:22:58 <indiagreen> > > fix$scanl(+)0.(1:⁠) -- dramforever, is this replaced too
08:23:08 <indiagreen> > fix$scanl(+)0.(1:⁠) -- ouch
08:23:09 <lambdabot>  <hint>:1:18: lexical error at character '\8288'
08:23:16 <indiagreen> ah darn, stupid lambdabot
08:23:20 <indiagreen> it works in GHCi
08:23:21 <dramforever> indiagreen: why?
08:23:48 <geekosaur> indiagreen, it's the comment character, your irc client changed it to a unicode dash
08:24:10 <dramforever> hmmm....
08:24:12 <geekosaur> hm, no, my client claims otherwise
08:24:19 <geekosaur> \8288 is weird though
08:24:24 <dramforever> it doesn't even show up
08:24:27 <indiagreen> it's zero-width space
08:24:27 <geekosaur> OH
08:24:36 <indiagreen> I use it in Skype to prevent smileys from appearing
08:24:43 <geekosaur> hm, no
08:24:47 * geekosaur too tired for this
08:24:57 <geekosaur> ok
08:25:16 <geekosaur> yes, that's the sort of thing ghci probably handles per haskell spec but hint doesn't
08:25:24 <geekosaur> hint has a lot of shortcomings in that regard
08:25:54 <EvanR> we should liberally be using zero width spaces in our source code
08:26:09 <EvanR> to keep things from getting boring
08:26:10 <dramforever> why? why is there even a char for it?
08:26:23 <clrnd> damn youuuu unicode
08:27:09 <EvanR> some scripts do not have explicit spacing, and theoretically such zero width spaces could be used by a typesetter to put "space" separated things on the next line
08:27:30 <geekosaur> zero width space? to prevent programs from auto-ligature-ing "ffi" and such, I think
08:27:36 <cdk> has anyone tried using `ghc -fno-code` as a lightweight syntastic syntax checker? I've never written an extension for syntastic and my knowledge of vimscript is pretty poor so I'm not sure what I'm doing wrong...
08:28:08 <wei2912> http://lpaste.net/114633 - why is there a parse error on line 4, "<-"?
08:28:30 <clrnd> wei2912, you forgot `do`
08:28:31 <iLike> you forgot 'do'?
08:28:37 <EvanR> i get the feeling that zero width space is only there to describe typesetting machinations that existed before unicode
08:28:40 <indiagreen> on line 2
08:28:43 <wei2912> clrnd: ohh, thanks
08:29:39 <geekosaur> you'll pry ligatures away form font designers' cold dead hands...
08:29:39 <EvanR> 8288 is WORD JOINER though
08:30:02 <EvanR> which is the opposite
08:30:24 <EvanR> also known as NBSP
08:38:06 <ReinH> er, NBSP is an actual space
08:38:35 <dramforever> yeah
08:38:38 <ReinH> NO-BREAK SPACE is U+00A0
08:38:54 <ReinH> aka &nbsp;
08:39:26 <indiagreen> now ReinH will come and say we should move to #haskell-bla— oh, hi, ReinH
08:39:41 <EvanR> ok, word joiner seems to be the same thing
08:39:53 <ReinH> same thing as what?
08:40:05 <EvanR> a non breaking space
08:40:19 <ReinH> No. non-breaking space looks like a space.
08:40:29 <indiagreen> word joiner is a zero-width non-breaking space
08:40:40 <EvanR> oh, this is no space
08:41:25 <EvanR> ZWNBSP
08:41:25 <ReinH> although ZERO WIDTH NO-BREAK SPACE is U+FEFF
08:41:27 <ReinH> lol unicode
08:41:35 <indiagreen> no-o, this one is deprecated
08:41:41 <ReinH> still exists
08:41:47 <EvanR> fuck FEFF
08:44:15 * hackagebot learning-hmm 0.1.1.0 - Yet another library for hidden Markov models  http://hackage.haskell.org/package/learning-hmm-0.1.1.0 (mnacamura)
08:48:55 <blicero> how to lift sortBy to take a function that returns IO Ordering?
08:49:06 <indiagreen> blicero: no way
08:49:33 <indiagreen> there's a package for that
08:49:38 <indiagreen> @hackage monadlist
08:49:38 <lambdabot> http://hackage.haskell.org/package/monadlist
08:51:08 <blicero> thanks
08:51:21 <blicero> are there any other sort functions shipping with haskell platform libraries?
08:54:33 <bartavelle> blicero, http://haddocks.fpcomplete.com/fp/7.8/20140916-162/base/GHC-Exts.html#v:sortWith
09:06:18 <seangrove> is there a way to have a where definition depend on anothe where definition? e.g. where x = 10, y = f(x) ?
09:06:57 <ClaudiusMaximus> > let z = y where { x = 10 ; y = x + 1
09:06:58 <lambdabot>  <hint>:1:37:
09:06:59 <lambdabot>      parse error (possibly incorrect indentation or mismatched brackets)
09:06:59 <bitonic> seangrove: yeah, that's fine
09:06:59 <ClaudiusMaximus> oops
09:07:02 <ClaudiusMaximus> > let z = y where { x = 10 ; y = x + 1 } in z
09:07:03 <lambdabot>  11
09:07:34 <ClaudiusMaximus> likely replace { ; } with layout in real code
09:07:34 <seangrove> ClaudiusMaximus: What does the `in z` part do?
09:08:07 <ClaudiusMaximus> seangrove: it's part of let .. in .. - you need a binding = (or case) to attach a where to
09:09:12 <zennist> edwardk: how can I apply a function to a field in a data structure and return that data structure..?
09:10:07 <glguy> zennist: Are you asking specifically about using lenses? records?
09:10:08 <zennist> e.g. ("hello", "world") => ((++"haha") "hello", "world")
09:10:12 <zennist> yes
09:10:28 <glguy> > over _1 (++"haha") ("hello","world")
09:10:29 <lambdabot>  ("hellohaha","world")
09:10:40 <fds4345> is it possible to create a recursive anonymous function
09:10:42 <seangrove> ClaudiusMaximus: Thank you!
09:10:50 <HeladoDeBrownie> @type fix
09:10:51 <lambdabot> (a -> a) -> a
09:10:51 <Taneb> fds4345, you need something like fix
09:10:59 <zennist> glguy: cool cheers
09:11:09 <fds4345> how do you use fix
09:11:13 <Taneb> > fix (\r n -> if n == 0 then 1 else n * r (n - 1)) 10
09:11:15 <lambdabot>  3628800
09:11:17 <HeladoDeBrownie> Beat me to it
09:11:22 <n4x> fix (\fact n → if n == 0 then 1 else n * fact (n - 1)) -- ...
09:11:25 <n4x> damn
09:11:28 <fds4345> ah there we go :) cheers
09:13:46 <fds4345> :info fix
09:13:56 <fds4345> :t fix
09:13:57 <lambdabot> (a -> a) -> a
09:14:02 <josephle> @src fix
09:14:02 <lambdabot> fix f = let x = f x in x
09:14:07 <fds4345> aaw why no info lambdabot
09:15:47 <clrnd> @faq is Maybe a Functor?
09:15:47 <lambdabot> http://www.haskell.org/haskellwiki/FAQ
09:16:05 <EvanR> yes haskell can do that
09:17:32 <benzrf> #bringbackoldfaq
09:17:33 <benzrf> @where faq
09:17:33 <lambdabot> http://www.haskell.org/haskellwiki/FAQ
09:17:59 <benzrf> ^this exists
09:19:16 * hackagebot casadi-bindings 2.1.3.2 - mid-level bindings to CasADi  http://hackage.haskell.org/package/casadi-bindings-2.1.3.2 (GregHorn)
09:29:45 <bitraten> hi, can i redefine instance declarations of GHC.Base?
09:30:29 <dmwit> newp
09:30:35 <dmwit> Instances are global and immortal.
09:30:55 <dmwit> You can make a new identical class with different instances, though.
09:31:21 <bitraten> :/ There is no such thing as NoImplicitPrelude for GHC.Base?
09:32:10 <dmwit> It wouldn't help much, really.
09:32:32 <dmwit> Anything anywhere in your tool that imported GHC.Base would put those instances in scope for the whole application.
09:32:42 <dmwit> You want subtle bugs, that's how you get subtle bugs.
09:33:05 <dmwit> And if you're not importing GHC.Base anywhere in your whole app, well, then there's no cost to making a second class with different instances. ;-)
09:33:25 <bitraten> I am not exactly coding a tool, just following the Exercises in Typeclassopedia.
09:34:50 <dmwit> Right. Making class Functor' where fmap' :: (a -> b) -> f a -> f b (or whatever) is strongly recommended.
09:35:10 <dmwit> It just cuts out a whole class of headaches you don't want to worry about during an exploratory exercise.
09:35:26 <bitraten> Ah, thanks!
09:35:58 <dmwit> (That's what the original suggestion to "make a new identical class with different instances" meant, by the way.)
09:36:42 <Javran> seems like Foldable instance of Data.Tree is doing a preorder traversal, it is also possible to make it do inorder or postorder traversal right?
09:37:19 <dmwit> I'm not sure inorder makes sense.
09:37:31 <dmwit> Postorder should be no problem; can probably just do it by choosing an appropriate monoid.
09:37:58 <Javran> and if the monoid is commutative, it actually doesn't matter how you do traversal
09:40:01 <Javran> I want to do something like data TraversalOrder = Preorder | Postorder, and make instances like "instance Foldable (TreeTraversal TraversalOrder Tree) where", wondering if there's a better way?
09:40:24 <Javran> dmwit: yeah I guess inorder only make sense for binary trees.
09:46:42 <ThreeOfEight> Javran: that shouldn't be a big problem
09:58:07 <clrnd> mmm is there a game that runs on GIMP?
09:58:34 <vanila> GIMP image editor?
09:58:50 <vanila> you could play knots and crosses or that one where you make lines
09:59:08 <ThreeOfEight> Javran: http://lpaste.net/114638
09:59:10 <ThreeOfEight> you mean like this?
09:59:48 <ThreeOfEight> or did you want to use the Tree from the library?
09:59:55 <clrnd> yeah, since you can write plugins in python ... maybe someone had already programmed a simple game
09:59:57 <ThreeOfEight> in that case, I'm not sure if that's possible
10:04:20 <Javran> ThreeOfEight: that looks good! thanks.
10:07:16 <wei2912> how do i implement the Num typeclass?
10:07:33 <johnw> the docs for Num should tell you what you need to implement at a minimum
10:07:41 <johnw> instance Num Foo where ...
10:07:47 <wei2912> thanks
10:08:01 <wei2912> http://hackage.haskell.org/package/base-4.7.0.1/docs/GHC-Num.html - :P
10:08:21 <wei2912> well
10:09:18 <clrnd> wei2912, http://hackage.haskell.org/package/base-4.7.0.1/docs/Prelude.html#g:7
10:09:19 <clrnd> lol
10:10:37 <wei2912> clrnd: thanks
10:10:46 <clrnd> did you get there using google?
10:11:30 <merijn> Also, unless your linux distro screwed up you should have local docs for base
10:13:27 <kttm> hi, what is the typeclass for errors/exceptions that contain a String message ?
10:14:18 * hackagebot diagrams-builder 0.6.0.2 - hint-based build service for the diagrams graphics EDSL.  http://hackage.haskell.org/package/diagrams-builder-0.6.0.2 (bergey)
10:16:58 <robstewartuk> hi folks. Is the a standard practise for including/excluding data for unit tests in a cabalised project? I've got 6Mb of test data that I'm not sure should be included when `cabal install` is used to download from hackage.
10:17:13 <robstewartuk> But, I do want the data there is a user wants to `cabal test`.
10:17:37 <wei2912> MY SCHEME INTERPRETER FINALLY WORKS
10:17:39 <wei2912> well, part of it
10:17:42 <robstewartuk> I've seen other libraries separated, e.g. foo for the library foo, and foo-tests for just the unit tests and data.
10:17:44 <wei2912> time to go to sleep
10:17:56 <dispersed> haskell to create a scheme interpreter ?
10:17:58 <wei2912> thanks for your help to everyone who helped
10:18:10 <vanila> wei2912, well done!!
10:18:28 <dispersed> that's fkd up but I guess it's a good project for haskell, to get around the limitations of haskell itself
10:18:59 <dispersed> haskell with an extension language
10:19:17 <dispersed> sounds pretty powerful actually
10:19:19 * hackagebot diagrams-haddock 0.2.2.12 - Preprocessor for embedding diagrams in Haddock documentation  http://hackage.haskell.org/package/diagrams-haddock-0.2.2.12 (bergey)
10:19:47 <Hijiri> I thought writing a scheme interpreter was a common exercise, not actually used for doing other things
10:20:05 <dispersed> usually you write it in scheme.
10:20:16 <dispersed> and call it metacyclic
10:20:27 <vanila> to write a haskell interpreter in haskell would be hard because of type checking
10:20:30 <Hijiri> well I mean, you wouldn't write scheme in haskell to get more functionality out of haskell
10:20:50 <vanila> its an easier project for beginners
10:20:56 <merijn> vanila: It wouldn't be so hard, but substantially harder than Scheme, yes
10:21:34 <merijn> dispersed: It doesn't "get around the limitations of haskell", it's just that Scheme is really simple to implement as a toy
10:21:35 <dispersed> Hijiri: how would you instead embed an interpreter in haskell
10:21:52 <Hijiri> embed what kind of interpreter?
10:21:53 <Fuuzetsu> dispersed: you forgot ‘and be high and mighty about it even though it's as useless as the source language’
10:21:56 <merijn> Although those remarks all sound like trolling anyway, so I'm back to work
10:22:12 <Hijiri> haskell is popular for writing interpreters and compilers in general
10:22:19 <merijn> Fuuzetsu: Don't feed the bridge dwellers :)
10:22:28 * Fuuzetsu also goes back to doing stuff
10:22:31 <Fuuzetsu> deadlines deadlines ;(
10:22:44 <Hijiri> that's usually done directly in haskell
10:22:52 <merijn> Fuuzetsu: Word!
10:23:23 <dispersed> I guess I am coming from a different field of computing than you guys
10:23:36 <dispersed> since I have used many languages where you have a core language and a scripting language, separately
10:23:41 <vanila> dispersed, don't worry about it, some people  are just rude here
10:23:52 <dispersed> I mean in many projects you combine two languages
10:24:02 <vanila> I used that technique a bunch too
10:24:19 * hackagebot creatur 5.9.0 - Framework for artificial life experiments.  http://hackage.haskell.org/package/creatur-5.9.0 (AmyDeBuitleir)
10:24:25 <vanila> when you need rapid development with scripting but have to speed up certain parts by implementing them lower level
10:24:39 <dispersed> yeah, and it works, and haskell sounds like an ideal core language, if it's fast enough (that part I don't know)
10:24:40 <vanila> its very powerful
10:24:51 <vanila> but haskell is high level enough that you wont benefit doing this, probably
10:24:52 <dispersed> in the sense that the core should be devoid of bugs
10:25:12 <vanila> or another way to do look at it: That is what you normally do in haskell (with monads and similar)
10:25:23 <Hijiri> all software should be devoid of bugs
10:25:24 <vanila> so you have a much easier time adding a new language than you would in C
10:25:55 <dispersed> Hijiri: not true, .. bugs are relative
10:25:59 <dispersed> some of them could be features
10:26:09 <merijn> vanila: Oh, I agree that scripting languages for a lower level layer can be nice design (I think WoW's UI was one of the most impressive real world examples I've seen)
10:26:14 <Hijiri> well it's not really a bug in that case
10:26:26 <dispersed> Hijiri: yeah but if you prototype rapidly, you will not know, necessarily
10:26:38 <Hijiri> sure, but ideally software wouldn't have bugs
10:26:46 <dispersed> well that is just a pointless remark
10:26:54 <dispersed> who is the troll here
10:26:56 <merijn> vanila: It's just that claiming that a scheme interpreter "avoids haskell's limitations" triggers the "smug lisp-weenie trolling" threshold :)
10:27:01 <Hijiri> then so is the remark that the core should be devoid of bugs
10:27:03 <EvanR> rapid prototyping, havent heard that one in a while
10:27:07 <dispersed> Hijiri: fuck you
10:27:15 <dispersed> Hijiri: go fuck yourself for real
10:27:24 <dispersed> you are as stupid as a fucking brick up your anus
10:27:25 <Hijiri> I do it every day
10:27:28 --- mode: ChanServ set +o johnw
10:27:28 --- mode: johnw set +b *!~deph@virtual80.tentacle.fi
10:27:28 --- kick: dispersed was kicked by johnw (Rudeness)
10:27:28 --- mode: johnw set -o johnw
10:27:43 <JonReed> Hi. What are my options if I want to add databinding to state in haskell. So, let's say I have data Person = Person { _name :: String }. And "name" has to be databinded to some external source. Can lens do something like that? So that each time I do "name = "changed"" it does IO and updates some external source.
10:28:51 <Fuuzetsu> no such thing
10:29:06 <JonReed> It's depressing
10:29:37 <Fuuzetsu> the sole idea of such a monstrosity is depressing
10:29:38 <EvanR> that sounds hard to debug
10:30:10 <EvanR> and test
10:30:23 <Fuuzetsu> and do anything with
10:31:47 <JonReed> Databinding is great IMO. Just look at e.g. Firebase, where you can write in a few moments a functional app, where controller's state is in sync with database and is in sync with the view
10:32:13 <JonReed> "functional" not in the sense of functional programming, a better word choice would be "working" app
10:32:14 <EvanR> JonReed: you can use unsafePerformIO to cause IO during the evaluation of expressions
10:32:32 <zomg> JonReed: you could look into functional reactive programming, you can achieve similar results with it
10:32:35 <Fuuzetsu> it'll be as safe as your Firebase ‘app’
10:33:00 <Fuuzetsu> EvanR: it still won't do what he wants most of the time anyway
10:33:03 <zomg> and this is how you help them, not by bashing their idea
10:33:04 <zomg> :p
10:33:07 <Fuuzetsu> and it certainly won't be with name = "foo" syntax
10:33:21 <EvanR> no, it would be like name .= "foo" ;)
10:34:09 <Fuuzetsu> it'll still be 99% bugs
10:35:47 <EvanR> JonReed: you can look into the various haskell web frameworks and see how they do it
10:36:13 <juri_> implicitcad is making me really hate haskell.
10:42:34 <vanila> Fuuzetsu, http://comonad.com/reader/2014/letter-to-a-young-haskell-enthusiast/
10:42:39 <seangrove> Data.Text.Read.decimal "99 bottles" => Right (99," bottles") - how do I get the 99 out of there?
10:43:37 <EvanR> seangrove: you need to handle the Either, with pattern matching or the function either
10:43:53 <clrnd> > let (Right (x, _)) = Right (99, "Lol") in x
10:43:54 <lambdabot>  99
10:43:59 <dark321> @pl remslash (x:xs) = x:	filter(/="") xs
10:43:59 <lambdabot> remslash = ap ((. filter ([] /=)) . (:) . head) tail
10:44:06 <seangrove> EvanR: Ah, ok, thank you
10:44:06 <dark321> ok no
10:44:23 <EvanR> > let (Right (x, _)) = Left "yo ho!" in x
10:44:24 <lambdabot>  *Exception: <interactive>:3:5-34: Irrefutable pattern failed for pattern (Da...
10:44:29 <dark321> @pl (\x -> fst x==k)
10:44:29 <lambdabot> (k ==) . fst
10:44:43 <clrnd> hey I didn't imply it was right :P
10:44:52 <seangrove> Hehe
10:45:00 <seangrove> Thanks for that, makes some sense now
10:45:46 <EvanR> :t either
10:45:47 <lambdabot> (a -> c) -> (b -> c) -> Either a b -> c
10:47:05 <EvanR> > either show (const "balls") (Right 99)
10:47:06 <lambdabot>  "balls"
10:47:14 <EvanR> > either show (const "balls") (Left 99)
10:47:15 <lambdabot>  "99"
10:47:30 <EvanR> i guess left goes first
10:47:44 <clrnd> seeing how Optional/Maybe is just now getting to pop languages makes me sad ... how long will it take till Either is pop?
10:48:01 <EvanR> if Either gets pop without ADT being pop, ill be sad
10:48:04 <jeltsch> "balls" → "balloons"
10:48:28 <benzrf> balloons pop
10:48:52 <EvanR> > nub "balloons pop"
10:48:53 <lambdabot>  "balons p"
10:49:06 <jeltsch> clrnd: What would it mean that Either is pop?
10:49:59 <clrnd> if swift had Either in their stdlib :P
10:50:28 <EvanR> swifts enum types might work
10:50:35 <EvanR> "enums with components"
10:51:17 <EvanR> but they only have short circuit syntax for "optional" which is basic Maybe
10:51:24 <EvanR> nillable
10:51:28 <clrnd> Rust too
10:52:00 <clrnd> lol
10:52:00 <clrnd> https://github.com/rust-lang/rust/issues/9157
10:53:14 <EvanR> i cant think of where using Either is preferrale to defining a more informative type
10:53:19 <bjz> We use Result in for most eithery things. It never really got much use :)
10:53:57 <clrnd> I use Either a lot ... data MyType = Either SomeError Magic
10:54:01 <clrnd> EitherT actually
10:54:02 <bjz> ie. data Result a e = Ok a | Err e
10:54:04 <EvanR> if Left is assumed to be an exceptional or failure case, theres not much more informative than that.
10:54:14 <clrnd> well it's a convention ...
10:54:20 <bjz> yeah
10:54:32 <bjz> no probalem with that
10:54:46 <EvanR> another reason to use a standard version of this is for the library support so you dont have to implement all the utilities for it again
10:54:53 <clrnd> exactly
10:55:09 <EvanR> though if its just an enum, there might be the issue of "i cant think of any utilities for it"
10:56:24 <EvanR> clrnd: this issue seems uncomfortably familiar to the evolution of ruby the language, which renamed essentially the same concepts, just to be different
10:56:47 <clrnd> EvanR, I'm not familiar with ruby, what do you mean?
10:57:23 <mauris_> "cabal.exe: does not exist" this sounds, uh, fatal
10:57:23 <EvanR> newer languages tend to rename their constructs relative to currently existing, identically behaving features of other languages
10:57:49 <clrnd> you mean for propaganda ...
10:57:52 <mauris_> i had haskell platform 2013.2.0.0 installed, uninstalled it, installed 2014.2.0.0, now i get this. this is on both windows and cygwin
10:57:55 <EvanR> i dont know why
10:58:12 <EvanR> personal entertainment on the part of the designer
10:58:42 <merijn> EvanR: Either is preferable when you expect to integrate with, for example, ExceptT
10:59:05 <merijn> I hate having to manually rewrap some annoying libraries "custom" error type into Either
10:59:07 <mauris> (is there some more specific place to ask cabal questions?)
10:59:27 <EvanR> merijn: yes, its good to have a standard such type, in haskell its Either
10:59:32 <bjz> merijn: are there any other use cases for Either than error handling?
10:59:45 <merijn> bjz: Sure, disjunct collections
10:59:52 <merijn> [Either Int String]
11:00:25 <EvanR> in this case they may complain and want "a more descriptive type"
11:00:26 <clrnd> mauris, not that I know of. I'm not familiar with haskell on windows, but I'd suggest checking your $PATH
11:00:39 <EvanR> isomorphic to Either
11:00:41 <merijn> EvanR: The descriptiveness should come from left
11:00:51 <merijn> EvanR: i.e. "Either DescriptiveError a"
11:01:18 <EvanR> good point
11:01:36 <EvanR> replacing Either with Error a | Ok b would then be redundant
11:01:44 <merijn> In other words, I disagree with your earlier claim that "i cant think of where using Either is preferrale to defining a more informative type"
11:01:57 <EvanR> that wasnt my claim sorry that was a quote from the github issue
11:02:03 <bjz> merijn: strikes me as something where structural unions would be nicer
11:02:03 <merijn> Ah
11:02:23 <EvanR> "Remove std::either #9157"
11:02:25 <EvanR> closed
11:02:27 <merijn> bjz: Oh, I'd love to have structural subtyping/row typed records, etc.
11:03:03 <bjz> merijn: I get the point though - I just think that is still seems like an awkward use case
11:03:37 <merijn> bjz: I use it for that occasionally, but I agree it's not as nice as proper row types or something like that would be :)
11:04:14 <bjz> merijn: I mean, I quess it would be useful for quickly putting something together - rather than making a new sum type all the time
11:06:29 <droidboi> I am trying this tutorial https://byorgey.wordpress.com/2010/06/29/typed-type-level-programming-in-haskell-part-i-functional-dependencies/
11:07:25 <droidboi> A tutorial on type-level programming
11:08:25 <droidboi> class Plus m n r
11:08:26 <droidboi>   instance Plus Z n n
11:08:26 <droidboi>   instance (Plus m n r) => Plus (S m) n (S r)
11:08:59 <droidboi> I get
11:08:59 <droidboi> Prelude> :l mptc
11:08:59 <droidboi> [1 of 1] Compiling Main             ( mptc.hs, interpreted )
11:08:59 <droidboi> mptc.hs:12:3: parse error on input `instance'
11:08:59 <droidboi> Failed, modules loaded: none.
11:09:16 <mpbl> @help
11:09:16 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
11:09:24 <droidboi> Can anyone help me
11:09:38 <mpbl> @type map
11:09:39 <lambdabot> (a -> b) -> [a] -> [b]
11:09:42 <clrnd> droidboi, ehm, did you enable the extensions the article mentions, right?
11:10:05 <droidboi> clrnd: No
11:10:21 <mpbl> @pl \f g x y -> f (x ++ g x) (g y)
11:10:21 <lambdabot> join . ((flip . ((.) .)) .) . (. ap (++)) . (.)
11:10:43 <clrnd> droidboi, you need to, use `:set -XExtension`
11:11:12 <clrnd> or https://downloads.haskell.org/~ghc/7.2.2/docs/html/users_guide/pragmas.html
11:11:43 <droidboi> Some flags have not been recognized: -XExtension
11:11:56 <droidboi> :o(
11:12:04 <clrnd> no, with the extensions the article mention, :set -XMultiParamTypeClasses, etc
11:12:32 <droidboi> what is "article"?
11:12:57 <clrnd> droidboi, the blog post, tutorial you linked
11:13:05 <droidboi> ok
11:13:07 <droidboi> sorry
11:13:19 <clrnd> droidboi, no problem, what's your first language?
11:13:31 <droidboi> lisp
11:15:37 <osa1> recently there was a pretty printer library announcement at /r/haskell but I can
11:15:48 <osa1> can't find it now, does anyone here have a link to that?
11:16:15 <droidboi> Prelude> :set -XMultiParamTypeClasses
11:16:17 <droidboi> Prelude> :l mptc
11:16:17 <droidboi> [1 of 1] Compiling Main             ( mptc.hs, interpreted )
11:16:17 <droidboi> mptc.hs:12:3: parse error on input `instance'
11:16:22 <droidboi> still no luck
11:16:38 <indiagreen> osa1: http://www.cse.chalmers.se/~bernardy/prettiest.html
11:16:52 <clrnd> droidboi, try enabling FlexibleInstances, EmptyDataDecls and UndecidableInstances
11:17:12 <clrnd> one by one, with the same command
11:17:24 <droidboi> ok - one sec
11:17:38 <merijn> lpaste your code
11:17:54 <droidboi> clrnd ok
11:18:02 <osa1> indiagreen: that's it, thanks
11:21:35 <droidboi> Prelude> :set FlexibleInstances
11:21:36 <droidboi> Some flags have not been recognized: FlexibleInstances
11:21:36 <droidboi> Prelude> :set EmptyDataDecls
11:21:36 <droidboi> Some flags have not been recognized: EmptyDataDecls
11:21:36 <droidboi> Prelude> :set UndecidableInstances
11:21:36 <droidboi> Some flags have not been recognized: UndecidableInstances
11:21:37 <droidboi> Prelude> :l mptc
11:21:39 <droidboi> [1 of 1] Compiling Main             ( mptc.hs, interpreted )
11:21:41 <droidboi> mptc.hs:12:3: parse error on input `instance'
11:21:43 <droidboi> Failed, modules loaded: none.
11:21:45 <droidboi> no luck
11:21:53 <clrnd> droidboi, the format is :set -XnameOfExtension
11:21:57 <clrnd> so it would be:
11:22:01 <clrnd> :set -XFlexibleInstances
11:22:08 <clrnd> :set -XEmptyDataDecls
11:22:12 <droidboi> ok
11:22:14 <clrnd> :set -XUndecidableInstances
11:22:15 <clrnd> etc
11:22:22 <droidboi> my bad
11:25:07 <droidboi> Prelude> :set -XFlexibleInstances
11:25:08 <droidboi> Prelude> :set -XUndecidableInstances
11:25:08 <droidboi> Prelude> :set -XEmptyDataDecls
11:25:08 <droidboi> Prelude> :l mptc
11:25:08 <droidboi> [1 of 1] Compiling Main             ( mptc.hs, interpreted )
11:25:10 <droidboi> mptc.hs:12:3: parse error on input `instance'
11:25:10 <droidboi> Failed, modules loaded: none.
11:25:12 <droidboi> Prelude> :set -XMultiParamTypeClasses
11:25:15 <droidboi> Prelude> :l mptc
11:25:16 <droidboi> [1 of 1] Compiling Main             ( mptc.hs, interpreted )
11:25:18 <droidboi> mptc.hs:12:3: parse error on input `instance'
11:25:20 <droidboi> Failed, modules loaded: none.
11:25:22 <droidboi> Prelude>
11:25:22 <dark321> whats going on
11:25:42 <droidboi> I'm struggling
11:26:36 <alrunner4> @where lpaste
11:26:36 <lambdabot> http://lpaste.net/
11:26:53 <benzrf> is there like
11:27:00 <benzrf> something like `when' but for maybe-values
11:27:35 <clrnd> benzrf, when . isJust :P
11:27:40 <benzrf> eesh
11:27:43 <benzrf> i feel dirty using isJust
11:27:54 <benzrf> :t when . isJust
11:27:55 <lambdabot> Monad m => Maybe a -> m () -> m ()
11:27:59 <angerman> how can I tell cabal that I want a flag to be set on a dependency?
11:28:38 <droidboi> My file
11:28:41 <droidboi> http://lpaste.net/114640
11:28:51 <benzrf> @src when
11:28:51 <lambdabot> when p s = if p then s else return ()
11:28:55 <benzrf> thought so
11:29:17 <merijn> angerman: You can't
11:29:17 <benzrf> :t when
11:29:18 <lambdabot> Monad m => Bool -> m () -> m ()
11:29:20 <benzrf> oh
11:29:21 <dcoutts_> angerman: when building you can specify via command line flags or local config file. However authors (deliberately) cannot specify within a .cabal file.
11:29:40 <clrnd> droidboi, ohhhh, you need to remove the indentation
11:29:45 <merijn> angerman: Your package interface is not allowed to depend on a flag
11:29:47 <clrnd> class Plus
11:29:51 <clrnd> instance Plus
11:29:53 <angerman> dcoutts_, hmm. ok.
11:30:06 <mauris> what's a string-like datatype with very fast "snoc"?
11:30:07 <alrunner4> droidboi: don't indent those instances
11:30:12 <angerman> merijn: so if i want to say disable th on a package I can't do that. :-/
11:30:14 <mauris> apparently Data.ByteString's is also O(n)?
11:30:15 <droidboi> ok
11:30:18 <dcoutts_> angerman: packages are not allowed to change their API based on flags
11:30:50 <dcoutts_> angerman: this restriction means we can translate cabal packages into binary distro packages, which on balance seems to be more important
11:31:07 <angerman> dcoutts_: right.
11:31:21 <droidboi> can you please just remind me how to apply those flags on the command line
11:31:36 <droidboi> is it -D something
11:31:41 <clrnd> droidboi, ofc, it's :set -XSomething
11:31:46 <merijn> mauris: You might want a DList?
11:32:16 <clrnd> droidboi, you can also write on the top of your file {-# LANGUAGE ExtensionName, AnotherExtension -#}
11:32:22 <clrnd> and it will persist
11:32:37 <merijn> mauris: ByteString is O(n) since snoc requires you to copy the entire ByteString
11:32:54 <merijn> mauris: The DList approach should work for any list-like type for efficient append
11:33:03 <merijn> (I'm assuming efficient append is the goal)
11:34:16 <mauris> i'm actually receiving chars one at a time and snoc'ing them onto a TVar Something
11:34:21 <mauris> now to find a fitting Something!
11:35:49 <merijn> mauris: http://h2.jaguarpaw.co.uk/posts/demystifying-dlist/
11:38:08 <mauris> merijn: hmm, i don't need to display the string nearly as often as i receive chars... would it be sane to just use a String and (:) and then reverse the string when i need it?
11:38:18 <merijn> mauris: Sure
11:39:21 <merijn> mauris: That's actually a common way to represent queues in haskell "data Queue a = Queue [a] [a]" you pop elements from the first list and add elements to the front of the second list. If the first list is empty, reverse the second and use it as the new first list
11:39:25 <merijn> amortised O(1)
11:41:30 <clrnd> droidboi, could you make it work?
11:41:50 <droidboi> andre@andre-mint17-64 ~/haskell $ cat mptc.hs
11:41:51 <droidboi> {-# LANGUAGE FlexibleInstances, UndecidableInstances, EmptyDataDecls,
11:41:51 <droidboi> MultiParamTypeClasses -}
11:41:51 <droidboi> data Z
11:41:51 <droidboi> data S n
11:41:51 <droidboi> class Plus m n r
11:41:52 <droidboi> instance Plus Z n n
11:41:54 <droidboi> instance (Plus m n r) => Plus (S m) n (S r)
11:41:56 <droidboi> andre@andre-mint17-64 ~/haskell $ ghci mptc.hs
11:41:58 <droidboi> GHCi, version 7.6.3: http://www.haskell.org/ghc/  :? for help
11:42:00 <droidboi> Loading package ghc-prim ... linking ... done.
11:42:03 <droidboi> Loading package integer-gmp ... linking ... done.
11:42:07 <droidboi> Loading package base ... linking ... done.
11:42:08 <droidboi> mptc.hs:2:1:
11:42:10 <droidboi>     Cannot parse LANGUAGE pragma
11:42:12 <droidboi>     Expecting comma-separated list of language options,
11:42:14 <droidboi>     each starting with a capital letter
11:42:16 <droidboi>       E.g. {-# LANGUAGE RecordPuns, Generics #-}
11:42:17 <clrnd> mmm droidboi use lpaste for this, so we don't bother the other in the channel
11:42:18 <droidboi> Failed, modules loaded: none.
11:42:20 <droidboi> Prelude>
11:42:22 <droidboi> No
11:42:46 <droidboi> I am sorry. What is lpaste?
11:43:00 <simpson> droidboi: lpaste.net
11:43:03 <clrnd> @where lpaste
11:43:03 <lambdabot> http://lpaste.net/
11:43:09 <simpson> Also you didn't close your pragma correctly.
11:43:10 <droidboi> ok
11:43:33 <droidboi> I will use that in future
11:43:37 <clrnd> droidboi, replace -} with -#}
11:43:44 <droidboi> ok
11:44:48 <simpson> Well, #-} right?
11:45:05 <clrnd> droidboi, ^ that, my bad
11:45:23 <droidboi> clrnd - your bad
11:45:41 <droidboi> Ok, modules loaded: Main.
11:45:43 <droidboi> :o)
11:45:46 <clrnd> :D
11:46:07 <droidboi> where was I in all this?
11:46:10 <lpaste> mauris pasted “ugly loop” at http://lpaste.net/114643
11:46:23 <mauris> ^ is there anything obvious i can do to make this nicer?
11:46:52 <mauris> i've tried rewriting the outer loop with "fix" but if i do that i can't seem to get the indentation right for the "where" on line 11
11:47:03 <droidboi> Oh yeah - learning type-level programming
11:47:54 <droidboi> clrnd: Your a treasure. Thanks
11:48:03 <clrnd> no problem
11:48:14 <clrnd> glad I could help
11:48:20 <droidboi> Your = You're of course
12:02:10 <droidboi> clrnd: What is a good site for learning Haskell type-level programming in your opinion?
12:03:16 <clrnd> droidboi, mmm sorry I have no idea, I've never got interested on the subject really
12:04:13 <clrnd> I guess this article is nice thogh: https://www.haskell.org/haskellwiki/Type_arithmetic
12:05:10 <droidboi> Is there not much call for type-level programming
12:05:28 <clrnd> droidboi, I even suppose Idris may be more suitable for this, or Agda
12:05:49 <droidboi> Or Coq
12:06:00 <droidboi> All this is new to me
12:06:18 <clrnd> me too
12:06:25 <droidboi> Maybe there is no real need for it
12:06:31 <droidboi> Just academic
12:07:17 <clrnd> I'm pretty sure some things require compter assisted proofs, like microprocessor design ...
12:07:30 <clrnd> I may be talking bollocks of course
12:08:16 <Fuuzetsu> I don't suppose there's some Really Clever Way™ to have dependent pairs easily?
12:08:19 <droidboi> It was suggested to me to learn "shapeless".
12:08:22 <LeCamarade> Hello, guys. Is there are channel for Yesod?
12:08:35 <seangrove> In my main function, I'm trying to take in a string via getLine like "1,2", then parse out [x,y] = map (\c -> read c :: Int) (Data.Text.splitOn (T.pack ",") (T.pack "1,2"))
12:08:48 <droidboi> Should I learn "shapeless"?
12:08:54 <seangrove> Obviously this has a ton of problems with types, with IO() infecting everything
12:09:01 <Fuuzetsu> LeCamarade: #yesod
12:09:12 <LeCamarade> Or, on the other hand, how does one pull a HTTP header? I am having trouble finding any guides in the online Yesod book.
12:09:19 <LeCamarade> Fuuzetsu: Thanks.
12:09:34 <seangrove> Everything else in the program is pure, etc. I'm trying to figure out how to extract the values from a string input at the top level, and pass that to the rest of the program
12:10:01 <Fuuzetsu> seangrove: Reader monad
12:11:00 <seangrove> Fuuzetsu: Am I going to need to use LiftM to get the monadic values into non-monadic functions?
12:11:06 <Fuuzetsu> clrnd: microprocessor stuff actually is the leading use of *automated* theorem proving as far as I know
12:11:20 <droidboi> clrnd: I am a noob. Should I learn shapeless?
12:11:22 <Fuuzetsu> seangrove: liftM is just fmap
12:11:28 <Fuuzetsu> not sure what it has to do here
12:11:58 <clrnd> Fuuzetsu, what do you mean with the emphasis in "automated"?
12:12:00 <droidboi> clrnd: Perhaps you can recommend something to learn
12:12:09 <seangrove> Fuuzetsu: Neither am I, trying to put it together, sorry for the silly question
12:12:14 <droidboi> like scalaz
12:12:18 <Fuuzetsu> clrnd: by that I mean not Agda/Coq/whatever
12:12:20 <clrnd> droidboi, what do you want to accomplish?
12:12:39 <droidboi> I am a student.
12:12:40 <Fuuzetsu> seangrove: can you lpaste what you have and say what you'd like to change?
12:12:57 <droidboi> clrnd: I am not sure what to learn
12:13:01 <Fuuzetsu> seangrove: if your functions all look like ‘String -> a’ then Reader is what you want
12:13:41 <clrnd> droidboi, what do you study?
12:13:50 <S11001001> droidboi: I'm afraid unless you understand the underlying type-level functions really well than the encoding of shapeless will confuse you more than help.
12:14:00 <S11001001> s,than,then,
12:14:28 <droidboi> what do I need to learn to understand shapeless?
12:14:58 <droidboi> any webistes? tutorials
12:15:18 <sivteck> droidboi, what's shapeless?
12:15:32 <clrnd> it's like type-level programming in scala
12:15:36 <sivteck> ah
12:15:44 <sivteck> droidboi, #scala , #scalaz
12:15:48 <sivteck> go there ^
12:16:29 <S11001001> droidboi: #shapeless
12:16:36 <lpaste> alrunner4 annotated “ugly loop” with “ugly loop (annotation)” at http://lpaste.net/114643#a114644
12:17:17 <droidboi> My bad. I got into Scala. But I hate it
12:17:30 <droidboi> I'm into Haskell
12:17:52 <clrnd> lol
12:18:09 <droidboi> I'd like to learn real programming
12:18:50 <bennofs> >real< programmers use C ;)
12:19:12 <droidboi> do they indeed
12:19:46 <droidboi> I want to learn type-level programming
12:19:50 <dark321> are we gonna do the whole realprogrammer debate
12:19:57 <droidboi> how hard can it be
12:20:05 <dark321> there is a xkcd comic for that
12:20:19 <bitemyapp> seangrove: not a silly question.
12:20:20 <droidboi> its just like programming, but with types - right?
12:20:32 <bitemyapp> seangrove: can you put your code on http://lpaste.net/ for me?
12:20:35 <clrnd> droidboi, I'm guessing you'd need a couple of algebra courses first :P
12:20:44 <dark321> https://xkcd.com/378/
12:20:47 <dark321> that one
12:21:20 <vanila> droidboi, what do you want to use type level programming for?
12:21:22 <clrnd> lol
12:21:57 <Fuuzetsu> real programmers come into #haskell and say something is impossible then copy+paste the result into their file five minutes later
12:22:25 <simpson> Ugh, I'm stuck on this stupid problem. I'm supposed to figure out whether a program halts or not.
12:22:31 <clrnd> bold claim :P
12:22:34 <simpson> I think it might be imposibble. :T
12:22:34 <droidboi> vanila: Why would you not use it?
12:22:36 <vanila> simpson, post the program?
12:22:46 <simpson> vanila: It could be any program! That's the problem.
12:22:58 <mauke> @quote mauke halting
12:22:58 <lambdabot> No quotes match.
12:23:00 <vanila> simpson, this seems like a bad attempt at a joke
12:23:10 <Fuuzetsu> no fun allowed
12:23:11 <mauke> simpson: every program halts.
12:23:12 <simpson> vanila: I'm just following Fuuzetsu's lead.
12:23:20 <vanila> oh I have him on ignore so I missed whatever he said
12:23:30 <simpson> vanila: Oh. Consider not ignoring people.
12:23:32 <vanila> he seems to encourage rudeness and stupidity
12:23:39 <Fuuzetsu> ;^)
12:23:50 <vanila> simpson, see what happened earlier
12:23:56 <clrnd> it's easy: case mayHalt of { Just Halted -> something ; Nothing -> somethingElse }
12:24:31 <simpson> vanila: Oh. Then you should probably /ignore me too. And most of the people in most channels, really.
12:24:38 <clrnd> vanila, that's a rude statement
12:24:42 <droidboi> vanila: Do you know much about type-level programming?
12:24:48 <vanila> droidboi, yes
12:25:03 <droidboi> so why do you ask
12:25:14 <vanila> droidboi, I thought i could help you if you were stuck
12:25:14 <bennofs> droidboi: I feel like Coq can help to understand all these type-level stuff better, and it has the best learning materials available IMO (just learning coq myself)
12:25:32 <Fuuzetsu> I'd say learn Agda instead, it's much more like Haskell
12:25:33 <droidboi> I am a type-level noob
12:25:54 <vanila> It's so sad how low qualitty this channel is compared to a few years ago
12:25:54 <droidboi> I have no idea what it is for
12:25:56 <Fuuzetsu> read some Agda (or Coq) tutorials
12:26:01 <vanila> I wonder how it degraded so bad
12:26:10 <simpson> vanila: It didn't. You're just nostalgic.
12:26:14 <merijn> vanila: It's not that bad
12:26:23 <clrnd> :|
12:26:23 <bennofs> Fuuzetsu: yeah, but I felt like Adga doesn't have so many good materials on stuff like structural induction etc.
12:26:24 <merijn> Although there's some peaks in rudeness occasionally
12:26:44 <jeltsch> vanila: In what ways did the channel degrade?
12:26:49 <bennofs> At least I never really understood it until learning Coq
12:26:54 <Fuuzetsu> bennofs: it never will if everyone keeps going to Coq ;P
12:26:59 <merijn> Quality has actually gone up, wider availability is eliminating repetitive answering of simple things
12:27:29 <vanila> jeltsch,  the community was friendlier, less arrogant and people were able to share and learn knowledge better
12:28:01 <simpson> A few years ago I was chased off of this channel for not agreeing that dynamically-typed languages are bad.
12:28:07 <droidboi> does type-level programming have much practical use?
12:28:08 <Fuuzetsu> seems like bitching about #haskell should go into -blah if anywhere
12:28:10 <simpson> Things are better here than ever before. You're just nostalgic.
12:28:12 <zomg> vanila: way more users these days
12:28:27 <jeltsch> vanila: Hmm, I wonder what caused this increase in arrogance you are talking about. New generation of participants?
12:28:41 <Fuuzetsu> simpson: I don't think you'd get any better today with that statement ;)
12:28:42 <vanila> I guess so, but also probably bad influence from some of the ops
12:28:44 <merijn> I see lots of arrogance outside #haskell, not in #haskell
12:28:47 <clrnd> simpson, what did you say??! get out of here!
12:28:52 <S11001001> vanila: the friendly sharing version is now #nothaskell :)
12:29:09 <simpson> Fuuzetsu: Meh. I still think it's funny that it's possible for smart people to be bigots.
12:29:20 <Fuuzetsu> Justified bigotry!
12:29:30 <bitemyapp> #haskell-beginners has proven very friendly, but it's explicitly for learning/teaching.
12:29:41 <droidboi> as simple yes or no will do
12:29:44 <Fuuzetsu> Does anyone ask stuff in -beginners?
12:29:44 <dark321> does haskell beginners have the pointfree bot ?
12:29:48 <bitemyapp> I suspect that focus has helped keep people polite and on task.
12:29:51 <bitemyapp> dark321: yep.
12:29:51 <vanila> droidboi, it's not very useful in practice
12:29:53 <bitemyapp> Fuuzetsu: yep.
12:29:56 <merijn> droidboi: Yes, I'm using it a lot
12:29:59 <merijn> vanila: I disagree
12:30:06 <merijn> vanila: Very strongly, even
12:30:12 <Fuuzetsu> Strictly.
12:30:14 <vanila> dark321, lambdabot does it, try @pl <some code>
12:30:38 <merijn> bitemyapp: tbh, I don't see that much unfriendliness in here. At least not more than when I was first here
12:30:41 <dark321> vanila: ty
12:31:11 <dark321> yeah im not here very often but it seems pretty friendly here
12:31:28 <dark321> a lot friendlier than other IRC's Im in at least
12:31:29 <zomg> yeah honestly I've not seen many issues either
12:31:40 <bitemyapp> merijn: I don't either, but #haskell is really big, really noisy, and doesn't have a specific focus.
12:31:55 <droidboi> some people use type-level programming, some don't it seems
12:31:59 <bitemyapp> merijn: I started #haskell-beginners not because of unfriendliness, but because lessons kept getting interrupted. I'm not the only person to comment on this.
12:32:08 <bitemyapp> merijn: http://chrisdone.com/posts/teaching
12:32:15 <droidboi> seems fifty/fifty
12:32:18 <merijn> bitemyapp: Sure, I'm not saying there's no reason for a specific channel
12:32:24 <bitemyapp> Sure
12:32:51 <bitemyapp> I'd say it's not unfriendliness so much as unrefined manners here and there.
12:32:51 <merijn> I just don't like this "#haskell is becoming unfriendly" rhetoric. It's doing pretty well, just need to stay watchful
12:32:52 <Fuuzetsu> droidboi: It's useful, learn it. Don't let someone put you off from learning it because they don't think it's useful or they can't do it or whatever. At least give it a go and decide yourself.
12:33:05 <bitemyapp> that can rub new people feeling a bit sensitive about their struggle with a new programming language the wrong way.
12:33:18 <bitemyapp> we can do a better job of making them feel welcome and not like they're stupid.
12:33:37 <bennofs> droidboi: well, there's a lot in between "extensive use of programming at type-level" and "no programming at type-level."
12:33:44 <wyager> Hey guys. I am getting this error when I try to install msgpack using Cabal. If I don’t specify the current version, it succeeds but with an old shitty version. http://pastebin.com/78aHVgiZ
12:33:44 <bitemyapp> that doesn't, to my mind, mean #Haskell has a friendliness problem. It's not ##C
12:33:56 <merijn> droidboi: For what it's worth, I'm using type level programming to, for example, guarantee that my authentication handshakes are only run with the right configuration
12:34:01 <bitemyapp> anybody that thinks #haskell has a friendliness problem should try to learn C by asking questions in ##C
12:34:09 <bennofs> droidboi: TypeFamilies, which could be considered a form of type-level programming, are pretty widely used for example
12:34:15 <bitemyapp> should've been named ##MosEisley
12:34:29 <merijn> bitemyapp: Well, I think it's not so much friendliness as people making stupid tired old in jokes to newbies
12:34:50 <merijn> bitemyapp: i.e. "monads are just monoids in the category of endofunctors" and anything involving burritos needs to die
12:34:50 <bennofs> wyager: wgat GHC version is that?
12:34:52 <bitemyapp> I could do without that too.
12:34:55 <S11001001> droidboi: Recently, I've had some Scala code that I'm not confident is well-behaved, but it's so general that it's too hard to write tests or property checks to see if it's well-behaved, and intuition-defying that it's hard to just think through whether it's correct.  So I'm working on using type-level programming to prove that it always works.
12:34:58 <mauke> I think trying to learn any programming language by asking questions on IRC is incredibly rude
12:34:59 <eric__> Hi! i have a problem. I want to define a function with the class Num, but in the base case i want to use the zero of the tyoe (o for int, 0.0 for Float, etc..). How i can do it? This is my code: http://pastebin.com/PZmMfdKE
12:35:00 <bitemyapp> merijn: agreed
12:35:11 <wyager> bennofs: 7.8.3
12:35:16 <merijn> bitemyapp: I don't mind jokes, but they're NOT appropriate when the question asker is clearly new
12:35:17 <numberten> mauke: why?
12:35:34 <chrisdone> evening
12:35:36 <merijn> numberten: Because you're wasting people's time rather than reading a book
12:35:38 <mauke> eric__: 0 is polymorphic. it works for any Num type
12:35:52 <bennofs> mauke: as long as you don't use it as your only reference, just when you get stuck, I don't have a problem with it
12:36:02 <merijn> #haskell should not teach you haskell, it should help you sort out your confusion when you get stuck
12:36:03 <eric__> but the interpreter not think the same...
12:36:04 <numberten> maybe the person stumbled upon something they didn't think the book explained clearly?
12:36:08 <chrisdone> bitemyapp: that newbie haskell post was pre' cool, i liked it
12:36:09 <numberten> or need references for good books
12:36:10 <merijn> bennofs: I think that's mauke's point
12:36:17 <numberten> good learning material makes a huge difference when learning any new language
12:36:18 <merijn> numberten: Sure, but that's not what mauke refers too
12:36:26 <mauke> numberten: it doesn't have to be a book. there are online tutorials, videos, you can just brute force try things locally
12:36:29 <numberten> merijn: ah maybe I was missing context
12:36:53 <mauke> numberten: that's actually an excellent use of IRC
12:37:13 <mauke> "this book I'm reading says X, but I don't understand what it means"
12:37:14 <numberten> mauke: I thought you were referring to newbies asking questions
12:37:16 <bennofs> wyager: can you try cabal install --allow-newer ?
12:37:22 <bitemyapp> chrisdone: does lpaste have Emacs integration?
12:37:23 <merijn> numberten: It's not rare to see people asking about things that are very clearly explained in multiple tutorials and people indulging them, rewriting said tutoiral in the channel
12:37:24 <numberten> mauke: i agree that irc isn't the place to come in and expect to be taught a language
12:37:26 <eric__> mauke: the interpreter dont think the same of you
12:37:33 <bitemyapp> chrisdone: a la - https://github.com/Raynes/refheap.el
12:37:34 <mauke> or: "I tried this program based on X, but it doesn't work the way I expected. what's going on?"
12:37:44 <bitemyapp> chrisdone: argumatronic really liked your comments and ideas. They made her really excited.
12:37:46 <mauke> eric__: what's the error message?
12:37:47 <wyager> bennofs: “cabal: unrecognized option `--allow-newer’”
12:37:52 <bitemyapp> chrisdone: I'm serious about a tree of knowledge wiki.
12:37:56 <levi> eric__: The interpreter has some slightly different type-defaulting rules than the compiler. Numeric literals really *are* polymorphic, though.
12:38:09 <numberten> mauke: yeah we're on the same page, I just misunderstood what you meant :)
12:38:47 <merijn> bitemyapp: I agree with that chrisdone link, btw
12:38:59 <merijn> bitemyapp: I routinely tell people to shut up when explaining and more people should
12:39:17 <bennofs> wyager: ok, then can you cabal unpack msgpack, then edit the msgpack.cabal file in the newly created directory and remove the < 2.9 in the line where it says template-haskell, then cd into that directory and run cabal install?
12:39:24 * hackagebot betacode 0.1.0.0 - A codec for beta code (http://en.wikipedia.org/wiki/Beta_Code).  http://hackage.haskell.org/package/betacode-0.1.0.0 (EricRochester)
12:39:32 <eric__> my mistake, sorry... i forget pass a lambda function like parameter... the zero dont was the problem
12:39:33 <bitemyapp> merijn: well. Telling people to shut up might weaken your case that #haskell doesn't have a friendliness problem :)
12:39:41 <bitemyapp> merijn: easier to just flow around the problem, in my experience.
12:39:51 <bitemyapp> I don't want to argue with anybody or hurt anybody's feelings...just a quiet space to teach.
12:40:13 <chrisdone> bitemyapp: cool, glad they found it a positive idea. yeah, me too. tho obv. my focus is on the interactivity component
12:40:22 <chrisdone> bitemyapp: there is a simple lpaste function for emacs, sec
12:41:02 <bitemyapp> chrisdone: danke
12:41:22 <wyager> bennofs: How do I check where it put msgpack.cabal? It’s not in my .cabal directory
12:41:25 <merijn> bitemyapp: Well I don't say "shut up" :)
12:41:35 <levi> eric__: It's always helpful to share any errors you're getting rather than just the code; it helps the people who are helping you to recognize when you've misdiagnosed the problem.
12:41:37 <merijn> bitemyapp: I tell them to "please avoid spoilers, it's not helping" :)
12:41:39 <EvanR> > fix ("c a codec for betacode" ++)
12:41:40 <lambdabot>  "c a codec for betacodec a codec for betacodec a codec for betacodec a codec...
12:41:41 <bennofs> wyager: cabal unpack msgpack should create a new directory
12:41:47 <bitemyapp> merijn: yer :)
12:41:52 <bennofs> wyager: it's in that directory
12:41:57 <chrisdone> bitemyapp: ah, i only have this dumb curl-based one, if that helps: https://github.com/chrisdone/chrisdone-emacs/blob/master/packages/lpaste/lpaste.el select a region and paste it. i've been using it for a while, basically works
12:42:53 <bitemyapp> chrisdone: I'll keep it in mind, thank you.
12:43:02 <bennofs> wyager: btw, are you on windows, linux, mac, ... ?
12:43:29 <knyon> Is there a calendar math library? Hackage and Google aren't turning up anything useful.
12:43:42 <bennofs> wyager: ah, slight edit: you need to remove the '&&' too, ofc
12:43:44 <knyon> e.g. how many months are between this date and that date?
12:44:09 <wyager> bennofs: I’m on mac. OK, so I edited the dependencies. When I run “cabal install”, it tells me that “the following packages are likely to be broken by the reinstalls:” <a bunch of packages>. Should I force it?
12:44:26 <bennofs> wyager: paste the msg please
12:44:40 <wyager> I’m not sure why this should break anything… I don’t really understand how cabal does dependency isolation
12:44:42 <saep> wyager: I "fixed" some of the msgpack libraries this morning.
12:45:24 <marchelzo_> Does anyone know of a decent resource for learning how to pass structs back and forth with the FFI?
12:45:29 <bennofs> saep: oh, then do you know if it's just a restrictive upper bound on TH or does it actually fail to compile?
12:46:05 <saep> bennofs: I just removed the upper bounds and got rid of the errors. :S https://github.com/saep/msgpack-haskell
12:47:07 <bennofs> wyager: ah, you might want to install from that source then. Just git clone  https://github.com/saep/msgpack-haskell, cd to the checkout and run cabal install
12:47:37 <wyager> bennofs: Sorry, my internet went out. Did you get my last message? Cabal complains that following through with the install would break a bunch of stuff
12:47:59 <bennofs> wyager: yeah, it seems that saep fixed the issue in his github fork
12:48:08 <bennofs> "wyager: you might want to install from that source then. Just git clone  https://github.com/saep/msgpack-haskell, cd to the checkout and run cabal install"
12:48:43 <wyager> I see. Does it say anywhere what the problem was?
12:49:44 <bennofs> wyager: you can view the latest commit on the repository. Basically, the problem is that the package just hasn't been updated to work with the latest version of the libraries, and also not with ghc 7.8.3 (but saep's fork updates it)
12:49:52 <sinelaw> What's an efficient data structure for this? a set of sets, where an item can be in one or more of the sets. the operations are: find which sets an item belongs to, and add an item to a set,
12:49:53 <eric__> <levi>: yes, you are right, sorry
12:50:00 <eric__> levi: yes, you are right, sorry
12:50:42 <sinelaw> was thinking about a map item -> set of sets that this item belongs to
12:51:02 <sinelaw> when you add an item, you add it both to the given set and you also add the set to the item's map
12:51:15 <bennofs> sinelaw: Map a [Integer] ? (where the Integer is an ID for a set the item belongs to)
12:51:36 <sinelaw> bennofs, the item could belong to multiple sets
12:51:44 <sinelaw> but yeah, that's what I'm thinking
12:51:47 <bennofs> sinelaw: that's why there is a list of integers
12:51:50 <sinelaw> oh
12:51:57 <sinelaw> yeah, ok
12:52:27 <bennofs> so {{1,2},{1,3}} would be a map with 1 -> [0,1], 2 -> [0] and 3 -> [1]
12:52:32 <wyager> bennofs: Thanks. Looks like I also FUBAR’d all my Haskell packages while trying to get this working earlier. Have to figure out how to completely remove everything
12:53:10 <bennofs> wyager: you can remove all packages by removing ~/.ghc
12:53:19 <sinelaw> bennofs, yeah, looks like the natural choice. thanks.
12:55:41 <wyager> bennofs: It’s still borked. Cabal-install fails and tells me to run ghc-pkg check. That prints out a bunch of stuff like “cannot find any of [haddock files, dyn_hi files, etc.]” and stuff like “import-dirs: /Users/williamyager/.cabal/lib/x86_64-osx-ghc-7.8.3/SHA-1.6.4.1 doesn't exist or isn't a directory”. So somehow it thinks those things are still around even though I deleted all of .cabal and .ghc
12:56:34 <bennofs> wyager: can you paste `ghc-pkg list` please?
12:56:39 <saep> wyager: rm -rf ~/.cabal as well (you may want to keep changes you made in there by hand)
12:56:48 <wyager> Yes, I did that saep
12:57:48 <wyager> bennofs:  May have found the issue. A persistent homebrew install of ghc
12:57:50 <wyager> give me a minute
12:59:28 <Javran> I have a question about cabal: if I've customized "Setup.hs", am I supposed to only use "runghc Setup.hs" avoiding "cabal" command?
12:59:59 <Hijiri> I usually remove ~/.ghc/<architecture name>
12:59:59 <Hijiri> because I have a ghci.conf in there
13:00:54 <nh2_work> bergmark: ping
13:01:50 <Hijiri> cabal build install etc should use the provided Setup.hs
13:01:56 <Hijiri> at least I think
13:02:16 <bennofs> Javran: you need build-type:Custom in your .cabal
13:02:17 <dcoutts_> Javran: no, cabal will use your custom Setup.hs. You just need to declare build-type: Custom
13:05:25 <bergmark> nh2_work: hello!
13:05:51 <Javran> bennofs: dcoutts_: Hijiri: but I added a putStrLn before defaultMain, changing .cabal to build-type:Custom doesn't seem to print that line out
13:06:30 <nh2_work> bergmark: can I ask you something about rest?
13:06:38 <bergmark> nh2_work: sure thing
13:08:01 <nh2_work> bergmark: so I'm just getting into this. Is it correct that the *only* way rest will give me information obtained from a resource (blog post tiltle etc) is a REaderT? I was wondering whether there's a more lightweight approach in which the `sid` is just passed in as a function argument
13:08:20 <nh2_work> bergmark: or is the stack of readers somehow necessary for client/doc generation?
13:08:44 <wyager> bennofs: Now cabal is failing in other ways. http://pastebin.com/6ukt0bNw
13:09:29 <Javran> bennofs: dcoutts_: Hijiri: ahh I see, "cabal build" does work, but not the others
13:09:44 <bergmark> nh2_work: a sub resource doesn't need a new ReaderT, if you use e.g. mkResourceId you don't add anything
13:09:56 <Hijiri> maybe stdout is being funneled somewhere where it's not visible?
13:10:00 <bennofs> wyager: hmm, that looks weird
13:10:08 <Hijiri> I don't really know, I haven't made custom Setup.hs
13:10:28 <bergmark> nh2_work: i'm thinking about your first question
13:10:57 <Javran> I thought I could customize cabal in a way that it accepts "cabal my-command" by modifying Setup.hs
13:11:04 <benzrf> ok guys
13:11:26 <benzrf> can you think of any reason at ALL that 2 non-structurally-equal type terms would fail to unify
13:11:32 <benzrf> 1 of them is type family application
13:11:42 <benzrf> and it only fails in a particular context
13:12:07 * sinelaw has yet to educate himself about type families
13:12:35 <nh2_work> bergmark: but when I use mkResourceId, I won't be given the `sid` (e.g. blog post title), will I?
13:13:24 <Javran> actually I try to cabalizing my xmonad config, and make it built and copied to ~/.xmonad automatically. maybe simply go with Makefile would be better.
13:14:19 <stepkut>  is there a name for, flip ($)
13:14:25 <sivteck> `&
13:14:25 * hackagebot twitter-feed 0.1.1.3 - Client for fetching Twitter timeline via Oauth  http://hackage.haskell.org/package/twitter-feed-0.1.1.3 (jsl)
13:14:31 <sivteck> :t (&)
13:14:32 <lambdabot> a -> (a -> b) -> b
13:14:40 <bergmark> nh2_work: i think you want to write your own `enter` function, see Rest.Resource
13:14:48 <Javran> :t (#)
13:14:49 <lambdabot> parse error on input ‘)’
13:14:54 <bitonic> why isn't (&) in base :(
13:15:03 <sivteck> ah ;x
13:15:18 <Javran> parse error..?
13:15:25 <bitonic> we need reverse composition in base
13:15:43 <bitonic> I mean we have =<< and >>= but no reverse ..  what a shame
13:15:44 <EvanR> :t (..)
13:15:45 <lambdabot> parse error on input ‘..’
13:15:54 <bitemyapp> :t (.)
13:15:55 <lambdabot> (b -> c) -> (a -> b) -> a -> c
13:16:02 <bitemyapp> :t flip (.)
13:16:03 <lambdabot> (a -> b) -> (b -> c) -> a -> c
13:16:22 <EvanR> :t (<&>)
13:16:23 <saep> Javran: Why do you want to build it with cabal?
13:16:23 <lambdabot> Functor f => f a -> (a -> b) -> f b
13:16:28 <EvanR> :t (<**>)
13:16:29 <lambdabot> Applicative f => f a -> f (a -> b) -> f b
13:16:49 <sivteck> :t (<<<)
13:16:50 <lambdabot> Category cat => cat b c -> cat a b -> cat a c
13:17:03 <bitemyapp> :t (>>>)
13:17:04 <lambdabot> Category cat => cat a b -> cat b c -> cat a c
13:17:11 <sivteck> > length <<< (+1) $ "blu"
13:17:12 <lambdabot>  No instance for (GHC.Num.Num [GHC.Types.Char])
13:17:12 <lambdabot>    arising from a use of ‘GHC.Num.+’
13:17:16 <bitemyapp> so we do have reverse ., it just looks ludicrous.
13:17:19 <bitonic> bitemyapp:  right, that works but imo is ugly
13:17:24 <bitonic> ehe yeah
13:17:27 <bitemyapp> bitonic: more than a little.
13:17:36 <wyager> Man, by cabal is really FUBAR. I thought I deleted everything at this point
13:17:53 <bergmark> nh2_work: does it seem like the right thing? I've never tried to do this... :-)
13:18:12 <Javran> saep: previously it's a Makefile, but since cabal knows more about haskell, I think it's better to let it handle the building phrase
13:18:30 <bitemyapp> wyager: ~/.ghc/?
13:18:38 <Javran> saep: pull in some dependency packages for example
13:18:57 <wyager> bitemyapp: And the one in /usr/local/. I guess I haven’t tried the one in /Library
13:19:39 <Javran> @hoogle Control.Category.Dual
13:19:41 <lambdabot> package dual-tree
13:20:01 <saep> Javran: I would just write a shell-script for that. `#!/bin/sh\ncabal install the missing packages`
13:20:39 <bennofs> wyager: anyway, gn. wish you good luck solving the issue :)
13:20:43 <bitemyapp> wyager: you shouldn't be deleting global ghc package-db.
13:20:48 <bitemyapp> wyager: that sounds hairy.
13:20:56 <bitemyapp> wyager: methinks a reinstall would be faster.
13:21:03 <wyager> bitemyapp:  Thought I did :/ I tried to nuke it
13:21:27 <saep> Javran: If you have a lot of extra files and compilation takes some time, then I would create a simple cabal package as a library and cabal install that.
13:21:40 <bitemyapp> wyager: OS?
13:21:43 <bitemyapp> Mac OS X?
13:21:43 <wyager> OS X
13:22:01 <porges> bitonic: there was a thread recently on haskell-cafe about putting it into base, it's going into Data.Function
13:22:01 <bitemyapp> wyager: if ghc isn't in your path, and you don't have a ~/.ghc/ it's gonzo for all intents and purposes.
13:22:09 <wyager> Ghc is in my path
13:22:09 <bitemyapp> wyager: http://new-www.haskell.org/downloads/osx
13:22:12 <wyager> I have a .ghc
13:22:22 <wyager> Deleting that didn’t seem to help much
13:22:22 <bitemyapp> wyager: kill 'em with fire, reinstall using the link I just gave you.
13:22:28 <nh2_work> bergmark: ah, now I understand what exactly enter does. I think this means that I can use the ((->) r) monad instead of its Reader newtype, but `enter` makes it clear that the only way how I can pass the `sid` into my handlers is via the monadic environment
13:22:39 <wyager> Did that already… now cabal-install won’t build when I try to upgrade it
13:23:07 <wyager> “cannot satisfy -package-id HTTP-4000.2.10-da371776b88c2889959897a2dc40abe7”
13:23:27 <nh2_work> bergmark: what I was trying to do is something like `mkResourceWithParam $ \title -> something{ ..., get = Just (getPost title) }`, but that is not possible
13:24:14 <bitemyapp> wyager: install cabal-install in a sandbox.
13:24:16 <Javran> saep: I think a shell script would do.
13:24:21 <bitemyapp> wyager: if it still breaks, you're borked.
13:24:24 <nh2_work> bergmark: because `mkResource` separates the `sid -> s b -> m b` function and the returned Resource - in the place where I make the Resource, the sid cannot be in scope
13:25:31 <wyager> bitemyapp: Trying that
13:25:33 <nh2_work> bergmark: let me try if I can just use plain `(->) r`
13:25:39 <nh2_work> bitonic: sup?
13:25:41 <bergmark> nh2_work: and different end points require different identifiers
13:25:44 <bergmark> or no identifiers
13:26:51 <nh2_work> bergmark: do you happen to know the answer to the second part of my question, whether the ReaderTs are actually used to do some documentation generation, or whether that's just an API choice here?
13:29:46 <wyager> bitemyapp: `cabal install cabal-install` fails in a sandbox :(
13:30:20 <bergmark> nh2_work: i don't think so, all that information should be available elsewhere
13:30:32 <a3gis> hey! what would be the most efficient (while staying readable) way of doing the following in haskell: "take elements from a list until it repeats itself" ? basically, as soon as you encounter an element that is in the N first, return
13:30:47 <a3gis> e.g. f [1, 3, 2, 1, ...] should return [1, 3, 2]
13:31:45 <lgandras> hi, good day for everyone. What tool can I use to generate boilerplate? Let's say a base source code file?
13:31:49 <vanila> > let take acc (x:xs) | elem x acc = [] ; take acc (x:xs) = x : take (x:acc) xs in take [1,3,2,1]
13:31:50 <lambdabot>  <[Integer] -> [Integer]>
13:32:05 <vanila> > let take acc (x:xs) | elem x acc = [] ; take acc (x:xs) = x : take (x:acc) xs in take [] [1,3,2,1]
13:32:06 <lambdabot>  [1,3,2]
13:32:11 <wyager> a3gis: You will want to use a set if you want speed
13:32:20 <vanila> note that you cuol write it this way
13:32:28 <vanila> > let take acc (x:xs) | elem x acc = acc ; take acc (x:xs) = take (x:acc) xs in take [] [1,3,2,1]
13:32:29 <lambdabot>  [2,3,1]
13:32:29 <a3gis> vanila: yep tht's the solution I came up with but it's very inefficient
13:32:37 <a3gis> since 'elem' has to go through the list again and again
13:32:38 <vanila> which makes sense in a strict language but the first way is much better in haskell
13:32:45 <a3gis> I think worse case would be O(n!) or something
13:32:50 <vanila> and secondly, the way I wrote it lets you easily replace 'acc' with a different data type
13:32:56 <vanila> e.g. a Set as wyager recommended
13:33:08 <bitemyapp> wyager: wipe out everything, reinstall, verify that no GHC is in your path before you reinstall.
13:33:22 <bitemyapp> wyager: I've no idea how you've gotten this tangled up, I've never seen anything this bad before.
13:33:23 <bergmark> nh2_work: the way i see it, the enter function creates the stack and only gets called when you run a request against it, for all other purposes you can just inspect the api tree to gather information about identifiers and such
13:33:25 <bitemyapp> wyager: just unfortunate.
13:33:29 <bitemyapp> mutable state sucks :|
13:33:35 <nh2_work> a3gis: it's n; you can use a set or hashmap to make it n logn
13:33:36 <vanila> a3gis, I think it would be n^2
13:33:49 <wyager> Well technically a hashmap would make it just n
13:34:12 <wyager> Set (in Haskell) makes it n*log(n) since we use ord-based sets, not hash-based sets
13:34:24 <a3gis> oh ok
13:34:26 <wyager> bitemyapp: Hmm. I will try
13:34:33 <a3gis> I'll check out sets
13:36:07 <nh2_work> bergmark: I see. I wonder if single-argument-functions instead of stacked readers would make me happier, but I'm not sure yet. I understand that the concept here is "put all new information into the monad stack" because that's general, but I don't know yet if it's the easiest thing to do.
13:38:40 <lgandras> hi, any chance to het help? I've seen HStringTemplateHelpers and template, but they seem to have dropped support. Is there a better and obvious option to generate boilerplate?
13:39:47 <agocorona> hello haskell
13:40:03 <bitemyapp> agocorona: hi
13:40:42 <nh2_work> lgandras: what do you mean with "they've dropped support"?
13:41:24 <bergmark> lgandras: Template Haskell? GHC Generics? It depends on what you are trying to do i suppose
13:41:54 <bergmark> or haskell-src-exts?
13:43:30 <lgandras> nh2_word, bergmark: thank you. HStringTemplateHelpers doesn't get updates since 2009 and says beta. template doesn't get updates since 2008. I mean a templating system, just like any HTML generator works. I just need it to create source code written in Javascript.
13:43:46 <sinelaw> lgandras, there's shakespear
13:43:55 <sinelaw> http://www.yesodweb.com/book/shakespearean-templates
13:43:57 <sinelaw> lgandras, ^^
13:44:25 <bergmark> lgandras: oh, i assumed you wanted to generate haskell code, n/m my suggestions then
13:44:35 <bergmark> lgandras: there's also jmacro
13:44:39 <dtruby> I’ve got a problem with conduit that I can’t for the life of me fix. I’m using the socket stuff and I can’t work out how to quit on ctrl-D
13:45:02 <dtruby> Is the a function in conduit that causes a Source to stop producing when it produces a given value?
13:45:04 <Fuuzetsu> C-d just sends EOF
13:45:25 <lgandras> sinelaw: I believe that's exactly what I was looking for. bergmark: I'll check jmacro. Thank you.
13:45:28 <dtruby> yeah I can’t work out how to get it to stop ever actually, not just on EOF
13:45:32 <Jamshid_> The `show` class is used to output the item in a form that can be read by ghci itself....  PrettyPrint is used to output in human readable form, and does not seem to use a class.  Does anyone know, however if there is a common (idomatic) class used like `show` for pretty printing?
13:45:48 <nh2_work> lgandras: isnt template updated 2014? https://hackage.haskell.org/package/template
13:45:50 <simpson> Jamshid_: There's one in generic-prettyprint.
13:45:50 <bergmark> lgandras: or language-ecmascript if you want to go the AST route
13:45:57 <dtruby> e.g. I tried getting it to quit when it sees ‘q’ but can’t get that to work either
13:46:28 <Jamshid_> simpson: I'll go look, thanks, brb
13:47:10 <lgandras> nh2_work: you're right. rookie mistake. thanks.
13:47:48 <dtruby> atm I’ve got http://hastebin.com/aveduciciw.hs and I want it to terminate when ctrl-D gets sent on stdin
13:48:01 <lgandras> bergmark: oh that's way beyond my needs, but thanks for suggesting. Required output is just a base class without previous AST.
13:48:14 <bergmark> lgandras: heh, and i forgot about our package http://hackage.haskell.org/package/code-builder
13:48:30 <bergmark> not sure if i recommend using that though :-)
13:48:37 <Fuuzetsu> dtruby: that depends on what stdinC does
13:49:05 <Fuuzetsu> oh, not even
13:49:27 <Fuuzetsu> depends on the default sink used
13:49:45 <lgandras> bergmark: hahaha a simple template system is just what I need. Thank you for the complete list, really.
13:50:05 <dtruby> I assumed I would be able to combine either the sink or the source with one that disconnected when ctrl-d gets sent but I can’t work out how to do that
13:50:43 <benzrf> can anybody think of any reason at ALL that 2 non-structurally-equal type terms would fail to unify
13:50:50 <benzrf> 1 of them is type family application
13:50:50 <benzrf> and it only fails in a particular context
13:51:07 <dtruby> actually, what you said made me wonder and it seems that ctrl-d does actually disconnect that path.. so it’s just continuing to concurrently run the other one…
13:51:18 <wyager> bitemyapp: I managed to nuke everything, I think. Although this damn msgpack library still won’t build...
13:51:38 <dtruby> so Conduit is doing exactly what I expected, I obviously just didn’t read the docs for Control.Concurrent.Async properly :-P
13:51:39 <bitemyapp> wyager: I don't know anything about msgpack libraries and cannot help you on that, sorry.
13:51:50 <indiagreen> wyager: it won't build 'cause it's old and has some issue with dependencies
13:52:11 <indiagreen> use messagepack or download msgpack from github and apply some pull request, don't remember which
13:52:15 <indiagreen> @hackage messagepack
13:52:15 <lambdabot> http://hackage.haskell.org/package/messagepack
13:53:01 <indiagreen> https://github.com/msgpack/msgpack-haskell/pull/54
13:54:27 * hackagebot traverse-with-class 0.2 - Generic applicative traversals  http://hackage.haskell.org/package/traverse-with-class-0.2 (RomanCheplyaka)
13:56:03 <ChristianS> is is considered good style to try to align the '<-' and '='s in a do block?
13:57:39 <marvin-hh> ChristianS: you should spend time on more important issues.
13:57:59 <bergmark> ChristianS: i find it makes it easier to read, but formatting is a highly controversial topic :-)
13:58:01 <marvin-hh> ChristianS: if people cared enough, they would write tools which would do layout automatically.
13:58:08 <indiagreen> which they did
13:58:15 <marvin-hh> So, problem solved.
13:58:19 <marvin-hh> indiagreen: which one in this case?
13:58:34 <indiagreen> chrisdone's structured Haskell mode
13:58:41 <zurk> ChristianS: This might help: http://snapframework.com/docs/style-guide
13:58:45 <wyager> indiagreen: THanks. MessagePack looks nice. Just provides a serializable isntance
13:59:06 <marvin-hh> indiagreen: and that works on arbitrary GHC Haskell?
13:59:29 <marvin-hh> indiagreen: and it has no known bugs anymore?
14:00:11 <marvin-hh> I ask, because I think it's rather pointless to introduce others to tools which have known issues.
14:00:30 <marvin-hh> It's the same with people claiming everyone should be using Julia.
14:00:50 <ChristianS> zurk: that specific question is not answered in the snap style guide, methinks, but i guess i'll just stick with my current style (align '=' in where blocks, but don't align in do blocks)
14:00:52 <marvin-hh> Julia has some simple minded GC system, IIRC.
14:00:57 <marvin-hh> So, in pretty much all ways it'
14:01:07 <marvin-hh> s inferior to Java, except for syntax.
14:01:20 <marvin-hh> "Java" as in the ecosystem, etc.
14:01:41 <indiagreen> I took your statement to mean “if people cared, they would've written tools”. People have written tools. Whether they work for all of GHC Haskell as opposed to the subset of GHC Haskell which -people who have written those tools- are using is another question.
14:02:13 <indiagreen> I believe the existence of structured-haskell-mode proves the original point, which is “some people care enough”.
14:03:31 <zurk> indiagreen: see also http://hackage.haskell.org/package/haskell-formatter-0.1.0 for people that care
14:03:46 <indiagreen> well, I don't care, actually :)
14:05:17 <P4Titan> Hello all, can I use a where in a do statement to define a sub function
14:06:01 <sivteck> sure
14:06:24 <nh2_work> P4Titan: if the subfunction shall depend on a value that you <-'ed in the do block, no
14:06:25 <sivteck> not inside the do block?
14:06:52 <nh2_work> P4Titan: but you can use "monadic let": just `let f = ...` in the do block
14:07:15 <P4Titan> So pretty much I cannot use where in the do
14:07:49 <Evilsparza> Couldn't match type `Gen Prop' with `Bool' - I get this error when I try to apply constraints to my quick check test, both f and fnew take integer tuples, I don't get what's wrong http://pastebin.com/SL8FX2eP
14:08:45 <indiagreen> :t (==>)
14:08:46 <lambdabot> Testable prop => Bool -> prop -> Property
14:09:10 <indiagreen> so your result type should be Property and not Bool
14:09:15 <nh2_work> P4Titan: yes
14:09:27 <P4Titan> Thanks
14:09:43 <nh2_work> P4Titan: you can write a where if it is outside the do block and doesn't depend on anything declared inside the do block
14:09:53 <P4Titan> yes
14:15:41 <nh2_work> bergmark: just to give the answer to my idea from before if I can use the `(->) r)` monad: no
14:15:53 <bergmark> nh2_work: :-( why not?
14:16:07 <stepkut> sivteck: neat
14:16:17 <_2_Rebecca> hello
14:17:20 <nh2_work> bergmark: because in `Resource m s ...`, the m is just some Monad, not `Monad a` (kind *->*) and I cannot apply `(->) r` around that, I need a monad transformer to "compose monads on the kind level", and the monad transformer for `(->) r` is ReaderT
14:18:44 <bergmark> nh2_work: i see, in what sense did you want it to be more lightweight by the way?
14:19:28 * hackagebot ersatz 0.2.6.1 - A monad for expressing SAT or QSAT problems using observable sharing.  http://hackage.haskell.org/package/ersatz-0.2.6.1 (EdwardKmett)
14:20:30 <nh2_work> bergmark: visually (that my handler can just have a "label" argument), that the type is shorter, to avoid lift.lift.lift and because GHC isn't good at optimising transformer stacks
14:20:58 <nh2_work> but again I'm not sure yet whether this is actually a problem or not, still trying around things
14:22:04 <bergmark> we usually define type classes to avoid the lift.lifting
14:22:18 <nh2_work> bergmark: yes I will also try that now and see how it looks
14:23:23 <bergmark> we also typically use a type alias so the type of the handler body becomes something like `ErrorT (Reason a) WithMyResource b'
14:25:11 <nh2_work> bergmark: I only have a "gut feeling" problem with it in that Reader is, in some way, a packed version of giving a function an argument, and that in many cases so far I don't make any use of the "packaging" (I only access the field at the next immediate level)
14:26:26 <bergmark> we use the intermediary layers quite a lot
14:27:21 <sinelaw> what's a good name for something that gets "a b" out of "forall a b. t"?  "getQuantificands" ?
14:27:42 <nh2_work> bergmark: but, for example, for an /a/b/c/d/e route, in the e resource, do you read out the value provided by a via the reader?
14:28:22 <nh2_work> bergmark: it feels a bit weird that mkIdHandler gives me the value out of the Reader and then I never need it again (but it still sits in the reader unused)
14:29:04 <bergmark> nh2_work: yep, for example our api has /site/page/autosave and when we want to do something with the identified autosave we have to make sure it belongs to the correct site
14:30:31 <nh2_work> bergmark: from autosave, how do you lift just up into the site level? Do you have a Monad<Something> for each layer?
14:31:49 <bergmark> nh2_work: for the important ones at least, we have a MonadSite class, but I don't think we have MonadPage
14:33:12 <bergmark> most resources are leaves so they don't need it until we nest something under them
14:33:24 <bergmark> s/it/their own class/
14:37:05 <nh2_work> bergmark: I see. That probably does allow for quite a bit of reuse, since you can write resources that just, say, grab something (e.g. a UUID) from the environment if it's there (e.g. a UUID) and do something with it (e.g. save the changes), but it does give the feeling that rest is built rather for the more complated setups and not the absolutely easy ones
14:38:01 <nh2_work> bergmark: I wonder if it can have an API evolution like conduit, which in the past was more complicated and by now has absolutely simple types and less combinators, without having had to sacrifice on its usefulness or generality
14:38:04 <bergmark> it started as an internal project so it's very much tailored for our use case
14:38:48 <hugomg> I have a silly style question: It bugs me that if I import a module qualified the types in my signatures get really long, like "IntMap.IntMap". Whats the best way to handle qualified imports to avoid types from getting too long?
14:39:03 <monochrom> two import lines
14:39:17 <mauke> import qualified IntMap as IM
14:39:26 <monochrom> import qualified Data.Map; import Data.Map(Map)
14:39:31 <bergmark> sebas wrote a good comment about this a while back https://news.ycombinator.com/item?id=7969475
14:41:18 <Axman6> hugomg: I wrote a snippet for sublime text which makes doing that really easy. it's in the sublimehaskell package (default tab trigger is impq<tab>)
14:43:03 <hugomg> axman6: hmm, using an editor shortcut sounds like a clever workaround as the only big negative of the double imports is the extra typing. Now I need to figure out how to do it in vim though :)
14:43:21 <mauris> wow, haskell has been the only language in which writing networking code was actually sort of fun
14:43:29 <bitemyapp> mauris: :)
14:43:52 <mauris> here's what i made! https://gist.github.com/maurisvh/1a4d7752e2900459011c
14:44:36 <mauris> the code is very... IO-y, i guess, but it makes sense, as IO is all this program really does
14:45:08 <nh2_work> bergmark: I've actually read that already :) It's funny how now that I read it again, "simplest case with a reader" gets a much more literal meaning. So far I'm pretty pleased with my experience with rest.
14:45:24 <bitemyapp> mauris: netcat really is too damn neat ain't it?
14:45:39 <mauris> it's quite cool!
14:46:01 <nh2_work> bergmark: do you know how the routes are actually matched at runtime, and how fast that is? What kind of data structure does it use for matching?
14:46:35 <bergmark> someone at zurihac did benchmarks on it
14:47:12 <nh2_work> mauris: if you name it with ".hs" at the end, github will syntax higlight it nicely
14:47:16 <bergmark> but i don't remember the results. I think the code is pretty naive and probably not very efficient
14:47:42 <mauris> neat. done
14:47:54 <bergmark> type UriParts = [String]
14:47:57 <bergmark> :-o
14:48:36 <bergmark> i will be extremely happy when the day that this is our bottleneck comes though :-)
14:48:52 <kttm> hi, how can i wrap an either value into a ExceptT value?
14:49:21 <bergmark> @type ExceptT . return
14:49:22 <lambdabot> Not in scope: data constructor ‘ExceptT’
14:49:30 <bergmark> @type ErrorT . return
14:49:31 <lambdabot> Monad m => Either e a -> ErrorT e m a
14:50:47 <nh2_work> bergmark: I was just reading https://news.ycombinator.com/item?id=8631022 yesterday where netflix was screwed by linear-trying route matching in express.js
14:51:10 <nh2_work> bergmark: rest can probably optimise this really nicely because it doesn't allow regex in the resource names
14:52:26 <nh2_work> bergmark: so you can do a very efficient prefix match, or just stuff everything into a big regex with | in between, and have it optimised by the regex engine to achieve the same with C speed
14:52:28 <bergmark> "Something was adding the same Express.js provided static route handler 10 times an hour. " :-)
14:56:22 <bergmark> nh2_work: indeed, it doesn't sound hard :-)
14:56:27 * geekosaur likes the claim about closed source solving the proble,
14:56:55 <geekosaur> I should show that to the folks in another channel I'm in who have to do that drop-everything-and-rewrite every time atlassian revs a product...
14:58:20 <nh2_work> geekosaur: I don't understand - isn't Atlassian "open source" as in "you get all the source when you subscribe to the product?
14:58:49 <geekosaur> I get the impression it's more "'open'"
14:59:07 <geekosaur> you get the source but $DEITY help you if you (a) read it (b) try to dio anything with it
14:59:26 <geekosaur> incomprehensible and you're screwed on their next release because your local changes won't apply
14:59:30 * hackagebot Folly 0.1.3.0 - A first order logic library in Haskell  http://hackage.haskell.org/package/Folly-0.1.3.0 (dillonhuff)
14:59:55 <nh2_work> geekosaur: I see
15:00:03 <geekosaur> atlassian was probably a bad example though, yes
15:00:22 <geekosaur> just the upgrade screams of rage came to mind immediately on reading that claim
15:01:04 <geekosaur> the folks I know who use atlassian ignore the open source aspect after getting burned on an upgrade; it might as well not be
15:01:37 <geekosaur> (and I have just avoided it, who needs that pain? I can get it by trying to track gnome3 >.>)
15:07:38 <nh2_work> bergmark: is the actual routing provided by rest-core or by e.g. rest-wai?
15:09:38 <Evilsparza> is there a possibility to get every 2-permutation of a list easily?
15:10:19 <Dodek> what is 2-permutation?
15:11:35 <Evilsparza> e.g. I have a list [1,2,3], what I want is [(1,2),(2,3),(1,3)]
15:12:10 <Dodek> you mean, two-element _combinations_
15:12:11 <Evilsparza> every possible combination of each 2 elements of the list
15:12:39 <Evilsparza> if that's what you call them, then yes, that's what I mean :D
15:12:41 <bergmark> nh2_work: rest-core, it's shared between all backends
15:12:47 <Welkin> > sequence [1,2,3]
15:12:48 <lambdabot>  No instance for (GHC.Show.Show (m0 [a0]))
15:12:48 <lambdabot>    arising from a use of ‘M49533752536460681897813.show_M49533752536460681897...
15:12:48 <lambdabot>  The type variables ‘m0’, ‘a0’ are ambiguous
15:12:48 <lambdabot>  Note: there are several potential instances:
15:12:48 <lambdabot>    instance [safe] GHC.Show.Show a =>
15:12:50 <bergmark> nh2_work: Rest.Driver.Routing
15:13:01 <Welkin> > sequence [[1],[2],[3]]
15:13:03 <lambdabot>  [[1,2,3]]
15:13:21 <Welkin> > sequence [[1,2,3]]
15:13:22 <lambdabot>  [[1],[2],[3]]
15:13:22 <vanila> > tails [1,2,3]
15:13:22 <nh2_work> Evilsparza: a list comprehension with two `<-` and a `\\` will do that nicely
15:13:24 <lambdabot>  [[1,2,3],[2,3],[3],[]]
15:13:29 <vanila> > map tails . tails $ [1,2,3]
15:13:31 <lambdabot>  [[[1,2,3],[2,3],[3],[]],[[2,3],[3],[]],[[3],[]],[[]]]
15:13:57 <Dodek> nh2_work: it wil have duplicates.
15:14:00 <nh2_work> bergmark: I haven't found yet where the actual traversal down Rest.paths is yet
15:14:04 <quchen> liftA2 (,) xs xs -- will be the cartesian product of xs with itself, not a list of 2-permutations.
15:14:06 <vanila> > filter ((==2) . length) . concat . map tails . tails $ [1,2,3]
15:14:08 <lambdabot>  [[2,3],[2,3]]
15:14:17 <Evilsparza> > [(a,b) | a <- [1,2,3], b <- [1,2,3]]
15:14:18 <lambdabot>  [(1,1),(1,2),(1,3),(2,1),(2,2),(2,3),(3,1),(3,2),(3,3)]
15:14:20 <vanila> > filter ((==2) . length) . map (take 2) . concat . map tails . tails $ [1,2,3]
15:14:22 <lambdabot>  [[1,2],[2,3],[2,3]]
15:14:42 <nh2_work> Evilsparza: you also need to use \\
15:15:02 <Dodek> wait what is \\
15:15:08 <Evilsparza> list difference
15:15:12 <Welkin> :t (\\)
15:15:13 <lambdabot> Eq a => [a] -> [a] -> [a]
15:15:23 <vanila> > let part [] = [] ; part (x:xs) = (x,xs) : part xs in do (a,xs) <- part [1,2,3] ; (b,_) <- part xs ; return (a,b)
15:15:24 <lambdabot>  [(1,2),(1,3),(2,3)]
15:15:26 <Dodek> how would you use it here?
15:15:27 <Welkin> > [1,2,3] \\ [2,3,4]
15:15:29 <lambdabot>  [1]
15:15:55 <Evilsparza> I don't know where to use it h2_work :/
15:16:11 <Dodek> i mean, recursive function to calculate it is like two lines
15:16:18 <bergmark> nh2_work: i'm not familiar with the routing code
15:16:35 <Dodek> why would one want to use list comprehensions and \\ and what not is beyond me
15:16:58 <nh2_work> > [(a,b) | a <- [1,2,3], b <- [1,2,3] \\ [a] ] -- assumes that the order is significant
15:16:59 <lambdabot>  [(1,2),(1,3),(2,1),(2,3),(3,1),(3,2)]
15:17:22 <Dodek> nh2_work: these are not all combinations. these are all combinations counted twice each.
15:18:32 <lengzai> exit
15:18:40 <nh2_work> yes, the above as assuming that order is significant
15:19:03 <nh2_work> > [(a,b) | a <- [1,2,3], b <- filter (<a) $ [1,2,3] \\ [a] ]
15:19:05 <lambdabot>  [(2,1),(3,1),(3,2)]
15:19:10 <Welkin> I thought you could use sequence to obtain the cartesian product of a list?
15:19:15 <Dodek> nh2_work: 00:10 < Evilsparza> e.g. I have a list [1,2,3], what I want is [(1,2),(2,3),(1,3)]
15:19:16 <nh2_work> (then you can also scrap the \\
15:19:20 <Dodek> you must have missed that
15:19:25 <Dodek> and also it works only with integers
15:19:28 <nh2_work> yes I just read it afterwards
15:19:31 <Dodek> and is generally pretty complicated to understand
15:19:39 <Dodek> really, i'd just write a recursive function
15:19:47 <Dodek> it's like two lines
15:19:55 <nh2_work> works only with Ord
15:20:07 <Dodek> well yeah, right
15:20:32 <Dodek> still it's not difficult to write a function that works with any [a]
15:20:42 <vanila> I just showed how
15:20:44 <vanila> > let part [] = [] ; part (x:xs) = (x,xs) : part xs in do (a,xs) <- part [1,2,3] ; (b,_) <- part xs ; return (a,b)
15:20:46 <lambdabot>  [(1,2),(1,3),(2,3)]
15:21:09 <indiagreen> > [(x, y) | (x:s) <- tails [1..4], y <- s]
15:21:10 <lambdabot>  [(1,2),(1,3),(1,4),(2,3),(2,4),(3,4)]
15:21:19 <Welkin> > (,) <$> [1..3] <*> [1..3]
15:21:21 <lambdabot>  [(1,1),(1,2),(1,3),(2,1),(2,2),(2,3),(3,1),(3,2),(3,3)]
15:21:33 <indiagreen> what do I win
15:21:40 <nh2_work> Dodek: "[your 48 char oneliner] is too complicated to understand, I'd just write a recursive function in 2 lines"? :D
15:21:52 <Dodek> of course
15:21:58 <monochrom> you need to understand everything
15:22:04 <nh2_work> > [(a,b) | a <- [1,2,3], b <- [1,2,3], a < b]
15:22:05 <lambdabot>  [(1,2),(1,3),(2,3)]
15:22:07 <Dodek> oneliners are not necessarily more clear
15:22:24 <vanila> indiagreen, well that is cool but I don't think it solve the problem
15:22:27 <Dodek> short code is not necessarily more clear either
15:22:29 <vanila> and we can do it without Ord
15:22:48 <Welkin> :t tails
15:22:49 <lambdabot> [a] -> [[a]]
15:22:53 <indiagreen> vanila: well, assuming the list was nub-ed before
15:22:58 <vanila> Dodek, I guess people ar eopposed to defining a hhelper function
15:23:30 <Dodek> these kind of people are welcome to import Data.Choose
15:43:16 <pharpend> so, odd question, I'm trying to write a password generator - http://lpaste.net/114657
15:43:44 <pharpend> Every time I run it, I get an error like this - http://lpaste.net/114659
15:44:28 <pharpend> whenever I run sha1 on the command line, the output is always letters and numbers. Why is that not the case with Crypto.Hash.SHA1?
15:44:29 <Dodek> so you essentially take random bytes and try to decode it as utf-8 string?
15:44:35 <pharpend> no
15:44:55 <koala_man> pharpend: the sha1 command line tool helpfully formats the binary hash sum in hex
15:45:05 <koala_man> otherwise it would garble the terminal
15:45:25 <pharpend> no - I take random bytes, hash them with SHA-1, which I thought would output UTF-8 data. Oh, okay, koala_man
15:45:59 <Dodek> pharpend: crypto libraries generally return hashes as they are, not in human readable form.
15:46:47 <pharpend> okay, thank you.
15:46:54 <pharpend> yay it worked
15:46:58 <koala_man> yay
15:47:25 <pharpend> I used base16-bytestring. I should use a base that includes both capital and lowercase numerals
15:47:56 <pharpend> capital and lowercase letters, as well as numbers
15:48:04 <Welkin> pharpend: use unicode
15:48:09 <pharpend> that would be base 62
15:48:18 <pharpend> Welkin: we just discussed this, Unicode doesn't work in this situation
15:48:27 <Welkin> why not?
15:48:32 <Welkin> for random passwords?
15:49:08 <koala_man> it works fine (except on half the sites you'll use it on), you just have to generate the characters rather than assume that binary data are valid utf8 characters
15:49:34 <pharpend> Yes, exactly - most of the random bytes are not valid utf8 characters
15:50:29 <koala_man> they're not digits or numbers either. it's the same problem, just with a larger output domain
15:50:47 <pharpend> base 64-bytestring sort of works, I will just have to do a hackish filter
15:52:30 <crazym4n> Are L-Systems monadic? They seem like they would be.
15:54:44 <vanila> crazym4n, no I dont think so
15:55:03 <vanila> you would interpret them using a monad in haskell
15:55:09 <crazym4n> Well, is there any way that L-Systems could be simulated with haskell idioms?
15:55:20 <crazym4n> And the more I think of it the less it makes sense
15:56:25 <crazym4n> http://lpaste.net/6790139494482837504 this is the code I have now, and I feel like it could be made much more haskell-y
15:56:36 <vanila> > rule '#' = "# #" ; rule ' ' = "   " in iterate (concatMap rule) "#"
15:56:37 <lambdabot>  <hint>:1:10: parse error on input ‘=’
15:56:39 <vanila> > let rule '#' = "# #" ; rule ' ' = "   " in iterate (concatMap rule) "#"
15:56:41 <lambdabot>  ["#","# #","# #   # #","# #   # #         # #   # #","# #   # #         # # ...
15:56:49 <vanila> there's cantor set L system example
15:56:49 <crazym4n> That's exactly what I'm doing
15:57:00 <crazym4n> Like, literally. Look at the code, haha
15:57:28 <vanila> well I think that is a good way to do it
15:58:06 <crazym4n> I guess. I was thinking that if I did it some other way, it'd be easier to use post-runtime generated rules
15:58:27 <vanila> so rule in my example is a hard coded function
15:58:35 <crazym4n> Yes, so is mine
15:58:48 <crazym4n> I can't think of a good way to make it not hardcoded though
15:58:51 <vanila> but if you started with data like  [('#', "# #"), (' ', "   ")]
15:59:12 <vanila> you could make a function buildRule such that buildRule [('#', "# #"), (' ', "   ")] is the same as rule above
15:59:47 <crazym4n> That's quite a good idea
15:59:53 <crazym4n> Thanks
16:05:01 <fds4345> whats everyone's favourite regex library
16:07:14 <saep> Is there a recommended way to generate haskell code from a text file specification?
16:07:23 <sm> fds4345: regex-tdfa
16:11:39 <prinsen> In my ECMA interpreter I need to do IEEE 754 arithmetic. I represent a number with a data Number = Number Double | NumberNaN | NumberInfPos | NumberInfNeg. My problem is that I need to check the signed ness of 0-values, but (0) and (-0) is overlapping in pattern matching etc
16:13:13 <mauke> > isNaN (0 / 0)
16:13:13 <mauris> prinsen: data Sign = Pos | Neg and then keep only the absolute value in the other part?
16:13:14 <lambdabot>  True
16:13:32 <mauris> but yeah that is assuming you even want to reinvent the wheel here
16:15:11 <prinsen> Might it bee so that I can use the haskell Double right of?
16:16:07 <merijn> prinsen: Double is IEEE754
16:16:19 <Polarina> prinsen, you can use Double directly, it is IEEE754.
16:16:23 <merijn> > (0/0) :: Double
16:16:24 <lambdabot>  NaN
16:16:33 <merijn> > (0/10) :: Double
16:16:34 <lambdabot>  0.0
16:16:41 <merijn> > (10/0) :: Double
16:16:42 <lambdabot>  Infinity
16:16:51 <merijn> > (-10/0) :: Double
16:16:52 <lambdabot>  -Infinity
16:17:34 <prinsen> perfect
16:17:58 <Polarina> > 0/0 == 0/0
16:17:59 <lambdabot>  False
16:18:14 <chrisdone> aw hell yeah
16:18:17 <Guest6> Is there code reloading for Haskell?  I don't want to make a change and wait for the code to compile.
16:18:21 <ion> FSVO perfect
16:18:22 <chrisdone> just converted my Html monad to an HtmlT transformer
16:18:32 <chrisdone> it made it twice as slow
16:18:46 <chrisdone> i added some well-placed ~'s and it brought it back down to near the same speed
16:19:07 <ion> chrisdone: Take a book from the JavaScript playbook and call it “it made it have 2× the performance”.
16:19:17 <chrisdone> http://chrisdone.com/lucid-trans.png
16:19:51 <merijn> "I increased the amount of dynamic allocation to my code and got a 3x speedup" <- no joke :>
16:20:15 <merijn> s/to/in
16:20:19 <Welkin> Guest6: what?
16:20:26 <Welkin> the code has to compile anyway
16:20:30 <Welkin> there is no way around that
16:20:42 <Welkin> yes, some web frameworks have built-in code-reloading
16:20:44 <Welkin> like yesod
16:20:46 <merijn> Compile with -O0 if you want faster compile time for developing
16:20:59 <merijn> Or, if you just want to typecheck, use "-O0 -fno-code"
16:21:06 <lc80> hi there
16:21:50 <Guest6> Welkin:  Code reloading is what I meant.  Thanks
16:22:00 <nh2_work> Guest6: or use ghci or hdevtools
16:23:10 <lc80> I have a question about defining my own type: is it possible to do it in a way allowing to use it in ranges?
16:23:43 <chrisdone> lc80: limited possibilities
16:24:03 <chrisdone> there're smart constructors and there're sophisticated type-system models
16:24:50 <chrisdone> lc80: what kind of range do you want to model?
16:24:50 <lc80> but theoretically it should be possible, as long as type is enumerable
16:25:35 <lc80> let's say I have something like
16:25:38 <lc80> data JediRank = Initiate | Padawan | Knight | Master deriving (Bounded, Enum, Eq, Ord, Show)
16:26:03 <lc80> and would like to get [Initiate..Master] list
16:26:37 <aphorisme> Uhm, what are the ":::" in Haskell?
16:26:47 <lc80> I am new relatively new to Haskell, but it should be working, isn't it?
16:26:53 <zwer> lc80 that should already work, just add spaces around ..
16:26:58 <zwer> [Initiate .. Master]
16:27:51 <lc80> ookay, that was it :)
16:27:52 <chrisdone> ah, i'm glad i asked what you meant
16:28:03 <lc80> thanks a lot, zwer
16:28:10 <Adamant> what’s the dependent typing/proof assistant language for these days? Agda, Epigram, Coq, Idris?
16:28:21 <zwer> welcome
16:28:29 <vanila> Adamant, epigram doesnt exist
16:28:35 <lc80> spaces are not needed in case of [1..3] or ['a'..], so a bit of inconsistency, there
16:28:36 <chrisdone> Adamant: they're all different with different strengths
16:28:55 <Adamant> ah.
16:29:06 <chrisdone> Adamant: johnw's done some work with Agda and Coq
16:29:19 <bitemyapp> Adamant: Coq has the strongest proof search and tactics, Agda has the best Haskell integration (some would argue syntax), Idris can generate JavaScript.
16:29:22 <Haskellfant> Hi, I'm looking at the implementation of bracket http://hackage.haskell.org/package/base-4.7.0.1/docs/src/Control-Exception-Base.html#bracket and it looks to me like in the case of an exception during thing a I call the release operation twice. once in the exception handler and once after that, what am I missing?
16:29:31 <Adamant> cool. thanks all.
16:30:59 <greymalkin> I once saw a good description of "how to get good at haskell" which was somewhat iterative -- make a program, it's ugly. Learn more at X site, make it prettier...
16:31:09 <greymalkin> The problem is I don't remember what X site was
16:32:05 <Yuras> Haskellfant: onException rethrows the exception, so the second "after" is not called
16:32:22 <Haskellfant> Yuras: ah right, I forgot about that, thx
16:34:11 <merijn> Adamant: Idris is not really trying to be a proof assistant as much as a pragmatic language
16:34:38 <merijn> Adamant: Epigram is mostly dead, afaik. Last I heard pigworker stopped working on it for "religious reasons", it is unsure whether those reasons involve HoTT
16:34:53 <merijn> Adamant: Agda and Coq are very different, I found Coq more fun :)
16:35:04 <Adamant> thanks merijn!
16:35:10 <merijn> Adamant: There's a good free book introducing program verification using Coq
16:35:12 <merijn> @where sf
16:35:12 <lambdabot> "Software Foundations" by Pierce,Casinghino,Greenberg,Sjöberg,Yorgey in 2011-06 at <http://www.cis.upenn.edu/~bcpierce/sf/> about "the mathematical theory of programming and programming languages", "It develops basic concepts of functional programming, logic, operational semantics, lambda-calculus, and static type systems, using the Coq proof
16:35:12 <lambdabot> assistant."
16:35:41 <Adamant> :)
16:39:54 <bitemyapp> merijn: ...religious reasons?
16:41:31 <merijn> bitemyapp: You would say theoretical CS is not religion? :p
16:42:18 <merijn> bitemyapp: That was a joke about the ongoing fights which mathematical foundation should be used
16:42:52 <SwashBuckla> hi there. Could i get some help writing an instance Arbitrary for a recursive data type? https://github.com/spanners/cis194/blob/master/Course/answers/07-folds-monoids/JoinList.hs#L51
16:43:06 <SwashBuckla> (quickCheck question)
16:43:07 <bitemyapp> I knew about the IOE thing, but not much else. I'm not really in tune with academic matters.
16:43:53 <merijn> bitemyapp: IOE?
16:44:08 <Axman6> SwashBuckla: sure.
16:44:35 <SwashBuckla> Axman6: so.. I'm just wondering what direction to head in
16:44:44 <Axman6> From memory the result of arbitrary can is a type with an Alternative instance, so you can use:
16:45:08 <bitemyapp> merijn: intensional / observational / extensional
16:45:53 <SwashBuckla> Axman6: 'arbitrary can'?
16:45:59 <Axman6> arbitrary = pure Empty <|>  (Single <$> arbitrary <*> arbitrary) <|> (Append <$> arbitrary <*> arbitrary <*> arbitrary)
16:46:15 <Axman6> _I think_
16:46:32 <SwashBuckla> what is <|> here?
16:46:47 <SwashBuckla> alternative?
16:46:49 <Axman6> @hoogle (<|>)
16:46:49 <lambdabot> Control.Applicative (<|>) :: Alternative f => f a -> f a -> f a
16:46:49 <lambdabot> Text.Parsec.Prim (<|>) :: (ParsecT s u m a) -> (ParsecT s u m a) -> (ParsecT s u m a)
16:46:50 <lambdabot> Text.ParserCombinators.Parsec.Prim (<|>) :: (ParsecT s u m a) -> (ParsecT s u m a) -> (ParsecT s u m a)
16:46:59 <SwashBuckla> oh, nifty
16:47:01 <Axman6> hmm, that's probably not right actually
16:47:04 <merijn> bitemyapp: Right, that discussion :)
16:47:13 <greymalkin> Is there a way to set a single field on a `data` structure (non-lens based)?
16:47:19 <Axman6> what is the point of the m by the way?
16:47:40 <bitemyapp> merijn: I don't really understand CoC or predicativity either.
16:47:48 <Axman6> if there are some constraints on how m can work, then you might need to use smart constructors to ensure you produce valid trees
16:48:22 <SwashBuckla> Axman6: I need it to be Sized and a Monoid
16:48:53 <SwashBuckla> Axman6: line 25 shows a sample data https://github.com/spanners/cis194/blob/master/Course/answers/07-folds-monoids/JoinList.hs#L25
16:49:21 <SwashBuckla> so I essentially want to generate trees like that
16:50:28 <merijn> bitemyapp: CoC is not that hard, afaict
16:50:53 <merijn> bitemyapp: It's just the "combine everything" corner of the lambdacube + inductive families?
16:51:10 <merijn> oh and maybe the infinite hierarchy of kinds
16:51:19 <bitemyapp> merijn: I was going to ask about the kinds.
16:51:30 <bitemyapp> merijn: worse-is-better lambda calculus? :P
16:52:54 <merijn> How so?
16:54:33 * hackagebot geodetic 0.1.3 - Geodetic calculations  http://hackage.haskell.org/package/geodetic-0.1.3 (TonyMorris)
16:54:43 <bitonic> what was the lambdabot command to send a message to an offline person?
16:54:50 <hpc> @tell bitonic this
16:54:50 <lambdabot> Consider it noted.
16:54:54 <bitemyapp> merijn: I was being flippant
16:54:56 <bitemyapp> sorry
16:54:57 <bitonic> blah
16:55:02 <bitonic> hpc: thanks
16:55:26 <greymalkin> nevermind... found it -- tried it once and probably had a different error.
16:55:29 * monochrom wonders what is a worse lambda calculus and what is a better one
16:56:22 <Axman6> SwashBuckla: I'd recommend exposing a smart constructor like append :: JoinList m a -> JoinList m a -> Joinliad m a; append a b = JoinList (mappend (tag a) (tag b)) a b and then using that in the Arbitrary instance
16:56:36 <danilo2> hello! Could anyone explain to me why haskell complains that rthese type family instances are in conflict? type instance TraveralMorph base [a] = [TraveralMorph base a]    AND   type instance TraveralMorph base String = String    AND    type instance TraveralMorph base Char   = Char  ? They are not though ... :(
16:56:48 <ski> aphorisme : where ?
16:57:08 <cdk> danilo2: [a] and String conflict, since String ~ [Char]
16:57:50 <danilo2> cdk I know, still they mean the same - they shouln not conflict because they are telling the same, am i wrong?
16:57:55 <aphorisme> ski: here, when declaring name for example, http://www.jonmsterling.com/posts/2013-04-06-vinyl-modern-records-for-haskell.html
16:58:32 <chrisdone> did hackage…  change its passwords or something? i'm getting 401 when trying to upload
16:59:07 <SwashBuckla> Axman6: is `append` already presently defined in (+++)?
16:59:34 * hackagebot lucid 0.0 - Clear to write, read and edit DSL for HTML  http://hackage.haskell.org/package/lucid-0.0 (ChrisDone)
16:59:39 <chrisdone> \o/
17:00:04 <Axman6> SwashBuckla: oh, yes, sorry.
17:00:28 <Axman6> arbitrary = pure Empty <|>  (Single <$> arbitrary <*> arbitrary) <|> ((+++) <$> arbitrary <*> arbitrary)
17:00:35 <Axman6> hopefully that'll do what you want.
17:00:45 <Axman6> I assume that for your tests you only want valid trees
17:00:50 <SwashBuckla> yes
17:01:18 <Axman6> (you can write other tests to make sure that things like (+++) only produce valid trees if you want)
17:02:06 <ski> aphorisme : hm, it's a(n infix) type constructor, defined in some library
17:02:54 <Axman6> chrisdone: ooo, got a link to more details? you haven't listed a repo in the cabal file
17:02:59 * ski hand's Axman6 two `liftA2's
17:03:09 <Axman6> bleh, yes, thanks =)
17:03:31 <chrisdone> axman6: working on a blag post for it. i'll add the git link next version i push tho: https://github.com/chrisdone/lucid
17:03:32 <aphorisme> ski : how could be defined? Like type A ... ?
17:03:58 * Axman6 wants an function: applyArbitrarilly whiuch takes a function of n aerguments and applies it to arbitrary values
17:04:20 <Axman6> chrisdone: thanks, love your work =)
17:04:34 * hackagebot traverse-with-class 0.2.0.1 - Generic applicative traversals  http://hackage.haskell.org/package/traverse-with-class-0.2.0.1 (RomanCheplyaka)
17:04:34 <chrisdone> Axman6: <3
17:04:58 <chrisdone> ^ traverse-with-class is awesome
17:05:01 <ski> aphorisme : `type a ::: b = ...', or using `data' or `newtype'
17:05:33 <aphorisme> ski : thanks. This is new to me.
17:06:39 <bitonic> ImplicitParams galore
17:06:44 <bitonic> (traverse-with-class)
17:06:46 <Axman6> chrisdone: what happens when `with` is used infix? table_ `with` [rows_ 2] (tr_ ...)
17:07:35 <SwashBuckla> Axman6: wow that seems to have worked! Thankyou
17:07:52 <pharpend> how do I build my program so it's entirely statically linked?
17:07:58 <Axman6> SwashBuckla: might want to use verboseCheck to make sure it's producing results you're after
17:07:59 <SwashBuckla> I'll have to explore Alternative a bit as I've not seen it before
17:08:12 <pharpend> -staticlib in ghc doesn't work (apparently only supported on darwin)
17:08:13 <SwashBuckla> Axman6: ok, will do
17:08:20 <Axman6> > Just 'a' <|> Just 'b'
17:08:21 <lambdabot>  Just 'a'
17:08:21 <pharpend> -static doesn't do it
17:08:26 <ski> aphorisme : apparently defined in `Data.Vinyl.Universe.Field' at <https://hackage.haskell.org/package/vinyl>
17:08:33 <ski> aphorisme : .. using `data'
17:08:38 <Axman6> > Nothing <|> Just 'b'
17:08:39 <Welkin> > Nothing <|> Just 3
17:08:39 <lambdabot>  Just 'b'
17:08:40 <lambdabot>  Just 3
17:08:59 <Welkin> <|> is alternative?
17:09:02 <chrisdone> Axman6: that doesn't work
17:09:07 <chrisdone> Welkin: yeah
17:09:09 <Welkin> left-biased
17:09:44 <Axman6> chrisdone: yeah, thought it might not. might be possible to make it an infix op?
17:10:53 <aphorisme> ski : what is a bit confusing: "name" ::: String is a type, right? But "name" is an instance and String a type.
17:11:34 <Axman6> s/instance/value, is that what you meant?
17:11:41 <aphorisme> yes
17:11:52 <chrisdone> Axman6: i'm afraid not. i've an allergy to infix ops, part of the motivation of this lib is to avoid them like the plague
17:12:21 <indiagreen> aphorisme: I think it's a type-level literal and not a value
17:12:24 <pharpend> I tried following this - http://stackoverflow.com/questions/5953199/create-a-static-haskell-linux-executable
17:12:54 <indiagreen> https://downloads.haskell.org/~ghc/7.8.3/docs/html/users_guide/type-level-literals.html
17:13:13 <pharpend> I keep getting this error - http://lpaste.net/114662
17:13:41 <pharpend> dons and snoyberg were the belligerents of that SO thread, so you'd think it'd be trustworthy
17:13:57 <danilo2> hello! Could anyone explain to me why haskell complains that rthese type family instances are in conflict? type instance TraveralMorph base [a] = [TraveralMorph base a]    AND   type instance TraveralMorph base String = String    AND    type instance TraveralMorph base Char   = Char  ? They are not though ... :(
17:14:17 <HeladoDeBrownie> danilo2, type String = [Char]
17:14:31 <danilo2> I know that String is [Char] of course but this type families are NOT in conflict
17:14:34 <merijn> pharpend: You can't use -fvia-C in modern GHC
17:14:38 <aphorisme> indiagreen : whoa! Thanks.
17:14:50 <danilo2> HeladoDeBrownie: One is just more specific than other, isnt it?
17:14:54 <pharpend> ah
17:14:57 <merijn> pharpend: The via-C backend is deprecated and build for the default distribution, it's also bitrotted, so compiling GHC yourself won't help
17:15:11 <pharpend> i did compile ghc myself
17:15:17 <pharpend> but yeah
17:15:17 <merijn> --make is also deprecated
17:15:52 <HeladoDeBrownie> danilo2, I think it's a matter of them overlapping, which I believe is not permitted.
17:16:04 <merijn> Or rather, --make is not deprecated, but it's the default, so it's redundant
17:16:06 <merijn> So try without those two flags
17:16:21 <pharpend> merijn: searching the man page for 'static' reveals only '-static' and '-staticlib'
17:16:42 <pharpend> merijn: my current ghc-options field is     -Wall -O1 -static -optc-static -optl-static -optl-pthread
17:16:45 <merijn> Also the errors on line 12 and 13 imply that your library search path is broken
17:16:52 <monochrom> danilo2: I would just say that the compiler doesn't even bother expanding RHSes. if LHSes overlap, it already declares failure. as simple as that. there is no point arguing how much more AI we all want to add to compilers.
17:16:59 <danilo2> HeladoDeBrownie: hmm, so I cannot wrie a general rule in a file and more specific ones oin other files. hmm, that is kind of limitating I think :(
17:17:21 <danilo2> monochrom, HeladoDeBrownie: ok, thank you :)
17:17:24 <pharpend> merijn: here's what's happening how - http://lpaste.net/114663
17:17:32 <merijn> pharpend: Do you have static versions of gmp and ffi installed?
17:18:22 <merijn> If you do, they're not in your library path
17:19:56 <ski> aphorisme : "Vinyl is a general solution to the records problem in Haskell using type level strings and other modern GHC features, ..."
17:20:23 <aphorisme> I see.
17:20:24 <aphorisme> : )
17:21:39 <SwashBuckla> Axman6: I seem to have made a monster of a `sample` call
17:21:55 <SwashBuckla> `sample (arbitrary :: (Alternative Gen, Arbitrary m, Sized m, Monoid m, Arbitrary a) => Gen (JoinList m a))`
17:22:30 <fds4345> whats the function to see if 2 strings have a common prefix
17:23:23 <lpaste> SwashBuckla pasted “No instance for (Alternative Gen)” at http://lpaste.net/114664
17:23:31 <SwashBuckla> I am stuck at this error output from GHCI ^
17:23:32 <tsani> fds4345: well there's isPrefixOf
17:23:40 <tsani> @hoogle isPrefixOf
17:23:40 <lambdabot> Data.List isPrefixOf :: Eq a => [a] -> [a] -> Bool
17:23:40 <lambdabot> Data.ByteString isPrefixOf :: ByteString -> ByteString -> Bool
17:23:40 <lambdabot> Data.ByteString.Char8 isPrefixOf :: ByteString -> ByteString -> Bool
17:23:41 <ski> every pair of strings has `""' as common prefix
17:23:55 <fds4345> eeexcelent. thanks
17:24:03 <ski> @hoogle commonPrefix
17:24:03 <lambdabot> Data.Text commonPrefixes :: Text -> Text -> Maybe (Text, Text, Text)
17:24:03 <lambdabot> Data.Text.Lazy commonPrefixes :: Text -> Text -> Maybe (Text, Text, Text)
17:24:08 <SwashBuckla> Axman6: as far as I can tell, I am using an instance declaration for (Alternative Gen)...
17:24:31 <SwashBuckla> `sample (arbitrary :: (Alternative Gen, ...`
17:28:27 <fds4345> Am I correct in thikning that in ghci you cant play with the REPL inside a state monad
17:29:21 <fds4345> Would be good if ghci had a magic (IO ()) function that resumed the repl...
17:29:49 <SwashBuckla> yes that sounds neat, fds4345
17:30:22 <SwashBuckla> a project!
17:30:23 <indiagreen> wait, what exactly would it do?
17:30:34 <indiagreen> I want to understand neat things
17:30:58 <SwashBuckla> you could save the state of the REPL at the current moment
17:31:10 <SwashBuckla> and restore it in a future session of GHCI
17:31:24 <indiagreen> the state = defined functions?
17:31:40 <SwashBuckla> depends
17:32:09 <SwashBuckla> you might want to be more granular, e.g. the point in a datastructure
17:32:39 <fds4345> SwashBuckla: thats cool but its not what I meant
17:32:58 <fds4345> I just meant: runStateT resumeRepl thingy
17:33:14 <fds4345> StateT Int >>>
17:33:35 <fds4345> then ctrl-d would exiet that context and take you back to the last one
17:34:35 * hackagebot lucid 0.1 - Clear to write, read and edit DSL for HTML  http://hackage.haskell.org/package/lucid-0.1 (ChrisDone)
17:43:37 <merijn> SwashBuckla: What if your state is not saveable?
17:46:43 <gansteed> after install haskell-doc package, how can I read it?
17:48:44 <merijn> What is the haskell-doc package?
17:50:13 <gansteed> http://packages.ubuntu.com/trusty/haskell-doc
17:50:45 <gansteed> merijn: it contains haskell98-report and haskell98-tutorial
17:51:04 <HeladoDeBrownie> gansteed, /usr/share/doc contains them
17:51:33 <HeladoDeBrownie> gansteed, check "list of files" on the dependencies of that package and you'll see more specifically
17:52:23 <gansteed> HeladoDeBrownie: thanks
17:52:57 <gansteed> But I wonder is there some GUI application that can show these docs
17:53:15 <merijn> ah, linux silliness
17:54:31 <michaelt> gansteed: a browser will exhibit the haskell report to you https://www.haskell.org/onlinereport/haskell2010/
17:55:36 <HeladoDeBrownie> gansteed, you can feel free to access them using a graphical file manager and view them using a graphical web browser.
17:56:23 <michaelt> gansteed what kind of documentation are you looking for, though?
17:57:01 <gansteed> haskell98-report
17:57:34 <gansteed> I think you're right, browser is enough :D
17:57:49 <HeladoDeBrownie> gansteed, not to mention that's not the latest Haskell language report.
17:57:56 <HeladoDeBrownie> 2010 is more recent than 98.
17:59:54 <gansteed> thanks, I know it. I just wonder how can I use the haskell-doc package :D
18:01:08 <HeladoDeBrownie> I believe it's mostly meant to be used how I said – opening the files from that location using a browser.
18:02:34 <michaelt> gansteed: I think it will be html or pdf files buried in /usr/somewhere
18:03:04 <gansteed> HeladoDeBrownie: yes, you're right. but I think I should download the hasekll2010-report rather than install haskell-doc package
18:03:14 <HeladoDeBrownie> gansteed, that sounds reasonable.
18:06:50 <gansteed> michaelt: I've found it: /usr/share/doc/haskell98-tutorial and /usr/share/doc/haskell98-report
18:08:02 <michaelt> gansteed: strange no file ending, are they directories?
18:09:14 <gansteed> michaelt:  oh, I'm sorry. yes, it is directories
18:09:36 * hackagebot lucid 0.2 - Clear to write, read and edit DSL for HTML  http://hackage.haskell.org/package/lucid-0.2 (ChrisDone)
18:26:19 <begriffs> Question about monoids. If I have a tuple (a, b) where a and b are both monoids then I get a monoid instance for free. However if my type is (a, Bool) I don't because it's not defined for Bool. if I try to define an instance for Bool it is an orphan instance. If I try to define it for the tuple it is considered an overlapping instance. What can I do?
18:27:49 <HeladoDeBrownie> begriffs, there are "Bool" instances for Monoid, you just have to wrap the Bool. See http://hackage.haskell.org/package/base-4.7.0.1/docs/Data-Monoid.html#g:2
18:28:05 <dibblego> begriffs: the reason is because there are several possible Monoids for Bool, so Data.Monoid defines types like Any and All, which wrap Bool and define that specific Monoid.
18:29:37 <joehillen> welp this isn't good: https://gist.github.com/joehillen/751ebf8232e5131d5649#file-gistfile1-txt-L1997
18:30:09 <begriffs> Ah I see. So I'm using a library that has a function that expects exactly (a, Bool)...am I able to give it a (a, Any False)?
18:31:08 <kadoban> begriffs: No.
18:31:33 <kadoban> begriffs: You have to give it that and it expects it to be a Monoid? O.o
18:32:36 <begriffs> No it doesn't expect it. It's a database query where the tuple is the query, the params, and a bool saying whether it is allowed to prepare the statement. I'm building statements dynamically so I thought it would be handy to make a monoid.
18:33:34 <kadoban> begriffs: Well, you can probably still do that, but you have to do a bit of wrapping/unwrapping to add the newtype and then remove it.
18:34:17 <kadoban> If that's a good idea or not...I'm not sure. Someone better at haskell might know :)
18:36:17 <begriffs> OK, well it's good enough for now thanks.
18:41:02 <nshepperd> you can use coerce from Data.Coerce.Coercible to safely convert between (a, Bool) and (a, Any) without any runtime cost
18:41:22 <nshepperd> > coerce (True, False) :: (Any, Any)
18:41:23 <lambdabot>  Couldn't match expected type ‘Data.Monoid.Any’
18:41:23 <lambdabot>              with actual type ‘GHC.Types.Bool’
18:41:43 <nshepperd> boo
18:41:46 <tsani> Aren't newtypes zero cost though?
18:41:46 <nshepperd> :t coerce
18:41:47 <lambdabot> (Contravariant f, Functor f) => f a -> f b
18:41:53 <dfeuer> tsani, yes but.
18:42:01 <nshepperd> dammit lambdabot, you have the wrong coerce
18:42:19 <Zekka> nshepperd: That's a fun one too!
18:42:55 <dfeuer> tsani, the newtype conversion is free; traversing a Functor to apply the conversions is not. I've been working on adding map/coerce rules to various functors to help with that, but there are some remaining (including Vector).
18:43:10 <begriffs> Can I coerce in the other direction (Any -> Bool) as well?
18:43:26 <tsani> Ah! That makes sense. I hadn't considered it from that perspective.
18:43:37 <nshepperd> yep, you can wrap and unwrap newtypes, and tuples of newtypes with coerce
18:45:13 <dfeuer> nshepperd, which reminds me: unless we have map/coerce for tuples, we'd better add those rules.
18:46:47 <dfeuer> tsani, as of 7.10.1, you probably won't have to worry (in most cases) about mapping newtype wrap/unwrap over [], Array, Seq, Map, or IntMap.
18:47:11 <dfeuer> Joachim Breitner did a lot of work to get the lists working, and then kind of forgot to do the rest :P
18:47:27 <dfeuer> (which are easy given his underlying work)
18:47:42 <dfeuer> Except that Vector is ... not going to be easy.
18:49:10 <nshepperd> I'm not really familiar with how this works, but I assume there's more to it than "instance Coercible a b => Coercible (Vector a) (Vector b)"
18:49:36 <nshepperd> or are you talking about something else
18:49:57 <dfeuer> No, not at all.
18:50:10 <dfeuer> Because Coercible is *entirely pure magic*
18:50:17 <dfeuer> You can't define an instance of it.
18:50:20 <tsani> dfeuer: it wouldn't be possible to provide zero-cost newtype wrap/unwrap for arbitrary Functors, would it?
18:50:49 <dfeuer> tsani, it would, in theory, but there are "unlawful" Functor instances out there that would break in one way or another.
18:51:20 <dfeuer> nshepperd, I don't understand all the details, but the rules basically look like {-# RULES map coerce = coerce #-}
18:51:42 <dfeuer> These rules basically ignore the role stuff that normal Haskell code can't.
18:52:04 <k-u> what are some neat (haskell) projects that use quickcheck?
18:52:07 <nshepperd> hmm
18:52:14 <tsani> dfeuer: that's frustrating. Couldn't a pragma be used so that those with lawful instances can benefit from the zero-cost wrap/unwrap fmap ?
18:52:36 <dfeuer> nshepperd, Coercible is so magical that it's actually defined as a *datatype* and then the compiler *changes its kind*.
18:52:50 <nshepperd> o_O
18:53:12 <nshepperd> that's way too magical for me
18:53:19 <dfeuer> tsani, I think there's a ticket or two open. No one really knows the right way to do it yet.
18:53:35 <dfeuer> What we're doing so far is just making rules for various important functors.
18:54:10 <tsani> Right. The generalization is probably much less useful than having the rules exist for the big functors for now.
18:55:32 <dfeuer> tsani, the generalization would be very nice to have, but the existence of *barf* unlawful functors throws a monkey wrench into that nice idea. There are also some issues with simplifier phases that you might run into....
18:56:18 <tsani> I have no idea how GHC internally represents anything :) it just *seemed* possible
18:56:35 <tsani> What kind of horrible person writes unlawful functors!
18:57:13 <dfeuer> Edward Kmett has admitted to doing some similarly shady things from time to time, for weird internal efficiency reasons.
18:57:44 <tsani> I had a bet going with myself that his name would come up :)
18:58:26 <tsani> I wonder what kinds of problems, concretely, are solved with unlawful functors.
18:58:52 <dfeuer> But I don't know that he's evil enough to write the sorts of unlawful functors that would break such rules.
18:58:58 <dfeuer> He seems too kind for that.
19:00:14 <dfeuer> tsani, suppose you want an array that counts how many times each element has been changed. It looks a lot like a functor. It just isn't quite.
19:02:41 <tsani> Right. It wouldn't respect the composition functor law.
19:04:39 <dfeuer> tsani, wouldn't respect any functor laws.
19:04:52 <tsani> Oh
19:05:02 <tsani> Yeah, fmap id = id would break too.
19:05:17 <Zekka> You could always write a crappy Eq instance to compensate!
19:05:24 <tsani> :(
19:06:19 <dfeuer> Zekka, that's not a crappy thing to do. As long as you hide away all the non-functory stuff, you're good--unless some RULES mess things up...
19:06:42 <jolux> hello?
19:07:10 <Zekka> dfeuer: I would not actually do this because of RULES and because I don't think a functor defined that way, even if you wrap it like that, is really a functor
19:07:15 <chrisdone> jolux: Marco?
19:07:22 <Zekka> It doesn't make sense to count how many times you fmap over a thing
19:07:29 <Zekka> That's not the same as counting discrete operations
19:07:36 <Zekka> See i.e. composition law
19:08:00 <jolux> Ah sorry.
19:08:09 <Zekka> jolux: What's up?
19:08:20 <jolux> I forgot my nickserv password and couldn’t tell whether or not I had actually joined.
19:08:21 <jolux> My bad.
19:08:25 <jolux> I just lurk.
19:08:36 <jolux> you can ignore me
19:08:47 <dfeuer> Zekka, there's all sorts of other things that are/might be only functors up to isomorphism....
19:09:12 <Zekka> dfeuer: I don't think "really a functor" is a good way of putting it in retrospect
19:09:19 <dfeuer> Zekka, for example, you could decide to rebalance your tree as you traverse it with fmap.
19:09:31 <Zekka> It breaks the composition law but also it doesn't make very much sense
19:09:46 <Zekka> And you can define other structures like yours that have funny Eq instances and don't violate the composition law
19:09:59 <dfeuer> The rebalancing wouldn't break fmap/coerce rules though.
19:10:25 <dfeuer> The counted array was a hypothetical example.
19:10:47 <Zekka> What I meant with that last comic is that I think the counted array has other problems: it's not a great general example
19:10:53 <Zekka> comment*
19:11:02 <lifter> yeeee
19:11:39 <dfeuer> Zekka, I don't know of a good example of an unlawful Functor instance, because I don't think they're a good idea at all.
19:12:11 <Zekka> Really? I think your tree sounded fairly justifiable disregarding RULES
19:12:35 <dfeuer> Zekka, it's a Functor up to ==, and the RULES won't break it.
19:12:36 <Zekka> Although it also follows the laws if you use == for "fmap id == id"
19:13:57 <dfeuer> In fact, I can't *personally* come up with anything sufficiently whack to make any sense as a Functor instance that would be broken, but edwardk has a more twisted mind than I do, and reads code written by more lunatics.
19:14:08 <lifter> o
19:14:39 * hackagebot radian 0.0.1 - A floating-point wrapper for measurements that use radians.  http://hackage.haskell.org/package/radian-0.0.1 (TonyMorris)
19:14:50 <ReinH> you definitely can't count the number of times fmap is evaluated...
19:15:38 <edwardk> there are times when it it useful to follow the laws there in spirit, not letter
19:15:41 <kadoban> I thought the laws about those typeclasses weren't allowed to use Eq or whatever...isn't it supposed to mean that they're exactly the same, not that they're (==) ?
19:15:52 <edwardk> folks often 'quotient' the resulting type under their own interpretation
19:16:00 <Zekka> kadoban: If you're polite, usually!
19:16:02 <edwardk> e.g. adding a Map :: (a -> b) -> Foo a -> Foo b  -- constructor to their ADT
19:16:34 <kadoban> Okay, just checking.
19:16:51 <ReinH> Sure, but if you want to count the number of fmaps, the best you can say that your count will be meaningless.
19:17:11 <ReinH> Well, not meaningless. A glb.
19:17:21 <dfeuer> edwardk, if the thing is a functor up to ==, and everything respects that, won't it be safe for fmap/coerce?
19:17:27 <edwardk> the point is they should be able to not care about it
19:17:30 <edwardk> dfeuer: no
19:17:36 <dfeuer> edwardk, when not?
19:17:56 <edwardk> dfeuer: (==) is not part of the laws here, its whatever 'equivalence' notion they want to work up to
19:18:46 <dfeuer> edwardk, right, what I really meant was that if they have some ADT and it's equivalent up to that, that should be okay, right?
19:18:57 <edwardk> illegal instances exist, folks find them useful. we can talk at some point about ways to make an fmapCoerce that does the right thing that goes into the class, etc. but that actually turns out to be non-trivial to get right
19:18:57 <Litruv> Hey peeps, what
19:19:00 <Litruv> 's up
19:19:03 <edwardk> the obvious definition is insufficient
19:19:12 <dfeuer> You're not allowed to care how the tree is balanced, say.
19:19:17 <lifter> Anybody have a feel for how often in the Haskell community ViewPatterns is used? I recently discovered this language extension; I think it's pretty cool, and there are many places in my code I've discovered where I could use it, but I wonder if it would make my code less readable
19:19:42 <edwardk> they are allowed to do whatever the hell they want, you're trying to reason from outside of the set of invariants they have imposed about _all the sets of invariants anyone could ever impose_
19:19:46 <ReinH> lifter: I don't see it used that often, but that doens't mean that you shouldn't try it.
19:19:52 <edwardk> lifter: they aren't used much
19:20:03 <lifter> Really?
19:20:09 <lifter> Yeah I kinda like it
19:20:18 <HeladoDeBrownie> Isn't that extension new-ish?
19:20:22 <lifter> I don't think sio
19:20:34 <edwardk> lifter: they are occasionally nice, the problem is that the semantics of how much sharing you get on their computations is ill defined
19:20:44 <dfeuer> edwardk, what I'm suggesting is that as long as the thing is a functor *up to whatever equivalence they care about*, fmap/coerce won't break that.
19:20:58 <edwardk> foo (quux -> Just a) = ..; foo (quux -> Nothing) = ..   -- does that evaluate quux twice?
19:21:06 <dfeuer> It might, of course, break something outside that equivalence.
19:21:52 <dfeuer> edwardk, regarding view pattern semantics: I thought that was just me failing to understand the spec.
19:22:01 <lifter> I find that by refactoring my code to use ViewPatterns, most of my functions can be reduced by 1 or 2 lines. Especially functions that begin with "let x' = blah" where x' is just a revision of the binding x that I assign to a parameter passed in to said function
19:22:20 <edwardk> and my point is that what you propose could actually critically break code i have actually seen in the wild. if i 'record' the shape of a thing with one walk through it with a traversal and play it back with another, i need all the fmaps and (<*>)'s i saw along the way. you spot that i changed a newtype in one situation and don't spot it in the other and the
19:22:20 <edwardk> playback breaks
19:22:29 <edwardk> i use this in lens
19:22:57 <edwardk> i use the power of the functor /applicative laws and parametricity to know that you can't change the tree structure based on what instance i pass you
19:22:57 <HeladoDeBrownie> Haha, never mind, definitely not new. The page on them was made eight years ago
19:23:00 <edwardk> and i make up a bad functor
19:23:03 <edwardk> and then i use it
19:23:36 <edwardk> HeladoDeBrownie: viewpatterns are old, patternsynonyms are the new thing
19:23:55 * dfeuer is still trying to understand this interesting recording/playback thing.
19:24:08 <lifter> I also discovered pattern binds, which are neat as well.
19:24:18 <lifter> or bind patterns, I don't know which
19:24:24 <edwardk> my 'ad' package uses the same invariants. it can gather all the parts of a structure by traversing it once, and put them back into a shape by traversing it again
19:24:43 <edwardk> if i start having 'fmap's disappear out of some of these walks and not others, i can't do that
19:24:58 <lifter> Do you (anyone) think extensive use of ViewPatterns would make my code less readable?
19:25:12 <edwardk> think of it as me deliberately using all that shape data you say i can't care about
19:25:21 <dfeuer> edwardk, I think I get the vague gist.
19:25:28 <edwardk> but i'm offering this up as a case where what i'm relying on is that the _consumer_ of the abstraction can't care what i use
19:25:41 <edwardk> its in negative position so the power of the abstraction is flipped on its head
19:25:51 <dfeuer> The what?
19:26:09 <dfeuer> Negative position?
19:26:19 <edwardk> 'contravariant'
19:26:27 <edwardk> (->) is contravariant in its first argument, covariant in its second
19:26:38 <edwardk> we say something covariant is 'positive'
19:26:48 <edwardk> and you flip signs when you go to the left of a (-.)
19:26:50 <edwardk> er (->)
19:27:12 <dfeuer> I (sort of) understand covariant vs. contravariant functors. What the terms mean in any other context is totally beyond me.
19:27:26 <edwardk> a -> b  has a in negative position, b in positive position   on the other hand (a -> r) -> r -- has a in 'positive' position, its been negated twice, and r occurs in both positive and negative position
19:28:38 <dfeuer> OK, so what's in negative position that flips the power of the abstraction on its head (whatever exactly that means)?
19:29:13 <gcganley> if i wanted to get into parsing and lexing in haskell but have had
19:29:15 <P4Titan> Hello all, I want to implement the Eq class on my own custon data. I want to do somethign where (==) = funEq, (/=) = not . funEq but haskell does not like my function composition. Why does that happen?
19:30:09 <dfeuer> P4Titan, you can't just use (.) like that for a two-argument function.
19:30:16 <HeladoDeBrownie> P4Titan, it's ill-typed. You're saying to apply not to funEq after it's been applied to one argument, but there's another one missing before you  can apply not to it
19:30:26 <dfeuer> not . funEq = \x -> not (funEq x)
19:30:30 <gcganley> if i wanted to get into parsing and lexing in haskell but had no experiece with parsing nor lexing should i read a tutorial in haskell or a general book about parsing and lexing
19:30:37 <kadoban> P4Titan: You only have to define one or the other, by the way. (/=) has a default based on (==)
19:30:39 <dfeuer> So (not . funEq) x y = not (funEq x) y
19:30:56 <HeladoDeBrownie> gcganley, one particular to Haskell is fine; especially since Haskell has a peculiar way of doing parsing
19:31:07 <P4Titan> Ok, so function composition only works on single arg funcions
19:31:14 <dfeuer> edwardk, what's in negative position?
19:31:16 <HeladoDeBrownie> P4Titan, that's not true
19:31:30 <HeladoDeBrownie> P4Titan, do you understand how to do type unification?
19:31:41 <P4Titan> define unification :)
19:31:59 <dfeuer> P4Titan, function composition works for multiple-argument functions, but it does so in a single-argument sort of way.
19:32:08 <dibblego> P4Titan: all functions in haskell are single arg functions
19:32:17 <P4Titan> true
19:32:24 <dfeuer> @pl \x y -> not (x == y)
19:32:24 <lambdabot> (/=)
19:32:25 <kadoban> P4Titan: Haskell only has functions that take a single argument :) So even if you were right, it would work on everything :)
19:32:33 <dfeuer> That was not helpful, lambdabot.
19:32:35 <dibblego> (there are zero exceptions to this rule  you can rely on it completely)
19:32:38 <P4Titan> Could you give me an example
19:32:58 <dfeuer> @pl \x y -> fish (x == y)
19:32:59 <lambdabot> (fish .) . (==)
19:33:03 <dfeuer> There we go.
19:33:05 <tsani> dfeuer: pl is the essence of wisdom.
19:33:10 <HeladoDeBrownie> P4Titan, "type unification" is a whole term. It consists of deciding which types and type variables in a given expression/program should be "equal".
19:33:21 <MP2E> is it? pl seems more like the essence of confusion to me :P
19:33:42 <MP2E> i've seen some pretty horrid things come out of it x.x
19:33:44 <tsani> MP2E: precisely. If you can understand pl's output reliably, you have achieved true enlightenment.
19:33:50 <MP2E> haha fair enough
19:34:05 <gcganley> HeladoDeBrownie: do you suggest any in particular?
19:34:08 <dfeuer> So what lambdabot is, cryptically, saying, is that we could write your function as  (/=) = (not .) . funEq  if we wanted to confuse everyone.
19:34:17 <P4Titan> Helado: what do you mean by "equal"
19:34:21 <L8D> I've achieved true enlightenment
19:34:23 <HeladoDeBrownie> P4Titan, for example, when you apply id 'a', you are using id :: a -> a and 'a' :: Char and one type unification rule says that when you apply a function to a value, that value's type must unify with the type of the type to the left of ->.
19:34:24 <L8D> that's nice to know
19:34:42 <gcganley> l8D: how did you manage that?
19:34:48 <HeladoDeBrownie> gcganley, I think Real World Haskell has a chapter on it if I recall. You can also read Parsec's tutorial.
19:34:58 <P4Titan> like dynamic type
19:35:05 <gcganley> is Parsec really the best library out there?
19:35:10 <L8D> gcganley: one second, making a meme
19:35:22 <gcganley> L8D: NO!
19:35:26 <HeladoDeBrownie> P4Titan, I don't know what you mean by that.
19:35:27 <gcganley> L8D: STOP!
19:35:36 <Pamelloes> What's the difference between (f .) . (==) and f . (==)?
19:35:58 <P4Titan> where a takes the type of the passing argument, like if you pass a Char, a becomes a char
19:36:00 <HeladoDeBrownie> gcganley, it depends on what you want. It is good for jumping into parsing with Haskell though, I'd say.
19:36:01 <gcganley> :t (id .) . (==)
19:36:02 <lambdabot> Eq a => a -> a -> Bool
19:36:09 <gcganley> :t f . (==)
19:36:09 <lambdabot> (FromExpr c, Typeable a, Eq a) => a -> c
19:36:25 <gcganley> :t (f .) . (==)
19:36:25 <lambdabot> (FromExpr c, Eq a) => a -> a -> c
19:36:37 <HeladoDeBrownie> P4Titan, well, the type checker essentially writes the equation a = Char (although we actually write a ~ Char). If it doesn't find any equations to contradict that, the expression type checks
19:36:47 <gcganley> :t id . (==)
19:36:48 <lambdabot> Eq a => a -> a -> Bool
19:37:08 <HeladoDeBrownie> P4Titan, e.g., if you tried to write id 'a' :: Integer, it would complain because it tried to assume the contradictory constraints a ~ Char and a ~ Integer
19:37:21 <Pamelloes> So they're the same for id but not for "f"?
19:37:29 <dfeuer> Pamelloes, the more illuminating opposite of @pl is @pointy
19:37:29 <HeladoDeBrownie> Pamelloes, what is f?
19:37:51 <Pamelloes> HeladoDeBrownie: No idea, but lambdabot clearly knows...
19:38:04 <L8D> gcganley: ok so I can't find the right picture
19:38:19 <Pamelloes> @pointy (fish .) . (==)
19:38:19 <lambdabot> (\ d g -> fish (d == g))
19:38:22 <HeladoDeBrownie> Pamelloes, oh, that's a thing from some package to help visualize function application through use of a convenient Show instance.
19:38:34 <L8D> gcganley: but you know that one scene from the Matrix where the guy is like:
19:38:40 <Pamelloes> @pointy fish . (==)
19:38:40 <lambdabot> (\ c -> fish ((==) c))
19:38:48 <gcganley> L8D: the spoon kid
19:38:51 <L8D> "at first it's all jibberish"
19:39:01 <Pamelloes> Huh.... Well then.
19:39:11 <L8D> "but after a while, you see foo, bar, baz, etc."
19:39:13 <Pamelloes> :t .
19:39:13 <lambdabot> parse error on input ‘.’
19:39:16 <Pamelloes> :t (.)
19:39:17 <lambdabot> (b -> c) -> (a -> b) -> a -> c
19:39:21 <L8D> the dude who stares at the green stuff
19:39:30 <gcganley> L8D: the operator
19:39:40 <L8D> gcganley: anyways I was gonna make a meme from that quote about @pl output
19:39:42 <P4Titan> Could you give me an example of type unification
19:39:51 <L8D> gcganley: that's how I achieved enlightenment
19:40:05 <L8D> "< tsani> MP2E: precisely. If you can understand pl's output reliably, you have achieved true enlightenment."
19:40:14 <HeladoDeBrownie> P4Titan, I did above, but we can try another. Say you want to type check not . not.
19:40:17 <HeladoDeBrownie> @type not
19:40:18 <lambdabot> Bool -> Bool
19:40:18 <HeladoDeBrownie> @type (.)
19:40:19 <lambdabot> (b -> c) -> (a -> b) -> a -> c
19:40:21 <Pamelloes> L8D: You can do that D: I salute you!
19:40:29 <Pamelloes> *do that?
19:40:44 <L8D> yeah I had this weird "point-free everything!" period
19:41:04 <L8D> so my scripts were a single declaration of main
19:41:08 <HeladoDeBrownie> P4Titan, so, we're using not as both the first and second argument to (.), so the types of those must unify for this to be correct. I.e., (b -> c) must unify with (a -> b).
19:41:21 <L8D> now I can comprehend anything!
19:41:25 <HeladoDeBrownie> P4Titan, more specifically we have not :: Bool -> Bool, so both of those are Bool -> Bool, which indeed unifies
19:41:27 <Pamelloes> L8D: Like... one liners? MY head is hurting just thinking about that
19:41:36 <Pamelloes> :t fish
19:41:36 <lambdabot> Not in scope: ‘fish’
19:41:41 <P4Titan> So, they just have to agree
19:42:02 <L8D> Pamelloes: they would be stretched across multiple lines, just there were no variables other than main
19:42:02 <Pamelloes> What's a simple function with two inputs?
19:42:10 <L8D> (+)
19:42:13 <L8D> > 1 + 1
19:42:15 <lambdabot>  2
19:42:17 <L8D> :D
19:42:17 <Pamelloes> Thanks
19:42:20 <HeladoDeBrownie> P4Titan, yes. So, we set all of a, b, and c to Bool in the process, which means we now also know what the output will be: It's a -> c, so Bool -> Bool in this example.
19:42:21 <Pamelloes> :t (+)
19:42:22 <lambdabot> Num a => a -> a -> a
19:42:28 <Pamelloes> :t ((+) .)
19:42:29 <lambdabot> Num b => (a -> b) -> a -> b -> b
19:42:33 <HeladoDeBrownie> P4Titan, now let's try the thing you mentioned above that didn't work. What was it again?
19:42:35 <ReinH> P4Titan: specifically, we have (Bool -> Bool) -> (Bool -> Bool) -> (Bool -> Bool) ~ (b -> c) -> (a -> b) -> (a -> c), which unifies when a ~ Bool, b ~ Bool, c ~ Bool
19:43:43 <P4Titan> not . funEq where funEq was Val -> Val -> Bool
19:43:43 <HeladoDeBrownie> P4Titan, ah, it was  not . (==) where (==) :: Foo -> Foo -> Bool
19:43:47 <HeladoDeBrownie> Yeah that
19:43:56 <HeladoDeBrownie> Okay
19:44:09 <HeladoDeBrownie> So again let's look at the types of not and (.)
19:44:11 <HeladoDeBrownie> @type not
19:44:12 <lambdabot> Bool -> Bool
19:44:13 <HeladoDeBrownie> @type (.)
19:44:14 <lambdabot> (b -> c) -> (a -> b) -> a -> c
19:44:20 <P4Titan> ok
19:44:46 <HeladoDeBrownie> So since not is the first argument, we have (b -> c) ~ (Bool -> Bool)
19:44:51 <HeladoDeBrownie> Right? Understand that part?
19:45:20 <P4Titan> yes
19:46:03 <HeladoDeBrownie> Okay, so then we also want to unify (a -> b) ~ (Val -> Val -> Bool)
19:46:12 <HeladoDeBrownie> Let's write parens to make this clearer
19:46:19 <HeladoDeBrownie> Okay, so then we also want to unify (a -> b) ~ (Val -> (Val -> Bool))
19:46:25 <HeladoDeBrownie> Oop, copied too much :P
19:46:40 <HeladoDeBrownie> So, a ~ Val and b ~ (Val -> Bool)
19:46:49 <HeladoDeBrownie> Ah, but we hit a snag!
19:46:57 <ReinH> Oh no, not a snag!
19:47:01 <HeladoDeBrownie> Remember how (b -> c) ~ (Bool -> Bool)?
19:47:05 <HeladoDeBrownie> So b ~ Bool
19:47:08 <P4Titan> b has to be bool
19:47:22 <HeladoDeBrownie> So we're asserting that b is two different instantiated types
19:47:28 <HeladoDeBrownie> which makes the type checker sad
19:47:40 <P4Titan> yes
19:48:03 <P4Titan> so (a -> b) is the type of a function taking 1 arg
19:48:06 <HeladoDeBrownie> And that is the problem you ran into with the thing you originally posted
19:48:13 <cjenkin1> You'd have to curry funEq in this case, yes?
19:48:32 <P4Titan> and since funEq takes 2, it expects b to be a function that returns a function that takes 1 arg
19:48:41 <solatis> what's this ~ operator ?
19:48:45 <P4Titan> but in the not, b was Bool and that does not match
19:48:54 <solatis> i haven't seen it before
19:48:57 <cjenkin1> solarus: it's a way of saying "these types are equivalent"
19:49:01 <solatis> oh
19:49:05 <cjenkin1> it doesn't exist in Haskell proper AFAIK
19:49:16 <cjenkin1> Just useful for equational reasoning
19:49:22 <solatis> it's early over here, i'm not fully awake yet
19:49:39 <HeladoDeBrownie> cjenkin1, it does, actually, but is rarely used
19:49:47 <cjenkin1> HeladoDeBrownie: Ah. shows what I know
19:49:49 <solatis> what would it be useful for?
19:49:50 <HeladoDeBrownie> At least in GHC Haskell afaik
19:50:00 <P4Titan> Thanks brownie ice cream
19:50:06 <HeladoDeBrownie> No problem :)
19:50:15 <solatis> to enforce some sort of static typing?
19:50:20 <cjenkin1> solatis: Probably rewrite rules, used for performance
19:50:25 <solatis> gotcha
19:50:46 <solatis> but, then, why not just say (Bool -> Bool) instead of (b -> c) ?
19:51:04 <P4Titan> b and c are type variables i believe
19:51:06 <cjenkin1> :t (.)
19:51:06 <lambdabot> (b -> c) -> (a -> b) -> a -> c
19:51:15 <ReinH> https://downloads.haskell.org/~ghc/7.4.2/docs/html/usersguide/equality-constraints.html
19:51:16 <cjenkin1> solatis: ^
19:51:26 <FofG> I think I'm missing something basic about one of the questions from Week 5 of the Yorgey course
19:51:35 <cjenkin1> :t (.) not
19:51:36 <lambdabot> (a -> Bool) -> a -> Bool
19:51:39 <ReinH> ~ is the "equality constraint" type operator
19:51:42 <solatis> ReinH: 404 ?
19:51:48 <FofG> it asks you to create type class called Expr with functions that mirror the ExprT constructors
19:52:14 <solatis> ReinH: nvm, google helped
19:52:16 <ReinH> That's an older GHC anyway. Try https://downloads.haskell.org/~ghc/latest/docs/html/usersguide/equality-constraints.html
19:52:39 <ReinH> (the only change was the addition of Coercible though)
19:53:02 <solatis> ok.
19:53:10 <solatis> thanks, i learned something again
19:53:20 <solatis> and i feel like i will never have to use it unless i'm developing a library :)
19:53:41 <ReinH> probably not
19:53:50 <ReinH> I have never used equality constraints
19:54:00 <ReinH> But I'm sure edwardk could tell you all about them
19:54:05 <edwardk> ?
19:54:15 <solatis>                 mapTuple :: (a -> b) -> (a, a) -> (b, b)
19:54:17 <ReinH> edwardk: !
19:54:20 <solatis> would that be a proper candidate?
19:54:21 <edwardk> they are useful
19:54:45 <solatis> because a ~ b
19:54:47 <edwardk> what is the question?
19:54:57 <ReinH> solatis: but that's not true
19:55:04 <ReinH> a and b can be different types
19:55:04 <solatis> yeah you are correct
19:55:13 <solatis> that would be a very limited implementation
19:55:15 <ReinH> edwardk: when is ~ useful
19:55:27 <gcganley> on a scale of 1 to 10 how daughting is making a haskell bash-like shell interpreter
19:55:41 <ReinH> Usually when you're doing something with type families that make unification undecideable?
19:55:53 <ReinH> gcganley: Well, there have been attempts...
19:56:18 <solatis> hmm
19:56:20 <edwardk> (~) is a constraint, like Show, Ord, etc. when show is brought into scope it can be used to call show, showsPrec, etc. When a ~ b is brought into scope then the typechecker can use a as b and vice versa
19:56:21 <ReinH> @google haskell hell shell
19:56:22 <lambdabot> https://github.com/chrisdone/hell
19:56:22 <solatis> a lazy shell
19:56:27 <solatis> i wonder how that will work
19:56:39 <edwardk> instance a ~ Char => IsString [a]  -- for instance would be a nicer way to implement the IsString String instance.
19:56:40 <edwardk> why?
19:56:42 <nshepperd> I remember seeing a few of things on hackage with like a "(Foo a ~ b) => blah b"
19:56:42 <ReinH> solatis: as little as possible, presumably
19:56:42 <gcganley> ReinH: i know about Shelly and Hell but i was just thinking of using it as a way of learning Haskell
19:56:51 <nshepperd> instead of "blah (Foo a)"
19:56:51 <solatis> ReinH: zing!
19:56:55 <edwardk> right now if you call 'length "foo"' with overloaded strings turned on you get a type error
19:56:56 <edwardk> why?
19:57:16 <ReinH> gcganley: Writing a shell involves a lot of stuff that has very little bearing on functional programming...
19:57:32 <edwardk> it doesn't know that "foo" is a string. it just knows that its IsString a for some choice of 'a', then you go to call length on it, and length tells you it must be [a] for some choice of a
19:57:37 <edwardk> but then the compiler gets stuck
19:57:41 <edwardk> nothing tells it to pick Char
19:57:49 <gcganley> ReinH: Oh :/ pitty i wanted my shell to know if i wanted to tab complete commands or files
19:58:02 <edwardk> with the above instance the moment we refine to [a] we get to know for free that a ~ Char must hold
19:58:06 <nshepperd> ohh
19:58:08 <edwardk> it comes out of the context of the instance
19:58:18 <edwardk> another example: _every_ GADT.
19:58:21 <ReinH> gcganley: (various shells do that already, ofc)
19:58:38 <gcganley> ReinH: i need to branch out from bash...
19:58:41 <edwardk> data Is a b where Refl :: Is a a
19:58:47 <ReinH> gcganley: zsh? fish?
19:58:59 <gcganley> ReinH: theres a shell called fish
19:59:03 <edwardk> secretly that uses Refl :: (a ~ b) => Is a b
19:59:04 <ReinH> Indeed
19:59:06 <gcganley> this cant be real
19:59:10 <gcganley> @google fish shell
19:59:11 <lambdabot> http://fishshell.com/
19:59:11 <lambdabot> Title: fish shell
19:59:15 <gcganley> god damn
19:59:31 <cjenkin1> edwardk: that's heterogeneous equality, right?
19:59:50 <cjenkin1> or no, just equality between types
19:59:51 <edwardk> type equality
19:59:55 <cjenkin1> gotcha
20:00:13 <solatis> fish shell is actually pretty awesome
20:00:19 <gcganley> ReinH: "you'll never write esac again", SOLD!
20:00:58 <cjenkin1> edwardk: Wait, so you're saying GADTs use ~ in the background for instantiating their type arguments with specific choices?
20:00:59 <solatis> gcganley: now only if we would never had to write "snoc" anymore i would be a happy man
20:01:04 <cjenkin1> That's pretty neat
20:01:15 <gcganley> solatis: snoc?
20:01:17 <gcganley> :t snoc
20:01:18 <lambdabot> Snoc s s a a => s -> a -> s
20:01:21 <gcganley> huh
20:01:22 <cjenkin1> gcganley: reverse cons
20:01:23 <cjenkin1> xD
20:01:26 <solatis> it's the reverse of cons
20:01:40 <gcganley> how could you reverse a cons...
20:01:46 <gcganley> remove the head?
20:01:48 <solatis> :t cons
20:01:48 <lambdabot> Cons s s a a => a -> s -> s
20:01:54 <cjenkin1> gcganley: Append to the end
20:01:56 <numberten> add to the end
20:01:59 <gcganley> oh ok
20:02:15 <nshepperd> > unsnoc [1, 2, 3]
20:02:17 <lambdabot>  Just ([1,2],3)
20:02:18 <edwardk> cjenkin1: yep
20:04:16 <gcganley> > uncons [1, 2, 3]
20:04:17 <lambdabot>  Just (1,[2,3])
20:04:37 <gcganley> :g unsnoc
20:04:43 <edwardk> gcganley: i used to run an old fidonet clone called fishnet back in the day ;)
20:05:02 <edwardk> re: fish
20:05:04 <gcganley> edwardk: what the hell is fidonet...
20:05:10 * edwardk feels old
20:05:25 <gcganley> edwardk: dude im still in high school
20:05:30 <ReinH> gcganley: Except that I don't write esac. I write case and tab complete. ;)
20:05:38 <edwardk> http://en.wikipedia.org/wiki/FidoNet
20:06:17 <ReinH> edwardk: holy crap you are so old
20:06:30 <gcganley> edwardk: WHAT IS THIS?
20:06:54 <gcganley> this shit was made 4 years before i was born
20:06:57 <edwardk> gcganley: it was easier than throwing messages at each other on stone tablets
20:07:25 <edwardk> we tried that first, but after too many injuries they made us stop
20:07:32 <gcganley> edwardk: the original instant message
20:07:42 <cjenkin1> edwardk: and imagine, you'd have to etch drawings on our tablets just to send pictures
20:08:01 <cjenkin1> s/our/your/
20:08:09 <gcganley> 28.8 kbs holy moly the blazing speed
20:08:12 <solatis> fidonet apparently is an artifact of a neckbeard generation
20:08:41 <edwardk> gcganley: it was. i got started at 300/1200bps =P
20:09:09 <solatis> :)
20:09:13 <solatis> my first modem was 2400bps
20:09:30 <gcganley> my first modem was 15mb/5mb
20:09:36 <gcganley> awkward
20:09:43 <edwardk> you haven't lived until you've paid $6/hour to connect to compuserv to play a damned roguelike.
20:09:51 <solatis> haha
20:09:54 <edwardk> http://en.wikipedia.org/wiki/Island_of_Kesmai
20:09:54 <solatis> anyone remembers BRE?
20:10:17 <solatis> https://en.wikipedia.org/wiki/Barren_Realms_Elite
20:10:36 <solatis> i was so addicted to that
20:10:47 <benzrf> i have vague
20:10:48 <benzrf> distant
20:10:50 <gcganley> edwardk: this was PRE AOL?
20:10:51 <ReinH> I remember AOL used to have some MUDs...
20:10:53 <benzrf> foggy memories of compuserve
20:10:56 <gcganley> thats a thing...
20:11:04 <solatis> you could launch a missile to someone else, and i would take like 1 week for all the BBS'es to synchronize and for the missile to reach its target
20:11:21 <solatis> and then take another week to give you feedback
20:11:30 <edwardk> Kesmai ultimately went on to do a lot of the AOL games
20:12:14 <gcganley> 1 2/3 cents a command...
20:12:32 <edwardk> I did some work on a voxel character modeling engine with a guy who was working for Kesmai.
20:12:55 <kadoban> That brings back memories, I think Kesmai made a few games I used to play a lot
20:12:56 <edwardk> gcganley: i pretty much learned to program to feed my Island of Kesmai addiction, that is a _lot_ of shareware to write!
20:12:56 <gcganley> edwardk: did you nerd out on him?
20:13:22 <gcganley> edwardk: was it scripted language of compiled mods
20:13:27 <edwardk> gcganley: you'll eventually learn that i'll "nerd out" on everyone ;)
20:14:19 <gcganley> edwardk: how was the meetup btw, i didnt get to go to it but im determined to make it to the next one
20:14:42 <edwardk> it compiled static models down to a dense bytecode that could be interpreted at something like 8 cpu cycles / voxel to play them back on a z-buffer
20:16:06 <gcganley> edwardk: was it from that era why youre into the opengl bindings you're writing now?
20:16:10 <edwardk> gcganley: this last boston haskell was pretty epic actually
20:16:46 <edwardk> gcganley: back in the day i used to have to write my own rasterizers, etc. nowadays its pretty easy =)
20:16:55 <edwardk> like embarassingly so
20:17:06 <gcganley> edwardk: is there an age min?
20:17:27 <gcganley> i would feel awkward being the lower bound by like 5 years
20:17:35 <edwardk> nah, you're fine
20:18:03 <dfeuer> edwardk, I was hoping you'd tell me what it is you put in a negative position, and how that turns abstraction power "upside down".
20:18:06 <benzrf> gcganley: i came to a hackathon in august and it was fine
20:18:10 <edwardk> we had benzrf show up at the hackathon, so you're probably not the lowest
20:18:11 <edwardk> yeah
20:18:13 <benzrf> you're probably good
20:18:32 <gcganley> benzrf: are you still in highschool?
20:18:36 <benzrf> ye
20:18:37 <edwardk> and we've had at least two people bring actual babies ;)
20:18:44 <gcganley> benzrf: oh ok
20:19:02 <gcganley> benzrf: i have to drive up from sandwhich though
20:19:03 <edwardk> i don't think either baby got much out of the session though.
20:19:11 <Hijiri> any haskell events in socal?
20:19:24 <benzrf> gcganley: wtf is sandwhich
20:19:25 <gcganley> edwardk: hey no one groks monads their first go
20:19:31 <edwardk> fair nuff
20:19:34 <gcganley> benzrf: lol its a town on cap
20:19:37 <gcganley> *cpae
20:19:39 <gcganley> fuck
20:19:41 * hackagebot coordinate 0.0.17 - A representation of latitude and longitude  http://hackage.haskell.org/package/coordinate-0.0.17 (TonyMorris)
20:19:44 <gcganley> s/cap/cape
20:20:07 <gcganley> hey nothing is wrong with sandwich!
20:20:11 <dfeuer> edwardk, did you see the question?
20:20:20 <edwardk> dfeuer: no
20:20:44 <dfeuer> Oh. I was asking *what* is in a negative position, and how that turns abstraction power upside down (whatever that means)
20:21:39 <edwardk> dfeuer: https://github.com/ekmett/lens/blob/master/src/Control/Lens/Internal/Magma.hs#L62 is what i 'compile' your traversal into
20:21:58 <edwardk> i build it by using an evil Applicative: https://github.com/ekmett/lens/blob/master/src/Control/Lens/Internal/Magma.hs#L124
20:22:30 <gcganley> edwardk: how are applicatives evil?
20:22:40 <edwardk> this particular one is evil
20:22:47 <edwardk> not a value judgment on applicatives in general
20:22:51 <edwardk> some of my best friends are applicative
20:23:00 <dfeuer> Why do you need #. here?
20:23:17 <gcganley> benzrf: you have the best website
20:23:46 <houshuang> Don't really understand the code style here. Why all the parenthesis? And lambdas. Is this generated code? https://github.com/glutamate/probably-baysig/blob/master/src/Target/Heston.hs
20:24:00 <edwardk> dfeuer: the #. isn't materially relevant
20:24:04 <dfeuer> OK.
20:24:38 <dfeuer> edwardk, clearly you're talking about the MagmaFmap constructor.
20:24:50 <edwardk> MagmaFmap is built 'illegally' by Molten
20:25:00 <HeladoDeBrownie> houshuang, I hope so, I would consider that poorly styled
20:25:08 <edwardk> once you have a magma you'll note i respect the laws
20:25:12 <gcganley> edwardk: naughty boy!
20:25:21 <edwardk> but the construction extracts information i shouldn't be able to get
20:25:40 <edwardk> Magma lets me do things like write 'fair' interleaved traversals
20:25:56 <edwardk> > ("hello","world")^..both.traverse
20:25:57 <lambdabot>  "helloworld"
20:26:02 <edwardk> > ("hello","world")^..levels (both.traverse).traverse
20:26:03 <lambdabot>  Ambiguous occurrence ‘levels’
20:26:03 <lambdabot>  It could refer to either ‘Control.Lens.Level.levels’,
20:26:03 <lambdabot>                           imported from ‘Control.Lens’ at L.hs:47:1-43
20:26:03 <lambdabot>                           (and originally defined in ‘lens-4.1.2:Control.Lens...
20:26:03 <lambdabot>                        or ‘Data.Tree.levels’,
20:26:10 <edwardk> > ("hello","world")^..Control.Lens.levels (both.traverse).traverse
20:26:11 <lambdabot>  "hweolrllod"
20:26:25 <dmj`> Yuras: ping
20:26:29 <edwardk> > ("hello","world")^..Control.Lens.taking 3 (levels (both.traverse)).traverse
20:26:30 <lambdabot>  Ambiguous occurrence ‘levels’
20:26:30 <lambdabot>  It could refer to either ‘Control.Lens.Level.levels’,
20:26:30 <lambdabot>                           imported from ‘Control.Lens’ at L.hs:47:1-43
20:26:30 <lambdabot>                           (and originally defined in ‘lens-4.1.2:Control.Lens...
20:26:30 <lambdabot>                        or ‘Data.Tree.levels’,
20:26:31 <Axman6> edwardk: wut o.O
20:26:34 <trap_exit> when devloping haskell, is 27" lcd vs 15" mbp different in terms of productivity?
20:26:44 <edwardk> > ("hello","world")^..taking 3 (Control.Lens.levels (both.traverse)).traverse
20:26:45 <lambdabot>  "hw"
20:26:51 <trap_exit> edwardk: what's your haskell setup?
20:27:00 <edwardk> > ("hello","world")^..Control.Lens.levels (both.traverse)
20:27:00 <trap_exit> edwardk: do you use a 15" mbp, or do you develop on a large screen ?
20:27:01 <lambdabot>  [Zero,Zero,Two 0 (One () 'h') (One () 'w'),Two 0 (One () 'e') (One () 'o'),T...
20:27:02 <HeladoDeBrownie> Whenever I see traverse.traverse or similar I think of the Chacha slide. Maybe we need a Haskell slide?
20:27:03 <dfeuer> Sorry, edwardk, I don't know what those actually mean.
20:27:15 <edwardk> trap_exit: 13" mbp, and a big screen
20:27:31 <trap_exit> edwardk: so you do find the 13" too small and want to use an external monitor?
20:27:36 <edwardk> 'levels' lets me extract the levels of applicative use
20:27:36 * Axman6 uses a 32" 4k monitor... but it's not necessary to have anything that large
20:27:44 <trap_exit> edwardk: do you use more than one terminal when coding? or is it just one big emacs window?
20:27:53 <trap_exit> Axman6: we'll care about your opinions when you've wrirtten half of cabal
20:27:54 <gcganley> Axman6: i wouldnt be able to handle all of that
20:27:56 <edwardk> trap_exit: actually i'd probably switch back down to the 11" macbook air next time i switch machines
20:28:00 <trap_exit> Axman6: I'm kidding :-)
20:28:08 <edwardk> trap_exit: the portability is more important to me than the screen
20:28:18 <trap_exit> edwardk: sure, but do you need an large external montiir to code; or can you code on a 13" / 11" screen ?
20:28:21 <edwardk> i'd hoped the 13" pro would be a good compromise, but the weight is enough that i prefer the air
20:28:29 <Axman6> gcganley: yeah, some kind of tiling becomes necessary
20:28:32 <gcganley> trap_exit: most of the time i code in a 80x24 terminal, thats all you really need
20:28:44 <edwardk> i code on the 11" screen fine. i usually dump stuff like irc, reference docs, etc. on the other monitors
20:28:50 <gcganley> Axman6: im the lone guy in this channel that uses i3 and not xmonad
20:29:00 <dfeuer> Can't you get a monitor that stretches to whatever size you need and locks in place with a tap?
20:29:10 <Axman6> edwardk: 11" is only ok for you because you code with your eyes closed
20:29:19 <dfeuer> Axman6++
20:29:21 <gcganley> ^
20:29:27 <Axman6> I don't use xmonad, I use Window tidy (a mac app)
20:29:46 <gcganley> Axman6: i use Arch :/
20:29:48 <dfeuer> edwardk, so which what is in negative position?
20:29:50 <edwardk> Axman6: technically i can. well, i did work with blind users back in the day. i can still read braille / know how to use a screen reader ;)
20:29:52 <trap_exit> edwardk: oh, so you rmbp is your coding monitor, and the external monitor is your 'distractions' monitor ?
20:30:32 <edwardk> dfeuer: *sigh* https://github.com/ekmett/lens/blob/master/src/Control/Lens/Level.hs#L82
20:30:39 <trap_exit> TIL: edwardk codes on his iphone, using the sound to generate morse code instead of reading the screen
20:30:40 <Axman6> edwardk: ha
20:30:47 <dibblego> dfeuer: "negative position" means the same as "contravariant position" and this has a relationship to the Contravariant type-class. class Contravariant f where contramap (b -> a) :: f a -> f b
20:31:18 <gcganley> :t swap
20:31:19 <lambdabot> (a, b) -> (b, a)
20:31:19 <dfeuer> dibblego, the question was *what* was sitting in that position that somehow made things okay.
20:31:21 <dibblego> in the type (b -> a), it is the (b) that is in negative position
20:31:30 <dibblego> dfeuer: ok
20:31:31 <gcganley> is swap in negitive position?
20:31:41 <gcganley> i dont know what im talking about
20:31:58 <edwardk> dfeuer: in general lens does a lot of things where it 'exposes a lot of type information' in negative position, in the arguments o the combinators that consume lenses, this enables the combinators to work with more lens types, by leaking more information they become more general. its contradictory, but only insofar as contravariance is always that way
20:32:02 <dfeuer> Oh, there's a big comment.
20:32:06 <dibblego> in the type (a, b) -> (b, a) the (a) and (b) are invariant  appearing in both negative and positive positions
20:32:52 <gcganley> it almost sounds as though 'negitive position' is 'the type that is returned by the function
20:32:53 <gcganley> '
20:32:55 <dfeuer> edwardk, yes, I know that more specific stuff in these negative positions gives more generality.
20:33:32 <dfeuer> Sort of know.
20:33:50 * dfeuer goes off to read.
20:34:18 * gcganley goes to sleep now
20:42:09 <nshepperd> 'negative position' in curry howard isomorphism is the premises of an implication
20:42:46 <nshepperd> "foo implies bar" -- if foo is more specific, the statement is more frequently true
20:51:29 <benzrf> l8r
20:51:30 <benzrf> sleeping
21:13:05 <Welkin> if I setup nginx to serve my static files through a reverse proxy on S3, do I need to change anything in my yesod settings?
21:13:28 <Welkin> or will the request never reach yesod?
21:13:46 <Welkin> it seems likely
21:16:08 <dmj`> it will never reach yesod, the reverse proxy intercepts it
21:16:39 <dmj`> why not just use cloudfront urls tho?
21:17:06 <Welkin> sorry, I am new to all of this server stuff
21:17:14 <Welkin> yeah, I could use cloudfront
21:17:19 <dmj`> cloudfront propogates your static files to all amazon regions, its a personal cdn
21:17:25 <Welkin> just another thing to learn along with all the other aws junk
21:17:38 <Welkin> anyway, hm
21:17:46 <Welkin> it still looks like I need to do something in yesod
21:17:55 <Welkin> to override the static routes...
21:18:00 <Welkin> http://www.yesodweb.com/blog/2010/08/static-file-optimizations
21:18:06 <Welkin> this blog post is not helpful enough though
21:18:28 <Welkin> and the yesod book skips right over it, just saying "it's possible", but never showing an example
21:18:59 <dmj`> the web server should know what environment its in then choose to serve files based on that
21:19:19 <dmj`> if prod serve cloudfront cdn else static dir
21:19:43 * hackagebot mono-traversable 0.6.3 - Type classes for mapping, folding, and traversing monomorphic containers  http://hackage.haskell.org/package/mono-traversable-0.6.3 (MichaelSnoyman)
21:19:47 <dmj`> heist templates make it easy to do that
21:20:01 <Welkin> you mean in nginx?
21:21:39 <dmj`> you can use nginx to serve your static files for you yes, but if your html is generated dynamically then the yesod web server should handle those requests, things like css and js (static assets) can be sent via nginx
21:23:59 <Welkin> yes
21:24:13 <Welkin> I am only serving js/css/fonts through s#
21:24:15 <Welkin> S3
21:24:29 <Welkin> everything else is from the yesod app
21:26:51 <dmj`> nice
21:27:05 <Welkin> this is all terribly frustrating for me
21:27:27 <Welkin> getting yesod deployed and running behind nginx
21:28:40 <Welkin> well, another problem is that yesod needs to know how where the static files are
21:28:42 <DANtheBEASTman> I built purescript with cabal, but my shell can't find the binary.. is there a PATH i'm supposed to add?
21:28:47 <Welkin> because some of them are included programmatically
21:29:07 <dmj`> if yesod isn't serving them why does it care
21:29:14 <dcoutts_> DANtheBEASTman: ~/.cabal/bin
21:29:30 <DANtheBEASTman> ahha, tyvm dcoutts_
21:32:17 <dmj`> Welkin: if your javascript / css is dynamically generated on each request then nginx can't serve it alone
21:33:57 <Welkin> oh, I know
21:34:09 <Welkin> I am serving the libraries on S3
21:34:20 <Welkin> the small amount of custom css/js is served by yesod
21:34:28 <Welkin> but that it built in to the binary
21:34:34 <Welkin> along with the html templates
21:35:11 <Welkin> although I don't know how the tmp directory works if serving from a remote location...
21:35:37 <Welkin> perhaps I misunderstand
21:49:44 * hackagebot http-client-auth 0.1.0.1 - HTTP authorization (both basic and digest) done right  http://hackage.haskell.org/package/http-client-auth-0.1.0.1 (MiguelMitrofanov)
21:54:44 * hackagebot radian 0.0.2 - A floating-point wrapper for measurements that use radians.  http://hackage.haskell.org/package/radian-0.0.2 (TonyMorris)
22:14:45 * hackagebot egison 3.3.15 - Programming language with non-linear pattern-matching against unfree data  http://hackage.haskell.org/package/egison-3.3.15 (SatoshiEgi)
22:22:08 <diracdeltafunk> @pl \mark sb -> any (all ((flip elem)  (filter.(==) mark sb)))
22:22:08 <lambdabot> ((any . all . flip elem . (filter .)) .) . (==)
22:22:47 <diracdeltafunk> @pl \mark sb -> any (all ((flip elem)  (filter.(==) mark sb))) wc
22:22:47 <lambdabot> flip flip wc . ((any . all . flip elem . (filter .)) .) . (==)
22:24:24 <Axman6> chrisdone: How come Attr in lucid has a Builder and a Text? seems strange the two parts differ. also I would've assumes the attr name would be the text and the value the builder
22:27:40 <diracdeltafunk> @pl \wc mark sb -> any (all ((flip Map.member)  (Map.filter.(==) mark sb))) wc
22:27:40 <lambdabot> flip (flip . ((any . all . flip Map.member) .) . Map.filter. (==))
22:33:08 <L8D> DANtheBEASTman: what
22:37:21 <diracdeltafunk> @pl flip (flip.((any.all.flip Data.Map.Lazy.member).).Data.Map.Lazy.filter.(==)) [[]]
22:37:21 <lambdabot> flip flip [[]] . ((any . all . flip Data.Map.Lazy.member) .) . Data.Map.Lazy.filter. (==)
22:40:31 <DANtheBEASTman> L8D: no worries, figured it out
22:45:35 <L8D> DANtheBEASTman: no I mean what
22:45:38 <L8D> as in... your nick
22:51:30 <DANtheBEASTman> it's supposed to be sort of ironic. but I am a beast at drums
22:55:38 <sgronblo> makes me think about Dan Severn
23:49:08 <mrenaud__> Is there an easy way to completely reinstall everything with cabal? I'm trying to compile with profiling and it keeps complaining about stuff not having profiling enabled.
23:50:49 <Hijiri> you can unregister packages by deleting ~/.ghc
23:51:15 <Hijiri> when you go to install something again it'll reinstall from scratch
23:51:29 <Hijiri> unless there are global packages coming from somewhere else, like distro packages
23:51:57 <mrenaud__> I'll try that. There shouldn't be distro packages other than ghc (I'm on Arch)
23:53:14 <mrenaud__> Also, will having everything installed with profiling support have any performance impact even if it's turned off?
