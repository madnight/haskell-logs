00:08:45 <solatis> anyway, next up: unicode
00:09:03 <solatis> almost as bad as timezones :)
00:10:49 <solatis> why isn't there a Data.Text.Encoding.encodeAscii
00:11:01 * hackagebot shared-buffer 0.2 - A circular buffer built on shared memory  http://hackage.haskell.org/package/shared-buffer-0.2 (JohnLato)
00:11:01 * hackagebot sws 0.1.0.1 - A simple web server for serving directories, similar to weborf.  http://hackage.haskell.org/package/sws-0.1.0.1 (DerekElkins)
00:15:41 <bergmark> solatis: perhaps because it's not a safe operation?
02:21:34 --- topic: 'http://www.haskell.org/ | Paste code/errors: http://lpaste.net/new/haskell | Logs: http://tunes.org/~nef/logs/haskell/?C=M;O=D http://ircbrowse.net/day/haskell/today?mode=recent | Administrative issues: #haskell-ops | Hackage status? http://status.haskell.org'
02:21:34 --- topic: set by glguy on [Thu Sep 25 17:55:19 2014]
02:24:08 <adas> how would i approach number to sum of digits in number?
02:26:26 <lieven> adas: something like sum . map digitToInt . show ?
02:30:39 <adas> thanks
02:32:09 <nkar> is there a simpler way to write \(a,_,_) -> a?
02:33:04 <y> > view _1 ('a', 'b', 'c')
02:33:06 <lambdabot>  'a'
02:33:33 <nkar> lens, yay!
02:33:36 <y> but I don't think adding lens as a dependency for that is worth it
02:33:45 <nkar> y: thanks anyway
02:33:52 <y> > sum . map digitToInt $ "1234"
02:33:54 <lambdabot>  10
02:42:41 <Ephexeve> Hey guys, I am trying to install base version 4.6 but I am getting this -> https://bpaste.net/show/282cb69208a9
02:43:41 <Saizan> Ephexeve: you can only use the base that came with your ghc
02:45:35 <Ephexeve> hm
02:45:49 <Ephexeve> Is there anywhere I can get 4.6 ghc for osx?
02:46:14 <kadoban> Ephexeve: ? wouldn't that be super old?
02:46:32 <Ephexeve> well, it would, but the thing I need to run requires that
03:01:02 * hackagebot alarmclock 0.1.0.1 - Wake up and perform an action at a certain time.  http://hackage.haskell.org/package/alarmclock-0.1.0.1 (dcturner)
03:14:32 <Aruro> please take a look at this short code http://lpaste.net/114234
03:14:58 <Aruro> is there a way to get rid from dummy argument serving as a variable storage?
03:15:36 <Fuuzetsu> write it with an inner function
03:16:53 <Aruro> inner you mean inside wrap?
03:17:04 <Fuuzetsu> yes
03:17:24 <Aruro> will it be shorter?
03:17:30 <Aruro> or more elegant? :)
03:18:20 <Fuuzetsu> it's only as elegant as you make it
03:19:20 <Aruro> hm extra function will definitely add more code
03:20:07 <bn>  @pl \xs n -> take n xs
03:20:24 <Fuuzetsu> flip take
03:20:38 <bn> @pl \x -> 4*(1-x)*x
03:20:38 <lambdabot> (*) =<< (4 *) . (-) 1
03:20:39 <Aruro> if there would be a way to remember the first value of the arguments
03:21:17 <Aruro> what is @pl?
03:21:58 <bn> wait
03:22:17 <Fuuzetsu> point-free
03:22:28 <bn> im trying to convert expressions to pointfree, and the wiki said i had to type @pl
03:23:22 <bn> @pl \f x -> f x x
03:23:22 <lambdabot> join
03:24:11 <bn> @pl \f g a -> (f a, g a)
03:24:11 <lambdabot> liftM2 (,)
03:25:33 <bergmark> @type [liftM2 (,), (&&&)]
03:25:34 <lambdabot> (Arrow a, Monad (a b)) => [a b a1 -> a b a2 -> a b (a1, a2)]
03:30:42 <tero-_> I get "thread blocked indefinitely in an MVar operation" inside: modifyMVar $ \v -> catch ( ..do http request.. ) ( ..handle http exception..) . I get a StatusCodeException and then it crashes. any ideas how to debug this?
03:36:03 * hackagebot cprng-aes 0.6.1 - Crypto Pseudo Random Number Generator using AES in counter mode.  http://hackage.haskell.org/package/cprng-aes-0.6.1 (VincentHanquez)
03:40:09 <tero-_> oops nevermind. it came elsewhere
04:03:49 <fds4345> Can't figure out how to pass a lens as an argument for use in: a0 & b .~ (a1 ^. b). It either complains about b not being a setter or not being a getter
04:04:33 <Fuuzetsu> you might need to write down the specific type
04:05:29 <cchalmers> I think you can do using ^# and #~ from Control.Lens.Loupe
04:14:48 <fds4345> Fuuzetsu: When I do that it complains about Identity i vs Const i i in `f`
04:15:46 <Fuuzetsu> post actual code, we can't read minds
04:17:14 <cchalmers> fds4345: is this what you want: https://github.com/diagrams/diagrams-pgf/blob/master/src/Graphics/Rendering/PGF.hs#L676
04:21:05 * hackagebot shakespeare 2.0.2 - A toolkit for making compile-time interpolated templates  http://hackage.haskell.org/package/shakespeare-2.0.2 (MichaelSnoyman)
04:22:19 <fds4345> Fuuzetsu: https://gist.github.com/anonymous/275521876714c538284e
04:22:52 <fds4345> cchalmers: looks like it!
04:28:22 <scooby> list
04:31:06 * hackagebot list-t 0.2.5 - ListT done right  http://hackage.haskell.org/package/list-t-0.2.5 (NikitaVolkov)
04:36:06 * hackagebot language-puppet 1.0.1 - Tools to parse and evaluate the Puppet DSL.  http://hackage.haskell.org/package/language-puppet-1.0.1 (SimonMarechal)
04:38:25 <osa1> how is unboxed bool vectors held internally?
04:42:16 <cchalmers> osa1: as words
04:43:18 <cchalmers> osa1: Word8 even http://hackage.haskell.org/package/vector-0.10.12.1/docs/src/Data-Vector-Unboxed-Base.html
04:51:06 * hackagebot list-t 0.2.6 - ListT done right  http://hackage.haskell.org/package/list-t-0.2.6 (NikitaVolkov)
04:53:51 <osa1> hm, I may need a bitfield version but let's start with Word8
04:56:07 * hackagebot hasql 0.1.5 - A minimalistic general high level API for relational databases  http://hackage.haskell.org/package/hasql-0.1.5 (NikitaVolkov)
04:56:09 * hackagebot hasql-postgres 0.3.1 - A "PostgreSQL" backend for the "hasql" library  http://hackage.haskell.org/package/hasql-postgres-0.3.1 (NikitaVolkov)
05:01:07 * hackagebot securemem 0.1.4 - abstraction to an auto scrubbing and const time eq, memory chunk.  http://hackage.haskell.org/package/securemem-0.1.4 (VincentHanquez)
05:01:09 * hackagebot hasql-postgres 0.3.2 - A "PostgreSQL" backend for the "hasql" library  http://hackage.haskell.org/package/hasql-postgres-0.3.2 (NikitaVolkov)
05:09:31 <dramforever> Hi, does anyone know if there's a binary equivlant to System.Process.readProcess?
05:09:50 <dramforever> I mean, a version that returns a Data.ByteString.ByteString
05:11:08 * hackagebot postgresql-binary 0.2.3 - Encoders and decoders for the PostgreSQL's binary format  http://hackage.haskell.org/package/postgresql-binary-0.2.3 (NikitaVolkov)
05:11:36 <lieven> dramforever: System.Process.ByteString.readProcess :)
05:11:45 <dramforever> which package?
05:12:00 <dramforever> well, is that a joke again?
05:12:11 <BoR0> why not use pack?
05:12:22 <lieven> process-listlike
05:12:27 <lieven> no joke
05:12:46 <dramforever> BoR0: Maybe the program outputs binary data
05:36:08 * hackagebot shakespeare 2.0.2.1 - A toolkit for making compile-time interpolated templates  http://hackage.haskell.org/package/shakespeare-2.0.2.1 (MichaelSnoyman)
05:38:04 <dramforever> Sorry for the disconnect. Thanks for process-listlike
05:44:29 <clrnd> http://research.cs.washington.edu/zpl/comicbook/comicbook.html
05:46:18 <fds4345> anyone know a library for exclusive containers? ie container for one, many, or all of n elements
05:46:58 <dramforever> fds4345: Didn't quite understand that
05:47:57 <fds4345> like Either on crack. So you could have an Exclusive5 which holds One, Many, or All of it's elements.
05:48:30 <dramforever> fds4345: what does "on crack" mean
05:49:25 <augur> dramforever: intensified
05:49:33 <fds4345> in this case, more betterer!
05:49:40 <dramforever> okay
05:50:11 <dramforever> what does "all of it's elements" mean?
05:50:19 <augur> crack is an extremely powerful stimulant, known for making people more intense, i guess you could say, so people use it (and other similar drugs) to describe a kind of extreme intensification
05:50:29 <dramforever> all of what's elements?
05:50:49 <augur> i agree tho, fds4345: can you elaborate?
05:51:05 <fds4345> the elements of the container which is on crack
05:51:17 <fds4345> are the elements also on crack? who can say
05:51:35 <dramforever> can you give an example?
05:52:27 <dramforever> like...it would be great if you can give concrete examples of Exclusive5?
05:52:35 <dramforever> ? -> .
05:53:40 <fds4345> data Exclusive2 a b = OneOf2 (Either a b) | AllOf2 a b
05:54:36 <fds4345> data Exclusive3 a b = OneOf3 (Either a (Either b c)) | SomeOf3 (Maybe a) (Maybe b) (Maybe c) | AllOf3 a b c
05:54:54 <fds4345> dramforever: ^^
05:55:28 <dramforever> fds4345: I assume you wanted data Exclusive3 a b c =...
05:55:36 <dramforever> Why not just SomeOf3 work?
05:55:43 <BoR0> let's first try to understand Exclusive2. isn't AllOf2 a b the same union type as Either a b?
05:55:45 <fds4345> sorry yes
05:55:50 <BoR0> s/union/sum/
05:56:40 <BoR0> right, it's not. it's a product type. my bad
05:57:16 <HeladoDeBrownie> fds4345, what's the use case? It's entirely possible a different, existing structure will suit your needs
05:57:18 <dramforever> why not just Exclusive3 a b c = BlahThinkOfABetterConstructorName a b c work?
05:58:31 <fds4345> HeladoDeBrownie: Because I need to be able to merge a new type b into an existing container of (Maybe a, Maybe b, Maybe c) and then perform an action only if I have all of a, b and c
05:58:44 <fds4345> HeladoDeBrownie: y dulce de leche?
05:59:34 <HeladoDeBrownie> fds4345, so why not pattern match on (Just a, Just b, Just c)?
05:59:38 <HeladoDeBrownie> fds4345, sí lo soy :)
06:00:46 <fds4345> HeladoDeBrownie: genius
06:00:57 <fds4345> its... so simple...
06:01:11 <dramforever> hmm...
06:01:59 <kqr> have I misunderstood something or are lpastes editable by anyone, and as such not very safe long-term (or even short-term) storage?
06:02:20 <MP2E> editing makes a second copy i thought
06:02:24 <MP2E> i haven't tried it though.
06:02:28 <kqr> but with the same ID
06:02:30 <kqr> which is weird
06:02:35 <MP2E> o.O
06:03:11 <HeladoDeBrownie> Either way, isn't the original still available?
06:03:15 <greymalkin> Is there an inverse to fmap? I find myself using it a lot, but it feels like the arguments are in the wrong order.
06:03:19 <HeladoDeBrownie> I seem to recall having seen annotations added to my pastes
06:03:22 <kqr> HeladoDeBrownie, I don't know how to access it, which worries me
06:03:31 <greymalkin> I want to think "do this monadic thing, then 'bind' it to this pure thing"
06:03:32 <HeladoDeBrownie> kqr, what's the edited lpaste?
06:03:48 <kqr> HeladoDeBrownie, annotations and edits are two different things
06:03:50 <dramforever> greymalkin: you can always have your own, like this
06:03:58 <HeladoDeBrownie> greymalkin, when you say "inverse", do you just mean that has type (Functor f) => f a -> (a -> b) -> f b?
06:04:02 <BoR0> greymalkin, can you not combine "flip" ?
06:04:08 <HeladoDeBrownie> greymalkin, I don't know specifically of one but flip fmap should serve
06:04:19 <dramforever> > let (<$:>) = flip fmap in Just 1 <$:> (+1)
06:04:20 <lambdabot>  Just 2
06:04:21 <HeladoDeBrownie> kqr, oh, okay.
06:04:57 <bergmark> greymalkin: perhaps =<< will feel more natural to you
06:09:23 <clrnd> so pastes are immutable
06:10:48 <Fuuzetsu> lpaste is written in Haskell and everyone knows you can't change things with Haskell ;^)
06:13:02 <dramforever> Wow, I was impressed again by haskell. I just wrote a program that fetches haskell code from a redis server and compiles and runs them (don't worry, it's run locally)
06:13:31 <Fuuzetsu> wget foo | ghc ?
06:13:33 <Fuuzetsu> ;P
06:13:34 <dramforever> After I finished writing it and fixing a few errors, it magically worked!
06:13:39 <dramforever> Fuuzetsu: well, about that
06:13:46 <dramforever> It just worked!
06:13:51 <tdammers> Fuuzetsu: I'd use curl, but heh
06:13:53 <Fuuzetsu> yes, things tend to just work
06:14:11 <Fuuzetsu> tdammers: so would I, just got the dumb and didn't want to point out the mistake. Thanks!
06:14:23 <tdammers> also, wget 1.16, symlinks, shenanigans
06:15:12 <dramforever> And even with lots of error handling with case's it's only 65 lines
06:15:35 <dramforever> well, Either Reply (Maybe a) is a bit hard to chain...
06:15:43 <tdammers> 65 lines of Haskell is like what, a kernel
06:15:58 <tdammers> also, EitherT ftw
06:16:06 <dramforever> oh, IO (Either Reply (Maybe a))
06:16:18 <dramforever> That's what hedis has for me
06:16:26 <tdammers> EitherT Reply MaybeT IO a -- :D
06:16:32 <Fuuzetsu> yes, EitherT
06:16:42 <Fuuzetsu> well, there's ExceptT now which is probably better for IO
06:17:16 <dramforever> I hate this IO (Either Reply (Maybe a)) appearing everywhere
06:17:30 <Fuuzetsu> use what tdammers said and use a type alias
06:18:19 <Fuuzetsu> also your Either seems flipped
06:18:27 <dramforever> no
06:18:30 <Fuuzetsu> normally result goes in Right, exception/error/whatever Left
06:18:42 <dramforever> Reply is the raw, "errorful" reply
06:18:46 <Fuuzetsu> ah
06:19:02 <dramforever> (Maybe a) is the cooked reply
06:19:25 <Fuuzetsu> sure
06:19:30 <Fuuzetsu> you shouldl still use EitherT/ExceptT
06:19:33 <Fuuzetsu> should*
06:20:35 <dramforever> I hate hedis for not exporting liftRedis
06:20:56 <dramforever> no way do instance Monad ThatThing
06:21:00 <dramforever> do -> to
06:21:08 <dramforever> Monad -> MonadRedis
06:21:23 <Fuuzetsu> MonadRedis a = Identity (Redis a) ;P
06:21:41 <Fuuzetsu> or do you want to go other way
06:21:55 <dramforever> maybe I'll do it on my own
06:22:10 <wei2912> just curious, do you prefer the Maybe monad or the list monad for handling either 0 or 1 values?
06:22:23 <Fuuzetsu> Redis is not Monad or anything
06:22:27 <dramforever> it is
06:22:32 <dramforever> it's a monad
06:22:32 <Fuuzetsu> wei2912: Maybe
06:22:32 <wei2912> lol
06:22:38 <wei2912> Fuuzetsu: me too
06:22:39 <Fuuzetsu> dramforever: not according to Hackage
06:22:43 <tdammers> everything is a monad
06:22:49 <wei2912> :P
06:22:53 <dramforever> Fuuzetsu: ??
06:22:59 <dramforever> but no way to do IO in Redis
06:23:03 <Fuuzetsu> http://hackage.haskell.org/package/redis-0.13.0.1/docs/Database-Redis-Redis.html#t:Redis
06:23:10 <dramforever> so runRedis everywhere
06:23:12 <dramforever> ha!
06:23:21 <dramforever> We are not talking about the same thing
06:23:25 <dramforever> @hackage hedis
06:23:25 <lambdabot> http://hackage.haskell.org/package/hedis
06:23:33 <Fuuzetsu> oh
06:23:56 <Fuuzetsu> what's the problem again?
06:24:13 <dramforever> Fuuzetsu: me?
06:24:26 <Fuuzetsu> yeah, what was that about MonadRedis and lifting?
06:24:36 <dramforever> not exported
06:24:45 <dramforever> otherwise I have no problem
06:25:18 <dramforever> let's make a newtype Blah a = Blah { runBlah :: IO (Either Reply (Maybe a)) }
06:25:33 <dramforever> and make it a monad
06:25:54 <Fuuzetsu> you should put Redis inside your stack and lift it out when you need it I guess
06:26:26 <dramforever> newtype Blah a = Blah { runBlah :: Redis (Either Reply (Maybe a)) }
06:26:59 <dramforever> Fuuzetsu: ^^ is that correct?
06:27:14 <Fuuzetsu> there is no transformer stack going on here ;P
06:27:50 <dramforever> Fuuzetsu: because hedis operations are like Redis (Either Reply (Maybe a)) everywhere
06:28:03 <clrnd> everything should be a MonadTrans, until a better abstraction makes us look stupid
06:28:53 <Fuuzetsu> right, so you'd make your own liftRedis which unwraps enough of your stack to get at Redis
06:29:04 <Fuuzetsu> and you should make way to the hedis issue tracker and ask for RedisT or whatever you need
06:36:11 * hackagebot HarmTrace-Base 1.4.0.1 - Parsing and unambiguously representing musical chords.  http://hackage.haskell.org/package/HarmTrace-Base-1.4.0.1 (BasDeHaas)
06:51:11 * hackagebot hs-mesos 0.20.0.2 -   http://hackage.haskell.org/package/hs-mesos-0.20.0.2 (IanDuncan)
06:55:28 <anandaji> how can I quikly construct a value of type UTCTime?
06:55:40 <clrnd> getCurrentUTCTime
06:55:51 <clrnd> getCurrentTime*
06:56:29 <anandaji> But that is IO I guess, can't I construct a value with read or something? how does a String have to look like?
06:57:23 <clrnd> :t parseTime
06:57:24 <lambdabot> Not in scope: ‘parseTime’
06:58:04 <clrnd> UTCTime :: Day -> DiffTime -> UTCTime
06:58:11 <clrnd> fromGregorian makes a Day
06:58:19 <clrnd> and DiffTime I can't remember
06:58:31 <clrnd> > fromGregorian 2014 11 13
06:58:32 <lambdabot>  Not in scope: ‘fromGregorian’
06:59:06 <anandaji> mhm okay
06:59:25 <bolmar> secondsToDiffTime
06:59:26 <clrnd> oh you can provide it as an Int
06:59:38 <clrnd> docs: the time from midnight, 0 <= t < 86401s (because of leap-seconds)
07:00:05 <clrnd> UTCTime (fromGregorian year month day) seconds
07:00:41 <anandaji> clrnd: Thank you :)
07:01:01 <clrnd> no problem :)
07:01:41 <clrnd> is Data.Time suceptible to Y2K bugs?
07:03:04 <bananagram> I'm getting this error a lot: http://lpaste.net/8300312350091640832 anyone recognize it?
07:04:50 <michaelt> bananagram: you're in a sandbox? does  " cabal sandbox hc-pkg list  " show primitive etc. ?
07:05:36 <bananagram> uh, no
07:05:50 <bananagram> no, yes it does
07:06:52 <bananagram> I get it outside the sandbox too
07:07:00 <michaelt> hm, so it looks like the package registry says its there, but that the compiled libs themselves have been deleted?
07:09:20 <bananagram> why do you cay that?
07:09:31 <bananagram> I don't see why they'd be missing
07:10:25 <michaelt> bananagram: yeah, i was thinking it just wasn't loading them because they arent there, but that would be 'cannot find ...' I think, so I take it back
07:15:37 <michaelt> bananagram: is it that some things were compile with shared libraries, others not?
07:19:34 <benzrf> edwardk: y are you ekmett on github but edwardk on irc
07:19:39 <benzrf> why dont you
07:19:41 <benzrf> unify your identities
07:20:21 <michaelt> benzrf: you are thinking there is only one Edward Kmett, clearly
07:20:41 <clrnd> there can only be one
07:20:57 <EvanR> glad clrnd said it so i dont have to
07:21:58 <michaelt> If there were only one Edward Kmett, there wouldn't be so many libraries. It's just common sense, really.
07:22:26 <tdammers> I think Edward Kmett forked himself
07:22:51 <clrnd> so it's just Amdahl's law
07:23:54 <latk> for people using emacs, how does ghc-mod compare to hdevtools ?
07:25:50 <benzrf> michaelt: shit
07:25:55 <benzrf> why did i never think of this
07:25:58 <benzrf> oh wow
07:25:59 <benzrf> >We can even do things like use the combinator
07:25:59 <benzrf>  
07:25:59 <benzrf> traverseLens :: ((c -> c) -> a -> b) -> a -> b
07:25:59 <benzrf> traverseLens f = f id
07:26:02 <benzrf>  
07:26:04 <benzrf> to project a Functor out through an appropriate lens family:
07:26:07 <benzrf>  
07:26:09 <benzrf> ghci> :t traverseLens (fstLens . sndLens)
07:26:12 <benzrf> traverseLens (fstLens . sndLens)
07:26:14 <benzrf> >  :: Functor f => ((a, f b), c) -> f ((a, b), c)
07:26:16 <lambdabot>  <hint>:1:1: parse error on input ‘::’
07:26:17 <benzrf> wow that is really reallly clever
07:31:47 <jophish> Yo yo yo
07:31:58 <jophish> I'm getting a bunch of errors along the lines of: warning: _stat64 from msvcrt is linked instead of __imp__stat64
07:32:50 <jophish> The package causing this is Shelly, or one of its dependencies
07:34:13 <McManiaC> just realized you can use WriterT to run monadic code inside a blaze-html document: http://npaste.de/p/X09LF/
07:34:14 <McManiaC> :)
07:39:17 <cdk> McManiaC: neat! btw, your (<!>) function can be written a little more succinctly as: f <!> m = mapWriter (second f) m
07:39:35 <McManiaC> o yeah :)
07:39:45 <mauketwork> mapWriter . second
07:39:54 <cdk> mauketwork: even better
07:41:01 <hs1> is there a better way to write  `... :: IO Bool >>= \succes -> if succes then liftM Just $ ...; else return Nothing`  ?
07:41:15 <hs1> it occurs quite a lot in my code
07:41:54 <kadoban> :t when
07:41:55 <lambdabot> Monad m => Bool -> m () -> m ()
07:42:11 <kadoban> Hmm, nevermind, ignore me...
07:42:17 <cdk> :t \m n -> m >>= \s -> if s then liftM Just n else return Nothing
07:42:19 <lambdabot> Monad m => m Bool -> m a1 -> m (Maybe a1)
07:43:12 <chrisdone> is there a way to make haddock only generate docs for one module for when writing docs?
07:43:26 <kadoban> hs1: If nothing else, you can just abstract it out into a function, no?
07:43:52 <hs1> yes, but it's in two modules
07:44:09 <hs1> i could create a util/helper module of course
07:46:22 <albeit> :t liftM Just
07:46:23 <lambdabot> Monad m => m a1 -> m (Maybe a1)
07:46:36 <albeit> :t return . Just
07:46:37 <lambdabot> Monad m => a -> m (Maybe a)
07:48:54 <EvanR> hs1: pull request to put in one of the many "missing and or useful utils" packages ;)
07:49:35 <hs1> haha
07:49:55 <hs1> and return . Just wont work, it wraps an IO result
07:50:55 <hs1> ... >>= return . Just   would, but hlint complains about that
07:51:33 <EvanR> this problem has many constrains ;)
07:51:48 <kadoban> hs1: What is its complaint with it?
07:52:39 <hs1> Test.hs:1:16: Warning: Use liftM
07:52:59 <hs1> but its more the `else return Nothing` that looks wrong to me
07:53:13 <EvanR> :t return . Just
07:53:14 <lambdabot> Monad m => a -> m (Maybe a)
07:53:18 <EvanR> :t liftM
07:53:19 <lambdabot> Monad m => (a1 -> r) -> m a1 -> m r
07:53:53 <hs1> this is the code: https://github.com/lennart96/haskell-channels/blob/master/Channel.hs#L29
07:54:09 <hs1> (warning: im very new to haskell)
07:55:07 <c_wraith> hs1: it's complaining about the ">>= return ." part
07:55:22 <clrnd> I don't know why but I'd use lambda-case and a case, not a fan of 'if'
07:55:33 <c_wraith> hs1: foo >>= return . bar is the same as fmap bar foo
07:56:07 <EvanR> hlint recommends liftM over fmap?
07:56:40 <clrnd> weird
07:56:45 <hs1> Channel.hs:30:14: Warning: Use <$>
07:56:50 <c_wraith> well...  not all instances of Monad are instances of Functor, at the moment
07:56:54 <clrnd> <$> is fmap
07:57:01 <clrnd> well, right
07:57:51 <hs1> using <$> it already looks somethat cleaner
07:58:34 <clrnd> yeah I love <$>, and it's cousin <*>
07:59:20 <Denommus> c_wraith: aren't all instances of Monad instances of Applicative?
07:59:39 <c_wraith> Denommus: not in code, necessarily
07:59:49 <hs1> :t (<*>)
07:59:50 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
07:59:52 <c_wraith> Denommus: GHC 7.8 warns about it.  GHC 7.10 will make it an error
08:00:07 <clrnd> :i Monad
08:00:12 <clrnd> @info Monad
08:00:12 <lambdabot> Monad
08:00:18 <kadoban> Haha
08:00:23 <Taneb> clrnd, (* -> *) -> Constraint
08:00:26 <clrnd> that's helpfull lambdabot thank you very much
08:00:27 <c_wraith> lambdabot's @info isn't the most useful
08:00:31 <Denommus> c_wraith: so... in GHC 7.10, isn't every Monad instance a Functor instance?
08:00:37 <Denommus> :i Monad
08:00:42 <c_wraith> Denommus: yes, but ghc 7.10 hasn't been released
08:00:48 <mauketwork> lambdabot has no @info command
08:00:53 <Denommus> c_wraith: hurr, okay
08:00:59 <c_wraith> Denommus: it's still a week away from feature-freeze, iirc
08:01:28 <clrnd> base's Monad has no constraint for Functor nor Applicative
08:01:33 <EvanR> is that going to break a lot of code
08:01:43 <shock_one> Hi is there a function that would allow me to call functions in the methods style, like in imperative languages? https://www.dropbox.com/s/c6v8z8x1bp24n4o/Screenshot%202014-11-13%2017.57.16.png?dl=0
08:02:00 <c_wraith> EvanR: lots of things that aren't maintained, yes.  Anything that's being maintained has been updated since 7.8 made it a warning
08:02:21 <mauketwork> shock_one: what's a "method style" and what would it look like in C?
08:02:41 <hs1> probably object.function().function()
08:02:48 <shock_one> Exactly.
08:02:53 <EvanR> my_foo.field1.field2
08:02:55 <nkar> shock_one: take a look at the lens library and its use of .
08:02:59 <mauketwork> C has no objects
08:03:07 <mauketwork> (I know, C has objects. but they have no methods.)
08:03:35 <EvanR> my_foo.field1(my_foo, x)
08:03:45 <EvanR> >")
08:03:52 <shock_one> nkar, thank you.
08:03:58 <dv-> function pointers are like methods
08:04:02 <Taneb> I don't need central heating, I can try and install lens on my laptop
08:04:10 <clrnd> jajaj
08:05:07 <hs1> hackish: [0..10] >>= return . (+1) >>= return . (*2)
08:05:12 <shock_one> But I remember I've read in LYAH or somewhere else about a standard library function that does exactly what my >>> does.
08:05:16 <hs1> you probably shouldnt do that
08:05:30 <mauketwork> <&> maybe
08:05:33 <mauketwork> does that exist?
08:05:40 <shock_one> hs1, yes, it was my first idea too. But having returns isn't exactly beautiful.
08:05:43 <mauketwork> :t (<&>)
08:05:44 <lambdabot> Functor f => f a -> (a -> b) -> f b
08:05:58 <ij> mauketwork, What do you want it to do?
08:06:01 <mauketwork> > "Skeleton Jelly" <&> toUpper
08:06:03 <lambdabot>  "SKELETON JELLY"
08:06:08 <albeit> :t <&> maybe
08:06:09 <lambdabot> parse error on input ‘<&>’
08:06:22 <albeit> :t (flip (<&>)) maybe
08:06:23 <lambdabot> Functor f => f a -> f ((a1 -> a) -> Maybe a1 -> a)
08:06:25 <ij> @src (<&>)
08:06:25 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
08:06:32 <ij> Is it just flipped fmap?
08:06:46 <albeit> :t fmap
08:06:47 <lambdabot> Functor f => (a -> b) -> f a -> f b
08:06:56 <shock_one> Where is it even defined?
08:07:09 <EvanR> <&> seems just as not-a-method-call as C fields
08:07:32 <mauketwork> lens
08:07:47 <shock_one> I think I can use some unicode symbol similar to a dot for that ;).
08:08:05 <mauketwork> http://hackage.haskell.org/package/lens-4.5/docs/Control-Lens-Operators.html#v:-60--38--62-
08:08:15 <mauketwork> shock_one: please don't. dot already means function composition
08:08:16 <clrnd> > "magic dirtBIKES" <&> toUpper <&> toLower
08:08:18 <lambdabot>  "magic dirtbikes"
08:08:51 <mauketwork> > 2 & sqrt
08:08:53 <EvanR> this style is creepy
08:08:53 <lambdabot>  1.4142135623730951
08:09:02 <EvanR> ruby flashbacks
08:09:10 <clrnd> are we smalltalk?
08:09:21 <kadoban> :t (<&>)
08:09:22 <lambdabot> Functor f => f a -> (a -> b) -> f b
08:09:27 <mauketwork> or are we dancer
08:09:29 <kadoban> :t (&)
08:09:30 <lambdabot> a -> (a -> b) -> b
08:09:42 <shock_one> let (•) = flip fmap in "Something"•toLower•toUpper
08:09:44 <ij> EvanR, But isn't it sort of awesome? You get to keep the syntax, but not ruby itself?
08:09:53 <kadoban> So it's flip ($) ? I see
08:10:03 <ij> kadoban, more wings
08:10:08 <ij> kadoban, it's a flip (<$>)
08:10:15 <shock_one> Oh, wow.
08:10:41 <EvanR> > 1 & succ & show & read & sqrt
08:10:42 <lambdabot>  1.4142135623730951
08:10:43 <clrnd> > let (•) = flip fmap in "Something"•toLower•to
08:10:45 <lambdabot>  Couldn't match type ‘s -> a’ with ‘GHC.Types.Char’
08:10:45 <lambdabot>  Expected type: GHC.Types.Char -> p a (f a) -> p s (f s)
08:10:45 <lambdabot>    Actual type: (s -> a) -> p a (f a) -> p s (f s)
08:10:50 <kadoban> Right, I meant the second one. Even though that wasn't clear at all, heh..
08:10:54 <clrnd> > let (•) = flip fmap in "Something"•toLower
08:10:56 <lambdabot>  "something"
08:11:21 <EvanR> > [1, 2, 3] <&> succ & sum
08:11:23 <lambdabot>  9
08:11:41 <clrnd> brb refactoring my whole github to use Java style
08:11:46 <EvanR> lol
08:12:15 <EvanR> i remember trying a reverse $ operator back in the day, no one in the channel was on board
08:12:42 <prophile|phone> isn't there one of those in lens these days
08:13:05 <mauketwork> prophile|phone: scroll up
08:13:06 <clrnd> :t flip $
08:13:07 <lambdabot>     parse error (possibly incorrect indentation or mismatched brackets)
08:13:10 <clrnd> :t flip ($)
08:13:11 <lambdabot> b -> (b -> c) -> c
08:13:25 <prophile|phone> ah
08:13:37 <hs1> i wish i had known this earlier
08:13:47 <michaelt> lens got rid of 50% of the received #haskell wisdom.
08:14:05 <texasmynsted> what?
08:14:06 <ij> What do you mean received?
08:14:20 <mauketwork> such as "don't compose functions"
08:14:38 <mauketwork> and "functors suck"
08:14:39 <michaelt> 'recieved wisdom' , like conventional wisdom
08:14:40 <kadoban> ij: "Having been accepted as true or worthy"
08:14:53 <ij> Hadn't heard that, ok.
08:15:13 <EvanR> you learn special english on the internet
08:15:54 <ij> michaelt, And can you give examples of the wisdom supposedly disregarded by lens?
08:16:33 <michaelt> ij: EvanR gave an example. "Obviously it's stupid to want a flip ($), a flip fmap , etc etc."
08:17:10 <mauketwork> michaelt: it is stupid. unless you have a very good reason to want it.
08:17:19 <mauketwork> "I want my code to look like java" is not a good enough reason
08:17:26 <clrnd> lens is stupid then?
08:17:35 <michaelt> That's certainly true.
08:17:56 <michaelt> I mean, "I want it like Jave" is stupid.
08:18:08 <mauketwork> there is/was such a module somewhere on the internet
08:18:09 <EvanR> java, ruby, C, D, javascript, python
08:18:17 <ij> It doesn't seem that silly to me, maybe because I'm inexperienced or smth.
08:18:23 <hs1> i kind of like reading my code from left to right sometimes
08:18:28 <clrnd> what about BASIC https://hackage.haskell.org/package/BASIC
08:18:31 <mauketwork> it redefined (.) and did things like ["foo", "bar", "baz"].sort.map(length)
08:18:35 <EvanR> reverse polish notation
08:18:44 <mauketwork> and not as a joke
08:19:12 <kadoban> ij: Well, it's generally a good idea to learn the idioms of the programming language before deciding when to break them.
08:19:47 <mauketwork> it's like doing #define BEGIN { in C because you're used to Pascal
08:19:49 <FireFly> mauketwork: is that just having (.) be flip ($) ?
08:19:55 <mauketwork> FireFly: yes
08:20:14 <kadoban> ij: That doesn't mean you should /always/ follow them, but if you start out with the goal of conforming the language to your existing thinking, it's...a bit of a waste of time to even learn the language.
08:20:26 <michaelt> right http://hackage.haskell.org/package/air-2014.5.19/docs/Air-Light.html#v:.
08:21:07 <tdammers> mauketwork: a book I bought early in my programming journey did exactly that
08:21:11 <tdammers> #define BEGIN {
08:21:14 <tdammers> #define END }
08:21:20 <michaelt> Air even has seventh :: [a] -> Maybe a
08:21:30 <kadoban> tdammers: :-/
08:21:36 <EvanR> michaelt: handy
08:22:10 <mauketwork> tdammers: did it also do int *p = &a[-1]; so the array elements would be at p[1] .. p[n]?
08:22:32 <tdammers> mauketwork: who knows
08:23:00 <tdammers> I picked up C shortly after that, realizing that Pascal-based programming books had a tendency to be quite shitty
08:23:02 <mauketwork> IIRC one of the well known algorithms books did that. it's not valid C, of course
08:23:06 <ij> kadoban, Can you give me some arguments in favor of not flipping $, <$>, .?
08:23:33 <kadoban> ij: I think I just did.
08:23:56 <ij> appeal to authority
08:24:23 <EvanR> (f . g . h) x reads fine from left to right
08:24:31 <kadoban> Appeal to making your code readable by other people in the community, and understanding what you're doing before branching out.
08:24:35 <ij> And you said that it's justified when starting out, and I agree, but it's not a real argument.
08:25:04 <kadoban> So you agree, but it's not a real argument? Okay then...
08:25:22 <EvanR> f x corresponds to math notation, and function call notation in languages with function calls
08:25:43 <EvanR> just reversing that in isolation is countercultural!
08:25:45 <ij> I agree that I should accept it without questions, initially.
08:26:13 <EvanR> you should be like everybody else
08:26:14 <clrnd> I think it's subjective, anyway nobody reads code, we have types
08:26:15 <EvanR> ;)
08:26:31 <kadoban> Well, that's pretty much the entirity of my point. So we agree then.
08:26:36 <mauketwork> type x & f = f x
08:26:46 <mauketwork> Int & Maybe & []
08:26:58 <EvanR> makes a lot of sense
08:27:03 <kadoban> If you're a master of the language and decide that & helps you write good code, you certainly have my blessing.
08:27:13 <mauketwork> ocaml goes full german: int option list
08:27:14 <kadoban> For whatever little that's worth, heh.
08:27:46 <tdammers> mauketwork: full german would be Intoptionlist, no?
08:27:53 <mauketwork> well, true
08:27:54 <EvanR> Int & Maybe & [] to me is a really good argument against RPN
08:28:05 <EvanR> because its insane
08:28:39 <shock_one> In OO languages each method resides in its own namespace: a class. It allows to have the same method names for different objects. It seems like in Haskell I can't achieve this behaviour if I have to work with two types such in the same module, and I need to use different names for the functions. How do you guys solve this issue?
08:28:42 <clrnd> maybe because types represent structure very graphically?
08:28:44 <mauketwork> > [Just 42] :: Int & Maybe & []
08:28:45 <lambdabot>  [Just 42]
08:28:56 <y> shock_one: records
08:28:58 <shock_one> *such types.
08:29:04 <EvanR> shock_one: you can define the function in another module and use namespaces
08:29:24 <y> oh, thought you were emulating OOP in Haskell
08:29:25 <mauketwork> :t [Just 42] :: Int & Maybe & []
08:29:26 <lambdabot> (Int & Maybe) & []
08:29:27 <EvanR> use more modules is the first way to do that
08:30:07 <EvanR> Maybe<Int>[]
08:30:11 <clrnd> I need a stdin-friendly version of runhaskell
08:37:30 <xandaros> clrnd: How is runhaskell not stdin-friendly?
08:37:52 <clrnd> eh I emant, I want to > echo "haskell" | runhaskell --
08:38:07 <ij> You can't?
08:38:12 <clrnd> s/haskell/anActualHaskellExample/
08:38:26 <xandaros> That works for me...
08:38:35 <ij> Same here.
08:39:01 <clrnd> mmm
08:39:59 <clrnd> lol you are right
08:40:14 <clrnd> it was a bash issue
08:40:55 <jophish> Is there a nice way to pattern match on Data.Text?
08:41:38 <EvanR> theres view patterns
08:44:35 <latk> Using ghc-mod in emacs, hlint doesn't seem to show all suggestsion (e.g. running hlint file.hs has a different output from ghc-mod's). Anyone else experienced this ?
08:45:25 <gdoteof> I want to add a one-click backup to my yesod app.. essentially just a DB dump.  I'm considering just using System.Process but was wondering if there is some higher-level way of doing it in haskell.  my 30 second search only showed protocol-level interactions
08:45:45 <gdoteof> postgres db
08:50:48 <lib> ;;tslb
08:57:42 <shock_one_> y, mauketwork, I can't believe it, TDNR solves two of my issues at once. It resolves functions by type, which allows me to have many functions with the same name for different types, and it uses the dot notation. https://ghc.haskell.org/trac/haskell-prime/wiki/TypeDirectedNameResolution
08:59:20 <Squiggles> Hello there!
08:59:28 <shock_one_> Although, it functions take parameters, it becomes not so beautiful. "x.f(3).g(v,w).h" => "((x.f 3).g v w).h"
09:01:45 <Squiggles> I am currently learning Haskell and I am tackling a prefix tree encoding problem I found on the internet. I was wondering if anyone had any pointers for me for accomplishing this with haskell..  The problem I am looking at is at http://www.geeksforgeeks.org/construct-a-special-tree-from-given-preorder-traversal/
09:02:34 <Squiggles> I thought I could replicate the recursive nature of the tree construction from a [char] but I am unable to keep an index of where to split the string at the appropriate spot
09:04:01 <Squiggles> So here is a tree that I was working with in its preorder traversal: *a**!*dc*rb
09:04:22 <Squiggles> The case with the tree is that every node has 0 or 2 children
09:05:03 <Squiggles> Would anyone happen to have any advice on how to reconstruct the tree from this string?
09:05:28 <RchrdB> Squiggles: you're representing the pre array as a [Char] and the preLN array as what, sorry?
09:06:05 <Squiggles> RchrdB: pardon me, I only have the [char] to work with, as the weight of the values do not matter
09:06:15 <Squiggles> the preLN is my string
09:06:26 <Squiggles> in this case "*a**!*dc*rb"
09:06:35 <mauketwork> that's not a valid preLN string
09:06:43 <RchrdB> "*a**!*dc*rb" doesn't look like a string of 'L' and 'N' characters.
09:06:47 <mauketwork> preLN looks like "NNLLL"
09:07:10 <Squiggles> well * would be the N and any ascii character represents the L
09:07:31 <mauketwork> why?
09:07:47 <Squiggles> my ascii characters are on the leaves and the asterisks are my nodes with two children
09:08:01 <mauketwork> anyway, I think I can do this with a State-y kind of thing
09:08:35 <mauketwork> the state is the remaining string, the value is the constructed tree
09:09:23 <Squiggles> So I was trying to read the first character of the string and determine if its a leaf (ascii char) or a node (asterisk)
09:09:33 <Squiggles> and then call my function again to continue on the rest of the string
09:10:07 <Squiggles> however I ran into difficulty determining where the subtrees began and ended in my slice of the initial string
09:10:10 <Squiggles> if that makes sense
09:10:58 <NemesisD> if i bump a dependency using a sandbox, is there any way to upgrade that package and anything that depends on it other than blowing away the sandbox?
09:11:52 <kadoban> NemesisD: Not really in general, without reinstalls or whatever. AFAIK that is.
09:12:36 <Squiggles> mauketwork: This is the snippet of code I have constructed so far
09:12:40 <Squiggles> http://ideone.com/9yA5CI
09:12:55 <Squiggles> I am new to this, excuse the code
09:13:01 <mauketwork> > let construct pre preLN = fst (work (zip pre preLN)) where work ((x, 'L') : rest) = (Node x [], rest); work ((x, 'N') : rest) = let (left, rest') = work rest; (right, rest'') = work rest' in (Node x [left, right], rest'') in construct [10, 30, 20, 5, 15] "NNLLL"
09:13:02 <lambdabot>  Node {rootLabel = 10, subForest = [Node {rootLabel = 30, subForest = [Node {...
09:14:22 <Squiggles> the snippet I provided works, but I did not consider the case where a tree  might have a left sub tree and right subtree
09:14:26 <mauketwork> the trick here is that my helper function has the type [Input] -> (Tree, [Input])
09:14:45 <mauketwork> that is, it takes a list of inputs, constructs a tree, and returns it along with the remaining input
09:15:26 <mauketwork> now I can combine multiple subtrees by passing the remaining input from the first subcall into the second subcall
09:16:56 <Squiggles> hmmm
09:17:03 <mauketwork> and I bet this code could be simplified a lot by using an appropriate tree type and State
09:17:24 <EvanR> mauketwork: does the length output list equal the length of the input list?
09:17:46 <mauketwork> no, the output list is always shorter, as it's a suffix of the input list
09:17:51 <mauketwork> and I always consume at least one element
09:17:55 <EvanR> ok [Input] isnt a list of different input streams
09:18:07 <EvanR> [Tokens]
09:18:12 <EvanR> Token
09:18:12 <mauketwork> in Squiggles's code Input would be Char
09:18:18 <mauketwork> in mine it's something like (a, Char)
09:18:45 <mauketwork> because I'm zipping the pre and preLN together and I'm keeping the silly Char representation of L/N
09:20:10 <Squiggles> mauketwork: I will try to interpret what you have written, but I am fairly new here
09:21:03 <mauketwork> > let construct str = fst (work str) where work ('*' : rest) = let (left, rest') = work rest; (right, rest'') = work rest' in (Node () [left, right], rest''); work (x : rest) = Node x [] in construct "*a**!*dc*rb"
09:21:04 <lambdabot>  Couldn't match expected type ‘(Data.Tree.Tree (),
09:21:04 <lambdabot>                                 [GHC.Types.Char])’
09:21:04 <lambdabot>              with actual type ‘Data.Tree.Tree GHC.Types.Char’
09:21:07 <mauketwork> aw
09:21:07 <Squiggles> but yeah, I do not need the list of values as I am only concerned with the data stored in the leaves
09:21:12 <mauketwork> oh, right
09:21:24 <mauketwork> > let construct str = fst (work str) where work ('*' : rest) = let (left, rest') = work rest; (right, rest'') = work rest' in (Node '*' [left, right], rest''); work (x : rest) = Node x [] in construct "*a**!*dc*rb"
09:21:25 <lambdabot>  Couldn't match expected type ‘(Data.Tree.Tree GHC.Types.Char,
09:21:26 <lambdabot>                                 [GHC.Types.Char])’
09:21:26 <lambdabot>              with actual type ‘Data.Tree.Tree GHC.Types.Char’
09:22:20 <mauketwork> > let construct str = fst (work str) where work ('*' : rest) = let (left, rest') = work rest; (right, rest'') = work rest' in (Node '*' [left, right], rest''); work (x : rest) = (Node x [], rest) in construct "*a**!*dc*rb"
09:22:21 <lambdabot>  Node {rootLabel = '*', subForest = [Node {rootLabel = 'a', subForest = []},N...
09:22:31 <mauketwork> ok, that works
09:23:24 <Squiggles> mauketwork: may I ask your thought process?
09:24:02 <mauketwork> > let construct str = fst (work str) where work ('*' : rest) = let (left, rest') = work rest; (right, rest'') = work rest' in (BNode left right, rest''); work (x : rest) = (BLeaf x, rest) in construct "*a**!*dc*rb"
09:24:04 <lambdabot>  BNode (BLeaf 'a') (BNode (BNode (BLeaf '!') (BNode (BLeaf 'd') (BLeaf 'c')))...
09:24:10 <mauketwork> now with more readable tree
09:24:52 <mauketwork> Squiggles: "this looks like prefix notation"
09:25:00 <Squiggles> lol
09:25:16 <mauketwork> instead of 2 + 3 * 4 the input is like + 2 * 3 4
09:25:37 <mauketwork> every non-leaf node is like an operator that takes two subtrees as input
09:25:37 <Squiggles> correct!
09:26:02 <mauketwork> and it can consume an arbitrary number of input tokens because trees can be nested
09:26:31 <mauketwork> so I somehow need to communicate two things back to my caller: the tree I just parsed, and the remaining input
09:26:51 <mauketwork> because otherwise it has no way to know where it should continue
09:27:15 <mauketwork> so instead of returning plain tree, I return a (tree, rest-of-input) tuple
09:27:35 <Squiggles> that was what I was running into, I did not know how to, as you said, communicate back to my caller
09:28:55 <Squiggles> mauketwork: thank you, I will look into your snippet further
09:28:58 <Squiggles> RchrdB: thank you as well
09:31:57 <mauketwork> this should be nicely parsec-able
09:33:30 <mauketwork> leaf = Leaf <$> noneOf "*"; node = char '*' *> (Node <$> node <*> node)
09:33:43 <mauketwork> no, that's wrong
09:33:57 <mauketwork> leaf = Leaf <$> noneOf "*"; node = char '*' *> (Node <$> tree <*> tree); tree = leaf <|> node
09:34:27 <mauketwork> runParser tree () "(input)" "*a**!*dc*rb"
09:35:06 <mauketwork> assuming data Tree a = Leaf a | Node (Tree a) (Tree a) deriving (Show)
09:35:52 <Squiggles> my data structure is Tree a = Empty | Node a (Tree a) (Tree a) deriving (Show)
09:38:01 <mauketwork> that fits the original problem but not your revised version
09:38:25 <Squiggles> understood
09:38:26 <mauketwork> well, you could store an artificial '*' at the nodes
09:55:33 <SvenskFisk> Anyone tried installing Helm on OS X 10.10? I'm running into all sorts of issues with glib/sdl2/pango
10:05:05 <senoj> installing pango and/or cairo on OS X is painful, I haven't tried installing sdl2 though
10:05:57 <kgadek> hi. OS X related: have anyone transitioned Mavericks→Yosemite? were there any problems with GHC?
10:06:35 <Squiggles> Aww he left
10:08:02 <glguy> kgadek: I have been using GHC on Yosemite since the betas and I haven't had issues
10:08:08 <ReinH> kgadek: nope
10:08:09 <glguy> Most of the people at work have upgraded
10:08:27 <ReinH> kgadek: er. yes. and no.
10:08:44 <kgadek> ReinH: please elaborate?
10:08:55 <ReinH> kgadek: yes, I have upgraded. No, there were no problems.
10:08:58 <josephle> seems like Yosemite is not the "change ALL the C compilers" upgrade like Mavericks was
10:09:03 <kgadek> ah, okay :)
10:09:43 <kgadek> josephle: yeah, Mavericks was a pain in a pre-7.8 era.
10:10:06 <kgadek> thanks all!
10:14:07 <senoj> no issues here with GHC 7.8.3 and OS X 10.10
10:15:12 <Luizluz> is there anyone here that knows about jpos emv ?
10:17:21 <glguy> Luizluz: I don't, but it's usually better to ask your question than to hope someone will bite
10:17:34 <glguy> unless all you wanted to know is if anyone else knows about it
10:21:35 <Luizluz> glguy: ii just need  help from someone that know about it ! thats it
10:23:30 <snyp> what's <$> ?
10:23:43 <glguy> fmap
10:23:46 <snyp> ah
10:24:02 <Denommus> is there a function (a, a) -> (a -> b) -> (b, b)?
10:24:08 <Denommus> the arguments could also be flipped
10:24:22 <benzrf> Luizluz: google suggests that that's java..
10:24:29 <benzrf> Denommus: join bimap
10:24:30 <benzrf> =)
10:24:34 <benzrf> er,
10:24:35 <glguy> > over both not (True, False)
10:24:37 <lambdabot>  (False,True)
10:24:38 <benzrf> wait
10:24:42 <benzrf> :t flip (join bimap)
10:24:44 <lambdabot> Bifunctor p => p a a -> (a -> b) -> p b b
10:24:48 <benzrf> ebin
10:25:06 <Denommus> :t join bimap
10:25:07 <lambdabot> Bifunctor p => (a -> b) -> p a a -> p b b
10:25:15 <simpson> :t \(a, a') f -> (f a, f a') -- here's the non-golfy version
10:25:16 <lambdabot> (t, t) -> (t -> t1) -> (t1, t1)
10:25:23 <Denommus> :t bimap
10:25:24 <lambdabot> Bifunctor p => (a -> b) -> (c -> d) -> p a c -> p b d
10:25:31 <glguy> Denommus: There's no Prelude function that does that directly
10:26:10 <Denommus> glguy: it doesn't need to be in Prelude, but it would be nice if it was in the built-in modules
10:26:19 <glguy> Not that, either
10:27:18 <jle`> Denommus: you can also do join (***)
10:27:25 <jle`> :t join (***)
10:27:27 <lambdabot> Arrow a => a b c -> a (b, b) (c, c)
10:27:47 <jle`> > join (***) (+3) (5, 7)
10:27:49 <lambdabot>  (8,10)
10:27:55 <jle`> just until Bifunctor gets added into base
10:28:06 <Denommus> I don't think those are what I want
10:28:25 <Denommus> I just done apply f (x, y) = (f x, f y) :P
10:28:26 <jle`> :t join (***) `asAppliedTo` (undefined :: a -> b)
10:28:27 <lambdabot> (b' -> c') -> (b', b') -> (c', c')
10:28:36 <jle`> that seems to be exactly what you want though :|
10:28:51 <Denommus> jle`: indeed
10:29:29 <benzrf> Denommus: get lens ( ͡° ͜ʖ ͡°)
10:29:47 <Denommus> jle`: where does (***) come from?
10:30:10 <jle`> Control.Arrow
10:30:31 <jle`> it's actually a little bit of an unfortunate abuse i think of the Arrow typeclass, but it's what most people live with today until we can get a proper bifuctors module into base
10:30:48 <jle`> (***) can be thought of as a monomorphic bimap of some sort
10:30:51 <jle`> to only work on tuples
10:31:08 <Denommus> jle`: ah, I forgot (->) is a data constructor :P
10:31:33 <jle`> yeah, that's the trick
10:31:43 <jle`> :)
10:31:44 <glguy> (minor quibble) It's a *type* constructor, not data
10:32:09 <benzrf> bifunctors are ebin
10:32:45 <Denommus> glguy: it was just a brain fart
10:34:56 <jle`> also of course
10:34:58 <jle`> > (1,2) & both %~ (+3)
10:35:00 <lambdabot>  (4,5)
10:36:30 <rmorgan> What is the name of the '<>' operator?
10:36:35 <glguy> mappend
10:36:42 <Iceland_jack> mappend or diamond
10:37:01 <jle`> in math you sometimes see it as that circley operator i think
10:37:17 <rmorgan> thanks! I keep seeing it in some code I'm working on -- turns out it's difficult search for without knowing the name
10:37:23 <jle`> @hoogle (<>)
10:37:25 <ReinH> "plus" also works
10:37:25 <lambdabot> Language.Haskell.TH.PprLib (<>) :: Doc -> Doc -> Doc
10:37:25 <lambdabot> Text.PrettyPrint.HughesPJ (<>) :: Doc -> Doc -> Doc
10:37:25 <lambdabot> Text.PrettyPrint (<>) :: Doc -> Doc -> Doc
10:37:33 <jle`> that's spectacularly unhelpful, hoogle
10:37:39 <jle`> :|
10:38:03 <jle`> @hayoo (<>)
10:38:03 <lambdabot> Unknown command, try @list
10:38:04 <ReinH> m'plus
10:38:50 <jle`> rmorgan: http://hayoo.fh-wedel.de/?query=%28%3C%3E%29
10:39:43 <rmorgan> thanks :)
10:40:28 <rmorgan> so is mappend used for concatenating monoids of the same type?
10:43:26 <jle`> well...Monoid is a type class. so it's used for combining two values of the same Monoid instance, yeah.
10:43:35 <jle`> :t (<>)
10:43:36 <lambdabot> Monoid m => m -> m -> m
10:43:52 <Iceland_jack> > "hello" <> " " <> "world"
10:43:54 <lambdabot>  "hello world"
10:43:55 <Bor0> > [1,2,3] <> [4,5,6]
10:43:57 <lambdabot>  [1,2,3,4,5,6]
10:43:57 <jle`> two values of the same type, which are both Monoid instances
10:43:58 <Iceland_jack> > Sum 10 <> Sum 243
10:44:00 <lambdabot>  Sum {getSum = 253}
10:44:03 <jle`> i guess that's what the type signature says
10:44:18 <Denommus> qsort _ [] = []
10:44:18 <Denommus> qsort comp (x:xs) = smaller ++ [x] ++ bigger where (smaller, bigger) = join (***) (qsort comp) $ partition (comp x) xs
10:44:20 <jle`> two values of the same type, where that type is a Monoid instance
10:44:24 <Denommus> this is the coolest qsort ever
10:45:15 <jle`> (qsort comp *** qsort comp) looks nice to me, it is kind of like a bird or bat :)
10:45:37 <jle`> but yes congrats :D
10:48:53 <benzrf> > (replicate <> replicate) 2 "test"
10:48:56 <lambdabot>  ["test","test","test","test"]
10:49:38 <kadoban> :t replicate <> replicate
10:49:40 <lambdabot> Int -> a -> [a]
10:58:04 <clrnd> :t join
10:58:06 <lambdabot> Monad m => m (m a) -> m a
10:58:14 <clrnd> yeah ofc
10:58:17 <oliffea_> is there any way to use \p{L} etc in alex?
10:59:08 <clrnd> :t (***)
10:59:11 <lambdabot> Arrow a => a b c -> a b' c' -> a (b, b') (c, c')
11:01:22 * hackagebot reasonable-lens 0.2.0.0 - Lens implementation. It is more small but adequately.  http://hackage.haskell.org/package/reasonable-lens-0.2.0.0 (outoftune)
11:04:46 <xpilot> question about TypeOperators
11:05:02 <xpilot> I have data a :*: b = a :*: b
11:05:08 <c_wraith> Hey, I *can* write unmaintainable code in Haskell.  And apparently, put it on lpaste.
11:05:37 <xpilot> and I want to partially apply this: type Fst a = (a :*:)
11:05:45 <glguy> c_wraith: yay?
11:05:52 <clrnd> c_wraith, congrats!
11:05:53 <c_wraith> xpilot: you can't do type-level sections
11:06:02 <xpilot> this isn't syntactically correct, but this is: type Fst a = (:*:) a
11:06:06 <c_wraith> xpilot: you would need to write that type as ((:*:) a)
11:06:29 <xpilot> so there is no way to write type Snd b?
11:06:55 <c_wraith> xpilot: That'd be a type-level lambda.  Haskell explicitly does not have them.
11:07:05 <xpilot> that is, partially apply :*: to the second type variable
11:07:06 <glguy> type Snd b a = a :*: b
11:07:18 <c_wraith> xpilot: Haskell doesn't have them because they remove the injectivity of type constructors
11:07:44 <c_wraith> though in this specific case, glguy's code works
11:08:01 <xpilot> well, you can't partially apply type synonyms
11:08:08 <xpilot> so it wouldn't work in my case
11:08:28 <xpilot> I can't talk about (Snd Int)
11:09:28 <c_wraith> xpilot: you can write a type family to do that, but its functionality will be limited in the way type families always are.
11:10:02 <xpilot> the problem being that they are not injective?
11:11:20 <c_wraith> Right.
11:12:21 <c_wraith> xpilot: it still might do what you want, with some clever use of type equality constraints (~)
11:13:08 <xpilot> hm, seems I need ghc 7.8 for closed type families
11:16:41 <c_wraith> seriously, I am really having trouble understanding what I did here.  http://lpaste.net/102101  I apparently CPS-transformed something that used to be simpler.
11:17:43 <c_wraith> that really deserves a sentence about what the heck countAppend does.
11:18:13 <c_wraith> I figured it out, but it's confusing as heck.
11:24:05 <mmachenry> When I got to https://hackage.haskell.org/package/haskelldb-hsql-oracle and click on hsql-oracle in the dependencies I get package not found. Does this mean that haskelldb-hsql-oracle is broken because one of its dependencies no longer exists on Hackage?
11:25:20 <c_wraith> mmachenry: it does indeed look broken.
11:26:18 <mmachenry> Bummer, thanks for clarifying for me, c_wraith
11:30:05 <fragamus> having trouble combining the braces notation with do notation where let is involved:     do {let a="flooble"; b<-someMonadicAction a; c<-anotherMonadicAction a b}
11:30:56 <mauke> do let {a = "flooble"}; b <- asdf; ...
11:31:07 <fragamus> thanks
11:34:08 <circ-user-1rMDK> Hi guys. Don't you have an idea why deleteBy in base has the wrong type?
11:34:53 <monochrom> @type deleteBY
11:34:55 <lambdabot>     Not in scope: ‘deleteBY’
11:34:55 <lambdabot>     Perhaps you meant one of these:
11:34:55 <lambdabot>       ‘deleteBy’ (imported from Data.List),
11:34:56 <circ-user-1rMDK> From the definition it must be (a -> b -> Bool) -> a -> [b] -> [b]
11:34:56 <monochrom> @type deleteBy
11:34:58 <lambdabot> (a -> a -> Bool) -> a -> [a] -> [a]
11:35:12 <L8D> @src deleteBy
11:35:12 <lambdabot> deleteBy eq x []     = []
11:35:12 <lambdabot> deleteBy eq x (y:ys) = if x `eq` y then ys else y : deleteBy eq x ys
11:36:00 <circ-user-1rMDK> I was going to remove an element from a list of pairs by the value of the first element
11:36:16 <circ-user-1rMDK> And surprisingly deleteBy (\a b -> a == fst b) failed
11:37:07 <kadoban> circ-user-1rMDK: Use filter?
11:37:32 <circ-user-1rMDK> (An example was deliberately chosen)
11:37:48 <circ-user-1rMDK> (Yeah, I know about filter)
11:38:06 <L8D> filterFirst?
11:38:14 <L8D> or is that delete?
11:44:45 <success>         //canvas.drawBitmap( background, null, backgroundRect, null );
11:44:45 <success>         backgroundDrawable.draw( canvas );
11:44:53 <success> is there a big speed difference in those calls?
11:45:34 <mauke> that looks like syntax errors
11:49:30 <success> if using canvas, how can I optimize the drawing of bitmaps? turn them into some thing Drawable? make them of a certain size (does power of 2 matter anymore?)?
11:49:43 <trap_exit> this might be a bit premature / early -- anyone working on a haskell => aws lambda compiler?
11:49:51 <trap_exit> I'd like to run my haskell code on aws, without managing the servers
11:51:24 <jfischoff> trap_exit: have you read the docs yet on lambda?
11:51:45 <trap_exit> I'm looking at http://docs.aws.amazon.com/lambda/latest/dg/walkthrough-custom-events-create-test-function.html
11:51:48 <trap_exit> and I have no fucking clue how it works
11:52:08 <trap_exit> it's like "when <EVENT> happens, execute <CODE BLOCK>"
11:52:14 <trap_exit> where <CODE BLOCK> appears to be non-haskell right now
11:52:16 <clrnd> CODE is JS right?
11:52:55 <trap_exit> it's JS?
11:53:01 <trap_exit> oh, I can just use Fay, Haste, or GHCJS then
11:54:28 <jfischoff> they said “for this example” so maybe other languages are supported?
11:56:24 * hackagebot FTGL 2.1 - Portable TrueType font rendering for OpenGL using the Freetype2 library  http://hackage.haskell.org/package/FTGL-2.1 (laquendi)
11:58:42 <Adeon> I'd like to see a pango-based text renderer for opengl
11:59:07 <Adeon> I once had subpixel-rendered text in opengl but my code wasn't very general
11:59:21 <n9810> How are you  ?
11:59:25 <Adeon> just using freetype won't handle unicode text as well as pango
12:05:41 <jcf> Hello all. It's been a while since I've written any Haskell and I've forgotten the majority of what I read in LYAH and other books. I can of course go back and read them to recover what I've lost but wonder if anyone would be willing to help me get back on the wagon by critiquing a really simple bit of interact in https://gist.github.com/jcf/e1fc9c9d4c0c301d3b64
12:06:24 * hackagebot persistent-odbc 0.2.0.1 - Backend for the persistent library using ODBC  http://hackage.haskell.org/package/persistent-odbc-0.2.0.1 (gbwey)
12:06:24 <jcf> What I'm trying to do is take a list of indexes provided on the command line and return the relevant characters from a super secret password. The kind of thing you have to do to sign into your online back account…
12:06:53 <jcf> I've got a Ruby version, Python version, Golang version and a Clojure version (although it's impractical because of JVM startup time).
12:09:37 <SvenskFisk> Hey guys, has anyone else had trouble running "hoogle data"? Wget complains about the certificate being invalid when trying to get the data from hackage
12:09:52 <ReinH> jcf: Think about the types of each part of codes
12:10:23 <ReinH> jcf: `code' expects an Int. What does `words' give?
12:10:52 <jcf> Thanks ReinH. I can just about decipher the type errors when I try to load the script into GHCI. words returns a list of strings… I believe it's [Char] if memory serves.
12:11:07 <ReinH> :t words
12:11:08 <lambdabot> String -> [String]
12:12:00 <jcf> The problem comes from my combination of read_int and code inside the map. I can work my way through the type errors, but feel like I'm missing something more fundamental in my approach.
12:12:32 <ReinH> codes s = (unwords) (map read_int  code) (words s) = (unwords . map read_int . code . words) s
12:12:50 <ReinH> :t (.)
12:12:51 <lambdabot> (b -> c) -> (a -> b) -> a -> c
12:12:53 <ReinH> :t words
12:12:54 <lambdabot> String -> [String]
12:13:03 <jfischoff> Adeon: It seems like signed distance fields are the font techinique of choice these days
12:13:07 <ReinH> so for code . words to work, code has to have type [String] -> c
12:13:18 <ReinH> but your code is Int -> Char
12:15:03 <ReinH> jcf: I think you want to map code over the input words
12:15:18 <ReinH> map (code . read) . words
12:15:38 <ReinH> would work assuming your input is like "1 4 5 2", i.e. integers separated by whitespace
12:16:01 <jcf> That's the plan at least, and how my implementation works in other languages.
12:16:14 <Laquendi> jcf: f . g $ x = f(g(x)), g gets the argument before f
12:16:18 <jcf> Thanks for the tips. Let me have another crack at it…
12:16:20 <ReinH> but note that read will fail with an exception if your string contains a word that can't be read as an integer, and (!!) will fail if the integer given exceeds the list length
12:16:25 * hackagebot flamethrower 0.0.4.1 - A template engine for HTML  http://hackage.haskell.org/package/flamethrower-0.0.4.1 (charmander)
12:17:07 <jcf> I'm looking at using reads to make things safer, but have to remember how to use Maybe and mapM or whatever it is I need to unbox a boxed value.
12:17:17 <jcf> This stuff is in my brain somewhere. Just not readily available. :)
12:17:28 <ReinH> reads isn't what you want
12:17:44 <ReinH> @hackage safe
12:17:44 <lambdabot> http://hackage.haskell.org/package/safe
12:18:02 <Iceland_jack> @ty Text.Read.readMaybe
12:18:03 <lambdabot> Read a => String -> Maybe a
12:18:27 <ReinH> Yes, that
12:22:14 <codygman> What would be a good way to model mechanize in Haskell? I was thinking I could just use a StateT monad transformer with the current pages html as a cursor. Then have something like get "http://www.google.com" >>= (\c -> c $// form (Name "search") >=> input (Name "query") &| submit . modify)... err that's kinda horrible but it's a place to start. Or would I be better off trying to revive Shpider?
12:22:47 <codygman> (above would also be incorrect, but hopefully idea translates)
12:23:36 <angerman> Say I have two lists I want to merge on their key: List 1and List 2 of type [(String, String)]. Where the first element is the key and the second is the value. Now I want to get [(String, [String])] as the result.
12:25:36 <ReinH> angerman: look at sort and groupBy
12:28:06 <angerman> ReinH: Got an idea how I can preserve missing elements and put in some kind of placeholder?
12:28:15 <ReinH> "missing elements"?
12:28:31 <yukko> is there a way to use an STM channel with two threads such that one thread (which only reads from the channel) only is alive/woken up when there's new data to read on the channel, and is asleep otherwise?
12:28:50 <yukko> or do I have to do something with threadDelay
12:28:54 <ReinH> :t let merge :: [(String,String)] -> [(String,[String])]; merge = map _collapse . groupBy ((==) `on` fst) . sortBy (comparing fst) in merge
12:28:55 <lambdabot>     Found hole ‘_collapse’
12:28:55 <lambdabot>       with type: [(String, String)] -> (String, [String])
12:28:55 <lambdabot>     Relevant bindings include
12:29:21 <mmachenry> Does anyone have experience with Oracle and Haskell?
12:30:18 <angerman> ReinH: say one list has a key, but the other one does not, I'd like to have [value1, Missing] if the element was not in the second list. and [Missing, value2] if the element was not in the first list.
12:30:48 <ReinH> Oh, I see.
12:30:57 <ReinH> Why use a list for exactly 2 elements when you could use a tuple?
12:31:08 <ReinH> And can you guarantee that each list only has each key at most once?
12:31:44 <angerman> ReinH: yes, keys will be unique.
12:32:18 <angerman> ReinH: the list will contain many values. But both lists may not necessarily contain the same set of keys.
12:32:28 <ReinH> map each list to [(String,(Maybe String,Maybe String)], with the first list being (Just s, Nothing) and the second being (Nothing Just s), then do the sorting and grouping
12:32:29 <angerman> ReinH: i want to build some kind of matrix.
12:32:46 <ReinH> er (Nothing, Just s)
12:33:31 <supki> yukko: I may be misunderstanding the question but reading from TChan blocks when it's empty
12:33:42 <supki> yukko: well, "retries" is more accurate
12:33:52 <yukko> ohhh that's very interesting!
12:34:03 <yukko> I think that'll do fine then, thank you :)
12:34:47 <ReinH> angerman: the grouping will give you elements like [("foo", (Nothing, Just "bar")),("foo", (Just "bazz", Nothing))], which you then combine
12:35:09 <ReinH> and then `map combine' merges the whole list
12:35:48 <ReinH> Argh, the monoid instance is wrong for Maybe. Again.
12:35:48 <ReinH> sigh
12:36:08 <bitemyapp> > mappend (Just (Product 2)) Nothing
12:36:09 <lambdabot>  mueval-core: L.hs: openBinaryFile: does not exist (No such file or directory)
12:36:16 <bitemyapp> ...
12:36:39 <ReinH> You want to be able to combine line this:
12:36:40 <ReinH> > (Nothing, Just ()) <> (Just (), Nothing)
12:36:41 <lambdabot>  (Just (),Just ())
12:36:46 <ReinH> *like
12:37:18 <ReinH> And in this case you can because there will be at most one Just value at each point
12:37:28 <ReinH> so you're always mappending Just "foo" with Nothing or vice versa
12:37:33 <ReinH> So in this case you can use the monoid instance
12:37:36 <ReinH> but it's still wrong
12:38:06 <ReinH> > (Nothing, Just "foo") <> (Just "bar", Nothing)
12:38:07 <lambdabot>  (Just "bar",Just "foo")
12:38:08 <ReinH> Happens to work
12:38:18 <ReinH> > (Nothing, Just "foo") <> (Nothing, Just "bar")
12:38:19 <lambdabot>  (Nothing,Just "foobar")
12:38:27 <ReinH> Does not work, but can't happen if keys are unique
12:39:22 <ReinH> Actually this has nothing to do with whether the Maybe Monoid instance is correct, sorry
12:40:09 <ReinH> (Although you could handle duplicate keys either by wrapping each item in a singleton list)
12:40:16 <ReinH> s/either //
12:40:34 <ReinH> actually
12:40:43 <ReinH> heh, you can use monoids all the way down
12:43:35 <Yxven> How do I learn how to properly structure a program in a functional language like Haskell?
12:43:43 <ReinH> > map fold [[(First (Just "a"), (Nothing, Just "b")),(First (Just "a"), (Just "c", Nothing))],[(First (Just "d"), (Nothing, Just "f"))]]
12:43:45 <lambdabot>  [(First {getFirst = Just "a"},(Just "c",Just "b")),(First {getFirst = Just "...
12:43:52 <ReinH> @google Thinking Functionally in Haskell
12:43:53 <lambdabot> https://pragprog.com/magazines/2012-08/thinking-functionally-with-haskell
12:43:58 <ReinH> Not that :(
12:44:03 <ReinH> @google Thinking Functionally with Haskell Richard Bird
12:44:04 <EvanR> Yxven: write code, repeat
12:44:05 <lambdabot> http://www.cambridge.org/us/academic/subjects/computer-science/programming-languages-and-applied-logic/thinking-functionally-haskell
12:44:05 <lambdabot> Title: Thinking Functionally with Haskell | Programming languages and applied logic ...
12:44:07 <ReinH> Yxven: That.
12:46:32 <Yxven> ReinH that book hasn't been released yet?
12:46:48 <ReinH> Yxven: kindle version is available
12:47:03 <Yxven> EvanR  I tried that. My code is gross
12:47:19 <EvanR> paste code, get tips
12:47:32 <ReinH> Yxven: http://www.amazon.com/gp/product/B00O0RKGTO?btkr=1
12:47:39 <ReinH> Also much cheaper than the dead tree versions
12:49:56 <pjdelport> Yxven: Read some of the bigger libraries and see how they are organized?
12:51:26 * hackagebot ghci-pretty 0.0.1 - colored pretty-printing within ghci  http://hackage.haskell.org/package/ghci-pretty-0.0.1 (larsk)
12:51:28 * hackagebot json 0.9 - Support for serialising Haskell to and from JSON  http://hackage.haskell.org/package/json-0.9 (IavorDiatchki)
12:56:48 <snyp> Do you think infix looks better, or prefix, like for fmap and apply?
12:58:08 <EvanR> or postfix
12:58:37 <EvanR> f g h . . .
12:59:10 <EvanR> fmap looks better prefix, <$> looks better infix
12:59:38 <mauke> <&> looks better xifni
12:59:50 <snyp> EvanR:  yes.
13:02:33 <Guest53264> http://bit.ly/1xvn9KM
13:02:43 <ReinH> Suggest not clicking on that
13:03:30 <bitemyapp> ReinH: thanks
13:03:45 <snyp> Any tips for reading and understanding haskell code quickly? Or is it all experience?
13:04:41 <c_wraith> snyp: experience and not reading unmaintainably clever code.  (as I discovered when I checked an old snippet of mine earlier today)
13:05:20 <snyp> is using generous amount of let bindings recommended?
13:05:24 <snyp> c_wraith: hmmmm
13:05:40 <EvanR> i use more wheres than lets
13:05:56 <EvanR> but you can also do a big let too
13:06:02 <EvanR> or several small lets
13:06:03 <c_wraith> snyp: if it actually improves clarity to name subexpressions - in many cases a composition pipeline is easier to read than naming a bunch of intermediate results.
13:06:04 <yukko> how to write readable haskell code: run all of your functions through @pl
13:06:16 <pjdelport> snyp: Well-written code shouldn't generally be an obstacle to read (once you understand Haskell syntax and all, and any necessary concepts the code or library might depend on)
13:06:42 <snyp> c_wraith: ok
13:06:48 <snyp> pjdelport: i see
13:07:54 <pjdelport> snyp: There are multiple ways of expressing things, though, and it depends somewhat on taste. For example, i'm fond of writing functions as a compact expression with a where clause giving named sub-expressions.
13:07:56 <Denommus> weird
13:08:06 <c_wraith> pjdelport: http://lpaste.net/102101 I discovered that's not easy to read when I went back to it today.  I mean, I know what it does, and it's tricky. :)
13:08:29 <pjdelport> c_wraith: Two levels of "where" is probably a warning bell. :)
13:09:00 <c_wraith> pjdelport: that happens all the time.  The problem is the knot tying mixed with a CPS transform.
13:09:14 <pjdelport> c_wraith: True.
13:09:40 <snyp> yukko: what's @pl?
13:10:27 <c_wraith> snyp: a code obfuscation tool.  (not quite, but close enough for the purposes of his joke)
13:10:33 <yukko> snyp I was joking, it's a lambdabot feature that takes a function and makes it point-free
13:10:37 <snyp> pjdelport: i see. maybe coming from imperative languages makes me like let bindings more.
13:10:42 <EvanR> it makes your code pointless
13:10:42 <snyp> yukko: oh
13:11:02 <vanila> @pl \f x -> f (f x x) x
13:11:02 <lambdabot> join . ap (.) join
13:11:14 <yukko> @pl f a b c d = f d c b a
13:11:14 <lambdabot> f = fix (flip . ((flip . (flip .)) .) . flip . (flip .) . flip)
13:11:21 <EvanR> paradoxically it tends to add a lot of periods
13:11:24 <snyp> o_o
13:11:27 * hackagebot ghci-pretty 0.0.2 - colored pretty-printing within ghci  http://hackage.haskell.org/package/ghci-pretty-0.0.2 (larsk)
13:11:39 <Denommus> does anyone know how to check which files were searched by ghc-mod in flycheck-haskell?
13:12:21 <c_wraith> pjdelport: also, my accidental shadowing + near-shadowing don't help things. >_>
13:12:33 <fragamus> hey I am getting dirty in the IO monad, and I have some exceptions happening which I want to ignore because some of my actions are idempotent.  HOW can I ignore exceptions in an action
13:12:48 <EvanR> with catch
13:13:01 <vanila> c_wraith, what is thits for?
13:13:36 <c_wraith> vanila: I was using it for a "clever" BFS that used its output as its queue.  That's the recusion pattern abstracted out from it.
13:13:58 <EvanR> :t catch
13:13:59 <lambdabot> Exception e => IO a -> (e -> IO a) -> IO a
13:14:07 <bitemyapp> I have the exact code, h/o
13:14:08 <c_wraith> vanila: you could consider it to be kind of like a multi-scanl, or something.
13:14:34 <fragamus> EvanR:tank you
13:14:36 <bitemyapp> fragamus: http://stackoverflow.com/questions/4243117/how-to-catch-and-ignore-a-call-to-the-error-function
13:15:01 <bitemyapp> :t try
13:15:02 <lambdabot> Exception e => IO a -> IO (Either e a)
13:15:14 <bitemyapp> fragamus: you might consider using try and either as well
13:15:15 <bitemyapp> :t either
13:15:16 <lambdabot> (a -> c) -> (b -> c) -> Either a b -> c
13:15:18 <Denommus> forget it
13:15:21 <gonzaw> hey, I was wondering. Is there a mature haskell library for web services, and web service clients?
13:15:26 <Denommus> I deactivated flycheck-haskell because I'm dumb
13:15:28 <gonzaw> You know, with the WS-* extensions adn all that
13:15:35 <gonzaw> *and
13:15:36 <bitemyapp> then you just choose a default value in the case you get an exception.
13:15:49 <EvanR> "dont try to catch error"
13:16:02 <bitemyapp> > either (const 0) (+1) (Right 1)
13:16:03 <lambdabot>  2
13:16:08 <bitemyapp> > either (const 0) (+1) (Left "blah")
13:16:10 <lambdabot>  0
13:16:12 <bitemyapp> fragamus: ^^
13:16:38 <bitemyapp> fragamus: https://www.fpcomplete.com/user/snoyberg/general-haskell/exceptions/catching-all-exceptions
13:21:53 <EvanR> dont catch error, if you can help it, dont try to catch all exceptions
13:22:32 <EvanR> though it might be hard to catch the possibly large undocumented list of exceptions which you might reasonably want to ignore
13:23:58 <hans2504> Hi, I'm trying to implement a Warp Server using TLS client cert authentication. So far, I've grabbed a copy of WarpTLS.hs and modified it to require a client cert. I feel like I'm taking the long way around the block here. My next step is to write a function that verifies the client cert. Is this all done somewhere?
13:28:35 <SvenskFisk> Could anyone explain to me why case statements use ->, but guards use =?
13:30:13 <EvanR> or why case uses -> and function definition cases use =
13:30:38 <stephenmac7_> What is the Cont type for?
13:30:59 <Welkin> everything is converted to case statements
13:31:05 <Welkin> when it is compiled
13:31:28 * hackagebot simple-smt 0.1.0.0 - A simple way to interact with an SMT solver process.  http://hackage.haskell.org/package/simple-smt-0.1.0.0 (IavorDiatchki)
13:32:20 <c_wraith> that's easy.  = is used for equations
13:32:45 <c_wraith> -> is used for things that aren't equations
13:33:15 <c_wraith> in case Just 5 of Just x -> x, it would be a lie to claim Just 5 = 5
13:33:23 <c_wraith> So it doesn't use an =
13:33:42 <stephenmac7_> Meaning, I know it's for continuations, but it's it just a complicated way to write them?
13:34:55 <SvenskFisk> c_wraith: Thanks, that makes a lot of sense actually
13:36:28 * hackagebot ReadArgs 1.2.2 - Simple command line argument parsing  http://hackage.haskell.org/package/ReadArgs-1.2.2 (NoahEasterly)
13:40:46 <bobajett> noob dumb question: when I type: myListOFunctions = [doubleIt, doubleIt, doubleIt] ghci is ok, but when I type myListOfFunctions = [succ, succ, pred] it complains?
13:42:21 <bobajett> its probably because "succ" and pred are too general for ghci to understand here? So how do I fix this?
13:43:10 <hans2504> I'm not sure what you mean:
13:43:11 <hans2504> Prelude> let myListOfFuncs = [doubleIt, doubleIt, doubleIt]
13:43:11 <hans2504> Prelude> let myListOfFuncs = [succ, succ, pred]
13:43:11 <hans2504> Prelude>
13:44:32 <bobajett> when I type let myListOfFuncs = [succ, succ, pred], i get:
13:44:44 <bobajett>     No instance for (Enum a0) arising from a use of `succ'
13:45:10 <ReinH> :t let funcs = [succ, succ, pred] in funcs
13:45:11 <lambdabot> Enum a => [a -> a]
13:45:24 <ReinH> Did you give myListOfFuncs an explicit type?
13:45:55 <Ferdirand> win 19
13:45:58 <Ferdirand> oops
13:46:12 <Ankhers> Would anyone be able to explain the difference between boxed and unboxed types, or point me towards to reading material?
13:46:23 <bobajett> ReinH: no, I didn't know how to give an explicit type for a list of functions. I guess myListOfFunctions :: [a -> a] ?
13:47:02 <ReinH> bobajett: I can't reproduce that error so I'm not sure how you're getting it
13:47:06 <ReinH> can you pastie a ghci session?
13:47:07 <greymalkin> I feel like I'm graduating.
13:47:31 <greymalkin> I'm finally writing a haskell program where I need to break it up into modules for clarity's sake.
13:47:39 <ReinH> Ankhers: https://www.haskell.org/ghc/docs/latest/html/users_guide/primitives.html, http://stackoverflow.com/questions/13055/what-is-boxing-and-unboxing-and-what-are-the-trade-offs
13:48:02 <Ankhers> ReinH: Thanks.
13:49:37 <lpaste> bobajett pasted “No title” at http://lpaste.net/114264
13:50:02 <joe9> code:   http://codepad.org/Xd3zEOio , error : http://codepad.org/ii5bj6Hh any suggestions on how to get it to compile, please?
13:50:02 <bobajett> ReinH: there you go.
13:51:45 <ReinH> bobajett: Ah, you are experiencing the dreaded monomorphism restriction. You can either use the NoMonomorphismRestriction language pragma or give your definition an explicit type signature
13:51:57 <ReinH> which would be myListOfFunctions :: Enum a => [a -> a]
13:52:09 <ReinH> @where dmr
13:52:09 <lambdabot> http://www.haskell.org/haskellwiki/Monomorphism_restriction
13:52:30 <bobajett> ReinH: got it. So how come your ghci session didn't give you this error? Do you have something set in a configuration file to turn this restriction off?
13:53:16 <ReinH> bobajett: the monomorphism restriction is turned off at the ghci prompt
13:53:30 <ReinH> but not for files loaded by ghci
13:53:42 <greymalkin> hackage webserver crash?
13:54:00 <ReinH> greymalkin: yep
13:54:00 <bobajett> ReinH: gotcha. Thanks!
13:54:06 <ReinH> I'm sure someone is working on it
13:54:07 <greymalkin> ouch.
13:54:13 <ReinH> bobajett: np
13:54:33 <ReinH> greymalkin: you have documentation generation enabled in your cabal settings right?
13:54:48 <greymalkin> No idea, I assume so?
13:55:00 <ReinH> The default is off :(
13:55:06 <ReinH> http://www.vex.net/~trebla/haskell/cabal-cabal.xhtml
13:55:19 <ReinH> It's not a very good default
13:55:34 <hans2504> exit
13:57:56 <SvenskFisk> If I have something like "index <- getLine", can I apply the 'read' function to it in the same line to convert it to an int, or do I have to do it in two lines?
13:58:14 <ReinH> SvenskFisk: let's think about the types here
13:58:16 <ReinH> :t getLine
13:58:17 <lambdabot> IO String
13:58:42 <SvenskFisk> But index would be a String right? Then I could read it?
13:58:48 <ReinH> SvenskFisk: so if you have, say, read :: String -> Int, and you have IO String, what could you use to turn IO String into IO Int?
13:59:16 <ReinH> SvenskFisk: what about if I have read and Just "1"? How could I get Just 1?
13:59:16 <SvenskFisk> I don't know, is there such a function?
13:59:30 <ReinH> what about (+1) and [1], how can I get [2]?
13:59:50 <SvenskFisk> map?
13:59:55 <ReinH> :t fmap
13:59:56 <lambdabot> Functor f => (a -> b) -> f a -> f b
14:00:02 <ReinH> :t fmap read getLine
14:00:03 <lambdabot> Read b => IO b
14:00:18 <ion> Btw, in the case of IO, you’ll want to use readIO or readLn instead of fmap read.
14:00:35 <greymalkin> ReinH: O.M.G. thank you for that!  Just blasted away the sandbox, started a new one, and all is beautiful
14:01:11 <ReinH> ion: if you aren't going to handle the IO exception, there isn't much difference
14:01:19 <ReinH> but yes, in this particular case, readLn is a better option
14:01:20 <SvenskFisk> ReinH: Thank you! Large portions of my code are now unneccesary haha
14:01:38 <ReinH> greymalkin: np
14:02:07 <ReinH> I was more interested in pointing out that IO actions can be fmapped :)
14:02:54 <ReinH> ion: I would prefer readMaybe . getLine anyway
14:03:31 <bobajett> 2nd noob question: how can I successively apply the functions in this list to 1:  [succ, succ, pred]. I ended up with foldl (\v f -> f v) 1 [succ, succ, pred] but is there a nicer more idiomatic way?
14:04:15 <ion> [succ, succ, pred] <*> pure 1, map ($ 1) [succ, succ, pred]
14:04:30 <ion> Oh, that wasn’t what you wanted.
14:04:34 <cdk> foldl (flip ($))
14:05:04 <ion> foldl' is usually better than foldl
14:05:26 <bobajett> cdk: nice!
14:05:51 <EvanR> foldl' is usually/always better than foldl
14:06:31 <EvanR> so they should be swapped ;)
14:07:17 <EvanR> foldl = foldl', foldl'' = foldl, use foldl'' when you want your system to perform worse or just crash
14:18:24 <spaceships> I find myself writing something like this all the time "applyM2 f x y = x >>= \x' -> y >>= f x'". is there something like this defined in the standard libraries?
14:18:53 <spaceships> with applyM2 :: Monad m => (a -> b -> m c) -> m a -> m b -> m c
14:19:06 <EvanR> @hoogle Monad m => (a -> b -> m c) -> m a -> m b -> m c
14:19:10 <lambdabot> Control.Monad zipWithM :: Monad m => (a -> b -> m c) -> [a] -> [b] -> m [c]
14:19:10 <lambdabot> Control.Monad zipWithM_ :: Monad m => (a -> b -> m c) -> [a] -> [b] -> m ()
14:19:10 <lambdabot> Control.Monad foldM :: Monad m => (a -> b -> m a) -> a -> [b] -> m a
14:20:25 <EvanR> :t (>=>)
14:20:26 <lambdabot> Monad m => (a -> m b) -> (b -> m c) -> a -> m c
14:20:46 <zipper> Man just how much does one have to read to actually be good at haskell and CS?
14:20:59 <EvanR> counterstrike?
14:21:19 <hpc> it doesn't take much to start writing regular code that does regular things
14:21:38 <zipper> I was so happy about to complete http://www.seas.upenn.edu/~cis194/lectures.html when I discovered http://www.scs.stanford.edu/14sp-cs240h/
14:21:48 <EvanR> @pl \f x y -> x >>= \x' -> y >>= f x'
14:21:48 <lambdabot> flip ((.) . (>>=)) . flip ((.) . (>>=))
14:22:01 <zipper> hpc: Well nobody likes to be average.
14:22:17 <Ouyang> haskell websites down for anyone? the status website says they are up
14:22:18 <zipper> EvanR: WHat does pl do?
14:22:33 <EvanR> converts something with variables into only composed combinators
14:22:56 <hpc> pl stands for pointless
14:23:01 <spaceships> sometimes it makes things simpler. not in this case :D
14:23:05 <hpc> which means pointfree which means without points
14:23:14 <hpc> (points are explicit mentions of function parameters)
14:23:21 <EvanR> spaceships: it revealed a pattern, see g . g
14:23:22 <josephle> but sometimes it makes you wonder if trying to go pointfree is pointless
14:24:17 <zipper> lol I was waiting for someone to say what points actually means hpc
14:24:50 <hpc> that looks like a pretty good class though
14:25:02 <hpc> bos and ezyang both are sometimes here
14:25:07 <Ouyang> ok dumb quick question (servers are down for  me) but if I am making a script of functions to load into ghci, would I not just define variables such as xs = [True, True]?
14:25:28 <Ouyang> I figured using :load would work on loading both the objects and the functions
14:25:52 <hpc> Ouyang: the easiest way to do what you want without weird edge cases is
14:25:53 <hpc> ghci foo.hs
14:25:57 <hpc> and then to reload, do :r
14:25:58 <zipper> hpc: Looks like a very good class to me too but... the workload seems huge. no?
14:26:05 <spaceships> EvanR: it's just bind with an extra argument ... uncommon I guess
14:26:15 <hpc> it will properly reload things
14:26:16 <Ouyang> ok thank you hpc
14:26:31 <hpc> :load and :m+ and such do more specific things
14:27:44 <EvanR> spaceships: its fmap over a sequence of two actions
14:28:07 <spaceships> yep
14:28:20 <EvanR> f <$> x <*> y ?
14:28:22 <zipper> EvanR: Why would you want to write in pointless form? It seems so cryptic.
14:28:24 <Ouyang> oh do I need to declare variables inside main or something
14:28:30 <EvanR> zipper: for laughs
14:28:30 <L8D> nooooooo
14:28:50 <zipper> Oh lol
14:28:57 <L8D> my favorite library doesn't support safe haskell
14:28:58 <zipper> because I was confused as hell
14:29:00 <benmachine> Ouyang: you can define stuff at the toplevel
14:29:17 <maurer> Hey, does anyone know what's going on with haskell.org?
14:29:21 <hpc> zipper: that class is worth it
14:29:24 <L8D> @pl x -> case x of [] -> []; (x:xs) -> x:xs
14:29:24 <lambdabot> (line 1, column 5):
14:29:24 <lambdabot> unexpected '>'
14:29:24 <lambdabot> expecting operator
14:29:38 <hpc> it covers some pretty useful problems to know how to solve
14:29:47 <L8D> @pl \x -> case x of [] -> []; (x:xs) -> x:xs
14:29:47 <lambdabot> (line 1, column 22):
14:29:47 <lambdabot> unexpected '>'
14:29:47 <lambdabot> expecting operator
14:29:49 <spaceships> :t f <$> x <*> y
14:29:50 <lambdabot>     Couldn't match expected type ‘f a1’ with actual type ‘Expr’
14:29:50 <lambdabot>     In the second argument of ‘(<$>)’, namely ‘x’
14:29:50 <lambdabot>     In the first argument of ‘(<*>)’, namely ‘f <$> x’
14:30:05 <hpc> for general polymorphism/type class stuff, concurrency, etc
14:30:05 <spaceships> :t \f x y -> f <$> x <*> y
14:30:06 <lambdabot> Applicative f => (a1 -> a -> b) -> f a1 -> f a -> f b
14:30:19 <spaceships> f needs to have type (a -> b -> m c)
14:30:27 <EvanR> spaceships: oh, this is liftM2
14:30:49 <zipper> hpc: Will it help me learn stuff out of FP? Because I need to learn more and more CS. Luckily I saw STM among the topics and I know it's modern CS stuff.
14:31:08 <L8D> @pl \x xs -> [x] ++ [xs] >>= id
14:31:08 <lambdabot> flip flip id . ((>>=) .) . (. return) . (:)
14:31:12 <EvanR> spaceships: the <$> <*> pattern is for applicative, and liftM2 is the same thing just for monad
14:31:21 <spaceships> EvanR: yes
14:31:24 <zipper> FP has helped me learn more math and more CS
14:31:30 <zipper> but math mainly
14:31:48 <spaceships> EvanR: otherwise i would have used them, instead of defining ApplyM2 everywhere ;P
14:31:49 <L8D> >"math"
14:31:50 <hpc> zipper: don't worry about learning specifically functional programming
14:31:52 <L8D> >lol
14:32:17 <hpc> if you've made it to the point of this class, you're going to have a good grasp of functional style anyway and can focus on specific stuff
14:32:21 <EvanR> spaceships: oh, the f is itself monad..
14:32:22 <zipper> @pl \x y -> x
14:32:22 <lambdabot> const
14:32:26 <L8D> zipper: if you think that Haskell or FP in general is about maths then you have a long way to go
14:32:37 <spaceships> EvanR: yep
14:32:49 <EvanR> so its liftM2 without a return ;)
14:32:54 <spaceships> ya!
14:32:57 <EvanR> noreturn . liftM2
14:33:04 <spaceships> noreturn?
14:33:06 <spaceships> :t noreturn
14:33:07 <lambdabot>     Not in scope: ‘noreturn’
14:33:07 <lambdabot>     Perhaps you meant ‘return’ (imported from Control.Monad.Writer)
14:33:08 <EvanR> not realy
14:33:17 <spaceships> noreturn = unsafeCoerce
14:33:18 <spaceships> heh
14:33:33 <L8D> @let noreturn = unsafeCoerce
14:33:34 <lambdabot>  .L.hs:163:12: Not in scope: ‘unsafeCoerce’
14:33:35 <zipper> L8D: I didn't say that. I want to be better at CS. Learning haskell has made me learn about areas of math I didn't know about.
14:34:06 <L8D> did they take unsafeCoerce out of lambdabot?
14:34:17 <EvanR> spaceships: im finding it nicer to write this as do notation
14:34:39 <L8D> @pl \('f':'o':'o':xs) -> xs
14:34:39 <lambdabot> (line 1, column 3):
14:34:39 <lambdabot> unexpected "'"
14:34:39 <lambdabot> expecting pattern
14:34:39 <zipper> :t >>=
14:34:40 <lambdabot> parse error on input ‘>>=’
14:34:51 <spaceships> EvanR: applyM2 f x y = do x' <- x; y' <- y; f x' y' ?
14:35:06 <L8D> :t (>>=) @ zipper
14:35:07 <lambdabot> Pattern syntax in expression context: >>=@zipper
14:35:09 <zipper> :t (>>=)
14:35:10 <lambdabot> Monad m => m a -> (a -> m b) -> m b
14:35:11 <hpc> L8D: it was never in
14:35:11 <L8D> :t (>>=)
14:35:12 <lambdabot> Monad m => m a -> (a -> m b) -> m b
14:35:16 <hpc> you can write unsafePerformIO with it
14:35:23 <hpc> which then gets you access to arbitrary code
14:35:25 <spaceships> EvanR: I don't like it equally with the non-do form ;)
14:35:38 <EvanR> spaceships: well that yeah, but i mean just written out at the use-point
14:35:40 <zipper> @pl \f x -> x >>= f
14:35:40 <lambdabot> (=<<)
14:35:48 <zipper> :t \f x -> x >>= f
14:35:49 <lambdabot> Monad m => (a -> m b) -> m a -> m b
14:35:54 <spaceships> EvanR: ah yeah
14:36:02 <phaazon> hey
14:36:05 <L8D> @pl \f x -> x >>= return . f
14:36:05 <lambdabot> fmap
14:36:09 <L8D> :)
14:36:16 <phaazon> I’d like to include a haskell source hilighter in my blog
14:36:18 <phaazon> any idea how?
14:36:30 <spaceships> EvanR: often is the differnce between a 1 liner and a 3 liner in the code i've been writing, which is nice when pattern matching over some big datatype
14:36:33 <L8D> phaazon: javascript?
14:36:39 <L8D> phaazon: highlight.js?
14:36:46 <phaazon> L8D: isn’t there something already done for that?
14:36:52 <phaazon> L8D: is there a haskell support?
14:36:56 <phaazon> a _good_ one
14:36:56 <L8D> phaazon: of course
14:37:04 <phaazon> ok, thanks :)
14:37:11 <L8D> phaazon: wait are you using hakyll?
14:37:12 <hpc> phaazon: i used shBrush
14:37:25 <zipper> L8D: Nice one
14:37:30 <piskrist> I liked rainbow.js
14:38:00 <hpc> it falls back to a <pre> tag and actually works with noscript
14:38:09 <piskrist> I recently replaced other highlighter with it, I think it might have been the highlight.js
14:38:20 <hpc> really anything that can be css configured will work
14:38:29 <zipper> L8D: When you wrapped f in a monad but unwrapped x
14:38:41 <L8D> phaazon: https://highlightjs.org/static/test.html#anchor-haskell
14:39:00 <L8D> zipper: I wasn't wrapping f though
14:39:05 <L8D> zipper: I was composing it with return
14:39:12 <phaazon> thanks L8D
14:39:22 <zipper> wouldn't you again have to wrap x in a monad then use <*> on them?
14:39:35 <zipper> I don't see how it's fmap
14:39:36 <phaazon> woh that rocks!
14:39:57 <zipper> L8D: Talking to you
14:40:08 <phaazon> oh there’s monokai <3
14:40:16 <L8D> :t (<*>)
14:40:17 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
14:40:18 <zipper> L8D: Oh yeah you composed it
14:40:19 <EvanR> zipper: fmap for monads just uses a f on the result of an action, then returns it
14:40:20 <L8D> @src (<*>)
14:40:21 <lambdabot> Source not found. stty: unknown mode: doofus
14:40:25 <phaazon> I use that in my vim
14:40:30 <phaazon> I luv it <3
14:40:36 <L8D> Tomorrow ftw
14:40:43 <Vorpal> This is probably a stupid newbie question, but is there a generic way to evaluate to normal form (like seq evaluates to weak head normal form)? I mean, I can obviously write a function to evaluate a specific data structure to normal form, but I'm interesting in a generic one.
14:40:49 <zipper> L8D: So that it can return a type m b
14:40:50 <L8D> I'm like the only person in my city who uses a light color scheme
14:40:59 <EvanR> Vorpal: theres NFData
14:41:04 <L8D> zipper: yes
14:41:04 <MP2E> Vorpal: deepseq :)
14:41:08 <L8D> :t (return .)
14:41:09 <lambdabot> Monad m => (a -> b) -> a -> m b
14:41:31 <Vorpal> EvanR, MP2E, ah thanks, will take a look at those. Are they part of the haskell platform or external?
14:41:33 <zipper> but >>= returns a monad you don't have to return for it to give a monad
14:41:37 <zipper> L8D:
14:41:42 <EvanR> deepseq package
14:41:43 <MP2E> deepseq is used in GHC, so it's definitely available with the platform
14:41:46 <MP2E> NFData should be as well.
14:41:47 <Vorpal> Ah
14:42:00 <EvanR> in general you cant evaluate everything to normal form
14:42:05 <EvanR> because it may not exist
14:42:17 <L8D> zipper: but f doesn't return a monad
14:42:35 <zipper> :t (>>=)
14:42:36 <lambdabot> Monad m => m a -> (a -> m b) -> m b
14:42:48 <Vorpal> EvanR, you mean, it might throw an exception for example?
14:42:49 <L8D> f is of type a -> b instead of a -> m b
14:42:53 <zipper> L8D: Oh nice
14:43:06 <L8D> but when I do:
14:43:19 <L8D> @pl \f x -> x >>= return . f
14:43:20 <lambdabot> fmap
14:43:21 <EvanR> Vorpal: or freeze up, or stack overflow, or... but you can ensure a specific data type has normal forms
14:43:21 <zipper> and the return made it of type a -> m b
14:43:32 <L8D> it's making the assumption that the monad is also a functor
14:43:39 <L8D> (which is basically true)
14:43:39 <Vorpal> EvanR, right. Makes sense.
14:43:51 <EvanR> but not necessarily algorithms that build the data
14:43:53 <L8D> (except for all those idiots who use monads to make DSLs out of do-blocks)
14:44:08 <L8D> (just fuck those people)
14:44:15 <L8D> (they don't even make then MonadIOs!!!)
14:44:25 <L8D> them*
14:44:43 <EvanR> abusing do syntax for fun and profit
14:45:13 <zipper> L8D: Ha the do syntax
14:45:27 <L8D> GHC should require proofs one every type instance to prevent people from breaking rules
14:45:32 <L8D> like how idris does it
14:45:37 <L8D> on*
14:46:01 <L8D> GHC-declared rules I mean...
14:46:06 <zipper> Is idris based on haskell?
14:46:11 <L8D> of course
14:46:16 <benzrf> > 10 `divRem` 3
14:46:17 <MP2E> yeah, so is Agda
14:46:18 <lambdabot>  Not in scope: ‘divRem’
14:46:18 <L8D> idris IS haskell but with dependent types
14:46:26 <benzrf> > 10 `divMod` 3
14:46:26 <n4x> zipper: it has haskell-ish syntax, but it isn't exactly haskell
14:46:27 <lambdabot>  (3,1)
14:46:27 <MP2E> Idris is strictly evaluated instead of lazily evaluated
14:46:39 <L8D> MP2E: IT IS?!
14:46:42 <ReinH> Idris is not Haskell with dependent types...
14:46:43 <L8D> oh god
14:46:46 <ReinH> It has a similar syntax.
14:46:48 <benzrf> @let maybeDiv x y = case x `divMod` y of (n, 0) -> Just n; _ -> Nothing
14:46:50 <lambdabot>  Defined.
14:46:50 <EvanR> idris is implemented in haskell
14:46:53 <benzrf> lambdabot:
14:46:55 <benzrf> * L8D:
14:47:06 <benzrf> > fmap (`maybeDiv` 3) (Just 10)
14:47:06 <L8D> benzrf: what?
14:47:07 <lambdabot>  Just Nothing
14:47:11 <MP2E> yes, but since Idris is total it doesn't have normal implications. You can still reason with infinite data structures and such
14:47:12 <zipper> L8D: I don't know what dependent types are
14:47:16 <benzrf> just cause it's a kleisli arrow, doesnt mean u cant fmap
14:47:18 <L8D> zipper: you don't need to
14:47:52 <zipper> L8D: by type instance you mean every time we create a value of that type?
14:47:53 <EvanR> MP2E: it can be total if you turn on total by default, otherwise its partial
14:47:57 <MP2E> ah
14:47:59 <MP2E> good to know EvanR
14:48:05 <Vorpal> EvanR, oh, so deepseq requires your type to support evaluation to normal form by being part of the NFData typeclass? Well okay, I was hoping for a generic "magic" way like seq, where you don't need support from the underlying type, but I guess that is prone to breaking as you described above
14:48:22 <L8D> zipper: when the words "class", "type class", "instance" and "type instance" are used we are talking about the type system
14:48:46 <L8D> benzrf: isn't there a instance Monad m => Functor m ?
14:48:55 <EvanR> Vorpal: all the standard types have NFData instance, and you can easily make an instance, ... for me i didnt even have to implement anything just put instance NFData Foo where
14:48:56 <zipper> L8D: I know all those except for type instance
14:49:02 <ReinH> L8D: no
14:49:10 <Vorpal> EvanR, hm okay
14:49:11 <L8D> ReinH: couldn't there be?
14:49:15 <ReinH> L8D: yes.
14:49:25 <benzrf> L8D: that's not valid
14:49:31 <benzrf> at least, not w/o extensions
14:49:34 <zipper> unless you mean typeclass instance
14:49:40 <ReinH> Although it should be Functor m => Applicative m => Monad m, and will be in 7.10
14:49:54 <L8D> zipper: there's a difference between typeclass and class though
14:50:17 <zipper> L8D: and the difference is?
14:50:17 <L8D> ReinH: why are all the cool things in 7.10?
14:50:42 <MP2E> well, that's how we felt about 7.8 before it was out too :) GHC just improves at an alarming rate
14:50:46 <MP2E> thus the yearly releases
14:51:23 <zipper> ReinH: Your voice has not been heard in a while.
14:51:31 <zipper> What happened?
14:51:42 <ReinH> zipper: we got busy. Recording a new one this weekend.
14:51:52 <jfischoff> ReinH: speaking of which congrats a the new job :)
14:51:56 <ReinH> jfischoff: thanks!
14:51:57 <L8D> zipper: nothing ;-)
14:51:57 <jfischoff> are you remote or around here?
14:51:57 <zipper> ReinH: sweet
14:52:02 <ReinH> jfischoff: remote :)
14:52:05 <jfischoff> cool
14:52:06 <zipper> jfischoff: Which new job?
14:52:15 <ReinH> jfischoff: but I travel sometimes. Maybe we can get dinner next time I'm in the area.
14:52:20 <jfischoff> yeah
14:52:30 <jfischoff> just ping me
14:52:34 <zipper> L8D: You mean there is no difference? You were joking?
14:52:58 <L8D> zipper: oh sorry, I though I typed "there's not a"
14:53:03 <ReinH> zipper: `class' defines a typeclass.
14:53:20 <ReinH> typeclass is not synonymous with `class' in, say, OOP
14:53:31 <phaazon> hm L8D
14:53:40 <L8D> phaazon: ?
14:53:42 <phaazon> I can’t find any way to specify the theme I wanna use
14:53:45 <phaazon> (hilight.js)
14:53:56 <L8D> phaazon: oh it's whatever CSS stylesheet you choose to use
14:54:03 <zipper> ReinH:  L8D made a confusing typo
14:54:20 <L8D> phaazon: it's not something specified in JavaScript
14:54:24 <Mokosha> can someone explain to me the reasoning behind this difference: https://www.haskell.org/hoogle/?hoogle=(a+-%3E+b+-%3E+c)+-%3E+Map+k+a+-%3E+Map+k+b+-%3E+Map+k+c
14:55:12 <L8D> Mokosha: are you looking for a map zip?
14:55:16 <ReinH> Mokosha: weird
14:55:21 <jfischoff> I don’t get how hoogle works
14:55:37 <zipper> jfischoff: Why?
14:55:53 <zipper> How to use or how it actually works?
14:56:02 <jfischoff> the implementation
14:56:17 <jfischoff> does it return all specializations?
14:56:27 <zipper> I know how to use a lot of things in haskell but have no idea how they work/implementation :(
14:56:35 <jfischoff> yeah
14:56:43 <L8D> zipper: what's your background?
14:56:44 <EvanR> magnets
14:56:59 <jfischoff> I find that decreases as time goes by, but I guess it will always be there
14:57:03 <josephle> one of two things: FFI magic or Type magic :P
14:57:06 <phaazon> L8D: oh, ok, thanks
14:57:35 <zipper> L8D: I'm in school 3rd year taking informatics. http://mu.ac.ke
14:58:52 <zipper> L8D: They teach us so much business things and so little CS it hurts. Self teaching wins though.
14:59:11 <ReinH> zipper: fix your cert :p
14:59:26 <L8D> zipper: so you don't have a programming background yet?
14:59:36 <L8D> it's good your starting with Haskell though :D
14:59:48 <ToTheInternet> i have a list of expressions that each return a [String] list when evaluated. i want to evaluate them one after another until the resulting [String] list is not empty, in which case i don't want to evaluate the remaining expressions anymore. any pointers on that?
14:59:49 <EvanR> go to school to learn how to learn
14:59:54 <ReinH> josephle: I prefer to call it sufficiently advanced technology. Except maybe for the FFI stuff.
14:59:56 <EvanR> rather than be taught
14:59:58 <EvanR> (by some asshole)
15:00:08 <L8D> ToTheInternet: use a fold
15:00:29 <ReinH> A foldr, specifically
15:00:38 <L8D> wait no
15:01:00 <Axman6> that's just dropWhile null no?
15:01:03 <L8D> ToTheInternet: what do you mean by "list of expressions" ?
15:01:09 <EvanR> takeWhile not null
15:01:11 <ReinH> Axman6: good point
15:01:17 <Axman6> take 1 . dropWhile null anyway
15:01:23 <zipper> L8D: What do you mean? That course is a CS related course. Like when they advertise a job and say CS or a related degree. It's related. Something like less CS and business mixed.
15:01:29 <ToTheInternet> L8D: basically a list of functions that return [String]
15:01:30 <ReinH> take 1 . dropWhile null . fmap evaluate
15:01:31 <ReinH> yay laziness
15:01:40 <zipper> ReinH: I didn't get that.
15:01:47 <Axman6> lazy evaluation will only evaluate at most up to the first non-null result
15:01:53 <L8D> ToTheInternet: but what do the functions take?
15:01:53 <ToTheInternet> L8D: i want to evaluate the functions until i find one that returns a non empty list
15:02:05 <L8D> ToTheInternet: Haskell doesn't really have a strong notion of "evaluate"
15:02:09 <zipper> L8D: Oh I know other langs like python ruby and a little C++
15:02:17 <L8D> ToTheInternet: do you just mean a list of strings?
15:02:27 <zipper> L8D: I thought you were asking education haha
15:02:50 <ToTheInternet> L8D: in fact it is only 1 function applied to different arguments. func :: [String] -> [(String,Int)] -> [String]
15:02:50 <L8D> zipper: are you super experienced in them or just entry level stuff?
15:03:44 <ToTheInternet> L8D: i worded my problem wrong. i have different arguments that i want to apply the function to, until it returns a non empty list
15:03:48 <Mokosha> L8D, yea, something that does unionWith where I can union two maps with different value types that share the same key type
15:03:59 <zipper> L8D: I can use them to do stuff I need. No big projects. A few web things and writing scripts I need for my needs
15:04:14 <EvanR> ToTheInternet: so you want to find the first non empty result
15:04:18 <zipper> L8D: So entry level I guess. :(
15:04:19 <L8D> Mokosha: you could write your own
15:04:48 <ToTheInternet> EvanR: yes
15:04:59 <L8D> ToTheInternet: then you make a list of those arguments, fold over them with the function, and dropWhile null
15:05:12 <EvanR> ToTheInternet: so if you have a [[String]] you want a Maybe [String]
15:05:15 <Axman6> ToTheInternet: if you can produce a list of lists of String ([[String]]), where each inner list is the function applied to a different argument, it's trivial to find the first non-null result
15:05:32 <L8D> zipper: well in case you haven't noticed, everything is completely different in Haskell
15:05:34 <ReinH> > listToMaybe . dropWhile null . map ($ 1) $ cycle [const [], const [1]]
15:05:36 <lambdabot>  Just [1]
15:05:49 <L8D> zipper: and you don't need to understand how the compiler works or performs it's lazy-eval optimizations
15:05:50 <ReinH> only evaluates enough to produce the [1]
15:05:54 <Axman6> > take 1 . dropWhile null $ [[],[],["Hello",World!"],[]]
15:05:55 <lambdabot>  <hint>:1:55:
15:05:56 <lambdabot>      lexical error in string/character literal at end of input
15:06:02 <Axman6> > take 1 . dropWhile null $ [[],[],["Hello","World!"],[]]
15:06:03 <lambdabot>  [["Hello","World!"]]
15:06:08 <zipper> L8D: I noticed that the second I started haha
15:06:16 <Axman6> > listToMaybe . dropWhile null $ [[],[],["Hello","World!"],[]]
15:06:18 <lambdabot>  Just ["Hello","World!"]
15:06:50 <zipper> L8D: I was reading http://book.realworldhaskell.org/read/profiling-and-optimization.html and decided to look at it at a later date
15:06:52 <EvanR> :t find
15:06:53 <lambdabot> (a -> Bool) -> [a] -> Maybe a
15:07:05 <EvanR> find (not . null)
15:07:10 <ToTheInternet> Axman6: wouldn't this give me all non empty lists though? i only want the first one (after which i want to stop evaluating the remaining arguments)
15:07:10 <L8D> zipper: Haskell enphasizes "higher level programming"
15:07:38 <zipper> The second I saw printf in example haskell code I knew I was in the wrong place
15:07:39 <ReinH> This is often done with filter, since filter is also lazy:
15:07:42 <ReinH> > listToMaybe . filter (not . null) . map ($ 1) $ cycle [const [], const [1]]
15:07:42 <EvanR> @src find
15:07:42 <lambdabot> find p = listToMaybe . filter p
15:07:43 <lambdabot>  Just [1]
15:07:50 <zipper> I didn't even know haskell uses `printf`
15:08:10 <ReinH> zipper: printf is an ugly hack in Haskell
15:08:17 <EvanR> as in C
15:08:22 <ReinH> touché
15:08:30 <zipper> ReinH: Had me confused when reading http://book.realworldhaskell.org/read/profiling-and-optimization.html
15:08:42 <Axman6> > listToMaybe . dropWhile null $ [[],[],["Hello","World!"],[],["I'm","also","non-empty"]] -- ToTheInternet
15:08:44 <lambdabot>  Just ["Hello","World!"]
15:08:51 <ReinH> It makes me sad that RWH uses printf
15:08:53 <zipper> Threw me off for the rest of the chapter
15:09:00 <n4x> it is a "proof of concept" that you can have varidic(sp?) functions in Haskell :P
15:09:06 <zipper> :t printf
15:09:07 <lambdabot> PrintfType r => String -> r
15:09:22 <ReinH> n4x: just because you can do something doesn't mean it should be done :p
15:09:24 <zipper> PrintfType?
15:09:38 <ReinH> zipper: a magic typeclass
15:09:47 <EvanR> > find (not . null) [[], [], [], ["hoohah", ":|"], ["shucks"]]
15:09:49 <lambdabot>  Just ["hoohah",":|"]
15:09:55 <ReinH> oh, find, nice
15:10:04 <ReinH> I forgot that was a thing
15:10:08 <ReinH> find is perfect
15:10:09 <zipper> :t find
15:10:10 <lambdabot> (a -> Bool) -> [a] -> Maybe a
15:10:17 <Axman6> I always forget find exists
15:10:26 <L8D> are there any Haskellers from Austin?
15:10:29 <Axman6> but it is just listToMaybe . dropWhile
15:10:38 <zipper>  Axman6 I didn't know it exists,
15:10:44 <ReinH> Axman6: listToMaybe . filter, actually
15:10:45 <n4x> it is nice how much the type says about the function itself
15:11:09 <ToTheInternet> thanks for the valuable input
15:11:16 <EvanR> unlike some functions types, head :: [a] -> a
15:11:38 <ToTheInternet> i need to read up again on Maybe and Just, keep forgetting what's that about
15:11:41 <Welkin> head is unsafe
15:11:45 <n4x> that lets you know it is a partial function
15:11:45 <L8D> only use head when working with comonadic lists
15:11:48 <mjboa> what can I do with dependent types that I can't do with Liquid Haskell?
15:11:58 <zipper> > (\x -> x == 3) [1,2,3,4,5]
15:12:00 <lambdabot>  No instance for (GHC.Classes.Eq t0)
15:12:00 <lambdabot>    arising from a use of ‘GHC.Classes.==’
15:12:00 <lambdabot>  The type variable ‘t0’ is ambiguous
15:12:00 <lambdabot>  Relevant bindings include x :: [t0] (bound at <interactive>:1:3)
15:12:00 <lambdabot>  Note: there are several potential instances:
15:12:07 <L8D> though if you're using comonadic lists you might as well just use streams
15:12:09 <zipper> > (\x -> x == 3) [1,2,3,4,5] :: Maybe Int
15:12:11 <lambdabot>  Couldn't match expected type ‘Data.Maybe.Maybe GHC.Types.Int’
15:12:11 <lambdabot>              with actual type ‘GHC.Types.Bool’
15:12:14 <L8D> so yeah...
15:12:24 <n4x> zipper: what are you trying to do?
15:12:25 <L8D> "head considered harmful"
15:12:36 <zipper> n4x: lol use find
15:12:40 <L8D> it'll get number one on lobsters
15:12:47 <n4x> > find (==3) [1,2,3,4,5]
15:12:50 <lambdabot>  Just 3
15:13:06 <ReinH> > find (==3) [1,2,3,undefined,undefined]
15:13:08 <lambdabot>  Just 3
15:13:10 <ReinH> yay laziness
15:13:30 <zipper> n4x: Why is my lambda bad? I see no difference
15:13:38 <zipper> n4x: Both take one arg
15:13:41 <ReinH> zipper: you don't use find?
15:14:01 <n4x> > find (\x → x == 3) [1..]
15:14:03 <lambdabot>  Just 3
15:14:08 <n4x> there, using a λ :P
15:14:09 <EvanR> > let isBottom = const False in find [1, 2, 3, undefined, undefined]
15:14:09 <blizzy> that reminds me. what exactly does Maybe do.
15:14:11 <lambdabot>  Couldn't match expected type ‘a -> GHC.Types.Bool’
15:14:11 <lambdabot>              with actual type ‘[t0]’
15:14:16 <Cale> zipper: (==3) is syntax sugar for (\x -> x == 3) anyway
15:14:17 <zipper> n4x: LMAO I didn't actully USE find
15:14:18 <L8D> > let x = read (show 1) in x == x
15:14:20 <lambdabot>  *Exception: Prelude.read: no parse
15:14:24 <EvanR> > let isBottom = const False in find isBottom [1, 2, 3, undefined, undefined]
15:14:25 <lambdabot>  Nothing
15:14:26 <zipper> > find (\x -> x == 3) ([1,2,3,4,5]
15:14:28 <lambdabot>  <hint>:1:33:
15:14:28 <lambdabot>      parse error (possibly incorrect indentation or mismatched brackets)
15:14:37 <zipper> > find (\x -> x == 3) [1,2,3,4,5]
15:14:39 <lambdabot>  Just 3
15:14:40 <Welkin> blizzy: Maybe represents a computation that can fail
15:14:48 <zipper> smh
15:14:57 <blizzy> so it's basically a try/catch?
15:15:02 * ReinH sighs
15:15:06 <ReinH> @src Maybe
15:15:06 <lambdabot> data Maybe a = Nothing | Just a
15:15:17 <ReinH> That's what Maybe does
15:15:21 <EvanR> > let isBottom x = x `seq` False in find isBottom [1, 2, 3, undefined, undefined]
15:15:22 <zipper> ReinH: lol
15:15:23 <L8D> blizzy: have you gotten to Monads yet?
15:15:23 <lambdabot>  *Exception: Prelude.undefined
15:15:27 <ReinH> @src Maybe fmap
15:15:27 <lambdabot> fmap _ Nothing  = Nothing
15:15:27 <lambdabot> fmap f (Just a) = Just (f a)
15:15:27 <ReinH> and that
15:15:39 <blizzy> L8D, no. I've heard monads are hard af tho. :L
15:15:47 <blizzy> thanks, Welkin.
15:15:48 <Welkin> blizzy: they are not hard
15:15:53 <n4x> they are hard as conditionals
15:16:07 <zipper> blizzy: lol I think I know what monads are
15:16:11 <ReinH> blizzy: maybe represents having something or nothing
15:16:32 <blizzy> thxs everyone.
15:16:37 <zipper> They are just wrappers for things. I stand corrected.
15:16:42 <zipper> Monads ^^
15:16:45 <n4x> > fmap (\x → x * 2) (Just 2)
15:16:46 <lambdabot>  Just 4
15:16:47 <L8D> zipper: what is? [[1], [2, 3, 4], [5], [6, 7]] >>= id
15:16:52 <L8D> no one evaluate that
15:16:54 <n4x> > fmap (\x → x * 2) Nothing
15:16:56 <lambdabot>  Nothing
15:17:23 <zipper> L8D: lol uh the same thing
15:17:33 <EvanR> zipper: not all monad instances are wrappers/containers
15:17:45 <ReinH> (>>= id) = join
15:17:49 <L8D> zipper: nope
15:17:59 <n4x> m (m a) → m a
15:18:02 <zipper> L8D: but id won't wrap it in a monad will it?
15:18:08 <L8D> zipper: it won't
15:18:23 <zipper> Yeah so it shouldn't even work
15:18:27 <ReinH> It works.
15:18:31 <L8D> it definitely work
15:18:39 <L8D> zipper: lists are monads
15:18:40 <n4x> it is join, which is "concat" for lists
15:18:42 <Cale> zipper: It's very misleading to think of monads as simply wrapper types.
15:18:48 <L8D> n4x: don't explain it!
15:18:50 <L8D> ywt
15:18:55 <dfeuer_> Monads is as monads does!
15:18:59 <zipper> but id is not type `a -> ma`
15:19:09 <L8D> zipper: it's not
15:19:10 <ReinH> in soviet russia, you wrap monad! wait no...
15:19:11 <n4x> zipper: try to match the types
15:19:12 <Welkin> :t id
15:19:13 <lambdabot> a -> a
15:19:15 <Cale> zipper: For instance, you wouldn't think of /bin/ls as being merely some kind of wrapped up list of files.
15:19:24 <n4x> ReinH: in soviet russia, haskellers use comonads
15:19:33 <Cale> zipper: So why think of values of type IO t as "wrapped up" values of type t?
15:19:53 <L8D> :t (>>= \(x:xs) -> x:xs)
15:19:54 <lambdabot> [[b]] -> [b]
15:19:56 <dfeuer_> n4x, I think in the Soviet Contraunion, comonads use Haskellers.
15:20:09 <ReinH> @quote /bin/ls
15:20:09 <lambdabot> shachaf says: getLine :: IO String contains a String in the same way that /bin/ls contains a list of files
15:20:14 <Cale> zipper: A value of type IO t is a description of some action which if carried out would produce a value of type t as its result.
15:20:25 <Cale> (provided that it completes normally)
15:20:47 <EvanR> not all monads are wrappers, but this is not because IO is somehow special
15:20:55 <zipper> Cale: Wow I actually read something very similar in some lecture notes.
15:21:10 <dfeuer_> In GHC, IO *is* a wrapper (a newtype).
15:21:11 <EvanR> IO is one counterexample, Parser is another
15:21:12 <dfeuer_> :P
15:21:23 <ReinH> So is (-> r)
15:21:25 <Cale> dfeuer_: a newtype around something fiddly
15:21:45 <Welkin> the reader monad is fun
15:21:48 <Cale> dfeuer_: (and hacky -- GHC's implementation of IO is really not the best one to think about)
15:21:50 <dfeuer_> Cale, well, a newtype around a function type between fiddly things.
15:21:58 <dfeuer_> No, GHC's implementation of IO is ugly.
15:22:03 <dfeuer_> You are right about that.
15:22:04 <zipper> ReinH: Yeah that (-> r) is something I avoid from functors to monads
15:22:17 <n4x> avoid?
15:22:29 <ReinH> zipper: you shouldn't void the (-> r) functor. You probably use it all the time.
15:22:34 <Cale> ReinH, zipper: you mean (->) r
15:22:35 <zipper> n4x: I read about an didn't get it. Decided to read later.
15:22:38 <dfeuer_> Cale, I'm wading into a bit of that (well, actually ST, but that's about the same) mucking around in GHC.Arr. Yech.
15:22:40 <ReinH> Cale: Woops
15:22:47 <ReinH> (r ->)
15:22:55 <zipper> Cale: Yeah same thing. Partially applied function
15:22:58 <Cale> Or if you're going to put the r inside the parens (which is invalid syntax) it would at least be (r ->), yeah
15:23:00 <ReinH> zipper: not the same thing
15:23:02 <Cale> It's not the same
15:23:03 <EvanR> Reader might be confused with a wrapper type
15:23:08 <ReinH> My bad
15:23:10 <n4x> zipper: no, (a →) != (→ a)
15:23:16 <zipper> OMFG my life is a lie
15:23:24 <Cale> (-> r), if it existed, would be the type constructor such that (-> r) t = (t -> r)
15:23:36 <n4x> the first would be (a → X) and the other would be (X → a)
15:23:38 <dfeuer_> Me wants to know why such a thing does not exist, Cale.
15:23:45 <Cale> (->) r is the type constructor such that (->) r t is (r -> t)
15:24:00 <dfeuer_> Me want type-level flip, me thinks.
15:24:05 <Cale> dfeuer_: Because Haskell has no type level lambda
15:24:22 <Cale> because it screws with a lot of things, notably type class instance resolution and type inference
15:24:32 <zipper> Cale: but it's waiting for the second argument
15:24:33 <dfeuer_> Hummm.
15:24:39 <zipper> -> already has a first
15:24:51 <ReinH> zipper: is (1/) the same as (/1)?
15:25:01 <zipper> ReinH: True
15:25:06 <EvanR> > (1/) 1 == (/1) 1
15:25:08 <lambdabot>  True
15:25:11 <EvanR> >:)
15:25:13 <Cale> lol
15:25:18 <Cale> > (1/) 2 == (/1) 2
15:25:19 <ReinH> Thanks.
15:25:20 <lambdabot>  False
15:25:25 <Cale> ruh roh
15:25:33 <ReinH> Same difference, except (-> r) isn't valid syntax.
15:25:33 <zipper> but -> a b == a -> b
15:25:48 <Cale> (->) a b = a -> b
15:25:50 <ReinH> zipper: (-> r) would be \t -> (t -> r)
15:25:58 <ReinH> (r ->) would be \t -> (r -> t)
15:26:03 <ReinH> (->)
15:26:03 <dfeuer_> > decodeFloat (0/0) == decodeFloat (0/0)
15:26:04 <lambdabot>  True
15:26:12 <dfeuer_> > 0/0 == 0/0
15:26:14 <lambdabot>  False
15:26:19 <EvanR> /\t => (t -> r)
15:26:34 <n4x> decodeFloat?
15:26:38 <ReinH> Anyway, the point is, you probably already use the (->) r Functor quite a bit
15:26:46 <dfeuer_> n4x, yeah, it's a function, you know.
15:26:48 <zipper> ReinH: Why so? Isn't (->) a function that's taking r as it's first arg?
15:27:03 <n4x> what is it doing? separing the exponent and mantisa of the float?
15:27:19 <ReinH> zipper: section notation is (a+) = \b -> a + b, (+a) = \b -> b + a
15:27:24 <dfeuer_> n4x, yah.
15:27:36 <n4x> ah, nice, didn't know about it
15:27:55 <ReinH> (r ->) and (-> r) would be section notation for type constructors
15:27:59 <zipper> I should write that down
15:28:25 <ReinH> zipper: sections have a hole on the side of the operator that doesn't contain a value
15:28:35 <ReinH> that's where the argument goes
15:28:41 <ReinH> s/value/expression
15:28:52 <ReinH> well, no, not all expressions are valid.
15:29:03 <benzrf> oh shit it just occurred to me
15:29:15 <benzrf> has anybody written a css-like lens lib for interacting with parsed html
15:29:17 <zipper> :t (+ 3)
15:29:18 <lambdabot> Num a => a -> a
15:29:38 <EvanR> :t (/ 0)
15:29:39 <lambdabot> Fractional a => a -> a
15:29:40 <zipper> That won't help because associativity
15:29:49 <zipper> in my +
15:29:54 <EvanR> (/ 0) 1
15:29:55 <ReinH> zipper: you mean commutativity?
15:29:58 <EvanR> > (/ 0) 1
15:29:59 <lambdabot>  Infinity
15:30:22 <EvanR> > toRational (1/0)
15:30:24 <lambdabot>  1797693134862315907729305190789024733617976978942306572734300811577326758055...
15:30:26 <zipper> ReinH: Heh I confuse these. I mean 3 + 2 == 2 + 3
15:30:27 <EvanR> sweet
15:30:32 <ReinH> zipper: commutativity
15:30:38 <fread2282> :o
15:30:55 <EvanR> infinite is an infinitely long number starting with a 1
15:31:12 <josephle> seems legi
15:31:15 <josephle> *legit
15:31:17 <EvanR> </sideshow>
15:31:49 <ReinH> Cale: Oh, I have a question you might know the answer to. It's a denotational semantics question.
15:32:45 <ReinH> Cale: infinity = 1 + infinity is bottom. Is infinity = S infinity also bottom? I thought fix S was a lub...
15:32:48 <benzrf> :t to
15:32:49 <lambdabot> (Contravariant f, Conjoined p, Functor f) => (s -> a) -> p a (f a) -> p s (f s)
15:33:08 <benzrf> wah
15:33:55 <Cale> ReinH: In Haskell it surely isn't bottom
15:34:10 <Cale> Unless the natural type is defined to be strict
15:34:21 <ReinH> Cale: the its approximating function approaches bottom in the limit?
15:34:25 <ReinH> *but its
15:34:25 <Cale> @let data Nat = Z | S Nat
15:34:27 <lambdabot>  Defined.
15:34:31 <Cale> > fix S
15:34:32 <lambdabot>  No instance for (GHC.Show.Show L.Nat)
15:34:32 <lambdabot>    arising from a use of ‘M539344265280714289826258.show_M5393442652807142898...
15:34:37 <Cale> @undefine
15:34:37 <lambdabot> Undefined.
15:34:39 <benzrf> :t \f -> dimap f (fmap f)
15:34:40 <lambdabot> (Profunctor p, Functor f) => (a -> b) -> p b (f a) -> p a (f b)
15:34:41 <Cale> @let data Nat = Z | S Nat deriving (Show)
15:34:42 <lambdabot>  Defined.
15:34:44 <Cale> > fix S
15:34:46 <lambdabot>  S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S...
15:35:09 <zipper> :t (id >>=)
15:35:10 <lambdabot> (a -> a -> b) -> a -> b
15:35:18 <ReinH> Cale: Right, I'm trying to understand how their denotations differ. Is it just due to strictness?
15:35:23 <benzrf> :t \f -> dimap f (contramap f)
15:35:24 <lambdabot> (Contravariant f, Profunctor p) => (a -> b) -> p b (f b) -> p a (f a)
15:35:25 <Cale> ReinH: In fact, it gets infinitely far away from _|_ in the ordering
15:35:32 <zipper> :t (>>= id)
15:35:33 <lambdabot> Monad m => m (m b) -> m b
15:35:37 <ReinH> Cale: right, it's a lub
15:35:42 <benzrf> huh...
15:35:49 <Cale> ReinH: It's the upper limit of the chain _|_ -> S _|_ -> S (S _|_) -> ...
15:36:11 <ReinH> Cale: I get that. I'm reading http://people.cis.ksu.edu/~schmidt/text/densem.html
15:36:20 <ReinH> But why is fix finding a lub?
15:36:34 * hackagebot google-oauth2 0.1.0 - Google OAuth2 token negotiation  http://hackage.haskell.org/package/google-oauth2-0.1.0 (PatrickBrisbin)
15:36:58 <ReinH> doesn't fix find the least fixed point?
15:37:02 <Cale> Yes
15:37:10 <Cale> _|_ is not a fixed point of S
15:37:24 <zipper> > [[2,3], [2,3,4,5]] >>= id
15:37:25 <lambdabot>  [2,3,2,3,4,5]
15:38:11 <zipper> > [[2,3], [2,3,4,5]] >>= return . id
15:38:12 <lambdabot>  [[2,3],[2,3,4,5]]
15:38:23 <benzrf> > let to f = dimap f (contramap f) in view (to snd) (3, 4)
15:38:25 <lambdabot>  4
15:38:32 <benzrf> what does to do o_o
15:38:42 <benzrf> i mean, the one in lens
15:38:46 <benzrf> why is its type so less general
15:38:49 <bobajett`> is there a way to turn on and off, language features within ghci itself and not when starting it? I'd like to turn off Xnomonomorphism in my emacs inferior-haskell buffer.
15:38:56 <ReinH> Cale: right, so the approximating function isn't f_0 = _|_, f_1 = _|_, like it is for fix (1+), it's f_0 = _|_, f_1 = S _|_, ...
15:38:58 <Cale> Otherwise, _|_ and S _|_ would have to be equal, in which case we'd have that  case undefined of Z -> 0; S n -> 1  and  case S undefined of Z -> 0; S n -> 1  would have to be equal
15:38:58 <benzrf> bobajett`: :set -X
15:39:09 <bobajett`> benzrf: thanks!
15:39:14 <ReinH> (assuming a strict (+))
15:39:28 <Cale> and we don't want those to be equal, the first one should be undefined (a.k.a. _|_) and the second should be 1
15:39:42 <Cale> yeah
15:39:44 <EvanR> Xnomnomnomorphism
15:39:46 <benzrf> @let data SNat = Z | S !SNat deriving Show
15:39:47 <lambdabot>  .L.hs:157:13:
15:39:47 <lambdabot>      Multiple declarations of ‘Z’
15:39:47 <lambdabot>      Declared at: .L.hs:153:12
15:39:47 <lambdabot>                   .L.hs:157:13
15:39:47 <lambdabot>  
15:39:51 <ReinH> and it's just due to strictness
15:39:52 <benzrf> bleh
15:39:53 <benzrf> @undef
15:39:54 <lambdabot> Undefined.
15:39:55 <ReinH> > fix (1+) :: Expr
15:39:56 <benzrf> @let data SNat = Z | S !SNat deriving Show
15:39:57 <lambdabot>  1 + (1 + (1 + (1 + (1 + (1 + (1 + (1 + (1 + (1 + (1 + (1 + (1 + (1 + (1 + (1...
15:39:57 <lambdabot>  Defined.
15:40:01 <benzrf> > fix S
15:40:05 <lambdabot>  mueval-core: Time limit exceeded
15:40:07 <benzrf> now *THAT* is bottom
15:40:07 <ReinH> Since a non-strict (+) behaves like S
15:40:21 <ReinH> and a strict S behaves like (+)
15:40:47 <Cale> Yeah, it's really about the structure of Integer more than it is about the operation of addition specifically
15:40:56 <zipper> @pl (id >>=)
15:40:57 <lambdabot> (id >>=)
15:41:02 <augur> grothendieck is dead :(
15:41:09 <Cale> Integer's partial ordering has _|_ and then all the integer values right above that, and nothing else.
15:41:09 <zipper> L8D: Why is (id >>=) same as join?
15:41:22 <Cale> zipper: It's not
15:41:29 <ReinH> zipper: it isn't
15:41:30 <Cale> zipper: (>>= id) is the same as join
15:41:34 <L8D> @src join
15:41:34 <lambdabot> join x = x >>= id
15:41:39 <L8D> ^
15:41:39 <ReinH> :t (>>=)
15:41:39 <lambdabot> Monad m => m a -> (a -> m b) -> m b
15:41:50 <ReinH> :t id
15:41:51 <lambdabot> a -> a
15:41:55 <L8D> zipper: (>>= id) not (id >>=)
15:41:59 <ReinH> you need to unify a -> m b with a -> a
15:42:02 <EvanR> Cale: what is Integer's partial ordering?
15:42:10 <ReinH> you can only do so by setting m b ~ a
15:42:14 <MP2E> bind can be written as 'm >>= f = join $ fmap f m'
15:42:18 <MP2E> fmap id = id
15:42:22 <zipper> Ok the (-> r) confused me
15:42:29 <ReinH> :t (=<<) `asAppliedTo` id
15:42:30 <lambdabot> Monad m => (m b -> m b) -> m (m b) -> m b
15:42:47 <Cale> EvanR: _|_ is strictly less than all the defined integer values, and the defined integer values are incomparable to each other, and that's all there is
15:43:14 <EvanR> ok the definedness ordering
15:43:18 <Cale> There are no partially defined Integers, you have bottom, or you have a completely defined one
15:43:29 * dfeuer_ offers Cale some hot chocolate.
15:43:34 <Cale> zipper: It's not (-> r)
15:43:49 <Cale> zipper: It's (r ->) if you're going to write it like that :)
15:43:56 <zipper> Ok I think I have it figured out.
15:43:59 <dfeuer_> Cale, you ever in the D.C. area? I could give you actual hot chocolate.
15:43:59 * ReinH apologizes for his typo
15:44:07 <zipper> Cale: lol I was confused.
15:44:23 <dfeuer_> ReinH, I read that as "apologizes for his type" :-P
15:44:28 <Cale> dfeuer_: I live in Canada, so hot chocolate would be nice, but it's a pretty sizeable trip to D.C.
15:44:45 <ReinH> Cale: where in Canada?
15:44:54 <Cale> Brantford, Ontario
15:44:56 <dfeuer_> Ah. I have ~family up in Toronto.
15:45:05 <dfeuer_> (my brother's girlfriend is from there)
15:45:13 <Cale> I'm about an hour's drive from Toronto.
15:45:15 <ReinH> Cale: Hmm, are you going to ICFP next year? I hear it'll be in Vancouver, BC?
15:45:24 <zipper> L8D: How is (>>= id) same as join? I can't see how (x -> x) is working as a (a -> m b) function
15:45:43 <L8D> zipper: it's not
15:45:48 <Cale> ReinH: Might be nice, but I wouldn't hold my breath :D
15:45:52 <L8D> the id in (>>= id) looks like:
15:45:56 <Cale> ReinH: I'm pretty bad at travelling
15:46:01 <L8D> m a -> m a
15:46:06 <L8D> :t join
15:46:07 <lambdabot> Monad m => m (m a) -> m a
15:46:12 <L8D> ^
15:46:34 * hackagebot hsqml 0.3.2.0 - Haskell binding for Qt Quick  http://hackage.haskell.org/package/hsqml-0.3.2.0 (RobinKay)
15:46:35 <Cale> zipper: Okay, let's think about what join ought to do
15:46:36 * hackagebot hsqml-demo-samples 0.3.2.0 - HsQML sample programs  http://hackage.haskell.org/package/hsqml-demo-samples-0.3.2.0 (RobinKay)
15:46:38 * hackagebot hsqml-demo-morris 0.3.1.0 - HsQML-based implementation of Nine Men's Morris  http://hackage.haskell.org/package/hsqml-demo-morris-0.3.1.0 (RobinKay)
15:47:16 <zipper> Cale: [[a]] -> [a]
15:47:59 <Cale> zipper: So, let's think about join x, where x :: M (M a), so x is an M-action which when we run it is itself going to produce an M-action of type (M a) as its result
15:48:04 <zipper> L8D: I think I see it a is a monad too
15:48:30 <Cale> Let's implement join in do-notation, so we want to first execute x, getting some additional computation y...
15:48:33 <zipper> but in that case it seems it should return an m (m a)
15:48:36 <Cale> join x = do y <- x; ...
15:48:38 <L8D> zipper: [[a]] -> ([a] -> [[a]]) -> [a]
15:48:38 <zipper> L8D: ^
15:48:55 <Cale> and then what we'll do is to execute y, getting some result v :: a
15:48:56 <zipper> Cale: ok I was uh distracted. I'm back now
15:48:56 <L8D> wait
15:49:02 <Cale> join x = do y <- x; v <- y; ...
15:49:03 <L8D> [[a]] -> ([a] -> [b]) -> [b]
15:49:06 <L8D> ^ zipper
15:49:08 <Cale> and we'll return that as our result
15:49:10 <Cale> join x = do y <- x; v <- y; return v
15:49:15 <Cale> cool?
15:49:24 <Cale> Let me know when you've caught up to this far :)
15:49:46 <Cale> So, the entire do-block there is an action of type M a
15:49:54 <Cale> because v :: a
15:50:01 <Cale> and so return v :: M a
15:50:14 <Cale> (and the type of a do-block is always the type of the last action in it)
15:51:17 <zipper> Cale: I might take a few minutes.
15:52:26 <fds4345> anyone find that overuse of type classes leads to lots of ambiguous type issues
15:52:29 <Cale> So to recap, x :: M (M a), and we obtain y as the result of executing x (that's what "y <- x" means), and so y :: M a, and then we obtain v as the result of running y, so v :: a
15:52:32 <Cale> fds4345: Sure
15:53:01 <zipper> Cale: ok here v is of type a and not m a
15:53:11 <Cale> yes
15:53:59 <EvanR> 0:w
15:54:03 <EvanR> uhg
15:54:06 <fds4345> Cale: Ie having to hint to the compiler the concrete types of an expression for it to be accepted. Really annoying
15:54:30 <Cale> fds4345: If you ever run into issues like that, consider just not using type classes. There's much to be said for good ol'-fashioned functional programming.
15:54:32 <EvanR> fds4345: you might need a top level type signature?
15:54:52 <Cale> fds4345: You can make record types consisting of the methods of your would-be type class, and pass those records around explicitly.
15:55:19 <Cale> This requires a little more typing, but avoids all issues of ambiguity and issues with wanting to define more than one instance per type.
15:55:46 <Cale> (and maybe less typing in the case that you would have been putting lots of explicit type signatures into your code)
15:56:21 <EvanR> i noticed typeclasses being more successful as a library export rather than a way to structure an application
15:56:27 <Cale> fds4345: That said, is this by any chance a multi-parameter type class?
15:56:28 <zipper> Cale: I see that it will return a type of m a because we eventually return a list but where it actally joined them into one list I think is where i don't get.
15:56:35 * hackagebot help-esb 0.1.6 - A Haskell client for the Help.com team's ESB.  http://hackage.haskell.org/package/help-esb-0.1.6 (suitupalex)
15:56:37 * hackagebot Agda 2.4.2.1 - A dependently typed functional programming language and proof assistant  http://hackage.haskell.org/package/Agda-2.4.2.1 (AndresSicardRamirez)
15:56:47 <Cale> zipper: Let's not worry about lists at all for the moment
15:56:54 <ReinH> fds4345: this happens a lot when the return type is typeclass polymorphic ime
15:57:23 <Cale> zipper: Worry about what the list instance of Monad does separately from this
15:58:08 <zipper> Oh it got lots of values of type a and wrapped them in the appropriate monad (figured by type inference) that is a list, right?
15:58:10 <Cale> zipper: So, does that code for join make sense on its own?
15:58:19 <zipper> Cale: Yes
15:58:25 <Cale> Please don't think of anything as being wrapped
15:58:41 <Cale> A value of type M a is some sort of computation which if we were to run it, would produce a value of type a.
15:59:21 <Cale> In particular, it's not (in general) very much like a value of type a which is wrapped up in some packaging. It could be in some instances, but those tend to be somewhat boring instances.
15:59:39 <zipper> Cale: but does my line of thought make sense?
15:59:47 <fds4345> Cale: I'd imagine its worth it to avoid the headache alone. Yes it is a MPTC. So I get around it by wrapping the data up with the methods to operate on it?
16:00:08 <Cale> zipper: Well, the real type of join is (Monad m) => m (m a) -> m a
16:00:24 <RaceCondition> trying to cabal install alex but getting: http://pastebin.com/F1PBUbMk
16:00:31 <Cale> zipper: and the type at which we use it determines which instance of the Monad class is selected, so which code for (>>=) and return gets used.
16:00:42 <fds4345> and its just become clear to me why I'm having the issue, its the MPTC
16:00:54 <Cale> fds4345: You might be looking for a functional dependency
16:01:09 <Peaker_> the name "monad transformers" might imply that monads are "type transformers"
16:01:10 <EvanR> fds4345: if youre trying to apply this to various different types, you could hide the "data" behind a closure. as long as no external code needs to use it
16:01:28 <Cale> Peaker_: and they are...
16:01:29 <EvanR> then the types would be really easy
16:01:40 <Peaker_> Cale: yeah, looking for an alternative to "wrapped"
16:01:41 <Cale> Peaker_: Though they're a special sort of type transformers
16:01:55 <Peaker_> Cale: monad transformers are also a special sort of monad transformers :)
16:01:55 <exio4> I used the list and maybe monad to get it at first
16:02:03 <Cale> heh
16:02:24 <zipper> Cale: In as far as the list is concerned?
16:02:24 <zipper> So all monads are computations that yield certain values when run not wrappers holding certain values. Got it.
16:02:24 <fds4345> EvanR: All needs to be serializable. This *is* a good time to use ghosts tho :)
16:02:51 <Cale> zipper: That's a better way to think of them. Obviously it's a *little* bit weird in the case of lists.
16:03:07 <Cale> zipper: As lists really are just datastructures containing a bunch of values
16:03:36 <zipper> Cale: To me the list monad makes more sense as a wrapper
16:03:38 <Cale> zipper: But when we're thinking of them as computations, they become a sort of computation which produces zero-or-more results (the elements of the list)
16:03:45 <zipper> IO as a computation
16:03:53 <Cale> and we explore all possible choices
16:03:59 <zipper> hmmmmm
16:04:09 <Cale> > do x <- [1,2,3]; y <- [4,5]; z <- [6,7,8]; return (x,y,z)
16:04:11 <lambdabot>  [(1,4,6),(1,4,7),(1,4,8),(1,5,6),(1,5,7),(1,5,8),(2,4,6),(2,4,7),(2,4,8),(2,...
16:04:32 <Cale> So here, x <- [1,2,3] means "pick x from the list [1,2,3] in all possible ways"
16:04:46 <Cale> and that becomes our notion of what it means to "execute" a list
16:04:52 <fds4345> thx for help all
16:05:02 <zipper> Cale: I see, non determinism
16:05:07 <Cale> yes, exactly
16:05:51 <zipper> Ok maybe I need to read more on monads.
16:06:03 <Cale> and the sense of "execution" is perhaps a bit more usual (if a lot more elaborate) in the case of IO
16:06:39 <Cale> Where something like x <- getLine means "execute the action getLine to get a line of text from the user and call the resulting String value x"
16:07:57 <Cale> Values of type IO t are pretty much like what you would ordinarily think of as arbitrary computer programs, apart from the fact that they have no parameters (they're not functions on their own), and they produce a result of type t.
16:08:52 <blizzy> how would I make the input by 'getLine' an Int?
16:08:56 <dfeuer_> Cale, this is why I call them "recipes".
16:08:58 <Cale> In a parsing monad, you might have values of type Parser t, which would be parsers that consume some initial portion of a string (or sequence of tokens or what have you) in order to (perhaps nondeterministically) produce a result of type t
16:09:17 <Cale> blizzy: You could apply read to it, or just use readLn
16:09:45 <dfeuer_> IO (Cake) is a recipe for making a cake. Simple!
16:10:09 <RaceCondition> cabal install alex giving: ld: library not found for -lHStransformers-0.4.2.0-ghc7.8.3
16:10:28 <RaceCondition> I'm setting up a Haskell dev env for the first time and I have no idea why cabal isn't able to set packages up
16:10:47 <dfeuer_> do {x <- makeCake; eatCake x}  says "Make a cake; then eat it."
16:10:58 <Cale> RaceCondition: That is a pretty interesting error
16:11:07 <Cale> RaceCondition: How did you install GHC?
16:11:15 <RaceCondition> brew install ghc on OSX
16:11:36 <blizzy> thxs Cale. so, to print a function, I would use 'putStrLn $ (foo bar)'?
16:11:39 <Cale> Oh, hm. Probably all my OSX Haskell knowledge is out of date.
16:11:41 <RaceCondition> first it was ld: library not found for -lHSrandom-1.0.1.1-ghc7.8.3 but cabal install random helped
16:11:59 <Cale> blizzy: Well, if foo bar is a String, yes.
16:12:10 <zipper> Cale: lol I shall remember it all.
16:12:10 <blizzy> what if it is an Int?
16:12:11 <RaceCondition> is cabal or GHC broken on OS X then? because I'm just doing a very basic package install
16:12:12 <dfeuer_> Wikipedia, on cabals: "The use of this term usually carries strong connotations of shadowy corners, back rooms and insidious influence."
16:12:15 <Cale> blizzy: and usually you go with either the parens or the $ but not both :)
16:12:21 <zipper> s/lol//
16:12:23 <RaceCondition> just following http://tim.dysinger.net/posts/2014-02-18-haskell-with-emacs.html
16:12:25 <Cale> zipper: Okay, so back to join
16:12:31 <Cale> zipper: We had:
16:12:32 <blizzy> oh ok. thxs Cale. what if the function returns an Int?
16:12:34 <zipper> Cale: Yeah
16:12:39 <Cale> join x = do y <- x; v <- y; return v
16:13:04 <Cale> Now, one of the monad laws says that whenever we have something like do v <- y; return v, that this is the same thing as y
16:13:14 <dysinger> RaceCondition: I need to update that config.  It’s outdated a bit since I wrote it.  basically you want haskell-mode & ghc-mod however you can get it. melpa is fine.
16:13:17 <Cale> So, we can simplify the code for join:
16:13:22 <Cale> join x = do y <- x; y
16:13:24 <zipper> Cale: Makes sense
16:13:29 <blizzy> nvm I got it using putStrLn . show
16:13:31 <blizzy> thxs, Cale.
16:13:50 <exio4> that is print
16:13:51 <RaceCondition> dysinger: so no happy, alex, and all the others? and just ghc-mod and that's it?
16:13:53 <zipper> Cale: yet y is really two lists
16:13:53 <zwer_l> perhaps this is easier to follow: join mmx = do mx <- mmx; x <- mx; return x
16:14:04 <Cale> y is not necessarily a list at all here
16:14:08 <zipper> Cale: *`y`
16:14:10 <Cale> but if it's a list, it's just one list
16:14:13 <RaceCondition> but then, cabal install quickcheck still gives that error about the transformers lib missing
16:14:15 <Cale> it's not a list of lists
16:14:35 <Cale> Oh, it will be a nondeterministically selected list though
16:14:42 <Cale> (one of the lists which is an element of x)
16:14:57 <zipper> Cale: We can't be sure how the list will look
16:15:07 <Cale> If we read join x = do y <- x; v <- y; return v in the list monad, it says
16:15:33 <Cale> "pick a list y from the list of lists x, and then pick an element v of the list y, and return v"
16:15:48 <Cale> and we do this in all possible ways, collecting a list of the results
16:15:58 <Cale> So, this results in a concatenation of the list of lists x
16:16:32 <Cale> > do y <- [[1,2,3],[4,5],[6,7,8]]; v <- y; return v
16:16:33 <lambdabot>  [1,2,3,4,5,6,7,8]
16:16:38 <dysinger> RaceCondition: you want all the same packages for haskell & emacs yes.  I’m just saying that you don’t have to follow my config & using el-get emacs packages.  Try to install them with M-x package-list-packages
16:16:47 <Cale> zipper: cool?
16:16:54 <Cale> But that's not where I was going
16:16:55 <dfeuer_> join :: IO (IO Cake) -> IO Cake
16:16:58 <Cale> I wanted to talk about join in general
16:17:06 <Cale> and show that it's really the same as (>>= id)
16:17:06 <RaceCondition> dysinger: I know that but I'm talking about cabal install ...
16:17:10 <dysinger> RaceCondition: because melpa is built into emacs these days & haskell-mode & ghc-mod are in there IIRC
16:17:18 <Cale> (regardless of the choice of monad)
16:17:24 <zipper> Cale: I get 80% of it.
16:17:29 <Cale> So, we had join x = do y <- x; y
16:17:29 <RaceCondition> dysinger: ok, that's good news :) that solves the setting-up-Emacs bit
16:17:32 <dysinger> RaceCondition: y you want all those haskell packages installed with cabal & in your $PATH
16:17:41 <Cale> If we desugar that do-notation, that becomes:
16:17:45 * dfeuer_ just thinks it's easier to understand monads that have cake in them.
16:17:53 <RaceCondition> but I'd still like to cabal install QuickCheck
16:17:55 <RaceCondition> but it currently fails
16:18:06 <RaceCondition> ah wait, --reinstall --force-reinstalls transformers solved it...
16:18:16 <RaceCondition> how come cabal runs into issues on a clean machine?
16:18:24 <Cale> join x  =  do { y <- x; y }  =  x >>= (\y -> do { y })  =  x >>= (\y -> y)
16:18:33 <Cale> and (\y -> y) is the same thing as id
16:18:44 <Cale> So  join x = x >>= id
16:19:12 <Cale> (Though I think it's far clearer to write it long-hand with do-notation)
16:19:13 <RaceCondition> dysinger: ok, so alex, happy, ghc-mod, structured-haskell-mode and stylish-haskell *are* all needed still?
16:19:25 <RaceCondition> I got the impression from what you said initially that no
16:19:46 <dysinger> no. you do need those things if you want all the bells & whistles
16:20:12 <zipper> Cale: Yeah do notation is less confusing
16:20:22 <RaceCondition> dysinger: got it; they've installed fine now.. I'm just disappointed it didn't go smoothly
16:21:32 <zipper> Cale: Thaks
16:21:46 <dysinger> RaceCondition: what I’ve done is keep cabal, ghc-mod & those other basic tools in my —user env ($HOME/.cabal) & use sandboxes for _everything_ else.  This keeps cabal conflicts mostly out of the picture.  You can douche out your $HOME/.cabal & $HOME/.ghc to do it this way if you like.
16:21:50 <zipper> L8D: Thanks
16:22:12 <ReinH> @. pl undo \k -> do { v <- k; v }
16:22:12 <lambdabot> join
16:22:52 <L8D> @pl \k -> do { v <- k; v }
16:22:53 <lambdabot> (line 1, column 10):
16:22:53 <lambdabot> unexpected '{'
16:22:53 <lambdabot> expecting variable, "(", operator or end of input
16:23:02 <L8D> -.-
16:23:03 <Cale> zipper: No problem :)
17:27:10 <RaceCondition> dysinger: your tutorial suggests auto-complete should be working once C-c C-l is used for the REPL but it's not
17:27:46 <dysinger> hmm well something isn’t configured right then
17:28:24 <RaceCondition> dysinger: I just skipped all of the el-get related Emacs configuration but followed everything else
17:29:09 <RaceCondition> wait, the recipes are still needed?
17:29:31 <dysinger> there’s some elisp code that does some config in the el-get packages I had in the article (& github)
17:29:51 <dysinger> if you grabbed your emacs packages from melpa then you need to put that config somewhere where it’ll load
17:29:53 <RaceCondition> but how do I apply that config with melpa?
17:29:56 <dysinger> in your emacs init
17:30:04 <RaceCondition> ah right, I thought recipes were somehow special
17:30:37 <dysinger> Unless you really want to use emacs, I would suggest trying the new haskell IDE thing that’s out
17:30:48 <dysinger> I use emacs because I’ve always used emacs.
17:30:50 <RaceCondition> I'd like to keep using Emacs
17:30:54 <RaceCondition> same here
17:31:24 <dysinger> ok then you know where to scoop up elisp bits & place them in your emacs init.  I’m going to shush now as I don’t want emacs to take over the channel. :)
17:31:53 <RaceCondition> that's fine; sorry :)
17:33:40 <andrei> How can I add an argument to hsc2hs, specifically an include path. It's running through cabal
17:36:38 * hackagebot yaml-light-lens 0.3.1.4 - Lens interface to yaml-light.  http://hackage.haskell.org/package/yaml-light-lens-0.3.1.4 (AnthonyCowley)
17:49:25 <tempay> hey guys, quick question
17:49:34 <tempay> map ($ 10) [succ pred]
17:49:42 <tempay> why does that work?
17:50:08 <tempay> shouldn't that equate to something like [($ 10 succ), ($ 10 pred)]?
17:50:51 <exio4> > map ($ 10) [succ, pred]
17:50:52 <lambdabot>  [11,9]
17:50:53 <exio4> > map ($ 10) [succ pred]
17:50:55 <lambdabot>  No instance for (GHC.Show.Show b0)
17:50:55 <lambdabot>    arising from a use of ‘M885858229608681038428819.show_M8858582296086810384...
17:50:55 <lambdabot>  The type variable ‘b0’ is ambiguous
17:50:55 <lambdabot>  Note: there are several potential instances:
17:50:55 <lambdabot>    instance [safe] GHC.Show.Show
17:51:20 <tempay> sorry, forgot the comma
17:55:10 <NemesisD> why is it when i create a new sandbox its still deciding dependencies based on the installed version of process, bytestring, etc. shouldn't it be able to use the newest versions?
17:57:13 <Guest22720> any hacker news account holders here who appreciate the value of sufficiently powerful type systems?
17:58:07 <Guest22720> i would appreciate some upvotes on a thread that just got downvoted into oblivion
17:58:54 <NemesisD> consider yourself lucky. hacker news is a cesspool
17:59:04 <zwer_l> tempay ($ x) is an operator section. ($ x) is different than (x $)
17:59:24 <zwer_l> > (/10) 5
17:59:25 <Guest22720> https://news.ycombinator.com/item?id=8605321
17:59:26 <lambdabot>  0.5
17:59:31 <zwer_l> > (10/) 5
17:59:32 <lambdabot>  2.0
17:59:39 <Guest22720> Nemesis: yes, i know but you have to work within the system to some extent
17:59:51 <Guest22720> or at least give the impression of working within the system
18:00:07 <NemesisD> Do we? what work is posting links to a site that is terrible?
18:00:16 <NemesisD> is that good work to do?
18:00:26 <zwer_l> (/10) is equal to (\x -> x / 10) and  (10/) is equal to (\x -> 10 / x)
18:01:05 <tempay> but $ isn't an infix operator is it?
18:01:06 <Guest22720> it isn’t bad for one’s career to appear to be a person who works within the system
18:01:13 <zwer_l> tempay it is
18:01:15 <ski> tempay : `map ($ 10) [succ,pred]  =  [($ 10) succ,($ 10) pred]  =  [succ $ 10,pred $ 10]  =  [succ 10,pred 10]  =  [11,9]'
18:01:21 <zwer_l> @src ($)
18:01:21 <lambdabot> f $ x = f x
18:01:47 <tempay> oh! that completely explains my confusion, thanks zwer_l
18:02:04 <zwer_l> welcome
18:04:15 <NemesisD> @Guest22720 bro are you seriously trying to argue that trolling golang on hacker news and asking for helps to upvote it out of a downvote hole is a good career move?
18:04:15 <lambdabot> Unknown command, try @list
18:04:59 <NemesisD> what are you even
18:07:22 <Guest22720> NemesisD: I’m suggesting that not losing mod points is a good career move. and it wasn’t a troll- i pointed out a quite clear fallacy in the parent post I responded to
18:08:02 <Guest22720> Sometimes that sort of thing is actually *UP* voted. in sufficiently intelligent communities that is
18:09:39 <NemesisD> Guest22720: if your standing on hacker news is a hiring criteria at a job stay away from it. I also don't think you shouldn't come to #haskell and ask for help restoring your made up internet points, especially when it seems like you're just slinging mud.
18:10:19 <Welkin> who uses that as a hiring criteria?
18:10:27 <Welkin> "I'm popular on the internet"
18:11:26 <NemesisD> I've posted over 500 "well actually"s on hacker news comments. You will not find a more qualified candidate
18:11:40 * hackagebot messagepack 0.2.1 - Serialize instance for Message Pack Object  http://hackage.haskell.org/package/messagepack-0.2.1 (rodrigosetti)
18:14:20 <Gurkenglas> How could one solve the problem that instance declarations can conflict with one another?
18:16:40 <Gurkenglas> Some language feature that allows you to specify which instance declaration to use at each juncture?
18:17:03 <dibblego> Gurkenglas: usually by creating a newtype
18:19:52 <ski> Gurkenglas : there's `OverlappingInstances' and `IncoherentInstances', but they're usually frowned upon
18:25:33 <Guest22720> NemesisD: I’m not sure that you should try to prevent others’ free movement. if I want to visit a room and ask for help, what is it to you?
18:37:42 <SvenskFisk> What's the best way to get ["a" .. "z"]? Is there a way to get the enumeration to work with strings or do I need to
18:37:56 <SvenskFisk> map show ['a' .. 'z'] is what I have so far
18:38:48 <sm> map (:[]) should work too
18:38:57 <glguy> SvenskFisk: You probably want sm's version instead of show
18:39:05 <glguy> > show 'a'
18:39:07 <lambdabot>  "'a'"
18:39:14 <glguy> has extra ' s in there
18:39:29 <glguy> But String isn't an instance of Enum
18:40:17 <SvenskFisk> Oh got it, I'll use the map (:[]) thing
18:41:10 <sm> or map (:"")
18:41:19 <Hafydd> or map pure
18:42:08 <SvenskFisk> :t pure
18:42:08 <lambdabot> Applicative f => a -> f a
18:42:24 <SvenskFisk> How would map pure work?
18:42:51 <Hafydd> > pure 'x' :: String
18:42:52 <glguy> pure happens to coincide with the function you want for lists
18:42:53 <lambdabot>  "x"
18:44:09 <Hafydd> @src pure
18:44:09 <lambdabot> Source not found.
18:44:22 <Hafydd> Well, for [], pure x = [x].
18:44:55 <exio4> > return 2 ∷ [Int]
18:44:56 <lambdabot>  [2]
18:44:59 <exio4> > pure 2 ∷ [Int]
18:45:01 <lambdabot>  [2]
18:56:42 * hackagebot mwc-random 0.13.2.2 - Fast, high quality pseudo random number generation  http://hackage.haskell.org/package/mwc-random-0.13.2.2 (AlexeyKhudyakov)
19:03:59 <sshine> http://lpaste.net/114273 - this code works, but when I do :t makePair in GHCi, I get the type 't'. why doesn't it infer that the type is (String, JSON) -> String?
19:05:49 <glguy> sshine: because undefined has any type, so when it computes the type of makePair as a top level definition it comes up with that
19:06:07 <glguy> and then that general type is instantiated to the one you use it at at the call site
19:06:30 <joe9> source: http://codepad.org/BFzGDUzP on line 33, there is the fork implementation. I cannot figure out how it works though. Can anyone please explain?
19:07:17 <joe9> I understand that cfork returns (Fork True False), but, I cannot understand how that boolean value gets to be the child variable value?
19:07:54 <joe9> More specifically, how does t1 and t2 on line 44 get to be the continuation?
19:08:22 <joe9> I can understand if t1 and t2 are boolean values.
19:08:33 <sshine> glguy, ah. thanks. :)
19:08:45 <joe9> But, the way the program is working, the t1 and t2 are the continuation and not just the boolean value.
19:09:14 <joe9> I am not able to grap how t1 and t2 became the continuation.
19:11:42 * hackagebot hs-mesos 0.20.1.0 -   http://hackage.haskell.org/package/hs-mesos-0.20.1.0 (IanDuncan)
19:11:49 <ski> joe9 : `roundRobin' walks the `Thread' tree breath-first, more or less
19:12:50 <joe9> ski,  I understand that. I also understand that with the free monad, we are just building an AST.
19:13:05 <joe9> but, I am not able to figure out how the Fork works.
19:13:29 <joe9> ski, As a learning exercise, I am trying to do this without using the free monad. ie. build the AST
19:13:31 <joe9> manually.
19:13:45 <joe9>   http://codepad.org/wxj63HYA my attempt at it.
19:14:04 <joe9> ski, on line 25, I cannot figure out how the fork would work though.
19:14:24 <gentmen> Hi - I'm working on a 2013 Brent Yorgey homework (http://www.seas.upenn.edu/~cis194/spring13/hw/08-IO.pdf). Could someone please help me out?
19:14:25 <joe9> ski, does that make sense?
19:15:29 <ski> joe9 : `cFork' creates a node with two "continuation" children, one which immediately yields `False', and one `True'. `fork' then replaces those two children by : in the `False' case, `return ()' (because of `when'); in the `True' case, `thread', terminated by `Done'
19:16:43 * hackagebot thrift 0.9.2 - Haskell bindings for the Apache Thrift RPC system  http://hackage.haskell.org/package/thrift-0.9.2 (jfarrell)
19:16:58 <joe9> ski, yes, where is this 'creates a node with two "continuation" children' happening?
19:17:47 <sshine> is there a mapLeft :: (a -> b) -> Either a c -> Either b c? I can't find it.
19:17:55 <ski> joe9 : if one uses `fork thread >>= k', then `k' is the continuation of the `fork thread' operation. it is automatically "appended" to (the leaves of) the two branches in the `fork thread', iow : for the `False' case, `return ()' is simply replaced by `k ()'; for `True', since it has been terminated by `Done', there are no leaves (no `Pure ...')) in it, so "appending" to them just makes `k' get dropped, here
19:19:03 <sshine> I guess there's 'either (Left . f) Right'
19:19:30 <ski> joe9 : line 25 of which paste ?
19:20:03 <ski> joe9 : "where is this 'creates a node with two "continuation" children' happening?" -- that's `cFork = liftF (Fork False True)'
19:20:10 <joe9> ski,  http://codepad.org/wxj63HYA
19:20:32 <ski> joe9 : that line is illtyped
19:20:39 <joe9> ski, I am trying to build the AST without using the free monad just to figure out how it works.
19:20:46 <joe9> ski, and got stuck at that line.
19:21:02 <ski> @type left  -- sshine
19:21:03 <lambdabot> ArrowChoice a => a b c -> a (Either b d) (Either c d)
19:21:03 <joe9> as I could not figure out how to structure that.
19:21:38 <ski> joe9 : well, you still seem to be using `ThreadF' -- is that what you wanted to do ?
19:22:13 <joe9> ski, ThreadF is just the data structure. Not using Thread though (which is the FreeT ThreadF)
19:23:00 <joe9> ski, I think I need to rethink this. I am missing something fundamental. Sorry for the bother.
19:23:04 <batchm> hello
19:23:09 <batchm> I am looking at this: http://hackage.haskell.org/package/base-4.7.0.1/docs/Control-Monad-ST.html
19:23:46 <batchm> nd I have no clue how to use it..
19:24:30 <batchm> I see nothing similar to set/get in State, or newIORef , writeIORef for IORef
19:24:56 <batchm> and :writeSTRef (used in the example) is not exported
19:25:02 <simpson> batchm: You'll need Data.STRef as well.
19:25:17 <batchm> ah
19:26:00 <ski>   fork :: ThreadF a -> ThreadF (Maybe (ThreadF ()))
19:26:03 <ski>   fork thread = fmap (\child -> if child then Just (fmap (const ()) thread) else Nothing) cFork
19:26:21 <ski> joe9 : i suppose you *could* do that .. not that it's that much help
19:26:48 <joe9> ski, thanks a lot.
19:27:07 <ski> joe9 : the `Free ThreadT' version would have `Pure ()' instead of `Nothing' in the `else' branch (and no `Just' in the `then' branch)
19:27:55 <joe9> ski, makes sense. thanks.
19:28:37 <ski> joe9 : but the `Free ThreadT' version allows one to nest however many levels of `ThreadF' one wants to, where `Fork' means a binary tree node, `Done' a nullary tree node (no children), and `Pure' can be used at any time to insert a leaf (which will be replaced by a further subtree, when one uses `>>= ...')
19:28:40 <batchm> a bit unusual that functions are split between Data.STRef and Control.Monad.ST
19:29:45 <ski> joe9 : so, i think for `fork' to be sensible here, you can't really just use `ThreadF', you need to nest (at least you want to be able to use `Pure' for the `else' branch)
19:30:34 <batchm> is unsafePerformIO needed for implementing ST?
19:30:37 <ski> joe9 : and in case you're wondering, `liftF' (i think) is inserting `Pure's around the `Bool's passed to `Fork', in `cFork'
19:30:38 <batchm> STRef
19:30:51 <gentmen> does this function look right for folding over a rose tree - `treeFold :: (b -> [b] -> b) -> (a -> b) -> Tree a -> b`?
19:31:15 <ski> batchm : primitive implementation support, for both GHC and Hugs
19:31:49 <batchm> what if it didn't exist as a haskell primitive? it would only be implementable with unsafePerformIO
19:31:50 <batchm> ?
19:31:59 <ski> gentmen : how's your `Tree' defined ?
19:33:00 <ski> batchm : i don't think that would be enough (well, unless you intend to store `STRef's and `IORef's in e.g. files)
19:33:00 <batchm> STRef looks interesting.. like a localized IORef
19:33:37 <batchm> ski, so unsafePerformIO + FFI
19:33:48 <batchm> if FFI isn't part of haskell spec
19:33:51 <ski> well, if you allow implementing `STRef' in terms of `IORef', then that's different. i was talking about implementing both `STRef' and `IORef'
19:33:59 <batchm> me too
19:34:00 <ski> FFI is an addendum
19:34:11 <gentmen> data Tree a = Node { 	rootLabel :: a, 	subForest :: [Tree a] }  deriving (Show)
19:34:16 <chirpsalot> What does "Include documentation on what each field means" do (cabal init)?
19:34:41 <ski> gentmen : then, no
19:34:48 <ski> gentmen : at least it's not on the standard form
19:35:01 <gentmen> ok - can you please tell me standard form, i.e. signature?
19:35:06 <batchm> ski then isn't unsafePerformIO enough? you can use ffi to manage manually
19:35:09 <batchm> +how
19:35:17 <sshine> with Text.ParserCombinators.ReadP, doing 'many . satisfy' is a no-no, but I don't suppose that it is with Parsec, is it?
19:36:03 <batchm> let's try again.. you can use ffi to manage memory manually, then unsafePerformIO to turn IO a into a
19:37:10 <ski> gentmen : `Node :: a -> [Tree a] -> Tree a' would give an argument type `a -> [b] -> b', so you'd normally get `treeFold :: (a -> [b] -> b) -> (Tree a -> b)'
19:37:49 <ski> gentmen : the idea being that we "replace" each constructor by a corresponding argument -- in this case, there's just one constructor
19:38:15 <ski>   treeFold node (Node a ts) = node a (map (treeFold node) ts)
19:38:23 <ski> compare with
19:38:34 <ski>   foldr cons nil [    ] = nil
19:38:45 <ski>   foldr cons nil (a:as) = cons a (foldr cons nil as)
19:39:31 <gentmen> @ski - thanks. why doesn't your definition of `treeFold` include 3 arguments rather than 2?
19:39:32 <lambdabot> Maybe you meant: wiki src ask
19:39:35 <ski> batchm : yes
19:39:55 <gentmen> ah nvm - it's point-free I think
19:40:30 <batchm> how fast is newSTRef? is it equal to (in C terms) malloc or stack allocation
19:40:30 <ski> gentmen : btw, fyi, the traditional way on IRC to address someone is to start a message with their nickname, followed by e.g. a comma or a colon, and then the message
19:40:48 <gentmen> ski: thanks. I never used IRC before
19:40:53 <sshine> some people might resort to "HEY SKI!!!", but you shouldn't follow their example
19:41:02 <exio4> HEY! :P
19:41:29 <ski> gentmen : no, my `treeFold' only took two arguments. it was your suggested signature which wanted three
19:41:29 <exio4> gentmen: you can probably use tab in your client, try "s[tab]"
19:42:19 <sshine> ski, isn't the 'i' superfluous?
19:43:02 <ski> gentmen : btw, many IRC clients highlight the user whenever a message on some channel starts with their nickname. not as many highlight when their nickname occurs somewhere else in the message. it's safest to start the message with the nickname, if you want to get someone's attention, e.g. to make them note that someone addressed them, when they hours later check their IRC scrollback/logs
19:43:35 <gentmen> ski : roger, thanks
19:43:40 <ski> sshine : you can even have an `X' such that `S = (X X) X' and `K = X (X X)' (if i didn't mix those two up)
19:43:56 <ski> s/note/notice/
19:44:17 <gentmen> ski : also, your signature for `foldTree` is the same as `foldTree :: (a -> [b] -> b) -> Tree a -> b ? The parentheses around (Tree a -> b) don't matter, do they?
19:44:27 <L8D> wait...
19:44:29 <sshine> ski, are you saying the lambda calculus can be reduced to a combinatory logic with just that X?
19:44:30 <L8D> ski is talking about ski
19:44:35 <ski> batchm : perhaps you could try to measure `newSTRef' ?
19:45:00 <ski> sshine : yes, but it's fairly silly, imho
19:45:13 <sshine> ski, I'm a fan of silly. anyway, good night. :)
19:45:34 <ski> night, sshine. dream interesting dreams
19:45:49 <L8D> this one time
19:45:52 <L8D> I was dreaming
19:46:06 <L8D> and someone offered me a job to write Haskell
19:46:17 <L8D> and then when I got to the office
19:46:53 <L8D> everyone was writing ruby
19:47:24 <L8D> and then I woke up
19:49:02 <ski> .. when i was waking up two days ago, i was thinking about how to possibly be able to "divide" and "subtract" types from one another
19:49:25 <L8D> can't you do that in Idris?
19:49:41 <ski> (i then managed to write down some expanded notes of that line of thought)
19:49:49 <ski> L8D : i dunno, elaborate ?
19:50:04 <L8D> ski: you can have like... sets of types
19:50:17 <L8D> where you can have signatures that subtract and add different types
19:50:19 <ski> i was thinking about stuff akin to "calculations" in combinatorial species
19:50:20 <L8D> to these sets
19:51:01 <ski> L8D : oh, are you talking about using union and set difference between one set and a singleton set ?
19:51:08 <L8D> ski: do you do anything practical with Haskell or are you just a researcher?
19:51:26 <L8D> ski: no I mean there is a thing in Idris for having types that are sets of other types
19:51:42 <L8D> ski: so you can denote the "type" of effects that occur in things like IO
19:51:53 <L8D> so you can have an IO of type "IO (Error)"
19:52:22 <L8D> with try :: IO (Error | e) -> IO (e)
19:52:26 <L8D> or something like that
19:52:31 <ski> "types that are sets of other types" doesn't tell me very much
19:52:37 <L8D> no wait
19:52:52 <gentmen> is there any difference between (a -> b) -> c and a -> b -> c?
19:52:56 <ski> perhaps you mean they are subsets of the type of (small) types ?
19:53:11 <ski> gentmen : yes, `a -> b -> c' is interpreted as `a -> (b -> c)'
19:53:30 <gentmen> ski : due to currying?
19:53:46 <ski> (because the `->' operator is specified as a right-associative operator. this is the convention in most work on type theory, as well)
19:53:52 <L8D> try : IO {Exception | e} a -> IO {e} (Exception, a)
19:53:56 <L8D> ^ something like that
19:54:17 <L8D> wait no
19:54:20 <L8D> this isn't idris
19:54:26 <L8D> this is like PureScript or something
19:54:48 <ski> gentmen : it's to avoid having to write the brackets in `a -> (b -> c)', because one gets types like that with currying (which one happens to do quite often in Haskell (and type theory), though it's not required)
19:55:27 <ski> is PureScript related to ECMAScript, somehow ?
19:55:47 <L8D> PureScript is like a Haskell-style language designed to compile to JavaScript
19:55:58 <L8D> it supports "kinds"
19:56:36 <ski> does it support higher-order types ?
19:56:42 <L8D> sort of
19:57:31 <ski> does it support parametric polymorphism (even if not having parametricity) ? on non-concrete / higher types as well ?
19:58:12 <L8D> I believe so
19:58:12 <L8D> I
19:58:19 <L8D> I'm not too familiar with it
19:59:15 <ski> ok
19:59:49 <L8D> are you a researcher, hobbyist or pragmatic user of Haskell?
20:00:03 <ski> i'm a student
20:00:17 <L8D> in CS?
20:00:30 <ski> yeah. some math and logic as well
20:00:46 <L8D> do you plan on being a researcher?
20:01:16 * ski realized today that the naturality condition for a natural transformation can be understood as saying that the application operation of a functor on an object is a bifunctor
20:01:23 <ski> L8D : perhaps
20:02:04 <L8D> we need more people porting erlang to haskell
20:02:23 <ski> (do you mean CloudHaskell ?)
20:02:39 <L8D> no I mean like we need to further our concurrency primitives
20:02:51 <L8D> like making cross-network nodes a thing
20:03:13 <L8D> we already got "threads" down and they're even smaller than erlang's
20:03:23 <L8D> but now we need to distribute this shit
20:03:24 * ski thought that's what CloudHaskell was about
20:03:29 <ski> perhaps i misunderstood
20:03:43 <L8D> oh
20:03:48 <L8D> cloudhaskell the library
20:03:53 <L8D> I thought you were talking about the company
20:04:08 <L8D> yeah then that
20:04:21 <Welkin> L8D: what counts as a "pragmatic user"?
20:04:24 * ski hadn't heard about any company named such
20:04:59 <L8D> Welkin: someone who uses Haskell in their day job or at least is following Haskell-inspired practices
20:05:30 <L8D> and they're using it for a real-world something
20:05:52 <Welkin> so they build tools/applications with it
20:06:00 <Welkin> and not just "experiments"
20:06:28 <L8D> yeah
20:07:38 <L8D> there is a large difference between someone who learns/writes Haskell in their spare time and those who write real stuff with it
20:07:54 <L8D> because like Haskell can do WAY more than solve euler problems
20:08:15 <Welkin> when I started learning haskell I could only write small functions
20:08:28 <L8D> and I see a bunch of people who learn it and then passively ignore it as something "not practical"
20:08:29 <Welkin> I did things like solve project euler exercises
20:08:29 <exio4> what about writing hobby projects
20:08:43 <Welkin> I built my first real application with it using yesod
20:08:53 <L8D> Welkin: that's good then
20:09:09 <L8D> but I know people who claim they "know Haskell" but have never used it for anything serious
20:09:16 <Welkin> I plan on writing a lot more applications in it
20:09:22 <L8D> exio4: what kind?
20:09:42 <Welkin> use it for web and ios development
20:09:55 <L8D> Welkin: ios with ghc-ios?
20:09:59 <Welkin> yes
20:10:04 <Welkin> I haven't tried it yet, though
20:10:06 <batchm> can yesod create static web pages?
20:10:10 <exio4> Welkin: well, I can only spam IPoIRC >:P
20:10:12 <Welkin> batchm: of course
20:10:20 <L8D> batchm: for static sites Hakyll is the standard
20:10:26 <Welkin> for static sites you could use Hakyll
20:10:30 <Welkin> I love hakyll
20:10:37 <Welkin> it is so easy to set up
20:10:37 <L8D> effing github!
20:10:38 <batchm> why hakyll if yesod can do it as well?
20:10:49 <Welkin> yesod is for dynamic sites
20:10:56 <L8D> batchm: because Hakyll is specifically for static sites
20:11:21 <L8D> batchm: it generates a folder and then you can serve from that folder with anything
20:12:11 <L8D> batchm: whereas if you're using yesod, you'd be serving content dynamically
20:12:28 <L8D> batchm: and thus, have to deploy your site with yesod
20:12:43 <Welkin> you could use yesod to serve a static site, but that would be wasteful
20:12:54 <Welkin> use the simplest solution instead
20:13:08 <batchm> ok. I have not used haskell for web yet, but it is on my TODO list
20:13:08 <lifter> Is a 6000 line Haskell project considered to be med size?
20:13:29 <Welkin> batchm: it is really easy to use
20:14:39 <L8D> lifter: I'd say large
20:14:51 <Welkin> web programming was always a pain in python (or other similar languages)
20:15:15 <exio4> L8D: what is ghc then? extreme?
20:15:17 <lifter> L8D: Cool. That's where I'm at. One of my modules in this project is 2400 lines alone so I gotta figure out how to split it up
20:15:40 <lifter> L8D: (and avoid circular imports somehow...)
20:15:56 <batchm> Welkin you found it easier in haskell? interesting
20:16:00 <L8D> lifter: circular imports should be fine, no?
20:16:10 <batchm> to be*
20:16:11 <Welkin> lifter: you could split out the Types, utilities, etc into separate modules
20:16:30 <Welkin> you can avoid circular imports by importing everything once in an Import module
20:16:41 <Welkin> then importing that into each module
20:16:43 <L8D> exio4: ghc is split up into smaller sub-sections
20:16:47 <lifter> L8D: Every time I've tried to split it up I run into circular imports quickly. And yeah otherwise I have it split up as you describe
20:16:58 <batchm> I have heard scary things about yesod (or was it hakyll?).. that it has a steep learning curve. but, again, I have zero experience with either
20:17:08 <lifter> Welkin: woah
20:17:24 <Welkin> batchm: yesod is really easy to get started with, but doing more advanced things is a pain because the docs are pretty poor
20:17:32 <Welkin> but I haven't run into any unsolvable problems
20:17:35 <batchm> and hakyll?
20:17:42 <Welkin> and lot of it was just understanding how yesod works
20:17:47 <Welkin> I haven;t done anything much with hakyll
20:17:48 <merijn> batchm: yesod, hakyll is simple but a complete different framework
20:17:52 <L8D> batchm: hakyll is just as straight-forward as jekyll
20:17:55 <merijn> Hakyll is a static site generator
20:18:01 <Welkin> I just installed it and compiled my markdown files to html
20:18:07 <merijn> Yesod is...intimidating
20:18:18 <L8D> there's snap, scotty and simple though
20:18:24 <L8D> and they have their own benefits
20:18:24 <Welkin> yesod is not that hard to understand
20:18:27 <Welkin> but it takes some reading
20:18:30 <merijn> lifter: GHC support circular imports using boot files
20:18:34 <Welkin> you should read the yesod book
20:18:35 <merijn> lifter: See the user's guide
20:18:44 <lifter> Welkin: Not sure if I follow you entirely. If modules A and B are imported into module Import, and A and B themselves import Import... would that work?
20:18:52 <Welkin> and you'll have to search around or ask in #yesod when you run into issues
20:18:54 <batchm> sounds like hakyll is what i need.. process some images, text files, spit out static html pages
20:19:17 <merijn> Should I CC libraries@ on non-library GHC change proposals?
20:19:23 <batchm> probably need additional library for image processing
20:19:29 <merijn> batchm: Right, then Hakyll is what you want
20:19:36 <lifter> merijn: Never heard of that b4, will have to check it out
20:20:07 <merijn> L8D: I wouldn't call 6k lines large, tbh
20:20:24 <Welkin> ghc is the largest haskell project on record, is it not?
20:20:30 <merijn> L8D: Keep in mind, there's companies with 100k or even >1 million LOC codebases
20:20:35 <Welkin> at over 600k slc?
20:20:39 <merijn> Welkin: Open source? Maybe
20:20:40 <L8D> merijn: but in Haskell though
20:20:46 <merijn> L8D: Yes, haskell
20:21:04 <L8D> merijn: for an open source Haskell project/module/package/library, 6000 LOC is borderline large
20:21:09 <merijn> L8D: Standard Charter has >1.5 million lines of haskell and another million of their in-house haskell dialect
20:21:18 <batchm> 1 million lines of haskell? that is like 10 billion lines of C :)
20:21:30 <lifter> fwiw my project is open src, tho I'm the only one writing it
20:22:09 <Welkin> according to some "study" done by the US Navy, 67 lines of Haskell is equivalent to 1300+ lines of C++
20:22:24 <lifter> Welkin: gosh
20:22:27 <batchm> I buy that
20:22:31 <Welkin> the paper is linked on the haskell wiki
20:24:42 <Welkin> merijn: do you suspect there is code bloat in Standard Chartered's code base?
20:24:55 <Welkin> that seems like a lot, even for haskell, for a single company
20:25:28 <Welkin> I would suspect that commercial codebases have significantly more bloat than open source projects
20:26:41 <merijn> Welkin: Well, they have their own strict haskell compiler implemented in-house, so that gets large fast :)
20:27:55 <codygman> How can I debug a program that just prints out "<<loop>>"?
20:28:18 <Welkin> find the infinite loop?
20:28:41 <L8D> codygman: Debug.Trace exists for a reason
20:28:51 <Welkin> ah yes, trace
20:29:02 <L8D> > trace "foo"
20:29:04 <lambdabot>  Not in scope: ‘trace’
20:29:12 <L8D> > Debug.Trace.trace "foo"
20:29:13 <lambdabot>  Not in scope: ‘Debug.Trace.trace’
20:29:16 <L8D> -.-
20:29:27 <Welkin> :t trace
20:29:28 <lambdabot> Not in scope: ‘trace’
20:29:32 <Welkin> :t Debug.trace
20:29:33 <lambdabot> Not in scope: ‘Debug.trace’
20:29:37 <Welkin> :t Debug.Trace.trace
20:29:38 <lambdabot> String -> a -> a
20:35:56 <codygman> Can you debug code from other libraries? I tried setting a breakpoint and got "this command requires an interpreted module" and don't see any useful search results.
20:40:25 <L8D> codygman: it means you need to initiate the trace from ghci
20:40:45 <L8D> codygman: you need to load up whatever code you're using and run it in ghci
20:46:46 * hackagebot twitch 0.1.0.0 - A high level file watcher API  http://hackage.haskell.org/package/twitch-0.1.0.0 (JonathanFischoff)
20:53:10 <codygman> L8D: So you can't debug code from other libraries then?
20:53:46 <L8D> codygman: what would prevent you from doing that?
20:54:18 <codygman> L8D: it's a library installed from cabal.
20:54:45 <magicflakes> join haskell-beginners
20:54:52 <L8D> ^
20:55:11 <L8D> no patronization intended
21:00:37 <seafood> So, there are flags in Cabal. Is there any way to only build an executable based on whether a flag has been specified on the command line?
21:01:20 <L8D> seafood: I belive so
21:01:42 <seafood> L8D: Got a reference?
21:02:23 <L8D> seafood: https://github.com/jgm/pandoc/blob/master/pandoc.cabal
21:02:26 <L8D> somewhere in there
21:02:32 <L8D> is somethin
21:02:45 <L8D> "Flag flag-name-here"
21:03:07 <seafood> Thanks. The trick was the “Buildable: False” directive :-)
21:03:32 <L8D> "Executable flag-name-here"
21:03:58 <L8D> seafood: unfortunately cabal ins't very intuitive v.v
21:15:27 <juri_> ok, why is my ghc -Wall crashing when warning me when i have a problem in a line containing the ℝ character?
21:19:16 <L8D> juri_: because utf-8
21:20:18 <codygman> Is it obvious to anyone why this line of code causes an infinite loop? https://github.com/codygman/shpider/blob/master/Network/Shpider/State.hs#L157
21:21:43 <Zekka> codygman: I don't personally see why it would cause that
21:22:01 <codygman> Zekka: Yeah, it's something about the transformer stack it's being run in I guess.
21:22:15 <Zekka> codygman: My gut was "incorrect lift implementatION"
21:24:29 <Cale> codygman: Well, where do you set pageFilenames?
21:25:03 <Cale> Well, even then, it wouldn't be *that* line which causes the loop
21:25:33 <codygman> Cale: in SphiderState, which is modified in other places throughout code.
21:25:50 <codygman> Sorry, actually just forked this tonight and new'ish to monad transformers anyway.
21:26:12 <Cale> I don't think it has anything to do with monad transformers
21:26:33 <Cale> The most likely cause is using a name where it shadows something unexpectedly
21:26:38 <Cale> are you building with -Wall?
21:26:44 <Cale> are there any warnings about shadowing?
21:26:48 * hackagebot cabal-db 0.1.11 - query tools for the local cabal database  http://hackage.haskell.org/package/cabal-db-0.1.11 (VincentHanquez)
21:27:31 <Cale> I only see pageFilenames ever get set to M.empty
21:27:59 <codygman> Cale: Let me try -Wall right quick. Yeah, I was going to say it should be M.empty
21:28:30 <Cale> How are you checking that the infinite loop happens there?
21:29:04 <codygman> I println debug traced my code to there. Then when I tried to print out "mname" i noticed it halted with "<<loop>>" faster.
21:29:25 <codygman> eg, it was hitting one print further down, but then I tried printing out mname and it stopped before that print.
21:29:59 <Cale> Okay, so it's the *evaluation* of mname which causes the loop, and not that line itself.
21:30:22 <Cale> (since that line doesn't cause mname to be evaluated)
21:31:05 <codygman> Cale: Alright, so how should I proceed with debugging?
21:31:30 <Cale> What program are you actually running?
21:31:44 <Cale> I need to see all the places which might update pageFilenames
21:32:38 <codygman> Cale: http://lpaste.net/114275
21:33:24 <codygman> Cale: pageFilenames appears to never be updated.
21:33:43 <codygman> Also probably obvious, but I'm using the version of Shpider from my repo.
21:34:36 <codygman> I have to head to bed, but I'll definitely check this out in the morning if you find anything else.
21:35:52 <Cale> I'm not sure I'll find anything without more interactive information, but feel free to ping when you come back.
21:37:07 <Cale> codygman: If you're still here, it could also be that url is an infinite loop
21:37:15 <Cale> have you tried printing that?
21:37:50 <Cale> Basically, you should try printing out subexpressions here
21:38:16 <Cale> and when you figure out which thing causes the loop, figure out where it's being defined
22:27:53 <NemesisD> does anyone know why even with a fresh sandbox, cabal will still resolve dependencies trying to hold "installed" versions of certain packages like bytestring and time?
22:29:16 <Welkin> I believe the sandbox uses globally installed libraries by default
22:29:29 <Welkin> there may be a way to change that setting
22:29:37 <Welkin> if any exist
22:29:57 <NemesisD> i would love to know how hmm
22:33:44 <NemesisD> because right now i'm stuck in this hell where it will only give me old versions of criterion/statistics which actually don't build, so it accepts the build graph, builds everything then fails on those. can't upgrade because its sticking with old bytestring
22:34:40 <Welkin> install the correct version of bytestring in the sandbox first
22:36:21 <osa1> `data A = A Int --^ docs` does that add doc to Int field, A constructor or to the type?
22:36:55 <Welkin> that is just a haddock style comment
22:37:01 <Welkin> haskell comments begin with --
22:37:21 <Welkin> --^ means it is a haddock comment used to describe a function parameter
22:37:36 <glguy> Well, it means it's a comment that describes the previous thing
22:37:42 <osa1> right
22:37:44 <glguy> osa1 is asking which previous thing will it pick
22:37:47 <osa1> right
22:38:01 <lightquake> what sort of architectures do people use when doing game programming?
22:38:04 <glguy> I vote.... data constructor :)
22:38:26 <glguy> You can't put comments on unnamed constructor fields
22:38:37 <osa1> oh, I didn't know that
22:38:50 <glguy> OK, now go test and tell us the answer ^_^
22:38:52 <osa1> glguy: you sure?
22:38:54 <osa1> heh
22:39:12 <Welkin> lightquake: join #haskell-game
22:42:36 <L8D> is there a TypeScript-like language that uses a type system that haskellers would be more comfortable with?
22:42:49 <lpaste> NemesisD pasted “this went poorly” at http://lpaste.net/114278
22:43:07 <NemesisD> Welkin: i think I've done something i'm not supposed to do ^
22:43:47 <osa1> glguy: it's doc for constructor
22:44:25 <Welkin> NemesisD: you could nuke your globally installed packages
22:44:30 <Welkin> and do everything in sandboxes
22:44:36 <trap_exit> i have a silly question ... is the fact that Haskell has data types (rather than just arrays of raw primitives) one of the reasons why Haskell can not be as terse as APL?
22:44:56 <trap_exit> i.e. in haskell, we have to use constructor names / do pattern matching, where as APL is just like "eh, here's a array of ints of blahs," use these generic functions to manip them
22:45:17 <L8D> trap_exit: I wouldn't say so
22:45:30 <NemesisD> yikes
22:45:41 <NemesisD> i more want to understand why sandboxes aren't actually sandboxing hehe
22:46:14 <Welkin> well, I don't know what is actually happening
22:46:16 <Welkin> I'm just guessing
22:46:36 <Welkin> is this for some package you are trying to install?
22:48:22 <NemesisD> yeah trying to install criterion
22:48:34 <osa1> NemesisD: cabal sandbox doesn't use globally installed packages, it only uses downloaded packages in ~/.cabal/packages
22:48:46 <bitemyapp> osa1: begging your pardon?
22:48:54 <NemesisD> i actually just found a project that had a version of criterion that wasn't borked and specified that *exact* version. crappy solution but less wasted time i guess
22:49:09 <osa1> bitemyapp: does it use globally installed packages?
22:49:09 <bitemyapp> osa1: I'm pretty sure that's not how Cabal sandboxes work.
22:49:15 <bitemyapp> osa1: where do you think base is?
22:49:23 <bitemyapp> how would anything work if they didn't?
22:49:28 * glguy prefers his base sandboxed ^_^
22:49:35 <bitemyapp> sandbox just stands in for your user packages which live in ~/.ghc/
22:49:48 <bitemyapp> you should leave your ~/.cabal/ alone except to change your config.
22:50:03 <NemesisD> bitemyapp: so does bytestring live in your global packages?
22:50:10 <NemesisD> that would explain what i'm seeing
22:50:11 <osa1> bitemyapp: does it use stuff installed in .cabal?
22:50:26 <bitemyapp> NemesisD: I'm not really sure anymore. I use Nix and have no idea what's going on. Let me check.
22:50:40 <bitemyapp> NemesisD: I could check a more typical bindist install. Uno momento.
22:50:43 <bitemyapp> just remembered I had one.
22:50:44 <NemesisD> i gotta get on that nix tip
22:50:51 <NemesisD> not enough hours in the day
22:51:03 <bitemyapp> NemesisD: it is a large and unforgiving yak.
22:51:25 <NemesisD> yeah. i get the impression it got some sharp edges that they're kinda stuck with
22:51:44 <bitemyapp> bytestring is in the global packagedb of my ghc 7.6.3 installed by ubuntu.
22:51:48 <NemesisD> i've got an old laptop i'm trying it out on. haven't got past fighting to get my window manager working
22:51:49 <bitemyapp> but I don't know if that's vanilla GHC or Haskell Platform
22:52:00 <glguy> bytestring comes with vanilla GHC
22:52:02 <NemesisD> ah ok, that answers it
22:52:58 <Welkin> some packages seem to be too tightly restricted in terms of dependency versions
22:52:58 * glguy has added all the vanilla GHC packages to his .cabal/config (e.g. constraint: transformers installed  )
22:53:07 <glguy> to protect from cabal getting toooo clever
22:53:34 <NemesisD> uuuuuuuugh criterion
22:53:59 <trap_exit> can haskell be concise
22:54:00 <trap_exit> like APL ?
22:54:04 <trap_exit> or is this unpossible?
22:54:10 <NemesisD> need sleep. i can't deal with cabal hell this late
22:54:32 <L8D> trap_exit: what do you mean by concise?
22:54:34 <bitemyapp> trap_exit: it's possible.
22:54:42 <osa1> NemesisD: I don't know what problem you're having but maybe try --allow-newer
22:54:55 <bitemyapp> trap_exit: pointfree (tacit programming) is perfectly doable in Haskell. You just need runic aliases to functions.
22:54:58 <L8D> trap_exit: like point-free concise or pattern concise?
22:55:00 <trap_exit> L8D: looking at APL code, APL code looks shorter
22:55:10 <trap_exit> bitemyapp: waht is runic ?
22:55:12 <bitemyapp> trap_exit: not necessarily the kind of "shorter" you want.
22:55:14 <trap_exit> what is 'runic aliases" ?
22:55:22 <L8D> isn't APL a bunch of fancy UTF-8 characters?
22:55:22 <trap_exit> 'runic aliases' as in 'use unicode' ?
22:55:25 <bitemyapp> APL is pretty glyphy and write-once/read-never.
23:31:53 * hackagebot hasql-postgres 0.3.3 - A "PostgreSQL" backend for the "hasql" library  http://hackage.haskell.org/package/hasql-postgres-0.3.3 (NikitaVolkov)
23:31:55 * hackagebot hasql-postgres 0.4.0 - A "PostgreSQL" backend for the "hasql" library  http://hackage.haskell.org/package/hasql-postgres-0.4.0 (NikitaVolkov)
23:56:54 * hackagebot conduit 1.2.3 - Streaming data processing library.  http://hackage.haskell.org/package/conduit-1.2.3 (MichaelSnoyman)
23:59:47 <dwat3r> hi guys, i'm having troubles with libssh2. When I try to use this code, i get SOCKET_DISCONNECT error http://pastebin.com/1k3q82zn
