00:09:08 * hackagebot bindings-libstemmer 0.1.0.0 - Binding for libstemmer with low level binding.  http://hackage.haskell.org/package/bindings-libstemmer-0.1.0.0 (cosmo0920)
00:09:08 * hackagebot samtools-conduit 0.1.0.0 - Conduit interface to SAM/BAM format files through samtools  http://hackage.haskell.org/package/samtools-conduit-0.1.0.0 (NicholasIngolia)
00:24:04 * hackagebot samtools-conduit 0.1.1.0 - Conduit interface to SAM/BAM format files through samtools  http://hackage.haskell.org/package/samtools-conduit-0.1.1.0 (NicholasIngolia)
00:29:27 <solrize> @pl \x y -> abs (x-y)
00:29:28 <lambdabot> (abs .) . (-)
00:31:43 <m4db0y> @pl
00:31:43 <lambdabot> (line 1, column 1):
00:31:43 <lambdabot> unexpected end of input
00:31:43 <lambdabot> expecting white space, "()", natural, identifier, lambda abstraction or expression
00:43:58 <zeiris_> Has there been any recent (last ~year) developments in production-grade FRP libraries?
00:44:17 <zeiris_> IE ones that don't suffer from space leaks or an excess of experimental/impractical features.
01:12:33 <solatis> is there any way to tell cabal to expose all modules it can find based on the path of the files?
01:12:47 <solatis> or do i have to keep manually adding new modules to the exposed-modules field?
01:18:25 <solatis> nevermind, https://stackoverflow.com/questions/18084265/cabal-expose-all-modules-while-building-library tells me it is not possible
01:20:31 <edwardk> ok, i'm sitting here trying to find any cross platform gui library that can give me an opengl 4.1 context on a panel, and 'draw a bunch of other stuff in panels around it'.  That is the sum total of my requirements. wxhaskell can't do it -- wxmac 3.1 is the first version to let me pick profile, hsqml comes close but qt won't support core profile rendering
01:20:31 <edwardk> until 5.4, so thats dead. gtk+ has the same braindead options as wxmac < 3.1.
01:20:34 <edwardk> did i miss an option?
01:22:50 <edwardk> i can cripple myself down to a mac in theory and try to use hoc, but hoc is not on hackage apparently which is a great sign for how well the user experience for that would work out, and language-c-inline has a development story for producing a bundle, but its not appreciably better than 'start up xcode and cut and paste a ton of crap and do it yourself'
01:23:00 <edwardk> so even if i wanted to limit myself to one platform i seem to be dead in the water there as well.
02:29:14 <agocorona> edwardk I have never used WebGL but It seems the solution, at first sight
02:29:41 <edwardk> agocorona: doesn't scale to the features i need
02:29:59 <edwardk> webgl is basically crippled opengl es 2
02:30:11 <edwardk> and its a _lot_ slower due to running in a robust context
02:30:43 <edwardk> the webgl solution was my fallback plan, but it means the editor for what i'm working on would be orders of magnitude slower than the main display engine
02:30:53 <edwardk> and i'd have to maintain two radically different code paths
02:31:10 <edwardk> and incorporate ghcjs or the like into my whole pipeline, making for very complex builds
02:32:58 <Ralith> it seems like cobbling an OpenGL-based UI together by hand would be easier than that
02:32:59 <chrisdone> building with ghcjs so far has been not too bad. using it on a work project now
02:33:30 <simpson> edwardk: I think, annoyingly, that building your own UI in GL might be the easiest.
02:33:54 <edwardk> simpson: i'd been going that route
02:34:08 * hackagebot gloss-rendering 1.9.1.1 - Gloss Picture data type and rendering functions.  http://hackage.haskell.org/package/gloss-rendering-1.9.1.1 (BenLippmeier)
02:34:10 * hackagebot gloss 1.9.1.1 - Painless 2D vector graphics, animations and simulations.  http://hackage.haskell.org/package/gloss-1.9.1.1 (BenLippmeier)
02:34:12 * hackagebot gloss-raster 1.9.1.1 - Parallel rendering of raster images.  http://hackage.haskell.org/package/gloss-raster-1.9.1.1 (BenLippmeier)
02:34:14 * hackagebot gloss-examples 1.9.1.1 - Examples using the gloss library  http://hackage.haskell.org/package/gloss-examples-1.9.1.1 (BenLippmeier)
02:34:36 <edwardk> simpson: upon reflection it looks like qt 5.4 will support rendering to an opengl core context, .. and will be released in about a week and a half, and has an active release candidate i can test on
02:34:37 <chrisdone> edwardk: why not something like GLUT which gives you a basic window?
02:34:51 <edwardk> chrisdone: i'm using sdl2 right now
02:34:58 <chrisdone> or do you want actual toolkit things like basic text, buttons, layout, etc.
02:35:05 <edwardk> i'm working on some editor bits, and am looking for the toolkit
02:35:21 <chrisdone> i see
02:35:31 <luite> edwardk: we could try using ghcjs-dom, if you can live with the webgl limitations. at least you'd have the option to compile to native code then
02:35:31 <edwardk> basically i want something that looks grown up and usable =P
02:35:40 <edwardk> i can't live with the webgl limitations right now
02:35:56 <edwardk> i think i'm writing that off as all but a last resort
02:36:03 <chrisdone> edwardk: so sdl2 gives you the window, and i want the toolkit. gotcha
02:36:11 <chrisdone> s/i/you
02:36:15 * chrisdone being too empathetic
02:36:38 <edwardk> i don't particularly care where i get an opengl 4.1 context from, i just want one i can plug 'gl' into and go
02:37:33 <edwardk> it sounds like the qt 5.4 path is the most sensible, i can see if i can tweak hsqml into doing what i need to do off the release candidate, and have a user interface story that is installable by the time i can pay any real attention to it in 2 weeks time after i come back from australia
02:38:30 <luite> edwardk: hmm, i'd have to check if it's possible to better in this setting with webkitgtk or cef, since we're running native code anyway it might be doable to get a normal opengl context in a page
02:38:31 <Ralith> Qt can actually draw widgets *into* a GL context, which is pretty neat
02:38:47 <luite> +do
02:38:50 <edwardk> cef was my first plan, but its nigh uninstallable for users
02:39:09 <luite> edwardk: really? i thought it was reasonably self-contained
02:39:12 <edwardk> Ralith: yeah and with 5.4 it can do so for a core profile context
02:39:35 <chrisdone> Ralith: that's cool
02:39:45 <edwardk> luite: for windows and linux. for a mac you wind up with a frankenstein app bundle with 3 sub-app bundles and a structure that is pre-determined and it can't be bundled as a haskell application normally would
02:39:47 <luite> at least i had some hope for cef being easier than webkitgtk, the currently most complete ghcjs-dom+native backend
02:40:14 <luite> perhaps that's not setting the bar very high ;)
02:40:15 <edwardk> so any sense of 'cabal install quine' would go out the window
02:40:52 <edwardk> Ralith: that is actually a big factor in my decision to head down this route, being able to do the 'doom 3' thing would be really really nice
02:41:09 <luite> edwardk: hmm okay, is that a hard requirement, one step install?
02:41:11 <edwardk> where they at the time embedded a version of flash, doing the same for qml widgets could be quite productive
02:41:15 <edwardk> luite: damn near
02:41:28 <Ralith> edwardk: I was just thinking of overlays on the camera view, but that's pretty fun too, yeah
02:41:28 <chrisdone> i was thinking about the old win32 api and how you could render onto a bitmap and stick that in the gl. if qt does that, that's neato
02:41:57 <luite> edwardk: is cef typically packaged well/usably on linux?
02:41:59 <edwardk> Ralith: i was hoping to just get that out of the box, with current qt, but it looks like its _just_ at the edge of happening =/
02:42:08 <Ralith> aw
02:42:15 <edwardk> luite: typically packaged? ha,.. hah...hahahaha...hahahahahahaa
02:42:43 <edwardk> Ralith: well, its not bad, the release candidate is apparently cut
02:42:46 <luite> okay okay, i'm glad that at least you got some laughs out of this
02:43:05 <edwardk> Ralith: so i think the qt path looks viable
02:43:11 <Ralith> cool!
02:43:16 <Ralith> excited to see where this goes
02:43:20 <luite> hmm
02:43:26 <edwardk> hopefully i can get by with just qml for the heavy lifting
02:43:53 <edwardk> because i've tried all the other windowing options, so this is my last hope ;)
02:43:57 <luite> unfortunately for my own things i'm kind of html
02:44:02 <edwardk> sure
02:44:05 <edwardk> normally i would be
02:44:14 <edwardk> i was holding out a lot of hope for cef
02:44:29 <edwardk> but both times i spent hacking on trying to figure out haskell bindings have led nowhere
02:45:14 <edwardk> so i'm going to put it to bed for a while, and try other approaches
02:45:25 <luite> i do like the idea of proper opengl though, but the haskell and ghcjsi user interface needs interactive-diagrams / ghc-live type results
02:45:37 <luite> well at least i want those :p
02:46:23 <chrisdone> luite: well it have lazy presentations? =p
02:47:17 <edwardk> on the other hand the guts of hsqml are making me squeamish. it likes to hide a lot of the internals from users
02:47:23 <chrisdone> luite: like this https://www.youtube.com/watch?v=4rcPfZveGZc
02:47:31 <luite> chrisdone: sure, you mean calculate as much of the result as you display?
02:47:43 <chrisdone> luite: yup
02:49:53 <luite> but the main goal is to make sure you never need to use R anymore ;)
02:50:56 <chrisdone> luite: i'm currently interested in any ways to do that generically. more generically than Data.Data … for which most types are not instances. i'm beginning to think i could add it to ghci-ng, if the ghc api can give me enough information about types similar to Data.Data does
02:51:00 <luite> unfortunately we're still a bit behind in algorithms and data-frame support
02:51:38 <chrisdone> luite: sure, i just think the display of JS objects e.g. in Chrome is pretty decent. but the Haskell crowd has no decent inspection tool like that
02:52:00 <luite> so i still don't need to get bored once ghcjs is good enough to run the standalone distributed front end
02:52:02 <chrisdone> oddly, javascript is more 'functional' than haskell in that sense
02:52:42 <luite> chrisdone: yeah javascript has easy access to a gui toolkit
02:53:11 <luite> and laziness does make it more complicated
02:53:48 <chrisdone> from my experience with the present API, it's pretty easy if you have the reflection capabilities
02:53:50 <luite> you could do ghc-vis style
02:54:18 <chrisdone> http://hackage.haskell.org/package/present-1.1/docs/Present.html
02:54:28 <luite> i mean you don't want to unnecessarily expand a node, since it might not finish, or your evaluation order may be terrible
02:55:29 <luite> and it requires somewhat deep interaction with the rts to do it properly
02:55:54 <chrisdone> what are you proposing that my demo doesn't do?
02:56:51 <chrisdone> as i achieved this with a simple `present` function that takes a cursor "1.2.3.4" into a value, it only goes as far as it needs and only forces constructors it's asked to
02:58:05 <chrisdone> regarding computations that don't finish, that's a general REPL problem, already solved: you just need a simple C-c C-c
02:59:28 <luite> can you do it in such a way that it doesn't affect evaluation, or show you what it did affect?
03:00:07 <luite> also perhaps I'm biased by not thinking of C-c as simple, since the underlying async exceptions machinery is rather complicated :p
03:00:10 <chrisdone> i don't know what that question means
03:00:37 <chrisdone> you have to evaluate the part that you want to look at
03:00:44 <chrisdone> so that ‘affects’ evaluation
03:01:50 <chrisdone> maybe you're thinking of some kind of REPL that acts like some kind of laziness debugger
03:01:54 <luite> chrisdone: oh i'm thinking in terms of a debugger. if you dig into a node and show it, it's similar to manually calling a function in another language
03:02:22 <chrisdone> sure
03:02:38 <luite> right, sometimes i just want to see a value, but not have it update thunks everywhere, or i'd like to kow what exactly is involved in reducing that node to whnf
03:03:42 <kraljev7> how can I most easily implement a map that would prevent duplicate values?
03:03:49 <kraljev7> besides keys, that is.
03:03:59 <luite> in think the tools that we have so far for this are rather inadequate or teaching or figuring out laziness issues in complicated existing code
03:04:07 <kraljev7> I could use Bimap, but that seems inefficient
03:04:12 <Cale> kraljev7: Maybe two maps? Or a map and a set?
03:04:16 <luite> anyways
03:04:23 <kraljev7> Cale, so nothing inbuilt?
03:04:31 <Cale> kraljev7: It depends on how you want to deal with duplicates
03:04:39 <luite> <- need to go fix my cabal patch stuffs
03:04:40 <kraljev7> what are the options?
03:04:54 <Cale> Well, when you insert the same value at a new key, what happens?
03:05:16 <kraljev7> probably Left
03:05:26 <kraljev7> but it could just as well override the value
03:05:57 <kraljev7> that is, remove the previous associated key
03:06:08 <Cale> In the first case, it would be sufficient to store an additional Set of the values in the Map, in the latter, you'd like to know which key the original value occurred at, so that you could remove it, so you'd need the reverse Map.
03:06:24 <kraljev7> Cale, thank you
03:06:40 <kraljev7> Does the Strict map do anything like that?
03:07:05 <Cale> Nope
03:07:34 <Cale> Data.Map.Strict uses the same datatype as Data.Map.Lazy, it's just stricter versions of the functions acting on maps
03:08:30 <Cale> Bimap is probably ideal for you.
03:09:20 <Cale> If you want to produce good error messages, having the reverse mapping is pretty good regardless.
03:09:36 <kraljev7> yes, i have decided not to complicate the life with a map and a set
03:09:49 <kraljev7> despite a bit higher memory requirement
03:09:53 <kraljev7> How does WeakMap (in java) compare to Lazy.Map
03:10:53 <ChristianS> kraljev7: completely unrelated
03:10:54 <kraljev7> oh, stupid question, forget it.
03:11:02 <Cale> Yeah, there's no weak pointers there.
03:11:03 <kraljev7> thank you both!
03:11:42 <Cale> System.Mem.Weak is a way to make weak pointers
03:12:28 <Groutcho> Is there an open source project somewhere simple enough to study it as a beginner in Haskell, though not a beginner en programming ?
03:12:45 <Groutcho> (With documentation and good comments, if possible)
03:14:05 <ChristianS> Groutcho: xmonad maybe
03:14:25 <Cale> I'm not totally sure what to recommend, but this is sort of roughly in the same direction: https://www.haskell.org/haskellwiki/Research_papers/Functional_pearls
03:14:45 <alpounet> Groutcho: maybe you'll enjoy these "code deconstructed" videos https://www.youtube.com/playlist?list=PLxj9UAX4Em-Lz5btngxMVZxf_B44GETVz
03:15:13 <Cale> (Though without the practical engineering side of things, they're papers about applying functional techniques to various problems, where things worked out very well.)
03:15:44 <Cale> Some of them are more rarefied than others
03:15:55 <Groutcho> Christians: Thank you, though i'm on Windows, I'll have a look at this
03:16:33 <Groutcho> Cale: Those functional pearls seem promising ! Thank you
03:17:02 <Groutcho> alpounet: Thank you :)
03:17:05 <Cale> Yeah, Xmonad has some really interesting structure. At its core, it has an abstract datatype representation of what windows are on the screen which can be manipulated with pure functions, and then there's a layer around that which does actual communication to the X server.
03:18:52 <Cale> http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.8.3014 -- had to look twice at the author's name here :D
03:19:40 <Cale> (not quite Magnus Carlsen ;)
03:20:05 <dibblego> heh, you watch the world championship?
03:20:10 <Cale> Yeah
03:20:15 <dibblego> same same
03:20:21 <dibblego> better than last year
03:20:50 <Cale> I watched Jerry's stream ChessNetwork on twitch.tv. I don't play a whole lot of chess, so the analysis helped in appreciating everything that was going on.
03:21:00 <dibblego> yeah I watch jerry
03:21:28 <dibblego> I play every week at a club, with my son.
03:44:33 <apo> chrisdone: of course I'm right ;)
03:45:32 <chrisdone> apo: also a great demotivator ;)
03:45:54 <apo> :(
03:46:01 <apo> meanie
03:47:12 <Cale> wat
03:57:09 <lennartl> is there a (ghc) extension to allow the same variable twice in a pattern match, eg. `tupleEq (a, a) = True; tupleEq _ = False`?
03:57:44 <mauke> no
03:58:44 <mauke> tupleEq = uncurry (==)
03:59:42 <lennartl> yes, but for more complex matches it makes my code way cleaner
04:00:08 <lennartl> thanks
04:00:12 <mauke> except it's unclear what it would mean
04:00:40 <mauke> consider: foo x y y x = (x, y)
04:00:45 <mauke> what would that desugar to?
04:01:23 <lericson> fairly obvious don't you think?
04:01:27 <mauke> no
04:01:47 <mauke> I put in two traps
04:01:51 <lericson> the same as foo x y z w | x == z, y == w = (x, y)
04:02:02 <mauke> that's wrong
04:02:11 <mauke> you're comparing x to z
04:02:23 <lericson> ah well switch around a little and it should be fine
04:02:41 <mauke> then the question becomes, why are you comparing x == w first and not y == z?
04:03:14 <bitonic> lericson: the problem here is that Eq does not really mean that two things are "the same".  in languages where there is a better notion of equality you can have pattern matches with the same variables multiple times
04:03:19 <bitonic> e.g. prolog, Agda
04:03:27 <mauke> bitonic: shh, that's trap #2
04:03:40 <lericson> i see
04:03:53 <lericson> well then that's just a weak Eq
04:04:04 <bitonic> what do you mean?
04:04:26 <mauke> trap #3 would be NaN, I guess
04:04:26 <lericson> if two things are equal you should be able to interchange them, don't you think?
04:04:39 <mauke> lericson: that's undecidable
04:04:50 <bitonic> lericson: if by "equal" you mean "== returns True", then no
04:05:08 <bitonic> I mean presumably you should, but there are no laws for == stating that
04:05:12 <lericson> what is an example of two things that are equal but not interchangeable?
04:05:18 <lericson> that is the definition of equality, to be equal
04:05:43 <lericson> i am, by the way, an engineer ;)
04:06:02 <mauke> lericson: I can give you the opposite: two things that are interchangeable but not equal
04:06:06 <bitonic> lericson: this very useful type: <http://hackage.haskell.org/package/bound-1.0.4/docs/Bound-Name.html#t:Name>
04:06:34 <bitonic> lericson: the equality compares only the `b' element, but the Show instance shows the `n' too
04:06:56 <bitonic> so they're not "the same" (you can replace one for the other in every context), even if == returns true
04:07:03 <bitonic> and it's a perfectly valid Eq instance
04:07:31 <mauke> lericson: btw, is this "interchangeable" before or after == ?
04:07:35 <mauke> because == has effects
04:07:37 <lericson> i see
04:07:47 <lericson> mauke: how so?
04:07:53 <bitonic> oh right, lazyness
04:07:55 <mauke> it can force thunks
04:08:05 <mauke> could be a performance difference
04:08:17 <bitonic> well, I think that's a marginal problem there
04:08:27 <bitonic> the big problem is that == doesn't mean what lericson thought it meant
04:08:28 <mauke> the decision which input you bind to the variable can also affect memory use
04:08:41 <mauke> (more/less sharing)
04:10:24 <lericson> then a stronger form of equality could be formulated
04:10:53 <mauke> like ... really unsafe pointer equality?
04:11:10 <lericson> i have to say i maintain that Eq should be enough here, even if it can have implications
04:11:16 <lericson> we never said we weren't gonna have implications
04:11:35 <mauke> you still have to say which implications
04:11:37 <bitonic> lericson: Eq wasn't created for that
04:12:01 <mauke> in particular, how do you desugar 'foo x y y x = (x, y)' and why?
04:14:41 <lericson> mathematically it's no problem
04:14:58 <mauke> this isn't math
04:14:58 <lericson> in many other languages it's no problem either
04:15:16 <mauke> in many other languages it's a problem too
04:15:19 <lericson> istm it should be possible to have a non-ambiguous way to deal with it
04:31:41 <ThreeOfEight> Equality in Haskell is a bit different from equality in logic
04:33:19 <ThreeOfEight> In Haskell, wenn you e.g. define data Fraction = Fraction Integer Integer and define an Eq instance with Fraction a b == Fraction c d = a*d == b*c, the idea is that you kind of look at Fraction as equivalence classes w.r.t. (==)
04:33:25 <ThreeOfEight> *when
04:33:55 <ThreeOfEight> But Fraction still /has/ an internal structure that you can inspect, so to ‘equal’ values don't necessarily behave exactly the same
04:34:44 <ThreeOfEight> The onus is on the programmer to ensure that outside the module where the type is defined, this internal structure is invisible and equal values behave the same
04:34:54 <ThreeOfEight> And of course, this is not enforced at all by Haskell
04:35:48 <bitonic> lericson: btw, this problem of when considering two things "the same" is highly debated in circles that need such a notion, like dependently typed languages/theorem provers
04:35:49 <ThreeOfEight> In Isabelle, you cannot ‘define’ equality of values; the only things you know about equality is that ∀x. x = x and ∀f g. (∀x. f x = g x) ==> f = g
04:36:15 <bitonic> ThreeOfEight: that's already a lot!  extensionality
04:36:17 <ThreeOfEight> i.e. reflexivity and extensionality (and symmetry and transitivity, of course, but I think only one of them is an axiom in th elogic)
04:36:30 <ThreeOfEight> bitonic: yes it is
04:36:49 <bitonic> well usually you can derive everything else with whatever "eliminator" you have for =
04:36:52 <ThreeOfEight> and if you want a fraction type in which (1,2) is equal to (2,4), you explicitly have to derive a new type
04:37:20 <ThreeOfEight> in which the values are the equivalence classes of Integer × Integer w.r.t. your equivalence relation
04:37:28 <bitonic> e.g. the leibniz's law, but probably something more powerful like J
04:38:29 <bitonic> there are "more powerful" equalities being developed though, like OTT/HoTT.  I think lericson would want something like OTT -- two things are equal when you can replace one for the other in any context
04:38:42 <bitonic> when they're "drop in" replacements for one another
04:38:53 * bitonic goes for lunch
04:39:57 <ThreeOfEight> um
04:41:16 <hacker> OTT/HoTT? what is it?
04:41:16 <ThreeOfEight> If you know that ∀P::a→Bool. P x = P y
04:41:39 <ThreeOfEight> (i.e. the "you can replace one for the other in any context)
04:41:52 <ThreeOfEight> then you can simply instantiate P := λx. x = y
04:42:06 <ThreeOfEight> and get (x = y) = (y = y)
04:42:17 <ThreeOfEight> and (y = y) = True due to reflexivity, so (x = y) = True
04:42:33 <ThreeOfEight> Or am I missing something?
04:42:49 <ThreeOfEight> hacker: HoTT is Homotopy Type Theory, I never heard of OTT.
04:44:06 <lennartl> is the missing `real/replacement` equality the only thing in the way of `foo x y y x = (x, y)`?
04:46:32 <lennartl> because then a Eq' class with laws stating that two 'equal' instances must always be replacable by each other, should solve that
04:47:04 <shachaf> lennartl: Here's a section in a book about some of the issues with it: http://research.microsoft.com/en-us/um/people/simonpj/papers/slpj-book-1987/PAGES/065.HTM
04:48:17 <shachaf> I didn't read the conversation above in detail but it sounds like mauke was getting at this sort of thing.
04:49:52 <Kaidelong> haskell (==) isn't even reflexive
04:50:12 <Kaidelong> so there might be some surprising results anyway
04:50:46 <lennartl> shachaf: yes, that looks like a problem
04:51:56 <wz1000> ThreeOfEight: How does that deal with bottoms
04:52:23 <ThreeOfEight> wz1000: ah yes, that is the problem. Isabelle has no bottom.
04:52:33 <ThreeOfEight> well, HOL doesn't
04:53:06 <wz1000> ThreeOfEight: So you have to prove that all your programs terminate?
04:53:08 <ThreeOfEight> logical reasoning in the presence of undefinedness is a huge PITA
04:53:09 <Kaidelong> shachaf: it's not clear to me how spj's example breaks down *without* involving bottom
04:53:17 <ThreeOfEight> wz1000: well, not technically
04:53:32 <Procian> wz1000: Isabelle isn't a "Curry-Howard" like theorem prover.
04:53:48 <Procian> It's classical simple type theory.
04:53:50 <ThreeOfEight> you can have nonterminating functions, but until you prove termination, you know absolutely nothing about your functions
04:53:53 <Kaidelong> I'm not sure if it's really that relevant that language features can sometimes break or misbehave when you involve it, particularly if they misbehave in a well documented way
04:53:54 <ThreeOfEight> yes, it is
04:54:18 <Procian> (Isabelle/HOL, anyway)
04:54:30 <Kaidelong> what this seems to say is that you should simply just automatically transform "f x x V" into "f x y V | x == y"
04:54:40 <ThreeOfEight> e.g. you can define function f :: "nat ⇒ nat" where "f x = f x + 1"
04:54:47 <Kaidelong> since the latter is an upper bound of the former
04:54:59 <lennartl> shachaf: if matches are evaluated in parallel (until one fails or all match), i think it should be solvable (might have said something stupid there), but i see how it is a problem in haskell
04:55:09 <ThreeOfEight> but you cannot use the equation "f x = f x + 1" until you prove that f terminates for that particular x
04:55:39 <ThreeOfEight> but normally, you just prove that your functions terminate everywhere
04:55:44 <ThreeOfEight> it makes things much easier
04:55:58 <ThreeOfEight> (Isabelle can almost always prove that automatically anyway)
04:56:24 <Kaidelong> ThreeOfEight: that specific example is kind of bad when talking about how you need to prove that f terminates to be able to do it because it demonstrates that f doesn't terminate
04:56:39 <ThreeOfEight> Kaidelong: what do you mean?
04:56:43 <ThreeOfEight> oh
04:56:44 <ThreeOfEight> I see
04:56:44 <Kaidelong> well unless + is non-strict in its first argument
04:56:51 <ThreeOfEight> No, Isabelle is strict.
04:57:53 <ThreeOfEight> okay, you could have something like "f 0 = 0; f x = 1 + f (x - 1)"
04:58:11 <ThreeOfEight> that is the identity for non-negative numbers and does not terminate for negative numbers
04:58:17 <Procian> Kaidelong: What you're doing in most HOLs with something like "f x = f x + 1" is picking the arbitrary least fixpoint of the corresponding higher-order function.
04:58:37 <ThreeOfEight> then you could prove that it terminates for all non-negative values
04:58:45 <ThreeOfEight> and for any x ≥ 0, you can then use f x = x
04:58:54 <ThreeOfEight> but for x < 0, you know absolutely nothing about what f x is.
04:59:03 <Procian> Kaidelong: If there is no such fix-point, you just get an arbitrary function.
05:03:18 <wz1000> Is there any name for values that can never be beta-reduced?
05:03:21 <bitonic> ThreeOfEight: OTT = observational type theory
05:03:50 <Procian> wz1000: Beta normal forms?
05:04:18 <wz1000> Sorry, s/never/always/g
05:04:45 <Procian> Beta redexes?
05:05:56 <wz1000> OK, i'm really sleepy. I meant never be beta reduced completely.
05:06:25 <wz1000> Terms of the form 'justjust = Just justjust'
05:06:42 <ThreeOfEight> Isn't that a type error?
05:06:45 <ThreeOfEight> Occurs check?
05:07:02 <wz1000> Wait that won't type check
05:07:03 <ThreeOfEight> (unless justjust is defined in a type class or something)
05:07:20 <wz1000> infinity = S infinity
05:07:20 <Procian> wz1000: Maybe something like "divergent" then.
05:07:21 <ThreeOfEight> you mean something like zeros = 0 : zeros?
05:07:22 <wz1000> there
05:07:36 <wz1000> ThreeOfEight: Yes
05:07:45 <ThreeOfEight> I think infinity is actually bottom
05:07:52 <ThreeOfEight> wait
05:07:53 <ThreeOfEight> no
05:07:54 <ThreeOfEight> it's a datatype
05:08:09 <wz1000> ThreeOfEight: It is in head normal form
05:08:24 <wz1000> data N = Z | S N
05:08:25 <ThreeOfEight> in that case, I think that all non-bottom values in Haskell that can be beta-reduced infinitely often are infinite ADTs
05:08:40 <wz1000> infinity :: N
05:08:49 <ThreeOfEight> Yes, I get it. :)
05:09:01 <shachaf> Kaidelong: Yes, well, Haskell without _|_ is a very well-behaved language.
05:09:17 <wz1000> ThreeOfEight: infinity is not a datatype. Its a number
05:09:23 <ThreeOfEight> (in Isabelle, we call those codatatypes)
05:09:26 <bitonic> @quote curry-howard
05:09:26 <shachaf> lennartl: You have to be careful with that sort of thing.
05:09:26 <lambdabot> poetix says: I would really like to read, as an epistolary novel, the Curry-Howard correspondance (that is, letters they wrote to each other). Yes, I know it's really a correspondence, that they didn't actually correspond. But someone should write the letters they would have written if they had.
05:09:38 <ThreeOfEight> wz1000: but N is an ADT
05:09:39 <bitonic> @quote kmc curry-howard
05:09:39 <lambdabot> kmc says: "Haskell is great, because Curry-Howard!  Proving things in the type system.  We can prove that, uh, Ints exist, unless they're ⊥."
05:09:52 <shachaf> lennartl: First specify the semantics of that expression and then figure out how to compile it.
05:09:58 <wz1000> ThreeOfEight: infinity is a value
05:10:10 <ThreeOfEight> well, it's a value whose type is an ADT
05:10:14 <wz1000> ThreeOfEight: It is the successor of infinity
05:10:23 <ThreeOfEight> and in particular, it's an infinite value of that datatype
05:10:27 <wz1000> ThreeOfEight: yes
05:10:50 <ThreeOfEight> and I would say that all Haskell values that can be β-reduced infinitely often are either bottom or infinite values of a datatype
05:11:33 <wz1000> ThreeOfEight: Stream a = Cons a (Stream a)
05:11:35 <ThreeOfEight> I think ‘non-terminating values’ would be a good name for that
05:11:46 <ThreeOfEight> wz1000: Yes, I know what a stream is. ;)
05:12:02 <wz1000> Values :: Stream can always be beta reduced infinitely
05:12:05 <ThreeOfEight> That's another classic example of a codatatype
05:12:13 <ThreeOfEight> yes, because all values of stream are infinite
05:12:22 <bitonic> I think I'm throwing GHC into a loop :(
05:12:38 <wz1000> bitonic: You should be ashamed of yourself
05:13:05 <bitonic> or it might  just be some exponential behaviour related to higher ranked types
05:13:11 <bitonic> probably that actually
05:14:14 * hackagebot caramia 0.3.0.0 - Less painful OpenGL 3.3 rendering  http://hackage.haskell.org/package/caramia-0.3.0.0 (Adeon)
05:14:22 <wz1000> Haha in some cases x == x will fail to terminate, but x /= y will terminate when x and y are both infinitly beta reducible
05:14:26 <ThreeOfEight> What can cause GHC to loop? Non-normalising rewrite rules, undecidable instances, …?
05:14:31 <wz1000> Thats really funny
05:14:46 <bitonic> ThreeOfEight: UndecidableInstances for sure.  probably funny rewrite rules too
05:14:52 <Kaidelong> that probably shouldn't have to be the case
05:15:04 <ThreeOfEight> Sure. zeros = zeros will never terminate, zeros = ones will always terminate very quickly.
05:15:10 <ThreeOfEight> For zeros = 0 : zeros and ones = 1 : ones
05:15:16 <ThreeOfEight> (assume 0 ≠ 1, of course)
05:15:18 <Kaidelong> if the RTS sees two types in the form X : FnPtr Rest
05:15:22 <Kaidelong> err, two values
05:15:28 <Kaidelong> it should be able to say they're equal
05:15:39 <ThreeOfEight> bitonic: well, yes, that's what I thought, I just wondered whether there was something else that can cause GHC to loo
05:15:42 <ThreeOfEight> *loop
05:16:53 <bitonic> ThreeOfEight: my code which uses neither, apparently
05:17:11 <bitonic> ThreeOfEight: the inliner used to loop sometimes
05:17:14 <bitonic> not sure if that's still the case
05:17:49 <ThreeOfEight> Random though: one feature that I've been wanting occasionally is type wildcards
05:18:22 <ThreeOfEight> i.e. something like "return :: _ -> [_]"
05:18:49 <mauke> return `asTypeOf` (undefined :: a -> [b])
05:19:02 <ThreeOfEight> Yes, but that is a bit verbose
05:19:32 <wz1000> ThreeOfEight: It is the exact same number of characters
05:19:32 <bitonic> ThreeOfEight: that is being implemented
05:19:42 <mauke> wz1000: ??
05:19:43 <bitonic> ThreeOfEight: "partial type signatures", it's called
05:19:51 <ThreeOfEight> bitonic: awesome :)
05:19:59 <mauke> > length "return :: _ -> [_]"
05:20:01 <lambdabot>  18
05:20:07 <mauke> > length "return `asTypeOf` (undefined :: a -> [b])"
05:20:09 <lambdabot>  41
05:20:13 <ThreeOfEight> mauke: but that is a neat trick, I hadn't thought of that
05:20:14 <bitonic> ThreeOfEight: <https://ghc.haskell.org/trac/ghc/wiki/PartialTypeSignatures>
05:20:23 <wz1000> mauke: I meant the type signature
05:20:41 <ThreeOfEight> however, my colleague always gives me very funny looks when I use undefined in code
05:20:57 <ThreeOfEight> I used it as a phantom variable to specialise polymorphic properties for QuickCheck testing once
05:21:21 <ThreeOfEight> he took it out and replaced it with singleton types; it is now twice as long, but if it makes him happy *shrug*
05:35:39 <Saizan> wz1000: for return you could write (return :: a -> [a]) but in other cases like read :: _ -> Int it doesn't work to replace _ with a type variable
05:38:32 <ThreeOfEight> How does it work with return?
05:38:45 <ThreeOfEight> I meant when I want to use return somewhere
05:39:08 <ThreeOfEight> i.e. say I want to do „map return xs”, where xs :: [SomeComplicatedType]
05:39:37 <ThreeOfEight> then I'd have to write ‘map return xs :: [SomeComplicatedType]’
05:39:49 <ThreeOfEight> With type wildcards, can write ‘map return xs :: [_]’
05:41:37 <shachaf> @let gives :: (a -> b) -> b -> (a -> b); gives f _ = f
05:41:39 <lambdabot>  Defined.
05:41:41 <shachaf> :t return `gives` []
05:41:42 <lambdabot> a -> [a]
05:42:31 <ThreeOfEight> :t return `gives` Nothing
05:42:32 <lambdabot> a -> Maybe a
05:43:23 <Procian> Given?
05:43:48 <mauke> gaben
05:50:52 <adamse> is there a nice way to combine two Values in Aeson?
05:51:47 <Cale> adamse: Combine in what way?
05:52:13 <Cale> There are lots of things which can be done with two Values
05:53:49 <Cale> You can (\x y -> toJSON (x,y)) :: Value -> Value -> Value
06:07:57 <afadfa> @unpl h g f = (f . g) $ f
06:07:57 <lambdabot> h g f = f (g f);
06:09:16 * hackagebot caramia 0.3.0.1 - Less painful OpenGL 3.3 rendering  http://hackage.haskell.org/package/caramia-0.3.0.1 (Adeon)
06:13:47 <afadfa> :t h g f = f  (g f)
06:13:48 <lambdabot> parse error on input ‘=’
06:16:43 <afadfa> @unpl h g f = (f. g)
06:16:43 <lambdabot> h g f c = f (g c);
06:24:20 <favetelinguis> Anyone doing nothing and what to help me up with my homework? It is this lab http://www.cse.chalmers.se/edu/course/TDA452/labs/3/ I have implemented everything but im totaly stuck on the solve' function. I have three different implementations but non of them find a solution withing reasonable time. Been trying to get it to work for 2 days not so im fed up and would rly appreciate some help.
06:30:44 <athan> favetelinguis: How are you trying to solve it? How are you going about the actual solving routine?
06:31:10 <favetelinguis> i can send you the code i have so far
06:31:19 <favetelinguis> dont whant to put it out on the internet
06:31:23 <favetelinguis> ?
06:31:24 <athan> If you can organize it into a 1-pass fold, that usually gets things done pretty quick :)
06:32:06 <athan> or you could just pm me an lpaste
06:33:16 <solarus> favetelinguis: I think there are some extra assignments available for this lab to make the solve function faster
06:33:34 <athan> @tell chrisdone Could you look at this sometime? I can't seem to get the types to coerce :S http://lpaste.net/115335 . Is there a definitive `empty_` term that I should be using?
06:33:34 <lambdabot> Consider it noted.
06:34:26 <athan> favetelinguis: Accumulators are your friend! At least that's what I keep telling myself :P
06:34:53 <ThreeOfEight> favetelinguis: one common approach is to maintain a list of possible values for each field
06:35:28 <ThreeOfEight> and once there is only one possible value left for a field, you can set that value as fixed and updated the rest of the lists accordingly with that new information
06:35:58 <ThreeOfEight> you can also do stuff like ‚If there is only one field in a row that can accomodate a 9, this field /must/ be assigned a 9.‘
06:36:10 <ThreeOfEight> But at some point, you /will/ have to guess assignments.
06:36:13 <favetelinguis> solarus: yes bu my solution does not find anything for minutes :)
06:36:29 <jcora> I have a simple question: is `data Maybe a = Nothing | Maybe a` a declaration of an algebraic type? To be more general, are types with multiple constructors (like Maybe), algebraic?
06:36:32 <favetelinguis> http://lpaste.net/115336 here is the solution if someone feel like having a look
06:36:40 <favetelinguis> i will delete the paste in a few minutes :)
06:36:45 <chrisdone> athan: remove the toHtml call?
06:36:55 <athan> :O
06:36:57 <favetelinguis> i have tree different solvers
06:37:18 <favetelinguis> one is just a desperete oneliner using list comprehension thogh
06:37:21 <athan> chrisdone: Thank you so much, sorry if I woke you ><
06:37:45 <chrisdone> athan: it's the afternoon here, i'm around =)
06:41:21 * athan is okay... this time.
06:44:40 <solarus> favetelinguis: your current solve' does not seem to be tail recursive
06:44:47 <solarus> that might be related
06:45:34 <ThreeOfEight> jcora: what do you mean by ‘algebraic’?
06:45:39 <pold> Is there a tool/automatic way for removing all comments in a .hs file?
06:45:42 <ThreeOfEight> data produces algebraic data types
06:47:04 <favetelinguis> solarus: well im not getting a stack overflow after letting it run for a few minutes
06:48:15 <joeytwiddle> pold, i don't know about block comments, but you can try this for lines: cat file.hs | grep -v "^--" | sed 's+\s*--.*++' > file_no_comments.hs
06:50:41 <lpaste> mauke pasted “remove haskell comments” at http://lpaste.net/115337
06:50:48 <mauke> pold: ^
06:51:05 <mauke> sorry, the code is deliberately crazy
06:51:14 <mauke> and I haven't tested it with TH
06:51:48 <pold> joeytwiddle: ohh, that's clever and works fine, thanks a lot!
06:52:02 <mauke> ... and I found a bug in gaps handling
06:52:07 <mauke> damn corner cases
06:52:13 <pold> mauke: I will try that!
06:52:39 <lericson> can haskell syntax really be completely handled by a regular expression?
06:52:42 <mauke> joeytwiddle: broken if you have an operator called --+ or something
06:53:11 <mauke> lericson: no, due to "nested" comments
06:53:24 <lericson> what of show "-- amazing --"
06:53:27 <mauke> this code only handles one level of nesting
06:53:35 <lericson> ah yes
06:53:36 <lericson> no recursion
06:53:43 <mauke> that should work in my regex
06:53:52 <mauke> it tries to properly tokenize and skip string literals
06:54:32 <joeytwiddle> mauke :) what a regexp!
06:55:38 <lpaste> mauke annotated “remove haskell comments” with “remove haskell comments (handle gaps)” at http://lpaste.net/115337#a115341
06:56:07 <mauke> I haven't tested it but I think the original code misparsed "\ \"
06:56:09 <mauke> > "\ \"
06:56:11 <lambdabot>  ""
06:56:38 <mauke> which isn't really common in code
06:57:38 <mauke> this program was adapted from a similar one for C comments
06:58:01 <mauke> I wanted to see if I could remove C comments using only a single substitution op
06:58:24 <mauke> (answer: yes, but it's fucking awful due to trigraphs and line continuation)
06:59:10 <pold> mauke: Nice, thanks, very handy! No, I didn't have any "\ \" and it works great.
07:00:01 <jcora> ThreeOfEight, well algebraic data types seem to be well-defined, I'm just not sure I'm interpreting their definition well. You can look them up on Wikipedia or HaskellWiki.
07:01:06 <ThreeOfEight> well, it's complicated
07:01:18 <ThreeOfEight> I think normally, infinite lists are not considered datatypes
07:01:24 <ThreeOfEight> but codatatypes
07:01:28 <ThreeOfEight> but I'm not really an expert in this
07:02:21 <favetelinguis> is there someway i can get the output of traceShow to be logged into a externa file?
07:03:01 <ThreeOfEight> but anyway, the types data produces (without compiler extensions) are normal algebraic datatypes (with possibly infinite values)
07:03:38 <ThreeOfEight> favetelinguis: one way would be to output to stderr and redirect stderr to a file on the terminal
07:04:01 <favetelinguis> how do i do that?
07:04:31 <mauke> ./prog 2>error.txt
07:05:09 <ThreeOfEight> oh, actually, trace already logs to stderr
07:07:18 <ThreeOfEight> favetelinguis: alternatively, http://lpaste.net/115342
07:07:31 <ThreeOfEight> But that might not be very efficient. Not sure, didn't test performance.
07:07:50 <ThreeOfEight> usage: logTraceShow "/tmp/log" (42 :: Integer)
07:22:05 <EvanR> cabal install java-bridge isnt working http://lpaste.net/115344
07:22:31 <EvanR> it says cant find src/ffijni.h ... but where does that come from
07:25:54 <EvanR> in /System/Library/Frameworks/JavaVM.framework/Headers there is jni.h but not ffijni.h
07:30:53 <EvanR> these are supposed to be in the package itself it seems
07:32:34 <stephen_> /nick stephen_
07:32:34 <stephen_>  
07:37:03 <michaelt> EvanR: they are in the package, if you do `cabal unpack java-bridge` etc
07:37:43 <michaelt> EvanR: they uploaded the /dist directory to hackage, I don't know if thats the problem somehow
07:38:25 <EvanR> yes i see, im trying to cabal build in the unpacked package
07:39:19 * hackagebot gitcache 0.2 - Simple git utility to use and manage clone cache  http://hackage.haskell.org/package/gitcache-0.2 (VincentHanquez)
07:43:07 <EvanR> ok i got it to work, first by doing -v3 to get the real error message
07:43:26 <EvanR> which was "jni.h not found" and then putting the path in extra-include-dirs
07:44:41 <EvanR> the path to the headers for javaVM
08:14:54 <thungsten> is there a typeclass that has a function with the type (a -> b) -> f a -> b? like for example if i wrap a list in a newtype and I want to get the length of the wrapped list as an Int
08:15:55 <mauke> @hackage newtype
08:15:56 <lambdabot> http://hackage.haskell.org/package/newtype
08:16:43 <enrico_gec> !lista
08:16:43 <monochrom> enrico_gec: http://okmij.org/ftp
08:17:02 <thungsten> mauke: thank you
08:19:21 <EvanR> if you have f a and a -> b, you cant necessarily get b, because you cant necessarily get an a
08:20:25 <EvanR> the empty list has no a's for example
08:23:58 <hughfdjackson> hey :)
08:24:06 <hughfdjackson> i'm having a little factoring conundrum
08:24:27 <hughfdjackson> i'm attempting to add the idea of synonyms (i.e. symbols represending expressions to be substituted in before evaluation) to my lambda calculus repl
08:24:50 <hughfdjackson> https://github.com/hughfdjackson/abattoir/blob/synonyms/src/Lambda.hs#L27-L32 <- i changed to the type to this, where S is the synonym type, V a regular variable, Ap function application, and L a lambda function
08:25:35 <hughfdjackson> my intention is to attempt to resolve all synonytms into lambda expressions only using L, V and Ap before trying to eval them
08:25:58 <hughfdjackson> but i have no way to express that in the type system atm, so all of my previous evaluation functions are now not exhaustive pattern matches
08:26:43 <hughfdjackson> :| i think i'm talking myself into writing two separate types here - ExprWithSynonyms, and regular Expr
08:26:52 <hughfdjackson> *ahem* apologies, will go and try that
08:28:01 <hughfdjackson> (my initial objection to that was having to write two separate show implementions for those, but i guess that's the lesser evil here!)
08:29:22 * hackagebot list-t 0.3.0 - ListT done right  http://hackage.haskell.org/package/list-t-0.3.0 (NikitaVolkov)
08:29:55 <EvanR> hughfdjackson: also known as variables
08:30:19 <thungsten> EvanR: I will allways get an a if I just newtype something, because if my function is ([a] -> Int)  (length for example). Then my newtype wrapper will have type MyNewType [a].
08:30:25 <EvanR> doesnt lambda calculus already have those
08:31:03 <EvanR> thungsten: yeah so youre really talking about the wrapper unwrapper for newtype
08:31:14 <thungsten> yes that is correct.
08:31:14 <EvanR> rather than general f a
08:31:32 <hughfdjackson> EvanR: Synonyms come from a generic global environment, used for convenience
08:31:36 <hughfdjackson> like I = (\x.x)
08:31:44 <hughfdjackson> for the identity function
08:32:35 <EvanR> hughfdjackson: ok, standard library. which can be implemented by putting your program inside of a big lambda
08:32:35 <hughfdjackson> variables represent either values (as in just `x`) or bound values (i.e. will change when the lambda function is invoked: e.g. the last `x` in (\x.x))
08:32:43 <hughfdjackson> EvanR: basically
08:32:59 <EvanR> unless you are distinguishing between symbols and variables syntatically
08:33:15 <EvanR> thungsten: this newtype class looks cool
08:33:21 <hughfdjackson> i am - capital or numbers for synonyms, lower-case for variables
08:33:49 <hughfdjackson> executing inside a big lambda is an interesting way to look at it ^^
08:41:40 <thungsten> EvanR: Yeah, I guess what I was looking for was the "unpack" function. So I can do things like length . unpack $ MyWrapper [1, 2, 3]
08:42:48 <redwire> Has anyone here played with implementations of Clojure's transducers in Haskell? More interestingly, has anyone thought about their relationship with traditional finite state transducers?
08:48:20 <EvanR> hughfdjackson: on the flip side, considering all lambda bodies as having some environment, rather than getting substituted, also works and is more efficient
08:52:11 <bitemyapp> redwire: not much of a relationship with finite state transducers, unless those are a fold too. https://hackage.haskell.org/package/lens-4.6/docs/Control-Lens-Fold.html
08:53:14 <redwire> I was just thinking that. They may just be semantically distinct
08:54:22 * hackagebot hasql-backend 0.2.1 - API for backends of "hasql"  http://hackage.haskell.org/package/hasql-backend-0.2.1 (NikitaVolkov)
09:09:23 * hackagebot stm-containers 0.2.4 - Containers for STM  http://hackage.haskell.org/package/stm-containers-0.2.4 (NikitaVolkov)
09:09:23 <marchelzo_> @src tell
09:09:23 <lambdabot> Source not found. Have you considered trying to match wits with a rutabaga?
09:09:25 * hackagebot cli 0.0.1 - Simple Command Line Interface Library  http://hackage.haskell.org/package/cli-0.0.1 (nicolasdp)
09:13:54 <indigo945> what is considered to be a good pure data structure with a nice interface for multi-dimensional access when i need to modifiy it often?
09:14:23 * hackagebot slave-thread 0.1.4 - A principal solution to ghost threads and silent exceptions  http://hackage.haskell.org/package/slave-thread-0.1.4 (NikitaVolkov)
09:14:24 <indigo945> Data.Array.IArray is O(n) on every modification, and Data.Sequence doesn't have a proper interface when i need a two-dimensional structure
09:15:15 <indigo945> i could just use the old trick from C and do index dataSequence (x + y * WIDTH), but eh
09:16:18 <alexchandel1> hey
09:16:22 <alexchandel1> why haven't y'all ported Rust's borrow checker to Haskell?
09:16:24 <mauke> the C trick would be a sequence of sequences
09:16:51 <indigo945> but then i have to call index twice for every access
09:17:23 <indigo945> sure i could just wrap it in a function, but i felt like the standard library has to have a nicer solution :/
09:17:31 <alexchandel1> like, you could eliminate Haskell's garbage collector altogether
09:19:23 * hackagebot cli 0.0.2 - Simple Command Line Interface Library  http://hackage.haskell.org/package/cli-0.0.2 (nicolasdp)
09:20:24 <alexchandel1> you could pretty much eliminate the Haskell's runtime mm
09:20:46 <mauke> alexchandel1: why haven't you?
09:20:57 <chrisdone> get on it!
09:21:16 <alexchandel1> lol I think that would be quite difficult
09:21:21 <alexchandel1> I don't have sufficient knowledge of
09:21:22 <mauke> ...
09:21:27 <alexchandel1> 1) Haskell the language
09:21:33 <alexchandel1> 2) Haskell internals
09:21:41 <alexchandel1> 3) Rust's borrow checking implementation
09:21:47 <alexchandel1> other than that I think I could do it, though
09:21:56 <mauke> same here, plus 4) I don't even have ghc installed
09:22:11 <mauke> also 5) what is rust
09:22:49 <exio4> a imperativeish language with lots of cheap functional features
09:23:11 <exio4> (cheap in the cost-sense eh!)
09:23:28 <agocorona> and a nice name and logo
09:23:58 <exio4> it is kinda nice, alpha, though
09:24:07 <agocorona> that is almost the most important today
09:24:24 * hackagebot yesod-bin 1.4.1 - The yesod helper executable.  http://hackage.haskell.org/package/yesod-bin-1.4.1 (MichaelSnoyman)
09:24:26 * hackagebot yesod-form 1.4.2.1 - Form handling support for Yesod Web Framework  http://hackage.haskell.org/package/yesod-form-1.4.2.1 (MichaelSnoyman)
09:25:00 <mauke> my next language will be called "herpes"
09:25:51 <EvanR> in order to spread fast?
09:27:00 <alexchandel1> mauke: make sure you add ownership & a borrow-checker
09:28:51 <hughfdjackson> alexchandel1: there's no such thing as borrowing in herpes :|
09:29:27 <alexchandel1> boom, headshot
09:54:05 <Black0range> Hello p
09:54:48 <Black0range> people, i'm trying to test compile a program on mac 10.10 but get the error message "gcc-4.8: warning: couldn't understand kern.osversion '14.0.0" anyone know whats up?
09:57:41 <Black0range> oh nvm should've just googled straight away
09:59:07 <tattsun> hi, i want to verify a signature using openssl. is there any way to verify by haskell?
10:01:43 <EvanR> tattsun: there seem to be several TLS packages
10:02:38 <EvanR> HsOpenSSL and tls
10:03:04 <bitonic> edwardk: is it somehow bad to define Zoomed instances for my own monads?  or is there some way to use `zoom' otherwise with my own monads?  I'm asking because I need to import Internal stuff
10:03:46 <tattsun> thanks!
10:04:45 <EvanR> tattsun: try tls first, it looks simpler
10:09:17 <edwardk> bitonic: if you have a strong enough stomach to figure out how to write it for your own monad, then by all means go for it
10:09:59 <bitonic> edwardk: I'm in the process of.  it doesn't look *too* bad
10:10:05 <bitonic> btw, I've needed `Err' before
10:10:23 <edwardk> does anyone know whatever became of the qthaskell project? the site is dead
10:10:50 <bitonic> edwardk: I asked this question a few days ago <https://www.haskell.org/pipermail/libraries/2014-November/024416.html>.  I'm not sure why you need it in `FocusingErr' though
10:12:11 <edwardk> i saw the question, I'm ambivalent about the Monoid you want there. it is slightly less defined than the semigroup i have now, and more or less to get your desired usecase I'd use something like Validation and asum
10:12:37 <bitonic> edwardk: `Validation' does something different though
10:12:51 <edwardk> I don't remember the details of FocusingErr off the top of my head nd i'm going to go hop on a plane in a bit here and still need to pack so i have limited time to dig
10:12:58 <bitonic> and I do use it, I found out about yours after I reinvented it :P
10:13:14 <bitonic> edwardk: sure, I asked since you were around
10:13:40 <edwardk> bitonic: np, just explaining the situation i find myself in =)
10:13:59 <edwardk> happy to have the conversation when i have more time to dig
10:14:06 <bitonic> coolio, enjoy your flight
10:14:44 <edwardk> i have something like 24 hours on planes coming up, not sure enjoy is the right word =)
10:15:41 <bitonic> ehe I hate even 2 hours of flying
10:15:44 <bitonic> you seem to do a lot of that
10:16:06 <edwardk> made the mistake of saying yes to all the places that invited me out to give a talk this year ;)
10:16:19 <bitonic> I remember you complaying about that at ICFP
10:16:26 <bitonic> the great ekmett Haskell tour of 2014
10:16:50 <edwardk> next year i think i'll scale back a bit
10:17:34 <bitonic> FWIW I really enjoyed your lens talk... although I probably wouldn't be spending time on `zoom' now if I hadn't :P
10:17:50 <bitonic> not sure if that's good or bad
10:18:00 <edwardk> heh
10:18:55 <Black0range> On osX yosmite, I can't seem to get ghc to run properly... :/ anyone know anything about it?
10:19:26 <tobiasgw> @Black0range no, sorry,
10:19:27 <lambdabot> Unknown command, try @list
10:19:32 <dmj`> Black0range: what's the problem?
10:19:37 <Black0range> ghc --make test
10:19:37 <Black0range> Linking test ...
10:19:37 <Black0range> gcc-4.8: warning: couldn't understand kern.osversion '14.0.0
10:19:48 <michaelt> hah, I was just adding slightly surly praise of `zoom` on the extensible-effects reddit http://www.reddit.com/r/haskell/comments/2novmn/til_about_extensibleeffects_an_alternate_universe/cmfo4di
10:20:16 <michaelt> Black0range: did you install a new ghc?
10:20:27 <Black0range> yeah
10:20:28 <Heather> why it's not possible to write something alike getArgs >>= (getOpt RequireOrder options)
10:20:51 <Black0range> full error message: http://pastebin.com/wTsBH09z
10:22:37 <tattsun> EvanR: actually, i'm writing android purchase verifier. i must encode der to pem. but tls or hsopenssl seems too complex for me.
10:23:55 <michaelt> Black0range: hm .. . I don't know. I haven't had trouble.  I cleared out all my old stuff.  I am using the tarball from the ghc site, locally installed fwiw
10:24:27 * hackagebot hasql-postgres 0.7.2 - A "PostgreSQL" backend for the "hasql" library  http://hackage.haskell.org/package/hasql-postgres-0.7.2 (NikitaVolkov)
10:24:43 <EvanR> tattsun: oh.. then you might be able to just run a command line program
10:25:04 <EvanR> openssl
10:25:27 <EvanR> openssl x509 -in cert.crt -inform der -outform pem -out cert.pem
10:25:43 <tattsun> EvanR: i know that i can encode "openssl rsa -inform DER -outform PEM -pubin -in public.der -out public.pem",
10:26:02 <HeladoDeBrownie> Heather, because getArgs is in IO but getOpt RequireOrder options does not have an IO action as its output. Try fmap (getOpt RequireOrder options) getArgs instead.
10:26:09 <HeladoDeBrownie> @type (>>=)
10:26:11 <lambdabot> Monad m => m a -> (a -> m b) -> m b
10:26:12 <HeladoDeBrownie> @type fmap
10:26:15 <lambdabot> Functor f => (a -> b) -> f a -> f b
10:26:26 <tattsun> but i must do that in server program.
10:26:40 <HeladoDeBrownie> Heather, in those types above, substitute m ~ IO or f ~ IO
10:26:44 <EvanR> tattsun: server surely has openssl installed
10:26:56 <HeladoDeBrownie> (>>=) :: IO a -> a -> IO b -> IO b
10:27:04 <HeladoDeBrownie> fmap :: (a -> b) -> IO a -> IO b
10:27:25 <HeladoDeBrownie> Woops
10:27:29 <Heather> HeladoDeBrownie so I don't escape monad with both operations...
10:27:31 <HeladoDeBrownie> (>>=) :: IO a -> (a -> IO b) -> IO b
10:27:39 <bitonic> edwardk: if I comment out the Monoid instance for Err nothing happens.  so it's just dead code
10:27:45 <bitonic> nothing happens = `lens' compiles fine
10:27:46 <Black0range> Hmm how do you uninstall haskell completely on a mac?
10:27:49 <HeladoDeBrownie> Heather, yeah, there's no "escaping" IO. You just lift everything to IO.
10:27:57 <athan> Is there any way to get lucius to render css with lines intact? I think something's going buggy :S
10:27:59 <bitonic> Semigroup and Monoid instance
10:28:36 <tattsun> EverR: hmm, i mean that i must do that in my server program written in haskell. maybe, is it easier to use System.Process to use openssl?
10:28:47 <Heather> HeladoDeBrownie but well when I get args with <- in do notation and then use it... why can't I do the same inline?
10:29:18 <HeladoDeBrownie> Heather, that's just syntactic sugar. do { x' <- x ; f x' } is the same as x >>= \x' -> f x'
10:29:28 <bitonic> edwardk: or, more likely, there is some subtly ramification I don't see right now :P
10:29:39 <michaelt> Black0range: the haskell platform used to come with a script that hunted stuff out.
10:29:51 <Heather> HeladoDeBrownie but I can't pass getArgs >>= do x
10:30:04 <edwardk> bitonic: not necessarily
10:30:08 <Heather> HeladoDeBrownie I mean as for my example pass getArgs to getOpt
10:30:13 <edwardk> re 'dead code'
10:30:17 <HeladoDeBrownie> Heather, getArgs >>= \args -> …
10:30:23 <Black0range> michaelt: used to? :(
10:30:26 <bitonic> edwardk: yeah, I realise those instances could affect stuff downstream
10:30:28 <monochrom> getArgs and getOpt have different types. incomparable.
10:30:30 <bitonic> I just don't see it now though
10:30:31 <Heather> HeladoDeBrownie I was trying it, doesn't work also
10:30:34 <EvanR> tattsun: or use System.Cmd
10:30:38 <HeladoDeBrownie> Heather, show what you tried
10:30:39 <michaelt> Black0range: if you install it without the haskell platform, the crucial stuff to get rid of is in ~/.ghc and ~/.cabal  but you should keep some of the executables in .cabal/bin
10:30:43 <HeladoDeBrownie> Heather, include any error messages
10:30:57 <Heather> I know that getOpt RequireOrder options $ unsafePerformIO getArgs will work
10:31:01 <Heather> but it's kinda evil )
10:31:16 <michaelt> Black0range: oh I just meant, I haven't used the platform for a long time.
10:31:16 <tattsun> EvanR: i see.. thank you.
10:31:30 <HeladoDeBrownie> Heather, getArgs >>= \args -> getOpt RequireOrder options args
10:31:46 <edwardk> the scenarios this would arise would be something like using zoom with a traversal or magnify with a fold
10:31:49 <Heather> HeladoDeBrownie  Expected type: ([Options -> IO Options], [String], [String])    Actual type: IO [String]
10:31:50 <HeladoDeBrownie> Heather, or simply just getArgs >>= getOpt RequireOrder options
10:31:55 <edwardk> bitonic: something like that triggers the need for that monoid
10:31:57 <michaelt> Black0range: I think if you hunt down the actual place of the platform ghc there is an 'uninstall-haskell.sh' or something like that in there.
10:31:59 <Heather> HeladoDeBrownie it doesn't work
10:32:05 <HeladoDeBrownie> Heather, if what you just said is true, it should
10:32:07 <HeladoDeBrownie> Heather, show code
10:32:21 <edwardk> bitonic: the library doesn't do that itself, however, its more user code that would
10:32:22 <Heather> HeladoDeBrownie (actions, nonOpts, msgs) = getArgs >>= \args -> getOpt RequireOrder options args
10:32:26 <Black0range> michaelt: i found that but it didn't remove things properly
10:32:38 <HeladoDeBrownie> Heather, not =, <-
10:32:54 <Heather> why <-
10:33:03 <EvanR> :t not (=)
10:33:05 <HeladoDeBrownie> Because you want to chain that with some other IO
10:33:05 <lambdabot> parse error on input ‘=’
10:33:06 <bitonic> edwardk: right, I have never thought about that use-case -- I had just defined something to run a StateT computation with a smaller state inside a bigger one.  I'm going to dig more
10:33:09 <EvanR> :t not (==)
10:33:11 <lambdabot>     Couldn't match expected type ‘Bool’
10:33:11 <lambdabot>                 with actual type ‘a0 -> a0 -> Bool’
10:33:11 <lambdabot>     Probable cause: ‘(==)’ is applied to too few arguments
10:33:26 <monochrom> Heather: you may need to read my http://www.vex.net/~trebla/haskell/IO.xhtml
10:34:02 <Black0range> michaelt: ooh i had it installed with brew and the normal way... :/
10:34:10 <Heather> HeladoDeBrownie but I use >>= there and I don't need both <- and >>=
10:34:23 <HeladoDeBrownie> Heather, you are effectively using (>>=) twice
10:34:24 <michaelt> Black0range: oh, can you uninstall the brew one too?
10:34:39 <HeladoDeBrownie> Heather, or what you're going for would involve doing so
10:35:15 <Heather> HeladoDeBrownie getOpt doesn't return IO
10:35:24 <Heather> iirc
10:35:36 <lebesgue> @type getOpt
10:35:38 <lambdabot> Not in scope: ‘getOpt’
10:35:51 <lebesgue> @type System.Console.getOpt
10:35:52 <michaelt> Black0range: I highly recommend just using the ghc tarball putting it in ~/haskell/...   you need to have cabal build independently and maybe happy and alex
10:35:53 <lambdabot> Not in scope: ‘System.Console.getOpt’
10:36:04 <lebesgue> @type System.Console.GetOpt.getOpt
10:36:07 <lambdabot> System.Console.GetOpt.ArgOrder a -> [System.Console.GetOpt.OptDescr a] -> [String] -> ([a], [String], [String])
10:36:13 <lebesgue> yep, no io
10:36:21 <Heather> so I use = there
10:36:28 <Black0range> michalt: yes worked fine :) now it all works
10:36:34 <Heather> but I can't escape monad if I use >>= there...
10:36:45 <Heather> or somehow type problem appears with >>=
10:37:07 <HeladoDeBrownie> Heather, right, I almost forgot, we mentioned that earlier. That's when I suggested using fmap
10:37:07 <HeladoDeBrownie> My fault
10:37:07 <HeladoDeBrownie> (actions, nonOpts, msgs) <- fmap (getOpt RequireOrder options) getArgs
10:37:07 <HeladoDeBrownie> That ought to do it for you
10:37:07 <HeladoDeBrownie> Also read monochrom's tutorial
10:37:18 <lebesgue> Since getOpt is pure, you would normally invoke it like getOpt [opt descs] <$> getArgs
10:37:25 <HeladoDeBrownie> Heather, no, don't use =, use <-. And you don't want to "escape" IO anyway
10:37:28 <michaelt> Black0range: oh good
10:38:09 <Heather> Heather how should I use <- without IO ?
10:38:11 <HeladoDeBrownie> Heather, it helps if you look at the types involved
10:38:11 <HeladoDeBrownie> Heather, do you know how to read types?
10:38:15 <EvanR> what does escape IO mean
10:38:26 <Heather> HeladoDeBrownie basically
10:38:30 <EvanR> you cant escape anything anywhere
10:39:08 <Heather> EvanR I can )
10:39:19 <Heather> EvanR unsafePerformIO  does it
10:39:28 * hackagebot hasql 0.2.2 - A minimalistic general high level API for relational databases  http://hackage.haskell.org/package/hasql-0.2.2 (NikitaVolkov)
10:39:59 <HeladoDeBrownie> Heather, so what you have is getArgs :: IO [String], getOpt RequireOrder options :: [String] -> ([Something], [String], [String]), and fmap :: (a -> b) -> IO a -> IO b. You can combine these to ultimately end up with IO ([Something], [String], [String])
10:40:02 <HeladoDeBrownie> And that way is the way I mentioned above
10:40:17 <Heather> finally
10:40:18 <Heather> (actions, nonOpts, msgs) <- getOpt RequireOrder options <$> getArgs
10:40:20 <Heather> works )
10:40:29 <Heather> lebesgue HeladoDeBrownie thanks
10:41:38 <AnalogFile> Heather: yes. It is the same as what HeladoDeBrownie suggested. (actions, nonOpts, msgs) <- fmap (getOpt RequireOrder options) getArgs
10:41:53 <HeladoDeBrownie> Once you have that, it's a matter of chaining it with another computation using (>>=) or what have you
10:41:53 <HeladoDeBrownie> Which is what <- desugars to
10:41:53 <HeladoDeBrownie> (I just wrote Something as a shorthand for that other type I don't know the entirety of, it's not important)
10:41:55 <AnalogFile> the <$> is in fact the same as fmap (but as an infix operator)
10:41:56 <HeladoDeBrownie> Namely, fmap (getOpt RequireOrder options) getArgs has that type
10:42:09 <HeladoDeBrownie> Heather, sweet, glad you got it figured out
10:42:51 <Heather> yes I understand
10:42:57 <EvanR> Heather: why would you describe that as escaping, you would use it when *not* in IO to get a type to match some non-IO environment
10:43:00 <HeladoDeBrownie> Heather, and again I highly recommend monochrom's tutorial, if you missed the link it's http://www.vex.net/~trebla/haskell/IO.xhtml
10:43:08 <Heather> never used <- with <$> before
10:43:18 <EvanR> Heather: so unsafePerformIO is closer to "breaking into" IO
10:43:46 <monochrom> there is always the first time
10:44:09 <monochrom> in year 2000, I would have said, "never heard of Haskell before". look where I am now.
10:44:29 * hackagebot hasql 0.3.0 - A minimalistic general high level API for relational databases  http://hackage.haskell.org/package/hasql-0.3.0 (NikitaVolkov)
10:44:32 <Heather> Haskell I/O is not lazy ...
10:44:42 <AnalogFile> you use <- within the do notation when the right hand side has a monadic type. The expression to the right of <- can be anything as long as the type is in the same monad of the do block
10:44:45 <Heather> okay I know nothing about Haskell :D
10:44:52 <EvanR> Heather: well theres getContents
10:46:24 <lebesgue> unsafePerformIO is wonderful, I use it all over my code.
10:46:31 <EvanR> its the shit
10:46:35 <lebesgue> unsafePerformIO . return $ 5
10:46:36 <Heather> :D
10:46:40 <Heather> opinions
10:46:42 <AnalogFile> you can very well use an expression containing <$> or >>= or fmap to the right of <- (look at the types of those operators and of fmap, they return a functor/monad)
10:47:11 <EvanR> now = unsafePerformIO getCurrentTime
10:47:36 <Heather> EvanR what difference with <- ?
10:47:55 <monochrom> lebesgue: you may also like: http://lpaste.net/77374
10:48:02 <lebesgue> Heather, a <- b is literally more or less b >>= \a ->
10:50:03 <EvanR> Heather: if you use do ... <- ... to combine IO actions to get another IO action, it doesnt necessarily execute anything
10:50:43 <EvanR> > Just (getChar >>= putChar)
10:50:47 <lambdabot>  Just <IO ()>
10:50:57 <arianvp__> < ? >
10:51:00 <arianvp__> what is <>
10:51:46 <EvanR> :t (<>)
10:51:49 <lambdabot> Monoid m => m -> m -> m
10:51:50 <Heather> > Just(putChar (unsafePerformIO getChar))
10:51:54 <lambdabot>  Not in scope: ‘unsafePerformIO’
10:51:56 <lebesgue> arianvp_: IO a doesn't have a Show instance, so its showing the type instead, I presume
10:52:01 <arianvp__> ah
10:52:16 <EvanR> <IO ()> is dummy output for an IO action
10:52:41 <monochrom> lambdabot adds it for user friendliness
10:52:54 <EvanR> Heather: if that were fully evaluated, that would execute effects. my version would not
10:53:05 <nerium> Has anyone here worked with primitive recursive functions?
10:53:16 <nerium> in haskell
10:53:40 <Heather> EvanR what kind of effects
10:53:49 <EvanR> Heather: the getChar
10:53:59 <Heather> EvanR with no input there for example?
10:54:09 <lebesgue> Presumably the thread on the machine where lambabot is running would try to `getchar`
10:54:11 <EvanR> getChar doesnt take input, its an atomic command
10:54:27 <EvanR> :t getChar
10:54:28 <lambdabot> IO Char
10:58:01 <EvanR> :t getCurrentTime
10:58:03 <lambdabot> Not in scope: ‘getCurrentTime’
11:02:44 <bitonic> edwardk: ohhhh now I see why you need it
11:02:47 <bitonic> this stuff is pretty crazy
11:03:03 <edwardk> bitonic: heh
11:03:25 <exio4> is there anything in haskell that isn't pretty crazy?
11:03:27 <edwardk> bitonic: i had to go pretty crazy to figure out how to fit it all together
11:03:33 <bitonic> edwardk: I can imagine that
11:03:56 <bitonic> exio4: yeah but there is a crazy ladder you walk up to
11:04:27 <bitonic> I really wonder if this stuff can realistically be in the standard Haskell vocabulary
11:04:49 <bitonic> as transformers are, for example.  maybe it's just that I'm new to them
11:10:18 <K999> hi .
11:12:51 <arjanb> hi K999
11:13:05 <K999> to what kind of music belongs this music video?
11:13:17 <K999>  https://www.youtube.com/watch?v=4-he9-F0dic
11:17:55 <edwardk> bitonic: i confess by the end of working on lens i was seeing things more or less by corollary to Jonathan Strange and Mr. Norrell -- around when Strange consumes something and starts seeing the little candles in everyone's heads and goes a little cracked.
11:17:56 <ReinH> K999: This isn't a music channel.
11:18:17 <dmj`> any hosting recommendations for standalone haddocks? I need them private...
11:19:00 <ReinH> dmj`: Hackage server?
11:19:29 <K999> We are anonymous we are legion we do not forgive we do not forget expect us
11:19:46 <davean> dmj`: They
11:19:52 <davean> dmj`: They're static files, just use any webserver?
11:21:07 --- mode: ChanServ set +o edwardk
11:21:18 --- kick: K999 was kicked by edwardk (K999)
11:21:22 <EvanR> noice
11:21:57 <bitonic> edwardk: lol.  do you realize what you've done?
11:22:03 <solrize> haskell has had anonymous functions fromthe beginning, what's the prob?  :)
11:22:36 <EvanR> lol
11:22:57 <edwardk> bitonic: yes, i was nice and didn't /kickban, just /kicked ;)
11:23:08 <bitonic> edwardk: ahah no, I meant by creating `lens'
11:23:56 <bitonic> I feel like I'm going a little cracked too when I try to figure out some of those types
11:24:43 <edwardk> bitonic: heh, I'm pretty sure I accidentally invoked the many-angled ones, the horrors who live at the bottom of the mandelbrot set, but otherwise not sure. =)
11:33:15 <EvanR> how do i cabal configure, or cabal build, or something but activating DEBUG flags?
11:34:07 <EvanR> ok -f DEBUG
11:39:20 <dmj`> ReinH, davean: not for hackage this time, yes they are just static. Was looking for an off-the-shelf solution. I could do it myself. It's like using travis vs. rolling your own build server
11:39:33 <dmj`> wanted something easy
11:39:51 <dmj`> plus I'm lazy
11:47:05 <EvanR> hot diggity i got java-bridge to work
11:54:31 * hackagebot hasql 0.2.3 - A minimalistic general high level API for relational databases  http://hackage.haskell.org/package/hasql-0.2.3 (NikitaVolkov)
11:57:07 <favetelinguis> what would be the best way to totaly remove haskel platform and everything cabal has installed from osx and then reinstall the newest haskell platform?
11:57:56 <lebesgue> rm -rf
12:09:44 <edwardk> favetelinguis: there is an uninstaller in /Library/Frameworks/GHC.framework/
12:10:09 <favetelinguis> ok, what does it uninstall?
12:10:20 <edwardk> ok, hasql officially gets the prize for best haskell db pun
12:10:39 <edwardk> favetelinguis: you can ask it to uninstall by version or all versions through a given number
12:10:42 <edwardk> it basically nukes everything
12:11:22 <favetelinguis> hmm cant find it
12:11:26 <favetelinguis> what is it named
12:12:14 <edwardk> uninstall-hs
12:12:25 <favetelinguis> noope i dont have that
12:12:51 <favetelinguis> all i have i Resources and Versions under that dir
12:13:03 <edwardk> alternately: bash <(curl -s https://raw.github.com/gist/3775443/uninstall-haskell-platform.sh)
12:17:57 <angerman> I'm looking for some simple th applications, if someone has some simple or slightly more complex th snippets for me, please send them my way (or even better, send me a PR with the test case on https://github.com/angerman/oopth/tree/master/Test)
12:25:15 <cdk> @unmtl WriterT (Reader r w) m a
12:25:17 <lambdabot> m (a, (Reader r w))
12:25:45 <cdk> @unmtl ReaderT r m (Writer w a)
12:25:47 <lambdabot> r -> m (Writer w a)
12:31:44 <athan> So normally lists model non-determinism with cartesian combinations of it's elements, correct? Is there a way to simply model parallel combinations, like zippers, with lists? ideally I'd like to use them with applicative:
12:32:04 <athan> > (\x y -> x * y) <$> [1,2,3,4] <*> [1,2,3,4]
12:32:06 <lambdabot>  [1,2,3,4,2,4,6,8,3,6,9,12,4,8,12,16]
12:32:21 <athan> instead of [2,4,6,8] :/
12:32:28 <athan> er
12:32:42 <ion> > zipWith (*) [1,2,3,4] [1,2,3,4]
12:32:44 <lambdabot>  [1,4,9,16]
12:32:46 <ion> > liftA2 (*) [1,2,3,4] [1,2,3,4]
12:32:48 <athan> [1,4,9,16] u_u
12:32:48 <lambdabot>  [1,2,3,4,2,4,6,8,3,6,9,12,4,8,12,16]
12:33:08 <ion> > liftA2 (*) (ZipList [1,2,3,4]) (ZipList [1,2,3,4])
12:33:10 <lambdabot>  ZipList {getZipList = [1,4,9,16]}
12:34:41 <athan> ion: !!! Thank you!!!
12:39:46 <athan> christdone: How can I use pre-escaped text? For instance "&nbsp;"?
12:41:52 <ThreeOfEight> athan: you could probably use OverloadedStrings and your own String type
12:41:59 <ThreeOfEight> unless there already exists something like that
12:42:33 <athan> ThreeOfEight: I'm not sure, I think toHtmlRaw_ might be used for this :S
12:42:47 <athan> Yep!
12:42:56 <nitrix> I have a question. Given a Integer, how does one find the largest power of two that fits in there? In C, I'd look at the most significant bit, which is probably possible too in Haskell for a Int, but what about an Integer? Do we have that level of access to the internals?
12:43:39 <ThreeOfEight> nitrix: yes, see Data.Bits
13:00:35 <vrs> I have a bunch of monads packed in a two-dimensional list and I want to do roughly this: [[a b]] -> a [b]
13:00:36 <nitrix> ThreeOfEight: They all seem to be working on Ints.
13:00:43 <nitrix> ThreeOfEight: Not Integer. Did I miss something?
13:01:17 <vrs> I have no idea where to start
13:01:31 <nitrix> ThreeOfEight: Nevermind: "Instances of the class Bits for the Int and Integer types are available from this module"
13:02:05 <marchelzo_> :t (sequence . concat)
13:02:09 <lambdabot> Monad m => [[m a]] -> m [a]
13:03:04 <vrs> hmmm
13:06:47 <vrs> I had no idea concat could do that
13:07:36 <lebesgue> vrs: Why not? the concact is just going from [[m a]] to [m a], which for k = m a, is just [[k]] to [k]
13:08:28 <vrs> oh, wrong end then
13:22:25 <bernalex> how do I replace oldexception with exception here: https://www.haskell.org/haskellwiki/Roll_your_own_IRC_bot/Source ?
13:23:01 <bernalex> the use of 'catch' will fail because no instance for (Exception e0) arising from a use of 'catch'
13:25:39 <vrs> wheeee
13:25:56 <vrs> @pf sequence $ map sequence
13:25:58 <lambdabot> Maybe you meant: pl bf
13:26:04 <vrs> @pl sequence $ map sequence
13:26:07 <lambdabot> sequence (map sequence)
13:26:31 <vrs> that's what I was looking for
13:26:49 <vrs> it was staring me in the face from the documentation but I didn't read it right
13:26:58 <vrs> thanks marchelzo_
13:32:03 <mauke> bernalex: catchIOError
13:32:52 <bernalex> mauke: oh right. thanks.
13:35:42 <vrs> @pl \x y -> x ++ "a" ++ y
13:35:44 <lambdabot> (. ('a' :)) . (++)
13:37:34 <bernalex> vrs: that's basically intercalate
13:37:45 <indigo945> is there a way of having lambdabot import a module before asking it to pl?
13:37:48 <bernalex> > intercalate " " ["hello", "world"]
13:37:51 <lambdabot>  "hello world"
13:38:03 <vrs> intersperse you mean?
13:38:25 <bernalex> vrs: no, you used "a". intersperse would be 'a'.
13:39:07 <bernalex> and intersperse is typically used for stuff like
13:39:10 <bernalex> > intersperse ' ' ("hello" ++ "world")
13:39:14 <lambdabot>  "h e l l o w o r l d"
13:39:22 <mauke> indigo945: what would that do?
13:39:34 <indigo945> pl \xs -> (Data.Sequence.index . Data.Sequence.index) xs
13:39:40 <indigo945> @pl \xs -> (Data.Sequence.index . Data.Sequence.index) xs
13:39:40 <lambdabot> Data.Sequence.index . Data.Sequence.index
13:39:56 <indigo945> ic
13:40:39 <indigo945> @pl \xs -> Data.Sequence.index . Data.Sequence.index xs
13:40:39 <lambdabot> (Data.Sequence.index .) . Data.Sequence.index
13:40:47 <bernalex> vrs: interspersing "a" would do something very different than the function you defined
13:41:06 <bernalex> > (. ('a' :)) . (++) $ "hello" "world"
13:41:09 <lambdabot>  Couldn't match expected type ‘[GHC.Types.Char] -> [GHC.Types.Char]’
13:41:09 <lambdabot>              with actual type ‘[GHC.Types.Char]’
13:41:17 <bernalex> erm
13:41:30 <bernalex> @let f x y = x ++ "a" ++ y
13:41:33 <lambdabot>  .L.hs:162:1:
13:41:33 <lambdabot>      Equations for ‘L.f’ have different numbers of arguments
13:41:33 <lambdabot>        .L.hs:162:1-11
13:41:33 <lambdabot>        .L.hs:163:1-21
13:41:37 <bernalex> god damnit
13:41:40 <mauke> @undefine
13:41:42 <bernalex> @let vrs x y = x ++ "a" ++ y
13:41:43 <lambdabot> Undefined.
13:41:46 <lambdabot>  Defined.
13:41:50 <bernalex> vrs "hello" "world"
13:41:53 <bernalex> > vrs "hello" "world"
13:41:56 <lambdabot>  "helloaworld"
13:42:03 <bernalex> > intercalate "a" ["hello", "world"]
13:42:06 <lambdabot>  "helloaworld"
13:42:13 <bernalex> > intersperse "a" ["hello", "world"]
13:42:16 <mauke> indigo945: @pl doesn't understand haskell anyway
13:42:16 <lambdabot>  ["hello","a","world"]
13:42:29 <bernalex> vrs: so, you see what I mean, I'm sure.
13:42:50 <bernalex> mauke: it knows about some builtin stuff
13:43:10 <bernalex> @pointless f a b = f b
13:43:13 <lambdabot> f = fix const
13:43:22 <mauke> ?
13:43:47 <mauke> @pl \x -> do y <- x
13:43:49 <lambdabot> (do y <-)
13:43:58 <bernalex> @undo do { y <- x }
13:44:00 <lambdabot> <unknown>.hs: 1: 14:Parse error: Last statement in a do-block must be an expression
13:44:18 <bernalex> heh.
13:44:27 <indigo945> mauke: yeah i figured that out now, should have realized that earlier, thanks
13:44:27 <nitrix> You can undo!?
13:44:40 <bernalex> nitrix: sure
13:44:53 <indigo945> i don't even know why i typed the module names in the second pl call, i guess i was at it ;)
13:45:04 <bernalex> @undo do { x <- Just 42 ; return x }
13:45:05 <lambdabot> Just 42 >>= \ x -> return x
13:45:27 <bernalex> then you can
13:45:32 <bernalex> @pointless Just 42 >>= \ x -> return x
13:45:33 <lambdabot> Just 42
13:45:46 <bernalex> there should be a way to 'undo & then pointfree' something.
13:46:01 <mauke> @. pl undo do { x <- f y; return (g x) }
13:46:02 <lambdabot> g `fmap` f y
13:46:16 <bernalex> mauke: sweet -- thanks.
14:04:58 <chrisdone> mgsloan =)
14:12:01 <mgsloan> 'lo chrisdone!
14:18:57 <beso35> is there any chanell for portuguese speakers?
14:21:56 <beso35> ?
14:22:02 <beso35> is there any chanell for portuguese speakers?
14:22:39 <MrFlibble> is there any channel for white, male, gay, British, English speakers with hayfever?
14:22:46 <tobiasgw> :P
14:24:19 <tobiasgw> @beso35 almost: #haskell.es
14:24:21 <lambdabot> Unknown command, try @list
14:24:39 <shachaf> There is #haskell-br but I think it's pretty empty.
14:24:54 <MrFlibble> I guess saying Portuguese is like Spanish is kind of an insult
14:25:13 <tobiasgw> yeah, I suppose
14:25:37 <tobiasgw> and to make matters worse haskell.es is practically empty
14:27:18 <escondida> MrFlibble: Well, they're both Romance languages, but still definitely quite different (-:
14:29:33 * hackagebot hsqml 0.3.2.1 - Haskell binding for Qt Quick  http://hackage.haskell.org/package/hsqml-0.3.2.1 (RobinKay)
14:29:35 * hackagebot hsqml-demo-notes 0.3.2.0 - Sticky notes example program implemented in HsQML  http://hackage.haskell.org/package/hsqml-demo-notes-0.3.2.0 (RobinKay)
14:35:16 <kolossen> I used to love Python, as a less experienced programmer it was so much simpler than other things and offered so many good libraries. but the more experienced I get the more i question the design.
14:35:40 <kolossen> OO is not as great as it promises. self is terrible. no private methods...
14:36:00 <kolossen> we need a functional prog lang for MCUs though
14:36:03 <kolossen> what can we do?
14:36:39 <cjheath> What size MCU do you mean. ARM7, or PIC?
14:37:32 <cjheath> kolossen: ping?
14:38:02 <kolossen> ping?
14:38:08 <j201> i'm looking forward to trying rust for uCs
14:38:24 <kolossen> cjheath, well, I guess 8 bit MCUs is going abit low? but 16 and 32
14:38:43 <cjheath> Yup. You can already do Haskell on ARM
14:40:38 <cjheath> The thing in MCUs is often memory capacity, which is much inflated if you need to GC
14:44:51 <alexchandel1> cjheath: wouldn't be a problem if haskell has a borrow checker like Rut
14:44:53 <alexchandel1> * Rust
14:45:44 <cjheath> Yup. I like tyhe way Rust is going, but it looks like you have to understand and be very deliberate about the different kinds of ownership
14:45:51 <cjheath> i.e. it’s really not transparent yet
14:47:55 <alexchandel1> cjhealth: it makes sense for stack types, and for boxes
14:48:18 <alexchandel1> lifetime parameters and the task-local things are still weird
14:49:16 <alexchandel1> but since Haskell doesn't have explicit heap allocations, it could be completely transparent
14:57:05 <Hijiri> does safecopy and acid-state work properly with base 4.8? I'm getting role errors when using deriveSafeCopy
14:57:52 <Hijiri> nevermind, it was a different issue
15:24:09 <nerium> I’m trying to imlement the projection function in Haskell, but I’m stuck.
15:24:09 <nerium> https://gist.github.com/oleander/40f1490d4ae3a9c32af1
15:24:38 <nerium> The idea is to implement it using rec
15:26:10 <nerium> Any idea how this can be done?
15:26:31 <Taneb> I can't work out what you are trying to do
15:27:47 <merijn> You have a bunch of functions without definition and without description of what you're doing
15:28:36 <codygman> > putStrLn "Lambdabot, Am I connected?"
15:28:37 <lambdabot>  <IO ()>
15:29:28 <nerium> merijn: Sorry. I’m trying to implement the set of functions from primitive recursions
15:30:06 <nerium> One being the projection function
15:32:18 <merijn> That doesn't really help a lot, considering there's still 3 functions being defined there, none of which are actually used anywhere and the functions that are used don't have a definition
15:32:48 <chrisdone> is there an argument you can pass to ghci to stop it outputting colours?
15:36:30 <merijn> chrisdone: Wait, ghci outputs colour?
15:36:34 <merijn> Since when?
15:36:40 <merijn> How do I get it to do that? :>
15:37:06 <chrisdone> it looks like it's doing so:
15:37:08 <dibblego> merijn: http://www.reddit.com/r/haskell/comments/144biy/pretty_output_in_ghci_howto_in_comments/
15:37:12 <chrisdone> [?1h=
15:37:12 <chrisdone> [?1h=λ>
15:37:20 <mauke> that's not colors
15:37:23 <chrisdone> ^ those look like tty codes for either colors or bold or w/e
15:37:54 <chrisdone> mauke: do you know how to disable it?
15:38:25 <merijn> Indeed those don't look like ANSI colour escapes to me
15:38:33 <merijn> But I'll be damned if I know what escapes they are
15:38:48 <Koganei> hi all, I discovered functional programming three days ago and my mind is totally blown!
15:38:53 <mauke> huh. that looks like DECCKM
15:38:54 <shachaf> What you want is syntax highlightning that's lazy enough that it only reads one character at a time.
15:38:59 <chrisdone> possibly som e readline thing
15:39:02 <Koganei> wanted to share my excitement with people who'd understand :p
15:39:03 <shachaf> Like http://slbkbs.org/lazy-syntax.png
15:39:10 <dibblego> Koganei: welcome
15:39:20 <mauke> ESC [ ? 1 h  When set, the cursor keys send an ESC O prefix, rather than ESC [.
15:39:33 <Koganei> dibblego: hi!
15:39:44 <nerium> merijn: The other functions is there to easier understand what proj does
15:39:52 <Koganei> I'm a javascript developer, but I'm installing Haskell now to play around :)
15:39:57 <nerium> They’re just examples
15:40:00 <shachaf> Most syntax highlightning libraries aren't lazy enough.
15:40:12 <chrisdone> shachaf: you want a printer that doesn't care about characters =p
15:40:16 <chrisdone> like https://www.youtube.com/watch?v=4rcPfZveGZc
15:40:33 <merijn> chrisdone: How are you interacting with ghci that you're running into this?
15:40:39 <shachaf> s/ning/ing/
15:40:46 <merijn> i.e. what's the data being send over ?
15:41:23 <merijn> I would hope that ghci is smart and detects when it's talking to a pty and when it isn't....
15:41:53 <chrisdone> merijn: i'm running it: (1) via a pipe which (2) launches it inside a docker
15:42:06 <chrisdone> i expect it thinks it's in a terminal due to the docker launcher
15:42:19 <chrisdone> i guess i can make a script that pipes it to cat
15:42:43 <merijn> I know 0 about docker, so I can't help you with that
15:43:22 <merijn> piping to cat ಠ_ಠ
15:44:06 <merijn> Why isn't it talking to the pipe directly?
15:44:18 <chrisdone> this channel is full of disapproval, it oppresses me like a sheet of tarpaulin
15:44:49 <shachaf> merijn: Next you'll complain about writing (id . f)
15:47:53 <chrisdone> merijn: nevermind -- i suppose this is the kind of problem adding a unix domain socket to ghci will avoid
15:48:04 <merijn> chrisdone: \o/
15:52:41 <chrisdone> dibblego: do you have reddit links on speeddial?
15:53:26 <dibblego> chrisdone: no, I just came across it after your question.
15:53:39 <chrisdone> =)
15:54:13 <chrisdone> i'm thinking i can use TyThing from the ghc-api to re-implement Present http://hackage.haskell.org/package/present-1.1/docs/Present.html without needing the Data instance, and add it to ghci-ng
15:54:17 * chrisdone strokes beard
15:54:36 * hackagebot hasql 0.4.0 - A minimalistic general high level API for relational databases  http://hackage.haskell.org/package/hasql-0.4.0 (NikitaVolkov)
15:55:23 <chrisdone> as the DataCon type has Data.Data-like information: http://www.haskell.org/platform/doc/2013.2.0.0/ghc-api/DataCon.html
15:55:36 <chrisdone> on the other hand so does template-hakell's `reify'
15:56:07 <chrisdone> i'll try that
16:00:42 <chrisdone> holy awesome. TH can do this after all. it even crosses module boundaries
16:02:09 <chrisdone> http://chrisdone.com/th-forpresent.png ← check it
16:02:22 <chrisdone> X's constructors are unexposed but TH can access them. excellent
16:03:53 <chrisdone> this means we can implement a :present command that can convert a value to a lazy presentation
16:04:14 <chrisdone> without the author of the type having to derive any class or define anything
16:05:27 <tobiasgw> @chrisdone are you running ghc inside docker?
16:05:27 <lambdabot> Unknown command, try @list
16:05:47 <chrisdone> yeah
16:05:58 <tobiasgw> me too
16:06:04 <tobiasgw> or, ghcjs
16:06:46 <tobiasgw> are you running emacs inside docker too?
16:06:56 <chrisdone> nope
16:08:15 <tobiasgw> I'm trying to decide if I should install emacs inside the container or try to connect to ghc from the host
16:17:18 <codygman> For some reason with haskell-mode in emacs with a cabal sandbox I have to delete the dist folder and run cabal confiugre, then restart the haskell mode session before the repl will work. Anyone know why?
16:17:52 <chrisdone> codygman: depends on 'work'
16:18:01 <chrisdone> too vague to give a useful answer
16:21:49 <chrisdone> codygman: iow, what are you talking about?
16:23:48 <nerium> Could anyone help me implement the Pn (projection function) in haskell? http://i.imgur.com/vdifLcE.png
16:23:49 <nerium> Only using rec, and comp. I’ve been scratching my head for 2 days now, i’m getting nowhere
16:24:02 <dmj`> codygman: why would the repl not start if the dist folder is present? What error are you getting?
16:24:27 <athan> Would anyone happen to see why this isn't correct syntax? GHC is telling me it's seeing a syntax error from the `=` http://lpaste.net/115356
16:24:49 <athan> erp, nevermind ._.
16:24:52 <athan> found it
16:25:30 <HeladoDeBrownie> nerium, it's not implementable generally as-is. There is no general tuple indexing function in Haskell. There are some possible solutions but it depends on what you want.
16:26:27 <nerium> HeladoDeBrownie: I’m not allowed to use anything in haskell except rec and compo
16:26:31 <nerium> *comp
16:26:45 <HeladoDeBrownie> nerium, do you have those defined already? If so, what are their types?
16:27:06 <nerium> HeladoDeBrownie: Hold on
16:27:29 <nerium> HeladoDeBrownie: https://gist.github.com/oleander/40f1490d4ae3a9c32af1
16:28:42 <HeladoDeBrownie> nerium, ah, so you're using lists instead of tuples. Very well then. That won't allow you to distinguish the lengths of the lists at type level as that equation implies, but it's certainly doable.
16:28:56 <HeladoDeBrownie> nerium, what have you tried?
16:29:47 <HeladoDeBrownie> nerium, also your function will either have to be partial or return a Maybe value
16:30:41 <nerium> HeladoDeBrownie: It should raise an error if something goes worng
16:30:49 <nerium> HeladoDeBrownie: Here is what I’ve so far https://gist.github.com/oleander/c92d51cf874c5bae5950
16:30:53 <HeladoDeBrownie> That'd be the first alternative I mentioned then.
16:31:28 <nerium> That’s like version 105. I’ve tried of bunch of stuff on the whitebord without getting anywhere
16:32:38 <HeladoDeBrownie> selectElem does not type check
16:32:55 <HeladoDeBrownie> (x:xs) :: [Int] → xs :: [Int]
16:33:08 <nerium> HeladoDeBrownie: Yeah, sorry. That’s right
16:33:09 <HeladoDeBrownie> Sorry, arrow is confusing :P I mean "implies"
16:33:26 <nerium> I can’t run it as ”compose” isn’t defined
16:33:45 <HeladoDeBrownie> Can you define compose?
16:35:44 <HeladoDeBrownie> ("Can" in the sense of "Do you know how to" or "Are you permitted to")
16:37:00 <nerium> Darn, my machine dided. What did you say again?
16:37:12 <HeladoDeBrownie> Do you know how to and/or are you permitted to define compose?
16:38:52 <nerium> HeladoDeBrownie: I know it it suppose to work, but not how to define it
16:41:10 <Welkin> > t: fmap . fmap . fmap .fmap . fmap
16:41:12 <lambdabot>  Couldn't match expected type ‘[Debug.SimpleReflect.Expr.Expr]’
16:41:12 <lambdabot>              with actual type ‘(a0 -> b0)
16:41:12 <lambdabot>                                -> f0 (f1 (f2 (f3 (f4 a0)))) -> f0 (f1 (f2 (f3...
16:41:26 <Welkin> > t: (fmap . fmap . fmap .fmap . fmap)
16:41:27 <lambdabot>  Couldn't match expected type ‘[Debug.SimpleReflect.Expr.Expr]’
16:41:27 <lambdabot>              with actual type ‘(a0 -> b0)
16:41:27 <lambdabot>                                -> f0 (f1 (f2 (f3 (f4 a0)))) -> f0 (f1 (f2 (f3...
16:41:37 <Welkin> > t: fmap . fmap . fmap . fmap . fmap
16:41:39 <lambdabot>  Couldn't match expected type ‘[Debug.SimpleReflect.Expr.Expr]’
16:41:39 <lambdabot>              with actual type ‘(a0 -> b0)
16:41:39 <lambdabot>                                -> f0 (f1 (f2 (f3 (f4 a0)))) -> f0 (f1 (f2 (f3...
16:41:46 <Welkin> :t fmap . fmap . fmap . fmap . fmap
16:41:47 <lambdabot> (Functor f4, Functor f3, Functor f2, Functor f1, Functor f) => (a -> b) -> f (f1 (f2 (f3 (f4 a)))) -> f (f1 (f2 (f3 (f4 b))))
16:41:48 <Welkin> oops
16:45:45 <HeladoDeBrownie> nerium, are there any restrictions on how you need to define that one? If not, there's already a compose in the Prelude, (.)
16:46:26 <HeladoDeBrownie> nerium, that's assuming it's the usual function we mean when we say compose. Although if it is then I'm confused why you pass ident to it
16:46:39 <HeladoDeBrownie> nerium, so, I guess, how is it supposed to work as far as you know?
16:46:55 <codygman> dmj`, chrisdone: It basically tells me that the libraries needed aren't available. I don't have time to make a minimal repro right now though. I was hoping this was a common issue with a common solution which is why I tossed the vague problem description out.
16:47:05 <nerium> HeladoDeBrownie: Like this
16:47:05 <nerium> P(5)[1,2,3,4,5] => 5
16:47:20 <HeladoDeBrownie> nerium, no, the compose function that you're using but said you don't have defined
16:48:30 <nerium> HeladoDeBrownie: Aha.
16:48:31 <nerium> compose(g,[h, e])[1,2] => g(h([1,2]), e([1,2])
16:50:54 <FireFly> Note that Haskell doesn't use the syntax f(x,y) for function invocation
16:51:14 <nerium> FireFly: That was more math then haskell
16:51:19 <FireFly> Aha
17:00:09 <HeladoDeBrownie> nerium, sorry, something came up and I've gotta go. Good luck solving this
17:00:34 <nerium> HeladoDeBrownie: Thanks for you help so far
17:01:28 <dmj`> can test projects be libraries ? Or just produce an executable..
17:01:38 <dmj`> can test projects be documented basically
17:04:31 <ReinH> tests do produce an executable
17:04:40 <ReinH> that's how they are run
17:18:45 <Aruro> >fromIntegral (100/10)
17:18:59 <Aruro> > fromIntegral (100/10)
17:19:01 <lambdabot>  Could not deduce (GHC.Real.Integral a0)
17:19:01 <lambdabot>    arising from a use of ‘GHC.Real.fromIntegral’
17:19:01 <lambdabot>  from the context (GHC.Num.Num b)
17:19:01 <lambdabot>    bound by the inferred type of it :: GHC.Num.Num b => b at Top level
17:19:01 <lambdabot>  The type variable ‘a0’ is ambiguous
17:19:11 <Aruro> > fromIntegral 100/10
17:19:12 <lambdabot>  10.0
17:19:17 <Aruro> why?
17:19:27 <Welkin> why what?
17:19:30 <Hermit> :t (/)
17:19:31 <lebesgue> Aruro: Difference in precedence?
17:19:32 <lambdabot> Fractional a => a -> a -> a
17:19:35 <Aruro> ok
17:19:39 * hackagebot hsc3-data 0.15 - haskell supercollider data  http://hackage.haskell.org/package/hsc3-data-0.15 (RohanDrape)
17:20:01 <Aruro> so / is weaker than function application?
17:20:34 <Welkin> everything is lower precedence than function application
17:20:46 <Welkin> unless you mean ($)
17:21:01 <Hermit> he doesn't
17:21:08 <Aruro> no i dont :)
17:21:14 <Aruro> but good to know
17:21:14 <ReinH> Nearly everything.
17:24:13 <a_total_newbie> will someone help me out with this? http://lpaste.net/522302361457131520
17:26:45 <Aruro> fractional is considered Integral type?
17:27:21 <johnw> a_total_newbie: you're missing a closing paren on the line before
17:27:21 <benzrf> Aruro: i should hope not
17:27:23 <hexagoxel_> a_total_newbie: in the lines above: word vs Word
17:28:34 <a_total_newbie> hexagoxel: thanks for pointing that out: however, that doesn't seem to solve the parse error
17:28:38 <a_total_newbie> johnw: where at?
17:28:42 <hexagoxel_> (but yes, johnw points out the real problem)
17:28:50 <hexagoxel_> "pos (xis) (length (head (recebeTab t))"
17:28:59 <Welkin> @src Fractional
17:28:59 <lambdabot> class (Num a) => Fractional a where
17:28:59 <lambdabot>     (/)          :: a -> a -> a
17:29:00 <lambdabot>     recip        :: a -> a
17:29:00 <lambdabot>     fromRational :: Rational -> a
17:29:05 <a_total_newbie> ah yup
17:29:07 <a_total_newbie> saw it, thanks
17:29:12 <Welkin> @Integral
17:29:12 <lambdabot> Unknown command, try @list
17:29:15 <Welkin> @src Integral
17:29:16 <lambdabot> class (Real a, Enum a) => Integral a where
17:29:16 <lambdabot>     quot, rem, div, mod :: a -> a -> a
17:29:16 <lambdabot>     quotRem, divMod :: a -> a -> (a,a)
17:29:16 <lambdabot>     toInteger       :: a -> Integer
17:29:50 <Aruro> Welkin: ty
17:30:09 <Aruro> > (55 `mod` 10) / 10
17:30:10 <lambdabot>  No instance for (GHC.Show.Show a0)
17:30:10 <lambdabot>    arising from a use of ‘M61736883292478221518212.show_M61736883292478221518...
17:30:10 <lambdabot>  The type variable ‘a0’ is ambiguous
17:30:10 <lambdabot>  Note: there are several potential instances:
17:30:10 <lambdabot>    instance [safe] GHC.Show.Show
17:30:22 <Aruro> i guess my problem is here :)
17:30:30 <Welkin> :t mod
17:30:31 <lambdabot> Integral a => a -> a -> a
17:30:38 <Welkin> :t (/)
17:30:39 <lambdabot> Fractional a => a -> a -> a
17:30:56 <Aruro> so numerator is not fractional?
17:31:29 <Welkin> > fromIntegral (55 `mod` 10) / 10
17:31:30 <lambdabot>  0.5
17:31:38 <Aruro> yes, was just typing that :)
17:31:40 <Aruro> ty
17:32:16 <Aruro> >:t 5
17:32:23 <Welkin> just t:
17:32:31 <Aruro> :t 5
17:32:32 <lambdabot> Num a => a
17:32:33 <Welkin> er, :t
17:32:49 <Aruro> aaa so 5 is not Integer either :D
17:32:51 <Aruro> nice
17:32:56 <Aruro> converted on the fly
17:33:03 <Welkin> not converted
17:33:07 <Welkin> just infered
17:33:11 <Aruro> k
17:33:16 <Welkin> :t 5 (:: Int)
17:33:17 <lambdabot> parse error on input ‘::’
17:33:24 <Welkin> :t (5 :: Int)
17:33:25 <lambdabot> Int
17:33:29 <Welkin> heh, of course
17:33:58 <Aruro> can the result of function be Num?
17:34:06 <Welkin> Num is a typeclass
17:34:12 <Welkin> it is a constraint on the type
17:34:15 <Welkin> not a type itself
17:34:23 <Aruro> so strictly speaking 5 has no type?
17:34:42 <Aruro> or 6 for that matter
17:34:46 <Welkin> well, it has whatever type is infered for it
17:34:56 <Welkin> or you can explicity delcare it as Int, Integer, etc
17:35:08 <Aruro> interesting
17:35:26 <Welkin> > (5 :: Int) / (2 :: Int)
17:35:28 <lambdabot>  No instance for (GHC.Real.Fractional GHC.Types.Int)
17:35:28 <lambdabot>    arising from a use of ‘GHC.Real./’
17:35:38 <Welkin> > (5 :: Int) `div` (2 :: Int)
17:35:40 <lambdabot>  2
17:35:55 <Welkin> > (5 :: Int) / (2 :: Double)
17:35:56 <lambdabot>  Couldn't match expected type ‘GHC.Types.Int’
17:35:56 <lambdabot>              with actual type ‘GHC.Types.Double’
17:35:59 <Welkin> > (5 :: Double) / (2 :: Double)
17:36:01 <lambdabot>  2.5
17:36:07 <Welkin> or just
17:36:14 <Welkin> > 5.0 / 2.0
17:36:15 <lambdabot>  2.5
17:36:56 <Aruro> so in reality 2 / 10 is not same as (12 `mod` 10) / 10 , second having a different type
17:36:57 <Welkin> use div for integer division
17:37:13 <Welkin> :t 2 / 10
17:37:14 <lambdabot> Fractional a => a
17:37:15 <Aruro> :t div
17:37:16 <lambdabot> Integral a => a -> a -> a
17:37:20 <Welkin> :t (12 `mod` 10) / 10
17:37:21 <lambdabot> (Integral a, Fractional a) => a
17:37:50 <Welkin> :t (12.0 `mod` 10.0) / 10.0
17:37:52 <lambdabot> (Integral a, Fractional a) => a
17:37:55 <Welkin> > (12.0 `mod` 10.0) / 10.0
17:37:57 <lambdabot>  No instance for (GHC.Show.Show a0)
17:37:57 <lambdabot>    arising from a use of ‘M200661113144054823618451.show_M2006611131440548236...
17:37:57 <lambdabot>  The type variable ‘a0’ is ambiguous
17:37:57 <lambdabot>  Note: there are several potential instances:
17:37:57 <lambdabot>    instance [safe] GHC.Show.Show
17:38:05 <Welkin> > (12 `mod` 10) / 10.0
17:38:07 <lambdabot>  No instance for (GHC.Show.Show a0)
17:38:07 <lambdabot>    arising from a use of ‘M18587244625365477418463.show_M18587244625365477418...
17:38:07 <lambdabot>  The type variable ‘a0’ is ambiguous
17:38:07 <lambdabot>  Note: there are several potential instances:
17:38:07 <lambdabot>    instance [safe] GHC.Show.Show
17:38:10 <Welkin> heh
17:38:13 <Aruro> :)
17:38:19 <Aruro> yep
17:38:25 <Aruro> funny problem
17:38:35 <Welkin> > fromIntegral (12 `mod` 10) / 10.0
17:38:37 <lambdabot>  0.2
17:38:38 <Welkin> that is the solution
17:38:45 <Aruro> somehow it can not infere types correctly here
17:38:46 <Welkin> use fromIntegral
17:38:52 <Welkin> no
17:38:54 <Aruro> i do use it yes
17:38:57 <Welkin> the types are infered correctly
17:39:04 <Welkin> it is a programmer error
17:39:09 <Aruro> why?
17:39:11 <Welkin> :t mod
17:39:12 <lambdabot> Integral a => a -> a -> a
17:39:16 <Welkin> :t (/)
17:39:17 <lambdabot> Fractional a => a -> a -> a
17:39:19 <Aruro> what is wrong with that original formula?
17:39:28 <Aruro> well
17:39:38 <Welkin> mod produced a type that is an instance of Integral
17:39:40 <Aruro> fractional can be easily infered from integer
17:39:51 <Welkin> (/) takes a type that is an instance of Fractional
17:39:53 <Welkin> they are not the same
17:39:54 <Aruro> Integral
17:40:06 <batchm> :t 2e6
17:40:07 <lambdabot> Fractional a => a
17:40:10 <Aruro> so the question remains why?
17:40:26 <Aruro> they are not same
17:40:51 <batchm> why is 2e6 Fractional and not Num?
17:41:10 <Aruro> i have no idea :)
17:41:10 <Welkin> @src Num
17:41:10 <batchm> :t 2000000
17:41:10 <lambdabot> class  (Eq a, Show a) => Num a  where
17:41:10 <lambdabot>     (+), (-), (*)       :: a -> a -> a
17:41:10 <lambdabot>     negate, abs, signum :: a -> a
17:41:10 <lambdabot>     fromInteger         :: Integer -> a
17:41:11 <lambdabot> Num a => a
17:41:15 <batchm> :t 2e6
17:41:16 <lambdabot> Fractional a => a
17:41:37 <Welkin> Fractional can be represented as a numerator and a denominator
17:41:41 <Welkin> Num is not
17:41:49 <hexagoxel_> :t 2e-2
17:41:50 <lambdabot> Fractional a => a
17:41:52 <batchm> what?
17:41:58 <Aruro> is there any use of that ? i mean the fractional type?
17:42:08 <Welkin> :t 100 % 9
17:42:08 <hexagoxel_> because with scientific notation, you can write non-integers
17:42:10 <lambdabot> Integral a => Ratio a
17:42:11 <batchm> hexagoxel that is not 2e6 though
17:42:38 <Welkin> https://www.haskell.org/tutorial/numbers.html
17:42:40 <johnw> Aruro: fractional types can be represented as floating-point numbers on the CPU, which makes for some very fast approximation computations
17:42:45 <Aruro> technically speaking 5 is also fractional
17:42:47 <Aruro> 5/1
17:42:51 <hexagoxel_> yeah, but the compiler does not decide depending on the specific value; it looks at the type of literal
17:42:57 <Aruro> actually even scientifically speaking :)
17:43:25 <Aruro> so mod giving Integral and not fractional is interesting
17:43:58 <Aruro> >  5.2 `mod` 3
17:44:00 <lambdabot>  No instance for (GHC.Show.Show a0)
17:44:00 <lambdabot>    arising from a use of ‘M679314638342454315818595.show_M6793146383424543158...
17:44:00 <lambdabot>  The type variable ‘a0’ is ambiguous
17:44:00 <lambdabot>  Note: there are several potential instances:
17:44:00 <lambdabot>    instance [safe] GHC.Show.Show
17:44:05 <Aruro> >  5.2 `mod` 3.0
17:44:07 <lambdabot>  No instance for (GHC.Show.Show a0)
17:44:07 <lambdabot>    arising from a use of ‘M10609622570751221118620.show_M10609622570751221118...
17:44:07 <lambdabot>  The type variable ‘a0’ is ambiguous
17:44:08 <lambdabot>  Note: there are several potential instances:
17:44:10 <lambdabot>    instance [safe] GHC.Show.Show
17:44:26 <Welkin> http://book.realworldhaskell.org/read/using-typeclasses.html#numerictypes.funcs
17:44:35 <batchm> :t 10^6
17:44:36 <lambdabot> Num a => a
17:44:36 <Welkin> that is a helpful table of all the numeric types and functions
17:44:43 <batchm> :t 10^(-6)
17:44:44 <lambdabot> Num a => a
17:44:47 <Aruro> ty! :) im reading that book now
17:44:49 <batchm> > 10^(-6)
17:44:51 <lambdabot>  *Exception: Negative exponent
17:44:57 <Aruro> :t mod
17:44:58 <lambdabot> Integral a => a -> a -> a
17:45:00 <batchm> more weirdness
17:45:10 <Aruro> wooa
17:45:24 <Aruro> that is bug :)
17:45:28 <johnw> why is that a bug?
17:45:42 <Aruro> clearly not in agreement with scientific notation
17:45:42 <Welkin> it is not a bug
17:46:09 <batchm> 10^(-6) is well defined in math
17:46:16 <Welkin> > 10 ^^ (-10)
17:46:17 <lambdabot>  1.0e-10
17:46:17 <batchm> why would it throw exception?
17:46:21 <Aruro> what is it? (*my favorite question*)
17:46:25 <Welkin> it needs to be non-negative
17:46:28 <hexagoxel_> :t (^)
17:46:29 <lambdabot> (Num a, Integral b) => a -> b -> a
17:46:36 <Welkin> please see the table I posted
17:46:44 <Welkin> ^^ is for *any* integral exponent
17:46:50 <Welkin> ^ is for non-negative integrals
17:46:54 <Welkin> ** is for fractionals
17:47:00 <batchm> it is obvious it needs to be non-negative.. does make it any less fucking stupid
17:47:11 <Welkin> > 10 ^^ (-10)
17:47:13 <lambdabot>  1.0e-10
17:47:45 <Aruro> how did you type that ?
17:48:13 <Welkin> http://book.realworldhaskell.org/read/using-typeclasses.html#numerictypes.funcs
17:48:44 <Aruro> no it shows a smile in the middle of expression for e to minus ten
17:48:50 <batchm> why do we need both ^ and ^^?
17:48:58 <johnw> :t (^)
17:48:59 <lambdabot> (Num a, Integral b) => a -> b -> a
17:49:01 <johnw> :t (^^)
17:49:01 <dfeuer> Welkin, as far as I'm concerned, (**) is really for complex numbers, but works okay if the base is non-negative.
17:49:02 <lambdabot> (Integral b, Fractional a) => a -> b -> a
17:49:11 <dfeuer> Don't use it otherwise.
17:49:38 <batchm> this is horrible
17:49:39 <dfeuer> (non-negative real, I mean)
17:49:45 <Aruro> so we can formulate feature more clearly some expressions being fed just integer numbers will give error
17:49:57 <Aruro> being perfectly fine mathematically
17:50:12 <Welkin> then use ^^
17:50:26 <dfeuer> We need ^^ and ^ because ^^ only makes sense if the result can be fractional.
17:51:04 <a_total_newbie> guys, how would you convert this into a function with guards? following the exact same structure, without using high-order functions (keep the same pattern). I'm trying to come up with an alternative to that using guards, however I'm already in tilt mode since it's 2AM... http://lpaste.net/6878853396896415744
17:51:08 <dfeuer> What makes less sense is that the second arguments of ^ and ^^ are so polymorphic.
17:51:14 <dfeuer> They should really be Int.
17:51:49 <dfeuer> a_total_newbie, before  I answer that, I'd like to know why you want to know.
17:52:05 <Aruro> :t 5
17:52:06 <lambdabot> Num a => a
17:52:13 <Aruro> :t 4.1
17:52:14 <lambdabot> Fractional a => a
17:52:18 <Aruro> hm
17:52:24 <Aruro> :t 4.0001
17:52:25 <lambdabot> Fractional a => a
17:52:39 <Aruro> it does not want to say type :)
17:52:40 <Welkin> a_total_newbie: just replace the ifs with |
17:52:52 <Welkin> but that is not a good way to write your function
17:52:52 <Aruro> :t 2*2
17:52:53 <lambdabot> Num a => a
17:53:05 <Aruro> :t 2+2
17:53:07 <lambdabot> Num a => a
17:53:09 <batchm> so we have three different exponential functions
17:53:15 <johnw> :t 2+2 :: Int
17:53:15 <Welkin> Aruro: that is because it could be Float, Double, etc
17:53:16 <lambdabot> Int
17:53:24 <batchm> > 10^6
17:53:25 <a_total_newbie> dfeuer: I'm trying to make my code simpler, and using the 'if -> then -> else' pattern doesn't really fit my style. It's around 200 lines of code I've made solely using guards, however I could not come with a solution to this one and I had to make use of if -> then -> else, as it was the only way my brain could process with
17:53:25 <lambdabot>  1000000
17:53:26 <batchm> > 10^^6
17:53:26 <Welkin> :t 4.0000001 :: Double
17:53:27 <lambdabot> Double
17:53:27 <lambdabot>  1000000.0
17:53:29 <batchm> > 10**6
17:53:30 <lambdabot>  1000000.0
17:53:32 <batchm> this is sane?
17:53:49 <johnw> it seems to be Rail Against The Numeric Hierarchy Day
17:53:53 <Welkin> what is sane?
17:53:56 <johnw> where is carter
17:53:59 <Aruro> :D
17:54:02 <carter> johnw: whats up
17:54:06 <johnw> carter ^^
17:54:10 <carter> johnw: wann know my 2 step plan?
17:54:15 <johnw> people are going crazy about numbers in Haskell
17:54:20 <carter> a) finish numerical and have it be fabulously successful
17:54:26 <Welkin> a_total_newbie: break it up into smaller functions and declare them in a where clause or let statements
17:54:34 <Aruro> yes we are :)
17:54:35 <carter> b) in rage make my own math replude
17:54:45 <carter> johnw: thing is, theres no such thing as a good abstraction
17:54:49 <carter> for that
17:54:55 <carter> or at least a one true™ abstraction
17:54:59 <carter> at least yet
17:55:12 <Aruro> :t 5/10
17:55:13 <lambdabot> Fractional a => a
17:55:20 <Aruro> :t 5 `mod` 10
17:55:21 <johnw> easy: just use a higher-order abstraction over many abstractions
17:55:21 <lambdabot> Integral a => a
17:55:37 <hexagoxel> a_total_newbie: have you looked at the hlint suggestions below the paste?
17:55:41 <a_total_newbie> Welkin: I've tried that way, however and when I try to compile it, ghc shows me quite a bunch of type errors. might just be my brain that's too tired to think right now, hence my request for how you guys would solve it
17:55:44 <marchelzo_> Is there a way to have overloaded character literals, like 'a' :: Word8 == 97?
17:55:45 <dfeuer> a_total_newbie, the first step (for standard Haskell) is to turn the thing into a trivial "case" expression.  validadePos t = case () of _ | whatever -> foo; | somethingelse -> bar ....
17:55:47 <Aruro> is there any math function with will not feed me typeclass as answer?
17:55:53 <Welkin> a_total_newbie: then just fix them
17:56:00 <johnw> Aruro: you're asking lambdabot, so the type is not fixed
17:56:04 <Welkin> that is the point of the type errors, so you can fix them easily
17:56:05 <carter> Aruro: ghci in >= 7.8 has mono morphism disabled
17:56:31 <carter> Aruro: in GHC when used as a compiler, or ghci with :seti -XNoMonomorphismRestriction
17:56:35 <carter> it'll have a concrete type
17:56:39 <johnw> Aruro: in your own code, unless you are writing generic algorithms, there will be a numerical type involved
17:56:52 <Aruro> yes
17:56:54 <carter> and when you ask for an answer, i'tll default ot nice things
17:57:03 <carter> etc etc
17:57:03 <dfeuer> Welkin, that's not the right answer this time, I don't think. HLint is giving suggestions that don't look so useful (just yet).
17:57:03 <Aruro> but here it keeps throwing at me typeclasses
17:57:07 <Aruro> refusing to make types
17:57:11 <carter> Aruro: did you read what i said?
17:57:13 <johnw> Aruro: add a type annotation
17:57:16 <carter> johnw: no
17:57:18 <carter> he should do
17:57:36 <Aruro> yes ty
17:57:37 <carter> :seti -XNoMonomorphismRestriction
17:57:40 <johnw> well, adding a type annotation will work too
17:57:42 <batchm> why would he do that
17:57:44 <Aruro> i read now what you said carter
17:57:48 <carter> Aruro: try it
17:57:56 <carter> it does wind up depending on type defaulting
17:58:03 <carter> so it'll not "work" for fancier stuff
17:58:11 <carter> FFF
17:58:13 <carter> Aruro: woooops
17:58:15 <carter> i means
17:58:20 <carter> :seti -XMonomorphismRestriction
17:58:23 <carter> for learning times
17:58:37 <Aruro> what monomorphism mean?
17:58:43 <carter> Aruro: dont worry about it
17:58:46 <Aruro> it will always try to give one type?
17:58:49 <carter> try it
17:58:57 <Aruro> wait
17:59:11 <batchm> why are you suggesting that.. either he is just curious and wondering if any math function is defined with concrete types.. or he does not know how typeclasses work. XNoMonomorphismRestriction does not seem helpful in either case
17:59:25 <carter> a) i suggested the wrong thing
17:59:27 <carter> b) i'm tired
17:59:34 <dfeuer> Also for learning times, turn off defaulting.
17:59:38 <marchelzo_> I'm indexing a ByteString and I want to compare the Word8 to various character literals, how can I do this without unsafeCoerce or any other runtime conversions? I know all of the Word8 values at compile time, I just want the syntax like b `index` i == 'a'.
17:59:46 <carter> i'll stop trying to hlep
17:59:50 <carter> i'm confusing myself righ tnow :)
17:59:54 <Aruro> batchm i know what typeclasses are
17:59:57 <Welkin> a_total_newbie: you could also just use a Maybe monad for that...
17:59:57 <dfeuer> marchelzo_, Word8 is not a character.
18:00:06 <Aruro> and i do wonder why functions have no type
18:00:07 <Welkin> it will propogate your "False" as a Nothing automatically
18:00:15 <carter> .... functions have types
18:00:21 <marchelzo_> dfeuer: I know that it is not a character. But every Char has a corresponding Word8 value.
18:00:23 <Aruro> @src mod
18:00:23 <lambdabot> Source not found. My pet ferret can type better than you!
18:00:27 <Welkin> a_total_newbie: have you read any basic haskell books yet? Such as LYAH?
18:00:29 <dfeuer> marchelzo_, that is simply not true.
18:00:30 <carter> marchelzo_: fase
18:00:35 <carter> sooo false
18:00:40 <Aruro> @src (mod)
18:00:41 <marchelzo_> Oh
18:00:41 <lambdabot> Source not found. Do you think like you type?
18:00:41 <carter> Char takes up >= 32bits
18:00:52 <a_total_newbie> Welkin: Yes, I have
18:00:55 <Aruro> lol lambdabot jokes at me :D
18:01:00 <dfeuer> A Char is actually 32 or 64 bits, but you should think of it as 21 bits.
18:01:04 <carter> yeah
18:01:05 <marchelzo_> Ok well then every Word8 has a corresponding Char
18:01:07 <dfeuer> A Word8 is 8 bits.
18:01:07 <Aruro> @src (*)
18:01:07 <lambdabot> Source not found. I don't think I can be your friend on Facebook anymore.
18:01:14 <Aruro> lol :D
18:01:24 <Aruro> lets see how many jokes he has
18:01:28 <Aruro> @src (/)
18:01:28 <lambdabot> Source not found. My brain just exploded
18:01:35 <Aruro> @src (+)
18:01:35 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
18:01:44 <Aruro> @src (:)
18:01:44 <lambdabot> Source not found. I am sorry.
18:01:52 <Aruro> ok sorry seems not a joke
18:02:01 <marchelzo_> instead of b `index` i == 97, I'd like to be able to use just 'a'. It seems like a reasonable thing to want to be able to do.
18:02:45 <Aruro> :t mod
18:02:46 <lambdabot> Integral a => a -> a -> a
18:02:59 <Aruro> so mod is polimorphic?
18:03:07 <Aruro> am I correct here?
18:04:09 <Aruro> :t (1::Integer)
18:04:11 <lambdabot> Integer
18:04:15 <Aruro> :t (1::Int)
18:04:16 <lambdabot> Int
18:04:21 <zwer> mod is part of the Integral class. each Integral instance defines its own mod
18:04:26 <Welkin> you are declaring the type
18:04:27 <marchelzo_> I realized I can just use Data.ByteString.Char8 instead.
18:04:36 <Aruro> yes that i know
18:04:49 <Aruro> so mod is polimorphic on two types? Int and Integer
18:05:19 <Welkin> anything that is an instance of Integral
18:05:30 <Welkin> you can create your own type and make it an instance of Integral
18:05:33 <zwer> there are more than two Integral types. and you could even define your own, if for whatever reason you wanted
18:05:46 <dfeuer> marchelzo_, why are you trying to do this?
18:05:48 <Aruro> yes seem logical
18:05:52 <Aruro> :t sin
18:05:53 <lambdabot> Floating a => a -> a
18:06:02 <LordBrain> hmm i vaguely recall some ancient haskell or haskell predecessors not standardizing main as having type IO ()
18:06:31 <marchelzo_> dfeuer: Because ByteString has O(1) indexing and the only characters I'm representing are in ASCII.
18:06:51 <dfeuer> Aha.
18:07:19 <dfeuer> marchelzo_, then you want functions like ord, chr, and fromIntegral.
18:07:33 <marchelzo_> But those work at run time.
18:07:33 <Welkin> > ord "∫"
18:07:34 <lambdabot>  Couldn't match expected type ‘GHC.Types.Char’
18:07:34 <lambdabot>              with actual type ‘[GHC.Types.Char]’
18:07:37 <Welkin> > ord '∫'
18:07:39 <lambdabot>  8747
18:07:55 <merijn> LordBrain: Main doesn't have type IO ()
18:08:13 <merijn> LordBrain: The report specifies that any value of type "IO a" is accepted
18:08:19 <LordBrain> oh
18:08:27 <merijn> "IO String" should work just fine with GHC, for example
18:08:50 <LordBrain> but it doesnt do anything wiht that value, so that's kind of like false advertising
18:08:56 <LordBrain> right?
18:09:25 <merijn> It's not false advertising, but yes nothing happens with that value
18:09:30 <LordBrain> maybe it should automatically print the value
18:09:48 <merijn> People commonly use "IO ()" to avoid accidentally throwing away results
18:09:48 <marchelzo_> It'd be neat if you could have main :: IO Int and return an exit code
18:10:11 <LordBrain> i think some compiler actually did that marchelzo_
18:10:16 <LordBrain> in the past
18:10:23 <LordBrain> does uhc do it?
18:10:37 <merijn> marchelzo_: You can just use System.Exit for exit codes
18:11:06 <merijn> marchelzo_: Windows doesn't really have a notion of exit codes, afaik
18:11:11 <batchm> yes it does
18:11:35 <LordBrain> i think it would neater to actually use main :: (IsString s, Show a) String s -> IO a, and actually wrap the whole program in a getContents and print :)
18:11:40 <marchelzo_> dfeuer: Did you mean that if I use those functions, they'll be optimized at compile time?
18:11:46 <merijn> LordBrain: That would be terrible
18:11:58 <LordBrain> well it is optional so, its not so awful really
18:12:24 <LordBrain> i guess it might mess up module testing some how, let me think.... no can't think it would be an issue
18:13:23 <Aruro> i read the types of math functions in Real World haskell table 6.2 and 6.3
18:13:36 <Aruro> and i have a question why Integer is not an instance of Fractional?
18:13:59 <merijn> Aruro: Because Fractional is the typeclass for types that can represent fractional values and Integer, by definition, can't?
18:13:59 <shachaf> Because the operations don't make sense for it.
18:14:14 <dfeuer> marchelzo_, it depends. ord and chr and fromIntegral with those types are *very* cheap.
18:14:22 <Aruro> 5==5/1
18:14:27 <Aruro> it is clearly fractional
18:14:29 <ReinH> Aruro: the reciprocal of 5 is not an Integer
18:14:53 <marchelzo_> dfeuer: ah ok, so I shouldn't use Data.ByteString.Char8?
18:15:05 <ReinH> :t recip
18:15:06 <lambdabot> Fractional a => a -> a
18:15:09 <batchm> Aruro and 5/2 ?
18:15:10 <merijn> Aruro: The fact that *some* fractional values are whole numbers doesn't mean all fractional values are whole numbers...
18:15:20 <Aruro> 5/2 is not 5
18:15:27 <merijn> Aruro: Exactly
18:15:29 <Aruro> and 5/2 is also fractional
18:15:34 <ReinH> :t (/)
18:15:35 <lambdabot> Fractional a => a -> a -> a
18:15:35 <batchm> what integral value is it?
18:15:37 <merijn> Aruro: So how could Integer be fractional?
18:15:41 <ReinH> (/) and recip must both be closed
18:15:47 <ReinH> which is not possible for Integer
18:15:49 <Aruro> it is subset of fractional like in math
18:16:10 <ReinH> That is true, but that's not compatible with the Haskell definition of Fractional
18:16:18 <LordBrain> well if you have some weird scheme you can actually make your own instance of Fractional for Integer, but i think most experienced haskellers would tell you if you are going to do that, then you probably want to use a newtype
18:16:25 <shachaf> Haskell doesn't have subsets, and that's not how type classes work.
18:16:39 <dfeuer> marchelzo_, I don't know what you should or shouldn't do :-)
18:16:46 <merijn> LordBrain: No, most experienced haskellers will form a lynch mob :)
18:16:47 <ReinH> LordBrain: you can't make a legal instance of Fractional
18:16:47 <shachaf> "Integer is an instance of Fractional" means you have a function (/) :: Integer -> Integer -> Integer
18:16:54 <ReinH> because Integer is not closed under (/) and recip
18:17:17 <ReinH> recip 5 is not an Integer, and neither ofc is 1/5
18:17:24 <Aruro> correct
18:17:29 <Aruro> there should be no integer
18:17:32 <Aruro> only fractional
18:17:35 <Aruro> that what im saying
18:17:38 <merijn> Why?
18:17:49 <ReinH> Aruro: Have you read anything I've said so far?
18:18:00 <Aruro> that is closed under (/)
18:18:05 <merijn> ReinH: He's saying that we shouldn't use Integer and just use Double for everything
18:18:10 <ReinH> What.
18:18:15 <merijn> ReinH: Exactly
18:18:17 <LordBrain> yes, well you won't be arrested. And mathematicians redefine symbols all the time, so who is to say you cant use some totally weird definitions for things.
18:18:31 <Aruro> why totally weird?
18:18:45 <Aruro> if i open math book it it will tell me 5 is fractional
18:18:51 <ReinH> Aruro: No it won't.
18:19:03 <Aruro> yes it will, read continuous fractions
18:19:03 <ReinH> How could it possibly
18:19:12 <LordBrain> it will tell you it is a rational number yes, but that's not what the class implies
18:19:12 <Welkin> Aruro: haskell is not mathematics
18:19:27 <Aruro> numbers are :)
18:19:28 <ReinH> Aruro: There are different nunmber systems
18:19:40 <ReinH> 5 is not a fractional number if it is a peano number
18:19:42 <ReinH> come on
18:20:01 <ReinH> "5 is fractional" doesn't even mean anything
18:20:06 <ReinH> since it doesn't sufficiently define "5"
18:20:07 <Aruro> 5/1
18:20:12 <Aruro> man denominator is 1
18:20:19 <LordBrain> doesnt sufficiently define fractional either
18:20:30 <Aruro> dull denominator
18:20:32 <Aruro> that is it
18:20:36 <ReinH> what
18:20:42 <ReinH> You are making less and less sense
18:20:52 <LordBrain> well you know what his confusion is
18:20:58 <LordBrain> so don't act like he is from mars
18:21:14 <ReinH> I actually don't.
18:21:19 <Aruro> every  non real number is a fraction
18:21:30 <ReinH> No.
18:21:33 * ReinH sighs
18:21:35 <Aruro> and non irrational :D
18:21:38 <ReinH> No.
18:21:56 <Aruro> did you read continuous fractions as i told you?
18:22:01 <merijn> ReinH: You do realise this is an exercise in futility, no?
18:22:04 <LordBrain> he just got out of calculus or whatever, and he's only dealing with reals, and using subsets of the reals for everything, and its not as if that's not a commonly done thing.
18:22:06 <ReinH> merijn: yep
18:22:21 <Aruro> ty Lord
18:22:49 <ReinH> In a universe where the only numbers are real numbers, it's certainly true that all non-irrational numbers are rational
18:22:57 <ReinH> But math isn't that universe, and neither is Haskell
18:23:35 <batchm> math is serious business
18:23:45 <Aruro> yeah i made mistake above, u got my point
18:24:11 <ReinH> I do. If all numbers in Haskell were rational, they would all be rational.
18:24:41 <LordBrain> some simple languages literally do use floating points for everything
18:24:48 <Aruro> so lets turn around our argument, why do i need a troublesome integer?
18:24:54 <LordBrain> take javascript i think
18:25:08 <jamesmradoom> question: do all functions in haskell have to return a value?
18:25:14 <ReinH> jamesmradoom: yes
18:25:25 <Welkin> Aruro: integer division is implemented by `div`
18:25:38 <Aruro> ah, forgot about that
18:25:39 <Aruro> ty
18:25:47 <Welkin> jamesmradoom: it can produce Unit
18:25:47 <Aruro> u told me to use div
18:25:52 <dkbrk> jamesradoom: a function can not terminate, in which case it's typed as _|_
18:25:53 <LordBrain> jamesmradoom: There is (). which is sort of like a void value you can return when you are just interested in side effects
18:25:57 <jamesmradoom> ok another one: is haskell both strongly, strictly, and statically typed? i'm making a haskell presentation and i'm just making sure everything i put on these slides is accurate
18:26:03 <jedai42> jamesmradoom: since functions don't have side effects, the only reason for a funbction to exist is to return a value
18:26:13 <jamesmradoom> ok yeah thought so just making sure
18:26:16 <batchm> functions can't have side effects
18:26:17 <ReinH> dkbrk: And _|_ is a member of all types
18:26:29 <ReinH> It isn't "typed as _|_"
18:26:31 <Welkin> Aruro: (/) is specifically for preserving the decimal
18:26:33 <ReinH> it's typed as whatever its type is
18:26:33 <jedai42> LordBrain: Right but that would be the parameter of a monadic value, not a function since they don't have side effects
18:26:52 <dkbrk> My mistake.
18:26:59 <LordBrain> hmmm. i'm not familiar with this new semantics, we have historically referred to them as functions i am pretty sure.
18:27:16 <jamesmradoom> does anyone have some really elegant haskell code? i need to put at least 2 code examples in and i want something that really shows how amazing haskell is. i'm using quicksort for one but not sure what to use for the other one or two
18:27:26 <LordBrain> as in f :: a -> IO ()
18:27:45 <ReinH> The "side effects" are encapsulated in the type of m
18:27:55 <LordBrain> i don't object, i just am pretty sure we've been calling them functions
18:28:00 <ReinH> They are functions
18:28:02 <batchm> that is a function
18:28:04 <ReinH> And they don't have any side effects.
18:28:12 <Welkin> jamesmradoom: any of these: https://www.haskell.org/haskellwiki/Prime_numbers_miscellaneous#One-liners
18:28:31 <Welkin> jamesmradoom: my favorite is: primes = nubBy (((>1).).gcd) [2..]
18:28:34 <jedai42> LordBrain: that's a function but it doesn't have side-effects
18:28:47 <Welkin> > take 50 $ nubBy (((>1).).gcd) [2..]
18:28:49 <lambdabot>  [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,...
18:28:50 <jamesmradoom> welkin: i was looking at that but i didnt understand it so i coudn't really explain it.. lol
18:28:52 <LordBrain> well, hmmmmmmmmmmm saying it has no side effects seems like pedantic silliness to me
18:28:53 <ReinH> jamesmradoom: if you're going to use quicksort, be prepared to explain how it differs from a typical quicksort written in, say, C
18:28:57 <Welkin> it is a prime number generator
18:29:06 <jedai42> LordBrain: the return value is of type IO () so it could have side-effects but the function itself doesn't
18:29:06 <jamesmradoom> reinh yeah i know it's inefficient
18:29:07 <ReinH> LordBrain: not at all, it's a pretty important property of Haskell functions
18:29:24 <ReinH> jamesmradoom: look at any of the functional pearls
18:29:30 <batchm> LordBrain what will this print?  main = head [print 10, print 20, print 30] ?
18:29:52 <batchm> or this main = print 10 `seq` print 20
18:29:57 <Aruro> :t (..)
18:29:58 <lambdabot> parse error on input ‘..’
18:30:08 <Welkin> > take 50 $ nubBy (\x y -> (filter >1) $ gcd x y) [2..]
18:30:09 <lambdabot>  Couldn't match expected type ‘s -> GHC.Types.Bool’
18:30:09 <lambdabot>              with actual type ‘GHC.Types.Bool’
18:30:09 <lambdabot>  Relevant bindings include
18:30:09 <lambdabot>    y :: s (bound at <interactive>:1:21)
18:30:09 <lambdabot>    x :: s (bound at <interactive>:1:19)
18:30:12 <jedai42> LordBrain: You're saying this as if monadic value and functions that returns a monadic value were somehow the same thing.. but they're not
18:30:27 <lebesgue> batchm: 10, 20?
18:30:29 <Welkin> > take 50 $ nubBy (\x y -> (filter >1) (gcd x y)) [2..]
18:30:31 <lambdabot>  Couldn't match expected type ‘a -> GHC.Types.Bool’
18:30:31 <lambdabot>              with actual type ‘GHC.Types.Bool’
18:30:31 <lambdabot>  Relevant bindings include
18:30:31 <lambdabot>    y :: a (bound at <interactive>:1:21)
18:30:31 <lambdabot>    x :: a (bound at <interactive>:1:19)
18:30:38 <batchm> lebesgue it will print just 20
18:30:40 <jedai42> LordBrain: getLine isn't a function and it have side-effects (when executed by GHC runtime)
18:30:41 <triliyn> Aruro: list syntax like [1..20] desugars into applications to enumFromTo and enumFrom
18:30:43 <LordBrain> no, i think its purely semantic. sorry i if i offended you
18:30:46 <batchm> evaluating `print 10' does not print anything
18:30:52 <Aruro> nubBy is confusing if you dont know what it is
18:30:53 <triliyn> :t enumFromTo -- [a..b]
18:30:54 <lambdabot> Enum a => a -> a -> [a]
18:31:02 <triliyn> :t enumFrom -- [a..]
18:31:02 <lambdabot> Enum a => a -> [a]
18:31:05 <Aruro> triliyn: ty!
18:31:09 <Welkin> @pl (((>1).).gcd)
18:31:09 <lambdabot> ((> 1) .) . gcd
18:31:09 <LordBrain> maybe you are right, but in practice, if we say a haskell function with side effects, we actually do mean that above sort of thing
18:31:16 <Welkin> @unpl (((>1).).gcd)
18:31:17 <lambdabot> (\ e h -> (gcd e h) > 1)
18:31:18 <lebesgue> batchm: You asked two questions... 10 for first, 20 for second.
18:31:20 <Aruro> i was wondering if you can define your own ..
18:31:22 <Welkin> there we go
18:31:29 <Aruro> i was wondering if you can define your own (..)
18:31:35 <Welkin> > take 50 $ nubBy (\x y -> (gcd x y) > 1) [2..]
18:31:36 <LordBrain> so, i guess there's a place for pedantry, and a place for getting over it
18:31:36 <lambdabot>  [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,...
18:31:45 <batchm> lebesgue ah.. ok then. here is your cookie
18:31:49 <triliyn> > let (..) = (+) in 5 .. 6
18:31:50 <lambdabot>  <hint>:1:6: parse error on input ‘..’
18:31:54 <triliyn> hmmm, looks like not
18:32:07 <triliyn> I think (...) is a valid operator though
18:32:17 <triliyn> > let (...) = enumFromTo in 5 ... 8
18:32:18 <lambdabot>  [5,6,7,8]
18:32:23 <shachaf> You can define an instance of enumFromTo for your type. Which is something.
18:32:30 <triliyn> oh, also that
18:32:52 <Welkin> > let (#!) = (+) in 5 #! 6
18:32:53 <lambdabot>  <hint>:1:8: parse error on input ‘)’
18:33:03 <Welkin> > let #! = (+) in 5 #! 6
18:33:04 <lambdabot>  <hint>:1:5: parse error on input ‘#!’
18:33:10 <Aruro> :t enumFromTo
18:33:11 <lambdabot> Enum a => a -> a -> [a]
18:33:14 <triliyn> http://hackage.haskell.org/package/base-4.7.0.1/docs/Prelude.html#t:Enum this typeclass will give you all of the .. syntax variants I think
18:33:19 <Welkin> > let `#!` = (+) in 5 `#!` 6
18:33:20 <lambdabot>  <hint>:1:5: parse error on input ‘`’
18:33:36 <Aruro> ty!
18:34:11 <Aruro> there should be some code phrase how to say thank you  to everybody :)
18:34:46 <Aruro> something like tyeb
18:35:02 <batchm> LordBrain I don't think it is pedantry.. it is fundamental in understanding how IO works
18:35:47 <batchm> (at the language level, that is)
18:37:21 <ReinH> I would prefer that "we" didn't say "a haskell function with side effects", since that's not an accurate statement.
18:38:07 <ReinH> It contributes to a misunderstanding of monads and especially IO as some sort of magical way to allow side effects in an otherwise pure language
18:38:35 <dibblego> ReinH: this is a common problem among people who teach FP.
18:39:33 <jedai> I wouldn't mind the term in the context of a discussion between several strong Haskeller that automatically interpret it as "a function that returns a monadic value that would have side effects)
18:40:11 <jedai> but in the context of someone asking if functions have side effects in Haskell, I really don't think that's pedantry to try and make a distinction
18:40:23 <dibblego> functions do not have side-effects. IO values have as much to do with side-effects as [] values do.
18:40:24 <jedai> in order to avoid confusions
18:40:31 <ReinH> Exactly
18:41:36 <batchm> it would be neat if ghci shipped with "describeIO" function, thated returned an english description of what composed IO action would do if executed
18:41:42 <jedai> dibblego: ok I said it before but to be absolutely correct you have to append " that would have side effects when executed by the GHC runtime" but I think that's taking things a bit too far :)
18:42:04 <ReinH> That isn't a side effect, though. That's an effect.
18:42:04 <LordBrain> hmm batchm kindof a docstring
18:42:21 <jedai> true
18:42:34 <ReinH> Execution of an IO action by the runtime system *is* the effect of running a Haskell program.
18:42:56 <Aruro> does recursion always goes down in a parameter? like f x = .....f (x-1) ?
18:43:15 <Aruro> is there interesting examples of upward recursion? f x = .... f (x+1) ?
18:43:24 <LordBrain> well, i am all for whatever language you want to use, just so long as you are flexible enough to be able to converse without getting obnoxious.
18:43:43 <ReinH> I don't think it's obnoxious to not want to lie about how your language behaves.
18:43:46 <jedai> Aruro: It better do if you want to get to the base case and so end the recursion somewhere
18:43:48 <kadoban> Aruro: It at least has to tend towards...simpler problems to solve. That usually means a lower number, but not always.
18:43:54 <batchm> LordBrain more than a docstring, since it would describe arbitrarily composed IO actions. it would have pedagogical uses, to demonstrate that IO a is just another value
18:44:06 <LordBrain> ah
18:44:23 <kadoban> Aruro: If you recurse into a more difficult to solve problem, then...when will that ever end?
18:44:25 <Aruro> yeah i would like to read something nice on unusual recusrions
18:44:34 <LordBrain> you could do it with a transformer on IO instead tho
18:44:36 <jedai> Aruro: note that "downward" isn't always the right description (you can recurse on things other than int anyway)
18:44:51 <ReinH> Aruro: are you familiar with mathematical induction?
18:45:00 <Aruro> i am :)
18:45:01 <LordBrain> like a log
18:45:17 <ReinH> the f (x - 1) form of recursion (with a suitable base case) is a form of induction
18:45:17 <merijn> Fun fact, fold + trivial helper is sufficient to implement any primitive recursive function :)
18:45:18 <LordBrain> using WriterT
18:45:28 <ReinH> But so is the (x + 1) case (with a suitable base case)
18:45:47 <Aruro> i know, i just want to see some smart people using it to amuse
18:46:06 <ReinH> Well, there are recursive functions that are not inductive
18:46:13 <Aruro> would be nice to read some essay on unusual recursions
18:46:16 <ReinH> > let f = 1 : f in f
18:46:18 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
18:46:29 <shachaf> That's not a function.
18:46:37 <shachaf> And it's corecursive anyway. :-)
18:46:57 <ReinH> shachaf: Insert 30 minutes of "nullary function" argument here.
18:47:08 <merijn> No such thing
18:47:11 <shachaf> ReinH: Huh?
18:47:20 <ReinH> merijn: At least, not in Haskell ;)
18:47:27 <merijn> ReinH: Not in any language
18:47:38 <ReinH> merijn: Sure there are. It depends on your definition of function.
18:47:52 <merijn> ReinH: Ah, but this is #haskell, we use sane definitions of function :)
18:47:55 <Aruro> ok he just wanted to demonstrate horizontal recursion, not bad  still :)
18:48:09 <ReinH> merijn: There are sane definitions of function that allow nullary function
18:48:11 <ReinH> like category theory
18:48:32 <shachaf> Oh, you meant you actually wanted to have the argument.
18:48:40 <ReinH> shachaf: I didn't, but apparently merijn does ;)
18:48:47 <Aruro> so nobody wrote great poem on recursion? everybody just mentions it in books?
18:49:02 <ReinH> merijn: we could take this to -blah?
18:49:29 <shachaf> If you mean "function that isn't a Haskell function" then sure, and maybe it belongs in a non-Haskell channel.
18:49:53 <ReinH> shachaf: I think that's what I just said as well.
18:50:13 <Aruro> one example of using up recursion is when modifying a list from down up
18:50:17 <shachaf> Yes. I was saying: If you aren't talking about Haskell, you can take it to #haskell-blah.
18:50:25 <Aruro> thus not knowing its length
18:50:30 <ReinH> Yep. I also just said that.
18:50:31 <merijn> ReinH: Naah, I'll go back to procrastinating instead of getting into arguments :)
18:50:31 <shachaf> But I was talking about Haskell functions, and that's not a Haskell function.
18:50:34 <ReinH> merijn: :)
18:50:47 <shachaf> But I'll just link to conal's post instead of arguing.
18:50:52 <shachaf> @google conal everything is a function
18:50:54 <lambdabot> http://conal.net/blog/posts/everything-is-a-function-in-haskell
18:50:54 <lambdabot> Title: Conal Elliott » “Everything is a function” in Haskell?
18:50:56 <ReinH> shachaf: I've read it.
18:51:17 <Aruro> in case of lists you can always stop recursion by [] pattern match, thus it can be both upward and downward
18:51:18 <shachaf> Well, read it again, and you can have the experience of an argument.
18:51:36 <ReinH> shachaf: Do you not remember me saying that I didn't want to have the argument?
18:52:04 <jamesmradoom> @google the nut job
18:52:06 <lambdabot> http://www.imdb.com/title/tt1821658/
18:52:06 <lambdabot> Title: The Nut Job (2014) - IMDb
18:52:15 <batchm> I think having an argument whether we should have a nullary function argument is much more interesting
18:52:23 <batchm> than a nullary function argument
18:52:39 <ReinH> batchm: I think the fixed point of that argument is even more interesting
18:54:59 <dibblego> believing in "functions that have no arguments" has also shown to be an impediment in teaching, in my experience and that of others with whom we share ideas
18:55:36 <Aruro> meirjn i just notice your comment about fold
18:55:42 <ReinH> You are all determined to have this argument with me, aren't you?
18:55:49 <Welkin> haskell has changed the way I write in other languages (which is not often)
18:56:04 <Welkin> but my javascript is broken into small, pure functions when possible
18:56:32 <Aruro> haskell has good sintax
18:56:44 <Welkin> syntax*
18:57:01 <Aruro> identation is definitive win over brackets insanity
18:57:03 <Welkin> yes, the syntax is the best I have found
18:57:12 <Aruro> exactly
18:57:25 <Welkin> Aruro: you can override the whitespace-dependent syntax using brackets
18:57:37 <Aruro> yes that i know :)
18:57:45 <Aruro> but im glad nobody using it
18:57:58 <Welkin> it is usefule for typing a do block in one line for lambdabot
18:57:59 <merijn> Aruro: I've got a paper that discusses the proof if you're curious
18:58:00 <Welkin> useful*
18:58:12 <Aruro> yes merijn
18:58:24 <Aruro> i am curious
18:58:36 <merijn> Aruro: http://eprints.nottingham.ac.uk/224/1/fold.pdf
19:01:14 <Aruro> ty! chapter 2 has links to recursion theory :)
19:01:16 <Aruro> ill read that
19:03:28 <Aruro> funny part that fold is also defined recursively
19:03:43 <Welkin> of course it is
19:03:59 <ReinH> fold is what's doing the recursion
19:04:20 <Aruro> mm
19:05:04 <Aruro> recursion is there before fold is defined
19:05:07 <Aruro> i guess
19:05:22 <ReinH> fold is a recursive function
19:07:54 <zwer> Aruro perhaps you should read about fix if you're curious about a function that can implement any recursive algorithm
19:08:12 <zwer> :t fix
19:08:13 <lambdabot> (a -> a) -> a
19:08:22 <zwer> @src fix
19:08:22 <lambdabot> fix f = let x = f x in x
19:09:46 <zwer> > fix (\rec x -> x : rec (x+1)) 0
19:09:47 <lambdabot>  [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,2...
19:10:33 <Aruro> ty! i will read about it
19:12:19 <ReinH> zwer: can fix implement any recursive algorithm?
19:12:25 <Aruro> i feel like beginners introduction to haskell has to be solely based on functions currying recursion and where let expressions
19:12:55 <Aruro> maybe also types and typeclasses
19:13:01 <zwer> ReinH I believe so
19:13:07 <ReinH> Types are pretty important.
19:13:59 <Aruro> merijn thank you for article
19:14:04 <Aruro> im enjoying reading it :)
19:14:09 <zwer> ReinH am I mistaken?
19:15:12 <merijn> fix can implement any primitive recursive function, afaik. I don't think it can do any arbitrary recursion, but I'm not confident about that
19:15:30 <Aruro> i see that omitting arguments is a common under the hood practice
19:17:01 <dibblego> Aruro: arguments are not omitted. Rather, all haskell functions accept exactly one argument, always, with no exception.
19:17:38 <Welkin> how can I represent unicode character in code by using the codepoint?
19:18:10 <indiagreen> > '\0066'
19:18:11 <lambdabot>  'B'
19:18:49 <Welkin> > '\1010'
19:18:50 <lambdabot>  '\1010'
19:18:53 <Aruro> by omitting i mean that 2 arguments are needed to use one of them as counter
19:19:05 <Aruro> for example, thus having a role of variable
19:19:09 <Welkin> > '\0101'
19:19:10 <lambdabot>  'e'
19:19:20 <Welkin> that's not right
19:19:33 <ReinH> Aruro: I wouldn't recommend thinking of accumulating parameters as "having a role of variable"
19:19:42 <Welkin> > '\257'
19:19:43 <lambdabot>  '\257'
19:19:45 <Welkin> > '\0257'
19:19:46 <ReinH> And not all arguments that appear to be accumulating parameters actually accumulate anything
19:19:47 <lambdabot>  '\257'
19:19:50 <Aruro> well sorry :) my naive understanding is that
19:19:59 <ReinH> foldr doesn't have an accumulating parameter, for instance
19:20:02 <indiagreen> > '\x0101'
19:20:03 <lambdabot>  '\257'
19:20:16 <indiagreen> it's decimal by default
19:20:19 <Welkin> fmap Data.Char.ord "áǎàēéěèīíǐìōóǒòūúǔùǖǘǚǜ"
19:20:24 <Welkin> > fmap Data.Char.ord "áǎàēéěèīíǐìōóǒòūúǔùǖǘǚǜ"
19:20:25 <lambdabot>  [225,462,224,275,233,283,232,299,237,464,236,333,243,466,242,363,250,468,249...
19:21:26 <Welkin> for some reason these don't know up in emacs with my font
19:21:33 <batchm> ReinH hmm, foldr does not have an accumulating parameter? what does it have, then/
19:21:34 <Welkin> even though I'm pretty sure it;s a unicode font
19:21:45 <Welkin> they display in my terminal using the same font... but not in emacs
19:21:52 <enthropy> @src foldl
19:21:52 <lambdabot> foldl f z []     = z
19:21:52 <Welkin> only some of them show up
19:21:52 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
19:22:05 <Welkin> > fmap Data.Char.ord "āáǎàēéěèīíǐìōóǒòūúǔùǖǘǚǜ"
19:22:07 <lambdabot>  [257,225,462,224,275,233,283,232,299,237,464,236,333,243,466,242,363,250,468...
19:22:11 <enthropy> batchm: I think 'z' there is what you'd call an accumulating parameter
19:22:24 <Welkin> > show "āáǎàēéěèīíǐìōóǒòūúǔùǖǘǚǜ"
19:22:25 <lambdabot>  "\"\\257\\225\\462\\224\\275\\233\\283\\232\\299\\237\\464\\236\\333\\243\\4...
19:22:32 <batchm> I know. I was confused what ReinH meant when he said that foldr does not have an accumulating parameter
19:22:38 <ReinH> @src foldr
19:22:38 <lambdabot> foldr f z []     = z
19:22:38 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
19:22:50 <ReinH> batchm: it has an argument called z that replaces []
19:23:28 <ReinH> recursive applications of foldr always use the same z
19:23:49 <batchm> ok, I get what you mean. foldl accumulates, foldr doesn't
19:23:53 <ReinH> Right.
19:25:20 <dibblego> the expression (foldr f z list) replaces, in list, (:) with f and [] with z. Where foldl f z list runs a loop like this pseudocode: { var r = z; foreach(e in list) { r = f r e; } return r; }. This is explained in more detail here: http://functionaltalks.org/2013/06/19/tony-morris-explain-list-folds-to-yourself/
19:25:50 <exio4> I think a
19:25:59 <exio4> er, wrong chan
19:27:34 <marchelzo_> I get this error when I run my program: "<stdin>: hGetChar: illegal operation (handle is closed)". How can I fix this?
19:27:34 <ReinH> foldr is a typed church encoding for lists, which has a name I can't remember
19:27:39 <ReinH> dibblego: do you remember what johnw called it?
19:28:02 <dibblego> ReinH: no idea, but perhaps "catamorphism"
19:28:03 <ReinH> Oh. Boehm-Balducci.
19:28:08 <ReinH> I believe.
19:28:10 <dibblego> ok
19:28:52 <jamesmradoom> making a powerpoint presentation for class. besides linq, what languages have borrowed features/ideas from haskell and what languages/ideas were they?
19:29:02 <pavonia> marchelzo_: Post your code, please
19:29:05 <pavonia> @lpaste
19:29:05 <lambdabot> Haskell pastebin: http://lpaste.net/
19:29:09 <batchm> marchelzo sounds like lazy IO at work. did you call getContent twice by any chance?
19:29:45 <dibblego> jamesmradoom: scala has monad comprehensions like linq
19:29:49 <ReinH> Sounds like we should look at some code...
19:30:02 <christiansen> jamesmradoom: Idris has lots and lots of Haskell in it :)
19:30:08 <batchm> (bets that is it)
19:30:15 <ReinH> jamesmradoom: F#? Microsoft employs a bunch of Haskell developers for research...
19:30:19 <marchelzo_> batchm: ah. I called getContents and then I used getChar later >.<
19:30:25 <ReinH> Less so now than they used to, though
19:30:27 <jamesmradoom> o so many thank you everyone
19:30:35 <christiansen> F#'s computation expressions are related to do notation
19:30:53 <christiansen> (see Tomas Petricek's recent paper)
19:31:03 <batchm> marchelzo_ there you go :).
19:31:35 <christiansen> http://tomasp.net/academic/papers/computation-zoo/
19:31:53 <Aruro> it was really important to know that presentation is powerpoint :)
19:31:54 <marchelzo_> batchm: What I want to do is get whatever was piped in right at the start, and then any other reading takes place later. Is that possible? Like a non-blocking getContents or something.
19:32:00 <dkbrk> jamesmradoom: Rust traits are inspired by Haskell type classes
19:32:21 <christiansen> Coq got type classes too :)
19:32:27 <ReinH> dibblego: I usually just call them "church encodings", because more people say "What's a Boehm-Balducci encoding?" than "Actually it's a Boehm-Balducci encoding." ;)
19:32:56 <ReinH> Idris was inspired by monad transformers (and how to avoid having them)
19:33:01 <batchm> marchelzo_ getContents reads until end of file. it will either: 1) read everything. 2) read portions of stdin needed to do whatever you're doing with the result, and then close the stdin handle
19:33:26 <christiansen> ReinH: rather Idris's effects library, which is just a library
19:33:42 <marchelzo_> batchm: ok. I'll just read the input from a file and reserve stdin for the getChar calls. Thanks.
19:33:44 <batchm> marchelzo_ what is it that you're actually trying to do?
19:34:05 <ReinH> christiansen: that was pretty much a direct paraphrase of edwin ;)
19:34:07 <batchm> if you're redirecting a file to stdin then you can't expect getChar to read from a keyboard
19:34:25 <ReinH> One of his goals with Idris was *not* having monad transformers
19:34:26 <marchelzo_> batchm: I wrote a brainfuck interpreter and I want to use it like 'cat hello.bf | ./bf' and then still have ',' read from stdin.
19:34:28 <christiansen> ReinH: I know - that's what he always says about it. but the language is way older than that lib!
19:34:40 <ReinH> christiansen: true enough
19:34:52 <dkbrk> ReinH: do you have any more information on Boehm-Balducci? Google mostly turns up irc logs...
19:35:07 <ReinH> Of course, monad transformers are just libraries as well ;)
19:35:31 <ReinH> dkbrk: Not really. Presumably johnw does. afaik they are just typed church encodings.
19:35:52 <batchm> marchelzo_ yeah that won't work. getContents and getChar read from the same handle,
19:36:11 <marchelzo_> Alright, it's not a big deal. Thanks for the info.
19:36:21 <batchm> no problem
19:36:23 <dkbrk> nvm, I found it: http://okmij.org/ftp/tagless-final/course/Boehm-Berarducci.html
19:36:33 <ReinH> Oh yeah, tagless final.
19:36:36 <ReinH> Thanks
19:36:58 <ReinH> That's a nice course as well
19:38:40 <ReinH> dkbrk: Ah, you probably found the same misspelling I did ;)
19:44:44 * hackagebot gloss-rendering 1.9.2.1 - Gloss picture data types and rendering functions.  http://hackage.haskell.org/package/gloss-rendering-1.9.2.1 (BenLippmeier)
19:44:46 * hackagebot gloss 1.9.2.1 - Painless 2D vector graphics, animations and simulations.  http://hackage.haskell.org/package/gloss-1.9.2.1 (BenLippmeier)
19:44:48 * hackagebot gloss-algorithms 1.9.2.1 - Data structures and algorithms for working with 2D graphics.  http://hackage.haskell.org/package/gloss-algorithms-1.9.2.1 (BenLippmeier)
19:44:50 * hackagebot gloss-raster 1.9.2.1 - Parallel rendering of raster images.  http://hackage.haskell.org/package/gloss-raster-1.9.2.1 (BenLippmeier)
19:44:52 * hackagebot gloss-examples 1.9.2.1 - Examples using the gloss library  http://hackage.haskell.org/package/gloss-examples-1.9.2.1 (BenLippmeier)
20:15:27 <Welkin> how can I easily split a list in two places?
20:16:30 <Welkin> split where a consonant meets a vowel and where a vowel meets a consonant, for example
20:16:31 <centrinia> :t span
20:16:32 <lambdabot> (a -> Bool) -> [a] -> ([a], [a])
20:17:46 <Welkin> I'm looking for ([a] -> Bool) -> [a] -> [[a], [a], [a]]
20:18:18 <indiagreen> use span twice
20:18:29 <Welkin> it seems messy
20:19:08 <indiagreen> well, then you can split at all transitions
20:19:15 <indiagreen> and keep the first 2 chunks
20:19:18 <indiagreen> and concat the rest
20:19:20 <Welkin> > span (`elem` "aeoiu") "zhuang"
20:19:22 <lambdabot>  ("","zhuang")
20:19:22 <indiagreen> which, too, seems messy
20:19:30 <Welkin> not right
20:19:45 * hackagebot tinyMesh 0.1.0.0 - TinyMesh - communicating with auto-meshing sensor network  http://hackage.haskell.org/package/tinyMesh-0.1.0.0 (MichalGajda)
20:19:47 <centrinia> :t partition
20:19:48 <lambdabot> (a -> Bool) -> [a] -> ([a], [a])
20:19:48 <indiagreen> > break (`elem` "aeoiu") "zhuang"
20:19:49 <lambdabot>  ("zh","uang")
20:19:50 <Welkin> > break (`elem` "aeoiu") "zhuang"
20:19:51 <lambdabot>  ("zh","uang")
20:19:52 <Welkin> break works
20:19:56 <Welkin> but not quite what I want either
20:20:13 <centrinia> > partition (`elem` "aeiou") "banana"
20:20:14 <lambdabot>  ("aaa","bnn")
20:20:29 <Welkin> > partition (`elem` "aeoiu") "zhuang"
20:20:30 <lambdabot>  ("ua","zhng")
20:20:33 <Welkin> hm
20:20:39 <indiagreen> it's the same as filter
20:20:44 <indiagreen> just slightly more efficient
20:20:47 <Welkin> I need to reconstruct it after I modify the vowels with tone marks
20:20:53 <Welkin> so that won't work
20:21:47 <Welkin> I could use takeWhile . dropWhile
20:21:53 <Welkin> but then I lose the rest of the string
20:22:07 <Welkin> I suppose I could work around that
20:22:09 <centrinia> > let str="mississippi"; f = `elem` "aeiou"; g = map fst in (g *** g) $ partition (\(x,y) -> f x &&  not (f y)) $ zip str (tail str)
20:22:10 <lambdabot>  <hint>:1:28: parse error on input ‘`’
20:22:23 <merijn> Welkin: Look at the split package?
20:22:34 <merijn> That may have more of the sort of function you're looking for
20:22:43 <centrinia> > let str="mississippi"; f = (flip elem) "aeiou"; g = map fst in (g *** g) $ partition (\(x,y) -> f x &&  not (f y)) $ zip str (tail str)
20:22:45 <lambdabot>  ("iii","msssspp")
20:22:59 <centrinia> > let str="mississippi"; f = (flip elem) "aeiou"; g = map fst in (g *** g) $ break (\(x,y) -> f x &&  not (f y)) $ zip str (tail str)
20:23:00 <lambdabot>  ("m","ississipp")
20:24:29 <Welkin> merijn: that looks good
20:24:32 <Welkin> splitBy
20:25:31 <Welkin> er, splitWhen
20:29:22 <Welkin> > break (`elem` "aoeiu") "a"
20:29:23 <lambdabot>  ("","a")
20:32:58 <basedsiren> how do i make thing do thing?
20:33:41 <yukko> well that's easy, you just make a thing that does the thing
20:34:30 <basedsiren> thanks it works now
20:39:45 * hackagebot syntax-trees-fork-bairyn 0.1.2.5 - Convert between different Haskell syntax trees. Bairyn's fork.  http://hackage.haskell.org/package/syntax-trees-fork-bairyn-0.1.2.5 (ByronJohnson)
20:55:28 <stephen_> > chain :: Integer -> Integer
20:55:29 <lambdabot>  Not in scope: ‘chain’
20:55:46 <gcganley> stephen: chain?
20:56:30 <stephen_> gcganley: never mind, pasted in the wrong window
21:04:46 * hackagebot ltk 0.14.0.1 - Leksah tool kit  http://hackage.haskell.org/package/ltk-0.14.0.1 (HamishMackenzie)
21:06:41 <stephen_> I'm having some trouble resolving dependencies for the Copilot DSL package. Here's my cabal-install pastebin http://lpaste.net/115361
21:06:41 <stephen_> Resolving dependencies...
21:06:41 <stephen_> Notice: installing into a sandbox located at
21:06:41 <stephen_> /home/stephen/lab/wrt/ahrs/.cabal-sandbox
21:06:44 <stephen_> Configuring copilot-core-2.1.1...
21:06:47 <stephen_> Building copilot-core-2.1.1...
21:06:50 <stephen_> Failed to install copilot-core-2.1.1
21:06:53 <stephen_> Build log ( /home/stephen/lab/wrt/ahrs/.cabal-sandbox/logs/copilot-core-2.1.1.log ):
21:06:56 <stephen_> Configuring copilot-core-2.1.1...
21:06:59 <stephen_> Building copilot-core-2.1.1...
21:07:03 <stephen_> Preprocessing library copilot-core-2.1.1...
21:07:06 <stephen_>  
21:07:09 <stephen_> src/Copilot/Core/External.hs:17:8:
21:07:12 <stephen_>     Could not find module ‘Data.DList’
21:07:15 <stephen_>     There are files missing in the ‘dlist-0.7.1’ package,
21:07:16 <foobarbazinga> idea: ultra-simple web framework using lazy lists. the user just provides a function of the signature [Request] -> [Response]. Routing is handled with a simple pattern match, and state can be preserved by using a fold instead of a map. thoughts?
21:07:19 <stephen_>     try running 'ghc-pkg check'.
21:07:20 <stephen_>     Use -v to see a list of the files searched for.
21:07:23 <stephen_>  
21:07:26 <stephen_> src/Copilot/Core/Interpret/Render.hs:18:8:
21:07:29 <stephen_>     Could not find module ‘Text.PrettyPrint.NCol’
21:07:33 <stephen_>     There are files missing in the ‘pretty-ncols-0.1’ package,
21:07:36 <stephen_>     try running 'ghc-pkg check'.
21:07:39 <stephen_>     Use -v to see a list of the files searched for.
21:07:42 <stephen_>  
21:07:45 <stephen_> src/Copilot/Core/MakeTags.hs:13:8:
21:07:48 <stephen_>     Could not find module ‘Control.Monad.State’
21:07:50 <stephen_>     There are files missing in the ‘mtl-2.1.3.1’ package,
21:07:53 <stephen_>     try running 'ghc-pkg check'.
21:07:56 <stephen_>     Use -v to see a list of the files searched for.
21:07:59 <stephen_>  
21:08:03 <stephen_> src/Copilot/Core/Random.hs:24:8:
21:08:06 <stephen_>     Could not find module ‘System.Random’
21:08:09 <stephen_>     There are files missing in the ‘random-1.1’ package,
21:08:12 <stephen_>     try running 'ghc-pkg check'.
21:08:15 <stephen_>     Use -v to see a list of the files searched for.
21:08:19 <stephen_>  
21:08:20 <stephen_> src/Copilot/Core/Random.hs:25:8:
21:08:23 <stephen_>     Could not find module ‘Control.Monad.Reader’
21:08:24 <shachaf> you can /msg chanserv op #haskell
21:08:26 <stephen_>     There are files missing in the ‘mtl-2.1.3.1’ package,
21:08:27 <shachaf> Er.
21:08:29 <stephen_>     try running 'ghc-pkg check'.
21:08:30 --- mode: ChanServ set +o shachaf
21:08:33 <stephen_>     Use -v to see a list of the files searched for.
21:08:34 --- kick: stephen_ was kicked by shachaf (stephen_)
21:08:48 --- mode: shachaf set -o shachaf
21:10:01 <foobarbazinga> you folks have any comments on this idea?
21:10:48 <HeladoDeBrownie> foobarbazinga, it has similar problems to the previous Haskell IO model that worked like that.
21:11:06 <foobarbazinga> HeladoDeBrownie: ooh, do you have more details?
21:11:18 <HeladoDeBrownie> Looking for a source
21:11:25 <gfixler> Anyone recall what it was SPJ said Java got from Haskell?
21:11:41 <gfixler> I seem to remember one of the Haskell core devs worked on it
21:11:53 <marchelzo_> Phil Wadler did I think
21:12:08 <gfixler> marchelzo_: sounds right, but what was the concept?
21:12:12 <cojy> generics?
21:12:19 <dmj`> gfixler: C# and Java got lambdas ?
21:12:21 <gfixler> cojy: that's what I was thinking, but it didn't seem right
21:12:33 <gfixler> did Wadler implement generics for Java?
21:12:36 <gfixler> dmj`: not sure
21:12:40 <marchelzo_> Wiki says Wadler was involved in adding Generics to Java
21:12:45 <cojy> yea he has a book on it too
21:12:51 <gfixler> marchelzo_: ah, then that must be it
21:12:58 <dmj`> In C# it was definitely generics and linq
21:13:00 <gfixler> cojy: nice - I'll have to look it up
21:13:21 <gfixler> dmj`: was Erik Meijer behind linq?
21:13:27 <HeladoDeBrownie> foobarbazinga, read the section on input and output http://research.microsoft.com/en-us/um/people/simonpj/papers/marktoberdorf/mark.pdf
21:13:30 <dmj`> I believe so
21:13:42 <merijn> foobarbazinga: Haskell's initial way of IO was indeed a function of lazy requests to lazy responses, but you may have more luck asking the mailing lists
21:13:47 <cojy> yes gfixler
21:13:59 <gfixler> dmj` and cojy - thanks for the info
21:14:00 <merijn> foobarbazinga: More of the implementors of original haskell might see it and answer :)
21:14:55 <foobarbazinga> HeladoDeBrownie / merijn: but aside from performance issues, are there any conceptual issues? not really designing this to be used in high-performance environments, just to make it easier to craft little webapps in my favorite language :)
21:15:35 <HeladoDeBrownie> foobarbazinga, conceptual issues are touched on in what I linked
21:16:27 <merijn> foobarbazinga: I think the monadic approach has just proved to me more flexible, powerful and easier to program
21:17:00 <HeladoDeBrownie> merijn, fyi, the original context was about handling web requests
21:18:12 <merijn> I think the current design of most web frameworks already takes a very "Request -> Response" approach, modulo type noise for efficiency/safety :p
21:20:06 <foobarbazinga> merijn: I read the attached paper and this is a bit different -- it looks like the model discussed in there is almost the reverse of what I'm proposing. "New input or output facilities can be added only by extending the Request and Response types" doesn't matter because it's just HTTP stuff. the other two points in that list don't really apply either because it's req -> res rather than the other way
21:20:20 <HeladoDeBrownie> foobarbazinga, I'm the one who linked that
21:20:26 <foobarbazinga> oh whoops
21:20:36 <foobarbazinga> HeladoDeBrownie: do you get what I mean though?
21:21:02 <foobarbazinga> you'd never get out of step because request and response can't be unlinked
21:21:17 <HeladoDeBrownie> I get what you mean about extension, but not the part where you said "it's req -> res rather than the other way"
21:21:32 <HeladoDeBrownie> Well your question was about [Request] -> [Response], which does have that problem
21:21:41 <HeladoDeBrownie> If you instead use Request -> Response I think you'd be fine
21:23:57 <ReinH> And you don't really get anything out of [Request] -> [Response] anyway since HTTP is stateless?
21:24:29 <HeladoDeBrownie> If you did want to incorporate some sort of server-side state then you'd want something more complex than Request -> Response, probably
21:24:41 <HeladoDeBrownie> It'd be more like Request -> State Foo Response or even Request -> IO Response
21:25:28 <HeladoDeBrownie> and the action that actually runs the server and handles these requests would maintain the state between requests
21:56:43 <Welkin> > char '\252'
21:56:44 <lambdabot>  ü
21:56:52 <Welkin> > char '\2522'
21:56:53 <lambdabot>  ৚
21:57:08 <Welkin> > map char "\2522"
21:57:10 <lambdabot>  [৚]
21:57:13 <Welkin> hm
21:57:21 <Welkin> > map char '\252':"2"
21:57:22 <lambdabot>  Couldn't match expected type ‘[GHC.Types.Char]’
21:57:23 <lambdabot>              with actual type ‘GHC.Types.Char’Couldn't match type ‘GHC.Types....
21:57:23 <lambdabot>                with ‘[Text.PrettyPrint.HughesPJ.Doc]’
21:57:23 <lambdabot>  Expected type: [[Text.PrettyPrint.HughesPJ.Doc]]
21:57:23 <lambdabot>    Actual type: [GHC.Types.Char]
21:57:40 <athan> Welkin: You might be able to get away with Char8s!
21:57:55 <Welkin> > map char "ü2"
21:57:56 <lambdabot>  [ü,2]
21:57:59 <Welkin> hm
21:58:21 <Welkin> what's the difference between "\2522" and "ü2"?
21:58:30 <Welkin> :t "\2522"
21:58:31 <lambdabot> [Char]
21:58:35 <Welkin> :t "ü2"
21:58:36 <lambdabot> [Char]
21:58:38 <athan> :t '\2522'
21:58:39 <lambdabot> Char
21:58:46 <Welkin> yeah...
21:59:07 <Welkin> then how it it represented? explicitly as [Char]?
21:59:14 <athan> http://hackage.haskell.org/package/utf8-string-0.3.3/docs/Data-ByteString-Lazy-UTF8.html
21:59:17 <Welkin> rather than the double-quote syntactic sugar?
21:59:17 <athan> well...
21:59:23 <athan> the actual characters are single-quoted
21:59:33 <athan> but that ^ gives you a bytestring interface...
21:59:37 <athan> which is a little better
21:59:46 <athan> So you can actually edit characters
21:59:58 <athan> I'm just not sure how those characters are represented as bytestrings :P
22:01:01 <Welkin> hm, I need to perform list operations on it
22:01:07 <Welkin> so I think I'll leave it as a String
22:02:11 <athan> hmm...
22:02:21 <athan> > read "\2522" :: Char
22:02:23 <lambdabot>  *Exception: Prelude.read: no parse
22:02:30 <athan> ._.
22:02:43 <ab9rf> heh
22:02:44 <merijn> Welkin: Pretty sure "\2522" gets parsed as a single unicode codepoint
22:02:52 <merijn> Rather than a codepoint followed by '2'
22:02:57 <ab9rf> most likely
22:03:00 <Welkin> isn't that a problem?
22:03:06 <merijn> Why?
22:03:08 <Welkin> how can unicode even work then?
22:03:14 <merijn> It means you're typing it wrong
22:03:18 <Welkin> > ord '2'
22:03:20 <lambdabot>  50
22:03:39 <merijn> Welkin: Unicode is something internal, the fact that you're inputting the wrong data doesn't mean unicode is broken :)
22:03:39 <Welkin> > map char "\252\50"
22:03:40 <lambdabot>  [ü,2]
22:03:42 <ab9rf> > length "\2522"
22:03:42 <merijn> Right
22:03:43 <lambdabot>  1
22:03:51 <ab9rf> indeed, parsed as a single codepoint
22:03:51 <Welkin> but I don't type it that way in my source
22:03:55 <Welkin> I type 2
22:04:02 <Welkin> I am using ü now as well
22:04:13 <merijn> Welkin: You can just write unicode directly in haskell source files
22:04:15 <Welkin> but other unicode characters won't show up in my editor for some reasom...
22:04:23 <merijn> Welkin: The report mandates utf-8 for haskell source files
22:04:27 <Welkin> it shows in my terminal with the same font
22:04:49 <merijn> Welkin: Sounds like an issue with your editor's font?
22:04:53 <Welkin> no
22:04:56 <Welkin> the font is fine
22:05:03 <merijn> Which editor?
22:05:07 <Welkin> emacs is acting strange
22:05:17 <merijn> Which platform?
22:05:24 <Welkin> I had to fix chinese by specifying a font for a fontset
22:05:26 <ab9rf> Welkin: that's to be expected, it is emacs, after all
22:05:29 <Welkin> osx
22:05:36 <merijn> Welkin: Ding, ding, we have a winner
22:05:44 <merijn> Welkin: You're using the default emacs?
22:05:45 <ab9rf> hehe, osx acting strange, that's also to be expected
22:05:47 <Welkin> no
22:05:49 <merijn> Welkin: GUI mode?
22:05:56 <merijn> ab9rf: Quit trolling
22:05:57 <Welkin> I installed via binariesI think
22:06:02 <Welkin> yes gui mode
22:06:22 <merijn> Welkin: Yeah, there's something wonkey with gui mode emacs on OSX, you need aquamacs for proper support
22:06:36 <merijn> Rather than the default xemacs or whatever it's called
22:06:43 <ab9rf> merijn: hey, it's not my fault that OSX is a weird environment
22:06:46 <merijn> Try if it works in terminal emacs
22:06:56 <merijn> ab9rf: OSX is a perfectly fine environment
22:07:04 <merijn> ab9rf: It's more posix compliant than linux
22:07:26 <ab9rf> merijn: you say that like it's a good thing :)
22:07:38 <merijn> Welkin: http://aquamacs.org/
22:09:01 <Welkin> oh
22:09:07 <Welkin> yeah it works fine in the terminal
22:09:50 <Welkin> I can use it in terminal mode I suppose, but I wonder if it will mess up my theme
22:10:53 <merijn> Welkin: Right, look into aquamacs, that should work in GUI mode (although I haven't really tried)
22:17:28 <Welkin> thanks merijn
22:27:44 <ania12> any brazilian here?
22:29:49 * hackagebot global 0.2.0.0 - Haskell2010 compatible library enabling unique top-level declarations  http://hackage.haskell.org/package/global-0.2.0.0 (ByronJohnson)
22:34:49 * hackagebot atlassian-connect-descriptor 0.1.0.0 - Code that helps you create a valid Atlassian Connect Descriptor.  http://hackage.haskell.org/package/atlassian-connect-descriptor-0.1.0.0 (RobertMassaioli)
22:35:33 <ByronJohnson> Don't you love catching a problem *only* just after you upload a package? -_-
22:39:49 * hackagebot global 0.2.0.1 - Library enabling unique top-level declarations  http://hackage.haskell.org/package/global-0.2.0.1 (ByronJohnson)
22:41:15 <monochrom> :)
22:52:12 <ReinH> Welkin: http://emacsformacosx.com/ works for me
22:58:18 <solatis> ByronJohnson: nothing better than a stress-and-caffeine-induced emergency coding session
22:59:39 <Welkin> how can I always print the proper unicode characters instead of the code point?
22:59:58 <Welkin> > show "h\283n ch\464"
23:00:00 <lambdabot>  "\"h\\283n ch\\464\""
23:00:32 <Welkin> > map (ch . ord) "h\283n ch\464"
23:00:33 <lambdabot>  Not in scope: ‘ch’
23:00:33 <lambdabot>  Perhaps you meant one of these:
23:00:34 <lambdabot>    ‘c’ (imported from Debug.SimpleReflect),
23:00:34 <lambdabot>    ‘h’ (imported from Debug.SimpleReflect),
23:00:34 <lambdabot>    ‘chr’ (imported from Data.Char)
23:00:37 <Welkin> > map (chr . ord) "h\283n ch\464"
23:00:38 <lambdabot>  "h\283n ch\464"
23:00:40 <thebnq>  > "h\283n ch\464"
23:00:41 <Welkin> hm
23:00:44 <thebnq> > "h\283n ch\464"
23:00:45 <lambdabot>  "h\283n ch\464"
23:01:26 <Welkin> > map (chr . ord) ['h','\283','n',' ','c','h,'\464']
23:01:27 <lambdabot>  Syntax error on 'h
23:01:27 <lambdabot>  Perhaps you intended to use TemplateHaskell
23:01:55 <Welkin> > show ['h','\283','n',' ','c','h','\464']
23:01:55 <thebnq> it works when i do putStrLn
23:01:57 <lambdabot>  "\"h\\283n ch\\464\""
23:02:24 <Welkin> oh
23:02:33 <Welkin> dammit, ghci always fucks with me
23:02:56 <thebnq> well giving a string to show means it escapes it
23:03:10 <thebnq> > show "\n"
23:03:11 <lambdabot>  "\"\\n\""
23:05:39 <Welkin> > putStrLn "ü"
23:05:40 <lambdabot>  <IO ()>
23:06:51 <merijn> No, the problem is that just an expression in lambdabot/ghci uses the show instance which will escape the unicode
23:07:12 <merijn> putStrLn *prints* the string, so assuming your encoding is set correct, that does work
23:07:46 <merijn> In other words, expecting ghci/lambdabot to print characters properly will never work
23:08:15 <thebnq> now i'm curious if theres a way around that
23:09:44 <merijn> Sure, hack up ghci to work differently
23:10:12 <merijn> Or just actually print stuff if that's what you want
23:17:11 <thebnq> yeah It seems so
23:19:08 <supki_> > text "h\283n ch\464"
23:19:10 <lambdabot>  hěn chǐ
23:48:59 <ab9rf> so how do you get a unicode escape followed by an regualr digit?
23:49:16 <ab9rf> > "\2882\42"
23:49:17 <lambdabot>  "\2882*"
23:53:07 <ab9rf> oh, i see
23:53:20 <ab9rf> > "\252\&2"
23:53:21 <lambdabot>  "\252\&2"
23:53:42 <ab9rf> it seems that \& is the "magic cookie" used for "end of code point"
23:55:28 <Maxdamantus> I think the \& just means nothing.
23:56:03 <Maxdamantus> but it happens to potentially terminate a numeral sequence.
23:56:08 <ab9rf> yeah
23:59:51 * hackagebot expiring-cache-map 0.0.5.3 - General purpose simple caching.  http://hackage.haskell.org/package/expiring-cache-map-0.0.5.3 (elblake)
