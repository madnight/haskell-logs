00:07:10 <homesitter> Is ther another way than using "hi" for package initialization
00:07:12 <homesitter> ?
00:08:21 <homesitter> ogh "cabal init"
00:08:52 * hackagebot nibblestring 0.0.1 - Packed, strict nibble arrays with a list interface (ByteString for nibbles)  http://hackage.haskell.org/package/nibblestring-0.0.1 (jamshid)
00:08:52 * hackagebot yaml 0.8.9.4 - Support for parsing and rendering YAML documents.  http://hackage.haskell.org/package/yaml-0.8.9.4 (MichaelSnoyman)
00:30:02 <sidoaight> Sorry for poppping in all sudden-like.  I err, have a newb question.  -- Does the haskell compiler care about source code order?
00:31:40 <MP2E> sidoaight: what do you mean by source code order? If you mean, can a function be called before it is defined yes
00:31:47 <MP2E> the only exception to this is Template Haskell
00:32:02 <MP2E> Template Haskell has to be carefully ordered
00:34:29 <sidoaight> Okay, cool.  I've always wanted to program in a language that would let me put "the cool part" of a program at the top of the file and define my implementation of said cool part below.
00:36:09 <sidoaight> Anyways, thank you for answering MP2E!  ^_^
00:36:11 <sidoaight> Take care!
00:36:15 <MP2E> no problem :)
00:36:27 <MP2E> bye!
00:38:09 <albertid> such friendly persons around here
00:38:35 <sbrg> it is the natural consequence of regularly programming in something that makes sense
00:49:44 <tom39291> Upon `cabal sandbox init; cabal install`, I receive "cabal: The following packages are likely to be broken by the reinstalls:"
00:49:56 <tom39291> If I'm in a sandbox, how can I break OS-managed packages?
00:51:13 <AlecTaylor> hi
00:51:36 <AlecTaylor> I know I can use `:type` to get the type from GHCI, how do I get it from an .hs file?
00:52:43 <pavonia> Load the file into GHCi and use :type?
00:52:59 <AlecTaylor> pavonia: I'm using a script runner, so I can't do that
00:53:03 <AlecTaylor> Is there another way?
00:55:27 <pavonia> AlecTaylor: How is the script related to GHCi?
00:55:46 <AlecTaylor> ?
00:56:05 <shachaf> AlecTaylor: ghc f.hs -e ':t foo'
00:56:20 <bahamas> AlecTaylor: http://stackoverflow.com/a/10399738/449541
00:56:39 <shachaf> Typeable does a very different thing from :t
00:56:47 <shachaf> Much more limited.
00:57:05 <shachaf> And it works on a (monomorphic) value, not on a .hs file or an expression.
00:57:22 * AlecTaylor wants http://en.wikipedia.org/wiki/Typeof
00:57:29 <pavonia> Isn't ghc -e basically the same as what GHCi does?
00:57:39 <shachaf> It is.
00:57:53 <shachaf> OK, if you want that, then typeOf is the answer.
00:58:00 <shachaf> But it's pretty limited.
00:58:08 <shachaf> E.g. you can't get the general type of length.
01:01:03 <AlecTaylor> This is confusing. SayI have s="foo"; I can't do putStrLn typeof s?
01:01:19 <tdammers> AlecTaylor: no, why
01:01:28 <shachaf> print (typeOf s), sure.
01:01:36 <shachaf> Why do you want to?
01:01:41 <pavonia> :t typeOf
01:01:42 <lambdabot> Typeable a => a -> TypeRep
01:01:44 <wei2912> > print (typeOf "foo")
01:01:46 <lambdabot>  <IO ()>
01:01:58 <pavonia> > typeOf "foo"
01:02:00 <lambdabot>  [Char]
01:02:12 <wei2912> i should have expected that, lol
01:02:23 <AlecTaylor> Ah cool, thanks
01:02:25 <tdammers> but, bigger picture, this isn't very useful
01:02:30 <pavonia> > typeOf 123
01:02:31 <lambdabot>  Integer
01:02:34 <tdammers> types are compile-time
01:03:09 <AlecTaylor> Yeah that's fine, just wanted to know how to acquire them
01:03:31 <AlecTaylor> Helpful for learning (when I'm not using GHCi)
01:04:00 * pavonia is still wondering how that script runner is related to the whole question
01:06:37 <AlecTaylor> I'm guessing this pattern isn't recommended:
01:06:41 <AlecTaylor> ```putStrLn ("typeOf [\"foo\"] = " ++ (show(typeOf(["foo"]))))```
01:07:42 <pavonia> Too many parentheses
01:08:41 <AlecTaylor> Fixed
01:08:42 <AlecTaylor> putStrLn $ "typeOf [\"foo\"] = " ++ show(typeOf ["foo"])
01:08:56 <ski> looks ok, either way
01:10:19 <AlecTaylor> I can't get rid of those parens around show, how do I do that?
01:10:31 <shachaf> There are no parentheses around show in what you wrote.
01:10:48 <AlecTaylor> I mean inside, like `show(typeOf ["foo"])`
01:10:51 <shachaf> But Haskell function application is written "f x", not "f(x)"
01:10:57 <AlecTaylor> Can I remove those?
01:11:05 * ski would get rid of the `$', instead ..
01:11:11 <shachaf> I would write "show (typeOf ...)"
01:11:25 <shachaf> Because you're giving one argument to show, and that argument is (typeOf ...).
01:12:23 <AlecTaylor> So just keep my 3 minutes ago answer?
01:12:49 <shachaf> What's that?
01:12:58 <AlecTaylor> putStrLn $ "typeOf [\"foo\"] = " ++ show(typeOf ["foo"])
01:13:16 <shachaf> No, put a space between show and (
01:13:31 <shachaf> I think you probably shouldn't be writing this code in the first place.
01:13:43 <AlecTaylor> Well that was my initial question
01:13:56 <AlecTaylor> quote: "I'm guessing this pattern isn't recommended:"
01:14:08 <shachaf> Which pattern?
01:14:32 <AlecTaylor> Of printing out the types rather than trusting that they will work/fail as expected
01:14:36 <AlecTaylor> This is Haskell afterall
01:14:45 <shachaf> Remember: In Haskell it's idiomatic to put a space between a function and its argument.
01:14:48 <shachaf> Whatever.
01:15:13 <AlecTaylor> ?
01:19:14 <sgronblo> hey guys, I'm doing the Exercises for Erik's Haskell course and was a bit confused about this implementation of sequence_
01:19:48 <sgronblo> sequence_' ms = foldr (>>) (return ()) ms is apparently a correct implementation
01:20:13 <shachaf> Looks reasonable.
01:20:45 <sgronblo> but wouldnt this build up an expression like ma >> (mb >> (mc >> return ())) which would be evaluated from the inside, causing the monads to be evaluated in reverse order?
01:24:22 <johnw> evaluation is different from execution
01:24:41 <johnw> return 1 >> (return 2 >> return 3) and (return 1 >> return 2) >> return 3
01:24:42 <johnw> both return 3
01:24:53 <sgronblo> or is this dependent on the operator precedence settings for >> ?
01:25:00 <johnw> because both evaluate to actions which yield a 3
01:25:12 <johnw> it's not about operator precedence
01:25:17 <johnw> it's about the associativity of >>
01:25:57 <shachaf> return isn't a good example because executing (return x) does nothing.
01:26:01 <johnw> in fact, I probably shouldn't even be using the term "execution" here
01:26:19 <johnw> so strike that part
01:26:21 <shachaf> But in general ((a >> b) >> c) is equal to (a >> (b >> c))
01:26:40 <_1_AlexMarkin200> Hi guys
01:26:42 <sgronblo> ah its because of the fixity declaration?
01:26:46 <johnw> no
01:26:54 <johnw> it's due to the monad laws
01:26:55 <sgronblo> which includes both associativity and precedence
01:27:28 <ski> sgronblo : regardless of whether `ma >> (mb >> (mc >> return ()))' would be *evaluated* from the inside or from the outside, evaluating it still produces the same *description/recipe* of a sequence of I/O-operations to do. and after evaluating this description, it is still (some time later, when it is actually executed) executed in a left-to-right order
01:27:33 <shachaf> sgronblo: You should take some concrete monad that you understand and figure out what goes on in that case.
01:27:45 <shachaf> E.g. Maybe, or something. If you know what (>>) and return do for Maybe.
01:28:45 <sgronblo> shachaf: well you already said it was due to associativity which is specified in the fixity?
01:28:59 <shachaf> I didn't say anything was due to associativity.
01:29:12 <sgronblo> ah sorry, it was johnw who said it
01:29:18 <ski> sgronblo : a binary operation "being associative" is not the same as a binary *operator* being specified to "be left-associative" or "be right-associative" or "be non-associative"
01:29:46 <shachaf> sgronblo: You talked about (ma >> (mb >> (mc >> return ()))) being "evaluated from the inside".
01:29:49 <ski> sgronblo : the latter is about how expressions with operators in them are parsed. the former is about the *meaning* of the operation
01:30:22 <shachaf> I just mentioned that (((ma >> mb) >> mc) >> return ()) is equal to the thing you wrote.
01:32:16 <sgronblo> i forgot that >> was left associative and then i just checked an online example of foldr with (+)
01:32:49 <shachaf> (>>) is left-associative but it *should* be right-associative (but that's only for efficiency reasons and you don't need to care either way).
01:32:54 <shachaf> The terminology is confusing.
01:33:16 <sgronblo> shachaf: really? now i am getting more confused too.
01:33:25 <shachaf> The last thing I said was confusing.
01:33:58 <shachaf> Let's start over. Talking about associativity has only made this conversation worse, and it's not necessary for this.
01:34:44 <shachaf> What's the original confusion?
01:36:30 <sgronblo> ok, i was confused about the foldr implementation of sequence_ was correct
01:36:52 <sgronblo> because i checked this example of using foldr https://www.haskell.org/haskellwiki/Foldr_Foldl_Foldl'
01:37:28 <shachaf> OK. The first thing is that foldr f z on a (finite) list is just a roundabout way to write an expression with lots of fs and a z at the end.
01:38:01 <shachaf> foldr (>>) (return ()) [a,b,c,d] = a >> (b >> (c >> (d >> return ())))
01:38:13 <shachaf> So do you have the same confusion with the expression on the right?
01:38:19 <sgronblo> yeah this matches my understanding
01:38:37 <sgronblo> but now these parentheses seem to apply that d would be "evaluated" first
01:39:09 <shachaf> But (for the most part, modulo infinite loops) it doesn't matter what order things are "evaluated" in.
01:39:26 <shachaf> From the perspective of the meaning of a Haskell program, that question doesn't even make sense.
01:39:37 <shachaf> So I think this is confusion about what (>>) is.
01:39:39 <sgronblo> yeah but for something like IO it does matter
01:39:49 <shachaf> Nope. Even for IO it doesn't matter.
01:40:08 <shachaf> (print 1 >> (print 2 >> print 3)) and ((print 1 >> print 2) >> print 3) do the same thing.
01:40:15 <shachaf> They're the same value.
01:41:17 <shachaf> (a >> b) means "do a, then do b", for various values of the word "do".
01:43:00 <dcoutts_> it's slightly more subtle than that, it's a consequence of one of the monad laws that makes that equality true
01:43:25 <shachaf> More subtle than what?
01:44:14 <shachaf> I did suggest picking a specific monad earlier. I think that's much better than working with a general abstraction you don't really understand.
01:44:57 <tdammers> I think the key thing here is that (>>) does not "do" anything at all, it just combines two monadic actions
01:45:16 <tdammers> print "foo" >> print "bar" -- combines two IO actions into a new IO action
01:45:37 <tdammers> and when we talk about associativity in this context, it relates to the way these actions are combined
01:45:39 <shachaf> I think I should never have gotten involved in this conversation.
01:45:45 <shachaf> Especially with johnw around.
01:45:52 <tdammers> well
01:46:05 <tdammers> the "what are Monads anyway" conversation tends to end up badly, yes
01:46:35 <ski> sgronblo : note that `let a = print 1 in let b = print 2 in a >> b' is equal to `let b = print 2 in let a = print 1 in a >> b' .. and both are equal to `print 1 >> print 2' -- all three evaluate to the same description of a sequence of I/O-operations to perform
01:47:16 <tdammers> "IO is an EDSL for constructing imperative programs" :D
01:47:34 <tdammers> if you think of it this way, it's not even complicated
01:47:36 <ski> sgronblo : this isn't that different from `let a = ["1"] in let b = ["2"] in a ++ b' being equal to `let b = ["2"] in let a = ["1"] in a ++ b' being equal to `["1"] ++ ["2"]'
01:48:02 <sgronblo> yeah i think part of my confusion was assuming that >> actually evaluates the monad expression
01:48:03 <ski> sgronblo : evaluating `print 1' does *not* perform any I/O-operation
01:48:05 <t4nk286> @pl (\a -> (a + x / a) / 2)
01:48:05 <lambdabot> (/ 2) . ap (+) (x /)
01:48:33 <ski> evaluation is distinct from execution
01:49:03 <ski> evaluation of an `IO'-action is finding out *which* I/O-operations to (later, or perhaps never, or perhaps multiple times later) perform
01:49:05 <sgronblo> but i guess ma >> (mb >> mc) becomes ma >> (combined monad that first does mb and then mc)
01:49:45 <ski> execution of an `IO'-action is about actually communicating with the rest of the world, *performing* the specified I/O-operations
01:49:53 <ski> sgronblo : yes
01:50:09 <ski> sgronblo : though you should say "combined action", not "combined monad"
01:50:19 <ski> `ma',`mb',`mc' are *actions*
01:50:24 <ski> `IO' itself is a monad
01:50:56 <t4nk286> @unpl (/ 2) . ap (+) (x /)
01:50:56 <lambdabot> (\ e -> ((\ h i j -> i >>= \ g -> j >>= \ h -> return (h g h)) (\ k -> k) (+) (\ b -> x / b) e) / 2)
01:51:00 <ski> (in out case above, `print 1',`print 2',`print 3' would be `IO'-actions, specifically)
01:51:53 <ski> "computation" is sometimes used as a synonym for "action"
01:52:10 <ski> and "recipe" can be a good analogy, in the I/O case
01:52:22 <lpaste> lambdabot pasted “lambdabot wanna share how IO works” at http://lpaste.net/6726133194598383616
01:52:28 <sgronblo> ok, I'm not sure I see where the line between the two goes yet
01:52:48 <ski> think of an `IO'-action as a recipe .. you can think of it roughly as a list of instructions
01:53:33 <ski> the recipe is distinct from what it is a recipe of
01:53:53 <ski> in cooking, the recipe is usually made from paper, and some pen scribblings
01:54:06 <ski> while the cake (e.g.) is made from other things
01:54:22 <ski> evaluating an `IO'-action corresponds to figuring out what the recipe should be
01:54:37 <ski> executing it corresponds to following its instructions to actually bake a cake
01:55:13 <ski> sgronblo : does that make sense ?
01:58:03 <sgronblo> ski: kind of
01:59:29 <ski> sgronblo : did you read lambdabot's paste as well ?
02:00:01 <sgronblo> halfway
02:00:37 <sgronblo> I got a bit sidetracked and started wondering if there is some sort of runIO function
02:00:41 <_rgn> so main :: IO () is just a big recipe of instructions?
02:01:14 <sgronblo> since most other monads seem to have a runSomething function to actually "execute" those "actions" if i am using my vague terms correctly here
02:02:05 <ski> _rgn : conceptually, yes
02:02:29 <_rgn> how does it work then if there are computations between IO actions
02:02:48 <exio4> sgronblo: the type of that function would be "IO a → a"
02:02:53 <ski> in practice, the evaluation and execution of `main' is interleaved. but it's good to think of it as conceptually separate
02:03:04 <ski> sgronblo : there is no `runIO', no
02:03:43 <ski> `main' (and entering an `IO'-action in an interactor like GHCi) is the only way to execute an `IO'-action in Haskell
02:03:55 <sgronblo> computations between IO actions are bound together using >>=, no?
02:04:20 <ski> so, apart from the interactor : every `IO'-action which is executed is executed because it has in some way or another been made part of the whole composite `IO'-action `main'
02:04:51 <ski> sgronblo : `(>>=)' is the main glue which binds `IO'-actions together, yes
02:04:57 <tdammers> sgronblo: >>= is the bind operator, yes
02:05:02 <ski> however, it's not the only such glue
02:05:11 <ski> @type catch
02:05:12 <lambdabot> Exception e => IO a -> (e -> IO a) -> IO a
02:05:16 <ski> is another
02:05:16 <sgronblo> just trying to answer _rgn's question
02:05:48 <tdammers> well, _rgn's question doesn't exactly make sense
02:05:48 <ski> _rgn : "in practice, the evaluation and execution of `main' is interleaved. but it's good to think of it as conceptually separate"
02:05:57 <tdammers> there are no computations "between" IO actions
02:05:59 <ski> well, it's unclear, anyway :)
02:06:05 <sgronblo> so but in the haskell runtime or somethign there is something that calls main and executes the IO action returned by main? doesnt this amount to a runIO function?
02:06:31 <tdammers> sgronblo: yes, it does, but "runIO" is not a Haskell function
02:06:37 <sgronblo> tdammers: right
02:06:40 <tdammers> it only exists outside of Haskell-the-language
02:06:42 <ski> sgronblo : it can't be expressed in Haskell (by purpose)
02:07:15 <tdammers> Haskell is, in a way, highly declarative
02:07:34 <tdammers> you don't "run" anything, you just declare how to construct a recipe that the runtime can execute
02:07:40 <zwer_a> note that main doesn't return IO action, main *is* IO action
02:07:51 <ski> sgronblo : if you want to, you can make your own "I/O-operation instruction type", and then write an interpreter for it, which translates from this type to the ordinary `IO' type
02:08:01 <sgronblo> is IO the only monad that doesnt have a runSomething action that is defined in Haskell itself?
02:08:11 <tdammers> zwer_a: and then note that since Haskell is pure, "returning a value" and "being a value" is the same thing, sort of
02:08:43 <zwer_a> tdammers, you don't call main and have it return an IO action, that would imply it is a function
02:09:00 <ski> sgronblo : so then your type behaves more or less like `IO'. and your interpreter of it, *plus* the run-time system interpreting the ordinary `IO', behaves more or less like the run-time system interpreting the ordinary `IO' descriptions/actions
02:09:07 <tdammers> zwer_a: "call" is kind of a dubious concept even
02:09:26 <ski> sgronblo : no, `ST's `runST' isn't defined in Haskell either
02:09:33 <tdammers> zwer_a: you can think of main as a nullary function, or you can think of it as a lazy value - it doesn't make a real different
02:09:40 <tdammers> *difference
02:09:44 <ski> @type Control.Monad.ST
02:09:45 <lambdabot>     Not in scope: data constructor ‘Control.Monad.ST’
02:09:49 <ski> @type Control.Monad.ST.runST  -- i mean
02:09:50 <lambdabot> (forall s. ST s a) -> a
02:09:50 <Adeon> @type unsafePerformIO
02:09:51 <lambdabot> Not in scope: ‘unsafePerformIO’
02:10:21 <ski> sgronblo : this is really not that different from the fact that addition of `Int's or `Float's not being defined in Haskell
02:10:34 <zwer_a> tdammers, there are no nullary functions in haskell
02:10:52 <sgronblo> hadnt even heard of ST
02:11:00 <johnw> he means you can think of it that way
02:11:22 <zwer_a> so is 10 a nullary function?
02:11:27 <johnw> a nullary function is like a function that takes unit as its argument, which is like a lazy value represented by a thunk
02:11:55 <tdammers> zwer_a: it makes sense to think of it as one occasionally, yes
02:11:56 <ski> sgronblo : `ST' is used to get local mutable variables
02:12:23 <johnw> I never think of them as nullary functions, but I can see the motivation for presenting it that way sometimes
02:12:47 <johnw> "it's a value that the system 'calls' at some point in the future"
02:12:56 <tdammers> the "nullary function" thing helps make the mental leap to understanding lazy values / thunks
02:12:59 <johnw> without you passing any argument to it
02:13:07 <zwer_a> http://conal.net/blog/posts/everything-is-a-function-in-haskell
02:13:16 <johnw> yes, I know that blog post very well
02:13:20 <tdammers> same here
02:13:23 <bennofs> I think an important difference is that thunks are memoized, functions are not
02:13:25 <ski> > let incSTRef ref = do x <- readSTRef ref; writeSTRef ref (x+1) in runST (do ref <- newSTRef 3; replicateM 5 (incSTRef ref); x <- readSTRef ref; return x)
02:13:27 <lambdabot>  8
02:14:10 <ski> sgronblo : that shows a simple use of `ST' and `STRef' (references to mutable cells). there's also `STArray' (references to mutable arrays)
02:14:12 <zwer_a> then you also know this causes confusion among newbies
02:14:14 <johnw> zwer_a: we're not saying that denotationally anything is like a nullary function, since there is no such thing; but operationally the lazy evaluation scheme uses things that are exactly like nullary functions from other languages
02:14:34 <johnw> it depends on the newbie
02:14:37 <zwer_a> that's just implementation detail though
02:14:46 <johnw> some it will confuse, some it will help, it's tdammers choice
02:14:56 * tdammers nods
02:15:00 <ski> tdammers : i'd prefer saying that it can be *implemented* as a nullary *procedure* ..
02:15:30 <tdammers> ski: I like to reserve the term "procedure" for things that are conceptually sequences of commands (or statements, if you will)
02:15:49 <johnw> I like to reserve the term "reserve" for calling restaurants
02:16:05 <tdammers> main is still pure - you can evaluate it once, or twice, or a million times, the resulting action is always the same
02:16:19 <ski> tdammers : that's ok. but "procedure" is used e.g. in Scheme for things that take arguments and can return results
02:16:30 <sgronblo> ski: anyway, getting quite far from the original topic. going back to the original question, i guess i was confusing (>>) as including execution.
02:16:32 <tdammers> ski: yes, and scheme procedures can also have side effects
02:16:41 <ski> tdammers : yes, which was the point here
02:16:42 <johnw> in Lisp procedure usually means "has side-effects"
02:16:54 <ski> @type randomIO
02:16:55 <lambdabot> Random a => IO a
02:16:59 <ski> @type randomIO :: IO Int
02:17:00 <lambdabot> IO Int
02:17:00 <zwer_a> johnw this was started when someone, who doesn't fully grasp IO or monads yet, said "runtime calls main, which returns IO action". I thought it was worthwhile pointing out that main is not a function but a value, in the same way 10 is
02:17:12 <tdammers> johnw: aren't side effects kind of implicit, except for the fact that naming conventions signal them?
02:17:19 <tdammers> johnw: at least in Scheme, that is?
02:17:35 <sgronblo> also i seemed to have been confused in thinking that a left associative operator could not be associative
02:17:37 <ski> sgronblo : consider this `randomIO'. evaluating it several times yield the same value (an action). only executing it will generate fresh (pseeudo-)random numbers
02:17:43 <ski> @type randomRIO ::
02:17:44 <lambdabot>     parse error (possibly incorrect indentation or mismatched brackets)
02:17:46 <ski> @type randomRIO
02:17:47 <lambdabot> Random a => (a, a) -> IO a
02:17:52 <ski> @type randomRIO :: (Int,Int) -> IO Int
02:17:52 <johnw> zwer_a: I agree with you that it's better to avoid the use of terms like "nullary functions", and to shift toward thinking denotationally
02:17:53 <lambdabot> (Int, Int) -> IO Int
02:18:17 <johnw> tdammers: yeah, they are implicit in Lisp too
02:18:46 <ski> sgronblo : and evaluating `randomRIO (0,9)' several times will always give the same value (the same `IO'-action). only executing it will produce an integer between `0' and `9' (inclusive)
02:18:49 <johnw> main returns a value which is a set of "instructions" for the runtime to execute as it sees fit
02:19:35 <ski> sgronblo : `do x <- randomRIO (0,9); y <- randomRIO (0,9); return (x,y)' is the same as `let act = randomRIO (0,9) in do x <- act; y <- act; return (x,y)'
02:20:31 <ski> johnw : "aren't side effects kind of implicit" -- yes, that's what "side" means :)
02:20:46 <johnw> oh, I thought he meant implicit as in "the type doesn't tell you"
02:20:52 <bennofs> What's the extension that allows type B = A (where A is a typesynonym taking one argument) in GHC?
02:21:00 <tdammers> Yeah
02:21:07 <tdammers> implicit at the source code level
02:21:09 <bennofs> I forgot the name
02:22:14 <ski> even if you had a pure (dynamically typed) Scheme with monads (and an `IO'-monad), the `IO'-effects would be explicit
02:22:45 <tdammers> you could have a lisp that somehow tags things as "pure"
02:23:01 <johnw> i'd like that in every language I use
02:23:05 <ski> because you still couldn't confure an integer with an `IO'-action value which when executed generated an integer. the run-time type check would generate an exception or something like that
02:23:07 <johnw> it's been proposed for C++ a few times
02:23:09 <tdammers> johnw: yeah, but alas
02:23:23 <pantsman> bennofs: does LiberalTypeSynonyms allow that?
02:23:41 <batchm> how usable is reactive banana? would you use it in production? for hobby projects?
02:23:45 <tdammers> btw, does anyone else find it weird that C++ had "const" from day 1, but three decades later still doesn't provide a way to declare and enforce purity?
02:24:06 <tdammers> (oh, and IIRC, D does have it)
02:24:08 <batchm> is it usable on windows?
02:24:11 <johnw> well, "const" also never meant you couldn't change things  :)
02:24:26 <tdammers> it's C++, there is always a way
02:24:41 <ski> `const' only means that *you* aren't allowed to change it
02:24:48 <tdammers> but at least you have to jump through hoops and do things that ring alarm bells to do it
02:24:57 <ski> however, if you call a callback function, then *it* could be allowed to change it
02:24:58 <johnw> you mean, or just use a cast?
02:25:03 <tdammers> yes
02:25:08 <tdammers> cast -> alarm bell
02:25:08 <ski> .. or another thread could change it, if we're multi-threaded
02:25:21 <johnw> "const" was more like, "I'd kind of like you not to change this, but what the heck, we're in C++"
02:25:21 <ski> all this without violating `const'ness anywhere
02:25:34 <johnw> oh, right
02:25:36 <tdammers> "what the heck we're in C++" always applies
02:25:47 <ski> johnw,tdammers : no, no cast
02:26:14 <wei2912> johnw: haha
02:26:32 <ski> if you have an `cha *', then you can pass it to a C function expecting a `const char *'
02:26:36 <johnw> ski: how would you change a const POD structure in another thread?  since there are no pointers involved, that function should be the only user of that value
02:26:36 <batchm> isn't casting const-ness away undefine and then mutating variable undefined behavior?
02:26:40 <ski> s/cha /char /
02:26:43 <batchm> isn't casting const-ness away and then mutating variable undefined behavior?
02:26:48 <wei2912> 18:03 < wei2912> infContinuedFrac :: Integer -> [Integer] -> [Rational]
02:26:49 <wei2912> 18:03 < wei2912> infContinuedFrac n xs = scanl1 (\ acc x -> n + 1 / x) xs
02:26:49 <wei2912> 18:03 < wei2912> how do i magically make this work? :P
02:26:58 <ski> johnw : "POD" meaning ?
02:26:58 <batchm> it may mutate the value, or it may not, IIRC
02:27:06 <johnw> ski: "Plain Old Data"
02:27:18 <johnw> meaning one of the fundamental types, or another constructed using only fundamental types
02:27:21 <ski> batchm : i'm not talking about casting `const'-ness away
02:27:27 <johnw> it's actually a specific term in the C++ standard, sorry
02:28:00 <batchm> const member function?
02:28:13 <dfeuer> Why can't Haskell be more like C++? Then everyone would understand it!
02:28:26 <wei2912> dfeuer: lol
02:28:34 <ski> the simplest way is probably to define (e.g.) `char *foo;' at file scope (and therefore static extent)
02:28:52 <johnw> one of the things I like most about Haskell is that we extend it by libraries, and rarely by syntax
02:29:10 <wei2912> true
02:29:17 <johnw> at the recent C++ standards meeting, the number (and scope) of new syntax proposals made my spine tingle
02:29:24 <batchm> ski if you thought I was replying to "passing char * to a function accepting const char *", it wasn't
02:29:27 <batchm> I*
02:30:01 <tdammers> ski: you mean, you have a mutable variable, and a function that takes a const variable, and you cannot expect the value to be immutable?
02:30:14 <ski> tdammers : yes, of course
02:30:15 <wei2912> any ideas about my problem? :)
02:30:25 <tdammers> ski: but that's not really a failure of the const keyword
02:30:30 <ski> then in some function you set `foo' to point to a (mutable) `char'. and then that function passes `foo' to a function expecting a `const char *' and also a `void (*)(void)', which you pass a pointer to a third function to
02:30:36 <johnw> wei2912: you didn't really say anything about your problem
02:30:43 <Ralith> johnw: they tend to be fairly innocuous, but ghc has pretty huge numbers of syntax-affecting extensions...
02:30:55 <johnw> Ralith: and you can NOT TURN THEM ON! :)
02:30:56 <ski> and this third function mutates that `char' via the file-scope access to it via `foo'
02:31:06 <ski> tdammers : did i say it was ?
02:31:22 <wei2912> johnw: basically, i want to convert the dividing into rational numbers so as to prevent the loss of accuracy
02:31:35 <tdammers> ski: but then your problem isn't the callback, it's the fact that you granted your entire codebase unrestricted mutable access to that variable
02:31:45 <ski> wei2912 : `fromIntegral'
02:31:50 <exio4> Rational isn't a type
02:31:52 <wei2912> ski: thanks
02:31:54 <exio4> is it?
02:31:56 <tdammers> I don't blame `const` for that
02:31:57 <Ralith> johnw: tell that to all the ones that landed in 2010 :p
02:31:57 <ski> exio4 : yes it is
02:31:59 <johnw> Rational is Ratio Integer
02:32:08 <exio4> oh, thought it was "Ratio"
02:32:24 <exio4> confused them, sorry
02:32:24 <johnw> it is, it's just a synonym
02:32:28 <ski> tdammers : you can also do it otherwise
02:32:33 <johnw> type Rational = Ratio Integer
02:33:00 <batchm> ski I've re-read everything you said. that's quite natural behavior to me. if you have char * you can mutate it. if you pass it to a function accepting const char *, function can't mutate it
02:33:09 <tdammers> ski: yes, but the point is, "const" just says "you cannot modify what this variable points to through this variable"
02:33:28 <tdammers> not, "what this variable points to is guaranteed to be immutable"
02:33:38 <ski> tdammers : say the function accepts both a `const char *' and a `char *' (or a structure, or pointer to structure, which eventually allows you to refer to that `char *') .. and then you simply pass `foo' in both arguments (or `foo' in first, and something from which `char *foo' can be referenced in the second)
02:34:10 <ski> tdammers : yes, that's my whole point. with emphasis on "*you* cannot modify ..."
02:34:21 <tdammers> ok then
02:34:42 <tdammers> I guess, just understand what const is and is not, and you're good
02:34:54 <tdammers> and if you want real immutable values, wrap them in a class, I guess
02:35:17 <tdammers> private fields, only settable throught the constructor
02:35:30 <tdammers> then the only way to modify them is through dangerous casts or suchc
02:35:44 <johnw> it's like const doesn't mean const, but rather "locked"; because it's not constant at all (say, in a multi-threaded program), but it is locked from mutation by the callee
02:35:59 <johnw> although, in the context of threading, locked would be a horrible choice of wording
02:36:04 <tdammers> it means "read-only reference/pointer"
02:36:11 <batchm> what would you prefer? if you couldn't pass char * to a function accepting const char *?
02:36:11 <johnw> there you go
02:36:12 <johnw> readonly
02:36:15 <exio4> I think the main problem with pure approachs in other language, is that becomes really expensive doing very little
02:36:48 <tdammers> the important part is that it attaches to the reference/pointer, not to the value it refers/points to
02:36:52 <ski> tdammers : then i'm not sure why you said "but at least you have to jump through hoops and do things that ring alarm bells to do it"
02:37:09 <tdammers> ski: "it" being "modifying the value through a const variable"
02:37:23 <ski> well, i wasn't talking about that in the first place :)
02:37:44 <tdammers> void foo(const char* bar); // whatever happens in foo cannot use bar to modify what bar points to
02:37:48 <tdammers> that is all
02:38:02 <batchm> char* bar sucks, by the way :)
02:38:10 <tdammers> batchm: of course
02:38:23 <tdammers> batchm: well, unless you need a pointer to a single byte
02:38:31 <batchm> char *bar is much better
02:38:45 <tdammers> eh, they're both broken
02:38:55 <batchm> char* p1, p2;
02:38:58 <tdammers> char* foo, bar; // boink
02:39:00 <tdammers> yes
02:39:12 <ski>   void foo(const char *bar,blah_t blah);  /* now, depending on what `blah_t' and `blah' is, `foo' can (indirectly) modify what `bar' points to */
02:39:36 <tdammers> ski: yes, sure
02:40:29 <ski> this is a case where parametric polymorphism would be helpful
02:40:39 <tdammers> ski: and basically, the only defense that you have in C++ is keeping your interfaces narrow, your functions small, and being religious about stuff like DRY, SRP, etc.
02:40:53 <ski> "SRP" ?
02:40:59 <tdammers> Single Responsibility Principle
02:41:05 <ski> (i assume "DRY" is "Don't Repeat Yourself")
02:41:10 <tdammers> yes
02:41:18 <tdammers> and I think I just meta-violated them both
02:41:49 <tdammers> I'll go report myself with the Redundancy Department of Redundancy now.
02:42:10 * ski has pondered an extension to Haskell where you'd declare types of things similar to the C style
02:43:53 <ski>   replicate (_ :: Int) (_ :: a) !! _ :: a
02:44:27 <Peaker> do { Int Maybe x <- Just 5; Int Maybe maybeIntList[] = [1,2,3]; ... }
02:44:41 <Peaker> that <- should be =, probably
02:44:44 <Peaker> how terrible :)
02:45:08 <ski> instead of `Maybe', you should say `fromJust'
02:47:07 <ski>   let { fromJust (x <- Just 5) :: Int; fromJust ((maybeIntList = [1,2,3]) !! _) :: Int; ... }
02:47:52 <ski> (note that i think `int x,*p = &x;' in C really ought to look like `int x,*(p = &x);' ..)
02:48:16 <ski> (oh, s/<-/=/)
02:49:37 <ski> .. however, otoh i think it's bad that field names and selection functions in Haskell use the same syntax
02:50:04 <ski>   data Foo = F {x :: Int}
02:50:08 <ski> this gives
02:50:14 <ski>   x :: Foo -> Int
02:50:18 <ski> which is confusing
02:50:22 <ski> also
02:50:28 <ski>   incX :: Foo -> Foo
02:50:36 <ski>   incX f = F
02:50:44 <ski>     { x = x f + 1
02:50:46 <ski>     }
02:50:51 <ski> also looks confusing
02:51:19 <ski> SML uses `#x f' instead of `x f', which is fine
02:52:36 <ski> (and the `f.x' in OCaml is also ok)
02:53:25 <ski> (if OCaml has sections, then `(.x)' the selection function would be clearly distinguishable from `x' the field. and in SML `#f' is the selection function)
02:53:33 <ski> (s/has/had/)
02:54:52 <dfeuer> ski, indeed, the record syntax is pretty bad.
02:58:56 <batchm> how usable is reactive banana? would you use it in production? for hobby projects?
03:01:23 <hugomg> I am trying to convert an Ocaml program to Haskell and I have some doubts on the best ways to do some things. For starters, I have an ADT with 6-7 cases and a fold funtions with 6-7 arguments that I use extensively but which is only readable because I can label the arguments. In Haskell do I just bite the bulled and use my fold without labeled arguments or is there a better way?
03:03:09 <bitraten> why are there to different ReaderT definitions?
03:05:31 <tdammers> batchm: you could use a record type that has all the arguments, write a Default instance for it, and use that to construct your argument list
03:05:42 <tdammers> batchm: sorry, hugomg
03:06:13 <tdammers> hugomg: either that, or write 6-7 different functions
03:06:47 <hugomg> that sounds awful :( Is that what people really do when they need to traverse a big ADT?
03:08:45 <wei2912> http://lpaste.net/114558 - how could i convert the foldr in continuedFrac such that it returns a list of converging results?
03:10:45 <wei2912> for this example, it should return [2, 3, 8 % 3, 11 % 4, 19 % 7, ...]
03:11:45 <ski> hugomg : you can introduce a record type for the arguments (usually called an algebra for the sum/variant type)
03:11:46 <bennofs> pantsman: yeah, that's what I was looking for. Thanks
03:13:05 <wei2912> i've attempted using scans, but they didn't work
03:13:16 <hugomg> ski: do you know any project out of the top of your had that uses an algebra like that? I would like to check it out?
03:18:31 <hugomg> hmm https://www.fpcomplete.com/user/bartosz/understanding-algebras looks promising. You refactor the original ADT to turn the recursive bits into a parameter. Then you can use fmap as the fold.
03:18:45 <ski> hugomg : hm, now that i think about it, i think it's probably more common to use a single function from a sum/variant type as representation of the algebra
03:18:46 * hackagebot rot13 0.1.0.2 - Fast ROT13 cipher for Haskell.  http://hackage.haskell.org/package/rot13-0.1.0.2 (KyleVanBerendonck)
03:20:03 <bennofs> hugomg: it's not really fmap that's the fold, but if F is your ADT with a parameter, then cata :: (F a -> a) -> Fix F -> a is like a fold
03:20:09 <ski> hugomg : yeah, that links has an example of the "single function from sum type" i mentioned
03:20:34 <ski> hugomg : look at the "Catamorphisms" section, at `eval' and `alg'
03:20:45 <ski> often one would simply define `alg' locally to `eval'
03:22:13 <ski> hugomg : so, instead of a record of functions, one for each constructor case, you have a single function that pattern-match on the constructor, and each such branch corresponds to the corrsponding function in the record of functions
03:23:06 <ski> hugomg : you might also be interested in checking out <https://www.haskell.org/haskellwiki/Uniplate> and <https://www.haskell.org/haskellwiki/Multiplate>
03:24:14 <hugomg> oh, yeah, forgot about uniplate. It helps a lot when you dont care about all the cases.
03:24:19 <ski> @where DecoratingStructures
03:24:19 <lambdabot> <http://web.archive.org/web/20051126143527/http://haskell.org/hawiki/DecoratingStructures>
03:24:21 <ski> @where IndirectComposite
03:24:21 <lambdabot> <http://web.archive.org/web/20051126141834/http://haskell.org/hawiki/IndirectComposite>
03:24:42 <ski> those two are old hawiki pages that are also related in some way to this
03:33:46 * hackagebot yesod-core 1.4.4.1 - Creation of type-safe, RESTful web applications.  http://hackage.haskell.org/package/yesod-core-1.4.4.1 (MichaelSnoyman)
03:52:17 <Peaker> is there a nice way to write (^.a) &&& (^.b)  without importing control.Arrow?
03:53:35 <hvr> Peaker: there's surely a lens-operator for that =)
03:53:43 <Peaker> that's what I'm wondering :)
03:54:17 <Peaker> Control.Arrow is such an arcane place to get a simple operator like &&& from
03:55:01 <hvr> Peaker: somewhat related, GHC 7.10/base-4.8 comes w/ Data.Bifunctor out of the box
03:55:21 <bennofs> :t (&&&)
03:55:22 <lambdabot> Arrow a => a b c -> a b c' -> a b (c, c')
03:55:25 <hvr> but you still need to 'a->(a,a)' somehow before applying bimap
03:55:43 <bennofs> Peaker: liftA2 (,) (view a) (view b)
03:57:39 <Peaker> (,) <$> (^.a) <*> (^.b) is pretty terrible :)  (\x -> (x^.a, x^.b)) is probably nicer
03:58:00 <Peaker> bimap f g . join (,)   also terrible...
03:58:40 <Peaker> @. pl djinn a -> (a, a)
03:58:40 <lambdabot> f = join (,)
04:12:28 <dramforever> New thought: the shunting-yard algorithm is like a zipper of the expression tree
04:13:30 <dramforever> poping from the operator stack -> move up
04:13:35 <dramforever> pushing -> move down
04:14:28 <dramforever> and finally emptying the stack -> move to the top to get the whole tree
04:16:58 <Peaker> when using a class that has a type family inside it -- GHC complains about lack of evidence for the type family's equality to a type before complaining about the lack of instance which is a much clearer problem
04:22:46 <lpaste> u pasted “f” at http://lpaste.net/114561
04:24:54 <lpaste> u revised “f”: “No title” at http://lpaste.net/114561
04:25:17 <shiona> whom should I ask about fixing paste.hskll.org
04:37:14 <adas> is it possible to create a function like so (~) :: a -> a ?
04:37:42 <Peaker> > let (~) x = x in (~) "Hi"
04:37:44 <lambdabot>  <hint>:1:7: parse error on input ‘)’
04:38:01 <Peaker> > let (!) x = x in (!) "Hi"
04:38:02 <lambdabot>  "Hi"
04:38:04 <adas> I got the same error
04:38:07 <Peaker> ~ is taken
04:38:15 <adas> Peaker: taken by?
04:39:21 <Peaker> adas: it is syntax for irrefutable patterns
04:39:35 <adas> Peaker: i thought that was '_'
04:39:49 <adas> Peaker: irrefutable patterns?
04:41:32 <Peaker> let f ~(x:xs) | True = "bazoogla" | False = x in f []
04:41:40 <Peaker> > let f ~(x:xs) | True = "bazoogla" | False = x in f []
04:41:41 <lambdabot>  "bazoogla"
04:41:47 <Peaker> > let f ~(x:xs) | False = "bazoogla" | True = x in f []
04:41:49 <lambdabot>  "*Exception: <interactive>:3:5-45: Irrefutable pattern failed for pattern (x...
04:42:18 <Peaker> adas: ~ marks the pattern as irrefutable and causes it to be lazily matched. A similar thing happens when you use pattern-matching in let bindings, where patterns are irrefutable by default
04:43:52 <a3gis> Peaker: so an irrefutable pattern will throw an error if it doesn't match?
04:45:53 <Peaker> a3gis: yes, but only if it is actually needed
04:46:16 <a3gis> Peaker: so could you use it to define a function like "head", where you expect a list of one or more element?
04:46:52 <Peaker> a3gis: yeah, though with head, the pattern-matched variable is always used, so a regular partial pattern match and an irrefutable pattern behave the same
04:47:03 <a3gis> oh ok
04:47:05 <Peaker> except that if you want the partiality, an irrefutable pattern lets you suspend the compiler warning about it if you want
04:47:47 <Peaker> With ghc -Wall, head (x:_) = x    <-- will give a partial-match warning (as it should!)     but if you are evil, you can use:  head ~(x:xs) = x    which is functionally the same, but will not give the partiality warning
04:48:19 <a3gis> and I assume the error for head [] will be slightly different?
04:48:39 <a3gis> e.g. irrefutable pattern failed to match instead of non-exhaustive pattern
04:48:46 <Peaker> let's see:
04:48:51 <Peaker> > let head ~(x:xs) = x in head []
04:48:53 <lambdabot>  *Exception: <interactive>:3:5-20: Irrefutable pattern failed for pattern (x ...
04:48:58 <Peaker> > let head (x:xs) = x in head []
04:48:59 <lambdabot>  *Exception: <interactive>:3:5-19: Non-exhaustive patterns in function head
04:49:19 <a3gis> mmh interesting
04:49:32 <a3gis> so the ~ symbol basically makes a pattern lazy
04:49:52 <a3gis> but to the cost that if it fails to match when needed, it throws an error instead of switching to the next pattern
04:50:41 <Peaker> a3gis: an irrefutable pattern is exclusive
04:50:49 <a3gis> exclusive?
04:50:51 <Peaker> a3gis: there can't be other patterns because how would it decide which pattern to use?
04:51:29 <yiannis_t> hey guys, i have a question about cloud-haskell :-D I try to use 'match' on a tuple that, among other things, contains a function closure (Int -> Int). This fails because that closure is not an instance of Binary: http://lpaste.net/114565
04:51:30 <Peaker> IOW: It's only applicable when you match on a single pattern
04:51:57 <a3gis> what do you mean? usually the patterns are checked in order, right? f p1 ; f p2 ; f p3 ; ...; haskell attempts to match against p1; if it fails it proceeds to matching against p2, and so on. If none match => non-exhaustive error
04:52:44 <Peaker> oh, apparently I am wrong, an irrefutable pattern isn't exclusive, it just has to be the last one
04:52:54 <Peaker> (or you get a warning about your code being dead, and indeed the code is dead)
04:53:10 <a3gis> yeah that's what I was thinking
04:53:12 <a3gis> ok cool
04:53:12 <a3gis> thanks!
04:53:16 <Peaker> a3gis: yes, but an irrefutable pattern immediately "succeeds" in matching when in practice it is postponing the matching to later
04:53:22 <chrisdone> yeah, irrefutable patterns are lazy patterns
04:53:52 <chrisdone> let Just x = … in e  is  case … of ~(Just x) -> …
04:53:52 <Peaker> I've used it a bit when matching infinite lists (Was too lazy to create a stream type)
04:54:05 <Peaker> to suppress the non-exhaustiveness warnings
04:54:11 <a3gis> what are legit reasons to use lazy patterns btw?
04:54:20 <chrisdone> few and far between =p
04:54:44 <Peaker> ^^ is one reason :)
04:56:38 <chrisdone> there's a good description of lazy patterns in the report http://haskell-lang.org/report/2010/haskellch3.html#x8-440003.12
04:57:45 <chrisdone> or was it http://haskell-lang.org/report/2010/haskellch4.html#x10-830004.4.3
05:01:43 <a3gis> chrisdone: thanks!
05:02:08 <clrnd> what a pretty thing, the Report. hadn't read the Preface till just now
05:05:08 <chrisdone> clrnd: thanks, i tried a bit to make it look prettier. the way that it's generated from latex makes it use rather unconventional HTML (e.g. in code samples and the table of contents). hopefully at some point i can employ a latex guru to help make it output something easier to prettify, preferably with syntax highlighting
05:05:43 * chrisdone would prefer to touch latex with a ten foot pole only
05:06:30 <clrnd> chrisdone, :D
05:06:39 <clrnd> yeah latex still makes me shiver
05:07:08 <clrnd> also, I see a vertical black line in http://haskell-lang.org/report/2010/haskellch2.html Section 2.4
05:07:22 <clrnd> around 'This Lexes as this'
05:07:37 <JonReed> Is there an easy way to run a process and get its "stderr"? Perhaps somehow with Conduit.Shell? E.g. conduit says that it Stdin/out and stderr are handled as an Either type: Chunk  Left is stderr, Right is stdin/stdout. But I'm confused about how to get it. E.g., a simple example is running "xgamma", which should be on most linux machines. In returns it's output in stderr.
05:07:46 <jeltsch> Peaker: You don’t need to define a Stream type yourself. There is the streams package: http://hackage.haskell.org/package/streams.
05:07:59 <chrisdone> clrnd: yeah it hard codes that
05:08:12 <bernalex> hm. is there a way to get:
05:08:31 <bernalex> type A = (A, B) | A
05:08:34 <bernalex> ?
05:08:54 <bernalex> er sorry
05:08:59 <bernalex> type A = (B, C) | B
05:09:01 <bernalex> rather
05:09:09 <Peaker> jeltsch: I'm wary of adding dependencies for minor/little things :( The versioning hell is usually not worth it
05:09:13 <clrnd> bernalex, data?
05:09:49 <Peaker> bernalex: data A = A1 B C | A2 B  ?
05:10:00 <bernalex> Peaker: then you need A1 and A2
05:10:04 <Peaker> type A = Either (B, C) B
05:10:15 <Peaker> type A = (B, Maybe C)
05:10:15 <bernalex> then you need Either. :->
05:10:24 <Peaker> bernalex: Haskell doesn't have structural types
05:10:46 <bernalex> haskell doesn't have a lot of things. GHC tends to have a flag for most of them regardless. :-P
05:10:51 <Peaker> bernalex: why don't you want A1/A2, or Either?
05:11:00 <Peaker> bernalex: what does the (B, C) represent? What does the B represent?
05:11:02 <bernalex> I just want a glorified typesig
05:11:55 <bernalex> actually a more truthful example would be A = (F B, [F C]) | F B | F C | F D
05:12:17 <Peaker> bernalex: surely these things represent something, each?
05:12:25 <Peaker> bernalex: then give those options helpful names
05:12:33 <chrisdone> JonReed: i started work on a 'redirect' functionality for shell-conduit https://github.com/chrisdone/shell-conduit/commit/5304ee6e39a6bd46aa650b608d78751ae8ea04ba but not finished
05:13:08 <jeltsch> bernalex: What would type A = B | B mean? Would left-alternative values and right-alternative values be different in what you want?
05:13:28 <bernalex> jeltsch: I don't want A = B | B, so I don't know what that would mean. :-]
05:13:58 <AleksejsHome> Hi, how do I pass an output of some command to ghc -e? I tried ls | xargs ghc -e "getArgs >>= words", it doesn't work
05:14:07 <jeltsch> bernalex: But an extension that allows type with | would probably not allow type A = B | B.
05:14:26 <bernalex> jeltsch: I would hope not.
05:14:44 <jeltsch> bernalex: This would then be a rather weird extension, wouldn’t it?
05:14:47 <jeltsch> bernalex: How do you want to do case distinction for type A = B | (B, C)?
05:15:08 <jeltsch> bernalex: Do you want to distinguish according to the type? Pattern-match on the types
05:15:12 <jeltsch> types → type?
05:15:17 <bernalex> jeltsch: with regular pattern matching. I don't really have time to explain this anymore. it doesn't exist. I'm moving on with my programming. I'm at work.
05:15:21 <bernalex> jeltsch: yes.
05:15:39 <jeltsch> bernalex: Okay, move on, use data. :-)
05:16:03 <indiagreen> AleksejsHome: yes, it won't work (and in fact getArgs won't even be in scope unless you call it like “System.Environment.getArgs”)
05:16:06 <bernalex> jeltsch: :-]
05:18:46 <AleksejsHome> indiagreen: ok, thanks, but the question is how to pass the output?
05:19:21 <indiagreen> AleksejsHome: you'd probably be better off just doing «ls | ghc -e "interact (show.length.lines)"» or something
05:20:45 <AleksejsHome> indiagreen: thanks
05:21:14 <hsk8> Has someone here read the "Yet Another Monad Tutorial" posts at "Mike's World-O-Programming"? http://mvanier.livejournal.com
05:23:32 <hsk8> Whatever. I'll just ask my real question.
05:23:39 <osfameron> :-)
05:28:05 <VW8CBWOVY3> Greetings
05:28:15 <ski> hello VW8CBWOVY3
05:29:38 <VW8CBWOVY3>  So um...
05:29:53 <VW8CBWOVY3>  Anything going on?
05:30:18 <ski> doesn't seem so
05:30:40 <VW8CBWOVY3>  Ahh
05:32:27 <ski> if you wait a while, then eventually there will probably start some discussion
05:32:38 <ski> .. or you could start one yourself :)
05:33:41 <VW8CBWOVY3> Well this is my first time on this channel so i think i'll wait
05:34:42 <ij> that was.. odd
05:35:21 <fds4345> how to go [(a, b)] -> ([a], [b]) ?
05:35:32 <fds4345> :t zip
05:35:33 <lambdabot> [a] -> [b] -> [(a, b)]
05:35:41 <fds4345> :t unzip
05:35:42 <lambdabot> [(a, b)] -> ([a], [b])
05:35:53 <fds4345> aha!
05:36:00 <fds4345> thanks #haskell
05:36:03 <ij> You're lucky.
05:37:23 <clrnd> he left :P
05:37:52 <hsk8> Suppose m is a type constructor, and f :: a -> m b
05:37:53 <hsk8> Why is the statement
05:37:54 <zwer_a_b> @hoogle [(a, b)] -> ([a], [b])
05:37:54 <hsk8> f x >>= return     is equivalent to    f x   for all possible x
05:37:56 <lambdabot> Prelude unzip :: [(a, b)] -> ([a], [b])
05:37:56 <hsk8> equivalent to the statement
05:37:56 <lambdabot> Data.List unzip :: [(a, b)] -> ([a], [b])
05:37:57 <hsk8> mv >>= return      is equivalent to    mv    for all possible mv
05:37:57 <hsk8> ?
05:38:27 <hsk8> hmm that question is incomplete
05:38:57 <clrnd> that's just a 'law' that 'should' be followd
05:39:26 <clrnd> I can define a >>= f = lolcats
05:46:05 <ski> hsk8 : because of a monad law
05:46:43 <ski> we already know `mv >>= return  =  mv' .. therefore this is equivalent to true
05:47:08 <hsk8> ski: Do you have time to look at http://mvanier.livejournal.com/4586.html ? He's trying to show the equivalence of his "nice version" of the monad laws and the actual monad laws (the "ugly version")
05:47:11 <ski> so "mv >>= return      is equivalent to    mv    for all possible mv" is therefore equivalent to `forall mv. True'
05:47:16 <hsk8> I'm stuck at let mv == fx
05:47:34 <hsk8> I don't see how he can just let f x be some variable and be done with it
05:47:40 <hsk8> he has to show that all possive mv are covered by this
05:47:44 <hsk8> doesn't he?
05:48:33 <hsk8> search for "let mv == f x". That's where I'm stuck
05:48:34 <hsk8> for Law 2
05:50:53 <ski> hsk8 : hm, it obviously works in the upwards direction
05:50:59 <ski> let me ponder the downwards one
05:51:28 <bennofs> ski: how can you assume that mv == f x in the upwards one?
05:51:35 <ski>   let x = (); f () = m
05:51:40 <ski> proves the other direction
05:51:43 <bennofs> ski: oh hmm, right
05:51:56 <ski> bennofs : you have to realize that we're really showing the equivalence of
05:52:26 <ski>   forall f x.    f x >>= return        =    f x
05:52:27 <ski> and
05:52:53 <ski>   forall mv.    mv >>= return            ==    mv
05:53:22 <ski> so, going from bottom to to, we're given arbitrary `f' and `x', and is required to show
05:53:34 <ski>   f x >>= return  =  f x
05:53:37 <ski> and we know
05:53:41 <bennofs> ski: one direction is easy. Just instantiate mv to f x
05:53:56 <ski>   forall mv.  mv >>= return  =  mv
05:54:25 <ski> so, as the article says, we can instantiate `mv' in the assumption with `f x', and then we get what we wanted to show
05:54:33 <ski> in the other direction, we assume
05:54:45 <ski>   forall f x.  f x >>= return  =  f x
05:54:48 <ski> and want to show
05:54:56 <ski>   forall mv.  mv >>= return  =  mv
05:55:07 <ski> iow, we want to show for every `mv' :
05:55:12 <ski>   mv >>= return  =  mv
05:55:28 <ski> (which is that same as saying that we're given `mv' and need to show that ^ then)
05:55:34 <ski> so, we can e.g. define
05:55:36 <ski>   x = ()
05:55:39 <ski>   f () = mv
05:55:52 <hsk8> ski: We have f :: a -> m b    Isn't he sort of assuming that looping through all possible  a   means that   f a   is looping through all possible   m b   ? That's not given is it? He's assuming that the image of the function is the whole damn thing
05:56:02 <hsk8> whole damn thing =   all possible   m b
05:56:39 <ski> so, using that instantiation on `forall f x.  f x >>= return  =  f x', we get
05:56:45 <ski>   f x >>= return  =  f x
05:56:46 <ski> which is
05:56:58 <ski>   (\() -> mv) () >>= return  =  (\() -> mv) ()
05:56:59 <ski> which is
05:57:08 <ski>   mv >>= return  =  mv
05:57:15 <ski> quod erat demonstrandum
05:57:53 <ski> hsk8 : i'm not quite sure you have the right idea when saying "We have f :: a -> m b"
05:58:05 <ski> `f' isn't predetermined, before this whole argument
05:58:18 <ski> each step (which mentions `f') has its own `f'
05:58:24 <bennofs> hsk8: it's a little weird. what ski is doing is more intuitive to me (show that    forall f x. f x >>= return == f   if and only if     forall mv. mv >>= return == mv)
05:58:54 <bennofs> I forgot an x there
05:59:00 <hsk8> oh
05:59:23 <ski> hsk8 : if `f' was already given earlier, then there's possibly be something reasonable in "Isn't he sort of assuming that looping through all possible  a   means that   f a   is looping through all possible m b   ?"
05:59:46 <ski> "That's not given is it?" -- right, it's not given (and not needed)
06:00:18 <ski> "He's assuming that the image of the function is the whole damn thing" -- they would need to assume that if `f' was to be determined before showing the equivalence chain
06:00:57 <ski> hsk8 : but i'm suggesting to you to not read it that way. and then we don't need that extra (generality-restricting) assumption
06:01:00 <ski> hsk8 : do you see ?
06:01:23 <ski> here are the steps (without justifications) :
06:01:40 <ski>          forall f.  f >=> return  =  f
06:02:03 <ski>   <=>  forall f.  \x -> (f x >>= return)  =  \x -> f x
06:02:18 <ski>   <=>  forall f x.  f x >>= return  =  f x
06:02:21 <hsk8> ski: i gotta ponder on this
06:02:33 <hsk8> but yeah I get that i was wrong about fixing f
06:02:34 <ski>   <=>  forall mv.  mv >>= return  =  mv
06:04:10 <ski> hte middle step uses that `\x -> E0  =  \x -> E1' is equivalent to `forall x.  E0  =  E1', where `E0' and `E1' are two expressions that may contain `x'
06:05:06 <ski> hsk8 : btw, to make this more explicit, one should really also quantify over the argument *type* of `f'
06:05:18 <batchm> hsk8 do you know what [1,2,3] >>= return will evaluate to without typing it in ghci? how about Just x >>= return?
06:05:58 <ski>        forall (a :: *) (f :: a -> b).  f >=> return  =  f
06:06:12 <ski>   <=>  forall (a :: *) (f :: a -> b).  \x -> (f x >>= return)  =  \x -> f x
06:06:28 <ski>   <=>  forall (a :: *) (f :: a -> b) (x :: a).  f x >>= return  =  f x
06:06:51 <batchm> :t (>>=)
06:06:52 <lambdabot> Monad m => m a -> (a -> m b) -> m b
06:06:55 <ski> um, actually i just realized that every `b' above should be `m b'
06:07:00 <ski>   <=>  forall (mv :: m b).  mv >>= return  =  mv
06:07:09 <bennofs> ski: then shouldn't you also quantify over m and b ?
06:07:20 <bennofs> (types ofc)
06:07:21 <ski> anyway, if we wanted to, we *could* also quantify each step over `b'
06:07:26 <ski> but we don't *need* to
06:07:38 <ski> but we *need* to quantify over `a'
06:08:20 <ski> otherwise we can't treat it as abstract when passing the last step downwards, while setting it to the type `()' when passing the last step upwards
06:08:20 <batchm> >>= "pulls" (not really, but sort of) a out of ma, and if your function does nothing but wraps it again in a monadic context (which is what return does) then you are left with the same thing you started with
06:08:50 <ski> also, we *can't* quantify over `m' in the intermediate formulae in the chain
06:09:07 <bennofs> ski: why is that?
06:09:16 <ski> hm
06:09:22 <ski> or maybe i'm wrong there
06:09:50 <ski> the argument i had was that we need `m' free, because it's mentioned free in the law that we're using
06:10:21 <ski> but when thinking twice, i see that we don't actually *use* that law, we just prove it's equivalent to another law
06:10:28 <ski> so i suppose we should be fine, then
06:11:10 <dramforever> math: formalizing everything
06:12:07 <chrisdone> haskell all the things! https://lh6.googleusercontent.com/-Jv6B5OuxLXI/Uh4m5EvZirI/AAAAAAAABm8/djIC8oA4Z3w/w1217-h1142-no/whhhhhhyyy.png
06:12:13 <ski> (if we had said : assuming the right unit monad law holds for `m',`(>>=)' and `return', then <blah> -- then my argument would have been right)
06:13:22 <ski> hsk8 : makes any sense ? disagree about any part ?
06:13:33 <hsk8> ski: hehe, it will take a while to go through this
06:13:54 <hsk8> thanks for the comments
06:14:12 <hsk8> i think i'll be fine now that i realized the error of keeping f fixed
06:14:51 <ski> the exact place(s) of quantifying variables can matter .. especially with equivalences
06:15:39 <ski> if i'd typed that chain, i'd probably written the `forall' for `f' and `x' explicitly, since it may not be obvious to a reader that that's the intended interpretation
06:16:07 <hsk8> the cool thing is that >=> and >>= are just any functions at all (but with proper type). >=> is just defined in terms of >>= but that's it.  Also the return function is not defined, it just has to type match.
06:16:09 <hsk8> so it's quite abstract
06:17:28 <ski> yeah, it's quite nice
06:18:54 <JonReed> Is there a function "Either a b -> b" that is like "fromJust" ("Maybe a -> a"). The function that would just throw an error if right is not there. There are "rights", but it acts on list "[Either a b]" rather than on one Either
06:19:57 <dramforever> @hoogle Either a b -> b
06:19:58 <lambdabot> Data.Either rights :: [Either a b] -> [b]
06:19:58 <lambdabot> Data.Typeable typeOf2 :: Typeable2 t => t a b -> TypeRep
06:19:58 <lambdabot> Prelude either :: (a -> c) -> (b -> c) -> Either a b -> c
06:20:09 <dramforever> hmm....
06:20:14 <JonReed> Hoogle doesn't seem to show anything. I already searched
06:20:22 <slomo_> JonReed: either (error "bla") id ?
06:20:47 <dramforever> > either (const undefined) id (Right x)
06:20:48 <lambdabot>  x
06:20:59 <dramforever> > either (const undefined) id (Left 1)
06:21:01 <lambdabot>  *Exception: Prelude.undefined
06:21:51 <JonReed> Thanks!
06:23:43 <ski> my preferred way of stating the monad laws (abstractly) :
06:23:50 <ski>   join ⦇ m,return ⦇⦈ ⦈  =  m
06:23:55 <ski>   m  =  join ⦇ return ⦇⦈,m ⦈
06:24:00 <ski>   join ⦇ join ⦇ m₀,m₁ ⦈,m₂ ⦈  =  join ⦇ m₀,join ⦇ m₁,m₂ ⦈ ⦈
06:24:59 <ski> (showing more clearly how "a monad is just a monoid in the category of endofunctors")
06:25:01 <clrnd> I only see a lot of unicode error squares, which happens to summarize my understanind of the subject :D
06:25:26 <dramforever> lol me too
06:25:36 * dramforever almost typed "mee to"
06:25:47 <bennofs> ski: what font do you use to see these symbols?
06:26:35 <ski> here's an ASCII-version, just for you :
06:26:38 <ski>   join (| m,return (| |) |)  =  m
06:26:42 <ski>   m  =  join (| return (| |),m |)
06:26:43 <ski>   join (| join (| m0,m1 |),m2 |)  =  join (| m0,join (| m1,m2 |) |)
06:26:54 <ski> bennofs : dunno, i haven't changed from whatever is default
06:27:15 <clrnd> ßßßß
06:27:41 <dramforever> Has anyone used lens before?
06:27:44 * bennofs
06:27:47 <dramforever> how did you learn to do it?
06:28:09 <dramforever> I mean, I can't understand anything about lens
06:28:39 <clrnd> dramforever, I learned to use them because Wreq uses them, didn't feel so hard
06:28:46 <bennofs> dramforever: I watched  http://youtu.be/cefnmjtAolY?hd=1, then implemented my own Lens/Traversal, then later implemented pure profunctor lenses (this might not be neccessary if you just want to use lenses)
06:28:48 <clrnd> haven't mad emy own yet
06:29:00 <ski> my terminal reports the font as `-misc-fixed-medium-r-semicondensed--13-120-75-75-c-60-iso10646-1' -- i'm not sure if that helps much ..
06:29:21 <dramforever> ouch, can't access youtube here, it's blocked
06:30:42 <dramforever> none of the lens tutorials in the wiki make sense to me
06:31:02 <bennofs> dramforever: do you already understand Traversable/Foldable ?
06:31:05 <clrnd> :t (&)
06:31:05 <lambdabot> a -> (a -> b) -> b
06:31:13 <clrnd> The End
06:31:14 <dramforever> bennofs: yep
06:31:22 <bennofs> clrnd: that is just flip ($)
06:31:46 <clrnd> lol indeed it is
06:31:55 <fds4345> dramforever: its black magic you have to sacrifice goats
06:32:09 <dramforever> uh oh, no goats here
06:32:11 <statusbot> Status update: The new `spiped` daemon is in place to connect the new WWW server to our shared MySQL database. We're monitoring to see what other issues may arise, but we believe the migration is otherwise complete. -- http://status.haskell.org
06:33:01 <clrnd> tip: in the indie game Goat Simulator, the player is a goat that sacrifices humans for pleasure and achievements
06:33:04 <bennofs> dramforever: I've heard good things about:  https://www.fpcomplete.com/school/to-infinity-and-beyond/pick-of-the-week/a-little-lens-starter-tutorial and
06:33:05 <ski> bennofs : fwiw <https://i.imgur.com/iD1aUts.png>
06:34:04 <chrisdone> i don't have any fonts which support those characters
06:34:25 <bennofs> dramforever: also  https://www.fpcomplete.com/user/tel/lenses-from-scratch
06:34:25 <ski> not even subscripts ? :(
06:34:29 <chrisdone> although amusingly if i put my cursor over one, emacs knows they're brackets and highlights them both
06:34:43 <chrisdone> they're displayed as the generic square with unicode point number in it
06:35:07 <chrisdone> emacs describes it as: Z NOTATION LEFT IMAGE BRACKET
06:35:12 <clrnd> lol
06:35:12 <ski> you see they're basically banana / lens brackets in the screenshot
06:35:21 <bennofs> dramforever: there is also #haskell-lens if you have questions :)  https://www.fpcomplete.com/user/tel/lenses-from-scratch
06:35:28 <bennofs>  https://www.fpcomplete.com/user/tel/lenses-from-scratch
06:35:31 <bennofs>  https://www.fpcomplete.com/user/tel/lenses-from-scratch
06:35:42 <ski> i'm not sure if any other unicode glyph would be appropriate. this was the one pair i found that best match my handwriting
06:35:52 <bennofs> oops
06:36:23 <bennofs> dramforever: one more thing: if you get lost in operators, here's a handy overview:  https://github.com/ekmett/lens/wiki/Operators
06:37:31 <dramforever> hmmm...that "a little lens starter tutorial" makes more sense to me
06:37:37 <bennofs>  https://github.com/ekmett/lens/wiki/Operators
06:37:38 <ski> .. however, i wonder if there's a corresponding abstract way to state the laws in terms of `(>>=)' or `(>=>)' ..
06:37:58 <dramforever> imo many others are just memos, not for lens newbies
06:41:57 <dramforever> > Right "aaa" ^? _Right
06:41:59 <lambdabot>  Just "aaa"
06:42:08 <dramforever> > Left "xxx" ^? _Left
06:42:10 <lambdabot>  Just "xxx"
06:42:18 <dramforever> > (1,2) ^. _1
06:42:19 <lambdabot>  1
06:48:43 <ocramz> :t (^.)
06:48:44 <lambdabot> s -> Getting a s a -> a
06:49:21 <ocramz> hmm
06:49:34 <gcganley> :k Getting
06:49:35 <lambdabot> * -> * -> * -> *
06:50:00 <gcganley> :t get
06:50:01 <lambdabot> MonadState s m => m s
06:50:45 <S11001001> :t view -- <- name of ^.
06:50:46 <lambdabot> MonadReader s m => Getting a s a -> m a
06:51:07 <gcganley> :t zoom
06:51:08 <lambdabot> (Zoom m n s t, Control.Lens.Internal.Zoom.Zoomed n ~ Control.Lens.Internal.Zoom.Zoomed m) => LensLike' (Control.Lens.Internal.Zoom.Zoomed m c) t s -> m c -> n c
06:52:04 <clrnd> oh my
06:52:24 <bennofs> I always have problems understanding the zoom error messages ... :D
06:52:49 <clrnd> why are people scared of monads, with their intrinsic beauty, instead of this black magic?
06:53:35 <indiagreen> clrnd: show me someone who is scared of monads but not lenses
06:54:07 <clrnd> I meant haskell agnostics
06:54:15 <tdammers> it's all just propaganda
06:54:23 <tdammers> similar to how people perceive Python as "easy"
06:54:25 <gcganley> indiagreen: glasses manufacturers
06:54:42 <tdammers> lenses look somewhat familiar
06:54:48 <ski> clrnd : perhaps you need to start writing bad ports of lenses to other languages ?
06:54:49 <tdammers> monads don't
06:54:50 <clrnd> I meant people don't go around saying 'I don't use haskell because of lenses'
06:54:57 <clrnd> lol
06:55:06 <clrnd> ski, that'd be hilarios, py-lenses
06:55:13 <bennofs> most people go around saying: I use haskell because of lenses :)
06:55:18 <gcganley> ski: oh god...
06:55:45 <hugomg> ski: apparently theres a package on Hackage that implements the folds/unfolds for that f-algebra pattern we talked about earlier today: http://hackage.haskell.org/package/data-fix. But apparently no other packages depend on it. Are people reimplementing the pattern on their own or am I missing something?
06:55:51 <exio4> tdammers: functional programming is hard, logic programming is awful, [...] ? :P
06:55:53 <clrnd> bennofs, neither for >>=
06:56:15 <tdammers> exio4: OOP can solve all your problems.
06:56:23 <bennofs> hugomg: I think it's just that many people don't know about that package
06:56:41 <exio4> tdammers: it is true though, most the problems you don't have can be solved with OOP :D
06:57:00 <bennofs> hugomg: and, recursion-schemes also implements generic folds/unfolds (but even more generically with more operations), though idk if anyone uses that
06:57:06 <bennofs> @hackage recursion-schemes
06:57:06 <lambdabot> http://hackage.haskell.org/package/recursion-schemes
06:57:22 <tdammers> lenses in python... sheesh, I wonder what the point of that would even be
06:57:40 <bennofs> tdammers: separating "what to do" and "what to do it to"
06:58:05 <tdammers> bennofs: separating concerns in Python? don't be silly.
06:58:12 <clrnd> jajaja
06:58:22 <clrnd> https://pypi.python.org/pypi/pylens
06:58:36 <ski> tdammers : wouldn't being able to access virtual parts be wonderful ?
06:58:45 <tdammers> clrnd: lost it at "stored in a string"
06:58:47 * hackagebot creatur 5.8.0 - Framework for artificial life experiments.  http://hackage.haskell.org/package/creatur-5.8.0 (AmyDeBuitleir)
06:59:34 <tdammers> ski: access virtual parts?
06:59:35 <clrnd> tdammers, but is taht pythonic enough?
06:59:58 <tdammers> clrnd: how would I know... the meaning of "pythonic" seems to change whenever I come up with anything that matches the previous definition
07:00:04 <bennofs> 'lens' doesn't only have Lens, but also Traversal, Prism, Iso
07:00:32 <gcganley> :k Iso
07:00:33 <lambdabot> * -> * -> * -> * -> *
07:00:38 <bennofs> :k Iso'
07:00:39 <lambdabot> * -> * -> *
07:00:42 <gcganley> wat
07:00:44 <bennofs> :t iso
07:00:45 <lambdabot> (Profunctor p, Functor f) => (s -> a) -> (b -> t) -> p a (f b) -> p s (f t)
07:00:49 <bennofs> ugh
07:00:55 <ocramz> hullo room, does anyone have knowledge of ThreadScope? Is there a way to get reports without using gtk, e.g. summaries in text form?
07:00:58 <gcganley> yay Iso s t a b
07:01:16 <hugomg> @benoffs: yeah, theres 10x more people using recursion-schemes but still no other dependencies on Hackage. Kind of a shame though - using regular pattern matching instead of dozens of lambdas to write a fold means you don't need to remember the argument order
07:01:16 <lambdabot> Unknown command, try @list
07:01:31 <ZioCrocifisso> http://lpaste.net/114570
07:01:38 <ZioCrocifisso> why?
07:02:03 <ski> tdammers : using any isomorphism to exhibit the part you wanted. `reverse' on lists is a simple example
07:02:12 <tdammers> ski: ah, right
07:02:25 <tdammers> bit like what C++ STL does with iterators and such
07:02:31 <tdammers> well, actually Python has similar mechanisms
07:02:32 <bennofs> hugomg: idk if there are even that many packages on hackage working with big ADTs.
07:02:44 <ski> tdammers : or, if we ignore zero, access the magnitude of a complex number represented in rectangular coordinates
07:02:44 <tdammers> but I think the usual approach is to wrap stuff with decorators and such
07:02:51 <tdammers> yeah, I get it
07:03:19 <tdammers> public function __get($key) { if ($key == "length") { return count($this->data); } } // oh boy
07:03:35 * tdammers sobs
07:03:49 <bennofs> tdammers: is that PHP?
07:03:52 <tdammers> bennofs: yeah
07:04:07 <tdammers> basically, that's how you make virtual properties in PHP
07:05:48 <bennofs> > over (subtracting 3) (*4) 4
07:05:49 <lambdabot>  7
07:06:14 <clrnd> :t substracting
07:06:15 <lambdabot>     Not in scope: ‘substracting’
07:06:15 <lambdabot>     Perhaps you meant ‘subtracting’ (imported from Numeric.Lens)
07:06:19 <clrnd> :t subtracting
07:06:20 <lambdabot> (Profunctor p, Num a, Functor f) => a -> p a (f a) -> p a (f a)
07:06:31 <bennofs> subtracting :: Num a => a -> Iso' a a
07:07:11 <ski> > over (subtracting 3) (*4) 8
07:07:12 <lambdabot>  23
07:07:31 <osener> Hi everyone, I'm new to haskell and don't have much experince using conduits. I'm trying to download a file using http-conduit and I'm stuck at something. Here is the code for the downloader: https://gist.github.com/osener/f0dcea018fb72ebed3e0
07:07:31 <osener>  
07:07:59 <osener> downloadFile takes an url, a filename to save and an updater function. It saves the incoming data to a file and calls the updater with current progress percentage. I'm supplying an updater function that shows the progress in the UI and if it reaches 100.0 calls a shell script. This works most of the time but in some cases updater gets called with 100.0 when the last bits of data hasn't flushed to the disk yet. Any idea how can I make
07:08:00 <osener> sure the file has downloaded completely before calling the shell script?
07:08:51 <osener> the code is based on this snippet by snoyberg: https://github.com/yesodweb/yesod/wiki/Consume-a-webpage-with-http-conduit-and-print-progress-along-the-way
07:09:50 <osener> I swapped the composition of sinks so that progress reporting comes after file writing which solved the problem in most cases but it still persists with some urls
07:09:51 <bitonic> how do I print the decimal representation of a Rational?  something like `showRational :: Int -> Rational -> String', where Int is the number of digits
07:11:32 <malllle> bitonic: something like: take n (show rat)?
07:11:58 <bitonic> > show (5 % 3)
07:12:00 <lambdabot>  "5 % 3"
07:12:00 <clrnd> :t fromRational
07:12:01 <lambdabot> Fractional a => Rational -> a
07:12:10 <clrnd> > fromRational 5 % 3
07:12:11 <lambdabot>  No instance for (GHC.Show.Show a0)
07:12:11 <lambdabot>    arising from a use of ‘M49113114444487216305893.show_M49113114444487216305...
07:12:11 <lambdabot>  The type variable ‘a0’ is ambiguous
07:12:11 <lambdabot>  Note: there are several potential instances:
07:12:11 <lambdabot>    instance [safe] GHC.Show.Show
07:12:17 <clrnd> > fromRational $ 5 % 3
07:12:18 <lambdabot>  1.6666666666666667
07:12:45 <bennofs> osener: would it be possible to call the script not from the updater, but from downloadFile directly? I think it should work if you just call the script after doing the responseBody res $$+ ... stuff
07:12:58 <bitonic> clrnd: right, but like that you go through to double
07:12:58 <clrnd> > printf "%.2f" (fromRational (5 % 3))
07:13:00 <lambdabot>  No instance for (GHC.Show.Show a0)
07:13:00 <lambdabot>    arising from a use of ‘M26944670201689240795917.show_M26944670201689240795...
07:13:00 <lambdabot>  The type variable ‘a0’ is ambiguous
07:13:00 <lambdabot>  Note: there are several potential instances:
07:13:00 <lambdabot>    instance [safe] GHC.Show.Show
07:13:14 <clrnd> > printf "%.2f" (fromRational (5 % 3) :: Double)
07:13:15 <lambdabot>  No instance for (GHC.Show.Show a0)
07:13:15 <lambdabot>    arising from a use of ‘M54246552134968993715942.show_M54246552134968993715...
07:13:15 <lambdabot>  The type variable ‘a0’ is ambiguous
07:13:15 <lambdabot>  Note: there are several potential instances:
07:13:15 <lambdabot>    instance [safe] GHC.Show.Show
07:13:25 <clrnd> whatever, yeah but maybe you need to go to Double
07:14:32 <clrnd> > printf "%.2f" $ fromRational (5 % 3)
07:14:34 <lambdabot>  No instance for (GHC.Show.Show a0)
07:14:34 <lambdabot>    arising from a use of ‘M57336382162243675635971.show_M57336382162243675635...
07:14:34 <lambdabot>  The type variable ‘a0’ is ambiguous
07:14:34 <lambdabot>  Note: there are several potential instances:
07:14:34 <lambdabot>    instance [safe] GHC.Show.Show
07:14:37 <clrnd> that works in GHCI damn
07:15:10 <bennofs> > printf "%.2f" $ fromRational (5 % 3) :: String
07:15:12 <lambdabot>  "1.67"
07:15:17 <bennofs> there you go
07:15:30 <clrnd> ohhhhhhhhhhhh
07:15:32 <clrnd> :t printf
07:15:33 <lambdabot> PrintfType r => String -> r
07:15:51 <bitonic> bennofs: yeah but again, you're going through Double.  it just seemed weird that there isn't a direct function
07:16:54 <bennofs> osener: that would also make sure that you still call the script even if for some reason (I don't trust floating point) the percentage doesn't exactly reach 100%
07:21:11 <osener> bennofs: supplying the `done` function and calling it after that was my last resort but I failed to that because of my lack of knowledge in haskell. For some reason the script wasn't getting called at all so I gave up early and decided to ask here
07:21:58 <osener> bennofs: I'll get back to you after I give it another go. But if the progress is not 100% the script shouldn't be called at all since it extracts the file
07:22:43 <bennofs> osener: well, i meant that because of floating point rounding errors, the progress could be 99.999999999999999999999 instead of 100 and the file was still downloaded fully (i
07:22:58 <bennofs> but I'm not an floating point expert
07:23:05 <clrnd> osener, in any case you shouldn't decide your actions based on the progress but directly from the download
07:23:32 <clrnd> I don't know conduit but I'm sure it has the tools for that
07:23:35 <fds4345> anyone know how to lens map over (a, a, a) to get (b, b, b) ?
07:23:43 <bennofs> fds4345: use over each
07:23:44 <osener> bennofs: yeah you are right, it's better to handle that case
07:23:53 <bennofs> > over each (+2) (1,2,3)
07:23:55 <lambdabot>  (3,4,5)
07:24:00 <fds4345> sweet thanks
07:24:59 <osener> I was monitoring console output to make sure it reached 100% once the script was called so in this case it wasn't the problem but that doesn't say that it won't ever happen
07:26:00 <bennofs> osener: I think https://gist.github.com/bennofs/955cbaf4037e6c73e8b8 is how it should look with an explicit "done" action (not a conduit expert either :p)
07:27:43 <osener> bennofs: ok it worked this time, i think the problem was I should've called it as "liftIO done"
07:27:57 <osener> thanks for your guidance!
07:29:40 <hsk8> If  f :: a -> b,  g :: c -> d   and f $#$ g :: a -> d  for some given operator $#$,  does it follow that  (f $#$ g) x = f x $#$ g   ?
07:29:44 <hsk8> I don't see why
07:29:45 <lib> @run 2**3
07:29:46 <lambdabot>  8.0
07:34:23 <tdammers> hsk8: it doesn't follow, but there are not a lot of other possible useful implementations
07:37:14 <hsk8> tdammers: so far example, why is   return x >>= f   =  \x -> (return x >>= f)   ?
07:37:20 <hsk8> For the monadic >>= and return
07:37:25 <hsk8> I don't see that assumption stated anywher
07:37:30 <hsk8> e.
07:37:40 <hsk8> for* example
07:37:54 <tdammers> ah, I see
07:38:04 <bennofs> hsk8: they didn't say that that is equal.
07:38:14 <bennofs> hsk8: the article added an \x -> ... on both sides
07:38:47 <hsk8> bennofs: thanks for remember my original context :D
07:38:47 <bennofs> hsk8: it's like in math: a = b  -- multiple by 3 on both sides: 3a = 3b. But that doesn't imply that b = 3b
07:38:47 * hackagebot Nomyx-Language 0.7.3 - Language to express rules for Nomic  http://hackage.haskell.org/package/Nomyx-Language-0.7.3 (CorentinDupont)
07:38:49 * hackagebot Nomyx-Core 0.7.3 - A Nomic game in haskell  http://hackage.haskell.org/package/Nomyx-Core-0.7.3 (CorentinDupont)
07:43:23 <athan> Is there a functor for instantiating a variable? Say I have type `Foo`, and I want to bring it to a type `a -> Foo`, or `(Fooable a) => a -> Foo`, or something of that nature?
07:43:47 * hackagebot Nomyx-Web 0.7.3 - Web gui for Nomyx  http://hackage.haskell.org/package/Nomyx-Web-0.7.3 (CorentinDupont)
07:43:49 * hackagebot Nomyx 0.7.3 - A Nomic game in haskell  http://hackage.haskell.org/package/Nomyx-0.7.3 (CorentinDupont)
07:44:35 <HeladoDeBrownie> athan, I'm having trouble understanding your question. For example, I don't get how you're using "functor".
07:44:44 <bennofs> athan: so do you have a value v :: Foo, and you want a value f :: a -> Foo ? In that case, you can use 'const v :: a -> Foo'
07:45:52 <athan> bennofs: I actually want to use the variable, that's why I'd like the Fooable constraint (or maybe have both be variables with the constraint, I'm not sure)
07:46:12 <athan> I was actually thinking of a monoid instance, where the `a` variable would just be appended
07:46:29 <bennofs> athan: can you give a concrete example for the datatype Foo ?
07:46:33 <bennofs> athan: just something simple
07:46:43 <athan> ehh, how about []?
07:46:59 <athan> so something like `[] -> a -> []`
07:47:03 <athan> er sorry
07:47:06 <athan> crud
07:47:31 <athan> I'd begin with a `[]` and then end with a `[] -> []`
07:47:52 <bennofs> ? what should that be? a function or a type?
07:47:58 <athan> (where really I'm trying to use multiparams and functional dependencies to manage the actual data types)
07:48:00 <HeladoDeBrownie> [] has kind * -> *, but the parameters of (->) must have kind *
07:48:03 <athan> it should result in a function
07:48:32 <athan> so it creates a parameter on the input, by just appending the parameter to the input
07:48:34 <HeladoDeBrownie> athan, can you describe your use case?
07:48:51 <athan> so I'd have foo :: [a], thing(foo) :: [a] -> [a]
07:49:06 <athan> where thing x = \y -> x ++ y
07:49:09 <athan> or something
07:49:20 <athan> :T
07:49:25 <bennofs> so just mappend?
07:49:28 <HeladoDeBrownie> That's not a use case
07:49:41 <athan> actually
07:49:43 <athan> yeah hahaha
07:49:46 <bennofs> :t let foo :: [a]; foo = undefined in mappend foo
07:49:47 <lambdabot> [a] -> [a]
07:50:06 <athan> wow
07:50:14 <athan> this kind of thinking is nuts for me hahaha
07:50:15 <bennofs> :t let foo :: x; foo = undefined in mappend foo
07:50:16 <lambdabot> Monoid a => a -> a
07:50:17 <athan> thank you bennofs
07:52:12 <exio4> > let foo x = (let y = x <> y in y) in foo [1,2,3,4]
07:52:13 <lambdabot>  [1,2,3,4,1,2,3,4,1,2,3,4,1,2,3,4,1,2,3,4,1,2,3,4,1,2,3,4,1,2,3,4,1,2,3,4,1,2...
07:52:30 <exio4> \o/
07:52:49 <bennofs> congratulations, you have just invented cycle!
07:53:00 <bennofs> > cycle [1,2,3,4]
07:53:02 <lambdabot>  [1,2,3,4,1,2,3,4,1,2,3,4,1,2,3,4,1,2,3,4,1,2,3,4,1,2,3,4,1,2,3,4,1,2,3,4,1,2...
07:53:05 <lengzai> :t (<>)
07:53:06 <lambdabot> Monoid m => m -> m -> m
07:53:20 <bennofs> if m is a list, (<>) is just (
07:53:20 <exio4> bennofs: but cycle is only for lists.. :P
07:53:23 <bennofs> :)
07:53:23 <Taneb> bennofs, that is a generalized cycle
07:53:54 <lengzai> :t (:)
07:53:55 <lambdabot> a -> [a] -> [a]
07:55:40 <bennofs> > (mconcat . repeat) [1,2,3,4]
07:55:41 <lambdabot>  can't find file: L.hs
07:55:42 <bennofs> > (mconcat . repeat) [1,2,3,4]
07:55:44 <lambdabot>  [1,2,3,4,1,2,3,4,1,2,3,4,1,2,3,4,1,2,3,4,1,2,3,4,1,2,3,4,1,2,3,4,1,2,3,4,1,2...
07:56:26 <clrnd> what's the L.hs thing? it happens randomly
07:56:38 <bennofs> clrnd: a race condition in lambdabot I think
07:56:43 <nshepperd> gah, the allure of code golf
07:57:04 <clrnd> a race cond in haskell? they sold me this didn't happen D:
07:57:16 <nshepperd> > let mcycle = fix . (<>) in mcycle [1,2,3,4]
07:57:17 <lambdabot>  [1,2,3,4,1,2,3,4,1,2,3,4,1,2,3,4,1,2,3,4,1,2,3,4,1,2,3,4,1,2,3,4,1,2,3,4,1,2...
07:57:43 <bennofs> Ah, I just thought "this looks like fix" :)
07:57:49 <AR45> Haskell is quite different.
07:58:11 <lib> :t
07:58:47 * hackagebot creatur 5.8.2 - Framework for artificial life experiments.  http://hackage.haskell.org/package/creatur-5.8.2 (AmyDeBuitleir)
07:58:59 <lib> :t (:)
07:59:00 <lambdabot> a -> [a] -> [a]
07:59:21 <lib> :t 1.0
07:59:22 <lambdabot> Fractional a => a
08:03:22 <EvanR> Peaker: i found this blurb from linux on the subject of close (on linux, though he asserts his opinion about what other implementations do). close is "guaranteed" to really close the fd no matter what, and then it might return an error too. at least its not nondeterministic, at least on this one platform ;)
08:03:52 <EvanR> if you throw an exception in this case, then it would violate exception safety. so dont throw an exception? ;)
08:04:21 <EvanR> Peaker: werent you saying some case where you are left with a dangling open fd?
08:08:47 * hackagebot Nomyx-Language 0.7.4 - Language to express rules for Nomic  http://hackage.haskell.org/package/Nomyx-Language-0.7.4 (CorentinDupont)
08:08:49 * hackagebot Nomyx-Core 0.7.4 - A Nomic game in haskell  http://hackage.haskell.org/package/Nomyx-Core-0.7.4 (CorentinDupont)
08:08:51 * hackagebot Nomyx-Web 0.7.4 - Web gui for Nomyx  http://hackage.haskell.org/package/Nomyx-Web-0.7.4 (CorentinDupont)
08:08:53 * hackagebot Nomyx 0.7.4 - A Nomic game in haskell  http://hackage.haskell.org/package/Nomyx-0.7.4 (CorentinDupont)
08:14:51 <AR45> Is Haskell easy to learn?
08:16:28 <lucs> AR45: In my relative-beginner opinion, no.
08:16:34 <michaelt> AR45: Yes and no?
08:16:42 <lengzai> AR45: it depends
08:16:47 <lengzai> it's easy to get started
08:16:51 <batchm> haskell has a steep learning curve
08:16:56 <lengzai> but it's such a deep language
08:17:04 <batchm> but it is worth it,
08:17:19 <lengzai> it's not deep in the same sense as C++
08:17:21 <lengzai> imo
08:17:32 <AR45> C is to programming as learning basic anatomy is to a medical doctor. C is a "machine level" language, so you'll learn how a program interacts with the hardware and learn the fundamentals of programming at the lowest—hardware—level (C is the foundation for Linux/GNU). You learn things like debugging programs, memory management, and how computers work that you don't get from higher level languages like
08:17:33 <sivteck> the language itself is very very very small ;p
08:17:34 <AR45> Java—all while prepping you to code efficiently for other languages. C is the "grandfather" of many other higher level languages, including Java, C#, and JavaScript.
08:18:12 <lucs> AR45: Have you started reading the cis194 lectures yet?
08:18:24 <AR45> lucs no I bookmarked them and went to bed.
08:18:30 <lengzai> haskell has very simple syntax, different, but simple
08:18:49 <lengzai> the difficulty comes in the sheer power that the simplicity gives you
08:18:59 <mauris> how do i get a program to listen on multiple ports simultaneously?
08:19:08 <mauris> i'm using Network right now but i feel like i might need Network.Socket :(
08:19:15 <AR45> Now I'm up trying to inquire which language is best for an absolute beginner to learn first
08:19:22 <AR45> Most people have said C and Perl.
08:19:35 <lengzai> not perl
08:19:37 <lucs> Some people still say Perl?
08:19:37 <dv-> perl? ugh
08:19:38 <lengzai> python
08:19:53 <AR45> So what's wrong with Perl?
08:19:55 <lengzai> python over perl always #opinion
08:19:59 <lucs> I'm a Perl programmer, and I love it, but I wouldn't recommend it as a first language.
08:20:00 <ChristianS> AR45: python is a good choice, yes
08:20:01 <AR45> & what's better with Python?
08:20:20 <ChristianS> AR45: easier syntax, more users
08:20:21 <knyon> lambda calculus. It's how I got my wife to learn. It's more like a paper-and-pencil game than programming
08:20:45 <lengzai> i believe knyon is referring to haskell, not python
08:21:00 <Peaker> EvanR: ah, OK, that might be the case. My understanding was based on the manpage but I might have missed something
08:21:22 <knyon> I'm meaning what to teach an 'absolute beginnner'. That's where I've had the best luck teaching principles
08:22:12 <knyon> no, there's no lamdba calculus programming language, but it's an easier translation to ML or Haskell
08:22:49 <lengzai> python is quite logical and it's easy to get productive very quickly with the language
08:23:44 <vanila> lambda calculus can be considered a language in its own,  just an extremely extremely minimal one
08:23:56 <batchm> AR45  learning C doesn't teach you how computers actually work any more than learning how to drive stick teaches you how a car actually works. for example C has a simple memory model that in no way reflects what actual hardware does in any way shape or form.
08:24:03 <lengzai> haskell also, but you need to learn a whole different set of skills
08:24:07 <osfameron> perl's block scoping is far closer to lisp's than python's is.  This might make some concepts about scoping and closures easier coming from Perl (arguably :-)
08:24:40 <Peaker> batchm: it has pointers and pointer arithmetic which reflects hardware somewhat..
08:24:45 <batchm> C is an abstraction over the actual hardware. a lower level abstraction, granted, but still an abstraction
08:25:01 <Peaker> batchm: everything is also unboxed which is "closer" to hardware than languages that box
08:25:59 <bitonic> batchm: oh cmon.  C teaches you more about how what kind of instruction a computer accepts than Haskell
08:26:25 <bitonic> so it is a good language if you want to learn that
08:26:31 <lengzai> C teaches you more about how a computer really works in real life
08:27:00 <lengzai> in that sense it's very practical
08:27:03 <vanila> assembly teaches better abot how your computer works
08:27:12 <lengzai> that's true
08:27:28 <vanila> C is mostly about confusing people will ill defined semantics
08:28:09 <bitonic> bah.  I think that for a person that is starting to program knowing C is still extremely useful.  it also depends on what your goals are
08:28:12 <lengzai> I wouldn't say so, unless you delve into some of the nether regions of the spec
08:28:37 <bitonic> AR45: what do you want to program?
08:28:38 <lengzai> C can be used in a completely transparent way
08:28:40 <vanila> C is good to know if you use a computer because it empowers you a lot
08:28:48 * hackagebot wai-route 0.3 - Minimalistic, efficient routing for WAI  http://hackage.haskell.org/package/wai-route-0.3 (romanb)
08:28:53 <knyon> I think the obsession with learning to be productive is misguided. You don't learn arithmetic in order to become productive as a cashier. Yes, that's what can fall out of it, but it's not the purpose of learning. Learn the principles and concepts first; learn hwo to apply them second
08:29:00 <AR45> bitonic stuff to make me money
08:29:05 <vanila> it's a terrible language that shouldn't be used anything like as often as it is, but since it is - knowing it gives you the ability to hack/repair most software you use
08:29:10 <vanila> (assuming that it is free software)
08:29:12 <bitonic> AR45: mhm.  that's a bit vague.  making money how?
08:29:20 <AR45> bitonic on the internet :D
08:29:30 <AR45> bitonic making web apps
08:29:54 <johannes__> then Javascript is unfortunately the language to learn, I would say
08:30:04 <blicero> is it possible to make scoped typeclass instances? for example if i wanted to define an instance of Ord that depends on parameters read from IO?
08:30:13 <bitonic> AR45: with Haskell you can get started making web apps pretty quickly.  so you'll get closer to your goal and you'll have fun quickly.  although in that space I'd say most people use some dynamic language (python, ruby, php, etc.)
08:30:19 <zennist> How can I write a function that takes a function and a list and apply that list as the arguments to the function?
08:30:40 <zennist> e.g. apply f [a1, a2] = f a1 a2
08:30:41 <HeladoDeBrownie> blicero, not as such, no.
08:30:42 <vanila> zennist, like apply (+) [1,2] --> 3 ? not possible
08:30:49 <zennist> vanila: why not?
08:30:52 <EvanR> Peaker: yeah the man page is not telling that story very precisely
08:30:57 <hseg> blicero: Not really. Although, you could write something using the reflection package.
08:31:06 <Peaker> blicero: nope, but Ord is contravariant on the type - so you might be able to stick it into the type
08:31:10 <zennist> I tried apply = foldl id but it gives me Occurs error
08:31:12 <vanila> zennist, there's no good type for 'apply' function
08:31:22 <ij> zennist, id is arity 1, you need 2
08:31:26 <vanila> you could create apply1, apply2, apply3, ...
08:31:28 <hseg> zennist: What type would apply have?
08:31:29 <vanila> separate functions
08:31:43 <vanila> (and possibly make a typeclass that selects the right one)
08:33:09 <danilo2> Hello! Is there in lesnes (or anything else) a function which will convert (a,a,a,a,a,...) into [a] ? I can easly do it using typeclasses, but I would prefer an existing solution :)
08:33:41 <HeladoDeBrownie> edwardk would know even if no one else
08:33:59 <HeladoDeBrownie> The solution is likely to involve a typeclass anyway
08:35:01 <danilo2> HeladoDeBrownie: I know, but I would love not to duplicate any code. So I edwardk Is here I would be thankful for answering it, iff not -- maybe someone knows? :)
08:35:21 <indiagreen> > (1,2,3) ^.. each
08:35:23 <lambdabot>  [1,2,3]
08:35:29 <indiagreen> danilo2: ^
08:35:47 <HeladoDeBrownie> Sure, I wasn't disagreeing about reusing code. Code reuse is good :)
08:35:56 <danilo2> indiagreen: wow
08:36:00 <clrnd> magic
08:36:07 <danilo2> indiagreen: I was not thinking about such each use, thank you!
08:36:12 <HeladoDeBrownie> @type each
08:36:17 <lambdabot> (Each s t a b, Applicative f) => (a -> f b) -> s -> f t
08:36:28 <HeladoDeBrownie> Interesting.
08:36:36 <bennofs> each :: Each s t a b => Traversal s t a b
08:36:56 <nshepperd> > execWriter (each (tell . (:[])) (1,2,3,4))
08:36:58 <lambdabot>  [1,2,3,4]
08:37:16 <danilo2> indiagreen: ahh it does not work :( view each ("a","b") gives "ab" :(
08:37:38 <bennofs> danilo2: toListOf each ("a", "b") does what you want
08:37:43 <bennofs> > toListOf each ("a", "b")
08:37:45 <lambdabot>  ["a","b"]
08:37:52 <danilo2> bennofs: great! thank you very much1
08:37:54 <FireFly> @ty toListOf
08:37:54 <danilo2> :)
08:37:55 <lambdabot> Getting (Endo [a]) s a -> s -> [a]
08:38:07 <bennofs> danilo2: also notice that indiagreen used ^.. (=toListOf) instead of ^. (=view)
08:38:09 <bennofs> :)
08:38:16 <zennist> What is 'each' function?
08:38:19 <zennist> Where is it defined
08:38:22 <HeladoDeBrownie> lens package
08:38:23 <bennofs> zennist: lens package
08:38:25 <HeladoDeBrownie> @hackage lens
08:38:25 <bennofs> @hackage lens
08:38:25 <lambdabot> http://hackage.haskell.org/package/lens
08:38:25 <lambdabot> http://hackage.haskell.org/package/lens
08:38:27 <bennofs> :)
08:38:28 <HeladoDeBrownie> jinx
08:38:28 <zennist> thanks
08:38:29 <L8D> lens package
08:38:33 <HeladoDeBrownie> L8D, so late :P
08:38:38 <nshepperd> :t toListOf
08:38:38 <danilo2> bennofs: oh, you are right. Sorry indiagreen and thank you! :)
08:38:39 <lambdabot> Getting (Endo [a]) s a -> s -> [a]
08:38:45 <L8D> I just got my coffee... :(
08:38:46 <nshepperd> the joy of lenses
08:39:03 <HeladoDeBrownie> L8D, don't worry, you can be first or second on a pile of answers another time
08:39:14 <YKY> how do I define a data type that is a set of lists, using Data.Set perhaps?
08:39:17 <bennofs> toListOf :: Fold s a -> s -> [a] -- simplified type
08:39:38 <YKY> I mean what should be the definition syntax
08:39:52 <HeladoDeBrownie> YKY, the type would be Set [Foo] where Foo are the list elements
08:39:54 <clrnd> lens package
08:40:12 <HeladoDeBrownie> YKY, to actually make one you'd just use insert and the like with these lists and a set of that type
08:40:31 <HeladoDeBrownie> or fromList on a list of lists of Foo
08:40:33 <YKY> it says "expecting one more argument to 'Set'"
08:40:42 <HeladoDeBrownie> YKY, what is your expression?
08:40:58 <HeladoDeBrownie> Or, er, code
08:41:00 <YKY> data NF = NF Set [Int]
08:41:11 <HeladoDeBrownie> NF (Set [Int])
08:41:16 <bennofs> YKY: you need parentheses, like data NF = NF (Set [Int])
08:41:25 <clrnd> type Lol = Set [Int]
08:41:36 <YKY> ah....  =)
08:41:54 <YKY> thanks  =)
08:42:05 <HeladoDeBrownie> The way you wrote it, NF would take a value of type Set and another of type [Int], but that doesn't work because Set is not concrete
08:42:20 <HeladoDeBrownie> (I.e., its kind is not *)
08:42:31 <YKY> how about the type statement?
08:42:39 <clrnd> type is just like an alias
08:42:40 <L8D> did haskell.org come back online yet?
08:43:04 <YKY> it seems to work
08:43:06 <clrnd> type Name = String
08:43:09 <phaazon> hey, I have a graph – as a list of (node,node) (edges)
08:43:11 <clrnd> it dependes on what you want
08:43:18 <phaazon> I saw Data.Graph
08:43:27 <bennofs> but type doesn't create a new datatype, just an alias
08:43:28 <phaazon> is it a good module to deal with graphs?
08:43:30 <YKY> I want to make it like an ADT
08:43:38 <bennofs> YKY: then don't use type :)
08:43:46 <phaazon> I especially need to extract strongly connected components
08:43:57 <YKY> but the "data" statement was wrong?
08:44:03 <HeladoDeBrownie> YKY, if you write type NF = Set [Int], that means that NF is now totally interchangeable with Set [Int]. If you write data NF = NF (Set [Int]), you are defining a new type altogether, it just contains a Set [Int] value.
08:44:13 <HeladoDeBrownie> YKY, it wasn't wrong, it depends on what you want.
08:44:14 <bitraten> regarding ReaderT: with mtl I can ask inside of IO, can i do the same with transformers?
08:44:16 <L8D> nooo!
08:44:19 <L8D> nooooooo!
08:44:20 <L8D> stawp
08:44:23 <L8D> stawp using 'type'
08:44:35 <clrnd> I really like type ... :(
08:44:38 <L8D> bad HeladoDeBrownie !
08:44:45 <EvanR> stop using types
08:44:47 <L8D> use 'newtype' !
08:44:51 <EvanR> they are bad for the environment
08:44:54 <HeladoDeBrownie> L8D, I'm not the one who brought that up, I was merely explaining
08:45:07 <bennofs> clrnd: until you hit a bug where you passed a Date (type Data = Int) instead of an Age (type Age = Int) ... .P
08:45:26 <bennofs> bitraten: what do you mean with "ask inside IO"? do you have an example?
08:45:27 <L8D> bad clrnd or whoever brought that up !
08:45:30 <clrnd> I know I know, I've found them but it's just so easy to use them ...
08:45:38 <HeladoDeBrownie> L8D, anyway, I would appreciate it if you chasisted me you would at least explain why :P
08:45:55 <EvanR> help im trapped in IO and cant get out
08:46:00 <L8D> oh... type is bad because then you can mix the alias with the actual type
08:46:11 <HeladoDeBrownie> L8D, and so... ?
08:46:25 <HeladoDeBrownie> Anyway, it seems like the asker wanted data regardless
08:46:25 <L8D> so I could do things like: readFile name where name :: Name
08:46:29 <bennofs> @let type Age = Int; type Size = Int
08:46:32 <lambdabot>  Defined.
08:46:32 <EvanR> use type when you want to mix it with the actual type
08:46:55 <L8D> > (1 :: Age) + (6000 :: Size)
08:46:56 <lambdabot>  6001
08:47:02 <HeladoDeBrownie> L8D, I know and understand all that. Sometimes you do want that, as a way of making a longer type more manageable for example.
08:47:19 <L8D> HeladoDeBrownie: using newtype enforces that those types won't get mixed unless your code explicity mixes them
08:47:21 <clrnd> exactly, like when creating transformer stacks
08:47:31 <L8D> ok.
08:47:37 <bennofs> HeladoDeBrownie: yeah, I only uses type for things like type Lens' s a = Lens s s a a (filling some type args)
08:47:49 <L8D> but you should prefer to use newtype over type
08:47:54 <HeladoDeBrownie> L8D, I'm sorry, I think you're estimating me as at a lower level of knowledge than I am. I don't need this explanation, but thanks for trying to help.
08:48:03 <vanila> http://comonad.com/reader/2014/letter-to-a-young-haskell-enthusiast/
08:48:18 <L8D> HeladoDeBrownie: I made the assumption when you "you would at least explain why"
08:48:21 <EvanR> also `type's can be curried
08:48:32 <L8D> I didn't know who you wanted me to explain too
08:48:37 <L8D> to*
08:48:40 <bitraten> bennofs: in mtl: ask :: MonadReader r IO => IO r     in transformers: ask :: Monad IO => ReaderT r IO r
08:48:52 <HeladoDeBrownie> L8D, well, because it's not obvious that type should be avoided. I do acknowledge it's only appropriate in specific circumstances though.
08:49:01 <bennofs> > ask :: IO Int
08:49:02 <lambdabot>  No instance for (Control.Monad.Reader.Class.MonadReader
08:49:02 <lambdabot>                     GHC.Types.Int GHC.Types.IO)
08:49:02 <lambdabot>    arising from a use of ‘Control.Monad.Reader.Class.ask’
08:49:09 <bennofs> bitraten: doesn't seem to work
08:51:41 <edwardk> vanila: the only problem with that article is that by writing it, Gershom raised the quality bar so high that I've been reluctant to bump it from the leading slot on comonad.com for more banal posts ;)
08:53:51 <bitraten> bennofs: I am trying to rebuild https://github.com/silkapp/rest/blob/master/rest-example/example-api/Api/Post.hs#L76 with transformers instead of mtl. Is this possible at all?
08:56:10 <zennist> OK I've just started reading on Lens. One quick question: why does the function composition seems to go in the wrong direction..?
08:56:34 <zennist> e.g. _1.mapped takes the first field and does 'mapped'. Although I expect to read from right to left
08:56:59 <zennist> at least from my experience with fmap it seems more natural for me read from right..
08:57:40 <EvanR> edwardk: "In functional programming, our proofs are not by contradiction, but by construction"
08:57:48 <EvanR> head explode ;)
08:59:48 <bennofs> bitraten: why do you want to do it with transformers alone? You'd need to expose the implementation of BlogApi (from ApiTypes.hs) for that (e.g. use a type synonym instead of a newtype)
09:00:51 <bennofs> But that would make the code less flexible, as it'd then explicity use ReaderT everywhere, so you can't later decide to e.g. use an IORef for the ServerData or a StateT without needing to change all the code
09:01:17 <bitraten> bennofs: well I figured less dependencies were better, but thanks for your answer.
09:01:35 <bennofs> bitraten: also, rest-core (which you use) already depends on mtl, so you can't avoid it anyway
09:03:25 <bennofs> @let _fst f (a,b) = fmap (\x -> (x,b)) $ f a
09:03:27 <lambdabot>  Defined.
09:03:37 <bennofs> @let _snd f (a,b) = fmap (\x -> (a,x)) $ f b
09:03:38 <lambdabot>  Defined.
09:03:42 <bennofs> :t _fst
09:03:43 <lambdabot> Functor f => (t -> f t1) -> (t, t2) -> f (t1, t2)
09:03:47 <bennofs> :t _fst._snd
09:03:48 <lambdabot> Functor f => (t -> f t3) -> ((t1, t), t2) -> f ((t1, t3), t2)
09:05:20 <bennofs> zennist: notice how this also "composes backwards"
09:06:06 <zennist> bennofs: what is the 'this' you are refering to?
09:06:09 * HeladoDeBrownie remembers that post on r/haskell about how it isn't actually backwards
09:06:27 <bennofs> :t _fst  -- like traverse over the first element of a tuple
09:06:28 <lambdabot> Functor f => (t -> f t1) -> (t, t2) -> f (t1, t2)
09:06:35 <zennist> HeladoDeBrownie: mind just quickly helping me go over that?
09:06:55 <bennofs> :t _fst._snd     -- like traverse over the snd element of the fst element of a tuple ("composes backwards")
09:06:56 <HeladoDeBrownie> I'm looking for it
09:06:56 <lambdabot> Functor f => (t -> f t3) -> ((t1, t), t2) -> f ((t1, t3), t2)
09:07:11 <edwardk> zennist: it happens in part because we have to cps things.
09:07:46 <edwardk> zennist: but the net effect is that you can read (.) as the object oriented programmer's dot, so this weirdness becomes just the right thing to someone who expects that.
09:08:04 <edwardk> foo^.bar.baz.quux    -- goes and gets foo's bar field, the baz field from that and the quux field from that.
09:08:13 <HeladoDeBrownie> zennist, I'm having trouble finding it, but the lens master is answering you now anyway :)
09:08:43 <zennist> HeladoDeBrownie: cool thank you anyway
09:09:11 <edwardk> i used to think of it as backwards, now i think of it as 'the only sensible way it can work'
09:09:38 <zennist> edwardk: I'm reading up on cps right now, beginning to understand what you said
09:09:45 <edwardk> and getting (.) from FP and (.) from OOP to pun is incredibly happy-making
09:10:43 <bennofs> @unlet
09:10:43 <lambdabot>  Define what?
09:10:46 <bennofs> @undef
09:10:46 <lambdabot> Undefined.
09:11:44 <zennist> edwardk: sorry I still can't make sense out of it
09:12:09 <EvanR> something besides . for composition, and . for "OOP" would make more sense to me
09:12:25 <michaelt> > Just 12  &  ((. show) . (.reverse) . (. words) . (. map reverse)) id
09:12:27 <lambdabot>  ["12","Just"]
09:12:28 <EvanR> im ok with different symbols for different things in the same sentence
09:12:33 <zennist> I understand that objective style might be convenient, but since we are dealing with a functional language anyway so why not just stick to the convention...
09:12:47 <michaelt> ^^ zennist it isn't any different from this
09:13:03 <bennofs> zennist: here is another example. Assume overFst f maps f over the first element of a tuple, and overFst maps over the second element of a tuple
09:13:08 <bennofs> :t overFst
09:13:09 <lambdabot> (a -> b) -> (a, c) -> (b, c)
09:13:10 <bennofs> :t overSnd
09:13:11 <lambdabot> (a -> b) -> (c, a) -> (c, b)
09:13:15 <EvanR> > [1,2,3] <&> succ & sum
09:13:16 <lambdabot>  9
09:13:33 <edwardk> zennist: intuition is a powerful thing. what you are asking for isn't a thing that is possible. lens literally does the only sensible thing it can do here
09:14:03 <edwardk> zennist: composing the other way can't happen, so effectively you'd be asking it not to exist =P
09:14:10 <bennofs> zennist: then, (overFst.overSnd) f will then map f over the second element of the first element of a tuple (=> backwards composition)
09:14:21 <bennofs> :t overFst.overSnd
09:14:22 <lambdabot> (a -> b) -> ((c1, a), c) -> ((c1, b), c)
09:14:35 <edwardk> if you call 'map.map' you don't invoke lens, but they 'compose' in the manner lenses do.
09:14:37 <edwardk> :t map.map
09:14:38 <lambdabot> (a -> b) -> [[a]] -> [[b]]
09:14:44 <edwardk> that isn't obvious but
09:14:47 <edwardk> :t map.fmap
09:14:48 <lambdabot> Functor f => (a -> b) -> [f a] -> [f b]
09:14:55 <edwardk> you can see the 'f' is on the inside
09:15:06 <edwardk> this happens with traverse.traverse
09:15:09 <edwardk> foldMap.foldMap
09:15:13 <edwardk> types that have been around since forever
09:15:38 <edwardk> :t (.).(.)
09:15:39 <lambdabot> (b -> c) -> (a -> a1 -> b) -> a -> a1 -> c
09:15:50 <edwardk> all of these idioms have been around in haskell since the dawn of time
09:16:00 <edwardk> lens just extends the pattern
09:16:18 <edwardk> they all 'compose backwards'
09:16:59 <torpet> I am using a datatype which provides a function, how would I access it?
09:17:16 <torpet> This question is as noobish as it sounds, I'm just missing the point
09:17:27 <zennist> bennofs: your overFst and overSnd example is really useful
09:17:35 <michaelt> torpet: say more ...
09:17:37 <zennist> I think I understand it now :)
09:17:51 <torpet> http://lpaste.net/8936314843904868352
09:18:43 <michaelt> torpet: well, you can define an accessor, getFunction (Tree f _ _) = f , for one thing
09:18:43 <seangrov`> Is there a way to clean this up? https://www.refheap.com/93638
09:18:55 <danilo2> Hello! Is there a funtion in lenses which would allow me to do something like: over each (+1) (1,(2,()))  ?
09:19:09 <Peaker> is there a nice package that can derive Monoid via GHC.Generics?
09:19:20 <bennofs> danilo2: if you like magic, you can use biplate for that
09:19:32 <bennofs> > over biplate (+1) (1,(2,()))
09:19:34 <lambdabot>  (2,(3,()))
09:19:42 <torpet> michaelt: oh right accessor functions
09:19:49 <torpet> it's been a long day
09:19:51 <zennist> edwardk: mind I asking the difference between 'mapped' and 'each'?
09:19:55 <torpet> thanks
09:19:55 <Peaker> I thought generic-deriving was it, but it has its own silly GenericMonoid class and it wants an instance to exist for the TVs
09:19:56 <danilo2> bennofs: I love magic in such situations where it just simplifies a code. Thank you, I will look into biplate :)
09:19:56 <bennofs> danilo2: that will find the targets by looking for things that have the right Type
09:19:58 <EvanR> Magic | MoreMagic
09:20:04 <seangrov`> I think anagrams could be a bit cleaner without the anonymous helper function
09:20:26 <michaelt> torpet: but if you are trying to define a function on trees you just 'pattern match', writing myfunction (Tree f a xs) = f a or whatever
09:20:32 <edwardk> 'each' is a sort of magic 'do what i mean' traversal. mapped is a setter.
09:20:44 <torpet> michaelt: thanks
09:20:47 <torpet> helped me a lot
09:20:49 <Peaker> edwardk: about GHC.Generics being slow: :-(   Ideally all the Generic mess could be inlined away?
09:20:50 <edwardk> each can be written to do whatever evil monomorphic thing your container needs
09:20:56 <edwardk> Peaker: they don't
09:21:05 <edwardk> Peaker: they are just awful performance wise
09:21:23 <Peaker> is it because GHC doesn't specialize instance code enough?
09:21:32 <bennofs> edwardk: I thought Generics had special compiler support, compared to SYB?
09:21:32 <edwardk> no idea
09:21:57 <Peaker> edwardk: TH has a huge compile-time penalty, btw
09:22:05 <edwardk> bennofs: doesn't matter. compare Data.Data.Lens.tinplate to GHC.Generics.Lens.tinplate, its night and day
09:22:07 <Peaker> when runtime doesn't matter much, getting rid of TH can be nice
09:22:44 <danilo2> edwardk: Why not? Why all the generics could not be inlined away?
09:22:48 <edwardk> Peaker: i agree, but in general generics work much less of the time and the performance hit is _ridiculous_
09:23:00 <edwardk> danilo2: i'm just stating what happens in practice
09:23:15 <danilo2> edwardk: oh, ok
09:23:41 <torpet> michaelt: But I think the getFunction you posted should use the constructor Node right?
09:24:04 <edwardk> GHC.Generics is one of those things where my pragmatist hat was on. i tried rebuilding all of Data.Data.Lens with GHC.Generics and i just couldn't get past the performance slump
09:24:32 <danilo2> so If we want to use *plates we shoudl always stick with generics now because theyu are much faster than anything else?
09:24:53 <Peaker> What's a good way to derive tedious instances like Monoid? GHC.Generics doesn't seem right, and it has the data-abstraction problem too
09:25:05 <danilo2> or I missunderstand that one
09:25:06 <Peaker> The "derive" package TH is one solution but it doesn't constrain the instances correctly
09:25:07 <michaelt> torpet: right, sorry I used the type name, not the constructor
09:25:19 <torpet> michaelt: Cool
09:25:20 <Peaker> It always uses recursive constraints, even when unneeded :(
09:25:37 <bennofs> danilo2: I think edwardk said Data.Data.Lens was faster than the generics stuff
09:25:54 <danilo2> bennofs: Oh, I missread your comment about special compiler support for generics, right
09:26:15 <danilo2> bennofs: anyway I do not understand why it is not "free" - compiler can (as far as I know) inline it out :(
09:26:17 <dreixel> Peaker: you certainly could use GHC.Generics.
09:26:25 <michaelt> torpet, it's slightly confusing but you can recycle the type name as a construction, and this is often done data Tree = Tree (Label -> Label) Label [Tree]  ... I was replacing your type-definition with that one.
09:26:27 <edwardk> danilo2: it has special support, its just not fast =)
09:26:54 <torpet> michaelt: I think it's also possible with an implicit constructor, is that right?
09:27:00 <michaelt> torpet: which has nothing to be said for it over data Tree = Node (Label -> Label) Label [Tree] except one is occasionally at a loss for names...
09:27:39 <michaelt> torpet: Oh, I meant constructor by construction of course.
09:27:53 <michaelt> torpet: anyway, yes you were right above
09:27:53 <danilo2> edwardk: heh :)
09:28:08 <danilo2> edwardk: is there any info if someone is working on that to make it "transparent" ?
09:28:53 <Peaker> dreixel: There doesn't seem to be any package that uses GHC.Generics to derive Monoid, except generic-deriving, which requires a GMonoid constraint recursively
09:29:21 <Peaker> meaning I cannot have:  instance Monoid a => Monoid (Foo a) where { use the default impls here }. I need:   instance GMonoid a => Monoid (Foo a) where ...  <-- requiring Generic to be everywhere!
09:29:28 <torpet> michaelt: Ok think I got it
09:29:41 <bennofs> Peaker: I think this might be a limitation of GHC.Generics itself
09:29:58 <bennofs> Peaker: either you cannot support recursive types, or you need a constraint everywhere iirc
09:32:31 <Peaker> bennofs: then I guess fixing the TH is the only way
09:33:10 <dreixel> Peaker: I think you should just use GMonoid everywhere, and not Monoid
09:33:39 <Peaker> dreixel: hmm.. I am looking at snoyman's code and it doesn't seem to have this problem
09:33:46 <dreixel> Peaker: although you could even add a |instance GMonoid a => Monoid a| if you're ok with OverlappingInstances
09:34:04 <pointed_set> are that combinators from those Edward's "optics"?
09:34:09 <dreixel> Peaker: GHC.Generics certainly doesn't have any problem with recursive types.
09:34:12 <Peaker> just the generic-deriving package seems broken
09:34:18 <Fuuzetsu> I wish that Google stopped searching for ‘pseudomonas’ when I search for something with ‘pseudomonads’ in it ;(
09:34:42 <Peaker> dreixel: oh, generic-deriving is yours?
09:34:51 <ocharles> Can I use `timeout` with `Network.Socket.connect`? It's unclear to me if `connect` would block the RTS
09:34:56 <dreixel> Peaker: yep. why do you think it's broken?
09:35:27 <dreixel> Peaker: basically, you should use GMonoid instead of Monoid if you want generics. That's because the former has default signatures, which makes it more convenient to use
09:35:34 <Peaker> dreixel: because using Snoyman's def_append, def_mempty, I get the correct Monoid constraint (none or (Monoid a)) depending on whether "a" is used in the type. With generic-deriving I think I get a GMonoid constraint on the "a" leaking there
09:35:47 <hsk8> Here, http://mvanier.livejournal.com/4586.html
09:35:47 <hsk8> Why can he "substitute f for g, g for h" ?
09:35:50 <hsk8> I don't get that step.
09:35:50 <Peaker> dreixel: but then I'm not able to re-use the entire Haskell eco-system which is based on Monoid
09:36:01 <Peaker> dreixel: which loses most of the point of Monoid in the first place, I think
09:36:31 <dreixel> Peaker: you certainly have a good point there. but what about the |GMonoid a => Monoid a| suggestion?
09:36:54 <hsk8> hmm, never mind
09:36:56 <Peaker> dreixel: That overlaps with *everything*, that's very bad
09:37:03 <hsk8> i keep forgetting it's for ALL functions f,g,h
09:37:07 <Peaker> instance heads are selected with no regard at all to their constraints
09:37:11 <dreixel> Peaker: I know :-)
09:37:19 <dreixel> but OverlappingInstances...
09:37:36 <Peaker> dreixel: would you accept a pull request to change GMonoid constraints to Monoid constraints when possible?
09:37:45 <Peaker> I think GMonoid should be considered an implementation detail
09:39:42 <dreixel> Peaker: I think the package is trying to say that GMonoid is what Monoid should be. All other functions in the package are implemented in that same style.
09:40:01 <Peaker> What's the point of "M1" in GHC.Generics?
09:40:22 <dreixel> Peaker: but I'm not thinking too much about this. please feel free to open a pull request or a bug to force me to think it through :-)
09:40:32 <Peaker> I think I understand U1, :*:, :+:, K1, V1. What's M1?
09:40:41 <dreixel> Peaker: alternatively, you could implement your own. basically you want to change this instance: |instance GMonoid a => GMonoid' (K1 i a)|
09:40:46 <dreixel> M1 is for meta-data
09:40:52 <Peaker> what kind of meta-data?
09:40:52 <bitonic> has anybody ripped out the very useful `Criterion.Measurement' module in a different package?
09:40:57 <dreixel> Peaker: http://hackage.haskell.org/package/generic-deriving-1.7.0/docs/Generics-Deriving-Base.html#g:5
09:41:03 <bitonic> I'm not particularly keen in pulling criterion as a dependency of my program
09:41:25 <Peaker> dreixel: I looked at that page, it doesn't explain what M1 means
09:41:30 <nkar> is there a way to omit 'otherwise -> return ()' in a multiway if but achieve the same result?
09:41:54 <merijn> nkar: No
09:41:58 <EvanR> otherwise = return (), or _ -> return () right
09:42:08 <EvanR> if its a failed pattern match, thats fail
09:42:29 <EvanR> better to be explicit though
09:42:42 <nkar> okay, thanks
09:42:45 <Peaker> you could use "when" or "unless" in the last branch under "otherwise"
09:43:10 <dreixel> Peaker: there's a little bit more here: https://www.haskell.org/haskellwiki/GHC.Generics
09:43:31 <L8D> wait... is there a Monad instance for (a ->) ?
09:43:32 <dreixel> Peaker: but eventually it refers you to Section 2.1 of the paper
09:43:51 <L8D> omg there is!
09:43:54 <EvanR> L8D: thats Reader
09:44:10 <L8D> oh yeah...
09:44:42 <EvanR> which is an awesome monad ;)
09:44:51 <L8D> I guess I've never used it
09:45:22 <L8D> cause' it's like state but without the put
09:45:37 <EvanR> ReaderT over IO gives you an environment that may contain mutable storage cells
09:47:09 <merijn> You don't need ReaderT IO for that
09:47:22 <L8D> where's the source code for GHC.Base
09:47:23 <merijn> You can just do "Reader (IORef Int)"
09:47:33 <L8D> or wherever instance Monad (a ->) is
09:47:46 <EvanR> merijn: but you wouldnt be able to modify the IORef
09:48:31 <merijn> EvanR: "Reader (IORef Int) (IO ())"
09:49:18 <EvanR> trying to think of how that would change a ReaderT IO program
09:49:47 <jeltsch> merijn: Reader r (IO a) is isomorphis to ReaderT r IO a, but the Monad instances are different.
09:50:03 <merijn> jeltsch: No it's not
09:50:23 <merijn> jeltsch: The latter can hide arbitrary IO during the reader approach
09:50:34 <merijn> @unmtl Reader r (IO a)
09:50:34 <lambdabot> r -> (IO a)
09:50:50 <merijn> hmm, actually I guess the unmtl is the same
09:50:53 <EvanR> they can both "hide" IO
09:51:05 <merijn> Still, the former is restricted in *where* the IO can be while writing
09:51:28 <EvanR> interesting
09:51:36 <jeltsch> merijn: They are essentially the same types, and their implementations are public. So you can construct the same things with them.
09:52:11 <jeltsch> merijn: The difference is that the (>>=) and return of ReaderT r IO a also do (>>=) and return on the underlying IO.
09:52:37 <merijn> jeltsch: Sure, but I can also "construct the same thing" in any two Turing complete systems, which tells me that the value of that observation is pretty limited
09:52:39 <jeltsch> merijn: With Reader r (IO a), you have to explicitly deal with the IO values.
09:53:12 <merijn> In other words, they are *not* the same
09:53:28 <jeltsch> merijn: The types are isomorphic.
09:53:36 <jeltsch> merijn: They essentially have the same values.
09:53:40 <merijn> Which is a pretty useless piece of trivia in the real world
09:53:58 <jeltsch> merijn: It is not. State s, for example, is different from Reader s.
09:54:07 <merijn> Word is isomorphic to [()]
09:54:21 <merijn> (Well, the new Natural discussed in libraries@ is)
09:54:25 <jeltsch> merijn: No, because Word has a fixed bit size. :-)
09:55:03 <jeltsch> merijn: In the Reader/ReaderT example, both types are not just isomorphic, but have essentially the same implementation (r -> IO a).
09:55:07 <merijn> Fine, Integer and [Bool] if you're going to be difficult about Natural not yet existing
09:55:27 <opqdonut> merijn: false, consider (repeat True)
09:55:28 <merijn> isomorphism only matters if you don't care about operational behaviour
09:55:28 <EvanR> im more interested in the real difference of writing programs with a bunch of Reader e (IO a)s
09:55:28 <jeltsch> merijn: Natural exists in my natural-numbers package.
09:55:49 <exio4> opqdonut: that is the same as the integer "x = 1 + x"
09:55:54 <merijn> It's very obvious that Reader and ReaderT are not operationally the same
09:56:08 <jeltsch> merijn: In what way are they not operationally the same?
09:56:16 <opqdonut> exio4: no, that's _|_ and we also have a _|_ in [Bool]
09:56:27 <exio4> different bottoms
09:56:37 <merijn> jeltsch: For one I can "runReader" without sideeffects, I can't runReaderT without sideeffects
09:56:41 <merijn> exio4: No such thing
09:56:46 <merijn> exio4: All bottoms are identical
09:56:54 <opqdonut> exio4: and repeat True is not bottom, as "head" will tell you :)
09:56:58 * joeyh wonders where to report the bug that the instuctions on https://www.haskell.org/platform/linux.html have a typo in the path to the activate-hs script
09:56:59 <EvanR> "ignoring bottoms"
09:57:11 <opqdonut> EvanR: and codata
09:57:40 <jeltsch> merijn: runReader and runReaderT are two different things. But Reader/ReaderT are operationally the same in that you can do the same operations with them (maybe with different code) and internally the same things will happen.
09:57:57 <merijn> "if they're the same then they're the same"
09:58:22 <EvanR> you need to clearly define the kind of sameness
09:58:44 <merijn> My argument is that writing a "Reader" that has the same behaviour as an arbitrary ReaderT is non-trivial
09:59:04 <jeltsch> merijn: I think, it is clear in what Reader r (IO a) and ReaderT r IO a are the same: both are r -> IO a internally and this internal structure is exposed to the userj.
09:59:08 <merijn> So very clearly Reader is making some things harder to write than ReaderT and there is value in that
09:59:48 <merijn> Programmers live in the real actual world and the difficulty of writing code that does X matters more than the fact that you can conceptually write it
09:59:58 <jeltsch> merijn: Depends. If you explicitly write your Readers and ReaderTs by Reader someFun  and ReaderT someFun, then it is exactly the same.
10:00:00 <merijn> Anyway, I have more productive things to do :)
10:00:12 <EvanR> i guess in the original context, if you had the idea of an environment of mutable variables, and thats *it*, then using IO at all is not the best plan
10:00:27 <jeltsch> merijn: Why are you discussing then about details if it is clear what I meant?
10:00:59 <merijn> jeltsch: Because I'm pointing out that what you meant is a fairly useless fact in the real world
10:01:44 <jeltsch> merijn: No, it is not. Because the similarity between the two reader things is stronger than the one between Natural and [()]. In the latter case, performance is completely different, in the reader case it is the same.
10:01:46 <joeyh> https://github.com/haskell/haskell-platform/issues/148 it seems
10:01:50 <EvanR> not all isomorphisms are equal? Bool and Ok | Error, Either a b and Error a | Ok b
10:03:57 <favetelinguis> in clojure we have partition, what would be the same in haskell?
10:04:25 <EvanR> :t chunk
10:04:25 <lambdabot> Int -> [e] -> [[e]]
10:05:01 <EvanR> partition seems to have a lot of functionality
10:05:17 <EvanR> but basically its trying to chunk
10:05:34 <favetelinguis> yes i only need the basic usecase
10:05:39 <favetelinguis> works fine thanks
10:06:13 <sinelaw> favetelinguis, next time you can hoogle it by type
10:06:26 <sinelaw> @hoogle Int -> [a] -> [[a]]
10:06:28 <lambdabot> Prelude drop :: Int -> [a] -> [a]
10:06:28 <lambdabot> Data.List drop :: Int -> [a] -> [a]
10:06:28 <lambdabot> Prelude take :: Int -> [a] -> [a]
10:06:35 <EvanR> blub
10:06:43 <sinelaw> oops. use the website ... will show more reuslts.
10:07:03 <JonReed> Is it possible to pattern match a typeclass? So if type matches it returns one result, otherwise it returns another result.
10:07:04 <dfeuer> Is there a library with a version of fast exponentiation for general Monoids?
10:08:11 <dfeuer> xplat, do you know?
10:08:27 <JonReed> Is something like this possible?  http://lpaste.net/114580
10:08:52 <EvanR> exponentiation by squaring might be easy to just write, based on this wikipedia page
10:09:02 <dfeuer> JonReed, I don't understand the comment at the bottom.
10:09:18 <favetelinguis> sinelaw: hoogle does not show chunk if i serch for name or type
10:09:27 <dfeuer> EvanR, no, it's not hard to write simple versions, but there are some crazy fancy ones referenced on Wikipedia that might minimize "multiplications".
10:10:22 <dfeuer> Oh, JonReed, are you hoping to show it if it's in Show, and otherwise give a generic message? I don't think you can do that, no.
10:10:29 <JonReed> dfeuer: It's suppose to return another error if a has a show instance
10:10:50 <dfeuer> JonReed, there's no way, at runtime, to know if it has a Show instance.
10:11:16 <sinelaw> favetelinguis, weird. I can find it in Data.List.Split as chunksOf
10:11:37 <favetelinguis> ok i will check that out
10:11:48 <sinelaw> http://hackage.haskell.org/package/split-0.2.1.1/docs/Data-List-Split.html
10:12:01 <EvanR> :t chunksOf
10:12:02 <lambdabot> Int -> [e] -> [[e]]
10:12:10 <sinelaw> favetelinguis, that's in package "split"
10:12:11 <EvanR> chunk existed in an old version
10:12:34 <sinelaw> hoogle seems to not know about any of these
10:12:48 <sinelaw> is hoogle missing packages?
10:12:59 <dfeuer> JonReed, you can try to do some really ugly/horrible things faking similar things sometimes using FlexibleInstances with OverlappingInstances (or IncoherentInstances) but that gets you well into horrible horrors that you don't ever ever want to touch.
10:13:15 <EvanR> maybe hoogle suffered a labotomy yesterday
10:13:28 <Fuuzetsu> add +split to your search
10:13:29 <sinelaw> "what chunks?"
10:13:48 * hackagebot uhc-light 1.1.7.1 - Part of UHC packaged as cabal/hackage installable library  http://hackage.haskell.org/package/uhc-light-1.1.7.1 (AtzeDijkstra)
10:13:56 <sinelaw> Fuuzetsu, yip
10:13:59 <sinelaw> favetelinguis, https://www.haskell.org/hoogle/?hoogle=Int+-%3E+[a]+-%3E[[a]]+%2Bsplit
10:14:07 <sinelaw> Fuuzetsu, but that misses the point of hoogle
10:14:11 <EvanR> if you already know the package then..
10:14:28 <Fuuzetsu> hayoo does more packages by default
10:14:34 <sinelaw> to find where a function is defined, first tell us where the function is defined
10:14:35 <Fuuzetsu> but you can just list a bunch of packages always
10:14:56 <EvanR> if google required you to list a bunch of websites to search ;)
10:15:10 <dfeuer> Is Hoogle integrated into Hackage?
10:15:21 <benzrf> dfeuer: i dont think so
10:15:37 <dfeuer> benzrf, that seems kind of an obvious thing to do, no?
10:15:47 <dfeuer> Hoogle/Hayoo/whatever
10:15:50 <benzrf> i kno
10:16:18 <Fuuzetsu> Hackage provides hoogle file dumps
10:16:20 <sinelaw> is it just me or is hayoo's ui buggy?
10:16:21 <Fuuzetsu> that's it
10:17:42 <dfeuer> I also wish they let me be more precise about type signatures and which parts matter how. Like "must have a context that's a subclass of Functor" or "can have a context but must be satisfied by (Functor, Monoid)"
10:17:56 <EvanR> according to hayoo, Int -> [a] -> [[a]] has a wealth of interpretations ;)
10:18:05 <sinelaw> EvanR, and none of them are "chunksOf"
10:18:22 <sinelaw> plus the "next page" button doesn't seem to work
10:18:34 <EvanR> none of them are in the split package
10:18:46 <sinelaw> right
10:19:00 <Fuuzetsu> bitching here won't change anything you know
10:19:25 <EvanR> uses "did you know, if you need a function of a certain type, you can go to haskell IRC channel?"
10:19:42 <sinelaw> Fuuzetsu, I'm not bitching I asked "is it only me"
10:19:50 <sinelaw> not sure if the bug is on my side or not
10:20:01 <EvanR> my next button also does not function
10:20:10 <sinelaw> ok.
10:20:14 <xplat> dfeuer: i'm unaware of such a library for general monoids
10:20:22 <dfeuer> Thanks, xplat.
10:21:35 <sinelaw> Hayoo server is sending back this error when you click "next":
10:21:36 <sinelaw> (line 1, column 9):
10:21:36 <sinelaw> unexpected '['
10:21:36 <sinelaw> expecting "\\", "^", space, white space, "++", "NEAR", "FOLLOW", "AND", "OR" or end of input
10:26:51 <EvanR> for me the default packages searched, on hoogle, is a single package "text", so i think theres something wrong with it
10:27:32 <EvanR> nevermind
10:35:39 <ReinH> FPComplete has a Hoogle that searches its Stackage, I believe. It tends to give more complete answers than the "official" one. https://www.fpcomplete.com/hoogle
10:36:07 <ReinH> For example, it finds chunksOf https://www.fpcomplete.com/hoogle?q=Int+-%3E+%5Ba%5D+-%3E+%5B%5Ba%5D%5D+&env=ghc-7.8-stable-14.09
10:36:42 <benzrf> what is stackage
10:36:47 <sinelaw> ReinH, cool. was it very slow for you as well?
10:36:58 <ReinH>  Not too slow...
10:37:20 <sinelaw> for me it's in the 10 second range
10:37:30 <sinelaw> but yeah, it's more complete
10:37:34 <sinelaw> chunksOf is the first result
10:37:35 <sivteck> Stackage™ = Stable Hackage
10:37:41 <EvanR> hence the name
10:37:44 <clrnd> stackage is stable hackage, is a static colleciton of packages that work in harmony
10:37:55 <clrnd> (in theory)
10:37:59 <sinelaw> benzrf, it's like the haskell platform, basically, but with more packages and a different way to decide what goes in
10:38:08 <sinelaw> "kind of"
10:38:20 <benzrf> oh
10:38:26 <sinelaw> a set of packages guaranteed to build together with no dependency issues
10:38:27 <benzrf> this sounds familiar
10:38:43 <benzrf> how does StateT on reader differ from readert on state
10:39:26 <sinelaw> in harmony and theory
10:40:07 <jeltsch> benzrf: Let’s see:
10:40:20 <jeltsch> @unmtl StateT s (Reader r) a
10:40:20 <lambdabot> s -> (Reader r) (a, s)
10:40:36 <jeltsch> @unmtl ReaderT r (State s) a
10:40:36 <lambdabot> r -> (State s) a
10:40:51 <EvanR> recursive unmtl
10:40:56 <jeltsch> Hmm, unmtl is not recursive.
10:41:14 <benzrf> i know
10:41:15 <benzrf> sad
10:41:16 <jeltsch> EvanR: How can I recursively use unmtl.
10:41:28 <jeltsch> benzrf: Okay, then manually
10:41:29 <benzrf> @. unmtl unmtl ReaderT r (State s) a
10:41:29 <lambdabot> r -> (State s) a
10:41:34 <benzrf> laaaaame
10:42:02 <benzrf> so they are isomorphic by flip, right
10:42:02 <EvanR> s -> (r -> (a,s))
10:42:07 <jeltsch> StateT s (Reader r) a is s -> r -> (a, s).
10:42:23 <EvanR> r -> (s -> (s,a))
10:42:26 <jeltsch> ReaderT r (State s) a is r -> s -> (a, s).
10:42:34 <jeltsch> Indeed, they are isomorphic.
10:42:44 <benzrf> ebin
10:42:49 <jeltsch> More than isomorphic. They are “basically the same”.
10:42:54 <jeltsch> Interesting.
10:42:54 <EvanR> haha
10:42:57 <benzrf> um, jeltsch
10:43:00 <benzrf> that's what iso means
10:43:11 <nkar> can I run cabal build with -Wall without reconfiguring?
10:43:49 <jeltsch> benzrf: No, I had a long discussion with merijn about this a bit ago.
10:44:10 <jeltsch> benzrf: For example, if we had no lazyness, then Natural and [()] would be isomorphic.
10:44:22 <jeltsch> benzrf: But the representation is completely differentjd
10:44:46 <jeltsch> With this State–Reader thing, representations are exactly the same, except swapping of function arguments.
10:45:45 <benzrf> jeltsch: with Natural and [()], representations are exactly the same except for the extra pointer to ()
10:45:58 <jeltsch> benzrf: ???
10:45:58 <EvanR> exactly the same except
10:46:08 <EvanR> morphism
10:46:38 <jeltsch> benzrf: Ah, you think of the Natural defined via Zero and Succ. I was thinking about the Natural from my super-duper-cool natural-numbers package.
10:46:45 <jeltsch> Which is implemented as Integer.
10:46:49 <benzrf> should i use StateT (Reader R) or StateT ((->) R)
10:47:19 <jeltsch> benzrf: If you do not want to use the readers explicitly as functions, then I would use Reader instead of (->).
10:47:41 <jeltsch> Seems to say more precisely what you mean.
10:48:08 <benzrf> mm
10:48:30 <EvanR> > monus 5 6
10:48:31 <lambdabot>  Not in scope: ‘monus’
10:49:17 <ReinH> jeltsch: why are Nat and [()] not isomorphic with laziness?
10:49:24 <chrisdone> (-> r) is the path to confusion. confusion leads to anger. anger leads to hate. hate leads to suffering
10:49:25 <ReinH> What does "the representation is completely different" mean?
10:49:44 <ReinH> "The representation" doesn't really matter
10:49:47 <EvanR> jeltsch: you have a view for zero or succ, what about a view for less than (which could support a minus operation that didnt need to deal with the GT case)
10:49:54 <EvanR> less than or equal
10:50:24 <ReinH> What matters is whether or not you have morphisms that form an isomorphism. And you do: foldNat Z = []; foldNat (S n) = () : foldNat n
10:50:29 <jeltsch> If Natural is implemented as Integer, then a value is either ⊥ (bottom) or fully defined.
10:50:33 <ReinH> and a similar fold from [()] to Nat
10:50:49 <jeltsch> ReinH: With [()], you have partially defined things like () : ⊥.
10:51:02 <ReinH> jeltsch: and with Nat you have S _|_
10:51:07 <jeltsch> ReinH: The representation matters for performance etc.
10:51:24 <jeltsch> ReinH: As I said, I am talking about Natural defined as Integer internally.
10:51:28 <chrisdone> he just said it's presented as n integer
10:51:47 <jeltsch> newtype Natural = Natural Integer
10:51:53 <ReinH> Ah, then you have isomorphic up to bottoms
10:52:01 <jeltsch> ReinH: So to say.
10:52:07 <ReinH> which is how we usually like to think of Hask anyway
10:52:12 <jeltsch> ReinH: In a strict language, they would be isomorphic.
10:52:23 <ReinH> They are isomorphic *up to bottoms*
10:52:37 <ReinH> which removes the strict/non-strict distinction
10:52:45 <jeltsch> ReinH: I don’t like to think of it that way, because the effects of lazyness are often important. But yes, sometimes we tend to ignore this a bit.
10:53:03 <ReinH> jeltsch: We usually like to throw bottoms out when treating Hask as a category
10:53:04 <jeltsch> ReinH: Has “up to bottoms” a precise mathematical definition?
10:53:24 <EvanR> does Hask even have a precise definition
10:53:27 <ReinH> @google fast and loose rasoning
10:53:28 <lambdabot> http://www.cse.chalmers.se/~nad/publications/danielsson-et-al-popl2006.html
10:53:28 <lambdabot> Title: Fast and Loose Reasoning is Morally Correct
10:53:28 <chrisdone> surely “down to bottoms”? =p
10:53:39 <mads-> People keep telling me how easy Parsec is. The examples (and tutorials) I am finding seems too involved for me to understand completely. Could anyone hint to me how I would parse a String "(Times (Plus 3 4) 5)" into the data type I have here? http://pastebin.com/1mScMDgD ?
10:53:40 <EvanR> raisening
10:53:45 <ReinH> EvanR: Yes. Hask is the category of Haskell types and functions
10:53:53 <jeltsch> ReinH: Absolutely not. I would say the most reasonable definition of Hask is that objects are domains and morphisms are domain homomorphisms.
10:54:11 <ReinH> chrisdone: "up to X" means http://en.wikipedia.org/wiki/Up_to
10:54:26 <ReinH> jeltsch: Ok, but that is not what people mean by Hask
10:54:46 <ReinH> @google haskellwiki hask
10:54:47 <lambdabot> http://www.haskell.org/haskellwiki/hask
10:54:49 <jeltsch> ReinH: I don’t know what “people” mean by Hask. Maybe different people mean different things here.
10:55:00 * chrisdone retracts his pun from seriouscat
10:55:08 <benzrf> mads-: do you understand how IO works in haskell?
10:55:09 <ReinH> "Hask is the category of Haskell types and functions."
10:55:11 <seangrov`> I have a data type, data ShipType = Carrier | Battleship | Submarine | Cruiser | Destroyer deriving (Show) - and I have another data type Ship { _type :: ShipType}
10:55:14 <EvanR> ok at least one precise definition of Hask is enough
10:55:23 <EvanR> that satisfies the constructive proof
10:55:34 <benzrf> jeltsch: what do you mean by domains
10:55:37 <josephle> proof of the existence of Hask?
10:55:41 <ReinH> Without bottoms it has nice properties, like being a CCC, which means you have internal homs, which means you have currying
10:55:42 <EvanR> hehe
10:55:44 <seangrov`> I'd like to write a sizeOf fn that takes a Ship, and pattern matches off of the _type field, but I'm not sure of the syntax, or if it's possible
10:55:54 <ReinH> We like to program in categories with exponentials
10:55:56 <jeltsch> ReinH: Actually on http://www.haskell.org/haskellwiki/hask, they *do* care about bottoms.
10:56:07 <jeltsch> Otherwise, Hask would be cartesian-closed, etc.
10:56:19 <ReinH> jeltsch: yes, that's what CCC means
10:56:25 <seangrov`> Can I pattern match the custom ShipType inside of the sizeOf fn?
10:56:33 <ReinH> jeltsch: see 3. "Platonic" Hask
10:56:39 <ReinH> this is what people prefer to use
10:56:43 <ReinH> see the fast and loose paper
10:57:04 <chrisdone> seangrov`: you can write f (Ship thetype) = …  to bring the type in as a variable
10:57:06 <ReinH> "Platonic" Hask is a much nicer category, being cartesian-closed and such
10:57:06 <jeltsch> ReinH: But this page shows that there is in fact no common definition of Hask.
10:57:20 <chrisdone> seangrov`: or f (Ship Carrier) = …; f (Ship Submarine) = … to do a case analysis on the type
10:57:25 <jeltsch> ReinH: I know. We should use Agda, which is platonic by design. :-)
10:57:29 <jeltsch> No bottoms!
10:57:29 <ReinH> jeltsch: Ok. It's usually a good idea to specify what the category is anyway.
10:57:29 <chrisdone> seangrov`: alternatively f (Ship ty) = case ty of …
10:57:48 <ReinH> I've never heard Hask used to refer to domains and domain homomorphisms
10:57:54 <jeltsch> evanr: I didn’t understand your comment about natural numbers and ≤-views.
10:57:57 <seangrov`> chrisdone: Ah, I think case may be the way to go
10:58:15 <ReinH> jeltsch: Haskell people like denotational semantics, but maybe not quite that much ;)
10:58:39 <_1_funny> cool
10:58:44 <ReinH> jeltsch: speaking of denotational semantics, we just interviewed Conal Elliott and discussed denotation a bit
10:58:45 <EvanR> jeltsch: monus is total but fills in artificial zeros, you could also have minus that takes some sort of proof that the arguments are LTE
10:59:03 <benzrf> what is monus
10:59:07 <jeltsch> EvanR: That’s right. Do you think this would be useful?
10:59:12 <EvanR> i dont know
10:59:22 <ReinH> chrisdone: get your puns out of here, Haskell already has enough punning thank you very much
11:00:16 <EvanR> benzrf: minus on naturals extended to be defined as zero for a < b in a - b
11:00:33 <EvanR> auto zero just weirds me out
11:00:39 <seangrov`> chrisdone: That worked perfectly, thanks!
11:00:49 <benzrf> >ships
11:00:50 <benzrf> >platonic
11:00:54 <benzrf> these do not go together tsk
11:00:54 <merijn> dcoutts_: ping?
11:01:01 <chrisdone> seangrov`: welcome =)
11:01:49 <EvanR> jeltsch: well the default is crash so thats fine
11:02:14 <RyanGlScott> Why can you derive instances (using Template Haskell) for data types that don't export their constructors?
11:03:10 <clrnd> mads-, you have to work in parts. for example, I'd start with "so I need to parse something between parenthesis"
11:03:18 <RyanGlScott> e.g., $(deriveJSON defaultOptions ''Duration), using Duration from the active library, is perfectly fine, even though it seems to pattern-match on Duration
11:03:42 <clrnd> parsec3 has a combinator, between, so I'd say let parens = between (char '(') (char ')')
11:04:30 <danilo2> Hello! :) Would somebody be so nice and tell me if can I write thisc code more efficiently in haskell ? I just want to append something to list under specific key in map or create single list when the key was not found. The simple solution is: Map.insertWith (++) "x" [p1] $ Map.empty
11:04:31 <seangrov`> And is this idiomatic, if I'm making a game board for battleship, and I want to have a Spot data type, that may contain a ship or nothing: data Spot = Just Ship | Nothing
11:04:58 <clrnd> seangrov`, Maybe Ship
11:05:41 <phaazon> hey, I’d like to know
11:05:43 <phaazon> oops :D
11:05:57 <seangrov`> clrnd: That's what I was wondering, thanks
11:05:58 <phaazon> I was saying, I’d like to know more about pipe
11:06:29 <phaazon> I read the documentation and it sounds a bit like some kind of FRP to me
11:06:37 <phaazon> (not time-related though)
11:07:12 <merijn> phaazon: pipes is about a unrelated to FRP as you can be...
11:07:13 <phaazon> I’m just curious about how the interaction is performed between a producer and a consumer
11:07:39 <merijn> phaazon: It's basically a CPS transform, iirc
11:07:58 <phaazon> CPS ?
11:08:05 <merijn> phaazon: Tekmo has a blog, I think he has a few posts on the design of pipes
11:08:12 <merijn> phaazon: Continuation Passing Style
11:08:33 <phaazon> interesting
11:08:40 <ReinH> phaazon: We also talk about it a bit on the haskell cast
11:08:56 <zq> :t insertWith
11:08:58 <lambdabot>     Not in scope: ‘insertWith’
11:08:58 <lambdabot>     Perhaps you meant one of these:
11:08:58 <lambdabot>       ‘IM.insertWith’ (imported from Data.IntMap),
11:09:05 <zq> :t IM.insertWith
11:09:06 <lambdabot> (a -> a -> a) -> IS.Key -> a -> IM.IntMap a -> IM.IntMap a
11:09:44 <phaazon> I think I can use pipes in my 3D engine
11:09:52 <phaazon> if it does what I think
11:09:56 <phaazon> especially the Effect type
11:11:57 <merijn> phaazon: pipes is mostly useful for stream processing
11:12:36 <merijn> I wouldn't exactly know how it would fit into a 3D engine
11:12:49 <merijn> Maybe you should have a look at netwire?
11:13:34 <koala_man> danilo2: I don't know what kind of optimizations ghc does, but maybe  insertWith (const (x:)) key [x]  is faster since it avoids appending
11:13:37 <phaazon> I know that
11:13:49 * hackagebot persistent-postgresql 2.1.1 - Backend for the persistent library using postgresql.  http://hackage.haskell.org/package/persistent-postgresql-2.1.1 (MichaelSnoyman)
11:14:00 <phaazon> I want to expose a “model–view” way of using photon (the engine)
11:14:11 <phaazon> in a way that is not restricted to a specific monad or applicative functor
11:14:34 <merijn> "not restricted to a specific monad or applicative functor" <- that sounds fairly impossible?
11:14:35 <AnalogFile> what's the problem with haskell.org? it's been up and down (mostly down) for a few days.
11:14:38 <danilo2> koala_man: hmm, interesting. Anyway I just discovered I do not need this anymore because I need to use sets instead of lists there, so I really dont think GHC will optimize "union" operation on sets there :(
11:15:13 <phaazon> merijn: my idea is to connect a view to a model through a monad, of course
11:15:16 <lpaste> monochrom pasted “an s-expression parser” at http://lpaste.net/114582
11:15:23 <phaazon> but that monad would be more like a monad transformer
11:15:26 <merijn> AnalogFile: A migration was planned to a new machine in the near future, yesterday a disk in the RAID volume died and rather than investing time to fix it and THEN invest more time to migrate they made the decission to just migrate immediately
11:15:30 <phaazon> so that the user can still use its application’s monads
11:15:36 <monochrom> mads-: http://lpaste.net/114582
11:15:36 <phaazon> his*
11:15:57 <merijn> AnalogFile: It should be back up, but the new machine hasn't been performance tweaked yet, so it may be slow until that gets done
11:16:22 <ReinH> phaazon: Actually, Tekmo has an "MVC" framework that might be very interesting to you.
11:16:30 <phaazon> ReinH: inded
11:16:31 <phaazon> indeed
11:16:44 <phaazon> https://hackage.haskell.org/package/mvc
11:16:45 <ReinH> phaazon: see http://www.haskellforall.com/2014/04/model-view-controller-haskell-style.html
11:16:45 <phaazon> found it
11:16:49 <ReinH> Yes exactly
11:16:54 <merijn> AnalogFile: See this thread: https://www.haskell.org/pipermail/haskell/2014-November/024370.html
11:16:56 <ReinH> Sounds very much like what you mean
11:17:14 <AnalogFile> merijn: if it's up CLoudFlare hasn't noticed :P
11:17:18 <ReinH> phaazon: I've been wanting to play around with it myself, so let me know how you find it :)
11:17:32 <merijn> AnalogFile: It's working for me
11:17:37 <merijn> AnalogFile: Also, for the future: https://status.haskell.org/
11:17:42 <ReinH> edge caching is hard :(
11:17:57 <phaazon> “The Model is a pure streaming transformation from inputs to outputs
11:17:58 <phaazon> ”
11:18:08 <phaazon> that is why I firstly thought of pipes ;)
11:18:16 <phaazon> because MVC implies streaming
11:18:19 <ReinH> merijn:  Hmm. Perhaps "haskell.org is down" should not be accompanied with an "Operational" tag and a big green box...
11:18:24 <phaazon> ahah
11:18:32 <phaazon> his mvc framework uses pipes :)
11:18:40 <ReinH> Interestingly enough, if you click on it you get the expected red box https://status.haskell.org/pages/incident/537c07b0cf1fad5830000093/546a0ebb947b76831e002bef
11:18:46 <merijn> ReinH: That box was red when it was down
11:19:02 <ReinH> merijn: Ok, but the status message is "www.haskell.org is down"
11:19:03 <merijn> ReinH: It's green now because it's back up
11:19:25 <ReinH> I see.
11:19:40 <ReinH> It would be better if a new status event were published
11:19:46 <ReinH> "haskell.org is back up"
11:19:53 <ReinH> It's quite confusing as is
11:20:06 <AnalogFile> merijn: status.haskell.org works and it says it's all operational. but I cannot access www.haskell.org. I get a CloudFlare error page that says the origin is unreachable.
11:20:19 <seangrov`> If I make a data type, data Spot = Maybe Ship deriving (Show), how can I instantiate a Spot?
11:20:25 <merijn> AnalogFile: Have you tried force refreshing? It works for me
11:20:35 <ReinH> It works for me as well
11:20:39 <benzrf> phaazon: what framework is this
11:20:57 <phaazon> https://hackage.haskell.org/package/mvc
11:21:02 <AnalogFile> merijn: yes. it's not a local cache. I get that from the net.
11:21:02 <ReinH> merijn: see this status page for an example of what I mean: https://status.heroku.com/
11:21:26 <merijn> AnalogFile: Must be a problem with CloudFlare then
11:21:46 <ReinH> merijn: Anyway, it's not your problem, it's just a bit confusing
11:22:01 <bennofs> AnalogFile: maybe visit #haskell-infrastructure if you have problems
11:22:02 <ReinH> It is nice to have a status page though
11:22:16 <Yuras> Peaker: hi, will you have time today?
11:23:12 <AnalogFile> merijn: It could be. but I do not think I can do anything about it as that's where the DNS is pointing me. I'll investigate a little and eventually check with #haskell-infrastructureas bennofs suggests
11:25:44 <statusfailed> is it possible to write a traversal over sublists of a list rather than elements?
11:29:21 <zq> a wha
11:29:29 <zq> :t tails
11:29:30 <lambdabot> [a] -> [[a]]
11:29:41 <zq> :t tails  -- statusfailed: like that?
11:29:42 <lambdabot> [a] -> [[a]]
11:30:04 <statusfailed> :i tails
11:30:13 <zq> :type (tails, inits)
11:30:20 <zq> :t (tails, inits)
11:30:21 <lambdabot> ([a] -> [[a]], [a1] -> [[a1]])
11:31:34 <statusfailed> is that just a function on list though?
11:32:43 <statusfailed> zq: and where did you get it?
11:33:01 <statusfailed> oh, data.list
11:39:34 <dmwit> :t subsequences
11:39:35 <lambdabot> [a] -> [[a]]
11:39:41 <dmwit> :t substrings
11:39:42 <lambdabot> Not in scope: ‘substrings’
11:40:21 <dmwit> I've never heard the term "sublists", so it's not clear exactly what you want.
11:40:43 <dmwit> substrings should be implementable with tails and inits.
11:40:43 <clrnd> > subsequences [1..4]
11:40:44 <lambdabot>  [[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3],[4],[1,4],[2,4],[1,2,4],[3,4],[1,3...
11:44:02 <dmwit> > (tails >=> inits) [1..4]
11:44:03 <lambdabot>  [[],[1],[1,2],[1,2,3],[1,2,3,4],[],[2],[2,3],[2,3,4],[],[3],[3,4],[],[4],[]]
11:44:16 <dmwit> some duplicates there
11:44:48 <dmwit> > (tails >=> drop 1 . inits) [1..4]
11:44:49 <lambdabot>  [[1],[1,2],[1,2,3],[1,2,3,4],[2],[2,3],[2,3,4],[3],[3,4],[4]]
11:45:07 <dmwit> > ([]:) . (tails >=> drop 1 . inits) $ [1..4]
11:45:09 <lambdabot>  [[],[1],[1,2],[1,2,3],[1,2,3,4],[2],[2,3],[2,3,4],[3],[3,4],[4]]
11:48:49 * hackagebot yesod-bin 1.4.0.9 - The yesod helper executable.  http://hackage.haskell.org/package/yesod-bin-1.4.0.9 (MichaelSnoyman)
11:52:47 <ReinH> statusfailed: Can you give the type of the function you are looking for?
11:53:08 <ReinH> Is it just (a -> b) -> [[a]] -> [[b]]?
11:53:12 <ReinH> :t fmap . fmap
11:53:12 <lambdabot> (Functor f1, Functor f) => (a -> b) -> f (f1 a) -> f (f1 b)
11:53:15 <ReinH> er
11:53:17 <ReinH> :t map . map
11:53:18 <lambdabot> (a -> b) -> [[a]] -> [[b]]
11:53:26 <benzrf> traverse . traverse
11:53:33 <benzrf> :t traverse . travserse
11:53:34 <lambdabot>     Not in scope: ‘travserse’
11:53:34 <lambdabot>     Perhaps you meant one of these:
11:53:34 <lambdabot>       ‘traverse’ (imported from Control.Lens),
11:53:41 <benzrf> :t traverse . traverse
11:53:42 <lambdabot> (Traversable t1, Traversable t, Applicative f) => (a -> f b) -> t (t1 a) -> f (t (t1 b))
11:53:49 * hackagebot yesod-static 1.4.0.3 - Static file serving subsite for Yesod Web Framework.  http://hackage.haskell.org/package/yesod-static-1.4.0.3 (MichaelSnoyman)
11:53:55 <ReinH> I'm not sure what "traverse" and "sublist" mean, but traverse . traverse is a valid interpretation
11:54:05 <ReinH> for some values of "traverse" and "sublist" ;)
11:54:08 <benzrf> > over (traverse.traverse) (+1) [[1, 2, 3], [4, 5], [6]]
11:54:10 <lambdabot>  [[2,3,4],[5,6],[7]]
11:54:40 <ReinH> ofc that's just map . map
11:54:59 <ReinH> I want to know if statusfailed wants effectful traversals (Data.Traversable.traverse) or what...
11:55:19 <EvanR> :t traverse
11:55:20 <lambdabot> (Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)
11:56:16 <ReinH> over traverse is fmap with a Traversable constraint
11:58:13 <benzrf> ReinH: oh true
11:58:23 <EvanR> :t over
11:58:24 <lambdabot> Profunctor p => Setting p s t a b -> p a b -> s -> t
11:58:34 <benzrf> > view (traverse.traverse) [[1, 2, 3], [4, 5], [6]]
11:58:35 <lambdabot>  No instance for (GHC.Show.Show a0)
11:58:36 <lambdabot>    arising from a use of ‘M274907513461812344411597.show_M2749075134618123444...
11:58:36 <lambdabot>  The type variable ‘a0’ is ambiguous
11:58:36 <lambdabot>  Note: there are several potential instances:
11:58:36 <lambdabot>    instance [safe] GHC.Show.Show
11:58:39 <benzrf> > toListOf (traverse.traverse) [[1, 2, 3], [4, 5], [6]]
11:58:41 <lambdabot>  [1,2,3,4,5,6]
11:58:47 <benzrf> wait
11:58:50 <benzrf> one second...
11:59:01 <benzrf> ah
11:59:13 <chrisdone> :t over traverse
11:59:13 <lambdabot> Traversable t => (a -> b) -> t a -> t b
11:59:37 <EvanR> Setting ...
11:59:55 <benzrf> EvanR: lens
11:59:58 <benzrf> o3o
12:00:02 <benzrf> :t id over
12:00:03 <lambdabot> Profunctor p => Setting p s t a b -> p a b -> s -> t
12:00:04 <benzrf> oh poo
12:00:17 <clrnd> :t over . each . ^.
12:00:18 <lambdabot> parse error on input ‘^.’
12:00:21 <ReinH> what else were you expecting id to do? :p
12:00:24 <clrnd> :t over . each
12:00:25 <lambdabot>     No instance for (Profunctor p) arising from a use of ‘over’
12:00:25 <lambdabot>     Possible fix:
12:00:25 <lambdabot>       add (Profunctor p) to the context of
12:00:33 <benzrf> ReinH: i thought maybe it would expand the type for some reason
12:00:36 <clrnd> i cant even troll with lenses :(
12:00:40 <chrisdone> ReinH: http://weknowgifs.com/wp-content/uploads/2013/03/its-magic-shia-labeouf-gif.gif
12:00:59 <benzrf> ReinH: like since it was an application instead of a name, it'd recalculate the type instead of just parroting what's written over it
12:01:05 <EvanR> so over is from lens
12:01:08 <benzrf> EvanR: indeed
12:01:30 <ReinH> chrisdone: That version of the gif has been deprecated. Please use http://i.imgur.com/iZcUNxH.gif
12:01:42 <benzrf> > over (traverse._2._tail) reverse [(1, "hello"), (2, "world")]
12:01:44 <lambdabot>  [(1,"holle"),(2,"wdlro")]
12:01:58 <ReinH> fun :)
12:02:11 <EvanR> over . easy
12:02:24 <benzrf> :t each
12:02:25 <lambdabot> (Each s t a b, Applicative f) => (a -> f b) -> s -> f t
12:02:26 <benzrf> :t every
12:02:27 <lambdabot> Not in scope: ‘every’
12:02:29 <benzrf> hmm
12:02:33 <benzrf> :t both
12:02:34 <lambdabot> (Data.Bitraversable.Bitraversable r, Applicative f) => (a -> f b) -> r a a -> f (r b b)
12:02:38 <benzrf> oh lord
12:02:42 <ReinH> :)
12:02:45 <chrisdone> ReinH: i'd be better off downloading a full HD movie in than waiting to load that gif
12:02:49 <EvanR> :t raverse
12:02:50 <lambdabot>     Not in scope: ‘raverse’
12:02:50 <lambdabot>     Perhaps you meant one of these:
12:02:50 <lambdabot>       ‘reverse’ (imported from Data.List),
12:02:53 <ReinH> chrisdone: worth
12:03:26 <EvanR> wget the gif
12:04:27 <sithrak> well isnt this the was coding works? 1. start coding 2.??? 3.magic 4.profit
12:04:36 <vanila> lol
12:04:49 <sithrak> how not the was
12:04:58 <EvanR> was the not how
12:05:40 <monochrom> 1. start coding 2. sleep deprivation 3. starving 4. death
12:06:04 <sithrak> you are clearly livin in a dystopian or crapsack world
12:06:22 <EvanR> Data.Crapsack
12:08:52 <sithrak> in my younger days i threw white knights into crapsack worlds just to watch them wither and get so corrupted they tried to suicide but couldnt because a crapsack world got no easy way out :)
12:10:22 <EvanR> :t fold
12:10:22 <lambdabot> (Monoid m, Foldable t) => t m -> m
12:10:52 <sivteck> > fold $ map Sum [3,3,2,2,4,4,5,6]
12:10:54 <lambdabot>  Sum {getSum = 29}
12:10:54 <EvanR> so monoid terminology seems to commonly mixed with folding terminology
12:11:04 <EvanR> even in haskell
12:11:22 <EvanR> annoying
12:11:30 <sivteck> ;(
12:11:46 <ReinH> EvanR: Annoying? There's a good reason for it.
12:12:09 <EvanR> well, a left fold is not something you would be expecting to do in parallel
12:12:14 <ReinH> Foldable is for structures that can be folded; Moniod is for values that can be combined. fold does the obvious things for foldable structures of combinable values.
12:12:15 <EvanR> a mconcat however, you could
12:12:35 <hugomg> Hi, does anyone know if there is a way to tell cabal to detect what dependencies Im using and add them to the .cabal file?
12:12:40 <ReinH> fold is a list homomorphism; foldl is not necessarily one.
12:13:08 <EvanR> list homomorphism?
12:13:27 <Aquana> what is the type of a list consisting of values of different types of the same type class?
12:13:27 <ReinH> EvanR: https://www.cs.auckland.ac.nz/research/groups/CDMTCS/researchreports/005thirdht.pdf
12:13:46 <ReinH> A fold that can be written as both a foldl and foldr is a list homomorphism; the converse is also true.
12:13:55 <ReinH> monoids get this property for free by associativity
12:13:59 <EvanR> example assertion "clojure can do folds in parallel"
12:14:12 <EvanR> which that makes not much sense to me coming from foldr/foldl
12:14:21 <hugomg> aquana: you can use existential types to do that but Its probably better if you found another way to do it without typeclasses
12:14:29 <ReinH> Aquana: For that you need existentials: see http://lukepalmer.wordpress.com/2010/01/24/haskell-antipattern-existential-typeclass/
12:14:30 <hugomg> just using regular closures
12:14:59 <ReinH> EvanR: only certain folds can be done in parallel: those that are list homomorphisms.
12:15:14 <ReinH> all monoidal folds can be done in parallel, since all monoidal folds are list homomorphisms
12:15:24 <ReinH> So it is impossible for closure to do *all* folds in parallel: some are not associative.
12:15:26 <statusfailed> ReinH, EvanR sorry, was cycling. I want to be able to operate on "partitions" of a traversable, for example, I want the lengths of contiguous sequences within a list
12:15:42 <statusfailed> e.g.: [1, 2, 2, 3, 3, 3] -> [1 ,2, 3]
12:15:49 <ReinH> statusfailed: perhaps you want something like `group'
12:16:03 <ReinH> > fmap length . group $ [1,2,2,3,3,3]
12:16:04 <lambdabot>  [1,2,3]
12:16:10 <statusfailed> ReinH: I'm actually wondering if group can be written as a traversal over groups
12:16:17 <statusfailed> specifically with lens
12:16:18 <levi> Regarding parallelism and abstractions supporting it, here's an interesting Guy Steele talk about it: http://vimeo.com/6624203
12:16:24 <ReinH> statusfailed: the real question is "how do I turn my list of [a] into [[a]] so that I can traverse the "sublists"
12:16:33 <EvanR> ReinH: right, and such cases are not distinguished explicitly, just folk idea of "when it makes sense"
12:16:42 <Aquana> hugomg: the idea is that i have a game with multiple worlds which can have their own generator function etc
12:16:51 <ReinH> EvanR: (list homomorphisms turn that folk theory into an actual one ;)
12:16:51 <statusfailed> ReinH: is there a way to turn group into a traversal?
12:17:13 <hugomg> sure, but have it be a regular functions instead of a typeclasses. Haskell typeclasses are *not* like object-oriented classes
12:17:15 <ReinH> statusfailed: the result of group is of type [[a]], which can be mapped with (map . map) and traversed with (traverse . traverse) and so on
12:17:23 <Aquana> hugomg: i thought typeclasses are the method of choice for that, or is there anything better?
12:18:00 <ReinH> EvanR: Haskell doesn't give you a way to state "This fold is a list homomorphism", but it does give you a way to say "this fold is monoidal"
12:18:11 <EvanR> ReinH: in this case, they get around it by using monoid terminology as part of the explanation of the fold procedure. the procedure involves basically doing mconcat given a monoid operation and identity
12:18:15 <ReinH> The latter doesn't cover all the cases of the former, but it does cover a lot of interesting ones
12:18:22 <hugomg> check out that "existential type antipattern" link reinH posted. You might be able to do a "list of functions" or "list of records of functions"
12:18:29 <ReinH> EvanR: yes, fold is a generalization of mconcat
12:18:33 <Aquana> okay, thank you!
12:19:05 <EvanR> ReinH: so whats Foldable, a generalization of Monoid?
12:19:07 <ReinH> EvanR: the hidden implication is that monoidal folds are parallelizable, not necessarily that fold or mconcat perform the parallelization
12:19:16 <ReinH> EvanR: Foldable is a generalization of []
12:19:32 <ReinH> "Structures which can be folded'
12:20:08 <EvanR> where folded means mconcatted, rather than foldl/red
12:20:15 <EvanR> that was confusing to me at first
12:20:33 <ReinH> > fold Nothing :: String
12:20:34 <lambdabot>  ""
12:20:41 <ReinH> > fold (Just "foo")
12:20:42 <lambdabot>  "foo"
12:21:40 <EvanR> how does implementing foldMap allow it to auto implement foldl?
12:22:36 <ReinH> EvanR: look at the default implementations. foldr uses the Endo monoid. foldl uses the dual of the Endo monoid.
12:23:13 <ReinH> http://haddocks.fpcomplete.com/fp/7.8/20140916-162/base/src/Data-Foldable.html#foldMap
12:23:42 <EvanR> :t Endo
12:23:43 <lambdabot> (a -> a) -> Endo a
12:23:45 <ReinH> (This actually allows you to write foldr' as well, which is pretty interesting)
12:23:56 <ReinH> Endo is the monoid of endomorphisms (functions a -> a)
12:24:11 <ReinH> (functions a -> a in Hask, that is)
12:24:14 <EvanR> attempting to grok Endo . f
12:24:59 <levi> It's just a newtype wrapper for the purpose of defining a typeclass instance for Monoid.
12:25:04 <EvanR> alright, so it applies the fold operation to all the elements and combines them
12:25:09 <ReinH> EvanR: "Endo . f", not Endo
12:25:16 <ReinH> er levi ^
12:25:55 <statusfailed> ReinH: hm. I guess I am confused how I can use that information with lens
12:26:10 <EvanR> using mempty as the accumulator
12:26:15 <ReinH> statusfailed: It depends on what you are trying to do.
12:26:24 <ReinH> EvanR: mempty for Endo is (Endo id)
12:26:36 <EvanR> makes sense
12:27:04 <EvanR> :t getDual
12:27:05 <lambdabot> Dual a -> a
12:27:09 <ReinH> :t foldl
12:27:10 <lambdabot> (b -> a -> b) -> b -> [a] -> b
12:27:11 <ReinH> :t foldr
12:27:12 <lambdabot> (a -> b -> b) -> b -> [a] -> b
12:27:41 <ReinH> EvanR: notice that if you partially apply the combining function (a -> b -> b) you get (b -> b), which is an endomorphism
12:27:49 <EvanR> yeah
12:27:57 <ReinH> Endo . f says take that partially applied function and wrap it with Endo
12:28:01 <ReinH> @src (.)
12:28:01 <lambdabot> (f . g) x = f (g x)
12:28:11 <ReinH> Endo . f = \x -> Endo (f x)
12:28:20 <ReinH> :t foldl
12:28:21 <lambdabot> (b -> a -> b) -> b -> [a] -> b
12:28:22 <EvanR> i saw a derivation on reddit showing how something like that gets you from Foldable to Traversable, in some fashion
12:28:35 <ReinH> Dual does the requisite flipping for foldl
12:28:51 <EvanR> @src getDual
12:28:51 <lambdabot> Source not found.
12:29:01 <ReinH> getDual is just the accessor for the Dual newtype
12:29:16 <EvanR> Dual is a newtype over what
12:29:20 <statusfailed> ReinH: I think the type I want is this: "groups :: Traversal [a] [b] [a] b"
12:29:50 <ReinH> EvanR: any Moniod. It swaps the arguments to mappend: http://haddocks.fpcomplete.com/fp/7.8/20140916-162/base/src/Data-Monoid.html#Dual
12:30:03 <EvanR> ok
12:30:09 <EvanR> dual monoid
12:30:13 <ReinH> So there are two flips that need to happen:
12:30:14 <ReinH> foldl f z t = appEndo (getDual (foldMap (Dual . Endo . flip f) t)) z
12:30:32 <ReinH> the function b -> a -> b needs to be flipped to a -> b -> b
12:30:37 <ReinH> that's flip f of course
12:31:21 <EvanR> :t appEndo
12:31:22 <lambdabot> Endo a -> a -> a
12:31:22 <ReinH> and assoc : a(bc) ~> (ab)c needs to be perfomed, that's the Dual
12:31:38 <ReinH> so Dual reassociates the applications
12:32:16 <ReinH> well, assoc is usually defined (ab)c -> a(bc), so this is assoc^-1, but anyway
12:32:34 <EvanR> what would assoc be in haskell
12:32:40 <ReinH> Dual ;)
12:33:13 <ReinH> At least, assoc for monoids
12:34:33 <favetelinguis> what am i doing wrong here http://lpaste.net/114586, get type error for ord line 7 and 48 line 9
12:34:55 <ReinH> EvanR: btw https://www.cs.auckland.ac.nz/research/groups/CDMTCS/researchreports/005thirdht.pdf is a wonderful paper and really worth the read
12:35:21 <edwardk> actually the easiest way i know to think about foldl there is this
12:35:24 <edwardk> start with foldr
12:36:27 <edwardk> foldr :: (a -> r -> r) -> r -> [a] -> r -- we can note that r -> r is a Monoid, its just Endo, so that is (a -> Endo r) -> r -> [a] -> r -- and if we foldMap over the list with(( (Endo . f) we get an Endo r that is the result of composing all those result functions
12:36:33 <edwardk> just feed it the starting r and fire off the chain
12:36:37 <edwardk> if we look at foldl
12:36:50 <edwardk> foldl :: (r -> a -> r) -> r -> [a] -> r -- now we first need to flip the functions
12:36:57 <edwardk> that gets us (a -> r -> r)
12:37:01 <edwardk> then we wrap it in Endo
12:37:07 <edwardk> that gets us (a -> Endo r) like before
12:37:19 <edwardk> but if we just did what we did before we'd get foldr . flip
12:37:22 <ReinH> edwardk: I mentioned that :p
12:37:24 <edwardk> we'd still compose them in the same order
12:37:48 <edwardk> so Dual isn't technically reassociating here, its being used to flip the order of composition
12:37:59 <ReinH> ah
12:38:17 <ReinH> oh ofc
12:38:17 <edwardk> its being used to work in the dual monoid, where instead of Endo f <> Endo g = Endo (f . g) its Dual (Endo f) <> Dual (Endo g) = Dual $ Endo (g . f)
12:38:26 <edwardk> so we're just composing functions... in the opposite order
12:38:31 <edwardk> then feeding it the starting 'r'
12:38:50 <edwardk> that is why i felt the need to comment
12:38:56 <edwardk> the assocativity is irrelevant, its all functions
12:39:00 <edwardk> functions associate
12:39:39 <EvanR> > foldMap (+1) [1, 2, 3, 4]
12:39:40 <lambdabot>  No instance for (GHC.Show.Show a0)
12:39:40 <lambdabot>    arising from a use of ‘M836640265556230705012370.show_M8366402655562307050...
12:39:40 <lambdabot>  The type variable ‘a0’ is ambiguous
12:39:40 <lambdabot>  Note: there are several potential instances:
12:39:40 <lambdabot>    instance [safe] GHC.Show.Show
12:40:07 <EvanR> > foldMap (+1) (map Sum [1, 2, 3, 4])
12:40:08 <lambdabot>  Sum {getSum = 14}
12:40:13 <augur> :t foldMap
12:40:14 <lambdabot> (Monoid m, Foldable t) => (a -> m) -> t a -> m
12:40:34 <fragamus> anyone doing haskell IOS development
12:40:48 <edwardk> evanr you first need to switch it over to Endo or something
12:41:57 <EvanR> :t concatMap
12:41:58 <lambdabot> (a -> [b]) -> [a] -> [b]
12:42:38 <EvanR> this means classic foldr can be implemented with concatMap
12:42:43 <EvanR> head explode
12:43:15 <JagaJaga> That's may be a stupid question, but how can I read from handle by lines? Not until EOF?
12:43:22 <JagaJaga> (Reading bytestrings)
12:43:27 <EvanR> :t getLines
12:43:28 <lambdabot>     Not in scope: ‘getLines’
12:43:28 <lambdabot>     Perhaps you meant one of these:
12:43:28 <lambdabot>       ‘getLine’ (imported from Prelude),
12:43:39 <EvanR> :t lines . getContents
12:43:40 <lambdabot>     Couldn't match expected type ‘a -> String’
12:43:40 <lambdabot>                 with actual type ‘IO String’
12:43:40 <lambdabot>     In the second argument of ‘(.)’, namely ‘getContents’
12:43:52 <EvanR> :t fmap lines getContents
12:43:52 <lambdabot> IO [String]
12:43:59 <exio4> :t lines <$> getContents
12:44:00 <exio4> aw
12:44:02 <lambdabot> IO [String]
12:44:06 <Peaker> Lazy I/O :-(
12:44:16 <EvanR> :t getContents <&> lines
12:44:17 <lambdabot> IO [String]
12:44:21 <EvanR> raw haw haw
12:44:46 <Peaker> I like <&>
12:45:27 <EvanR> but hGetContents takes another arg
12:45:48 <EvanR> :t hGetContents h <&> lines
12:45:49 <lambdabot>     Not in scope: ‘hGetContents’
12:45:49 <lambdabot>     Perhaps you meant one of these:
12:45:49 <lambdabot>       ‘BSC.hGetContents’ (imported from Data.ByteString.Char8),
12:45:59 <EvanR> :t BSC.hGetContents h <&> lines
12:46:00 <lambdabot>     Couldn't match type ‘[Char]’ with ‘BSC.ByteString’
12:46:00 <lambdabot>     Expected type: BSC.ByteString -> [String]
12:46:00 <lambdabot>       Actual type: String -> [String]
12:46:24 <JagaJaga> EvanR: well, I'm using BSC.hGetContents, but input is received only afted EOF
12:46:35 <JagaJaga> (I'm writing TCP server)
12:46:43 <EvanR> you have block buffering set
12:47:13 <EvanR> if you want interactive lines you need to set the socket to line buffering
12:47:22 <JagaJaga>     hSetBuffering handle NoBuffering
12:47:24 <JagaJaga>     hSetBinaryMode handle True
12:47:26 <JagaJaga> ?
12:48:36 <EvanR> er, then im not sure, except that hGetContents is lazy IO so you should probably do it properly
12:49:35 <EvanR> which is really annoying actually, with the primitives
12:49:54 <EvanR> :t hGetLine
12:49:54 <lambdabot>     Not in scope: ‘hGetLine’
12:49:55 <lambdabot>     Perhaps you meant one of these:
12:49:55 <lambdabot>       ‘BSC.hGetLine’ (imported from Data.ByteString.Char8),
12:51:40 <JagaJaga> :t BSC.hGetLine
12:51:41 <lambdabot> GHC.IO.Handle.Types.Handle -> IO BSC.ByteString
12:52:04 <EvanR> this will read and block and read and block and only return when a newline or EOF is encountered
12:52:17 <EvanR> but, that is a security hazard
12:53:16 <JagaJaga> EvanR: anyway thanks!
12:53:36 <EvanR> you need to trust your peer to not send unlimited bytes with no newline
13:03:45 <EvanR> :t for
13:03:46 <lambdabot>     Not in scope: ‘for’
13:03:46 <lambdabot>     Perhaps you meant one of these:
13:03:46 <lambdabot>       ‘T.for’ (imported from Data.Traversable),
13:03:50 <EvanR> :t T.for
13:03:51 <lambdabot> (Traversable t, Applicative f) => t a -> (a -> f b) -> f (t b)
13:04:00 <JagaJaga> EvanR: yeah, that's a university project, so I'm trusting the sender :)
13:04:31 <EvanR> the university setting was historically where people trusted each other on the network and then got trolled ;)
13:05:15 <hc> that reminds me to read the cuckoo's egg again ;}
13:10:16 <EvanR> is Functor a special case of Traversable?
13:10:26 <EvanR> ah its a prerequisite
13:10:54 <EvanR> so confused how youd use fmapDefault
13:11:33 <EvanR> same for foldMapDefault
13:11:51 <benzrf> EvanR: explain
13:11:57 <benzrf> :t fmapDefault
13:11:58 <lambdabot>     Not in scope: ‘fmapDefault’
13:11:58 <lambdabot>     Perhaps you meant ‘T.fmapDefault’ (imported from Data.Traversable)
13:12:02 <benzrf> :t T.fmapDefault
13:12:03 <lambdabot> Traversable t => (a -> b) -> t a -> t b
13:12:13 <benzrf> EvanR: it's implemented in terms of traverse
13:12:29 <benzrf> EvanR: you can write traverse in terms of fmap, but if you write it from scratch, it implicitly contains the ability to fmap
13:12:30 <EvanR> it says you can use this for a Functor instance, but Functor is a requirement for Traversable
13:12:38 <benzrf> EvanR: interdependent definitions
13:12:41 <benzrf> EvanR: something like:
13:12:45 <benzrf> instance Functor T where
13:12:50 <benzrf>   fmap = fmapDefault
13:12:56 <benzrf> instance Traversable T where
13:13:00 <benzrf>   traverse = ...
13:13:11 <EvanR> far out
13:13:15 <benzrf> yeah =D
13:13:38 <benzrf> it's possible to do something similar with Applicative and Functor
13:14:23 <EvanR> so for is a generalization of forM
13:14:43 <EvanR> so it could be used in monad code instead of forM right
13:15:01 <EvanR> would it be slower
13:18:58 <benzrf> EvanR: not if ghc is doing its job
13:19:19 <wyager> Why is it that when I run “cabal install msgpack” it installs a completely different msgpack-0.2.2 instead of http://hackage.haskell.org/package/msgpack-0.7.2.5/docs/Data-MessagePack.html ?
13:19:42 <rodlogic> has anyone here used uuagc (attribute grammar system)?
13:20:25 <merijn> wyager: Because your locally installed dependencies are too old?
13:20:35 <wyager> merjin: How do I fix this?
13:20:35 <bennofs> wyager: try cabal install msgpack-0.7.2.5
13:20:40 <merijn> wyager: Also, did you "cabal update" to update the package index?
13:20:47 <wyager> of course, merijn
13:20:51 <wyager> I will try that bennofs
13:20:54 <merijn> wyager: By installing newer dependencies if that's the problem
13:21:15 <wyager> OK, it prints this:
13:21:16 <wyager> Resolving dependencies...
13:21:17 <wyager> cabal: Could not resolve dependencies:
13:21:17 <wyager> trying: msgpack-0.7.2.5 (user goal)
13:21:23 <wyager> then a bunch of stuff about conflicts with template-haskell
13:21:47 <wyager> Can I tell cabal-install to install whatever it needs to?
13:21:58 <bennofs> wyager: what GHC version are you using
13:22:08 <wyager> 7.8.3
13:24:11 <wyager> Any suggestions
13:25:45 <Yuu_chan> How to get list of lists with kind * -> *? I'd want to write something like instance Someclass [[]]
13:28:02 <EvanR> instance SomeClass [[a]] where
13:28:14 <EvanR> er no
13:28:45 <EvanR> er yeah
13:28:51 * hackagebot shake 0.14 - Build system library, like Make, but more accurate dependencies.  http://hackage.haskell.org/package/shake-0.14 (NeilMitchell)
13:30:08 <wyager> I’ve posted the whole error here: http://pastebin.com/Su0hvpwn
13:30:32 <Yuu_chan> EvanR: nope, if the class requires a polymorphic type
13:30:37 <wyager> (same thing if I leave off —upgrade-dependencies, I was just trying that)
13:31:03 <sinelaw> Yuu_chan, is right
13:31:29 <EvanR> ok
13:32:30 <EvanR> instance Class (([]) . ([])) where?
13:32:47 <wyager> Can you do a type def?
13:32:54 <wyager> type Thing a = [[a]]
13:33:00 <wyager> instance Class Thing where
13:33:11 <EvanR> TypeSynonymInstances
13:34:10 <lynnard> Can someone explain (.).(.) in layman's term?
13:34:35 <lynnard> I roughly know what it does (composition where the second function takes two arguments)
13:34:35 <EvanR> :t (.).(.)
13:34:36 <lambdabot> (b -> c) -> (a -> a1 -> b) -> a -> a1 -> c
13:34:45 <lynnard> but I just can't seem to understand how it works
13:34:56 <L8D> so if I want extensible record types in 7.8 what do I do?
13:34:57 <lengzai> just follow the types
13:34:58 <wyager> It helps just to work out the types on paper
13:35:00 <lengzai> it creates a new function
13:35:00 <EvanR> :t (.)
13:35:01 <lambdabot> (b -> c) -> (a -> b) -> a -> c
13:35:03 <L8D> is there a language extension or something?
13:35:23 <sinelaw> @src (.)
13:35:23 <lambdabot> (f . g) x = f (g x)
13:35:27 <sinelaw> lynnard, ^^
13:35:29 <lengzai> the whole point of composition is to create new functions
13:35:42 <lengzai> but, the (.) is a function
13:35:58 <Yuu_chan> wyager: "Type synonym ‘Thing’ should have 1 argument, but has been given none"
13:36:07 <EvanR> fill in the types of the arguments into the types of the function
13:36:08 <lengzai> so when you follow the types, you create a new function similar to (.) but that can go a level deeper
13:36:33 <wyager> Yuu_chan: Maybe “instance Class Thing a where”. I forget the exact syntax
13:36:38 <merijn> Yuu_chan: You can't use partially applied type synonyms for instances
13:36:47 <wyager> Oh, that then ^
13:36:57 <sinelaw> heh
13:37:09 <merijn> That would be the same as allowing type level lambda's, which makes type inference undecidable
13:37:16 <EvanR> :k []
13:37:16 <lambdabot> * -> *
13:37:26 <EvanR> :k [] . []
13:37:27 <lambdabot>     Illegal symbol '.' in type
13:37:27 <lambdabot>     Perhaps you intended to use RankNTypes or a similar language
13:37:27 <lambdabot>     extension to enable explicit-forall syntax: forall <tvs>. <type>
13:37:33 <merijn> Yuu_chan: You want the Compose newtype from Data.Functor.Compose
13:37:37 <merijn> :t Compose
13:37:38 <lambdabot> Not in scope: data constructor ‘Compose’
13:37:41 <merijn> hmm
13:38:03 <sinelaw> @hoogle Compose
13:38:03 <lambdabot> Data.Functor.Compose Compose :: f (g a) -> Compose f g a
13:38:03 <lambdabot> Data.Functor.Compose newtype Compose f g a
13:38:03 <lambdabot> Data.Functor.Compose module Data.Functor.Compose
13:38:04 <benzrf> :k 3
13:38:05 <sinelaw> there.
13:38:05 <lambdabot> GHC.TypeLits.Nat
13:38:07 <merijn> newtype Compose f g a = Compose { getCompose :: f (g a) }"
13:38:24 <Yuu_chan> merijn: I used a newtype first, but then wondered if it was possible to deal without one, enabling some extensions
13:38:35 <merijn> Yuu_chan: Nope, not possible
13:38:51 <benzrf> @let newtype (f ◦ g) a = C {de :: f (g a)}
13:38:51 <lambdabot>  Parse failed: Illegal data/newtype declaration
13:38:53 <benzrf> aw
13:39:11 <EvanR> merijn: so this is a limitation of List not having a name?
13:39:38 <exio4> I would think using type synonym and that extension that allows to make typeclass instances of type synonyms would make that possible.. I think
13:40:01 <sinelaw> merijn, what syntax would you use with Compose to define a [[]] instance for some class?
13:40:48 <EvanR> exio4: that doesnt work for partially applied synonyms
13:40:49 <Yuu_chan> EvanR: that would be the same for any type, that's equal to type lambdas AFAIU
13:40:51 <L8D> sinelaw: Compose [] [] ?
13:41:19 <sinelaw> L8D, you mean this? instance MyClass (Compose [] []) where
13:41:33 <L8D> yeah
13:41:41 <L8D> instance Monad (Compose [] []) where ...
13:41:55 <EvanR> to hell with completely decidable type inferrence with no annotations anywhere ;)
13:41:56 <L8D> or instance Monoid [[a]] where ..
13:42:16 <Yuu_chan> merijn: thanks for clarification
13:42:49 <EvanR> L8D: i suggested that last one first, and its illegal
13:43:03 <L8D> EvanR: how come?
13:43:04 <Yuu_chan> EvanR: it's legal
13:43:09 <EvanR> wuh?
13:43:38 <EvanR> instance SomeClass [[a]] where
13:43:41 <merijn> EvanR: This is a limitation of haskell's type system
13:43:50 <merijn> sinelaw: "Compose [] [] a"
13:43:53 <Yuu_chan> Monoid demands * ([[a]] has it), but Functor requires * -> *
13:44:08 <sinelaw> L8D merijn, ok thanks
13:44:24 <L8D> EvanR: what's illegal about that?
13:44:39 <merijn> sinelaw: Well, the thing is you can define an instance "[[a]]" just fine, you CAN'T define one without 'a' (for example Functor)
13:44:50 <EvanR> i thought you had to have  a constraint for the a, but i guess the only issue is the kinds matching up
13:44:51 <sinelaw> yes, I understand
13:44:54 <merijn> "instance Functor (Compose [] [])" does work, though
13:44:56 <sinelaw> not sure why though
13:45:02 <sinelaw> is it a syntax issue?
13:45:19 <merijn> sinelaw: No, there is no way to partially apply type constructors
13:45:28 <merijn> Or rather
13:45:39 <merijn> You can't compose type constructors in a partially applied way
13:45:50 <merijn> Because that requires type level lambda's
13:45:50 <sinelaw> I see
13:46:07 <merijn> And type level lambda's make type inference undecidable (maybe even type checking, I'm not sure(
13:46:10 <sinelaw> merijn,  instance Functor (forall a. [[a]]) where
13:46:12 <EvanR> :k Either ()
13:46:13 <lambdabot> * -> *
13:46:14 <tdammers> guys, what's the go-to library for processing image files these days?
13:46:21 <merijn> sinelaw: Kind error
13:46:34 <tdammers> loading/saving jpg, png, etc., and resizing and stuff like that?
13:46:35 <L8D> tdammers: GraphicsMagick
13:46:41 <merijn> EvanR: That doesn't let you compose, though
13:46:44 <sinelaw> merijn, oops right
13:46:50 <tdammers> L8D: will look into it, thanks
13:46:51 <merijn> EvanR: My initial phrasing was confusing
13:46:55 <escondida> tdammers: imagemagick is pretty great
13:47:06 <L8D> tdammers: hsmagick is the Haskell library
13:47:11 <JagaJaga> I have function like http://lpaste.net/114592. But getting `openBinaryFile: does not exist (No such file or directory)` (But I'm surely I have this file, file from the path argument). What's that? :(
13:47:23 <sinelaw> merijn, I confused foralls with type-level lambdas.
13:47:38 <tdammers> L8D: yeah, just found it
13:47:40 <escondida> tdammers: It takes some learning to get beyond the basics with it, but they have lots of docs on their Web site.
13:47:54 <tdammers> escondida: imagemagick is what I thought of, just wondering about haskell bindings
13:48:00 <EvanR> type level lambdas are the shit
13:48:12 <escondida> tdammers: I forgot what the bindings package was called, apologies (-:
13:48:13 <L8D> graphicsmagick is imagemagick
13:48:27 <EvanR> theres ghc extensions which accept undecidable stuff in one way or another
13:48:28 <L8D> gm is just a revision of im
13:48:29 <sinelaw> merijn, type level lambdas are the "omega" axis of the lambda cube?
13:48:30 <tdammers> haha, so that's why it looks so familiar :D
13:49:28 <Yuu_chan> Wow, 1500 users.
13:49:50 <peropaal> yes
13:53:40 <sinelaw> merijn, apparently type checking is decidable in Fw
13:53:50 <sinelaw> but probably not inference.
13:53:51 * hackagebot data-transform 0.1.0.0 - Functions to transform data structures.  http://hackage.haskell.org/package/data-transform-0.1.0.0 (JonasScholl)
13:54:10 <Marga28> ufffff mmm http://imgdino.com/viewer.php?file=48244565830511698472.jpg
13:55:17 <L8D> wtf is that a bot?
13:55:31 <L8D> apparently
13:55:39 <sinelaw> I wonder if the link has some malware
13:55:43 <merijn> EvanR: UndecidableInstances is still a lot less dangerous than type level lambda's would be
13:55:55 <merijn> Probably
13:55:57 <EvanR> dangerous?
13:56:00 <merijn> Just the usual spambots
13:56:02 <L8D> sinelaw: it's some stupid image with a person in their underware
13:56:12 <merijn> EvanR: The amount of inference broken
13:56:35 <merijn> EvanR: UndecidableInstances can cause typeclass resolution to infinite loop, type lambda's could make *any* type infinite loop
13:56:36 <L8D> I never understood bots
13:57:02 <L8D> like, botnets sure, but spam bots are like wut?
13:57:13 <L8D> and why are they in #haskell?
13:57:39 <sinelaw> maybe when you visit the underwear picture you get a virus installed via browser vulnerability
13:57:58 <EvanR> merijn: curious, in idris i have not noticed more type signatures practically speaking, and you can put function applications in the signatures of stuff
13:58:13 <L8D> there are far more effective ways to get malware on someones computer
13:58:24 <EvanR> in this case (.)
13:58:36 <L8D> like nearly everyone on freenode would be wise enough to not visit the link or use a browser with vulnerabilities
13:58:41 <merijn> EvanR: Language that are from the ground up dependent are much easier than language that retrofit it
13:59:02 <EvanR> ok but that a different reason
13:59:05 <merijn> EvanR: i.e. retrofitting dependent types into haskell's world is *hard*
13:59:43 <EvanR> now im wondering what the real reason is, like instead of computer science math reasons, the GHC reason
13:59:46 <merijn> EvanR: Does idriss do totality checking on type signatures? It could very well be that they just silently allow loops in typechecking on account of "don't do that then"
14:00:09 <EvanR> the type checker is supposed to be the most total of the total system
14:00:15 <EvanR> up to bugs
14:01:51 <JagaJaga> Some ideas? I have function like http://lpaste.net/114592. But getting `openBinaryFile: does not exist (No such file or directory)` (But I'm surely I have this file, file from the path argument). What's that? :(
14:02:38 <oliffea> JagaJaga: whats the name oe the file that its failing on?
14:02:54 <RyanGlScott> How are you supposed to import "data Number" from Text.Read.Lex in base? There's a constructor in the same module called Number, so it won't let me.
14:02:56 <JagaJaga> oliffea: the first one of the result of the getDirectoryCOntents
14:03:07 <oliffea> JagaJaga: right, but whats the actual name of it
14:03:47 <JagaJaga> oliffea: work2.cabal
14:04:03 <JagaJaga> oliffea: that was called with "../" arg
14:04:05 <dfeuer> RyanGlScott, you probably want to do something like import Text.Read.Lex (Number(..))
14:04:38 <JagaJaga> oliffea: oh! may be I have to set the full path?
14:04:50 <RyanGlScott> dfeuer: So, Number doesn't export any constuctors. See here: http://hackage.haskell.org/package/base-4.7.0.1/docs/Text-Read-Lex.html#t:Number
14:04:55 <oliffea> JagaJaga: peshapd gefDirectoryContents cd's into that directory t; list the files, so youll need to join the path and filkname to opkn it?
14:05:02 <oliffea> wow apologies for the typos
14:05:06 <dfeuer> RyanGlScott, okay, so try Number()
14:05:06 <oliffea> AHK ftl
14:05:40 <JagaJaga> oliffea: yeah, that's the same that I think
14:05:51 <RyanGlScott> If I try to import Number, GHC thinks its a constructor of Lexeme, not the Number, so it gives me a useless warning to import Text.Read (Lexeme(Number))
14:06:14 <dfeuer> RyanGlScott, did you try importing Number()?
14:06:22 <dfeuer> No guarantee that'll work, but I think it might.
14:06:23 <merijn> EvanR: btw, the reason you haven't noticed more signatures is that most haskellers provide *way* more signatures than the language needs
14:06:42 <EvanR> right
14:06:54 <RyanGlScott> dfeuer: Yes, I've tried importing Text.Read (Lexeme(..)) and Text.Read (Number ()) separately in the same module to no avail.
14:06:54 <EvanR> which is not bad, so why shoot for less
14:07:26 <EvanR> "Idris won't reduce partial functions at the type level, in order to keep type checking decidable." stack overflow
14:07:59 <EvanR> so i guess thats the difference, theres no totality checking in ghc
14:08:31 <RyanGlScott> dfeuer: Weirdly enough, this doesn't seem to happen in GHCi. Just when I try to use import statements in a module.
14:08:55 <dfeuer> RyanGlScott, GHCi is weird about modules in general. I wouldn't pay too much attention to what it does.
14:09:18 <merijn> EvanR: I'm not saying I disagree, but then we're fundamentally moving away from Haskell. And since Idriss was already designed to do that... :p
14:10:27 <EvanR> so whats the difference between type level lambda, and type level function application (of a name function)
14:10:28 <RyanGlScott> dfeuer: Whoops, it turns out I was confusing "Text.Read" and "Text.Read.Lex".
14:10:30 <dfeuer> Even though most programs have a lot more type signatures than they need, they do still typically rely heavily on (local) inference. How well does Idris handle that?
14:10:40 <dfeuer> RyanGlScott, ah, okay :-)
14:12:16 <RyanGlScott> Is there a way to jump to typeclass instance declarations from a Haddock-generated page?
14:12:20 <EvanR> dfeuer: type sig is required on all top level things, and i havent seen much code with local types, but also i have seen people struggling to get things to check, but its usually because of implicit parameters and type directed name disambiguation
14:12:21 <Yuu_chan> If I have a [[a]], what's the easiest way to transform it into Compose ZipList ZipList a, and backwards?
14:12:47 <johnw> ZipList . fmap ZipList
14:12:52 <L8D> what are some good video games for Haskell enthusiasts?
14:12:55 <johnw> getZipList . fmap getZipList
14:13:51 * hackagebot wai-routing 0.12 - Declarative routing for WAI.  http://hackage.haskell.org/package/wai-routing-0.12 (ToralfWittner)
14:16:16 <merijn> EvanR: Nothing, but while haskell + extensions gives you type level functions it doesn't allow partially applied ones
14:16:53 <EvanR> ok, so partially applied would be like a lambda
14:17:17 <merijn> ugh, I'm having a hard time finding the correct wording for what I'm trying to say :)
14:17:38 <vanila> S,K combinators are equivalent to lambda calculus
14:22:34 <L8D> you could implement a parser that would convert lambda calculus to sk combinators in sk combinators
14:23:14 <EvanR> sk combinators, plus a supply monad of characters besides s and k ;)
14:23:38 <L8D> well, s, k and `
14:23:46 <L8D> '`' is used for precedence ordering
14:24:01 <EvanR> balanced parentheses
14:24:11 <EvanR> hehe
14:28:30 <vanila> it's a bit complex to transform lambda calculus into S,K combinators
14:35:05 <merijn> dfeuer: Basically, the trickiest bit of dependent inference is function application
14:35:26 * ion remembers he wrote a lambda→SKI transformer in Erlang a number of years ago. https://gist.github.com/ion1/341735
14:35:28 <merijn> dfeuer: If you require signatures on all functions (including local ones) you should be fine.
14:35:34 <dfeuer> merijn, okay. I know so little about dependent types it's not even funny.
14:35:51 <dfeuer> But signatures on all local functions would annoy Haskell programmers greatly, I think.
14:36:06 <EvanR> idris says you need signatures on all local functions, but this is relaxed by some rules
14:36:13 <EvanR> for common cases
14:38:10 <EvanR> also, many local functions are results of some computation rather than new definitions
14:39:06 <merijn> EvanR: Yeah, non-dependent local functions infer perfectly
14:39:18 <merijn> dfeuer: I've started adding signatures on all local functions
14:39:34 <merijn> Especially non-trivial ones
14:39:52 <cdk> does GHC have a command line flag to just typecheck a file and print any type errors?
14:40:09 <merijn> cdk: -fno-code
14:40:16 <merijn> Or something along those lines
14:40:21 <dfeuer> merijn, yeah, I tend to do that a fair bit too, but I do like to be able to write a function, even if I don't quite have its type figured out, and ask GHC for the type.
14:40:24 <merijn> Consult user guide for details
14:40:41 <merijn> dfeuer: btw: https://github.com/sweirich/pi-forall
14:40:52 <cdk> merijn: thanks
14:41:01 <merijn> dfeuer: The lecture notes on implementing a simple dependently typed lambda calculus from this year's OPLSS
14:41:05 <merijn> plus source
14:41:06 <dfeuer> o.O
14:41:18 <dfeuer> Thanks, merijn. Sounds rather educational.
14:42:16 <merijn> dfeuer: Also, I learned a lot about dependent types from pigworker's thesis, but I wouldn't try to tackle that one until you're comfortable with the basics of type theory
14:42:54 <EvanR> this repo is the bomb
14:42:55 <merijn> dfeuer: Have you read the lambdacube paper?
14:43:30 <merijn> "Introduction to Generalized Type Systems" by Henk Barendregt
14:43:36 <dfeuer> Nope.
14:43:46 <dfeuer> I've not. Is it readable by people who don't know a lot?
14:44:07 <merijn> dfeuer: Do you understand natural deduction notation + basic type theory?
14:44:09 <cyco__> hello
14:44:13 <cyco__> i have a question
14:44:15 <dfeuer> merijn, a *little*.
14:44:23 <merijn> dfeuer: Try it
14:44:24 <dfeuer> Emphasis on little.
14:44:29 <dfeuer> Will do, merijn.
14:44:33 <merijn> dfeuer: Although it may require some struggle :)
14:44:50 <dfeuer> cyco__, if you have a question, ask it. We don't care that you have it unless you ask it.
14:45:03 <cyco__> hello i want to edit content of and exe file is it possibel
14:45:05 <merijn> dfeuer: Basically it's the paper that explains the notion of the "lambdacube" and how all three axes relate
14:45:34 <dfeuer> cyco__, yes, you can. Just open it in vim or nano.
14:45:58 <indiagreen> cyco__: there are also resource editors, etc.
14:46:14 <indiagreen> or at least disassemblers
14:46:24 <indiagreen> is it related to Haskell, tho?
14:47:08 <athan> Is it possible to make a commutative functional dependency? Say I've got a `class Foo a b c | a b -> c where ...`, would it be possible to make a `instance (Foo a b c) => Foo b a c where ...`? GHC it telling me I need UndeicdableInstances, but I've been told that's bad (mmkay). Are there any alternative ways to do this?
14:47:19 <cyco__> i have a exe file i want to edit the image or background or whatever it is how cna i do it i tried the resource editors but with this exe file they dont work
14:47:45 <dfeuer> cyco__, what does this have to do with Haskell?
14:47:45 <lisbeth> why does [50,3..100] return an empty list?
14:48:04 <dfeuer> lisbeth, what would you like it to return?
14:48:06 <merijn> athan: Functional dependencies exist to allow you to write safe instances with undecidableinstances
14:48:32 <lisbeth> all of the integers between fifty and 100 counting in threes
14:48:40 <merijn> athan: UndecidableInstances is not that bad, worst case it causes your compilation to fail
14:48:52 <kadoban> lisbeth: Perhaps you mean [50,53..100] ?
14:48:54 <merijn> lisbeth: the second number is not the increment, it's the next step
14:48:57 <lisbeth> OH
14:48:58 <lisbeth> thanks
14:49:00 <simpson> > [50,53..100] -- haven't done this in a while, but...
14:49:00 <merijn> > [50,53..100]
14:49:01 <lambdabot>  [50,53,56,59,62,65,68,71,74,77,80,83,86,89,92,95,98]
14:49:02 <lambdabot>  [50,53,56,59,62,65,68,71,74,77,80,83,86,89,92,95,98]
14:49:05 <lisbeth> ok thank you
14:49:07 <lisbeth> for clearing that up
14:49:41 <merijn> lisbeth: So it was assuming you wanted a stepsize of -47 until you reached 100 ;)
14:49:58 <lisbeth> oh that's weird
14:50:16 <lisbeth> That is so strange to think about
14:50:19 <athan> merijn: Thank goodness haha, thank you :)
14:50:21 <merijn> '3 - 50 = -47' -> stepsize = 47
14:50:29 <merijn> eh
14:50:33 <merijn> -47, obviously
14:50:42 <merijn> Similarly "53 - 50 = 3" -> stepsize = 3
14:51:16 <merijn> > [10,8..0] -- negative stepsizes work fine
14:51:17 <lambdabot>  [10,8,6,4,2,0]
14:52:39 <merijn> athan: Basically, the way instance lookup happens is very conservative to guarantee instance look up is decidable (i.e. it always terminates!), UndecidableInstances allows infinite recursion so it can cause GHC to hang during compilation (well, in reality there's a recursion counter and after a while it gives up)
14:52:51 <EvanR> > [3.14, 99.0]
14:52:52 <lambdabot>  [3.14,99.0]
14:52:57 <EvanR> > [3.14 .. 99.0]
14:52:58 <lambdabot>  [3.14,4.140000000000001,5.140000000000001,6.140000000000001,7.14000000000000...
14:53:22 <athan> merijn: I want to curse in amazement, this is freakin cool!!
14:53:27 <merijn> athan: But using functional dependencies you can make some instance lookups safe that are not normally safe. Which, in fact, is the reason for their existence.
14:53:50 <merijn> athan: Well, I say safe, but I mean "terminating"
14:54:35 <merijn> Anyway, the point to all this is that UndecidableInstances can never break code, it can only break compilation (by not terminating). But IF compilation terminates it will always be correct
14:54:43 <merijn> s/But/So
14:54:49 <athan> merijn: That's very interesting. Couldn't there be a way to see how far a fundep _goes_? to help the decidablility?
14:55:33 <athan> that's redicuously awesome
14:55:57 <merijn> athan: No, this whole undecidable thing is very similar to the halting problem (in fact, I believe they're basically isomorphic in that a solution to one gives you a solution to the other?)
14:56:26 <athan> ?:)
14:56:26 <lambdabot> Maybe you meant: wn v rc pl id do bf @ ? .
14:56:34 <EvanR> they are logically equivalent
14:56:39 <EvanR> or something
15:00:37 <merijn> EvanR: Yeah, something along those lines
15:01:26 <mat10> do you ever use if-then-else ? because mostly using guard would do the trick ?
15:02:11 <merijn> mat10: Not a lot, usually only in do-notation
15:02:30 <EvanR> :t cond
15:02:31 <lambdabot>     Not in scope: ‘cond’
15:02:31 <lambdabot>     Perhaps you meant one of these:
15:02:31 <lambdabot>       ‘cons’ (imported from Control.Lens),
15:02:50 <koala_man> does "wn v rc pl id do bf @ ?" actually mean something?
15:03:18 <merijn> :t bool
15:03:19 <lambdabot> a -> a -> Bool -> a
15:03:42 <EvanR> nice
15:03:47 <merijn> > bool 1 2 False
15:03:49 <lambdabot>  1
15:04:05 <merijn> Note that bool follows the tradition of bool-elimination NOT if-then-else
15:04:31 <EvanR> @src bool
15:04:31 <lambdabot> Source not found. Do you think like you type?
15:04:52 <merijn> bool x _ False = x; bool _ x True = x
15:05:11 <merijn> Elimination rules generally follow constructor order
15:05:19 <merijn> compare
15:05:20 <merijn> :t maybe
15:05:21 <lambdabot> b -> (a -> b) -> Maybe a -> b
15:05:24 <merijn> :t either
15:05:25 <lambdabot> (a -> c) -> (b -> c) -> Either a b -> c
15:05:40 <mat10> is there a way to connect python module and haskell module ?
15:06:01 <merijn> There was someone working on that, but I forget the name
15:06:14 <merijn> The easiest way to connect python and haskell would be through C
15:06:19 <merijn> Using the FFI of both
15:06:29 <mat10> because, wring Sieve in python in compare with how they do Sieve in Haskell is a whole another level
15:07:14 <Maxdamantus> nother
15:07:42 <EvanR> :t nother
15:07:43 <lambdabot>     Not in scope: ‘nother’
15:07:43 <lambdabot>     Perhaps you meant ‘either’ (imported from Data.Either)
15:07:45 <mat10> other ?
15:08:07 <Maxdamantus> a whole nother level
15:08:44 <EvanR> yeah, proper english
15:09:28 <mat10> google say a whole other level
15:09:52 <EvanR> http://www.urbandictionary.com/define.php?term=a-whole-nother
15:12:32 <houshuang> mat10: http://hackage.haskell.org/package/json-python
15:12:50 <mat10> http://grammarist.com/usage/a-whole-nother/
15:13:16 <ReinH> mat10: grammarist is wrong. It does make sense in a variety of ways. http://speechdudes.wordpress.com/2013/10/03/tmesis-a-whole-nother-word-to-use/
15:13:33 <ReinH> I read a nice article about it recently that I can't find now
15:14:10 <mat10> right, so conclusion, a whole nother is correct
15:14:16 <mat10> houshuang:  thanks you
15:14:26 <EvanR> hahaha
15:14:29 <ReinH> Yep
15:14:41 <ReinH> I wish I could find the article. It was quite interesting :(
15:15:00 <EvanR> a whole nother is completely wrong, but "a whole other" is even more wrong than that
15:15:07 <mat10> right
15:15:13 <mat10> so, what is correct then ?
15:15:19 <mat10> seem like everything is wrong
15:15:20 <mat10> XD
15:15:21 <EvanR> a whole nother
15:15:33 <mat10> didnt you just said its wrong ?
15:15:49 <EvanR> youll be laughed out of whatever journal for using it
15:16:00 <ReinH> http://www.calvin.edu/weblogs/language/more/whole_nother_paper/
15:16:09 <EvanR> but laughed out harder for a whole other
15:16:10 <ReinH> Isn't it, but it is interesting
15:16:14 <mat10> so, better, never use "a while *other" notion
15:16:30 <mat10> if you are not prepared for a war
15:16:41 <ReinH> Ah, "metanalysis" is the closest to what I remember from the paper: http://english.stackexchange.com/questions/33155/a-whole-nother-way-of-looking-at-things
15:17:11 <japgolly> hello. I'm your little-slow-eh cousin visiting from Scala-land. Does Haskell have subtype variance? It doesn't because Haskell doesn't have inheritance, right?
15:17:16 <EvanR> grammatical english nazis who attempt to "correct" colloquial constructions are misguided
15:17:31 <EvanR> haskell does not have subtyping
15:17:44 <Peaker> haskell-src-exts seems to be confused by empty let, while ghc eats it
15:17:48 <mat10> haha, well, I learn some thing today :)
15:18:02 <japgolly> I didn't think so... let me ask a different question...
15:18:13 <ReinH> The thing I read got quite in depth: it isn't a "an whole other" because we expect article agreement between "an" and "whole"; it isn't "a whole other" because that changes the meaning: it is supposed to mean as "another", not "an other", etc...
15:18:25 <EvanR> it does not have inheritance from oop since it doesnt have classes
15:19:09 <silasm> are people really still discussing this? It's "another whole".
15:19:21 <mat10> ok, so its another whole
15:19:25 <ReinH> silasm: No, it is not.
15:19:26 <mat10> man, im so confuse
15:19:28 <EvanR> hes joking
15:19:48 <ReinH> "another whole" has the wrong meaning as well
15:20:12 <japgolly> StateT m s a <-- The only functor available for s here is a contravariant functor in a lens right? So a StateT m s a with a Lens t t s s will give you a StateT m t a.
15:20:16 <mat10> hehe, nothing ever work
15:20:41 <Peaker> japgolly: StateT is invariant on "s", not contra-variant
15:20:43 <benzrf> it's s m a actually
15:21:17 <silasm> well until "a whole nother" is accepted as valid English, "another whole" is the closest acceptable alternative imo.
15:21:41 <ReinH> silasm: it is "accepted as valid English", whatever that is supposed to mean.
15:21:41 <EvanR> no one would understand what youre saying in my country
15:21:55 <mat10> haha, the more you know :p
15:22:08 <silasm> ReinH: not among grammar pedants I know.
15:22:12 <japgolly> ah thanks, StateT s m a
15:22:26 <ReinH> They're wrong.
15:22:31 <ReinH> Prescriptivism lost.
15:22:36 <EvanR> tell them to go speak french ;)
15:22:48 <japgolly> yes, the s in StateT in invariant in terms of subtyping, but a Lens t t s s can be applied to a StateT s m a to create a StateT t m a, correct?
15:23:03 <silasm> I agree, honestly. English is ultimately too stupid to make enforcing its rules reasonable.
15:23:20 <EvanR> the rule is: a whole nother lol
15:23:24 <Peaker> japgolly: That's a Lens' t s  and yeah, that's what "zoom" does
15:23:50 <japgolly> In that case is it correct to say that Lens' is a contravariant functor on StateT?
15:23:51 <ReinH> silasm: "accepted as valid English" implies that there is an authority capable of accepting and validating. There ain't none.
15:24:10 <japgolly> :t zoom
15:24:11 <lambdabot> (Zoom m n s t, Control.Lens.Internal.Zoom.Zoomed n ~ Control.Lens.Internal.Zoom.Zoomed m) => LensLike' (Control.Lens.Internal.Zoom.Zoomed m c) t s -> m c -> n c
15:24:21 <Clint> and therefore everything is valid english or nothing is
15:24:21 <silasm> ReinH: "ain't". Well played. Again, I agree.
15:24:22 <ReinH> Time to put up the edwardk signal
15:24:28 <Peaker> japgolly: I don't think that's right
15:24:57 <ReinH> silasm: double negative as well; another one of those ridiculous "rules".
15:25:20 <mat10> I don't need no education
15:25:22 <japgolly> Peaker: Is it my terminology or do you mean the concept? The types work out.
15:25:26 <silasm> the closest thing, however, is probably Webster's, which probably doesn't have "nother" in it (at least not as a singular word, since it's never used in any other context).
15:25:43 <EvanR> uhg, the dictionary
15:25:52 <EvanR> never read it
15:26:19 <ReinH> silasm: A dictionary isn't anything like an authority on the correctness of language usage. Dictionaries are fundamentally descriptive.
15:26:29 <ReinH> What happens when languages change? Dictionaries change.
15:26:55 <mat10> which language is then , "smart" ?
15:27:07 <ReinH> mat10: no, but the people who employ it generally are.
15:27:13 <EvanR> im more interested in this lens question
15:27:26 <ReinH> We should move this to #haskell-blah
15:27:27 <Peaker> japgolly: Well, Lens' s t   is like  (s -> (t, t -> s))  so it's almost like a bidirectional function, so it's like applying a mapping on an invariant type via a bidirectional function. Not sure if that relates to "Functors"
15:27:40 <ReinH> (The lens question. That way we can focus on important linguistics discussions here.)
15:28:26 <japgolly> :t Lens'
15:28:27 <lambdabot>     Not in scope: data constructor ‘Lens'’
15:28:27 <lambdabot>     Perhaps you meant ‘Lens’ (imported from Control.Lens)
15:28:43 <Peaker> Lens' s t = Lens s s t t
15:29:26 <Peaker> japgolly: what are you wondering about though?
15:29:32 <EvanR> what does "contravariant functor" mean in scala?
15:29:33 <japgolly> Thanks, was trying to confirm :) So in other words (a -> b, a -> b -> b)
15:29:52 <indiagreen> not if you're talking about the lens library
15:29:55 <Peaker> japgolly: yeah, but extracting the (a->) part out of both is nice for conciseness and even performance
15:30:15 <Peaker> japgolly: but in the "lens" package, Lens isn't actually represented in this manner
15:30:21 <japgolly> woah... I'll have to ponder that offline, food for thought there
15:30:41 <japgolly> I'm getting my meaning of contravariant functor generally from internetland, not really scala.
15:31:00 <japgolly> functor is (basically) f a -> ??? -> f b right?
15:31:24 <japgolly> So fa -> (a->b) -> fb is a covariant functor
15:31:30 <japgolly> fa -> (b->a) -> fb is a contravariant functor
15:31:36 <EvanR> :t fmap
15:31:36 <lambdabot> Functor f => (a -> b) -> f a -> f b
15:31:41 <indiagreen> :t contramap
15:31:42 <lambdabot> Contravariant f => (a -> b) -> f b -> f a
15:32:14 <japgolly> Maybe I shouldn't be using the term functor for my case then....
15:32:55 <indiagreen> I think it's still called “functor” in category theory, but it's different from Haskell's “Functor”
15:32:59 <japgolly> I guess I'm just interested in that to convert a StateT s m a to a StateT t m a, I used a Lens' t s
15:34:16 <japgolly> indiagreen: well in cattheory a functor is (I believe) anything that moves objects and morphisms from one category to another (potentially the same) category right?
15:34:45 <japgolly> That's why I was thinking that Lens is acting as a functor for StateT in this case...
15:35:31 <L8D> @pl \(x, y) -> (f x, g y)
15:35:31 <lambdabot> f *** g
15:35:40 <japgolly> And contravariantly because the arrow flips if you imagine a Lens' a b being a higher level (a -> b)
15:36:06 <EvanR> a functor must also preserve the structure in the process of moving things
15:37:23 <phaazon> hm, I have two functions, fun1 :: (Expr a -> Expr b) -> Expr (a -> b), and fun2 :: (Expr a -> Expr b -> Expr c) -> Expr (a -> b -> c); I’d like to create a function fun that would accept any kind of lambda and create the resulting expression. I guess I need a functor like structure, but I can’t figure which one, any idea?
15:37:47 <phaazon> for instance
15:38:02 <phaazon> fun $ \x y z w -> … :: Expr (a -> b -> c -> d)
15:38:09 <phaazon> fun $ \x y z w -> … :: Expr (a -> b -> c -> d -> e)
15:38:13 <phaazon> ^ that one
15:38:27 <indiagreen> you need a polyvariadic function
15:38:35 <indiagreen> you can look at Text.Printf for inspiration
15:39:14 <phaazon> thanks indiagreen
15:39:41 <dutchie> is there a better way to turn an Int into a ByteString than pack . show?
15:39:54 <indiagreen> basically you make your “fun” function a method of a class, and then create instances for “Expr a” and “Fun x => Fun (Expr a -> x)”
15:39:57 <japgolly> EvanR: ah yes, thanks that too. I believe it does in the case of StateT
15:40:15 <EvanR> japgolly: im not sure how? can you explain the details
15:40:16 <phaazon> indiagreen: that sounds legit
15:40:20 <phaazon> thank you very much! :)
15:41:19 <bitemyapp> anybody know a trick for pretty-printing a string without string escaping?
15:41:27 <bitemyapp> doesn't even really need pretty printing
15:41:32 <phaazon> hi bitemyapp :)
15:41:36 <bitemyapp> right now I have:  "{\"size\":10,\"from\":0,\"query\":{\"term\":{\"name\":{\"value\":\"FooSys*\"}}},\"track_scores\":false}"
15:41:36 <EvanR> > Constant 3 'a'
15:41:37 <lambdabot>  Not in scope: data constructor ‘Constant’
15:41:39 <phaazon> I saw your tweet about ash, thanks! :)
15:41:43 <bitemyapp> and I want something I could copy-pasta
15:41:43 <EvanR> > Const 3 'a'
15:41:44 <lambdabot>  Couldn't match expected type ‘GHC.Types.Char -> t’
15:41:44 <lambdabot>              with actual type ‘Control.Applicative.Const a0 b0’
15:41:44 <bitemyapp> phaazon: :)
15:41:54 <japgolly> EvanR: Isn't it sufficient to observe that the result is a StateT with the same m? I'm not sure what the implications would be if the a were different but in this case it's preserved.
15:42:25 <phaazon> bitemyapp: I’m still building my engine (photon, you might already have seen a few screenshots/videos from it), and I discovered the need of pipes for model/view modeling :)
15:42:34 <phaazon> the need for*
15:42:41 <bitemyapp> phaazon: makes sense.
15:42:43 <phaazon> I’m not sure I’ll use pipes, but it’s very likely
15:42:58 <bitemyapp> pipes was nice for csv processing. Very solid memory use, though I didn't test huge amounts of data.
15:43:04 <phaazon> someone (ReinH?) pointed out your mvc package as well
15:43:06 <bitemyapp> I need to make a CSV data generator
15:43:13 <bitemyapp> phaazon: that's Gabe's, not mine.
15:43:23 <bitemyapp> I didn't write anything pipes related.
15:43:27 <bitemyapp> I just made a CSV test repo
15:43:29 <phaazon> oh, right
15:43:31 <phaazon> sorry :)
15:43:34 <bitemyapp> np
15:43:50 <bitemyapp> I really would like to know how to print JSON  /  a string properl.y
15:43:51 * hackagebot purescript 0.6.1.1 - PureScript Programming Language Compiler  http://hackage.haskell.org/package/purescript-0.6.1.1 (PhilFreeman)
15:44:00 <bitemyapp> so if anybody has any ideas there, I'd be appreciative.
15:44:14 <indiagreen> dutchie: yes, see http://hackage.haskell.org/package/bytestring-0.10.2.0/docs/Data-ByteString-Builder.html#v:intDec
15:44:25 <EvanR> japgolly: i was thinking more about the data structure, rather than the type
15:44:46 <indiagreen> if you need speed, you should be using builders. If you don't really need speed, “pack . show” should be totally fine.
15:45:17 <EvanR> a computation with state S will manipulate various values of type S, so how would you replace S with T and still keep that computation the same
15:45:34 <dutchie> currently i'm building it up in a list and throwing it to unwords, which i'm assuming uses Builder under the hood
15:45:49 <dutchie> speed is probably not the biggest concern
15:46:07 <dutchie> though maybe i should use a builder
15:46:20 <dutchie> meh, i'll just get it working now and builder-ify it another day
15:46:39 * indiagreen chuckles
15:46:40 <indiagreen> that's the spirit
15:47:28 <dutchie> :)
15:49:04 <japgolly> EvanR: It's like a dividing point where T pauses, branches off into a S, runs, then gets merged back into the T. Which means T needs to be provided when runState is called, as far as the parts of code working with StateT s they're oblivious.
15:49:33 <Zekka> japgolly: You probably don't need to literally introduce Lens but have you looked at the lens Zoom machinery?
15:49:50 <Zekka> The gist is that you provide a function that lifts stateful operations over Ts into stateful operations over Ss
15:50:07 <japgolly> No not at all! I only heard about it 5 min ago hehe
15:50:10 <Zekka> and in Lens those lifts are functions over lenses between Ss and Ts
15:50:22 <Zekka> but you can write them yourself adhoc without worrying about scary Kmett stuff
15:50:58 <Zekka> Another common fun trick in a similar vein is writing a morphism from Reader s a to State s a to let you write read-only functions on your state
15:51:38 <indiagreen> bitemyapp: can you explain again?
15:51:40 <Zekka> If you're wondering, by comparison, Zoom is basically a group of clever ways to write State t a -> State s a
15:51:52 <japgolly> oh interesting... and then that resulting state is thrown away? Because the outer is Reader?
15:52:04 <bitemyapp> indiagreen: I want to print the unescaped string
15:52:11 <indiagreen> putStrLn, then
15:52:13 <bitemyapp> right now I have:  "{\"size\":10,\"from\":0,\"query\":{\"term\":{\"name\":{\"value\":\"FooSys*\"}}},\"track_scores\":false}"
15:52:16 <bitemyapp> no
15:52:17 <bitemyapp> putStrLn prints that ^^
15:52:22 <bitemyapp> that's not what I want.
15:52:22 <EvanR> use show
15:52:25 <bitemyapp> no.
15:52:28 <Zekka> japgolly: I think you're slightly misunderstanding. Nothing's thrown away -- the Reader computation gets read-only access to the s in state
15:52:30 <bitemyapp> that's not it either.
15:52:32 <indiagreen> putStrLn . read, then
15:52:35 <EvanR> the opposite of show, read
15:52:43 <bitemyapp> wut
15:52:52 <Zekka> So it's technically a State s compoutation once you've passed it through that function, but because you originally wrote it as a Reader omputation you know it can't possibly actually change the state
15:53:05 <bitemyapp> Prelude> encode search
15:53:05 <bitemyapp> "{\"size\":10,\"from\":0,\"query\":{\"query_string\":{\"query\":\"FooSys*\"}},\"track_scores\":false}"
15:53:08 <bitemyapp> Prelude> show $ encode search
15:53:11 <bitemyapp> "\"{\\\"size\\\":10,\\\"from\\\":0,\\\"query\\\":{\\\"query_string\\\":{\\\"query\\\":\\\"FooSys*\\\"}},\\\"track_scores\\\":false}\""
15:53:14 <bitemyapp> Prelude> putStrLn $ show $ encode search
15:53:14 <bitemyapp> where am I supposed to use read there?
15:53:17 <bitemyapp> "{\"size\":10,\"from\":0,\"query\":{\"query_string\":{\"query\":\"FooSys*\"}},\"track_scores\":false}"
15:53:20 <japgolly> Zekka: oh sorry I had it the other way around in my head. Reader outside, State inside. The reverse of that makes much more sense. Temporary read-only-ness
15:53:24 <Zekka> japgolly: It's a different trick that falls into the same category of "things that make State safer"
15:53:26 <indiagreen> you need “Prelude> putStrLn $ encode search”
15:53:31 <EvanR> > read "\"{\\\"size\\\":10,\\\"from\\\":0,\\\"query\\\":{\\\"query_string\\\":{\\\"query\\\":\\\"FooSys*\\\"}},\\\"track_scores\\\":false}\""
15:53:33 <lambdabot>  *Exception: Prelude.read: no parse
15:53:39 <EvanR> oh :(
15:53:41 <bitemyapp> indiagreen: that would work if it wasn't ByteString
15:53:46 <bitemyapp> but I can import that putStrln and try it.
15:53:51 <bitemyapp> I don't think it'll do what you think it'll do.
15:53:53 <japgolly> Zekka: It's fascinating :D
15:53:59 <Zekka> because as a primitive for writing stateful computations, if they're ever large, State is a little unwieldy
15:54:11 <EvanR> > read "\"{\\\"size\\\":10,\\\"from\\\":0,\\\"query\\\":{\\\"query_string\\\":{\\\"query\\\":\\\"FooSys*\\\"}},\\\"track_scores\\\":false}\"" :: String
15:54:12 <lambdabot>  "{\"size\":10,\"from\":0,\"query\":{\"query_string\":{\"query\":\"FooSys*\"}...
15:54:20 <Zekka> (you can always use ST or whatever but it runs up aganist other problems involving the type system, and IO is obviously IO)
15:54:25 <japgolly> Zekka: Yeah, that's sort of my situation now.
15:55:08 <dhinojosa> > pure 4
15:55:10 <lambdabot>  No instance for (GHC.Show.Show (f0 a0))
15:55:10 <lambdabot>    arising from a use of ‘M33854883217489986615484.show_M33854883217489986615...
15:55:10 <lambdabot>  The type variables ‘f0’, ‘a0’ are ambiguous
15:55:10 <lambdabot>  Note: there are several potential instances:
15:55:10 <lambdabot>    instance [safe] GHC.Show.Show a =>
15:55:14 <bitemyapp> indiagreen: bytestring putstrln did it, thank you!
15:55:19 <Zekka> dhinojosa: For which applicative?
15:55:26 <Zekka> > pure 4 :: [Int]
15:55:27 <lambdabot>  [4]
15:55:31 <Zekka> > pure 4 :: Maybe Int
15:55:32 <lambdabot>  Just 4
15:55:36 <Zekka> > pure 4 :: IO Int
15:55:37 <dhinojosa> I was trying with Maybe
15:55:38 <lambdabot>  <IO Int>
15:55:44 <dhinojosa> Awesome Zekka!
15:55:45 <dhinojosa> Boom
15:55:49 <dhinojosa> that's all I needed
15:55:55 <Zekka> dhinojosa: No problem, bets of luck
15:56:17 <dhinojosa> I am thinking of using this IRC more for my questions.
15:56:19 <japgolly> I'm going to go try some things. Thank you all for the help and very interesting food for thought!
15:56:24 <Zekka> japgolly: Best of luck to you too
15:56:27 <Zekka> Hopefully we were helpful
15:56:36 <japgolly> Helpful and appreciated :D
15:56:40 <dhinojosa> Zekka: very :)
15:56:42 <japgolly> Cheers!
16:00:55 <gcganley`> is there a map of where the most haskell programmers are centered?
16:01:12 <gcganley`> like London or San Fransisco or Boston
16:01:34 <alrunner4> check http://www.haskellers.com
16:02:07 <gcganley`> alrunner4: cool thanks
16:02:20 <gcganley`> alrunner4: isnt that run by snoyman?
16:03:21 <Zekka> alrunner4: Strangely enough, I know apparently the only other Haskeller in my town!
16:03:41 <alrunner4> :P
16:03:58 <Zekka> Except he no longer lives here
16:06:15 <Welkin> which town is this?
16:06:46 <Welkin> I'm imagining a small town in rural germany
16:06:48 <Zekka> Welkin: Tucson, Arizona. Although they're missing a few people
16:07:06 <Zekka> I guess not everyone uses their site who uses Haskell
16:07:24 <gcganley`> Zekka: exactly lol
16:07:38 <Welkin> I have never found anyone who uses haskell anywhere around me
16:07:55 <gcganley`> no one is anywhere near me. i would have to drive an hour to reach the next person, all the way in boston
16:08:09 <gcganley`> I'm on cape cod, MA
16:08:26 <Welkin> when I look at local meetups it is always: scala, go, ruby, javascript
16:08:31 <Welkin> or other trendy junk
16:08:36 <indiagreen> ⁠/r/haskell has 7× more subscribers than there are accounts on that site
16:08:41 <Yxven> start a haskell meetup then
16:08:45 <Yxven> you'll find others
16:08:53 <gcganley`> Welkin: I think that haskell is pretty trendy, people talk about it alot
16:08:54 <RevJohnnyHealey> I'm at a haskell meetup.
16:09:05 <gcganley`> RevJohnnyHealey: where?
16:09:26 <RevJohnnyHealey> gcganley: Cambridge, MA
16:09:45 <gcganley`> RevJohnnyHealey: THAT WAS TONIGHT?!
16:09:52 <Zekka> We have a pretty big FP meetup here but lately it's taken over by Javascript programmers and Lisp useres
16:10:04 <gcganley`> RevJohnnyHealey: fuck... i meant to drive up to that...
16:10:29 <gcganley`> RevJohnnyHealey: how many people go there on a usual meeting?
16:10:59 <RevJohnnyHealey> 50 or so?
16:11:13 <gcganley`> from what times?
16:12:58 <RevJohnnyHealey> starting now.
16:13:35 <gcganley`> to when?
16:13:40 <seancorfield> looks like there are two Haskell meetups near me (San Francisco)... I thought the main SF group had gone inactive but it looks like it just took a year off in 2013 and started back up early this year...
16:13:54 <gcganley`> becuase wensdays are a school night for me and I live an hour away
16:14:14 <Zekka> Aren't there a lot of Haskell programmers out there  comparatively? I thought a lot of the trendy web companies were using it for stuff internally now.
16:14:36 <gcganley`> yeah i always think of SF as a hot bed for programmers
16:14:41 <seancorfield> That Haskellers map shows a Bay Area hotspot
16:14:51 <seancorfield> and the SF Haskellers group has 345 members
16:14:56 <gcganley`> do hipsters like haskell?
16:15:44 <seancorfield> looks like 30-50 attendees at meetups, based on their page... I just re-joined (I'd signed off when they went inactive)
16:16:10 <benzrf> gcganley`: hipsters loove haskell
16:16:16 <seancorfield> There are some Bay Area companies doing production Haskell... not sure how many tho'... bitemyapp you have any insight there?
16:16:20 <benzrf> gcganley`: as a massive fucking hipster i can confirm this
16:16:36 <gcganley`> benzrf: whats your favorite haskell?
16:16:47 <gcganley`> vinyl
16:16:49 <gcganley`> woops
16:18:53 * hackagebot yesod-test 1.4.2 - integration testing for WAI/Yesod Applications  http://hackage.haskell.org/package/yesod-test-1.4.2 (MichaelSnoyman)
16:19:08 <benzrf> gcganley`: vinyl is too mainstream
16:19:19 <benzrf> gcganley`: you ask anybody "what do hipsters use" theyll say vinyl
16:19:21 <benzrf> screw that
16:19:27 <benzrf> i use mp3s
16:19:30 <gcganley`> benzrf: betamax?
16:19:36 <benzrf> it's metahipster
16:19:50 <gcganley`> betahipster
16:19:51 <benzrf> hipsters defy the mainstream of mp3s by using flac, so i defy their mainstream with mp3
16:19:54 <benzrf> B)
16:20:12 <gcganley`> i use FLAC....
16:20:31 <gcganley`> i wounder if there is a flac codec in haskell
16:20:47 <benzrf> gcganley`: lol, mainstream ple
16:20:48 <benzrf> b
16:20:54 <benzrf> i bet you actually enjoy the music you listen to
16:21:13 * benzrf only listens to ironically terrible mashups
16:21:44 <bsmt> queue space jam
16:23:41 <Welkin> seancorfield: how do you manage the rotten atmosphere around technology in SF?
16:23:53 * hackagebot yesod-auth 1.4.1 - Authentication for Yesod.  http://hackage.haskell.org/package/yesod-auth-1.4.1 (MichaelSnoyman)
16:24:48 <Enigmagic> Welkin: wat
16:25:15 <Welkin> Enigmagic: the VC/startup culture (ie. get rich quick schemes)
16:25:19 <ChristianS> is there a function that checks whether a Char is a member/element of a Text? I cannot find it it Data. Text...
16:26:07 <ChristianS> never mind
16:26:13 <Enigmagic> Welkin: it's not hard to avoid those sorts of companies
16:26:57 <Welkin> what especially bothers me is the "we are changing the world with our SoLoMo application"
16:27:02 <Welkin> rhetoric*
16:27:45 <avocade> Welkin: Word
16:32:53 <seancorfield> Welkin: I don't work for a-holey startups :)
16:33:28 <seancorfield> I've done a couple of startups and the VC culture is soul-destroying... I never want to visit Sand Hill Road again :(
16:34:32 <seancorfield> I work for an Internet dating company, that bootstrapped itself about 10-15 years ago and has never taken outside funding. Still run by the original founders. Small dev team (doing Clojure). Everyone works from home. It's nice.
16:34:45 <Welkin> that is ideal
16:34:49 <Welkin> investors ruin everything
16:35:25 <jonsterling> benzrf: lmao
16:35:58 <benzrf> well tbh i only PARTLY Listen to ironically terrible mashups
16:36:07 <benzrf> they probably form no more than 10% of my overall music consumption
16:36:42 <koala_man> seancorfield: world singles? do you have any oktrends style statistics to share?
16:40:09 <merijn> Welkin: By not working for a startup :)
16:44:27 <chrisdotcode> help with a function name really quickly? I have a function named "parseReadme", but I'm not sure about punctuation.
16:44:34 <chrisdotcode> "parseREADME"? "parseReadMe"?
16:46:02 <dmj`> camel case is more idiomatic
16:46:09 <dmj`> parseReadme or parseReadMe
16:46:55 <gcganley`> parseReadme
16:46:56 <koala_man> I'd go with parseReadme, since "readme" is a term in itself
16:47:16 <Adeon> is it still necessary to manually upload hackage documentation
16:48:03 <chrisdotcode> Yeah, I'm thinking so. parseReadme looks ugly, but it makes the most sense
16:48:10 <chrisdotcode> either that, or parseREADME, github style
16:48:45 <koala_man> most style guides for other languages frown upon capitalizing words and abbreviations over 2 or 3 characters
16:49:06 <P4Titan> Hello all, I want to pattern match the last element in a list. It can be done with view patterns, but I am wondering if there is another way as they are not enabled by default
16:49:23 <koala_man> I don't think parseReadme looks ugly at all
16:50:06 <chrisdotcode> P4Titan: f [x] = code
16:50:26 <n4x> P4Titan: using an explicit case is the other way
16:50:34 <P4Titan> That matches a single element list
16:50:41 <n4x> which is basically a desugared version of a view pattern .. :P
16:50:50 <P4Titan> Should I use last explicitly then?
16:51:17 <DannyFritz> i'm having trouble trying to figure out how to floor a Float http://lpaste.net/6118782436206706688
16:54:34 <benzrf> DannyFritz: have you tried punching it
16:54:44 <DannyFritz> throw it to the ground
16:55:33 <DannyFritz> oh dur, i was missing () around sin
16:55:36 <DannyFritz> i feel dumb now
16:55:41 <DannyFritz> thanks for listening. :P
16:55:58 * DannyFritz successfully rubber ducked
17:03:53 * hackagebot data-ordlist 0.4.7.0 - Set and bag operations on ordered lists  http://hackage.haskell.org/package/data-ordlist-0.4.7.0 (LeonSmith)
17:07:44 <crazym4n> Is there any way to convert a Ratio to a Double or similar value without writing the function yourself?
17:08:10 <crazym4n> fromRational
17:08:21 <crazym4n> > fromRational (2 % 3)
17:08:23 <lambdabot>  0.6666666666666666
17:08:29 <crazym4n> ah, okay haha
17:09:21 <Cale> crazym4n: Also in general for converting between fractional types, there's realToFrac
17:10:15 <crazym4n> Interesting
17:10:30 <crazym4n> > (realToFrac 10.5) :: Ratio
17:10:31 <lambdabot>  Expecting one more argument to ‘GHC.Real.Ratio’
17:10:31 <lambdabot>  Expected a type, but ‘GHC.Real.Ratio’ has kind ‘* -> *’
17:10:45 <crazym4n> > (realToFrac 10.5) :: Ratio Integer
17:10:46 <lambdabot>  21 % 2
17:10:51 <crazym4n> That's really cool, thanks
17:18:53 * hackagebot happindicator3 0.2.1 - Binding to the appindicator library.  http://hackage.haskell.org/package/happindicator3-0.2.1 (mlacorte)
17:18:55 * hackagebot bet 0.1.0.0 - Betfair API bindings. Bet on sports on betting exchanges.  http://hackage.haskell.org/package/bet-0.1.0.0 (Adeon)
17:27:39 <dhinojosa> > Just(\e -> e + 1) :: Maybe (Integer -> Integer)
17:27:41 <lambdabot>  Just <Integer -> Integer>
17:27:50 <dhinojosa> So that's interesting
17:28:19 <dhinojosa> in ghci the above will complain that there isn't a show for  No instance for (Show (Integer -> Integer))
17:28:38 <Adeon> lambdabot uses secret alien technology to show them anyway
17:28:52 <dhinojosa> f(n) aliens ;)
17:33:53 * hackagebot objective 0.5 - Extensible objects  http://hackage.haskell.org/package/objective-0.5 (FumiakiKinoshita)
17:38:53 * hackagebot bet 0.1.1.0 - Betfair API bindings. Bet on sports on betting exchanges.  http://hackage.haskell.org/package/bet-0.1.1.0 (Adeon)
17:53:56 <phaazon> dammit
17:54:05 <phaazon> the PrintF trick doesn’t work for my use case :(
17:54:12 <phaazon> I think I need something more complex
17:55:43 <vanila> what is it you want to do?
17:56:20 <phaazon> vanila: I know how to lift a unary function, a binary function in my Expr
17:56:29 <phaazon> (Expr a -> Expr b) -> Expr (a -> b)
17:56:45 <phaazon> know, I’m looking for a way to lift haskell lambda to an expression
17:56:51 <phaazon> which is, in my case, Expr a -> b
17:57:09 <phaazon> and I can’t figure out how :(
17:57:34 <phaazon> since that would make… (Expr a -> b) -> Expr (a -> ?)
17:57:35 <vanila> I don't havea good picture of what you want to do excatly
17:57:57 <phaazon> vanila: lift any kind of arity function into my Expression
17:58:16 <vanila> oh so it doesn't have anything to do with lambda?
17:58:27 <phaazon> well, not really
17:58:38 <phaazon> but in practise, I use lambda only for that
17:58:44 <phaazon> fun $ \x y -> …
17:58:49 <vanila> well i think you can fill in  (Expr a -> Expr b) -> Expr (a -> b)  with typeclasses
17:58:57 <phaazon> yeah
17:59:04 <vanila> it might be a bit difficult
17:59:05 <phaazon> and I’m looking for one
17:59:13 <phaazon> I’ve been looking for that for hours :D
17:59:36 <vanila> do you have code for lifting unary and binary that I can see?
17:59:49 <phaazon> yeah
17:59:56 <phaazon> it’s pretty stupid
18:00:26 <phaazon> the fun function captures the function, puts it in a state, and get back and identifier and return a bound variables
18:00:42 <phaazon> https://github.com/phaazon/ash/blob/master/src/Ash.hs#L59
18:00:46 <phaazon> consider this:
18:00:58 <phaazon> fun1 :: (Expr a -> Expr b) -> Expr (a -> b)
18:01:05 <phaazon> fun1 _ = Bound (Var 0)
18:01:28 <phaazon> (I ommitted the State for simpler understanding)
18:01:38 <vanila> you have Let but no constructor for Lambda?
18:01:54 <phaazon> yeah
18:02:01 <phaazon> do you think it’s an issue?
18:02:09 <vanila> yes
18:02:10 <phaazon> Lam would fix it indeed
18:02:14 <vanila> why remove it?
18:02:17 <vanila> well
18:02:19 <vanila> let me explain why
18:02:24 <phaazon> yeah
18:02:30 <phaazon> because of the GADT
18:02:51 <vanila> An easy way to make a programming language is to start with lambda calculus - then add a couple of things
18:03:21 <vanila> this works well because lambda calculus is simple and extremely powerful as well as handling a lot of annoying things for you
18:03:53 <vanila> if you delete one of the things that make up lambda calculus it will make everything difficult because you have to reinvent parts of it
18:03:54 <phaazon> vanila: yeah
18:04:01 <phaazon> so
18:04:09 <phaazon> Lam :: Expr a -> Expr b -> Expr (a -> b)
18:04:19 <vanila> that looks wrong to me
18:04:34 <phaazon> if b = (c -> d)
18:04:43 <phaazon> I end up with Expr (a -> (c -> d))
18:04:48 <phaazon> which is Expr (a -> c -> d)
18:04:54 <phaazon> why wrong?
18:05:20 <phaazon> the single issue with that is I need to call lam several times
18:05:24 <phaazon> which is pretty annoying
18:05:33 <phaazon> lam $ \x -> lam $ \y -> Lam …
18:07:10 <crazym4n> How fast is map on lists?
18:07:16 <crazym4n> Is it O(n)?
18:07:41 <phaazon> depends on what you do with the list, crazym4n
18:07:46 <phaazon> it could be O(1) ;)
18:08:18 <phaazon> in the wrong scenario, yes, it’s O(n)
18:08:33 <tohast> hi All! I am beggining Haskell and one question puzzling my mind. How <$> and <*> can actually work together? <$> has type (<$>) :: Functor f => (a -> b) -> f a -> f b and (<*>) :: Applicative f => f (a -> b) -> f a -> f b. And my question is how it could be combined in something like this (+) <$> Just 3 <*> Just 4? It seems that after (+) <$> Just 3 we have partially applied function Just (3+) hovewer how can it work as we have (<$>) :: Functor f => (a -> b)
18:08:34 <tohast> -> f a -> f b?
18:08:42 <phaazon> vanila: it’s late
18:08:51 <phaazon> I got to wake up early in a few hours
18:08:54 <vanila> okay
18:08:59 <phaazon> I’ll see that later
18:09:06 <vanila> see what
18:09:15 <phaazon> but I guess I’m hitting a wall with that issue
18:09:19 <vanila> well
18:09:22 <vanila> there's an easy solution
18:09:22 <ReinH> :t ((+) <$>)
18:09:23 <lambdabot> (Num a, Functor f) => f a -> f (a -> a)
18:09:24 <phaazon> vanila: how to lift a n-ary function in my expression
18:09:29 <Gentmen> I'm looking at the Typeclassopedia example (do functors compose): `instance (Functor f, Functor g) => Functor (Compose f g)` But, how can `fmap` be implemented since its signature indicate a *single* Functor argument ::: ``` fmap :: Functor f => (a -> b) -> f a -> f b ```
18:09:33 <ReinH> :t (<*>)
18:09:34 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
18:09:35 <vanila> (A) just write  lam $ \x -> lam $ \y -> ...
18:09:36 <phaazon> vanila: yeah, lam lam lam lam everywhere
18:09:49 <vanila> (B) create a parser for your language that emits terms with lam etc. in them
18:10:04 <ReinH> :t (+) <$> Just 3
18:10:05 <lambdabot> Num a => Maybe (a -> a)
18:10:25 <ReinH> tohast:  (+) <$> Just 3 gives us a value of type Num a => Maybe (a -> a)
18:10:28 <ReinH> :t (<*>)
18:10:29 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
18:11:01 <ReinH> This matches up with the type of (<*>)'s first argument: Maybe is an Applicative, and `b' can be set to `a'
18:11:56 <ReinH> :t (<*>) `asAppliedTo` ((+) <$> Just 3)
18:11:57 <lambdabot> Num b => Maybe (b -> b) -> Maybe b -> Maybe b
18:13:23 <houshuang> Argh fighting with the linker just to cabal install a library, Haskell you're not being nice :(
18:13:43 <ReinH> :t \f g -> fmap f . fmap g
18:13:43 <lambdabot> Functor f => (a -> b) -> (a1 -> a) -> f a1 -> f b
18:16:06 <ReinH> Gentmen: Talking abstractly for a moment, given two functors F : D -> E and G : C -> D, their composition (F . G) is a functor from C -> E that sends objects X in C to F(G(X)) and arrows f in C to F(G(f))
18:16:17 <ReinH> (both in E)
18:16:28 <crazym4n> Sorry for a late response, but in what case can map be O(n) and what case can map be O(1)?
18:17:15 <ReinH> crazym4n: Do you have a reason for thinking that map can be O(1)?
18:17:37 <crazym4n> No, but the fact that he mentioned it made me wonder
18:17:38 <tohast> ReinH: type for <$> misleading me. resulting value of <$> is f b. Hovewer it is function for (+) <$> Just 3.
18:17:43 <johnw> map is always O(n); now, due to laziness, you might only access the first element of the list, in which case n = 1
18:17:44 <crazym4n> I'm guessing it's O(n)
18:17:53 <crazym4n> yeah, that's what I was thinking he meant
18:18:28 <crazym4n> How can I speed it up? Using REPA arrays maybe?
18:18:40 <johnw> that would need an understanding of what you're doing
18:19:28 <ReinH> Gentmen: talking about Haskell, now, a composition of Functor instances f and g can be given by data Compose f g a = Compose (f (g a))
18:20:14 <crazym4n> I'm just messing with infinite fractional expansions (I don't know what they are actually called)
18:20:20 <ReinH> remember that f and g are type constructors (of kind * -> *), so instances of Compose are like: Compose Maybe Maybe a
18:20:37 <crazym4n> > fromRational $ foldl1 (+) $ take 5000 $ map (\x -> 1 % x) [1..] --for example
18:20:41 <lambdabot>  mueval-core: Time limit exceeded
18:21:07 <Zer000> is there a function to get all possible sub-lists of a list?
18:21:34 <ReinH> Gentmen: now we have that if f and g are instances of Functor, then so is Compose f g a for all a: (Functor f, Functor g) => Functor (Compose f g)
18:21:43 <ReinH> Zer000: what does "all possible sub-lists" mean?
18:21:53 <dfeuer> :k Compose
18:21:53 <lambdabot>     Not in scope: type constructor or class ‘Compose’
18:21:56 <ReinH> Zer000: the equivalent of a powerset?
18:22:08 <ReinH> Gentmen: can you think of what the definition for fmap would be for Compose?
18:22:22 <hakujin> Zer000: I think you want permutations
18:22:25 <hakujin> :t permutations
18:22:25 <lambdabot> [a] -> [[a]]
18:22:31 <ReinH> fmap f (Compose x) = ?
18:22:42 <AlecTaylor> hi
18:22:44 <Zer000> sorry I forgot I can hoogle by type. The thing I wanted was subsequences
18:22:50 <Zer000> hoogle is crazy!
18:23:36 <AlecTaylor> How do I remove these two parentheses? Prelude> putStrLn $ "length \"foo\" = " ++ show (length "foo")
18:23:44 <ReinH> :t fmap
18:23:44 <lambdabot> Functor f => (a -> b) -> f a -> f b
18:24:18 <ReinH> AlecTaylor: not easily. There's nothing wrong with parenthesis though.
18:24:27 <AlecTaylor> Aren't they the root of all evil?
18:24:28 <AlecTaylor> :3
18:24:31 <ReinH> Nope.
18:24:41 <ReinH> Lots of people prefer them to $
18:24:57 <AlecTaylor> Well they're much more common
18:25:03 <ReinH> Personally I would keep the parenthesis
18:25:14 <AlecTaylor> In fact, I can't think of another language which allows you to use something other than parentheses
18:25:26 <AlecTaylor> To specify explicit OoO
18:25:29 <ReinH> grouping expressions with parenthesis is unambiguous
18:25:36 <AlecTaylor> Yeah
18:25:51 <ReinH> Gentmen: did I lose you?
18:27:51 <tohast> ReinH: could you explain in more detail how :t <$> changed to :t (+) <$> Just 3? I thought that type "f b" in :t <$> cant change to Maybe (a -> a).
18:28:08 <ReinH> tohast: ok
18:28:14 <ReinH> :t (<$>)
18:28:15 <lambdabot> Functor f => (a -> b) -> f a -> f b
18:28:25 <ReinH> Now, if we partially apply it:
18:28:31 <ReinH> :t (+) <$> Just 3
18:28:32 <lambdabot> Num a => Maybe (a -> a)
18:29:07 <ReinH> Haskell needs to be able to *unify* the type of (+) with (a -> b)
18:29:38 <ReinH> Well, that's easy: a ~ Num a => a and b ~ a (where ~ means "unifies with")
18:29:50 <ReinH> Then, given:
18:29:57 <ReinH> :t (+) <$>
18:29:57 <lambdabot>     parse error (possibly incorrect indentation or mismatched brackets)
18:30:04 <ReinH> :t ((+) <$>)
18:30:04 <lambdabot> (Num a, Functor f) => f a -> f (a -> a)
18:30:31 <ReinH> Ok, let's take a step back. Let's say that these numbers are Int rather than any instance of Num
18:30:33 <ReinH> that's going to get confusing
18:30:55 <ReinH> :t ((+) <$>) :: Maybe (Int -> Int)
18:30:56 <lambdabot>     Couldn't match expected type ‘Maybe (Int -> Int)’
18:30:56 <lambdabot>                 with actual type ‘f0 a0 -> f0 (a0 -> a0)’
18:30:56 <lambdabot>     In the expression: ((+) <$>) :: Maybe (Int -> Int)
18:31:09 <ReinH> :t ((+) <$>) :: (Int -> Int) -> Maybe (Int -> Int)
18:31:10 <lambdabot>     Couldn't match type ‘Maybe Int’ with ‘Int -> Int’
18:31:10 <lambdabot>     Expected type: (Int -> Int) -> Maybe (Int -> Int)
18:31:10 <lambdabot>       Actual type: Maybe Int -> Maybe (Int -> Int)
18:31:13 <ReinH> sorry
18:31:59 <ReinH> :t ((+) <$>) :: Functor f => f Int -> f (Int -> Int)
18:32:00 <lambdabot> Functor f => f Int -> f (Int -> Int)
18:32:51 <ReinH> so the right hand side of <$> here needs to be of type Functor f => f Int
18:32:59 <ReinH> :t Just (3 :: Int)
18:33:00 <lambdabot> Maybe Int
18:33:14 <ReinH> and Maybe is an instance of Functorm, and (3 :: Int) is an Int
18:33:48 <ReinH> which means that:
18:33:50 <ReinH> :t (+) <$> Just (3 :: Int)
18:33:50 <lambdabot> Maybe (Int -> Int)
18:34:09 <ReinH> :t (<$>)
18:34:09 <lambdabot> Functor f => (a -> b) -> f a -> f b
18:34:17 <tohast> ReinH: cool! I didn't thought about partial application "inside" the Functor value.
18:34:20 <ReinH> so we have a function (+) of type Int -> Int -> Int
18:34:32 <ReinH> so we need to unify Int -> Int -> Int with a -> b
18:34:38 <johnw> tohast: just to be technical, there is no such thing as a "Functor value"
18:34:44 <ReinH> we can do that with: a ~ Int, b ~ Int -> Int
18:34:58 <ReinH> since Int -> Int -> Int is the same as Int -> (Int -> Int)
18:35:14 <ReinH> And we know we're using the Maybe instance of Functor
18:35:25 <johnw> tohast: Functors map types, like Maybe maps Int to Maybe Int.  A particular Maybe Int is not a functor, nor is the type 'Maybe Int' a functor.
18:35:25 <ReinH> so we can replace those everywhere and get the type of (<$>) *specialized* to its arguments:
18:35:42 <ReinH> (Int -> Int -> Int) -> Maybe Int -> Maybe (Int -> Int)
18:36:16 <ReinH> tohast: does that make more sense?
18:37:49 <tohast> ReinH: ooohh... I need to save your answers and think about it more throughly. And maybe get used to usage of <$> and <*> in practical tasks. Thank you a lot!
18:38:19 <ReinH> tohast: you're welcome
18:42:40 <ReinH> johnw: on another note, it turns out XML parsing in Haskell is pretty nice, all things considered.
18:42:51 <johnw> cool
18:43:23 <ReinH> johnw: On the other hand, I am repeatedly reminded of how terrible AWS's API is
18:45:18 <AlecTaylor> lol
18:46:41 <seafood> Anyone here know anything about stackage?
18:46:50 <johnw> I know a few things about it
18:48:01 <seafood> My question is, do they test that the builds work on all the platforms they support? i.e. do they test it on Linux, Mac OS X and Windows?
18:48:17 <johnw> as far as I know, they test it mainly on Linux
18:48:21 <johnw> you'd have to ask them
18:48:43 <johnw> one of the main authors reads reddit, so if you comment on any recent reddit thread about it, you may get an answer that way
18:50:32 <DannyFritz> i'm having a hard time printing out a 2d array in a table to the console
18:51:11 <DannyFritz> i'm having a hard time printing out a 2d array in a table to the console
18:51:13 <DannyFritz> oops
18:59:13 <DannyFritz> can i print from a lambda function?
19:00:51 <DannyFritz> oh, the reason nothing is printing is because none of my map indexes are being evaluated. hrmmm
19:02:41 <houshuang> seafood: I think the main thing is to make sure that there are no Cabal conflicts - which goes for all platforms
19:03:48 <seafood> houshuang: Right, is that the only problem it’s solving?
19:14:13 <houshuang> seafood: Well it does run the test-suites, but many packages don't have tests at all. It's mainly focused on solving "cabal hell" - which is real enough unfortuntely.
19:14:35 <seafood> houshuang: That’s an excellent problem to solve, and I’m happy it exists.
19:15:17 <houshuang> seafood: Yeah it's at least a stop-gap solution. It works well when all the packages you need are inside Stackage, installing Yesod for example is a breeze. But when you need some outside packages it can be tricky.
19:15:28 <Zer000> can I extend the show function to output "ADD" instead of (+) for example? I'd like to print a list of mathematical functions like that
19:16:20 <ReinH> Zer000: you mean that you want show (+) to be "ADD"?
19:16:25 <Zer000> yes
19:16:28 <ReinH> No.
19:16:48 <ReinH> In fact it's impossible
19:16:51 <Zer000> So can I implement a custom show?
19:16:55 <ReinH> No.
19:17:17 <ReinH> There is no way to determine if a function passed is (+)
19:17:21 <Zer000> so you can't use pattern matching, if statements or case for comparing functions/
19:17:25 <Zer000> ok
19:17:28 <ReinH> There is no pattern matching for functions
19:17:34 <Zer000> ohya
19:17:37 <ReinH> Functions are completely opaque
19:17:46 <Zer000> ReinH, I really do need to print a list of them though
19:17:53 <ReinH> Then print a list of them?
19:17:58 <vanila> Zer000, maybe you could create a data type
19:18:04 <vanila> data Functions = ADD | ...
19:18:10 <vanila> and then have an interpretation function
19:18:11 <ReinH> Perhaps what you want to do is write an expression type
19:18:13 <vanila> interpret ADD = (+)
19:18:16 <vanila> ...
19:18:23 <ReinH> data Expr = Add Int Int | Mult Int Int ...
19:18:31 <vanila> this way you can apply the function by going   interpret f x y
19:18:43 <vanila> but of course you can show it too
19:18:44 <ReinH> then evaluate either by printing or by actually doing arithmetic
19:18:44 <Zer000> vanila, what's interpret?
19:18:56 <vanila> it turns the name for a function into the function itself
19:19:18 <Zer000> cool. Ok I dig that idea
19:19:45 <ReinH> showName :: Expr -> String; showName Add _ _ = "ADD"; showName Mult _ _ = "MULT"
19:20:07 <Zer000> sweet
19:20:10 <ReinH> eval :: Expr -> Int; eval (Add x y) = x + y
19:20:10 <ReinH> etc
19:20:25 <Zer000> thanks guys!
19:20:42 <ReinH> this can even be changed to be recursive, so you can have Add (Mult 2 (Add 2 3)) (Add 3 4))
19:20:46 <Axman6> eval x + eval y is probably what you meant
19:20:53 <ReinH> Axman6: No, I did not.
19:20:57 <Axman6> D:
19:21:02 <n4x> Add Int Int
19:21:08 <Axman6> oh right, I see your definition now
19:22:00 <ReinH> (really it would be like Add (Mult (Val 2) (Val 3)) (Val 2)), but you can be a bit clever and get the above)
19:24:25 <ReinH> in fact, you can be really clever and get (1 + 1) :: Expr
19:24:39 <ReinH> to be (Add (Val 1) (Val 1))
19:24:40 <Axman6> don't need to be too clever...
19:24:44 <ReinH> indeed
19:25:10 <Axman6> instance Num Expr where (+) = Add; fromIntegral = Var . fromIntegral etc
19:25:22 <ReinH> yes, that is the requisite amount of cleverness ;)
19:25:30 <Axman6> (well worth doing because you get all the fixity and binding power right
19:25:40 <Axman6> for free)
19:25:44 <ReinH> it's rather nice really
19:25:49 <ReinH> although a bit fiddly
19:25:58 <ReinH> 2 == 1 + 1 ??
19:26:08 <ReinH> structural equality says no
19:26:20 <ReinH> semantically, they are equal, but checking involves evaluation
19:26:22 <n4x> instance Eq Expr where x == y = (eval x) == (eval y)
19:26:25 <Axman6> (==) = (==) `on` eval
19:26:28 <ReinH> Yes.
19:26:30 <benzrf> Axman6: lol
19:26:43 <n4x> unfair Axman6
19:26:46 <ReinH> :)
19:26:49 <ReinH> totes fair
19:26:52 <ReinH> on is a nice combinator
19:37:00 <Zer000> Axman6, "instance Num Expr where (+) = Add; fromIntegral = Var . fromIntegral etc" can you explain the fromIntegral part? and you meant Val  right?
19:37:30 <Zer000> what I don't get is, if Val is a type constructor, why are you composing it with a function?
19:40:37 <benzrf> Val /= Var
19:42:30 <Zer000> benzrf, ok so what's Var then
19:43:37 <benzrf> a data constructor, probably
19:43:39 <benzrf> i dont know the context
19:44:33 <ReinH> Val is a data constructor, which means it is a function
19:45:24 <Zer000> interesting
19:46:08 <houshuang> Is there a pattern for doing something to three levels of lists - like I have a list of type [[]], and I want to apply a function to all inner elements, then a function to all elements, and then a function to the whole list?
19:46:26 <houshuang> (three = arbitrary depth). I figure something like map.map.map, but can't quite figure it out
19:48:46 <Hijiri> if you want to map three levels down, map.map.map is what you'd want (or fmap.fmap.fmap)
19:48:58 <Hijiri> > (fmap.fmap.fmap $ (+5)) [[[2]]]
19:49:00 <lambdabot>  [[[7]]]
19:49:16 <vanila> map (f . map (g . map h))
19:49:20 <Hijiri> > (fmap.fmap.fmap $ (+5)) [[[2],[3,4,5]],[[1]]]
19:49:21 <lambdabot>  [[[7],[8,9,10]],[[6]]]
19:49:38 <Hijiri> :t map.map.map
19:49:38 <lambdabot> (a -> b) -> [[[a]]] -> [[[b]]]
19:49:44 <Hijiri> :t fmap.fmap.fmap
19:49:44 <lambdabot> (Functor f2, Functor f1, Functor f) => (a -> b) -> f (f1 (f2 a)) -> f (f1 (f2 b))
19:49:51 <vanila> :t \f g h -> map (f . map (g . map h))
19:49:52 <lambdabot> ([b1] -> b) -> ([b2] -> b1) -> (a -> b2) -> [[[a]]] -> [b]
19:50:51 <Hijiri> sorry, I didn't read your question properly
19:50:54 <Hijiri> vanila's is right
19:55:16 <DannyFritz> is there a good way to unlazy map so i can print each element in an list to the console?
19:55:53 <benzrf> DannyFritz: what
19:56:04 <benzrf> DannyFritz: what does laziness have to do with that
19:56:09 <Welkin> DannyFritz: just use print or show
19:56:25 <Welkin> er, print or putStrLn
19:56:25 <DannyFritz> benzrf: when i try to print each thing in the map nothing happens. i assume because i never index and evaluate the index
19:56:55 <benzrf> DannyFritz: you think you know how I/O works in haskell but you don't
19:57:01 <DannyFritz> :P
19:57:05 <benzrf> DannyFritz: i recommend learning how it works before trying to use it
19:57:20 <Welkin> > putStr $ show $ map (+4) [1..10]
19:57:22 <lambdabot>  <IO ()>
19:57:28 <Welkin> er, lambdabot doesn't do IO
19:57:32 <Welkin> anyway
19:57:45 <benzrf> Welkin: i suspect that DannyFritz came over from lisp and decided to do `map print [1..10]' firs tthing
19:58:04 <DannyFritz> this is my first functional language
19:58:09 <benzrf> ah
19:58:09 <DannyFritz> so something similar to your story
19:58:30 <Hijiri> evaluating an (IO something) doesn't do anything on its own, it has to get read by the RTS somehow
19:58:31 <DannyFritz> but i created something that prints out sine waves to the console. and i want it to animate.
19:58:40 <Hijiri> so you need to make it part of main or a fork
19:59:22 <joehh> > map print [1..10]
19:59:24 <lambdabot>  [<IO ()>,<IO ()>,<IO ()>,<IO ()>,<IO ()>,<IO ()>,<IO ()>,<IO ()>,<IO ()>,<IO...
19:59:32 <DannyFritz> here is where i'm at http://lpaste.net/9040259413314633728
19:59:45 <Hijiri> > mapM_ print [1..10]
19:59:47 <lambdabot>  <IO ()>
20:00:27 <Hijiri> mapM_ f is sequence_ . map f
20:00:39 <Hijiri> in the context of IO, sequence_ strings together all the IO actions
20:00:45 <Hijiri> to make a big one that does them in sequence
20:01:19 <Hijiri> and then if this big IO action is run by the RTS, it will perform them
20:01:41 <Hijiri> you should think of a value of type (IO a) as a program that can yield a value of type a
20:01:52 <Kaidelong> incidentally, in most contexts, you can actually do something like "map print [1..10]"
20:02:07 <Kaidelong> haskell does not keep very much company in not having that as a thing
20:02:32 <Hijiri> a program doesn't do anything until it's run, so you need your (IO a) run somehow
20:03:06 <Kaidelong> (however consider that the result of that would be [(),()..] in a language that did things that way, not very useful compared to a result of [<action that prints 0>, <action that prints 1> ..]
20:03:30 <Hijiri> there are different tools for composing IO actions ((>>=), (<*>), fmap, etc.) and you want to build "main" out of small components using these
20:03:45 <codygman> I'm pretty proud of this function I wrote earlier. It's small, but it feels like the culmination of my learning efforts paying off: http://lpaste.net/114594
20:03:48 <Hijiri> if you're following a tutorial these will get introduced as you go on
20:03:54 * hackagebot bloodhound 0.4.0.0 - ElasticSearch client library for Haskell  http://hackage.haskell.org/package/bloodhound-0.4.0.0 (bitemyapp)
20:04:24 <Hijiri> codygman: what's a Cursor?
20:04:47 <codygman> Text.Xml.Cursor, basically a representation of html elements.
20:04:55 <codygman> Hijiri: ^^
20:06:08 <Kaidelong> DannyFritz: anyway what you want is mapM_
20:06:09 <Welkin> codygman: using (***), nice
20:06:20 <Kaidelong> :t mapM_ print
20:06:21 <lambdabot> Show a => [a] -> IO ()
20:06:22 <Welkin> I have found several chances to use that but have not done so
20:06:47 <Welkin> I should go fix that, even if it means adding an extra import from Control.Arrow
20:06:56 <DannyFritz> Kaidelong: thanks. i'll look into it
20:07:39 <Kaidelong> you can do it using map, but it takes more effort, figuring out how to do it might be a good way to learn about how IO works
20:07:51 <codygman> Welkin: In this case I felt it really helped readability, so long as you know what *** does somewhat.
20:08:05 <Kaidelong> :t foldr (>>) (return ())
20:08:06 <lambdabot> Monad m => [m a] -> m ()
20:08:23 <Kaidelong> :t foldr (>>) (return ()) . map print
20:08:24 <lambdabot> Show a => [a] -> IO ()
20:09:11 <Kaidelong> :t map print
20:09:12 <lambdabot> Show a => [a] -> [IO ()]
20:09:59 <Axman6> :t foldM
20:10:00 <lambdabot> Monad m => (a -> b -> m a) -> a -> [b] -> m a
20:11:00 <Hijiri> :t mapM_ print
20:11:00 <lambdabot> Show a => [a] -> IO ()
20:12:28 <bitemyapp> :t mapM print
20:12:29 <lambdabot> Show a => [a] -> IO [()]
20:16:44 <Zer000> which is more correct? http://lpaste.net/114598
20:18:37 <merijn> Zer000: Don't use "Fractional a => Expr a"
20:18:54 <merijn> Zer000: DatatypeContexts are bad, that's why they were removed in Haskell2010
20:19:16 <merijn> I would use the second minus the Fractional constraint
20:21:10 <Zer000> merijn, I don't understand something - if I remove the fractional constraint wouldn't I have trouble writing a function that evaluates expressions with division?
20:22:06 <Axman6> you can use div
20:22:16 <Axman6> if you stick to integral values
20:22:32 <n4x> you already need to have the constraint in the function
20:23:00 <bananagram> :t print
20:23:01 <lambdabot> Show a => a -> IO ()
20:23:19 <Zer000> oh, so Expr a can have a of any type but eval :: Expr a (implemented properly) would have to have a constrained?
20:23:30 <Axman6> of, you can parameterise your Expor type by the type that's contained in Vars: data Expr a = Var a | Add (Expr a) (Expr a) | ...; instance Fractional a => Fractional (Expr a) where (/) = Div
20:23:39 <Axman6> yep
20:23:59 <Zer000> interesting
20:24:02 <Zer000> thanks
20:24:29 <Axman6> Zer000: the reason to now put the type constraint on the type itself is that it infacts the types of all functions that have to work on Exprs. show will then have type show :: (Fractional a, Show a) => Expr a -> String, which is unnecessary
20:24:39 <Axman6> s/now/not
20:24:50 <Zer000> ok, cool
20:25:28 <cdk> codygman: I think your function can be simplified even more: M.fromList . filter (not . null . fst) . map (take 1 . attribute "name" &&& take 1 . attribute "value") $ c $// element "input"
20:25:47 <cdk> i'd probably split that into a 2 functions though
20:50:21 <Zer000> a little bit of help please - I don't understand what the errors mean: http://lpaste.net/114602
20:51:12 <vanila> why don't you try changing Floating a, Integral with Num
20:51:32 <ahammel> howdy
20:52:58 <johnw> hi ahammel
20:53:02 <ahammel> Is there an idiom for (m >>= f >>= f >>= f)?
20:53:17 <johnw> not really
20:53:31 <johnw> that would be iterateM, except that there is no guarantee it will end
20:53:39 <johnw> you can find some possible implementations in the monad-extras package
20:53:56 <johnw> maybe one of them will be what you need
20:54:00 <merijn> johnw: Don't forget monad-loops
20:54:08 <johnw> i don't think monad-loops has this
20:54:13 <johnw> unless he includes a guard condition
20:54:14 <Zer000> vanila, well now I get many "could not deduce" errors in the eval function
20:54:29 <johnw> but yeah, see monad-loops
20:54:36 <johnw> it may have a better answer than what you're asking for
20:55:04 <merijn> Zer000: "(Floating a, Integral a)" <- this can't be right
20:55:16 <merijn> Zer000: There are no types which are both floating and integral
20:55:49 <Zer000> oh i see. is there somewhere I can read up on why?
20:56:06 <merijn> Because being Integral and Floating are contradictory properties?
20:56:43 <vanila> eval :: Expr Double -> Double
20:56:50 <vanila> try making it work with a concrete type like Double
20:56:55 <Zer000> "The class Integral provides whole-number division and remainder operations." oh.
20:56:56 <ahammel> yeah, it's more of a "take some starting data and bind the same thing 'n' times" deal. There isn't really a guard condition
20:56:58 <vanila> then you'll see that you need ** instead of ^
20:57:06 <merijn> Zer000: Btw
20:57:32 <ahammel> Cheers for the monad-loops and monad-extras tips
20:57:47 <merijn> Zer000: Try making "eval :: Floating a => Expr a -> a" and adding "eq :: Expr Double" as signature
20:59:05 <merijn> Zer000: The error on line 21 is basically saying "Val 4 is polymorphic and I don't know which type to pick!"
20:59:51 <merijn> Because you're doing "show $ eval eq" GHC needs to know which instance of show to use, which means it needs to know what the type of "eval eq" is, which is unknown because the type of "eq" is ambiguous
21:01:15 <Zer000> merijn, hey that helps. I think I'm using the wrong power function though, ^ requires the second argument to be an Integral
21:01:26 <merijn> :t (^)
21:01:27 <lambdabot> (Num a, Integral b) => a -> b -> a
21:01:30 <merijn> Try
21:01:32 <merijn> :t (**)
21:01:33 <lambdabot> Floating a => a -> a -> a
21:01:43 <merijn> > 2 ** 2
21:01:44 <lambdabot>  4.0
21:02:00 <Zer000> >2 ** 0.5
21:02:07 <Zer000> no? it won't do it for me
21:02:13 <merijn> You need a space after >
21:02:20 <Zer000> > 2 ** 0.5
21:02:22 <lambdabot>  1.4142135623730951
21:02:24 <Zer000> COOL
21:02:43 <Zer000> ty
21:02:59 <merijn> Zer000: There's separate functions because restricting the exponent to integral types allows for a more efficient implementation
21:03:03 <Welkin> > 2 ** pi
21:03:04 <lambdabot>  8.824977827076287
21:03:20 <Welkin> > e ** i * pi
21:03:21 <lambdabot>  e**i * pi
21:03:25 <Welkin> > e ** (i * pi)
21:03:26 <lambdabot>  e**(i * pi)
21:03:34 <merijn> hah
21:03:35 <Welkin> hrm
21:03:36 <merijn> :t e
21:03:36 <lambdabot> Expr
21:03:38 <merijn> :)
21:03:45 <Welkin> > e
21:03:46 <lambdabot>  e
21:03:54 <merijn> Welkin: e is from simple-reflect
21:04:01 <merijn> Which allows us to do
21:04:08 <merijn> > map f [a,b,c,d,e]
21:04:10 <lambdabot>  No instance for (GHC.Show.Show b0)
21:04:10 <lambdabot>    arising from a use of ‘M504685742334193989220858.show_M5046857423341939892...
21:04:10 <lambdabot>  The type variable ‘b0’ is ambiguous
21:04:10 <lambdabot>  Note: there are several potential instances:
21:04:10 <lambdabot>    instance [safe] GHC.Show.Show
21:04:13 <merijn> hmm
21:04:25 <merijn> > map f [a,b,c]
21:04:26 <lambdabot>  No instance for (GHC.Show.Show b0)
21:04:26 <lambdabot>    arising from a use of ‘M676338633958085300520870.show_M6763386339580853005...
21:04:26 <lambdabot>  The type variable ‘b0’ is ambiguous
21:04:26 <lambdabot>  Note: there are several potential instances:
21:04:26 <lambdabot>    instance [safe] GHC.Show.Show
21:04:37 <merijn> I'm confused...
21:05:00 <merijn> oh, here we go
21:05:09 <merijn> > map f [a,b,c,d,e] :: [Expr]
21:05:10 <lambdabot>  [f a,f b,f c,f d,f e]
21:05:45 <n4x> :t f
21:05:46 <lambdabot> FromExpr a => a
21:06:05 <Zer000> sorry vanila I didn't see your comment about ^ and ** haha, I didn't mean to ignore you
21:06:14 <Welkin> :t (^^)
21:06:15 <lambdabot> (Integral b, Fractional a) => a -> b -> a
21:06:18 <Welkin> :t (^)
21:06:19 <lambdabot> (Num a, Integral b) => a -> b -> a
21:06:22 <johnw> merijn: I have Expr
21:06:24 <johnw> s/have/love
21:07:10 <Welkin> what is the math package which contains math constants like "e", "i", etc
21:07:32 <merijn> I don't think we have 'i', but we have complex
21:07:44 <merijn> > sqrt (-1) :: Complex Double
21:07:45 <lambdabot>  (-0.0) :+ 1.0
21:08:04 <n4x> > let i = √ (-1) ∷ Complex Double in 1 + 2 * i
21:08:05 <lambdabot>  <hint>:1:9: parse error on input ‘√’
21:08:22 <merijn> Why would you expect that to work? :)
21:08:25 <n4x> > let i = sqrt (-1) :: Complex Double in 1 + 2 * i
21:08:26 <lambdabot>  1.0 :+ 2.0
21:08:26 <Welkin> haha
21:08:36 <merijn> > generalCategory '√'
21:08:37 <lambdabot>  MathSymbol
21:08:39 <n4x> I didn't, I wrote \sqrt without realizing
21:08:44 <merijn> :D
21:08:57 <merijn> You can also just write
21:09:04 <merijn> > let i = 0 :+ 1 in i
21:09:06 <lambdabot>  0 :+ 1
21:09:11 <benzrf> @let √ = sqrt
21:09:11 <lambdabot> Plugin `eval' failed with: Enum.toEnum{Word8}: tag (8730) is outside of bounds (0,255)
21:09:17 <benzrf> dammit
21:09:22 <merijn> Must be an operator
21:09:34 <merijn> @let (√) = sqrt
21:09:35 <lambdabot>  Defined.
21:09:43 <benzrf> aw
21:09:45 <Welkin> how do you type non-standard unicode characters so easily?
21:09:45 <merijn> Don't think you can use it without parens though
21:09:53 <merijn> Welkin: I'm copy-pasting :p
21:09:59 <benzrf> same
21:10:09 <Welkin> Ωç√
21:10:11 <Welkin> okay
21:10:12 <merijn> > √ 5 -- parse error, I expect
21:10:13 <lambdabot>  <hint>:1:1: parse error on input ‘√’
21:10:17 <Welkin> it is Alt + v
21:10:19 <merijn> > (√) 5
21:10:21 <lambdabot>  2.23606797749979
21:10:23 <Welkin> on macs, anyway
21:10:41 <merijn> Welkin: You must have a different mac than I do :p
21:10:45 <merijn> For me alt +v is
21:10:48 <merijn> ˇ
21:10:52 <Welkin> haha
21:11:28 <n4x> autoreplacement on my client
21:11:39 <n4x> with latex-like commands :P
21:11:52 <Hijiri> what client?
21:12:04 <merijn> Is Map an instance of Monoid? (assuming the values are monoids)
21:12:05 <Hijiri> I forgot ctcp existed
21:12:34 <merijn> Whoo, it is :D
21:12:42 <johnw> merijn: it is
21:12:44 <merijn> > Just 1 <> Just 2
21:12:46 <lambdabot>  No instance for (GHC.Show.Show a0)
21:12:46 <lambdabot>    arising from a use of ‘M878937186851083458421128.show_M8789371868510834584...
21:12:46 <lambdabot>  The type variable ‘a0’ is ambiguous
21:12:46 <lambdabot>  Note: there are several potential instances:
21:12:46 <lambdabot>    instance [safe] GHC.Show.Show
21:12:52 <johnw> it's a left-biased union
21:12:52 <merijn> eh...
21:13:12 <merijn> johnw: ugh
21:13:15 <n4x> Hijiri: :)
21:13:20 <johnw> yeah, kind of useless in my opinion
21:13:21 <merijn> johnw: That's not the monoid I wanted :(
21:13:32 <johnw> someday I'll find that one person who did want that monoid
21:15:35 <carter> johnw: ed claims theres code in the wild will break if that ever got fixed
21:15:54 <vanila> Zer000, thats ok :)
21:16:12 <johnw> carter: yeah, that one guy
21:16:35 <carter> johnw: a hackage audit would probably be the ONLY way to sell that change
21:17:01 <johnw> i hereby commission you
21:18:59 <carter> nope
21:19:04 <carter> then it wont happen for 2 years
21:19:08 <carter> i've enough backlog
21:19:14 <merijn> Not it :>
21:21:41 <merijn> johnw: If you lobby for it, I'll write the patch :p
21:22:09 <johnw> how would I find out which packages would break though?
21:22:16 <johnw> if every package had full tests, I could do it
21:27:04 <carter> johnw: just read all the modules that import monoid and Data.Map
21:27:07 <carter> thats all
21:27:24 <carter> and are public
21:27:25 <carter> and on hackage
21:33:00 <nshepperd> right-biased union would at least make Map.fromList a monoid homomorphism
21:33:24 <merijn> nshepperd: I wanted "instance (Monoid v, Ord k) => Monoid (Map k v)"
21:33:44 <nshepperd> is there any way to mechanically find modules that use the monoid instance of Data.Map?
21:34:04 <nshepperd> actually, you could remove the instance, and try to recompile all of hackage
21:34:18 <nshepperd> that might take some time
21:34:56 <nshepperd> well, all of hackage that imports Monoid and Data.Map*
21:35:34 <Welkin> when is ghc 7.10 set to release?
21:35:49 <Welkin> I heard that it will implement the applicative-monad proposal
21:36:06 <merijn> Welkin: Code freeze for 7.10 is this friday
21:36:14 <merijn> So probably early next year
21:36:24 <Welkin> so will we see a lot of breakage?
21:36:38 <merijn> Probably not
21:36:51 <merijn> 7.8 had a warning for packages that are not AMP ready
21:36:53 <merijn> Well
21:37:07 <merijn> actively maintained packages probably won't break
21:37:16 <merijn> Orphaned packages? Who knows...
21:37:24 <Welkin> I noticed those warnings when compiling yesod recently
21:38:25 <nshepperd> I guess Map.union would be a good candidate for "instance Ord k => Alternative (Map k)"
21:38:48 <nshepperd> so given that, there's even less use for a union-based Monoid instance
21:41:38 <nshepperd> actually scratch that, there's no sane Applicative for Maps, so Alternative is impossible
21:53:42 <merijn> There's no sane applicative for maps? I'm pretty sure that's not true
21:54:02 <codygman> cdk: Thanks for the alternative. I'm going to look that over tomorrow, but that solution feels very unreadable/unmaintainable. I'll try splitting it into two functions tomorrow and seeing though.
21:54:18 <merijn> Although I'd need to check the laws...
21:59:52 <osa1> does anyone here use hslogger? I'm removing default handler and adding a fileHandler to global logger but it still prints to stdout too. any ideas how to stop it printing to the stdout?
22:02:12 <merijn> Hmmm, filepath doesn't have any tools for listing files in a directory? Do I need base for that?
22:07:59 <alpounet> merijn: getDirectoryContents or smth like that does that, from 'directory', iirc
22:08:08 <merijn> alpounet: Yeah, just found it :)
22:08:33 <nshepperd> merijn: well, you can't do a zippy applicative, since there's no infinite Map you can use for 'pure'. and you can't do a cartesian applicative, since you can't make new keys
22:08:52 <merijn> Why is there no infinite map for pure?
22:09:18 <nshepperd> you'd have to build a Map mapping every key to the value
22:09:37 <merijn> Sure, but that seems a mere implementation detail
22:09:54 <merijn> You could just define a special "pure" data constructor internally for that
22:10:05 <nshepperd> yes, you could do that
22:10:10 <merijn> Shouldn't be hard to implement
22:10:19 <nshepperd> I was thinking of the plain Map data type
22:10:53 <nshepperd> but yes, you could redefine Map to be data Map a = Pure a | NormalMap {...}
22:11:03 <nshepperd> er, Map k a, whatever
22:11:47 <merijn> Seems like it'd be useful and not cost much
22:13:05 <L8D> is there a paper somewhere that goes in-depth on the differences between Haskell and Erlang threads?
22:13:41 <nshepperd> well, it would actually have to be "data Map k a = Map (Maybe a) (NormalMap k a)"
22:13:45 <merijn> L8D: I think it's mostly is that Erlang has per thread heaps and communication is therefore copy instead of reference based
22:13:53 <nshepperd> basically a map with default
22:13:58 <nshepperd> optional default
22:14:03 <merijn> nshepperd: Why?
22:14:23 <WigglesMcMuffin> What do the a0 and a1 types mean in the function signatures?
22:14:32 <L8D> merijn: so then Haskell threads would be more lightweight than Erlang's?
22:14:32 <merijn> WigglesMcMuffin: Just random variables
22:14:32 <nshepperd> because "Map.insert k v (Pure x) = ???"
22:14:34 <jfischoff> is it possible to export only pattern synonyms, and not the constructors that make them?
22:14:48 <merijn> L8D: haskell threads are more lightweight than Erlang's afaik
22:14:49 <L8D> merijn: and are there any solutions for managing threads across systems in Haskell?
22:14:59 <L8D> like in Erlang
22:15:04 <merijn> L8D: There's Cloud Haskell, but it's work in progress
22:15:12 <merijn> Haskell's thread management is pretty bear bones
22:15:16 <merijn> nshepperd: Ah, true
22:15:28 <L8D> oh yeah
22:15:31 <merijn> jfischoff: afaik, yes
22:15:35 <L8D> I keep hearing about Cloud Haskell over and over...
22:15:47 <jfischoff> merijn: awesome
22:15:58 <merijn> Still no TH support for patterns though, sadly :\
22:16:07 <merijn> eh, pattern synonyms
22:16:07 <jfischoff> that’s okay
22:16:33 <merijn> Yeah, but I was working on a quasiquoter to automatically hide constructors and generate synonyms :p
22:16:45 <jfischoff> nice
22:16:52 <WigglesMcMuffin> merijn: Random? if I had (Num a) => [a] -> [(a0, a1)] what would that mean compared to (Num a) => [a] -> [(a,a)] ?
22:17:20 <merijn> jfischoff: The idea was to newtype CInt and use synonyms for a nice but cheap way to wrap FFI error codes :)
22:17:20 <jfischoff> some things you can safely destruct but not construct.
22:17:32 <merijn> WigglesMcMuffin: a0 and a1 are different from 'a'
22:17:48 <nshepperd> actually, there's also "Map.delete k (Map (Just x) nm) = ???"
22:17:57 <jfischoff> merijn: Right you can reuse the same capitialized error codes
22:18:02 <nshepperd> you could make deletion reset to the default
22:18:12 <merijn> WigglesMcMuffin: "Num a => [a] -> [(a0, a1)]" is identical to "Num a => [a] -> [(b, c)]"
22:18:17 <WigglesMcMuffin> merijn: Oh, so would substituting say 'a0' with 'b' be equivalent
22:18:27 <merijn> WigglesMcMuffin: Right
22:18:32 <nshepperd> or maybe "data Map k a = Map (Maybe a) (NormalMap k (Maybe a))"
22:18:44 <nshepperd> and have Nothing represent an explicitly deleted value
22:18:53 <merijn> WigglesMcMuffin: GHC tries to keep type variables related to the original variable names
22:19:07 <merijn> WigglesMcMuffin: To provide a clue where they might come from
22:19:34 <merijn> I'm not sure entirely which voodoo it uses to generate fresh names :)
22:21:36 <WigglesMcMuffin> merijn: I see, I was thinking that they might mean a0 and a1 were distinct Nums (or more generically they inherit a's type). Is there a way to specify that, for example?
22:22:30 <merijn> WigglesMcMuffin: To specify what? That they're the same as 'a' or that they're Num instances too
22:23:50 <WigglesMcMuffin> merijn: When you put it that way, I'm really starting to see the pointlessness of that question, haha
22:24:23 <merijn> Well, the latter is still sensible
22:24:57 <merijn> "(Num a, Num b, Num c) => [a] -> [(b,c)]" <- here 'b' and 'c' are both instances of Num, but they're (potentially) different from 'a'
22:24:59 <WigglesMcMuffin> merijn: wouldn't you just use a again in that case though, if they were also Num?
22:25:40 <merijn> Well "[Int] -> [(Double, Word)]" is not a valid type for "Num a => [a] -> [(a,a)]" (all a's must be the same)
22:25:57 <merijn> But it is valid for the other example with (Num a, Num b, Num c)
22:26:35 <WigglesMcMuffin> merijn: I see, so even though Int and Double are Num, they both can't be a?
22:26:57 <merijn> WigglesMcMuffin: Multiple 'a' in a signatures literally means they're the exact same type
22:27:25 <merijn> WigglesMcMuffin: You can read "foo :: Num a => a -> a" as "IF 'a' is an instance of 'Num' THEN 'foo :: a -> a' ELSE type error"
22:27:44 <dmj`> that's like saying: f :: Show a => [a]; f = ["a", 3] ... String and Int are instances of Show, but not the same type
22:29:00 <WigglesMcMuffin> merijn: I'm not sure I follow that second point
22:29:23 <benzrf> @hoogle Monoid m => Int -> m -> m
22:29:25 <lambdabot> Text.Regex.Base.RegexLike after :: Extract source => Int -> source -> source
22:29:25 <lambdabot> Text.Regex.Base.RegexLike before :: Extract source => Int -> source -> source
22:29:25 <lambdabot> Prelude scaleFloat :: RealFloat a => Int -> a -> a
22:29:29 <benzrf> ahrg
22:29:41 <merijn> WigglesMcMuffin: Which second point?
22:30:09 <WigglesMcMuffin> merijn: You can read ... ELSE type error"
22:30:19 <merijn> Example
22:30:35 <merijn> > 'a' + 'b' -- <- type error, Char is not an instance of Num
22:30:36 <lambdabot>  No instance for (GHC.Num.Num GHC.Types.Char)
22:30:36 <lambdabot>    arising from a use of ‘GHC.Num.+’
22:30:41 <merijn> :t (+)
22:30:42 <lambdabot> Num a => a -> a -> a
22:31:07 <merijn> :t (+) `asAppliedTo` (1 :: Int)
22:31:08 <lambdabot> Int -> Int -> Int
22:31:12 <merijn> :t (+) `asAppliedTo` 'c'
22:31:13 <lambdabot>     No instance for (Num Char) arising from a use of ‘+’
22:31:13 <lambdabot>     In the first argument of ‘asAppliedTo’, namely ‘(+)’
22:31:13 <lambdabot>     In the expression: (+) `asAppliedTo` 'c'
22:31:42 <merijn> WigglesMcMuffin: See how the variables are replaced with the actual type when you apply the function?
22:32:07 <merijn> WigglesMcMuffin: The part before the '=>' says that that substitution is only correct if the variables match the constraints left of '=>'
22:32:33 <WigglesMcMuffin> merijn: I understand how the => section works :)
22:33:39 <WigglesMcMuffin> merijn: so first of all, lambdabot is awesome, and second of all, this all makes a lot more sense now. Thank you
22:33:46 <merijn> np :)
22:33:55 * hackagebot parsergen 0.2.0.7 - TH parser generator for splitting bytestring into fixed-width fields  http://hackage.haskell.org/package/parsergen-0.2.0.7 (AkioTakano)
22:33:57 * hackagebot persistent-mysql 2.1.2 - Backend for the persistent library using MySQL database server.  http://hackage.haskell.org/package/persistent-mysql-2.1.2 (MichaelSnoyman)
22:38:55 * hackagebot persistent-sqlite 2.1.1 - Backend for the persistent library using sqlite3.  http://hackage.haskell.org/package/persistent-sqlite-2.1.1 (MichaelSnoyman)
22:44:23 <benzrf> :t scanl
22:44:24 <lambdabot> (b -> a -> b) -> b -> [a] -> [b]
22:45:01 <benzrf> :t iterateM
22:45:02 <lambdabot>     Not in scope: ‘iterateM’
22:45:02 <lambdabot>     Perhaps you meant one of these:
22:45:02 <lambdabot>       ‘iterate’ (imported from Data.List),
22:45:06 <benzrf> hmm
22:52:11 <merijn> benzrf: How would you lazily abort an infinite monadic operation?
22:52:24 <johnw> pipes!
22:52:31 <merijn> johnw: Word
22:52:42 <merijn> ugh, filesystems suck
22:52:50 <johnw> ... electricity
22:53:56 * hackagebot http-client 0.4.4 - An HTTP client engine, intended as a base layer for more user-friendly packages.  http://hackage.haskell.org/package/http-client-0.4.4 (MichaelSnoyman)
22:54:21 <benzrf> merijn: u-um
22:54:28 <benzrf> wait
22:54:29 <benzrf> :t iterate
22:54:30 <lambdabot> (a -> a) -> a -> [a]
22:54:35 <benzrf> merijn: ^
22:54:46 <merijn> Yes?
22:55:00 <benzrf> it werk
22:55:06 <merijn> Sure, because that's pure
22:55:11 <johnw> benzrf: see the several implementations of iterateM in http://hackage.haskell.org/package/monad-extras-0.5.9/docs/Control-Monad-Extra.html
22:55:12 <merijn> Infinite pure lists are fine
22:55:22 <johnw> and note the comments "it will never terminate"
22:55:39 <johnw> i do have a version using lazy I/O though
22:55:40 <benzrf> you'r mother will never terminate
22:55:42 <johnw> but pipes is more principled
22:55:50 <johnw> benzrf, my mother already has :(
22:56:01 <benzrf> D:
22:56:10 <benzrf> s-sorry
23:02:58 <L8D> benzrf: holy fuck man
23:05:36 <benzrf> sleeping now
23:05:41 <benzrf> bye
23:06:20 <L8D> like... jesus christ
23:09:12 <merijn> Is there a function that does filter+map in one go?
23:09:24 <L8D> merijn: bind?
23:09:30 <L8D> merijn: aka. concatMap?
23:09:39 <merijn> How is that the same as filter+map?
23:09:48 <L8D> because you can do filtering and mapping
23:10:24 <merijn> That's hardly a simple way of writing it
23:10:30 <L8D> > [1, 2, 3, 4] >>= \x -> if even x then [x / 2] else []
23:10:32 <lambdabot>  No instance for (GHC.Show.Show b0)
23:10:32 <lambdabot>    arising from a use of ‘M82301087090100143322920.show_M82301087090100143322...
23:10:32 <lambdabot>  The type variable ‘b0’ is ambiguous
23:10:32 <lambdabot>  Note: there are several potential instances:
23:10:32 <lambdabot>    instance [safe] GHC.Show.Show
23:10:55 <L8D> > ([1, 2, 3, 4] :: Int) >>= \x -> if even x then [x / 2] else []
23:10:56 <lambdabot>  Couldn't match expected type ‘GHC.Types.Int’
23:10:57 <lambdabot>              with actual type ‘[t0]’Couldn't match expected type ‘[b]’ with a...
23:10:59 <merijn> Wrong
23:11:06 <L8D> wtf am I doing
23:11:06 <merijn> You have to return [[x/2]]
23:11:26 <L8D> > [1, 2, 3, 4] >>= \x -> if even x then [[x / 2]] else []
23:11:28 <merijn> Anyway, that hardly improves things
23:11:28 <lambdabot>  No instance for (GHC.Show.Show t0)
23:11:28 <lambdabot>    arising from a use of ‘M203127818320952651622963.show_M2031278183209526516...
23:11:28 <lambdabot>  The type variable ‘t0’ is ambiguous
23:11:28 <lambdabot>  Note: there are several potential instances:
23:11:28 <lambdabot>    instance [safe] GHC.Show.Show
23:11:33 <L8D> what?
23:12:01 <supki_> merijn: mapMaybe
23:12:17 <merijn> supki_: \o/
23:12:35 <L8D> but bind is more powerful!
23:12:58 <L8D> join [1, 2, 3]
23:12:59 <L8D> > join [1, 2, 3]
23:13:01 <lambdabot>  No instance for (GHC.Show.Show a0)
23:13:01 <lambdabot>    arising from a use of ‘M247021871218019595722988.show_M2470218712180195957...
23:13:01 <lambdabot>  The type variable ‘a0’ is ambiguous
23:13:01 <lambdabot>  Note: there are several potential instances:
23:13:01 <lambdabot>    instance [safe] GHC.Show.Show
23:13:09 <L8D> > join [[1], [2], [3]]
23:13:11 <lambdabot>  [1,2,3]
23:13:14 <L8D> -.-
23:13:19 <wei2912> > [1, 2, 3, 4] >>= \x -> if even x then [[x / 2]] else []
23:13:20 <lambdabot>  No instance for (GHC.Show.Show t0)
23:13:20 <lambdabot>    arising from a use of ‘M790794784695713455723025.show_M7907947846957134557...
23:13:20 <lambdabot>  The type variable ‘t0’ is ambiguous
23:13:20 <lambdabot>  Note: there are several potential instances:
23:13:20 <lambdabot>    instance [safe] GHC.Show.Show
23:13:22 <wei2912> > [1, 2, 3, 4] >>= \x -> if even x then [x / 2] else []
23:13:24 <lambdabot>  No instance for (GHC.Show.Show b0)
23:13:24 <lambdabot>    arising from a use of ‘M729485420095667236823037.show_M7294854200956672368...
23:13:26 <lambdabot>  The type variable ‘b0’ is ambiguous
23:13:28 <lambdabot>  Note: there are several potential instances:
23:13:30 <lambdabot>    instance [safe] GHC.Show.Show
23:13:45 <L8D> > [1, 2, 3, 4] >>= (\x -> if even x then [x / 2] else [])
23:13:47 <danilo2_> Hello! What is the status with dynamic plugins loading to haskell (via shared libbraries?) I donwloaded the sources of plugins libraries, run everythink like in stated in README and I see on the screen that all of the test just failed.
23:13:47 <lambdabot>  No instance for (GHC.Show.Show b0)
23:13:47 <lambdabot>    arising from a use of ‘M455485500059932389623049.show_M4554855000599323896...
23:13:47 <lambdabot>  The type variable ‘b0’ is ambiguous
23:13:47 <lambdabot>  Note: there are several potential instances:
23:13:47 <lambdabot>    instance [safe] GHC.Show.Show
23:13:52 <L8D> omg lambdabot
23:13:54 <wei2912> lol
23:14:04 <merijn> [x/2] is wrong
23:14:16 <L8D> > [1, 2, 3, 4] >>= (\x -> if even x then [x `div` 2] else [])
23:14:17 <lambdabot>  [1,2]
23:14:20 <L8D> aha!
23:14:22 <merijn> hmm, wait
23:14:24 <wei2912> ahhh
23:14:26 <merijn> I guess not
23:14:28 <wei2912> right
23:14:46 <merijn> :t even
23:14:47 <lambdabot> Integral a => a -> Bool
23:15:18 <L8D> danilo2_: did they just "fail" or was there anything specific on that?
23:15:22 <dmwit> danilo2_: I don't think anybody's touched the "plugins" package in years. These days you use the GHC API (e.g. hint, mueval, etc.) instead.
23:15:37 <danilo2_> L8D: Everythinh looks like this: === testing testsuite/pdynload/univquant                       ... ../../build.mk:23: recipe for target 'prog/Main' failed
23:16:10 <danilo2_> dmwit: oh! good to know! So what is the best way to implement plugins in haskell these days?
23:16:21 <L8D> that one implementation of lua in Haskell
23:16:31 <L8D> Lua is *the* plugin language
23:16:36 <dmwit> ... "These days you use the GHC API (e.g. hint, mueval, etc.) instead."
23:16:59 <danilo2_> dmwit: ehh - ok , sorry for not being clear - which one should I grab - which one would work the besrt?
23:18:02 <dmwit> well
23:18:21 <dmwit> I'm not sure, to be honest. I haven't actually done much in that domain, so I don't know what the decision points are between them.
23:18:23 <danilo2_> i see mueval is posix only, so it will not work for me. I want to just load some shared libraries and use them just like they woudl be written normally in code - I wanrt them to call instances declared in the code and provide new instances for the code being host
23:18:51 <dmwit> I personally would start with just using the GHC API all by itself and see where that got me.
23:18:56 * hackagebot iCalendar 0.4.0.2 - iCalendar data types, parser, and printer.  http://hackage.haskell.org/package/iCalendar-0.4.0.2 (ChristianRoedliAmble)
23:19:03 <danilo2_> Hmm, but GHC API would not work more "runtime"? I would love these pklugins to provide instances for type classes - it is possible ?
23:19:24 <wei2912> 15:00 < wei2912> http://zach.se/project-euler-solutions/65/ - how does the solution at rationalize work?
23:19:27 <wei2912> 15:00 < wei2912> and why is it faster than using the Rational type?
23:19:27 <dmwit> I don't know.
23:19:44 <wei2912> am i right in guessing that the above method is faster because the fraction doesn't need to be simplified?
23:19:45 <danilo2_> ok, thank you
23:19:47 <dmwit> It would surprise me a bit if they could provide instances for a type class.
23:19:57 <dmwit> For that, you might look into dyre.
23:20:11 <dmwit> Which isn't "plugins" so much as "compile a replacement program and exec it".
23:20:15 <danilo2_> dmwit: me too. So Im just sceptic to this idea. Is there really any "good" haskell plugin system out there?
23:20:22 <dmwit> um
23:20:33 <dmwit> I think it's possible that "implement a type class" is an XY problem.
23:21:01 <danilo2_> dmwit: No I would call them plugins - These instances would be used to "register" plugins in a wise way - providing informations what types are available
23:21:34 <dmwit> I didn't understand this.
23:21:42 <danilo2_> dmwit: you could be right. I just want to load plugins which provide passes to complier. I want them to register functions, that compiler could call - jsut like passes in LLVM
23:22:29 <dmwit> I wouldn't expect that to require much type class machinery.
23:22:50 <dmwit> Just have an explicit record instead.
23:23:37 <danilo2_> dmwit: I wanted to create such instances of type classes, that woudl automatically connect "data" generated by passes to functions without using dynamics.. I can use dynamic there, but not using it is so much better
23:24:07 * dmwit shrugs
23:24:10 <danilo2_> dmwit: Oh, explicit record will not work - users can define custom data, custom passes and everything - fully open world here
23:24:31 <dmwit> We're deep in unknown territory for me. Even if I could follow the technical points you're making, I doubt I could be very helpful.
23:24:49 <danilo2_> dmwit: I see. Thank you very much! :)
23:29:47 <merijn> danilo2_: "fully open world" sounds like a pretty bad idea, tbh
23:30:26 <danilo2_> merijn: you could be right. I just wanted to design passes in such way, that the data generated by the passes and feed to functions would base on types and not on dynamic dependencies
23:30:39 <danilo2_> merijn: because of that I wanted to generate type class instances in plugins
23:35:35 <merijn> @hoogle Ord a => (b -> a) -> b -> b -> b
23:35:37 <lambdabot> Data.Ord comparing :: Ord a => (b -> a) -> b -> b -> Ordering
23:35:37 <lambdabot> Data.Function on :: (b -> b -> c) -> (a -> b) -> a -> a -> c
23:35:37 <lambdabot> Prelude maybe :: b -> (a -> b) -> Maybe a -> b
23:35:53 <merijn> > Nothing < Just 1
23:35:55 <lambdabot>  True
23:35:57 <merijn> bah
23:36:31 <merijn> Any suggestion on how to get the minimal non-Nothing value?
23:37:31 <merijn> Or for those who like to codegolf, given two values and a list I want to return the value with the lowest index in the list (if found) or the first if neither are in the list
23:39:04 <johnw> head . sort . catMaybes?
23:39:24 <johnw> well, not quite head, but some safe_head
23:40:37 <Arahael> maybeHead.
23:40:49 <johnw> or a head that takes a default
23:41:10 <Hijiri> listToMaybe?
23:42:41 <merijn> johnw: No
23:42:57 <merijn> johnw: I have two values, which may or may not appear in a list
23:43:13 <johnw> what's the type of the functino you want?
23:43:14 <merijn> I want to return the value which appears first in the list
23:43:31 <merijn> "Eq a => [a] -> a -> a -> a"
23:43:38 <johnw> ahh
23:43:40 <Arahael> The *index of the value*.
23:43:45 <merijn> Right
23:43:56 <Arahael> merijn: So that type sig is wrong.
23:44:12 <merijn> Arahael: eh, why?
23:44:23 <Arahael> merijn: Are list indices the same type as the list values?
23:44:25 <merijn> I don't want to return the index
23:44:35 <merijn> I want to return the value with the lowest index
23:44:46 <johnw> foo xs x y = case filter (\i -> i == x || i == y) xs of [] -> ?; (i:_) -> i
23:44:48 <Arahael> merijn: Ah, right.
23:45:08 <johnw> find (\i -> i == x || i == y) xs
23:45:48 <merijn> johnw: oh! I was looking at findIndex and missed fine
23:45:51 <johnw> or ((== i) `on` (||)) or some such
23:45:52 <merijn> Excellent
23:47:48 <johnw> oh, forget that last comment
23:49:39 <Arahael> That '?' is just a placeholder, right, or is it valid haskell in that context?
23:49:48 <johnw> it meant "whatever goes here"
23:50:00 <Arahael> Right, so placeholder.
23:50:03 * Arahael is a newbie.
23:51:12 <johnw> yeah, that was just for merijn
23:51:27 <johnw> welcome to Haskell, Arahael!
23:52:57 <Arahael> johnw: I love it, especially with hlint.  As for that filter there, ignoring 'find', wouldn't takewhile be better?
23:53:16 <Arahael> Or does laziness effectively mean that it's equivalent?
23:53:26 <johnw> the latter
23:53:27 <merijn> takeWhile does something entirely different than filter
23:53:37 <merijn> Or am I crazy?
23:53:38 <johnw> yeah takeWhile selects another list
23:53:44 <johnw> find picks out an element matching a predicate
23:53:47 <johnw> sorry, late here
23:53:47 <Arahael> D'oh, it's been a long day.
23:54:17 <johnw> if takeWhile were to return a non-empty list, it's first element would be what find would return :)
23:54:39 <merijn> takeWhile requires inversing the predicate
23:58:56 * hackagebot colchis 0.2.0.3 - Rudimentary JSON-RPC 2.0 client over raw TCP.  http://hackage.haskell.org/package/colchis-0.2.0.3 (DanielDiazCarrete)
