00:01:07 <mrsElectron> it's not that, I just don't understand what sense a -> ... -> a makes (I know that a is a type variable)
00:01:35 <MP2E> well, it shows the 'shape' of the function. In this case, it takes 3 things of any type, as long as those 3 things are the same type
00:01:44 * hackagebot neil 0.8 - General tools for Neil  http://hackage.haskell.org/package/neil-0.8 (NeilMitchell)
00:01:44 <MP2E> and it gives back one type of a
00:01:58 <MP2E> one thing of type a*
00:02:23 <MP2E> that function isn't technically legal though, because you can't add any type!
00:02:46 <indiagreen> mrsElectron: you might want to read the beginning of this chapter, because it answers exactly your question: http://learnyouahaskell.com/higher-order-functions
00:03:07 <mrsElectron> thanks
00:03:55 <hunt> there arent very many haskell employees out there eh
00:04:27 <mrsElectron> hunt: I know one, and he doesn't even have an education .. compared to all the other programmers that I know.
00:04:54 <mrsElectron> the market isn't so big, it's quite niched I guess.
00:05:29 <hunt> mrsElectron: this is personal i guess, but is he decently paid?
00:05:37 <mrsElectron> I really don't know, I'm just guessing :3
00:05:53 <mrsElectron> hunt: idk, he works in a small company though
00:06:01 <hunt> mrsElectron: what specifically do you mean by he doesnt have an education
00:06:08 <hunt> mrsElectron: like how much education are we talking about
00:07:40 <hunt> i hope ethats not too personal
00:07:46 <hunt> i jsut find this all very interesting
00:07:59 <hunt> also i think its important to help decide for myself what to do
00:08:10 <mrsElectron> hunt: he lacks any education what so ever
00:08:19 <hunt> mrsElectron: highschool? elementary schoool?
00:08:41 <hunt> mrsElectron: all included?
00:08:42 <mrsElectron> He finished elementary school, and that's it
00:10:00 <mrsElectron> I'm not a good source for info about the haskell market though. I'd suggest you google around
00:10:31 <hunt> mrsElectron: thats pretty intense, i guess i will
00:12:36 <tolt> hunt: I'm an intern at a company that only writes in haskell
00:12:54 <johnw> tolt: which company?
00:12:56 <tolt> hunt: We have ~5 developers
00:13:20 <tolt> hunt: It's an automation company in Oklahoma City
00:13:36 <hunt> tolt: sounds sexy, as someone in the midwest, i will seek employment ;)
00:13:42 <hunt> tolt: is it stable?
00:13:59 <hunt> tolt: like is the company safe in its market?
00:14:23 <tolt> Yeah. I believe so. I don't know much about the oil field (main market) though
00:16:27 <mrsElectron> how do you comment in haskell? My source is wrong
00:16:39 <mrsElectron> (my source about how to comment is wrong)
00:17:03 <sivteck> -- comments are preceded by --
00:17:14 <sivteck> > 6 * 6 -- bleh
00:17:15 <lambdabot>  36
00:17:34 <mrsElectron> oh, I just forgot t osave
00:17:53 <_1_lawaljos> hi room any body here good day
00:18:38 <_1_lawaljos> hello
00:19:04 <_1_lawaljos> any body here?
00:19:10 <johnw> hi.  in general we respond to questions about Haskell :)
00:19:11 <mrsElectron> lol
00:20:06 <_1_lawaljos> am new in here can some one talk to me please
00:20:14 <johnw> ask a question
00:20:30 <johnw> this isn't a social channel, but we are happy to help all comers
00:20:59 <_1_lawaljos> what is it all about
00:21:07 <johnw> it is a functional programming language
00:21:35 <_1_lawaljos> how am new I don't understand
00:21:45 <johnw> this may not be the channel for you, _1_lawaljos
00:22:21 <_1_lawaljos> okay so tell me about this channel
00:23:02 <mrsElectron> _1_lawaljos: you ask question about haskell in this channel
00:23:28 <sivteck> _1_lawaljos, we discuss about haskell, the programming language used to make computers do menial stuff. check out http://haskell-lang.org/ ?
00:25:42 <mrsElectron> does this make sense?  encrypt [] = [] ?
00:26:09 <wei2912> mrsElectron: probably?
00:26:12 <johnw> it's a valid, partial function
00:26:17 <wei2912> no idea what encrypt is supposed to do
00:26:40 <wei2912> do you need to obscure the lack of information?
00:26:43 <wei2912> :P
00:27:01 <mrsElectron> it just "iterates" trough a string. But I need an edge condition
00:27:04 <indiagreen> well, it's certainly desirable... sometimes...
00:27:08 * indiagreen remembers exams
00:27:28 <mrsElectron> it adds one to each char
00:27:37 <wei2912> mrsElectron: more like a cipher, i guess
00:27:55 <wei2912> that's a good start if you're using recursion
00:28:05 <wei2912> (there're better ways though :))
00:28:23 <mrsElectron> like encrypt a = a ?
00:28:33 <wei2912> no, that wouldn't work
00:28:39 <wei2912> since you need to manipulate the string
00:28:46 <mrsElectron> ah, ofc
00:28:49 <mrsElectron> lol
00:29:12 <wei2912> once you get your first piece of code out, do paste it here using lpaste.net (refer to topic)
00:29:23 <mrsElectron> any idea what the x and xs in (x:xs) stands for in many examples? (I know that they're the head and the tail)
00:29:33 <johnw> xs is the plural of x
00:29:53 <wei2912> lazy haskellers
00:30:11 <mrsElectron> lal
00:30:32 <wei2912> the hardworking people doing enterprise-java would have named it listOfIntegers
00:30:37 <wei2912> or something like that
00:30:42 * wei2912 ducks
00:31:05 <S11001001> tailOfListOfIntegers
00:31:09 <MP2E> haha
00:31:54 <indiagreen> and then we'd tell them to be a bit more polymorphic and they'd rename it to tailOfListOfArbitraryThings (sure, “a” stands for “arbitrary”, right?)
00:33:04 <narendraj9> indiagreen: a is pronounced alpha, sometimes. So I guess not.
00:34:06 * indiagreen wonders how to confess that it was some attempt at sarcasm
00:34:39 * narendraj9 has always been bad at gettting sarcasm.
00:36:19 <sohum> in current ghc, 7.8, is map . filter fused?
00:36:29 <sohum> on the Prelude array type, I mean
00:38:07 <indiagreen> sohum: there's no array type in Prelude. If you meant “list”, then yep, it is fused
00:38:16 <sohum> um, derp, yes, thank you
00:38:40 <sohum> is that documented anywhere? :p
00:38:58 <indiagreen> probably, but I just used ghc-core to find out
00:39:14 <indiagreen> I think there are lists of good producers and consumers somewhere
00:39:24 <indiagreen> good producers fuse with good consumers
00:39:56 <indiagreen> https://www.haskell.org/ghc/docs/7.8.3/html/users_guide/rewrite-rules.html
00:40:02 <sohum> aha
00:40:04 <sohum> thank you!
00:44:42 <Guest57420> @pl ofSize f = f . length . text
00:44:42 <lambdabot> ofSize = (. (length . text))
00:45:32 <mrsElectron> most efficient way to concatenate "Player: " name "." ?
00:45:44 <mrsElectron> I'm thinking ++
00:46:20 <sohum> indiagreen: why are only the enumerations on Int, Integer, and Char good producers?
00:46:25 <johnw> efficiency requires knowing a lot more context than that
00:46:30 <johnw> but for that one use, sure
00:46:50 <solatis> mrsElectron: T.concat ["Player: ", name, "."] ?
00:47:31 <merijn> solatis: That's not going to matter much, tbh
00:47:50 <solatis> in terms of performance, probably not
00:48:43 <mrsElectron> lol
00:49:23 <Guest57420>  @pl combine f filter1 filter2 = \email -> f (filter1 email) (filter2 email)
00:49:35 <solatis> mrsElectron: basicly that's going to be your best bet -- I would be more concerned about the underlying data type (Text versus String) rather than the way the concatenate them
00:49:59 <Guest57420>  @pl combine f filter1 filter2 = \email -> f (filter1 email) (filter2 email)
00:50:08 <Hijiri> there's a space before your messages
00:50:17 <Guest57420> @pl combine f filter1 filter2 = \email -> f (filter1 email) (filter2 email)
00:50:18 <lambdabot> combine = liftM2
00:50:24 <Guest57420> thanks
00:52:52 <indiagreen> sohum: my guess is that it's hard to write a generic enumeration function which would both fuse and work correctly in presence of overflows/etc. See the implementation for Ints: http://hackage.haskell.org/package/base-4.7.0.1/docs/src/GHC-Enum.html#efdtIntUp
00:53:35 <indiagreen> I don't actually know *why* it's hard, but I guess if it was easy it would've been done, and judging by the source of GHC.Enum it's not done
00:55:39 <sohum> indiagreen: and I suppose the default implementation of Enum for user-defined types uses fromEnum and toEnum to convert it to an enum on Ints anyway, so it's only really relevant if you're doing something weird beyond that
00:55:44 <solatis> indiagreen: damn that code looks.. incomprehensible
00:56:44 * hackagebot apiary 1.1.3 - Simple and type safe web framework that can be automatically generate API documentation.  http://hackage.haskell.org/package/apiary-1.1.3 (HirotomoMoriwaki)
00:56:46 * hackagebot apiary-logger 1.1.1 - fast-logger support for apiary web framework.  http://hackage.haskell.org/package/apiary-logger-1.1.1 (HirotomoMoriwaki)
00:56:48 * hackagebot apiary-persistent 1.1.1 - persistent support for apiary web framework.  http://hackage.haskell.org/package/apiary-persistent-1.1.1 (HirotomoMoriwaki)
00:56:50 * hackagebot apiary-mongoDB 1.1.1 - mongoDB support for apiary web framework.  http://hackage.haskell.org/package/apiary-mongoDB-1.1.1 (HirotomoMoriwaki)
01:04:31 <Guest57420> I have a type SomeT a = a -> Bool
01:05:20 <Guest57420> I am trying to define functor instance for it
01:05:58 <merijn> Guest57420: Good luck :p
01:06:10 <merijn> Guest57420: And by that I mean "it's not possible" :>
01:06:30 <merijn> Guest57420: You may want to define a contravariant functor instance
01:07:03 <merijn> "contramap :: Contravariant f => (a -> b) -> f b -> f a"
01:07:20 <merijn> See also
01:07:25 <merijn> @hackage contravariant
01:07:25 <lambdabot> http://hackage.haskell.org/package/contravariant
01:08:27 <Guest57420> merijn: thanks :-)
01:20:34 <mrsElectron> how do you have a simple string macro or something in haskell. like you have in imperative languages? Like a global string or macro or something
01:21:03 <johnw> can you clarify?
01:21:18 <johnw> not everything from an imperative language needs an analog in Haskell
01:22:25 <mrsElectron> If you're printing a hard coded name of a game character on multiple places, you'd typically use a global variable for that
01:23:01 <johnw> you can just define 'name = "foo"'
01:23:05 <johnw> and then use "name" everywhere
01:23:20 <mauke> yeah, that's a global variable
01:23:29 <mauke> why a macro??
01:23:45 <johnw> i'm guessing he's thinking that global definitions = memory storage
01:23:58 <johnw> and that macros embed directly into the text segment
01:24:00 <Fuuzetsu> johnw: have you got a nix expr for GHC HEAD?
01:24:01 <favetelinguis> are the assignments in a where clause evaluated before any other expression?
01:24:02 <johnw> anyway, that's what it made me think
01:24:04 <Fuuzetsu> that's up to date &c
01:24:07 <mauke> that's not even true in C
01:24:13 <mrsElectron> johnw: yeah
01:24:15 <johnw> mauke: how not?
01:24:22 <johnw> Fuuzetsu: no, not an up-to-date one
01:24:27 <Fuuzetsu> ok thx
01:24:38 <mauke> a C string literal is an array with static storage
01:24:47 <johnw> constant strings in gcc can be placed directly into the text segment
01:24:47 <mauke> i.e. it's effectively an unnamed global variable
01:24:59 <johnw> i.e., not in a possibly separate memory page
01:25:13 <mauke> if your compiler is smart enough, it'll merge occurrences of the same string literal, but that's not even required
01:25:18 <johnw> this also ensures they can't be modified at runtime
01:26:16 <mauke> so what you get is either char foo_0[] = "hello"; char foo_1[] = "hello"; char foo_2[] = "hello"; i.e. separate copies for each use
01:26:38 <mauke> or char foo[] = "hello"; once and references to foo in the code
01:26:55 <johnw> huh, looks like my information is out of date
01:26:55 <mauke> so it works exactly like a global variable at best, in terms of storage requirements
01:27:01 <johnw> they go into .rodata these days
01:27:05 <johnw> http://stackoverflow.com/questions/12393888/where-are-string-constants-stored-by-gcc-and-from-where-these-pointers-are-mappe
01:28:00 <johnw> well, I've worked on linkers where we placed constant strings into TEXT, but that may have been an architectural restriction (on Windows)
01:28:08 <mauke> gcc used to have an option to put string literals in .data, i.e. make them modifiable. but I don't know if that was removed
01:28:31 <johnw> you mean, like -fno-constant-strings or something?
01:28:56 <johnw> ah, -fwritable-strings
01:29:49 <johnw> mrsElectron: anyway, when thinking in Haskell, it's better not to think about "memory slots" or where/how things will be represented, at least not at first
01:30:17 <johnw> because it's likely going to be much different than what you expect, and the optimizer does a very good job
01:30:33 <johnw> later on, you will need to know some of these things, in order to effectively optimize your code later
01:32:39 <javaj>  hello programmers
01:33:41 <javaj> who still uses Fortran?
01:33:55 <johnw> is this related to Haskell, javaj?
01:34:46 <mrsElectron> so you can't make a pattern  test (x:x:xs) to match "aasdf"?
01:34:47 <javaj> john I am new to IRC chat
01:35:02 <mrsElectron> javaj: you will love ##programming
01:35:15 <javaj> I dont know what thevtopic iscall about here
01:35:15 <Fuuzetsu> mrsElectron: You can't.
01:35:27 <johnw> javaj: this channel has a pretty specific purpose, being questions about Haskell; you might find more social communities in other channels, such as mrsElectron's recommendation
01:35:42 <Fuuzetsu> You could try to achieve something similar through ViewPatterns and friends.
01:36:04 <johnw> foo ('a':'a':"sdf") = True
01:36:27 <johnw> oh, I see what he means
01:36:35 <Fuuzetsu> thought you were joking
01:36:38 <johnw> he wants Agda-style equality from the pattern matcher
01:36:41 <Fuuzetsu> yeah
01:37:03 <mrsElectron> prolog has such a feature. I suppose haskell doesn't?
01:37:11 <Fuuzetsu> well, he probably only wants sugar for Eq there
01:37:31 <johnw> you could say: foo (x:y:xs) | x == y = True
01:38:05 <mauke> I find it weird to see "he" in reference to a "mrs"
01:38:10 <mauke> mrsElectron: are you a he?
01:38:27 <Fuuzetsu> does it matter?
01:38:34 <mauke> yes
01:38:36 <Fuuzetsu> no
01:38:54 <mrsElectron> I'm a cat
01:39:24 <MP2E> :D
01:39:39 <PHO> (cons cat (cons cat nil))
01:39:41 <javaj> ok thanks to you guys
01:39:41 <PHO> https://twitter.com/lvsn/status/533685461957349376
01:39:52 <mauke> I was asking about pronouns, though. not species :-)
01:40:21 <MP2E> Cat : Cat : []
01:40:22 <Hafydd> My preferred pronoun is "cat".
01:40:25 <javaj> what was the recomendation by mrs electron though?
01:40:56 <mauke> javaj: try ##programming
01:41:15 <thungsten> If iit's so important, you can always use singualr they: http://en.wikipedia.org/wiki/Singular_they
01:41:41 <Ralith> I like using 'cat' when in doubt
01:41:48 <PHO> thungsten:  heh. I didn't know that
01:41:50 <Ralith> then everyone will be too confused to feel offended *or* correct your grammar!
01:42:31 <thungsten> Ralith: Facebook uses it. I don't think it will confuse that much
01:42:49 <Ralith> thungsten: facebook offers 'cat' as a pronoun?
01:43:06 <thungsten> No, singular they. :P
01:43:23 <johnw> we're kind of off topic now
01:43:27 <mrsElectron> so I have to mix myfunc x = | some_test = if ... then .. else   <-- is there anything syntactically wrong with that?
01:43:36 <mauke> yes. no = before |
01:44:11 <mrsElectron> do the condition have to come right after | (same line)?
01:44:12 <johnw> mrsElectron: they are called "guards"
01:44:32 <mauke> mrsElectron: no
01:44:58 <mauke> you're pretty free in regards to where you want to place your line breaks
01:45:17 <mrsElectron> define password = "secret" not in scope?
01:45:37 <mauke> eh?
01:45:59 <mauke> parse error / show your code + actual error message
01:48:16 <mrsElectron> nvm. It's 'password = "secret"', not 'define password = "secret"'. I misunderstood.
01:48:52 <mauke> ah
02:07:27 <trap_exit> what'sa good pair of programming ear plugs?
02:07:34 <trap_exit> comfortableenough for lng term wear
02:07:42 <trap_exit> good enough to block out sutpid cars / humans noise
02:07:46 <trap_exit> so I can focus on programmig
02:07:51 <trap_exit> (living in a college town)
02:09:13 <thungsten> koss sparkplug is nice. but what exactly makes a pair of earplugs good or bad for programming?
02:14:24 <sohum> @hoogle (a -> (a,a)) -> a -> [a]
02:14:26 <lambdabot> No results found
02:14:33 <sohum> :(
02:15:18 <mauke> :t sequence [fst, snd]
02:15:19 <lambdabot> (a, a) -> [a]
02:17:57 <sohum> :t let keepApplying f a = let (ret,next) = f a in ret:(keepApplying f next) in keepApplying
02:17:57 <lambdabot> (t -> (a, t)) -> t -> [a]
02:18:31 <Fuuzetsu> :t unfold
02:18:32 <lambdabot>     Not in scope: ‘unfold’
02:18:32 <lambdabot>     Perhaps you meant one of these:
02:18:32 <lambdabot>       ‘BS.unfoldr’ (imported from Data.ByteString),
02:18:34 <Fuuzetsu> :t unfoldr
02:18:35 <lambdabot> (b -> Maybe (a, b)) -> b -> [a]
02:18:51 <sohum> ooh
02:19:22 <mauke> @hoogle (a -> (b,a)) -> a -> [b]
02:19:22 <lambdabot> No results found
02:19:26 <sohum> :t \f a -> unfoldr (Just . f) a
02:19:27 <lambdabot> (b -> (a, b)) -> b -> [a]
02:19:40 <sohum> @pl \f a -> unfoldr (Just . f) a
02:19:40 <lambdabot> unfoldr . (Just .)
02:22:34 <trap_exit> to be good for programming
02:22:39 <trap_exit> they should block out noise so you don't get inerrupted
02:22:48 <trap_exit> and they should feel like they're not there, so you can wear them for 4 hour cycles
02:23:00 <trap_exit> (on what makes ear plugs good for programming)
02:26:44 * hackagebot hspec-wai 0.6.1 - Experimental Hspec support for testing WAI applications  http://hackage.haskell.org/package/hspec-wai-0.6.1 (SimonHengel)
03:10:50 <nerium> Why can’t I have these two defs in my application? https://gist.github.com/oleander/283439177fe6b461b03d
03:11:18 <nerium> I can’t see why they would be the same
03:11:38 <notdan> nerium: because you end up with two functions/constructors with the same name
03:11:45 <ClaudiusMaximus> nerium: name clashes aren't allowed, if you have Zero is it an N or a Z
03:11:47 <notdan> it's like declaring two different functions under the same name
03:12:42 <ClaudiusMaximus> nerium: you could put them in different modules and import them qualified, like import qualified Natural as N ; import qualified Integer as Z ; then use N.Zero or Z.Zero to disambiguate
03:13:01 <nerium> notdan: ClaudiusMaximus  But they have two different names Z and N.
03:13:13 <ClaudiusMaximus> nerium: the types do, but the constructors don't
03:13:16 <Freundlich> If guess it would break type inference if it was allowed.
03:13:35 <nerium> Aha, Cant I just define -1 on one if them?
03:14:41 <ToTheInternet> I wrote a function that gets all strings that can be derived from replacing 1 character in a given word: replaced1 word = [take i word ++ [a] ++ drop (i+1) word | i <- [0..length word - 1], a <- ['a'..'z']] The problem is that it includes the original string as well because characters are replaced with themselves. How can i best avoid that?
03:15:28 <Fuuzetsu> you'd add a predicate to the comprehensions making sure that a /= yourCurrentCharacter
03:15:33 <nerium> ClaudiusMaximus: I guess that’s the only way
03:15:34 <Fuuzetsu> comprehension*
03:15:39 <ClaudiusMaximus> ToTheInternet: replaced1 word = delete word [...]  -- probably the simplest
03:16:10 <ClaudiusMaximus> woops, that won't catch multiple repeats
03:16:37 <ClaudiusMaximus> ToTheInternet: filter (/= word) will eliminate all repeats
03:16:50 <nerium> ClaudiusMaximus: Where can I read more about this tecuique?
03:17:50 <ClaudiusMaximus> nerium: https://www.haskell.org/onlinereport/modules.html#sect5.3.2 is the specification
03:18:20 <ToTheInternet> ClaudiusMaximus: perfect. thanks
03:20:11 <ClaudiusMaximus> nerium: http://book.realworldhaskell.org/read/advanced-library-design-building-a-bloom-filter.html#id680447 talks a bit about it in a more practical setting
03:31:54 <bluebelle> Is there any way to debug this Parsec error? *** Exception: Text.ParserCombinators.Parsec.Prim.many: combinator 'many' is applied to a parser that accepts an empty string.
03:32:04 <bluebelle> i.e determine the function causing it
03:41:09 <Fuuzetsu> cool, didn't know Parsec did that
03:41:32 <Fuuzetsu> just look for all your uses of many
03:41:40 <Fuuzetsu> it might be by proxy…
03:41:58 <Fuuzetsu> can you post your full code?
03:49:13 <nerium> What I’m I missing here? https://gist.github.com/oleander/4115c96d31b3cde16bdc
03:49:45 <nerium> Hmm, that was a bad example has Z.Zero isn’t an IO
03:49:46 <Fuuzetsu> import shouldn't be indented
03:49:55 <Fuuzetsu> imports are top-level
03:50:09 <nerium> Fuuzetsu: Hehe, I was trying to make it nicer :)
03:50:10 <ClaudiusMaximus> if you indent the imports you need to indent main too
03:50:33 <Fuuzetsu> yes
03:50:43 <Fuuzetsu> but at that point shit son what are you doing
03:50:54 <nerium> Now I’m getting that Z.Zero is out of scope
03:50:56 <nerium> Main.hs:4:14: Not in scope: data constructor ‘Z.Zero’
03:51:35 <ClaudiusMaximus> you are only exporting the type A, without constructors
03:51:50 <ClaudiusMaximus> maybe you want module Z (A(..)) where ...
03:51:58 <ClaudiusMaximus> which exports all the constructors of A
03:52:30 <nerium> ClaudiusMaximus: Like this A(Zero Pred Succ) ?
03:52:50 <nerium> aha, ”,” in between
03:52:50 <ClaudiusMaximus> either A(Zero,Pred,Succ) or A(..)  (literally two dots)
03:53:02 <nerium> okay
03:53:21 <nerium> ClaudiusMaximus: Awesome, thanks!
03:54:05 <ClaudiusMaximus> btw your derived Ord will be confusing, perhaps data A = Pred A | Zero | Succ A  would give a more expected ordering
04:05:31 <kwos> hi everyone :)
04:06:05 <thungsten> hello kwos
04:06:29 <kwos> ah, they are kicking me out from Starbucks :S
04:06:34 <kwos> back later ;)
04:16:43 <adas> during compilation are there some standard flags that can be passed to GHC for getting a nice optimized executable?
04:17:11 <dv-> -O2?
04:18:13 <MP2E> '-O2 -fllvm' if you have llvm 3.4.x installed
04:18:20 <MP2E> produces nice and speedy code
04:18:34 <adas> dv-: what does that do? does it optimize to 2nd level?
04:18:42 <bennofs> adas: GHC uses -O1 by default, but you can try -O2. -fllvm is most useful if you have numeric code (just try if it produces better code, sometimes it produces worse code too)
04:19:22 <adas> MP2E: -fllvm produces llvm code which is then sent to llvm 3.4.x which in turn produces the actual object code...am i correct ?
04:19:29 <Fuuzetsu> -O2 is quite a lot faster than -O1, I feel the manual should remove the mention that -O2 rarely produces better result
04:19:30 <MP2E> yep
04:19:38 <MP2E> agreed Fuuzetsu
04:19:55 <bennofs> -fllvm can produce worse code too though I think
04:20:16 <MP2E> haven't seen it happen in practice, but i'm sure there are cases where the native codegen wins.
04:20:32 <bitonic> Fuuzetsu: in my experience the manual is right
04:21:04 <Fuuzetsu> in my experience it's wrong by ~4x speedup but sure, guess it depends
04:21:10 <Fuuzetsu> in the end you should benchmark anyway
04:21:17 <bitonic> I mean obviously it depends on what kind of code you write
04:21:20 <Fuuzetsu> I got some nice speedups just from playing different optimisation flags
04:21:32 <bitonic> right, but I think -O2 by default is wrong
04:21:33 <bitonic> for haskell
04:21:44 <adas> if that is the case, why cant we do things like asking llvm 3.4.x to produce ARM code for the ARM platform? because I always heard GHC doesnt do ARM well. But why produce ARM code directly when we can send it llvm instead? Or am I misreading something somewhere..
04:21:58 <MP2E> adas: we can produce ARM code via LLVM
04:21:59 <bennofs> @hackage ghc-gc-tune    -- If you want to find the best GC RTS flags automatically
04:21:59 <lambdabot> http://hackage.haskell.org/package/ghc-gc-tune    -- If you want to find the best GC RTS flags automatically
04:22:02 <MP2E> the cross compiler works now
04:22:07 <MP2E> i'ev used it to make little android applications
04:22:08 <Fuuzetsu> bennofs: ha, I knew that existed!
04:22:14 <Fuuzetsu> I looked for it some time ago
04:22:14 <MP2E> still no template haskell, and it's not exactly a beaten path though
04:22:22 <bitonic> bennofs: I didn't!  nice!
04:22:57 <Fuuzetsu> does it work still?
04:23:02 <adas> MP2E: you mean template haskell doesn't work for LLVM and consequently ARM?
04:23:12 <MP2E> no, template haskell doesn't work when cross compiling
04:23:25 <MP2E> it probably would work on arm if you could get a self hosting compiler there
04:23:37 <MP2E> for what it's worth, I did get template haskell working using a pretty bad hack
04:23:43 <MP2E> but it worked well enough to get lens to build and work
04:23:43 <Fuuzetsu> I think TH + GHCi are the problem on ARM
04:23:59 <Fuuzetsu> but AFAIK some people got GHC to run on ARM natively, or at least I saw work there
04:24:00 <adas> oh GHCi don't work on ARM either?
04:26:16 <adas> if it work on ARM .. it cwould be really nice to write code on all the SOC boards including Rpi.
04:26:42 <adas> i see it works.. but not all features
04:28:17 <Fuuzetsu> it sucks all the galois.com/~dons links are dead
04:31:45 * hackagebot twitter-types 0.6.0 - Twitter JSON parser and types  http://hackage.haskell.org/package/twitter-types-0.6.0 (TakahiroHimura)
04:31:47 * hackagebot twitter-types-lens 0.6.0 - Twitter JSON types (lens powered)  http://hackage.haskell.org/package/twitter-types-lens-0.6.0 (TakahiroHimura)
04:38:02 <titusg> I've got a weird problem with emacs haskell-mode, anyone here use it?
04:38:12 <Fuuzetsu> a lot of people
04:38:16 <titusg> :)
04:39:31 <titusg> I was working on a file, loading it with C-c C-l and so on, then moved it into a subdir. Now when I load it ghci changes directory up a level, so the imports break
04:40:04 <Fuuzetsu> M-x cd higher up
04:42:15 <titusg> Doesn't work...I'm working in ~/haskell/src/spam/src and every time I load the file ghci does Prelude> :cd ~/haskell/src/spam/
04:45:02 <titusg> If I start ghci in a terminal there is no cd-ing going on
05:06:45 * hackagebot slave-thread 0.1.3 - A principal solution to ghost threads and silent exceptions  http://hackage.haskell.org/package/slave-thread-0.1.3 (NikitaVolkov)
05:06:47 * hackagebot stm-containers 0.2.3 - Containers for STM  http://hackage.haskell.org/package/stm-containers-0.2.3 (NikitaVolkov)
05:11:45 * hackagebot hasql 0.1.6 - A minimalistic general high level API for relational databases  http://hackage.haskell.org/package/hasql-0.1.6 (NikitaVolkov)
05:11:47 * hackagebot postgresql-binary 0.3.1 - Encoders and decoders for the PostgreSQL's binary format  http://hackage.haskell.org/package/postgresql-binary-0.3.1 (NikitaVolkov)
05:11:49 * hackagebot hasql-postgres 0.5.1 - A "PostgreSQL" backend for the "hasql" library  http://hackage.haskell.org/package/hasql-postgres-0.5.1 (NikitaVolkov)
05:47:21 <mads-> Is there any guide or good explanation on how indentation works in Haskell? It seems like something I just suck at.
05:48:46 <torpet> How could I implement addition with a custom data type?
05:48:52 <torpet> "data Nat = Z | S Nat deriving Show"
05:48:55 <wei2912> mads-: the easy way out is to see if the compiler complains
05:50:28 <mads-> wei2912: Seems like all it does :P
05:50:47 <wei2912> mads-: then, the second step is paste your code here
05:52:06 <ski> mads- : some keywords (`where',`let',`do',`of') introduce layout. the layout block starts at the first non-whitespace non-comment after the keyword, and continues until the the first non-whitespace non-comment that occurs earlier on a line than the start of the layout block
05:53:06 <ski> mads- : each layout block is divides into segments, each segment starts at the leftmost column of the block and continues up to the next non-whitespace non-comment that starts in the leftmost column
05:55:00 <ski> mads- : i think there's some exceptions to this, involving `do' and `if', where a segment in a block can extend past leftmost column, if it's the last segment, and it introduces a new block starting at the same column
05:56:12 <ski> mads- : there's a layout-eliminating desugaring that inserts `{',`;',`}' to explicitly delimit and segment a block
05:57:05 <wei2912> ski: i like your use of ` and ' :P
05:57:12 * ski bows
06:01:24 <mads-> ski: thanks :)
06:07:52 <ski> mads- : where by "extend past leftmost column" i mean "extend past the next line starting on leftmost column"
06:13:25 <Fuuzetsu> ‘’
06:14:09 <stephenmac7_> Anyone know of a good guide to reading haddock pages? Meaning, I get what they do and how they work... but have no idea how to pick out the most important information, especially if the creator decided not to write any documentation.
06:19:10 <chrisdone> Fuuzetsu: it's like a mime clapping
06:19:17 <chrisdone> ‘ ’
06:19:18 <chrisdone> ‘’
06:19:22 <chrisdone> ‘ ’
06:19:25 <wei2912> chrisdone: haha
06:26:45 * hackagebot twitter-conduit 0.0.8.1 - Twitter API package with conduit interface and Streaming API support.  http://hackage.haskell.org/package/twitter-conduit-0.0.8.1 (TakahiroHimura)
06:31:56 <phaazon> edwardk: about my shading language, you mentionned a monadic interface for uniforms. I’m wondering, what would be the best between explicit typing, like do { t <- uniform Float }, and implicit one, like do { t <- uniform :: ? Float }, so that I can infer the type of the uniform?
06:32:51 <phaazon> (btw, the combinator won’t be uniform, but cpu :) )
06:33:35 <phaazon> since the unifor
06:33:52 <phaazon> hm, nvm
06:45:52 <phaazon> edwardk: https://github.com/phaazon/ash/blob/master/src/Ash.hs#L191
06:46:46 * hackagebot twitter-conduit 0.1.0 - Twitter API package with conduit interface and Streaming API support.  http://hackage.haskell.org/package/twitter-conduit-0.1.0 (TakahiroHimura)
06:46:47 <phaazon> I still need to find a way to have multi-parameters functions statement
06:50:46 <osa1> any ideas why `connect` function in Network.Socket is not returning a new Socket?
06:52:33 <simpson> osa1: Probably because it follows the BSD API.
06:52:49 <simpson> osa1: You'll need to hold onto your Socket.
06:54:33 <favetelinguis> this gives me a float value between 3-33  randomR (3,33) (mkStdGen 4) how can i get this to return an int value?
06:55:16 <phaazon> :t randomR
06:55:17 <lambdabot> (Random a, RandomGen g) => (a, a) -> g -> (a, g)
06:55:28 <phaazon> favetelinguis: how do you use the resulting value?
06:55:54 <phaazon> :t mkStdGen
06:55:55 <lambdabot> Int -> StdGen
06:56:02 <simpson> :t randomR (3 :: Int, 33)
06:56:02 <lambdabot> RandomGen g => g -> (Int, g)
06:56:11 <simpson> Add the annotation and see what else breaks.
06:57:24 <dfeuer> I'm on the very first page of the Mainland/Leshchinskiy/Peyton Jones stream fusion paper, and I'm already confused.Why does a Stream have an (s->Step s a) and an s, rather than just a Step s a?
06:58:12 <favetelinguis> simpson: makes no difference
06:58:47 <RGamma> Hey there, here is a best practices question: Suppose I have f :: a -> b -> c -> d (or more arguments). Now I want to sometimes pass functions f' :: b -> c -> d or f'' :: a -> c ->d or f''' :: a -> d (i.e. specify some of the arguments to get another function, but not more)
06:59:32 <simpson> favetelinguis: You mean that it works just fine, or that it doesn't fix your problem?
06:59:35 <RGamma> I guess I could use flip, or specify other flip functions that do what I want. Any shorthand for that? Use where clauses?
07:00:45 <favetelinguis> simpson: This is the output i get (18,200070 40692) when i do what you say whice is strange
07:00:57 <favetelinguis> aa dam srry
07:01:06 <favetelinguis> im still haksell retarded
07:01:11 <favetelinguis> that is correct
07:01:25 <RGamma> E.g. nifty would be something like f _ xb xc meaning f would be transformed to f :: b -> c -> a -> d automatically
07:02:01 <RGamma> (thus f _ xb xc :: a -> d)
07:03:05 <JagaJaga> Isn't there a library (can't find) with smth like filepath -> md5?
07:05:02 <JagaJaga> Oh, well, will read like ByteString.readFile and pass to md5 func from pureMD5
07:13:31 <zq> i just love it when cabal install forces my poor laptop to recompile every single one of snap-core's dependencies
07:17:45 <orion> What are some good solutions for serializing data structures in Haskell for use in network applications?"
07:18:21 <orion> (and deserializing)
07:18:27 <simpson> orion: binary, cereal, or one of the many standard serialization formats.
07:20:06 <bjobjo> sort of piggy-backing on that question; how would you usually implement the (de)serialisation routines?
07:20:24 <bjobjo> make your types instances of the binary typeclass, have seperate functions, or something else?
07:21:07 <simpson> If you don't really care about anything other than correctness and completeness, binary and cereal can be auto-derived if your types are Generic.
07:21:26 <bjobjo> huh, I did not know that
07:21:35 <bjobjo> that probably works in my case
07:22:12 <simpson> TBH I really recommend schemata and formatted serialization, but that's only because I write free software and like interoperability.
07:22:34 <simpson> The Generic binary/cereal route is great if you're just trying to dump stuff to disk and then read it back and don't care about versioning.
07:22:50 <bjobjo> my fun little project is implementing a bittorrent udp tracker which already has a defined format
07:23:06 <bjobjo> right now I just have a bunch of serialiseX and deserialiseX functions
07:23:08 <orion> I care about versioning.
07:23:27 <wei2912> does anyone have suggestions on toy problems that can be used to illustrate why haskell matters? :)
07:23:34 <wei2912> other than quicksort
07:23:40 <wei2912> "quicksort"*
07:24:07 <simpson> wei2912: Haskell is a general-purpose language and doesn't shine especially brightly in any one manner.
07:24:32 <wei2912> simpson: i'm just looking for a particularly elegant piece of code
07:24:35 <orion> wei2912: This past summer I wrote a blockchain.info password brute-forcer that used constant memory and maxed out the load on a 32 CPU EC2 instance.
07:24:42 <orion> In <100 lines of code.
07:24:55 <wei2912> not bad
07:25:02 <orion> That's why Haskell matters. :)
07:27:06 <wei2912> my choice is a recursive function
07:27:07 <thungsten> I think this is pretty impressive: https://gist.github.com/kasbah/b6e638655f18c1e11a2c
07:27:24 <wei2912> since i just want a small example
07:27:39 <wei2912> http://pastebin.com/AjnTg6Y9
07:28:19 <wei2912> thungsten: too bad i'm unfamiliar with fractal trees :( but that does look impressive
07:28:48 <simpson> orion, bjobjo: Anyway, my plan of attack is generally to write Binary/Get/Put instances for my types. It's relatively easy as long as the type doesn't have too many constructors.
07:29:00 <thungsten> wei2912: did you se the gif? http://fat.gfycat.com/AbleDismalIndianpangolin.gif
07:29:21 <simpson> I had a bad experience with a Minecraft parser that had a constructor for every packet type. Fifty constructors on a single type is not fun.w
07:29:24 <wei2912> thungsten: wow
07:29:27 <orion> simpson: ok
07:29:41 <augur> interesting observation:   with subtyping, you you can use elims-then-intros to transport along subtypes, and then for eta to be uniformly true, the original thing must also transport along the subtypes
07:29:59 <bjobjo> simpson: thanks :)
07:30:15 <thungsten> wei2912: otherwise, most functions on https://www.haskell.org/haskellwiki/Blow_your_mind are pretty intresting
07:30:54 <wei2912> thungsten: thanks
07:37:26 <dmj`> Fuuzetsu: ping
07:40:37 <torpet> could someone explain me why that works? https://www.dropbox.com/s/kftht7mw9xj1n65/Screenshot%202014-11-16%2016.36.55.png?dl=0
07:41:10 <simpson> torpet: Which part of it confuses you?
07:41:22 <torpet> Last line
07:41:33 <torpet> it looks like endlessrecursion to me
07:41:46 * hackagebot ghc-pkg-lib 0.1 - Provide library support for ghc-pkg information  http://hackage.haskell.org/package/ghc-pkg-lib-0.1 (JeanPhilippeMoresmau)
07:42:15 <simpson> Well, unless m is infinite, it'll eventually terminate.
07:43:11 <simpson> m probably looks like S(S(S(S(S(Z))))) or something like that, right?
07:43:25 <adamse_> torpet: if m is not infinite it terminates because the first argument to plus is strictly smaller in each recursion
07:43:25 <torpet> yes
07:43:43 <torpet> adamse_: I must be blind, but what makes the  first argument smaller each time?
07:43:58 <simpson> torpet: The pattern match captures what's *inside* the S.
07:44:02 <adamse_> torpet: you remove 1 layer of S each time in the pattern match
07:44:09 <torpet> (S a)
07:44:09 <torpet> ?
07:44:16 <simpson> Yeah.
07:44:18 <torpet> fml...
07:44:23 <simpson> Sx + y = S(x + y)
07:44:45 <torpet> i feel dumb now
07:44:47 <torpet> and i should...
07:44:49 <simpson> No worries.
07:44:49 <torpet> thanks guys
07:45:03 <simpson> Maths is hard. Don't worry about it.
07:45:30 <lericson> c/join #vim
07:45:32 <lericson> whops
07:45:59 <shafox> May I ask the use cases of Haskell language ?
07:46:20 <simpson> shafox: It's general-purpose.
07:46:34 <mrsElectron> so you can't overload functions with different arities?
07:47:05 <simpson> mrsElectron: Correct. In fact, you can't overload functions at all.
07:47:24 <mrsElectron> are name_ a valid variable name?
07:47:29 <simpson> You can certainly get funny arity effects with certain typeclasses, though.
07:47:32 <adamse_> mrsElectron: yes
07:47:37 <mrsElectron> kthnx
07:47:39 <simpson> > let name_ = 42 in name_
07:47:40 <lambdabot>  42
07:48:08 <Zorg> Haskell has a version of inet_ntoa but not one for inet_ntop?
07:48:58 <shafox> simpson: as in which domain it can be used ? Like Scala can be used in servers as well as for web development. So with regards to that can Haskell be used there
07:49:03 <simpson> shafox: Yes.
07:49:31 <shafox> simpson: ok thanks
07:49:39 <mrsElectron> wait.. why whould you code a server with haskell?
07:50:18 <mrsElectron> in*
07:51:34 <alpounet> mrsElectron: why wouldn't you?
07:51:35 <thungsten> mrsElectron: haskell runs on my webserver.
07:51:55 <mrsElectron> can you in the type specification (what's it called?) just specify the return type?
07:51:57 <friden> torpet: all you do is basically go from an expression with (possible) two zeroes succ(succ(...(zero))) +  (succ(succ(...(zero))) to one where you have only one zero, succ(succ(succ(succ(...(zero)))), so as long as you have an expression on the left side that contains a successor, you take one successor away from the left side and applies it to ((left side - 1) + right side), until what's left in the left side is zero, then you return the right s
07:52:30 <torpet> friden: Yeah I just wasn't sure where "deduction" happens.
07:52:30 <friden> sorry, i wrote that on an android, did not see that an answer was already given -_-
07:52:40 <Zorg> ah, getNameInfo might be what I'm looking for.. if it can just do an integer -> string conversion and not be expensive
07:52:43 <orion> < simpson> TBH I really recommend schemata and formatted serialization, but that's only because I write free software and  like interoperability.
07:52:45 <torpet> friden: No worries. :)
07:52:53 <orion> shafox: What packages provide such a framework?
07:53:01 <orion> I get the impression that binary and cereal don't.
07:53:05 <orion> simpson*
07:53:06 <simpson> mrsElectron: No, you need to fully specify the type. Note that if you don't specify the type, Haskell will infer one for you.
07:53:22 <simpson> orion: JSON and XML are examples of such formats.
07:53:41 <Zorg> (yep looks this way)
07:53:51 <friden> torpet: i recently learned Agda, where you need to do stuff like that yourself to even use the + operator at all in your proofs
07:54:19 <torpet> friden: Will look into it, sounds pretty interesting.
07:54:45 <mrsElectron> how do I type specify this function?  sing a b c where a is a string, b and c are ints
07:55:24 <friden> its really cool, Agda is like haskell, but instead of saying "This function takes a list, and returns head from it if the list isn't empty, and throws an error otherwise", it says "this function takes a non empty list and returns the first element"
07:56:14 <friden> or like, "this function takes an already sorted list as an argument, and returns exactly the first half of it", and if you have not coded it so that it actually returns a list of that size, it will not compile
07:57:25 <friden> that makes it easier when you have done a few proofs, cause the compiler can im many cases code for you, once you have written your function header, since everything is so strongly typed, and it already knows what results is wanted, and what we have access to
07:58:51 <mrsElectron> is sing :: int -> int -> String equivalent to  "string sing (int, int)"?
08:00:32 <Cale> mrsElectron: kind of, though if you use lower case i, that will make int a type variable
08:00:42 <Cale> which means it stands for an arbitrary choice of type
08:01:48 <Cale> mrsElectron: -> associates to the right, while function application associates to the left
08:01:50 <mrsElectron> Cale: OOooooooh, thanks
08:02:00 <Cale> mrsElectron: So if you have A -> B -> C, it means A -> (B -> C)
08:02:08 <Cale> and if you have f x y, it means (f x) y
08:02:49 <Cale> But of course, a function which produces another function as its result is essentially the same thing as a function of (at least) two arguments
08:03:19 <shafox> orion: routing , view rendering like simpson said
08:10:33 <blume> hi, im trying to get 'unfoldTreeM_BF' (building a tree breadth-first) from Data.Tree to work, and searching an element. this is my code (which doesnt even find the first element): http://lpaste.net/114399
08:12:35 <vanila> blume, I guess the tree is infinite
08:13:35 <blume> vanila: it is, but i thought searching through it breadth-first and lazily would account for that
08:13:47 <vanila> im not sure if it will work or not
08:14:03 <vanila> just thought i should mention it as possible source of problem
08:17:28 <Yuras> carter: you was correct. I failed completely
08:17:55 <Yuras> github reports >330 unique visitor, but still only 5 comments on reddit
08:18:39 <dfeuer> :t liftM
08:18:40 <lambdabot> Monad m => (a1 -> r) -> m a1 -> m r
08:18:53 <Yuras> people are interested, but don't understand it, don't have an oppinion, or don't care
08:19:21 <Yuras> I tend to think about the worse case: they don't care
08:20:47 <jergason> 1.5% engagement in writing comments doesn't seem the worst
08:20:55 <jergason> linky to what you are talking about btw?
08:21:16 <Yuras> jergason: http://www.reddit.com/r/haskell/comments/2mfxka/handling_async_exceptions_in_haskell_the_right_way/
08:21:34 * oleo sings "i've been lifted, lifted....."
08:21:37 <oleo> lol
08:23:52 <jergason> place me firmly in the "don't understand it" camp
08:24:03 <Yuras> jergason: :(
08:24:13 <jergason> but this is day four of haskell for me so i'm a giant noob
08:24:44 <Yuras> jergason: it is not haskell specific. it is just a thing where haskell fails compeltely
08:25:01 <Yuras> jergason: even C++ is better
08:30:19 <yesthisisuser> i feel like exceptions do not belong in functional programming language semantics at all
08:30:36 <oleo> jep
08:31:45 <Yuras> yesthisisuser: you can argue that, but then IO doesn't belong too
08:31:58 <oleo> haha
08:32:24 <yesthisisuser> but that's the thing.. pure functional programming is not programming without effects.. but it is about having a clear separation between the two worlds
08:32:47 <yesthisisuser> someone needs to come up with a clever abstraction that provides a similar separation of concerns w.r.t. exception handling
08:32:54 <jergason> i'm trying to do division on integers using the fractional typeclass, but the compiler complains about not being able to deduce the type. can someone tell me what i'm doing wrong? http://lpaste.net/114400
08:33:34 <Yuras> yesthisisuser: that is true, but nobody cares -- that is the problem
08:33:47 <Yuras> silent ignorance
08:34:15 <yesthisisuser> Yuras: I am sure there is some research :)
08:35:19 <blume> jergason: the problem is your type signature. you cant go from (Int,Int) to a general (a,a)
08:35:46 <orion> simpson: How would you transmit binary data when serializing to JSON? Would you first encode it in hex or base64?
08:35:48 <jergason> why not? is that just a general feature of the type system?
08:36:10 <jergason> oh so it might be because there is nothing using the function that it can actually use to determine what the concrete type would be?
08:36:52 <blume> jergason: the type is more like Fractional a => (a,a) -> (a,a)
08:36:56 <marchelzo_> jergason: if b :: Int then (b + 1) can't be in the Fractional typeclass
08:39:04 <jergason> ty for the help. basically i have a lot to learn about typeclasses i think
08:39:54 <marchelzo_> imo the numeric typeclassis are a bit confusing
08:39:57 <marchelzo_> classes*
08:40:32 <Yuras> yesthisisuser: fyi async exceptions where introduced into haskell 14 years ago
08:40:54 <muzzle> i want to write an efficient function to get all n-element long sublists of a list, something like
08:40:55 <muzzle> let f n = (filter (\l -> (length l) > n)) . (map (take n)) . tails
08:41:02 <muzzle> but faster
08:41:12 <tomberek> Hi, I haven't played around with the newer closed type families or type-level nats so I'd like to work on a type that tracks how many repeated applications of a type-function it takes to satisfy an equality (or reach the recursion limit and fail)  what would be the current implementation for type-level Nats/Literals to use?
08:41:28 <muzzle> the length operation on every sublist that i have in the above example is not ok
08:41:39 <muzzle> do you have any ideas ?
08:41:57 <simpson> orion: The entire point is that you wouldn't transmit binary data; you'd preserve the structure.
08:42:15 <simpson> orion: If you've got lots of blobs, though, JSON might not be the right format.
08:52:52 <yesthisisuser> Yuras: I wasn't following the discussion from the start. I was referring to the "try catch" idiom which I find a bit unrefined
08:53:32 <yesthisisuser> i.e. not so functional
08:54:14 <meretrix> My application uses a Haskell library that's a wrapper for a C++ library.  When I call a certain function it eats all my memory and exits with "std::bad_alloc".  How would I go about debugging this?
08:54:43 <meretrix> Do I use Haskell debugging tools or C++?
08:55:10 <Yuras> yesthisisuser: hmm, even when it is actually in pure MonadError?
08:57:25 <Yuras> meretrix: linux? probably try valgrind
08:58:44 <mrsElectron> so ++ is slow if you're playing with lists and recursion?
08:59:05 <meretrix> Yuras: Yeah. Sounds like this going to be painful.. I don't really know C/C++.
08:59:53 <benzrf> mrsElectron: sort of
09:00:06 <mrsElectron> benzrf: so what's a fast way to sort them together?
09:00:10 <benzrf> mrsElectron: (++) is (more or less) O(n), where n is the first list
09:00:18 <Yuras> meretrix: what lib? try to create minimal example and raise an issue
09:00:27 <benzrf> so ([1, 2, 3] ++) is constant time
09:00:34 <benzrf> but (++[1, 2, 3]) is O(n)
09:01:17 <mrsElectron> benzrf: thanks. So I want to use []++ in recursions, but not ++[] if the list is exhaustive?
09:01:35 <benzrf> mrsElectron: you DEFINITELY do not want to EVER do (++[])
09:01:47 <benzrf> well, ghc might optimize it away. i don't know
09:01:50 <meretrix> Yuras: QuickFIX. It's a niche library, not actively maintained.
09:01:54 <mrsElectron> thanks
09:02:19 <benzrf> mrsElectron: also, fusion can mean that if you have another O(n) operation, (++) costs you little extra
09:02:33 <benzrf> mrsElectron: what are you doing exactly?
09:02:56 <mrsElectron> benzrf: reversing a list manually
09:03:16 <benzrf> mrsElectron: the typical way is to use an accumulator, i think
09:03:23 <benzrf> mrsElectron: that way you only need to cons
09:03:34 <Yuras> meretrix: this one: https://github.com/alphaHeavy/quickfix-hs
09:03:35 <Yuras> ?
09:04:52 <mrsElectron> benzrf: cons?
09:06:03 <meretrix> Yuras: Yup
09:06:49 <benzrf> mrsElectron: wait, how much haskell do you know?
09:08:26 <mrsElectron> didn't even know what haskell was 24 hours ago
09:08:36 <Yuras> meretrix: It looks like maintained, so minimize an example and open a ticket
09:08:36 <mrsElectron> have read half a book
09:09:14 <Yuras> meretrix: you can also run "valgrind --leak-check=full <your-app>"
09:09:28 <meretrix> Thanks, I'll give that a try.
09:09:28 <Yuras> and paste the output
09:10:04 <nerium> ski: I’m continued with what we talked about yesterday; using smart constructors to normelize Z. I’ve this so far https://gist.github.com/oleander/64bfe644bb9296ce31be Any hints on how to proede
09:10:08 <nerium> *procede
09:11:01 <benzrf> mrsElectron: ah
09:11:08 <benzrf> mrsElectron: well, do you know what a linked list is
09:12:00 <benzrf> wait thats not i mportant
09:12:22 <benzrf> mrsElectron: if youve seen the (:) operator, cons is just the english name for it
09:13:16 <mrsElectron> it can be used in the argument list, yes
09:13:49 <benzrf> haskell lists are basically nested tuples
09:13:50 <mrsElectron> I could solve this problem, but I fear > O(n)
09:14:00 <jmcarthur> what's the story with blaze-builder? i've been under the impression that Data.ByteString.Builder is basically what blaze-builder is, but it looks like blaze-builder is still maintained. does the blaze-builder package still offer something not available in the bytestring package?
09:14:02 <benzrf> [1, 2, 3] is something like (1, (2, (3, nil)))
09:14:11 <benzrf> > 1:[2, 3]
09:14:13 <lambdabot>  [1,2,3]
09:14:28 <mrsElectron> >[2,3]:1
09:14:35 <mrsElectron> > [2,3]:1
09:14:36 <lambdabot>  No instance for (GHC.Show.Show t0)
09:14:36 <lambdabot>    arising from a use of ‘M471363734955017206827875.show_M4713637349550172068...
09:14:36 <lambdabot>  The type variable ‘t0’ is ambiguous
09:14:36 <lambdabot>  Note: there are several potential instances:
09:14:36 <lambdabot>    instance [safe] GHC.Show.Show
09:14:37 <benzrf> :t (:)
09:14:38 <lambdabot> a -> [a] -> [a]
09:15:04 <benzrf> mrsElectron: a list like [1, 2, 3] is really 1:(2:(3:[]))
09:15:14 <mrsElectron> is 1:[2,3] slow?    is it the same as [1]++[2,3]?
09:15:25 <benzrf> mrsElectron: no, (:) is the actual constructor of lists
09:15:36 <benzrf> 1:[2, 3] is literally exactly the same as [1, 2, 3] in every way
09:15:41 <benzrf> the latter is just syntactic sugar for the former
09:15:54 <benzrf> that's why head is fast and last is slow
09:16:02 <benzrf> you can instantly see a list as head:tail
09:16:08 <benzrf> because that's literally what it is
09:16:17 <mrsElectron> if you accumulate a list, do you typically return = x:xs?
09:16:23 <benzrf> yeah
09:16:40 <benzrf> (:) is constant time because it doesn't actually do anything, any more than making a tuple "does something"
09:16:45 <benzrf> > (1, 2)
09:16:46 <jmcarthur> ah, i see. blaze-builder has a lot more utilities and extras, such as for http and html
09:16:47 <lambdabot>  (1,2)
09:16:47 <mrsElectron> and x ++ xs is the same thing?
09:16:51 <Sorella> mrsElectron: consider that Lists in Haskell are something like: `data List a = { head: a, tail: List a }`. Then `a : b ` would be like `{ head: a, tail: b }`. You just construct one new value.
09:17:00 <vanila> 1:[2,3] = [1]++[2,3]
09:17:05 <benzrf> mrsElectron: no, (++) is defined in terms of (:)
09:17:11 <benzrf> @src (++)
09:17:11 <lambdabot> []     ++ ys = ys
09:17:11 <lambdabot> (x:xs) ++ ys = x : (xs ++ ys)
09:17:11 <lambdabot> -- OR
09:17:11 <lambdabot> xs ++ ys = foldr (:) ys xs
09:17:26 <benzrf> mrsElectron: (:) is the only way to get lists.
09:17:33 <benzrf> well, [] is predefined
09:17:34 <benzrf> but otherwise
09:17:40 <vanila> data [a] = [] | (:) { head :: a, tail :: [a] }
09:17:55 <vanila> @src []
09:17:55 <lambdabot> data [] a = [] | a : [a]
09:17:59 <benzrf> mrsElectron: just like when you say (1, 2) you're not actually computing anything, just sticking them into one value,
09:18:08 <benzrf> when you say head:tail you're not computing anything, just sticking them into one value
09:18:17 <titusg> I am reading some files with Text.IO.readFile and getting the exception: hGetContents: invalid argument (invalid byte sequence) -- do I need a different char encoding or something?
09:18:26 <benzrf> vanila: i don't think mrsElectron has seen data decls yet
09:19:34 <titusg> How do I read it as UTF8, for instance?
09:19:36 <mrsElectron> so which one is faster?    addl x = [x] ++ [1..999] or x = [1..999] ++  [x] ?
09:19:54 <vanila> mrsElectron, ++ is recursive on the left argument
09:20:03 <vanila> so [x] ++ [1..999] will be much faster
09:20:08 <vanila> it only has to do one recursion step
09:20:13 <vanila> but the other has to do almost 1000 steps
09:20:21 <mrsElectron> k ^^
09:20:50 <benzrf> mrsElectron: see, look at the code
09:20:53 <benzrf> 12:13 < lambdabot> []     ++ ys = ys
09:20:53 <benzrf> 12:13 < lambdabot> (x:xs) ++ ys = x : (xs ++ ys)
09:21:05 <benzrf> notice it never does anything to ys
09:21:08 <benzrf> ys just sits in place
09:21:12 <benzrf> but it breaks down xs
09:21:37 <benzrf> try thinking through the steps involved in something like [1, 2, 3] ++ [1..999]
09:21:40 <mrsElectron> in recursion, if the return type is a list (88888 elements long at the end of the recursion before it returns) .. and you have like 99999 recursions.. there isn't a new list for each recursion, is there?
09:21:50 <benzrf> mrsElectron: there is, sort of
09:22:02 <benzrf> mrsElectron: when i say head:tail, i'm making a new list
09:22:09 <benzrf> just like how saying (thing, other) makes a new tuple
09:22:15 <benzrf> mrsElectron: but look at this:
09:22:25 <benzrf> x = 1:2:3:4:[]
09:22:33 <benzrf> h:t = x
09:22:40 <benzrf> y = 100:t
09:22:51 <benzrf> mrsElectron: the tail of y is the same as the tail of x
09:22:59 <benzrf> so the only new memory that actually needs to be used is for the 100
09:23:14 <benzrf> even though it's a "new list"
09:23:27 <benzrf> mrsElectron: if you say [1, 2, 3] ++ l
09:23:29 <benzrf> that becomes
09:23:34 <benzrf> 1:2:3:l
09:23:42 <benzrf> so you only need new memory for the 1 and 2 and 3
09:23:43 <mrsElectron> nice
09:23:49 <benzrf> or even not that, but at least a pointer to them
09:23:58 <benzrf> otoh, if i say l ++ [1, 2, 3]
09:24:03 <benzrf> i reuse [1, 2, 3] as a tail
09:24:08 <benzrf> but i have to list down every element of l again
09:24:45 <benzrf> if l is only 2 elements that's a savings
09:24:45 <mrsElectron> thanks :)
09:24:46 <srhb> You reuse everything but the [] though, no?
09:24:47 <benzrf> but
09:25:07 <benzrf> srhb: i still need to write down, at the very least, pointers to the 1 and 2 and 3
09:25:21 <srhb> Yes.
09:25:31 <benzrf> srhb: try doing this on paper
09:25:42 <benzrf> you are allowed to draw an arrow to existing lists or values instead of rewriting the
09:25:45 <benzrf> m
09:25:50 <srhb> But in l ++ m, you're only replacing a [] with a cons
09:26:00 <benzrf> then try to write down [1, 2, 3] ++ l without having to write 3 new locations
09:26:17 <benzrf> srhb: seriously
09:26:19 <benzrf> get a sheet of paper
09:26:39 <benzrf> you can denote a list with something:otherthing
09:27:05 <benzrf> you can write down an arrow that points to some other, circled value instead of writing an actual value
09:27:36 <benzrf> now write down "x = 1:2:3:[]" and "y = 1:2:3:4:5:6:7:8:9:[]"
09:27:50 <benzrf> try to write down the resulting lits from x ++ y without more than 3 arrows
09:28:09 <jmcarthur> srhb: http://bm380.user.srcf.net/cgi-bin/stepeval.cgi?expr=%5B1%2C2%2C3%2C4%2C5%2C6%2C7%2C8%5D+%2B%2B+%5B9%2C10%2C11%2C12%2C13%2C14%2C15%2C16%5D
09:28:23 <jmcarthur> err, that may look like a suspicious link, but i assure you it is not
09:28:43 <benzrf> jmcarthur: damn, nice :)
09:28:51 <benzrf> jmcarthur: i think this is about memory rather than time though
09:29:14 <jmcarthur> benzrf: you can observe the memory used by noting how many times (:) is used
09:29:18 <benzrf> true
09:29:27 <nerium> Why isn’t this possible? https://gist.github.com/oleander/4e90f69426fd0a0a8f0e
09:30:07 <benzrf> nerium: what is it supposed to do?
09:30:15 <benzrf> >  (Succ a) = undefined
09:30:16 <lambdabot>  <hint>:1:10: parse error on input ‘=’
09:30:30 <benzrf> nerium: you are defining a?
09:30:46 <nerium> benzrf: I’m trying to validate the recursion of Succ
09:30:59 <benzrf> huh?
09:31:06 <jlind> capisce: ping
09:31:25 <benzrf> nerium: also fyi that datatype is not isomorphic to the integers
09:31:41 <nerium> benzrf: What do you mean?
09:32:06 <benzrf> nerium: any mapping from that type to the integers is necessarily noninjective
09:32:34 <nerium> okay
09:33:05 <nerium> I’m trying to define Z, but it must be normlized. Which means that a number, 5 for example can only be defined in one way
09:33:20 <nerium> benzrf: In my case Succ(Succ(Succ(Succ(Zero))))
09:33:30 <benzrf> er, by "mapping" i mean any group homomorphism
09:33:33 <nerium> one more Succ
09:33:43 <benzrf> obviously there are probably injective mappings that aren't homomorphisms
09:34:24 <benzrf> nerium: can i recommend
09:34:35 <benzrf> wait, 1 sec
09:34:37 * benzrf thinks
09:34:42 <nerium> benzrf: Sure :)
09:34:56 <benzrf> heh, hard :<
09:35:28 <nerium> benzrf: This is the code I was trying to run : https://gist.github.com/oleander/1ecde063b6d5001af223
09:36:04 <benzrf> how about
09:36:07 <nerium> This would allow Succ(Succ…..), but not Succ(Pred(Succ…))
09:36:11 <benzrf> data N = One | Succ N
09:36:20 <benzrf> data Z = Zero | Pos N | Neg N
09:36:30 <benzrf> nerium: you cannot define Succ as a function
09:36:32 <benzrf> it's a data constructor
09:36:39 <benzrf> ...which is also a functoin, but
09:36:50 <benzrf> i mean you can't write a regular function def for it
09:37:09 <nerium> benzrf: I havent defined it
09:37:37 <benzrf> yes you have
09:37:37 <nerium> benzrf: Which line have I done this?
09:37:48 <benzrf> you're trying to, using
09:37:51 <benzrf>  (Succ a) = (validate (Succ) (a) (Succ a))
09:37:52 <nerium> benzrf: I didnt say I didn’t, I’m can just see where
09:38:09 <jmcarthur> looks like a pattern match to me
09:38:25 <benzrf> jmcarthur: yeah but i think nerium is trying to use it to define a Succ function
09:38:27 <nerium> Okay
09:38:29 <nerium> jmcarthur: Which should be okay, shouldnt it?
09:38:35 <benzrf> jmcarthur: only outside of the clas
09:38:40 <benzrf> er, * nerium
09:38:49 <benzrf> nerium: but you won't be able to look at a
09:38:52 <benzrf> it's bottom
09:39:00 <nerium> benzrf: No I’m not trying to define a function on Succ, but instead on Z
09:39:16 <jmcarthur> actually i can't infer what the intent is. it looks weird to me
09:39:16 <nerium> that true
09:39:17 <benzrf> define what you mean
09:39:20 <benzrf> jmcarthur: yeah
09:39:27 <benzrf> jmcarthur: it seems to have stemmed from a confusion of ideas :I
09:39:32 <nerium> I think I know what you mean
09:39:32 <benzrf> nerium: what are you reading to learn haskell
09:39:34 <titusg> Switching to BS.Char8 fixed my problem
09:46:30 <nerium> benzrf: Thanks btw!
09:46:58 <benzrf> np
09:47:08 <benzrf> nerium: seriously though, what are you learnin haskell from
09:47:32 <nerium> benzrf: what do you mean?
09:48:05 <benzrf> nerium: what resource are you using to learn haskell
09:48:17 <nerium> benzrf: Google
09:48:57 <benzrf> ):
09:49:03 <benzrf> nerium: what's your prior programming experience
09:49:31 <nerium> 12 years using Ruby
09:50:32 <fresheyeball> hello out there
09:50:41 <fresheyeball> I am in over my head and need help
09:50:46 <vanila> hi
09:50:51 <vanila> whats up
09:51:13 <monochrom> is Ruby that old? 12 years?
09:51:16 <fresheyeball> So, I generally write interface code
09:51:39 <fresheyeball> and recently learned about the Cassowary algorithm to solve linear constraints
09:51:42 * monochrom recalls jokes about CV's that say "40 years of C++"
09:51:48 <benzrf> nerium: well, it's better than python :b
09:51:52 <fresheyeball> its can't be unseen, Cassowary is the future of interface layout
09:51:57 <vanila> Cassowary algorithm ok
09:52:10 <vanila>  incremental constraint solving toolkit that efficiently solves systems of linear equalities and inequalities
09:52:24 <fresheyeball> I can use an existing implementation, but they are OO based
09:52:27 <linduxed> hey guys, i'm having a hard time figuring out what i'd use "newtype" for
09:52:29 <fresheyeball> and difficult to reason about
09:52:37 <linduxed> it seems to be working like data
09:52:38 <pantsman-> Ruby is about 20 years old
09:52:51 <fresheyeball> If I'm going to live in a space of purity
09:53:15 <fresheyeball> then I need Cassowary as a native functional api
09:53:18 <vanila> "the same algorithm Apple uses to compute native layout"
09:53:27 <vanila> I've always thought that apple mac os xhas the best GUI in terms of resizing
09:53:35 <vanila> I didn't know it was done with this
09:53:40 <fresheyeball> I've spent days now  trying to understand the thing from a math perspective
09:53:44 <fresheyeball> but I am not getting it
09:53:51 <benzrf> linduxed: operationally speaking, newtypes are erased at compile time
09:53:53 <hiptobecubic> constraints-based layout is not the beautiful gem you're imagining
09:54:11 <hiptobecubic> When it behaves how you're expecting, sure. It's great.
09:54:27 <fresheyeball> @hiptobecubic, please continue
09:54:27 <lambdabot> Unknown command, try @list
09:54:29 <hiptobecubic> When you can't get it to do what you want and you have no control over what the solver finds it makes you want to kill yourself
09:54:57 <hiptobecubic> Enaml works this way (python)
09:55:04 <benzrf> linduxed: if you say `newtype Foo a = Foo (Maybe a); x = Just 3; y = Foo x;', then freeze your program at runtime, they will have the exact same data inmemory
09:55:06 <fresheyeball> @hiptobecubic my understanding is that Cassowary has a unique property there
09:55:07 <lambdabot> Unknown command, try @list
09:55:13 <benzrf> linduxed: in fact, y may be implemented as a pointer to x
09:55:19 <fresheyeball> as it finds solution of least change
09:55:33 <benzrf> linduxed: so any calls to newtype accessors or pattern matches are wiped from your code at compile time
09:55:36 <saep> linduxed: It is a "crippled" `data` definition that has no run-time cost. So, if your data definition works with a newtype, you should use newtype.
09:55:36 <benzrf> or constructors
09:55:39 <hiptobecubic> Usually it's great. It was (still is) based on Cassowary as well.
09:56:31 <fresheyeball> @hiptobecubic I think its the best that is possible right now
09:56:31 <lambdabot> Unknown command, try @list
09:56:31 <hiptobecubic> but often you're left thinking "Why the HELL won't that thing expand!?" and then things get pretty crazy
09:57:01 <vanila> fresheyeball, is there a paper that explains how it works
09:57:16 <fresheyeball> yes
09:57:29 <fresheyeball> http://constraints.cs.washington.edu/solvers/cassowary-tochi.pdf
09:57:35 <hiptobecubic> if your layout fits into a nice tree and doesn't need to look 'up' the tree to figure anything out and you don't have too many interesting constraints, then it's really fast to develop with
09:58:00 <vanila> I noticed that scwm uses the C++ implementation
09:58:12 <linduxed> benzrf: saep thx!
09:58:12 <hiptobecubic> once you start demanding that far away things line up with each other you realize that it's really opaque and difficult to tweak
09:58:32 <fresheyeball> @hiptobecubic it still sounds better than what I have now
09:58:32 <lambdabot> Unknown command, try @list
09:58:37 <hiptobecubic> fresheyeball, you might still be right that it's the best that's currently available.
09:58:37 <fresheyeball> which is css box model
09:58:57 <fresheyeball> anyway there is a paper http://constraints.cs.washington.edu/solvers/cassowary-tochi.pdf
09:58:59 <hiptobecubic> fresheyeball, the @ is confusing lambdabot :)
09:59:07 <fresheyeball> oh sorry
09:59:13 <vanila> im having a look at the paper
09:59:32 <fresheyeball> I'm not mathy enough to understand it
09:59:41 <fresheyeball> simplex, normal simplex has me stumped right now
09:59:47 <vanila> you can just learn math
10:00:22 <fresheyeball> vanila, thats not really helpful
10:00:41 <benzrf> linduxed: what's saep?
10:00:54 <saep> benzrf: me
10:00:57 <linduxed> benzrf: another dude in the channel :-P
10:01:22 <mrsElectron> foobar x:xs = foobar(xs) ++ foobar(x) ... is there a rule for in which order foobar will be evaluated? Will it evaluate foobar(xs) recursively first, before it evaluates any foobar(x)?
10:01:29 <fresheyeball> I've been watching videos on simplex
10:01:59 <fresheyeball> when you move to the tableau you select the smallest coefficient
10:02:02 <fresheyeball> why?
10:02:06 <monochrom> mrsElectron: if you use ++ there, ++ determines it. why do you want to know?
10:02:26 <benzrf> ah
10:02:27 <fresheyeball> I feel like its just operations but no explanation as to why it works
10:02:36 <simpson> fresheyeball: http://webstaff.itn.liu.se/~stegu/simplexnoise/simplexnoise.pdf
10:03:10 <mrsElectron> monochrom: order matters. So how do ++ determine it? ^^
10:03:53 <hiptobecubic> perlin got an academy award for Perlin Noise?
10:04:06 <simpson> hiptobecubic: Tron.
10:04:07 <monochrom> I disagree.
10:04:25 <hiptobecubic> ah
10:04:26 <mauris> > let l = concatMap (\a -> [0, a]) $ map succ l in l !! 0
10:04:30 <lambdabot>  mueval-core: Time limit exceeded
10:04:39 <mauris> how come this doesn't evaluate to 0?
10:04:48 <monochrom> knowledge of lazy evaluation plus the source code of ++ tell you what is done first.
10:05:08 <mrsElectron> monochrom: you're right, order shouldn't matter
10:09:05 <nerium> What I’m I missing here? https://gist.github.com/oleander/bb256a09b4f66d12b343
10:09:23 <nerium> the compiler complains about the last two lines
10:11:01 <keko-2> ll gives you a Z
10:11:16 <keko-2> but you're giving what you get from ll to Pos/Neg
10:11:21 <keko-2> and they take a N
10:11:46 <nerium> keko-2: Aha, how would I create a Z instread?
10:11:58 <keko-2> Pos (ll (a - 1))
10:12:46 <nerium> keko-2: Isn’t that what I*m doing on the second to last line?
10:12:57 <keko-2> yes, that's where the problem is
10:13:10 <keko-2> you're using ll, which gives you a Z
10:13:20 <keko-2> you already defined fromInteger to create N's, so use that instead
10:14:10 <chpatrick> hiya
10:14:25 <chpatrick> can you use lens to do multiple folds in one go a la the foldl package?
10:14:54 <nerium> keko-2: I dont get what’s wrong. Should the ll create a sequence like this Neg ( Succ Succ One )
10:16:35 <keko-2> wait, is the definition of Z supposed to be Zero | Pos Z | Neg Z?
10:16:44 <keko-2> in that case you would need recursion
10:17:07 <keko-2> I thought you just wanted to reuse N
10:17:16 <benzrf> keko-2: would you
10:17:28 <nerium> keko-2: I think it should be Zero | Pos N | Neg N
10:17:36 <benzrf> yeah, that's what i gave you
10:17:37 <benzrf> :p
10:17:44 <benzrf> where N starts from One
10:17:53 <nerium> benzrf: Yes, I know :)
10:18:58 <keko-2> so, you have an Integer and want to get a N and put that N inside Neg/Pos
10:19:26 <keko-2> and you already defined fromInteger to take an Integer and give you a N
10:20:29 <keko-2> so, Pos (fromInteger a), right?
10:20:51 <nerium> keko-2: Yeah, now I get it. Thanks
10:29:36 <lpp> @pl f x = x + 1
10:29:36 <lambdabot> f = (1 +)
10:30:10 <lpp> how can I have infinite loop which writes number of seconds on the output since when it is started?
10:30:41 <lpp> I'm familiar with threadDelay but don't know how to combine it together
10:30:42 <benzrf> lpp: with I/O
10:30:49 <lpp> yeah I get it
10:30:57 <lpp> but how (syntax wise)
10:30:57 <benzrf> lpp: use some kind of syscall to get the current time
10:31:08 <benzrf> lpp: and keep track of when you started
10:31:08 <lpp> the point is I have a counter
10:31:12 <benzrf> a counter?
10:31:21 <lpp> in some procedural language
10:31:28 <lpp> for (;;) {
10:31:32 <lpp> x = f(x)
10:31:33 <benzrf> haskell can be procedural
10:31:37 <lpp> sleep(1);
10:31:37 <lpp> }
10:31:40 <benzrf> you probably mean imperatice
10:31:44 <benzrf> *imperative
10:32:29 <monochrom> main = do { x <- getCurrentTime; print x; main }
10:32:43 <lpp_> (sorry I disconnected accidentally)
10:32:45 <monochrom> I don't know why threadDelay comes in
10:33:01 <benzrf> monochrom: why involve do-notation?
10:33:02 <lpp_> because I need to have some pause
10:33:09 <benzrf> main = forever $ getCurrentTime >>= print
10:33:34 <monochrom> do-notation is more well-known
10:33:54 <exio4> forever $ getCurrentTime >>= print >> threadDelay (somenumberthatmeansonesecond) :P
10:34:35 <monochrom> but I haven't printed time since start, only time since dawn of humanity
10:34:36 * ChristianS likes >>= / >> if everything fits into a single line, do-notation otherwise
10:34:44 <benzrf> operators are left-associative by default, right
10:34:53 <benzrf> > x `f` y `g` z
10:34:54 <lambdabot>  Could not deduce (Debug.SimpleReflect.Expr.FromExpr t0)
10:34:55 <lambdabot>    arising from a use of ‘Debug.SimpleReflect.Vars.f’
10:34:55 <lambdabot>  from the context (Debug.SimpleReflect.Expr.FromExpr t)
10:34:55 <lambdabot>    bound by the inferred type of
10:34:55 <lambdabot>             it :: Debug.SimpleReflect.Expr.FromExpr t => t
10:34:59 <benzrf> > x `f` y `g` z :: Expr
10:35:00 <lambdabot>  No instance for (Debug.SimpleReflect.Expr.FromExpr t0)
10:35:00 <lambdabot>    arising from a use of ‘Debug.SimpleReflect.Vars.f’
10:35:01 <lambdabot>  The type variable ‘t0’ is ambiguous
10:35:03 <lambdabot>  Note: there are several potential instances:
10:35:04 <benzrf> > (x `f` y `g` z) :: Expr
10:35:05 <lambdabot>    instance (GHC.Show.Show a, Debug.SimpleReflect.Expr.FromExpr b) =>
10:35:07 <lambdabot>  No instance for (Debug.SimpleReflect.Expr.FromExpr t0)
10:35:09 <lambdabot>    arising from a use of ‘Debug.SimpleReflect.Vars.f’
10:35:09 <benzrf> dammit
10:35:10 <lpp_> Thank you.
10:35:11 <lambdabot>  The type variable ‘t0’ is ambiguous
10:35:13 <lambdabot>  Note: there are several potential instances:
10:35:15 <lambdabot>    instance (GHC.Show.Show a, Debug.SimpleReflect.Expr.FromExpr b) =>
10:35:23 <benzrf> lpp_: no problem
10:35:39 <zwer> loop start = do { now <- getCurrentTime; print (diffUTCTime now start); loop start }
10:36:56 <blume> hey benzrf, yesterday you gave me a hint on how to remove duplicate entries from a tree: by populating a list while building/traversing it. now ive been sitting here all day long not being able to get it to work properly. mind having a look? http://lpaste.net/848964225232535552
10:37:43 <benzrf> np
10:38:24 <benzrf> blume: ah, i was thinking of more as-you-generate it
10:38:29 <benzrf> although fusion could make this work i guess
10:39:08 <blume> i tried that, too, to no avail. the tree isn't infinite any more, but still there are many duplicates and trees-within-trees.
10:39:18 <benzrf> blume: anyway your impl looks correct
10:39:22 <benzrf> what's the question?
10:39:38 <benzrf> (btw you may want to use a Set rather than a list for faster inclusion-checking)
10:39:58 <blume> i used a Sequence when building the tree
10:42:07 <benzrf> blume: so how is this malfunctioning
10:42:11 <blume> the building looks like this: http://lpaste.net/189751401734209536
10:43:01 <blume> well, as soon as the tree hits the original node again(which /should/ be Empty), it's rebuilding all over
10:43:25 <benzrf> blume: generate it lazily
10:43:33 <benzrf> then your filter can filter it without it going into a loop
10:43:56 <benzrf> it'll also force the generation up to the truncated parts
10:44:10 <blume> i thought i was already doing it lazily :/
10:50:51 <torpet> I am writing a division method: http://lpaste.net/8202869961736060928
10:51:04 <torpet> But the problem is that the result is too large by 1.
10:51:40 <torpet> A way to fix that would be to write a function to subtract 1 (S(Z)) from the result, but thats really ugly.
10:51:49 <torpet> Any idea how i can make it more elegantly?
10:52:19 <simpson> torpet: Division in Peano is always kind of a matter of definition.
10:53:48 <torpet> simpson: Well, what do you mean?
10:53:57 <torpet> 7/2 should always be 3 and not
10:54:01 <torpet> *and not 4
10:54:11 <benmachine> torpet: doesn't that function say 6/3 is 2?
10:54:19 <benmachine> torpet: i.e. not one too large
10:54:28 <benmachine> just eyeballing it, haven't checked
10:54:40 <adamse_> torpet: wouldn't rounded up division be useful sometimes/
10:54:50 <simpson> torpet: I just mean that your current definition of division isn't based on multiplication and addition, but on subtraction, so I'm not surprised that it acts a little differently.
10:54:57 <torpet> well 6/3 does work.
10:55:02 <simpson> But that's just me. I prefer piano to Peano.
10:55:07 <torpet> but the problem is when a number has a divisionrest
10:55:54 <torpet> simpson: I will try to implement it with addition
10:56:42 <Kototama> hi, what's wrong with my usage of lens aeson to iterate over all values? I got only one value http://paste2.org/AB69hZhN
10:57:14 <adamse_> torpet: what if you add an additional base case: http://lpaste.net/8202869961736060928
10:57:55 <benmachine> torpet: what I would do is replace the a = 0 clause with an a < b clause
10:58:09 <torpet> I cannot do that
10:58:20 <torpet> then I would have to define a > and < function
10:59:31 <torpet> benmachine: Doesn't that only fix the problem when the division rest is 1 :D
10:59:39 <torpet> What if I divide 10 by 4
10:59:43 <torpet> ^^^
11:00:00 <benmachine> well then you get 1 + (6 / 4) = 2 + (2 / 4) = 2 + 0
11:00:04 <benmachine> which is what you wanted
11:07:02 <jlind> §
11:07:15 <Kototama> ok i needed to replace ^? by ^..
11:07:24 <Kototama> is there a good lens tutorial for haskell beginners?
11:09:27 <mrsElectron> is grabbing the x:th element from a list O(1)?
11:10:04 <simpson> No, it's O(n).
11:10:14 <simpson> Er, O(x) in your case.
11:12:01 <zwer> this is odd.. `threadDelay undefined' delays indefinitely rather than throwing an exception
11:12:29 <mitu> don't you mean ... undefinetly?
11:12:44 <zwer> probably
11:13:08 <Pamelloes> Is that a bad pun, or am I missing something?
11:14:00 <benmachine> zwer: are you sure? I bet it does throw an exception, but maybe you're not seeing the exception
11:14:15 <zwer> why am I not seeing it?
11:14:20 <benmachine> zwer: be aware that if you raise an exception in a thread and it is not caught, it does not get raised to the parent thread
11:14:24 <benmachine> I don't know, that's also weird
11:14:24 <zwer> typing threadDelay in ghci
11:14:28 <benmachine> ah
11:14:34 * benmachine tries
11:14:48 <benmachine> the behaviour you describe is almost but not quite impossible
11:15:05 <zwer> that is what I'm getting
11:15:06 <exio4> > threadDelay undefined
11:15:07 <lambdabot>  Not in scope: ‘threadDelay’
11:15:08 <exio4> *** Exception: Prelude.undefined
11:15:13 <exio4> heh
11:15:14 <winobes> does anyone know how to sequence parsec parsers in such a way that the result of both is returned? I can do (p1 >> p2) but then i only get the result of p2.
11:15:22 <benmachine> zwer: I get the exception immediately
11:15:33 <benmachine> winobes: sure, there are a few ways
11:15:43 <benmachine> winobes: one of which is liftA2 (,) p1 p2
11:15:54 <benmachine> or (,) <$> p1 <*> p2, which is equivalent
11:15:56 <zq> winobes: (,) <$> p1 <*> p2
11:16:02 <zq> meh
11:16:05 <benmachine> or pure (,) <*> p1 <*> p2
11:16:07 <simpson> winobes: do { a <- p1; b <- p2; return (a, b) } -- if you don't like tuple sections
11:16:18 <exio4> there isn't any tuple section there
11:16:45 <simpson> Huh. I was sure that (,) only worked with TupleSections. Guess I'm wrong.
11:16:53 <zwer> benmachine ok, I tried in plain ghci now instead of emacs.. I get <interactive>: Prelude.undefined  but prompt hands.. I have to kill ghci
11:17:05 <benmachine> zwer: that's weird
11:17:15 <zwer> hangs*
11:17:22 <winobes> ahh ok... the only problem is, i don't know a priori how many I'm going to combine
11:18:11 <winobes> currently my ugly-ass expression looks like this: w <- (iterate (\p -> field >> (string "/") >> p) field)!!(nSlashes-3)
11:18:15 <indiagreen> winobes: you can use (,,,) <$> p1 <*> p2 <*> ... or something. Or, if you truly don't know, you can make a list of them and use sequence
11:18:27 <edwardk> phaazon: one argument for being explicit about the type in a term through a value-level proxy is that there are things where you need to specify layout, std140, std430, packed, shared, etc. if matrices are transposed, etc. capturing those in a type annotation is hard, capturing them in a value is easy
11:19:20 <phaazon> edwardk: that’s very true
11:19:26 <phaazon> I’ll see that later on tho
11:19:35 <winobes> i will look more closely at sequence
11:20:29 <edwardk> simpson: tuple sections allow you to mix and match the explicit constructor has always worked (,,,,,,) etc is fine (,,,3,,,) requires a tuple section
11:21:00 <mauris> > let l = concatMap (\a -> [0, a]) $ map succ l in l !! 0
11:21:02 <simpson> edwardk: TIL.
11:21:04 <lambdabot>  mueval-core: Time limit exceeded
11:21:09 <mauris> how come this doesn't evaluate to 0?
11:21:20 <mads-> When I have a function Expr -> [Int] -> Int and another function Expr -> Int, what is it then called when I "pack" the first into another such that the new function and the second has the same signature and I can use them interchangably? Like this: http://ideone.com/zxSdEO
11:22:52 <mauris> oh, wait, i think i sorta get why
11:23:17 <mauris> hmm. what i'm trying to do is
11:23:38 <mauris> generate the ruler sequence [0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,4, ...]
11:23:40 <phaazon> mauris: because of concatMap
11:24:00 <mauris> noting that the even elements are [0,0,0,0,...] and the odd ones are (map succ ruler)
11:25:05 <mauris> > let l = 1 : (concatMap (\a -> [0, a]) $ map succ l) in take 17 l
11:25:07 <lambdabot>  [1,0,2,0,1,0,3,0,1,0,2,0,1,0,4,0,1]
11:25:19 <mauris> this sort of works
11:25:20 <codygman> If I wanted to create a specialization (add things to mainly) the BrowserAction StateT monad, it would be correct and reasonable to create my own StateT monad transformer over it right?
11:25:44 <phaazon> mauris: oh
11:25:51 <mauris> oh, here i go:
11:25:51 <mauris> > let l = 0 : (concatMap (\a -> [a, 0]) $ map succ l) in take 17 l
11:25:53 <lambdabot>  [0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,4,0]
11:26:13 <mauris> > let l = 0 : (concatMap (\a -> [a, 0]) $ map succ l) in l
11:26:15 <lambdabot>  [0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,5,0,1,0,2,0,1...
11:26:43 <exio4> > let l = 1 : foldr (\a > 0:succ a:) [] l in l
11:26:44 <lambdabot>  <hint>:1:23: parse error on input ‘>’
11:26:47 <exio4> > let l = 1 : foldr (\a → 0:succ a:) [] l in l
11:26:49 <lambdabot>  <hint>:1:34: parse error on input ‘)’
11:27:05 <exio4> er?
11:27:27 <phaazon> > let l = 1 : foldr (\a -> 0:succ a:) [] l in l
11:27:29 <lambdabot>  <hint>:1:35: parse error on input ‘)’
11:27:38 <phaazon> > let l = 1 : foldr (\a -> 0:succ a) [] l in l
11:27:39 <lambdabot>  Couldn't match expected type ‘[[a1]] -> [[a1]]’
11:27:39 <lambdabot>              with actual type ‘[a1]’
11:27:39 <lambdabot>  Relevant bindings include
11:27:39 <lambdabot>    a :: [a1] (bound at <interactive>:1:21)
11:27:39 <lambdabot>    l :: [[a1]] (bound at <interactive>:1:5)
11:27:55 <exio4> > let l = 1 : foldr (\a b → 0:succ a:b) [] l in l
11:27:57 <lambdabot>  [1,0,2,0,1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,5,0,1,0,2,0,1,0...
11:28:27 <phaazon> > let l = 1 : l in take 2 l
11:28:29 <lambdabot>  [1,1]
11:28:30 <winobes> indiagreen: sequence worked -- here's what i end up with w <- fmap concat $ map sequence (iterate (++[(string "/"), field]) [field])!!(nSlashes-3)
11:28:41 <phaazon> > let l = l in take 2 l
11:28:45 <lambdabot>  mueval-core: Time limit exceeded
11:28:54 <phaazon> that was why you got a mueval-core, exio4
11:29:02 <phaazon> huh, mauris *
11:29:21 <exio4> heh :P
11:29:23 <mauris> yeah i figured "why doesn't concatMap make sure to always give me at least one 0" but if l == [] it wouldnt
11:30:28 <phaazon> @hoogle typeAsIn
11:30:28 <mauris> > let l = 0 : foldr (\a b → succ a:0:b) [] l in l
11:30:29 <lambdabot> No results found
11:30:30 <lambdabot>  [0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,5,0,1,0,2,0,1...
11:30:35 <phaazon> @hoogle asTypeIn
11:30:35 <lambdabot> No results found
11:30:43 <mauris> > let l = fix $ (0:) . foldr (\a b → succ a:0:b) [] in l
11:30:45 <lambdabot>  [0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,5,0,1,0,2,0,1...
11:30:47 <phaazon> @hoogle asTypeOf
11:30:47 <lambdabot> Prelude asTypeOf :: a -> a -> a
11:30:55 <phaazon> hm
11:34:48 <Zorg> https://gist.github.com/zorgiepoo/940a822ad8a1a45174d5 any way I can make this simpler (especially the last function)? Not really sure how to bind the Maybe's here.
11:36:09 <phaazon> Zorg: you can use maybe
11:36:12 <phaazon> or MaybeT
11:36:25 <phaazon> or even (MonadPlus m,MonadIO m) => m Socket
11:36:30 <phaazon> which is my favorite way to go
11:38:02 <phaazon> furthermore
11:38:08 <phaazon> you might want Functor
11:39:08 <phaazon> fmap reuse (makeSocket addrInfo) where reuse serverSocket = fmap bindIt …
11:40:53 <Fuuzetsu> One day I will be looking at IRC when dmj` is on… Clearly today was also not the day.
11:42:42 <phaazon> Zorg: I left a comment on the gist ;)
11:43:32 <phaazon> oh wait
11:43:34 <phaazon> it’s wrong
11:43:37 <phaazon> don’t mind me :D
11:43:38 <Zorg> thanks. I'll take a look at MaybeT first
11:43:41 <Zorg> heh
11:44:37 <phaazon> you have to use traverse actually :)
11:47:06 <phaazon> but yeah, with MaybeT
11:47:16 <phaazon> it’s just monadic and basic code :)
11:52:13 <joneshf-laptop> hmm, it seems like modeling with state machines should be used more regularly, is there a reason why they aren't?
12:05:24 <adarc> hey quick q, im using bracket with openFile and then some cleanup function.. when I openFile on a non existent file, I don't get to my cleanup.. however if I use try, I can catch the exception.. is bracket unable to catch those kinds of exceptions? i don't remember running into this before when I used bracket
12:11:15 <JonReed> Hi! Does anybody know why "readProccess" doesn't sometimes intercept the output of a process? E.g., "o <- readProcess "xgamma" [] []" will not be able to catch the output. The output will "leak" to the console output instead of being assigned to the "o" variable.  With other processes like "o <- readProcess "ls" [] []" it works as expected.
12:12:47 <marchelzo_> JonReed: maybe one is writing to stderr and the other to stdout? I don't know what xgamma is
12:13:25 <marchelzo_> yes xgamma appears to write to stderr for me
12:13:58 <nerium> benzrf: How would you define N and Z if N includes zero?
12:15:35 <JonReed> marchelzo_: Thx! I wonder how to read stderr
12:19:29 <nitrix> I have to say, of all the haskell code I've read, never seen a single TODO comment.
12:19:51 <nitrix> If that doesn't hint something...
12:19:55 * nitrix mumbles mumbles
12:20:22 <dispersed> fneuro
12:20:23 <sinelaw> TODO: add more TODOs
12:21:37 <nitrix> I wonder if TODO-driven development is a thing.
12:22:41 <Hodapp> nitrix: It's what I use.
12:23:33 <ersiees> hi?
12:23:57 <sinelaw> hi.
12:24:36 <ersiees> i have some questions about haskell (noob :D)
12:24:41 <sinelaw> ask away
12:26:33 <benzrf> nerium: difficult
12:26:42 <nerium> benzrf: I solve it
12:26:43 <benzrf> nerium: i believe either 1 or 2's complement does a trick where
12:26:48 <benzrf> you have just Neg and Pos
12:26:51 <nerium> hold on
12:26:52 <benzrf> but then when converting you add one if neg
12:26:54 <benzrf> er, subtract 1
12:26:59 <nerium> data N = Zero | Succ N deriving(Eq, Show, Ord)
12:27:00 <nerium> data Z = Pos N | Neg N
12:27:06 <nerium> That should work
12:27:13 <dispersed> nnn/RWD
12:27:18 <nerium> And then just match on Pos Zero and Neg Zero
12:27:21 <benzrf> nerium: well, the obvious conversion gives Neg Zero /= Pos Zero
12:27:42 <nerium> benzrf: Hmm, that might be a problem
12:27:45 <benzrf> nerium: treat Neg n as Pos n - Pos n - Pos n - 1
12:28:05 <benzrf> then Neg Zero -> -1
12:28:59 <nitrix> Is GHC clever enough to chose to use a pointer if always copying an object on the stack to call be copy becomes expensive?
12:29:14 <nitrix> Similarly, to just copy a value instead of using a reference to it?
12:30:13 <nitrix> Having done a lot of C, letting the compiler pick for me is a releif but also a source of stress.
12:30:58 <nerium> benzrf: Where should I treat it like that?
12:31:37 <sinelaw> nitrix, it happens in C also when you pass a struct by value. :) but you're right that it's simpler and predictable
12:32:10 <sinelaw> nitrix, but I don't think GHC works that way - it does graph reduction, not function calls
12:32:19 <sinelaw> at least when not using the FFI
12:32:29 <nitrix> Interesting.
12:32:36 <sinelaw> but actually I don't know. I'm just guessing. ask in #ghc perhaps
12:33:01 <nitrix> Meh, I'll just keep writing code and worry about it if it actually becomes a problem.
12:33:05 <nitrix> It just feels weird.
12:33:26 <sinelaw> keep in mind that haskell is also lazy, so it's actually more complicated than that
12:33:39 <dispersed> hemol
12:34:14 <JonReed> Is there an easy way to run a command and read its stderr (like "readProcess" which reads from stdout)? I'm about to copy the readProcess code (http://hackage.haskell.org/package/process-1.0.1.3/docs/src/System-Process.html#readProcess)  and modify it for my needs.
12:34:43 <JonReed> I feel I'm overcomlicating things
12:36:21 <nitrix> sinelaw: Quick question, I'm using a lot of Data.DataString.Lazy and Data.Text.Lazy. Is this prone to explode to my face or having it lazy is more likely desirable?
12:36:44 <sinelaw> nitrix, it depends what you're doing with it
12:36:46 <nitrix> sinelaw: Why isn't the default version lazy with an extra .Strict or something?
12:37:01 <sinelaw> I don't know
12:37:12 <nitrix> Ah.
12:37:15 <sinelaw> :)
12:37:33 <nitrix> sinelaw: In my case they're almost immediatly used, so the lazyness is probably not a good gain.
12:38:13 <sinelaw> nitrix, this seems useful: http://blog.ezyang.com/2010/08/strings-in-haskell/
12:38:27 <sinelaw> basically, laziness is nice for streaming
12:38:36 <sinelaw> I use it to parse enormous files
12:38:44 <nitrix> sinelaw: Thanks :)
12:39:51 <mrsElectron> what, what's the $ char doing in the source code of some examples? Never seen that one before
12:40:01 <mrsElectron> (abs $ x2 - x1)
12:40:19 <indiagreen> it's an operator which just applies a function to the value
12:40:24 <RchrdB> mrsElectron: it's defined as f $ x = f x
12:40:36 <indiagreen> but it has the lowest priority, so it lets you avoid using parens
12:40:38 <triliyn> It has very low precedence, so sometimes it can be used in place of parentheses
12:40:57 <triliyn> abs $ x2 - x1 is abs (x2 - x1)
12:44:22 <nerium> benzrf: Isn’t there another way of prevent Pos Zero to happen?
12:44:40 <benzrf> nerium: you could probably do something disgusting with GADTs
12:45:13 <nerium> benzrf: I looked at that before, but I didn’t get anywhere
12:45:24 <nerium> Any hints on  where to get to start
12:45:55 <benzrf> i wouldnt
12:46:25 <benzrf> nerium: but if you absolutely muts
12:46:43 <benzrf> nerium: you can use GADTs to make Zero :: Nat SomeType and S thing :: Nat OtherType
12:46:55 <benzrf> then require that the Neg constructor take a Nat OtherType
12:46:59 <benzrf> while Pos can take Nat a
12:47:04 <benzrf> trust me, this is a bad idea
12:47:43 <nerium> benzrf: Is there a simpler way of preventing this? Or does it matter? I’m trying to build a surjectve function from N to Z
12:48:04 <nerium> benzrf: Right now I just normalize the values
12:48:30 <codygman> Could I somehow add a Wreq.Session.Session to my monad transformer stack? Should I use something other than Wreq? How would I create a default Session, Wreq doesn't seem to export the Session constructor. Basically I want to achieve Sessions/cookie handling: http://lpaste.net/114405
12:48:41 <benzrf> nerium: you can do that fairly easily
12:48:55 <nerium> benzrf: How?
12:48:57 <benzrf> nerium: tbh this seems like something that would be more appropriate to do in coq
12:49:05 <benzrf> then you can, for example, verify surjectivity
12:49:14 <nerium> coq?
12:49:19 <benzrf> interactive theorem prover
12:49:22 <benzrf> 1 sec let me show you a demo
12:49:31 <triliyn> benzrf: if you wanted to, you could probably call your constructors NegS and PosS rather than Neg and Pos, and say that PosS Zero represents 1 and so on
12:49:31 <nerium> benzrf: https://gist.github.com/oleander/6f6b00428b6766630274
12:49:37 <JonReed> mrsElectron: $ char is like putting brackets around statement. "(abs $ x2 - x1)" is the same as  (abs (x2 -x1)). You can think of it as putting wrapping the following statement with brackets till the next bracket is encountered. "print ("Hello " ++ "world")"is the same as "print $ "hello " ++ "world"
12:49:39 <ski> nerium : `data Z = Zero | PosSucc N | NegSucc N'
12:49:42 <benzrf> triliyn: that's what i suggewted
12:49:48 <nerium> benzrf: That’s my current one
12:49:49 <triliyn> ah, okay
12:49:50 <benzrf> ski: i gave him that already
12:49:55 <blume> benzrf: i made it work after all. the problem was that my show instance sorted each element in the tree, so that they /looked/ the same, but werent... faith in haskell restored, faith in myself not so much :D thanks for your help.
12:50:08 <benzrf> blume: haha
12:50:10 <benzrf> np
12:50:40 <nerium> ski: I already have a working implementation of Z using Pred and Succ, but I can’t find a way to prevent what we talked about yesterday
12:50:53 <ski> oh, i missed triliyn suggested it
12:51:16 <benzrf> nerium: 1 moment im working out a demo in coq of something like this
12:51:21 <ski> nerium : prevent what ? `Pred (Succ n)' and `Succ (Pred n)' ?
12:51:28 <merijn> heh, I was checking my junk mail folder and apparently Indian students are mailing me their haskell homework to solve... >.>
12:51:39 <nerium> ski: Yes
12:51:53 <ski> nerium : didn't smart constructors work ?
12:52:04 <ski> or aren't your examiner happy about that ?
12:52:13 <nerium> ski: I didn’t get it to work
12:52:22 <monochrom> you're looking at: the integers are not free. they are a quotient thing.
12:52:35 <nerium> ski: Currently i’m using https://gist.github.com/oleander/bdabca590487ece7a440
12:52:56 <nerium> ski: Which i guess prevents this
12:53:13 <benzrf> nerium: what did you say about surjections?
12:53:21 * ski . o O ( "I am not free, I am a quotient thing." )
12:53:34 <benzrf> ski: heheheh
12:53:57 <nerium> benzrf: I have a surjective function from N to Z
12:54:11 <nerium> The problem is that Z might return two types of zeroes
12:54:20 <nerium> I’m not sure that’s a problem tho
12:55:23 <ski> nerium : why would it prevent this ? (whatever "this" means in this circumstance)
12:56:17 <nerium> ski: Now there is only one way to create a value in Z
12:56:27 <mrsElectron> I want to make a datatype Circle that contains a float, float and a float. One way is this: data Shape = Circle Float Float Float. But I want to make a Circle type without it being a shape or anything else but just a circle. How do you do that?
12:56:38 <ski> nerium : just make sure either (a) nobody (external to your module) can tell the difference between `Pos Zero' and `Neg Zero'; or (b) normalize to one of them, and make sure noone can create the other
12:56:51 <benzrf> kk nerium this is what coq is like https://gist.github.com/8744cc2487dc0b1b2b2c
12:56:58 <monochrom> data Circle = CircleConstructor Float Float Float
12:57:14 <benzrf> nerium: (this is a paste of an interactive session i just did)
12:57:26 <nerium> benzrf: Aha, okay. But that’s a different language :)
12:57:34 <ski> mrsElectron : in your declaration, `Shape' was the type, and `Circle' the data constructor for that type. in monochrom's veriant, `Circle' is the type
12:58:03 <ski> iow, monochrom's version is just a renaming of yours
12:58:39 <mrsElectron> can you give the type and destructor the same name?
12:58:46 <benzrf> nerium: well, why are you doing this?
12:58:51 <benzrf> nerium: is it specifically for haskell use?
12:58:59 <mrsElectron> brb
12:59:01 <monochrom> there is no destructor
12:59:03 <benzrf> or are you trying to do something mathematical in nature and haskell seemed like a good fit
12:59:47 <nerium> benzrf: I’m trying to define N and Z in Haskell. Then I’m using those types to define a surjective function from N to Z to show that Z is countable
12:59:59 <benzrf> nerium: why *haskell* though
13:00:27 <nerium> benzrf: b/c I need to use a functional programing language (according to the assignment)
13:00:43 <benzrf> nerium: exactly
13:00:44 <monochrom> what is "show"? I am serious. is it a proof written in Haskell? is it a proof written about Haskell, i.e., at the meta level? they are different.
13:00:48 <benzrf> coq is a perfect fit for this kind of thing
13:00:48 <robstewartuk> Is there a Haskell library that provides performance regression testing facilities? I'm thinking of something between criterion and GHCs http://ghcspeed-nomeata.rhcloud.com/ .
13:01:01 <benzrf> it is specifically designed as a theorem prover
13:01:06 <benzrf> er, proof assistant
13:01:09 <ski> mrsElectron : you can give the type and the data constructor the same name, yes. personally i would probably do `data Circle = MakeCircle Float Float Float' or `data Circle = MkCircle Float Float Float', though
13:01:24 <nerium> benzrf: Okay. The problem is that I need to hand in the assignment in 2h and i’m almost done
13:01:28 <benzrf> haha
13:01:31 <benzrf> ok fair enough
13:01:44 <robstewartuk> I'd like to provide a collection of micro benchmarks, and performance improvements or regression are compared directly against previous benchmarks.
13:01:50 <benzrf> nerium: ah, you couldnt use nat starting from one because then you have the wrong type?
13:01:50 <nerium> I’ve been working on it for about 30h now so swiching now is a bit late
13:01:54 <ski> benzrf : are you suggesting they learn Coq before a (non-dependent) functional programming language ?
13:02:00 <benzrf> ski: uuuum
13:02:05 <benzrf> m-maybe
13:02:11 * ski grins
13:02:21 <monochrom> I would suggest to use a proof language for proofs, and a programming language for programs.
13:02:43 <benzrf> well i assume nerium's proof will be non-computerized
13:02:47 <nerium> I’m not trying to prove that Z is countable in haskell
13:02:49 <ski> monochrom : isn't that what the tactic language is ?
13:02:56 <nerium> I’m just need to implement a function N -> Z
13:03:01 <nerium> thats surjective
13:03:03 <benzrf> nerium: why in haskell?
13:03:06 <adamse> nerium: define an addition al type N+ or something that starts from 1
13:03:10 <benzrf> oh right
13:03:22 <benzrf> nerium: why are you defining Z, then
13:03:26 <benzrf> why not just use built in Integer
13:03:34 <nerium> benzrf: That’s part of the assignment
13:03:37 <benzrf> oh
13:03:40 <nerium> We should define N and Z
13:03:46 <benzrf> nerium: i'd go with the shift-the-negatives thing
13:03:59 <nerium> benzrf: What you wrote before?
13:04:05 <benzrf> yeah
13:04:13 <nerium> benzrf: I didn’t really understand that
13:04:15 <benzrf> that is, abs (Neg v) = S v
13:04:22 <benzrf> nerium: er
13:04:26 <benzrf> nerium: ok, you have N
13:04:34 <benzrf> then data Z = Pos N | Neg N
13:05:00 <benzrf> but Neg x (the value)
13:05:22 <benzrf> instead of having Integer value of -(convert x), it should have Integer value of -(convert x) - 1
13:05:29 <ski> benzrf : `abs (Neg _) = Zero' would also work, given the other part is still surjective
13:05:32 <benzrf> nerium: that is, Neg x + Pos x = -1
13:05:42 <benzrf> ski: i know
13:05:49 <nitrix> What is the best way to have multiple objects with a uniform Provider type, that'd allow me to have the same `get` and `put` operations for them but with multiple implementations for each provider?
13:05:56 <ski> ok, you wanted to use `abs' for some reason. that's fine
13:06:08 <benzrf> nitrix: ruby guy!!!
13:06:20 <benzrf> ski: just because it was familiar
13:06:27 <nitrix> Right now it's a Provider record, with two function pointer...
13:06:32 <benzrf> nitrix: just 2 functions
13:06:34 <benzrf> not pointers
13:06:42 <nitrix> ah.
13:06:55 <benzrf> nitrix: wait hold on, *are* you the guy who has 12 yrs ruby?
13:06:59 <benzrf> or have i confused you
13:07:06 <benzrf> *with somebody else
13:07:07 <nitrix> benzrf: I'm not, I write C.
13:07:12 <benzrf> derp ok
13:07:27 <benzrf> nitrix: what is this Provider for?
13:07:40 <nitrix> benzrf: I'd like to isolate each get/put operation for each provider into their own modules since these are quite complicated.
13:07:52 <merijn> nitrix: I would just write a record of functions
13:07:54 <benzrf> nitrix: there may be a slight xy problem here
13:08:03 <benzrf> this type sounds fishy
13:08:11 <benzrf> nitrix: what is it being used in?
13:08:39 <nitrix> benzrf: It's providing chunks to a distributed file-system, which is what I'm writing.
13:08:52 <merijn> nitrix: Do get/put always have the same type?
13:09:01 <merijn> nitrix: i.e. only their implementation should be different?
13:09:19 <nitrix> merijn: They do. get :: PageId -> Page, put :: Page -> PageId
13:09:28 <benzrf> nitrix: you have it in memory?
13:09:29 <nitrix> merijn: yes.
13:09:37 <merijn> nitrix: ok, then I'd go the "record of functions" approach
13:09:42 <merijn> nitrix: For an example, see
13:09:55 <merijn> @google Gabriel Gonzalez scrap your typeclasses
13:09:56 <lambdabot> http://www.haskellforall.com/2012/05/scrap-your-type-classes.html
13:09:56 <lambdabot> Title: Haskell for all: Scrap your type classes
13:10:26 <nitrix> merijn: I have that. But then, how would I create that record? Have each implementation provide a function to create the record with the proper functions assigned?
13:10:39 <merijn> nitrix: Yeah
13:10:56 <nitrix> Interesting. So I instinctively did it right.
13:11:06 <nitrix> How weird's that.
13:11:10 <benzrf> :)
13:11:16 <merijn> nitrix: For example, I'm working on a library with sockets where I just have a "Config -> IO (Socket a)" function, where "Socket a" is the relevant implementation
13:11:55 <nitrix> I remember having that discussion now! I was half asleep though, maybe that's why it was natural this time.
13:12:02 <merijn> nitrix: :)
13:12:28 <benzrf> nitrix: if this is a file system then why is there no IO involved?
13:12:30 <benzrf> is itall memory?
13:12:51 <nitrix> benzrf: There'll be IO, tons of IO :P
13:13:00 <benzrf> then shouldnt it be
13:13:07 <benzrf> get :: PageId -> IO Page, put :: Page -> IO PageId
13:13:19 <nitrix> :: PageId -> IO (Maybe PageId)
13:13:27 <nitrix> Whoops, Page, you get the idea.
13:13:49 <L8D> guys
13:14:00 <nitrix> I like my Maybes :)
13:14:04 <L8D> what's the highest quality keyboard you can get with ~$40?
13:14:20 <L8D> I know, I know... #haskell-blah is five keys away
13:14:42 <L8D> but anways... are there any mechs at that price?
13:14:52 <nitrix> L8D: logitech g105
13:14:58 <nitrix> L8D: My all time favorite so far.
13:15:10 <L8D> nitrix: it's mechanical?
13:15:24 <nitrix> Yeah, but the noise is bearable.
13:15:48 <L8D> are you sure those aren't rubber domes?
13:15:52 <vanila> is it possible to implement a pure version of ST using monadprompt?
13:16:45 <nitrix> L8D: Mhhh, if that's the case, it doesn't feel like it. I'll pop a key later to check.
13:16:47 * hackagebot traced 2014.11.15 - Simple evaluation trace  http://hackage.haskell.org/package/traced-2014.11.15 (EdwardKmett)
13:16:49 * hackagebot postgresql-binary 0.4.0 - Encoders and decoders for the PostgreSQL's binary format  http://hackage.haskell.org/package/postgresql-binary-0.4.0 (NikitaVolkov)
13:23:02 <benzrf> https://hackage.haskell.org/package/MonadPrompt-1.0.0.5/docs/Control-Monad-Prompt.html how is this different from cont
13:23:10 <benzrf> it seems pretty similar on the fac
13:23:13 <benzrf> *face
13:23:45 <Tekmo_> I remember there was a comment a long time ago explaining the relationship between Prompt and Free
13:23:55 <Tekmo_> Let me see if I can dig it up
13:24:31 <Tekmo_> Found it: http://www.reddit.com/r/haskell/comments/1h1etb/adventures_in_three_monads_logic_prompt_failure/caq493k
13:25:44 <nitrix> I have a strange "Not in scope data constructor `Provider` when the import is clearly there.
13:25:45 <JonReed> L8D: If you'll ever want to buy an expensive keyboard go with "Kinesis Advantage Linear Feel". IMO, it's the best keyboard available (besides perhaps a steno keyboard that allows you to type 280 wmp)
13:26:23 <L8D> JonReed: does it use cherry switches?
13:27:08 <JonReed> L8D: it uses the light ones. I think those are red.
13:27:19 <L8D> -.-
13:27:35 <nitrix> https://github.com/nitrix/udfs/blob/develop/src/Provider/Local.hs    and    https://github.com/nitrix/udfs/blob/develop/src/Provider.hs
13:27:44 <nitrix> Provider/Local.hs:11:17: Not in scope: data constructor ‘Provider’
13:28:03 <JonReed> L8D: Yes those are red
13:28:14 <L8D> MX Browns ftw
13:28:37 <blume> i <3 Blue
13:28:45 <L8D> too loud
13:28:56 <blume> nope, the other ones are too silent :3
13:29:15 <nitrix> merijn: ping ;-;
13:29:20 <L8D> pang
13:29:48 <Tekmo_> nitrix: You need to export the constructor like this: Provider(Provider, name, ...)
13:29:54 <Tekmo_> nitrix: The outer `Provider` is the type name
13:29:59 <Tekmo_> nitrix: THe inner` Provider` is the constructor
13:30:05 <benzrf> :t re
13:30:06 <lambdabot> (Contravariant f, Functor f) => AReview s t a b -> (t -> f t) -> b -> f b
13:30:08 <nitrix> Ah, crap.
13:30:23 <Tekmo_> nitrix: Or you can just do:
13:30:24 <nitrix> Tekmo_: Makes sense, I have a data constructor and a type with the same name.
13:30:26 <Tekmo_> nitrix: Provider(..)
13:30:32 <Tekmo_> nitrix: That exports everything
13:30:50 <nitrix> Sold!
13:30:52 <benzrf> > over (re _Left) (fmap (+1)) "foo"
13:30:53 <lambdabot>  No instance for (Data.Functor.Contravariant.Contravariant
13:30:53 <lambdabot>                     Data.Functor.Identity.Identity)
13:30:53 <lambdabot>    arising from a use of ‘Control.Lens.Review.re’
13:30:55 <benzrf> wait
13:31:04 <benzrf> aw dang
13:31:09 <Tekmo_> nitrix: Neat project, by the way!
13:31:21 <benzrf> :t review
13:31:22 <lambdabot> MonadReader b m => AReview s t a b -> m t
13:32:00 <nitrix> Tekmo_: Give it a star! Depending how long it takes me to pick up Haskell, it should be pretty nice, indeed :)
13:32:45 <Tekmo_> nitrix: I have a no-star policy, but you have my moral support! :)
13:33:05 <nitrix> Woot!
13:33:31 <benzrf> :t (^..)
13:33:32 <lambdabot> s -> Getting (Endo [a]) s a -> [a]
13:33:57 <benzrf> > (1, 2) ^.. traverse
13:33:59 <lambdabot>  [2]
13:35:36 <merijn> nitrix: pong?
13:36:27 <Tekmo_> > Just 2 ^.. traverse
13:36:29 <lambdabot>  [2]
13:36:46 <Tekmo_> > sumOf both (1, 2)
13:36:47 <lambdabot>  3
13:37:16 <Tekmo_> > sumOf (both . folded) ([1, 2], [3, 4])
13:37:18 <lambdabot>  10
13:37:24 <NemesisD> is it possible with TH to get visible types? I'm trying to get a list of all Type that is a member of an typeclass
13:37:49 <Zekka> NemesisD: I don't know TH offhand but are you sure you need to do that?
13:38:03 <Zekka> Generally that's a sign you mean to do something else (often existentials)
13:38:12 <Tekmo_> NemesisD: I don't believe that is possible since it would conflict with compilation boundaries
13:39:22 <NemesisD> Zekka: Tekmo_ : here's what i'm trying to do, i've go a QC property, say Eq a => [a] -> Property, i would like to generate specialized properties for all visible inhabitants of Eq a, Show a, Arbitrary a
13:39:45 <Zekka> NemesisD: How are they specialized?
13:40:03 <Tekmo_> Are you specializing them just for performance reasons?
13:40:10 <NemesisD> as it stands, i have that generic property and then if I want to use them I must hint to GHC which a i mean
13:40:18 <NemesisD> oh, sorry maybe i didn't mean specialize, fully qualified?
13:40:35 <NemesisD> so i want a [Int] -> Property, [Char] -> Property, etc
13:41:19 <NemesisD> so if i were to write a test i'd have to do testProperty "qualified to Ints" (myProp :: [Int] -> Property)
13:41:57 <Tekmo_> What's the type signature of the function you want to create copies of?
13:42:16 <NemesisD> (Arbitrary a, Eq a) -> [a] -> Property
13:42:35 <Tekmo_> Couldn't you write just one function of that type?
13:42:57 <NemesisD> I could but then i'd have to write a test for every single inhabitant to actually run quickcheck against it
13:43:17 <NemesisD> it has to decide A at the call site
13:43:20 <NemesisD> a*
13:44:06 <Tekmo_> What function consumes that property?
13:44:23 <Tekmo_> In other words, what is the (rough) type of `testProperty`?
13:44:51 <NemesisD> should be something like String -> Property -> AThingMyTestFrameworkCanRun
13:45:15 <Tekmo_> What about the `[a] -> ...`?  Where did that go?
13:45:57 <NemesisD> i think that uses coarbitrary or something in quickcheck, its basically the arbitrary bit of the property
13:47:05 <Tekmo_> I mean, is it in the type signature of `testProperty`?  Like this: String -> ([a] -> Property) -> AThingYourTestFrameworkCanRun?
13:47:48 <dweave> general functional programming question here:  When you want to map and filter an array.  It’s not always necessary to do 2 iterations over the list.  What is the FP way of accomplising a map and a filter in one iteration?  this could be done in a reduce or a fold I guess but that seems sloppy.
13:48:21 <benzrf> dweave: lazy eval = fusion happens
13:48:50 <Tekmo_> dweave: It will be in one pass automatically
13:48:53 <NemesisD> Tekmo_: I'm referring to something like this guy https://hackage.haskell.org/package/test-framework-quickcheck2-0.3.0.3/docs/Test-Framework-Providers-QuickCheck2.html
13:49:05 <dweave> what if you not using a lazily evaluted language (sorry i know this is the haskell room, but i don’t know who else to ask)
13:49:46 <Tekmo_> dweave: Usually non-lazy languages still have generators or lazy iterators or something likethat
13:49:54 <Tekmo_> dweave: Those will do the right thing if you do map + filter
13:50:12 <dweave> gotcha
13:50:12 <Tekmo_> dweave: As for other things, there are still ways to do this, but slightly more complicated
13:50:39 <Tekmo_> dweave: For example, some libraries will actually represent `map` and `filter` as a syntax tree, optimize the tree (i.e. by fusing map and filter) and then turn that into an array operation
13:51:07 <dweave> interesting
13:51:20 <Tekmo_> NemesisD: In that case, there are a couple of things you can do instead of duplicating the function
13:51:28 <Tekmo_> NemesisD: Are you familiar with `Data.Proxy`?
13:51:30 <dweave> Tekmo_ do you know any JS implementation of these things
13:51:55 <Tekmo_> dweave: I don't, but I can explain it so that you could implement it
13:52:22 <dweave> Tekmo_ : i think i need to find out how to articulate what I’m looking for.
13:52:33 <NemesisD> hmm, so thinking about this problem more, I think what i'm after is if you give me any function: (Arbitrary a, Show a, plus more) => Proxy a -> Property, i'll find the inhabitants  of all those typeclasses, generate a Proxy of them and give you back [Property]
13:52:43 <NemesisD> Tekmo_: yeah
13:52:51 <Tekmo_> dweave: The general term for this is stream fusion or deforestation or shortcut fusion
13:52:57 <Tekmo_> Those are the keywords you should look for
13:52:58 <dweave> cool
13:53:03 <dweave> i’ll look into it thanks a lot
13:53:12 <Tekmo_> NemesisD: Right
13:53:49 <Tekmo_> NemesisD: Alternatively, you can just return a list of functions with `testProperty` applied to them with type signatures
13:53:50 <NemesisD> the trick is grabbing the list of typeclasses, unioning it with Arbitrary/Show and then finding the inhabitants
13:54:09 <NemesisD> Tekmo_: that could work too although that would tie me to a test framework
13:54:19 <Tekmo_> NemesisD: i.e. [testProperty ... (yourProperty :: [Int] -> Property), testProperty ... (yourProperty :: [Char] -> Property)]
13:54:34 <dweave> Tekmo_ : are you familiar with clojure transducers? if so is this the same thing?
13:54:38 <Tekmo_> NemesisD: In that case, what you're looking for is existential quantification
13:55:03 <NemesisD> oh interesting. hadn't considered how that would work here
13:55:08 <Tekmo_> dweave: I'm only passingly familiar with them
13:55:46 <dweave> k sounds like it’s an implementation of what i’m going for
13:55:51 <Tekmo_> NemesisD: You can do: data MyProperty = forall a . (Eq a, Arbitrary a, ... ) => MyProperty ([a] -> Property)
13:56:13 <Tekmo_> dweave: You may want to check out the Haskell `foldl` library
13:56:18 <Tekmo_> dweave: Disclaimer: I wrote it
13:56:21 <dweave> cool
13:56:27 <Tekmo_> dweave: It's basically the Haskell analog of transducers
13:56:46 <Tekmo_> dweave: What it does is that it's a fold that just preserves the step function and accumulator
13:57:00 <Tekmo_> dweave: When you do `map` or `filter` on it you just modify the step function
13:58:13 <Tekmo_> dweave: Here's the relevant type: http://hackage.haskell.org/package/foldl-1.0.7/docs/Control-Foldl.html#t:Fold
13:59:08 <NemesisD> Tekmo_: so my TH would generate that data definition?
13:59:20 <Tekmo_> NemesisD: No, it still wouldn't be able to
13:59:40 <Tekmo_> NemesisD: I'm pretty sure a module can not have access to the complete list of all instances, because type class instances are "open"
13:59:52 <Tekmo_> NemesisD: Meaning that new instances might arise as you mix in additional modules
14:00:21 <NemesisD> Tekmo_: that would be fine with me, i'm aiming for whatever is in scope at compile time
14:00:35 <NemesisD> i.e. if you have prelude you get all prelude's Eqs, unless i misunderstand you
14:00:55 <Tekmo_> NemesisD: I'm not sure, then
14:04:24 <NemesisD> Tekmo_: I see TH has reifyInstances :: Name -> [Type] -> Q Bool, so if there was some sort of allInScopeTypes :: Q [Type] i'd be in business, but of course I can imagine some types are problematic, like lists, etc. so maybe i could restrict it to types of kind * i'm thinking
14:08:22 <torpet> How can i make this function output False if condition in line 2 isn't met? http://lpaste.net/5258179395062857728
14:08:54 <cdk> torpet: eqN _ _ = False
14:09:29 <torpet> cdk: Well, pattern are overlapping then
14:09:42 <pharpend> hmm
14:09:59 <pharpend> torpet: why not use guards? This seems like a place where guards are better than patterns
14:10:14 <cdk> torpet: they are, but not in a bad way. Only the (Z, S a) and (S a, Z) cases overlap
14:10:15 <torpet> I cannot use equal because the datatype doesnt implement it
14:10:27 <Tekmo_> Wait, why is that pattern overlapping?
14:10:34 <mrsElectron> do I have to use class constraints, when I'm type specifying    printName :: NameContainer -> String. NameContainer is my own datatype!
14:11:19 <cdk> Tekmo_: the lpaste torpet pasted doesn't contain any overlapping patterns. My suggested "eqN _ _ = False" contains 2 overlapping patterns
14:11:52 <Tekmo_> cdk: I meant, why does `eqN _ _ = False` overlap with other patterns?
14:12:23 <cdk> maybe overlap is not the right word. But that matches the (Z, S a) and (S a, Z) case
14:12:29 <torpet> cdk: overlaps with eqN (S a) (S b) = eqN a b
14:12:49 <tolt> It doesn't overlap if it's placed last does it?
14:12:51 <cdk> torpet: no, because that pattern will be checked first
14:12:56 <Tekmo_> It doesn't overlap if it's the last pattern
14:13:26 <Tekmo_> To be precise, it doesn't overlap if it's the last pattern and the previous patterns were non-exhaustive
14:13:26 <torpet> cdk: Excellent. Didn't know there is an order involved
14:13:28 <cdk> I guess I wasn't clear that the wildcard pattern should be the last one
14:13:47 <torpet> wow that actually is quite a blessing, could have written so much better code if i knew that
14:14:11 <Tekmo_> :)
14:14:47 <cdk> torpet: yes, the patterns will be checked in the order they appear. Of course, this also applies to the patterns in a "case x of y -> ..." expression
14:15:41 <torpet> So if no "S" can be found because one of the two values is zero, your pattern will be matched
14:15:51 <cdk> exactly :)
14:16:09 <statusfailed> Does anyone use NixOS as their desktop OS?
14:16:23 <torpet> Thanks
14:19:20 <benzrf> statusfailed: >>>#nixos
14:19:49 <johnw> statusfailed: I know people who do
14:21:03 <Tekmo_> statusfailed: ocharles is a big fan of Nix, if I remember correctly
14:21:18 <statusfailed> Ah then presumably it has an up to date ghc :D
14:21:41 <Tekmo_> Yeah :)
14:21:47 * hackagebot higher-leveldb 0.1.1.0 - A rich monadic API for working with leveldb databases.  http://hackage.haskell.org/package/higher-leveldb-0.1.1.0 (jeremyjh)
14:21:54 <ocharles> You remember correctly :)
14:22:48 <Tekmo_> :)
14:30:26 <edwardk> new code golf opportunities: let s=n/l in is 2 characters longer than if|s<-n/l=  -- and the latter admits characters immediately following the =
14:30:47 <dweave> Thank Tekmo_
14:30:53 <dweave> *thanks
14:31:47 * hackagebot postgresql-binary 0.5.0 - Encoders and decoders for the PostgreSQL's binary format  http://hackage.haskell.org/package/postgresql-binary-0.5.0 (NikitaVolkov)
14:32:20 <edwardk> oh, i guess its |s<-n/l->
14:32:48 <pharaun> i have a question, i implemented a primitive scheme interpreter in haskell for fun. right now its strictly eval at the language level, how hard/is there any good resouce on how to make your own interpreter/dsl lazy-eval ?
14:33:28 <ski> a lazy scheme ?
14:33:37 <Tekmo_> dweave: You're welcome!
14:33:37 <pharaun> ya
14:33:57 <ski> or lazily interpreting the scheme source input ?
14:34:06 <pharaun> ski: lazy scheme itself.
14:35:03 <ski> pharaun : you need to implement promises/thunks, making every Lazy Scheme expression evaluate internally to such a thing
14:35:31 <pharaun> ahh i see, promises/thunks, k i'll look up those, got any good paper on how to implement those?
14:36:41 <pharaun> i think i found a few examples, thanks ski i'll dig into this more
14:37:14 <ski> pharaun : "Scheme Requestion For Implementation 45: Primitives for Expressing Iterative Lazy Algorithms" by André van Tonder in 2003-09-20 at <http://srfi.schemers.org/srfi-45/srfi-45.html> will perhaps also be interesting to check out
14:38:01 <ski> pharaun : it's about a efficiently implementing a separate data type of explicit promises in (non-lazy) Scheme, but it can still be useful to read for your pervasive implicit promises
14:38:39 <pharaun> ya, this seems neat
14:41:54 <ski> pharaun : it also mentions "How to add laziness to a strict language, without even being odd" by Philip Wadler,Walid Taha,David MacQueen in 1998-09 at <http://homepages.inf.ed.ac.uk/wadler/topics/language-design.html#lazyinstrict>, which is also relevant
14:42:47 <vanila> You could reflect haskells lazyness into your interpreter
14:43:08 <vanila> this may be the easiest way to write a lazy interpreter
14:44:05 <NemesisD> does anyone have any tips on debugging template haskell? I just want to see what data it generates in the REPL
14:45:03 <hellohaskell> hello. I'm searching for an easy solution for a little problem. How can I remove equal elements in a list that are neighbours? For example ["", "Hello", "Haskell", "", "", "", "", "how", "", "are", "you"] => ["", "Hello", "Haskell", "", "how", "", "are", "you"]
14:45:25 <pharaun> vanila: probably my ultimate solution, but i would still like to understand the impl and also see if i can't provide the same semantics as outlined in (lazy or etc) when possible
14:45:31 <pharaun> very helpful, thanks ski
14:45:56 <NemesisD> hellohaskell: take a look at "group" from Data.List
14:46:19 <NemesisD> i imagine your solution is something like concat . map take 1 . group
14:47:03 <ski> pharaun : and you should then also probably check out "Tail recursion without space leaks" Richard Jones in 1992-01 at <http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.45.5083>
14:47:12 <ion> take 1 <=< group
14:47:14 <vanila> hellohaskell, map head . group I think
14:47:15 <ski> (i don't recall if i've looked at that one)
14:47:23 <vanila> > map head . group $ ["", "Hello", "Haskell", "", "", "", "", "how", "", "are", "you"] => ["", "Hello", "Haskell", "", "how", "", "are", "you"]
14:47:24 <lambdabot>  <hint>:1:86: parse error on input ‘=>’
14:47:32 <vanila> > map head . group $ ["", "Hello", "Haskell", "", "", "", "", "how", "", "are", "you"]
14:47:33 <lambdabot>  ["","Hello","Haskell","","how","","are","you"]
14:47:45 <hellohaskell> vanila NemesisD Thank you!!
14:48:43 <hellohaskell> If I only want to delete empty lists? I have to take groupBy?
14:48:56 <ion> filter (not . null)
14:49:21 <vanila> > groupBy null $ ["", "Hello", "Hello", "Haskell", "", "", "", "", "how", "", "are", "you"]
14:49:22 <lambdabot>  Couldn't match type ‘GHC.Types.Bool’
14:49:22 <lambdabot>                with ‘[GHC.Types.Char] -> GHC.Types.Bool’
14:49:22 <lambdabot>  Expected type: [GHC.Types.Char]
14:49:22 <lambdabot>                 -> [GHC.Types.Char] -> GHC.Types.Bool
14:49:22 <lambdabot>    Actual type: [GHC.Types.Char] -> GHC.Types.Bool
14:49:32 <vanila> > groupBy ((==)`on`null) $ ["", "Hello", "Hello", "Haskell", "", "", "", "", "how", "", "are", "you"]
14:49:33 <lambdabot>  [[""],["Hello","Hello","Haskell"],["","","",""],["how"],[""],["are","you"]]
14:49:49 <vanila> > groupBy ((&&)`on`null) $ ["", "Hello", "Hello", "Haskell", "", "", "", "", "how", "", "are", "you"]
14:49:50 <hellohaskell> wow. thank you
14:49:50 <lambdabot>  [[""],["Hello"],["Hello"],["Haskell"],["","","",""],["how"],[""],["are"],["y...
14:50:11 <vanila> so map head on that will only merge null neibhours
14:50:14 <kadoban> :t on
14:50:15 <lambdabot> (b -> b -> c) -> (a -> b) -> a -> a -> c
14:50:20 <vanila> @src on
14:50:20 <lambdabot> (*) `on` f = \x y -> f x * f y
14:51:20 <kvitebjorn> anyone help with package dependencies? http://npaste.de/p/gxtu/
14:51:47 * hackagebot pandoc-lens 0.3 - Lenses for Pandoc documents  http://hackage.haskell.org/package/pandoc-lens-0.3 (BenGamari)
14:53:55 <platz> sometimes I wonder if there should be more meaningful names for parameters of functions.  e.g. for `on` essentially you have a combining function and a mapping function
14:54:15 <platz> but then again you'd probably need documentation anyway
14:57:15 <henk> I want the current time (getZonedTime from Data.Time.LocalTime) to do some calculations and I’d like it to be "ZonedTime", not "IO ZonedTime". How do I get that Value out? Or what’s the proper way of doing this in haskell?
14:58:27 <HeladoDeBrownie> henk, you don't "get the value out", instead you combine the IO ZonedTime with a computation that can deal with the value. E.g.,
14:58:32 <HeladoDeBrownie> @type (>>=)
14:58:33 <lambdabot> Monad m => m a -> (a -> m b) -> m b
14:58:43 <HeladoDeBrownie> Just substitute m ~ IO there
14:59:17 <hellohaskell> map head . groupBy ((==) `on` null) [".","tbwcm8o2gappn1","vm7orep8wfpxr88","s6","hs","","","2",".."]
14:59:24 <ski> hellohaskell : or just use `time <- getZonedTime' with `do'-notation ..
14:59:27 <ski> er
14:59:29 <vanila> note difference beetween == and &&
14:59:29 <benzrf> are there any traversables in base that arent applicatives
14:59:31 <ski> henk ^
14:59:45 <HeladoDeBrownie> So, in particular, (>>=) :: IO ZonedTime -> (ZonedTime -> IO Whatever) -> IO Whatever
15:00:14 <HeladoDeBrownie> Notice how the function just takes a ZonedTime
15:00:23 <chrisdone> @let (;) = flip (>>)
15:00:24 <lambdabot>  Defined.
15:00:25 <hellohaskell> > map head . groupBy ((&&) `on` null) [".","tbwcm8o2gappn1","vm7orep8wfpxr88","s6","hs","","","2",".."]
15:00:26 <lambdabot>  Couldn't match expected type ‘a -> [[b]]’
15:00:26 <lambdabot>              with actual type ‘[[[GHC.Types.Char]]]’
15:00:37 <ski> henk : do you want to understand, or just use ?
15:00:43 <hellohaskell> > map head . groupBy ((==) `on` null) [".","tbwcm8o2gappn1","vm7orep8wfpxr88","s6","hs","","","2",".."]
15:00:43 <chrisdone> > do return 1; return 2 :: Maybe Int
15:00:44 <lambdabot>  Couldn't match expected type ‘a -> [[b]]’
15:00:44 <lambdabot>              with actual type ‘[[[GHC.Types.Char]]]’
15:00:44 <lambdabot>  can't find file: L.hs
15:00:49 <benzrf> > over id (+1) 34
15:00:50 <lambdabot>  35
15:01:12 <chrisdone> > do return 1; return 2 :: Maybe Int
15:01:13 <lambdabot>  Just 1
15:01:15 <chrisdone> =)
15:02:06 <hellohaskell> vanila: ah, just got it. The first solution looked correct to me, too
15:02:18 <Boreeas> > map head $ groupBy ((==) `on` null) [".","tbwcm8o2gappn1","vm7orep8wfpxr88","s6","hs","","","2",".."]
15:02:19 <lambdabot>  can't find file: L.hs
15:02:32 <henk> HeladoDeBrownie: that would mean that I’d have to make half my code monadic AFAIU /-:
15:02:50 <ski> henk : can you paste the relevant code ?
15:02:57 <henk> ski: understand, but I’ve been trying to understand monads for a while now (;
15:03:01 <ion> henk: fmap yourCalculations getZonedTime
15:04:09 <lpaste> henk pasted “diddohs” at http://lpaste.net/114410
15:05:21 <henk> lines 87-92 are my attempts …
15:07:57 <ski> henk : are `defaultStartDate' and `defaultEndDate' supposed to be the same `ZonedTime' ?
15:09:22 <henk> ski: defaultEndDate will remain the current time. defaultStartDate will get some more sensible logic when I come up with some and when I have defaultEndDate figured out (:
15:12:38 <henk> If that makes any difference: should the program execute that statement and it fails in any way, I want the program to die.
15:13:37 <adamse> is there any way to generate html of haskell source with clickable types and functions (taking you to their definition)
15:13:48 <adamse> kinda like haddocks but always in source
15:14:13 <Frivillig> Can somebody explain to me how nomad solve the problem with side effects or direct me to a site that explain this in a fashion suited to a seven years old kid?
15:14:19 * telser
15:14:24 * telser
15:15:44 <hellohaskell> vanila: I just found out that i don't want to have any of those grouped empty strings. how do i have to modify map head . groupBy ((&&) `on` null)?
15:16:42 <Peaker> Frivillig: There's a lot of confusion around that: Particular types "solve" (or at least help) with side effects, and those types happen to be instances of "Monad" but that is less important
15:16:49 <hellohaskell> so, if there ["Hello", "", "Haskell", "how", "", "", "", "are", "you"] => ["Hello", "", "Haskell", "how", "are", "you"]
15:17:01 <hellohaskell> -if there
15:17:33 <Peaker> Frivillig: For example, the "IO" type helps quarantine code that has IO side-effects. The "State" type specifies a restricted kind of side effects that some other code can have. "State" and "IO" are instances of Monad but that's secondary
15:18:24 <henk> oh, unsafePerformIO sounds like a useful hammer (:
15:18:51 <benzrf> henk: it is ridiculously unuseful
15:19:15 <benzrf> henk: it is about as useful as treating objects as strings in c++
15:19:30 <johnw> it is genuinely useful if you're working with an FFI binding
15:19:39 <johnw> otherwise, there is almost no case where I felt decent using it
15:19:57 <ski> henk : sorry, got a bit distracted
15:20:03 <sinelaw> Frivillig, in other words: side effects require strong ordering (mixing up the effects leads to different results). monads let you put operations in order.
15:20:08 <johnw> you're circumventing the type system, which means you're ignoring what it's telling you
15:20:36 <ski> henk : "defaultEndDate will remain the current time" -- which current time ? the current time at which point in the sequence of I/O operations to perform ?
15:20:59 <johnw> I love current times, there are so many of them :)
15:21:01 <benzrf> sinelaw: monads hardly let you put things in order
15:21:18 <benzrf> sinelaw: monads are just a common interface for things that, among other things, may or may not be put in order
15:21:40 <sinelaw> benzrf, he/she asked for an explanation suitable for a 7 year old
15:21:47 * hackagebot higher-leveldb 0.2.0.0 - A rich monadic API for working with leveldb databases.  http://hackage.haskell.org/package/higher-leveldb-0.2.0.0 (jeremyjh)
15:22:12 <benzrf> sinelaw: there is no such explanation
15:22:35 <henk> benzrf: hm, I don’t know c++, but it certainly sounds like what I need. Thanks for the warning though.
15:22:37 <benzrf> monads are too abstract and general for analogies to really help
15:22:42 <johnw> benzrf: given a >> b >> c, there is a sequence there
15:22:47 <henk> johnw: What’s FFI?
15:22:57 <johnw> the effects will not be executed in the reverse order
15:22:59 <benzrf> johnw: given a <> b <> c, there is a sequence there
15:23:00 <ski> Frivillig : particular monads or applicatives like `IO',`Maybe',`State',`Parser',&c. don't "solve the problem of effects" (though they do solve the problem of *side* effects) -- what they do is encapsulate/insulate the effects from the other parts of the program that aren't interested in these effects (and therefore shouldn't run the risk of accidentally be affected by them)
15:23:03 <johnw> henk: it's the Foreign Function Interface
15:23:09 <benzrf> johnw: but we dont talk about how 'monoids let us order things'
15:23:13 <johnw> benzrf: I think you're confusing evaluation with execution
15:23:23 <henk> johnw: Yes, but IMHO in that situation what it’s telling me doesn’t make much sense …
15:23:27 <benzrf> johnw: am i?
15:23:27 <johnw> benzrf: monadic binds can be evaluated left or right associatively
15:23:33 <benzrf> ok, so?
15:23:34 <johnw> benzrf: but they *must* execute left to right
15:23:41 <benzrf> how do you define execute
15:23:59 <johnw> "instantiating the effect of the Monad" perhaps?
15:24:05 <henk> ski: No problem! Runtime shouldn’t be so long that it really matters and accuracy isn’t important either.
15:24:07 <johnw> as in, IO doing things on the machine
15:24:07 <ski> henk : if you use `unsafePerformIO', then the compiler might perform the side-effect an another time than you expect. and it might even perform it more (or less) times that you expected, as well
15:24:07 <benzrf> monads don't have effects
15:24:13 <benzrf> lots of things with effects are monads
15:24:23 <johnw> benzrf: I don't follow what you mean
15:24:32 <sinelaw> benzrf, given that each bind's second parameter accepts an argument derived from the first, the ordering is strong
15:24:44 <johnw> sinelaw: precisely
15:24:55 <henk> johnw: thanks, but never heard of that either …
15:24:58 <johnw> an ordering that is *not* required by Applicative
15:25:06 <sinelaw> or monoid
15:25:07 <benzrf> sinelaw: that's a property of functors, not monads
15:25:14 <benzrf> sinelaw: i can nest fmap all i like
15:25:23 <benzrf> sinelaw: monads just let me collapse the stack i create
15:25:24 <sinelaw> @type (>>=)
15:25:25 <lambdabot> Monad m => m a -> (a -> m b) -> m b
15:25:27 <dpwright> henk: It's a way to call functions from another language (generally C) from Haskell
15:25:32 <dpwright> or vice versa
15:25:42 <ski> benzrf : the monadic interface itself imposes an order. whether any particular monad cares about that order or not is another thing. compare with rings, in which the multiplication isn't specified to be commutative. for particular rings, it might still be, though
15:25:44 <johnw> benzrf: how is that a property of functors?
15:26:02 <sinelaw> benzrf, fmap does not require passing the result of previous (left) computations to the next( right)
15:26:09 <benzrf> yes it does
15:26:22 <benzrf> @let (<$$>) = flip fmap
15:26:23 <lambdabot>  Defined.
15:26:26 <henk> ski: Getting the current time IMHO shouldn’t have side effects, so I’m just assuming it doesn’t (: And doing it more than once should not be a problem either.
15:26:37 <HeladoDeBrownie> henk, sorry I didn't reply, I had to handle something. Anyway, you can perfectly well write pure functions (e.g., ZonedTime -> SomeResult) and simply lift them to IO using things like the already mentioned fmap. Thus you don't need to go and change all your code to be "monadic"
15:26:40 <henk> dpwright: ah, I understand that, thank you very much
15:26:41 <benzrf> foo <$$> bar <$$> fmap baz <$$> fmap (fmap quux)
15:26:46 <benzrf> ^same 'ordering'
15:26:52 <benzrf> the difference is only in the type of the result
15:27:06 <johnw> benzrf: that does not involve multiple actions in the monad
15:27:12 <benzrf> johnw: what?
15:27:25 <johnw> benzrf: you can fmap a 1000 times on an IO action, but it's still just one action
15:27:36 <benzrf> assume bar, baz, and quux are kleisli arrows
15:27:43 <johnw> then you can't pass them to fmap
15:27:44 <benzrf> well, they need to be for the types to work
15:27:49 <benzrf> johnw: um, yes i can
15:27:51 <johnw> fmap takes function a -> b
15:27:53 <johnw> not a -> m b
15:28:00 <benzrf> johnw: seriously?
15:28:03 <johnw> :t fmap
15:28:04 <lambdabot> Functor f => (a -> b) -> f a -> f b
15:28:15 <benzrf> > fmap Just (Just 3)
15:28:17 <lambdabot>  Just (Just 3)
15:28:21 <benzrf> that looks like fmapping a kleisli arrow to me
15:28:42 <johnw> I feel like you're not listening to what we're saying, benzrf, so I'm going to stop now
15:28:46 <dpwright> henk: the phrase "side effect" is a little bit misleading -- it covers things that affect the state of the world, but also things that are *affected by* the state of the world
15:29:23 <benzrf> johnw: there is no notion of exeuction that is fundamental to monads
15:29:38 <benzrf> johnw: if you just mean that monadic join is not necessarily commutative
15:29:43 <benzrf> johnw: well, that's true of lots of things
15:29:50 <dpwright> a rough yardstick of "side effect" is "does this function always return the same result given the same input?"
15:29:51 <henk> HeladoDeBrownie: sure, no problem and thanks for the reply (:
15:29:52 <johnw> neither of those two statements has anyhting to do with our discussion
15:29:52 <benzrf> and people do not say that those things "allow them to have ordering"
15:29:55 <ski> henk : getting the current time is obviously a side-effect, since doing it twice isn't the same as doing it once and reusing the value (or doing it twice and swapping around the values)
15:30:05 <dpwright> in the case of the current time, it clearly doesn't
15:30:10 <benzrf> johnw: then i don't know what we're discussing
15:30:25 <henk> dpwright: good point, thanks
15:31:03 <ski> henk : iow, if we assume that `currentTime' somehow magically gave use the current time, then `let a = currentTime in let b = currentTime in (a,b)' would be different from `let a = currentTime in (a,a)' would be different from `let a = currentTime in let b = currentTime in (b,a)'
15:31:13 <henk> Seems like I’ll just do it as intended after all. Seems like the path of least resistance … Thanks everyone
15:31:39 <ski> henk : but simple algebra / equational reasoning tells us that these three expressions ought to be equal. ergo, `currentTime' must have side-effects
15:32:35 <ski> (henk : however, an *action* `getCurrentTime :: IO Time' would be ok, since it doesn't *evaluate* to the current time. it doesn't break equational reasoning, like the above hypothetical `currentTime' would)
15:33:03 <johnw> I will concede that monads are not "about" sequencing
15:33:16 <johnw> can you explain, in types, your connection of fmap to Kleisli ?
15:34:04 <henk> ski: that sounds reasonable, thanks for the explanation (:
15:34:34 <ski> henk : btw, if you have `let x = someExpression in ..x..x..', then that ought to be equal to `..(someExpression)..(someExpression)..' -- but this kind of reasoning, all of the three above expressions are equal to `(currentTime,currentTime)', hence they must be equal. since the behaviour you (presumabnly) propose is that they should be different, the conclusion is that `currentTime' must then have *side*-effects
15:35:48 <ski> henk : and Haskell bans *side*-effects (*effects* on their own is fine. iow, when you have isolated them, and *explicitly* accounted for them, they're fine. the problem is the "happening on the *side*, as a side-effect of the main computation, while not appearing in the interface (i.e. type)")
15:35:50 <johnw> https://www.haskell.org/haskellwiki/What_a_Monad_is_not#Monads_are_not_about_ordering.2Fsequencing is highly relevant to our discussion
15:36:46 <ski> henk : so, the reason why `getZonedTime :: IO ZonedTime' is ok is because it *explicitly* accounts for the dependence on ordering, on *when* the computation is performed, by *explicitly* listing `IO' in its type
15:38:39 <ski> johnw : btw, i'd claim that `do z <- [0 .. 9]; y <- [0 .. z]; x <- [0 .. x]; guard (x^2 + y^2 == z^2); return (x,y,z)' expresses ordering/sequencing
15:38:53 <johnw> oh sure
15:39:03 <chrisdone> > do return 1; return 2 :: Maybe Int -- johnw, definitely not about sequencing =p
15:39:04 <lambdabot>  Just 1
15:39:07 <ski> johnw : an ordering of a more abstract nature than a plain "nested-looping" ordering
15:39:27 <johnw> that web page really says it all better than I have been
15:40:02 <johnw> > do { return 1; return 2 } :: Maybe Int
15:40:03 <lambdabot>  Just 2
15:40:35 <ski> johnw : similarly, i'd say that collapsing `m (m (m (..(m (m a))..)))' into `m a' also inherently is about ordering (the ordering of the different parts of the input represented by the various `m' in theeir sequence)
15:41:31 <johnw> ski: I would say that monads allow one to encode sequencing, but are they "about" sequencing?  The Reader monad example in that link is compelling, since sequence has nothing to do with Reader
15:42:01 <johnw> and with m (m (m a)), I can merge m's one of two ways, and I'm free to choose which
15:42:09 <ski> johnw : that for some monads, this ordering turns out not to matter, is beside the point. a product `a * b * c * d * e' in a ring (*not* assumed to be commutative) is still ordered, regardless of whether the ring *happens* to be commutative or not
15:42:47 <johnw> ski: I think I am in whole-hearted agree with you, I'm just wondering why other people (like Stephen Diehl) make such a point of monads "not being about order/sequencing"
15:43:04 <ski> the `Reader'/environment monad here is akin to a ring that just happens to be commutative
15:43:07 <johnw> and I've found other authors write about how they're all about sequencing
15:43:22 <ski> if you're restricting your attention to only commutative rings, the matter is different
15:43:30 <mauris> (is Reader a ring?)
15:43:33 <johnw> all I know is that with f <*> x, I can process either f or x first; but with m >>= f, I have to process m first
15:43:58 <johnw> that is, whatever "monadic action" is returned by f, is dependent on the value "produced" by m
15:44:09 <johnw> and that to me says sequencing
15:44:14 <ski> so, it depends not only on the "substance" (the particular ring/monad) that you're considering, but also which *properties* of it that you're taking into account
15:44:32 <johnw> i've never heard people liken monads to rings before, that's interesting
15:44:58 <ski> never heard "a monad is just a monoid in the category of endofunctors" ?
15:45:01 <LunarJetman> monads, monads, monads. always with the bloody monads.
15:45:03 <johnw> sure
15:45:15 <mauris> i don't get the ring analogy. what's addition? 0? 1?
15:45:17 <ski> how about "a ring is just a monoid in the category of abelian groups" ?
15:45:29 <johnw> no, hadn't heard that one
15:45:30 <mrenaud__> Hey, quick question. If I do sortBy (comparing snd) it sorts them with (<), what's the best way to do (>)? sortBy (flip (comparing . snd))?
15:45:40 <mauris> whoa me neither
15:45:52 <mauris> in Ab arrows are group homomorphisms right
15:46:01 <ski> yes
15:46:12 <johnw> so, some monads are monoids in the category of endofunctors on groupoids?
15:46:28 <nshepperd> mrenaud__: comparing (Down . snd)
15:46:42 <johnw> (and abelian at that?)
15:46:47 <nshepperd> or flip, I guess that works too
15:46:47 <ski> and `(*)' being a group homomorphism (from a tensor abelian group) expresses exactly the distributive laws of the ring
15:46:56 <johnw> very cool, ski, thanks
15:47:19 <mauris> wow!
15:47:47 <mauris> i see the similarity between the distributive law and homomorphisms but i should work it out on paper, i guess
15:47:52 <mauris> what's a "tensor" abelian group?
15:47:57 <mrenaud__> nshepperd: thanks, Down is more clear
15:48:14 <ski> johnw : "I'm just wondering why other people ... make such a point of monads \"not being about order/sequencing\"" -- i think the intent is to steer away from *operational/procedural* ordering (when what is evaluated), which is *good* !
15:48:28 <ski> johnw : however, there are still more abstract kinds of ordering
15:48:52 <sinelaw> ski, but it really has nothing to do with operational ordering
15:48:56 <sinelaw> @type (>>=)
15:48:57 <lambdabot> Monad m => m a -> (a -> m b) -> m b
15:49:19 <SrPx> can functions be cool? if they can, this is certainly the coolest:
15:49:20 <johnw> ski: what you've said is spelled out here too: http://ncatlab.org/nlab/show/distributive+law
15:49:20 <SrPx> > data Tree = Node Tree Tree | Leaf Int deriving Show; binTree x 0 = Leaf x; binTree x i = Node (binTree (x*2) (i-1)) (binTree (x*2+1) (i-1)); main = print (binTree 0 3)
15:49:21 <lambdabot>  <hint>:1:1: parse error on input ‘data’
15:49:30 <SrPx> lambdabot: I love you too !
15:49:32 <johnw> "Abstractly, there are two monads on the category Set, one (call it T) whose algebras are abelian groups, and one (call it S) whose algebras are monoids"
15:49:44 <ski> mauris : no, `Reader rho' is a monad, not a ring -- to be a ring, the endofunctor category would have to only have isomorphisms, i suppose ... hmmm
15:50:24 <ski> johnw : the case with applicative/idiomatic `f <*> x' is somewhat different, but the basic picture is more or less the same
15:51:31 <dpwright> I'd like to build a GHC cross-compiler for a platform for which the only C compiler I have available is clang (no gcc).  In https://ghc.haskell.org/trac/ghc/wiki/Building/CrossCompiling parlance, "build" and "host" are both Windows (I have gcc/mingw on Windows), and "target" is the platform I'm working with (using clang)
15:51:35 <dpwright> should this be possible?
15:52:21 <ski> johnw : in that case we have (rephrasing slightly) `unit :: () -> i ()' and `zip :: (i a,i b) -> i (a,b)' .. so here the ordering is the ordering of the bifunctor `(,)', not the ordering of the functor composition `(.)' in `(m . m . m . ... . m . m) a'
15:53:10 <johnw> ski: I would love it if you blogged this subject, so I could pour over it a few times in detail, maybe with some proofs to work as exercises
15:53:24 <ski> johnw : "some monads are monoids in the category of endofunctors on groupoids" -- strike "on groupoids"
15:53:40 <johnw> ah, ok
15:53:49 <athan> If I'm parsing a string into an AST with a state monad, all the plumbing like partially constructed ASTs, leftovers, and errors should be the state "s" type, while the result type "a" would be negligible, correct? Something like ()?
15:54:05 <johnw> athan: if so, then why use State?
15:54:17 <athan> johnw: I don't know yet :P
15:54:19 <johnw> State s () is pretty much the same thing as s
15:54:26 <athan> derp
15:54:29 <athan> thanks hahaha
15:54:41 <ski> @tell sinelaw "but it [monadic or applicative sequencing] really has nothing to do with operational ordering" -- i agree, which is why i understand why people say "monads aren't about sequencing". but this ignores the other kinds of ordering present
15:54:41 <lambdabot> Consider it noted.
15:54:44 <trap_exit> this is fucking annoying
15:54:54 <johnw> unless you have *lots* of intermediate functions that produce intermediate working values (of type State s a), *and* which don't care about s at all
15:54:58 <trap_exit> the greatest limitation to me programming in ahskll right now is some dumbass's alarmclock
15:55:08 <trap_exit> beep beep beep [pause]
15:55:12 <trap_exit> beep beep beep
15:55:23 <johnw> in that case, State s () can be a convenience
15:55:55 <ski> athan : usually the (various) AST types would be in the `a' part of `State s a' or `StateT s m a'
15:55:57 <johnw> also, State s () is the same as s -> s, sorry
15:56:29 <athan> johnw: makes sense, I just don't have the wisdom yet :P
15:56:42 <trap_exit> no, it's more like s -> ((), s)
15:56:42 <ski> johnw : hehe, i've yet to succumb to the buggery of blaggery ;)
15:56:48 <johnw> it could help to start building the parser without monads at all, just as regular pure functions
15:56:58 <johnw> ski: well, you have things to say that I would value having in print
15:57:03 <mauris> ((), s) is isomorphic to s
15:57:28 <johnw> ((), s) is the algebraic equivalence to 1 * s, which, like in algebra, equals s
15:57:45 <athan> ski: my route is to use `forever` and on each step, try and add more to the AST. I'm not sure if I can build the AST purely from each step, it's somewhat contextual
15:57:50 <trap_exit> in the same way
15:57:58 <johnw> the "type equivalent" (got that backwards)
15:57:58 <athan> johnw: Hmm, I'll give it a go
15:58:08 <trap_exit> the most intelligent human is isomorphic to an idiot who can only utter 'baa' and 'gaa'
15:58:23 <ski> johnw : also, i think part of it is half-formed, or not that explicitly realized, and only comes out as a response to conversation
15:58:51 <johnw> athan: when you find a commonly recurring pattern about the functions that begins to annoy you, that's usually when I ask, "Hmm.. will some construct (like Monad) help to abstract this pattern"?  The point of the abstraction is not just convenience, but can also be safer
15:58:58 <johnw> ski: I hear you there
15:59:05 <ski> (and obviously (well hopefully) such conversation sharpen my understanding, and my understanding of how to explain it)
15:59:20 <johnw> trap_exit: isomorphic in what category though?
15:59:24 * athan shrugs
15:59:27 <athan> thanks guys :)
15:59:27 <johnw> trap_exit: to aliens who eat humans, sure :)
15:59:58 <ski> johnw : basically. i've a long time felt a nagging discomfort with "monads aren't about ordering/sequencing", but i've also long struggled to explicate what's wrong with it
16:00:08 <athan> johnw++
16:00:11 <athan> ski++
16:00:20 <johnw> athan: it good to go through the exercise of hitting the wall that lets you know you really do need some particular monad or another
16:00:31 <athan> everyone gets karma!! -oprah
16:00:33 <ski> (the same is true for various other topics. though of course sometimes it's my understanding which is impaired, misled, or plain wrong)
16:00:49 <johnw> ski: it felt a bit wrong to me as well, since there are many excellent presentations (like Marlow's on Haxl), where a key reason for his use of Monads was to express ordering/sequence
16:01:06 <athan> johnw: I'm loving it haha. I'm trying to parse really trivial ML-style type signatures
16:01:16 <athan> I only have Unit and polymorphic terms right now
16:01:28 <johnw> athan: are you using a parsing library, or just parsing strings manually?
16:01:32 <chrisdone> there's also the problem that "X are about" is the canonical starting phrasing of imminent oversimplification
16:01:40 <johnw> chrisdone++
16:01:42 <athan> manually, I don't think there's a need for attoparsec or anything right now
16:01:53 <johnw> athan: you should ask Cale to give you his parsing spiel sometime
16:02:03 <johnw> athan: might be highly apropos for where you're at
16:02:03 <ski> johnw : part of the problem may also be that some people refuse to say list monad computations (or continuation monad computations) are ordered in the way i intended above
16:02:35 <johnw> right!  Cont is basically the essence of sequencing, isn't it
16:02:39 <athan> johnw: Hmm, alright I'll ask him when I get the chance! Thanks :)
16:03:07 <Tekmo_> Functors are basically the essence of functoring
16:03:32 <johnw> @tell Cale athan would love to walk through building up a parsing library with you, as he's writing parsing using normal functions right now and was wondering how monads could improve things
16:03:32 <lambdabot> Consider it noted.
16:03:43 <ski> i've heard "list monad" mentioned as a counterexample to "monads (and specifically ordering in `do' or of `(>>=)' ( or more abstractly, of `join')) are about ordering/sequencing" (since "obviously the order in `do' doesn't correspond to the evaluation order")
16:04:23 <ski> johnw : `Cont' is more or less the essence of *control* (in the sense of controlling the thread of computation)
16:04:26 <vanila> @src Cont >>=
16:04:26 <lambdabot> Source not found. That's something I cannot allow to happen.
16:04:28 <johnw> Tekmo_: !!!
16:04:30 <Tekmo_> My favorite monad counter examples are list and free
16:04:34 <Tekmo_> johnw: !!!
16:04:46 <johnw> Tekmo_: I've been playing more with formalizing your Proxy type, and making a bit of headway
16:04:55 <johnw> Tekmo_: I need next to really understand this "functors as containers" approach
16:04:57 <ski> @src Cont (>>=)
16:04:57 <lambdabot> m >>= k = Cont $ \c -> runCont m $ \a -> runCont (k a) c
16:05:03 <ski> vanila : ^ there you go
16:05:27 <Tekmo_> I think when people say "functors are containers" they mean that they "contain" type parameters, not that they are collections
16:05:37 <vanila> @src Cont
16:05:37 <lambdabot> newtype Cont r a = Cont { runCont :: (a -> r) -> r }
16:05:51 <johnw> I mean in the forall a : A, B a -> Free, sense
16:06:00 <vanila> so basically   m >>= k = \c -> m (\a -> (k a) c)
16:06:05 <johnw> Tekmo_: https://github.com/jwiegley/notes/blob/master/Pipes.v
16:06:19 <athan> > fix johnw++
16:06:20 <lambdabot>  <hint>:1:12:
16:06:20 <lambdabot>      parse error (possibly incorrect indentation or mismatched brackets)
16:06:21 <ski> johnw : so, instead i just generalize the meaning of "ordering" to apply to all monads
16:06:23 <johnw> ProxyF abstracts the functoral component of your Proxy type, so that Proxy is just the free monad over ProxyF
16:06:45 <johnw> now I need to define the functor-as-container that represents ProxyF, so that I can demonstrate to Coq that such a free monad construction is strictly positive
16:06:58 <ski> Tekmo_ : or you can generalize the meaning of "collection" to include all functors ! ;)
16:07:03 <ski> (which is what i prefer to do)
16:07:13 <Tekmo_> ski: That's a good approach, too :)
16:07:57 <torpet> I am coding my homework, and there is this one emphasized word. A tuple is _invalid_ if its denominator is 0
16:08:09 <torpet> Can i somehow raise a message or something when that happens?
16:08:33 <johnw> Tekmo_: https://github.com/jwiegley/notes/blob/master/agda-free-monad-trick.md is still the most succinct resource I have, but I don't yet see how to connect the end of his description to ProxyF
16:08:33 <mauris> f (x, 0) = error "everything exploded!"
16:08:38 <Tekmo_> torpet: Do you mean that a tuple represents some sort of fraction?
16:08:45 <torpet> Yeah
16:08:51 <torpet> and the denom isn't allowed to be 0
16:08:51 <HeladoDeBrownie> torpet, do you want to be able to handle the error?
16:09:05 <torpet> Well I'm not sure the tasks are that advanced
16:09:12 <HeladoDeBrownie> torpet, just use error then I guess
16:09:14 <HeladoDeBrownie> @type error
16:09:15 <lambdabot> [Char] -> a
16:09:26 <HeladoDeBrownie> > error "This is an error."
16:09:26 <Tekmo_> johnw: Did I ever show you the Agda implementation of `pipes` that Paolo wrote up?
16:09:27 <lambdabot>  *Exception: This is an error.
16:09:36 <johnw> Tekmo_: no!  that would help a _lot_
16:09:45 <Tekmo_> johnw: It's just the unidirectional pipes, but let me pull it up
16:09:48 <johnw> agda's stdlib apparently has containerish functors in it
16:09:51 <ski> torpet : if you can, i think it would be preferred simply to make sure you never construct such a tuple (and make sure any user of your module can't construct it, using your exported operations)
16:10:23 <Tekmo_> johnw: Here: http://lpaste.net/95393
16:10:26 <johnw> Tekmo_: or maybe you did, but I forgot about it; thanks
16:10:34 <torpet> ski: Yeah that sounds right.
16:10:47 <Tekmo_> johnw: You're welcome!
16:11:33 <ski> torpet : to make to watertight, you need to define a new data type, and then not export the data constructor(s) of it
16:11:50 <ski> s/make to/make it/
16:12:09 <johnw> Tekmo_: oh, and little reminder about https://github.com/Gabriel439/Haskell-Pipes-Library/issues/126 :)
16:12:17 <HeladoDeBrownie> ski, the teacher is likely expecting a dumber solution than that
16:12:20 <Tekmo_> johnw: Yeah, I will get to that!
16:12:34 <Tekmo_> johnw: Right now I'm focusing on completing a Haskell project for work.  That's why I've been really quiet lately
16:12:37 <johnw> cool, I'd like to switch my focus to pipes and this would eb a good impetus
16:12:51 <johnw> ah, understandable
16:13:07 <johnw> I've been snowed under lately as well
16:13:42 <bitemyapp> Tekmo_: MAKE IT PERFECT
16:13:45 <bitemyapp> Tekmo_: No pressure!
16:13:47 <Tekmo_> bitemyapp: It will be
16:13:57 <carter> @tell yuras well, thats why i suggested letting it bake more before sharing
16:13:57 <lambdabot> Consider it noted.
16:14:04 <bitemyapp> Tekmo_: btw: http://haskellbook.com/
16:14:09 <Tekmo_> bitemyapp: It's basically a Haskell rewrite of thousands of lines of Python code
16:14:24 <johnw> sounds like fun
16:14:25 <Tekmo_> Nice
16:14:27 <bitemyapp> Tekmo_: so, what, like 50 lines of >=> and >>= right?
16:14:30 <bitemyapp> ezpz
16:14:34 <Tekmo_> bitemyapp: Basically :)
16:14:47 <bitemyapp> Also I'm #2 for trending Haskell repos for the weekly and monthly views.
16:15:05 <bitemyapp> John MacFarlane has #1 for both, damn him and his pandoc :)
16:15:29 <bitemyapp> incidentally, *not* for the guide. Github doesn't consider that Haskell code.
16:15:53 <mauris> i have a project i WANT to make that's: rewriting thousands of lines of Perl into haskell
16:15:59 <Tekmo_> I'm completing the first smoke test of the rewrite right now
16:16:00 <carter> bitemyapp: the CSS is off
16:16:07 <carter> the hakyll thing is inthe middle
16:16:10 <johnw> I see hledger as the #1 trending repo...
16:16:10 <mauris> it's sad because the fun part is writing haskell but the sad part is reading perl :(
16:16:10 <bitemyapp> Tekmo_: awesome.
16:16:14 <bitemyapp> carter: wfm?
16:16:18 <bitemyapp> let me try in a diff browser
16:16:21 <carter> bitemyapp: chrome
16:16:28 <bitemyapp> carter: wfm in firefox and chrome.
16:16:37 <bitemyapp> Tekmo_: did haskellbook.com look janky to you?
16:16:42 <bitemyapp> carter: nobody else has said anything.
16:16:44 <mauris> bitemyapp: try a tiny window
16:16:44 <Tekmo_> No, it looked fine
16:17:03 <carter> yeah, tiny windows
16:17:07 <carter> http://imgur.com/WRzyoAW
16:17:09 <bitemyapp> carter: oh I se.
16:17:11 <bitemyapp> oh I see*
16:17:19 <bitemyapp> I know how to fix this. I had something else to push.
16:17:25 <bitemyapp> I was a dummy and used absolute positioning. Bad me.
16:17:34 <carter> bitemyapp: whats the repo you have thats trending?
16:17:39 <bitemyapp> carter: Bloodhound
16:17:44 <carter> wat
16:17:48 <bitemyapp> I dunno.
16:17:55 <bitemyapp> I was surprised too.
16:18:07 <bitemyapp> I figured Haskell && Elasticsearch would be a small crowd.
16:18:35 <carter> bitemyapp: is that by stars or foks?
16:18:42 <carter> idk, FTS is a pretty common app dev need
16:18:45 <bitemyapp> prolly both. I don't know how they calculate.
16:18:48 <bitemyapp> carter: it is.
16:19:59 <bitemyapp> carter: good catch, thanks.
16:20:01 <carter> huh, 150 stars
16:20:04 <carter> np
16:20:24 <johnw> i think trending is targeting some of our preferences
16:20:26 <johnw> my #2 is linear
16:20:37 <Tekmo_> My #2 is an empty repository -.-
16:20:45 <johnw> how zen of you
16:20:45 <carter> lol
16:20:58 <johnw> 'I would have made this program smaller, but I ran out of time'
16:21:03 <Tekmo_> Haha
16:21:08 <carter> bitemyapp: johnw: i've got sweet offers on the table, my oss stuff will be shipping soon
16:21:26 <bitemyapp> carter: excellent. :)
16:21:53 <bitemyapp> my #3 repo is a Clojure database client.
16:22:01 <bitemyapp> #4 is a Clojure database migration library that nobody uses
16:22:04 <bitemyapp> #5 is my dotfiles
16:22:57 <Tekmo_> bitemyapp: Here's a good opportunity for you to teach sandboxes: http://www.reddit.com/r/haskell/comments/2mi15m/how_do_i_build_a_library_locally/
16:24:48 <johnw> carter: congrats!
16:24:53 <bitemyapp> Tekmo_: I have a howistart.org article getting released probably tomorrow.
16:24:59 <bitemyapp> Tekmo_: it has sandbox stuff in there. What timing.
16:25:10 <bitemyapp> looks like somebody already recommended sandboxes.
16:29:13 <ski> @tell mauris "<mauris> what's a \"tensor\" abelian group?" -- take two abelian groups ⌜A⌝ and ⌜B⌝. construct ⌜C = A × B⌝ (cartesian product set) and define the group operations pointwise. now form a quotient of ⌜C⌝ forcing ⌜∀ a : A , b₀,b₁ : B. (a,b₀) + (a,b₁) = (a,b₀ + b₁)⌝,⌜∀ a₀,a₁ : A , b : B. (a₀,b) + (a₁,b) = (a₀ + a₁,b)⌝ and ⌜∀ n : ℤ , a : A , b : B. (n · a,b) = n · (a,b) = (a,n · b)
16:29:13 <lambdabot> Consider it noted.
16:29:25 <ski> @tell mauris .. this causes some pairs to be identified. the resulting quotient on ⌜C⌝ is ⌜A ⊗ B⌝, the tensor product of ⌜A⌝ and ⌜B⌝
16:29:25 <lambdabot> Consider it noted.
16:29:28 <bitemyapp> carter: should be fixed now.
16:29:42 <carter> yup
16:29:47 <bitemyapp> sweet.
16:31:04 <ski> @tell mauris if you are wondering what a quotient is here (or anything else), perhaps we could discuss it later. .. possibly i shouldn't try to cram a noninteractive explanation of it into `@tell' :)
16:31:04 <lambdabot> Consider it noted.
16:33:53 <ski> @tell mauris oh, i should add that the above quotient essentially forces the passage from (pairs in) ⌜C⌝ to (pairs-with-extra-identification in) ⌜A ⊗ B⌝ to be a *bilinear* map. that's the whole point of it, forcing the distributive laws, and the "associative law where one of the factors is an integer"
16:33:53 <lambdabot> Consider it noted.
16:35:03 <ski> @tell mauris .. and, now that i think of it, that last property can be proved from the other two (because we're talking about integers. if we generalize from integers ⌜ℤ⌝ to some possibly other ⌜Z⌝, we still need the last property)
16:35:03 <lambdabot> Consider it noted.
16:36:55 <ski> HeladoDeBrownie : possibly
16:36:58 <jlg123> I am trying to write some basic concurrency algorithms using IORefs, but it seems like I would have to use atomicModifyIORef to get predictable results given the reordering that can take place otherwise. Is that true?
16:37:29 <ski> yes
16:37:53 <Tekmo_> jlg123: Are you familiar with STM?
16:38:06 <ski> `MVar's are better. `STM' even better
16:38:23 <jlg123> Tekmo_: Not really.
16:38:37 <jlg123> I am currently just trying to get as close an implementation to some classic concurrency papers
16:39:01 <ski> `atomicModifyIORef' works and is safe, but doesn't compose
16:39:15 <Tekmo_> jlg123: I recommend reading this, then: https://www.fpcomplete.com/school/advanced-haskell/beautiful-concurrency
16:39:20 <ski> otherwise modifying `IORef' in a concurrent context isn't safe, afaicr
16:39:29 <Tekmo_> jlg123: It explains how to use software-transactional memory and also motivates why you'd want to use it
16:39:32 <ski> using `MVar's is safe, but also doesn't compose
16:39:46 <Tekmo_> jlg123: Software-transactional memory (STM) greatly simplifies concurrent programming
16:41:05 <jlg123> Tekmo_: I will look into it, thanks
16:41:42 <Tekmo_> jlg123: You're welcome!
16:43:37 <meretrix> When using the Interactive-Haskell emacs mode, how can I load a hidden module without having to add it to my cabal file?
16:43:59 <meretrix> (When using the REPL.)
16:46:48 * hackagebot haskell-neo4j-client 0.3.0.9 - A Haskell neo4j client  http://hackage.haskell.org/package/haskell-neo4j-client-0.3.0.9 (asilvestre)
16:47:04 <batchm> what makes SMT simpler and safer than MVar's?
16:47:42 <Axman6> STM?
16:47:58 <batchm> yes STM
16:48:01 <Axman6> it allows you to modify several variables at once in an atomic way
16:48:37 <Axman6> so you can read var A, B and C, and set B and C to a+b and C to a*c, in a single transaction
16:48:49 <Axman6> s/ and C//
16:50:00 <Tekmo_> batchm: It's easy to combine multiple atomic transactions into a new atomic transactions
16:50:07 <batchm> if you have just one variable then you can chose either?
16:50:14 <batchm> choose
16:50:34 <Tekmo_> batchm: This gives a good explanation of the issue: https://www.fpcomplete.com/school/advanced-haskell/beautiful-concurrency/2-a-simple-example-bank-accounts
16:55:24 <batchm> thanks i will take a look
16:56:53 <Axman6> batchm: possibly; MVars are good if you need to wait for data to be made available. STM is useful when you need atomic transactions, IORefs can also often be useful in concurrent situations if you only have a single piece of data to store (but a single piece of data might be an while immutable structure like a list of Map)
16:57:15 <dmj`> meretrix: depends how its configured, are you invoking the repl with 'cabal repl' or 'ghci' commands? I'd assume ghci would let you load the hidden module, not so cabal repl
17:00:05 <ski> @type Data.IORef.atomicModifyIORef
17:00:06 <lambdabot> GHC.IORef.IORef a -> (a -> (a, b)) -> IO b
17:02:30 <batchm> I liked that bank account example
17:06:06 <harlanhaskins> :t takeWhile
17:06:07 <lambdabot> (a -> Bool) -> [a] -> [a]
17:06:29 <harlanhaskins> :t return
17:06:30 <lambdabot> Monad m => a -> m a
17:06:41 <harlanhaskins> :t cycle
17:06:42 <lambdabot> [a] -> [a]
17:06:48 <harlanhaskins> :t zipWith
17:06:49 <lambdabot> (a -> b -> c) -> [a] -> [b] -> [c]
17:07:05 <harlanhaskins> Sorry, just demonstrating lambdabot
17:10:56 <ski> well, there wasn't much happening, anyway, and it wasn't excessive
17:19:41 <batchm> so STM guarantees atomic reads and writes at compile time?
17:20:33 <merijn> batchm: That question doesn't make a lot of sense
17:20:40 <batchm> hmm
17:20:58 <batchm> it made sense when I imagined it in my head :P
17:21:06 <merijn> batchm: STM guarantees that IF a transaction finishes THEN it will happen as if it was atomic
17:21:16 <batchm> ah yes, it can fail
17:21:34 <batchm> and it will keep trying the transaction until it is succesful
17:21:40 <batchm> ?
17:21:48 * hackagebot hailgun 0.3.0.0 - Mailgun REST api interface for Haskell.  http://hackage.haskell.org/package/hailgun-0.3.0.0 (RobertMassaioli)
17:22:02 <merijn> There can be multiple transactions at once, but the succesfull ones will not have been interfered with
17:22:30 <batchm> what if it fails? do you have to manually restart it?
17:22:31 <merijn> batchm: If it fails it will retry, yes. But you can compose transactions using "orElse :: STM a -> STM a -> STM a"
17:22:51 <batchm> are deadlocks impossible with STM?
17:22:58 <merijn> That will first try the first STM action, if the first one fails it'll try the second, if the second one fails they entire thing will retry
17:23:24 <merijn> I'm not sure STM is sufficient to guarantee deadlock freeness
17:23:41 <fryguybob> batchm: STM is about two things: allows you to specify the atomicity rather then how that atomicity is achieved and it is implemented using speculation so that non-conflicting transactions can proceed without interference.
17:26:29 <fryguybob> batchm: Haskell STM additionally allows for rich composition of transactions including blocking with the `retry` primitive and with `orElse` for atomically choosing between alternatives.
17:26:48 * hackagebot egison 3.3.14 - Programming language with non-linear pattern-matching against unfree data  http://hackage.haskell.org/package/egison-3.3.14 (SatoshiEgi)
17:28:56 <batchm> thanks.. I guess I will have to try them in practice to fully grook them. but they seem very interesting
17:30:02 <fryguybob> batchm: When you say "what if it fails?" what sort of failure are you wondering about.
17:30:05 <Krikey_sanchez> I type "cabal sandbox init"
17:30:06 <batchm> it is scary how many potential pitfalls there are when trying to combine *safe* withdraw and deposit functios to a safe transfer function
17:30:09 <Krikey_sanchez> and then I type cabal list --installed
17:30:12 <batchm> when using locks
17:30:14 <Krikey_sanchez> in that sandbox
17:30:16 <Krikey_sanchez> and there is output to it
17:30:18 <Krikey_sanchez> WHY IS THAT?
17:31:50 <Krikey_sanchez> the broader problem is that I've created a sandbox and am trying to install elm
17:31:51 <batchm> fryguybob failure to commit, I guess
17:32:05 <Krikey_sanchez> and it says that there are packages likely to be broken by the reinstalls
17:32:18 <Krikey_sanchez> that seem to have nothing to do with elm, and so shouldn't even be visible within that sandbox
17:33:30 <fryguybob> batchm: A failure to commit happens when a conflict is detected (noticing that the expected value of a TVar has changed in the implementation).  This is where the speculation come is.  The implementation can safely just start the transaction again from the beginning.  It does so automatically.
17:35:18 <batchm> fryguybob it does that until it succeeds, by default?
17:36:02 <fryguybob> batchm: Yes, though the thread is still subject to the schedular choosing to run it.
17:36:25 <fryguybob> batchm: And that is not just by default, that is what always happens.
17:39:04 <fryguybob> (with the current implementation at least)
17:40:15 <fryguybob> batchm: But typically a failure to commit implies the successful commit of some other transaction in the system, implying that something is making progress.
17:40:34 <batchm> yes
17:40:54 <fryguybob> There is a narrow window where this is not true in the Haskell STM, but it is not easy to trigger in any practical setting.
17:41:48 * hackagebot hailgun-send 0.1.1.0 - A program to send emails throught the Mailgun api.  http://hackage.haskell.org/package/hailgun-send-0.1.1.0 (RobertMassaioli)
17:43:47 <mrenaud__> Question regarding where blocks in the Reader monad. If I have val <- ask in a do block, how can I use that value in a where block of the monadic function?
17:44:31 <batchm> I see how haskell's type system fits neatly into all of this too.. we are guaranteed at compile time that STM doesn't have any effects that can't be reverted back
17:45:13 <merijn> mrenaud__: You can't, use let
17:45:29 <fryguybob> batchm: Right
17:45:49 <fryguybob> batchm: And you are free to bring in pure computations
17:47:23 <mrenaud__> merijn: Small example?
17:47:49 <mrenaud__> I want the equivalent of do {i <- ask; return f} where f = 2*i
17:48:10 <mrenaud__> I'm not sure how to do that using let :/
17:48:15 <merijn> mrenaud__: "do { i <- ask; let f = 2*i; return f"
17:48:26 <merijn> eh, plus a } at the end
17:48:43 <mrenaud__> Ahh, that makes sense, silly me :P Thanks ):
17:48:44 <mrenaud__> :)*
17:48:51 <merijn> @undo do { i <- ask; let f = 2*i; return f }
17:48:51 <lambdabot> <unknown>.hs: 1: 38:Parse error: }
17:48:55 <geekosaur> if you're doing it on one line like that, it needs mor braces because the let introduces layout
17:48:58 <merijn> hmmm
17:49:08 <merijn> oh, duh
17:49:10 <geekosaur> @undo do { i <- ask; let { f = 2 * i }; return f }
17:49:10 <lambdabot> ask >>= \ i -> let { f = 2 * i} in return f
17:50:29 <exio4> I would use "fmap (\i → 2 * i) ask" in that case
17:50:48 <exio4> fmap/liftM
17:51:53 <merijn> I'm assuming 'f' is substantially more complicated in his real scenario :)
17:55:03 <torpet> http://lpaste.net/4897585253834555392
17:55:07 <torpet> why does map not work in this case?
17:55:12 <torpet> and how could i solve this problem i have?
17:56:39 <P4Titan> Hello all, is there someway when I import a module, it also imports all of the modules that it imported
17:56:54 <merijn> torpet: You forgot to past the error, also you should split this up into a few local definitions
17:57:11 <merijn> P4Titan: Depends, is it your code?
17:57:14 <dmj`> P4Titan: if you export the modules you imported yes
17:57:18 <merijn> P4Titan: You can reexport entire modules
17:57:26 <P4Titan> It is my code
17:57:27 <torpet> merijn: http://lpaste.net/1916057087671009280
17:57:31 <P4Titan> So how do I do it then?
17:57:38 <exio4> oh, the problem was about the let
17:58:56 <merijn> torpet: I don't see a line 187 in your code paste and don't know what the type of mkCanPR is
17:59:17 <merijn> P4Titan: Put "module Foo" into the export list of a module to reexport everything imported from Foo
17:59:54 <merijn> i.e., "module Bar (module Foo) where import Foo hiding (blah)" will reexport every function from Foo except blah
17:59:57 <c74d> Trying to use the `C-c C-=`, `C-c C-|`, etc. described at <https://www.haskell.org/haskellwiki/Emacs/Keybindings_and_simple_usage>, I realize that my terminal emulator doesn’t support `C-=`, `C-|`, etc.; should I bind `C-c =`, `C-c |`, etc. to the same functions and use those?
18:09:51 <torpet> merijn: actually i just want to extract a value from "type PosRat = (Nat,Nat)"
18:10:00 <torpet> I need to access either value
18:11:17 <Krikey_sanchez> anyone have any info on why cabal sandbox isn't working as expected?
18:12:57 <P4Titan> Thanks for helping me with the exporting thing. What I have so far is module MyMod (module 1, module 2) where ..., I will now have to write all the functions I want to export in those parenthesis, is there a way to tell it to use the file's contents instead of me writing everything
18:14:43 <Pamelloes> If you don't have anything in parentheses, everything will be exported
18:14:56 <P4Titan> But I want to export modules that are imported
18:16:27 <alpounet> P4Titan: nope, if you want to export modules that you import in addition to functions, types, classes and values defined in the current module, you have to lsit everything explicitly
18:16:27 <Pamelloes> There's probably a solution, but I don't know it. Sorry :/
18:16:39 <alpounet> last time i checked at least
18:18:34 <merijn> alpounet: Not true
18:18:45 <alpounet> oh
18:18:46 <alpounet> ?
18:18:49 <merijn> alpounet: You can do "module Foo (module Foo) where" to reexport everything in the current module
18:18:59 <merijn> I only learned this like a week ago
18:19:06 <alpounet> you can?
18:19:13 <alpounet> doh
18:19:32 <zq> merijn: how's that different from module Foo where?
18:19:50 <alpounet> merijn: so that'll include _all_ imported modules too?
18:20:03 <alpounet> oh no
18:20:06 <alpounet> you just list them along
18:20:18 <alpounet> module Foo ( module Foo, module Data.Text ) for instance?
18:21:07 <merijn> alpounet: Right
18:21:24 <merijn> zq: You can't have an export list containing reexported modules with your version :)
18:21:48 * hackagebot haskakafka 1.0.0 - Kafka bindings for Haskell  http://hackage.haskell.org/package/haskakafka-1.0.0 (tdimson)
18:25:44 <zq> merijn: i don't understand what you're trying to say
18:25:46 <P4Titan> So you are saying that by adding the where, it includes everything?
18:26:11 <zq> merijn: in both cases, symbols imported into Foo from other modules are not re-exported by Foo
18:27:54 <P4Titan> So how is it done then?
18:32:07 <zq> P4Titan: i'm not sure what it is that you want, but "module Foo (module Foo, module A, module B) where // import A // import B // ..." re-exports all the symbols in Foo including those imported from A and B
18:32:41 <Johannes13> Someone asked to convert ["foo", "bar", "baz", "quxx"] to [("foo", "bar"), ("baz", "quxx")]. I used pattern matching, someone else used zipWith twice
18:33:32 <Johannes13> As a newcomer in haskell, I'd say pattern matching is easier readable, but what is the best way?
18:33:34 <Johannes13> http://stackoverflow.com/questions/26963985/list-to-tuple-in-haskell/26964458#26964458
18:40:53 <merijn> zq: In the second case you can write "module Foo (module Foo, module Bar) where", etc. that was the point I was making
18:44:13 <L8D> Fuuzetsu: where should I go to learn how to use yi?
18:44:53 <L8D> oh wait
18:53:34 <L8D> Ok so it's taking my computer 20+ minutes to compile yi
18:53:37 <L8D> this is fucking stupid
18:54:09 <gcganley> L8D: hmm. manually or through cabal
18:54:11 <L8D> does anyone else experience really slow compile speeds in OS X?
18:54:15 <L8D> gcganley: through cabal
18:54:23 <L8D> gcganley: and then through the dyan re-compilation
18:54:43 <L8D> gcganley: like... this same machine recompiles xmonad configs fine on Arch
18:54:47 <gcganley> L8D: what are your specs?
18:55:08 <L8D>  2.4 GHz Intel Core 2 Duo
18:55:17 <L8D> 2 GB 667 MHz DDR2 SDRAM
18:55:44 <gcganley> watch top or htop whilst you compile and then get back to me
18:56:19 <L8D> gcganley: when it finishes compiling?
18:56:39 <gcganley> no while its compileing. to see if its maxing out
18:59:08 <gcganley> L8D: how is it running?
18:59:22 <luite> L8D: i usually work in a linux vm to haskell, since it's faster and easier to set up
18:59:51 <L8D> gcganley: so one core stays at 70-80
19:00:00 <L8D> the other jumps between 30 and 70
19:00:03 <gcganley> luite: i've never owned a Mac i've only owned linux boxes and a few windows machines
19:00:06 <gcganley> :/
19:00:15 <L8D> and then once everything finishes it's back to 0-10
19:00:26 <gcganley> and that takes 20 min?
19:00:50 <L8D> no that was just for compiling Data.Text
19:01:01 <L8D> derp just the text package from cabal
19:01:01 <luite> L8D: you can pass -j2 to ghc to make it do a parallel compile, or to cabal-install to compile packages in parallel
19:01:10 <L8D> I resumed my compilation from earlier and it's still going
19:01:12 <gcganley> yeah -j2 is a good idea
19:01:26 <gcganley> or is yours a quad core...
19:01:31 <L8D> how can I pass -j2 to dyan?
19:01:32 <gcganley> if it is then -j4
19:01:46 <luite> 2GB RAM might be on the lowish side to do higher than 2
19:01:49 <gcganley> does cabal take flags like that?
19:02:05 <luite> gcganley: recent cabal-install accepts -jN yes
19:02:20 <gcganley> luite: sweet!
19:03:03 <gcganley> is there a way to get cabal to play nicely with snapshot images of GHC
19:03:53 <L8D> oh I have --ghc-option :)
19:03:56 <luite> gcganley: i don't think you need to do anything special for that?
19:04:00 <L8D> I guess I'll just make an alias
19:04:16 <gcganley> luite: oh... then cabal just doesnt like me
19:05:00 <luite> gcganley: usually i just set up a shell script that adds a specific ghc version to the path if i'm working on something with that version. otherwise passing the ghc location explicitly might be better
19:05:22 <gcganley> luite: i compile ghc and alias it 'ghc-head
19:05:26 <gcganley> '
19:06:01 <L8D> gcganley: wow that goes much faster
19:06:06 <L8D> thanks
19:06:09 <gcganley> yeah dude
19:06:19 <orion> Are there drawbacks to nullary type classes?
19:06:21 <gcganley> well luite suggested -j2
19:06:35 <gcganley> lol
19:06:50 <L8D> luite: thanks
19:07:09 <gcganley> luite: do you recompile ghc often?
19:07:22 <luite> gcganley: few times a day
19:07:30 <gcganley> luite: i do it every day because i like watching 8 cores going at 100%
19:08:05 <gcganley> luite: whats average time for compilation
19:10:04 <luite> gcganley: uh dunno, i only have quad cores, and usually i don't recompile from scratch
19:11:23 <deathknight> Is there a highly regarded book that teaches a deep dive in to the fundamentals of programming with haskell just as SICP does with scheme?
19:13:09 <L8D> deathknight: lyah
19:13:10 <L8D> jk
19:13:16 <L8D> @lyah
19:13:16 <lambdabot> Unknown command, try @list
19:13:20 <L8D> @list lyah
19:13:20 <lambdabot> No module "lyah" loaded
19:13:25 <L8D> -.-
19:13:35 <L8D> @quote Fuuzetsu
19:13:35 <lambdabot> Fuuzetsu says: I know someone who pulls in Lens just for & and ??
19:13:45 <deathknight> learn you a haskell?
19:14:00 <L8D> deathknight: it doesn't, but it's a great place to start with Haskell
19:14:07 <dmj`> deathknight: learn type classes
19:14:23 <L8D> since it goes over the fundamentals of functional thinking at the same time as teaching Haskell's version of category theory
19:14:35 <deathknight> awesome, thank you
19:15:08 <L8D> deathknight: also once you're done, don't think that Haskell is purely academic or is something like latin
19:15:22 <L8D> deathknight: you should read "Real World Haskell" right after finished lyah
19:15:27 <benzrf> oh man no
19:15:34 <benzrf> most certainly do not
19:15:36 <dmj`> I disagree
19:15:37 <benzrf> L8D: please dont spread this nonsense
19:15:46 <dmj`> benzrf++
19:15:55 <L8D> benzrf: so Haskell is pure academic and something like latin?
19:16:00 <L8D> purely*
19:16:04 <benzrf> lyah is really more like an overview of the language for ppl who already know the concepts
19:16:15 <benzrf> it may not be *intended* to be that, but that's what it is
19:16:29 <benzrf> deathknight: https://github.com/bitemyapp/learnhaskell
19:16:50 <deathknight> SICP is awesome because it really taught recursive thinking...especially with recursive maps in recursive maps...
19:16:58 <deathknight> is there something that is as much of a deep dive as that is?
19:16:58 <benzrf> deathknight: ^ the official education-snob sanctioned guide
19:17:03 <deathknight> grazi mucho benzrf
19:17:14 <benzrf> deathknight: np
19:17:33 <dmj`> deathknight: to go deep, you should do the typeclassopedia
19:17:59 <benzrf> dmj`: how much do you already know
19:18:02 <benzrf> * deathknight
19:18:25 <dmj`> deathknight: what is the type of fmap?
19:18:29 <deathknight> No idea! :)
19:18:41 <L8D> I stand corrected
19:18:43 <dmj`> I'd start with LYAH
19:18:59 <deathknight> and then from there, dmj`?
19:19:17 <dmj`> deathknight: the typeclassopedia, then parallel and concurrent programming in haskell
19:19:17 <gcganley> real world haskell
19:19:22 <gcganley> or typeclassopedia
19:19:31 <dmj`> real world haskell is dated and doesn't cover streaming I/O
19:19:56 <dmj`> deathknight: what do you plan on using haskell for?
19:20:21 <dmj`> deathknight: this is also a good resource: http://dev.stephendiehl.com/hask/
19:20:23 <deathknight> to become a better programmer with other languages
19:20:33 <deathknight> I do web application development mostly in PHP and Javascript
19:20:45 <benzrf> deathknight: please don't use LYAH as your primary resource
19:20:58 <benzrf> deathknight: i really, REALLY recommend learning it from CIS194 as recommended by https://github.com/bitemyapp/learnhaskell
19:21:07 <deathknight> awesome
19:21:10 <deathknight> this is all appreciated so much
19:21:21 <gcganley> deathknight: the web sources you may be interested in later on may be yesod, fay, snap framework, and scotty
19:21:27 <dmj`> deathknight: this is also a good resource for how documentation, testing and the build system works: http://taylor.fausak.me/2014/03/04/haskeleton-a-haskell-project-skeleton
19:21:32 <benzrf> deathknight: a lot of people love lyah, and that's because it's pretty good for what it is
19:21:51 <benzrf> deathknight: the problem is that it gets recommended for purpose that are not good for what it is is
19:22:10 <L8D> because Haskellers are idiots sometimes
19:22:22 <deathknight> What projects have you used Haskell with, benzrf?
19:22:28 <benzrf> deathknight: if you already know Ocaml or ML and a little bit of abstract algebra and category theory, lyah will probably be a fine introduction
19:22:35 <benzrf> otherwise, i recommend against it
19:22:39 <benzrf> deathknight: not a ton
19:22:42 <benzrf> i dont, uh
19:22:43 <dmj`> deathknight: you have a long journey ahead, code in haskell everyday and keep it fun and before you know it you'll be reading category theory books at coffee shops getting strange looks
19:22:46 <benzrf> actually write much code >.>
19:23:05 <deathknight> benzrf: I do not :)
19:23:10 * benzrf runs find ~/codes/haskell
19:23:34 <gcganley> mine is in ~/code/haskell
19:23:43 <gcganley> one fewer keystroke
19:23:47 <deathknight> BOOM
19:25:12 <benzrf> deathknight: to be perfectly honest, the biggest project i've ever used haskell for is a shitty tiny lisp
19:25:15 <benzrf> interpreter
19:25:21 <gcganley> deathknight: are you interested in just getting things done or are you interested in some of the theory in haskell
19:25:42 <carter> i advocate "bang the keyboards, then see if it type checks"
19:25:45 <carter> style of coding :)
19:25:53 <carter> i need to do that style more
19:26:05 <gcganley> lots of :t in ghci
19:26:13 <carter> i like tea too
19:26:21 <gcganley> wow
19:26:33 <L8D> wow?
19:26:33 <carter> ?
19:26:38 <gcganley> almost as bad as Rein cloud
19:26:47 <carter> ?
19:26:49 <deathknight> gcganley: I "get shit done(tm)" with javascript and PHP with web application development. I am interested in spicing up my life (in that kind of way) by seeing how my Javascript/PHP code will improve after coding in Haskell
19:27:02 <gcganley> was that not supposed to be a pun -.-
19:27:11 <carter> gcganley: tea is the stuff you sip
19:27:17 <benzrf> deathknight: i hope you hate php
19:27:22 <benzrf> if not i dont think we can be friends
19:27:23 <dmj`> deathknight: you can replace your javascript / php with haskell code, I'd recommend it for sanity
19:27:33 <carter> i suppose the folks writing ghc(i) drank a lot (of tea)
19:27:35 <gcganley> deathknight: how do you live with yourself
19:27:37 <L8D> I was at this web developer meetup last week
19:27:45 <deathknight> benzrf: I hear a lot of hate on it, but I have had a lot of fun with it. I spend most of my PHP time coding in the Laravel framework. The laravel framework reminds me of Ruby on Rails.
19:27:53 <benzrf> eew
19:27:56 <L8D> and there was this group of people talking about whether they should use an ORM in their PHP framework
19:28:03 <carter> sql ftw
19:28:16 <carter> deathknight: pardon the pile up of opinions, whatever floats your boat is totally ok k:)
19:28:17 <deathknight> L8D: like the eloquent ORM?
19:28:19 <L8D> and they said that ORM is good because you avoid SQL injection attacks
19:28:23 <carter> ....
19:28:28 <gcganley> ive never used php so i cant talk. but javascript can be ok if written in by an ok programmer
19:28:30 <deathknight> L8D: I use the eloquent ORM every day. I love it
19:28:40 <carter> @google eloguent orm
19:28:42 <lambdabot> http://laravel.com/docs/4.2/eloquent
19:28:42 <lambdabot> Title: Laravel - The PHP framework for web artisans.
19:28:47 <deathknight> yup
19:28:48 <deathknight> that link
19:28:48 <L8D> so then I joined the discussion with the viewpoint of a Haskeller and they thought I was joking around
19:29:23 <gcganley> deathknight: look up yesod
19:29:30 <gcganley> deathknight: yesodweb.com
19:29:38 <L8D> apparently everyday PHP coders don't trust other PHP coders to paramaterize their queries properly
19:29:45 <gcganley> http://yesodweb.com/
19:29:54 <carter> yesod is the "rails" flavor of haskell web stack
19:29:54 <L8D> gcganley: but yesod is a big-o-scary framework
19:29:56 <carter> i like snap personally
19:30:02 <deathknight> awesome
19:30:04 <gcganley> scotty?
19:30:04 <carter> also yesod has no version bounds
19:30:18 <gcganley> what about scotty, i hear thats light
19:30:24 <L8D> snap or scotty are quite nice to start learning with
19:30:35 <carter> gcganley: ... afaict, scotty is just like snap, but less things
19:30:38 <dmj`> carter: snap for the win
19:31:06 <carter> yesod.... is the leading cause of newb "cabal hell"
19:31:38 <L8D> I really wish cabal was more mature and fleshed out
19:31:49 <L8D> it has too large of a learning curve
19:31:51 <benzrf> gcganley: php is a web language with easy syntax for string interpolation
19:31:54 <carter> L8D: it is pretty mature... as long as you dont use yesod
19:32:05 <carter> L8D: if you wanna make it better, they always need mroe contribs
19:32:09 <benzrf> gcganley: php is a web language that still encourages cgi
19:32:17 <carter> L8D: ... eg, someone helping improve the cabal test suite would be HUGEEEEE
19:32:19 <L8D> carter: I mean... look at how many stackoverflow problems about cabal and compare those to ones about actual Haskell problems
19:32:30 <carter> L8D: most ofthose are yesod problems i bet
19:32:36 <L8D> probably
19:32:42 <Tekmo_> Yeah, it's yesod that causes Cabal hell
19:32:44 <benzrf> gcganley: php is a web language where all code is in templates and the way you "interpolate strings in" is to call rint
19:32:47 <benzrf> *print
19:32:48 <carter> L8D: ... i was using hakell + cabal in 2008. cabal had real problems in 2008
19:32:54 <L8D> but still, cabal is no where near npm or go-get
19:32:57 <carter> nope
19:32:58 <carter> its better
19:33:01 <carter> those have deeper problems
19:33:02 <BSDgrill> 203.205.148.103/update1.dlied.qq.com/lol/autopatch/3137/LOL_ V3137_2345_9D.exe?mkey=545f930d150dc743&f=2284&p=.exe
19:33:05 <carter> that dont surface till runtime
19:33:11 <Tekmo_> The other big offender used to be lens, but the situation improved a lot recently once it dropped aeson as a dependency
19:33:22 <L8D> carter: I mean in terms of user-interface and the learning curve
19:33:27 <carter> L8D: npm and go-get  HAVE NO VERSIONING
19:33:27 <mrsElectron> how do I cast an int to double?
19:33:27 <gcganley> whats with the download link...
19:33:34 <Tekmo_> mrsElectron: fromIntegral
19:33:40 <xandaros> don't know about apt-get, but pacman is probably better than cabal...
19:33:41 <dfeuer> Tekmo_, did aeson pick up the lensy slack?
19:33:51 <L8D> xandaros: pacman++
19:33:51 <carter> xandaros: package managers aren lib managers, dont mix them up,
19:33:55 <Tekmo_> dfeuer: I think there's a separate package for it now
19:33:56 <gcganley> where is a good tutorial on lens?
19:34:05 <gcganley> @google lens tutorial
19:34:06 <lambdabot> http://www.cambridgeincolour.com/tutorials/camera-lenses.htm
19:34:06 <lambdabot> Title: Understanding Camera Lenses
19:34:10 <MP2E> lol
19:34:10 * carter summons bernalex  to explain that difference between a package manager and  a lib manger
19:34:13 <gcganley> woops
19:34:16 <Tekmo_> I can shamelessly plug my own tutorial: http://www.haskellforall.com/2013/05/program-imperatively-using-haskell.html
19:34:19 <carter> bernalex: could you explain the differnce?
19:34:19 <L8D> carter: wtf how do those not have versioning?
19:34:21 <mrsElectron> if I'm dividing with an Int, I have to cast it first, right?
19:34:25 <carter> L8D: go get has NONE
19:34:34 <Tekmo_> mrsElectron: Yes, or use `div` (which is integer division)
19:34:38 <L8D> carter: isn't it based on git tags?
19:34:39 <gcganley> Tekmo_: FOR SHAME. i'll read it now
19:34:40 <carter> nope
19:34:43 <Tekmo_> gcganley: :)
19:34:46 <carter> L8D: thats an overlay on top
19:35:01 <carter> and with NPM, theres some really really nasty runtime bugs you can get with the npm model
19:35:12 <dfeuer> carter, the fmap/coerce program is going well in the containers direction. vector remains very challenging-looking, but I think I've figured out some of the rules that I will want.
19:35:16 <gcganley> Tekmo_: holy shit your gabriel?
19:35:19 <Tekmo_> gcganley: Yeah
19:35:20 <Tekmo_> :)
19:35:20 <carter> tis he
19:35:26 <carter> dfeuer: cool!
19:35:39 <BSDgrill> dl4.getz.tv/tmp/87/0d/870d5eb62659c739bf329834adaf3713/renau lt_logan_s_dvigatelyami_1.4i_1_6i._ustroystvo_ekspluatatsiya _obsluzhivanie_remont_2009_russkiy.exe
19:35:47 <MP2E> o.O
19:36:11 <gcganley> Tekmo_: whenever i browse this channel i learn that more names i've heard on the haskell cast get brought up. its wicked cool
19:36:23 <mrsElectron> 11/fromIntegral length d   fails.  d is an array
19:36:26 <L8D> there's a Haskell podcast?!
19:36:35 <gcganley> L8D: Haskell Cast
19:36:37 <Tekmo_> gcganley: A lot of us hang out on /r/haskell
19:36:39 <dmj`> http://www.haskellcast.com/
19:36:45 <gcganley> L8D: by ReinH
19:37:00 <gcganley> and idk if the other dude is on here or not
19:37:10 <L8D> ewwww reddit
19:37:11 <L8D> gross
19:37:11 <Tekmo_> gcganley: For example: bos (Bryan O'Sullivan), pigworker (Conor McBride), ekmett (Edward Kmett), snoyberg (Michael Snoyman)
19:37:12 <gcganley> i havent read his name before lol
19:37:14 * dfeuer has heard of reddit.
19:37:33 <gcganley> Tekmo_: quit blowing my mind!
19:37:39 <Tekmo_> /r/haskell is one of the best Haskell communities, in my opinion
19:37:45 <mrsElectron> really? is it that hard to divide a double by an integer?
19:37:47 <BSDgrill> zhushou.52lishi.com/jiasuqi/yxbaobd/bd_4_36534.exe
19:37:48 <gcganley> L8D: dude reddit is bomb
19:37:59 <gcganley> can someone ban this dude?
19:38:07 <Tekmo_> mrsElectron: The syntax is: 11 / fromIntegral (length d)
19:38:12 <BSDgrill>  	zhushou.52lishi.com/jiasuqi/yxbaobd/bd_4_36534.exe
19:38:13 <BSDgrill>  	zhushou.52lishi.com/jiasuqi/yxbaobd/bd_4_36534.exe
19:38:13 <BSDgrill>  	zhushou.52lishi.com/jiasuqi/yxbaobd/bd_4_36534.exe
19:38:17 <Tekmo_> mrsElectron: However, if you meant "list" instead of array, then there is an even simpler way
19:38:18 <gcganley> or at the very least convert him to haskell
19:38:21 <L8D> most of the subreddits I've gotten into seem to develop into cesspools
19:38:23 <Tekmo_> mrsElectron: 11 / genericLength d
19:38:38 <dfeuer> > 11 / fromIntegral (length [1,2,3])
19:38:39 <lambdabot>  3.6666666666666665
19:38:45 <MP2E> L8D : welcome to reddit
19:38:45 <gcganley> BSDgrill: have you heard the word of our lord and saviour simon peyton jones?
19:39:19 <gcganley> L8D: dont go to spacedicks and youre cool
19:39:19 <MP2E> where reasonable opinions backed by facts are downvoted into oblivion, but controversial bullcrap made up by the layman is upvoted to the heavens
19:39:26 <dfeuer> Simon Peyton Jones is not our lord and savior, although he seems to be a good and helpful person.
19:39:29 <Tekmo_> Yeah, reddit is a very mixed bag
19:39:35 <Tekmo_> A lot of great and awful subreddits
19:39:43 <gcganley> like a city
19:39:43 <mrsElectron> fromIntegral length d  is interpreted as (fromIntegral length) d, isn't it?
19:39:44 <dfeuer> He does not appear on Freenode, to the best of my knowledge.
19:39:50 <MP2E> I like /r/haskell for the most part, but even that lately has been getting on my nerves
19:39:54 <dfeuer> Yes, mrsElectron.
19:40:06 <gcganley> defeur: no he does not, ive never seen him
19:40:13 <mrsElectron> thanks
19:40:15 <dfeuer> And you will find it very hard to convert length to a number.
19:40:33 <Tekmo_> mrsElectron: That's right
19:40:42 <Tekmo_> mrsElectron: Haskell function application is left-associative
19:40:56 <Tekmo_> mrsElectron: f x y z = ((f x) y) z
19:41:06 <dfeuer> Tekmo_, on the other hand, is right-associative. Better watch out for those types.
19:41:25 <gcganley> type signitures are right asssoc
19:41:28 <Tekmo_> Yeah
19:41:43 <Tekmo_> If you see the type `a -> b -> c -> d`, it really is `a -> (b -> (c -> d))`
19:41:45 <gcganley> :t fmap
19:41:46 <lambdabot> Functor f => (a -> b) -> f a -> f b
19:41:50 <gcganley> or
19:42:05 <gcganley> Functor f => (a -> b) -> (f a -> f b)
19:42:38 <dfeuer> I was kidding about Tekmo_ being right-associative. Because I'm sleepy and stressed out.
19:42:49 <Tekmo_> I only associate with people to the right of me
19:43:19 <gcganley> dfeuer: drink more coffee, helps so much with stress levels
19:43:25 <Tekmo_> Get more sleep!
19:43:32 <dfeuer> Sleep++
19:43:34 <Tekmo_> Sleep is good for the soul
19:43:37 <dfeuer> @karma Sleep
19:43:38 <lambdabot> Sleep has a karma of 1
19:44:01 <gcganley> defeur: eww my c++ days are still haunting me
19:44:15 <gcganley> well
19:44:29 <gcganley> i mean i enjoyed it and it has its place i just dont like doing it anymore
19:44:31 <dfeuer> gcganley, my name is not spelled like that.
19:44:53 <dfeuer> gcganley, its place appears to be Windows system programming or something.
19:44:54 <MP2E> (protip: use tab and you will never misspell someone's name again)
19:44:57 <lwm> hey, I have three items and I wanna stick them together into a list ...
19:44:57 <gcganley> dfeuer: woops....
19:45:09 <lwm> I am doing: concat [x, y, z]
19:45:13 <dfeuer> lwm, use GLUE.
19:45:25 <dfeuer> lwm, be more concrete, please.
19:45:33 <dfeuer> What kinds of things, and how do you want them to be stuck?
19:45:50 <ReinH> Tekmo_: oh hi
19:45:55 <Tekmo_> ReinH: Hi!
19:46:04 <gcganley> dfeuer: and Windows has terrible C++ API, i hated it sooo much
19:46:36 <benzrf> ReinH: hi
19:46:41 <lpaste> lwm pasted “insertAt attempt” at http://lpaste.net/114422
19:46:41 <gcganley> ReinH: hi
19:46:50 <ReinH> gcganley: hi
19:46:53 <ReinH> benzrf: hi
19:47:03 <benzrf> ReinH: hi
19:47:07 <dfeuer> gcganley, I never really learned C++. I tried to learn it back in the mid-nineties from a Borland C++ manual. Later I understood that the reason it made little sense to me is that it makes little sense.
19:47:12 <lwm> dfeuer: I added my code to lpaste
19:47:13 <Hijiri> benzrf: gcganley ReinH hi
19:47:20 <benzrf> Hijiri: hi
19:47:24 <lwm> I just want to know a nice way to stick three items of type 'a' together
19:47:42 <gcganley> Hijiri: hi
19:47:48 <dmj`> ReinH: hi
19:47:49 <ReinH> lwm: [x,y,z]
19:47:52 <dfeuer> lwm, I think you're looking for ++
19:48:04 <dfeuer> But your code there should also use pattern matching.
19:48:05 <gcganley> :t (++)
19:48:05 <lambdabot> [a] -> [a] -> [a]
19:48:08 <ReinH> lwm: but are you sure you don't want a tuple?
19:48:21 <gcganley> :t concat
19:48:22 <lambdabot> [[a]] -> [a]
19:48:25 <L8D> @hoogle [a] -> [a] -> [a]
19:48:27 <lambdabot> Prelude (++) :: [a] -> [a] -> [a]
19:48:27 <lambdabot> Data.List (++) :: [a] -> [a] -> [a]
19:48:27 <lambdabot> Data.List deleteFirstsBy :: (a -> a -> Bool) -> [a] -> [a] -> [a]
19:48:30 <mrsElectron> I have a datatype shape. Now, can I access an object of it? I want to compare its first element with something .. like shapevar.element1 == 12 or something
19:48:36 <dfeuer> Pattern match to get your ys and zs, lwm.
19:48:43 <dfeuer> Instead of using fst and snd.
19:49:21 <lwm> dfeuer: ah, but I will split my list, so how can I pattern match when I don't know what index of the list I am going to need
19:49:23 <gcganley> and you dont need that ($)
19:49:32 <lwm> gcganley: ok, cool
19:49:37 <tabemann> mrsElectron: record accessors act as functions, so element1 shapevar
19:49:45 <dfeuer> lwm, split the list, and then pattern match on the tuple splitAt gives you.
19:49:48 <gcganley> lwm: your lpaste even says so lol
19:49:48 <ReinH> mrsElectron: Records have field accessors, all data types have pattern matching. data Foo = Foo { str :: String } provides: theString (Foo s) = s and theString foo = str foo
19:49:59 <lwm> gcganley: ha, I saw that
19:50:16 <dfeuer> lwm,    (ys, zs) = splitAt n xs
19:50:30 <lwm> dfeuer: cool!
19:50:35 <gcganley> :t splitAt
19:50:35 <lambdabot> Int -> [a] -> ([a], [a])
19:51:40 <mrsElectron> data shape = circel int int | stick int.  Now, I have a function    areal a_shape =    where I want to square its first int field
19:52:23 <lwm> gcganley, dfeuer: cool, nice one guys, looks better now
19:53:36 <gcganley> lwm: type signitures, pattern matching, standard library. all part of your batman-esque programming utility belt
19:53:45 <gcganley> man i have bad spelling
19:53:48 <ReinH> mrsElectron: Capitalization is important in Haskell syntax
19:54:00 <lwm> but you do have a batman-esque programming utility belt!
19:54:12 <gcganley> true
19:54:16 <Tekmo_> mrsElectron: areal (Circle n _) = n ^2; areal (Stick n) = n^2
19:54:30 <gcganley> lwm: how long have you been programming in haskell?
19:55:15 <lwm> gcganley: maybe a year but always on/off ... I never make it past a month of continuous programming
19:55:25 <lwm> gcganley: got some free time now :)
19:55:44 <ReinH> I can barely manage 4 hours of continuous programming o_O
19:55:52 <dfeuer> lwm, find a project. You can work with me on implementing fmap/coerce rules for Vector (you know, if you're insane)
19:56:07 <lwm> ReinH: ha, woops ...
19:56:19 <gcganley> ReinH, lwm: i want 1 month where i can rocky and just train for a mounth and come out a better man
19:56:31 <ReinH> I want to skip that and just do the montage
19:56:40 <dfeuer> ReinH++
19:56:53 <gcganley> what would be your montage music?
19:57:34 <lwm> haha ... montage of you getting repetitive strain injury, a bad back and sore eyes. Oh the glory
19:58:39 <gcganley> i was thinking more of research papers strewn every where and just PAGES of core on screen with him pulling out his hair as he slowly slips into insanity
19:58:44 <netgear> lol man lol ol ol ol
19:58:50 <netgear> la la la
19:59:22 <lwm> dfeuer: but yes, I found a postgresql database of spanish verbs, so I was thinking of making a small command line tool pull stuff out of that
19:59:33 <lwm> dfeuer: looks hard enough for me right now
20:00:00 <netgear> haskell iz a+ b = 1 - 2 + 4
20:00:38 <gcganley> lwm: im trying to think of how to better bash by adding types. I dont know if thats building an entire shell or just typechecking bash commands
20:00:50 <ReinH> gcganley: https://www.youtube.com/watch?v=VNXu9xKxiR4
20:01:01 <dfeuer> lwm, sounds like it.
20:01:06 <netgear> A MUTHA FUCKIN L + 4 - 1 = 2 !
20:01:14 <ReinH> Ah here's the real version https://www.youtube.com/watch?v=nai7w1frB1E
20:02:02 <netgear> let m = c ^ 2
20:02:29 <lwm> gcganley: I just stear clear of bash programming altogether ... oof, scary stuff
20:02:36 <gcganley> ReinH: yes... this is just the thing I need
20:02:37 <netgear> + 1 yeh + 1
20:02:43 <netgear> Itz all
20:03:09 <gcganley> ReinH: i like their trainer, looks kinda like edwardk
20:03:10 <mrsElectron> !=   means not equal to?
20:03:19 <netgear> In minus l it'z the above
20:03:20 <netgear> !
20:04:06 <ReinH> mrsElectron: sometimes. Not in Haskell.
20:04:17 <gcganley> :t (/=)
20:04:18 <lambdabot> Eq a => a -> a -> Bool
20:04:27 <gcganley> /= == !=
20:04:30 <gcganley> ah yes
20:04:33 <gcganley> that made sense
20:04:33 <netgear> Alwayz i nlizp minuz numerle I think they wanta make the lan that firefox iz makin it'z the awezome
20:04:39 <netgear> I waz here yeh watz teh name uf it
20:04:41 <mrsElectron> thnxz
20:05:05 <netgear> Fake
20:06:57 <infinmed> Antononiactic nonsense
20:07:01 <infinmed> FU
20:07:04 <dfeuer> What was that?
20:07:24 <infinmed> I think hydrolic lift
20:08:04 <gcganley> good night all
20:12:32 <mrsElectron> when using a guard and ending it with "where" where for which you defined multiple functions... you'll have to put them all aligned for haskell not to confuse them with "global functions", right. But what does this "alignment" mean? Is a tab before all of them okay, or do you have to have the same amount of tabs in front of all of them?
20:12:45 <infinmed> Itz a fuckin assertion man learn it
20:12:51 <lwm> gcganley: laterrr
20:13:44 <infinmed> Monolouge no man itz what makez an assertion +m
20:14:50 <srhb> mrsElectron: Generally, the first character after a layout herald decides the indentation
20:15:28 <srhb> So if you have do { a ... } -- (but without the braces) everything following must be aligned to the same indentation as the 'a' or deeper, or it will terminate the block
20:15:52 <infinmed> itz not a macro man what iz it
20:16:12 <srhb> infinmed: Who are you talking to? :-)
20:16:33 <infinmed> I'm implyin that u are not lettin me know
20:16:51 <srhb> mrsElectron: Also you should never use tabs in Haskell. But you are right, the first character of the first name bound in the where block decides where all following lines must start.
20:17:13 <srhb> infinmed: are you here to learn Haskell? :)
20:17:24 <infinmed> Yes in haskell what iz it that is used to make an assertion
20:18:05 <srhb> infinmed: What do you mean exactly by assertion?
20:18:24 <infinmed> Minus 1+24771111111 what makez an ASZERTUN that iz wITH an mM
20:18:29 <infinmed> It ztartz w/ an M
20:18:52 <srhb> infinmed: You're not making much sense. :)
20:18:59 <infinmed> Hmm alrite
20:19:02 --- mode: ChanServ set +o monochrom
20:19:07 <infinmed> I'd assume u look it up for me
20:19:09 <lucs> Um, no ops here to quiet infinmed ?
20:19:14 --- mode: monochrom set +b *!*infinmed@*.xyz
20:19:14 --- kick: infinmed was kicked by monochrom (infinmed)
20:19:22 <lucs> Thanks.
20:20:11 --- mode: monochrom set +b-b *!*@*.xyz *!*infinmed@*.xyz
20:20:25 --- mode: monochrom set -o monochrom
20:20:46 <DTSCode> hello guys... im learning haskell and came across this and dont quite understand it. could someone explain it to me? :: Num t => [t]
20:21:29 <Hijiri> Num is a typeclass, this type is polymorphic
20:21:34 <Hijiri> it can be a list of any "numeric" type
20:21:40 <Hijiri> like Int, Integer, Float , etc
20:21:51 <DTSCode> ok that makes sense
20:21:55 <Hijiri> If you haven't learned typeclasses yet you don't need to worry too much about it
20:22:00 <DTSCode> alright
20:22:42 <srhb> DTSCode: I read them backwards. The type is [t] where t is an instance of the Num type class.
20:23:39 <DTSCode> so it reads as TYPE identifier => [list]?
20:23:48 <srhb> It's called a context.
20:23:57 <srhb> A list of ts where t is a Num
20:24:07 <mrsElectron> haskell is case sensitive I suppose?
20:24:08 <srhb> In this case you (probably) get this type because you've used number constants
20:24:08 <DTSCode> oh ok that makes sense
20:24:13 <srhb> mrsElectron: Yes
20:24:14 <monochrom> Num is not a type.
20:24:29 <mrsElectron> ty
20:24:45 <monochrom> instead, "t" and "[t]" are types
20:24:54 <DTSCode> thanks guys! hopefully ill make it to the point where i actually understand haskell this time
20:25:04 <srhb> DTSCode: Hang in there, it's very rewarding :)
20:25:49 <DTSCode> it looks like it is. its just very different from learning c++ or python
20:25:59 <srhb> DTSCode: Indeed :)
20:26:03 <merijn> I like to read it typeclass constraints as if/then implications
20:26:17 <srhb> merijn: if t is an instance of Num, then [t] ?
20:26:36 <merijn> "foo :: Num t => [t]" -> "IF 't' is an instance of 'Num' THEN 'foo :: [t]' ELSE type error"
20:26:47 <srhb> That makes sense.
20:28:30 <lpaste> lwm pasted “insertAt' attempt again ...” at http://lpaste.net/114425
20:28:48 <lwm> hey guys, still working on getting some decent code, can anyone take a look at that
20:29:14 <DTSCode> whats the difference between a tuple and a list in haskell?
20:29:25 <lwm> works with: insertAt' 8 [1,2,3] 2
20:29:34 <merijn> lwm: Why not "ys ++ (x:zs)"?
20:29:36 <lwm> but fails with:  insertAt' "a" "abcd" 2
20:29:40 <srhb> DTSCode: Tuples can be heterogenous and have a fixed length.
20:29:48 <monochrom> [False, 'x'] is an illegal list, (False, 'x') is a legal tuple
20:30:00 <srhb> DTSCode: That is, ('a', 1) is possible but ['a', 1] is not
20:30:06 <srhb> Eh, beat me to it
20:30:10 <DTSCode> oh ok that makes sense
20:30:23 <monochrom> [False, True] and [False, True, False] have the same type. (False, True) and (False, True, False) have different types.
20:30:31 <merijn> lwm: define "fails"
20:30:39 <lwm> merijn: that still fails with the string input
20:30:45 <lwm> merijn: ghc screams at me :|
20:30:52 <srhb> lwm: "screams"
20:30:59 <lwm> merijn: Couldn't match type `Char' with `[Char]'
20:31:01 <merijn> It would help if you enlighten us by telling us what it is screaming :)
20:31:03 <merijn> oh!
20:31:04 <merijn> duh!
20:31:12 <spopejoy> 'a'
20:31:13 <merijn> lwm: "a" is not a Char, it's a String
20:31:18 <merijn> :t "a"
20:31:19 <lambdabot> [Char]
20:31:22 <merijn> :t 'a'
20:31:23 <lambdabot> Char
20:31:30 <monochrom> @type splitAt
20:31:31 <lambdabot> Int -> [a] -> ([a], [a])
20:31:31 <Tekmo_> > "a" = ['a']
20:31:32 <lambdabot>  <hint>:1:5: parse error on input ‘=’
20:31:36 <Tekmo_> > "a" == ['a']
20:31:38 <lambdabot>  True
20:31:45 <lwm> merijn: yep, I got that, but I still don't know how to make it work haha
20:32:02 <merijn> insertAt' 'a' "abcd" 2 ?
20:32:03 <srhb> lwm: Think about it, if you try to insert a String into a String, what would you get?
20:32:04 <lwm> merijn: the types all line up but it fails at runtime with the string
20:32:25 <merijn> "fails at runtime" <- doubtful
20:32:33 <lwm> AH
20:32:44 <merijn> I think you're confusing runtime and compile time due to ghci mixing the two
20:33:17 <lwm> ah, I was using: insertAt' "a" "abcd" 2
20:33:26 <lwm> and not: insertAt' 'a' "abcd" 2
20:33:41 <lwm> merijn: when I load a script into ghci and pass it some input
20:33:48 <lwm> merijn: not runtime?
20:33:50 <monochrom> you should say that right at the beginning. no one can guess.
20:34:13 <lwm> I did, I copied in my inputs ...
20:34:31 <lwm> merijn: thanks for the help
20:34:59 <monochrom> I see.
20:35:03 <merijn> lwm: Inputs don't help, because the majority of people aren't going to run your code :)
20:35:30 <merijn> lwm: The majority of people here will look at your code, types and type error and spot the error from there
20:35:57 <lwm> merijn: OK. I wasn't aware of the difference of 'a' and "a"
20:36:05 * monochrom frowns. would you rather askers conceal inputs?
20:36:52 <merijn> monochrom: I consider that part of the code
20:37:00 <mrsElectron> 10-2*2 returns 6.  shouldn't it be interpreted as (10-2)*2 since functions works that way?
20:37:18 <merijn> mrsElectron: No, because the precedence of * is higher
20:37:40 <mrsElectron> I thought - was a function just like anyone else
20:38:00 <srhb> Operators all have precedence. :)
20:38:16 <srhb> (-) is a function like any else.
20:38:18 <merijn> mrsElectron: It *is* a function
20:38:18 <srhb> - is not.
20:38:31 <merijn> srhb: Why would you say that - is not a function?
20:38:32 <srhb> Aside from being a function, it has precedence and associativity
20:38:38 <srhb> merijn: I never said that.
20:39:04 <carter> its a bit tricky
20:39:15 <carter> -a desugars to negate a
20:39:23 <carter> but a - b is  (-) a b
20:39:31 <carter> roughly
20:39:35 <srhb> carter: Isn't that just (-a) ?
20:39:44 <carter> which?
20:39:47 <carter> -7
20:39:54 <srhb> Oh yeah.
20:39:54 <carter> > :t -7
20:39:55 <lambdabot>  <hint>:1:1: parse error on input ‘:’
20:39:59 <srhb> You're right.
20:40:11 <carter> the white space gotcha
20:40:16 <srhb> But that's just minus being even specialler. :-)
20:40:22 <srhb> :t -7
20:40:23 <lambdabot> Num a => a
20:40:29 <carter> :t  - 7
20:40:30 <lambdabot> Num a => a
20:40:41 <carter> :t   7  -
20:40:42 <lambdabot>     parse error (possibly incorrect indentation or mismatched brackets)
20:40:55 <carter> > -  7
20:40:56 <lambdabot>  -7
20:41:03 <carter> > 7 -
20:41:04 <lambdabot>  <hint>:1:4:
20:41:04 <lambdabot>      parse error (possibly incorrect indentation or mismatched brackets)
20:41:12 <carter> > 7 `(-)`
20:41:14 <lambdabot>  <hint>:1:4: parse error on input ‘(’
20:41:23 <carter> :t minux
20:41:25 <lambdabot> Not in scope: ‘minux’
20:41:25 <carter> :t minus
20:41:26 <lambdabot> Not in scope: ‘minus’
20:41:30 <carter> :t sub
20:41:31 <lambdabot>     Not in scope: ‘sub’
20:41:31 <lambdabot>     Perhaps you meant one of these:
20:41:31 <lambdabot>       ‘sum’ (imported from Data.List),
20:41:36 <carter> :t substrac
20:41:37 <lambdabot>     Not in scope: ‘substrac’
20:41:37 <lambdabot>     Perhaps you meant ‘subtract’ (imported from Prelude)
20:41:38 <carter> :t substract
20:41:39 <lambdabot>     Not in scope: ‘substract’
20:41:39 <lambdabot>     Perhaps you meant ‘subtract’ (imported from Prelude)
20:41:44 <carter> :t subtract
20:41:45 <lambdabot> Num a => a -> a -> a
20:41:49 <carter> kdjfdkj
20:41:52 <carter> srhb: :)
20:42:17 <srhb> The only weird thing to me is how (-7) is not a function.
20:42:22 <srhb> It makes sense, but it still always gets me.
20:42:45 <srhb> Probably because I'm used to ~7 for negative constants
20:43:18 <carter> ~ is already taken sadly
20:43:23 <carter> but that'd be neat
20:43:37 <carter> what language uses ~ for negative constants?
20:43:38 <monochrom> SML does it
20:43:41 <carter> ah
20:43:45 <srhb> Yeah, SML is where I have it from.
20:43:49 <carter> huh
20:44:06 <carter> i do wanna at some point do a strict haskell+ml hybrid
20:44:29 <srhb> Why?
20:44:53 <solatis> hmz
20:44:56 <srhb> The only thing that seems worth salvaging is the ML style functor-signature system
20:45:08 <solatis> what's the rationale for using ~7 instead of -7?
20:45:16 <solatis> to avoid the 'Just -7' issue?
20:45:18 <srhb> solatis: Then (-7) can be a function
20:45:24 <srhb> Just like you'd expect
20:45:36 <solatis> yeah like right now in haskell -7 is a function
20:45:39 <solatis> instead of a constant
20:45:47 <srhb> solatis: Huh?
20:45:54 <srhb> :t (-7)
20:45:55 <lambdabot> Num a => a
20:45:58 <solatis> > Just -7
20:45:59 <lambdabot>  No instance for (Data.Typeable.Internal.Typeable a0)
20:45:59 <lambdabot>    arising from a use of ‘M24172893586306530417297.show_M24172893586306530417...
20:45:59 <lambdabot>  The type variable ‘a0’ is ambiguous
20:45:59 <lambdabot>  Note: there are several potential instances:
20:45:59 <lambdabot>    instance Data.Typeable.Internal.Typeable Data.Dynamic.Dynamic
20:46:00 <srhb> :t (+7)
20:46:01 <lambdabot> Num a => a -> a
20:46:11 <solatis> Just -7 is evaluated as Just - 7
20:46:28 <solatis> > Just 7
20:46:30 <lambdabot>  Just 7
20:46:33 <solatis> > Just -7
20:46:35 <lambdabot>  No instance for (Data.Typeable.Internal.Typeable a0)
20:46:35 <lambdabot>    arising from a use of ‘M74958801564024516317326.show_M74958801564024516317...
20:46:35 <lambdabot>  The type variable ‘a0’ is ambiguous
20:46:35 <lambdabot>  Note: there are several potential instances:
20:46:35 <lambdabot>    instance Data.Typeable.Internal.Typeable Data.Dynamic.Dynamic
20:47:01 <Tekmo_> Man, that's a really bad error message
20:47:05 <solatis> see also: https://www.haskell.org/ghc/docs/latest/html/users_guide/syntax-extns.html#negative-literals
20:47:38 <solatis> Tekmo_: don't worry, my previous language of choice was c++ -- trust me, the error messages are far worse there :)
20:47:56 <Cale> solatis: Just - 7 means "subtract the function 7 from the function Just"
20:48:01 <solatis> Cale: i know
20:48:04 <Cale> (no matter how you space it)
20:48:08 <Cale> -7 itself isn't a function
20:48:23 <solatis> Cale: the issue is that 'Just -7' is evaluated as 'Just - 7'
20:48:25 <Cale> -7 is negate 7
20:48:49 <Cale> Is that an issue?
20:49:07 <solatis> yes
20:49:14 <solatis> negate (7) != fromIteger (-7)
20:49:40 <Cale> When you put - between two terms, it becomes infix subtraction
20:49:47 <solatis> i know
20:49:52 <Cale> When it occurs at the start of a subexpression, it's negation
20:49:56 <solatis> it's a language design choice
20:50:02 <Cale> So, Just -7 is infix subtraction
20:50:09 <srhb> ...
20:50:20 <Cale> I... don't understand how this is problematic :)
20:50:21 <solatis> > Just fromInteger (-7)
20:50:22 <lambdabot>  Couldn't match expected type ‘a1 -> t’
20:50:23 <lambdabot>              with actual type ‘Data.Maybe.Maybe
20:50:23 <lambdabot>                                  (GHC.Integer.Type.Integer -> a0)’
20:50:35 <Cale> huh?
20:50:43 <solatis> nevermind, that was a wrong example
20:50:50 <solatis> well
20:51:00 <carter> :t Just $ -7
20:51:01 <lambdabot> Num s => Maybe s
20:51:24 <solatis> i know there are millions of ways to rewrite your code to make it work correctly
20:51:32 <solatis> :t Just (-7)
20:51:33 <lambdabot> Num a => Maybe a
20:51:36 <srhb> The REAL problem is that - is overloaded in everyday use.
20:51:38 <solatis> :t Just -7
20:51:39 <lambdabot> Num (a -> Maybe a) => a -> Maybe a
20:51:47 <srhb> What a terrible design choice. Who do we blame? The arabs?
20:53:03 <solatis> i sense a load of sarcasm in your comment, but i think this is a valid issue to raise
20:53:22 <srhb> I'm not being sarcastic. I think it's annoying, although not very much. :P
20:53:37 <srhb> (Well, blaming people was definitely sarcastic)
20:54:05 <solatis> i had to design a DSL that wanted this behaviour *and* have comma-less array definitions
20:54:18 <solatis> i quickly whipped their asses for making that a requirement
20:54:24 <solatis> [1 2 3] would be [1, 2, 3]
20:54:28 <solatis> what would [1 2 -3] be ?
20:54:35 <solatis> [1, -1] or [1, 2, -3]
20:54:43 <srhb> Who knows.
20:55:10 <solatis> "who knows" isn't really part of any language specification :)
20:55:24 <Clint> "undefined behavior"
20:55:26 <srhb> My point exactly.
20:55:29 <solatis> :)
20:55:35 <srhb> Ah well.
20:56:12 <solatis> i'm sure our haskell overlords have put great thought into these design decisions
20:56:33 <carter> but a well written proposal and roadmap CAN make changes happen :)
20:56:49 * hackagebot elevator 0.1 - Immediately lifts to a desired level  http://hackage.haskell.org/package/elevator-0.1 (FumiakiKinoshita)
20:56:52 <solatis> well, there already is -- -XNegativeLiterals
21:06:16 <benzrf> bye
21:13:04 <Javran> hi, I want some explanation on Coarbitrary of QuickCheck, I can understand that to have Gen (a->b), we need a function of type a -> Gen b, but why the type of coarbitrary is a -> Gen b -> Gen b rather than a -> Gen b?
21:19:15 <ReinH> solatis: "Who knows" appears all over the C specification, just in slightly different wording. ;)
21:19:27 <solatis> ReinH: i know :)
21:19:41 <johnw> well, it kind of means "the compiler vendor knows" :)
21:19:50 <johnw> "and makes no promises"
21:20:20 <ReinH> Except when they don't ;)
21:20:39 <solatis> sometimes they do, sometimes they don't
21:20:49 <johnw> sometimes undefined behavior can be a good thing
21:20:49 <solatis> char c; c++; sometimes is undefined, sometimes is not
21:21:04 <johnw> it means the vendor is less constrained in the implementation; for example, if a different behavior would really be preferable on an embedded device
21:21:47 <solatis> johnw: yeah, it allows for more optimizations to just say 'undefined'
21:21:57 <johnw> http://blog.llvm.org/2011/05/what-every-c-programmer-should-know.html
21:22:25 <johnw> "You can look at this either as "optimizations enabled" by the class of undefined behavior or as the "overhead avoided" that would be required to make each case defined."
21:22:32 <monochrom> does it have a sequel called "what every c programmer cannot know"? :)
21:22:58 <solatis> monochrom: like c++'s FAQ and FQA ? :)
21:23:21 <solatis> (frequently questioned answers)
21:23:59 <ReinH> monochrom: No, but it has a sequel called "what ever C programmer shouldn't know". The two combined contain all of human knowledge.
21:23:59 <Javran> never mind my question, kinda figure that out
21:25:14 <solatis> ReinH: there are so many 'what every X programmer should know about Y' posts in the world i've grown immune to them
21:25:16 <carter> and over specified language actually sucks in some ways
21:25:25 <carter> its kinda why SML really languished
21:25:39 <solatis> carter: i'm actually really glad they over-specified HTML5
21:25:53 <carter> did they?
21:25:56 <solatis> well
21:25:57 <carter> are you sure?
21:26:04 <carter> i know SML has formal semantics
21:26:05 <solatis> compared to html4, yes
21:26:07 <solatis> :)
21:26:08 <carter> i dont think html5 does :)
21:26:13 <solatis> ok
21:26:30 <solatis> but html5 defines exactly what to do when incorrect input comes in, and what to do
21:26:57 <solatis> so instead of just defining correct syntax, they even define what to do when the syntax is incorrect
21:27:54 <solatis> i think that goes into the "over-specification" area when you're specifying what a compiler should do with invalid input
21:28:46 <solatis> like: <table><tr><h1>foo<td>blah</table> -- clearly invalid, but html5 even specifies where the <h1/> should belong
21:28:57 <carter> no
21:29:07 <carter> thats specifying an error correcting semantics
21:29:13 <carter> for a document rendering / parsing
21:29:18 <carter> slightly different thing
21:29:23 <carter> though i guess theyr'e related
21:29:28 <johnw> solatis: that might be invalid html, but it would be perfectly valid sgml
21:29:41 <johnw> i meant, invalid xml
21:29:48 <carter> i meant more so that it crippled SML compiler implementator innovation
21:30:01 <solatis> i understand both points
21:30:28 <solatis> i was just arguing that sometimes it's a good thing when things get specified beyond what (initially) seemed appropriate
21:30:52 * solatis looks at JSON
21:31:03 <solatis> "text should be unicode" is all that's specified
21:31:06 <solatis> bastard JSON
21:31:18 <solatis> so we have an RFC and an ECMA specification of JSON
21:31:24 <johnw> that's pretty inspecific
21:31:29 <solatis> yep
21:31:39 <solatis> and both RFC and ECMA use different encoding types
21:31:55 <solatis> so when you store ECMA-encoded JSON, it cannot be RFC-decoded
21:32:14 <solatis> when i found out, i really couldn't believe it
21:32:34 <solatis> when you define a data serialization format, text encoding format would be the first thing i would be thinking about
21:33:01 <solatis> but apparently JSON leaves that up to the implementors
21:33:09 <solatis> and now we have two competing standards
21:34:03 <johnw> which encoding does Aeson use?
21:34:21 <solatis> i hope ECMA
21:34:32 <solatis> ECMA uses UCS-2 or UTF-16
21:34:39 <solatis> RFC uses UTF-8, UTF-16 or UTF-32
21:34:50 <solatis> but ECMA is what all browser vendors + node.js use
21:35:26 <solatis> anyway, ECMA nowadays just says 'UTF-16'
21:35:52 <solatis> RFC leaves the choice of UTFx up to the implementation
21:36:01 <solatis> which is, imho, horrible
21:36:41 <johnw> anyways, back in Haskell land... :)
21:37:14 <solatis> oh, awesome
21:37:16 <solatis> https://github.com/bos/aeson/blob/master/Data/Aeson/Encode/ByteString.hs#L79
21:37:21 <solatis> so it uses UTF-8
21:37:29 <solatis> which is neither recommended by ECMA or RFC
21:38:35 <orion> Does anyone know why this build is failing?: https://travis-ci.org/centromere/cacophony/jobs/41213666 <-- complains about the 'type' field https://github.com/thoughtpolice/hs-nacl/blob/master/nacl.cabal <-- line 149 clearly has the type field
21:38:41 <monochrom> and Haskell 2010 section 2.1 on what constitutes source code: "Haskell uses the Unicode character set" :)
21:39:16 <johnhgdhjvb> hi im new to haskell and im on exercise 11 on haskell.org.. not sure why this is failing on the else. any pointers? http://pastebin.com/yEsjWykS
21:40:42 <johnw> what's the exact error johnhgdhjvb ?
21:40:52 <johnhgdhjvb> testing.hs:9:88: parse error on input `else'
21:41:03 <solatis> so basicly this means that Aeson's JSON is incompatible with any browser-engine's JSON
21:41:11 <monochrom> you have multiple errors. you miss "then". and you need parentheses for (head x), (length x), and (head x)
21:41:14 <solatis> since browser engines use UCS-2 or UTF-16
21:41:19 <johnhgdhjvb> o
21:41:20 <johnhgdhjvb> ok
21:41:41 <monochrom> by that I don't mean "length x > 0". I mean "Multiple (head x) (length x)"
21:42:06 <monochrom> and that is in the wrong order. the right order is "Multiple (length x) (head x)"
21:42:33 <johnhgdhjvb> thanks so much! i guess im getting sleepy
21:43:10 <monochrom> "Amount b" makes no sense. Amount is a type, not a type class. rle :: [Char] -> [Amount]
21:44:02 <monochrom> it can only be Char because Amount forces Char. you cannot have Eq a => [a] -> [Amount]. your implementation does not live up to that much generality
21:45:20 <solatis> ok
21:45:37 <solatis> it's official, Aeson is incompatible with ECMA JSON :)
21:45:39 <ReinH> solatis: Um. http://www.ietf.org/rfc/rfc4627.txt says "JSON text SHALL be encoded in Unicode.  The default encoding is UTF-8."
21:45:46 <solatis> that's the RFC
21:45:56 <solatis> there are two competing specifications
21:46:02 <solatis> ECMA 404 is the other one
21:46:24 <monochrom> > span (== 'c') ['c', 'c', 'c', 'a', 'a']
21:46:26 <lambdabot>  ("ccc","aa")
21:46:42 <solatis> they just say 'Unicode' in the ECMA specification
21:46:46 <solatis> but they also say this:
21:46:55 <solatis> So for example, a string containing only the G clef character (U+1D11E) may be represented as "\uD834\uDD1E".
21:47:05 <solatis> which clearly means UTF-8 :)
21:47:25 <solatis> so the examples in ECMA 404 are UTF-8, but they never explicitly say UTF-8
21:47:36 <solatis> so a browser vendor is free to use, say, UCS-2
21:47:39 <monochrom> "(x : listPass) : pack listFail" will lead to wrong lengths later. it should simply be "listPass : pack listFail"
21:48:58 <monochrom> wait a second, "\uD834\uDD1E" cannot be UTF-8.
21:52:16 <monochrom> err, rle :: [[Char]] -> [Amount]
21:53:33 <monochrom> after midnight, everyone is sleep-deprived, only monochrom is as sober as a compiler.
21:54:15 <johnw> well, midnight is really my biological 6pm
21:55:19 <chirpsalot> monochrom: which compiler? :P
21:55:26 <monochrom> hugs
21:55:38 <johnw> if you want really sober, smlnj is the way to go
21:55:52 <monochrom> <-- not going to figure out data kinds for you
21:56:47 <chirpsalot> For some reason this isn't clicking right now... How would you go about parsing ANY string between, say, "begin" and "end" (up to the first end) in attoparsec?
21:57:16 <johnw> something like: string "begin" *> manyTill anyChar (try (string "end"))
21:57:30 <johnw> there's an example of this in the docs
21:57:41 <chirpsalot> Crap, must have missed it.
21:57:54 <monochrom> write a KMP thing to search for "end"...
21:58:00 <johnw> note that if "e" or "en" occur a lot in your text, that's going to be hella slow
21:58:22 <monochrom> yes, this is why you should go KMP :)
21:58:29 <johnw> KMP?
21:58:40 <chirpsalot> johnw: string matching algorithm.
21:58:50 <chirpsalot> http://en.wikipedia.org/wiki/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm
21:58:52 <johnw> ah
21:58:54 <monochrom> the Knuth Morris Pratt algorithm
21:58:57 <johnw> thanks, I hadn't heard of it
21:59:35 <monochrom> it fixes the problem of "if e or en occur a lot, it is dog slow"
21:59:52 <johnw> awesome, I'll read up on it, thanks
22:01:42 <chirpsalot> johnw: something like that had occurred to me, it just seemed a lot less readable than the usual... blah; thing <- thingParser; endblah you usually get.
22:03:57 <Malar> what is the best way to define a function that takes an input like "hello" and returns [('h',"ello"),('e',"hllo"),('l',"helo"),('l',"helo"),('o',"hell")]
22:05:55 <wei2912> let f xs = map f' [0..length xs - 1] in f "hello"
22:06:15 <wei2912> there's probably a way to omit the "length"
22:06:31 <chirpsalot> What's f'?
22:06:59 <wei2912> f' should take in the index of the character, then remove that char from the input string
22:07:43 <wei2912> take i xs ++ tail $ drop i xs, perhaps? :P
22:08:12 <wei2912> there's probably a better way
22:10:58 <jle`> Malar: simon marlow has such a function i think in his book Parallel & Concurrent Haskell
22:11:22 <johnw> > let xs = "Hello" in zipWith (\i x -> (xs !! i, take i xs ++ drop (i + 1) xs)) [0..] xs
22:11:24 <lambdabot>  [('H',"ello"),('e',"Hllo"),('l',"Helo"),('l',"Helo"),('o',"Hell")]
22:12:14 <johnw> the asymptotics are pretty horrid though
22:12:21 <johnw> with a custom recursive function you could do much better
22:15:52 <Malar> jle` i'll look into it thanks.
22:15:58 <wei2912> johnw++
22:17:18 <johnw> oh, haha: let xs = "Hello" in zipWith (\i x -> (x, take i xs ++ drop (i + 1) xs)) [0..] xs
22:17:25 <johnw> I was looking up the exact element being passed to me
22:17:34 <johnw> still not great, but better
22:18:50 <DTSCode> are strings just lists of characters? so "abc" and ['a', 'b', 'c'] are of type [char] right?
22:18:57 <johnw> correct
22:19:08 <DTSCode> awesome
22:19:35 <DTSCode> why does fst "abc" not work then?
22:19:48 <johnw> fst works on tuples
22:19:51 <johnw> you mean "head"
22:20:06 <jle`> :t fst
22:20:07 <lambdabot> (a, b) -> a
22:20:10 <jle`> :t head
22:20:11 <lambdabot> [a] -> a
22:20:19 <DTSCode> oh ok that makes sense.
22:20:28 <DTSCode> i forgot i was using it on tuples before
22:21:15 <indiagreen> @let f s = case s of [] -> []; x:xs -> (x,xs) : [(y,x:ys) | (y,ys) <- f xs]
22:21:16 <lambdabot>  .L.hs:161:55:
22:21:16 <lambdabot>      Ambiguous occurrence ‘f’
22:21:16 <lambdabot>      It could refer to either ‘L.f’, defined at .L.hs:158:1
22:21:16 <lambdabot>                            or ‘Debug.SimpleReflect.f’,
22:21:16 <lambdabot>                               imported from ‘Debug.SimpleReflect’ at .L.hs:11...
22:21:17 <johnw> the type error should have made this pretty clear, too
22:21:41 <indiagreen> @let ex s = case s of [] -> []; x:xs -> (x,xs) : [(y,x:ys) | (y,ys) <- ex xs]
22:21:43 <lambdabot>  Defined.
22:21:50 <indiagreen> > ex [1..8]
22:21:52 <lambdabot>  [(1,[2,3,4,5,6,7,8]),(2,[1,3,4,5,6,7,8]),(3,[1,2,4,5,6,7,8]),(4,[1,2,3,5,6,7...
22:21:56 <ReinH> johnw: it's a pointed set, which is a comonad :)
22:22:12 <johnw> ReinH: oh yeah, exactly!
22:22:54 <zzz> Greetings you functional programming wizards
22:22:59 <zzz> https://www.kickstarter.com/projects/yhwh/moot
22:23:07 <zzz> if you don't mind, take a look at that
22:23:09 <johnw> ReinH: only it failed to record which "l" was the focus
22:24:28 <ReinH> johnw: well it's actually not quote a set ;)
22:24:30 <ReinH> *quite
22:25:22 <Hijiri> zzz: is this a haskell project
22:25:25 <ReinH> you actually need to track a prefix and suffix to do a pointed list properly
22:25:35 <ReinH> Hijiri: no, it's spam
22:25:41 <zzz> lmao no. I'm aware it's kind of spammy
22:25:54 <johnw> please don't post off-topic links here, zzz
22:25:56 <zzz> just trying to reach out to any possible individuals who would feel nostalgic for one of the most loved games ever
22:26:04 <ReinH> zzz: not appropriate
22:26:11 <ReinH> johnw: oh look https://hackage.haskell.org/package/pointedlist-0.6.1/docs/Data-List-PointedList.html
22:26:22 <zzz> doesn't matter if I do or not due to the fact that I'll probably never come here again after idling here tonight
22:26:39 <zzz> or /getting banned for ignorant reasons when with one-time slip ups
22:26:47 <ReinH> zzz: ok, you can leave now
22:27:01 <zzz> on a side note. I like haskell and have heard nothing but good about the community itself
22:27:52 <johnw> we typically don't ban anyone for a one-time slip up
22:28:11 <zzz> ReinH, where is the technology channel on the freenode network?
22:28:12 <johnw> unless it's NSFW spam links; in a case like this, we just ask to follow our channel policies
22:28:16 <zzz> that's why I ended up here
22:28:26 <zzz> it's not a spam link though. It's simply offtopic
22:28:41 <zzz> I wouldn't post multiple times, as I respect the scene, etc
22:28:42 <red__> is there a nub for [Maybe a] values that leaves the Nothing's intact? I'm trying to detect duplicates in a [Maybe Int]
22:28:54 <ReinH> zzz: Ok, and new we can stop talking about it.
22:29:04 <ReinH> *now
22:29:16 <zzz> only irc I could find with possible nostalgic intelligent people. Could someone please tell me where the technology chat is?
22:29:24 <zzz> sorry, I typed before reading this, ReinH
22:29:24 <johnw> red__: you could write such a function yourself pretty easily; nothing comes to mind
22:29:45 <johnw> zzz: I actually don't know where to go for "general technology chat" on IRC...
22:29:48 <ReinH> red__: what purpose do the duplicate Nothing entries serve?
22:29:56 <red__> johnw: thanks .. trying to use libraries as much as possible
22:30:01 <srhb> zzz: I don't believe there is one.
22:30:21 <zzz> don't most places have channels for just technology or whatever? I only sit on Rizon with my buddies. Not too savvy about other servers
22:30:21 <ReinH> red__: Maybe there's a better way to express your intent
22:30:22 <red__> ReinH: blanks in a sudoku grid/row/col
22:30:39 <jle`> there are a bunch of sorta off-topic anything-goes chatrooms, like #haskell-blah etc.
22:30:51 <kadoban> zzz: Even if there is, we're supposed to help you spam channels?
22:31:05 <zzz> ... Do what kadoban?
22:31:17 <srhb> This meta-discussion is way more noisy than the original link.
22:31:21 <srhb> Shhh.
22:31:25 <zzz> Again, it's not spam as stated above, and never did I say I needed some sort of army
22:31:31 <Hijiri> it's advertising
22:31:52 <zzz> kadoban, I was simply asking to be directed, and only myself directed
22:31:55 <ReinH> Everyone please stop discussing this?
22:32:04 <zzz> ^ this
22:32:49 <zzz> well, I'll see if I can find a general tech discussion channel. Thanks for the attempted help and sorry to intrude.
22:32:56 <johnw> zzz: good luck!
22:34:42 <ReinH> red__: and you are checking for duplicate elements?
22:35:58 <ReinH> red__: if so, you can just ignore Nothing elements altogether:
22:36:14 <ReinH> :t let nodups [] = True; nodups (x:xs) = x `notElem` xs && nodups xs in nodups . catMaybes
22:36:14 <lambdabot> Eq a => [Maybe a] -> Bool
22:36:46 <Malar> thanks indiagreen, as johnw pointed out, it looks great.
22:37:14 <ReinH> johnw: duplicate for a pointed list would give a pointed list of all possible pointed lists :)
22:37:45 <johnw> yep, it's a canonical example for store-type comonads
22:38:17 <ReinH> red__: out of curiosity, why are you writing a sudoku solver?
22:40:26 <red__> ReinH: thanks .. i wrote the function pretty quickly. i was just wondering if there was a library version of something along those lines
22:41:33 <red__> ReinH: i thought a naive version would be a good start .. i wanted to learn a bit about constraint programming
22:41:37 <ReinH> red__: no, it doesn't see like a very common thing to do with [Maybe a] values :)
22:42:42 <red__> and i'm pretty pisspoor with haskell and wanted a small project to play with
22:42:45 <ReinH> Well, you can certainly write a Sudoku solver as a constraint problem
22:43:50 <ReinH> A constraint solver is a bit overpowered for sudoku, but it's not a bad way to learn about constraint solving
22:44:38 <jle`> i wonder if just a list monad thing is enough to solve a single sudoku in a resonable amount of time
22:45:13 <ReinH> jle`: you can do a lot just with laziness and pruning a la Bird
22:45:38 <red__> bird's book scares me .. i haven't touched the sudoku chapter yet
22:45:59 <ReinH> red__: The sudoku chapter is significantly easier than the rest imo http://www.cs.tufts.edu/~nr/cs257/archive/richard-bird/sudoku.pdf
22:46:08 <ReinH> I think it should have been chapter 1
22:46:26 <red__> that is good to hear!
22:46:33 <red__> i'll dig in, then
22:46:39 <ReinH> it's a very elegant solution
23:22:29 <lightquake> anybody here familiar with vty-ui? I want to toy around and make a simple roguelike, but I'm not sure how to handle drawing the 'map' part
23:23:04 <lightquake> if I was using ncurses I'd just use raw console-drawing primitives, but it doesn't look like vty-ui wants me to do that
23:31:50 * hackagebot fay-dom 0.5 - DOM FFI wrapper library for Fay  http://hackage.haskell.org/package/fay-dom-0.5 (AdamBergmark)
23:41:50 * hackagebot yesod-fay 0.7.0 - Utilities for using the Fay Haskell-to-JS compiler with Yesod.  http://hackage.haskell.org/package/yesod-fay-0.7.0 (MichaelSnoyman)
23:44:20 <mrsElectron> what do dot . do? I see it sometimes
23:45:00 <ReinH> mrsElectron: (.) is function composition
23:45:08 <mrsElectron> meaning?
23:45:15 <ReinH> :t (.)
23:45:16 <lambdabot> (b -> c) -> (a -> b) -> a -> c
23:45:32 <ReinH> @src (.)
23:45:32 <lambdabot> (f . g) x = f (g x)
23:45:55 <ReinH> f . g says to apply f to the result of applying g to x
23:46:48 <mrsElectron> (f . g) x,  is just some syntax for f ( g x)?
23:46:50 * hackagebot json-schema 0.7.2.0 - Types and type classes for defining JSON schemas.  http://hackage.haskell.org/package/json-schema-0.7.2.0 (AdamBergmark)
23:47:22 <mrsElectron> what's the point? It's just harder to read
23:47:38 <ReinH> It allows you to build up functions by composing other functions together
23:47:55 <ReinH> function composition is the basic building block of functional programs
23:48:35 <ReinH> If you want to sum the even integers in a list, you can say f xs = sum (filter isEven xs) or you can say f = sum . filter isEven
23:48:46 <kadoban> mrsElectron: You don't write it like that. You do  someFunc = blah . something, or you use it in higher-order functions directly
23:49:31 <mrsElectron> I think I get it. For now, that's satisfying :).
23:49:33 <ReinH> mrsElectron: it's not syntax, it's the definition of the (.) operator
23:50:26 <ReinH> In Haskell, names that contain symbols are considered operators, like (.), (+), (==)
23:50:33 <ReinH> = is special syntax
23:50:35 <ReinH> the rest are just names
23:50:40 <mrsElectron> a.b.c  returns a function   a (b (c X)) where X is some argument if c takes any
23:51:12 <ReinH> mrsElectron: c must take an argument or (.) will not typecheck, but other than that you are correct
23:51:36 <johnw> for example, map (f . g) xs is considered more readable and clear than map (\x -> f (g x)) xs
23:51:45 <ReinH> most Haskellers prefer to write f x = foo (bar (bazz (bizz x))) as f = foo . bar . bazz . bizz
23:52:48 <ReinH> composition also lets you define functions without referring to a named argument, called "pointfree style" (the arguments are the points, not the dots)
23:56:50 * hackagebot wai-app-static 3.0.0.3 - WAI application for static serving  http://hackage.haskell.org/package/wai-app-static-3.0.0.3 (MichaelSnoyman)
