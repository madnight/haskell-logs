00:00:48 <tempay> I think I need to be more explicit about keeping state, I don't think iterate is the right function
00:00:50 <tempay> thanks everyone
00:04:35 * hackagebot tinylog 0.12.0 - Simplistic logging using fast-logger.  http://hackage.haskell.org/package/tinylog-0.12.0 (ToralfWittner)
00:29:36 * hackagebot reflection-without-remorse 0.9.2 - Efficient free and operational monads.  http://hackage.haskell.org/package/reflection-without-remorse-0.9.2 (AtzeVanDerPloeg)
00:44:37 * hackagebot type-aligned 0.9.1 - Various type-aligned sequence data structures.  http://hackage.haskell.org/package/type-aligned-0.9.1 (AtzeVanDerPloeg)
00:49:37 * hackagebot type-aligned 0.9.2 - Various type-aligned sequence data structures.  http://hackage.haskell.org/package/type-aligned-0.9.2 (AtzeVanDerPloeg)
00:49:39 * hackagebot type-aligned 0.9.3 - Various type-aligned sequence data structures.  http://hackage.haskell.org/package/type-aligned-0.9.3 (AtzeVanDerPloeg)
00:55:35 <slomo> when using a list monad, is there a way to easily add parallelism to solve each of the options in parallel?
00:58:44 <dmj`> slomo: http://chimera.labs.oreilly.com/books/1230000000929/ch04.html
00:59:00 <slomo> dmj`: thanks!
01:02:45 <tdammers> following up on my recent defeat re. image magick; I wonder what a good way would be to generate PNG images in a multithreaded haskell app
01:02:56 <tdammers> magick and GD both hate threads
01:03:37 <dmj`> tdammers: diagrams ? writePNG :: String -> Point -> Render () -> IO ()
01:04:32 <Ralith> tdammers: DIY? PNG isn't that complicated a format.
01:04:56 <Ralith> given that you only need to care about the one format you're outputting
01:05:03 <tdammers> Ralith: I'd rather not reinvent any wheels
01:05:23 <Ralith> there comes a point at which that's not a reasonable excuse
01:05:37 <tdammers> yes, but I don't believe I have reached that point yet
01:05:38 <Ralith> you wouldn't pull in a library to get the text "Hello, world!" as a constant
01:05:44 <tdammers> I like to choose my wheels wisely
01:05:45 <Ralith> why should you pull in a library to get the PNG header?
01:05:53 <dmj`> tdammers: what's wrong with diagrams?
01:06:04 <tdammers> dmj`: haven't looked at it enough :D
01:06:10 <Ralith> I think you're really overestimating the difficulty
01:06:17 <Ralith> of course, if diagrams works, that's great too
01:06:32 <Ralith> might be too high level for your purposes though
01:06:49 <dmj`> it's worth a look, don't know what kind of pngs you want, not sure diagrams does text yet. It's darn cool though
01:06:59 <tdammers> I don't need text
01:07:11 <tdammers> I'm generating a heatmap to overlay on top of a leaflet map
01:07:45 <dmj`> there's a backend renderer for pngs
01:07:45 <dmj`> http://hackage.haskell.org/package/diagrams-0.2.2.2/docs/Graphics-Rendering-Diagrams-Engine.html
01:08:01 <tdammers> so basically, iterate over all the pixels in a tile, for each pixel, transform coordinates to lat/long, find heat value, transform into a suitable color, write pixel
01:08:13 <tdammers> and then dump the whole thing as PNG
01:08:52 <tdammers> I'll look into diagrams, but my first impression is that it might be too high-level
01:09:46 <dmj`> it might be for your needs, worth a look
01:26:19 <mietek> Is there a way to ask GHC or Cabal for the identifier that is "x86_64-linux-ghc-7.8.3"?  What is the proper name for this identifier?
01:28:55 <shachaf> Where does that string come up?
01:29:34 <shachaf> Ah, a directory in .cabal/lib
01:29:39 * hackagebot data-lens-light 0.1.2.1 - Simple lenses, minimum dependencies  http://hackage.haskell.org/package/data-lens-light-0.1.2.1 (RomanCheplyaka)
01:31:57 <mietek> shachaf: not just there
01:32:00 <Geekingfrog> I'm working my way through the examples of http://learnyouahaskell.com/making-our-own-types-and-typeclasses#algebraic-data-types and I have a problem when trying to load an example in ghci, when I define the class Eq. error is: Ambiguous occurrence `Eq'. How do I fix that?
01:32:20 <mietek> shachaf: for example, this is part of the path do the data-dir, holding runtime data files, like /app/share/x86_64-linux-ghc-7.8.3/tryhaskell-0.0
01:32:32 <mietek> s/do/to/
01:34:37 * Geekingfrog is stupid
01:34:47 <mietek> I'm looking at https://github.com/haskell/cabal/blob/master/Cabal/Distribution/Simple/Build/PathsModule.hs
01:34:52 <mietek> But it's kind of... unclear
01:34:55 <Geekingfrog> module Practice where \n import Prelude hiding (...)
01:36:14 <shachaf> Geekingfrog: You could also just call it something else.
01:36:46 <mietek> shachaf: getDataFileName is supposed to return the path I pasted
01:36:54 <mietek> Well, files inside that path
01:37:01 <mietek> And it does.
01:37:23 <mietek> I'd just like to know how Cabal gets the identifier, and whether I can get it without invoking runhaskell at least
01:38:21 <mietek> String-based runtime codegen makes me frown
01:39:02 <dcoutts> mietek: x86_64-linux-ghc-7.8.3 comes from $arch-$os-$compiler
01:39:20 <dcoutts> which is currently used as the default libsubdir
01:39:31 <dcoutts> the default libsubdir template
01:40:07 <mietek> dcoutts: yes. Is there a way to ask cabal-install for this identifier?
01:40:11 <dcoutts> https://github.com/haskell/cabal/blob/master/Cabal/Distribution/Simple/InstallDirs.hs#L215
01:40:42 <mietek> Or, the entire path
01:41:04 <dcoutts> display compilerId, display os, display arch
01:41:54 <dcoutts> mietek: it's not an identifier really, it's just a way to make the install paths not overlap
01:42:17 <mietek> Sure. I am lacking the proper name to refer to whatever it is.
01:42:18 <dcoutts> mietek: the user can select any install paths they like
01:42:36 <dcoutts> mietek: it's not really a thing, it's just part of the default install path template
01:42:49 <dcoutts> that the user can override in their config file or on the command line
01:42:50 <osa1> hiding things using explicit exports list is good but makes testing harder ;-(
01:43:22 <dcoutts> mietek: it's certainly not a platform identifier on its own, like a gnu configure triple, if that's what you're thinking
01:43:29 <mietek> dcoutts: when you say "display"... what do you mean?
01:43:34 <dcoutts> the function display
01:43:38 <dcoutts> from the Cabal lib
01:44:04 <mietek> Right. So, not exposed in cabal-install?
01:44:09 <dcoutts> e.g. display Distribution.System.buildOS
01:44:35 <dcoutts> mietek: this comes from the Cabal lib
01:44:47 <mietek> I can ask Idris, for example, to give me `idris --libdir`
01:45:07 <mietek> Which makes it easier to package stuff
01:45:19 <mietek> I guess I'll just add yet another workaround.
01:46:01 <luite> dcoutts: speaking of CompilerId and non-overlapping paths. what's your opinion on dealing with this for the derived compilers extension? removing parentCompiler makes CompilerId by itself insufficient for nonoverlapping paths, adding a version tag could fix that, but the tag inside Version is deprecated
01:47:04 <dcoutts> mietek: what are you actually trying to do?
01:47:13 <mietek> dcoutts: work around data-files not supporting real globs
01:47:25 <dcoutts> ooh, ok
01:47:31 <mietek> i.e. allow the user to declare files to copy into the runtime data-dir
01:47:48 <mietek> For which I just need the path to the data-dir
01:48:02 <dcoutts> which you have
01:48:12 <dcoutts> in the Paths module
01:48:14 <mietek> I only have it if I launch a Haskell process
01:48:14 <osa1> any ideas about how to test internals without exposing them? can I have a CPP macro that is only defined when building tests?
01:48:28 <mietek> So I need to make a dummy Haskell program to run with runhaskell, at least
01:48:47 <mietek> What I would like to have is the ability to say `cabal display compilerId`, from the command-line
01:48:52 <mietek> Which I thought was what you said
01:48:52 <mietek> :)
01:49:03 <luite> mietek: Cabal now stores it in the InstalledPackageDB, but that's only since a week
01:49:26 <dcoutts> luite: so your point is that ghcjs-x built with ghc-y is a different compiler to ghcjs-x built with ghc-z?
01:49:30 <luite> in the master branch, still unreleased
01:49:45 <luite> dcoutts: at least it has incompatible interface files
01:50:09 <dcoutts> luite: so for compilers like that, then yes we need to include the info into the compiler id
01:50:31 <dcoutts> luite: but note that this doesn't go for all compilers, even derived ones. They rules they follow will be particular to the compiler.
01:50:40 <Aleksejs> hello, is there any forum engine written on haskell?
01:51:04 <mietek> Aleksejs: this isn't exactly a forum, but https://github.com/thoughtbot/carnival
01:51:32 <dcoutts> mietek: I don't know that cabal display compilerId makes a lot of sense, it's not uniquely determined
01:52:00 <dcoutts> and what it says now doesn't tell you about other things that are already installed
01:53:20 <luite> dcoutts: sure. in general it's safer to err on the side of more uniqueness, since that usually would just lead to a bit more reinstallations
01:54:07 <dcoutts> luite: or at least we would need to have that extra info available to use when we need it. The problem is we use compiler id for various things, like referring to it, as well as for things like paths
01:54:35 <luite> dcoutts: but switching to a version tag field would work fine too
01:54:53 <dcoutts> luite: and users want to refer to ghcjs, without having to specify the extra, but obviously when we use the paths then we want the extra info. We may just need two types.
01:55:28 <dcoutts> luite: also, we almost certainly only find out the ghc version when we configure the compiler. But the compiler id is a universal thing, prior to configuring.
01:55:29 <luite> dcoutts: i think the CompilerId is always built by the D.S.CompilerName backend?
01:56:08 <dcoutts> luite: in the build system, but it's used elsewhere. For example when anyone wants to resolve a configuration of a .cabal file, which lots of tools do.
01:56:57 <luite> dcoutts: well, this would be very similar to the GHC CompilerId prior to configuring, you just don't know either the version number or tag
01:57:10 <dcoutts> luite: we should probably move this conversation to #ghc
01:57:20 <luite> dcoutts: but for resolving you need to have configured already, since the version has to be known
01:57:23 <luite> ok
01:58:09 <tdammers> juicy pixels... any experience with that one?
01:58:26 <tdammers> from the descriptions, it looks like it does what I need
02:01:45 <gfixler> Am I wrong in thinking that <- is sort of like the impure version of -> ?
02:03:23 <gfixler> i.e. -> is "transform a value through a pure function," and <- is "obtain a value from an impure function"
02:03:23 <bernalex> gfixler: on so many levels that I'm not sure how to even address it. :-]
02:03:29 <gfixler> woow
02:04:15 <bernalex> -> is just an arrow. "Int -> Int" could be written "a Int Int" where a has kind *->*->*. "->" in the type signature is really just a fancy type variable.
02:04:35 <gfixler> or even -> is "let's generate a value inside the code," and <- is "let's pull in a value from outside the code"
02:04:36 <bernalex> also there are no impure functions in haskell bar unsafePerform & friends
02:05:05 <bernalex> @let f xs = do { x <- xs ; return x }
02:05:08 <lambdabot>  Defined.
02:05:09 <bernalex> f [1..5]
02:05:16 <bernalex> what impurities are you talking about here? :-]
02:05:18 <bernalex> > f [1..5]
02:05:19 <lambdabot>  Ambiguous occurrence ‘f’
02:05:19 <lambdabot>  It could refer to either ‘L.f’, defined at L.hs:203:1
02:05:19 <lambdabot>                        or ‘Debug.SimpleReflect.Vars.f’,
02:05:19 <lambdabot>                           imported from ‘Debug.SimpleReflect’ at L.hs:118:1-26
02:05:19 <lambdabot>                           (and originally defined in ‘simple-reflect-0.3.2:De...
02:05:22 <bernalex> oh lord
02:05:31 <gfixler> you broke everything
02:05:35 <bernalex> @let gfixler xs = do { x <- xs ; return x }
02:05:36 <lambdabot>  Defined.
02:05:40 <bernalex> > gfixler [1..5]
02:05:42 <lambdabot>  [1,2,3,4,5]
02:05:44 <gfixler> oh great, now it'll be my fault
02:06:07 <jle`> there's always @undefine :)
02:06:11 <gfixler> this is why I asked - so <- isn't necessarily pulling in values from other dimensions
02:06:23 <bernalex> @undo { x <- [1..5] ; return x }
02:06:23 <lambdabot> <unknown>.hs: 1: 1:Parse error: {
02:06:26 <bernalex> @undo do { x <- [1..5] ; return x }
02:06:26 <lambdabot> [1 .. 5] >>= \ x -> return x
02:06:34 <bernalex> ^ that's what <- is
02:06:45 <gfixler> I don't know what this @undo thing is still
02:06:56 <bernalex> it desugars do-notation
02:07:08 * gfixler should have guessed that one
02:07:10 <bernalex> @undo do { print "hello" >> " world!" }
02:07:10 <lambdabot> print "hello" >> " world!"
02:07:19 <bernalex> erm
02:07:22 <bernalex> @undo do { print "hello" ; " world!" }
02:07:22 <lambdabot> print "hello" >> " world!"
02:07:26 <tdammers> wut?
02:07:29 <bernalex> right ok I'm too tired for this lol
02:07:34 <bernalex> @undo do { print "hello" ; print " world!" }
02:07:34 <lambdabot> print "hello" >> print " world!"
02:07:37 <bernalex> there we go.
02:07:41 <tdammers> print "hello" >> "world" -- how does this even type check?
02:07:55 <bernalex> tdammers: *not*.
02:07:59 <tdammers> ya
02:08:01 <bernalex> undo doesn't typecheck things.
02:08:15 <Maxdamantus> print could return a String
02:09:02 <bernalex> @pointless f xs = putStrLn return xs . xs + read 5 - "hallo"
02:09:02 <lambdabot> f = subtract "hallo" . (read 5 +) . ((.) =<< putStrLn return)
02:09:05 <bernalex> tdammers: ^ :-P
02:09:10 <gfixler> I keep having this image of all my pure code freaking out and running away when a value appears via getLine
02:09:42 <Maxdamantus> > let print = id in do { print "hello" ; " world!" }
02:09:44 <lambdabot>  " world! world! world! world! world!"
02:09:51 <bernalex> gfixler: your code is still pure. getLine isn't impure. it gives you a set of instructions that when carried out in runtime will have effects. youc an reason about it like pure code.
02:10:08 <gfixler> hmmmm
02:10:43 <gfixler> are you saying getLine is pure, but creates impure code to run at runtime?
02:10:43 <bernalex> gfixler: IO String is *not* a "String wrapped in an IO". an IO String is an already fully beta-reduced IO action that when performed in RTS will have an effect.
02:11:10 <tdammers> the scary part isn't that getLine has effects - the scary part is what you do with the String that it produces when executed
02:11:11 <bernalex> gfixler: more or less.
02:11:20 <solatis> jesus, they should rename @pointless to @obfuscate
02:11:21 <tdammers> (typically something like `read` or so)
02:11:29 <gfixler> I admit, this feels a tad hand-wavey
02:11:33 <augur> i thought where's were multi-clausal
02:11:42 <augur> huh.
02:11:47 <augur> oh gosh scrollback.. ffffff
02:11:51 <quantum-mechanic> when do i use a map and when do i need to use comprehensions ?
02:11:55 <tdammers> gfixler: it's not hand-waiving, just an important distinction
02:11:55 <bernalex> solatis: "pointless" is a way more punny way of getting the point acress though :-]
02:12:01 <quantum-mechanic> are they interchangable?
02:12:02 <bernalex> quantum-mechanic: when you'd like!
02:12:04 <bernalex> quantum-mechanic: yes!
02:12:16 <gfixler> tdammers: getLine feels impure to me, because I have no idea what I'm going to get from it at runtime
02:12:18 <solatis> bernalex: i'm afraid to admit, i missed that.. point
02:12:47 <quantum-mechanic> thanks bernalex
02:13:04 <mietek> dcoutts: perhaps I should rephrase my question. Is it possible to ask cabal-install what is the libsubdir which is going to be used during this particular copy operation?
02:13:28 <tdammers> > map (const "yo") [ print "Hello", return (), putStrLn "oy vey!" ]
02:13:29 <lambdabot>  ["yo","yo","yo"]
02:13:39 <tdammers> gfixler: ^ nothing impure about that
02:13:52 <dcoutts> mietek: this info is emitted during configure as a status message for the user (if you use -v)
02:14:03 <gfixler> tdammers: that's all output, though
02:14:17 <dcoutts> mietek: as you know, none of cabal's commands are really designed as a machine interface producing readily parsable output.
02:14:22 <mietek> Yep
02:14:35 <mietek> Thanks
02:14:37 <tdammers> > map (const "yo") [ getLine >>= print, getLine >>= putStrLn, print "Nope" ]
02:14:38 <lambdabot>  ["yo","yo","yo"]
02:14:41 <tdammers> doesn't matter
02:14:48 <gfixler> oh, right, const
02:14:54 <bernalex> in scale const might launch missiles. that's funny to me.
02:14:59 <solatis> tdammers: but but.. that's just haskell being lazy, right?
02:15:05 <bernalex> consider "const f g". in scala, both f & g will be executed, lol!
02:15:09 <tdammers> solatis: no
02:15:10 <gfixler> tdammers: okay, that gets me a step closer
02:15:19 <gfixler> but we're really just ignoring getLine now
02:15:25 <tdammers> solatis: even if I force *evaluation* of those list elements, it would still not *execute* them
02:15:39 <mietek> dcoutts: "Data files installed in: /app/share/x86_64-linux-ghc-7.8.3/hello-1.0" all right
02:15:42 <gfixler> but I recognize that this shows that getLine isn't necessarily doing impure things until it's run
02:15:51 <solatis> because they're never consumed?
02:16:05 <tdammers> solatis: no, because they are never fed to the runtime
02:16:16 <Maxdamantus> > seq (print 4) "foo"
02:16:18 <lambdabot>  "foo"
02:16:20 <bernalex> gfixler: I'm not sure "impure" makes a lot of sense at runtime. I mean, it's runtime. the CPU is getting hotter. there's entropy all around regardless of what the program does.
02:16:21 <solatis> yeah thats (probably) what i mean
02:16:26 <Maxdamantus> > seq (print 4) (print 5)
02:16:27 <lambdabot>  <IO ()>
02:16:34 <Maxdamantus> O_o
02:16:36 <gfixler> tdammers: sounds like semantics around the idea of thunks
02:17:02 <Maxdamantus> Hm, so lambdabot doesn't execute IO actions.
02:17:06 <gfixler> bernalex: I've entered a state of mental flux - I'm open to suggestions and possibilities
02:17:08 <solatis> bernalex: besides, gamma waves, random bit shifts, etc
02:17:11 <bernalex> gfixler: also note that getline is not a side-effect at runtime, because in Haskell things like getline are *explicitly typed* as IO String. i.e. they are an *effect*, not a *side-effect*. you can always tell that something might have an effect in runtime thanks to IO.
02:17:13 <mietek> dcoutts: that is perfectly parseable :)
02:17:17 <tdammers> gfixler: it's not
02:17:20 <augur> gfixler: getLine is sort of impure. it depends on what you mean by "pure"
02:17:35 <gfixler> getLine is going to get me a string if it gets run
02:17:39 <gfixler> I just don't know what the string will be
02:17:46 <tdammers> getLine >>= print, for example, is an IO action
02:17:48 <augur> gfixler: specifically, its impure if you mean "has an effectful monadic type" but thats the wrong way to think about it
02:17:50 <gfixler> so maybe that isn't impure
02:17:53 <bernalex> gfixler: ... getline is *maybe* going to give you a string when performed at runtime.
02:17:54 <solatis> gfixler: it can throw an error, tho
02:18:01 <bernalex> gfixler: ^C won't give you a string, likely :-]
02:18:03 <augur> gfixler: the right way is this: something is impure if the type **doesn't** include the effects
02:18:03 <tdammers> it doesn't matter whether it's thunked or not, the action is the action, and as such, it is pure
02:18:11 <gfixler> bernalex: doesn't that quit the program?
02:18:11 <solatis> what if stdin doesn't exist?
02:18:15 <gfixler> hmmm
02:18:21 <augur> gfixler: because the type of getLine mentions IO, its pure
02:18:22 <gfixler> okay, now you're all arguing my point, I think - it's impure
02:18:23 <bernalex> gfixler: yeah, what about your so-called String now? where is it? :-]
02:18:24 <phaskell> No symbol 'it' found anywhere.
02:18:39 * gfixler searches pockets for a String
02:18:41 <bernalex> gfixler: so is this:
02:18:45 <bernalex> > let a = 2 in a
02:18:46 <lambdabot>  2
02:18:48 <solatis> gfixler: i think we're just all arguing for the sake of it
02:18:52 <augur> gfixler: no what im saying is, its only impure if you use a very simple, and generally not very good, notion of purity
02:18:59 <gfixler> solatis: I need the argument - I want to learn
02:19:10 <augur> gfixler: the true is that it's 100% pure, because the effects have been reified into the type level
02:19:15 <Maxdamantus> augur: what would be an example of something impure because it has a type that doesn't mention IO?
02:19:18 <solatis> yeah, the crux is not the 'getLine' function, but it's about the definition of 'pure'
02:19:22 <solatis> so this is all just semantics
02:19:29 <bernalex> pure means something very specific
02:19:39 <bernalex> pure means that there's a weak equivalence between call-by-need and call-by-value.
02:19:40 <augur> Maxdamantus: well, everything in haskell is impure in a different way -- errors are implicit
02:19:54 <gfixler> you guys have successfully removed all of my notions of what impurity even is, or that it even exists
02:19:55 <augur> bernalex: there is no agreed upon meaning for purity
02:19:57 <gfixler> I'm tabula rasa
02:20:01 <gfixler> so we can start fresh
02:20:14 <bernalex> augur: this one is agreed-upon enough, and cited frequently in CS research. by myself as well.
02:20:25 <solatis> bernalex: there are other conflicting definitions of 'pure', tho
02:20:37 <gfixler> I looked up purity recently
02:20:39 <bernalex> solatis: are they by researchers trying to actively define pure?
02:20:39 <augur> bernalex: so are many other meanings.
02:20:45 <solatis> well
02:20:57 <gfixler> it means all data comes from the arguments or function body
02:20:59 <bernalex> augur: none that I can think of are as established as this one.
02:21:02 <solatis> google says something different.. and google is always right, not?
02:21:08 * Maxdamantus doesn't see errors as impurity.
02:21:12 <solatis> https://en.wikipedia.org/wiki/Pure_function
02:21:15 <Maxdamantus> they're predictable.
02:21:20 <bernalex> Maxdamantus: errors are impure if they just happen
02:21:22 <solatis> yes, i know, wikipedia is not necessarily true, yadayada
02:21:25 <gfixler> and also that the same inputs always yield the same outputs
02:21:25 <bernalex> Maxdamantus: if you have Error a, they are not.
02:21:27 <Maxdamantus> as much so as results.
02:21:36 <augur> bernalex: very common is: no side effects, referential transparency, etc
02:21:38 <gfixler> the problem with getLine is that I can type anything, and you get back different results all the time
02:21:45 <solatis> https://en.wikipedia.org/wiki/Pure_function#I.2FO_in_pure_functions
02:21:49 <solatis> that's interesting tho
02:21:50 <bernalex> augur: those things are just symptoms
02:22:01 <bernalex> augur: the definition I gave captures all of those
02:22:04 <augur> gfixler: no no thats not true
02:22:08 <pantsman> gfixler: purity is a syntactic property, it allows you to rearrange your code without changing the meaning of th eprogram.
02:22:14 <augur> gfixler: with getLine, you never get back different things
02:22:17 <gfixler> Maxdamantus: slippery slope - you'll start respecting errors, and programming with them
02:22:21 <gfixler> Maxdamantus: and then you'll have Python
02:22:27 <augur> gfixler: the VALUE of getLine is always precisely the same
02:22:41 <gfixler> augur: are we back to thunks?
02:22:42 <solatis> so, the big question is.. how do monads relate to function purity?
02:22:49 <Maxdamantus> gfixler: I'm not saying they're good, just not a violation of purity.
02:22:52 <bernalex> I think gfixler just gave us the crux of why they are misunderstanding purity, and augur can take it from here :-] going back to programming now
02:23:03 <augur> gfixler: no. its nothing more or less than a code
02:23:09 <Welkin> as soon as I realized I was implementing my own error handling in some functions I was writing tonight, I immediately rewrote them to let the type-checker take care of it
02:23:13 <gfixler> pantsman: that's a new way to define it for me
02:23:15 <augur> gfixler: the right way to think about IO (even tho this is not how its implemented) is like this
02:23:22 <bernalex> solatis: monads & purity is 100% completely orthogonal
02:23:53 * gfixler awaits augur's insights
02:24:08 <vanila> solatis, monads let you express effectful computations in a pure language
02:24:12 <augur> gfixler:   data IO a where   GetLine :: IO String  ;  PutLine :: String -> IO ()  ;  Return :: a -> IO a  ;  (:>>=) :: IO a -> (a -> IO b) -> IO b
02:24:28 * gfixler is blown away by 120-character insight
02:24:39 <solatis> gfixler: it even fits in a tweet!
02:24:50 <augur> gfixler: the right way is to think of it EXACTLY as a datatype like that
02:25:12 <solatis> i think the big take-away here is IO a -> (a -> IO b) -> IO b -- every IO action depends upon another IO action
02:25:18 <augur> IO is nothing more or less than a data type that represents IO code
02:25:33 <augur> sobaken: no, only (:>>=) does
02:25:36 <augur> er, solatis
02:25:53 <augur> obviously, sequencing IO actions does, but thats what bind is for
02:25:56 <gfixler> I feel like we've thrown referential transparency out of the discussion entirely
02:25:59 <solatis> right
02:26:12 <augur> gfixler: as we should, because RT is a very poorly understood concept that everyone fucks up
02:26:12 <solatis> gfixler: yes, please don't bother us with it again
02:26:23 <gfixler> but... but
02:26:32 <solatis> no, gfixler, just... no
02:26:35 <gfixler> you guys are killing me - I thought that was the whole point
02:26:56 <augur> gfixler: point of?
02:27:19 <gfixler> I thought the whole point of IO was to separate out the non-referentially transparent stuff from the pure stuff
02:27:26 <augur> no
02:27:28 <bernalex> gfixler: everything is referentially transparent
02:27:38 <vanila> gfixler, that's right
02:27:43 <gfixler> I'm missing something then
02:27:45 <augur> the point of IO, and monads in general, is to make reasoning about code easier. especially equational reasoning
02:27:49 <bernalex> gfixler: getline is already fully beta-reduced
02:27:55 <augur> referential transparency is a tangential issue
02:28:01 <gfixler> bernalex: I only [sort of] know what eta reduction is - not beta
02:28:21 <gfixler> augur: then what's all this talk of purity in haskell?
02:28:22 <bernalex> gfixler: beta reduction is like "5 + 2" can be reduced down to 7
02:28:24 <solatis> @where referential transparency
02:28:24 <lambdabot> I know nothing about referential.
02:28:29 <solatis> @where rt
02:28:29 <lambdabot> I know nothing about rt.
02:28:38 <augur> gfixler: oh gosh, if you dont know what beta reduction is, and barely know eta, you should be reading more foundational stuff
02:28:40 <bernalex> gfixler: getline cannot be reduced down to a string. it is already a fully reduced IO action.
02:28:51 <gfixler> I can't believe that 11 months into learning about Haskell, now I'm hearing that RT is not important or interesting
02:28:53 <vanila> gfixler, Haskell is purely functional but you can express effectful computations in it anyway, using monads
02:28:55 <augur> gfixler: stop reading about this stuff and immediately go watch Pfenning's intro to proof theory
02:28:56 <augur> gfixler:
02:28:59 <augur> @where oplss2012
02:28:59 <lambdabot> https://www.cs.uoregon.edu/research/summerschool/summer12/curriculum.html
02:29:04 <solatis> i don't know what orthogonal means.. i should probably be heading to #haskell-beginners :)
02:29:09 <solatis> or rather, #math-beginners
02:29:23 <augur> gfixler: RTness _IS_ important and interesting!
02:29:33 <vanila> I agree with augur there
02:29:39 <augur> gfixler: but that doesnt mean they're relevant to monads/IO :)
02:29:45 <augur> it* rather
02:29:45 <gfixler> I can see the space where my confusion lies, but not its internals
02:29:52 <tdammers> also, "monads" and "IO" are two mostly orthogonal issues
02:30:03 <bernalex> solatis: orthogonal means that two objects at right angles are perpendicular to each other. what it means here simply "independent of each other"
02:30:22 <vanila> It is related to monads though, because monads are the technique we use to do this in a pure language
02:30:33 <tdammers> the fact that IO can be expressed monadically is kind of convenient, but it is not fundamental to understanding either
02:30:39 <augur> vanila: well, one of the techniques
02:30:43 <gfixler> it feels like I'm saying "But what about the values that come in from the user at the keyboard?"
02:30:50 <nh2_work> gfixler: it is very possible though to grasp all relevant bits of how things can be reduced for any practical purpose without diving much into theore, depending on what your preferences are
02:30:53 <tdammers> vanila: we could do it without monads, no problem
02:30:57 <gfixler> and everyone else is saying "No no, we're just talking about the actions that the IO monad creates"
02:31:07 <augur> gfixler: aha yes
02:31:07 <solatis> bernalex: yeah i was able to google that, but i keep forgetting it, since it's a term i don't use (haven't used) in my day-to-day life a lot
02:31:11 <tdammers> putStrLn "Hello!" -- represents an action which, when run, will print "Hello!\n"
02:31:12 <bernalex> gfixler: the values that come in are in RTS not haskell
02:31:16 <gfixler> nh2_work: not in *this* room :)
02:31:16 <tdammers> nothing monadic about that
02:31:16 <solatis> (not a CS graduate here)
02:31:18 <augur> gfixler: those are essentially not your concern in programming
02:31:35 <bernalex> gfixler: think of IO as a DSL that writes a program which when run will have effects
02:31:41 <gfixler> augur: which things aren't my concern?
02:31:42 <tdammers> the point is that "running an action" is not something Haskell itself can do
02:31:45 <augur> gfixler: that is to say, every haskell program is a meta-program programming the haskell execution widget
02:32:00 <gfixler> tdammers: ah ha - so you've removed impurity by kicking it out of haskell entirely
02:32:06 <gfixler> you blame it on the runtime system
02:32:08 <tdammers> yes, pretty much
02:32:10 <bernalex> gfixler: this is how we solve things in haskell, yes
02:32:11 <tdammers> :D
02:32:11 <gfixler> what's that written in, java?
02:32:13 <augur> gfixler: when you write a program in haskell, that's what you're doing -- producing an IO value, which is precisely a bit of code that the executor can run
02:32:15 <bernalex> gfixler: we define problems out of existence. :-]
02:32:19 <gfixler> you guys blaming java for this?
02:32:22 <gfixler> lol
02:32:23 <vanila> the runtime is in assembly code
02:32:29 <vanila> talking about java seems odd
02:32:39 <gfixler> just yesterday I learned that bottoms are just 'left out' of categories by mathematicians
02:32:45 <gfixler> seemed *awfully* convenient to me
02:33:01 <vanila> yes, its convenient not to include bottom
02:33:02 <bernalex> gfixler: you know how main has type IO (), right?
02:33:08 <gfixler> bernalex: yes
02:33:11 <augur> gfixler: thats how you can and should think of it. when you write this:   getLine >>= \x -> putLine x   you should think of that sa nothing more or less than a program which writes some lower-level code
02:33:15 <augur> because thats what it is
02:33:22 <bernalex> gfixler: you can beta-reduce all haskell programs down into one pure "IO ()" action
02:33:41 <bernalex> gfixler: and you can reason about this action and all other IO actions in a pure and nice way
02:33:45 <gfixler> augur: that's filling in the blurry void for me a bit
02:34:06 <gfixler> bernalex: right - graph reduction, equals for equals, it's all one big expression, etc?
02:34:16 <bernalex> gfixler: yes.
02:34:21 <pantsman> gfixler: think of your IO value as being a tree of all possible command-response routines. When you run the same program more than once, you may receive different commands, but it is still executed against the same tree. And because IO is pure, you can refactor programs in IO while guaranteeing not to alter that tree.
02:34:30 <gfixler> bernalex: I had that epiphany a few months ago - realized that = isn't assignment in Haskell - it's definition
02:34:41 * hackagebot haskell-names 0.5.0 - Name resolution library for Haskell  http://hackage.haskell.org/package/haskell-names-0.5.0 (PhilippSchuster)
02:34:52 <bernalex> gfixler: beta-abstraction and -reduction is substituting equals for equals, like 5 + 5 can be reduced to 10 and it's the exact same thing.
02:34:57 <gfixler> pantsman: that's a really neat way to view it
02:35:05 <bernalex> gfixler: yes we have actual mathematical variables, not "variables".
02:35:10 <gfixler> pantsman: so it *is* pure, provided I do the same things when I run it again
02:35:19 <bernalex> gfixler: we also have functions instead of "functions". welcome to the future (as of 1990 or so).
02:35:20 <gfixler> bernalex: let's call them truths, or something
02:35:36 <bernalex> gfixler: they come from maths. C and those languages are the ones that got the terminology wrong.
02:35:39 <gfixler> omg, in 1990 I was about 1 year out from starting coding in gw basic
02:35:53 <tdammers> gfixler: the haskell code is pure; the IO action is always the same, just like the output of your C compiler is (ideally) always the same for the same input
02:35:56 <bernalex> I don't think C are going to start using appropriate category theory terminology though.
02:35:59 <pantsman> gfixler: it is pure, if your notion of purity is syntactic
02:36:15 <gfixler> tdammers: it sounds like your trying to sell me on Nix
02:36:21 <gfixler> "the executable will hash to the same value!"
02:36:34 <tdammers> but if you run that C program, its behavior is going to be impure, just like the behavior of the Haskell runtime executing your pure action
02:36:47 <tdammers> hehe, I'm not even using Nix myself
02:36:54 <gfixler> are any of us?
02:36:55 <solatis> so the haskell program is pure, but the execution is impure?
02:36:58 <gfixler> I want to be using NixOS
02:36:59 <pantsman> discussing purity of executing code has no meaning
02:37:02 <solatis> i am using nixos
02:37:10 <solatis> it's the best choice of my life
02:37:10 <tdammers> constructing the program is pure; running it is not.
02:37:11 <gfixler> solatis: fancy
02:37:13 <bernalex> solatis: saying "the execution is pure" makes no sense
02:37:15 <pantsman> unless you find a different definition of purity to the syntactic one
02:37:16 <pantsman> 
02:37:22 <tdammers> constructing the program is what we do in Haskell; running it is left to the runtime
02:37:28 <gfixler> tdammers: so I should just not run these things, and I'll be fine
02:37:29 <augur> solatis: more or less thats the thing you want to say with haskell
02:37:39 <bernalex> solatis: yes, your CPU gets hot at runtime, so I guess it's impure? or pure? it doesn't matter very much.
02:37:45 <augur> sofancy_: the idea is, you force all the true impurity out to the place where you LITERALLY cannot avoid it
02:37:59 <gfixler> augur: sounds a lot like late-binding
02:38:00 <augur> damnit, solatis^^
02:38:10 <bernalex> augur: sure you can avoid it
02:38:12 <gfixler> I love late-binding
02:38:19 <bernalex> augur: first versions of haskell had no IO. it was a riveting success. :-P
02:38:30 <augur> bernalex: no no
02:38:32 <augur> what i mean is
02:38:42 <augur> you can push the impurity out and out and out
02:38:46 <solatis> augur: you mean you force all impurity out where you *can* avoid id?
02:38:51 <solatis> it
02:38:52 <gfixler> bernalex: what did they do, hook up an oscilloscope to the CPU?
02:38:53 <augur> and eventually you cant not be impure when you're touching the real world
02:39:13 <bernalex> augur: ah yes. my original point. the CPU is getting warm. :-]
02:39:14 <augur> you cannot avoid impurity at the interface between program and world
02:39:20 <augur> but everywhere else, you can simulate
02:39:22 <solatis> ok, i understand
02:39:32 <solatis> so you try to hide the impurity for as long as you can
02:39:51 <pantsman> I feel that to newcomers, purity is either over-sold or misunderstood as giving stronger guarantees than it really does.
02:39:56 <solatis> so you can still (mathematically) reason about a program
02:39:58 <augur> so by insulating in this way, we can reason completely about the non-IO parts of haskell without COMPLETE certainty about whats going to happen
02:39:58 <gfixler> so getLine is pure, because it's not a function that gets inpute; it's a function that creates code that gets input
02:40:06 <solatis> pantsman: to me, it meant 'having no side effects' and f(x) == f(x)
02:40:24 <gfixler> pantsman: I was sold pretty hard - a little deflated right now
02:40:24 <augur> the only place haskell becomes uncertain, where we dont know, is IO
02:40:30 <bernalex> gfixler: getline is not a function.
02:40:42 <gfixler> bernalex: third base!
02:40:50 <augur> and more over, in doing it this way, the reasoning becomes easy/easier
02:40:56 <bernalex> gfixler: getline is an IO action that when performed in RTS might deliver a String.
02:41:01 <pantsman> gfixler: it's still a pretty useful property, once you understand how to take advantage of it
02:41:04 <solatis> augur: well that is the only thing CPUs start to become interesting... so we have a problem here :)
02:41:05 <bernalex> @quote ls
02:41:05 <lambdabot> Vellos says: I TYPE IN CAPS BECAUSE I WANT ALL THESE PIXELS TO ADD TO MY PENIS LENGTH
02:41:07 <bernalex> hm
02:41:13 <bernalex> @quote list of files
02:41:13 <lambdabot> No quotes for this person. Wrong!  You cheating scum!
02:41:15 <bernalex> gah
02:41:24 <bernalex> someone help me out :-P
02:41:36 <gfixler> @quote files
02:41:36 <lambdabot> ghc says: Splices are not allowed in hs-boot files
02:41:41 <gfixler> there you go
02:41:53 <augur> Soft: not really. sometimes we write programs just to run them down and spit out some stuff, not to interact
02:42:08 <augur> the only real time that things get shady is input
02:42:11 <gfixler> augur: all of my haskell so far has been that way
02:42:13 <Guest-3088> that's helpful
02:42:35 <bernalex> Guest-3088: oh I got it!
02:42:36 <bernalex> erm
02:42:39 <bernalex> gfixler:
02:42:44 <bernalex> @quote shachaf getline
02:42:44 <lambdabot> shachaf says: getLine :: IO String contains a String in the same way that /bin/ls contains a list of files
02:42:56 <bernalex> :-]
02:43:00 <vanila> When the runtime interprets the IO action m >>= f, it will execute m and then pass control back to haskell by inserting the result into f
02:43:35 <solatis> augur: i'm starting to laugh at how many time you can write solatis wrong ;)
02:43:43 <augur> solatis: tab complete :(
02:43:49 <solatis> i know
02:43:57 <augur> stupid limechat has no idea how to use context
02:43:59 <augur> its ridiculous
02:44:12 <augur> these people arent talking, why are they tab-completing? its ridiculous
02:44:12 <gfixler> augur: how does your tab complete work? sol<Tab> gets me solatis
02:44:26 <augur> gfixler: im just doing s-tab or so-tab
02:44:33 <augur> s-tab works now, interestingly
02:44:38 <solatis> and now?
02:44:39 <gfixler> weird, s-tab gets me "so"
02:44:48 <augur> so-tab is sohum
02:44:51 <solatis> lol
02:45:12 <augur> that makes 0 sense
02:45:25 <gfixler> these name-tabs all seems awfully non-referentially-transparent
02:45:38 <augur> lol
02:45:42 <augur> im going to bed
02:45:42 <augur> night!
02:45:48 <gfixler> thanks for the help - night!
02:46:13 <solatis> well, there was probably some developer rationale 'if you are typing at least 2 characters, you're not replying in an active conversation but looking for someone specific, so the most reasonable thing to do is to select someone that is *not* part of the active conversation'
02:46:27 <solatis> at least, in my experience, that's how these decisions are made
02:46:33 <augur> thats stupid
02:46:41 <augur> its just not true
02:46:42 <augur> anyway
02:46:43 <augur> night
02:46:45 <solatis> nn
02:47:19 <gfixler> me: oh, so it's a b? #haskell: No, you're thinking about it backwards
02:47:30 <gfixler> me: ah, so then... b a? #haskell: there is no b
02:47:46 <gfixler> me: so, a? #haskell: a is actually b
02:47:49 <ChristianS> solatis: i think most clients are not that smart, they just pick the first user that start with the letter combination. i get solarus when i type sol<tab>
02:48:01 <vanila> gfixler, not everyone agrees or explains clearly and consistent with each other
02:48:02 <gfixler> me: so... b? #haskell: as and bs don't exist
02:48:35 <augur> vanila: except me, im clear and consistent and of course correct
02:48:37 <gfixler> me: c? #haskell: you're imaginary
02:48:42 <augur> ((wasnt i going to bed?? hm))
02:48:50 <solatis> ChristianS: that's silly and is a major UI issue
02:49:23 <solatis> if there is one thing i want my irc client to get correct, it's auto-completion of nicknames
02:49:45 <solatis> and no it is not that hard
02:49:53 <vanila> well maybe implement it
02:49:57 <gfixler> weechat supposedly does it right
02:50:01 <vanila> if you do it well it could be accepted into the code
02:50:05 <solatis> guess which irc client i use..
02:50:09 <gfixler> I'm using irssi, and it's usually what I expect
02:50:17 <solatis> i went from irssi -> weechat
02:50:20 <solatis> best choice ever
02:50:27 <solatis> before going to nixos, of course
02:50:34 <ChristianS> solatis: it's not *that* silly and i get your name if i type sol<tab><tab>, but i agree it could be smarter
02:50:41 <gfixler> solatis: I was going to guess "ImpureTabEffectsClient 2.0"
02:50:48 <solatis> gfixler: haha
02:51:33 <solatis> i think we can all agree here that sorting nickname-autocompletion based on 'most recently spoken' makes the most sense
02:51:47 <gfixler> there's an interesting ratio that I'm starting to see
02:51:54 <pantsman> gfixler: when you've used haskell for a while you get a sense for what purity really means. People in #haskell have trouble putting that into coherent words for newcomers.
02:52:04 <gfixler> in languages like Python, theres' a kind of 90% certainty about things that are probably 70% wrong
02:52:10 <solatis> it's not like i'm sorting things alphabetically in my head when i'm using autocomplete, so it makes no sense to present me the suggestions in alphabetical order
02:52:22 <gfixler> in Haskell, I'm using things that are like 90% guaranteed, but I'm about 20% certain what any of it is
02:52:42 <augur> gfixler: after a recency threshold, it should default to most-frequently-used (by the user)
02:52:57 <gfixler> augur: haha, you still going on about tab completion?
02:53:04 <augur> or alphabetical. and give the user control
02:53:12 <gfixler> :)
02:53:13 <solatis> gfixler: what's amazing that, as long as you use safe libraries, how often when things compile, they actually work correctly first attempt
02:53:14 <augur> gfixler: what? no im asleep, this is my agent program!
02:53:15 <augur> >_>
02:53:16 <augur> <_<
02:53:25 <gfixler> <=<
02:53:27 <gfixler> >>
02:53:38 <solatis> oh god, the fish operator
02:53:47 <gfixler> your agent program is smarter than the tab completer
02:53:53 <tdammers> solatis: you should read up on intercal
02:53:54 <gfixler> we should just hook those two up
02:54:05 <tdammers> solatis: they have alternative names for all the characters that the language uses
02:54:17 <augur> solatis: i thought <>< was the fish
02:54:19 <bernalex> augur: I find a tab-completion order based on least recently active user quite useful.
02:54:22 <solatis> tdammers: only if you read up on brainfuck
02:54:23 <augur> and <=< was the missile
02:54:32 <tdammers> double quotes are called "rabbit ears", for example
02:54:32 <SwashBuckla> no way is (<><) an operator
02:54:40 <tdammers> brainfuck, been there, done that
02:54:40 <solatis> SwashBuckla: haha
02:54:44 <bernalex> SwashBuckla: hallo, Simon!
02:54:49 <augur> bernalex: what? why?
02:54:49 <solatis> SwashBuckla: there's a little library you don't know about, obviously..
02:54:51 <SwashBuckla> hallo bernie
02:54:54 <SwashBuckla> how are you?
02:55:00 <augur> bernalex: i mean, it should all be customizable anyway
02:55:03 <bernalex> augur: usually I want to talk to the last recently active person.
02:55:07 <bernalex> augur: yes, that is true.
02:55:19 <augur> its not like customizing this stuff is hard
02:55:23 <bernalex> SwashBuckla: I'm doing OK I guess. busy hacking haskell. how's the job? you settling in?
02:55:32 <solatis> SwashBuckla: http://hackage.haskell.org/package/plumbers-0.0.3/docs/Control-Plumbers.html
02:55:33 <gfixler> most inactive person is great for upping participation
02:55:34 <solatis> ^
02:55:42 <solatis> look at that humongous list of operators
02:55:52 <solatis> i'm pretty sure (<><) is a part of it
02:57:23 <SwashBuckla> bernalex: I am jelly
02:57:49 <SwashBuckla> bernalex: I've been working through CIS194 (Brent Yorgey's intro course), adding QuickCheck property tests as I go
02:58:07 <SwashBuckla> bernalex: work is a bit dull, but stable/secure. I'm gaining financial security
02:58:18 <bernalex> SwashBuckla: what kind of tech?
02:58:19 <SwashBuckla> bernalex: I rarely code for work
02:58:23 <bernalex> SwashBuckla: ah
02:58:53 <SwashBuckla> bernalex: it's application support/writing SQL/stored procedures/VBScripts (seriously)
02:59:11 <SwashBuckla> it was a job I landed in a tight spot as I'd burned through my student loan
02:59:46 <bernalex> SwashBuckla: well financial security and having work experience on your CV is good I guess.
02:59:53 <SwashBuckla> yeah
03:00:13 <Zol_> I'm trying to manually find the type of: (.)(.), but I find it really difficult to do. Should I start from left to right, or other direction, which way is usually easier?
03:00:39 * SwashBuckla looks at solatis' link. My eyes  o_O
03:00:53 <bernalex> Zol_: making it pointful is easier
03:01:00 <SwashBuckla> lol
03:01:03 <vanila> Zol_, it's syntax directed you can type check f x by checking f then x then applying the application rule
03:01:45 <Zol_> vanila: Ah, thanks!
03:02:16 <bernalex> Zol_: consider instead: f g h i j = g h (i j)
03:02:45 <bernalex> I *think* that's right lol
03:03:16 <vanila> http://lpaste.net/115092
03:03:20 <vanila> here's a starter
03:03:51 <Zol_> vanila: Why do the two first lines differ?
03:04:08 <vanila> its to make it easier to understand
03:04:22 <Zol_> Oh, yeah, forgot about partially applied functions?
03:06:44 <chrisdone> type holes are gonna be awesome
03:06:54 <chrisdone> i can't wait to be able to write
03:06:58 <chrisdone> Foo -> _ -> Bar
03:07:07 <chrisdone> and then go to _ and get emacs to expand it for me
03:09:26 <gfixler> chrisdone: Hole-driven Haskell?
03:09:37 <pantsman> any hole's a goal
03:10:28 <chrisdone> i don't remember what the proposal calls it
03:10:32 <chrisdone> maybe type wild cards or something
03:10:47 <chrisdone> https://ghc.haskell.org/trac/ghc/wiki/PartialTypeSignatures
03:11:01 <IRCNanny> The last link has been flagged by IRC NANNY as "Possibly Unsuitable". Please find your parent(s) first and have them check the content before opening. [this channel protected by IrCNaNNY by SafeSoft v1.0b]
03:11:13 <chrisdone> IRCNanny: get lost
03:11:33 <gfixler> chrisdone: I meant this - have you seen it? https://www.youtube.com/watch?v=52VsgyexS8Q
03:11:42 <chrisdone> sure
03:11:56 <gfixler> just checking - it would be crazy if you were excited about holes and hadn't
03:12:05 <chrisdone> that's about value level holes
03:12:13 <gfixler> ah, I see the distinction
03:12:26 <gfixler> this is starting to feel like Idris
03:12:58 <chrisdone> i tend not to used the TypedHoles functionality now
03:13:29 <chrisdone> i just insert an undefined and then query the type
03:14:48 <bernalex> chrisdone: why not just leave out the typesig entirely? GHC usually figures it out and then you can use emacs or vi or whatever to insert it automatically.
03:17:09 <chrisdone> bernalex: dunno. if you've never written your own type-sig, this feature probably isn't for you
03:17:58 <bernalex> chrisdone: I write type signatures way before I write any code. I write docs between those activities.
03:19:16 <pantsman> PartialTypeSignatures looks like it is only really useful for the cases where GHC can't infer the full type signature.
03:19:34 <pantsman> or for whatever reason you want to over-constrain it to something narrower than what GHC infers
03:19:38 <osa1> if I enable two lines here http://lpaste.net/115094 (and disable last line, of course) it fails with "thread blocked indefinitely in an MVar operation" any ideas how can this happen?
03:19:54 <osa1> getChanContents is from Control.Concurrent.Chan
03:20:14 <bernalex> pantsman: yes. and that happens very rarely in my experience. unless I'm deep into some databasewebservertestframework-burrito from hell, I can write them fully myself. and when I'm in that situation, GHC will infer the full thing for me.
03:21:44 <osa1> it looks like the exceptions is thrown when reading from channel. is this possible?
03:21:57 <pantsman> bernalex: and you don't want holes in your burrito.
03:22:14 <bernalex> pantsman: no, imagine that. it'd be a right mess!
03:24:47 <osa1> interesting. that should not work but I'd expect it to fail with something else
03:26:20 <bernalex> is there a way to not cut the output of :i in GHCi short?
03:26:53 <bernalex> or maybe it isn't cut short and something is just broken somewhere...
03:30:17 <jang> quick question, which is obviously OO-inspired. Sorry about that. Is it possible to create two typeclasses, A a and B b, and specialise a function f :: a -> b -> something? (ie, select behaviour on the basis of "more than one" argument, to put it informally)?
03:36:12 <bernalex> can I print all instances of a typeclass in GHCi somehow?
03:36:24 <bernalex> yes I can! neat
03:37:40 <bitonic> jang: I don't understand the question
03:37:46 <bitonic> can you give a concrete example?
04:09:45 * hackagebot varan 0.5 - Process mpileup output to identify significant differences  http://hackage.haskell.org/package/varan-0.5 (KetilMalde)
04:16:22 <jang> bitonic: the concrete examples I've got in mind are complex. I'm basically asking if multiple typeclasses can be used to do something like "multiple dispatch" for selecting a particular function implementation. Er, let me give you a contrived example.
04:17:20 <m_m> Hi. I am seraching the most active haskell web framework. With good databases support, and documentation.
04:17:36 <jang> let's say I have a Prefix and a Suffix typeclass, and I want to write a "concatenate" function whose implementation somehow tacks the suffix onto the prefix. Theactual implementation of the concatenation function depends on the concrete types that are instances of Prefix and Suffix, respectively
04:18:07 <vanila> jang, I think you can use multiple parameter typeclasses
04:18:15 <vanila> just one class, but it has two varibles
04:18:19 <jang> oh-ho, I'd not heard of those. Those sound likely
04:18:29 <wei2912> m_m: i've heard of yesod, not sure about others.
04:18:37 <jang> right. Now I've got a phrase I'll go and read up on it. Thanks!
04:19:10 <m_m> wei2912: Yesod have orm or something simmilar ?
04:19:40 <wei2912> m_m: not certain abt that
04:19:52 <jang> vanila: that's _precisely_ what I'm looking for. thanks
04:24:12 <chpatrick> does anyone know if it's possible to access the parent name referred to on this page? https://ghc.haskell.org/trac/ghc/wiki/Commentary/Compiler/NameType
04:24:28 <chpatrick> Name seems to be opaque
04:25:32 <chpatrick> in particular how to resolve someImplementationOfReturn -> GHC.Base.return
04:27:46 <ski> perhaps #ghc would know
04:37:02 <Th30n> hello everyone
04:37:21 <Th30n> i'll be doing a simple web server as an exercise in haskell
04:37:36 <Th30n> what framework do you recommend? something that is easy to learn?
04:47:02 <nh2_work> Th30n: what exactly do you want to learn? How to accept requests and serve some byte strings back? In that case, take a look at a minimal server library like Scotty. Want to explore a full web framework with HTML templating and everything? You could look at Yesod, Snap and Happstack. I've used yesod in the past and it has a nice comprehensive book written by the authors: http://www.yesodweb.com/book
04:47:59 <Th30n> nh2_work: I've done some web servers before with node.js and Java, wanted to try it in Haskell.
04:50:07 <nh2_work> Th30n: still the question remains: are you mainly interested in the server+routing bit, e.g. look for an equivalent to Express.js? Scotty. Full stack framework that deals with templating, HTML forms, sessions, database connection? Yesod and friends
04:50:24 <Th30n> nh2_work: I'll look at last three. I was thinking of doing something like a simple tweeter/facebook. You know per user data with the ability to upload content or delete.
04:51:23 <Th30n> nh2_work: Full stack is what I need
04:51:44 <tdammers> Th30n: yesod is pretty heavy - super powerful, but heavy, and a lot of concepts to grok before you get productive beyond running a scaffolded site
04:52:12 <tdammers> Th30n: if you start with scotty, you'll have an easier time understanding how stuff fits together
04:52:36 <Th30n> tdammers: anything in between?
04:52:39 <tdammers> scotty doesn't have templating or persistence, but you can integrate other libraries for that
04:52:47 <nh2_work> Th30n: check out https://ocharles.org.uk/blog/posts/2013-12-05-24-days-of-hackage-scotty.html and the tutorial linked from it
04:52:48 <tdammers> it's pretty straightforward, really
04:53:07 <tdammers> oh, and there's also happstack and snap, they're both somewhat in between yesod and scotty in terms of weight
04:53:24 <tdammers> I like happstack, but I don't know how actively it is developerd
04:53:27 <tdammers> -r
04:54:06 <nh2_work> Th30n: the post shows off scotty itself, the linked post shows how you can combine it with your own templating. Then you'll have a rough idea of how things fit together, and have a better point of dealing with all-in-one solutions that the big frameworks offer.
04:56:32 <Th30n> nh2_work: yeah just skimmed through the post. Looks like scotty will actually be enough for what I'm interested
05:10:17 <Th30n> Thanks! I'll probably take scotty. It's simple, I'll probably learn more and more gradual than jumping into likes of Yesod and it seems it's easy tu plugin additional libraries when needed.
05:17:32 <RayNbow`TU> :t zip
05:17:33 <lambdabot> [a] -> [b] -> [(a, b)]
05:18:05 <RayNbow`TU> does a more generalized notion of zip exist?
05:18:10 <vanila> :t zipWith
05:18:11 <lambdabot> (a -> b -> c) -> [a] -> [b] -> [c]
05:18:18 <vanila> this one takes a "combiner" function
05:18:22 <RayNbow`TU> as in, one that does not work with lists?
05:18:26 <vanila> and you can recover the original zip with zipWith (,)
05:34:48 * hackagebot gimlh 0.1.0.0 - Haskell parser for GIML  http://hackage.haskell.org/package/gimlh-0.1.0.0 (gazay)
05:36:35 <wei2912> does haskell have a built-in tree data structure?
05:36:51 <tdammers> wei2912: not built into the language itself, no
05:37:05 <tdammers> wei2912: but you can easily build one yourself
05:37:12 <tdammers> wei2912: or use one of the existing ones
05:37:31 <tdammers> data Tree a = Leaf a | Branch [Tree a]
05:37:34 <tdammers> for example
05:38:09 <wei2912> tdammers: thanks
05:38:31 <tdammers> thing is, there is more than one possibly useful tree structure, so you can't just provide a one-size-fits-all solution
05:38:47 <tdammers> data Tree a = Node a [Tree a] -- is another useful tree-like structure
05:38:57 <wei2912> yeh
05:39:04 <wei2912> i'm just looking for a generic tree, nothing else
05:39:04 <tdammers> data Tree a = Leaf a | Branch a a
05:39:14 <tdammers> that would be a binary tree
05:39:31 <tdammers> anyway, I believe there's a Data.Tree somewhere or something like that
05:39:41 * wei2912 is too lazy to draw a tree in ASCII and was hoping that a library had such a function
05:39:55 <tdammers> yes, here it is: http://hackage.haskell.org/package/containers-0.5.5.1/docs/Data-Tree.html
05:40:03 <wei2912> thanks!
05:49:30 <clrnd> it has a drawing funciton, nice
05:54:49 * hackagebot hs-gen-iface 0.5.0 - Utility to generate haskell-names interface files  http://hackage.haskell.org/package/hs-gen-iface-0.5.0 (PhilippSchuster)
06:04:49 * hackagebot call 0.1.0.1 - The call game engine  http://hackage.haskell.org/package/call-0.1.0.1 (FumiakiKinoshita)
06:09:50 * hackagebot Agda 2.4.2.2 - A dependently typed functional programming language and proof assistant  http://hackage.haskell.org/package/Agda-2.4.2.2 (AndresSicardRamirez)
06:09:51 * hackagebot Deadpan-DDP 0.3.0.1 - Write clients for Meteor's DDP Protocol  http://hackage.haskell.org/package/Deadpan-DDP-0.3.0.1 (LyndonMaydwell)
06:10:56 <gigabytes> Hi all
06:11:46 <gigabytes> I've written a function that takes a function of type s -> a -> (b,s) and turns it into a MonadState s m => a -> m b
06:12:18 <gigabytes> Was it something like that already into some standard library?
06:12:36 <Yuras> @hoogle state
06:12:36 <lambdabot> Control.Monad.Trans.RWS.Lazy state :: (Monoid w, Monad m) => (s -> (a, s)) -> RWST r w s m a
06:12:36 <lambdabot> Control.Monad.Trans.RWS.Strict state :: (Monoid w, Monad m) => (s -> (a, s)) -> RWST r w s m a
06:12:36 <lambdabot> Control.Monad.Trans.State.Lazy state :: Monad m => (s -> (a, s)) -> StateT s m a
06:12:42 <Iceland_jack> There is 'state'
06:12:48 <lengzai> Control.Monad.State
06:13:07 <gigabytes> ouh
06:13:10 <gigabytes> exactly XD
06:13:48 <gigabytes> and s -> s to m () ?
06:14:50 * hackagebot uuid 1.3.5 - For creating, comparing, parsing and printing Universally Unique Identifiers  http://hackage.haskell.org/package/uuid-1.3.5 (AntoineLatter)
06:15:03 <Yuras> @hoogle withState
06:15:03 <lambdabot> Control.Monad.Trans.State.Lazy withState :: (s -> s) -> State s a -> State s a
06:15:03 <lambdabot> Control.Monad.Trans.State.Strict withState :: (s -> s) -> State s a -> State s a
06:15:03 <lambdabot> Control.Monad.State.Lazy withState :: (s -> s) -> State s a -> State s a
06:15:16 <Yuras> not exactly though :)
06:15:28 <gigabytes> modify
06:15:32 <gigabytes> @hoogle modify
06:15:33 <lambdabot> Control.Monad.Trans.RWS.Lazy modify :: (Monoid w, Monad m) => (s -> s) -> RWST r w s m ()
06:15:33 <lambdabot> Control.Monad.Trans.RWS.Strict modify :: (Monoid w, Monad m) => (s -> s) -> RWST r w s m ()
06:15:33 <lambdabot> Control.Monad.Trans.State.Lazy modify :: Monad m => (s -> s) -> StateT s m ()
06:15:33 <nshepperd> wouldn't that be called 'modify' or something
06:15:39 <nshepperd> oh yeah that
06:15:53 <gigabytes> cool
06:15:54 <Yuras> ah, yes, modify
06:15:56 <bitonic> is there any TH facility to derive Bifunctor?
06:16:56 <lpaste> Lengzai pasted “Snake” at http://lpaste.net/5614566856342896640
06:17:07 <lengzai> hey all
06:17:28 <lengzai> i could use a little bit of help trying to abstract what's happening in main
06:17:32 <lengzai> does anyone have a suggestion?
06:18:17 <vanila> lengzai, this looks like state monad
06:18:40 <lengzai> but if it's state monad how can i print it?
06:18:46 <nshepperd> StateT IO
06:19:17 <bitonic> lengzai: use foldM
06:19:50 <lengzai> :t foldM
06:19:51 <lambdabot> Monad m => (a -> b -> m a) -> a -> [b] -> m a
06:20:17 <bitonic> lengzai: `foldM (\act snake -> putScreen (paintSnake snake screen) >> return (moveSnake snake act)) snake0 [DOWN, DOWN, UP, ...]' or something like that
06:20:32 <bitonic> if you want something more sophisticated StateT is the way to go
06:20:37 <bitonic> but if you just want to debug
06:20:49 <lengzai> alright, I'll have to do some reading on monad transformers then
06:21:02 <bitonic> lengzai: well, you don't have to, you can just use foldM for now :)
06:21:05 <bitonic> or just write a loop
06:21:09 <lengzai> ok
06:21:13 <lengzai> thanks!
06:21:27 <nshepperd> oh yeah foldM seems more sensible for testing
06:21:33 <nshepperd> or a manual loop
06:28:28 <clrnd> in that paste the linter says "Use init... Note: increases laziness"
06:28:43 <clrnd> that's some funny wording
06:30:07 <lengzai> XD
06:30:21 <lengzai> such a beautiful language
06:30:22 <lengzai> and lazy
06:31:52 <narendraj9> clrnd: what's the name of the drawing function?
06:32:09 <narendraj9> clrnd: Sorry. I am talking about Data.Tree
06:32:25 <clrnd> narendraj9, drawTree
06:32:35 <narendraj9> clrnd: Thanks.
06:32:44 <clrnd> no problemo :D
06:33:13 <narendraj9> clrnd: :-D
06:34:14 <adamse> I'm writing data List (n :: Nat) e where ... using GHCs TypeLits, but i'm having trouble implementing a fromList :: [e] -> List n e function
06:34:29 <adamse> does anyone have a implementation i can look at?
06:35:05 <Iceland_jack> adamse: You can't write a function with that type since you don't know the length of the list [e]
06:36:26 <adamse> Iceland_jack: I'm ok it being partial
06:37:08 <adamse> fromList :: (KnownNat n) => [e] -> List n e is the type I'm currently working with
06:39:17 <pyon-free> Is there any online site for running Haskell snippets that use de facto standard libraries that do not come by default with GHC (lens, parsec, etc.)?
06:39:46 <alpounet> pyon-free: fpcomplete's online IDE i guess
06:39:47 <adamse> pyon-free: FPcompletes haskell center IDE
06:40:25 <pyon-free> Oh, right! Thanks!
06:44:55 <juanpablo_> Question: what would be the best option if I want to have an IO action execute every hour?
06:45:57 <clrnd> juanpablo_, I guess a thread with threadDelay?
06:46:03 <clrnd> and forkIO
06:46:12 <clrnd> what's the context? yesod?
06:46:58 <juanpablo_> clrnd: so just sleep? I guess I could do that. I just wanted to know if there was a cleaner solution...
06:47:20 <clrnd> juanpablo_, I'd personally use unix's cron, most times
06:47:59 <juanpablo_> clrnd: yes, that's probably the best idea. But I can't use cron for some internal reasons. Thanks :)
06:51:02 <adamse> juanpablo_: i do fork and threadsleep
06:51:54 <DqrkdeviL> hi
06:54:52 <nh2_work> juanpablo_: it depends a lot on what time means for you. Looking at the actual getCurrentTime could make your hourly thing execute more on time, but then you might have times where nothing happens for an hour when it's a summer/winter time shift
06:55:35 <nh2_work> juanpablo_: so the first important thing to think about is: do you want hours as time differences, or hours in terms of calendar time
06:56:15 <juanpablo_> nh2_work: ideally it would 1AM, 2AM, etc. But I could do with time differences
06:57:35 <ninja258> hello
06:57:52 <ninja258> why is this so silent?
06:58:15 <tdammers> "this" being #haskell?
06:58:21 <pantsman> hi ninja258
06:58:24 <ninja258> yeah.
06:58:29 <c_wraith> as channels go, this one has a fairly focused topic
06:58:30 <ninja258> hi pantsman
06:58:48 <c_wraith> And it's mostly a help channel.  (not 100%, not even close.  But maybe 60%)
06:58:58 <ninja258> oh.
06:59:00 <ninja258> i see
06:59:18 <ninja258> and help channel means?
06:59:31 <c_wraith> People ask questions about the topic, and often get answers.  (often)
06:59:36 <pantsman> it means people rarely go off-topic and start discussing PHP or C++… oh wait.
06:59:54 <clrnd> or python
07:02:46 <ninja258> oh ;) but no conversation is taking place here. why? everybody joins, then leaves. only those notification messages i'm getting
07:04:27 <zguy> ninja258 you should probably silence those
07:05:30 <Yuras> is there any type-directed autocompletion for vim?
07:05:44 <bitonic> ninja258: loads of conversation is taking place here.  <http://ircbrowse.net/haskell>
07:05:49 <zguy> type-directed?
07:06:19 <ninja258> vim is cramp, use emacs
07:06:36 <Yuras> zguy: that filters obviously wrong suggestions
07:06:38 <hrnz> use vim!
07:06:41 <Yuras> by type
07:06:49 <osfameron> to be fair, I get more cramp from chording (which vim minimizes)
07:06:53 <Yuras> ninja258: emacs is cramp, use vim :)
07:07:30 <Yuras> zguy: I tried something similar 4 year ago: https://www.haskell.org/pipermail/haskell-cafe/2010-September/083154.html
07:07:34 <chrisdone> use god-mode for emacs =p
07:07:43 <Yuras> just found my old email
07:07:46 <ninja258> god mode?
07:07:55 <Yuras> and wonder whether something better exists
07:08:14 <Yuras> because I never got time to finish it
07:08:43 <Yuras> not with type holes it should be pretty easy
07:08:47 <Yuras> *now
07:09:54 <zguy> Yuras: You could write a plugin for NeoVim
07:10:40 <ninja258> somebody please help me. i'm getting all notification here. how can i make this silent?
07:10:54 <Yuras> zguy: hmm, so nobody did that yet :(
07:10:54 <zguy> what irc client are you using?
07:11:02 <ninja258> i use ircii
07:11:50 <zguy> not sure about ircii, but in irssi: '/ignore -channels #channel * JOINS PARTS QUITS NICKS'
07:12:37 <zguy> Yuras: Maybe, I'm just not aware of it. I read some hackish stuff that would do it for some languages
07:13:16 <zguy> It invovled setting up an intelliJ-something server that connected to vim plugin to check your code as your wrote
07:14:17 <zguy> ninja258: replace #channel with whatever channel you want to mute, in this case #haskell
07:19:34 <ninja258> i'm using irsii. how to set channel notifications off?
07:19:51 <ninja258>  
07:19:59 <lpaste> wojtekM_ pasted “What's wrong with my kind code?” at http://lpaste.net/115112
07:20:50 <sivteck> @google i'm using irsii. how to set channel notifications off? -- ninja258 use google or read the manual ;/
07:20:52 <lambdabot> No Result Found.
07:26:10 <JonReed> Hi! What would be the fastest way to register a module? Let's say that I wrote a quick module "mymodule.hs" and I want to use it in "main.hs". Both things are just local scripts, so there is no reason to bother writing setup files and etc. What would be the fastest way to make  mymodule.hs available in main.hs? Right now ghc refuses to see the module even if it's in the same directory and writing Setup.hs for some 5 minute script will
07:26:56 <bergmark> JonReed: the file name needs to be the same as the modul, incl. capitalization
07:27:09 <nh2_work> JonReed: yes, ghc should see it
07:27:19 <nkar> otherwise, it's assumed to be 'Main'
07:28:15 <linduxed> is there some summary of the year for haskell apart from this page? https://www.haskell.org/haskellwiki/Haskell_Communities_and_Activities_Report
07:29:04 <JonReed> So if my module name is Notification.Visual, then I'll have to create a folder Notification and put Notification/Visual.hs?
07:29:14 <zguy> ninja258: I think you're using irssi and just spelled it wrong. There is no irsii
07:29:43 <nkar> JonReed: yes
07:30:12 <JonReed> nkar: oh ok. Thx!
07:30:15 <nkar> np
07:30:34 <zguy> ninja248 type this: '/ignore -channels #haskell * JOINS PARTS QUITS NICKS'
07:30:45 <zguy> no quotes
07:31:25 <meretrix> My attoparsec Parser works on single lines, but when I try to use it with "many" to handle multiple lines, I just get "Partial _".  How do I debug this?
07:31:56 <haasn> zguy: He's no longer in the channel
07:32:05 <haasn> (That's what you get for disabling quits!)
07:32:21 <zguy> haansn: Clearly! XD
07:35:08 <indiagreen> meretrix: are you skipping whitespace/newlines?
07:35:33 <indiagreen> also, since you're getting Partial, have you tried using parseOnly
07:36:03 <indiagreen> (or endOfInput)
07:36:15 <Bastihase> ACHTUNG!!! ---> now guys i search users they have intresst to made an new net and link unrealircd servers .. PN to Bastihase :)
07:36:25 <meretrix> indiagreen: Yes, my single line parser eats up any newlines.
07:37:07 <meretrix> Ah, parseOnlye works.
07:43:14 <meretrix> Why doesn't 'parse (many $ take 1) "abcd"' not work, but 'parseOnly (many $ take 1) "abcd"' does?
07:43:32 <meretrix> Isn't all input consumed, so why would I need parseOnly?
07:43:36 <wei2912> how does it "not work"?
07:43:44 <meretrix> It results in "Partial _".
07:44:11 <alpounet> meretrix: because "many" doesn't restrict the number of times the given parser has to succeed, so technically it could eat some more input
07:44:17 <bitonic> meretrix: because the first one is waiti for more input
07:44:20 <bitonic> it could consume more chars
07:44:37 <meretrix> Oh, so I always should use parseOnly here?
07:45:24 <bitonic> meretrix: well, either that or supply the partial with an empty string
07:45:33 <bitonic> to signal that game's over, no more input
07:45:53 <meretrix> Ok, thanks.
07:46:14 <indiagreen> or add endOfInput to your parser
07:46:27 <indiagreen> but better use parseOnly, I guess
07:46:48 <nh2_work> meretrix, indiagreen: no, I don't think that is the same
07:47:24 <meretrix> Yeah, I tried endOfInput but it doesn't really make sense with "many".
07:47:38 <nh2_work> the reason that attoparsec gives you a Partial even after you have matched endOfInput is that if you actually give the Partial more input, then the parser shall fail (because it wasn't the end of the input)
07:47:47 <indiagreen> ...ah
08:11:24 <mmmm> Is it possible to write a filter function for an indexed vector type?
08:12:31 <Iceland_jack> mmmm: Sure, but the length of the vector you return must be hidden (existential)
08:13:36 <Iceland_jack> In Idris 'filter' has type:
08:13:37 <Iceland_jack>     filter : (a -> Bool) -> Vect n a -> (p ** Vect p a)
08:13:42 <petrus> On archlinux editing haskell files vim started crashing with segmentation faults. I am using haskellmode-vim, and the haskell-core repo. I was wondering if anybody is experiencing the same.
08:13:46 <Iceland_jack> Where 'p' is 'some length'
08:14:22 <bitonic> Iceland_jack: well, it can be more precise than that -- e.g. returning some length which is less than the original one
08:14:58 <bitonic> e.g. storing the difference
08:15:14 <Iceland_jack> That's right, but you can't know the resulting length statically in a sane way
08:16:12 <bitonic> that depends on what you mean by sane :P
08:16:19 <bitonic> but I think storing the difference might be a good compromise
08:16:22 <Iceland_jack> Yes
08:17:28 <bitonic> mmmm: you could be really precise, and have `count : (a -> Bool) -> Vec a n -> Nat; filter : (f : a -> Bool) -> (v : Vec a n) -> Vec a (count f v)'
08:17:58 <bitonic> where `count' counts how many elements respect the predicate in the vector
08:18:46 <mmmm> and how would you promote count to the type level?
08:19:07 <bitonic> mmmm: by using a language with dependent types
08:19:13 <mmmm> :)
08:19:30 <Iceland_jack> mmmm: If you're using Haskell to write this kind of stuff do the simple thing first
08:19:51 <mmmm> I'm just trying to get a handle on what is possible using singletons at the moment
08:20:21 <Iceland_jack> mmmm: Have you implemented the other functions (map, zipWith, vapp, ...)?
08:21:19 <mmmm> yes
08:21:49 <Iceland_jack> mmmm: Try defining a data type that hides the length and then define filter
08:24:35 <mmmm> thanks, did injective type families made it into ghc 7.10?
08:27:46 <Iceland_jack> mmmm: Probably not
08:28:24 <bitonic> mmmm: but type plugins did, iirc!  which means a lot more type-level solving for naturals
08:28:34 <gigabytes> has anybody experience with Data.Boolean.SatSolver from the incremental-sat-solver library?
08:29:01 <gigabytes> I don't understand how to use it to simply have a Yes/No answer
08:29:16 <gigabytes> the assertTrue function returns the solver state into a MonadPlus
08:29:26 <gigabytes> it says "because the result is nondeterministic"
08:29:42 <gigabytes> never used MonadPlus
08:29:55 * hackagebot uhc-light 1.1.7.2 - Part of UHC packaged as cabal/hackage installable library  http://hackage.haskell.org/package/uhc-light-1.1.7.2 (AtzeDijkstra)
08:36:34 <int-e> gigabytes: I have not used the package, but isSolvable looks what you're looking for. assertTrue simplifies clauses, which may lead to a contradiction, in which case there's no point in continuing. (As far as I can see, if m is [], then assertTrue will return either a singleton list or the empty list)
08:37:20 <gigabytes> int-e: I thought it would return a solver instance for all possible assignment that satisfy the formula
08:37:31 <gigabytes> which would mean an empty list for unsatisfiable formulas
08:38:00 <gigabytes> anyway, isSatisfiable takes a Solver, while I get a m Solver
08:38:13 <int-e> gigabytes: assertTrue is not the solver. solve does that.
08:39:07 <gigabytes> int-e: but assertTrue "adds" the formula I want to check, right?
08:39:44 <int-e> gigabytes: right, but that step can succeed even if there is a contradiction already
08:39:49 <gigabytes> so will (null $ assertTrue formula newSatSolver >>= solve) work?
08:40:22 <int-e> gigabytes: that looks correct. (let me stress that I haven't used the library)
08:40:32 <gigabytes> int-e: yes, don't worry
08:40:46 <gigabytes> int-e: but then I can't understand the usefulness of the isSolvable function
08:40:53 <gigabytes> that takes a single solver and returns a boolean
08:41:00 <gigabytes> where am I expected to take that single solver?
08:41:08 <gigabytes> Inside a monadic action anyway, or not?
08:41:34 <int-e> gigabytes: isSolvable is just  not . null . solve
08:41:48 <gigabytes> int-e: ahah
08:41:50 <gigabytes> sounds right
08:42:08 <mmmm> Iceland_jack: Is this the right constructor? data AnyVec a = forall n . AnyVec (Vec a n)
08:44:44 <int-e> gigabytes: finally note that 'solve' may return solvers with partial assignments (i.e. lookupVar can still return "Nothing"); this means that either value for the variable would work.
08:44:55 * hackagebot acme-strtok 0.1.0.0 - A Haskell port of the C/PHP strtok function  http://hackage.haskell.org/package/acme-strtok-0.1.0.0 (eberlm)
08:45:34 <gigabytes> int-e: but since I only need a Yes/No answer, it still works as we said previously, right?
08:46:09 <int-e> gigabytes: right. I'm just mentioning it as a potential pitfall when using DPLL SAT solvers in general.
08:47:55 <gigabytes> int-e: yes of course
08:49:30 <vrs> @pl (\f (g, h) x -> f (g x) (h x)
08:49:30 <lambdabot> (line 1, column 30):
08:49:30 <lambdabot> unexpected end of input
08:49:30 <lambdabot> expecting variable, "(", operator or ")"
08:49:32 <vrs> @pl (\f (g, h) x -> f (g x) (h x))
08:49:32 <lambdabot> (`ap` snd) . (. fst) . liftM2
08:49:36 <vrs> meh
08:49:56 * hackagebot acme-strtok 0.1.0.1 - A Haskell port of the C/PHP strtok function  http://hackage.haskell.org/package/acme-strtok-0.1.0.1 (eberlm)
08:50:14 <int-e> gigabytes: I'd also prefer to use some binding to a more powerful SAT solver like minisat. The solvers really profit massively from arrays at the low level, and clever heuristics for selecting atoms and learning clauses on a higher level.
08:50:22 <vrs> I had hoped forks had a haskell equivalent
08:50:46 <gigabytes> int-e: oh yeah, I'm not really expecting any kind of performance from this experiment
08:50:55 <gigabytes> I need a quick and dirty solution right now
08:51:06 <gigabytes> have you used the minisat bindings?
08:51:11 <int-e> gigabytes: sounds perfect then. have fun :)
08:51:13 <FireFly> vrs: as in J forks?
08:51:17 <vrs> FireFly: yup
08:51:26 <gigabytes> thanks :)
08:51:31 <int-e> gigabytes: can't say I have since I wrote my own at some point (unpublished)
08:51:59 <FireFly> @pl \f g h x -> g x `f` h x
08:52:00 <lambdabot> liftM2
08:52:16 <FireFly> vrs: there's that, which is kinda like a monadic fork
08:52:23 <vrs> ah
08:53:00 <int-e> @type uncurry . liftM2
08:53:02 <lambdabot> Monad m => (a1 -> a2 -> r) -> (m a1, m a2) -> m r
08:54:20 <int-e> @type (`ap` snd) . (. fst) -- uncurry?!
08:54:21 <lambdabot> (b1 -> b2 -> b) -> (b1, b2) -> b
08:54:31 <int-e> fun.
08:54:47 <FireFly> @pl (`ap` snd) . (. fst)
08:54:48 <lambdabot> (`ap` snd) . (. fst)
08:55:00 <int-e> @. pl unpl (`ap` snd) . (. fst)
08:55:01 <lambdabot> join . (((snd >>=) . (return .)) .) . (. fst)
08:55:43 <vrs> > liftM2 (+) fst snd (1,2)
08:55:45 <lambdabot>  3
08:56:42 <FireFly> Heh.
08:57:04 <vrs> fork enough for my purposes
08:57:38 <FireFly> I just realised "like a monadic fork" is a bit punny, didn't even think of the fact that liftM2 is related to Haskell monads at first
08:57:47 <ReinH> Um...
08:57:53 <ReinH> > uncurry (+) (1,2)
08:57:55 <lambdabot>  3
08:59:29 <vrs> ReinH: til
09:04:56 * hackagebot WMSigner 0.1.0.0 - WebMoney authentication module  http://hackage.haskell.org/package/WMSigner-0.1.0.0 (triplepointfive)
09:16:43 <smdiehl> What's the preferred Haskell library for accessing libgit these days?
09:32:53 <favetelinguis> is there a way that i can make a where clause that belongs to only one guard? As in this code http://lpaste.net/115133 i dont want the where clause to be executed when the first guard gets evaluated to true
09:34:34 <monochrom> lazy evaluation will skip them
09:34:57 * hackagebot persistent-zookeeper 0.2.0 - Backend for persistent library using Zookeeper.  http://hackage.haskell.org/package/persistent-zookeeper-0.2.0 (junjihashimoto)
09:35:11 <favetelinguis> ok so it is not the case that thy get evluated before the guards get evaluated
09:35:29 <favetelinguis> since the errors im getting indicating this but then it must be something else
09:35:33 <monochrom> and "where" belongs to all of the guards, not just one. use "let ... in ..." if you want narrower
09:36:15 <favetelinguis> thanks, forgot about let
09:39:57 * hackagebot amazonka-autoscaling 0.0.4 - Amazon Auto Scaling SDK.  http://hackage.haskell.org/package/amazonka-autoscaling-0.0.4 (BrendanHay)
09:39:59 * hackagebot amazonka-cloudformation 0.0.4 - Amazon CloudFormation SDK.  http://hackage.haskell.org/package/amazonka-cloudformation-0.0.4 (BrendanHay)
09:40:01 * hackagebot amazonka-cloudfront 0.0.4 - Amazon CloudFront SDK.  http://hackage.haskell.org/package/amazonka-cloudfront-0.0.4 (BrendanHay)
09:40:03 * hackagebot amazonka-cloudsearch 0.0.4 - Amazon CloudSearch SDK.  http://hackage.haskell.org/package/amazonka-cloudsearch-0.0.4 (BrendanHay)
09:40:05 * hackagebot amazonka-cloudsearch-domains 0.0.4 - Amazon CloudSearch Domain SDK.  http://hackage.haskell.org/package/amazonka-cloudsearch-domains-0.0.4 (BrendanHay)
09:43:32 <matheus23> How is the implementation idea of a lens on a tree exactly?
09:43:57 <matheus23> is there somewhere a _really_ simple implementation of a lens on a tree on the inet?
09:45:08 * hackagebot amazonka-cloudtrail 0.0.4 - Amazon CloudTrail SDK.  http://hackage.haskell.org/package/amazonka-cloudtrail-0.0.4 (BrendanHay)
09:45:10 * hackagebot amazonka-elasticache 0.0.4 - Amazon ElastiCache SDK.  http://hackage.haskell.org/package/amazonka-elasticache-0.0.4 (BrendanHay)
09:45:12 * hackagebot amazonka-elasticbeanstalk 0.0.4 - Amazon Elastic Beanstalk SDK.  http://hackage.haskell.org/package/amazonka-elasticbeanstalk-0.0.4 (BrendanHay)
09:45:14 * hackagebot amazonka-elastictranscoder 0.0.4 - Amazon Elastic Transcoder SDK.  http://hackage.haskell.org/package/amazonka-elastictranscoder-0.0.4 (BrendanHay)
09:45:16 * hackagebot amazonka-elb 0.0.4 - Amazon Elastic Load Balancing SDK.  http://hackage.haskell.org/package/amazonka-elb-0.0.4 (BrendanHay)
09:47:06 <pharpend> matheus23: what kind of tree?
09:47:17 <matheus23> any number of nodes
09:47:20 <matheus23> on each node
09:47:21 <pharpend> matheus23: binary tree? rose tree?
09:47:26 <pharpend> okay, a rose tree
09:47:31 <wei2912> does anyone know how to add a field to a context in hakyll?
09:47:56 <flyingfisch> rose bushes, cherry trees
09:47:59 <matheus23> binary tree probably helps understanding too, though
09:48:14 <pharpend> well, a binary tree would be pretty simple
09:49:16 <pharpend> data BinTree a = Node a (BinTree a) (BinTree a) | Empty
09:50:09 <pharpend> _node :: BinTree a -> Maybe a
09:50:18 * hackagebot amazonka-emr 0.0.4 - Amazon Elastic MapReduce SDK.  http://hackage.haskell.org/package/amazonka-emr-0.0.4 (BrendanHay)
09:50:20 * hackagebot amazonka-iam 0.0.4 - Amazon Identity and Access Management SDK.  http://hackage.haskell.org/package/amazonka-iam-0.0.4 (BrendanHay)
09:50:22 * hackagebot amazonka-importexport 0.0.4 - Amazon Import/Export SDK.  http://hackage.haskell.org/package/amazonka-importexport-0.0.4 (BrendanHay)
09:50:24 * hackagebot amazonka-kinesis 0.0.4 - Amazon Kinesis SDK.  http://hackage.haskell.org/package/amazonka-kinesis-0.0.4 (BrendanHay)
09:50:24 <ReinH> Ooh, maybe he fixed the bug I reported in amazonka-cloudformation... let's see
09:50:26 * hackagebot amazonka-kms 0.0.4 - Amazon Key Management Service SDK.  http://hackage.haskell.org/package/amazonka-kms-0.0.4 (BrendanHay)
09:50:36 <ReinH> Also, I (don't) love that his package updates spam #haskell
09:50:50 <pharpend> ReinH: you can just /ignore hackagebot temporarily
09:52:42 <ReinH> Well, it affects everyone
09:53:19 <ReinH> I suppose it's sort of unavoidable... I agree with the package-per-API decision.
09:53:34 <bitonic> ReinH: but you just found out relevant information thanks to it!  ehe
09:54:46 <ReinH> bitonic: :)
09:55:28 * hackagebot amazonka-lambda 0.0.4 - Amazon Lambda SDK.  http://hackage.haskell.org/package/amazonka-lambda-0.0.4 (BrendanHay)
09:55:30 * hackagebot amazonka-opsworks 0.0.4 - Amazon OpsWorks SDK.  http://hackage.haskell.org/package/amazonka-opsworks-0.0.4 (BrendanHay)
09:55:32 * hackagebot amazonka-rds 0.0.4 - Amazon Relational Database Service SDK.  http://hackage.haskell.org/package/amazonka-rds-0.0.4 (BrendanHay)
09:55:34 * hackagebot amazonka-redshift 0.0.4 - Amazon Redshift SDK.  http://hackage.haskell.org/package/amazonka-redshift-0.0.4 (BrendanHay)
09:55:36 * hackagebot amazonka-route53 0.0.4 - Amazon Route 53 SDK.  http://hackage.haskell.org/package/amazonka-route53-0.0.4 (BrendanHay)
10:00:38 * hackagebot amazonka-route53-domains 0.0.4 - Amazon Route 53 Domains SDK.  http://hackage.haskell.org/package/amazonka-route53-domains-0.0.4 (BrendanHay)
10:00:40 * hackagebot amazonka-s3 0.0.4 - Amazon Simple Storage Service SDK.  http://hackage.haskell.org/package/amazonka-s3-0.0.4 (BrendanHay)
10:00:42 * hackagebot amazonka-sdb 0.0.4 - Amazon SimpleDB SDK.  http://hackage.haskell.org/package/amazonka-sdb-0.0.4 (BrendanHay)
10:00:44 * hackagebot amazonka-ses 0.0.4 - Amazon Simple Email Service SDK.  http://hackage.haskell.org/package/amazonka-ses-0.0.4 (BrendanHay)
10:00:46 * hackagebot amazonka-sns 0.0.4 - Amazon Simple Notification Service SDK.  http://hackage.haskell.org/package/amazonka-sns-0.0.4 (BrendanHay)
10:05:48 * hackagebot amazonka-sqs 0.0.4 - Amazon Simple Queue Service SDK.  http://hackage.haskell.org/package/amazonka-sqs-0.0.4 (BrendanHay)
10:05:50 * hackagebot amazonka-storagegateway 0.0.4 - Amazon Storage Gateway SDK.  http://hackage.haskell.org/package/amazonka-storagegateway-0.0.4 (BrendanHay)
10:05:52 * hackagebot amazonka-sts 0.0.4 - Amazon Security Token Service SDK.  http://hackage.haskell.org/package/amazonka-sts-0.0.4 (BrendanHay)
10:05:54 * hackagebot amazonka-support 0.0.4 - Amazon Support SDK.  http://hackage.haskell.org/package/amazonka-support-0.0.4 (BrendanHay)
10:05:56 * hackagebot amazonka-swf 0.0.4 - Amazon Simple Workflow Service SDK.  http://hackage.haskell.org/package/amazonka-swf-0.0.4 (BrendanHay)
10:10:58 * hackagebot amazonka 0.0.4 - Comprehensive Amazon Web Services SDK  http://hackage.haskell.org/package/amazonka-0.0.4 (BrendanHay)
10:11:00 * hackagebot amazonka-core 0.0.4 - Core functionality, serialisation primitives, and data types for the Amazonka Amazon Web Services SDKs.  http://hackage.haskell.org/package/amazonka-core-0.0.4 (BrendanHay)
10:12:55 <lifter> I have nested "if"s that look like if .. then if .. then if ...is there an idiomatic way to refactor this to make it look less ugly? All I can think of is using a "case" that matches on "True" and "False"...
10:14:25 <knyon> lifter: what's the purpose of the logic? If it's checking for failure (or good path/bad path), then using an Either/EitherT can be a very clean way of handing it
10:14:33 <oliffea> does "Alternative" have laws?
10:14:48 <oliffea> additional*
10:15:05 <michaelt> oliffea: the docs just say 'a monoid' , I think
10:15:25 <oliffea> yeah, thats all
10:15:36 <lifter> knyon: Well, it's code that's in the STM monad, and there is just some complex logic to determine what to return
10:17:28 <knyon> lifter: how many possible choices of things to return are there?
10:17:49 <lifter> 4 :)
10:19:00 <lifter> it just looks a little ugly, but it works fine
10:19:15 <indiagreen> lifter: what about MultiwayIf / the “case ()” trick
10:19:24 <jedai> lifter: you can use an empty "case of" with guards
10:19:50 <jedai> case () of _ | ... -> ; _ | ... ->
10:20:04 <lifter> yeah actually multi-way if might clean it up
10:20:13 <lifter> I didn't think of that. let me try that, thanks
10:21:43 <monochrom> you don't need ; between guards
10:22:16 <indiagreen> you don't need repeating underscores either
10:22:18 <monochrom> > case () of _ | 1<0 -> 'x' | 0<1 | 'y' | 0==1 | 'z'
10:22:20 <lambdabot>  <hint>:1:33: parse error on input ‘|’
10:22:37 <monochrom> > case () of _ | 1<0 -> 'x' | 0<1 -> 'y' | 0==1 -> 'z'
10:22:40 <lambdabot>  'y'
10:23:10 <monochrom> > case () of _ | 1<0 -> 'x' ; | 0<1 -> 'y' ; | 0==1 -> 'z'
10:23:12 <lambdabot>  <hint>:1:29: parse error on input ‘|’
10:23:21 <monochrom> in fact ; will hurt
10:24:38 <monochrom> multiway-if is probably better
10:38:26 <gigabytes> I'm missing the sense of traceIO in Debug.Trace
10:38:41 <gigabytes> if it's a IO action where is the debugging facility?
10:39:24 <Fuuzetsu> anyone know how to get charts to use different granularity for an axis? It insists to use ranges of 10 and I don't know how to change it
10:39:37 <Fuuzetsu> insists on using*
10:41:24 <zmbmartin> Is it possible to read from a stream without removing the first item?
10:41:59 <ReinH> zmbmartin: what sort of stream, and what kind of reading?
10:42:58 <ReinH> Some things that might be considered a stream have a peek operation
10:43:03 <zmbmartin> ReinH: I still don't fully understand as this is new to me, but I think it is an MVar.
10:43:31 <ReinH> peek operations can generally be simulated by pop >>= push
10:43:48 <lifter> so you want to get the value in the MVar and put it back?
10:44:05 <codygman> Anyone used the authentication/authorization in Spock?
10:44:13 <zmbmartin> lifter: Just the first Value
10:44:35 <zmbmartin> ReinH: would your suggestion work?
10:44:37 <davean> ReinH: pop pushL?
10:44:51 <ReinH> An MVar isn't a stream, and doesn't let you peek without removing it, but you can read and then put
10:44:59 <lifter> zmbmartin: Well an MVar is not a stream and it can only contain a single value, or be empty
10:45:47 <ReinH> davean: for some generic pop :: m a, push :: a -> m () ;)
10:45:59 <davean> ReinH: but double ended!
10:46:25 <ReinH> my abstract stream I just made up on the spot is not double ended :p
10:49:12 <ReinH> With an MVar, readMVar is probably what you want
10:49:31 <ReinH> It is more or less a combination of takeMVar and putMVar, returning the value
10:58:09 <zmbmartin> ReinH: so readMVar instead of takeMVar is what I want. I was using take.
10:59:34 <sinelaw> Q: When doing unification (in HM inference), how does this make sense?
10:59:34 <sinelaw> mgu :: Type -> Type -> TI Subst
10:59:34 <sinelaw> mgu (TFun l r) (TFun l' r') =
10:59:34 <sinelaw>     do s1 <- mgu l l'
10:59:34 <sinelaw>        s2 <- mgu (apply s1 r) (apply s1 r')
10:59:35 <sinelaw>        return (s1 `composeSubst` s2)
10:59:36 <sinelaw> ...
10:59:38 <sinelaw> What if the first unification result (s1) doesn't agree with the second one (s2)?
10:59:54 <sinelaw> The `composeSubst` could just hide it
11:00:01 <Cale> Oh, interesting, I hadn't noticed the new guarantee that readMVar is atomic
11:00:45 <Cale> It used to simply be a combination of takeMVar and putMVar, which meant that it could block if another thread did a putMVar in between
11:02:32 <ReinH> Cale: yep, now it's magic with an IO constructor :D
11:03:18 <zmbmartin> ReinH: So using readMVar is safe?
11:04:18 <Cale> zmbmartin: It's safe
11:04:21 <ReinH> yes
11:04:58 <bitonic> ah, I hadn't noticed that either!  that's pretty sweet
11:05:08 <bitonic> it's the more intuitive semantics of `readMVar'
11:06:31 <zmbmartin> ReinH: what about for GHC 7.6?
11:06:40 <bitonic> it's not so sweet in the sense that now programs are going to have subtly different semantics on different GHC versions
11:06:47 <bitonic> but better than nothing ehe
11:07:13 <ReinH> bitonic: well, if you consider a readMVar that can block inbetween the take and put a bug, which I am inclined to do...
11:07:51 <Tantadruj> I have a function `f x y = x + y` and I'd like to see what I get when I partially apply it like `z = f 3`; What would be the way to let me see that `z` now contains `z = 3 + y`?
11:08:29 <bitonic> ReinH: well I agreed already that the new semantics are better -- I'm just saying it's inconvenient that the same functions do subtly different things in different versions
11:08:45 <sinelaw> I'm obviously missing something here - when unifying "a -> a" with "Int -> String", the unification will compose "a = Int" with "a = String" and simply override it. That can't be.
11:08:59 <crobbins> Tantadruj: if you are in a repl use the :t command
11:09:07 <crobbins> you can get the type, that's about it
11:09:36 <crobbins> but yeah, there's no way to get it to build the expression for you
11:10:16 <Tantadruj> crobbins: ok, thanks
11:11:01 <sinelaw> oh never mind. I forgot that you must apply the substitution from the previous  unification step before doing the next one.
11:11:33 <zmbmartin> ReinH: I need to support 7.8 and 7.6. But I am told for 7.6 we could have a deadlock. How can I get around that.
11:12:04 <seangrove> crobbins: So there aren't any tools at all for visualizing or understanding a value beyond just its type?
11:12:49 <chrisdone> sinelaw: yeah it should end up unify (a,Int) = substitute a Int and then it'll be unify (Int,String) = type mismatch
11:13:05 <Cale> zmbmartin: Well, it won't necessarily be a deadlock
11:13:08 <sinelaw> chrisdone, yip, 4 hours of sleep does this to me.
11:13:29 <Cale> zmbmartin: It'll just mean the thread which does the readMVar will block until something else empties the MVar
11:14:09 <zmbmartin> Cale: if another thread puts, that won't cause a deadlock?
11:14:12 <Cale> zmbmartin: (and then it will write back the original value that it read)
11:14:13 <zmbmartin> in 7.6
11:14:28 <chrisdone> sinelaw: i implemented one recently, which is why i know what you're talking about =) https://gist.github.com/chrisdone/516489f4f27846712225#file-type-hs-L240
11:14:33 <Cale> Not necessarily a deadlock. It will block the thread which is doing the readMVar
11:14:56 <Cale> But the thread will be able to proceed once the MVar becomes empty again
11:15:10 <zmbmartin> Cale: So it is still safe to use in 7.6?
11:15:13 <sinelaw> chrisdone, that's very cool!
11:15:16 <Cale> Well, maybe
11:15:21 <Cale> It's a weaker guarantee
11:15:36 <zmbmartin> Cale: any other options?
11:15:39 <Cale> STM
11:15:55 <zmbmartin> Is that the only other option?
11:15:58 <Cale> If you really need transactional behaviour, STM is really great.
11:16:01 <clrnd> joking with this at the office  	This logo program is inappropriate or abusive?
11:16:06 <clrnd> http://code.org/frozen
11:16:16 <Cale> actually, even if you don't really *need* it, STM keeps things nice and sane for you
11:16:18 <clrnd> is there a funuctional logo-like online playground?
11:16:31 <chrisdone> STM <3
11:16:32 <Cale> It is a bit of a performance hit, but often the cost of the operations is negligible anyway
11:16:54 <sinelaw> chrisdone, you aware of the Algorithm W paper/tutorial? http://www.grabmueller.de/martin/www/pub/AlgorithmW.pdf
11:17:09 <sinelaw> chrisdone, and accompnying source https://github.com/wh5a/Algorithm-W-Step-By-Step/blob/master/AlgorithmW.lhs
11:17:49 <zmbmartin> Cale: STM is a perfomance hit?
11:17:52 <chrisdone> sinelaw: that's a complete implementation? so short! =)
11:17:54 <zmbmartin> That might be an issue.
11:18:07 <Cale> zmbmartin: vs. MVar, yes, it requires more bookkeeping
11:18:24 <sinelaw> chrisdone, yeah, basic HM is cool.
11:18:29 <sinelaw> elegant
11:18:42 <Cale> zmbmartin: It's impossible to answer these questions definitively without taking lots of time to understand what the program in question is doing though.
11:19:05 <sinelaw> chrisdone, yours is also short.
11:19:08 <zmbmartin> Cale: I understand that. I appreciate the responses so far.
11:19:34 <Cale> zmbmartin: There are many tradeoffs to be made between cleanliness of semantics and maintainability on the one hand and performance on the other.
11:19:52 <zmbmartin> Cale: true
11:21:29 <chrisdone> sinelaw: i wish people didn't use that weird latex display of haskell code, makes it hard to read
11:21:43 <chrisdone> the .lhs is much easier to read
11:21:52 <sinelaw> chrisdone, you have the .lhs in the second link
11:23:16 <monochrom> some people's fanatism with latex is rather irrational
11:23:56 <sinelaw> If it isn't a postscript fie, I don't read it. (*sips tea*)
11:26:10 <monochrom> I love tea
11:28:18 <sinelaw> it was the metaphorical tea
11:29:30 <chrisdone> tea gives me headaches D:
11:30:03 <zmbmartin> Cale: Did I get miss information? according to haskage readMVar prior to 4.7 was the old behavior. Can GHC 7.6 use base 4.7?
11:30:23 <crobbins> seangrove: super late, but no, not that i know of
11:30:33 <crobbins> there *might* be, i just haven't heard of any
11:30:37 <monochrom> no, GHC version is locked with base version
11:31:00 <zmbmartin> monochrom: It is so 7.6 uses an older version of base?
11:31:19 <chrisdone> miss information sounds like the next ill-conceived STEM barbie doll
11:31:32 <sshine> cabal-install-1.20.0.3 depends on Cabal-1.20.0.2 which failed to install.
11:31:39 <sinelaw> miss information sounds like disinformation
11:31:56 <Iceland_jack> Or.. misinformation :)
11:32:06 <sshine> I installed a system package called zlib1g-dev because 'cabal install cabal-install' failed by missing zlib.h.
11:32:52 <monochrom> GHC 7.6 uses base 4.6.0.1
11:33:18 <JonReed_> Is there an aesthetic way to run conditinal logic with values inside monads without getting them out? Without a monad it would be "if Bool then ... else .." but what if (Bool) is (IO Bool), now you can't do "if (IO Bool) then ... else..." nor can you use any "&&", "==", "||" operators
11:33:50 <Iceland_jack> JonReed_: Not really, languages like Idris provide sugar for that (!) but GHC/Haskell don't
11:33:58 <bitonic> JonReed_: yeah, it's quite annoying.  if we had idiom brackets...
11:34:14 <monochrom> IMO sugar doesn't count. sugar is unreal.
11:34:16 <bitonic> there isn't a quick solution to that
11:34:22 <exio4> maybe writing lifted &&/||/if functions
11:34:34 <sinelaw> right
11:34:42 <exio4> @hoogle m Bool -> m Bool -> m Bool
11:34:44 <lambdabot> Data.Generics.Aliases ext0 :: (Typeable a, Typeable b) => c a -> c b -> c a
11:34:44 <lambdabot> Control.Applicative (<|>) :: Alternative f => f a -> f a -> f a
11:34:44 <lambdabot> Language.Haskell.TH.Syntax qRecover :: Quasi m => m a -> m a -> m a
11:34:44 <sinelaw> like if' p a b = if p then a el se b
11:34:45 <angerman> anyone got a link to a good documentation on: why you cannot access the outer monad from the inner one, and how you'd solve these kinds of trickery with monads where monad transformers are not available?
11:35:02 * hackagebot threadscope 0.2.6 - A graphical tool for profiling parallel Haskell programs.  http://hackage.haskell.org/package/threadscope-0.2.6 (MikolajKonarski)
11:35:07 <fatho> JonReed: have a look at http://hackage.haskell.org/package/cond-0.4.1.1/docs/Control-Conditional.html#v:ifM
11:35:10 <sinelaw> or rather, if' a b p = if p then a else b
11:35:19 <bitonic> exio4: well, but you have to define two versions for each function.  unless you make every operation in Identity by default, which I guess is an option :P
11:35:20 <Iceland_jack> sinelaw: 'bool'?
11:35:22 <Iceland_jack> @ty bool
11:35:24 <lambdabot> a -> a -> Bool -> a
11:35:37 <sinelaw> Iceland_jack, oh. hoogle!
11:35:37 <clrnd> > bool 1 2 False
11:35:38 <bitonic> with something like idiom brackets it'd be much nicer
11:35:40 <lambdabot>  1
11:35:45 <sinelaw> hoogle missed it.
11:35:49 <clrnd> what's idiom brackets?
11:36:02 <bitonic> @google idiom brackets
11:36:02 <lambdabot> https://personal.cis.strath.ac.uk/conor.mcbride/pub/she/idiom.html
11:36:08 <Iceland_jack> bitonic: Idiom brackets wouldn't completely solve it, but along with (!) it's damn close
11:36:24 <bitonic> Iceland_jack: what's (!)?
11:36:28 <sinelaw> JonReed_, then: bool thenStuff elseStuff <$> (your IO Bool)
11:36:34 <boxrick> Anyone here based around Manchester?
11:36:46 <chrisdone> boxrick: i grew up in greater manchester
11:36:51 <JonReed_> Would it be possible in theory to generalize "&&" to accept Bool or IO Bool?
11:37:09 <bitonic> JonReed_: you can make it work for any monad, and then you can use Identity
11:37:19 <boxrick> I assume you moved on chrisdone?
11:37:21 <chrisdone> boxrick: unless you're referring to that american knock-off in pensylcaliforniyorkio state
11:37:30 <clrnd> meh, I can live without more syntax sugar
11:37:38 <Iceland_jack> bitonic: It allows you to implicitly bind monadic values
11:37:46 <Iceland_jack>     case !getLine of
11:37:46 <Iceland_jack>       "quit" -> ...
11:38:00 <Iceland_jack> Would be the same as:
11:38:00 <Iceland_jack>     line <- getLine
11:38:00 <Iceland_jack>     case line of
11:38:00 <Iceland_jack>       "quit" -> ...
11:38:07 <bitonic> ah ok.  nice.
11:38:11 <sinelaw> there is a manchester in pensylcaliforniyorkio?
11:38:13 <chrisdone> lambda case helps with that slightly
11:38:19 <chrisdone> getLine >>= case of "quit" -> ..
11:38:26 <chrisdone> or what was the eventual syntax..
11:38:29 <Iceland_jack> \case
11:38:30 <chrisdone> \case
11:38:42 * chrisdone preferred case of >_>
11:38:53 <Iceland_jack> also no 'of'
11:39:07 <Iceland_jack> I think that's an ugly use of lambda case, the !-notation is nicer at least
11:39:23 <chrisdone> it's one of the motivating cases for lambda case
11:39:54 <bitonic> I wonder how feasible it is to have a language where things are always monading, and by default m = Identity
11:39:59 <Iceland_jack> I almost exclusively use lambda case to avoid naming and repeating function arguments:
11:39:59 <Iceland_jack>     foo = \case
11:39:59 <Iceland_jack>       Just x -> ...
11:40:22 <chrisdone> bene per te
11:40:29 * bitonic uses x0 ... case x0 of
11:44:34 <Cale> bitonic: The thing about implicitly using the identity monad is that it's hard to tell when to stop doing so
11:45:11 <Iceland_jack> Cale: We can make a reverse do-notation that indicates Identity
11:45:39 <Iceland_jack> don't-notation, it can include normal lets and where and would look exactly like normal Haskell
11:46:18 <bitonic> Cale: mhm.  I was thinking of some sort of bidirectional checking to find out what the `m' should be
11:46:23 <bitonic> is there anything written on the subject?
11:48:12 <Cale> I don't think on that subject specifically
11:48:19 <Cale> At least, not that I know
11:48:23 <Cale> You can try it in Coq though
11:48:37 <athan> chrisdone: I hate to bug you, but does lucid v0.4 not support Monoid appending? I'm getting an error telling me that HtmlT isn't an instance :/
11:49:04 <chrisdone> athan: i expect you just need a type annotation like x :: Html ()
11:49:06 <Cale> Because its type class implementation is hacky and just uses the existing implicit parameter resolution, which doesn't care about uniqueness of solutions, and just picks the first one it finds.
11:49:31 <chrisdone> athan: the combinators are overloaded, so they need some help being inferred either by a top-level type sig or in the REPL an expression sig
11:49:50 <Cale> My small bit of experience with that is that adding a real identity monad instance immediately screws things up badly.
11:50:03 * hackagebot snap-loader-dynamic 0.10.0.2 - Snap: A Haskell Web Framework: dynamic loader  http://hackage.haskell.org/package/snap-loader-dynamic-0.10.0.2 (DougBeardsley)
11:50:17 <Cale> In fact, even adding a State monad instance for functions s -> (s,a) is pretty questionable.
11:50:25 <chrisdone> athan: e.g.
11:50:25 <chrisdone> λ> p_ "Hello, " <> p_ "World!" :: Html ()
11:50:25 <chrisdone> <p>Hello, </p><p>World!</p>
11:50:26 <athan> chrisdone: I think you're right >< Thank you!!! (this is friggin awesome btw)
11:50:32 <chrisdone> welcome =)
11:50:33 <athan> Ahhh wow
11:50:37 <Cale> You really need the tags to help pick instances
11:50:43 <t4nk946> Hello guys, haskell noob here; I'm having issues resolving dependencies for the copilot DSL. https://hackage.haskell.org/package/copilot. I'm trying to add it to the Arch-Haskell ABS tree here. https://github.com/archhaskell/habs
11:52:18 <Cale> t4nk946: okay, perhaps posting the output of cabal-install copilot to hpaste.org would be a decent way to start :)
11:52:44 <Cale> (or whatever it is that's giving dependency errors)
11:53:09 <chrisdone> cale: was that referring to me or just coincidentally similar vocabulary?
11:54:10 <Cale> chrisdone: I wasn't paying attention to the thread you're in
11:54:20 <chrisdone> =)
11:54:28 <chrisdone> Cale: it was an oddly appropriate comment
11:55:00 <Cale> I was talking about picking monad instances in the presence of instances at type lambdas
11:55:09 <bitonic> Cale: you have a similar system in Coq?
11:55:18 <bitonic> or you mean just using canonical structures?
11:55:24 <Cale> bitonic: Yeah, if you want, I can paste my monad library for Coq
11:56:21 <lpaste> Cale pasted “Monads.v” at http://lpaste.net/115143
11:56:24 <chrisdone> it's not immediately obvious to me why type lambdas aren't available in haskell
11:56:44 <chrisdone> i might try implementing it in my HM checker and see what trouble it causes
11:57:03 <Cale> chrisdone: Well, instance resolution gets pretty tricky...
11:57:40 <chrisdone> Cale: example?
11:57:54 <t4nk946> Not sure if you're famililar, but they  actually have scripts set up to make a temporary chroot env. Here's an example of the general process https://github.com/archhaskell/habs/issues/156. Here's my output http://lpaste.net/115144
11:58:12 <Cale> Well, you might have instances at type lambdas, which means that you need to beta expand in order to find out that the instance applies.
11:58:15 <chrisdone> i can imagine (\x.x Int) Identity ~ Identity Int
11:58:24 <t4nk946> The package that's failing is a dependency of atom
11:58:26 <zmbmartin> Cale: One last question about 7.6 and the weaker guarantee. Would you feel safe with it in a production database driver?
11:58:31 <Cale> (or else you don't, and the instance can't be found)
11:58:33 <zmbmartin> of readMVar
11:58:35 <t4nk946> http://hackage.haskell.org/package/atom
11:58:40 <Cale> zmbmartin: I have no idea
11:58:54 <zmbmartin> Cale: OK thanks
11:58:55 <chrisdone> Cale: isn't beta expansion a natural thing to do with lambdas anyway?
11:59:09 <Cale> zmbmartin: It could very well be fine. The thing that matters is whether there's another thread to empty out the MVar to keep things going.
11:59:34 <Saizan> chrisdone: unification becomes undecidable
11:59:37 <Cale> chrisdone: as opposed to beta reduction
11:59:48 <chrisdone> i'm imagining a type-level lambda to be just like a less dumb type synonym. perhaps that's an inaccurate intuition
11:59:49 <Cale> chrisdone: I mean you have to do the opposite of evaluation
12:00:08 <t4nk946> http://hackage.haskell.org/package/atom
12:00:22 <bitonic> Cale: I don't know if canonical structures are powerful enough to express what I wanted to express.  but yeah I'd love to see the libraries!
12:00:45 <lpaste> Cale revised “Monads.v”: “Monads.v” at http://lpaste.net/115143
12:00:46 <bitonic> chrisdone: you open a big can of worms when type checking if you start being able to compute types
12:00:50 <t4nk946> Cale: any ideas?
12:00:52 <Cale> ^^
12:00:58 <bitonic> Cale: danke
12:01:10 <Cale> t4nk946: looking...
12:01:53 <Cale> t4nk946: That doesn't look like a cabal error...
12:01:58 <Cale> or GHC dependency issue
12:02:13 <Cale> So I'm guessing that there's no bimap package in whatever system this is?
12:02:23 <chrisdone> compare:
12:02:24 <chrisdone> type F a = <…> then [F a]
12:02:24 <chrisdone> vs [(\x -> <…>) a]
12:02:39 <chrisdone> what's the difference between a named type synonym and an anyonymous one?
12:02:57 <Cale> chrisdone: Well, suppose you have  instance Monad (\x -> x) where ...
12:03:29 <chrisdone> going by what i wrote above that'd be like instance Monad F where …
12:03:50 <Cale> chrisdone: Then it always becomes an option to artificially insert the identity function into type level expressions in order to cause that instance to match.
12:03:52 <chrisdone> (where type F a = a)
12:04:29 <Cale> Like, even with something such as  getLine >>= putStrLn -- is this going to use the instance of Monad for IO, or is it using the instance for (\x -> x) ?
12:04:36 <Saizan> chrisdone: ghc doesn't allow Monad F, in fact
12:04:44 <chrisdone> Saizan: that was my point
12:05:36 <t4nk946> As I understand it, their stuff is supposed to pull from hackage, and the first part seems to be working, since I cleared a bunch of dependencies... check out my additions http://lpaste.net/115144
12:06:02 <bitonic> Saizan: well, but where can these lambdas appear?  if they can only appear in type-synonyms like you showed, then there is no point to them.  if they can appear in any type, then type inference just became a lot harder
12:06:24 <bitonic> sorry, chrisdone
12:06:42 <chrisdone> well, i can write: type Flip f a b = f b a
12:06:49 <chrisdone> and then Flip Either Int Char to mean Either Char Int
12:06:51 <Cale> *** ERROR: No such package: bimap
12:06:58 <chrisdone> but i can't just write (\f x y -> f y x) Int Char
12:07:04 <chrisdone> why not?
12:07:20 <Cale> t4nk946: http://hackage.haskell.org/package/bimap
12:07:23 <bitonic> chrisdone: so you're saying that these lambdas can appear (and be applied) in any expression?
12:07:53 <Cale> t4nk946: My guess is that it's looking for an analogue to the corresponding bimap package on hackage, at least in part due to the commandline you typed (which mentions bimap)
12:08:17 <Cale> t4nk946: and it's not finding it. I have no familiarity with this package system you're using though.
12:08:21 <bitonic> chrisdone: also, I don't get your example -- you're binding the `f' to `Int'?
12:09:12 <Cale> chrisdone: It's quite possible that Haskell could support *some* type lambdas, but they'd have to be forbidden in a lot of places.
12:09:30 <Saizan> chrisdone: if your lambdas always appear fully applied it would be fine, yep
12:09:33 <Cale> (especially instance heads)
12:09:48 <Cale> and yeah, if they were always fully applied, it would definitely be okay)
12:09:48 <t4nk946> Cale: Yeah, I'm aware of that package; I'm just not getting why their script build scripts aren't finding it
12:10:04 * hackagebot scion-browser 0.4.2 - Command-line interface for browsing and searching packages documentation  http://hackage.haskell.org/package/scion-browser-0.4.2 (JeanPhilippeMoresmau)
12:10:05 <chrisdone> Saizan: Cale: right -- curried lambdas and things like that i imagine would need to be disallowed, like curried type synonyms
12:10:07 <Cale> t4nk946: Yeah, that I really don't know.
12:10:12 <bitonic> but if they're fully applied, then they're not that useful -- I don't think this is what chrisdone had in mind
12:10:31 <t4nk946> Anyone else use Arch-Haskell for package management and have experince with contributing packagebuilds from the hackage tree?
12:10:43 <stepkut> I need to write a little script to perform a couple sql queries on an existing database. Things like haskelldb, persistent, etc, are way overkill. What sql binding should I use?
12:11:14 <bitonic> stepkut: postgresql-simple works for me
12:11:15 <chrisdone> bitonic: just a simple example:
12:11:16 <chrisdone> λ> type Flip f a b = f b a
12:11:16 <chrisdone> λ> :k Flip Either Int Char
12:11:16 <chrisdone> Flip Either Int Char :: *
12:11:21 <Iceland_jack> You could add syntax for "anonymous" type synonyms, that must be fully saturated without while keeping type checking decidable
12:11:36 <chrisdone> Flip Either Int Char ~ Either Char Int, just a simple superficial type-level flip
12:11:45 <Iceland_jack> With no higher-order unification needed
12:12:10 <bitonic> stepkut: there's also the new and shiny `hasql'
12:12:13 <Cale> chrisdone: Can you give an example of a program where having fully applied type lambdas would improve things?
12:12:16 <stepkut> oh, I should note that I am using mysql
12:12:37 <bitonic> stepkut: oh, then mysql-simple, which is basically the same with mysql
12:12:38 <t4nk946> Cale: here's the source... https://github.com/archhaskell/habs/blob/master/makeahpkg
12:12:40 <stepkut> ah
12:13:02 <chrisdone> Cale: do you need one?
12:13:07 <bitonic> chrisdone: I don't see where type lambdas come into place there
12:13:09 * stepkut should dedicate some time to featurizing acid-state so people will stop with this mysql nonsense :p
12:13:18 <Cale> chrisdone: Well, to justify the implementation cost :D
12:13:31 <chrisdone> bitonic: well instead of having to go define a type i could just use a quick lambda
12:13:50 <bitonic> chrisdone: ...but then you can just apply Either directly
12:14:04 <bitonic> or whatever you need to apply
12:14:08 <Cale> chrisdone: I can't think of a program which would be reasonably improved by having type level lambdas if they were forced to always be fully applied.
12:14:10 <bitonic> since you're applyign the lambda fully anyway
12:14:14 <chrisdone> Cale: well my original question was 'why not?'  so if your answer is 'dunno, no technical reason, probably costly to implement' then that's a fine answer
12:14:22 <Cale> The whole advantage of lambda is that you don't need to fully apply it :)
12:14:24 <bitonic> I think they're useful when that restriction is lifted
12:14:27 <bitonic> exactly
12:14:52 <bitonic> well they can be useful as a cheap `let'.  but then I'd rather have a type-level `let'
12:14:57 <Cale> It's like, imagine a programming language with lambdas at the value level, only you were forced to always fully apply them
12:14:58 <Iceland_jack> If you want non-saturated lambdas the singletons library provides that
12:15:58 <chrisdone> any case where a type synonym can be used it'd be nice to use a lambda =)
12:16:30 <Cale> t4nk946: I see no usage of cabal in that
12:16:42 <bitonic> chrisdone: like where?  if you're fully applying the lambda
12:16:52 <Cale> t4nk946: So I don't think it'll pull things from hackage
12:16:53 <bitonic> the advantage of type-synonyms is that you can reuse them
12:17:11 <mauris> hey, can someone quickly think of an "evil" fmap instance for [] that passes the law "fmap id == id" but not "fmap (f.g) == fmap f . fmap g"?
12:17:50 <Saizan> mauris: there cannot be
12:18:07 <Cale> mauris: any such instance wouldn't typecheck due to the polymorphism involved
12:18:26 <t4nk946> Yeah, actually, the relevant function is right at the bottom, and you'll notice it just looks in my current directory, so I think I'm supposed to have the sources downloaded already; let me see...
12:18:32 <mauris> aha. how about any other functor? or is the second law superfluous?
12:18:38 <bitonic> you could do it with an indexed functor I guess
12:19:11 <Cale> mauris: Yeah, the second law will always hold if the first does because of parametric polymorphism.
12:19:30 <Iceland_jack> (ignoring seq, bottoms etc etc)
12:19:37 <mauris> i see, neat
12:19:47 <mauris> (is there a nice proof?)
12:20:39 <ReinH> mauris: yes.
12:20:51 <Cale> I don't know about "nice"
12:20:58 <ReinH> It's pretty nice.
12:21:24 <mauris> and i suppose the other way around wouldn't be possible, either, setting f = g = id
12:21:27 <ReinH> it follows from the free theorem for fmap
12:21:31 <Cale> @free f :: (a -> b) -> [a] -> [b]
12:21:31 <lambdabot> h . k = p . g => $map h . f k = f p . $map g
12:21:32 <tobiasgw> is anyone using flycheck-haskell?
12:21:54 <Cale> ReinH: Yeah, the proof that free theorems exist is pretty fiddly though
12:22:04 <ReinH> :p
12:22:19 <mauris> i've read the paper on that but it blew my mind
12:22:28 <ReinH> it is pretty mind blowing
12:23:05 <ReinH> choose p = id and g = h . k
12:23:05 <t4nk946> Cale: Haha, found my issue: I was missing the command               cblrepo pkgbuild [package-names]             which downloads from hackage.
12:23:31 <Cale> t4nk946: cool, good that you found a solution :)
12:23:34 <nitrix> Hi, I've been using `data` types and `type` alias in my applications so far, but I realise how the latter can be dangerous. I would like to refactor with `newtype`s, but I'm confused as to how you'd extract the initial value again. Is there only pattern matching?
12:23:36 <t4nk946> ... and we're compiling now
12:23:56 <ReinH> h . k = p . g => fmap h . fmap k = fmap p . fmap g; fmap h . fmap k = fmap id . fmap (h . k)
12:24:03 <bitonic> nitrix: `newtype F a = F {unF :: a}'
12:24:10 <ReinH> fmap h . fmap k = id . fmap (h . k)  { fmap id = id }
12:24:10 <Cale> nitrix: Yeah, pattern matching, or if you use record syntax in the newtype, you can use the field name as an extractor
12:24:11 <bitonic> unF :: F a -> a
12:24:18 <ReinH> fmap h . fmap k = fmap (h . k ) { definition of id)
12:24:26 <t4nk946> Cale: Thanks!
12:24:32 <ReinH> mauris: QED :)
12:25:19 <nitrix> Cale: Oh so you can use the record syntax for newtypes too. Interesting! Let me try that :)
12:25:22 <mauris> cool!
12:25:59 <ReinH> (you also need h . k = id . (h . k), which follows from the definition of id as well)
12:26:13 <stepkut> nitrix: yes -- though still limited to one field
12:26:28 <nitrix> I see.
12:26:40 <nitrix> Makes sense actually.
12:29:14 <ReinH> nitrix: The common pattern is newtype Foo = Foo { runFoo :: Bar }, with variations on the name runFoo
12:29:40 <nitrix> runFoo :/ ?
12:30:01 <nitrix> run... sound weird.
12:30:37 <chrisdone> Cale: hmm, i can't think of a saturated example. consider me party pooped
12:31:11 <Cale> chrisdone: Basically you can only use it as a let with awkward syntax if it has that requirement
12:31:13 <sinelaw> nitrix, getBar could also work.
12:31:25 <chrisdone> i had some funky uses of liberal type synonyms but the domain they're hosted on is not responding, i was trying to find my old code
12:32:21 <chrisdone> Cale: right, you could write (\x -> f x x x) to save repeating yourself if the 'x' is large
12:34:58 <chrisdone> haskell.org isn't responding for me D:
12:35:12 * chrisdone kicks his italian internet
12:37:04 <sinelaw> chrisdone, you still in italy?
12:38:09 <chrisdone> sinelaw: ja
12:38:33 <chrisdone> i mean
12:38:35 <chrisdone> sinelaw: si
12:39:16 <sinelaw> chrisdone, walla.
12:41:37 <zmbmartin> Is there anyway to block the MVar while I take then put. So for 7.6 I can assure that all is fine?
12:43:08 <codygman> I remember there being a reason but can't recall: Why doesn't cabal install multiple versions of libraries?
12:43:10 <kadoban> zmbmartin: modifyMVar ?
12:43:41 <zmbmartin> kadoban: is modifyMVar blocking?
12:43:46 <bergmark> codygman: it does, but it doesn't install the same version with different dependencies because ghc doesn't support that
12:44:17 <codygman> bergmark: If it did support that, wouldn't it alleviate most cabal install issues?
12:44:57 <bergmark> codygman: a lot of them, at least. i'm pretty sure someone is working on this already
12:45:24 <kadoban> zmbmartin: Hmm, I thought so but maybe not.
12:46:02 <codygman> bergmark: I hope so, because the many of the issues I'm having now/had seem to be caused by that.
12:46:31 <codygman> I'll checkout their issues on github
12:47:23 <Luke> Guys i need some help. I'm writing a FromJSON (Aeson) instance for a JSON Object that has a string in it. that string is more escaped JSON. What's the best way to write that parser?
12:49:22 <favetelinguis> Can someone plz help me find the type error on line 4 for candidates. What process do i need inorder to solve these type errors, i still get headace and cant sort them out http://lpaste.net/115150
12:49:52 <favetelinguis> Expected type [Maybe Int] actual type [Int]
12:51:42 <bergmark> Luke: what are your options?
12:52:09 <platz> Luke: maybe just parse the escaped json into a Map instead of an AST
12:52:10 <Luke> bergmark: what I've been thinking is just call "decode" from within the FromJSON instance
12:52:13 <dhrosa> favetelinguis: can you paste the full error?
12:52:29 <bergmark> Luke: that was what popped into my mind as well
12:52:37 <Luke> platz: Yeah that's what I'm trying to do. I'm wondering if there's a way to do that while staying in the Parser monad
12:52:43 <dhrosa> favetelinguis: and also the type signature of update
12:53:03 <codygman> Can anyone help me diagnose this issue when trying to install latest snap with -fdevelopment: http://lpaste.net/115149 (partial, couldn't post all)
12:53:52 <bergmark> Luke: what's the benefit of staying in the parser monad?
12:54:01 <favetelinguis> dhrosa: http://lpaste.net/115150
12:55:46 <Luke> bergmark: you mean calling "decode" from within the current ToJSON?
12:56:05 <favetelinguis> dhrosa: i found it when you mentioned update
12:56:21 <favetelinguis> needed to apply pure on c for line 9
13:00:50 <bergmark> Luke: not sure what that means. Anyway, you seem to have a solution at hand and I haven't heard anything that's bad about it, so why not just do it?
13:01:23 <Luke> bergmark: haven't got it working yet. Just wanted to make sure it didn't sound insane to call "decode" from within another "decode" call
13:02:00 <cdk> Are there any benchmarks comparing the performance of blaze-builder against the builder modules in bytestring?
13:02:04 <bergmark> Luke: ok, i think the insane part is having escaped json inside of json in that case ;-)
13:02:13 <makalu> can I get a generator for MWC random from pure code? I mean if I initialize it from a seed then it would be pure?
13:02:15 <Luke> bergmark: ha I couldn't agree more!
13:02:30 <Luke> bergmark: it's weird because you can totally put a JSON object inside another JSON object...
13:02:38 <makalu> it seems to me that the only way to get a generator is from ST or IO
13:02:48 <Luke> bergmark: it's pusher.com
13:03:35 <bergmark> i'm hoping that's a bug in their api and not a conscious decision then!
13:04:36 <makalu> I'll ask my question in a better way: how can I have a StateT ST stack where the state is the MWC random generator? From pure code.
13:07:35 <Luke> bergmark: nah totally conscious
13:07:48 <bergmark> :(
13:09:14 <athan> chrisdone: Is there a way to make arbitrary tags in lucid? I'm trying to use <main> :/
13:10:06 * hackagebot hsbencher-fusion 0.3.2 - Backend for uploading benchmark data to Google Fusion Tables.  http://hackage.haskell.org/package/hsbencher-fusion-0.3.2 (RyanNewton)
13:12:20 <makalu> ok, I can do it by running an ST and using the generator when running a (StateT generator (ST s)) computation
13:13:57 <athan> bergmark: I think that's for 3rd-party javascript code er something :S
13:14:51 <bergmark> athan: that is somewhat beleivable and completely insane at the same time
13:19:40 <athan> bergmark: Hey, at least there aren't DOM interfaces into the filesystem or syscalls :P
13:19:42 <chrisdone> athan: sure: main_ = term "main"
13:19:48 * athan probably spoke too soon
13:20:14 <chrisdone> http://hackage.haskell.org/package/lucid-2.0/docs/Lucid.html#v:term
13:22:05 <chrisdone> athan: see here for examples: http://hackage.haskell.org/package/lucid-2.0/docs/src/Lucid-Html5.html#p_
13:23:38 <chrisdone> athan: oh, <main> appears to be a new element type in html5
13:23:46 * chrisdone checks the spec
13:24:17 * chrisdone adds
13:24:37 <augur> main is a new element type in html5? weird
13:24:48 <augur> <main>...</main> :: IO a   hopefully
13:25:01 <chrisdone> https://developer.mozilla.org/en-US/docs/Web/HTML/Element/main
13:26:26 <chrisdone> seems like they're just trying to think of names to fill the namespace
13:30:28 <bitemyapp> chrisdone: I eagerly await main-main
13:30:40 <bitemyapp> chrisdone: which is the *real* content of the *real* content of the body which is the content.
13:33:53 <chrisdone> bitemyapp: yeah D:
13:34:15 <athan> chrisdone: !!! Thank you!!
13:34:37 <chrisdone> athan: http://hackage.haskell.org/package/lucid-2.1
13:34:49 <chrisdone> athan: i added it (and a couple other new ones) to the html5 module
13:35:01 <athan> :D
13:35:07 * hackagebot lucid 2.1 - Clear to write, read and edit DSL for HTML  http://hackage.haskell.org/package/lucid-2.1 (ChrisDone)
13:35:21 <athan> ...`term` isn't used in 0.4 though, is it?
13:35:36 <athan> (also wtf `cabal unpack`, why aren't you getting the latest version?)
13:35:51 <chrisdone> athan: nope. update to 2.0! it gets rid of the need for `with'
13:36:11 <rhollor> so, I want to learn Haskell
13:36:12 <chrisdone> you can just write p_ (span_ [class_ "name"] "athan") now
13:36:18 <athan> > fix $ "!" ++
13:36:20 <lambdabot>  <hint>:1:13:
13:36:21 <lambdabot>      parse error (possibly incorrect indentation or mismatched brackets)
13:36:26 <athan> erm...
13:36:33 <rhollor> is it anything like Common Lisp?
13:36:37 <mauke> rhollor: no
13:36:38 <athan> O:!
13:37:07 <chrisdone> the only way it's like common lisp is type-classes are a bit like generic functions
13:37:21 <chrisdone> otherwise they're quite unalike in almost every other way
13:37:29 <mauke> but really, Perl is about 10x more like CL than Haskell is
13:38:04 <athan> Is there such a thing as _ambiguously_ typed lambda calc?
13:38:08 <rhollor> what are some good references? I have a PDF of a book called "Learn you a haskell for great good". Is that good?
13:38:12 <athan> I might have a (nutty) use case
13:38:21 <athan> rhollor: It's great!
13:38:35 <chrisdone> CL is dynamic, object oriented, imperative, s-expression based, macro'ing, image-based
13:38:38 <athan> Real world haskell is probably mid-level
13:39:21 <chrisdone> Haskell is static, functional, pure, ML syntax, awkward templating, one-shot
13:39:37 <chrisdone> and currying
13:39:53 <rhollor> are there any obvious advantages to it?
13:40:07 * hackagebot handa-gdata 0.7 - Library and command-line utility for accessing Google services and APIs.  http://hackage.haskell.org/package/handa-gdata-0.7 (RyanNewton)
13:40:11 <mauke> it doesn't make me rage as hard as CL
13:40:12 <chrisdone> purity gives you confidence a function only does what it says on the tin
13:40:22 <chrisdone> and static types as the tin's label
13:41:18 <rhollor> well, if I need a functional language, I can just use CL. Is there anything it's got over CL?
13:41:38 <chrisdone> CL is about as function as python or ruby or javascript
13:41:55 <rhollor> CL is whatever it wants
13:42:05 <chrisdone> you can say that of any general purpose programming language
13:42:07 <monochrom> I actually hate Lisp's idea of "every name has two bindings, one for value one for function"
13:42:18 <athan> Haskell is whatever it is :P
13:42:27 <chrisdone> yes, in Lisp parlance that's called a Lisp-2
13:42:37 <tempay> rhollor: I'm learning Haskell coming from lisp (Clojure not CL). It's worth your time for the type system alone
13:42:40 <chrisdone> Lisp-1's don't have the separate namespaces
13:42:42 <mauke> CL is not whatever it wants
13:42:59 <rhollor> chrisdone: scheme is lisp-1
13:43:00 <mauke> CL is pretty terrible at being a functional language
13:43:15 <monochrom> although, it's kind of cute that Guy Steele generalizes it to javascripts "every name has as many bindings as you want, just give them field names"
13:43:26 <xificurC> rhollor: try it and see for yourself. I came from CL too and like many things here
13:43:33 <rhollor> mauke: I'll take your word for it
13:43:40 <mauke> CL is blub
13:43:50 <monochrom> and yeah, CL doesn't feel like functions are first-class. only cons cells are first-class there.
13:43:55 <chrisdone> you can't consider a language in isolation. if it's just you and the computer, who cares, make up your own language
13:44:05 <chrisdone> you have to consider a language as a thing that a group of people use to communicate ideas
13:44:25 <rhollor> chrisdone: I've tried to create my own several times
13:44:42 <bitemyapp> tempay: hello fellow Clojurian.
13:44:55 <monochrom> @quote monochrom invent
13:44:55 <lambdabot> monochrom says: When I invent a programming language I will use Word100 to stand for 8-bit words. :)
13:44:57 <tempay> rhollor: read learn you a haskell, you should get some idea
13:44:58 <chrisdone> one person out of one hundred writing functional code does not a functional language make =)
13:45:03 <bitemyapp> chrisdone: "you can't consider a language in isolation" somebody should've told the Common Lispers about that.
13:45:09 <monochrom> @quote monochrom design.*language
13:45:09 <lambdabot> monochrom says: I was trying to design a sensible language... then I downloaded ghc.
13:45:14 <bitemyapp> galapagos island code.
13:45:24 <chrisdone> bitemyapp: i consider that the essence of the lisp curse
13:45:29 <bitemyapp> chrisdone: yarp.
13:45:37 <chrisdone> lisp is a selfish language for selfish programmers =)
13:45:50 <bitemyapp> chrisdone: template haskell doesn't bother me in part because people use it for relatively innocuous purposes compared to CL.
13:45:56 <rhollor> Don't know what you guys are talking about
13:46:00 <tempay> bitemyapp: hi! I don't know if I stuck with it long enough to be a card carrying Clojurian..
13:46:06 <mauke> and because you can tell where TH is used
13:46:09 <rhollor> CL was made to standardize lisp
13:46:12 <mauke> all lisp looks the same
13:46:16 <bitemyapp> tempay: just as well, your time is well-spent here.
13:46:46 <xificurC> what do you mean when saying 'CL is a language in isolation'
13:47:01 <rhollor> damn… you guys are to CL what Perl people are Python, aren't you
13:47:01 <dfranke> edwardk: in your algebra package, what are the semantics of isUnit? Does it mean "equal to one", or just "has a multiplicative inverse"?
13:47:04 <tempay> bitemyapp: yeah, I think so too. Do you still use Clojure, even knowing haskell?
13:47:16 <edwardk> has a multiplicative inverse
13:47:17 <mauke> rhollor: huh?
13:47:34 <edwardk> http://en.wikipedia.org/wiki/Unit_%28ring_theory%29
13:47:42 <rhollor> mauke: evryone here seems to hate CL with a passion
13:47:48 <mauke> I think that's only me
13:47:48 <bitemyapp> tempay: not willingly.
13:47:54 <bitemyapp> tempay: only because of some legacy stuff at work.
13:47:58 <chrisdone> rhollor: i don't
13:48:02 <chrisdone> i like CL
13:48:06 <edwardk> dfranke: happy to take documentation patches that make that clearer
13:48:06 <bitemyapp> tempay: http://bitemyapp.com/posts/2014-04-29-meditations-on-learning-haskell.html
13:48:07 <chrisdone> (relatively speaking)
13:48:15 <monochrom> I don't hate lisp. I just hate the statement "lisp is functional".
13:48:17 <mauke> rhollor: but the general perl attitude to python seems to be "not bad, use it if you like it"
13:48:27 <mauke> (I also hate python, though)
13:48:39 <dfranke> edwardk: I'm writing a newtype for the multiplicative group of a field and trying to figure out what instances to give it.
13:48:51 <rhollor> mauke: python was the reason I got into Perl
13:48:57 <mauke> heh
13:49:00 <tempay> bitemyapp: oh, I think I read that on HN when I was thinking about learning haskell
13:49:04 <edwardk> well, once you go to a field, everything but zero 'is a unit'
13:49:16 <dfranke> edwardk: right.
13:49:28 <tempay> bitemyapp: do you work in a mostly haskell shop?
13:49:40 <rhollor> chrisdone: so you guys just don't like people using saying CL is a better functional language than haskell
13:49:54 <mauke> this isn't even about "better"
13:50:03 <mauke> if CL is a functional language, almost everything is
13:50:05 <chrisdone> rhollor: i rather consider it a category error
13:50:08 * hackagebot handa-gdata 0.7.0.1 - Library and command-line utility for accessing Google services and APIs.  http://hackage.haskell.org/package/handa-gdata-0.7.0.1 (RyanNewton)
13:50:11 <guesting> I have a type that is a tree of records of strings and Maps. Is there a super easy way to write this type to a file as a JSON?
13:50:20 <chrisdone> it's like saying "steak is a better fruit than oranges"
13:50:21 <bitemyapp> tempay: no :(
13:50:26 <guesting> Using Data.Tree and Data.Map
13:50:37 <mauke> guesting: yes
13:50:39 <mauke> but you won't like it
13:50:46 <edwardk> rhollor: if you wanted to argue for something like scheme it'd be a much cleaner fight. CL pretty much requires you to use 'non-functional' idioms for almost everything
13:50:53 <guesting> mauke: But if it's easy, what's not to like?
13:51:06 <monochrom> McDonald's used to advertise "fries is our most popular vegetable"
13:51:09 <chrisdone> in fact, the functional subset of CL is rather annoying to work with due to the separate namespacing
13:51:12 <mauke> guesting: it involves 'show' to convert the whole thing to a string first
13:51:12 <dfranke> edwardk: but Field doesn't seem to inherit from Eq or from anything in Numeric.Decidable.*, so I'm trying to figure out the Right Thing for MultiplicativeGroup's DecidableZero instance.
13:51:15 <tempay> bitemyapp: ah well. It seems like more people are seeing the functional light nowadays, even if not haskell
13:51:18 <chrisdone> (FUNCALL #'FOO …) gets old
13:51:20 <edwardk> but in general we try to avoid getting into 'haskell is a better language than X' fights around here
13:51:23 <dfranke> edwardk: whether it should have one at all and if so what its context should be.
13:51:25 <edwardk> they just suck all the air out of the room
13:51:28 <guesting> mauke: I'm fine with that
13:51:37 <mauke> oh, ok
13:52:04 <guesting> mauke: At least for the time being, it depends how big these things get, but I'm sure it will be fine
13:52:15 <edwardk> You don't need to actually have a decidable equality, the laws are reasoning tools, not unit tests.
13:52:42 <mauke> chrisdone: perl is a lisp-6 or something, but I think it got function calls less wrong
13:52:53 <mauke> $foo->(...)
13:52:57 <edwardk> to have DecidableZero for the multiplicative group you'd need "DecidableOne" =)
13:52:58 <chrisdone> mauke: does perl have quotation?
13:53:04 <edwardk> i don't think i have one of those
13:53:06 <chrisdone> mauke: in the symbolic sense
13:53:26 <mauke> chrisdone: no, that's the one big lispy thing perl lacks: s-exprs/macros/etc
13:53:35 <dfranke> edwardk: sure, but I could also just put Eq in the context.
13:53:38 <guesting> mauke: So what is the technique?
13:53:52 <dfranke> edwardk: then isZero (MultiplicativeGroup x) = x == one
13:53:54 <rhollor> edwardk: I'm not trying to start any fights. I was just wondering what everyones problem with CL is.
13:53:56 <edwardk> tempay: i figure if we keep making haskell a nicer and nicer place to work, they'll come around. we skim off a lot of the 'high end' functional programming scala crowd in the end, etc.
13:54:11 <mauke> guesting: find a json library, figure out how to make it render strings, hand it 'show x'
13:54:14 <edwardk> dfranke: you could, but there are counter examples.
13:54:31 <chrisdone> right… i consider symbolic quotation to be the essence of lisp. that's its roots, and what made it different
13:54:55 <bitemyapp> tempay: I uh, don't really want to do without types any longer than I have to.
13:55:00 <edwardk> rhollor: you hopped into a channel of folks who have given themselves over to types and recursion and asked what their problem with a language that doesn't have either is? =)
13:55:13 <edwardk> (that effectively)
13:55:27 <codygman> For those interested: Shouldn't cabal opt for an older version of transformers in this case? https://github.com/codygman/hint-transformers-3-bug
13:55:29 <rhollor> edwardk: I didn't know what you had!!!
13:55:37 <tempay> edwardk: do you think it's a lack of software support (heavy editors, etc) more than the image of being weird and hard?
13:55:56 <dfranke> edwardk: wait, do you mean there are fields for which that instance definition is incorrect?
13:56:02 <edwardk> tempay: i think its more a function of middle management being afraid of anything that isn't java.
13:56:10 <guesting> mauke: How is that different from using, say aeson and defining the instances for the types?
13:56:16 <edwardk> dfranke: i have lots of things i can decide 0 for, but not decide every other element
13:56:26 <edwardk> dfranke: it woudn't surprise me to have the same situation arise for 1
13:56:41 <chrisdone> edwardk: i experienced an almost cartoony instance of that. using haskell at previous job, new management comes in, wants to replace everything with java
13:56:43 <mauke> guesting: you don't have to define any instances
13:56:50 <tempay> bitemyapp: that's honestly the main reason why i'm so much more productive in haskell. I started with java, my brain cannot keep track of types alone
13:57:11 <guesting> mauke: There are libraries that do that? I'll see if I can find one
13:57:20 <mauke> guesting: huh?
13:57:27 <mauke> guesting: do you know haskell?
13:58:00 <dfranke> edwardk: oh okay, so you're saying that there are some fields that can't have Eq instances, but whose multiplicative group could still have a DecidableZero instance?
13:58:02 <guesting> mauke: Apparently not, unless I'm misunderstanding you
13:58:03 <edwardk> chrisdone: other folks around here have had the same thing. i know at least one incident where basically the entire austrian railway's purchasing system runs on haskell and they've been frantically trying and failing to replace it with java for years. =P
13:58:10 <edwardk> dfranke: yes
13:58:38 <edwardk> dfranke: you can ignore those and put in the constraint anyways, but its worth knowing what you are ignoring when you write down a thing that isn't strictly required by law
13:58:49 <tempay> edwardk: true, but there's also things like go to choose from
13:59:01 <chrisdone> edwardk: haha
13:59:15 <tempay> edwardk: i guess i more mean startups and other smaller companies
13:59:16 <mauke> guesting: sorry, I think there's a misunderstanding somewhere and I can't think of a good way to figure out what it is
13:59:33 <guesting> mauke: It's fine, I'll see what I can find first
14:00:11 <edwardk> tempay: Until go figures out that generics are a thing that should exist, and that exceptions aren't just for language implementors, but for users, then go isn't an option. It is a way to keep certain googlers busy and out of other people's hair. =P
14:00:31 <mauke> guesting: looks like it's 'encode (show x)' with aeson
14:00:35 <edwardk> and a trap for the unwary
14:00:40 <rhollor> well, I'm going now, but I'll read the book and come back tomorrow
14:01:03 <guesting> mauke: Seriously? It seems like it would be more complicated than that...
14:01:22 <dfranke> edwardk: okay, I think I'll just punt on this instance for now. I don't actually need it for anything, just trying to be complete.
14:01:31 <mauke> or probably 'encode [show x]' if you want to decode it again
14:01:34 <guesting> mauke: Wouldn't that just convert the structure to a string and write the string?
14:01:43 <mauke> guesting: yes
14:01:45 <edwardk> dfranke: you're welcome to package it up in algebra if you like
14:02:05 <tempay> edwardk: that's basically how i see it, but it seems to get a fair amount of attention. Although i'm more basing my opinions of popularity on HN mention frequency :P
14:02:06 <guesting> mauke: It wouldn't be haskell to json, it would be a string to json, the string would still be in haskell format
14:02:13 <edwardk> i'm not very active in maintaining that package, so if someone wants a thing to appear there, let me know, and i'll happily toss you access or take patches
14:02:32 <mauke> guesting: yes
14:02:58 <romanandreg> edwardk: so they have a proven solution, and they still wanted to replace it with Java because Haskell is not Java?
14:03:16 <guesting> mauke: I guess I am looking for a library which has instances already for records, Data.Tree and Data.Map (and strings, chars, and ints, but that should be obvious)
14:03:20 <romanandreg> edwardk: interested in knowing the whole list of reasons
14:03:25 <guesting> but maybe I do need to define it myself
14:03:44 <dfranke> edwardk: okay, I'll send you a pull request some time soon.
14:04:07 <edwardk> romanandreg: the list of reasons was that management wanted to get it out of an 'academic and proprietary language' and brought in a new team to build it in java
14:04:31 <edwardk> mind you it is built on things like LogicT, etc. internally and has non-trivial logic to prune portions of the path space
14:04:51 <edwardk> so they've basically failed to make a dent in the problem at all
14:05:01 <romanandreg> edwardk: what do you mean with propietary? kind of lost with that word in this context
14:05:08 * hackagebot hsbencher-fusion 0.3.3 - Backend for uploading benchmark data to Google Fusion Tables.  http://hackage.haskell.org/package/hsbencher-fusion-0.3.3 (RyanNewton)
14:05:12 <alrunner4> guesting: pretty sure aeson can handle all that. for records it has a generic instance builder
14:05:21 <edwardk> romanandreg: i mean they viewed haskell as dangerous and proprietary. not my words
14:05:30 <monochrom> the glass tower certainly has a warped sense of what's "proprietory"
14:05:34 <guesting> cool, I'll see if I can do it
14:05:42 <romanandreg> edwardk: holly s…
14:05:58 <edwardk> romanandreg: meh.
14:05:59 <pantsman-> I'm sure they'll nail it eventually when the programmers stumble upon the Spring LogicBean
14:06:21 <Rarrikins> Spring is the work of Satan!
14:06:31 <edwardk> romanandreg: from what i heard at last check they were going to put a wrapper in java around the haskell solution and call it 'done' to be able to claim progress for some reason
14:06:52 <romanandreg> edwardk: I guess is an interesting problem, trying to make Haskell less of the buggyman to management, I remember there were some conversations on the discussion Haskell Exchange panel about that
14:07:56 <edwardk> romanandreg: my solution thus far has been to do everything i can to build libraries and an ecosystem that just work together, then let the folks who "get it" enjoy the productivity boost and let the others well.. fail.
14:08:11 <chrisdone> it seems to me 'middle' companies that're the problem
14:08:22 <edwardk> i can only help folks onto the boat so fast =P
14:08:54 <krakrjak1> romanandreg: here is some ammo to make Haskell a little mor palletable to management: http://youtu.be/ZR3Jirqk6W8
14:08:56 <chrisdone> big companies can afford to experiment with one team that uses haskell on a project, and start-ups often contain people willing to put up with some friction for an ultimately preferably technology
14:09:10 <edwardk> i figure i leave it to others to deal with most of the outreach side of things, because well, i'm just bad at it
14:09:24 <romanandreg> lol
14:09:34 <krakrjak1> edwardk: you are not bad at outreach, you'd just rather be writing comonads.
14:09:37 <chrisdone> the other 90% out there:  established companies with people set in their ways that can't just throw money to support a novel technology find it harder to try something like haskell>
14:09:39 <romanandreg> yeah… I tried to start my own company with Haskell
14:10:12 <romanandreg> and I can say that an actual pain I had was the fact that we weren’t to skilled with the implications of Lazy evaluation
14:10:17 <romanandreg> and had pains with memory leaks
14:10:25 <romanandreg> was a great learning experience for sure
14:10:29 <romanandreg> learned how to use a lot of tools
14:10:31 <edwardk> right now i'm going through and trying to fix up the haskell 'gaming' infrastructure. we have good sdl2 bindings now, thanks to Polarina. and i repackaged her OpenGL bindings into the 'gl' package, so now I have some tooling there that doesn't obviously get in my way
14:10:43 <romanandreg> but I was a slown down for actual business stuff
14:11:08 <romanandreg> sadly it failed… I would repeat Haskell as a tech again, though
14:12:19 <krakrjak1> romanandreg: lazy evaluation gets in most programmers way initially.  It's very different from what you expect coming from eager evaluation backgrounds, but I find it indispensable once it is conquered and use it in other languages like C# where appropriate.
14:12:21 <edwardk> If I want folks in that space to sit up and take notice of Haskell, which I do, in the quake of Carmack's QuakeCon keynote talking about Haskell then as I see it we need 3 things. 1.) tools that aren't obviously worse than what they have elsewhere and which can say all the things. gl/sdl2 are about checking that box. 2.) wrappings that make it pleasant to
14:12:21 <edwardk> use the code in Quine.GL is about this, and will splinter out into a separate package, and 3.) a reason to look. something that is distinctive enough to make someone have to actually read the haskell code to figure out what the heck it is doing and drive folks to see why we write haskell
14:12:30 <romanandreg> The conversation from the HaskellCast with Don Stewart about Real World Haskell was a good one, sometimes I believe there should be a real heavy “real world haskell” book that covers in more detail the stuff covered in that podcast session
14:12:47 <chrisdone> edwardk: in the quake of =p
14:12:49 <edwardk> that last leg is the reason i'm working on quine, i figure i can write some interesting code for dealing with realtime raytracing of signed distance fields in a form suitable for gaming
14:13:29 <edwardk> and that'd drive some folks to read the code, rather than just have us pick up the folks in the gaming industry who happen to also geek out on languages enough to find haskell via brownian motion
14:14:26 <edwardk> eventually we need to be able to do the same thing on the UI side. that is also currently a mostly un-installable trainwreck
14:14:53 <krakrjak1> yeah the UI front is sad to say the least in Haskell right now.
14:15:07 <edwardk> chrisdone: heh meant to write 'in the wake of' but my brain got ahead of me
14:15:09 * hackagebot hsbencher 1.20.0.3 - Launch and gather data from Haskell and non-Haskell benchmarks.  http://hackage.haskell.org/package/hsbencher-1.20.0.3 (RyanNewton)
14:16:14 <krakrjak1> We can write the most amazing whizbang algorithms all day long, but if we can't take input from the user without serious pain, like writing a library in C or C++ to shim into a GUI toolkit, then it will stay difficult to promote Haskell to existing studios.
14:16:26 <edwardk> anyways that is why i'm off playing with games. i don't want folks to look at haskell in that space as a thing suitable for writing little toys, i want it to look like something you could ship a AAA title on.
14:16:58 <edwardk> krakrjak1: in theory the wxhaskell binding is _almost_ cross platform installable
14:17:01 <chrisdone> edwardk: +1
14:17:06 <edwardk> there are a couple of major showstoppers right now
14:17:37 <edwardk> one is that the wxmac package in brew is broken in that it tries to link against QuickTime on 64 bit macs, which is a library that does not exist and will never exist
14:17:38 <ihatehex> I secretly suspect there are only 10 people in here with lots and lots of clone accounts.
14:17:48 <bitemyapp> edwardk: +1
14:17:51 <bitemyapp> @karma+ edwardk
14:17:51 <lambdabot> edwardk's karma raised to 45.
14:17:54 <edwardk> it relies on the fact that the c tools filter out bullshit like that, but the haskell side tools give you what you ask for, and just crash
14:18:26 <edwardk> we have patches submitted upstream to wxmac, which will fix the problem in a year or so whenever they get around to doing it
14:18:32 <krakrjak1> edwardk: yeah the wxmac package is horrible.  I spent a week over the summer, instead of doing my paid work, trying to fix it and could not unwind the issues well enough to get something working.
14:18:35 <edwardk> and in theory we can patch the brew installer for it now
14:18:53 <krakrjak1> edwardk: you patched it up and made it installable?
14:19:04 <edwardk> there is an issue open for it, but i just don't speak 'brew' so i can't fix it myself without going down a rabbit hole
14:19:25 <edwardk> krakrjak1: all you need to do is disable the mediactl extension on 64 bit macs in the brew installer
14:19:37 <edwardk> krakrjak1: with that wxmac installs and wxhaskell runs on it
14:19:48 <krakrjak1> edwardk: I think that is the issue I opened.  I thought I had it fixed after completely removing brew after the Mavericks upgrade and reinstalling, but that was not the case so I abandoned all hope.
14:19:53 <edwardk> but currently the brew installer doesn't do that
14:20:26 <edwardk> the maintainer of it said, sure, 'just have it flag that on 64 bit' but someone has to do the last mile and send him a patch
14:20:35 <edwardk> at that point in time wxhaskell can install cleanly on a mac
14:20:46 <edwardk> alternately we could just filter wxconfig ourselves in wxhaskell
14:20:47 <krakrjak1> edwardk: good to know, if I find myself on a Mac again I will play with that and see how it goes.
14:21:04 <edwardk> but i don't know any of the wxhaskell devs other than having met atze at icfp
14:21:43 <edwardk> but my rule of thumb is i don't pick up dependencies unless they can be installed out of the box without magic
14:22:02 <edwardk> because any dependency i pick up that has arcane install requirements acts as a huge filter on my set of users
14:22:36 <edwardk> its like how if you have a website making a user click drives away 80% of your traffic, making them register drives away almost all of it.
14:22:42 <edwardk> cabal install foo is easy
14:22:44 <krakrjak1> I am okay if we never really get a first class windowing toolkit for haskell as the future for us is likely the web, server closets and games.
14:22:48 <edwardk> brew install blah; cabal install foo is a bit harder
14:22:55 <edwardk> anything more is a registration form ;)
14:23:22 <edwardk> i have a situtation where i have the core of a game engine, i'm goign to eventually need to buiid an editor ;)
14:23:23 <krakrjak1> I agree with that.
14:23:57 <krakrjak1> yup, forgot about tooling :)  I guess we still need traditional thick apps for tooling...
14:24:26 <edwardk> anyways right now i'm ignoring that issue and hoping the wxmac installer thing clears up before i need it
14:25:28 <haasn> edwardk: Do you consider ‘lens’ such a library that can be installed out of the box without any magic?
14:25:34 <krakrjak1> If it doesn't, may there be a better way like making a cross-platform windowing toolkit just for Haskell that has pluggable backends for QT, GTK, Cocoa, Windows?  Is that tractable or just too pie in the sky?
14:26:01 <edwardk> haasn: 'cabal install lens' should work on a clean out of the box ghc install
14:26:14 <edwardk> and it works with packages in stackage across a wide array of configurations
14:26:28 <haasn> So by the logic, is ‘lens’ a library that's “cheap” in terms of picking up dependencies?
14:26:52 <edwardk> by that logic lens is frickin huge, but it is huge in a way that users can pick it up and install it.
14:27:07 <edwardk> if i added manual package manager steps to it? it'd go too big to be usable
14:27:13 <haasn> Hmm. There has to be a cut-off somewhere, though. For example, I'm cut off from installing basically any KDE program ever
14:27:30 <haasn> Because even something as simple as “emerge kcalculator” or whatever tiny application that shouldn't pull in more than a few megabyte wants me to download like 200 packages
14:27:45 <haasn> Sure, it might just work if I hit ‘y’ and let it run for ages
14:27:45 * edwardk shrugs.
14:27:54 <haasn> But I'm never okay with pulling in 200 packages for a simple calculator
14:28:08 <edwardk> i can cut my thinking off in that space and just not write any new code, or i can make code that works together
14:28:11 <edwardk> i want to keep building
14:28:18 <edwardk> so i'm going to keep building code that builds on code i've written
14:28:27 <edwardk> that is the very reason why i've written the code i've written
14:28:29 <edwardk> so i can use it
14:28:29 <haasn> Fair enough. I don't think lens is that large yet
14:28:50 <haasn> But the KDE scenario to me seems pretty much like a real world software dystopia
14:28:52 <edwardk> sure, now quine on the other hand uses lens and linear as building blocks, adds sdl2, gl, adjunctions, etc.
14:29:22 <Polarina> haasn, when lens beats this package in size, I'd consider it large: http://hackage.haskell.org/package/gl
14:29:24 <haasn> I guess it depends on the scope of your application. I'd fully expect to pull in 50 dependencies for something like an entire video game engine
14:29:32 <edwardk> heh
14:29:41 <edwardk> quine just depends on both lens and that gl package, no biggie, right? =)
14:29:45 <haasn> But I wouldn't expect to pull in 50 dependencies for a command line calculator. Even though it could, if it ends up pulling in the wrong abstractions for its 1-liners :)
14:29:46 <monochrom> "number of packages" is just a proxy of "how much disk space, how much build time" which you really care about.
14:29:51 <krakrjak1> haasn: kcalculator isn't that simple :)
14:30:03 <edwardk> haasn: you can write small little calculators i have no problem with that.
14:30:15 <edwardk> i'm not going to bend over backwards caring about that problem space though
14:30:32 <chrisdone> nor, presumably, bend over forwards
14:30:56 <edwardk> to me it comes down to making sure everything works together. that trumps almost every other competing concern i have
14:30:59 * krakrjak1 chuckles
14:31:01 <chrisdone> maybe just standing up and using a "grabbing stick"
14:31:44 <edwardk> the fact that 'gl' started bumping up against hard command line length limits on windows for cabal rather troubled me
14:32:01 <edwardk> we had to pick shorter module names or it couldn't install on windows!
14:32:26 * chrisdone blinks
14:32:34 <Tene> That's hilarious.
14:32:38 <haasn> krakrjak1: The thing that really irks me about KDE the most is the fact that it always pulls in stuff like phonon, which pulls in gstreamer, which pulls in VLC, which requires USE flag changes, which requires rebuilding other packages, which ...
14:32:40 <monochrom> poor you ;)
14:32:49 <haasn> It's just a never-ending chain reaction of things that should not be related to each other at all
14:32:51 <edwardk> chrisdone: to be fair it is 750 modules
14:33:14 <bitemyapp> good lord
14:33:14 <chrisdone> C:\Documents and Settings\Dave Jones\Documents\We're Going to Get There Eventually\… /me dozes off
14:33:22 <monochrom> haha, a calculator that depends on VLC, that's news :)
14:33:22 <chrisdone> edwardk: ah. ha
14:34:01 <edwardk> on the other hand, Polarina managed to get all of opengl wrapped. all versions, all extensions.
14:34:17 <edwardk> so in that sense, its amazing that it is so small
14:34:32 <haasn> monochrom: I'm fully serious. https://bpaste.net/show/4f0b7c82bbdc
14:34:54 <ruuns> Is it possible in haskell to access a simple string via IO-Handle?
14:35:06 <haasn> (It used to be a lot bigger, but over the past few years I've eventually ended up installing gstreamer and a few other ‘gigantic’ dependencies)
14:35:09 <ruuns> similar to sstreams / iostream in c++ :3
14:35:22 <edwardk> haasn: it strikes me that the USE flag notion is the problem. folks tried to spackle 'hey i'm going to build this justfor this limited scenario' noise on the build systen
14:35:29 <edwardk> and it means that ehen you aren't, you pay double
14:35:43 <krakrjak1> haasn: this sounds like a specific Gentoo issue where you are free to mix and match features when you build the software.  This is not the case in other Linux distributions like Debian.
14:35:49 <edwardk> the very thing that is causing you pain is folks trying to make things 'more minimal' badly
14:36:21 <mauke> also that you're building from source
14:36:43 <carter> i'm being slow today: how do i read in the command line args in haskell again?
14:36:50 <mauke> carter: getArgs
14:36:51 <carter> i never can remember what  module has that
14:36:52 <carter> ahhh
14:36:57 <carter> where the heck is that hidden
14:37:00 <monochrom> System.Environment.getArgs
14:37:07 <mauke> @hoogle getArgs
14:37:08 <lambdabot> System.Environment getArgs :: IO [String]
14:37:08 <lambdabot> System.Posix.Env.ByteString getArgs :: IO [ByteString]
14:37:08 <lambdabot> Graphics.UI.GLUT.Initialization getArgsAndInitialize :: IO (String, [String])
14:37:13 <krakrjak1> I agree with edward here, I love Gentoo in the abstract, but after 5 years of running it the newness wore off and the lack engineering discipline in the package manager has always been a source of pain there.
14:37:31 <haasn> krakrjak1: On something like debian, I would've had no choice but to pull in all the things under the sun either way. And for the cases where that is actually large enough to cause users distress, they provide like 4 versions of the same package, according to how many (non-)features you want, eg. nginx-minimal, nginx, nginx-full, nginx-complete, whatever
14:37:55 <tempey> ruuns: do you mean something like hGetLine?
14:38:10 <krakrjak1> haasn: VLC is not a dependency of GStreamer in Debian.
14:38:22 <Boreeas> So I wrote this: http://lpaste.net/115158 - Is it bad practice to have that many 'where... ' statements?
14:38:41 <monochrom> no, it's fine
14:38:58 <haasn> krakrjak1: Nor is it here, actually - it's a dependency of phonon
14:39:49 <krakrjak1> haasn: Not on Debian, https://packages.debian.org/wheezy/libqt4-phonon
14:40:10 * hackagebot cql-io 0.12.2 - Cassandra CQL client.  http://hackage.haskell.org/package/cql-io-0.12.2 (ToralfWittner)
14:40:24 <haasn> krakrjak1: Oh, looks like it requires either VLC, gstreamer *or* aqua
14:40:47 <ruuns> tempey: not really. I would like to have an interface where i don't distinguish between simple strings or a handle.
14:41:50 <krakrjak1> haasn: What you are experiencing is the specific features you are asking for when compiling phonon.  In Debian, and other distros, those decisions are made for you.  This is presumably done to ensure that all the packages in the system play well together.  In Gentoo, you are just hoping that all those packages you override with different USE flags will still play nicely together after they are built and sometimes you get a really nasty s
14:42:29 <tempey> ruuns: as in, you want to write code which operates on strings that either come from a handle or somewhere else?
14:42:55 <krakrjak1> I remember ls breaking several times in Gentoo after doing upgrades do to not building a dependent library due to inconsistency between the USE flags and the actual runtime requirements.
14:43:44 <krakrjak1> I got over the idea that I need to micromanage all those decisions.  The system is not more stable, nor is it faster or more flexible with the Gentoo approach.
14:44:15 <haasn> Disagree. I don't think what you are describing is relevant to anything said, and I do not wish to continue discussing the matter here, nor anywhere else
14:44:34 <krakrjak1> On the flip side, I would encourage anyone who has never used Gentoo to give it a shot if for no other reason than it is extremely good at teaching the internals of Linux and understanding how all the software actually fits together.
14:45:06 <ruuns> tempey: i have code that has to access data from Handle (simple File). Would be great i could also shadow a String behind and Handle for testing and otherthings.
14:45:14 <ruuns> +it
14:45:31 <hughfdjackson> hey :)
14:45:43 <hughfdjackson> i've made a very basic repl for my lambda calculus evaluator
14:45:43 <hughfdjackson> https://github.com/hughfdjackson/abattoir/blob/master/src/Main.hs#L8-L28
14:45:58 <hughfdjackson> mostly stolen from the repl in the scheme in 48 hours tutorial
14:46:38 <hughfdjackson> there's a bunch 'wrong' with it though - no history, no support for the arrow keys, or any other of my regular shell bindings (the ones I have come to appreciate in ipython, ghci, etc)
14:46:58 <Tene> hughfdjackson: just run it under rlwrap
14:47:09 <hughfdjackson> Tene: that's the kinda tip i was looking for :D
14:47:20 <SrPx> Guys... guys
14:47:33 <Tene> rlwrap is quite useful.
14:47:53 <hughfdjackson> oh.. ah
14:48:15 <tempey> ruuns: aah. I don't know if there is exactly what you're looking for. Maybe you could try writing your test string to a file in the code and then viewing it, or abstracting the file handling from the piece you want to test
14:48:17 <hughfdjackson> :) it's an external program - i was hoping to be able to run my repl platform agnostically
14:48:21 <SrPx> I've had a great marvelous insight in how to make every purely functional data access in O(1). It involves tweaking with the allocation/garbage collector! I've got some astonishing speedups
14:48:32 <relrod> hughfdjackson: haskeline is nice too ;)
14:49:03 <hughfdjackson> relrod: i'll give that a go right away :D cheers
14:49:17 <hughfdjackson> (clever name pun; but it meant i missed it entirely while searching hackage ;D)
14:49:19 <tempey> ruuns: there might be some way of doing it directly but I don't know it, I would refactor if possible
14:49:59 <SrPx> should I do something with this?
14:50:10 * hackagebot bytestring-conversion 0.3.0 - Type-classes to convert values to and from ByteString.  http://hackage.haskell.org/package/bytestring-conversion-0.3.0 (ToralfWittner)
14:50:56 <Haskellfant> is there some nice trick to do uncurryN without writing a function for each N you need it for?
14:52:32 <fragamus> im having trouble with cabal install zlib    im on ubuntu
14:53:14 <ruuns> tempey: alright :] thx
14:55:02 <alrunner4> SrPx: access all the things?
14:55:10 * hackagebot simple-smt 0.2.0.0 - A simple way to interact with an SMT solver process.  http://hackage.haskell.org/package/simple-smt-0.2.0.0 (IavorDiatchki)
14:57:23 <monochrom> fragamus: what is the complete verbatim output?
14:57:39 <fragamus> im figuring it out... sory to bug you
14:58:22 <hughfdjackson> relrod: oh my goodness
14:58:23 <hughfdjackson> this is
14:58:24 <hughfdjackson> ;-;
14:58:27 <hughfdjackson> beautiful
14:58:41 <dibblego> fragamus: probably need to install libghc6-zlib-dev
15:00:11 * hackagebot redis-resp 0.3.2 - REdis Serialization Protocol (RESP) implementation.  http://hackage.haskell.org/package/redis-resp-0.3.2 (ToralfWittner)
15:00:12 <SrPx> alrunner4: yes
15:00:58 <krakrjak1> Haskellfant: I don't completely understand this approach using GHC.Generics, but it appears up your alley: http://stackoverflow.com/questions/13436366/manipulating-arbitrary-tuples
15:01:29 <relrod> hughfdjackson: yeah it's a nice library :)
15:02:09 <Haskellfant> krakrjak1: thx, need to read about ghc generics tomorrow then :)
15:02:44 <trap_exit> sup n00bs -- anyone know how of a good tutorial on using haskell-src-exts to parse haskell ?
15:02:50 <trap_exit> s/n00bs/haskellers
15:04:09 <trap_exit> s/haskellers/n00bs # if no one knows, clearly all are n00bs
15:05:43 <statusfailed> edwardk: is it possible to "reset" a Machine ? I want to basically write "repeatedly", but force the repeating plan to stop and restart when input changes
15:06:30 <edwardk> statusfailed: machines provides a pretty sparse combinator set and exposes its guts so you can write whatever special case combinators you wind up needing
15:08:56 <trap_exit> what's a 'Machine' ?
15:13:41 <marchelzo_> So I made sort of a Lisp REPL in Haskell, and I want to use it as an interpreter for a C program that I made. How can I have a persistent state, so that when I call the Haskell function from C, all of the function and variables that I have defined previously are still available? In C I would just have a static map or something, but in Haskell there is no mutable state :|
15:16:38 <Maxdamantus> marchelzo_: that's generally a bad idea in C as well.
15:17:04 <monochrom> what does your REPL look like, from the user or API perspective?
15:17:25 <fragamus> hmmm can you guys try this: cabal install xml-types
15:17:32 <fragamus> it fails for me
15:17:42 <monochrom> more precisely, what are the types of your API functions?
15:19:18 <marchelzo_> monochrom: I have a type constructor REPL, which is just IO and State stacked pretty much
15:19:41 <marchelzo_> monochrom: and right now it just reads a string and evaluates it, mutating the global map
15:20:56 <monochrom> do you mean you currently have a "f :: StateT X IO ()" and it's the main thing?
15:21:28 <marchelzo_> monochrom: yes
15:23:26 <monochrom> I see two choices. one is easy to code but ugly. one is more to code up but elegant.
15:23:39 <marchelzo_> Right now it just reads from stdin and loops, but I would instead like to just pass a string to function and mutate the state, like emacs.
15:23:49 <marchelzo_> M-: if you're familiar
15:24:21 <marchelzo_> monochrom: It'll end up ugly anyway with all of the FFI stuff, so I don't mind that
15:24:46 <monochrom> the easy ugly one is a global mutable IORef to replace the StateT. (it uses unsafePerformIO)
15:25:59 <marchelzo_> I'm not above that :)
15:26:34 <monochrom> at the top level, "bindings :: IORef (Map Name Value)", "bindings = unsafePerformIO (newIORef Map.empty)", "{-# NOINLINE bindings #-}"
15:27:31 <monochrom> then the function to export has type "lisp :: String -> IO String". inside, you can read from and update bindings.
15:29:23 <marchelzo_> monochrom: awesome, thanks for the guidance
15:30:12 * hackagebot wai-predicates 0.8.4 - WAI request predicates  http://hackage.haskell.org/package/wai-predicates-0.8.4 (ToralfWittner)
15:35:12 * hackagebot gl 0.6.1 - Complete OpenGL raw bindings  http://hackage.haskell.org/package/gl-0.6.1 (EdwardKmett)
15:35:44 <fragamus> why would I be getting a HTTP 403 from stackage when trying cabal install xml-types
15:50:13 * hackagebot wai-routing 0.12.1 - Declarative routing for WAI.  http://hackage.haskell.org/package/wai-routing-0.12.1 (ToralfWittner)
16:03:46 <Welkin> are there any god tutorials/guides on getting started with haskell -> js?
16:03:53 <Welkin> good*
16:04:23 <Welkin> I'm just adding some client-side functionality to an existing project
16:04:32 <Welkin> Fay? Haste? ghcjs?
16:04:41 <Welkin> I'll need jquery and another external library
16:06:16 <Dashkal> No idea about your direct question.  An alternative: PureScript looks pretty promising.
16:06:45 <chrisdone> fay will be easy to setup and have small output. ghcjs will be better in the long term for big apps, not sure i'd recommend it for a bit of client-side enhancement, tho
16:08:24 <chrisdone> (just due to the current output size)
16:09:04 <marchelzo_> monochrom: out of curiosity, what was the more elegant way that you had in mind?
16:11:34 <Welkin> thanks for the advice
16:11:42 <Welkin> I'll check out Fay first
16:17:15 * bergmark hands chrisdone $5
16:18:41 <luite> :)
16:26:39 <dmwit> marchelzo_: Why not have an opaque context token that the C functions are responsible for passing in to the Haskell code?
16:26:59 <dmwit> This is a pretty common thing in C libraries, I think. e.g. especially graphics libraries do this a lot.
16:30:39 <marchelzo_> dmwit: What do you mean by "context token"? I considered passing the whole map back and forth, but it would be expensive.
16:45:31 <dmwit> marchelzo_: Just a pointer to the map is enough.
16:45:48 <dmwit> marchelzo_: No need to marshall it, as all your accessors/setters should be behind your API.
16:47:38 <dmwit> i.e. on the C side you'd have a void *.
16:56:39 <monochrom> marchelzo_: use a StablePtr for the context token. the context token is IORef (Map Name Value).
16:58:55 <monochrom> you have to export two functions instead of one. createLispEnv :: IO (StablePtr (IORef (Map Name Value))); lisp :: StablePtr (IORef (Map Name Value)) -> String -> IO String
16:59:33 <stefan_1__> is there a way to turn a Data.Time.Calendar.Day into a string? e.g. 5 => "Friday"
16:59:37 <dmwit> monochrom++ for knowing the mechanics of implementing the idea
17:00:03 <monochrom> the C side sees "void *createLispEnv(void)"
17:00:19 <marchelzo_> I like the way that sounds
17:00:43 <dmwit> stefan_1__: formatTime "%A"?
17:01:27 <stefan_1__> dmwit, I'll give it a try, thanks
17:03:37 <dmwit> :t formatTime
17:03:38 <lambdabot> Not in scope: ‘formatTime’
17:03:48 <dmwit> :t Data.Time.Format.formatTime
17:03:49 <lambdabot> Data.Time.Format.FormatTime t => System.Locale.TimeLocale -> String -> t -> String
17:03:52 <dmwit> oh ho
17:04:47 <dmwit> > Data.Time.Format.formatTime Data.Time.Format.defaultLocale "%A" (Data.Time.Calendar.Day 0)
17:04:49 <lambdabot>  Not in scope: ‘Data.Time.Format.formatTime’Not in scope: ‘Data.Time.Format.d...
17:04:53 <dmwit> aww
17:05:24 <stefan_1__> dmwit, that worked, thanks
17:05:34 <stefan_1__> today = (formatTime defaultTimeLocale "%A" . utctDay) <$> getCurrentTime
17:05:52 <dmwit> nice =)
17:14:09 <Ralith> What's a good simple HTTP request lib?
17:14:14 <Ralith> not looking for anything fancy
17:14:20 <Ralith> just maximum ease of use
17:14:28 <Ralith> wreq looked nice, but doesn't seem to build
17:15:19 <dmwit> curl, http-conduit
17:16:06 <dmwit> I've used http-conduit and I like the fact that it has a smooth upgrade path from knock-off GETs to full-fledged use.
17:16:25 <Ralith> I've used it before and been satisfied for more complex projects
17:16:34 <Ralith> seems like overkill here though, I'm just talking to a trivial JSON API
17:17:31 <Ralith> might use http-client directly
17:20:12 <JonReed_> Wreq git version should build, somebody in the issues said that. The hackage package is outdated
17:29:53 <solatis> ehrm, am i allowed to ask stupid cabal questions in here?
17:30:54 <cite-reader> I don't see why you can't ask, at least.
17:31:26 <solatis> ok
17:31:36 <solatis> i have a .cabal file with an executable and a test-suite
17:31:46 <solatis> executable hs-source-dirs is src/, the test-suite is test/
17:32:14 <solatis> how can i 'allow' the test-suite to import modules from src/ ?
17:32:20 <solatis> just add it to hs-source-dirs ?
17:32:49 <solatis> or refactor the modules i want to test out of src/ into a separate library and then build-depends upon that library?
17:35:30 <solatis> here is a discussion i found of people discussing the same problem, and it seems like there isn't a real solution to this https://www.haskell.org/pipermail/haskell-cafe/2014-February/112763.html
17:35:43 <solatis> the problem is, i do not want my cabal file to produce a library, i want it to produce an executable
17:36:49 <clrnd> solatis, well you can have both ... I usually do libraries and thin executable wrappers, it's just my workflow
17:37:08 <clrnd> and cabal build will produce the executable with the bundled libs
17:37:33 <solatis> yeah but this already is a thing executable wrapper around a library :)
17:38:09 <solatis> i just want to invoke the executable from my test suite
17:38:42 <solatis> for example, I have src/Main.hs and src/Parser.hs -- Main.hs only calls Parser.hs with some arguments, and test/ParserSpec.hs calls Parser.hs a lot of times with different arguments
17:39:07 <solatis> how can i have test/ParserSpec.hs be able to 'find' src/Parser.hs without making a separate library?
17:39:22 <clrnd> i usually have a lib, an exec and the test-suite
17:39:29 <solatis> or should I just throw the whole shebang in a single directory?
17:39:58 <solatis> so that means i will have to make a separate lib for every executable i create?
17:40:30 <solatis> or should I just throw my test cases in src/ too?
17:41:21 <clrnd> oh, I'n no cabal expert, bu what I usually do is have separate dirs for lib and exe
17:41:41 <clrnd> also to avoid extra compilations
17:41:48 <solatis> yeah i know
17:42:11 <solatis> but it just feels silly to have to create a separate library for *every* executable i make
17:42:25 <clrnd> mmm
17:42:51 <solatis> since my whole idea is that i have a central library for shared code amongst executables, and separate executables for code that is *not* shared
17:43:13 <solatis> it feels silly to have to build a separate library for all the executables when that code is not even shared
17:43:24 <marchelzo_> Should HsFFI.h be in /usr/include?
17:44:05 <clrnd> I understand your frustration :P cabal is not really friendly
17:44:08 <solatis> ah well, i'll just fix it with the hack to add src/ to the hs-source-dirs
17:44:14 <nshepperd> solatis: I would assume there should be some way to make src/* available to test/*
17:44:29 <nshepperd> it would silly if there wasn't
17:44:39 <solatis> nshepperd: yes, there is -- multiple hs-source-dirs
17:45:02 <solatis> and then main-is: Main.hs doesn't work anymore, since I have src/Main.hs and test/Main.hs
17:45:02 <clrnd> and the problem is ... ?
17:45:04 <solatis> *sigh*
17:45:07 <clrnd> ahhh
17:45:10 <clrnd> lol
17:45:14 <solatis> yeah it just feels all ugly
17:46:00 <nshepperd> well, how do other libraries do testing
17:46:13 <solatis> they are libraries :)
17:46:15 <solatis> that's easy
17:46:16 <clrnd> exactly
17:46:20 <solatis> you can add the library to your build-depends
17:46:48 <nshepperd> they don't include tests in the same package?
17:47:15 <clrnd>  I would have hacked in bashby this time I think ...
17:47:16 <solatis> yes they do
17:47:20 <solatis> anyway
17:47:38 <solatis> when adding src/ to the build-depends of my Test-Suite, it causes all the modules in src/ to be compiled twice
17:47:51 <solatis> once for the executable, once for the test case
17:47:57 * solatis gets ready to shoot himself
17:48:38 <solatis> guess refactoring the code i want to test into a separate library might be the most elegant way to go..
17:48:52 <clrnd> you are dramatizing this a little bit, can't you rename test/Main.hs to test/Test.hs?
17:49:05 <solatis> haha
17:49:10 <clrnd> :P
17:49:35 <solatis> no that's not the problem, cabal just uses the Main.hs it finds 'first'
17:49:41 <solatis> (which, in this case, means test/Main.hs)
17:49:49 <solatis> but now all my modules in src/ get compiled twice
17:49:56 <solatis> once for the executable, once for the test case
17:50:17 <clrnd> I know, I always wondered why does ghc/cabal do this ...
17:50:48 <nshepperd> hmm, I see, other libraries put build-deps: $libraryname
17:51:21 <solatis> yeah
17:51:34 <solatis> anyway, all solutions seem suboptimal
17:51:54 <solatis> for small projects, the recommended aproach seems to be to keep your source and spec files in the same directory
17:52:01 <clrnd> I'd say the seem unpractical
17:52:29 <solatis> for bigger projects, the recommended aproach seems to be to refactor the modules you want to test into a separate library
17:52:43 <solatis> and there is nothing elegant in between, really
17:53:17 <clrnd> how would you like it?
17:54:15 <solatis> that's a good question
17:55:16 <solatis> i guess a way for a Test-Suite to specify where to look for the source files that it's going to test
17:55:40 <solatis> adding them to hs-source-dirs is likely to generate name conflicts between src/ and test/
17:56:15 <solatis> but i'll be going for the 'everything in 1 directory' aproach
17:56:27 <marchelzo_> I'm having some trouble compiling some Haskell stuff to be called from C. I'm getting "HsFFI.h: No such file or directory", and when I downloaded the header and put it in my include dir, it said permission denied, so for whatever reason I tried to compile as root, and then there was just another header missing.
17:56:32 <marchelzo_> What can I do?
17:57:27 <clrnd> marchelzo_, sound like you are missing ghc header files
17:58:18 <marchelzo_> clrnd: The generated stub file was the one that tried to include HsFFI, and it used quotes not angled brackets, so I don't know where that header is supposed to come from.
17:58:26 <akurilin> question: in classy-prelude, I noticed that NonEmpty doesn't implement IsSequence, is that intentional or am I missing an import somewhere?
18:00:35 <nshepperd> solatis: cabal-install seems like it does a similar thing to you - http://hackage.haskell.org/package/cabal-install-1.20.0.3/cabal-install.cabal
18:01:17 <marchelzo_> nevermind, I was compiling with the wrong arguments. It's working now
18:01:28 <solatis> nshepperd: you are right
18:02:22 <nshepperd> no library, at least
18:02:49 <clrnd> weird how hs files are beside the cabal file
18:02:49 <codygman> Anyone used digestive functors with ByteString before? Well I guess it's a form upload field so it would need to be ignored?
18:02:55 <clrnd> but, then this compilates twice?
18:02:55 <nshepperd> 'hs-source-dirs: tests, .'
18:03:42 <solatis> nshepperd: yeah, they just include both the directories
18:03:46 <solatis> i don't like that, tho
18:04:03 <solatis> it seems like 'import Foo' then becomes ambiguous if you have both src/Foo.hs and test/Foo.hs
18:04:42 <nshepperd> well, you can just make it Test.Foo
18:04:47 <nshepperd> or Foo.Test
18:05:03 <solatis> yeah what i do now is simple have src/Foo.hs and src/FooSpec.hs
18:05:13 <solatis> and just say main-is: src/FooSpec.hs
18:05:43 <solatis> so that means a separate test-suite for every module
18:06:03 <nshepperd> in the cabal case they have main-is: UnitTests.hs, and then all tests are under UnitTests.Distribution.Client.***
18:06:26 <clrnd> akurilin, well it seems NonEmpty is from a completely different package than IsSquence, it doesn't feel weird that it's not implemented
18:06:27 <solatis> yeah
18:06:31 <solatis> i was thinking of something similar
18:06:32 <clrnd> it implements IsList at least
18:06:40 <solatis> and then use hspec's autodiscover
18:07:07 <nshepperd> so if you have a module Foo.Bar you would create UnitTests.Foo.Bar containing a bunch of proptests or whatever
18:07:10 <solatis> so every ~Spec.hs file in my src/ is automatically treated as a HSpec file
18:07:29 <nshepperd> or Foo.BarSpec is good too, I guess
18:07:39 <solatis> yeah
18:10:16 <solatis> awesome, this appears to work
18:10:27 <solatis> great, i think this is something i can live with
18:15:40 <nshepperd> looks like 'cabal test' does indeed recompile all sources even after running 'cabal build'
18:15:44 <nshepperd> that's a shame
18:19:28 <solatis> nshepperd: yeah, the only solution to fix that is to refactor it into a library / executable / test-suite
18:19:36 <solatis> instead of executable / test-suite
18:22:01 <user9876> If anyone's around, I'm curious how you "read" list comprehensions in your head.  I get how they work, I just want to know how other people "pronounce" it if you will
18:22:55 <user9876> for example [x*2 | x <- [1..10], x*2 >= 12]
18:24:04 <cite-reader> "X times two for x from one to ten, such that x times two is greater than or equal to twelve." Personally.
18:24:35 <user9876> cite-reader: thanks
18:25:04 <cite-reader> Sure.
18:32:18 <athan> Woah, so...
18:32:29 <athan> @let (&) = flip ($)
18:32:31 <lambdabot>  Defined.
18:32:47 <athan> ((+) 1 $ 2 &)
18:32:51 <athan> > ((+) 1 $ 2 &)
18:32:52 <lambdabot>  Ambiguous occurrence ‘&’
18:32:52 <lambdabot>  It could refer to either ‘L.&’, defined at L.hs:194:1
18:32:52 <lambdabot>                        or ‘Control.Lens.Lens.&’,
18:32:52 <lambdabot>                           imported from ‘Control.Lens’ at L.hs:47:1-43
18:32:52 <lambdabot>                           (and originally defined in ‘lens-4.1.2:Control.Lens...
18:32:57 <athan> ><
18:33:06 <athan> > ((+) 1 $ 2 L.&)
18:33:07 <lambdabot>  The operator ‘L.&’ [infixl 9] of a section
18:33:07 <lambdabot>      must have lower precedence than that of the operand,
18:33:07 <lambdabot>        namely ‘GHC.Base.$’ [infixr 0]
18:33:07 <lambdabot>      in the section: ‘(+) 1 $ 2 L.&’
18:33:25 <edwardk> @undefine
18:33:25 <lambdabot> Undefined.
18:33:37 <athan> thank you
18:35:20 * hackagebot cab 0.2.14 - A maintenance command of Haskell cabal packages  http://hackage.haskell.org/package/cab-0.2.14 (KazuYamamoto)
18:57:52 <lpaste> Deca pasted “Why can't Int be applied to variables like Num?” at http://lpaste.net/115167
18:59:43 <Clint> deca_: what do you think that would do?
19:00:20 <deca_> Output an Int?
19:00:47 <Clint> deca_: so you want myLength :: [a] -> Int ?
19:01:12 <deca_> Yeah but I was wondering why I can't assign it to a type variable like Num
19:01:20 <marchelzo_> deca_: What you have sometying like "(Foo a) =>", it's a constraint that says, whatever the type of a, it must be part of the Foo typeclass.
19:01:37 <marchelzo_> Int is not a typeclass, it is a type.
19:01:42 <marchelzo_> Num is a typeclass.
19:01:44 <deca_> Oh ok
19:02:56 <codygman> Trying to use postgres with snap within a handler, and got this error I couldn't make sense of. What is [r0] for isntance? Shouldn't query_ be fine to use as long as it's with the "with db" scope? code: http://lpaste.net/115168
19:13:01 <geekosaur> [r0] is presumably because query_ expects to return rows, even though in this case you are not. but it's also not the problem.
19:16:43 <geekosaur> I do not know snap, but if I read this correctly then db needs to go from App to AuthManager app, but instead goes from App to App?
19:25:46 <athan> In haskell, the only way to create variable arity from the result of a function is with templating, right?
19:26:05 <HeladoDeBrownie> athan, also typeclasses
19:26:10 <HeladoDeBrownie> see printf
19:26:48 <HeladoDeBrownie> @type printf
19:26:49 <lambdabot> PrintfType r => String -> r
19:28:39 <athan> HeladoDeBrownie: !!! Thank you!!
19:29:02 <Cale> athan: It's often not the best idea though. Probably saner just to take a list argument when you can do that
19:29:04 <Axman6> :t printf "test" 1
19:29:04 <lambdabot> PrintfType t => t
19:29:15 <Axman6> :t printf "test" 1 2 "three" True
19:29:16 <lambdabot>     Could not deduce (PrintfArg Bool) arising from a use of ‘printf’
19:29:16 <lambdabot>     from the context (PrintfType t)
19:29:16 <lambdabot>       bound by the inferred type of it :: PrintfType t => t at Top level
19:29:24 <Axman6> :t printf "test" 1 2 "three" 'c'
19:29:24 <lambdabot> PrintfType t => t
19:29:51 <Cale> :t printf "%d %d" 7 10 :: String
19:29:52 <lambdabot> String
19:29:55 <Cale> :t printf "%d %d" 7 10 :: IO ()
19:29:56 <lambdabot> IO ()
19:30:09 <Cale> ^^ it acts both as printf and sprintf :)
19:30:19 <dmwit> and fprintf
19:30:28 <dmwit> :t printf "%d %d" 7 10 :: Handle -> IO ()
19:30:29 <lambdabot>     Not in scope: type constructor or class ‘Handle’
19:30:29 <lambdabot>     Perhaps you meant one of these:
19:30:29 <lambdabot>       ‘Handler’ (imported from Control.Exception),
19:30:37 <geekosaur> no, there's an hPrintf for that
19:30:42 <Iceland_jack> :t hPrintf
19:30:43 <lambdabot> HPrintfType r => GHC.IO.Handle.Types.Handle -> String -> r
19:30:47 <dmwit> oh, dang
19:30:48 <geekosaur> because the Handle comes before the format string
19:31:11 <athan> O_O
19:31:15 <athan> Thank you!!!
19:31:21 <Iceland_jack> athan: there is also formatting
19:31:25 <Iceland_jack> @hackage formatting
19:31:25 <lambdabot> http://hackage.haskell.org/package/formatting
19:31:32 <athan> ooooooh woah that sounds cool
19:31:42 <Iceland_jack> It's typesafe and you can make your own format paramteres
19:31:48 <athan> I was thinking (barely) of trying to do some kinda generic something or other, idk
19:32:02 <athan> wow this sounds like it might fit the bill!!
19:32:08 <Iceland_jack> I added format parameters for "Show" and "Enum" and oct/bin among others
19:32:08 <athan> Thank you Iceland_jack :)
19:32:10 <geekosaur> also, where Haskell giveth with the typeclass trick, it also taketh away; partial application is tricky at best
19:32:34 <Iceland_jack> So that's very nice for your own private projects, to add a new way to format
19:33:20 <athan> holy crap guys, thank you so much
19:33:49 <Iceland_jack> yw
20:00:23 * hackagebot objective 0.5.2 - Extensible objects  http://hackage.haskell.org/package/objective-0.5.2 (FumiakiKinoshita)
20:15:23 * hackagebot influxdb 0.9.0 - Haskell client library for InfluxDB  http://hackage.haskell.org/package/influxdb-0.9.0 (MitsutoshiAoe)
20:37:46 <Porygon-Z> :t printf
20:37:47 <lambdabot> PrintfType r => String -> r
20:37:59 <Porygon-Z> :t printf "ten"
20:38:00 <lambdabot> PrintfType r => r
20:38:14 <Porygon-Z> :t printf "ten%d" 4
20:38:15 <lambdabot> PrintfType t => t
20:44:18 <Porygon-Z> printf is weird
20:45:23 <Porygon-Z> `printf "%d" returns a "PrintfType r => r", but it acts like a function that accepts an argument
20:45:24 * hackagebot thyme 0.3.5.5 - A faster time library  http://hackage.haskell.org/package/thyme-0.3.5.5 (LiyangHu)
20:49:16 <ddellacosta> I'm trying to figure out how to test higher level functions in quickcheck--is there a way to pass in some functions explicitly and then let quickcheck handle generation of random data?  The docs are failing me.  Or I'm failing to read the docs properly, or something...
20:50:01 <Iceland_jack> ddellacosta: Do you mean testing higher-order functions that *you* pass in or do you want QuickCheck to *generate* functions for you?
20:50:42 <Iceland_jack> For the latter, you can use 'Test.QuickCheck.Function' http://hackage.haskell.org/package/QuickCheck-2.7.6/docs/Test-QuickCheck-Function.html
20:50:51 <ddellacosta> Iceland_jack: well, my understanding that it was not possible to get QuickCheck to generate functions for use with higher-order (thanks, that's what I meant rather than higher-level, mistake) functions
20:50:58 <ddellacosta> oh, well then...
20:51:17 <Iceland_jack> It works quite well :) engineered by Koen Claessen
20:51:43 <Iceland_jack> It allows generating arbitrary functions, showing them and even shrinking them
20:51:44 <dibblego> http://hackage.haskell.org/package/QuickCheck-2.7.6/docs/Test-QuickCheck-Function.html
20:51:49 <ddellacosta> Iceland_jack: wow, great--thank you!  That's incredible
20:51:50 <dibblego> oh sorry, already posted
20:52:33 <Iceland_jack> ddellacosta: https://www.youtube.com/watch?v=CH8UQJiv9Q4 here is a video of his takl if you're interested
20:52:37 <chirpsalot> There's no way to pattern match a constructor regardless of how many parameters the constructor takes, is there?
20:52:45 <ddellacosta> Iceland_jack: oh awesome, bonus
20:52:46 <Iceland_jack> chrisdone: Constructor{} ?
20:53:12 <Iceland_jack> That works for any constructor, also constant ones
20:53:26 <chirpsalot> Iceland_jack: apparently yes, thank you :). Wasn't sure what to Google for.
20:53:30 <Iceland_jack> > (\True{} -> "it's True") True{}
20:53:31 <lambdabot>  "it's True"
20:54:04 <Iceland_jack> No problem chirpsalot, it should be better known than it is frankly
20:54:22 <Iceland_jack> It's much nicer than having:
20:54:22 <Iceland_jack>     Foo _ _ _ _ _ -> ...
20:54:23 <Iceland_jack>     Bar _ _       -> ...
20:54:29 <chirpsalot> Doing (Blah _ _ _ _ _ _ _ _) is pretty stupid >_<
20:54:35 <Iceland_jack> Indeed :)
20:54:42 <Iceland_jack> But you see it all the time
20:54:43 <chirpsalot> I knew their had to be a better way, but I had no idea what it was.
20:57:20 <xpika> is there a name for an binary operator that does not take two of the same type? Heterogenous Operation?
20:58:34 <chirpsalot> a -> b -> c :P
20:59:09 <chirpsalot> I don't think there is one in common usage. Most math ignores types pretty hard sometimes.
20:59:28 <liyang> xpika: to me, nothing in the name ‘binary operator’ implies that both arguments are of the same type.
20:59:30 <dibblego> xpika: "unclosed" perhaps
20:59:42 <chirpsalot> liyang: I was about to say that.
21:00:20 <chirpsalot> We have stuff like monoids?
21:00:48 <chirpsalot> That give like "monoid operator" which is more specific?
21:00:57 <chirpsalot> But that suggests other axioms.
21:01:01 <Iceland_jack> A binary operation does imply that they arguments are from the same set in a lot of sources
21:01:32 <Iceland_jack> An example where the operands differ might be an action
21:01:53 <chirpsalot> Direct product.
21:02:11 <liyang> I guess it depends on the context. If you're talking about operations on a given set, then it's kind of implied that both arguments are going to come from the same set.
21:02:58 <Iceland_jack> Yes, the majority of interesting binary operations are "internal" in that sense
21:03:34 <dibblego> closed
21:04:18 <liyang> But were it in a programming context, then no. :)
21:04:37 <Iceland_jack> dibblego: Closed is not quite the same as an internal operation
21:05:12 <Iceland_jack> The codomain of internal operations doesn't have to match the operands
21:05:19 <chirpsalot> Iceland_jack: I totally should have said external direct product, then ;).
21:05:21 <Iceland_jack> *don't have to
21:08:34 <CrazyM4n_> How can you do multiline type statements?
21:08:51 <CrazyM4n_> Is it as easy as just putting a newline after each arrow in the type?
21:09:09 <chirpsalot> CrazyM4n_: yeah, indented properly.
21:09:20 <CrazyM4n_> Okay, thanks
21:09:30 <Iceland_jack> CrazyM4n_: Something like:
21:09:30 <Iceland_jack>     take :: Int -- number of elements to take
21:09:30 <Iceland_jack>          -> [a] -- input  list
21:09:30 <Iceland_jack>          -> [a] -- output list
21:10:00 <chirpsalot> Yeah, that works too (probably preferred style)
21:10:15 <CrazyM4n_> Sounds good
21:10:28 <chirpsalot> It just can't be completely unindented.
21:11:00 <ccshan> I have a burning question. What do you call the function with this type: (Monad m) => m a -> (a -> m b) -> m (a,b)
21:12:34 <Iceland_jack> ccshan: It reminds me of monad strength
21:12:51 <Iceland_jack> Which would be:
21:12:51 <Iceland_jack>     strength :: Monad m => a -> m b -> m (a, b)
21:12:51 <Iceland_jack> in Haskell
21:13:45 <Iceland_jack> Normally it would be uncurried
21:13:56 <ccshan> Right, so strength = liftM . (,)
21:14:09 <Iceland_jack> Yes
21:15:05 <Iceland_jack> But I'm not familiar with the type you asked about
21:15:25 <ccshan> Just to be clear, the term is \m k -> m >>= \x -> k x >>= \y -> return (x,y)
21:15:55 <Axman6> @pl \m k -> m >>= \x -> k x >>= \y -> return (x,y)
21:15:55 <lambdabot> (. flip (liftM2 (>>=)) ((return .) . (,))) . (>>=)
21:16:01 <Axman6> so clear
21:17:01 <ccshan> Absolutely. I'm going to have Google pronounce it next.
21:21:18 <ccshan> Thanks for trying :)
21:22:26 <carter> oh hes gone
21:22:50 <Iceland_jack> carter: Do you have an answer?
21:22:57 <carter> nope
21:23:08 <carter> ii wnated to ask when the next version of hakaru is landing
21:23:11 <carter> :)
21:23:21 <Iceland_jack> Ah
21:24:10 <Axman6> haraku?
21:34:30 <carter> no
21:34:31 <Ralith> why does 'getEnv "HOST"' indicate that no such variable exists contrary to the judgement of the shell?
21:34:37 <carter> @hackage hakaru Axman6
21:34:37 <lambdabot> http://hackage.haskell.org/package/hakaru Axman6
21:35:07 <carter> Axman6: i assume ccshan is ken shan who collabs with oleg
21:49:50 <joeytwiddle> Ralith, it is probably not exported to the child process.  To test that theory, do `export HOST` in your shell, then try again.
21:50:20 <joeytwiddle> Ralith, then read the `/etc/hostname` file instead ;)
21:54:47 <lpaste> hcore pasted “No title” at http://lpaste.net/115178
21:54:56 <codygman> If I run cabal install --max-backjumps=-1 it could theoretically go on forever right? I'm pretty sure it's been going for about 30 minutes, lol.
21:54:58 <hcore> so i've been getting this error a lot
21:55:02 <hcore> and i dont really understand it
21:55:32 <hcore> that code btw takes the k'th element from a list but indexes starting at 1
21:56:08 <codygman> hcore: You are wanting your first guard to be 'error "Number out of range"' I think
21:56:16 <hcore> is it expecting chars and seeing nums and not knowing how to compute them?
21:56:51 <hcore> ahh ok
21:57:13 <codygman> You are returning a string in one case and number in the other if I'm reading this correctly.
21:57:29 <hcore> so it knows it needs to return something that's the same as its input but instead it is seeing that it's returning a character list and erroring out?
21:57:41 <hcore> yeah that's what i was doing
21:57:44 <hcore> thanks!
21:58:45 <codygman> hcore: Also in the first guard you probably want: n+1 < length
21:59:19 <codygman> i'd probably use where to set n' = n + 1
21:59:34 <codygman> err... I don't know how that works with guards though
21:59:41 <codygman> I don't use them as muich
22:00:54 <hcore> actually in that second guard looks like it should be n-1 to adjust it to the way haskell indexes
22:00:58 <Ralith> joeytwiddle: huh, looks like you're right
22:01:03 <Ralith> I guess each shell sets it independently
22:01:04 <Ralith> weird
22:01:42 <hcore> i could definitely use where in guards but i dont repeat n - 1 anywhere else
22:02:54 <codygman> > [0..5] !! 5
22:02:55 <lambdabot>  5
22:03:08 <codygman> hcore: ^^ Haskell indexing works like most other languages
22:03:24 <codygman> > length ([0..5])
22:03:24 <hcore> yeah
22:03:25 <lambdabot>  6
22:03:30 <codygman> ah... silly me
22:04:34 <hcore> ohh programming, at this point i understand zipwith, map, and a few other things (noobish i know) but zero-indexes still get me every time
22:05:06 <codygman> hcore: Nice! Do you program in other languages too?
22:05:32 <hcore> i was learning java for a couple months but decided to switch to haskell
22:05:40 <hcore> totally different languages i know
22:05:55 <codygman> sounds like one of my friends
22:06:38 <hcore> was tired of all of java's scaffoldings and retreated to a language with the most minimal amount of scaffolding possible?
22:06:40 <codygman> hcore: You might want to bookmark this: https://github.com/bitemyapp/learnhaskell
22:07:33 <hcore> thanks! bookmarked that
22:07:41 <malc_> hcore: java is zero indexed too.. in fact i know only 2 languages that use one based indexing
22:08:49 <hcore> i know, zero index got me there too, that wasnt one of my reasons for switching
22:09:03 <hcore> i only know of ruby being 1 indexed
22:09:08 <hcore> what's the other?
22:09:37 <simpson> Ruby's zero-indexed.
22:09:38 <codygman> visual basic?
22:09:44 <hcore> also stay tuned for my upcoming modification to haskell2010 that makes list 2-indexed
22:09:46 <simpson> Lua is one-indexed, for example.
22:09:47 <hcore> it is?!
22:10:10 <hcore> hrmmm looks like it is
22:10:14 <joehh> matlab
22:10:21 <hcore> excel :)
22:10:39 <carter> fortan
22:10:40 <simpson> Zero-indexed languages are the norm.
22:16:12 <jle`> matlab and mathematica are languages/platforms i commonly use that are 1-indexed
22:16:22 <jle`> also fortran is arbitrarily indexed
22:16:52 <jle`> so i guess not all of my day to day languages are necessarily 0 indexed
22:19:13 <hcore> there's no real point for newer languages to be 0 indexed other than people being used to them
22:19:20 <hcore> at least as far as i can see
22:20:06 <HeladoDeBrownie> It's kind of nice that Haskell arrays don't force you
22:20:56 <HeladoDeBrownie> (arrays, not lists)
22:20:58 <simpson> hcore: Dijkstra has a great justification for zero-indexing which is pretty great.
22:21:21 <HeladoDeBrownie> great justification is great
22:21:29 <simpson> hcore: https://www.cs.utexas.edu/users/EWD/transcriptions/EWD08xx/EWD831.html
22:22:06 <hcore> too late! i've already made an operator to do things my way! (!!!) x n = x !! (n-1)
22:22:17 <hcore> jk, thanks for the link, would like to see the justifications
22:51:20 <dmj`> does unboxed mean "on the stack" ?
22:51:28 <dmj`> "An unboxed type, however, is represented by the value itself, no pointers or heap allocation are involved."
22:51:42 <dmj`> if there's no heap allocation, I assume it lives on the stack
22:56:18 <carter> nope
22:56:27 <carter> dmj`: nope, the stack is on the heap
22:56:43 <carter> Int# and Word# live in registers
22:56:50 <carter> unless the registers get spilled in the stack
22:57:11 <carter> when they're on the heap, they get boxed up in Word or Int
22:59:12 <dmj`> carter: registers on the cpu?
22:59:18 <carter> well
22:59:19 <carter> yeah
22:59:22 <carter> do you know how a cpu works
22:59:25 <carter> those
22:59:46 <carter> wellll
22:59:46 <carter> ok
22:59:55 <carter> i'm speaking specifilaly about how ghc does stuff
22:59:58 <carter> generally speaking
23:00:05 <carter> boxed types have an extra pointer of indirection
23:00:11 <carter> whatever language
23:00:35 <nshepperd> you can unbox things inside of things that live on the heap though, iirc
23:00:40 <nshepperd> like unboxed arrays
23:01:17 <nshepperd> "unboxed" in that case means it's an array of ints instead of an array of pointers to int boxes
23:01:50 <dmj`> so unboxed just removes one level of indirection, or does it also change where the value lives?
23:02:23 <nshepperd> the first thing, which can result in the second thing
23:02:26 <nshepperd> I think
23:02:31 <carter> roughly yeah
23:05:46 <akurilin> Do you guys know if it's possible to use optparse-applicative to parse to Text values?
23:06:01 <akurilin> I'm trying to do it turhgou "option auto"
23:06:04 <akurilin> *through
23:07:16 <thoughtpolice> unboxed arrays are just a fancy term for having fixed-size types (Int, Char, Word) mapped into a ByteArray#, which is essentially contiguous memory. but the actual story is more complicated. there are 'boxed' things which are pointers to things in the heap vs unboxed, and 'unlifted' things which are simply "not _|_". ByteArray# is boxed type, but also unlifted, and you map other unboxed types into a ByteArray# which gives you something like U
23:08:21 <Axman6> thoughtpolice: did you get cut off after "something like U"?
23:08:42 <thoughtpolice> "Something like UArray"
23:12:02 <thoughtpolice> dmj`: and to answer the question, yes, you're basically right. GHC keeps unboxed/unlifted things like Int# in registers where possible, or it may spill them to the stack (which yes, is actually allocated on the heap) if necessary to spill something, or for calling conventions when doing function calls (which dictate on some platform arguments are passed on the stack)
23:13:23 <supki_> akurilin: auto uses Read. if you want to get the value of the String option verbatim try  fmap Text.pack (option str ...)
23:15:26 <akurilin> let me give that a try. My packs are all over the place iwth classy-prelude
23:16:17 <dmj`> thoughtpolice: big thanks
23:16:18 <dmj`>  
23:18:13 <akurilin> supki_: whoa that worked, thanks
23:18:26 <akurilin> I guess doing read was a bad idea there
23:45:31 * hackagebot learning-hmm 0.2.0.0 - Yet another library for hidden Markov models  http://hackage.haskell.org/package/learning-hmm-0.2.0.0 (mnacamura)
23:45:33 * hackagebot hspec-core 2.1.0 - A Testing Framework for Haskell  http://hackage.haskell.org/package/hspec-core-2.1.0 (SoenkeHahn)
23:45:35 * hackagebot hspec-discover 2.1.0 - Automatically discover and run Hspec tests  http://hackage.haskell.org/package/hspec-discover-2.1.0 (SoenkeHahn)
23:45:37 * hackagebot hspec 2.1.0 - A Testing Framework for Haskell  http://hackage.haskell.org/package/hspec-2.1.0 (SoenkeHahn)
23:59:32 <codygman> Having an issue with persistent. I'm pretty sure I need to specialize "backend" but I'm not sure how to/what to: http://lpaste.net/5010286106214662144
