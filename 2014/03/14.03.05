00:23:30 <ski> johnw : `series' ?
00:23:49 <johnw> it's a CL library that provides lazy effectful streaming
00:24:21 <ski> s/lazy/on-demand/ ?
00:24:27 <johnw> yeah
00:24:35 <ski> (or is it push streaming ?)
00:27:36 <klrr2> :t (.) . (.)
00:27:37 <lambdabot> (b -> c) -> (a -> a1 -> b) -> a -> a1 -> c
00:53:07 <codygman> Has anyone ever used hxt to do type safe xml parsing? It seems to want to deal with everything as text
00:53:25 <xintron> Any recommendations on command line parsing library?
01:01:31 <mlen> Any Yi users here? Do you have any tips for a user migrating from vim?
01:03:42 * hackagebot egison-tutorial 3.2.7 - A tutorial program for the programming language Egison  http://hackage.haskell.org/package/egison-tutorial-3.2.7 (SatoshiEgi)
01:03:42 * hackagebot Spock 0.4.2.2 - Another Haskell web toolkit based on scotty  http://hackage.haskell.org/package/Spock-0.4.2.2 (AlexanderThiemann)
01:18:40 <codygman> I'm doing some xml parsing with hxt based on a few tutorials I did, but it is just using strings for everything. How can I use the type system? Should I create a function that either reads the strings into the correct type or throws an exception? Here is my code: http://lpaste.net/100712
01:21:08 <quicksilver> codygman: what do you mean "it is using strings for everything"?
01:21:10 <Fuuzetsu> codygman: yes, you'd have parsers
01:21:19 <quicksilver> codygman: which parts of what you just showed us shouldn't be string?
01:21:22 <Fuuzetsu> quicksilver: he means types return by the parser
01:21:40 <quicksilver> Fuuzetsu: well he's returning an Item, that's not a string :)
01:21:52 <quicksilver> and all the fields of Item *are* String - but maybe they would be better as something else
01:21:53 <Fuuzetsu> I should probably look at the paste
01:22:17 <Fuuzetsu> he probably wants them to not be String
01:22:50 <codygman> quicksilver: Oh, I think I should use getAttrValue. All tutorials except the one I just looked at on fpcomplete used getText for everything.
01:23:31 <Fuuzetsu> codygman: getAttrValue and getText do different thing
01:23:39 * hackagebot Spock 0.4.2.3 - Another Haskell web toolkit based on scotty  http://hackage.haskell.org/package/Spock-0.4.2.3 (AlexanderThiemann)
01:23:46 <codygman> Fuuzetsu: I jsut saw that when I looked in the docs :/
01:23:51 <quicksilver> getAttrValue might well be useful to you but it will still return text
01:23:54 <quicksilver> strings, I mean
01:24:13 <quicksilver> you can certain compose the HXT arrows with parser arrows of your own
01:24:19 <quicksilver> to produce more specific types
01:24:38 <quicksilver> (that's effectively what you are already doing with the proc notation and "returnA -< Item ..."
01:25:18 <Fuuzetsu> codygman: https://github.com/Fuuzetsu/h-booru/blob/master/src/HBooru/Parsers/FieldParsers.hs#L113 here I try to parse something into a Bool and use Maybe to consider failure
01:25:21 <Fuuzetsu> you could do something like this
01:25:36 <codygman> If I wanted productId to be an Int for instance I would use read and maybe?
01:25:42 <codygman> Fuuzetsu: Looking now
01:26:00 <Fuuzetsu> codygman: There's ‘readMaybe’ in Text.Read which is what you could use
01:26:21 <Fuuzetsu> PS: I use ‘read’ and fromMaybe with error in a bunch of places, this isn't model code ;) I'll be getting rid of those
01:27:09 <jle`> is there a better way to do { x <- f; y <- g; h x y } ?
01:27:44 <Fuuzetsu> @undo do { x <- f; y <- g; h x y }
01:27:44 <lambdabot> f >>= \ x -> g >>= \ y -> h x y
01:27:55 <Fuuzetsu> ;P
01:27:59 <Fuuzetsu> :t liftA2
01:28:00 <lambdabot> Applicative f => (a -> b -> c) -> f a -> f b -> f c
01:28:04 <jle`> :P
01:28:12 <jle`> liftA2 does not work
01:28:17 <jle`> it would have to be (a -> b -> f c)
01:29:04 <Fuuzetsu> :t join . liftM2
01:29:04 <lambdabot> Monad m => (a1 -> a1 -> r) -> m a1 -> m r
01:29:26 <Fuuzetsu> I dunno
01:29:50 <Fuuzetsu> @. pl undo do { x <- f; y <- g; h x y }
01:29:50 <lambdabot> (g >>=) . h =<< f
01:30:06 <Fuuzetsu> oh yeah, isn't there a name for this pattern?
01:30:15 <supki_> :t ((join .) .) . liftA2
01:30:16 <lambdabot> (Monad m, Applicative m) => (a1 -> b -> m a) -> m a1 -> m b -> m a
01:31:00 <jle`> ew
01:31:47 <jle`> wow you can compose lamdabot stuff?
01:32:20 <jle`> that pl output is cute but you lose all sense of execution order
01:33:04 <Fuuzetsu> a command to turn infix to prefix considering precedence could be useful
01:33:40 * hackagebot clash-prelude 0.2 - CAES Language for Synchronous Hardware  http://hackage.haskell.org/package/clash-prelude-0.2 (ChristiaanBaaij)
01:33:43 <Iceland_jack> Fuuzetsu: I submitted a patch for adding parenthesis to GHCi
01:34:07 <Iceland_jack> normalizing everything to prefix could be doable
01:35:33 <Iceland_jack> *parentheses
01:42:35 <codygman> Where can I learn about (-<)? I know it is an arrow but I don't totally understand it. I tried ":t (-<)" after turning on -XArrows in ghci but it is a symbol and doesn't show the type.
01:42:55 <merijn> codygman: -< is syntax
01:42:59 <codygman> Actually, I think I answered my own question: http://www.haskell.org/ghc/docs/latest/html/users_guide/arrow-notation.html
01:43:03 <Fuuzetsu> you could look up how arrows are desugared but I recommend against it, it's a clusterfuck
01:43:03 <merijn> codygman: Like the <- in do notation
01:43:40 <codygman> Fuuzetsu: Yeah, but I wouldn't want to use something I totally don't understand would I?
01:43:41 <merijn> codygman: The simplest explanation is: you know how arrows are like pipelines?
01:43:47 <Fuuzetsu> codygman: works for me
01:44:09 <Fuuzetsu> I think reading an arrow tutorial would be more beneficial
01:44:11 <merijn> codygman: i.e. "Arrow arr => arr a b" is a pipe that takes a's and spits out b's
01:44:24 <Fuuzetsu> merijn: arrows are like functions!
01:44:29 <merijn> Fuuzetsu: No
01:44:34 <merijn> Fuuzetsu: Functions are like arrows
01:44:52 <Fuuzetsu> merijn: http://ro-che.info/ccc/12
01:45:02 <codygman> merijn: Alright, I get what you mean. I can see why hxt used them and why the tutorials show something I'd also expect pipes or conduit to do.
01:45:33 <merijn> codygman: "x <- foo -< arg", if "foo :: Arr arr => arr a b" then 'arg :: a' (functioning as input) and 'x :: b' (referring to the output)
01:45:54 <Fuuzetsu> wait a sec
01:46:03 <merijn> codygman: Notice the symmetry of <- and -<
01:46:04 <Fuuzetsu> was -< used because combined with <- it looks like an arrow?
01:46:08 <merijn> Fuuzetsu: Yes
01:46:11 <Fuuzetsu> I only just realised this
01:46:24 <Fuuzetsu> I won't be able to unsee it now
01:46:26 <merijn> :p
01:46:30 <jle`> it's cute hehe
01:46:37 <jle`> target <- arrow -< input
01:46:38 <codygman> lol
01:46:39 * Fuuzetsu uses ← so that's probably why
01:46:40 <jle`> <- arrow -<
01:47:15 <codygman> Is it totally wrong that -< is reminding me of <*>?
01:47:23 <merijn> codygman: "Generalising Monads to Arrows" is a pretty readable paper (well, the first half, you can skip the remainder anyway it's just proofs)
01:47:38 <codygman> merijn: I have it open actually ;)
01:47:38 <jle`> > (proc x -> (*2) -< x) 6
01:47:40 <lambdabot>  Pattern syntax in expression context: proc x -> (* 2) -< x
01:47:54 <jle`> aw
01:48:07 <merijn> jle`: I think that needs a do somewhere
01:48:14 <jle`> it works in ghci
01:48:16 <codygman> jle`: That works in ghci
01:48:21 <jle`> you only need a do when you link arrow statements
01:48:25 <jle`> *chain
01:48:33 <codygman> jle`: but that arrow is shooting itself :/
01:48:37 <codygman> ghc took an arrow to the knee
01:49:00 <jle`> proc x -> do { a <- (*2) -< x; b <- (+1) -< a; returnA -< (a,b) }
01:49:41 <jle`> returnA is just id but i always use it instead for some reason
01:49:55 <jle`> maybe so i feel like i'm in familiar territory
01:50:01 <jle`> the name has more semantic meaning than id so yea
01:50:46 <codygman> merijn, jle`, Fuuzetsu: Thanks for the help.
01:51:05 <jle`> codygman: it might help to toy around with some simple desguars
01:51:15 <jle`> and you will also appreciate how useful proc/do notation is
01:51:29 <jle`> proc x -> f -< x ==> f
01:51:36 <jle`> the second one is...
01:51:39 <jle`> holy crap
01:51:53 <jle`> (id ** (+1)) . (*2)
01:51:56 <jle`> er
01:52:01 <jle`> (id *** (+1)) . (*2)
01:52:06 <jle`> sorry, &&&
01:52:15 <jle`> is that how it desugars?
01:52:27 <jle`> it's equivalent but i never was able to fully read through the specs
01:52:46 <jle`> > id . (id &&& (+1)) . (*2) $ 4
01:52:47 <lambdabot>  (8,9)
01:52:57 <jle`> > returnA . (id &&& (+1)) . (*2) $ 4
01:52:58 <lambdabot>  (8,9)
01:53:12 <jle`> that's probably not how it actually desguars :| but you get the point
01:53:48 <jle`> hm
01:55:16 <jle`> this is how i might do it if i were to implement a desugarer ---
01:56:47 <jle`> > (\(a,b) -> returnA (a,b)) . (id &&& (+1)) . (*2) $ 4
01:56:48 <lambdabot>  (8,9)
01:57:05 <jle`> i don't know i'm just talking to myself at this point
01:57:14 <jle`> :)
01:57:26 <ashwin> hey, I've got a quick question about WHNF
01:57:38 <ashwin> so, I understand that lambdas are generally in WHNF
01:57:53 <Guest62174> but, do subexpressions of lambdas also have to be in WHNF?
01:58:04 <Guest62174> that is, would \x -> (2*x)+3+5 count?
01:58:09 <Guest62174> what about \_ -> 3+4?
01:58:22 <codygman> jle`: I just read everything ;)
01:58:27 <codygman> gnight all
01:58:44 <jle`> no haha i meant that it's probably not useful to anybody >.<
01:58:47 <jle`> night
02:14:43 <quicksilver> Guest36506: no, that's exactly the point
02:14:49 <quicksilver> wrong guest hmm
02:14:59 <quicksilver> Guest62174: no, that's exactly the point.
02:15:14 <quicksilver> Guest62174: the sub expresions don't have to be reduced and that's why it is WHNF not NF.
02:18:45 * hackagebot clash-lib 0.2.1 - CAES Language for Synchronous Hardware - As a Library  http://hackage.haskell.org/package/clash-lib-0.2.1 (ChristiaanBaaij)
02:23:50 <zipper`> Should I be worried about the following: `cannot find libHSghc-events-0.4.2.0.a on library path`
02:24:05 <zipper`> I have /usr/bin/ghc-events
02:35:49 <spacekitteh> so when one uses makeLenses or $(derive <xyz>), they can only be on types which are not GADTs, correct?
02:40:19 <quicksilver> spacekitteh: I think that's right. I think you have to write them yourself on GADTs although it's not hard unless your GADT is too exotic
02:41:21 <spacekitteh> hmm ok
02:43:47 * hackagebot dnssd 0.1.0.0 - DNS service discovery bindings  http://hackage.haskell.org/package/dnssd-0.1.0.0 (MaxwellSwadling)
02:45:41 <HugoDani1l> is there a good vim tags haskell tool ?
02:46:56 <HugoDani1l> im looking at fast-tags, has anyone used that ?
02:52:56 <zipper> You guys I really need some help with this: `ghc-events-0.4.2.0: cannot find libHSghc-events-0.4.2.0.a on library path`
02:53:15 <zipper> Should I be worried about that when trying to install threadscope?
02:58:40 <PatrickRobotham> Hi all, I'm having trouble install lens-4.04.
02:59:17 <PatrickRobotham> here's the code error I get
02:59:18 <PatrickRobotham> http://lpaste.net/100715
03:02:00 <tdammers> HugoDani1l: hasktags?
03:02:52 <supki_> PatrickRobotham: is it the whole log?
03:03:07 <supki_> it looks like OOM if so
03:03:28 <supki_> or something like that
03:04:11 <PatrickRobotham> supki_: whole log: http://lpaste.net/100717
03:07:25 <aleator_> Is there a common name for \f -> (==) `on` f ?
03:07:33 <Fuuzetsu> :t comparing
03:07:34 <lambdabot> Ord a => (b -> a) -> b -> b -> Ordering
03:08:01 <Fuuzetsu> not quite ==
03:08:54 <aleator_> Yeah. Good enough. How about for \f g x -> f x == g x? Besides (==) <$> f <*> g?
03:10:01 <zipper> How do I make cabal install packages get installed in the system?
03:10:10 <Fuuzetsu> @pl eq f g x = f x == g x
03:10:10 <lambdabot> eq = liftM2 (==)
03:10:21 <PatrickRobotham> zipper: Add ~/.cabal/bin to your PATH
03:10:33 <zipper> PatrickRobotham: I tried that
03:10:35 <aleator_> Fuuzetsu: Thanks.
03:10:44 <zipper> but the /lib doesn't reflect
03:10:58 <zipper> the ~/.cabal/lib
03:12:05 <supki_> PatrickRobotham: yeah, you'd need more memory; ExitFailure 9 means ghc has received SIGKILL
03:13:03 <PatrickRobotham> supki_: Thank you :)
03:33:29 <SLi> How should I use QuickCheck to check properties which are not universally quantified in any way? (Essentially, I have a prop_foo :: Bool; QuickCheck, or its cabal integration, still prints "OK, passed 100 tests", but I think it shouldn't need to run them more than once :)
03:34:12 <SLi> Or should I mix QuickCheck and HUnit and use the latter for those?
03:35:31 <opqdonut> I think it's fine
03:35:58 <opqdonut> if you start having tens of :: Bool tests, HUnit might be more applicable
03:36:04 <SLi> Ok.
03:36:29 <opqdonut> besides, looking up a constant is pretty fast, so it's not like you're paying for the 100 runs
03:36:43 <opqdonut> the computation gets done either on the first test or in CAF
03:38:14 <bahamas> why is Just 10 :: Double ok, but let val = Data.Char.ord 'a' in Just val :: Double is not?
03:38:54 <mniip> bahamas, because first specifies the 10 literal to be a Double
03:39:11 <mniip> second attempts to convert an Int to a Double
03:40:18 <bahamas> mniip: the distinction is not clear to me
03:40:40 <SLi> :t 10
03:40:41 <lambdabot> Num a => a
03:40:52 <bahamas> aah, yes
03:40:52 <SLi> :t Data.Char.ord 'a'
03:40:53 <lambdabot> Int
03:41:10 <bahamas> 10 is part of the Num class
03:41:39 <mniip> yeah, basically, Num a => a can be a Double (but also can be an Int and many other things)
03:41:43 <mniip> Int can only be an Int
03:42:35 <bahamas> true. I realized it now. my second attempt would be the equivalent of Just (10 :: Int) Maybe Double
03:42:46 <bahamas> I forgot the second ::
03:42:53 <SLi> Yes.
03:43:59 <bahamas> I'm reading lyah and it says that Maybe a is a type constructor. is Just a also a type constructor?
03:48:42 <raichoo> No, it's a value constructor that constructs a value of type 'Maybe a'
04:21:09 --- topic: 'http://www.haskell.org/ | Paste code/errors: http://lpaste.net/new/haskell | Logs: http://tunes.org/~nef/logs/haskell/?C=M;O=D http://ircbrowse.net/day/haskell/today?mode=recent | Administrative issues: #haskell-ops | Hackage down? http://hdiff.luite.com | XCode 5 issues? http://is.gd/H4sEub | Need an op? Try: @where ops'
04:21:09 --- topic: set by johnw!~johnw@c-69-245-200-160.hsd1.il.comcast.net on [Mon Feb 17 18:32:10 2014]
04:21:09 --- names: list (clog importantshock blz37 Xeno-Genesis ologNation Actreka wires BobFunk OneEyedWill conal trnh Swizec glaebhoerl bjz r444 blast_hardcheese manji011_ takuan john2x lopex ValicekB Maerten predator117 Kiryx Rylee neurocyte Sebastien-L guest-guest cowtown davorak bitemyapp nanotech ConstantineXVI jmct cwvh ormaaj jroesch liyang occamshatchet Vbitz MMuse kpence HalfWayMan arjun_ neptunepink pdxleif RogueShadow shanse posco leifw acfoltzer ortmage_ __main__ simlay_)
04:21:09 --- names: list (ryanbooker Klumben ananthakumaran2 jagtalon dflemstr joefiorini Xorlev mtlatif__ _tca zoglesby krkini ij Crate_ stelleg__ polynomi tobyp hiredman_ lightquake Madarc ethercro1 Fubar^ ndrei_ Guest14703 ktosiek_ eyck marsam_ vital_ mshroyer_ d-snp_ SethTisue____ seanparsons korpse___ ljhms_ ahf thorstadt udevd_ khy guymann_ Iceland_jack aloiscochard lpsmith_ scott shintah thasc_ raphie____ mantovan1 Starfire_ Lefeni rola_ idnar Blkt_ bgyss zeiris_ dennda_ Jei_)
04:21:09 --- names: list (ernst_ docsis_ flux Jessin si14__ ``rawr stepkut` michaelpj_ wagle_ pp^_ wilfredh aleator munro vili_ jaspervd1 Guest84615 yumike__ IceDanelol AlainODea kuribas` PatrickRobotham mgaare_ mlinksva_ caumeslasal seschwar Thooms hamid jkarni certainty Earnestly ceedubs artyomkazak zcd Robotijn_ cwu rahult zacts narendraj9 io2 quchen q66 perspectival hexagoxel sw1nn AfC goldkatze dmj` Umschwung rgr bjorkintosh karlek erkin vijaykiran waterlaz xinming ccc skchrko)
04:21:09 --- names: list (agjacome pdpi kludge` razieliyo carminemlt Guest551 gehmehgeh bahamas tazjin asc ousado Sarah lukexi Lemmih zipper randomclown thevishy no0y ivanm Guest36506 alexherbo2 m3ga Guest62174 Maxdamantus solrize jetho danilo2 redShadow _d3f snuffeluffegus arnihr Feuerbach sinclair|work amosr allsystemsarego alinab SoupEvil ts33kr OlegYch HugoDaniel pfurla jusion zpconn__ orbital__ mrb_bk xrl____ MoALTz jonsterling avdi t7 hackagebot katis mjo gbarboza canta bo2)
04:21:09 --- names: list (wchun gg7 xexonixxexillion akraut lacrosse_ BoR0 aseidl_ tv_ djcoin sxn JesuZ [[zz]] mirpa dogmaT heath alang srh Sgeo nominolo [mth]_away javawizard cdidd mindCrime_ filo3sofie Reisen kennycaosn_ maaku vmeson seantallen d3lxa n4l GGMethos george2 SegFaultAX gauthier morolin knyppeldynan Soft klaut Enigmagic mgomezch yusukesuzuki PerestoRonin jroesch_ kadoban `bps xnil mr- AleXoundOS fabjan unsymbol Raynes linduxed augur enemy kloeri ciaranm jix mjrosenb)
04:21:09 --- names: list (Fabianius drdo pnielsen thirsteh cdk dhrosa bezik idoru sea-gull fffej mreh ClaudiusMaximus edsko DarkTiger _flatline_ [aviraldg] JanBessai Lethalman omefire tzbob1 mgsloan armyriad doomlord_ osa1 danvet tesuji albertid_ arenz pieter_ k_89 rexim funfunctor joshsz bocaneri betawaffle yacks vendethiel shennyg chrra lamilami zxq9 Okasu dj_ryan_ jcristov1o boggle_ ninegrid_ numberten pqmodn_ wollw_ sm_ ssedov jayne uniquenick ddellaco_ yogurt_t_ Galactic jesyspa)
04:21:09 --- names: list (RayNbow` au__ marcus-aurelius raichoo chad `0660 Reite creichert Nyyx bobobo1618 dagle codygman drAgda Shin-LaC gienah fredyr peterhil kcliu talzeus seggy angerman joneshf-laptop MercurialAlchemi RichyB bartavelle segf Wuzzy isenmann gentleben xeno ThomasLocke Vorpal karls Roklobsta buzzykins jizanthapus ski sopvop kfish jefimenko favonia otto_s_ milfjord path[l] arpunk sellout- setmeaway nisstyre Guest61739 papna drewr recycle tavelram_ orzo_ diadara juhp)
04:21:09 --- names: list (steamboat yeshuah xl1 Ralith apaku JaredR stepcut dolio IanKelling Natch fikusz cads ivan\ n^izzo dario| treaki__ uncleBlazer cognominal hiptobecubic cjsarette mikeizbicki carter mceier crs_ Dinkar_ noam yano mljsimone paper fran timmot_ Aetherspawn Mon_Ouie rgrinberg _janne cow-orke1 mrgoodcat satshabad mononofu mindleyhilner joachifm kylcarte zenon purefn etabot Ulrar yggr td123 petantik Aleksejs LordDeath Paprikachu_ averell uu1101 Excedrin mcglk Scorchin)
04:21:09 --- names: list (adelbertc saep sykora thunderrd bytbox Philonous gspr zoktar jml skrio mniip asterblaster lurker6 _5kg mixi psquid Ivo dv- lattenwald spacekitteh BMeph jedai martingale et|kkl ezrios hamishmack obcode sam_d jonke_ adlan levi ozataman mrmonday amatsu cdh473_ indigo m1dnight hal8_ xymox slobo maurer emma timemage codesoup stevejb Internet13 ixti jle` tlevine jabbslad keyvan Sycamore AntiSpamMeta Yawgmoth Boney asjo saurik chrisch19742 n-dolio brackets Spockz)
04:21:09 --- names: list (bbloom thetallguy benj_ eL_Bart0 Fullma zalami lusory SHODAN Luke Nik05 saml gael twn Ornedan valdyn dustinswan peder DarkFox fridim_ runde pranz KitB joshbohde RevJohnnyHealey Tehnix gridaphobe mrd BlastHardcheese mnbernstein Cale JPohlmann pcapriotti DasIch nilg elrancho sirdancealo3 jibi nimish_ theorbtwo DT`` sShintah copumpkin Maior andyo grantsmith stephenmac7 sajith phienone kakos tych0 araujo ThatCantBe orzo Polarina WraithM tippenein snorble TK009)
04:21:09 --- names: list (yac mrowe_away ZsoL jbauman_ Myk267 kungp dh sipa bergey Plasmastar jmbto mk74 Matrixiumn magicman Cerise TheFuzzball _8680_ mendez earthy ofan gibsonfs dmwit mikeplus64 ilmig deevus pikhq scshunt passiveobserver l4u eamonnw ninzine hive-mind alexdoom plhk_ derekv Kruppe gthorslund zaphar_ps sohum AeroNotix tomboy64 mathu thorkilnaur irssi zeroskillor flazz Nafai zorzar dilinger felipe_ mattp_ b_jonas xaimus mavam amontez dan64 FUZxxl hc glowcoil)
04:21:09 --- names: list (hattusili_III vsayer ckx henk aoh finnrobi popx integral_ deni xintron sclv_ DigitalKiwi pi8027 Qfwfq rs0 killy9999 Valodim dreixel troydm helgikrs CosmicRay yam gemelen bhek wunki egads ziman ft koala_man aford deavidsedice dsrx tov Svedrin hpc cross vobi nwf vera pjdelport puzza007____ horlicks_ mangaba_leitosa bitraten mikecaruso1 djahandarie lahwran macron ttuegel Moiman drone| k00mi Javafant SLi Elision jrmithdobbs shiona albel727 mp Cryovat jmcarthur)
04:21:09 --- names: list (necronian iNode001 chirpsalot adimit Twey Hodapp flori dsantiago jakutis Taneb FireFly shelf joelteon kiddesr jfhall__ jj2baile honkfestival skypers tomaw cmsd2 mero boyscared Hardolaf jchee bcoppens banjiewen dawik osfameron spaceships jorendorff @ChanServ _flow_ Sagi petanqk kbotnen dmilith sordina1 companion_cube Belgarion0 fall_ fayden opqdonut Walther pierreghz Dtgr otulp bgamari fergusnoble vikraman solarus epsylon spion bduc ion lab-notes Razz Jaak)
04:21:09 --- names: list (benbangert raek froztbyte martin pharaun dixie_ FliPPeh drmegahertz johnw eagleflo relrod absence tristan__ marienz BrianHV jlewis Olive` obiwahn prinsen Vq qwandor evax epta muricula mmaruseacph2 winocm apples finster shapr profmakx mami AshyIsMe Igloo inarru_ ec WzC noteventime ivan` cschneid Thulsadu1 Deewiant cryzed haasn brixen robinbb-freenode npcomp zomg erikl_ wjlroe_ majoh shutdown_-h_now paz_ bergmark srhb Eagle_Erwin mirsal kardboardb robbert)
04:21:09 --- names: list (bholst_ helgar ChongLi_ pyykkis_ elgot jrib benmachine mietek ibid c_14 eyenx Laney mak` stiell majackson joeyh tridactyla Jello_Raptor Bigcheese lpaste dlat Martty__ Athas xnyhps awfabian vhz Clint subleq nurupo nik_89 bbee brainproxy lenstr barrucadu __class__ Tene tromp_ Phlogistique andrewsw bernalex zenzike mshoruzu liori prattmic s_e kaol tero- kragniz yeltzooo cpa qz NickHu noddy Nahra moop jliikka Kabaka_ bunzen |tch tburns niko tsou Paks Ceryn)
04:21:09 --- names: list (mountaingoat rawtass og01 `^_^v Arnar_ akurilin2 AncientPC wormphlegm saiam larsrh ido Will| MK_FG Draggor _arch Syneh myme cynick tessier Dashkal Drezil klugez yan_ jlouis wting voyd Rembane demolith1 exicer mike2 zso Gracenotes bearclaw lulf monochrom drbean brisbin jzl smarter theDon aninhumer grohne DustyDingo Zariel bstrie iross KorriX mlen Nshag Ptival aegray Dodek zerokarmaleft Ezku harski seliopou Th0mas anders^^ sa1 mimi_vx mokus oldmanstan stbuehler)
04:21:09 --- names: list (KaneTW Adeon ByronJohnson dqd Kinnison Nimatek greymalkin vpm LeaChim powellc tomprince kqr ps-auxw zebr int-e jonh ReinH earldouglas bd_ shachaf bigos Ikarus Baughn StoneToad ircbrowse edk unlink confound gseitz pfoetchen freedrull lokydor_ helmut Ke peltchu_ alexsdut1on jmob zasimov Kneiva Corey Eliel_ Guest9813 s4msung rieper krakrjak_ thoughtpolice aristid heikkih Biohazard geekosaur melter bogner peddie keko_ fnordbert taruti kalz pyrtsa Rockj so)
04:21:09 --- names: list (kittenso1p Hafydd geal stephe_ iteratee etrepum utkarsh oubiwann sleepynate sunnavy annulus gereedy TakSuyu dyreshark otterdam alexsdutton ixian flebron Khisanth jonathanj stvc Heffalump mars-92 kloplop321 mortberg thebnq \q ted1 luigy tamiko asm89 socksy Brando753 Jonno_FTW zeroXten tekacs willb1 quicksilver dlundy_ notdan nicoo phryk burp Liskni_si Raynos ahihi qrada koninkje_away dp_wiz ckw regtools ghorn ParahSailin lieven_ japesinator shepheb eyem)
04:21:09 --- names: list (Counter-Strike iron_houzi davd dumbhat Gothmog_ saarin natte bind2 ephess quaestor aji kipras FreakyPenguin hpd boegel rasmusto schlumpi jackhill sdx23 Nickeeh defanor_ edwtjo_ estewei maoe nemesit|znc M-ou-se supki_ joogi gfarfl_ zymurgy CindyLinz mist11`off ccasin xplat MasseR_ brandonw Erstarrung GaveUp releaf hvr robj_ Revenrof cyphase cods inr MitchW riceandbeans PHO_ julmac|2 zalzane OceanSpray Adios Spaceghost cizra Douglas bsmt newsham_ Chousuke)
04:21:09 --- names: list (drbop_ dschoepe oinkina tdammers solirc zarul adnap Axman6 stevely jrslepak rk[lies] Zolomon liszt NobbZ simon statusfailed kmicu chipdude_ Derander mephx_ Eridius Lindrian [swift] mrshoe bounb iulian mrpantoufle davorb acharles byorgey Fuco topi` kxra v0|d` fryguybob arrdem honza jaimef Saizan dcoutts copton jzelinskie xahry dju kshannon_ ehamberg Excureo Tesseraction_l lambdabot leper` necroyeti davean sleuth frontend1oader heaumer_ luite Iloiny_ tg mandu)
04:21:09 --- names: list (rmunroe jang callumacrae XMunkki tpsinnem h_chiro edunham bxc_ ryanakca SaBer_ drjfreeze lispy leroux cjay kosmikus tomejaguar talzeus_ MrRacoon_ Licenser Fuuzetsu hongminhee)
04:24:18 <raichoo> quchen: I guess that was directed towards bahamas wasn't it? ;)
04:31:47 <zipper> Could I get some help with the following ambiguous occurence errors `https://gist.github.com/urbanslug/9366247`
04:33:33 <Saizan> zipper: try hiding all those symbols when importing Graphics.Rendering.Cairo ?
04:35:24 <zipper> Saizan: I got a fix here http://trac.haskell.org/ThreadScope/ticket/32
04:35:31 <zipper> Seems it was reported.
04:35:56 <zipper> After updating the source with said changes should I ghc build?
04:36:59 <zipper> Also is there another way of applying the diff other than deleting some parts and pasting others?
04:43:04 <aleator> I just learned how to make a variant of list datatype that can contain any type except Int (or any specific type). Is this kind of thing ever useful?
04:44:02 <dmj`> aleator: how
04:45:14 <aleator> dmj`: Closed type families and ~ constraint :)
04:45:45 <dmj`> very cool
04:46:16 <osa1> do we have a arrow function in Control.Arrow for `foldr (<+>) zeroArrow`?
04:50:14 <zipper> How can apply a diff/patch as the one below? http://trac.haskell.org/ThreadScope/attachment/ticket/32/ThreadScope-explicit-cairo-imports.diff
04:51:09 <makalu> is there a recommended lens tutorial/introduction?
04:52:08 <tdammers> makalu: the lens documentation itself is pretty good
04:52:10 <tdammers> https://github.com/ekmett/lens/wiki/_pages
04:52:30 <tdammers> https://github.com/ekmett/lens/wiki/Overview this, particularly
04:52:39 <tdammers> also, the cheatsheet once you have the basics down
04:54:12 <makalu> that overview is really short
04:54:39 <dmj`> makalu: SPJ gives a good talk on lens
04:54:44 <dmj`> https://skillsmatter.com/skillscasts/4251-lenses-compositional-data-access-and-manipulation
04:55:19 <makalu> requires registration :(
04:55:37 <dmj`> makalu: I just did, it's free
05:03:02 <makalu> thanks tdammers and dmj`
06:00:37 <aib> I have a small binary tree search code. In order to return the Nth node, I need to keep track of how many nodes there are below me as well as whether one of them was the Nth node. I did this using Either, but my code looks a bit dirty: http://lpaste.net/100718 Any suggestions?
06:00:57 <randomclown> aib: sounds like you need a zipper
06:02:13 <aib> randomclown: as in map the tree from Node -> (Node, index)?
06:04:04 <aib> my function is Int -> Either Node Int; it returns a Left if the node was found and a Right (number of children) if it wasn't. I thought I could abuse Either to use bind here beautifully, but it didn't happen :)
06:10:02 <milfjord> findNth Leaf n = pure n
06:11:56 <milfjord> findNth (Node x l r) n = do { n' <- findNth l n; if n' == 0 then Left x else findNth r (n' - 1) }
06:12:40 <aib> hmm gotta try that
06:12:42 <t7> here is my idea for a haskell extension: if an expression does not typecheck, the compiler will try all possible combinations of brackets and tuple placements
06:12:47 <milfjord> findNth (Node x l r) n = do { n' <- findNth l n; when (n' == 0) (Left x); findNth r (n' - 1) }
06:13:12 <t7> so Left (Just 2)   becomes   Left Just 2
06:13:21 <t7> and  (1, 2)  becomes  1 2
06:13:32 <milfjord> t7: why not (Left, Just 2)?
06:13:36 <t7> anyone wanna fund my kickstarter?
06:13:38 <milfjord> or (Left Just, 2)
06:14:00 <t7> milfjord: no if you are explicit about parens then it accepts it
06:14:41 <t7> could make for some really funny errors when it gets parens wrong :)
06:14:51 <t7> nothing funnier than an error in production
06:15:49 <t7> think of the time savings though
06:16:03 <t7> could push back RSI for a few years...
06:18:03 <t7> it could use some kinda path finding too
06:18:09 <t7> be really efficient
06:18:27 <t7> and why stop at haskell? i could release a for-pay plugin for visual studio
06:25:06 <khyperia> t7, I've had a lot of the same ideas, but there's a problem: Readability. You *want* to have to be forced to insert parens everywhere, even if it's more difficult to write, otherwise, your code becomes a massive confusing mess of "ok wait how does the compiler parse this?"
06:26:30 <khyperia> I think I figured out (possibly incorrectly) that if you scan values from right to left and keep track of what's expected, you can produce the unique result that typechecks correctly
06:27:07 <khyperia> although I'm not sure if that works with auto-insertion of tuples, probably doesn't.
06:27:26 <khyperia> *unique result that typechecks correctly, if it exists
06:30:27 <myname_> exit
06:33:47 <fizbin> :t all
06:33:48 <lambdabot> (a -> Bool) -> [a] -> Bool
06:34:30 <FreeFull> :t any
06:34:31 <lambdabot> (a -> Bool) -> [a] -> Bool
06:38:44 <heatsink> @tell bennofs I couldn't reproduce the corrupted profile error with your forking example.
06:38:44 <lambdabot> Consider it noted.
06:52:11 <danilo2> Hello! Recently I saw something like this "data X = ... deriving (MonadReader AppConfig, ...)". What does it mean? I cannot find any information about it - I assume it is connected to monad transformers somehow, am I right?
06:55:38 <c_wraith> danilo2: that specific thing is, yes..  But the broader explanation is that it's the GeneralizedNewtypeDeriving extension
06:56:16 <heatsink> It doesn't have to be a newtype?
06:56:34 <c_wraith> It does.  I'm sure that detail was lost in translation
06:56:48 <heatsink> ok
06:56:49 <danilo2> c_wraith: hmm, Ok, I'll read about it. heatsink: sorry, my example could be wrong - it is possible, that iwt was newtype
06:57:35 <c_wraith> danilo2: it just lets a newtype declaration use an instance from the type it wrapped, without rewriting it.
06:59:06 <danilo2> c_wraith: ahh ok! thank you! that clarifies everything! By the way - do I understand correctly, that all the monad transformers in mtl have instances of all other monad transformer type classes? So when we use monad stack, it calls "lift" as many times as we need to get to the correct monad implementation?
06:59:50 <c_wraith> danilo2: yes, but it breaks down if there are two of the same transformer in a stack.
07:01:09 <remdezx> Hi! I keep getting strange error, can somebody look at it? http://lpaste.net/100723
07:01:51 <danilo2> c_wraith: right - I've never used 2 the same transformers - is it allowed? Is there any other magical support for such case or you just warned about such situation?
07:03:26 <remdezx_> this is something very strange about "forall z. "
07:04:04 <c_wraith> danilo2: Well, what's going on is that you've defined multiple different instances that could match the type in question. So the overlapping rules apply for selecting which instance to use. It doesn't all break down, it just gets less convenient.
07:05:02 <c_wraith> remdezx: yes, it is.
07:05:41 <heatsink> remdezx: What's the type of runZMQ?
07:05:47 <danilo2> c_wraith: If I get it correctly, if we use multiple different instances of the same transformer, and we just use functions without explicit lifting, always the innermost transformer instance would be selected - and you are right, it would not break, it would need to use explicit lifting if we want to use the outer one, am I right?
07:06:12 <c_wraith> heatsink: the error message includes that...
07:06:15 <heatsink> It looks like the kind of error you get when polymorphic types are passed as function arguments
07:06:44 <remdezx_> runZMQ :: Control.Monad.IO.Class.MonadIO m => (forall z. ZMQ z a) -> m a
07:06:47 <c_wraith> err, I guess it doesn't
07:06:52 <c_wraith> But that's what it had to be
07:07:00 <heatsink> Ah, yes
07:07:13 <c_wraith> Because yeah, that error message only comes when you try to use a higher-order function with polymorphic types
07:07:48 <heatsink> runZMQ takes a polymorphic argument, but (.) doesn't pass polymorphic values around
07:07:55 <c_wraith> remdezx_: it's the same problem as in http://stackoverflow.com/questions/9468963/runst-and-function-composition
07:08:08 <c_wraith> remdezx_: runST is the function where people tend to run into that first.
07:08:12 <Hodapp> folks use 0MQ with Haskell?
07:09:06 <danilo2> Hodapp: yes, do you know any nice alternative?
07:09:21 <remdezx_> Hodapp: why not use it?
07:09:51 <Hodapp> I figured there'd be some other zomgawesome concurrency framework that they'd prefer.
07:10:38 <remdezx_> c_wraith: okay... I thought I could make my code cleaner but I will leave it as it is
07:10:54 <remdezx_> c_wraith: thanks :)
07:11:35 <c_wraith> remdezx_: ultimately, it's an artifact of the choices made by haskell to make type inference work.  Haskell assumes that all values passed around are monomorphic, possibly just with an unknown type.
07:11:57 <c_wraith> remdezx_: that assumption is an important part of the hindley-milner type inference algorithm
07:12:23 <Fuuzetsu> I thought Haskell doesn't use HM but the… uhh
07:12:26 <Fuuzetsu> the other one ;P
07:12:32 <c_wraith> damas-milner?
07:12:44 <c_wraith> Really, it uses a combination of them.
07:12:47 <Fuuzetsu> pretty sure I'm thinking of something with a ‘g’ in it
07:13:17 <c_wraith> I mean, technically, GHC uses OutsideIn(X) to deal with all of its type-system extensions.
07:13:36 <remdezx_> c_wraith: Thats right. I got similar error before but in more complicated stuff. It's sad that it occurs in even simplier examples
07:13:50 <remdezx_> c_wraith: but there is nothing to do with that
07:14:21 * hackagebot animalcase 0.1.0.0 - Convert camelCase to snake_case and vice versa  http://hackage.haskell.org/package/animalcase-0.1.0.0 (ibotty)
07:14:33 <remdezx_> Hodapp: what is the name of that framework and why is it better?
07:14:37 <c_wraith> remdezx_: it's the price you have to pay for working with RankNTypes or other extensions that allow passing around polymorphic values.
07:14:38 <greg`> suggestions for a library for writing a socketbased server please
07:14:52 <remdezx_> c_wraith: exactly
07:15:05 <c_wraith> remdezx_: they enable expressing much more interesting types, but you lose type inference in some cases.
07:15:20 <Hodapp> remdezx_: oh, it's just that every time there's a library, there seems to be a better Haskellian way that people prefer... so this is all hypothetical :P
07:15:37 <greg`> haskellian
07:16:24 <remdezx_> Hodapp: okay, so whats in your opinion better than zmq?
07:16:41 <danilo2> remdezx_, c_wraith, Fuuzetsu: I think this is the same type system error, that we get when we try to create such function in haskell "test f = (f 5, f "test")", which also does not compile until we explicit write rank2types types, which is kind of ugly in some situations, but as remdezx_ told, we cannot fix it in easy way as far as I know from some talks in the past :)
07:16:54 <Hodapp> remdezx_: The point is that I don't know, but #haskell always seems to.
07:17:02 <c_wraith> danilo2: yes, that's exactly the same issue.
07:17:03 <danilo2> Hodapp: I second remdezx_'s question
07:17:20 <greg`> the #haskell hivemind
07:17:48 <joneshf-laptop> when you're looking at a class definition, how do you know the kind of its argument?
07:18:04 <Iceland_jack> > let foo f = (f (), f True) in foo id
07:18:05 <lambdabot>  Couldn't match expected type `()' with actual type `GHC.Types.Bool'
07:18:13 <Fuuzetsu> greg`: I've been trying out network-conduit that someone recommended to me the other day, perhaps that?
07:18:14 <c_wraith> joneshf-laptop: either infer from how they're used, assuming * if it's impossible to infer, or they have a signature on them.
07:18:37 <joneshf-laptop> c_wraith, where's the signature?
07:18:38 <Iceland_jack> > let { foo :: (forall a. a -> a) -> (Int, String); foo f = (f 5, f "test") } in foo id
07:18:39 <lambdabot>  (5,"test")
07:18:53 <c_wraith> joneshf-laptop: it'll be on the class declaration if there is one
07:18:58 <joneshf-laptop> c_wraith, do i just have to open up ghci and find out, or is there some documentation?
07:19:11 <c_wraith> class Foo a (b :: * -> *) where
07:19:21 <joneshf-laptop> oh
07:19:48 <joneshf-laptop> that raises questions
07:20:05 <joneshf-laptop> why do the classes in base not carry this information?
07:20:16 <joneshf-laptop> historical artifact?
07:20:29 <danilo2> c_wraith: I still belive it could be somehow fixed in the future. Maybe my beliefs are wrong, but according to: http://research.microsoft.com/en-us/um/people/simonpj/papers/higher-rank/putting.pdf it may be done - but this leads to long discussions - I just wated to send you this doc, because it is fun to read :)
07:20:42 <milfjord> joneshf-laptop: it's not H98
07:20:47 <milfjord> also, redundant
07:20:56 <c_wraith> joneshf-laptop: The only class in base that I know of that requires a kind signature is Typeable in GHC 7.8
07:21:25 <c_wraith> joneshf-laptop: Most of the time, you can determine the kind by looking at how the type variable is used.
07:21:38 <Iceland_jack> c_wraith: Categories?
07:21:50 <joneshf-laptop> hmm, i'm not sure that i agree with the way that played out
07:22:05 <c_wraith> Iceland_jack: No, inference works properly for Category
07:22:12 <Iceland_jack> oh you were talking about inference
07:22:56 <joneshf-laptop> seems like kinds take a backseat to types in the source
07:22:58 <Iceland_jack> they did make Category polykinded in 7.8 though
07:23:07 <Iceland_jack> joneshf-laptop: How so?
07:23:18 <milfjord> because kinds are an extension
07:23:20 <c_wraith> Oh really?  Huh.  I guess Category can be polykinded, can't it.
07:23:31 <joneshf-laptop> Iceland_jack, because they're not in the source
07:23:48 <c_wraith> joneshf-laptop: in general, the philosophy in haskell is "infer as much of the higher level from the lower level as possible"
07:24:09 <Iceland_jack> c_wraith: * The `Control.Category` module now has the `PolyKinds` extension enabled, meaning that instances of `Category` no longer need be of kind `* -> * -> *`.
07:24:14 <Iceland_jack> from changelog.md
07:24:45 <c_wraith> joneshf-laptop: So it infers as much about types as it can from values.  And it infers as much as it can about kinds from types.  In fact, the haskell spec doesn't even require a kind system.
07:25:26 <quchen> Is there are reason there aren't default min/max Monoid instances for Bounded types? For Int, you could define `mempty = maxBound; mappend = min`, for example.
07:25:48 <c_wraith> quchen: that instance would overlap with everything
07:26:00 <quchen> c_wraith: Then newtype it
07:27:31 <c_wraith> Ah.  In that case, just looks like no one has ever added it.
07:28:17 <Iceland_jack> quchen: Probably because in general you don't want the empty case to be the min/max bounds
07:29:04 <Iceland_jack> > minimum [] :: [Word8] -- same reason this isn't 0
07:29:05 <lambdabot>  *Exception: Prelude.minimum: empty list
07:29:06 <prophile> they exist in Data.Monoid but only for Bool :)
07:29:41 <prophile> they're also in Data.Semigroup I think
07:29:42 <quchen> That's not 0 because of parametricity.
07:30:10 <Iceland_jack> quchen: You could add a Bounded constraint
07:30:25 <quchen> Then [Integer] wouldn't have a minimum function anymore :-\
07:30:38 <prophile> http://hackage.haskell.org/package/semigroups-0.12.2/docs/Data-Semigroup.html#t:Min
07:30:56 <prophile> a semigroup, or a monoid if the bounded constraint is there
07:30:57 <quchen> prophile: The semigroup avoids the mempty case, of course.
07:31:02 <prophile> precisely
07:31:10 <quchen> Oh, semigroup has a minimum Monoid?
07:31:19 <Iceland_jack> quchen: You very rarely want the {min,max}Bounds
07:31:25 <prophile> as linked above
07:31:36 <Iceland_jack> mixed with your actual results
07:31:52 <quchen> I thought you just wanted to mention semigroups in general, pardon
07:32:11 <prophile> nw
07:33:30 <Iceland_jack> There may be a usecase for such a monoid, but I think a monoid where mzero = Nothing and mappend is the min/max of the available values is more useful
07:35:28 <Clint> there are min and max semigroups
07:35:57 <Iceland_jack> https://ghc.haskell.org/trac/ghc/ticket/1952 it's an abandoned proposal apparently
07:36:15 <Clint> with Bounded-contrained monoid instances
07:36:27 <milfjord> read that as metroid instances
07:36:51 <Iceland_jack> the Samus monad
07:36:56 <Clint> with Bounded-constrained metroid instances
07:37:32 <Yaniel> kinky
07:37:36 <prophile> conal uses the min monoid quite a bit in the FRP paper
07:37:39 <prophile> so that makes sense
07:37:57 <quchen> I don't know how that thing can be abandoned
07:38:03 <quchen> I mean it's a 10-line patch
07:38:30 <quchen> It's not something you can try out and then abandon because it's too big, bad, or whatever
07:39:09 <Iceland_jack> I suppose not enough people felt it was useful
07:40:04 <mgomezch> it’s the wheel I most often reinvented until I found some useful instances in semigroups (IIRC)
07:40:36 <mgomezch> (yeah, in semigroups, as previously mentioned :)
07:46:11 <Fuuzetsu> quchen: post it up on libraries@ with 2 weeks discussion and then we can have it in
07:47:45 <greg`>  where can i read about semigroups?
07:47:46 <greg`> im still resisting the urge to go full math
07:47:58 <Iceland_jack> greg`: any book on abstract algebra
07:47:59 <quchen> Last time I posted something nobody cared :-C
07:48:12 <greg`> Iceland_jack: see last comment :P
07:48:13 <shapr> greg`: You can join the google semigroup that discusses abstract algebra
07:48:14 <quchen> greg`: semigroup = monoid without mempty
07:48:30 <Iceland_jack> greg`: Semigroups are very simple concepts
07:48:40 <greg`> ah ..... thanks all
07:49:01 <Iceland_jack> You can know what semigroups are about in.. 2 minutes? 4
07:49:17 <quchen> Depends on how long it takes you to read "semigroup = monoid without mempty" ;-)
07:49:36 <Iceland_jack> quchen: And on how familiar you are with monoids and identities :) but yes
07:50:01 <Iceland_jack> that's not the same as understanding their implications, categories and groups have very simple definitions as well
07:51:00 <quchen> Reading a book on linear algebra is probably not the right way to learn about the semigroup typeclass.
07:51:56 <Iceland_jack> no definitely not
07:52:19 <t7> @hoogle Int -> a -> (a -> a) -> a
07:52:20 <lambdabot> Data.Sequence iterateN :: Int -> (a -> a) -> a -> Seq a
07:52:20 <lambdabot> Data.Sequence adjust :: (a -> a) -> Int -> Seq a -> Seq a
07:52:20 <lambdabot> Data.IntMap.Strict adjust :: (a -> a) -> Key -> IntMap a -> IntMap a
07:52:42 <Iceland_jack> I shouldn't have suggested reading a book if that's greg` was interested in
07:53:07 <greg`> hmmm i worryh about disappearing into my own navel with the category theory
07:53:07 <greg`> im trying to cut down on category theory
07:53:07 <greg`> just taking it one day at a time, you know, sometimes i have a good day
07:53:57 <Iceland_jack> You can get by fine in Haskell without knowing any category theory by the way
07:54:36 <shergill> category theory needs an IUPAC like naming convention. or is there already one, and i'm just unaware of it?
07:55:58 <Iceland_jack> shergill: Does it need it more than other fields of mathematics?
07:57:06 <cariveri_> hey. can anyone help me with a indentation/type error? http://lpaste.net/100727
07:57:21 <shergill> Iceland_jack: well it's not the one which needs most. but some sub-fields of maths seem to need it more than others. also, that could also just be attributed to sampling error
07:57:50 <shergill> but category theory, abstract algebra seem to be up there
07:58:01 <greg`> cariveri_: looks like its the hashes
07:58:14 <greg`> i think haskell single comment is --
07:58:28 <milfjord> cariveri_: what error?
07:58:38 <quchen> Category theory has IUPAC naming: at least half the names are random.
07:59:14 <Egbert9e9> is there a thing called "funtion"?
07:59:37 <quchen> Not that I know of.
07:59:40 <Iceland_jack> Egbert9e9: not really
08:00:00 <Iceland_jack> No doubt a misspelling of 'function'
08:00:07 <Egbert9e9> cool
08:00:21 <milfjord> or funtime
08:01:39 <shergill> quchen: yeah, that doesn't help. i guess i should've clarified that the naming convention in question should be composed of a small number of atomic components strung together. i.e., the 'goodness' of a naming convention being inversely proportional to some monotonically increasing function of number of such atomic components
08:06:07 <cariveri> milfjord: when I insert those exJS lines somewhere in the setup function then youll see it. I thought I could execute just any fct :: UI ()  in there.
08:07:58 <milfjord> cariveri: no, I don't see it
08:08:06 <milfjord> in fact, I can't see anything you do
08:09:20 <cariveri> milfjord: take line 65 and paste it to 49 e.g.   as you can see Id like to call js somewhere in there, because the native html's js isnt executed. threepenny has controle of js.
08:10:02 <milfjord> you're assuming I have a haskell compiler
08:10:15 <milfjord> and all those libraries
08:10:22 <milfjord> what even is Paths
08:11:18 <thehenster> Hello all. I have a newbie question. In this snippet: https://github.com/sleepyfox/7L7W-Haskell/blob/master/day1/colours.hs is the filter "x <= y" applied while the input is being collated.. or after?
08:12:38 <cariveri> milfjord: Just imagine ghci is telling me that on line 50 is an (possibly) identation error if I pasted line 65 to 49.
08:12:40 <Iceland_jack> thehenster: Well it doesn't really matter since Haskell is non-strict
08:12:51 <milfjord> cariveri: no, I will not
08:13:00 <milfjord> if you want actual help, give me actual errors
08:14:06 <cariveri> milfjord: the actuall eror I dont understand because there is no message for it. all I got is that: parse error (possibly incorrect indentation or mismatched brackets)
08:14:29 <Iceland_jack> thehenster: The evaluation of
08:14:29 <Iceland_jack>     [ e | b, Q ]
08:14:29 <Iceland_jack> is the same as
08:14:29 <Iceland_jack>     if b then [ e | Q ] else []
08:14:51 <Iceland_jack> and you can just as well thinking of it as a list that gets filtered out
08:14:57 <milfjord> cariveri: what, no file name?
08:16:39 <thehenster> Iceland_jack: Thanks for replying. I thought 'b' in your example was the input? I'm not sure I understand how your too statements are the same..
08:16:54 <thehenster> *two
08:16:58 <Iceland_jack> thehenster: ah sorry, that's just how it looks in the Haskell Report
08:17:10 <cariveri> milfjord: http://lpaste.net/100727 that is that file.
08:17:14 <Iceland_jack> http://www.haskell.org/onlinereport/exps.html, 3.11 List Comprehensions
08:17:22 <milfjord> cariveri: how do you know?
08:18:19 <cariveri> milfjord: because I put it there? ghci of course tells me abotu my local file from which I copied.
08:18:38 <ski> @undo [e | b,x <- xs]
08:18:38 <lambdabot> if b then concatMap (\ x -> [e]) xs else []
08:18:40 <milfjord> cariveri: so you're still refusing to show me the error message?
08:18:50 <Iceland_jack> @undo  [(x,y) | x <- colours, y <- colours, x <= y ]
08:18:50 <lambdabot> concatMap (\ x -> concatMap (\ y -> if x <= y then [(x, y)] else []) colours) colours
08:19:11 <Iceland_jack> thehenster: It's a good exercise to go through the transformation steps in the Report yourself
08:20:37 <functor_fag>  test
08:20:38 <cariveri> milfjord: not refusing. Im trying to give you all you need to know. file:50 parse error ... (as pasted before) Failed, modules loaded: Paths. but that last part isnt relevant. thats it.
08:21:00 <milfjord> I repeat: if you want actual help, give me actual errors
08:21:27 --- mode: ChanServ set +o milfjord
08:21:41 <Iceland_jack> thehenster: Do you understand the desugared version?
08:23:27 --- mode: milfjord set -o milfjord
08:23:58 <cariveri> milfjord: what do you expect me to do? if the error message was telling me exactely what the problem is and what to do, then I wouldnt need to ask for help.
08:24:00 <thehenster> Iceland_jack: It took me a sec to work out what @undo was doing.. that's a clever bot. I don't yet.. but doing some googling.
08:24:14 <milfjord> cariveri: I expect you to show me the error
08:24:21 <Iceland_jack> @undo [ x | x <- [1,2,3], even x ]
08:24:21 <lambdabot> concatMap (\ x -> if even x then [x] else []) [1, 2, 3]
08:24:23 <Iceland_jack> does that make sense?
08:24:24 <Kron> hmm, is there a function (\(f,x,y) -> f x y)?
08:24:29 * hackagebot Spock 0.4.2.4 - Another Haskell web toolkit based on scotty  http://hackage.haskell.org/package/Spock-0.4.2.4 (AlexanderThiemann)
08:24:37 <Kron> a pre built function for applying a function to two arguments
08:24:53 <milfjord> cariveri: and now you've wasted almost half an hour arguing and I've got to go
08:25:04 <Iceland_jack> Kron: where the function is an element of the tuple? not that I know of
08:25:13 <Kron> alright, thanks
08:25:18 <Iceland_jack> there is 'curry' if that helps
08:25:19 <Kron> oh wait
08:25:19 <Iceland_jack> @ty curry
08:25:20 <lambdabot> ((a, b) -> c) -> a -> b -> c
08:25:29 <Kron> is there a nontuple version? no wait that doesn't make any sense
08:25:45 <Iceland_jack> Kron: There is one where the function is not in the tuple
08:25:51 <Kron> oh! what is it?
08:25:56 <Iceland_jack> curry :)
08:26:13 <Kron> :P
08:26:14 <Kron> duly noted
08:26:21 <Iceland_jack> > uncurry (+) (25, 3)
08:26:22 <lambdabot>  28
08:27:08 <cariveri> milfjord: at the bottom of http://lpaste.net/100727
08:27:32 <Kron> but I can't quite just uncurry ($)
08:27:45 <Kron> I need a function application that takes two arguments
08:27:51 <Kron> and uncurry3 or something I suppose
08:28:03 <Kron> it's probably too unreadable to really follow through with all that
08:28:19 <Kron> the lambda form is easier to read than a complex curry/composition point free thing I'm guessing
08:28:28 <Iceland_jack> why do you need this anyway?
08:28:45 <Kron> no reason, really
08:28:48 <Kron> http://codepad.org/P1FN7s9c just doing this :P
08:28:59 <Kron> doubt I'd ever run into a strange scenario in real coding but you never know
08:29:11 <Iceland_jack> Kron: zipWith?
08:29:12 <Kron> my solution is zipBinary = map (\(f,x,y) -> f x y) .:. zip3
08:29:19 <Iceland_jack> @ty zipWith
08:29:20 <lambdabot> (a -> b -> c) -> [a] -> [b] -> [c]
08:29:28 <Iceland_jack> hm, a list of functions?
08:29:29 * hackagebot inflections 0.1.0.3 - Inflections library for Haskell  http://hackage.haskell.org/package/inflections-0.1.0.3 (jsl)
08:29:34 <Kron> yeah a list of functions
08:29:37 <Kron> zipWith won't quite work
08:29:46 <Kron> I zipped them together and just mapped the tuple application
08:29:50 <Iceland_jack> ZipList may help you
08:29:59 <Kron> .:. is from Data.Composition cause I like data.composition :$
08:30:41 <Kron> don't quite know how to use ziplists
08:30:43 <Kron> anyway, gtg
08:30:49 <Kron> thanks for the help!
08:31:56 <Iceland_jack> @ty zipWith3 ($)
08:31:56 <lambdabot> [b -> c -> d] -> [b] -> [c] -> [d]
08:32:02 <Iceland_jack> Kron: that doesn't seem healthy though :)
08:32:16 <thehenster> Iceland_jack: I get it. Thank you. Is there an @undo in ghci?
08:32:25 <Iceland_jack> thehenster: no
08:32:26 <Fuuzetsu> thehenster: no
08:32:40 <Iceland_jack> > zipWith3 (\a b -> a b) (cycle [(+), (*)]) [1..4] [2..5] -- Kron
08:32:41 <lambdabot>  [3,6,7,20]
08:32:54 <solarus> I've been reading the elm papers and both of them mentions a primitive named async. This value seems to be undefined though when trying it out in the elm javascript compiler?
08:34:07 <solarus> anyone knows anything about this? :)
08:35:13 <solarus> or is there an elm irc channel hmm
08:35:39 <solarus> yes there was trying there instead!
08:36:18 <Kron> back
08:36:22 <haasn> :t uncurry . uncurry
08:36:22 <lambdabot> (a -> b1 -> b -> c) -> ((a, b1), b) -> c
08:36:26 <haasn> ah
08:36:33 <ski> forward
08:37:23 <haasn> @tell mm_freak Have you thought about adding curry3/uncurry3 to acme-schoenfinkel? :: ((a,b,c) -> d) -> a -> b -> c -> d
08:37:23 <lambdabot> Consider it noted.
08:38:49 <joelteon> is there build-depends syntax for specifying cabal flags to be used when installing packages?
08:39:11 <dcoutts> joelteon: no, and that's a deliberate design decision
08:39:16 <joelteon> ok good
08:45:38 <quchen> haasn: häßlich3
08:46:14 <quchen> Or sehr_häßlich :-D
08:48:40 <Kron> how exactly does `ap` work?
08:48:47 <sipa> :t ap
08:48:48 <lambdabot> Monad m => m (a -> b) -> m a -> m b
08:48:52 <quchen> ap = <*>
08:48:53 <sipa> @src ap
08:48:53 <lambdabot> ap = liftM2 id
08:49:26 <Kron> ... I have difficulty even parsing that
08:49:32 <Kron> applicative functors make my brain melt :(
08:49:33 * hackagebot criterion 0.8.0.1 - Robust, reliable performance measurement and analysis  http://hackage.haskell.org/package/criterion-0.8.0.1 (BryanOSullivan)
08:49:41 <quchen> ap mf mx = do { f <- mf; x <- mx; return (f x) }
08:50:36 <Kron> okay, I want to take large groups of a single element like ('l', 'l', 'l') and convert them to ('l', 3); basically element and length
08:50:48 <Kron> right now I'm doing ((,) <$> head <*> length)
08:51:00 <Kron> which works, but I wonder if i can make it more readable and I've seen people use ap
08:51:05 <Kron> and all of this is sheer magic to me
08:51:09 <joelteon> liftM2 (,) head length
08:51:14 <joelteon> might be shorter
08:51:18 <Kron> I'm not sure what liftM2 is
08:51:21 <joelteon> or you could explicitly pattern match, that would probably be easier to read for most people
08:51:38 <joelteon> Kron: liftM2 f a b === f <$> a <*> b
08:51:52 <Kron> agreed, but I'm not sure if I'm reaching for the most readable, small solution
08:51:56 <Kron> okay
08:52:24 <haasn> quchen: let (f!) g (x,y,z) = (f g . f g) ((x,y),z) in hässlich! id
08:52:24 <joelteon> if you want the most readable solution, collapse xs@(x:_) = (x, length xs)
08:53:19 <Kron> right
08:53:34 <joelteon> it's really your choice
08:53:40 <joelteon> depends on how many people will be reading or maintaining the code too
08:53:43 <haasn> quchen: generalizes easily to hässlich!!, hässlich!!! etc. as well; assuming we want to import Prelude hiding ((!!)) :)
08:54:01 <Kron> I'm just doing random haskell exercises
08:54:17 <joelteon> oh well in that case, go with what your heart tells you
08:54:18 <Kron> so while learning to write readability is important, learning to use advanced tools is also part of the objective
08:54:34 <Kron> heh, alright
08:54:50 <joelteon> you know how to use (<$>) with functions, that's a step in the right direction
08:55:06 <klrr_> anyone got an idea how you design a extendable irc bot using FRP?
08:55:32 <Kron> well I don't actually know how to use it
08:55:41 <Kron> i've just kind of memorized the type signature from LYAH
08:55:59 <Kron> "<$> and <*> lets you apply functions to a single cloned input and then does a final function on them, got it"
08:56:07 <quchen> haasn: let (f!) g (x,y,z) = (f g . f g) ((x,y),z) in hässlich !id -- Always move the "!" to the right operand. Always!
08:56:11 <Kron> it's just a more heterogenous `on` as far as I know
08:56:50 <Kron> klrr_: that's a really fascinating concept
08:57:02 <Kron> FRPing an irc bot sounds like a lot of fun
08:57:47 <haasn> quchen: oh that looks deliciously misleading
09:00:36 <klrr_> Kron: yeah, mm_freak purposed it. i just dont understand how to design it so its more extendble than callback approuch :s
09:01:03 <Kron> are there any great FRP systems in haskell?
09:01:12 <klrr_> reactive-banana is pretty good
09:05:21 <hc> why does Text.Printf not use template haskell?
09:05:56 <Fuuzetsu> because this and that and the other
09:06:03 <hc> okay
09:06:06 <Fuuzetsu> look at the seven million discussions on the mailing lists
09:06:09 <hc> oh
09:06:13 <hc> sry, didn't know about htese
09:06:17 <hc> will look it up, thanks!
09:06:18 <Fuuzetsu> ;P
09:06:20 <haasn> hc: because there's Text.Printf.TH
09:07:35 <haasn> actually I wonder if that one is decent
09:07:48 <haasn> oh
09:07:51 <haasn> you want printf-mauke
09:08:07 <haasn> That's the one I was thinking of
09:09:19 <Fuuzetsu> we have a few papers about type-safe printf without dependent types but did any implementations make it on to Hackage?
09:09:28 <carter> Fuuzetsu: yup
09:09:30 <carter> no one uses em :)
09:09:35 <Kron> how do we query infix priorities?
09:09:39 <Kron> for parsing
09:09:43 <carter> for parsing what
09:09:49 <carter> with wich tools
09:09:49 <haasn> Fuuzetsu: are you thinking of something like http://hackage.haskell.org/package/xformat ?
09:10:03 <Kron> just haskell parsing
09:10:08 <haasn> that uses a type-safe format specifier (this is not possible with a string without TH)
09:10:09 <Kron> (a . b `ap` c . d)
09:10:17 <Kron> will that apply the dots first?
09:10:35 <haasn> Kron: you can use :i in GHCi to query the precedence of operators
09:10:42 <Kron> thank you!
09:10:45 <haasn> (.) is infixr 9 .
09:10:52 <haasn> ap has no precedence, which means it defaults to.. something
09:10:57 <haasn> I can never remember what
09:11:15 <Fuuzetsu> haasn: looks a bit heavy-handed
09:11:26 <haasn> Fuuzetsu: not sure what you're looking for
09:11:39 <haasn> Fuuzetsu: oh, wait, you said without dependent types - not necessarily without TFs/DataKinds
09:12:05 <Fuuzetsu> Well, you can have a look at Oleg's printf stuff as well as bunch of others
09:12:15 <haasn> Fuuzetsu: you could do printf (Format :: Format "foo bar %s bat %d baz") and calculate the type in the type system
09:12:19 <haasn> using DataKinds
09:12:33 <haasn> + TypeFamilies. Maybe.
09:12:37 <haasn> Actually, I think that's still impossible
09:14:20 <haasn> Kron: the default is infixl 9
09:14:28 <Kron> yeah I just ran into it
09:14:28 <haasn> Kron: which means that this is mixing infixl 9 and infixr 9 and will actually be a parse error
09:14:33 <Kron>         cannot mix `.' [infixr 9] and `ap' [infixl 9] in the same infix expression
09:14:40 * Kron nods
09:16:20 <Kaidelong> if there exists a mapping for each m to get (Monad m) => m t -> Cont r t, coudln't something like this be used instead of monad transformers?
09:17:27 <Kaidelong> I guess you would lose type safety
09:17:41 <Kaidelong> since Cont lets you introduce any effect without typing it
09:18:34 <Fuuzetsu> what's meant by ‘qualified types’?
09:18:45 <Fuuzetsu> I guess I'll just Google it.
09:19:08 <JagaJaga> Hi guys. How to force cabal install packages in sandbox only? I mean dodn't look what pkgs I've already have in my system and install everything listed in .cabal file..
09:19:24 <geekosaur> you don't
09:19:32 <triliyn> Fuuzetsu: I think that means things with a namespace specified
09:19:35 <geekosaur> if you need something like that, you might be better served by hsenv
09:19:38 <triliyn> Like Data.Map.Map
09:19:47 <triliyn> As opposed to just Map
09:19:58 <dcoutts> JagaJaga: cabal sandbox will let you ignore the per-user package db, but not the global one
09:20:07 <geekosaur> (in particular, you need the base package from the global db or nothing will work)
09:20:11 <dcoutts> JagaJaga: it needs the global one because that contains base etc
09:20:54 <JagaJaga> oh. thx. I have problems using Nixos, vim and ghc-mod. Trying to get the solution. Have no working autocomplete
09:20:59 <Fuuzetsu> triliyn: No, I don't think that's it ;P ‘fts :: {x:String | isPrefix "d" x && not (elem '%' x)} -> String’ is apparently using qualified types
09:21:22 <triliyn> Fuuzetsu: oh, I have no idea then
09:21:37 <Kaidelong> is that even haskell?
09:21:40 <Fuuzetsu> JagaJaga: Have you seen http://ocharles.org.uk/blog/posts/2014-02-04-how-i-develop-with-nixos.html ? It seems you could just escape sandboxes all together with nix
09:21:46 <Fuuzetsu> Kaidelong: No
09:22:03 <Fuuzetsu> see http://okmij.org/ftp/typed-formatting/#dep-type
09:23:57 <Fuuzetsu> JagaJaga: …at least that's why I'm leaning towards it. I even tried it out the other day for few minutes.
09:24:04 <JagaJaga> Fuuzetsu, no, everything works awesome, but with no working ghc-mod :( Think it's a nixos bug
09:26:13 * Fuuzetsu gave up on having a working ghc-mod long time ago
09:26:43 <Fuuzetsu> it breaks far too much when switching GHC versions and I often had times where the library worked but the executable didn't and the other way around too.
09:29:37 * hackagebot lens 4.0.5 - Lenses, Folds and Traversals  http://hackage.haskell.org/package/lens-4.0.5 (EdwardKmett)
09:34:16 <joelteon> did the behavior of cabal repl change recently?
09:34:22 <Fuuzetsu> change how?
09:34:28 <joelteon> It used to give me a REPL even if a module wouldn't compile
09:34:31 <joelteon> but now it doesn't
09:35:13 <Fuuzetsu> I don't remember it giving a REPL  when compilation failed but my memory is terrible.
09:35:37 <dcoutts> joelteon: where is the failing module, relative to the component you're loading in the repl?
09:35:47 <dcoutts> same component, different? dependent?
09:36:25 <joelteon> ok, so I have a yesod project where one of the handlers won't compile because something isn't in scope
09:36:43 <joelteon> it used to be that if I ran cabal repl, in this situation, cabal would print out the error message then give me a shell with all the modules that *would* compile loaded
09:36:50 <joelteon> then I could :r once i'd fixed the bug and it would load the other ones
09:36:58 <joelteon> now it prints out the error message and pops me back to the command line
09:37:52 <dcoutts> joelteon: this is a package with only one component?
09:38:18 <joelteon> no there are several
09:38:29 <joelteon> a library, an executable, and a test suite
09:38:50 <dcoutts> joelteon: so it's not something simple like the failing module is in the lib, and you're running repl on the exe?
09:38:56 <dcoutts> where the exe depends on the lib
09:39:06 <joelteon> well, I'm about to find out
09:39:15 <dcoutts> in which case no, the behaviour has not changed
09:39:22 <briennetheblue> if I have 4 Word8 in "native byte order" is there an easy way to them into a Word32 without asking myself what my byte order is?
09:39:38 * hackagebot STL 0.2 - STL 3D geometry format parsing and pretty-printing  http://hackage.haskell.org/package/STL-0.2 (bergey)
09:39:50 <joelteon> dcoutts: even if I explicity make the library the repl target, it exits early
09:39:56 <dcoutts> briennetheblue: shift & or
09:39:58 <briennetheblue> i think that would just be a cast in C
09:40:05 <joelteon> now I wonder what happens if I introduce a bug once the repl is loaded
09:40:22 <briennetheblue> dcoutts: doesn't that depend on what my byte order is
09:40:43 <joelteon> well, if I do that, the repl stays open and it gives me the error message
09:40:45 <joelteon> which is what I'd expect
09:40:53 <dcoutts> briennetheblue: oh, right the point is you don't actually know what order your bytes are in
09:40:59 <briennetheblue> dcoutts: yup
09:41:02 <milfjord> briennetheblue: I'd like to see that cast in C
09:41:29 <carter> dcoutts: what are the best defns for foldl' and foldr' (if i'm writing em for statically sized lists)
09:41:41 <joelteon> I'll install an older version and check that I'm not going insane
09:41:43 <briennetheblue> hm... i know they're in native byte order, so just a cast in C would work right?
09:41:43 <carter> is the Data.Foldable model a sane one?
09:41:51 <milfjord> briennetheblue: a cast from what to what?
09:42:03 <dcoutts> joelteon: can I see a log? run cabal repl -v3
09:42:17 <joelteon> ok hang on
09:42:23 <dcoutts> joelteon: we run ghci and we don't tell it to exit early
09:42:24 <briennetheblue> from a pointer to an array of char to a pointer to an int i think...
09:42:39 <milfjord> yeah, that's UB
09:42:43 <joelteon> okay
09:42:45 <milfjord> likely to cause SIGBUS, even
09:42:54 <joelteon> i'll create a smaller test package
09:43:00 <joelteon> this one won't be very helpful for debugging
09:43:07 <joelteon> too many dependencies
09:43:10 <dcoutts> joelteon: the only time you should see it fail before starting ghci is when it's in a different component (or if we have to compile a different "way" for some reason)
09:43:29 <dcoutts> joelteon: a log would be enough probably
09:43:40 <carter> dcoutts: would your thesis have anythings?
09:43:48 <milfjord> > PortNum 1
09:43:49 <lambdabot>  Not in scope: data constructor `PortNum'
09:44:00 <milfjord> :-(
09:44:06 <dcoutts> briennetheblue: so you can do the same trick, poke the bytes to a buffer, peek a word
09:44:40 <dcoutts> briennetheblue: Foreign.Storable
09:44:58 <dcoutts> carter: can you be more specific?
09:45:00 <milfjord> or you could define isBigEndian = PortNum 1 == 1
09:45:13 <dcoutts> carter: foldl' and foldr' on lists?
09:45:21 <carter> well, lists + a static size param
09:45:36 <dcoutts> carter: but still really the normal list type
09:45:40 <carter> yeah
09:45:48 <dcoutts> carter: in which case foldr' doesn't really make a lot of sense
09:45:50 <carter> ok
09:45:58 <carter> well, its also a value strict list
09:46:23 <carter> yeah, foldr' seemed like a weird thing
09:46:30 <dcoutts> carter: foldr' makes sense when you can access the back of the list directly and process it in reverse order (e.g. an array)
09:46:35 <carter> ok
09:46:52 <dcoutts> carter: I don't think the size hint will help you
09:46:59 <carter> fair
09:47:17 <carter> if I inline my foldr, will it unroll on a static sized list?
09:47:20 <dcoutts> carter: if you were producing a stream then it could be helpful, but you're folding
09:47:23 <carter> yeah
09:47:28 <carter> streams don't matter here
09:47:39 <briennetheblue> dcoutts: thanks
09:47:43 <carter> i'm using this as generic interface for multi dim array indexing
09:47:44 <dcoutts> carter: no, recursive functions are not inlined
09:48:09 <carter> dcoutts: so i should unroll the pattern matching to handle the first 4-5 sizes?
09:48:43 <dcoutts> carter: you can get unrolling if different sizes are different types, e.g. using type class trickery
09:48:51 <carter> yeah
09:48:59 <dcoutts> because then it's not really recursive
09:49:04 <carter> yeah
09:49:24 <carter> i was doing that, but i dind't like how much type class constraints would creap in
09:49:53 <carter> can i emulate by INLINE + top level case to check if its a size 0 - 4 list
09:50:44 <carter> f [] = .. ; f [a] = ... [] ; f [a,b] = ... ;  f general = ....
09:50:58 <carter> i agree the type class approach definitely works
09:51:09 <carter> just trying to explore an alternative
09:52:15 <dcoutts> carter: yep, you can do the top level special cases and ghc will specialise when it inlines
09:52:22 <carter> ok
09:52:37 <carter> yay
09:52:59 <carter> happilly most people will just be dealing with dim <= 4 arrays
09:53:08 <carter> heck, even just dims 0-2
09:54:21 <carter> thanks duncan
09:54:26 <dcoutts> np
09:54:32 <carter> :)
09:54:40 <carter> none the less appreciated
09:55:01 <carter> i could do the type class approach alternatively, but i'm trying to be moderate in my types complexity budget
09:55:20 <magneticduck> http://ix.io/aX2
09:55:31 <magneticduck> problem with style
09:55:51 <magneticduck> really simple trivial thing
09:55:53 <carter> magneticduck: you don't need to use case
09:55:58 <magneticduck> but was wondering, what's the standard way of doing it
09:56:05 <magneticduck> carter: it's part of a larger definition, so I actually do
09:56:07 <carter> f []  = ... ;  f (a:as) = ...
09:56:12 <carter> you can do a local where
09:56:17 <carter> and pattern rules there
09:56:25 <magneticduck> yeah, but what's case for anyway?
09:56:32 <carter> its for pattern matching
09:56:35 <magneticduck> exactly
09:56:48 <magneticduck> that's what I'm using it for; it's handier for my context
09:56:48 <carter> you could do (_:[])
09:56:51 <carter> cool
09:56:54 <carter> so whats the question
09:57:02 <magneticduck> what's the stylish way of doing it
09:57:10 <magneticduck> just wondering x|
09:57:14 <carter> dpeends on the style of the ambient code
09:57:18 <carter> theres more than one good style
09:57:26 <carter> i'm kinda only now developing my own haskell style
09:57:31 <magneticduck> it's a really simple context in this case, but I'm wondering what the good style is, to be applied to more complex cases
09:57:32 <carter> and thats after years of haskellin
09:57:36 <milfjord> magneticduck: what is this supposed to do?
09:57:38 <magneticduck> I see
09:57:52 <milfjord> because the different versions do different things
09:57:54 <magneticduck> milfjord: remove fold markers from a piece of text
09:57:59 <magneticduck> really?
09:58:01 <magneticduck> nooo
09:58:02 <milfjord> magneticduck: what are fold markers?
09:58:10 <magneticduck> oops, I mean "tail"
09:58:16 <magneticduck> in the first definition, not init, tail
09:58:25 <milfjord> I don't get it
09:58:29 <milfjord> sample input/output?
09:58:31 <magneticduck> milfjord: I'm using "fold markers" to mark folds in my source files
09:58:33 <magneticduck> yes
09:58:44 <magneticduck> it's just a silly thing I was writing, part of something more interesting
09:59:20 <jfischoff> magneticduck: there are a few style guides, and you can look at the code of master haskell hackers
09:59:38 <magneticduck> okay
09:59:42 <magneticduck> I should do that
09:59:48 <jfischoff> http://stackoverflow.com/questions/6398996/good-haskell-source-to-read-and-learn-from/6399082#6399082
10:00:11 <jfischoff> https://github.com/tibbe/haskell-style-guide/blob/master/haskell-style.md
10:00:26 <carter> yeah
10:00:36 <jfischoff> there are more sources but I would start with those
10:00:36 <carter> the Tibbe one is a good "syntatic" style guid
10:00:55 <magneticduck> I personally have been having my own style, so I should probably read some others to not get too far from the main stream
10:00:56 <carter> but theres many coding / ways of writing good haskell styles
10:01:10 <magneticduck> and there's several level of style to think of
10:01:29 <magneticduck> there's the general macro style, the micro syntax style...
10:01:31 <jfischoff> magneticduck: the stream you speak of does not exist
10:01:41 <magneticduck> jfischoff: =P
10:01:42 <joelteon> dcoutts: think it's a GHC thing, not a cabal thing
10:01:43 <joelteon> i'll file a ticket
10:01:48 <jfischoff> :)
10:02:01 <dcoutts> joelteon: 7.8?
10:02:04 <joelteon> yep
10:17:43 <shergill> is there a function to convert MaybeT m a to ListT m a?
10:18:53 <milfjord> @unmtl MaybeT m a
10:18:53 <lambdabot> m (Maybe a)
10:19:05 <bennofs> @ty runMaybeT
10:19:06 <lambdabot> Not in scope: `runMaybeT'
10:19:07 <milfjord> @unmtl ListT m a
10:19:07 <lambdabot> m ([] a)
10:19:15 <bennofs> @let import Control.Monad.Trans.Maybe
10:19:15 <milfjord> @hoogle Maybe a -> [a]
10:19:16 <lambdabot>  Defined.
10:19:17 <lambdabot> Data.Maybe maybeToList :: Maybe a -> [a]
10:19:17 <lambdabot> Data.Foldable toList :: Foldable t => t a -> [a]
10:19:17 <lambdabot> Data.Maybe catMaybes :: [Maybe a] -> [a]
10:19:21 <bennofs> @ty runMaybeT
10:19:22 <lambdabot> MaybeT m a -> m (Maybe a)
10:19:39 <milfjord> :t fmap maybeToList
10:19:40 <lambdabot> Functor f => f (Maybe a) -> f [a]
10:19:56 <Iceland_jack> This is like watching a recipe unfold..
10:20:23 <milfjord> is that what the r in unfoldr stands for
10:20:47 <Iceland_jack> that must be it :)
10:22:30 <bennofs> @ty lift . runMaybeT >=> maybe mzero return :: Monad m => MaybeT m a -> ListT m a
10:22:32 <lambdabot> Monad m => MaybeT m a -> ListT m a
10:23:36 <milfjord> :t ListT . fmap maybeToList . runMaybeT
10:23:37 <lambdabot> Functor m => MaybeT m a -> ListT m a
10:23:40 <bennofs> Is there a shortcut for (>>= maybe mzero return) ? Or maybe mzero return?
10:24:51 <Iceland_jack> Well there is maybeToList
10:25:48 <Iceland_jack> does the same for when m ~ []
10:30:03 <jfischoff> new split
10:30:08 <jfischoff> oops
10:30:59 <cschneid> what was the name of the project that attempted to reimplement bignum math in haskell, rather than gmp, maybe a month or three ago?
10:31:38 <Iceland_jack> Was it simple-integer
10:31:39 <Iceland_jack> ?
10:31:49 <Iceland_jack> or integer-simple..
10:32:04 <cschneid> it was written at a low level trying to optimize for speed
10:32:15 <Iceland_jack> https://ghc.haskell.org/trac/ghc/wiki/ReplacingGMPNotes maybe this is useful
10:32:15 <cschneid> under the "don't link against lgpl" grossness that gmp has
10:32:33 <ClaudiusMaximus> integer-simple is part of GHC that can be used instead of integer-gmp, but it's performance is dreadful, or was the last time i tried
10:33:00 <ClaudiusMaximus> and recompiling ghc to use it isn't exactly fun
10:33:16 <ClaudiusMaximus> *its
10:33:21 <cschneid> ya, there was a new library that attempted to fill the same role, written in haskell, but with primops and such, aiming for optimization
10:33:27 <Iceland_jack> ClaudiusMaximus: What *do* you consider fun then :)
10:33:29 <cschneid> I can't find it in my email ...
10:33:55 <Iceland_jack> cschneid: Do post it here if you find it, I recall hearing about it and am curious
10:34:01 <cschneid> oh, maybe this? http://www.mega-nerd.com/erikd/Blog/CodeHacking/Haskell/integer_pt1.html
10:34:16 <cschneid> no damn it
10:35:49 <cschneid> yeah, it is that: more links in the reddit thread: http://www.reddit.com/r/haskell/comments/1twtvm/the_problem_with_integer/
10:36:48 <Iceland_jack> thanks cschneid
10:36:49 <Iceland_jack> I would be pleasantly surprised if a pure-Haskell library could hold its own against GMP
10:36:54 <cschneid> > This will be open sourced (the library and all testing and benchmarking code) as soon as I get permission to do so from my employer (yes, doing this in my own time, but thats what my employment contract says I have to do).
10:36:55 <cschneid> damn
10:36:56 <lambdabot>  <hint>:1:110: parse error on input `do'
10:37:13 <cschneid> sorry lambdabot, that wasn't for you - that was a quote from the thread.
10:37:34 <geekosaur> I would be surprised as well unless we're using a non-asm version of gmp
10:38:24 <magneticduck> lols interesting syntax error
10:38:30 <magneticduck> "the last word in the phrase doesn't look right!"
10:38:42 <magneticduck> s/phrase/statement
10:39:10 <cschneid> magneticduck: thought that was funny too. Everything else could have been functions I guess, and it hadn't resolved those names, but `do` is syntax, so it barfed on taht first
10:39:36 <cschneid> Iceland_jack: from what I understand, "hold its own" is possible, but rather unlikely to be as fast
10:40:00 <geekosaur> it looks to the parser like a function call with a lot of parameters, but a dangling "do"
10:40:01 <cschneid> but within 2x would be totally fine for most everything, and get rid of a dependency. As long as you can still link gmp when you do need hardcore math, that'd be cool
10:40:04 <briennetheblue> rephrasing my previous question: the first four bytes of a ByteString i receive is the message length, guaranteed to be in native byte order for me.  Data.Binary assumes network order.  is the sensible approach just to ask what my endianness is and reverse the bytes if necessary? i shouldn't have brought up C because i know even less about that than Haskell..
10:40:11 <carter> cschneid: its work in progress but not public
10:40:38 <carter> but it'll happen
10:40:46 <carter> theres also plans for other approaches too
10:40:46 <cschneid> carter: my ulterior motive is that a friend is doing the same thing w/ Rust's bignum library. He updated the gmp wrapper and wants to play w/ the algorithms a bit to do some native rust impls.
10:40:54 <carter> oh
10:40:57 <cschneid> was hoping for some code to send his way :)
10:41:03 <carter> heres a book instead
10:41:19 <carter> http://shoup.net/ntb/
10:41:24 <carter> he should read that first
10:41:25 <cschneid> haha, if I send it to him, I'll derail him totally, he's the kind who will dive into a hardcore algorithm book :)
10:41:29 <carter> ok
10:41:30 <carter> well
10:41:33 <carter> thats a good thing
10:41:43 <cschneid> well, the derail part not as much :)
10:41:46 <carter> nope
10:41:47 <carter> it is
10:41:48 <cschneid> he should keep his day job
10:41:51 <carter> oh
10:41:56 <carter> he's on the rust team?
10:41:59 <cschneid> he's not
10:42:05 <carter> i meant derail him on the rust projec
10:42:11 <cschneid> ahh, no.
10:42:13 <carter> t'cause theres no simd story for rust yet... and
10:42:13 <carter> :)
10:42:21 <carter> until you can simd
10:42:30 <carter> by hand
10:42:35 <carter> no big num story in rust will shine
10:42:42 <Actreka> Can someone explain why this doesn't work and how I would fix it?: "map sqrt . takeWhile (<1000) [x^2|x<-[1..], odd x]"
10:43:06 <carter> Actreka: what error do you get
10:43:13 <carter> oh
10:43:17 <carter> Actreka: try  1.0 ...
10:43:20 <geekosaur> it doesn;t work because you are using (.) to apply a function to a value
10:43:21 <carter> * 1.0 ..
10:43:25 <carter> oh that too
10:43:28 <carter> use $ instead of .
10:43:43 <Actreka> It didnt work with $ either IIRC
10:43:54 <Actreka> geekosaur: Isn't that what the dot is for?
10:43:56 <Hafydd> You'll want (sqrt . fromIntegral).
10:44:03 <geekosaur> no, (.) composes functions
10:44:22 <geekosaur> > (5 +) 3
10:44:23 <lambdabot>  8
10:44:29 <Actreka> geekosaur: But isn't the last part a function? :/
10:44:33 <geekosaur> > (5 +) . 3 -- this is what you are doing
10:44:34 <lambdabot>  No instance for (Data.Typeable.Internal.Typeable c0)
10:44:34 <lambdabot>    arising from a use of `M62446284942834938106976.show_M62446284942834938106...
10:44:34 <lambdabot>  The type variable `c0' is ambiguous
10:44:34 <lambdabot>  Possible fix: add a type signature that fixes these type variable(s)
10:44:34 <lambdabot>  Note: there are several potential instances:
10:44:54 <geekosaur> it is a fully applied function, which means it produces a value, not a function
10:45:09 <magneticduck> hmm, Control.Monad.Reader is exported from two packages!
10:45:10 <Actreka> geekosaur: Oh! Eureka!
10:45:11 <magneticduck> what to do?
10:45:21 <Hafydd> If you write it as "(map sqrt . takeWhile (<1000)) [x^2|x<-[1..], odd x]" it would do what you think it does.
10:45:29 <magneticduck> I'm just making a little standalone haskell file, so no cabal to help me
10:45:47 <Cale> magneticduck: ghc-pkg hide monads-tf or whatever it was
10:46:26 <Actreka> Hafydd: I got errors again, is it because I tried it in ghci?
10:46:27 <magneticduck> hmm... but cabal projects that require monads-tf can still find it?
10:46:29 <magneticduck> Cale
10:46:32 <Cale> magneticduck: yes
10:46:45 <cschneid> carter: thanks for that book link, looks cool for me to skim
10:46:52 <magneticduck> Cale: alright cool
10:46:54 <carter> happy to snipe :)
10:47:42 <Hafydd> Actreka: no, you probably didn't read carefully enough.
10:47:43 <Hafydd> Prelude> map (sqrt . fromIntegral) $ takeWhile (<1000) [x^2|x<-[1..], odd x]
10:47:44 <Hafydd> [1.0,3.0,5.0,7.0,9.0,11.0,13.0,15.0,17.0,19.0,21.0,23.0,25.0,27.0,29.0,31.0]
10:48:31 <magneticduck> boy, it seems like "catch" brings up a can of worms in most languages
10:48:33 <Actreka> Oh, I see. Thank you
10:48:35 <magneticduck> it's not used much in haskell is it?
10:48:43 <ixmatus> I'm trying to delete a single node from an HTML document with HXT - I've figured out how to delete all occurrences of a node, but not just one
10:48:44 <magneticduck> I'm going through some code that's using it extensively
10:48:55 <ixmatus> could someone point me in the right direction please?
10:50:22 <ixmatus> runX $ d >>> processTopDown (filterA $ neg (hasName "ul"))
10:50:39 <ixmatus> that is what I'm using to remove all instances of the "ul" element
10:50:54 <ixmatus> but I can't quite figure out how to restrict it to just the first UL element
10:51:53 <ixmatus> I've been banging my head on the desk for a few hours with this one so I hope someone can help
10:52:24 <magneticduck> uhmm glitch? http://www.haskell.org/hoogle/?hoogle=catch <- click on the first link, the page refrenced has no #catch tag!
10:53:01 <geekosaur> hoogle db may be out of date
10:55:21 <pdxleif> no more http://cokmett.github.io/ ? Whyyyyy???? :(
10:56:02 <briennetheblue> pdxleif: http://cokmett.github.io/cokmett/
10:56:36 <pdxleif> ah, thx.  I blame browser completion
10:59:47 * hackagebot regex-easy 0.1.0.0 - sugar for regex-pcre  http://hackage.haskell.org/package/regex-easy-0.1.0.0 (MatthiasFischmann)
11:06:02 <haasn> > [x | x <- [1..], odd x, x*x < 1000]
11:06:05 <lambdabot>  mueval-core: Time limit exceeded
11:06:13 <haasn> ah
11:06:54 <quchen> I don't understand.
11:08:25 <haasn> I wonder if it would be useful to add an extension to list comprehension syntax a la TransformListComp for “takeWhile”-type behavior
11:09:14 <haasn> Hmm
11:09:24 <quchen> List comprehensions aren't even used that often, are they?
11:09:57 <haasn> > [x | x <- [1..], odd x, then takeWhile by x*x < 1000]
11:09:58 <lambdabot>  Unexpected transform statement in a list comprehension
11:09:58 <lambdabot>  Use -XTransformListCompNot in scope: `by'
11:09:58 <lambdabot>  Perhaps you meant one of these:
11:09:58 <lambdabot>    `b' (imported from Debug.SimpleReflect),
11:09:58 <lambdabot>    `y' (imported from Debug.SimpleReflect)
11:10:19 <haasn> works here
11:10:20 <haasn> brilliant
11:10:30 <haasn> can we have TransformListComp in lambdabot now?
11:10:50 <quchen> Haha. takeWhile by x*x < 1000  == ((takeWhile by x) * x) < 1000
11:11:59 <geekosaur> @let {-# LANGUAGE TransformListComp #-}
11:11:59 <lambdabot>  Parse failed: Parse error: EOF
11:12:02 <geekosaur> bleh
11:14:52 <litb> hello all
11:15:01 <litb> is there a channel about functional programming / system F ?
11:17:27 <quchen> litb: I think the right people might be around in this channel, but it might be borderline OT. Maybe ask in #haskell-blah.
11:18:33 <cariveri> how to resolve: Ambiguous module name `Control.Monad.State': it was found in multiple packages: monads-tf-0.1.0.1 mtl-2.1.2
11:18:36 <cariveri> ?
11:19:37 <litb> quchen, thanks. what are the possible values of "blah" ?
11:19:41 <Clint> cariveri: use PackageImports or hide monads-tf
11:21:09 <quchen> In GHCi you can use  :set -hide-package monads-tf
11:21:22 <litb> i remember something like ##haskell-coffee, but that seems empty :)
11:21:27 <quchen> litb: blah is a word, it doesn't have values.
11:22:03 <litb> lulz
11:22:34 <litb> ohh it's a channel itself! haha
11:23:10 <litb> does haskell have universal types?
11:23:27 <prophile> what do you mean by universal types?
11:23:40 <prophile> a type containing every value?
11:23:46 <quchen> Universally quantified, probably.
11:23:58 <cariveri> Clint: howe would I package import it?
11:23:59 <prophile> I'd imagine you'd need existentially quantified, no?
11:24:05 <prophile> data Universal = forall a. Universal a
11:24:15 <prophile> as opposed to data Universal = Universal (forall a. a)
11:24:17 <litb> we are doing universtal types in our university class
11:24:27 <prophile> (note that both are pretty useless)
11:24:43 <Clint> cariveri: import "mtl" Control.Monad.State (evalState, ...)
11:24:49 <pordan30> you can universally quantify in types and data fields in haskell
11:24:53 <quchen> One is bottom, the other one is something else.
11:24:59 <quchen> Of Universal ^
11:25:10 <litb> as in   \X. \a:X. a   for an identity function with universal type "forall X. X->X"
11:25:26 <milfjord> \a -> a
11:25:31 <prophile> litb: ah, that kind of universal type - yes, it does
11:25:32 <milfjord> type is implicit
11:25:40 <quchen> In Haskell, all types are universally quantified as far as I know.
11:25:47 <prophile> you can make it explicit via the RankNTypes extension
11:25:53 <milfjord> all type variables, I mean
11:26:02 <litb> so that you can do       id = \X. \a:X. a     and later say   id[Num] 10    or  id[String] "haha"
11:26:16 <milfjord> > let id = \a -> a in (id 10, id "haha")
11:26:17 <lambdabot>  (10,"haha")
11:26:25 <litb> oh
11:26:54 <litb> so the type of "a" is   "forall X", and it has type inference
11:26:54 <nolrai66> Huh, I thought let bound variables were monomorphic?
11:27:06 <litb> or is this just let polymorphism
11:27:19 <prophile> at a guess, lambdabot has -XNoMonomorphismRestriction
11:27:22 <milfjord> :t \a -> a
11:27:23 <lambdabot> t -> t
11:27:31 <litb> ah
11:27:50 <quchen> > let f = id in (f 10, f "haha")
11:27:51 <lambdabot>  (10,"haha")
11:27:56 <quchen> Interesting.
11:28:02 <c_wraith> nolrai66: I think MonoLocalBinds is turned on by some specific extensions
11:28:08 <litb> anyway, my real problem. If I have   \X. \x:X. plus x 1
11:28:12 <milfjord> I don't think the MR affects this
11:28:16 <litb> and plus is a function  Num -> Num
11:28:23 <cariveri> ok thanks. but I had to turn -XPackageImports on. which is rather annoying.
11:28:27 <litb> then that definition doesn't type check right?
11:28:31 <quchen> Right.
11:28:32 <litb> because plus would need to be    X -> X
11:28:35 <milfjord> litb: not as far as I can see
11:28:56 <milfjord> > (\x -> x + 1) :: t -> t
11:28:57 <nolrai66> :t \ n -> n + 1
11:28:57 <lambdabot> Num a => a -> a
11:28:58 <lambdabot>  No instance for (GHC.Num.Num t1) arising from a use of `GHC.Num.+'
11:28:58 <lambdabot>  Possible fix:
11:28:58 <lambdabot>    add (GHC.Num.Num t1) to the context of
11:28:58 <lambdabot>      an expression type signature: t1 -> t1
11:28:59 <lambdabot>      or the inferred type of it :: t -> t
11:29:03 <milfjord> oops
11:29:04 <litb> i mean it has type   Num -> Num -> Num
11:29:33 <litb> but, it would need to be   X -> Num -> Num
11:29:37 <nolrai66> Sorry milfjord.
11:30:07 <litb> but then that renders the universal types useless because you can't use normal non-universal typed functions in it with the universal typed parameters
11:30:44 <milfjord> u wot m8
11:31:32 <pordan30> right, \X. \x:X. plus x1 in the context plus: Num -> Num -> Num won't type check. how does this make universal types useless? you can write large numbers of generic functions with them.
11:32:25 <kr4t0s> Hi,
11:32:26 <nolrai66> Well..variations of const and id..but that is useful.
11:32:29 <litb> every function would want to use inside it would need to be universally typed too. so you would need to say   plus[X]x1  for example.
11:32:36 <quchen> map = Λa. Λb. λf:a→b. λxs:[a]. (...)
11:32:37 <kr4t0s> I just stumbled upon some pretty crazy behavior of haskell
11:32:43 <quchen> Seems like a useful function
11:32:45 <kr4t0s> have a look at this line:
11:32:55 <kr4t0s> let xx = Map.delete id xx
11:33:07 <milfjord> :t M.delete
11:33:08 <kr4t0s> this is accepted by GHC even though xx is only defined in this line
11:33:08 <lambdabot> Ord k => k -> M.Map k a -> M.Map k a
11:33:20 <kr4t0s> what does this mean?
11:33:27 <milfjord> kr4t0s: it's a recursive definition
11:33:27 <Iceland_jack> kr4t0s: Recursive binding
11:33:38 <kr4t0s> Shouldn't this be a bug?
11:33:41 <Iceland_jack> no
11:33:46 <quchen> I don't understand why this is well-typed. id is not Ord, after all.
11:33:48 <litb> quchen, ah i see
11:33:48 <kr4t0s> (i.e. in what situation would you want this to be correct?)
11:33:55 <milfjord> quchen: probably shadowed by another id
11:34:00 <Iceland_jack> > let x = 1:x in x
11:34:01 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
11:34:12 <milfjord> > let xs = 0 : map (+ 1) x in x
11:34:13 <lambdabot>  Couldn't match expected type `[a0]'
11:34:13 <lambdabot>              with actual type `Debug.SimpleReflect.Expr.Expr'
11:34:13 <quchen> kr4t0s: Haskell's let = letrec, if that helps.
11:34:17 <milfjord> > let x = 0 : map (+ 1) x in x
11:34:18 <lambdabot>  [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,2...
11:34:41 <kr4t0s> ok
11:34:48 <milfjord> > let x = \n -> if n < 2 then 1 else n * x (n - 1) in x 5
11:34:49 <kr4t0s> doesn't seem to make much sense in case of maps, though
11:34:50 <lambdabot>  120
11:34:54 <milfjord> true
11:35:07 <nolrai66> :t xx = Map.delete id xx
11:35:07 <lambdabot> parse error on input `='
11:35:18 <nolrai66> :t let xx = Map.delete id xx in xx
11:35:19 <lambdabot> Couldn't find qualified module.
11:35:41 <nolrai66> :t Map.delete
11:35:42 <lambdabot> Couldn't find qualified module.
11:35:43 <quchen> :t let xx = M.delete id xx in xx
11:35:44 <lambdabot> Ord (a1 -> a1) => M.Map (a1 -> a1) a
11:36:05 <Iceland_jack> :t let xx = M.delete "Sally" xx in xx
11:36:06 <lambdabot> M.Map [Char] a
11:36:19 <milfjord> > let xx = M.delete "Sally" xx in xx
11:36:22 <Iceland_jack> Like someone said, 'id' is probably shadowed
11:36:23 <lambdabot>  mueval-core: Time limit exceeded
11:36:33 <Iceland_jack> this is most likely done by accident
11:36:35 <nolrai66> Nope.
11:36:40 <kr4t0s> id is not shadowed in my code, as far as I can see
11:37:01 <milfjord> kr4t0s: I'm not sure I believe you
11:37:01 <nolrai66> No its not.
11:37:08 <milfjord> nolrai66: how do you know?
11:37:30 <nolrai66> Well it could be..but its not here. Lambdabot is reporting the correct type.
11:37:32 <quchen> Works in GHCi, indeed.
11:37:52 <milfjord> nolrai66: what are you even talking about?
11:38:16 <nolrai66> :t let xx = M.delete id xx in xx
11:38:17 <lambdabot> Ord (a1 -> a1) => M.Map (a1 -> a1) a
11:38:23 <nolrai66> Type checks right here.
11:38:31 <milfjord> ... so?
11:38:41 <Iceland_jack> nolrai66: Yes and how useful is that key type?
11:38:58 <nolrai66> Not very, but how is Haskell supposed to know that?
11:39:41 <Iceland_jack> Nobody is claiming that it can't be type checked
11:39:49 <quchen> I don't get it either. Why is there no "no instance Ord (a -> a)" error?
11:40:11 <milfjord> > let xx = M.delete id xx in ()
11:40:12 <lambdabot>  ()
11:40:25 <Dementhor> Hi. I have a question regarding Haskell  type system. So I have a data declaration as follows: data State a = State a deriving (Show, Read) and the problem is when i want to read a state from GHCi. The problem is that I have to specify the type of a, and I don't want to (to be as general as possible). So (read "State 2") gives me a error and (read "State 2") :: State Int doesn't. Is there a way around it?
11:40:30 <milfjord> > id > id
11:40:31 <lambdabot>  No instance for (GHC.Classes.Ord (a0 -> a0))
11:40:31 <lambdabot>    arising from a use of `GHC.Classes.>'
11:40:31 <lambdabot>  Possible fix:
11:40:31 <lambdabot>    add an instance declaration for (GHC.Classes.Ord (a0 -> a0))
11:40:37 <milfjord> interesting
11:40:52 <milfjord> I blame excessive defaulting
11:40:56 <nolrai66> > let xx = M.delete id xx in xx M.empty
11:40:58 <lambdabot>  Couldn't match expected type `Data.Map.Base.Map k0 a2 -> t0'
11:40:58 <lambdabot>              with actual type `Data.Map.Base.Map (a1 -> a1) a0'
11:41:23 <nolrai66> Hmm. Thats not the error that I would expect..
11:41:24 <Iceland_jack> Dementhor: You have to specify something, the most general thing would be
11:41:24 <Iceland_jack>     read "State 2" :: Read a => State a
11:41:51 <quchen> Dementhor: You'll have to specify the exact type of "a", otherwise GHC can't know which `read` function to use.
11:41:59 <haasn> quchen: the monomorphism restriction doesn't hold for bindings inside “let <bindings> in ...” afaik
11:42:14 <quchen> haasn: The DMR again? NoooOOO
11:42:26 <haasn> quchen: this was due to your confusion earlier about let f = id in (f 10, f "hello") working
11:42:37 <prophile> haasn: surely that form applies to all bindings in ghci, no? And ghci certainly suffers from monomorphism restriction pain
11:42:38 <haasn> or perhaps not confusion
11:43:00 <jle`> today is day 1 of my arrowized machine-based pipes/conduit replacement
11:43:12 <prophile> jle`: hooray
11:43:19 <haasn> prophile: bindings in GHC are “let <bindings>”, without the “in ...” bit. Come to think of it, I'm not sure if the DMR applies to those types of bindings inside do-notation
11:43:28 <jle`> hopefully i can contribute to the world :)
11:43:31 <jle`> prophile: thanks :D
11:44:00 <nolrai66> Hmm. Pipes cant be arrowized because its bidirectional.
11:44:38 <prophile> nolrai66: the types going backwards are not the same as the types going forwards
11:44:41 <prophile> if that makes sense
11:44:50 <jle`> nolrai66: this is a ground-up replacement for something filling a similar role
11:44:52 <prophile> I'm pretty sure pipes can be arrowised, but aren't because that means choosing one category instance
11:44:58 <prophile> when there are five possible categories
11:45:11 <nolrai66> No, the types don't work, because it works on pairs of types.
11:45:30 <prophile> oh, I see what you mean
11:45:47 <jle`> either way pipes idioms encourage pipe transformers and applicative interfaces
11:45:54 <jle`> instead of arrow idioms
11:46:07 <nolrai66> Ah..deeper then I understand.
11:46:24 <jle`> a lot of Pipe -> Pipe functions
11:46:26 <sm> g'day all, is it possible to turn on profiling with runghc, so I can use +RTS -xc when running interpreted ?
11:46:41 <pjdelport> Is there a reasonable way to calculate a large logarithm without using a heavy external library?
11:47:48 <nolrai66> Hey anyone here understand using DataKinds/type level hackery? I was trying to see if I could use that to implement values with physical dimension easier then the existing packages..but I think it doesn't actually help. Am I right?
11:48:24 <quchen> pjdelport: Logarithm of what?
11:48:44 <quchen> For a fast logarithm of an Integer, consider sizeof. :-)
11:49:05 <yatharth01> can anyone help me? I'm unable to install yesod on my debian!! :(
11:49:11 <haasn> prophile: you could probably make it work by adding a newtype for Pipe a b ()
11:49:15 <joelteon> yatharth01: #yesod
11:49:17 <Iceland_jack> nolrai66: Can you give an example of what you have in mind?
11:49:17 <Iceland_jack>  
11:49:17 <haasn> with arr :: (a -> b) -> Pipe a b ()
11:49:21 <pjdelport> quchen: heh, that will actually suffice
11:49:36 <prophile> haasn: I think you're probably right but that doesn't extend to the full generality of pipes
11:49:37 <jle`> haasn: you might have to do some rearrangement
11:49:41 <jle`> for unification purposes
11:49:45 <quchen> pjdelport: It's beyond hacky though, but good enough for a ballpark log
11:49:45 <prophile> as nolrai66 pointed out
11:49:52 <bennofs> :t sizeof
11:49:52 <lambdabot>     Not in scope: `sizeof'
11:49:53 <lambdabot>     Perhaps you meant one of these:
11:49:53 <lambdabot>       `IM.size' (imported from Data.IntMap),
11:50:24 <quchen> I don't know a sizeof function in (GHC-) Haskell, but you could also right-shift the integer until it's 0 or something along those lines.
11:50:36 <quchen> What I meant to say was "look for the most significant 1s"
11:50:52 <haasn> jle`: oops, I forgot the ‘m’; but apart from that they unify under (>->)
11:50:55 <haasn> (>->) :: Monad m => Pipe   a b m r -> Pipe     b c m r -> Pipe     a c m r
11:50:59 <geekosaur> sm, I think you'd need a ghc that was built with profiling
11:51:11 <yatharth01> joelteon: thnks a lot :)
11:51:22 <sm> geekosaur: rats, thanks
11:51:28 <jle`> :t arr
11:51:29 <lambdabot> Arrow a => (b -> c) -> a b c
11:51:33 <haasn> Pipe is downwards only, it has () flowing upwards from both sides
11:51:47 <jle`> your a and b have to appear at the end of the type
11:51:52 <haasn> jle`: hence newtype
11:52:09 <jle`> ah
11:52:12 <geekosaur> ignoring the option parsing fun in the runghc shell script, runghc amounts to a special invocation of ghc in the same way that ghci turns into ghc --interactive
11:52:27 <haasn> newtype APipe m a b = APipe { runAPipe :: Pipe a b m () } -- ish
11:52:33 <jle`> i see
11:52:37 <prophile> there are fast count-leading-zero algorithms
11:52:39 <pjdelport> quchen: I was just a bit disappointed that Haskell can do logBase 2 $ fact (52*2), but not logBase 2 $ fact (52*4)
11:53:16 <pjdelport> Python's math.log doesn't top out with the latter
11:53:17 <bergey> nolrai66: Have you seen http://hackage.haskell.org/package/units ?
11:54:33 <pjdelport> (I'm playing around with factoradic number encodings)
11:54:39 <nolrai66> *bergey* ..some how I had forgot that existed.
11:54:43 <nolrai66> Thanks!
11:55:26 <geekosaur> sm: also note that profiling is not so useful with runghc anyway since it's using the unoptimized bytecode backend
11:55:37 <haasn> pjdelport: http://hackage.haskell.org/package/arithmoi-0.4.0.3/docs/Math-NumberTheory-Logarithms.html#v:integerLogBase
11:55:40 <geekosaur> so right off the top you can say "crappy and wasteful"
11:55:49 <haasn> pjdelport: you probably want this instead of going through Double, if you're fine with an integer result
11:55:58 <haasn> that way you work with Integer which doesn't max out at Infinity either
11:56:49 <sm> geekosaur: gotcha, just trying to figure out where this printf don't use (IO a) error is coming from
11:56:55 <bergey> nolrai66: That's one approach, with an open family of units.  With a closed set of units (ie SI), I'd expect you can use type-level numbers.  Is that what you were trying?
11:57:29 <pjdelport> haasn: Thanks; this is just for back-of-the-napkin calculation, though, so I can get away with just using Python.
11:57:34 <Iceland_jack> nolrai66: You'll probably find GHC.TypeLits useful for that
11:58:04 <nolrai66> bergey: Yes..but I couldn't figure out how to define a operation on typelevel Integers.
11:58:11 <nolrai66> (The literals are Nats.)
11:58:22 <Iceland_jack> nolrai66: You can use a type family
11:58:40 <Iceland_jack>     type family IsZero (n :: Nat) :: Bool where
11:58:40 <Iceland_jack>         IsZero 0 = True
11:58:41 <Iceland_jack>         IsZero n = False
11:59:02 <nolrai66> Hmm. Okay.
11:59:44 <nolrai66> Too bad DataKinds lifts tipes but not functions..but that would be kind of crazy.
11:59:59 <Iceland_jack> You can lift some functions using Template Haskell
12:00:17 <Iceland_jack> using the singletons library for example
12:00:20 <bergey> nolrai66: Doesn't GHC.TypeLits provide some of that?
12:00:52 <nolrai66> It lets you lower Type Values i.e. singletons.
12:01:15 <nolrai66> but...I don't think that lets you go the other direction very well.
12:01:18 <c_wraith> lifting arbitrary functions is more or less dependent typing.
12:01:21 <nolrai66> I could be confused.
12:01:55 <nolrai66> c_wraith: yeah. Well with clearer distinction between compile and runtime.
12:01:56 <Iceland_jack> nolrai66: What do you mean “lower type values”?
12:02:34 <c_wraith> Iceland_jack: converting types to values is easier than converting values to types...  Mostly because types are known at compile time, and values are not.
12:03:30 <Iceland_jack> But you're not actually ‘lowering’ them
12:03:44 <c_wraith> Not really, no.
12:03:51 <nolrai66> Iceland_jack: the example in the docs is defining a array with type level size, TypeLits module lets you extract that size, say to do bounds checking.
12:04:11 <nolrai66> I was just using the closest word I could think of.
12:04:28 <Iceland_jack> nolrai66: Yes, that's /the/ example of more expressive type systems :)
12:04:31 <Iceland_jack> vectors that is
12:05:27 <nolrai66> Well in haskell terminology vectors seem to be type-bound _lists_, but I am being pedantic.
12:05:39 <c_wraith> Hmm.  There's supposed to be more work going on in the Nat solver for GHC 7.10.  Will it be strong enough to compile an Eq instance for the pedagogical Vec type?
12:05:49 <sm> cabal install -p alreadyinstalledpkg does nothing, eh ?
12:06:02 <c_wraith> In 7.8, you need unsafeCoerce to write an Eq instance
12:06:10 <sm> ie, it doesn't reinstall if the non-profiled package is already installed ?
12:06:16 <quchen> pjdelport: log(n!) ≈ n*log(n)-n
12:06:49 <pjdelport> Oh, right.
12:07:00 <quchen> Haskell can do that one reasonably well.
12:07:32 <Iceland_jack> nolrai66: I'm not sure if you're being pedantic, Vector is what they're called in the literature, or type-indexed lists/vectors etc.
12:08:06 <nolrai66> Right where my example was a type-bound _array_.
12:08:15 <nolrai66> err..the docs example that is.
12:09:19 <kadoban> @pl \x -> length . filter id . zipWith (/=) x
12:09:19 <lambdabot> ((length . filter id) .) . zipWith (/=)
12:09:40 <nolrai66> Wow a pl result thats not horrid.
12:09:47 <Iceland_jack> I don't know what youre example is but encoding the length of something on the type level is basically is the example normally used
12:09:47 <quchen> That's not horrid?
12:09:52 <Earnestly> ^
12:09:53 <kadoban> it's kinda horrid, haha
12:10:07 <kadoban> i knew it would be, but was still curious
12:10:11 <Iceland_jack> It only has 2 levels of grouping parentheses, that's good!
12:10:48 <quchen> @pl \a b c -> [a,b,c]
12:10:48 <lambdabot> (. ((. return) . (:))) . (.) . (:)
12:11:14 <Iceland_jack> @pl \a b c -> [b,c,b,a]
12:11:14 <lambdabot> liftM2 (.) (:) . (flip (:) .) . flip (:) . return
12:11:37 <nolrai66> ...whats doubling the b?
12:11:44 <quchen> liftM2
12:11:45 <nolrai66> I don't see join in there.
12:11:58 <Iceland_jack> liftM2 for ((→) r)
12:11:59 <nolrai66> :t liftM2 (.)
12:12:00 <lambdabot> Monad m => m (b -> c) -> m (a -> b) -> m (a -> c)
12:12:49 <nolrai66> :t liftM2 (.) (:)
12:12:49 <lambdabot> (a1 -> a -> [a1]) -> a1 -> a -> [a1]
12:12:55 <Iceland_jack> :t liftM2 (.) :: (r -> b -> c) -> (r -> a -> b) -> (r -> a -> c)
12:12:56 <lambdabot> (r -> b -> c) -> (r -> a -> b) -> r -> a -> c
12:13:15 <nolrai66> Okay.
12:14:35 <czro_> Hello. I'm have some wonderings about thread safety and parallelism. the State monad is thread safe as long as it's not used in a context with IO (StateT over IO for example)?
12:15:13 <Iceland_jack> czro_: Do you know how State is implemented?
12:15:54 <nolrai66> Hmm, which LANGUAGE flag turns on type literals?
12:16:09 <Iceland_jack> you can use them by importing GHC.TypeLits
12:16:25 <Iceland_jack> but you have to import some other related flags
12:16:27 <czro_> Iceland_jack: Not exactly, but it passes around a implicit state context which in my case is a record. I think it uses CPS internally??
12:17:54 <Iceland_jack>     ghci> :set -XDataKinds
12:17:55 <Iceland_jack>     ghci> import GHC.TypeLits
12:17:55 <Iceland_jack>     ghci> :kind 0
12:17:55 <Iceland_jack>     0 :: Nat
12:19:56 * hackagebot Hclip 1.0.0.2 - A small cross-platform library for reading and modifying the system clipboard.  http://hackage.haskell.org/package/Hclip-1.0.0.2 (JensThomas)
12:20:15 <Iceland_jack> czro_: When using the state monad it's effectily the same as using let's and lambdas to pass the state around, so when you use 'StateT IO' it's no less threadsafe than doing the same IO actions without StateT
12:20:42 <quchen> czro_: Spoiler, http://lpaste.net/100735
12:21:03 <Iceland_jack> quchen: Huh, the Zebra did it
12:21:29 <quchen> ..?
12:22:13 <Iceland_jack> (the murderer is always revealed at the end of the book :) in this case a dictionary)
12:22:37 <czro_> Iceland_jack: I realize that now. I have been fighting with a pile of old c++ code absolutely full of race conditions and it seemed too good to be true :)
12:23:47 <czro_> Iceland_jack: Another question on the same subject. Do you know if mwc-random is thread safe?
12:24:04 <milfjord> did you mean: Zygohistoprepromorphism
12:24:12 <Iceland_jack> milfjord: ;)
12:24:13 <kadoban> Iceland_jack: twist ending, zebra was framed, zyzzyva did it
12:24:37 <Iceland_jack> czro_: If you don't modify any external state, using StateT shouldn't make that thread-unsafe
12:26:04 <Iceland_jack> czro_: I don't know, but this seems relevant http://stackoverflow.com/questions/16248600/parallel-computations-with-fast-randomness-and-purity
12:39:15 <czro_> Iceland_jack: That is exactly what I was looking for. Thanks.
12:50:00 * hackagebot rainbow 0.8.0.0 - Print text to terminal with colors and effects  http://hackage.haskell.org/package/rainbow-0.8.0.0 (OmariNorman)
12:50:02 * hackagebot http-test 0.1.3 - Test framework for HTTP APIs  http://hackage.haskell.org/package/http-test-0.1.3 (glutamate)
12:59:36 <knz> hoi
13:00:11 <knz> so I checked vacuum and ghc-vis; the latter has greatly helped me with visualizing data structures. Is there any tool able to decompile a function node?
13:02:08 <ion> reinh: The enclosure links in http://www.haskellcast.com/feed.xml (such as <http://feeds.soundcloud.com/stream/137515344-haskellcast-the-haskell-cast-6-gabriel.mp3>) give error 500. I wonder if that’s just temporary?
13:26:55 <chrisdotcode> > liftM2 (,) (Just 2) (Just 4)
13:26:56 <lambdabot>  Just (2,4)
13:35:05 * hackagebot cabal-bounds 0.2 - A command line program for managing the bounds/versions of the dependencies in a cabal file.  http://hackage.haskell.org/package/cabal-bounds-0.2 (DanielTrstenjak)
13:39:51 <tomejaguar> Why does Data.Text use UTF-16 rather than UTF-8?
13:40:08 <Iceland_jack> For the internal representation?
13:40:15 <shachaf> There was a Google Summer of Code project to port it to UTF-8.
13:40:45 <tdammers> I wonder whether utf-8 would actually be better
13:40:48 <shachaf> By jaspervdj with edwardk as the mentor, maybe?
13:41:04 <shachaf> I think the biggest reason in the end was ICU bindings.
13:41:19 <shachaf> There may have been worse performance for UTF-8 but I don't remember.
13:41:25 <Iceland_jack> they cite using UTF-16 over UTF-8 due to "much lower overhead"
13:41:27 <tomejaguar> Iceland_jack: Yes for internal representation.  The Wikipedia page for UTF-8 suggests UTF-8 is better for all purposes except size of asian text, compared to UTF-16.
13:41:32 <Iceland_jack> http://www.cs.ox.ac.uk/files/4455/paper.pdf
13:41:57 <geekosaur> the gsoc project completed and found that utf8 was actually a little faster for common use cases, but was never merged
13:42:25 <tomejaguar> Iceland_jack: Thanks.  I wonder what they mean by overhead.
13:42:56 <Iceland_jack> tomejaguar: “The price for UTF-8's compactness is increased overhead in decoding.”
13:43:43 <jle`> set out to make a library only to realize that edwardk might have done it first and better
13:43:46 <jle`> :'(
13:43:48 <Iceland_jack> “Outside of traditional ASCII characters [...], it is necessary to reconstruct points from two or more bytes for many commonly used characters.”
13:44:16 <Iceland_jack> tomejaguar: Does that answer your question?
13:44:16 <milfjord> just like UTF-16, then
13:45:06 * hackagebot ViennaRNA-bindings 0.1.2.2 - ViennaRNA v2 bindings  http://hackage.haskell.org/package/ViennaRNA-bindings-0.1.2.2 (ChristianHoener)
13:45:08 * hackagebot BiobaseXNA 0.8.2.0 - Efficient RNA/DNA representations  http://hackage.haskell.org/package/BiobaseXNA-0.8.2.0 (ChristianHoener)
13:45:17 <Iceland_jack> milfjord: Yes but it's close to being fixed, very few points exceed the BMP
13:45:23 <milfjord> uh
13:45:35 <milfjord> you still need two bytes to represent a code point in UTF-16
13:45:41 <Iceland_jack> Yes
13:45:43 <Iceland_jack> or more
13:45:48 <milfjord> "for many commonly used characters", including ASCII!
13:47:23 <tdammers> jle`: whenever you need to solve a problem in Haskell, checking whether edwardk has already solved it is a viable strategy
13:47:43 <milfjord> this is why haskell is often called "lazy"
13:47:44 <tdammers> also: http://cokmett.github.io/cokmett/
13:47:45 <Iceland_jack> The indexing is for the 16-bit subset of UTF-16 is fixed length and this is most characters
13:47:55 <quchen> milfjord: It's called `const True`
13:48:15 <Iceland_jack> makes indexing faster and calculating string lengths
13:48:36 <milfjord> fortunately indexing is useless so you won't need it often
13:49:27 <jle`> tdammers: saw this before but did not realize that there is a different string of code streaming out of his mouth every time you clikc it haha
13:50:23 <jle`> i wonder if it's procedurally generated
13:51:24 <Iceland_jack> milfjord: I'm just saying how things are :) in UTF-8 you also need to keep track of the length of the current point being decoded
13:51:43 <milfjord> that's actually easier than in UTF-16, no?
13:52:04 <milfjord> the first byte of a utf-8 sequence tells you how long it is
13:52:05 <edwardk> jle`: what library did you reinvent?
13:52:21 <jle`> edwardk: it's not quite a reinvention but possible overlap of interface
13:52:48 <jle`> edwardk: i'm trying to write a machines-based pipes/conduit thing with strong arrow idioms/interface
13:52:56 <jle`> but you already have machines
13:53:03 <edwardk> jle`: it appears to be a random tree. one problem is they don't seem to check that the tree is finite
13:53:06 <jle`> i think it's slightly different than what i am trying to do then
13:53:17 <Iceland_jack> No because you need to keep track of where you are in the current encoding for basically security reasons
13:53:18 <jl> Hi, I'm trying to define lists as folding functions (a common encoding in lambda calculus) and I have a hard time making it typecheck. Can I get some help please ?
13:53:33 <jle`> jl: just ask :)
13:53:35 <Iceland_jack> also branch prediction favours UTF-16
13:54:01 <edwardk> jl: you can throw longer code snippets on lpaste.net
13:54:08 <jl> http://lpaste.net/100737
13:54:12 <jl> thank you !
13:54:56 <milfjord> :t let nil = \f z -> z; cons x xs = \f z -> f x (xs f z) in (nil, cons)
13:54:57 <lambdabot> (t -> t1 -> t1, t3 -> ((t3 -> t4 -> t2) -> t5 -> t4) -> (t3 -> t4 -> t2) -> t5 -> t2)
13:55:07 * hackagebot aeson 0.7.0.2 - Fast JSON parsing and encoding  http://hackage.haskell.org/package/aeson-0.7.0.2 (BryanOSullivan)
13:55:35 <edwardk> jl: with the newtype noise it may be noisier but it'd be easier to get the rank-2 types to do the right thing
13:55:59 <tomejaguar> Iceland_jack: I understand the point, but it disagrees with Wikipedia on this issue, which claims UTF-8 is generally faster.
13:56:21 <jl> edwardk : I'm trying
13:57:45 <edwardk> jl: My http://hackage.haskell.org/package/folds-0.3/docs/src/Data-Fold-R.html#R is basically the type you have here plus an extra function to apply at the end.
13:57:59 <Iceland_jack> tomejaguar: I'm not saying that decoding UTF-16 is faster than decoding UTF-8 since I haven't seen the numbers, I'm just thinking of possible reasons :)
13:58:09 <edwardk> there i have     data R a b = forall r. R (r -> b) (a -> r -> r) r
13:58:12 <magneticduck> uhm, I think I need a little bit of help setting up ghc-mod and syntastic and all that gang in vim
13:58:23 <tomejaguar> Iceland_jack: Now I look at Wikipedia again I can't see that claim anyway.
13:58:27 <edwardk> note that i'm using an existential 'r' for the recursion, and converting it to b in the en
13:58:36 <magneticduck> I'm using syntastic, got that all set up
13:58:39 <Iceland_jack> One thing they say in the paper
13:58:40 <Iceland_jack>     Those code points that are stored in only one 16-bit word
13:58:40 <Iceland_jack>     are stored as raw values; no arithmetic is required to
13:58:40 <Iceland_jack>     decode them.
13:58:47 <edwardk> that lets me set up more instances for common classes, fuse folds, etc.
13:58:52 <magneticduck> syntastic seems to be set up to use "ghc-mod, hlint"
13:59:02 <magneticduck> err, ghc_mod and hlint
13:59:06 <magneticduck> it's working fine there
13:59:20 <magneticduck> the ghc-mod plugin is also working fine in vim
13:59:32 <edwardk> jl: that might be a bit deep down the rabbit hole, but it shows the approach working ;)
13:59:43 <magneticduck> however, the errors I'm getting from syntastic are ugly, I wish it could use the error messages GhcModCheck gives me
13:59:58 <magneticduck> any ideas what to do?
14:00:22 <jle`> magneticduck: can you show an example of a syntastic error vs a ghcmodcheck error
14:00:37 <brill> Anyone know a way to get a parsec parser to include the delimiter (or separator) in the result?
14:01:08 <magneticduck> sure
14:01:30 <jle`> brill: just parse the delimiter?  is there a specific combinator you are using?
14:01:45 <edwardk> jl: http://lpaste.net/100737 fixes your problem.
14:01:47 <magneticduck> http://ix.io/aXl
14:01:49 <magneticduck> jle`:
14:02:03 <Peaker> edwardk: hey, can trifecta/parsers handle textual "include" files that can change the grammar (i.e: cannot be done in a 2nd phase)?
14:02:24 <magneticduck> jle`: on, and it does very nice indentation on more complex errors
14:02:25 <Peaker> edwardk: (Parsec allows it by using ParsecT and control over the parser state)
14:02:38 <magneticduck> it seems like ghc-mod is meant to work alone, seperate from syntastic'
14:02:51 <magneticduck> but syntastic is nice to see the error positions in the code
14:02:52 <brill> jle`: I'm doing this part = many $ noneOf ['-','\n']
14:02:54 <magneticduck> :/
14:03:13 <jle`> magneticduck: syntastic only shows up as one line on the status line right?
14:03:16 <brill> And needs the '-' to be included.
14:03:17 <jle`> or have i been doing it wrong this whole time
14:03:25 <brill> So noneOf won't work...
14:03:32 <magneticduck> jle`: yes
14:03:34 <edwardk> Peaker: nothing keeps you from writing a new parser module that just uses some of the parts of trifecta, but the stock trifecta parser doesn't try to handle that usecase. it'd destroy the remaining performance of the main parser
14:03:36 <Iceland_jack> tomejaguar: They don't go into detail on the decoding in the paper but I suspect the type of text being decoded has a significant influence: if you're only parsing ASCII then decoding it in UTF-8 doesn't require arithmetic
14:03:45 <Iceland_jack> *impact
14:03:45 <jle`> brill: what are you trying to do? in words
14:03:46 <magneticduck> jle`: oh no, it's from the pane made when I type ":Error"
14:03:48 <magneticduck> jle`: oh no, it's from the pane made when I type ":Errors" *
14:03:55 <jle`> magneticduck: what the
14:03:58 <jle`> this whole time?
14:03:59 <jle`> i have to try this
14:04:04 <magneticduck> xD
14:04:06 <jl> edwardk : thanks a lot. What does it work now ? Is the eta expansion for something like avoiding the monomorphism restriction ?
14:04:08 <jle`> oh my gosh
14:04:10 <magneticduck> lol
14:04:10 <Peaker> edwardk: ah, ok
14:04:20 <magneticduck> but it's still horrible compared to GhcModCheck's output
14:04:40 <jle`> hm
14:04:47 <jle`> yeah i have been living with this the whole time
14:05:00 <brill> I'm doing parsing of hyphens. And need to break "acc-ede" into ["acc-","-ede"]
14:05:02 <magneticduck> jle`: well, essentially all I need to do is get GhcModCheck to update every time I reload the file
14:05:09 <jle`> but does syntastic even support multi-line error messages?
14:05:18 <magneticduck> yeah, I'm not even sure
14:05:20 <jle`> brill: you don't want noneOf
14:05:28 <magneticduck> it doesn't matter, I think I'll just stick with this, come to think of it
14:05:38 <edwardk> jl: pretty sure what was happening was when you had 'cons e l' it was picking that 'l' was a function for some concrete 'b' too early. now t happens at the 'runFoldList' site, not at the pattern match on l.
14:05:39 <brill> jle`: Nope. Got any idea what to use?
14:05:40 <jle`> isn't there some split combinator?
14:05:47 <magneticduck> syntastic for simple error messages and position in the code, GhcModCheck for long error messages
14:06:07 <jle`> oh what the i never noticed i had ghcmodcheck
14:06:10 <jle`> well
14:06:19 <jle`> i mostly only use syntastic to get the markers on the left margin
14:06:22 <magneticduck> yeah
14:06:27 <magneticduck> alright thanks for the help I gtg
14:06:33 <edwardk> jl: you could reduce the rank on your definitions literally by just removing he type signatures and get definition that would work
14:07:16 <jl> edwardk : what do you mean by "reducing the rank"" ?
14:08:22 <edwardk> jl: in lens i avoid taking higher rank arguments explicitly. just writing    cons e l = \f x -> f e (l f x)    sans type signature gives you a viable definition for cons
14:08:34 <edwardk> when passed a FoldList and a value it'll give you a FoldLiist
14:08:44 <jle`> brill: you can use sepBy and family, and maybe add i the hyphens manually.  or you can look at the source of sepBy and write your own
14:08:45 <edwardk> but it'll also accept args that aren't 'proper' foldlists
14:09:03 <edwardk> it infers a scarier type: cons
14:09:04 <edwardk>   :: t1
14:09:04 <jle`> you can get chainl to do what you want i am sure as well, it's pretty general
14:09:06 <edwardk>      -> ((t1 -> t2 -> t) -> t3 -> t2) -> (t1 -> t2 -> t) -> t3 -> t
14:09:22 <litb> hmm, as I see it, the "fix point combinator" doesn't really have to do with fix points, does it?
14:09:33 <litb> a fix point is an x, such that  x = f x
14:09:43 <edwardk> but it is logically cons :: a -> FoldListLike r a -> FoldListLike r a -- for all r.
14:10:00 <edwardk> your previous code required separate quantifiers for 'r', which meant you had to be careful about when 'r' was picked.
14:10:10 <edwardk> and you had to use a signature to cal t
14:10:28 <Iceland_jack> tomejaguar: If you're not totally bored by this yet, you can look at the dissertation which covers the choice in a bit more detail http://www.cs.ox.ac.uk/files/3929/dissertation.pdf
14:10:30 <litb> what's the relation between then?
14:10:39 <edwardk> but if you remove all the signatures from that file, you get code that is correct, and for which main = print . toList $ cons "H" nil    just works without the signature!
14:11:05 <Lethalman> so... let [a,b] = foo; somethingelse
14:11:20 <supki_> jle`: syntastic supports multiline error messages but you'd need to enable them manually IIRC
14:11:20 <Lethalman> the pattern is not matched until either a or b is forced
14:11:38 <supki_> jle`: i.e. you can ask it to populate quickfix window
14:12:00 <jl> edwardk++
14:12:14 <jl> Thanks a lot ! Good evening.
14:12:26 <edwardk> jl: np, have fun =)
14:20:10 * hackagebot snap-testing 0.3.0.0 - A library for BDD-style testing with the Snap Web Framework  http://hackage.haskell.org/package/snap-testing-0.3.0.0 (DanielPatterson)
14:34:20 <WraithM> What are the options for loggingin Haskell? I know of hslogger and monad-logger. Are those my options? Are there other packages that I'm not aware of?
14:35:12 <johnw> http://hackage.haskell.org/package/fast-logger
14:35:22 <johnw> which monad-logger is implemented on top of
14:35:28 <johnw> i like monad-logger
14:35:46 <quchen> WriterT (DList Text)?
14:36:07 <WraithM> johnw: Okay :) cool!
14:36:07 <johnw> but then you can't see the log until the program is over
14:36:09 <quchen> Or Text.Builder or what it's called
14:36:23 <johnw> WraithM: also, you *don't* need LoggingT in your transformer stack
14:36:32 <johnw> you just need an instance for MonadLogger in the stack
14:36:42 <johnw> so you could, very easily, make an instance of MonadLogger for IO, for example
14:36:50 <johnw> and then you have logging available everywhere that you have IO
14:37:49 <xexonixxexillion> can I define f g x = g x x in a pointsfree style without needing to import Control.Monad? (i.e with just the prelude)
14:38:01 <johnw> f g = join g
14:38:16 <johnw> aka, your f is join :)
14:38:30 <monochrom> I don't think Prelude has what you need
14:38:31 <litb> :t church 5
14:38:32 <lambdabot> Not in scope: `church'
14:38:33 <litb> hm
14:38:38 <xexonixxexillion> doesn't work; by default there is no monad instance on ((->) r)
14:38:52 <johnw> import Control.Monad.Instances?
14:38:52 <monochrom> hmm, maybe it does, but not going to be pretty
14:39:18 <johnw> yes, that's where that instance lives
14:39:34 <johnw> i believe it comes in by importing Control.Monad as well
14:39:43 <jle`> i wonder where that decision came from
14:39:48 <johnw> which?
14:39:53 <kakos> n/whois mokus
14:39:54 <kakos> Er, mistell. :)
14:39:59 <jle`> to not have monad instance in Prelude
14:40:01 <monochrom> g x x = uncurry g (x,x) = (uncurry g . (\x -> (x,x))) x
14:40:12 * hackagebot PrimitiveArray 0.5.4.0 - Efficient multidimensional arrays  http://hackage.haskell.org/package/PrimitiveArray-0.5.4.0 (ChristianHoener)
14:40:19 <monochrom> therefore, f g = uncurry g . (\x -> (x,x))
14:40:27 <johnw> ah, I see, he specifically said "just the prelude", sorry
14:40:44 <monochrom> can furthermore eliminate g but that's going to blow minds :)
14:40:57 <johnw> @pl \f g x = g x x
14:40:58 <lambdabot> (line 1, column 8):
14:40:58 <lambdabot> unexpected "="
14:40:58 <lambdabot> expecting pattern or "->"
14:41:02 <johnw> @pl \f g x -> g x x
14:41:02 <lambdabot> const join
14:41:05 <johnw> hrpmh
14:41:05 <Iceland_jack> and then
14:41:05 <Iceland_jack>     uncurry g . (join (,… no sorry :)
14:41:20 <cmccann> hm, ubuntu update-manager crashed with a TypeError, I am sure glad that "dynamic" languages don't need types b/c they have unit tests
14:42:08 <monochrom> cmccann: duplicity (written in python) had a trivial bug that could have been caught by trivial type checking, too
14:42:34 <Iceland_jack> cmccann: Preaching to the choir
14:42:58 <monochrom> it basically lurked in a seldom used execution path, namely, when I turned on --short-filenames. I guess duplicity's programmers seldom use --short-filenames themselves
14:43:07 <cmccann> monochrom: how shocking and unexpected
14:43:24 <Xeno-Genesis> Iceland_jack, LOL, I was just thinking that. Another Python bug fixed yesterday in Electrum would not have happened if it had type checking.
14:44:25 <monochrom> this is why I acidicly say that choosing non-static-type-check is equivalent to choosing fraud and scam.
14:44:43 <Iceland_jack> monochrom: It's not that black and white :)
14:44:53 <cmccann> *rimshot*
14:45:21 <Xeno-Genesis> monochrom, Interesting way to put it.
14:45:22 <monochrom> I know. I sometimes prefer the type system to not track array bounds. by doing that, I am also committing fraud and scam.
14:45:58 <monochrom> it is not that black and white. it is all black. even I am black. but I'm monochromatic anyway.
14:58:15 <Eduard_Munteanu> Hm, I wonder if parametrizing file paths by 4 type-level naturals is a sign things are off. :)
14:59:09 <kadoban> any haskellmode-vim users? having this issue where it keeps regenerating its haddock indexes every time i restart vim, would anyone have any idea how to get it not to do that? or general recommendations on vim integration maybe?
15:05:02 <ChongLi_> kadoban: I don't use haskellmode-vim
15:05:28 <ChongLi_> I use ghc-mod, neocomplete, unite.vim
15:05:44 <ChongLi_> and syntastic
15:06:20 <kadoban> ChongLi_: thanks! i'll check those out. haskellmode seems kind useful, but also pretty buggy, wondering if it's been abandoned or something
15:07:09 <ChongLi> I think so
15:08:31 <enemy> destroy everything that lives
15:12:32 <cdh473_> enemy: what about viruses?
15:16:45 <enemy> cdh473_: i am not sure
15:17:13 <cdh473_> problematic, indeed.
15:17:38 <enemy> maybe the entire universe is alive
15:18:05 <enemy> it spontanously crates entities that self-reference, like myself
15:18:17 <monochrom> note that "destroy everything" satisfies the specification "destroy everything that lives". :)
15:18:34 <hcaulfield57> I'm trying to learn how to structure a Haskell program, so I'm using a homework example from Java class I'm in, I have the following code http://lpaste.net/100739, but how can I keep updating values in main?
15:19:42 <monochrom> hcaulfield57, see my http://lpaste.net/52480
15:19:48 <Eduard_Munteanu> hcaulfield57: what do you do with the values before / after updating?
15:20:11 <cdh473_> enemy: i think "alive" is too loose a term for such ultimatums
15:20:29 <hcaulfield57> Eduard_Munteanu: Well I want to have a loop in main, that allows the user to enter a command and change thus either print the bank value, make a deposit, whatever
15:20:40 <Eduard_Munteanu> FP-wise, the "update" is already well-defined if you wrote those 2 functions.
15:21:07 <Eduard_Munteanu> hcaulfield57: write a recursive function that does that then, and calls itself with the new value
15:21:26 <monochrom> which is what my example does
15:21:58 <hcaulfield57> monochrom: Yes, I just looked at it, so you generally need some sort of helper function for main
15:22:42 <Eduard_Munteanu> hcaulfield57: not really, why?
15:23:28 <hcaulfield57> Eduard_Munteanu: Well, because how else would you keep updating values, you have to call some function? Sorry, I'm new
15:23:30 <monochrom> the "helper" is the recursive function
15:24:09 <monochrom> all of us are in agreement, just using different languages
15:24:19 <hcaulfield57> Oh
15:24:27 <Eduard_Munteanu> Generally in functional programming you make fewer assumptions about how data is used (e.g. "is this something stored in a variable?")
15:24:55 <Eduard_Munteanu> hcaulfield57: that, or some looping combinator
15:25:37 <hcaulfield57> Is there a simple "complete" program that I could read to help get an idea?
15:25:42 <Eduard_Munteanu> hcaulfield57: anyway, the "update" isn't the central thing here, but looping itself
15:25:51 <monochrom> my example is a simple and complete program
15:26:13 <monochrom> you can already run it and play a number guessing game. go ahead play it. don't just read.
15:26:42 <hcaulfield57> monochrom: Okay I will, I'm going to work on mine a little though
15:27:05 <Hermit> I'm struggling beyond sanity trying to get libssh2 to work with ghc under mingw. It took me _days_ to get to the point where cabal compiles the package libssh2 without problems, but when I try to compile some code involving ssh, the linking phase fails miserably. http://lpaste.net/100740
15:27:31 <Hermit> maybe I should trash mingw and go with cygwin?
15:27:39 <Eduard_Munteanu> Hermit: FWIW, have you considered just calling 'ssh'?
15:27:50 <Hermit> the command?
15:27:54 <Eduard_Munteanu> Hermit: yes
15:28:18 <Hermit> wouldn't be clean in this situation. I need to transfer files and show progress and what not
15:28:55 <Hermit> I wouldn't sleep peacefully knowing I duct taped it to ssh
15:29:12 <Eduard_Munteanu> Hermit: implementing your own file transfer protocol, or using something provided by libssh2?
15:29:31 <joneshf-laptop> given `traverse` would `mapM` still be needed if the typeclass hierarchy were fixed?
15:29:45 <Hermit> I use libssh2 to do sftp and execute remote commands
15:30:09 <prooftechnique> Hermit: In answer to your mingw question, probably
15:30:39 <Eduard_Munteanu> Hermit: you can reuse the same ssh connection with the command itself too, if that's a concern
15:31:28 <maurer> So, when I try to build the 'encoding' library, cabal hangs on Preprocessing forever
15:31:31 <maurer> any idea what's up?
15:32:02 <hcaulfield57> Why does putStr not do anything?
15:32:10 <Eduard_Munteanu> joneshf-laptop: the flexibility might be nicer in case some traversable functor might have a more efficient mapM
15:32:11 <prooftechnique> How long is forever? Also, what's your cabal, ghc, etc. version?
15:32:24 <prooftechnique> hcaulfield57: What do you mean
15:32:25 <prooftechnique> ?
15:32:30 <maurer> prooftechnique: forever here is >10min
15:32:31 <Eduard_Munteanu> hcaulfield57: are you outputting a newline too?
15:32:37 <hcaulfield57> No
15:32:42 <maurer> ghc 7.6.3
15:32:44 <maurer> cabal 1.18.0.2
15:32:47 <joneshf-laptop> Eduard_Munteanu, ah okay, but they're for all intents and purposes equivalent right?
15:32:48 <Eduard_Munteanu> hcaulfield57: might be line-buffering then
15:32:48 <monochrom> hcaulfield57: simply line-buffering
15:33:12 <monochrom> use hFlush if you want
15:33:27 <hcaulfield57> monochrom: That's what I was just going to ask, is that normally necessary?
15:33:35 <Hermit> Eduard_Munteanu: I wasn't aware of the session reuse feature. That should make it less inconvenient, but I'd still like to get libssh2 working properly
15:33:47 <monochrom> it depends on the program specification
15:33:51 <Eduard_Munteanu> joneshf-laptop: assuming the applicative and monad in question behave identically
15:34:09 <hcaulfield57> http://lpaste.net/100741
15:34:32 <monochrom> no. specification. that is, what is the objective.
15:35:04 <hcaulfield57> monochrom: Was that for me?
15:35:06 <monochrom> and why are you placing the \n before, as opposed to after.
15:35:09 <monochrom> yes.
15:35:21 <hcaulfield57> Because I want to move the line forward one
15:35:42 <monochrom> ok, add an \n after as well.
15:35:49 <hcaulfield57> Yes, I just did that
15:36:10 <Eduard_Munteanu> Hermit: it looks like it doesn't find the openssl *static* library
15:36:20 <prooftechnique> hcaulfield57: You should also add a fallthrough case in loopBank
15:36:43 <hcaulfield57> prooftechnique, Well I'm not done yet, I just wanted to make sure it compiled
15:36:48 <Eduard_Munteanu> Hermit: generally static libs are a sign things are off in Windows, I think
15:37:09 <prooftechnique> maurer: What's your OS, and what's your C compiler? I'm trying to install now, so I'll let you know what happens
15:37:10 <Eduard_Munteanu> Try getting it to link dynamically only instead.
15:37:56 <Hermit> Eduard_Munteanu: I'll look into it, I'm not too familiar with C toolchains so that pointer is useful
15:38:31 <Eduard_Munteanu> Hermit: the problem is you generally need static libs to build static libs and dynamic libs to build dynamic libs.
15:38:44 <Eduard_Munteanu> As dependencies, I mean.
15:39:03 <Hermit> *.a are static, *.dll are dynamic   right?
15:39:14 <maurer> prooftechnique: OS is gentoo, gcc is 4.7.3-r1
15:39:35 <maurer> Oh nevermind
15:39:38 <maurer> it's finished
15:39:40 <maurer> it took 30 minutes
15:39:40 <Eduard_Munteanu> Hermit: DLLs are dynamic libs under Windows, the *.a's might be a mingw bastardization
15:39:42 <maurer> but it finished
15:39:50 <prooftechnique> Hahaha
15:39:59 <prooftechnique> Oh, good. I hope I'm not waiting that long
15:40:17 <geekosaur> Hermit: .a would be static for cygwin, .lib is usually static for native
15:40:19 <Eduard_Munteanu> Hermit: I don't think there's any equivalent to static libs for Windows, not anything in widespread use.
15:40:19 * hackagebot bytestring-from 0.2.1 - A type-class to convert values from ByteString.  http://hackage.haskell.org/package/bytestring-from-0.2.1 (ToralfWittner)
15:40:30 <prooftechnique> maurer: Do you have the jobs flag set in your cabal config?
15:40:53 <prooftechnique> Actually, no, that's probably irrelevant here
15:41:24 <Hermit> I see
15:41:47 <Hermit> geekosaur: since mingw uses msys, a fork of cygwin, .a may be static
15:41:52 <monochrom> *.lib is static lib for windows, but I have not seen one for a long time
15:43:40 <tidux> why is cabal-install running out of memory trying to install Pandoc?
15:43:52 <tidux> I have 8GB RAM in this machine and not a heck of a lot else running
15:44:54 * Hermit is considering making a guide if he happens to get the whole thing working
15:46:29 <Eduard_Munteanu> It's a bit awful Linux distros still use static libs to build self-contained stuff.
15:46:51 <Eduard_Munteanu> It can be done just as well with .so's.
15:48:02 <Hermit> maybe the gain is in robustness? (no .so version incompatibility problem when updating)
15:48:35 <tidux> that's probably it
15:48:52 <tidux> GHC in particular is an enormous goddamn pain to build from source
15:49:09 <geekosaur> if you wiorship at the altar of the ideal shared object, that cannot be a problem. if you worship at the altar of reliability, you are obviously stupid becaluse <long list of failure modes> are known to be absolutely impossible on modern systems by worshippers of the ideal shared object
15:49:09 <hcaulfield57> Okay, I'm making a little progress, why does getLine not block on line 15 http://lpaste.net/100741
15:49:13 <Eduard_Munteanu> Hermit: with RPATH set properly and providing all deps there should be no such problem
15:49:49 <geekosaur> hcaulfield57, because getChar does just thatr
15:49:58 <geekosaur> but your terminal is in line mode, so you entered a line\
15:50:13 <hcaulfield57> geekosaur: Oh so it didn't consume the newline
15:50:22 <geekosaur> so getChar returned the first character and the ensuing getLine read the following newline
15:50:36 <hcaulfield57> geekosaur: Okay, thank you!
15:51:01 <hcaulfield57> I switched to just taking the head of getLine
15:51:04 <merijn> geekosaur: The more I learn about linking, the more I <3 static linking everywhere :)
15:51:42 <geekosaur> dynamic linking is not indefensible, in fact for many things it makes a lot of sense, but I want my recovery tools to be static
15:51:53 <Eduard_Munteanu> It's a bit annoying the toolchains can't use .so's for building statically-linked code.
15:52:10 <geekosaur> that actually worked on i386
15:52:30 <hcaulfield57> Cool, it's working, but I still don't understand the calls to hFlush
15:52:40 <geekosaur> it does not work on x86_64, the code generated for dynamic calls is not compatible with static cals
15:53:33 <Eduard_Munteanu> geekosaur: not sure why that'd be a problem if you just want to build a static binary
15:53:50 <geekosaur> this suggests to me you dont actually know what's going on
15:54:40 <hcaulfield57> me?
15:55:01 <geekosaur> no, Eduard_Munteanu does not understand why a dynamic call is not a static call
15:55:07 <hcaulfield57> Oh okay, sorry
15:55:07 <Eduard_Munteanu> geekosaur: hm? .so code is PIC, so you can just do whatever the linker does at runtime, or what prelinkers do
15:55:41 <Eduard_Munteanu> That is, just do relocation at build time and copy in all code.
15:56:19 <Hermit> Eduard_Munteanu: I'm rebuilding most libs adding "share" parameter to the config script, just in case.... Been looking for RPATH but looks like what I've found about it is not very relevant
15:56:58 <Eduard_Munteanu> Hermit: you shouldn't need to mess with RPATH, that was just a reference to building self-contained packages using dynamic libs only.
15:57:19 <Eduard_Munteanu> Actually it doesn't even make sense on Windows.
15:57:37 <codygman> Why is this python: http://pastebin.com/Y924jd0j 3 seconds faster than this haskell: http://lpaste.net/100743 However when input is changed to (replicate 12 12) the Haskell is twice as fast.
15:57:49 <Eduard_Munteanu> Hermit: if it's an autoconf package, you might want to --disable-static --enable-shared when building
15:59:17 <Eduard_Munteanu> codygman: ghci doesn't run code efficiently
15:59:31 <monochrom> @type replicate
15:59:32 <lambdabot> Int -> a -> [a]
15:59:49 <monochrom> I don't understand "replicate (n - 1) (n - 1)"
15:59:59 <Eduard_Munteanu> codygman: compile with 'ghc' and enable optimizations, '-O'
16:00:06 <monochrom> oh, now I understand
16:02:04 <codygman> Eduard_Munteanu: I did compile, here are my results: http://pastebin.com/WV2y6qaz
16:02:59 <Eduard_Munteanu> codygman: the Haskell RTS might be slower to load... also the GC might be a bit too aggressive, you can try increasing the heap size
16:03:27 <Eduard_Munteanu> codygman: however you should try testing them on larger, multiple runs
16:03:44 <codygman> Eduard_Munteanu: Alright, how large do you think?
16:04:13 <codygman> pypy seems to do this task 40 times faster than ghc
16:04:26 <codygman> I'm just wondering why
16:05:22 <hcaulfield57> Yeaa, done with my program, thanks for all the help! Comments? http://lpaste.net/100741
16:05:39 <Eduard_Munteanu> codygman: run the test 10 times in a loop inside your code (you might want to make sure it doesn't share results though, for fairness)
16:05:47 <Hermit> Eduard_Munteanu: breakthrough! (though not working yet) http://lpaste.net/100745
16:05:56 <codygman> Eduard_Munteanu: Alright I will do that.
16:06:18 <Hermit> (recompiled most libs with --enable-shared  (and openssl with "shared" (has a strange config script)))
16:06:36 <Eduard_Munteanu> Hermit: have you tried  ghc -dynamic cuack.hs  ?
16:06:45 * Hermit tries
16:06:45 <tidux> [72 of 72] Compiling Distribution.Simple ( Distribution/Simple.hs, dist/build/Distribution/Simple.o )
16:06:46 <tidux> ghc: out of memory (requested 1048576 bytes)
16:06:46 <tidux> Failed to install Cabal-1.18.1.3
16:06:46 <tidux> cabal: user error (Error: some packages failed to install:
16:06:46 <tidux> Cabal-1.18.1.3 failed during the building phase. The exception was:
16:06:46 <tidux> ExitFailure 1
16:06:46 <tidux> )
16:06:53 <ParahSailin> codygman: looks like its slow because naive implementation
16:07:04 <tidux> that's complete bullshit, I had at least 6GB RAM free
16:07:16 <tidux> how do I make GHC allocate more RAM for a build process?
16:07:59 <quchen> hcaulfield57: What if I enter "hello" when the program asks me for a deposit?
16:08:31 <artyomkazak> tidux: I think it's “cabal install --ghc-options=...”
16:08:38 <Hermit> Eduard_Munteanu: strange, it now complains about Data.DList. 'Perhaps you haven't installed the "dyn" libraries for package `dlist-0.6.0.1`?'
16:08:41 <artyomkazak> tidux: hold on, I'll figure it out
16:09:01 <quchen> hcaulfield57: There might be other functions similar to read in Text.Read that allow you to handle a reding error.
16:09:50 <Eduard_Munteanu> Hermit: do that then... it's a bit weird GHC doesn't link Haskell stuff dynamically by default on Windows, though, I recall that was the case.
16:10:00 <monochrom> readMaybe is in Text.Read. it tells you about errors without bombing your program
16:10:04 <artyomkazak> tidux: something like “cabal install --ghc-options="+RTS -M1G" ”
16:10:15 <quchen> monochrom: Spoilers etc.
16:10:17 <geekosaur> if it's a 32 bit system there's only so much memory a single process can address
16:10:26 <tidux> it's a 64 bit system with 8GB RAM
16:10:31 <tidux> I should *not* be having OoM problems
16:11:03 <monochrom> don't attribute to GHC that quickly. it may be simply ld.
16:11:17 <hcaulfield57> quchen: Yea, I'm pretty hosed if someone does that haha
16:11:46 <hcaulfield57> This was my first attempt though, the repeated >> and >>= could probably be cleaned up with do too
16:13:46 <quchen> hcaulfield57: Also consider an empty result in line 11. (Adding support for invalid entries is fairly easy, by the way; the code to handle an invalid entry of some sort is already in the paste, namely line 19. Have a look at readEither.)
16:15:23 * hackagebot wai-predicates 0.2 - WAI request predicates  http://hackage.haskell.org/package/wai-predicates-0.2 (ToralfWittner)
16:15:56 <hcaulfield57> quchen: Thanks, I did not know about readEither, I was just happy I made something that worked.
16:17:46 <quchen> hcaulfield57: readEither is generally preferrable to read (which crashes on invalid input). Even more preferrable is a proper parser, but for the beginning using the Read class is often good enough.
16:18:16 <quchen> Also consider this, which is equivalently valid for Read: https://github.com/quchen/articles/blob/master/fbut.md#i-dont-like-this-show-instance
16:18:45 <quchen> Where prettyprinter -> parser, Show -> read, to String -> from String.
16:18:45 <carter> tidux: what ghc version?
16:19:06 <monochrom> for now, readEither is not better than readMaybe. the error message given by readEither is dumb. see the source code.
16:19:28 <tidux> 7.6.3
16:19:50 <tidux> ok, something is clearly wrong here
16:20:00 <tidux> I used --ghc-options="+RTS -M4G"
16:20:04 <tidux> and still ran out of memory
16:20:17 <Luke> I'm trying to upload a package to hackage but I'm getting "forbidden" HTTP errors even though I'm in the maintainer group. any ideas why?
16:20:53 <quchen> monochrom: At least you get the distinction between invalid and ambiguous parses. But yes.
16:21:00 <haskellanout> hello #haskell
16:21:04 <quchen> (Also String)
16:21:22 <monochrom> readMaybe makes the same distinction
16:22:00 <quchen> readMaybe gives you a Nothing, which could be either.
16:22:00 <monochrom> err, I need to check
16:22:05 <quchen> http://hackage.haskell.org/package/base-4.6.0.1/docs/src/Text-Read.html#readEither
16:22:09 <hcaulfield57> Despite the lack of error handling, is the program structured decently? I'm just trying to get an idea of what Haskell code looks like, vs how one would do something in an imperative language like C, etc.
16:22:20 <haskellanout> is IdentityT (Writer [a]) () appropriate for testing something like mapM_ ?
16:23:02 <quchen> hcaulfield57: Yes, that's what a program that does what your program does looks like in Haskell.
16:23:29 <haskellanout> or , if not, what do you use to test monadic functions that discard results ?
16:23:36 <Eduard_Munteanu> haskellanout: hi... what sort of testing?
16:23:39 <monochrom> I see, ok, it may nominally say "ambiguous parse". note that none of the standard Read instances and "deriving Read" ever give you an ambiguous parse. therefore, that is dead code in practice. it's why I say it's dumb.
16:24:21 <quchen> I don't think anyone has ever checked the Left result of readEither anyway.
16:24:24 <Hermit> Eduard_Munteanu: ok, I figured out how to get those dyn libs, made cabal rebuild a bunch of stuff, then had to manually copy lots of .dll files to the cuack.hs (dummy name) folder, and it seems to be closer to working than before. This time it links, and runs, but complains about needing "-threaded". Seems I'll have to rebuild something else but maybe it'll work this time
16:24:27 <quchen> You would have to parse the error message ;-)
16:24:29 <hcaulfield57> quchen: Haha, thanks :)
16:24:55 <quchen> hcaulfield57: That's not to say you can't refactor it. Make the >>= >> business `do` notation, handle bad input.
16:25:08 <Eduard_Munteanu> haskellanout: are you aware 'IdentityT m a' is pretty much equivalent to 'm a'?
16:25:21 <hcaulfield57> quchen: Yea, I probably will tonight, I think do notation probably makes it easier to read
16:25:24 * hackagebot wai-routing 0.4 - Declarative routing for WAI.  http://hackage.haskell.org/package/wai-routing-0.4 (ToralfWittner)
16:26:19 <haskellanout> Eduard_Munteanu: yes I am aware of that from the definition, but i want to keep the map results so I can compare them with another, let's say list
16:26:45 <Eduard_Munteanu> haskellanout: you can mapM in Writer directly too
16:29:53 <haskellanout> Eduard_Munteanu: I don't really understand what you are saying, so , to take an example how would I test that customMapM_ == mapM_
16:30:25 * hackagebot stripe 0.8.0 - A Haskell implementation of the Stripe API.  http://hackage.haskell.org/package/stripe-0.8.0 (LukeHoersten)
16:31:20 <Eduard_Munteanu> haskellanout: not sure, what does a custom mapM_ do differently?
16:32:53 <haskellanout> Eduard_Munteanu: nothing, i just want to see if it's correct, but I guess I could just use 'tell' and the get out something like ((),t)
16:33:35 <Eduard_Munteanu> haskellanout: can you pastebin some code you're working on? I'm not sure what you mean.
16:35:22 <haskellanout> Eduard_Munteanu: i haven't really started working on anything, this is me figuring out where to start
16:35:30 <codygman> ParahSailin: How should it be implemented?
16:37:11 <Hermit> Eduard_Munteanu: thanks for the help so far. It now compiles, links, but segfaults. Will resume this tomorrow, too tired right now
16:37:22 <Eduard_Munteanu> haskellanout: mapM_ over a list and print something in IO
16:37:41 <Eduard_Munteanu> Hermit: heh, alright... good luck.
16:37:56 <Hermit> :)
16:39:19 <ParahSailin> codygman: i didnt look at it that hard, but you might try looking for another way
16:39:22 <haskellanout> Eduard_Munteanu: can't, I have to use monadic quickcheck, but from what I can see Writer a () will do just fine, thank you for your time.
16:40:21 <Eduard_Munteanu> Oh, I see.
16:41:40 <mathstuf> hi, how would i do something like Reader Store [Either a b] -> Reader Store (Either a b)
16:41:45 <monochrom> yes, Writer makes a good test
16:41:58 <mathstuf> "lift sequence" isnt working
16:42:29 <joelteon> :t lift sequence
16:42:29 <lambdabot> (Monad m, MonadTrans t) => t ((->) [m a]) (m [a])
16:42:40 <joelteon> :t lift . sequence
16:42:41 <lambdabot> (Monad m, MonadTrans t) => [m a] -> t m [a]
16:43:35 <monochrom> parametric polymorphism means that testing mapM_ on Writer tells you a whole lot about what happens to mapM_ on other monads. but right now I'm too lazy to detail what is in the whole lot.
16:44:31 <monochrom> but it's the same story as: suppose "f :: a -> [a]" and "f () = [(), ()]". then it generalizes to "f x = [x,x]".
16:44:45 <monochrom> so even Identity is a good test
16:45:26 * hackagebot stripe 0.6.0 - A Haskell implementation of the Stripe API.  http://hackage.haskell.org/package/stripe-0.6.0 (LukeHoersten)
16:45:29 * hackagebot stripe 0.4.0.0 - A Haskell implementation of the Stripe API.  http://hackage.haskell.org/package/stripe-0.4.0.0 (LukeHoersten)
16:46:28 <mathstuf> huh
16:46:30 <haskellanout> how does Identity make a good test, I need a way to save some state and return unit ?
16:46:52 <mathstuf> :t (lift.).(lift.sequence) -> unhappy GHC
16:46:53 <lambdabot> parse error on input `->'
16:46:57 <mathstuf> :t (lift.).(lift.sequence)
16:46:58 <lambdabot> ghc: panic! (the 'impossible' happened)
16:46:58 <lambdabot>   (GHC version 7.6.3 for x86_64-unknown-linux):
16:46:58 <lambdabot>         kindFunResult
16:47:00 <mathstuf> yep
16:48:14 <monochrom> I guess for mapM_, Identity isn't very informative. but mapM and Identity is very informative.
16:48:20 <joelteon> GHC 7.8 can handle it!
16:49:21 <haskellanout> yes it does, because all i need to know is in the return type
16:49:42 <haskellanout> * data, not type
16:54:18 <artyomkazak> weird, it crashes for me when I import Control.Monad.Trans.Class, but not when I import ClassyPrelude (which seems to reimport Control.Monad.Trans.Class)
17:03:17 <codygman> How would you guys handle an api exposing products (50+ million) which needs to be able to process 100 requests per second? Would Haskell and postgres be a fit for this? Is Haskell/mongodb good for this? I'm not sure how to approach this problem in Haskell.
17:03:58 <codygman> api would offer things like searching by title and filtering on attributes.
17:06:00 <hakujin> codygman: you're asking multiple questions. 1) how do I engineer a backend persistence solution that will handle X transactions/sec with some known query complexity? 2) how do I use Haskell to implement that design?
17:07:07 <hakujin> you need to understand 1 before you can understand 2
17:07:49 <jrmithdobbs> codygman: 100/s from one core? because ruby and python (and therefore, basically anything) can hit those numbers trivially
17:07:56 <cmears> If you move a cabal sandbox from one directory to another, everything breaks, right?
17:08:05 <jrmithdobbs> with a few basic assumptions anyways
17:08:19 <jrmithdobbs> cmears: nope
17:08:31 <jrmithdobbs> cmears: fully qualified paths ftw
17:08:51 <geekosaur> um? that'd be ftl
17:08:59 <geekosaur> since it will look for everything in the old location
17:09:24 <cmears> yes, relative paths would be more winny in this case
17:09:44 <jrmithdobbs> no, that is very much correct usage of ftw, it's almost always used sarcastically.
17:09:51 <cmears> oh
17:11:51 <jrmithdobbs> cmears: it's surprising behavior, i agree. i was shocked the first time i tried to move one, kind of seems to defeat the purpose
17:12:01 <cmears> yeah, it's a bit unfortunate
17:12:15 <jrmithdobbs> cmears: tbqh, i just moved things to 7.8 and started using dynamic linking
17:12:29 <cmears> does that help?
17:13:52 <hakujin> will GHC 7.8.1 work correctly on windows x64 post RC phase? https://ghc.haskell.org/trac/ghc/wiki/Status/GHC-7.8 isn't clear to me
17:16:22 <jrmithdobbs> cmears: ya it takes care of most of the problems i was actually addressing using sandboxes so it helps by not dealing with the problematic feature
17:16:43 <jrmithdobbs> cmears: but sandboxes themeselves are completely broken with dynamic linking last i looked, just to make things more fun ;p
17:17:56 <geekosaur> in any case I think the absolute path thing is a ghc-ism, I am not sure it even supports relative paths in a package database
17:25:57 <kgadek> anyone got haskell-platform installed via brew for GHC 7.8 on OS X Mavericks? configure complains about lacking  of "--enable-unsupported-ghc-version" but when I've added that I got: "parse error on input ‛glDrawArraysInstanced’"
17:26:11 <kgadek> got GHC via brew install --devel ghc
17:33:26 <jrmithdobbs> kgadek: i don't think all of the platform has been updated yet
17:34:08 <roboguy_> kgadek: I don't think brew is the suggested method
17:34:28 <jrmithdobbs> kgadek: so you're trying to build 7.6 ghc using a 7.8 ghc pre-release
17:34:43 <jrmithdobbs> which should rightly throw errors
17:35:15 <roboguy_> jrmithdobbs: I think brew does have 7.8 if you give it --devel
17:35:28 <jrmithdobbs> roboguy_: it has ghc but the platform package will depend on 7.6
17:35:35 <roboguy_> oh, I see now
17:36:31 <kgadek> yeah, --devel gives ghc 7.8. well. Any gossips on when the platform would be 7.8-ready?
17:36:39 <jrmithdobbs> kgadek: tl;dr version: platform on 7.8, you can have one
17:36:40 <geekosaur> much of the platform won't be upgraded for it until the final ships
17:36:44 <jrmithdobbs> s/on/or/
17:36:52 <geekosaur> because changes can sometimes occur
17:37:56 <kgadek> ok thanks then, i'll live w/o platform for a moment then
17:38:22 <geekosaur> you would do better installing the current released ghc
17:38:56 <geekosaur> unless you're working at the forefront of type hackery, 7.8 now won't get you much
17:39:09 <kgadek> wanted to play a little, yes ;)
17:39:22 <Galactic> could someone explain how this works:  foldl (flip (:)) [] [1,2,3,4]    I know what it does and I know a little about foldl but I don't know how to think about this one....for exaple I know that   foldl (+) 0 [1,2,3,4]  would  do ((((0+4)+3)+2)+1)  is that correct?
17:40:30 <Iceland_jack> > foldl (+) 0 [a,b,c,d]
17:40:31 <kgadek> Galactic: the second one is correct
17:40:31 <lambdabot>  0 + a + b + c + d
17:40:33 <Iceland_jack> > foldr (+) 0 [a,b,c,d]
17:40:33 <jrmithdobbs> geekosaur: gnd
17:40:34 <lambdabot>  a + (b + (c + (d + 0)))
17:41:17 <jrmithdobbs> safe gnd is the one thing you get that's obviously beneficial atm outside the perf stuff which may or may not apply anyways
17:41:45 <haasn> > foldl (+) 0 [a,b,c,d] :: Expr -- Galactic
17:41:46 <lambdabot>  0 + a + b + c + d
17:41:55 <haasn> > foldl (flip f) 0 [a,b,c,d] :: Expr -- Galactic
17:41:56 <lambdabot>  f d (f c (f b (f a 0)))
17:42:47 <kgadek> Galactic: about the first one… (:) is list concat, right? flip it, push to foldl so it'll start with [], then do 1:[], then do 2:1:[], etc
17:43:00 <mrbojangles3> hello all, I am trying to write a simple "Hello World" sytle haskell program, and I am having problems with the main method
17:43:22 <mrbojangles3> first time posting, I am an imperative programmer
17:43:29 <geekosaur> kgadek, not exactly
17:43:34 <geekosaur> (++) is list concat
17:43:37 <geekosaur> (:) is cons
17:43:38 <hpc> @where hpaste
17:43:38 <lambdabot> http://lpaste.net/new/haskell
17:43:38 <haasn> mrbojangles3: are you reading an introduction to Haskell?
17:43:56 <kgadek> geekosaur: yes, you're right. my bad
17:43:58 <jrmithdobbs> geekosaur: just mention it because it's a pretty underplayed feature of 7.8 and it benefits people new to haskell quite a bit
17:43:58 <mrbojangles3> haasn, got a lot of tabs open atm
17:44:06 <haasn> mrbojangles3: is LYAH among them?
17:44:07 <mrbojangles3> I think os
17:44:08 <jrmithdobbs> awesome terminal freeze for 2 minutes for no reason, bleh
17:44:18 <haasn> mrbojangles3: it's aimed towards programmers with imperative experience
17:44:31 <hpc> mrbojangles3: you can pretty much just follow lyah start to finish without any supplemental information
17:44:37 <mrbojangles3> ah, it was burried there
17:44:41 <hpc> (maybe being here will help, though ;))
17:44:59 <mrbojangles3> I am trying to read that and go through some project euler problems to get my feet wet
17:45:38 <desheng> I just spent like 15 minutes trying to figure out how on earth "interact" keeps -going- after getting one line and found myself in awe of the power of laziness
17:45:40 <mrbojangles3> I will continue through that book, and pop in with questions. Thank you
17:45:46 <jrmithdobbs> mrbojangles3: and then skim RWH for some decent examples of "design patterns" with semi-modern free libraries
17:46:04 <hpc> desheng: laziness isn't what makes interact tick, just first-class functions
17:46:06 <haasn> as opposed to proprietary libraries? :)
17:46:07 <hpc> @src interact
17:46:07 <lambdabot> interact f = do s <- getContents; putStr (f s)
17:46:16 <jrmithdobbs> (i mean the concept design patterns, not the specific 'patterns' in the work that references ;p)
17:46:17 <desheng> getContents reads stdin lazily though
17:46:20 <hpc> ...oh, it is laziness
17:46:21 <haasn> desheng: lazy IO
17:46:25 <mrbojangles3> the problem that originally brought me here was that I solved the first project euler in ghci
17:46:27 <haasn> desheng: but it's pretty horrible once you dig deeper
17:46:31 <hpc> desheng: derp, i thought interact mapped its function over each line
17:46:32 <kgadek> jrmithdobbs: RWH has issues with recent GHC, examples sometimes do not work out of the box
17:46:36 <mrbojangles3> and was looking to keep it in a file
17:46:43 <hpc> but yes, laziness
17:46:43 <jrmithdobbs> kgadek: i said skim ;p
17:46:44 <mrbojangles3> and I couldn't get it to compile
17:47:25 <haasn> mrbojangles3: if you have a file full of definitions you can just :l(oad) it in GHCi, or run “ghci filename.hs”. You can use :r(eload) to reload it after changes, too
17:47:27 <kgadek> jrmithdobbs: ok, just wanted to say that loud. I liked RWH a lot but then suddenly got very disappointed ;)
17:48:04 <jrmithdobbs> kgadek: it's a good *read* though if you keep in mind that some of it's already outdated
17:48:11 <mrbojangles3> thank you all
17:48:15 <haasn> mrbojangles3: note that definitions in GHCi and definitions in Haskell files look a bit different. I'm not sure if you've seen it but GHCi uses “let x = y” for introducing new definitions, in HAskell files the syntax is just “x = y”
17:48:15 <kgadek> jrmithdobbs: agreed
17:48:18 <haasn> no “let” in front of them
17:48:19 <hpc> kgadek: you might try to just keep going with RWH, and take the "not working out of the box" as "learn to understand type errors and debugging"
17:48:31 <mrbojangles3> ah
17:48:43 <jrmithdobbs> hpc: i actually found exactly that to be useful
17:48:50 <mrbojangles3> and the difference between "=" and "<-" is ...
17:48:51 <mrbojangles3> ?
17:48:59 <hpc> mrbojangles3: for a short and mostly meaningless to you at this point summary, ghci is a gigantic do-block
17:49:04 <jrmithdobbs> more so than the example i was trying to run in the first place, in several cases
17:49:06 <geekosaur> (a long story)
17:49:11 <hpc> "<-" is part of the sugar of do-notation
17:49:23 <hpc> it translates to (>>=) which you haven't learned yet
17:49:27 <hpc> (probably)
17:49:28 <haasn> mrbojangles3: <- is part of do syntax and binds the identifier on the left to the result of the action at the right
17:49:40 <geekosaur> the short version is, = is a binding, <- executes an action in a monad
17:49:48 <haasn> mrbojangles3: = is used for actual definitions, which don't involve actions or execution
17:49:48 <geekosaur> (this is a lie but close enough)
17:49:52 <haasn> mrbojangles3: LYAH explains this a lot better
17:49:59 <jrmithdobbs> ^
17:50:02 <mrbojangles3> ah
17:50:02 <haasn> mrbojangles3: I recommend not worrying about <- until you get to the chapter on Monads and IO
17:50:07 <hpc> mrbojangles3: basically, just go with it until a resource teaches it better
17:50:21 <hpc> there's an order of introduction of concepts that needs to be followed
17:50:23 <haasn> and by “not worrying about <-” I mean “not using it”
17:50:27 <haasn> don't write a hello world, play around in the debugger
17:50:40 <haasn> s/the debugger/GHCi/
17:50:44 <hpc> roughly along the lines of learning derivatives before integrals
17:50:50 <jrmithdobbs> mrbojangles3: i'm going to say something that's not going to be very popular, but you may be best off reading through lyah all the way once maybe not grasping everything or running the examples, then go back and re-read and follow the examples
17:51:10 <mrbojangles3> good to know
17:51:12 <jrmithdobbs> mrbojangles3: there is a lot of stuff that just will not make sense at all until near the end of the text and once it does the rest of it makes even more sense
17:51:27 <kgadek> jrmithdobbs: that's actually a good way, so you get ideas first and then (the second pass) is for the code
17:51:38 <kgadek> ideas > code
17:51:44 <jrmithdobbs> yes
17:51:48 <haasn> jrmithdobbs: if you follow it in order, there will be nothing introduced before it makes sense
17:51:59 <jrmithdobbs> haasn: you can assert that if you like, but I disagree.
17:52:11 <haasn> not my experience, at any rate
17:52:19 <hpc> not so much "ideas" as just having the words in your head
17:52:39 <hpc> so you can kind of "read ahead" and get a little bit of context for what you are currently reading
17:52:45 <mrbojangles3> (for me) I usually have to read things a few times through
17:52:50 <jrmithdobbs> haasn: it is *maybe* "the best kind of correct" but there's things near the end that if you understand them concepts at the begining are almost common sense
17:53:26 <mrbojangles3> jrmithdobbs & haasn & hpc, thank you all. going to get reading
17:53:30 <jrmithdobbs> monads are introduced and fully explained way too late in lyah imho
17:53:31 <roboguy_> jrmithdobbs: that's sometimes how I read papers that seem particularly cryptic
17:54:19 <hpc> jrmithdobbs: i think monads are introduced at the right point
17:54:44 <jrmithdobbs> and monoids are underrepresented
17:54:46 <hpc> jrmithdobbs: there's so much other stuff to learn that when you get to Monad there's basically nothing else to learn but "here's what join is, here's what do is"
17:55:00 <hpc> and it just becomes yet another type class, which it is
17:55:31 <hpc> instead of being "boosh, here's the ultra-code to everything; also here's some smaller similar abstractions"
17:55:59 <roboguy_> "Monoids: Themes and Variations" is good after you learn the basics of monoids
17:56:03 * hpc considers it analogous to going FSM -> CFG -> UTM in computability classes
17:57:29 <hpc> at the end of it all, a turing machine grammar ends up just being CFG plus the squeenciest of differences
17:57:31 <jrmithdobbs> hpc: i'm not claiming to have a better approach ;p
17:57:35 <hpc> :P
17:58:02 <Galactic> humm but I am confuse about the   flip (:)     part...and why I cannot do   foldl (:) [] [1,2,3,4]   that should be ((([]:4):3):2):1) which does not work... I guess my real question is how does flip work?
17:58:18 <hpc> yeah, all i know is that i learned Monad before LYAH had the chapter, and i wish that chapter was written sooner so i could have read it before the wikibook and such
17:58:22 * haasn likes byorgey's monoids pearl
17:58:24 <roboguy_> @src flip
17:58:24 <lambdabot> flip f x y = f y x
17:58:32 <hpc> perl monoid? ;)
17:58:58 <geekosaur> your real question might be what (:) does
17:59:00 <geekosaur> :t (:)
17:59:01 <lambdabot> a -> [a] -> [a]
17:59:21 <geekosaur> and how lists work in general, but that is defined by how (:) works
17:59:31 <hpc> flip (:) elem list = (elem : list)
17:59:37 <haasn> Galactic: if (:) 1 [2,3,4] = [1,2,3,4]  then  flip (:) [2,3,4] 1 = [1,2,3,4]
17:59:41 <geekosaur> []:4:3:2:1 is not a valid list
17:59:50 <jrmithdobbs> hpc: honestly, i don't think any of the haskell related texts directly made it make sense, i had to look at usage in familiar domains
17:59:56 <hpc> geekosaur: it is for spectacularly bad values of Num instances
17:59:59 <no-n> why can i do this infixr 5 :-:; data List a = Empty | a :-: (List a) and this (==>) = (*) but not this infixr 5 ==>; data List a = Empty | a ==> (List a)
18:00:01 <Fuuzetsu> > flip (:) 1 [2]
18:00:02 <lambdabot>  No instance for (GHC.Show.Show t0)
18:00:02 <lambdabot>    arising from a use of `M58311691095212961947861.show_M58311691095212961947...
18:00:02 <lambdabot>  The type variable `t0' is ambiguous
18:00:02 <lambdabot>  Possible fix: add a type signature that fixes these type variable(s)
18:00:02 <lambdabot>  Note: there are several potential instances:
18:00:06 <Fuuzetsu> hpc: ;)
18:00:18 <Fuuzetsu> > flip (:) 1 [2] :: [Integer]
18:00:19 <lambdabot>  Couldn't match expected type `GHC.Integer.Type.Integer'
18:00:19 <lambdabot>              with actual type `[t0]'
18:00:28 <jrmithdobbs> hpc: and that means research papers, and i'm not suggesting that to anyone as a learning method ;p
18:00:30 <khyperia> > flip (:) [2] 1 -- isn't it this?
18:00:31 <lambdabot>  [1,2]
18:00:32 <haasn> no-n: constructors in operator form have to start with a :
18:00:36 <Fuuzetsu> khyperia: it is
18:00:40 <geekosaur> no-n: because infix constructors must start with :
18:00:41 <no-n> o
18:00:42 <haasn> no-n: : is basically like an upper-case for symbols, if that makes sense
18:00:49 <no-n> ahh
18:00:50 <no-n> ty
18:01:10 <no-n> yeah that makes sense
18:01:28 <geekosaur> pattern matching must be able to identify a constructor lexically, which is normally done by looking fo rinitial uppercase. so : was declared to be an "uppercase symbol character"
18:01:43 <geekosaur> (thus making (:) not be a special case)
18:02:06 <jrmithdobbs> by making the definition a special case (cheaters)
18:02:07 <hpc> the decision was totally arbitrary and revolved mostly around the historical choices of ML-like languages' list syntax
18:02:19 <jrmithdobbs> heh
18:02:54 <hpc> but as bad decisions go, the repercussions of this one were pretty much nil, so yay on that
18:03:11 <Galactic> haasn: aaaa I see...I was not thinking of  ":" beeing a function :)  thanks
18:05:56 <no-n> why can't i do this data Tree a = Empty | (Tree a) :<: a :>: (Tree a)
18:06:00 <hakujin> what's the history on :: being type of and : being cons rather than the inverse?
18:06:18 <haasn> no-n: haskell does not have mixfix operators, only simple infix ones
18:06:23 <roboguy_> no-n: you can't do multiple operators-as-one-operator in haskell
18:06:27 <haasn> no-n: that is, your operators must consist of a single chain of symbols and it must have exactly two arguments
18:06:30 <roboguy_> unlike agda (I think)
18:06:35 <no-n> ok
18:06:57 <prooftechnique> roboguy_: Yeah, you can do all kinds of scary fixity stuff in Agda :D
18:07:16 <triliyn> Operators can have more than two arguments in their type, but if you want to pass a number of arguments to them that is not 2, they need to be sectioned
18:07:27 <roboguy_> prooftechnique: I always wondered about that. it seems like it could make things a little weird and potentially hard to read. I need to learn agda at some point
18:07:36 <triliyn> > let (+) = toUpper in ('a'+)
18:07:37 <lambdabot>  'A'
18:07:42 <prooftechnique> roboguy_: The simple example is if_then_else_
18:08:26 <augur> triliyn: wow thats.. interesting
18:08:29 <triliyn> > let (+) = foldr in ((:) + []) [1,2,3]
18:08:30 <lambdabot>  [1,2,3]
18:08:52 <haasn> triliyn: that's only valid with extensions, and not in Haskell
18:08:57 <khyperia> Isn't such an example (.)? It takes "three" arguments, depending on if you consider the final function to be the return value or if it takes a third value (silly currying)
18:09:03 <haasn> the former example, I meant
18:09:05 <khyperia> @src (.)
18:09:05 <lambdabot> (f . g) x = f (g x)
18:09:06 <lambdabot> NB: In lambdabot,  (.) = fmap
18:09:06 <roboguy_> > let (%) x y z w = x + y * (z - w) in (1 % 2) 3 4
18:09:07 <lambdabot>  -1
18:09:27 <haasn> khyperia: yeah, this is the magic of higher order functions. in reality, every function just takes one parameter
18:09:29 <triliyn> haasn: really? I was pretty sure it was possible normally
18:09:39 <haasn> triliyn: needs PostfixOperators
18:09:57 <triliyn> Interesting
18:09:58 <prooftechnique> > 4 ^.. adding 1
18:09:59 <lambdabot>  Not in scope: `adding'
18:10:03 <prooftechnique> Aww
18:10:04 <haasn> triliyn: normally ('a' +) is syntax sugar for (\x -> 'a' + x); with PostfixOperators it's instead (+) 'a'
18:10:14 <triliyn> Is that on by default in ghc? I thought I had seen someone do it without specifying the extension...
18:10:16 <haasn> @let import Numeric.Lens
18:10:17 <lambdabot>  Defined.
18:10:19 <haasn> > 4 ^.. adding 1
18:10:19 <pavonia> > let (%) = (/ 100) in (20%)
18:10:20 <lambdabot>  Not in scope: `adding'
18:10:20 <lambdabot>  can't find file: L.hs
18:10:35 <haasn> Oh no, lambdabot and her old version of lens :(
18:10:54 <Kaidelong> http://ocharles.org.uk/blog/posts/2014-02-04-how-i-develop-with-nixos.html did ocharles write this?
18:11:00 <prooftechnique> Oh, well, better not to pollute minds with the hardest way to add :D
18:11:01 <Kaidelong> I'm going to guess yes
18:11:36 <triliyn> hmmm, apparently it is not on by default! let (+) = toUpper in ('a'+) fails in ghci
18:12:48 <khyperia> So I read the wikipedia page on System F for the first time today, and I think I get it - but I think I heard once that Haskell is System Fw. Wikipedia has a note about this, but I'm not sure I understand it fully and it's differences with System F. Something about kinds? (the wikipedia note is pretty short)
18:12:50 <roboguy_> hmm, for when you need a representation of the isomorphism between +n and -n
18:13:24 <roboguy_> khyperia: haskell also has type classes
18:13:49 <khyperia> And - guessing here - type classes are, uh, "mappings from types to values"?
18:14:15 <roboguy_> no, type classes are adhoc polymorphism. the system Fw thing does have more to do with kinds, I think
18:14:25 <khyperia> ah
18:14:43 <prooftechnique> Isn't Fω an extension of Fc, or is it the other way around?
18:14:46 <roboguy_> type classes are sort of like logical propositions about types (kind of). and multiparameter type classes are sort of like relations between types
18:14:48 <haasn> khyperia: yes, type classes are mappings from types to values
18:15:20 <roboguy_> oh, actually that might make sense. type classes map types to their methods
18:15:27 <haasn> khyperia: at least, classic type classes. once you add MPTCs and FunDeps things get hairier
18:15:32 <prooftechnique> It's the other way around, now that I look it up
18:15:46 <khyperia> Haven't learned those things, so it's still pure for me, heh
18:15:57 <erisco> Having a tough time solving this without filter/fromJust [(1,Just 2),(2,Nothing),(3,Just 5)] -> [(1,2),(3,5)]
18:16:11 <prooftechnique> khyperia: FC gets us GADTs, too
18:16:19 <haasn> erisco: look into concatMap
18:16:29 <roboguy_> it always helped me to think of multiparam type classes as relations between types, so that would make single parameter type classes propositions about types (I think)
18:16:37 <haasn> oh, I know: you could use sequenceA and catMaybes :)
18:16:41 <haasn> :t catMaybes . map sequenceA
18:16:42 <lambdabot>     Not in scope: `sequenceA'
18:16:42 <lambdabot>     Perhaps you meant one of these:
18:16:42 <lambdabot>       `T.sequenceA' (imported from Data.Traversable),
18:16:43 <roboguy_> in sort of a prology way
18:16:48 <haasn> :t catMaybes . map T.sequenceA
18:16:48 <lambdabot> Traversable t => [t (Maybe a)] -> [t a]
18:16:52 <erisco> haasn, hmm I can see how that would work
18:17:13 <haasn> > catMaybes $ T.sequenceA <$> [(1, Just 2),(2, Nothing),(3,Just 5)] -- lovely
18:17:15 <lambdabot>  [(1,2),(3,5)]
18:17:37 <erisco> any other solutions that does not use an intermediate list?
18:17:46 <haasn> “intermediate list” -> fusion
18:17:57 <haasn> erisco: lens
18:18:23 <haasn> Hmm, I think
18:18:47 <haasn> :t toListOf $ _1 `beside` _2.Just
18:18:48 <lambdabot>     Precedence parsing error
18:18:48 <lambdabot>         cannot mix `beside' [infixl 9] and `.' [infixr 9] in the same infix expression
18:18:55 <haasn> :t toListOf $ beside _1 (_2.Just)
18:18:56 <lambdabot>     Couldn't match type `(->)' with `Accessor'
18:18:56 <lambdabot>     Expected type: p0 a0 (b0 -> Accessor (Endo [b0]) b0)
18:18:56 <lambdabot>                    -> t1 -> Accessor (Endo [b0]) t1
18:19:31 <haasn> :t toListOf $ folded.beside _1 (_2._Just)
18:19:32 <lambdabot> (Foldable f, Field2 t1 t1 (Maybe b) (Maybe b), Field1 t t b b) => f (t, t1) -> [b]
18:19:56 <erisco> haasn, okay thanks
18:20:11 <erisco> I am actually hunting for something to work in another language but I see it won't be so easy then
18:20:26 <roboguy_> erisco: what language?
18:20:32 <haasn> hmm what I just gave doesn't quite seem right
18:20:41 <erisco> roboguy_, an offtopic one :)
18:21:08 <haasn> oh, I don't want beside
18:21:17 <erisco> > toListOf $ folded.beside _1 (_2._Just) $ [(1, Just 1),(2,Nothing)]
18:21:18 <lambdabot>  Couldn't match type `[]' with `p0 a1'
18:21:18 <lambdabot>  Expected type: p0 a1 (t2, Data.Maybe.Maybe a2)
18:21:18 <lambdabot>    Actual type: [(t2, Data.Maybe.Maybe a2)]Couldn't match type `(t0, t1)'
18:21:18 <lambdabot>                with `Control.Lens.Internal.Getter.Accessor
18:21:18 <lambdabot>                        (Data.Monoid.Endo [a0]) a0'
18:21:19 <roboguy_> erisco: well, if it has lenses, that might be a place to look
18:21:31 <erisco> oh t1 is not right
18:21:44 <haasn> actually I do want beside. huh?
18:22:15 <haasn> oh, I don't want _1 and _2
18:22:18 <erisco> roboguy_, I might be able to implement something ad hoc for this case
18:22:26 <haasn> :t toListOf $ folded.beside id _Just
18:22:27 <lambdabot> Foldable f => f (t, Maybe t) -> [t]
18:22:29 <haasn> there we go ;)
18:22:58 <haasn> > [(1, Just 2),(2, Nothing),(3,Just 5)] ^.. folded.beside id _Just -- lens to the rescue again
18:22:59 <erisco> hm, I do not possess lens-fu
18:23:00 <lambdabot>  [1,2,2,3,5]
18:23:01 <prooftechnique> haasn: Damn, beat me to it
18:23:02 <roboguy_> haasn: that doesn't preserve the pairs though
18:23:06 <haasn> oops, not quite :(
18:24:34 <haasn> > [(1, Just 2),(2, Nothing),(3,Just 5)] ^.. folded.alongside id _Just -- this is the one I wanted
18:24:36 <lambdabot>  No instance for (Control.Applicative.Applicative
18:24:36 <lambdabot>                     (Control.Lens.Internal.Context.Pretext (->) b0 b0))
18:24:36 <lambdabot>    arising from a use of `e_112235'
18:24:36 <lambdabot>  Possible fix:
18:24:36 <lambdabot>    add an instance declaration for
18:24:49 <haasn> > [(1, Just 2),(2, Nothing),(3,Just 5)] ^.. folded.alongside (_1.id) (_2._Just)
18:24:50 <lambdabot>  Could not deduce (Control.Lens.Tuple.Field1
18:24:50 <lambdabot>                      GHC.Integer.Type.Integer GHC.Integer.Type.Integer a1 a1)
18:24:50 <lambdabot>    arising from the ambiguity check for `e_11223512'
18:24:50 <lambdabot>  from the context (GHC.Num.Num t,
18:24:50 <lambdabot>                    GHC.Num.Num a,
18:24:53 <haasn> oh well
18:25:10 <erisco> ah mapMaybe would be a simple solution
18:27:00 <haasn> oh, alongside only works on a single target :(
18:28:49 <haasn> oh well, it can be done using ReifiedFold's applicative instance
18:29:12 <johnw> erisco: yeah, alongside wants lenses, and _Just is not a lens
18:30:32 <johnw> > [(1, Just 2),(2, Nothing),(3,Just 5)] ^.. traverse.beside id _Just
18:30:34 <lambdabot>  [1,2,2,3,5]
18:32:11 <haasn> > let pair l r = runFold $ liftA2 (,) (Fold l) (Fold r) in [(1, Just 2),(2, Nothing),(3,Just 5)] ^.. folded.pair _1 (_2._Just)
18:32:12 <lambdabot>  Not in scope: `runFold'
18:32:12 <lambdabot>  Perhaps you meant `gunfold' (imported from Data.Data)Not in scope: data cons...
18:32:18 <haasn> lens version strikes again
18:34:10 <roboguy_> I think I'd just go with the "mapMaybe . sequenceA" verison
18:34:13 <roboguy_> *version
18:34:35 <roboguy_> err, mapMaybe sequenceA
18:34:45 <haasn> :t mapMaybe
18:34:46 <lambdabot> (a -> Maybe b) -> [a] -> [b]
18:34:51 <haasn> lovely
18:35:01 <roboguy_> > mapMaybe sequenceA [(1, Just 2), (3, Just 4), (5, Nothing), (6, Just 7)]
18:35:02 <lambdabot>  Not in scope: `sequenceA'
18:35:02 <lambdabot>  Perhaps you meant one of these:
18:35:02 <lambdabot>    `T.sequenceA' (imported from Data.Traversable),
18:35:02 <lambdabot>    `sequence' (imported from Control.Monad.Writer),
18:35:02 <lambdabot>    `T.sequence' (imported from Data.Traversable)
18:35:08 <roboguy_> > mapMaybe T.sequenceA [(1, Just 2), (3, Just 4), (5, Nothing), (6, Just 7)]
18:35:10 <lambdabot>  [(1,2),(3,4),(6,7)]
18:39:29 <erisco> roboguy_, for special reasons I cannot use sequence :o hrm
18:39:48 <roboguy_> erisco: that's a shame. sequence is pretty great
18:40:33 <haasn> write it yourself:
18:41:20 <erisco> ah wait that sequence is going from (a, Maybe b) -> Maybe (a, b) ... that I can do
18:41:22 <haasn> > let strength (x, m) = fmap (x,) m in mapMaybe strength [(1,Just 2),(3, Nothing)]
18:41:23 <lambdabot>  [(1,2)]
18:41:35 <haasn> -- we don't even need traversable
18:42:15 <erisco> haasn, nah it is just that I do not want [t a] -> t [a] because it destroys a key performance characteristic I need
18:42:46 <haasn> sequenceA is t (f a) -> f (t a)
18:42:56 <haasn> and the t here is (,) n
18:43:27 <erisco> yes, good, and so it won't be a problem :)
19:11:04 <dibblego> where can I find the library: hoist :: (forall a. f a -> g a) -> t f a -> t g a ?
19:11:21 <prooftechnique> @hoogle hoist
19:11:22 <lambdabot> No results found
19:11:34 <roboguy_> dibblego: mmorph I think
19:11:36 <johnw> (a, Maybe b) -> Maybe (a, b), that's actually distribute, isn't it?  f (g a) -> g (f a)
19:11:50 <roboguy_> johnw: I think it is strength as well
19:11:53 <johnw> it's mmorph
19:12:09 <dibblego> ok cheers
19:12:23 <johnw> roboguy_: strength from which library?
19:12:39 <johnw> ah, yes, that is tensorial strength
19:12:47 <roboguy_> johnw: not really from a library, just a sort of representation of functor strength http://statusfailed.com/blog/2013/01/26/haskells-strength-generalising-with-lenses.html
19:12:48 <johnw> v ⊗ F(w) → F(v ⊗ w)
19:13:07 <roboguy_> all I know is that it's functor strength haha. I don't know a whole lot of abstract math
19:13:15 <johnw> http://ncatlab.org/nlab/show/tensorial+strength
19:13:18 <roboguy_> (not yet, anyway)
19:13:39 <roboguy_> I have a copy of Conceptual Mathematics that I'm going to work through when I get the time
19:13:50 <johnw> that's a nice book
19:13:53 <johnw> i'm reading through it now too
19:14:15 <johnw> see also http://hackage.haskell.org/package/distributive-0.4/docs/Data-Distributive.html
19:14:18 <roboguy_> I haven't gotten too far yet, I got pretty busy with classes. I like it quite a bit so far though
19:14:36 <Galactic> If I have a list like [1,2,3,4,5] how could I print the odd or even indexes?
19:15:05 <johnw> Galactic: zip it with [1..], pick out the odds or even fsts, then take the snds
19:16:25 <Galactic> woa...thanks.
19:16:40 <johnw> Galactic: the compiler will likely boil it down to very little actual code by the end
19:16:58 <Iceland_jack> > [ elt | (elt, index) <- zip [1,2,3,4,5] [0..], odd index ]
19:16:59 <lambdabot>  [2,4]
19:17:00 <Iceland_jack> > [ elt | (elt, index) <- zip [1,2,3,4,5] [0..], even index ]
19:17:01 <lambdabot>  [1,3,5]
19:17:19 <johnw> Iceland_jack: that's probably the best use case for list comprehensions that I've ever seen
19:17:32 <Galactic> that is cool haha
19:17:55 <roboguy_> I kind of like things like catMaybes xs = [x | Just x <- xs]
19:18:15 <johnw> > do { (elt, index) <- zip [1,2,3,4,5] [0..]; guard (even index); return let }
19:18:15 <lambdabot>  <hint>:1:72: parse error on input `let'
19:18:22 <johnw> > do { (elt, index) <- zip [1,2,3,4,5] [0..]; guard (even index); return elt }
19:18:23 <lambdabot>  [1,3,5]
19:18:25 <roboguy_> that might be a controversial thing, I'm not sure. it's handy that pattern match failure works that way in list comprehensions though
19:18:43 <prooftechnique> Anyone wanna share their .ghci? I wonder if I'm missing anything important
19:18:58 <roboguy_> also singletons xs = [x | [x] <- xs]
19:23:50 <prooftechnique> Is there a good list of the mapping between English and operator in lens?
19:23:50 <Fuuzetsu> my .ghci is empty I thin
19:23:53 <Galactic> wao list comprehension is fucking awesome.
19:24:03 <Fuuzetsu> oh it has
19:24:06 <Fuuzetsu> :set -package ghc
19:24:51 <mwc> Is monad-control still the accepted solution for threading IO exceptions through application-specific monad transformer stacks?
19:25:10 <johnw> what do you mean by "threading"?
19:25:21 <johnw> if you mean, making polymorphic variants of "bracket" and "catch", then yes
19:25:31 <johnw> in fact, just use lifted-base
19:25:36 <prooftechnique> roboguy_: Oh, I didn't know there was a second edition of Conceptual Mathematics
19:25:39 <prooftechnique> Neato
19:26:09 <roboguy_> prooftechnique: yeah. % means modify (because it's used as "modulus" in some languages and that sort of sounds like "modify"), @ is for indexed. I think there are others, but I don't remember the mapping off the top of my head
19:27:06 <roboguy_> prooftechnique: looking ahead (well, pretty far ahead), it looks a bit intimidating but I guess that's why I should go through it in order haha
19:27:16 <roboguy_> looking ahead in Conceptual Mathematics, that is
19:27:27 <prooftechnique> Yeah, I remember a few of them, I was just hoping for a master list :D. @ for indexed is a mnemonic I didn't know, so I'll remember that
19:27:44 <prooftechnique> roboguy_: It's a really fun book (if this is what you find fun)
19:28:10 <prooftechnique> Lawvere's style is pretty approachable
19:28:12 <roboguy_> prooftechnique: I've had fun so far, just not enough time yet. probably will have some time for it soon though
19:28:45 <prooftechnique> I keep meaning to work through HoTT, myself, but it looks kinda scary :
19:28:47 <prooftechnique> *:D
19:29:06 <roboguy_> I like how it starts out at a very accessible level. that's the problem I've had all the other times I've tried to learn about category theory: it felt like trying to learn German by reading a German dictionary
19:29:30 <roboguy_> (I don't have very much background in abstract math though)
19:29:36 <prooftechnique> The first book I used to learn French was in French. Pictures helped. Just like categories! :D
19:30:10 <roboguy_> haha, yeah
19:31:17 <roboguy_> the pictorial aspect of category theory is interesting. is it a bad idea to rely on that a lot for picturing the concepts, or does that break down sometimes?
19:31:51 <roboguy_> on the other hand, I notice a lot of the information seems to often be contained mostly in the diagrams
19:32:56 <prooftechnique> The diagrams are definitely helpful for forming a mental model, I'd say
19:33:12 <johnw> the diagrams are very valuable
19:33:14 <prooftechnique> I used to draw a lot of pictures in algebra, too, so it fit my style of learning
19:33:45 <johnw> they can express a lot of details at once, and show the relationships among the details, that a linear presentation can make harder to see
19:34:11 <raphie____> my question is hard to explain without a gist, so the question's inside the gist: https://gist.github.com/RaphiePS/23cd3b5fd090a9d7329a
19:34:28 <johnw> indeed
19:34:41 <johnw> raphie____: writeFile <$> fmap head getArgs <*> getContents
19:34:53 <raphie____> what do <$> and <*> do?
19:35:00 <johnw> <$> is the operator form of fmap
19:35:10 <roboguy_> raphie____: <*> is from Applicative
19:35:11 <prooftechnique> :t <*>
19:35:12 <lambdabot> parse error on input `<*>'
19:35:15 <prooftechnique> :t (<*>)
19:35:16 <johnw> <*> applies a function-in-a-context to an argument-in-a-context, which in this case is IO
19:35:16 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
19:35:32 <raphie____> ahhh cool
19:35:36 <roboguy_> raphie____: I like to think of them as "context sensitive whitespace", if that makes sense
19:35:51 <johnw> raphie____: in general we refer to this as "applicative style"
19:35:53 <raphie____> do you guys have a recommended tutorial on these?
19:35:56 <raphie____> this is fascinating
19:36:06 <roboguy_> so, if not for IO, you would write it as writeFile (fmap head getArgs) getContents, but since we have IO we use writeFile <$> fmap head getArgs <*> getContents
19:36:17 <prooftechnique> raphie____: LYAH talks about them, RWH covers them.
19:36:24 <johnw> raphie____: you could try also http://www.serpentine.com/blog/2008/02/06/the-basics-of-applicative-functors-put-to-practical-work/
19:36:32 <raphie____> awesome!
19:36:37 <jle`> also there's that adit tutorial but it's more overview and less practical
19:37:04 <jle`> hm
19:37:08 <jle`> it's interesting that the Arrow laws
19:37:10 <jle`> do not require
19:37:20 <jle`> first f . second g === second g . first f
19:37:42 <jle`> or do they?
19:37:46 <jle`> http://hackage.haskell.org/package/base-4.6.0.1/docs/Control-Arrow.html#t:Arrow
19:38:10 <johnw> jle`: are you sure that's what you meant to write?
19:38:12 <roboguy_> jle`: doesn't second have to have an implementation that is functionally equivalent to the default?
19:38:17 <johnw> i don't think anything requires commutativity of composition
19:38:30 <jle`> but it's sort of the basic premise of Arrows, isn't it?
19:38:38 <jle`> the ability to compute things side-by-side and independently?
19:38:43 <roboguy_> johnw: doesn't it make sense in this context though?
19:38:53 <jle`> > first (*2) . second (+3) $ 7
19:38:55 <lambdabot>  No instance for (GHC.Show.Show a1)
19:38:55 <lambdabot>    arising from a use of `M51130759947631739358299.show_M51130759947631739358...
19:38:55 <lambdabot>  The type variable `a1' is ambiguous
19:38:55 <lambdabot>  Possible fix: add a type signature that fixes these type variable(s)
19:38:55 <lambdabot>  Note: there are several potential instances:
19:39:00 <jle`> > first (*2) . second (+3) $ (7,7)
19:39:01 <lambdabot>  (14,10)
19:39:07 <roboguy_> mapping over the first element of a tuple and then the second, vs mapping over the second then the first?
19:39:18 <jle`> > second (+3) . first (*2) $ (7,7)
19:39:19 <lambdabot>  (14,10)
19:39:38 <johnw> > second (+3) . first (-2) $ (6,7)
19:39:39 <jle`> it just sort of seems to make sense that they should be able to commute
19:39:40 <lambdabot>  Could not deduce (GHC.Num.Num (GHC.Integer.Type.Integer -> d))
19:39:40 <lambdabot>    arising from the ambiguity check for `e_13267'
19:39:40 <lambdabot>  from the context (GHC.Num.Num a,
19:39:40 <lambdabot>                    GHC.Num.Num (b -> d),
19:39:40 <lambdabot>                    GHC.Num.Num b)
19:39:45 <johnw> > second (+3) . first (/2) $ (6,7)
19:39:46 <lambdabot>  (3.0,10)
19:39:52 <johnw> > first (/2) . second (+3) $ (6,7)
19:39:53 <lambdabot>  (3.0,10)
19:40:20 <jle`> it's like if we had separate mapl and mapr
19:40:40 <jle`> although i guess it would make sense to have separate maplM and maprM
19:40:55 <jle`> if the arrow has effects
19:40:58 <roboguy_> jle`: oh, what about first f >>> arr (id *** g) = arr (id *** g) >>> first f
19:41:10 <jle`> roboguy_: not powerful enough
19:41:15 <jle`> g is a pure function
19:41:16 <roboguy_> jle`: doesn't "second f" have to be equivalent to id *** f?
19:41:17 <raphie____> johnw / roboguy: it actually doesn't work your way
19:41:20 <raphie____> which is perplexing
19:41:20 <Someguy123> oh wow this channel is pretty big, didn't think haskell had such a large community o_O
19:41:35 <jle`> roboguy_: g is a pure function in this case
19:41:43 <johnw> raphie____: show me the error!
19:41:43 <jle`> and not the arrow
19:41:47 <jle`> hm
19:41:49 <roboguy_> oh, I see
19:42:02 <jle`> actually yeah i think this makes sense for, say, any non-commutative monad
19:42:12 <raphie____> johnw: no error, it just runs and immediately exits
19:42:24 <prooftechnique> Doesn't that mean it worked?
19:42:38 <johnw> raphie____: show me what you have, and how you're running it
19:42:45 <roboguy_> raphie____: did it do something different when it was in do notation?
19:43:07 <jle`> > runKleisli (first (Kleisli (const () >=> put)) . second (Kleisli (const () >=> put))) (1,2)
19:43:08 <lambdabot>  Couldn't match expected type `Control.Arrow.Kleisli m0 (t0, t1) b0'
19:43:09 <lambdabot>              with actual type `a0 -> c0'Couldn't match expected type `b1 -> c0'
19:43:09 <lambdabot>              with actual type `Control.Arrow.Kleisli m1 (b2, d0) ((), d0)'Cou...
19:43:09 <lambdabot>              with actual type `Control.Arrow.Kleisli m2 (d1, b4) (d1, ())'Cou...
19:43:30 <jle`> i should probably step back to work this out
19:43:49 <johnw> jle`: use equational reasoning to prove your idea
19:44:00 <raphie____> johnw / roboguy: https://gist.github.com/RaphiePS/23cd3b5fd090a9d7329a
19:44:02 <johnw> show that first f . second g == second g . first f
19:45:30 <johnw> hmmm
19:45:33 <johnw> i find that quite surprising
19:45:46 <johnw> cute that you called it johnw.hs :)
19:45:48 * hackagebot rainbow 0.10.0.0 - Print text to terminal with colors and effects  http://hackage.haskell.org/package/rainbow-0.10.0.0 (OmariNorman)
19:45:53 <raphie____> heh
19:46:01 <roboguy_> has lazy IO struck again?
19:46:18 <raphie____> I also tried "liftM2 writeFile (fmap head getArgs) getContents" which compiled also
19:46:21 <johnw> i wonder
19:46:29 <johnw> if I compile it with GHC, it never asks for input
19:46:45 <raphie____> but it should be doing the same thing as desired.hs, right?
19:46:49 <raphie____> which works perfectly for me
19:47:04 <johnw> yes, they should be identical
19:47:04 <haasn> I see the error :)
19:47:08 <johnw> aha!
19:47:09 <johnw> don't tell me
19:47:11 <haasn> check the type of main
19:47:11 <jle`> @let put' = Kleisli put
19:47:12 <lambdabot>  .L.hs:156:16:
19:47:12 <lambdabot>      No instance for (MonadState a0 m0) arising from a use of `put'
19:47:12 <lambdabot>      The type variables `m0', `a0' are ambiguous
19:47:12 <lambdabot>      Possible cause: the monomorphism restriction applied to the following:
19:47:12 <lambdabot>        put' :: Kleisli m0 a0 () (bound at .L.hs:156:1)
19:47:13 <haasn> oh
19:47:19 <haasn> sorry
19:47:30 <Galactic> why when I do    print "Hello"   it prints it with the quotes...can I print without the quotes?
19:47:39 <haasn> Galactic: use putStrLn, not print
19:47:42 <jle`> @let put' = Kleisli (put :: s -> State s ())
19:47:43 <lambdabot>  Defined.
19:47:48 <haasn> Galactic: print = putStrLn . show
19:47:54 <hakujin> Galactic: print is defined as 'putStrLn . show'
19:47:58 <jle`> > runState (runKleisli (first p . second p) (1,2)) 0
19:47:59 <lambdabot>  Couldn't match expected type `b0 -> c0'
19:47:59 <lambdabot>              with actual type `Debug.SimpleReflect.Expr.Expr'Couldn't match e...
19:47:59 <lambdabot>              with actual type `Debug.SimpleReflect.Expr.Expr'Couldn't match e...
19:47:59 <lambdabot>                                  (Control.Monad.Trans.State.Lazy.StateT
19:47:59 <lambdabot>                                     s0 Data.Functor.Identity.Identity)
19:48:03 <Galactic> aaa ok thanks.
19:48:05 <haasn> Galactic: and show on a String will “format it” as if it was a haskell literal
19:48:09 <johnw> ahh
19:48:12 <johnw> my mistake
19:48:14 <jle`> aw works on ghci
19:48:15 <Iceland_jack> > show "hello"
19:48:16 <lambdabot>  "\"hello\""
19:48:19 <roboguy_> ahh
19:48:23 <roboguy_> I see the error too
19:48:25 <haasn> johnw: main = join $ do  -- ;)
19:48:28 <mgsloan> jle`: A first step to proving it would probably be to substitute the default definition of second, which is (arr swap >>> first f >>> arr swap)
19:48:37 <raphie____> haasn / johnw: ahhh, it's IO (IO ())
19:48:40 <roboguy_> this is why you should always have explicit type signatures for top-level functions (even main!)
19:48:45 <raphie____> how do I get rid of the extra IO wrapper?
19:48:48 <roboguy_> raphie____: join
19:48:51 <johnw> join
19:49:09 <johnw> nice catch, haasn
19:49:17 <raphie____> what's adding it though? the extra layer I mean
19:49:20 <johnw> raphie____: this is why I never code without type signatures on functions, even main
19:49:22 <raphie____> (sorry, I'm really new to monads)
19:49:35 <roboguy_> raphie____: writeFile gives you an IO ()
19:49:35 <johnw> writeFile <$> ..., the <$> is adding it
19:49:44 <raphie____> ahhhh
19:49:45 <roboguy_> and fmap (aka <$>) is adding another IO
19:50:21 <Iceland_jack> If you're new to IO, 'IO (IO ())' really shouldn't happen
19:50:35 <haasn> johnw: my reasoning was that f <$> x <*> y is equal to liftA2 f x y and liftM2 f x y is defined as do { a <- x; b <- y; return (f a b) } -- the “return” is what got my attention
19:50:47 <johnw> right
19:50:50 <johnw> i should have noticed that
19:50:56 <raphie____> so I settled on: main = do join $ liftM2 writeFile (fmap head getArgs) getContents
19:51:00 <johnw> the f before <$> is always pure in my usage
19:51:03 <raphie____> is there anything cleaner I could do?
19:51:34 <johnw> raphie____: what you had originally is really the cleanest and clearest
19:51:49 <raphie____> with the arrows? yeah
19:51:55 <raphie____> just wanted to experiment and see what's possible
19:51:56 <haasn> but you could use f:_ <- getArgs
19:52:06 <haasn> for a cleaner syntax and a cleaner error message
19:52:09 <prooftechnique> Shouldn't he be able to replace the <$> with <*> to avoid the extra IO ()?
19:52:23 <johnw> I tried that, but it didn't work
19:52:24 <haasn> prooftechnique: no, that would mean writeFile :: IO (...)
19:52:29 <Iceland_jack>     do [arg]    <- getArgs
19:52:30 <Iceland_jack>        contents <- getContents
19:52:30 <Iceland_jack>        writeFile arg contents
19:52:34 <haasn> what you want to do is replace the <*> by something that will join afterwards
19:52:34 <prooftechnique> Ah, right
19:52:47 <haasn> :t let f a b = join (ap f b) in f
19:52:48 <lambdabot>     Occurs check: cannot construct the infinite type: a0 = t0 -> a0
19:52:48 <lambdabot>     Expected type: t0 -> a0 -> t0 -> a0
19:52:48 <lambdabot>       Actual type: t0 -> (t0 -> a0) -> t0 -> a0
19:52:53 <haasn> :t let f a b = join (ap a b) in f
19:52:53 <lambdabot> Monad m => m (a1 -> m a) -> m a1 -> m a
19:53:02 <haasn> I wonder if that exists
19:53:09 <haasn> @hoogle m (a -> m b) -> m a -> m b
19:53:10 <lambdabot> Prelude (=<<) :: Monad m => (a -> m b) -> m a -> m b
19:53:11 <lambdabot> Control.Monad (=<<) :: Monad m => (a -> m b) -> m a -> m b
19:53:11 <lambdabot> Prelude (>>=) :: Monad m => m a -> (a -> m b) -> m b
19:53:40 <johnw> well, (a -> m b) -> m (a -> m b) is just return
19:53:47 <haasn> GHC should also warn if main is not :: IO () and no type signature is given
19:53:58 <haasn> and by should I mean “I want it to”
19:54:17 <roboguy_> haasn: I wouldn't think anyone would have a problem with that
19:54:22 <raphie____> so johnw, if writeFile returns an IO (), why does this not work? main = liftM2 writeFile (fmap head getArgs) getContents
19:54:32 <raphie____> ghc says that main then has the type (), not IO ()
19:54:51 <haasn> :t liftM2 writeFile (fmap head getArgs) getContents
19:54:52 <lambdabot> Not in scope: `getArgs'
19:54:59 <Iceland_jack> @ty liftM2 writeFile (fmap head System.Environment.getArgs) getContents
19:55:00 <lambdabot> IO (IO ())
19:55:03 <roboguy_> raphie____: that's equivalent to the <$> and <*> version
19:55:06 <johnw> raphie____: it would have to *not* return IO ... for that to work
19:55:18 <roboguy_> raphie____: it's trying to match IO () against (), that doesn't mean main is ()
19:55:37 <roboguy_> if it tries to match IO (IO ()) against IO (), it is trying to match IO () against ()
19:55:45 <raphie____> oh, so how would I fix it? trying to see how short I can get this, hehe
19:55:52 <roboguy_> well, join
19:56:00 <raphie____> so nothing shorter than: main = do join $ liftM2 writeFile (fmap head getArgs) getContents
19:56:00 <roboguy_> it's really equivalent
19:56:16 * haasn .oO( iI writeFile (head <$> getArgs) getContents J )
19:56:26 <raphie____> nothing that replaces do join?
19:56:35 <roboguy_> raphie____: you don't need do
19:56:42 <haasn> s/J/Ji/
19:56:42 <roboguy_> since you're not using do notation
19:56:47 <haasn> but please just forget that code ;)
19:56:53 <roboguy_> you essentialyl only need do if you're using <-
19:56:58 <Iceland_jack> raphie____: You shouldn't try to golf your code, especially when you're starting out with IO
19:58:03 <raphie____> Iceland_jack: fair enough, I guess I've learned the most when I ask "is there a more efficient way to do this?" and haskell usually says "yes!"
19:58:12 <prooftechnique> raphie____: Well, if you're golfing like this, you may as well drop the redundant do
19:58:40 <prooftechnique> haasn: You and your idiom brackets
19:58:55 <johnw> > @@ @pl @undo do { x <- fmap head getArgs; y <- getContents; writeFile x y }
19:58:57 <lambdabot>  <hint>:1:1: parse error on input `@@'
19:59:00 <johnw> @@ @pl @undo do { x <- fmap head getArgs; y <- getContents; writeFile x y }
19:59:00 <lambdabot>  (getContents >>=) . writeFile =<< fmap head getArgs
19:59:10 <johnw> as you can see, it doesn't really get much better
19:59:19 <TallerGhostWalt> is there a way to get cabal to tell you which packages in a cabal file aren't being used?
19:59:20 <prooftechnique> Oh, so I guess it was =<<
19:59:39 <johnw> TallerGhostWalt: I have a way to do that
19:59:51 <johnw> TallerGhostWalt: I use this script: https://gist.github.com/9382096
20:00:04 <johnw> first, you need to format your cabal file so that every package is of the form ", package"
20:00:07 <johnw> then, comment them all out
20:00:10 <johnw> and then run that script
20:00:15 <johnw> and it will bring back the ones that are necessary to build
20:00:38 <johnw> the other day I was able to remove 52 packages from a cabal file
20:00:59 <johnw> oh, and it's slow as molasses
20:01:12 <TallerGhostWalt> johnw: ooh, thanks!  I will try it.
20:01:27 <TallerGhostWalt> I just had like 3 things break on deps that weren't even needed.  so irritating
20:04:41 <TallerGhostWalt> oh man, thanks! this is perfect
20:04:52 <prooftechnique> I'm surprised cabal doesn't have something like that built in. I always end up running ghc -ddump-minimal-imports before I package anything up. That script will help
20:04:56 <johnw> TallerGhostWalt: my pleasure
20:05:16 <johnw> it hangs on multi-line dependency reports, so it need manual intervention sometimes
20:07:35 <johnw> yes, Cabal should know that it's importing a package for which no module is ever imported
20:08:31 <prooftechnique> Maybe stylish-haskell and ghc-mod can get a touch more clever. Hmm
20:09:33 <jle`> > runState (runKleisli (first put' . second put') (1,2)) 0
20:09:34 <lambdabot>  Couldn't match expected type `Control.Arrow.Kleisli
20:09:34 <lambdabot>                                  (Control.Monad.Trans.State.Lazy.StateT
20:09:35 <lambdabot>                                     s0 Data.Functor.Identity.Identity)
20:09:35 <lambdabot>                                  (t0, t1)
20:09:35 <lambdabot>                                  a0'
20:10:24 <jle`> ah well, it works on my ghci and it shows that second and first do not commute
20:10:31 <jle`> how weird
20:10:50 * hackagebot Commando 1.0.0.4 - Watch some files; Rerun a command  http://hackage.haskell.org/package/Commando-1.0.0.4 (LyndonMaydwell)
20:11:02 <jle`> (i'm assuming Kleisli follows the Arrow laws for appropriately lazy/strict monads)
20:11:51 <prooftechnique> Oh neat, a Haskell version of guard, maybe
20:11:54 <jle`> hm. in my arrow i am constructing i would like things to commute, although looking at it now it is apparently impossible with the way i am structuring it now. back to the drawing board
20:12:47 <jle`> question!
20:12:53 <jle`> if all you have is Applicative and Category
20:12:56 <jle`> can you get arr?
20:13:20 <codygman> I have a snippet of code, is there an easy way for me to count how many times it loops?
20:13:53 <jle`> (Applicative r a, Category r) => (a -> b) -> r a b ?
20:14:36 <jle`> i remember hearing on this channel some time in the past that you can, but the claim was heavily contested and i had to leave before i could hear the end of it
20:15:32 <raphie____> does anyone know of something like codecademy for haskell? where you learn stuff (preferably monads and all that jazz) by completing challenges?
20:15:50 <raphie____> I find it hard to learn from just reading a book, but when someone gives me a problem to solve, it makes sense
20:15:54 <jle`> doesn't codecademy have Haskell?
20:16:02 <jle`> guess not
20:16:34 <jle`> there are a couple of sites but they escape my mind at the moment :|
20:16:50 <Fuuzetsu> jle`: I hear that codecademy is bad
20:17:02 <TallerGhostWalt> johnw: yeah, this should so be part of cabal
20:17:09 <TallerGhostWalt> cabal -wall!
20:17:33 <raphie____> jle`: lemme know if you think of 'em!
20:17:44 <raphie____> I've tried the section on LYAH a couple times and I just get kinda muddled
20:17:57 <prooftechnique> raphie____: Which section?
20:18:01 <jle`> raphie____: exercism
20:18:13 <Platz> I've been enjoying exercism.io for acutal feedback on exercies, but I hear the https://github.com/NICTA/course is good for concepts too
20:18:18 <prooftechnique> Oh, yeah, exercism's pretty good
20:18:41 <jle`> :t pure
20:18:42 <lambdabot> Applicative f => a -> f a
20:18:46 <raphie____> prooftechnique: Functors, Applicatives, Monads, and then the Fistful of Monads chapter
20:19:11 <prooftechnique> Also, raphie____, you can try byorgey's course materials: http://www.seas.upenn.edu/~cis194/lectures.html
20:19:19 <prooftechnique> The homeworks are a lot of fun
20:19:53 <prooftechnique> raphie____: Okay, what are you having trouble with. I'm sure we can help.
20:19:58 <prooftechnique> *?
20:20:16 <codygman> If I wanted to write obsfucated Haskell, I'd use ":" to make lists
20:20:20 <codygman> > foldr (+) 0 $ 1 : 2 : 3 : []
20:20:20 <roboguy_> jle`: I think I just found a way
20:20:21 <lambdabot>  6
20:20:24 <raphie____> it's not a specific thing at all (though I certainly appreciate this channel, it's hands-down the most helpful I've ever visited)
20:20:51 <Platz> only problem with the exercism ones is the problems are simple enough they don't really force you to deal with things unique to haskell (yet)
20:20:51 <roboguy_> jle`: it helped to specialize the type signatures for pure and <*>. also, I used the fancy new type holes in ghc 7.8
20:20:52 <raphie____> more just like, I understand the theory but when it's time to make anything actually useful I have no idea what do to
20:20:53 <raphie____> *to do
20:21:25 <jle`> roboguy_: really now? :)
20:21:30 <jle`> probably just as interested in your process as your results
20:21:39 <prooftechnique> codygman: You could reasonably just stack folds as deep as you like. foldr (+) 0 (foldr (:) [] [1..3])
20:22:02 <jle`> codygman: you can also lambda-encode lists
20:22:28 <jle`> basically use functions as a free monoid
20:23:30 <prooftechnique> raphie____: A problem a lot of people have is that they don't separate the laws of Functors et al. from the semantics of particular instances.
20:24:08 <prooftechnique> Experiment with the familiar ones like [] and Maybe, then see if you can work out the instance for something like (r ->)
20:24:20 <jle`> every instance is unique and individual, there is really nothing uniting them semantically necessarily other than that they satisfy the laws
20:24:30 <prooftechnique> Right
20:25:53 * hackagebot identifiers 0.3.1.0 - Numeric identifiers for values.  http://hackage.haskell.org/package/identifiers-0.3.1.0 (awagner83)
20:26:11 <roboguy_> jle`: here's my result and an outline of how I went about it http://lpaste.net/100755
20:27:15 <roboguy_> type holes are one of my favorite new features
20:27:46 <Fuuzetsu> I'm just glad that 7.8 is here (nearly) because now we actually get to use TypeHoles with more than 3 libraries that compile
20:28:01 <Platz> Do they really give you any more information than using undefined and something like hdevtools?
20:28:19 <roboguy_> Platz: I haven't used hdevtools, but they do give more info than undefined
20:28:26 <roboguy_> they show (possibly) relevant bindings
20:28:46 <Platz> ah, yes thats different
20:29:26 <roboguy_> also, it's more convenient than writing either (undefined :: ()) or doing data Void; ... (undefined :: Void)
20:29:55 <Fuuzetsu> ‘data Hole’ is what all the cool kids used
20:30:39 <roboguy_> Platz: oh, also it tells you what parts of the code binds the various type variables
20:36:02 <codygman> Is the countToSlay function here tail recursive: http://lpaste.net/100758
20:38:25 <johnw> codygman: it looks that way to me
20:38:57 <johnw> you probably want to use !acc !heads
20:38:58 <roboguy_> codygman: I was going to say "if I wanted to write obfuscated haskell, I'd use : to do anything other than make lists", but it looks like ghc gets confused if you redefine it
20:39:15 <johnw> otherwise, you're going to accumulate (((acc +1) + 1) +1), etc.
20:39:27 <roboguy_> > let (:) x y = (*) x y in undefined
20:39:28 <lambdabot>  Occurs check: cannot construct the infinite type: t0 = [t0]
20:39:34 <roboguy_> > let (%) x y = (*) x y in undefined
20:39:35 <lambdabot>  *Exception: Prelude.undefined
20:39:41 <roboguy_> oh, I guess that makes sense
20:39:42 <geekosaur> I think you need rebindable syntax
20:39:45 <nolrai66> @pl swap (a,b) = (b, a)
20:39:45 <lambdabot> swap = uncurry (flip (,))
20:39:48 <codygman> johnw: Thanks for that. ! are bang patterns and require the compiler extension right?
20:39:53 <johnw> yes
20:39:54 <roboguy_> it's looking at it like a pattern match I guess
20:39:56 <geekosaur> also, expect the list sugar syntaxes to break badly
20:39:59 <johnw> you can avoid the compiler extension using seq
20:40:12 <johnw> let x = acc + 1 in x `seq` .. x ...
20:40:43 <haasn> Is it just me or does @pl seem to be popular lately?
20:41:35 <roboguy_> geekosaur: looks like it doesn't like it even with rebindable syntax
20:41:48 <roboguy_> probably for the best, haha
20:41:51 <codygman> johnw: Thanks!
20:41:54 <codygman> roboguy_: lol :P
20:42:01 <haasn> confusing haskell? rebind (>>=) and (>>) within a do block
20:42:02 <roboguy_> I wanted to set (:) = fmap
20:42:13 <geekosaur> actually, come to think of it, since leading : is a constructor, it probably should be somewhat weird
20:42:17 <haasn> bonus points if you make them behave differently
20:42:34 <haasn> (this is with RebindableSyntax)
20:42:50 <codygman> could you make : do the same thing except by using unsafeperformIO?
20:42:55 <roboguy_> geekosaur: right, I didn't even think of that
20:43:06 <nolrai66> Why?? >.<
20:43:35 <haasn> more bonus points if in  do { (>>=) <- foo; (>>) <- bar; ...} the new (>>=) makes the (>>) <- binding do something even crazier
20:44:02 <roboguy_> what if you just rebind it every time and actually get it to do something just by rebinding it over and over?
20:44:12 <roboguy_> to new things
20:44:13 <haasn> roboguy_: that would work, too. nice idea
20:44:18 * haasn can't wait to see this antipattern in action
20:44:32 <roboguy_> now *that's* obfuscation!
20:45:11 <haasn> do { (>>=) <- (=<<); (>>=) <- (=<<); (>>=) <- (=<<) } ...
20:45:30 <pharaun> ;_;
20:45:38 <haasn> bonus points if both (>>=) and (=<<) introduce new side effects
20:46:23 <haasn> I sort of want to program fizzbuzz using that.
20:51:37 <JustFunds> i need a bulk seller for cPanel pls
20:53:10 <prooftechnique> I prefer wine sellers
21:01:40 <codygman> Alright, in trying to calculate how many chops to cut off a hydras head the python is still 10x faster even after making the haskell variation tail recursive and using strictness annotations. I'm doing something wrong I think, but I haven't the slightest clue what. Is there a way to calculate this only doing 12 loops like the python does:  http://pastebin.com/index/UeWzy2NQ
21:03:25 <johnw> codygman: let me take a look
21:03:52 * BMeph shakes his head...so Many things wrong, there.
21:04:02 <johnw> BMeph: oh?
21:06:52 <codygman> BMeph: It's from this blog post: http://blog.gja.in/2014/01/functional-programming-101-with-haskell.html#.UxUuzt9B3os The solution there is mostly for description, but I was annoyed at it taking 7~ seconds and tried to make it faster. I soon realized I wasn't quite sure how to do that and now I want to fix this :)
21:07:30 <johnw> ok, it's slow because of the number of lists you're creating
21:07:36 <johnw> running it with "trace" shows this
21:08:54 <roboguy_> hmm, do you need to use lists at all?
21:09:31 <johnw> so, killing a hydra with 6 heads creates 5 hydras with 5 heads?
21:09:35 <haasn> why not uhm
21:09:39 <codygman> johnw: Do you mean with debug.Trace or with the compiler flags like +rts that generate prof files? Apologies, I haven't done much in the way of improving performance of Haskell stuff.
21:09:42 <haasn> chops 1 = 1; chops n = 1 + n * chops (n-1) ?
21:09:44 <haasn> is that not correct?
21:09:45 <johnw> Debug.Trace
21:10:14 <johnw> the replicate (n - 1) (n - 1) doesn't match with my memories of Hercules' trial
21:10:38 <prooftechnique> Is the explicit recursion necessary here?
21:10:58 * hackagebot warp 2.0.3.3 - A fast, light-weight web server for WAI applications.  http://hackage.haskell.org/package/warp-2.0.3.3 (MichaelSnoyman)
21:11:09 <nolrai66> err..why is it not (n!)?
21:11:16 <johnw> shouldn't it be replicate (n-1) 1?
21:11:37 <johnw> ah, I see
21:11:42 <johnw> (reading the original article now)
21:12:04 <haasn> oh, (n-1) *
21:12:05 <johnw> the reason for the list is to know the "rank" of the head you're chopping at any given times
21:12:37 <codygman> haasn: I don't get the same result. chops gives me 68588312 whereas countToSlay gives me 9864101
21:12:49 <haasn> codygman: see my correction
21:12:57 <codygman> haasn: Oh, alright
21:13:20 <haasn> I thought killing a rank 8 spawns 8 heads, it actually spawns 7
21:13:55 <haasn> I think that's just one extra step either way; you could just use chops (n-1)
21:14:03 <haasn> ie. chops 9 = countToSlay 10
21:16:01 <codygman> haasn: Yes that solution does indeed work for the case of one hydra. Then for multiple I can just use map. Interesting.
21:16:27 <haasn> as for the maximum length.. it seems like the problem should be similar
21:17:32 <codygman> johnw: Could the original inferior solution be made faster? I'm sure a problem will arise where I'll need to know how to reduce the number of lists generated in getting my solution. I thought maybe there was someway to use fold and use just one generated list but couldn't figure it out.
21:17:59 <prooftechnique> It does look a lot like a fold
21:18:58 <johnw> yeah, actually
21:19:22 <codygman> prooftechnique: Awesome, that means I'm building at least a bit of intuition :D
21:19:23 <haasn> ah, the other problem is indeed similar
21:19:58 <haasn> maxHydras 1 = 1; maxHydras n = (n-1) + maxHydras (n-1) - 1
21:20:05 <haasn> the -1 is because we slew one head to get there
21:20:16 <haasn> > let maxHydras 1 = 1; maxHydras n = (n-1) + maxHydras (n-1) - 1 in maxHydras 10
21:20:17 <lambdabot>  37
21:20:19 <haasn> :)
21:21:24 <codygman> haasn: Cool :)
21:24:55 <Fuuzetsu> “only doing 12 loops” is not something I hear every day
21:25:20 <prooftechnique> I can't remember the last time I thought about loops explicitly
21:25:29 <prooftechnique> Even in Ruby or Obj-C
21:25:34 <nolrai66> @pl f >** (x, y) = (f x, f y)
21:25:34 <lambdabot> (line 1, column 15):
21:25:34 <lambdabot> unexpected " "
21:25:47 <nolrai66> @pl \f  (x, y) -> (f x, f y)
21:25:47 <lambdabot> (`ap` snd) . (. fst) . (flip =<< (((.) . (,)) .))
21:26:00 * hackagebot yesod-platform 1.2.7.2 - Meta package for Yesod  http://hackage.haskell.org/package/yesod-platform-1.2.7.2 (MichaelSnoyman)
21:26:08 <prooftechnique> :t \f  (x, y) -> (f x, f y)
21:26:09 <lambdabot> (t -> t1) -> (t, t) -> (t1, t1)
21:26:13 <prooftechnique> :t (***)
21:26:14 <lambdabot> Arrow a => a b c -> a b' c' -> a (b, b') (c, c')
21:26:20 <Fuuzetsu> nolrai66: that func… yeah that
21:26:59 <nolrai66> > f *** (a, b)
21:27:00 <haasn> seriously, what's up with all the @pl users lately?
21:27:01 <lambdabot>  Could not deduce (Control.Arrow.Arrow (,))
21:27:01 <lambdabot>    arising from a use of `Control.Arrow.***'
21:27:01 <lambdabot>  from the context (Debug.SimpleReflect.Expr.FromExpr (b, c))
21:27:01 <lambdabot>    bound by the inferred type of
21:27:01 <lambdabot>             it :: Debug.SimpleReflect.Expr.FromExpr (b, c) =>
21:27:03 <haasn> prooftechnique: join (**)
21:27:07 <haasn> (***)
21:27:17 <prooftechnique> Yeah, I immediately had that thought
21:27:19 <haasn> over both
21:27:28 <haasn> (lens to the rescue again)
21:27:34 <roboguy_> prooftechnique: yeah. it's always strange to me when I hear someone complain about using recursion over loops because it's been so long...
21:27:36 <prooftechnique> Oh, that's much nicer.
21:28:06 <nolrai66> :t join (***)
21:28:07 <lambdabot> Arrow a => a b c -> a (b, b) (c, c)
21:28:38 <prooftechnique> roboguy_: Smart collection types and good generic code. <3
21:29:52 <nolrai66> @haasn: not sure. I use pl fairly regularly. Probobly not worth while now that I understand most of the functions/instances it uses.
21:29:52 <lambdabot> Unknown command, try @list
21:31:41 <roboguy_> nolrai66: it's often not too worthwhile regardless
21:32:25 <nolrai66> Oh i most used it too learn about the functions it uses.
21:32:44 <nolrai66> and sometimes I would forget something obvious.
21:33:51 <prooftechnique> I mainly use it when I know there's a simpler way to express something really pointy and just don't want to do the work
21:34:14 <prooftechnique> Then I strip out all the flips and aps to retain sanity
21:35:22 <roboguy_> I'm a little surprised it doesn't replace flip =<< with >>=
21:35:29 <roboguy_> oh, I misread that
21:37:07 <hellwolf> sort of ot, wouldn't it be cool to have some sort of haskell programming toy, like "lego"? Have anyone known whether such thing exists?
21:37:36 <prooftechnique> I'm pretty sure the Haskell toy of choice is PL design :
21:37:38 <prooftechnique> *:D
21:40:21 <hellwolf> what is that?
21:41:05 <prooftechnique> Programming language design
21:42:03 <johnw> codygman: still here?
21:42:42 <Redz> i dont think so. haskell programmers who wants to write a pl are too busy with learning the deeps of haskell.
21:44:43 <joneshf-laptop> so i've got this function: foo :: (Foo a b -> Foo a' b') -> Bar a b -> Bar a' b'
21:44:49 <joneshf-laptop> is this not fmap in disquise?
21:44:55 <roboguy_> hellwolf: you mean like logo?
21:45:02 <prooftechnique> Redz: https://github.com/chrisdone/z, http://www.idris-lang.org/, http://hackage.haskell.org/package/Agda, and DSLs all over the place, if you wanna count those
21:45:19 <mgsloan> and many many more
21:45:41 <johnw> codygman: https://gist.github.com/9383231
21:46:00 <mgsloan> It's quite possible to write a good compiler in plain Haskell 98
21:46:04 <prooftechnique> joneshf-laptop: Is Bar a Functor around Foo?
21:46:08 <johnw> joneshf-laptop: you'd need dimap and two functions Foo -> Bar and Bar -> Foo to write your 'foo'
21:46:10 <mgsloan> heck, GHC was once purely Haskell 98 :)
21:46:37 <levi> My haskell toy is an IRC server.
21:46:37 <mgsloan> (assuming by "deeps of haskell" you mean the extensions and such, which btw, sound much more daunting than they are)
21:46:42 <Redz> i also write on a pl, but i simple dont know how to do it the right way. yet. ;)
21:46:53 <prooftechnique> mgsloan: How can you even live without record puns and lambda cases?~
21:46:57 <hellwolf> roboguy_, yes, but with a haskell theme, each block is a function, and some function will have side effect(like light a led or show a number in screen)
21:47:22 <mgsloan> mgsloan: I don't use record puns or lambda cases - still using ghc 7.4 here
21:47:30 <mgsloan> (though record puns are in that)
21:47:31 <prooftechnique> hellwolf: You could check out http://hackage.haskell.org/package/atom
21:47:32 <levi> I ponder programming language design, but I have not yet indulged.
21:47:51 <mgsloan> I do use record wildcards, despite being semi-evil with respect to tooling :)
21:47:57 <prooftechnique> Haha
21:47:58 <joelteon> christ, there are still tarballs of GHC 3.02
21:48:03 <joelteon> that's awesome
21:48:37 <levi> prooftechnique: He's got a newer eDSL language as well. And Galois has a DSL that they're using to build control firmware for quadcopters.
21:48:52 <prooftechnique> Oh, neat
21:48:56 <roboguy_> wow z has the most aggressively whitespace based syntax I've seen
21:48:59 <roboguy_> well, other than "whitespace"
21:49:05 <joneshf-laptop> prooftechnique, huh, i hadn't thought of that part yet, but i suppose it is
21:49:16 <joneshf-laptop> prooftechnique, it's a zipper, so that's pretty much a functor, right?
21:51:05 <alpounet> codygman: the results given by the haskell and python programs differ
21:51:05 <codygman> johnw: Thanks, checking that out!
21:51:53 <prooftechnique> joneshf-laptop: I think so
21:51:57 <codygman> alpounet: I think the updated python program was using timeit and not outputting the result. I know the first python program had the same result, but didn't check the second. You did check it?
21:52:15 <alpounet> codygman: i have a list-less solution I think
21:52:26 <alpounet> at least it agrees with your Haskell program's output
21:53:02 <joneshf-laptop> i think i'm being fast and loose with the def'n of functor here
21:53:11 <hellwolf> I meant not programming a toy with haskell.. but build a programmable toy that can resembles haskell programming. For haskell learning, let's say. Imagine you have a `+` brick, two "Integer" brick and a IO monad brick with displaying functionality and a evaluate button on it. Join them together and click the button, wouldn't it be fun? A foldr machine would be even more fun, a button of evaluate next...
21:53:19 <joneshf-laptop> between the haskell version and the cat-theory version
21:53:28 <roboguy_> what was that visual haskell-based language someone was working on?
21:53:45 <joneshf-laptop> lambdu
21:53:58 <alpounet> codygman: is there a reference post that shows some values for various values of n?
21:54:10 <levi> joneshf-laptop: Yeah, I think you're being fast and loose with the term too. :)
21:54:11 <roboguy_> hellwolf: you might find this interesting http://peaker.github.io/lamdu/
21:54:19 <levi> I can't be specificy about *how*, though.
21:54:29 <prooftechnique> Well, every functor is unzippable. I think the laws should hold, mostly
21:54:40 <roboguy_> not quite what you're talking about, but still might be cool
21:55:23 <codygman> alpounet: yes, one second
21:55:49 <hellwolf> roboguy_, good stuff
21:56:11 <codygman> alpounet: http://blog.gja.in/2014/01/functional-programming-101-with-haskell.html#.UxUuzt9B3os
21:56:25 <levi> prooftechnique: I think the trick is being explicit about *how* it is a functor.
21:56:53 <prooftechnique> levi: Yeah, that'd be pretty key
21:57:01 <prooftechnique> codygman: That is some really unusual code
21:57:23 <joneshf-laptop> well in the cat sense it takes each Foo to a FooZipper, and all the (Foo -> Foo) functions become (FooZipper -> FooZipper)
21:57:42 <alpounet> codygman: for 9 9-level heads, I get the same result in a few ms
21:57:50 <alpounet> i don't go through lists at all
21:58:09 <roboguy_> I'm confused by his choice of definition of chop...
21:58:14 <prooftechnique> Yeah
21:58:23 <codygman> alpounet: With the updated solution that was provided by haasn it takes 0.003 for me.
21:58:32 <codygman> same for the one provided by johnw
21:58:35 <joneshf-laptop> although, i'm not sure the laws hold, so who knows
21:58:57 <alpounet> codygman: right, we're doing the same thing I think now
21:59:12 <codygman> roboguy_: I think its more for descriptive purposes but it should show a "warning: stack overflow" message and provide the more efficient listless solution.
21:59:34 <joneshf-laptop> though they should
21:59:41 <levi> prooftechnique: I think that's an example of a natural transformation, then
21:59:53 <joneshf-laptop> but wait, that makes sense, right?
22:00:00 <joneshf-laptop> since zippers are comonads
22:00:04 <joneshf-laptop> and comonads are functors
22:01:08 <jfischoff> the report says that unsafeLocalState is expected to be removed in a future revision of Haskell. http://www.haskell.org/onlinereport/haskell2010/haskellch30.html#x38-28500030
22:01:08 <levi> Every algebraic data type with a polymorphic type variable is a functor.
22:01:10 <jfischoff> why?
22:01:47 <roboguy_> levi: how do you define algebraic data type?
22:01:48 <joneshf-laptop> levi, hmm, really?
22:02:31 <roboguy_> levi: wait, also what do you mean by functor?
22:03:14 <alpounet> codygman: even with n=1000 it's almost immediate, although it's slowed down by switching to Integer
22:03:32 <levi> roboguy_: I mean haskell algebraic data types and endofunctors on Hask, roughly.
22:03:50 <roboguy_> levi: but you don't specifically mean the Functor type class, right?
22:04:32 <roboguy_> because there are definitely haskell data types that aren't instances of Functor
22:05:00 <levi> roboguy_: They either *could* be instances of Functor or have bounds on their polymorphism, I think.
22:05:12 <roboguy_> levi: bounds on their polymorphism?
22:05:31 <levi> That's what, e.g. type classes are.
22:05:54 <roboguy_> oh. well, here's an example: newtype Predicate a = Predicate (a -> Bool)
22:05:56 <roboguy_> no Functor instance
22:06:03 <roboguy_> (there's a Contravariant instance though)
22:06:42 <levi> Ah. Well, a functor but not a Functor.
22:06:51 <roboguy_> yeah
22:06:56 <levi> I had forgotten about contravariant functors.
22:07:14 <roboguy_> I could believe that, barring bounds on polymorphism, all haskell data types are either instances of Functor or Contravariant (or both)
22:07:16 <codygman> alpounet: Yes, I actually did up to 10000 I think and it was 1s or so ;)
22:07:28 <roboguy_> (that have a polymorphic type variable)
22:08:17 <prooftechnique> joneshf-laptop: If I'm remembering correctly, if your zipper is really a zipper, it should trivially be a functor (and maybe even a Functor)
22:08:25 <levi> Well, of kind * -> * anyway.
22:08:51 <joneshf-laptop> it's probably not
22:09:31 <joneshf-laptop> i didn't differentiate it to get the proper zipper, just kind of threw this together
22:09:47 <prooftechnique> Ah. Well, no idea, then :D
22:10:37 <joneshf-laptop> fwiw it doesn't lose any information between the transformations
22:11:05 <levi> Huet's zipper was not originally derived via differentiation, if I remember the story correctly.
22:11:42 <roboguy_> how does type differentiation work? I've heard about it before, and it *sort of* makes intuitive sense that a list zipper is the derivative of a list somehow, but I don't know much more than that
22:12:42 <roboguy_> I have a feeling I should wait until I know a little more about category theory
22:12:52 <prooftechnique> joneshf-laptop: Well, it's probably reasonable to say that foo is fmap, then and let the chips fall where they may
22:12:53 <joneshf-laptop> roboguy_, McBride has quire a few papers on it i think
22:12:57 <prooftechnique> It certainly looks like it
22:13:41 <levi> Well, types have enough of the same algebraic structure as the numbers we differentiate in calculus that the same algebraic manipulations work out, at least most of the time.
22:14:15 <roboguy_> hmm true. sum, product, exponentiation...
22:14:39 <joneshf-laptop> roboguy_, http://strictlypositive.org/diff.pdf http://strictlypositive.org/dfordata.pdf and i think some other
22:14:46 <roboguy_> joneshf-laptop: thanks!
22:14:58 <joneshf-laptop> roboguy_, don't forget subtraction and division!
22:15:09 <roboguy_> joneshf-laptop: can those be expressed in haskell?
22:15:09 <levi> McBride has a whole section of his site dedicated to it.
22:15:50 <roboguy_> division is somehow related to isomorphisms right?
22:15:52 <levi> Well, "subtraction" and "division" are addition and multiplication of inverses.
22:16:20 <joneshf-laptop> roboguy_, http://www.cs.indiana.edu/~sabry/papers/rational.pdf
22:17:01 <prooftechnique> roboguy_: Also, your derivation of arr with only Applicative and Category seems to work for me
22:17:10 <haasn> I'm quite sure I've read an article about embedding quotient types into Haskell for all algebraic ADTs (ones not involving GADTs)
22:17:40 <roboguy_> prooftechnique: cool!
22:18:32 <prooftechnique> roboguy_: There might be some general cases I missed, but the laws seem to hold for concrete stuff
22:20:37 <prooftechnique> What does type subtraction look like?
22:22:15 <prooftechnique> Quotient types make sense, but I'm finding it difficult to visualize difference types
22:22:57 <prooftechnique> At least in Haskell. Agda I can see. Are they even representable in Haskell?
22:23:17 <dolio> Quotient types aren't the same thing as fractions.
22:23:36 <dolio> Whatever fractions are.
22:23:55 <dolio> That Sabry paper is about a significantly different language than Haskell, too.
22:24:28 <dolio> It's not obvious if the notions in that paper correspond to the subtraction and division you might see in certain type manipulations in Haskell.
22:30:13 <dolio> For instance, 1 = 2 / 2 in his language, because 2 / 2 is a type that provides a boolean and demands a boolean (in some compatible way), and without anything else, you're forced to use the provided boolean only to fill the demand, so it's like not having either the supply or the demand.
22:30:51 <dolio> But in Haskell, if you have a boolean, you can use it to fill the demand and then use it for other things.
22:31:48 <dolio> Or just not meet the 'demand' for a boolean. Throw the demand away.
22:34:26 <haasn> dolio: something like linear operations on types?
22:34:45 <dolio> Yes, the Sabry language is linear, I beleive.
22:34:51 <dolio> It's for invertible computing.
22:34:58 <haasn> Ah
22:36:04 <dolio> Anyhow, you often see people manipulate formal power series of types, and get that List a = 1 / (1 - a)
22:36:50 <dolio> Is a list of as the same as a multiplicative demand of a supply of multiplicative unit and an additive demand of a?
22:37:16 <dolio> Maybe, but it's not super obvious.
22:38:29 <dolio> I guess that's 'multiplicative unit or additive demand of a' maybe.
22:41:11 <dolio> I guess it works out in that language.
22:42:03 <nolrai66> huh. That is interesting.
22:44:59 <jle`> my new thing is redefining operators locally in where/let clauses
22:45:17 <jle`> actually why do we even need functions with names, every two argument function should be an operator
22:47:06 <haasn> If I cabal install a library into a sandbox, how can I invoke “runghc” with access to that library?
22:47:26 <haasn> or ghci, for that matter
22:48:52 <prooftechnique> jle`: See if you can define insert to be (=>)
22:49:02 <prooftechnique> That'd be fun
22:50:27 <haasn> oh
22:50:32 <haasn> overriding GHC_PACKAGE_PATH works
22:51:05 <Fuuzetsu> yes, that does work, I do it for running sandboxed Yi
22:52:05 <prooftechnique> Fuuzetsu: Does Yi work well for you? I experiment with it occasionally, but I haven't settled on it
22:52:56 <Fuuzetsu> prooftechnique: I patch it up when I have time but I would certainly not call it usable to the point where you can abandon your own editor just yet. Hopefully I can work on it as GSoC project
22:53:10 <Fuuzetsu> but if you have problems then come to #yi and/or make GitHub issues
22:55:02 <levi> jle`: You really don't want anyone to be able to understand your code, do you? ;)
22:55:19 <jle`> > let (=>) = insert in 5 => [2,6,10]
22:55:20 <lambdabot>  <hint>:1:6: parse error on input `=>'
22:55:25 <jle`> :'(
22:56:16 <jle`> also my crazy idea for a new pipes/conduit implementation/framework/interface is stalling becuase i cannot figure out a proper semantics for side-chained pipes
22:56:58 <levi> What's a side-chained pipe?
22:56:59 <vozz> I want to use websockets and the scotty web framework together, but both servers just run together, so I can only use one or the other. What am I supposed to do?
22:57:58 <jle`> levi: exactly, right?
22:58:13 <jle`> imagine pipes being able to split off and re-join again
22:58:16 <levi> jle`: Um, yeah?
22:58:27 <jle`> and each half going through different pipes/transformations
22:58:52 <jle`> the main problem is that pipes can tick/progress at different rates :/
22:59:36 <jle`> so say one fork emits twice for every input, and the other fork emits once
22:59:45 <jle`> so how do you meaningfully join them back together?
23:00:03 <levi> vozz: Sorry, I'm not familiar with the APIs of either of those.
23:00:39 <jle`> my solution right now is that the 're-joining' part should only emit at 'common multiples' of both forks
23:00:44 <jle`> but implementing it is weird
23:00:50 <vozz> whoops, when I said together I meant forever
23:00:52 <jle`> while still following Arrow
23:01:54 <jle`> the whole point is to have it be based around an Arrow instance
23:04:01 <levi> vozz: Well, it's okay if they both run forever; you just need to have two threads. Or there may be some way to shoehorn the streaming interface of one into the other.
23:04:20 <levi> jle`: Still trying to arrowize everything, eh?
23:04:47 <jle`> levi: yes :) or well i decided that maybe a pipes/conduit type thing written from the bottom up with an arrow interface in mind might be worth looking into
23:05:06 <jle`> if at least as a side hobby
23:05:22 <jle`> i get to apply some things i learned from AFRP implementations
23:05:42 <jle`> if i have inhibition semantics then i can easily swap and switch out pipes mid-stream
23:07:43 <jle`> oh i think i have an idea.
23:10:08 <no-n> @src init
23:10:08 <lambdabot> init [x]    = []
23:10:08 <lambdabot> init (x:xs) = x : init xs
23:10:09 <lambdabot> init []     = undefined
23:10:28 <no-n> @src intercalate
23:10:29 <lambdabot> intercalate xs xss = concat (intersperse xs xss)
23:48:18 <luite> I've uploaded some GHCJS Google Summer of Code project ideas. If anyone is interested, join #ghcjs or #haskell-gsoc : https://github.com/ghcjs/ghcjs/wiki/GHCJS-GSoC-project-ideas
