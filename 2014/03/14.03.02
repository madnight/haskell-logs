00:49:47 <the_berserker> When I entered the recursive type bug at http://www.haskell.org/ghc/docs/6.12.2/html/users_guide/bugs.html in GHCi, it runs successfully. Why?
00:52:47 <pavonia> the_berserker: Do you mean the inliner bug?
00:53:07 <the_berserker> pavonia: Yes. Why?
00:53:57 <pavonia> Not sure, but does GHCi even use inlining?
00:54:26 <pavonia> I'd guess that's only a problem in compiled code
00:54:50 <the_berserker> pavonia: How to turn off the inliner?
00:55:25 <pavonia> I don't know
00:57:35 <pavonia> the_berserker: There's a NoInline pragma
00:58:04 <m3ga> the_berserker: {-# NOINLINE functionName #-} aove the functions definition
00:58:21 <m3ga> a/aove/above/
01:17:19 <peteretep> {-# LANGUAGE ...
01:17:22 <peteretep> What's the name for that?
01:17:44 <bxc_> language pragma?
01:17:53 <pavonia> yes
01:17:54 <bxc_> http://www.haskell.org/ghc/docs/7.2.1/html/users_guide/pragmas.html
01:17:58 <peteretep> perfect, thanks
01:22:39 <chrisdotcode> whoever made ghc(i) play nicely with shebang lines, thank you very much :)
01:25:03 <jle`> is there any way to denote a strict tuple?
01:25:15 <Axman6> in pattern matching sure
01:25:57 <jle`> hm
01:26:05 <jle`> i mean in a data declaration
01:26:20 <jle`> data Foo = Foo !(Double,Double)
01:26:22 <jle`> i feel like that would
01:26:26 <jle`> only force to WHNF
01:26:37 <jle`> does that make the doubles inside strict as well?
01:27:07 <Axman6> why do you need the tuple?
01:27:22 <Axman6> it just adds an extra redirection
01:28:08 <jle`> well there are multiple fields and one of them is a height/width tuple
01:28:19 <jle`> it would be kinda weird to have both a separate height and width
01:28:33 <jle`> in the forest of all of the other record accessors
01:28:47 <aristid> jle`: ?
01:29:10 <aristid> jle`: just do data Foo = Foo { width :: !Double, height :: !Double } :P
01:29:15 <Axman6> jle`: ... Foo !Double !Double? o.O
01:29:38 <jle`> there are a lot of other accessors
01:29:44 <jle`> in that record
01:29:51 <jle`> so i want some kind of way to semantically organize them
01:56:19 <ivanm> what happened to preflex?
01:57:17 * hackagebot trivia 0.0 - The trivial monad and comonad  http://hackage.haskell.org/package/trivia-0.0 (FumiakiKinoshita)
02:31:59 <antithesis> Is Haskell a good language for heavy interaction with the system shell?
02:32:31 <milfjord> why are you trying to interact with the shell?!
02:32:37 <antithesis> I currently work in sh and it's very straightforward for me since I often need to pass arguments to external programs like sed
02:32:55 <antithesis> Will Haskell be good for this as well?
02:33:22 <milfjord> you've lost me
02:33:37 <milfjord> running external programs doesn't require interaction with the shell
02:33:54 <Tijn> @antithesis http://www.yesodweb.com/blog/2012/03/shelly-for-shell-scripts
02:33:54 <lambdabot> Unknown command, try @list
02:34:01 <milfjord> what exactly do you mean by "work in sh"?
02:34:15 <milfjord> typing interactive commands, or writing batch scripts?
02:34:18 <antithesis> milfjord I write bash scripts
02:34:32 <Tijn> try HSH : http://hackage.haskell.org/package/HSH-2.0.3/docs/HSH.html
02:34:49 <Tijn> or shelly http://www.yesodweb.com/blog/2012/03/shelly-for-shell-scripts
02:36:20 <antithesis> Okay, if I want to do, say, echo "$@" | sed 's/a/b/'
02:36:33 <antithesis> But it absolutely needs to call the programs echo and sed
02:36:50 <antithesis> What's the Haskell equivalent for that? Does that require shell interaction?
02:37:16 <milfjord> I don't think you understand the problem you're trying to solve
02:37:32 <ivanm> antithesis: first of all, is there any particular reason for going out to the shell or another command rather than using a Haskell library for it?
02:37:41 <Tijn> hmm, what do you want? do you want to script the shell? Or do you want shell like commands in Haskell without calling the shell?
02:40:06 <antithesis> ivanm those were just common examples for convenience. I could've said "okular $@".
02:40:21 <ivanm> well, you can run external commands, that's not a problem
02:40:31 <ivanm> and it's possible to get input from them as well
02:40:38 <milfjord> if it's just that, I'd keep the shell script
02:40:44 <ivanm> note that it's not really in-built shell commands then
02:40:45 <milfjord> it doesn't get much easier than that
02:41:04 <ivanm> but yes, if it's something simple you can do with bash, etc. then there might not be a need for a full-fledged programming language
02:41:38 <antithesis> Yeah, I feel inclined to stick with bash for that reason, but I want to learn something new
02:41:44 <bjorkintosh> do it!
02:42:18 <antithesis> But that's why I'm asking if things like that aren't too hard
02:43:09 <bjorkintosh> you can watch people smoke the good stuff and ask them how it feels, or you can smoke it yourself and know it deep in your bones.
02:43:19 <bjorkintosh> it may or may not be hard, depending on your skill level.
02:43:39 <antithesis> So Haskell _is_ for potheads
02:43:40 <bjorkintosh> what would it cost you to find out?
02:43:42 <antithesis> Now I know
02:43:48 <antithesis> time
02:43:52 <bjorkintosh> potheads? i never mentioned anything.
02:44:32 <bjorkintosh> it's mainly for craced kheads.... people with cracks large enough in their heads to understand how it all works :)
03:14:33 <skypers> is there a structure with keys/values without the Ord constraint?
03:14:47 <ivanm> skypers: unordered-containers?
03:14:50 <ivanm> a hash table?
03:14:50 <skypers> like [(a,b)], but with nice insert / lookup?
03:15:02 <ivanm> you need _some_ constraint to get nice insert/lookup
03:15:14 <skypers> hm
03:15:23 <ivanm> AFAIK, for arbitrary key types, you currently need either Ord or Hashable
03:15:30 <skypers> yeah
03:15:38 <skypers> I link String to monadic actions
03:15:39 <skypers> like
03:15:46 <skypers> [(m (),String)]
03:16:01 <skypers> I think m () is neither in Ord nor Hashable :D
03:16:05 <ivanm> ummmmm.... I don't think that'll work...
03:16:18 <ivanm> you can't even use [(a,b)] for that!
03:16:25 <skypers> ?
03:16:28 <skypers> yes I can
03:16:31 <skypers> why wouldn’t i?
03:16:44 <Axman6> skypers: is the key the m () or the String?
03:16:52 <skypers> m ()
03:16:57 <Axman6> ...
03:17:00 <Axman6> how does that even work
03:17:06 <Axman6> the results would all be the same
03:17:14 <skypers> Axman6: ?
03:17:18 <kfish> Axman6, m is for magic
03:17:31 <Axman6> I mean, it sort of kinda makes some sense when m is [] or Maybe
03:17:34 <kototama> what does {..] mean in "fromValue st@PState{..} = go ...." ?
03:17:39 <skypers> it’s a monadic action, in my case it’s not really m, but a monad like IO
03:17:52 <milfjord> so how are you going to compare actions for equality?
03:17:59 <ClaudiusMaximus> kototama: record wildcards language extensions i think
03:18:00 <kfish> kototama, RecordWildCards
03:18:07 <Axman6> skypers: how on earth do you look up something based on an IO ()? o.O
03:18:17 <skypers> I don’t plan to lookup
03:18:24 <skypers> I just want to associate values to IO
03:18:35 <Axman6> what exactly are you trying to do, because it sounds completely bonkers
03:18:50 <kfish> skypers, if you never look up the value, you can make a very efficient hashtable with no constraints
03:18:52 <skypers> the type would be [(IO (),[String])] actually
03:19:08 <milfjord> skypers: if you don't want lookup, what do you mean by "key"?
03:19:13 <ivanm> skypers: what do you want to do with that?
03:19:15 <ivanm> just run them all?
03:19:31 <ivanm> if so, then why not use [(IO (), [String])] ?
03:19:31 <skypers> not really
03:19:39 <aristid> skypers: why do you need nice insert/lookup when you don't want to lookup?
03:19:42 <ClaudiusMaximus> kototama: http://www.haskell.org/ghc/docs/latest/html/users_guide/syntax-extns.html#record-wildcards
03:19:52 <skypers> woh
03:19:56 <ivanm> skypers: association lists have the _best_ insert!
03:19:57 <skypers> too much questions
03:20:01 <skypers> bufferoverflow.
03:20:06 <ivanm> (:) is O(1) !!!
03:20:12 <skypers> yeah, I may need that
03:20:18 <ivanm> methinks this might be an X-Y problem
03:20:18 <skypers> I’m still digging my problem
03:20:51 <aristid> ivanm: (:) wow much fast
03:20:55 <kototama> ClaudiusMaximus: thank you
03:22:28 <aristid> skypers: i think there is no buffer overflow with the questions because they all boil down to "wtf do you actually want to do" :P
03:23:40 <skypers> aristid: I don’t even know
03:23:45 <skypers> I’ll refactor my problem
03:23:51 <skypers> it’s bull***** now
03:27:07 <quchen> Bullshit, it's spelled bullshit. We're adults here.
03:27:31 <no-n> i'm 12
03:27:54 <aristid> yeah i was gonna say there's probably no lack of children here
03:28:24 <quchen> Then maybe don't use words like bullshit and hide behind asterisks to get a silly "I didn't really say it" cop-out.
03:28:33 <aristid> which is good, the more young Haskell learners the better:)
03:28:37 <quchen> Yes!
03:28:58 <milfjord> that's just b*llshit
03:29:34 <quchen> Maybe those young Haskellers spend all their time with FP, and when they're 22 and have to learn Python they join other channels and complain how incomprehensible the concept of a loop is.
03:29:53 <aristid> i don't think children need to be protected from very common swearwords such as "bullshit" though
03:30:34 <ion> Children need to be protected from Haskell
03:30:54 <aristid> ion: why?: D
03:31:22 <ion> aristid: Dunno, i was trying to make the conversation on-topic again.
03:31:49 <Axman6> because ->'s are sharp and can take out chindren's eyes
03:32:02 <Axman6> and they might run with lenses
03:32:41 <quchen> Hm. Well, here's something on-topic. The other day me and my friend were looking for a fast algorithm to count the number of distinct elements in a container (list/vector/...) of Int.
03:32:45 <aristid> and i guess there's always the risk of accidentally unsafePerformingIO
03:33:09 <aristid> quchen: just sorting is not good enough i guess?:D
03:33:12 <quchen> The Ints are consecutively from 0 to N, where N is known.
03:33:30 <pjdelport> consecutively?
03:33:34 <quchen> aristid: It turned out that sorting was indeed the bottleneck.
03:33:35 <aristid> quchen: but there are gaps?
03:33:43 <pjdelport> or just bounded by that range?
03:34:06 <quchen> aristid: Maybe. The point is the numbers in the list aren't absurdly high, think of automatically generated database ID entries.
03:34:42 <quchen> So one algorithm you could use would be to maintain a database of a long chain of bits, i.e. a Vector Bool.
03:35:08 <quchen> Whenever you encounter a certain entry, you set the bit at that position in the Vector to 1.
03:35:12 <aristid> Vector Bool is bitpacked? didn't know that
03:35:18 <quchen> No idea.
03:35:25 <quchen> Do it for every entry, count the 1s in the Vector, that's your result.
03:35:25 <Axman6> it's not afaik
03:35:35 <quchen> However, that requires mutability. Is there a way to do it without?
03:35:37 <Axman6> yeah that makes sense
03:35:42 <aristid> edwardk made a bitpacked Vector Bit for succinct tho
03:35:57 <aristid> quchen: dunno i don't see much wrong with using ST for this
03:35:59 <quchen> You can write it as a fold with xors.
03:36:01 <Axman6> you could use the popCnt primites to make that even faster btw
03:36:05 <quchen> But then you have a lot of copying.
03:36:35 <quchen> aristid: Right, ST would work in practice, but we were wondering about a nifty smart functional solution.
03:36:37 <Axman6> kfish: #haskell.au is missing you, you should come join the party (which is very unparty like on a sunday night)
03:37:22 <ClaudiusMaximus> @hackage bitwise -- i made a bitpacked array thing once, though i haven't touched it for ages
03:37:22 <lambdabot> http://hackage.haskell.org/package/bitwise -- i made a bitpacked array thing once, though i haven't touched it for ages
03:37:36 <nadirs> Hello. I'm playing around with Scotty + Aeson and can't get a json response working: http://lpaste.net/100604
03:38:00 * Axman6 -> sleep
03:38:03 <nadirs> I'm following Data.Aeson.TH example (http://hackage.haskell.org/package/aeson-0.6.2.1/docs/Data-Aeson-TH.html)
03:38:23 <quchen> The thing is when you have  a `or` (b `or` (c `or` 0))), each parenthesis copies the entire database (what I called the Vector Bool earlier).
03:38:53 <quchen> So the question is really whether all these or-s can be unified into one big thing without the necessity of copying all the time.
03:39:05 <aristid> quchen: you could make a tree of small bitwise thingies i guess?
03:39:08 <Axman6> well, the obvious solution really is ST
03:39:24 <Axman6> everything else will be n log n
03:40:00 <Axman6> you could totally use an Integer actually...
03:40:10 <Axman6> that way you don't even need to know N
03:40:12 <quchen> Sure.
03:40:18 <pjdelport> quchen: Couldn't you something like Vector's accum?
03:40:35 <aristid> Axman6: Integer is actually suited for that?
03:40:52 <Axman6> db' = db `or` (1 `shiftL` n)
03:41:05 <aristid> that does not copy?
03:41:10 <Axman6> nah it will
03:41:24 <Axman6> but... it's a fun use of Integer =)
03:41:27 <quchen> pjdelport: Hmm, right, Vector has functions like that. I wonder whether that uses ST internally, let me check
03:41:28 <aristid> :)
03:41:37 <Axman6> quchen: yeah it definitely does
03:43:06 <quchen> Axman6: Confirmed
03:43:18 <quchen> Well hidden behind layers and layers of stream fusion though
03:45:58 <quchen> Vector is quite a beast now that I look at it.
04:15:40 <greg`> is liftIO in Prelude?
04:16:06 <Reite> pretty sure its not
04:16:16 <greg`> ha , ok thanks
04:18:09 <Reite> http://hackage.haskell.org/package/base-4.6.0.1/docs/Prelude.html
04:19:48 <quchen> liftIO isn't even in Base I think
04:22:01 <bennofs> it's in transformers, in Control.Monad.IO.Class
04:25:24 <zcd> hi, is there a way to make this function fit inside another function:
04:25:26 <zcd> packer :: (Eq a) => a -> [[a]] -> [[a]]
04:25:28 <zcd> packer x [] = [[x]]
04:25:30 <zcd> packer x acc
04:25:32 <zcd>     | (head $ head acc) == x = (x:head acc) : tail acc
04:25:34 <zcd>     | otherwise = [x] : acc
04:25:53 <zcd> i tried lambda but they don't agree with guards
04:26:35 <artyomkazak> er, replace guards with “if”?
04:29:44 <jesyspa> Why would you want to?  That function has no free variables (except head, tail and (:), if you call them such, and you may want to reduce that to only (:), anyway).
04:30:11 <jesyspa> (I suppose you might then also call ($) and (==) free variables...)
04:30:27 <zcd> i want to fit it inside a fold neatly, but that's not necessary
04:31:04 <davorak_> zcd: You can use either `let` or `where`  I would recommend wher ein this case.
04:33:03 <zcd> using where, would i need a nested if to handle the multiple definitions?
04:33:58 <davorak_> zcd: Pretty sure you can use a guard.
04:34:02 <artyomkazak> you can declare functions in “where” just like you can declare them globally – with multiple clauses, type signatures, guards, etc.
04:34:04 <davorak_> Try and find out
04:36:19 <zcd> got it
04:36:21 <zcd> thanks!
04:36:37 <zcd> is it considered bad style to nest functions like this though?
04:37:17 <bennofs> zcd: isn't your function just "group" from Data.List?
04:37:40 <bennofs> ah no, sorry
04:37:56 <zcd> it could be, but i'm just trying to get some practice with the language
04:38:53 <quchen> I suggest rewriting the function so that it doesn't use head/tail at all.
04:39:05 <bennofs> zcd: Note that your function crashes when you feed it [[]] for acc
04:39:13 <quchen> Or [[x]].
04:39:25 <quchen> Oh, nevermind, not that.
04:39:29 <quchen> Anyway, head/tail are bad.
04:41:07 <zcd> bennofs: i think it's fine in this case, since the acc is explicitly []
04:41:29 <zcd> quchen: what's the reason behind avoiding head/tail ?
04:42:03 <bennofs> zcd: that the compiler can warn you if you forget a case (like my [[]])
04:42:04 <quchen> They crash on empty lists, and in most cases you're better off with pattern matching.
04:42:14 <bennofs> zcd: if you use pattern matching
04:42:44 <greg`> hi can anyone tell me why i get the following error
04:42:54 <greg`> http://lpaste.net/100609
04:43:10 <greg`> its a cabal thing it seems
04:43:23 <greg`> im trying to use cabal sandbox
04:44:17 <bennofs> greg`: try cabal clean and make sure that the dist directory doesn't exists afterwards and then try to configure & build again
04:44:27 <greg`> thanks bennofs
04:44:45 <zcd> i will try to rewrite into pattern match then
04:45:17 <dart> hi
04:45:54 <dart> has anyone any experience with shenlanguage ? what are your thoughts ?
04:49:18 <zcd> okay, i it to pack :: (Eq a) => [a] -> [[a]]
04:49:20 <zcd> pack = foldr packer []
04:49:22 <zcd>     where packer x [] = [[x]]
04:49:24 <zcd>           packer x ((y:ys):zs)
04:49:26 <zcd>             | y == x = (x:y:ys):zs
04:49:28 <zcd>             | otherwise = [x] : ((y:ys):zs)
04:49:30 <zcd> which looks nicer, but is there a way around the parentheses?
04:51:42 <ClaudiusMaximus> zcd: you could use an as-pattern ys'@(y:ys) to avoid the repetition of (y:ys) in the body of the guards
04:52:35 <ClaudiusMaximus> zcd: or even ys@(y:_) as you don't need the ys without the y: in front of it
04:53:31 <zcd> oh that's nifty
04:55:06 <johtso> hmm, if I have a method that takes a Char, and depending on the Char converts it into a data type, is there a nice way to namespace it inside the definition of of the datatype?
04:56:45 <johtso> or will I just have to have a separate fromChar function? .. what happens if I have a second data type that also needs a fromChar?
04:58:02 <ClaudiusMaximus> johtso: putting them in their own module is the standard way to namespace things, using qualified imports (like  import qualified Foo(fromChar) as F  then using  F.fromChar 'x'
04:58:25 <johtso> Ah, okay
04:59:03 <johtso> but that would mean a separate module per data type I suppose
05:00:22 <ClaudiusMaximus> johtso: yeah...  an alternative might be to define a typeclass like  class FromCharable t where fromChar :: Char -> t  and making instances for each type, but i'd only recommend that if there were more operations related by laws
05:03:21 <johtso> ah, I'll have a play around with type classes, haven't used them yet
05:06:32 <waldkauts> i have a happstack-lite app and i'm generating blaze html in my request handler. there i'm also generating links, but i want these links to keep "current" request parameters
05:06:51 <waldkauts> but i want to avoid passing them through all the rendering functions
05:07:37 <waldkauts> is there a way to have some kind of context-aware link creation?
05:08:37 <ClaudiusMaximus> waldkauts: sounds like an application for MonadReader (i have no clue about happstack or blaze html though to know if it's practical)
05:09:24 <waldkauts> thx for the hint ClaudiusMaximus, i'll see if its applicable for my purpose
05:09:24 <H1FuelCell> hello gentlemen
05:09:28 <H1FuelCell> why does [1,2]!!1 work, but not 1:2:[]!!0
05:09:37 <zygentoma> how do I tell ghc(i) that my tab with is 4 spaces?
05:09:43 <H1FuelCell> something to do with lazy evaluation?
05:09:45 <bennofs> zygentoma: use spaces :)
05:10:13 <H1FuelCell> but by the point the interpreter reaches !! it should already have built a list
05:10:24 <zygentoma> H1FuelCell: operator precedence?
05:10:28 <ClaudiusMaximus> H1FuelCell: my guess is operator precedence (use :info in ghci to see)
05:10:39 <H1FuelCell> ah
05:11:59 <H1FuelCell> (!!) :: [a] -> Int -> a 	-- Defined in `GHC.List'
05:12:08 <H1FuelCell> data [] a = ... | a : [a] 	-- Defined in `GHC.Types'
05:12:19 <H1FuelCell> infixr 5 :
05:12:31 <H1FuelCell> ... no info about the precedence from :info
05:13:00 <ClaudiusMaximus> then !! has no explicit precedence defined, so it takes the default precedence which should be mentioned in the Report and i forgot what it is
05:13:17 <H1FuelCell> searching on hoogle for : did not yield the result for : either...
05:13:45 <H1FuelCell> :+, :-> etc came up but not the plain :, any idea why?
05:13:46 <ClaudiusMaximus> infixr 5 is the fixity of (:), the 5 is the precedence level
05:13:50 <ivanm> zygentoma: you can't; the report states that on *nix tab = 8 spaces, on windows tab = 4 spaces
05:14:43 <ivanm> I get the fixity for `:' by doing `:info (:)' (which comes up with what you put above)
05:15:08 <johtso> ClaudiusMaximus, hmm, so if I have two data types that are instances of the same type class, and they both expose the same function with overlapping patterns, how does it know which one I'm referring to when I call the function?
05:15:38 <ClaudiusMaximus> johtso: the context of the caller
05:15:43 <zygentoma> ivanm: what really, not even configureable? o.o
05:15:47 <ivanm> zygentoma: nope
05:15:52 <ClaudiusMaximus> H1FuelCell: http://www.haskell.org/onlinereport/decls.html#fixity
05:15:53 <ivanm> which is why you shouldn't use tabs in Haskell code
05:16:02 <zygentoma> i see …
05:16:03 <H1FuelCell> ivanm: searching for infixr on hoogle worked, thanks
05:16:15 <ivanm> and why we keep yelling at our students every year about it, then gleefully mark them down when they do :p
05:16:36 <Cale> ivanm: what? I thought it said 8 spaces everywhere
05:16:39 <ivanm> H1FuelCell: that wasn't my recommendation...
05:16:43 <Cale> Well, align to 8 space multiples
05:16:46 <ivanm> Cale: pretty sure it's 4 spaces on windows
05:16:47 <bjorkintosh> you can use 'tabs' as long as it converts to spaces.
05:16:52 <ivanm> @where report
05:16:52 <lambdabot> http://www.haskell.org/onlinereport/haskell2010/ (more: http://www.haskell.org/haskellwiki/Definition)
05:17:05 <H1FuelCell> yeah, turns out infixr is not the word for :, which I presumed, sorry
05:18:07 <Cale> The “indentation” of a lexeme is the column number of the first character of that lexeme; the indentation of a line is the indentation of its leftmost lexeme. To determine the column number, assume a fixed-width font with the following conventions:
05:18:07 <Cale> The characters newline, return, linefeed, and formfeed, all start a new line.
05:18:07 <Cale> The first column is designated column 1, not 0.
05:18:07 <Cale> Tab stops are 8 characters apart.
05:18:08 <Cale> A tab character causes the insertion of enough spaces to align the current position with the next tab stop.
05:18:37 <osa1> any ideas what term manipulation C library is used to do that https://github.com/diml/utop ? I need something similar. I'm currently using ncurses but it captures the whole terminal screen, so user can't scroll etc. also, it's hard to get input from user in ncurses ..
05:18:44 <johtso> ClaudiusMaximus, aha, so if the type signature of the caller expects it to produce a certain type, the function defined in type's instance is used?
05:18:55 <johtso> *in that type's
05:19:00 <ivanm> Cale: where's that?
05:19:39 <Cale> http://www.haskell.org/onlinereport/haskell2010/haskellch10.html
05:19:49 <Cale> in 10.3
05:20:01 <ClaudiusMaximus> > (maxBound :: Int, maxBound :: Word8) -- johtso ,  yes like this, but in "real" code the context usually is not so ambiguous that it needs type annotations
05:20:01 <ivanm> well, my mistake then...
05:20:03 <lambdabot>  (9223372036854775807,255)
05:20:19 <johtso> ClaudiusMaximus, magic :)
05:20:34 <Cale> But yeah, I personally think that tab characters should just be lexical errors when encountered, the same way that vertical tabs presently are.
05:20:50 <ivanm> though I'm sure I've seen errors in the past due to tabs not aligning from windows to *nix...
05:21:21 <ivanm> and Haskell98 says the same, so it's not something that has been changed since
05:21:26 <ivanm> unless GHC did something fancy...
05:23:11 <bxc_> oh noes a tab thread
05:23:14 <ivanm> maybe I was just conflating what various windows editors defined a tab as... *shrug*
05:23:28 <ClaudiusMaximus> johtso: btw, you might want   fromChar :: Char -> Maybe t  in case you get an unexpected character
05:28:08 <bjorkintosh> so there's really no tool to correctly 'spacify' a haskell script?
05:28:14 <bjorkintosh> removing needless tabs?
05:28:21 <bjorkintosh> aligning what needs to be aligned, in one go?
05:28:30 <bjorkintosh> so that this becomes a non issue?
05:32:11 <Cale> bjorkintosh: Well, most text editors can expand tabs to spaces automatically
05:32:32 <bxc_> bjorkintosh: respacing source code is an issue in itself.
05:33:21 <Cale> You do have to be a bit careful to begin with, because the alignment of lines can change the meaning of code. (Not just prevent it from compiling)
05:33:41 <bjorkintosh> ugh.
05:34:26 <bjorkintosh> when a misplaced comma or misaligned tab is no longer relevant, useful things might happen.
05:34:31 <bxc_> its because haskell is insufficiently c-like.
05:34:45 <bjorkintosh> right. it's sufficiently haskell-like.
05:35:00 <bjorkintosh> but, all the bright minds haven't been able to make that problem go away?
05:35:29 <bxc_> bjorkintosh: maybe its also an issue in python.
05:35:31 <Cale> bjorkintosh: Well, the solution is just not to have any tab characters in your source code in the first place
05:35:55 <bjorkintosh> bxc_, not at all :)
05:35:59 <bjorkintosh> python, is beautiful.
05:36:24 <aristid> bjorkintosh: chrisdone's structured haskell mode for emacs does fully automatic indentation, although i guess that's not exactly what you want
05:36:44 <nadirs> anyone here using Web.Scotty?
05:36:44 <bjorkintosh> aristid, that might work very well, in fact.
05:37:31 <bxc_> bjorkintosh: but changing indent changes the meaning of programs?
05:37:52 <bjorkintosh> bxc_, it simply won't work!
05:38:03 <bjorkintosh> an error is immediately reported.
05:38:20 <bjorkintosh> and it's always obvious what's wrong at a glance.
05:38:28 <Rylee> in what cases is whitespace significant in haskell?
05:38:31 * bxc_ calls troll and goes back to cooking.
05:38:45 <aristid> Rylee: do blocks, where declarations..
05:38:53 <aristid> case of
05:38:58 <bjorkintosh> hehehe.
05:39:01 <sipa> whitespace is not significant as such
05:39:05 <sipa> indentation is
05:39:26 <aristid> indentation is whitespace, so whitespace is significant, just not all whitespace is.
05:39:28 <bxc_> while we're at it, lets argue about what bi-weekly means.
05:39:40 <bjorkintosh> twice a week :D
05:39:49 <bjorkintosh> bi for dos, week for week.
05:39:57 <Cale> sipa: also, you can have things like   foo x y z = do blah
05:40:29 <Cale> sipa: every piece of whitespace on that line is now significant, because it determines the column in which the following line should start in order to be part of the do-block
05:40:38 <sipa> ca
05:40:43 <sipa> Cale: true
05:41:35 <sipa> i just meant that whitespace itself is only significant in so far that it affects indentation (and as you point out, also alignment with other lines)
05:49:59 <nadirs> I have a function `f :: (Foo a) => a -> Bar` and a `data D = D Text Text deriving (Show, Generic)` (with `-XDeriveGeneric`), I have an `instance Foo D`. Nonetheless `f (D "abc" xyz")` finds "No instance for Foo D arising from a use of f"
05:50:03 <nadirs> (I also use -XOverloadedStrings)
05:50:47 <nadirs> can anyone  spot what am I missing?
05:51:44 <prophile> nadirs: can you provide a test case file?
05:51:51 <Cale> nadirs: Are you sure you really have that instance?
05:52:49 <nadirs> prophile, Cale: http://lpaste.net/100604
05:54:08 <milfjord> version issues?
05:54:35 <nadirs> Cale: maybe there are several ToJSON classes around
05:55:30 <nadirs> milfjord: might be, `ghc-pkg aeson` finds "aeson-0.6.2.1" and "aeson-0.7.0.0"
05:55:46 <nadirs> * I mean `ghc-pkg list aeson`
05:57:15 <nadirs> but if I removing one version would break scotty, while removing the other would break several other packages
05:57:24 <nadirs> maybe I should start using something like hsenv?
06:03:41 <Cale> nadirs: Yeah, that tends to be a good idea. You could even perhaps try cabal's new sandboxing
06:04:14 <nadirs> Cale: do you prefer the latter?
06:04:31 <Cale> Well, you probably already have cabal-install :)
06:04:42 <nadirs> definitely :)
06:04:59 <Cale> I think it should probably become the standard way, though I haven't actually used cabal-install's sandboxing yet myself
06:05:13 <Cale> I've used cabal-dev in the past which worked reasonably well.
06:06:22 <nadirs> I'll look into both `cabal sandbox` and cabal-dev. Thank you!
06:43:56 <haskell_newb> hello
06:44:49 <haskell_newb> is there a way to do efficient functional programming in haskell? i'm concerning about huge data structures coping when you need to modify one tiny bit of it
06:44:55 <haskell_newb> how can it be work arounded
06:45:29 <Maior> haskell_newb: cow efficiency is a fairly mature field
06:45:56 <haskell_newb> Maior: cow?
06:46:02 <prophile> copy-on-write
06:46:03 <Maior> haskell_newb: copy-on-write
06:46:29 <haskell_newb> does it mean that ghc should optimize such things to simple assignment?
06:46:36 <Saizan> haskell_newb: when you update a tiny bit most often the rest can be shared rather than copied, immutability helps
06:46:57 <haskell_newb> Saizan: thats great
06:47:32 <Saizan> so e.g. if you change a leaf of a tree, you only create new nodes along the path to that leaf, the rest is shared with what you had before
06:48:42 <Saizan> immutable arrays get copied though, because they are a single chunk of memory, it can still be efficient for bulk operations though
06:49:09 <haskell_newb> Saizan: but on haskell side i need to reconstruct whole tree with my tiny change, so ghc sees that and shares old tree with new tree?
06:49:13 <Saizan> (there are also libs for mutable arrays though)
06:50:05 <Saizan> haskell_newb: yeah, it's not even an optimization, it just follows from how constructors are implemented
06:50:50 <Saizan> well, it's not like your haskell code is going to recurse over the whole tree if it just has to reach a particular leaf
06:51:53 <haskell_newb> Saizan: for retrieval - yes, but for change tree reconstruction is needed on haskell side
06:52:29 <Saizan> haskell_newb: a simple example: leftmostToZero (Leaf _) = Leaf 0; leftmostToZero (Branch l x r) = Branch (leftmostToZero l) x r;
06:52:57 <Saizan> haskell_newb: the right branch 'r' doesn't get recursed over, it's just passed to the new Branch constructor
06:53:39 <haskell_newb> Saizan: gotcha
06:56:33 <haskell_newb> is it possible to make typeclass of records? for example i want [Foo] where Foo may be any records with field fooBar
06:57:22 <c_wraith> Are you coming from an OO language?
06:58:16 <Maior> so I don't suppose anyone's seen some odd `int foo()` weirdness like https://gist.github.com/doismellburning/9307715 have they?
06:58:28 <Maior> I've got so very little to go on...
06:59:10 <haskell_newb> c_wraith: i guess
06:59:30 <c_wraith> haskell_newb: well, the big thing to realize is that type classes are entirely unlike OO classes.
06:59:45 <c_wraith> haskell_newb: they don't do the same thing, nor do they solve the same problem.
07:00:07 <sipa> also, type classes are not types
07:00:08 <Cale> If you want to relate them to something on the OO side of things, they're a bit closer to Java's interfaces
07:00:13 <Maior> they're a bit like OO inter...that
07:00:15 <Cale> (only a good deal more general)
07:00:31 <geekosaur> Maior: the surprising thing to me there is it shows on a terminal; configure uses something like that to probe the C compiler, but it should be sending output to config.log
07:00:41 <c_wraith> They don't really work like interfaces, either.  Interfaces are still nominal subtyping.
07:00:51 <haskell_newb> Cale: Yeah, so i want interface to certain set of record types
07:01:01 <haskell_newb> not sure how that related to OO but still
07:01:08 <spacekitteh> how can i view the kind of some piece of data in ghci?
07:01:15 <Maior> geekosaur: I thought it might be something like that; I'm trying to avoid "read the source" a bit...
07:01:19 <ZWJ> type :k
07:01:26 <ZWJ> spacekitteh,
07:01:33 <geekosaur> but if it's actual data its kind is *
07:01:36 <ZWJ> :k Dataconstructor
07:01:37 <lambdabot>     Not in scope: type constructor or class `Dataconstructor'
07:01:48 <milfjord> ZWJ: data constructors don't have kinds
07:01:49 <spacekitteh> ah ok thanks ZWJ
07:01:54 <Cale> haskell_newb: Well, it doesn't matter that they happen to be record types
07:02:12 <Cale> haskell_newb: You can define a type class and make your types instances of it
07:02:49 <ZWJ> sorry, is :k Typeconstructor right?
07:03:03 <spacekitteh> ZWJ,milfjord: Oh. Because I'm trying to derive Data,Typeable on a data constructor with type parameters and yeah
07:03:31 <c_wraith> haskell_newb: the big thing is that haskell doesn't have subtyping.  There is no common supertype of two different types - you can't put them in a list together.  You need to approach the problem differently.
07:03:31 <haskell_newb> Cale: Ah, indeed data FooLike = {} derives (Foo)
07:03:47 <Cale> haskell_newb: what?
07:04:16 <Cale> haskell_newb: I mean like   class Foo where ... some operations ...   instance Foo MyRecordType where ... definitions of those operations ...
07:04:39 <haasn> c_wraith: I still wonder how close you could get to actual subtyping by using subclasses + existentials
07:04:46 <haskell_newb> Cale: yeah, i meant the same
07:04:53 <haasn> and perhaps Typeable for casting to a subtype
07:05:03 <sipa> haskell_newb: that line defines a type FooLike (with no records), and hope the compiler knows how to make it an instance of Foo
07:05:21 <c_wraith> haasn: I was intentionally ignoring existential hacks, because they encourage people to do the wrong thing before they know anybetter.
07:05:27 <haasn> fair enough
07:05:28 <Cale> deriving generally won't work with your own classes, unless you're doing it for a newtype and using the GeneralisedNewtypeDeriving extension
07:05:34 <haasn> I wouldn't really use it either, it's just a thought experiment
07:05:36 <sipa> haskell_newb: typically, if you feel the need to call something Foo and FooLike, my guess is that you want Foo to be the type and FooLike the class
07:05:44 <haasn> GeneralizedNewtypeBreakage
07:05:53 <sipa> haskell_newb: types belong to classes, not the other way around
07:08:19 <haskell_newb> okay, lput aside Foo stuff, why there is no way to do [Eq]? It feel completely typesafe
07:08:35 <c_wraith> haskell_newb: Eq isn't a type
07:09:01 <nadirs> Cale: an hour later everything works fine! I use cabal sandboxes following this guide: http://coldwa.st/e/blog/2013-08-20-Cabal-sandbox.html
07:09:03 <haskell_newb> c_wraith: it feels like shortcoming
07:09:03 <nadirs> :)
07:09:10 <c_wraith> haskell_newb: no, it's a big win.
07:09:24 <c_wraith> haskell_newb: Eq is a big example why it's a big win, actually.
07:09:52 <c_wraith> haskell_newb: If you have two values, and all you know about them is that they're types that implement Eq, you can't compare them.
07:10:00 <nadirs> haskell_newb: I think you'd write `Eq a => [a]`
07:10:06 <Cale> nadirs: cool!
07:10:07 <c_wraith> haskell_newb: after all, you don't know if they're the same type or not
07:10:31 <c_wraith> haskell_newb: and the requirement of Eq is that to compare two values, they have to be the same type
07:10:33 <nadirs> Cale: ther's even a rosetta's stone for cabal-dev users
07:10:39 <nadirs> *there's
07:11:10 <haskell_newb> c_wraith: yeah, i see it now sine [1,True, "a"] :: Eq and comparing 1 and True makes little sense
07:11:11 <c_wraith> haskell_newb: if all you know about a value is that it's some type that's an instance of Eq, the only thing you can do with that knowledge is compare the value with itself.
07:11:27 <haskell_newb> > [1] :: Eq a => a
07:11:29 <lambdabot>  Could not deduce (a1 ~ [GHC.Integer.Type.Integer])
07:11:29 <lambdabot>  from the context (GHC.Classes.Eq a)
07:11:29 <lambdabot>    bound by the inferred type of it :: GHC.Classes.Eq a => a
07:11:29 <lambdabot>    at Top level
07:11:29 <lambdabot>  or from (GHC.Classes.Eq a1)
07:13:56 <haskell_newb> > [1] :: Eq a => [a]
07:13:58 <lambdabot>  Could not deduce (GHC.Num.Num a1) arising from the literal `1'
07:13:58 <lambdabot>  from the context (GHC.Classes.Eq a)
07:13:58 <lambdabot>    bound by the inferred type of it :: GHC.Classes.Eq a => [a]
07:13:58 <lambdabot>    at Top level
07:13:58 <lambdabot>  or from (GHC.Classes.Eq a1)
07:14:01 <haskell_newb> yeah
07:14:19 <c_wraith> haskell_newb: There's no subtyping.  [Int] is not a subtype of [a]
07:15:14 <c_wraith> haskell_newb: if you say an expression has the type [a], you are saying that "this expression is polymorphic list. It can have any contents you want"
07:15:20 <c_wraith> :t []
07:15:21 <lambdabot> [a]
07:15:31 <c_wraith> haskell_newb: the empty list *is* polymorphic
07:15:51 <haskell_newb> c_wraith: yeah, i got it thanks
07:17:59 <haskell_newb> i wonder what is a haskell way to create big record types with slight differences for example gamedev example record for human and robot both are having fields like health, speed, etc but also having slight differences
07:18:09 <haskell_newb> what is the haskell way to eliminate duplication?
07:18:13 <troydm> what's the name of the ghc flag that turns all strings in a file into bytestrings ?
07:18:25 <troydm> like automaticly does packing of strings
07:18:40 <haskell_newb> or it's okay to repeat these fields(health, speed, etc) in each record type with slight variations?
07:18:45 <haasn> in 2014 I would probably use a record like Specific { specificA, specificB :: T, common :: Common } with Common { commonA, commonB, commonC :: T }
07:19:08 <haasn> and I would use lens's mechanisms for creating classes to abstract over things that have a certain field
07:19:16 <haskell_newb> haasn: ah, so like in C composing 2 different structs?
07:19:25 <haasn> I guess so, yeah
07:19:39 <haskell_newb> haasn: https://stackoverflow.com/questions/1114349/struct-inheritance-in-c/1114362#1114362
07:20:07 <haasn> yes, sans the pointer tricks mentioned
07:20:28 <haskell_newb> haasn: yeah, i thought so too by myself but just wanted to check with community
07:20:38 <haasn> note: in Haskell, you can also extend existing records in the other direction, by providing alternatives: data Specific = Common Common | Specific Field1 Field2 ...
07:21:10 <haasn> but that isn't near the same thing
07:21:14 <haskell_newb> haskell_newb: alas, specific is not recrod type
07:21:47 <haasn> (you could make Specific a record constructor here but the fields would be unsafe unless you add them to Common as well)
07:22:18 <haasn> haskell doesn't have “record types”. Actually, maybe it does in GHC HEAD + various extensions?
07:22:20 <haskell_newb> i don't trust sum types in haskell since every time i need to extend it i need to fix every single pattern matching on it in my program unlike with records wildcards
07:22:50 <haskell_newb> haasn: by record types i mean data Record = Record {..}
07:22:54 <haasn> haskell_newb: I think that is pretty much a case of a feature, not a bug; if you add a new constructor then pattern matches are *forced* to be able to handle it as well, otherwise your program is unsafe
07:23:55 <haskell_newb> haasn: Yeah, that makes sense
07:24:00 <c_wraith> well.  Partial, not unsafe.  It will just crash, not corrupt memory. :)
07:24:06 <haasn> point taken :)
07:26:36 <hpc> some people say that partial functions are still unsafe
07:26:53 <hpc> because crashing is a side-effect
07:27:17 <Kaidelong> so I think I have an idea that might give a general and nice solution to the issue of the unsafePerformIO hack and also allow some things like logic programming
07:27:20 <prophile> not if you consider crashing the same as evaluating to _|_
07:28:11 <Kaidelong> and also make main a special case of a more general mechanism rather than truly magic
07:28:55 <Kaidelong> but I'm having some trouble working out the semantics
07:30:35 <nadirs> troydm: OverloadedStrings?
07:31:05 <troydm> nadirs: yeah thx, i've found it
07:31:10 <nadirs> troydm: what it does though is interpreting double-quoted strings as `IsString a` instances
07:31:15 <nadirs> I think
07:31:34 <haasn> prophile: exceptions can be caught in IO, evaluating _|_ not necessarily
07:31:42 <haasn> so there is somewhat of a distinction
07:31:45 <geekosaur> it wraps string literals in fromString the same way numeric literals are wrapped in fromIntegral or fromRational
07:32:02 <haasn> there's also a difference between an exception and the type of crash that unsafe* functions can produce
07:32:26 <haasn> unsafe* can circumvent the type system and the RTS itself, causing segfaults, corruption and other badness
07:32:37 <haasn> exceptions are within the intended semantics
07:32:44 <haasn> and can readily be caught from within IO
07:33:07 <haskell_newb> for example i have data Faction = Faction { factionMembers :: [FactionMember] } how should FactionMember be implemented if faction member can be either human or robot(different records)?
07:33:49 <geekosaur> easiest: data FactionMember = HumanMember AHuman | RobotMember ARobot
07:33:52 <prophile> haskell_newb: make FactionMember a sum type
07:33:55 <prophile> ^
07:34:16 <geekosaur> the way you want to do it doesn't work the way you'd like, OO is possible in Haskell but it's not the native idiom
07:34:33 <troydm> so i'm using import qualified Data.ByteString as B with parsec
07:34:33 <geekosaur> and you need to do a lot of work if you insist on using it
07:34:41 <haskell_newb> geekosaur: thanks!
07:34:41 <troydm> now i need to match characters
07:35:00 <troydm> what's the char datatype for a bs ?
07:35:06 <haskell_newb> geekosaur: so having sum type of member variants is a haskell way?
07:35:07 <haasn> troydm: Word8?
07:35:12 <geekosaur> it's a way
07:35:24 <haasn> sum types are definitely Haskell-y
07:35:37 <geekosaur> probably the most common, but we neeed to know a bit more about your intent to make better decisions about representation
07:35:57 <troydm> does OveriddeStrings converts 'a' into word8 characters?
07:36:06 <haasn> troydm: OverloadedStrings? no
07:36:27 <haasn> troydm: you also shouldn't use OverloadedStrings with ByteString if you can avoid it
07:36:30 <haasn> that instance is bad
07:36:45 <troydm> why?
07:36:56 <troydm> should i always manually pack them?
07:37:01 <prophile> the encoding is implicit presumably
07:37:39 <geekosaur> Haskell Char can hold more than 256 codepoints; they get truncated when converting to ByteString
07:37:50 <troydm> also are Word8 strings capable of storing unicode characters?
07:37:50 <haskell_newb> geekosaur: i'm just want to make game faction with members type which is as extensible as possible since it's not set in stone what faction member should be actually
07:38:13 <milfjord> troydm: I dislike your question because the answer is yes
07:38:32 <haasn> troydm: “should i always manually pack them” <- only if you avoid Data.ByteString.Char8
07:38:39 <haskell_newb> geekosaur: sum type feels okay but i'm not aware of other options for task
07:39:02 <troydm> haasn: what do you mean by avoid char8 ?
07:39:17 <haasn> haskell_newb: if you don't need to abstract over what things are but rather what you can do with them, you could also use a different approach eg. see http://lukepalmer.wordpress.com/2010/01/24/haskell-antipattern-existential-typeclass/
07:39:26 <geekosaur> Char8 pretends to use Haskell Char-s but lops their heads off (hence "Char8")
07:39:37 <geekosaur> this means potentially silent data corruption
07:39:40 <troydm> lops?
07:39:42 <haasn> troydm: .Char8 will corrupt any code point above 255
07:39:45 <troydm> how?
07:39:52 <troydm> ohh ic
07:40:01 <haasn> > BSC.pack "Hello world ☃"
07:40:01 <troydm> yeah well i don't use .Char8
07:40:02 <lambdabot>  "Hello world \ETX"
07:40:07 <haasn> \ETX is not ☃ :(
07:40:13 <haskell_newb> haskell_newb: actually i want to abtract what things are since i don't know yet what they could be :)
07:40:19 <geekosaur> it looks at the bit representation but only pays attention to the bottom 8 bits, everything above is lost
07:40:22 <haasn> troydm: OverloadedStrings does the same when converting from string literals to ByteString, unfortunately
07:40:29 <geekosaur> no warning if the upper bits aren't 0
07:41:03 <troydm> geekosaur: ohh, ic, i thought it just substitutes "a" to (B.pack "a")
07:41:12 <milfjord> it does
07:41:14 <troydm> but i was wrong
07:41:16 <geekosaur> it does. but B.pack does not preserve data
07:41:32 <haasn> milfjord: geekosaur: it uses Data.ByteString.Char8.pack, not Data.ByteString.pack
07:41:44 <haasn> his ‘B’ was Data.ByteString, I think
07:41:49 <troydm> yeah
07:41:49 <milfjord> that would be a type error then
07:41:50 <haasn> important distinction. The latter does not type check
07:42:22 <haasn> troydm: as for what the correct way to do it is would depend on your semantic, there's no general answer because ByteString and String are inherently incompatible
07:43:02 <haasn> You'd probably want to use the “correct” encoding system to encode String as a ByteString, eg. ASCII (if you know errors are either impossible or you handle them correctly) or UTF-8
07:43:04 <Kaidelong> wait, the "IsString" instance for bytestring doesn't write out UTF-16?
07:43:16 <Kaidelong> that's not nice
07:43:21 <haasn> but we can't offer any better advice without more information
07:43:24 <geekosaur> haskell_newb, there is a difference in design philosophy here. it sounds good to leave things as open as possible, but when you do that you necessarily lose validation
07:43:25 <Kaidelong> I guess they wanted it to be ASCII to make it more like C?
07:43:31 <dmwit> Use Text for text...?
07:43:42 <milfjord> Kaidelong: UTF-16? that would be the real wtf
07:43:56 <dmwit> Kaidelong: I do not believe the goal was to be like C.
07:43:57 <Kaidelong> what did haskell use?
07:44:00 <companion_cube> WTF-16? that would be the real utf
07:44:12 <geekosaur> Kaidelong: ByteString is for data that is represented as octet strings. this means sockets and various POSIX strings
07:44:14 <haasn> Kaidelong: what do you mean?
07:44:19 <geekosaur> if you want textual data there is Data.Text
07:44:24 <Kaidelong> the default character encoding
07:44:30 <Kaidelong> I thought it was UTF-16 but I guess not
07:44:32 <milfjord> Kaidelong: what default character encoding?
07:44:34 <haasn> Kaidelong: there is no “default character encoding” in Haskell
07:44:52 <haasn> Kaidelong: unless you meant Char, which is a unicode code point
07:44:57 <geekosaur> (also ByteString includes POSIX filenames, and the oh so very common assumption that you can treat filenames as UTF8 is a fertile source of both bugs and security issues)
07:45:01 <Kaidelong> that's what I meant yet
07:45:03 <Kaidelong> yes
07:45:25 <dmwit> GHC uses UCS-32 for Char, but that's not a part of the spec.
07:45:39 <dmwit> There is no way to observe which encoding is used from within Haskell.
07:45:41 <geekosaur> o.O
07:45:48 <geekosaur> you meant UTF32?
07:45:54 <dmwit> I... maybe?
07:45:56 <Kaidelong> dmwit: the IsString instance for ByteStrings
07:45:56 <haasn> dmwit: does it really?
07:46:00 <dmwit> I often get those mixed up.
07:46:03 <geekosaur> the UCS version would be UCS4 but it was flawed and replaced by UTF32
07:46:06 <milfjord> it doesn't use any encoding
07:46:11 <milfjord> Char isn't a byte
07:46:21 <dmwit> What I mean is that it uses a full word, and represents the code point by its Int-like equivalent.
07:46:35 <dmwit> milfjord: That's silly. Of course it uses an encoding.
07:46:37 <haasn> (full words are also 64 bits on many platforms)
07:46:38 <milfjord> so ... it represents code points as code points
07:46:43 <Kaidelong> I figured it would reflect the fact that Char's are not single bytes, rather than truncating each char
07:46:56 <haskell_newb> geekosaur: sorry, what do you mean by loosing validation? does sum type for faction member looses it?
07:47:00 <haasn> Kaidelong: it's stupid.
07:47:15 <geekosaur> haskell_newb, if you don't know what you can have, you can't verify that you have something sensible
07:47:20 <haasn> I think it should produce an “error” for code points above 256 instead of silently truncating them
07:47:23 <geekosaur> this is not a Haskell thing, it's a design thing
07:47:24 <haasn> that would be less stupid than what it does currently
07:47:32 <haasn> above 255
07:47:42 <troydm> haasn: okey, now i have a straightforward problem
07:47:50 <cbm80> i have a program that works well with ghc 7.6.3, but goes completely bananas with 7.8-rc - where do i report that?
07:47:57 <haskell_newb> geekosaur: Yeah, you're right.
07:48:06 <geekosaur> there is an OO design methodology that says you design as "flexible" as possible, but that means all you can do if handed something unexpected is crash
07:48:07 <haasn> cbm80: ghc trac I suppose
07:48:14 <troydm> haasn: ahh nvm i've figured it out
07:48:18 <dmwit> Kaidelong: The IsString instance for ByteString is a bit dumb, yes.
07:48:30 <geekosaur> (well, throw an exception, but an unhgandled exception is a crash and how do you hndle the general case?)
07:48:37 <dmwit> Kaidelong: But ByteString isn't really intended for character strings anyway. It's intended for (shock of shocks) byte strings.
07:48:52 <haskell_newb> geekosaur: well, by using sum type i'm simple enumerating what is sensible
07:48:53 <cbm80> haasn: i'm not sure if its a program in the compiler or one of the libraries involved, so i dunno if trac is the right place
07:49:01 <cbm80> ** problem i mean
07:49:18 <Kaidelong> all data you work with in haskell fundamentally boils down to byte strings though, somehow
07:49:27 <geekosaur> Haskell errs in the other direction, it wants to know everything possible at compile time. there are ways to weaken this, but you still have this essential tradeoff that is more of a design issue than a language one
07:49:39 <Kaidelong> you'd think that they'd at least make the IsString instance an isomorphism
07:49:49 <geekosaur> and there are a lot of advantages to having the compiler help you make sure you didn't miss something
07:49:50 <dmwit> Well, that would be really hard.
07:49:57 <dmwit> I'm sure that's not really what you want.
07:49:59 <milfjord> Kaidelong: how would that even work?
07:50:12 <dmwit> Certainly at the very least none of the common encodings of Unicode are isomorphisms.
07:50:25 <haskell_newb> geekosaur: agreed, i think i'll go with sum types and ignore somthing weaker
07:50:48 <haskell_newb> geekosaur: what this "weaker" thing actually is? just out of curiousity
07:51:35 <Kaidelong> milfjord: the bytestring has the same representation as the string it is built from
07:51:48 <milfjord> strings don't have a binary representation
07:51:50 <Kaidelong> at least to the degree of the characters
07:51:58 <milfjord> also, that's not an isomorphism
07:52:03 <Kaidelong> milfjord: that sounds like a bug in the haskell standard
07:52:11 <milfjord> no, it's a feature
07:52:30 <dmwit> Kaidelong: What makes you think that all strings of bytes correspond to different, correct strings of characters?
07:52:39 <Kaidelong> then how do you serialize a string in such a way that differently-compiled haskell programs can deserialize it?
07:52:56 <milfjord> Kaidelong: by using UTF-8, for example
07:53:03 <dmwit> Kaidelong: Because that's really not true, and is part of the reason w ehave a type system.
07:53:17 <sipa> Kaidelong: serialization doesn't need to be "binary copying"
07:53:24 <milfjord> that's the entire point of UTFs
07:53:42 <sipa> internally, you represent characters any way you like, in a non-observable way
07:53:55 <sipa> only when serializing ("encoding") it, you get a well-defined byte array
07:54:41 <Kaidelong> that sounds like a way to just make the C++ nightmare of marshalling between character types invisible and hard to reason about
07:55:20 <milfjord> you've completely lost me
07:55:36 <sipa> from the point of Haskell the language, a String is just a list of Chars, and you don't get to see how those Chars are stored in memory
07:55:46 <troydm> so how do i convert [Char] to ByteString without loosing the data?
07:55:52 <milfjord> from the point of Haskell, there isn't even a memory
07:55:58 <Kaidelong> I guess something makes me really uncomfortable about that last bit
07:55:59 <troydm> .Char8 isn't the solution i presume
07:56:06 <milfjord> troydm: depends. which encoding do you want?
07:56:19 <troydm> milfjord: UTF-8
07:56:21 <milfjord> Kaidelong: are your bytes big endian or little endian?
07:56:36 <sipa> Kaidelong: C also doesn't expose what's inside a FILE structure
07:56:38 <geekosaur> Kaidelong, there comes a point where micromanaging your bits becomes way too much work for no gain or net loss
07:56:51 <milfjord> troydm: there's probably an encoding module
07:57:03 <milfjord> Kaidelong: and by that I mean the bits within a byte
07:57:15 <Kaidelong> geekosaur: but it lets you implement things like hash tables that work on arbitary things
07:57:52 <milfjord> Kaidelong: hash tables? I don't see how
07:57:59 <sipa> a hash table requires a mapping of the stored type to a hash
07:58:04 <c_wraith> troydm: the standard way to convert to UTF-8 is to go via Text.  convert the String into a Text value by using pack from text.  Then use Text's encodeUTF8 function to spit out a ByteString
07:58:05 <dmwit> troydm: Text has modules for converting to UTF8.
07:58:12 <dmwit> troydm: Or you could look at the encoding package.
07:58:13 <Kaidelong> milfjord: you iterate over the representation of the data to build your key
07:58:21 <Kaidelong> and then store the pointer to the hash
07:58:27 <milfjord> Kaidelong: in what language?
07:58:28 <sipa> Kaidelong: that assumes your representation is byte array
07:58:33 <dmwit> troydm: There's also http://hackage.haskell.org/package/iconv-0.4.1.2/docs/Codec-Text-IConv.html though I've never used it.
07:58:35 <milfjord> Kaidelong: because that doesn't even work in C
07:58:35 <Kaidelong> milfjord: C# works that way
07:58:40 <milfjord> hahaha, no
07:58:42 <Kaidelong> all objects have a method getHashCode
07:58:45 <milfjord> ...
07:59:01 <sipa> Kaidelong: voila, that's it... you need a getHashCode implementation
07:59:08 <milfjord> that's pretty much the opposite of a byte representation
07:59:15 <sipa> you don't need to know anything about the representation, as long as that hash code can be optained
07:59:45 <wereHamster> What's better, wrap StateT in an ErrorT or the other way around?
07:59:47 <Kaidelong> sipa: but in something like haskell you have to implement it yourself
07:59:47 <troydm> c_wraith: ic
07:59:48 <sipa> it's a strength that you're able to abstract the representation and the high-level functionality on top from eachother
08:00:01 <dmwit> In fact, I would argue that you don't *want* a bit representation if what you're really after is a hash code.
08:00:07 <sipa> Kaidelong: not more or less than in another language
08:00:19 <sipa> Kaidelong: the Map type requires the key to be Ord and Eq
08:00:25 <dmwit> Because for some reasonable data types, there are many correct bit representations of the same value -- so implementing hashing on top of that would be flat wrong.
08:00:25 <Kaidelong> http://msdn.microsoft.com/en-us/library/system.object.gethashcode(v=vs.110).aspx
08:00:31 <sipa> Kaidelong: and pretty much all types where that makes sense implement it
08:00:35 <Kaidelong> sipa: you inherit getHashCode from object
08:00:49 <Kaidelong> all objects inherit from object
08:00:58 <wereHamster>  see both being used in examples. Is there a distinct advantage of one over the other?
08:01:08 <dmwit> wereHamster: Neither is better. For each use case, one will be wrong. No guarantee the other will be right, though.
08:01:30 <dmwit> ?unmtl StateT s (ErrorT e) a
08:01:30 <lambdabot> s -> (ErrorT e) (a, s)
08:01:33 <dmwit> ugh
08:01:39 <dmwit> ?unmtl s -> ErrorT e (a, s)
08:01:39 <lambdabot> s -> ErrorT e (a, s)
08:01:44 <dmwit> uuuugh
08:01:49 <sipa> Kaidelong: great, go use C# :)
08:01:49 <dmwit> ?unmtl ErrorT e (a, s)
08:01:49 <lambdabot> Plugin `unmtl' failed with: `ErrorT e (a, s)' is not applied to enough arguments.
08:02:04 <dmwit> Oh, okay.
08:02:11 <dmwit> ?unmtl StateT s (ErrorT e m) a
08:02:12 <lambdabot> s -> (ErrorT e m) (a, s)
08:02:16 <dmwit> ...
08:02:23 <dmwit> ?unmtl ErrorT e m (a, s)
08:02:24 <lambdabot> m (Either e (a, s))
08:02:28 <Kaidelong> also javascript doesn't specify a bit representation but it has JSON
08:02:41 <Kaidelong> which is good enough
08:03:17 <milfjord> and also completely different
08:04:18 <Kaidelong> milfjord: it still provides something in the form "t -> Rep"
08:04:20 <dmwit> StateT s (ErrorT e m) a =~ s -> m (Either e (a, s))
08:04:21 <bennofs> You can also implement Serialize instances or ToJSON instances or Storable instances or whatever in haskell. You can even use TH to auto-generate most of them
08:04:35 <dmwit> ErrorT e (StateT s m) a =~ s -> m (Either e a, s)
08:04:42 <milfjord> Kaidelong: does Haskell: const ()
08:04:49 <Kaidelong> as opposed to something like "(Typeable t) => t -> Rep"
08:04:50 <milfjord> er, *so does Haskell
08:05:06 <dmwit> wereHamster: Does staring at those two rough type equalities help?
08:05:09 <Kaidelong> milfjord: () is not a good representation for haskell values
08:05:23 <milfjord> Kaidelong: JSON is not a good representation for javascript values
08:05:28 <troydm> so i want my data to be stored in a efficient way
08:05:31 <Kaidelong> but it is one
08:05:32 <troydm> text data
08:05:34 <troydm> i mean
08:05:39 <Kaidelong> at least there is one
08:05:42 <troydm> should i use ByteString or Text ?
08:05:52 <bennofs> Kaidelong: what is the problem with constraints like Serialize a => or ToJSON a => ?
08:06:04 <milfjord> Kaidelong: () is also a representation
08:06:08 <dmwit> wereHamster: The former says you can short-circuit earlier, but in case of an error you don't know what state you got. The second says you keep munging the state even after error conditions, but you get to find out what state you ended up at.
08:06:14 <dmwit> troydm: Use Text for text.
08:06:16 <milfjord> Kaidelong: it's even a perfect representation of ()
08:06:51 <Kaidelong> bennofs: because you can define values that, for the purposes of the type system, cannot be represented at all
08:06:58 <Kaidelong> which is just wrong, if they're non-bottoms
08:07:40 <wereHamster> dmwit: so if I want to be able to recover from errors, I need to use the second?
08:07:48 <dmwit> No?
08:07:53 <sipa> Kaidelong: there is no meaning in serializing a file handle
08:08:03 <Kaidelong> sipa: but it can be done, conceptually
08:08:06 <sipa> Kaidelong: as you can't deserialize it and expect any meaningful properties from it
08:08:13 <milfjord> I just tried it. JSON.stringify(alert) ==> undefined; JSON.stringify(document) ==> '{"location":{}}'; JSON.stringify(window) ==> _|_
08:08:18 <dmwit> Oh, maybe if "need to recover" means "need to recover and continue using the updated state". Then yes.
08:08:20 <sipa> Kaidelong: making it explicit which types make sense to be serialized or not is much cleaner
08:08:26 <dmwit> wereHamster: Sorry for not thinking before I answered.
08:08:40 <bennofs> Kaidelong: can you serialize a c function pointer?
08:08:46 <wereHamster> dmwit: no problem, I ask before thinkin :P
08:09:05 <k_89> hey can someone help me with this : http://lpaste.net/100614 ,
08:09:06 <sipa> can you serialize a Javascript function?
08:09:09 <Kaidelong> bennofs: sure, it may not be very useful when you run the program again, but a pointer is just an integer
08:09:19 <milfjord> Kaidelong: pointers are not integers
08:09:27 <Kaidelong> natural number
08:09:30 <Kaidelong> fine
08:09:30 <milfjord> no
08:09:33 <k_89> http://lpaste.net/100615 , another version
08:09:35 <milfjord> pointers are not numbers
08:09:36 <Kaidelong> it's a bunch of bits
08:09:39 <wereHamster> sipa: in JS? Yes, sortof
08:09:45 <sipa> i'm tired of this trolling :)
08:09:48 <bennofs> Kaidelong: You can also get the address of a haskell value (at least with GHC, iirc), which is an integer value. It's just not very useful
08:09:54 <geekosaur> k_89, your data constructors are Node and Empty, not Tree
08:09:58 <geekosaur> also you are missing parentheses
08:10:34 <geekosaur> also in your second one the parentheses in Node Tree (Tree) (Tree) do nothing
08:10:42 <k_89> yeah, i know that
08:11:19 <k_89> but if my data constructors are Node and empty, how do i check for the type "Tree"
08:12:10 <geekosaur> ? you can't have naything but a Tree there
08:12:49 <geekosaur> Haskell won't let you put an Int or something there, it has to be a Tree, so why do you need to check?
08:13:00 <milfjord> > () :: (a ~ ()) => a
08:13:01 <lambdabot>  ()
08:13:01 <geekosaur> the case on line 9 should be Node par left right
08:13:09 <k_89> oh
08:13:18 <Cale> k_89: This is a type of ternary trees, btw
08:13:36 <troydm> so i use Text.Parsec.Text package, is there a way to force many be of Parser Text type instead of Parser String ?
08:13:38 <Cale> (not binary)
08:13:45 <k_89> Cale, how ?
08:13:53 <k_89> oh
08:13:58 <k_89> Tree Tree Tree
08:14:00 <k_89> oh
08:14:03 <Cale> Your Node data constructor has three parameters of type Tree, right
08:14:07 <k_89> yeah
08:14:31 <Cale> Tree also is not a type class
08:14:38 <k_89> oh,
08:14:43 <Cale> It's just a type
08:14:45 <klrr_> > (\x y -> y) :: (a ~ b) => a -> b -> b
08:14:46 <lambdabot>  No instance for (Data.Typeable.Internal.Typeable b0)
08:14:46 <lambdabot>    arising from a use of `M573703798941385527631515.show_M5737037989413855276...
08:14:46 <lambdabot>  The type variable `b0' is ambiguous
08:14:46 <lambdabot>  Possible fix: add a type signature that fixes these type variable(s)
08:14:47 <lambdabot>  Note: there are several potential instances:
08:14:57 <Cale> (same goes for Int)
08:15:05 <Cale> So, you'd want something like   treeHeight :: Tree -> Int
08:15:11 <Kaidelong> bennofs: that might basically be the sort of last resort I was thinking of, if you can dereference it
08:15:24 <bennofs> Kaidelong: there is Foreign.StablePtr
08:15:24 <Kaidelong> I don't think the facilities are too useful but it seems strange that it should be impossible in principle
08:15:43 <k_89> Cale, how do I know when to do something like (Tree a, Int b) => a -> b and Tree -> Int
08:15:44 <k_89> ?
08:15:54 <milfjord> k_89: you use => with classes
08:16:00 <milfjord> Tree and Int aren't classes
08:16:00 <Cale> The things which show up on the left of => are type class constraints
08:16:08 <k_89> hmm
08:16:19 <Cale> They constrain which types the type variables can range over
08:16:19 <k_89> classes are not data types
08:16:22 <Kaidelong> "How are these data represented?" "You can't, in principle, know"
08:16:24 <k_89> okay
08:16:26 <Kaidelong> why not compromise somewhere?
08:16:31 <milfjord> Kaidelong: you can never know
08:16:40 <Cale> For example, consider  sort :: (Ord a) => [a] -> [a]
08:17:03 <Cale> This says that sort can sort a list of elements of any type which has an instance of Ord
08:17:15 <Cale> (i.e. for which <= and such are defined)
08:17:35 <dmwit> Kaidelong: Why compromise somewhere?
08:17:46 <dmwit> Kaidelong: However, I also have an actual answer to "why not compromise".
08:17:54 <milfjord> hmm, I'm kind of disappointed that (a () ~ [b]) is not a valid constraint
08:17:59 <Kaidelong> dmwit: to have some element of useful functionality if you really only know that you're taking a "t"
08:18:07 <Cale> sort :: [a] -> [a]  wouldn't work, because we wouldn't know how to compare the elements of an arbitrary type a (there are practically no operations which can be done to values of a completely arbitrary type)
08:18:07 <dmwit> Kaidelong: Which answer is: we would like, in principle, to have a semantics for Haskell that we can use for equational reasoning.
08:18:28 <dmwit> Kaidelong: As soon as you put a bit representation into the semantics, many, many important reasoning principles are lost.
08:18:42 <dmwit> Kaidelong: For example, parametricity is out.
08:18:45 <milfjord> Kaidelong: the useful functionality is that you can be sure that a polymorphic function won't look at your values
08:18:53 <dmwit> Kaidelong: And it has shown historically to be a very powerful principle.
08:19:05 <Kaidelong> milfjord: I can see how that might be useful
08:19:12 <milfjord> e.g. there aren't too many functions of the type (a, b) -> a
08:19:16 <Cale> k_89: Does that make sense?
08:19:19 <milfjord> if you ignore bottoms, there's exactly one
08:19:48 <k_89> Cale still reading, made the tree generic, so  it can store a value
08:19:54 <dmwit> milfjord: (a () ~ [b]) isn't valid?
08:20:00 <Kaidelong> if you're looking at equational reasoning from the perspective of reasoning by the programmer it doesn't seem like bit representations are that bad but I totally see how it could interfere with the machine using it
08:20:04 <milfjord> similarly, you know a function like length :: [a] -> Int will return the same result, regardless of the actual values in the list
08:20:07 <dmwit> :t let f :: a () ~ [b]; f = undefined in f
08:20:07 <lambdabot>     Predicate `a () ~ [b]' used as a type
08:20:08 <lambdabot>     In the type signature for `f': f :: a () ~ [b]
08:20:08 <lambdabot>     In the expression:
08:20:13 <Cale> k_89: Yeah, you might've wanted something like  data Tree a = Node a (Tree a) (Tree a) | Empty
08:20:17 <dmwit> :t let f :: a () ~ [b] => a b; f = undefined in f
08:20:17 <lambdabot> [()]
08:20:21 <k_89> Cale, yeah
08:20:23 <dmwit> milfjord: Looks valid to me.
08:20:36 <Kaidelong> milfjord: yes, I understand that. I wasn't thinking about that at the time.
08:20:39 <k_89> Cale, so typeclasses are like scala traits
08:20:41 <k_89> in a manner
08:20:49 <dmwit> Kaidelong: I as a programmer have used parametricity many times.
08:20:53 <Kaidelong> Now I see the point more
08:20:58 <k_89> ?
08:21:04 <Kaidelong> k_89: yes
08:21:07 <Cale> k_89: I think that's right.
08:21:07 <milfjord> > [] :: (a () ~ [b]) => a b
08:21:08 <lambdabot>  Could not deduce (a ~ [])
08:21:08 <lambdabot>  from the context (a () ~ [b])
08:21:08 <lambdabot>    bound by an expression type signature: a () ~ [b] => a b
08:21:08 <lambdabot>    at <interactive>:1:1-25
08:21:08 <lambdabot>    `a' is a rigid type variable bound by
08:21:16 <k_89> hmm, okay
08:21:29 <geekosaur> there are similarities
08:21:43 <Kaidelong> milfjord: you could still provide the functionality unsafely though
08:21:51 <geekosaur> taking those similarities too far can get you into trouble
08:22:07 <Kaidelong> "assume this isn't actually a feature, implement it anyway unsafely for people who end up in a situation where they're desparate enough to need it"
08:22:21 <dmwit> milfjord: investigating
08:22:26 <milfjord> Kaidelong: what functionality exactly?
08:22:43 <Kaidelong> inspecting representations of things at runtime
08:22:51 <milfjord> uh
08:22:54 <milfjord> we do that all the time
08:22:59 <milfjord> like, pattern matching
08:23:00 <troydm> so i use parsec with text to parse my data
08:23:06 <dmwit> Kaidelong: Yes, you can offer that functionality unsafely, and GHC does.
08:23:07 <troydm> i provide data as text data tye
08:23:11 <troydm> *type
08:23:26 <troydm> but all the operations in parsec return strings
08:23:27 <Kaidelong> dmwit: I guess that's good enough for me then
08:23:37 <troydm> so i'm jungling between String -
08:23:43 <troydm> to Text all the time
08:23:43 <dmwit> Kaidelong: You can even offer it safely, to an extent, by sticking everything in the sin bin (IO).
08:23:48 <troydm> is there a better way?
08:23:55 <dmwit> Kaidelong: ...which GHC does. ;-)
08:24:10 <dmwit> Kaidelong: But it's really, really uncommon to use it in actual code.
08:24:14 <Kaidelong> dmwit: and come to think of it, the only situations you'd actually need this would be when you're extending the functionality of GHC
08:24:17 <dmwit> Kaidelong: I think I've only ever seen it used for debugging.
08:24:24 <Kaidelong> so I guess it's a sensible place to put that functionality too
08:24:30 <Cale> k_89: So, they're kind of like Java interfaces, but note that  sort :: (Ord a) => [a] -> [a]  gives you somewhat more information than  sort :: [Ord] -> [Ord]  would
08:25:04 <Cale> k_89: In that it tells you that the type of elements in the input list is the same as the type of elements in the result.
08:25:13 <k_89> oh
08:25:16 <k_89> yeah
08:25:23 <dmwit> milfjord: Yeah, that's a bit strange. The only guess I can offer would be that it thinks 'a' may be from the syntactic class that includes type families...+
08:25:29 <dmwit> s/\+/?/
08:25:33 <k_89> thanks
08:25:57 <k_89> got it working !
08:26:04 <dmwit> milfjord: I'm not sure about that, though. It might be worth asking on glasgow-haskell-users@ or something similar.
08:26:08 <Cale> cool :)
08:26:11 <Maior> k_89: also you can't f/ex do "x :: [Eq]"
08:26:41 <k_89> ?
08:27:54 <Maior> if I have a Java interface Foo, I can do `List<Foo> x`
08:28:16 <Maior> if I have a typeclass like Ord, I can't do `x :: [Ord]
08:28:32 <k_89> oh, okay
08:29:21 <Cale> Maior: Right, the [Ord] -> [Ord] syntax that I gave was pseudocode :)
08:29:22 <Maior> (I _can_ do `x :: [Ord a]` but that's stricter
08:29:43 <Maior> Cale: my bad sorry
08:30:06 <Cale> Well, it's good that you clarified that, I could have been clearer to begin with :)
08:30:27 <cbm80> i filed a bug report: https://ghc.haskell.org/trac/ghc/ticket/8835
08:30:39 <Cale> You could imagine allowing the name of a type class to be used as a type and introducing new type variables for each one, but that would result in [Ord] -> [Ord] meaning  (Ord a, Ord b) => [a] -> [b], which is different.
08:31:48 <Cale> cbm80: Interesting catch
08:32:06 <cbm80> Cale: i have no idea whats causing that
08:32:33 <milfjord> Ord ==> (exists a. Ord a => a)
08:33:43 <Maior> Cale: I assumed that was the case
08:34:02 <haasn> milfjord: exists a. Ord a *> a
08:34:07 <Maior> (i.e. I could write `x :: Ord -> Ord` which was equivalent to `x :: Ord a -> Ord b`)
08:34:55 <benmachine> Maior: note that Ord a isn't a type
08:35:10 <Maior> benmachine: I know
08:35:19 <milfjord> Maior: you can't do x :: [Ord a]
08:35:24 <benmachine> right
08:35:25 <haasn> classes are not to be confused with constraints, and constraints are not to be confused with types; although all three live in the type system
08:35:48 <Maior> > let x = [] :: [Ord a]
08:35:49 <lambdabot>  not an expression: `let x = [] :: [Ord a]'
08:36:09 <Maior> er, ghci seems happy with above
08:36:17 <geekosaur> lambdabot is not ghci
08:36:21 <geekosaur> let ... in
08:36:30 <Maior> fair; cheers
08:36:42 <milfjord> Maior: my ghci isn't
08:36:53 <haasn> my GHCi, I wonder why
08:36:59 <haasn> that seems like a kind error to me
08:37:08 <Maior> Prelude> :t y
08:37:09 <Maior> y :: [Ord a]
08:37:48 <k_89> wow .. even a data type is a function
08:37:59 <haasn> is there more than one definition of Ord?
08:38:13 <benmachine> Maior: would you mind dropping your whole ghci session on lpaste.net? 'cause I have no idea what you are doing :P
08:38:15 <haasn> no, otherwise it would be an ambiguous name. Huh?
08:38:29 <Taneb> haasn, :k y?
08:38:32 <milfjord> I'm on 7.6, though
08:38:49 <haasn> It “works” for me in 7.6 and it doesn't work in 7.8 (kind error, as expected)
08:38:51 <Maior> benmachine: http://lpaste.net/100619
08:39:00 <Maior> haasn: that'd do it
08:39:06 <benmachine> oh, bizarre
08:39:11 <haasn> Taneb: ‘y’ is not a type
08:39:31 <benmachine> Maior: 7.4.2 rejects it as well
08:39:38 <haasn> λ :k forall a. [Ord a]
08:39:40 <haasn> forall a. [Ord a] :: *
08:39:42 <milfjord> 7.6.1 rejects it
08:39:42 <haasn> huh?
08:39:52 <haasn> 7.6.2 here
08:40:06 <benmachine> yep, only 7.6.2 accepts it
08:40:10 <benmachine> I wonder what it thinks it is doing
08:40:31 <Taneb> A list of constraints'd be my guess
08:40:37 <tmhedberg> Does it have to do with ConstraintKinds (i.e. Ord :: * -> Constraint)?
08:40:39 <haasn> works with stock 7.6.2 and no .ghci file and no extensions, for me. Just “:t [] :: [Ord a]” (or any other class I've tried)
08:40:47 <benmachine> tmhedberg: maybe
08:40:48 <haasn> tmhedberg: doubtful, that would be kind error
08:41:02 <benmachine> haasn: I claim it /should/ be a kind error, and 7.6.2 is just being odd
08:41:17 <benmachine> haha, okay
08:41:19 <haasn> tmhedberg: unless [] is poly-kinded, which it can't be; I think it might have to do with some sort of leakage of internal representations of type classes?
08:41:21 <benmachine> let x = [] :: [a ~ b]
08:41:24 <benmachine> also works
08:41:32 <benmachine> anyone wants to try to explain that one, you're welcome to
08:41:49 <milfjord> aliens.jpg
08:41:56 <Maior> what's ~ ?
08:42:03 <milfjord> =
08:42:03 <benmachine> Maior: type equality constraint
08:42:48 <benmachine> Maior: they're only of use when you're using certain extensions, like type families
08:43:05 <benmachine> or else if you're edwardk
08:43:05 * hackagebot electrum-mnemonic 0.1.1 - easy to remember mnemonic for a high-entropy value  http://hackage.haskell.org/package/electrum-mnemonic-0.1.1 (JoeyHess)
08:43:07 * hackagebot assert-failure 0.1.1.0 - Syntactic sugar improving 'assert' and 'error'  http://hackage.haskell.org/package/assert-failure-0.1.1.0 (MikolajKonarski)
08:43:11 <benmachine> although admittedly the two tend to go together
08:43:38 <bennofs> benmachine: instance Num (Int ~ Int) also works! :p
08:44:00 <benmachine> bennofs: tres bizarre
08:44:02 <k_89> how'd you define a simple Graph data type ? I am thinking of this, data Graph a = Node a [Graph a]  | Empty
08:44:14 <bennofs> benmachine: Now I can even write let x = [x] :: [Int ~ Int] ... I only need a show instance :p
08:44:23 <bennofs> s/[x]/[1]/
08:45:24 <benmachine> Maior: in conclusion, what you said is possible, but only on one specific GHC version, and only because it is on crack
08:45:33 <Maior> funsies
08:46:23 <milfjord> the important question is, is instance Num (a ~ b) valid? and does it allow [1] :: [Int ~ Int]?
08:46:26 <benmachine> I don't think the "type" Ord a has any inhabitants
08:46:44 <benmachine> milfjord: not sure how you would implement the methods
08:46:50 <triliyn> a ~ b is a constraint, not a type
08:46:50 <milfjord> don't have to
08:46:56 <milfjord> triliyn: o rly
08:47:06 <benmachine> triliyn: we know, but GHC 7.6.2 seems to get this wrong
08:47:06 <triliyn> Yeah
08:47:09 <triliyn> oh
08:47:15 <triliyn> Okay then
08:47:18 <triliyn> How strange
08:47:20 <bennofs> wtf, you can even do instance Num (Ord Int) haha
08:47:21 <benmachine> I know, right?
08:47:38 <milfjord> go for broke, instance Num (Num a)
08:47:49 <bennofs> instance Num (Num (Num (Num (Num a))))
08:48:30 <benmachine> seems like the kind checker is just flat-out broken
08:48:32 <benmachine> oh well
08:48:40 <benmachine> probably doesn't lead to any inconsistenc
08:49:32 <bennofs> benmachine: try instance Eq (Eq a) where a == b = a == b. The error you get is confusing :p
08:50:42 <benmachine> bennofs: ...
08:50:46 * benmachine scratches head
08:50:59 <bennofs> and instance Eq (Eq a) where (==) = True typechecks ...
08:51:06 <bennofs> this is broken
08:51:07 <benmachine> woah what the fuck
08:51:11 <benmachine> I just did the same thing
08:51:23 <hpc> that's beautiful
08:52:02 <bennofs> ([undefined] :: [Eq a]) == [undefined]  -- True
08:52:23 <benmachine> bennofs: ...
08:52:38 <bennofs> hey, it works in lambdabot
08:52:48 <benmachine> conjecture: this is something to do with dictionary arguments
08:52:50 <bennofs> > ([undefined] :: [Eq a]) == [undefined]
08:52:53 <lambdabot>  True
08:53:26 <bennofs> I wonder if you can get it to get the "real" (==) out of the dictionary
08:53:35 <bennofs> That would be fun
08:54:59 <t7> wut
08:55:10 <t7> how on earth does that work
08:56:16 <benmachine> we're not sure, it's fair to say
08:56:37 <Cale> t7: It's not supposed to work, so who knows? :)
08:56:50 <Cale> Probably SPJ would know if he was the one to fix the bug (which is likely)
08:57:09 <haskell_newb> it doesn't work in ghci 7.6.3
08:57:15 <haskell_newb> porbably lambdabot bug
08:57:24 <bennofs> haskell_newb: I'm using ghci 7.6.3
08:57:25 <benmachine> oh, I didn't even know there was a 7.6.3
08:57:26 <hpc> ?ghc-ver
08:57:26 <lambdabot> Unknown command, try @list
08:57:27 <benmachine> must have skipped that one
08:57:30 <Cale> lambdabot just uses ghc
08:57:37 <Cale> So, it's a GHC bug
08:57:41 <bennofs> haskell_newb: ghci --version                                                                                                                                              17:55
08:57:43 <bennofs> The Glorious Glasgow Haskell Compilation System, version 7.6.3
08:58:09 <haskell_newb> http://lpaste.net/100620
08:58:38 <bennofs> haskell_newb: you need to write instance Eq (Eq a) where (==) = True      before that line
08:58:48 <bennofs> haskell_newb: I did this in lambdabot via private msg :)
08:59:05 <haskell_newb> bennofs: yeah, it works now
09:48:12 * hackagebot jsc 0.1.1.1 - High level interface for webkit-javascriptcore  http://hackage.haskell.org/package/jsc-0.1.1.1 (HamishMackenzie)
09:53:13 * hackagebot anansi 0.4.7 - Simple literate programming preprocessor  http://hackage.haskell.org/package/anansi-0.4.7 (JohnMillikin)
10:02:49 <k_89> can someone help me out with this : http://lpaste.net/100621 ?
10:03:07 <benmachine> k_89: Real isn't a type
10:03:15 <Iceland_jack> @kind Real
10:03:16 <lambdabot> * -> Constraint
10:03:17 <benmachine> k_89: do you want Rational or maybe Double?
10:03:37 <k_89> benmachine, i was looking at thes
10:03:38 <k_89> http://hackage.haskell.org/package/base-4.6.0.1/docs/Prelude.html#t:Real
10:03:45 <benmachine> k_89: ah, that's a type class
10:03:55 <Iceland_jack> k_89: Real is a type class, not a type
10:04:04 <k_89> oh, so "class" can't be used in defintions
10:04:10 <benmachine> so you'd want something like data Point a = Point { x, y :: a }
10:04:16 <k_89> type can be
10:04:46 <k_89> benmachine, no, i guess, Point {x :: Double, y :: Double} would do
10:04:47 <k_89> thanks
10:04:57 <benmachine> yeah, fair enough
10:05:21 <k_89> so only "type" and "data" can be used to in function definitions ?
10:07:28 <benmachine> k_89: classes can be used, you just use them in a different way
10:08:11 <benmachine> e.g. blah :: (Real a) => a -> a means "a function that takes an a and returns an a, where a is an instance of Real"
10:08:32 <k_89> benmachine, so can i understand it like with classes, i need to give space for the actual "type" or "data" which includes that class and is to be used by this function
10:08:33 <k_89> ?
10:08:54 <benmachine> k_89: I don't follow exactly
10:08:56 <enemy> WHY DONT YOU USE STANDARD ML INSTEAD
10:09:16 <benmachine> k_89: the way I think about it is, you have some type, in this case a -> a, and it has some constraints attached
10:09:30 <benmachine> k_89: in this case those constraints say "this a must be Real"
10:09:42 <k_89> like (Real a) ... i need to provide that "a" in the definition, which would be filled up by the compiler with a particular "data" or "type" which includes Real
10:09:43 <k_89> ?
10:10:00 <k_89> enemy, who was that for ?
10:10:10 <fizruk> hello! I have a question regarding comonads. The general question is when should I use one? The more specific question concerns working with a set of (moving) points each interacting with its closest neighbours.
10:10:14 <enemy> everyone!
10:10:44 <benmachine> k_89: well, when you use that function, a might become Integer or Float or something
10:10:51 <benmachine> so yeah, in that sense
10:10:53 <k_89> yeah
10:10:56 <k_89> cool
10:11:07 <benmachine> but the definition says "I work with all a, as long as it's Real"
10:11:21 <k_89> this "class" thing is probably the most confusing thing about haskell till now
10:11:28 <benmachine> yep
10:11:36 <benmachine> that's normal, type classes take some getting used to
10:11:45 <benmachine> but they're one of the things that really make Haskell special
10:11:47 <fizruk> is anyone interested in explaining these command things to me? or at least could someone direct me to something close to my case?
10:11:51 <k_89> everything else just "fits", and that "class" thing is confusing, only because class is used for something else altogether in other langs
10:11:53 <fizruk> s/command/comonad/
10:12:48 <benmachine> fizruk: there are a few good articles, I can find them for you but I've never really used comonads so I don't promise they'll help
10:12:56 <Saizan> fizruk: you could look at the cellular automata blog post from sigfpe
10:13:12 <fizruk> Saizan: yeah, I've seen that one
10:13:21 <monochrom> yeah, I don't read too much into names. C++ "functor" is unrelated to Haskell "functor".
10:13:31 <benmachine> oh, that was what I was just about to link you to :P
10:13:45 <benmachine> monochrom: and ML functors are another thing again
10:13:48 <fizruk> my problem is my points are not fixed (they move)
10:13:49 <benmachine> although more closely related than those
10:15:01 <monochrom> the other day in #haskell.tw (Taiwan) we observed that Haskell is easier to learn for us English-as-second-language people because we cannot presume what the keywords mean
10:15:03 <fizruk> Saizan: at least I can't apply the same reasoning to my case
10:15:16 <benmachine> see also comonads are objects: http://www.haskellforall.com/2013/02/you-could-have-invented-comonads.html and comonads are not objects: http://gelisam.blogspot.ca/2013/07/comonads-are-neighbourhoods-not-objects.html
10:15:54 <fizruk> benmachine: yeah, seen those two also, doesn't help
10:16:05 <benmachine> fizruk: oh, well, I'm out then :P
10:17:03 <fizruk> perhaps, comonads can't solve my problem. but how do I know that for sure?
10:17:17 <benmachine> that sounds like a pretty deep question
10:17:40 <benmachine> not sure it's amenable to being answered
10:19:19 <fizruk> should I try to explain my problem in more detail here?
10:19:53 <monochrom> either deep question or undefined question
10:20:16 <Diskord> i'm having an issue using the haskell packages when attempting to install xmonad... is that a question I could get help for here?
10:21:02 <prophile> Diskord: just ask, if we can't help or don't know we'll say then
10:22:29 <benmachine> fizruk: it doesn't sound like there are any comonad experts around right now, so I'd try stackoverflow, reddit, or just working things out yourself :)
10:23:35 <fizruk> benmachine: okay, I'll dig a bit more myself then. thanks for response :)
10:23:37 <Diskord> error: failed to prepare transaction (could not satisfy dependencies)
10:23:38 <Diskord> :: haskell-regex-base: requires haskell-mtl=2.1.2-27
10:23:52 <Diskord> i have the package installed, but it still comes up with this
10:31:57 <Kaidelong> Diskord:" you have the package installed, or that exact version?
10:32:14 <Kaidelong> note that cabal is looking for haskell-mtl=2.1.2-27
10:32:21 <Kaidelong> you might have gotten yourself into cabal hell
10:33:04 <Diskord> Kaidelong: the #xmonad chat has pointed out i missed out the change in package necessary with using the archhaskell repo's
10:33:58 <Diskord> thanks though
10:34:00 <Kaidelong> if you're just using xmonad you should see if you can get a packaged version of it, rather than using cabal, honestly
10:34:12 <Diskord> it's not cabal i'm using, it's pacman
10:34:15 <Kaidelong> unless you're using cabal to build it off of SVN or something
10:37:08 <dhrosa> what's wrong with xmonad on cabal?
10:37:32 <Earnestly> ^
10:37:42 <hcalves> hi everyone. Im learning Haskell, but found www.learnyouahaskell.com is not enough to start hacking. anyone knows good resources with examples of *real* Haskell applications (e.g., how to deal with I/O, lazy I/O, pipes... String vs. Bytestring mess, etc)?
10:38:02 <c_wraith> dhrosa: nothing.  The recommendation was "if you're not going to be developing haskell software, just get it from your package manager"
10:38:04 <klrr_> hcalves: http://en.wikibooks.org/wiki/Write_Yourself_a_Scheme_in_48_Hours
10:38:30 <hcalves> klrr_: thx that sounds a little better
10:39:17 <klrr_> hcalves: i suggest going through LYAH though, it will help out with the functional thinking
10:39:21 <hcalves> any other codebases I should look at that don't revolve around academia? XMonad is quite opaque to me as I don't know anything about X11
10:39:34 <Earnestly> There is always rwh
10:39:35 <hcalves> (I got recommendations to read XMonad)
10:39:36 <klrr_> acedmia?
10:39:58 <klrr_> hcalves: hmm
10:39:59 <steamboat> hcalves: have you checked out http://book.realworldhaskell.org/
10:40:14 <c_wraith> real world haskell really needs a second edition
10:40:20 <hcalves> steamboat: that sounds good I'll take a look at this
10:40:30 <c_wraith> The state of the haskell universe has changed immensely since it was written - mostly because of it.
10:40:34 <Earnestly> I liked craft
10:40:45 <t4nk265> hi, is there something equivalent to http://hackage.haskell.org/package/shaker which is currently maintained? i.e., a tool which allows you to continuously build on save
10:40:46 <hcaulfield57> Okay, I feel like I understand monads a lot better (read: *think*), but I still can't program anything practical haha
10:40:51 <klrr_> hcalves: this is really easy to unserstand https://github.com/switchface/helm , before you read nay haskell code though you need to know some stuff about monads
10:41:29 <klrr_> well, really easy just depends how much experience, but after you grasp basics of haskell it wont be hard, it doesnt use anything too advanced
10:43:00 <bernalex> are there any guides to uhm writing a "main loop"? like gloss has
10:43:17 <hcalves> I'm comfortable with LISP so I understand the underpinnings of FP (HOF, immutability), also hacked with Hope and Haskell enough to understand how algebraic types work... the problem Im having writing anything useful in Haskell is dealing with some idiosyncrasies. For instance, what's the idiom for dealing with I/O? What's up with the proliferation of String types in the the stdlib? Etc.
10:43:32 <t4nk265> i'm coming to haskell from scala, and one of the things that i particularly enjoy about sbt is its ability to compile/test on source code change (which allows me to code iteratively, as i am guided by compiler messaged). is there a haskell equivalent?
10:43:51 <bernalex> t4nk265: uhm just use ghc-mod plug-in for your editor?
10:44:32 <t4nk265> bernalex: thanks, will look into it
10:44:50 <klrr_> hcalves: there's several
10:45:07 <klrr_> hcalves: i personally suggest pipes, but io-streams might be better to start out with
10:45:33 <bernalex> t4nk265: I use it in vim with syntastic. basically you get a bunch of errors/warnings, including type errors. compared to C++, I hardly ever actually compile anything. and when I do, it just compiles and works because I've taken care of the errors long since, with the assistance of ghc-mod.
10:45:46 <benmachine> I personally think the standard library treatment of IO is fine for a lot of applications
10:45:49 <hcalves> klrr_: yeah, so... tutorials so far don't cover idiomatic Haskell. it looks like Haskell has so far accumulated multiple modules for doing almost anything
10:46:05 <hcalves> klrr_: even for regex I didn't found a unique solution
10:46:20 <benmachine> bernalex: I didn't know there was a ghc-mod vim syntastic thing, point me at it?
10:46:34 <benmachine> hcalves: haskellers don't even like regex that much, if it helps :P
10:46:40 <klrr_> hcalves: well, i can tell some stuff
10:46:49 <bernalex> http://lpaste.net/8874075334652198912 I'm wondering: how on earth do I structure this to be able to read a file on start (getText per now is just hard coded to a file), and then change it when the user clicks File -> Open and selects a new file
10:47:02 <bernalex> I'm completely at a loss because of my haskell newbieness here. unchartered territory for me.
10:47:22 <klrr_> hcalves: one rule is to use Text for anything that use strings a lot, since its more effecient
10:47:29 <bernalex> benmachine: I don't really remember as it's such a long time since I set it up, heh. but http://www.mew.org/~kazu/proj/ghc-mod/en/ should be it.
10:47:41 <klrr_> hcalves: another is to never user Writer monad, since its very inefficent
10:47:42 <benmachine> bernalex: noted, thanks
10:47:54 <klrr_> hcalves: you should emulate it with a restricted state monad instead
10:48:27 <t4nk265> bernalex: yes, it seems to do what i want. and luckily for me i've found a recent blog which guides you to setting up a haskell dev environment for emacs. thanks for pointing me in the right direction, appreciated
10:48:30 <bernalex> benmachine: let me know when you are setting it up if you have any trouble. maybe I can be of help. I have a few things in .vimrc for haskell stuff that might be relevant.
10:48:45 <bernalex> t4nk265: also look into haskell-mode
10:48:46 <klrr_> hcalves: also, for anything IO related that's not super trivial you should probably use pipes/condiut/io-streams, it shouldnt matter which just that you dont use lazy IO since it have some pit falls
10:48:50 <benmachine> bernalex: I'm not gonna do it now, just going to write it down as "this would be cool to look at when I have time"
10:48:55 <benmachine> bernalex: maybe some time in 2016 :P
10:49:04 <bernalex> benmachine: yes and I'm saying I'll be there for you come 2016. ;-)
10:49:10 <benmachine> thanks :)
10:49:12 <bernalex> t4nk265: http://www.haskell.org/haskellwiki/Emacs
10:50:03 <klrr_> hcalves: for anything related to events like games or interactive systems you should probably use FRP, i suggest reactive-banana cause i prefer classical FRP (ses an applicative interface) over arrowized (using a Arrow interface, i dont even know what a arrow is tbh)
10:50:15 <bernalex> there should be a channel more suited for hand-holding of bigger projects. #haskell works better for small, easily identified and solved bugs. =/
10:50:29 <bernalex> or, rather, I should have AFK friends that actually know haskell lol
10:50:30 <t4nk265> bernalex: gotcha
10:50:47 <Saizan> bernalex: you could try the mailing list
10:50:52 <klrr_> hcalves: also, one tips for learning monads that was useful for me was to not care about them, just fpocus on how to use the common ones before reading the more in-depth tutorials on them
10:50:56 <bernalex> t4nk265: good luck! AFAIK, emacs is even better for haskell than vim is. :-)
10:51:31 <klrr_> hcalves: also ignore all jargon, if something is called a strange name is not equal difficult concept
10:51:33 <bernalex> Saizan: hm. I guess it might be an option. but the mailing list has so many clever people with clever problems, it seems almost offensive to come around with my "uhm howto basic haskell??", heh.
10:51:52 <hcaulfield57> Like take a look at this monstrocity -> http://lpaste.net/100628
10:52:07 <c_wraith> I hate that hlint suggestion
10:52:20 <c_wraith> I think case on a bool often makes more sense than if
10:52:28 <bernalex> hcalves: klrr_: I didn't catch the entire conversation: but don't care about monads. just ignore them. then whoopsie daisy, suddenly you've written a few programs and understood monads all by yourself, and find yourself giving haskell lectures. ;-)
10:52:29 <t4nk265> bernalex: like for most things other than opening large files? ;P
10:52:43 <klrr_> bernalex: i said exactly that :P
10:53:12 <bernalex> klrr_: good. :-)
10:55:40 <hcalves> klrr_: yeah... I still have no idea what monad *means*, and none of the articles on it helped, because it's so abstract... I did understood how the IO monad works though
10:55:48 <hcalves> but then I saw all the other ways of dealing with IO and got lost
10:56:00 <bernalex> hcalves: ignore all the articles
10:56:07 <monochrom> the best way to learn programming is by using experiments and observations to form and refute hypotheses. not by reading more philosophical essays.
10:56:11 <bernalex> hcalves: the "monad tutorial" trap is best avoided. :-)
10:56:20 <klrr_> hcalves: you dont need to write idomatic code when starting out
10:56:23 <czro_> Are there any benefits to using ST instead of IO besides being able to escape from ST?
10:56:35 <klrr_> i recommend the scheme tutorial i linked eariler :)
10:56:39 <bernalex> monochrom: until you get good at it. then wadler's paper on monadic i/o is a must! hehe
10:57:16 <monochrom> wadler's monad tutorial is a lot of experiments, observations, and forming and refuting hypotheses. not philosophical at all.
10:57:45 <bernalex> I guess. :-)
10:58:05 <benmachine> bernalex: there's always haskell-beginners
10:58:35 <bernalex> benmachine: where? you mean it's a chan?
10:58:39 <monochrom> even Moggi's paper, that is a lot of math, which is very abstract forming and refuting hypotheses rather than philosophy.
10:58:57 <benmachine> bernalex: sec
10:59:53 <benmachine> bernalex: http://www.haskell.org/mailman/listinfo/beginners
11:00:04 <bernalex> benmachine: right. thanks.
11:01:23 <klrr_> hcalves: also, dont forget to use hoogle http://www.haskell.org/hoogle/, i use it all the time ( unless you want/can memorize everything)
11:01:59 <hcaulfield57> Is this terrible, or am I on the right path? http://lpaste.net/100628
11:02:22 <t4nk265> monochrom: could you link to wadler's tutorial in question?
11:02:30 <hcalves> klrr_: yeah I got a nifty app called "Dash" for looking up the documentation, it has been helpful to search by type signature
11:02:40 <klrr_> hcalves: what do you want to accomplish?
11:02:59 <monochrom> http://homepages.inf.ed.ac.uk/wadler/topics/monads.html#marktoberdorf "monads for functional programming"
11:03:00 <klrr_> hcalves: ubuntu dash?
11:03:00 <hcalves> klrr_: I'm trying to write a simple server / client
11:03:07 <klrr_> aa okey
11:03:07 <t4nk265> monochrom: thanks
11:03:07 <hcalves> klrr_: no, it's a mac app
11:03:16 <klrr_> aa
11:03:21 * hackagebot alsa-mixer 0.2.0 - Bindings to the ALSA simple mixer API.  http://hackage.haskell.org/package/alsa-mixer-0.2.0 (ThomasTuegel)
11:03:41 <monochrom> hcaulfield57, it's good
11:04:08 <monochrom> but you may like to know about "readFile"
11:04:12 <klrr_> yup compiles for me too
11:04:12 <hcaulfield57> monochrom: Okay thanks, I'm learning obviously
11:04:22 <hcalves> klrr_: I've been search the API like that: http://www.haskell.org/hoogle/?hoogle=String+-%3E+ByteString
11:04:31 <hcalves> *searching
11:04:37 <hcaulfield57> Yea, readFile would simplify it.
11:04:38 <klrr_> hcalves: good :)
11:05:54 <hcalves> what's been throwing me off a little is how functions inside the stdlib deal with different sets of types
11:08:41 <hcalves> like String, Bytestring, Char8, Text... also, is it idiomatic to keep "casting" from one type to another (pack, unpack, show, etc.)? or is there a better way?
11:09:05 <c_wraith> hcalves: ByteString is fundamentally different from String and Text
11:09:33 <monochrom> Char8 was short-sighted. Char8 would make sense 40 years ago.
11:09:52 <c_wraith> monochrom: it's still convenient.  You just have to be not braindead to use it properly.
11:10:19 <monochrom> Char8 was also conceived when GHC itself could not decode UTF8
11:11:07 <monochrom> the logic was: since GHC was doing iso-latin-1 anyway, let's perpetual more entrenched iso-latin-1
11:11:10 <klrr_> hcalves: also, avoid partial functions (e.g. head, tail)
11:11:21 <monochrom> s/perpetual/perpetuate/
11:11:26 <c_wraith> monochrom: it's not even iso-latin-1, is it?
11:11:35 <monochrom> it is
11:11:47 <hcalves> from what I understood, Text is an efficient Unicode type, ByteString an efficient 8 bit, and String is just naive [Char]
11:11:49 <klrr_> hcalves: use pattern matching instead, like "foo (head:tail) = ..."
11:11:51 <hcalves> isnt it?
11:11:59 <monochrom> it is not iso-latin-15 (the one with the euro dollar sign), it's iso-latin-1
11:12:03 <klrr_> hcalves: that's correct
11:12:08 <c_wraith> iso-latin-1 is defined exactly as "unicode codepoints mode 256"?
11:12:14 <monochrom> yeah!
11:12:16 <c_wraith> *mod
11:12:43 <klrr_> hcalves: here's a legitimate use of String for example: http://hackage.haskell.org/package/attoparsec-0.10.4.0/docs/Data-Attoparsec-Text.html#v:notInClass
11:13:17 <c_wraith> hcalves: if you don't know the difference between a sequence of bytes and a sequence of characters..  It's really very fundamentally different.
11:13:22 <klrr_> hcalves: also, yes there is a way to avoid pack unpack , use {-# LANGUAGE OverloadedStrings #-}
11:13:38 <benmachine> c_wraith: I believe iso-latin-1 is a subset of that
11:13:58 <c_wraith> benmachine: yes.  a subset is not the whole set
11:14:09 <benmachine> it doesn't code anything between 128 and 159 inclusive
11:14:09 <monochrom> or rather, unicode was defined to extend iso-latin-1. after all, iso-latin-1 existed first.
11:14:22 <hcalves> klrr_: what is that, pragma?
11:14:29 <benmachine> right
11:15:08 <hcaulfield57> Is there a way I can test my understanding of Monads?
11:15:15 <klrr_> hcalves: it makes GHC infer anything inside double quotes, so you can write "foo = \"hahaha\"" so it becomes Text
11:15:46 <benmachine> hcaulfield57: can you implement them?
11:16:26 <benmachine> hcaulfield57: that is to say, write the Monad class, write all the standard instances and as many others as you know, write the implementations of Control.Monad stuff
11:16:36 <benmachine> might be an interesting exercise
11:16:44 <hcaulfield57> benmachine: I think so, I've went through Either,State,REader,Writer,Maybe, etc
11:16:48 <klrr_> or just implement monads with lambda expressions
11:17:10 <bernalex> http://lpaste.net/5746181752557142016 here I have implemented a file chooser dialogue. any ideas on how to restructure the program to let me change out the txt in main with the one I read inL
11:17:15 <monochrom> consider Cont :)
11:17:25 <bernalex> forgive the obtuse code -- I wil make it suck less once I get the functionality I want.
11:17:27 <hcalves> klrr_: so literals become Text? interesting thx
11:17:41 <benmachine> hcalves: well, they *can* become Text
11:17:48 <benmachine> hcalves: like numbers, they are typeclass-overloaded
11:18:09 <bernalex> what I really should do is make the program start with no file open. then when the user selects a file, open it and fire off the network.
11:19:19 <bernalex> so some magic needs to happen instead of "case file of Just fpath -> putStrLn ("You selected: " ++ fpath)"
11:19:30 <hcaulfield57> benmachine: Yea, maybe I'll do the functions in Control.Monad
11:20:33 <hcaulfield57> Monads seem not that hard to me, you just have to follow the type signatures, some kind soul helped me figure that out on here the other day
11:20:49 <hcalves> thanks to whoever indicated the Real World Haskell book
11:21:49 <monochrom> I followed the types and got very far too
11:22:08 <bernalex> some F# guy helped me a bit
11:22:15 <bernalex> Brian Beckman
11:23:12 <monochrom> I think learners avoid types too much and doubt flowery essays too little
11:23:21 <benmachine> bernalex: so why is getText a global?
11:23:25 <hcaulfield57> Actually Arrows took a few minutes to learn, just by following the type signatures
11:23:42 <hcaulfield57> monochrom: The only thing that helped me was learning the types, not following stupid tutorials
11:24:04 <bernalex> he helped me understand how we compose computational contexts, and how we sometimes can't do (a -> b) -> a -> b, but need a (a -> m b) -> m a -> m b.
11:24:09 <bernalex> benmachine: because placeholder
11:24:26 <bernalex> benmachine: it's a "omg what do I do" panic function that I put there to work on other things
11:24:52 <bernalex> benmachine: so what should be done instead is no file active, then the user opens a file, then that file is uhm opened and "active" and the network starts.
11:25:07 <bernalex> benmachine: then later I need to implement buttons for pausing/moving to the next/previous word of the file.
11:25:25 <monochrom> I compare learning these abstract concepts to learning numbers and chess. numbers and chess are the first abstract things people learn, and for most people, the last abstract things they learn ever.
11:25:43 <bernalex> benmachine: the text should use this structure that I have: http://lpaste.net/911424019062849536
11:25:51 <levi> hcaulfield57: I think people get trained to ignore types while programming in Java or whatever. Like they're just noise to put in to make the compiler happy.
11:25:55 <benmachine> bernalex: hmm, when I look closer at this I see it involves lots of things that possibly I don't understand :P
11:25:57 <bernalex> benmachine: but ATM setting up opening a file would make me plenty happy for today.
11:25:57 <monochrom> Definition: X is abstract iff the question "but does is really X? what does X really mean?" can't be answered, or is irrelevant.
11:26:17 <monochrom> you never heard anyone blogging on the meaning of chess
11:26:26 <bernalex> benmachine: ignore everything except structuring so that I can open a file and use it, instead of uhm the program starts, getText reads a file, and then you're stuck with it. :-P
11:26:27 <shachaf> @quote formalist
11:26:27 <lambdabot> SaulGorn says: A formalist is one who cannot understand a theory unless it is meaningless.
11:26:28 <benmachine> monochrom: I don't like that definition
11:26:52 <monochrom> benmachine, that definition is useful for this context only! don't you worry.
11:26:55 <bernalex> monochrom: I read something nice lately, "a list has a monad like your monitor has a rectangle". :->
11:26:58 <benmachine> monochrom: I think abstractions should have meaning
11:27:06 <hcaulfield57> levi: On the otherhand, Java's type system is stronger than C, but what I love about Haskell is if it compiles, it generally works.
11:27:18 <benmachine> well. not always
11:27:22 <benmachine> but I certainly think numbers have meaning
11:27:40 <monochrom> you were never told the meaning of numbers. never. all you have been ever told were rote rules for numbers and some applications such as money, candies, height.
11:28:32 <benmachine> it wasn't until my degree that I talked about the meaning of numbers, perhaps, but I did
11:28:38 <cizra> What, numbers have meaning?
11:28:47 <levi> hcaulfield57: Yeah, the bit about Java is really referring to a straw man Java that is more like C than actual Java. But I think people generally don't 'get' any of the more advanced bits of Java's type system except to get annoyed at type erasure.
11:28:48 <benmachine> sure, or I think so at least
11:28:56 <cizra> Point me at some intro reading?
11:29:01 <monochrom> ok, then what is your meaning of numbers? what does 0 mean?
11:29:10 <pdd> hey, I'm just getting started with haskell and parsec and I've finally managed to write a parser p, that does what I need but now I'd like to repeat that parser until I reach eof
11:29:19 <benmachine> monochrom: two possible meanings are "cardinalities of finite sets" and "shapes of lists"
11:29:23 <hcaulfield57> levi: Yea, I'm still having a tough time with gnerics
11:29:55 <monochrom> well, ok, then I can weaken my stance, but most people were still never told any meaning of numbers.
11:30:10 <benmachine> or even "cardinalities of sets" depending on your definitions
11:30:19 <benmachine> monochrom: ok, that I agree with
11:30:32 <levi> hcaulfield57: You will probably have an easier time with them after having come to terms with polymorphism in Haskell.
11:30:58 <monochrom> and at the same time I could start a new war surrounding "but what is the meaning of set" :)
11:31:24 <benmachine> monochrom: oh, certainly. I wouldn't dream of saying these questions are /easy/
11:31:26 <hcaulfield57> levi: Yea, I still don't feel super confident with Haskell's type system, but I'm learning...
11:31:32 <benmachine> but I think they are worth talking about
11:31:40 <benmachine> and sometimes even answerable
11:31:43 <hcaulfield57> Okay, I have to cheat and look up mapM
11:31:47 <benmachine> at least partially
11:31:50 <benmachine> hcaulfield57: nooo :P
11:32:06 <benmachine> bernalex: btw I didn't stop looking at your thing, but I just have no experience with reactive-banana
11:32:16 <benmachine> bernalex: sooo I don't know what to suggest
11:32:42 <benmachine> bernalex: except that you're either going to want to add a parameter to getText or move it to a local context where you know the filename
11:33:30 <bernalex> benmachine: I'm very comfortable working with haskell for games, because there you just have a main loop (step) that takes an entire Game, which has a World and a Menu, etc, and so changing stuff is really simple.
11:33:33 <levi> There are some interesting philosophical questions at the foundations of mathematics. I had no idea until I really started looking into it.
11:33:36 <bernalex> benmachine: but here I am just completely lost. =/
11:34:03 <benmachine> bernalex: surely the filename/contents is just another piece of state?
11:34:11 <benmachine> bernalex: or is the problem that you don't understand FRP either :P
11:34:31 <bernalex> benmachine: I don't understand FP, FRP or haskell at all. I am just very enthusiastic. :-P
11:34:34 <levi> Logic, mathematics, and computation all sort of get fuzzy and intertwined.
11:34:43 <benmachine> levi: I think "the right way to think about things" is an underrated question
11:34:54 <benmachine> which can actually lead to discoveries that matter
11:34:56 <bernalex> benmachine: which might be a problem since I started a haskell company >_<
11:34:59 <benmachine> bernalex: haha
11:35:06 <benmachine> bernalex: enthusiasm might go a long way!
11:35:23 <hcaulfield57> It's always so obvious when I look it up.
11:35:44 <monochrom> no, I think "more ways to think about things" is the one you want
11:35:58 <Twey> levi: Well, it's all just mathematics
11:36:08 <levi> Twey: Or is it all just logic?
11:36:26 <Twey> levi: That's what I just said :þ
11:36:35 <monochrom> also, logic math compsci are fuzzy and intertwined when you assume that they are separated and then you find that they are not separated as you assumed. therefore, don't assume. they are one.
11:36:48 <monochrom> all confusions are due to wrong assumptions.
11:38:21 <hcalves> someone smarter than me might be able to rectify, but for instance, turing machines and lambda calculus are the same thing, formalized with different tools
11:38:30 <levi> One doesn't think of "more ways to think about things" until pondering whether there might be a *better* way to think about something.
11:38:59 <hcaulfield57> Well, I think I've got monads now, now I just need to learn Haskell
11:39:18 <greg`> im using takusen at work to connect to an oracle database
11:39:21 <levi> hcalves: Only the idea of what it means for things to be "the same thing" is still being hashed out a bit.
11:39:25 <c_wraith> hcaulfield57: you'll know you understand monads when you say "oh, is that all?"
11:40:03 <benmachine> there are various different levels of "the same thing"
11:40:21 <benmachine> I've tried to program turing machines and lambda calculus
11:40:30 <benmachine> lambda calculus is substantially less suffering :P
11:40:33 <monochrom> I prefer lambda calculus
11:40:43 <greg`> its best to try and program turing machines
11:40:43 <bernalex> the only thing I've made on a turing machine is a simple addition program
11:40:45 <benmachine> (although still quite a lot, especially if it's untyped)
11:40:59 <hcaulfield57> c_wraith: Insofar as I can understand, it's simply a wrapper. They seem pretty simple to me, but I may be deluded
11:41:18 <c_wraith> hcaulfield57: you're operating at entirely the wrong level of abstraction
11:41:21 <greg`> so ive compiled my takusen oracle program, it links to some oracle dlls
11:41:32 <hcaulfield57> c_wraith: What do you mean?
11:41:43 <greg`> my question is can i take the executable to a machine that doesnt have the dlls installed
11:42:04 <levi> hcaulfield57: Well, they are 'wrappers' inasmuch as they are Functors, but that which makes them also monads is extra on top of being Functors.
11:42:05 <c_wraith> hcaulfield57: many data structures that form monads are simple wrappers around other things.  But that's not what monads are.  Monads are the abstraction
11:42:06 <monochrom> probably not
11:42:27 <tmhedberg> greg`: Doubtful, GHC only statically links Haskell libs by default
11:42:45 <hcaulfield57> c_wraith: Like the s -> (a,s) in the case of State?
11:43:08 <greg`> tmhedberg: can i co-erc ghc to static link other libs?
11:43:13 <hcaulfield57> levi: Yea, okay Functors fufill that too
11:43:22 <c_wraith> hcaulfield57: State is a specific data type.  The whole point of Monad is to abstract specific sets of behavior away from implementations.
11:43:26 * hackagebot cabal-graphdeps 0.1 - Generate graphs of install-time Cabal dependencies  http://hackage.haskell.org/package/cabal-graphdeps-0.1 (JohnMillikin)
11:43:39 <tmhedberg> greg`: You would need static versions of the Oracle libs to do that
11:43:43 <c_wraith> hcaulfield57: if you want to say a monad *is* something, it's the behavior that the abstraction specifies - nothing else.
11:44:09 <greg`> tmhedberg: how do i know if my oracle libs are static?
11:44:24 <levi> An intution about monads that doesn't encompass their operations and laws is an intuition about something other than, though possibly related to, monads.
11:44:40 <tmhedberg> greg`: If they are .dll files, they are dynamic (based on my limited knowledge of Windows)
11:44:51 <greg`> tmhedberg: nuts!
11:45:30 <hcaulfield57> c_wraith: Could you give me a simple example?
11:46:22 <levi> There's actually a huge taxonomy of algebraic structures, of which monad is but a single example, and many of them are related to others simply by the addition or removal of some law or operation.
11:46:45 <c_wraith> hcaulfield57: class Monad m where return :: a -> m a; (>>=) :: m a -> (a -> m b) -> m b  + the monad laws.  That's it.  That's all.
11:46:51 <greg`> its actually really quite fluffy and abstract, so it hard to bring it down into a concreate fashion
11:47:17 <greg`> but i always think that monads allow you to link functions
11:47:31 <c_wraith> hcaulfield57: you can't give an example.  That's the wrong level of abstraction
11:47:39 <greg`> to me its like a function linker, but without destroying the context
11:47:51 <c_wraith> greg`: yes, monads are about composing functions.
11:48:06 <hcaulfield57> c_wraith: Then it's pretty simple?
11:48:15 <greg`> think of building a set of interconnecting pipes under a blanket
11:48:17 <greg`> lol
11:48:26 <yesthisisuser> one could say that >>= and >> is about sequentiality
11:48:28 <monochrom> is everyone rushing to prove that they know monads?!
11:48:44 <c_wraith> greg`: especially if you look at the Kleisli Category intepretation.  The monad laws are just the category laws, then.
11:49:13 * monochrom accepts only this kind of proof-of-understanding: writing correct code
11:49:47 <monochrom> or if you're thinking of the math concept of monads: writing correct proofs
11:49:53 <hcaulfield57> To me, >>= and >>> bear a remarkable similarity to UNIX pipes
11:50:19 <c_wraith> hcaulfield57: still an analogy.  Stop thinking in terms of analogies.  Just use the math.
11:50:21 <greg`> simply put if you can make you type implement the monad type class you can funnel them
11:50:47 <hcalves> how do you call this character in english -> `
11:50:55 <monochrom> backtick
11:50:56 <dwcook> hcalves, backtick
11:50:56 <hcaulfield57> c_wraith: Okay
11:51:02 <monochrom> also backquote
11:51:03 <hcaulfield57> Or grave accent
11:51:13 <greg`> very true no analogies
11:51:30 <dwcook> I'd call it a grave accent if it were over a character
11:51:33 <hcalves> thanks. this is un-Googleable... what's the effect of backtick in Haskell?
11:51:33 <dwcook> à
11:51:52 <dwcook> hcalves, turn a non-infix identifier into an infix
11:51:56 <tmhedberg> hcalves: Surrounding a function name, it produces an infix operator
11:52:01 <hcaulfield57> c_wraith: Well then if I understand return and >>= then am I 'there'?
11:52:08 <dwcook> > let plus a b = a + b in a `plus` b
11:52:09 <lambdabot>  a + b
11:52:12 <hcalves> I see
11:52:17 <monochrom> max x y can be written as x `max` y
11:52:20 <hcaulfield57> dwcook: Yea, I think grave is more for like languages
11:52:22 <greg`> c'mon lets make this fun, lets think of silly analogies for monads
11:52:32 <monochrom> and I almost made the typo there of x `mas` y :)
11:52:32 <hcalves> kinda weird syntax choice, but I got it... thx
11:52:53 <hcaulfield57> hcalves, Perhaps it comes from bourne shell?
11:53:21 <monochrom> in SML I think they use $ for the same thing. max x y can be written as x $max y
11:53:27 * hackagebot cabal-graphdeps 0.1.1 - Generate graphs of install-time Cabal dependencies  http://hackage.haskell.org/package/cabal-graphdeps-0.1.1 (JohnMillikin)
11:53:30 <dwcook> In Bourne shell it's used to mean "insert the output of the quoted command here"
11:53:36 <hcalves> in Bash the backtick just evaluates as command
11:53:36 <dwcook> which I'd say is not comparable
11:53:55 <greg`> a monad is like a cow connected to a milkshake machine
11:53:57 <hcaulfield57> I guess, it made sense for me haha
11:54:50 <dwcook> A monad is also like a typeclass with methods return :: a -> m a and (>>=) :: m a -> (a -> m b) -> m b with certain laws
11:54:56 <hcalves> greg`: thanks, I'll be unable to unsee this image in mind now
11:55:14 <dwcook> That's a metaphor, right? :P
11:55:30 <dwcook> s/metaphor/analogy/
11:55:49 <monochrom> MonadFix is like a cow connected to a milkshake machine both directions
11:56:07 <johnw> Tardis is like a cow that has been, and will be, connected to milkshake machines
11:58:04 <greg`> since we are being pendantic , the use of the word like makes it a similie which is a form of metaphor
11:58:35 <johnw> A Monad is like hooking greg` up to a grammar book
11:59:08 <haasn> TardisT
12:00:01 <greg`> hmmm im starting to think its better to stick to the math :-/
12:01:02 <monochrom> a monad transformer steak is like a T-bone steak. for example SirloinT Tenderloin gives you both sirloin and tenderloin, one on each side of the T
12:01:24 <tmhedberg> instance Monad /bin/sh where (>>=) = (|); return = cat
12:01:51 <johnw> monochrom: :)
12:02:04 <haasn> I think it would be more analogous to >=>
12:02:30 <greg`> monochrom: lol
12:03:26 <hcaulfield57> Well, I'm satisfied
12:03:28 <greg`> tmhedberg: oooh
12:04:19 <greg`> only that /bin/sh isnt kind * -> *
12:04:49 <tmhedberg> I doubt that's the only problem with the analogy :)
12:04:51 <hcaulfield57> What about /bin/sh -c? Probably not
12:05:47 <haasn> type Program = [Arguments] -> InputStream -> IO OutputStream
12:06:44 <greg`> well that seems to fit /bin/sh -c
12:06:59 <greg`> seems good , cant remember the monad laws
12:07:14 <haasn> instance Category /bin/sh where (>>>) = (|); id = cat
12:07:20 <greg`> nearly out of power , have sleeping baby on my lap so cat recharge
12:07:27 <greg`> cant*
12:07:49 <haasn> greg`: in this analogy, it would mean that foo | cat = cat | foo = foo
12:07:59 <haasn> greg`: and that foo | (bar | bat) is the same as (foo | bar) | bat
12:10:11 <haskell_newb> do you remember a name of emacse mode for haskell code formatting?
12:10:44 <haskell_newb> it was doing type aligning in records and various other things
12:12:20 <haskell_newb>  stylish-haskell was it
12:13:29 * hackagebot Spock 0.4.2.0 - Another Haskell web toolkit based on scotty  http://hackage.haskell.org/package/Spock-0.4.2.0 (AlexanderThiemann)
12:38:32 * hackagebot poppler 0.12.3 - Binding to the Poppler.  http://hackage.haskell.org/package/poppler-0.12.3 (IanWooKim)
12:44:26 <hcalves> alright, can someone help me in writting idiomatic haskell?
12:44:30 <hcalves> https://gist.github.com/hcarvalhoalves/9313500
12:45:09 <hcalves> this obviously fails with a parse error on runtime if I specify a non-valid port number. whats the best way to handle errors like these?
12:46:15 <monochrom> use readMaybe. it's in Text.Read, comes with GHC
12:48:34 <hcalves> monochrom: thanks. it isnt possible to pattern match only a number string in this case?
12:48:44 <levi> When the amount of input validation grows, I find it helpful to capture the validation rules in the form of functions a -> Either e b, and then use EitherT to compose a sequence of validation rules so that the process shortcuts to failure with a sensible error value as soon as one fails.
12:48:51 <Iceland_jack> hcalves: no
12:48:51 <monochrom> no
12:51:23 <chrisw_> Can I use the 2D graphics package "gloss" to draw some pictures to a bitmap and save it to a file?
12:51:37 <pranz> hcalves: if you want a to default to a port number, look up "fromMaybe"
12:52:42 <hcalves> I would use it as `readMaybe port :: Maybe Int`?
12:52:59 <pranz> yes
12:53:18 <pranz> if 'port' is a string
12:53:24 <levi> Tekmo put together a handy collection of functions implementing error-handling idioms in his 'errors' package.
12:53:33 * hackagebot hspec2 0.0.0 - Alpha version of Hspec 2.0  http://hackage.haskell.org/package/hspec2-0.0.0 (SimonHengel)
12:55:08 <dwcook> chrisw_, at a glance, doubtful, since all the rendering functions seem to assume the existence of a display rather than being passed one
12:55:15 <levi> chrisw_: I'm not sure if you can save gloss stuff to bitmaps; it's based on OpenGL
12:55:31 <levi> chrisw_: You might look at Diagrams
12:56:36 <chrisw_> dwcook, yeah but maybe there is a way to pull the image from the display?
12:56:53 <levi> And there's the new Rasterific library as well.
12:57:14 <chrisw_> levi, doesn't diagrams only operate on vector graphics?
12:58:14 <levi> Mostly, but it can render them to bitmaps via its Cairo backend.
12:58:15 <chrisw_> levi, Rasterific looks great, but again it looks like it's only for vector graphics
12:58:25 <hcalves> monochrom: pure magic, thank you: https://gist.github.com/hcarvalhoalves/9313500
12:58:38 <levi> gloss is also largely about vector graphics.
12:58:59 <chrisw_> I'm looking for something which will allow me to load bitmaps from a file, rotate and draw them on top of one another, then save that back out to a file.
12:59:05 <enthropy> gloss does bmp
12:59:20 <c_wraith> Rasterific can texture.
12:59:26 <chrisw_> OpenGL/GLUT seems like overkill in this situation, but I'm not against using it.
13:01:18 <levi> Diagrams.TwoD.Image provides some bitmap graphics support as well.
13:04:20 <hcalves> besides strip, what are other tricks to shrink the binary size?
13:04:36 <hcalves> a simple echo server linked to 3mb here
13:04:50 <monochrom> self-extracting exe
13:05:12 <levi> Dynamic linking is one way
13:05:43 <hcalves> I still want static linked... can you be more selective on what ghc links?
13:06:09 <levi> There's also a way to tell ghc to create a bunch of tiny object files as it compiles things, but I don't recall the option name.
13:06:45 <haskell_newb> hello
13:06:50 <Iceland_jack> hey haskell_newb
13:06:53 <levi> It will likely be more trouble than it's worth unless you really have tight resource constraints.
13:07:00 <haskell_newb> can you recomend be a binary trees package?
13:07:06 <haskell_newb> s/be/me/
13:07:07 <tmhedberg> hcalves: I believe a lot of the bulk is due to the RTS, which you can't really eliminate
13:07:30 <hcalves> tmhedberg: right
13:07:35 <haskell_newb> when searching hackage it outputs just too many
13:08:12 <byorgey> chrisw_: what sort of pictures do you want to draw?
13:08:16 <hcalves> I was just wondering because if a simple echo server links to 3mb, what can you expect of a sizeable system
13:09:08 <sipa> haskell_newb: binary tree for what?
13:09:11 <tmhedberg> hcalves: It's a more or less constant factor, so while it makes "hello world" seem fat, it makes up a relatively small proportion of a normal-sized program
13:09:11 <byorgey> chrisw_: oh, sorry, I just saw your description of what you want above
13:09:11 <hcalves> but if that 3mb is just a fixed overhead, good
13:09:36 <monochrom> hcalves, you are right to try to extrapolate, but you should extrapolate based on more data points, not one data point.
13:09:56 <levi> hcalves: Depends on how many dependencies your program pulls in.  Some sizeable haskell programs are massive, and some are closer to 3mb. :)
13:10:05 <haskell_newb> sipa: i just want to create genealogical tree
13:10:16 <chrisw_> byorgey, I want to load in an image, cut it up into multiple images, rotate and draw those images back onto an image and save it to a file.
13:11:09 <hcalves> does it optimize the size if I import x (x) as opposed to the whole module import x ?
13:11:15 <haskell_newb> so nodes should be male of female and has UID of person
13:11:20 <levi> byorgey: If 'Diagrams' is the 'Illustrator' of Haskell, is there a 'Photoshop'?
13:11:36 <monochrom> I have an exe 2MB after strip. and it is fairly more than echo server.
13:12:08 <greg`> oooh i fancy some diagram tutorials any recommendations
13:12:09 <byorgey> levi, chrisw_ : try http://hackage.haskell.org/package/unm-hip perhaps
13:12:10 <greg`> ?
13:12:27 <monochrom> so, wait, it means adding more stuff to the program shrinks its size? :)
13:12:29 <hcalves> monochrom: good to know, thx. Linux?
13:12:38 <monochrom> linux, 64-bit x86_64
13:12:48 <byorgey> greg`: diagram tutorials in general?  Or tutorials for the 'diagrams' framework specifically?
13:12:53 <chrisw_> byorgey, thanks I'm looking into it
13:12:57 <haskell_newb> familytree
13:13:23 <levi> haskell_newb: I think most people would just write their own data type in that case. Most tricky binary tree operations, like rebalancing, wouldn't apply to a genealogical tree.
13:14:17 <byorgey> genealogical trees are typically not simple binary trees anyway.
13:14:30 <haskell_newb> levi: yeah, i guess so
13:14:36 <haskell_newb> byorgey: why not simple?
13:14:59 <roboguy_> haskell_newb: I'm reading Oedipus Rex for a class right now. there's an example
13:15:17 <levi> byorgey: That's exactly what I had in mind! Not that I have any immediate use for it, but it's good to know it's there.
13:15:55 <byorgey> haskell_newb: there are step-parents and half-siblings and remarriages and distant cousins who get married etc. etc. etc.
13:16:07 <byorgey> I guess it depends on how faithfully you want to model things.
13:17:06 <monochrom> use a graph library
13:17:10 <haskell_newb> byorgey: ah, i see, so it's more graph
13:17:19 <byorgey> right
13:18:27 <bernalex> benmachine: lulz. after hitting my code with a hammer for long enough, I am now able to read in a file. the problem of course is that I need to stop *the other file*. xD reading both at once was confusing.
13:18:40 <benmachine> sounds fun
13:19:26 <bernalex> reading two wheel of time books at once is maybe a bit of a cognitive overload for my brain
13:21:33 * Picos salut all
13:24:06 <bernalex> Twey: OK so with this huge mess (which I will rewrite, I promise): http://lpaste.net/1439641950645911552 -- what should I *really* be doing on lines 187..190?
13:24:16 <steamboat> I'm trying to get acquainted with netwire and I'm running through http://ocharles.org.uk/blog/posts/2013-08-01-getting-started-with-netwire-and-sdl.html, but when I try to compile GHC doesn't recognize the integral_ function. Have I missed an import or something?
13:24:38 <bernalex> Twey: there we have a user opening a new file, so it should be reading that file now instead of the old one
13:24:53 <bernalex> Twey: right now it will, as I told you, just read all of the files opened.
13:24:57 <bernalex> at once.
13:26:36 <guymann> h
13:26:37 <steamboat> code at http://lpaste.net/100631
13:27:23 <Twey> bernalex: Don't set up your network multiple times.
13:27:34 <bernalex> Twey: no, I understand that. so what should I be doing instead?
13:27:50 <bernalex> I would like to "modify" my network to use the new text instead
13:28:09 <Twey> bernalex: Create an extra AddHandler that represents the addition of a file, and make bWords switch its value to the new file's contents when you get a new file
13:28:57 <bernalex> Twey: but uh bWords is just a synonym for accumB (w, ws) (const nextWord <$> eTick), right? I'm a bit confused
13:32:02 <greg`> say i have a few different programs in my sandbpx
13:32:24 <greg`> how do i switch between sandboxes, via sandbox init?
13:33:00 <greg`> would be nice if sandboxes where datomic
13:33:05 <greg`> :-\
13:33:52 <hcalves> anyone here cross compiling with GHC?
13:34:14 <Twey> bernalex: Sure, but you can use an Either, union (Left <$> eFileLoaded) (Right <$> eTick), and then change the accumulation function so that you just overwrite the current list of words with the new list of words when you get a Left
13:35:18 <bernalex> Twey: I have no idea on how to do that. =/ I guess I'll re-read the reactive-banana tutorials.
13:37:03 <jfischoff> does anyone know how to use edwardk's algebra package? specifically the Numeric.Algebra.Quaternion.QuaternionBasis's Algebra instance
13:37:26 <jfischoff> I'm not sure what function I am suppose to pass in …
13:37:33 <roboguy_> steamboat: it looks like netwire changed since that was written
13:37:36 <Twey> bernalex: E.G. accumB (w, ws) (const (either (const . splitAt 1) (const nextWord)) <$> union (Left <$> eFileLoaded) (Right <$> eTick) … or something like that
13:37:42 <steamboat> yeah
13:37:52 <roboguy_> steamboat: there is an integral function in FRP.Netwire.Move that might help
13:37:53 <steamboat> apparently it lives in FRP.Netwire now
13:37:57 <steamboat> yeah
13:38:22 <steamboat> I'm still struggling to get it to compile though, so I think I'm going to have to wade through hackage
13:39:13 <steamboat> although sadly the tutorial here: http://hub.darcs.net/ertes/netwire/browse/README.md is also out of date
13:39:17 <x77686d> Newbie question: I'm astounded that the the two versions of prswap in http://lpaste.net/100632 run in about the same time and that prswap2 uses only 50% memory.  Can anybody shed some light on this?
13:39:49 <kuribas> @pl \x f -> f x
13:39:49 <lambdabot> flip id
13:40:24 <roboguy_> it would be nice if lambdabot favor ($) over id where applicable
13:41:04 <dwcook> roboguy_, what rule would you use to determine which to say?
13:41:49 <shachaf> x77686d: What happens if you do the same thing a second time?
13:41:53 <roboguy_> dwcook: would it work if it used things that must be function types, like in that example?
13:42:02 <shachaf> (Not that m has been forced.)
13:42:08 <shachaf> Er, now.
13:42:59 <shachaf> Also, ghci benchmarking is very unreliable. I wouldn't use it for measuring anything serious.
13:43:04 <kuribas> dwcook: maybe if the type is the same when using ($)
13:43:20 <x77686d> shachaf: Interesting -- prswap2 goes to 2x time and 2.5x memory
13:43:35 <dwcook> You mean if ($) can be used instead of id without the type being less general? Sure, sounds like a reasonable rule to me
13:43:38 <shachaf> By unreliable I guess I just mean different.
13:43:42 <kuribas> dwcook: yes
13:46:14 <roboguy_> dwcook: yeah
13:46:20 <roboguy_> dwcook: like flip id
13:47:51 <fizruk> :w
13:47:56 <fizruk> oops
13:48:04 <yac> just found this thing: http://girlloveshaskell.com/
13:48:14 <monochrom> E154: the file is write-protected :)
13:48:44 <bernalex> Twey: I'll look into it some more later -- I have to prepare and eat a very belated dinner first.
13:49:18 <jfischoff> @tell edwardk how do I use mult  with Numeric.Algebra.Quaternion? How do I use Numeric.Algebra.Quaternion in general?
13:49:18 <lambdabot> Consider it noted.
13:49:26 <roboguy_> hmm, that's interesting: both calls to the prswap functions say they take 0 bytes in the ghci 7.8 rc. maybe it's a bug?
13:52:15 <roboguy_> unless they found a way to optimize it so that everything uses no memory I'm pretty sure that's a bug
13:54:51 <[1]grant> When receiving an http request, is there a good way to incrementally parse the request (as it's coming in)?
14:03:42 * hackagebot base-compat 0.4.0 - A compatibility layer for base  http://hackage.haskell.org/package/base-compat-0.4.0 (SimonHengel)
14:21:08 <chrisw_> byorgey, unm-hip actually doesn't support image rotation =( literally all I want is "gloss" with the ability to render a Picture back to a regular bitmap
14:24:06 <idnar> does `eitherToMaybe = either (const Nothing) Just` already exist somewhere?
14:29:49 <supki_> idnar: it does in the either package
14:32:33 <haasn> chrisw_: doesn't http://hackage.haskell.org/package/diagrams-lib-1.0.1/docs/Diagrams-TwoD-Image.html help?
14:32:54 <haasn> but I guess that's only useful for images that are actually saved as bitmaps on your disk :P
14:33:58 <haasn> byorgey: I've noticed you have a Diagrams.ThreeD module now; is there any usable instance Backend b R3 yet?
14:34:45 <chrisw_> haasn, thanks, I'm taking a look at it now
14:37:30 <the_berserker> @pl while cond action = cond >>= \c -> if c then action >> while cond ction else return ()
14:37:30 <lambdabot> while = fix (liftM2 (.) (>>=) . flip flip (return ()) . ((flip . ((flip . flip if') .) . flip (>>)) .) . flip flip ction)
14:37:31 <chrisw_> haasn, is diagrams a bad choice if I want to repeatedly draw lots of small bitmaps, while displaying them to the user?
14:37:51 <dhrosa> that's beautiful, you should defintely use that in your code.
14:38:00 <haasn> chrisw_: I don't really know
14:38:45 <the_berserker>   @pl while cond action = cond >>= \c -> if c then action >> while cond action else return ()
14:39:19 <the_berserker> @pl while cond action = cond >>= \c -> if c then action >> while cond action else return ()
14:39:19 <lambdabot> while = fix (liftM2 (.) (>>=) . flip flip (return ()) . ((flip . ((flip . flip if') .) . ap (>>)) .))
14:39:50 <prophile> a thing of beauty to be sure
14:41:16 <the_berserker> @pl while cond action = let loop = cond >>= \c -> if c then action >> loop else return () in loop
14:41:16 <lambdabot> (line 1, column 20):
14:41:16 <lambdabot> unexpected " "
14:41:16 <lambdabot> expecting operator
14:41:56 <ion> the_berserker: It works in private, too.
14:42:01 <prophile> the_berserker: I don't think @pl handles let-expressions fyi
14:42:30 <the_berserker> @pl \cond action -> cond >>= \c -> if c then action >> while cond action else return ()
14:42:30 <lambdabot> liftM2 (.) (>>=) (flip flip (return ()) . ((flip . flip if') .) . ap (>>) . while)
14:43:17 <the_berserker> @pl \cond action -> let loop = cond >>= \c -> if c then action >> loop else return () in loop
14:43:17 <lambdabot> (line 1, column 82):
14:43:17 <lambdabot> unexpected " "
14:43:17 <lambdabot> expecting variable, "(", operator, ">>", ">>=", "=<<", ">>>", "^>>", "^<<", ";" or "in"
14:44:27 <the_berserker> @pl loop = cond >>= \c -> if c then action >> loop else return ()
14:44:27 <lambdabot> loop = fix ((cond >>=) . flip flip (return ()) . flip if' . (action >>))
14:45:00 <ion> the_berserker: It works in private, too.
14:45:36 <the_berserker> @pl while cond action = fix ((cond >>=) . flip flip (return ()) . flip if' . (action >>))
14:45:36 <lambdabot> while = (fix .) . (. (((flip flip (return ()) . flip if') .) . (>>))) . (.) . (>>=)
14:45:41 <Fuuzetsu> but if he does it in private, how will the witty #haskell users chime in with their shortened versions?
14:47:14 <the_berserker> @type (fix .) . (. (((flip flip (return ()) . flip if') .) . (>>))) . (.) . (>>=)
14:47:15 <lambdabot>     Not in scope: if'
14:47:15 <lambdabot>     Perhaps you meant f' (imported from Debug.SimpleReflect)
14:47:30 <ion> the_berserker: You should do that in private.
14:48:20 <the_berserker> @type let {if' True a _ = a; if' False _ b = b} in (fix .) . (. (((flip flip (return ()) . flip if') .) . (>>))) . (.) . (>>=)
14:48:21 <lambdabot> Monad m => m Bool -> m a -> m ()
14:50:36 <haasn> Where do I find the GHC 7.8 release candidates?
14:50:51 <roboguy_> haasn: http://www.haskell.org/ghc/dist/7.8.1-rc2/
14:51:02 <haasn> roboguy_: thanks
14:51:05 <khyperia> @pl (>>=) f g e = g (f e) e
14:51:05 <lambdabot> (line 1, column 14):
14:51:05 <lambdabot> unexpected " "
14:51:05 <lambdabot> expecting operator
14:51:31 <bernalex> I have a function FilePath -> IO String, which is f txt = txt = readFile txt `catch` fail. what does fail need to look like to return ""?
14:51:39 <roboguy_> @pl bind f g e = g (f e) e
14:51:39 <lambdabot> bind = flip flip id . (ap .) . flip (.)
14:51:48 <khyperia> Hrm.
14:52:06 <bernalex> oh I figured it out
14:52:11 <khyperia> I thought someone said that the reader monad is something simple?
14:52:25 <bernalex> or at least I think I did. fail _ = return "" type checks at least.
14:52:27 <khyperia> (at least I think I did the reader monad correctly, not sure)
14:52:51 <roboguy_> khyperia: well, the pointfree version might not be simple
14:52:58 <khyperia> Oh, right, yeah
14:53:08 <khyperia> @pl \e -> g (f e) e
14:53:08 <lambdabot> g =<< f
14:53:17 <khyperia> Oh, thanks lambdabot.
14:53:47 * hackagebot miniutter 0.4.3.0 - Simple English clause creation from arbitrary words  http://hackage.haskell.org/package/miniutter-0.4.3.0 (MikolajKonarski)
14:54:27 <the_berserker> @pl while cond action = fix ((cond >>=) . flip flip (return ()) . flip if' . (\y -> action >>= \_ -> y))
14:54:27 <lambdabot> while = (fix .) . (. (((flip flip (return ()) . flip if') .) . (. const) . (>>=))) . (.) . (>>=)
14:54:34 <khyperia> Is there a simpler way to write that without bind?
14:55:16 <khyperia> someone said something about "ask is id, bind is ($)" or something crazy like that, I forget who
14:55:26 <haasn> :t ?g =<< ?f
14:55:27 <lambdabot> (Monad m, ?g::a -> m b, ?f::m a) => m b
14:55:39 <haasn> :t flip ?g <*> ?f
14:55:40 <lambdabot> (?g::a -> b -> c, ?f::b -> a) => b -> c
14:55:54 <haasn> I think this is the same
14:56:05 <khyperia> what is this question mark thing?
14:56:17 <ion> ImplicitParams
14:56:29 <the_berserker> @pl while = (fix .) . (. (((flip flip (return ()) . flip if') .) . (\x y -> x >>= \_ -> y))) . (.) . (>>=)
14:56:30 <lambdabot> while = (fix .) . (. (((flip flip (return ()) . flip if') .) . (. const) . (>>=))) . (.) . (>>=)
14:56:52 <geekosaur> um? that's already pointfree
14:57:11 <prophile> @hoogle (Functor f) => (a -> b) -> (a -> b -> a) -> ((b -> f b) -> a -> f a)
14:57:12 <lambdabot> No results found
14:57:16 <ion> the_berserker: Please do that in private. Three screenfuls of *that* is detrimental to the channel discussion.
14:57:17 <prophile> >:|
14:57:45 <haasn> prophile: ‘lens’
14:57:53 <prophile> ah
14:58:00 <prophile> yes, that's a pretty obvious name too
14:58:19 <haasn> http://hackage.haskell.org/package/lens-4.0.4/docs/Control-Lens-Lens.html#v:lens
14:58:25 <prophile> presumably hoogle didn't get it because it's the four-parameter lenses?
14:58:25 <haasn> but you should probably define your lens directly
14:58:38 <haasn> presumably hoogle didn't get it because hoogle doesn't index lens
14:58:47 <prophile> yes, that would make sense too
14:58:50 <haasn> @hoogle lens
14:58:50 <lambdabot> package lens
14:58:50 <lambdabot> package lens-aeson
14:58:50 <lambdabot> package lens-datetime
14:58:54 <haasn> Ah, it has the package
14:58:57 <haasn> @hoogle ilens
14:58:57 <lambdabot> No results found
14:58:57 <prophile> I thought hoogle indexed all of hackage?
14:59:02 <haasn> prophile: no, only a select subset
14:59:08 <ion> Why is that, btw?
14:59:09 <prophile> k
14:59:11 <haasn> however:
14:59:15 <geekosaur> fpcomplete has a hoogle that indexes all of hackage
14:59:21 <haasn> @hoogle (Functor f) => (a -> b) -> (a -> b -> a) -> ((b -> f b) -> a -> f a) +lens
14:59:21 <lambdabot> Could not find some databases: lens
14:59:21 <lambdabot> Searching in:
14:59:21 <lambdabot>   .
14:59:29 <haasn> Oh, this is lambdabot's local hoogle instance
14:59:41 <prophile> I see
14:59:54 <prophile> popping a stack frame here, what did you mean by "define your lens directly"?
15:00:09 <prophile> write the van laarhoven lens by hand?
15:00:14 <haasn> prophile: yes
15:00:24 <prophile> hm, okay
15:00:27 <khyperia> ahh, ok, figured it out, I think whoever that was said "ask is id, asks is ($)" or something like that
15:00:49 <prophile> this is a lens for an element of a record, and it seemed neat to be able to use the record name as the getter part to lens
15:01:05 <the_berserker> @type let {if' True a _ = a; if' False _ b = b} in (fix .) . (. (((flip flip (return ()) . flip if') .) . (. const) . (>>=))) . (.) . (>>=)
15:01:06 <lambdabot> Monad m => m Bool -> m b -> m ()
15:01:24 <ion> khyperia: Btw: the last heading in https://gist.github.com/ion1/9285144
15:01:26 <the_berserker> How to write anonymous pattern-matching functions?
15:01:50 <ion> the_berserker: Why?
15:01:55 <geekosaur> the_berserker, you can write them but only with a single pattern
15:01:57 <prophile> the_berserker: use a lambda and a case expression...
15:02:01 <khyperia> Ah, thanks
15:02:29 <prophile> geekosaur: he was asking for anonymous, not necessarily point-free though
15:02:49 <prophile> so a case expression inside a lambda should be fine?
15:04:14 <geekosaur> yes, that's the workaorund (also with lambdacase it can still be pointfree)
15:04:26 <geekosaur> but the lambda syntax itself only supports a single pattern
15:05:45 <dwcook> khyperia, that's a little bit confusing considering that ($) is just id for functions. Was there further explanation attached to that statement?
15:06:21 <ion> @type runReader . asks
15:06:22 <lambdabot> (r -> a) -> r -> a
15:06:29 <khyperia> was explaining how reader is the same thing as function monad, only wrapped in a newtype
15:06:54 <dwcook> That I agree with, but from that the other statement doesn't follow
15:07:19 <geekosaur> hm? made sense to me
15:07:32 <khyperia> I think the "is" in "ask is id, asks is ($)" is "equivalent if newtypes didn't exist" or something like that
15:08:19 <khyperia> and... fmap for functions is (.)? Possibly?
15:08:23 <roboguy_> that does seem like a strange distinction since ($) = id
15:08:33 <roboguy_> khyperia: it is
15:08:44 <khyperia> well, asks takes a function as a parameter
15:08:47 <geekosaur> but ($) is also function application
15:09:05 <geekosaur> which is the intended context, not the fact that it's a more specific id
15:09:08 <dwcook> Oh, I think I see now
15:09:14 <roboguy_> ahh
15:09:35 <dwcook> I did the newtype expansion wrong in my head, then did it again just now and found I made a mistake
15:09:51 <the_berserker> @pl ($)
15:09:51 <lambdabot> id
15:10:32 <the_berserker> Why isn't ($) defined with the most general type in the Prelude?
15:10:46 <the_berserker> ($) x = x
15:10:59 <geekosaur> because people get confused by it enough as it is
15:11:00 <khyperia> 'cause if you want to use id, then use id - ($) is made for a specific purpose (I think)
15:11:14 <geekosaur> it'd be worse if ($) didn't at least enforce a function context
15:11:53 <roboguy_> the_berserker: sometimes making something more general makes it unnecessarily more confusing
15:12:07 <dwcook> > let f x = x + 1 in (`f` 10)
15:12:08 <lambdabot>  No instance for (Data.Typeable.Internal.Typeable t0)
15:12:08 <lambdabot>    arising from a use of `M541890649355790272532367.show_M5418906493557902725...
15:12:08 <lambdabot>  The type variable `t0' is ambiguous
15:12:08 <lambdabot>  Possible fix: add a type signature that fixes these type variable(s)
15:12:08 <lambdabot>  Note: there are several potential instances:
15:12:16 <dwcook> > let f x = x + 1 in (`f` (10 :: Integer))
15:12:17 <lambdabot>  No instance for (Data.Typeable.Internal.Typeable t0)
15:12:17 <lambdabot>    arising from a use of `M815343361077680228032376.show_M8153433610776802280...
15:12:17 <lambdabot>  The type variable `t0' is ambiguous
15:12:17 <lambdabot>  Possible fix: add a type signature that fixes these type variable(s)
15:12:18 <lambdabot>  Note: there are several potential instances:
15:12:26 <dwcook> :(
15:12:28 <Algebr> l
15:12:39 <ion> We should learn from lens and make ($) = asks
15:12:53 <ion> > (10 `succ`)
15:12:54 <lambdabot>  can't find file: L.hs
15:12:58 <ion> > (10 `succ`)
15:12:59 <lambdabot>  11
15:13:00 <khyperia> @pl \e -> (f e) (g e)
15:13:00 <lambdabot> ap f g
15:13:03 <dwcook> Oh heh, of course
15:13:05 <khyperia> wait... what is ap?
15:13:09 <Algebr> Why is this not allowed `someFunc :: [a] -> Int`
15:13:12 <roboguy_> khyperia: <*>
15:13:13 <roboguy_> for Monads
15:13:15 <haasn> khyperia: ap :: Monad m => m (a -> b) -> m a -> m b
15:13:17 <khyperia> Ah.
15:13:30 <geekosaur> Algebr: not allowed where?
15:13:38 <khyperia> I was checking to see what <*> looks like for functions, but apparently there is no simpler form, heh
15:13:42 <roboguy_> ap will be totally unnecessary in new code when ghc 7.10 i here
15:13:42 <dwcook> Algebr, you mean length?
15:13:46 <Algebr> geekosaur: I can't compile this
15:13:49 <Algebr> yes, length
15:13:56 <dwcook> Algebr, compile what? Show code.
15:14:03 <ion> roboguy: instance Applicative … where (<*>) = ap ;-)
15:14:08 <geekosaur> are you typing that into ghci? writing it in a source file?
15:14:20 <roboguy_> ion: oh right. except for that
15:14:22 <khyperia> and one last confirmation of me figuring stuff out - for functions, pure = const?
15:14:38 <roboguy_> khyperia: yeah
15:14:48 <Algebr> sumList :: [a] -> Int
15:14:49 <Algebr> sumList (x:xs) = x + sumList xs
15:14:52 <Algebr> sumList [] = 0
15:14:54 <d3lxa> I have a Data.Text and I need a lazy ByteString, is this reasonable: Text -> Lazy Text -> Lazy ByteString?
15:15:11 <dwcook> Algebr, you need Num for (+)
15:15:13 <roboguy_> Algebr: we know nothing about the type "a", so we can't call any functions on it (including +)
15:15:13 <khyperia> Awesome. Just figured out Functor/Applicative/Monad for functions on my own!
15:15:24 <ion> khyperia: congrats
15:15:26 <geekosaur> dwcook, he has Int where that matters
15:15:26 <dwcook> Algebr, that is also not a length function :P
15:15:36 <geekosaur> oh wait
15:15:40 <Umschwung> roboguy_: Well we could call id on it...
15:15:42 <dwcook> geekosaur, nope, a is too general
15:15:51 <dwcook> Actually the problem is that a should be Int
15:15:52 <roboguy_> Umschwung: that's true
15:15:56 <Algebr> So because we haven't said anything about a, thats why it won't compile?
15:15:56 <geekosaur> why are you adding x to it?
15:16:04 <dwcook> Or else Int should be a and you should have a Num a constraint
15:16:05 <geekosaur> you are adding an a to an Int
15:16:21 <geekosaur> but when you use a there, you are saying "any type"
15:16:35 <geekosaur> you are not saying "oh, figure this out for me and fill it in with Int"
15:16:42 <Algebr> ah, makes sense now.
15:16:50 <dwcook> Algebr, yes, but more specifically, (+) only works on things that are instances of Num, and all its parameters must have the same type
15:17:18 <ion> d3lxa: It should be, Text → Lazy Text should be O(1)
15:18:05 <d3lxa> ion: ok, thank you for your opinion
15:18:18 <bernalex> Twey: set up bWords to now use my own data type instead of string at least.
15:18:37 <bernalex> Twey: I guess my next stop is now looking into what you wrote about updating the file instead of uh adding new files.
15:18:44 <bernalex> Twey: then pause+manual step.
15:19:56 <bernalex> Twey: quick question: how do I get rid of the lambda in: changes bWords >>= reactimate' . fmap (fmap $ \ tr -> set label [labelText := (fromMaybe "" (curWord tr))]) -- ? I don't need it because I uh already have tr in scope
15:20:38 <ion> Huh. The documentation for Data.Text.Lazy.fromStrict says O(c), not O(1). I suppose c = 1, but that’s confusing.
15:22:57 <monochrom> is it really O(1)?
15:23:02 <haasn> ion: that looks like a typo, they have O(C) for toStrict as well (which scales with the number of chunks)
15:23:22 <ion> haasn: It said O(n) for toStrict i think.
15:23:50 <ion> and O(c) for fromChunks :: [Strict.Text] -> Lazy.Text
15:24:17 <haasn> monochrom: yes
15:25:01 <haasn> monochrom: the source code is literally chunk t Empty; which boils down to if len t == 0 then Empty else Chunk t Empty
15:25:19 <monochrom> I see, thanks
15:26:01 <[1]grant> If I call recvFrom on a socket to which a client has only partially sent their http request (say they are sending it really slowly), i'll need to call recvFrom again to get the rest of the request?
15:26:34 <haasn> ion: oh, yes
15:28:02 <geekosaur> Why are you using recvFrom on a TCP socket?
15:28:33 <haasn> (doesn't recvFrom use lazy IO?)
15:28:37 <geekosaur> no
15:28:42 <geekosaur> recvFrom is intended for UDP
15:29:19 <[1]grant> Oh, what should I use for TCP?
15:29:40 <haasn> geekosaur: it says it uses hGetContents, doesn't that use lazy IO?
15:29:42 <geekosaur> it returns a single datagram. for UDP that's a single datagram packet, for TCP it depends on the network stack and may not have much relationship to what was sent
15:29:57 <geekosaur> er. which recvFrom are you looking at?
15:30:07 <haasn> oh
15:30:09 <haasn> http://hackage.haskell.org/package/network-2.4.2.2/docs/Network.html#v:recvFrom sorry
15:30:14 <geekosaur> I'm looking at Network
15:30:32 <haasn> I just found http://hackage.haskell.org/package/network-2.4.2.2/docs/Network-Socket-ByteString.html#v:recvFrom
15:30:34 <haasn> did you mean that one?
15:31:05 <geekosaur> hm, that doc also mentions hGetContents but that implies whoever wrote that did not know what they were up to, or copied and pasted blindly
15:31:19 <geekosaur> it has no business doing unsafeInterleaveIO
15:31:28 <geekosaur> and if it does then Network does not support UDP
15:31:46 <geekosaur> (this would not actually surprise me, sadly)
15:31:52 <haasn> I'm confused. Which recvFrom are you looking at?
15:32:10 <geekosaur> I looked again at the doc in Network's haddock
15:32:24 <geekosaur> the docs in "Simple sending and receiving" do claim it uses hGetContents
15:32:56 <geekosaur> if it does then it is broken and wrong and whoever wrote that code does not understand why sendTo/recvFrom exist, and Network does not work with UDP as a result
15:33:33 <geekosaur> aaaaaaaaa
15:33:34 <geekosaur> it does
15:33:46 * geekosaur gets ready to submit a bug report against Network
15:34:23 <[1]grant> geekosaur: so, as glad as I am to have brought this to your attention, what should I use for receving HTTP requests over TCP :D
15:34:39 <geekosaur> I guess you use that since that's all it is good for. except you shouldn't
15:34:46 <[1]grant> ._.
15:34:47 <geekosaur> a socket is a filehandle, use filehandle routines on it
15:35:03 <geekosaur> (TCP socket at least.)
15:35:11 <[1]grant> so just keep using recvFrom?
15:35:19 <[1]grant> or hGetContents
15:35:33 <dwcook> Does Network.Socket.ByteString do it properly? It looks like it doesn't have that particular problem at least
15:35:43 <geekosaur> oh, its using socketToHandle actually
15:35:50 <geekosaur> you want to do that on a TTCP socket
15:35:50 <dwcook> Heh
15:35:55 <haasn> geekosaur: I'm confused. Are you complaining about the presence of lazy IO functions in Network?
15:36:03 <geekosaur> haasn: no.
15:36:11 <geekosaur> do you, by any chance, know about UDP?
15:36:19 <haasn> no
15:36:23 <haasn> not really
15:36:39 <geekosaur> (I have this sudden feeling that your question means that my bug report should be "Network claims to support UDP, does not"
15:36:55 <geekosaur> TCP is a stream, you can read and write it like a file
15:37:01 <haasn> (I don't see where Network claims to support UDP)
15:37:06 <geekosaur> UDP is packets. These packets have hard boundaries
15:37:46 <geekosaur> oh, hm, the upper level stuff does not. so they're just abusing namespace
15:37:52 <geekosaur> why, I do not know
15:37:56 <haasn> “Notice that although you can pass any Socket to Network.accept, only sockets of either AF_UNIX, AF_INET, or AF_INET6 will work”
15:38:08 <geekosaur> that's not relevant
15:38:13 <haasn> for “accept”, which is what returns the Handle (that recvFrom uses)
15:38:23 <haasn> oh, no, it uses the lower level accept
15:38:30 <geekosaur> and I gues sthis means I give up because nobody actually understands TCP/IP enough to know what is going on at all
15:38:37 <geekosaur> AF_INET is TCP/IP
15:38:56 <[1]grant> I am so extremely confused. I just want to write a toy http server T_T
15:39:02 <geekosaur> there are two primary socket types in AF_INET: SOCK_STREAM is TCP, SOCK_DGRAM is UDP
15:39:23 <geekosaur> since 99% of what most people work with is TCP, nobody understands UDP
15:39:31 <geekosaur> never mind that key stuff like DNS uses it
15:39:35 <haasn> [1]grant: I would personally just use pipes and stay away from lazy IO and everything related to it
15:39:44 <haasn> [1]grant: or use a higher level http abstraction
15:39:55 <geekosaur> [1]grant: as far as I can tell, you are in fact intended to use recvFrom.
15:40:02 <geekosaur> so I guess I have to say use recvFrom
15:40:03 <khyperia> Wait wait wait. How does Haskell UDP support work? Like, is there a "get next packet" function that returns whatever packet it wants to? (streams seem... not nice for UDP)
15:40:29 <haasn> geekosaur: I don't understand how socketToHandle :: Socket -> IOMode -> IO Handle works
15:40:31 <geekosaur> but, since I actually understand how TCP/IP works, I am telling you to use a fundamentally broken interface :(
15:40:49 <geekosaur> haasn: on unix it's a no-op. Windows requires magic
15:41:11 <haasn> geekosaur: but what does it do for non-TCP sockets?
15:41:22 <[1]grant> haasn: What sort of pipes? Never used them I suppose...
15:41:23 <geekosaur> it still give syou a filehandle
15:41:37 <haasn> don't file handles behave like streams?
15:41:42 <geekosaur> but you can only (at the sytem call level) call send/sendto or recv/recvfrom on it
15:41:48 <haasn> okay
15:41:49 <geekosaur> the normal file operations are not defined on UDP
15:42:21 <geekosaur> haasn, on unix there is only a filehandle. some things, like UDP sockets, don;t actually fit into it very well
15:42:26 <haasn> then I don't understand where the problem with recvFrom is. Can you explain to me how it breaks UDP?
15:42:50 <geekosaur> (an old early attempt at Unix IPC also used filesystem stuff for shared memory and semaphores, which was just laughably wrong)
15:43:20 <geekosaur> it breaks UDP because it has nothing to do with the recvfrom() syscall, which you therefore cannot call
15:43:28 <geekosaur> which means you cannot work with a UDP socket
15:43:53 <geekosaur> bit in fact the higher level Network interface seems to only do TCP anyway, so someone just took the recvFrom name and did something weird with it
15:44:28 <geekosaur> I am a litle afraid to look inside Network.Socket and see if it actually supports UDP, or if the lack of network clue implicit in this definition of recvFrom goes deeper
15:44:50 <geekosaur> but right now I want to whack someone with a copy of Stevens >.>
15:45:12 <haasn> geekosaur: so your complain is that Network.recvFrom has nothing to do with the recvfrom() syscall?
15:45:14 <haasn> complaint*
15:45:31 <geekosaur> it is clearly modeled after the BSD sockets interface
15:45:47 <geekosaur> oh, never mind
15:45:56 <haasn> I would never have guessed that, personally. Would you suggest they choose a different name? Like getContentsFrom
15:46:23 <geekosaur> that would make me happier, because all the other names are very obvious to anyone who knows the BSD sockets interface
15:46:31 <geekosaur> but this one... isn't really
15:46:56 <dwcook> So, does almost nobody do UDP in Haskell, then?
15:47:04 <geekosaur> does something completely different from what anyone recognizing the BSD sockets interface would expect it to do
15:47:18 <[1]grant> So I return to my original question: if someone connects, I split off a thread to deal with it, I call recvFrom on the socket, but they are sending data really slowly so recvFrom only gets part of the request. Can this happen? If it does happen, do I just wait and call recvFrom again to get more data?
15:47:19 <geekosaur> dwcook, I haven't ooked in Network.SOcket yet
15:47:21 <geekosaur> it may work
15:47:39 <geekosaur> [1]grant: it's using hGetContents behind the scenes
15:47:41 * dwcook wonders how hard it would be to implement a Teeworlds server in Haskell
15:47:57 <[1]grant> geekosaur: That means more to you than to me. Elaborate please?
15:48:05 <geekosaur> it returns everything ever sent on the socket, as a lazy String
15:48:17 <[1]grant> aaaaaaahhhh
15:48:23 <[1]grant> So how does it know when it stops?
15:48:31 <[1]grant> (networking noob here)
15:48:36 <[1]grant> Does the socket "close" or something?
15:48:39 <geekosaur> you hit the end of the String
15:48:52 <haasn> [1]grant: you should probably look up getContents and how it works
15:49:00 <geekosaur> after calling recvFrom you cannot use the socket any more, it is what Haskell lazy I/O calls "half closed"
15:49:05 <haasn> (which is similar, but for STDIN)
15:49:15 <[1]grant> aaaaah ok
15:49:19 <geekosaur> but you have a lazy String that will have contents as long as the sender writes data
15:49:35 <[1]grant> so let's say they are sending data at 1 byte per second to my socket
15:49:35 <geekosaur> and whne the sender closes the socket you will hit the end of the String
15:49:42 <[1]grant> will that just freeze the progrm as it reads it?
15:49:54 <geekosaur> no
15:50:23 <[1]grant> so let's say I call recvFrom and get a lazy string. I try to parse an http request out of this string.
15:50:34 <[1]grant> But the end of the string isn't available
15:50:38 <[1]grant> because they are sending data really slowly
15:50:55 <[1]grant> the parsing will just take as long as it takes them to send it?
15:51:01 <geekosaur> then your porgram keeps reading "in the background" until you get what you are looking for, yes
15:51:13 <[1]grant> gotcha
15:51:15 <geekosaur> if you're looking for defense against e.g. a slowloris attack, don't use lazy I/O
15:51:42 <[1]grant> could I use some sort of timer inside of the thread to defend against slowloris?
15:51:53 <geekosaur> this is perhaps the biggest flaw in lazy I/O: you cannot see or control the network connection, and you cannt distinguish a network error from EOF
15:51:56 <[1]grant> to kill the thread if it is below a certain rate
15:52:03 <geekosaur> not with lazy I/O
15:52:15 <[1]grant> Aaaah :(
15:52:20 <geekosaur> you've handed it off to the GHC runtime, which is not smart enough to do such things
15:52:24 <[1]grant> So what would the none lazy alternative been?
15:52:28 <[1]grant> be*
15:52:34 <benmachine> well hold on
15:52:36 <geekosaur> this is why all the major network packages use things like pipes or conduit
15:52:42 <benmachine> you can kill a thread if it's been alive too long
15:52:52 <benmachine> regardless of what it's doing
15:52:53 <[1]grant> ben: not measuring time, measuring rate of data transfer
15:53:30 <benmachine> hmmmm.
15:53:40 <[1]grant> So would you recommend pipes or conduit or what?
15:53:43 <geekosaur> lazy I/O is quick and dirty. if you want correct, use pipes or conduit
15:53:54 * hackagebot tasty 0.8 - Modern and extensible testing framework  http://hackage.haskell.org/package/tasty-0.8 (RomanCheplyaka)
15:53:56 * hackagebot tasty-smallcheck 0.8 - SmallCheck support for the Tasty test framework.  http://hackage.haskell.org/package/tasty-smallcheck-0.8 (RomanCheplyaka)
15:53:58 * hackagebot tasty-quickcheck 0.8 - QuickCheck support for the Tasty test framework.  http://hackage.haskell.org/package/tasty-quickcheck-0.8 (RomanCheplyaka)
15:54:00 * hackagebot tasty-hunit 0.8 - HUnit support for the Tasty test framework.  http://hackage.haskell.org/package/tasty-hunit-0.8 (RomanCheplyaka)
15:54:05 <benmachine> I'm still not convinced there's a problem
15:54:06 <haasn> geekosaur: so what's the status of http://hackage.haskell.org/package/network-2.4.2.2/docs/Network-Socket-ByteString.html#v:recvFrom ?
15:54:27 <geekosaur> haasn: that looks sane to me
15:54:30 <benmachine> any attempt you make to assess the data transfer rate of a lazy stream is going to be an estimate at best
15:54:35 <benmachine> but you /can/ estimate it
15:54:40 <geekosaur> I just wish the higher level interface didn't use the name for something else :/
15:54:47 <joe9> any emacs haskell-mode and structured-haskell-mode users?
15:54:49 <haasn> geekosaur: that I can agree with
15:54:52 <benmachine> however, lazy network IO sounds mad regardless
15:55:03 <geekosaur> it would be nice f they at leas documented that their recvFrom has nothing whatsoever to do with recv()/recvfrom()
15:55:03 <joe9> just want to check if anyone has got them both working.
15:55:04 <haasn> geekosaur: I would certainly change the name of recvFrom to something better, like getContents
15:55:10 <geekosaur> and same with sendT and send()/sendto()
15:55:52 <[1]grant> geekosaur: so which do you think is better to use, pipes or conduit?
15:56:01 <haasn> looks like pipes-network only supports TCP and only claims to support TCP
15:56:10 <geekosaur> I am probably not the person to ask about that
15:56:15 <yesthisisuser> but aren't these libraries built on top of Network?
15:56:18 <seksifemale> hi
15:56:22 <bernalex> anyone who know reactive-banana care to tell me how to change the timeout for this: http://lpaste.net/23501296539533312 ?
15:56:23 <geekosaur> I would be very surprised if either of them did UDP
15:56:32 <geekosaur> yesthisisuser, they are built on Network.Socket
15:56:44 <haasn> [1]grant: holy war territory, afaik both are popular, with conduit somewhat older and more widely used but pipes having a “more elegant” abstraction
15:56:54 <geekosaur> Network is a higher level interface which is somewhat at odds with what conduit and pipes do
15:56:55 <haasn> I personally like pipes but I don't have a lot of experience working with conduit
15:56:58 <bernalex> i.e. not in the timeoutAdd call, but after firing it. so I'll have buttons for in/decreasing the timeout.
15:57:41 <haasn> pipes-network is built on Network.Simple.TCP
15:58:08 <dwcook> You don't need to use pipes-network, you can make your own producer using whatever underlying interface you want
15:58:11 <haasn> which, ironically, uses Network.Socket in a way that to me seems compatible with UDP
15:58:15 <haasn> Maybe somebody should test it.
15:58:17 <bernalex> guess I'll re-read http://www.haskell.org/haskellwiki/FRP_explanation_using_reactive-banana tomorrow
15:58:37 <geekosaur> in general UDP datagram programming works differently enough that you don't really want either pipes or conduit or even normal lazy I/O like Network; they're all based around a network stream abstraction
15:58:45 <[1]grant> Mmmm usually I leave #haskell enlightened, but now I am so bloody confused... reading a pipes tutorial now...
15:58:48 <geekosaur> with UDP you get and deal with individual packets
15:58:55 * hackagebot tasty-golden 2.2.1 - Golden tests support for tasty  http://hackage.haskell.org/package/tasty-golden-2.2.1 (RomanCheplyaka)
15:58:57 <geekosaur> and you must deal with them that way
15:59:28 <dwcook> I'd say write a producer that yields the contents of each individual UDP packet
15:59:41 <dwcook> If you can find some way to get those
15:59:53 <Kaidelong> ukraine is mobilizing it's army =(
15:59:53 <geekosaur> [1]grant, for what it's worth you have just wandered into one of the harder corners of Haskell
16:00:05 <geekosaur> dwcook, can I tell packet boundaries?
16:00:10 <Kaidelong> oh wrong channel
16:00:11 <Kaidelong> sorry
16:00:26 <dwcook> geekosaur, that depends on the UDP interface you're using
16:00:27 <c_wraith> geekosaur: a datagram is the whole thing.
16:00:35 <geekosaur> certainly you could lump them into a stream, but you gave just made UDP pointless
16:00:57 <geekosaur> and you should be using TCP
16:00:57 <dwcook> geekosaur, how so?
16:01:00 <haasn> geekosaur: is the regular ‘recv’ function sensible with UDP?
16:01:01 <c_wraith> not at all
16:01:08 <c_wraith> You still don't have stream semantics
16:01:13 <c_wraith> You have datagram semantics
16:01:29 <geekosaur> c_wraith, I kinda feel like you wandered into a discussion without reading what is going on
16:01:56 <haasn> geekosaur: you can write a producer that models a stream of datagrams
16:02:01 <haasn> (not a stream of characters)
16:02:07 <geekosaur> but yes, it's stream vs. datagram semantics, and being able to lump datagrams into a stream is missing the point of datagrams
16:02:25 <dwcook> geekosaur, I'm pretty sure that using a UDP datagram producer is just as good as processing them manually
16:02:31 <geekosaur> haasn: the problem is, you do not necessarily have a stream of datagrams
16:02:49 <haasn> geekosaur: eg.?
16:03:10 <geekosaur> haasn: datagrams are connectionless
16:03:20 <geekosaur> every single packet can come from a different sender
16:03:24 <yesthisisuser> and unreliable
16:03:29 <chrisdotcode> can somebody help me refactor a whole bunch of filters: http://lpaste.net/100637
16:03:49 <haasn> geekosaur: but they still arrive in a certain order, no?
16:03:53 <geekosaur> no
16:03:58 <[1]grant> Well, I'll start reading this pipes tutorial and come back to cry in an hour or two, thanks for the thought food
16:04:02 <geekosaur> there is no order. there is no connection.
16:04:10 <monochrom> . o O ( they arrive in the order they arrive )
16:04:31 <geekosaur> there is also no error handling, so if a packet is lost then neithetr the sender nor the intended recipient know or can know
16:04:33 <c_wraith> geekosaur: so what?  Why does that mean you can't have a producer that just yields packets as they come in?
16:04:35 <haasn> geekosaur: but recvFrom only gives you one datagram at a time, no?
16:04:37 <dwcook> They do have an order, it's just not necessarily the same they're sent
16:04:37 <yesthisisuser> there is no way of knowing in which order udp packets will arrive
16:04:41 <yesthisisuser> or if they will arrive at all
16:04:43 <dwcook> and not every one sent is received
16:05:05 <haasn> yesthisisuser: tangent. they will still arrive in some order, whether or not you can predict that order in advance
16:05:46 <geekosaur> under some circumstances you may be able to pretend that they are a stream of some kind, but this is the same order of mistake as assuming that all strings represnrt UTF8
16:05:55 <monochrom> chrisdotcode: perhaps filter (\x -> all (x `in`) [userRealName x, userZipCode x, ...]) u
16:06:05 <monochrom> @type all
16:06:06 <lambdabot> (a -> Bool) -> [a] -> Bool
16:06:34 <dwcook> geekosaur, give an example of where a producer of datagrams would yield incorrect behavior
16:06:34 <c_wraith> geekosaur: What exactly do you think the difference is between a producer that yields datagrams as they arrive, and a loop that reads packets as they arrive?
16:06:45 <chrisdotcode> monochrom: that looks like  a pretty cool solution, thanks :D
16:06:52 <monochrom> \∩/
16:07:06 <geekosaur> let me put it this way
16:07:07 <yesthisisuser> haasn: well, ok but certain order implies "certainty" hehe...
16:07:11 <chrisdotcode> monochrom: correct me if I"m wrong, but you couldn't do anything with applicatives and lists to solve the problem, right?
16:07:36 <monochrom> I don't think applicative makes it simpler
16:07:37 <haasn> geekosaur: I don't see how you can possibly avoid giving datagrams some order, seeing as you're limited by the interface (recvFrom giving you datagrams one at a time). Stick them all in a producer in the same order you get them from recvFrom and tada, you have a stream of datagrams
16:07:40 <geekosaur> could you write a producer that can pack up everything you need to process a datagram, including sender information etc.? certainly
16:07:57 <geekosaur> *should* you? you're just oging to have to undo it to use it, so it's extra work to no purpose
16:08:21 <c_wraith> geekosaur: no purpose except being able to connect it to all the existing machinery
16:08:22 <geekosaur> absolutely if you think that's how you want to process datagrams, go ahead.
16:08:41 <geekosaur> but you will find that all that existing machinery mostly gets in the way
16:09:10 <haasn> P.for myProducer $ \d -> ...   -- I certainly would find this more useful than, say, writing my own recvFrom loop every time
16:09:21 <geekosaur> so let;s say you're reading NFS3 UDP packets
16:09:57 <geekosaur> now you have to process that stream of yours to reassemble multiple streams by sender, check the data inside the packets and possibly reorder those streams or request retransmission and buffer the parts you have
16:11:15 <geekosaur> or let's say you are handling streaming video, in that case you may actually be able to pretend it's a stream okay unless they're using a multicast-like trick in which case you need to again keep track of sequence and either reorder or more likely drop out of sequence stuff from multiple senders
16:12:52 <geekosaur> most of the machinery you have is designed for TCP streams, you need different machinery for UDP. maybe t would be worth writing such machinery, but last I checked there seemed to be a very strong focus on TCP and I wonder if UDP support that would end up being largely disjoint would even be accepted
16:13:01 <geekosaur> or, once accepted, maintained
16:13:19 <c_wraith> You have a very network-centric view of what conduit and pipes do
16:13:33 <c_wraith> They're not fundamentally networking libraries
16:13:38 <geekosaur> I have the strong impression they are both HTTP-centric
16:13:43 <c_wraith> Neither is
16:13:54 <haasn> pipes' Producer is fundamentally like a list transformer
16:14:13 <haasn> (Pipe is a bit more general, I think, I'm not sure what a good summarization would be)
16:14:52 <haasn> I don't think pipes even has support for http
16:15:16 <geekosaur> or perhaps I should say, they may not be HTTP centric by intent but the people using them seem largely HTTP focused
16:16:01 <geekosaur> enough that I seriously wonder if UDP specific machinery would bitrot rapidly if someone provided it'
16:16:04 <haasn> I think the primary use case is file I/O
16:16:13 <geekosaur> (I also have the impresison they still change fairly often...)
16:17:10 <c_wraith> Ultimately, it comes down to whether you want to write your own loop, or abstract out of it.
16:18:19 <c_wraith> Both of them are abstractions over loops that perform actions, giving a way to make them composable.
16:18:28 <dwcook> Don't producers have to loop anyway? Even if it's just forever doStuff
16:18:36 <c_wraith> they don't *have* to
16:18:42 <haasn> dwcook: producers can have an end
16:19:11 <dwcook> Sure they can, forever was just an example
16:19:34 <haasn> producers can also only produce a single value (no “looping”)
16:19:56 <dwcook> Fair enough
16:20:11 <Twey> bernalex: const x = \_ -> x
16:20:20 <dwcook> Producers seem a fair bit like lists, actually, though I'm not sure how to articulate why they're not lists
16:21:23 <dwcook> Probably has to do with the difference between the correct and incorrect ListT's
16:23:37 <haasn> dwcook: http://hackage.haskell.org/package/pipes-4.1.0/docs/Pipes.html#g:5
16:24:23 <dwcook> I know about that, in fact I alluded to it just now
16:24:32 <haasn> oh, I think I misread your statement slightly
16:26:01 <orzo_> is there a generalization of MaybeT and ListT for any Traversable base monad?
16:29:20 <haasn> ListT m a here looks like Empty | Cons a (ListT m a) | M (m (ListT m a))
16:29:25 <haasn> interesting
16:29:39 <roboguy_> orzo_: what do you mean?
16:29:49 <haasn> (and Producer a m r more generally like Pure r | M (m (Producer a m r)) | Cons a (Producer a m r)
16:37:09 <jle`> hi, anyone here familiar with pipes?
16:37:11 <jle`> oh
16:37:13 <jle`> just read up haha
16:37:48 <jle`> what's the best way to get a producer/stream of bits read from a file?
16:38:23 <jle`> i'd imagine it'd be like some pipe that takes a stream of word8's from bytestring or soemthing and thne yields each bit in order
16:38:51 <jle`> but i'm looking through pipes and pipes-binary and i'm not sure how exactly to get that pipe that reads word8's from a file one by one, even
16:40:07 <jle`> or pipes-bytestring
16:42:29 <bitraten> how can i use sepBy in parsec, if i am not sure if my text start with content or a seperator?
16:43:00 <haasn> jle`: you can repeatedly use ‘for’ to replace each ByteString by a producer of Word8, and each Word8 by a producer of bits
16:43:28 <jle`> haasn: that makes sense
16:43:39 <jle`> how can i get a producer that gives me each ByteString?
16:44:08 <haasn> jle`: Pipes.ByteString.fromHandle
16:46:33 <haasn> jle`: http://hackage.haskell.org/package/pipes-extra-0.2.0/docs/Control-Pipe-Binary.html
16:46:39 <haasn> this has a ‘bytes’ pipe
16:47:33 <haasn> so “fromHandle h >-> bytes” will be a producer of Word8s
16:48:31 <haasn> jle`: and you can bits out of that using something like toListOf (Data.Bits.Lens.bits) -- and turning that [Bool] into a producer
16:48:42 <haasn> although I'm suddenly not sure whether there's some function that turns a lens Fold into a producer
16:48:44 <haasn> that would be pretty cool
16:48:48 <haasn> alas, time to sleep
16:49:05 * geekosaur pokes the network bug tracker with a stick
16:50:10 <jle`> haasn: thanks :) i'll try it
16:50:28 <jle`> haasn: good night
16:55:24 <Algebr> Why does this not work?                                            data Check = Check {first::Row}
16:55:24 <Algebr>              deriving (Show)
16:55:24 <Algebr>  
16:55:24 <Algebr> type Row = Maybe String
16:55:56 <roboguy_> Algebr: what about it doesn't work?
16:55:57 <geekosaur> please don't paste into the channel
16:55:58 <Algebr> And I try to do let a = Check{first="bob"}, but
16:56:08 <Algebr> geekosaur: oh sorry.
16:56:21 <roboguy_> @where paste
16:56:21 <lambdabot> http://hpaste.org/new/haskell
16:56:27 <roboguy_> Algebr: ^ paste there
16:56:39 <geekosaur> since you didn't provide the error you are getting, I would want to cut and paste that but then I get IRC stuff with it. this is one reason we use pastebins
16:57:07 <geekosaur> (that, and if you paste too much either freenode will drop you for flooding or someone will kick you because it's the only way to stop a runaway paste)
16:57:25 <Algebr> geekosaur: oh wow, didn't know all that. Will do from now on, thanks
16:58:15 <Algebr> geekosaur: http://lpaste.net/100639
16:58:38 <geekosaur> so anyway, what is the error you are getting?
16:58:41 <roboguy_> Algebr: the first field is Maybe String not String
16:58:50 <roboguy_> Algebr: so you can't do Check{first="bob"}
16:59:09 <Algebr> roboguy_: but isn't maybe supposed to give me the value I gave it or Nothing?
16:59:14 <geekosaur> not exactly
16:59:25 <roboguy_> Algebr: you use Just when you have a value. so it would be Just "bob"
16:59:27 <geekosaur> it gives you (Just something) or (Nothing)
16:59:40 <geekosaur> "bob" is of type String, not Maybe String
16:59:49 <geekosaur> (Just "bob") is Maybe String
17:00:20 <Algebr> geekosaur: So Maybe doesn't default to Nothing? Also, Nothing is like null/Nones, right
17:00:35 <roboguy_> Algebr: what do you mean default?
17:00:50 <geekosaur> this design is deliberate so you are forced to deal with Maybe appropriately --- otherwise (a) it's harder to infer types when a string could be a String or a Maybe String, and (b) it's tooeasy to forget to handle the Nothing case
17:01:11 <geekosaur> so you must always be clear that you're working with a Maybe type, by using Just or Nothing
17:01:20 <dwcook> As a simple example of type inference getting harder, imagine trying to distinguish between Nothing and Just Nothing
17:01:43 <dwcook> (of type Maybe (Maybe a) for some a)
17:01:58 <Algebr> dwcook: whoa, I wouldn't even know how to go about that.
17:02:02 <prophile> shove in an implicit join, what could possibly go wrong
17:02:06 <dwcook> Algebr, neither would I
17:02:12 <prophile> worked for perl arrays
17:02:33 <geekosaur> perl doesn;t even know the difference between strings and numbers :p
17:02:56 <roboguy_> Algebr: exactly. which is why you have to explicitly say Just x and Nothing
17:03:35 <monochrom> I rather think that perl knows but lies to you
17:03:53 <geekosaur> well, yes, it's more complex than that. dualvars are just weird
17:04:40 <geekosaur> but at the same time it silently promotes the IV or the PV depending on what you used most recently, and you can't observe this easily
17:04:48 <cschneid> I'm building cabal as per the local (--user) instructions, and don't seem to be getting a cabal executable out the other end. Any idea of what's up?
17:05:20 <geekosaur> where are you looking for it?
17:05:21 <roboguy_> cschneid: are you building cabal-install?
17:05:32 <geekosaur> also, yes, is this Cabal or cabal-install?
17:05:50 <cschneid> roboguy_: no, cabal itself.
17:05:56 <geekosaur> the former is a library (and you should probably not replace the one that comes with your compiler, since it can mess up Template Haskell)
17:05:56 <cschneid> ahh, is that the thing that's getting me? :)
17:06:05 <geekosaur> cabal-install is the cabal command line program
17:06:06 <cschneid> geekosaur: cabal itself is shipped w/ ghc?
17:06:14 <cschneid> building ghc from scratch
17:06:24 <geekosaur> yes? it's the engine behind ghc-pkg, among other things
17:06:38 <cschneid> ok, I'll go do this right then :) thanks
17:07:14 <geekosaur> but again this is the Cabal library, not cabal the executable
17:07:35 <geekosaur> (and yes, this is horribly confusing naming)
17:08:22 <monochrom> it would be better if the executable's name were cabal-install.exe, too. but I guess "cabal-install install cabal-install" was too much.
17:08:39 <cschneid> heh, ya
17:08:57 <roboguy_> I hear they're going to change the naming to make it a little less confusing
17:09:24 <geekosaur> ...then it'll just be confusing to everyone who is used to the old names >.>
17:09:32 <pharaun> haha
17:09:37 <pharaun> can't ever win eh? :)
17:11:39 <monochrom> I think it's ok to rename.
17:13:08 <chrisw_> How do I use a Ptr to read pixel data from the OpenGL window? readPixels :: Position -> Size -> PixelData a -> IO ()
17:13:46 <chrisw_> The only constructor for PixelData is PixelData PixelFormat DataType (Ptr a)
17:14:17 <chrisw_> Any idea how to make a Ptr to some memory and readPixels into it?
17:17:00 <geekosaur> chrisw_: in general that's Foreign.Marshall.Array stuff, but I suspect you need to know internal OpenGL details to make sense of the pointed-to values
17:17:42 <bitraten> how can i make ghc look for installed modules in a sandbox?
17:19:18 <bergey> bitraten: something like: ghc -global-package-db -no-user-package-db -package-db .cabal-sandbox/x86_64-linux-ghc-7.6.3-packages.conf.d/
17:19:21 <chrisw_> Hmm, maybe there is an easier way to simply fetch the window and save it as a bitmap? I'm trying to use the gloss package because it has a simple interface for rotating and drawing bitmaps on screen. All I need is to be able to grab the image it drew.
17:23:22 <magicman> ... I've finally come to appreciate the complexity of the datatype maze that is the Data.Time hierarchy.
17:24:18 <magicman> A scheduling server I'm talking to allows a timezone as input, and the idea is that it'll return the slots with times converted to that timezone.
17:24:36 <Cale> magicman: Humans have made time into a complicated ridiculous mess.
17:24:39 <bitemyapp> magicman: what's the problem in this case?
17:25:08 <magicman> Except that it does not do that. It returns the slots with times converted to that timezone, sure enough, but it doesn't start at "now" (or somewhere at a slot containing "now").
17:25:46 <magicman> No. It starts at the time according to the argument timezone, interpreted as if it was in the server's timezone, and then re-formatted according to the argument timezone.
17:25:59 <bitemyapp> magicman: lpaste?
17:26:14 <magicman> The server being in EST, and my argument being UTC, it's 5 hours off >_<
17:26:22 <Cale> https://www.youtube.com/watch?v=-5wpm-gesOY -- here's a cheesy YouTube video which pretty accurately conveys the frustration everyone who has to deal with time zones has
17:26:41 <magicman> bitemyapp: Not a bug in my code. It's some crummy PHP thingy somewhere that doesn't know how to handle stuff :P
17:26:52 <magicman> (and I don't have the code of that anyway, I just have to talk to it)
17:27:57 <bitemyapp> oh.
17:28:21 <magicman> It also doesn't know the difference between CET and CEST, or between EST and EDT.
17:28:27 <bitemyapp> magicman: lol
17:28:39 <magicman> With the upcoming US timechange... yeah <_<
17:29:18 <magicman> Which is why I thought of always asking UTC no matter what (default is "server time"), but then I ran into that other issue.
17:30:50 <bitemyapp> magicman: UTC-by-default is indeed a good idea.
17:31:07 <bitemyapp> projection into the timezone the user cares about should, as much as possible, be a presentation layer concern.
17:31:14 <magicman> *nodnod*
17:31:36 <bitemyapp> it's one of those things you won't learn unless you get burnt or work on a really huge project.
17:36:19 <orzo_> Control.Monad.Trans.List transformer is too narrow. it uses Prelude.mapM and [] when it should use Traversable mapM and transform arbitrary traversables
17:39:10 * hackagebot webkitgtk3 0.12.5.3 - Binding to the Webkit library.  http://hackage.haskell.org/package/webkitgtk3-0.12.5.3 (HamishMackenzie)
17:39:12 * hackagebot webkitgtk3-javascriptcore 0.12.5.1 - JavaScriptCore FFI from webkitgtk  http://hackage.haskell.org/package/webkitgtk3-javascriptcore-0.12.5.1 (HamishMackenzie)
17:41:01 <jle`> orzo_: there are many things wrong with the transformers ListT
17:44:10 * hackagebot webkit 0.12.5.3 - Binding to the Webkit library.  http://hackage.haskell.org/package/webkit-0.12.5.3 (HamishMackenzie)
17:44:12 * hackagebot webkit-javascriptcore 0.12.5.1 - JavaScriptCore FFI from webkitgtk  http://hackage.haskell.org/package/webkit-javascriptcore-0.12.5.1 (HamishMackenzie)
17:44:57 <orzo_> i like to use do-notation for list and maybe, and then i have IO (Maybe a) and IO [a] and things that i want to mix in.  So a transformer comes to mind... but is there a clean way to write this stuff using just Traversable/Applicative?
17:45:43 <orzo_> i made a TraversableT which is similar to transformers ListT and lets me use do syntax similarly
17:45:55 <orzo_> but I dont think that makes for pretty code
17:46:00 <dwcook> orzo_, do blocks that can be turned to usages of applicative methods are a subset of do blocks. Care to show what you want to convert?
17:47:35 <orzo_> dwcook: http://lpaste.net/100640
17:47:55 <orzo_> that's a snippit from my program
17:47:57 <dwcook> You can't turn that whole thing into applicative, but maybe parts of it
17:48:26 <orzo_> liftNested = ListT there
17:48:29 <dwcook> The reason you can't is because you have part of it relying on the variables bound by <-
17:48:39 <dwcook> values of the variables*
17:48:48 <orzo_> i guess variables bound by <- can become variables bound by lambdas
17:49:21 <dwcook> Is there any particular reason you want to change it?
17:50:22 <orzo_> i think it would be better to habitually use Applictaive/Traversable than to habitually use ListT
17:50:52 <dwcook> This is a transformation that you can do: do { a' <- a ; b' <- b ; return (f a' b') } becomes f <$> a <*> b
17:51:08 <dwcook> You can do that for arbitrarily many bindings like that, I just showed the 2 case
17:51:31 <jle`> is there any reason why pipes doesn't have an Arrow interface?
17:52:50 <orzo_> dwcook: I think i can replace "user <- liftBase $ Map.keys cbu" with "for (Map.keys cbu) $ \user -> do"
17:53:29 <dwcook> I'm not familiar with liftBase and have only passing familiarity with pipes
17:55:29 <prophile> jle`: at a guess
17:55:36 <prophile> that would require Category as a superclass
17:55:43 <prophile> and there are two different possible Category instances for pipes
17:55:50 <prophile> which would mean making an arbitrary choice between the two
17:56:00 <jle`> ah
17:56:09 <jle`> i still do not understand it enough to really see
17:56:16 <jle`> but i keep on wanting to rely on arrow combinators everywhere
17:56:24 <jle`> just out of habit
17:56:50 <prophile> you could probably wrap it in an arrow container of some kind
17:56:59 <prophile> but you'd need to decide between >-> and >+>
17:57:09 <jle`> what does >+> do?
17:57:33 <prophile> http://hackage.haskell.org/package/pipes-4.1.0/docs/Pipes-Core.html#v:-62--43--62-
17:57:39 <jle`> ah
17:58:03 <jle`> i see, he explains that there are multipl categories
17:58:32 <jle`> five
17:58:47 <prophile> ah, the madness never ends
17:59:23 <jle`> heh
17:59:54 <jle`> what is the identity of >-> ?
18:00:44 <luite> oh cool ascii art :)
18:00:59 <joelteon> jle`: cat
18:01:13 <joelteon> meow
18:01:58 <jle`> oh haha that's cute
18:02:05 <jle`> just like unix cat
18:02:10 <joelteon> yeah
18:02:23 <jle`> i never realized that unix pipes formed a category with cat as the identity
18:06:24 <Earnestly> lol
18:06:36 <jle`> i should alias id = cat
18:06:43 <jle`> but id is already something
18:06:47 <Earnestly> Indeed
18:06:56 <joelteon> do you ever use id?
18:07:01 <Earnestly> Yes
18:07:09 <Earnestly> Oh, not asking me, nevermind \o
18:07:23 <jle`> joelteon: i don't, but i hope i don't mess up any scripts
18:07:36 <joelteon> just put it in your bashrc?
18:07:48 <Earnestly> jle`: (fwiw, no script should ever use `id` so you should be safe)
18:07:48 <jle`> oh does that not affect scripts?
18:07:56 <Earnestly> aliases don't, nope
18:08:11 <jle`> i read somewhere to not alias rm in case a script uses it
18:08:13 <Earnestly> Because scripts run non-interactively
18:08:50 <Earnestly> jle`: It was wrong, you can try it yourself if you want.  Just alias rm, and then run a script which does `type rm` and see what it says
18:09:03 <joelteon> i'm pretty sure scripts won't pick up your env files
18:09:29 <jle`> empiricism? blasphemy!
18:09:34 <Earnestly> It will use your env though (`env`)
18:09:38 <Earnestly> jle`: http://sprunge.us/aYSU
18:10:01 <jle`> Earnestly: thanks :)
18:10:05 <jle`> this blows my mind.
18:10:11 <Earnestly> The only way for a script to use aliases or your functions, is to source your .bashrc/shellrc
18:10:29 <jle`> ah.
18:10:32 <jle`> i see
18:10:34 <jle`> hm
18:10:35 <Earnestly> jle`: It's just the difference between interactive (prompt) and non-interactive (scripts)
18:10:54 <orzo_> dwcook: http://lpaste.net/100640
18:11:00 <jle`> is there an `arr` for pipes?
18:11:16 <jle`> to lift a pure function into a pipe that transforms its input using that function?
18:12:24 <orzo_> theres probably a better way than the fmap join . for stuff
18:12:57 <orzo_> i also had to bind two new variables: addrs and buds
18:13:15 <orzo_> my intuition is that a more direct conversion is possible
18:13:20 <levi> jle`: How did you manage to get so arrow-centric?  Did you start doing Haskel with an arrowized FRP library or something?
18:13:55 <Clint> jle`: Pipes.Prelude.map?
18:14:18 <levi> I just never hear people talking about arrows, except to say that they're not terribly useful.
18:15:22 <pharaun> i've used arrow with hxt i've found them to be alright, still not sure what to think about it
18:15:28 <jle`> levi: heh i hav been living in arrow world for a few months
18:15:32 <jle`> in AFRP
18:15:53 <jle`> it just feels like a natural way to deal with Categories
18:16:31 <levi> hxt and frp are the only things I've come across that use them, and I think people generally prefer applicative interfaces for those things now.
18:16:48 <Clint> hakyll used to
18:17:30 <Hodapp> hxt?
18:17:43 <jle`> so isntead of map i'd use <$> ?
18:19:31 <pharaun> oh i never got into hakyll till 4.0
18:19:37 <pharaun> so never got to mess with the arrow interface there
18:20:04 <Clint> it was prettier
18:21:40 <chirpsalot> Hmmm... Is there a single function which comes either in the prelude or the standard set of libraries that doesn't have any type variables in the signature?
18:21:56 <chirpsalot> OH! BOOLS!
18:22:09 <chirpsalot> Nevermind. Answered my own question :). Thanks. (&&)
18:22:13 <jle`> haha
18:22:24 <jle`> yeah sometims it's hard to think of non-polymorphic functions
18:22:45 <jle`> also consider the functions in Data.Char
18:22:46 <jle`> :t chr
18:22:47 <lambdabot> Int -> Char
18:23:30 <chirpsalot> jle`: ah that's a good one :). Thanks!
18:24:21 <chirpsalot> jle`: explaining to people, and I was like... "I can't think of anything without type variables... And I don't want to explain that juuuuuust yet."
18:24:59 <jle`> most people wave their hands
18:25:04 <jle`> with (+) and stuff
18:27:31 <chirpsalot> jle`: yeah. That's what I normally do, but I was like "can I avoid that..."
18:28:09 <jle`> heh
18:28:20 <jle`> in that case (&&) is probably a good example of it
18:28:35 <jle`> although we should really have generalized bools
18:28:39 <jle`> as a part of Prelude :P
18:29:20 <jle`> instance Truthy b where isTruty :: b -> Bool
18:29:35 <jle`> hm
18:29:40 <jle`> *class
18:30:14 <jle`> so then
18:30:25 <jle`> (&&) :: Truthy b => b -> b -> b
18:31:02 <jle`> x && y | isTruthy x = y | otherwise = x
18:31:21 <jle`> edwardk can you get this into base plz
18:31:36 <edwardk> =P
18:32:23 <jle`> we cannot have any monomorphic functions in prelude
18:38:37 <haasn> jle`: I'd rather have class Boolean b where (&&), (||) :: b -> b -> b; true, false :: b
18:38:53 <haasn> your version doesn't permit, say, Boolean b => (r -> b) as a valid instance
18:39:36 <dario> still ok for the "we cannot have any monomorphic functions in prelude" part ;-)
18:39:45 <hpc> true = \_ -> true
18:39:49 <hpc> false = \_ -> false
18:40:06 <hpc> (&&) a b p = (a p) && (b p)
18:40:09 <hpc> etc
18:40:46 <jle`> haasn: ah
18:41:05 <haasn> hpc: true = pure true; (&&) = liftA2 (&&) -- even more general
18:41:12 <jle`> that is much better :)
18:41:14 <jle`> but
18:41:20 <jle`> perhaps we can live with both
18:41:24 <jle`> Truthy matches more of Javascript's approach
18:41:26 <johnw> > join (&&) (==1) (==2) 1
18:41:27 <lambdabot>  Couldn't match type `(a1 -> GHC.Types.Bool) -> a2 -> t0'
18:41:27 <lambdabot>                with `GHC.Types.Bool'
18:41:27 <lambdabot>  Expected type: (a0 -> GHC.Types.Bool)
18:41:27 <lambdabot>                 -> (a0 -> GHC.Types.Bool) -> (a1 -> GHC.Types.Bool) -> a2 -> t0
18:41:27 <lambdabot>    Actual type: GHC.Types.Bool -> GHC.Types.Bool -> GHC.Types.Bool
18:41:34 <jle`> as its namsak
18:43:19 <haasn> edwardk: I'm struggling to find more rigorous intuition for Traversable types. A simple sufficient condition seems to be “A Functor t is Traversable if the fully expanded form of (t a) never contains any ‘a’ to the right of a function”
18:43:39 <haasn> But this is obviously not necessary, as eg. representable, traversable functors prove
18:45:11 <haasn> maybe something like “if for any occurrence ‘a’ on the right hand side of a function (r ->), ‘r’ is finite” but that's also not necessary, since (Nat -> a) aka Stream a should be a “valid” Traversable, no?
18:45:17 <sclv> don't representables fully characterize traversables?
18:45:31 <johnw> I believe any functor can also be made Traversable if you have a natural transformation: forall a. Functor f => f a -> [a]
18:45:32 <haasn> perhaps ‘r’ is enumerable, but “enumerable” isn't well-defined. Every type is enumerable in Haskell
18:45:56 <haasn> So theoretically, every sufficiently monomorphic Functor could be made a valid traversal
18:46:09 <johnw> yes, because with that transformation you can implement foldMap
18:46:22 <haasn> sclv: no, [a] is not representable
18:46:23 <johnw> (and vice-versa)
18:46:40 <sclv> haasn: oh right, oops :-)
18:46:57 <haasn> johnw: a Foldable, sure
18:47:07 <johnw> oh, oops :)
18:47:32 <prophile> you can't get traversable out of representables I don't think
18:47:35 <prophile> that would be distributive
18:47:41 <sclv> right i had it backwards
18:48:15 <haasn> prophile: I'm quite sure you can make a traversable instance for every representable functor, if that's what you meant
18:48:42 <prophile> really?
18:49:01 <haasn> edwardk: come to think of it, if you want to traverse over (r ->) you also need to be able to “reconstruct” the function which also somehow implies Eq, I guess
18:49:16 <prophile> I'm relatively confident you can't
18:49:51 <haasn> prophile: representable functors are isomorphic to (s, a, a, a, a, ...) for some fixed number of ‘a’ and an abstract ‘s’; just traverse over all of the ‘a’s
18:50:03 <sclv> traversables "push in", representables "pull out"
18:50:49 <haasn> oh, but I guess that also includes infinite ‘a’s
18:51:02 <jle`> haasn: for my Truthy
18:51:09 <jle`> i was thinking about an instance like Maybe a
18:51:09 <prophile> streams are representable but I don't see any Traversable instances for them
18:51:28 <jle`> i don't think you can instance maybe a using your Boolean?
18:51:34 <jle`> what would true be?
18:51:35 <haasn> prophile: a traversal instance for streams is certainly law-abiding; in that Identity and Const on streams behave as fmap/fold
18:51:51 <prophile> ah, I withdraw the previous statement, ekmett's streams package does have them ^^
18:51:53 <jle`> even something like Either b a
18:52:18 <haasn> prophile: a better counter-example would be ((->) e) which is quite certainly representable
18:52:25 <haasn> but a traversable instance for them requires knowing certain things about ‘e’
18:52:38 <sclv> sequence :: Stream (IO a) -> IO (Stream a) -- sorta janky?
18:52:44 <sclv> that's a good counterexample
18:52:52 <haasn> sclv: it would be _|_
18:52:59 <haasn> since IO is too strict
18:53:05 <sclv> right the famous infinitraversals debate :-)
18:53:08 <haasn> but it's no less silly than [IO a] -> IO [a] for infinite lists
18:55:15 <jle`> how do i turn a Bytestring Producer to a Word8 producer in pipes?
18:55:19 <c_wraith> :t let unsafeSequence f = sequence . map unsafeInterleaveIO in unsafeSequencce
18:55:20 <lambdabot> Not in scope: `unsafeInterleaveIO'
18:55:20 <lambdabot>     Not in scope: `unsafeSequencce'
18:55:20 <lambdabot>     Perhaps you meant `unsafeSequence' (line 1)
18:55:30 <c_wraith> no unsafeInterleaveIO?  boo!
18:55:42 <sclv> so consider the basic counterexample (Bool -> a). (Bool -> Maybe a) -> Maybe (Bool -> a)
18:55:49 <haasn> edwardk: what's the actual distinction between Data.Stream.Future and Data.List.NonEmpty?
18:56:05 <prophile> :t System.IO.Unsafe.unsafeInterleaveIO
18:56:06 <lambdabot> IO a -> IO a
18:56:10 <prophile> ^
18:56:11 <c_wraith> Oh, there it is
18:56:19 <sclv> oh wait maybe that works.
18:56:22 <c_wraith> :t let unsafeSequence f = sequence . map System.IO.Unsafe.unsafeInterleaveIO in unsafeSequence
18:56:23 <lambdabot> t -> [IO a] -> IO [a]
18:56:31 <sclv> i take it back
18:56:33 <haasn> oh, tail is a bit different
18:56:39 <c_wraith> err..  why do I have an f in there?  I'm all confused
18:56:41 <c_wraith> anyway
18:57:11 <c_wraith> jle`: it's going to be something like B.mapM_ yield
18:57:23 <edwardk> data NonEmpty a = a :| [a]       data Future a = Last a | a :< Future a   -- the former is nicer for end users, the latter is easier to reason about recursively
18:57:32 <edwardk> they are of course isomorphic
18:57:38 <jle`> c_wraith: ty
18:57:42 <haasn> edwardk: including instances?
18:57:49 <sclv> so wtf is a concrete counterexample to traversable -- i.e. disallowing ((->) e) since i relies on "not knowing e"
18:57:59 <c_wraith> jle`: huh.  there is no B.mapM_
18:58:00 <edwardk> the instances should all do the same things as i recall
18:58:12 <prophile> presumably any e that you can't enumerate through
18:58:16 <c_wraith> jle`: ok, that makes it mapM_ yield . unpack
18:58:21 <prophile> ((->) (Int -> Int)) perhaps
18:58:27 <haasn> c_wraith/jle`: wait wait wait
18:58:44 <edwardk> sclv: well, (->) e  is the canonical counter-example. whenever 'e' is big enough you can't enumerate it within the language
18:58:52 <c_wraith> haasn: I'm waiting!
18:58:56 <prophile> maybe ((->) (Integer -> Integer)) since Int -> Int probably can be enumerated
18:59:01 <haasn> c_wraith/jle`: http://hackage.haskell.org/package/pipes-extra-0.2.0/docs/Control-Pipe-Binary.html#v:bytes
18:59:07 <haasn> Didn't I link this to jle` earlier already? :P
18:59:14 <sclv> edwardk: right but i'm not looking for an internal counterexample now
18:59:19 <sclv> i'm looking for an _external_ one
18:59:25 <c_wraith> oh.  Something that solves the problem directly? psh.
18:59:27 <sclv> just to be a pain
18:59:33 <haasn> c_wraith: fwiw it uses B.foldl
18:59:45 <haasn> and >>
18:59:51 <haasn> might as well have been mapM_ I guess
19:00:00 <jle`> haasn: heh sorry
19:00:07 <jle`> i just ctrl+f'd word8 and found it
19:00:11 <edwardk> well traversability also requires a selected ordering to the elements
19:00:15 <c_wraith> haasn: that's because it's a bit smarter than my code. It actually does the await that I forgot about
19:00:19 <jle`> ty again
19:00:48 <edwardk> so maybe start with things you can't do that to
19:01:24 <sclv> again, we can externally
19:01:35 <haasn> c_wraith: not that it's strictly necessary, it might actually be more idiomatic to use `for` \b -> mapM_ ...
19:01:36 <sclv> hrm
19:01:54 <haasn> assuming GHC is kind enough to get rid of the [] intermediate structure for us :)
19:02:05 <haasn> (or B.foldl)
19:02:23 <c_wraith> haasn: I'm pretty sure B.unpack fuses.  mapM_ ought to fuse, too
19:02:40 <haasn> I wonder how much more efficient (for p f) is than (p >-> forever (await >>= f))
19:03:38 <haasn> I wonder why the latter pattern actually exists
19:04:29 <mrmonday> is there some way to get permutations of a certain size for a list? eg given [a] I want it cut into 10 slices, then I want the permutations of each of those slices
19:04:34 <saml> what's letter pattern?
19:05:00 <saml> @type permutation
19:05:01 <lambdabot>     Not in scope: `permutation'
19:05:01 <lambdabot>     Perhaps you meant `permutations' (imported from Data.List)
19:05:05 <c_wraith> mrmonday: Datal.List has permutations
19:05:13 <c_wraith> mrmonday: then all you need to do is slice it up the way you want
19:05:17 <saml> > Data.List.permutations "hello"
19:05:18 <haasn> Data.List.Split has chunksOf
19:05:18 <lambdabot>  ["hello","ehllo","lehlo","elhlo","lhelo","hlelo","lleho","lleho","lelho","le...
19:07:12 <mrmonday> thanks :)
19:07:52 <saml> you're welcome
19:22:41 <haasn> edwardk: do you know if we have integration for ‘lens’ with pipes? eg. creating a producer from anything that can be folded, akin to fromList . toListOf
19:22:57 <haasn> P.fromList . L.toListOf l -- that is
19:23:09 <edwardk> there is some nascent lens support in pipes, but i haven't looked into it at all
19:23:21 <haasn> I know pipes provides a fair amount of lenses
19:23:31 <edwardk> lens itself doesn't know pipes exists, so we don't have it
19:23:50 <haasn> right, and this would be a pipes thing not a lens thing (since we're not providing lenses, we're providing pipes)
19:25:17 <haasn> I wonder why Pipes.Concurrent uses STM (Maybe a) for its producers and not Producer' a STM ()
19:25:34 <haasn> seems like a Producer' living inside STM would have access to exactly these kinds of effects
19:26:52 <pingu> haasn: I think it's just because it's a wrapper around recv :: Input a -> STM (Maybe a)
19:27:05 <haasn> fair enough
19:27:24 <pingu> but I have no idea. that's a guess.
19:35:40 <_flatline_> If I have two function arguments that evaluate to the same value, is there a way to specify that in one line rather than pattern match both of them individually?
19:36:05 <Iceland_jack> _flatline_: Are they instances of Eq?
19:36:27 <Iceland_jack>     foo x y | x == y    = ...
19:36:27 <Iceland_jack>             | otherwise = ...
19:36:48 <_flatline_> No, I mean like
19:37:32 <_flatline_> Nvm
19:37:56 <_flatline_> Ok not nvm
19:38:04 <_flatline_> The function doesn't take two arguments
19:38:09 <geekosaur> you can't write a pattern which tests value equality
19:38:11 <Iceland_jack> I apologize if I misunderstood your question
19:38:12 <_flatline_> it's more like f x = a
19:38:14 <_flatline_> and f y = a
19:38:16 <Iceland_jack> but Haskell doesn't have linear patterns
19:39:14 <_flatline_> ah k
19:39:16 <_flatline_> thanks
19:40:02 <Iceland_jack> I mean to say that Haskell *does* have linear patterns :)
19:40:29 <Clint> _flatline_: you want something like f x | x `elem` [3,4,5] = 4 ?
20:05:04 <gamegoblin> Howdy folks, playing with making a server. Is there a unix tool that would allow me to send a string to a server?
20:05:28 <geekosaur> nc? telnet?
20:05:52 <gamegoblin> i.e. some_command 123.123.123.123:1337 "please echo this back"
20:05:55 <gamegoblin> netcat can do that?
20:06:13 <geekosaur> echo some string | nc ...
20:06:22 <gamegoblin> gotcha thanks
20:06:29 <geekosaur> or in bash/zsh, nc ... <<< 'please echo this back'
20:06:41 <gamegoblin> playing with those pipes you guys mentioned earlier
20:06:50 <gamegoblin> I was grant[0] by the way
20:06:54 <gamegoblin> or whatever it defaulted my nick to
20:07:02 <gamegoblin> grant__
20:07:06 <gamegoblin> Not sure
20:07:18 <gamegoblin> We talked about recvFrom and you ranted about why it was poorly named
20:07:27 <Clint> [1]grant
20:07:42 <gamegoblin> sounds right
20:08:12 <gamegoblin> Had to pop into Python but it doesn't let you chat without registering
20:08:38 <Earnestly> Helps cut down on the spam
20:08:51 <gamegoblin> I imagine python gets a lot more of that than Haskell
20:09:29 * hackagebot identifiers 0.3.0.0 - Numeric identifiers for values.  http://hackage.haskell.org/package/identifiers-0.3.0.0 (awagner83)
20:10:12 <Earnestly> gamegoblin: I mean bots which spam malware/fishing links
20:10:14 <gamegoblin> Does hackagebot echo new uploads to hackage or...?
20:10:17 <gamegoblin> aaaah gotcha
20:14:29 <jle`> what's the best way to make a pipe that accumulates a state and outputs the 'last' return value?  i have been doing it using recursion but is there a more idiomatic ay?
20:16:37 <levi> I'm not sure what you mean by 'outputs' in the context of pipes. Do you mean that it yields the latest state downstream, or that it exits with the accumulated value, or what?
20:16:40 <jle`> for example, a pipe that outputs the sum of all numbers that have passed through it so far
20:16:56 <jle`> using recursion it'd be something like..
20:16:56 <johnw> well, in conduit i'd use "fold"
20:17:09 <gamegoblin> pipes has fold also, I believe
20:17:31 <johnw> i'm certain it does, I just don't know what Tekmo calls it
20:17:32 <jle`> ah ok
20:17:48 <levi> There are probably 20 different ways you could write any particular thing in pipes. ;)
20:18:08 <jle`> sumall n = await >>= \x -> yield (n + x) >> sumall (n + x)
20:19:55 <gamegoblin> I love that the pipes lib doesn't have any tests, and tekmo just mathematically proved its correctness
20:20:47 <jle`> what would be the most pipesy way?
20:21:06 <jle`> it looks like fold is nice
20:21:29 <gamegoblin> I think fold is the most elegant way to go
20:24:34 <johnw> gamegoblin: if only that meant it was correct :)
20:26:51 <jle`> fold have the same interface that i was looking for
20:26:59 <jle`> but it will probably force m to be more idiomatic
20:29:53 <jle`> i am fixated on composition
20:31:36 <sinelaw> for frp they make intuitive sense
20:31:52 <gamegoblin> geekosaur: I finally understand what you were saying about lazy IO with networking. Using netcat I sent 1 line of a file at a time with a 5 second delay between to a socket that I'd called hGetContents on, and sure enough it waited until the entire file had sent to print it out
20:31:55 <jle`> i just think it makes sens to do producer >-> summer
20:32:02 * sinelaw replied to a message from the top of his buffer. damn scrollbar
20:32:02 <jle`> instead of summer producer
20:32:20 <jle`> oh what you said made sense as a response to my last message >.<
20:33:14 <sinelaw> I feel like the old markov bot
20:34:02 <dwcook> gamegoblin, that seems to me like an example of non-lazy IO, or am I thinking about it wrong?
20:34:28 <gamegoblin> dwcook: I have a line that says "read all the content from this socket" which returns a lazy string
20:34:35 <gamegoblin> the next line says print all the content out
20:35:13 <gamegoblin> It seems to me that if it were eager it'd grab all the content currently in it, and then print it out
20:35:25 <dwcook> gamegoblin, it seems like either the hGetContents isn't returning a result until it has everything, or the print isn't printing until it has everything. One or the other is not lazy.
20:35:29 <gamegoblin> but the hGetContents waies for EOF
20:35:34 <geekosaur> no]
20:35:52 <gamegoblin> hGetContents waits until it gets EOF I believe
20:35:53 <geekosaur> hGetContents returns a magic lazy string which delivers content as it becomes available
20:36:00 <gamegoblin> ooo
20:36:05 <geekosaur> it does not wait for EOF, that would be strict I/O
20:36:11 <gamegoblin> Aaah ok
20:36:32 <dwcook> Then the print waits for everything?
20:36:39 <gamegoblin> terminology. Regardless, I thought it would just grab the extant content and continue on with life.
20:36:48 <dwcook> gamegoblin, how are you printing it?
20:36:52 <gamegoblin> putStrLn
20:37:04 <dwcook> In fact, showing the whole program might be useful
20:37:05 <geekosaur> *but* whatever you may be doing with that string may not actually produce output immediately, in particular if you have code that looks for newlines (perhaps implicitly via line or block buffering) then you may only see output in chunks
20:37:12 <dwcook> Oh, I bet it has to do with buffering then
20:37:38 <gamegoblin> I activated NoBuffering
20:37:51 <gamegoblin> Here is the code if you want to play with it:
20:37:53 <dwcook> gamegoblin, mind showing the code? This makes no sense to me and I want to play with it
20:37:56 <geekosaur> then I think we'd have to see your code
20:38:25 <geekosaur> but it's ridiculously easy to do things that are stricter than you actually need, if you're not careful
20:39:02 <gamegoblin> one sec
20:39:42 <gamegoblin> code: http://lpaste.net/100643
20:40:05 <gamegoblin> I'm still wrapping my head around lazy programming myself
20:40:13 <gamegoblin> I'm an eager boy grown up in an eager world
20:40:39 <c_wraith> Rmember..  Be lazy *with class*.
20:40:40 <dwcook> A good question is how netcat buffers
20:41:54 <gamegoblin> If I comment out the NoBuffering line it seems to behave the same?
20:41:57 <geekosaur> that's a good point too
20:42:07 <dwcook> I'm definitely not getting the behavior you described; I'm getting line at a time since netcat is line buffered
20:42:18 <geekosaur> it doesn't matter what buffering si in your program if netcat is serving up buffered output
20:42:53 <dwcook> Oh, the interval option doesn't seem to behave as expected
20:43:01 <dwcook> This is a problem with using netcat, not with lazy IO
20:43:09 <gamegoblin> aaaah
20:43:19 <gamegoblin> Any other unix tools I could use?
20:43:32 <dwcook> netcat is fine, just the way you're using it might not do what you want
20:43:48 <gamegoblin> I'd like to simulate doing something like sending data really slowly
20:44:11 <geekosaur> there are programs to do that, look for web server testers
20:44:33 <geekosaur> they're not like standard unix utilities but you can probably install them readily enough
20:45:16 <gamegoblin> Could I just write a small program to do it?
20:45:34 <gamegoblin> since it's a pretty specific little task I want to play with
20:46:35 <dwcook> I don't see why not
20:47:33 <dwcook> You could use Control.Concurrent.threadDelay for the waiting
20:48:45 <gamegoblin> Quick and dirty... just going to use python where I am not a novice T_T (hangs head in shame)
20:49:04 <dwcook> You could probably learn to do it in Haskell in like ten minutes
20:49:09 <dwcook> But that's fine
20:49:32 <geekosaur> well, except they're doing it in part to understand the haskell they've already written :[
20:49:34 <geekosaur> er :p
21:05:14 <ij> I want something of type [[Integer]] that'd give me [[0,0,0], [1,0,0], [0,1,0]..], and basically would keep on counting. Where could I get one/are my intentions clear?
21:06:30 <Iceland_jack> ij: replicateM 3 [0,1]
21:06:36 <Iceland_jack> where replicateM is from Control.Monad
21:06:40 <Iceland_jack> > replicateM 3 [0,1]
21:06:41 <lambdabot>  [[0,0,0],[0,0,1],[0,1,0],[0,1,1],[1,0,0],[1,0,1],[1,1,0],[1,1,1]]
21:06:51 <Iceland_jack> it's not in the order you wanted though
21:06:59 <ij> That order will do too, thanks!
21:07:03 <Iceland_jack> :)
21:07:30 <chrisw> Does anyone know how to save a screenshot to file using the gloss package? Either there is no convenient function, or I can't find it.
21:09:12 <roboguy_> Iceland_jack: there wouldn't be something like that that would only result "unique" sequences is there (i.e., it would either have [1,1,0] or [0,1,1] but not both)?
21:09:57 <ij> Iceland_jack, If the numbers were big (rM 8 [0..199]), would dropping a branch cost me much time?
21:10:52 <ij> hmmmm
21:11:15 <ij> that probably makes no sense
21:19:19 <Fuuzetsu> There seem to be no libraries dealing with video decoding (such as dumping individual frames as images), is there a library I'm overlooking?
21:19:44 <dwcook> roboguy_, you could try turning the (Num a) => [[a]] into a (Num a) => Set (Set a)
21:20:22 <roboguy_> dwcook: it would probably be Set [a], but I'm not sure how efficient that would be...
21:20:28 <ij> Say I have replicateM 8 [0..199]. They're coefficients for some function, such that f [0,0,5,0] == 90000, f [1,0,0,0] == 500. So i would like to have the rM steps from [0,0,5,0] to [0,0,199,0] skipped so that I c'd get to [0,1,0,0]. Any simple ways to go about doing that?
21:20:42 <dwcook> roboguy_, no, because then [1,1,0] and [0,1,1] aren't equal
21:21:04 <roboguy_> dwcook: oh right. but then neither of them can exist
21:21:14 <dwcook> roboguy_, why do you say that?
21:21:39 <dwcook> roboguy_, or how about Data.List.nubBy?
21:21:45 <roboguy_> dwcook: Set.fromList [1,1,0] == Set.fromList [1,0]
21:22:02 <dwcook> Oh, good point. Then nubBy for sure
21:22:55 <roboguy_> well, I want to generate fewer elements to make things more efficient and I'm not sure that nubBy would be very efficient
21:22:59 <cmears> ij, I think you'd need to discard "replicateM" and choose the values one-by-one, perhaps sticking in a "guard" between choices to filter any values you want to skip
21:23:45 <dwcook> roboguy_, might not be possible
21:24:03 <dwcook> Well no, it could be possible but maybe with a space tradeoff
21:24:05 <ij> cmears, Hmm, thought so. Thanks for the input.
21:24:20 <cmears> ij, you're welcome, good luck! (:
21:24:37 * hackagebot time 1.4.2 - A time library  http://hackage.haskell.org/package/time-1.4.2 (AshleyYakeley)
21:29:49 <gamegoblin> dumb IO question: I have a string that I want to print out 1 char at a time. map putChar mystring isn't it. What is?
21:30:21 <artyomkazak> mapM_ putChar mystring ?
21:30:31 <artyomkazak> or do you also need a delay between characters?
21:30:34 <gamegoblin> That's it
21:30:39 <gamegoblin> Thanks :D
21:30:58 <Iceland_jack>     forM_ mystring (\ch -> putChar ch; threadDelay delay)
21:31:01 <gamegoblin> tried mapM but it didn't work. Didn't know about mapM_
21:31:03 <Iceland_jack> *do putChar
21:31:12 <gamegoblin> :t mapM_
21:31:13 <lambdabot> Monad m => (a -> m b) -> [a] -> m ()
21:31:22 <Iceland_jack> @src forM_
21:31:22 <lambdabot> forM_ = flip mapM_
21:31:30 <cmears> mapM_ is the same as mapM, but it throws away the returned value
21:31:47 <cmears> (which is just what you want, because putChar doesn't return anything useful)
21:31:47 <gamegoblin> ahhh so if I'd have stuck a return () after the mapM it would have worked?
21:31:55 <cmears> probably
21:32:03 <gamegoblin> (that was the last line in the do block)
21:32:04 <ij> Can I ask haskell how somehow gets reduced from replicateM 3 [0,1] to the final form? I know I can find source, but I just want to see it get reduced visually.
21:32:09 <cmears> then yes (:
21:32:23 <Iceland_jack> ij: Do you understand monads?
21:32:27 <Iceland_jack> The list monad in particular?
21:32:29 <roboguy_> :t mapM putChar
21:32:30 <lambdabot> [Char] -> IO [()]
21:33:29 <ij> I know >>= for list is a concatMap, isn't it
21:33:42 <Iceland_jack> flip concatMap, yes
21:33:51 <Fuuzetsu> @seen ksf
21:33:51 <lambdabot> kSf
21:33:56 <Iceland_jack>     replicateM 3 [0,1]
21:33:56 <Iceland_jack> is the same as
21:33:56 <Iceland_jack>     sequence (replicate 3 [0,1])
21:33:58 <Fuuzetsu> @lastseen ksf
21:33:58 <lambdabot> Unknown command, try @list
21:34:05 <Fuuzetsu> I swear there was a command for this.
21:34:10 <ij> Yeah, I saw that in @src.
21:34:15 <Iceland_jack> which is the same as
21:34:15 <Iceland_jack>     sequence [[0,1], [0,1], [0,1]]
21:34:43 <pavonia> preflex had a seen command
21:34:48 <Iceland_jack> which is the same as
21:34:48 <Iceland_jack>     [ [x, y, z] | x <- [0,1], y <- [0,1], z <- [0,1] ]
21:35:13 <ij> That's still sugar.
21:35:18 <Iceland_jack> sure
21:35:39 <Iceland_jack> but since you know bind is flip concatMap you can figure the rest out from there
21:35:50 <roboguy_> @undo [ [x, y, z] | x <- [0,1], y <- [0,1], z <- [0,1] ]
21:35:50 <lambdabot> concatMap (\ x -> concatMap (\ y -> concatMap (\ z -> [[x, y, z]]) [0, 1]) [0, 1]) [0, 1]
21:36:04 <Iceland_jack> ..or just have lambdabot do the actual work :)
21:36:10 <ij> Well see yeah, I can ask you and I can reduce in my he... so it's just @undo?
21:36:11 <roboguy_> oh oops sorry
21:36:23 <Iceland_jack> haha it's fine roboguy_
21:36:30 <ij> That's what I wanted to know.
21:36:46 <Iceland_jack> The list comprehension probably gives the best intuitive understanding
21:37:02 <Iceland_jack> sequence builds up a monadic list from a list of monadic actions
21:37:17 <Iceland_jack> @ty sequence :: [[a]] -> [[a]]
21:37:18 <lambdabot> [[a]] -> [[a]]
21:38:32 <gamegoblin> geekosaur: still around?
21:38:45 <Iceland_jack> So if you have
21:38:45 <Iceland_jack>     sequence [a, b, c, ..., z]
21:38:45 <Iceland_jack> which returns a list where first elements are picked from a, second elements are picked from b, ... etc.
21:38:58 <Iceland_jack> > sequence ["ABC", "abc", "012"]
21:38:59 <lambdabot>  ["Aa0","Aa1","Aa2","Ab0","Ab1","Ab2","Ac0","Ac1","Ac2","Ba0","Ba1","Ba2","Bb...
21:39:06 <ij> Ah, I now got it, finally.
21:39:13 <Iceland_jack> ij: :) good
21:40:56 <Iceland_jack> Aaannd just to hit the point home
21:40:56 <Iceland_jack> > do x <- [0,1]; y <- [0,1]; z <- [0,1]; return [x, y, z]
21:40:58 <lambdabot>  [[0,0,0],[0,0,1],[0,1,0],[0,1,1],[1,0,0],[1,0,1],[1,1,0],[1,1,1]]
21:41:59 <Iceland_jack> and
21:41:59 <Iceland_jack> > [0,1] >>= \x -> [0,1] >>= \y -> [0,1] >>= \z -> return [x, y, z]
21:42:00 <lambdabot>  [[0,0,0],[0,0,1],[0,1,0],[0,1,1],[1,0,0],[1,0,1],[1,1,0],[1,1,1]]
21:42:20 <Iceland_jack> where
21:42:20 <Iceland_jack>     return [x, y, z]
21:42:20 <Iceland_jack> is the singleton list
21:42:20 <Iceland_jack>     [[x, y, z]]
21:43:43 <jowens> stupid question: I have two lists of equal length; I want the pairwise maximum. how do i get that? (e.g. input is [0,3] and [1,2], output is [1,3]; zip gives me a tuple and not sure how to take maximum of a tuple; I want "zipWith (:)" but that needs a list as the second arg, can't do 0:1).
21:43:57 <Iceland_jack> zipWith max?
21:43:59 <dwcook> jowens, zipWith max
21:44:02 <jowens> there ya go
21:44:04 <Iceland_jack> > zipWith max [0,3] [1,2]
21:44:06 <lambdabot>  [1,3]
21:44:09 <jowens> thx
21:44:10 <dwcook> > zipWith max [0,3] [1,2]
21:44:11 <lambdabot>  [1,3]
21:46:06 <ij> Do syntax is weird.
21:46:27 <Iceland_jack> Not very, think of it as a list comprehension
21:46:57 <Iceland_jack>     do x ← [0,1]
21:46:57 <Iceland_jack>        y ← [0,1]
21:46:58 <Iceland_jack>        z ← [0,1]
21:46:58 <Iceland_jack>        return [x, y, z]
21:47:01 <Iceland_jack> versus
21:47:03 <ij> Yeah, but well it does not do only that.
21:47:04 <Iceland_jack>     [ [x, y, z] | x ← [0,1], y ← [0,1], z ← [0,1] ]
21:47:13 <Iceland_jack> What else does it do?
21:47:22 <ij> >> on do print this; print that
21:47:41 <Iceland_jack> You can have monadic list comprehensions
21:48:00 <Iceland_jack> We're talking about the list monad here though
21:48:39 <ij> So you're saying this is a case of list comprh. as well?
21:48:50 <Iceland_jack> ‘this’ what?
21:48:54 <roboguy_> there are really only two things in do notation: do a monadic action and store the result (with <-) or do a monadic action and don't store it's result
21:49:23 <Iceland_jack> ij: You can write
21:49:23 <Iceland_jack>     [ () | _ ← print "hi",
21:49:23 <Iceland_jack>            _ ← print "bye" ]
21:49:37 <Iceland_jack> And it has type IO ()
21:50:18 <roboguy_> don'y you need MonadComprehensions turned on for that?
21:50:22 <Iceland_jack> Yes you do
21:53:15 <Iceland_jack> Just to show that you aren't limited to the list monad for comprehensions
21:53:30 <Fuuzetsu> What are some good use cases for MonadComprehenensions? I don't think I've seen any (and I think MonadComprehensions were a thing in the past but got removed, right?)
21:53:58 <levi> Yeah, they were there and then they were removed, and now they're back.
21:54:10 <Iceland_jack> Fuuzetsu: They were more useful back in the day before do-notation
21:54:38 <Fuuzetsu> I can't say I've been around long enough to imagine Haskell without do-notation.
21:55:06 <Fuuzetsu> Although I do cry a little when using monads in Agda which doesn't have do notation so I imagine it's a bit like that.
21:55:55 <levi> Imagine what it was like before Functor and Monad, and type classes on kinds other than * in general.
21:56:16 <Iceland_jack> Fuuzetsu: You can get close https://lists.chalmers.se/pipermail/agda/2011/003430.html
21:58:35 <Fuuzetsu> Iceland_jack: eh, I actually just defined do_ to be identity and _↯_ to be _>>_, it worked out fine
21:59:20 <augur> can anyone explain generalized de bruijn indices?
22:00:23 <Fuuzetsu> I didn't know ‘syntax’ keyword was a thing in Agda
22:06:36 <pavonia> augur: Where did you came across these?
22:06:57 <augur> pavonia: edwardk uses them for Bound
22:06:57 <pavonia> *come
22:07:30 <augur> but i dont get the general structure/nature of them, especially from a type-theoretic standpoint
22:19:40 <shalom> \help join
22:32:24 <NemesisD> when writing an arbitrary using the monadic style, i'm doing (msg :: Message) <- arbitrary; (pred :: Predicate) <- arbitrary fails. the first use of arbitrary decides all future ones in the monad it seems
22:33:24 <NemesisD> oh wait i've got it backwards i think. the monad instance is on Gen a
22:33:28 <Iceland_jack> NemesisD: That shouldn't be the case
22:33:28 <Iceland_jack> @ty do int <- arbitrary :: Gen Int; bool <- arbitrary :: Gen Bool; return (int, bool)
22:33:29 <lambdabot> Gen (Int, Bool)
22:33:54 <NemesisD> ah so if i do it as a tuple i can get around this restriction
22:34:02 <Iceland_jack> No that's not the issue
22:34:29 <Iceland_jack> where are you actually having problems NemesisD?
22:34:52 <NemesisD> i've got 2 mutually recursive datatypes that i'm trying to define a sized arbitrary instance for
22:34:59 <Iceland_jack> You can also do it your style
22:34:59 <Iceland_jack> @ty do (int :: Int) <- arbitrary; (bool :: Bool) <- arbitrary; return (if bool then int else int + 1)
22:35:00 <lambdabot> Gen Int
22:35:20 <NemesisD> switching from msg <- arbitrary, pred <- arbitrary, name <- arbitrary to (msg, pred, name) <- arbitrary cleared up the issue
22:35:20 <Iceland_jack> NemesisD: Can you show me the code?
22:35:21 * spacekitteh waves to Iceland_jack 
22:35:26 <Iceland_jack> hey spacekitteh!
22:35:35 <Iceland_jack> NemesisD: okay fair enough
22:36:20 <ion> int + if bool then 0 else 1
22:36:33 <augur> someone explain generalized de bruijn indices to me! :(
22:36:48 <ion> augur: They’re like de Bruijn indices, but they’re generalized. hth
22:36:53 <augur> ion: :P
22:38:22 <NemesisD> arbitrary instances for these structures seems to get hairy pretty quick. i should probably sleep on it
22:39:03 <Iceland_jack> NemesisD: Writing sized arbitrary instances for recursively defined datatypes shouldn't be very hairy
22:41:08 <spacekitteh> hey Iceland_jack wanna see my code? :3
22:41:13 <spacekitteh> it's awesome now.
22:41:16 <spacekitteh> "awesome"
22:41:26 <Iceland_jack> sure
22:41:40 <spacekitteh> https://raw.github.com/spacekitteh/haskell-clifford/feature/dynamics/src/clifford.lhs
22:41:53 <covi> What are some popular and useful concurrent / parallel constructs nowadays?
22:42:16 <spacekitteh> i really need to split that shit up into modules
22:43:53 <Iceland_jack> haha yeah you're probably right about that
22:44:00 <Iceland_jack> it looks good
22:45:20 <spacekitteh> i love the ghc/llvm optimiser omg
22:45:35 <spacekitteh> in ghci, computing the logarithm of 2ik took ~1.79 seconds
22:45:50 <spacekitteh> after i compiled it it took ~280 nanoseconds
22:47:51 <Iceland_jack> impressive speedup
22:48:13 <Iceland_jack> sounds like strictness problems
22:48:16 <spacekitteh> 7 orders of magnitude ahoy
22:48:54 <spacekitteh> hmm, i wanna try using normal lists instead of fused lists to see what it gets then
22:49:17 <gamegoblin> So I have a socket that I know is receving data at 1 char per second. I have code set up to read individual chars from the socket, and putChar them to stdout, but when I test it all, it waits until all data has been sent and then prints it all out at once.
22:49:23 <gamegoblin> Any way I can force it to print chars as it receives them?
22:51:40 <dwcook> gamegoblin, show code, this sounds similar to your earlier problem.
22:53:27 <gamegoblin> http://lpaste.net/100645
22:53:41 <gamegoblin> attempted to make it as explicitly char-based as possible
22:54:00 <gamegoblin> as I'd really like to just print chars as they are received
22:54:17 <spacekitteh> Iceland_jack: running the test in ghci without stream fusion
22:54:50 <dwcook> gamegoblin, the problem is mapM_, which tries to build up the whole thing before giving a result
22:54:56 <Iceland_jack> spacekitteh: Where is the stream fusion coming from?
22:55:03 <spacekitteh> data.list.stream
22:55:05 <gamegoblin> dwcook: what should I sue
22:55:08 <gamegoblin> use*
22:55:09 <spacekitteh> i just chopped off the stream on import
22:55:33 <Iceland_jack> Was there any difference?
22:55:57 <spacekitteh> i'll let you know when the test finishes :v
22:56:05 <dwcook> gamegoblin, might be a good idea to learn pipes
22:56:17 <perebor> how can I alter a cabal package before installing it? I've 'cabal unpack'ed it, and I've made the changes. how to I install them now?
22:56:24 <gamegoblin> dwcook: no way to do it without?
22:56:36 <dwcook> gamegoblin, I'm not saying that
22:56:51 <dwcook> Just that it seems like it might be worth the time to learn
22:57:03 <gamegoblin> Definitely, I'd just like to figure out this bit before going to sleep ;D
22:57:40 <gamegoblin> But if it'd require > 20 lines of boilerplate I'll just sleep and pipe tomorrow
22:58:00 <dwcook> gamegoblin, you might try rolling your own loop, making use of recursion or possibly even forever
22:58:23 <dwcook> Control.Monad.forever, that is
22:58:42 <dwcook> Actually I'm not certain the problem is with mapM
22:58:51 <dwcook> I don't know how this chars behaves
22:59:14 <dwcook> Oh right, it's right there -_- I'm sleepy
23:00:11 <dwcook> You might try taking lpaste's suggestion, actually, see if that helps
23:00:31 <dwcook> Ah, no it doesn't
23:00:34 <gamegoblin> Nope
23:00:59 <dwcook> It could well be a buffering issue again
23:01:29 <gamegoblin> I've tried it on all the different buffering modes
23:02:41 <gamegoblin> Oh well. I don't actually need to be able to do this, I just got really curious that I couldn't figure out how
23:03:37 <dwcook> Oh of course
23:03:42 <dwcook> Yeah, your chars builds up a list
23:03:51 <gamegoblin> I figured since it was lazy it'd still work
23:03:53 <gamegoblin> oh well
23:03:54 <gamegoblin> sleep time
23:04:06 <dwcook> Well it's not lazy IO nor does it really process one character at a time
23:04:09 <dwcook> Your chars is the holdup
23:04:30 <dwcook> It won't come back with anything short of the entire list
23:04:40 <gamegoblin> aaaahk gotcha
23:04:50 <gamegoblin> yyyyep using just getContents and NoBuffering on stdout worked
23:04:54 <gamegoblin> I can die happy now
23:04:54 <dwcook> I'm not certain that's it but it's suggestive
23:05:58 <dwcook> Well I should probably get to bed myself. Good night
23:08:00 <Iceland_jack> gamegoblin: Alternatively you should continue with Haskell :)
23:30:20 <chrisw> Is anyone familiar with gloss for 2D graphics? I would like to save an image I created to a file, but I can't figure out how.
23:31:10 <haasn> gamegoblin: what's wrong with:  loop = do eof <- hIsEof h; if eof then return () else do { hGetChar h >>= putChar; loop }
23:31:18 <haasn> that way you process chars/effects one at a time
23:31:40 <haasn> Instead of reading them all into a list and outputting the entire thing at the end
23:53:07 <chrisdotcode> Can someone help me optimize this function? Forget about the condition (it's made up), but how would I optimize that if-else to remove the duplicate code?:
23:53:07 <chrisdotcode> f cond [] = []
23:53:07 <chrisdotcode> f cond (x:xs) = if cond then (x : f cond xs) else (f cond xs)
23:54:46 <jle`> well you can check cond at the beginning
23:54:48 <jle`> before you recurse at all
23:55:15 <jle`> because it won't change during your entire recursion
23:55:24 <jle`> so...
23:55:45 <jle`> f True xs = xs
23:55:50 <jle`> f False _ = []
23:56:18 <chrisdotcode> jle`: well the condition was just an example to make it a bit more realistic, but I was trying to eliminate the code duplication in the if-else
23:56:42 <jle`> does it change?
23:56:44 <jle`> or is it a function of x?
23:57:00 <jle`> (or a function of xs?)
23:57:31 <jle`> well either way you can get rid of th if/then/else using guards
23:57:39 <chrisdotcode> okay, so I re-wrote it more clearly to try and show my point. how would I "optimize" the if-else to avoid ccode duplication?
23:57:39 <chrisdotcode> f _ [] = []
23:57:39 <chrisdotcode> f p (x:xs) = if p x then (x : f p xs) else (f p xs)
23:57:42 <covi> What are the seminal papers on dependent types?
23:57:58 <jle`> @src filter
23:57:58 <lambdabot> filter _ []     = []
23:57:59 <lambdabot> filter p (x:xs)
23:57:59 <lambdabot>     | p x       = x : filter p xs
23:57:59 <lambdabot>     | otherwise = filter p xs
23:58:43 <chrisdotcode> jle`: yes, I knew that was filter :) but I was under the impression that you didn't have to write the "filter p xs" part twice. guess you have to. thanks, then :)
23:58:49 <jle`> well
23:58:51 <jle`> you don't have to :)
23:59:06 <jle`> and i suspected you knew it was filter; just wanted to show you an implementation with guards
23:59:11 <jle`> it's hard to write out guards in one line >.>
23:59:21 <jle`> hm.
23:59:30 <jle`> ghc's filter does the filter stuff twice
23:59:32 <jle`> http://hackage.haskell.org/package/base-4.6.0.1/docs/src/GHC-List.html#filter
23:59:45 <jle`> but you can use a where clause
23:59:48 <jle`> to only write it once
23:59:55 <chrisdotcode> jle`: yeah, I was working on something completely different and got nerd snipped on this >_>
23:59:56 <jle`> it's sorta unecessary though
