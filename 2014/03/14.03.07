00:00:08 <joelteon> so it's join (.) fmap
00:00:45 <joelteon> oh, that doesn't typecheck
00:09:58 * hackagebot rainbow 0.10.2.0 - Print text to terminal with colors and effects  http://hackage.haskell.org/package/rainbow-0.10.2.0 (OmariNorman)
00:09:58 * hackagebot happstack-fastcgi 0.1.5 - Happstack extension for use with FastCGI.  http://hackage.haskell.org/package/happstack-fastcgi-0.1.5 (tomberek)
00:24:57 <shiona> is there a less specialized kdtree library than Trees.KdTree? If possible I'd like my points to be unboxed Word8-triplets but the only kd-library only allows n-dimensional doubles
00:26:19 <shiona> usecase: I'm trying to find the closest 24bit color that is not used and use them one by one
00:26:39 <shiona> closest being a 3d-distance
00:27:19 <shachaf> Closest?
00:28:33 <shiona> like distance of #fcfdfe from #ffffff is sqrt(3²+2²+1)
00:29:14 <ologNation> shiona, That's pretty interesting.  Do you know about Okasaki's book, Purely Functional Data Structures?
00:29:31 <shiona> no, should I look it up?
00:29:32 <ologNation> shiona, Do you have any code posted?
00:30:13 <shiona> ologNation: not yet, I did try this with a stupid bitset-implementation (no kd-tree, linear search)
00:30:23 <ologNation> shiona, Sure, why not?  It is just what the title says and the implementation for the data structures are at the back of the book.
00:30:45 <ologNation> shiona, I also think a lot about color and programming
00:31:20 <ologNation> shiona, I love this website: http://www.huevaluechroma.com/
00:31:45 <shiona> http://codegolf.stackexchange.com/questions/22144/images-with-all-colors what about these
00:31:50 <shiona> that's where the idea came from
00:32:35 <shiona> I suggest you look the 1080p youtube video from the first answer. it's gorgeus
00:35:08 <shiona> It took me some time to realize that finding the colosest color to one given in a set of available colors should be exactly what kd-tree is for. Only that the tree is very dense (at first when all colors are available) and we can use just word8's for the dimensions
00:38:19 <ologNation> shiona, http://hackage.haskell.org/package/KdTree-0.2/docs/Data-Trees-KdTree.html
00:39:14 <shiona> I tried using that. The implementation of Point-typeclass restricts the dimensions to be of type Double
00:39:29 <shiona> which may, or may not be the reason it's unusably slow
00:44:36 <shiona> or to be more exact: it was a horrible memory hog
00:47:24 <shiona> also I guess a regular dense grid isn't the best possible case for kd-tree
01:07:48 <1JTAAL2U4> quick list comprehension question
01:07:55 <1JTAAL2U4> say I do this
01:08:45 <1JTAAL2U4> let rightTriangles = [(a,b,c) | c <- [1..10], a <- [1..c], b <- [1..a], a^2 + b^2 == c^2]
01:09:05 <1JTAAL2U4> for the sets we draw a and b from
01:09:33 <1JTAAL2U4> will it evalue as follows c = 1 ---> a = 1 ---> b = 1?
01:10:00 <johnw> I don't understand that question
01:10:10 <quicksilver> if that is a question about the order of the resulting list, yes, it runs like nested for loops in that order
01:10:24 <1JTAAL2U4> I'm trying to understand how the interpreter will parse the statement
01:10:34 <quicksilver> > [ (a,b) | a <- [1,2,3], b <- [1,2,3] ]
01:10:36 <lambdabot>  [(1,1),(1,2),(1,3),(2,1),(2,2),(2,3),(3,1),(3,2),(3,3)]
01:10:49 <1JTAAL2U4> ah ok beautiful
01:11:01 <1JTAAL2U4> should have considered a simplier example
01:21:35 <mniip> can someone link me to an example usage of BrowserState from Network.Browser? The only examples available don't use the state, and I can't seem to be able to deduce it from the manual
01:21:44 <mniip> er, docs, I mean
01:23:36 <Fuuzetsu> I can't give you an example (although I might have one buried somewhere) but perhaps we can help with whatever you're struggling to do. What's your goal?
01:31:57 <mniip> Fuuzetsu, I need to send multiple POST requests (synchronously) while preserving cookies between them
01:35:03 <quicksilver> that should just happen automatically with the Network.Browser interface
01:35:29 <quicksilver> cookie should just work
01:37:38 <ologNation> shiona, Have you had a chance to look at Data.Trees.KdTree?
01:39:39 <mniip> quicksilver, yeah but cookies are stored where?
01:39:43 <jle`> how do i use cabal with two ghc's?
01:39:44 <mniip> in BrowserState, no?
01:40:03 <merijn> jle`: Define "with two ghcs"
01:40:16 <jle`> two versions of ghc's
01:40:22 <jle`> hm
01:40:26 <merijn> jle`: Do you mean "I installed GHC HEAD/7.8 and want to tell cabal to use that"?
01:40:26 <jle`> like use 7.6.3 for one project
01:40:31 <jle`> 7.8 for another
01:40:50 <merijn> jle`: The simple solution is: cabal will just use whichever GHC is in your path first
01:40:52 <jle`> because i upgraded to ghc and my project is insiting on using the wrong array version for some reason
01:41:07 <merijn> jle`: Like, the only thing I change to switch ghc versions is put 7.8 earlier in my $PATH
01:41:14 <jle`> probably because of of my dependencies requires the wrong array
01:41:16 <jle`> ah, ok.
01:41:22 <luite_> jle`: use --constraint=array==theversionyouexpect
01:41:28 <luite_> and it will tell you why it can't solve it
01:41:34 <jle`> luite_: thanks, i'll lookat the output
01:41:40 <jle`> merijn: thanks
01:41:52 <jle`> how do i go about installing them to make sure they don't conflict? use a custom --prefix ?
01:42:12 <scshunt> look up cabal sandboxing
01:45:50 <merijn> jle`: haskell packages are installed into GHC version specific directories, so those automatically don't conflict
01:46:17 <jle`> scshunt: sandboxing ghc versions?
01:46:24 <merijn> jle`: I just installed haskell platform in its usuall directory and a version of 7.8 in ~/ghc, so then I just prefix my path with ~/ghc/bin to use it
01:46:26 <jle`> merijn: yeah, i noticed that in my .ghc
01:46:34 <jle`> merijn: ah that's a good idea
01:46:43 <jle`> and i can have a per-shell $PATH huh
01:47:19 <merijn> There's all the hsenv, god knows who tools, but in my experience just multiple install dirs and setting PATH works fine
01:47:29 <twomashi2> Got this weird issue: src/Main.hs:21:18: Could not find module `GMYB.Datastore' Locations searched: GMYB/Datastore.hs
01:47:39 <merijn> jle`: Yeah, all you need to do is "export PATH=$HOME/ghc/bin:$PATH" and done
01:47:47 <twomashi2> It can't find the module yet it looked in it Oo
01:49:52 <jle`> ah the culprit is gnuplot
01:49:57 <jle`> tsk
01:50:27 <jle`> do i just have to download and build it myself for now until the version constraints get relaxed on hackage?
01:52:39 <abc22134> @pl \a b c -> const b [a,c]
01:52:39 <lambdabot> const const
01:53:08 <jle`> SDL is broken :/ it require Typeable(typeOf) which apparently is not exported?
01:53:59 <quicksilver> mniip: yes, but why do you ask where they are stored?
01:54:17 <mniip> quicksilver, because I haven't seen how to use the BrowserState
01:54:25 <mniip> nor can figure it out
01:56:15 <jle`> where would i file a ticket?
01:56:29 <jle`> http://hackage.haskell.org/package/SDL has no bug tracker link
01:57:08 <quicksilver> mniip: you dont' need to do anything. It just works.
01:57:43 <quicksilver> mniip: Network.Browser remembers cookies; use setCookies if you want to override them.
01:58:13 <quicksilver> mniip: it would be easier to help you if showed what you have tried and what doesn't work.
02:01:05 <shiona> ologNation: yes. It seems to force dimensions to be of type Double as it stands. I'm not sure if that's the reason, but the library is way too slow for my purposes
02:01:58 <shiona> ologNation: also I have the impression that the "fromList" isn't optimal for my usecase, which is dense regular grid
02:02:31 <ologNation> I see.
02:04:26 <shiona> ologNation: I think I should try to fork the library and try to make it polymorphic over the location type and go from there
02:06:48 <ologNation> shiona, I'd be curious to see that.
02:09:04 <abc22134> @pl \a b c -> const b ( (a:) . (c:) )
02:09:04 <lambdabot> const const
02:09:35 <abc22134> @pl \a b c -> const const b ( (a:) . (c:) )
02:09:35 <lambdabot> flip ((.) . const const) . (. (:)) . (.) . (:)
02:12:18 <ologNation> shiona, if you haven't already, you may want to look at this other effort to hand-build a kd-tree: http://stackoverflow.com/questions/20119826/how-to-implement-a-fast-lazy-kdtree-in-haskell
02:12:18 <ologNation> The item has a link to github.
02:12:38 <klrr_> anyone know what index means here? http://codepad.org/3A1QmmdN
02:13:32 <shiona> ologNation: I quickly browsed that but didn't realize it had an actual implementation in it, going to check it closer
02:13:38 <supki_> klrr_: position in the list
02:14:29 <klrr_> i dont get it
02:14:41 <klrr_> is even true and uneven false?
02:14:57 <supki_> > zip "klrr_" [0..]
02:14:58 <lambdabot>  [('k',0),('l',1),('r',2),('r',3),('_',4)]
02:14:58 <jle`> klrr_: for the second example
02:15:09 <jle`> only 0, 2, and 4 are true
02:15:13 <jle`> the rest are false
02:15:25 <klrr_> okey
02:15:30 <jle`> 1,3,5,6,7,8... are false
02:15:38 <klrr_> so the given list specify which elements are going to be true?
02:15:45 <jle`> yes
02:15:48 <klrr_> okey, thanks!
02:22:03 <jle`> @pl \xs -> map (`elem` xs) [0..]
02:22:03 <lambdabot> flip map [0..] . flip elem
02:22:19 <jle`> hm. probably not a good idea
02:23:30 <bahamas> @help pl
02:23:30 <lambdabot> pointless <expr>. Play with pointfree code.
02:26:57 <mniip> quicksilver, I tried nothing, really
02:27:13 <mniip> I can't try because I don't know what to
02:29:40 <Taneb> > x + 1
02:29:42 <lambdabot>  x + 1
02:29:59 <Taneb> > det22 (V2 (V2 a b) (V2 c d))
02:30:00 <lambdabot>  Not in scope: `det22'Not in scope: data constructor `V2'Not in scope: data c...
02:30:04 <Taneb> No linear :(
02:30:11 <Taneb> @let import Linear
02:30:12 <lambdabot>  .L.hs:114:1:
02:30:12 <lambdabot>      Failed to load interface for `Linear'
02:30:12 <lambdabot>      Perhaps you meant Linker (needs flag -package ghc-7.6.3)
02:30:12 <lambdabot>      Use -v to see a list of the files searched for.
02:32:53 <quicksilver> mniip: there is an example at the top of http://hackage.haskell.org/package/HTTP-4000.2.11/docs/Network-Browser.html
02:33:20 <mniip> quicksilver, yeah but that doesn't use the BrowserState
02:33:36 <quicksilver> you don't need to use the browserstate
02:33:40 <quicksilver> cookies are automatic
02:33:48 <mniip> how can they be automatic
02:33:54 <quicksilver> the browserstate is an implementation detail
02:34:05 <quicksilver> if you want to set them, use setCookie/setCookies
02:34:19 <mniip> so you're implying that storing cookies is a side effect of the IO action?
02:35:35 <quicksilver> inside "browse"
02:35:41 <quicksilver> cookies are automatically passed from one request to another
02:35:43 <quicksilver> just like a browser
02:36:14 <quicksilver> between separate "browse" sessions you would have to save/restore them if you want to
02:36:14 <mniip> well they should've clarified that
02:37:07 <quicksilver> it works the same way in every other library on every other language I've used
02:37:12 <quicksilver> I guess it seemed obvious to me
02:37:16 <quicksilver> I agree the package doesn't have much docs
02:45:11 <shiona> how would I go about modifying a cabal-package (locally)
02:45:55 <shiona> do I just cd into ~/.cabal/something and edit the .hs's and assume it to work
02:46:12 <aleator> shiona: cabal unpack <package>
02:46:48 <shiona> oh, hi. and thanks :D
02:47:10 <aleator> then edit and cabal install that. Though it is much nicer to just pull them from whatever repo the package is stored in.
02:48:22 <shiona> so I would first delete the currenty installed version
02:48:25 <shiona> if that's even possible
02:49:36 <aleator> shiona: you don't really need to delete the previous version as the new one can be installed alongside.
02:49:51 <aleator> although if you want, ghc-pkg unregister <package> does the job.
02:50:16 <shiona> ok
02:50:40 <mniip> quicksilver, I haven't used a lot of haskell libraries
02:50:53 <aleator> Also, if you change the deps on the package you're modifying and cabal complains about not managing to satisfy them do 'cabal install . <package-with-complaint> <package-with-complaint> <etc.>'
02:51:03 <aleator> Usually works.
02:52:43 <bahamas> Monad is a type class?
02:52:53 <Axman6> yes
02:52:57 <Axman6> @src Monad
02:52:58 <lambdabot> class  Monad m  where
02:52:58 <lambdabot>     (>>=)       :: forall a b. m a -> (a -> m b) -> m b
02:52:58 <lambdabot>     (>>)        :: forall a b. m a -> m b -> m b
02:52:58 <lambdabot>     return      :: a -> m a
02:52:58 <lambdabot>     fail        :: String -> m a
02:53:36 <jle`> pretend fail isn't there :)
02:53:42 <Axman6> yeah
02:53:49 <mniip> quicksilver, btw, with that example, I'm not really sure how to do multiple requests
02:53:59 <bahamas> I don't understand most of that anyway :)
02:55:01 <Axman6> it's all extremely simple, and people get confused by the simplicity
02:55:30 <Yuu-chan_> @pl \f (a, b) -> (f a, f b)
02:55:30 <lambdabot> (`ap` snd) . (. fst) . (flip =<< (((.) . (,)) .))
02:55:36 <mniip> quicksilver, besides, it seems that I'll have to pass the BrowserState down a function
02:55:44 <Yuu-chan_> @pl \f (a, b) -> (f a, b)
02:55:44 <lambdabot> (`ap` snd) . (. fst) . ((,) .)
02:55:51 <bahamas> Axman6: I don't know some of the notation. that's why I don't understand
02:56:00 <bahamas> @src Eq
02:56:00 <lambdabot> class  Eq a  where
02:56:01 <lambdabot>     (==), (/=)   :: a -> a -> Bool
02:56:09 <Yuu-chan_> Is Lambdabot unaware of Control.Arrow?
02:56:25 <jle`> bahamas: ignore the forall :)
02:56:41 <jle`> (>>=) :: m a -> (a -> m b) -> m b
02:56:43 <Axman6> sure, you'll get there. I'm just letting you know that monads are not hard, but you need to understand a few functional programming concepts before it'll make sense
02:56:45 <bahamas> jle`: is '.' the function composition operator?
02:56:53 <bahamas> ah
02:56:53 <jle`> bahamas: in this situation, it is syntax
02:57:31 <Axman6> bahamas: you can, and should, ignore the "forall a b." bit completely
02:57:32 <jle`> think of it as meaning "m a -> (a -> m b) -> m b, for all types a and b"
02:57:33 <bahamas> jle`: how do you read m a? I've normally seen just one type before ->
02:57:44 <jle`> bahamas: do you know Maybe?
02:57:47 <Yuu-chan_> By the way, is there some operator in Control.Arrow or somewhere else which could have type (a -> b) -> (a, b) -> (b, b)?
02:58:03 <Axman6> Yuu-chan_: first will do that
02:58:07 <bahamas> jle`: yeah, actually that's why I asked about Monad as being a type class. I did :i Maybe
02:58:07 <jle`> Yuu-chan_: there's first, but it's a bit more general
02:58:09 <Yuu-chan_> * sorry, I mean (a -> b) -> (a, a) -> (b, b)
02:58:21 <jle`> bahamas: have you seen Maybe in the wild?
02:58:23 <Axman6> :t first show `asAppliedTo` (1,True)
02:58:24 <lambdabot> (Num a, Show a) => (a, Bool) -> (String, Bool)
02:58:46 <Axman6> oh, well join (&&&) will do it
02:58:52 <Axman6> :t join (&&&)
02:58:53 <lambdabot> Arrow a => a b c -> a b (c, c)
02:58:55 <Yuu-chan_> I know about 'first' and 'second', but couldn't find 'both'
02:58:57 <jle`> basically, a Maybe Int is either Just an Int or Nothing
02:58:58 <Axman6> oops, no
02:59:07 <skypers_> is there a foldM strict?
02:59:07 <bahamas> jle`: in the wilderness of lyah. I know it's returned by List.find for example
02:59:23 <jle`> Yuu-chan_: (&&&) forks, (***) applies in parallel
02:59:30 <jle`> bahamas: try http://adit.io/posts/2013-04-17-functors,_applicatives,_and_monads_in_pictures.html
02:59:43 <jle`> bahamas: basically, when we say class Something x where ....
02:59:52 <jle`> we can say instance Something Type where ...
02:59:57 <jle`> and x refers to that type
03:00:10 <jle`> so when we say that Maybe is an instance of Monad
03:00:14 <jle`> we replace all m's with Maybe
03:00:28 <supki_> :t over both
03:00:28 <lambdabot> (a -> b) -> (a, a) -> (b, b)
03:00:36 <jle`> instance Maybe Monad where (>>=) :: Maybe a -> (a -> Maybe b) -> Maybe b
03:00:52 <jle`> (>>) :: Maybe a -> Maybe b -> Maybe b
03:01:02 <jle`> return :: a -> Maybe a
03:01:20 <jle`> Maybe is probably the most readily available example
03:01:39 <jle`> you can actually sort of guess from the type signature of (>>=) what it has to do, for Maybe
03:01:40 <Yuu-chan_> :t over
03:01:41 <lambdabot> Profunctor p => Setting p s t a b -> p a b -> s -> t
03:01:49 <Yuu-chan_> :t both
03:01:49 <lambdabot> Applicative f => (a -> f b) -> (a, a) -> f (b, b)
03:01:52 <jle`> there is really only one meaningful implementation
03:02:18 <bahamas> jle`: it's interesting that the instance of the other type classes for Maybe are instance Eq (Maybe m). only for Monad and Function are instance Monad Maybe
03:02:37 <bahamas> s/Function/Functor/
03:02:39 <jle`> bahamas: yeah, that is something important to notice :)
03:02:43 <quicksilver> mniip: you don't have to pass the browser state anywhere from what you've said. You don't even have to know what it is.
03:02:49 <quicksilver> mniip: it's just an implementation detail.
03:02:56 <jle`> bahamas: that's why you see m a
03:02:58 <bahamas> so for them it works with a type constructor instead of a concrete type
03:02:58 <jle`> instead of m
03:03:02 <quicksilver> mniip: you might have to pass the cookies around, but that's [Cookie]
03:03:06 <Yuu-chan_> I can't grasp that :( Better to write a small helper function.
03:03:16 <jle`> bahamas: you can tell by the kind of the typeclass constraint
03:03:19 <jle`> :k Monad
03:03:20 <lambdabot> (* -> *) -> Constraint
03:03:31 <jle`> only (* -> *)'s can be Monads
03:03:34 <jle`> :k Maybe
03:03:35 <lambdabot> * -> *
03:03:38 <jle`> that's ok
03:03:41 <jle`> :k Eq
03:03:42 <lambdabot> * -> Constraint
03:03:45 <jle`> only *'s can be Eq
03:03:48 <jle`> :k Maybe Int
03:03:49 <lambdabot> *
03:03:51 <jle`> that's ok
03:03:53 <jle`> :k Maybe
03:03:53 <lambdabot> * -> *
03:03:56 <jle`> Maybe can't be Eq
03:03:59 <jle`> only Maybe a can
03:04:09 <jle`> similarly Maybe a can't be Monad, only Maybe can
03:04:26 <bahamas> ah, so m a above stands for Maybe a
03:04:52 <jle`> yes
03:05:06 <jle`> another possibly accessible example is []
03:05:13 <jle`> [] a is a list of a's
03:05:19 <jle`> you will see it with syntactic sugar as [a]
03:05:26 <bahamas> (>>=)       :: forall a b. m a -> (a -> m b) -> m b
03:05:27 <jle`> :k ([])
03:05:28 <lambdabot> * -> *
03:05:40 <jle`> [] can be a Monad
03:05:42 <jle`> [a] can't
03:05:51 <jle`> :k [a]
03:05:52 <lambdabot> Not in scope: type variable `a'
03:05:56 <bahamas> so this means that the function takes Maybe a and a function that takes a type a and returns Maybe b and returns Maybe b
03:05:57 <jle`> :k [Int]
03:05:57 <lambdabot> *
03:06:03 <bahamas> what I pasted above
03:06:05 <jle`> bahamas: yes
03:06:08 <jle`> precisely
03:06:24 <jle`> try writing a function that fulfills those types
03:06:37 <jle`> and you will probably get the actual (>>=)
03:06:44 <jle`> for Maybe
03:06:54 <jle`> and then think about what it does and why it might be useful :)
03:07:42 <bahamas> ah, so "m" in class Monad "m" stands for any type constructor or for any type?
03:08:14 <jle`> the m in class Monad m stands for anything type-level of kind (* -> *)
03:08:29 <jle`> something that takes a single type in order to get a concrete type
03:08:46 <jle`> Maybe is one --- Maybe Int is a concrete type
03:08:53 <bahamas> jle`: ah, not only a type constructor does that?
03:08:54 <jle`> [] is one
03:09:03 <bahamas> jle`: so type constructor, no?
03:09:04 <jle`> only a type constructor with one argument does that :)
03:09:06 <jle`> consider Either
03:09:12 <jle`> :k Either
03:09:13 <lambdabot> * -> * -> *
03:09:18 <jle`> Either needs two parameters to be a concrete type
03:09:20 <bahamas> right :) it takes two types
03:09:40 <jle`> so Either can't be a monad
03:09:44 <jle`> only Either a can
03:09:48 <jle`> :k Either Int
03:09:49 <lambdabot> * -> *
03:09:51 <mniip> quicksilver, actually you know what, screw this idea, I'll implement it in a different language :P
03:10:09 <bahamas> right, because it partially applies Either to Int
03:10:31 <bahamas> damn, this whole currying thing is cool
03:11:39 <t4nk366> Hello there. Can someone explain to me what I am doing wrong in the following recursive function. triangle x = x + ( triangle (x-1))
03:11:40 <jle`> :)
03:12:15 <Axman6> t4nk366: that's an infinite loop, the x on the left is the same as as the two on the right
03:12:21 <t4nk366> No matter how much I read, I just can't understand how to write my own
03:12:22 <Axman6> > let x = a : x in x
03:12:24 <lambdabot>  [a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a...
03:13:21 <t4nk366> I want it to sum all of the numbers including x, and then -1 away each step until we reach 0
03:13:54 <Axman6> so you've written x = x + t (x-1) ==> x = (x + t ((x + t (x-1)-1)) + t (x + t (x-1))) => x =  ... (or something like that)
03:14:09 <t4nk366> The example I read in the book says factorial (n+1) = (n+1)*factorial n
03:14:14 <t4nk366> And I just can't understand it lol
03:14:15 <dv-> add triangle 1 = 1
03:14:22 <Axman6> t4nk366: but x is defined interms of summing itself with something
03:14:40 <Axman6> oh, i completely missed the triable x bit at the beginning!
03:14:41 <Axman6> ha
03:14:48 * Axman6 isn't having a good night
03:15:18 <t4nk366> Cheers dv- that worked!
03:15:43 <Axman6> t4nk366: remember, when wring loops, you almost always need a base case to stop the recursion
03:15:54 <Axman6> for lists it's almost always []
03:17:14 <t4nk366> The question I have says it should be 0 inclusive, so for example f 4 would be 4+3+2+1+0
03:17:26 <t4nk366> If I set base as 1 = 1 then I am guessing it doesn;t include 0?
03:17:27 <jle`> t4nk366: also (n+1) patterns have been out of vogue for at least a decade and a half :)
03:17:40 <Axman6> t4nk366: then triangle 0 = 0
03:17:43 <t4nk366> Blame my lecturer :v
03:17:49 <t4nk366> Ah I see
03:19:28 <shiona> aleator: would you mind taking a look at my first try at editing an existing library: http://lpaste.net/8701599103131320320
03:19:54 <shiona> everyone is of course welcome. I have some problem which I believe has to do with limiting type variables in some way
03:20:31 <shiona> wait, it's missing the important part
03:20:32 <shiona> or is it
03:24:49 <fizruk> shiona: did you mean compareDistance :: (Point p d, Ord d) => p -> p -> p -> Ordering ? also should there be a functional dependency linking p and d for Point class?
03:25:51 <shiona> fizruk: yes and yes
03:26:11 <shiona> fizruk: I've never done anything even remotely this "complex"
03:26:28 <t4nk366> If I wanted to use recursion in a function to check if any bool value in a list is true
03:26:30 <skypers_> hi
03:26:36 <t4nk366> would my base value be f [] = True
03:26:38 <t4nk366> ?
03:26:39 <bahamas> btw, when talking about classes and instances and types, isn't it better to say that "Maybe *has* an instance for Eq" than to say that "Maybe *is* an instance of Eq."
03:26:48 <skypers_> http://lpaste.net/1362358373546196992
03:26:50 <Yuu-chan_> Hi skypers_
03:27:02 <skypers_> what would you say is strict in there that causes it to loop forever?
03:27:14 <fizruk> shiona: you could also use type family instead of functional dependency
03:27:16 <skypers_> even I use a take function to extract a limited list
03:27:23 <quicksilver> bahamas: no.
03:27:26 <bahamas> t4nk366: doesn't it make sense to return False for an empty list?
03:27:39 <quicksilver> bahamas: a class is a set of types.
03:27:46 <t4nk366> bahamas -- I have no idea what I am doing, so just trying everything out :v
03:27:55 <quicksilver> bahamas: you're either in it or not; so "is" is a reasonable verb.
03:28:06 <Axman6> t4nk366: what do you want the result to be for [False]?
03:28:07 <shiona> fizruk: ok, damn this becomes way too difficult to me
03:28:09 <bahamas> t4nk366: to me it makes sense to return False if the list is empty, since there is no True in list
03:28:23 <t4nk366> There will be, that's only the base value
03:28:40 <bahamas> t4nk366: yes, we're talking about the case when there isn't :)
03:28:56 <fizruk> shiona: the fundep/type family part?
03:28:57 <t4nk366> Aah I see
03:29:01 <Axman6> base cases are very important, there's no "only" ahout them! =)
03:29:05 <shiona> fizruk: yea
03:29:09 <Yuu-chan_> skypers_: I think that's because of holding the list in a tuple
03:29:27 <bahamas> t4nk366: you return True if you have at least 1 True in list. if you have none, you should return False
03:29:30 <shiona> I hoped I could edit the kdtree just by adding adding an extra letter for the new typeclass
03:29:35 <skypers_> tuple are stricts?
03:29:39 <skypers_> I tried with a State
03:29:40 <shiona> type param*
03:29:41 <skypers_> it’s the same thing
03:29:43 <t4nk366> Thanks bahamas
03:29:47 <aleator> shiona: What are you doing?
03:29:52 <bahamas> t4nk366: you're welcome
03:30:04 <aleator> shiona: How does the original Point class look like?
03:30:25 <Yuu-chan_> skypers_: nope, but here you need to get the snd of an infinitely last tuple, which could cause the problem.
03:30:34 <shiona> aleator: trying to get https://github.com/ijt/kdtree/blob/master/Data/Trees/KdTree.hs to work with unboxed word8's
03:30:59 <skypers_> ?
03:31:03 <skypers_> I don’t get it
03:31:07 <shiona> but I thought I'd try to make it polymorphic at the same time
03:31:12 <skypers_> snd doesn’t have to know abou the list
03:31:25 <skypers_> take 4 . snd $ (undefined,[0..])
03:31:28 <skypers_> > take 4 . snd $ (undefined,[0..])
03:31:29 <lambdabot>  [0,1,2,3]
03:31:36 <skypers_> it perfectly works
03:31:37 <aleator> shiona: Ie. you want it to use Word8 instead of the Double?
03:31:50 <shiona> aleator: yes
03:32:14 <aleator> shiona:  If you want genericity, does the point type imply the scalar type? Ie. if you have point of type T, is the scalar always some specific type?
03:32:48 <shiona> I don't know
03:32:54 <t4nk366> Would the function to check if any of the boolean values in a list are true use guards ?
03:33:16 <bahamas> quicksilver: hmm. I think the point I was trying to convey was that you don't redefine the type if you want it to be a part of a new type class. instead you define an instance of the new class for the new type
03:33:26 <bahamas> am I correct in saying this?
03:33:35 <skypers_> Yuu-chan_: http://lpaste.net/6519190391692984320
03:33:42 <skypers_> I get the same behavior with that version
03:34:12 <skypers_> if I turn the [0..] into [0..10]
03:34:13 <skypers_> it works
03:34:23 <skypers_> so there might be strictness in there
03:34:58 <Yuu-chan_> Well, let's walk along the lazy computation. To take 4 elements, you need a list. To get a list, you need to take snd of a pair. To get a pair, you need to compute the fold. The fold never finishes.
03:34:58 <quicksilver> bahamas: you write the instance down, yes.
03:35:12 <quicksilver> bahamas: there is nothing wrong with 'has', I just disagree with your claim 'has' is better than 'is'.
03:35:35 <quicksilver> bahamas: list *is* a Monoid, State *is* Applicative.
03:35:41 <quicksilver> they are properties of the type
03:35:46 <skypers_> hm I see Yuu-chan_
03:35:51 <Yuu-chan_> If fold produced only a list, the computation could take 4 and defer the rest. But here is nowhere to take 4 from.
03:36:03 <bahamas> quicksilver: using *is* make me thing that something in type definition makes it a part of a class
03:36:27 <Axman6> it sort of does
03:36:28 <quicksilver> something about the inherent nature of the type does make it part of the class
03:36:38 <quicksilver> writing the instance is just showing the proof
03:36:46 <fizruk> aleator: I guess 'class (Ord d, Num d) => Point p d | p -> d where' makes sense for kd-trees
03:36:59 <quicksilver> it is a fact that lists form a monoid, and a fact that State forms an applicative functor
03:37:04 <bahamas> quicksilver: yes, but if you don't write the instance, the type is not part of the class, no?
03:37:04 <skypers_> Yuu-chan_: yeah I see now
03:37:10 <Axman6> list can be an apllicative in two different ways right? zip and the cartesian product version?
03:37:19 <skypers_> it’be better to put the take inside the fold
03:37:20 <skypers_> like
03:37:22 <shiona> aleator: I think it would be nicest if the Point -typeclass would not know anything about the underlying data type that different instances use for their dimensions
03:37:27 <skypers_> foldM … … (take 4 $ [0..])
03:37:30 <quicksilver> Axman6: only sort-of. The zip only really works for infinite lists and the cartesian product only really works for finite lists
03:37:31 <skypers_> it would terminate now
03:37:42 <quicksilver> Axman6: so in a sense the two instances are applying to two different types.
03:38:01 <bahamas> quicksilver: anyway, I'm not trying to convince to use "has" instead of "is". I just wanted to make sure I understand things. thanks
03:38:01 <fizruk> shiona: you should know at least how to compare them
03:38:04 <Yuu-chan_> skypers_: I think you can use unfold here, it produces a (potentially infinite) list.
03:38:10 <shiona> but I don't think a typeclass can say it returns values whose type is dependant on the parametrization of its instance
03:38:10 <quicksilver> bahamas: if you don't write the instance then GHC doesn't know it's part of the class.
03:38:25 <Yuu-chan_> > unfoldl (\i -> Just (i, i + 1)) 0
03:38:25 <quicksilver> bahamas: as a mathematician  you might say still is though.
03:38:26 <lambdabot>  Not in scope: `unfoldl'
03:38:26 <lambdabot>  Perhaps you meant one of these:
03:38:26 <lambdabot>    `Seq.unfoldl' (imported from Data.Sequence),
03:38:26 <lambdabot>    `BS.unfoldr' (imported from Data.ByteString),
03:38:26 <lambdabot>    `BSL.unfoldr' (imported from Data.ByteString.Lazy)
03:38:29 <aleator> shiona: Non sensical, but: http://lpaste.net/100829
03:38:39 <fizruk> shiona: and for default dist2 implementation you should know it behaves like a number
03:38:41 <Yuu-chan_> > unfoldr (\i -> Just (i, i + 1)) 0
03:38:42 <lambdabot>  [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,2...
03:38:45 <quicksilver> lists really are a monoid. Whatever programming language you're using and whatever you have written.
03:38:47 <shiona> aleator: thanks, i'll take a look
03:38:55 <bahamas> quicksilver: sorry, I don't understand your last sentence
03:39:02 <skypers_> woh
03:39:06 <skypers_> I didn’t know unfoldr
03:39:07 <aleator> fizruk: That could be fixed with the new defaulting mechanism
03:39:08 <skypers_> sounds great
03:39:10 <bahamas> ah, now I understood it
03:39:10 <skypers_> thank you
03:39:17 <Axman6> quicksilver: huh, why does the zip version only work for infinite lists?
03:39:28 <Yuu-chan_> skypers_: you're welcome!
03:39:28 <quicksilver> lists are a well-understand mathematical structure, bahamas, and so are monoids. Lists are monoids.
03:39:32 <Axman6> or possible a better question, what are the rules for applicatives again?
03:39:42 <Axman6> s/rules/laws
03:39:49 <quicksilver> Axman6: consider the definition of return (pure)
03:39:52 <shiona> aleator: I guess that type -trick is typeFamilies
03:39:55 <bahamas> quicksilver: anyway, I adhere to the thought that "is" is very ambigous. so I try to avoid using it.
03:39:55 <fizruk> aleator: with type family you don't know if scalar is Ord
03:40:04 <quchen> Axman6: http://www.haskell.org/haskellwiki/Typeclassopedia#Laws_2
03:40:16 <Axman6> quicksilver: ah yes, hadn't thought about that
03:40:37 <shiona> aleator: thanks, I'll have to take a look and try to expand the example to fill my needs after some coffee
03:40:57 <aleator> shiona: Edited the paste a bit.
03:41:16 <t4nk366> or (x:xs) = x || or xs -- can someone explain this to me?
03:41:35 <Axman6> t4nk366: how much do you understand?
03:41:50 <bahamas> t4nk366: "or" is a function
03:41:54 <t4nk366> I don't unerstand the || and the :
03:42:06 <Axman6> :t (||)
03:42:07 <lambdabot> Bool -> Bool -> Bool
03:42:14 <Axman6> > True || False
03:42:14 <bahamas> t4nk366: "||" is boolean OR
03:42:14 <Yuu-chan_> t4nk366: haven't you seen logical || in another languages?
03:42:15 <lambdabot>  True
03:42:21 <Axman6> > False || False
03:42:22 <lambdabot>  False
03:42:30 <t4nk366> Aah I see
03:42:37 <aleator> fizruk: Can't that constraint be placed on the compare-function?
03:42:41 <bahamas> t4nk366: ":" is 4:[] -> [4]
03:42:59 <Axman6> (:) is is how you construct a list, and because it's a constructor, you can also pattern match on it
03:43:02 <Axman6> @src []
03:43:02 <lambdabot> data [] a = [] | a : [a]
03:43:06 <BoR0> > foldr (||) False [True, False, False]
03:43:07 <lambdabot>  True
03:43:32 <Axman6> a list of a's is either [] or an a joined onto the front of a list of a's using (:)
03:43:49 <Yuu-chan_> Btw, how is this list definition even parsed? Some inner hacks in the lexer/parser?
03:44:10 <t4nk366> or :: [Bool ] -> Bool or [] = False or (x:xs) = x || or xs
03:44:34 <quicksilver> Yuu-chan_: which list definiton?
03:44:48 <Yuu-chan_> quicksilver: data [] a = [] | a : [a]
03:44:49 <fizruk> aleator: I just thought there's a lot of functions this constraint would be placed on: all id-tree operations use compare
03:45:15 <quicksilver> Yuu-chan_: oh, that's just fake
03:45:27 <quicksilver> Yuu-chan_: @src is a pit of lies and should be ignored.
03:45:37 <aleator> fizruk: True.. Didn't look at the context too much.
03:46:09 <fizruk> aleator: i'm not saying type family is wrong, just not obviously :)
03:48:17 <fizruk> OTOH Data.Map abuses Ord k constraints in each function
03:48:35 <Axman6> abuses?
03:48:59 <Yuu-chan_> quicksilver: thanks for reassuring me. I've already been strucked by infix operator contructors (prefixed with a colon) and prepared to face something even weirder...
03:49:17 <tdammers> "abuses" in that the fact that the keys need to be orderable is kind of an implementation detail
03:49:49 <Axman6> right, but a kind of important one
03:49:54 <fizruk> Axman6: one could place the constraint in data Map definition (theoretically)
03:50:18 <Yuu-chan_> fizruk: that would be worse
03:50:23 <Axman6> fizruk: that's bad practice, because it then places an Ord k constraint on every function using a Map, even those which don't need the Ord constraint
03:50:24 <skypers_> http://lpaste.net/100831 Yuu-chan_
03:50:28 <aleator> fizruk: How about this? http://lpaste.net/100829
03:50:37 <skypers_> it works perfectly <3
03:50:39 <skypers_> thank you!
03:50:43 <Axman6> so size would become size :: Ord k => Map k v -> Int
03:50:50 <skypers_> I really didn’t know unfoldr
03:50:53 <aleator> fizruk: The doCompare is just example fluff
03:50:54 <skypers_> it’s a very interesting fuction
03:50:57 <skypers_> function*
03:51:10 <fizruk> Axman6: Yuu-chan_: I'm aware of that, thus 'theoretically'
03:51:34 <Axman6> right, so I'm not sure why you said it was an abuse
03:51:36 <skypers_> doCompare a b = compare (coord 1 a) (coord 1 b)
03:51:39 <Yuu-chan_> skypers_: nice!
03:51:57 <skypers_> I think you can write that compare `on` coord 1
03:51:57 <skypers_> :)
03:52:10 <skypers_> on is so lovely :)
03:52:11 <Peaker> a distinction between mathematical Ord and implementation-detail Ord is missing.. i.e:  Map (Complex Double) ..  makes sense even though mathematical Ord for (Complex Double) doesn't
03:52:13 <Yuu-chan_> Or even comparing (coord 1)
03:52:14 <tdammers> Axman6: in an ideal world, Data.Map would transparently act as a key/value store on the outside, and figure out efficient lookups and inserts internally without bothering the user
03:52:24 <skypers_> :t comparing
03:52:25 <lambdabot> Ord a => (b -> a) -> b -> b -> Ordering
03:52:27 <tdammers> Eq k is all you need, conceptually speaking
03:52:31 <skypers_> @src comparing
03:52:31 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
03:52:36 <skypers_> ahah
03:52:39 <skypers_> lambdabot is a clown
03:52:40 <Yuu-chan_> skypers: comparing == (conpare `on`)
03:52:45 <Axman6> tdammers: sure... I guess this is what the talking about typo families was for then
03:52:47 <skypers_> yeah, I guessed so :)
03:52:56 <Axman6> type even
03:52:57 <Axman6> heh
03:53:06 <skypers_> I really wonder why it’s there
03:53:11 <tdammers> meta-typo \o/
03:53:41 <Peaker> If we had ArbitraryEq/ArbitraryOrd, then Float could instantiate those, without instantiating Eq/Ord.  And Complex could instantiate Eq (if underlying type has it) but not Ord
03:53:50 <Yuu-chan_> skypers_: I was really amazed by combining different comparers with Monoid instances
03:54:00 <bahamas> I don't think anyone can say that haskell is not their type, since haskell has a type for anything :)
03:54:01 <skypers_> Yuu-chan_: I mean
03:54:03 <fizruk> aleator: seems like nothing would be changed in code with this type class definition!
03:54:10 <skypers_> we with have compare, but not both
03:54:43 <skypers_> both would be (Bifunctor p a a) => (a -> b) -> p a a -> p b b
03:54:53 <skypers_> both’s worth it to be there
03:55:11 <Wizord> > "\nQUIT"
03:55:12 <lambdabot>  "\nQUIT"
03:55:16 <Wizord> > print "\nQUIT"
03:55:17 <lambdabot>  <IO ()>
03:55:34 <Axman6> skypers_: does your keyboard not have a ' key? your use of _ instead is excellent, but distracting :P
03:55:44 <tdammers> Wizord: trying to get lambdabot to quit?
03:55:44 <ion> Yes, that’s the kind of bug lambdabot will surely have after years of operation.
03:55:52 <skypers_> Axman6: _?
03:55:57 <Wizord> tdammers: yes. I had to test this idea
03:56:00 <skypers_> where do I put _?
03:56:10 <Axman6> tdammers: whenever you type it's, you write it_s
03:56:31 * ion greps his buffer for it_s and doesn’t see any.
03:56:33 <skypers_> what’s your charset?
03:56:33 <Axman6> > text :\nQUIT"
03:56:34 <lambdabot>  <hint>:1:14:
03:56:35 <lambdabot>      lexical error in string/character literal at end of input
03:56:43 <Axman6> > text "\nQUIT"
03:56:44 <lambdabot>  QUIT
03:56:46 <Axman6> utf-8
03:56:47 <Wizord> oh well.
03:56:50 <skypers_> I type typographic ', Axman6
03:56:53 <skypers_> ’
03:57:06 <skypers_> (I use a bépo layout that enables me to do so)
03:57:09 <Axman6> I have a feeling your client doesn't support it then
03:57:17 <merijn> Axman6: I have a feeling yours doesn't
03:57:19 <tdammers> Axman6: what?
03:57:20 <Axman6> because I see unicode symbols from everyone else
03:57:22 <skypers_> :D
03:57:26 <Axman6> eh?
03:57:30 <merijn> Axman6: I see a unicode quote just fine from skypers_
03:57:32 <Axman6> mine's been working fine for years...
03:57:47 <skypers_> yeah like « that », “that” or this ©
03:57:48 <Yuu-chan_> Axman6: I see skypers_'s dashes as usual
03:57:58 <ion> axman6: What’s an example of a line on which you see “it_s”?
03:58:00 <bahamas> Axman6: I see the apostrophe
03:58:16 <skypers_> ion: it’s
03:58:17 <merijn> Axman6: Maybe your font is limited and doesn't support that character?
03:58:20 <skypers_> maybe there?
03:58:25 <merijn> Although this is more of -blah discussion
03:58:43 <Axman6> hmm, when I send one to my terminal, i also get the _, how odd
03:58:47 <Yuu-chan_> «Typographic layouts» are cool²!
03:58:56 <skypers_> Yuu-chan_: yup, totally
03:59:00 <ion> co²l²
03:59:08 <skypers_> I can write greek like a boss with that δ
03:59:14 <Yuu-chan_> Axman6: unicode issues of your chat client, maybe?
03:59:18 <Axman6> but I've been seeing people's annoying use of fancy ' and " for years
03:59:27 <skypers_> Axman6: fancy?
03:59:30 <skypers_> I don’t agree
03:59:33 <merijn> Axman6: I suspect either a font or locale issue?
03:59:34 <skypers_> they’re prettier
03:59:38 <ion> I have seen people use the annoying kluge ' and " for even longer. :-P
03:59:41 <Yuu-chan_> skypers_: must be good for Agda :)
03:59:45 <skypers_> :D
03:59:48 <merijn> I still need a decent way to input unicode :\
04:00:00 <skypers_> I also like the capability to write “insecable” spaces
04:00:08 <skypers_> for my paper it’s so neat
04:00:22 <skypers_> Shift + Space, et voila!
04:00:26 <Yuu-chan_> skypers_: can you Triforce?
04:00:37 <skypers_> hm, let me see that for a sec
04:00:41 <Yuu-chan_> Well, here begins #haskell-blah
04:00:45 <ion> It’s not about pretty, it’s about a choice between grammatically correct punctuation and a nasty kluge made to minimize the number of keys in typewriters and the number of codepoints in ASCII. :-) But yeah, this is definitely -blah material and i’ll stop now.
04:00:50 <Axman6> tdammers: can you type it's again?
04:00:54 <Axman6> hmm, no
04:01:07 <Axman6> uh, meant skypers_, but nevermind
04:01:31 <bitonic> pcapriotti: hey, is there a way with `optparse-applicative' to have a subcommand which simply gets every argument after the command and lets you do something with it?
04:01:43 <bitonic> using `arguments Just' won't work because it will choke on flags
04:01:44 <skypers_>  ▲
04:01:54 <bitonic> I just want to have the verbatim list of arguments and use them with `withArgs'
04:01:56 <skypers_> ▲  ▲
04:02:00 <skypers_> bitonic: !
04:02:03 <skypers_> you ruined it
04:02:04 <skypers_> :(
04:02:11 <Yuu-chan_> it‘s it’s „it's“
04:02:13 <ion> Talk about `annoying'
04:02:20 <skypers_> Axman6: it’s okay now?
04:02:26 <Axman6> no
04:02:28 <skypers_> :D
04:02:34 <skypers_> ok, I have to go to get some lunch
04:02:38 <skypers_> see you pals!
04:02:39 <Axman6> I don't understand, it;s been working for years
04:02:44 <ion> see you ntsc
04:03:04 <mietek> http://www.vex.net/~trebla/haskell/cabal-cabal.xhtml
04:03:10 <mietek> Wow... Just wow
04:03:20 <mietek> Why is Cabal like this?
04:03:20 <Wizord> > text "\rtest"
04:03:22 <lambdabot>  test
04:03:41 <Wizord> > text "\x00"
04:03:43 <ion> mietek: Because you didn’t submit your patch to make it better yet.
04:04:02 <Wizord> > text "123\x00"
04:04:04 <lambdabot>  123
04:04:08 <skypers_> Wizord: can you just do your experiments in pm?
04:04:14 <Wizord> is it possible?
04:04:33 <Wizord> oh, it is
04:04:51 <skypers_> :)
04:04:56 <skypers_> have a good day
04:05:42 <Wizord> ty
04:11:18 <bahamas> is there a way to define an interface of a class for all the types of another class in bulk? for example, to define an interface for all the types in "Num". the context is the yes-no type class here http://learnyouahaskell.com/making-our-own-types-and-typeclasses
04:14:19 <ion> What do you mean by an interface of a class?
04:15:42 <bahamas> ion: interface Eq Int where... I mean interface of Eq
04:15:59 <ion> instance?
04:16:08 <bahamas> sorry, instance
04:16:11 <bahamas> damn terms
04:17:14 <Peaker> bahamas: you can do something like:  instance Num a => Eq a where ...  if you enable some extensions. However, the constraint part ("Num a =>") is ignored when selecting instances (and used only to verify the code can compile *after* the instance is selected).  so that instance will overlap with *every* other instance, which is a problem
04:18:01 <Peaker> bahamas: for example, if you have:  instance Num a => Eq a where ..        and    instance Foo a => Eq a where  ... there's no way for GHC to know which one to select (both "instance heads" are just "a", identical)
04:18:37 <Wizord> are there any other bots with commands here?
04:18:49 <Peaker> bahamas: you can have one instance that overlaps with every other instance -- and GHC can select the more specific instance. But you can't have two, and even one is usually considered a bad idea
04:19:06 <Wizord> :t replicate
04:19:07 <lambdabot> Int -> a -> [a]
04:19:27 <bahamas> Peaker: so there's no way to do what I'm asking. I assume the instance needs to be created for each type explicitely
04:19:52 <Peaker> bahamas: yeah, that is sometimes annoying
04:20:03 <Peaker> bahamas: another option is to make a "newtype" like:
04:20:08 <Wizord> > text (replicate 116 '\x2063' ++ ".look at me calling other commands")
04:20:10 <lambdabot>  ⁣⁣⁣⁣⁣⁣⁣⁣⁣⁣⁣⁣⁣⁣⁣⁣⁣⁣⁣⁣⁣⁣⁣⁣⁣⁣⁣⁣⁣⁣⁣⁣⁣⁣⁣⁣⁣⁣⁣⁣⁣⁣⁣⁣⁣⁣⁣⁣⁣⁣⁣⁣⁣⁣⁣⁣⁣⁣⁣⁣⁣⁣⁣⁣⁣⁣⁣⁣⁣⁣⁣⁣⁣⁣⁣⁣...
04:20:27 <Peaker> bahamas: newtype NumEq a = NumEq a  ;   instance Num a => Eq (NumEq a) where ...
04:20:38 <ion> bahamas: If you just want to define a yesNo for all “Num a” values, you can define a “yesNo :: Num a => a -> Bool” without a new type class.
04:20:46 <Peaker> bahamas: then you need no extensions, but you have to explicitly wrap your values with the newtype to select that instance
04:21:48 <Peaker> this is a real problem in Haskell though. For example, there's a good standard way to instantiate Monoid for every ((Applicative f, Monoid a) => f a), but it cannot be made a global instance for all "f a", you need to wrap it in a newtype
04:22:29 <bahamas> ion: yes, but the problem is that I won't be able to define yesNo for the the other types
04:22:38 <bahamas> ion: that are not part of the Num class
04:23:07 <ion> Yes. I was just saying because i wasn’t sure if you wanted that or not.
04:23:49 <bahamas> ok, thank you both
04:24:49 <merijn> bahamas: Note, that if you define your own class, you can put a superclass restriction on it, for example "class Eq a => Ord a where ..."
04:25:06 <merijn> bahamas: This says that it is impossible to make a type an instance of Ord unless it is also an instance of Eq
04:25:21 * hackagebot kure 2.14.6 - Combinators for Strategic Programming  http://hackage.haskell.org/package/kure-2.14.6 (NeilSculthorpe)
04:25:22 <bahamas> merijn: yes, lyah mentioned that
04:26:09 <merijn> bahamas: Also, if you want to provide a "default" implementation the relies on the presence of Num, there are ways to do that without overlap too
04:26:31 <bahamas> merijn: I don't know what you mean by that
04:26:45 <shiona> well, it wasn't the data type that ate all the memory
04:26:45 <merijn> The default signature extension of GHC allows you to provide a "default implementation" with a less generic type
04:27:05 <bahamas> but I think I'm going too far. I'm really trying to process type classes, functors, monads, all in one day
04:27:07 <shiona> which I guess isn't a huge surprice to anyone who knows their stuff
04:27:20 <bahamas> my brain is heating up
04:27:20 <tpsinnem> merijn: hey -- have you had progress with the cabally hdevtools?
04:27:42 <merijn> bahamas: Well, as you just saw "instance Num a => Foo a where" won't work as a "default", right?
04:28:13 <merijn> tpsinnem: A little, but nothing tangible yet, I have a few open questions about cabal and dcoutts hasn't been around to answer
04:28:24 <tpsinnem> ok
04:29:02 <dcoutts_> merijn: oh I didn't know you had Qs
04:29:03 <bennofs> merijn: Maybe I can help? As I mentioned, I worked on it a little bit (for my own purposes)
04:29:09 <merijn> bahamas: You could, however write (warning: I don't remember the exact syntax): "class Foo a where myFoo :: a -> a -> Bool; default myFoo :: Num a => a -> a -> Bool; myFoo = {- implementation here -}"
04:29:36 <merijn> dcoutts_: I tried pinging you a few times last week, but didn't get a response and then I got distracted by work :)
04:30:06 <dcoutts_> merijn: oh sorry, I didn't see, #haskell gets quite busy, you could ask in #ghc or #hackage
04:32:03 <bahamas> merijn: alright. I'll come back to this when I'll feel more comfortable. thanks
04:32:23 <bahamas> I first need to put into my long-term memory what I learned today, because it's a lot already
04:34:18 <merijn> dcoutts_: I had some really implementation specific questions, mostly
04:34:30 <dcoutts_> merijn: ok
04:34:44 <dcoutts_> merijn: I'm disappearing for a bit, but ask in #ghc or #hackage
04:35:01 <merijn> dcoutts_: ok, I'll write down a list later today and then mention them there
04:35:10 <merijn> dcoutts_: I have some other work to do first anyway
04:35:10 <dcoutts_> 'k
04:35:19 <aleator> shiona: Did you get anywhere with that kd-tree?
04:37:05 <xintron> Would it be possible to build something like RabbitMQ in Haskell and get the same amount of performance without losing much when it comes to ease of writing the code (as in concurrency in Erlang I presume)?
04:37:37 <xintron> (I'm guessing the choice of Erlang was because it was easier to build Concurrent solutions than compared to Haskell)
04:39:17 <bezirg> hey ppl, how do I model a real while statement in Haskell?
04:39:43 <bezirg> my variables are not iorefs, they are simple let x = x+ 1
04:39:52 <bezirg> should I turn them to iorefs and be done with it?
04:40:36 <hiptobecubic> bezirg, conditional recursion?
04:40:38 <Axman6> let x = x+1 is something that will never terminate
04:40:51 <hiptobecubic> also what Axman6 said
04:41:02 <bezirg> Axman6: sry I mean x <- (return x) ...
04:41:08 <Axman6> ...
04:41:21 <bezirg> hiptobecubic: y
04:41:22 <Axman6> what are you actually trying to do, because things smell quite fishy
04:41:50 <bezirg> i have this language with effects, so I compile it to Haskell monadic code
04:42:19 <bezirg> imperative code like x = x+1;  becomes x <- return x (liftM2 +) return 1
04:42:41 <bezirg> this is ok, until I have to implement the while statement
04:43:03 <Axman6> foo args = do ...; check <- calculateTermination ...; when check $ foo args'
04:43:21 <bezirg> y that's what I am thinking of too
04:43:33 <quicksilver> if you want a more direct looking translation
04:43:41 <quicksilver> then jsut implement a 'while' in haskell
04:43:44 <quicksilver> and compile to that
04:44:17 <bezirg> quicksilver: I came up with this function while :: Monad m => a -> (a -> m Bool) -> (a -> m a) -> m ()
04:44:25 <quicksilver> yes, that's one possible one
04:44:46 <bezirg> is this the optimal way u think? or should I go with variables == Iorefs?
04:44:54 <quicksilver> a downside of this (compared to the recursion translation) is that the condition part will probably have to use something like IORefs
04:45:12 <quicksilver> mind you I would have thought IORefs are the natural way to translate an imperative language automatically
04:45:20 <quicksilver> the question is, what are your objectives? :)
04:45:50 <bezirg> quicksilver: speed
04:47:33 <quicksilver> dunno :)
04:47:51 <quicksilver> non-IORef might be faster but fiddlier
04:54:12 <bezirg> thx guys!
04:54:21 <shiona> aleator: yes, I was able to make it work with Word8. That did not visibly change the memory usage
04:54:23 <bezirg> and/or gals
04:54:30 <bezirg> :)
04:55:10 <shiona> Next idea was to change strictness properties, but all I could do was double the run time
05:00:45 <hseg> How do I implement mkNewEq as defined here: http://lpaste.net/100835 ?
05:01:52 <hseg> The idea basically is that I want to wrap a value in a newtype to give it an alternative Eq instance, without having to write the boilerplate of the newtype and the instance declaration.
05:02:22 <hseg> I just want to pass what (==) should mean and that's it.
05:03:48 <quicksilver> you can't, hseg
05:03:59 <quicksilver> you can't create new anonymous types
05:04:15 <quicksilver> however, you can do something pretty similar by using a wrapper type
05:04:28 <hseg> Not in pure Haskell, no. I was thinking more in the sense of some Template Haskell.
05:05:03 <hseg> The problem with a generic wrapper type is that you can't constrain the comparing functions to be equal.
05:07:18 <quicksilver> I'm not sure I understand you but don't forget that TH is staged
05:07:29 <quicksilver> it runs at a separate stage from the actual code (compile time, IOW)
05:07:36 <quicksilver> so it can't interleave with actual code
05:14:51 <hseg> Wait, can't I place a call to a TH function in the middle of an expression that will be expanded into a new sub-expression?
05:15:07 <hseg> And which might expand into some top-level definitions?
05:15:30 <quicksilver> you can, but it's only going to be called once, at compile time
05:17:27 <hseg> Once, as opposed to what?
05:17:46 <hseg> What do you think I'm trying to do that makes it being called once a problem?
05:20:08 <grohne> hseg: you are trying to create newtypes at runtime
05:20:36 <hseg> No. I'm trying to create newtypes at compile time.
05:21:19 <hseg> However, I can see how what I wrote can be interpreted as an attempt to create a newtype at runtime.
05:24:48 <certainty> hi, i just glanced over Control.Monad.Identity and saw that its status is experimental. Why is that? I suspected it to be a basic thing that just works?
05:27:33 <geekosaur> the package status isn't really that meaningful
05:28:11 <geekosaur> (which is to say, nobody really keeps an eye on whether it reflects reality much)
05:28:43 <certainty> ok thanks
05:29:23 <aleator> shiona: Did you do a memory profile?
05:30:57 <aleator> shiona: Also, note that the point-type uses boxed values. Ie. if you put word8's into Point3d you get 16 bytes of payload + probably 3*32 bits of indirection..
05:34:29 <quicksilver> aleator: s/16/64/; s/32/64/;
05:43:29 <eacameron> how do you assign a type sig in ghci?
05:43:48 <c_wraith> eacameron: you mean in a single-line let binding?
05:43:55 <eacameron> c_wraith: yes
05:44:08 <c_wraith> eacameron: two different approaches.  let x :: ... ; x = ...
05:44:21 <c_wraith> or let x = ... :: ...
05:44:33 <geekosaur> depending on what you are doing, you may need braces for the first one
05:44:38 <shiona> aleator: how would I do a memory profile
05:45:20 <eacameron> c_wraith: I've tried the second one but I can never seem to get it right
05:45:35 <eacameron> c_wraith: I've never seen the first, though, that looks promising!
05:45:41 <c_wraith> eacameron: well, the second variety doesn't include the type of the arguments, if it's a function
05:45:54 <c_wraith> eacameron: at least, it doesn't include the type of the named arguments.
05:46:09 <c_wraith> eacameron: because you're only supplying the type of the expression on the LHS of the =
05:46:32 <bergmark> is it possible to hide the "Ok, modules loaded: list-of-all-modules" message ghci? If you have a lot of modules it's pretty annoying, esp since errors are printed before that
05:46:35 <eacameron> c_wraith: that's probably what I was doing wrong
05:58:30 <dwcook> c_wraith, surely you meant to say that about the first one
05:58:39 <dwcook> c_wraith, woops, I misread
06:00:46 <hexagoxel> bergmark: verbosity 0 seems to work, or is that too brutal?
06:03:46 <hexagoxel> i can not find any details about the verbosity levels on ghc man page..
06:04:56 <quchen> Is --testsuite implicit now in sync-all?
06:05:08 <quchen> Just wondering because it wasn't recognized as a flag.
06:05:17 <bennofs> quchen: yes it is
06:05:23 <quchen> Wonderful.
06:08:28 <heatsink> bennofs, which GHC are you using for profiling?
06:08:40 <bennofs> heatsink: ghc 7.6.3
06:09:32 <heatsink> ok.  I tried it with 7.4.1.
06:09:35 <quchen> Now sync-all is failing. Could it be that the file is wrong? It tries to cline 'packages/Cabal.git', when the Cabal repo is actually 'packages-Cabal.git'.
06:10:15 <bennofs> quchen: I just did ./sync-all get -b ghc-7.8, and everything worked for me
06:10:33 * hackagebot gang-of-threads 0.0.2 - Non-deterministic parallelism with bags  http://hackage.haskell.org/package/gang-of-threads-0.0.2 (bholst)
06:11:30 <fizruk> just read "Non-deterministic parallelism with bugs" ^
06:11:35 <eacameron> whoa, I just discovered that you must declare your "data" types prior in the file to using them...
06:11:47 <heatsink> Maybe decreasing the profiling interval will reveal the bug
06:11:57 <heatsink> I'll try it
06:12:11 <quchen> bennofs: That's odd. I cloned GHC 10 minutes ago from Github.
06:12:12 <bennofs> eacameron: only if you use template haskell
06:12:12 <geekosaur> considering that constructors are discerned lexically, that's not too surprising
06:12:35 <bennofs> quchen: I did:  git clone -b ghc-7.8 git://git.haskell.org/ghc.git
06:12:45 <eacameron> bennofs: no way! I thought I was losing my mind
06:12:48 <bennofs> quchen: then, cd ghc; ./sync-all get -b ghc-7.8
06:13:11 <quchen> Maybe it's because I cloned HEAD, not 7.8.
06:13:31 <bennofs> eacameron: in particular, usage of template haskell splits the file: definitions prior to the template haskell usage cannot refer to definitions later in the file.
06:14:16 <eacameron> bennofs: profound....
06:14:47 <eacameron> bennofs: isn't there a limitation as to what functions you can use, like those defined in other files or something?
06:15:09 <eacameron> bennofs: (within template expressions)
06:17:27 <bennofs> eacameron: yes, template haskell may only use functions defined in other modules (that's called stage restriction)
06:20:49 <t7> > [+ 4, 5 -, * 2] ?? 5
06:20:51 <lambdabot>  A section must be enclosed in parentheses thus: (+ 4)A section must be enclo...
06:21:01 <t7> > [(+ 4), (5 -), (* 2)] ?? 5
06:21:04 <lambdabot>  [9,0,10]
06:22:05 <t7> @hoogle (a -> d, b -> e, c -> f) -> (a, b, c) -> (d, e, f)
06:22:06 <lambdabot> No results found
06:22:16 <BoR0> :t ??
06:22:17 <lambdabot> parse error on input `??'
06:22:21 <BoR0> :t (??)
06:22:22 <lambdabot> Functor f => f (a -> b) -> a -> f b
06:22:30 <BoR0> @src (??)
06:22:30 <lambdabot> Source not found. And you call yourself a Rocket Surgeon!
06:34:50 <FireFly> @hoogle (??)
06:34:51 <lambdabot> No results found
06:35:06 <FireFly> It's defined in lens I think
06:35:54 <bennofs> FireFly: try hayoo
06:36:00 <bennofs> :index (??)
06:36:06 <bennofs> @index (??)
06:36:06 <lambdabot> bzzt
06:37:05 <FireFly> Oh, yeah, http://hackage.haskell.org/package/lens-4.0.5/docs/Control-Lens-Lens.html#v:-63--63-
06:38:58 <khyperia> source is "fab ?? a = fmap ($ a) fab", BoR0
06:40:38 * hackagebot language-lua 0.2.3 - Lua parser and pretty-printer  http://hackage.haskell.org/package/language-lua-0.2.3 (OmerAgacan)
06:41:02 <spacekitteh> is there a decent natural number type yet?
06:41:15 <sleepynate> i'm fond of 4
06:46:54 <troydm> what's wrong with this parsing with attoparsec
06:46:56 <troydm> x <- many' (notChar '\\' <|> (liftM escapeChar $ char '\\' >> anyChar))
06:47:03 <osa1> is TemplateHaskell capable of doing something like this: I want to replace every "putMark" expression in my program with "mark 1", "mark 2", ... etc. where numbers are unique to that "putMark" expression.
06:47:05 <troydm> i get failed to satisfy
06:47:20 <troydm> sorry: Failed reading: satisfy
06:48:08 <heatsink> What input fails to parse?
06:48:48 <troydm> input: ""
06:48:56 <troydm> input: "a"
06:48:58 <troydm> any input
06:49:21 <troydm> i have this paring expression surrounded by _ <- char '"'
06:49:21 <heatsink> No, osa1.  You might be able to do it in a single file, but I wouldn't recommend it.
06:49:54 <heatsink> troydm, does anyChar accept quote characters?
06:49:57 <quchen> spacekitteh: You mean Integer >= 0, or type-level nats?
06:50:10 <osa1> heatsink: why?
06:50:20 <heatsink> I mean, does notChar accept quote characters?
06:50:29 <spacekitteh> Integer >= 0
06:50:38 <spacekitteh> or better yet >0
06:50:43 <spacekitteh> but i'll settle for >=0
06:50:51 <troydm> heatsink: yeah it does
06:51:06 <troydm> heatsink: should i change it to notChar '"' ?
06:51:31 <troydm> no, prob i shouldn't
06:51:38 <heatsink> troydm, I think that notChar '\\' is parsing the closing quote.  You need to accept characters that are neither \\ nor \" there
06:51:51 <troydm> ohh
06:52:00 <troydm> let's see it
06:52:39 <troydm> changed it to this
06:52:41 <troydm> ohhx <- many' (notChar '"' <|> notChar '\\' <|> (liftM escapeChar $ char '\\' >> anyChar))
06:52:46 <troydm> *x
06:52:56 <troydm> didn't helped
06:54:53 <heatsink> osa1, the program would be affected by the order that TH code is evaluated.
06:55:01 <quchen> spacekitteh: Hackage is full of "ℕ" packages, just look for "natural"
06:55:06 <heatsink> That is undesirable because it makes TH-based code depend on other, unrelated TH-based code
06:55:29 <quchen> spacekitteh: 'nats' is pretty basic
06:56:02 <heatsink> troydm: (notChar '"' <|> notChar '\\') === anyChar
06:56:35 <osa1> heatsink: order does not matter as far as generated ints are unique
06:56:45 <heatsink> troydm: Give me an example of a character that is both not '"' and not '\\'
06:56:48 <spacekitteh> quchen: are any of them high performance enough to put in numeric code?
06:57:23 <troydm> heatsink: a
06:57:31 <heatsink> Now give me an example of a character that is both '"' and '\\'
06:57:41 <troydm> heatsink: it can't be both
06:57:50 <troydm> heatsink: that's why i'm using <|>
06:58:09 <heatsink> What happens when you parse the backslash?
06:58:15 <quchen> spacekitteh: nats should have performance almost identical to Integer.
06:58:41 <troydm> heatsink: ohh wait i think i know what you mean
06:58:43 <spacekitteh> quchen: cool, thanks
06:59:20 <troydm> heatsink: fixed it, thx
06:59:39 <heatsink> osa1, there is no way of generating unique integers without imposing an order.
07:01:01 <heatsink> Why do you want unique integers?
07:08:56 <devnullrandom> Hello. I am composing a 'convenient' function. let myConcat x y = Foldable.toList $ Sequence.fromList x >< Sequence.fromList y     is it possible to remove the y?
07:09:57 <heatsink> let myConcat x = Foldable.toList $ Sequence.fromList x >< Sequence.fromList []
07:10:04 <heatsink> I think I don't understand the question
07:10:17 <merijn> heatsink: He wants to make it pointfree
07:10:31 <heatsink> oh
07:10:36 <devnullrandom> yes thanks
07:10:45 <devnullrandom> is it possible for it to be pointfree, from some example i have learnt
07:11:43 <heatsink> You could do that.  First change the $ term so that it passes y along, then change the >< term so that it passes y along
07:12:22 <heatsink> I think the pointfree code is too complicated though
07:12:28 <quchen> You can make any function pointfree, but it's not a very good idea to do so in most cases.
07:12:40 <mangaba_leitosa> @pl \x y -> Foldable.toList $ Sequence.fromList x >< Sequence.fromList y
07:12:40 <lambdabot> (Foldable.toList .) . (. Sequence.fromList) . (><) . Sequence.fromList
07:12:48 <mangaba_leitosa> :-O
07:13:03 <t7> @hoogle (><)
07:13:04 <lambdabot> Test.QuickCheck.Arbitrary (><) :: (Gen a -> Gen a) -> (Gen a -> Gen a) -> (Gen a -> Gen a)
07:13:04 <lambdabot> Test.QuickCheck (><) :: (Gen a -> Gen a) -> (Gen a -> Gen a) -> (Gen a -> Gen a)
07:13:04 <lambdabot> Data.Graph.Inductive.Query.Monad (><) :: (a -> b) -> (c -> d) -> (a, c) -> (b, d)
07:13:39 <quchen> You could use "on", but that's also obfuscation.  Foldable.toList `on` Sequence.fromList
07:14:27 <heatsink> It would be (><) `on` Sequence.fromList
07:15:19 <devnullrandom> Thanks, mangaba_leitosa, quchen, heatsink
07:15:35 <bennofs> devnullrandom: Why are you using (><) from Data.Sequence instead of just using (++) for lists in the first place?
07:16:04 <devnullrandom> Just practising.
07:16:22 <devnullrandom> Needed a strict ++
07:16:51 <devnullrandom> the question said y is a infinite list
07:20:10 <merijn> Don't you want a non-strict ++ then?
07:20:53 <devnullrandom> Right :) thanks
07:21:27 <merijn> > [1..5] ++ [1..] -- works fine
07:21:29 <lambdabot>  [1,2,3,4,5,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25...
07:21:39 <quchen> (++) is the non-strict version of (++).
07:21:43 <haasn> > [1..] ++ [1,3..] -- works fine
07:21:44 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
07:21:50 <merijn> > [1..] ++ [1..] -- even this works fine, but a bit useles :p
07:21:51 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
07:22:15 <quchen> inb4 [1..] ++ undefined
07:22:17 <ion> > [250..] ++ [250..] :: [Word8]
07:22:18 <lambdabot>  [250,251,252,253,254,255,250,251,252,253,254,255]
07:22:31 <haasn> > foldr (++) [] [[1,1+n..] | n <- [1..]] -- even this works fine
07:22:32 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
07:22:44 <haasn> that's an infinite number of ++ operators each operating on infinite lists
07:22:58 <ion> Evaluate all the things!
07:23:33 <haasn> > length (foldr (++) [] [[1,1+n..] | n <- [1..]] :: [Word8])
07:23:34 <lambdabot>  1705
07:23:36 <merijn> ion: Don't you mean "don't evaluate any of the things!"?
07:23:57 <haasn> merijn: evaluate the bits of the things that are needed!
07:24:15 <ion> merijn: Touché
07:24:27 <heatsink> > if let x = x in x then () else ()
07:24:30 <lambdabot>  mueval-core: Time limit exceeded
07:24:36 <heatsink> Pff, the answer is clearly ()
07:24:58 <haasn> _|_ is correct
07:25:19 <haasn> so the answer is _|_, not () -- but perhaps not clearly so ;)
07:25:20 <krgn> hiho
07:27:18 <krgn> I wonder whats the best way to format table-like output for the console. I really like ansi-wl-pprint, but if I want data in columns it might not be exactly the right tool to use
07:27:28 <krgn> anyone has a tip for a good library?
07:27:57 <quchen> if p then t else f == case p of { True -> t; False -> f }
07:28:09 <quchen> So it has to be decidable whether p is True or False.
07:28:27 <quchen> The semantics of 'case' don't allow a shortcut when all cases are identical.
07:29:55 <narendraj9__> lambdabot, > [1..10] ++ [11..20]
07:30:05 <narendraj9__> > [1..10] ++ [11..20]
07:30:05 <carlosgaldino> instance Functor ((,) a) where
07:30:05 <carlosgaldino>     fmap f (x,y) = (x, f y)
07:30:06 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20]
07:30:19 <carlosgaldino> why not fmap f (x, y) = (f x, f y)
07:30:23 <carlosgaldino> ?
07:30:40 <narendraj9__> sorry guys. I used lambdabot for the first time.
07:30:55 <Eduard_Munteanu> What's a common, simple way to read/write to a collection of records in a file?
07:31:39 <Eduard_Munteanu> carlosgaldino: think about fmap's type
07:31:41 <quchen> carlosgaldino: Tuples unify two different types. Your Functor would be the Functor for "data Tuple a = Tuple a a", not for "data (a,b) = (a,b)".
07:31:52 <quicksilver> Eduard_Munteanu: by records you mean values of a haskell data type?
07:33:09 <carlosgaldino> quchen: sorry, I didn't get it
07:33:19 <Eduard_Munteanu> quicksilver: yes, but not necessarily though, I just want to be able to look stuff up into it and add other entries
07:34:17 <Eduard_Munteanu> carlosgaldino: for 'Functor ((,) a)', you have fmap :: b -> b' -> (a, b) -> (a, b')
07:34:34 <Eduard_Munteanu> Er.
07:34:40 <quicksilver> Eduard_Munteanu: read/show; cereal; safecopy; persistent-{sqlite,postgresql}
07:34:51 <Eduard_Munteanu> carlosgaldino:  fmap :: (b -> b') -> (a, b) -> (a, b')
07:34:58 <quicksilver> Eduard_Munteanu: starting with the conceptually simplest but least flexible.
07:35:45 <Eduard_Munteanu> quicksilver: it might be a larger file and I'm concerned about performance... would cereal be appropriate to update a bunch of stuff without rewriting all of it?
07:37:46 <quicksilver> Eduard_Munteanu: no.
07:38:14 <quicksilver> Eduard_Munteanu: well, it's quite fast so it might not matter. But it would re-write it all.
07:38:14 <carlosgaldino> Eduard_Munteanu: ok, thank you
07:38:30 <quicksilver> Eduard_Munteanu: acid-state or persistent-{sqlite,postgresql} then, I think.
07:39:17 <Eduard_Munteanu> Thanks... persistent might be nice.
07:41:09 <User96> http://en.wikipedia.org/wiki/Category:People_by_city_in_the_United_States_by_state ,  stu "d!ckless" lantz betrays all; trannys & queers(chaste Homos/a$$holes), rule; andrea hylton/tranny
07:44:31 <keko_> ...what
07:47:33 <merijn> keko_: The usual freenode spam
07:47:53 <merijn> keko_: Bored teenagers try and spam channels by copypasting wikipedia and curse words
07:51:19 <Eduard_Munteanu> Any opinions on the 'vault' package?
08:03:59 <haasn> merijn: at least they're not bored teenagers with access to NTP servers
08:05:24 <hcaulfield57> What is the point of pass and listen in the Writer monad, I just don't understand what their used for.
08:05:34 <hcaulfield57> *they're
08:08:33 <ion> > runWriterT (do tell ['a']; (a,w) <- listen (do tell ['b']; tell ['c']; return 42); tell ['d']; return (a,w))
08:08:35 <lambdabot>  No instance for (GHC.Show.Show
08:08:35 <lambdabot>                     (m0 ((t0, [GHC.Types.Char]), [GHC.Types.Char])))
08:08:35 <lambdabot>    arising from a use of `M619415604368026162715045.show_M6194156043680261627...
08:08:35 <lambdabot>  The type variables `m0', `t0' are ambiguous
08:08:35 <lambdabot>  Possible fix: add a type signature that fixes these type variable(s)
08:08:52 <ion> whoops
08:08:54 <ion> > runWriter (do tell ['a']; (a,w) <- listen (do tell ['b']; tell ['c']; return 42); tell ['d']; return (a,w))
08:08:55 <lambdabot>  ((42,"bc"),"abcd")
08:09:57 <quicksilver> hcaulfield57: listen lets you observe - within the writer monad - the log messages written by some specified sub-action
08:10:21 <ion> > runWriter (do tell ['a']; a <- pass (do tell ['b']; tell ['c']; return (42, reverse)); tell ['d']; return a)
08:10:23 <lambdabot>  (42,"acbd")
08:10:32 <quicksilver> this is the only way to actually see the log "from inside" - otherwise the log is only viewable from the outside
08:11:01 <hcaulfield57> ion: Thanks I'm going to play with that example
08:11:02 <quicksilver> pass lets you apply a function to a subsection's log messages, you could imagine an example being "add indentation to this"
08:12:56 <d3lxa> how can I rewrite this: mapMaybe (\x -> fa <$> (fb x)) xs  or  mapMaybe (liftA fa . fb) xs ? that is combining fa into the functor pipeline?
08:14:12 <quchen_> d3lxa: mapMaybe (fmap fa . fb) xs, yes.
08:14:22 <quchen_> (<$>) is just infix fmap (= liftA = liftM)
08:14:28 <hcaulfield57> quicksilver: Okay, I understand how listen is used, that makes sense now, could you show me an example of pass?
08:14:50 <ion> See above for an example of pass.
08:15:49 * hackagebot xss-sanitize 0.3.5 - sanitize untrusted HTML to prevent XSS attacks  http://hackage.haskell.org/package/xss-sanitize-0.3.5 (GregWeber)
08:16:00 <d3lxa> quchen_: yup thank you :)
08:16:34 <supki_> :t mapMaybe (fmap ?f . ?g)
08:16:34 <lambdabot> (?f::a1 -> b, ?g::a -> Maybe a1) => [a] -> [b]
08:16:42 <supki_> :t map ?f . mapMaybe ?g
08:16:42 <lambdabot> (?f::a -> b, ?g::a1 -> Maybe a) => [a1] -> [b]
08:17:03 <quchen_> @free mapMaybe
08:17:04 <lambdabot> $map_Maybe g . h = k . f => $map g . mapMaybe h = mapMaybe k . $map f
08:17:24 <quchen_> Hmm.
08:17:48 <hcaulfield57> ion: Okay, I think I understand, sorry missed the example.
08:18:12 <hcaulfield57> ion, quicksilver: thanks for the help, the type signatures, didn't make it obvious how they were used
08:18:19 <d3lxa> whats @free?
08:18:20 <fizruk> quchen_: how's @free working?
08:18:28 <ski> @help free
08:18:28 <lambdabot> free <ident>. Generate theorems for free
08:18:35 <alpounet> @where free
08:18:35 <lambdabot> http://andrew.bromage.org/darcs/freetheorems
08:18:40 <quchen_> I have no idea how it works. I just know what it does. :-)
08:18:44 <ski> @google Wadler Theorems for Free
08:18:47 <lambdabot> http://ttic.uchicago.edu/~dreyer/course/papers/wadler.pdf
08:18:47 <lambdabot> Title: Theorems for free Philip Wadler University of Glasgow* June 1989 Abstract Fro...
08:18:49 <alpounet> yeah, that's it
08:19:16 <ski> @free listToMaybe
08:19:17 <lambdabot> $map_Maybe f . listToMaybe = listToMaybe . $map f
08:19:20 <ski> @type listToMaybe
08:19:21 <lambdabot> [a] -> Maybe a
08:19:34 <quchen_> Re: MonadWriter, the docs could probably use some examples and better explanations. I wonder whether that would be a welcome addition.
08:19:55 <ion> I don’t see why not.
08:20:33 <alpounet> quchen_: that would definitely will, I haven't seen many doc patches being rejected
08:21:08 <ion> It would be really cool if logged in people could edit the documentation on Hackage which would result in patches being sent to the authors.
08:21:23 <quchen_> alpounet: That's good to know. Actually the maintainer is Edwardk, who particularly liked doc patches in the past.
08:21:34 <hcaulfield57> Reader and State contain examples, that are pretty explanatory
08:21:36 <ion> on the Hackage web site, that is
08:21:36 <quchen_> In particular MonadWriter took me quite some time to understand from the docs to be honest.
08:21:53 <hcaulfield57> How do you do anything with the function in pass though?
08:22:17 <ski> iirc, there's some Wadler monad papers explaining output monads ?
08:22:18 <ion> See how “reverse” transformed the output in my example.
08:22:24 <alpounet> quchen_: yeah, he will most likely accept a small tutorial embedded in the module donc I guess
08:22:30 <ski> (amongst other monads)
08:24:51 <alpounet> ski: I think I've seen Moggi mention them too
08:24:51 <hcaulfield57> ion: It doesn't look like it did anything?
08:24:54 <hcaulfield57> runWriter (do tell ['a']; a <- pass (do tell ['b']; tell ['c']; return (42, (++""))); tell ['d']; return a)
08:25:37 <hcaulfield57> Thank gives me the same output
08:26:02 <ion> because a ++ "" = a
08:26:26 <ion> Try “map Data.Char.toUpper”
08:26:32 <hcaulfield57> Okay
08:29:02 <quicksilver> > runWriter (do tell ["a"]; a <- pass (do tell ["b"]; tell ["c"]; return (42, (map ("    "++)))); tell ["d"]; return a)
08:29:04 <lambdabot>  (42,["a","    b","    c","d"])
08:29:04 <hcaulfield57> ion: I see now, sorry, I was misunderstanding, but it makes sense now, thanks
08:29:13 <quicksilver> hcaulfield57: more realistic example maybe? not sure.
08:29:23 <quicksilver> it uses pass to add indentation to the lines from the "subroutine" part
08:29:47 <quicksilver> I just about never see people actually use writer monads, whereas I see State and Reader all the time.
08:30:23 <ion> The regexp-grid example in ersatz uses MonadWriter. :-)
08:30:40 <hcaulfield57> I'm playing around with all of them, I understand how they work, but I'm trying to gain intuition on how their used practically
08:30:49 <hcaulfield57> *they're
08:31:04 <ion> https://github.com/ekmett/ersatz/blob/master/examples/regexp-grid/RegexpGrid/Problem.hs
08:32:45 <hcaulfield57> ion: I'll see if I can understand that over lunch
08:33:26 <ion> hcaulfield57: That’s rather advanced code. That might not be the most beneficial piece of code to study as a beginner.
08:34:54 <ion> (It uses a SAT solver via the Ersatz library to solve https://github.com/ekmett/ersatz/raw/master/notes/grid.pdf)
08:36:08 <quchen_> From the Writer docs, "tell is like tell on the MUD's" - what's an MUD?
08:36:25 <dwcook> quchen_, multiplayer online text game
08:36:37 <c_wraith> very old-school.
08:36:43 <dwcook> Also Writer tell has almost nothing to do with MUD tell :P
08:36:52 <quchen_> Oh. Well that's two reasons to purge it from the docs.
08:36:52 <c_wraith> Think WoW before there were raster graphics on PCs. :)
08:36:56 <ion> It stands for multi-user dungeon.
08:37:46 <dwcook> What documentation is that even in?
08:37:58 <hcaulfield57> ion: Yea, I didn't think so :)
08:38:14 <gal_bolle> how do I initialize a MVector from a Vector?
08:38:46 <quchen_> dwcook: mtl's Control.Monad.Writer.Class
08:38:56 <quchen_> Simple comment, not Haddock
08:39:12 <quchen_> I don't get half of the comments there.
08:39:34 <Richie_> Hi guys ! little question, i try postgres-simple, but doc lacks on to toRow http://hackage.haskell.org/package/postgresql-simple-0.4.0.2/docs/Database-PostgreSQL-Simple-ToRow.html , i don't how build the instance http://lpaste.net/100842
08:39:36 <dwcook> Oh ha, I guess that's not *quite* as bad… :P
08:39:38 <quchen_> "Note, the partially applied function type @(->) r@ is a simple reader monad." -- Okay, but why is that relevant here?
08:39:55 <c_wraith> Holy crap, I suddenly understand why I should implement foldMap instead of foldr for Foldable
08:40:06 <quchen_> "See the @instance@ declaration below." -- Good thing to write as the very last sentence before said instance declaration
08:40:09 <quchen_> c_wraith: elighten us?
08:40:44 <dwcook> foldr is very list-centric
08:40:49 <dwcook> That's my intuitive reasoning
08:40:53 <c_wraith> quchen_: because monoids guarantee associativity, you don't need to construct the calculation in a strictly left-to-right manner
08:40:56 <gal_bolle> just found Data.Vector.thaw, don't know how I missed it, sorry for the noise
08:41:32 <quchen_> I usually went with the pragmatic solution, which says "use fold instead of foldr because it's easier to implement".
08:41:50 <quchen_> Oh, the directional argument is compelling, c_wraith.
08:42:04 <Richie_> no one, can help me with postgresql-simple ?
08:44:43 <gwern> 'Since my knowledge of Haskell is rather limited (but I wrote some programs in Miranda many years ago), can you recommend a package of very typical Haskell sources (there is no such thing as typical sources, I know) so I can do tests?' https://bugs.debian.org/cgi-bin/bugreport.cgi?bug=499328
08:45:03 <gwern> any suggestions on a package of very vanilla normal haskell code?
08:45:10 <c_wraith> gwern: I was going to say it's sort of unusual for you to drop by these days.  But I guess you have a reason. :)
08:45:26 <gwern> c_wraith: yes, unfinished business from 4 years ago
08:45:51 <gwern> (the wheels of open source can grind slowly indeed)
08:45:52 * hackagebot dirfiles 0.1.0.4 -   http://hackage.haskell.org/package/dirfiles-0.1.0.4 (HugoGomes)
08:45:54 <monochrom> does xmonad counts as vanilla normal?
08:46:05 <monochrom> or hledger
08:46:11 <gwern> monochrom: mm, not sure. CPP, custom operators...
08:46:20 <supki_> Richie_: instance (ToField a, ToField b) => ToRow (a,b)  may be helpful
08:47:05 <supki_> Richie_: you can either reuse it or lookup the code and do the same thing
08:47:14 <monochrom> pick one of the CSV libraries. randomly pick one.
08:48:48 <gwern> fair enough
08:50:35 <orbisvicis> can I use ghci like a script interpreter, similar to python (python -c "read stdin; myscript") or perl (even easier: 'perl -ne "operation" ...')
08:50:54 <Richie_> supki_ thanks, i'll try :)
08:51:01 <c_wraith> orbisvicis: you can use ghc that way
08:51:34 <c_wraith> orbisvicis: haskell isn't designed for terse string handling, though, so it's not as good for that sort of thing.
08:51:38 <ion> ghc -e 'print 42'
08:52:08 <joelteon> yeah, I'd just go with perl were i you
08:52:59 <orbisvicis> c_wraith: ion: that's very neat.
08:53:21 <orbisvicis> joelteon: maybe...  aside from the io, everything else is terse
08:54:26 <joelteon> yep, but IO is a part of string handling
08:54:32 <joelteon> maybe you could use interact
08:54:47 <joelteon> but still, perl has regular expression support and all that, and that's not nearly as easy in haskell
08:58:44 <zipper> What does :b do? I thought it meant browse but it doesn't.
08:58:53 <zipper> *:browse
09:01:29 <Kron> is there anything like a cond statement in haskell?
09:01:38 <artyomkazak> zipper: it's a command of GHCi's debugger
09:01:39 <Kron> a list of guards without an associated function definition
09:02:38 <zipper> artyomkazak: Explain just a bit.
09:02:40 <artyomkazak> Kron: either use MultiWayIf extension or there's a “cond” function in Boolean package
09:02:48 <Kron> ah! okay
09:03:00 <artyomkazak> zipper: ouch, sorry. It allows setting breakpoints.
09:03:24 <artyomkazak> load a file, type “:b 13” and it'll set a breakpoint on 13th line
09:03:36 <artyomkazak> or you can do “:b functionName”
09:03:40 <zipper> All I get are such errors "cannot set breakpoint on..."
09:04:36 <no-n> is there a way to exit a do statement before the end, like using return in other languages?
09:04:48 <Kron> hmmm, is there any difference between the boolean <--> function and ==?
09:04:53 <zipper> I have seen
09:04:57 <c_wraith> no-n: depends on the implementation of >>=
09:04:58 <artyomkazak> zipper: what file are you trying to use it at?
09:05:03 <c_wraith> no-n: sometimes yes, sometimes no
09:05:08 <zipper> artyomkazak: How do I undo that?
09:05:11 <no-n> hmm, actually using guards will do in this situation
09:05:47 <zipper> artyomkazak: I had tried :b map and got "cannot set breakpoint on map: module GHC.Base is not interpreted"
09:06:04 <hcaulfield57>  /quit
09:06:13 <artyomkazak> zipper: no, you can only set breakpoints on file you've currently loaded into GHCi
09:06:30 <artyomkazak> *in
09:07:34 <artyomkazak> zipper: there's a small tutorial here: http://www.haskell.org/ghc/docs/7.0.1/html/users_guide/ghci-debugger.html
09:07:38 <zipper> artyomkazak: I just read about it
09:08:04 <zipper> artyomkazak: I read that after asking.
09:08:07 <zipper> artyomkazak: My bad
09:08:48 <artyomkazak> ghci's debugger isn't very usable or easily understandable
09:09:18 <quicksilver> artyomkazak: I think you actually can set breakpoints on other files than the current file - as long as they are interpreted
09:09:29 <quicksilver> if you want to force this for your own code you delete any .o files lying around
09:09:38 <quicksilver> but for libraries you're out of luck.
09:09:47 <zipper> Wow breakpoints. I used them in ruby via pry but I didn't know what they were called.
09:09:59 <zipper> Now I know :D
09:10:10 <quicksilver> I must admit I've never done haskell debugging that way
09:10:28 <quicksilver> I've always favoured the "program in small bits which can be tested/explored/debugged from ghci" approach
09:10:31 <zipper> quicksilver: We used then for rails.
09:10:46 <artyomkazak> quicksilver: yep, I've just checked, you're right. Thanks
09:10:54 <Kron> haskell has breakpoints?
09:11:00 <zipper> rails apps are kinda hard to debug. Especially because the code base started growing un unplanned ways.
09:11:01 <Kron> I just make small functions and use undefined stubs a lot
09:11:11 <zipper> and the code was all over
09:11:48 <zipper> The classes got mixed up in weird ways and we did a lot of bad thing so that we could ship code ASAP
09:12:32 <zipper> Kron: I wish to learn to write stubs and those little tests in haskell. I took a mooc on racket and we used stubs quite a bit.
09:13:47 <c_wraith> zipper: the first pass of doing that comes directly from the compiler.  Write a top-level name, followed by its type.  Then set the binding for that name as undefined.  Then tweak that until you have something that looks right and type checks.
09:14:02 <Kron> "undefined" is one of my favorite things ever
09:14:11 <Kron> complexFunction this that theOther = undefined
09:14:13 <Kron> and it compiles!
09:14:14 <c_wraith> zipper: and you can always throw an undefined in where you don't know what that particular part is.
09:14:17 <Kron> come back to it later
09:14:20 <Kron> yeah
09:14:41 <Kron> undefined always typechecks
09:14:46 <Kron> and crashes your program on evaluation
09:15:05 <Kron> it's basically a free plug you can use to seal up holes in large code skeletons
09:15:05 <c_wraith> zipper: I actually wrote an article with some examples of doing this recently - https://www.fpcomplete.com/user/chowells79/types-not-tutorials
09:15:20 <c_wraith> Kron: it doesn't *always* type-check. :)
09:15:25 <Kron> shhhh
09:15:27 <Kron> details
09:15:29 <zipper> c_wraith: lol thanks was having trouble following you
09:15:41 <c_wraith> But you need some language extensions for it to fail to type-check
09:16:15 <Kron> and it's just so... I donno, visually neat
09:16:26 <Kron> it's like the incomplete nature of the program is automatically apparent to any casual reader
09:16:37 <Kron> function = undefined is basically self explanatory
09:20:16 <zipper> c_wraith: Your way of making instances of a typclass is weird all you did was: instance "typeclass" "type"
09:21:54 <eacameron> I had an innocent cabal project (< 200 lines) and I just introduced containers...blam cabal complains I need to reinstall transformers and that likely breaks virtually everything...any ideas?
09:22:22 <bennofs> eacameron: Please post the output of the cabal command you ran using -v2 as an argument
09:23:57 <eacameron> bennofs: http://lpaste.net/100847
09:24:47 <monochrom> how many containers do you have? get rid of all those not came with GHC
09:24:53 <eacameron> bennofs: I haven't added any versions to my "build-depends"...
09:25:06 <eacameron> monochrom: not sure what you mean?
09:25:13 <bennofs> eacameron: ghc-pkg list containers
09:25:48 <eacameron> ahhh
09:25:52 <bennofs> eacameron: then ghc-pkg unregister containers-0.5.4.0 and repeat that for any other version of containers that is not 0.5.0.0
09:25:57 * hackagebot cabal-bounds 0.2.1 - A command line program for managing the bounds/versions of the dependencies in a cabal file.  http://hackage.haskell.org/package/cabal-bounds-0.2.1 (DanielTrstenjak)
09:26:18 <monochrom> read my http://www.vex.net/~trebla/haskell/sicp.xhtml
09:26:47 <eacameron> monochrom: cool, I will
09:27:20 <eacameron> bennofs: monochrom: it says "ghc-pkg: unregistering containers-0.5.4.0 would break the following packages: attoparsec-0.11.2.1 Cabal-1.18.1.3"
09:27:39 <eacameron> I guess this is dependency hell, huh?
09:28:12 <monochrom> you will have to get rid of them also now, and rebuild later but using what comes with GHC
09:28:43 <eacameron> so downgrade them both? does removing them accomplish that, I guess?
09:29:32 <monochrom> I wouldn't call it "downgrade". but "get rid of" = "remove" this should be pretty obvious
09:30:35 <monochrom> you may be still in disbelief that you have to give up some things. but this is why I wrote the article.
09:33:08 <yarbles> why is the current haskell release called 7.8.1, but when you do ghc --version you get 7.8.0?
09:33:39 <yarbles> actually you get 7.8.0.20140228
09:33:50 <monochrom> the current release is still 7.6.3
09:34:29 <yarbles> well the current rc for 7.8
09:34:38 <yarbles> http://www.well-typed.com/blog/87
09:34:51 <monochrom> that's rc for you. do you understand the "c" part?
09:35:11 <Andrej_T_> hey guys, i have a question (i'm new to haskell, python/js dev.) I want to make a simple program that takes two command line arguments and adds them. i wrote this: https://gist.github.com/whoeverest/9415960
09:35:31 <Andrej_T_> at line 17 i want to somehow handle the IO list of strings
09:35:44 <yarbles> i would guess c stands for candidate.  candidates never deliver on their promises.  it promises 7.8.1 but delivers 7.8.0.
09:36:37 <monochrom> since it is a candidate, it is before-7.8.1 rather than right-exactly-at-7.8.1. therefore, 7.8.0 is logical.
09:37:22 <yarbles> ah ok, now i get it
09:37:43 <Kron> I think I found an error on the haskell wiki, but I'm not sure since I'm not fantastic at haskell
09:37:45 <Andrej_T_> my question is: what do i need to do to convert the IO list of strings to a normal list, so i can convert them to integers later
09:37:47 <Kron> http://www.haskell.org/haskellwiki/GHC/TypeHoles
09:38:02 <Kron> shouldn't it be "Free f >>= g = Free _"?
09:38:11 <Kron> or wait... I guess there is a _ there, I just can't see it... hmm
09:38:17 <Kron> browser error I guess, nevermind
09:38:31 <pordan30__> getArgs:: IO [String], so "args" is a list of strings (in particular, the arguments)
09:38:43 <monochrom> Andrej_T_: when you write "line <- Env.getArgs", line is already a list, you can already give it to parseIntList
09:39:42 <Andrej_T_> oh, that's right. thanks!
09:40:15 <eacameron> monochrom: thanks for the dose of reality...I was living in a fairland I guess; but how did Cabal let me get to this point without any trouble?
09:41:36 <monochrom> the authors of cabal think that multiple versions and instances is safe.
09:41:47 <monochrom> well, I think, and you see, that it is unsafe. we need to petition.
09:42:53 <Clint> this is the hell that .debs save you from
09:43:40 <monochrom> debian packages give a different hell. they circumvent a safety check that ghc-pkg does
09:44:04 <monochrom> the world is not black and white. it's all black.
09:44:48 <Clint> monochrom: what's the safety check?
09:47:48 <zebr> @pl \f g x -> maybe h (f g) (f x)
09:47:48 <lambdabot> flip =<< (((.) . maybe h) .)
09:48:26 <monochrom> when you ask "ghc-pkg register" to register containers-0.5.0.0, ghc-pkg checks that containers-0.5.0.0 does not already exist.
09:48:36 <monochrom> see my article.
09:48:39 <Mathnerd314> so, I ran into http://stackoverflow.com/questions/11907922/linking-error-using-hslua-on-windows . I tried --gcc-options="-D__NO_ISOCEXT", didn't work... any recommendations?
09:48:52 <zebr> @pl \f g x -> maybe h (f g) (g x)
09:48:53 <lambdabot> ((.) . maybe h =<<)
09:51:06 <kadoban> ChongLi: Thanks again for your recommendations on vim integration. Finally got everything (except unite.vim) set up, it's super nice so far.
09:51:59 <Cale> Andrej_T_: You should think of a value x :: IO t as being like a program which is capable of producing a value of type t when it's run. In the do-notation for an IO action, you can write v <- x, which means "run the action x and name its result v"
09:52:14 <Cale> Andrej_T_: and so whenever x :: IO t, then v :: t there
09:52:30 <eacameron> monochrom: thanks...my simple library works now!
10:06:02 * hackagebot bytestring-arbitrary 0.0.1 - Arbitrary instances for ByteStrings  http://hackage.haskell.org/package/bytestring-arbitrary-0.0.1 (tsuraan)
10:13:32 <phyre> Is this an alright implementation of a switch-like function for a list (being treated as an array)? http://lpaste.net/1180220862201069568
10:16:01 <orbisvicis> when using ghc -e is it possible to import modules outside the program ? (ghc --import MyModule -e "program")
10:16:25 <supki_> orbisvicis: ghc -e 'import M' -e 'program'
10:16:53 <supki_> ghc also reads ~/.ghci so you can put common imports there
10:16:59 <orbisvicis> supki_: thanks
10:25:58 <realmen> hi
10:26:55 <path[l]> "All three men reported their concerns through the official, approved process, and all three men were subject to armed raids by the FBI and threats of criminal sanction."
10:26:58 <path[l]> sounds right
10:27:13 <path[l]> they werent arrested though, so what i said just now was wrong
10:27:18 <path[l]> but I pasted that nearly an hour ago
10:27:37 <path[l]> more importantly ,this wasnt an option snowden had, if you read further down in the document
10:28:18 <path[l]> "As an employee of a private company rather than a direct employee of the US government, I was not protected by US whistleblower laws, and I would not have been protected from retaliation and legal sanction for revealing classified information about lawbreaking in accordance with the recommended process."
10:30:08 <joelteon> oh ok
10:45:06 <pjdelport> I have a recursion pattern question. Is there some standardized function that implements something inbetween unfoldr and mapAccumL?
10:46:04 <pjdelport> I'm trying to express a mixed-radix numeric base conversion function elegantly.
10:46:05 <adelbertc_> has anyone tried both haskellmode-vim and vim2hs?
10:46:42 <bennofs> dcoutts: Is there any particular reason why the zlib package does not use pkg-config?
10:47:00 <dcoutts> bennofs: historically zlib did not use pkg-config
10:47:12 <dcoutts> and probably still doesn't on anything other than linux
10:47:22 <dcoutts> and recent linux at that
10:48:57 <bennofs> dcoutts: Hmm, ok. Also, ghc 7.8 reports a warning: ‘Stream’ is an instance of Monad but not Applicative - this will become an error in GHC 7.10, under the Applicative-Monad Proposal. (From Codec/Compression/Zlib/Stream.hsc)
10:49:08 <dcoutts> bennofs: ok, ta
10:57:25 <pjdelport> The function I have is something like: toMixedBase placeValues n = mapAccumL quotRem n placeValues
10:59:12 <pjdelport> That converts a number to a list of mixed-base digits, where placeValues is a list of the radix sizes
11:01:19 <pjdelport> for example, toMixedBase [60,60,24] will convert a number to seconds, minutes, and hours
11:02:33 <pjdelport> This works for a finite list of placeValues, though, and not an infinite list
11:12:28 <pjdelport> The other approach is very similar, but uses unfoldr to generate only as many digits as are significant:
11:13:30 <pjdelport> toBase base = unfoldr (\n -> if n == 0 then Nothing else let (q,r) = quotRem n base in Just (r,q))
11:14:21 <pjdelport> However, that only works with a fixed base
11:16:56 <pjdelport> Is there some way to combine the strengths of the two approaches? That is, taking a list of mixed-radix place values like the mapAccumL approach, but also lazily generating all the significant digits, like the unfoldr approach?
11:20:03 <pjdelport> It seems like the function I'm looking for should be like mapAccumL, but taking a function (acc -> x -> Maybe (acc, y)) instead, so that it supports signalling termination, like unfoldr.
11:20:19 <pjdelport> Does something like this exist?
11:20:48 <pjdelport> Or is it expressible using the more standard list recursion schemes?
11:27:51 <enthropy> pjdelport: consider foldr with the accumulator having type (acc,[y])
11:28:30 <enthropy> but maybe that gets threaded in the "wrong" direction
11:30:25 <pjdelport> enthropy: I considered trying that, but having to manually unpack each element of [y] (and having to explicitly handle the case of it becoming empty) seemed significantly messier than what mapAccumL provides
11:30:25 <Cale> mapAccumR is "wrong"
11:30:57 <Cale> I kind of wish that someone would fix it, even if it would then contradict the standard
11:36:26 <eacameron> is there a way to have a `where` clause for a lambda?
11:36:36 <eacameron> or perhaps a multiline `let...in`?
11:36:39 <Cale> eacameron: You can use let
11:37:10 <eacameron> Cale: huh...for some reason I'm getting a parse error...but now that I know its doable, I'll mess with it
11:37:49 <Cale> Make sure that the rest of the definitions inside the let are lined up with the first non-whitespace character after 'let'
11:39:18 <Cale> So it'll look something like
11:39:23 <Cale> let foo = ...
11:39:29 <Cale>     bar = ...
11:39:36 <Cale>  in something foo bar
11:39:45 <eacameron> here it is: http://lpaste.net/100854
11:40:06 <pordan30__> could you write a custom version of mapAccumL with something like mapAccumL f v (x : xs) = (snd $ f v x) : mapAccumL f (fst $ f v x); this wouldn't return the accumulator, though.
11:40:27 <Cale> eacameron: Oh, your problem is that you need a do-expression to glue together those statements in the 'in' part.
11:40:38 <eacameron> Cale: ohhhh
11:41:03 <eacameron> yup...that was it
11:41:13 <eacameron> I feel like a noob everyday
11:41:24 <eacameron> eventhough i've been using haskell (very lightly) for 3 years!
11:45:14 <eacameron> gee I wish there was a way to load a module in GHCi and have it load all the symbols that worked, even if some were broken
11:45:25 <eacameron> as it is, if even one is broken, the whole module fails
11:47:11 <klugez> eacameron: -fdefer-type-errors
11:47:32 <eacameron> kludgez: surely you jest
11:48:11 <klugez> http://www.haskell.org/ghc/docs/7.6.1/html/users_guide/defer-type-errors.html
11:49:20 <eacameron> kludgez: you just caused a thousand flowers to bloom before my eyes
11:49:24 <pjdelport> enthropy: I have a version based on unfoldr with that accumulator, but it seems about as messy as expected.
11:49:47 <pordan30__> > let mal f v xs = case xs of {[] -> []; (x : xs) -> (snd $ f v x) : mal f (fst $ f v x) xs } in take 20 $ mal quotRem 1000 [1..]
11:49:49 <lambdabot>  [0,0,2,2,1,2,1,0,0,0,0,0,0,0,0,0,0,0,0,0]
11:49:53 <eacameron> kludgez: sorry for the poetry...this is just awesome news
11:51:14 <RaceCondition> how would I rewrite `countWhere pred xs = length $ filter pred xs` to be point-free?
11:51:16 <kadoban> wow, defer type errors looks super useful...how did i not know about that
11:51:44 <pjdelport> pordan30__: I'd like it to terminate when the remaining quotient reaches zero, though
11:51:53 <heatsink> @pl \pred xs -> length $ filter pred xs
11:51:53 <lambdabot> (length .) . filter
11:52:38 <pjdelport> :t let (.:) = (.).(.) in length .: filter
11:52:39 <lambdabot> (a -> Bool) -> [a] -> Int
11:53:13 <RaceCondition> pjdelport: ...in a human-friendly fashion :P
11:53:35 <RaceCondition> heatsink: (length .) . filter is quite nice... I couldn't figure out the (length .) part--thanks!
11:53:43 <pjdelport> RaceCondition: (.).(.) is actually a commonly useful (and human-friendly) combinator for this
11:53:52 <heatsink> :t  let (…) = (.) . (.) in length … filter
11:53:52 <lambdabot> lexical error at character '\128'
11:54:02 <RaceCondition> pjdelport: human friendly maybe from an experienced Haskeller point of view
11:54:11 <heatsink> Did I not set up unicode properly?
11:54:20 <pjdelport> RaceCondition: basically, you'll say "f . g" if g takes one argument, and "f .: g" if g takes two arguments
11:54:32 <RaceCondition> I'm reading http://evincarofautumn.blogspot.co.uk/2012/02/why-concatenative-programming-matters.html and there's this `countWhere = length filter` example which I thought could be equally nice in Haskell
11:54:38 <geekosaur> LB has various unicode issues
11:55:08 <RaceCondition> pjdelport: I'll have to wrap my head around (.).(.) first
11:55:12 <heatsink> Ah, that's too baad
11:58:54 <heatsink> Does "concatenative" mean combinator-based?
12:00:08 <mountaingoat> talk about nsfw ascii art, sheesh
12:00:52 <klugez> I think it refers to stack-based languages. Like Forth and Factor.
12:04:31 <pordan30__> > let mal f v xs = case xs of { [] -> []; (x : xs) -> maybe [] (\(a,b) -> b : mal f a xs) (f v x) }; f x y = if (snd $ quotRem x y) == 0 then Nothing else Just (quotRem x y) in mal f 121 ([60,60,24] ++ [1..])
12:04:33 <lambdabot>  [1,2]
12:10:15 <eacameron> I'm annoyed by this pattern, how can I improve it? bool <- getBoolFromFile; when bool $ do ...
12:11:35 <ClaudiusMaximus> eacameron: http://holumbus.fh-wedel.de/hayoo/hayoo.html#0:whenM
12:12:13 <eacameron> ClaudiusMaximus: figures....should have checked myself; thanks for not eating me alive
12:13:23 <ClaudiusMaximus> eacameron: it seems defined all over in many different packages... guess it's a common need
12:16:18 <pjdelport> pordan30__: That's why I'm looking for something more elegant, yeah... compare all that to "mapAccumL quotRem n placeValues"
12:18:35 <pordan30__> pjdelport: i agree
12:27:32 <haasn> booleans :(
12:27:50 <haasn> whenFileCond $ do ...
12:28:13 <haasn> food for thought: do fun <- getFunFromFile; fun $ ...
12:37:29 <akahn> I'm trying to print a list of strings using map. I don't understand the type error I'm getting. can someone explain this to me? http://lpaste.net/3448263529235218432
12:37:56 <geekosaur> you can't use map that way, perhaps you meant mapM_?
12:38:18 <geekosaur> map did what you told it to, mapped an IO action over a list of strings producing a list of IO actions
12:39:21 <akahn> ah, right
12:39:36 <akahn> thank you kindly
12:40:35 <Guest54431> actually
12:40:36 <Guest54431> http://hackage.haskell.org/package/base-4.6.0.1/docs/Prelude.html#v:sequence_
12:41:25 <geekosaur> you could do that, but mapM_ exists
12:41:39 <geekosaur> and exists pretty much for this use case
12:41:45 <mietek> What exactly does --enable|disable-executable-dynamic do, and which one is the default?
12:42:01 <akahn> what is mapM doing exactly
12:42:16 <tmhedberg> Guest54431: mapM_ f = sequence_ . map f
12:42:21 <milfjord> @src mapM
12:42:21 <lambdabot> mapM f as = sequence (map f as)
12:42:33 <milfjord> @src mapM_
12:42:33 <lambdabot> mapM_ f as = sequence_ (map f as)
12:42:48 <Guest54431> > sequence_ . map putStrLn [1..3]
12:42:49 <lambdabot>  Couldn't match expected type `a0 -> [m0 a1]'
12:42:49 <lambdabot>              with actual type `[GHC.Types.IO ()]'
12:43:18 <Guest54431> > sequence_ . map putStrLn ["hello", "world"]
12:43:19 <lambdabot>  Couldn't match expected type `a0 -> [m0 a1]'
12:43:19 <lambdabot>              with actual type `[GHC.Types.IO ()]'
12:43:35 <Guest54431> > sequence_ $ map putStrLn ["hello", "world"]
12:43:36 <lambdabot>  <IO ()>
12:43:38 <geekosaur> (.) only works with values that are functions
12:43:41 <akahn> map didn't work because I was attempting to map an IO action over a list of strings, producing a list of IO actions. mapM_ *does* do what I want because it is still mapping an IO action of a list of strings but...
12:44:03 <Guest54431> geekosaur: yep I really need some sleep -->
12:44:07 <geekosaur> but then it applies sequence_ to them, which applies a list of IO actions producing an IO action
12:44:08 <milfjord> mapM_ combines those actions into one
12:44:09 <geekosaur> so do I
12:44:12 <milfjord> :t sequence_
12:44:13 <lambdabot> Monad m => [m a] -> m ()
12:44:22 <Guest54431> :t mapM_
12:44:23 <lambdabot> Monad m => (a -> m b) -> [a] -> m ()
12:44:34 <Guest54431> :t (sequence_ . mapM_)
12:44:35 <lambdabot>     Couldn't match type `[a1] -> m1 ()' with `[m0 a0]'
12:44:35 <lambdabot>     Expected type: (a1 -> m1 b0) -> [m0 a0]
12:44:35 <lambdabot>       Actual type: (a1 -> m1 b0) -> [a1] -> m1 ()
12:44:36 <geekosaur> and discarding the resulting value from executing it, which for putStrLn is IO ()
12:44:42 <Guest54431> :t (sequence_ . map)
12:44:43 <lambdabot>     Couldn't match type `[a1] -> [b0]' with `[m0 a0]'
12:44:43 <lambdabot>     Expected type: (a1 -> b0) -> [m0 a0]
12:44:43 <lambdabot>       Actual type: (a1 -> b0) -> [a1] -> [b0]
12:44:49 <akahn> the key is that it applies the IO actions
12:45:05 <geekosaur> mapM would give you a list filled with (), which is kinda useless
12:45:34 <milfjord> :t sequence
12:45:35 <lambdabot> Monad m => [m a] -> m [a]
12:45:48 <milfjord> "do all the things in that list, and collect the results"
12:47:49 <Guest54431> > sequence [Just 3, Just 4]
12:47:50 <lambdabot>  Just [3,4]
12:48:06 <Guest54431> > sequence [[1, 2], [3, 4]]
12:48:07 <lambdabot>  [[1,3],[1,4],[2,3],[2,4]]
12:48:08 <Iceland_jack> > sequence ["hi", "bye", "sigh"]
12:48:09 <lambdabot>  ["hbs","hbi","hbg","hbh","hys","hyi","hyg","hyh","hes","hei","heg","heh","ib...
12:50:50 <Guest54431> > sequence [(1, 2), (3, 4)]
12:50:52 <lambdabot>  No instance for (GHC.Show.Show t0)
12:50:52 <lambdabot>    arising from a use of `M207653621172287714315717.show_M2076536211722877143...
12:50:52 <lambdabot>  The type variable `t0' is ambiguous
12:50:52 <lambdabot>  Possible fix: add a type signature that fixes these type variable(s)
12:50:52 <lambdabot>  Note: there are several potential instances:
12:54:39 <akahn> is there no pair monad? or is there just no way to show it?
12:55:28 <milfjord> how would return work?
12:55:49 <akahn> I don't know
12:57:14 <bennofs> akahn: what's the pair monad? (a,a) ?
12:57:53 <akahn> I don't know what I'm talking about, I just saw Guest54431 exercising sequence with Maybe and list
12:58:46 <bennofs> akahn: There is instance Monoid w => Monad ((,) w) in GHC 7.8 at least,I think
12:58:53 <bennofs> akahn: the writer monad
12:59:31 <haasn> > sequence [("hello",3), ("world",4)]
12:59:33 <lambdabot>  Could not deduce (GHC.Base.Monad ((,) [GHC.Types.Char]))
12:59:33 <lambdabot>    arising from a use of `Control.Monad.sequence'
12:59:33 <lambdabot>  from the context (GHC.Num.Num a)
12:59:33 <lambdabot>    bound by the inferred type of
12:59:33 <lambdabot>             it :: GHC.Num.Num a => ([GHC.Types.Char], [a])
12:59:35 <haasn> Ah okay
12:59:41 <haasn> Not in lambdabot then
12:59:57 <pordan30__> there is also instance Monad ((,) a) where return = (,) defaultValue; m >>= f = f $ snd m
13:00:07 <pordan30__> i think
13:01:13 <pavonia> pordan30__: What is defaultValue?
13:06:24 * hackagebot base-compat 0.4.2 - A compatibility layer for base  http://hackage.haskell.org/package/base-compat-0.4.2 (SimonHengel)
13:07:34 <Cale> pordan30__: Yeah, there's really a monoid instance involved there though, it's just not a very good one. :)
13:07:59 <Cale> Well, probably shouldn't make judgment calls like that
13:08:00 <pordan30__> does (,) a need to have a monoid constraint on a for the monad laws to hold?
13:08:07 <Cale> yes
13:08:21 <pordan30__> that's what i thought, when pavonia asked the question
13:08:34 <Cale> In particular the monad laws use the monoid laws directly
13:08:54 <Cale> The left unit law for the monad comes from the left unit law for the monoid, and so on.
13:08:55 <benmachine> actually if you prove the monad laws for ((,) a) you've proven that a is a monoid
13:09:02 <ownclo> does ghc perform Tail-Call Optimisation explicitly or it's just built into STG?
13:09:02 <Cale> yes
13:09:17 <Cale> ownclo: There's no call stack
13:09:32 <Cale> ownclo: The evaluation model is so different that TCO doesn't exactly mean as much
13:10:07 <pordan30__> yeah, i was concerned about the left and right unit laws; sounds like a good exercise
13:10:39 <ownclo> Cale: if a recursion is not tail-recursive which stack grows?
13:11:02 <milfjord> ownclo: none
13:11:23 <milfjord> function calls don't use a stack
13:11:32 <Cale> ownclo: There is a stack in GHC which is used for pattern matching, case expressions which are waiting for their scrutinee to be sufficiently evaluated to match go on there
13:12:11 <Cale> It's also used while evaluating a function value into a lambda in order that it can be applied to its argument, but it's very uncommon for such a thing to take much reduction.
13:12:32 <Cale> (I have never witnessed a stack overflow from that)
13:13:14 <Cale> e.g. if you have  f x  then you need to evaluate f into the form (\v -> ...) in order to be able to apply the function.
13:13:24 <haasn> but if you have something like sum (x:xs) = x + sum xs, then the evaluation of (+) requires that “sum xs” be evaluated first, so an implementation strategy would be to pop “x +“ on the evaluation stack and calculate sum xs first. This is still distinct from call stacks, and is not related to tail calls at all. Because Haskell has no function calls
13:13:29 <haasn> Just function applications
13:14:09 <Cale> Yeah, the way I think of that is that the definition of (+) is pattern matching on both its arguments (which it does in the case of Integer)
13:14:10 <Reite> Will forkIO threads continue if the main finishes execution?
13:14:22 <Cale> and one of those pattern matches waits on the stack
13:14:29 <Cale> Reite: no
13:14:39 <Reite> ok so the main thread wont wait for the forkIO threads?
13:14:53 <Cale> Reite: When main exits, the whole program stops immediately
13:15:45 <Reite> Ok thanks!
13:17:36 <Andrej_T_> Cale: thanks, I guess I'll get the hang of it as I practise :)
13:17:48 <heatsink> Cale, that sounds like a chain of continuations
13:17:59 <heatsink> Isn't the stack in ML implementations a chain of continuations?
13:18:19 <kadoban> is it me or is it weird that there's no Array lookup that returns a Maybe?
13:18:46 <Cale> kadoban: You mean to handle cases where the index is out of range?
13:18:58 <kadoban> Cale: yeah
13:19:24 <Cale> Yeah, I guess that is a little strange.
13:20:21 <kadoban> doesn't seem like you can really implement one from the outside either, in a general way...unless i'm missing something. oh well, guess i'll use a different data structure
13:21:28 <milfjord> why can't you implement it?
13:21:51 <kadoban> milfjord: well, how do i test in general if a key is in the index?
13:22:00 <Guest54431> kadoban: what about: safeIndex n xs = if n < length xs then Just (xs !! n) else Nothing
13:22:14 <milfjord> Guest54431: arrays
13:22:25 <kadoban> Guest54431: arrays, not lists :/ that would work for lists, yeah
13:22:33 <Guest54431> milfjord: oops sorry
13:22:41 <milfjord> :t inRange
13:22:42 <lambdabot> Ix a => (a, a) -> a -> Bool
13:22:44 <milfjord> :t bounds
13:22:45 <lambdabot> Ix i => Array i e -> (i, i)
13:23:14 <milfjord> if inRange (bounds arr) i then Just (arr ! i) else Nothing
13:23:23 <heatsink> Should use unsafeIndex
13:23:27 <kadoban> milfjord: oh, haha...thanks, that works!
13:23:27 <heatsink> No point in checking bounds twice
13:27:55 <carter> who wants to comment on https://github.com/github/markup/issues/196 to pester github more :)
13:37:28 <haasn> :t (//)
13:37:29 <lambdabot> Ix i => Array i e -> [(i, e)] -> Array i e
13:37:38 <haasn> Interesting
13:37:45 <haasn> I wonder if that would make sense as an operator version of ‘div’
13:38:06 <Shammah> Hey, I loaded a .hs in GHCi with :l that contains a single function no type signature. However, GHCi did not warn me of a lack of type signature of the function. How can I enable this?
13:38:15 <Shammah> *with no type signature
13:39:08 <bennofs> Shammah: :set -Wall
13:39:26 <Shammah> Ah that did it, thanks!
13:39:46 <Shammah> Anyway to set it this permanently?
13:40:33 <carter> haasn: why?
13:40:48 <haasn> carter: just for symmetry with /, I guess
13:40:54 <carter> heh
13:40:58 <haasn> integer vs. fractional division
13:41:07 <carter>  /.
13:41:12 <acowley> o/
13:41:16 <carter> acowley: !
13:41:17 <haasn> :t (/.)
13:41:17 <Shammah> nvm, figured it out!
13:41:18 <lambdabot>     Not in scope: `/.'
13:41:18 <lambdabot>     Perhaps you meant one of these:
13:41:18 <lambdabot>       `.' (imported from Data.Function),
13:41:20 <haasn> Aaw
13:41:23 <haasn> :t (./)
13:41:23 <lambdabot>     Not in scope: `./'
13:41:24 <lambdabot>     Perhaps you meant one of these:
13:41:24 <lambdabot>       `.' (imported from Data.Function),
13:41:29 <carter> haasn: i'm making a suggestion
13:41:32 <carter> for lifted pointwise
13:41:34 <haasn> Isn't that used for scalar division somewhere
13:41:41 <carter> ML i think
13:42:02 <bennofs> Shammah: you can also pass that flag to ghci when starting, like ghci -Wall ... you can create an alias for that
13:42:05 <tmhedberg> haasn: Matlab uses it for that I think
13:42:33 <Shammah> bennofs, I find it easier to have a config file, looks like all I needed to do was create the file ~/.ghci
13:42:41 <bennofs> Shammah: that works too of course
13:42:44 <haasn> oh, it's .*^
13:42:48 <haasn> maybe ./^?
13:43:12 <RaceCondition> heatsink: re: concatenative--I think it's what J. Backus' FP is all about
13:43:47 <carter> haasn: theres no such operation in haskell yet
13:58:01 <Noldorin> I'm learning about functors & applicatives here, but I'm struggling to see the use of plain old functors. applicatives can be used for non-deterministic computation, okay... but what else?
13:58:48 <Iceland_jack> Noldorin: well, 'map' :)
13:59:00 <Iceland_jack> @src [] fmap
13:59:01 <lambdabot> fmap = map
13:59:19 <Noldorin> true
13:59:29 <Noldorin> but that can be done just as easily without functors really
13:59:42 <Iceland_jack> Also
13:59:42 <Iceland_jack>     "you have a 'Maybe Int' value and you want to turn it into a 'Maybe String'."
13:59:42 <Iceland_jack>  
13:59:44 <Iceland_jack> what do you do?
13:59:57 <Iceland_jack> > fmap show (Nothing :: Maybe Int)
13:59:58 <lambdabot>  Nothing
14:00:00 <Iceland_jack> > fmap show (Just 5 :: Maybe Int)
14:00:01 <lambdabot>  Just "5"
14:00:06 <Iceland_jack> and a million other things
14:00:29 <fizbin> What are the dangers of adding -XLiberalTypeSynonyms to your project?
14:00:42 <Noldorin> Iceland_jack, okay. but that's their essential use, yeah? there's no other big use case I presume
14:00:46 <Iceland_jack> Noldorin: You wouldn't be doing it without functors, maybe without the Functor type class but map would still be fmap for the Functor []
14:01:15 <Iceland_jack> Noldorin: I wonder what you consider big use case
14:01:22 <Noldorin> Iceland_jack, sure. but I'm just saying you don't need to treat it as a Functor. Functor is just an abstraction here...
14:01:25 <Noldorin> Iceland_jack, well, try me :)
14:01:30 <Noldorin> with any use cases you consider notable
14:01:31 <Iceland_jack> it's a pattern that appears everywhere
14:01:42 <Noldorin> okay
14:02:20 <[swift]> fizbin: i don't have an answer for you, but thanks for making me aware of LiberalTypeSynonyms. that's something i've wanted for quite some time
14:02:21 <Noldorin> and applicative functors? are they basically about non-determinism?
14:02:33 <Iceland_jack> Noldorin: No
14:02:34 <Noldorin> that is, parallel computation paths
14:02:40 <Noldorin> that what it seems like to me :P
14:02:52 <Noldorin> don't see what else they're good for
14:02:54 <Noldorin> so please tell ne
14:03:01 <Iceland_jack> > liftA2 (++) (Just "a") (Just "b")
14:03:02 <lambdabot>  Just "ab"
14:03:07 <Iceland_jack> Not very parallel
14:03:11 <Noldorin> hmm
14:03:12 <Noldorin> okay
14:03:13 <[swift]> fizbin: it sounds like they're not so liberal that the expanded version can have a different kind than the pre-expansion type synonym, though, which makes me sad. still can't hide the (forall s) on an ST-like monad, AFAICT
14:03:17 <Iceland_jack> @ty liftA2 (++) getLine getLine
14:03:18 <lambdabot> IO [Char]
14:04:10 <Iceland_jack> Noldorin: One usefulness of functors is of course applicative functors :)
14:04:24 <Iceland_jack>     class Functor f => Applicative f where
14:04:24 <Noldorin> Iceland_jack, is that equivalent to (++) <$> getLine <*> getLine ?
14:04:27 <Iceland_jack> Yes
14:04:30 <Noldorin> okay
14:04:46 <Noldorin> Iceland_jack, woah. all Functors are Applicatives?
14:04:51 <Iceland_jack> No, other way around
14:05:06 <tmhedberg> Applicative is Functor plus <*>
14:05:15 <Noldorin> then what does  class Functor f => Applicative f where mean?
14:05:17 <Noldorin> okay
14:05:22 <dagle> All monads are functors too.
14:05:30 <Noldorin> dagle, and applicatives I hear
14:05:36 <dagle> Indeed
14:05:45 <Iceland_jack> Noldorin: Just look hard at the type signature of ‘fmap’
14:05:45 <Iceland_jack>     fmap :: Functor f => (a -> b) -> (f a -> f b)
14:05:45 <Iceland_jack> it's basically lifting a computation to some context (lists, IO, maybe, .....), you'll see that pattern everywhere
14:05:56 <Noldorin> fair enough
14:06:01 <Iceland_jack> s/computation/function/
14:06:12 <Noldorin> Iceland_jack, yeah I guess I need to go beyond tutorials to see their usefulness in real life really
14:07:18 <pjdelport> Noldorin: the hierarchy basically goes Monad < Applicative < Functor; each is a specialization of the next
14:07:26 <byorgey> Noldorin: looking for "applications" of the Functor class *in isolation* is a bit of a red herring.  The idea is more that (1) functors show up *everywhere*, so (2) it's useful to be able to abstract over them
14:07:39 <Noldorin> byorgey, yeah I'm starting to get that nice. thanks :)
14:07:42 <Noldorin> get thatn ow*
14:07:49 <Noldorin> darn, I can't type today
14:07:53 <byorgey> hehe, no worries =)
14:07:54 <pjdelport> alternatively, you can see each as adding functionality to the one above it
14:08:09 <Noldorin> pjdelport, yeah that's a good way to look at it...
14:08:46 <pjdelport> Functor is so useful because it's so general; like byorgey says, it's *everywhere*
14:09:24 <Iceland_jack> Noldorin: A more ‘concrete’ example, imagine asking
14:09:24 <Iceland_jack>     why do we have a Num type class with (+)? couldn't we just define
14:09:24 <Iceland_jack>         addInt    :: Int    -> Int    -> Int
14:09:24 <Iceland_jack> 	addDouble :: Double -> Double -> Double
14:09:27 <Iceland_jack> 	addFloat  :: Float  -> Float  -> ...?
14:09:33 <Iceland_jack> can, aligning..
14:09:34 <Iceland_jack> *gah
14:09:41 <pjdelport> it's a powerful, wide foundation to build more sophisticated general abstractions on top of (like Applicative and Monad)
14:09:44 <milfjord> > fmap (* 2) (+ 1) 20
14:09:45 <lambdabot>  42
14:10:01 <jroesch_> carter: I can complain at them (I'm very good at it)
14:10:20 <carter> jroesch_: oh , they said they're gonna merge it in and release soooon
14:10:35 <Iceland_jack> Noldorin: You absolutely could, and you could duplicate your code effort: a function summing a list of elements would have to be duplicated as well
14:10:35 <Iceland_jack>     sumDouble :: [Double] -> Double
14:10:35 <Iceland_jack>     sumInt    :: [Int]    -> Int
14:11:59 <Noldorin> so for an applicative, are (<$>) , fmap , and \f -> pure f <*>  ?
14:12:04 <Noldorin> all the same *
14:12:25 <milfjord> @src (<$>)
14:12:26 <lambdabot> f <$> a = fmap f a
14:12:32 <Iceland_jack> '\f -> (pure f <*>)', yes
14:13:02 <Noldorin> Iceland_jack, ah okay, you need the brackets I guess...
14:15:40 <byorgey> Noldorin: <$> is just a synonym for fmap, so they are always the same.  \f -> (pure f <*>)  is supposed to be the same as fmap (it's an Applicative law)
14:15:47 <Noldorin> right
14:16:18 <Iceland_jack> Noldorin: You can basically play this game with every abstraction :) “why are for/while loops so great? I can implement them using jumps”
14:16:46 <jfischoff> So I have something that is like a monoid, but the append also takes in an index associated with each element. Does this type of operation have a name?
14:16:50 <laar> :t (<*>) . pure
14:16:51 <lambdabot> Applicative f => (a -> b) -> f a -> f b
14:17:09 <Iceland_jack> jfischoff: What kind of index is it?
14:17:12 <Cale> jfischoff: What do you mean by 'index' in this case?
14:17:13 <jfischoff> appendWithIndex :: a -> a -> (Int, Int) -> a
14:17:37 <jfischoff> So I want to glue simplical complexes together by there face indices
14:17:55 <jfischoff> not sure if that is exactly the right way to say that
14:18:10 <Cale> Is it still a monoid if you take the elements to be (Int, a) pairs?
14:18:25 <jfischoff> Cale yeah but what would it return?
14:18:32 <Cale> Good point :)
14:18:36 <Noldorin> Iceland_jack, byorgey, also trying to understand why something like fmap (+) (Just 2) $ 5  doesn't work
14:18:42 <Cale> What operation on simplicial complexes is this?
14:19:07 <byorgey> Noldorin: what do you expect it to do?
14:19:08 <tmhedberg> Noldorin: fmap (+) (Just 2) == Just (2+)
14:19:11 <Iceland_jack> Noldorin: Because
14:19:11 <Iceland_jack>     fmap (+) (Just 2) :: Maybe (Int -> Int)
14:19:11 <Iceland_jack> (simplified)
14:19:13 <jfischoff> Not exactly sure what it is called, maybe that is the first step
14:19:15 <Iceland_jack> that's not a function
14:19:25 <Cale> jfischoff: Well, can you describe it a little better?
14:19:27 <Noldorin> tmhedberg, oh of course!
14:19:28 <Noldorin> thanks
14:19:32 <ion> > fmap (+) (Just 2) <*> pure 5
14:19:34 <lambdabot>  Just 7
14:19:34 <Noldorin> Iceland_jack, yeah
14:19:38 <Cale> jfischoff: What do the Int values represent?
14:19:48 <Iceland_jack> jfischoff: Could you add the indices to the type-level? :)
14:19:53 <Cale> jfischoff: Top-dimensional faces of the complexes?
14:20:07 <Noldorin> tmhedberg, byorgey , and that's precisely what Applicatives are useful, I suppose
14:20:16 <Noldorin> Iceland_jack, ^
14:20:47 <jfischoff> Cale: one sec ...
14:21:34 * hackagebot sloane 1.1 - A command line interface to Sloane's On-Line Encyclopedia of Integer Sequences  http://hackage.haskell.org/package/sloane-1.1 (AndersClaesson)
14:22:16 <Noldorin> Iceland_jack, so really it's just the composition applicative functor that gives the effect of non-deterministic/parallel computation eh?
14:22:33 <Shammah> Hmm, http://codepad.org/0hE5itkv somehow the first one fails but the second one doesn't. I'm sure I'm indenting the where clause correctly? I get 'parse error on input `=''
14:22:43 <Iceland_jack> Noldorin: It depends entirely on the underlying applicative functor
14:22:55 <Noldorin> Iceland_jack, I said composition functor :)
14:23:18 <Iceland_jack> I'm not sure what you mean by that, do you mean ((->) r)?
14:23:23 <Noldorin> yeah
14:23:24 <Iceland_jack> That's not parallel
14:23:34 <milfjord> [] is sort of nondeterministic
14:23:34 <Noldorin> well it sure gives the effect of it...
14:23:40 <Noldorin> milfjord, yeah that too
14:23:58 <Iceland_jack> Not really
14:24:03 <jfischoff> Cale: I can't find the name of shape I want. But take two tetrahedra with labeled faces, and glue the two faces together to get a diamond polyhedra
14:24:04 <Cale> Shammah: Are there any tabs in your source code?
14:24:12 <jfischoff> so whatever that is called :)
14:24:19 <jfischoff> Cale: does that make more sense?
14:24:59 <milfjord> "a polyhedra" :-(
14:25:02 <Cale> jfischoff: Okay. So imagine an operation on k-pointed complexes, which are complexes together with a specific k-dimensional face selected
14:25:03 <Iceland_jack> Noldorin: https://hackage.haskell.org/package/async-2.0.1.5/docs/Control-Concurrent-Async.html
14:25:05 <jfischoff> Cale: that would be the simplest inductive step, the shapes get more complicated as you glue faces together more
14:25:17 <jfischoff> Cale: no just 3d
14:25:22 <jfischoff> that's all I care about :)
14:25:23 <Iceland_jack> Noldorin: Look at the 'newtype Concurrently' with the Applicative instance
14:25:24 <Shammah> Cale, doh! I'm using vim instead of my usual text editor for the first time since ages, forgot that vim doesnt convert tabs to spaces
14:25:35 <jamieklassen> i think they are called "chains" in algebraic topology
14:25:36 <Cale> Shammah: It will if you :set expandtab
14:25:43 <milfjord> :set et sw=4 sts=4
14:25:45 <Shammah> thanks, will do that
14:26:03 <Iceland_jack> When you do
14:26:03 <Iceland_jack>     ... <$> Concurrently a <*> Concurrently b
14:26:03 <Iceland_jack> it creates a computation which will run a and b concurrently
14:26:20 <jamieklassen> jfischoff: does "chains" sound right?
14:26:35 <jfischoff> maybe
14:26:43 <Cale> jfischoff: Well, in any case, you have structures with some identified k-dimensional face, and when you glue them together at that face, it's still a face of the resulting structure (isn't it?)
14:27:02 <Cale> jfischoff: Or are you deleting the face where they're being glued?
14:28:03 <jfischoff> Cale: I wasn't planning on deleting them. I see what you are saying. the face is internal and has be reindexed
14:28:18 <jfischoff> So it would make sense to return it
14:29:04 <jfischoff> Cale: do I appear to understand you correctly?
14:29:14 <Cale> jfischoff: and then you can glue more things to that face, and the operation will be associative, commutative, and it has an identity (a single face)
14:29:15 <Cale> yeah
14:29:36 <jfischoff> okay cool, the answer is ... its a monoid yay!
14:29:39 <Cale> You might not want to actually *expose* the Int used to index
14:30:13 <jfischoff> why not?
14:30:28 <Cale> Well, you won't get the monoid laws on the nose
14:30:38 <jfischoff> oh
14:30:40 <Cale> It'll just be up to isomorphism of the resulting complexes
14:31:04 <jfischoff> ah right
14:31:14 <jfischoff> different index same simplex
14:31:24 <jfischoff> simplical complex :p
14:32:08 <Noldorin> Iceland_jack, ah okay, so the function applicative, what I was just talking about... it's really for sort of building up nested functions?
14:32:30 <Cale> Shammah: btw, you should probably consider using guards there
14:32:47 <cdh473> give up the regex!
14:32:50 <jfischoff> That's interesting. Similar problem with syntax trees I guess
14:33:01 <Cale> Shammah: also, you use head and tail, where you'd probably be better off pattern matching
14:33:11 <cdh473> \latex
14:33:26 <Iceland_jack> Noldorin: You can think of it as adding an 'environment'
14:33:29 <cdh473> spandex?
14:33:38 <Noldorin> Iceland_jack, I prefer my way to think about it. I think it's accurate :)
14:33:49 <Noldorin> since you haven't refuted it heh..
14:34:05 <Noldorin> i'll presume it's pretty much right
14:34:28 <Iceland_jack> That's your choice
14:34:50 <Noldorin> Iceland_jack, well you're not saying it's wrong, so i'll take it as a plus :)
14:35:06 <Iceland_jack> Well, it isn't parallelism
14:35:16 <Noldorin> Iceland_jack, i didn't say that just now!
14:35:18 <Noldorin> i said something new
14:35:27 <Noldorin> don't make up things
14:35:27 <Cale> jfischoff: btw, what are you doing with simplicial complexes? :)
14:36:28 <Iceland_jack> Noldorin: Right but, 'building up nested functions' doesn't mean much and doesn't describe what ((->) r) does without describing a million different things
14:36:45 <Noldorin> Iceland_jack, nor does "adding an environment" in honesty :P
14:37:08 <Iceland_jack> yes it does, it supplies every value with an implicit environment
14:37:15 <Noldorin> that's your opinion
14:37:15 <Iceland_jack> Does
14:37:15 <Iceland_jack>     plusTwo x = plusOne (plusOne x)
14:37:15 <Iceland_jack> also build nested functions?
14:37:22 <Noldorin> you're talking about English language semantics here
14:37:33 <Noldorin> and I'd argue I know the English later better than you... but that's another point
14:38:39 <Iceland_jack> You can argue that, it's not really an opinion since it's the basis of something called the Reader monad
14:38:46 <Iceland_jack> also known as the environment monad
14:38:51 <jroesch_> Carter: cool, looks like it has been sitting there a while since Richard opened it
14:39:03 <carter> jroesch_: well
14:39:06 <carter> not any more :)
14:39:26 <jfischoff> Cale: Well what I am trying to do, and I just realized that what I just discussed won't help, is come up with the operations for constructing simplical complexes that are always homomeorphic to manifolds
14:39:32 <Noldorin> Iceland_jack, okay, but you're being pigheaded. who said whoever named that named it well? probably they weren't very good with English.
14:40:22 <tmhedberg> Noldorin: The name descibes exactly what it does
14:40:24 <Iceland_jack> It seems like you take issue with other people's English instead of backing your views up
14:40:39 <Noldorin> tmhedberg, in my view, no. it's an unapt description
14:41:07 <Noldorin> and given I'm a linguist, I know what I'm talking about
14:41:15 * monochrom frowns. what is this debate about?
14:41:39 <Noldorin> people being stuck up their own self-righteous arses, it would seem.
14:41:43 <Noldorin> on which note I'm off
14:41:50 <tmhedberg> You can think of ((->) r) as an implicit extra parameter being passed around, i.e. an implicit environment
14:41:56 <Kaidelong> (the irony)
14:42:06 <Iceland_jack> I believe the word of the day is 'projection'
14:42:23 <Noldorin> Kaidelong, no, the truth. turning an a statement around like that is a petulantly childish thing to do.
14:42:41 <jfischoff> Cale: or maybe more precisely a simplical complex where all of the vertices links have discs
14:43:17 <jfischoff> I guess that would Euler characteristic 0
14:44:29 <jfischoff> Cale: a better way to think about it would be I have 2d simplical complex and I can glue faces and delete them
14:44:32 <jfischoff> I think
14:44:39 <haasn> monochrom: I don't know, but based on the amount of cursing I'm seeing at least on one side I don't think I need to know, either
14:44:41 <jfischoff> Cale: does any of this make sense?
14:46:07 <jfischoff> Cale: it's for a mesh modeling. I want mesh operations that preserve the topology and keep manifolds as manifolds.
14:48:33 <ij> @pl \(a,b,c) -> [a,b,c]
14:48:33 <lambdabot> (line 1, column 7):
14:48:33 <lambdabot> unexpected "c"
14:48:33 <lambdabot> ambiguous use of a non associative operator
14:48:44 <ij> @pl \p@(a,b,c) -> p
14:48:44 <lambdabot> (line 1, column 3):
14:48:44 <lambdabot> unexpected "@"
14:48:44 <lambdabot> expecting letter or digit, operator, pattern or "->"
14:48:46 <ij> wth^
14:49:27 <Hafydd> @_@
14:49:27 <akahn> is there any function like !! but than I can supply a fallback value to if my index is out of bounds?
14:49:44 <Hafydd> @pl \(a,b,c) -> a:b:c:[]
14:49:44 <lambdabot> (line 1, column 7):
14:49:45 <lambdabot> unexpected "c"
14:49:45 <lambdabot> ambiguous use of a non associative operator
14:49:52 <Hafydd> Okay, then.
14:50:02 <Iceland_jack> Hafydd: It doesn't seem to accept 3-tuples for some reason
14:50:24 <ij> Still, is there a :: (a,a,a) -> [a]
14:51:53 <vanila> no
14:52:25 <Cale> jfischoff: Sorry, went to dinner for a bit there
14:52:45 <Hafydd> @hoogle (a,a,a) -> b
14:52:46 <lambdabot> Network.HTTP.Base matchResponse :: RequestMethod -> ResponseCode -> ResponseNextStep
14:52:46 <lambdabot> Data.Typeable typeOf3 :: Typeable3 t => t a b c -> TypeRep
14:52:46 <lambdabot> Data.Typeable typeOf2Default :: (Typeable3 t, Typeable a) => t a b c -> TypeRep
14:52:54 <Guest54431> hey folks, is it possible to add a constraint to a typevariable of fmap? i.e. in fmap :: Functor f => (a -> b) -> f a -> f b I need to enforce Eq a
14:53:08 <Guest54431> (for a specific instance of course)
14:53:23 <Cale> jfischoff: Yeah, that operation isn't good if you want to make manifolds, however you'll probably want the connected sum
14:53:38 <Guest54431> since the signature is specified by the typeclass I guess not but I don't see another way around my problem
14:53:40 <Cale> jfischoff: http://en.wikipedia.org/wiki/Connected_sum
14:53:44 <Iceland_jack> Guest54431: This is called the constrained functor/monad problem, there are some solutions but they're quite involved and don't work for all cases
14:54:02 <Guest54431> Iceland_jack: at least now I can put a name on it! thanks
14:54:11 <johnw> Iceland_jack: the ConstraintKind solution looks pretty decent
14:54:26 <jfischoff> Cale: heh, I remember this from topology class!
14:54:48 <Guest54431> basically I am trying to implement the Basket example around 15:00-18:00 in http://vimeo.com/6590617
14:54:50 <Iceland_jack> johnw: yes, not sure I'd recommend it for the faint of heart though
14:55:00 <Iceland_jack> Well, once it's up and running it's quite nice
14:55:29 <Hafydd> @pl f x y z = [x,y,z]
14:55:29 <lambdabot> f = (. ((. return) . (:))) . (.) . (:)
14:55:54 <jfischoff> Cale: I think there is algebraic way to do, once you represent the objects as planar things with identified edges or something
14:56:11 <ij> vanila, you're cold ;-D Thanks.
14:56:16 <Hafydd> :t uncurry3 (. ((. return) . (:))) . (.) . (:)
14:56:17 <lambdabot>     Not in scope: `uncurry3'
14:56:17 <lambdabot>     Perhaps you meant `uncurry' (imported from Data.Tuple)
14:57:42 <vanila> haha
14:58:23 <Guest54431> Iceland_jack: is there any way at all to get around it?
14:58:26 <Guest54431> even a dirty hack
14:59:39 <Iceland_jack> Guest54431: You can look at the implementation of http://hackage.haskell.org/package/set-monad and http://www.ittc.ku.edu/~neil/papers_and_talks/constrained-monad-problem.pdf
15:00:08 <Guest54431> Iceland_jack: thanks!
15:00:34 <Iceland_jack> The paper mostly covers monads, but it does mention the Constrained-Functor problem which is simpler to solve
15:01:08 <Iceland_jack> There is also a talk on it on the Galois webpage: http://vimeo.com/69261960
15:01:27 <Iceland_jack> *on Galois' Vimeo page
15:01:36 <Guest54431> Iceland_jack: oh great; have you seen the talk I was talking about? http://vimeo.com/6590617
15:02:06 <Iceland_jack> No I don't think so
15:06:37 <eacameron> why does ghc complain about top-level bindings with no signature for things like: topLevel = 5 :: Int
15:07:22 <monochrom> "5 :: Int" is not a type signature. "topLevel :: Int" is.
15:13:03 <eacameron> monochrom: oh, i c
15:53:13 <Sebboh> Greetings.  I'm a longtime Debian user, and I've decided to learn some new things, so I've built an Arch GNU/Linux machine and now I'm installing aura. It's a package manager type thing apparently implemented in Haskell.  I figured, why not, as I intend to use Snap or Happstack on this new machine anyway, might as well get used to these things.  So... I see the aura-bin package, but I'd rather learn to build it.  Which brings me to
15:53:13 <Sebboh> package haskell-tls-extra. Build fails: Setup: At least the following dependencies are missing: tls >=1.1.0 && <1.2.0.  I believe it is referring to a haskell package named tls, not the Arch package named tls.  Is this correct?
15:54:01 <zennist> For a list, how can I insert a term before each and every element? e.g. fun 5 [1,2,3] = [5,1,5,2,5,3]
15:55:03 <tmhedberg> Sebboh: Yes, Cabal doesn't know anything about Linux distro packages
15:55:05 <shepheb> what's the go-to package for fancy terminal handling? http://hackage.haskell.org/package/ncurses ?
15:55:30 <tmhedberg> I would avoid trying to mix cabal-installed Haskell packages and pacman-installed Haskell packages
15:55:39 <kayloos_> fun y (x::xs) = y ++ x ++ fun xs
15:55:45 <Kaidelong> > (:) 5 . intersperse 5 $ [1,2,3]
15:55:46 <lambdabot>  [5,1,5,2,5,3]
15:55:53 <Kaidelong> so umm
15:56:00 <Sebboh> tmhedberg: it's cpan all over again. :)
15:56:05 <Kaidelong> @ty (:) <*> intersperse
15:56:06 <lambdabot>     Couldn't match type `[a0]' with `[a0] -> [a0]'
15:56:06 <lambdabot>     Expected type: a0 -> [a0]
15:56:06 <lambdabot>       Actual type: a0 -> [a0] -> [a0]
15:56:41 <Kaidelong> @ty intersperse
15:56:42 <lambdabot> a -> [a] -> [a]
15:56:42 <CandyCorns> I would do fun y (x:xs) = y : x : fun xs
15:56:53 <tmhedberg> Sebboh: Yeah, it's a common problem
15:57:02 <Kaidelong> why doesn't (:) <*> intersperse work?
15:57:15 <tmhedberg> shepheb: If you don't need anything too fancy, ansi-terminal is pretty easy to use
15:57:49 <tmhedberg> There are a few packages with ncurses bindings if you want the extra stuff ncurses does, like input events and windowing
15:58:08 <Sebboh> tmhedberg: do you happen to know the minimal set of pacman packages required to support cabal?  Can cabal keep all its packages in $HOME/.somedirectory, or does it require super-user privleges?
15:58:21 <magicman> Kaidelong: (<*>) :: Applicative f => f (a -> b) -> f a -> f b; if (:) :: f (a -> b) and intersperse :: f a, what are f, a, and b?
15:59:07 <tmhedberg> Sebboh: I usually just install ghc and cabal-install via the package manager, and everything else gets installed in my home directory by cabal
15:59:34 <Sebboh> great.  Thanks!
15:59:37 <jamieklassen> Sebboh: I've got cabal on freebsd with everything in ~/.cabal
16:01:11 <Sebboh> I'll aim to do that.  It probably means just using the bin package of this 'aura' tool. *shrug*
16:01:58 <tmhedberg> Sebboh: Does "cabal install aura" not work?
16:04:27 <Sebboh> I don't know yet, and that doesn't seem to be the installation method described on their home page.  It's a linux package manager, so I'd imagine that they generally use linux packages to deliver it.. (:
16:05:51 <ffwacom__> YOU MENA HASKELL?!
16:15:16 <Axman6> ffwacom__: what?
16:17:45 <copumpkin> should I prefer Put or Builder in Data.Binary? is it purely a difference in monoid vs. writer?
16:17:53 <copumpkin> are there performance differences?
16:25:49 <k00mi> Put is a pretty thin wrapper around Binary, it shouldn't matter
16:27:31 <Sebboh> After I've done cabal install json, let's say...  Under what circumstances could I run a haskell program so that it wouldn't find the json package that I've installed?
16:27:55 <Sebboh> Hm, sudo...?
16:28:33 <k00mi> Sebboh: if .cabal/bin is not in your PATH
16:29:26 <dcoutts_> k00mi: I think Sebboh is talking about not finding a lib, rather than not finding a program
16:29:33 <tmhedberg> That would be for executables; if theres a library which can't find its json dependency then it would be some other reason
16:30:04 <k00mi> ah, right
16:30:06 <dcoutts_> Sebboh: if you installed it with: sudo cabal install, then that will indeed screw things up because it'll mean all the files belong to root (but still are under your home dir)
16:31:02 <Sebboh> Well, ~/.cabal/bin/cabal was not on my path.  I'll fix that.  I do own the .cabal directory.
16:31:12 <Sebboh> What is runhaskell?
16:31:37 <Axman6> haskell interpreter
16:32:00 <khyperia> Are there any documented, standard transformations to turn a lambda calculus (with primops) language into an imperative one (maybe LLVM)?
16:32:26 <dcoutts_> khyperia: take a look at the STG papers
16:33:15 <dcoutts_> khyperia: or if you just want something very simple then look at the early interpreter / abstract machines
16:33:38 <khyperia> right
16:33:43 <khyperia> thanks
16:34:32 <copumpkin> yeah, it looks like Builder is a lighter abstraction
16:34:49 <copumpkin> I'll stick with that, especially since I don't even like the writer stuff much
16:46:50 * hackagebot inflections 0.1.0.4 - Inflections library for Haskell  http://hackage.haskell.org/package/inflections-0.1.0.4 (jsl)
16:56:00 <CandyCorns> Has there been much research for getting Haskell to work on embedded devices?
16:57:00 <Axman6> CandyCorns: it's not really well suited for embedded devices, but it is very well suited for producing code for embedded devices. see Atom and Copilot
16:58:12 <CandyCorns> Axman6: Awesome, thank you. I'll start looking there
17:01:52 * hackagebot inflections 0.1.0.5 - Inflections library for Haskell  http://hackage.haskell.org/package/inflections-0.1.0.5 (jsl)
17:24:20 <levi> CandyCorns: Also see smaccmpilot.org
17:27:01 <CandyCorns> levi: Oh wow, this looks like it's exactly what I was looking for. Thanks a bunch!
17:29:50 <Iceland_jack> ah thanks levi as well :) I was actually looking for this for writing my own EDSL
18:47:03 * hackagebot gtk3 0.12.5.5 - Binding to the Gtk+ graphical user interface library.  http://hackage.haskell.org/package/gtk3-0.12.5.5 (HamishMackenzie)
18:47:06 * hackagebot gtk 0.12.5.5 - Binding to the Gtk+ graphical user interface library.  http://hackage.haskell.org/package/gtk-0.12.5.5 (HamishMackenzie)
18:51:55 <ij> To get to Word16 from Word8, I fromInteger.toInteger?
18:57:42 <BMeph_> ij: Why not just "fromIntegral"? :)
18:57:47 <carter> yeah
18:57:47 <carter> that
18:57:58 <pordan30> the data.word documentation says: "for coercing between any two integer types, use fromintegral, which is specialized for all the common cases...coercing word types to an from integer types preserves representation, not sign." so you can use fromintegral specialized to Word8 -> Word16
19:02:59 * ij bows.
19:08:52 <pordan30> have there been serious attempts to introduce strongly-typed computations (ala monads) into traditional imperative languages? i ask because, having learned to program on languages like haskell, i'm finding the lack of strongly-typed computations quite unnatural and unsafe now that i'm getting around to learning c (which shows that 'natural' really means 'what i'm comfortable with' 99% of the time).
19:09:29 <geekosaur> lots, generally unsuccessfully because few of them have the machinery to handle that level of polymorphism and the ones that do (e.g. C++ templates) are hell
19:10:14 <geekosaur> but see LINQ
19:14:09 <pordan30> ah, so their type systems have generally been extended to allow (bounded? higher-ranked?) parametric polymorphic types, but as an optional component like in the LINQ library, not as part of the language specification.
19:14:13 <Galactic> does someone here uses emacs with the haskell-mode on windows?
19:18:37 <no-n> @hoogle compareBy
19:18:38 <lambdabot> No results found
19:20:28 <artyomkazak> no-n: did you mean `comparing`?
19:20:44 <no-n> no. some reason i thought there was compareBy too, heh
19:20:57 <no-n> although i can't think what it would do that's different from comparing :p
19:21:58 <ij> How slower is Integer likely to be?
19:22:07 * hackagebot gtk3 0.12.5.6 - Binding to the Gtk+ graphical user interface library.  http://hackage.haskell.org/package/gtk3-0.12.5.6 (HamishMackenzie)
19:22:08 <copumpkin> than Int?
19:22:09 * hackagebot gtk 0.12.5.6 - Binding to the Gtk+ graphical user interface library.  http://hackage.haskell.org/package/gtk-0.12.5.6 (HamishMackenzie)
19:22:13 <copumpkin> quite a bit, but it's not slow
19:23:08 <geekosaur> also keep in mind that, at leats in ghc, if you keep your values small enough they will quietly be Ints anyway
19:23:32 <ij> Hmm.
19:23:32 <carter> so
19:23:36 <geekosaur> I think they only get kicked up to gmp integers if there's a risk of a computation overflowing an Int
19:23:41 <geekosaur> @src Integer
19:23:41 <lambdabot> data Integer = S# Int#
19:23:41 <carter> use Integer if you want an integer
19:23:42 <lambdabot>              | J# Int# ByteArray#
19:23:58 <carter> geekosaur: and theres been some tuning to make it faster in 7.8
19:24:09 <Axman6> geekosaur: but there's overhead form Integer having two constructors
19:24:16 <carter> Axman6: shhh
19:24:35 <carter> Axman6: most code isn't bottlenecked inmath
19:24:39 <carter> :P
19:24:40 <geekosaur> there is, but it's less than the overhead of gmp, even as highly tuned as that usually is
19:24:51 <carter> that too
19:25:25 <Axman6> right. but if you know it'll be less than abs maxBount :: Int, use Int
19:25:28 <Axman6> d*
19:25:42 <carter> Axman6: yes, but most people dont' use that correctly
19:25:47 <carter> so they should use integer
19:26:27 <carter> though if youre counting network events on a single computer, Int64 will last you  1k years
19:26:38 <carter> soooooo, sometimes just use Int64
19:26:48 <carter> Int should only be used for indexing arrays
19:26:58 <carter> othrewise use  Int32 or Int64 explictily
19:27:03 <Axman6> agreed
19:27:04 <carter> or you'll have to use lots of CPP :)
19:27:23 <carter> Int should be call TypeForArrayIndices
19:27:39 <Axman6> Word sho9uld be that really
19:27:46 <cpehle> i want to use a lens to prepend an element to a list in a record, there is <>=
19:28:03 <carter> Axman6: not quite,
19:28:20 <carter> beause you want to talk about indexing differences and array arrith
19:28:43 <enthropy> you could use  Ix i => i
19:28:47 <Axman6> hmm, I guess. but still, there are better ways to do that
19:28:59 <cpehle> but no apparent analogue for cons (in a StateMonad)
19:29:26 <Axman6> can you use some modify operator?
19:31:15 <carter> enthropy: what type should i use for indexing on the surace?
19:31:17 <carter> Int64?
19:31:27 <carter> internally i need to Int everything for the primops
19:31:45 <carter> and i'm ok with it being slow on 32bit systems
19:31:55 * Axman6 is
19:32:07 <carter> ?
19:32:12 <johnw> I wonder why there is no Int256 or Int512
19:32:16 <Axman6> but not really, I'd like ARM to be fast too
19:32:20 <johnw> aren't those native integer types on GPUs?
19:32:26 <carter> johnw: nope
19:32:29 <carter> theres Vectors
19:32:30 <Axman6> not that I know of
19:32:35 <carter> of those sizes
19:32:35 <carter> in SIMD
19:32:35 <johnw> ah
19:32:37 <carter> on CPU and GPU
19:32:45 <carter> but those aren't "extended ints"
19:32:51 <Axman6> 128bit integers are native on x86 I think...
19:32:57 <carter> Axman6: link?
19:33:01 <carter> thats news to me
19:33:08 <carter> you encode it with simd
19:33:12 <enthropy> > cycle "long "
19:33:13 <lambdabot>  "long long long long long long long long long long long long long long long ...
19:33:19 <carter> enthropy: :P
19:33:20 <Axman6> I could be wrong, but I thought SSE supported 128 bit ints
19:33:21 <johnw> "really long int;"
19:33:24 <carter> > cycle "lol"
19:33:25 <lambdabot>  "lollollollollollollollollollollollollollollollollollollollollollollollollol...
19:33:27 <Axman6> maybe I made that up
19:33:40 <carter> sse2 has 128bit simd
19:34:07 <carter> you can "encode" those larger "Ints" with simd
19:34:16 <carter> but they're not quite first class / builtin
19:34:32 <carter> you'd have to do lots of shuffles too i think
19:34:45 <ij> I was playing around with number averaging and after writing one that counts with Integer I tried to write an algorithm that'd chunk up and do a divide and conquer of sorts, but it fails miserably. Any ideas why? http://sprunge.us/JWdW
19:35:18 <carter> ij: explain those codes
19:35:29 <carter> why divide and conquer
19:35:31 <carter> hows it fail
19:35:32 <carter> what
19:35:39 <ij> second
19:35:55 <carter> whats it trying to do
19:36:16 <ij> It tries to calculate the brightness of my screenshot or any png, really, by averaging pixels.
19:37:03 <ij> I give output the method to average with, which should(but in this case, does not) provide consistent results given the same input.
19:37:32 <carter>  ij  is the Integer one too slow?
19:38:08 <ij> Currently they're both two seconds, without utilizing the other core.
19:38:14 <carter> ok
19:38:19 <carter> tahts too slow
19:38:27 <Hafydd> ij: isn't (`div` 2) wrong?
19:38:33 <carter> ij: you're not allowed to use list
19:38:37 <carter> just do a fold
19:38:52 <carter> *vector fold
19:38:58 <carter> do a big it sum / fold
19:39:04 <carter> then divide at the end by the size of the vector
19:39:09 <ij> Hafydd, well, it'd only cut off some of the value, it should be just a little bit incorrect.
19:39:09 <carter> *Integer
19:39:30 <carter> i'm off
19:39:31 <carter> night all
19:39:34 <ij> nn
19:39:59 <ij> Hafydd, Why do you think it's incorrect?
19:41:57 <Hafydd> ij: because you're taking the average of a list of possibly more than 2 values by dividing their sum by 2. For example, it would give an average of 20 for [10,10,10,10], wouldn't it?
19:42:36 <ij> Completely correct, brainfarted there.
19:49:17 <saulzar> Hey guys -  is it just me or is cabal sandbox    ignoring the --sandbox=  argument? I'm trying to point it at another directory but it keeps looking for the one in the current directory
19:50:53 <no-n> what's a simple/good example use-case of fix?
19:51:21 <Iceland_jack> no-n: Factorial, as always :)
19:51:48 <Iceland_jack> > fix (\f n -> if n == 0 then 1 else n * f (n-1)) 6
19:51:49 <lambdabot>  720
19:52:05 <Iceland_jack> > fix (1:) -- or stupid stuff
19:52:06 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
19:52:09 <Iceland_jack> > fix error
19:52:10 <lambdabot>  "*Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *Ex...
19:52:36 <no-n> ahh
19:52:53 <Iceland_jack> It's not really used in real code
19:53:05 <Iceland_jack> @src fix
19:53:06 <lambdabot> fix f = let x = f x in x
19:53:13 <Iceland_jack> You can just as easily use Haskell's built in recursion
19:53:20 <no-n> ye
19:53:22 <saulzar> I dunno, it's one of those things which sometimes makes things tidier
19:53:30 <saulzar> I use it occasionally
19:53:44 <Iceland_jack> saulzar: Yes, once or twice but those are rare occasions
19:53:48 <enthropy> @src forever
19:53:49 <lambdabot> Source not found. The more you drive -- the dumber you get.
19:54:07 <Iceland_jack>     forever a = a >> forever a
19:56:07 <enthropy> or it could be   forever a = fix (a >>)
19:56:43 <saulzar> Nice example :)
19:56:47 <enthropy> which might be a little different in ways that might not matter
19:57:12 * hackagebot dependent-sum 0.2.0.2 - Dependent sum type  http://hackage.haskell.org/package/dependent-sum-0.2.0.2 (JamesCook)
19:57:14 * hackagebot dependent-map 0.1.1.2 - Dependent finite maps (partial dependent products)  http://hackage.haskell.org/package/dependent-map-0.1.1.2 (JamesCook)
20:04:12 <Nyyx> how do you recurse to a lambda
20:04:44 <pavonia> :t fix
20:04:45 <lambdabot> (a -> a) -> a
20:04:53 <jamieklassen> y combinator
20:11:22 <Nyyx> oh what a coincidence, you guys were talking about fix before I came up with my question
20:22:14 * hackagebot vado 0.0.1 - Runs commands on remote machines using ssh  http://hackage.haskell.org/package/vado-0.0.1 (HamishMackenzie)
20:24:15 <Fuuzetsu> hamishmack: does that package just run ‘ssh whateverhost 'yourcommand'’?
20:24:58 <hamishmack> yes
20:25:22 <hamishmack> and it chooses the "whateverhost" based on the current directory
20:25:44 <hamishmack> so you can use sshfs to mount a remote dir
20:25:56 <hamishmack> then use vado to run commands in it
20:26:05 <hamishmack> but on the remote server
20:26:58 <luite_> and it also runs the command in the correct dir on the remote server
20:27:12 <luite_> so something like ghcjs -o x x.hs just works
20:27:14 <luite_> err
20:27:16 <luite_> vado that
20:27:19 <luite_> :)
20:28:57 <Fuuzetsu> That's nice, I think I can find a use for it
20:34:45 <n4l> Hi everyone.. noob here. im going through LYAH and ghci isn't accepting "let removeNonUppercase :: [Char] -> [Char]"
20:35:05 <n4l> I get "The type signature for `removeNonUppercase' lacks an accompanying binding"
20:35:25 <n4l> am i just missing something here?
20:35:27 <levi> n41: You'll need to put ghci in multi-line mode
20:35:34 <scshunt> or use braces
20:35:59 <levi> It won't accept the type signature without getting a binding that goes with it at the same time.
20:36:19 <n4l> hence why i need multi-line mode?
20:37:40 <levi> Right; what you typed here was just a type declaration, but it's not acceptable to ghci unless it gets a binding at the same time.  You can either use the braces-and-semicolons syntax for it or use a multi-line ghci command.
20:38:28 <levi> You do that with :{ to start it and :} to end it.
20:38:55 <pavonia> n4l: You could also do "let removeNonUppercase = (... implementation goes here ...) :: [Char] -> [Char]"
20:40:18 <n4l> cool, and do I need "let" if its in :{ :} ?
20:40:28 <levi> Well, that works too, but at some point you'll want to be able to enter things in ghci on separate lines, so now is a good time to discover it. :)
20:40:43 <n4l> also stackoverflow gave me :set +m
20:40:57 <n4l> do i need let after that?
20:41:47 <geekosaur> you still need it, yes
20:41:58 <pavonia> What is +m?
20:42:27 <geekosaur> http://www.haskell.org/ghc/docs/latest/html/users_guide/interactive-evaluation.html#ghci-multiline
20:43:09 <geekosaur> "let" is still needed to tell ghc you are creating a binding instead of evaluating an expression
20:43:14 <geekosaur> *ghci
20:43:47 <levi> When you are writing at the ghci prompt, it's kind of like you're filling in a 'do' block in your main function.
20:46:01 <n4l> thanks everyone!
20:46:17 <n4l> geekosaur: thanks for the link :)
20:52:26 <iduhetonas> carter: You here?
20:58:15 <jle`> is Data.Typeable.Typeable(typeOf) no longer exported in 7.8 ?
20:59:16 <jle`> if not, what is the alternative?  i'm trying to use a library that is not building in 7.8 because of that error
20:59:23 <jle`> i am willing to download it and tweak some things
21:04:44 <enthropy> jle`: you should be able to derive typeable instances for everything now
21:05:48 <pavonia> jle`: see also https://ghc.haskell.org/trac/ghc/wiki/GhcKinds/PolyTypeable
21:11:41 <gamegoblin> How would I serve files (such as images) from a haskell http server?
21:12:16 <jle`> gamegoblin: the same way you serve normal web pages?
21:12:21 <jle`> are you using a framework?
21:12:38 <jle`> only thing is you should probalby specify a mime type
21:12:41 <gamegoblin> no framework
21:12:44 <jle`> in the headers
21:12:46 <jle`> ah
21:12:50 <gamegoblin> just doing it raw
21:12:55 <gamegoblin> learning experience
21:13:06 <jle`> are you using a library? HTTP?
21:13:10 <gamegoblin> Nope
21:13:16 <jle`> oh wait HTTP is client side
21:13:24 <jle`> how are you receiving connections?
21:13:39 <gamegoblin> Network.Socket
21:13:48 <gamegoblin> actually just Network
21:13:56 <jle`> have you conquered serving static web pages?
21:13:57 <johnw> gamegoblin: I use a WAI static middleware
21:13:58 <jle`> or any web pages
21:14:03 <gamegoblin> Yes
21:14:11 <johnw> or, front your Haskell server with nginx
21:14:27 <gamegoblin> I'm looking to do it all myself
21:14:30 <gamegoblin> trying to learn
21:14:49 <gamegoblin> I can serve HTML and whatnot just fine
21:14:59 <jle`> how do you serve webpages? with ByteString? or Text/String?
21:15:04 <gamegoblin> ByteString
21:15:24 <jle`> i'd imagine you can just serve the raw binary of the image file, and make sure to have sensible MIME types in your headers
21:15:34 <jle`> as a ByteString
21:15:37 <gamegoblin> I'll try it
21:16:01 <jle`> load the file with normalIO file stuff
21:16:09 <jle`> this...might not be the best way, i've never done this manually myself
21:17:20 <johnw> gamegoblin: what web framework are you using?
21:17:22 <jle`> for doming something this low-level i would recommend using conduit or pipes
21:17:27 <gamegoblin> johnw: none
21:17:27 <jle`> johnw: he's trying to do it from scratch
21:17:29 <jle`> with only Network
21:17:32 <johnw> oh, ouch
21:17:52 * jle` realizes that he can probably let people answer their own questions :)
21:18:20 <gamegoblin> So far I have a server that can accept and parse requests, send error codes if needed, serve pages
21:18:22 <gamegoblin> working on to media now
21:18:40 <johnw> network-conduit will let you do stuff like: sourceFile "foo.png" $$ sinkSocket mysocket
21:18:51 <gamegoblin> mmmm that's no fun though
21:18:53 <jle`> afaik HTTP is file format-agnostic
21:18:54 <gamegoblin> I want to learn how to really do it
21:19:15 <johnw> that's how we really do it in production
21:19:19 <jle`> gamegoblin: conduit just handles stuff like reading from a file and processing it, it doesn't have to do with http exactly
21:19:22 <johnw> doing it manually just isn't worth all the bug vectors
21:19:34 <jle`> it'd be like re-implementing foldl
21:19:41 <jle`> but it's not my learning project :)
21:19:53 <gamegoblin> But learning how foldl works is still valuable
21:20:05 <johnw> he does have a point
21:20:06 <johnw> ok, carry on :)
21:20:08 <gamegoblin> and it's hard to reaaaally know how it works without doing it yourself
21:20:19 <jle`> true. or maybe not, because of rewrite rules :)
21:20:43 <gamegoblin> I'll hopefully have it serving here in a little bit. Will update.
21:20:53 <jle`> by that i mean that you might be able to consider foldl as an implementation-less abstraction
21:21:08 <jle`> actually there are no rewrite rules for foldl in base oops.
21:21:10 <jle`> for ghc
21:22:03 <jle`> gamegoblin: yup, just try serving it as a normal bytestring, browser should be able to infer the mime type from the url but it's good practice to explicitly specify it
21:22:59 <gamegoblin> Will try to serve the haskell logo, gimme a few
21:25:04 <streblo> what should i learn first, haskell or clojure?
21:25:11 <Nyyx> :t ⊥
21:25:12 <lambdabot> lexical error at character '\138'
21:25:24 <cdh473_> streblo: have you used lisps or MLs?
21:25:47 <streblo> cdh473_: ive used lisps, ive only read about MLs
21:26:20 <johnw> Nyyx: it would be forall a. a
21:27:11 <Nyyx> johnw: makes sense
21:27:24 <Nyyx> streblo: which one do you plan to use more
21:27:25 <jle`> streblo: is there any significant departure of clojure from other lisps?
21:27:37 <cdh473_> streblo: then you should be able to pick up haskell alright, but clojure even easier
21:27:57 <jle`> clojure is literally a lisp, iirc
21:28:05 <streblo> i guess im not really worried about how hard itll be/how long itll take to learn
21:28:08 <cdh473_> jle`: more datatypes, built-in STM, etc
21:28:15 <cdh473_> JVM, etc
21:28:20 <streblo> i'm just more interested in something that i can learn from
21:28:20 <jle`> ah i see
21:28:28 <roboguy_> jle`: I've been thinking some more about arrows
21:28:36 <streblo> i use a lot of scala at work, ive heard people say haskell is a nice learning parallel
21:28:40 <roboguy_> I wonder if something like this could replace Control.Arrow http://lpaste.net/100875
21:28:43 <jle`> you will probably learn more from Haskell, I feel
21:29:01 <Nyyx> streblo: you will learn more from haskell if you use scala at work
21:29:47 <streblo> do people tend to like the "learn you a haskell" book?
21:29:48 <Nyyx> clojure is dynamic and macro based
21:30:35 <Nyyx> streblo: I read it, it's good, but there is still a lot to learn after it
21:30:48 <streblo> is there a better comprehensive introduction?
21:31:23 <jle`> streblo: from what i know, lisps gain their expressive power and elegance from their high capacity for metaprogramming and self-AST-manipulation, and sometimes dynamicness.  Haskell is functional but its power and beauty comes from many other aspects that aren't found in lisp-like languages.
21:31:32 <jle`> streblo: what's wrong with lyah? :)
21:31:39 <jle`> roboguy_: impressive :)
21:32:09 <streblo> jle`:  nothing, just wondering what people recommend
21:32:31 <roboguy_> jle`: thanks! I haven't proven any laws yet but the types work out. this is an idea that's sort of been in the back of my mind for a little while
21:32:42 <jle`> roboguy_: i especially like the hlint warnings :P
21:32:55 <roboguy_> jle`: haha, yeah I just fixed that
21:32:57 <jle`> what is Strong?
21:33:22 <roboguy_> it's a "subclass" of Profunctor
21:33:24 <jle`> fmap f id
21:33:26 <jle`> wow
21:33:28 <jle`> how did i not see that
21:33:30 <jle`> haha
21:33:42 <jle`> i feel silly now
21:33:52 <roboguy_> haha, yeah I was thinking the same thing earlier. it took me too long to see that
21:34:09 <jle`> i was probably fixated on (<*>)
21:34:24 <johnw> fmap f id == f, right?
21:34:33 <jle`> johnw: id from Control.Category
21:34:40 <jle`> fmap f id == arr
21:34:45 <jle`> er
21:34:46 <johnw> ah
21:34:47 <jle`> arr f
21:35:03 <jle`> i asked the other day for an arr from Category and Applicative
21:35:06 <johnw> :t fmap f id
21:35:07 <lambdabot> (Show a, FromExpr b) => a -> b
21:35:10 <roboguy_> all I'm missing is ArrowLoop
21:35:13 <johnw> I think it's just f too
21:35:32 <jle`> johnw: it's f for the (->) Category
21:35:56 <jle`> :t fmap f Control.Category.id
21:35:57 <lambdabot> (Functor (cat a), Show a, Category cat, FromExpr b) => cat a b
21:36:18 <jle`> what a weird Show constraint
21:37:38 <roboguy_> :t flip fmap (Control.Category.id :: Kleisli Identity a a)
21:37:39 <lambdabot> Functor (Kleisli Identity a) => (a -> b) -> Kleisli Identity a b
21:38:19 <parc> suppose you have a typeclass for a function like eval :: Eval e => e a -> a (a datatype that can be evaluated to an a), is there a way to make a pair an Eval b if it has the type Eval e1, e2 => (e1 (a -> b), e2 a)? i.e. its first argument can be evaluated to a function a->b, and its second argument can be evaluated to an a
21:41:04 <hellwolf> How can I achieve this: data Packet s = STUArray s Int Int8  -- newPacket :: Int -> ST s (STUArray s Int Int8) newPacket :: Int -> ST s (Packet s) . where commented out code is meant for a short hand notion
21:41:05 <roboguy_> parc: it is possible to make a pair like that but I'm not sure I'm understanding the question correctly.
21:41:09 <roboguy_> the notation is a bit different though
21:41:18 <roboguy_> your constraint should be (Eval e1, Eval e2)
21:42:30 <parc> essentially i want an ast, so a pair reduces to a b if the first argument of the pair is also pair (which reduces to an a->b), and the second argument is a pair (which reduces to an a)
21:43:08 <jle`> roboguy_: every Functor has a free Strong instance?
21:43:38 <parc> and then the eval instance for a pair is simply eval (x,y) = eval x $ eval y
21:43:50 <roboguy_> jle`: it looks like every Profunctor does, but I'm no Profunctor expert
21:44:12 <jle`> from the docs http://hackage.haskell.org/package/profunctors-4.0.2/docs/Data-Profunctor.html
21:44:19 <roboguy_> hmm, that seems like it could be a useful property
21:44:24 <jle`> "Note: every Functor in Haskell is strong"
21:45:54 <gamegoblin> Here is the haskell logo served from a haskell server: http://192.241.249.206:5002/
21:46:24 <gamegoblin> Not on the real server, just a 10 line toy one
21:46:28 <gamegoblin> so expect it to break ;)
21:46:32 <parc> so the ideal is if i try to call eval on a tree that is improperly typed it requires that all its elements also be evals, so staticly verifying its welltyped should be possible
21:46:40 <roboguy_> jle`: I think that free instance is represented by UpStar
21:46:43 <gamegoblin> Was just seeing if I could do it. Time to implement the real version.
21:47:24 <jle`> gamegoblin: not loading, looks like it  might be a LAN/local address?
21:47:38 <jle`> but congrats :)
21:47:50 <gamegoblin> jle`: Keep trying
21:48:02 <gamegoblin> jle`: It's on a toy server so it is just acting goofy. Refresh a few times.
21:48:14 <roboguy_> gamegoblin: nice
21:48:24 <gamegoblin> It doesn't load for me 50% of the time
21:48:35 <gamegoblin> 10 line servers tend to do that ;D
21:48:37 <roboguy_> parc: hmm. what sort of function type are you looking for?
21:48:52 <roboguy_> parc: also, have you considered gadts?
21:49:44 <no-n> I did addTimerCallback 1000 (putStrLn "hi") and it did nothing at all :|
21:51:38 <parc> i was kind of looking at those. ideally i'd like any function to be usable i like this. i'm trying to describe a context free grammar that i can enumerate, of all functions that fit a desired type using a set of primitive functions (including various combinators like (.) and so forth), where the context free grammar yields abstract syntax trees
21:52:12 <roboguy_> no-n: did you initialize glut?
21:52:33 <no-n> no :<
21:52:37 <parc> so essentially any function that is part of the set of primitives and obeys the type constraint, plus any combination of functions that obey the type constraint, need to be able to fit into the ast
21:53:03 <roboguy_> parc: well, I mean it sounds like you want some kind of "reduction" function to do the transformation you're talking about. what type do you think it'd be?
21:53:16 <roboguy_> no-n: probably need to do that first
21:53:21 <no-n> hehe
21:54:24 <jle`> roboguy_: can you get first/second from only Functor/Applicative and Category?
21:54:37 <jle`> although i guess all Functorshave a Strong instance
21:54:49 <jle`> i'll look at the Strong instanace of Upstar
21:56:38 <parc> that's really the problem i guess. to have eval (a,b) = eval a $ eval b i thought something like eval :: Eval e1, Eval e2 => (e1 (a -> b), e2 a) -> b should work, at least for pairs
21:58:01 <parc> if i can essentially claim that an Eval e1, Eval e2 => (e1 (a -> b), e2 a) is also an Eval b, then i think it would work, since then the type just becomes eval :: Eval e => e a -> a
21:58:20 <roboguy_> jle`: hmm interesting question
21:59:57 <parc> but getting pairs from Eval e1, Eval e2 => (e1 (a -> b), e2 a) -> b to Eval e => e a -> a is where im stuck
22:00:10 <jle`> i'm not sure if it's easier to do it by definting (***) and (&&&) and deriving first and second from there
22:00:21 <jle`> or vice versa
22:02:55 <roboguy_> parc: I have a feeling that gadts would simplify things quite a bit
22:02:57 <parc> it feels almost like the (e1 (a->b), e2 a) is also a precondition essentially
22:05:47 <parc> i guess i'll look into them again then. thanks
22:05:51 <roboguy_> parc: eval (a,b) = eval a $ eval b doesn't do what you want?
22:08:52 <parc> well i haven't managed to declare (,) to be a member of the typeclass in the way i need, so that results in an infinite type
22:09:53 <roboguy_> type classes might not be the best approach here
22:11:11 <roboguy_> or, if they are, it's probably best to put the eval outside the type class
22:11:20 <roboguy_> parc: this might be useful too http://okmij.org/ftp/tagless-final/course/lecture.pdf
22:12:29 <parc> ooh, that looks interesting
22:43:45 <n4l> going through LYAH and read the sentence "The elem function has a type of (Eq a) => a -> [a] -> Bool because it uses == over a list to check whether some value we're looking for is in it."
22:44:28 <n4l> is there a tool maybe in ghci that alows for openin up elem and seeing its code?
22:44:43 <n4l> *opening
22:45:19 <pavonia> unfortunately no
22:45:29 <johnw> @src elem
22:45:30 <lambdabot> elem x    =  any (== x)
22:45:57 <johnw> you can always ask lambdabot in a /QUERY session
22:47:38 <jle`> n4l: if you are feeling adventurous you can look it up on hoogle and see the source in base
22:47:41 <jle`> in ghc
22:48:38 <jle`> also https://github.com/mokus0/lambdabot/blob/master/lambdabot/State/source and ctrl+f
22:48:45 <jle`> but those defintions are usually not the actual ones
22:48:51 <jle`> they're just what yo'll get from lambdabot
22:53:11 <Fuuzetsu> it'd be cooler if it tried to look the actual source up
22:59:11 <mgomezch> To what degree would it be possible to implement a language very similar to Haskell but where functions are not extensional?
22:59:30 <mgomezch> Does anything like that exist?
22:59:47 <n4l> jle`: im always feeling adventurous :)
23:01:12 <mgomezch> (I’m not even sure what I’m asking — it came to mind from the idea of opening up `elem` and seeing its code, but at runtime.  I suppose it would turn out to be simply some sort of lisp.)
23:01:17 <pordan30> do you mean that extensional equality can be proved, or that an extensional representation is available under certain circumstances?
23:02:21 <jle`> mgomezch: i feel like being able to see the source of a function at runtime might violate referential transparency
23:02:52 <jle`> i might be wrong
23:03:16 <mgomezch> hmm
23:03:20 <jle`> actually i'm probably wrong
23:03:25 <pordan30> in languages like coq and agda, either you or the compiler can prove extensional equality of functions: say that f x = g x for all x : A if f, g : A -> B.
23:03:39 <bitemyapp> jle`: runtime reflection against function source?
23:04:14 <jle`> bitemyapp: yeah. actually i'm most likely wrong im not sure whre that intuition came from
23:04:24 <jle`> but it'd be a side-effectless function
23:04:25 <mgomezch> pordan30: I was mostly thinking about the latter
23:04:32 <bitemyapp> jle`: at minimum, it seems inadvisable.
23:04:41 <jle`> bitemyapp: of course
23:06:07 <bitemyapp> jle`: well you'd be surprised what some Lispers get up to.
23:06:13 <jle`> hm
23:06:18 <jle`> the basic argument is that
23:06:23 <pordan30> perhaps you could define a relation =S such that f =S g if some normal form of the source of f and g are equal as strings modulo variable names? haha
23:06:41 <jle`> \x -> 2*x and \x -> x + x for x :: Int are supposed to be the same mathematical function
23:06:59 <jle`> and so if you get one as f and one as g, then swapping one for the other should be identical
23:07:05 <jle`> and not affect your program
23:07:30 <jle`> but if you had a function :: (Int -> Int) -> String or :: (Int -> Int) -> AbstractSyntaxTree
23:07:34 <jle`> f and g could not be swapped
23:07:44 <jle`> because they would change the program, despite being the same mathematical function
23:08:17 <mgomezch> f ≠ id f
23:08:20 <jle`> i don't know if i am convinced by that because i don't know what definition of referential transparency this is using
23:08:39 <mgomezch> For some relevant definition of ≠ :)
23:08:59 <jle`> mgomezch: that's probably a better example :)
23:09:24 <jle`> if g = id f you should be able to swap out g for id f
23:09:27 <jle`> @src id
23:09:27 <lambdabot> id x = x
23:09:31 <jle`> and swap out id f for f
23:09:33 <mgomezch> At the very least, it’d be cute as a teaching tool, hence I wonder.  Granted, there’s a lot to be said for tracing evaluation and the like.
23:09:47 <pordan30> most dependently typed languages have intensional equality, something like eq : A -> A -> Prop
23:10:13 <jle`> so if g and id f, then g has to be indistinguishable from f in every way --- because if you expand out g you get id f and if you expand out id f you get f
23:10:19 <jle`> but if you had such a reflection function
23:10:25 <jle`> g and f would show up as different things
23:10:31 <jle`> so we violate referential transparency
23:10:33 <jle`> ah.
23:10:57 <jle`> but it's not like ghc doesn't have backdoors that let you violate referential transparency
23:11:05 <jle`> cough seq
23:11:35 <pordan30> unless you have the ability to apply rewrites and reductions, so that id f = f and then f = g
23:12:19 <mgomezch> Well, it wouldn’t be too useful without reductions ;)
23:12:24 <jle`> pordan30: such a proposed reflection function would be more useful showing g as id f
23:14:03 <Fuuzetsu> pordan30: hm? You can't prove extensionality in Agda, it's usually postulated
23:14:20 <jle`> actually i don't think seq breaks ref transp. hm. sorry.
23:16:41 <pordan30> oh, for some reason i thought that agda had extensional equality (following some new release); my bad
23:17:16 <Fuuzetsu> Oh, maybe it does in a new release, I haven't been following git changes but I haven't heard anything. I doubt it.
23:18:55 <pordan30> you probably know more than me, so i'll take your word on it
23:22:00 <pordan30> oh, i guess extensionality is an axiom in coq also; i should shut up :/
23:35:19 <gamegoblin> So I have an array of IO actions that I'd like to run in parallel with forkIO
23:35:26 <gamegoblin> but I only want say, 1000 to be running at any given time
23:35:31 <gamegoblin> how do?
23:35:47 <gamegoblin> thread pooling - ish I guess
23:36:02 <bitemyapp> gamegoblin: thread pooling
23:36:14 <bitemyapp> gamegoblin: or trust Haskell's forkIO thread pool
23:36:22 <bitemyapp> you know, either way.
23:36:33 <johnw> gamegoblin: use the parallel-io library
23:36:49 <johnw> you'd do this: withPool 1000 $ parallel $ map (someIOAction) xs
23:37:04 <fly2web> haskell tutorial can read only one day?
23:38:37 <pordan30> maybe "A Gentle Introduction to Haskell" for a single-day read: http://www.haskell.org/tutorial/
23:39:33 <johnw> you could read LYAH in one day
23:39:40 <johnw> I don't know how much you'd absorb that way, though
23:39:45 <bitemyapp> johnw: LYAH is so yawn.
23:39:53 <johnw> I really enjoyed it
23:40:06 <bitemyapp> I know people often like it, but I found it ponderous.
23:40:07 <johnw> in fact, sometimes I wish I knew less Haskell so I could read it again :)
23:40:18 <bitemyapp> wow. That's a glowing endorsement.
23:40:24 <bitemyapp> can't say I'd make that trade.
23:40:31 <johnw>  I have very fond memories of my days spent reading it
23:40:40 <johnw> it gave Haskell a certain feel
23:40:58 <johnw> in contrast to some of the blog articles I couldn't make either heads or tails of
23:41:39 <kadoban> i don't think i had much progress in haskell before i switched back and forth between real world haskell and lyah a few times
23:42:05 <johnw> i could get into a lot of RWH's "real world" examples, because they were so distant from what my real world consists of
23:42:08 <johnw> couldn't*
23:42:38 <bitemyapp> johnw: I didn't care for RWH that much as a "tutorial to Haskell" but there are some truly choice chapters in it.
23:42:56 <bitemyapp> you should pick over it again if you haven't, it's got some great stuff.
23:42:57 <johnw> I agree with that
23:43:07 <shergill> what's the empty/vacuous type in haskell?
23:43:09 <johnw> I used it to refine my understanding of something just recently...
23:43:12 <johnw> Void
23:43:39 <kadoban> johnw: i don't think monads really clicked at all for me until reading it though, that was my major gain from it. it seemed to motivate them well, and it skipped trying to explain using 10 dumb analogies about toxic waste and factories and such, which was nice
23:44:19 <shergill> right, ok so nothing in prelude right? i must have been misremembering
23:44:28 <johnw> correct
23:44:37 <johnw> nothing even in base
23:44:46 <bitemyapp> kadoban: I hate those analogies.
23:44:56 <n4l> is there a diference between data types and function types or are they the same thing? (maybe the wrong question.)
23:44:58 <kadoban> bitemyapp: me too. they really don't explain anything
23:45:10 <johnw> concrete types are all of the same kind
23:45:33 <bitemyapp> There's just * and # innit?
23:46:01 <kadoban> n4l: function types include a -> i guess?
23:46:18 <n4l> what is their kind?
23:47:01 <johnw> the kind of all concrete types is *
23:47:10 <n4l> sorry i know i could probably look this up but I don't know all the resources yet.
23:47:29 <n4l> johnw: thanks
23:47:46 <Saizan> n4l: i think we need some context to answer your question properly, e.g. data type could sometime refer only to those types you define through constructors
23:48:22 <Saizan> i.e. using the data or newtype keyword
23:51:26 <n4l> Saizan: maybe what i ment was is there a difference between type (eg. :t 'a') and typeclass (eg :t product) .... (im reading lyah)
23:51:39 <jle`> product?
23:51:52 <n4l> or just some function
23:52:34 <jle`> well
23:52:38 <jle`> a function has type  a -> b
23:52:43 <jle`> but is itself data
23:52:53 <Saizan> well, in both those cases you are just asking the type of a value, and they happen to differ
23:58:22 <gamegoblin> checkMany is of type [String] -> IO () . When I do mapM_ checkMany xs everything works as expected. When I do mapM_ (forkIO . checkMany) xs, the program seems to end without doing anything
23:58:29 <gamegoblin> some sort of lazy stuff happening that I don't know about or..?
23:58:54 <hamid> :t forkIO
23:58:55 <lambdabot> Not in scope: `forkIO'
23:59:27 <hamid> gamegoblin, forkIO :: IO () -> IO ThreadId
