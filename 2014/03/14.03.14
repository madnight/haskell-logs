00:41:43 <eatman> Morning!
00:42:18 <shiona> morning
00:43:36 <haasn> Who is the current maintainer of lambdabot?
00:45:28 <pavonia> According to hackage James Cook
01:30:30 <osa1> http://www.haskell.org/cabal/users-guide/ what happened to specification page?
02:08:52 * hackagebot egison-tutorial 3.3.2 - A tutorial program for the programming language Egison  http://hackage.haskell.org/package/egison-tutorial-3.3.2 (SatoshiEgi)
02:26:34 <osa1> I had a cabal file for an executable and I had "alex, cabal" in build-tools field. It was working fine without me having to manually generate hs file from .x and .y files. I wanted to have one Main.hs file for executable and move other modules to a library(parser and lexer included). I added "library" part in cabal file and moved "build-tools" field to there
02:26:34 <osa1> but now I have to manually call alex and cabal to generate hs files. why is that?
02:27:26 <ffwacom> YOU MENA HASKELL?!
02:27:49 <dcoutts_> osa1: are the lexer/parser modules listed in the library? (exposed/other-modules)
02:27:59 <merijn> osa1: Well, does your executable have a build-depend on the library you added?
02:29:03 <dcoutts_> osa1: oh, yes right, if the problem is with building the exe then likely you're not listing all the modules for the exe, ie lexer+parser modules
02:29:36 <dcoutts_> osa1: if your exe does not depend on the lib then it has to pre-process & compile the modules directly, so they need to be listed for the exe
02:30:28 <Iceland_jack> This is the second time ffwacom joins and says: <ffwacom> YOU MENA HASKELL?!
02:30:30 <Iceland_jack> and leaves
02:31:09 <dcoutts_> osa1: in principle all components have to list all their modules (exposed/other). In practice for exes you can often get away without, but one of the cases where you can't get away without listing them is when they need pre-processing, like alex/happy.
02:32:54 <merijn> How do I check whether ghc is 64 or 32 bit?
02:33:52 <guymann> merijn, you could probably use `file` on the ghc binary
02:35:55 <osa1> dcoutts_: hmm yeah listing that in exposed worked.
02:35:57 <osa1> thanks
02:37:06 <osa1> I'm not getting this weird error though: http://lpaste.net/101182 (gotta go for 2 mins)
02:38:56 * hackagebot containers 0.5.5.1 - Assorted concrete container types  http://hackage.haskell.org/package/containers-0.5.5.1 (JohanTibell)
02:38:56 <dcoutts_> osa1: I'd guess your exe is importing some modules from the lib and some direct
02:41:30 <Fuuzetsu> uninstall your global package
02:41:45 <osa1> Fuuzetsu: I don't have any global package
02:41:49 <osa1> I'm using cabal sandbox
02:42:17 <osa1> I tried cleaning up everything (cabal clean && cabal sandbox delete) but didn't work
02:42:38 <Fuuzetsu> osa1: having a sandbox doesn't hide any packages that are installed outside of it
02:43:00 <merijn> I have an odd FFI problem
02:43:04 <osa1> Fuuzetsu: ghc-pkg list doesn't show my package as installed
02:43:06 <merijn> "Unacceptable result type in foreign declaration: IO Foreign.C.Types.CInt"
02:43:13 <Fuuzetsu> osa1: I see. Just making sure.
02:43:24 <merijn> Why the hell would "IO CInt" be an unacceptable result type?
02:43:34 <Fuuzetsu> you could try without the sandbox to confirm whether that's the problem or not
02:43:51 <osa1> btw, I'm using cabal 1.19.2, could it be related with that? (with GHC 7.8 RC2)
02:44:15 <dcoutts_> Fuuzetsu: it's from within the same package
02:44:59 <Fuuzetsu> Well, I think you'd know best here ;)
02:45:02 <bxc> if i'm writing a module to parse PHP serialisation format, what should I call it?
02:45:13 <Fuuzetsu> dcoutts_: by the way, it'd be great if you could leave a quick comment on https://github.com/haskell/cabal/issues/1721
02:45:29 <Fuuzetsu> bxc: php-serialisation-format
02:45:46 <Fuuzetsu> or psf if you're lazy
02:46:07 <osa1> my cabal file: http://lpaste.net/101183
02:46:12 <dcoutts_> osa1: my guess is you've got the exe depending on the lib, but some source modules are still being used directly. We could see from the .cabal file
02:47:19 <dcoutts_> osa1: win for psychic debugging :-)
02:48:05 <dcoutts_> osa1: so the problem is you're picking up all the modules directly in your exe, not using the lib, because you're sharing the same src dir
02:49:28 <dcoutts_> osa1: that's the root issue. As for the type error, not important but it happens because you're not picking up *every* module directly, because of the pre-processing, and hence the type error.
02:49:49 <osa1> ahh
02:50:01 <dcoutts_> osa1: you'll have the same issue with the testsuite
02:50:05 <osa1> yeah
02:50:12 <osa1> that makes sense. thanks dcoutts_
02:50:34 <dcoutts_> osa1: normally it'd actually work, but just not do what you want, as it'd pick up every module as a src module, and not use the lib at all
02:51:23 <dcoutts_> osa1: but here it picks up all the src modules except the .x & .y ones, as you've not listed them so no pre-processing, so it doesn't generate and pick up the .hs src
02:53:01 <osa1> yup, thanks.
02:53:05 <osa1> I gotta go now.
03:02:58 <merijn> dcoutts_: The best/only way to list multiple emails in a cabal file is to just add multiple address to the author field?
03:09:00 * hackagebot convertible 1.1.0.0 - Typeclasses and instances for converting between types  http://hackage.haskell.org/package/convertible-1.1.0.0 (NicolasWu)
03:09:02 * hackagebot HDBC 2.4.0.0 - Haskell Database Connectivity  http://hackage.haskell.org/package/HDBC-2.4.0.0 (NicolasWu)
03:18:12 <merijn> oooooh
03:18:22 <merijn> You can use quasiquoters in pattern matches?
03:18:26 <merijn> That's neat
03:21:43 <tdammers> wait what?
03:22:06 <tdammers> oh yeah, makes sense, given suitable output from the quasiquoter
03:33:00 <zhasha> I have a Yesod subsite and I'd like for the master to be able to give it some CSS as a parameter, but I can't see a way of making 'css :: render -> Css' in the subsite data fly. I'm not really sure how to do this
03:37:55 <merijn> @pl \fs -> mapM_ (\x -> mapM_ ($x) fs)
03:37:55 <lambdabot> mapM_ . flip (mapM_ . flip id)
03:39:03 * hackagebot dsp 0.2.3 - Haskell Digital Signal Processing  http://hackage.haskell.org/package/dsp-0.2.3 (HenningThielemann)
03:39:05 * hackagebot Interpolation-maxs 0.3.0 - Multiline strings, interpolation and templating.  http://hackage.haskell.org/package/Interpolation-maxs-0.3.0 (MaxwellSwadling)
03:44:04 * hackagebot sample-frame 0.0.3 - Handling of samples in an (audio) signal  http://hackage.haskell.org/package/sample-frame-0.0.3 (HenningThielemann)
03:44:06 * hackagebot sample-frame-np 0.0.4 - Orphan instances for types from sample-frame and numericprelude  http://hackage.haskell.org/package/sample-frame-np-0.0.4 (HenningThielemann)
03:44:22 <anon_555> Bangs xs = [ if x < 10 then "BOOM!" else "BANG" | x <- xs, odd x]
03:44:29 <anon_555> What is wrong in this
03:44:49 <anon_555> i get message parse error in input `=`
03:45:11 <no-n> say let first
03:45:55 <no-n> oh, and it won't work with the capital
03:46:11 <no-n> np
03:47:58 <anon_555> :)
03:48:17 <anon_555> so when we write in script file then we do not need to write let and when we use ghci we should write let
03:48:17 <anon_555> so guys suppose i write :l first.hs
03:48:34 <anon_555> it will show Main in place to prelude how can i get prelude back
03:49:05 * hackagebot midi 0.2.1.1 - Handling of MIDI messages and files  http://hackage.haskell.org/package/midi-0.2.1.1 (HenningThielemann)
03:49:26 <fizruk> anon_555: you have both Prelude and Main there
03:50:06 <fizruk> anon_555: also you can set any prompt with :set prompt "prompt> "
03:50:21 <peteretep> only it must be lambda
03:50:50 <fizruk> peteretep: i use "ghci> "
03:51:02 <peteretep> it's definitely required to be a lambda symbol
03:51:57 <fizruk> i don't like the look of "λ> " or "λ$ ", do you suggest just "λ " ?
03:52:21 <supki> I use ">>> " because it's easier to copypaste doctests that way
03:52:39 <peteretep> Prelude λ=
03:52:42 <peteretep> for great justice
03:52:58 <fizruk> supki: that's nice!
03:55:13 <bahamas> supki: just like the python prompt :)
03:56:07 <merijn> fizruk: I use just "λ " as prompt, yeah
03:56:58 <anon_555> great guys
03:57:06 <bahamas> why doesn't LYAH mention anything about encodings when talking about bytestrings?
03:58:18 <anon_555> can i set the prompt default so that next time i open ghci the promot remains lambda
03:58:31 <fizruk> anon_555: sure, in ~/.ghci
03:58:46 <merijn> bahamas: Because there's nothing different from other programmig languages, most likely
03:59:06 * hackagebot jack 0.7.0.1 - Bindings for the JACK Audio Connection Kit  http://hackage.haskell.org/package/jack-0.7.0.1 (HenningThielemann)
04:00:01 <bahamas> merijn: well, I expected it to mention how you encode or decode a bytestring, for example
04:00:45 <bahamas> or what the default encoding is
04:00:57 <merijn> bahamas: ByteString doesn't have an encoding
04:01:18 <merijn> bahamas: ByteString is an unfortunate name that is kept for historical reasons, they're just bytes
04:01:30 <merijn> bahamas: There is nothing string or unicode like about ByteString
04:01:53 <merijn> bahamas: If you are dealing with unicode text, use Text (Text.Encoding has ByteString -> Text functions)
04:02:29 <sudeep12> hey
04:02:45 <merijn> bahamas: ByteString is like C's uint8_t[] or python's bytes
04:04:18 <merijn> bahamas: In short: ByteString if it's binary (binary files, network traffic, etc), Text if it's unicode text and String if it's small constants or you hate performance :p
04:08:09 <bahamas> merijn: are you referring to python 3's bytes?
04:09:07 * hackagebot jack 0.7.0.2 - Bindings for the JACK Audio Connection Kit  http://hackage.haskell.org/package/jack-0.7.0.2 (HenningThielemann)
04:09:09 * hackagebot data-accessor 0.2.2.4 - Utilities for accessing and manipulating fields of records  http://hackage.haskell.org/package/data-accessor-0.2.2.4 (HenningThielemann)
04:09:10 <bahamas> python's bytes have an encoding. it's just that it's ascii by default
04:09:22 <bahamas> in python 2, I mean
04:10:07 <merijn> bahamas: Yeah, python 3's
04:14:08 * hackagebot data-accessor 0.2.2.5 - Utilities for accessing and manipulating fields of records  http://hackage.haskell.org/package/data-accessor-0.2.2.5 (HenningThielemann)
04:15:02 <quicksilver> if I remember correctly, LYAH predates "Text"
04:15:26 <quicksilver> and bytestring was widely used in those days as a fast string type with poor encoding safety
04:17:58 <bahamas> so it looks like System.IO uses the system encoding
04:19:08 * hackagebot data-accessor-template 0.2.1.11 - Utilities for accessing and manipulating fields of records  http://hackage.haskell.org/package/data-accessor-template-0.2.1.11 (HenningThielemann)
04:21:24 <bahamas> I hope that the web frameworks decode everything to unicode
04:22:26 <dcoutts> bahamas: no, it uses whatever encoding you set
04:22:34 <dcoutts> bahamas: it just defaults to the locale encoding
04:22:38 <dcoutts> if you don't specify
04:22:46 <dcoutts> hSetEncoding hnd utf8
04:24:09 * hackagebot alsa-seq 0.6.0.3 - Binding to the ALSA Library API (MIDI sequencer).  http://hackage.haskell.org/package/alsa-seq-0.6.0.3 (HenningThielemann)
04:24:31 <bahamas> dcoutts: I mean by default it uses the system encoding
04:24:57 <anon_555> hi
04:25:20 <anon_555> hey guys can you show me some of the web app you have created suing haskell
04:25:26 <anon_555> ** using
04:27:01 <iross> anon_555: You could take a look at www.bayeshive.com
04:27:34 <iross> anon_555: That uses Yesod for the server side and some AngularJS stuff on the client side.
04:27:45 <iross> anon_555: If you like.
04:28:21 <user_2> I don't get that: "What's with the [(),(),(),(),()] at the end?" @ http://learnyouahaskell.com/input-and-output
04:29:05 <Axman6> without l;ooking at the code, I'd guess there's a use of mapM?
04:29:09 * hackagebot alsa-pcm 0.6.0.1 - Binding to the ALSA Library API (PCM audio).  http://hackage.haskell.org/package/alsa-pcm-0.6.0.1 (HenningThielemann)
04:29:39 <bahamas> yup
04:29:41 <Axman6> ah, well sort of.
04:29:54 <Axman6> user_2: the type of mapM:
04:29:57 <Axman6> :t mapM
04:29:58 <lambdabot> Monad m => (a -> m b) -> [a] -> m [b]
04:30:51 <Axman6> for each element of the list, run the function in the monad m and return a list of the results of each time the function was run. since print returns (), then we get a list of ()'s
04:37:44 <user_2> I am a bit confused... is 'm' a type parameter? or a function?
04:38:15 <user_2> don't know how to understand a -> m b
04:38:18 <mniip> user_2, in 'm' is a character, you've got to clarify
04:38:25 <mniip> oh, m is a type constructor
04:38:42 <mniip> b is a type variable. Applying b to m produces a type
04:38:50 <Axman6> m mighyt be [], or Maybe, or IO
04:38:53 <user_2> type constructor that work both on b and on [b]?!
04:39:06 <Axman6> :k []
04:39:07 <lambdabot> * -> *
04:39:17 <mniip> user_2, huh
04:39:26 <Iceland_jack> You can do both
04:39:26 <Iceland_jack>     Maybe b
04:39:26 <Iceland_jack>     Maybe [b]
04:39:32 <Axman6> [] is a type constructor, [a] is syntactic sugar for [] a
04:39:43 <mniip> yeah, you can nest type constructors
04:41:29 <user_2> so it could be (int -> maybe int) -> [int] -> maybe [int]
04:41:48 <Axman6> yep
04:41:51 <bahamas> user_2: re-read about type constructors. they are mentioned here http://learnyouahaskell.com/making-our-own-types-and-typeclasses#type-parameters
04:41:54 <Axman6> though, Maybe and Int
04:41:55 <mniip> (Int -> Maybe Int) -> [Int] -> Maybe [Int] actually
04:43:08 <user_2> bahamas, thanks, I read that already. I am still trying to make sense of it. I am not used to such kind of types.
04:43:46 <user_2> :t print
04:43:47 <lambdabot> Show a => a -> IO ()
04:43:57 <mniip> user_2, well look, (Maybe a), you can put anything in place of a, it can be an Int or a ()
04:44:17 <Axman6> :t mapM
04:44:18 <lambdabot> Monad m => (a -> m b) -> [a] -> m [b]
04:44:20 <mniip> (m Int), you can put any type constructor in place of m, be it Maybe or ((->)String)
04:44:20 <Axman6> :t mapM print
04:44:21 <lambdabot> Show a => [a] -> IO [()]
04:44:24 <Axman6> :t mapM print []
04:44:25 <lambdabot> IO [()]
04:45:21 <sudeep12> anon_555: hi
04:45:36 <bahamas> user_2: you can start like this data Bool = False | True. what is on the right of "=" are value constructors. what is on the left are types
04:45:45 <anon_555> user_2: hi
04:45:46 <user_2> :t mapM_ print
04:45:46 <lambdabot> Show a => [a] -> IO ()
04:45:58 <bahamas> user_2: you see that Bool doesn't take any parameters, so it's a concrete type
04:46:17 <Axman6> user_2: mapM_ just runs the function on each element of the list, and ignores the results
04:46:27 <Axman6> :t mapM_
04:46:27 <lambdabot> Monad m => (a -> m b) -> [a] -> m ()
04:46:28 <bahamas> user_2: but in data Maybe a = Nothing | Just a, "Maybe" takes a parameter. that makes it a *type constructor*
04:46:54 <merijn> bahamas: Not everything that takes a parameter is a type constructor
04:47:03 <bahamas> user_2: "Maybe" takes a type and returns a concrete type
04:47:10 <merijn> bahamas: Consider "Either Int" that takes a type parameter, but it's not a type constructor
04:47:11 <bahamas> merijn: oh. what are exceptions?
04:47:27 <bahamas> merijn: what is it then?
04:47:36 <merijn> A partially applied type constructor?
04:47:48 <bahamas> ah, true
04:47:58 <merijn> bahamas: If you have "data Pair a = Pair a a", would you consider "Pair 1" a data constructor?
04:48:23 <bahamas> merijn: no
04:48:45 <bahamas> merijn: but I was referring to things that take a parameter in the definition
04:48:53 <bahamas> like data Maybe a above
04:49:22 <merijn> I prefer explanations using kinds, but those are not for everyone, I guess. And I'm too busy to clarify them to a beginner atm
04:49:37 <user_2> ahem... excuse me, ahem... is this Either types not just like a topple of pointers (a,b) ?
04:49:49 <Axman6> no
04:49:53 <Axman6> (and it's tuple)
04:49:58 <bahamas> merijn: well, kinds are explained in LYAH. the explanation made sense to me
04:49:59 <Axman6> @src Either
04:49:59 <lambdabot> Source not found. I feel much better now.
04:50:03 <Axman6> wut
04:50:08 <bahamas> heh
04:50:10 <merijn> user_2: Either is more like a union than a tuple
04:50:14 <Axman6> data Either a b = Left a | Right b
04:50:24 <merijn> @quote data.Neither
04:50:25 <lambdabot> Berengal says: data Neither a b = Left | Right
04:50:30 <user_2> (btw emacs spell check disliked the word tuple)
04:50:31 <merijn> My favourite haskell joke :)
04:50:47 <Iceland_jack> heh
04:50:58 <no-n> hahaha
04:52:42 <bahamas> now I see what the age of LYAH is. it links to ghc 6.10.1
04:53:26 <Axman6> most of the stuff in it will be up to date though, it covers the fundamentals of using haskell
04:53:47 <bahamas> yeah. I only found a deprecation warning so far
04:55:49 <bahamas> merijn: I'm curious what is incorrect or not usefull about the way I identify type constructors. namely, if in their definition they take a parameter, then they are type constructors
04:59:13 * hackagebot gnuplot 0.5.2.1 - 2D and 3D plots using gnuplot  http://hackage.haskell.org/package/gnuplot-0.5.2.1 (HenningThielemann)
04:59:35 <tom_> @pl (\ k v m -> p k v >> m)
04:59:35 <lambdabot> ((>>) .) . p
05:00:18 <merijn> bahamas: Well, is Bool a type constructor?
05:00:51 <thrakcattack> :t Bool
05:00:51 <lambdabot> Not in scope: data constructor `Bool'
05:00:54 <merijn> bahamas: If not, do you consider Nothing a data constructor?
05:00:54 <thrakcattack> :t True
05:00:55 <lambdabot> Bool
05:01:00 <JagaJaga> Hello! How to add to my cabalised project a folder with other .cabal file? I mean smth like add-sources in sandbox, but without using it
05:01:21 <Guest92670> @pl (\ m k v -> p k v >> m)
05:01:21 <lambdabot> flip (flip . ((>>) .) . p)
05:01:32 <Guest92670> @pl (\ m k v -> m >> p k v)
05:01:32 <lambdabot> (. p) . (.) . (>>)
05:01:34 <bahamas> merijn: I say that Bool is not a type constructor while Nothing is a value constructor. is this incorrect?
05:01:43 <Guest92670> @pl (\ k v m -> m >> p k v)
05:01:43 <lambdabot> (flip (>>) .) . p
05:03:15 <bahamas> I think the term is "nullary value constructor" for Nothing
05:04:14 * hackagebot sox 0.2.2.3 - Play, write, read, convert audio signals using Sox  http://hackage.haskell.org/package/sox-0.2.2.3 (HenningThielemann)
05:04:15 <merijn> bahamas: Well, I'm curious why you distinguish those two cases?
05:04:38 <merijn> Why would you consider nullary data constructors a constructor, but not nullary type constructors?
05:04:40 <bahamas> merijn: I don't understand the question
05:04:54 <bahamas> merijn: ah, I understand :)
05:05:50 <bahamas> merijn: so Bool is a nullary type constructor, which can be considered a concrete type. am I correct in saying this?
05:05:52 <merijn> I generally have the simplified model that (not counting literal values) that anything capitalised is a constructor (type or data) and anything lower case is a variable (type or data)
05:06:08 <bahamas> like Nothing is a Nothing is a nullary value constructor which is a concrete value
05:06:25 <bahamas> aha, that makes sense
05:06:38 <bahamas> s/is a Nothing//
05:06:47 <merijn> bahamas: I find the term "concrete type" a bit confusing, because it's unclear whether, for example, "Nothing :: Maybe a", is this a concrete type (since it has kind *) or inconcrete since 'a' is a variable?
05:07:31 <merijn> I prefer to just talk about "types of kind *", because it's unambiguous what that means :)
05:08:08 <no-n> :}
05:08:38 <bahamas> I see and I think I understand
05:09:06 <bahamas> but yeah, that requires people to understand kinds
05:09:14 * hackagebot non-empty 0.2 - List-like structures with static restrictions on the number of elements  http://hackage.haskell.org/package/non-empty-0.2 (HenningThielemann)
05:09:26 <merijn> Of course the entire notion of "type constructors" becomes a bit muddled in the presence of TypeFamilies, because now you can have capitalised types which are not type constructors, but when you reach that point, the rest should be easy already anyway :p
05:09:33 <bahamas> well, at least my explanation was a good crutch
05:11:32 <zhasha> How would I go about getting some lucius CSS into a data type?
05:11:51 <zhasha> It has the type 'render -> Css'
05:12:11 <merijn> Argh, who decided that "True" was a reasonable default for a debug flag >.>
05:12:12 <bahamas> why can you use a type variable in Nothing :: Maybe a? how do you read it? Nothing has type Maybe a?
05:12:18 <merijn> :t Nothing
05:12:19 <lambdabot> Maybe a
05:12:37 <merijn> bahamas: The why is more logical with an explicit forall
05:12:45 <merijn> "Nothing :: forall a. Maybe a"
05:12:58 <merijn> bahamas: i.e. Nothing can be "Maybe a" for any value of 'a'
05:13:16 <merijn> Hence, why you can do "Nothing :: Maybe Int" or "Nothing :: Maybe Char" and it all works
05:13:31 <merijn> > Nothing :: Maybe Int
05:13:32 <lambdabot>  Nothing
05:13:46 <merijn> > (Nothing :: Maybe Int) :: Maybe Char -- this doesn't
05:13:47 <lambdabot>  Couldn't match type `GHC.Types.Int' with `GHC.Types.Char'
05:13:47 <lambdabot>  Expected type: Data.Maybe.Maybe GHC.Types.Char
05:13:47 <lambdabot>    Actual type: Data.Maybe.Maybe GHC.Types.Int
05:17:44 <bahamas> ok, I think I get it :)
05:23:04 <Axman6> hmmm, STM should have two new functions, trying :: STM a -> STM (Maybe a) and succeding/didRun/try :: STM a -> STM Bool so it's easy to write wait free versions of any STM action
05:24:17 * hackagebot tf-random 0.4 - High-quality splittable pseudorandom number generator  http://hackage.haskell.org/package/tf-random-0.4 (MichalPalka)
05:24:29 <Axman6> (implementations being trying m = fmap Just m `orElse` return Nothing and succeeding m = m >> return True `orElse` return False
05:25:57 <supki> :t optional
05:25:58 <lambdabot> Alternative f => f a -> f (Maybe a)
05:26:37 <Axman6> that would also work
05:27:27 <supki> :t fmap (maybe False (const True)) . optional
05:27:28 <lambdabot> Alternative f => f a -> f Bool
05:28:10 <user_2> do people use haskel for real stuff, or is it hobby?
05:28:22 <supki> user_2: yes
05:28:28 <Axman6> damn,. beat me to it
05:28:39 <Axman6> user_2: like most languages, it's used for both
05:29:57 <user_2> is it likely for someone who learn it, to find coding job in haskel?
05:30:23 <Axman6> not easily
05:32:24 <merijn> It depends
05:32:29 <merijn> How good you are
05:33:31 <Axman6> user_2: but it does look good on a resume and will teach you some very important ideas you can use in pretty much any other language
05:33:31 <raichoo1> user_2: Hobby and work.
05:33:32 <bahamas> there aren't as many jobs as there are for the main imperative languages, that's for sure
05:36:13 <raichoo1> I use quite a lot of languages at work, we are not limited to one language or paradigm. When it's possible some of us reach out for Haskell.
05:36:28 <JagaJaga> guys. I really need help. How to add to my project subdirectiry containing it's own cabal file?
05:36:45 <JagaJaga> like add local library i mean
05:36:53 <JagaJaga> and without using of cabal sandbox
05:37:01 <dcoutts> JagaJaga: you can just cabal install it
05:37:15 <JagaJaga> dcoutts, that will install it widely
05:37:17 <dcoutts> JagaJaga: e.g. cabal install ./thelocallib/
05:37:29 <dcoutts> JagaJaga: yes, and if you don't want to do that then use a sandbox
05:37:56 <JagaJaga> well, but when i use cabal build of my main prject it is compilet to dest directiry
05:37:59 <Axman6> @hoogle yield
05:38:00 <lambdabot> Control.Concurrent yield :: IO ()
05:38:00 <lambdabot> GHC.Conc.Sync yield :: IO ()
05:38:00 <lambdabot> GHC.Conc yield :: IO ()
05:38:04 <JagaJaga> i need smth like that for library
05:38:33 <dcoutts> JagaJaga: it sounds like you want to use a sandbox with the lib + exe in it
05:46:47 <merijn> Is there any naming convention for when you fork someone else's package?
05:47:09 <Hafydd> BEST-$pkgname
05:47:10 <FuuzetsuNix> no, I think we just had that discussion like 2 weeks ago
05:47:11 <Axman6> classy-foo
05:47:22 <merijn> :p
05:47:39 <FuuzetsuNix> I recommend the-REAL-$pkgname
05:47:56 <adas> what happens when i do "e <- [1, 2, 3]"
05:47:57 <adas> ?
05:48:01 <tiffany> $(pkgname)2
05:49:21 <adas> with say something like an IO Int "s <- IO Int" bind s to the Int value..but its not clear what happns in the case of "e <- [1,2,3]"
05:49:31 <FuuzetsuNix> adas: the same thing as would happen if you were to do [1, 2, 3] >>= \e -> ...
05:49:32 <merijn> Relatedly, what is the best way to handle packages whose interface is conditional?
05:49:48 <FuuzetsuNix> and if you don't know what happens then, I suggest you look up how the list monad works ;)
05:49:52 <merijn> i.e. I'm dealing with OpenCL and the available functions depends on the available OpenCL version
05:50:30 <merijn> I can easily ifdef out the relevant functions, but packages using the library have no way to specify they only work with version X available
05:52:33 <adas> FuuzetsuNix: say i do something like [1,2,3] >>= (\e -> ......) , does the (>>=) function call the function '(\e -> ..)' length ([1,2,3]) number of times with each value of [1,2,3] as the value applied to (\e -> ..)?
05:53:23 <mniip> adas, look up the implemetation of (>>=) for instance Monad []
05:55:51 <applicative> > [1,2,3] >>= show
05:55:52 <lambdabot>  "123"
05:56:22 <adas> mniip: coming to this channel would be my last resort .. as helpful as this channel is I try not to depend on this channel .. too much. bad experiences .. You can be rest assured I've already seen the implementation of (>>=) for []. Thanks
05:56:22 <d3lxa> adas: it's like the list comprehension, if you what that is
05:57:02 <merijn> adas: >>= for list is concatMap
05:57:17 <d3lxa> :t concatMap
05:57:18 <lambdabot> (a -> [b]) -> [a] -> [b]
05:59:05 <applicative> > take 3 $ [1,2,3,undefined] >>= show
05:59:06 <lambdabot>  "123"
06:02:21 <mniip> > [1..4] >>= (:[])
06:02:22 <lambdabot>  [1,2,3,4]
06:04:20 <applicative> adas: so it calls the function on as many elements of the list as it needs to
06:04:50 <applicative> concatenating as it goes along
06:05:35 <adas> so when i do something like {do s <- [1,2,3]; return s } its essentially something like "[1,2,3] >>= (\s -> return s)" which returns "concat $ [[1], [2], [3]]" which is "[1,2,3]" ? am i following the drift?
06:05:51 <Axman6> looks good to me
06:06:03 <applicative> adas, yes, mniip 's example was equivalent to that
06:07:32 <d3lxa> adas: you can write simply as: [1,2,3] >>= return
06:07:46 <merijn> adas: It is not "essentially" that, it's LITERALLY that
06:08:17 <d3lxa> when you extract in the monad list (like x <- xs) you actually do all possilbe combinations of xs in x in the below parts, think as a combination exploration
06:09:10 <d3lxa> (like nested for loops, one new loop per extraction)
06:10:10 <applicative> > take 3 $ do { x <- [1,2,3,error "but this branch was not explored"]; show x}
06:10:11 <lambdabot>  "123"
06:10:39 <d3lxa> yeah that's interesting, but it's due to the laziness of haskell :)
06:11:33 <applicative> It wasn't clear from the original question that this wasn't involved.
06:12:23 <fredyr> @undo do {s <- [1,2,3]; return s }
06:12:23 <lambdabot> [1, 2, 3] >>= \ s -> return s
06:12:42 <fredyr> adas: lambdabot can desugar do notation for you
06:14:25 <adas> cool.. so im on the right track. thanks
06:15:17 <mniip> also this
06:15:19 <mniip> > do a <- [1..3]; b <- [9..11]; return $ a * b
06:15:20 <lambdabot>  [9,10,11,18,20,22,27,30,33]
06:17:29 <adas> so there is nothing special about "<-" after all..
06:17:49 <applicative> > do {a <- "abc"; n <- [1,2,3]; return (a,n)}
06:17:50 <lambdabot>  [('a',1),('a',2),('a',3),('b',1),('b',2),('b',3),('c',1),('c',2),('c',3)]
06:18:27 <no-n> pretty much list comprehension
06:20:10 <adas> which becomes something like "let m = [1,2,3] >>= (\e -> "abc" >>= (\e' -> return (e, e')))"
06:22:39 <applicative> > let m = [1,2,3] >>= (\e -> "abc" >>= (\e' -> return (e, e'))) in m
06:22:40 <lambdabot>  [(1,'a'),(1,'b'),(1,'c'),(2,'a'),(2,'b'),(2,'c'),(3,'a'),(3,'b'),(3,'c')]
06:22:56 <applicative> > concatMap (\a -> concatMap (\b -> [(a,b)]) [1,2,3]) "abc"
06:22:57 <lambdabot>  [('a',1),('a',2),('a',3),('b',1),('b',2),('b',3),('c',1),('c',2),('c',3)]
06:23:46 <adas> which is (simplicity in complexity = beauty) and I haven't  even scratched the surface.. im sure ill have an "aha" moment when i finally grok transformers or lenses or yampa or frp or conduit or any other exotic haskell stuff
06:25:07 <quicksilver> <- is just -> in the mirror
06:25:33 <merijn> When wrapping existing libraries where my API can only implement some function Foo for a specific version of the external library, what's the most convenient way to deal with this?
06:26:11 <merijn> If I just #ifdef the relevant functions, then anyone trying to build a program depending on my code will get inscrutable errors about missing functions when they try to build while the wrong external library is present
06:27:55 <merijn> I could define one haskell library per version, but then I don't know how to define multiple cabal libraries from the same source modules...
06:28:24 <luite> merijn: you could make an autoconf package and generate a header file with some defines based on the detected lib
06:28:38 <dcoutts> merijn: see what the network lib does now
06:28:43 <quicksilver> generally haskell pacakges don't go the autoconf route
06:28:43 <merijn> luite: I *have* defines already
06:28:51 <merijn> I don't see why I would add autoconf
06:29:01 <quicksilver> because it's considered bad form for them to produce different semantics depending what libraries are installed at compile time
06:29:05 <merijn> My problem is, how do I expose this to packages depending on me
06:29:29 * hackagebot Hclip 2.0.0.1 - A small cross-platform library for reading and modifying the system clipboard.  http://hackage.haskell.org/package/Hclip-2.0.0.1 (JensThomas)
06:29:46 <quicksilver> different package name IMO
06:29:51 <quicksilver> if it actually makes your package different
06:29:55 <luite> merijn: hm, i see now
06:29:57 <applicative> oh dcoutts I was trying to make a sort of pipes-bytestring-builder but wanted to ask about the internal module for builders
06:30:01 <quicksilver> although that is a pain
06:30:03 <merijn> quicksilver: Right, but how do I do that without duplicating all the code?
06:30:09 <dcoutts> applicative: uh oh :-)
06:30:20 <quicksilver> merijn: I hope dcoutts has an answer there because I don't :P
06:30:46 <daniel-s_> Hi
06:31:00 <applicative> dcoutts: I see ... what I realized was I had no problem if I could use hPut and liftPutIO, but I take it these are only sensible under a lot of assumptions?
06:31:01 <dcoutts> merijn: the network lib went though various approaches before settling on its current one
06:31:28 <dcoutts> applicative: let me have a quick look for context...
06:31:40 <merijn> dcoutts: Yes, but they have the luxury of segregating windows vs non-windows, which means they can just expose modules dependently on the OS in the cabal file
06:31:58 <daniel-s_> Hi, I was wondering if anyone here had read this book or one similar: https://www.springer.com/computer/swe/book/978-3-540-21146-4
06:32:05 <dcoutts> merijn: iirc, they do more than that, for their common stuff
06:32:07 <daniel-s_> I just started tonight and am 10% through
06:32:46 <applicative> dcoutts the practical difficulty is that if your pipe ends up making a zillion micro bytestrings, sending the result to a terminal with buffering etc. is unpleasantly choppy
06:33:10 <dcoutts> applicative: I guess your problem is that your pipes are impure right?
06:33:26 <fizbin> @type ((),)
06:33:27 <lambdabot> t -> ((), t)
06:33:27 <merijn> dcoutts: They seem to just conditionally export things
06:33:32 <dcoutts> applicative: I mean they have effects in IO
06:34:01 <merijn> dcoutts: Which means you get confusing missing function errors if you compile your code depending on those network symbols on a platform where they're missing
06:34:21 <dcoutts> merijn: are you looking at the latest? as I think that's exactly why they changed from conditional export
06:34:51 <merijn> dcoutts: I'm looking at github
06:34:57 <merijn> dcoutts: https://github.com/haskell/network/blob/master/Network.hs
06:35:57 <dcoutts> merijn: oh but that's only the OS-level things, not the other features, like IPV6
06:36:14 <narendraj9__> What was the last thing that you built with Haskell?
06:36:18 <merijn> They hide IPV6 by not letting you specify IPs at all
06:37:00 <merijn> My problem is similar to OS-level problems
06:37:28 <merijn> i.e. I'm wrapping OpenCL and some primitives only exist in opencl 1.1 or 1.2, but I don't want to duplicate the opencl 1.0 code for those 2 cases
06:38:05 <merijn> And I don't see how I can make packages depend on a minimal opencl version without introducing 1 package per version
06:38:20 <merijn> I don't even oppose having 1 package per version, but I don't want to duplicate my code if it gets to that
06:38:47 <Taneb> Hmm, I could get a plane to ZuriHac for £150
06:40:10 <dcoutts> merijn: can apps sensibly do something when they don't have the ideal version (like you can fall back to ipv4)? or is it simply a case of having to specify a hard dep on the opencl version you need?
06:40:49 <merijn> dcoutts: It depends, some things just don't work in older versions
06:41:06 <applicative> dcoutts: yes, the pipes are in IO ultimately, since the problem only arises where buffering is involved on the way out
06:41:18 <merijn> Whether an app can work around that is app dependent
06:41:29 <dcoutts> applicative: you could do what io-streams does
06:42:05 <applicative> dcoutts: oh do they have a builder aggregating method, or whatever it should be called
06:42:18 <dcoutts> merijn: so do you want apps to be able to specify a dependency on the opencl version at build time, or only to find out at runtime?
06:42:40 <applicative> dcoutts: Oh I see the module.
06:42:43 <peteretep> The biggest thing I dislike about Hackage are that most modules miss a "Synopsis" section, that shows you some example usage
06:42:52 <peteretep> Is that considered a feature because it stops cargo-culting?
06:42:56 <peteretep> Or it's just a bit of a shame?
06:43:08 <dcoutts> applicative: they "run" the builder step by step in IO, essentially giving them a free implementation of buffering
06:43:42 <merijn> dcoutts: Preferably t build time, else I could just always export the functions, but only implement them using "error"
06:43:48 <dcoutts> peteretep: I think the lack of good docs is not considered a feature :-)
06:43:54 <peteretep> :-)
06:44:11 <peteretep> CPAN responded well to gamification and "Kwalitee" scores
06:44:14 <peteretep> hrmmm
06:44:21 <peteretep> That's not a bad project idea for my MSc
06:44:32 <applicative> dcoutts: right, this is like what I started out writing -- not understanding the internals too well yet -- then I realized this Put monad makes the whole thing unnecessary
06:44:33 <merijn> peteretep: Hackage is open source, feel free to hack together something like that :p
06:44:45 <applicative> dcoutts: I mean, if you are writing to a handle
06:44:45 <merijn> peteretep: You could volunteer it as a GSoC project too
06:45:00 <dcoutts> peteretep: having scores for things like doc coverage etc is certainly something we'd like to do. (Others are, build results, test coverage etc)
06:45:09 <peteretep> merijn: I'm a student too infrequently for that to be an option. I have a few months off at some point in the future to do something like this
06:45:51 <merijn> dcoutts: I could split the version 1 or version 2 functions into separate modules (which are conditionally empty or not) and then tell users in the docs to guard those imports with the appropriate ifdef's
06:46:06 <iross> peteretep: Take a look at this for perhaps the best documentation on Hackage: http://hackage.haskell.org/package/layers-0.1/docs/Documentation-Layers-Overview.html
06:46:09 <applicative> dcoutts: then instead of writing "for randomsProducer (lift . hPutBuilder h)
06:46:12 <dcoutts> applicative: if you're writing to a handle and want to do a bit of pre-buffering then you could do worse than following the io-streams example. If you want to construct a pure Builder then that's a different matter.
06:46:44 <applicative> dcoutts: I would write hoist (hPut IO.stdout) $ for (hoist putLiftIO randomsProducer) (lift . putBuilder)
06:46:47 <peteretep> iross: That's nice, but I've been spoiled by CPAN
06:47:02 <applicative> which is very much with the tenor of the pipes libraries, absurd as it seems
06:47:40 <merijn> dcoutts: It's a shame I can't make the import of modules a compile time error in my dependencies. i.e., my library compiles fine, but if someone tries to import a module that's empty on this machine it produces a compile error in the program trying to import it
06:47:51 <peteretep> I wasted a lot of time yesterday with Data.JSON, before switching to Data.Aeson, which had examples I could copy-paste from
06:48:09 <applicative> dcoutts: this works miraculously for simple cases; I was a little worried what would happen if my builder producer was getting user input, checking the weather etc
06:49:19 <dcoutts> merijn: right, an individual package has to have a fixed interface, it doesn't really work to allow deps to specify "I want the package built this way vs that way"
06:49:37 <dcoutts> merijn: because that doesn't translate into binaries or distro packages at all well
06:49:59 <merijn> dcoutts: I know, as I said, I'd be willing to maintain separate packages for each version IFF I don't have to duplicate my code to do it
06:50:10 <dcoutts> merijn: #include :-)
06:50:59 <merijn> And then you get nasty versions that if you have one library depending on OpenCL 1.0 and another on OpenCL 1.1 that the entire thing doesn't work
06:51:06 <dcoutts> merijn: I don't think there's a good solution if you need to allow build-time constraints. They either need to be different versions of the package, or different packages.
06:51:12 <merijn> Even though the OpenCL 1.0 library could work just fine with OpenCL 1.1
06:51:46 <dcoutts> merijn: um, I'm not sure that's the case
06:52:10 <merijn> I guess the OpenCL 1.0 package should then just specify that it can depend on either version of my code
06:52:13 <merijn> dcoutts: Why not?
06:52:23 <dcoutts> merijn: right exactly
06:52:45 <dcoutts> merijn: so you could use a non-PVP version scheme and encode the opencl version into it
06:53:18 <merijn> I might not even need that, right?
06:53:46 <dcoutts> applicative: I fear I havn't quite got what you're doing exactly
06:53:55 <merijn> If bother packages export the same module names then they could just be separate packages on programs could depend n either, no?
06:55:20 <merijn> dcoutts: I don't suppose I can use CPP in cabal files? >.>
06:55:47 <applicative> dcoutts: i'm trying to get the results of a pipe that produces a zillion little bytestrings or builders, into stdout!
06:55:48 <dcoutts> merijn: separate package names is another option, there you're encoding the opencl version into the package name rather than the package version
06:56:16 <merijn> dcoutts: That was my idea, yes
06:56:16 <dcoutts> applicative: and running this pipe is definitely an IO op
06:56:45 <dcoutts> merijn: I tend to prefer encoding versions into versions rather than names, but I'm not making the decision :-)
06:57:03 <merijn> dcoutts: Actually, my current idea is: separate package names, all using the same modules but each package forcing a CPP define that disables "newer" functionality
06:57:25 <applicative> well, yes, it is true that the plan I was wondering about involves using 'hPut h' ; ideally one would have Pipe Builder ByteString m r, perhaps where m is 'MonadIO'
06:57:45 <applicative> the latter is what I will get emulating IO streams
06:57:55 <merijn> dcoutts: Then you can depend on ANY of the three if you can run with either 1.0, 1.1 or 1.2 of OpenCL
06:58:29 <merijn> I just need a build time way to check whether a compatible version of OpenCL is available
06:58:49 <dcoutts> merijn: actually that's a good reason to use versions rather than names, so you can easily say that you depend on any (or some) of them
06:58:59 <applicative> dcoutts: but the other is more beautiful, at least according to a perverse aesthetic. I transform my pipe into the Put monad with a 'monad  morphism' liftPutIO, then render with hPut
06:59:24 <merijn> dcoutts: I thought cabal already supported multiple possible dependency sets (not just versions)
06:59:35 <dcoutts> applicative: which hPut are you referring to exactly?
06:59:36 <merijn> Does GHC support #error?
06:59:53 <dcoutts> merijn: it does but it's considerably less convenient
06:59:56 <applicative> dcoutts: the one defined in the internal module, hPutBuilder is defined in terms of it
06:59:59 <dcoutts> merijn: since you have to use flags etc
07:00:26 <applicative> sorry, I forgot that other hPuts are in town
07:01:42 <applicative> hPutBuilder h = hPut h . putBuilder
07:03:24 <dcoutts> applicative: so you'd be accumulating a Put value and then running it at the end with Builder.hPut ?
07:03:34 <applicative> right, exactly
07:03:57 <applicative> rather than explicitly accumulating builders and making decision about them etc
07:04:20 <Philonous> Can I "register" a Decl in a template haskell computation so that subsequent calls to reify would take it into account?
07:04:28 <dcoutts> applicative: there's not really that much difference between Builder and Put monad values
07:04:35 * hackagebot doctest 0.9.10.2 - Test interactive Haskell examples  http://hackage.haskell.org/package/doctest-0.9.10.2 (SimonHengel)
07:05:37 <applicative> yes, I couldn't figure out how to apply the Builder monad here, but maybe I should try again.
07:06:12 <applicative> there is also this stuff ciosBlah that is supposed to help with 'streaming libraries' but doesn't see to get used anywhere
07:06:13 <dcoutts> applicative: so I think if you take that approach you'd end up accumulating a big dlist-like chain of thunks and then when you've finished folding over your input, then when you hPut then it'll all get written out in one go
07:06:26 <dcoutts> applicative: so it's not really streaming
07:06:51 <applicative> yes, my question is associated with that
07:07:11 <dcoutts> applicative: where as the io-stream use of builder is really streaming
07:07:24 <dcoutts> but it's lower level and less nice
07:07:41 <dcoutts> they run the 'BuildStep's as they go
07:09:27 <applicative> dcoutts: oh it streams alright, I am writing the infinite random number producer
07:09:29 <no-n> do people use catch?
07:09:35 <applicative> dcoutts: or rather running it
07:09:48 <merijn> no-n: What do you mean "do people use catch?"?
07:10:02 <merijn> no-n: You mean from Control.Exception?
07:10:07 <no-n> idk. though maybe people just use Maybe/Either instead
07:10:08 <no-n> yeah
07:10:12 <no-n> thought*
07:10:20 <merijn> no-n: I don't use them for the same things
07:10:35 <no-n> just wondering if the exceptions part of lyah is worth the read
07:10:40 <dcoutts> applicative: but what you're doing right now is for each little output chunk you're calling (hPut h . putBuilder)
07:10:44 <dcoutts> applicative: right?
07:10:54 <dcoutts> applicative: in which case you don't really get any buffering
07:10:55 <merijn> no-n: I think APIs should return Maybe/Either, but if I have a deeply nested server loop and my only response to an error is "throw exception and terminate connection" then exceptions + catch are much easier
07:11:08 <merijn> no-n: I do use exceptions quite a bit for IO heavy code
07:11:20 <no-n> *nod*
07:11:32 <no-n> I guess I'll read it then :}
07:11:36 <dcoutts> applicative: you only get buffering within that Put action, not between subsequent ones in your pipe
07:12:45 <applicative> dcoutts: yes, I was wondering, but in fact its behaviour is absolutely unlike that for printing the corresponding zillion bytestringsss
07:12:57 <merijn> no-n: haskell exceptions are effectively like Java's unchecked exceptions or (perhaps a better comparison) Go's panic/recover
07:13:16 <no-n> I've never worked with either of those languages ;o
07:13:36 <no-n> mostly just Python
07:13:53 <merijn> no-n: Python only has unchecked exceptions :)
07:14:00 <dcoutts> applicative: oh that may simply be a bug, that it's not respecting the buffering mode of the handle, so never flushing.
07:14:05 <no-n> ahh, okay :}
07:14:09 <dcoutts> applicative: hPut I mean
07:14:22 <merijn> no-n: And people use them too much :p
07:14:36 * hackagebot numeric-prelude 0.4.1 - An experimental alternative hierarchy of numeric type classes  http://hackage.haskell.org/package/numeric-prelude-0.4.1 (HenningThielemann)
07:14:37 <no-n> yeah
07:14:47 <dcoutts> applicative: which actually is what you want it seems, you would like to use the normal handle output buffering, but presumably don't feel that you can fiddle with that handle-global setting
07:15:00 <applicative> dcoutts: right now we are getting closer to my original worry
07:16:31 <applicative> dcoutts: ah well, I will return to trying something like io-streams I guess. The miracle of hPut seems to be an illusion
07:16:49 <dcoutts> applicative: yes, we'll likely fix that bug at some point :-)
07:17:28 <dcoutts> applicative: though it's an interesting point that sometimes you would like to override the buffer mode and always use buffering for certain writes
07:18:06 <dcoutts> applicative: the other difference with doing you're own buffering is you'd take the Handle lock less often, but would interleave differently with other concurrent writers.
07:18:18 <dcoutts> you're/your
07:18:33 <fizbin> @type \x -> x >> return ()
07:18:34 <lambdabot> Monad m => m a -> m ()
07:18:46 <fizbin> @hoogle m a -> m ()
07:18:47 <lambdabot> Control.Monad void :: Functor f => f a -> f ()
07:18:47 <lambdabot> Foreign.Marshal.Error void :: IO a -> IO ()
07:18:47 <lambdabot> Text.ParserCombinators.ReadP optional :: ReadP a -> ReadP ()
07:19:13 <peteretep> Someone recently asked for an example where Erlang's pattern matching was better than Haskell's, and I went with: http://lpaste.net/101194
07:19:20 <peteretep> Can you do something similar in Haskell?
07:19:20 <dcoutts> applicative: alternatively, if the thing you were writing was actually pure then you could lift each chunk directly to a builder and mconcat the result, and do a single write at the end (which would be streaming)
07:19:39 <applicative> dcoutts: you can see why hoist (hPut IO.stdout) $ for (hoist putLiftIO randomsProducer) (lift . putBuilder) looked good to me...
07:20:01 <applicative> oh let me think about what you just said
07:20:37 <applicative> dcoutts: right that's what you do in making a lazy bytestring
07:20:44 <dcoutts> applicative: right
07:20:58 <applicative> thats what i was trying to emulate at first
07:21:07 <dcoutts> applicative: though here with a dlist (Builder) rather than a list (lazy bytestring)
07:21:45 <dcoutts> a foldr on a dlist works great, where as a foldl on one doesn't
07:22:27 <Philonous> peteretep, I don't know any erlang. What's A? A variable? A construktor?
07:22:51 <applicative> dcoutts ok, I think I'm getting enough ideas to have another go at it.  the types in here are a chamber of horrors
07:23:10 <peteretep> Philonous: It's a variable. Once it's assigned in the first isntance in the match, it's assigned for the rest of the match
07:23:13 <dcoutts> peteretep: that's a Prolog hangover in Erlang and sadly it doesn't go any further than that so it's not that great a help
07:23:23 <peteretep> Philonous: So the concept here is matching winning tic-tac-toe boards
07:23:32 <peteretep> dcoutts: Fair enough
07:23:32 <merijn> Philonous: Erlang has linear pattern matches
07:23:38 <dcoutts> applicative: yes, and thinking about what's going on when, tricky.
07:23:39 <applicative> dcoutts I will get back to you if I keep having trouble, thanks!
07:23:46 <dcoutts> applicative: ok, np :-)
07:24:23 <dcoutts> peteretep: the Haskell language folks considered it back at the beginning, but it doesn't generalise or add much power so they didn't add it.
07:25:33 <dcoutts> peteretep: so you'd just say: evaluate([ a,a',a'', _,_,_, _,_,_ ]) | a == a', a == a''  = Winner a
07:26:03 <dcoutts> peteretep: oh, missing the /= b bit.
07:27:08 <peteretep> dcoutts: I like the guard idea
07:28:03 <merijn> dcoutts: There's no CPP macro for the package's own version, no?
07:28:11 <Philonous> So the idea is that variables that are mentioned multiple times in bindings positions imply equality?
07:28:30 <peteretep> Philonous: Well they're immutable, and the first time they're bound, they retain that value
07:28:42 <peteretep> Philonous: So, yes
07:28:44 <dcoutts> merijn: no, just as a value in the Paths module.
07:28:48 <peteretep> Philonous: But from a slightly different angle
07:29:23 <dcoutts> Philonous: it's a left-over from proper Prolog unification
07:29:40 * hackagebot numeric-quest 0.2.0.1 - Math and quantum mechanics  http://hackage.haskell.org/package/numeric-quest-0.2.0.1 (HenningThielemann)
07:30:06 <dcoutts> Erlang started as prolog and then they removed the unification, leaving just the ugly syntax ;-)
07:30:38 <Kron> I quite like prolog unification
07:30:47 <Kron> I wonder if it could be like, functionally generalized?
07:30:53 <Kron> foo x (fn x) =
07:31:06 <Kron> where it can run functions and stuff inside the patterns and use unification too
07:31:09 <dcoutts> Kron: see mercury
07:32:25 <Philonous> Kron, You can already have functions inside patterns with haskell
07:32:48 <Kron> ... oh?
07:32:59 <Philonous> Kron, view patterns
07:33:04 <Kron> elaborate
07:33:55 <applicative> > let f (even -> True) = 0; f _ = 1 in f 2
07:33:56 <lambdabot>  0
07:34:19 <Kron> ooooh
07:34:28 <applicative> we can count on lambdabot to have things like -XViewPatterns turned on
07:34:29 <Kron> can I read up on these?
07:34:54 <bennofs> :t (,3)
07:34:55 <lambdabot> Num t1 => t -> (t, t1)
07:35:01 <Kron> and tuple sections
07:35:02 <Kron> apparently
07:35:37 <Philonous> http://www.haskell.org/ghc/docs/7.6.3/html/users_guide/syntax-extns.html#view-patterns
07:42:25 <Kron> thanks phil
07:43:08 <merijn> dcoutts: When in the build process is the _paths module generated? Supposing I want to obtain the version number from it during the build process
07:43:27 <dcoutts> merijn: it's generated at the start of the build step
07:44:43 * hackagebot llvm-tf 3.0.0.2 - Bindings to the LLVM compiler toolkit using type families.  http://hackage.haskell.org/package/llvm-tf-3.0.0.2 (HenningThielemann)
07:44:44 * hackagebot clash-prelude 0.3 - CAES Language for Synchronous Hardware - Prelude library  http://hackage.haskell.org/package/clash-prelude-0.3 (ChristiaanBaaij)
07:49:43 * hackagebot llvm-tf 3.0.1 - Bindings to the LLVM compiler toolkit using type families.  http://hackage.haskell.org/package/llvm-tf-3.0.1 (HenningThielemann)
07:51:25 <merijn> ಠ_ಠ
07:51:30 <merijn> c2hs is misbehaving
07:52:11 <merijn> I feel yet another yak shaving adventure coming up
07:52:31 <Kron> there is a joke I am missing here
07:52:33 <Kron> yak shaving? :P
07:53:27 <merijn> Kron: http://www.catb.org/jargon/html/Y/yak-shaving.html
07:53:51 <Kron> hah, okay
07:54:06 <merijn> Kron: or: https://programmers.stackexchange.com/questions/34775/correct-definition-of-the-term-yak-shaving#34788
07:54:09 <merijn> for a better example
07:54:48 <Kron> ahahahaha
07:55:05 <iross> merijn: Dare I ask?  What's c2hs doing?  Or failing to do?
07:56:33 <Kron> shave yaks, clearly
07:58:04 <merijn> iross: It's generating invalid CPP in the headers it generates
07:58:46 <merijn> I have a suspect, but I need to find where in the c2hs code it is to be sure
07:59:09 <iross> If you find it, a pull request would be *lovely*...
08:00:35 <merijn> iross: If you can clue me in where the CPP is being called, that'd help
08:00:48 <Guest901> ?help
08:00:48 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
08:01:29 <Guest901> ?list
08:01:29 <lambdabot> What module?  Try @listmodules for some ideas.
08:03:09 <iross> merijn: It's right in Main.hs, line 600 in HEAD (cppproc <- runProcess cpp args, if you want something to search for).
08:04:02 <Guest901> ?src (->)
08:04:02 <lambdabot> Source not found. BOB says:  You seem to have forgotten your passwd, enter another!
08:04:49 <Guest901> I have a question. Where can I get the definition of (->) ?
08:05:38 <thebnq> its just function application
08:06:45 <merijn> ugh
08:06:49 <Guest901> no, it's type constructor. if you type :info in ghci you'll get (data (->) a b)
08:06:55 <merijn> I suspect it might be gcc fouling things up as usual
08:07:42 <geekosaur> it's both. but it does not have "source", it's wired in
08:08:18 <thebnq> Guest901: the function (a -> b) can be thought of as typed (->) a b
08:08:21 <geekosaur> (put otherwise it's spread throughout the compiler)
08:08:28 <Guest901> and it means i can't write my own definition to understand it better?
08:09:22 <merijn> What machinery is responsible for generating "Foo.chs.h" from "Foo.chs"? Just c2hs?
08:10:00 <mniip> Guest901, how can you write an implementation of it if you don't understand what exactly is it, even
08:10:21 <mniip> And no, you cannot. Unless you want to reimplement GHC
08:10:28 <geekosaur> Guest901, it may be possible to write a wrapper but since function application is an intrinsic it's not really possible to write your own
08:11:11 <thebnq> if you do, you get arrows hehe
08:11:22 <geekosaur> and yes, if you want to "understand it better" int hat way, you are looking at implementing your own compiler, possibly for a simplified subset of Haskell. but that's a pretty big job
08:11:26 <Guest901> i thought, i could get the source and then somehow rewrite it in my own words and understand, but if it doesn't exist, okay
08:12:24 <Guest901> so, tell me, (->) is only a part of compiller, not a part of haskell?
08:12:48 <Axman6> well, its implementation is defined by the compiler
08:13:59 <iross> merijn: I think that's just written at around line 571 in Main.hs.  To be honest, although I've been working on C2HS for some months now, I've still not quite understood what the CPP stuff is all about...
08:16:15 <Guest901> compiller defines it and gives us some common interfaces so that we could  use it as (data (->) a b), for example, to define Functor for it, right?
08:16:24 <merijn> iross: Right, but I don't think that's the problem as if the exitcode is a failure it should return via "fatal", but I don't see the ftatal error
08:17:25 <moein7tl> recently I interested to functional programming,Is there any good free ebooks about learning haskell?
08:17:31 <Iceland_jack> moein7tl: LYAH
08:17:33 <Iceland_jack> @where lyah
08:17:33 <lambdabot> http://www.learnyouahaskell.com/
08:18:06 <moein7tl> @Iceland_jack: LYAH? what does it mean?
08:18:06 <lambdabot> Unknown command, try @list
08:18:14 <Iceland_jack> moein7tl: Learn You a Haskell
08:18:22 <Iceland_jack> It's what the link says
08:18:41 <iross> merijn: So you think CPP is just failing?  Can you switch on the tracing so you can see what preprocessor command is actually being executed?  (Flags like "-d trace" to make that happen, I think.)
08:19:09 <moein7tl> @Iceland_jack: thanks,where does haskell use in real world? I have some little experience with Erlang and Scala
08:19:09 <lambdabot> Unknown command, try @list
08:20:22 <merijn> iross: CPP is failing, but it should do that in this case
08:20:28 <merijn> iross: I think I've found the problem, though
08:22:00 <merijn> iross: It's producing invalid CPP in Foo.chs.h if there's an elif in Foo.chs
08:23:36 <iross> merijn: Interesting.  None of the C2HS test cases have and
08:23:48 <iross> merijn: #elseif (or #elif)...
08:24:31 <iross> merijn: There are some #elses, but nothing else.  Maybe I need to add a test case for that, although I'm not sure why it wouldn't be working.
08:24:48 * hackagebot dlist-instances 0.1 - Difference lists instances  http://hackage.haskell.org/package/dlist-instances-0.1 (GregWeber)
08:25:42 <Guest901> can someone say if it's right: >compiller defines it and gives us some common interfaces so that we could  use it as (data (->) a b), for example, to define Functor for it
08:27:09 <merijn> iross: http://lpaste.net/101197
08:27:23 <merijn> iross: That's the input CPP and generated output header
08:27:46 <merijn> iross: The output is missing an #endif, which is messing up the compile
08:29:16 <iross> merijn: OK, I need to look at that.  Will you make a ticket or shall I do it?  I was going to do some C2HS fixing tomorrow, so I could deal with it then.
08:30:18 <merijn> iross: I can make a ticket in a bit, I'm checking if I understand what's going on
08:30:38 <iross> merijn: Cool. Thanks!
08:46:33 <lpsmith> hmm, if you declare an IsString instance,  does fromString run at compile time when writing down string literals with a non-polymorphic type?
08:48:37 <Axman6> I don't think so, I think it's just transformed into fromString "foo". anything more would require being able to run potentially anything at compile time right?
08:48:40 <merijn> lpsmith: "It Depends(TM)"
08:48:54 <merijn> I think Text/ByteString use dark voodoo to convert at compile time
08:50:12 <int-e> "dark voodoo" meaning that they exploit the fact that ghc encodes string literals as some "unpack" function applied to a char array, so they have a rewrite rule that removes that indirection.
08:50:23 <int-e> there is no evaluation happening in that case either.
08:50:57 <lpsmith> Axman6, well it would require running pure functions at compile time,  which should be theoretically possible,  but constant folding in GHC doesn't seem to be anything you can rely on.
08:51:16 <quicksilver> GHC constant folds a few simple arithmetic things
08:51:23 <quicksilver> and it will evaluate a constant case
08:51:27 <quicksilver> but that's about it I believe
08:51:57 <Axman6> well, "pure" for bytestring means allocating memory, does ghc know how to then make that memory constant data in the binary>?
08:52:09 <prinsen> I compile with -XSafe, and still want to use aeson, so I added -trust aeson, but it still complains on importing Data.Aeson
08:52:22 <lpsmith> I've seen plenty of cases where,  intuitively, constant folding should have worked, but didn't.
08:52:44 <lpsmith> Axman6, well GHC would have to anyway :)
08:53:12 <Axman6> well, it would have to with the string sure
08:53:40 <Axman6> but not necessarilly for the bytestring produced by fromString "str"
08:53:45 <__sebastian__> Hi all, anyone knows a lens for ((<$>) . (<$>)) ?
08:54:02 <__sebastian__> or an infix op
08:54:50 <edwardk> mapped.mapped
08:55:02 <edwardk> :t over (mapped.mapped)
08:55:02 <lambdabot> (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
09:00:01 <napping> Is anyone using structured-haskell-mode? How in the world do you select the parent node?
09:04:25 <napping> ah, it really is ")"
09:04:55 * hackagebot ixmonad 0.3 - Indexed monads library  http://hackage.haskell.org/package/ixmonad-0.3 (DominicOrchard)
09:04:57 * hackagebot th-desugar 1.3.0 - Functions to desugar Template Haskell  http://hackage.haskell.org/package/th-desugar-1.3.0 (RichardEisenberg)
09:07:05 <joelteon> Damn you, "blocked indefinitely on an STM transaction"
09:07:17 <joelteon> damn you!
09:08:41 <Kron> so I was reading quchen's articles and I ran into this: https://github.com/quchen/articles/blob/master/fbut.md#show-is-not-for-prettyprinting
09:09:16 <Kron> which is definitely a sin I was committing on my quadtrees. Now that I've fixed that, I'm curious about the best way to properly define pretty printing functions, cause i'd like to do that. I find pretty prints to really help me in debugging
09:15:00 * hackagebot snaplet-postgresql-simple 0.5 - postgresql-simple snaplet for the Snap Framework  http://hackage.haskell.org/package/snaplet-postgresql-simple-0.5 (DougBeardsley)
09:15:54 <c_wraith> Kron: there are a couple packages designed for pretty printing
09:16:16 <c_wraith> .. By which I apparently mean like 50
09:17:05 <c_wraith> Kron: http://hackage.haskell.org/package/pretty is probably the best option
09:18:01 <Kron> ookay. Thanks!
09:25:03 * hackagebot llvm-extra 0.4.2 - Utility functions for the llvm interface  http://hackage.haskell.org/package/llvm-extra-0.4.2 (HenningThielemann)
09:32:08 <joelteon> damn it, ghci
09:32:15 <guymann> agreed
09:33:13 <zlatan> hi. in tryhaskell I came to exercise where I need to:
09:33:15 <zlatan> ry to get the 'a' value from this value using pattern matching:
09:33:15 <zlatan> (10,"abc")
09:33:46 <zlatan> si I did it with let (a,b:_)=(10,"abc") in b
09:33:50 <zlatan> so*
09:33:56 <c_wraith> zlatan: that's correct, yes
09:34:10 <c_wraith> zlatan: though you didn't need to name a
09:34:28 <c_wraith> zlatan: (_, b:_) would be a sufficient pattern
09:34:34 <zlatan> c_wraith, yes the spoiler says let (_,(a:_)) = (10,"abc") in a
09:35:04 * hackagebot llvm-extra 0.5 - Utility functions for the llvm interface  http://hackage.haskell.org/package/llvm-extra-0.5 (HenningThielemann)
09:35:13 <zlatan> c_wraith, so there isn't any significant difference between two?
09:35:16 <bitemyapp> xuser: hi
09:35:31 <c_wraith> zlatan: if you enabled all warnings, ghc/ghci would warn you about an unused variable with your definition.  They work the exact same way, though.
09:35:44 <jrmithdobbs> zlatan: well, naming a may force it to be evaluated so it can't be undefined, but in most cases no
09:35:57 <zlatan> c_wraith, okay, thanks...thats good point :)
09:36:15 <zlatan> jrmithdobbs, thanks
09:36:26 <geekosaur> jrmithdobbs, it's irrefutable, so shouldn't force evaluation to whnf
09:36:42 <c_wraith> zlatan: it's worth using -Wall in learning exercises, just because it may catch some things for you.
09:37:15 <c_wraith> zlatan: after all, the whole purpose of that flag is to catch things even when experienced programmers do them. :)
09:37:58 <c_wraith> (experience *haskell* programmers, that is)
09:38:05 <Kron> I also like using hlint
09:38:10 <Kron> when learning
09:41:18 <joelteon> so using :trace main instead of just :main means STM exceptions don't get thrown :?
09:57:33 <TallerGhostWalt> is there some trick to installing hmatrix in a sandbox?
09:58:00 <TallerGhostWalt> getting a bunch of ...Linking dist/dist-sandbox-34d68aef/build/wavelets/wavelets ...
10:00:29 <geekosaur> hm? that is not an error
10:00:53 <geekosaur> if there is an error after that then you might want to show that instead of a normal progress message
10:02:16 <xintron> Is there an easy way to get the OS page_size?
10:04:32 <geekosaur> doesn't look like it; the sysconf interface in System.Posix.Unistd is rather incomplete
10:06:34 <xintron> Found one example where the following was used: foreign import ccall unsafe "unistd.h getpagesize"; pagesize :: CInt
10:07:01 <xintron> But didn't seem like the optimal solution. Well, maybe it is for this situation :/
10:07:21 <TallerGhostWalt> sorry
10:07:24 <TallerGhostWalt> it must not have posted
10:09:36 <TallerGhostWalt> here is the full error when I try and build with hmatrix installed in a sandbox http://lpaste.net/101203
10:10:40 <TallerGhostWalt> I tried deleting the sandbox and remaking it but just ended up right back where I was
10:11:26 <geekosaur> xintron: technically you should be using sysconf(SC_PAGESIZE) I think
10:12:43 <xintron> geekosaur, Any easy way to do this in Haskell?
10:13:09 <geekosaur> TallerGhostWalt, did you install those packages with profiling?
10:14:06 <geekosaur> xintron, I think you need a wrapper unfortunately. you can probably get away with getpagesize for now but it's not portable
10:14:33 <TallerGhostWalt> geekosaur: that was it
10:14:41 <TallerGhostWalt> geekosaur: thanks
10:18:28 <xintron> geekosaur, Maybe I should be parsing /proc/PID/status instead of stat+statm. Not as easy to parse but it will have the memory info pre-calculated.
10:18:48 <TallerGhostWalt> can you hide instances on module import?
10:18:55 <geekosaur> oh, if you're using /proc you're already out of portability territory
10:19:00 <geekosaur> TallerGhostWalt, no
10:19:12 <TallerGhostWalt> geekosaur: why not?
10:19:21 <geekosaur> that's a long story
10:19:27 <TallerGhostWalt> oh
10:19:39 <xintron> geekosaur, So, any easy way (mainly on Linux) to find the current page size? :D
10:19:40 <geekosaur> take a look at the current discussion of GenericNewtypeDeriving on libraries@
10:20:10 <TallerGhostWalt> k
10:20:15 <geekosaur> xintron, just use getpagesize if it's there (it's actually a BSDism but if glibc supports it then you're fine). if you're using /proc you have already lost portability to non-linux
10:20:31 <geekosaur> (lots of systems have /proc but it behaves differently on all of them
10:20:33 <geekosaur> )
10:21:19 <xintron> geekosaur, I was looking for a process information library but couldn't find any (that didn't use procfs) so thought I'd just start there :)
10:21:23 <geekosaur> TallerGhostWalt, the short version is, if I can hide Ord instance for a type then I can break Data.Map
10:22:10 <geekosaur> xintron: there aren't many portable ones because it's a hard job. there's gnome's libgtop if you can live with GPL (not LGPL)
10:22:30 <geekosaur> (unless they changed that; I stopped looking some time back)
10:23:53 <xintron> nope, seems to be GPL still
10:25:35 <xintron> Well, that was the knife in my (thought to be) small project. Not worth the effort anymore
10:26:01 <xintron> Did learn a lot from it all though with regards to process management (in Linux mainly)
10:32:15 <edwardk> TallerGhostWalt: wait, did i release my wavelets package?
10:32:22 <edwardk> oh, that isn't mine
10:32:36 <edwardk> for that matter mine isn't even on github, nevermind =)
10:32:53 <edwardk> carry on then
10:35:15 * hackagebot tagged 0.7.1 - Haskell 98 phantom types to avoid unsafely passing dummy arguments  http://hackage.haskell.org/package/tagged-0.7.1 (EdwardKmett)
10:40:16 * hackagebot synthesizer-core 0.7 - Audio signal processing coded in Haskell: Low level part  http://hackage.haskell.org/package/synthesizer-core-0.7 (HenningThielemann)
10:40:21 <ski> Twey : i don't follow what contravariance has to do with nominal equality here
10:41:02 <fizruk> how do I compile a program using some libraries from sandbox with GHC? it seems to ignore packages installed in sandbox. GHC 7.6.43, cabal-install 1.18.0.3
10:41:55 <supki> fizruk: -package-db
10:42:52 <fizruk> supki: thanks!
10:45:16 * hackagebot synthesizer-dimensional 0.7.0.1 - Audio signal processing with static physical dimensions  http://hackage.haskell.org/package/synthesizer-dimensional-0.7.0.1 (HenningThielemann)
10:47:02 <ion> Interesting
10:47:21 <guymann> interdasting
10:47:54 <Hafydd>  /w 12
10:55:18 * hackagebot synthesizer-midi 0.6.0.1 - Render audio signals from MIDI files or realtime messages  http://hackage.haskell.org/package/synthesizer-midi-0.6.0.1 (HenningThielemann)
11:05:19 * hackagebot synthesizer-alsa 0.5.0.1 - Control synthesizer effects via ALSA/MIDI  http://hackage.haskell.org/package/synthesizer-alsa-0.5.0.1 (HenningThielemann)
11:09:43 <Twey> ski: Nominal equality is the ‘no you can't convert it’ rôle
11:18:40 <dacali> This is probably a stupid question, but a monad is a monoid, right?
11:19:08 <Clint> no
11:19:36 <geekosaur> mm. arguably a monad is a monoid but a Monad is not necessarily a Monoid
11:19:45 <edwardk> dacali: a monad is a monoid in a categorical enough sense.   however a Monad is not a Monoid.
11:19:55 <geekosaur> (the former referring to category theory, the latter to Haskell)
11:20:05 <dacali> Ah, gotcha.
11:20:38 <dacali> In the categorical sense, would unit/return be zero and >=> be append?
11:21:27 <edwardk> yes
11:21:42 <edwardk> return is the unit of (>=>)
11:21:48 <ToTheSkies> @pl \ x -> x * x
11:21:48 <lambdabot> join (*)
11:22:18 <edwardk> dacali: notice, that because of the indices, this forms a category
11:22:41 <edwardk> dacali: but there is a way to describe it as a monoid in the bicategory of endofunctors
11:23:28 <dyfrgi> So given that I have a system with the gold linker, how do I build a ghc that works with it? I need a working ghc to build ghc, but in order to have a working ghc I need to not be using gold; if I'm not using gold, then ghc will build with the flags for GNU ld hardcoded.
11:23:44 <dyfrgi> This is also assuming that I want to build a released version of GHC.
11:23:46 <edwardk> dacali: so the 'return is the unit of (>=>)'  monoid/category is a rather weak version, while when a category theorist is describing how a monad is a 'monoid in the category of endofunctors' they are making a deeper statement
11:23:46 <ski> Twey : i was more or less wondering how covariance and contravariance would fit into this scheme, if at all
11:24:19 <dacali> Thanks, edwardk! I've been slowly trying to straighten out the category theory in my head.
11:24:35 <dyfrgi> This is fixed in ghc 6063, but 7.6.3 was cut months before that ticket was closed.
11:25:07 <shachaf> edwardk: Weak version of what?
11:25:20 <dacali> edwardk: Sounds like I have more reading to do. Thanks for clearing that up though.
11:25:23 <edwardk> shachaf: of how to view a monad as a monoid
11:25:37 <shachaf> I think "the Kleisli category is a category" is a reasonable statement.
11:25:42 <edwardk> sure
11:25:46 <shachaf> Oh, restricting it to a monoid? Sure.
11:25:47 <edwardk> its a very useful statemnt
11:25:48 <dyfrgi> Oh hey, there's a #ghc; I'll try there.
11:25:55 <edwardk> but its not a good _monoid_ =)
11:26:19 <magicman> The categorical monoid is join :: M * M ~> M, and return :: I ~> M, or something?
11:26:45 <shachaf> Yes. But you have to decide what * and I are.
11:26:58 <absence> hm, it's not possible to make a monad instance using join and return is it? because join isn't part of the typeclass?
11:27:14 <shachaf> x >>= f = join (fmap f x)
11:27:18 <shachaf> It's not part of the class right now.
11:27:30 <magicman> As in, f * g = /\a. f (g a), and I a = a? Or does that not work?
11:27:48 <absence> shachaf: will it be? is that part of the applicative monad proposal?
11:28:27 <absence> since you say "right now", i mean :)
11:28:30 <shachaf> It's been floating around for a long time. I don't know.
11:28:42 <absence> ok. thanks
11:28:44 <shachaf> magicman: Yes, if you use functor composition and the identity functor you get a monad.
11:30:13 <ski> magicman : you could also have `*' be tensor product in a category of vector spaces, and `I' be the field of scalars
11:32:03 <ski> magicman : then you get basically <http://en.wikipedia.org/wiki/Algebra_over_a_field>
11:32:27 <dacali> geekosaur: Thanks for the clarification.
11:32:31 <magicman> Not familiar with tensors, but that's kinda cool :)
11:33:17 <mmmm> Say I'm making some changes to a library, say the module is X.Y.Z then I make some changes to the module, how can I get import X.Y.Z to refer to the new version rather than the old version?
11:34:33 <ski> magicman : you know how if you take direct product of a vector space `|R^m' and `|R^n' you get something that's isomorphic to `|R^{m + n}' ?
11:34:44 <magicman> ski: Aye.
11:35:01 <ClaudiusMaximus> mmmm: bump the version number (append a .1 or so) before you install your modified version
11:35:06 <Twey> ski: It doesn't make a difference; the same rules apply to covariant parameters as contravariant parameters (I think)
11:35:07 <ski> magicman : well, if you take the tensor product of those instead, you get something that's isomorphic to `|R^{m*n}'
11:35:45 <ski> Twey : but if we had subtyping, probably we'd had to refine it (like OCaml does, e.g.)
11:36:22 <Twey> ski: But we don't have subtyping :þ
11:36:36 <Twey> ski: Convertability is a bijection
11:36:51 <ski> magicman : a linear transformation from that tensor space corresponds to a bilinear transformation from the two starting spaces
11:37:39 <magicman> I see.
11:37:42 <ski> Twey : yes. i'm wondering whether maybe for some functor idea we want to make this distinction anyway. or whether we want to think about the matter, if we would ever add subtyping (e.g. in the form of refinement types) in the future
11:38:10 <mm_freak> http://lpaste.net/101205
11:38:13 <mm_freak> savegames for free! =)
11:38:21 <ski> magicman : so, tensors can be used to express "multiple-argument" linear transformations, in the sense that it makes sense to curry them, getting a linear transformation to a vector space of linear transformations
11:38:38 <ski> magicman : it wouldn't make sense to try to curry a linear transformation from a direct product
11:38:38 * Twey nods.
11:38:59 <magicman> Right, yes.
11:39:27 <mm_freak> i finally figured out serializable wires, so netwire/wires applications will be serializable…  for free
11:39:44 <triliyn> mm_freak: oooh, looks cool
11:39:56 <Twey> Neat!
11:40:40 <ski> Twey : e.g. it might be possible to make an extension of `newtype' which allows multiple arguments, and where one could O(0)-map from that to the type of the first argument ..
11:40:49 <Hodapp> mm_freak: you dawg, I heard you like wires, so I made your wires into a form that can go over wires?
11:40:56 <Hodapp> s/you/yo/ >_>
11:41:46 <Twey> mmmm: It should already refer to the new version (or, more specifically, whichever version is available).  You can use Cabal (probably with a sandbox) to force an environment in which it's the only version available.
11:42:12 <mm_freak> Hodapp: indeed =)
11:42:23 <houshuang> What is the meaning of k1/a1 and k0/a0 in this error message? Couldn't match expected type `String -> (k1 -> M.Map k1 a1 -> M.Map k1 a1) -> k1 -> M.Map k1 a1 -> M.Map k1 a1' with actual type `M.Map k0 a0'
11:42:23 <houshuang>  
11:42:41 <Twey> ski: Hm, sounds like a very slippery slope
11:43:21 <Twey> houshuang: They're probably generated variable names (i.e. you have two different variables called a and two different variables called k, so the compiler renamed them to make the error make more sense)
11:44:21 <geekosaur> houshuang: they're types, k0/k1 are types used as keys in Map, a0/a1 are types used as values. and your problem is likely that it cannot prove to itself that your k0 and k1 (resp. a0 and a1) are the same. so either your type signature(s) need some work or you need ScopedTypeVariables
11:44:31 <geekosaur> (don't forget to `forall` the ones to be scoped)
11:45:31 * hackagebot synthesizer-llvm 0.6 - Efficient signal processing using runtime compilation  http://hackage.haskell.org/package/synthesizer-llvm-0.6 (HenningThielemann)
11:45:34 <houshuang> geekosaur: Thanks, never seen those types before. I'm just playing with Maps, and was trying to write a very simple word count: foldr M.empty (\x -> M.insertWith (+) x 1) $ words "this is this"
11:46:29 <geekosaur> ah. I think you have your parameters backwards in that case?
11:47:54 <houshuang> geekosaur: Hm, this works though. M.insertWith (+) "hi" 1 M.empty
11:48:02 <Twey> The problem isn't that the parameters don't match in this error.  The two types being unified are completely different.
11:48:09 <geekosaur> :t Data.Map.foldr
11:48:10 <lambdabot> (a -> b -> b) -> b -> M.Map k a -> b
11:48:14 <ski> Twey : possibly
11:48:16 <houshuang> so I thought I would replace "hi" with x (from the list), and that the accumulator would come last
11:48:30 <houshuang> but I'm not using Data.Map.foldr, I'm using Base.foldr, because I'm mapping over a list?
11:48:33 <geekosaur> compare type above with how you called foldr
11:48:43 <geekosaur> still the same problem
11:48:45 <geekosaur> :t foldr
11:48:46 <lambdabot> (a -> b -> b) -> b -> [a] -> b
11:48:55 <geekosaur> mapping function, initial value, list
11:49:12 <geekosaur> but you have M.empty *before* the mapping function
11:49:17 <houshuang> ahhh
11:49:27 <geekosaur> so it's complaining that M.empty is not the type of a mapping function
11:49:42 <mm_freak> the best part is:  wire serialization is actually very cheap…  only the moving parts are written, and you can selectively omit certain subwires from serialization (like particle effects in a game that you may not want to save)
11:49:43 <houshuang> geekosaur: Perfect.
11:50:07 <houshuang> geekosaur: Haha, I should have just tried I guess, but I would have never guessed that from the obscure (to me) type error...
11:51:11 <houshuang> geekosaur: Thanks a lot.
11:52:31 <roconnor> heh, building GHC takes a little longer than I expected.
11:52:54 <mm_freak> that's it for now…  happy weekend everybody =)
11:53:19 <roconnor> @tell haasn ICC profiles is beyond my knowledge. :(
11:53:19 <lambdabot> Consider it noted.
12:08:08 <__zeratul__> Hey, anyone here?
12:08:24 * haasn forgot what message he originally left for roconnor
12:09:04 <__zeratul__> Need some help setting up the Scotty web framework
12:09:52 <klrr> that's no qusetion ;)
12:10:14 <jle`> i wonder why the bot net isn't targeted #haskell yet
12:10:50 <jle`> __zeratul__: just ask your question :)
12:10:52 <jle`> for aiur
12:10:56 <__zeratul__> Well, this is more likely to be a problem with cabal
12:10:57 <klrr> __zeratul__: what you need help with? im not super experienced with scotty but could try to help
12:11:11 <__zeratul__> So I've got a basic scotty file, just using what's in their read me
12:11:22 <__zeratul__> When I try and run it I get "unable to load package `attoparsec-0.11.2.1'"
12:12:07 <__zeratul__> But if I run: cabal list --installed attoparsec
12:12:09 <__zeratul__> I see that I have it installed
12:12:25 <klrr> put attoparsec as a dependencyh in your *.cabal
12:13:01 <__zeratul__> Oh okay
12:13:39 <__zeratul__> Thanks
12:13:46 <klrr> to be precise: under build-depends:
12:13:48 <klrr> np!
12:14:22 <__zeratul__> Is there any other basic setup stuff I should know?
12:15:52 <klrr> __zeratul__: cabal sandboxes
12:15:54 <klrr> perhaps
12:16:00 <__zeratul__> What do you use for that
12:16:10 <klrr> first let me ask a qusetion
12:16:17 <klrr> is it first time you run cabal on your system?
12:16:38 <__zeratul__> I've been playing with haskell for a few days
12:16:51 <klrr> if so: you can continue without it, if you already installed some packages with it i suggest using sandboxes, read this http://coldwa.st/e/blog/2013-08-20-Cabal-sandbox.html
12:17:08 <klrr> it let you install libraries locally within the project
12:17:17 <__zeratul__> awesome
12:17:48 <__zeratul__> i was hoping there would be something good for this. I saw cabal-dev mentioned somewhere
12:18:03 <klrr> yeah cabal-dev is similar
12:19:21 <jle`> cabal-dev is nice, sandboxes are much trendier these days
12:19:32 <jle`> for most purposes you should be fine with sandboxes
12:20:26 <__zeratul__> great. thanks
12:20:50 <dmj`> is there a way to make this point free? "f v = modify $ \db -> db & versionsTo %~ S.insert v"
12:20:55 <dmj`> f v = modify $ \db -> db & versionsTo %~ S.insert v
12:21:43 <c_wraith> dmj`: there's always a way.  The question is if it's worth it. :)
12:22:02 <c_wraith> @pl f v = modify $ \db -> db & versionsTo %~ S.insert v
12:22:02 <lambdabot> (line 1, column 6):
12:22:02 <lambdabot> unexpected " "
12:22:02 <lambdabot> expecting operator
12:22:06 <dmj`> c_wraith: good point, lambdabot couldn't figure out :/
12:22:07 <ReinH> try over
12:22:16 <ReinH> instead of %~
12:22:35 <c_wraith> @pl \v -> modify $ \db -> db & versionsTo %~ S.insert v
12:22:35 <lambdabot> (line 1, column 40):
12:22:35 <lambdabot> unexpected "~"
12:22:35 <lambdabot> expecting white space or simple term
12:22:47 <c_wraith> huh.  lambdabot doesn't like ~ in operators, I guess
12:22:52 <dmj`> @pl addToVersion v = modify $ \db -> db & versionsTo `over` S.insert v
12:22:52 <lambdabot> addToVersion = modify . flip (over . (& versionsTo)) . S.insert
12:23:08 <dmj`> yea, not worth it :)
12:23:22 <artyomkazak> @pl addToVersion v = modify $ versionsTo `over` S.insert v
12:23:22 <lambdabot> addToVersion = modify . (versionsTo `over`) . S.insert
12:23:22 <supki> :t (%=)
12:23:23 <lambdabot> (Profunctor p, MonadState s m) => Setting p s s a b -> p a b -> m ()
12:24:02 <ReinH> dmj`: now switch & with $
12:24:40 <supki> @pl addToVersion v = versionsTo %= S.insert v
12:24:41 <lambdabot> addToVersion = (versionsTo %=) . S.insert
12:24:46 <ReinH> also (versionsTo `over`) = over versionsTo
12:25:31 <Twey> dmj`: f v = versionsTo %~ S.insert v
12:25:38 * hackagebot synthesizer-core 0.7.0.1 - Audio signal processing coded in Haskell: Low level part  http://hackage.haskell.org/package/synthesizer-core-0.7.0.1 (HenningThielemann)
12:25:58 <Twey> dmj`: f = over versionsTo . S.insert
12:26:11 <ReinH> if you define insertVersion v db it might help
12:26:15 <Twey> Oh, there was a lambda in there
12:26:19 <ReinH> seems like a reasonable thing to have anyway
12:26:26 <Twey> dmj`: f v = modify $ versionsTo %~ S.insert v
12:26:51 <doncaps> Hi, does anyone know of any companies in Houston/Dallas/remote that are looking for functional programmers? I've been searching but having a bit of trouble finding many. If this is not the right platform to ask this question, please tell me off.
12:26:54 <Twey> dmj`: f = modify . over versionsTo . S.insert
12:27:09 <ReinH> Twey: I thought it might be that
12:27:18 <ReinH> but converting to/from lens operators makes my head hurt
12:27:28 <ReinH> especially when you start using &
12:27:32 <Twey> ReinH: No conversion here :þ
12:27:38 <Twey> (&) = flip ($)
12:27:44 <ReinH> Twey: I know what it is :p
12:27:49 <Twey> So you can just leave it off
12:28:01 <ReinH> well ok. fine
12:28:03 <Twey> :þ
12:28:05 <dmj`> Twey, ReinH: thanks this is pretty awesome
12:28:13 <dmj`> really like supki's version addToVersion v = versionsTo %= S.insert v
12:28:35 <Twey> Yeah, the modify + over looks like it should be %=
12:28:55 <Twey> You can section that: addToVersion = (versionsTo %=) . S.insert
12:29:01 <Twey> If you're into that kind of thing
12:29:19 <ReinH> does %= have a non-operator version?
12:29:35 <Twey> Probably
12:30:03 <edwardk> addToVersion v = versionsTo.contains v %= True
12:30:07 <ReinH> Is lens still not indexed by hoogle? :/
12:30:28 <ReinH> edwardk: omg
12:30:42 <ReinH> lens is magic
12:30:44 <edwardk> contains can be written back to
12:30:47 <doncaps> Hi, does anyone know of any companies in Houston/Dallas/remote that are looking for functional programmers? I've been searching but having a bit of trouble finding many. If this is not the right platform to ask this question, please tell me off.
12:30:51 <Twey> ‘It puts the state in the monad or it gets the hose again’ — heh.
12:31:08 <edwardk> Twey: was in an odd mood that day
12:31:12 <Twey> doncaps: Try functionaljobs.com
12:31:12 <ReinH> edwardk: that particular kind of traversal (?) is amazing
12:31:20 <Twey> edwardk: Is that why you missed out the ‘else’?  :þ
12:31:43 <ReinH> Twey: which totally changes the meaning
12:31:46 <roconnor> surely addToVersion v = versionsTo.contains v .= True
12:31:50 <edwardk> oh did he say else?
12:31:50 <ReinH> maybe you put the state in the monad and also get the hose
12:31:54 <Twey> edwardk: He did
12:31:56 <edwardk> roconnor: yes
12:31:58 <Twey> Hehe
12:32:01 <edwardk> Twey: patch!
12:32:02 <Twey> ReinH: That's the worst
12:32:02 <roconnor> .~
12:32:04 <Twey> Haha
12:32:07 <ReinH> Twey: so unfair
12:34:55 <bitemyapp> ReinH: I liked the Yorgey chat. Would've liked more depth on the typeclassopedia and good library/API design.
12:35:18 <bitemyapp> ReinH: I just noticed the new one, mega-excited.
12:35:56 <bitemyapp> ReinH: thanks for doing Haskellcast :)
12:36:05 <ReinH> bitemyapp: <3
12:36:26 <ReinH> bitemyapp: I'm seriously working on an algebra-pedia
12:36:36 <bitemyapp> ReinH: that would be pretty cool.
12:36:54 <ReinH> I think monoids are just as useful as monads
12:37:07 <Twey> Algebra-pedia eh
12:37:11 <ReinH> maybe more
12:37:13 <ReinH> and of course monads ARE monoids so QED
12:37:14 <Twey> I think monoids are rather more useful than monoids
12:37:16 <Twey> Yeah
12:37:18 <bitemyapp> ReinH: I caught myself explaining to a friend last night when to use functions vs. typeclasses and ended up settling on, "if you don't have some kind of organizing laws or invariants, then it probably shouldn't be parametric"
12:37:19 <Twey> :þ
12:39:06 <ReinH> Twey: I also like explaining monoids as degenerate categories
12:39:55 <bitemyapp> yay video.
12:40:34 <haasn> ReinH: I like explaining categories are super-charged monoids
12:40:40 <ReinH> haasn: that too :)
12:41:06 <ReinH> haasn: e.g. the matrix monoid is a nice introduction to categories
12:41:18 <Cale> I like explaining categories are super-charged preorders.
12:41:27 <Cale> ;)
12:41:32 <ReinH> Cale: go on...
12:41:33 <Twey> ReinH: I'm with haasn on that
12:41:40 <Cale> ReinH: Oh, you haven't seen that yet? :)
12:41:41 <ReinH> Twey: yes what he said is what I meant :)
12:41:46 <Twey> Oh, okay
12:41:48 <ReinH> Cale: nope!
12:41:56 <Cale> Usually that happens at the same time as the explanation about the connection to monoids
12:42:25 <Twey> Cale: Not if you're coming via programming languages
12:42:35 <Twey> Unless you skipped straight to subtyping
12:42:43 <Cale> So, given a set S, a preorder <= on S is a relation which is 1) reflexive: for any a in S, we have a <= a, and 2) transitive: for any a, b, c in S, if a <= b and b <= c, then a <= c.
12:43:39 <ReinH> Cale: right, but not necessarily symmetric
12:43:43 <Cale> (note that cycles are allowed, you can have both a <= b and b <= a without a and b being equal. If a <= b and b <= a implies that a = b, we call <= a partial order)
12:44:03 <ReinH> a preorder + symmetry is a partial order?
12:44:05 <Cale> and not necessarily antisymmetric either
12:44:10 <ReinH> right
12:44:15 <ReinH> ok
12:44:19 <bitemyapp> ReinH: this is a fun Haskellcast so far! Informative too :)
12:44:23 <ReinH> bitemyapp: yay!
12:44:26 <Cale> If it's symmetric, it's called an equivalence relation
12:44:30 <ReinH> bitemyapp: we had a lot of fun recording it
12:44:35 <ReinH> oh right
12:44:35 <Cale> If it's antisymmetric, it's a partial order
12:44:39 <ReinH> riiight
12:44:49 <ReinH> Cale: ok with you now
12:45:26 <Cale> Okay, so given any preorder (S, <=), we can define a category whose objects are the elements of S, and where there is a single arrow a -> b whenever a <= b, and no arrows otherwise.
12:45:43 * hackagebot ixmonad 0.30 - Indexed monads library  http://hackage.haskell.org/package/ixmonad-0.30 (DominicOrchard)
12:46:02 <ReinH> Cale: so a preorder is "a set equipped with a reflexive, transitive binary operator"
12:46:07 <Cale> The fact that <= is reflexive means that we end up with an arrow id_a : a -> a, since a <= a
12:46:16 <ReinH> s/binary operator/relation
12:46:16 <Cale> s/operator/relation/
12:46:21 <Cale> yea
12:46:39 * ski prefers using either `=<' or ⌜≤⌝ for the ordering
12:46:40 <ReinH> Cale: also the other day I learned that "an S equipped with an X" literally just means (S, X) ;)
12:46:50 <Cale> The fact that <= is transitive means that we have an arrow appropriate to define as the composition
12:47:38 <ReinH> Cale: ok I'm with you
12:47:44 <Cale> i.e. if we have an arrow a -> b and an arrow b -> c (there will only be one such arrow when they exist), then we know that a <= b and b <= c, so we know that a <= c, and so there will be an arrow a -> c
12:48:01 <Cale> and we can define that to be the composite of our two given arrows
12:48:09 <ReinH> yup
12:48:38 <ski> Cale : i suppose one might say categories are `Set'-valued preorders ? :)
12:48:39 <Cale> and the equational laws all hold (identity, associativity) because of the uniqueness -- there's at most one arrow between any two objects here
12:49:24 <Cale> Conversely, if we have a small category for which there is at most one arrow between any two objects, we get a preorder by defining a <= b whenever there is an arrow a -> b
12:49:36 <roconnor> ski: after learning all this, I am of the opinion that pre-order enriched categories are more important than normal categories.
12:49:43 <ReinH> Cale: Ok, so testing my intuition, there's a relationship here from preorders to digraphs and from digraphs to categories, right? A free category is a digraph, right?
12:50:03 <ski> roconnor : allegories ?
12:50:13 <Cale> ReinH: A free category is built on a digraph by adding lots of arrows to it, in general.
12:50:16 <roconnor> ski: is that what they are?
12:50:19 <ReinH> Cale: ok
12:50:41 <Cale> (i.e. by throwing in an additional arrow for every sequence of composable arrows in the digraph)
12:50:50 <ReinH> right
12:50:55 <ski> roconnor : <http://en.wikipedia.org/wiki/Allegory_(category_theory)>
12:50:55 <ReinH> cool
12:51:23 <ski> Cale : why digraph ?
12:51:41 <ReinH> ski: er, because arrows have directionality?
12:52:28 <ski> ReinH : oh .. i was thinking about "bipartite graph", apparently
12:52:34 <Cale> Well, people usually just say "graph" in this context, but the graphs involved are directed...
12:53:32 <ski> roconnor : "pre-order enriched" means each `Hom'-set is equipped with a preorder (playing nice with composition) ?
12:55:55 <roconnor> ski: let's say yes.
12:56:28 <roconnor> ski: I object a little to the term `Hom'-set since a set ought to be a pre-order that is symmetric :D
12:57:33 <ski> hm, is that relating to discreteness, somehow ?
12:58:46 <roconnor> ski: I think so ... somehow.
13:00:46 * hackagebot synthesizer-core 0.7.0.2 - Audio signal processing coded in Haskell: Low level part  http://hackage.haskell.org/package/synthesizer-core-0.7.0.2 (HenningThielemann)
13:05:34 <ski> roconnor : it being symmetric seems to be related to a partition, no ?
13:05:43 <ski> roconnor : or maybe a multi-set / bag
13:05:47 * hackagebot yesod-markdown 0.8.4 - Tools for using markdown in a yesod application  http://hackage.haskell.org/package/yesod-markdown-0.8.4 (PatrickBrisbin)
13:06:22 <roconnor> ski: a type with an equivalence relation; a setoid.
13:07:02 <ski> hm, i suppose
13:07:17 <ski> roconnor : so, without symmetry, how would the ordering be interpreted ?
13:07:57 <ski> roconnor : .. in some cases, i think it makes more sense to have an ordering as basic concept, rather than an equality / equivalence relation
13:09:19 <ski> roconnor : maybe you're thinking about some kind of definiteness/information ordering, as in domains. or maybe in terms of reduction (like equalities for lambda-calculus, turned one-directional)
13:09:39 <roconnor> ski: yes, I think ordering is the basic concept.
13:10:13 <ski> roconnor : anyway. take e.g. degree of polynomial, which i think can be defined in terms of ordering as the basic concept, and then equality as derived
13:10:39 <ReinH> ski: your face is derived
13:10:45 <ReinH> I'm really elevating the discourse here
13:10:46 <roconnor> ski: and yes, my prime example of ordering is beta / eta ordering.
13:11:04 <ski> also, if ordering is basic. what corresponds to extensionality of functions ?
13:11:27 <roconnor> ski: a preoder is is simply a (unit-enriched category)-enriched category. :)
13:12:16 <roconnor> ski: I'm not certain where extentionality of functions fits in.
13:12:51 <roconnor> so many libraries to build with GHC.
13:13:04 <bitemyapp> ReinH: at 32:00, what's the library Snoyman names that uses lazy IO?
13:13:14 <ski> roconnor : augur_ mentioned <http://en.wikipedia.org/wiki/Pregroup_grammar> to me a while ago. i had been thinking about something similar, but where also the basic monoid structure is directed : `1 * x =< x =< x * 1' and `(x * y) * z =< x * (y * z)' -- both these feel "reduction"-like to me
13:14:17 <ski> roconnor : well, we generally want a function to respect equality : `forall x,y. x = y => f x = f y'. so for ordering we could get monotonicity `forall x,y. x =< y => f x =< f y'
13:14:29 <ski> though we probably also want antitonicity as an alternative
13:15:02 <ski> and i think if we go to binary relations, there may be more alternatives of "reasonable" assumptions, relating to the order
13:15:16 <roconnor> ski: montonicity implies that it respects equivalence.
13:15:29 <ski> yes
13:16:02 <ReinH> bitemyapp: foldl?
13:16:04 <ReinH> @hackage foldl
13:16:05 <lambdabot> http://hackage.haskell.org/package/foldl
13:16:09 <ski> roconnor : also, if you use beta-reduction, do you pair it with eta-reduction or eta-expansion ?
13:16:10 <ReinH> bitemyapp: oh lazy IO, not that
13:16:14 <ski> (i assume the latteR)
13:16:16 <ReinH> bitemyapp: which one?
13:17:29 <roconnor> ski: eta long is the same direction as beta short.
13:18:19 <bitemyapp> ReinH: that's the problem, I couldn't understand him. (I'm a little hard of hearing and it's a recording)
13:18:30 <bitemyapp> I'll replay it when I'm done with the video to see if I can understand it.
13:18:51 <roconnor> making eta-long beta-short an extreme value
13:19:32 <ReinH> bitemyapp: ok let me see
13:22:23 <ReinH> bitemyapp: I'm not sure :(
13:23:49 <bitemyapp> ReinH: nuts. Ping him maybe?
13:24:05 <roconnor> f => \x. f x => \x. (\x. f x) x => \x. f x
13:24:29 <ski> roconnor : anyway, i think that Pregroup grammar is probably in some way related to ordered logic
13:25:00 <ski> roconnor : why the extra steps ?
13:25:40 <roconnor> ski: not steps.  just true statements
13:25:42 <isaacbw> does haskell have anything like python's virtualenv?
13:26:01 <Twey> isaacbw: Cabal has sandboxes now
13:26:14 <isaacbw> ah, nice
13:26:23 <geekosaur> isaacbw, the literal answer to your question is hsenv, but it virtualizes an entire installation
13:26:45 <ski> roconnor : s/=>/=</ ?
13:27:10 <isaacbw> ah, it's a very new feature
13:27:53 <roconnor> ski: i'm not sure which direction it needs to be or if it makes a difference.
13:28:00 <ReinH> bitemyapp: will do
13:28:09 <__zeratul__> Can anyone tell me what this means: "lookupSymbol failed in relocateSection (relocate external)"
13:28:27 <__zeratul__> I'm trying to get Scotty working. I also get "unable to load package `attoparsec-0.11.2.1'"
13:28:53 <ski> roconnor : you can sortof think of a computation as starting from `_|_', then (possibly) using `=<' to trickle up to more information, in terms of domains
13:28:55 <isaacbw> hmm, so you have to check in .cabal-sandbox?
13:28:59 <isaacbw> would be nice if it was created automatically
13:29:09 <isaacbw> assuming you have a cabal.sandbox.config
13:29:11 <ski> roconnor : `_|_' meaning "nothing known (yet)" about the datum
13:29:20 <pavonia> __zeratul__: Is that a GHC panic?
13:29:21 <__zeratul__> I'm using cabal sandbox, and I have a config
13:29:23 <ReinH> ski: something something lattice?
13:29:24 <roconnor> ski: my PO is on terms, rather than values in a domian.
13:29:32 <meiji11> I'm writing some code for a toy language interpreter using type families, and I'm wondering why the final line of code causes a compiler error: http://lpaste.net/101207
13:29:32 <__zeratul__> and I have scotty in my build-depends
13:29:35 <isaacbw> s/check in/check in to source control
13:29:40 <isaacbw> *version
13:29:57 <meiji11> well, GHC is telling me, of course, but I don't understand why it can't infer the proper type.
13:30:03 <ski> roconnor : yes, but i think there's some kind of analogy
13:30:35 <ski> ReinH : anything something lettuce ?
13:30:40 <__zeratul__> pavonia: I'm not sure. Here's the full error: http://lpaste.net/101209
13:30:48 <pavonia> meiji11: What error do yu get?
13:30:52 <pavonia> *you
13:31:15 <meiji11> pavonia: 'Couldn't match 'KLFunction a' with 'KLFunction a0''
13:31:27 <roconnor> ski: it would seem that terms and domains are not nearly as releated to each other as I had hoped.
13:31:41 <meiji11> I get that this is probably an injectivity problem, but I don't want to use data families.
13:31:44 <meiji11> is there some other recourse?
13:31:55 <roconnor> ski: at least that is what my "seq that respects functions that return bottom" investigation has revealed to me.
13:33:18 <ski> roconnor : i'd be interested in hearing about that, if you'd care to explain it, or write it up in some form
13:34:39 <roconnor> ski: it's hard to write up, because it is incomplete.
13:34:48 * ski nods
13:35:14 <meiji11> given the quantification on Partial, I just don't see why it should be a problem.
13:35:20 <roconnor> ski: http://cstheory.stackexchange.com/questions/1916
13:35:28 * ski sometimes tries explaining stuff on IRC, to get a better grip on what's missing
13:35:41 <roconnor> ski: http://cstheory.stackexchange.com/questions/19165
13:36:18 <roconnor> ski: I beleive one can implement seq (ineffencity) such that it cannot discriminate (const undefined) from undefined.
13:36:40 <arboris> what is a good way to implement something like the observer pattern? I came up with http://lpaste.net/101210 but as soon as I do any rendering there is noticable lag in the console output
13:36:48 <roconnor> ski: I had a more efficent plan that I could use head normal form reduction to implement an efficent versions of this modifed seq.
13:36:56 <roconnor> ski: but that turns out not to work.
13:37:09 <roconnor> ski: And I see no "term" directed way of implementing it.
13:37:40 <roconnor> ski: It seems one has to do the "domain" way which is to run the function on every compact input to see if it ever terminates.
13:39:21 <ski> roconnor : with Escardó-tricks ?
13:41:34 <roconnor> ski: no
13:41:41 <arboris> the example code for glfw-b uses TQueues for event handling, but that does not really admit dynamic addition of "listeners" as far as I can tell
13:42:11 <roconnor> ski: if I spend forever searching for an input that terminates, that's the same as returning bottom, which is the "correct" answer for seq (const undefined)
13:43:00 <roconnor> ski: the closest thing to a trick is that if any input cause f to make progress, then there is a compact input (ie finite input) that causes f to make progress.
13:43:40 <arboris> i am not sure if one can dynamically add sinks in any of the reactive programming libraries
13:44:32 <ski> roconnor : hm, but you'll want `por' in case some of the inputs terminate ?
13:45:40 <ski> roconnor : i'm also reminded of Brouwer's Bar recursion and Fan theorem, and his continuity principles
13:46:30 <roconnor> ski: I think `por` is not related to seq ... though I have plans for `por` as well.
13:47:03 <roconnor> ski: all seq does is semi-decide if a value is non-bottom or not.
13:47:15 <roconnor> ski: the actual non-bottom value is irrelevent.
13:47:32 <roconnor> clearly we should toss away that work. :D
13:48:47 <ski> roconnor : say the type is `Bool -> Sierpinski'; given `f' of that type, don't you want to compute `por (f False) (f True)' more or less ?
13:49:03 <ski> so that if any of those terminate, your `seq' terminates
13:49:16 <roconnor> ski: yes, that is true.
13:49:27 <roconnor> ski: but you don't need to "unify" the results a la lub.
13:49:49 * ski nods
13:50:05 <ski> (i suppose one could say it's a particular trivial kind of unification)
13:50:17 <roconnor> ski: my plan for `por` is to implement (luke's?) ultra-lazy language.
13:50:31 <ski> roconnor : not sure i've heard about that one
13:50:39 <roconnor> where branches of a case statement begin evaluation before the term being analyized gets into HNF.
13:51:01 * hackagebot yesod-dsl 0.1.1.12 - DSL for generating Yesod subsite to manage an RDBMS;  http://hackage.haskell.org/package/yesod-dsl-0.1.1.12 (TeroLaitinen)
13:51:24 <ski> hm, ok
13:51:25 <roconnor> if all branches of a case statement return the same constructor then that constructor is made available, even if the term being analyzed hasn't finished normalization.
13:51:42 <roconnor> (or even if the term being analyzed is undefined)
13:51:58 <ski> i wonder whether that's related to some more powerful-looking versions of eta, mentioned by Bart Jacobs
13:52:27 <roconnor> ski: commutativity?
13:52:42 <ski> not sure how commutativity would enter the picture
13:54:04 <roconnor> ski: it means that (if b then f x else f y) is actually equal to f (if b then x else y).
13:54:20 <roconnor> (I think)
13:55:20 <isaacbw> do I need to do anything special with cabal sandboxes for the libraries to be found by ghc? I installed happstack but it isn't being found when I run ghc
13:55:52 <MagneticDuck> isaacbw: pretty sure the point of sandboxes is to make a seperate context from the rest of the machine
13:55:54 <MagneticDuck> so, yeah
13:56:02 * hackagebot yesod-dsl 0.1.1.13 - DSL for generating Yesod subsite to manage an RDBMS;  http://hackage.haskell.org/package/yesod-dsl-0.1.1.13 (TeroLaitinen)
13:56:02 <MagneticDuck> (I think)
13:56:04 * hackagebot yesod-dsl 0.1.1.14 - DSL for generating Yesod subsite to manage an RDBMS;  http://hackage.haskell.org/package/yesod-dsl-0.1.1.14 (TeroLaitinen)
13:56:10 <isaacbw> MagneticDuck: well, I running ghc from within the sandboxed directory
13:56:13 <isaacbw> *I'm
13:56:15 <MagneticDuck> two versions in one lol
13:56:17 <ski> beta for ⌜+⌝ is ⌜case ι₀ M₀ of ι₀ x₀ ↦ N₀ | ι₁ x₁ ↦ N₁  ⇝  N₀[x₀ ↦ M₀]⌝ , and similarly for the other branch
13:56:26 <MagneticDuck> isaacbw: yeah
13:57:01 <ski> eta for ⌜+⌝ is ⌜case M of ι₀ x₀ ↦ ι₀ x₀ | ι₁ x₁ ↦ ι₁ x₁  ⇝  M⌝
13:57:04 <ski> roconnor : yes ?
13:57:08 <isaacbw> am I missing somthing?
13:57:16 <isaacbw> oh
13:57:21 <isaacbw> cabal build?
13:58:45 <ski> roconnor : the more general eta i saw was ⌜case M of ι₀ x₀ ↦ N[x ↦ ι₀ x₀] | ι₁ x₁ ↦ N[x ↦ ι₁ x₁]  ⇝  N[x ↦ M]⌝, iirc
13:58:59 <byorgey> isaacbw: ghc doesn't look for cabal sandboxes.
13:59:56 <byorgey> isaacbw: there is a command-line flag you can pass to ghc to tell it to look in some particular place for the package database (I don't remember what it is)
14:00:06 <ReinH> byorgey: hai
14:00:16 <byorgey> but if you want to install packages in a sandbox and then run ghc and have it look at those packages, I suggest using hsenv
14:00:24 <byorgey> hi ReinH
14:01:03 * hackagebot yesod-dsl 0.1.1.15 - DSL for generating Yesod subsite to manage an RDBMS;  http://hackage.haskell.org/package/yesod-dsl-0.1.1.15 (TeroLaitinen)
14:01:11 <ofan> is hsenv compatible with cabal-sandbox?
14:01:16 <roconnor> ski: sounds right.
14:01:47 <roconnor> ski: I think that general eta law implies my if statement law where f plays the role of N.
14:01:58 <roconnor> ski: though the general eta law is more general.
14:02:07 <byorgey> ofan: not really
14:02:44 <ski> roconnor : ok
14:06:54 <xico> hi. im trying to build a c++ executable from cabal, so i put a single "main-is: mysource.cc" in an executable section, but cabal build fails with "ghc: no input file". any idea what may be going wrong? (seems my mysource.cc is never showing up in --verbose=3)
14:07:50 <Eduard_Munteanu> Is there a convention for naming Haskell includes in the CPP sense?
14:08:02 <Eduard_Munteanu> I mean filename-wise.
14:08:49 <geekosaur> main-is only works with Haskell source, it tells ghc which Haskell module and/or function should be the entry point. if you are using C / C++ then you must handle that yourself by how you call into Haskell
14:10:59 <xico> geekosaur: i thought it was fixed
14:11:06 <geekosaur> huh?
14:11:19 <JagaJaga> Hello! Am i right, that bytestring works wrong with unicode?
14:11:37 <xico> geekosaur: by https://github.com/haskell/cabal/pull/1080 and https://github.com/haskell/cabal/issues/497
14:11:43 <Eduard_Munteanu> JagaJaga: bytestring and unicode are orthogonal things
14:12:22 <Eduard_Munteanu> JagaJaga: Unicode has more of a relationship with String or Text
14:12:54 <JagaJaga> Eduard_Munteanu, oh :( Sow how to send request with unicode symbols? I meah http requests..
14:13:39 <Eduard_Munteanu> JagaJaga: likely depends on the library in question, but if you have to provide a bytestring then you'll likely want to use Data.Text.Encoding
14:13:40 <jrmithdobbs> unicode isn't valid in all parts of a uri depending ...
14:14:06 <geekosaur> interesting
14:14:13 <jrmithdobbs> but, eg, conduit-http and such provide helpers that do the legwork for you
14:14:26 <jrmithdobbs> err conduit-http w/e
14:14:26 <JagaJaga> Eduard_Munteanu, jrmithdobbs, got it, thx
14:14:49 <isaacbw> hmm, is there a way to use emacs' inferior process but open a cabal repl instead of ghci?
14:15:05 <Eduard_Munteanu> JagaJaga: the idea is ByteString represents a raw stream of data, not text. So a ByteString can relay *encoded* text, not Unicode codepoints.
14:15:23 <JagaJaga> Eduard_Munteanu, yeah, that's what I got ^)
14:16:40 <Eduard_Munteanu> (And that's valuable on its own when dealing with arbitrarily-encoded text, it doesn't mean "bytestrings are bad at unicode".)
14:17:33 <JagaJaga> Eduard_Munteanu, thx a lot. Now I know what r they. Because I thought.. smth strange
14:25:27 <jrmithdobbs> Eduard_Munteanu: if anything it means bytestrings are GREAT at unicode because they completely (and proprely) ignoring their encoding ;p
14:25:46 <Eduard_Munteanu> Indeed. :)
14:26:28 <plookn> (Newb question) Could someone explain why haskell type declaration for functions is formatted as (arg1 -> arg2 -> result) instead of something cleaner, like ((arg1, arg2) -> result)?
14:26:33 * jrmithdobbs *wc() shivers
14:26:42 * jrmithdobbs *wc(3) shivers
14:27:43 <Eduard_Munteanu> plookn: because that form, the curried form, allows partial application for one thing
14:27:47 <Twey> plookn: (arg1, arg2) -> result is also valid syntax, but means something different
14:28:40 <jrmithdobbs> plookn: because when they're all defined consistantly you don't end up with a mess like the syntax for c++ templates/java (all of java, really)
14:28:42 <Twey> plookn: A function  A → B → C  is equivalent to a function  (A, B) → C  — when you're generating the result C, you have access to both the A and the B, in both cases
14:28:56 <plookn> Eduard_Munteanu: ooh good point
14:29:06 <plookn> Twey: forgot about that
14:29:42 <Twey> plookn: The difference is that in the latter (‘uncurried’) case the (A, B) argument has to be provided all at once, whereas the ‘curried’ case allows arguments to be passed one at a time (partial application)
14:29:46 <plookn> jrmithdobbs: what do you mean?
14:30:10 <jrmithdobbs> plookn: the syntax makes sense when you start looking at more complex instead of extremely simple cases
14:30:41 <Twey> plookn: It so happens that if you design your syntax carefully you also get a nice syntax out of it, i.e. you don't have to have a special syntax (often involving commas…) for multi-argument functions — calling a multi-argument function is just repeatedly calling a single-argument function
14:30:57 <Eduard_Munteanu> plookn: it's also nicer because it gives you a unified approach to multiple arguments, instead of relying on n-ary tuples which are all different from each other
14:31:02 <plookn> that makes sense. what happens if it return a function? e.g. a->b->(a->c) ?
14:31:21 <Twey> plookn: You're *always* returning a function.  The brackets are redundant.
14:31:28 <Eduard_Munteanu> plookn: it's the same thing... a -> b -> c  is  a -> (b -> c)  by definition.
14:31:31 <jrmithdobbs> plookn: eg think about how to express this in a c++ template and try and write it out: (Functor m,Applicative m,Monad m) => m a -> m b -> m c;
14:32:10 <plookn> riiiight, i get it. thanks y'all
14:34:29 <plookn> another question, which i know is a bit sensitive.. why doesn't haskell use lisp-y syntax? i.e. what's wrong with lisps?
14:34:43 <jrmithdobbs> what's wrong with haskells?
14:34:52 <jrmithdobbs> (is the obvious response)
14:34:58 <Eduard_Munteanu> plookn: Lisp is rather syntax-less
14:35:12 <jrmithdobbs> i love lisp/scheme the language but it's syntax is enraging
14:35:35 <jrmithdobbs> no one should ever have to line up 20 sets of nested parens
14:35:39 <plookn> well lisp seems great because programs are all data structures, and it has introspective benefits right?
14:35:50 <bitemyapp> plookn: types are better.
14:36:00 <bitemyapp> and more meaningful.
14:36:00 <cdh473> jrmithdobbs: wot?
14:36:12 <cdh473> sure types are great but your editor should do your parens for you
14:36:13 <Eduard_Munteanu> plookn: also I'm not sure how one would get a reasonable way to abstract Haskell declarations using Lisp syntax.
14:36:18 <plookn> jrmithdobbs: from my experience with clojure, parenmatching hasn't been an issue if the language is designed well
14:36:21 <jrmithdobbs> cdh473: it shouldn't have to
14:36:24 <Twey> template <template<typename> typename m, typename a, typename b, typename c> std::enable_if<is_functor<m>::value && is_applicative<m>::value && is_monad<m>::value, m<c>> then(m<a> ma, m<b> mb) { … }
14:36:36 <cdh473> jrmithdobbs: lisp is not a language you write without an editor
14:36:42 <cdh473> a specialized editor*
14:36:48 <jrmithdobbs> cdh473: i'm just saying, i'd ask the opposite, why isn't lisp's syntax more layout based like haskell
14:36:48 <bitemyapp> I was fine with Clojure's syntax. I don't really like talking about syntax. It's tedious, petty, and besides the point.
14:36:50 <plookn> true
14:37:06 <cdh473> jrmithdobbs: because the whole point of lisp is its syntax
14:37:11 <Twey> cdh473: I'm not sure I trust this argument
14:37:19 <jrmithdobbs> cdh473: i was pointing out the invalidity of the question and illustrated it with my personal dislike of that aspect of lisp
14:37:25 <ski> jrmithdobbs : how would you encode stuff like `(((foo bar) baz (quux blargh)) frob)' using layout ?
14:37:28 <cdh473> oi
14:37:30 <cdh473> i missed the question
14:37:31 <isaacbw> my favorite thing about lisp is structured editing
14:37:33 <cdh473> i apologize
14:37:39 <Twey> cdh473: It sounds too much like ‘who cares if you have to write two hundred lines of setters and getters for your class?  Your IDE will generate them for you’
14:37:47 <cdh473> Twey: lolno
14:37:50 <cdh473> you don't have to do that
14:37:52 <jrmithdobbs> ski: foo bar $ baz $ quux blargh $ frob
14:37:59 <cdh473> or anything of the sort
14:38:07 <cdh473> it's just parens
14:38:17 <cdh473> it's more like autocompletion
14:38:18 <ski> jrmithdobbs : that's ambiguous
14:38:27 <cdh473> or normal paren matching completion
14:38:40 <Twey> While I recognize the quantitative difference, they seem like qualitatively similar arguments, so I get scared.
14:38:41 <jrmithdobbs> Twey: yes exactly that. That's exactly my feeling about lisps' (lack of) syntax. That is a copout;p
14:38:42 <ski> jrmithdobbs : that might possibly mean `((foo bar) (baz) (quux blargh) (frob))'
14:38:46 <cdh473> yeah yeah
14:38:55 <Eduard_Munteanu> plookn: another issue is syntax is nice to have, comparing Haskell and Agda to ML and Coq (which also have syntax yet more "traditional")
14:39:10 <jrmithdobbs> ski: it doesn't if you're following haskell's rules
14:39:11 <ski> jrmithdobbs : "SRFI 49: Indentation-sensitive syntax" <http://srfi.schemers.org/srfi-49/srfi-49.html> has been attempted. people tend not to like it
14:39:26 <cdh473> lisp's little-syntax and haskell's syntax have their own advantages and disadvantages
14:39:27 <ski> jrmithdobbs : Lisp is about nested multi-way trees
14:39:34 <ski> jrmithdobbs : .. or rather, sexps are
14:39:42 <cdh473> it's not meant to serve the same purpose
14:39:53 <Twey> I've always preferred concatenative notation anyway
14:39:56 <jrmithdobbs> i like how saying you don't like X about lisp obviously means you don't understand lisp
14:40:05 <ski> jrmithdobbs : if you're going to device a new concrete syntax for sexps, you should be able to distinguish all the things it distiguishes
14:40:15 <Twey> The only thing the Lisp syntax gives you extra is variadic functions, which I'm not sure are worth all that explicit bracketing
14:40:16 <jrmithdobbs> ski: i know. i get it. I still don't like the () clusterfuck, sorry, you're not changing my mind
14:40:21 <cdh473> jrit usually is the case
14:40:26 <cdh473> oops
14:40:30 <bitemyapp> can we talk about something actually interesting?
14:40:33 <cdh473> jrmithdobbs: ^^
14:40:35 <bitemyapp> like the TypeFamilies abuse thread on haskell-cafe?
14:40:50 <cdh473> and also pretty printing eliminates literally every issue with readability
14:41:01 <cdh473> virtually*
14:41:01 <jrmithdobbs> Twey: they're nifty, but I agree and think they aren't
14:41:34 <Twey> And you can always use some kind of list to get the advantages anyway
14:41:44 <Twey> Or even choose other data structures, like a multiset
14:41:49 <Eduard_Munteanu> The nice thing about Lisp's is simplicity. It would be interesting to use the actual Lisp syntax as an AST and compile to it from a higher-level, more styled syntax.
14:42:04 <Twey> Eduard_Munteanu: Isn't that what we do?
14:42:10 <ski> Twey : it also makes it easier to do meta-programming
14:42:10 <cdh473> ya ya ya
14:42:25 <Eduard_Munteanu> Twey: what are you referring to?
14:42:58 <Twey> ski: Does it?  I'm not sure why sexprs would make metaprogramming easier  than RPN
14:43:03 <Twey> (in the presence of types)
14:43:11 <ski> "RPN" ?
14:43:23 <Twey> Eduard_Munteanu: The AST of e.g. Haskell looks a lot like a Lisp program already
14:43:31 <jrmithdobbs> Twey: or a recursive free monad that you can apply multiple different f-algs to ... so much better than variadic functions any how ;p
14:43:52 <Eduard_Munteanu> There are mechanism's like Agda's to define extra syntax in the language though arguably not to define *all* syntax.
14:44:03 <Twey> ski: I was comparing sexprs to concatenative syntaxes like FORTH's or Factor's
14:44:10 <ski> Eduard_Munteanu : yes, binders are missing
14:44:26 <Twey> How does Agda's syntax construct work?
14:44:27 <Eduard_Munteanu> ski: Agda's 'syntax' construct has binders
14:44:34 <Twey> I've used it, but I don't really understand it.
14:44:42 <ski> Eduard_Munteanu : ok, haven't seen that
14:44:47 <Twey> I think there's some kind of binding going on
14:45:07 <Twey> syntax Σ-syntax A (λ x → B) = Σ[ x ∈ A ] B
14:45:17 <jrmithdobbs> i'm not a huge fan of rebinding syntax, i think LUA takes the right approach re: lang extension in 5.1+ .. simple language constructs that are powerful enough that you never think about extending the language syntax itself
14:45:19 <Twey> x is bound, somehow
14:45:39 <Twey> Also A and B
14:45:49 <Eduard_Munteanu> You can define do-notation in it as well.
14:45:57 <Twey> Eduard_Munteanu: But how does it work?
14:47:07 <Eduard_Munteanu> Twey: it does binding... syntax Σ-syntax A (λ x → B) means "bind x to A in B, as arguments to Σ-syntax"
14:47:08 <ski> Twey : have you seen "Macros as Multi-Stage Computations: Type-Safe, Generative, Binding Macros in MacroML" by Steve Ganz,Amr Sabry,Walid Taha in 2001 at <http://www.cs.indiana.edu/~sabry/papers/macroml.ps> ?
14:47:19 <Twey> Oh, does it match the RHS, binding alphabetical identifiers to subexpressions, then construct the LHS with them in scope?
14:47:29 <Twey> Eduard_Munteanu: How does it know which parts are variables?
14:47:32 <Eduard_Munteanu> Twey: yes
14:47:40 <Twey> It's syntactic?  Okay
14:47:55 <napping> It's a bit more behaved than a general syntax extension, I think
14:48:11 <Twey> I think I was confused by the use of the ‘Σ-syntax’ definition
14:48:13 <Eduard_Munteanu> Twey: it has a few rules like holes and non-holes must alternate and the patterns must be linear
14:48:19 <napping> AFAIK, the RHS is parsed just like any other mixfix operator, except some of the things end up being treated as binders rather than expressions
14:48:48 <Twey> Eduard_Munteanu: Aha
14:49:00 <ski> napping : can you use more complicated patterns that mere variables in place of `x', in a use of it ?
14:49:04 <napping> you can define things like "if_then_else_" as perfectly ordinary functions in agda
14:49:31 <napping> I know I've tried it, but all I remember is that what was implemented didn't really match what was on the wiki
14:49:34 <ski> s/that/than/
14:49:38 <Twey> Agda's syntax is cool, but also rather scary.
14:49:41 <Eduard_Munteanu> Twey: when it parses "Σ[ x ∈ A ] B", it breaks it into "Σ[", "x", "∈", "A", "]", "B" and the variables are things mentioned in the LHS
14:49:52 <napping> You can't use very complicated patterns in lambdas anyway in Agda
14:50:01 <ski> which is a shame
14:50:11 <napping> maybe you can destructure the only constructor of a single-constructor data type, or open records
14:50:30 <ski> i think you can do `\ ()', at least
14:50:31 <napping> also not sure if you can squeeze in a binder-style type annotation
14:50:38 <Twey> Eduard_Munteanu: Ah, right
14:50:46 <Eduard_Munteanu> napping: x : A? Yes, it's in the stdlib.
14:50:47 <napping> Yeah, I guess that's morally the same
14:51:00 <napping> Eduard_Munteanu: in a syntax definition, though
14:51:24 <napping> Σ[ (x : Bool) ∈ A ] B
14:51:53 <napping> oops, guess I don't have agda-mode installed at the moment
14:51:56 <Eduard_Munteanu> napping: yes, you can, the actual sigma is more like Σ (x : A) B
14:52:23 <napping> I was trying out the stuff from http://tim.dysinger.net/posts/2014-02-18-haskell-with-emacs.html which worked pretty nicely once I remembered to actually install the Haskell bits
14:53:06 <Twey> ski: I think I saw something similar, a dependent code-generation paper
14:53:36 <Twey> napping: Don't know how you can not have agda-mode installed :þ  I use that thing *everywhere*.
14:53:57 <napping> Anyway, I think the Agda "syntax extension" system is morally closer to a language with non-extensible syntax except you can declare functions some of whose arguments are patterns to be bound in others
14:53:57 <ski> Twey : the input-mode ?
14:54:13 <Twey> ski: Yes
14:54:19 <Eduard_Munteanu> napping: it seems they changed the stdlib definition, but here it was: https://github.com/agda/agda-stdlib/commit/70a2bf4dd793b12534512aa3934ae270104f9cff
14:54:36 <Twey> ski: Is a multi-stage language like Meta/MacroML equivalent to tactics in Agda or Coq?
14:54:37 <napping> Twey: I usually do, but Tim Dysinger's instructions suggest backing up and moving aside your .emacs before that huge list of extensions
14:55:13 <Eduard_Munteanu> Twey: Agda has some tactics-like stuff, btw
14:55:45 <ski> Twey : i don't know about tactics, but i suspect the answer might be "no"
14:55:50 <Twey> ski: My compose key doesn't work in emacs unless I unset XMODIFIERS before starting the daemon, which I inevitably forget to do almost every session
14:56:08 <Twey> Eduard_Munteanu: Really‽
14:56:17 <Eduard_Munteanu> Actually they are tactics, they're just way more rare than in Coq.
14:57:43 <Eduard_Munteanu> Twey: it has reflection a-la TH, so they're simply functions that take a quotation of the goal and produce a term, which in turn is typechecked.
14:57:48 <ski> Twey : MetaML has quasiquotations and unquotations, which work like in the Lisps, only better (also supporting Cross-Stage Persistence, which might or might not be desirable)
14:59:02 <Eduard_Munteanu> Twey: the stdlib has the ring solver for example, and a few other people have been working on tactical stuff outside the stdlib
14:59:35 <ski> Twey : e.g. `<fn x => ~((fn true => <x> | false => <0>) (2 =< 3))>' evaluates to `<fn x => x>' -- so in some sense, you have "evaluation-under-lambda"
14:59:39 <Twey> Eduard_Munteanu: Cool!
14:59:41 <Eduard_Munteanu> Twey: https://github.com/agda/agda-stdlib/blob/master/src/Algebra/RingSolver.agda
14:59:42 <ski> of course only for quoted lambdas
14:59:55 <Twey> I've heard of this, but never used it
15:02:52 <ski> Twey : also, if you match `<fn x => sin x + 2 * cos x>' on the pattern `<fn x => ~(f <x> + g <x>)>', `f' gets bound to `fn t => <sin ~t>' and `g' to `fn t => <2 * cos ~t>'
15:03:13 <ski> this is similar to HOAS matching in e.g. lambdaProlog or Twelf
15:03:35 <kvasnyk> Hi, anybody know, how can I contact with GSoC mentors?
15:04:07 <geekosaur> have you checked #haskell-gsoc ?
15:04:12 <Eduard_Munteanu> kvasnyk: do you have a name?
15:04:17 <Eduard_Munteanu> Of said mentor.
15:04:54 <kvasnyk> Of course, I search Heinrich Apfelmus.
15:13:04 <c_wraith> kvasnyk: his blog is at http://apfelmus.nfshost.com/ and seems to list an email address
15:13:18 <kvasnyk> c_wraith: thanks!
15:18:33 <Twey> Why is the GSoC tracker so horribly outdated?  Was it abandoned?
15:18:49 <edwardk> it has been picked over for years
15:18:56 <edwardk> we never did find a better system
15:19:18 <edwardk> and there was at least one year when more or less nobody could access it
15:25:32 <vvvrooom> I'm reading lines terminated with \r\n. is there a way to have BS.getLine automatically strip off the '\r' from the end?
15:27:37 <vvvrooom> or a way to modify the stdin handle?
15:29:28 <Twey> vvvrooom: http://hackage.haskell.org/package/base-4.2.0.0/docs/GHC-IO-Handle.html#v%3AhSetNewlineMode
15:29:32 <Twey> (non-portable)
15:30:21 <vvvrooom> thanks! it's fine as long as it works for ghc
15:30:50 <Twey> Yeah, I don't know why I bother warning about non-portability any more.
15:31:10 <tikhon> misplaced idealism?
15:31:21 <tikhon> planning to compile to JavaScript or something else exotic?
15:31:54 <Twey> I think even compiling to JavaScript is irrelevant now we have GHCJS, isn't it?
15:32:00 <tikhon> maybe
15:32:02 <isaacbw> man, I keep getting blown away by haskell
15:32:07 <Twey> (or use future tense as appropriate)
15:32:07 <tikhon> I'm not sure exactly what GHCJS supports
15:32:11 <isaacbw> type inference based on return type? cray
15:32:28 <Twey> isaacbw: You haven't seen the half of it yet… :þ
15:32:49 <Twey> isaacbw: If you feel like being confused, you should look at some of Oleg Kiselyov's code snippets.
15:33:26 <isaacbw> I already confused enough :P
15:36:30 <merijn> isaacbw: Well, not so much type inference based on return type. But polymorphic return type selected by type inference :p
15:36:38 <merijn> isaacbw: How about
15:36:42 <merijn> > minBound :: Char
15:36:43 <lambdabot>  '\NUL'
15:36:48 <merijn> > minBound :: Int
15:36:50 <lambdabot>  -9223372036854775808
15:36:55 <merijn> polymorphic values!
15:37:23 <tikhon> my favorite example is still read, because it's so nicely symmetric with show
15:37:24 <tikhon> :t show
15:37:25 <lambdabot> Show a => a -> String
15:37:27 <tikhon> :t read
15:37:28 <lambdabot> Read a => String -> a
15:37:53 <tikhon> as a rule, if you find symmetry, it means you're onto something
15:39:04 <isaacbw> I love this idea that you "discover" programs rather than engineer them
15:40:52 <thebnq> > minBound :: Integer
15:40:53 <lambdabot>  No instance for (GHC.Enum.Bounded GHC.Integer.Type.Integer)
15:40:53 <lambdabot>    arising from a use of `GHC.Enum.minBound'
15:40:53 <lambdabot>  Possible fix:
15:40:53 <lambdabot>    add an instance declaration for
15:40:53 <lambdabot>    (GHC.Enum.Bounded GHC.Integer.Type.Integer)
15:41:37 <merijn> isaacbw: I would say that this discovering based on types is the only way to engineer programs, the rest is just blindly mucking about
15:41:45 <merijn> thebnq: Integer isn't bounded :p
15:42:05 <thebnq> merijn: yea makes sense :b
15:42:22 <Hermit> is there a way in cabal to define "executable" blocks inside a conditional? The app I'm working on currently has no support for many server-side DB management commands so they should only be compiled on *nix platforms, not windows. I tried adding a conditional then executable but cabal complains about this. How can it be achieved?
15:42:51 <jle`> > let x = toDyn True; y = toDyn "Hello"; z = toDyn 1 in map fromDynamic [x,y,z] :: [Maybe Bool]
15:42:52 <lambdabot>  [Just True,Nothing,Nothing]
15:42:57 <jle`> > let x = toDyn True; y = toDyn "Hello"; z = toDyn 1 in map fromDynamic [x,y,z] :: [Maybe String]
15:42:58 <lambdabot>  [Nothing,Just "Hello",Nothing]
15:43:16 <merijn> Hermit: Define the executable conditionally using a flag and then set the flag default to True for nix and False for windows, I think
15:44:12 <Hermit> define it where?
15:44:14 <bergey> Hermit: https://github.com/diagrams/diagrams-backend-tests/blob/master/diagrams-backend-tests.cabal
15:45:00 <Hermit> thanks, that's what I needed
15:45:26 <merijn> tikhon: ghcjs supports all GHC extensions, threading and STM, afaik
15:45:26 <Hermit> the "buildable" attribute
15:46:06 <merijn> tikhon: So it's pretty damn cool
15:47:05 <gamegoblin> I'd like to get my stream back after parsec operates on it. How do?
15:49:00 <merijn> gamegoblin: Keep a reference to the original input? Or do you mean you have a stream you want to partially parse and then get the remainder?
15:49:22 <isaacbw> what does <|> mean?
15:49:55 <h_nooob> I made a very simple project with cabal; but the executable doesn't get copied into .cabal/bin
15:50:04 <tikhon> usually some sort of alternation: think of it like a generalized or
15:50:12 <tikhon> but also remember that operators in Haskell are just normal functions
15:50:15 <h_nooob> it got copied in the first time I built it, but now it only goes into ./dist
15:50:32 <tikhon> so anybody can define it to do anything—it's just that conventionally (and in the standard library) it represents alternation
15:50:36 <gamegoblin> merjin: I have my own data type that I made an instance of Stream (what a parsec parser wants). While parsec is using it, I manipulate some satellite data inside my stream data type. I'd like to be able to examine this data once parsec finishes.
15:50:40 <h_nooob> I deleted it manually from ./cabal/bin, was that bad?
15:50:52 <merijn> isaacbw: It's from the alternative class you can think of it as "or"
15:51:01 <merijn> > Just 5 <|> Just 3
15:51:02 <lambdabot>  Just 5
15:51:07 <merijn> > Nothing <|> Just 3
15:51:08 <lambdabot>  Just 3
15:51:12 <henk> When parsing a utf8-textfile, should I be using String or Data.Text.Text? I read that String is awfully slow …
15:51:13 <merijn> > Just 5 <|> Nothing
15:51:14 <lambdabot>  Just 5
15:51:19 <merijn> Hermit: Text
15:51:24 <merijn> eh, henk
15:51:31 <isaacbw> ah, so like a short circuiting or, almost
15:51:43 <isaacbw> cool beans
15:51:45 <isaacbw> thanks
15:51:56 <merijn> henk: Let me put it this way, String can on some platforms take up to 20 bytes per characters (and lots of pointers, since it's a linked list)
15:52:12 <tikhon> isaacbw: that's what it is for Maybe; it also works on other types too
15:52:15 <tikhon> :t (<|>)
15:52:15 <lambdabot> Alternative f => f a -> f a -> f a
15:52:44 <merijn> henk: Text uses about 2-3 bytes per unicode character and has them as a list of densely packed chunks (like 1kb per chunk or something)
15:53:22 <merijn> isaacbw: It is exactly like short circuiting or for types that have a "empty" value
15:54:07 <Saizan> h_nooob: are you running cabal install or just cabal build?
15:54:13 <gamegoblin> merjin: idea on how to do what I said?
15:54:21 <h_nooob> oh yeah I forgot
15:54:25 <merijn> gamegoblin: use getInput?
15:54:27 <h_nooob> I was just running cabal build
15:54:32 <h_nooob> thx
15:54:51 <merijn> gamegoblin: like "do { result <- myParser; stream <- getInput; return (result, stream) }"?
15:55:17 <dmj`> cabal is saying base and haskell2010/98 are hidden when they're not, unsure what to do
15:55:19 <dmj`> http://lpaste.net/101218
15:55:36 <dmj`> ghc-pkg list | grep base shows its not hidden, same w/ others
15:56:09 <bergey> dmj: What's in your .cabal build-depends?
15:56:10 <geekosaur> "Perhaps you need to add `base' to the build-depends in your .cabal file."
15:56:34 <geekosaur> (pick one, don't add all of them... they're mutually incompatible)
15:57:00 <dmj`> geekosaur: bergey: I have  base == 4.6.0.1, in there
15:57:00 <henk> merijn: ok, thank you. Some functions expect Strings, is there any way of giving them Texts? Is the OverloadedStrings extension a (good) solution for that? I read extensions should be avoided, unless one really needs them and knows what one is doing …
15:57:35 <dmj`> henk: you will find yourself using OverloadedStrings for everything it's awesome
15:58:38 <henk> dmj`: hehe, ok, thanks. Any other extensions I should know about? (:
15:58:57 <ReinH> henk: it won't let you give a Text to a function that expects a String though
15:59:03 <ReinH> it just overloads the "" constructor
15:59:16 <ReinH> so you can't say putStrLn (foo :: Text)
15:59:30 <gamegoblin> merjin: I think that'll work, thanks
15:59:51 <dmj`> henk: TypeSynonymInstances are useful when doing stuff w/ exceptions. Just prods ghc to understand the type.
16:00:10 <einganzdoofernic> @pl \x -> (y (f x) (g x))
16:00:10 <lambdabot> liftM2 y f g
16:00:22 <ReinH> einganzdoofernic: y <$> f <*> g
16:00:58 <dmj`> geekosaur: I don't want to delete my sandbox and start over :/
16:01:34 <merijn> dmj`: Well, is "base" in your build-depends?
16:01:46 <geekosaur> dmj`: I think we need to see more of your cabal config
16:01:53 <iduhetonas> To all: I've finished reading LYAH and RealWorldHaskell. What would be a good book to read next? I was thinking about starting on Parallel and Concurrent Programming by Simon Marlow
16:02:08 <dmj`> ok
16:02:22 <tikhon> iduhetonas: that's certainly a good book
16:02:27 <tikhon> it'll help if you have a project to work on too
16:02:41 <merijn> henk: There is a Text -> String function in Data.Text or wherever
16:03:09 <merijn> @hoogle Text -> String
16:03:09 <lambdabot> Data.Text.Lazy.Internal showStructure :: Text -> String
16:03:09 <lambdabot> Data.Text.Internal showText :: Text -> String
16:03:09 <lambdabot> Data.Text.Lazy unpack :: Text -> String
16:03:10 <iduhetonas> tikhon: It's not necessarily related to what I'm doing yet, but I can't think of any other books to choose from
16:03:11 <henk> ReinH: I see, thank you
16:03:46 <henk> merijn: Yeah, I know, I just thought there might be a more elegant way, thanks
16:03:50 <merijn> iduhetonas: That, or graduate to the easier and cooler papers, depending on your interest
16:03:51 <tikhon> iduhetonas: in your position, I'd probably take a break from reading books and try to actually build something concrete
16:04:05 <merijn> iduhetonas: Or, indeed, build something
16:04:07 <tikhon> design a programming language or something
16:04:12 <tikhon> that's always fun
16:04:18 <merijn> iduhetonas: I've heard good things about Write Yourself a Scheme in 48 Hours
16:04:30 <tikhon> merijn: that's how I learned Haskell
16:04:42 <iduhetonas> merijn: That's a good idea
16:04:45 <tikhon> it's good for getting over the intermediate Haskell "hump"
16:04:49 <merijn> I always love how "an easy beginner haskell project" is "design your own programming language" :D
16:04:54 <tikhon> but I'm not sure the code is super idiomatic
16:05:02 <tikhon> designing languages is fun!
16:05:06 <dmj`> geekosaur: http://lpaste.net/101219
16:05:06 <merijn> tikhon: Word.
16:05:29 <artyomkazak1> tikhon: not if you're a perfectionist
16:05:31 <merijn> tikhon: I'm TAing a compiler course atm, it's fun to see the alternation of dread and epiphany :)
16:05:31 <dmj`> cabal install -j is a life saver
16:05:42 <iduhetonas> tikhon: I wrote a compiler in Haskell when I first started, but we did it SO poorly
16:05:55 <tikhon> unfortunate
16:05:57 <iduhetonas> Though we were still far ahead of every other team in the class
16:06:04 <geekosaur> so your build-depends including base do not applu to the executables other than web?
16:06:11 <tikhon> you could write a better compiler
16:06:28 <bergey> dmj: I get caught by this regularly.  Each executable section needs its own build-depends.
16:06:30 <iduhetonas> tikhon: Yeah, that's a really good idea. I haven't really thought about it since the first time
16:06:30 <geekosaur> admin, worker, and db need it too
16:06:41 <Nafai> merijn: What implementation language are your students using?
16:06:49 <tikhon> starting with an interpreter is easier though
16:06:58 <tikhon> which is exactly what "Write Yourself a Scheme" covers
16:07:06 <merijn> Nafai: Homegrown C framework, on account of functional languages not being mandatory for undergrads
16:07:17 <tikhon> but C?
16:07:20 <tikhon> ugh
16:07:24 <tikhon> I thought Python was bad enough
16:07:27 <merijn> tikhon: That's what they know and what we had
16:07:44 <Nafai> Yeah, we used C in my undergrad compilers course
16:08:02 <tikhon> At my school we have an unofficial policy that you're supposed to be able to pick up a new language in a weekend (well enough to do coursework, at the very least)
16:08:07 <merijn> tikhon: We basically ripped the basic framework out of the compiler they're developing in the research group wich gives them automated traversal generation for their AST
16:08:10 <tikhon> apparently it doesn't apply to Haskell though :(
16:08:16 <dmj`> geekosaur: I see what you're saying, but for some reason I've always been able to compile all executables by only specify build-depends in web
16:08:23 <dmj`> specifying
16:08:28 <tikhon> but maybe OCaml
16:08:51 <geekosaur> not sure how that would have worked; see also bergey's response to you
16:08:54 <merijn> tikhon: The professor is not really a haskell guy, but he'd like to use OCaml. But teaching both OCaml and compilers in one course is deemed to tricky for undergrads
16:09:01 <dmj`> bergey: It didn't use to... I can't afford to copy paste 60 lines 4 times :)
16:09:13 <tikhon> meh, other professors are perfectly happy to hoist C++ on unsuspecting students
16:09:21 <tikhon> and that's far harder than OCaml
16:09:26 <dmj`> bergey, geekosaur: do you guys recommend I create a libary internal or seperate from this package?
16:09:34 <Nafai> It was interesting.  In my AI course, we used CL (which included learning the language during the course).  We accomplished so much more in my section than in a section taught by a different professor using Java (which the students already knew).
16:09:50 <merijn> dmj`: Personally I frequently use an internal library and then have the executables depend on that
16:10:14 <merijn> Nafai: Don't look at me, if I was designing the course it'd be brutal :)
16:10:26 <merijn> Haskell all the way \o/
16:10:34 <tikhon> Write a certified compiler with Coq :)
16:10:35 <iduhetonas> merijn: "Fun" fact: We were the only team in our compilers group that used Git, or any sort of version control. One team even used a Google Doc for code
16:10:50 <blipped> noob haskell code here, been going through lyah in the ghci, but having difficulties when switching over to eclipseFP even printing a simple list? I can define a list, but how do I print it? I can print strings
16:10:52 <merijn> At least all the groups in the lab seem to use git
16:11:04 <tikhon> Personally, I would have loved to have a proof-based class with all the homeworks in Coq
16:11:05 <nschoe> Hey everyone, can anyone explain to me what's going on here, please ? I just want to read a file as a BS (ByteString), append a new BS to it, then write back the new BS to the file. But intead only the new content get written to the file. And when I try to print what I have just read from the file (with line 4) I get a illegal operating (Handled is closed) error.
16:11:05 <merijn> blipped: What are you using to print?
16:11:05 <Nafai> I'm pretty sure if Haskell was even mentioned during any of my undergrad coursework, it was briefly during the PL course.
16:11:09 <tikhon> but I may be the only one
16:11:09 <blipped> print
16:11:10 <dmj`> blipped: ditch eclipse
16:11:15 <nschoe> Anyone has a clue for me ?
16:11:19 <merijn> blipped: That should work fine for lists too...
16:11:21 <Nafai> Anything remotely about functional languages was about scheme in that course.
16:11:45 <tikhon> for us, the only mention of Haskell was when we learned about how Hindley-Milner works
16:11:53 <merijn> nschoe: Using hGetContents by any chance?
16:11:55 <blipped> I just have simple code module Main where \n l = [1,2,3] \n print l ?
16:12:03 <blipped> dmj, why ditch eclipse?
16:12:15 <nschoe> merijn, yes absolutely, here is the portion of the code that is buggy : http://lpaste.net/101220
16:12:16 <tikhon> not very many people like functional programming around here, unfortunately
16:12:18 <merijn> blipped: Oh, you just have "print l" on a separate line?
16:12:33 <nschoe> B is ByteString.Lazy and C is Data.Csv
16:12:36 <merijn> blipped: Haskell doesn't have anything like "top level statements"
16:12:41 <blipped> yah, it's how it's done in the ghci. How should I do it?
16:12:58 <Twey> henk: You will find yourself using extensions for everything; they're awesome ;)
16:13:00 <geekosaur> main = print l
16:13:01 <dmj`> merijn: I was afraid it would come to this, one massive code refactoring, but I swear all executables built and depends-on was only specificied in web, ill try to repro
16:13:03 <merijn> blipped: "l = [1,2,3] \n main :: IO \n main = print l"
16:13:08 <tikhon> GHCi behaves differently than the Haskell you write in a file
16:13:11 <blipped> Ahh, k :) thanks
16:13:16 <merijn> nschoe: hGetContents is a filthy lie
16:13:29 <nschoe> merijn, oh ? how so?
16:13:39 <merijn> nschoe: It's lazy, so you are probably trying to write to the file while still reading from it
16:13:51 <Twey> henk: There are some that are potentially unpleasant, but they usually sound scary.  Like IncoherentInstances.
16:13:53 <merijn> nschoe: lazy as in lazy IO, not lazy as in "whole of haskell is lazy"
16:14:08 <Rylee> I dunno, some of you people are really lazy.
16:14:09 <kqr> Twey, that's a good rule of thumb noone has taught me yet
16:14:11 <kqr> Twey, thanks
16:14:46 <nschoe> merijn, well that is what I thought, this is why I tried to force evaluation with hPut ing the just-read BS to screen, but then I have this illegal operaiong (handle closed)
16:14:50 <merijn> nschoe: If you read the docs it's mentioned that it reads the entire file lazily AND closes the file when it hits EOF
16:15:18 <merijn> nschoe: Basically, after you use hGetContents it's unsafe to use that file descriptor again
16:15:26 <nschoe> merijn, how my.... I am so sorry. absolutely right -_-
16:15:47 <blipped> dmj, curious why you said ditch eclipsefp?
16:15:52 <nschoe> merijn, okay... so basically, how do I do soemthiing such simple as reading fomr a file, processing the data and write them jsut back in ?
16:15:53 <merijn> nschoe: Try using hGetContents from strict ByteString
16:16:13 <blipped> What would you suggest? Lekash? Vim? emacs?
16:16:15 <merijn> nschoe: Actually, while that reads everything strictly, it still closes the file :)
16:16:22 <Twey> kqr: The big exception I can think of is TypeSynonymInstances, which sounds fairly innocuous until you think about what it actually means, at which point it becomes terrifying
16:16:24 <nschoe> merijn, yeah ^^
16:16:29 <merijn> blipped: If you're already comfortable with vim or emacs, I'd use that
16:16:35 <einganzdoofernic> Why does `avg  = liftM2 div (foldl1 (+)) length` work, but `avg  = liftM2 div  foldl1 $ (+) length` doesn't?
16:16:39 <merijn> blipped: If not, I don't see why you should ditch eclipse
16:16:53 <blipped> Alrighty, thanks again
16:17:10 <nschoe> merijn, so basically i have the option of readFile it with strict BS then writeFile it OR read it lazily with hGetContents and writing the changed into another, temporary file, then delete the first and rename the second ?
16:17:36 <Twey> einganzdoofernic: Because the latter means liftM2 div foldl1 ((+) length), and you wanted liftM2 div (foldl1 (+)) length
16:17:39 <merijn> nschoe: Or you read and write chunks using hGet/hGetSome and hPut
16:17:39 <dmj`> blipped: I shouldn't have said that, use any editor you feel comfortable with. I just despise eclipse becuase I think it's a resource hog and I don't like big IDE's. I'd rather code java in emacs than eclipse.
16:18:06 <dmj`> blipped: vim, sublime or emacs
16:18:19 <merijn> nschoe: Those behave more like read/write in C and other languages (i.e. just return a ByteString, and empty ByteString if you hit EOF)
16:18:20 <nschoe> merijn, but... I have to write it back to the same file. So I can't really do that, can I ? I mean to be able to write back to the file I must finish processing all its input before
16:18:47 <tikhon> learning a good editor like Emacs is worth doing at some point, but it's largely orthogonal to learning Haskell
16:18:47 <merijn> nschoe: Right, so you keep reading building one big ByteString until you hit EOF, then you start writing to it
16:19:13 <nschoe> merijn, you make it sound like that's a bad idea ?
16:19:22 <merijn> nschoe: It depends
16:19:47 <merijn> nschoe: For anything smaller than several hundred MB, up to a gigabyte or so that'll work just fine
16:19:57 <nschoe> merijn, that would make the whole file stored in memory, right ?
16:20:01 <merijn> nschoe: Right
16:20:04 <Twey> merijn: Hm, that's a bit unpleasant
16:20:09 <merijn> nschoe: So it depends whether that's a problem
16:20:34 <Twey> You can read and write at once in POSIX, but I don't know of a Haskelly way of doing that
16:21:03 <nschoe> merijn, so what if I lazily read it chunk by chunk, then process it chunk by chunk, then lazily write the result into another temprary file that and then replacing the first file with it after the last chunk is processed and written ?
16:21:20 <merijn> nschoe: Actually, hold on
16:21:23 <nschoe> That should keep my memory sane, won't it ?
16:21:36 <merijn> nschoe: You don't even care about the original contents, no? You just wanna leave them untouched?
16:21:53 <merijn> nschoe: Why don't you just use appendFile?
16:22:30 <merijn> That'll use about as much memory as the ByteString you want to append :p
16:22:47 <nschoe> merijn, because the BS I write to the file is encrypted. So I need to fecth the whole content, decrypt it, append the new unencrypted BS to it, THEn re-encrypt the new BS and write it back
16:23:39 <isaacbw> of the web frameworks, which has the sanest type system for a noobie to explore?
16:23:46 <merijn> nschoe: Right, then streaming it is nicer
16:24:02 <Twey> nschoe: Usually encryption is done ‘block-wise’ so you don't have to read the whole file in at once to decrypt it
16:24:05 <merijn> nschoe: There's actually a whole bunch of libraries to make streaming IO nicer, i.e. pipes and conduits
16:24:07 <isaacbw> snap looks like it might be the easiest from what I've seen
16:24:17 <c_wraith> You should pretty much never stream encrypted data.
16:24:19 <merijn> isaacbw: snap/happstack should be simplest for beginners
16:24:25 <Twey> You should be able to just read the last block
16:24:26 <c_wraith> Or if you do, you need to stream it twice
16:24:49 <c_wraith> Because the only correct way to handle encrypted data is to check its signature first, then process the contents.
16:24:57 <Twey> isaacbw: It's the old simplicity/power question
16:25:07 <merijn> c_wraith: You're assuming there is a signature
16:25:12 <Twey> isaacbw: Snap has more simplicity, Happstack and Yesod have more power
16:25:18 <nschoe> Twey, so the "correct" way to encrypt the file would be to encrypt it should be to encrypt 4K blocks of it? SO that I have to read only 4K chunks at a time ?
16:25:21 <isaacbw> What I really need right now is simplicity :P
16:25:27 <nschoe> merijn, okay I'll look into that.
16:25:34 <c_wraith> merijn: if there isn't a signature, it should be assumed to be dangerous.
16:25:36 <nschoe> merijn, thanks for the quick response by the way !
16:25:41 <Twey> nschoe: Something like that, yes
16:25:43 <isaacbw> I had zero idea what was going on in happstack's hxp section
16:25:50 <merijn> Is thoughtpolice's NaCl library on hackage yet? :p
16:25:54 <nschoe> Twey, okay, I'll look into it too, thanks !
16:26:08 <tikhon> I've heard Scotty is very simple
16:26:15 <merijn> nschoe: What are you using to encrypt anyway?
16:26:27 <tikhon> it's like Ruby's Sinatra, apparently
16:26:56 <hpc> sinatra is artful and rich with texture
16:27:01 <tikhon> my impression is that it goes beyond just "simple" and into "minimalist"
16:27:03 <hpc> scotty is a nerd ;)
16:27:12 <nschoe> merijn, right now, nothing. I want to finish the program around it.
16:27:12 <tikhon> but I like minimalism
16:27:15 <einganzdoofernic> @pl avg list = div (foldl1 (+) list) (length list)
16:27:16 <lambdabot> avg = ap (div . foldl1 (+)) length
16:27:17 <nschoe> Then I'll look into encryption
16:27:41 <nschoe> I will jsut need something that can turn my BS into another, encrypted BS.
16:27:52 <merijn> nschoe: Look into NaCl when you do, and go back thoughtpolice to put his haskell library online for you ;)
16:28:05 <tikhon> einganzdoofernic: div <$> sum <*> length
16:28:46 <Twey> tikhon: I like minimalism.  But I also like convenience and type-safety.
16:28:59 <Twey> runWebServer ∷ String → String
16:29:05 <Twey> Er
16:29:08 <Twey> runWebServer ∷ (String → String) → IO ()
16:29:11 <tikhon> runWebServer :: IO ()
16:29:11 <nschoe> merijn, okay, thanks you. But... it is alreayd online : http://thoughtpolice.github.io/salt/doc/ no ?
16:29:23 <merijn> nschoe: Yes, but not on hackage, I think :)
16:29:39 <henk> Twey: Hehe, I thought something like that. OverloadedStrings didn’t sound too scary and quite useful.
16:30:12 <tikhon> Scotty seems pretty reasonable, but I haven't really used any of the web frameworks
16:30:27 <nschoe> merijn, ho okay. Thank you then ^^
16:30:54 <Twey> Scotty's cute
16:30:55 <merijn> henk: Most haskell extensions are fairly useful (that's why the exist) and almost all of them are safe (safe means, won't silently break your code, i.e. either it breaks loudly or it doesn't break)
16:31:17 <Twey> Most of them won't break existing code at all
16:31:35 <merijn> henk: See for example: https://stackoverflow.com/questions/10845179/which-haskell-ghc-extensions-should-users-use-avoid
16:31:43 <Twey> You usually have to use some kind of explicit syntax
16:32:46 <Twey> What are SQL comprehensions and why are they ‘Bad’?
16:32:50 <merijn> henk: Generalized Newtype Deriving and incoherent instances have some sharp edges, overlapping instances is a misfeature and undecidable instances can cause GHC to hang trying to compile your code. The rest should be perfectly safe
16:32:56 <merijn> Twey: No clue
16:33:32 <hpc> sql comprehensions are a way of taking list comprehensions and making them enterprise
16:33:33 <Twey> +1 ‘SQL comprehensions is bad and IncoherentInstances is not?’
16:33:53 <Twey> hpc: Do you mean LINQ™ for Haskell©?
16:34:10 <hpc> there's no semantic issue, but the actual parsing of it looks tremendously doofy if you imagine what the compiler does
16:34:54 <Twey> It's just a few new kinds of conditions on comprehensions
16:35:17 <Twey> I guess it's Bad because it makes parallelization or translation to do-notation awkward
16:35:55 <tikhon> to me, it always seemed like a reasonable extension—then again, I never used it and never saw any real code with it
16:36:39 <tikhon> I do really like parallel list comprehensions, and those would probably look just as weird when translated to do notation
16:36:43 <hpc> in any event, i think the question isn't so much "which to avoid", as which extensions are unambiguous improvements to the language
16:36:57 <tikhon> "unambiguous" is such a high standard :P
16:36:58 <hpc> such as type families, data kinds, constraint kinds, GADTs
16:37:01 <FreeFull> I never really was taken by list comprehensions
16:37:03 <tikhon> scoped type variables
16:37:10 <hpc> rank N types
16:37:18 <tikhon> that's the only one that I think is *completely* unambiguous
16:37:26 <tikhon> or the only one that comes to mind
16:37:40 <tikhon> I mean, RankNTypes, for example, is awesome but also compromises type inference sometimes
16:37:54 <hpc> yeah
16:38:09 <hpc> RankNTypes in its current implementation only adds typechecking values that can't be inferred
16:38:18 <tikhon> and type families overlaps with functional dependencies
16:38:21 <hpc> it doesn't subtract from the space of inferrable values/types
16:38:38 <tikhon> well
16:38:41 <hpc> there's a few places where type families and fundeps differ in power
16:38:48 <hpc> which i would have to look up and i am lazy ;)
16:38:50 <tikhon> the other way around really: I guess fundeps are largely unnecessary now
16:39:04 <Twey> Hm
16:39:06 <tikhon> except they look so much prettier than the alternatives
16:39:08 <geekosaur> afaik they are still needed
16:39:13 <tikhon> are they?
16:39:15 <tikhon> it's possible
16:39:29 <hpc> i like the notation of fundeps and just how much "smaller" they are
16:39:31 <tikhon> not for the stuff I use them for, but my typeclass hackery tends to be pretty limited
16:39:37 <geekosaur> it was found that type families couldn't readily solve some issues that fundeps handle easily
16:39:42 <hpc> as well as the explicitness of putting the extra types into each instance
16:39:42 <tikhon> hpc: yeah, that captures my feelings exactly
16:40:02 <hpc> and i don't mean syntactically smaller or smaller implementation-wise
16:40:04 <kakos> So, any magical new Haskell IDE out there that everyone is gushing over and everyone loves?
16:40:06 <geekosaur> so type families got evolved in a different direction, which is where we got closed type families which solve an issue that fundeps can't address easily
16:40:12 <hpc> but in mental load when reading/writing
16:40:19 <gnuvince> Anyone familiar with the Haskell SDL library?  My event loops catches joystick input only for the first second of execution, after that, events are not captured.
16:40:22 <tikhon> come to think of it, I don't use *that* many extensions regularly—I've naturally come to prefer particular ones
16:40:40 <hpc> i use extensions only very rarely
16:40:46 <tikhon> ooh, all I've managed to do with SDL was cause segfaults if you moved your mouse too much
16:41:04 <Twey> tikhon: The *behaviour* of ScopedTypeVariables is completely unambiguous, but I know people who refuse to use it because it has crazy syntax
16:41:08 <geekosaur> segfaults sounds like something in the binding has the wrong type
16:41:10 <hpc> i have been forced into a few by acid-state, and once with overloaded strings for bytestrings
16:41:13 <tikhon> Twey: the foralls?
16:41:17 <hpc> because the alternative would have been horrific
16:41:17 <Twey> Yeah
16:41:26 <tikhon> I like overloaded strings a lot
16:41:34 <hpc> but the type system expansions i rarely get into
16:41:43 <geekosaur> xmonad has uncovered a number of incorrectly typed FFI bindings in the haskell X11 library
16:41:52 <gnuvince> tikhon: doesn't bode well for me if the library seems so fragile :/
16:42:00 <tikhon> gnuvince: I was doing things really wrong
16:42:05 <hpc> that might just be that i like to be a bit more lax with types
16:42:17 <hpc> just enough to stop edge cases, rather than enough to specify a full api
16:42:21 <tikhon> hmm
16:42:37 <tikhon> I often use types for actual expressiveness rather than safety per se
16:42:40 <vozz_> Is this still relevant? https://ghc.haskell.org/trac/summer-of-code/ticket/1607
16:42:42 <Twey> tikhon: The argument being that really type variables should be scoped by default, and ∀ should indicate a *non-*scoped type variable
16:43:15 <tikhon> Twey: how would that work when the ∀ is actually needed *and* you want scoped variables?
16:43:19 <tikhon> (Can that actually come up?)
16:43:36 <tikhon> If we had a time machine, we could just make type variables always scoped no matter what
16:43:39 <tikhon> that would be nice
16:43:46 <tikhon> but instead we have to deal with backwards compatibility
16:43:49 <isaacbw> how is liftM different from fmap
16:43:51 <Twey> tikhon: I.E. the ∀ at the start of the type signature limits the variable's scope to the type signature, in the same way that a ∀ at the start of a bracketed expression inside the type signature limits the variable's scope to the bracketed expression
16:43:53 <geekosaur> no, because only top level foralls affect scope and those are always optional otherwise
16:43:59 <tikhon> isaacbw: it's the same function with a different type
16:44:00 <shachaf> Turning on ScopedTypeVariables can break backwards compatibility, by the way.
16:44:03 <Twey> isaacbw: liftM works on Monads.
16:44:05 <shachaf> But only in specific cases.
16:44:14 <geekosaur> isaacbw: current Monad can't assume existence of a Functor, so it replicates fmap as liftM
16:44:14 <shachaf> (I mean, even without using forall.)
16:44:16 <Twey> isaacbw: Any well-behaved Monad should have liftM = fmap
16:44:24 <Twey> isaacbw: = liftA
16:44:25 <geekosaur> using the Monad machinery
16:44:27 <isaacbw> ah, okay
16:44:31 <isaacbw> cool
16:44:33 <vozz_> Is there an up to date Google Summer of Code ideas page for haskell anywhere?
16:44:57 <shachaf> vozz_: I'm not sure -- maybe someone in #haskell-gsoc would know.
16:45:39 <Twey> tikhon: Hm, it can happen when you need to use a ∀ to restrict the kind of a type variable
16:46:03 <tikhon> Twey: come to think of it, I actually have code that does that lying around
16:46:13 <Twey> Yeah, I do too
16:46:56 <Twey> Personally I think I would have a distinction between  ∀ a. foo  and  (∀ a. foo)
16:47:15 <Twey> So the ∀ always scopes up to the first bracket, or over the whole definition if there isn't one
16:47:27 <Twey> That seems coherent
16:47:29 <henk> thanks everyone for your opinions (:
16:48:18 <jmcarthur> i don't think i see the argument that scoped should be the default. it totally makes sense to me that a type variable that is scoped should have a binding somewhere. otherwise, i don't actually know what its scope is
16:48:32 <Cale> Twey: yeah, I tend to prefer that quantifiers scope as far as possible to the right
16:49:27 <tikhon> hmm, that makes sense
16:49:37 <jmcarthur> hi tikhon!
16:49:42 <tikhon> hey
16:50:38 <tikhon> at the very least, variables from inferred types should not magically appear in your scope
16:51:00 <tikhon> and, ideally, you should be able to just insert an inferred signature without changing anything
16:51:05 <tikhon> so that seems to be a case for not scoping things by default
16:52:02 <tikhon> I really hadn't put much thought into this before
16:53:39 <u-ou> I don't like scoped type variables but sometimes I want to do something like x :: SomeType = someValue
16:55:24 <Twey> tikhon: Scoping types by default doesn't mean scoping *inferred* types by default.  Inferred type variables should always be fresh in the definition.
16:55:24 <u-ou> in which case i have to use LANGUAGE ScopedTypeVariables
16:55:24 <u-ou> afaik
16:55:24 <Twey> u-ou: Why don't you like scoped type variables?
16:55:24 <Twey> Yes, you do
16:55:24 <u-ou> same reasons as above pretty much
16:55:24 <ion> x = someValue :: SomeType
16:55:24 <Twey> But note that x = someValue ∷ SomeType is equivalent
16:55:24 <u-ou> yea
16:55:24 <tikhon> that pattern often comes up in do notation
16:55:24 <u-ou> but sometimes i want to do the other thing :p
16:55:24 <tikhon> or inside lambdas
16:55:24 <Twey> u-ou: ‘The other thing’ (pattern signatures) introduces a scoped type variable, which is why it was merged with ScopedTypeVariables
16:55:24 <tikhon> I use that sort of pattern a lot with sbv because it's pretty promiscuous with its typeclasses
16:55:40 <Twey> Exception handlers are the other big use-case for that
16:56:01 <Twey> foo `catch` \(e ∷ BarException) → baz
16:56:17 <tikhon> heh, I think I've used `catch' a grand total of once
16:56:37 <Twey> I don't like exceptions, but people who do have to do that sort of thing
16:56:50 <Twey> Or people who want to do a lot of IO, I guess
16:57:26 <tikhon> yeah, most of my recent code hasn't used much IO
16:57:33 <tikhon> it makes for a happier world
16:58:32 <iduhetonas> Question! Has there been any work on Hexagonal maps in Haskell, as a library, in graphics, or otherwise?
16:58:50 <tikhon> I think there is a library for working with regularly tiled grids
16:58:53 <tikhon> that includes hexagons
16:59:13 <ion> tikhon: You should have said “Fact!” first.
16:59:25 <tikhon> http://hackage.haskell.org/package/grid
16:59:40 <iduhetonas> tikhon: Cool, thanks!
16:59:43 <tikhon> I love the straightforward naming convention so many Haskell libraries use :)
17:00:03 <iduhetonas> Me too
17:00:16 <Yaniel> "bananas, lenses, envelopes and barbed wire"?
17:00:31 <ion> yaniel: That’s a Haskell library? :-P
17:00:33 <tikhon> Yaniel: that's more a paper than a library
17:00:41 <FreeFull> Radioactive space burrito?
17:00:50 <edwardk> tikhon: guess i need to rename my grid project
17:01:03 <ion> Name it gridwardk
17:01:15 <FreeFull> lens is a library, reactivebanana is a library, not sure about envelopes and barbed wire =P
17:01:38 <Yaniel> iirc there is an entire set of "optics" libraries
17:01:44 <ion> Ooh, is *that* what the name of reactive banana refers to?
17:01:51 <edwardk> bananas, etc. are all taxonomized in recursion-schemes
17:02:07 <FreeFull> ion: I don't know
17:04:30 <Twey> tikhon: ‘Straightforward’?  :þ
17:12:52 <isaacbw> is Enum a monad?
17:13:26 <tikhon> Enum is a typeclass
17:13:27 <isaacbw> er
17:13:29 <isaacbw> right
17:14:52 <isaacbw> how I am I supposed to interpret enumFromTo 1 10 >>= ...
17:14:56 <isaacbw> where is that >>= implemented?
17:15:06 <Twey> isaacbw: For each monad separately
17:15:16 <Twey> Oh, in this case it's the list monad
17:15:20 <isaacbw> ah, okay
17:15:23 <Twey> @src [] (>>=)
17:15:24 <lambdabot> xs >>= f     = concatMap f xs
17:16:18 <jle`> isaacbw: >>= basically means "do this (a -> [b]) for every a in your list, and collect the results
17:16:40 <Twey> Yes; for [], (>>=) is (flip) concatMap
17:16:40 <jle`> > [1,2,3] >>= \x -> [x,x*2]
17:16:41 <lambdabot>  [1,2,2,4,3,6]
17:17:08 <jle`> the main advantage is that you can chain these
17:17:09 <Twey> > concatMap (\x → [x, x * 2, x * 3]) [2, 3, 5]
17:17:10 <lambdabot>  [2,4,6,3,6,9,5,10,15]
17:17:31 <jle`> > [1,2,3] >>= \x -> [x,x*2] >>= \y -> [show y, "oh " ++ show y]
17:17:32 <lambdabot>  ["1","oh 1","2","oh 2","2","oh 2","4","oh 4","3","oh 3","6","oh 6"]
17:18:33 <Twey> isaacbw: This is a pretty good intuition for (>>=), actually: ‘do something that results in more structure, then flatten the results together’
17:20:17 <isaacbw> I'm familiar with flatmap, which I guess is the same thing as >>=?
17:20:28 <Twey> I don't know, but it sounds like it
17:20:35 <Twey> In Scala?
17:20:56 <tikhon> yeah, that's what Scala calls it
17:20:59 <isaacbw> I don't know where I know it from
17:21:01 <isaacbw> maybe scala
17:21:03 <Twey> Yeah, that looks like the same thing
17:21:04 <tikhon> a pretty intuitive name, I think
17:21:28 <Twey> isaacbw: But note that concatMap is only (>>=) when you're talking about lists
17:21:38 <isaacbw> the big thing that made monads start to make sense for me was that they solve the problem of chaining a -> m b and b -> m c
17:21:49 <tikhon> exactly
17:21:53 * hackagebot yesod-dsl 0.1.1.15 - DSL for generating Yesod subsite to manage an RDBMS;  http://hackage.haskell.org/package/yesod-dsl-0.1.1.15 (TeroLaitinen)
17:21:53 * hackagebot tianbar 0.3.1.0 - A desktop bar based on WebKit  http://hackage.haskell.org/package/tianbar-0.3.1.0 (AlexeyKotlyarov)
17:21:57 <Twey> isaacbw: Other monads have other definitions of (>>=), but they all follow this ‘do something and then flatten it back into the original shape’ schema
17:21:57 <isaacbw> but I still have trouble understanding how you can emulate state with that
17:22:20 <isaacbw> for example, it seems like if you have functions in a do, they magically know about the containing monad
17:22:22 <isaacbw> but I can't figure out how
17:22:23 <tikhon> think about what a "stateful" value is
17:22:33 <Twey> isaacbw: By typeclasses
17:22:38 <Twey> :t (>>=)
17:22:39 <lambdabot> Monad m => m a -> (a -> m b) -> m b
17:22:44 <tikhon> ie if you have a State Int, it's a number that might depend or modify some state]
17:22:59 <tikhon> how would you represent a number that might *depend* on some state?
17:23:06 <jle`> isaacbw: it's not any more magic than
17:23:09 <jle`> > :t \x -> x + 2
17:23:10 <lambdabot>  <hint>:1:1: parse error on input `:'
17:23:13 <ski> it's a computation that might depend on ior modify some state, and result in a number result
17:23:14 <geekosaur> :t enumFromTo
17:23:15 <lambdabot> Enum a => a -> a -> [a]
17:23:16 <jle`> :t \x -> x + 2
17:23:17 <lambdabot> Num a => a -> a
17:23:20 <Cale> isaacbw: It's the same way as when you use (+) how it knows which sort of addition to use given the type of numbers you're adding.
17:23:21 <jle`> how does it know x is a number?
17:23:23 <jle`> (you add it)
17:23:30 <geekosaur> note that it produces a list. if you feed the result to (>>=) then it uses the list monad
17:23:30 <Twey> isaacbw: If you know that m a = Maybe Int, then m can only be Maybe, and the ‘m b’s must all be ‘Maybe b’s
17:23:36 <jle`> also a lot of times you'll put an implicit type sigature
17:23:42 <jle`> er
17:23:44 <jle`> explicit
17:23:45 <ski> tikhon : `MyStateThing -> Int' ?
17:23:46 <jle`> main :: IO ()
17:23:53 <tikhon> ski: exactly
17:24:02 <jle`> also, every line within a do block is the 'same monad'...because of the type of (>>=)
17:24:06 <tikhon> now think about how you would represent setting a new state
17:24:47 <isaacbw> so a concrete example that's confusing me is snap's getParam. Where does it get the Request from?
17:24:55 * ski idly wonders what tikhon wants to do
17:25:06 <tikhon> ski: trying to explain the state monad from the ground up
17:25:17 <ski> oh, you're explaining to someone else
17:25:21 <Twey> Heh
17:25:34 <Twey> I thought that was a more general philosophical question, for a bit
17:25:44 <Twey> ‘Well, I'd like to find true happiness’
17:25:56 <tikhon> why have happiness when I can have a state monad?
17:26:48 * hackagebot tianbar 0.3.2.0 - A desktop bar based on WebKit  http://hackage.haskell.org/package/tianbar-0.3.2.0 (AlexeyKotlyarov)
17:26:50 <isaacbw> oh wait, maybe the Snap monad is based on IO, and there's some magic there I'm missing?
17:26:57 <Twey> isaacbw: The Snap monad is a kind of State monad (rolled up with some other stuff)
17:27:39 <isaacbw> because I understand Maybe chaining perfectly. There's a cognitive gap somewhere between chaining Maybes and then everything else
17:27:43 <Twey> isaacbw: So every action in Snap also implicitly takes and returns a Request
17:27:54 <Twey> isaacbw: You just don't understand the State monad
17:28:00 <isaacbw> yea
17:28:15 <Twey> isaacbw: Snap does also have IO underneath (that's why you can liftIO) but it's not relevant to getParam
17:29:18 <isaacbw> cool, I guess I'll read about the state monad then
17:30:27 <ReinH> isaacbw: read the LYAH chapter on State and try to actually follow along with the derivation. It helps.
17:30:33 <ReinH> Like, open ghci and try things out
17:31:07 <jle`> only you can't
17:31:18 <jle`> because mtl/transformers chjanged its interface
17:31:35 <jle`> so instead of using the State function, use state :)
17:31:48 * hackagebot tianbar 0.3.3.0 - A desktop bar based on WebKit  http://hackage.haskell.org/package/tianbar-0.3.3.0 (AlexeyKotlyarov)
17:34:02 <u-ou> ahhh
17:34:07 <u-ou> i'm going to read chapter 11 today
17:34:08 <u-ou> of lyah
17:34:47 <u-ou> but not without first drinking coffee
17:38:17 <isaacbw> ReinH: I go to lyah next, but so far this seems to be a really nice explanation: https://en.wikibooks.org/wiki/Haskell/Understanding_monads/State
17:38:46 <ReinH> isaacbw: yep, it's good. My main point is that you won't really understand it until you actually write code for/with it
17:39:06 <isaacbw> yea, definintely. I've got ghci open
17:39:11 <isaacbw> and am hacking away at it
17:41:54 <isaacbw> thanks everyone, you folks are awesome :D
17:49:11 <isaacbw> I've been completely nerd sniped by haskell. I haven't done *anything* else I'm supposed to be doing
17:49:44 <zoku> anyone want to help me write accelerate-blas?
17:49:46 <zoku> haha
17:50:54 <sipa> isaacbw: but are you supposed to be doing haskell?
17:52:01 <Twey> isaacbw: The best kind of procrastination
17:57:13 <zomg_> isaacbw: join the dark side :P
17:58:52 <ReinH> mission very much accomplished
18:02:30 <dmj`> if I want to remove all package installations out of my sandbox should I delete cabal/lib/x86_64-osx-ghc-7.6.3
18:02:42 <dmj`> and then ghc-pkg recache?
18:04:13 <geekosaur> dmj`, no
18:04:15 <zlatan> hi - I am wondering does haskell have an IDE/tool/software to easy create GUI apps (I saw co-worker create simulator in Visual Studio and while looking at code haskell can do it more simple/better I do not know about GUI thing)
18:04:18 <zlatan> ?
18:04:32 <geekosaur> that will leave a broken entry in ghc's package database, which is under ~/.ghc
18:05:08 <jmcarthur> for whoever cares, for raw throughput when not being used persistently, a simple banker's queue is over twice as fast as Data.Sequence.
18:05:28 <jmcarthur> i think that's the be expected, but it's confirmed
18:05:39 <jmcarthur> *to be expected
18:05:56 <dmj`> geekosaur: I'm using hsenv if that makes a difference
18:06:07 <sm> zlatan: no, that doesn't really exist yet
18:06:24 <geekosaur> it makes a difference but I don't know offhand where your ghc local package database will be
18:06:34 <geekosaur> `ghc-pkg list` should show it
18:06:43 <zlatan> sm, anything close (I don't mind some hard work/module calls etc)
18:06:43 <dmj`> jmcarthur: that's good news, I'm using Data.Dequeue. Do you have benchmarks to show?
18:07:02 <geekosaur> (global db is printed before the first set, local db before the second)
18:07:03 <zlatan> sm, or is there at least plan for something more GUI oriented
18:07:15 <dmj`> geekosaur: it's in .hsenv/ghc_pkg_db/
18:07:19 <jmcarthur> dmj`: it's a pretty rudimentary benchmark, but yes
18:07:31 <jmcarthur> dmj`: i'll lpaste for you
18:07:44 <dmj`> thanks!
18:07:46 <zlatan> sm, not to be confused - I actually create/use mostly CLI but support the nice looking/useful gui apps
18:08:11 <dmj`> geekosaur: what do you do when you want to start over? Just cabal sandbox delete?
18:08:20 <dmj`> or do you never start over :)
18:08:38 <sm> zlatan: there are a number of libraries for building GUIS with code, just no GUI layout tools. Well, I take that back. If you use the wxwidgets/gtk/qt libs for haskell, you can probably use the native layout tools of those frameworks
18:09:08 <jmcarthur> dmj`: http://lpaste.net/101222   and the implementation of the Banker's queue is included at the bottom
18:09:31 <jmcarthur> dmj`: it doesn't really test every possible use case, just the "average" case i had in mind where consumption rate matches production rate
18:09:50 <jmcarthur> dmj`: and like i said, only when not used persistently
18:10:11 <jmcarthur> dmj`: and not accounting for that bad worst case, since this is a cumulative throughput benchmark...
18:10:20 <zlatan> sm, okay, so some work work...but no native haskell GUI/complete IDE? :)
18:11:13 <sm> there are several haskell IDEs, but none with special support for GUIs
18:11:48 <zlatan> sm, you think on vim, emacs, yi, laskeh and lamdu? :)
18:12:32 <sm> also eclipsefp, ideah, fpcomplete haskell center
18:13:11 <zlatan> sm, (y) forgot about those :D trying to be an smartass but I suck :D
18:13:43 <sm> heh
18:15:13 <zlatan> sm, anyway thanks...I love this ch as it really is hospital and not ignoring or aggressive :) and I really think haskell rocks
18:15:45 <zlatan> also, is haskell really capable of doing anything/everything as other languages/codes :)
18:15:51 <sm> np. Anyway console apps are cooler, note vty-ui and wizards
18:16:56 * hackagebot ghc-mod 3.1.7 - Happy Haskell Programming  http://hackage.haskell.org/package/ghc-mod-3.1.7 (KazuYamamoto)
18:17:38 <zlatan> sm, yeah, but my official work requires windows gui apps (sometimes android/ios) and I am for years debian/linux users so I have some trouble :)
18:17:56 <zlatan> s/users/user
18:18:55 <sm> perhaps a web ui then ? threepenny-gui and git-annex-assistant are worth a look
18:20:07 <sm> see you
18:21:26 <zlatan> sm, git-annex I could to joeyh as I met him twice ( but I think he doesn't recall me) :D
18:21:36 <zlatan> joeyh, or do you :D
18:21:56 <zlatan> s/to/talk
18:21:59 <zlatan> :)
18:24:10 <Twey> zlatan: Qt works across X11, Cocoa, Windows, Android, and iOS, now
18:24:44 <Twey> I don't know how pleasant it is to get a Haskell-based program running on the mobile platforms, though; Cale probably has a better idea
18:24:57 <zlatan> Twey, and they are nice with haskell?
18:25:08 <zlatan> Twey, oh, okay :D
18:25:13 <Twey> No idea; never used them.  But it's something you might want to look into.
18:26:22 <zlatan> Twey, I made few C++ stuff years ago on Qt but as I am gnome/xmonad users I don't actually use that :/
18:26:34 <zlatan> what about gtk2hs?
18:27:02 <Twey> Qt is a nice toolkit, irrespective of your desktop environment
18:27:05 <zoku> i'm trying to do some GPU accellerated BLAS on haskell
18:27:09 <zoku> anyone have experience with such stuff?
18:27:10 <Cale> I actually didn't have to deal with that aspect directly. blackh (Stephen Blackheath) is the guy who took care of that for the most part. I believe that much of his work is becoming part of the new GHC release.
18:27:17 <Twey> GTK does not run on mobile platforms, as far as I know
18:27:26 <Cale> (well, he wasn't the only one who worked on the iPhone/ARM support)
18:28:44 <alpounet> zoku: i have the beginning of a binding to cublas, using accelerate
18:28:52 <Cale> Indeed, it seems that RC2 has included the iOS cross compiler binaries
18:29:04 <zoku> alpounet: do you have it online?
18:29:18 <zoku> alpounet: I was thinking about staring to work on the same thing
18:29:18 <Cale> There's a readme about that here: http://www.haskell.org/ghc/dist/7.8.1-rc2/README.ios.html
18:29:38 <alpounet> http://github.com/alpmestan/accelerate-blas -- i have the helpers (setting up a context etc) and level 1 done, but i got carried away a bit since I started this job
18:29:52 <zoku> awesome, thanks
18:29:57 <hiptobecubic_> alpounet, :)
18:30:06 <alpounet> zoku: i can give you commit rights and let you carry on from where i left if you want
18:30:07 <zoku> I'll let you know if I add anything
18:30:17 <zoku> yea if you'd like
18:30:26 <zoku> otherwise I'll just fork and send you pull reqs
18:31:04 <hiptobecubic> wow. Apparently i sent my self a message with lambdabot...
18:31:17 <hiptobecubic> lambdabot │ hiptobecubic asked 1y 6m 1d 15h 46m 51s ago: How does this work?
18:31:43 <hiptobecubic> Do the messages persist across lambdabots or is lambdabot's uptime *that* good?
18:32:05 <geekosaur> they're stored in State so as ling as that gets handed off it'll survive
18:32:35 <Cale> lambdabot has actually changed owners at least twice in that time frame
18:32:40 <alpounet> zoku: well it's unreleased work, so I don't mind either, just do what's easier for you and let me know how it goes, if you need help with smth etc.
18:32:45 <Cale> So, it definitely doesn't have that much uptime :)
18:33:01 <geekosaur> also uptime can matter to the extent that if it runs a long time and then crashes it may then reread a now stale State db
18:33:04 <zlatan> okay enough st.patricks celebration for tonight...time to sleep and get sober...thanks on all help :)
18:33:04 <alpounet> zoku: https://github.com/alpmestan/hs-cublas i forgot to mention this, this is the *raw* binding to cublas, whereas the other package is the accelerate interface
18:33:10 <geekosaur> (@flush can help with this)
18:33:36 <geekosaur> @uptime
18:33:36 <lambdabot> uptime: 4d 10h 39m 29s, longest uptime: 1m 10d 23h 44m 29s
18:34:38 <alpounet> zoku: both of the "-test.hs" files actually run fine on my laptop, with HEAD
18:34:41 <zoku> ah yea, that bit is useful too :)
18:35:05 <zoku> alpounet.cred++
18:40:30 <isaacbw> wow, the state monad is like imperative programming... but better
18:41:24 <thebnq> best imperative programming language
18:44:46 <isaacbw> do clients have a sense of the power of haskell? As in, would a haskell web shop be marketable?
18:46:26 <thebnq> not really
18:46:59 <thebnq> there are definitely sites using haskell though :)
18:47:23 <isaacbw> I guess you could be a developer's developer
18:48:00 <isaacbw> I might use haskell a startup
18:48:07 <isaacbw> I was planning on clojure, but this is all just too cool
18:48:37 <isaacbw> it all seemed incredibly impractical until this State monad business
18:48:45 <isaacbw> well, not incredibly, but decently impractical
18:49:07 <zomg> but what about poor IORefs and MVars?
18:49:07 <zomg> =)
18:49:23 <magicman> ReaderT (MVar a) IO b ftw!
18:49:31 <magicman> *cough*
18:49:44 <hpc> yeah, i think i am going to place myself in rare company here and say sometimes you just want a little mutation
18:50:25 <hpc> but yes, State is handy but a very general abstraction and there are other ways to manage state
18:50:43 <hpc> and you should learn a few, because sometimes one is more useful than another
18:50:51 <hpc> for nebulous and subtle reasons
18:51:38 <isaacbw> State at the very least is helping me grok monads, even if I don't need to implement stateful operations
18:51:58 <ReinH> It's really all about ST and StateT
18:52:36 <zoku> I am a noob who knows nothing of statet
18:52:39 <hpc> or if you do lots of interaction with the outside world, STM/IO
18:52:45 <zoku> any good intros?
18:52:53 <hpc> zoku: go through LYAH
18:53:06 <hpc> the chapters introduce concepts in the right order to not be overwhelming
18:53:09 <zoku> I thought I did
18:53:20 <zoku> maybe it was still being written
18:53:32 <hpc> maybe; that was the case when i was learning too
18:53:36 <isaacbw> so monads are this magic thing that does a bunch of magic stuff. It's just a common pattern that happens to be useful for solving lots of problems
18:53:38 <isaacbw> sound about right?
18:53:41 <isaacbw> *arne't
18:53:46 <hpc> there's a monad chapter now, and i forget if it covers transformers but it's a good start
18:53:48 <zomg> haha.. =)
18:54:02 <hpc> isaacbw: yes
18:54:22 <hpc> isaacbw: even less than that, Monad is the name of the interface that provides join
18:54:34 <ezrios> @let pairToList = ((++) <$> fst <*> snd) . over both return
18:54:35 <hpc> assuming that you first have pure and fmap
18:54:36 <lambdabot>  Defined.
18:54:41 <ReinH> isaacbw: except for the part about magic
18:54:46 <ezrios> is there a better way of doing this function?
18:54:52 <ReinH> monads are a thing that do stuff
18:54:59 <ReinH> that does stuff?
18:55:01 <ReinH> english is hard
18:55:02 <zomg> Yeah personally I find it easier to just think of monads as a common interface to do certain kinds of things
18:55:03 <hpc> ReinH: monads are things that contain stuff!
18:55:04 * hpc ducks
18:55:09 <ReinH> hpc: stahp
18:55:12 <thebnq> monads stuff :D
18:55:17 <ReinH> such monad wow
18:55:26 <zomg> Monads work by using... magnets!
18:55:27 <ReinH> very >>=
18:55:28 <hpc> very codes, confuse
18:55:33 <ReinH> wow
18:55:47 <hpc> join am bamboozle
18:55:55 <hpc> doge not compute
18:55:58 <isaacbw> I just have to keep doing :t (>>=) to remind myself THIS ISN'T SCARY
18:56:08 <ezrios> @let pairToList = ((++) <$> fst <*> snd) . over both return
18:56:09 <lambdabot>  .L.hs:151:1:
18:56:09 <lambdabot>      Multiple declarations of `pairToList'
18:56:09 <lambdabot>      Declared at: .L.hs:150:1
18:56:09 <lambdabot>                   .L.hs:151:1
18:56:12 <ezrios> > pairToList (3,4)
18:56:15 <lambdabot>  [3,4]
18:56:17 <hpc> isaacbw: perhaps a little perspective on what scary is...
18:56:24 <thebnq> lens>.<
18:56:24 <hpc> :t callCC
18:56:25 <ezrios> is there a nicer way of doing this pointfree?
18:56:25 <lambdabot> MonadCont m => ((a -> m b) -> m a) -> m a
18:56:30 <hpc> ;)
18:57:03 <hpc> isaacbw: don't think about that one too hard, or you might melt into your chair
18:57:18 <ReinH> ezrios: that seems like a weird way of doing f (a,b) = [a,b]? :p
18:57:37 <ezrios> ReinH: sure, I am looking for a pointfree solution though
18:57:42 <ReinH> ezrios: why?
18:57:44 <hpc> ReinH: it uses lenses; lens is webscale
18:57:48 <ezrios> ReinH: https://github.com/1HaskellADay/1HAD/blob/master/exercises/HAD/Y2014/M03/D13/Exercise.hs
18:57:52 <Cale> lol
18:57:54 <hpc> it can index all tuples, and it composes
18:58:07 <Cale> I'd just write (\(x,y) -> [x,y]) myself
18:58:09 <triliyn> :t fst
18:58:10 <lambdabot> (a, b) -> a
18:58:21 <hpc> you just (^.) and it composes right down
18:58:22 <Cale> It's easily clearer than any other solution
18:58:29 <ezrios> I would never write this sort of function seriously
18:58:35 <ezrios> it's more of a pointfree exercise
18:58:43 <ReinH> strange exercise is strange
18:59:36 <ezrios> well, at least it led me to revise the applicatives chapter in LYAH
18:59:50 <ezrios> it's like code golf
18:59:51 <hpc> revise?
18:59:56 <ezrios> *revisit
18:59:58 <ezrios> ._.
19:00:01 <hpc> BONUS, is that you? ;)
19:00:14 <geekosaur> we could only hope
19:00:25 <Twey> :t (***)
19:00:25 <lambdabot> Arrow a => a b c -> a b' c' -> a (b, b') (c, c')
19:00:39 <hpc> he's probably rtfing the same m as mmorrow
19:00:47 <Twey> :t uncurry (++) . (return *** return)
19:00:48 <lambdabot> (a, a) -> [a]
19:00:56 <ezrios> wa wa wee wa
19:00:58 <Twey> Look ma, no lenses
19:01:00 <isaacbw> what is this doing return x = State $ \s -> (x,s), doesn't State take a type, not a lambda?
19:01:06 <edwardk> bah
19:01:11 <Twey> Sorry, edwardk :þ
19:01:14 <ezrios> Twey: you have angered the gods
19:01:17 <dwcook> isaacbw, State there is a data constructor, not a type constructor
19:01:30 <hpc> isaacbw: welcome to the mixing of type and value levels!
19:01:31 <dwcook> Data and type constructors can share a name since they're referred to in different places
19:01:45 <hpc> (mental mixing, not code mixing)
19:01:48 <dwcook> s/places/contexts/
19:02:15 <Twey> ezrios: But the important bit is that  f <$> fst <*> snd  ≡  uncurry f
19:02:35 <hpc> isaacbw: it's worth noting that State as a value no longer exists, and is now just state
19:02:35 <ezrios> hum
19:02:42 <ezrios> Twey: I was staring at that function for a while but didn't get it
19:02:56 <hpc> state f = StateT (return . f)
19:03:01 <hpc> or something like that
19:03:02 <ezrios> or rather, I couldn't get it to work for pairToList
19:03:11 <ezrios> I guess arrows were the key here
19:03:40 <isaacbw> hpc: you mean the API changed?
19:03:44 <hpc> isaacbw: it's not a major thing, but just remember to switch it out when you try code samples
19:03:53 <isaacbw> I see
19:03:54 <Twey> ezrios: The top (ab)use for Control.Arrow is probably point-free trickery with the function arrow :þ
19:03:56 <hpc> isaacbw: the API changed all of a capital letter
19:04:14 <hpc> due to reasons that were very much needed
19:04:49 <hpc> State and StateT used to be separate types, now State is an alias for StateT
19:04:53 <isaacbw> so you do you still do State String String and that sort of thing, but use state where you would use the data constructor?
19:04:56 <hpc> and lots of definitions are unified
19:05:05 <hpc> yeah
19:05:21 <hpc> it's exactly the same from the outside other than that one capital letter
19:05:41 <hpc> LYAH is just a bit dated
19:05:50 <isaacbw> so State $ \s -> (x,s) knows what kind of State a b to use, based on x and s
19:06:03 <isaacbw> I'm not used to a language being smarter than me :P
19:06:18 <hpc> essentially, yes
19:06:28 <isaacbw> so much implicit
19:06:38 <hpc> you have a lambda, with type inferred from x and s
19:06:43 <isaacbw> from afar haskell looks like a pita, but up close, it does all the important bits for you
19:06:50 <hpc> in this case, (a -> (b, a))
19:07:03 <hpc> State :: (a -> (b, a)) -> State a b
19:07:07 <ezrios> isaacbw: haskell is a PITA but for your own good
19:07:13 <ReinH> Twey: how about the monkey face operator? uncurry (flip fmap (:[]) . (:))
19:07:24 <hpc> and unification fills in the pieces
19:07:46 <isaacbw> seriously, people talk about what programming will be like in the future
19:08:14 <isaacbw> but compared to most languages, this *is* the future. Alright, I'll stop being super duper excited now
19:08:18 <isaacbw> and just get back to reading :P
19:08:21 <Twey> ReinH: Oh, I thought the question asked for a *nicer* way to write it ;)
19:08:27 <isaacbw> (even though I know it's old as beans)
19:08:36 <ReinH> Twey: well there isn't a nicer way than \(a,b) -> [a,b] so...
19:08:43 <isaacbw> (still feels like crazy techno futuristic space magic)
19:08:46 <Twey> isaacbw: This is nothing compared to some of the stuff that's in research now :þ
19:08:58 <ezrios> isaacbw: functional ideas are gradually becoming more mainstream
19:09:07 <ezrios> the javascript community seems somewhat receptive to them
19:09:11 <Twey> ReinH: I don't know, I like the uncurry + (***).  I'd probably use that over a lambda.
19:09:19 * dwcook came here from JavaScript
19:09:37 <Twey> Though I'd probably define pairToList as an auxiliary and pattern-match it in general.
19:09:47 <ReinH> Twey: but ++ is inefficient... except it isn't here. Ok fine.
19:09:54 <isaacbw> there's only so much you can do with javascript
19:10:08 <ezrios> isaacbw: that is true, but it's pretty much all you have in the browser
19:10:10 <dwcook> I can now hardly stand to write JavaScript because I know how beautiful my code *could* be
19:10:49 <ReinH> Twey: you could join (***) return instead of (return *** return) if you want
19:12:51 <ezrios> so is lens looked down upon in the haskell community or something?
19:13:13 <copumpkin> no
19:13:19 <zomg> I thought lens was the amazing cool thing?
19:13:25 <dwcook> Odd, I've never got that impression. Just the opposite
19:13:25 <isaacbw> ezrios: do you have an opinion on the haskell based ->js languages? Elm, Purescript, Fay?
19:13:54 <ezrios> isaacbw: I don't know much about them
19:14:09 <ezrios> but I would venture to say that they aren't going to be quite as mature for web applications
19:14:16 <zomg> Fay is the only one of those that actually *is* Haskell
19:14:36 <zomg> It's quite usable too, has a few quirks you'll probably run into and spend hours banging your head on a wall
19:14:48 <zomg> but other than for those quirks which you'll eventually figure out, it's quite nice :P
19:14:49 <isaacbw> okay, so basically State is a wrapper of a function that defines type on it
19:14:55 <isaacbw> if that makes any sense
19:15:13 <isaacbw> a State *is* a function
19:15:36 <isaacbw> slowly making sense
19:16:29 <Twey> ReinH: I considered that, yes
19:16:30 <dwcook> That last thing you said is one way to put it
19:16:45 <dwcook> Namely, State s a is interchangeable with s → (a, s)
19:16:50 <ReinH> Twey: it saves so many characters.
19:16:57 <Twey> ReinH: I'd also be okay with ((: []) *** (: [])) or join (***) (: []).  Just not with moving it inside the uncurry.
19:17:04 <ReinH> heh
19:17:06 <ReinH> ok
19:17:15 <ReinH> Why don't you like the monkey face? (:[])
19:17:19 <ReinH> :p
19:18:43 <ReinH> > range (1,2)
19:18:44 <lambdabot>  [1,2]
19:18:48 <ReinH> Some of the time it works every time
19:21:18 <Twey> ReinH: I don't approve of unspaced operators
19:21:41 <ReinH> Twey: ah
19:21:43 <Twey> Unspaced operators are to blame for ‘negate’
19:21:54 <ReinH> subtract?
19:21:58 <Twey> And having to put brackets around all my negative integers
19:22:03 <ReinH> right
19:22:28 <Twey> (: []) is just a slightly longer monkey face, anyway.  :þ
19:22:50 <ReinH> heh
19:26:26 <magicman> @type ($ []) . uncurry ((.) `on` (:)) -- The dizzy monkey face.
19:26:27 <lambdabot> (a, a) -> [a]
19:26:43 <isaacbw> so if it's on the left side of an =, it's a type constructor, and on the right side a data constructor?
19:27:04 <ezrios> isaacbw: well, type constructors are sort of functions at the type level
19:27:10 <ezrios> they accept types and give you another type
19:27:36 <ezrios> data constructors give you "values" you can use in computation
19:28:06 <isaacbw> I'm trying to understand this line: let (a, newState) = h s
19:28:09 <isaacbw>                                         (State g) = f a
19:28:17 <ezrios> er
19:28:52 <isaacbw> within State's Monad instance
19:29:17 <ezrios> what page are you looking at?
19:29:23 <ezrios> is this from All About Monads?
19:29:38 <isaacbw> https://gist.github.com/isaacbw/9561005
19:30:09 <ezrios> basically you are pattern matching on the State value
19:30:14 <ezrios> and "unwrapping" the function inside
19:30:18 <Cale> isaacbw: Let's do a slightly better job of this
19:30:32 <Cale> (this way of writing the code is needlessly confusing)
19:30:38 <ezrios> applying the state to it, and getting a tuple containing a value and some new state
19:30:54 <ezrios> isaacbw: maybe this is a bit clearer? http://www.haskell.org/haskellwiki/All_About_Monads#The_State_monad
19:31:34 <Cale> So, the idea is that we want to represent computations which may act on a state value of some type s, before producing a result of type a
19:31:41 <Cale> and those computations will have type State s a
19:32:10 <Cale> A natural way to represent such a thing, given that we're working in a language with first class functions, is as a function from an initial state, to a pair consisting of a final state and result
19:32:28 <Cale> So we define  newtype State s a = S (s -> (s,a))
19:32:50 <Cale> and then to run such a computation on some initial state, we just have to unwrap the function and apply it:
19:32:57 <Cale> runState :: State s a -> s -> (s,a)
19:33:03 <Cale> runState (S f) s = f s
19:33:29 <Cale> isaacbw: Does that much make sense? (I'm going to rewrite (>>=) using this runState)
19:34:13 <Cale> x >>= f is supposed to be the computation which given an initial state s will first run the computation x
19:34:24 <Cale> getting some new state s' and result v
19:34:32 <Cale> and then run the computation f v, to get a final state and result
19:34:40 <Cale> So:
19:35:22 <Cale> x >>= f = S ... -- we don't have many ways to make state computations yet, so we pretty much have to use the S constructor
19:35:29 <isaacbw> alright, I'm following
19:35:43 <Cale> x >>= f = S (\s -> ...) -- the parameter to S is a function, so it might as well be a lambda, getting our initial state s
19:36:19 <Cale> x >>= f = S (\s -> let (s',v) = runState x s ...) -- we first run the computation x on the initial state s to get a new state s', and intermediate result v
19:36:56 <Cale> x >>= f = S (\s -> let (s',v) = runState x s; (s'',w) = runState (f v) s' ...) -- and then run the computation (f v) on the new state s'
19:37:18 <Cale> and this s'' and w are supposed to be our own final state and result, so...
19:37:26 <Cale> x >>= f = S (\s -> let (s',v) = runState x s; (s'',w) = runState (f v) s' in (s'', w))
19:38:06 <Cale> Cool?
19:38:34 <Cale> Of course, return is a fair bit easier: return v is supposed to be the computation which doesn't affect the state, and has result v
19:38:45 <Cale> So,  return v = S (\s -> (s,v))
19:39:48 <isaacbw> can you explain this? runState (f v) s' Isn't f of type State?
19:40:13 <isaacbw> ah, nevermind!
19:40:16 <isaacbw> I think
19:40:24 <Cale> x :: State s a
19:40:30 <Cale> f :: a -> State s b
19:40:49 <Cale> x is our initial computation to run first, and then f is a function which is going to decide what to do next by looking at the result of x
19:41:17 <Cale> and  x >>= f :: State s b
19:42:12 <isaacbw> alright
19:42:16 <isaacbw> definitely starting to udnerstand!
19:42:18 <isaacbw> thank you thank you
19:42:23 <isaacbw> *understand
19:45:17 <ezrios> Cale: can you recommend a good book after LYAH/RWH?
19:46:46 <Cale> ezrios: Depends on what you want to do after that point. Simon Marlow's newish book on concurrency seems really good
19:47:05 <Cale> http://chimera.labs.oreilly.com/books/1230000000929/index.html
19:47:19 <ezrios> Cale: I was thinking about that one, I skimmed over the first chapter and it seemed pretty well written
19:47:31 <ezrios> I think I'll give that one a go
19:47:40 <Cale> It also contains lots of stuff related to performance of single threaded code
19:48:08 <ezrios> would it be wise to read this without prior experience in parallel/concurrent programming though?
19:48:10 <Cale> (because you have to understand that stuff to begin to understand parallel performance of course)
19:48:14 <Cale> I think so
19:48:59 <Cale> Maybe not, but if not, then you can always ask questions here and people will probably be able to either answer your question or point you to something more basic about whatever you're stuck on.
19:49:33 <ezrios> well, I'll try it at least
19:49:36 <ezrios> thanks for the recommendation
19:50:06 <napping> about concurrency, is there any way to make an Async in an STM transaction?
19:52:37 <napping> I've written code a few times to cache results from IO by using something like TVar (Map Key (TMVar Result))
19:58:33 <isaacbw> so there's no way to end with just the value, right? Eventually I have a State which is never called?
19:59:04 <isaacbw> hrm
19:59:34 <isaacbw> I'm tired, it's probably time for bed
20:00:05 <Cale> isaacbw: In the end, you'll end up using State computations by applying runState to them along with an initial state value
20:00:51 <isaacbw> ah, of course
20:01:43 <isaacbw> beautiful! Thanks again Cale
20:01:51 <isaacbw> your help has been wonderful
20:02:01 <Cale> No problem :)
20:12:17 <aupiff> A
20:13:08 <aupiff> hello, how seriously should I take cabal's warnings that "the following packages are likely to be broken by the reinstalls"
20:14:06 <aupiff> I am just trying to install yesod-bin and yesod-platform, and cabal is warning me that conduit, warp, xmonad, fay... are likely to break
20:14:07 <zomg> aupiff: it's exactly what it says, it's very likely the packages it lists will break
20:14:07 <gamegoblin> :t runPT
20:14:08 <lambdabot>     Not in scope: `runPT'
20:14:09 <lambdabot>     Perhaps you meant `runST' (imported from Control.Monad.ST.Safe)
20:14:19 <gamegoblin> :t Text.Parsec.Prim.runPT
20:14:20 <lambdabot> Text.Parsec.Prim.Stream s m t => Text.Parsec.Prim.ParsecT s u m a -> u -> Text.Parsec.Pos.SourceName -> s -> m (Either Text.Parsec.Error.ParseError a)
20:15:05 <aupiff> zomg: how does one cleanly go about installing a package like yesod, then?
20:15:08 <gamegoblin> so runPT takes a Stream, parser, state, and sourcename, and returns an m (Either ParseError a). Is there any way I can get it to return what's left of my stream to me?
20:15:53 <zomg> aupiff: you can try adjusting the version so things won't break, or install anyway and be prepared to reinstall and fix all the broken packages =)
20:16:11 <zomg> there's also cabal sandboxing so you can have differnet versions
20:20:13 <aupiff> zomg: does fixing broken packages mainly entail adjusting other package's version numbers?
20:21:18 <hakujin> aupiff: for yesod specifically: try yesod-platform
20:22:00 <napping> aupiff: most likely just reinstalling. The root of the problem is that cabal/ghc can currently have only one version of a package around at a time
20:22:21 <napping> and a compile package only works with basically the exact version of other libraries it was compiled with
20:23:09 <dwcook> gamegoblin, you could combine your parser with a parser that eats the entire rest of the stream
20:23:30 <kardboardb> This is a bit of a long shot, but is anyone from FP Complete here? Creating new projects is completely broken.
20:23:31 <dwcook> (Not sure that's a good idea but it's what came to mind)
20:24:52 <c_wraith> kardboardb: chrisdone is a regular here, though maybe not around now
20:25:31 <napping> chrisdone works for FP complete now?
20:25:38 <kardboardb> c_wraith: Okay, thanks. I'll PM him; it seems like something he'd want to know.
20:26:40 <aupiff> hakujin: I am installing yesod-platform
20:26:54 <hakujin> using Attoparsec how would I write a parser that matches a string at an arbitrary location in the stream, and keeps the result? manyTill anyChar (string "foo" <|> string "bar") returns everything up to the "foo" or "bar" but consumes the foo/bar and disregards it
20:27:12 <hakujin> Parsec has lookahead that helps with this
20:27:14 <aupiff> napping: thanks, I'll play around with sandboxing.
20:28:02 <hakujin> manyTill anyChar is bad form in Attoparsec as well, but I don't know how to accomplish this using one of the takeWhle/takeTill parsers
20:29:47 <gamegoblin> dwcook: But what if the first parser fails
20:30:04 <gamegoblin> I want to get what's left of my stream no matter what
21:04:23 <meditans> a slight unusual question: I was thinkering on emacs + haskell-mode, playing with haskell-mode settings (I was setting up a vm so that haskell-mode was the only installed package)
21:05:01 <meditans> I touched something, and than I had this beautiful font in haskell files (i prefer unicode symbols for -> or () )
21:05:34 <meditans> the empty set symbol for () was larger than usual, and the -> symbol was bigger and more centered
21:06:21 <meditans> then I lost the setting, and wasn't able to recreate it. Do you have any idea (I know the question is vague, but I have turned customize-group upside down)
21:07:14 <Cale> Using the empty set for () would be weird
21:08:05 <Cale> () is a type with two values in it, one defined and one not
21:08:10 <meditans> Cale: mathematically, yes, but it's the default setting for haskell mode, and I begin to like it
21:08:18 <Cale> Really?
21:08:35 <shachaf> It's weird Haskelly as well as mathematically.
21:08:47 <meditans> shachaf: xd
21:09:18 <meditans> the point is, it was bigger and "beautifuller", for being an empty set
21:10:31 <meditans> but it's an interesting question how to render it properly, maybe I will find it in the .el files, just for the sake of denotational purity
21:12:55 <Kron> good luck meditans
21:19:26 <meditans> Kron: thanks, but I think, after giving a peek at the el file in question, that I'm not that fluent in elisp (or desperate enough) to try to change it
21:23:54 <Twey> ⊤ makes more sense
21:24:30 <Twey> Though ⊥ : ⊤ is also pretty weird :þ
21:26:56 <Cale> heh, yeah, () is what would be top if types were actually partially ordered
21:28:06 <shachaf> Or (exists a. a)
21:31:14 <stolaruk> How can I get QuickCheck to generate Data.Text values? Do I need to roll my own generator?
21:33:18 <Iceland_jack> stolaruk: You can use the String one and just pack it
21:33:38 <stolaruk> Iceland_jack: Haha, yes. So simple. Thanks.
21:34:16 <Iceland_jack> :t Data.Text.pack <$> arbitrary
21:34:17 <lambdabot> Gen Data.Text.Internal.Text
21:34:26 <Iceland_jack> To put too fine a point on it :)
21:34:41 <stolaruk> right
21:35:17 <stolaruk> :t arbitrary
21:35:18 <lambdabot> Arbitrary a => Gen a
21:45:28 <startling> Can I write an "instance SomeClass a => SomeClass (Either a b)" as well as an "instance SomeClass b => Someclass (Either a b)"? If not, can I do this with a type family or something?
21:45:28 * startling <- working with type-level lists of transformers
21:45:31 <Twey> startling: It's an IncoherentInstance
21:45:41 <Twey> startling: Which one do you pick when they're both SomeClass?
21:45:52 <startling> Twey, the first one
21:46:15 <startling> Or the second one. It doesn't matter much.
21:46:30 <Twey> That was a rhetorical question; whichever you prefer, the compiler doesn't have a way to choose in the general case and doesn't give you enough power to choose in special cases
21:46:42 <Twey> If it really doesn't matter, you could try turning on IncoherentInstances
21:46:59 <startling> It matters that it consistently chooses one. :)
21:47:41 <Twey> I don't think IncoherentInstances produces a consistent result for any useful definition of ‘consistent’
21:47:49 <startling> Alright, thanks anyway!
21:47:59 <startling> I feel like I can do this with type families; I should read up I guess.
21:48:02 <Twey> E.G. it's not stable with respect to η-expansion
21:48:14 <Twey> You can't
21:48:38 <Twey> The only way to do it is to explicitly specify which instance you want, which you can do by e.g. making them two separate classes
21:48:58 <Twey> Or adding another parameter to the class and making it an MPTC
21:49:05 <startling> Well, I mean something more like 'I feel like I can also solve my problem with type instances'/
21:49:15 <Twey> Ah, right
21:49:26 <Twey> I don't know what your more general problem is, so maybe :þ
21:49:49 <startling> The problem is "working with type-level lists of transformers is kind of hard". :<
21:50:18 <startling> Well, type-level n-ary transformer sums (if that makes sense?)
21:51:35 <Twey> startling: [(★ → ★) → ★ → ★] ?
21:52:09 <startling> Twey: yeah.
21:52:46 <Twey> What do you want to do with them?
21:53:16 <startling> My idea is to annotate ASTs and do things like "AST (Let ': s) v -> AST s v".
21:53:53 <startling> with e.g. data Let f a = Let (Scope () f a)
21:54:45 <startling> The thing is: it's a pain to go up and down the transformer stack, so I was trying to figure out a way to pull off something analogous to the MonadX transformer classes.
21:55:35 <startling> oh, hang on a minute.
21:55:36 <Twey> Sure, you can lift it
21:55:39 <Twey> No need for lists
21:55:50 <startling> Twey: right, but the lists are nice. :)
21:56:27 <startling> data Let f a = Let (Scope () f a) | Unlet (f a) might be productive.
21:56:47 <Twey> So the parameter to ‘AST’ is, what?  A complete list of the bindings passed so far?
21:57:37 <startling> Twey: no. a list of transformers that allow different types of AST nodes.
21:59:10 <Twey> Ah, right, you're breaking the AST up into different parts
21:59:40 <startling> Yeah, so that I can have nice types + guarantees for AST transforms.
22:00:27 <Twey> Got it.  Yeah, that looks about right.
22:16:17 <xpika> in ghci wast is the keyword for the last evaluated expression?
22:16:53 <Iceland_jack> it
22:18:29 <xpika> Iceland_jack: ta
22:19:28 <augur_> another coup for FP: notch
22:20:50 <xpika> yes, i agree, first person games are really good.
22:21:49 <Ralith> and getting better still!
22:21:53 <Ralith> lookin' at you, oculus rift
22:25:25 <augur_> but importantly, getting well-respected names in game programming to be interested in FP is a PR coup
22:26:16 <ndeine_> names #cnulug
22:26:20 <ndeine_> goddamnit
22:27:00 <nisstyre_> augur_: we already have Tim Sweeney and John Carmack, who else is there?
22:27:14 <augur_> nisstyre_: as i said, Notch just got sold on it
22:27:16 <augur_> by Carmack
22:27:32 <nisstyre_> so is he rewriting minecraft in Haskell?
22:27:41 <augur_> haha. well, he doesnt know FP yet!
22:28:00 <augur_> he just said he should learn some functional programming cause carmack showed him how awesome it was
22:28:07 <nisstyre_> fair enough
22:28:15 <erisco> I wonder what Carmack likes about it
22:28:18 <erisco> anything FRP-related?
22:28:22 <nisstyre_> erisco: he likes the purity
22:28:23 <augur_> erisco: no
22:28:28 <ndeine> I've always thought of writing games in Haskell as having to be pretty hard
22:28:36 <ndeine> how do you build something interactive?
22:28:40 <augur_> apparently he really likes the lack of mutable state because it makes things like updates nicer
22:28:56 <tar_> he's been trying to prove his games' correctness for a while
22:29:04 <nisstyre_> he likes the purity because it means less spooky action at a distance and the static types for finding bugs
22:29:04 <augur_> tar_: wowzers
22:29:12 <tar_> to help their large teams in check, using various C++ verification tools
22:29:12 <augur_> erisco: you should watch his keynote talk
22:29:27 <erisco> that's fair. afaik purity is ideal for concurrency, and in games concurrency can make or break your performance
22:29:34 <erisco> and Carmack is all about new technologies
22:29:45 <nisstyre_> erisco: a lot of their code is single threaded for that reason apparently
22:29:45 <tar_> "new" :)
22:30:17 <nisstyre_> erisco: Carmack has historically been about inventing new tech
22:30:25 <nisstyre_> e.g. sidescrolling on the PC
22:30:25 <Twey> ndeine: Well, there are the usual ways
22:30:27 <augur_> erisco: https://www.youtube.com/watch?v=1PhArSujR_A is what i get from youtube and google
22:30:41 <augur_> but i think its a lot more than just that bit, i dont know
22:30:42 <Twey> ndeine: But we also have FRP, which is a much nicer framework for interactivity
22:31:07 <erisco> I wonder what he thinks about the memory consumption... a games programmer often appreciates low-level efficiency
22:31:31 <ndeine> Twey: Thanks, I'll look into FRP
22:31:39 <nisstyre_> erisco: ask him on twitter, or look at what he's said
22:31:45 <nisstyre_> I'm sure he has addressed it somewhere
22:31:51 <ndeine> Twey: I'm pretty darn new to Haskell; have yet to build anything useful with it.
22:32:08 <erisco> ndeine, I just looked at it a couple days ago and I found that Sodium is a wonderfully simple library for FRP
22:33:14 <Twey> ndeine: Haskell has a fairly normal imperative language embedded in it (the ‘IO’ type).  In the worst case, you can always write programs in IO pretty much exactly the same as you would in an imperative language.
22:33:29 <Twey> ndeine: The only reason we don't do so is that there are usually other ways that are better ☺
22:34:54 <MP2E> Hmm, with state machines it seems the key is abstracting as much of the pure functionality as possible from the "tainted" bits
22:35:38 <spacekitteh> hey so like, i am trying to figure out these compile errors while using type lits. i have ScopedTypeVariables enabled, but yeah.http://lpaste.net/101231
22:35:48 <Twey> MP2E: Hmm?  You can implement pure state machines purely
22:36:02 <MP2E> Huh, good to know
22:36:27 <ndeine> Twey: does stuff like the State monad count as pure?
22:36:36 <Twey> ndeine: Yes
22:37:16 <Twey> ndeine: The State apparatus is just a set of convenience functions to capture a particular pattern of passing arguments to functions
22:37:25 <Twey> There's nothing impure or magical about it
22:40:24 <Ralith> augur_: idk, notch is not really known for his good technical judgement...
22:40:36 <augur_> Ralith: well there's always a start!
22:44:00 <i_s> can anyone explain this? http://pastebin.com/SqP0Lncm having a problem making a concat function with foldr
22:45:51 <augur_> erisco: carmack is hugely in favor of strong static typing, too.
22:46:06 <erisco> I hope that most people who work on huge code bases are
22:46:16 <Twey> i_s: GHC is right.  ☺
22:46:24 <augur_> erisco: he also says empirical as "empire-ical"
22:48:40 <Twey> i_s: Your input is of type [[a]], so x has type [a] (it's each element of the [[a]]) and acc has type [b] (because that's the type of []).  So x : acc has type [[a]], which unifies with [b] as b = [a], giving your foldr a return type of [[a]].  But your type signature says that you'll return something of type [[a]], so GHC tells you you're being daft.
22:49:07 <Twey> > foldr (\x acc → x : acc) [] [1, 2, 3, 4]
22:49:08 <lambdabot>  [1,2,3,4]
22:49:17 <Twey> i_s: You actually produced id for lists.  ☺
22:49:26 <Hafydd> Oh god.
22:49:36 <Hafydd> You're using Unicode faces now, too.
22:50:43 <Twey> Hafydd: ‘Now’?  :þ
22:51:15 <bitemyapp> unicode symbols are way too tiny.
22:51:20 <Twey> i_s: your type signature says you'll return something of type [a] **  sorry
22:51:28 <Twey> bitemyapp: Unicode doesn't specify a font size.  ;)
22:51:51 <Iceland_jack> I embed unicode smileys for noses in other smileys :☻)
22:52:06 <Twey> Smileyception.
22:52:12 <Iceland_jack> :☹(
22:52:30 <i_s> thanks Twey. i'm trying to understand what you wrote, but i'm very new, so it will take me a while.
22:53:40 <Hafydd> If I could configure my terminal to display such symbols as double-width characters, they might more readable.
22:54:08 <Hafydd> But I feel that might fuck up some text-layout algorithms.
22:54:53 <zenkeku> @paste
22:54:53 <lambdabot> Haskell pastebin: http://lpaste.net/
22:57:07 <zenkeku> After this program runs in GHCi I am unable to type anything else. I receieve this error from GHCi after killing GHCi: <stdin>: hGetChar: end of file
22:57:13 <zenkeku> http://lpaste.net/101232 ^
22:58:37 <startling> Is there a polykinded Const somewhere?
22:59:13 <zenkeku> startling: Are you asking me?
22:59:30 <startling> zenkeku: no.
23:01:57 <augur_> erisco: ah yes, part 5 also has some discussion of haskell as well
23:02:40 <gamegoblin> I have a bytestring that I know is entirely ascii digits. Fastest way to convert it to an Int?
23:02:48 <gamegoblin> something akin to read
23:03:10 <gamegoblin> there is of course (read . unpack) but I am wondering of a faster way
23:06:29 <geekosaur> there's something in the evil version: http://lambda.haskell.org/platform/doc/current/ghc-doc/libraries/bytestring-0.10.0.2/Data-ByteString-Char8.html#v:readInt
23:06:56 <gamegoblin> so I could just fromJust that...
23:07:12 <gamegoblin> I have this guarantee because I literally just attoparsec'd takeWhile1 isDigit
23:07:17 <gamegoblin> Still smells
23:07:52 <gamegoblin> good call though
23:08:40 <kazagistar> gamegoblin: faster in what way? I mean, you could foldmap and convert from ascii with (-'0') or something horrible?
23:09:12 <gamegoblin> kazagistar: that's something I was considering
23:09:45 <gamegoblin> Another question: best way to toLower or toUpper an entire bytestring?
23:10:08 <geekosaur> actually, considering that its only available for char8 it probably *is* something like read . unpack
23:10:16 <geekosaur> *it's
23:10:59 <kazagistar> presumably read . unpack is going to generate some pretty optimal code anyways?
23:11:11 <Twey> read won't
23:11:18 <Twey> read is a full-blown parser
23:11:53 <gamegoblin> I thought I might be able to do some super low level hacking since I know that they are all ascii digits
23:12:03 <Twey> > read "((-3))" ∷ Int
23:12:04 <lambdabot>  -3
23:12:05 <gamegoblin> do a bunch of -'0' s and multiply by powers of ten
23:12:22 <gamegoblin> But I imagine it really doesn't matter much at all
23:12:26 <gamegoblin> just optimization fun
23:12:57 <Twey> sum . zipWith (*) (iterate (* 10) 1) . reverse
23:13:00 <Twey> Or something
23:13:11 <Twey> Data.Char has digitToInt
23:13:28 <gamegoblin> Mmmm that's good
23:13:30 <Twey> Which is just chr . subtract (ord '0') . ord
23:14:15 <kazagistar> haha, it all comes back to subtracting '0' I guess
23:14:20 <Twey> > sum . zipWith (*) (iterate (* 10) 1) . reverse . map digitToInt $ "1234"
23:14:21 <lambdabot>  1234
23:14:54 <startling> > digitToInt 'a'
23:14:55 <lambdabot>  10
23:14:57 <Twey> If you can use ByteString methods to avoid going via a list you'll get a boost
23:14:59 <startling> heh.
23:15:14 <startling> > digitToInt 'z'
23:15:15 <lambdabot>  *Exception: Char.digitToInt: not a digit 'z'
23:15:19 <Twey> > map digitToInt "fg"
23:15:20 <lambdabot>  [15,*Exception: Char.digitToInt: not a digit 'g'
23:15:21 <startling> aw.
23:15:47 <startling> A shame.
23:16:54 <Twey> The weird thing is, we have showIntAtBase but no readIntAtBase
23:17:43 <Twey> > showIntAtBase 12 ("0123456789XƐ" !!) 579
23:17:44 <lambdabot>  <[Char] -> [Char]>
23:17:54 <Twey> > showIntAtBase 12 ("0123456789XƐ" !!) 579 ""
23:17:55 <lambdabot>  "403"
23:18:04 <Twey> > showIntAtBase 12 ("0123456789XƐ" !!) 11 ""
23:18:05 <lambdabot>  "\400"
23:18:14 <Twey> > text $ showIntAtBase 12 ("0123456789XƐ" !!) 11 ""
23:18:15 <lambdabot>  Ɛ
23:18:19 <gamegoblin> lol
23:19:14 <kazagistar> oh god, the dozenal society is everywhere
23:23:40 <Twey> We are legion!  Or at least several dozen
23:24:44 <dwcook> A ping timeout on your kin!
23:24:59 <gamegoblin> jesus christ what's up with this
23:25:14 <MP2E> FreeNode is exploding or something holy shit
23:25:14 <dwcook> gamegoblin, netsplit
23:25:20 <dwcook> (I think)
23:25:30 <gamegoblin> The Great Purge
23:25:40 <MP2E> The non-believers shall burn
23:26:02 <MP2E> give your soul to the lamda
23:26:04 <MP2E> lambda*
23:26:18 <gamegoblin> I actually wrote an FP version of the lords prayer a few months ago
23:26:23 <MP2E> ahah
23:27:16 <gamegoblin> Our Language who art in Functions, Hallowed be thy name
23:27:26 <gamegoblin> Thy lambdas come, thy recursion be done in stack, as it is in heap
23:27:43 <gamegoblin> Give us this day our daily abstractions, and forgive us our imperative pasts, as we forgive those who code in Java
23:28:02 <gamegoblin> And lead us not into C, but deliver us from segfaults; For thine is the Haskell, and the Scheme, and the Clojure for ever, Amen.
23:34:02 <gamegoblin> > Data.ByteString.unpack (Data.ByteString.empty)
23:34:03 <lambdabot>  Not in scope: `Data.ByteString.unpack'Not in scope: `Data.ByteString.empty'
23:41:55 <erisco> where does FRP stand with parallelism/concurrency? are there libs which already do this?
23:54:13 <Twey> erisco: I think you can just call reactive-banana's event handlers from a different thread
23:54:43 <erisco> Twey, do updates block though?
23:55:44 <eeezkil> anyone familiar with prolog?
