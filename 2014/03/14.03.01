00:03:07 <irssi> luite: awesome to see it actively being worked on
00:06:51 <irssi> luite: is there a workaround at the moment? it doesn't seem to be considered installed after cabal build
00:09:21 * hackagebot check-pvp 0.0 - Check whether module and package imports conform to the PVP  http://hackage.haskell.org/package/check-pvp-0.0 (HenningThielemann)
00:09:21 * hackagebot shelly 1.4.4.2 - shell-like (systems) programming in Haskell  http://hackage.haskell.org/package/shelly-1.4.4.2 (GregWeber)
00:16:31 <Saizan> irssi: try "cabal install --only" too
00:19:06 <irssi> i've been manually extracting and editing the .cabal file before running cabal install
00:19:30 <irssi> now i've got a different issue with jmacro (i'm trying to get the ghcjs-hello example working)
00:21:39 <luite> irssi: sorry, don't have a workaround ready, but if you do something like args <- getArgs; when ("--install-executable" `elem` args) exitSuccess  (in src/bin/Main.hs before jumping to the actual compiler) it should at least let Cabal continue
00:21:56 <luite> src-bin/Main.hs that is
00:37:36 <luite> irssi: you need ghc 7.8.1 rc2 or newer to have a stable (non-segfaulting) ghcjs by the way
00:44:58 <hellwolf> "data Range = Between from to | From from | All" and "f From from = f Between from to", how can I assign to in a way that I can construct a infinite [from..to] which looks like [from..]
00:45:28 <milfjord> that's a precedence error
00:47:41 <Axman6> hellwolf: set to to maxBound? from the Bounded class
00:47:51 <Axman6> > maxBound :: Int
00:47:52 <lambdabot>  9223372036854775807
00:48:06 <milfjord> oh, and that type definition is invalid
00:48:19 <hellwolf> sorry, it's "data Range = Between Integer Integer | From Integer | All"
00:48:41 <hellwolf> let f (Between from to) = [from..to]
00:48:53 <milfjord> then you can't
00:49:01 <hellwolf> ok :(
00:50:21 <hellwolf> was hoping for "let f (From from) = f Between from 1000 -- what to replace 100"
00:51:22 <no-n> what
00:51:38 <EcoGiko> Hi, installing haskell has been a nightmare and I can't find much clues as to how to solve a compilation problem, anyone want to help me out?
00:55:08 <EcoGiko> My latest make error states: Perhaps you haven't installed the profiling libraries for package `mtl-2.1.2'? I have no idea how to install the profiling libraries for mtl-2.1.2
00:55:44 <irssi> what exactly do you mean by installing haskell?
00:56:14 <joelteon> EcoGiko: try reinstalling mtl with profiling enabled.
00:56:25 <milfjord> EcoGiko: what make error?
00:57:20 <EcoGiko> joelteon: I edited the .cabal cfg to -- library-profiling: False and made cabal reinstall world, still the same error
00:57:57 <EcoGiko> milfjord: http://lpaste.net/100564
00:58:28 <hellwolf> ok, I guess  if I add one more constructor then it's easier to for me to define the function "data Range = In [Integer] | Between Integer Integer | From Integer | All". The "actual" function will reply on "In [Integer]" constructor
00:59:13 <EcoGiko> I have installed ghc linux binaries and downloaded the haskell platform, in the ./configs I have --prefix only on the haskell platform one. Could that affect it?
01:01:23 <joelteon> EcoGiko: specify "library-profiling: True"
01:01:32 <joelteon> I *think* profiling is off by default
01:01:36 <joelteon> which is a really bad idea in my opinion
01:01:39 <EcoGiko> it was
01:01:45 <joelteon> oh was it?
01:02:19 <EcoGiko> my default config http://lpaste.net/100565
01:02:19 <irssi> http://pastebin.com/aGjXyABu
01:02:41 <joelteon> it was True before?
01:03:42 <EcoGiko> it was on False on default. I changed it to true after the error and reinstalled world. Still the same error
01:04:22 <joelteon> interesting
01:05:13 <EcoGiko> is this the correct command to use after altering the cfg $ cabal install --reinstall world
01:06:12 <dcoutts_> EcoGiko: you did uncomment the library-profiling line right?
01:06:20 <EcoGiko> dcoutts_: uncomment?
01:06:35 <EcoGiko> dcoutts_: how do I uncomment in the cfg
01:06:45 <EcoGiko> dcoutts_: oh...
01:06:53 <dcoutts_> EcoGiko: see the file it says:
01:07:10 <dcoutts_> -- Some of them have default values listed.
01:07:10 <dcoutts_> -- Lines (like this one) beginning with '--' are comments.
01:07:22 <EcoGiko> dcoutts_: I am uncommenting it, what should it be set to?
01:07:33 <dcoutts_> you want library profiling turned on
01:08:12 <EcoGiko> ok, editted it and I am reinstalling now
01:10:22 <EcoGiko> dcoutts_: now I can't even install it -> http://lpaste.net/100566
01:11:31 <dcoutts_> EcoGiko: actually 'world' target is not enough because that only records things you asked to be installed, not their dependencies that you didn't care about
01:11:58 <EcoGiko> dcoutts_: how can I reinstall everything?
01:12:19 <dcoutts_> EcoGiko: the easiest thing is to rm -r ~/.ghc  and then do it (ie starting from clean)
01:13:30 <EcoGiko> dcoutts_: as in, reinstalling everything from the ground up?
01:14:03 <dcoutts_> EcoGiko: it's the same principle you were trying with 'world', but would actually work
01:17:52 <EcoGiko> dcoutts_: I just purged all of ghc and starting all over now.
01:20:42 <EcoGiko> dcoutts_: I just reinstalled ghc 7.6.3 from binaries, what should I do now?
01:21:18 <dcoutts_> EcoGiko: erm, there was no need to do that, I only said rm -r ~/.ghc
01:21:37 <dcoutts_> EcoGiko: so if you reinstalled ghc, then you still need to rm -r ~/.ghc
01:21:45 <EcoGiko> dcoutts_: I did it anyway. I did both
01:22:05 <dcoutts_> ok, well just so you know that was unnecessary
01:22:18 <EcoGiko> ok, thanks.
01:22:25 <dcoutts_> EcoGiko: now you can do the original install you were after
01:22:40 <dcoutts_> since you've enabled profiling now
01:23:49 <no-n> @src isPrefixOf
01:23:49 <lambdabot> isPrefixOf [] _          = True
01:23:49 <lambdabot> isPrefixOf _  []         = False
01:23:49 <lambdabot> isPrefixOf (x:xs) (y:ys) = x == y && isPrefixOf xs ys
01:23:57 <dcoutts_> EcoGiko: so you understand what's going on, your per-user packages are registered in a db under ~/.ghc
01:24:14 <dcoutts_> EcoGiko: so uninstalling or reinstalling ghc does not affect those files in your home dir
01:25:03 <EcoGiko> dcoutts_: oh...I get it.
01:26:31 <irssi> oh
01:26:56 <irssi> just noticed the packages directory in ghcjs.github.com repo. maybe that could be made more prominent, luite
01:28:10 <EcoGiko> dcoutts_: awesome, I passes all the error points!
01:28:50 <EcoGiko> what is library profiling? why was it causing me troubles?
01:29:26 * hackagebot check-pvp 0.0.1 - Check whether module and package imports conform to the PVP  http://hackage.haskell.org/package/check-pvp-0.0.1 (HenningThielemann)
01:31:53 <dcoutts_> EcoGiko: presumably you were trying to profile something right?
01:32:15 <dcoutts_> EcoGiko: profiling mode is a separate ABI and so libs need to have both normal and profiling versions installed
01:32:45 * dcoutts_ disappears
01:33:46 <EcoGiko> dcoutts_: By profiling you mean installing the linux x84 ghc? If that is so then its clean to me that I needed the specific libraries as well. So if I compile from source then it should work without profiling? Thanks for the help!
01:35:10 <milfjord> EcoGiko: no, profiling means running a program and measuring which parts take how long
01:38:18 <no-n> @pl f s = article s ++ " " ++ s
01:38:18 <lambdabot> f = liftM2 (++) article (' ' :)
01:38:35 <no-n> that function body looks happy
01:38:42 <FreeFull> :)
01:38:46 <no-n> hehe
01:39:51 <hellwolf> something mysterious about ghci.. "primes = sieve [2..]
01:39:51 <hellwolf>   where
01:39:51 <hellwolf>     sieve (p:xs) = p : sieve [x|x <- xs, x `mod` p > 0]" I run this once "take 1 $ drop 10000 $ primes" it took some 10 seconds, I ran second time it took 0 second. How did the magic optimization kick in??
01:40:09 <joelteon> first evaluation forces that list
01:40:12 <joelteon> now it's in memory
01:40:26 <FreeFull> hellwolf: It's called sharing
01:41:09 <FreeFull> Note that generating 10000 primes took that long because that sieve isn't very efficient
01:41:12 <ion> hellwolf: When you give a name to a monomorphic value, its evaluated parts stay in memory as long as the name is in scope.
01:41:54 <hellwolf> nice. is there a ghci command I can flush away these, and try again? Just curious
01:42:19 <ion> You could redefine primes.
01:42:49 <FreeFull> If the definition is in a file, not sure if :r would get rid of the evaluated thunks or not
01:42:59 <FreeFull> That's something to test I suppose
01:43:53 <hellwolf> :r didn't work. but :load actual file makes the reevaluation
01:44:28 * hackagebot glib 0.12.5.3 - Binding to the GLIB library for Gtk2Hs.  http://hackage.haskell.org/package/glib-0.12.5.3 (HamishMackenzie)
01:44:30 * hackagebot gio 0.12.5.3 - Binding to the GIO.  http://hackage.haskell.org/package/gio-0.12.5.3 (HamishMackenzie)
01:44:32 * hackagebot cairo 0.12.5.3 - Binding to the Cairo library.  http://hackage.haskell.org/package/cairo-0.12.5.3 (HamishMackenzie)
01:44:34 * hackagebot pango 0.12.5.3 - Binding to the Pango text rendering engine.  http://hackage.haskell.org/package/pango-0.12.5.3 (HamishMackenzie)
01:44:51 <FreeFull> hellwolf: Another example of sharing is    fibs = 0 : 1 : zipWith (+) fibs (tail fibs)
01:45:07 <FreeFull> Although that is far more efficient than the prime numbers example
01:46:05 <hellwolf> I have another primes3 function which takes in a list and output primes in the list. "*Main> :t primes3
01:46:05 <hellwolf> primes3 :: [Integer] -> [Integer]" This didn't enjoy any "sharing" though
01:47:10 <milfjord> what do you mean, another function?
01:47:15 <milfjord> the other one was a list, not a function
01:47:49 <hellwolf> I meant primes3 is a function, is it not?
01:48:09 <hellwolf> http://pastebin.com/bLWvSQ7Z
01:48:40 <milfjord> primes3 is but primes is not
01:49:17 <hellwolf> huh?
01:49:36 * hellwolf having the huskellish confusing moment
01:49:45 <milfjord> what is confusing?
01:50:05 <hellwolf> "primes is not"
01:50:19 <milfjord> what's confusing about that?
01:50:23 <hellwolf> primes = ... <-- I have my naive definitino of what is a function
01:50:34 <milfjord> a function is something with -> in its type
01:50:48 <milfjord> something you can apply to an argument
01:50:55 <milfjord> a list is not a function
01:51:31 <hellwolf> thank you!
01:51:36 <hellwolf> *Main> let a=primes3 [2..]
01:51:41 <hellwolf> *Main> take 1 $ drop 2000 $ a
01:51:41 <hellwolf> [17393]
01:51:41 <hellwolf> (4.40 secs, 863823604 bytes)
01:51:41 <hellwolf> *Main> take 1 $ drop 2000 $ a
01:51:42 <hellwolf> [17393]
01:51:42 <jle`> it's just a value
01:51:44 <hellwolf> (0.00 secs, 517984 bytes)
01:51:46 <hellwolf> :)
01:51:49 <cpa> how do I compare Int#? (<) throws a type error. http://lpaste.net/100568
01:51:50 <jle`> well functions are values
01:51:58 <jle`> but yeah, you get the picture
01:52:04 <hellwolf> milfjord, you made it very clear, thanks
01:52:23 <jle`> cpa: i think it's <# or something like that
01:52:32 <milfjord> cpa: that looks like a kind error, not a type error
01:53:16 <cpa> milfjord: indeed but I don't know the # kind, what is it? Kind of unboxed stuff?
01:53:20 <hellwolf> but, just thinking about it more, would it make sense for compiler actually shares "primes3 [2..]" in "take 1 $ drop 2000 $ primes3 [2..]"?
01:53:34 <cpa> jle`: I'll try thanks
01:54:09 <milfjord> cpa: yes
01:54:17 <shachaf> It's not just "kind of" unboxed!
01:54:31 <shachaf> Anyway, I think the GHC.Prim documentation covers this.
01:55:06 <maybefbi> Anybody here who have used SBV SMT Solver?
01:55:32 <maybefbi> I want to know how to write a symbolic constant 0
01:55:44 <maybefbi> of type SInteger
01:56:55 <johtso_> How can you avoid things getting overly verbose when using Maybe and pattern matching? http://lpaste.net/1205606030180876288
01:57:04 <hooplahoops> Hello, how does Haskell find a typeclass instance for some value at runtime, when the declared type is abstract?
01:57:34 <milfjord> hooplahoops: huh?
01:58:18 <hooplahoops> milfjord: let's say I have a function with type f :: (Ord a) => a -> Bool , how does it find the right Ord instance at runtime?
01:58:28 <jle`> there is only one Ord instance
01:58:37 <jle`> (per type)
01:58:50 <jle`> if that's what you mean
01:58:55 <milfjord> hooplahoops: it's passed in as an argument
01:59:04 <hooplahoops> Right, but one type may have multiple different typeclass instances of different type class declarations
01:59:12 <hooplahoops> milfjord: that's what i would expect
01:59:26 <hooplahoops> milfjord: my confusion is when you call it from some other generic function, e.g. (map f xs)
01:59:29 * hackagebot gtk3 0.12.5.3 - Binding to the Gtk+ graphical user interface library.  http://hackage.haskell.org/package/gtk3-0.12.5.3 (HamishMackenzie)
01:59:31 * hackagebot tdoc 0.4.4 - TDoc is a typed document builder with support for (X)HTML  http://hackage.haskell.org/package/tdoc-0.4.4 (NicolasPouillard)
01:59:33 * hackagebot gtk 0.12.5.3 - Binding to the Gtk+ graphical user interface library.  http://hackage.haskell.org/package/gtk-0.12.5.3 (HamishMackenzie)
01:59:46 <milfjord> data Ord a = Ord{ compare :: a -> a -> Ordering }
01:59:56 <luite> irssi: oh, jmacro hasn't been updated to work with ghc 7.8 yet. we used to have a patched version in our dependencies, but since it started to diverge too much from the original jmacro, the parts we needed are now in the ghcjs package
02:00:05 <milfjord> ord_instance_Int = Ord { compare = ... }
02:00:23 <milfjord> and f is effectively f :: Ord a -> a -> Bool
02:00:28 <luite> irssi: unfortunately ghcjs-hello still depends on jmacro
02:01:00 <luite> irssi: i did fix the weblog examples earlier this week (or at last got them to compile again)
02:01:06 <milfjord> hooplahoops: when the type is nailed down enough, the type checker can select the right instance
02:01:26 <milfjord> it probably turns into map (f ord_instance_Int) xs there
02:01:59 <hooplahoops> milfjord: oh right I see
02:02:19 <hooplahoops> milfjord: so the type checker will propagate those contraints "down", and then make sure it packs the data when it still knows the concrete type
02:02:31 <milfjord> yeah
02:02:48 <milfjord> > show undefined
02:02:49 <hooplahoops> Ah very cool
02:02:50 <lambdabot>  "*Exception: Prelude.undefined
02:02:56 <milfjord> heh, extended defaulting
02:03:06 <hooplahoops> milfjord: So it would actually pack a little closure there?
02:03:16 <milfjord> I think so
02:03:27 <milfjord> or maybe it outright specializes the function? no idea
02:03:47 <hooplahoops> Yeah either would work :) Ok
02:06:25 <jle`> johtso_: do you have any sort of pattern?
02:06:46 <johtso_> jle`, how do you mean?
02:07:02 <hooplahoops> Now, I have another newbie question, this time about lazyness. There's an example in http://learnyouahaskell.com/making-our-own-types-and-typeclasses under 'recursive data structures' about a binary search tree, where you produce a new tree for every insertion, and lazyness makes sure perform isn't horrid.
02:07:23 <hooplahoops> My question is, would it allocate a thunk at every level of the tree when you subsequently read a path through the tree? And would it also allocate new no des on the heap for every node traversed?
02:07:30 <shachaf> I'm not sure that laziness has that much to do with it.
02:08:00 <jle`> johtso_: like can you simplify your function?
02:08:07 <jle`> or are you looking for an easier way to just define all of that
02:08:10 <jle`> hm
02:08:10 <hooplahoops> shachaf: what do you think has to do with good performance in this case?
02:08:12 <jle`> i think
02:08:18 <jle`> one way
02:08:24 <jle`> would be first to check if the first is Nothing
02:08:36 <jle`> and then once you know it's not, you can use liftA2 or <$>/<*>
02:08:45 <jle`> and and lift
02:08:46 <jle`> perhaps
02:08:56 <shachaf> Sharing, I guess? Good performance as compared to what, copying the entire tree every time you change it?
02:09:07 <jle`> but the function itself seems to be inherently entropic/messy so you can't do too much to shorten it
02:09:32 <hooplahoops> shachaf: basically log(N) insertion and lookup time, is what I would compare it to
02:09:51 <jle`> or you could even use flip fmap or something
02:09:52 <hooplahoops> It would clearly have that, but I'm wondering how much allocation it would have to do
02:10:04 <jle`> that way you can use pure functions instead of Maybe functions
02:10:21 <jle`> but you'd have to do stil define the same combinations and results
02:10:32 <jle`> but you would not be pattern matching out Just's anymore
02:10:34 <johtso_> jle`, ah, I haven't learnt about Functors or Applicatives yet
02:10:47 <jle`> well
02:11:00 <jle`> it's probably a lot less complicated than you think
02:11:14 <jle`> just rewrite your function to be GameState -> GameState
02:11:32 <jle`> er sorry
02:11:36 <jle`> GameState -> GameState -> GameState
02:11:47 <jle`> instead of Maybe GameStage -> GameState -> GameState
02:11:55 <jle`> assuming that the first is a Just
02:12:03 <jle`> you actually don't even need functors for this
02:12:06 <jle`> you can just use maybe
02:12:09 <jle`> :t maybe
02:12:09 <no-n> wow
02:12:10 <lambdabot> b -> (a -> b) -> Maybe a -> b
02:12:13 <no-n> this sounds a lot like what i'm doing :3
02:12:33 <jle`> > maybe "No Number" show (Just 2)
02:12:34 <lambdabot>  "2"
02:12:39 <jle`> > maybe "No Number" show Nothing
02:12:41 <lambdabot>  "No Number"
02:12:48 <jle`> it'll apply the function you give it to whatever is inside the Just
02:12:57 <jle`> or return just the default if it's a Nothing
02:13:07 <johtso_> no-n google code jam tic tac toe? :)
02:13:14 <no-n> no
02:13:44 <jle`> hm looking at it now, maybe might not necessarily be the best tool either..there's just a lot you can do here
02:14:00 <johtso_> jle`, here's more context http://lpaste.net/9078872105608544256
02:14:03 <jle`> if you just turn your function into a pure GameState -> GameState -> GameState function
02:14:08 <jle`> and pretend there is no Maybe
02:14:14 <jle`> and use the various maybe/functor combinators
02:14:43 <jle`> you do realize that all of your results are Just, right?
02:14:52 <jle`> you don't ever have a Nothing result?
02:15:20 <johtso_> jle`, oops!
02:15:24 * johtso_ adds a test
02:16:29 <jle`> ah it's for a fold?
02:16:53 <jle`> can you...state what you want to do in words?
02:17:13 <jle`> so if it's all Nothing...return Draw
02:17:51 <jle`> otherwise, return Draw, Unfinished, or Win a
02:18:01 <jle`> in that priority
02:18:04 <jle`> ?
02:18:37 <jle`> it sounds like you can just fold using Draw as your base case
02:19:26 <jle`> and not worry about Maybe's
02:19:57 <jle`> or you can use maximumBy f, where f ranks Win a highest, Unfinished second, Draw last
02:20:38 <jle`> but i think you already have enough to turn it into a normal fold...with Draw as your base case
02:27:50 <johtso_> jle`, I've reduced it to this, but am having a little trouble with the fold http://lpaste.net/9078872105608544256
02:28:18 <johtso_> Is my binary operator defined in an strange order?
02:28:30 <r444> Can someone point me to some guide to up-to-date haskell testing? Every post i've googled seem pretty outdated.
02:28:37 <johtso_> do I want to swap my arguments?
02:29:04 <jle`> johtso_: why do you still need a Maybe?
02:29:31 <jle`> :t foldl
02:29:32 <lambdabot> (a -> b -> a) -> a -> [b] -> a
02:30:07 <jle`> you can just fold over non-Maybe values
02:30:14 <jle`> with a non-maybe accumulator
02:30:26 <jle`> it'll look like foldl f Draw
02:32:51 <jle`> f w@(Win a) _ = w; f _ w@(Win a) = w; f Unfinished _ = Unfinished; f _ Unfinished = Unfinished; f _ _ = Draw
02:32:57 <jle`> there might be a simpler way to do it though
02:32:58 <johtso_> jle`, ugh, of course! that was silly.. http://lpaste.net/1153841392112369664
02:33:22 <johtso_> jle`, why do I not get a warning that the first two patterns overlap though?
02:33:28 <johtso_> isn't the second redundant?
02:33:39 <jle`> for yours or for the ones i posted?
02:33:48 <johtso_> sorry, I mean the first
02:33:50 <jle`> the first one is redundant yeah
02:34:06 <jle`> but i don't think the compiler checks things like that
02:34:29 <johtso_> jle`, ah, if I reverse the order i get a warning
02:34:30 <jle`> because it depends on what is on the right hand side of the equals sign
02:34:36 <jle`> yeah, it's not necessarily redundant
02:34:41 <jle`> if you make it = something not a
02:34:50 <jle`> it is not smart enough to figure it out
02:34:54 <jle`> or well, it was not programmed to be
02:35:19 <jle`> if you reverse the order it is definitely redundant no matter what is on the right hand side of the equals sign
02:35:27 <johtso_> makes sense
02:36:07 <johtso_> jle`, so my binary operator is not strict in its second argument, does it matter that that pattern is at the bottom? or do I need to put it at the top for the fold to short circuit?
02:36:34 <johtso_> and what would be better practice?
02:36:36 <jle`> strictness is not really at play here
02:36:51 <jle`> oh
02:36:59 <jle`> foldl's don't short circuit
02:37:01 <jle`> only foldr's
02:37:35 <jle`> (i think)
02:37:56 <jle`> @src minimum
02:37:57 <lambdabot> minimum [] = undefined
02:37:57 <lambdabot> minimum xs = foldl1 min xs
02:38:02 <jle`> wut
02:38:05 <jle`> @src maximum
02:38:05 <lambdabot> maximum [] = undefined
02:38:05 <lambdabot> maximum xs = foldl1 max xs
02:38:21 <jle`> wait
02:38:26 <jle`> i'm thinking of the wrong thing
02:38:41 <jle`> @src and
02:38:41 <lambdabot> and   =  foldr (&&) True
02:38:46 <jle`> yeah
02:39:14 <jle`> > and ([False, True] ++ repeat False)
02:39:16 <lambdabot>  False
02:39:31 <jle`> > let and' = foldl (&&) True in and' ([False, True] ++ repeat False)
02:39:36 <lambdabot>  mueval: ExitFailure 1
02:39:36 <lambdabot>  mueval: Prelude.undefined
02:39:48 <johtso_> jle`, oh wow, reordering the patterns coaxed some overlapping pattern warnings out, it can be reduced to this: http://lpaste.net/1153841392112369664
02:40:37 <jle`> sweet :)
02:40:44 <jle`> @src foldr
02:40:44 <lambdabot> foldr f z []     = z
02:40:44 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
02:41:01 <jle`> as you can see foldr will short circuit if your f ignores the second parameter
02:41:15 <johtso_> ah yes
02:41:25 <jle`> @src foldl
02:41:26 <lambdabot> foldl f z []     = z
02:41:26 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
02:41:38 <jle`> not so for foldl
02:42:18 <johtso_> jle`, is there an easy way to see what's getting executed so I can see if it short circuits? like a trace?
02:43:14 <jle`> johtso_: well there is Debug.Trace which you can use to send off a ping whenever something is evaluated
02:43:20 <jle`> but for this
02:43:26 <jle`> the easiest way is just to g et pencil and paper
02:43:33 <jle`> and do out the sbustitution by hand
02:43:55 <jle`> for situations like this evaluation can basically be seen as glorified text substitution
02:46:07 <johtso_> probably better practice to just think it through rather than reaching for Trace too :)
02:46:33 <jle`> yes, definitely :)
02:46:48 <jle`> equational reasoning and all
02:49:35 <Peaker> I wish Control.Applicative exported all the Control.Monad functions that don't require Monad, with Applicative constraint, and Control.Monad could re-export them   (e.g: "when", "unless", "guard", ...)
02:52:09 <jle`> 7.10 will apparently fix everything
02:52:44 <Peaker> Will it have the Applicative-do notation thing?
02:52:55 <jle`> that i do not know
02:54:06 <Peaker> 7.10 does intend to change all the filterM, sequence, when, guard, etc functions too?
02:55:53 <jle`> i don't think too much has been said specifically, but 7.10 is thrown out there as the miracle release :) it was partially a joke
02:56:14 <jle`> it is the goal for the applicative/monad superclass deal for sure
02:56:34 <jle`> and in doing that they will have to deal with things like pure/return
02:56:56 <jle`> so presumably they would also be able to move all of the relevant monad functions into applicative without much trouble
02:58:48 <jle`> if not then you will be around to voice your opinion :)
03:00:06 <Peaker> heh :)
03:00:42 <Peaker> it would be cool if the even more generalized functions from Data.Foldable/Traversable took over the type signature, but that would have the downside of beginner-unfriendly types
03:00:51 <jle`> you probably know that edwardk is on the board planning things like this
03:00:55 <jle`> and he is here often
03:01:11 <Peaker> yeah, that's great :)
03:01:18 <jle`> he has said that Foldable/Traversable being in Prelude/base is a high priority thing
03:01:37 <jle`> so mapM and sequence and stuff like that
03:01:42 <jle`> soon
03:01:57 <jle`> but i am also afraid of the scarier errors.
03:02:00 <jle`> for new people
03:02:09 <Peaker> imagine deprecating mapM for traverse, and explaining the type of "traverse" to newbies...
03:03:04 <Peaker> the solution of having various "depths" of expertise in the standard library has some significant annoying downsides, though
03:03:15 <jle`> it doesn't help that mapM for list has an implementation that most new people can understand
03:03:36 <jle`> i don't know, i'm happy as it is now
03:03:42 <jle`> with the slight boilerplate in my imports
03:04:08 <jle`> i mean i don't expect (.) and id to be genericized in Prelude any time soon
03:04:55 <jle`> @src mapM
03:04:56 <lambdabot> mapM f as = sequence (map f as)
03:05:11 <jle`> such a good learning demonstration
03:05:42 <skypers_> @src liftM
03:05:42 <lambdabot> liftM f m1 = do { x1 <- m1; return (f x1) }
03:05:55 <skypers_> hm
03:06:14 <skypers_> why isn’t it implemented with fmap?
03:06:23 <jle`> because Functor is not a superclass of Monad :P
03:06:30 <skypers_> because a Monad is not always a Functor
03:06:31 <skypers_> yes
03:06:37 <skypers_> obvious
03:07:46 <jle`> it's mostly annoying when I want to use fmap/(<$>) and now I have to add both (Monad m) and (Applicative m) to my constraints
03:08:00 <jle`> gr
03:08:45 <Peaker> jle`: yeah, that too
03:08:49 <jle`> liftM though is also a nice teaching demonstration i think
03:09:12 <jle`> also op
03:09:15 <jle`> @src op
03:09:15 <lambdabot> Source not found. Are you on drugs?
03:09:17 <jle`> darn
03:09:20 <Peaker> liftM can be renamed fmapDefault or something
03:09:28 <jle`> i mean ap
03:09:30 <Peaker> (so you can instantiate Monad and get Functor/Applicative from that)
03:09:32 <jle`> @src ap
03:09:33 <lambdabot> ap = liftM2 id
03:09:36 <jle`> haha
03:09:39 <jle`> darn
03:10:33 <jle`> was hoping it'd be the do notation version
03:11:38 <milfjord> ap = liftM2 (do id)
03:11:44 <Peaker> heh
03:11:56 <jle`> haha
03:12:22 <milfjord> :t liftM2 ask
03:12:23 <lambdabot> Monad m => m (a2 -> r) -> m a2 -> m r
03:15:07 <catalyst> RIOTisstupid88
03:15:10 <catalyst> well
03:15:13 <catalyst> that was dumb
03:19:52 <ion> @@ @undo @src ap
03:19:52 <lambdabot>  ap = liftM2 id
03:20:03 <ion> @undo liftM2 foo
03:20:03 <lambdabot> liftM2 foo
03:20:20 <milfjord> @src liftM2
03:20:20 <lambdabot> liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
03:34:41 * hackagebot pipes-errors 0.1 - Integration between pipes and errors  http://hackage.haskell.org/package/pipes-errors-0.1 (jdnavarro)
04:14:46 <foobar_> hey guys! got a doubt. If I apply a function to a value x  in haskell no matter how many times that function is used, the value is calculated once right?
04:15:12 <haasn>  foobar_: the general answer is “no”
04:16:28 <ion> foobar: You can give the result a new monomorphic name, though, and it’ll be memoized as long as it’s in scope.
04:16:32 <haasn> and even in special cases, programs like GHC for example can't really track multiple uses of the same function to the same parameter across different scopes. GHC will happily lift something like “f a + f a” out to (let x = f a in x + x” but I don't know how far it goes
04:16:49 <haasn> sharing has more to do with names - things you assign to a name get shared within the lifetime of that name
04:17:29 <haasn> (not always, I think. Depending on how unlucky you get w.r.t polymorphic values)
04:18:03 <foobar_> k. :)
04:18:17 <ion> haasn: Btw, in case you didn’t see this, i wrote https://gist.github.com/ion1/9285144
04:19:16 <haasn> ion: I never realized just how neat those come out during compilation :)
04:19:51 <ClaudiusMaximus> foobar_: you can explicitly tell the compiler you want it to be computed at most once by using  let y = f x in y + y  instead of  f x + f x   -- the issue is that sharing might change spacetime usage of the program, depending on what f does with x
04:20:13 <ClaudiusMaximus> foobar_: there's probably a good wiki page or mailing list discussion somewhere that explains it better than i can right now
04:20:51 <ion> ClaudiusMaximus++ “spacetime usage”
04:26:15 <Cale> foobar_: While it would not be incorrect to memoise the results of every function, the problem with that is that you then never garbage collect anything
04:26:44 <Cale> and there's not really any known good way to figure out automatically what would be worthwhile to memoise
04:50:36 <Taneb> > [join, fold, mconcat, concat, msum]
04:50:37 <lambdabot>  No instance for (Data.Typeable.Internal.Typeable a0)
04:50:37 <lambdabot>    arising from a use of `M519601742233319710729849.show_M5196017422333197107...
04:50:37 <lambdabot>  The type variable `a0' is ambiguous
04:50:37 <lambdabot>  Possible fix: add a type signature that fixes these type variable(s)
04:50:37 <lambdabot>  Note: there are several potential instances:
04:50:43 <Taneb> :t [join, fold, mconcat, concat, msum]
04:50:44 <lambdabot> [[[a]] -> [a]]
04:51:52 <Maior> cute
04:54:49 * hackagebot gtk3 0.12.5.4 - Binding to the Gtk+ graphical user interface library.  http://hackage.haskell.org/package/gtk3-0.12.5.4 (HamishMackenzie)
04:54:51 * hackagebot gtk 0.12.5.4 - Binding to the Gtk+ graphical user interface library.  http://hackage.haskell.org/package/gtk-0.12.5.4 (HamishMackenzie)
05:11:06 <zomg> I need to do some time manipulations, eg. add an hour to the current UTCTime, drop the minutes and use the resulting time for something... but Data.Time doesn't seem to have any functions for this
05:11:13 <zomg> Is there some other module available that does this stuff?
05:27:10 <zomg> hm maybe time-lens does this
05:31:16 <klrr_> mm_freak: hey, ive been thinking of FRP for irc bot last night (and this morning), i got hard time thinking of this complexity wall, could you please define what you mean with it? the only case i believe there might be addded complexity that i can think of is when you have to perhaps give handler function more state or when they need to initialize before use
05:44:36 <hexagoxel> i am working on a cabal executable package. sometimes there are modules that are not (indirectly) referenced by the main module (yet), so they don't get compiled by the standard commands (cabal build or in cabal repl)
05:45:23 <hexagoxel> i could :l them explicitly in the repl, or include them in my main module (temporarily), but i wonder if there is a better way
05:45:26 <enthropy> you are supposed to list those modules in extra-modules:
05:45:26 <ClaudiusMaximus> hexagoxel: list them in  other-modules:  otherwise they won't be bundled when you  cabal sdist
05:45:37 <enthropy> oops ClaudiusMaximus is right
05:48:14 <hexagoxel> yeah i tried exposed-modules already
05:48:48 <hexagoxel> still, the unreferenced modules seem not to be build on "cabal build" or loaded in "cabal repl"
05:50:50 <hexagoxel> in fact, i can effectively write garbage after extra-modules, without any problem on "cabal build"
05:51:42 <klrr_> hmm, when i dont reference any modules and run "cabal repl" they doesn't get compiled even if i have them in other-modules
05:53:33 <bennofs> hexagoxel: try other-modules instead of exposed-modules?
05:53:47 <c_wraith> well, yes.  other-modules don't get auto-compiled
05:53:56 <c_wraith> They exist only to tell cabal to include them in sdist
05:54:18 <bennofs> I have another cabal question: Is there a way to avoid the need to increase --max-backjumps by changing the cabal file?
05:54:19 <c_wraith> Because they're not part of the public interface, they're only compiled if GHC compiles them
05:54:31 <Saizan> other-modules are also important for what goes into installed libs
05:54:33 <hexagoxel> bennofs: i tried both without success
05:55:06 <bennofs> Maybe I should start putting bounds on my dependencies ...
05:55:20 <hexagoxel> but maybe my problem is more general; i switched from cabal-dev (which stopped working..) to cabal sandbox recently; will have to investigate that
06:00:44 <randomclown> @pl \x -> (x, ())
06:00:45 <lambdabot> flip (,) ()
06:04:17 <bennofs> Is there a difference between A >= 1.2 && < 1.3 and A == 1.2.*
06:04:18 <bennofs> ?
06:04:24 <haasn> is there a prelude-like thing in which all IO actions are lifted to MonadIO ?
06:04:59 <bennofs> haasn: maybe lifted-base?
06:05:03 <bennofs> @hackage lifted-base
06:05:03 <lambdabot> http://hackage.haskell.org/package/lifted-base
06:05:28 <bennofs> But I don't see System.IO there :|
06:05:38 <haasn> yeah looks like that's for MonadBase/MonadBaseControl
06:07:06 <hexagoxel> hmm no my setup seems fine; i think that neither other-modules nor exposed-modules does what i want
06:07:27 <hexagoxel> any other suggestions? :)
06:11:54 <c_wraith> bennofs: no, constraints are the same
06:13:35 <enthropy> probably nobody uses a cabal old enought that understands  >= 1.2 && < 1.3, but cannot understand == 1.2.*
06:16:15 <bennofs> Is there a tool for cabal packages that are not on hackage that warns when any of the choosen dependencies are not of the most recent versions?
06:19:15 <Feuerbach> @package packdeps
06:19:15 <lambdabot> http://hackage.haskell.org/package/packdeps
06:19:20 <Feuerbach> bennofs: ^^
06:20:56 <bennofs> Feuerbach: that's nice. Does that also check if because of the version constraint of any of your dependencies some packages are excluded?
06:22:21 <Feuerbach> good point, I'm not sure about that
06:30:00 * hackagebot HGamer3D-Data 0.3.1 - Game Engine for the Haskell Programmer - Data Definitions and Utilities  http://hackage.haskell.org/package/HGamer3D-Data-0.3.1 (PeterAlthainz)
06:30:02 * hackagebot HGamer3D-Enet-Binding 0.3.1 - Enet Binding for HGamer3D  http://hackage.haskell.org/package/HGamer3D-Enet-Binding-0.3.1 (PeterAlthainz)
06:30:04 * hackagebot HGamer3D-SDL2-Binding 0.3.1 - SDL2 Binding for HGamer3D  http://hackage.haskell.org/package/HGamer3D-SDL2-Binding-0.3.1 (PeterAlthainz)
06:35:01 * hackagebot HGamer3D-SFML-Binding 0.3.1 - SFML Binding for HGamer3D  http://hackage.haskell.org/package/HGamer3D-SFML-Binding-0.3.1 (PeterAlthainz)
06:35:03 * hackagebot HGamer3D 0.3.2 - A Game Engine for the Haskell Programmer  http://hackage.haskell.org/package/HGamer3D-0.3.2 (PeterAlthainz)
06:35:05 * hackagebot int-cast 0.1.1.0 - Checked conversions between integral types  http://hackage.haskell.org/package/int-cast-0.1.1.0 (HerbertValerioRiedel)
06:37:58 <ij> errors: http://sprunge.us/eZca / code:
06:38:00 <ij> http://sprunge.us/URga
06:38:14 <ij> I'm trying to get a hamlet template working.
06:38:53 <ij> Could you give me some hints?
06:41:03 <enthropy> Probable cause: `hamletToResponse' is applied to too few arguments
06:41:30 <enthropy> ghc's explanation is probably as good as any human's
06:44:46 <ij> I'm silly, thanks
06:45:17 <Twey> jle`: I don't know why you asked me specifically (I haven't even used pipes :þ), but yes, you can
06:45:54 <Twey> jle`: Data.Binary doesn't do lazy IO (or IO at all): it does pure encoding to and decoding from lazy ByteStrings, which is fine
06:47:01 <Twey> jle`: It recommends you use the IO functions in Data.ByteString.Lazy to do the actual IO
06:47:15 <Twey> jle`: Which are lazy IO, indeed, and can be replaced with pipes
06:47:39 <randomclown> Oh wow
06:47:42 <randomclown> haskell channels suck
06:47:51 <randomclown> The Concurrent.Chan sucks
06:48:03 <randomclown> don't use it if you want memory leaks
06:48:38 <hpc> memory leaks are webscale
06:48:50 <Twey> jle`: The pipes-bytestring package provides pipes for IO, https://hackage.haskell.org/package/pipes-bytestring-1.0.0/docs/Pipes-ByteString.html
06:50:27 <Twey> jle`: They produce and consume chunks of strict ByteString, which you can wrap into lazy ByteStrings with fromChunks/toChunks
06:57:42 <ClaudiusMaximus> randomclown: perhaps you want bounded channels as found in STM?
06:57:59 <randomclown> ClaudiusMaximus: that's just solving the wrong problem
06:58:04 <randomclown> not allowed to block
06:58:18 <randomclown> I ended up just atomicModifyIORef'
06:58:20 <randomclown> solves everything
06:58:52 <bennofs> Does cabal have 'or' constraints?
06:59:15 <enthropy> it has flags
06:59:55 <enthropy> so you can have   if flag(foobar)\n build-depends: dep1\nelse build-depends: dep2
07:00:58 <ClaudiusMaximus> bennofs: cabal will try to (de)activate flags in a combination that is likeliest to succeed, afaik - but because you can't specify a dependency on a flag in another package their use is a bit awkward in practice...
07:04:48 <ashmew2> Hi
07:06:15 <jmcarthur> enthropy: yes, i believe it does
07:06:37 <jmcarthur> oops
07:06:40 <jmcarthur> i mean bennofs
07:10:04 * hackagebot ViennaRNA-bindings 0.1.2.0 - ViennaRNA v2 bindings  http://hackage.haskell.org/package/ViennaRNA-bindings-0.1.2.0 (ChristianHoener)
07:25:31 <jcarpenter2> :t (:@:)
07:25:32 <lambdabot> Not in scope: data constructor `:@:'
07:25:42 <jcarpenter2> :k (:@:)
07:25:42 <lambdabot>     Not in scope: type constructor or class `:@:'
07:25:43 <lambdabot>     Perhaps you meant `:@' (imported from Control.Lens)
07:26:41 <jcarpenter2> but the string ":@" isn't on the page http://hackage.haskell.org/package/lens-1.2/docs/Control-Lens.html
07:26:54 <jcarpenter2> What are these operators?
07:27:59 <klrr_> is it bad to run perfromGC in a program?
07:28:58 <c_wraith> why would it be?
07:29:03 <supki_> jcarpenter2: you're looking at old docs
07:29:37 <supki_> jcarpenter2: I think :@ is zipper-related, zippers are now in the separate package
07:29:43 <jcarpenter2> lol
07:29:51 <geekosaur> not bad but not often useful
07:29:52 <c_wraith> jcarpenter2: lens is on version 4 now.  (though lambdabot probably only has something in the 3 series).  Don't google for haddocks, you'll always end up many versions behind
07:29:53 <jcarpenter2> it was the first hit on google
07:30:16 <supki_> not sure if it's released on hackage though
07:30:38 <supki_> jcarpenter2: yeah. that's often the case with google
07:30:39 <geekosaur> google shows what's linked to. because programming related stuff doesn't generally stand still, google links will generally be for old versions
07:30:45 <jcarpenter2> I see
07:30:49 <int-e> c_wraith: 3.10 to be precise.
07:31:49 <klrr_> c_wraith: hmm, i remember reading that manually managing memory breaks some aspect of the garuantees you get from the type checker in TAPL, perhaps performGC doesnt count as that?
07:32:14 <geekosaur> it doesn't, no
07:32:21 <c_wraith> It's not even close to manual memory management
07:32:30 <c_wraith> you can't say "deallocate that memory"
07:32:54 <klrr_> okey
07:32:54 <geekosaur> it can sometimes be useful to control when a gc occurs when you need some guarantees abotu timing, but the way ghc allocates memory it's not especially helpful
07:33:05 <int-e> c_wraith: is there any pressing need to update to 4.0?
07:33:35 <c_wraith> int-e: not that I know of. I was just making sure to not be misleading after saying the current version was 4.x
07:34:18 <int-e> ok. then I'll stick to my plan (which is to wait for ghc 7.8 to be released and the resulting mess to settle a bit before updating lambdabot.)
07:34:30 <c_wraith> that sounds like a solid plan
07:35:20 <Twey> klrr_: performGC is semantically a no-op — it never changes the semantics of code, just its time and space usage
07:36:01 <c_wraith> geekosaur: the main reason I can see to use performGC is if you can schedule idle GC manually better than GHC's runtime can.
07:36:28 <Twey> klrr_: You lose guarantees with manual memory management because you can free variables that are still in use, thereby causing your code to break next time it accesses that variable
07:36:37 <Twey> klrr_: Which changes the semantics
07:37:38 <Twey> klrr_: That said, inserting performGC willy-nilly will do more harm than good to your performance.  You should be very sure you need it (via profiling) before you insert it.
07:39:49 <geekosaur> c_wraith, that is more or less what I said...
07:39:54 <quchen> I think the pipes tutorial (in the Pipes.Tutorial module) has a couple of examples where it recommends manual GC.
07:40:19 <klrr_> Twey: okey
07:40:22 <quchen> Maybe that can motivate its use if you're looking for an application.
07:40:28 <klrr_> quchen: yeah
07:40:31 <klrr_> that's why i asked
07:40:46 <quchen> Oh, nevermind then.
07:41:23 <klrr_> another question, is there tail function that simply returns null Text if it's empty, the one in text seem to be a partial function
07:42:23 <int-e> klrr_: drop 1
07:42:31 <quchen> I don't think so. For lists, tail is literally "the second argument of the (:) constructor", so it has to fail on []. All other packages I know of follow that pattern (i.e. crash on tail []).
07:42:56 <geekosaur> it (and bytestring) are deliberately emulating lists there
07:43:08 <quchen> Or you can write your own function like int-e suggested, for sufficiently small definitions of "own" :-)
07:43:23 <magneticduck> http://ix.io/aSC <-- parsec question
07:43:26 <klrr_> int-e: thanks
07:43:30 <int-e> drop 1  doesn't deserve a name :)
07:43:31 * magneticduck is finally learning parsec
07:44:05 <magneticduck> int-e: why not?
07:44:17 <geekosaur> ...why are you importing both the parsec3 and parsec2 interfaces?
07:44:22 <magneticduck> I have no idea!
07:44:27 * magneticduck has no idea what he's doing
07:44:29 <quchen> int-e: let drop1 = drop 1 :-?
07:44:36 <magneticduck> Text.Parsec doesn't work by itself
07:44:42 <magneticduck> but is has a more convincing name
07:44:49 <magneticduck> and for some reason hlint isn't telling me that it's redundant
07:44:51 <Twey> data [a] = [] | (:) { head ∷ a, tail ∷ [a] }
07:45:08 <dagnachew> hi all
07:45:16 <int-e> quchen: That's sort of ok; at least it doesn't add much mental burden to the reader of the code.
07:45:24 <magneticduck> Twey: hmm
07:45:24 <klrr_> magneticduck: it's so trivial to write anyway ;) besides, head tail etc. is only there for beginners iirc
07:45:33 <magneticduck> .....
07:45:36 <magneticduck> only for beginners?
07:45:38 <magneticduck> excuse me?
07:45:44 <magneticduck> it's really handy for pointless code
07:45:53 <magneticduck> uh, as in, no lambda expressions
07:46:02 <Twey> magneticduck: ‘Point-free’
07:46:04 <magneticduck> yes
07:46:10 <magneticduck> :D pointless lol
07:46:19 <int-e> In general, point-free code can be recognized by its abundance of dots.
07:46:22 <Twey> That's a very old joke :þ
07:46:26 <magneticduck> int-e: ikr
07:46:30 <Twey> Hehe
07:46:31 <quchen> klrr_: And for beginners it's most likely misleading and bad :-\
07:46:40 <magneticduck> I'm not sure why it's called point-free actually
07:46:42 <klrr_> magneticduck: i actually think that was the reason iirc (long time since i read history of haskell), since it is common list operations in other languages but they're not type safe in haskell
07:46:47 <klrr_> well-typed*
07:46:55 <quchen> They are well-typed.
07:47:01 <quchen> They are not total though.
07:47:08 <klrr_> yeah truew
07:47:11 <magneticduck> klrr_: I'm still really not sure why you guys think head, tail, init, last are so bad
07:47:14 <quchen> head 3 isn't well-typed.
07:47:18 <dagnachew> in your opinion is it possible to build a web 2.0 with haskell ? or is haskell not yet SUITED for everyday computing ?
07:47:23 <klrr_> but if you write them with depentent type they will be better :D
07:47:31 <magneticduck> quchen: take 3 you mean?
07:47:35 <quchen> klrr_: The only valid use of head I can think of is  map head . group
07:47:37 <hellwolf> hi, imagine I have a "divExcpt :: Int -> Int -> (String -> Cont r Int) -> Cont r Int", which returns 1st/2nd and if 2nd == 0, use 3rd as handler. But if someday I decided to add IO to the handler, do I need to go back and change the definition of divExcpt to use ContT r IO?
07:47:40 <int-e> magneticduck: the variables denote 'points' in the sets of values corresponding to data types. point-free means you don't explicitely mention those.
07:47:55 <klrr_> magneticduck: cause they are not total, i.e if you pass [] they cause the entire program to fail
07:48:08 <Twey> magneticduck: ‘Point’ here refers to a topological point, i.e. a value of a type
07:48:11 <magneticduck> yes I see what you  mean now...
07:48:18 <dagnachew> I found this tutorial to test the waters http://yannesposito.com/Scratch/en/blog/Haskell-the-Hard-Way/
07:48:20 <magneticduck> Twey: huh, why don't you just say value?
07:48:36 <Twey> magneticduck: Mathematicians :þ
07:48:42 <quchen> And when you use head/tail you don't get exhaustiveness warnings by the compiler. When you pattern match you do ("you forgot matching [], sir!").
07:48:42 <magneticduck> yes
07:49:21 <magneticduck> quchen: yeah, something should be done about that...
07:49:28 <klrr_> magneticduck: but you can write head tail etc. so they cause a type error when you compile if you pass [], you will have to use depentend types for that, this tutorial explains it very nicely: https://www.fpcomplete.com/user/konn/prove-your-haskell-for-great-safety/dependent-types-in-haskell
07:49:31 <dagnachew> 
07:49:32 <magneticduck> I wonder if there's a better way
07:49:40 <quchen> Don't use head/tail unless you can prove it's safe, that's what should be done.
07:49:49 <Twey> magneticduck: The better way is to avoid head/tail :þ
07:49:50 <quchen> Use pattern matching is the better way.
07:49:58 <magneticduck> hm okay
07:50:25 <quchen> case list of [] -> emptyHandler; (x:xs) -> nonEmptyHandler x xs
07:50:27 <Twey> Or the list eliminator, list n c [] = n; list n c (x : xs) = c x xs
07:50:57 <enthropy> @type foldr . const
07:50:58 <lambdabot> (b -> b) -> b -> [a] -> b
07:51:10 <enthropy> @type foldr const
07:51:10 <lambdabot> b -> [b] -> b
07:51:26 <Twey> A safe head
07:51:26 <magneticduck> btw when a value can contribute to a type definition, you call that a dependant type?
07:51:32 <Twey> magneticduck: Yes
07:51:33 <int-e> example good uses of head and tail include: map head . group  and  tail . tails
07:51:43 <magneticduck> okay just checking to make sure I'm not saying complete gibberish
07:51:52 <magneticduck> when I say: I wish haskell had dependent types
07:51:53 <Twey> Because those things really ought to have a separate non-empty list type, but don't
07:52:02 <Twey> magneticduck: You're not alone.  :þ
07:52:06 <magneticduck> :D
07:52:14 <enthropy> you can deal with (a,[a])
07:52:20 <Hodapp> klrr_: that's not as clever of a title as "Hasochism", should I read anyway?
07:52:21 <Twey> magneticduck: You can do most things you'd want to do with dependent types in Haskell using singletons and typeclasses
07:52:39 <Twey> magneticduck: It's not always pretty, though
07:52:40 <klrr_> Hodapp: what you mean?
07:52:40 <quchen> Dependent types aren't free. They make many things a lot more complicated.
07:52:50 <magneticduck> mm
07:52:52 <Hodapp> klrr_: have you read the paper "Hasochism"? Search it
07:52:57 <klrr_> just did
07:52:59 <magneticduck> anyway, a while ago I asked an actual question
07:53:02 <magneticduck> about parsec
07:53:02 <klrr_> not read it
07:53:07 <quchen> It's really a trade-off between safety and convenience.
07:53:08 <magneticduck> http://ix.io/aSC <-- parsec question
07:53:17 <klrr_> hahah funny title ;)
07:53:23 <enthropy> Hodapp: that one is >10 years old?
07:53:58 <enthropy> oh no it's new
07:54:15 <Hodapp> klrr_: this post looks neat too
07:54:15 <klrr_> i just recommended it since i found it easy to undestand, and i usually struggle to understand
07:54:21 <jmcarthur> "dependent types" in ghc is not really a great presentation of dependent types :(
07:54:23 <Hodapp> I'll have to remember to check back for part 2 and onward
07:54:39 <Twey> magneticduck: With "())" the second invocation of parens fails immediately on ")" (expecting "(") so it jumps to the alternative, return ()
07:54:55 <magneticduck> oh that's right, alternatives.
07:54:57 <Twey> magneticduck: With "(()" it consumes the unmatched "(", so it can't backtrack
07:55:06 <magneticduck> so, how would I make ti fail on ())?
07:55:14 <Twey> magneticduck: Remove the <|> return ()
07:55:36 <magneticduck> yes but then only infinite paren structures pass right? =P
07:55:51 <magneticduck> oh wait, I need a parser for an empty string
07:55:55 <magneticduck> d'oh
07:56:01 <magneticduck> how do I have that? string ""?
07:56:03 <Twey> magneticduck: Make the internal parens optional
07:56:26 <Twey> parens = char '(' >> optional parens >> char ')'
07:56:38 <Twey> >> optional parens
07:57:18 <quchen> There's the `between` function, by the way.  between (char '(') (char ')')
07:57:22 <Twey> Aye
07:57:23 <magneticduck> optional eh
07:57:37 <Twey> >> return ()
07:57:43 <magneticduck> is that different from "(try something) <|> string """?
07:58:03 <Twey> magneticduck: optional p = try (Just <$> p) <|> return Nothing
07:58:15 <quchen> optional doesn't `try`
07:58:18 <magneticduck> ahah, yes, it has return of Maybe
07:58:20 <magneticduck> I was half right
07:58:25 <Twey> Doesn't it?
07:58:28 <quchen> ptional p = do { p; return () } <|> return ()
07:58:32 <Twey> Oh, okay
07:58:34 <quchen> http://hackage.haskell.org/package/parsec-3.1.5/docs/src/Text-Parsec-Combinator.html#optional
07:58:38 <magneticduck> huh
07:59:01 <Twey> Oh, I was thinking of optionMaybe
07:59:08 <Twey> Yeah.  optional is the one you want, anyway.
07:59:26 <quchen> optionMaybe doesn't `try` either :-þ
08:00:17 <Twey> Yes, I know >.<
08:00:25 <Twey> (though this is strange to me)
08:00:35 <Algebr> why is this `length [(x, y) | x <- [1..10], y <- [10..20]]` 110 but this: length [(x, y) | x <- [1..10], y <- [1..10]] is 100?
08:00:52 <quchen> Algebr: There are 11 numbers in [10..20].
08:00:54 <Twey> The fact that backtracking isn't indicated in the types of Parsec parsers is unpleasant
08:00:57 <quchen> There are 1 in [1..10].
08:00:59 <bennofs> > [10..20]
08:00:59 <quchen> 10*
08:01:02 <lambdabot>  [10,11,12,13,14,15,16,17,18,19,20]
08:01:03 <bennofs> > [0..10]
08:01:04 <lambdabot>  [0,1,2,3,4,5,6,7,8,9,10]
08:01:10 <Algebr> oh haha, oops.
08:01:12 <bennofs> > [1..10]
08:01:12 <Algebr> kk, thanks!
08:01:13 <lambdabot>  [1,2,3,4,5,6,7,8,9,10]
08:01:18 <magneticduck> uh, I still can't get the parens to work....
08:01:36 <magneticduck> http://ix.io/aSD
08:01:42 <magneticduck> I suck at monoidal parsers =P
08:03:13 <quchen> magneticduck: When you parse ()) with your parser, it will parse the () and then be done with it. You don't require the trailing ) to be parsed.
08:03:23 <magneticduck> ohhh ofc
08:03:26 <Twey> magneticduck: You want to end with an eof
08:03:30 <magneticduck> so I need that end of string thing
08:03:32 <quchen> If you demand an EOF after your parens parser, i.e. run "parens *> eof", then you should get an error.
08:03:43 <magneticduck> *>?
08:03:46 <quchen> >>
08:03:51 <Twey> :t (*>)
08:03:52 <lambdabot> Applicative f => f a -> f b -> f b
08:04:06 <quchen> (>>) = (*>).
08:04:15 <magneticduck> ah.
08:04:20 <quchen> inb4 someone takes me out of my dream world
08:04:20 <magneticduck> ofc
08:05:23 <magneticduck> and now "(())" doesn't parse either :D
08:05:24 <magneticduck> rofl
08:05:33 <magneticduck> oh d'oh never mind
08:05:37 <quchen> Your top-level parser should be parens *> eof
08:05:41 <quchen> Not the parens parser itself
08:05:45 <magneticduck> yes I figured that out the moment after I wrote it
08:05:51 <magneticduck> I need to think before I hit \n
08:06:24 <quchen> edit, git status, git commit -am, git push irc master
08:08:24 <magneticduck> [master 98aab4] I ask a question
08:08:29 <magneticduck> 1 file changed, 1 insertion
08:08:36 <magneticduck> file: question
08:08:40 <magneticduck> +hey guys I have a question
08:08:58 <magneticduck> ...actually I don't never mind
08:09:08 <Twey> @let swing = flip . (. flip id)
08:09:10 <lambdabot>  Defined.
08:09:14 <Twey> :t swing
08:09:15 <lambdabot> (((a -> c1) -> c1) -> b -> c) -> b -> a -> c
08:09:17 <Twey> :t swing map
08:09:18 <magneticduck> yum
08:09:18 <lambdabot> [a -> c1] -> a -> [c1]
08:09:20 <Twey> :t map
08:09:21 <lambdabot> (a -> b) -> [a] -> [b]
08:09:43 <magneticduck> ....
08:10:01 <magneticduck> *computing*
08:10:06 <magneticduck> yes, yes that would do that
08:10:16 <Twey> Neat combinator
08:10:23 <Twey> Confusing type :þ
08:10:29 <magneticduck> absolutely
08:10:59 <nicoo> Twey: Also, relatively confusing definition
08:11:22 <nicoo> Mmmh, does lambdabot have the converse of pl ?
08:11:23 <quchen> @unpl flip . (. flip id)
08:11:23 <lambdabot> (\ k b c -> k (\ f -> f c) b)
08:11:30 <nicoo> Thanks :D
08:11:35 <quchen> Is that moeb?
08:11:49 <Twey> Might be Löb
08:12:00 <quchen> löb = möb fmap
08:12:12 <Twey> Huh.
08:12:18 <klrr_> what's moeb?
08:12:25 <quchen> https://github.com/quchen/articles/blob/master/loeb-moeb.md
08:12:27 <magneticduck> what's löb?
08:12:30 <magneticduck> :D
08:12:34 <Twey> Where does that name come from?
08:12:39 <klrr_> quchen: will read, thanks
08:13:07 <quchen> chrisdone popularized the idea (of löb) I think, and then we tried to find uses for the generalized möb in this channel
08:13:11 <monochrom> Löb is a person's name. not sure about Möb
08:13:21 <Twey> quchen: It's not quite möb
08:13:30 <Twey> There's an extra argument
08:13:34 <magneticduck> lol I love that: "Feeling smart? Let's change that. Here's loeb:"
08:13:52 <quchen> Möb was named because it's a "multi-löb" function. In retrospect the Möbius reference would also have made sense.
08:13:56 <Twey> Oh, ‘multi-löb’ :þ
08:14:53 <Twey> quchen: It can't be möb: it's not even recursive
08:14:57 <gwz> hey, why is something like this not allowed, http://pastebin.com/pVZ1SnHy
08:15:08 <klrr_> :t \x -> fmap ($ x)
08:15:09 <lambdabot> Functor f => a -> f (a -> b) -> f b
08:15:18 <klrr_> :t (<*>)
08:15:19 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
08:15:21 <klrr_> hmm
08:15:41 <ion> gwz: That is parsed as (putStrLn "The input is ") ++ input [0]
08:15:43 <Twey> gwz: Your precedence is messed up
08:15:53 <ion> gwz: Additionally, input is not a function and can not be applied to the list [0]
08:15:53 <c_wraith> gwz: including the error message increases the odds of useful feedback by about 100%
08:15:57 <Twey> putStrLn $ "The input is " ++ input [0]
08:16:11 <Twey> Oh, input is also a list.
08:16:13 <c_wraith> ion: he's trying to use array access syntax
08:16:21 <c_wraith> Like haskell was C, or something
08:16:37 <gwz> this is so confusing
08:16:39 <ion> gwz: Use pattern matching: parse (x:xs) = something
08:16:50 <ion> gwz: Function application has higher precedence than any operator.
08:17:43 <gwz> ion: i am only trying to filter out the empty argument, everything else is good
08:17:44 <magneticduck> gwz: "this is so confusing"? welcome to haskell
08:17:48 <fragamus> good morning my haskellers
08:18:30 * monochrom decides to not help, since you have already made up your mind with "this is so confusing"
08:18:57 <magneticduck> monochrom is tough on newbies I guess
08:19:05 * gwz didnt make up his mind, was stating his opinion coming from non functional programming
08:19:09 <monochrom> no, wrong dichotomy
08:19:32 <monochrom> the right dichotomy is "have already made up mind" vs "have not"
08:19:50 <quchen> Oh come on monochrom.
08:20:03 <qwitwa> Play nice.
08:20:42 <Twey> gwz: We prefer the term ‘dysfunctional programming’.  Ho ho ho.
08:20:51 <magneticduck> poor gwz, attacked by a vicious haskell philosopher after coming in with a syntax problem
08:20:54 <gwz> well to be fair, the C/Java/etc community would have butchered me with insults after insults by now
08:20:54 <Twey> gwz: But, none of your errors are related to functional programming
08:20:58 <ion> monochrom: I’m pretty sure he meant “this is subjectively confusing, a.k.a. unfamiliar”, not “this is objectively confusing”.
08:21:00 <gwz> so haskell does have a better community in that sense
08:21:02 <Twey> gwz: Just language syntax
08:21:30 <magneticduck> gwz: haskell syntax is much cooler than C syntax
08:21:38 <Twey> gwz: monochrom's comment was unusually snappy; we're usually much friendlier to newbies.  ☺
08:21:41 <magneticduck> it's kind of cleaner
08:22:14 <gwz> magneticduck: probably but for someone who has only worked with C/Java like syntax for years and years, its quite confusing
08:22:31 <quchen> It's new and different.
08:23:25 <magneticduck> http://legacy.cs.uu.nl/daan/download/parsec/parsec.pdf <-- I have a feeling that this is a bit old or something
08:23:33 <magneticduck> a lot of the code snippets fail with type errors
08:23:35 <geekosaur> yes, that's parsec2
08:23:40 <magneticduck> mmmm
08:24:15 <eddieRay> I am in a programming languages class and I need to propose a project that teaches the class how to learn haskell. Can anyone suggest a beginners project? Something with concurrency, possibly a game?
08:24:32 <geekosaur> I think most of them work if you use parsec3 type signatures, but you have to know that and what to do about it. and nobody's up to doing updated documentation apparently :/
08:24:42 <pjdelport> gwz: Did you get that solved yet, or are you still looking for help?
08:24:46 <magneticduck> is parsec3 that recent?
08:24:57 <enthropy> geekosaur: because it's not terribly different?
08:25:06 <geekosaur> it's a couple years old
08:25:13 * hackagebot crypto-pubkey-types 0.4.2.2 - Generic cryptography Public keys algorithm types  http://hackage.haskell.org/package/crypto-pubkey-types-0.4.2.2 (VincentHanquez)
08:25:15 * hackagebot x509 1.4.10 - X509 reader and writer  http://hackage.haskell.org/package/x509-1.4.10 (VincentHanquez)
08:25:20 <geekosaur> not terribly different, but see what magneticduck said abut type errors
08:25:30 <magneticduck> eddieRay: something that teaches the class how to learn haskell?
08:25:44 <magneticduck> or teaches the class haskell
08:25:48 <enthropy> you might learn more by figuring out how to update the tutorial
08:25:54 <magneticduck> or... teaches the class how to teach themselves how to learn haskell and achieve enlightenment?
08:26:00 <enthropy> than by cutting and pasting stuff from a tutorial
08:26:02 <magneticduck> enthropy: yeah
08:26:06 <Twey> gwz: http://lpaste.net/9203861306099105792 — this is how we'd usually do it in Haskell
08:26:12 <magneticduck> I'm just picking up scraps, looking at the recent docs, etc
08:26:20 <Twey> gwz: The literal translation of your input[0] is (input !! 0)
08:26:23 <eddieRay> Yes, this will be the class's first time using haskell. The project should be simple enough for a beginer
08:26:32 <gwz> pjdelport: still looking, looking at the error it seems like some sort of type incompatibility stuff with appending to string with some other type
08:26:53 <eddieRay> My professor suggested that I come up with a game that uses concurrency
08:27:04 <Twey> eddieRay: Maybe a MUD?
08:27:05 <eddieRay> For example, last week we learned Scala and had to implement a Sudoku Solver
08:27:13 <gwz> parse :: [String] -> IO () <- takes a string and returns an IO ?
08:27:40 <Twey> eddieRay: You can get some parsing in there, maybe some pipes if you feel like going advanced
08:27:59 <magneticduck> gwz: when something returns an IO (), it's causing side effects and returning no useful information as a function
08:28:07 <Twey> gwz: I did something stupid, sorry.  http://lpaste.net/9203861306099105792
08:28:30 <Twey> gwz: I renamed your ‘parse’ function in main, since it's not parsing anything, but I forgot to rename it elsewhere :-D
08:28:39 <magneticduck> when a value has type (things -> IO a), it's taking things and returning a value of type a, but it has side effects, so we use the IO monad to.. deal with.. that...
08:28:53 <Twey> gwz: So, something of type IO () is a program that might do impure things
08:29:29 <Twey> gwz: Like printing to the terminal, or exiting the program
08:29:49 <gwz> and in this case, haskell can't resolve the type automatically if I take out the function definition?
08:29:51 <magneticduck> eddieRay: btw just to clarify, you already know haskell but are looking for a project to make and explain to beginners right?
08:29:58 <gwz> or is taht something thats always required
08:30:01 <Twey> gwz: Well, in general something of type ‘IO a’ is a program that might do impure things, and results in something of the type ‘a’
08:30:29 <Twey> gwz: It can, I just put it in because you're clearly a beginner and as a beginner it will help you a lot if you write down *all* the types
08:30:46 <eddieRay> magneticduck: Yes that is the case. I need to propose a project idea that a beginner can implement, while learning haskell at the same time
08:30:46 <Twey> gwz: (it's also good style to give top-level definitions explicit types, to help people reading your code)
08:31:17 <magneticduck> and also because it helps prevent errors if you specify exactly what the value's type is
08:31:21 <Twey> gwz: Writing the types out explicitly forces you to think about the types of what you're writing, which is a valuable tool to understanding Haskell.  Also, if you get something wrong, having explicit types will help the compiler give you better error messages.
08:31:22 <eddieRay> My project proposal also has to implement some form of concurrency
08:31:34 <magneticduck> (avoids complicated type errors later when you try to use your value)
08:32:03 <gwz> mm okay thanks, I can see myself struggling with these types when things get a little complex
08:32:23 <magneticduck> gwz:
08:32:24 <Twey> gwz: If you don't write the types of things down, the compiler might infer a perfectly valid type that isn't the type you expected, and then you'll get an error message somewhere else entirely when you try to use the value as if it were the type you thought it was
08:32:26 <magneticduck> @type (.) . (.)
08:32:27 <lambdabot> (b -> c) -> (a -> a1 -> b) -> a -> a1 -> c
08:32:28 <magneticduck> HAVE FUN
08:32:41 <pjdelport> gwz: You can leave them out, and use ghci to get the inferred type.
08:32:48 <gwz> can a method return a object
08:32:54 <gwz> of type X
08:33:05 <magneticduck> gwz: that's called a function
08:33:12 <magneticduck> and of course it can, it's all functions do
08:33:24 <gwz> like I am thinking OO here where you give it car and it is able to return all hondas/toyotas etc
08:33:30 <magneticduck> remember, haskell functions are pure if you don't see an IO constructor in its type
08:33:44 <magneticduck> all a pure haskell function does is takes a value and returns another value
08:34:24 <Twey> gwz: Give what a car?  And what is a car?
08:34:44 <Twey> (or rather, how are you thinking of representing a car as a programming-language value?)
08:34:50 <magneticduck> gwz: there are a few ways to handle contexts, like the one you're talking about in your problem there
08:34:57 <magneticduck> the simplest is just to supply the context as a value
08:35:09 <khyperia> I think gwz means "give the function a list of objects of type Car, and then return all cars that have subtype Honda", aka very-OOP-style-programming
08:35:18 <gwz> well I was thinking Car is some sort of object with some instance variables and what not
08:35:19 <gwz> yuh
08:35:22 <gwz> what khyperia  said
08:35:26 <magneticduck> gwz: learn about haskell data types
08:35:32 <magneticduck> we don't have objects, we have data types
08:35:38 <Twey> gwz: We don't have objects here (… usually; you can implement them but they're not all that useful)
08:35:41 <gwz> http://learnyouahaskell.com/ good source of information?
08:35:47 <Twey> gwz: Yes, read that
08:35:48 <khyperia> yeah, lyah is great
08:35:56 <gwz> okay thanks a lot
08:36:15 <gwz> wow I cant remember the last time IRC was this friendly, maybe back in the days >.>
08:37:10 <TovenaarKluns> Having read all that, I'm still in doubt how I should represent a car in haskell.
08:37:17 <Twey> gwz: It's a point of pride for the channel.  ☺
08:37:17 <TovenaarKluns> Especially when a car should hold a lot of data.
08:37:37 <Twey> TovenaarKluns: It rather depends what you want your car to do/be
08:38:00 <monochrom> use a data type with a lot of fields
08:38:06 <c_wraith> a car full of sd cards can hold a *lot* of data.
08:38:13 <c_wraith> The trick will be finding it all.
08:38:27 <gwz> lol
08:38:30 <TovenaarKluns> Say you're writing a traffic simulation.
08:38:34 <Twey> TovenaarKluns: Probably just something like: data Car = Car { carMake ∷ String, carModel ∷ String, carRegistration ∷ Registration, … }
08:39:09 <monochrom> "don't underestimate the bandwidth of a car full of SD cards, ramming head-on into a train"
08:39:24 <magneticduck> TovenaarKluns: in a traffic simulation, I'm fairly sure you'd just want a car data type to hold a finte, and fairly small, set of strict data and stuff
08:39:32 <magneticduck> monochrom: that's a lot of bandwidth!
08:39:41 <khyperia> or, if you need different fields (and you want to be able to pass around, say, a Honda by itself and know it's a honda), make a couple different data types, then lump them together in a big "data Car = HondaCar Honda | ..."... or is that not a good way to do things?
08:39:42 <Twey> TovenaarKluns: … , carPosition ∷ Point, carBrakingAccel ∷ Float, …
08:39:53 <pjdelport> gwz: If you want a more direct, imperative-style version of your code for comparison, see http://lpaste.net/100570
08:40:35 <Twey> khyperia: That's probably not a good way to do it because then your ‘Car’ is limited only to those makes
08:40:50 <Twey> khyperia: OTOH if you know you only ever care about those particular makes, that's fine
08:41:07 <TovenaarKluns> Regarding a similar problem, I have another question
08:41:07 <gwz> pjdelport: thanks thats very familiar and quite easily understandable
08:41:17 <khyperia> then perhaps a typeclass, Twey? (guessing here)
08:41:30 <TovenaarKluns> How would the basic architecture of this program be, since there is a lot of state to pass around?
08:41:36 <Twey> khyperia: A typeclass is certainly an option, but sounds like overkill for TovenaarKluns' example
08:41:45 <khyperia> yeah, I'm just generalizing
08:41:46 <magneticduck> khyperia: yeah, you could make a Car typeclass with a bunch of Car-like instances
08:41:58 <gwz> btw, is something like this allowed, http://lpaste.net/6748570623443730432
08:42:02 <magneticduck> but of course you wouldn't be able to add car types at runtime
08:42:05 <Twey> TovenaarKluns: For something like a simulation, you probably want something like FRP
08:42:25 <magneticduck> gwz: only one type definition per value
08:42:32 <Twey> TovenaarKluns: Which is a controlled and relatively well-understood means of talking about the state of the world at a point in time
08:42:35 <magneticduck> ghc would give you an error on the second type definition for that
08:43:02 <magneticduck> gwz: also, return is a monad constructor
08:43:05 <magneticduck> @type return
08:43:06 <lambdabot> Monad m => a -> m a
08:43:08 <khyperia> basically, you can't do that because haskell doesn't figure types out at runtime (return type is dependant on parameters)
08:43:12 <magneticduck> @type return "hey there" :: IO String
08:43:13 <lambdabot> IO String
08:43:39 <gwz> OH i see what you are saying
08:43:39 <Twey> gwz: No, that's not allowed in general, because if lst is some list, you no longer know whether ‘run lst’ has type IO () or String
08:43:52 <TovenaarKluns> Twey, hmm. I should look into that. Do you have any recommendation on a good FRP library?
08:43:59 <TovenaarKluns> Twey, or would you recommend throwing something together yourself?
08:44:32 <Twey> gwz: You *can* write a function run ∷ [String] → Either (IO ()) String  (but that's definitely not what you want here)
08:44:33 <gwz> okay so haskell doesn't support method overloading like this
08:44:47 <khyperia> gwz, it's not overloading
08:44:51 <Twey> gwz: I wouldn't say it doesn't support it, more that it's above your level right now
08:45:18 <magneticduck> gwz: http://hackage.haskell.org/package/base-4.6.0.1/docs/Text-Printf.html#v:printf ^^
08:45:22 <khyperia> it's the equivalent of writing "string Foo(ListOfString arg); void Foo(ListOfString arg);" even imperative programming doen't allow that
08:45:25 <Twey> gwz: The ‘printf’ function is an example of a function that does something similar, returning either an IO () or a String (or other things) depending on what you need it to return
08:45:25 <gwz> true the input is the same type
08:45:51 <Twey> gwz: But you should learn basic Haskell before you dive into the magic that is printf :þ
08:46:03 <magneticduck> it's not magic, it's typeclass
08:46:08 <magneticduck> classy types
08:46:19 <Twey> magneticduck: printf is a pretty magical use of a typeclass.
08:46:34 <ion> a.k.a. evil
08:46:40 <magneticduck> well, it does go against the normal rule that a function only has one type
08:46:43 <Twey> (in the sense that it's hard to understand for beginners, not in the sense that it's some kind of special case)
08:46:52 <Twey> Perhaps maxBound would be a better example
08:46:55 <Twey> :t maxBound
08:46:56 <lambdabot> Bounded a => a
08:47:17 <Twey> > maxBound ∷ Int -- gwz
08:47:19 <lambdabot>  9223372036854775807
08:47:20 <Twey> > maxBound ∷ Word8 -- gwz
08:47:22 <lambdabot>  255
08:47:46 <monochrom> printf is a bit more than just type class.
08:47:58 <Twey> TovenaarKluns: I'm not the best person to ask about this.  I like reactive-banana, but I hear that other libraries are better suited for simulations — maybe netwire?
08:48:12 <magneticduck> typewitchcraft
08:49:00 <Twey> TovenaarKluns: Writing your own FRP library is currently a bit of an undertaking, but might be good for educational purposes
08:49:28 <khyperia> Oh, neato, I never knew about printf before, looked up the type, that's pretty nifty
08:49:33 <monochrom> LYAH will cover type class and how nicely == and + are flexible
08:49:43 <TovenaarKluns> Twey, thanks!
08:50:04 <Twey> khyperia: No, it's evil
08:50:16 <Twey> khyperia: It has runtime errors if you pass something of the wrong type
08:50:24 <magneticduck> runtime type errors
08:50:26 <Twey> khyperia: There's a Template Haskell version that's much better
08:50:26 <khyperia> yeah, I was thinking of that
08:50:39 <khyperia> Yay for template haskell
08:50:58 <Twey> But generally strings are just not a good format for templates
08:51:11 <hpc> runtime "type" errors
08:51:24 <k0ral> Hello, I have the exact same issue as in https://stackoverflow.com/questions/10292868/how-do-i-pretty-print-a-table-in-haskell; would you know how to fix it without using the 'boxes' library ? I'd like to stick to 'pretty'
08:52:43 <Twey> k0ral: I'd use boxes if I were you
08:52:44 <khyperia> I think F# does witchcraft at compiletime and treats the printf string specially... which I think is cool that Haskell allows you to implement that witchcraft without relying on it being hardcoded into the compiler.
08:53:13 <Twey> khyperia: *nod* C does the same
08:53:26 <Twey> Well, modern C compilers do; I don't think it's standard
08:53:38 <k0ral> Twey: do you have a better reason than "the guy in stack overflow says it works" ?
08:53:54 <Guest16420> How can I use openFile, and handle file not found?
08:54:01 <geekosaur> pretty's not designed for it?
08:54:21 <magneticduck> Guest16420: paste your code
08:54:28 <magneticduck> @hpaste
08:54:29 <lambdabot> Haskell pastebin: http://lpaste.net/
08:54:29 <Guest16420> inh <- catch (openFile filename ReadMode) (\e -> putStr "oops")
08:54:33 <k0ral> geekosaur: is that a statement ?
08:55:12 <geekosaur> k0ral, I haven't studied pretty that extensively but what I've seen of it doesn't seem to be up to formatting in restricted areas (like table cells)
08:55:23 <Guest16420> http://lpaste.net/100572
08:55:32 <k0ral> 'pretty' and 'boxes' expose almost the exact same API, I would be really surprised if they weren't designed for the same thing
08:55:46 <geekosaur> except pretty is much older
08:56:02 <k0ral> therefore I expect 'pretty' to succeed wherever 'boxes' does
08:56:07 <geekosaur> one can infer that boxes was written to fill a need though
08:56:26 <geekosaur> and using a similar API to pretty suggests it's there to be a drop in replacement that adds functionality
08:56:35 <k0ral> and as a matter of fact, 'pretty' was maintained until more recently than 'boxes' was
08:57:27 <k0ral> which doesn't prove it works better, I give you
08:57:29 * hpc infers that someone didn't know about pretty and uploaded boxes instead
08:57:50 <hpc> (see also: cpan's fifty blooblejillion json parsing modules)
08:58:00 <geekosaur> also "maintained" doesn't prove as much as you'd think; it can mean minor fixes while other libraries add significant functionality
08:58:03 <magneticduck> btw question about parsec: what's with the Parsec.ParserCombinators.* modules? compatability?
08:58:20 <hpc> magneticduck: hysterical raisins
08:58:20 <geekosaur> magneticduck: parsec 2 backward compat, yes
08:58:27 <hpc> the module structure changed between 2 and 3
08:58:36 <bennofs> Does pretty have support for "rectangles" ?
08:58:54 <magneticduck> no, just boxes
08:58:56 <bennofs> For example, if you want to make a table?
08:59:02 <geekosaur> k0ral, a non-haskell example is that O'Reilly regularly updates its Perl books but they still teach what amounts to 20 year old Perl 4
08:59:03 <magneticduck> =P
08:59:31 <Twey> k0ral: ‘It does what you want without messing around’ :þ
08:59:37 <monochrom> I disagree that boxes has almost the same API with pretty. do not be fooled by corresponding names and types. what about semantics? in fact they have almost opposite semantics. boxes deliberately does vertical column alignment, pretty deliberately does not.
09:00:21 <Guest16420> magneticduck:http://lpaste.net/100572
09:00:40 <k0ral> monochrom: I would expect column alignment to be pretty much the core feature of both libraries
09:00:52 <magneticduck> Guest16420: first of all, that's an awfully strange way of defining a function
09:00:59 <k0ral> monochrom: what would it be if not column alignment ?!
09:01:00 <magneticduck> s/dumpfile(filename)/dumpfile filename
09:01:06 <monochrom> I respect your expectation. but have you actually checked?
09:01:45 <monochrom> indentation. pretty does indentation.
09:01:57 <k0ral> monochrom: I can't afford to read every library source, I trust maintainers (maybe I shouldn't=
09:01:59 <k0ral> )
09:02:11 <monochrom> you can test. I have never read its source.
09:02:24 <Guest16420> well ok, but how can I make the exceptions stuff work?
09:02:26 <k0ral> I tested, that's why I'm asking for help
09:02:58 <monochrom> indentation means that between two rows, you can align the 1st and 2nd columns, but you can't align other columns.
09:03:21 <magneticduck> Guest16420: one moment please...
09:03:47 <magneticduck> Guest16420: "oops" isn't a handle
09:04:04 <magneticduck> how do you expect inh to assume a handle value if the second argument of catch doesn't return a handle =P
09:04:08 <magneticduck> I reccomend a different form
09:04:22 <k0ral> trying boxes right now
09:04:29 <haasn> magneticduck: () isn't a handle*
09:04:38 <haasn> () isn't a Handle*
09:04:54 <enthropy> if you have the table as a [[String]] to start, you can make a table with pretty... but then again you can also make a table from that using Data.List
09:05:27 <Guest16420> well, magneticduck, I was gonna get to that, and somehow abort or something, but I figurecd first things first.
09:05:34 <k0ral> yeah, works right with boxes
09:06:10 <Guest16420> What I want to do is basically print file if exist, else print error and abort
09:07:31 <Guest16420> and go on with next file
09:07:35 <k0ral> thanks for your help
09:08:23 <magneticduck> Guest16420: okay
09:08:25 <monochrom> Guest16420: reload the paste, I have added how I would do it below
09:08:46 <magneticduck> yeah
09:13:14 <Guest16420> magneticduck: can't get that to compile
09:13:59 <Guest16420> No instance for (Exception e0) arising from a use of `try'
09:13:59 <Guest16420>     The type variable `e0' is ambiguous
09:14:15 <monochrom> oh, I see, yeah, I haven't tested
09:15:32 <monochrom> darn it I'll do the correct long way and use tryJust
09:16:09 <magneticduck> lol I was trying out something longhand with try and custom Maybe return values and I got that error, can't figure it out
09:16:17 <magneticduck> I gave up after 2 minutes and went back to parsec
09:16:24 <magneticduck> sorry Guest16420
09:16:34 <magneticduck> =P
09:17:02 <magneticduck> anybody here using syntastic and ghc_mod?
09:17:12 <magneticduck> I wish I had better error messages from ghc_mod. :<
09:17:22 <Guest16420> ok no prob :)
09:17:40 <magneticduck> really annoying; for instance, it decides to cut out all of the newline characters
09:19:42 <monochrom> Guest16420: reload again, the last one has it corrected and tested
09:20:17 <monochrom> magneticduck: "try" is too polymorphic, that's why. it doesn't know which exception type you like.
09:20:37 <magneticduck> oops, my brain just went into haskell-noob-mode; ix.io/aSH
09:21:07 <monochrom> oh, parsec's "try". then nevermind
09:21:16 <magneticduck> monochrom: no, regular "try
09:21:18 <magneticduck> "
09:21:23 <monochrom> ok, then yeah
09:21:31 <magneticduck> I was trying to solve Guest16420's problem with only try
09:22:08 <monochrom> it could be done with ScopedTypeVariables so that you can write Left (e :: IOException) -> putStr "oops"
09:22:25 <monochrom> but I don't want to explain ScopedTypeVariables!
09:22:29 <magneticduck> yeah
09:22:31 <magneticduck> :|
09:22:36 <magneticduck> any idea about my parsec problem?
09:22:39 <khyperia> how does one check for cabal packages that have a newer version?
09:22:53 <magneticduck> it gives me the strange error: "can't match type a with [Char]"
09:23:00 <monochrom> also, in real code, tryJust is better because you always have further restrictions
09:23:00 <magneticduck> uh, 'a' is a wildcard type, it should match everything right?!?
09:23:06 <magneticduck> yeah
09:23:12 <mzero> khyperia: you look on hackage
09:23:17 <mzero> 'cause that's where cabal looks!
09:23:34 <khyperia> so there's no automated way?
09:23:47 <magneticduck> dude, it's huge a page on the internet, of course you can automate it =P
09:23:56 <magneticduck> there is a myraid of commandline hoogle / hackage utilities
09:24:01 <monochrom> "testOr' :: Parser a" means that the user, not the author, has the right to choose what "a" should be at each call site.
09:24:16 <mzero> though I suppose     cabal install --dry-run --reinstall foo
09:24:18 <mzero> would check
09:24:22 <magneticduck> monochrom: ...ah yes
09:24:35 <mzero> but remember to do    cabal update    first (which reloads the catalog from Hackage)
09:24:47 <magneticduck> *brain snaps out of haskell-noob-mode and back into kind-of-medicore-haskell-amateur-mode*
09:24:54 <monochrom> haha ok
09:25:39 <mzero> khyperia: just never use --reinstall without the --dry-run
09:25:50 <khyperia> right
09:28:10 <magneticduck> oh boy, using vim and i3 is kind of annoying, because vim uses hjkl for movement, and i3 uses jkl; for movement :D
09:28:22 <magneticduck> I have to constantly snap my fingers into a slightly different layout
09:28:54 <monochrom> what does i3 do?
09:29:53 <magneticduck> monochrom: it's a window manager
09:29:55 <magneticduck> it's pretty cool
09:30:03 <magneticduck> I should be using xmonad in the spirit of haskell
09:30:05 <Twey> magneticduck: Why is there a semicolon on your home row?  x.x
09:30:16 * Twey has never understood why anyone thinks this is a good idea
09:30:20 <magneticduck> US keyboard?
09:30:38 <enthropy> so you can use explicit layout
09:31:00 <monochrom> so you can write C code more efficiently. also Pascal code.
09:31:05 <Twey> For all those people who use the semicolon more often than the letter e, I guess
09:31:12 <S11001001> and lisp comments
09:31:28 <geekosaur> never try to understand qwerty
09:31:54 <Twey> I've long accepted that I don't understand QWERTY; I have trouble accepting that there are still people who use it :þ
09:32:07 <monochrom> in fact, I go further. never try to understand humans. and corollarily, human designs.
09:32:09 <chirpsalot> Twey: Dvorak?
09:32:17 <Twey> chirpsalot: At the moment, yes
09:32:22 <chirpsalot> Twey: samesies.
09:32:24 <Twey> (Programmer's)
09:32:33 <monochrom> I am too lazy to learn dvorak. never try to understand me.
09:32:41 <magneticduck> Dvorak eh
09:32:43 <magneticduck> mmm
09:32:44 <chirpsalot> Twey: ah. I don't know if I agree with the number layout on programmer's Dvorak.
09:32:45 <magneticduck> uh
09:32:48 <magneticduck> do you actually type faster on it?
09:32:50 <magneticduck> :D
09:32:53 <magneticduck> I'm fairly happy with my keyboard setup atm
09:32:58 <magneticduck> I know it doesn't make any sense
09:32:59 <chirpsalot> Twey: also they swapped semi-colon and apostrophe, I think?
09:33:07 <monochrom> but what would happen to vi under dvorak! :)
09:33:08 <Twey> magneticduck: Probably not.  Hurts a lot less, though.
09:33:10 <magneticduck> but http://data.typeracer.com/pit/profile?user=magneticduck =P
09:33:14 <Twey> chirpsalot: Yeah
09:33:21 <Twey> monochrom: Remapping.  :þ
09:33:25 <magneticduck> 104 is a bit of a dissapointment actually, I get a lot better on a good day
09:33:33 <chirpsalot> monochrom: vi actually works okay under Dvorak without remapping.
09:34:00 <chirpsalot> monochrom: Twey it's annoying that, at least when I had checked, nobody had really made a good vi / vim rebinding for dvorak.
09:36:00 <pjdelport> I find hjkl to work a lot better under Dvorkak, personally.
09:36:30 <Twey> magneticduck: I keep wanting to learn to use Plover to ace these silly typing races
09:36:33 <pjdelport> Dvorak, even
09:36:47 <Twey> chirpsalot: I don't use vi, so
09:37:09 <Twey> magneticduck: My nice keyboard only does 6-key roll-over, though
09:37:42 <chirpsalot> pjdelport: yeah, it's perfect under either layout.
09:38:03 <Sculptor> dvorak? no, thanks. home row navigation? no, thanks
09:38:38 <chirpsalot> not perfect*
09:38:44 <magneticduck> Twey: ikr
09:39:07 <magneticduck> I have a strange feeling that a lot of those people are using things like plover (300 WPM? Uh, I doubt you're using qwerty)
09:39:54 <Twey> magneticduck: Yeah, IRC the world typing record is 220 WPM with Dvorak
09:40:00 <Twey> IIRC**
09:40:21 <magneticduck> lol, professional typists type at speeds of 50 to 80 WPM
09:40:29 <magneticduck> huh.
09:40:48 <Twey> magneticduck: Says who?
09:40:51 <magneticduck> oh, never mind (reading wikipedia article)
09:40:57 <Sculptor> it's not important how fast you type. it's important what you type
09:41:29 <Twey> It's kind of important how fast you type.  I remember being daunted by large programs as a child because they took so long to type up.
09:41:30 <magneticduck> yeah =P
09:41:39 <magneticduck> which reminds me, I have to type my parser thing
09:41:58 <Twey> Working memory only lasts so long
09:41:58 <magneticduck> Twey: well you aren't going to find me writing large programs on a calculator
09:42:16 <Twey> Uhh… good.  :þ
09:42:34 <chirpsalot> magneticduck: lol, I did that.
09:42:35 <magneticduck> largest I ever wrote was just like 700 characters =P
09:44:05 <magneticduck> I don't really understand the whole calculator-programming world
09:44:12 <magneticduck> people who write games on calculators as a hobby
09:44:40 <magneticduck> well, I guess I can kind of understand how it's fun to program simple machines
09:44:45 <magneticduck> but there are cooler things to program
09:45:20 <chirpsalot> magneticduck: well, in school it made my life much easier when we had to do a bunch of tedious uselessness.
09:45:34 <magneticduck> you wrote programs to solve problems you mean?
09:45:39 <gwz> hey, why is it complaining about type here, it seems pretty clear to me what I want, http://lpaste.net/8465791847959101440
09:46:15 <cyr> hello
09:46:16 <cyr> http://slashdot.org/submission/3377001/four-people-decided-the-fate-of-debian-with-systemd-bad-faith-likely
09:46:35 <geekosaur> this has what to do with haskell?
09:46:44 <magneticduck> cyr: :D
09:46:55 <magneticduck> haskell parsing issue?
09:47:02 <magneticduck> gwz: yeah, do expressions are only for monads son
09:47:13 <geekosaur> gwz: main'a type is `IO a` not `IO a -> something else`
09:47:15 <magneticduck> they're syntatical sugar for (>>) and (>>=) and things
09:47:17 <geekosaur> *main's
09:47:32 <triliyn> gwz: you cold get it to typecheck if you said "return (parse (args !! 0))", but that still wouldn't do anything
09:48:09 <magneticduck> gwz: you have to learn how haskell is, not how you think haskell should be =P
09:48:14 <magneticduck> are you doing a tutorial?
09:48:28 <gwz> I was trying to get splitting of string to work
09:48:34 <gwz> given an input
09:48:40 <magneticduck> gwz: take some advice
09:48:47 <magneticduck> start with pure functions exclusively
09:48:49 <simon> gwz, assuming you changed main's type into 'IO ()', then the line 'parse (args !! 0)' does not have this type.
09:48:56 <magneticduck> write a module, load the module into ghci, do your testing that way
09:48:58 <magneticduck> deal with IO later
09:49:13 * BMeph weeps softly in a corner, scarred for life at the sight of "args !! 0"...
09:49:15 <magneticduck> try to avoid IO whenever you can, it's good haskell practice to keep most of the program pure
09:49:18 <gwz> ok
09:50:51 <c_wraith> BMeph: for life?
09:53:06 <Guest16420> monochrom: So I was trying to make sense of the code, you wrote but I don't really understand what is happening
09:54:00 <Guest16420> Basically tryJust and sieve makes einh either an exception or a handle?
09:54:01 <c_wraith> it's not just good haskell practice to avoid IO whenever possible..  It's good software engineering.
09:55:23 <Guest16420> http://hackage.haskell.org/package/base-4.6.0.1/docs/Control-Exception-Base.html#v:tryJust
09:55:38 <Guest16420> that description really doesn't explain a lot
09:55:52 <monochrom> yes
09:57:54 <pranz> Guest16420: if the function returns None or an exception, it will return an IO exception
09:58:27 <monochrom> the fundamental problem is this. there are many exception types. "try" is very polymorphic about that. (well, "tryJust" too, but I'll get to that.) I need to say "IOException" somewhere, it can't be easily inferred.
09:59:00 <monochrom> so one purpose of "sieve" is a place to write an explicit type
09:59:45 <pranz> oh nvm, misread the type
10:00:11 <monochrom> there is a secondary consideration. eventually you may like to say "among all possible IOExceptions, I just want to catch the file-not-exist kind, and let others go". if you do that, then "tryJust" is exactly right. (I haven't done that.)
10:01:25 <monochrom> the same could be said about "catch" and "catchJust". but if you read the Control.Exception doc completely, you will see why they should be seldom used.
10:05:52 <Guest16420> monochrom: I don't understand much of what the Control.Exception doc says
10:08:36 <Guest16420> thanks for the help anyway :D
10:10:27 <bernalex> Twey: how would I stop this updater? I am going to get gtk to listen for the space key, and have it mean "pause". so I would need it to run only if not paused. if you don't remember, you can refer to http://lpaste.net/100524 because your paste is basically the same as what I have
10:11:17 <bernalex> Twey: also I guess this thing isn't very suited for going back/forward manually, considering nextWord just "destroys" the list, heh.
10:12:04 <bernalex> guess I'll use a tuple for ([String], Int) where Int is the currently active word
10:17:00 <[1]grant> I have a socket I'm going to be reading HTTP requests from. Any idea on the best way to measure the data rate that they are sending the request with?
10:17:33 <quchen> Make timestamp, read data, calculate Δ?
10:18:51 <[1]grant> I'm not super intimate with lower level network programming. If someone sends an HTTP request, and I call recv on the socket, can I read data before they are done sending it?
10:19:22 <hpc> you can't read data that isn't sent
10:19:30 <mzero> [1]grant: yes, yes you can -
10:19:33 <hpc> but the sender can send a large piece of data incrementally
10:19:43 <mzero> that is, you can read data they have sent, but they may not have finished sending the whole HTTP request
10:19:51 <[1]grant> What I'm getting at is I want to be able to detect a slowloris attack
10:20:09 <[1]grant> so if they are sending data at 1 byte per second, I want to just kill the connection
10:20:11 <quchen> Aaah. Should have said that in the first place :-)
10:20:15 <monochrom> you can use busy waiting.
10:20:32 <mzero> [1]grant: I'm pretty sure the existing major Haskell web server platforms all do this already
10:20:43 <[1]grant> mzero: Yes, but I am making one for learning purposes
10:20:53 <mzero> are you doing this to learn low level details? If not, just use Snap or Warp to do it
10:20:57 <mzero> ah - okay then!
10:21:33 <mzero> then yes, you are coding at the TCP level, and while it is a stream of data, the "chunks" you read that stream in may... or may not!... correspond to the chunks the sender sent (though all in order)
10:21:49 <mzero> and the sender is under no obligation to send a single request in minimal chunks
10:22:51 <[1]grant> so what route should I take to detect a malicious slow sender?
10:23:44 <[1]grant> Would it just be keeping time deltas of each socket read?
10:24:11 <mzero> yes
10:24:21 <mzero> well
10:25:07 <mzero> another way is to set a thread that kills the reading thread after, say 5 seconds (or whatever)
10:25:19 <mzero> then on each read, from the reading thread, kill the killing thread and recreate it
10:25:21 <mzero> OR
10:25:37 <mzero> don't kill stuff just leave a "last read time" MVar for the killing thread to check
10:25:58 <mzero> actually, I like this direction more than the time-delta mechanism
10:26:08 <[1]grant> For what reason?
10:26:18 <mzero> because you can drop the slowloris request before waiting for the next packet
10:26:38 <davean> mzero: That is not preventing a slowloris attack
10:26:45 <davean> mzero: a slowloris attack sends data regularly
10:26:48 <davean> but at a slow rate
10:27:01 <magneticduck> http://ix.io/aSJ <-- wtf parsec errors?
10:27:04 <mzero> well - again, you keep that info in the MVar, let the killer make the decision
10:27:05 <davean> YOu've just designed what it defeats
10:27:29 <mzero> and again, the slowloris attack could start... then if they just stop sending packets.... how are you going to kill the request if you only check at packet reception time
10:27:30 <davean> mzero: you'll do better looking at the *rate* it is sent
10:27:32 <davean> now how often
10:27:41 <mzero> keep the rate and the last time in the MVar then
10:27:43 <davean> *not how often
10:27:45 <[1]grant> magneticduck: reading, one sec
10:27:58 <davean> mzero: yes, I'm just saying you were doing it exactly wrong
10:28:23 <magneticduck> [1]grant: uhm, the word should also terminate with an eof
10:28:25 <davean> You designed a fine thread killer
10:28:26 <magneticduck> right?
10:28:33 <mzero> really? Wouldn't you still use two threads to do this?
10:28:36 <davean> you just designed a thread killer that is exactly what slowloris attacks
10:28:45 <mzero> 'cuase that was my main point, not the method of calculating when to kill
10:29:09 <magneticduck> [1]grant: oh ofc, the eof?
10:29:18 <magneticduck> nothing should have eof...?
10:29:27 <magneticduck> but then... oh man, I'm really not on the same page with parsec
10:29:51 <magneticduck> would be awesome if you could tell me exactly how to do that. The definition given in the tutorial isn't actually well formed
10:29:57 <davean> mzero: I'd use N+1
10:30:12 <davean> But he specificly asked about slowloris
10:30:18 <monochrom> "eof" seriously means eof, "the input stream ends"
10:30:40 <[1]grant> magneticduck: I am going to code what I think you are wanting, and then I'll lpaste it, one sec
10:31:07 <mzero> sure, you could use a single thread to monitor and kill multiple reqeusts - I'm pretty sure that is what both Warp and Snap do.... and pretty sure they handle slowloris in those threads, no?
10:31:12 <magneticduck> [1]grant: thanks
10:31:29 <davean> mzero: yes they do
10:31:34 <davean> well, no
10:31:38 <davean> no they don't technically
10:31:43 <davean> they do the killing in those threads
10:31:43 <mzero> ?
10:31:51 <davean> the threads themselves calculate WHEN they should be killed
10:32:09 <mzero> okay
10:32:10 <davean> All the kill thread is is a queue of timeouts
10:32:15 <quchen> magneticduck: You should also add the "<?>" parts to the appropriate parsers, and not to their usage location, like so: http://lpaste.net/100579
10:32:23 <davean> the request handles tickle the timeouts by a calculated value
10:33:13 <davean> Which works out slightly better
10:33:24 <davean> wel, *if* it works
10:33:27 <bernalex> OK I get a bunch of parse errors - what is the order for this stuff again? http://lpaste.net/1030309529859915776
10:33:35 <davean> I'll leave it as an excersize to the reader to show it works at all
10:33:40 <bernalex> (stuff being pragmas + module + copyright header)
10:33:58 <quchen> bernalex: Add your errors to the paste please.
10:34:16 <quchen> Presumably "module" has to be at the beginning of the line.
10:34:18 <bernalex> quchen: right now it's just: Main.hs|19 col 4 warning| Parse error: module
10:34:39 <bernalex> quchen: if I remove the pragma, everything is fine,, so no
10:34:53 <bernalex> quchen: I have that copyright header with module Foo where like that in all of my projects
10:34:55 <monochrom> or remove the comment
10:35:08 <bernalex> monochrom: what comment?
10:35:10 <quchen> And your error doesn't look like GHC. What's your compiler?
10:35:21 <bernalex> quchen: that's ghc-mod
10:36:13 <[1]grant> magneticduck: still there?
10:36:14 <bernalex> quchen: I am putting this stuff in cabal ATM, so it will take some time to get ghc ready if you need that output.
10:36:30 <quchen> Your paste works in GHCi here.
10:36:48 <quchen> 7.6.3, that is.
10:36:48 <monochrom> guess what, I can't reproduce the error either
10:37:09 <magneticduck> [1]grant: yeah, was doing something else x|
10:37:12 <magneticduck> but I'm back now
10:37:12 <bernalex> hm. so ghc-mod bug, maybe.
10:37:22 <bernalex> I thought it should work fine myself.
10:37:23 <[1]grant> magneticduck: kk one second, testing my code
10:37:50 <magneticduck> [1]grant: what's the difference between eof and eos?
10:38:06 <magneticduck> [1]grant: yeah you have a few typos
10:38:08 <magneticduck> but I get the idea
10:38:27 <magneticduck> <* eh
10:38:33 <magneticduck> everybody seems to love all these applicative infix operators =P
10:38:47 <monochrom> I like some of them too. but not all of them.
10:38:48 <quchen> a <* b = do { x <- a; b; return x }
10:39:05 <quchen> If you prefer the "do" way.
10:39:21 <quchen> Note that it's not "flip *>".
10:39:22 <bxc_> I found <* and *> easier when I realised that the arrow points at the result you want to keep
10:39:22 <monochrom> "I prefer to 'do' it my way" :)
10:39:30 <bernalex> quchen: monochrom: thanks for checking it out BTW. I'll try to figure out what's broken with ghc-mod after throwing everything into cabal and making that work.
10:39:52 <magneticduck> quchen: it's not?
10:39:55 <magneticduck> ...
10:39:56 <davean> 080
10:39:59 <magneticduck> oh well yeah, it's not
10:40:04 <magneticduck> it still evaluates a, then b
10:40:08 <quchen> Right.
10:40:20 <magneticduck> awlright
10:41:03 <quchen> As bxc_ said, you can read <* and *> as "keep only what the arrow points at".
10:41:17 <quchen> Everything is still evaluated left-to-right, in a sense, though.
10:41:48 <magneticduck> [1]grant: anyway, your code still doesn't seem to want to parse "test test."
10:41:51 <magneticduck> :|
10:42:10 <[1]grant> magneticduck: I didn't paste any code?
10:42:35 <[1]grant> quchen did, though
10:42:38 <magneticduck> oh
10:42:41 <magneticduck> thought it was yours
10:43:02 <quchen> I didn't improve the code logic, just moved definitions around.
10:43:06 <[1]grant> Here is my code, though http://lpaste.net/100581
10:43:07 <magneticduck> ahk
10:43:17 <[1]grant> Which I think does what you want...
10:44:15 <quchen> Eeeeh, Parsec 2 again. Don't use "Text.ParserCombinators.Parsec" unless you're dealing with a backwards compatibility thing.
10:44:28 <monochrom> hehe
10:44:34 <quchen> ?
10:44:43 <magneticduck> quchen: who's doing that?
10:44:48 <[1]grant> My code uses it
10:44:55 <[1]grant> Can be changed, though
10:45:17 <magneticduck> btw is there a cool way to make a synonym for an arbitrary value?
10:45:26 <magneticduck> prun is faster to type than parseTest
10:45:33 <quchen> x = "arbitrary value"
10:45:51 <magneticduck> but it doesn't want to be defined as prun = parseTest because of arbiritrary type variables
10:45:52 <magneticduck> try it
10:45:54 <magneticduck> it doesn't work.
10:45:55 <monochrom> make a "where prun = parseTest"
10:46:06 <magneticduck> but can't I make something global?
10:46:26 <monochrom> global is more likely to run into the monomorphism restriction
10:46:44 <magneticduck> so, no arbitrary value synonyms
10:46:49 <monochrom> local is less likely. (because local is likely to be correctly monomorphic)
10:46:50 <magneticduck> seriously no way of doing it?
10:46:57 <[1]grant> magneticduck: did that code work for you?
10:47:06 <[1]grant> magneticduck: the one I lpasted
10:47:39 <magneticduck> yes
10:47:47 <monochrom> if you insist, turn on NoMonomorphismRestrict, then you can make global "prun = parseTest"
10:48:15 <monochrom> but I fail to see why one should insist. "prun" is a very personal name to begin with
10:48:28 <magneticduck> I'm testing a module with ghci
10:48:35 <magneticduck> recompiling it, testing things out
10:48:44 <magneticduck> so I run prun from ghci a lot
10:48:45 <hpc> you can't give prun a type signature?
10:48:46 <bernalex> how would you guys structure a data structure where you have a [String], and you need to be able to iterate it word by word. i.e. I need a function that gets the current word, and one for moving to the next word, and one for moving to the previous word. i.e. the [String] of words cannot be "destroyed", it should be possible to go both ways.
10:49:05 <Twey> bernalex: You want a zipper
10:49:16 <Twey> bernalex: ([String], [String])
10:49:22 <bernalex> currently I just have data ToRead = ToRead { txt :: [String], activeIndex :: Int }, but using "indexes" like this doesn't strike me as fp.
10:49:28 <magneticduck> hpc: I guess I could
10:49:53 <bernalex> Twey: could you elaborate why this is a favourable way of doing it?
10:50:10 <magneticduck> Control.Monad.Identity is defined in multiple packages?
10:50:11 <magneticduck> oh come on
10:50:19 <magneticduck> is there that much to decide about the identity monad? :D
10:50:28 <bernalex> Twey: do you mean that when I traverse the [String], I throw read ones into the fst, and unread ones into the snd? (or vice versa if I'm going backwards)
10:50:28 <Twey> bernalex: nextWord (prevWords, word : nextWords) = (word : prevWords, nextWords); prevWord (word : prevWords, nextWords) = (prevWords, word : nextWords)
10:50:42 <Twey> bernalex: O(1) lookup for first/last word
10:50:48 <Twey> Er, next/previous word
10:50:54 <bernalex> Twey: OK, I see that's nice.
10:51:08 <Twey> And also O(1) movement forward or backward a word
10:51:22 <monochrom> perhaps use an array
10:51:38 <bernalex> Twey: is there a conventional nomenclature for the first/last of a zipper like this?
10:51:45 <Twey> bernalex: The ‘current’ word is the first element of nextWords
10:51:48 <monochrom> I know how to suggest an "immutable doubly-linked list" but that is too advanced
10:51:57 <bernalex> Twey: yes, I got that.
10:51:57 <Twey> bernalex: It's a zipper
10:52:07 <Twey> bernalex: (on a list)
10:52:33 <bernalex> Twey: I see. thanks.
11:00:30 * hackagebot socketio 0.1.1 - Socket.IO server  http://hackage.haskell.org/package/socketio-0.1.1 (TingYenLai)
11:05:26 <TheKing> @pl x_.x
11:05:26 <lambdabot> x_ . x
11:05:50 <Guest46701> @pl x->x
11:05:50 <lambdabot> (line 1, column 4):
11:05:50 <lambdabot> unexpected '>'
11:05:50 <lambdabot> expecting operator
11:05:54 <Guest46701> @pl \x->x
11:05:55 <lambdabot> id
11:06:39 <Guest46701> @pl \x->take x [0..]
11:06:39 <lambdabot> flip take [0..]
11:06:56 <Guest46701> @pl iterate (+y) 0 !! y
11:06:56 <lambdabot> iterate (y +) 0 !! y
11:07:03 <Guest46701> @pl \y->iterate (+y) 0 !! y
11:07:03 <lambdabot> (!!) =<< flip iterate 0 . (+)
11:08:48 <no-n> when pattern matching for records with several fields, do I have to put a word/_ for each field or is there another way?
11:09:13 <geekosaur> Foo {fieldIWant = localbinding}
11:09:22 <Twey> bernalex: Pass in a ‘pause’ event using an extra AddHandler, and fire it the same way as tick (but on keypress, obviously)
11:09:23 <geekosaur> or Foo {} if you just want to match the constructor
11:09:33 <Sonarpulse> oh haskell records.....
11:09:53 <no-n> geekosaur: ahhh, ty, ty :)
11:10:26 <bernalex> Twey: interesting. I will look at it shortly. right now I'm refactoring "all the other stuff". i.e. the easy stuff.
11:10:32 <monochrom> in fact, you may have not though of:
11:10:56 <monochrom> > case Just 1 of { Just{} -> True; Nothing -> False }
11:10:58 <lambdabot>  True
11:12:11 <beaky> hello
11:12:11 <haskell_newb> hello
11:12:16 <beaky> how do i unsderstand the state monad better
11:12:21 <geekosaur> yeh, as a degenerate case Foo {} works with any ADT whether it uses record syntax or not
11:12:21 <beaky> what is the best tutorial for it
11:12:35 <haskell_newb> struggling with understanding and implementation of perlin 2d noise funtion in haskell
11:12:43 <haskell_newb> got something working but there is error somewhere since for http://lpaste.net/7724568986175668224 i'm getting http://i.imgur.com/ChA7vit.gif
11:13:00 <Twey> bernalex: Then you can write a behaviour like: bPaused = accumB False $ const not <$> pause  and filter your update event, let eNextWord = whenE (not <$> bPaused) eTick
11:13:12 <monochrom> the best state monad tutorial is http://www.engr.mun.ca/~theo/Misc/haskell_and_monads.htm
11:13:21 <haskell_newb> with just ranom numbers form 0 to 1 i'm getting http://i.imgur.com/9qdudNb.gif so randering function should be fine
11:13:26 <Twey> bernalex: Then use eNextWord in bWords instead of eTick
11:13:28 <haskell_newb> must be something wrong with math
11:13:45 <bernalex> Twey: looks reasonable and neat by itself. I'm not sure I'm smart enough to get it into the codebase though, heh. I'll let you know later. right now I'm setting up file importing and menus.
11:14:21 <no-n> geekosaur: but how do i name the whole record as a parameter?
11:14:49 <Twey> bernalex: Another way to do it is to add event handlers to GTK that just pass (representations of) *every* GTK event into your network, then work out the logic of what to do in response to certain events inside the network itself
11:14:52 <monochrom> name@Foo{field_want = another_name}
11:14:54 <geekosaur> r@(Foo {...})
11:15:00 <no-n> ahh
11:15:02 <no-n> that's nice
11:15:05 <no-n> thanks
11:15:15 <haskell_newb> could you help me?
11:15:18 <monochrom> you can also do whole_list@(x:xs)
11:15:58 <no-n> yeah, i've done it with lists
11:16:10 <Twey> bernalex: I didn't include this in that code, but if you're going to be using big files (and even if not) it's a better idea to use something like https://hackage.haskell.org/package/pipes-bytestring-2.0.0/docs/Pipes-ByteString.html#v:fromHandle rather than the lazy-IO approach you've got going on currently
11:16:30 <bernalex> Twey: that's... not in scope for this weekend. ;-)
11:16:45 <monochrom> in fact, let's go crazy. suppose you are looking for x:y:more, but you also want a name to refer to the whole, and another name to refer to the y:more part. then it is: tmp1@(x : tmp2@(y : more))
11:16:50 <Twey> Alright :þ
11:17:03 <bernalex> Twey: my goal for the weekend is to have the basic crap working with file import and key bindings for pause/unpause, goto-next, goto-prev, and maaaybe setting yr own wpm.
11:17:16 <bernalex> Twey: if I can get to that stage, then I will be a very proud haskell newbie. :-)
11:17:19 <r444> http://uncyclopedia.wikia.com/wiki/Haskell
11:17:24 <Twey> bernalex: Luck!  :-D
11:19:00 <bernalex> Twey: thanks, and thanks a lot for your help thus far. I will likely nag you again once I get back to frp stuff.
11:19:12 <Twey> No problem
11:21:07 <bernalex> anyone know what's wrong here: http://lpaste.net/5131231122549637120 ?
11:21:26 <bernalex> it's a copy-paste from a gtk2hs tutorial with a few modifications (same problem with literal copypaste)
11:21:44 <bernalex> the error is for the last line
11:21:46 <monochrom> in line 6, two " s
11:22:19 <bernalex> monochrom: yesL
11:22:26 <bernalex> s/L/?
11:22:46 <bernalex> the whole thing is here: http://muitovar.com/gtk2hs/chap7-1.html
11:22:53 <monochrom> the first " closes the " in line 1. it is cool. the 2nd " now is lonely
11:23:39 <bernalex> yes, that does make sense to me, but they do the same thing in the full paste, so I assumed they were doing some kind of trick.
11:23:58 <monochrom> well then, the tutorial is wrong
11:24:22 <bernalex> it's probably my fault somehow when adapting it for my stuff. :-)
11:24:36 <monochrom> it has a typo. it's a work of a human.
11:27:21 <bernalex> erm. my program crashes with "hspread: Error on line 1 char 137: Document must begin with an element (e.g. <book>)". that's not a nice error.
11:27:54 <bernalex> I guess my uidecl is broken
11:29:02 <geekosaur> actually I don't think that's quite a typo, it looks like some of the page markup got escaped somehow and leaked into the listing
11:34:36 <monochrom> bernalex: you probably know that the </pre> makes no sense there anyway
11:35:34 * hackagebot penny 0.32.0.4 - Extensible double-entry accounting system  http://hackage.haskell.org/package/penny-0.32.0.4 (OmariNorman)
11:42:18 <zygentoma> hi, why does "let myP a = putStrLn ( show a )" give me "myP :: Show a => a -> IO ()", but "let myP = putStrLn . show" or "let myP = \a -> putStrLn ( show a )" give me "myP :: () -> IO ()"?
11:43:01 <geekosaur> @where DMR
11:43:01 <lambdabot> http://www.haskell.org/haskellwiki/Monomorphism_restriction
11:43:03 <tmhedberg> It's the monomorphism restriction
11:43:23 <zygentoma> k thanks, I'll read in that :)
11:43:23 <tmhedberg> Use an explicit type signature or -XNoMonomorphismRestriction
11:43:40 <quchen> The D in DMR stands for "dreaded". It's important.
11:45:15 <nadirs> quchen: haha, dejavu
11:46:55 <nadirs> what practice do you suggest when dealing with json in Haskell: 1) define distinct data types for each JS object (like the first example in Data.Aeson docs (http://hackage.haskell.org/package/aeson-0.7.0.1/docs/Data-Aeson.html)
11:47:31 <nadirs> 2) create a generic dict-like structure that maps directly to/from json data types
11:47:57 <nadirs> ? (end of question :) )
11:47:58 <hakujin> for non trivial projects I think you almost always want 1)
11:48:15 <hakujin> json is loose and fast; get back to Haskell safety asap
11:48:55 <bernalex> monochrom: yes. at first I just assumed that it was implicitly always opened, but I guess not.
11:49:12 <bernalex> geekosaur: probably.
11:49:14 <nadirs> hakujin: thanks. For more context I'm thinking about a web app that gives/takes objects to clients via a JSON API
11:50:44 <nadirs> so it makes sense to make data types for entities ("resources") that can then be translated both to DB-side tables and client-side JSON
11:51:10 <hakujin> you want a schema of sorts
11:51:24 <nadirs> a schema of sorts?
11:51:27 <hakujin> that defines your data going across the wire
11:51:59 <flebron> Hi. When using -XDataKinds, say I have data Nat = Nil | Suc Nat. * is a kind, and Nat is a kind. Is there a relation between * and Nat? (When I say Nat, I perhaps should clarify that as 'Nat, the kind, not Nat the type).
11:52:30 <Twey> nadirs: JSON is already a generic dict-like structure that maps directly to/from JSON types.  The point of marshalling it is to get it into a nice type-safe form that's safer and easier to deal with in Haskell.
11:52:32 <flebron> And would it be reasonable to say that Suc has kind Nat -> Nat?
11:52:43 <Cale> flebron: yes, it would
11:52:45 <Twey> flebron: Yes
11:52:59 <Cale> flebron: There's no particular relationship between * and Nat then
11:53:00 <Twey> flebron: There's no relation between ★ and Nat except that they both have the same sort
11:53:16 <flebron> Ah yes, that rabbit hole.
11:53:52 <flebron> So it'd be incorrect to say that Nil also has kind *?
11:54:06 <Twey> Yes
11:54:23 <flebron> And also impossible to make something like Nat a Functor, since its kind isn't * -> *
11:54:47 <Twey> Yes, but you can't fmap things on the type level anyway
11:54:53 <nadirs> Twey: thanks for the clarification. I'm always worried whether I should create several discrete data types or use a generic configurable data structure
11:54:57 <flebron> How would the set of types * be defined?
11:55:00 <Twey> (in Haskell)
11:55:04 <flebron> (Assuming it's a set of types)
11:55:19 <Twey> flebron: ★ contains the types that can have values
11:55:36 * hackagebot prednote 0.20.0.0 - Build and evaluate trees of predicates  http://hackage.haskell.org/package/prednote-0.20.0.0 (OmariNorman)
11:55:50 <flebron> Ohhh. So with DataKinds, these things can never have values?
11:56:02 <Twey> nadirs: The answer is always the former, unless your data structure is ‘configurable’ on the type level (i.e. you can pass it a parameter such that you get the separate types back)
11:56:15 <flebron> I saw some weird things with singleton types in hackage
11:56:17 <Twey> flebron: Right, it doesn't make sense to have a value of type Nil
11:56:24 <reklak> hi all, another json/aeson question: how would one approach decoding a value that could be for instance either Text or [Text]?
11:56:50 <hakujin> reklak: represent it as [Text] and pattern match on the result I think
11:56:57 <Twey> flebron: You can have something of type Sing Nil, whose single value is some kind of value-level equivalent of Nil.  That's what Sing is for.
11:57:12 <nadirs> Twey: makes a lot of sense. Since those are distinct entities it's not right to unify their type to a generic data structure
11:57:16 <Twey> flebron: Sing's argument isn't required to be of kind ★.
11:57:16 <beaky> hello
11:57:32 <flebron> Twey: What would Sing's kind be?
11:57:34 <reklak> hakukin: thanks, I'l give that a try
11:58:03 <Twey> flebron: Sing ∷ k → ★
11:58:08 <nadirs> hakujin: I'd like to learn more about this "schema of sorts". Do you have any doc/article to point me to?
11:58:11 <flebron> Fair enough.
11:58:12 <Twey> (a kind variable)
11:58:24 <Twey> (you need PolyKinds on to see that)
11:58:39 <flebron> Oh right, because k could be something like * -> *.
11:58:43 <hakujin> reklak: that assumes you're in control of generating the JSON...if you're consuming existing data that is either Text or [Text] that's different
11:58:55 <Twey> flebron: No, because k is a polymorphic kind.  :þ
11:59:04 <flebron> Well yeah :p
11:59:16 <flebron> Just to be clear, what is meant by polymorphic here?
11:59:26 <Twey> flebron: It can be instantiated to more than one possible kind
12:00:28 <Twey> flebron: E.G. Nat → ★ is a valid kind for Sing.
12:00:39 <flebron> Right :)
12:00:50 <flebron> Thanks!
12:00:55 <Twey> No problem
12:05:08 <reklak> hakujin: ah, yes, the latter actually. I'm trying to parse some bibliographic json, specifically pulling out the subject field, which is either a string or list of strings.
12:05:20 <Twey> reklak: The correct answer to your question depends on what you want to happen when you have something that's [Text] vs. Text.  Do you want to be able to tell the difference later on?  If so, you're going to have to pack it into something like Either Text [Text].  Otherwise, you can convert one into the other somehow, such as by wrapping the single Text into a list, or by concatenating the list into a single
12:05:22 <Twey> Text.
12:06:25 <flebron> Is there a reason why ExistentialTypes is an extension, and not part of the language? (Maybe it becomes inconsistent or something, even without bottom). Is it just a historical thing?
12:07:01 <reklak> twey: wrapping the single Text was something I tried but couldn't figure out where/how it should be done.
12:07:03 <hpc> many reasons
12:07:44 <Targen_> it doesn’t get along well with type inference
12:07:45 <hpc> it's not entirely certain if there is a need for it, it's possible there are more desirable features that existential types are mutually exclusive with
12:08:07 <hpc> also the syntax for it might change in a way that breaks existing code
12:09:24 <Twey> flebron: It's known to be consistent (with standard type theories), but we don't know that it's implemented the best way
12:10:21 <flebron> Does it go along well with the categorical interpretations of Hask, similar to how universal quantification yields natural transformations?
12:10:26 <Twey> flebron: For example, it's undecidable to do type inference with ExistentialTypes, so GHC currently just assumes there are no ExistentialTypes when inferring (if you want an existential type, you have to specify it manually)
12:10:47 <flebron> :o What would be an example that shows this undecidability?
12:10:55 <[1]grant> "data ParsecT s u m a" the u stands for user state type. What is that?
12:11:02 <Twey> We know it doesn't break anything we have at the moment, but we don't know that it won't break something we want in the future
12:11:24 <Twey> flebron: There is no example you can write in Haskell, because Haskell doesn't infer existential types
12:11:31 <Twey> But for example,
12:12:28 <Twey> :t (\ f -> (f 3, f 'H')) (\x → x)
12:12:28 <lambdabot> lexical error at character '\134'
12:12:33 <tmhedberg> [1]grant: The u is any type you want; it's for implementing a stateful parser
12:12:33 <Twey> Ugh
12:12:35 <Twey> :t (\ f -> (f 3, f 'H')) (\x -> x)
12:12:36 <lambdabot>     No instance for (Num Char) arising from the literal `3'
12:12:36 <lambdabot>     Possible fix: add an instance declaration for (Num Char)
12:12:36 <lambdabot>     In the first argument of `f', namely `3'
12:12:47 <Twey> Wait, that's not an existential type.
12:13:15 * Twey tries to think of an example
12:13:26 <[1]grant> tmhedberg: So what sort of thing might you put there?
12:13:57 <flebron> That'd be the monomorphism restriction acting there?
12:14:26 <Twey> flebron: I don't think there's anything I can write in Haskell, because existential types have to be wrapped up in data constructors, so you have to explicitly write out your type signature to even produce an existential type
12:14:33 <monochrom> [1]grant: my http://www.vex.net/~trebla/haskell/parsec-generally.xhtml#state has a toy example
12:14:37 <tmhedberg> [1]grant: It would completely depend on the application, but in general you would use it when you want the parsing behavior to change based on what has previously been parsed
12:15:38 * hackagebot matchers 0.16.0.0 - Text matchers  http://hackage.haskell.org/package/matchers-0.16.0.0 (OmariNorman)
12:20:07 <solrize> let y@(x:xs) = [] in 3  doesn't bottom, but   let y@(x:xs) = [] in y   does.  hmm.
12:20:39 * hackagebot multiarg 0.26.0.0 - Combinators to build command line parsers  http://hackage.haskell.org/package/multiarg-0.26.0.0 (OmariNorman)
12:20:45 <geekosaur> pattern matching is the canonical way to force evaluation
12:21:19 <monochrom> solrize, in the second expression, it is the "in y" that forces things.
12:21:29 <geekosaur> that said, let is lazy by default (top level bindings are strict) so it doesn't actually do the pattern match until you demand its result (here, y)
12:22:04 <monochrom> "let" doesn't say "must be lazy". it only says "does not add more eagerness than other parts of your code"
12:22:25 <monochrom> well, even that is a dangerous thing to say
12:22:30 <solrize> but it doesn't need to pattern match to figure out that y is []
12:22:40 <monochrom> the most reliable thing to say is "see the Haskell report" :)
12:22:51 <Algebr> How can I interact with IO prefixed objects?
12:23:03 <solrize> is y@(x:xs) actually syntax sugar for pattern matching and then consing the two parts back together?
12:23:05 <monochrom> oh, I see what you mean. I'll think again
12:23:14 <geekosaur> solrize, since you used y@(x:xs), to get y it needs to evaluate (x:xs)
12:23:33 <geekosaur> it does the pattern match, *then* binds y to the whole expression
12:23:47 <Algebr> like I have a IO String in ghci, I want to print it
12:23:58 <geekosaur> >>=
12:24:03 <geekosaur> or use do notation
12:24:12 <solrize> Algebr, you should be able to print it in ghci
12:24:13 <monochrom> at this point I really have to say "see the Haskell report". it is a very subtle detail.
12:24:18 <[1]grant> Couldn't match expected type `text-0.11.1.13:Data.Text.Internal.Text'
12:24:18 <[1]grant>                 with actual type `String'
12:24:23 <monochrom> but I will do it and tell you the result
12:24:26 <[1]grant> Sorry, didn't know it'd paste immediately
12:24:41 <[1]grant> Anyway, Parsec is giving me that compile error when in my call to the "parse" function
12:25:18 <[1]grant> Ideas?
12:25:41 <Algebr> solrize: I can't. My variable is of type IO String and doing print my_variable errors out
12:25:58 <solrize> in ghci, just type "my_variable" at the prompt
12:26:16 <Algebr> solrize: right, but is there a way to do with the prelude print ish functions
12:26:20 <solrize> otherwise, say "my_variable >>= print"
12:26:44 <Algebr> solrize: ah, >>= did it. Is that the bind operator?
12:27:04 <solrize> ok, yes, this is a usual beginning hurdle in haskell
12:27:06 <Algebr> Like how can I "un IO" the taint of IO
12:27:21 <hpc> you shouldn't learn IO as "taint"
12:27:22 <tmhedberg> You can't, that's the point :)
12:27:25 <Algebr> and have my_variable be a regular say String rather than IO String
12:27:31 <Algebr> oh
12:27:47 <hpc> (IO String) is an effectful computation that produces a String
12:27:53 <hpc> while String is just... a String
12:28:07 <geekosaur> @quote /bin/ls
12:28:07 <lambdabot> shachaf says: getLine :: IO String contains a String in the same way that /bin/ls contains a list of files
12:28:12 <hpc> in an impure language, it might be the difference between String foo; and String foo();
12:28:31 <solrize> you can't un IO to get the value out completely.  you can only pull it out in order to pass it to a function that returns another IO value
12:28:37 <solrize> such as print, which returns IO ()
12:28:38 <hpc> if you want to do something with the resulting String, you don't take it "out of IO", you bring the thing you want to do into it
12:28:39 <geekosaur> it's not "tainted"; it's a recipe.
12:28:44 <hpc> :t fmap
12:28:44 <lambdabot> Functor f => (a -> b) -> f a -> f b
12:28:54 <Algebr> hmm, okay, thanks all.
12:29:00 <geekosaur> you can't eat the recipe, someone has to follwo it to make something
12:29:01 <hpc> fmap is one of the simpler ways of doing such "lifting"
12:29:20 <solrize> [l]grant  if you don't mind slow speed, simplest may be to unpack the Text into a String
12:30:32 <quchen> [1]grant: ^
12:30:40 <pjdelport> If you're coming from a background with Deferreds or Futures, it's not entirely unreasonable to think of IO as analogous to that
12:31:07 <pjdelport> and fmap / bind / etc. as adding a "callback"
12:31:26 <pjdelport> (but that's intuition should just be for bootstrapping)
12:31:50 <[1]grant> :t (skipMany (space <|> oneOf "\n\r"))
12:31:51 <lambdabot> Not in scope: `skipMany'
12:32:20 <quchen> skipMany = many
12:32:22 <[1]grant> What should the type of "skipMany (space <|> oneOf "\n\r")" be in a typical parser?
12:32:30 <quchen> Parser ()
12:32:40 <[1]grant> See, whenever I declare that as the type
12:32:46 <[1]grant> I am getting the crazy compile error I pasted a minute ago
12:32:52 <[1]grant> when I don't declare the type, no error
12:33:22 <quchen> Could you paste the code (plus error)?
12:33:30 <kwstas> Hello there! when we have an expression like "(map f) . (map g)" does the compiler fuse it to "map ( f . g)"?
12:33:38 <tmhedberg> Are you trying to parse Text or String? It sounds like your parser expects one and you're giving it the other
12:33:44 <quchen> kwstas: Yes, there's a rule that does this for `map`.
12:34:30 <mm_freak> who administers lambdabot again?
12:34:40 <geekosaur> @version
12:34:40 <lambdabot> lambdabot 5.0-int-e
12:34:41 <lambdabot> git clone git://github.com/int-e/lambdabot.git
12:34:45 <[1]grant> quchen: http://lpaste.net/100587
12:34:54 <jaliRancher> Hey all. I've read through some of the pages on Haskell and was wondering what is functional vs object oriented. I still don't really get it.
12:35:08 <milfjord> jaliRancher: just write a few haskell programs
12:35:20 <mm_freak> or asked differently, who can make lambdabot permanently leave a channel?
12:35:28 <milfjord> I don't even know what object oriented means
12:35:28 <[1]grant> quchen: If you uncomment any of those type statements, it fails
12:35:38 <tmhedberg> [1]grant: You imported Text.Parsec.Text which defines type Parser = Parsec Text ()
12:35:52 <tmhedberg> That means the Parser type in your program expects Text input
12:35:56 <hpc> i think if lambdabot is kicked, it forgets where it was kicked from
12:36:00 <hpc> (or if not, it should)
12:36:09 <tmhedberg> If you give it String instead, that will result in the error you're seeing
12:36:28 <pjdelport> jaliRancher: Can you be more specific? The're two largely orthogonal paradigms.
12:36:33 <geekosaur> problem is the joins are in an rc file
12:36:42 <[1]grant> tmhedberg: So what should I do instead?
12:36:46 <geekosaur> and lambdabot does not manage that rc file, it only reads it
12:36:59 <geekosaur> so you probably want to talk to int-e
12:37:11 <tmhedberg> [1]grant: Import Text.Parsec.String instead
12:37:15 <[1]grant> Thanks
12:37:19 <jaliRancher> milfjord I'm not really looking to jump in. I was just wondering what the difference is. I use JavaScript and python all the time but some of the explanations I've seen got the differences are over my head. I sifted
12:37:26 <jaliRancher> Figured I'd just ask
12:37:31 <[1]grant> aaaaaand it works, magic.
12:37:39 <kwstas> quchen: ok. but my real question is, why should the compiler do such α fusion? Isn't lazy evaluation enough to ensure that we traverse the initial list just one time?
12:38:42 <dolio> You always traverse the initial list once.
12:38:58 <jaliRancher> I see functional has functions as first class objects but is that all it takes to make a language functional?
12:39:06 <dolio> And you always traverse an intermediate list once in map f . map g
12:39:13 <dolio> It's just a question of what order you do everything in.
12:39:42 <hpc> in a way, it's like a transposition
12:39:53 <dolio> map (f . g) saves work, even if it doesn't save peak memory usage.
12:40:09 <quchen> kwstas: Right, you would only traverse xs once even without the optimization. You would, in the naive evaluation, have to construct an intermediate list (one cons cell at a time) though - and that's what the fusion eliminates.
12:40:27 <quchen> Eh, what dolio said.
12:40:39 <tmhedberg> jaliRancher: "Functional" is not really a formally defined term. First-class functions is part of it. Most people would consider an emphasis on immutability and statelessness to be a requirement as well.
12:41:04 <kwstas> so, in that case we can say that fusion saves us space and laziness time
12:41:08 <pjdelport> jaliRancher: Functional programming is a general style and way of approaching problems; it's not *really* about having specific features or not. Most functional languages will have first-class functions, but some don't. Likewise, many languages with first-class functions aren't very functional in style.
12:41:31 <pjdelport> jaliRancher: Many languages are multi-paradigm, supporting functional, OO, and other styles to varying degrees.
12:42:01 <dolio> kwstas: Laziness saves space in this example.
12:42:19 <dolio> You don't need to build the entire intermediate list in memory at once.
12:42:32 <dolio> But you still build it and take it apart at each step, which uses time.
12:42:34 <hpc> jaliRancher: perl is a good example of a language that is both a good functional and OO language
12:42:38 <Cale> pjdelport: Which functional language doesn't have first class functions? Are you talking about things like spreadsheets? :)
12:42:40 <[1]grant> I don't know if any of you guys also code Python, but being in love with Haskell style currying, I hacked this monstronsity in Python to do the same: https://gist.github.com/grantslatton/9221084
12:42:44 <hpc> if you feel like learning that after/concurrent with haskell
12:43:01 <jaliRancher> So on statelessness what does that mean? hpc
12:43:09 <Cale> fsvo "good" :)
12:43:11 <dolio> Fusion eliminates the intermediate list entirely.
12:43:19 <jaliRancher> It seems like all languages have some sort of state
12:43:44 <jaliRancher> Isn't assignment itself a form of state?
12:43:46 <kwstas> dolio: ok, i see. thanks :)
12:44:02 <Cale> jaliRancher: Evaluation of expressions in Haskell is done in such a way that it has no visible effects besides producing the resulting value.
12:44:02 <hpc> jaliRancher: it's not that you have no state, just the style of programming de-emphasizes it
12:44:03 <pjdelport> Cale: Spreadsheets too. :) But I was thinking of e.g. Backus's FP, and related ideas, too.
12:44:13 <tmhedberg> jaliRancher: Yes it is, but functional languages deemphasize mutable state and assignment
12:44:20 <hpc> you don't write as many functions that are "void doBlahAndModifyState()"
12:44:27 <pjdelport> (Obviously, it depends how wide your "functional" umbrella is.)
12:44:27 <tmhedberg> Haskell for instance doesn't really have assignment in the same way that other languages do
12:44:28 <kwstas> quchen: thank you too for your answer
12:44:33 <Cale> yeah
12:44:33 <hpc> so much as "State doBlahAndReturnState(State)"
12:44:39 <quchen> "Assignment" is arguably a bad name for writing "x = …", it's better called a definition or binding.
12:45:03 <Cale> The style of programming in FP is pretty different from what you'd do in Haskell for the most part, but it does have some commonalities
12:45:04 <quchen> (In Haskell, that is.)
12:45:16 <Cale> (Backus' FP, I mean!)
12:45:39 <quchen> Cale: Was about to ask what FP is if it's not Haskell :-)
12:45:50 <[1]grant> jailRancher: Also, a neat thing about Purely Functional Languages is that in a language with uncontrolled side effects, I could slip a line like "if random() < .00001 return null" into a function and it would probably pass all of the unit tests, but it could still do naughty things in practice
12:45:57 <Cale> quchen: It's an actual language named "FP"
12:46:15 <[1]grant> jailRancher: In a purely functional language, you wouldn't be able to slip in that call to random() without making it well known
12:47:02 <monochrom> solrize: http://lpaste.net/100588
12:47:24 <solrize> monochrom, wow, thanks!
12:47:28 <jle`> Twey: wait aren't you the pipes guy :|
12:47:48 <quchen> jle`: Tekmo is
12:47:48 <Twey> jle`: Nope
12:48:00 <jle`> oh wait
12:48:04 <jle`> darnit, pressed tabbed too soon
12:48:07 <jle`> sorry ><
12:48:50 <jle`> i will re-ask
12:49:04 <jle`> he's not online now though
12:49:37 <quchen> Tekmo might be a little hard to reach right now, he just started his new job at Twitter. He told the list he'll be answering questions though, but I'm not sure what kind of communication he had in mind.
12:49:57 <jle`> ah. well hopefully he is around some time for me to convey my congratulations
12:50:23 <ocharles> jle`: do you have a pipes question?
12:50:48 <jle`> ocharles: yeah, but i think i have worked it out kinda already over the past few days
12:50:53 <ocharles> ah, ok
12:51:00 <jle`> i'm writing a huffman compressor for like a teaching/demonstration project
12:51:10 <jle`> and part of it involves manipulating bit streams
12:51:11 <silasm_> it seems like the only local FP jobs are in social networking. Pretty much the opposite of my current job, where I like what the company's doing but I hate the tools I need to work with there. Not crazy about supporting social networks :/
12:51:20 <jle`> and i was wondering if pipes was a good solution for that
12:51:21 <guymann> h
12:51:34 <silasm_> or at least not fb/twitter. I like privacy; they don't.
12:51:38 <jle`> because Data.Binary only has that lazy IO
12:51:44 <jle`> which from what i've heard isn't something to be relied on
12:52:30 <[1]grant> I am going to work at Amazon in June.... 99% Java... sigh
12:52:35 <jle`> from what I'm thinking...i use pipes-binary and then make a pipe that takes a bytestring received and turns it into maybe a 8-long vector of Bits and passes that on?
12:52:38 <solrize> lazy io works ok if you use it in constrained ways and don't care about closing files at precise times
12:52:40 <nadirs> silasm_: they like too. Well, at least they like *your* privacy
12:52:51 <hpc> [1]grant: 1% xml? ;)
12:53:05 <[1]grant> hpc: 1% various glue scripts
12:53:23 <pjdelport> hpc: isn't Java already 10% XML? :)
12:53:23 <nadirs> [1]grant: are you really sigh-ing for working at Amazon?
12:53:39 <[1]grant> nadirs: sighing for Java, not Amazon :P
12:53:42 <monochrom> not as much as 10% :)
12:53:58 <jle`> solrize: really? is that the extent of the justification for its shaky reputation
12:54:34 <silasm_> nadirs: not from what I heard. e.g., from people that worked at facebook -- all communication is done through fb itself, and there's no separate work vs. normal life account. No work-life separation in that sense bothers me.
12:54:35 <solrize> well if you want to write a server that opens another file on every request, you can run out of fd's if they don't get closed when you've processed the data
12:54:59 <quchen> solrize: The problem is more that when you don't care about closing something at the right time, it might be closed before you finished reading it.
12:55:07 <pjdelport> jle`: There's more to it; that's one problem.
12:55:17 <quchen> solrize: Here's a quiz for shits n giggles. https://github.com/quchen/articles/blob/master/crazy_io.md
12:55:23 <nadirs> silasm_: that sounds terrible. Anwyay, mine was a joke, although probably not a too good one :)
12:55:31 <jle`> speaking of the list
12:55:35 <jle`> how do mailing lists work?
12:55:38 <dolio> No, it's not closed before you finish reading it.
12:55:43 <jle`> do you just subscribe and get an email for all of the posts that day or something
12:55:43 <dolio> Unless you do it yourself.
12:55:49 <jle`> and you can reply to any one yourslef and everyone read s it?
12:56:05 <monochrom> I know for sure that [1]grant is sign-ing for working at Amazon. just not sure about sigh-ing. :)
12:56:14 <nadirs> jle`: there's also a digest mode, usually
12:57:09 <solrize> quchen, interesting.  the first two examples don't count as "constrained" but the last two superficially look ok unless the file is changing or something like that
12:57:25 <[1]grant> monochrom: signed past tense ;P Soul is sold.
12:58:06 <nadirs> [1]grant: congrats, by the way. Hopefully you'll manage to get haskell/FP projects too
12:58:22 <nadirs> s/get/work on/
12:58:36 <quchen> There's not that much room for Haskell in 99% Java.
12:58:41 <[1]grant> nadirs: Amazon is a Java shop through and through, unfortunately. If you go really low level you might get C.
12:59:08 <nadirs> but wasn't Yegge blogging about CLisp all the time, in the past?
12:59:37 <nadirs> (and he worked at Amazon *with* CommonLisp at that time)
13:01:56 <[1]grant> On non-windows platforms does withSocketsDo just get optimized out or what?
13:02:28 <geekosaur> yes
13:02:46 <geekosaur> although you only run it once so it doesn't matter much even if it didn't
13:02:57 <quchen> I think it's simply defined as "withSocketsDo = id" via CPP
13:03:00 <geekosaur> but pretty sure it's id on unix
13:04:03 <monochrom> @unmtl State Int Bool
13:04:03 <lambdabot> Int -> (Bool, Int)
13:08:57 <mm_freak> i'm off of all channels for a while…  for questions regarding wires/netwire i'm still available via /query =)
13:09:09 <mm_freak> be sure to try mm_freak and mm_freak_, as my connection drops every 24h
13:09:15 <mm_freak> bye people =)
13:56:28 <jle`> arguably
13:56:33 <jle`> oh sorry wrong window
13:58:54 <idnar> if I have a function a -> Maybe b, and a value of type Maybe a, how do I get a value of type Maybe b?
13:59:08 <idnar> I tried f <$> x but that gives me Maybe (Maybe b)
13:59:12 <jle`> (>>=)
13:59:15 <jle`> :t (>>=)
13:59:16 <lambdabot> Monad m => m a -> (a -> m b) -> m b
13:59:20 <jle`> alternatively you can fmap and join
13:59:31 <jle`> :t join
13:59:32 <lambdabot> Monad m => m (m a) -> m a
14:00:13 <idnar> jle`: that gives me a type error
14:01:53 <idnar> oh
14:01:56 * idnar facepalms
14:02:01 <idnar> I had my arguments swapped around
14:02:28 <idnar> jle`: thanks, I guess that should have been obvious in retrospect, but I was too hung up on applicative syntax
14:10:51 * hackagebot SVGFonts 1.4.0.2 - Fonts from the SVG-Font format  http://hackage.haskell.org/package/SVGFonts-1.4.0.2 (BrentYorgey)
14:19:45 <samba1> Can anyone help me understand unsafePerformIO? I don't want to use it, really, just play with it while playing with other things. Can I use it to print to the console at arbitrary times?
14:19:54 <samba1> ex.
14:20:00 <samba1> f = do
14:20:03 <samba1>   return $ unsafePerformIO $ putStrLn "hi"
14:20:06 <samba1>   Just 123
14:20:10 <samba1> I'm confused why this doesn't either print "hi" or fail because the return is of type Maybe () and the last line is of type Maybe Int
14:20:26 <shachaf> (return . unsafePerformIO) is roughly unsafeInterleaveIO
14:20:38 <milfjord> except this return is Just
14:20:46 <shachaf> Er, right.
14:21:19 <shachaf> OK, then it's just your typical laziness thing.
14:21:36 <shachaf> You have a value (unsafePerformIO $ putStrLn "hi") with type ()
14:21:50 <shachaf> If you force it, "hi" will be printed. But you're not forcing it.
14:22:18 <samba1> and how does one force it? i'm kind of new
14:22:38 <shachaf> Are you sure you should be using unsafePerformIO? :-)
14:23:03 <samba1> like i said, i don't want to use it except to play while i learn
14:23:10 <pantsman> return $! unsafePerformIO $ putStrLn "hi"
14:23:10 <haasn> I think it's probably best to forget about unsafePerformIO altogether until you're more familiar with the rest of Haskell
14:23:19 <shachaf> Look into seq and pseq and ($!) and so on.
14:23:38 <enthropy> plain old pattern matching does it too
14:23:49 <shachaf> That works too in this case.
14:23:59 <shachaf> But I think I agree with haasn.
14:24:07 <samba1> when i do that, i get an error for the types, like i thought
14:24:29 <haasn> do () <- return $ unsafePerformIO $ putStrLn "hi"; Just 123 -- would do the trick
14:24:45 <samba1> i'm familiar with seq from simon's book, which i'm a little in to
14:25:40 <shachaf> unsafePerformIO is bizarre and confusing and you'd be better off learning some less-confusing prerequisites, such as strictness
14:25:56 <haasn> and IO
14:26:11 <samba1> well, i think i understand strictness, just not in haskell
14:26:38 <haasn> what about nonstrictness?
14:26:38 <samba1> io i sort of understand.... i mean, i get things that work with it, at least
14:27:05 <shachaf> I had a strict teacher once but I don't think that helped me learn Haskell.
14:27:17 <samba1> sometimes i get it to only happen in one go at the end, but, it works
14:27:35 <haasn> (I think the absolute best way to gain intuition about nonstrictness and lazy evaluation is by writing your own lazy evaluator)
14:28:14 <haasn> and a great way to gain intuition about Haskell's semantics and GHC's implementation of it is by writing your own implementation of the STG
14:28:59 <roboguy_> haasn: not a bad idea. I haven't done that yet
14:33:40 <samba1> i've done something similar in ml during school. haskell is strange though
14:36:46 <monochrom> Debug.Trace uses unsafePerformIO internally.
14:37:33 <samba1> yes, my next step was to look at debug.trace source in actually
14:37:56 <samba1> because of that
14:39:36 <milfjord> @src trace
14:39:36 <lambdabot> trace string expr = unsafePerformIO $ do
14:39:36 <lambdabot>     hPutStrLn stderr string
14:39:36 <lambdabot>     return expr
14:40:51 <pjdelport> idnar: (=<<) is the canonical bind, if you lean toward applicative style. :)
14:41:12 <idnar> pjdelport: yeah, I ended up using that version
14:45:55 * hackagebot electrum-mnemonic 0.1.0 - easy to remember mnemonic for a high-entropy value  http://hackage.haskell.org/package/electrum-mnemonic-0.1.0 (JoeyHess)
14:46:01 <klrr_> cool snap got a book too now :)
14:59:22 <lispy> klrr_: oh yeah?
14:59:28 <lispy> klrr_: do you have a link?
15:01:00 <klrr_> lispy: yeah, here http://snapforbeginners.com/
15:01:39 <klrr_> only played with yesod yet but im not sure how i feel about all TH-fu
15:04:50 <ephess> I'm working through learn you a haskell at the moment, but could use a bit more practice.. I was wondering if anyone knows of any good exercises with solutions or anything that I could work through once I'm finished with LYAH?
15:05:09 <hpc> ephess: pick a thing you want a program for and write something that does it
15:06:21 <merijn> @where exercises
15:06:21 <lambdabot> http://www.haskell.org/haskellwiki/H-99:_Ninety-Nine_Haskell_Problems http://www.reddit.com/r/dailyprogrammer/ http://www.reddit.com/r/programmingchallenges/
15:06:26 <merijn> ephess: See above
15:06:32 <klrr_> ephess: http://en.wikibooks.org/wiki/Write_Yourself_a_Scheme_in_48_Hours
15:06:50 <klrr_> it goes thorugh writing a complete program
15:07:03 <klrr_> shows monads in practice for example
15:07:51 <ephess> Thanks a lot, that looks ideal
15:08:34 <ephess> hpc: I was hoping to practice the basics a bit more before trying to write something a bit bigger, I'm still pretty fuzzy on syntax and recursion, etc.
15:09:14 <hpc> ephess: you don't have to write a whole program at once, start small and muddle through until it compiles
15:09:23 <hpc> then make it do something small that you want
15:09:28 <hpc> then add more
15:09:38 <hpc> for specific problems you can still ask here
15:10:44 <hpc> haskell is especially good for such deep-end learning because the compiler is quick to tell you what is wrong
15:11:15 <hpc> you catch mistakes much quicker
15:11:35 <ephess> alright, well maybe I'll try making something a little earlier than I normally would then
15:11:46 <haasn> hpc: provided you can understand what the compiler is trying to say
15:11:48 <klrr_> i would suggest going thourhg a cookbook like WYaSin48h at first
15:12:14 <klrr_> ^
15:12:37 <klrr_> indeed, i remember having trouble understanding what the type checker wanted when i started out
15:12:40 <hpc> haasn: well, part of it is learning what the compiler is saying; it always gives a line number and that is almost always accurate
15:12:43 <klrr_> (still do sometimes xD)
15:12:46 <hpc> even if you don't know what on the line is wrong
15:12:55 <biscarch> lispy klrr_ Let me know if you have any questions about the book
15:14:29 <hpc> ephess: in any event, going off the deep end can be fun :D
15:16:21 <ephess> hpc: haha, true. I've only written a handful of functions at this stage though so perhaps even WYaSin48h would be the deep end at this stage ;)
15:16:24 <klrr_> biscarch: there is not much information what sets snap apart from yesod and happstack, i found this http://stackoverflow.com/questions/5645168/comparing-haskells-snap-and-yesod-web-frameworks but mightybyte didnt say anytthing that could be biased since he was snap dev, it would be cool to hear from a snap user what the advantage is over yesod regardless if it's just a matter of personal opinion
15:16:45 <klrr_> not really a question related to the book sorry
15:18:35 <ephess> hpc: one of the first things I'm interested in building is a haskell implementation of a ruby CLI tool I wrote, I'm not relaly sure where to start at this stage though. Lots of side effects and http calls.. I don't know how to translate it to a functional program really
15:18:38 <Peaker> Parsec is supposed to have good error msgs, but once you set up some "try" blocks, and failure will lose the meaningful error only to give an error about the happened-to-be-last alternative :(
15:18:54 <Peaker> Parsec could have accumulated the errors of all alternatives that consumed some input
15:19:18 <hpc> ephess: start with something that gets CLI options and prints them
15:19:21 <klrr_> ephess: can you link to that tool?
15:19:24 <hpc> then implement options one at a time
15:19:49 <ephess> klrr_: https://github.com/eroad/super-stacker
15:20:02 <Peaker> I have something like:  try bigParseA <|> bigParseB       and it *should* match bigParseA but has a silly error. I get an error about bigParseB :(
15:20:07 <biscarch> heh, that's fine. As for Yesod, what really threw me off is that I already know JavaScript and front-end development and the opinions of Yesod seem very inclined towards "We'd rather not write JavaScript"
15:20:20 <Peaker> The only solution seems to be to factor my parser inside-out so that I don't need "try" as much
15:20:26 <ephess> hpc: you're probably right, I imagine I'm just overcomplicating it.
15:20:44 <Peaker> biscarch: Haskellers don't like to write in untyped languages, usually
15:20:58 <hpc> Peaker: it depends on the language
15:21:20 <hpc> i like to (half-)joke that perl is the best functional language i know
15:21:25 <Peaker> Javascript is especially terrible, IMO
15:21:28 <hpc> and haskell being the best imperative language
15:21:38 <biscarch> klrr_ The was a lot of template haskell type stuff in Yesod and it threw me off. I also couldn't really see a team that didn't know haskell working on Julius (JS)/Lucius/Cassius code when Less/SCSS are already out there
15:21:44 <Peaker> I find Perl distasteful
15:21:51 <klrr_> ephess: if you've just started out then this is a bit overkill to learn, but you may keep in mind the word "free monad" since it may come in handy if you gonna write a DSL
15:22:04 <klrr_> for later on
15:22:16 <biscarch> Peaker yes, I find JavaScript unfortunate myself, but I find that writing straight JavaScript gives me the most flexibility on the front end
15:22:34 <hpc> there are weird parts, but there is a sane core of functionality
15:22:39 <hpc> even haskell has weird parts
15:22:50 <hpc> import Prelude hiding (Bool)
15:22:54 <hpc> and then try using True and False
15:23:00 <hpc> you might be surprised
15:23:04 <biscarch> klrr_ as for Snap, I was attracted to the slimmed down nature of the framework and Snaplets turned out to be a great design decision
15:23:58 <biscarch> klrr_ I can write html/JS as per usual with Angular/Backbone/framework-of-the-day, which means that anyone I hired for front-end work would be able to as well
15:24:03 <Peaker> hpc: I find the scalar/reference/hash/array division of the world weird and arbitrary. The comma and => thing being the same, lack of sugar for named parameters, the defaults (if you don't "use strict" enable all warnings, etc) to be laughably bad, the special cases ($a, $b, $c, iirc?), etc -- just a terrible lack of taste
15:24:15 <ephess> klrr_: okay, I'll take a look at that once I get through the monads chapter. I'm going to just drop the DSL and use yaml or something this time around.. unless it's particularly easy to implement a DSL in haskell, will have to wait and see I guess.
15:24:49 <Peaker> hpc: what's the surprise supposed to be, w.r.t hiding Bool?
15:24:58 <prinsen> In TH, is there any way of "lifting" a value into an Exp? Ie. I have a value of type DataType, and want to generate a function in TH like fun = _thevalue_
15:25:21 <lispy> biscarch: development speed of ruby? :(
15:25:25 <biscarch> klrr_ I also like that Snaplets provide an impetus towards having things like connection pools separated
15:25:26 <hpc> Peaker: you can't use True and False as constructors
15:25:30 <lispy> biscarch: So I should prefer a different framework?
15:25:38 <Peaker> hpc: the designer[s] of Perl did not know what he[they] were doing, in my eyes (but indeed that's an opinion)
15:25:44 <hpc> they still are in scope, but their parent type doesn't
15:25:44 <gwz> hey how would you do something like this, http://lpaste.net/4021636062613864448
15:25:47 <Peaker> hpc: but that's because you hid the type name and not the constructor names
15:25:53 <gwz> where you want to both print something and return stuff
15:25:54 <Peaker> hpc: if you hide Bool(..) then you can
15:25:56 <biscarch> lispy heh, not the run-speed. Outside of Haskell I find that most people use Ruby and such for how fast they can develop
15:26:00 <hpc> yes
15:26:03 <hiptobecubic> Peaker, they knew were they were doing. They didn't know what they were *going* to be doing. That's the problem
15:26:09 <hiptobecubic> Perl is really good at what they *were* doing
15:26:10 <roboguy_> hpc: wait, you *can't* use True and False as constructors?
15:26:13 <hpc> it still leads to weirdness if you actually use it
15:26:14 <lispy> biscarch: huh. I wouldn't have guess that as a selling point of ruby.
15:26:24 <hpc> it's not immediately visible wtf is happening
15:26:30 <hpc> see acme-php for an evil application
15:26:30 <biscarch> lispy it's certainly not the performance ;)
15:26:35 <klrr_> biscarch: sounds interesting, i started writing a web app in yesod and im new to web dev and everything just felt a bit overcomplicated, i think i gonna buy your book when this months end (when i have some pocket money)
15:26:57 <haasn> hiptobecubic: which is not the language designers fault but the fault of the programmers who use it, no?
15:27:03 <hpc> Peaker: another part that is quite delicate is the parsing of block and line comments
15:27:04 <Luke__> klrr_: i felt the same way about yesod. i fell in love with snap for the same reasons biscarch mentioned
15:27:13 <Peaker> gwz: printing is an effect, what you can do is return a description of that effect AND an int. or a description of that effect, and modify that effect to also return an int
15:27:30 <Peaker> hiptobecubic: what were they doing?
15:27:33 <klrr_> ephess: you can learn this later in your haskell carrier, while you implement your program you may even encounter some DSL's on the way :)
15:27:34 <Luke__> biscarch: the samples of your book look great btw
15:27:49 <biscarch> Luke__ thanks :)
15:28:20 <gwz> Peaker: the description is just there for info purpose, It will have no impact on anything else
15:29:07 <cschneid> if I install GHC from source, how do I bootstrap an install of cabal too?
15:29:20 <cschneid> ie, I don't have cabal at all - but I do have a working ghc/ghci/etc
15:29:20 <klrr_> Luke: you are not by chance luke who hosted LAS some time ago?
15:29:23 <Peaker> gwz: if it's for debugging, and you don't want it to be considered an actual visible effect of your program, you can use Debug.Trace -- but you should know that is evil, because if your function type declares itself pure, and I call you, and you print to my screen, you've violated a sacred agreement
15:29:40 <Luke> klrr_: probably not. what's LAS?
15:29:52 <klrr_> a Linux podcast
15:29:55 <Luke> oh no not me
15:30:01 <klrr_> okey
15:30:02 <Platz> so, after reading about Operational, it seems like you can implement almost any monad using Operational.  I guess I'd end up with a lots of internal DSL's.  Is this a good general technique or is it more "niche"?
15:30:12 <gwz> what package is Debug.trace defined in
15:30:24 <roboguy_> gwz: base
15:30:28 <Peaker> gwz: base, iirc.  import Debug.Trace (trace)
15:30:34 <geekosaur> case matters
15:34:25 <lispy> cschneid: the cabal repo has a bootstrap.sh that you run
15:34:52 <lispy> cschneid: ghc comes with Cabal (the library part) and what you need to install is cabal-install (the program you know as cabal)
15:35:24 <Peaker> I'm starting to realize that Parsec does not compose :(  at least if you want good error messages
15:36:48 <lispy> Parsec can also fail to compose well due to `try`
15:36:58 <lispy> (or a missing try, might be a better way to sayt hat)
15:38:50 <Peaker> lispy: my problem is that Parsec requires a "try" too far up, and then it loses too much error information when it back-tracks
15:39:04 <Peaker> now trying to refactor my parser to localize "try" for better error messages
15:39:44 <Peaker> currently it can parse something up to some minor error, get a good error msg at that location, but throw it all away to backtrack to some old "try" and try a totally unrelated parser next, and return its useless error instead
15:40:01 <Peaker> refactoring the parser to minimize "try" is breaking composition
15:40:51 <Peaker> though Parsec could remember errors from previous tried alternatives, and heuristically choose the "best" error from all attempts
15:45:12 <lispy> You should try a different parser. I prefer happy but I think some of the other applicative/monadic combinator libraries support backtracking better than parsec does.
15:45:19 <lispy> And probably have equally good error reporting.
15:46:24 <c_wraith> I think Peaker rejected all non-parsec parsers earlier
15:46:38 <c_wraith> Oh, right, the rest of them don't have transformer variants
15:46:46 <Peaker> Yeah, I need textual include support
15:47:12 <Peaker> alex/happy might work, but I really dislike the whole approach of custom code-generation with ugly template syntax
15:47:23 <lispy> Unless the includes can modify the grammar you can shoehorn that into other systems
15:47:24 <Peaker> seems like going back to the bad old 80's
15:47:43 <Peaker> lispy: they can modify the grammar, afaik
15:47:48 <lispy> happy is a DSL and I thought we liked those in this community :)
15:47:56 <c_wraith> we like EDSLs
15:47:59 <lispy> you're parsing makefiles?
15:48:04 <Peaker> lispy: yeah
15:48:14 <lispy> Show me a make directive tha can modify the grammar
15:48:24 <lispy> I don't think it exists (but I could be wrong)
15:48:49 <Peaker> lispy: variable expansion determines grammar, I think
15:48:54 <Peaker> lispy: and variables can be set by include files
15:49:29 <Peaker> lispy: also, an include file can define a new target, and following lines thus belong to that target
15:49:32 <merijn> Also, don't forget the horror that is recursive make calls :)
15:49:48 <merijn> Peaker: I've got a good stress test for your Makefile compatibility ;)
15:50:13 <lispy> variable expansion might happen at an awkward time (like during parsing), but I think that's different than modifying the productions of the language.
15:50:25 <Peaker> merijn: Fortunately, I don't need to deal with that :)   I am actually designing a replacement for "make" which will be much better.. I only want superficial Make compatibility, not complete compatibility.  I could restrict "include" not to change grammar, but I don't want to admit defeat to the weakness of Haskell parsers :)
15:50:50 <Peaker> lispy: ${FOO}  could expand to a whole grammar element, I think, via raw textual substitution
15:50:55 <merijn> Peaker: Behold, the beautiful wonder created during my master project: https://github.com/merijn/snet-rts/blob/master/src/snet.mkf
15:51:34 <Peaker> merijn: aaaahhh, the horror
15:51:37 <geekosaur> basic unix make is parseable, gnu make and bsd make both have the ability to modify things based on include files
15:51:37 <lispy> Peaker: that means you need to expand ${FOO} and lex/parse it, not that the language of make has changed
15:52:03 <Peaker> lispy: but FOO's value is determined by the included makefiles
15:52:08 <Peaker> lispy: and in theory, conditionals/etc
15:52:13 <lispy> yes
15:52:25 <lispy> the interpolation/expansion has to happen during parsing
15:52:28 <hpc> and it needs you need to lex and parse "${FOO}" out of the body too
15:52:51 <Peaker> anyway, I managed to hack around Parsec to make it work (not easily at all!)
15:53:05 <geekosaur> you can for example define functions in both, and you can use those in if expressions that control what rules you define
15:53:10 <Peaker> and now my problem is bad error messages, but I think I just managed to narrow down my "try" clauses enough to get better errors, too
15:59:51 <levi> Man, refactoring this program to use EitherT and Lens stuff more comprehensively has simplified it a great deal.
16:00:00 <Peaker> yay :)
16:01:42 <bernalex> Twey: have you worked anything with gtk?
16:02:15 <levi> I have a normal monad that handles state changes and accumulating output events, but I wrap it in EitherT while handling user commands to ensure the preconditions for them are all met.
16:02:35 <bernalex> anyway, maybe someone else has too, so: http://lpaste.net/8874075334652198912 -- any ideas how I can make opna read a new file?
16:02:40 <Nolrai66> So can I restrict an instance based on the superclass' associated types?
16:02:55 <merijn> levi: And never having to worry you forgot to update some code somewhere, yay types!
16:02:56 <levi> And then the actual state changes use Lens operations to get at nested data structures.
16:03:17 <letrec> Is there a faster way to write the function disp in http://lpaste.net/100592 ?
16:03:17 <bernalex> right now I do txt <- getText. I need to do something... dramatically different. I want no file to run at first, and then whenever someone does opna, load the new file.
16:03:22 <merijn> Nolrai66: Serious question or just curiosity where ghetto answers will suffice? :p
16:03:39 <Nolrai66> semi-serious?
16:03:54 <merijn> Nolrai66: You could ghetto hack something abusing this: https://gist.github.com/merijn/6130082
16:04:03 <merijn> 7.8 and later only
16:04:23 <merijn> Nolrai66: Then just put a Restrict constraint on your typeclass instance
16:04:31 <Twey> bernalex: Not in a long time
16:04:48 <levi> merijn: Yeah, refactoring with nice types and hdevtools hooked up to flycheck is so easy!
16:04:55 <merijn> Nolrai66: Might result in hairy type errors, though!
16:05:12 <bernalex> Twey: right. trying to figure out how to do something that would be super simple in... not haskell for me. :-P i.e. have a file that I can "change" by reading in a new file
16:05:15 <Nolrai66> Shouldn't ("Error!" ~ "Tried to apply a restricted type!") typecheck?
16:05:41 <merijn> Nolrai66: No, those are *types* (of kind Symbol, it's in DataKinds)
16:05:55 <merijn> Nolrai66: And since both strings (i.e. types) are different, they will never unify
16:06:02 <Nolrai66> Oh! Sweet!
16:06:08 <merijn> Nolrai66: It'd be the same as adding a "Int ~ Bool" constraint
16:06:24 <merijn> Nolrai66: Except, this prints both types upon error, making the type error somewhat less confusing
16:07:16 <Nolrai66> So how would I actually use this? Restict seems to be doing something with a list of types..but I cant tell what.
16:07:43 <Peaker> I haven't used Python in quite a while, and now accidentally named my new Haskell module EnumTargets.py, heh
16:07:45 <merijn> Nolrai66: It's abusing 7.8's closed type families and just doing "elem" on a list of types
16:08:02 <merijn> Nolrai66: Restrict has kind "* -> [*] -> Constraint"
16:08:29 <merijn> Nolrai66: If the first type is in the list, it produces the (always false) ("Error!" ~ "Tried to apply a restricted type!") constraint
16:08:48 <merijn> Nolrai66: If the first type is *not* in the list, it produces the empty () constraint (which always holds)
16:09:30 <levi> letrec: What's it supposed to be doing?
16:09:37 <merijn> Nolrai66: Take the example "foo :: Restrict a [Char, Bool] => a -> a", it's "a -> a" that can be applied to anything *except* Char and Bool
16:09:44 <merijn> So "foo 'c'" is a type error
16:09:51 <haasn> Nolrai66: interesting usage of (~) to produce an invalid constraint there
16:09:55 <haasn> merijn*
16:10:04 <haasn> with an error message, too
16:10:07 <merijn> It acts a bit wonky in the presence of polymorphic values
16:10:27 <merijn> i.e. "foo 1" will error, because it can't infer that "Num a => a" is NOT Char or Bool
16:10:33 <merijn> But "foo (1 :: Int)" works
16:10:50 <merijn> (Well, not in my example, because the paste disallows Int, but you get the idea)
16:11:14 <c_wraith> So, what gets to take advantage of closed type families, anyway?
16:11:25 <merijn> c_wraith: Line 6
16:11:35 <merijn> c_wraith: Uses implicit equality of the two a's
16:11:52 <merijn> c_wraith: Which relies on line 6 being matched before 7 and 8
16:12:01 <merijn> And open type families have no ordering
16:12:48 <c_wraith> Ah, so the patterns are checked in order.
16:12:51 <Nolrai66> merijn: Hmm. err, I think that is more then I need. I have: "class A a b with data F a b :: *..." and I want to do something like "class (A a b, F a b ~ a) => X a b where .."
16:13:03 <merijn> c_wraith: Yeah, with open type families 6 and 7 would overlap and things would break
16:14:33 <merijn> Nolrai66: Right, so you could write "class (Restrict a [Foo,Bar], A a b) => X a b where ..." and then you could never write instances "X Foo b" or "X Bar b", as the Restrict constraint will never hold if 'a' is Foo or Bar
16:16:11 <merijn> c_wraith: The thing with open type families is that there's no sensible way to define an "order" on patterns in multiple modules. The fact that closed families only allow a single comprehensive list of patterns eliminates that confusion
16:17:34 <c_wraith> merijn: so the only difference is that overlaps are allowed because the patterns are checked in order?
16:17:47 <merijn> c_wraith: Yeah
16:18:10 <merijn> c_wraith: Also, I'm not sure whether the reuse of type variables (like line 6) is allowed in open families
16:18:23 <Nolrai66> Actually you know what, I am going to make my "Sumable" class just take one type, instead of 2 with an associated type.
16:19:00 <Nolrai66> ...oh but you can add values with differnt prefixes..
16:19:02 <Nolrai66> hmm.
16:24:59 <enthropy> merijn: with a normal type family you can only write one of the equations on line 6 and 7, not both
16:25:50 <merijn> enthropy: Right, I already noted that a bit earlier :)
16:26:14 <merijn> Anyhoo, bed time!
16:26:44 <enthropy> "merijn | c_wraith: Also, I'm not sure whether the reuse of type variables (like line 6) is allowed in open families"
16:27:12 <enthropy> guess I missed a message you sent after that then
16:27:17 <Nolrai66> Okay why isnt 'a' in scope in "class (Sumable a a, HasOne a) => FromIntegral where"?
16:27:46 <enthropy> Nolrai66: you can write    instance (Sumable a a, HasOne a) => FromIntegral
16:28:06 <enthropy> (though maybe you need some type parameters to let you write FromIntegral
16:28:17 <Nolrai66> Yes I will.
16:28:20 <Nolrai66> Thanks!
16:29:47 <Nolrai66> Heh, it must work out whats in scope from the right side of the '=>'.
16:31:02 <monochrom> I think it wants you to write "class (Summable a a, HasOne a) => FromIntegral a where"
16:33:05 <Nolrai66> whats a good name for "f _ start Zero = start; f g z (Succ n) = f g (g start) n"
16:33:47 <hpc> fold
16:34:00 <Nolrai66> Well yes.
16:34:02 <Nolrai66> Hmm.
16:34:06 <monochrom> wait, I think your typo gets into the way in "f g z (Succ n) = f g (g start) n"
16:34:35 <Nolrai66> Oh yes it does. "z" /~ "start"
16:35:08 <monochrom> then it is like foldl for list
16:35:23 <lenstr> ох
16:36:59 <Axman6> Nolrai66: iterateN also makes sense
16:37:11 <Axman6> or applyN
16:37:15 <Axman6> perhaps
16:37:41 <Nolrai66> applyN was what I wrote before asking.
16:39:30 <Nolrai66> Do "f g start (Succ n) = f g (g start) n" and "f g start (Succ n) = g (f g start n)" differ at all? and if so is one better?
16:40:33 <Nolrai66> Hmm, is the second on more lazy? I think it is..
16:41:26 <Axman6> yeah
16:42:00 <Axman6> so if g is (1:) you'll get a lazy list of 1's
16:42:12 <Axman6> (assuming start is [], it'll work)
16:45:41 <Nolrai66> grr..I wish there was a fromNonNegIntegral.
16:46:36 <Nolrai66> Though I guess what I really need is type level Integers..so I could just not make Nat a FromIntegral..>.<
16:59:51 <Nolrai66> Okay why does "fromIntegral :: (a ~ Plus a a, Integral b) => b -> a; fromIntegral = foldZ neg (one +) zero" complain that it cant match "Plus a a" and "a"? Arn't I telling it that they do match?
17:36:44 <monochrom> I guess it is the "occurs-check", it is the same reason why "a ~ [a]" is rejected
17:39:02 <geekosaur> yeh, that type does look suspiciously infinite
17:53:45 <chirpsalot> Can the state monad be used to create a list of random numbers, or am I barking up the wrong tree? I know randoms exists, but I am trying to recreate it with the state monad so I can understand it better... Having a lot of troubles :(.
17:54:46 <quchen> chirpsalot: Yes, State can do that. The state type will be your RNG state.
17:55:31 <chirpsalot> quchen: like a stdGen? I'm so confused by all of these types o_o. Normally I have no problems, but the state stuff has just left me questioning my own existence.
17:56:07 <quchen> Your random number function has a type like  `g -> (Int, g)`, I assume.
17:56:29 <roboguy_> chirpsalot: State just carries around a state value
17:58:03 <chirpsalot> quchen: right.
17:58:06 <nisstyre> chirpsalot: in order to create any quality pseudorandom numbers you still need some kind of seed value to put in your PRNG
17:58:23 <nisstyre> that value must come from an IO based function
17:58:31 <hpc> that's easy, seed the PRNG with a value from a PRNG
17:58:44 <nisstyre> luckily it's easy to connect IO based code to pure functions
17:59:21 <roboguy_> nisstyre: that only really needs to be done once though, so it could be done outside of most of the rest of the code
17:59:27 <chirpsalot> nisstyre: yep! I do understand PRNGs like that... For now I am going to fix a seed, but it should be easy to get a random one with "randomIO", right?
17:59:29 <quchen> chirpsalot: So the State-based "get a random value" will look something like this: do { gen <- get; let (randomNumber, newGen) = getRandomNumber gen; put newGen; return randomNumber }
17:59:41 <nisstyre> yeah, it would just be getRandomSeed <$> genRandomNumbers
17:59:53 <nisstyre> er, genRandomNumbers <$> getRandomSeed
18:00:03 <nisstyre> or whatever you name your functions
18:00:04 <quchen> Where getRandomNumber is the function from above, i.e. one that turns a generator into a new generator plus a random number.
18:00:43 <nisstyre> chirpsalot: yes, something like that
18:00:51 <nisstyre> it's been a while since I did anything with random numbers
18:01:11 <haasn> :t state random
18:01:12 <lambdabot> (MonadState s m, RandomGen s, Random a) => m a
18:01:21 * hackagebot prednote 0.22.0.0 - Build and evaluate trees of predicates  http://hackage.haskell.org/package/prednote-0.22.0.0 (OmariNorman)
18:01:44 <quchen> haasn: That's what my function refactors to, but I felt like something more explicit might be in order :-)
18:01:57 <haasn> I was mainly curious in seeing whether those two actually lined up
18:02:00 <haasn> I thought I remembered they didn't
18:02:03 <chirpsalot> Man trying to get anything to work with the state function in ghci is a nightmare. It seems to want explicit types all the time and it confuses me.
18:02:25 <chirpsalot> I'm probably doing things really wrong :P.
18:02:30 <quchen> haasn: Rule of thumb for State: "It's the other way round".
18:02:35 <quchen> Make sure to apply only once.
18:02:44 <quchen> State s a = s -> (a, s) ;-)
18:02:53 <haasn> I would really like s -> (s, a) for both
18:02:59 <geekosaur> also turning off the monomorphism restriction can save you some trouble when playing in ghci, if you haven't already
18:03:05 <haasn> (,) s makes a nice Functor (and even Applicative)
18:03:28 <chirpsalot> geekosaur: I haven't... I feel like that's part of why I'm running into so many issues with this.
18:03:39 <nisstyre> chirpsalot: make this your .ghci file https://gist.github.com/9300784
18:03:48 <geekosaur> ghci will happily infer ()s all over the place
18:03:50 <nisstyre> you can remove the other extensions if you want
18:03:51 <quchen> haasn: Ignore the first component?
18:04:03 <haasn> ((and even Monad))
18:04:24 <haasn> quchen: what do you mean?
18:04:35 <chirpsalot> One day I am going to understand why the state monad changed and I will get it and be happy about the change, but for now I hate it so much because it hurts my wee brain :P.
18:04:48 <quchen> haasn: What's the Applicative for (,) s? I haven't heard of that.
18:04:50 <roboguy_> chirpsalot: why the state monad changed?
18:04:54 <geekosaur> you mean state vs. State?
18:05:00 <chirpsalot> geekosaur: yes.
18:05:07 <chirpsalot> roboguy_: ---^ that
18:05:07 <geekosaur> you will need a while to understand, yes
18:05:11 <hpc> quchen: the left side needs to be Monoid
18:05:12 <hpc> for pure
18:05:17 <geekosaur> I think you're a bit far from monad transformers as yet :)
18:05:23 <quchen> Yeah, that's why I'm asking.
18:05:25 <chirpsalot> geekosaur: yep!
18:06:17 <geekosaur> but the short version is, State and StateT were two different things, now they are one thing (same for the Reader and Writer versions and RWS)
18:06:57 <geekosaur> but really I think you not only have to grok monad transformers, you have to be a maintainer (since the main point is reduction of duplicated code)
18:06:59 <monochrom> there were two competing libraries of monad transformers. at the Vienna peace conference, they agreed to be unified, but a consequence is that one side had to give up a separate State.
18:09:14 <levi> Heh.
18:09:45 <enemy> the dreadful terror of excessive compulsive thinking that creates the illusionn
18:10:45 <BMeph> haasn: If State went your way, then return /= (,)
18:11:17 <dhrosa> hello, does anyone have any suggestions as to how to combine these two functions together? hlint is suggesting that I reduce duplication here, I see what it means, but not sure of an elegant way to do it
18:11:21 <dhrosa> oops
18:11:22 <dhrosa> heress a link: http://lpaste.net/100594
18:12:01 <roboguy_> dhrosa: if it were me, I'd make it a lens
18:13:36 <roboguy_> chirpsalot: have you tried writing the State monad instance yet?
18:13:53 <enthropy> dhrosa: you can make getReg/readIOReg and readRam arguments to another function
18:14:00 <chirpsalot> roboguy_: hmm?
18:14:22 <roboguy_> chirpsalot: have you tried implementing "instance Monad ((,) a) where ..." yet, to see how it works?
18:15:07 <chirpsalot> No.
18:15:16 <enthropy> dhrosa: something like http://lpaste.net/100594
18:15:32 * Eduard_Munteanu sort of wants open kinds other than * (and related) :(
18:15:32 <roboguy_> or, I mean newtype State a b = State (a -> (b, a))
18:16:19 <roboguy_> that should be newtype State s a = State (s -> (a, s))
18:16:34 <enthropy> Eduard_Munteanu: what do you do when you need a `asTypeOf` for the kind level?
18:17:04 <roboguy_> chirpsalot: anyway, that might be a good idea
18:17:27 <Eduard_Munteanu> enthropy: well, you wouldn't have inhabited types in other open kinds
18:17:30 <enthropy> (not really related to your complaint... except having more kinds leads to more diambiguation)
18:18:18 <Eduard_Munteanu> The issue is I want a DataKinds sort of kind that can be extended.
18:18:48 <c_wraith> extended how?
18:19:27 <dhrosa> enthropy: hmm, I see how that works, thanks!
18:19:45 <Eduard_Munteanu> c_wraith: declare more types that are part of it
18:19:49 <c_wraith> Now I'm curious if you can use a data family as a data kind.
18:20:13 <Eduard_Munteanu> c_wraith: you can't
18:20:24 <Eduard_Munteanu> Not even GADTs.
18:20:43 <c_wraith> data families are much like open GADTs, so...  yeah.
18:21:23 * hackagebot matchers 0.18.0.0 - Text matchers  http://hackage.haskell.org/package/matchers-0.18.0.0 (OmariNorman)
18:21:53 <c_wraith> Oh, that reminds me.  I never did check to see if you could use a GADT for a set of constructors in a data family.  I assume you can, but I haven't tested it.
18:22:26 <Eduard_Munteanu> I'm working on tagged paths and I was considering tagging paths with a phantom index: newtype Path r s = Path [r]
18:22:58 <Eduard_Munteanu> Then functions would ask for a constraint on said index.
18:23:29 <Eduard_Munteanu> Instead of using different newtype wrappers around Path, that is.
18:24:42 <Eduard_Munteanu> So the 's' could be a lifted list of capabilites, like Directory vs File, or Absolute vs Relative.
18:25:05 <Eduard_Munteanu> However it's a bit ugly having those defined as types in *.
18:25:38 <Eduard_Munteanu> But if I define them as a closed kind a-la DataKinds, then they can't be extended.
18:26:05 <Eduard_Munteanu> And I don't think I can make a type-level HList. :)
18:26:57 <Eduard_Munteanu> c_wraith: you mean whether constructors can be GADT-like in a data family? They can.
18:27:13 <c_wraith> Eduard_Munteanu: yeah, I just tested it.  Works perfectly.
18:27:41 <Eduard_Munteanu> c_wraith: also you can make newtype instances along with data instances
18:27:48 <c_wraith> yeah, I knew about newtype.
18:28:15 <c_wraith> Which is what made me assume a GADT would work.
18:28:47 <c_wraith> I even tested the error message when specifying an illegal type for the constructor to return.  It was actually clear.
18:30:20 <Eduard_Munteanu> With PolyKinds you can even make GADT instances spanning multiple kinds.
18:30:53 <Eduard_Munteanu> (not the instance itself)
18:30:53 <c_wraith> I couldn't figure out how to make a kinda-polymorphic data family, though.  Is that possible?
18:30:58 <c_wraith> *kind-polymorphic
18:31:35 <Eduard_Munteanu> c_wraith: data family Foo :: k -> *   ?
18:32:22 <Eduard_Munteanu> c_wraith: or like here...  http://hackage.haskell.org/package/base-4.6.0.1/docs/src/GHC-TypeLits.html#Sing
18:33:11 <c_wraith> Huh.  Yeah, like that.  Wonder what I did wrong.
18:33:16 <c_wraith> Now I have to try it again.
18:34:42 <c_wraith> Huh.  This time, exactly what I thought didn't work before... worked just fine.  I must have typoed something and not even seen it.
18:42:11 <mgomezch> I’ve seen references here and there to (attempts to develop?) PL/Haskell for PostgreSQL.  Does anybody have a link to any such implementation effort?
18:42:59 <c_wraith> mgomezch: there was just an article on /r/haskell about it
18:43:19 <mgomezch> wow, sweet timing then :) I’ll have a look
18:43:41 <c_wraith> mgomezch: it might be titled something about singleton types
18:44:12 <verement> http://www.reddit.com/r/haskell/comments/1yxffz/interpreting_haskell_inside_postgresql_with/
18:44:46 <mgomezch> verement, c_wraith: Awesome, thanks!
18:50:03 <k_89> hey, can someone help me out with this : http://lpaste.net/100596
18:52:19 <verement> :t (/)
18:52:20 <lambdabot> Fractional a => a -> a -> a
18:52:40 <jxv> :t div
18:52:41 <lambdabot> Integral a => a -> a -> a
18:52:51 <joelteon> wow, that blog post is amazing
18:52:59 <jxv> k_89, you must choose (/) or div
18:53:14 <jxv> (/) is not defined for typeclass Num
18:56:14 <jxv> k_89, http://codepad.org/DUON5Cee
19:01:19 <mwc> Are there any LaTeX packages designed for writing pseudocode in a more functional, recursive style as opposed to the iterative form of algorithm2e, algorithmicx, etc?
19:01:30 <adek> I started reading fpcomplete article about writing vector which uses types to prevent head [] errors. I got stuck here: http://lpaste.net/100598
19:02:40 <adek> How can I tell GHC that I want n to be any type which has kind Nat
19:03:36 <Enigmagic> (n::Nat)
19:03:49 <pavonia> mwc: You might want to have a look at lhs2TeX
19:04:19 <pavonia> mwc: It's not a package but a file pre-processor, though
19:04:37 <adek> Enigmagic: Nice, I thought that would solve my problem, but is not working, still the same error
19:04:47 <startling> adek, {-# Language KindSignatures #-}
19:04:55 <Enigmagic> adek: https://github.com/alphaHeavy/llvm-general-typed/blob/parameters/src/LLVM/General/Typed/Instructions/GetElementPtr.hs#L145
19:04:57 <startling> adek, then (n :: Nat)
19:05:01 <Iceland_jack> adek:
19:05:01 <Iceland_jack>     data Vector (a :: *) (m :: Nat) where ...
19:05:01 <Iceland_jack> or
19:05:04 <Iceland_jack>     data Vector :: * -> Nat -> * where ...
19:05:33 <ij> Are language pragmas a special cases of syntax that are hacked into compiler's soruce?
19:05:51 <startling> ij, huh?
19:06:11 <Iceland_jack> ij: Language pragmas are just like any other syntax, they're not taken care of by the preprocessor or anything like that: otherwise I don't understand your question
19:06:31 <startling> ij, they're in the Haskell Report: http://www.haskell.org/onlinereport/haskell2010/haskellch12.html#x19-18800012
19:08:55 <adek> startling: I did it and code still does not compile. I also added what Iceland_jack mentioned, but I assumed that it is inferred from the following lines...
19:09:12 <startling> is there an extension dangerous enough to allow "SomeClass a => SomeClass (Either a b)" and also "SomeClass b => SomeClass (Either a b)"?
19:09:25 <ij> I was wondering whether they're in the main compiler source all together.
19:09:37 <startling> ij, what?
19:09:42 <ij> never min
19:09:44 <ij> d
19:09:47 <startling> ij, ok.
19:10:16 <gwz> hey, if I have a regex such as "([A-Z])([0-9]+)", is there something can allow me to get the results in array or something with the proper grouping
19:12:04 <enthropy> startling: not directly. You could add an instance SomeClass t where method = somethingDummy, then  you can write   instance (SomeClass a, SomeClass b) => SomeClass (Either a b)
19:12:58 <roboguy_> gwz: it looks like matchRegexAll will do that
19:13:10 <enthropy> and if you can recognize a somethingDummy, you can get that instance to do something that might make sense
19:13:17 <adek> startling: I thought that UndecidableInstances already is dangerous enough
19:28:39 <c_wraith> adek: UndecidableInstances is perfectly safe by itself.
19:32:27 <anon9002> Can anyone recommend a non-bloated Haskell compiler/interpreter for GNU/Linux? GHC takes up too much space.
19:32:46 <ystael> @pl \f x y -> (f x) || (f y)
19:32:46 <lambdabot> flip =<< (((.) . (||)) .)
19:33:28 <ystael> @pl \f g x -> (f x) || (g x)
19:33:28 <lambdabot> liftM2 (||)
19:33:41 <pavonia> anon9002: hugs, but I guess that one it really outdated
19:51:33 * hackagebot options 1.0 - A powerful and easy-to-use command-line option parser.  http://hackage.haskell.org/package/options-1.0 (JohnMillikin)
19:51:57 <ryantrinkle> gwz: have you looked at the 'rex' package?
20:20:00 <joelteon> oh, options looks delightful
20:20:06 <joelteon> also it's easier to type than optparse-applicative
20:21:37 * hackagebot chell 0.3.3 - A simple and intuitive library for automated testing.  http://hackage.haskell.org/package/chell-0.3.3 (JohnMillikin)
20:21:53 <roboguy_> I wonder why it uses lowercase for type names and data constructors
20:26:23 <Tekmo> Yeah, it looks nice
20:26:27 <Tekmo> I can't wait for the haddocks to render
20:37:39 <haasn> I wonder what the difference between it and optparse-applicative is
20:37:43 <haasn> I'll need to have a better look tomorrow
20:43:30 <ystael> @pl \f g h x -> f (g x) (h x)
20:43:30 <lambdabot> liftM2
20:46:01 <randomclown> alternatively, f <$> g <*> h
20:50:51 <khyperia> Gah, I keep forgetting about the function monad.
20:50:57 <khyperia> It makes things so strange.
21:03:27 <carter> khyperia: the reader monad?
21:03:38 <khyperia> That too :P
21:11:36 <ystael> @pl \f g x y -> f (g x) (g y)
21:11:36 <lambdabot> join . ((flip . ((.) .)) .) . (.)
21:13:08 <khyperia> that's a fun pl
21:15:52 <Axman6> :t on
21:15:53 <lambdabot> (b -> b -> c) -> (a -> b) -> a -> a -> c
21:16:03 <Axman6> > on f g x y
21:16:05 <lambdabot>  Could not deduce (Debug.SimpleReflect.Expr.FromExpr b0)
21:16:06 <lambdabot>    arising from a use of `Debug.SimpleReflect.Vars.g'
21:16:06 <lambdabot>  from the context (Debug.SimpleReflect.Expr.FromExpr c)
21:16:06 <lambdabot>    bound by the inferred type of
21:16:06 <lambdabot>             it :: Debug.SimpleReflect.Expr.FromExpr c => c
21:16:15 <Axman6> > on f g x y :: Expr
21:16:16 <lambdabot>  No instance for (Debug.SimpleReflect.Expr.FromExpr b0)
21:16:16 <lambdabot>    arising from a use of `Debug.SimpleReflect.Vars.g'
21:16:16 <lambdabot>  The type variable `b0' is ambiguous
21:16:16 <lambdabot>  Possible fix: add a type signature that fixes these type variable(s)
21:16:16 <lambdabot>  Note: there are several potential instances:
21:16:41 <Axman6> hmm
21:16:58 <Axman6> > on (*) (+1) 4 5
21:16:59 <lambdabot>  30
21:17:13 <BMeph> > on (*) (+1) 4 5::Expr
21:17:14 <lambdabot>  (4 + 1) * (5 + 1)
21:17:19 <ij> Nice!
21:17:31 <ij> Is that lambdabot-thing?
21:18:49 <joelteon> nope
21:18:59 <joelteon> simple-reflect
21:19:06 <ij> I need to read up on that.
21:19:32 <Axman6> :t f
21:19:33 <lambdabot> FromExpr a => a
21:19:46 <Axman6> > 4 5 :: Expr
21:19:47 <lambdabot>  No instance for (GHC.Num.Num a0) arising from the literal `5'
21:19:47 <lambdabot>  The type variable `a0' is ambiguous
21:19:47 <lambdabot>  Possible fix: add a type signature that fixes these type variable(s)
21:19:47 <lambdabot>  Note: there are several potential instances:
21:19:47 <lambdabot>    instance GHC.Num.Num GHC.Types.Double
21:20:50 <ij> well this is just sweet
21:20:53 <ij> > foldr1 (+) [1,2,3,4,5,6] :: Expr
21:20:53 <lambdabot>  1 + (2 + (3 + (4 + (5 + 6))))
21:21:05 <ij> I think I've needed it before for debugging.
21:22:05 <joelteon> > foldl1 (+) [1,2,3,4,5,6]
21:22:07 <lambdabot>  21
21:22:13 <joelteon> > foldl1 (+) [1,2,3,4,5,6] :: Expr
21:22:14 <lambdabot>  1 + 2 + 3 + 4 + 5 + 6
21:22:21 <joelteon> wait, so is it foldl1 that's tail-call friendly?
21:22:27 <joelteon> damn it
21:22:31 <Axman6> no
21:22:52 <joelteon> which is it
21:23:02 <Axman6> wait, what do you mean?
21:23:05 <Axman6> @src foldl1
21:23:06 <lambdabot> foldl1 f (x:xs) = foldl f x xs
21:23:06 <lambdabot> foldl1 _ []     = undefined
21:23:28 <ij> foldl' was
21:23:30 <joelteon> will foldl1 op huge_list build a huge stack, or is it foldr1 that will do that?
21:23:35 <joelteon> or foldl1'
21:23:37 <ij> yup
21:23:37 <Axman6> foldl'
21:23:44 <Axman6> @src foldl1'
21:23:44 <lambdabot> Source not found. I am sorry.
21:23:47 <joelteon> "a or b?" "yes"
21:24:06 <Tekmo> joelteon: It depends on what you are using it for
21:24:06 <ij> joelteon, Sorry, the last one. Like Axman6 said.
21:24:10 <Axman6> foldl' will force each step in the computation to WHNF
21:24:17 <Axman6> @src foldl'
21:24:17 <lambdabot> foldl' f a []     = a
21:24:18 <lambdabot> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
21:25:36 <Tekmo> `foldl'` works best when reducing a list to a single value
21:25:49 <joelteon> so on that note, will 'length . filter f' take more memory than a usage of foldl1 would?
21:26:02 <Tekmo> `foldr` on the other hand preserves laziness
21:26:17 <Tekmo> joelteon: No
21:26:25 <joelteon> okay
21:26:41 <Tekmo> joelteon: `length . filter f` should run in constant space
21:27:16 <joelteon> okay that's one possible bug
21:27:44 <shachaf> genericLength won't run in constant (or even logarithmic or whatever) space. It's called "generic" but pretty much the only thing it's good for is lazy naturals.
21:28:06 <joelteon> but length will.
21:28:38 <Tekmo> shachaf: Why is that?  Is it written incorrectly?
21:28:53 <shachaf> It's written as a foldr.
21:29:13 <shachaf> I can't say whether it's correct or incorrect.
21:29:17 <Tekmo> shachaf: So in theory you can implement `foldl'` in terms of `foldr`, but I'll assume that you mean that it does not do so
21:30:28 <shachaf> It's written in the obvious way that you'd write it as a foldr.
21:30:30 <shachaf> @src genericLength
21:30:30 <lambdabot> genericLength []    = 0
21:30:30 <lambdabot> genericLength (_:l) = 1 + genericLength l
21:30:54 <Tekmo> Yeah, that's definitely the wrong way
21:30:59 <shachaf> That's the right way for lazy naturals.
21:31:12 <shachaf> It's not right for almost anything else. Caller beware.
21:32:22 <shachaf> Also, I think it's slightly misleading to say that you can write foldl (or foldl') as foldr. Given (f,z), there's no (f',z') such that foldr f' z' xs = foldl f z xs
21:32:40 <shachaf> (Well, not in general.)
21:34:48 <Tekmo> shachaf: foldl' f z0 xs = foldr f' id xs z0 where f' x k z = k $! f z x
21:34:50 <roboguy_> shachaf: really?
21:34:53 <Tekmo> shachaf: That's the general translation
21:34:54 <shachaf> It's true that you can do it with post-processing, but that's true of every list function.
21:35:06 <shachaf> Yes. You're applying it to an extra argument.
21:35:25 <roboguy_> does that invalidate it?
21:35:41 <Tekmo> shachaf: Thus the phrase "in terms of"
21:35:58 <shachaf> OK, but that's true of every function.
21:36:04 <shachaf> foldl f z = realFoldl f z . foldr (:) []
21:36:19 <roboguy_> I don't see post processing in the foldl in terms of foldr thing though
21:36:37 <Tekmo> shachaf: Now you're just being needlessly pedantic
21:37:00 <roboguy_> it seems like there is a real distinction that can be made here where foldl can be defined in terms of foldr, but not visa-versa
21:37:29 <shachaf> I was worried that I was being needlessly pedantic.
21:37:50 <shachaf> I think it's more that I don't quite understand what point is being made.
21:38:31 <shachaf> Maybe the point is that your foldl' doesn't use recursion itself. I suppose that's reasonable.
21:38:58 <Tekmo> There is an advantage to defining it in terms of `foldr`.  You can then take advantage of build/foldr fusion.  This is what my `foldl` package does to improve performance.
21:39:03 <copumpkin> shachaf: your foldl looks awesome
21:40:28 <shachaf> copumpkin: thanks
21:56:48 * hackagebot http-reverse-proxy 0.3.0.1 - Reverse proxy HTTP requests, either over raw sockets or with WAI  http://hackage.haskell.org/package/http-reverse-proxy-0.3.0.1 (MichaelSnoyman)
22:05:44 <redhands> web development in haskell?
22:06:34 <Axman6> yes?
22:06:49 * hackagebot yesod-bin 1.2.6.1 - The yesod helper executable.  http://hackage.haskell.org/package/yesod-bin-1.2.6.1 (MichaelSnoyman)
22:13:29 <speckle> hi, what's currently the best gui toolkit for haskell? if it's a binding to another language, I'm assuming the best is the one that is the most bug-free, since Haskell itself is pretty solid
22:14:34 <ij> What about the browser? You can make an interface with a browser too.
22:14:52 <speckle> ah, so you just use web frameworks for GUIs. gotcha
22:15:35 <pavonia> speckle: gtk2hs is the one covering the most GUI features/widgets, AFAIK
22:15:44 <Axman6> speckle: well, there are GUI libraries, but there's also some pretty sweet web based ones
22:16:08 <Axman6> speckle: http://www.haskell.org/haskellwiki/Threepenny-gui
22:16:12 <speckle> ah, the binding to GTK2? thanks!
22:16:34 <Axman6> redhands: did you have an actual question and not just a statement with a question mark on the end?
22:16:57 <pavonia> speckle: to Gtk3 even
22:17:28 <redhands> nope did not have a real question
22:21:50 <jle`> idnar: no problem.  for something more like what you wanted, (=<<) would do
22:22:05 <jle`> and (=<<) is more analogous to (<$>) than (>>=)
22:22:17 <jle`> (>>=) is kinda weird to be honest
22:22:46 <Axman6> makes sense to me, it's pointing to the continuation where the result(s) will be passed
22:22:53 <alevy> what terms would I use to describe the things on the left and right of a bind operator, respectively?
22:23:23 <jle`> idnar: you are reaching the fundamental difference between Applicative and Monad actually.  The reason why you can't do what you wanted to do with Applicative is because your `f` can choose, arbitrarily, to return either a Just or a Nothing
22:23:41 <gwz> hey , for pattern matching in function, can I do something like getSomeValueFromList ("R\d":tail) = etc
22:23:45 <gwz> where \d is an integer value
22:23:48 <alevy> like, if i wanna say that the thing on the left's result gets passed to the thing on the right?
22:24:04 <alevy> gwz: no
22:24:05 <jle`> idnar: this power --- to pass in functions that can determine the structure of the monad --- is something that is characteristically monadic (as opposed to applicative) and is what sets it apart, arguably
22:24:19 <alevy> gwz: you mean, you want to match **any** integer?
22:24:22 <gwz> yes
22:24:35 <alevy> gwz: no, only string literals, no regular expressions or anything like that
22:24:47 <alevy> you could do something like:
22:25:17 <Axman6> gwz: single digits?
22:25:26 <Axman6> :hoogle Char -> Int
22:25:33 <alevy> ("R":n:tail) | alphaNum n = ...
22:25:33 <Axman6> @hoogle Char -> Int
22:25:34 <lambdabot> Data.Char digitToInt :: Char -> Int
22:25:34 <lambdabot> Data.Char ord :: Char -> Int
22:25:34 <lambdabot> Graphics.UI.GLUT.Callbacks.Window Char :: Char -> Key
22:25:45 <Axman6> gwz: getSomeValueFromList ('R':n:tail) | '0' <= n && n <= '9' = let d = digitToInt n in ...
22:25:55 <alevy> yeah something like that
22:25:59 <alevy> might do the trick
22:26:06 <gwz> wont work for double I guess
22:26:23 <Axman6> it'll only work for single character numbers
22:26:24 <alevy> i mean... you can get abitrarily complex here, but it's probably not worth it at some point
22:26:28 <gwz> or arbitrary sized integers
22:26:33 <Clint> it sounds like you want a parser
22:26:36 <Axman6> indeed
22:26:37 <gwz> yuh
22:26:40 <gwz> thats exactly it
22:26:44 <Axman6> or at the very least a lexer
22:26:52 * hackagebot conduit-extra 0.1.6 - Experimental helper functions for conduit.  http://hackage.haskell.org/package/conduit-extra-0.1.6 (MichaelSnoyman)
22:27:08 <Axman6> @where ops
22:27:08 <lambdabot> arjanb bos byorgey Cale conal copumpkin dcoutts dibblego dmhouse dolio dons edwardk elliott geekosaur glguy Heffalump Igloo jmcarthur johnw kosmikus Lemmih monochrom nyc Philippa Pseudonym quicksilver roconnor Saizan shachaf shapr sjanssen ski sorear SyntaxPolice xerox
22:27:30 <Axman6> ops: want to do something about ssj4mo? joining and leaving every few seconds
22:27:42 --- mode: ChanServ set +o copumpkin
22:27:49 --- mode: copumpkin set +b ssj4mo!*@*$##fix_your_connection
22:27:55 --- mode: copumpkin set -o copumpkin
22:28:05 <Axman6> thanks =)
22:28:23 <Axman6> haven't seen you around for a while copumpkin
22:28:34 <copumpkin> I pop up every so often :)
22:31:52 * hackagebot yesod-auth 1.2.6 - Authentication for Yesod.  http://hackage.haskell.org/package/yesod-auth-1.2.6 (MichaelSnoyman)
22:41:17 <no-n> is there a way to save the input/output of a GHCi session?
22:42:55 <isaacd> no-n: copy/paste?
22:42:58 <isaacd> prompt history?
22:43:15 <isaacd> (my ghci remembers commands from past runs of ghci when I type the up arrow)
22:43:29 <no-n> script would work i suppose
22:43:35 <isaacd> yeah
22:43:47 <isaacd> there might be a more 'proper' way too but I don't know it
22:43:57 <no-n> *nod*
22:46:38 <isaacd> huh interesting, most ghci output goes to stdout but the prompt ("Prelude>") goes to the tty
22:46:54 * hackagebot mono-traversable 0.3.1 - Type classes for mapping, folding, and traversing monomorphic containers  http://hackage.haskell.org/package/mono-traversable-0.3.1 (MichaelSnoyman)
22:46:57 <isaacd> (deduced by redirecting stdout / stderr to /dev/null)
22:59:55 <gwz> hey, whats wrong with the last line here, http://lpaste.net/8031269014485336064
23:00:27 <copumpkin> why not tell us what the compiler says is wrong, and then we'll tel you
23:00:51 <copumpkin> I'd guess you forgot parentheses though
23:01:05 <gwz> Couldn't match expected type `Int' with actual type `Bool'
23:01:17 <copumpkin> digitToInt headVal > maxVal (digitToInt headVal) ?
23:01:23 <copumpkin> still seems like an odd thing to do
23:01:43 <copumpkin> (digitToInt headVal > maxVal)
23:02:25 <copumpkin> gwz: getNumberVal takes an Int as its second parameter and you're passing in a Bool
23:02:33 <copumpkin> you need to figure out what you intended to do
23:03:03 <gwz> i want it to check if the current headval is greater than our maxval and pass whatever is the result of the bool
23:03:33 <copumpkin> then write that :P
23:03:36 <copumpkin> what you wrote is a comparison
23:04:32 <copumpkin> (max headVal maxVal)  for example?
23:05:38 <copumpkin> I annotated it with something that looks a tad more idiomatic
23:05:57 <copumpkin> and either way is more efficient
23:06:14 <gwz> ok thank you
23:06:32 <copumpkin> err, there's a typo in mine but I'm sure you'll find it
23:06:48 <copumpkin> if not: http://lpaste.net/100600
23:28:29 <NiceOneBrah> Hi, suppose I want to create a type for a collection of 5 integers where order doesn't matter. I could use `type` to create a type synonym for a 5-tuple, but that doesn't really capture the fact that order is irrelevant. I could create a synonym for [Integer], but that doesn't enforce that there are exactly 5 elements. Does anyone know an idiomatic way to do this in Haskell?
23:32:13 <ivan_m> NiceOneBrah: you wrap it in a new data type, but don't expose the constructor and only allow accesss via your own types
23:32:19 <ivan_m> or, you could use a five-element array
23:33:54 <NiceOneBrah> ivan_m: right on. thanks!
23:35:02 <pavonia> There's also Data.Set if order doesn't matter
23:36:27 <NiceOneBrah> pavonia: yeah I was thinking about that as an option as well, but I was wondering about the case where you might have duplicate elements
23:37:45 <ivanm> use a multiset
23:37:55 <ivanm> but again, wrap it in your own type if you want to require exactly 5 integers
23:38:23 <NiceOneBrah> cool, I like that approach
23:38:34 <ivanm> @hackage multiset
23:38:34 <lambdabot> http://hackage.haskell.org/package/multiset
23:39:26 <kototama> hi, i'm new to haskell. where can i find some example on how to use this library https://hackage.haskell.org/package/wl-pprint-terminfo-3.7.1/docs/System-Console-Terminfo-PrettyPrint.html#g:7 ?
23:40:17 <ivanm> kototama: apparently hspec-expectations-pretty is the only package that uses that library: http://packdeps.haskellers.com/reverse/wl-pprint-terminfo
23:42:10 <kototama> even after reading three books on haskell i still find hard to decipher new libraries :-s
23:43:02 <ivanm> kototama: anything in particular you're confused with?
23:43:24 <ivanm> my guess is that the Float there is for the line length
23:43:42 <kototama> i don't see understand how the TermDoc abstraction is used
23:44:18 <kototama> there are this prettyterm and termdoc but i don't see how to combine them to display something, for instance a colored text
23:45:13 <ivanm> my guess is that you're meant to look at terminfo
23:45:22 <ivanm> this is a set of additional functions for use with terminfo
23:45:30 <ivanm> oh, and wl-pprint-extras
23:45:41 <ivanm> and in true edwardk style, minimal documentation :p
23:46:17 <kototama> is the developper known :) ?
23:46:35 <edwardk> i just use the ansi stuff that max bolingbroke wrote these days ;)
23:47:28 <edwardk> trifecta used to use it, but i switched when dependencies trifecta HAD were using the ansi pretty printing stuff he wrote. so i shipped him patches to make it do what i needed and switched
23:47:53 <edwardk> others still use wl-pprint-terminfo in a few places, but they are all applications, not libraries, so probably aren't on hackage
23:49:37 <kototama> edwardk: this one http://batterseapower.github.io/ansi-terminal/ ?
23:49:46 <kototama> i didn't found it on my first web search
23:50:46 <kototama> is there a prettyprinter that use it?
23:51:40 <kototama> ansi-wl-pprint, cool
23:57:25 <prooftechnique> Anyone know why the new haddock is dying on me? <no location info>: module ‘somePackage:Main’ is defined in multiple files:
