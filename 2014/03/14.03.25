00:00:04 <MP2E> I'm using "darcs get http://code.haskell.org/xmonad"
00:00:32 <MP2E> darcs failed:  Couldn't fetch `591d03fbff964ac9642593059570fa0e683fe6797cfa915d310936b032bf2858'
00:00:35 <MP2E> weird.
00:01:12 <MP2E> err ah the error is "hash failure"
00:03:56 <mariomystic> Does bold and emphasis markups described in http://www.haskell.org/haddock/doc/html/ch03s08.html#idp1371084652 work at all?
00:04:17 <mariomystic> I just get text displayed as it is.
00:05:02 <mariomystic> I also can't find a way to colourize part of my documentation in haddock.
00:08:19 * hackagebot simple-genetic-algorithm 0.1.0.2 - Simple parallel genetic algorithm implementation  http://hackage.haskell.org/package/simple-genetic-algorithm-0.1.0.2 (eax)
00:08:19 * hackagebot simple-genetic-algorithm 0.1.0.3 - Simple parallel genetic algorithm implementation  http://hackage.haskell.org/package/simple-genetic-algorithm-0.1.0.3 (eax)
00:15:32 <usrx> hi, since LYAH is often recommened as a beginner introduction here: did you notice many error in the text the author has written? I don't mean errors in the Haskell code examples but the errors in grammar. Just saying, my English is not perfect either, but I came across several text passages which I couldn't "parse"
00:16:05 <Welkin> there are a few
00:16:08 <Welkin> but they are rare
00:16:20 <Welkin> and they do not distract from the message
00:17:01 <Cale> usrx: Unfortunately, nobody's heard from the author since he released the book.
00:17:08 <kazagistar> I never noticed anything particularly jarring
00:17:16 <jle`> there are some errors
00:17:23 <jle`> well
00:17:31 <jle`> there are some out of date parts
00:17:32 <kazagistar> Cale: that is very interesting and mysterious, haha
00:17:39 <jle`> transformers/mtl have changed their API since LYAH
00:17:41 <Welkin> I find it is one of the best introductory programming books I have read
00:17:44 <jle`> so you can't use State as a constructor anymore
00:17:48 <jle`> you have to use state
00:18:03 <Welkin> it's also humorous
00:18:07 <Cale> His name is Miran Lipovača, it's possible that English also isn't his first language.
00:18:09 <jle`> oh you mean lexical errors
00:18:13 <Welkin> I like that it doesn't take itself too seriously
00:18:17 <jle`> oh
00:18:21 <jle`> you mean english grammar
00:18:21 <usrx> jle`: yep
00:18:23 <kazagistar> Also, complaining that "Learn You a Haskell for Great Good" has some strange english is kinda funny on its own
00:18:35 <jle`> isn't some of the non-grammar on purpose?
00:18:40 <jle`> i mean even the title is supposed to be weird
00:18:43 <Cale> Some of it certainly :)
00:18:59 <jle`> it sounds very borat-ey
00:19:04 <Welkin> he uses slang for comedic effect
00:19:31 <Welkin> many non-native English speakers have a hard time understanding slang
00:19:49 <jle`> and especially comedically mangled english grammar
00:19:50 <usrx> I mean, that's not a big deal. it's just as a non (or not?) native English speaker I have to read some senteces several times
00:20:07 <usrx> and then additionally several times to understand the concept of Haskell ;D
00:20:25 <usrx> Welkin: ^ ;)
00:20:28 <jle`> usrx: can you give an example?
00:20:45 <Welkin> the language is much easier than any comparable textbook you'll find
00:21:49 <jle`> i actually never really cared for Why's Poignant Guide, which was allegedly the inspiration for the style of lyah
00:22:09 <kazagistar> I think the language is casual, but that does not make it easy.
00:22:23 <usrx> jle`: not in particular, but this is the once I just came across "When I talk about concrete types I mean like fully applied types like Map Int String or if we're dealin' with one of THEM polymorphic functions, [a] or (Ord a) => Maybe a and stuff." I guess that should be "the"?
00:22:33 <Zolomon> Ooh! I found that book, Algebra of Programming, in my library at University!
00:22:53 <Welkin> yeah, that is southern American slang
00:22:55 <jle`> it's like...southern slang
00:23:05 <jle`> cowboy drawl
00:23:16 * hackagebot simple-genetic-algorithm 0.1.0.4 - Simple parallel genetic algorithm implementation  http://hackage.haskell.org/package/simple-genetic-algorithm-0.1.0.4 (eax)
00:23:18 <jle`> old west?
00:23:25 <jle`> im a cow boy yee haw
00:23:35 <usrx> lol
00:23:39 <jle`> i never thought i would say that on #haskell
00:23:40 <Welkin> the illustrations are incredible
00:24:09 <Welkin> the treasure chest with feet like a millipede to explain IO actions
00:24:54 <kazagistar> yeah, the pronunciation is more like "wun uh dem polmoific functordoodles"
00:25:18 <Welkin> I wish more books were willing to make fun of themselves instead of being so academic
00:25:52 <Welkin> I just personified books
00:25:55 <Welkin> I meant the authors
00:27:18 <ZettaBlade> http://s3.amazonaws.com/lyah/dognap.png
00:27:19 <kazagistar> Welkin: as a counterpoint, I had a really really horrible linear algebra textbook that was all full of irrelevant redneck jokes with math interspersed in a seemingly random manner
00:27:28 <ZettaBlade> Learn you a Haskell or the dog gets it!
00:28:10 <Welkin> that picture is great
00:28:27 <Welkin> kazagistar, yeah, it is an artform that requires balance
00:30:22 <kazagistar> but I can totally see how LYAHFGG could be pretty rough for non-native speakers, who might miss the tonality and whatnot
00:32:56 <kazagistar> I love how even the casual haskell textbook waits til chapter 9 to write "hello world" :D
00:34:02 <kazagistar> to be fair, most languages should wait at least that long, but they just brush stuff under the table to rush it out
00:36:59 <kazagistar> Q: "So why is that class Main thing there?"  A: "Well, see there is this thing called an object..." <hours later> "...and then the class initializer returns the Main class, and then call the hello world method. Does that explain it?"
00:39:15 <tikhon> kazagistar: to be fair, Haskell's main is also tricky to fully explain :P
00:39:29 <Cale> It's nice that in Haskell, you can actually do a significant amount of stuff without needing to know how to do I/O
00:39:39 <kazagistar> tikhon: well, thats why they are honest about it and put it in chapter 9 after monads and whatnot :P
00:39:49 * Ralith wrote an entire IRC bot without understanding monads once
00:39:53 <tikhon> yeah, a REPL is basically a prerequisite for a teaching language, as far as I'm concerned
00:39:54 <Cale> You can totally get by for a long time just hacking around in ghci
00:40:01 <jle`> what is monad
00:40:04 <tikhon> even a shifty one like GHCi
00:40:16 <jle`> is it that jquery-like thing...?
00:40:37 <tikhon> I tried teaching Java to a bunch of high schoolers once, and there was far more hand-waving than even in teaching Haskell without explaining monads
00:40:55 <tikhon> the sentence structure there was a kind of forced :/
00:41:17 * jle` reassures tikhon
00:41:24 <kazagistar> GHCi is pretty damn shifty to be sure, coming from dynamic langauge REPLs
00:41:39 <tikhon> I'm pretty hopeful for IHaskell
00:41:47 <tikhon> I haven't tried it yet
00:41:48 <tikhon> but I hope
00:42:01 <Hafydd> Is that Apple's version of Haskell?
00:42:11 <tikhon> that would be iHaskell—completely different thing
00:42:29 <kazagistar> I would say the fact that Haskell is able to have a pretty nice and usable REPL sets a high bar for everyone else
00:42:49 <tikhon> or maybe Objective Haskell: http://www.haskell.org/haskellwiki/O%27Haskell
00:43:04 <kazagistar> with the capital letters means "works with the fancy IPython Journal stuff" afaik
00:43:36 <Hafydd> Seeing a capital I prefix just brings back memories of .NET programming.
00:43:37 <tikhon> you can see a demo of IHaskell here: http://gibiansky.github.io/IHaskell/demo.html
00:44:10 <tikhon> I think it's pretty compelling, but I'm too content tooling around with GHCi in Emacs to try anything new at the moment
00:44:17 <kazagistar> haha, that too, for some reason C# really likes hungarian notation to signify interfaces
00:44:39 <tikhon> I think that got carried over from C++ where interfaces were just normal classes
00:45:49 <kazagistar> tikhon: IPython Notebook is more of a teaching/explaining tool I think...?
00:46:02 <tikhon> my understanding is that it works pretty well as a REPL too
00:46:21 <tikhon> I've used IPython that way, although not any of the fancy features
00:46:22 <kazagistar> tikhon: also, I am pretty sure interfaces and classes still share a namespace in C#, so they still need it for that I guess...
00:47:19 <tikhon> some of the IHaskell features are certainly aimed at interactive development, like the Hoogle integration
00:47:20 <pavonia> This IHaskell demo reminds me of Maple worksheets
00:54:27 <kazagistar> out of curiosity, does anyone know of a good syntax-aware autocomplete implementation for haskell?
00:56:09 <tikhon> kazagistar: I've never gotten anything like that working properly :(
00:56:14 <tikhon> maybe ghc-mod supports it?
00:56:49 <tikhon> I think it's supposed to do auto-completion, but I never got it fully working.
00:57:30 <tikhon> http://www.mew.org/~kazu/proj/ghc-mod/en/
00:57:34 <Aetherspawn> lenses make things so confusing
00:57:54 <tikhon> I have to admit I'm just really swayed by the "Happy Haskell Programming" title
00:58:33 <tikhon> I figure that would make for the perfect job title: "Happy Haskell Hacker"
00:59:20 <kazagistar> I can imagine syntax aware autocomplete to be a hard problem, and not the math hard, but the ugh so many hacks because inherently undecidable or too complex hard
00:59:31 <jle`> i use the neocomplcache plugin for vim?
00:59:40 <jle`> by syntax aware...it knows when i'm in a pragma, heh
00:59:44 <jle`> or trying to import a module
00:59:57 <jle`> so if i'm importing a module it looks up things exported by that module
01:00:02 <tikhon> kazagistar: I think it's a hard problem in the "ugh, what a hideous API" and "gah, so many extensions to support" variety
01:00:14 <jle`> if and also i can tab complete the module hierarchy names
01:00:22 <tikhon> jle`: what about normal identifiers rather than modules or pragmas?
01:00:50 <jle`> tikhon: i...don't really pay enough attention to it to notice
01:00:54 <tikhon> because I actually already have auto-complete for imports, although I'm not sure what plugin does that (maybe standard Haskell-mode)?
01:01:10 <Aetherspawn> I cried a shout of joy
01:01:23 <Aetherspawn> when I saw that the 7.8 release unbroke windows in the last like 20 hours
01:01:37 <Aetherspawn> would buy simon marlow beer.
01:07:33 <kazagistar> I guess with haskell it is pretty hard to guess what might come next in most cases, I think inline hoogle might be as good as it gets...
01:08:35 <tikhon> kazagistar: I think a "reverse" autocomplete would make sense. Normally, you start with what you have and autocomplete suggests what you can do with it. But, thanks to type inference, we can start with what we *need* and autocomplete can suggest how to get there.
01:10:20 <kazagistar> yeah, but the problem is, even in simple cases, it seems like what you need does not constrain it enough
01:11:04 <tikhon> I figured you could combine that with some heuristics based on what arguments you have, what else you have in scope... etc
01:11:34 <tikhon> so if you have an Int argument and need a Double, you could list functions that take an Int and ultimately return a Double above other options
01:11:37 <kazagistar> if for example you have a "x :: [Int] -> Int -> String" and you write something like "x y = read . (+y) .", it MIGHT be able to figure out that it needs to find something [Int] -> Int, but that is still pretty broad
01:12:51 <jle`> hm
01:12:57 <jle`> hey, with typed holes
01:13:03 <jle`> could we have hoogle integration?
01:13:12 <jle`> write a hole and have it automatically look up a hoogle search
01:13:34 <tikhon> that would be pretty cool
01:13:51 <jle`> although
01:13:52 <tikhon> I've also thought a Hoogle* would be cool
01:13:54 <jle`> you wouldn't even need hoogle?
01:14:01 <tikhon> the transitive closure of hoogle :)
01:14:08 <jle`> couldn't ghc provide a 'spell checker' for functions?
01:14:15 <jle`> like, for types
01:14:21 <jle`> it already has all of the functions/values in scope, right?
01:14:28 <ricky_clarkson> You could call it a 'type checker'.
01:14:29 <jle`> can't it suggest what functions are in scope that would fill that hole?
01:14:33 <jle`> ricky_clarkson: :P
01:15:00 <tikhon> Hoogle is great because it can search modules you haven't imported yet.
01:15:08 <tikhon> but you'd probably want to list stuff you have in scope earlier
01:15:47 <kazagistar> hmm, what about something like filling in with light, greyed out text the types of the parameters that are still missing for your expression?
01:16:14 <jle`> "Detected a typed hole _h.  It is of type [a] -> Maybe a.  Perhaps do you mean `listToMaybe` from `Data.Maybe`?"
01:16:41 <jle`> bad example because it's not in Prelude, but..
01:16:46 <MedDev> can i import qualified and hide an exported function at the same time?
01:16:56 <jle`> "detected a typed hole _h.  it is of type Int -> String.  Perhaps do you want `show`?"
01:17:10 <MedDev> i get parse errors when i try import qualified Data.Array.Accelerate hiding (++) as A
01:17:23 <MedDev> same with the hiding bit at the end
01:17:24 <jle`> MedDev: try movinng the hiding stuff after the as A
01:17:26 <jle`> hm
01:17:28 <tikhon> yeah
01:17:30 <jle`> oh
01:17:32 <jle`> you need ((++))
01:17:33 <tikhon> that works
01:17:36 <MedDev> ah ok
01:17:45 <jle`> because it's (identifier, identifier ...)
01:17:50 <jle`> and ++ is not an identifier, (++) is
01:17:54 <tikhon> you need both the extra parens and to put hiding after as
01:18:15 <jle`> it's kind of silly and it actually gave me much agony when i first tried importing <$>
01:18:22 <tikhon> yeah
01:18:52 <jle`> it's also kind of hard to google
01:19:01 <kazagistar> so will most of the hiding pain go away if the applicative monad functor hierarchy is fixed up?
01:19:15 <jle`> hm?
01:19:37 <kazagistar> actually, yeah, thats not where the pain is now anyways, nevermind lol
01:19:49 <kazagistar> all my pain came from !
01:21:37 <tikhon> if only we had a real module system...
01:21:51 <kazagistar> I was indexing an array and a map in the same code, so I constantly had to Array.! and Map.!
01:22:13 <tikhon> I would probably have renamed one of them to !: or something
01:22:17 <kazagistar> which kinda totally defeated the point of the terse syntax for infix lookup
01:27:09 <kazagistar> http://www.haskell.org/hoogle/?hoogle=%28!%29 ... all their type signatures are so similar (except the html one which is crazy but nevermind) and make me want to give up on it all and write Julia or something similarly duck-typed
01:27:41 <tikhon> yeah
01:27:54 <jle`> kazagistar: you can rename them...or even rename them locally heh
01:28:14 <tikhon> that's what a good module system would overcome: we could have a general "collection" module and lists, arrays, maps... etc could be based on that
01:28:30 <tikhon> typeclasses, unfortunately, aren't quite up to the task in practice
01:29:14 <tikhon> I'm using a library which has a Graph typeclass in order to be generic like this, and it's a royal pain because inference breaks really often
01:29:26 <tikhon> and there's only a single instance of the typeclass anyhow :P
01:30:16 <tikhon> with (!) it would be even worse because it would have to be a fairly complex multiparameter typeclass
01:32:03 <kazagistar> btw, why can't haskell figure out which (!) I want to use in this particular instance? it does it make the type system indecidable? If I write "name :: Map String String -> String; name person = show (person ! "first") ++ show (person . "last")", its clear to me at least that I don't want to use Array.!
01:32:23 <tikhon> for one, what would the type of (!) by itself be?
01:32:43 <tikhon> more generally, that sort of overloading is already handled by typeclasses most of the time
01:32:55 <tikhon> it would also screw up type inference
01:33:23 <tikhon> we generally want a "principal type" for every term
01:33:50 <tikhon> I was actually thinking about that same question a while back
01:34:32 <kazagistar> I know it would be a massive quality of life difference for me, even if it could only do it in some cases with an extention
01:34:49 <tikhon> there was a proposal vaguely like that involving a special use of .
01:34:52 <tikhon> let me see if I can find it
01:35:23 <tikhon> aha: "Type Directed Name Resolution": https://ghc.haskell.org/trac/haskell-prime/wiki/TypeDirectedNameResolution
01:35:31 <tikhon> it's not entirely dissimilar
01:36:03 <tikhon> but yeah, I'm worried that it would be a bit confusing in practice and likely to make bad programs type check
01:36:10 <tikhon> you can use ix from lens instead
01:36:23 <tikhon> which does the same thing but with typeclasses and lenses and magic
01:36:35 <kazagistar> ix has constraints which would make it unsuitable for things like Map
01:36:51 <kazagistar> oh, wait, I didnt read the lens part
01:36:52 <tikhon> I thought Map supported something akin to ix
01:36:57 <supki> ix works with Maps
01:37:02 <tikhon> yeah
01:37:24 <tikhon> and it unifies getting, setting, modifying and some other stuff
01:37:34 <tikhon> lots of other stuff, actually :P
01:37:52 <supki> yeah, there aren't many things ix does not work with
01:38:11 <kazagistar> ... so basically, all my problems come from not using lenses yet like the cool kids ;)
01:38:18 <tikhon> yes!
01:38:21 <jle`> haha
01:38:31 <tikhon> (I say a bit hypocritically: I'm not really using lens right now.)
01:39:16 <tikhon> one of the things lens does relatively well is really broad overloading based on a tower of typeclasses
01:39:34 <tikhon> this makes for some slightly scary types sometimes
01:39:35 <tikhon> :t ix
01:39:36 <lambdabot> (Indexable (Index m) p, Ixed f m) => Index m -> p (IxValue m) (f (IxValue m)) -> m -> f m
01:39:54 <kazagistar> so far, I watched some 2 hour video on lenses while half asleep, and seem to remember it being somewhat similar to linq, so yeah, I am basically at step zero right now
01:39:54 <tikhon> but its use isn't nearly as scary as all that!
01:40:04 <tikhon> [1..10] .~ ix 3
01:40:06 <tikhon> > [1..10] .~ ix 3
01:40:07 <lambdabot>  Couldn't match type `[t1]'
01:40:07 <lambdabot>                with `(a0
01:40:07 <lambdabot>                       -> Control.Lens.Internal.Setter.Mutator
01:40:07 <lambdabot>                            (p0 (Control.Lens.At.IxValue m0) (f0 (Control.Lens...
01:40:07 <lambdabot>                             -> m0 -> f0 m0))
01:40:17 <tikhon> ooh, got the operator wrong, I think
01:40:24 <tikhon> > [1..10] ^. ix 3
01:40:25 <lambdabot>  No instance for (Data.Monoid.Monoid a0)
01:40:25 <lambdabot>    arising from a use of `e_11103'
01:40:25 <lambdabot>  The type variable `a0' is ambiguous
01:40:25 <lambdabot>  Possible fix: add a type signature that fixes these type variable(s)
01:40:25 <lambdabot>  Note: there are several potential instances:
01:40:38 <tikhon> anyhow, I obviously don't use lens very much
01:40:40 <tdammers> my use case for lenses is mostly to make State computations look more imperative :x
01:40:43 <supki> > [1..10] ^? ix 3
01:40:45 <lambdabot>  Just 4
01:40:47 <tikhon> aha
01:40:52 <tikhon> thanks
01:41:13 <kazagistar> lambdabot has to write errors on multiple lines for lens :P
01:41:14 <tikhon> kazagistar: you should watch SPJ's talk about lenses
01:41:30 <tikhon> I found it to be a very accessible introduction
01:41:55 <tikhon> I even used them for a bit, but the stuff I'm working on didn't really benefit much from it
01:42:26 <supki> SPJ does not explain stuff that demands the complexity though
01:42:39 <jle`> i just like the lens tutorial on the lens homepage
01:42:43 <tikhon> right, but it gave me the kernel I needed to jump right into the library
01:42:45 <kazagistar> I watched this one, https://www.youtube.com/watch?v=Q7l56Ryy8H8, but I was tired and didn't use it, sooo.... could you link yours?
01:42:47 <supki> but for understanding simple lenses it's a good talk
01:43:42 <tikhon> hmm, it seems to be behind a login page
01:44:16 <pyon> Where are Indexable, Ixed, Index and IxValue defined? :-O
01:44:32 <tikhon> here's the link I have: https://skillsmatter.com/skillscasts/4251-lenses-compositional-data-access-and-manipulation
01:44:47 <tikhon> it used to just have the video, but now they seem to require you to log on or something
01:44:50 <tikhon> it's terrible!
01:44:59 <tikhon> I can't find it on YouTube either
01:45:01 <kazagistar> yeah, its login walled
01:46:59 <kazagistar> looks like it isn't paywalled at least?
01:47:08 <tikhon> hopefully not
01:50:12 <johannesbodannes> Is there anyone here who has found fpcomplete particularly useful? I'm contemplating buying a subscription...
01:50:22 <Peaker> I have a very-Filepath-handling-heavy program. The Stringy representation from Prelude is horrendous.  I am thinking of using System.Posix.ByteString which has RawFilePath = ByteString. But there doesn't seem to be System.FilePath-style functions
01:50:24 <kazagistar> well, ill save the link and watch it tommorow, thanks
01:50:32 <johannesbodannes> I love vim, but i'm a bit of an IDE junkie
01:51:00 <tikhon> Emacs is the best of both worlds ;)
01:51:13 <bergmark> johannesbodannes: they might be working on a vim plugin for the api like they are doing with emacs
01:51:18 <johannesbodannes> I find Emacs a bit terrifying compared to vim : S
01:51:33 <johannesbodannes> I don't have the manual dexterity for it
01:51:37 <tikhon> Terrifying in a *good* way. Like Haskell.
01:51:49 <kazagistar> johannesbodannes: we were just discussing earlier how autocomplete is kinda hard in haskell...
01:51:50 <Peaker> tikhon: emacs is the least worst of both worlds, perhaps :P
01:52:39 <tikhon> that said, I do wish fpcomplete success, and it wouldn't hurt them to have more customers
01:53:00 <johannesbodannes> That's a real shame. It's lovely being able to type like 2 letters of something and have the autocompletion engine type out everything else for you <_>
01:53:35 <johannesbodannes> that, testing, and ease of compilation are about the only things I really miss from IDEs
01:53:51 <tikhon> I think fpcomplete does have autocomplete, but I don't know how good it is
01:54:24 <kazagistar> it might be possible, but it is much stranger to figure out what autocomplete should be in haskell then in something like java...
01:54:49 <johannesbodannes> What do you think is the main challenge for haskell autocomplete?
01:55:32 <kazagistar> I mean, autocomplete by just looking at matching words from the document is 90% of the needed functionality
01:55:32 <tdammers> johannesbodannes: knowing what's in scope, and deciding whether the current context is type-level or value-level
01:56:09 <tdammers> personally, I think vim-style dumb autocomplete is perfectly adequate
01:56:09 <kazagistar> tdammers: why is type-level vs value-level hard?
01:56:30 <tdammers> kazagistar: because at the time you do the auto-completion, you have incomplete code
01:56:58 <tdammers> data Foo = Foo B<Tab>
01:57:19 <tdammers> eh wait
01:57:22 <tdammers> no that one is simple
02:05:31 <usrx> how is 'cons' another word for ':'?
02:05:43 <usrx> (again, LYAH)
02:05:50 <tikhon> it's short for "constructor"
02:06:13 <tikhon> you can't use it in your Haskell programs though
02:06:27 <tikhon> it's a historical artifact from the Lisp world
02:06:37 <usrx> I see
02:06:38 <usrx> thanks
02:07:17 <jle`> i always thought it was cons because it was snoc backwards
02:07:23 <jle`> and snoc meant postpend in finnish
02:07:38 <tikhon> no, it's snoc that's backwards :)
02:07:46 <tikhon> but the Finnish connection is interesting
02:08:01 <jle`> (it's not becuase i made it up :))
02:08:20 <zomg> as a finn that caused me to lift my eyebrow in confusion
02:08:43 <kazagistar> usrx: cons is a function that constructs a new list by taking an item and prepending it to an existing list
02:09:17 <kazagistar> lisp had some silly things though... see cdadr and whatnot :P
02:09:56 <tdammers> 'cons' is 'construct', i.e. 'make a construct with the given car and cdr'
02:10:12 <Axman6> a very poor choice or words
02:10:16 <tdammers> sure
02:10:17 <usrx> > :t cons
02:10:17 <lambdabot>  <hint>:1:1: parse error on input `:'
02:10:40 <jle`> it'd be :t cons...but cons isn't a real defined function i think
02:10:42 <jle`> :t cons
02:10:43 <lambdabot> Cons Control.Lens.Internal.Review.Reviewed Identity s s a a => a -> s -> s
02:10:45 <jle`> heh
02:10:56 <kazagistar> it would wouldn't it :P
02:10:56 <tdammers> but then, calling an effectful subroutine a "function" wasn't exactly a good choice either
02:12:23 <lieven_> lisp also has RPLACA, RPLACD and some other weird old stuff left
02:12:35 <kazagistar> most people have fixed that by using "method" for everything instead now :P
02:13:43 <jle`> hm
02:14:05 <jle`> i think procedure/subroutine might be nice
02:14:13 <jle`> method has connotations attached with objects i think
02:14:24 <kazagistar> that was my implication
02:14:30 <jle`> ah
02:14:44 <jle`> i'll get back to my fortran project then
02:14:45 <tikhon> I'm generally happy with "procedure"—subroutine feels too old-fashioned/Perl-ish
02:15:00 <tikhon> and that's the word they used in SICP :)
02:15:20 <jle`> subroutine is syntax in fortran
02:15:26 <zomg> Procedure sounds like something they do in surgery
02:15:33 <tikhon> I already said "old-fashioned" ;)
02:15:51 <jle`> fortran differentiates subroutines and functions, interestingly enough
02:15:52 <kazagistar> "subroutine" seems like it only belongs in a "routine"
02:16:02 <jle`> fortran is still alive!
02:16:12 <tdammers> procedure is fine.
02:16:25 <tdammers> (Pascal was my first language, can you tell?)
02:16:27 <tikhon> jle`: and yet my point stands
02:16:38 <zomg> kazagistar: or Basic
02:16:50 <kazagistar> sort of like "subtype" or "subclass" or whatnot, sub has connotations that make procedure seem nicer
02:16:52 <jle`> fortran makes the same distinction between functions and subroutines as we are taking about now
02:16:58 <jle`> so maybe fortran was ahead of its time
02:17:04 <jle`> or...c, etc. were backwards
02:17:19 <tikhon> I'd go for the latter, but I've never been a big fan of C
02:17:40 <merijn> tikhon: No one who knows C has been a big fan of it :p
02:18:11 <tikhon> merijn: you say that, but I know people...
02:18:15 <tikhon> *systems* people
02:18:24 <merijn> tikhon: I am system's people :<
02:18:29 <jle`> :<<
02:18:32 * hackagebot ngrams-loader 0.1.0.0 - Ngrams loader based on http://www.ngrams.info format  http://hackage.haskell.org/package/ngrams-loader-0.1.0.0 (YorickLaupa)
02:18:35 <kazagistar> ... I think C is pretty nifty? <_<
02:18:54 <Aetherspawn> I'm a fan of C99 actually
02:18:59 <tikhon> it's cute: it has whole *classes* of unique bugs and security exploits
02:19:02 <Aetherspawn> I like it more than C++, definately.
02:19:03 <merijn> tikhon: Well, there's people who claim to know C, but actually know a language that's almost, but not quite entirely unlike C :p
02:19:13 <merijn> Aetherspawn: C11 has stdatomic.h \o/
02:19:35 <tikhon> it's a shame the systems community and the PL community broadly do not play well together
02:19:59 <johannesbodannes> i actually really like C myself. more than C++ at least
02:20:03 <tikhon> some pretty promising C competitors never took off, which makes me sad :(
02:20:03 <Aetherspawn> c11 is impossible to find an implementation of
02:20:07 <johannesbodannes> i think C feels a lot more coherent
02:20:11 <Aetherspawn> yeah
02:20:14 <Aetherspawn> C++ is a dogs breakfast
02:20:17 <kazagistar> tikhon: such as?
02:20:23 <tikhon> BitC comes to mind
02:20:34 <jle`> does anyone use anything other than dogescript?
02:20:49 <Aetherspawn> and C, lets be honest, is powerful but at a really high level. For example, you can still do things like export your static types without exposing their inner methods using forward declaration
02:20:55 <tikhon> On the one hand, C++ is extremely complex with a messy design
02:20:58 <Aetherspawn> it has more powerful tools than C++, like array range initializers
02:21:02 <Arianvp> I was wondering... Is every (Applicative f, Foldable f, Monoid (f a)) a monad?  When we take (>>=) = flip foldMap
02:21:16 <tikhon> on the other hand, it actually supports defining reasonable abstractions, unlike C
02:21:17 <tdammers> tikhon: but so does PHP. And Python. And C++. And Java.
02:21:18 <tikhon> in fact, I'
02:21:27 <merijn> kazagistar: If you like C, I have a question for you :>
02:21:39 <tdammers> (having whole classes of unique bugs and security flaws, that is)
02:21:39 <Aetherspawn> well, C models OOP like Haskell does
02:21:44 <tikhon> in fact, I'm a fan of C++'s philosophy in terms of having abstractions that are free at runtime
02:21:48 <Arianvp> It seems to work out ...
02:21:49 <Aetherspawn> if there is OOP, you have to model it higher
02:21:51 <Aetherspawn> rather than as sugar
02:21:51 <zomg> jle`: ArnoldC
02:21:59 <jle`> zomg: ?
02:22:05 <Aetherspawn> and that is a good thing. OOP is a piece of turd.
02:22:10 <jle`> haha
02:22:12 <zomg> jle`: I use ArnoldC, not Dogescript
02:22:13 <zomg> =)
02:22:17 <tikhon> tdammers: could you name them? I'd think that most bugs would be shared between similar languages (ie PHP/Python/Ruby)
02:22:28 <Axman6> tikhon: but not at development time ;)
02:22:36 <tikhon> unlike problems with null-terminated strings or such
02:22:40 <merijn> kazagistar: Without compiling answer the following: 1) Does the result of this code depend on the implementation? 2) What is the result on the platform of your choice? http://lpaste.net/101705
02:22:56 <jle`> Arianvp: interesting
02:23:04 <johannesbodannes> i don't think OOP being turd is all that fair. i think it's a pleasant abstraction, but i am really disgusted by all these multiparadigm languages that just stick it on to cheaply solicit industry interest
02:23:14 <tikhon> Cyclone is another programming language that died out
02:23:54 <tikhon> There's also CCured, which adds type-safety to C. I think people actually use that one, but I'm not sure.
02:24:20 <Arianvp> jle` : let's assume all the instances behave according to their laws... Then I see no problem.
02:24:30 <zomg> tikhon: heh, you could ask a lot of people and they'd say C is type safe.. =)
02:24:51 <tikhon> my personal peeve about C is that the design feels very arbitrary, especially now that it doesn't match any current CPUs very closely
02:24:57 <lieven_> merijn: not all that obfuscated as C goes :)
02:25:03 <jle`> Arianvp: why do oyu need the monoid constraint?
02:25:04 <tikhon> it's the same feeling I have with Go, actually
02:25:11 <jle`> oh, for foldMap
02:25:16 <jle`> :t foldMap
02:25:17 <lambdabot> (Foldable t, Monoid m) => (a -> m) -> t a -> m
02:25:25 <Arianvp> FoldMap needs mono is
02:25:38 <Arianvp> Monoid*
02:25:40 <tikhon> to be fair, even Haskell feels that way at times, but at least it has a beautiful, consistent core. And it's much better overall too.
02:25:43 <Aetherspawn> There are tons of problems with OOP
02:25:58 <Aetherspawn> and, I admit, there are a few nice sides to it
02:26:07 <tdammers> tikhon: well, PHP for example is highly susceptible to remote code execution attacks because of the way it abuses a static-file server to generate dynamic content
02:26:14 <Aetherspawn> but E(warts) > E(clear skin)
02:26:31 <tikhon> tdammers: right, but that seems shared with a bunch of other systems like Perl
02:26:35 <Arianvp> What I like about doing OOP in Haskell is that you get dependency injection for free
02:26:36 <tikhon> or Ruby!
02:26:37 <tdammers> tikhon: Python, well... biggest issue there is the complete lack of encapsulation and access control
02:27:04 <Arianvp> :D
02:27:05 <tikhon> and that's a problem in a bunch of languages—C included, no?
02:27:36 <tdammers> tikhon: I don't have a lot of ruby or perl experience, but I assume you can go the sane route in those, bake a basic HTTP server into your application and run behind a reverse proxy
02:28:11 <tikhon> I think you could do that with PHP too. And I should add that I definitely like PHP far less than C.
02:28:33 * hackagebot levmar 1.2.1.4 - An implementation of the Levenberg-Marquardt algorithm  http://hackage.haskell.org/package/levmar-1.2.1.4 (RoelVanDijk)
02:28:34 <usrx> tdammers: well, you could archieve encapsulation and access control with some 'workarounds' in Python, but I am not sure if that fits your need
02:28:35 <tdammers> I don't think PHP could pull this off. Too many memory leaks
02:28:50 <tdammers> usrx: not worth the pain
02:28:53 <johannesbodannes> PHP web server? <_<
02:29:00 <tdammers> johannesbodannes: PHP has a built-in web server now
02:29:02 <zomg> PHP already has a builtin webserver
02:29:04 <johannesbodannes> wow
02:29:08 <johannesbodannes> i had no clue
02:29:11 <tdammers> johannesbodannes: also, I wrote one myself out of pure masochism
02:29:15 <zomg> I think it's mostly used for development
02:29:29 <zomg> so you can spin up a dev instance without having to set up apache and whatnot
02:29:31 <tdammers> it's intended for development only, and it mimics most of Apache too
02:29:43 <tdammers> it does not provide any benefits in terms of security
02:29:51 <tdammers> it even parses .htaccess
02:29:58 <johannesbodannes> oh
02:30:05 <zomg> Running a PHP *script* for a long-running process has been something I would never do for quite a while
02:30:10 <zomg> (Used to do PHP for a living for a long time)
02:30:15 <tdammers> zomg: if not a script, then what?
02:30:21 <zomg> A different language altogether
02:30:22 <zomg> :P
02:30:25 <Arianvp> Haha
02:30:26 <tdammers> obvioulsy
02:30:34 <zomg> As you said, it's just so leaky
02:30:39 <peteretep> Seems most all frameworks come with a built-in webserver these days
02:30:41 <zomg> Would crash fast due to OOM
02:30:50 <tdammers> but that's like saying "cars are a perfectly safe form of transportation as long as you take the bus"
02:31:03 <Arianvp> The only php I'll ever write.  <? Exec("ghci")
02:31:10 <peteretep> tdammers: Both Perl and Ruby have recently embraced a sort of CGI plus
02:31:21 <peteretep> PSGI and Rack respectively
02:31:27 <zomg> Arianvp: wouldn't even work anymore I think with recent versions ;)
02:31:40 <peteretep> Makes them server agnostic while being (considerably more) performant
02:31:55 <zomg> They removed short open tags <? so you need the full tag <?php
02:32:04 <tdammers> peteretep: it's also much easier to keep something like that secure - make strong boundaries between code and data
02:32:29 <tdammers> zomg: that is actually a good thing. It means shitty PHP is less likely to run without throwing errors.
02:32:52 <zomg> Yeah most good developers didn't use the short tags anyway
02:34:01 <tdammers> short tags are only available if configured thusly. Good developers know it and avoid them because of that. Bad developers think that saving three keystrokes is worth the sacrifice. Shitty developers don't give a fuck and say "why, it works!"
02:37:01 <tdammers> Then, Java. Not a lot of typical exploits there, except that it's easy to lose track of mutable state, and that the general state of security patches is mostly at the mercy of Oracle.
02:40:53 <bartavelle> well, most java development I see is using 4 mega-frameworks at the same time, so you always get to worry a lot about typical exploits
02:41:24 <tdammers> yeah... also, a lot of java code runs on a horribly outdated software stack
02:41:34 <johannesbodannes> losing track of mutable state is really just a side effect of OO anyway, i think.
02:41:36 <tdammers> tjava isn't directly to blame for that though
02:41:39 <merijn> Anyhoo, this seems -blah material :)
02:41:43 <johannesbodannes> i don't like Java much, but I appreciate that it's faithful to the paradigm
02:41:44 <bartavelle> true
02:41:48 <johannesbodannes> more so than most OO languages
02:41:50 <tdammers> yeah, let's take it to blah
02:43:00 <johannesbodannes> i'm not much of a fan of multiparadigm languages
02:43:15 <johannesbodannes> i think they tend to accommodate all of their paradigms really poorly
02:43:24 <johannesbodannes> rather than doing one of them exceptionally well
02:43:35 * hackagebot ngrams-loader 0.1.0.1 - Ngrams loader based on http://www.ngrams.info format  http://hackage.haskell.org/package/ngrams-loader-0.1.0.1 (YorickLaupa)
02:45:36 <johannesbodannes> i find OCaml to be a bit of an abomination in fact : /
02:45:53 <johannesbodannes> i just can't understand why anyone would think that functional and OO play well together
02:49:07 <merijn> Simplest way to get "(a -> b) -> a -> (a, b)" is (id &&&), I guess?
02:50:04 <jle`> that's how i've been dong it
02:50:15 <merijn> oh, bollocks, I need "Monad m => (a -> m b) -> a -> m (a, b)"
02:51:33 <bartavelle> ap ((<*>) . ((,) <$>) . pure)   :p
02:51:38 <czro_> Hello. Short question where I guess the answer is something dead simple I fail to remember at the moment... How do i go from [Maybe (Maybe a)] to [Maybe a] in the easiest way?
02:51:56 <merijn> czro_: map join
02:51:59 <merijn> :t map join
02:52:00 <lambdabot> Monad m => [m (m a)] -> [m a]
02:52:32 <czro_> merijn: Excellent! As I expected :)
02:52:59 <czro_> merijn: I owe you a beer.
02:53:00 <merijn> czro_: Doctor's prescription: Meditate on the contents and Control.Applicative and Control.Monad twice daily :)
02:53:17 <merijn> s/contents and/contents of
02:53:52 <merijn> Is there a short hand for [minBound..maxBound]?
02:54:03 <czro_> merijn: That is a prescription I will adhere to.
02:55:23 <Aetherspawn> gabriels libraries are really the best
02:55:36 <Aetherspawn> they are most beautifully designed
02:55:38 <Aetherspawn> a pleasure to work with
03:02:57 <Axman6> is GHC's type system turing complete?
03:05:46 <Aetherspawn> Axman6: yes
03:05:52 <Aetherspawn> actually, let me find you the link
03:05:55 <supki> :t (sequenceOf _2 .) . (\f -> (<<%~) id f)
03:05:56 <lambdabot> Monad m => (s -> m b) -> s -> m (s, b)
03:06:00 <Aetherspawn> theres a programming language that operates in the type system
03:06:34 <supki> :t (sequenceOf _2 .) . (<<%~) id
03:06:35 <lambdabot> Monad m => (s -> m b) -> s -> m (s, b)
03:06:49 <supki> merijn: how about that? ^
03:06:54 <Aetherspawn> Axman6: https://github.com/seliopou/typo
03:08:08 <cwvh> Axman6: Yes, via extensions, http://www.haskell.org/haskellwiki/Type_arithmetic
03:14:46 <Axman6> excellent, thanks
03:52:54 <byorgey> Haskell 2010's type system is not Turing complete since it does not allow unrestricted recursion.  Exercise for the reader: is it sufficient to only turn on UndecidableInstances?
03:53:37 <hc> by that definition any language that doesn't do tail call optimisation isn't turing complete ;)
03:53:56 <Axman6> no, only language implementations
03:55:13 <merijn> hc: Turing completeness is usually used to refer to languages, not implementations as, assuming a finite universe, any implementation will by definition by finite and therefore not Turing complete
03:55:34 <hc> yeah
03:55:42 <merijn> hc: Fun fact, standard C is not Turing complete :)
03:56:08 <tdammers> merijn: because it has no unbounded data types?
03:56:27 <merijn> tdammers: No, because it mandates that any memory object is addressable by a fixed size pointer
03:56:36 <hc> so what about byorgey's reason as to why haskell's type system is not turing complete? ;)
03:56:43 <tdammers> merijn: same thing, in the end, right?
03:56:53 <merijn> hc: Standard haskell's type system is not Turing complete, no
03:57:03 <merijn> hc: GHC extensions make it Turing complete, though.
03:57:04 <hc> but surely not because of limited recursion?
03:57:30 <merijn> hc: Why not? Turing completeness requires the ability to write infinite loops
03:57:42 <hc> sigh
03:57:43 <merijn> hc: Restricted recursion behaviour makes that impossible
03:57:53 <hc> either that restriction is a valid reason or not
03:58:00 <hc> make up your mind please
03:58:05 <byorgey> hc: when I said "it does not allow unrestricted recursion" what I meant was that it does not allow recursion it cannot prove is terminating.
03:58:06 <merijn> hc: Ah
03:58:14 <byorgey> it has nothing to do with resource limits.
03:58:19 <merijn> hc:  The difference is that in C you have a stack limit
03:58:44 <merijn> hc: Haskell's type system does not permit writing recursion that is not limited by terminating
03:59:00 <merijn> hc: So it's not a resource limit, but a limit to what you can express
03:59:23 <hc> ok, i see the difference now, thank you1
03:59:55 <merijn> hc: If you're familiar with STLC, it's similar to why you can write a y combinator in UTLC, but not STLC
04:00:16 <merijn> (i.e. haskell types are always strongly terminating unless you enable extensions)
04:02:08 <johannesbodannes> wait what? 2010 doesn't allow nonterminating recursion? like... does "nonterminating = getLine >>= putStrLn >> nonterminating" work then?
04:02:24 <Axman6> in the type system
04:02:32 <johannesbodannes> oh
04:02:38 <johannesbodannes> sorry, misunderstood
04:03:47 * hackagebot polysoup 0.5.0 - Online XML parsing with polyparse and tagsoup  http://hackage.haskell.org/package/polysoup-0.5.0 (JakubWaszczuk)
04:04:07 <hc> byorgey: so about your original question, if i understand it correctly, UndecidableInstances change the limit from 'must be provably terminating' to 'we impose some depth limit'
04:04:13 <hc> in other words, the answer is 'yes and no' ;)
04:04:16 <merijn> johnw: Why does c2hsc allow specifying a prefix, but not override the filename? i.e. why does foo.h always become module "Foo"?
04:04:44 <Axman6> because file a bug report
04:04:53 <Axman6> or, feature request i guess
04:23:50 * hackagebot socketio 0.1.2 - Socket.IO server  http://hackage.haskell.org/package/socketio-0.1.2 (TingYenLai)
04:24:33 <byorgey> hc: no, there is no depth limit with UndecidableInstances
04:24:46 <byorgey> hc: not other than the limits imposed by the phyiscal memory of course
04:25:17 <byorgey> oh, hmm, actually, I might be wrong about that
04:25:31 <byorgey> but in any case you can set the depth limit to whatever you want by a command-line flag
04:25:40 <hc> hmm, then it sould make the type system turing complete, right?
04:25:56 <hc> s/sould/would/
04:26:11 <byorgey> yes, with UndecidableInstances I think the type system is turing complete. (you might need one or two other extensions but I think UndecidableInstances is enough.)
04:33:20 <Kaidelong> okay I'm ready to try a different approach to windows development
04:33:33 <Kaidelong> run linux, cross compile with jhc, test on wine
04:33:42 <Kaidelong> how viable is this?
04:37:25 <tdammers> running linux is very viable
04:37:29 <tdammers> the rest, not so sure
04:37:44 <tdammers> testing on wine is only useful in a relative way in any case
04:37:49 <tdammers> not sure how well jhc cross-compiles
04:38:34 <Kaidelong> I'm actually more concerned how it interacts with GCC
04:38:48 <Kaidelong> because I'm going to need to cross compile C libraries too
04:38:54 <tdammers> ah
04:39:08 <tdammers> at that point, biting the bullet and installing windows in a vm might be less painful
04:39:17 <tdammers> my $0.02, that is
04:39:20 <Kaidelong> well
04:39:29 <Kaidelong> the whole reason why I am at this point is GHC+windows frustration
04:39:49 <Kaidelong> maybe I should bite the bullet and just abandon haskell
04:40:21 <Kaidelong> but there aren't many good alternatives
04:41:08 <divyanshu> Kaidelong : Have you tried vagrant
04:41:12 <divyanshu> Kaidelong : http://www.vagrantup.com/
04:41:46 <Sonderblade> Kaidelong: what is your windows frustration about?
04:42:03 <Welkin> windows
04:42:09 <Welkin> what more is there to say?
04:42:14 <Sonderblade> well obviously :p
04:43:17 <Welkin> you can run an ec2 server for dev work
04:43:21 <Sonderblade> but ghc runs on windows and there's nothing terrible about it
04:43:23 <Welkin> compile and test on it remotely
04:43:43 <Welkin> then you don't have to set up a local environment and can use any machine you like
04:43:48 <Kaidelong> Sonderblade: GHC can't interact with VC++, only MinGW, that's a big part of it
04:44:20 <Kaidelong> so you often have to build things yourself because mingw development libraries aren't pre-built for you
04:44:30 <Kaidelong> and then you have to manually figure out the dependencies
04:44:50 <Kaidelong> and then find out why your haskell code isn't linking to the libraries
04:44:55 <Kaidelong> and it's just a pain
04:45:36 <Kaidelong> I'm not smart enough to get wxhaskell working on windows and I've been bashing at this for way too long
04:45:52 <Kaidelong> haskell-mpi took me a few weeks to get working
04:46:21 <Kaidelong> I got haskell-sdl working once in the past and that's not even a C++ library
04:46:43 <Kaidelong> (that's what I have been bashing my head against now)
04:46:50 <Kaidelong> on linux most of this works out of the box
04:46:54 <MrElendig> easiest way to develope on windows: run a vm with gnu/linux
04:46:54 <Sonderblade> can't you use haskells ffi to load dlls dynamically?
04:47:47 <Kaidelong> Sonderblade: isn't this what the bindings are already supposed to do?
04:49:27 <Kaidelong> divyanshu: I confess I don't quite understand what that does
04:50:05 <Kaidelong> divyanshu: is the idea that you deploy your program running on its own little virtual machine?
04:51:11 <divyanshu> Kaidelong : yes. And you can edit code in host machine and run it in little virtual machine.
04:51:29 <divyanshu> It's done by sharing folder.
04:52:41 <Kaidelong> divyanshu: does the user need to have a virtual machine installed to run the application then? the docs seem to suggest this
04:52:54 <Kaidelong> that's not a very satisfactory solution for deploying haskell code on windows
04:52:58 <Kaidelong> although
04:53:05 <Kaidelong> if it's totally transparent to the end user
04:53:11 <Kaidelong> this may work for me
04:53:52 <divyanshu> Kaidelong : I want to point you here http://www.erikaheidi.com/2013/07/02/a-begginers-guide-to-vagrant-getting-your-portable-development-environment/
04:54:35 <Sonderblade> Kaidelong: i dont think so. it seem to want to compile and link to libsdl on windows which is different from dynamically loading it
04:55:21 <Sonderblade> Kaidelong: the latter approach is much easier for windows users since nothing has to be compiled, just find the libsdl.dll and you are ready
04:56:22 <Kaidelong> I guess the bindings don't really add much in the case of SDL
04:56:31 <Kaidelong> although
04:56:47 <Kaidelong> there are some hackage packages that depend on sdl
05:04:30 <merijn> Kaidelong: Have you worked with cygwin before? I never really had much trouble getting things to work on windows that way...
05:07:55 <Apocalisp> I'm having a hard time understanding the logic behind Data.Monoid.Coproduct.untangle
05:08:19 <Kaidelong> merijn: I'll admit I haven't really used cygwin much
05:08:40 <macanudoman> Apocalisp: holly molly that sounds awful
05:08:59 <Kaidelong> maybe I should, I'm used to using MSYS instead (and before that I used UNIX tools for Windows, which is now abandoned)
05:09:11 <Apocalisp> Why is it important that every n value is acted on by every m value on its left?
05:10:38 <macanudoman> @hoogle Data.Monoid.Coproduct.untangle
05:10:38 <lambdabot> No results found
05:10:54 <Kaidelong> macanudoman: (Action m n, Monoid m, Monoid n) => (m :+: n) -> (m, n)
05:11:08 <Kaidelong> :+: is the coproduct of m and n
05:11:43 <Apocalisp> http://hackage.haskell.org/package/monoid-extras-0.2.1.0/docs/Data-Monoid-Coproduct.html
05:12:29 <Sonderblade> Kaidelong: seen this http://mirror.seize.it/hsSDL/hssdl/WIN32
05:14:32 <haasn> Apocalisp: I'm sure byorgey would know. (ps. why is ‘act’ defined like appEndo . mconcat . map (Endo . f) rather than foldr ((.) . f) id?)
05:15:18 <Apocalisp> haasn: No idea. That should be equivalent, no?
05:15:51 <haasn> It should; but the former seems more “wasteful” to me; then again there's probably not really a difference either way
05:15:52 <Apocalisp> Maybe for coherence, to stay within monoids
05:16:02 <haasn> Yeah, I guess it's more “elegant”
05:16:06 <byorgey> haasn: no particular reason. pull requests welcome =)
05:16:14 * haasn should benchmark it
05:16:20 <Apocalisp> do it
05:16:32 <haasn> not sure how :P
05:16:34 <mr-> maybe comparing the resulting code will reveal more
05:16:38 <haasn> I mean, what Action would I be benchmarking
05:16:44 <byorgey> Apocalisp: the untangle stuff arose from the particular way we are using monoid coproucts in diagrams
05:16:57 <byorgey> Apocalisp: in particular we have a sequence of transformations and styles (collections of attributes)
05:16:57 <Apocalisp> byorgey: Do tell!
05:17:07 <byorgey> but some attributes are affected by transformations
05:17:40 <absence> what is the alternative to using Arrow for frp? Applicative? is reactive banana the primary example of this, or are there others? can netwire be used without the Arrow instances?
05:18:34 <Apocalisp> byorgey: I can _kind of_ see it. Can you give more detail?
05:19:01 <Apocalisp> also, is untangle a homomorphism?
05:20:27 <byorgey> Apocalisp: that is an excellent question.  No, it is not.
05:21:52 <macanudoman> I have to say that listening to this channel im learning more than in all my compsci degree
05:22:03 <haasn> Apocalisp: untangle (inL m) = (m, mempty);  untangle x = (m', n'); but untangle (inL m <> x) = (m <> m', act m n')
05:22:07 <haasn> or something like that
05:22:14 <haasn> the actions change, at any rate
05:22:30 <Apocalisp> eyah
05:23:25 <Apocalisp> I am wondering what kind of law I can state about it
05:23:34 <Apocalisp> I guess this is a legal question :)
05:23:40 <haasn> it's a monoid homomorphism in the left element, I think
05:23:53 <Apocalisp> yes, seems to be
05:24:04 <Kaidelong> installing cybwin right now
05:30:20 <haasn> byorgey: I'm a bit confused about untangle, maybe by asking my question here I'll realize where my confusion arises from
05:31:01 <haasn> as per the documentation, the RHS of (m1 <> n1 <> m2 <> n2 <> m3 <> n3 <> ...) is sent to: act m1 n1 <> act (m1 <> m2) n2 <> act (m1 <> m2 <> m3) n3 <> ...
05:31:21 <haasn> it's an Action law that act (m1 <> m2) n = act m1 (act m2 n)
05:31:36 <haasn> so this is: act m1 n1 <> act m1 (act m2 n2) <> act m1 (act m2 (act m3 n3)) <> ...
05:31:58 <haasn> but if ‘s’ is a monoid, it's also an Action law that act m s1 <> act m s2 = act m (s1 <> s2)
05:32:22 <haasn> so this becomes: act m1 (n1 <> act m2 n2 <> act m2 (act m3 n3))
05:32:43 <haasn> ah, that's where it stops
05:32:59 <haasn> I thought I would be able to further transform this to something like: act (m1 <> m2 <> m3) (n1 <> n2 <> n3)
05:33:12 <haasn> but I forgot that I can't simply pull out the ‘n1’ behind the act m2
05:33:26 <haasn> maybe it would be possible to implement untangle more efficiently with this transformation, though :)
05:33:48 <byorgey> maybe
05:33:53 <haasn> I somehow doubt it
05:34:21 <byorgey> to be honest the whole monoid coproduct/untangle stuff seems a bit unprincipled to me, I'd be happy to come up with a better way to solve the problem it's solving
05:34:24 <byorgey> but I don't know of one
05:35:13 <merijn> hmm, cabal doesn't support .chs files as Main-Is:?
05:35:33 <haasn> personally I'd just figure “monoid coproduct” means instance (Monoid m, Monoid n) => Monoid (Either m n)
05:35:48 <haasn> Oh, wait
05:35:56 <haasn> That's ambiguous between mempty = Left mempty and Right mempty
05:36:02 <haasn> (But both are legal!)
05:36:21 <haasn> I think..
05:36:31 <haasn> Wait, mappend is problematic
05:36:55 <haasn> No, it isn't, actually; depending on how you choose the logic
05:37:12 <haasn> with mempty = Left mempty and mappend (Right x) (Left _) = mappend (Left _) (Right x) = Right x -- it could work
05:40:04 <byorgey> haasn: you can make a monoid out of Either m n.  But it isn't a categorical coproduct.
05:40:35 <byorgey> (and it wouldn't suffice for what I am using monoid coproducts for.)
05:41:12 <byorgey> I guess you could call  Monoid (Either m n)  a "coproduct monoid".  which is very different than a "monoid coproduct". =)
05:44:01 * hackagebot log-effect 0.2.0.2 - An extensible log effect using extensible-effects  http://hackage.haskell.org/package/log-effect-0.2.0.2 (ibotty)
05:48:44 <r444> @hackage pcap
05:48:45 <lambdabot> http://hackage.haskell.org/package/pcap
05:52:49 <merijn> How come I'm getting a syntax error on this c2hs macro? "(#size edge_t)"
05:53:04 <merijn> "Main.chs:18:17: Not in scope: `#'" <- wut?
05:54:02 * hackagebot snaplet-mysql-simple 0.2.0.1 - mysql-simple snaplet for the Snap Framework  http://hackage.haskell.org/package/snaplet-mysql-simple-0.2.0.1 (ibotty)
06:10:27 <flebron> Hey guys. I'm going to have a presentation which will have Haskell code, commutative diagrams, and some math. Which LaTeX packages do you guys recommend? Is beamer still the best choice for presentations?
06:10:27 <Apocalisp> byorgey: Is the code that uses untangle posted anywhere?
06:12:10 <flebron> Apocalisp: http://www.cis.upenn.edu/~byorgey/diagrams-doc-HEAD/haddock/src/Diagrams-Core-Types.html#line-230 ?
06:18:20 <Kaidelong> I've just learned to run cabal with -v3
06:18:38 <Kaidelong> now I know that one of the problems I'm having is that I need the windows SDK installed
06:19:36 <Kaidelong> this feels like progress
06:20:42 <Kaidelong> I also feel a bit stupid
06:21:08 <Kaidelong> given that I do .NET I never realized that it might be important to have the windows SDK
06:21:43 <Kaidelong> (on ubuntu getting the development tools has always been an immediate impulse for me, so why not on windows too?)
06:25:19 <quicksilver> Kaidelong: because subconciously you know only a madman would try to develop on windows?
06:29:06 * hackagebot haskintex 0.4.0.0 - Haskell Evaluation inside of LaTeX code.  http://hackage.haskell.org/package/haskintex-0.4.0.0 (DanielDiaz)
06:29:08 * hackagebot wai-throttler 0.1.0.0 - Wai middleware for request throttling  http://hackage.haskell.org/package/wai-throttler-0.1.0.0 (mkulkin)
06:29:10 <davd> @djinn (Maybe a, Maybe b) -> Maybe (a,b)
06:29:10 <lambdabot> f (a, b) =
06:29:10 <lambdabot>     case a of
06:29:10 <lambdabot>     Nothing -> Nothing
06:29:10 <lambdabot>     Just c -> case b of
06:29:10 <lambdabot>               Nothing -> Nothing
06:29:12 <lambdabot>               Just d -> Just (c, d)
06:33:04 <davd> @pl it
06:33:04 <lambdabot> it
06:33:06 <bergmark> davd: i think do notation would be the nicest for that function
06:33:23 <davd> yeah
06:33:56 <Lethalman> :t \(a,b) -> ma <- a; mb <- b; return (ma,mb)
06:33:57 <lambdabot> Parse error in pattern: \ (a, b) -> ma
06:34:05 <Lethalman> :t \(a,b) -> do ma <- a; mb <- b; return (ma,mb)
06:34:06 <lambdabot> Monad m => (m t, m t1) -> m (t, t1)
06:34:23 * Lethalman did some practice
06:34:25 <ziman> :t liftM2 (,) :: Maybe a -> Maybe b -> Maybe (a,b)
06:34:26 <lambdabot> Maybe a -> Maybe b -> Maybe (a, b)
06:34:38 <Lethalman> :t \(a,b) -> (,) <$> a <*> b
06:34:39 <lambdabot> Applicative f => (f a1, f a) -> f (a1, a)
06:35:38 <davd> :t uncurry $ liftM2 (,)
06:35:38 <lambdabot> Not in scope: data constructor `'
06:36:15 <davd> oh well. great hints!
06:36:30 <peteretep> while uncurry is a phenomenally useful function, the names of curry and uncurry are unhelphul
06:37:39 <bergmark> my new favorite is f = curry $ \case (a,b) -> ...
06:38:31 <tromp> well, it's helpful if you remember currying transforms multi-argument functions
06:38:33 <bennofs> bergmark: how is that better than just using f pattern1 pattern1' = ..... ; f pattern2 pattern2' = ....; .... ?
06:38:59 <tromp> :t curry
06:38:59 <lambdabot> ((a, b) -> c) -> a -> b -> c
06:39:01 <bennofs> curry -> allows currying
06:52:01 <the_berserker> @pl foldr f a y = let {folder t [] = t; folder t (x:xs) = f x (folder xs)} in folder a y
06:52:01 <lambdabot> (line 1, column 14):
06:52:01 <lambdabot> unexpected " "
06:52:01 <lambdabot> expecting operator
06:52:45 <the_berserker> @pl let foldr f a y = (let {folder t [] = t; folder t (x:xs) = f x (folder xs)} in folder a y) in foldr
06:52:45 <lambdabot> (line 1, column 24):
06:52:45 <lambdabot> unexpected "{"
06:52:45 <lambdabot> expecting "()", natural, identifier or "in"
06:53:20 <the_berserker> @pl let foldr f a y = (let folder t [] = t; folder t (x:xs) = f x (folder xs) in folder a y) in foldr
06:53:20 <lambdabot> (line 1, column 33):
06:53:20 <lambdabot> unexpected "["
06:53:20 <lambdabot> expecting pattern or "="
06:53:35 <the_berserker> What the fuck?
06:55:46 <quicksilver> the_berserker: there are large chunks of haskell that @pl does not support.
06:56:01 <quicksilver> I think it doesn't support 'let', for example.
06:57:00 <the_berserker> > fix ((ap (:) .) . ((.) =<<)) (*2) 1
06:57:02 <lambdabot>  [1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,2...
07:00:02 <greg`> calloused fingered hackers, really simple question for you if you will
07:00:25 <greg`> ive updated my cabal file to include new dependencies, how do i get cabal to pull down the dependencies
07:00:42 <greg`> when i do capal build it complains about missing dependencies
07:02:06 <supki> cabal install --only-dependencies
07:03:46 <geekosaur> the deps will be checked during cabal configure, I believe, not cabal build
07:04:23 <greg`> so i need to type cabal configure?
07:04:28 <usrx> class Functor f where
07:04:29 <usrx>     fmap :: (a -> b) -> f a -> f b              how do we know that the f type variable produces a concrete value here?
07:04:58 <bennofs> usrx: what do you mean by "concrete value"?
07:05:10 <greg`> something of kind * ?
07:05:25 <usrx> bennofs: LYAH says "we see that the f type variable is used as a type that takes one concrete type to produce a concrete type. We know it has to produce a concrete type because it's used as the type of a value in a function." but I don't see the point
07:05:45 <supki> greg`: if you already have the dependencies installed then configure will be enough
07:06:25 <supki> I also think cabal build runs configure implicitly these days
07:06:29 <greg`> supki: thats, just it i dont, i dont think i should have to install the dependencies if they are already in my cabal file
07:06:38 <supki> ?
07:06:55 <geekosaur> usrx: the point is that you can't create a value of (for example) type `Maybe`; it has to be a type like `Maybe Int`
07:07:09 <geekosaur> so if you are referring to a value, it has to be something like the latter and not the former
07:07:52 <greg`> usrx: yes i think LYAH is defining 'concrete value' to mean a fully constructed value
07:07:59 <usrx> geekosaur: how does that fit in this definition then? fmap :: (a -> b) -> f a -> f b
07:08:02 <geekosaur> so when we refer to `f a` we know that `f` looks like (* -> *), that is, it takes a concrete type and produces a concrete type. like `Maybe` or `[]` or `Monad`
07:08:18 <supki> greg`: when you add dependencies to build-depends: you still need to tell cabal to install them
07:08:33 <usrx> geekosaur, greg`: ah ok
07:08:34 <geekosaur> (the [] one is kinda a special case; we would normally write [a] but [] a is just as valid)
07:08:43 <usrx> gotcha, thanks ;)
07:09:26 <greg`> supki: so i need to run cabal install in my project directory?
07:09:45 <usrx> and by "type of a value in a function" I think he means parameter?
07:09:51 <geekosaur> it cannot be Int because you can't apply Int to something else (what is Int Char?) and it cannot be something like State Int Char because that needs *two* types
07:10:07 <geekosaur> so there is no value of type State Int
07:10:22 <supki> greg`: yeah; if you only want to install the dependencies but not the package itself, append --only-dependencies
07:10:24 <geekosaur> a parameter or a return value
07:10:37 <geekosaur> so in that example, f a (parameter) and f b (return)
07:10:47 <usrx> alright
07:11:15 <greg`> usrx: "type of value" means its type is in the function type declaration
07:12:09 <greg`> supki: thanks, and this will stay in the sandbox.... ah i see on the console its going into the sandbox neat thanks
07:12:45 <greg`> so i made the mistake of using http-conduit and it seems to be attempting to download the whole internet
07:13:24 <makalu> hackage.haskell.org/package/base-4.6.0.1/docs/GHC-IO-Exception.html this gives me a "Page not found"
07:13:59 <merijn> LYAH's use of "concrete type" and ignoring kinds is probably the thing most often confusing readers :\
07:14:55 <greg`> merijn: he does mention kinds later on....but in a section with a caveat that states " you dont really need to read this" :-\
07:14:56 <c_wraith> understanding kinds is vital for understanding higher-kinded abstractions
07:15:19 <merijn> I don't think kinds are particularly tricky or hard either
07:15:25 <greg`> c_wraith: like jam is kinda important for a jam sandwich
07:15:36 <greg`> /s/jam/jelly/g
07:15:42 <merijn> Once you can manage haskell types, kinds are easy
07:16:09 <c_wraith> They really are pretty easy.  But being aware of them is important
07:16:57 <c_wraith> greg`: sure, but LYAH talks about Functor, Applicative, and Monad without a discussion of kinds.  That makes it harder to see what level of abstraction those classes are functioning on.
07:17:17 <Welkin> LYAH discusses kinds
07:17:27 <Welkin> it is in the section on types, at the end
07:17:35 <c_wraith> Welkin: not when it talks about Functor, Applicative, and Monad
07:18:17 <merijn> I know there is a printf, but is there a scanf in haskell? I don't care how ghetto and broken it is
07:18:24 <greg`> hmmm a kind is just a type anyway
07:18:33 <merijn> greg`: No
07:18:41 <merijn> greg`: At least not in haskell
07:18:45 <greg`> isnt a kind just a type of type
07:19:11 <merijn> greg`: "just a type" implies it's at the same level in the hierarchy as types, which they aren't
07:19:21 <merijn> Haskell has 3 explicit levels (and a 4th implicit one)
07:19:45 <merijn> Level 1: Values, Level 2: Types, Level 3: Kinds (implicit level 4: sort)
07:20:02 <greg`> oh really, i only know of the first 3
07:20:18 <merijn> greg`: That's because you can't write sorts in haskell
07:20:26 <merijn> greg`: They only exist implicitly inside GHC
07:20:29 <Welkin> printf? you mean putStrLn?
07:20:36 <merijn> greg`: sorts are to kinds as kinds are to types
07:20:38 <greg`> no printf
07:20:42 <merijn> Welkin: No, printf
07:20:44 <greg`> its in data.Text i think
07:20:45 <merijn> @hoogle printf
07:20:45 <lambdabot> Text.Printf printf :: PrintfType r => String -> r
07:20:45 <lambdabot> package printf-mauke
07:20:45 <lambdabot> Text.Printf module Text.Printf
07:20:48 <Welkin> really?
07:20:57 <Welkin> I don't know the standard library yet
07:21:06 <merijn> > printf "Yes, really: %d" 10 :: String
07:21:08 <lambdabot>  "Yes, really: 10"
07:21:30 <greg`> er.....
07:21:31 <merijn> It's kinda ghetto, though
07:21:37 <greg`> thats one level too meta
07:21:47 <greg`> kinds of kinds?
07:21:55 <greg`> does that even make sense?
07:22:08 <merijn> greg`: In dependently typed languages like Agda you essentially have an infinite number of nested universes for this
07:22:28 <greg`> ok, fair enough i will read a little more
07:22:34 <t7> >printf "%d %d" 1 2 :: String
07:22:37 <t7> > printf "%d %d" 1 2 :: String
07:22:38 <greg`> ok why doesnt cabal pull dependencies down
07:22:39 <lambdabot>  "1 2"
07:22:42 <greg`> like maven or apt
07:22:48 <t7> amazing
07:22:51 <greg`> argh cabal i hate you
07:22:54 <lieven_> merijn: xformat has something scanf like
07:23:25 <greg`> scanf would have to be in io no?
07:23:34 <merijn> That tries to be all type safe and proper
07:23:39 <greg`> ok gotta go, thanks for education guys
07:23:47 <merijn> I just want to ghetto grab some values from a String without writing a parser
07:24:05 <greg`> ghetto grab lol
07:24:31 <greg`> use regex
07:25:06 <greg`> regex is what you want, regex is ghetto , it was raised on the streets, grimy dirty and dusty but it gets the job done
07:25:16 <tdammers> merijn: write a parser anyway
07:25:18 <greg`> just dont complain if it turns round and bites you
07:25:22 <greg`> thats how it rolls
07:25:23 <greg`> lol
07:25:28 <mr-> greg`: cabal does pull the dependencies, if they are libraries.
07:25:31 * Kinnison tends to write a simple parser because they're usually easier than remembering how to ghetto it
07:26:26 <tdammers> also, a simple parser is less work, really, if you include testing and fixing all the edge cases
07:26:36 <mr-> greg`: also, there's no reason to hate cabal. You may only love it.
07:26:38 <greg`> ah ok, i think ive hidden one of the dependencies
07:27:09 <greg`> ok , like a bride in an arranged marriage, i will "learn to love" cabal
07:27:26 <merijn> tdammers: I'm not going to test and fix any edge cases
07:27:33 <greg`> gotta go , thanks all for my lunchtime education
07:27:37 <merijn> tdammers: I'm going to run it once as a PoC
07:27:37 <tdammers> merijn: still
07:27:59 <tdammers> or write it as a sed script
07:29:00 <merijn> tdammers: I would, if I thought calling system would be easier
07:29:13 * hackagebot json-assertions 1.0.2 - Test that your (Aeson) JSON encoding matches your expectations  http://hackage.haskell.org/package/json-assertions-1.0.2 (OliverCharles)
07:29:33 <quicksilver> write a sed script which outputs haskell code!
07:29:44 <merijn> Right now I decided on the following beauty
07:29:47 <tdammers> then feed that to node.js and complain that it doesn't work
07:29:48 <merijn> "((_:_:num_edges:_):_:(_:_:num_vertices:_):_) <- map (map read . words) . lines <$> readFile meta"
07:30:25 <merijn> Read it and weep
07:30:47 <tdammers> looks like the exact kind of thing I'd use a shell script for
07:31:32 <tdammers> walk through file line by line, split into words, extract 3rd word of first and third line
07:31:34 <merijn> tdammers: Right, except I can't call opencl from bash >.>
07:31:50 <tdammers> ah
07:31:56 <tdammers> I was assuming a text file somewhere
07:34:14 * hackagebot digestive-functors-aeson 1.1.6 - Run digestive-functors forms against JSON  http://hackage.haskell.org/package/digestive-functors-aeson-1.1.6 (OliverCharles)
07:34:33 <mr-> num_edges? I thought haskellers would have written numEdges..
07:35:30 <makalu> why is there no built-in function for waiting after threads?
07:36:08 <merijn> mr-: Because I'm transliterating some C code
07:36:25 <quicksilver> makalu: because there are MVars.
07:37:15 <makalu> I can use MVars but there should be a function that already does this
07:37:58 <mr-> makalu: maybe you want to use something higher level, like async?
07:38:02 <monochrom> in fact, don't even use threads by hand. use the async package
07:38:17 <monochrom> it comes with Haskell Platform
07:38:41 <Lethalman> makalu, maybe http://hackage.haskell.org/package/threads
07:39:31 <mzero> no, you don't want threads
07:39:48 <makalu> yes async, that's nice. Thank you.
07:41:21 <merijn> hmm, when compiling chs code I see lots of variable shadowing warnings which, as far as I can tell, don't involve any actual shadowing...
07:42:30 <monochrom> turn off all warnings :)
07:43:46 <merijn> That seems...counterproductive
07:44:48 <monochrom> yeah, it produces fewer warnings. imagine you're paid by the number of warnings you produce... :)
07:45:28 <merijn> My question was more: Why does it produce wrong warnings?
07:46:33 <monochrom> it seems unlikely that the compiler is wrong there. you may be misreading the code.
07:48:09 <merijn> monochrom: Well, I don't suspect ghc to be wrong, I expect c2hs to be wrong
07:49:01 <makalu> if I use ldd on a ghc produced binary, I should see libgmp?
07:49:11 <merijn> As it warns about shadowing variables in the same file, even though the variable mentioned only occurs once in the entire file
07:49:43 <c_wraith> makalu: yes, GHC produces binaries that depend on libgmp
07:51:26 <merijn> monochrom: c2hs appears to be inserting lambda's or whatever with variable names that clash with my own >.>
07:52:13 <monochrom> that is very appalling
07:53:03 <merijn> I used "ptr" as variable in my peek/poke implementations and they were being shadowed by c2hs
08:08:00 <klrr_> is "error "foo"" equivalent to "throwIO $ toException "foo""?
08:08:21 <klrr_> in the context of throwing it inside the IO monad
08:08:28 <merijn> klrr_: No
08:08:35 <klrr_> okey
08:08:43 <klrr_> is error un-catchable?
08:08:49 <merijn> klrr_: "error "foo"" can escape due to laziness
08:08:54 <merijn> It's catchable, but can escape
08:09:11 <klrr_> what of the above is most appropriate to use?
08:09:15 <klrr_> if you plan to catch it
08:09:17 <merijn> throwIO is always better
08:09:23 <klrr_> okey, thanks
08:09:28 <merijn> throwIO guarantees your exception can't escape
08:10:31 <c_wraith> it's a matter of timing.  error means the exception will be thrown when the value is evaluated.  throwIO means the exception will be thrown when the IO action is executed.
08:11:27 <c_wraith> Due to GHC's imprecise exception semantics from pure code, it can be quite difficult to figure out exactly when an exception is thrown.
08:11:37 <c_wraith> But from IO, it's pretty easy.
08:12:22 <mzero> why doesn't runhaskell have an option to put the program on the command line? like perl
08:12:45 <c_wraith> ghc has that option
08:12:55 <klrr_> ghc -e iirc
08:12:58 <c_wraith> runhaskell is just a shell script around ghc that sets a few options
08:13:00 <mzero> I want to do     runhaskell  -e "interact $ print . length . words"
08:13:14 <c_wraith> mzero: use ghc instead of runhaskell
08:13:34 <c_wraith> mzero: basically, never use runhaskell ever
08:13:35 <mzero> oh
08:13:46 <ion> c_wraith: #!/usr/bin/env runhaskell
08:14:39 <mzero> woot
08:14:57 <c_wraith> isn't that a type error, though?
08:15:05 <c_wraith> don't you need show instead of print?
08:15:06 <mzero> yes
08:15:12 <klrr_> mzero: cat ./foo | ghc -e "getLine >>= print . (++) \"it works\""
08:15:34 <mzero> it was just an example
08:15:44 <c_wraith> But your example had a type error! :)
08:16:14 <mzero> if all I wante was "interact $ show . length . words" .... i might be better off with wc
08:16:17 <mzero> :-)
08:16:53 <c_wraith> yeah, you should instead do something like "interact $ unwords . map (show . length) . words"
08:18:43 <c_wraith> Err.  That isn't great either, due to buffering issues.  But whatever.
08:19:40 <mzero> ghc -e "import Data.List" -e "import Control.Arrow" -e "interact $ unlines . map (show . (head &&& length)) . group . sort . words"
08:19:54 <mzero> wish there were a better way to handle the imports.....
08:20:12 <enthropy> probably you can put those imports into your .ghci
08:20:13 <klrr_> maybe make a alias for ghc including most common ones?
08:20:31 <mzero> the later makes most sense if one were going to do this alot
08:21:30 <yitz> mzero: ghc -e "import Data.List" -e "import Control.Arrow" -e "interact $ unlines . map (show . (head &&& length)) . group . sort . words"
08:21:36 <yitz> oops one sec
08:22:08 <yitz> mzero: ghc -e "import Data.List; import Control.Arrow; interact $ unlines . map (show . (head &&& length)) . group . sort . words"
08:22:23 <yitz> mzero: there, i'm sure that's great consolation for you
08:23:27 <bsdbeard> Is it possible to write a function that takes two tuples of any size and returns a tuple of size n1+n2?
08:23:34 <yitz> mzero: have you been able to install text-icu (and use it) on mac os x with recent cabal?
08:24:00 <c_wraith> bsdbeard: not without doing a lot of work writing classes to abstract over all the tuple sizes
08:24:13 <bsdbeard> c_wraith, so basically, there's no easy way to do generic programming?
08:24:23 <c_wraith> bsdbeard: sure there is.  Don't use tuples.
08:24:25 <yitz> bsdbeard: there is. just not with tuples.
08:24:27 <klrr_> you dont want tuples
08:24:28 <notdan> use vectors
08:24:32 <bsdbeard> oh
08:25:13 <c_wraith> tuple sizes are limited anyway.
08:25:48 <the_berserker> Why do different Haskell compilers give different error messages?
08:25:56 <c_wraith> On GHC 7.6.3, the max tuple size appears to be 62
08:26:10 <c_wraith> the_berserker: why do gcc and clang give different error messages?
08:26:25 <bsdbeard> because clang uses llvm and gcc does not? :P
08:27:01 <the_berserker> Hugs: "unification would give infinite type"
08:27:16 <the_berserker> GHC "Occurs check: Cannor
08:27:34 <monochrom> do you really want to know why?
08:27:36 <c_wraith> the_berserker: those are the same error.  They're just described with different words
08:27:39 <the_berserker> "GHC: Occurs check: Cannot construct the infinite type"
08:27:58 <the_berserker> monochrom: Why?
08:28:14 <monochrom> because they were written by different authors.
08:28:37 <c_wraith> I thought you were going to talk about something actually different.
08:28:49 <c_wraith> Like code using some GHC extension incorrectly.
08:29:17 <c_wraith> Where the Hugs error says it doesn't have a clue what you mean, and the GHC error says you have a type error.
08:30:39 <bahamas> what's wrong with my patterns here? the compiler says "pattern match(es) are overlapped" for the last two patterns
08:30:42 <bahamas> http://lpaste.net/101709
08:31:14 <c_wraith> bahamas: you can't match on a variable
08:31:23 <c_wraith> bahamas: you just end up rebinding it
08:31:28 <bahamas> c_wraith: ah, the mempty?
08:31:32 <c_wraith> yes
08:31:55 <c_wraith> Any token starting with a lowercase letter in a pattern match is treated as a binding.
08:32:07 <c_wraith> To actually pattern match on the structure, it needs to start with a capital letter
08:32:55 <c_wraith> bahamas: also, if that *did* compile, it'd violate the monoid laws
08:33:07 <bahamas> c_wraith: why?
08:33:16 <bahamas> because of the rebinding?
08:34:02 <thebnq> it doesn't form a monad, 5+x isn't x
08:34:05 <thebnq> monoid*
08:34:09 <thebnq> gosh mixing thoughts
08:34:13 <c_wraith> bahamas: No, because of the associativity law, actually.
08:35:15 <c_wraith> bahamas: (Bilbo 2 <> Bilbo 3) <> Bilbo 7  would not evaluate to the same thing as Bilbo 2 <> (Bilbo 3 <> Bilbo 7)
08:35:24 <c_wraith> bahamas: (where <> is an alternate name for mappend)
08:36:37 <bahamas> c_wraith: I'm confused. are you saying that the problem is with Bilbo 5 as a mempty value?
08:36:39 <bsdbeard> Don't think I've ever seen a type named Bilbo
08:36:51 <bahamas> heh
08:36:52 <c_wraith> bahamas: yes.
08:37:19 <yogert> Can anyone point me to some good resources regarding keeping my development environment "clean"? I find that I run into dependency issues every time I want to install a moderately complex package. Should I not be having these issues, and have simply done something wrong?
08:37:40 <c_wraith> bahamas: if you're writing a Monoid on integers with the operation as (+), the only choice of identity element is 0
08:37:41 <tdammers> yogert: cabal sandbox
08:38:00 <tdammers> yogert: worst case, delete the sandbox and start from scratch
08:38:01 <Eduard_Munteanu> Why does html-conduit require a bytestring as input? That seems wrong because it would have to guess the encoding, no?
08:38:06 <bahamas> c_wraith: ok, but this respects the associativity lawy http://lpaste.net/101709
08:38:18 <bahamas> s/lawy/law/
08:38:25 <tdammers> Eduard_Munteanu: because HTML is essentially bytestring by definition?
08:38:31 <c_wraith> bahamas: does it?  test with the two expressions I listed above
08:39:22 <bahamas> c_wraith: oh. true
08:40:06 <Eduard_Munteanu> tdammers: isn't it arbitrary unicode, and the HTTP headers would specify the encoding? I'd expect Data.Text, rather.
08:40:18 <bahamas> I see your point. in this case, I'm just trying to understand monoids.
08:40:23 <c_wraith> bahamas: the only way you could hack it into being an identity element is to prevent people from constructing two non-mempty values that mappend to the mempty value
08:40:39 <c_wraith> ..  And aren't both mempty already
08:41:24 <c_wraith> bahamas: well, the operations available in a monoid are pretty simple.  the laws *are* the important parts!  :)
08:41:35 <c_wraith> bahamas: they're what make monoids powerful.
08:41:42 <bahamas> c_wraith: yeah. it's the laws that I'm trying to understand or what they're useful for
08:41:45 <Eduard_Munteanu> IOW, unless I can somehow specify the encoding, I expect a HTML parser to read in encoding-independent strings like Text.
08:42:25 <merijn> Eduard_Munteanu: There is no such thing as "arbitrary unicode"
08:42:27 <c_wraith> bahamas: how do you feel about reading papers?  byorgey wrote an excellent paper about his use of monoids in the design of his diagrams library.
08:42:28 <tdammers> Eduard_Munteanu: HTML can be any encoding; user agents are allowed to expect ascii until the encoding is known
08:42:55 <Eduard_Munteanu> merijn: isn't that what String is?
08:42:59 <merijn> Eduard_Munteanu: Basically, what browsers do is parse as whatever default-encoding (usually utf-8) and if they encounter an encoding header, the start over again
08:43:02 <merijn> Eduard_Munteanu: No
08:43:17 <b3tamax> c_wraith: Got a link available? I'd love to see that paper.
08:43:23 <bahamas> c_wraith: I can give it a go
08:43:30 <yogert> tdammers: okay, so if I understand correctly, after I have initialized a sandbox within a folder, all future calls to "cabal install" etc will utilize the sandbox?
08:43:34 <tdammers> Eduard_Munteanu: what you get is just raw bytes. In order to put them in Texts or Strings, you have to know the encoding, but you don't always have that until before you're halfway through parsing the document
08:43:37 <merijn> Eduard_Munteanu: String is a list of unicode codepoints, they have a known (albeit hidden) encoding
08:43:41 <c_wraith> b3tamax bahamas http://www.cis.upenn.edu/~byorgey/pub/monoid-pearl.pdf
08:43:49 <tdammers> yogert: as long as you're inside that directory, yes
08:43:54 <b3tamax> crwaith: Thanks :)
08:44:01 <bahamas> c_wraith: thanks
08:44:10 <shapr> Does anyone make dubstep music with Haskell?
08:44:14 <Eduard_Munteanu> merijn: yes, but String hides the encoding and so does Text even if it uses UTF-16 internally.
08:44:22 <shapr> @seen yaxu
08:44:22 <lambdabot> yaXu
08:44:24 <monochrom> there is, in fact, a standard way to specify, right inside the octet stream, the encoding. and HTML 5 specifies, in full detail, how to read it.
08:44:24 <shapr> psh
08:44:36 <merijn> Eduard_Munteanu: Network connections and files only contain bytes
08:44:37 <Eduard_Munteanu> In contrast, Bytestring are raw streams.
08:44:37 <tdammers> String doesn't have an encoding. It doesn't *need* one, because a Char is a codepoint already.
08:44:43 <c_wraith> shapr: I bet so.  remember that article going around about people live-programming music at shows, and one of the photos clearly showed haskell code?
08:44:43 <monochrom> this, of course, does not contradict that there is also a standard way to specify outside
08:44:57 <shapr> c_wraith: yeah, it's probably yaxu, aka alex
08:45:09 <bahamas> c_wraith: I remember that article as well. I think it was on reddit and the guys were british
08:45:09 <merijn> Eduard_Munteanu: You can't hide an unknown encoding, because you need to know the unicode before you can convert it to a (hidden) encoding
08:45:23 <Fuuzetsu> does someone have the article/photo?
08:45:47 <shapr> I'm almost certain it was this guy: http://yaxu.org/
08:45:52 <merijn> Eduard_Munteanu: Suppose I give you 15 arbitrary bytes, how do you know what to do with them?
08:46:01 <Eduard_Munteanu> If I get  a HTTP result as Text/String, I expect it to have already decoded it according to the headers.
08:46:16 <c_wraith> Fuuzetsu: Hmm.  I can't find it in my browser history instantly
08:46:18 <merijn> Eduard_Munteanu: Which library returns Text/String for HTTP?
08:46:29 <Eduard_Munteanu> merijn: curl can
08:46:48 <shapr> I've been making some music in Ableton Live recently, but I'd like a more code-oriented approach. I used Haskore back in the dawn of time, what are the current Haskell tools for making music?
08:46:49 <merijn> Eduard_Munteanu: Curl just guess based on HTTP headers, but those can be wrongenvironment
08:47:27 <tdammers> Eduard_Munteanu: what does it do for HTTP responses that aren't textual?
08:48:10 <Fuuzetsu> http://www.youtube.com/watch?v=FenTeBMkAsQ first video I found
08:50:57 <bahamas> this looks interesting http://www.cs.yale.edu/homes/hudak/Papers/HSoM.pdf
08:50:58 <Fuuzetsu> that's pretty cool
08:52:50 <hemanth> meow
08:54:52 <hemanth> alcabrera, there? :)
08:55:35 <alcabrera> hemanth: heya. :)
08:55:45 <hemanth> wasup?
08:56:02 <alcabrera> meetings left and right, mostly. It's a busy day, heh.
08:56:23 <tdammers> aaaah, meetings... the modern plague that will bring our civilization to a grinding halt...
08:57:02 <hemanth> alcabrera, oh oh, ok! Will try and create a draft
08:57:33 <alcabrera> tdammers: oh yes, 30 minutes at a time. ;)
08:57:54 <alcabrera> hemanth: thanks! I'll make some time and respond via email
08:58:11 <shapr> Whoa, yaxu's Tidal looks like exactly the sort of thing I want http://kindohm.com/posts/2013/12/02/live-coding-with-tidal/
08:58:31 <tdammers> if you want to get things done, my stance is that acceptable time frames for meetings are:
08:58:39 <tdammers> a) less than 3 minutes
08:58:42 <yitz> shapr: euterpea is the modern version of haskore
08:58:42 <tdammers> b) more than two weeks
08:59:00 <yitz> shapr: you are an op
08:59:07 <hemanth> kool, thanks alcabrera :)
08:59:08 <shapr> I am? AWESOME! I HAVE THE POWER!
08:59:14 <shapr> yitz: is it bad for me to be an op?
08:59:17 <c_wraith> oh no.  shapr has the power
08:59:22 --- mode: shapr set +o c_wraith
08:59:36 <yitz> shapr: as long as you're careful about what you type. kind of like being root.
08:59:36 <tdammers> "with great power comes great responsibility"
08:59:44 <yitz> exactly
08:59:49 <shapr> You mean, I might accidentally kick myself off the channel?
08:59:52 --- kick: shapr was kicked by shapr (Kicked by shapr)
08:59:58 <tdammers> oink
08:59:59 <yitz> heh
09:00:02 <c_wraith> how often do you accidentally type /ban c_wraith ?
09:00:03 <shapr> Ok, now I'm not an op.
09:00:11 <haasn> And that is how curiosity killed the op
09:00:13 <tdammers> told you so
09:02:19 <shapr> Tidal looks really cool: https://github.com/yaxu/Tidal/blob/master/doc/tidal.md
09:02:24 <byorgey> I bet shapr has been an op longer than most people here have even been using IRC =)
09:02:42 <byorgey> shapr: yeah, yaxu does some really awesome stuff with it
09:02:48 <byorgey> I've never had time to try out tidal myself
09:03:07 <shapr> byorgey: You are probably correct, I was an op on #python on EFNet in the mid 90s
09:03:42 <c_wraith> byorgey: isn't that a bit axiomatic?  I mean, didn't shapr found this version of this channel?
09:04:00 <byorgey> c_wraith: no, and yes
09:04:18 <merijn> c_wraith: He said using IRC, not "using the #haskell channel"
09:04:24 <byorgey> precisely
09:04:25 <c_wraith> also, I only just realized shapr gave me ops before kicking himself.  The things I'm oblivious to!
09:04:27 <yitz> shapr: tidal is very different than haskore. if that's what you wnat - great. if you want something more like haskore, you probaby want euterpea, and probably with some modifications that mzero made recently.
09:04:34 --- mode: c_wraith set -o c_wraith
09:04:38 <merijn> c_wraith: Implication, this channel has existed longer than most people in it have used IRC
09:04:55 * shapr hires merijn as his proof assistant
09:05:22 <c_wraith> merijn: are we working over the set of all people, or merely the set of people who have used IRC?
09:05:27 <merijn> c_wraith: I once woke up and found myself opped in #haskell, I promptly went mad with power and decided to deop for my own safety :p
09:05:27 <shapr> yitz: I just want to make music, and a full Ableton Live setup is $1200 USD, where a Haskell lib is instead affordable and familiar.
09:05:45 <merijn> c_wraith: The set of people currently in #haskell, as far as I understood
09:06:09 <merijn> shapr: A cheap guitar is affordable and less likely to result in yak shaving :p
09:06:09 <shapr> yitz: I'm not picky about the approach, I'd just like to know about the best Haskell music tools available this year :-)
09:06:26 <shapr> merijn: Eh, I can play guitar, and I have a cheap guitar. It's fun, but I want to try making dubstep.
09:06:31 <merijn> shapr: However, should you enjoy yak shaving, I have a few herds :p
09:06:44 * monochrom suggests using a tautology to help make the statement correct :)
09:06:45 <c_wraith> shapr: now I want you to create dubstep with an acoustic guitar.
09:06:52 <shapr> c_wraith: you're mean
09:06:58 <shapr> :-P
09:07:41 <shapr> c_wraith: I have not yet reached that level of working against my constraints
09:08:21 <shapr> c_wraith: Have you tried making music with Haskell?
09:08:23 <c_wraith> I'm just imagining a drop on acoustic guitar, and giggling to myself.  It's a good thing no one's around.
09:08:37 <shapr> do it! make a youtube video! You'll be famous for ten minutes!
09:08:49 <c_wraith> shapr: negative. As much as I enjoy music, I'm pretty bad with the creation of it.
09:09:44 <Fuuzetsu> create a program that does it for you
09:09:44 <yitz> c_wraith: one of my kids dropped my acoustic guitar. i did not giggle.
09:11:28 <yitz> shapr is not picky about the approach because shapr wants to use haskell instead of a guitar
09:11:36 <shapr> pretty much
09:11:52 <merijn> c_wraith: Drops work pretty well on piano :p
09:11:56 <Fuuzetsu> @faq Can Haskell be dropped by yitz's kids?
09:11:56 <lambdabot> The answer is: Yes! Haskell can do that.
09:12:09 <shapr> I haven't written much Haskell in the past year or two, so I want to get back into Haskell some while learning to make music.
09:12:45 <c_wraith> shapr: you going to go all modern-haskell on it?  music lenses!
09:12:57 <shapr> hadn't considered that, but it's a good idea!
09:14:01 <merijn> c_wraith: She plays some pretty awesome dubstep on piano covers: https://www.youtube.com/channel/UCl3iv3eEOtZ0l5nb_jHKYwg
09:14:47 <c_wraith> merijn: wow, she's good
09:16:34 <yogert> Should using cabal require sudo? Or are the permissions on the index file messed up?
09:16:49 <merijn> yogert: Needing to sudo cabal is a sign you messed something up
09:16:52 <c_wraith> yogert: if you use sudo with cabal, you've probably messed up your permissions
09:17:05 <yogert> okay good to know, thanks.
09:17:14 <merijn> yogert: By default cabal should work user-local <3
09:17:54 <yogert> okay, well I'll try to fix the permissions and see how it goes. thanks! : )
09:19:13 <chirpsalot> shapr: I'm assuming you have seen Haskell School of Music?
09:19:45 <shapr> chirpsalot: Yes, Haskell School of Expression was my first Haskell book.
09:20:22 <shapr> I really enjoyed Haskore, but things have changed much since then.
09:20:32 <chirpsalot> shapr: ah. Have you gone through School of Music? How did you find it?
09:20:56 <ion> Does Hackage build documentation for candidate packages?
09:21:22 <shapr> chirpsalot: It was great! But I don't think it's been updated since publication in 2000
09:21:45 <ion> merijn: Nice piano covers.
09:21:45 <shapr> edwardk: Did I leave my copy of Okasaki's PFDS with you? I still have your copy of Death March
09:21:49 <chirpsalot> shapr: ah, is it that old? I assume much has changed in 14 years? :P
09:22:02 <edwardk> shapr: probably
09:22:34 <edwardk> shapr: send me an address, i'll amazon a copy to you =P
09:22:43 <shapr> edwardk: ok!
09:22:52 <shapr> I can mail Death March back to you.
09:22:56 <edwardk> meh
09:23:08 <edwardk> read it, internalized it way back when, keep it =)
09:23:15 <shapr> heh, thanks :-)
09:23:26 <shapr> In that case, I'll send you a surprise interesting book instead.
09:23:33 <edwardk> i got rid of all the fluffy books on my technology shelves
09:23:51 <shapr> So you want something like Coxeter's Introduction to Geometry?
09:24:13 <edwardk> i have everything coxeter ever wrote
09:24:31 <shapr> edwardk: srsly? Do you have a physical copy of his 'Introduction to Geometry' ?
09:24:35 <edwardk> including some pretty obscure stuff i used in a thesis =)
09:24:51 <shapr> Wow, which stuff? Some of his polytopes writing?
09:24:58 <chirpsalot> What's with Haskell people and differential geometry?
09:25:17 <chirpsalot> Seems a lot of people have been talking about it :O
09:25:23 <shapr> chirpsalot: Haskore and the other SoE libraries have been rewritten at least once since it was published.
09:25:31 <edwardk> shapr: he was the best reference i had into the mind of eduard study back when i was doing plucker/study coordinates
09:25:47 <shapr> iirc, dcoutts and others rewrote the graphical libraries to work with gtk2
09:26:00 <shapr> and Henning Thieleman rewrote Haskore to do way more and different stuff
09:26:20 <chirpsalot> shapr: I thought Sound of Music was made by the same person, but used a different library... Maybe I am wrong.
09:26:54 <edwardk> i actually don't have his dover polytopes book, but they never did much for me.
09:27:10 <edwardk> so i guess my claim of having _everything_ he wrote is voided ;)
09:27:12 <chirpsalot> shapr: Euterpea or something?
09:27:37 <shapr> edwardk: Got any tips on getting into Schläfli's work? His main writings are only in German.
09:28:16 <edwardk> shapr: nada. i kind of never cared about regular polytopes
09:28:17 <shapr> chirpsalot: I hadn't heard of that! Yes, Hudak did School of Music!
09:28:41 <shapr> edwardk: I could amazon you one just to complete your collection :-P
09:29:33 <chirpsalot> shapr: "This current book is a rewrite of The Haskell School of Expression with a focus on computer music, based on, and greatly improving upon, the ideas in Haskore and HasSound. The new Haskell library that incorporates all of this is called Euterpea."
09:29:41 <shapr> Wow, nifty! I want one!
09:29:48 <shapr> chirpsalot: that's a great find, thanks!
09:30:14 <chirpsalot> shapr: link: http://www.cs.yale.edu/homes/hudak/Papers/HSoM.pdf
09:30:45 <chirpsalot> Although you said you had already read it? So I guess this isn't useful XD.
09:30:52 <chirpsalot> I'm confused.
09:31:23 <shapr> chirpsalot: No, I read Haskell School of Expression back in the early 2000s right after it was published.
09:31:31 <chirpsalot> shapr: ooooooh, okay.
09:31:38 <chirpsalot> shapr: well there you go :D!
09:31:41 <shapr> hurrah!
09:32:14 <chirpsalot> I don't think there is a version of School of Expression online, but apparently School of Music is and is free?
09:32:36 <shapr> that's awesome!
09:32:38 <haasn> @ask roconnor Any plans on adding BT.2020 support to colour? Especially with regards to their constant luminance encoding system, which is a major deviation from the colormatrices used by previous systems (BT.601s, BT.709, BT.2020 non-constant luminance system)
09:32:38 <lambdabot> Consider it noted.
09:33:53 <chirpsalot> shapr: yeah. I have been meaning to go through HSoM, but I'm not much of a music person (don't really care for it at all to be honest), so I am not sure if it will be the book for me, but it seems interesting...
09:34:14 <chirpsalot> Lemme know if you read it / find it good?
09:34:14 <shapr> What do you care for?
09:34:28 <shapr> mathy?
09:34:35 <chirpsalot> shapr: math is cool!
09:34:47 <chirpsalot> I'm bad at it sometimes :[
09:35:30 <shapr> chirpsalot: Have you seen the Haskell Road to Logic and Maths?
09:35:31 <chirpsalot> E.g., my confusion at differential geometry (hence wondering why all of the Haskell people seem to be talking about it recently)
09:35:38 <chirpsalot> shapr: no, I haven't.
09:35:52 <shapr> You may enjoy that book.
09:36:09 <shapr> I just really enjoy geometry, and have since I was a child.
09:36:48 <chirpsalot> shapr: differential geometry seems really cool, but the class I am in isn't really doing it for me.
09:37:02 <chirpsalot> And I'm like "WHY ARE WE MAKING COORDINATE CHARTS!?"
09:37:13 <chirpsalot> I hope to have a better experience with it later :P.
09:37:33 <shapr> I've never had any college courses on geometry, I just enjoy reading about it.
09:38:14 <chirpsalot> shapr: that's probably the way to go. In fact that is pretty much always the way to go.
09:40:06 <chirpsalot> shapr: when I'm working through it on my own it's enjoyable... But then the actual class isn't so enjoyable. Plus I think I need more "real world" examples to really solidify this stuff in my head... I dunno.
09:40:11 <ystael> chirpsalot: differential geometry has an unpleasantly large amount of machinery to swallow up front, that's part of the problem
09:40:29 <shapr> I enjoy learning about machinery as long as it's well motivated.
09:41:41 <bahamas> where can you put a class constraint? class declaration, instance declaration, function type declaration. anywhere else?
09:42:03 <bahamas> I tried using it with newtype, but I got an error
09:42:26 <awestroke> a newtype is not a class
09:42:37 <bahamas> awestroke: I know
09:42:59 <bahamas> awestroke: I wanted to make a constraint on a type used in a value constructor
09:43:01 <awestroke> bahamas: what's your current definition?
09:43:22 <ystael> shapr: I spent a long time thinking algebraic topology was boring and tedious for that reason, but then somebody told me about homotopy type theory :)
09:43:22 <bahamas> awestroke: newtype Product a = Product {getProduct :: a}
09:43:36 <shapr> ystael: it's HoTT :-)
09:43:44 <bahamas> awestroke: I was thinking of limiting a to (Num a)
09:43:55 <chirpsalot> ystael: maybe that's my problem. My course uses this book: http://www.math.ethz.ch/~salamon/PREPRINTS/diffgeo.pdf which maybe isn't the best? If anybody has any suggestions for notes / books I wouldn't complain :P.
09:44:11 <shapr> I was thoroughly excited to be able to think of values as a continuum instead of just separate chunks in a set.
09:45:01 <ystael> chirpsalot: that's fairly stiff for a semester course - have you seen manifolds before this?
09:45:14 <chirpsalot> ystael: nope!
09:45:14 <awestroke> bahamas: http://stackoverflow.com/questions/7438600/datatypecontexts-deprecated-in-latest-ghc-why
09:46:18 <ystael> chirpsalot: My first recommendation for differential geometry is always Spivak's Comprehensive Introduction.  Volume I covers the basic material on manifolds, volume II the fundamentals of connections, both with lots of concrete examples.
09:46:25 <ystael> I suppose for further discussion we should take this to ##math :)
09:47:05 <chirpsalot> ystael: oh, yeah. Sorry. I'm in ##math. Also pm is fine? Thanks, though. I'll look into it.
09:48:31 <awestroke> bahamas: for example, the Complex datatype would probably have used a RealFloat a constraint in the type def if it was possible: http://hackage.haskell.org/package/base-4.6.0.1/docs/src/Data-Complex.html#Complex
09:48:32 <bahamas> awestroke: aha. I didn't know you could use "where" with "data"
09:49:26 <bahamas> awestroke: so is it safe to assume that in general you put these constraints on the functions that deal with the type?
09:49:44 <awestroke> bahamas: yes, I think so
09:49:53 <awestroke> only constrain the input if you need to
09:51:06 <yogert> Ok, so I've started using cabal sandbox for this project, installed the need dependencies, but now when I try using cabal repl, I get a linker error. In the past I've messed around with ghc-pkg to fix these errors, but I'm not clear how I would do it with the sandbox
09:51:07 <bahamas> GADT is interesting
09:51:48 <bahamas> I kind of like the fact that it's explicit
09:51:50 <fizbin> In a cabal file, when writing a test-suite, is there any good way to avoid duplicating the build-depends section from your library?
09:52:28 <bahamas> awestroke: any disadvantages to using GADT?
09:52:49 <merijn> bahamas: Not portable to other haskell compilers (this isn't really an objection to them, though)
09:53:30 <Krakarn> I'm trying to install sdl2 through cabal but it complains about not finding pkg-config; but pkg-config is my path. Have searched all over on google for solutions and tried a lot of weird things, anyone had the same problem?
09:54:08 <bahamas> merijn: are other compilers as prevalent as ghc?
09:54:13 <fizbin> yogert: Usually in that case I assume the sandbox is corrupt, nuke it, and recreate it. Did you create the sandbox and then get into this, or did you have some different versions of some libraries in the sandbox?
09:54:19 <merijn> bahamas: No
09:54:31 * hackagebot fdo-notify 0.3 - Desktop Notifications client  http://hackage.haskell.org/package/fdo-notify-0.3 (MaxRabkin)
09:54:34 <merijn> bahamas: I don't think there's a serious competitor for production use, so I wouldn't worry :)
09:54:51 <Okasu> fizbin: You don't have to specify dependencies for your library in you test suit, you only need to specify dependencies for your test suit there.
09:54:59 <awestroke> are things like {-# LANGUAGE TemplateHaskell #-} portable?
09:55:07 <merijn> awestroke: Nope
09:55:29 <fizbin> bahamas: I personally find GADTs more difficult to read in most cases, and would find it confusing to see GADTs where they weren't necessary.
09:55:52 <merijn> awestroke, bahamas: The basic logic is that by default GHC follows the haskell report (well, not entirely, there's some minor deviations) and the report is (on purpose) a bit backwards and conservative to function as implementation target for other compilers
09:56:03 <bahamas> being able to add a class constraint for the parameter passed to a value constructor would cut down on a lot of repetition
09:56:04 <DR6> I think GADT syntax is clearer than normal ADTs syntax
09:56:23 <shapr> yitz: Do you have any Haskell-produced music online?
09:56:30 <bahamas> DR6: that's my feeling as well, after seeing GADT
09:56:36 <merijn> awestroke, bahamas: Any extensions that go beyond the Haskell Report need to be explicitly turned on in GHC (using either -X flags or LANGUAGE pragma), so that you don't "accidentally" write unportable code
09:56:50 <bahamas> fizbin: seeing the type declaration makes it more obvious to me that the constructors are functions
09:56:57 <merijn> However, if you only care about production code (and thus most likely GHC) extensions aren't something to worry about
09:57:04 <fizbin> Okasu: Then I think I must be doing something wrong, because cabal wants to recompile my whole library into my test suite.
09:57:08 <solrize> is tekmo around here much these days?
09:57:24 <merijn> solrize: He shows up occasionally, but he's not always on IRC
09:57:32 <solrize> thanks
09:57:45 <merijn> solrize: He's pretty responsive on reddit and his mailing lists
09:57:49 <fizbin> I'm trying to follow the guide here: http://lambda.jstolarek.com/2012/10/code-testing-in-haskell/ and in that guide, the sources used in the test-suite are a superset of the sources used in the library.
09:58:02 <solrize> merijn, thanks, i don't have accounts on those
09:58:14 <fizbin> I don't quite understand how to have it not be that way.
09:58:19 <merijn> solrize: You don't need an account for mailing list, you can just email :)
09:59:01 <fizbin> Especially since at this point I just want anything, and don't want to deal yet with the fact that "test code" and "library code" are all comingled in the same source tree.
09:59:19 <solrize> merijn i use a craptacular self-hosted email scheme that makes mailing lists pretty much impractical for me.  i may set up something better sometime but the whole concept of mailing lists seems kind of lame
09:59:46 <Okasu> fizbin: If your test suite depends on your library you can include in build-depends name of your library.
10:00:16 <Fuuzetsu> are there test suites which don't depend on library (that aren't just the ‘throw shit at executable’ type)
10:00:30 <fizbin> Ah. So I guess I need a library name, since right now my cabal file just says "library".
10:00:46 <merijn> fizbin: library name is whatever you set as package name
10:00:54 <Okasu> fizbin: ^
10:01:15 <Fuuzetsu> I'm tempted to snatch the name ‘library’ up.
10:01:35 <awestroke> what does '' mean in templatehaskell? like makeLenses ''MyType
10:01:52 <edwardk> it converts the type to a template haskell "Name"
10:02:16 <edwardk> it expands out to the name of the type including the module it comes from, etc.
10:02:35 <edwardk> with a single quote you get it for a term
10:02:39 <awestroke> edwardk: so makeLenses is automatically expanded without $() ?
10:02:40 <monochrom> Fuuzetsu: consider "acme-library" :)
10:02:49 <edwardk> awestroke: you don't need $() any more
10:02:56 <awestroke> oh
10:03:06 <edwardk> awestroke: at t the top level it is unambiguous
10:03:09 <edwardk> er at the
10:06:04 <Fuuzetsu> monochrom: boring!
10:06:41 <pome> hi - quick question. i'm writing a report and i'm struggling to remember the name for the '@' notation - is there a generally accepted term?
10:06:51 <artyomkazak> as-pattern?
10:07:00 <edwardk> as patterns
10:07:02 <fizbin> merijn, Okasu: This isn't working, and cabal is still trying to build the library into the test suite. I think the tutorial I was looking at may have led me astray. I'm going to start by separating out my tests and non-test code into separate "src" and "tests" trees and then see where we are. I wish there were a way to say
10:07:05 <pome> perfect, thanks guys
10:07:06 <davidfetter_disq> so i'm not sure whether here is good for this question, but i'll ask it anyhow
10:07:09 <edwardk> not at-patterns as you might expect
10:07:17 <pome> i was googling 'as notations' but couldn't find anything
10:07:24 <pome> edwardk: yeah, i tried 'at notation' too ha
10:07:24 <Fuuzetsu> fizbin: look at existing projects with such setup
10:07:28 <Fuuzetsu> it's the easiest thing to do
10:07:33 <davidfetter_disq> is there a way to turn a yacc grammar into a principled tab-completion?
10:08:05 <fizbin> I wish there were a way to say in a cabal file "the dependencies you needed for that library and then also these other test-framework and test-framework-hunit"
10:08:05 <davidfetter_disq> (vs. the hacky list-driven stuff that remembers some fixed number of tokens backwards for context)
10:08:12 <edwardk> davidfetter_disq: not with stock tools but it can be done in theory
10:08:30 <Fuuzetsu> fizbin: but you can, in test-suite section
10:08:39 <edwardk> i do it for various recursive descent parsers, nothing stops the same thing from working with a standard LALR grammar
10:08:45 <davidfetter_disq> edwardk, oh, fascinating. what theories should i be studying, and where has someone actually attempted this?
10:09:19 <davidfetter_disq> this came out of my frustration with making psql actually work in cases people expect
10:09:34 <Fuuzetsu> fizbin: https://github.com/Fuuzetsu/haddock/blob/master/haddock.cabal#L221
10:09:38 <davidfetter_disq> ...and my discovery that nothing else in the business does what i thought was the obvious right thing
10:10:17 <edwardk> my usual recommendation would be to turn the grammar around to get a recursive descent rather than a yacc style grammar, then parse left to right. then the completions are easier. that is why c#, etc. are custom recursive descent parsers
10:10:23 <fizbin> Fuuzetsu: That doesn't say what I was asking for,
10:10:41 <Fuuzetsu> okay then, I'm not sure what you're asking for
10:10:41 <Fuuzetsu> afk
10:10:52 <davidfetter_disq> if there's an automated way to do that quickly, i suspect i'll have an easier time
10:11:05 <fizbin> Fuuzetsu: At least, I don't think it does. Hrm. I'm actually having trouble figuring out what it's saying then.
10:11:09 <edwardk> sadly nope. it requires understanding the grammar pretty well
10:11:27 <davidfetter_disq> if the pitch is, "stop using yacc and start using a custom recursive-descent parser," i'm going to lose before i start
10:11:39 <edwardk> i'd google LALR vs LL(*) happy/yacc vs parser combinators and recursive descent
10:11:45 <edwardk> yeah you'll lose
10:11:56 <fizbin> Fuuzetsu: Why the multipl build-depends: lines? What does that mean, as opposed to having just one?
10:12:24 <edwardk> i can help more later, but i'm buried at the moment
10:12:34 <davidfetter_disq> thanks for your help so far :)
10:13:30 <Fuuzetsu> fizbin: no difference AFAIK, must have been a style thing
10:13:48 <davidfetter_disq> the PostgreSQL version of the SQL grammar was so huge we had to patch bison
10:13:48 <davidfetter_disq> it's only gotten bigger
10:15:42 <colDrMcBeardman> davidfetter_disq, what did you have to change in bison? just size constants or something more complicated?
10:18:11 <fizbin> Fuuzetsu: Okay, then I really don't understand what's going on with my code.
10:19:34 * hackagebot quadratic-irrational 0.0.2 - An implementation of quadratic irrationals  http://hackage.haskell.org/package/quadratic-irrational-0.0.2 (ion)
10:19:52 <fizbin> I think I'm going to clone haddock and see how it breaks when I tweak those build-depends.
10:27:13 <fizbin> Fuuzetsu: I can't test this by mangling Haddock because it doesn't like my ghc version, apparently.
10:31:09 <davidfetter_disq> colDrMcBeardman, this happened back in the late 1990s, and it was some size constants, yes.
10:35:40 <yogert> With cabal repl can I load files that aren't exposed in my .cabal file?
10:35:52 <yogert> I doesn't look like I can...
10:36:04 <yogert> Using :l filename that is
10:37:36 <Fuuzetsu> fizbin: it was just an example project, you can look at any others
10:37:48 <Fuuzetsu> I know edwardk's projects have quite a few tests set up so maybe try those
10:38:45 <fizbin> Fuuzetsu: Well, the first I looked at next was lens, but it does the clean source separation thing where the test-suite's hs-source-dirs are distinct from the source dirs for the library
10:39:16 <Fuuzetsu> oh, Haddock does that too; why aren't you doing that?
10:39:19 <Fuuzetsu> maybe I missed some info
10:39:30 <fizbin> Haddock doesn't do that though.
10:39:38 <Fuuzetsu> I'm confused ;P
10:39:49 <Fuuzetsu> all our test stuff is in html-test or latex-test or spec-test
10:39:58 <Fuuzetsu> and the actual source is at src/
10:39:59 <fizbin> Look at its cabal file, the hs-source-dirs: for the test-suite includes both "test" and "src"
10:40:50 <fizbin> See on line 227?
10:41:04 <Fuuzetsu> I _think_ we could actually remove that but I'm unsure
10:41:39 <MagneticDuck> 1234 users!
10:41:41 <MagneticDuck> wonderful
10:41:56 * Fuuzetsu parts
10:43:40 <fizbin> But here's what I don't understand: how is it that Cabal doesn't then try to compile everything in src with that cabal file? Because that seems to be what it's doing for my code - it's compiling the library, then the code for the test suite, and when compiling the code for the test suite it recompiles some of the library code and complains that I'm missing a dependency on something that library code depends on.
10:44:04 <bennofs> Is undefined actually a type in GHC?
10:44:09 <bennofs> :t undefined :: undefined
10:44:09 <fizbin> I don't understand why cabal is trying to recompile modules of mine that are in the library.
10:44:10 <lambdabot> undefined
10:44:23 <Fuuzetsu> fizbin: can we see your cabal file and code perhaps?
10:44:39 <geekosaur> bennofs: `undefined` is a type variable there
10:44:41 <quchen> :t id :: undefined -> undefined -- bennofs
10:44:42 <lambdabot> undefined -> undefined
10:44:45 <geekosaur> types start with uppercase
10:44:51 <Fuuzetsu> also if your testsuite uses some external libraries, you have to put those in build-depends in the test-suite section
10:45:04 <fizbin> Fuuzetsu: Not yet. I'm going to start a new project from scratch to see if I can get myself in the same mess.
10:45:16 <bennofs> geekosaur: ah, thanks.
10:45:41 <geekosaur> so a type undefined -> undefined is the same as a -> a, provided both are free
10:45:55 <geekosaur> (that is, not fixed by something elsewhere in the type)
10:47:59 <b3tamax> Anyone got a good reference paper on the dangers of three-legged logic? ( I.e. True / False / Null ) Trying to convince a co-worker but I can't quite get him to read the book I read the best arguments from.
10:51:16 <mmmm> How do you use the lambabot pl feature?
10:51:17 <Fuuzetsu> just have him write Java for a daya
10:51:26 <Fuuzetsu> mmmm: @pl codehere
10:58:00 <bennofs> :t let f a m = m >>= \(a', b, mr) -> maybe (f a' m & mapped._1 %~ ((a,b):)) (return . ([(a,b)], a',)) mr in f#
10:58:01 <lambdabot>     Not in scope: `f#'
10:58:01 <lambdabot>     Perhaps you meant one of these:
10:58:01 <lambdabot>       `f' (line 1), `f' (line 145),
10:58:02 <bennofs> :t let f a m = m >>= \(a', b, mr) -> maybe (f a' m & mapped._1 %~ ((a,b):)) (return . ([(a,b)], a',)) mr in f
10:58:03 <lambdabot> (Monad m, Functor m) => t -> m (t, t1, Maybe a) -> m ([(t, t1)], t, a)
10:58:22 <colDrMcBeardman> is there another way to write a chain of <$> in a do-block?
10:58:54 <quicksilver> colDrMcBeardman: well, f <$> ( g <$> ( h <$> x )) is the same as (f.g.h) <$> x
10:59:02 <quicksilver> colDrMcBeardman: if that's what you mean?
10:59:26 <colDrMcBeardman> aha! I knew I was forgetting something simple.
11:00:08 <johnw> aka, the second functor law :)
11:01:20 <bennofs> Is there an easier way to do this?
11:01:22 <bennofs> :t let f a m = m >>= \(a', b, mr) -> maybe (f a' m & mapped._1 %~ ((a,b):)) (return . ([(a,b)], a',)) mr in f
11:01:23 <lambdabot> (Monad m, Functor m) => t -> m (t, t1, Maybe a) -> m ([(t, t1)], t, a)
11:03:27 <bennofs> That function takes a starting value, a, and a monadic action. The b value from the monadic action is matched with the a value of the previous iteration. If the action returns Just a result, then the iteration is aborted and the last a and the result is returned
11:09:57 <quchen> It's more than 80 characters in one line. There is an easier way to do this, or at least a more readable one.
11:10:22 <quchen> (I can read maybe a third of it without losing track of the rest) :-/
11:10:31 <cdk_> does compiling with -threaded have any effect on the execution time of purely sequential programs?
11:10:41 <quchen> cdk_: No.
11:10:43 <quicksilver> yes, probably, cdk_
11:10:47 <quchen> Yes?
11:10:49 <quicksilver> it invokes a completely different RTS
11:10:52 <quicksilver> including a different GC
11:11:00 <c_wraith> and different IO handling
11:11:03 <quicksilver> it would be surprising if everything worked out the same.
11:11:16 <quicksilver> it shouldn't be a significant problem though.
11:11:16 <c_wraith> It probably will perform better in some cases, worse in others.
11:16:06 <dleedev> hi, are monad transformers analogous to web server middleware?
11:16:29 <Fuuzetsu> uhh
11:16:34 <Hafydd> Hahah.
11:16:54 <fizbin> Fuuzetsu: Okay, so check out https://github.com/fizbin/tinytest
11:17:06 <fizbin> That as it is won't compile.
11:17:32 <DR6> dleedev: eh kinda but not really
11:17:39 <DR6> that's at best a metaphor
11:17:46 <fizbin> But if I make the hs-source-dirs: on the test-suite be just "test" instead of "src, test", then it will compile.
11:18:03 <dleedev> DR6: in what way does the metaphor/analogy not stick?
11:18:25 <fizbin> Yet haddock seems fine with hs-source-dirs set to "src, test" without then needing to recompile the universe and have all the build-depends in there.
11:18:26 <DR6> for one, it's not the way you'd do web server middleware on haskell
11:18:33 <DR6> because it changes the type
11:19:07 <fizbin> What I'd like is a way to specify in the test-suite "the build-depends for this test-suite are the same as for the library, and also these other testing modules"
11:19:22 <fizbin> But, as I said before, it appears you can't do that.
11:19:29 * Fuuzetsu clicks
11:20:26 <DR6> monad transformers help mix monads, not values
11:20:31 <fizbin> In a Makefile or an ant script, you could set up some variable to be the list of build-depends for the library and then if that got added to, you'd only need to change it in one spot.
11:20:54 <fizbin> But it seems that cabal doesn't let you do that.
11:20:55 <dleedev> DR6: I basically imagine that every MT bind is like a middleware stack, where input values flow from top to bottom, then output flows from bottom to top
11:21:03 <dleedev> is that a wrong way to think?
11:21:08 <Fuuzetsu> fizbin: no, you can't do that but there should be no need
11:21:27 <Fuuzetsu> if say your test files depend on containers, you have to add it to your build-deps even if your library already does depend on containers
11:21:33 <fizbin> Fuuzetsu: No? What if you want your tests to cover some module internals?
11:21:55 <Fuuzetsu> but if your lib depends on HXT and your test-suite uses HXT types, you need to specify HXT for both
11:22:12 <DR6> most monads don't necessarily have an "input" or a flow of values per se
11:22:13 <Fuuzetsu> fizbin: usually one would have .Internal module and would import that from the test-suite
11:22:26 <Fuuzetsu> it's a convention to not use .Internal modules of libraries
11:22:55 <fizbin> Fuuzetsu: But then you either need to list the Internal module as exposed or rebuild the library when you build your test.
11:23:06 <DR6> a monad transformer enhances monads
11:23:10 <Fuuzetsu> usually you list it as exposed
11:23:11 <dleedev> DR6: but they do necessarily have to pass values from top to bottom, no? even if they’re not doing anything to the values themselves
11:23:12 <DR6> but not necessarily like that
11:23:28 <dleedev> DR6: much like middleware that do only logging, etc, without changing the request or response
11:23:55 <fizbin> How can haddock's test suites compile without having all the build-depends for the library repeated for the test? After all, the hs-source-dirs for haddock's test-suite include "src".
11:24:32 <fizbin> When I include "src" in hs-source-dirs on the test-suite, tinytest fails to compile. When I use only "test" there, it compiles.
11:24:40 <DR6> I'm not sure how far you can get with that metaphor
11:24:54 <Fuuzetsu> actually 2 of those test-suites call the binary
11:25:44 <Fuuzetsu> fizbin: why does it fail to compile? What exactly does it say
11:25:46 <fizbin> Fuuzetsu: Well, fine, that's how they work, but I don't care about that. What I care about is that I can't understand why they don't hit the same kind of compilation errors my tinytest does.
11:25:46 <DR6> does this help you?
11:25:47 <DR6> http://www.cs.virginia.edu/~wh5a/personal/Transformers.pdf
11:26:05 <DR6> it's a paper but it's supposed to be easy to read
11:26:49 <Fuuzetsu> it is pretty easy to read
11:27:03 <Fuuzetsu> it's just presented in scary PDF format so it must only be for those researcher types
11:27:58 <quchen> Most Haskell papers are surprisingly readable.
11:28:10 <quchen> Some of them are even readable.
11:28:59 <fizbin> Fuuzetsu: Added a README to the github project to show the compile error. https://github.com/fizbin/tinytest
11:31:16 <Fuuzetsu> oh, ok, I think I see where you're getting confused and it's probably my fault for using Haddock as an example. The reason this works in Haddock is that it uses minimal number of packages: it ships with GHC so we can't use any external deps so pretty much everything we have already. If we were using external dependencies in library code, we'd have to add those to build-deps in test-suite section too.
11:31:52 <fizbin> Which is my whole complaint: that you need to add new stuff in multiple different places.
11:31:55 <Fuuzetsu> so if you're including src in test-suite, you'll have to add all the dependencies from library to test-suite (+ extra stuff you use for testing)
11:32:00 <bennofs> Maybe cabal could steal the syntax from GHCi, and allow "source deps" for libraries defined in the same file, like "*tinytest" instead of "tinytest"
11:32:51 <Fuuzetsu> fizbin: Right, but as I mentioned, in regular scenario the way we do it is to simply expose all the modules you wish to test (including .Internal ones) and just specify the library itself + test deps in the test-suite section so that you don't have to include src
11:32:57 <bennofs> Also, maybe a custom setup hook could help here?
11:33:08 <Fuuzetsu> and then by convention we don't use .Internal when we work with people's libraries
11:33:35 <Fuuzetsu> so while it'd be nice to be able to do such field duplication, we can't do it at the moment and it's not really that big of a deal
11:33:59 <fizbin> It appears to me that the rule followed is that if a module being compiled imports A.B.C, then first the hs-source-dirs are searched for A/B/C.hs, and only if a source file isn't found are the build-depends searched. It would be nice if that were explicit somewhere.
11:34:14 <bennofs> I think it's a good idea to expose internal modules in general. I hate it when I find a function I need, only to find out that's not exported :|
11:35:08 <fizbin> I'll grant you, that's probably the correct thing to do in terms of "fewer people would be surprised if local source overrides modules in compiled build-depends than the other way around" but it
11:35:18 <fizbin> it's still a bit confusing.
11:35:36 <fizbin> I still don't understand though why haddock is able to compile then.
11:37:56 <Fuuzetsu> fizbin: because the test-suite spec section mentions every build-compile that the module it imports from the library requires
11:37:58 <fizbin> If we look at https://github.com/Fuuzetsu/haddock/blob/master/haddock.cabal#L227 , we see that the test-suite includes "src". Also, if we look at lines 136-146, we see that the build-depends for the library include things like "xhtml" which aren't in the build-depends for the test-suite. (lines 234-241)
11:38:21 <Fuuzetsu> for example, it doesn't import modules dealing with XHTML output so it doesn't need xhtml in build deps as we never touch that part
11:39:07 <Fuuzetsu> if we were to add import Haddock.Backends.Xhtml to the files in the spec test-suite, cabal would complain
11:39:42 <Fuuzetsu> i.e. telling cabal that something is in src dir won't compile everything there, it simply knows where to look where we ask for a module that happens to be there
11:39:57 <Fuuzetsu> when we ask*
11:40:42 <fizbin> Okay. So... cabal compiles everything listed in exposed-modules, other-modules, main-is, and everything those modules import so long as a source file is found for what's been imported.
11:40:51 <Fuuzetsu> it's kind of like adding a NeverUsed.hs file to your project which isn't imported by any module nor is it mentioned in the cabal file
11:41:14 <fizbin> And that file could be line noise, and cabal would still build fine?
11:41:32 <Fuuzetsu> it should
11:41:58 <Fuuzetsu> you could import anything you want there but until you actually try to use it in your project, it's not touched and there's no problem
11:42:01 <Fuuzetsu> I sure hope I'm right ;)
11:42:20 <fizbin> What's the purpose of other-modules then? Shouldn't everything being compiled already be either exposed or imported by something that's exposed?
11:42:49 <bennofs> fizbin: it's for tarball generation
11:42:54 <fizbin> Or is that just an efficiency thing, so that cabal ...
11:42:56 <fizbin> oh.
11:42:57 <Fuuzetsu> I'm not sure what other-modules is for but I'm guessing it's for stuff like cabal sdist so that it knows to bundle the file
11:43:00 <bennofs> fizbin: cabal needs to know which files to include into the source tarball
11:43:11 <Fuuzetsu> hey, I guessed right ;P
11:44:49 <fizbin> bennofs: So... what's extra-source-files for?
11:45:05 <bennofs> i don't know :p
11:45:19 <Fuuzetsu> data files
11:45:43 <fizbin> Fuuzetsu: Um... isn't that what data-files: is for?
11:45:47 <dagano> can i write guards on one line? google is not teaching me
11:46:09 <bennofs> fizbin: data files is for files that should be installed i think (cabal will put them in .../share/...)
11:46:49 <Fuuzetsu> yeah, data files is for stuff that for example you want your executable to use
11:47:09 <fizbin> Okay. Fuuzetsu, should the other two *Spec.hs files be somehow listed in the other-modules clause that begins on line 230?
11:47:15 <Fuuzetsu> extra-source files is extra faff that you want in your tarball but that isn't actual modules
11:48:10 <fizbin> Because I don't understand why Haddock.ParserSpec is there but Haddock.Utf8Spec isn't.
11:48:22 <Fuuzetsu> Hm, maybe. I think we don't run those but that might be by mistake. I'll take a look the next time I do something in that repository.
11:48:32 <Fuuzetsu> Perhaps we just forgot to add it.
11:48:35 <fizbin> Or Haddock.Parser.UtilSpec
11:48:37 <fizbin> ok.
11:50:07 <Fuuzetsu> fizbin: yup, I just checked and the cabal tarball is missing. This doesn't break the build because the hspec finds test files dynamically but it does mean anyone fetching it that way is missing out on some tests. Good catch.
11:50:18 <Fuuzetsu> is missing those files*
11:50:46 <Fuuzetsu> I wish you told me this yesterday, before we made a release…
11:51:42 <fizbin> Unfortunately, yesterday I was fighting the local git server. I didn't start this particular fight with cabal until this morning.
11:54:45 * hackagebot hobbes 0.2.2 - A small file watcher for OSX  http://hackage.haskell.org/package/hobbes-0.2.2 (JasonHickner)
12:01:44 <nadirs> dagano: I tried writing guards on one line and it worked so it seems you can after all ;)
12:02:52 <geekosaur> you can but there are some common pitfalls in doing so (basically people making assumptions that don't hold in Haskell)
12:03:22 <nadirs> geekosaur: I'm interested!
12:03:46 <nadirs> geekosaur: do you have any resource to point?
12:03:55 <geekosaur> well, one I seem to see a lot is that people get the multiline form right but seem to think single line should go foo x = | ...
12:04:34 <Fuuzetsu> is Jose Pedro Magalhaes on IRC?
12:04:41 <Fuuzetsu> oh he is
12:04:45 <Fuuzetsu> dreixel: ping
12:04:58 <nadirs> geekosaur: why is it so?
12:05:07 <geekosaur> why is what so?
12:05:10 <nadirs> (that people think that, I mean)
12:05:15 <geekosaur> I have no idea
12:05:29 <nadirs> haha, misteries of human kind
12:05:32 <Fuuzetsu> @tell dreixel can you bump the upper version of TH for your generic-deriving package to accept TH 2.10.x?
12:05:32 <lambdabot> Consider it noted.
12:05:40 <geekosaur> it's common, it doesn't make a lot of sense to me --- but then I tend to have completely different kinds of syntax blindness from other people
12:06:42 <fizbin> If I have (data MyType) in my code with a derived Enum instance and I have need in my code of "get me all possible values of type MyType", is there a better way to do that than simply adding a derived Bounded instance and doing [minBound..maxBound] ?
12:06:53 <fizbin> I just want to be sure I'm not missing something obvious.
12:08:32 <geekosaur> fizbin, that's probably the easiest way
12:08:33 <Fuuzetsu> that should be fine although your need for all possible values of MyType is questionable depending on what you're trying to do
12:09:47 * hackagebot chatty 0.5.4.2 - Some monad transformers and typeclasses to simplify I/O on a transformer stack.  http://hackage.haskell.org/package/chatty-0.5.4.2 (implementation)
12:09:49 * hackagebot antisplice 0.14.0.3 - An engine for text-based dungeons.  http://hackage.haskell.org/package/antisplice-0.14.0.3 (implementation)
12:09:51 * hackagebot ironforge 0.1.0.28 - A technical demo for Antisplice.  http://hackage.haskell.org/package/ironforge-0.1.0.28 (implementation)
12:09:53 * hackagebot antagonist 0.1.0.15 - A web interface to Antisplice dungeons.  http://hackage.haskell.org/package/antagonist-0.1.0.15 (implementation)
12:11:01 <Kaidelong> does anyone know what version caused gtk2hs' gio project to break?
12:11:49 <Kaidelong> I'm wondering if I can get away with just installing an old version of gio that actually builds
12:18:58 <bl33d> hi
12:18:59 <bl33d> is there a wrap for winapi in haskell?
12:21:49 <geekosaur> win32 / win32-extras?
12:22:18 <geekosaur> hackage doesn't document, probably because it requires stuff to build in order to haddock and it's running linux
12:22:23 <dreixel> Fuuzetsu: I could, but I can't test if it actually works. is this for working with HEAD?
12:27:43 <Kaidelong> okay so Types.chs is a generated file, but what is generating it?
12:32:50 <skypers> hey, I have an Haskell function called foo, I’d like to wrap it in a FunPtr
12:32:51 <skypers> any idea?
12:34:36 <skypers> oh it’s a foreign export?
12:34:50 * hackagebot wai-throttler 0.1.0.1 - Wai middleware for request throttling  http://hackage.haskell.org/package/wai-throttler-0.1.0.1 (mkulkin)
12:38:51 <klrr_> whoever made network-simple, kudos to him. really nice api
12:39:13 <sm> or her
12:39:19 <klrr_> yeah, of course
12:39:57 <klrr_> i really should start using they
12:40:07 <Fuuzetsu> dreixel: yeah it is for HEAD
12:40:18 <skypers> ok hm, I’m using the function glDeleteVertexArrays from OpenGLRaw ; how could I turn that into a FunPtr?
12:40:20 <jle`> fizbin: you can leave off the maxBound
12:40:31 <skypers> do I need to re-foreign import the same symbol?
12:40:56 <dreixel> Fuuzetsu: did you try bumping it, does it compile with HEAD?
12:41:08 <fizbin> jle`: You mean as [minBound..] ?
12:41:09 <Fuuzetsu> dreixel: did not try
12:41:11 <jle`> fizbin: alternatively, enumFrom minBound
12:41:20 <jle`> fizbin: yes
12:41:23 <Fuuzetsu> if you don't have HEAD I can try
12:41:45 <jle`> > [False..]
12:41:46 <lambdabot>  <hint>:1:9: parse error on input `]'
12:41:55 <jle`> what
12:42:11 <Fuuzetsu> > [False .. True]
12:42:11 <jle`> oh yeah
12:42:12 <lambdabot>  [False,True]
12:42:25 <Fuuzetsu> didn't we go through this yesterday
12:42:38 <geekosaur> :)
12:42:51 <Kaidelong> any idea how gtk2hs-buildtools is generating a type named "Int249108103200"?
12:42:51 <Fuuzetsu> dreixel: is there no test-suite?
12:42:57 <Kaidelong> that seems like a lot of bits
12:43:01 <jle`> > [minBound..] :: [Bool]
12:43:02 <lambdabot>  [False,True]
12:43:36 <Kaidelong> mmm, is that the pango version number, actually?
12:43:42 <dreixel> Fuuzetsu: uhm, no, but for now I'd be happy if it just compiles.
12:43:48 <Fuuzetsu> ok one sec
12:43:55 <Fuuzetsu> yeah it does
12:44:25 <dreixel> ok, I'll bump and release
12:44:30 <Fuuzetsu> great!
12:44:51 * hackagebot wai-throttler 0.1.0.2 - Wai middleware for request throttling  http://hackage.haskell.org/package/wai-throttler-0.1.0.2 (mkulkin)
12:45:31 <dreixel> Fuuzetsu: done
12:47:18 <Fuuzetsu> hackagebot sure is slow
12:47:22 <Fuuzetsu> thanks a ton
12:47:33 <dreixel> yw
12:49:30 <prophile> http://bentnib.org/conservation-laws.pdf
12:49:33 <prophile> this is extremely cool
12:49:34 <yogert> Hmm, am i correct in thinking that cabal sandbox ignores the user package repo, but not the global one? It seems to be behaving in an inconsistent manner
12:49:52 * hackagebot generic-deriving 1.6.3 - Generic programming library for generalised deriving.  http://hackage.haskell.org/package/generic-deriving-1.6.3 (JosePedroMagalhaes)
12:49:54 * hackagebot hspec2 0.2.0 - Alpha version of Hspec 2.0  http://hackage.haskell.org/package/hspec2-0.2.0 (SimonHengel)
12:50:03 <Fuuzetsu> yogert: I don't know but if the dependency is not in the sandbox then cabal will look outside of it
12:51:09 <yogert> Fuuzetsu: Well It seems to be doing that in some cases, like when I include transformers for instance, but when I include Persistent it can't find it
12:51:57 <Fuuzetsu> No idea then. I pretty much always do cabal install --only-dependencies first, keeps me sane and my room even warmer
12:51:59 <yogert> Which leads me to think it only looks at the global package pb
12:52:27 <Fuuzetsu> I have like no global package db, pretty sure it's empty
12:52:52 <yogert> What happens when you do that? Does it look through your source code, and finds what needs to be there? Or does it look at the cabal file?
12:53:13 <yogert> cabal install —only-dependencies that is
12:53:18 <Fuuzetsu> do what, --only-dependencies? It installs everything in build-depends into the sandbox
12:53:22 <Fuuzetsu> right
12:53:38 <Fuuzetsu> --enable-tests also advised as it will add everything from test-suite depends too
12:54:27 <Kaidelong> okay so the only explanation I have is that C is somehow coming up with a result of approximately 29 GB as an answer to a "sizeof" question for a type, which can't be right
12:55:26 <yogert> Fuuzetsu: huh, okay, well I'll give that a shot. thanks
12:56:14 <Fuuzetsu> Kaidelong: not much is right in C
12:56:50 <quchen> prophile: Interesting! Although the title made me hope that Noether's theorem had some type-level application, such as conserving the umm charge of a free theorem
12:57:00 <Kaidelong> I think I'll have to talk to one of the gtk2hs devs, but right now I'm being begged for food
12:57:51 <prophile> values don't have a charge, but if they did, expressions would conserve them :)
13:04:36 <yogert> Fuuzetsu: Just so I can better understand the workflow, lets say you want to start a project using a fairly large framework (like yesod), do you reinstall it, and its dependencies, for each project you want to use it in?
13:10:12 <Walther> Hmm, a list comprehension of powers of 2?
13:12:36 <Iceland_jack> > [ 2^i | i <- [0..] ] -- Walther?
13:12:37 <lambdabot>  [1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,2...
13:12:41 <Walther> Iceland_jack: ha, thanks
13:12:44 <Iceland_jack> > map (2^) [0..]
13:12:45 <lambdabot>  [1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,2...
13:13:08 <Iceland_jack> where
13:13:08 <Iceland_jack>     (2^) = (\exp -> 2^exp)
13:13:21 * Eduard_Munteanu sighs... so many libraries use String... :(
13:13:29 <Iceland_jack> Eduard_Munteanu: I feel your pain..
13:13:37 <yogert> what do you mean?
13:13:40 <quchen> > iterate (*2) 1 -- better sharing
13:13:41 <lambdabot>  [1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,2...
13:14:04 <Iceland_jack> > [1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072] -- manual optimization
13:14:05 <lambdabot>  [1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072]
13:15:20 <Eduard_Munteanu> I sort of wish there was an overloaded API for string-like things, instead of committing to ByteString or Text, when possible.
13:15:25 <skypers> hm, newForeignPtr takes a finalizer and a Ptr a, how should the Ptr a be built?
13:15:34 <skypers> with a simple malloca?
13:15:35 <skypers> -a
13:15:44 <skypers> or a newPtr?
13:16:09 <simukis_> skypers: alloca
13:16:26 <skypers> ok, thank you
13:16:34 <Eduard_Munteanu> Although in many cases one of those two choices makes sense and the other doesn't.
13:16:34 <Iceland_jack> Eduard_Munteanu: there have been some attempts, none have caught on
13:16:47 <Iceland_jack> like http://hackage.haskell.org/package/string-class-0.1.5.1/docs/Data-String-Class.html ... ugh
13:16:47 <Iceland_jack>     class (Eq s, Monoid s, IsString s, Typeable s, StringCell (StringCellChar s), StringCell (StringCellAltChar s), ConvGenString s, ConvString s, ConvStrictByteString s, ConvLazyByteString s, ConvText s) => StringCells s where
13:16:51 <skypers> yeah it’s not alloca simukis_
13:17:02 <skypers> if I do that, I’ll invalidate the ForeignPtr
13:17:17 <Eduard_Munteanu> Heh.
13:17:53 <Apocalisp> So, the coproduct of three monoids
13:18:38 <Apocalisp> ((a :+: b) :+: c) is not very satisfying
13:19:20 <Walther> is there anything builtin in prelude that lets me check agains a first digit of an integer?
13:19:32 <haasn> Apocalisp: yeah, it's nothing like the “cycling list of a, b, c” we'd expect
13:19:34 <Iceland_jack> Walther: Check what against it?
13:19:44 <Iceland_jack> You can always do
13:19:44 <Iceland_jack> > head (show 123242) -- Walther
13:19:46 <lambdabot>  '1'
13:19:49 <haasn> other than in a very loose sense
13:19:55 <haasn> but “untangle” almost certainly doesn't make a lot of sense
13:19:56 <Apocalisp> Since rather than be a stream of cycling a, b, and c values, it will be streams of `Either a b` alternating with c.
13:19:56 <Eduard_Munteanu> Apocalisp: the restriction on type operators has been lifted, they don't need to start with ':' anymore, btw
13:19:59 <Walther> Iceland_jack: whee, thanks
13:20:10 <simukis_> skypers: I guess you want `mallocForeignPtr` from Foreign.ForeignPtr.Safe instead of making your own Ptr a and then wrapping it up into ForeignPtr.
13:20:16 <Apocalisp> Eduard_Munteanu: Oh awesome
13:20:30 <Iceland_jack> Walther: If you want to turn it into an Int you can use ‘digitToInt’ from Data.Char
13:20:35 <Iceland_jack> :t digitToInt . head . show
13:20:36 <lambdabot> Show a => a -> Int
13:20:40 <haasn> Eduard_Munteanu: unless they are a promoted constructor? :)
13:20:42 <Iceland_jack> > (digitToInt . head . show) 12345
13:20:43 <lambdabot>  1
13:20:46 <Eduard_Munteanu> On the downside, there are no type variable operators anymore.
13:20:47 <Iceland_jack> > (even . digitToInt . head . show) 12345
13:20:48 <lambdabot>  False
13:20:55 <Eduard_Munteanu> Mm, good point. :)
13:21:11 <skypers> simukis_: hm
13:21:16 <skypers> I simply use newForeignPtr
13:21:25 <haasn> Eduard_Munteanu: can't you still have those, by explicitly abstracting over them eg. forall (~>). Arrow (~>) => ... -- ?
13:21:32 <haasn> I haven't actually tested
13:22:00 <skypers> and hm
13:22:02 <Eduard_Munteanu> haasn: that doesn't work anymore AFAIK
13:22:06 <skypers> I wonder how it works
13:22:15 <skypers> it might not have a finalizer attached
13:22:23 <skypers> and that’s what I want
13:23:03 <Eduard_Munteanu> haasn: you may be able to fake it using some type synonyms, to write stuff like a |~f~> b
13:23:06 <haasn> Eduard_Munteanu: seems like it, unfortunately
13:23:30 <Apocalisp> I guess that like with (,,) and (,,,) etc. We can have MCo3 a b c, MCo4 a b c d etc.
13:23:50 <Apocalisp> Either3 Either4 etc.
13:24:31 <Eduard_Munteanu> type (|~) a b = b a; type (~>) a b = a b   or something like that
13:24:38 <Walther> > take 10[(x,2^x) | x <- [0..], head(show (2^x)) == '9']
13:24:40 <lambdabot>  [(53,9007199254740992),(63,9223372036854775808),(73,9444732965739290427392),...
13:24:42 <haasn> Apocalisp: HEither :: [*] -> *
13:24:47 <haasn> generalized
13:24:59 <Apocalisp> ooh yes
13:24:59 <minopret> This <http://www.haskellforall.com/2014/03/introductions-to-advanced-haskell-topics.html> uses "Church encoding" like it's not just for booleans and naturals and their functions, and I thought it must mean what I understand as "higher-order abstract syntax". I found this "A higher-order abstract syntax, also sometimes called a Church encoding" (Danvy 1991). Do I sound like I might know what I'm talking about?
13:25:00 <Walther> :) as an interesting brainteaser, "find 10 first powers of 2 that start with the digit 9"
13:25:36 <haasn> > take 10 [ n | n <- iterate (*2) 1, show n `startsWith` "9" ]
13:25:37 <lambdabot>  Couldn't match expected type `[GHC.Types.Char] -> GHC.Types.Bool'
13:25:38 <lambdabot>              with actual type `Data.List.Split.Internals.Splitter
13:25:38 <lambdabot>                                  GHC.Types.Char'
13:25:43 <Eduard_Munteanu> Walther: are there any?
13:25:50 <shachaf> @google boehm-berarducci encoding
13:25:51 <lambdabot> http://okmij.org/ftp/tagless-final/course/Boehm-Berarducci.html
13:25:51 <lambdabot> Title: Boehm-Berarducci Encoding
13:25:58 <sclv_> hoas is a rather more specified concept
13:26:01 <shachaf> minopret: ☝
13:26:03 <sclv_> but it has some relation to church encoding
13:26:12 <minopret> ok thanks!
13:26:14 <Walther> Eduard_Munteanu: quite many!
13:26:15 <haasn> > take 10 [ n | n <- iterate (*2) 1, "9" `isPrefixOf` show n ]
13:26:16 <lambdabot>  [9007199254740992,9223372036854775808,9444732965739290427392,967140655691703...
13:26:21 <haasn> Walther ^
13:26:35 <Eduard_Munteanu> Ah.
13:26:39 <Walther> haasn: yep,, my solution is further up in the log
13:26:41 <haasn> > filter ("9" `isPrefixOf`) $ iterate (*2) 1
13:26:42 <lambdabot>  No instance for (GHC.Num.Num [GHC.Types.Char])
13:26:42 <lambdabot>    arising from a use of `GHC.Num.*'
13:26:42 <lambdabot>  Possible fix:
13:26:42 <lambdabot>    add an instance declaration for (GHC.Num.Num [GHC.Types.Char])
13:26:50 <haasn> oh
13:26:52 <haasn> forgot to show :)
13:26:53 <Walther> also, mine has the values as tuples, showing the number of power
13:27:20 <haasn> > take 10 [ i | i <- [0..], "9" `isPrefixOf` show (2^i) ]
13:27:21 <lambdabot>  [53,63,73,83,93,156,166,176,186,249]
13:27:51 <Apocalisp> haasn: What are the data constructors of Heither?
13:27:51 <haasn> oh, I have an idea
13:28:25 <Eduard_Munteanu> Apocalisp: what are you trying to acheive?
13:28:38 <Walther> haasn: take 10[(x,2^x) | x <- [0..], head(show (2^x)) == '9'] --handy tuples
13:28:44 <Apocalisp> Eduard_Munteanu: Monoid coproducts of more than two monoids
13:28:49 <haasn> Apocalisp: HEmpty :: HEither '[]; HThis :: a -> HEither (a ': xs); HThat :: HEither xs -> HEither (a ': xs)
13:28:52 <haasn> Apocalisp: I think! :)
13:29:11 <csabahruska> hi!
13:29:21 <haasn> Apocalisp: drop HEmpty, actually
13:29:24 <haasn> not needed
13:29:44 <haasn> (unless you absolutely want coproducts of 0 monoids)
13:29:50 <rusk101> is there a function in haskell that works like takeWhile but just goes to the next element in a list instead of quitting?
13:30:17 <csabahruska> do you have experience with any generics library (uniplate,fixplate,multirec) using for compiler AST trasformations?
13:30:47 <Eduard_Munteanu> rusk101: filter?
13:30:57 <haasn> > take 10 [ (i,n) | i <- [0..], n@('9':_) <- [show (2^i)] ] -- Walther
13:30:58 <lambdabot>  [(53,"9007199254740992"),(63,"9223372036854775808"),(73,"9444732965739290427...
13:31:01 <shachaf> haasn: Sounds like a Foldr Either Void thing.
13:31:17 <Walther> haasn: eeeep, now they're strings
13:31:18 <Walther> ;)
13:31:31 <haasn> Walther: I just didn't want to type 2^i once, nor did I want to have to pick a name for it
13:31:34 <haasn> twice*
13:32:00 <rusk101> Yes, it's filter TY. Im trying to write a list of numbers that are not perfect squares. Am i going about it the right way using filter?
13:32:05 <haasn> shachaf: where is that from?
13:33:03 <monochrom> I suppose filter is good enough
13:33:05 <shachaf> Foldr? I don't know.
13:33:29 <haasn> shachaf: type family Foldr (f :: a -> b -> b) (z :: b) (xs :: [a]) :: b where Foldr f z '[] = z; Foldr f z (x ': xs) = f x (Foldr f z xs) -- ?
13:33:38 <shachaf> You can use a type family if you want.
13:33:41 <shachaf> I was thinking of a GADT.
13:35:29 <haasn> shachaf: data Foldr :: (a -> * -> *) -> * -> [a] -> * where FNil :: z -> Foldr f z '[]; FCons :: f x (Foldr f z xs) -> Foldr f z (x ': xs) -- ?
13:36:00 <haasn> that reminds me of the Either construction now that I look at it, yes
13:37:34 <Fuuzetsu> there's a #if MIN_VERSION_template_haskell(2,10,0) but how do I say that I don't want anything 2.10 or higher? That is, I'd like to say MAX_VERSION_template_haskell(2,9,0) but it doesn't seem valid
13:38:09 <rusk101> a little stuck. can anybody shoot a hint on this topic? a list of numbers that are not perfect squares?
13:38:32 <shachaf> haasn: Yep, that.
13:38:33 <Iceland_jack> rusk101: Where are you stuck? On creating the predicate 'isPerfectSquare' or on filtering by it?
13:38:40 <shachaf> If you're going to be fancy and polykinds about it.
13:38:50 <Fuuzetsu> filter (not . perfectSquare) [1 ..]
13:38:52 <Fuuzetsu> ;P
13:38:53 <shachaf> haasn: HList = Foldr (,) ()
13:38:56 <shachaf> And so on.
13:39:01 <Iceland_jack> rusk101: (what Fuuzetsu said)
13:39:16 <Iceland_jack> > filter even [1..]
13:39:18 <lambdabot>  [2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,52,5...
13:39:21 <Iceland_jack> > filter (not . odd) [1..]
13:39:22 <lambdabot>  [2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,52,5...
13:39:34 <haasn> shachaf: I wonder what other useful heterogeneous types can be constructed like this
13:39:41 <rusk101> wait
13:39:42 <rusk101> ok
13:39:42 <Fuuzetsu> I think I'll never remember if filter leaves the elements which return True with the predicate or whether it removes them
13:39:56 <Fuuzetsu> I always think ‘filter out’, that is remove
13:40:18 <shachaf> haasn: If you make the fancy one for functors you can use composition and identity, of course.
13:40:19 <Iceland_jack> Fuuzetsu: yeah me too, something like ‘keep’, ‘select’ or ‘choose’ might be a better name
13:40:19 <Fuuzetsu> but then it works both ways because if you filter something out, that's what you're left it
13:40:21 <monochrom> it is ok to forget. just test :)
13:40:23 <haasn> shachaf: Maybe if we generalize '[] to something else as well, like arbitrary trees
13:40:33 <haasn> to build a sort of HTree
13:40:39 <Fuuzetsu> monochrom: I must have tested into >40 times by now!
13:40:45 <haasn> That has a type-level tree carrying along the type information
13:41:48 <haasn> shachaf: fancy one for functors?
13:42:14 <Fuuzetsu> how can I negate #if in CPP?
13:42:28 <Fuuzetsu> I seem to have to do #if … #else STUFFGOESHERE #endif
13:42:34 <shachaf> haasn: data Foldr :: ((* -> *) -> * -> *) -> (* -> *) -> [* -> *] -> * -> * where ..., I guess.
13:42:40 <monochrom> yes
13:42:40 <shachaf> Maybe with polykinds you can unify them.
13:42:52 <Iceland_jack> Fuuzetsu: you should be able to use '!'
13:43:03 <Fuuzetsu> oh
13:43:05 <Fuuzetsu> I sure wish this line
13:43:07 <Fuuzetsu> the full boolean language of defined(), &&, ||, ==, etc.
13:43:13 <Fuuzetsu> didn't go with “etc.”
13:43:30 <Iceland_jack> CPP also allows #ifndef if you're checking if something is not defined
13:44:20 <prophile> there's !
13:44:21 <Fuuzetsu> nah
13:44:34 <Fuuzetsu> I hope I didn't need a space after !
13:44:39 <prophile> I'm pretty sure you can do #if !defined(bees)
13:44:59 <Fuuzetsu> hm, I think it worked
13:45:10 <rusk101> whats my error
13:45:12 <rusk101> http://lpaste.net/101718
13:45:47 <haasn> shachaf: not quite sure how that one works out, to be honest
13:46:24 <monochrom> that is not valid haskell, rusk101.
13:46:39 <monochrom> the idea is right. the syntax is, onoes
13:46:45 <Eduard_Munteanu> I wonder about... data N = Z | S N;    data (!!) :: [*] -> N -> * where Head :: x -> (x ': xs) !! Z; Tail :: xs !! n -> (x ': xs) !! (S n);   data Coproduct :: [*] -> * where Coproduct :: Sing n -> xs !! n -> Coproduct xs
13:46:51 <shachaf> haasn: Foldr (:*:) Proxy [f,g,h] = f :*: (g :*: (h :*: Proxy))
13:47:08 <Iceland_jack> rusk101: Have you looked at Learn you a Haskell?
13:47:08 <Iceland_jack> @where lyah
13:47:08 <lambdabot> http://www.learnyouahaskell.com/
13:47:34 <monochrom> isPerfectSq a = any [ i^2 == a | i <- [1..100] ]
13:47:38 <haasn> :k (:*:)
13:47:39 <lambdabot> Not in scope: type constructor or class `:*:'
13:48:03 <Eduard_Munteanu> And you can use a type family to cons another type to it.
13:48:04 <haasn> (k -> *) -> (k -> *) -> k -> * -- apparently
13:48:18 <quchen> monochrom: s/any/or/
13:48:21 <monochrom> there are better algorithms, but I won't pick on your algorithm today
13:48:28 <haasn> shachaf: ah, if I update the kind on the first parameter of your Foldr it looks like the poly-kinded version
13:48:32 <monochrom> oh, yikes, quchen is right
13:48:37 <haasn> sort of
13:48:38 <monochrom> isPerfectSq a = or [ i^2 == a | i <- [1..100] ]
13:50:26 <haasn> shachaf: the base case is tricky though; one version has z -> Foldr f z '[] while the functor version has g a -> Foldr f g '[]
13:50:52 <rusk101> thanks mono and quchen
13:51:37 <haasn> shachaf: it would certainly be doable to generalize both with a single type family, though
14:02:20 <jfhall> why is no one talking?
14:02:35 <jfhall> there's always activity here!
14:03:48 <Welkin> shh! It's nap time!
14:04:00 <Iceland_jack> Who just ruined naptime⁇
14:04:16 <jfhall> AHAHHH
14:08:01 <jle`> there's always that one guy
14:08:34 <Iceland_jack> The awakener
14:09:56 <jle`> free arrows are rocking my mind
14:10:09 <prophile> free arrows you say
14:10:09 <jle`> or, making them do useful things is.
14:10:11 <jfhall> sorry guys, I just thought it was like the zombipocalypse or something, got a little worried
14:10:20 <jle`> rocking in a bad way
14:10:30 <jle`> or maybe in a so bad it's good way
14:10:43 <prophile> free arrows generated by what?
14:11:04 <jle`> myself :)
14:11:25 <prophile> amusing :)
14:11:27 <jle`> well loosely following http://stackoverflow.com/questions/12001350/useful-operations-on-free-arrows
14:11:47 <jle`> but now trying to implement arrows with specific functionality
14:11:49 <jle`> based on them
14:13:31 <fizbin> @pl let f ef Nothing = Right Nothing; f ef (Just x) = fmap Just (ef x) in f
14:13:31 <lambdabot> (line 1, column 46):
14:13:32 <lambdabot> unexpected "x"
14:13:32 <lambdabot> expecting operator or ")"
14:13:46 <fizbin> Aw man, @pl, you're letting me down.
14:14:17 <Fuuzetsu> @pl f ef Nothing = Right Nothing; f ef (Just x) = fmap Just (ef x)
14:14:17 <lambdabot> (line 1, column 29):
14:14:17 <lambdabot> unexpected ';'
14:14:17 <lambdabot> expecting variable, "(", operator or end of input
14:14:21 <fizbin> I was hoping that was some sort of lift/map/whatever combination I'd never heard of.
14:14:30 <Fuuzetsu> @pl { f ef Nothing = Right Nothing; f ef (Just x) = fmap Just (ef x) }
14:14:30 <lambdabot> (line 1, column 1):
14:14:30 <lambdabot> unexpected "{"
14:14:30 <lambdabot> expecting white space, "()", natural, identifier, lambda abstraction or expression
14:14:32 <Fuuzetsu> pfft
14:15:06 <fizbin> I mean, I guess I can do it with maybe...
14:16:14 <edwardk> @remember Fuuzetsu I know someone who pulls in Lens just for & and ??
14:16:14 <lambdabot> Good to know.
14:16:33 <bos> 7 minutes to install lens in a sandbox on an 8-core system :-(
14:16:58 <edwardk> bos: would take less time if i hadn't added the attoparsec dep =P
14:17:23 <edwardk> er aeson
14:17:43 <thebnq> lens is like a huge maze
14:17:54 <Fuuzetsu> edwardk: convince bos to make an aeson release
14:17:54 <thebnq> figured out how to use over, see the type, start clicking on unknown things ...
14:17:56 <edwardk> on the plus side it makes sure the entire ecosystem builds ;)
14:17:56 <jle`> we should have an instance orphanage
14:18:15 <jle`> where we can drop orphaned instances so they won't be a nuisance
14:18:40 <fizbin> @pl let f ef mf = maybe (Right Nothing) (\x -> fmap Just (ef x)) mf in f
14:18:40 <lambdabot> maybe (Right Nothing) . (fmap Just .)
14:18:43 <jle`> don't think too much about it or it will make even less sense than it already does
14:18:51 <b0bbi10> evening, me again. http://ideone.com/w8k7VE -> how does Functor and partial type applying fit together in this sample code? is line 4 interpreted correctly by the following: fmap takes a function and a Barry, and extracts the value of 'yabba' into 'x' and 'dabba' into 'y' and returns a Barry with 'yabba' transformed
14:19:11 <b0bbi10> where does the missing parameter fit in here?
14:19:26 <edwardk> yeah but then people will pass orphan instances around from package to package, never giving them a good home. i saw outlaw them, kill them in the streets. make people who own the class or data type take them in or feel responsible for their premature demise. ;)
14:19:31 <jle`> b0bbi10: yes
14:20:05 <bos> edwardk: are the lenses in lens-family-th compatible with yours?
14:20:09 <jle`> edwardk: i say we defer to the problem to social workers and an oversight system
14:20:11 <edwardk> bos: yes
14:20:13 <fizbin> b0bbi10: The "missing" parameter is the type of yabba.
14:20:26 <edwardk> bos: deliberately so
14:20:28 <jle`> b0bbi10: what issing parameters?
14:20:29 <fizbin> @type fmap
14:20:30 <lambdabot> Functor f => (a -> b) -> f a -> f b
14:21:05 <jle`> do you mean the lack of p in instance Functor (Barry a b) ?
14:21:24 <b0bbi10> jle`: I guess
14:21:28 <fizbin> b0bbi10: See how when I say "foo is a Functor", that means that "foo" is not a type itself, but "foo a" is, and fmap transforms a "foo a" into a "foo b"
14:21:28 <jle`> perhaps if you wrote instance Functor (Barry t k) it'd be slightly clearer
14:21:36 <jle`> :k Functor
14:21:37 <lambdabot> (* -> *) -> Constraint
14:21:42 <bos> edwardk: why isn't that portion of lens separated out into its own package? do you really depend on the world for even notionally simple core functionality, or is it just an ease-of-maintenance thing?
14:21:43 <jle`> a functor is something * -> *
14:21:57 <jle`> Barry is * -> * -> * -> *
14:22:04 <jle`> Barry t is * -> * -> *
14:22:07 <jle`> Barry t k is * -> *
14:22:17 <jle`> only one can be a Functor
14:22:44 <Fuuzetsu> only the strongest (weakest?) prevails
14:23:07 <jle`> more pedagogically, a Functor is something that takes a type t and returns an 'f t'.
14:23:30 <jle`> replace f with "Barry t k"
14:23:33 <jle`> and you shall see.
14:25:00 <b0bbi10> fizbin, jle`: thanks, I'll try to figure it out with what you just said
14:26:33 <monochrom> the ability to type-class on something of kind *->* is pretty special of haskell. all mainstream languages lack it.
14:27:12 <jrmithdobbs> monochrom: there's been talk about it for rust!
14:29:54 <jle`> is it just me or the definition of the Par constructor kinda silly/not useful here?
14:29:56 <jle`> http://stackoverflow.com/questions/12001350/useful-operations-on-free-arrows
14:30:05 <jesyspa> monochrom: Would type-classing on * be, for example, C++ templates?  I'm not sure how to map typeclasses to anything in a mainstream language.
14:30:19 <jle`> neither a nor b  are even used
14:30:22 <Kaidelong> how do I get cabal to tell me where a C macro is defined that is being expanded?
14:31:07 <jle`> jesyspa: it is often said that typeclasses are like interfaces in java, but it's not the best analogy
14:32:59 <Iceland_jack> jesyspa: It may not be the best idea to try to map it to other languages
14:33:25 <jesyspa> Actually, hang on, the proposed C++ concepts come fairly close, don't they?
14:33:38 <bos> edwardk: do you know if it's possible to use TH to derive lenses for a type defined in another module?
14:34:06 <bos> edwardk: specifically, if i have data Foo = Foo { foo :: Int }, i'd like to generate a lens named foo in my other module
14:34:35 <edwardk> bos: makeLenss ''Foo should just work regardless of where you use it
14:34:48 <edwardk> it'll make local definitions, but Foo doesn't have to be local
14:35:26 <bos> edwardk: it doesn't seem to - the foo accessor remains visible as the only foo, for instance
14:35:35 <bos> rather than any foo lens
14:36:03 <Eduard_Munteanu> bos: you can write your own *Rules to derive things, possibly involving qualified names
14:36:24 <Eduard_Munteanu> bos: look at Control.Lens.TH's source
14:36:57 <edwardk> bos: "why isn't that portion of lens separated out into its own package?" -- we actually depend on HashMap for that simple thing, we use traversals to go through and perform rudimentary type substitution and unification in template haskell, we expose the template-haskell machinery for lenses with lenses in their own right.
14:37:30 <edwardk> we could shed a half-dozen packages from lens's dependencies, mostly in the platform, in exchange for making it a much trickier proposition for users to figure out what they need to import from where to use lens
14:38:14 <edwardk> bos: oh, te problem is the field is named foo not _foo
14:38:45 <bos> edwardk: right, that's what i was wondering about.
14:38:46 <jle`> keep in mind that edwardk doesn't use sandboxes
14:38:47 <edwardk> i don't know that we tried to make it reference something qualified in another module in the real lens TH. i'm pretty sure the simpler lens-family-th version doesn't do anything exotic
14:38:51 <edwardk> jle`: =P
14:39:04 <bos> edwardk: in my case, i want to take one of snoyberg's types and lens-ify it
14:39:42 <edwardk> bos: the usual way with real makeLenses would be to write something like makeLensesWith ?? ''Foo $ defaultRules & lensField .~ \x -> Just (x ++ "_")
14:39:55 <edwardk> then then lenses would be named foo_  for a field named foo
14:40:01 <bos> edwardk: i see
14:40:26 <edwardk> lensField lets you change the name used for the lenses it generates
14:40:41 <edwardk> and whether it should lensify a given field name
14:42:58 <bos> it seems that TH just won't do what i want
14:43:17 <bos> if there's already a foo in scope due to the import, it won't create a new foo
14:43:35 <edwardk> bos: re splitting out lens. i get about one request every week from someone to break out part of lens. however, so far basically none of those requests has been able to agree on what portion of what it should
14:43:42 <edwardk> if you have it imported qualified will it work?
14:44:04 <edwardk> er what portion of it it should be
14:45:17 <bos> edwardk: no, it doesn't generate a foo binding still - let me poke a bit more
14:45:25 <edwardk> any viable lens core winds up with about 80% of the same dependencies, we have some rather gratuitous ones around the fringes, but frankly i'd rather have them than just flat out not have stuff work with lens or deal with the terrible user experience of orphans
14:45:49 <Eduard_Munteanu> bos: with the default rules it will simply ignore anything not starting with '_'
14:45:52 <edwardk> bos: i'd be open to taking an issue about that, since we should be able to build it given a qualified mport
14:45:59 <bos> edwardk: ah, that did it.
14:46:23 <edwardk> and with the rule saying you should lensField .~ Just
14:46:30 <bos> yes
14:46:31 <bos> makeLensesWith ?? ''Type $ defaultRules & lensField .~ Just
14:46:33 <edwardk> to keep the same name
14:46:37 <edwardk> yep
14:46:48 <bos> but it only works tidily with a qualified import
14:47:04 <edwardk> as it has to. i can't write the definition by hand with the import unqualified
14:47:07 <bos> otherwise i end up with the two foo bindings in scope, not surprisingly
14:47:24 <edwardk> because the world ignored Lennart's requests to make local definitions the only sensible definition to export
14:47:26 <Tijuanense> this error message I get every time I compile
14:47:29 <Tijuanense> is getting to be too much
14:47:32 <Tijuanense> what does it mean?
14:47:32 <Tijuanense> http://i.imgur.com/eizzhMx.jpg
14:47:43 <Eduard_Munteanu> There's a proposal to allow TH to import stuff, but not implemented.
14:48:04 <edwardk> Eduard_Munteanu: no, the issue is that if there is a symbol imported i can't define a local thing with the same name and export it
14:48:21 <edwardk> Eduard_Munteanu: the issue is that the export becomes ambiguous, since the local module scope doesn't override import scope
14:48:35 <edwardk> despite the fact that it doesn't make sense the way it is
14:48:42 <Eduard_Munteanu> I know... but with that TH could take care of importing qualified.
14:49:33 <Eduard_Munteanu> Perhaps even importing qualified and then importing the rest hiding the fields.
14:51:36 <edwardk> Eduard_Munteanu: well, it'd have to _un_import the existing import
14:59:07 <pyon> Does lambdabot have anything like ghci's :i ?
14:59:20 <shachaf> No.
14:59:37 <pyon> Dang. :-( Never mind.
14:59:40 <pyon> Thanks.
15:05:08 * hackagebot stm 2.4.3 - Software Transactional Memory  http://hackage.haskell.org/package/stm-2.4.3 (HerbertValerioRiedel)
15:06:32 <prooftechnique> Fuuzetsu: Who should I talk to about working on the LaTeX backend for haddock?
15:06:49 <erisco> how do you sample the current value of a behaviour in reactive-banana?
15:08:40 <prooftechnique> As an aside, has anyone gotten the GL family stuff building under 7.8 on Mavericks?
15:09:27 <jle`> woo hoo my proof of concept for an arrows-based data parallelism dsl works
15:09:28 <jle`> kinda
15:09:41 <prooftechnique> Neato
15:09:59 <prooftechnique> Got a link? :)
15:11:19 <jle`> it's kinda silly right now, heh
15:11:48 <prooftechnique> I only write silly code
15:12:26 <erisco> looks like it has to be done through <@ ... I am just interested in wiring the network to the output
15:13:04 <jle`> http://lpaste.net/101721 ... but actually...i don't know how to merge sequential parallel branches right now
15:13:18 <jle`> so...
15:13:20 <jle`> maybe that goes out the window
15:14:26 <jle`> yeah, it probably does
15:14:31 <jle`> oh well
15:14:40 <jle`> back to the drawing board
15:16:09 <erisco> ah, 'initial'
15:20:10 * hackagebot ivory 0.1.0.0 - Safe embedded C programming.  http://hackage.haskell.org/package/ivory-0.1.0.0 (LeePike)
15:20:20 <Fuuzetsu> prooftechnique: me
15:21:07 <Fuuzetsu> preferably in #haddock and preferably in 10 minutes ;P
15:22:39 <jle`> i am sad about my arrow concept falling apart :/
15:22:52 <prooftechnique> Fuuzetsu: Oh, good :)
15:22:56 <jle`> there goes my spring break project
15:28:17 <jle`> oh, but a revelation.
15:30:11 * hackagebot ivory-opts 0.1.0.0 - Ivory compiler optimizations.  http://hackage.haskell.org/package/ivory-opts-0.1.0.0 (LeePike)
15:34:09 <jle`> woo hoo i think it works
15:35:42 <Aetherspawn> /r/haskell is down :C
15:36:01 <merijn> Aetherspawn: No it's not?
15:36:07 <Aetherspawn> it was up
15:36:09 <Aetherspawn> now it down again
15:36:14 <Aetherspawn> (in a window of about seconds)
15:36:32 <Aetherspawn> .. aaand its up again
15:36:33 <k00mi> reddit isn't the most stable of sites
15:36:39 <flebron> jle`: Remember that (a -> Maybe a) -> a -> a?. The way I did it was, with beta :: Expr -> Maybe Expr, eval x = maybe x eval (beta x), where eval is conceptually "repeated beta until you get Nothing"
15:36:51 <Tijuanense> wtf
15:36:59 <Tijuanense> i keep getting this compile error
15:37:01 <Tijuanense> why?
15:37:01 <Tijuanense> http://i.imgur.com/eizzhMx.jpg
15:37:16 <Yaniel> "compile error"
15:37:17 <flebron> Above image is porn.
15:37:19 <SrPx_> Does anyone know a VIM plugin that will fill the types after I wrote the definition?
15:37:20 <dagle> A compile error that is an image?
15:37:21 <k00mi> @where ops
15:37:21 <lambdabot> arjanb bos byorgey Cale conal copumpkin dcoutts dibblego dmhouse dolio dons edwardk elliott geekosaur glguy Heffalump Igloo jmcarthur johnw kosmikus Lemmih monochrom nyc Philippa Pseudonym quicksilver roconnor Saizan shachaf shapr sjanssen ski sorear SyntaxPolice xerox
15:37:30 <Tijuanense> stop trolling flebron
15:37:33 <k00mi> Tijuanense is linking porn
15:37:41 --- mode: ChanServ set +o monochrom
15:37:49 --- mode: monochrom set +b *!*@200.79.251.35
15:37:49 --- kick: Tijuanense was kicked by monochrom (Tijuanense)
15:38:16 <Fuuzetsu> when is GHC going to provide images instead of type errors?
15:38:35 <dagle> I thought lambdabot was talking some weird language... then it was just names of mods.
15:38:39 <dagle> ops*
15:38:41 <flebron> Or kittens when your code compiles.
15:39:24 <dwcook> Provide kittens? With the kitten dispensing peripheral attached to your computer?
15:40:03 <dwcook> Though if it did that a lot of people would be way less productive – They could just compile the same code over and over to get more kittens!
15:42:07 <colDrMcBeardman> with Data.Conduit and Data.Conduit.List does someSource $$ consume guarantee that it will consume everything from the source?
15:42:29 <Aetherspawn> ;_;
15:42:43 <Aetherspawn> people hate haskell because it's different. remember that, son.
15:42:53 <dario> remembered.
15:43:34 <monochrom> I like haskell because it produces kittens
15:44:00 <Aetherspawn> I wonder how many people got bombed with that image during a uni lecture
15:44:18 <Fuuzetsu> I doubt anyone cares during a uni lecture
15:44:35 <Aetherspawn> you're shameless.
15:44:49 <Fuuzetsu> I think there's some degree of ‘if I click on unknown image link online, it might be porn’ to be had
15:45:10 <Hafydd> Why are you chatting on IRC during a lecture, you disrespectful brat? Pay attention.
15:45:29 <colDrMcBeardman> Hafydd, maybe they're in Haskell class?
15:45:31 <monochrom> pay attention to twitter!
15:45:37 * Fuuzetsu stays at home and chats on IRC instead
15:45:39 <Hafydd> That does not change anything.
15:45:59 <jle`> flebron: ah that works
15:46:07 <jle`> :)
15:46:20 <colDrMcBeardman> maybe they're in haskell class because they couldn't get a local lambdabot working?
15:46:36 <colDrMcBeardman> s/because/and
15:46:49 <Aetherspawn> not even in a lecture right now
15:47:06 <Aetherspawn> but thanks for calling me a terrible person, appreciate.
15:49:09 <bahamas> the "you could have invented monads" article is a real pearl. I only skimmed it, but it already made me understand more about monads
15:51:27 <erisco> cabal install error... not in scope: "catch" http://lpaste.net/101723
15:53:25 <Hafydd> I'd hope you appreciate being called terrible when you really are.
15:53:54 <JEntrep> Can they really be serious?
15:54:19 <JEntrep> Oculus VR selling out to Facebook. :( I don't believe they did that.
15:54:24 <JEntrep> They were forced too. :O
15:54:30 <JEntrep> Yeah, that's what I'll believe.
15:54:37 <sipa> forced to?
15:54:46 <shachaf> This isn't really the channel for that.
15:54:50 <JEntrep> I can believe what I want! Leave me alone! D:
15:55:06 <SrPx_> Is it always necessary to annotate the type of an empty list?
15:55:19 <erisco> SrPx_, no
15:55:34 <erisco> :t 1:[]
15:55:34 <lambdabot> Num a => [a]
15:55:44 <S11001001> @ty mconcat []
15:55:45 <lambdabot> Monoid a => a
15:55:46 <monochrom> pretty sure in most real programs you don't need to annotate []
15:55:46 <SrPx_> ok, weird
15:55:48 <colDrMcBeardman> SrPx_, only if the type cannot be inferred for some reason would you have to.
15:56:32 <monochrom> toy programs, sure, toy programs have too many loose ends
15:56:57 <jle`> it's just as unecessary as annotating the type of Nothing
15:57:32 <jle`> hm. is there any way to work with a data type with existential types
15:57:38 <jle`> and like
15:57:40 <jle`> inspect it
15:57:42 <jle`> using Typeable
15:57:48 <jle`> you can't, huh
15:58:07 <erisco> only related issue I can find is https://ghc.haskell.org/trac/ghc/ticket/7024 to my compile error http://lpaste.net/101723
15:58:11 <erisco> but that was 21 months ago
15:58:14 <erisco> and patched
15:58:39 <erisco> I am using GHC 7.8
15:58:53 <flebron> So terminology question. Int has kind *, and Maybe has kind * -> *. Just as values have types, what has kinds? I was inclined to say types, but Maybe isn't a type (it's a type ctor) but still has a kind.
15:59:10 <jmcarthur> jle`: you can do something like this:   data Dynamic = forall e. Typeable e => Dynamic e
15:59:18 <erisco> flebron, type constructor maybe?
15:59:26 <Aetherspawn> Maybe is a type, Just is a constructor
15:59:29 <flebron> Well Int isn't a type constructor, and still has kinds.
16:00:11 <haasn> classes have kinds too, though I'm not sure if in h2010 or not
16:00:19 <erisco> well then to complete your statement, functions have types too
16:00:27 <erisco> so types have kinds, and type constructors have kinds
16:00:28 <flebron> Functions are values
16:00:46 <ion> aetherspawn: Maybe is a type constructor, Just is a data constructor.
16:01:02 <erisco> flebron, well I do not know how else to split the hairs :)
16:01:30 <jle`> jmcarthur: hm but then all functions that work with my data type have ot have those constraints
16:01:46 <jle`> i want to make a simple Show
16:01:55 <jmcarthur> jle`: no. the constraint is included with the constructor
16:02:18 <jmcarthur> jle`: if you want it to be showable then do this   data ShowableThing = forall e. Show e => ShowableThing e
16:02:32 <jmcarthur> jle`: btw, i don't recommend this style at all
16:02:33 <jle`> hm. maybe it's for my own specific use case
16:02:38 <jmcarthur> jle`: just showing that it's possible
16:02:42 <flebron> What I'm looking for is a word X, such that X is those "things" which have a kind.
16:02:54 <prooftechnique> kinded?
16:02:54 <jle`> flebron: type-level values?
16:03:03 <erisco> flebron, you might say that Maybe is a type, and that all types have a kind
16:03:05 <jle`> jmcarthur: ah, thanks
16:03:15 <flebron> So Maybe is a type-level value? (erisco: Maybe isn't a type though)
16:03:50 <erisco> flebron, what about an additional qualifier? a polymorphic type?
16:03:57 <flebron> Hrm?
16:04:00 <erisco> a parameterized type? a higher-order type?
16:04:08 <flebron> I'm not sure what you're askingl
16:04:14 <erisco> you said Maybe is not a type
16:04:23 <flebron> Indeed, there is no value of type Maybe.
16:04:32 <flebron> Nor can you unify it with any type variable.
16:04:40 <prooftechnique> Maybe a is a type, though
16:04:48 <flebron> Indeed.
16:05:01 <erisco> flebron, fine, so I was offering a way to distinguish Maybe from, say, Int
16:05:06 <erisco> using another qualifier
16:05:10 <flebron> That's their kind :)
16:05:33 <erisco> that is not relevant. you are asking for diction
16:05:35 <erisco> I am offering diction
16:06:10 <erisco> higher-order type is reasonable I think
16:06:15 <flebron> I wasn't asking for a word to distinguish Int from Maybe, I was asking for a word to unify them.
16:06:24 <hpc> i would go with "type"
16:06:29 <flebron> That is, a word that signifies "those things which have a kind".
16:06:32 <hpc> and "concrete type" when you care about the difference
16:06:44 <erisco> flebron, that is what I was trying to give you
16:06:47 <flebron> So you'd call * the class of concrete types?
16:06:59 <hpc> the kind of concrete types
16:07:09 <erisco> that is, call everything a type, and if you are worried about saying "Maybe is a type" then say something such as "Maybe is a higher-order type"
16:07:13 <erisco> that is, add a qualifier
16:07:37 <pyon> erisco: It is not a type. It is a type constructor.
16:07:37 <flebron> I'm not terribly comfortable calling everything a type :p But oh well.
16:07:45 * erisco facepalms
16:07:52 <erisco> nevermind
16:08:11 <pyon> erisco: It exists at the type level, though, which I guess was your point.
16:26:04 <conal> erisco: i think the types & haskell communities uses "type" inconsistently -- sometimes to mean types of values and sometimes things that have kinds. i'm especially sympathetic to the latter (your usage), though confusion is perhaps inevitable.
16:26:27 <bl33d> can I use winapi with haskell?
16:28:09 <conal> erisco: e.g., note the many uses of "higher-kinded types".
16:28:59 <conal> erisco: ... which would be an oxymoron if "types" referred just to types of things (i.e., not higher-kinded).
16:29:27 <hnewb> hey all... I am hoping for some help. I an installing scion-browser and buildwrapper for the eclipse plugin.. but they seem to break each other on install
16:29:59 <hnewb> is there any known solution to this problem?
16:30:38 <prooftechnique> hnewb: My strategy was cabal sandboxing
16:30:45 <erisco> I was offering what terminology I have heard and somewhat understood, but I am not well versed in type theory and accompanying language, conal, but, from what I can tell, on the type-level (as it is so-called)
16:30:55 <erisco> ... types are values
16:31:15 <prooftechnique> hnewb: I made a directory called eclipse-tools, cabal sandbox init in that directory, then cabal install the tools
16:31:35 <prooftechnique> And then I added eclipse-tools/.cabal-sandbox/bin to my PATH
16:32:03 <erisco> and so I am somewhat surprised that the confusion in language persists because I do not see why it needs to
16:32:49 <fizbin-mobile> Anyone want to help me generalize something?
16:32:53 <fizbin-mobile> http://lpaste.net/101725
16:34:08 <jle`> fizbin-mobile: it's mapM
16:34:13 <jle`> fizbin-mobile: from Data.Traversable
16:34:28 <jle`> fizbin-mobile: all three of them
16:34:45 <jle`> fizbin-mobile: the list version doesn't need an applicative either
16:34:51 <jle`> er, a monad
16:35:02 <fizbin-mobile> Ah. Data.Traversable. OK.
16:35:12 <prooftechnique> :t Data.Traversable.mapM
16:35:12 <lambdabot> (Monad m, Traversable t) => (a -> m b) -> t a -> m (t b)
16:35:25 <jle`> fizbin-mobile: traversable basically lets you treat Maybe like a list with 0 or 1 element
16:35:38 <jle`> so...you can use the list stuff on it
16:35:39 <fizbin-mobile> And Either?
16:36:40 <jle`> fizbin-mobile: yes, the same
16:36:45 <jle`> hm
16:36:50 <jle`> it looks like Either isn't a Traversable
16:36:51 <erisco> according to the Haskell 98 report, the language is
16:36:53 <erisco> 1) The symbol * represents the kind of all nullary type constructors
16:37:00 <erisco> 2) If k1 and k2 are kinds, then k1->k2 is the kind of types that take a type of kind k1 and return a type of kind k2.
16:37:10 <jle`> but i don't think i thsould be that hard to instance it as one...with a constraint on e, perhaps
16:37:33 <erisco> therefore, it calls Int a type constructor, and distinguishes it with "nullary"
16:38:20 <jle`> fizbin-mobile: actually all you need to do for trasversable is traverse, which is basically what you already wrote
16:38:24 <jle`> but for applicative, not monad
16:38:54 <Luke> is there a way in shake to depend on a directory of files? it looks like getDirectoryFiles returns the file name without the full path
16:39:08 <Luke> i basically want to depend on src//*.hs
16:39:20 <erisco> pyon, is that a satisfactory source?
16:39:35 <Luke> but if I "need [src//*.hs]" it looks for a task named that, not the files
16:40:19 * hackagebot timeplot 1.0.24 - A tool for visualizing time series from log files.  http://hackage.haskell.org/package/timeplot-1.0.24 (EugeneKirpichov)
16:41:07 <pyon> erisco: I do not think there is such thing as a "nullary" type constructor. Or "nullary" anything, in general.
16:41:53 <prooftechnique> 4 is a nullary function
16:42:06 <erisco> pyon, well http://www.haskell.org/onlinereport/decls.html#sect4.1.1 disagrees with you
16:42:24 <monochrom> we already know that haskell types are inconsistent :)
16:42:30 <pyon> erisco: Oh, whoa.
16:42:31 <erisco> a -> b is 1-ary, b is null-ary
16:43:10 <pyon> Where "a" and "b" are kinds, right?
16:43:55 <pyon> erisco: Well, in this case, only nullary type constructors are types.
16:44:01 <erisco> you can use the n-ary language to talk about how many arguments a function accepts
16:44:23 <erisco> pyon, correct
16:45:48 <jmcarthur> yeah i wish Either had a Traversable instance
16:45:53 <jmcarthur> tuples, too
16:46:18 <erisco> so like functions are values in Haskell (I believe this is called second-order), the equivalent at type-level would be if kinds were types, no?
16:47:42 <ReinH> What is a nullary function?
16:47:59 <jmcarthur> ReinH: Void -> a?  ;)
16:48:16 <ReinH> :p
16:49:02 <erisco> point being wrt my last question, pyon, is that "value" is only a convenient term because functions are values
16:49:03 <prooftechnique> ReinH: f :: Int; f = 4?
16:49:13 <ReinH> prooftechnique: what definition of function are you using?
16:49:29 <erisco> pyon, whereas if functions were not values, we would be having the exact same language problem as we are with types and kinds
16:50:02 <prooftechnique> A circular one that considers values to be nullary functions
16:50:13 <ReinH> prooftechnique: Ah. Well I guess I can't argue with that.
16:50:54 <prooftechnique> Hahaha
16:51:00 <MagneticDuck> I don't think "nullary functions" really have a place in haskell
16:51:03 <MagneticDuck> I mean
16:51:06 <MagneticDuck> ...
16:51:10 <ReinH> I don't think they are a thing.
16:51:12 <pyon> erisco: No idea. :-(
16:51:13 <MagneticDuck> there are functions, and there are values
16:51:16 <MagneticDuck> period.
16:51:27 <MagneticDuck> :D
16:51:34 <erisco> pyon, well think about it. assume that functions are not values. then what do you call all things which have a type?
16:51:39 <prooftechnique> But functions are values~~~~
16:51:59 <MagneticDuck> prooftechnique: no, functions are first class objects
16:52:01 <ReinH> "all functions are values" does not imply "all values are functions" :p
16:52:02 <MagneticDuck> =P
16:52:03 <glguy__> This is a bit of "There are squares and there are rectangles"
16:52:05 <pyon> erisco: "assume that functions are not values" --> That would be a very lame language.
16:52:09 <MagneticDuck> glguy__: well
16:52:12 <monochrom> I think you are arguing over conventions.
16:52:21 <MagneticDuck> yes
16:52:26 <prooftechnique> Hehe
16:52:27 <MagneticDuck> and I think I'm about to start loosing
16:52:44 <ReinH> monochrom: I'm sort of pointing to the definition of function. Which is a convention, yes.
16:52:47 <glguy__> Functions are values with a partiular type: _ -> _
16:52:53 <erisco> pyon, well they exist :) you'd end up saying values, like "5", have a type, and that functions, such as "id", have a type
16:53:07 <pyon> erisco: It would be awkward. :-|
16:53:30 <pyon> erisco: Perhaps we should come up with a single-word term that denotes all type-level values.
16:53:44 <prooftechnique> I vote for "type-y"
16:53:44 <MagneticDuck> yeah, disregard the distinction I made between functions and values, functions are values
16:53:48 <erisco> pyon, so same is happening at the type level, where nullary type constructor is the equivalent for "value", and n-ary type constructor is equivalent for "function"
16:53:57 <pyon> prooftechnique: :-)
16:54:06 <pyon> erisco: Not exactly.
16:54:22 <ReinH> type-constructor is one word if you hyphenate it...
16:54:31 <pyon> erisco: A n-ary type constructor is the type-level equivalent of what a n-ary data constructor is at the value level.
16:54:47 <ReinH> I suppose we're all out of interesting things to discuss today then? :)
16:54:51 <pyon> erisco: But there are type-level functions that are not type constructors.
16:55:00 <pyon> erisco: Think "type FlippedEither a b = Either b a".
16:55:28 <monochrom> the price of having 1200 people is that the majority begin to argue over bikeshed colours
16:55:47 <ReinH> Wow there actually are 1206 people in here o_O
16:55:51 <pyon> Errr... my bad.
16:55:56 <MagneticDuck> there's a haskell extension that lets types with kinds like ((* -> * -> *) -> * -> * -> *) exist right?
16:55:59 <mindleyhilner> oh man
16:56:02 <monochrom> and lpaste has exceeded 100000 pastes
16:56:28 <MagneticDuck> ReinH: there were 1234 earlier today
16:56:37 <MagneticDuck> and then everybody shuffled around and ruined a great number
16:56:37 <erisco> pyon, :)
16:56:49 <MagneticDuck> well, a midly interesting number expressed in base 10
16:56:50 <geekosaur> next stop, 1337
16:56:55 <MagneticDuck> yes :D
16:56:56 <monochrom> ((* -> * -> *) -> * -> * -> *) exists without extension.
16:57:00 <MagneticDuck> monochrom: oh cool
16:57:01 <ReinH> And then we close the room right?
16:57:15 <ReinH> s/room/channel
16:57:19 <Axman6> above 1337 it becomes too mainstream
16:57:25 <MagneticDuck> so I can make something like data Flip x a b = x b c ?
16:57:32 <MagneticDuck> uhm... hopefully that works?
16:57:34 <MagneticDuck> ... >_>
16:57:39 <ReinH> Time to join #agda
16:57:45 <monochrom> you're missing a data constructor on the RHS
16:58:04 <SrPx_> How do I foldl with indices? I need the indices, so I'm doing something like `foldl step initial (enumFromTo 0 (length list)) where { step accum index = ... where { element = list !! index } }` (I don't know how to inline that) - this is obviously not ideal as I'm using !! several times to access elements in a row!
16:58:15 <erisco> pyon, as far as I understood, a type system can be viewed as a language itself, but it is deliberately limited (usually) so that certain guarantees can be made (such as termination, efficiency, ease of reasoning)
16:58:28 <monochrom> SrPx_, consider zip [0..]
16:58:30 <Axman6> SrPx_: no need for the length list bit, just use [0..]
16:58:46 <SrPx_> Axman6: oh ok cool
16:58:53 <prooftechnique> > zip [1..10] [0..]
16:58:54 <lambdabot>  [(1,0),(2,1),(3,2),(4,3),(5,4),(6,5),(7,6),(8,7),(9,8),(10,9)]
16:59:11 <prooftechnique> > zip [0..] [1..5]
16:59:12 <lambdabot>  [(0,1),(1,2),(2,3),(3,4),(4,5)]
16:59:18 <SrPx_> monochrom: hm pardon? You want me to use zip to make pairs of index/elements? Let me try
16:59:20 <Axman6> foldl (\(ix,x) y -> do stuff) initial $ zip [0..] xs
16:59:21 <SrPx_> elements are not numbers... is that ok?
16:59:22 <glguy__> foldl (\acc (i,x) -> f acc i x) z (zip [0..] xs)
16:59:32 <Axman6> the elements can be anything at all
16:59:33 <Iceland_jack> SrPx_: yes
16:59:37 <prooftechnique> > zip [0..] ['a'..'g']
16:59:38 <lambdabot>  [(0,'a'),(1,'b'),(2,'c'),(3,'d'),(4,'e'),(5,'f'),(6,'g')]
16:59:39 <SrPx_> ok, a second
16:59:39 <monochrom> evidently, everyone else wants too, not just me
17:00:12 <Axman6> > zip [0..] "Hello, world!"
17:00:13 <lambdabot>  [(0,'H'),(1,'e'),(2,'l'),(3,'l'),(4,'o'),(5,','),(6,' '),(7,'w'),(8,'o'),(9,...
17:00:31 <prooftechnique> The possibilities are literally endless
17:00:37 <prooftechnique> (modulo machine memory)
17:00:41 <monochrom> haha
17:01:01 <MagneticDuck> > zip "The possibilities are endless" "Modulo machine memory"
17:01:02 <lambdabot>  [('T','M'),('h','o'),('e','d'),(' ','u'),('p','l'),('o','o'),('s',' '),('s',...
17:01:03 <MagneticDuck> =P
17:01:18 <SrPx_> Seems like that worked very well, I'm impressed.
17:01:22 <SrPx_> Thanks
17:01:29 <SrPx_> wow
17:01:39 <erisco> conal, I suppose because I would not call a function a "higher-order value" it would be equally nonsensical to call something of kind * -> * a "higher-order type"
17:03:08 <prooftechnique> SrPx_: Laziness is pretty neat
17:03:13 <conal> erisco: why not call a function a "higher-order value"? (higher than zeroth order)
17:04:19 <SrPx_> prooftechnique: not just the laziness, but pattern matching on the fold function to get the (idx,element) from the resulting pairs was pretty
17:04:44 <erisco> conal, hm, good question, it just sounded funny. What is meant by "order"? I suppose that when we say "higher-order function", we are talking about functions which accepts or returns a function
17:04:55 <nolrai66> So which is the best memoization library?
17:05:00 <erisco> and so just by substituting the words, a "higher-order value" would accept a value or return a value
17:05:10 <Axman6> @hoogle ((Int,a) -> b -> b) -> b -> [a] -> b
17:05:11 <lambdabot> No results found
17:05:15 <Axman6> :(
17:05:22 * hackagebot quadratic-irrational 0.0.3 - An implementation of quadratic irrationals  http://hackage.haskell.org/package/quadratic-irrational-0.0.3 (ion)
17:05:23 <Axman6> @hoogle (b -> (Int,a) -> b) -> b -> [a] -> b
17:05:24 <lambdabot> No results found
17:05:30 <glguy__> SrPx_: If you every find yourself using the lens library, you can also use "ifoldl" (fold with index)
17:06:17 <monochrom> soon, you will also have fun with "higher rank"
17:07:05 <erisco> conal, so in retrospect I'll do a 180 and claim it makes good sense to call something of kind * -> * a higher-order type. You mentioned higher-kinded... how does that fit into the picture?
17:07:53 <SrPx_> glguy__: so you're the opengl guy of this channel
17:08:28 <conal> erisco: higher-order types == higher-kinded types, i guess.
17:08:30 <glguy__> Oh, no. I've made a couple of things using the "gloss" library, but OpenGL and "glguy" aren't related :)
17:08:51 <athan> Hey, what does a tilda mean in haskell-speak?
17:08:57 <prooftechnique> Speaking of, is anyone else having issues getting those to build on RC2?
17:09:00 <athan> I see a definition here
17:09:00 <Axman6> lazy pattern match
17:09:12 <hpc> athan: it can mean a few things
17:09:18 <athan> ~(~(x,y),z) = (x, (y, z))
17:09:24 <athan> hmmm
17:09:24 <hpc> lazy pattern match, and it's also got a different meaning in type signatures
17:09:27 <prooftechnique> Isn't it also type equivalence or something?
17:09:29 <athan> OH WAIT
17:09:36 <athan> OF COURSE
17:09:40 <glguy__> athan: http://www.haskell.org/onlinereport/exps.html#let-expressions look for "irrefutable pattern" and "~"
17:09:42 <thebnq> haskell speek is typed :b
17:09:47 <athan> so it pattern matches without unboxing the type?
17:10:13 <athan> hahaha
17:10:16 <athan> "haskellian"
17:10:29 <athan> I was wondering....
17:10:39 <athan> does haskell do any pattern matching on the type level?
17:10:46 <athan> so like say the type of ($)
17:10:49 <athan> :t ($)
17:10:50 <lambdabot> (a -> b) -> a -> b
17:11:02 <athan> would that fit in with :: a -> b -> c
17:11:14 <athan> would that type declaration still work with ($)'s?
17:11:31 <athan> I feel like there's a more ambiguous pattern matching going on at the type level
17:11:39 <Eduard_Munteanu> athan: not pattern-matching, but unification is the term
17:11:48 <athan> or like... parametric objects as the descrete patterns to be matches against - the variables
17:11:52 <athan> hmm
17:11:56 <thebnq> yea, this comes up with in kind level polymorphism
17:12:06 <Axman6> look up hindley miller type system
17:12:12 <Axman6> hmm, not sure of the spelling
17:12:14 <mindleyhilner> milner
17:12:14 <Eduard_Munteanu> athan: a -> b -> c is too general for ($)
17:12:26 <Axman6> heh
17:12:39 <athan> ha!
17:12:42 <athan> ahhhh
17:12:43 <athan> hmm
17:12:45 <Axman6> :t ($)
17:12:46 <lambdabot> (a -> b) -> a -> b
17:12:52 <athan> that's gonna be tough to completely conceptualize
17:13:02 <kuribas> The only way to make a class member which is not a function, is to use a GADT, right?
17:13:08 <erisco> athan, a good example that warped my brain is the following...
17:13:13 <erisco> :t id uncurry
17:13:13 <lambdabot> (a -> b -> c) -> (a, b) -> c
17:13:26 <erisco> oh sorry
17:13:28 <erisco> lol
17:13:30 <Axman6> kuribas: well, you can have a member like mzero
17:13:33 <Axman6> :t mzero
17:13:34 <lambdabot> MonadPlus m => m a
17:13:37 <erisco> :t uncurry id
17:13:38 <lambdabot> (b -> c, b) -> c
17:13:40 <Axman6> @src MonadPlus
17:13:40 <lambdabot> Source not found. Whoa.
17:13:41 <erisco> that is what I meant :)
17:14:00 <erisco> :t uncurry const
17:14:00 <lambdabot> (c, b) -> c
17:14:11 <MagneticDuck> what?
17:14:13 <MagneticDuck> :t uncurry
17:14:14 <lambdabot> (a -> b -> c) -> (a, b) -> c
17:14:15 <Eduard_Munteanu> athan: the basic idea: you have type variables and function types. Clearly if you apply something it must be a function, and the argument type must match the type of the thing you apply it to.
17:14:25 <Axman6> :t uncurry (flip const)
17:14:26 <lambdabot> (a, c) -> c
17:14:36 <MagneticDuck> /
17:14:39 <MagneticDuck> oh I get it x|
17:14:41 <MagneticDuck> lols
17:14:47 <kuribas> athan: Types behave kind of like functions: http://www.haskell.org/haskellwiki/GADTs_for_dummies
17:15:31 <Algebr> I have a silly confusion, say that num :: Double -> Double, num x = x + 1 with num 2 work? I thought that Haskell frowned upon implicit type conversions.
17:15:31 <Eduard_Munteanu> athan: and whenever you have a type variable you can substitute (not pattern-match) something there, as long as you do it consistently
17:15:37 <prooftechnique> :t uncurried id
17:15:38 <lambdabot> (a -> b -> (d, e) -> f) -> (a, b) -> d -> e -> f
17:15:47 <erisco> const is less exciting I guess because it is 2-ary, whereas id is 1-ary and so surprising when used with uncurry
17:15:48 <prooftechnique> :t uncurried (flip const)
17:15:49 <lambdabot> (a -> b -> c) -> ((d, e) -> f) -> d -> e -> f
17:15:49 <nolrai66> :t 2
17:15:49 <lambdabot> Num a => a
17:15:52 <Eduard_Munteanu> Algebr: what implicit conversion?
17:16:03 <Algebr> Eduard_Munteanu: Its taking an Int and converting it into a Double
17:16:19 <nolrai66> 2 can be any Num.
17:16:20 <Eduard_Munteanu> Algebr: no, it's taking a Double
17:16:24 <kuribas> Axman6: right...
17:16:30 <monochrom> Algebr: "num 2" is fine. don't worry about it.
17:16:34 <Algebr> Eduard_Munteanu: but if I pass it an Int, it works.
17:16:47 <Eduard_Munteanu> Algebr: how?
17:17:05 <Algebr> Eduard_Munteanu: That's what I'm asking about.
17:17:06 <erisco> :t iterate ($)
17:17:06 <lambdabot> (a -> b) -> [a -> b]
17:17:12 <erisco> there is another neat one
17:17:39 <Eduard_Munteanu> athan: for instance in 'id :: a -> a' you can substitute 'a' with 'b -> c' to get 'id :: (b -> c) -> (b -> c)'
17:17:40 <nolrai66> > let num n = n + 2.0 in num (1 :: Int)
17:17:41 <MagneticDuck> > (read :: String -> Double) "2" -- Algebr?
17:17:41 <lambdabot>  No instance for (GHC.Real.Fractional GHC.Types.Int)
17:17:42 <lambdabot>    arising from a use of `num'
17:17:42 <lambdabot>  Possible fix:
17:17:42 <lambdabot>    add an instance declaration for (GHC.Real.Fractional GHC.Types.Int)
17:17:42 <lambdabot>  can't find file: L.hs
17:17:46 <kuribas> Axman6: As long as there is a type variable in the member.
17:17:54 <Eduard_Munteanu> Algebr: how are you passing it? Can you show the code?
17:17:55 <MagneticDuck> .......
17:17:59 <MagneticDuck> > (read :: String -> Double) "2" -- Algebr?
17:17:59 <lambdabot>  2.0
17:18:07 <Algebr> Eduard_Munteanu: num :: Double -> Double
17:18:09 <Algebr> num a = a + 1
17:18:21 <Algebr> loading it into ghci, then entering num 2
17:18:25 <Eduard_Munteanu> Algebr: and what's the Int?
17:18:28 <Algebr> and getting back 3.0
17:18:37 <MagneticDuck> > 2 :: Double
17:18:38 <lambdabot>  2.0
17:18:38 <Eduard_Munteanu> 2 is a Double there, not Int.
17:18:57 <Algebr> Eduard_Munteanu: then ghci cast my Int into a Double?
17:19:15 <MagneticDuck> Algebr: I don't know what Int you have to start with
17:19:16 <Eduard_Munteanu> Algebr: it's not an Int :)
17:19:23 <MagneticDuck> the function requires a Double
17:19:29 <MagneticDuck> ghci sees a Double
17:19:33 <MagneticDuck> the function returns a Double
17:19:44 <mindleyhilner> the literal 2 is polymorphic
17:19:50 <Algebr> but 2 is an Int, now granted if I do `let a = 2` and then num a, it craps out.
17:19:52 <mindleyhilner> :t 2
17:19:53 <lambdabot> Num a => a
17:19:55 <Eduard_Munteanu> Algebr: the idea is number *literals* like 5 are desugared into 'fromInteger 5', and thus '5 :: (Num a)'
17:20:14 <Eduard_Munteanu> 2 is a literal and its type is not Int.
17:20:18 <MagneticDuck> :t 2
17:20:19 <lambdabot> Num a => a
17:20:31 <Algebr> Eduard_Munteanu: ahh, okay, now that makes sense.
17:20:35 <Algebr> Eduard_Munteanu: Thank you, as always.
17:20:48 <Eduard_Munteanu> No problem, as always. :)
17:20:58 <erisco> > fmap ($1) $ iterate ((+1).) id
17:20:59 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
17:21:11 <Aetherspawn> could a socket be a lens
17:21:23 <Aetherspawn> it has that bidirectional kind of feel about it, but I can't put my finger on what kind of lens it would be
17:22:17 <Eduard_Munteanu> Aetherspawn: er, like a networking socket? I don't see anything in common.
17:22:37 <sipa> an eyesocket might be a lens
17:22:46 <Aetherspawn> a network socket yeah
17:23:41 <Aetherspawn> I would imagine something like this
17:23:45 <edwardk> Aetherspawn: you won't be able to get the to work out in the end, monadic lenses typically don't work
17:24:00 <Aetherspawn> I was thinking of a lens with pipes inside
17:24:23 <athan> HOW THE....???
17:24:28 <athan> Sorry I was pre-occupied
17:24:29 <athan> wow
17:24:30 <Aetherspawn> so you have like, Socket -> Lens' Producer Consumer
17:24:33 <Aetherspawn> it's a stretch..
17:24:34 <athan> :t uncurry const
17:24:34 <lambdabot> (c, b) -> c
17:24:41 <athan> I have no idea how that happens ^
17:24:55 <sipa> Aetherspawn: lenses are like hammers; they make every problem look like nails
17:25:16 <Eduard_Munteanu> Aetherspawn: is Consumer a part of Producer in any reasonable way?
17:25:19 <Algebr> Silly question: Does the order of stuff written in the deriving tuple matter?
17:25:23 <athan> Ha!
17:25:36 <Eduard_Munteanu> Algebr: no, not AFAIK.
17:25:38 <athan> Algebr: Naw
17:25:46 <Aetherspawn> Eduard_Munteanu: they are both pipes
17:25:51 <athan> Algebr: You may have to include pragmas, though, like deriving Functor
17:25:55 <Aetherspawn> consumer eats ByteStrings and producer produces ByteStrings
17:26:17 <athan> Aetherspawn: I'm actually trying to write a telnet client in conduit right now
17:26:32 <athan> Aetherspawn: Having trouble with encodings, but damn that library is awesome!
17:26:55 <Aetherspawn> conduit has some issues with fully streaming input over tcp
17:26:56 <athan> Aetherspawn: I really want to build on it for encoding matching via types, and have encoding conversion done internally
17:27:15 <athan> Aetherspawn: Really? Like what?
17:27:38 <Aetherspawn> its cereal/binary parse isn't a real parse. it throws away the remainder input
17:27:42 <Algebr> Monad Question: Is intuition correct? A Monad encapsulates a sequence of events.
17:27:47 <Algebr> this*
17:28:00 <athan> Algebr: Yes, it can
17:28:00 <sipa> Algebr: sometimes
17:28:19 <athan> Algebr: It's more how you use that encapsulation that creates the monad pattern
17:28:50 <sipa> i'd say it represents a computation
17:28:54 <Algebr> athan: So a Monad isn't a "thing", its a pattern of doing stuff?
17:29:03 <sipa> Algebr: forget monads
17:29:05 <sipa> Algebr: now
17:29:14 <athan> Algebr: listen to sipa!
17:29:22 <sipa> learn the IO type
17:29:24 <sipa> and the list type
17:29:26 <sipa> and the maybe type
17:29:32 <Algebr> lol, okay.
17:29:32 <athan> Algebr: it is technically a thing, but it's how it's used that makes it useful and popular
17:29:42 <athan> Algebr: Learn Functors!!!
17:29:46 <geekosaur> sort of
17:29:48 <athan> Algebr: Do you know functors yet?
17:29:50 <sipa> and once you realize they have something in common... that common thing will be a monad, but it's not very useful as such
17:29:58 <Algebr> I used mapM_, is that a functor?
17:30:05 <athan> Algebr: Nien
17:30:09 <MagneticDuck> Algebr: 9
17:30:14 <geekosaur> it's a pattern based on an abstract mathematical "thing". that abstraction is so general that trying to understand the thing is kinda pointless
17:30:14 <dmj`> Algebr: a monad in haskell is implemented as a typeclass, w/ its own set of laws
17:30:15 <athan> Algebr: it's a function that works upon functors
17:30:15 <MagneticDuck> :t mapM
17:30:16 <lambdabot> Monad m => (a -> m b) -> [a] -> m [b]
17:30:32 <MagneticDuck> (mapM_ just discards the result)
17:30:47 <MagneticDuck> but anyway, forget monads :D
17:30:56 <dmj`> all monads are functors, but not all functors are monads
17:30:57 <athan> Algebr: A monad is very similar to a functor
17:31:03 <athan> in fact, a monad IS a functor
17:31:10 <athan> but kinda like the square/rectangle problem
17:31:17 <athan> a functor isn't necessarrilly a monad
17:31:25 <MagneticDuck> geekosaur: "it's a pattern based on an abstract mathematical "thing" ..." <-- great introduction to any subject related to haskell xD
17:31:27 <geekosaur> (also, how the abstract mathematical thing interacts with a real programming language gets rather "interesting", so it's not really something to focus on too much at this point)
17:31:33 <athan> functors are also a subset of applicative's
17:31:42 <sipa> Algebr: seriously, ignore everything above about monads here
17:31:54 <sipa> Algebr: just learn some of the interesting types in haskell
17:31:57 <Aetherspawn> is a Lens still a good behaving lens if I make it take an argument?
17:32:04 <Aetherspawn> ie Socket -> Lens Something1 Something2
17:32:11 <Aetherspawn> or is that frowned upon
17:32:33 <athan> Aetherspawn: I think if you wrap the application in a nice pattern, you're fine
17:32:33 <MagneticDuck> I gotta start using lenses
17:32:37 <kuribas> Algebr: What sipa says.  Once you have looked at these instance, then you compare their types, and you see why they are similar.
17:32:38 <Eduard_Munteanu> That's a function returning a lens.
17:32:40 <edwardk> Aetherspawn: at works that way, but when it comes down to it, i don't think you'll be able to pass the laws with what you want
17:33:06 <Aetherspawn> I'm looking at the usage in pipes-binary which doesn't pass the laws
17:33:07 <Algebr> Hmm, okay.
17:33:07 <athan> Aetherspawn:  like how (MonadReader => r; (->) r) is a monad
17:33:17 <Aetherspawn> but the interface is quite nice as a result of it being a lens anyway
17:33:54 <kuribas> Algebr: Monads don't have to be very similar, except for their types.
17:34:00 <athan> Is there a good source for type systems research?
17:34:06 <athan> Liek for adga + others, too?
17:34:10 <athan> I love this science
17:34:20 <Eduard_Munteanu> athan: "source"? What do you mean?
17:34:35 <Eduard_Munteanu> Resources?
17:34:38 <athan> yeah!!
17:34:42 <athan> sorry haha
17:34:58 <athan> I want to get all the "functional pearls" down
17:35:10 <athan> And all of Mark P. Jones work
17:35:15 <athan> but that's all I really know of
17:35:17 <Eduard_Munteanu> athan: TAPL is a good introduction to type systems generally, although it doesn't touch dependent types.
17:35:35 <athan> I don't know of any of the classifications, or any structure of them. Haskell is the only thing that I can relate to
17:35:44 <athan> TAPL?
17:35:46 <dmj`> athan: if you're into types anything here: http://www.cis.upenn.edu/~bcpierce/
17:35:47 <ReinH> Eduard_Munteanu: TAPL 2: Revenge of the Types (or whatever it's called) does.
17:35:51 <Iceland_jack> athan: Types and Programming Languages
17:35:52 <athan> hahaha
17:35:57 <athan> AWESOME!!!!!!!!
17:35:59 <athan> Thank you!!!
17:36:10 <Aetherspawn> No problem!!!!
17:36:15 <ReinH> Yay!!!!
17:36:18 <ReinH> Why are we shouting?
17:36:20 <Iceland_jack> audax333: There is also a 'sequel' on advanced types that covers dependent types
17:36:22 <Aetherspawn> I dont know!!!
17:36:28 <sipa> ReinH: you're not; you're asking a question
17:36:30 <ReinH> Iceland_jack: that's what I was referring to :p
17:36:36 <ReinH> sipa: why not both?
17:36:37 <athan> "I stabbed a guy with a trident!"
17:36:58 <Iceland_jack> oops, athan, not audax333
17:37:05 <Eduard_Munteanu> athan: for Agda-like stuff you might want to go through Ulf's tutorial or even the Epigram stuff: http://wiki.portal.chalmers.se/agda/agda.php?n=Main.Documentation
17:37:13 <Iceland_jack> athan: Advanced Topics in Types and Programming Languages
17:37:13 <athan> class About a => Yell a b where...
17:37:50 <athan> Supreme information right here
17:38:09 <athan> Thank you Iceland, Eduard, ReinH, Aether, etc.
17:38:12 <athan> You are all so awesome
17:38:47 <Algebr> How can I use record syntax when I have multiple value constructors?
17:39:11 <sipa> Algebr: you just do :)
17:39:23 <Aetherspawn> Algebr: it works, but its kind of unsafe
17:39:31 <Aetherspawn> the compiler doesn't give you any nice things
17:39:35 <geekosaur> the only gotcha is that things with the same name must have the same type
17:39:36 <Eduard_Munteanu> Algebr: data Foo = Bar { x :: Integer } | Boo { y :: Bool }
17:39:37 <Iceland_jack> athan: There is a course at Chalmers (the birthplace of Agda) about Agda basically
17:39:41 <Iceland_jack> you can check it out
17:39:46 <Algebr> Aetherspawn: Why is it unsafe?
17:39:54 <Aetherspawn> if you have a Bar and you use y on it
17:39:55 <Iceland_jack> athan: http://www.cse.chalmers.se/edu/year/2013/course/DAT140_Types/
17:39:56 <Aetherspawn> you get an error
17:40:01 <Algebr> Eduard_Munteanu: Ah, I should have tried it first.
17:40:12 <Aetherspawn> likewise if you have a Boo but use x on it
17:40:20 <Aetherspawn> it's not "as safe" as ADTs
17:40:41 <Aetherspawn> well, 'yknow what I mean.
17:40:48 <Eduard_Munteanu> With -Wall it should be rather safe.
17:41:04 <Aetherspawn> does -Wall warn you about it?
17:41:09 <Eduard_Munteanu> Yes.
17:41:13 <Aetherspawn> Oh cool
17:41:57 <Eduard_Munteanu> Er, wait, actually I thought you were talking about partial initializers, not sure about accessors.
17:42:06 <athan> why would a record syntax have anything unsafe about it?
17:42:11 <athan> er
17:42:19 <athan> multi-constructor records?
17:42:25 <Eduard_Munteanu> athan: yes
17:42:31 <athan> becuase the functions aren't fully comprehensive?
17:42:41 <athan> they don't handle every instance of the data type?
17:43:03 <Eduard_Munteanu> Because if you don't match the constructor you don't really know it's the one you need.
17:43:15 <athan> oh woah
17:43:26 <athan> so the functions that the record syntax creates don't match on the constructors?
17:43:32 <Aetherspawn> ... wat
17:43:36 <athan> I would think that it totally would...
17:43:42 <athan> just to be safe haha
17:43:49 <Aetherspawn> data Foo = Bar { a :: Int } | Qux { b :: Bool }
17:43:53 <Eduard_Munteanu> (\(Just x) -> x) Nothing
17:43:56 <Eduard_Munteanu> > (\(Just x) -> x) Nothing
17:43:57 <lambdabot>  *Exception: <interactive>:3:2-15: Non-exhaustive patterns in lambda
17:44:07 <Aetherspawn> let x = Bar 3
17:44:08 <athan> ahhhhh
17:44:09 <Aetherspawn> a x = ?
17:44:14 <athan> yes see that's what I meant
17:44:15 <Aetherspawn> oh, a x is valid
17:44:16 <Aetherspawn> b x = ?
17:44:25 <athan> the function isn't comprehensive to all possabilities within the datatype
17:44:36 <Algebr> Why is it that Microsoft is so involved with Haskell's history/development? Is it just a playground for F#? Like Haskell is Fedora and F# is Redhat.
17:45:09 <hpc> essentially, yes
17:45:18 <Eduard_Munteanu> I thought F# was a side-effect, a byproduct of MSR wanting to justify their research. :P
17:45:22 <hpc> and for .NET in general, with code generation and larger compiler concepts
17:45:24 <athan> HA
17:45:27 <Cale> Algebr: Because Simon Peyton Jones was hired by MSR, and for essentially no other reason
17:45:27 * hackagebot purescript 0.4.9 - PureScript Programming Language Compiler  http://hackage.haskell.org/package/purescript-0.4.9 (PhilFreeman)
17:45:29 * hackagebot elm-repl 0.2.1 - a REPL for Elm  http://hackage.haskell.org/package/elm-repl-0.2.1 (EvanCzaplicki)
17:45:34 <merijn> Algebr: Because MS Research is one of the most renowned academic research institutions in the world
17:46:07 <merijn> Algebr: They're not really doing any R&D for MS, but more real acadmic science stuff
17:46:11 <Eduard_Munteanu> Also F*.
17:46:14 <Aetherspawn> (」ﾟヘﾟ)」F#
17:46:20 <Aetherspawn> come at me Haskell
17:46:40 <merijn> Algebr: Occasionally they will help develop something practical like F#, but that's not really what employees normally work on at MSR
17:46:43 <athan> HA
17:46:50 <Aetherspawn> F# is not very good IMO
17:47:16 <merijn> Aetherspawn: If your criterium is .NET/Windows development, it's pretty okay
17:47:41 <athan> hey guys so I'm thinking of making something crazy-
17:47:48 <athan> an FRP solution to the client-server model
17:48:07 <merijn> Aetherspawn: I'd see it as OCaml with better windows support :p
17:48:11 <athan> built on top of web sockets, yesod, and tons of html-safety mechanisms and possibly elm/fay
17:48:12 <ion> Why does it take so long for Hackage to build the documentation for new packages?
17:48:26 <athan> I really want it to be like...
17:48:28 <Aetherspawn> ion: its probably on a cron
17:48:40 <athan> a live effect creation environment
17:48:40 <merijn> ion: Are you sure it's still pending and not failed on building your package?
17:48:53 <Aetherspawn> merijn: the only people who use OCaml are jane street
17:49:05 <ion> merijn: Pretty sure.
17:49:10 <Aetherspawn> because the guy who gives all the talks doesn't like haskell
17:49:14 <Aetherspawn> /naive
17:49:30 <athan> haskell does have flaws
17:49:30 <merijn> ion: Which package?
17:49:39 <athan> but idk about ocaml lol
17:49:50 <ion> merijn: http://hackage.haskell.org/package/quadratic-irrational
17:49:53 <dolio> F# removes some key features of OCaml.
17:49:56 <athan> i really find elm's applicative syntax pleasant
17:49:59 <dolio> Unfortunately.
17:50:06 <Aetherspawn> imo haskell is pretty solid
17:50:11 <athan> they explicitly show how applicatives are functors
17:50:12 <Aetherspawn> there are flaws in prelude at the moment
17:50:17 <dolio> But it's still better than C#.
17:50:22 <athan> yeah that's what concerns me :/
17:50:27 <athan> YES
17:50:32 <dmj`> Aetherspawn: in Prelude?
17:50:46 <Aetherspawn> but those "flaws" in prelude might actually be warranting a language extension to fix rather than a prelude mod
17:50:49 <athan> dolio: what key features?
17:50:57 <dolio> Higher-order modules.
17:50:58 <Aetherspawn> dmj`: yeah, have you ever imported Map, Set, List etc
17:51:00 <merijn> ion: Failed: http://hackage.haskell.org/package/quadratic-irrational-0.0.3/reports/1/log
17:51:04 <Aetherspawn> and then had like M, L, LL, S, IS
17:51:05 <athan> ehh, see that's what gets me
17:51:10 <athan> I think it needs a redesign
17:51:13 <Algebr> hmm, I know these kinds of questions are frowned upon, but I'm really curious if people "feel" that programming zeitgeist is moving in Haskell's direction. Like, is there some kind of metric to show that HAskell usage has increased?
17:51:18 <merijn> ion: See here for how to manually upload docs: http://fuuzetsu.co.uk/blog/posts/2014-01-06-Fix-your-Hackage-documentation.html
17:51:20 <dmj`> Aetherspawn: yea
17:51:22 <Aetherspawn> I was talking to someone the other day
17:51:26 <Aetherspawn> was talking about how scala solves it
17:51:34 <Aetherspawn> they have automatic type based import resolution
17:51:48 <ion> merijn: Huh. Thanks. In the future, how can i tell it failed?
17:51:49 <Aetherspawn> so if you have x :: Map and you have import Data.Map and import Data.Set
17:51:52 <dmj`> Aetherspawn: When I switched from Data.Map to Data.HashMap I only had to change the import name, since all functions are the same name, was nice
17:51:56 <Aetherspawn> insert x comes from Data.Map
17:52:07 <Aetherspawn> but if x were a Set
17:52:12 <merijn> ion: Go to that log and check? There's no notification atm
17:52:12 <Aetherspawn> insert x would come from Data.Set
17:52:19 <ion> merijn: ok
17:52:27 <dmj`> Aetherspawn: true, is that an error though?
17:52:27 <merijn> ion: Although, feel free to provide a pull request for the Hackage server to add it :>
17:52:43 <Aetherspawn> dmj`: that would be the proposed fix.
17:52:49 <Aetherspawn> It's quite optimal behaviour
17:53:11 <Aetherspawn> slightly less "safe", kinda.
17:53:20 <zRecursive> :t fix
17:53:21 <lambdabot> (a -> a) -> a
17:53:24 <dmj`> Aetherspawn: So the ghc would infer the import based on usage?
17:53:32 <Aetherspawn> based on the types used yeah
17:53:39 <dmj`> that would be cool
17:53:43 <dolio> No.
17:53:50 <SrPx_> Why this won't parse?
17:53:54 <SrPx_> woops. This: http://lpaste.net/101732
17:54:00 <Aetherspawn> dolio said no.
17:54:03 <Aetherspawn> I am intrigued.
17:54:20 <merijn> SrPx_: 'a' and 'b' don't line up
17:54:36 <SrPx_> Ah nevermind, sorry. Didn't notice I had a space instead of a tab
17:54:41 <SrPx_> merijn: yep thanks
17:54:50 <dolio> I like my ad-hoc overloading to be less ad-hoc.
17:55:20 <Aetherspawn> actually, if the framework is there
17:55:25 <SrPx_> http://lpaste.net/101732 still won't parse, why?
17:55:25 <Aetherspawn> it also solves one other issue
17:55:36 <Aetherspawn> the uhh, overloaded record field stuff
17:55:57 <merijn> SrPx_: You lined up else with if
17:56:08 <dolio> People need to get over their record overloading, too.
17:56:18 <dolio> Although it's being solved anyhow.
17:56:21 <dmj`> SrPx: http://lpaste.net/101734
17:56:23 <SrPx_> merijn: pardon?
17:56:24 <dolio> In a way that's actually good.
17:56:29 <merijn> SrPx_: See https://en.wikibooks.org/wiki/Haskell/Indentation for explanation of layout
17:57:00 <SrPx_> dmj`: this uses spaces ): my code is tab based. merijn okay thanks...
17:57:42 <dmj`> SrPx_: my tabs are 4 spaces, think that's the way haskell-mode does it
17:58:10 <SrPx_> Okay, I'll try haskell-mode later
17:58:41 <ion> merijn: Okay, uploaded manually and that worked. Thanks. I’m still not sure why it failed.
17:58:44 <Zer000> would anyone here know of an easy to follow resource that explains context free grammar?
17:59:15 <ion> “cabal: dist/doc/html/quadratic-irrational/haddock-prolog24563.txt: invalid argument” probably means *something*. :-P
18:00:29 * hackagebot wai-app-file-cgi 2.0.2 - File/CGI/Rev Proxy App of WAI  http://hackage.haskell.org/package/wai-app-file-cgi-2.0.2 (KazuYamamoto)
18:01:29 <dmj`> haskell + windows == hell
18:01:44 <haasn> windows == hell
18:02:00 <Aetherspawn> ghc needs some work on windows..
18:02:35 <ion> By commutativity, hell = windows
18:02:46 <dmj`> haasn: getting this project to build on windows takes acrobatics
18:02:57 <Aetherspawn> well
18:03:01 <ion> Also, haskell = 0. QED
18:03:03 <Aetherspawn> windows + msys2 is kind of cozy
18:03:18 <dmj`> installing network on windows is so bad that both neil mitchell and johann tibbe wrote blog posts on it
18:03:45 <dmj`> http://neilmitchell.blogspot.com/2010/12/installing-haskell-network-library-on.html
18:03:46 <haasn> ion: no. windows is just an absorptive element of +
18:03:46 <Aetherspawn> I demented something in my installation
18:03:58 <Aetherspawn> waiting on GHC 7.8 rc2
18:04:02 <Aetherspawn> rather, rc3 or release.
18:04:05 <Aetherspawn> to bother fixing everything
18:04:08 <dmj`> Aetherspawn: are you able to build network and HsOpenSSL on windows?
18:04:16 <haasn> ion: adding windows to anything results in hell, just like multiplying anything by zero results in zero
18:04:24 <Aetherspawn> uh, cbits tend to work OK if you run cabal from inside mingw
18:04:26 <haasn> (especially buildings)
18:04:46 <Aetherspawn> and interestingly if you run msys2 some unix only stuff works too
18:05:00 <Aetherspawn> due to it pretending to be linux and having compatibility headers..
18:05:04 <haasn> “subtracting windows” is like dividing by zero.
18:05:06 <dmj`> Aetherspawn: I have a cygwin terminal, mingw terminal and dos terminal. The network pkg won't even configure in dos and mingw
18:05:19 <Aetherspawn> orginal mingw or msys2 ?
18:06:28 <dmj`> original mingw
18:06:36 <dmj`> it configures in cygwin64 terminal
18:07:20 <SrPx_> Okay, I read that article (and I managed to make it work), but I still don't see why http://lpaste.net/101734 particularly won't parse? Seems like everything is according to what was written
18:07:41 <dmj`> Aetherspawn: Per neil mitchell's blog post (from 4.5 years ago), this command allows network to install and link:
18:07:49 <dmj`> cabal install network --configure-option --host=i386-unknown-mingw32
18:08:44 <dmj`> Aetherspawn: and then HsOpenSSL: cabal install HsOpenSSL --extra-include-dirs=\"C:/OpenSSL-Win32/include\" --extra-lib-dirs=\"C:/OpenSSL-Win32/
18:08:54 <dmj`> after installing the libs
18:09:01 <Aetherspawn> iunno
18:09:09 <Aetherspawn> I'd rather not jump through hoops
18:09:33 <jrmithdobbs> am I evil for wishing unity3d introduced a monad metaphor instead of using ienumerable/coroutines to span actions over render loop iterations?
18:10:08 <Aetherspawn> evil for not using Lambdacube3D
18:10:16 <jrmithdobbs> "i have this sequence of actions which should run in-time with this other sequence of actions" sure sounds like a bunch of monads to me
18:10:39 <dmj`> Aetherspawn: what do you mean not jump through hoops? How did you get rid of the hoops
18:11:03 <Aetherspawn> the only strange library I've installed before is curl
18:11:09 <Aetherspawn> and it worked first time on msys2
18:11:15 <Aetherspawn> after I installed the system curl package using pacman
18:12:05 <dmj`> Aetherspawn: Does the terminal choice matter only because of the C lib paths?
18:12:42 <Aetherspawn> the terminal generally doesn't matter, the environment does
18:12:53 <dmj`> Aetherspawn: I assume you installed the curl package succesfully in MSYS using the mingw package manager, not the cygwin pkg manager
18:13:06 <Aetherspawn> msys2 has pacman from arch linux
18:13:39 <dmj`> no way
18:14:54 <Aetherspawn> yes way
18:15:12 <dmj`> Aetherspawn: Oh, I've been using msys2 I guess, when I say mingw terminal that's what it's running
18:16:14 <dmj`> Aetherspawn: too bad .bashrc isn't shared between cygwin and msys2
18:21:47 <Aetherspawn> just had to configure voicemail. I sound like an ass.
18:22:10 <Aetherspawn> "Hi, you'd be better off just sending me a text. If you must leave a message, do it after the tone and don't forget to press hash. Thanks"
18:22:42 <Aetherspawn> I rememeber back when voicemail wasn't such a painful thing to use... /ot
18:24:27 <fizbin> Hey, edwardk, what ever happened to http://www.haskell.org/pipermail/libraries/2012-July/018248.html and the Data.Traversable instances for (Either a) and ((,) a) ?
18:25:43 <fizbin> Huh. It's in the git tree, so I guess it got that far...
18:26:49 <dmj`> Aetherspawn: why does everyone say msys is better than cygwin
18:27:02 <dmj`> w/o justification of course
18:27:02 <Aetherspawn> cygwin only works if the other person has cygwin
18:27:16 <Aetherspawn> msys is a proper toolchain without emulation libs
18:27:17 <Eduard_Munteanu> They serve different purposes anyway.
18:27:25 <Aetherspawn> well, msys == cygwin
18:27:29 <Aetherspawn> but msys as used by mingw
18:27:42 <Eduard_Munteanu> I don't think so.
18:27:57 <Aetherspawn> the msys in MinGW is an ancient fork of the msys in cygwin
18:28:12 <Aetherspawn> msys2 is just MinGW using the more recent msys from cygwin
18:28:14 <Eduard_Munteanu> Cygwin is supposed to provide a Linux-compatible POSIX API on Windows.
18:28:43 <Eduard_Munteanu> That is, to port stuff directly.
18:29:00 <Aetherspawn> I've been reading about exokernels lately
18:29:01 <Eduard_Munteanu> msys on the other hand provides no compatibility layer.
18:29:04 <Aetherspawn> I really like the idea.
18:32:26 <dmj`> how does lack of emulation improve the cabal install process on windows
18:33:01 <fizbin> > traverse Right Nothing
18:33:02 <lambdabot>  Right Nothing
18:33:19 <geekosaur> depends on the kind of pain you want, I think. in general the emulation is imperfect
18:33:27 <fizbin> > traverse (const $ Left "boo") Nothing
18:33:28 <geekosaur> and breaks in bizarre ways
18:33:28 <lambdabot>  Right Nothing
18:36:30 <SrPx_> Wow my Haskell program performs worse than my JS equivalent ):
18:41:47 <dmj`> so close, so close
18:42:11 <dmj`> HsOpenSSL installs, but doesn't load properly: http://lpaste.net/101741
18:42:53 <dmj`> w/ cabal install HsOpenSSL --extra-include-dirs=\"C:/OpenSSL-Win32/include\" --extra-lib-dirs=\"C:/OpenSSL-Win32/\" on Windows Server 2008. GHC 7.6.3 (32-bit)
18:43:24 <dmj`> why wouldn't ghc be able to load eay32.dll?
18:44:02 <dmj`> Aetherspawn: any idears?
18:45:47 <pavonia> I guess you've already checked, but is it on the path?
18:48:08 <dmj`> pavonia: I think so, I'll print the path, here's what the application log gives
18:48:11 <dmj`> http://lpaste.net/101744
18:49:44 <pavonia> dmj`: That's a different file name
18:50:26 <pavonia> I had similar problems once with gtk where I had to rename some .dll files
18:51:55 <dmj`> pavonia: woa
18:52:00 <Rufflewind> It says it's missing VC90.CRT for some reason
18:52:15 <Rufflewind> have you tried installing the CRT then?
18:54:08 <dmj`> Rufflewind: yes, those have to be installed before the openssl libs
18:54:09 <dmj`> http://slproweb.com/products/Win32OpenSSL.html
18:54:19 <dmj`> Rufflewind: it's possible I installed an incorrect version
18:55:17 <dmj`> According to the ghc docs you're not supposed to install the light version, I'll reinstall to be sure
18:55:18 <dmj`> https://ghc.haskell.org/trac/ghc/wiki/Builder
18:55:55 <dmj`> Aetherspawn: I might try copying eay32.dll to libeay32.dll as well
18:58:02 <dmj`> do I install the 64 or 32-bit VC, that is the question
18:58:38 <dmj`> since ghc is 32 I think it has to be 32
19:10:37 * hackagebot ivory-backend-c 0.1.0.0 - Ivory C backend.  http://hackage.haskell.org/package/ivory-backend-c-0.1.0.0 (LeePike)
19:10:47 <SrPx_> http://www.reddit.com/r/haskell/comments/21doog/why_this_haskell_program_runs_considerably_slower/
19:10:58 <SrPx_> if anyone would look into that I'd be really thankful... frustrating \;
19:11:16 <copumpkin> glguy: ivory :O
19:11:35 <glguy> Yeah, someone poked the guys to put it on hackage :)
19:12:33 <flebron> Is there a standard recursion scheme which is like a foldr, but supports a "break"?
19:12:50 <copumpkin> foldr does support a break
19:13:21 <copumpkin> > foldr (&&) $ [True, True, False] ++ repeat True
19:13:22 <lambdabot>  Couldn't match expected type `GHC.Types.Bool'
19:13:22 <lambdabot>              with actual type `[GHC.Types.Bool]'
19:13:26 <copumpkin> > foldr (&&) True $ [True, True, False] ++ repeat True
19:13:27 <lambdabot>  False
19:13:41 <copumpkin> took it a while to iterate to infinity
19:14:00 <flebron> Ah, cool, yes :) Thanks!
19:15:37 * hackagebot ivory-bitdata 0.2.0.0 - Ivory bit-data support.  http://hackage.haskell.org/package/ivory-bitdata-0.2.0.0 (LeePike)
19:15:45 <ReinH> > any even [1..]
19:15:46 <lambdabot>  True
19:16:03 <Iceland_jack> > any even (repeat 1 ++ [2])
19:16:07 <lambdabot>  mueval-core: Time limit exceeded
19:16:20 <Iceland_jack> Bad lambdabot! the 2 is obviously even!
19:17:08 <dmj`> on windows is it necessary to specify "hs-source-dirs" in your cabal file?
19:25:39 * hackagebot ivory-backend-c 0.1.0.1 - Ivory C backend.  http://hackage.haskell.org/package/ivory-backend-c-0.1.0.1 (LeePike)
19:26:35 <dmj`> Aetherspawn, pavonia: got it, I had installed VC x64, not VC x86.
19:30:24 <SrPx_> anyone? ):
19:30:39 * hackagebot ivory-opts 0.1.0.1 - Ivory compiler optimizations.  http://hackage.haskell.org/package/ivory-opts-0.1.0.1 (LeePike)
19:33:24 <pavonia> SrPx_: Adding some more strictness would probably help, e.g. data Qt = Qt { !qx :: Double , !qy :: ... }
19:34:26 <dmj`> Are the GHC 7.8RC's available in binary or do I need to compile them myself?
19:34:45 <pavonia> dmj`: x86 is the 32-bit version?
19:34:55 <sylvanica> SrPx_: what was your question?
19:35:09 <no-n> how do i update GHC on OS X mavericks?
19:35:10 <SrPx_> pavonia: trying to do it \:
19:35:45 <SrPx_> sylvanica: I'm wondering why my haskell program runs considerably slower than the javascript equivalent.
19:35:50 <SrPx_> sylvanica: linked above there
19:36:20 <pavonia> sylvanica: http://www.reddit.com/r/haskell/comments/21doog/why_this_haskell_program_runs_considerably_slower/
19:36:52 <dmj`> pavonia: I had the Visual C++ 2008 Redistributables (x64) installed, and the OpenSSL 32-bit libs installed
19:37:35 <sylvanica> wow weechat sucks at big links!
19:37:46 <sylvanica> Having a look-see.
19:37:51 <dmj`> no-n: if you have cabal sandboxes you can use multiple ghc installations
19:37:58 <dmj`> no-n: cabal install --only-dependencies -w /path/to/ghc-1
19:38:06 <no-n> the last time i ran cabal something odd happened
19:38:51 <no-n> warned me of a non-void C function that reaches its end without a return statement among other things :S
19:41:12 <dmj`> no-n: did you install w/ the haskell-platform?
19:41:16 <dmj`> or homebrew?
19:41:21 <no-n> platform, i think
19:42:08 <sylvanica> SrPx_: did you follow pavonia's suggestion? I'm curious if that made a difference.
19:42:58 <SrPx_> I'm here failing in do it. Let me try again
19:43:03 <SrPx_> I just add "!"s?
19:43:25 <thebnq> SrPx_: I got a x5 speedup using foldl' in both places
19:43:27 <SrPx_> I get syntax errors with the !'s
19:43:27 <sylvanica> SrPx_: yes, it adds 'strictness'
19:43:56 <thebnq> yea .. strictness
19:44:12 <SrPx_> before the qx? This won't compile: data Qt = Qt { !qx :: Double, qy :: Double, qz :: Double, qw :: Double } deriving (Show)
19:44:20 <SrPx_> thebnq: oh great! I completely forgot that! :D
19:44:28 <SrPx_> let me test with foldl'
19:45:41 * hackagebot ivory-hw 0.1.0.0 - Ivory hardware model (STM32F4).  http://hackage.haskell.org/package/ivory-hw-0.1.0.0 (LeePike)
19:46:28 <SrPx_> No speedup here from using foldl'... are you sure?
19:47:27 <thebnq> with -O2?
19:49:23 <dmj`> SrPx_: use vector
19:49:46 <dmj`> and compile w/ -O2 -fllvm
19:49:58 <SrPx_> Sorry I was doing it wrong, got a 3x speedup from using foldl' (: that is nice, but it is still 2x slower than js /:
19:50:03 <SrPx_> dmj`: -fllvm?
19:50:47 <zRecursive> @src foldl'
19:50:48 <lambdabot> foldl' f a []     = a
19:50:48 <lambdabot> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
19:50:58 <thebnq> yea vector is probably the second point though, i assume the js one is using arrays so its not a direct translation of algorithm
19:51:09 <dmj`> SrPx_: http://www.haskell.org/ghc/docs/7.6.3/html/users_guide/code-generators.html#llvm-code-gen
19:51:19 <dmj`> "It generally produces code as with performance as good as the native code generator but for some cases can produce much faster code. This is especially true for numeric, array heavy code using packages like vector."
19:51:37 <dmj`> "for some reason"
19:51:47 <SrPx_> Hmm I see... interesting. I'll study on how to use vectors now, I'm not sure
19:51:54 <SrPx_> It is the "unboxed vectors" from the lib, you mean?
19:52:12 <zRecursive> @hoogle vector
19:52:13 <lambdabot> Test.QuickCheck.Arbitrary vector :: Arbitrary a => Int -> Gen [a]
19:52:13 <lambdabot> Test.QuickCheck vector :: Arbitrary a => Int -> Gen [a]
19:52:13 <lambdabot> package vector
19:52:33 <zRecursive> @package vector
19:52:33 <lambdabot> http://hackage.haskell.org/package/vector
19:52:43 <dmj`> you can take advantage of stream fusion
19:52:43 <dmj`> http://hackage.haskell.org/package/vector-0.10.9.1/docs/Data-Vector-Fusion-Stream.html
19:52:59 <StoneCypher> everything in haskell sounds like a ghostbusters reference but
19:53:02 <StoneCypher> that more than most
19:53:56 <dmj`> SrPx_: https://gist.github.com/dmjio/6166076
19:54:46 <SrPx_> dmj`: just wondering, isn't both cases just finding the answer at compile time?
19:55:07 <SrPx_> dmj`: also, does stream fusion work for lists or only vectors?
19:55:36 <SrPx_> zRecursive: I see, but which of those I use? There are 5 versions
19:55:42 * hackagebot ivory-stdlib 0.1.0.0 - Ivory standard library.  http://hackage.haskell.org/package/ivory-stdlib-0.1.0.0 (LeePike)
19:56:56 <SrPx_> also sorry for noobism but where it explains how to use the vector library? The methods etc, I can't find them (yes I never used Hackage)
19:57:34 <SrPx_> sometimes there is a tutorial on the page, but many times there is just a brief package description... how to do on those cases?
19:57:42 <dmj`> SrPx_: I don't think the answers are found at compile time. Unsure it works on lists since they are linked lists, and http://hackage.haskell.org/package/vector
19:57:57 <dmj`> SrPx_: there is a link w/ a tutorial on that page
19:58:13 <SrPx_> (yes but when there isn't?)
19:58:39 <thebnq> can't be a tutorial for each package :b
19:59:46 <pyon> SrPx_: When a library is not well documented, there is not much you can do besides read the types for the exposed definitions and, most importantly, try-it-and-see.
20:00:43 * hackagebot ivory-examples 0.1.0.0 - Ivory examples.  http://hackage.haskell.org/package/ivory-examples-0.1.0.0 (LeePike)
20:00:45 * hackagebot ivory-quickcheck 0.1.0.0 - QuickCheck driver for Ivory.  http://hackage.haskell.org/package/ivory-quickcheck-0.1.0.0 (LeePike)
20:01:05 <prooftechnique> Anyon using Ivory?
20:01:08 <SrPx_> mm I see!
20:01:09 <prooftechnique> It looks neat
20:01:16 <prooftechnique> *Anyone
20:01:24 <SrPx_> I thought there was a place or something I was missing
20:02:46 <dmj`> anyone using ghc 7.8 from a prebuilt binary? Or did you have to compile it yourself?
20:03:07 <td123> dmj`: i don't think 7.8 is out yet
20:03:26 <prooftechnique> The homebrew build is from source, IIRC.
20:03:52 <dmj`> prooftechnique: 7.8 is available via homebrew?
20:03:55 <prooftechnique> I tried it manually from source the other day, but ran into something or other and wiped it
20:04:00 <prooftechnique> dmj`: brew install ghc --devel
20:05:17 <dmj`> prooftechnique: Error: ghc-7.6.3 already installed
20:06:50 <prooftechnique> Ah. Hmm.
20:06:58 <prooftechnique> Also, yay, my hhvm PR went through!
20:07:15 <prooftechnique> dmj`: You can brew unlink ghc and then do it, I think
20:07:31 <prooftechnique> If you don't like it you can just brew rm and then relink the old one
20:08:07 <prooftechnique> Or keep a secondary homebrew installation somewhere else just for experimentation's sake
20:08:54 <dmj`> congrats on the PR, I'd like to keep two ghc's around, not two brews
20:09:47 <dmj`> prooftechnique: do you know if its similar on ubuntu? sudo apt-get ghc --devel?
20:10:18 <prooftechnique> No idea. I don't know if there's a package out for it, yet
20:10:24 <no-n> is ^C the way to stop the forever function
20:10:33 <prooftechnique> Maybe on some especially unstable channel :D
20:10:41 <no-n> hmm, ^D, i suppose
20:12:24 <jmcarthur> it looks like the answer is no, but is there something in the interface of Data.Map that allows me to optimize a hylomorphism where Data.Map is the intermediate data structure? I want to do something like take the intersection of two maps and immediately fold the result. it just seems silly to actually produce the entire intermediate data structure for this.
20:13:25 <prooftechnique> dmj`: Gross as it is, I guess the brew procedure would be brew unlink ghc, brew install ghc --devel, brew unlink ghc, then either brew link ghc-7.6.3 or just leave it unlinked and call everything explicitly
20:16:28 <colDrMcBeardman> jmcarthur, I would think you could build it with mapAccum, no?
20:16:57 <jmcarthur> colDrMcBeardman: I don't see how that is relevant.
20:17:25 <SrPx_> What does this mean? `No instance for (V.Unbox Col) arising from a use of `V.fromList'`
20:18:00 <jmcarthur> SrPx_: it means there's no instance of V.Unbox for the type Col. you need to write one or use a different kind of vector
20:18:08 <colDrMcBeardman> jmcarthur, sorry, I meant Data.Map.fold
20:18:29 <bitemyapp> nuttycom: 'ullo guvna.
20:18:36 <SrPx_> jmcarthur: ... the type Col is defined by me, what does it mean to write an instance of V.Unbox for the type Col?
20:18:40 <jmcarthur> colDrMcBeardman: That still doesn't answer my question. I'm trying to find a way to (possibly even manually) fuse away the intermediate Map
20:19:00 <jmcarthur> SrPx_: Have you ever implemented a type class instance before?
20:19:18 <jmcarthur> SrPx_: e.g. instance Ord Foo where ...
20:19:27 <SrPx_> jmcarthur: I've written simple one but I still haven't studded it
20:19:29 <prooftechnique> @info Unbox
20:19:29 <lambdabot> Unbox
20:19:34 <SrPx_> studied *
20:19:57 <jmcarthur> SrPx_: At your level of experience, I do not recommend writing an Unbox instance. Try just using Data.Vector instead of Data.Vector.Unboxed
20:20:54 <colDrMcBeardman> jmcarthur, you could check in the in the function being folded over the first map whether the current parameter is in the second map. That would effectively eliminate the intermediate map, wouldn't it?
20:20:55 <jmcarthur> SrPx_: Data.Vector may not perform as well in some cases, but doesn't require as much of you to use.
20:21:52 <jmcarthur> colDrMcBeardman: I want to eliminate the intermediate map in something like this:   Map.fold (Map.intersectWith f map1 map2)
20:21:53 <zRecursive> SrPx_: import qualified Data.Vector as V   main = print (V.foldl' (+) 0 (V.enumFromTo 1 1000000000) :: Int)
20:22:01 <nuttycom> bitemyapp: howdy
20:22:04 <zRecursive> import Data.Array.Vector  main = print (sumU (enumFromToU 1 (200000000 :: Int)))
20:22:12 <dx25> Noob question: any recommendations on how i should write f n in http://pastebin.com/aYJuEfWx ?  (See c++ version above -- my haskell function doesn't compile)
20:22:21 <zRecursive> import Data.Vector.Unboxed as U  sumSqrV = U.sum . U.map (^2) . U.filter odd
20:22:40 <bitemyapp> nuttycom: please don't pull a jfischoff and shave your beard.
20:22:41 <SrPx_> jmcarthur: oh okay, thanks
20:23:17 <colDrMcBeardman> jmcarthur, the only way I could see doing it is by making the fold's function parameter something complicated that does the intersection as well as the accumulation.
20:23:44 <jmcarthur> colDrMcBeardman: That's exactly right. I want some sort of hylomorphism.
20:25:04 <jmcarthur> colDrMcBeardman: a fold is a catamorphism. intersectWith is, I think, something of an anamorphism. a catamorphism composed with an anamorphism is a hylomorphism, and hylomorphisms can be optimized to eliminate the intermediate structure.
20:26:12 <dmj`> jmcarthur: this article might be relevant, explains how to fuse away intermediate trees (which could be maps in your case)
20:26:14 <dmj`> http://www.randomhacks.net/articles/2007/02/10/map-fusion-and-haskell-performance
20:26:51 <jmcarthur> i do know how this stuff works. i was really just asking a "trivial" question of whether anybody knows whether there is anything sufficiently powerful exposed from the Data.Map API to do it.
20:27:01 <zRecursive> > [0..] >>= \n -> n^2 <$ guard (even n)
20:27:02 <lambdabot>  [0,4,16,36,64,100,144,196,256,324,400,484,576,676,784,900,1024,1156,1296,144...
20:27:14 <colDrMcBeardman> jmcarthur, I think you'd have to forget about intersectionWith, though, and cook up something yourself to supply to the fold that can query the second map and decide if it's in the intersection
20:27:21 <zRecursive> @src guard
20:27:22 <lambdabot> guard True  =  return ()
20:27:22 <lambdabot> guard False =  mzero
20:27:23 <SrPx_> Guys, using Data.Vector (some work to convert) actually made the performance drop 1.5x ):
20:27:32 <SrPx_> Maybe it is the V.++ operation?
20:27:57 <jmcarthur> colDrMcBeardman: that's right. i'm trying to ask if there is anything more expressive or low level i can use for this.
20:28:07 <zRecursive> :t (<$)
20:28:07 <lambdabot> Functor f => a -> f b -> f a
20:28:35 <jmcarthur> colDrMcBeardman: intersectWith is a non-starter, since Map is internally strict and there are no rewrite rules anyway.
20:28:55 <dmj`> SrPx_: what compilation options did you use? Can you paste your code
20:28:56 <jmcarthur> SrPx_: it is generally good to avoid appending like that
20:29:31 <jmcarthur> stream fusion can sometimes optimize appends very well, but only those which occur statically
20:30:40 <SrPx_> dmj`: same as the thread, except using vectors instead of list ( http://lpaste.net/101757 ) and adding -fllvm
20:32:11 <dx25> < [0..]
20:32:25 <dx25> hmm
20:32:34 <dx25> oops
20:32:38 <dx25> > [0..]
20:32:39 <lambdabot>  [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,2...
20:34:08 <colDrMcBeardman> jmcarthur, I don't think anything in Data.Map is going to do, unless you start messing around by pulling the keys from both maps first, but going down that path looks like it would carry time complexity penalties.
20:35:10 <colDrMcBeardman> the only thing I could see is having a fold that carries around the other map and checks intersection by hand with Data.Map.member
20:35:47 * hackagebot ivory-examples 0.1.0.1 - Ivory examples.  http://hackage.haskell.org/package/ivory-examples-0.1.0.1 (LeePike)
20:36:30 <dmj`> SrPx: you're not really using vectors in your example
20:37:13 <prooftechnique> dx25: There are a number of problems in f
20:37:17 <dmj`> You call V.fromList, but most of the multiplication is still occuring w/ doubles
20:37:19 <jmcarthur> colDrMcBeardman: and would also introduce an intermediate data structure anyway
20:37:35 <prooftechnique> For starters, foldl (/) n (divisors n)
20:37:39 <prooftechnique> The parens are important
20:37:42 <jmcarthur> colDrMcBeardman: yeah, and that means traversing from the root of one of the maps for every key
20:38:15 <colDrMcBeardman> jmcarthur, yeah, you'd end up being m log n whereas intersection claims m + n. I'm confused how they do that.
20:38:29 <colDrMcBeardman> but in general, space and time complexities are inversely traded off.
20:38:46 <nuttycom> bitemyapp: too late... part of my "I get to have a beard in the winter" agreement with my wife is that I shave it the first day of spring.
20:38:46 <prooftechnique> dx25: So I guess what you want is f n = minimum n $ f n + foldl (/) n (divisors n)
20:38:52 <prooftechnique> :t minimum n $ f n + foldl (/) n (divisors n)
20:38:53 <lambdabot>     Ambiguous occurrence `f'
20:38:53 <lambdabot>     It could refer to either `L.f',
20:38:53 <lambdabot>                              defined at /home/lambda/.lambdabot/State/L.hs:145:1
20:39:01 <prooftechnique> :t \f -> minimum n $ f n + foldl (/) n (divisors n)
20:39:02 <lambdabot> Not in scope: `divisors'
20:39:24 <prooftechnique> @let divisors x = [n | n <- [1..], mod n x == 0]
20:39:25 <lambdabot>  Defined.
20:39:26 <prooftechnique> :t \f -> minimum n $ f n + foldl (/) n (divisors n)
20:39:27 <lambdabot>     Couldn't match expected type `[Expr -> t0]' with actual type `Expr'
20:39:27 <lambdabot>     In the first argument of `minimum', namely `n'
20:39:27 <lambdabot>     In the expression: minimum n
20:39:37 <prooftechnique> :t minimum
20:39:38 <lambdabot> Ord a => [a] -> a
20:39:38 <jmcarthur> colDrMcBeardman: that's not true. fusion is not a tradeoff at all. you save both space and time.
20:39:52 <prooftechnique> :t \f -> min n $ f n + foldl (/) n (divisors n)
20:39:53 <lambdabot> (Expr -> Expr) -> Expr
20:40:01 <dx25> oh.  guess i need to look up what '$' does
20:40:13 <SrPx_> dmj`: pardon?
20:40:21 <prooftechnique> dx25: It's just wrapping parens around the whole expression to the right
20:40:22 <zRecursive> @src ($)
20:40:23 <lambdabot> f $ x = f x
20:40:36 <dx25> ok
20:40:39 <zRecursive> @src ($!)
20:40:39 <lambdabot> f $! x = x `seq` f x
20:40:42 <prooftechnique> Also, what's with this Expr business?
20:40:48 * hackagebot ivory-examples 0.1.0.2 - Ivory examples.  http://hackage.haskell.org/package/ivory-examples-0.1.0.2 (LeePike)
20:41:09 <zRecursive> @src seq
20:41:10 <lambdabot> Source not found. You speak an infinite deal of nothing.
20:41:17 <zRecursive> :t seq
20:41:18 <lambdabot> a -> b -> b
20:41:20 <SrPx_> dmj`: how I'm not using vectors? How do I use them, then?
20:42:11 <prooftechnique> :t f 1 = 0; f n = min n $ f n + foldl (/) n (divisors n)
20:42:12 <lambdabot> parse error on input `='
20:42:27 <c_wraith|N10> zRecursive: seq is magic. It doesn't have haskell source.
20:42:30 <prooftechnique> @let f 1 = 0; f n = min n $ f n + foldl (/) n (divisors n)
20:42:31 <lambdabot>  .L.hs:150:1:
20:42:31 <lambdabot>      Multiple declarations of `f'
20:42:31 <lambdabot>      Declared at: .L.hs:145:1
20:42:31 <lambdabot>                   .L.hs:150:1
20:42:31 <lambdabot>  
20:42:40 <bitemyapp> nuttycom: damn. Fair enough. Hacking on anything in Haskell lately?
20:42:47 <zRecursive> c_wraith|N10: ok
20:42:50 <colDrMcBeardman> jmcarthur, I don't know anything about fusion, really, but the few examples I've seen are operations on single data structures.
20:42:55 <prooftechnique> @let dx25 1 = 0; dx25 n = min n $ dx25 n + foldl (/) n (divisors n)
20:42:56 <lambdabot>  Defined.
20:43:00 <prooftechnique> :t dx25
20:43:01 <lambdabot> (Fractional b, Integral b) => b -> b
20:43:19 <prooftechnique> Typechecks, so I guess it works :D
20:43:32 <jmcarthur> colDrMcBeardman: the data structure in this case would be Map
20:43:38 <dx25> hmm let me try that one.
20:46:10 <prooftechnique> > dx25 14
20:46:11 <lambdabot>  No instance for (GHC.Show.Show a0)
20:46:12 <lambdabot>    arising from a use of `M83758841670421667294360.show_M83758841670421667294...
20:46:12 <lambdabot>  The type variable `a0' is ambiguous
20:46:12 <lambdabot>  Possible fix: add a type signature that fixes these type variable(s)
20:46:12 <lambdabot>  Note: there are several potential instances:
20:46:26 <dx25>  No instance for (Fractional Int) arising from a use of `/'
20:46:37 <prooftechnique> @undef dx25
20:46:37 <lambdabot> There's currently no way to undefine just one thing.  Say @undefine (with no extra words) to undefine everything.
20:46:43 <prooftechnique> @undefine
20:46:43 <lambdabot> Undefined.
20:47:06 <prooftechnique> @let dx25 :: Int -> Int; dx25 1 = 0; dx25 n = min n $ dx25 n + foldl (/) n (divisors n)
20:47:06 <lambdabot>  .L.hs:148:40: Not in scope: `divisors'
20:47:30 <prooftechnique> @let divisors :: Int -> [Int]; divisors x = [n | n <- [1..], mod n x == 0]
20:47:30 <dx25> :/
20:47:31 <lambdabot>  Defined.
20:47:37 <prooftechnique> @let dx25 :: Int -> Int; dx25 1 = 0; dx25 n = min n $ dx25 n + foldl (/) n (divisors n)
20:47:37 <lambdabot>  .L.hs:151:33:
20:47:38 <lambdabot>      No instance for (Fractional Int) arising from a use of `/'
20:47:38 <lambdabot>      Possible fix: add an instance declaration for (Fractional Int)
20:47:38 <lambdabot>      In the first argument of `foldl', namely `(/)'
20:47:38 <lambdabot>      In the second argument of `(+)', namely `foldl (/) n (divisors n)'
20:47:38 <colDrMcBeardman> jmcarthur, you have two maps. I think the only reason intersectionWith can be m + n (assuming that's right) is because they're internally trees. If you could get at that tree structure, you could make an intersecting fold that was n + m
20:47:43 <prooftechnique> Ah, that
20:47:46 <dx25> yeah that's what i just got.
20:47:53 <prooftechnique> @let dx25 :: Int -> Int; dx25 1 = 0; dx25 n = min n $ dx25 n + foldl (div) n (divisors n)
20:47:53 <lambdabot>  Defined.
20:47:59 <prooftechnique> :t dx25
20:47:59 <lambdabot> Int -> Int
20:48:04 <prooftechnique> There, that's better
20:48:15 <prooftechnique> dx25: Just replace (/) with div
20:48:15 <dx25> oh i see.
20:48:32 <prooftechnique> div is integral division, (/) is fractional
20:48:42 <prooftechnique> > dx25 14
20:48:43 <lambdabot>  *Exception: stack overflow
20:48:46 <dx25> stack overflows
20:48:53 <prooftechnique> > dx25 1
20:48:54 <lambdabot>  0
20:48:56 <prooftechnique> > dx25 2
20:48:57 <lambdabot>  *Exception: stack overflow
20:49:01 <prooftechnique> Hahaha
20:49:16 <prooftechnique> dx25: What is this supposed to do, exactly?
20:49:26 <dx25> it's a topcoder problem
20:49:40 <dx25> lemme find the link
20:49:49 <dx25> http://apps.topcoder.com/wiki/display/tc/SRM+612
20:50:00 <prooftechnique> Bleh, logins
20:50:04 <dx25> oh.
20:50:25 <dx25> does this link work?
20:50:26 <dx25> http://community.topcoder.com/stat?c=round_overview&er=5&rd=15845
20:50:52 <prooftechnique> Yep
20:51:04 <dx25> ok it's emoticons div 2
20:53:03 <prooftechnique> Somebody had a really clever solution to a general form of this problem on /r/haskell the other day
20:53:06 <jle`> why is foldl even in base
20:53:15 <jle`> there should be a compiler warning when people use it
20:53:22 <prooftechnique> Why?
20:53:50 <dx25> link?
20:54:16 <prooftechnique> Looking
20:54:36 <jle`> prooftechnique: what is foldl even good for?
20:54:54 <jle`> rare and specialized use cases
20:55:37 <prooftechnique> foldl' seems pretty common
20:57:00 <prooftechnique> Also, some vague folk wisdom (fold wisdom) in the back of my brain says it's better than foldr for some useful class of finite lists
20:57:22 <SrPx_> dmj`: hm hi?
20:57:31 <prooftechnique> That should say *(fold wisdom?)
20:57:37 <jmcarthur> colDrMcBeardman: the two maps are just the inputs. the *one* map i want to fuse away is the intermediate one. and yes, if the API doesn't provide a powerful enough function to do what i want, the only way to do it is of course to dig into the internals.
21:00:13 <colDrMcBeardman> jmcarthur, like I said, I think you can do it by carrying around the other map in your fold accumulator, but it does then become m log n. Data.Map doesn't let you get at the tree to make it m + n by doing simultaneous in-order traversal.
21:00:43 <jle`> prooftechnique: foldl' is what you should use, but nobody uses it if foldl is there and they don't know the difference
21:01:13 <jle`> prooftechnique: foldl is more useful than foldl' for certain specialized use cases
21:01:22 <jmcarthur> colDrMcBeardman: That's not "doing" it at all. That's just changing the algorithm.
21:01:26 <dx25> hmm, would have been good if i'd defined divisors correctly.
21:01:50 <jmcarthur> colDrMcBeardman: If the answer is just that it seems impossible with the interface given, I agree.
21:02:04 <dmj`> jle`: foldl isn't strict tho
21:02:08 <colDrMcBeardman> jmcarthur, that idea would eliminate the intermediate map, though, wouldn't it?
21:02:32 <prooftechnique> jle`: Well, I guess that's why it's there. If you're a new Haskeller and having some kind of overflow issue, you'll come to #haskell and someone will say "use foldl'" and then you'll know
21:02:39 <SrPx_> Well guys I don't know what to do anymore guess I'm going to do something else /: best performance was still 2x slower than node.js, sadly
21:02:51 <prooftechnique> But for those cases where foldl is better, it's good to have
21:03:09 <dx25> foldl' "not in scope"
21:03:10 <prooftechnique> SrPx_: On what?
21:03:16 <prooftechnique> dx25: It's in Data.List
21:03:21 <jmcarthur> Yes, but by totally changing the algorithm. The question was about how to do a specific thing, and this solution just does something different instead.
21:03:23 <dx25> oh
21:03:23 <SrPx_> prooftechnique: http://www.reddit.com/r/haskell/comments/21doog/why_this_haskell_program_runs_considerably_slower/
21:03:33 <prooftechnique> SrPx_: Oh, that?
21:03:39 <jle`> prooftechnique: i'm sure 90% of new people to haskell will never run into advice to use foldl' over foldl
21:03:41 <SrPx_> yea /:
21:03:49 <jmcarthur> That is, changing the algorithm isn't what fusion does.
21:03:52 <jle`> they'll just say 'haskell is 20x slower than javascript'
21:04:12 <prooftechnique> jle`: Oh, that was one of the first things I learned
21:04:28 <SrPx_> jle`: I never said that! I'm just trying to figure out what I did of wrong. It is still slower with foldl', though
21:04:43 <jle`> SrPx_: oh, that's not you
21:04:45 <jle`> i'm not talkinga bout you
21:04:47 <jle`> you're a good example
21:04:55 <jle`> but for every good example like you, there are 10 that don't ask :/
21:04:58 <jle`> and they are lost forever :'(
21:05:00 <SrPx_> I guess considering I'm a complete Haskell noob and I've been programming in JS for years that isn't so bad, but I would really like to see how much this could improve
21:05:02 <jle`> i definitely have data to support this
21:05:04 <prooftechnique> SrPx_: Have you tried foldl'?
21:05:06 <SrPx_> jle`: that's true
21:05:14 <prooftechnique> Oh, I see
21:05:17 <SrPx_> prooftechnique: yea, 3x faster
21:05:37 <prooftechnique> But still slower than node, right?
21:05:47 <SrPx_> still slower than node.js though... I wonder if I could parallelize that to compensate... but then foldl is sequential by nature. hmm
21:05:51 <SrPx_> prooftechnique: yep
21:06:17 <prooftechnique> SrPx_: First, would you mind amending your paste with some type signatures? It's a bit hard to follow some of this
21:06:23 <prooftechnique> Also, you don't have to import Prelude
21:06:25 <prooftechnique> It's implied
21:06:27 <SrPx_> I know I'm doing something really stupid somewhere. I highly suspect of those "V.++". Also I wish I knew how to use the unboxed vector but I'm still studying that
21:06:33 <Olive`_> http://www.haskell.org/ghc/docs/latest/html/libraries/ghc/src/HsDecls.html did the syntax highlighter break about halfway through this page? is this a bug / should I report it
21:06:40 <SrPx_> prooftechnique: sure, a second
21:06:54 <colDrMcBeardman> jmcarthur, I suppose I am seeing calculating the intersection inside the fold as equivalent.
21:07:07 <colDrMcBeardman> but assume it isn't in this sense.
21:07:46 <dx25> f n = min n $ f (divisors n) + foldl' (div) n (divisors n)
21:07:51 <dx25> ^ that's wrong but it's what i'm trying to do
21:08:08 <jle`> dx25: import Data.List
21:08:22 <dx25> no i mean the f (divisors n) part
21:08:24 <jle`> also (div) = div
21:08:37 <dx25> previously i was stupidly calling f n causing the stack overflow
21:08:42 <prooftechnique> jle`: f takes an Int, but divisors yields a [Int]
21:08:59 <no-n> what function tells you if a list is a sublist of another?
21:09:01 <scb> Hi, I am looking for some kind of hybrid between error and writer monad. What I want is to run some computations, store all errors, if there are some errors at the end print them, otherwise return the final result. Should I just use Writer and be done with it?
21:09:26 <no-n> > "def" `isInfixOf` "abcdefg"
21:09:27 <lambdabot>  True
21:09:32 <no-n> there we go
21:10:08 <jle`> scb: what happens you you try to do something with an errored result?
21:10:11 <prooftechnique> > elem "def" (subsequences "abcdefg")
21:10:12 <lambdabot>  True
21:10:48 <jle`> scb: like...you want to do something with a result that doesn't exist?
21:10:54 <scb> jle`: it won't get to that, i am trying to lex some input. i would like to print at the end all the lexical errors.
21:11:05 <jle`> then error monad isn't really what you want
21:11:30 <jle`> error monad is for cases where your thing doesn' return anything
21:11:36 <jle`> so you can't possibly continue
21:11:45 <jle`> you just want a plain ol' writer
21:11:53 <dmj`> error is for actual errors in your haskell code, not invalid lexical input
21:12:03 <c_wraith|N10> scb: sounds more like you want an error application.
21:12:10 <scb> Excellent then. I was just making sure I wasn't thinking this wrong
21:12:14 <scb> c_wraith|N10: error paplication?
21:12:15 <c_wraith|N10> *applicative
21:12:19 <scb> applicative?
21:13:27 <scb> c_wraith|N10: googled it, looks promising.
21:13:37 <prooftechnique> paplication sounds great
21:13:42 <SrPx_> prooftechnique: updated the lpaste with type annotations http://lpaste.net/edit/101742
21:13:48 <prooftechnique> A totally cromulent word
21:14:06 <c_wraith|N10> scb: there's already a lib on hackage that had one, but I don't recall the name.
21:14:12 <colDrMcBeardman> prooftechnique, didn't they vote cromulent into the language?
21:14:40 <scb> c_wraith|N10: well i am looking at applicative-extras, but can't really figure out how to use it.
21:15:20 <prooftechnique> colDrMcBeardman: I hope so
21:16:04 <colDrMcBeardman> prooftechnique, a bunch of english doctorates get together every year and I'm pretty sure they added cromulent to the lexicon.
21:17:11 <prooftechnique> SrPx_: Okay, I think people actually meant you should use Data.Vector, not your own Vector type
21:17:39 <prooftechnique> Data.Vector is, to use the vernacular, optimized out the ass
21:17:58 <SrPx_> prooftechnique: pardon? What is my own vector type? Didn't I use Data.Vector?!
21:18:25 <SrPx_> prooftechnique: the Data.Vector version is this one http://lpaste.net/101757 but I didn't type annotate it yet :{
21:18:33 <prooftechnique> You code has data Vec = Vec { record stuff here }
21:18:53 <prooftechnique> Oh, wait, I see
21:19:03 <SrPx_> prooftechnique: nah this is just a 3D vector
21:19:07 <prooftechnique> I got my wires crossed between your Vec and Vector
21:20:38 <c_wraith|N10> scb: I'm on mobile at the moment, can't be of much help total. The main idea is that applicative structure means that it can check for errors from all the subcomputations and give you a full list when run, if it doesn't succeed. The fact that it's less powerful than Monad is why hat can work.
21:23:23 <SrPx_> do you guys know where/how I can pay some haskell dev to optimize this code for me? seems like it would be enlightening to see a professional version of this code, maybe even parallilelized or using repa/the gpu
21:23:36 <prooftechnique> SrPx_: Have you profiled it to see where the pain points are?
21:24:00 <prooftechnique> I feel like it's probably in the V.fromList's or the V.++'s
21:24:20 <SrPx_> prooftechnique: http://lpaste.net/101761
21:24:49 <prooftechnique> Weird, the show instance is pretty busy
21:26:02 <prooftechnique> Judging by those results, V.++ is probably your issue. Hmm
21:26:13 <prooftechnique> Oh!
21:26:18 <SrPx_> Why? I'm not sure how to interpret it
21:27:02 <prooftechnique> SrPx_: Generally, concatenation is more expensive that consing
21:28:01 <prooftechnique> I was hoping one of those mesh_*'s was just an element so we could use V.cons, but no such luck
21:28:21 <SrPx_> I don't understand, it points to `buildMesh.build_layer.build_vertexes.colors` as a bottleneck, but that isn't a function
21:28:27 <SrPx_> oh, I understand it now.
21:28:48 <prooftechnique> Yeah
21:29:02 <tapuu> Does anyone know of a monad, that is sort of like listT applied to IO, except it runs stuff in parallel with forkIO?
21:29:08 <SrPx_> tell me, is V++ making a copy of the old vector each time?
21:30:25 <SrPx_> I guess I need something like memcpy... or assignment such as vec[idx]=val... thatd probably solve it
21:30:46 <jle`> tapuu: so like implicit data parallelism...?
21:30:57 <prooftechnique> SrPx_: V.++ is just sticking the two Vectors together, but that requires traversal which is expensive
21:31:02 <SrPx_> the calculations are NOT the bottleneck, right? the bottleneck is just making the array. prooftechnique
21:31:12 <prooftechnique> That seems likely
21:31:32 <tapuu> jle`: maybe, im not sure what that is
21:31:38 <prooftechnique> You can test it by just doing the calculations elsewhere and calling that function for the sake of profiling
21:31:42 <SrPx_> isn't there something like (copy vector_a vector_b idx) ?
21:32:12 <jle`> SrPx_: have you tried using mutable vectors and ST ?
21:32:20 <Kaidelong> any gtk2hs developers in right now?
21:32:32 <SrPx_> jle`: no
21:32:42 <jle`> SrPx_: what is your code actually doing?
21:32:43 <jle`> sorry
21:32:58 <jle`> it's a fold
21:32:59 <tapuu> jle`: Can you give me a specific library or something?
21:33:06 <SrPx_> jle`: oh well there I go another hour learning about mutable vectors and trying to convert the code haha
21:33:23 <jle`> SrPx_: what are you doing at every step?
21:33:25 <jle`> of your fold
21:33:35 <jle`> because this might look like something that would do well in an ST monad
21:33:47 <SrPx_> jle`: it takes an array of pivotes (directions/lengths/radius) and creates a cylindrical mesh from it...
21:34:42 <SrPx_> jle`: This is the equivalent code in livescript, might explain better: http://lpaste.net/101762
21:34:54 <Kaidelong> @tell ManateeLazycat http://stackoverflow.com/questions/20908829/cullong-type-constructor-not-visible-when-installing-pango-and-gio-with-cabal-on/21309105#comment34489840_21309105
21:34:54 <lambdabot> Consider it noted.
21:35:13 <athan> culLong?
21:35:27 <Kaidelong> CULLong is a C long long
21:35:35 <athan> derp
21:35:36 <Kaidelong> either way I figured out how to fix that part
21:35:46 <Kaidelong> (well, unsigned long long)
21:36:23 <prooftechnique> SrPx_: Can you describe the algorithm? We may be able to help you find a more functional solution
21:36:23 <athan> So, I've heard there's a new IO system as of 7.8.1 - MIO
21:36:29 <Kaidelong> the problem is that the macro #gtk2hs_type is generating ridiculous names like 'Word9150716308491337760'
21:36:35 <athan> does that have any relation to this issue?
21:37:08 <athan> or, maybe, a possible alternative?
21:37:10 <Kaidelong> our current computer architectures, as you might expect, do not natively support Word9150716308491337760 so something weird is happening
21:37:25 <athan> hahaha
21:37:35 <athan> maybe the NSA has one lying around
21:38:16 <Kaidelong> any other gtk2hs people I should @tell?
21:39:47 <SrPx_> prooftechnique: the initial data is an array of pivot points, like that: {len :: double, rotation :: quaternion}. The algorithm starts with a 3D cursor at origin (Vector3 0 0 0). Each step, the 3D cursor is updated to a new position using a pivot. So, for example, if the first pivot has length 1 and direction X, each step the cursor will travel a distance of 1 in direction X.
21:40:55 <SrPx_> so that is just it, the cursor keeps travelling through space by changing direction, moving, changing direction, moving... accourding to the list of pivots... creating 3D vertexes as it go, and returning a list of 3D vectors containing the positions it has been
21:41:54 <SrPx_> it is actually a little more complex as for each position it actually creates a circle of vertexes pointing to its normal, but that is not essential to the algorithm (it probably causes the slowdown, though, as I have to append all those generated vertex to the array of results and this is the bottleneck)
21:42:13 * SrPx_ is not good at explaining algorithms
21:42:46 <prooftechnique> Hmm
21:43:37 <athan> me gusta
21:44:09 <athan> are you gonna render the 3d verticies to pixels, or a 2d vector like svg? I saw you use pango, although I'm not sure if that's like cairo :S
21:44:16 <athan> isn't pango a pixel library?
21:45:39 <no-n> import Prelude hiding (catch) -- why would somebody do this?
21:45:51 <dx25> ok here's my latest:
21:45:51 <dx25> http://pastebin.com/index/aYJuEfWx
21:46:02 <dx25> and it only fails 40 out of 61 test cases. :/
21:46:18 <dx25> and it's horribly verbose compared to the c++ version that actually works.
21:46:19 <tapuu> That code makes me smile
21:47:02 <dx25> so basically i suck at haskell
21:47:12 <tapuu> What are you trying to do?
21:47:37 <dx25> it's a medium level topcoder problem
21:47:38 <dmj`> dx25: Int is signed
21:47:50 <athan> topcoder?
21:47:52 <dx25> trying to use it to learn haskell
21:48:25 <dmj`> dx25: I think you're failing to account for negative input
21:49:13 <dx25> dmj`, it's guaranteed positive in problem statement.
21:49:33 <johnw> dmj`: hello!
21:49:58 <dmj`> johnw: Hey!
21:50:02 <johnw> Dave! :)
21:50:33 <dmj`> johnw: haha, my true identity.. thanks John :P
21:50:44 <johnw> I need to remind myself so I don't embarass myself next time
21:50:49 <johnw> are you going to Lambda Jam?
21:51:25 <dmj`> johnw: I'd love to, probably will. You going to be there?
21:51:30 <no-n> import Prelude hiding (catch) -- this seems like a strange thing to do, but would it be to get the catch from Control.Exception (which is also imported) rather than the catch from Prelude?
21:51:43 <tapuu> Does anyone know of a monad, that is sort of like listT applied to IO, except it runs things in parallel using forkIO?
21:51:48 <johnw> I think so
21:52:10 <jle`> no-n: it'd be to get catch from anywhere
21:52:14 <scb> Sigh, anyone know how to keep moving forward with an alex lexer after finding a lexical error?
21:52:15 <dmj`> johnw: wait is this free?
21:52:23 <jle`> no-n: i do import prelude hiding (..) a lot
21:52:28 <no-n> okay
21:52:30 <no-n> cool
21:52:30 <johnw> tapuu: a monad, no, since monads require sequencing
21:52:33 <johnw> tapuu: an applicative, yes
21:52:39 <jle`> commony...mapM,m apM_, id, (.)
21:52:39 <johnw> it's called Concurrently, from async
21:52:47 <prooftechnique> SrPx_: Why did you define depth but not use it?
21:52:53 <johnw> dmj`: I doubt it
21:52:53 <prooftechnique> Could that be relevant?
21:52:58 <tapuu> johnw: That makes sense, I tried making one and I couldn't write the monad instance
21:53:00 <jle`> dx25: can you explain what you are trying to do?
21:53:05 <johnw> tapuu: that's a good thing :)
21:53:37 <johnw> tapuu: see https://github.com/jwiegley/concurrent/blob/master/Concurrent.hs
21:53:47 <SrPx_> prooftechnique: mistake, it was necessary in other versions
21:53:54 <tapuu> thank you
21:54:00 <dmj`> dx25: are you using QuickCheck? Is that what you mean by tests? If not, can you show your tests
21:54:11 <tapuu> This looks very useful
21:54:14 <StoneCypher> i use quickcheck (in erlang)
21:54:20 <StoneCypher> (and actually a drop in replacement for it)
21:54:21 <dx25> dmj`, no i used gettc
21:54:24 <dx25> get install gettc
21:54:25 <prooftechnique> jle`: It's a copy and paste count. You start with one element on screen, copy it, paste, copy those, paste, up to n, with each action taking 1 second.
21:54:26 <johnw> I based it off of what Marlow wrote in his Haxl slides
21:54:31 <dx25> and then
21:54:57 <dx25> hmm lost the problem number
21:55:09 <dx25> er sorry
21:55:14 <dx25> "gem instal gettc"
21:56:00 <dx25> and "gettc 13041"
21:56:18 <tapuu> johnw: Maybe you should put this on hackage
21:56:40 <dx25> jle`, what prooftechnique said
21:56:59 <johnw> tapuu: if you use it and really find it that useful, maybe I will ;)
21:57:13 <johnw> it's never been put to production use yet, because I wanted to implement "pooling"
21:57:29 <dx25> i  know a couple ways to solve it, i was trying to implement the recurrence shown in the c++ solution i pasted
21:57:53 <athan> Hey yall, sorry to interject, but I remember hearing about a stronly typed purely functional language a while ago that's "faster than C"
21:58:01 <athan> I think it was something like SDE
21:58:03 <joelteon> doesn't exist
21:58:05 <athan> or S.... something
21:58:06 <StoneCypher> athan: i think that's html5
21:58:09 <athan> HA
21:58:16 <StoneCypher> apples: dramatic music
21:58:20 <athan> it's a research language
21:58:26 <athan> influenced by adga
21:58:28 <tapuu> Every month or so I hear somebody talking about something 'faster than C'
21:58:35 <athan> anyone catch a line?
21:58:37 <jle`> is it javascript?
21:58:46 <athan> :/
21:58:49 <prooftechnique> SrPx_: Also, it appears that V.enumFromTo may be inefficient, so you may want to use enumFromToN
21:59:09 <StoneCypher> i'm surprised i didn't get banned for making somoene laugh
21:59:14 <prooftechnique> *enumFromN
21:59:33 <athan> nobody... :(
22:00:21 <jle`> dx25, prooftechnique: are we looking at the same code?
22:00:28 <prooftechnique> athan: Haskell is faster than C when dealing with infinite lists :D
22:00:37 <athan> pfffttttt hahaha
22:00:49 <athan> Well then, I've got another weird question for you
22:00:57 <prooftechnique> jle`: http://community.topcoder.com/stat?c=problem_statement&pm=13041&rd=15845
22:01:17 <dx25> jle`, http://pastebin.com/index/aYJuEfWx
22:01:19 <dx25> that's my latest
22:01:22 <athan> what is covariance vs. variant?
22:02:03 <athan> I understand co- yadda works with the idea of infinite data
22:02:13 <athan> and free-wheel structures like the free monad
22:02:18 <athan> so here's a weird one:
22:03:07 <prooftechnique> SrPx_: Can you try this? http://lpaste.net/101764
22:03:08 <athan> if haskell's type system must have all inputs entered before calculating a result, would that not make the type system a normally structured program
22:03:18 <athan> while ghci is a guarded recursive program?
22:04:36 <redtricycle> I'm trying to use haskell to access an api (using HTTP POST) and parsing xml
22:04:47 <redtricycle> What's the recommended way to do this?  I am thinking libcurl, and then the xml library
22:04:50 <athan> conduit-http-client
22:04:58 <athan> i mean...
22:04:59 <prooftechnique> redtricycle: The current answer is conduit
22:05:06 <athan> the _right_ way, or the easiest?
22:05:06 <redtricycle> But am wondering if there's a more streamlined way
22:05:17 <johnw> tapuu: pretty soon, it will cycle back and then C will be faster than C
22:05:18 <redtricycle> Right way :)
22:05:20 <redtricycle> new to haskell
22:05:24 <prooftechnique> When I get off my ass and finish pipes-xml, then that will be the answer, maybe D:
22:05:24 <athan> parsec, also!!!
22:05:27 <redtricycle> so i want a good start
22:05:31 <erisco> hxt could be used
22:05:32 <athan> tagsoup
22:06:00 <athan> I personally think you should use conduits for it
22:06:02 <redtricycle> I'm learning haskell to get a feel for functional programming, so anything that encourages that is good
22:06:12 <athan> If I were you, I'd learn yesod
22:06:25 <athan> it'll give you a nice foundation (yuk yuk yuk)
22:06:41 <athan> then, learn Functor => Applicative => Monad pattern
22:06:43 <johnw> redtricycle: I'll give another vote for http-conduit and xml-conduit
22:07:02 <athan> then learn type arithmetic
22:07:16 <dmj`> Aetherspawn: ping?
22:07:27 <redtricycle> thanks all, will check out conduit
22:07:34 <athan> also, definitely pick up "the haskeller's guide to math, logic, and programming"
22:07:46 <redtricycle> athan: will do :)
22:07:50 <redtricycle> athan: or dream about doing it
22:07:52 <athan> HA
22:08:13 <tapuu> redtricycle: I did something similar for the first time today, I found this page useful: http://adit.io/posts/2012-03-10-building_a_concurrent_web_scraper_with_haskell.html
22:08:19 <SrPx_> prooftechnique: a sec
22:08:32 <athan> Nice!!
22:08:47 <athan> I'm gonna write an MMO in haskell soon
22:08:55 <athan> I've just gotta make a sockjs backend for conduits
22:09:03 <SrPx_> prooftechnique: hm, are you sure? Seems like it doesn't generate the mesh
22:09:20 <johnw> athan: you don't write "backends" for conduit
22:09:23 <prooftechnique> tapuu: After reading that article, I wrote a webscraper in 10 minutes during a meeting that did the exact thing I needed
22:09:28 <prooftechnique> It was a pretty neat feeling
22:09:28 <johnw> conduits are very simple things
22:09:29 <athan> johnw: insightful
22:09:51 <tapuu> Yes, that article is brilliant
22:10:04 <prooftechnique> SrPx_: Oh, whoops
22:10:11 <prooftechnique> I switched some things. Hang on
22:10:17 <redtricycle> tapuu: which article? sounds interesting
22:10:40 <redtricycle> tapuu: the one you sent above?
22:10:48 <tapuu> redtricycle: yes
22:12:24 <athan> johnw: Sorry, it's been a long night. You didn't deserve that.
22:12:27 <prooftechnique> SrPx_: http://lpaste.net/101764
22:12:30 <prooftechnique> That one should work
22:12:43 <prooftechnique> Runs pretty instantaneously for me
22:12:50 <johnw> athan: no problem :)
22:13:31 <SrPx_> prooftechnique: no ):
22:13:44 <SrPx_> prooftechnique: are you sure you see the mesh when you run it?
22:13:51 <prooftechnique> SrPx_: I pasted the wrong code again D:
22:14:09 <SrPx_> D:
22:14:20 <prooftechnique> SrPx_: http://lpaste.net/101769
22:14:26 <prooftechnique> I swear it should work now :D
22:15:08 <prooftechnique> I changed your enumFromTos to enumFromNs, and changed the foldls to foldl's
22:15:28 <meiji11> is there any reason the use of the 'use' function of Control.Lens in a state monad should cause execution of the function to block in ghci?
22:15:52 <johnw> can you show us the usage?
22:15:57 <athan> (lol)
22:16:11 <edwardk> well, if it is doing so, then i'd suspect yes, there must be a reason ;)
22:16:40 <johnw> hi edwardk!
22:16:51 <edwardk> heya, ltns
22:16:56 <athan> Edward, you are a demigod from what I've seen so far
22:16:59 <athan> just fyi
22:17:02 <SrPx_> prooftechnique: still 200ms ): (node.js running in 50ms)... but what have you done?
22:17:17 <meiji11> here: http://lpaste.net/101771
22:17:36 <SrPx_> prooftechnique: the code looks better though
22:18:01 <prooftechnique> SrPx_: V.enumFromTo is apparently less efficient than V.enumFromN, so I changed those. I also changed the V.foldls to V.foldl's
22:18:24 <prooftechnique> The real pain points still seem to be coming from V.++, though
22:18:24 <SrPx_> prooftechnique: oh I didn't know V had a foldl' too.
22:18:47 <SrPx_> I think the V++ is still ruining everything, though
22:19:29 <johnw> meiji11: can I see localEnv?
22:20:11 <meiji11> johnw: localEnv is of type Map Symbol [KLValue], and belongs to the Env record as _localEnv.
22:20:30 <no-n> hmm
22:20:38 <johnw> hmm
22:21:41 <no-n> http://www.haskell.org/haskellwiki/Roll_your_own_IRC_bot#A_simple_interpreter <- I commented out import Control.Exception and the first version of loop, and I get Not in scope: data constructor `SomeException'
22:22:11 <athan> If you could make the coolest thing ever, what would it be?
22:22:32 <johnw> erase lens from Hackage and reinvent it
22:23:13 <dmj`> no-n: SomeException is defined in Control.Exception
22:23:37 <no-n> so it does. but would importing both Exception and OldException not cause name clashes?
22:23:44 <erisco> @pl \x -> f x >>= g >>= h
22:23:44 <lambdabot> (h =<<) . (g =<<) . f
22:23:55 <athan> pl?
22:24:04 <jle`> it's pointless
22:24:07 <erisco> eh this is rather ugly ... is there a better option? I run into this all the time
22:24:08 <athan> derp
22:24:09 <athan> wow
22:24:13 <prooftechnique> SrPx_: http://lpaste.net/101757
22:24:13 <athan> there's an alg for that?
22:24:20 <athan> "there's an alg for that!"
22:24:20 <johnw> erisco: f >=> g >=> h
22:24:24 <jle`> ^^
22:24:27 <erisco> :t (>=>)
22:24:28 <lambdabot> Monad m => (a -> m b) -> (b -> m c) -> a -> m c
22:24:30 <prooftechnique> Switching to V.concat seems to have caused a notable speedup, amazingly
22:24:42 <erisco> johnw, that'll be fine thanks
22:24:50 <jle`> it's better parenthezided as (a -> m b) -> (b -> m c) -> (a -> m c)
22:24:54 <no-n> dmj`: what confuses me is it says Exception -- for base-3, OldException -- for base-4
22:24:58 <prooftechnique> SrPx_: Whoops: http://lpaste.net/101772
22:25:01 <no-n> not sure if i'm to import both or which or what
22:25:02 <jle`> (<=<) should remind you of (.)
22:25:06 <jle`> :t (<=<)
22:25:07 <lambdabot> Monad m => (b -> m c) -> (a -> m b) -> a -> m c
22:25:09 <jle`> :t (.)
22:25:09 <lambdabot> (b -> c) -> (a -> b) -> a -> c
22:25:18 <athan> gorgeous
22:25:19 <no-n> importing both does indeed give me name clashes
22:25:21 <jle`> so >=> and >>= are like (.) and ($)
22:25:22 <pyon> :t (Control.Category..)
22:25:22 <lambdabot> Category cat => cat b c -> cat a b -> cat a c
22:25:24 <jle`> er sorry, backwards.
22:25:32 <athan> er (&) of ($)
22:25:34 <jle`> <=< and =<< are like (.) and ($)
22:25:38 <kadoban> Soo.  I'm parsing a ByteString with Parsec, and everything seems fine, except the error messages suck.  Can I change those easily?  Specifically the "unexpected '\Blah'" part, where "Blah" is some weird character escape.  Can I just convert them to hex or Word8 or something on output?
22:25:41 <jle`> who even uses >>= anyway
22:25:42 <prooftechnique> SrPx_: If you can profile that and paste the results, maybe we can see what else we can do to optimize it without sacrificing clarity
22:25:42 <jle`> :)
22:25:52 <athan> WOAH
22:25:55 <no-n> looks like I can fix this with hiding though
22:26:06 <Aetherspawn> jle`: were you the one building network
22:26:09 <pyon> jle`: (<=<) is exactly (.) ... for wrapped Kleisli arrows.
22:26:22 <dmj`> it's monadic composition
22:26:29 <Aetherspawn> or was it dmj`
22:26:57 <jle`> pyon: yeah, silly newtype wrappers :/
22:26:59 <erisco> johnw, shame that it does not quite fit as a category
22:27:06 <athan> how do normal haskell arrows fit into the whole functor/monad paradigm?
22:27:14 <jle`> athan: they are different kinds
22:27:22 <athan> i know Functor => applicative => monad
22:27:22 <jle`> so
22:27:25 <Aetherspawn> well, whoever was building network on windows
22:27:30 <jle`> they can't really be involved in that way
22:27:33 <dmj`> Aetherspawn: I pinged you yes
22:27:34 <Aetherspawn> I put the correct configure line on neil mitchells blog
22:27:36 <johnw> erisco: it's the Kleisli category
22:27:37 <pyon> athan: Arrows have a completely different kind.
22:27:40 <jle`> they are sort of different beasts
22:27:47 <athan> hmmm
22:27:48 <jle`> :k Arrow
22:27:49 <lambdabot> (* -> * -> *) -> Constraint
22:27:51 <jle`> :k Monad
22:27:51 <lambdabot> (* -> *) -> Constraint
22:27:58 <athan> ahhhhhh
22:27:59 <SrPx_> prooftechnique: sorry, a sec
22:28:07 <athan> I think I was wondering about this earlier today
22:28:17 <erisco> johnw, well that would require wrapping
22:28:18 <athan> "how could I make a 2-ary fixpoint combinator?"
22:28:20 <pyon> athan: For every Monad instsance, there is an associated Arrow instance, however.
22:28:28 <pyon> athan: Namely, Kleisli arrows.
22:28:29 <dmj`> Aetherspawn: I see you added --host=i686-pc-mingw32
22:28:44 <jle`> :t Kleisli
22:28:45 <lambdabot> (a -> m b) -> Kleisli m a b
22:29:10 <jle`> Aetherspawn: wasn't me
22:29:13 <jle`> :)
22:29:22 <prooftechnique> SrPx_: My time output says .07 real         0.07 user         0.00 sys
22:29:37 <prooftechnique> So that's not bad
22:30:16 <SrPx_> prooftechnique: wow? It still says .215 here
22:30:25 <SrPx_> maybe I'm doing something wrong?
22:30:36 <SrPx_> prooftechnique: I'm usingghc -O2 -fllvm meshbuilder4.hs -o haskell
22:30:46 <no-n> import Module (foo, bar, baz) -- is this correct syntax?
22:31:34 <jle`> no-n: afaik
22:31:55 <prooftechnique> SrPx_: Weird. Your node code for me is 0.12 real         0.07 user         0.04 sys
22:32:14 <athan> hmm
22:32:14 <prooftechnique> SrPx_: Let me try with those flags
22:32:16 <dmj`> no-n: import Data.List (foldl')
22:32:19 <dmj`> like that
22:32:24 <SrPx_> prooftechnique: what kind of supercomputer are you in, by the way?
22:32:33 <athan> are there different kinds of arrows then the Kleisli ones?
22:32:34 <no-n> hmm. I'm doing import import Control.Exception (bracket, bracket_, SomeException) yet it says "Not in scope: data constructor `SomeException'"
22:32:38 <SrPx_> prooftechnique: what flags you used?
22:32:38 <prooftechnique> 2011 MBP
22:32:42 <no-n> minus import
22:32:45 <prooftechnique> I just used -O2
22:32:52 <SrPx_> prooftechnique: oh cool your 2011 MBP is faster than my MBPr
22:32:53 <prooftechnique> Maybe the llvm codegen is different
22:33:02 <jle`> athan: there are many neat arrows
22:33:05 <no-n> must be something to do with type cons vs data cons
22:33:07 <prooftechnique> SrPx_: I'm also on ghc 7.8, so that may be having an effect
22:33:07 <dmj`> no-n: import Control.Exception (SomeException(..))
22:33:10 <SrPx_> prooftechnique: same result without llv pretty much
22:33:12 <SrPx_> prooftechnique: oh maybe
22:33:18 <jle`> athan: the one you are probably the most familiar with is (->)
22:33:35 <athan> indeed!
22:33:40 <prooftechnique> SrPx_: Yeah, same results for me with -fllvm
22:33:45 <athan> that's merely parameterization, right?
22:33:49 <jle`> athan: ?
22:33:52 <erisco> johnw, was able to rewrite my entire do block using just ., =<<, and <=< thanks :)
22:33:58 <athan> like...
22:33:59 <jle`> athan: also useful would be the Automation arrows used heavily in AFRP
22:34:01 <prooftechnique> SrPx_: What's the fastest version of your js code?
22:34:08 <prooftechnique> I may be using an old revision of that paste
22:34:17 <athan> hmmmmmm
22:34:21 <athan> afrp?
22:34:26 <jle`> arrowized frp
22:34:29 <SrPx_> prooftechnique: I'm just trying to learn how to use mutable arrays, I really want to see how that would perform without the concatenations
22:34:30 <athan> WOAH
22:34:31 <athan> OKAY'
22:34:35 <SrPx_> prooftechnique: there's only one version
22:34:37 <athan> wow
22:34:39 <athan> hmm
22:34:40 <prooftechnique> Oh, okay
22:34:49 <jle`> writing a series on arrows in frp but have gotten held up in the second part due to time :/  but here is a good one ---
22:35:04 <jle`> http://en.wikibooks.org/wiki/Haskell/Arrow_tutorial
22:35:19 <jle`> that uses the Auto arrow to neat effect
22:35:59 <athan> interesting
22:36:02 <prooftechnique> SrPx_: Hmm. Well, GHC seems to beat node in every run for me. What's your node version?
22:36:17 <athan> so what's the main difference between the arrow paradigm and normal function application/mapping?
22:36:24 <bitemyapp> carter: it's time.
22:36:25 <athan> is it like, a multi-parameter map?
22:36:34 <carter> bitemyapp:  ?
22:36:48 <bitemyapp> carter: for another Haskell post!
22:36:54 <carter> by you?
22:36:58 <carter> at 130am?
22:37:05 <bitemyapp> carter: right now.
22:37:08 <bitemyapp> carter: by me
22:37:08 <jle`> athan: they are sort of different things
22:37:15 <jle`> they represent different things
22:37:17 <carter> heh
22:37:23 <athan> hmm....
22:37:33 <erisco> athan, if you write your library to use an arrow interface, you can allow the user to construct computations that you can analyse before carrying out
22:37:40 <athan> rather than a container to be applied upon (like a functor), it's....
22:37:50 <athan> hmm!
22:37:53 <athan> interesting
22:38:01 <carter> erisco: athan  no, start with applicative
22:38:02 <nisstyre> prooftechnique: node takes around 0.3 seconds to even start up for me
22:38:07 <athan> it's an ahead-of-time description for a runtime program?
22:38:08 <carter> applicative has a much much better UX
22:38:11 <carter> prooftechnique: sup?
22:38:18 <nisstyre> er, 0.03
22:38:21 <athan> okay, so applicative
22:38:26 <athan> absracts lifting
22:38:30 <erisco> carter, athan I was just answering to "what is the main difference between ..."
22:38:41 <carter> erisco: i'm not reading things very closely
22:38:41 <athan> into multiple parameters with <*>
22:38:43 <carter> its after 1am
22:38:55 <Aetherspawn> dmj`: blah
22:38:56 <erisco> carter, same here :D it is a fun time of day
22:38:59 <carter> :p
22:39:06 <bitemyapp> carter: http://bitemyapp.com/posts/2014-03-25-when-nested-io-actions-are-wanted.html
22:39:07 <dmj`> Aetherspawn: no dice?
22:39:07 <athan> I can't feel my thoughts!
22:39:07 <Aetherspawn> I thought it was rolling fine, but it got the very end and spawned something about wspiapi.h missing
22:39:17 <Aetherspawn> which is retarded, because I have it
22:39:17 <SrPx_> prooftechnique: yea seems like GHC 7.8 probably outperforms node on this case, then. I'm try updating it again sometime
22:39:19 <Aetherspawn> some glitch in network
22:39:28 <SrPx_> prooftechnique: v0.8.2
22:39:51 <erisco> athan, arrows are worthwhile to look at after applicative and monad
22:39:52 <dmj`> Aetherspawn: what are you system/ghc specs?
22:39:54 <Aetherspawn> I suspect it's because I'm using the newer Msys2 which defines some different pragmas to other mingw builds
22:39:54 <erisco> but not before
22:39:55 <nisstyre> SrPx_: I've been able to beat GHC consistently by a few milliseconds with Clean's compiler (almost the exact same code)
22:40:03 <Aetherspawn> 7.6.3, haskell platform
22:40:05 <nisstyre> I'm not sure what it does differently
22:40:05 <Aetherspawn> msys2
22:40:27 <dmj`> Aetherspawn: would be nice if tibbe could chime in
22:40:29 <erisco> however, you should feel free to borrow operators such as &&& because their need occurs often enough
22:40:39 <pixiebit> Verifying
22:40:44 <dmj`> Aetherspawn: In cygwin I was able to install it via: cabal install network-2.4.1.2 --configure-option -host=i386-unknown-mingw32
22:40:53 <prooftechnique> SrPx_: Hmm, I'm on 0.11.11. Have there been serious performance regressions? :D
22:41:01 <Aetherspawn> I'll trythat
22:41:01 <jle`> athan: i suggest you look at the Category typeclass first
22:41:02 <prooftechnique> I'll install 0.8.4 and see what happens
22:41:08 <athan> YES I need to get into that
22:41:19 <athan> I understand the principals of the practice
22:41:22 <dmj`> Aetherspawn: MSYS is out of the question since it doesn't recognize shared folders in vbox
22:41:24 <athan> I just need to see how it all fits
22:41:28 <athan> Thank you for your help!!
22:41:33 <erisco> > (+1) &&& (*2) $ 5
22:41:34 <lambdabot>  (6,10)
22:41:45 <prooftechnique> carter: Sup. I swear I'm working on hblas, I've just been busy with the job hunt :D
22:41:49 <athan> ahh
22:41:51 <athan> yeah
22:41:54 <athan> so it's like
22:42:01 <carter> prooftechnique: did you email the folks i pointedout
22:42:11 <Aetherspawn> that wont even configure for me
22:42:16 <athan> splitting the application
22:42:23 <Aetherspawn> it spawns that huge spew of arch stuff
22:42:25 <athan> I've seen that kind of stuff
22:42:28 <athan> OH WAIT
22:42:30 <athan> OKAY
22:42:30 <prooftechnique> Not yet. I should get on that, though. I did get a commit in hhvm, though, which was neat
22:42:32 <dmj`> > over both (+1) (5,9)
22:42:33 <lambdabot>  (6,10)
22:42:34 <athan> so arrow arithmetic
22:42:39 <bitemyapp> carter: bwahahaha, publish ALL the things
22:42:41 <carter> prooftechnique: email him damn it
22:42:50 <prooftechnique> Okay, geez, I will
22:42:53 <athan> focuses more on constructing the object to be applied to
22:42:55 <prooftechnique> :D
22:42:57 <erisco> :t (***)
22:42:58 <lambdabot> Arrow a => a b c -> a b' c' -> a (b, b') (c, c')
22:42:58 <athan> ie - the "function"
22:43:04 <carter> prooftechnique: you'll probably be on the crazy junior side
22:43:04 <erisco> odd, hoogle will not let me search for ***
22:43:06 <carter> but reachout
22:43:07 <dmj`> Aetherspawn: can you paste it
22:43:11 <carter> prooftechnique: seriously, just fuckin do it
22:43:16 <pixiebit> hey guys oculus vr
22:43:16 <carter> like tomrrow
22:43:19 <Aetherspawn> its the same one you get if you dont put in anything
22:44:05 <athan> pixiebit: I'm trying to make myself a DIY VR :P
22:44:05 <Aetherspawn> carter: when is 7.8
22:44:12 <Aetherspawn> and when is the new haskell platform for it
22:44:14 <jle`> athan: i'm not sure you should be trying to fit arrows into monads and applicatives
22:44:20 <no-n> {{{1}}} loop st = catch (runReaderT run st) (const $ return ()) {{{2}}} loop st = catch (runReaderT run st) (\(SomeException _) -> return ()) -- is {{{1}}} for OldException and {{{2}}} for Exception? Why has the person who wrote this said OldException for base-4 and Exception for base-3?
22:44:24 <carter> Aetherspawn: this week and when you help mark get it ready
22:44:27 <Aetherspawn> 'cuz now to install network-simple you need the new network which doesnt build on windows
22:44:27 <carter> respectively
22:44:28 <athan> jle` I'll find out the hard way xD
22:44:34 <jle`> athan: at its essense, category generalizes the idea of functions as "things from a to b"
22:44:37 <pixiebit> Nice try athan I'm not falling for that.
22:44:46 <jle`> athan: note the two members of the Category typeclass
22:44:51 <jle`> athan: (.) and id
22:45:03 <jle`> athan: (.) joins two 'arrow things' together into one long arrow thing
22:45:08 <Aetherspawn> wait
22:45:11 <jle`> id is the identity morphism
22:45:12 <Aetherspawn> haskell platform this week?
22:45:14 <Aetherspawn> seriously?
22:45:26 <prooftechnique> Aetherspawn: Wait, wat?
22:45:43 <jle`> athan: you can think of functions of type a -> m b as sort of morphisms from a to b
22:45:55 <jle`> a side-effectful morphism/arrow
22:46:01 <jle`> and so it makes sense to define a (.) for them
22:46:11 <dmj`> Aetherspawn: it does build on windows for me
22:46:16 <Aetherspawn> I'm assumin carter was telling me 7.8 this week, HP next
22:46:22 <Aetherspawn> dmj`: cygwin is NOT windows.
22:46:23 <jle`> athan: take a a -> m b, a b -> m c,  and make a 'giant' a -> m c
22:46:27 <Aetherspawn> you cant give people the binary
22:46:34 <carter> Aetherspawn: HP not happening fast
22:46:44 <carter> i'm sayin
22:46:48 <carter> help mark on HP
22:46:53 <carter> its using shake! ;)
22:47:10 <ReinH> carter: hai
22:47:15 <carter> hai
22:47:16 <carter> sup
22:47:18 <erisco> shake the build system?
22:47:24 <carter> yes
22:47:29 <carter> not the harlem one
22:47:32 <jle`> athan: and so what Arrow does is...an Arrow is a Category that has the ability to compute things 'side by side' and 'side-chain' compositions...split a value, apply stuff to one version of it, and then re-combine it later
22:47:43 <Aetherspawn> aw
22:47:44 <jle`> well, not recombine
22:47:50 <Aetherspawn> 64-bit llvm support never fixed in time :'(
22:47:52 <ReinH> jle`: that's a bit confusing :p
22:48:01 <erisco> :D I am using that for our project too... nice and simple
22:48:01 <carter> Aetherspawn: write a patch
22:48:01 <jle`> ReinH: :|
22:48:02 <carter> :P
22:48:02 <Aetherspawn> gotta wait till 7.10
22:48:03 <jle`> mk
22:48:04 <SrPx_> nisstyre: the clean compiler? How? You mean my code?
22:48:10 <SrPx_> prooftechnique: I don't think so, interesting
22:48:10 <Aetherspawn> in like 10 hours?! D:
22:48:16 <jle`> he'll probably learn it better figuring it out himself
22:48:17 <Aetherspawn> I can't build it within that time.
22:48:18 <SrPx_> prooftechnique: it is more about the V8 though, no?
22:48:19 <carter> Aetherspawn: for 7.8.2
22:48:26 <Aetherspawn> 5 days min for a windows build
22:48:37 <athan> jle` So it's inline description equates down to parallel execution?
22:48:42 <nisstyre> SrPx_: I mean I've found that for very similar code the compiler for the Clean language generates a binary that is faster
22:48:43 <carter> Aetherspawn: sounds like you need to use an AWS box
22:48:49 <athan> jle` That's goddamn insane lol
22:48:54 <athan> jle` but so intuitive haha
22:48:59 <Aetherspawn> setting up a cross sounds painful
22:48:59 <jle`> athan: yeah, not parellel like IO parallel
22:49:09 <athan> :/
22:49:09 <Aetherspawn> I wonder if its easier to setup a cross than do a home build
22:49:09 <prooftechnique> SrPx_: No clue. Can't say I really know much about node, I just have it installed because some projects I work on use grunt and bower
22:49:12 <prooftechnique> :D
22:49:17 <jle`> athan: but consider first
22:49:18 <athan> just theoretically parallel, correct?
22:49:19 <jle`> :t first
22:49:19 <lambdabot> Arrow a => a b c -> a (b, d) (c, d)
22:49:24 <SrPx_> anyway, let me ask a quick question, as you can see, my Haskell->JS programs are almot 100x slower than my js program. Considering emscripten generates kinda 2~3x slower than native programs, if I just compile Haskell programs to javascript using it should I expect it to be faster than what im getting with Haste/Fay?
22:49:36 <jle`> first takes an arrow from a -> b, and turns it into an arrow that works on the first item of a tuple
22:49:37 <carter> SrPx_: which thing
22:49:54 <SrPx_> nisstyre: I see, the clean compiler is great, but it is unmaintained now, right?
22:49:55 <jle`> and consider (&&&)
22:49:58 <nisstyre> SrPx_: ask luite_
22:49:58 <jle`> :t (&&&)
22:49:58 <lambdabot> Arrow a => a b c -> a b c' -> a b (c, c')
22:50:05 <dmj`> Aetherspawn: do you have 7.8 on windows?
22:50:06 <nisstyre> SrPx_: I think it is maintained
22:50:11 <athan> ahhh yeah
22:50:13 <jle`> (&&&) takes two arrows, and turns it into a 'parallel arrow' that operates on two sides of a tuple in parallel
22:50:15 <Aetherspawn> nope
22:50:18 <prooftechnique> SrPx_: You may be interested in https://github.com/ghcjs/ghcjs
22:50:20 <Aetherspawn> waiting for the actual release
22:50:24 <Aetherspawn> the last one had segfault issues
22:50:25 <jle`> er sorry, i meant (***)
22:50:28 <jle`> :t (***)
22:50:29 <lambdabot> Arrow a => a b c -> a b' c' -> a (b, b') (c, c')
22:50:31 <athan> I get ya
22:50:35 <SrPx_> nisstyre: I never see anyone talking about it and it is not on computer benchmark game... I thought it was unmaintained, sorry. who is luite_
22:50:43 <athan> &&& is more of result binding
22:50:45 <nisstyre> SrPx_: the creator of ghcjs
22:50:48 <jle`> (&&&) is forking
22:50:53 <SrPx_> nisstyre: oh I see.
22:50:56 <athan> oh....
22:50:58 <athan> hmm
22:51:01 <nisstyre> SrPx_: it didn't get the same popularity of Haskell but it is extremely similar
22:51:02 <SrPx_> prooftechnique: same performance pretty much ):
22:51:06 <nisstyre> (lazy, pure, similar syntax)
22:51:07 <athan> oH!
22:51:12 <athan> yeah, I get it then
22:51:14 <SrPx_> nisstyre: uh huh i know
22:51:17 <luite_> oh hai
22:51:22 <jle`> (&&&) takes two arrows, which both take 'a'...and turns it into an arrow that takes an a and applies *both* arrows to it
22:51:33 <dmj`> Aetherspawn: looks like serious issues w/ windows on 7.8, https://ghc.haskell.org/trac/ghc/wiki/Status/GHC-7.8
22:51:48 <SrPx_> nisstyre: are you using it for something?
22:51:55 <nisstyre> luite_: SrPx_ had a question about javascript above
22:51:59 <prooftechnique> SrPx_: I seem to remember there being a performance regression on Mavericks under 7.6.3 which was fixed in 7.8, so that may be what's biting you
22:52:05 <Aetherspawn> there was quite a few...
22:52:13 <Aetherspawn> I think simon marlow ninja fixed all of them yesterday
22:52:15 <luite_> SrPx_: yeah we basically did a rewrite of most of it, starting about 18 months ago, it's nw almost ready for release on hackage
22:52:22 <prooftechnique> Though I can't even get node 0.8.4 to compile, so I have no idea if it's better than 0.11.11
22:52:26 <nisstyre> SrPx_: not really, I don't have a good use for it, but writing a game with it (and using the FFI to get an engine) might be fun
22:52:31 <Aetherspawn> that is, all the segfault stuff
22:52:38 <Aetherspawn> the shared lib stuff we cant do anything about
22:52:40 <athan> this is exactly what I needed
22:52:45 <athan> thanks jle`
22:52:47 <Aetherspawn> ask @carter for the story about the symbols
22:52:54 <carter> ???
22:53:01 <Aetherspawn> 64k upper limit
22:53:08 <carter> windows sucks
22:53:12 <carter> but Aetherspawn  uses it a lot
22:53:13 <Aetherspawn> lol
22:53:13 <prooftechnique> Yeah, I heard
22:53:28 <jle`> athan: no problem. arrow interfaces have actually fallen out of vogue these days
22:53:30 <jle`> sadly
22:53:30 <dmj`> carter: yes, yes it does
22:53:36 <carter> does have nice games
22:53:41 <jle`> one place arrows are still popular is though is for AFRP
22:53:46 <SrPx_> nisstyre: interesting (: would it be easier to compile clean to js?
22:53:55 <nisstyre> SrPx_: I don't think so
22:53:58 <SrPx_> prooftechnique: hmm perhaps
22:54:10 <jle`> it turns out that Applicative interfaces pretty much the same power as arrow interfaces...give or take some things
22:54:16 <athan> jle` I think it's a perfect spot for them
22:54:18 <jle`> so these days most libraries come with an Applicative library
22:54:28 <jle`> *interface
22:54:30 <athan> the reason why I find the other's interesting are due to their abstractness
22:54:31 <nisstyre> SrPx_: you might be able to make some optimizations that you can't with Haskell due to uniqueness types
22:54:48 <jle`> also i think back when Arrows were popular, Applicative wasn't really a thing that was studied on its own
22:54:49 <nisstyre> that is, due to Clean's use of them
22:54:56 <prooftechnique> SrPx_: Did you install ghc through brew or the pkg installer? You can try out 7.8 today if you brew install ghc --devel
22:54:59 <athan> Eventually, I'd like to confidently do things like
22:55:00 <luite_> SrPx_: the new version completely changes how closure conversion (no js closures anymore but plain old js objects) and cps transformation (now with explicit stack) are done, to bring down the cost of both to acceptable levels without giving up multithreading and heap knowledge
22:55:00 <jle`> but now that we have them we know that they are amazing
22:55:15 <nisstyre> luite_: awesome :)
22:55:26 <nisstyre> luite_: it would be nice if you could use real structs for closures
22:55:51 <carter> prooftechnique: don't recoomment brew everrrr
22:55:54 <carter> don't brew your haskell
22:56:02 <prooftechnique> Why not?
22:56:07 <nisstyre> as in a struct that you just extract fields from for the free variables
22:56:08 * hackagebot exceptions 0.4 - Extensible optionally-pure exceptions  http://hackage.haskell.org/package/exceptions-0.4 (EdwardKmett)
22:56:15 <nisstyre> but I guess that's asking too much of JS
22:56:15 <bitemyapp> carter: eh. I was using Haskell platform but had to use homebrew Haskell to get haste working.
22:56:26 <carter> bitemyapp: i just build my own
22:56:27 <SrPx_> prooftechnique: interesting, thanks! I had **lots** of trouble in installing the haskell platform and making everything work on mavericks. It ended up working with a brew install and some quirks. I might try the --devel flag, ty (:
22:56:31 <carter> i've had brew do weird shit
22:56:34 <athan> ((( (((fmap inital data on functor) apply some applicative params) force monadic dependant events) turn into arrow with another expression like this)))
22:56:35 <carter> and then I had to yell at em
22:56:36 <bitemyapp> carter: I don't think anybody is going to build their own.
22:56:42 <carter> bitemyapp: i have a build online
22:56:42 <athan> then do like, applicative crap on that arrow too
22:56:43 <athan> lol
22:56:46 <carter> its really easy
22:56:47 <bitemyapp> carter: people like you will, but the hoi polloi won't.
22:56:53 <bitemyapp> carter: I'm just being realistic :P
22:56:58 <carter> thats why  yell at them to not fuck it yup
22:57:34 <erisco> athan, well arrows are not applicative, so you can't exactly do that
22:57:48 <athan> erisco: crap...
22:57:53 <athan> erisco: couldn't they be, though?
22:57:54 <prooftechnique> carter: I remember it was pretty borked for a bit a few months back, but I think it has stabilized, now. I do usually build my own, though. Wanna make sure all my flags are set properly :D
22:58:01 <luite_> nisstyre: ghcjs uses normal js objects, a thunk with 2 free vars has properties { f, d1, d2, m }, where f is the function that returns the reduced (whnf) result of the thunk (just a global function, no closure), d1, d2 are the free vars, m is a special thing for reachability testing (so we can do weak references, throw the dreaded "thread blocked indefinitely in an MVar operation" exception etc)
22:58:02 <jle`> most useful arrows are associated with a useful applicative instance though
22:58:02 <athan> erisco: couldn't they're just another function
22:58:06 <bitemyapp> I still haven't found a use for Control.Arrow
22:58:12 <jle`> actually...i think if you have an Arrow, you get an applicative instance for free
22:58:14 <bitemyapp> let me know if you folks find one.
22:58:15 <jle`> yeah, you do
22:58:16 <carter> bitemyapp: circuits
22:58:19 <luite_> nisstyre: oh and m is also used for stablename support
22:58:20 <jle`> bitemyapp: AFRP :)
22:58:23 <bitemyapp> carter: I don't model circuits.
22:58:28 <bitemyapp> jle`: okay that's intriguing.
22:58:31 <carter> real time decision things
22:58:34 <nisstyre> luite_: yep that makes sense
22:58:35 <athan> jle` knew it!
22:58:46 <nisstyre> luite_: that's about as optimized as you can get with normal JS
22:58:51 <bitemyapp> carter: my work is too boring :P
22:58:55 <carter> bitemyapp: :P
22:59:00 <carter> optimize your parsers
22:59:02 <erisco> jle`, they are different kinds
22:59:04 <jle`> athan: but remember that if you have Arrow r, you have Applicative (r a)
22:59:05 <carter> make em epplciative
22:59:18 <jle`> but if you have an arrow r you can get a free applicative (r a)
22:59:24 <bitemyapp> carter: bah, I'm in the middle of figuring out how to separate type-dispatch aeson results from an outer layer that needs to be pre-parsed.
22:59:27 <Aetherspawn> sigh
22:59:31 <bitemyapp> er, type-dispatched*
22:59:32 <jle`> pure x = arr (const x)
22:59:39 <carter> bitemyapp: type classes
22:59:41 <jle`> (<*>) = something something
22:59:43 <jle`> something
22:59:50 <Aetherspawn> carter: why does ghc take so long to build
22:59:51 <athan> lol
22:59:52 <carter> jle`: you're not doing a very good jot
22:59:53 <bitemyapp> carter: well, yes, but *precisely* how is another matter.
23:00:00 <carter> Aetherspawn: becasue jesus hates you
23:00:02 <carter> :)
23:00:04 <athan> <*> = $
23:00:04 <carter> i kid
23:00:07 <athan> wouldn't it?
23:00:09 <luite_> nisstyre: they are pretty fast though, since jit compilers generate code with hardcoded offsets for these objects
23:00:18 <athan> because an arrow is just natively applied, right?
23:00:22 <carter> Aetherspawn: get a bigger machine
23:00:23 <nisstyre> luite_: yeah of course
23:00:24 <athan> er wait
23:00:25 <bitemyapp> carter: the problem is that basically I get a JSON response that has status fields set at the top layer that I need to parse and react to before the user gets the inner document of results.
23:00:30 <athan> Why can't we just do that with functors
23:00:30 <athan> ?
23:00:33 <erisco> jle`, athan yeah that seems correct ... I have the instance lying around somewhere
23:00:35 <athan> DAMN YOU CONTEXT
23:00:41 <bitemyapp> carter: but I don't know what type the inner results will be, it'll probably be end-user product types.
23:00:44 <jle`> http://cdsmith.wordpress.com/2011/07/30/arrow-category-applicative-part-i/
23:00:46 <bitemyapp> product and sum, really.
23:00:50 <carter> bitemyapp: but json?
23:00:51 <carter> well
23:00:51 <Aetherspawn> my machine is fine
23:00:58 <carter> Aetherspawn: nah, its tiny
23:01:03 <Aetherspawn> there is no difference between -j2 and -j4 on ghc
23:01:04 <bitemyapp> carter: yeah, it's elasticsearch.
23:01:07 <athan> speaking of machines....
23:01:09 * hackagebot lens 4.1.2 - Lenses, Folds and Traversals  http://hackage.haskell.org/package/lens-4.1.2 (EdwardKmett)
23:01:12 <athan> I need to get into that library
23:01:14 <Aetherspawn> I have an ssd and my cores float at like 30%
23:01:20 <carter> -j40
23:01:20 <edwardk> me too
23:01:26 <carter> edwardk:?
23:01:33 <carter> ah
23:01:34 <carter> hehe
23:01:37 <edwardk> i need to get back into machines =)
23:01:38 <athan> edwardk: what's the latest you've been working on?
23:01:40 <jle`> carter: :'(
23:01:44 <carter> jle`: ?
23:02:00 <erisco> athan, and if you have ArrowApply you can define a Monad instance
23:02:01 <jle`> my lack of good jot
23:02:02 <bitemyapp> carter: so basically I need my client library to behave a bit like Aeson, but it's a step-removed.
23:02:10 <luite_> nisstyre: but if you have ideas for improving the object storage i'd be happy to experiment. the fastest or most efficient structure might be engine dependent though
23:02:13 <bitemyapp> because I'm handling some plumbing.
23:02:21 <carter> so wrapp up stuff more
23:02:21 <nisstyre> edwardk: I am looking at doing something with ARM bare metal...for fun :P
23:02:36 <nisstyre> luite_: I don't have a better idea than that no
23:02:44 <carter> nisstyre: ?
23:02:47 <bitemyapp> speaking of arrows: https://gist.github.com/fizbin/7217274
23:03:17 <athan> so... where does a lens fit into all this?
23:03:17 <nisstyre> carter: I was joking about "machines"
23:03:19 <edwardk> athan: trying to make `structures` faster while retaining the full deamortized asymptotics, working on the type checker for ermine which is almost usable now, been getting ready to ship a new version of ad - ad 4 will support monomorphic AD modes. been banging out a lot of javascript physics code in arcade
23:03:26 <athan> functor => app => monad business?
23:03:39 <erisco> lens is a completely different game
23:03:39 <edwardk> i use lens as an integral part of most of my code these days
23:03:50 <erisco> which edwardk can tell you all about :P
23:03:59 <athan> That's friggin awesome man
23:04:05 <athan> keep it up
23:04:08 <erisco> I think he sets his IRC window to ping him when someone says "lens"
23:04:11 <dmj`> Someone be honest with me. How bad does ghc suck on windows
23:04:16 <edwardk> erisco: sometimes =)
23:04:18 <athan> HA
23:04:26 <Aetherspawn> uhh
23:04:29 <Aetherspawn> uhhh
23:04:37 <edwardk> erisco: i try to vary my pings, otherwise everyone gets wise to them
23:04:41 <athan> im guessing it has to do with decidability
23:04:49 <athan> er...
23:04:52 <athan> something... automated
23:04:52 <athan> lol
23:05:03 <bos> @pl \(Foo a b) -> unFoo a b
23:05:03 <lambdabot> (line 1, column 7):
23:05:03 <lambdabot> unexpected "a"
23:05:03 <lambdabot> expecting operator or ")"
23:05:10 <bos> damn you, lambdabot
23:05:14 <Aetherspawn> the irony is that MSR funds ghc
23:05:54 <bitemyapp> Not that that means they get a free hand in setting priorities. It's an open source project, they pay for the labors of some smart people that happen to work on it.
23:06:02 <edwardk> lets see other recent projects, making linear work nicely with accelerate, branchless versions of the combinators in Linear.Quaternion and the instances for Data.Complex, so they can be more friendly to GPU code, like in accelerate
23:06:09 <dmj`> Don't tell me GHC is the first Microsoft product that doesn't work on Windows
23:06:16 <bitemyapp> dmj`: it's not, actually.
23:06:29 <dmj`> haha, unsurprising
23:06:31 <Aetherspawn> Windows is the first.
23:06:35 <bitemyapp> Aetherspawn: I think they care more about F# these days, which seems designed to keep the C# developers from committing seppuku without necessarily bringing them to satori.
23:06:47 <athan> What do you do, Edward? For a living?
23:06:51 <Aetherspawn> well
23:06:57 <Aetherspawn> iunno, *something* has to be fixed
23:06:59 <bitemyapp> athan: I'm going to take a wild guess and say it involves programming and math :P
23:07:04 <athan> I feel like it must be like space age stuff
23:07:05 <Fuuzetsu> athan: robots do not need jobs
23:07:10 <carter> heh
23:07:13 <athan> HA
23:07:15 <Aetherspawn> I had a more pleasent experience porting rust to a new platform (and its bootstrapping) than actually building a primary platform ghc
23:07:19 <bitemyapp> Aetherspawn: I'm with bos on this. Windows users are too fast to whine, too slow to roll up their sleeves.
23:07:24 <edwardk> getting some work done on layout parsing in trifecta, had a couple of grad students bang out a ton of improvements to free over the last month or so
23:07:55 <edwardk> athan: i write code for the financial industry
23:08:00 <carter> bitemyapp: true, i've not see Aetherspawn  help patch ghc yet
23:08:02 <Aetherspawn> where did bos say that
23:08:03 <carter> :)
23:08:04 <bitemyapp> edwardk: is a free reasonable base for tinkering with a DSL?
23:08:16 <bitemyapp> Aetherspawn: I'm paraphrasing from what was, to my memory, a Reddit comment of his.
23:08:19 <nisstyre> luite_: do you do any sort of analysis of when a closure is escaping or not?
23:08:26 <bitemyapp> er, "is free a reasonable"
23:08:26 <carter> bitemyapp: bound is worth checking out
23:08:27 <athan> edwardk: How much sleep did you have to sacrifice to get there?
23:08:29 <edwardk> bitemyapp: i use free monads as a starting point whenever i don't know what my semantics will be
23:08:37 <edwardk> athan: all of it for a few years
23:08:37 <athan> edwardk: And would you suggest it? lol
23:08:42 <bitemyapp> edwardk: that's what I was thinking. Thanks!
23:08:59 <bitemyapp> carter: I don't actually understand bound at the moment, but I feel okay tackling free monads for a library.
23:09:05 <carter> ok
23:09:11 <bitemyapp> carter: I just need to model nested constraints against nouns for the most part.
23:09:14 <bitemyapp> it's not that complicated.
23:09:24 <edwardk> bitemyapp: bound is useful when you need to add names/variables to your EDSL
23:09:25 <carter> bitemyapp: well, i'd say "mess with the example languages in the bound github"
23:09:31 <bitemyapp> my primary concern is actually syntax. I want this to be a PRETTY library :P
23:09:31 <carter> its really simple
23:09:39 <carter> just whack on the examples
23:09:39 <edwardk> before that, free is fine
23:09:57 <bitemyapp> edwardk: carter thanks the both of you :)
23:10:01 <carter> bitemyapp:  open or closed universe?
23:10:03 <edwardk> whe you want users to be able to define lambdas and to reason about that code, then turn to bound.
23:10:10 <bitemyapp> carter: hum, define please?
23:10:10 <athan> edwardk: Better get to work, then! One last question - what was your catalyst for understanding, using, then reinventing lenses?
23:10:22 <carter> "fixed set of primops"
23:10:23 <carter> vs open
23:10:38 <edwardk> fighting with roconnor until he convinced me he was right ;)
23:10:56 <edwardk> then making his tricks my own
23:11:04 <bitemyapp> carter: has to be fixed unless I want to write a codegen for the scripting language, it's in terms of the elasticsearch search/match DSL
23:11:07 <athan> I can dig it
23:11:09 <bitemyapp> carter: unless I've misunderstood something.
23:11:24 <bitemyapp> ...and I'm not writing codegen for the scripting language.
23:11:33 <bitemyapp> nobody does that.
23:11:54 <athan> Righteous. Thanks everybody for all the kindness, assistance, company, and all that shit!
23:11:57 <athan> Goodnight yall!
23:12:04 <bitemyapp> athan: cheers.
23:12:38 <bos> @hoogle [b] -> (a -> b) -> [a] -> [b]
23:12:38 <lambdabot> Data.Generics.Aliases mkQ :: (Typeable a, Typeable b) => r -> (b -> r) -> a -> r
23:12:38 <lambdabot> Data.Data gmapQi :: Data a => Int -> (forall d. Data d => d -> u) -> a -> u
23:12:38 <lambdabot> Data.Data gmapQr :: Data a => (r' -> r -> r) -> r -> (forall d. Data d => d -> r') -> a -> r
23:13:03 <bos> :-p
23:13:07 <Aetherspawn> right, well
23:13:13 <Aetherspawn> someone get rid of the evil mangler first
23:13:18 <Aetherspawn> and then we'll talk about fixing windows.
23:13:46 <edwardk> Aetherspawn: we have't had one for 3 years or so
23:13:53 <edwardk> so time to talk about fixing windows
23:13:54 <dmj`> Aetherspawn: what is the evil mangler exactly
23:13:56 <bitemyapp> what evil mangler?
23:13:57 <carter> Aetherspawn: you keep on readnig out dated stuff :)
23:14:07 <carter> bitemyapp: years ago, perl script to patch asm
23:14:12 <bitemyapp> hahahahahha
23:14:17 <bitemyapp> carter: that is freakin' diabolical. I love it.
23:14:18 <Aetherspawn> sigh
23:14:33 <Aetherspawn> isn't it still around, or is it only for llvm?
23:14:35 <bos> written by will partain in the early 1990s.
23:14:46 <luite_> nisstyre: GHC does some analysis for a common pattern an generates LetNoEscape bindings in the STG code for those
23:14:52 <Aetherspawn> llvm is definately not using the new prefix thingy in 3.4
23:15:02 <carter> Aetherspawn: its not using that yet
23:15:13 <nisstyre> luite_: neat, I really need to have a look at the source
23:15:14 <edwardk> bitemyapp: ghc commonly uses an optimization called 'tables next to code', the evil mangler was responsible for shuffling the code for the info tables right up next to the beginning of the block of code they were for.
23:15:14 <carter> Aetherspawn: the mangling in llvm is just for TNC
23:15:23 <bitemyapp> perl scripts are like overfed, undersocialized ocelots. They're cute and fun at first, but they get big, messy, and violent over time.
23:15:26 <nisstyre> maybe see if there's anything I can do, though I'm still a noob at writing compilers
23:15:33 <nisstyre> I could help with small stuff though
23:15:45 <carter> and the modern LLVM mangler isn't in perl
23:15:48 <carter> i think its in haskell now
23:15:50 <luite_> nisstyre: but that's actually pretty limited... and ghcjs unfortunately doesn't support generating better code for those yet, which is a bit of a performance hit
23:16:09 <erisco> jle`, took me long enough then I figured out I had not imported Control.Category so it was using the function arrow... d'oh
23:16:22 <erisco> :t \x y -> arr (uncurry id) . (x &&& y)
23:16:23 <carter> bos: is that info in the hopl papers or git repos?
23:16:23 <lambdabot> (b1 -> b -> c) -> (b1 -> b) -> b1 -> c
23:16:36 <jle`> erisco: :)
23:16:39 <erisco> well, lambdabot is using the function arrow too but that is the definition
23:16:56 <jle`> :t \x y -> arr (uncurry Control.Category.id) . (x &&& y)
23:16:56 <lambdabot> (b1 -> b -> c) -> (b1 -> b) -> b1 -> c
23:17:06 <jle`> :/
23:17:07 <luite_> nisstyre: but i'll probably add proper letnoescape support in a few months, after the more important bugs hav been fixed :)
23:17:24 <jle`> oh
23:17:25 <erisco> :t \x y -> arr (uncurry Control.Category.id) `Control.Category.(.)` (x &&& y)
23:17:25 <lambdabot> parse error on input `.'
23:17:30 <erisco> erm
23:17:37 <jle`> :t \x y -> arr (uncurry Control.Category.id) Control.Category.. (x &&& y)
23:17:38 <lambdabot> Arrow cat => cat a (b -> c) -> cat a b -> cat a c
23:17:38 <carter> luite_: what are you doing in life after zurihac + ghcjs release?
23:17:40 <luite_> nisstyre: there is no problem in the architecture to support it, the code generator just needs to keep track of a few more things
23:17:41 <jle`> woo hoo
23:17:45 <erisco> yay
23:17:56 <jle`> wait, what are you trying to do?
23:18:02 <carter> bah
23:18:03 <carter> tired
23:18:04 <erisco> implement <*>
23:18:04 <carter> ok
23:18:09 <nisstyre> luite_: are closures in ghcjs "linked", that is, can you follow the trail upwards, or do the free variables just get all packed in in one flat array?
23:18:09 <carter> actaully time for rest
23:18:09 <jle`> ah
23:18:12 <jle`> gj :)
23:18:12 <carter> happy hacking all
23:18:19 <jle`> night carter
23:18:20 <carter> nisstyre: ooo, goo question
23:18:30 <jle`> bitemyapp: i just realized that your twitter avatar was a wolf
23:18:36 <bitemyapp> jle`: that's a bear mate.
23:18:40 <jle`> oh
23:18:41 <jle`> well
23:18:43 <bitemyapp> jle`: a sunglasses wearing, ridiculously awesome bear.
23:18:43 <jle`> another revelation :)
23:18:49 <jle`> i always thought it was the head of a fish
23:18:54 <bitemyapp> derferk
23:18:58 <jle`> no offense, i love and respect fish greatly.
23:19:01 <jle`> i think it's the coloring
23:19:08 <bitemyapp> I just had some really good fish for dinner.
23:19:23 <bitemyapp> fried crappie, fished out a lake.
23:19:35 <bitemyapp> with chips and english pub ale.
23:19:36 <jle`> let me see if i can find a good picture to compare
23:20:00 <luite_> nisstyre: every individual closure is flat, but any free var can refer to some other closure
23:20:05 <jle`> https://encrypted-tbn1.gstatic.com/images?q=tbn:ANd9GcTrF45mAtIAbv8q6ICQ6FH61OxmD-urvZIOAqLLlLQxmt_bg5Wx
23:20:33 <jle`> https://encrypted-tbn2.gstatic.com/images?q=tbn:ANd9GcTrwVEBfrQ6H1p3cn1YXNh_nWwWNptDDcjluUy-0oX2FbLAEFy4
23:20:38 <nisstyre> luite_: makes sense
23:20:39 <jle`> that is all. good night everyone.
23:20:55 <luite_> nisstyre: but it's not like js with nested closures. haskell gives us an advantage, since the free vars are immutable, we can freely copy them, keeping the lookup chain short
23:21:15 <jle`> oh hey my data parallelism system using arrow combinators seems to work
23:21:26 <jle`> now to test it on real parallelism problems
23:21:35 <nisstyre> luite_: Compiling with Continuations suggests the linked method may give you smaller closures
23:21:53 <nisstyre> assuming a lot of variables are free in both the closure and the outer scope
23:22:04 <nisstyre> and then you can use something like a skiplist to efficiently find them
23:22:11 <bitemyapp> jle`: wait what? lpaste?
23:22:15 <bitemyapp> jle`: github?
23:22:23 <jle`> bitemyapp: fish?
23:22:37 <bitemyapp> jle`: the data parallelism. :|
23:23:42 <jle`> oh haha. it's just a proof of concept/toy for now
23:23:45 <jle`> let me throw it up
23:24:50 <jle`> http://lpaste.net/101774
23:24:56 <nisstyre> luite_: but I suppose memory is cheap
23:25:11 <jle`> i'm a little embarassed to be putting it up considering the list of people who are active in irc right now
23:25:20 <luite_> nisstyre: indirections ar still relatively expensive though. currently GHC's intermediate code doesn't seem to make the linked closure approach particularly easy though
23:25:30 <nisstyre> fair enough
23:26:43 <bitemyapp> jle`: dude, I just wrote a public blog post about mutable closures in Haskell. mega embarrassing.
23:26:46 <bitemyapp> jle`: post anyway >:)
23:27:32 <jle`> :)
23:27:45 <bitemyapp> modifyIORef'? Who even does that.
23:28:20 <bitemyapp> jle`: post please, I want learnins. :(
23:28:36 <jle`> i just did actually
23:28:44 <jle`> scroll up a bit, or
23:28:49 <bitemyapp> oh dammit
23:28:50 <jle`>  http://lpaste.net/101774
23:28:58 <bitemyapp> sorry
23:29:59 <jle`> ignore the debug messages
23:30:01 <jle`> np
23:30:15 <bitemyapp> jle`: my reaction:   *_*
23:30:52 <jle`> heh
23:31:03 <jle`> the plumbing is ugly >.>
23:33:01 <nisstyre> luite_: you could also combine the two methods, for example in \a -> b * ((\c -> (c+d)) b), make b directly used in the closure (flat), but require d to be accessed via a link
23:33:08 <nisstyre> and then obviously the same for the inner function there
23:33:47 <nisstyre> that way you wouldn't have to bother copying things that will never be used
23:34:00 <nisstyre> at least I don't think you would
23:34:10 <nisstyre> not sure how it would perform during creation though
23:36:12 <no-n> @djinn a -> b
23:36:12 <lambdabot> -- f cannot be realized.
23:36:33 <jle`> it's unsafeCoerce, of course.
23:36:35 <erisco> :t unsafeCoerce
23:36:35 <lambdabot> Not in scope: `unsafeCoerce'
23:39:07 <jle`> hm there is a problem, it can only chain up to two parallel computations..three or more, it regroups and relaunches them.
23:39:21 <jle`> er, i mean, chain up to two sequentially
23:40:15 <jle`> it can chain (a, b) -> (c, d)  and (c, d) -> (e, f) into (a, b) -> (e, f), but it isn't smart enough to compress it if there is another (e, f) -> (g, h) after it.
23:43:21 <jle`> back to the drawing board
23:51:29 <smiller2> Hey guys.  Say I have a lazy, infinite list that's shared by many modules.  At the low level, I'm concerned by the memory usage.  Is it possible to return a low-level copy of this infinite list of ints that internally is a separate, unevaluated thunk?
23:54:04 <no-n> what is a "lightweight" thread?
23:54:39 <johnw> no-n: something that runs within the user space of the process, rather than as an OS-level construct, I believe
23:55:01 <no-n> interesting
23:55:02 <Aetherspawn> no-n: context switching without calling into the kernel
23:55:11 <Aetherspawn> calling into the kernel > 100ns
23:55:12 <no-n> are there drawbacks?
23:55:16 <dmj`> no-n: see forkOS vs. forkIO
23:55:22 <Aetherspawn> yeah, shitter scheduling.
23:55:29 <Aetherspawn> no info about actual processor characteristics/load
23:55:33 <johnw> not as much separation
23:55:43 <no-n> the bot tut suggested Use forkIO to add a command line interface, and you've got yourself an irc client with 4 more lines of code.
23:56:03 <no-n> from http://www.haskell.org/haskellwiki/Roll_your_own_IRC_bot#Roll_your_own_monad
23:56:09 <no-n> not sure exactly how that would be done though
23:56:25 <no-n> I've never programmed with threads
23:57:11 <johnw> read this book: http://chimera.labs.oreilly.com/books/1230000000929
23:57:45 <no-n> .-.
23:57:52 <Aetherspawn> no-n: one advantage of lightweight threads is often they handle IO a LOT better
23:58:29 <no-n> does the lightweight imply they cannot do as much heavy lifting?
23:58:42 <johnw> no, not at all
23:58:50 <johnw> it's a scheduling thing, not a quantity of work
23:58:53 <erisco> in os-speak I believe they are application-level threads
23:58:57 <Aetherspawn> same as OS threads
23:59:01 <johnw> lighweight means roughly "inexpensive to have tons of them"
23:59:01 * no-n doesn't understand the description
23:59:04 <Aetherspawn> in terms of what you can do in them
23:59:13 <Aetherspawn> You can't have 1000 OS threads
23:59:17 <erisco> ie the haskell runtime is solely responsible for scheduling the threads
23:59:18 <Aetherspawn> but you can have 20,000 lightweight threads
23:59:20 <erisco> could be wrong
23:59:20 <Aetherspawn> hence, lightweight.
23:59:29 <johnw> you could easily have a million lightweight threads, in fact
23:59:31 <no-n> ahhh
23:59:35 <no-n> that's nice :)
23:59:40 <Aetherspawn> well, heh
23:59:59 <johnw> in fact, the Haskell scheduler will assign threads to different cores for you even, mapping multiple lightweight threads into individual OS threads
