00:06:02 <mfzb> hei...  looking for hints on setting up ghc-7.8-rc1?  i think i am stuck in a circular dependency: cabal install deepseq => "need cabal"; cabal install Cabal => "need deepseq".
00:18:50 <Kneiva> luite: that redirects to https://github.com/ghcjs/ghcjs/wiki
00:20:19 <Kneiva> luite: now I signed in and it offers me blank "create new page" editor
00:25:14 <jle`> is that the joke?
00:25:17 <jle`> that the ideas are up to you?
00:25:43 <jjhsiung> hi
00:25:47 <jle`> hi jjhsiung
00:26:29 <jjhsiung> anyone have an suggestion as to where i can continue learning haskell, i just finished going through LYAH
00:27:06 <jle`> :D
00:27:37 <jle`> i think just trying out your own small projects/ports is good, and reading blog posts here and there along the way
00:27:43 <jle`> a lot of people recommend real world haskell
00:28:00 <jle`> but it is getting slightly dated, but still good
00:28:11 <jle`> i like Simon Marlow's Parallel & Concurrent Haskell book a lot
00:28:12 <jjhsiung> alright, i'll look into that
00:28:16 <jjhsiung> thanks jle'!
00:28:26 <jle`> even if you don't go into concurrent programming
00:28:33 <jle`> it teraches you a lot of modern idioms
00:28:44 <jjhsiung> i'm actually pretty interested in how haskell does that, i'm in a OS class right now
00:28:45 <jle`> and the general thought process behind attacking problems
00:28:55 <jle`> for all problems
00:29:03 <jle`> but i think the best thing is just to start hacking porjects now :)
00:29:08 <jle`> port over your projects from other languages :)
00:29:51 <letrec> I'm writting something like that for a generic queue: http://lpaste.net/100769 The issue is, the type checker can't infer a when I'm using pop in my code. Any idea how to solve this?
00:30:40 <jjhsiung> thanks jle'!
00:31:36 <yoeight> letrec: if a and c are fixed, you need functional dependencies
00:41:56 <Lethalman> hi, is random access to a finger tree supposed to be O(logn)?
00:42:32 <Lethalman> I believe I'm misunderstanding the spine... does the spine split the structure in 2 or 3 branches?
00:44:28 <opqdonut> yes it's O(log n). why would 2 vs 3 matter?
00:45:05 <Lethalman> opqdonut, it's actually 2 or 3 branches.. I was misunderstanding it thinking it was a single pointer to the bottom structure
00:45:17 <Lethalman> like this: [digit] spine [digit]
00:45:30 <Lethalman> but in reality it's like [digit] (left, right) [digit]
00:45:51 <letrec> yoeight: It works, thanks!
00:45:51 <Lethalman> is that correct? (not very precise but somehow)
00:46:33 <opqdonut> yeah that's about right
00:47:06 <opqdonut> check the definitions of FingerTree and Node at http://hackage.haskell.org/package/containers-0.2.0.1/docs/src/Data-Sequence.html
00:47:18 <Lethalman> opqdonut, yes I'm a little lost with Node :P
00:47:45 <c_wraith> It uses polymorphic recursion
00:47:49 <c_wraith> That makes it a little tricky
00:48:37 <opqdonut> yeah you have the tree depth encoded at type level by having a type (Node (Node (Node (Node Int))))
00:51:07 <Lethalman> opqdonut, that would be a Node with 1 branch only
00:51:24 <c_wraith> No, that's the type
00:51:28 <c_wraith> Not the constructors
00:51:50 <opqdonut> yep
00:52:00 <Lethalman> ops :9
00:52:13 <opqdonut> an example value of type (Node (Node Int)) would be (Two (Three 1 2 3) (Three 4 5 6))
00:52:25 <opqdonut> yeah it's slightly tricky
00:52:39 <opqdonut> but I think hinze's paper does a good job of explaining the trickyness
00:52:42 <opqdonut> or so I recall
00:53:05 <opqdonut> (http://www.soi.city.ac.uk/~ross/papers/FingerTree.html)
00:54:38 <luite> Kneiva: oh sorry, nust hav made a copy/paste error
00:54:53 <shachaf> If you aren't familiar with polymorphic recursion, Data.Sequence is probably not the easiest example to learn from.
00:55:17 <shachaf> (Or non-regular data types, I guess I mean in this case.)
00:56:23 * hackagebot ponder 0.0.1 - PEG parser combinator  http://hackage.haskell.org/package/ponder-0.0.1 (matt)
00:56:31 <c_wraith> traversing the nodes is polymorphic recursion, the data type is non-regular.
00:58:47 <shachaf> Yep.
00:59:05 <shachaf> Any reasonable use of the latter requires the former, so I put them in the same bucket.
00:59:15 <c_wraith> makes sense
01:03:05 <luite> Kneiva: https://github.com/ghcjs/ghcjs/wiki/GHCJS-Google-Summer-of-Code-project-ideas
01:05:03 <Kneiva> luite: great, thanks
01:06:24 * hackagebot egison 3.3.0 - Programming language with non-linear pattern-matching against unfree data types  http://hackage.haskell.org/package/egison-3.3.0 (SatoshiEgi)
01:11:25 * hackagebot egison-tutorial 3.3.0 - A tutorial program for the programming language Egison  http://hackage.haskell.org/package/egison-tutorial-3.3.0 (SatoshiEgi)
01:18:39 <dword> \
01:26:26 * hackagebot clash-ghc 0.2.1 - CAES Language for Synchronous Hardware  http://hackage.haskell.org/package/clash-ghc-0.2.1 (ChristiaanBaaij)
01:36:27 * hackagebot pipes-p2p 0.2 - P2P network nodes with pipes  http://hackage.haskell.org/package/pipes-p2p-0.2 (jdnavarro)
01:37:28 <narendraj9_> hello everyone! Could someone please tell me about some open source project written in Haskell?
01:38:12 <Okasu> narendraj9_: https://github.com/trending?l=haskell
01:38:25 <osa1> I probably know the answer but is there an option in ghci to redirect output to some file or some other stream? :-)
01:39:12 <osa1> I'm wondering how hard would it be to implement, I sometimes find it very useful to have (for debugging purposes)
01:39:23 <merijn> osa1: I suspect not, you could do that easily using some unix tools like tee, probably
01:39:51 <merijn> osa1: Not very hard, I suspect, depending on how properly you want to do it
01:40:30 <merijn> osa1: Take a look at programs like rlwrap for inspiration (rlwrap runs an existing executable, but adds readline functionality, like command history)
01:40:39 <osa1> merijn: yeah I considered using tee but then it'll be writing _all_ outputs to the file. I only want output of some function call ...
01:41:08 <merijn> osa1: If you start with rlwrap you just need to selectively dump outputs to a file
01:41:19 <osa1> hmm.. that sounds interesting.
01:41:29 <osa1> I can start dumping to a file with a command and then end using another command.
01:41:50 <osa1> sounds like a nice weekend project
01:42:42 <osa1> I guess I'll give it a try over the weekend. merijn thanks for the idea.
01:46:29 * hackagebot pipes-p2p-examples 0.2 - Examples using pipes-p2p  http://hackage.haskell.org/package/pipes-p2p-examples-0.2 (jdnavarro)
02:11:00 <absence> is there a performance difference between a $ b $ c and a . b $ c? i have a vague memory of reading something about inlining..
02:12:28 <johnw> check the core
02:14:16 <haasn> your vague memory of inlining is probably referring to “they're the same, due to inlining”
02:14:49 <ion> (a . b) c
02:15:29 <absence> johnw: core is a bit intimidating yet, but i'll get there :)
02:16:39 <absence> haasn: oh! what about a (b c) or ion's suggestion? are they all the same?
02:16:48 <ion> check the core
02:16:58 <absence> -_-
02:17:30 <ion> You’ll find this useful: http://hackage.haskell.org/package/ghc-core
02:18:40 <shachaf> Or ghc -ddump-simpl -O2 f.hs
02:18:48 <shachaf> -dsuppress-all etc.
02:19:17 <shachaf> Mostly you shouldn't care. But if you do care and you have a particular example you should look at the generated code.
02:21:33 * hackagebot Spock-worker 0.1.0.2 - Background workers for Spock  http://hackage.haskell.org/package/Spock-worker-0.1.0.2 (AlexanderThiemann)
02:21:49 <absence> shachaf: i don't REALLY care, but if there was a difference i would possibly reconsider what i write by default
02:22:26 <shachaf> :-(
02:22:53 <absence> shachaf: is that a bad thing?
02:22:55 <johnw> absence: you realize that decision would be tied to a particular version of GHC?  the optimizer is always evolving
02:22:58 <johnw> it's better not to care
02:23:09 <ion> absence: Premature optimization is bad.
02:24:05 <johnw> in fact, with processors being what they are these days, something doing a thing in a more elaborate way ends up being faster; you just never know.  And even if you profile extensively, you probably haven't discovered any general knowledge
02:25:59 <Fuco> ignorance is strenght (or, in this case, speed)
02:27:52 <absence> i think perhaps i was confused about "GHC will only inline the function if it is fully applied", which means pointfree isn't always a good idea (for a particular version of ghc yes...), and i somehow thought it had to do with calling functions as well
02:29:14 <absence> i'll stop thinking about it now :)
02:30:59 <h_h> lambdabot, help
02:31:08 <h_h> !help
02:31:13 <h_h> :(
02:31:55 <t7> h_h: @help i think
02:32:20 <h_h> @hoogle [String] -> String
02:32:22 <lambdabot> Prelude unlines :: [String] -> String
02:32:22 <lambdabot> Data.List unlines :: [String] -> String
02:32:22 <lambdabot> Data.String unlines :: [String] -> String
02:33:23 <h_h> t7, I already found http://www.haskell.org/haskellwiki/Lambdabot but thanks anyway :)
02:34:52 <h_h> @ty (++)
02:34:53 <lambdabot> [a] -> [a] -> [a]
02:35:38 <h_h> @ty unwords
02:35:39 <lambdabot> [String] -> String
02:36:04 <h_h> > unwords ['a'..'g']
02:36:05 <lambdabot>  Couldn't match type `GHC.Types.Char' with `[GHC.Types.Char]'
02:36:06 <lambdabot>  Expected type: GHC.Base.String
02:36:06 <lambdabot>    Actual type: GHC.Types.CharCouldn't match type `GHC.Types.Char' with `[GHC...
02:36:06 <lambdabot>  Expected type: GHC.Base.String
02:36:06 <lambdabot>    Actual type: GHC.Types.Char
02:36:19 <h_h> > unwords ["a".."g"]
02:36:20 <lambdabot>  No instance for (GHC.Enum.Enum GHC.Base.String)
02:36:21 <lambdabot>    arising from the arithmetic sequence `"a" .. "g"'
02:36:21 <lambdabot>  Possible fix:
02:36:21 <lambdabot>    add an instance declaration for (GHC.Enum.Enum GHC.Base.String)
02:36:35 * hackagebot cpphs 1.18.3 - A liberalised re-implementation of cpp, the C pre-processor.  http://hackage.haskell.org/package/cpphs-1.18.3 (MalcolmWallace)
02:36:59 <h_h> @ty ['a'..'g']
02:37:00 <lambdabot> [Char]
02:37:07 <h_h> @ty ["a".."g"]
02:37:07 <lambdabot>     No instance for (Enum [Char])
02:37:08 <lambdabot>       arising from the arithmetic sequence `"a" .. "g"'
02:37:08 <lambdabot>     Possible fix: add an instance declaration for (Enum [Char])
02:37:23 <absence> > unwords $ pure <$> ['a'..'g']
02:37:24 <lambdabot>  "a b c d e f g"
02:38:37 <h_h> :)
02:38:46 <h_h> @hoogle [Char] -> [String]
02:38:46 <lambdabot> Prelude lines :: String -> [String]
02:38:47 <lambdabot> Data.List lines :: String -> [String]
02:38:47 <lambdabot> Data.String lines :: String -> [String]
02:39:11 <h_h> > unwords (lines ['a'..'g'])
02:39:12 <lambdabot>  "abcdefg"
02:39:55 <h_h> > unlines (lines ['a'..'g'])
02:39:57 <lambdabot>  "abcdefg\n"
02:41:17 <h_h> > [x ++ x | x <- ['a'..'g']]
02:41:18 <lambdabot>  Couldn't match expected type `[a0]'
02:41:18 <lambdabot>              with actual type `GHC.Types.Char'Couldn't match expected type `[...
02:41:18 <lambdabot>              with actual type `GHC.Types.Char'
02:41:56 <Fuuzetsu> h_h: you can message lambdabot privately if you need to try out more than a few things
02:42:18 <h_h> oh, ok. Sorry for flooding channel.
02:42:28 <Fuuzetsu> also
02:42:38 <Fuuzetsu> > unwords $ map show ['a' .. 'g']
02:42:39 <lambdabot>  "'a' 'b' 'c' 'd' 'e' 'f' 'g'"
02:43:13 <Fuuzetsu> hm, show is the bad thing to use here
02:43:16 <Fuuzetsu> > unwords $ map return ['a' .. 'g']
02:43:17 <lambdabot>  "a b c d e f g"
02:43:37 <fly2web> hi
02:43:41 <Fuuzetsu> could just intercalate or something
02:44:04 <fly2web> i want study haskell but i don't know the way of haskell.
02:44:15 <Fuuzetsu> @where lyah
02:44:15 <lambdabot> http://www.learnyouahaskell.com/
02:45:01 <fly2web> i heard about haskell from my friend. i don't know haskell. what is strength of haskell?
02:46:15 <h_h> Fuuzetsu, but i don't know what is '$'
02:46:23 <sipa> @faq Can Haskell lift up an airplane with one finger?
02:46:23 <lambdabot> The answer is: Yes! Haskell can do that.
02:46:50 <johnw> fly2web: it makes it easier to reason about programs
02:46:57 <absence> h_h: it's function application with low operator precedence
02:47:14 <absence> h_h: so it really says unwords (map return ['a' .. 'g'])
02:47:24 <fly2web> i want study haskell for hacking? is it possible?
02:47:29 <johnw> sure
02:47:38 <johnw> Haskell can do most anything
02:47:47 <johnw> it may not be the best at everything, but it's very good at most things
02:47:50 <fly2web> python vs haskell? which is good?
02:47:56 <johnw> depends on what you're doing
02:48:03 <fly2web> i want hacking.
02:48:05 <johnw> if you're trying to get a Python job, Python is better :)
02:48:09 <fly2web> i can do python.
02:48:19 <sipa> fly2web: the easiest language is always the one you already know
02:48:24 <johnw> if all you want is results, Python can get you there faster since you already know it
02:48:35 <sipa> fly2web: haskell requires very very different thinking
02:48:42 <absence> fly2web: what do you mean by hacking?
02:48:43 <fly2web> i just find language for hacking.
02:48:53 <sipa> @where lyah
02:48:53 <lambdabot> http://www.learnyouahaskell.com/
02:48:54 <Phlogistique> B/g
02:49:01 <sipa> fly2web: you may want to read that site ^
02:49:01 <johnw> a lot of people learn haskell because they want to go through the process of learning it
02:49:06 <ion> You can hack on code in any language.
02:49:12 <fly2web> yes sipa right
02:49:18 <sipa> fly2web: but expect that it will take some time before you feel you're confident in it
02:49:33 <fly2web> how much?
02:49:41 <sipa> depends on you
02:49:57 <sipa> i'd suggest to just start reading, and as long as it's interesting, continue :)
02:50:05 <fly2web> i can do python and perl. and java and objective-c
02:50:20 <sipa> that's not very relevant
02:50:28 <fly2web> ok. but how can i install the haskell.?
02:50:35 <johnw> what OS are you on?
02:50:41 <fly2web> mac
02:50:47 <johnw> do you use Homebrew?
02:50:52 <fly2web> yes
02:50:55 <fly2web> i used it.
02:50:58 <johnw> I'd recommend: brew install haskell-platform
02:51:04 <fly2web> oh
02:51:07 <fly2web> i see.
02:51:18 <johnw> are you on Mavericks?
02:51:37 * hackagebot StateVar-transformer 1.0.0.0 - State variables  http://hackage.haskell.org/package/StateVar-transformer-1.0.0.0 (seagull)
02:51:39 <fly2web> yes i am mavericks
02:51:43 <johnw> then you'll probably need this advice: http://is.gd/H4sEub
02:52:14 <bergmark> easiest thing on mavericks is to install haskell platform from homebrew
02:52:40 <fly2web> bergey: thanks
02:52:49 <fly2web> then i use vim?
02:52:56 <fly2web> for haskell?
02:53:03 <sipa> for example
02:53:19 <sipa> or emacs, or notepad, or edlin
02:53:45 <fly2web> there is no ide like pyDev of python?
02:54:24 <sipa> there may be some, but i don't think they're very common
02:54:38 <fly2web> ok i see.
02:54:52 <johnw> fly2web: you could play around with http://fpcomplete.com
02:54:53 <absence> fly2web: there's a plugin for eclipse, and http://leksah.org/ is another
02:54:56 <fly2web> i find more information with google, then i will return again
02:54:58 <absence> probably there are others
02:54:59 <johnw> that may be the easiest way to just play around with Haskell
02:55:25 <fly2web> thanks
02:56:20 <fredyr> if you've tried the ipython notebooks there's ihaskell
02:56:37 * hackagebot creatur 5.2.0 - Framework for artificial life experiments.  http://hackage.haskell.org/package/creatur-5.2.0 (AmyDeBuitleir)
02:56:42 <fredyr> might be an easy way to start playing around in an interactive environment
02:57:23 <absence> that fpcomplete font does not play well with windows' font engine :s
02:57:33 <johnw> oh, that is a good thing to know
02:57:43 <johnw> would you mind reporting that as a bug along with a screenshot?
02:58:06 <absence> if it doesn't involve creating an account
02:58:11 <ion> Oh, there’s a free version of the FP Complete thing? Cool, i’ll have to try that.
02:58:12 <johnw> you shouldn't need to
02:58:22 <johnw> if it does, e-mail me the bug report and screenshot: johnw@fpcomplete.com
02:58:34 <johnw> ion: yes!
02:58:37 <absence> johnw: great, where is the bug tracker?
02:58:42 <johnw> it's private
02:58:55 <johnw> we use a GitHub private repo
02:59:07 <absence> johnw: i mean, how do i report a bug :)
02:59:16 <johnw> there should be a feedback button on the website
03:00:50 <mgsloan> absence: Either via https://fpcomplete.desk.com/customer/widget/emails/new or https://fpcomplete.desk.com/
03:01:15 <mgsloan> (that prior link is usually in an iframe when you click "Feedback" on the site or in the IDE)
03:01:21 <absence> found it :) thanks
03:01:37 <johnw> mgsloan is an fpcompleter also, so bug him if you have UI questions :)
03:03:59 <mgsloan> absence: The bug is probably related to this: https://productforums.google.com/forum/#!topic/chrome/oXILHkVG75M
03:04:03 <macron> say I have a type T a b that I want to make a functor in its first argument, not the second. What's the best way to do that?
03:04:17 <johnw> you'll need to use a newtype warpper
03:04:36 <macron> Intuitively I would introduce a newtype Swap f a b = Swap (f b a), but is there is already such a newtype defined somewhere?
03:04:36 <johnw> there is no type-level "flip"
03:04:55 <johnw> none that I'm aware of, but there could be...
03:04:55 <macron> I see.
03:05:13 <macron> been hunting around some of the usual suspects on hackage but no luck so far...
03:07:49 <absence> mgsloan: i don't use chrome
03:12:56 <mgsloan> absence: IE or firefox, then?  Hopefully there's a way to resolve it in a way that's not too invasive
03:13:25 <mgsloan> One possibility might be to use a user-styles thing to override the font
03:13:32 <absence> johnw: thanks, report sent now. i'm not a user, but i've noticed the font issue when reading articles linked from reddit etc
03:13:42 <johnw> thank you!
03:13:48 <mgsloan> Ohh, the actual article fonts? yikes!
03:14:18 <mgsloan> Anywho, yeah, report appreciated!
03:15:22 <absence> mgsloan: i use firefox. it's not the article font, thankfully :)
03:16:06 <absence> mgsloan: it's the font used here: https://www.fpcomplete.com/user/edwardk
03:16:39 * hackagebot hblock 0.1.0.1 - A mutable vector that provides indexation on the datatype fields it stores  http://hackage.haskell.org/package/hblock-0.1.0.1 (HugoGomes)
03:17:25 <mgsloan> Well, that is indeed a google web font
03:17:39 <mgsloan> I imagine that the bug that affects chrome also affects firefox
03:17:56 <mgsloan> (since they probably uses windows' truetype font rendering)
03:18:34 <mgsloan> *use
03:18:34 <absence> that could indicate the bug is in the font :) i've seen similar results when using windows system fonts in linux
03:18:53 <mgsloan> Hmm, could be!
03:18:56 <absence> there's all this drama about freetype and hinting
03:20:07 <absence> so linux distros often doesn't rely on hinting, and mac os ignores it iirc
03:20:38 <mgsloan> Surprising considering apple's early emphasis on beautiful fonts
03:20:59 <mgsloan> (well, doing computerized typography proplery)
03:21:49 <tdammers> well, os x still renders way better than windows
03:22:01 <tdammers> freetype has the advantage of being utterly configurable
03:22:33 <johnw> codygman: ping
03:22:34 <tdammers> for example, you can remap Comic Sans to Bitstream Vera Sans
03:23:00 <absence> tdammers: that's a matter of opinion :) small text on os x is more blurry, but the characters also look more similar to how they look at bigger sizes
03:23:38 <tdammers> absence: I'm not really talking of the matter-of-taste choices
03:23:53 <johnw> @tell codygman the simplest I could make it: https://gist.github.com/9387598
03:23:53 <lambdabot> Consider it noted.
03:24:31 <absence> tdammers: we'll just have to agree to disagree then :) i prefer the way windows renders fonts
03:24:47 <absence> mgsloan: it looks the same in internet explorer FYI
03:25:24 <mgsloan> I imagine it's easily reproducible then, thanks for mentioning!
03:26:57 <absence> mgsloan: i didn't mention that you have to scale the text up a bit. it looks fine at the default size. i forgot it was scaled in my firefox until i opened the page in IE
03:27:28 <mgsloan> Ahh, interesting!
03:27:30 <absence> well, almost fine
03:27:54 <absence> the headings have a larger font size and still look weird
03:28:44 <mgsloan> fwiw, I didn't pick em :)
03:29:15 <absence> no worries :)
03:31:38 <Fuuzetsu> Does someone know who a person going by ‘ksf’ is? Their e-mail or something is good. They have last been in this ~5 months it seems. I'm looking for libs working with EBML and Matroska and his name seems to come up in IRC logs but nothing on Hackage. Wondering if he ever wrote anything of use.
03:32:58 <fly2web> http://www.learnyouahaskell.com <----- buy it vs read it online, they are different?
03:33:11 <absence> fly2web: content is the same
03:33:16 <fly2web> oh
03:33:17 <fly2web> good
03:33:28 <fly2web> then i don't need buy it.
03:33:29 <absence> if you buy it you get paper :)
03:33:29 <merijn> I think the web has maybe had 1 or 2 errata's, but mostly identical, yeah
03:33:46 <fly2web> oh paper. i don't need paper. i have i pad
03:33:49 <haasn> well the book version is more portable and easier to learn from
03:34:01 <Fuuzetsu> Paper is more useful than “i pad”.
03:34:08 <Fuuzetsu> at least it doesn't force inane licensing on you
03:34:27 <fly2web> thanks
03:34:27 <haasn> we are not as good as learning from text displayed on a screen
03:34:30 <haasn> at*
03:34:33 <bahamas> haasn: arguable.
03:34:48 <haasn> bahamas: empirically
03:34:57 <bahamas> haasn: that's how I learned programming.
03:35:04 <bahamas> do you have sources?
03:35:14 <haasn> I do but I don't know how to link to them since I have them in paper form and not digital
03:35:18 <Fuuzetsu> bahamas: who's not to say you could have learned a bit easier if you had a paper copy?
03:35:23 <bahamas> I never used a physical book to learn programming or many other things
03:35:28 <mgsloan> haasn: Among individuals who are used to learning from paper?
03:35:31 <Fuuzetsu> he's not saying it's impossible
03:35:33 <mgsloan> :)
03:35:35 <haasn> there are a few articles about it in sciam, citing a handful of studies on the human brain and text processing
03:35:56 <haasn> one of them less than a year ago iirc, you could try searching for it
03:36:07 <bahamas> fair enough
03:36:20 <fly2web> i just have a question one more. why i study functional language like haskell? what  is good for python?
03:36:51 <haasn> “what is good for python?” lens support, clearly
03:37:08 <Fuuzetsu> fly2web: Shouldn't you be the one answering that? You're the one that wants to learn it, there must be a reason.
03:37:24 <randomclown> costate, comonad, coalgebra = java's member state update technology
03:37:25 <fly2web> what is better for python.
03:37:25 <Fuuzetsu> haasn: a nail in the coffin is pretty good too
03:37:55 <haasn> randomclown: lens has come a long way since then
03:38:05 <Fuuzetsu> randomclown: keep joking and people might believe you
03:38:28 <fly2web> i just heard that haskell is good for hacking. so i want study haskell? that is right?
03:38:40 <randomclown> No haskell is not for hacking
03:38:58 <bahamas> depends on what he means by hacking
03:38:58 <haasn> you can hack in every language, but haskell makes it fun ;)
03:39:16 <haasn> (or a nightmare, depending on what you're hacking on)
03:39:20 <fly2web> i want hack websites content.
03:39:30 <bahamas> fly2web: what does "hack" mean for you?
03:39:58 <fly2web> i want download data of website database.
03:40:23 <Fuuzetsu> @faq Can Haskell enlighten this skid?
03:40:23 <lambdabot> The answer is: Yes! Haskell can do that.
03:40:33 <bahamas> ah, scraping
03:40:51 <Fuuzetsu> bahamas: I believe he means malicious data theft.
03:41:00 <bahamas> if you already know python, it's easy enough to do it that way
03:41:03 <haasn> no, you need python to hack into and download account data
03:41:11 <haasn> python has libraries for this, probably
03:41:16 <Fuuzetsu> import credit_card_numbers
03:42:04 <bahamas> fly2web: are you asking about breaking into websites?
03:42:11 <fly2web> yes
03:42:13 <fly2web> bahamas:
03:42:56 <Fuuzetsu> fly2web: http://freenode.net/policy.shtml#unlawful
03:43:28 <fly2web> it is not unlawful behavior.
03:43:32 <fly2web> dont worry.
03:43:46 <fly2web> i just upgrade my skill.
03:44:22 <bahamas> fly2web: python has plenty of security-related libraries. I don't know about haskell
03:44:49 <fly2web> ok i see.
03:44:52 <bahamas> I have no idea if you'll get a huge advantage for that from learning haskell
03:45:08 <fly2web> ok i see.
03:46:12 <fly2web> i know c, c++, java, php, python, perl, query, ajax jsp, android, iOS. so i have fear study new language.
03:47:00 <fly2web> so i have prudence.
03:47:07 <absence> fly2web: haskell is different from all those. it will be like learning programming all over again. which is good, makes you a better programmer :)
03:47:30 <bahamas> if you know that many, you shouldn't be afraid of learning a new one
03:47:52 <fly2web> ok i see.
03:48:14 <bahamas> almost. there are some things that are easier if you already know programming
03:48:20 <fly2web> then i will start haskell. someone tell me study only one language.
03:48:28 <bahamas> but I know what you mean
03:49:15 <fly2web> ok i see.
03:49:16 <fly2web> thanks
03:50:16 <haasn> “monads are like hacking into websites...”
03:50:57 <ski> fly2web : the languages you mentioned are all imperative ones (some with support for object-orientation)
03:51:14 <no-n> monads are like a box of chocolates
03:51:14 <fly2web> thanks ski
03:51:43 <ski> fly2web : learning a new programming paradigm, learning new ways to approach problems, will improve your understanding of computing
03:52:09 <narendraj9_> I tried learning monads for a while. Then I gave up. I will start again. What make monads tick for you anyway?
03:52:11 <fly2web> ok thanks ski then i will start study 'haskell'
03:52:18 <bahamas> a lot of concepts in haskell seem to be "more abstract", if I can say that, than in other programming languages
03:52:38 <ski> fly2web : so i suggest learning about functional programming. learning about logic programming and constraint programming is also useful
03:52:44 <narendraj9_> *made
03:52:44 <fly2web> haasn: what is monads?
03:53:07 <fly2web> oh i see.
03:53:09 <bahamas> fly2web: you will understand when the time is right
03:53:11 <ski> fly2web : monads are a way to avoid some kinds of boilerplate code
03:54:01 <haasn> narendraj9_: nothing in particular. just understanding how Haskell works
03:54:04 <haasn> narendraj9_: monads aren't special
03:54:38 <ski> narendraj9_ : learn some common examples of monads, like `Maybe',`Either',`[]',`Writer',`Reader',`State', and what they're good for. then you're better equipped to understand what monads are
03:55:29 <haasn> ski: do you think logic and constraint programming will help him hack into website databases?
03:55:37 <narendraj9_> I went through some chapters of Learn you A Haskell. It talked about Maybe but didn't tell it was a Monad.
03:55:41 <merijn> narendraj9_: What made them tick is when I tried to stop figure out "what" monads are
03:55:45 <ski> narendraj9_ : "What the hell are Monads?" by Noel Winstanley in 1999 at <http://web.cecs.pdx.edu/~antoy/Courses/TPFLP/lectures/MONADS/Noel/research/monads.html> might be of some use, to start with
03:56:12 <fly2web> there is no channel of monade?
03:56:16 <merijn> narendraj9_: I recommend reading the "Monads for Functional Programming" paper by Wadler and sigfpe's "You Could Have Invented Monads"
03:56:25 <merijn> @google you could have invented monads
03:56:26 <ski> haasn : it will probably help with hacking on database schemata, views and indexing in SQL
03:56:26 <lambdabot> http://blog.sigfpe.com/2006/08/you-could-have-invented-monads-and.html
03:56:27 <lambdabot> Title: A Neighborhood of Infinity: You Could Have Invented Monads! (And Maybe You Al...
03:56:35 <quchen> Let the Monad tutorials rain!
03:56:52 <quchen> I recommend this one. http://www.chrisstucchio.com/blog/2013/write_some_fucking_code.html
03:56:56 <no7hing> total haskell newbie here. any way the record updating can be improved? http://lpaste.net/100777
03:57:00 * haasn prefers the slightly more pessimistic, “You Couldn't Have Invented Monads”
03:57:24 <merijn> no7hing: One of the 15 million lens libraries :)
03:57:43 <narendraj9_> And I have one more question. After I learn Haskell, I want to keep building stuff. What do you guys do with Haskell, like contributing to a project which is open source or anything that you built with Haskell.
03:57:46 <ski> narendraj9_ : knowing that something is a monad doesn't tell you that much. in practice you have to know more about the particular monad in question to have any use of it. the fact that it's a monad is just one part of its functionality
03:57:56 <merijn> no7hing: lens is the most popular one, but it can be...rather intimidating to newbies, you may want to use another for a bit to understand the basic ideas
03:58:00 <no7hing> is there a flavour of the year?
03:58:16 <merijn> fclabels was decently newbie friendly I heard
03:58:20 <haasn> lens is my flavour of the decade
03:58:21 <no7hing> i already stumbled upon a few on SO
03:58:39 <merijn> lens has lots of examples and code, but it's types are...intimidating to say the least, even for intermediate haskellers :)
03:58:44 <no7hing> i might give it a try then :)
03:58:58 <no7hing> everything is quite intimidating right now
03:59:06 <haasn> but lens also isn't what it used to be. The type signatures and errors get more and more confusing if you don't really understand how they work internally
03:59:19 <ski> no7hing : write explicit update functions like `modifycomponents :: (Map.Map String Component -> Map.Map String Component) -> (Entity -> Entity)' -- or use lenses
03:59:40 <narendraj9_> Seems like my question is getting lost in this ocean..
03:59:55 <no7hing> ski: those would be nicely composable at least
03:59:56 <haasn> narendraj9_: I use Haskell for personal projects, everyday computation and I contribute to open source Haskell software
04:00:19 <narendraj9_> haasn, what projects do you contribute to?
04:01:28 <no7hing> i've seen this import suggestion in the set doc: http://lpaste.net/100778 ... what's the reason for the first line?
04:01:29 <haasn> narendraj9_: hard to pin down. Many tiny changes here and there. I think I've contributed the most to ‘lens’ and ‘haddock’
04:01:57 <bahamas> is there a way to get the fixity of an operator in ghci?
04:02:04 <quchen> bahamas: :i
04:02:19 <quchen> No fixity specified = infixl 9
04:02:22 <ski> no7hing : apparently to avoid having to write `Data.Set.Set' in types
04:02:30 <haasn> no7hing: lets you write type signatures as :: Set Int -> Set Int  instead of :: Set.Set Int -> Set.Set Int
04:02:32 <ski> (or `Set.Set')
04:02:47 <no7hing> thanks guys!
04:02:50 <narendraj9_> haasn, haven't heard of them. But I will learn Haskell. I think this channel is the most inspiring place on earth. :-) I mean it.
04:03:39 * narendraj9_ always finds life when he comes here. cheers to you people! 
04:04:11 <jdnavarro> is there some sort of standard practice for brown bag releases in Hackage?
04:04:42 <bahamas> quchen: thanks.
04:06:06 <bahamas> ah, :i also shows what instances a type has. I knew it looked familiar
04:07:16 <ski> it's short for `:info'
04:07:30 <ski> (also there's no `@info' command for lambdabot)
04:07:38 <ski> @info elem
04:07:38 <lambdabot> elem
04:08:01 <quchen> It does something, but it's not :i.
04:08:08 <haasn> jdnavarro: brown bag releases?
04:08:09 <ski> it does nothing, really
04:08:15 <ski> @help info
04:08:15 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
04:08:20 <ski> there is no `info' command
04:08:26 <haasn> @info do { x <- foo; bar }
04:08:26 <lambdabot> foo >>= \ x -> bar
04:08:41 <haasn> @undo do { x <- foo; bar }
04:08:42 <lambdabot> foo >>= \ x -> bar
04:08:50 <bahamas> ski: good to know. thanks
04:08:54 <ski> @help undo
04:08:54 <lambdabot> undo <expr>
04:08:54 <lambdabot> Translate do notation to Monad operators.
04:09:08 <haasn> How many years has it been since lambdabot's creation and we still haven't actually added an @info command that at least says “there is no @info command”?
04:09:23 <ski> @undo [y | x <- foo,bar,y <- baz x]
04:09:23 <lambdabot> concatMap (\ x -> if bar then concatMap (\ y -> [y]) (baz x) else []) foo
04:10:03 <bahamas> :help in ghci would have been great
04:10:22 <bahamas> I mean :help foo
04:12:31 <haasn> @undo [x | x <- foo, then group by x ]
04:12:31 <lambdabot> Plugin `undo' failed with: Undo plugin error: can't undo!
04:13:31 <bahamas> btw, here http://learnyouahaskell.com/making-our-own-types-and-typeclasses in the section about recursive data structure, where infixr 5 :-: is defined, how does haskell know what :-: does? is Cons the only option in the definition of List, so it knows that :-: stands for Cons?
04:14:39 <quchen> :-: is like Cons in the new definition of the list.
04:14:41 <haasn> bahamas: that infixr 5 refers to the List definition immediately below it
04:14:45 <Cale> bahamas: The data declaration defines :-:
04:15:02 <haasn> bahamas: (which is distinct from the List definition given earlier)
04:15:08 <Cale> bahamas: The fixity declaration is allowed to come before, but could just as well be placed after
04:15:27 <Feuerbach> jdnavarro: you can deprecate certain versions of the package
04:16:46 * hackagebot pipes-p2p 0.3 - P2P network nodes with pipes  http://hackage.haskell.org/package/pipes-p2p-0.3 (jdnavarro)
04:16:54 <ski> (actually it declares it .. like introducing new axioms in a theory)
04:18:37 <bahamas> haasn: Cale I don't understand how Haskell assumes that a :-: Empty is equivalent to a : Empty or a `Cons` Empty.
04:18:55 <bahamas> I'm asking, because lower the .++ operator is introduced and its behavior is also defined
04:19:14 <Cale> bahamas: It's not the same thing
04:19:27 <haasn> bahamas: it doesn't. It assumes that a :-: Empty is equivalent to a :-: Empty
04:19:32 <haasn> :-: is not : nor `Cons`
04:19:48 <Fuuzetsu> quchen: that's a good site
04:20:01 <Cale> bahamas: The confusing part about this is that he's considering different ways to define a type called List
04:20:10 <Cale> and those ways define different data constructors
04:20:23 <Cale> (Specifically Cons and :-:)
04:20:48 <Fuuzetsu> quchen: I also blame you for landing me on http://www.amazon.com/Hott-Place-Blow-Billy-Goat/dp/B00CJWV81W/ref=pd_sim_bt_6?ie=UTF8&refRID=0W19CZB867G48A0BG9WB
04:21:34 <jdnavarro> Feuerbach, that will work, thanks
04:21:47 * hackagebot pipes-p2p-examples 0.3 - Examples using pipes-p2p  http://hackage.haskell.org/package/pipes-p2p-examples-0.3 (jdnavarro)
04:21:54 <bahamas> he's defining a type that is supposed to act like the builtin List. therefore, :-: is supposed to act like :
04:22:17 <quchen> Fuuzetsu: I don't see how that relates to the Monad tutorial. (Did you find that because it cotains "hott"?)
04:23:37 <bahamas> oh, I understand now. I forgot that when you define a constructor and then you use it, it also shows up in the values
04:23:45 <fly2web> haskell is preinstalled in mac?
04:24:12 <quchen> No.
04:24:17 <bahamas> like Just 4 for example
04:24:24 <fly2web> thanks
04:24:25 <bahamas> Cale: haasn I get it now. thanks
04:24:53 <fly2web> perl and python is preinstalled in the mac so i think haskell is too.
04:32:08 <Fuuzetsu> quchen: no, the link you posted linked to a blow-up midget which then suggested the goat
04:32:19 <Fuuzetsu> although I guess HoTT works
04:43:13 <tdammers> fly2web: os x does not come with haskell, if that's what you're talking about
04:44:04 <fly2web> tdammers: i m installing now by home-brew.
04:52:14 <fly2web> how can i escape from 'Prelude>'?
04:52:30 <tdammers> you mean, exit ghci?
04:52:31 <tdammers> Ctrl_D
04:52:41 <tdammers> like any good REPL :D
04:53:12 <fly2web> yes exit ghci.
04:53:18 <fly2web> how can i?
04:53:20 <fly2web> do?
04:53:30 <fly2web> quit?
04:53:36 <solarus> ctrl+d as tdammers said
04:53:41 <solarus> also :q works
04:53:45 <fly2web> i use mac.
04:53:53 <fly2web> then ctrl + D?
04:54:27 <Clint> if only there were a way to test it
04:54:36 <Feuerbach> haha
04:56:45 <fly2web> thanks
05:00:35 <zebr> hi all. i'm trying to think of a term in set theory - is it the 'flat set of integers' that comprises all the integers, plus bottom _|_ ?
05:03:26 <quchen> Lifted set of integers?
05:05:20 <mr-> The pointed set?
05:08:31 <carlosgaldino> what's the best way to define a function placeholder?
05:08:55 <carlosgaldino> so the compiler doesn't complain it's not in scope
05:09:08 <zebr> quchen, mr-: i've found it; it is 'flat set', though that term only seems to be used in term rewriting.
05:09:30 <quchen> undefined, carlosgaldino
05:09:41 <quchen> :t foldr undefined 0 [1..10]
05:09:42 <lambdabot> Num b => b
05:09:58 <zebr> mr-: it differs from a pointed set because the flat set of X includes an extra element outside X, bottom. so the flat set of X is a pointed set X `union` {_|_}
05:10:07 <zebr> quchen, mr-: thanks, though :)
05:11:52 * hackagebot BlastHTTP 1.0.0 - Libary to interface with the NCBI blast REST interface  http://hackage.haskell.org/package/BlastHTTP-1.0.0 (FlorianEggenhofer)
05:24:19 <Lethalman> can fingertrees be used as infinite sequence?
05:25:18 <merijn> carlosgaldino: In the sense of you want it to typecheck?
05:25:48 <Lethalman> like with lists it's possible to x:(func y) to generate something like a stream
05:26:20 <Lethalman> at a first glance it's not possible with fingertrees because it needs a finger on the end of the sequence
05:27:39 <Lethalman> however it could be possible, for example, to return a fingertree like push (single x) (func y)
05:27:52 <Lethalman> mh... no :(
05:36:57 * hackagebot BlastHTTP 1.0.1 - Libary to interface with the NCBI blast REST interface  http://hackage.haskell.org/package/BlastHTTP-1.0.1 (FlorianEggenhofer)
05:36:59 * hackagebot HMap 1.0.5 - Fast heterogeneous maps.  http://hackage.haskell.org/package/HMap-1.0.5 (AtzeVanDerPloeg)
05:38:56 <carlosgaldino> merijn: what do you mean? the case is this: I have a set of test cases and I need to write the code to make them pass, but I wanted to define an `nop` function just to get rid of the `function x is not in scope` since I didn't define it
05:39:32 <carlosgaldino> that way, I can run the tests cases that are testing only one function and not the entire suite
06:10:06 <vozz> When should I use the state monad, and when should I use MVars?
06:10:25 <klrr_> vozz: when dealing with cuncurrency i think
06:10:40 <klrr_> also, IORefs and company are better performing
06:10:48 <klrr_> (AFAIK
06:10:49 <klrr_> )
06:11:13 <vozz> Oh god I'm so confused
06:11:30 <vozz> State monad, STRefs, IORefs, MVars, TVars
06:11:43 <vozz> loads of ways of doing nearly the same thing
06:11:53 <klrr_> that's common in haskell :P
06:12:08 <vozz> which are the most commonly used when you just need some basic state?
06:12:11 <klrr_> io-stream/pipes/conduit are another example, and reactive-banana/elerea/sodium/netwire
06:12:18 <klrr_> State
06:12:19 <klrr_> monad
06:13:12 <vozz> I'm not sure even how to fit that into the code I'm writing though, that's the problem
06:13:29 <klrr_> could you allabroate
06:13:32 <vozz> I'm using scotty, the webframework thing
06:13:37 <klrr_> okey
06:13:45 <vozz> If I wanted to have visiting a page increment a counter or something
06:13:49 <klrr_> do you know about monad transofmers?
06:13:50 <quicksilver> if you're using a framework you need to follow the conventions of the framework
06:14:03 <quicksilver> because inversion of control means you don't have all choices available to you
06:14:14 <quicksilver> in a web framework in particular you need persistent state
06:14:16 <vozz> I don't know about monad transformers
06:14:31 <vozz> well scotty seems basically the most minimal of the frameworks
06:14:42 <klrr_> well you can lift IO actions in the scotty monad and you can incoperate the State monad
06:14:43 <vozz> It's basically just a server and routine
06:14:46 <vozz> routing*
06:15:04 <quicksilver> klrr_: are you sure?
06:15:10 <klrr_> quicksilver: yes
06:15:13 <quicksilver> klrr_: how would that state get serialised between requests?
06:15:27 <klrr_> type ScottyM = ScottyT Text IO
06:15:43 <klrr_> hmm
06:16:31 <quicksilver> scotty doesn't appear to have documentation
06:16:36 <klrr_> http://hackage.haskell.org/package/scotty
06:16:41 <quicksilver> yes
06:16:42 <klrr_> and https://github.com/scotty-web/scotty/tree/master/examples
06:16:50 <quicksilver> ah that sounds more promising
06:16:59 <klrr_> this example uses tvars for example https://github.com/scotty-web/scotty/blob/master/examples/globalstate.hs
06:17:04 <quicksilver> https://github.com/scotty-web/scotty/blob/master/examples/globalstate.hs
06:17:07 <quicksilver> right :)
06:17:27 <quicksilver> vozz: because scotty is already layered over IO and makes that avalaible to you, you should use IO-based primitives
06:17:35 <quicksilver> so IORef, MVar and TVar are possible
06:17:44 <klrr_> i dont see why state wouldnt work though
06:17:48 <klrr_> State monad
06:17:54 <quicksilver> but you need to handle your own serialisation if you want the app to persist through restart
06:18:28 <vozz> I don't want it to persist through restart
06:18:37 <quicksilver> then you don't nee to worry about that :)
06:18:41 <vozz> I've done stuff using persist before, and I understand that
06:19:01 <vozz> Which out of the three you mentioned would you recommend?
06:19:17 <vozz> TVar is transactional isn't it? I don't need that
06:19:31 <Eduard_Munteanu> I'm getting some entities as JSON data and parsing it with aeson. I want to save it to a file and later check membership and append to it, like some sort of set. Any recommendations?
06:19:44 <klrr_> vozz: i think State would be most idomatic for just having some simple mutable state, i just try to figure out how to make it work :P
06:19:51 <quicksilver> klrr_: right. scotty is specificalyl designed to work with a customer transformer, I see that now.
06:19:54 <quicksilver> klrr_:  ( http://hackage.haskell.org/package/scotty-0.6.2/docs/Web-Scotty-Trans.html )
06:19:58 <klrr_> yes
06:20:03 <quicksilver> klrr_: I agree with you, StateT.
06:20:36 <vozz> So how do I use that in scotty? I've used it before by itself
06:21:48 <klrr_> vozz: okey, first read up on monad transformers if you dont know what they are (http://book.realworldhaskell.org/read/monad-transformers.html), then checkout this example https://github.com/scotty-web/scotty/blob/master/examples/globalstate.hs but simply use State instead of Reader (reader is "read-only state", State is mutable)
06:22:25 <vozz> The thing is also, I'm also using websockets, which I believe is some other kind of monad, and I want to access this state variable in there too
06:22:36 <vozz> Code is here https://gist.github.com/ollieh/9d77bf81bcb3f2c49ed9
06:23:26 <quicksilver> klrr_: is scotty single or multithreaded?
06:25:22 <sleepynate> quicksilver: doesn't it sit on top of warp?
06:25:31 <quicksilver> sleepynate: by default, at least, yes
06:26:08 <quicksilver> and warp uses threads as far as I know / can see
06:26:29 <quicksilver> klrr_: ^^ which means that StateT would probably end up with thread-local state, which would generally not be predictable or desirable.
06:26:59 <klrr_> quicksilver: okey
06:27:15 <klrr_> i thought it was single threaded, but in that case i dont know anything
06:27:39 <quicksilver> klrr_: I don't know anything either :(
06:27:48 <sleepynate> a single-threaded web server would not be very handy
06:27:50 <quicksilver> klrr_: except that the documentation is really poor if it doesn't answer these basic questions
06:28:59 <quicksilver> sleepynate: well a "one request at a time" webserver wouldn't be very handy.
06:29:14 <quicksilver> sleepynate: you can be single threaded and do a lot of multiplexed io in a way which works well.
06:29:20 <vozz> sleepynate: tell that to node.js programmers
06:29:28 <sleepynate> http://hiyoooo.com
06:29:31 <quicksilver> sleepynate: but generally not for application servers, which actually "do work"
06:29:43 <sleepynate> i was being less funny than i intended
06:29:49 <quicksilver> (unless the application server is also written to do everything asynchronously)
06:29:50 <sleepynate> i'm off for coffee
06:30:18 <vozz> Do I want an MVar then?
06:30:39 <quicksilver> vozz: yes, that would seem to be simplest
06:30:57 <vozz> Damn haskell is hard :D
06:31:29 <sleepynate> (and an initial look through scotty doesn't show it parallelizing anything itself, just relying on WAI/warp to do that
06:31:31 <fly2web> To get it, run cabal install hoogle in a console. The next time EclipseFP starts, it will detect and configure it for use.
06:31:35 <fly2web> what mean?
06:33:15 <tdammers> fly2web: which part do you not understand?
06:33:34 <quicksilver> vozz: this isn't really an example of haskell being hard, it's an example of a bunch of libraries depending on each other for key operations and that arrangement not being documented.
06:33:52 <quicksilver> vozz: (and insufficiently well informed people in #haskell to clear it up ;)
06:34:03 <fly2web> i install with brew and i plugin with eclipse but audetect is not work.
06:34:38 <fly2web> http://eclipsefp.github.io/install.html
06:34:51 <vozz> quicksilver: you missed a closing parens
06:35:01 <vozz> :D
06:35:54 <quicksilver> vozz: I dunno. I've always felt that the smiley could do double duty in that context.
06:36:00 <sleepynate> quicksilver: amen. i will probably always suck at haskell but we're the best he's got at this hour :D
06:37:34 <fly2web> i don't know about 'HLint' and HTF and Hoogle.
06:42:04 * hackagebot diagrams-builder 0.5.0.2 - hint-based build service for the diagrams graphics EDSL.  http://hackage.haskell.org/package/diagrams-builder-0.5.0.2 (BrentYorgey)
06:44:46 <vozz> Is there a way to install dependencies of a file with cabal, without having to write a .cabal file?
06:45:08 <vozz> Like if I'm just writing a quick script and I just want whatever is imported in that file
06:45:21 <dcoutts> vozz: sure, just cabal install the dependencies
06:47:05 * hackagebot diagrams-haddock 0.2.2.2 - Preprocessor for embedding diagrams in Haddock documentation  http://hackage.haskell.org/package/diagrams-haddock-0.2.2.2 (BrentYorgey)
06:50:20 <fly2web> how can i install cabal in the mac?
06:50:37 <mzero> install Haskell Platform
06:50:57 <mzero> unless you are trying to run on the bleeding edge, don't install GHC directly
06:52:09 <fly2web> i have commands of 'brew install haskell-platform' already.
06:52:21 <fly2web> mzero:
06:53:58 <mzero> then you should have cabal
06:54:12 <mzero> mind you, brew is not the normal way to install haskell-platform
06:54:27 <fly2web> i use mac
06:54:27 <mzero> brew, I believe, puts binaries in some non-standard bin directory
06:54:33 <mzero> you probably need that on your PATH
06:54:44 <mzero> yes, there is a native Mac installer for Haskell Platform
06:54:52 <mzero> I know... I'm the guy who builds it!
06:56:13 <Yaniel> mzero: brew puts its binary dir in your PATH or symlinks them to usual locations
06:56:19 <danilo2> Hello! I would love to deeply understand how monad transfrmers work. I've made a small example here (http://lpaste.net/100780). I want to ask you I'f I'm wrong or not. If we are creating custom monad transformer, we should make instances **for all** known monad type classes to allow people use nice syntax
06:56:54 <danilo2> I mean, If we declare for example MaybeT we should make instances for WriterMonad, StateMonad, ListMonad etc, not to force users to create explicit lifting - am I right?
06:57:31 <ski> well, make instances for all "well-known" such classes -- for which it makes sense to make instances
06:58:11 <ski> perhaps place those instances in a auxilary module (`Blah.Class')
06:59:14 <ski> also, i'd simplify `(Monad m) => ' to `Monad m => ' :)
06:59:36 <ski> (and `(State x) >>= f = ...' to `State x >>= f = ...'
06:59:38 <ski> )
06:59:57 <ion> hlint will probably suggest at least the latter.
07:00:28 <ski> (and also the simplifications HLint suggest)
07:00:51 <ski> ion : strangely it didn't judging from the suggestions at the end of that paste page
07:01:29 <ion> huh
07:02:15 <mzero> fly2web: did you find cabal from your brew install? or alternatively, did you find the Mac installer?
07:02:35 * ski doesn't understand the "Reduce duplication" warning
07:02:39 <fly2web> https://www.youtube.com/watch?v=qvH3-yPCMxc
07:02:43 <fly2web> i watch it.
07:04:22 <danilo2> ski: I'm sorry I get disconnected. Thank you for the suggestions - of course - hlint is great :)
07:05:56 <danilo2> ski: and I understand there is no additional magic out there? I mean - the people making libraries like mtl or transformers just have written such instances manualy? I was searching for instance MonadState (MaybeT ...) but I havent found it anywhere - is there a way in haskell to query ghci or something else to get info where such instance is declared?
07:08:18 <eacameron> what is the best practice regarding "FilePath"? Prelude's type synonym or filepath package...or...?
07:14:42 <vozz> Anyone got any ideas what's going on here? https://gist.github.com/ollieh/b2702978cb1740d965b2
07:16:30 <supki_> vozz: you don't put anything in GET / back in MVar, so it's empty; next GET / blocks
07:16:35 <danilo2> ski: I had some connection errors - did you recived my question? (about the way we can search where particular instances were declared) ? :)
07:16:55 <vozz> oh, I didn't realise I always had to put something in
07:17:01 <henk> Are "smart constructor" commonly used? Do they make sense in this use case: I read lines from files. I have a datatype matching the information contained in these lines: date, time, timezone, some text, i.e.: I need to extract the date, time, and timezone from the line. Is a smart constructor a good way to do that?
07:17:02 <vozz> thanks a lot
07:17:51 <supki_> vozz: well, you don't have to, but then it will be empty
07:18:11 <supki_> vozz: there are helpers like readMVar for common patterns
07:18:17 <vozz> thanks a lot, changed it to a readMVar and its working now :)
07:18:34 <supki_> :)
07:19:04 <ski> danilo2 : no magic
07:19:32 <anatok> Is there a garanty, that `smth' would be computed only once (pure context): go <go-vars> = go ... (smth <free-of-go-vars>) ... And if yes, it's according to standart or ghc?
07:20:07 <ski> @hackage MaybeT
07:20:07 <lambdabot> http://hackage.haskell.org/package/MaybeT
07:20:12 <ski> danilo2 : looked there ^ ?
07:20:36 <dwcook> anatok, there is not.
07:21:23 <ski> anatok : iiuc, auto-lifting out such non-depending expressions could cause space leaks
07:21:36 <merijn> anatok: No, it's not guaranteed
07:21:40 <dwcook> anatok, however, if you bound it using let, the calculation would happen once for that entire let expression
07:21:58 <danilo2> ski: Thank you a lot! :) hmm, I was looking into Control.Monad.Trans.Maybe (from transformers), but I assume we should use Control.Monad.Trans.Maybe instead ...
07:22:00 <dwcook> But if you left it still inside the definition of go, you'd hardly gain anything
07:22:03 <merijn> anatok: oh, wait, does "smth" only appear once in the expression?
07:22:05 <danilo2> ski: thank you once again! :)
07:22:08 * hackagebot HMap 1.1.0 - Fast heterogeneous maps and unconstrained typeable like functionality.  http://hackage.haskell.org/package/HMap-1.1.0 (AtzeVanDerPloeg)
07:22:15 <anatok> merijn: only once
07:22:17 <merijn> anatok: Then yes
07:22:44 <anatok> merijn: there could i find some info about semantics?
07:22:46 <danilo2> Btw - is there any general way to search haskell libraries when searching for partuicular instances of type classes?
07:22:46 <dwcook> merijn, even over multiple applications of go?
07:22:56 <merijn> dwcook: Oh, good question
07:23:08 <dwcook> I think not, and you'd have to take it outside go to get that guarantee
07:23:12 <merijn> dwcook: I would expect so, yes, but I don't dare say
07:23:32 <ski> danilo2 : i suppose you mean `MaybeT-tranformers' ?
07:23:37 <merijn> anatok: Well, Haskell doesn't actually have a defined evaluation strategy
07:23:41 <merijn> anatok: Beyond "non-strict"
07:23:55 <merijn> anatok: So it's implementation dependent, I think
07:24:26 <danilo2> ski: I was talking about this: http://hackage.haskell.org/package/transformers-0.3.0.0/docs/Control-Monad-Trans-Maybe.html
07:27:09 * hackagebot HMap 1.1.1 - Fast heterogeneous maps and unconstrained typeable like functionality.  http://hackage.haskell.org/package/HMap-1.1.1 (AtzeVanDerPloeg)
07:27:49 <anatok> dwcook: thx, so normally it's better to wrap in let.. does same things happens in functions-guard ... | smth <external-stuff> = ...?
07:28:52 <merijn> anatok: Yes, but "where" clauses can scope over multiple guards, so you can use those to make sure some guard function is only evaluated once
07:31:10 <anatok> merijn: e.g. in http://lpaste.net/100781 it's better to lift "map"-s?
07:32:14 <merijn> anatok: Won't matter there, as both maps are different
07:33:24 <dwcook> Am I reading this wrong or does the first case subsume the second?
07:34:19 <merijn> anatok: What I meant was: http://lpaste.net/100781
07:34:42 <merijn> anatok: Suppose I have 'x' in 'xs' and 'x' is an even, non-zero number
07:35:09 <merijn> anatok: In 'foo' it might recompute "x `elem` xs" three times (once for every case), it may be optimised, but it's not guaranteed
07:35:29 <merijn> anatok: In 'bar' "x `elem` xs" is only computed once for the first guard and then the result is reused
07:35:37 <merijn> anatok: This is guaranteed in ghc
07:35:50 <anatok> dwcook:  hm.. ideone said that it works
07:36:06 <dwcook> It works, but is the second case even reachable?
07:36:18 <dwcook> It doesn't look like it to me, and lpaste doesn't warn about that
07:36:54 <merijn> dwcook: Why wouldn't the second case be reachable?
07:37:10 * hackagebot HMap 1.1.2 - Fast heterogeneous maps and unconstrained typeable like functionality.  http://hackage.haskell.org/package/HMap-1.1.2 (AtzeVanDerPloeg)
07:37:11 <dwcook> Oh woops
07:37:15 <anatok> merijn: ok, thx
07:37:18 <merijn> dwcook: Missed the guard? :p
07:37:21 <dwcook> Yes I did
07:38:13 <dwcook> More accurately I stopped reading once I got to the end of the parameter list since I almost never use guards and forgot they mattered there
07:46:14 <robstewartuk> How do I list the unused rules and unused terminals that happy identifies in my grammar .y file?
07:46:28 <robstewartuk> "unused rules: 44". Great! Which ones?
07:49:15 <Peaker> code-generating parser-generators : parser combinators    <=>     macros : functions
07:58:15 <Hermit> by the way... what happened to hpaste? what's with it being a frontend to lpaste?
07:59:50 <anatok> merijn: there are recipes how to get intuition about boundary: to store enough context to be efficient, but not too much to blow heap?
08:01:35 <Peaker> we all know to avoid macros when we can use functions, but for some reason we use parser-code-generators rather than parser combinators, sometimes
08:03:02 <quicksilver> Peaker: I wonder about that.
08:03:13 <quicksilver> Peaker: presumably they are faster or at least popular wisdom was that they be.
08:03:43 <quicksilver> Peaker: they do better at separating static precomputation to the compile time phase. *in principle* combinators can do that, but it's harder to write them so they do. See S-D.
08:04:42 <Peaker> quicksilver: they can have concrete code go through the compiler's optimizer in addition to the parsing optimizer, which parser combinators can only have general code go through the optimizer -- but with a perfect compiler, the latter ought to be good enough? :)
08:05:28 <Peaker> doing the static analysis on the grammar is important, and I don't understand why there are no Applicative parsers with explicit fix-points to express Context-free grammars
08:06:07 <Peaker> (all the parser combinators seem to be monadic)
08:07:17 <vozz> How can I access an MVar from main from my websockets monad? https://gist.github.com/ollieh/5a38f4f3a97d0f47ae68
08:07:27 <fly2web> if i only 'brew install haskell-paltform' then all program with haskell is installed like cabal?
08:10:34 <klrr_> vozz: maybe incorperate a Reader monad and have the mvar inside it like in this example: https://github.com/xich/scotty/blob/master/examples/globalstate.hs
08:10:45 <klrr_> Reader monad is a read-only state monad
08:11:01 <vozz> I want to be able to change it from the websockets also
08:11:10 <klrr_> hmm
08:11:14 <klrr_> gotta check websockets docs
08:11:34 <vozz> Yeah I figure I need to pass it as an argument to ws or something
08:12:14 * hackagebot dirfiles 0.1.0.3 -   http://hackage.haskell.org/package/dirfiles-0.1.0.3 (HugoGomes)
08:12:36 <fly2web> mzero: hi
08:12:42 <fly2web> what are you doing?
08:12:51 <klrr_> hmm, i dont think i can help you i dont kow websockets
08:18:13 <Peaker> vozz: Reader monad is like passing an argument, with less syntactic overhead (or in some cases, more)
08:18:40 <Peaker> vozz: the argument may be a mutable cell, like an MVar.. whenever you have access to an MVar, you can change it, whether you got it with an explicit argument or via Reader
08:18:43 <untrothy> I'm trying to use union from Data.Map on 1 map I get as the snd from deleteFindMin and another map of the same type i create with fromList, but I get this error: Couldn't match type `M.Map x y with [a0]  Expected type: [a0]. Can't figure out why. Any ideas?
08:18:52 <Peaker> vozz: (change it in IO, of course)
08:19:02 <vozz> klrr_: figured it out! https://gist.github.com/ollieh/89a6c912cc9b096504bb
08:19:15 <Peaker> untrothy: paste some code?
08:19:42 <vozz> Peaker: I'll have to have a look at that then, it might be overkill / overly confusing for me though
08:19:47 <untrothy> sure, it one of my first trys at haskell, so you're eyes will bleed, be ready
08:20:05 <untrothy> Peaker, http://bpaste.net/show/185766/
08:20:17 <untrothy> Peaker, line 137
08:20:34 <Peaker> vozz: Reader on its own rarely saves much. But if you combine ReaderT with other transformers, it can save a lot
08:21:11 <vozz> I guess I need to learn about transformers too then :)
08:21:39 <Peaker> untrothy: "union" in line 137 is from Data.List
08:21:45 <untrothy> Peaker,
08:21:51 <untrothy> I'm an idiot
08:21:54 <Peaker> untrothy: I recommend avoiding using unqualified open imports
08:22:33 <untrothy> Peaker, Yeah I can see why that's a bad idea
08:23:11 <Peaker> untrothy: makes it very unclear what names means and where they come from.. harder to read code and also makes code bitrot faster (it can easily break by new names added to the imported libraries)
08:24:10 <untrothy> Peaker, Thank you, I'll start using qualified imports from now on.
08:24:46 <Peaker> untrothy: you can also do unqualified imports with explicit names like:  import Data.Map (Map)
08:25:21 <Peaker> untrothy: I personally use open unqualified imports only for (Badly designed) modules that qualify every name inside the names themselves.. e.g:  Data.IORef has "IORef" inside all the names, and IORef.newIORef is redundant
08:25:41 <Peaker> so I do have: import Data.IORef ; import Control.Concurrent.MVar
08:28:14 <untrothy> Peaker, Since you seem really helpfull I ask something else: I need to order the map and I added it to the Ord instance, since I need to compare elements of my keys is there a better way to extract the keys other then `head $ Map.Keys` ?
08:28:38 <untrothy> Peaker, Line 25-29
08:29:53 <fly2web> http://leksah.org/ vs http://fpcomplete.com vs plugin for eclipse, what is best for using?
08:31:09 <bxc_> i wrote some cod efor formatting nagios plugin output, for some nagios programs I wrote in haskell. is that the sort of thing i should stick on hackage?
08:32:16 * hackagebot type-eq 0.4.2 - Type equality evidence you can carry around  http://hackage.haskell.org/package/type-eq-0.4.2 (GaborLehel)
08:37:28 <Wizord> hello. I'm trying to implement quicksort in pure functional arrays. no, [<=pivot] ++ [pivot] ++ [>pivot] is not exactly quicksort because it requires ~(n^2) operations
08:37:57 <Wizord> but I'm really stuck at the moment and my head hurts aftert trying to wrap it around this problem
08:38:11 <c_wraith> Wizord: No, it uses O(n log n) operations.  But you're right that it's not really quicksort.
08:38:14 <hiptobecubic> Wizord, it's not On²
08:38:22 <c_wraith> Wizord: it would be more accurate to call it treesort
08:39:13 <jesyspa> Wizord: Quicksort is O(n^2) worst case, if you don't choose the pivot in some smart way, so what's the problem?
08:39:33 <jesyspa> (Though I'm not sure of the ++ costs...)
08:39:37 <c_wraith> Wizord: anyway, pure functional arrays do not play nicely with quicksort definitions that are in terms of mutation of an array.
08:39:43 <cdk> is there a more efficient way to update a delayed Repa array besides: update :: Array D sh e -> sh -> e -> Array d sh e; update arr ix e = let (sh, f) = toFunction arr in fromFunction sh $ \i -> if i == ix then e else f i ? I'm using this in a program and it's showing 85% of memory usage coming from this function.
08:39:58 <Wizord> c_wraith: it requires n^2 because ++ is linear
08:40:06 <c_wraith> jesyspa: the ++ costs are just another O(n) factor in an O(n) step.  It increases the constant factor, but it doesn't change the asymptotic costs
08:40:12 <c_wraith> Wizord: false. see above.
08:40:16 <Wizord> hm
08:41:03 <c_wraith> Wizord: in any case, there's a reason why Data.List's sort is a mergesort.
08:41:19 <c_wraith> Wizord: mergesort plays *much* more nicely with the data structures available.
08:42:06 <Hodapp> what is the one theorem about the maximum time required to turn a mutable-data algorithm in O(f(n)) time into an immutable-data one?
08:42:08 <Peaker> untrothy: not sure, I'd need to dive in to the meaning of these functions
08:42:11 <Wizord> c_wraith: got it. but what I'm trying to do is to build a list of 'swaps' and apply them simultaniously
08:42:32 <Wizord> and perform it on immutable array
08:42:45 <Wizord> the current state of code is here: https://gist.github.com/m1el/9393243
08:42:49 <c_wraith> Oh.  That's possible.
08:43:19 <c_wraith> For research purposes, you're building a permutation out of the list of swaps.  (group theory tells us these are equivalent)
08:43:44 <c_wraith> And you'd like to apply the permutation as a single operation when creating an array for the next recursive step.
08:43:51 <Wizord> I do
08:44:01 <Wizord> well. at least I think I do
08:44:40 <c_wraith> repa has stuff to permute its arrays efficiently.  I wonder if Vector does, too
08:45:16 <untrothy> Peaker, don't worry. I just realized I'm using maps all wrong and have to change a lot of things. Thank you for your help.
08:45:38 <c_wraith> ah, yes.  Vector's generate function can be used to apply a permutation in a single pass.
08:46:14 <c_wraith> oh, it also has backpermute.
08:46:15 <c_wraith> heh
08:48:37 <c_wraith> Wizord: Could you put type signatures on the top-level bindings?  It really helps when reading the code.
08:50:49 <kuribas> Does anyone know how to apply style to a window in wxhaskell?
08:51:05 <kuribas> Especially adding two scrollbars to a window.
08:51:35 <kuribas> the C++ doc says you have to use the style wxVSCROLL, but how to do that in wxhaskell?
08:57:01 <Wizord> c_wraith: I'm trying. but I think I'll go to sleep soon
08:57:47 <c_wraith> Wizord: ok, well.  I think your approach can work, though I'm not sure it'll be any faster.  But if you're interested in it, keep working on it.
09:02:19 * hackagebot git-annex 5.20140306 - manage files with git, without checking their contents into git  http://hackage.haskell.org/package/git-annex-5.20140306 (JoeyHess)
09:08:02 <xintron> I'm playing around with the dbus library. When using `listen` it runs the callback in it's own thread, how can I just "block" the main thread so that it doesn't exit but keeps running forever? I've done something like `forever getLine` but that doesn't seem nice
09:15:23 <simukis_> xintron: threadDelay instead of getLine.
09:16:12 <xintron> simukis_, So just threadDelay <24h or so> forever?
09:16:28 <xintron> (I'm wrapping the forever in catch to listen for UserInterrupt)
09:17:41 <simukis_> let loop = threadDelay maxBound >> loop in loop
09:18:15 <simukis_> if you have no function to keep your main thread alive, that’s your best bet.
09:35:46 <gridaphobe> can i specify which version of ghc to use with cabal-sandbox, or does that still require hsenv?
09:45:41 <nh2> when I use cabal, why would it prefer using yaml 0.8.7 when 0.8.7.2 is available? it works when running cabal with --constraint=yaml==0.8.7.2
09:46:05 <dcoutts> nh2: did you already have 0.8.7 installed?
09:46:40 <nh2> dcoutts: yes, and and 0.8.7 was not installed
09:46:57 <nh2> sorry I mean
09:47:13 <nh2> dcoutts: I already had 0.8.7.2 installed and and 0.8.7 was not installed
09:48:03 <dcoutts> nh2: then we'd have to look at the difference in the plans when you use the constraint vs not
09:48:32 <nh2> dcoutts: how do I print the plan?
09:48:37 <dcoutts> nh2: -v3
09:49:17 <dcoutts> nh2: but in general, it's just a preference to re-use installed versions and the order of preferences is not specified
09:49:20 <carlosgaldino> where can I see the implementation of Functor (,)?
09:49:38 <carlosgaldino> I want to know why fmap f (a, b) gets only applied to `b`
09:50:38 <S11001001> carlosgaldino: that is the only possible implementation
09:50:52 <S11001001> @kind Functor
09:50:53 <lambdabot> (* -> *) -> Constraint
09:50:55 <dcoutts> carlosgaldino: you can see that just from the type
09:50:59 <S11001001> @kind (,)
09:51:00 <lambdabot> * -> * -> *
09:51:02 <S11001001> @kind (,) Int
09:51:03 <lambdabot> * -> *
09:51:15 <nh2> dcoutts: is that "trying to use installed packages" transitive? Given that I didn't even have 0.8.7 installed but 0.8.7.2 was there, maybe something else was "preferred" to have its old version kept?
09:51:30 <nicoo> @kind Constraint
09:51:31 <lambdabot>     Not in scope: type constructor or class `Constraint'
09:51:31 <lambdabot>     Perhaps you meant `Contains' (imported from Control.Lens)
09:51:36 <dcoutts> nh2: right exactly
09:52:09 <dcoutts> nh2: so you forcing to re-use the installed instance will probably have caused a change elsewhere in the plan
09:53:29 <carlosgaldino> S11001001: I don't get it :(
09:53:29 <carlosgaldino> is there a way to see the implementation code? how can I find that?
09:53:58 <nh2> dcoutts: that behaviour might be against our interest: yaml 0.8.7 forgot to specify a correct lower bound on conduit, using a recently added function. The author fixed that quickly with 0.8.7.2, but that fix is ignored because 0.8.7 is preferred in any case
09:54:09 <kuribas> Can I import a module a second time, qualified?
09:54:37 <nh2> dcoutts: thus Snoyman fixing his version constraints doesn't really fix anything for end users, because cabal's preference ignores the fix
09:55:09 <dcoutts> nh2: mm, that's an interesting observation
09:55:21 <nh2> dcoutts: is there anything that speaks against using the most recent version when possible, apart from maybe download+compilation time?
09:55:44 <dcoutts> nh2: what happens if you add --preference="yaml > 0.8.7"
09:56:11 <dcoutts> nh2: this is an issue of priority of preferences really
09:57:09 <nh2> dcoutts: unfortunately I cannot reproduce - having it installed correctly will now always result in it picking the newer yaml
09:57:12 <dcoutts> nh2: if that changes the solution picked then deprecating 0.8.7 on hackage would help I think
09:57:26 * hackagebot text 1.1.0.1 - An efficient packed Unicode text type.  http://hackage.haskell.org/package/text-1.1.0.1 (BryanOSullivan)
09:58:08 <nh2> dcoutts: in general I can't think of a situation where you would prefer version A.B.C when A.B.C.fix is available - that version could bring a critical bug/security fix
09:58:09 <S11001001> carlosgaldino: How many type parameters does fmap, considered in the abstract, change from the 2nd to 3rd argument?  How many type parameters of (,) do you expect to change?  <-- These must be the same.  Put another way, how would your proposed functor work on (String, Int)?
09:58:41 <dcoutts> nh2: except if it's a choice between using the latest version of X and the latest of Y
09:58:53 <dcoutts> nh2: we didn't look at what the alternative that cabal picked was
09:59:06 <nh2> dcoutts: oh, that's true
09:59:22 <nh2> dcoutts: I'm not sure how to undo my install to get back to the same state
09:59:25 <dcoutts> nh2: and as I said, we do already prefer picking the installed versions of things, for good reasons
10:00:09 <carlosgaldino> S11001001: yeah, it's just one argument. but why it must be the Int in your example (String, Int), why not String in this case? that's the thing I want to know. I can see that it's impossible to fmap on both values so my question is why the second and not the first?
10:00:10 <S11001001> carlosgaldino: by 2nd to 3rd "argument", I mean the two things that aren't (a -> b).  Like, type arguments.  Sorry.
10:00:24 <carlosgaldino> S11001001: yeah I get it
10:00:44 <nh2> dcoutts: I think the reason it tried to avoid it was this required reinstall: http-client-conduit-0.2.0.1 (reinstall) changes: conduit-1.0.9.3 -> 1.0.15.1
10:01:09 <S11001001> carlosgaldino: because there is only one way to destructure (,) a b into a thing of kind (* -> *) and a thing of kind * to which the first is applied.
10:02:16 <pordan30> since fmap :: Functor f => (a -> b) -> (f a -> f b) where f :: * -> *, you need to partially apply (,) :: * -> * -> * for it to be a functor.
10:03:55 <carlosgaldino> I'm must be dumb or something, sorry guys
10:05:06 <dcoutts> nh2: right, so it also tries to avoid reinstalling things as that can cause breakage
10:05:14 <Guest30459> hello! could someone point me towards an active haskell core / library project I could contribute on (intermediate level)?
10:05:29 <dcoutts> nh2: and there's no particular well-specified order on these different preferences
10:08:26 <carlosgaldino> aaaaaah, I think I got it
10:08:37 <carlosgaldino> thanks S11001001 and pordan30
10:15:13 <h_h[2]> guys! What is the correct replacement for this code http://ideone.com/IrLGn9?
10:16:34 <dcoutts> h_h: looks like a homework assignment :-)
10:16:59 <dcoutts> h_h: not that that's a bad thing, but don't ask for the answer, ask for help in understanding
10:17:20 <milfjord> I don't understand the question
10:17:59 <dcoutts> h_h: e.g. explain what you think about it, and someone can point you in the right direction
10:18:39 <dcoutts> and as milfjord says, it's actually not clear what you mean
10:19:12 <dcoutts> apply :: (t -> a) -> (t -> a) -> t -> [a]
10:20:09 <milfjord> .oO( apply :: (tessier -> ashcroft) -> (tessier -> ashcroft) -> tessier -> [ashcroft] )
10:20:21 <h_h> okay, I guess that Haskell has already implemented function as part of language, which acts like 'apply' from my snippet above. It's like '$' for parentheses.
10:20:34 <Guest30459> h_h: a bit out of context but note that (\y -> succ $ succ y) can be expressed as (succ . succ)
10:21:02 <milfjord> > liftA2 (,) succ (succ . succ) 1
10:21:03 <lambdabot>  (2,3)
10:21:15 <h_h> wow
10:21:21 <h_h> thank you :)
10:21:35 <dcoutts> h_h: but that would not be the right answer to a homework assignment
10:21:52 <dcoutts> milfjord has just blinded you with wizardry :-)
10:21:54 <milfjord> > (succ &&& (succ . succ)) 1
10:21:56 <lambdabot>  (2,3)
10:21:59 <milfjord> better
10:22:00 <h_h> but it is not homework =\
10:22:18 <dcoutts> h_h: ok, but there's still a simple and clear way to do it
10:22:30 <dcoutts> which one should understand first before doing fancy things
10:22:46 <pordan30> you could write apply xs x = fmap ($ x) xs, then f = print . apply [succ, succ . succ]? this is a little more extensible
10:22:59 <dcoutts> namely: apply2 f g x = (f x, g x)
10:23:11 <Guest30459> https://gist.github.com/a3gis/9396092
10:23:12 <milfjord> pordan30: did you mean: sequence
10:23:32 <milfjord> > sequence [succ, succ . succ] 1
10:23:33 <lambdabot>  [2,3]
10:23:50 <h_h> heh
10:24:07 <supki_> > [succ, succ . succ] ?? 1
10:24:09 <lambdabot>  [2,3]
10:24:34 <milfjord> :t (??)
10:24:35 <lambdabot> Functor f => f (a -> b) -> a -> f b
10:24:47 <pordan30> sure, that works; i should have noticed that :)
10:24:54 * dcoutts prefers the (?!) "oh noes" operator
10:24:56 <troydm> so, i'm buffled i'm parsing Text using attoparsec so i need to parse a character only if it's part of a set of a character but i seem can't find a function for it
10:25:17 <troydm> that kind of functions are basicly in any parser library
10:25:19 <joelteon> (what ?!)
10:25:35 <t7> @src (??)
10:25:35 <lambdabot> Source not found. And you call yourself a Rocket Scientist!
10:25:54 <milfjord> f (m b) -> m (f b)
10:25:59 <dcoutts> troydm: yes and it's often called  satisfy :: (Char -> Bool) -> Parser Char
10:26:09 <dcoutts> troydm: which is what it is in attoparsec too
10:26:18 <troydm> dcoutts: ahh, thx
10:26:24 <joelteon> troydm: do you mean `inClass' and `notInClass'?
10:26:41 <joelteon> to be used in conjunction with satisfy
10:26:45 <dcoutts> troydm: it's the same in parsec
10:27:08 <troydm> dcoutts: i've used oneOf in parsec
10:27:12 <dcoutts> (though with a more complicated overloaded type)
10:27:19 <troydm> dcoutts: but attoparsec doesn't has oneOf
10:27:38 <skypers> what’s the command in ghci to see how much RAM it consumes?
10:27:43 <dcoutts> troydm: I guess it's trying to encourage you to use more efficient things
10:27:47 <joelteon> you could define it yourself
10:27:55 <dcoutts> since attoparsec is all about speed
10:28:07 <troydm> yeah, ic
10:28:14 <dcoutts> oneOf cs = satisfy (`elem` cs)
10:28:22 <dcoutts> but that's a linear lookup in a list
10:28:34 <ClaudiusMaximus> skypers: :set +s
10:28:42 <nh2> also satisfy gives very bad error messages
10:28:48 <skypers> thank you ClaudiusMaximus
10:28:52 <nh2> as useful as: "failed to parse: satisfy"
10:29:10 <joelteon> that's what <?> is for
10:29:17 <joelteon> there's no way to give a good error message for satisfy
10:29:20 <dcoutts> nh2: that's fair enough, and parsec does aim to give decent messages
10:29:36 <cdk> is there a prelude function like findMinBy :: (a -> a -> Ordering) -> [a] -> (a, [a]) which finds the minimum element in a list and returns that element and the list with that element removed? Theres similar functions for Set and Map, but not List which is surprising.
10:29:37 <dcoutts> but attoparsec doesn't try to give helpful error messages iirc
10:30:00 <skypers> Prelude> putStrLn "lol"
10:30:00 <skypers> lol
10:30:00 <skypers> (0.00 secs, 0 bytes)
10:30:02 <skypers> huh what?
10:30:04 <ReinH> ion: crap, thanks for the heads up. I'll look into it.
10:30:06 <skypers> 0 bytes?! :D
10:30:15 <vote_vis_systemd> yea haskel, hoorah
10:30:21 <vote_vis_systemd> runs on drones
10:30:25 <geekosaur> where did it need to do allocation?
10:30:25 <vote_vis_systemd> bombs little girls
10:30:27 <milfjord> vote_vis_systemd: hello
10:30:31 <vote_vis_systemd> remeber bomb little girls, don't marry them
10:30:37 <vote_vis_systemd> or do I have that backwards
10:30:39 <nh2> I mean: if possible, things like `char 'x'` are nicer than `satisfy (=='x')` since for those the parser can at least say what was expected; for satisfy, it can't inspect the ->Bool function
10:30:42 <vote_vis_systemd> make love not war
10:30:43 <vote_vis_systemd> so
10:30:44 --- mode: ChanServ set +o geekosaur
10:30:44 --- mode: ChanServ set +o milfjord
10:30:45 --- mode: ChanServ set +o dcoutts
10:30:51 <dcoutts> heh
10:30:52 --- mode: geekosaur set -o geekosaur
10:30:53 --- mode: ChanServ set -o dcoutts
10:31:00 --- mode: ChanServ set +o geekosaur
10:31:00 <vote_vis_systemd> marry little girls, don't bomb them
10:31:00 <vote_vis_systemd> Vote agaist systemd, Please Second this proposal: https://lists.debian.org/debian-vote/2014/03/msg00000.html
10:31:00 --- mode: ChanServ set +o dcoutts
10:31:02 --- mode: milfjord set +b *!*@ool-457ca46c.dyn.optonline.net
10:31:05 --- kick: vote_vis_systemd was kicked by dcoutts (vote_vis_systemd)
10:31:06 --- mode: geekosaur set +b vote_vis_systemd!*@*
10:31:12 <joogi> wtf
10:31:16 <joelteon> wat
10:31:36 <joelteon> ok i haven't seen that one before
10:31:41 <geekosaur> not worth trying to understand the motives of trolls
10:32:04 --- mode: ChanServ set -o dcoutts
10:32:17 <dcoutts> the dreaded systemd debate :-)
10:32:29 --- mode: geekosaur set -o geekosaur
10:33:03 --- mode: milfjord set -o milfjord
10:33:10 <troydm> what has marrying little gurls has to with systemd?
10:33:13 <troydm> O_o
10:33:21 <troydm> *to do*
10:33:44 <Yaniel> I thought the systemd debate had ended a long time ago already
10:33:56 <troydm> Yaniel: nah, it's still flaming
10:34:52 <Earnestly> Yaniel: It has ended, people are just making noises now
10:34:54 <Earnestly> ;p
10:35:24 <Yaniel> they voted and decided; one'd imagine people could stop whining already
10:35:27 <Yaniel> oh well it's the internet
10:35:50 <Yaniel> where everyone else is wrong
10:36:42 <pordan30> and not being able to choose an init system is just like drone warfare and arranged marriage, if i read that right...
10:37:30 * hackagebot text-format 0.3.1.1 - Text formatting  http://hackage.haskell.org/package/text-format-0.3.1.1 (BryanOSullivan)
10:39:30 <Guest30459> hello! could someone point me towards an active haskell core / library project I could contribute on (intermediate level)?
10:41:47 <armlesshobo> pordan30: haha
10:41:50 <lispy> jfischoff: Okay, done spamming you on twitter :)
10:42:59 <lispy> jfischoff: the Sean Parent talk is worth watching. He shows how to make haskell-like data structures using C++11 features. Specifically he uses move semantics and shared_ptr<const T> to get immutable data types with sharing.
10:43:19 <alpounet> oh cool
10:45:54 <johannesbodannes> Hey. So...
10:47:36 <johannesbodannes> Math was my major, not Computer Science. I really enjoy Haskell, but I still don't feel fluent to the level I feel that I need to be. I've been thinking of picking up some math material which delves deeply into category theory, since it's something that I never covered at university. Is it something that's worth investing in if the sole interest is improving my understanding of Haskell?
10:47:50 <johannesbodannes> In principle it shouldn't be too hard to pick up, but it's still a lot of effort
10:49:15 <johannesbodannes> I dropped by my old university the other day, in fact, and went poring over the shelves and shelves of math books and there was surprisingly little material on the subject. All of the stuff I found was online <_<
10:49:22 <joelteon> Well they always say you don't need to know category theory to know Haskell
10:49:28 <johannesbodannes> Is it helpful though?
10:49:31 <joelteon> not sure what the situation is when you *only* know category theory
10:49:49 <johannesbodannes> Well, I'm not sure that I -only- know category theory. I mean...
10:50:24 <johannesbodannes> I taught myself how to program when I was a kid, but I never felt I could stoop to the level of actually studying computer science at a tertiary level since I never took it seriously like I took math
10:52:05 <hseg> Hi. I have a function f :: [a] -> [a]. I'd like to apply it to a list xs :: [(a, Bool)] such that map fst (ap f xs) = ap f (map fst xs) and that the boolean values associated with each element remains the same. However, no elegant formulation of ap is apparent to me.
10:52:14 <alpounet> johannesbodannes: it depends, what do you want to study/understand about haskell?
10:53:52 <johannesbodannes> I find it particularly hard to penetrate monads, for example, beyond using existing ones and making extremely simple variations of them.
10:55:14 <johannesbodannes> Mostly -
10:56:28 <johannesbodannes> when I program in haskell, I use significantly fewer monads, applicative fuctors, etc than I see in much more experienced coders' software. And I get the sense that I'm suffering a cost in efficiency and maintainability as a result. I feel pretty certain that it's simply due to a discomfort with some of the more advanced concepts in Haskell
10:58:45 <xianxu> account add twitter
10:59:18 <hseg> johannesbodannes: I've found this to be the most accessible introduction to functors/applicatives/monads online: http://adit.io/posts/2013-04-17-functors,_applicatives,_and_monads_in_pictures.html
11:00:25 <johannesbodannes> Do you recommend this over picking up a good, generalized math text on category theory?
11:01:29 <johnw> johannesbodannes: start with functors; monads are just hopped-up functors with a few extra features
11:02:15 <johannesbodannes> OK, thanks. I'll put the math down and give this a try instead.
11:03:44 <flazz> how can i use runhaskell with a cabal sandbox?
11:03:45 <hseg> johannesbodannes: The math behind this might give you a greater appreciation of the generality of the concepts, but you don't need to know it to use monads.
11:04:03 <johnw> also, going the math route will take a while to get the hang of Haskell monads, since there is much more depth there
11:05:46 <johnw> (depth on the math side).  The fullness of mathematical monads are not expressible in Haskell, because in Haskell they are confined to endofunctors within a specific kind of category
11:06:11 <johnw> in fact, getting the hang of how to use monads doesn't need any math whatsoever
11:06:20 <alpounet> johannesbodannes: to be honest, studying the purely category-theoretic aspect of monads etc will provide you different insights than studying monads in haskell. And the fascinating connections we see in Haskell are not the most fascinating topics in the general setting of category theory.
11:06:26 <hcaulfield57> Well, I think I understand monads now, at least insofar as they are implemented. I ran through an example of running >>= on a State monad with some data, and it all makes sense
11:06:38 <johnw> first, you learn how to become adept with a particular concrete instance of Monad, like Maybe or IO.  Then you learn how to write code that works for any Monad m
11:06:45 <alpounet> johannesbodannes: also, what you feel is perfectly normal, I think we've all been through this
11:07:07 <johnw> yes, we all go through this
11:07:42 <alpounet> johannesbodannes: http://vimeo.com/6590617 this talk (and the related posts by the same person, and similar posts by others)  changed my perception of monads in haskell, really creative way to talk about them
11:08:10 <alpounet> (it's "Commutative Monads, Diagrams and Knots" by Dan Piponi)
11:08:12 <johannesbodannes> oh thanks!
11:08:14 <johnw> if I had it all to do again, I'd spend a lot more time on functors and applicative functors than worrying about monads; functors are a much deeper subject than they at first appear
11:08:37 <alpounet> johannesbodannes: let me know if you liked it once you've watched it :)
11:08:55 <hseg> And applicatives are more useful and optimizable than monads.
11:09:48 <hseg> alpounet: Thanks for the link. Looks interesting. Then again, anything from sigfpe is interesting. He introduced me to Andreas Blass's Seven Trees in One.
11:10:35 <hseg> Anyway, someone know how to implement funkyMap here: http://lpaste.net/100792 ? I'd rather not fuse the functions together.
11:10:51 <alpounet> hseg: yeah, almost any post he wrote inspired me a lot of thoughts, that's such an awesome feeling
11:11:45 <alpounet> johannesbodannes: in particular, a very interesting aspect is the relationship between monads and substitution
11:11:46 <hseg> Yup. Except for the physics and differential geometry ones. They just inspired confusion and a desire to learn those fields to understand what the hell he was talking about.
11:12:26 <alpounet> hseg: heh, yeah I was a bit lost in some of the physics post, but I was mostly able to follow the diff geometry ones, I've taken a few courses about that topic
11:12:41 <alpounet> (i studied math, not cs)
11:13:43 <dennda> 3
11:13:45 <hseg> Nice. Is topology necessary for differential geometry? I'm trying to grok that. Not going too well, I'm afraid.
11:13:45 <dennda> Oops.
11:13:46 <Cale> hseg: It is totally unclear to me what you want f to do
11:15:18 <Cale> (It's also pretty unclear what choose does...)
11:15:30 <hseg> OK.
11:16:15 <hseg> choose xs x should return the list of all subsequences of xs where all occurences of x are dropped but one.
11:16:54 <hseg> thus, "ababa" `choose` 'a' should be ["baba", "abba", "abab"]
11:16:58 <SJSUNoob> Running through a haskel tutorial, have the following in put and results
11:16:59 <SJSUNoob> ghci> 5 /= 5   False   ghci> 5 /= 4   True
11:17:07 <SJSUNoob> what is /=?
11:17:11 <shachaf> ≠
11:17:17 <Cale> hseg: wait, that example isn't consistent with what you described
11:17:19 <SJSUNoob> I see, thanks
11:17:33 <SJSUNoob> What an odd way to use "/"
11:17:38 <hseg> Cale: Why?
11:17:39 <SJSUNoob> It's like ascii art!
11:17:50 <SJSUNoob> For me "/" = divide
11:17:57 <Cale> You said all occurrences of x are dropped but one
11:17:59 <SJSUNoob> I seem != and ~= up to this point
11:18:00 <alpounet> hseg: knowing some topology definitely helps yes, since most interesting spaces to do diff geometry on are differentiable manifolds, which definitely is a topology topic
11:18:08 <SJSUNoob> seen*
11:18:18 <Cale> SJSUNoob: But when you put a slash through an = sign, it means "not equal to"
11:18:30 <hseg> alpounet: OK. I'll stick to my topology until I grok it, then.
11:18:32 <pordan30> i like <> for not equal, it looks less cluttered on the screen
11:18:35 <Cale> So because ≠ is hard to type, we just put it before :P
11:18:49 <SJSUNoob> Cale: I know, that's why I mentioned it's like ascii art :)
11:18:59 <StoneToad> at least there isn't any != operator, so you'll get an error if you type it in
11:19:07 <hseg> Cale, I meant the subsequences constructed by dropping all occurences of x but one.
11:19:12 <Cale> okay
11:19:24 <milfjord> > "map" <> "pend"
11:19:25 <lambdabot>  "mappend"
11:19:28 <alpounet> hseg: unless you're going to literally be working in that domain, don't focus too much on the symbols, but just paying attention to building an intuition for what's going on
11:19:28 <hseg> (that is, all the choices of a specific instance of x)
11:19:43 <alpounet> one can easily get lost when studying topology
11:19:43 <Cale> Then "ababa" `choose` 'a' should be ["abb", "bab", "bba"]
11:19:58 <edwardk> SJSUNoob: != being /= in haskell screwed me up for a while too
11:20:00 <hseg> Oops. Yes.
11:20:06 <edwardk> SJSUNoob: it grows on you though
11:20:22 <hseg> Sorry, inverted my logic. Yes, your example is correct.
11:20:23 <Cale> I never had much love for !=
11:20:35 <edwardk> especially as the expectation that you'll use operations like +=, etc. fades
11:20:52 <SJSUNoob> edwardk: I can see that being a problem
11:20:57 <Cale> Yes, who would want to define an operation like +=
11:21:01 <Cale> ;)
11:21:06 <edwardk> Cale: yeah, weirdos =)
11:21:50 <SJSUNoob> Someone mind explaining the phrase "cannot infer instance". Hugs> 5 == True ERROR - Cannot infer instance *** Instance   : Num Bool *** Expression : 5 == True
11:22:20 <Cale> SJSUNoob: In order to compare things for equality, they must be the same type
11:22:26 <SJSUNoob> I know that it's basically stating that I cannot compare a number to a boolean, but what does "infer instance" mean? Cannot interpret?
11:22:35 * hackagebot monad-st 0.2.3 - Provides a MonadST class  http://hackage.haskell.org/package/monad-st-0.2.3 (EdwardKmett)
11:22:43 <hseg> SJSUNoob: Numeric literals are overloaded.
11:22:44 <Cale> SJSUNoob: So, if 5 == True is to be well-typed, that means 5 must represent a Bool value
11:22:52 <hseg> SJSUNoob: 5 :: Num a => a
11:23:01 <hseg> > :t 5
11:23:02 <lambdabot>  <hint>:1:1: parse error on input `:'
11:23:10 <hseg> @type 5
11:23:11 <lambdabot> Num a => a
11:23:12 <Cale> So, the compiler looks for an instance of Num for Bool so that it can apply fromInteger to interpret the literal 5 as a Bool
11:23:19 <pordan30> using (==) :: Eq a => a -> a -> a forces the underlying types (which must be the same!) to implement the equality class. an implementation of Eq is called an instance.
11:23:59 <hseg> Since 5 is of some Num type, True must also be. But there is no Num instance for Bool.
11:24:35 <SJSUNoob> Thanks guys, I understand. I was trying to get more into why the phrase "cannot infer instance" was used. Why not just say "cannot evaluate expression". More straight forward and makes sence
11:24:44 <SJSUNoob> I don't know what "infer" means
11:24:47 <hseg> Anyway, what I'd like f to do is apply choose by considering only the first component of each value.
11:26:17 <pordan30> you applied (==) to two arguments, one of type Num a => a and another of type Bool. But these must be the same type. So GHC goes looking for an instance of Num for Bool in order to make the types equal, and select the right implementation of (==).
11:27:34 <SJSUNoob> "Goes looking for an instance of Num for Bool" brain is hurting :(
11:28:09 <hseg> http://lpaste.net/100792
11:28:11 <edwardk> SJSUNoob: you can have an instance of Num for Bool, you just have to pick semantics. semiring or ring.
11:29:11 <edwardk> SJSUNoob: you can have one with xor and and   or one with and and or, in one case you get more mathematical structure, in the other it does 'more of what you'd expect'
11:29:15 <hseg> SJSUNoob: In the OO world, you would hear this formulated as: "The class you provided does not implement the interface you implied it does when writing this expression"
11:30:07 <SJSUNoob> Oh, so in a sense it's going up the inheritance looking to see if Bool implements Num?
11:30:25 <Cale> hseg: see the last annotation http://lpaste.net/100792
11:30:52 <hseg> Yeah. But relying on OO semantics to understand Haskell will hurt you in the long run.
11:30:52 <hiptobecubic> is the difference between semiring and ring just 0?
11:31:06 <hiptobecubic> "0" i mean
11:31:17 <StoneToad> why do you *want* a num instance for bool though?
11:31:24 <Cale> hiptobecubic: No, it's negation
11:31:25 <StoneToad> if it's to fix a type error...
11:31:35 <hiptobecubic> Cale, what do you mean?
11:31:45 <Cale> hiptobecubic: A semiring is the same thing as a ring, except that additive inverses are not required.
11:31:54 <johnw> "a semiring is an algebraic structure similar to a ring, but without the requirement that each element must have an additive inverse"
11:32:05 <Cale> You still much have a 0
11:32:08 <Cale> must*
11:32:35 <hseg> Cale: That is what I'm trying to do. I'm just trying to separate it into its separate components.
11:32:45 <Cale> and multiplication by 0 must annihilate everything (you normally use additive inverses to prove that property for a ring)
11:33:30 <hiptobecubic> Cale, ah ok
11:33:59 <hiptobecubic> Cale, so you still have multiplication with 0, but you have to be explicit about it because it's not implied by the additive inverse?
11:34:06 <hseg> hiptobecubic: Yes
11:36:39 <hseg> StoneToad: The Num instance for Bool is useful for all sorts of bitwise calculations. For example, CRCs are defined as polynomials over GF(2), which is isomorphic to the Num instance for Bool
11:36:50 <hseg> You'd probably want to newtype that, though.
11:37:36 <StoneToad> ay yes, I was not thinking of bitwise in the context of bool
11:37:43 <prophile> the num instance for bool is great
11:37:49 <StoneToad> I've spent a lot of effort to break myself from bit != bool in haskell!
11:37:51 <prophile> it shares the property with Integer of not being able to overflow
11:37:54 <StoneToad> err, bit == bool
11:38:13 <prophile> at least for multiplication
11:38:23 <pordan30> SJSUNoo: some information on type classes: http://book.realworldhaskell.org/read/using-typeclasses.html, http://learnyouahaskell.com/types-and-typeclasses, http://www.haskell.org/tutorial/classes.html
11:38:24 <hseg> StoneToad: That's great.
11:38:37 <StoneToad> and there's quite a few places there I've had type errors that got caught cause bool doesnt have a num instance
11:38:42 <hseg> prophile: addition is also non-overflowing.
11:39:04 <prophile> True + True = False probably does count as overflowing
11:39:11 <StoneToad> though I expect I'd just have gotten a type error somewhere else
11:39:18 <StoneToad> if it had the instance
11:40:44 <hseg> OK. I think I've finally understood what I should have asked in the first place. How do I de-fuse the working implementation I gave here: http://lpaste.net/100792 so that I can write choose as I did?
11:41:28 <hseg> There is no reason choose should have to know the structure of my list.
11:44:52 <NikolajK> I just had the idea that if you have the production rules of a context-free grammar, e.g. 5 possibilities for the replacement of a character, say, then you could assign a probability for each of them and just run a simulation of word generations after n steps, where the number of words just branches and you compute the probability for each path. what is that idea called, does it have some applications?
11:45:37 <mniip> Won't the tree grow exponentially? That's ineffective
11:46:07 <hseg> NikolajK: I suppose it's a variation on Markov chains
11:46:27 <hseg> mniip: No, he's picking a random path through his derivation tree.
11:46:30 <mniip> Oh that
11:46:32 <hseg> That's linear
11:46:54 <davidfetter_disq> samples of the world, unite! you have nothing to lose but your Markov chains!
11:46:57 <mniip> Yeah, letter-based markov, I guess
11:49:22 <Rylee> @hoogle System.Plugins.Loa
11:49:23 <lambdabot> package loadavg
11:49:23 <lambdabot> package altfloat
11:49:23 <lambdabot> package cabal-upload
11:49:24 <Rylee> @hoogle System.Plugins.Load
11:49:24 <lambdabot> package loadavg
11:49:24 <lambdabot> package cabal-upload
11:49:25 <lambdabot> package dist-upload
11:50:03 <Wizord> so my half-assed incorrect version of quicksort is 2 times as slow as Data.List.sort
11:50:13 <NikolajK> mniip: ineffective w.r.t. what? it's not like I have an application in mind
11:50:21 <Wizord> I'm glad it's n log n anyway
11:52:02 <Redz> does ghc efficiently compare same references?
11:53:23 <Redz> when comparing a big type/object with itself, that it doesn't break performance.
11:54:03 <milfjord> do you realize that == is a library function, not a builtin?
11:54:14 <magneticduck> http://ix.io/aY7
11:54:46 <magneticduck> I have a feeling I typed too much to describe such simple a problem
11:55:00 <magneticduck> =P oh well, at least now nobody can claim to not understand me
11:55:09 <magneticduck> (not that they did in the past..)
11:55:12 <milfjord> magneticduck: are you talking about template haskell?
11:55:13 <chirpsalot> magneticduck: have you looked at the Read typeclass?
11:55:31 <magneticduck> chirpsalot: >_>
11:55:38 <magneticduck> milfjord: I guess so!
11:55:55 <magneticduck> chirpsalot: is there something magic about it?
11:56:28 <magneticduck> I'll learn about template haskell
11:56:30 <hseg> magneticduck: Read is just a typeclass that gives you a function read :: String -> a
11:56:34 <chirpsalot> magneticduck: it's just for reading strings in as certain data types.
11:56:34 <magneticduck> I kind of should have known
11:56:52 <magneticduck> lol I know haskell well enough to know about the Read typeclass
11:57:04 <magneticduck> =P
11:57:05 <edwardk> Redz: no
11:57:06 <ClaudiusMaximus> > let x = [1..2^50] in x == x   -- Redz, ghc isn't magic enough (but see also StablePtr and reallyUnsafePtrEquality# or whatever they are really called)
11:57:10 <lambdabot>  mueval-core: Time limit exceeded
11:57:28 <hseg> magneticduck: Template Haskell allows you to build an abstract syntax tree at compile time, which is inserted into your code.
11:57:37 <edwardk> Redz: it can't actually. because of the terrible semantics assigned to Float/Double re equalty
11:57:39 <magneticduck> wonderful
11:57:39 * hackagebot trifecta 1.4.1 - A modern parser combinator library with convenient diagnostics  http://hackage.haskell.org/package/trifecta-1.4.1 (EdwardKmett)
11:57:40 <edwardk> er equality
11:57:47 <magneticduck> I guess I should have known
11:57:52 <magneticduck> I haven't used templates in the past that much
11:58:29 <edwardk> Redz: NaN /= NaN, so any structure that might possibly contain a float couldn't use referential equality as  stronger form of structural equality
11:58:41 <Wizord> > 2^(2^50) `mod` 131
11:58:47 <lambdabot>  mueval: ExitFailure 1
11:58:47 <lambdabot>  mueval: Prelude.undefined
11:58:49 <hseg> magneticduck: It's mostly used to reduce boilerplate. Like in Edward Kmett's Lens library - you can derive the lenses for a type generically.
11:59:00 <hseg> s/type/record type/
11:59:29 <magneticduck> btw out of curiosity, are typeclass instances made with "deriving" anything to do with template haskell?
11:59:34 <Redz> uh. what have floating numbers to do with it?
11:59:41 <magneticduck> they aren't are they
11:59:42 <milfjord> magneticduck: no
11:59:46 <magneticduck> I really have to learn about templates
11:59:48 <magneticduck> xP
11:59:56 <hseg> magneticduck: Don't think so. It's GHC magic AFAICT.
12:00:04 <magneticduck> that's what I thought too
12:00:29 <Wizord> > 2^50 `mod` 131
12:00:30 <lambdabot>  80
12:00:40 <geekosaur> Redz: between that question and your first one, I think you do not understand how Haskell works
12:00:47 <hseg> Then again, it seems pretty easy to code using Generics, so it might be that that's what's happening under the hood.
12:01:51 <hseg> Question. How do I de-fuse the working implementation I gave here: http://lpaste.net/100792 so that I can write choose as I did at the top? choose shouldn't have to know about the structure of the elements of my list. Just that they contain values :: a
12:02:09 <ologNation> Can someone tell me how to reset the password for the nick name registered with NickServ?  Thanks.
12:02:37 <magneticduck> ologNation: #freenode
12:02:48 <StoneToad> hseg: what is choose supposed to do?
12:02:52 <magneticduck> there are staff there to help you with it and do some magic like restoring accounts if need be
12:03:05 <ologNation> magneticduck, Thanks
12:03:48 <NikolajK> http://en.wikipedia.org/wiki/Stochastic_context-free_grammar
12:04:06 <hseg> StoneToad: As seen in the working implementation, it's supposed to give the list of all choices of one particular instance of v in xs. e.g. "abaca" `choose` 'a' = ["abc", "bac", "bca"]
12:05:50 <aeio> so do any of you guys here use haskell at work?
12:05:56 <johnw> I do
12:06:02 <schell> aeio: i do
12:06:03 <Redz> edwardk: but i simply want to compare references. when one calculation leads to one value and i compare it with itself, it should be even in case of NaN compareable. even if its not in the spec.
12:06:11 <nh2> I did
12:06:12 <zomg> we're deploying something for SXSW and one of the components is in Haskell :)
12:06:31 <johnw> in fact, Haskell is the only language we use
12:06:59 <aeio> do you primarily use haskell or is it secondary?
12:07:09 <schell> has anyone written a tutorial on using reform with reform-blaze? (blaze-html form validation)
12:07:27 <aeio> if I may ask, how did you guys find those jobs?
12:07:39 <johnw> job posting to haskell-cafe
12:07:55 <aeio> I'm not particularly set on haskell, but everything I see is really trivial mid-range programming stuff
12:08:00 <zomg> I just wrote the component in haskell because nobody stopped me
12:08:04 <zomg> Otherwise we use node :P
12:08:07 <aeio> lol
12:08:12 <StoneToad> hseg: so, you're just returning a list of lists with a different duplicate of the target element retained? but you want this to work with some arbitrary typeclass instead of just lists?
12:08:33 <schell> aeio: at my work haskell is used just for development processes and tools that i write ;)
12:08:37 <nh2> aeio: primarily
12:08:40 <aeio> zomg, node.js?
12:08:43 <zomg> yeah
12:08:57 <magneticduck> javascript has grown too powerful.
12:09:02 <aeio> how is node?
12:09:03 <edwardk> Redz :there is reallyUnsafePtrEquality, but like i pointed out above, even if it says True, it isn't an indication that the valid Eq instance for those arguments will agree.
12:09:03 <magneticduck> it must be stopped
12:09:07 <magneticduck> ...before it is too late
12:09:12 <aeio> I've only heard vague references to it, never really looked at it
12:09:17 <zomg> aeio: depends on who you ask I guess.. it's alright if you like javascript
12:09:24 <hseg> StoneToad: Yes, then no. I want to use it for an arbitrary value of type [f a], where f is an instance of some appropriate typeclass.
12:09:31 <aeio> schell: do you work at a software company?
12:09:34 <Redz> okay. thank you edwardk. ;)
12:09:49 <schell> aeio: i do
12:10:13 <aeio> that sounds nice!
12:10:13 <edwardk> Redz: also expect to get some more positives than you expect if CSE has been done on the code, etc.
12:10:25 <schell> aeio: a digital agency with a small startup inside it
12:10:58 <edwardk> > (0/0) == (0/0)
12:10:59 <lambdabot>  False
12:11:09 <aeio> schell: if you don't mind me asking, how did you find out about it?
12:11:09 <edwardk> let x = (0/0) in x == x
12:11:16 <edwardk> > let x = (0/0) in x == x
12:11:17 <lambdabot>  False
12:11:30 <schell> aeio: about my agency or about haskell?
12:11:37 <aeio> schell: the agency
12:11:38 <milfjord> > join (==) (join (/) 0)
12:11:39 <lambdabot>  False
12:12:32 <schell> aeio: through freelancing and friends i met the CEO and did work for them for a couple years until they hired me full time
12:12:44 <aeio> schell: cool
12:13:04 <aeio> schell: how long had you been freelancing for?
12:13:07 <schell> aeio: are you looking for a job or just doing some market research?
12:13:28 <hseg> milfjord: Awesome use of join. Never saw it used in the Reader instance before.
12:13:36 <schell> aeio: about 3 years or so
12:13:48 <schell> aeio: wait, maybe 5
12:14:01 <schell> aeio: i'll say ~4
12:14:31 <aeio> schell: well, I am looking for a job; but mostly I'm asking around to see how others have done it out of curiosity/frustration
12:14:37 <ologNation> magneticduck, That solved my problem!  Thanks for redirecting me there.
12:14:42 <magneticduck> yay
12:14:51 <magneticduck> not sure why you asked on haskell =P
12:14:52 <StoneToad> hseg: I'm stumped, only though is to try rewriting insertOnce using traversable/foldable instead of list
12:14:53 <magneticduck> but it's solved
12:14:55 <magneticduck> so that's good
12:15:42 <Redz> edwardk: good thing is that i dont want to use it on numbers. ;)
12:15:45 <ologNation> Haskell is the greatest language ever !!!!
12:16:02 <aeio> aeio: I feel like I'm stuck in kind of a weird position where I spent so much time programming that I never made any programming contacts/friends
12:16:10 <magneticduck> @faq can haskell solve problems with NickServ accounts?
12:16:10 <lambdabot> The answer is: Yes! Haskell can do that.
12:16:18 <hseg> StoneToad: All solutions I've thought of make choose have to know way too much about its input.
12:16:35 <aeio> so I'm really good at programming, but I don't know how to use that to get a job :(
12:16:46 <schell> aeio: yeah the social aspect of programming/freelancing is important
12:17:25 <aeio> schell: yeah, I thought about freelancing for a time; I have a ton of respect for people who are able to make a living doing it
12:17:26 <schell> aeio: you could go the route of craigslist or other sites that hook up devs to companies
12:18:12 <aeio> schell: hmm, I never tried craigslist
12:18:32 <schell> aeio: meetups can also be a lucrative place to get gigs, free pizza and beer
12:18:57 <aeio> schell: oh, that's a good idea too. I totally forgot about meetups
12:18:58 <StoneToad> hseg: you should be able to get around that either providing a function to choose (aka chooseGeneric) or a custom typeclass
12:19:31 <StoneToad> which makes me think that someone who's deep into lenses would proably be able to cough out some crazy stuff that would deal with this
12:19:38 <StoneToad> but that is not me
12:19:39 <schell> aeio: i've found though that friends that are freelancers are great for freelancing, because everyone can pass around their overflow work
12:19:41 <hseg> Right.
12:19:55 <schell> aeio: that's probably the best resource IMO
12:20:10 <aeio> schell: yeah, that's true
12:20:30 <aeio> schell: thanks for the help btw, I appreciate it
12:20:36 <hseg> Thing is, I don't see how to decouple choose from the structure of its input
12:20:44 <schell> aeio: no prob - best of luck
12:20:45 <aeio> schell: you didn't work with haskell when you freelanced, right?
12:20:52 <Redz> edwardk: how about compare something multiple times? ghc sharing should handle it, right?
12:21:20 <schell> aeio: no - mostly flash, js, php and a little c
12:21:32 <aeio> I see
12:21:52 <schell> aeio: i've only been into haskell for the past ~2 years
12:21:57 <edwardk> Redz: no, you'll pay full price each time
12:22:07 <schell> wish i had come here earlier
12:22:12 <aeio> schell: oh, how long have you been coding for?
12:22:25 <NemesisD> hey guys, i'm trying to build a monad transformer stack that's got a reader and the ability to return success/failure like Either, but I'm not having luck with ReaderT MyState (Either String) a, should i be taking a different approach?
12:22:50 <schell> aeio: since 2003, that's when i first learned html (through photoshop of all places)
12:22:58 <aeio> I'm a little embarrassed to say this, but I don't think I've even touched haskell in like 5 years :/
12:23:00 <dwcook> NemesisD, what do you mean you're not having luck?
12:23:05 <Redz> i should write my own language, i guess. with blackjack and stuff.
12:23:09 <aeio> schell: lol
12:23:12 <hseg> Redz: Please. Tell us what you're trying to do. Not how you're trying to solve it. You might be wasting your time trying to optimize something unnecessary.
12:23:17 <aeio> schell: we started at around the same time then, cool
12:23:25 <aeio> schell: I assume you were pretty young?
12:23:42 <schell> aeio: i was...19
12:23:58 <aeio> schell: well, that's certainly not old ;)
12:24:00 <schell> so..maybe? maybe not
12:24:27 <NemesisD> dwcook: newtype MyStack a = { runStack :: ReaderT MyState (Either String) a }, i'm having trouble writing foo :: MyStack () that will return a Left case
12:24:33 <aeio> schell: lol, well that fact that you even know what haskell is already puts you higher than like 90% of programmers,  so you've got that going for you
12:25:00 <NemesisD> dwcook: i think my type is wrong, i need a function that evaluates a MyStack a and returns Either String a
12:25:08 <milfjord> lift (Left "hi")
12:25:27 <milfjord> runReaderT (runStack x) y
12:27:12 <schell> aeio: ha, thanks - i'm off to lunch
12:27:45 <Redz> hseg: i'm not sure what i do. ;)
12:27:49 <NemesisD> milfjord: alwaysFail :: MyStack (); alwaysFail = lift $ Left "hi"; expected type MyStack () actual type t1 (Either String) ()
12:27:51 <Redz> actually, i'm writing on a simple ui for games, based on circles and symbols (just images). just for fun, i consider to use symbols only to differ. and this would mean to compare images every time.
12:28:17 <pordan30> why does 1/0 == 1/0 and -1/0 == -1/0, but 0/0 /= 0/0? what differentiates the former cases from the latter one, and why isn't this just undefined behavior?
12:28:19 <milfjord> NemesisD: what's the error message?
12:28:50 <milfjord> oh, wait
12:28:54 <milfjord> : lift
12:28:57 <milfjord> :t lift
12:28:58 <lambdabot> (Monad m, MonadTrans t) => m a -> t m a
12:29:03 <hseg> pordan30: Because x/0 = infty, whereas 0/0 is NaN
12:29:18 <milfjord> yeah, because newtype
12:29:19 <NemesisD> in which M is Either String
12:29:27 <NemesisD> m*
12:29:33 <milfjord> MyStack (lift (Left "derp"))
12:29:44 <NemesisD> should i not use a newtype?
12:30:06 <hseg> Redz: And what do you mean by "comparing images"? When do you consider images to be equal?
12:30:09 <Redz> hseg: id's can fix it too, but i dont want strings or ids or a free type for comparison, when it's not necessary. after all, i just want to experiment with haskell/ghc now.
12:30:15 <NemesisD> ahh you're right
12:30:28 <NemesisD> milfjord: i can just do a lifStack = MyStack . lift
12:30:34 <Wizord> wow: (10 :: Z/23) ^ ((2 :: Z/23) ^ 100500)
12:31:34 <spion> Is there a way to convert a lazy ByteString to a regular String?
12:31:43 <pordan30> hseg: right, but what's the logic behind NaN /= NaN, as in 0/0 /= 0/0? is this a standard feature of floating point arithmetic, or is there some reason behind it?
12:31:46 <milfjord> spion: several
12:31:56 <milfjord> shortest is show
12:32:03 <dwcook> spion, there's unpack
12:32:16 <milfjord> unpack gives you [ByteString] or something
12:32:19 <NemesisD> milfjord: works great. i always forget this step. thanks!
12:32:24 <dwcook> :t unpack
12:32:25 <lambdabot>     Not in scope: `unpack'
12:32:25 <lambdabot>     Perhaps you meant one of these:
12:32:25 <lambdabot>       `BS.unpack' (imported from Data.ByteString),
12:32:28 <dwcook> :t BS.unpack
12:32:29 <lambdabot> BSC.ByteString -> [Word8]
12:32:34 <milfjord> that's strict
12:32:37 <dwcook> What
12:32:37 <Redz> hseg: its not written, what an image is. there is no more than a class that wants it compareable.
12:33:04 <pordan30> (i.e., why isn't this behavior undefined, rather than 0/0 == 0/0 or 0/0 /= 0/0 :: Bool)
12:33:06 <hseg> pordan30: A) It's standard in floating point, AFAICT B) it's there because NaN means "I can't approximate this". Whereas x/0 can be approximated by infty pretty well.
12:33:27 <pordan30> i see
12:33:48 <spion> thanks. trying :)
12:33:51 <riceandbeans> what do you guys think of ocaml?
12:34:28 <aeio> ocaml would be nice if it was as comprehensive as haskell
12:34:33 <aeio> or python
12:34:41 <hseg> Redz: OK. I don't understand why you want your images to be comparable. What do you mean by that?
12:34:54 <shergill> aeio: what do you mean by comprehensive?
12:34:55 <aeio> I think there is some work along those lines
12:34:56 <hseg> Redz: When is image A equal to image B?
12:35:02 <dwcook> When I was introduced to OCaml in one of my CS classes, it mostly struck me as a strictly evaluated impure and mostly not as nice Haskell
12:35:36 <aeio> shergill: it's more of a gut feeling, but o'caml reminds me a lot more like c where you're basically on your own if you want anything outside of the base language
12:35:54 <aeio> the community just seems...different
12:36:28 <aeio> like they don't really care too much about strengthening any sort of centralization of the language or libraries
12:36:39 <shergill> aeio: things are quite a bit different with opam
12:36:43 <aeio> I don't know, maybe I'm thinking too much about it
12:36:56 <milfjord> true is lowercase in ocaml :-(
12:37:02 <aeio> shergill, never heard of it
12:37:10 <Redz> hseg: when every part of two images are equal, the images are equal. the usual.
12:37:20 <shergill> aeio: google it, it's a package manager
12:37:21 <aeio> shergill, I never did too much with o'caml, so I'm sure my views aren't the most accurate on the subject
12:37:31 <aeio> shergill, and it has been years since I've done anything with the language
12:37:47 <aeio> shergill, actually, what I did like was F#
12:37:52 <aeio> mostly
12:38:34 <aeio> shergill, but anyway, if I ever need to use o'caml for anything I'll definitely keep opam in mind
12:39:16 <riceandbeans> milfjord: uppercase is haskell?
12:39:30 <Redz> hseg: the standard case should be, that the image is defined somewhere globally as  :: Image  and then regularly compared with other images and itself.
12:41:58 <engineering> @pl foo n = maximumBy (comparing sum) . filter (\x -> sum x < n) .inits
12:41:58 <lambdabot> foo = (maximumBy (comparing sum) .) . (. inits) . filter . flip ((<) . sum)
12:41:59 <dwcook> milfjord, why is true being lowercase an issue?
12:42:02 <spion> String consists of 32bit unicode chars - afaik, ByteString is just made of 8-bit bytes. if I'm reading correctly, I can get a (strict) ByteString from a lazy one by using BS.concat, but not a plain (Data.String) String.
12:42:36 <spion> (or [Char])
12:42:52 <dwcook> (String is exactly [Char])
12:42:56 <spion> right.
12:43:46 <spion> so I'm assuming that mapping [Word8] to [Char] wont work for unicode chars
12:43:49 <prinsen> Im working with TH. Right now GHC takes a long time to compile (several minutes) and runs out of memory. Is there any options that affects this?
12:43:55 <dwcook> That's not to say that you couldn't interpret the BS as ASCII or multiple bytes as a Char
12:44:06 <geekosaur> spion: you can;t have unicode chars as such in a bytestring
12:44:35 <spion> okay. so what I want is, I guess, an utf-8 interpretation of a bytestring.
12:45:01 * spion googles that
12:45:18 <spion> Data.ByteString.UTF8 perhaps.
12:46:22 <spion> toString. yay. :D
12:46:50 <dwcook> :t Data.ByteString.UTF8.toString
12:46:51 <lambdabot> BSC.ByteString -> String
12:46:54 <dwcook> Neat.
12:47:45 * hackagebot mono-traversable 0.4.0 - Type classes for mapping, folding, and traversing monomorphic containers  http://hackage.haskell.org/package/mono-traversable-0.4.0 (MichaelSnoyman)
12:47:47 * hackagebot conduit-combinators 0.2.0.0 - Commonly used conduit functions, for both chunked and unchunked data  http://hackage.haskell.org/package/conduit-combinators-0.2.0.0 (MichaelSnoyman)
12:52:13 <klrr_> pipes-banana
12:52:46 * hackagebot blaze-textual 0.2.0.9 - Fast rendering of common datatypes  http://hackage.haskell.org/package/blaze-textual-0.2.0.9 (BryanOSullivan)
12:56:12 <jle`> is there a generic unzip?
12:56:32 <jle`> something like unzip f = (fst <$> f, snd <$> f)
12:56:41 <jle`> except more performant/doing the traversal only once
12:56:44 <jle`> maybe in foldable?
12:57:18 <bennofs> Hey, does anyone have ideas for improving http://lpaste.net/100798 ? I don't like the implementation of alphaBeta in particular, it seems like there should be a way to refactor it into smaller, independent parts, but I don't know how
12:57:34 <Eduard_Munteanu> jle`: that should already traverse only once, if the caller traverses only once
12:58:00 <jle`> Eduard_Munteanu: no way, really?
12:58:27 <jle`> it won't build fst <$> f first, and snd <$> f second?
12:58:53 <Ceiv6> hello
12:58:54 <Eduard_Munteanu> jle`: no, that wouldn't be non-strict
12:59:02 <hseg> Redz: A) What do you mean by "images equal in all their parts"? B) Why do you need this - what are you trying to do that requires knowing whether images are equal?
12:59:13 <Ceiv6> how is it possible to do something like foo@{...} with record wildcards?
12:59:15 <jle`> what if i used eitherside of the tuple separately
12:59:41 <jle`> (left,right) = unzip f
12:59:48 <jle`> somethingwithleft...
12:59:50 <jle`> somethingwithright...
13:00:09 <Eduard_Munteanu> jle`: depends how you traverse it *finally*
13:01:01 <lcfrs> Why doesn't this type check?: data F p a b c d = P (p a b) | Q (p (F p c d))
13:01:16 <Eduard_Munteanu> lcfrs: extra parens at the end?
13:01:35 <Eduard_Munteanu> Er, sorry.
13:02:30 <hseg> Is it possible to drop elements using a traversal?
13:02:33 <lcfrs> np
13:02:38 <jle`> would writing a Foldable-based unzip be able to provide any guaruntees?
13:02:42 <jle`> hseg: i'm pretty sure no
13:02:46 <jle`> oh
13:02:55 <jle`> sorry, i'm probably thinking of the wrong traversal
13:03:36 <Eduard_Munteanu> lcfrs: do you really mean 'F p c d'?
13:03:37 <ion> lcfrs: What is the kind of p?
13:04:02 <lcfrs> p :: * -> * -> *
13:04:54 <xintron> Which http client library would you recommend? http-conduit?
13:04:58 <Eduard_Munteanu> jle`: there are no guarantees unless you can guarantee something about the consumer
13:05:05 <Redz> hseg: a) sorry, i forgot that the user must write an instance for it. its not defined, how to compare an image. but it might be just a bitmap where you compare every pixel.
13:05:06 <Redz> b) the idea is a shortcut. i simply try to kick out everything, that isn't needed. also names/strings/ids are not needed, when you can compare the representing symbol/image.
13:05:09 <ion> lcfrs: I think you’ll need to apply it to a second parameter in Q.
13:05:43 <hseg> OK. Was just hoping that seeing values of type [(a, Bool)] as the composition of two Traversables might help me generalize choose here: http://lpaste.net/100792 so that it would work like in the reference implementation.
13:06:11 <SJSUNoob> I'm trying to do the following... ghci> let lostNumbers = [4,8,15,16,23,42]
13:06:34 <SJSUNoob> when I do I get the following error: Syntax error in expression (unexpected end of input)
13:07:10 <geekosaur> works here
13:07:23 <hseg> Basically, I want to break down the working implementation into choose, which doesn't know about the extra structure my data has, and a wrapper function that passes the data around and makes sure the data is in the correct representation.
13:07:47 * hackagebot HaRe 0.7.1.3 - the Haskell Refactorer.  http://hackage.haskell.org/package/HaRe-0.7.1.3 (AlanZimmerman)
13:07:51 <SJSUNoob> I'm using Hugs, I think that's what is causing the issue
13:08:13 <geekosaur> oh, don't include the "ghci>" at the front
13:08:19 <geekosaur> that's a prompt
13:08:34 <geekosaur> I would also not use bugs as it has not been developed since 2005 or thenabouts
13:08:44 <geekosaur> has only received minimal changes to keep it compiling
13:08:56 <SJSUNoob> well I don't, I do everything after the ghci>, still get the error
13:08:59 <Redz> yeah. i wonder. is haskell and ghc not hipster enough? :p
13:09:00 <hseg> SJSUNoob: That's invalid Haskell syntax. Unless you're working at an interactive prompt, in which case, all your statements are evaluated in the IO monad.
13:09:06 <Cale> Hugs doesn't allow you to make definitions at the prompt
13:09:07 <Twey> Heh, ‘bugs’
13:09:11 <Cale> only evaluate expressions
13:09:23 <SJSUNoob> arg... I'm going through a tutorial and Hugs is what the professor said we should use
13:09:33 <hseg> Redz: Again. The main reason I don't know how to help you is because I don't see why you would need pixelwise equality.
13:09:37 <Cale> Hugs is ridiculously outdated
13:09:44 <hseg> Nor how it would be useful.
13:09:48 <Eduard_Munteanu> jle`: think about how things evaluate _ -> (_, _) -> (x:_, y:_) -> (x:x':_, y:y':_) -> ...
13:09:51 <Cale> I have no idea why anyone would recommend it now
13:10:01 <geekosaur> really? gave you a ghci tutorial and told you to use hugs?
13:10:15 <ion> ಠ_ಠ
13:10:40 <SJSUNoob> This tutorial is one of the tutorials in the green sheet
13:10:41 <SJSUNoob> http://learnyouahaskell.com/
13:10:47 <geekosaur> that's for ghci
13:10:52 <lcfrs> ion: yeah, i think i was reading it wrong
13:10:53 <lcfrs> thanks
13:10:57 <geekosaur> don't use hugs
13:11:07 <Redz> hseg: let us assume that there is a reason. ;)
13:11:12 <SJSUNoob> This seems to work
13:11:12 <SJSUNoob> let x = 1 in x + 1
13:11:22 <Cale> SJSUNoob: It should still work though, if you want to be stubborn, just copy all the part after the 'let' into a file and load it with hugs
13:11:26 <geekosaur> if the prof requires you to use hugs for assignments then use hugs for those, but use ghci for everything else because there are no tutorials for hugs
13:11:35 <geekosaur> yes, that will work but it's not persistent
13:11:36 <Cale> Yeah, Hugs wants expressions
13:12:18 <SJSUNoob> I see, thanks!
13:14:04 <hseg> Redz: In that case, there is no guarantee that two bindings with the same value refer to the same memory location. In fact, that question is meaningless in Haskell. The only way you can know whether the images are equal is by comparing them explicitly. GHC *might* optimize repeated comparisons, but don't count on it.
13:16:21 <Redz> hseg: i tried it with
13:16:22 <Redz> main = print $ and $ neighbor (==) $ replicate 1000 [1..10^7]
13:16:22 <Redz> and a lesser replication count. it dont seems so.
13:16:34 <hseg> Anyone have an idea how to de-fuse choose here: http://lpaste.net/100792 ? I've given a worker function, but I can't see how to wrap it.
13:17:38 <hseg> Redz. GHC won't magically memoize everything for you. It *might* do so, but there are no guarantees regarding that.
13:17:48 * hackagebot linear 1.7 - Linear Algebra  http://hackage.haskell.org/package/linear-1.7 (EdwardKmett)
13:17:50 * hackagebot bound 1.0 - Making de Bruijn Succ Less  http://hackage.haskell.org/package/bound-1.0 (EdwardKmett)
13:18:00 <Redz> hseg: but i love magic! :p
13:18:03 <Cale> It would be admissible, but would waste all your memory
13:18:24 <Cale> So GHC does no automatic memoisation
13:18:27 <hseg> Redz: All you can do is write stuff more optimally assuming GHC won't memoize it.
13:18:56 <Cale> (apart from the sort that lazy evaluation implies, that if a variable is bound to an expression, then it remains evaluated so long as it is in scope)
13:19:56 <hseg> Cale: Still stuck with my de-fusing problem. I had attempted to generalize choose to all Traversables and proceed from there, but traversals can't drop elements.
13:21:32 <Redz> i really wish that the compiler could find the best solution because at some point the human cant. i'm not happy with still-good solutions.
13:23:10 <hseg> Redz: And I wish my compiler could read my mind and compile the program I meant to write, as well as determining whether it will get stuck on any input.
13:24:00 <sipa> > foldr f [a,b,c]
13:24:01 <lambdabot>  Could not deduce (Debug.SimpleReflect.Expr.FromExpr
13:24:01 <lambdabot>                      [Debug.SimpleReflect.Expr.Expr])
13:24:01 <lambdabot>    arising from a use of `Debug.SimpleReflect.Vars.f'
13:24:01 <lambdabot>  from the context (GHC.Show.Show a)
13:24:01 <lambdabot>    bound by the inferred type of
13:24:15 <Redz> hseg: but then the life wouldn't be funny anymore. ;)
13:24:18 <sipa> > foldr f 0 [a,b,c]
13:24:19 <lambdabot>  No instance for (Debug.SimpleReflect.Expr.FromExpr a0)
13:24:19 <lambdabot>    arising from a use of `e_10'
13:24:19 <lambdabot>  The type variable `a0' is ambiguous
13:24:19 <lambdabot>  Possible fix: add a type signature that fixes these type variable(s)
13:24:19 <lambdabot>  Note: there are several potential instances:
13:24:44 <Redz> *fun
13:31:12 <sykora> Does anyone know if/when associated patterns will make it into GHC? They were mentioned in the original PatternSynonyms proposal but they're not in the GHC manual (nor do they work on RC2) so I assume they didn't make it to 7.8.
13:33:11 <mgomezch> Is there a go-to library for integers with infinity?
13:36:31 <hseg> mgomezch: Integer can handle integers without overflowing. What do you mean?
13:37:25 <pavonia> something like data Integer' = Integer' Integer | Infinity, I guess
13:38:03 <mgomezch> hseg: No, I actually want to explicitly have a value that represents infinity. :)  Like, say, data Integer' = NegativeInfinity | Finite Integer | Infinity
13:38:12 <mgomezch> yeah, that :)
13:38:56 <hseg> mgomezch: In that case, I don't know of a go-to library.
13:39:00 <mgomezch> I rolled my own for now, but it’s kind of awkward and I guess there must be some library out there since we all love our weird math. :)
13:39:07 <hseg> :D
13:44:04 <levi>  pavonia: That looks like Maybe Integer to me.
13:45:29 <poucet> Either Integer Boolean
13:45:50 <KeLoo> hello
13:46:29 <Ohkai> i need to generate random city names, how can i do it with haskell?
13:46:42 <jfischoff> @hoogle Random
13:46:43 <lambdabot> System.Random class Random a
13:46:43 <lambdabot> System.Random module System.Random
13:46:43 <lambdabot> package Random123
13:47:04 <Ohkai> jfischoff: it does not provides random city names
13:47:14 <Earnestly> homework?
13:47:15 <levi> Ohkai: That's what your ingenuity is for!
13:47:23 <jfischoff> how would you do it in another language?
13:47:29 <poucet> Ohkai: Define random city names. Do you mean random names that soudn like city names? Or random names of real cities?
13:47:31 <Ohkai> https://github.com/stympy/faker
13:47:32 <jfischoff> in any language
13:47:33 <Iceland_jack> Ohkai: So you have a list of valid city names and want a random sample from that?
13:47:52 <Ohkai> poucet: random names that sound like city names
13:48:06 <poucet> Ohkai: Sounds to me you need to define some grammar, and then randomly choose an option :)
13:48:28 <Ohkai> poucet: yeah, i think so
13:49:16 <Ohkai> just wondering if there are libraries which may help me
13:49:33 <Ohkai> except System.Random :)
13:51:09 <levi> There are most likely some more libraries that would help, but which ones to suggest would depend on how you plan on attacking the problem.
13:52:28 <Ohkai> levi: i see only one option here: define valid parts of city name like town/ville/shire/etc and combine then with other valid parts
13:52:37 <Ohkai> levi: can you see other options?
13:52:47 <Ohkai> s/then/them/
13:53:31 <Iceland_jack> Ohkai: Depends how imperative it is to have them be actual names..
13:53:50 <magneticduck> Ohkai: what's the problem with scraping some random websites for city names?
13:53:58 <magneticduck> like directories or stuff
13:53:59 <Iceland_jack> You can scrape some lists of actual cities or towns and then just picking one at random
13:54:12 <magneticduck> I don't know; but when you want to get a huge database of <a thing that people make>...
13:54:14 <magneticduck> scrape websites!
13:54:33 <magneticduck> it's really fun too
13:54:51 <magneticduck> especially if you made a web crawler that crawled relevant links and scanned them for information...
13:54:53 <magneticduck> mmm
13:55:00 <magneticduck> maybe it's just me, but that type is stuff is kind of fun
13:55:29 <magneticduck> release a spider onto the web with some criteria, and wait
13:55:52 <magneticduck> probably a bit too much for your project though xD
13:56:09 <magneticduck> ............anyway
13:57:31 <Ohkai> scraping is really limited to existing towns having two lists with 6 elements in each gives me 6! variants of distinct combinations
13:57:41 <Ohkai> unless my math is falwed
13:58:38 <magneticduck> Ohkai: there are a lot of existing towns.
13:58:49 <magneticduck> In fact, most random likely town names already exist somewhere =P
13:59:09 <magneticduck> Ohkai: uh, I think you mean 6^2
13:59:15 <magneticduck> but I"m not quite sure what you're doing with those two lists
14:00:24 <Ohkai> have to go, thank you feedback!
14:00:27 <Ohkai> for*
14:02:53 * hackagebot base-compat 0.4.1 - A compatibility layer for base  http://hackage.haskell.org/package/base-compat-0.4.1 (SimonHengel)
14:02:55 * hackagebot hsimport 0.2.10 - A command line program for extending the import list of a Haskell source file.  http://hackage.haskell.org/package/hsimport-0.2.10 (DanielTrstenjak)
14:06:39 <poucet> > let x = 1 : x in x
14:06:40 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
14:13:16 <Peaker> I just realized Haskell's precedence is just like C's:  postfix (records), prefix (application), infix
14:14:25 <magneticduck> > let x = 1 : map (*2) x in x -- poucet :)
14:14:26 <lambdabot>  [1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,2...
14:14:31 <magneticduck> muce more interesting
14:14:58 <magneticduck> (there are other more complicated infinite list tricks out there ofc)
14:16:28 <poucet> magneticduck: oh I know :)
14:17:02 <magneticduck> poucet: ah, just testing then?
14:17:06 <Wizord> > foldl (1:) [] [1..]
14:17:07 <lambdabot>  Couldn't match type `[a0]' with `b0 -> [a0]'
14:17:07 <lambdabot>  Expected type: [a0] -> b0 -> [a0]
14:17:07 <lambdabot>    Actual type: [a0] -> [a0]
14:17:18 <poucet> magneticduck: being spammy I guess
14:17:25 <staffehn> Hi, is there a standard function of type (Either String a -> a) that throws the String as a error on the Left case?
14:17:51 <magneticduck> @hoogle Either String a -> a
14:17:51 <lambdabot> No results found
14:17:57 <magneticduck> I guess not!
14:18:08 <Twey> poucet, magneticduck: fix f = let x = f x in x
14:18:32 <magneticduck> :D
14:18:47 <magneticduck> haskell tea-time
14:18:57 <poucet> staffehn: either (error) (id)
14:19:00 <Twey> poucet, magneticduck: let x = 1 : x in x ≡ fix (1 :).  let x = 1 : map (* 2) x in x ≡ fix ((1 :) . map (* 2))
14:19:06 <magneticduck> everybody exchanging one-liner recursive thinggs
14:19:07 <geekosaur> note that the parens are useless there
14:19:14 <poucet> good point :)
14:19:36 <magneticduck> yes ((parens)) likes these (are) often (((useless)))
14:19:50 <poucet> @quote
14:19:50 <lambdabot> IsoPallo says: "Error: This program isn't worth compiling"
14:20:01 <magneticduck> @quote poucet
14:20:01 <lambdabot> No quotes match. Are you on drugs?
14:20:04 <magneticduck> no
14:20:07 <poucet> @quote vincenz
14:20:08 <lambdabot> vincenz says: data Object = Enemy | Friend | Gun
14:20:12 <poucet> o.O
14:20:15 <Eduard_Munteanu> staffehn: you might want to use ErrorT / EitherT if you have a bunch of stuff that can fail
14:20:46 <magneticduck> Twey: btw I believe that fix function has another name...
14:21:12 <magneticduck> uhm
14:21:16 <magneticduck> trying to recall it
14:21:26 <prinsen> Im using HXT on windows and recieve "unsupported protocol in URI "C:\.." on readDocument
14:21:29 <staffehn> Eduard_Munteanu: Just wanted to handle the "decode" function of cereal, or rather not handle it but print the error. For a script.
14:21:31 <Eduard_Munteanu> magneticduck: Y? (it's not quite 'fix')
14:21:52 <Twey> magneticduck: quchen wrote a generalized version called ‘moeb’: https://github.com/quchen/articles/blob/master/loeb-moeb.md
14:22:20 <Twey> magneticduck: The Y combinator is an implementation of fix that doesn't require the language to have recursive bindings
14:22:34 <Eduard_Munteanu> prinsen: try file://... URIs?
14:22:59 <pordan30> the discussion of streams had me looking for hinze's papers again. now i'm wondering if anyone can recall a paper that discussed codata and coinduction in a tutorial format (using haskell code, or directed at haskell programmers). it starts off by constructing and modeling a series of machines with views on state (and so on) and later discussed e.g. bisimulations.
14:23:16 <Eduard_Munteanu> Also Y is specifically an untyped lambda calculus combinator.
14:24:04 <quchen> I thought Y is simply a name for the fixed point combinator. (The usual untyped definition isn't possible in typed lambda calculus though.)
14:24:36 <Eduard_Munteanu> quchen: no, it's a rather specific fixed-point combinator, since you also have Z and omega.
14:24:51 <quchen> omega?
14:24:55 <quchen> You mean Omega?
14:25:01 <Eduard_Munteanu> Yeah.
14:25:07 <quchen> What's Z?
14:25:30 <Eduard_Munteanu> quchen: it's very similar to Y but for strict semantics
14:26:02 <prinsen> Eduard_Munteanu: Works thanks
14:26:43 <Eduard_Munteanu> quchen: https://en.wikipedia.org/wiki/Fixed-point_combinator#Other_fixed-point_combinators  provides more definitions
14:27:45 <quchen> Eduard_Munteanu: Interesting, thanks
14:29:07 <prinsen> Im compiling a large TH project, is there any way to 1. reduce compile time, 2. reduce memory consumption (im running out on 6 GB)
14:29:31 <Eduard_Munteanu> 'fix' is also _a_ fixed point combinator.
14:30:31 <Eduard_Munteanu> And we can talk about least, greatest or inbetween fixed points of functors. :)
14:31:20 <jfischoff> prinsen: turn off optimizations and profiling if you have them on for the problematic files
14:32:03 <prinsen> jfischoff: using -threaded -O0
14:32:12 <magneticduck> an untyped lambda calculus combinator?
14:32:21 <jfischoff> do you compile with profiling?
14:32:23 <magneticduck> an extension to the vanilla lambda calculus?
14:32:27 <magneticduck> or a synonym
14:33:25 <jfischoff> prinsen: also if your TH code has a spaceleak, then you will need to fix that
14:33:46 <jfischoff> but honestly I doubt that is it
14:33:55 <Eduard_Munteanu> magneticduck: no, just a function
14:34:16 <magneticduck> ah I sees
14:34:17 <magneticduck> kind of
14:34:17 <magneticduck> recursion in lambda calculus used to stump me x|
14:34:17 <magneticduck> it's ... not very intuitive
14:34:17 <jfischoff> What does the TH do?
14:34:22 <spion> does anyone think that the ability to import a package without qualified, or without being specific about the functions, is a major setback towards learning how to use haskell libraries?
14:34:35 <poucet> spion: no
14:34:44 <spion> then I guess I'm missing a tool.
14:34:47 <spion> :)
14:35:12 <prinsen> jizanthapus: Reads about a 1000 xml-files and generates data-types
14:35:28 <osa1> can anyone help me with this error: http://lpaste.net/100804 why I can't define a more specific instance?
14:35:54 <prinsen> jizanthapus: it's my first time writing TH so if you can expand on space leaks :)
14:35:55 <spion> poucet, when reading code online, how do you answer the question "where does this function come from" ?
14:36:07 <koala_man> hoogle
14:36:12 <jle`>  or hayoo
14:36:13 <poucet> spion: google
14:36:41 <poucet> spion: or look at the haskell docs
14:37:33 <b3tamax> is there any support in ghci?
14:37:51 <geekosaur> osa1, because the fundep in Text.Parsec.String says you can't use [Tok] and (LToken,Indentation) together
14:37:57 <geekosaur> they have to be the same type
14:38:21 <jfischoff> prinsen: I never be able to get GHC to generate a large amount of types efficently. Maybe it is possible, I haven't seen it.
14:39:30 <jfischoff> Ideally would be designed to stream the decls into the AST, but I who knows what it does.
14:39:43 <jfischoff> s/Ideally/Ideally GHC
14:39:46 <prinsen> GHC on windows says out of memory after 1.3 GB
14:40:07 <prinsen> I moved to windows as I have more RAM on this machine
14:40:19 <jfischoff> you can probably increase the memory it gets
14:40:20 <poucet> @quote magneticduck
14:40:20 <lambdabot> No quotes match. There are some things that I just don't know.
14:40:38 <jfischoff> maybe with the RTS options, never tried
14:40:44 <tessier> milfjord: You mean Ashpool?
14:42:58 * hackagebot linear 1.8 - Linear Algebra  http://hackage.haskell.org/package/linear-1.8 (EdwardKmett)
14:43:00 * hackagebot linear 1.8.1 - Linear Algebra  http://hackage.haskell.org/package/linear-1.8.1 (EdwardKmett)
14:44:54 <mosolov> Hey guys, sorry to bother with such a noob question, but i can't google it up... what does the !! operator do?
14:45:09 <dmj`> > [1..10] !! 1
14:45:10 <lambdabot>  2
14:45:27 <ParahSailin> @src (!!)
14:45:27 <lambdabot> xs     !! n | n < 0 = undefined
14:45:27 <lambdabot> []     !! _         = undefined
14:45:27 <lambdabot> (x:_)  !! 0         = x
14:45:27 <lambdabot> (_:xs) !! n         = xs !! (n-1)
14:45:37 <bennofs> > [1,2,3,4,5,6,7,8,9,10] !! 2
14:45:38 <lambdabot>  3
14:45:41 <dmj`> mosolov: it indexes a list, unsafely
14:45:50 <geekosaur> to be remembered is that that's a singly linked list, not an array
14:46:07 <mosolov> thank you!
14:46:47 <`^_^v> you should go to hoogle to look up haskell functions because youa rent going to be able to google many of them
14:46:50 <pordan30> you might find this website useful: http://www.haskell.org/hoogle/?hoogle=%28!!%29
14:47:34 <mosolov> Thanks, sorry for asking before properly looking up!
14:49:20 <brisbin> is there a good example of a Functor that's not a Monad?
14:49:50 <Iceland_jack> @google functor that is not monad
14:49:51 <lambdabot> http://stackoverflow.com/questions/7220436/good-examples-of-not-a-functor-functor-applicative-monad
14:49:51 <lambdabot> Title: haskell - Good examples of Not a Functor/Functor/Applicative/Monad? - Stack O...
14:50:18 <brisbin> shit sorry
14:50:19 <dmj`> try a tuple :)
14:50:29 <bitemyapp> brisbin: Data.Map?
14:50:30 <dmj`> :i (,)
14:50:32 <Iceland_jack> brisbin: What for?
14:50:35 <bitemyapp> I don't know how arbitrary that is or isn't though.
14:50:43 <brisbin> it was just a question a coworker asked and i couldn't think of one
14:50:43 <S11001001> dmj`: some tuples are
14:50:47 <bitemyapp> it's a Monoid and a Functor which is damn close.
14:51:03 <quchen> Tuples are Functors, but not Applicatives. ZipLists are Applicatives, but not Monads.
14:51:24 <bitemyapp> brisbin: http://hackage.haskell.org/package/base-4.6.0.1/docs/Control-Exception.html#t:Handler
14:51:36 <bitemyapp> brisbin: Functor only. No monoid, applicative, or monad.
14:51:55 <S11001001> instance Monoid x => Monad (,) x where ... -- implementable
14:51:55 <bitemyapp> brisbin: http://hackage.haskell.org/package/base-4.6.0.1/docs/Control-Applicative.html#t:Const functor, monoid, and applicative - but not a monad.
14:51:56 <brisbin> awesome, thanks bitemyapp
14:52:05 <ParahSailin> @src (,) fmap
14:52:05 <lambdabot> fmap f (x,y) = (x, f y)
14:52:40 <dmj`> S11001001: which?
14:53:05 <prinsen> jfischoff: Seems like GHC for windows is 32 bit, as -M3G is the maximum allowed
14:53:19 <jle`> ParahSailin: what did you just do?
14:53:27 <jle`> hm
14:53:35 <dmj`> prinsen: there is a win 64-bit version, it's just not apart of the haskell platform for windows
14:53:36 <jle`> the fmap instance for (,) ?
14:53:41 <jle`> but (,) doesn't even have an fmap instance...
14:53:45 <jle`> *Functor
14:53:47 <jle`> what is going on
14:53:59 <poucet> > fmap (+ 1) (2, 3)
14:54:00 <lambdabot>  (2,4)
14:54:02 <dmj`> jle`: why not?
14:54:07 <jle`> that's the functor instance for (,) Int
14:54:09 <jle`> not for (,)
14:54:13 <jle`> (,) isn't evne the right kind >.<
14:54:16 <jle`> :k (,)
14:54:18 <lambdabot> * -> * -> *
14:54:20 <jle`> :k Functor
14:54:21 <lambdabot> (* -> *) -> Constraint
14:54:28 <Iceland_jack> @kind forall a. (,) a
14:54:29 <lambdabot> * -> *
14:54:47 <jle`> but that's a Functor instance for (,) a, not for (,)
14:54:53 <dmj`> instance Functor ((,) a) -- Defined in `GHC.Base'
14:54:59 <jle`> exactly
14:55:01 <dmj`> oh
14:55:01 <quchen> (,) can't be a Functor, wrong king.
14:55:01 <ParahSailin> @src (->) fmap
14:55:02 <lambdabot> fmap = (.)
14:55:03 <quchen> kind*
14:55:07 <jle`> that's what I mean
14:55:10 <jle`> what the
14:55:18 <ParahSailin> jle`: @src is just weird and ad hoc
14:55:18 <quchen> Oh. Backscroll blindness, sorry.
14:55:31 <jle`> oh you lambdabot, so silly.
14:55:40 <poucet> @botsnack
14:55:40 <lambdabot> :)
14:55:49 <jle`> i heard that @src is just a text search anyway >.>
14:55:52 <quchen>  @src is literally a lookup in a static file.
14:56:14 <quchen> It contains lines like "(->) fmap", and that's what it displays when you @src them.
14:56:18 <jle`> i see
14:56:44 <jle`> is this static file avialable anywhere?
14:57:21 <quchen> I've seen one that was used by Lambdabot, I'm not sure the actual one in use right now is HTTP-accessible though.
14:57:36 <jle`> i see
14:58:17 <Iceland_jack> lambdabot actually isn't a bot, it's a group of prominent Haskellers that take turns typing out the responses
14:58:18 <quchen> You would probably have to ask the owner of lambdabot. It's int-e I think.
14:58:38 <quchen> Iceland_jack: That was lambdabot 1.0, before edwardk automated it with strong AI
14:58:40 <cha0x_> I have kind of an idiotic question
14:58:47 <S11001001> dmj`: return x = (mempty, x); (l, a) >>= f = let (l2, b) = f a in (l `mappend` l2, b)
14:58:48 <jle`> cha0x_: no idiotic questions :)
14:58:49 <bitemyapp> cha0x_: have you googled it?
14:58:51 <jle`> well maybe some.
14:58:57 <jle`> *there are
14:58:58 <Iceland_jack> cha0x_: shoot
14:59:00 <cha0x_> bitemyapp: repeatably
14:59:05 <bitemyapp> cha0x_: then by all means.
14:59:11 <geekosaur> most of those files are in State/ in the lambdabot distribution, I think
14:59:32 <jle`> geekosaur: thanks, i'll check those out
15:00:05 <jle`> found you https://github.com/mokus0/lambdabot/blob/master/lambdabot/State/source
15:00:20 <cha0x_> How can I go about installing ghc manually? (I am running linux-mint 14) I am not finding it on the official repositories (nor can I find what repositories they are on)
15:00:43 <jle`> cha0x_: download the source, configure, make, make install :)
15:00:51 <jle`> or you can download the binaries too
15:00:51 <Peaker> or the binary
15:00:53 <jle`> (that's reocmmended)
15:00:54 <cha0x_> jle`: location location location
15:01:03 <cha0x_> jle`: I know how to build from source
15:01:40 <jle`> have you looked at http://www.haskell.org/platform/linux.html ?
15:02:05 <jle`> or http://www.haskell.org/ghc/download_ghc_7_6_3
15:02:54 <geekosaur> I don't think the platform page works, it points to the distro. but mint is still based on the ubuntu that dropped it
15:03:22 <Iceland_jack> well http://www.haskell.org/ghc/download_ghc_7_6_3#binaries
15:03:22 <cha0x_> one moment
15:03:35 <Iceland_jack> or dare I suggest RC2… :)
15:04:13 <quchen> Iceland_jack: RC2 should be pretty stable, but waiting another couple of weeks or so for release might not be a bad idea anyway.
15:04:34 <Iceland_jack> Yeah
15:04:41 <quchen> It's (release candidate) 2 after all, not (release²) candidate :-)
15:04:45 <cha0x_> Right yea, cannot find libgmp.so.3
15:05:55 <quchen> I think you can softlink to your libgmp and it'll work. It's a bad idea to keep this on your system though.
15:06:13 <quchen> I'm not sure whether you can make the softlink, use the binary GHC to compile your own GHC, and then delete the softlink.
15:06:24 <quchen> Depends on which libgmp the new one is linked to, but might be worth a try.
15:06:34 <cha0x_> possibly
15:07:17 <quchen> Maybe these help, they're what I wrote for myself for whenever I have to start from scratch every N months. Simple version, GHC+Platform from binaries, https://github.com/quchen/articles/blob/master/install_haskell_platform_manually.md
15:07:26 <quchen> And my current GHC setup, https://github.com/quchen/articles/blob/master/zero_to_local_ghc.md
15:07:53 <quchen> Depends on an "obtained by any means possible" bootstrapping GHC though, I used my repos.
15:08:25 <quchen> Read it as a story, not an instruction manual. I have only tested it on my computer :-)
15:09:03 <cha0x_> Oh wow, thanks quchen that actually really helps
15:09:56 <quchen> cha0x_: FWIW, the new GHC build servers have updated libgmp files, so the .so.3 thing will probably not be an issue with 7.8's release.
15:11:07 <jle`> quchen: is official release expected to come out in a couple of weeks?
15:11:14 <cha0x_> quchen: well that's convenient, but as someone said before (if I can find it) soft link my current libgmp library which may be 2. I will have to actually look thru
15:13:23 <quchen> jle`: I haven't followed development very closely for the last weeks, let me have a look at the mailing lists
15:13:47 <quchen> (Guesstimate: Currently being fixed are OSX and Windows issues, and there won't be RC3)
15:14:49 <Hermit> is there a way to append parameters to an option in a .cabal file? for example, I have ghc-options: ..., and an os specific option I'd like to append. Do I have to repeat the whole thing or is there a way to say something like  ghc-options+: ... ? (or shell style  ghc-options: $ghc-options, ...)
15:14:50 <quchen> cha0x_: From the RC2 release mail, "There are now two binary builds for Linux users: one for glibc 2.12 and GMP 4, primarily intended for RHEL users, and one built for glibc 2.13 and GMP 5 - intended for Debian and more recent machines."
15:15:28 <dcoutts_> Hermit: they're automatically appended
15:15:35 <Hermit> oh, nice
15:15:55 <dcoutts_> Hermit: all cabal command line and .cabal file options are monoids (either list or last)
15:16:04 <quchen> jle`: "We plan to make the final 7.8.1 release soon, and hope RC2 will be the last RC.", by Austin Seipp (IRC: thoughtpolice) this Monday
15:16:19 <jle`> i'm dumb, i accidentally deleted my previous ghc right before making v.v
15:16:22 <Hermit> dcoutts_: I see, that clears it up
15:16:41 <cha0x_> jle`: *bro-fist*
15:17:06 <quchen> My advice is don't do that.
15:17:10 <cha0x_> quchen: Alrighty then. I will have to look into more when I get home. I'll be back in a little while
15:17:11 <jle`> was not even necessary >.>
15:17:20 <jle`> i just rememberd that i checkinstalled it
15:17:25 <jle`> so i sudo dpkg -r'd it
15:17:27 <jle`> and it deleted the binary
15:17:30 <jle`> ym
15:17:32 <jle`> um
15:17:34 <jle`> i'll just grab and old one somewhere
15:29:02 <jle`> s/and/an
15:33:55 <johnsonn> Hi, whats the best haskell book for a first time commer to haskell? I know how to program but never really had a go at Haskell, any good recommendations?
15:34:05 <Iceland_jack> @where lyah
15:34:05 <lambdabot> http://www.learnyouahaskell.com/
15:34:09 <Iceland_jack> johnsonn: alongside a machine-checked proof of its correctness. You can verify your outside interface by nearly autogenerating an interface fuzzer and checking encode/decode roundtrips or system fixed points. Finally, you can compile the whole thing down to Javascript and deploy it atop Meteor if that's your endgame.
15:34:09 <Iceland_jack> Idris is just one interesting point on this spectrum. I think availability of formal correctness proving (in capability, expression, organization, and automatic execution) will be a major force in the future of CS.
15:34:09 <Iceland_jack> [0] http://en.wikipedia.org/wiki/QuickCheck
15:34:17 <Iceland_jack> oops, sorry for the spam
15:34:32 <Iceland_jack> johnsonn: ↑ Learn You a Haskell is the book you're looking for :)
15:36:10 <shachaf> johnsonn: I like _Programming in Haskell_ by Hutton.
15:37:19 <Axman6> johnsonn: "I know how to program" is more of a hinderance than an advantage when learning Haskell, so be prepared to forget most of what you know =)
15:37:57 <Axman6> what you really said was "I know how to program wrong"
15:38:08 <nisstyre> Axman6: unless you learned to program by reading SICP or something
15:38:24 <quchen> Because writing Haskell is the only true way. Oh my.
15:38:27 <Axman6> they teach mutation, so it's also wrong
15:38:47 <Iceland_jack> For #haskell's definition of 'wrong' :)
15:38:50 <nisstyre> Axman6: well, if you read any good Scheme book it will talk about how giving (set! a b) a value is problematic
15:38:59 <quchen> For wrong definitions of 'wrong'.
15:39:08 <nisstyre> and that things like set-car! and set-cdr! can ruin the semantics of map or other HOFs
15:39:45 <johnsonn> Learn you a Haskell it is then :) Thanks guys!
15:39:56 <Iceland_jack> johnsonn: Best of luck!
15:40:09 <Axman6> damn, no one told him that #haskell is the second best book
15:40:41 <Iceland_jack> And it may not be the most ‘welcoming’ introduction to #haskell to hear ‘you known how to program wrong’ :)
15:40:57 <Axman6> the truth hurts
15:41:05 <quchen> It's a bad and wrong introduction to Haskell and #haskell and you should stop now.
15:41:08 <Axman6> I hope he understood it was mostly a joke though
15:41:09 <Iceland_jack> It's not the truth
15:41:27 <nisstyre> http://www.cs.virginia.edu/~evans/cs655/readings/ewd498.html
15:41:48 <Axman6> my experience with teaching haskell is that people with prior programming experience do no better than those with none, and often worse when learning haskell
15:41:53 <shachaf> #haskell gives a lot of bad and/or wrong advice
15:42:27 <Axman6> yeah, some people say that IO isn't a state monad over the RealWorld(TM)
15:42:42 <FreeFull> I had no problems learning Haskell
15:42:52 <Iceland_jack> Axman6: Yes, that's not the same thing though :)
15:43:00 <FreeFull> I'm a weird guy though
15:43:02 <nisstyre> Axman6: some people believe that side-effects can't be pure
15:43:08 <nisstyre> (which is incorrect of course)
15:43:12 <jle`> well there's a difference between IO and GHC's IO implementation
15:43:43 <haasn> some people use the term “pure” without really defining what they mean
15:43:58 <jle`> one could imagine the same IO monad implemented without state w/ RealWorld
15:45:42 <letrec> In http://lpaste.net/100807 , I kinda wonder what's the status of a ?
15:45:42 <Axman6> nisstyre: "side effects" can only be pure when the effects are passed as inputs to all future functions. (IMO)
15:46:10 <nisstyre> jle`: this seems like what people usually cite http://www.cs.indiana.edu/~sabry/papers/purelyFunctional.ps
15:46:25 <nisstyre> Axman6: have you ever programmed in Clean?
15:46:26 <quchen> letrec: What's a "status"?
15:46:35 <Axman6> no
15:46:48 <jfischoff> shachaf: then you should speak up
15:46:55 <nisstyre> Axman6: if you can prove that you only touch an object once then you are free to mutate it or whatever and your program is still pure
15:47:21 <Axman6> is that linear typing?
15:47:40 <nisstyre> Axman6: uniqueness typing yeah
15:47:44 <nisstyre> which seems to be related
15:48:00 <nisstyre> not the same thing though
15:50:05 <letrec> Guest98150: I rephrased my question (see http://lpaste.net/100808). What's the difference between the 2 typeclasses?
15:50:56 <Axman6> nothing, but you will cause problems by having two functions named f
15:51:01 <mietek> Any idea why cabal-install bootstrap does not find my libgmp.so.3?
15:51:10 <Axman6> oh, actually, I'm wrong, i missed the a
15:51:23 <geekosaur> an instance of MyClass2 has to specify both f and a
15:51:38 <geekosaur> and you can have different instances for the same f but different a-s
15:51:46 <haasn> in the body of MyClass1, f has type :: forall a. Int -> f a -> Int
15:51:55 <geekosaur> also the second will be a PITA to use without a fundep or an associated type
15:51:56 <haasn> in the body of MyClass2, f has type :: Int -> f a -> Int -- the ‘a’ comes from the class
15:52:10 <mietek> I have one both in /usr/lib and in /usr/lib64
15:58:43 <copumpkin> argh, what's the syntax for a promoted list literal?
15:58:52 <haasn> copumpkin: '[a,b,c,d]
15:58:54 <copumpkin> do I need to use explicit cons with ticks?
15:58:55 <copumpkin> hmm
15:59:05 <haasn> copumpkin: a ': b ': c ': d ': '[]
15:59:32 <copumpkin> that's what I thought
15:59:43 <copumpkin> so say I have something of kind [[*]]
15:59:51 <clarissa> *promoted* list literal?
15:59:52 <copumpkin> how do I construct such a thing?
16:00:08 <copumpkin> clarissa: using DataKinds
16:00:12 <haasn> '[ '[Int, Char], '[(), Maybe Bool]]
16:00:17 <haasn> You need the space before ' sometimes
16:00:20 <copumpkin> ugh
16:00:24 <copumpkin> that's what was getting me :P
16:00:30 <copumpkin> gross, but I guess it looks like a char literal
16:00:31 <haasn> because '[' parses weirdly
16:00:38 <clarissa> *blinks* ah, apparently that's new since the last time I regularly used haskell
16:00:43 <Iceland_jack> ghci> :kind '[ '[] ]
16:00:43 <Iceland_jack> '[ '[] ] :: [[k]]
16:01:23 <Iceland_jack> lambdabot doesn't support DataKinds
16:01:33 <copumpkin> thanks!
16:09:01 <absence> does bytestring have something like chunksOf?
16:12:11 <enthropy> in an hsc file does (#peek Foo, x) y behaves like y.x or y->x?
16:12:21 <Eduard_Munteanu> @hoogle toChunks
16:12:22 <lambdabot> Data.ByteString.Lazy toChunks :: ByteString -> [ByteString]
16:12:22 <lambdabot> Data.ByteString.Lazy.Char8 toChunks :: ByteString -> [ByteString]
16:12:22 <lambdabot> Data.Text.Lazy toChunks :: Text -> [Text]
16:12:27 <Eduard_Munteanu> absence: ^
16:12:36 <enthropy> where we have   struct { Int x } Foo or something like that
16:12:54 <geekosaur> chunksOf is Data.List.Split though, not that?
16:14:04 <Eduard_Munteanu> Erm, I must be confusing it for that then.
16:14:10 <Eduard_Munteanu> @hoogle chunksOf
16:14:10 <lambdabot> Data.Text chunksOf :: Int -> Text -> [Text]
16:14:10 <lambdabot> Data.Text.Lazy chunksOf :: Int64 -> Text -> [Text]
16:14:28 <geekosaur> note lack of an item count in toChunks
16:15:02 <haasn> I think you'll have to manually unfold with “break”
16:15:03 <Eduard_Munteanu> Yeah, it merely converts a lazy BS to the underlying list of strict BSs.
16:15:19 <haasn> s/break/splitAt/
16:18:42 <absence> haasn: ah, that will work. thanks!
16:20:04 <orzo> what's the best way to determine if a hostname refers to the local machine?
16:21:24 <orzo> i could resolve the address and then check all the interfaces for a matching address, but then i need special handling for things like 127.0.1.1 and such
16:23:10 * hackagebot purescript 0.4.4 - PureScript Programming Language Compiler  http://hackage.haskell.org/package/purescript-0.4.4 (PhilFreeman)
16:26:22 <Eduard_Munteanu> orzo: what for?
16:27:02 <Eduard_Munteanu> It might be an XY problem.
16:27:07 <orzo> well, im writing an xmpp server and it needs to know the difference between messages sent to local users and to users elsewhere.  Very different handling
16:27:18 <orzo> so i get a jabber id of the form user@hostname
16:27:35 <orzo> and i need to react differently of hostname means me
16:27:48 <triliyn> "XY problem" is such a non-descriptive name
16:27:50 <Galactic> why do I get an error when I do:
16:27:51 <Galactic> solve :: Double -> Double
16:27:51 <Galactic> solve x = [e | i <- [0..9], let e = (x^i)/(fact i)]
16:27:55 <orzo> i woul drather support any possible name for the local box than force certain names
16:28:04 <Eduard_Munteanu> orzo: different in what way, and how do local clients interact with the server?
16:28:30 <Galactic> I think I know nvm.
16:28:30 <orzo> two local clients can bounce a chat message off the local server
16:28:48 <orzo> so the server routes mesage from client and then to other client
16:28:57 <orzo> if it werent to a local user, the routing would be to a remote peer
16:29:10 <geekosaur> :t (^)
16:29:10 <orzo> which is not a client, its a slightly differnet protocol, jabber server-to-server protocol
16:29:11 <lambdabot> (Integral b, Num a) => a -> b -> a
16:29:30 <levi> Are JIDs supposed to only use valid hostnames?
16:29:33 <geekosaur> mm, no
16:29:41 <geekosaur> oh, yes, depending on fact
16:30:06 <orzo> well regardless of what JIDS are "supposed" to do, my preference is to implement my own vision here, and i'd prefer to support any name
16:30:07 <levi> I.e., could you have a JID that referred to the local machine, but was not a name recognized by the host itself?
16:30:14 <Eduard_Munteanu> orzo: why not route them through the same server-to-server logic, having the server send the message to itself?
16:30:34 <Eduard_Munteanu> (more or less)
16:30:40 <eacameron> noob question: can I lift basic boolean ops to be higher-order functions so I can combine (a -> Bool) functions?
16:30:41 <levi> orzo: Well, you might supply a list of names in a configuration structure.
16:31:19 <Eduard_Munteanu> :t (all, any) -- eacameron, something like this?
16:31:20 <lambdabot> ((a -> Bool) -> [a] -> Bool, (a1 -> Bool) -> [a1] -> Bool)
16:31:35 <levi> At some point, you can figure out how to get the hostnames and such automatically, but you'll need something like that if you ever want to support names for the local machine that don't exist outside of the XMPP world.
16:31:52 <Galactic> ok I don't know...what is wrong with this:
16:31:54 <Galactic> fact 0 = 1
16:31:54 <Galactic> fact n = product [1..n]
16:31:54 <Galactic> solve :: Double -> Double
16:31:54 <Galactic> solve x = sum [e | i <- [0..9], let e = (x^i)/(fact i)]
16:32:16 <eacameron> Eduard_Munteanu: more like (a -> Bool) -> (a -> Bool) -> a -> Bool
16:32:49 <orzo> seems like there should be a simple way to test if an address would route to the local host
16:32:55 <eacameron> Eduard_Munteanu: f `or` g = \x -> f x || g x
16:32:57 <orzo> but i guess there isnt
16:33:09 <FreeFull> Galactic: Is this in a file?
16:33:17 <Galactic> FreeFull: yes
16:33:19 <Eduard_Munteanu> :t liftA2 (||) ?f ?g
16:33:20 <lambdabot> (Applicative f, ?f::f Bool, ?g::f Bool) => f Bool
16:33:36 <geekosaur> Galactic: without a type signature, the type of Fact is inferred as Integer -> Integer
16:33:39 <FreeFull> Galactic: What's the error you're getting?
16:33:40 <Eduard_Munteanu> :t liftA2 (||) (const True) (const False) $ ()
16:33:41 <geekosaur> you can't use (/) on an Integer
16:33:41 <lambdabot> Bool
16:33:47 <Eduard_Munteanu> > liftA2 (||) (const True) (const False) $ ()
16:33:48 <lambdabot>  True
16:33:52 <FreeFull> Ah, it's probably what geekosaur said
16:34:07 <Eduard_Munteanu> eacameron: ^
16:34:13 <sm> what is the "null monad" called ? I have a function of type CompletionFunc IO, but it doesn't do IO so I'd to replace that with some dummy monad
16:34:13 <Galactic> No instance for (Integral Double) arising from a use of `^'
16:34:14 <Galactic> Possible fix: add an instance declaration for (Integral Double)
16:34:14 <Galactic> In the first argument of `(/)', namely `(x ^ i)'
16:34:14 <Galactic> In the expression: (x ^ i) / (fact i)
16:34:14 <Galactic> In an equation for `e': e = (x ^ i) / (fact i)
16:34:22 <eacameron> Eduard_Munteanu: Interesting! yeah that's what I was looking for; what's the '?' stuff about?
16:34:27 <sm> s/I'd/I'd like/
16:34:47 <Eduard_Munteanu> eacameron: some trick to make something like a lambda and show the type of that thing in lambdabot
16:34:47 <alpounet> Galactic: then you want **
16:34:50 <pavonia> sm: Identity?
16:34:50 <alpounet> :t (**)
16:34:51 <lambdabot> Floating a => a -> a -> a
16:34:55 <enthropy> geekosaur: fact :: (Enum a, Eq a, Num a) => a -> a
16:35:10 <Eduard_Munteanu> eacameron: (it's actually a implicit parameter, but this is just a trick)
16:35:12 <enthropy> monomorphism restriction doesn't apply because fact has arguments
16:35:18 <geekosaur> ok, so the problem is the type of (^)
16:35:23 <haasn> alpounet: more likely he wants / fromIntegral (fact i)
16:35:27 <enthropy> yeah
16:35:28 <geekosaur> i is forced to be Integral, probably Integer
16:35:35 <Eduard_Munteanu> > (||) <$> const False <*> const True $ ()
16:35:36 <lambdabot>  True
16:35:38 <eacameron> Eduard_Munteanu: I vaguely remember reading about implicit parameters...I'll have to look into it more
16:35:42 <Galactic> alpounet: yeap that works thanks.
16:35:57 <Eduard_Munteanu> eacameron: you haven't missed much if you haven't looked into it yet :)
16:36:08 <sm> pavonia: that looks good - thanks!
16:36:12 <alpounet> haasn: well, i've just seen his error about ^ being used on Double's, i don't know about the more general problem he is solving, i'll let you advise on that :)
16:36:23 <eacameron> Eduard_Munteanu: the applicative style is cool, I think I'll use that!
16:36:32 <haasn> alpounet: he wrote x^i / fact i where fact :: Integer -> Integer
16:36:48 <alpounet> ah yeah
16:36:51 <haasn> alpounet: and i <- [0..9] which is perfectly compatible with Integer
16:37:02 <eacameron> Eduard_Munteanu: Is there a TH lib that allows the [| f x y z |] syntax? I know of some haskell preprocessor, but it seems easier with TH
16:37:02 <haasn> (in both places it's used)
16:37:14 <alpounet> will need to throw some fromIntegral I guess though
16:37:24 <enthropy> @hackage applicative-quoters
16:37:24 <lambdabot> http://hackage.haskell.org/package/applicative-quoters
16:37:59 <enthropy> eacameron: [i| f x y z |] may do what you want
16:38:06 <eacameron> enthropy: Awesome! I have been wanting this for so long
16:38:11 <Eduard_Munteanu> I don't know one in particular, but it does seem doable.
16:38:12 <haasn> oh, I think his “fact” is actually polymorphic, not Integer -> Integer. Maybe?
16:38:20 <enthropy> SHE may be better for that however
16:38:37 <haasn> Otherwise the error makes no sense. But it makes sense if it gets used as :: Double -> Double
16:38:57 <haasn> Integer -> Integer would still be the “righter” thing to do I think. so I would still go with x^i / fromIntegral (fact i)
16:39:25 <alpounet> yup, agreed
16:39:36 <alpounet> unless it's already Double all around the place
16:39:40 <enthropy> or skip the whole series and just make  solve = exp
16:40:44 <__pyon__> Is there any shorthand for "fmap ($ x)" ?
16:41:41 <Iceland_jack> @pl \x -> fmap ($ x)
16:41:41 <lambdabot> fmap . flip id
16:41:47 <haasn> notes: you can also move the definition of ‘e’ over to the answer itself, ie. solve x = sum [x^i / fact' i | i <- [0..9]]
16:41:50 <enthropy> > map length ["<*>pure x","($x)<$>","fmap($x)"]
16:41:51 <lambdabot>  [9,7,8]
16:42:45 <haasn> enthropy: neat, I didn't realize that's equal to exp
16:43:04 <enthropy> it's only close to it
16:43:04 <__pyon__> I was expecting there to be something like "($>) :: Functor f => a -> f (a -> b) -> f b". But, never mind. :-(
16:43:08 <Iceland_jack> > map length ["map length [\"<*>pure x\",\"($x)<$>\",\"fmap($x)\"]","length<$>[\"<*>pure x\",\"($x)<$>\",\"fmap($x)\"]"]
16:43:09 <lambdabot>  [45,43]
16:43:17 <FreeFull> :t flip id
16:43:18 <lambdabot> b -> (b -> c) -> c
16:43:23 <FreeFull> :t ($)
16:43:24 <lambdabot> (a -> b) -> a -> b
16:43:27 <Eduard_Munteanu> :t flip sequence
16:43:28 <lambdabot> b -> [b -> a] -> [a]
16:43:38 <Eduard_Munteanu> :t flip sequence ()
16:43:39 <lambdabot> [() -> a] -> [a]
16:44:06 <FreeFull> :t flip ap `asAppliedTo` [id]
16:44:07 <lambdabot> [a -> a] -> [(a -> a) -> b] -> [b]
16:44:07 <haasn> enthropy: getting closer as you increase the number of exponents (9)?
16:44:22 <enthropy> yeah
16:44:23 <FreeFull> :t flip ap `asAppliedTo` [3]
16:44:24 <lambdabot> Num a => [a] -> [a -> b] -> [b]
16:44:43 <haasn> ah, I see how it works out for x=1, since that's literally the definition of e
16:45:48 <haasn> :t (??) -- __pyon__
16:45:48 <lambdabot> Functor f => f (a -> b) -> a -> f b
16:45:53 <Galactic> is there a quick way to round a number to a certain number of places?
16:46:09 <__pyon__> haasn: Aaah, nice!
16:46:22 <__pyon__> haasn: Thanks. ;-)
16:46:29 <Eduard_Munteanu> Galactic: multiply by 10^n, round to integer, divide it back
16:46:29 <haasn> :t flip
16:46:30 <lambdabot> (a -> b -> c) -> b -> a -> c
16:46:36 <haasn> oh this one is non-generalized
16:46:58 <__pyon__> haasn: Wait, in what package is this (??) defined?
16:47:06 <Galactic> Eduard_Munteanu: Thanks
16:47:07 <haasn> __pyon__: lambdabot gets it from ‘lens’
16:47:17 <__pyon__> haasn: Ah, nice, thanks!
16:48:09 <anatok> For this code: http://lpaste.net/100810 trace shows two [1..10] depending on Poly/Mono signature and (NO)INLINE pragmas. Is there a robust (without core etc.) to evaluate [1..10] twice (use case: computationally cheap but takes a lot of memory to share)?
16:50:47 <haasn> enthropy: oh, I see, it's a taylor series
16:54:24 <schell> when using blaze.html5.attributes is there any way to append a class_ attribute?
16:55:43 <FreeFull> Seems like using the maclauren series to calculate e^x isn't the best idea
16:55:48 <zomg> schell: what do you mean?
16:55:49 <FreeFull> At least, in the naive way
16:56:58 <Eduard_Munteanu> Why calculate it explicitly in the first place?
16:57:05 <schell> zomg: well i've got an Html element i'm building that has a class attribute set using class_ and i'd like to conditionally add another class to it
16:57:23 <Eduard_Munteanu> As opposed to just doing e^x.
16:57:47 <schell> instead of just rewriting all the classes or keeping the classes in a list till the end i was hoping there's a combinator i haven't found yet
16:58:21 <Eduard_Munteanu> Floating-point stuff should do that far more easily.
16:58:51 <FreeFull> Simply using the floating constant for e doesn't guarantee an accurate result
16:59:14 <FreeFull> You tend to see an exp function rather than a provided e pretty often
16:59:34 <Eduard_Munteanu> Yeah, that's what I mean... don't you have an exp already?
16:59:46 <verement> > exp 1
16:59:47 <lambdabot>  2.718281828459045
17:00:09 <FreeFull> I'm not saying that making your own is useful
17:00:33 <Eduard_Munteanu> Besides, you can change bases easily if you have another exponential.
17:01:32 <Galactic> :i **
17:01:47 <Galactic> how can I execute commands?
17:02:05 <FreeFull> @info (**)
17:02:05 <lambdabot> (**)
17:02:13 <FreeFull> Oh, right, lambdabot doesn't do info
17:02:24 <Galactic> aa ok
17:02:25 <FreeFull> Galactic: :i (**)  in ghci
17:02:29 <Eduard_Munteanu> @src (**)
17:02:29 <lambdabot> Source not found. Have you considered trying to match wits with a rutabaga?
17:02:40 <Eduard_Munteanu> @src (+)
17:02:40 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
17:02:42 <FreeFull> Rutabagas are tasty
17:02:48 <Galactic> haha
17:03:08 <Galactic> :t sum
17:03:09 <lambdabot> Num a => [a] -> a
17:03:12 <FreeFull> > exp (3 * log 10)
17:03:14 <lambdabot>  1000.0000000000007
17:03:24 <FreeFull> Not the most accurate
17:03:43 <Eduard_Munteanu> :t exp (3 * log 10)
17:03:44 <lambdabot> Floating a => a
17:04:45 <haasn> > exp (3 * log 10) :: CReal
17:04:46 <lambdabot>  1000.0
17:04:54 <Galactic> round (21563.2656589848 * 10000) / 10000
17:05:07 <Eduard_Munteanu> > exp (3 * log 10) :: Double
17:05:08 <lambdabot>  1000.0000000000007
17:05:24 <Galactic> :t round
17:05:25 <lambdabot> (Integral b, RealFrac a) => a -> b
17:06:01 <Galactic> round $ 21545648.2156161 * 10000
17:06:14 <Galactic> round 2323.11656
17:06:16 <FreeFull> > 10 ** 3
17:06:17 <lambdabot>  1000.0
17:06:19 <__pyon__> > round $ 21545648.2156161 * 10000
17:06:21 <lambdabot>  215456482156
17:06:23 <haasn> :t multiplying
17:06:24 <lambdabot> Not in scope: `multiplying'
17:06:41 <Galactic> why did it worked for you?
17:06:56 <__pyon__> Galactic: notice the >
17:07:08 <Galactic> yea, what does that do?
17:07:27 <__pyon__> Galactic: it means that the remainder of the line must be evaluated by lambdabot
17:07:42 <Galactic> aa ok
17:07:55 <__pyon__> Galactic: the channel would be a mess if lambdabot tried to evaluate *every* line
17:08:18 <Galactic> > round $ 1564.313546 * 10000 / 10000
17:08:19 <lambdabot>  1564
17:08:58 <Galactic> > round (1564.313546 * 10000) / 10000
17:08:59 <lambdabot>  No instance for (GHC.Show.Show a0)
17:08:59 <lambdabot>    arising from a use of `M653123972932971377612397.show_M6531239729329713776...
17:08:59 <lambdabot>  The type variable `a0' is ambiguous
17:08:59 <lambdabot>  Possible fix: add a type signature that fixes these type variable(s)
17:08:59 <lambdabot>  Note: there are several potential instances:
17:09:19 <Galactic> why does that does not work?
17:09:40 <Eduard_Munteanu> :t round
17:09:41 <lambdabot> (Integral b, RealFrac a) => a -> b
17:09:51 <Eduard_Munteanu> :t (/)
17:09:52 <lambdabot> Fractional a => a -> a -> a
17:09:54 <__pyon__> Galactic: "x $ y" means "x (y)"
17:10:11 <__pyon__> Galactic: $ has low precedence and is right-associative
17:10:50 <__pyon__> Galactic: as a result "round $ 1564.313546 * 10000 / 10000" means "round (1564.313546 * 10000 / 10000)"
17:11:34 <Galactic> I see.
17:12:11 <Galactic> then how can I make this work... round (1564.313546 * 10000) / 10000
17:12:30 <cwvh> How can I use RecordWildCards in a situation like:   someRecord <- ioProducingRecord
17:12:50 <Iceland_jack>     RecordConstructor{..} <- ioProducingRecord
17:13:14 <__pyon__> Galactic: the result of round is an integral, and (/) requires fractional arguments
17:13:18 <Eduard_Munteanu> > round (1564.313546 * 10000 :: Double) / 10000
17:13:19 <lambdabot>  No instance for (GHC.Show.Show a0)
17:13:19 <lambdabot>    arising from a use of `M894540760249065867912420.show_M8945407602490658679...
17:13:19 <lambdabot>  The type variable `a0' is ambiguous
17:13:19 <lambdabot>  Possible fix: add a type signature that fixes these type variable(s)
17:13:19 <lambdabot>  Note: there are several potential instances:
17:13:26 <Eduard_Munteanu> Er.
17:13:48 <__pyon__> > round (1564.313546 * 10000) `div` 10000
17:13:48 <lambdabot>  1564
17:13:55 <cwvh> Iceland_jack: ah thanks
17:14:24 <Galactic> 1564 is no right
17:14:39 <__pyon__> Galactic: what result were you trying to get?
17:14:51 <Galactic> 1564.3135
17:15:30 <Galactic> basically round to 4 decimal places
17:15:39 <__pyon__> > fromIntegral (round (1564.313546 * 10000)) / 10000
17:15:40 <lambdabot>  1564.3135
17:15:46 <Galactic> wow
17:16:12 <Galactic> thanks
17:16:23 <haasn> sometimes I wonder if it would be worth giving a round' :: RealFrac a => a -> a -- somewhere
17:16:42 <Galactic> :t fromIntegral
17:16:43 <__pyon__> with a user-specified number of decimal places
17:16:43 <lambdabot> (Integral a, Num b) => a -> b
17:16:48 <haasn> multiplying 10000 %~ round'
17:16:56 <haasn> or fromIntegral . round I guess
17:17:24 <haasn> λ 134.123123123 & multiplying 10000 %~ fromIntegral . round
17:17:27 <haasn> 134.1231
17:19:20 <joelteon> :t multiplying
17:19:21 <lambdabot> Not in scope: `multiplying'
17:19:25 <joelteon> oh whoops
17:19:26 <enthropy> haasn: instance Integral Double :)
17:21:18 <Hafydd> instance Integrable (Double -> Double)
17:26:10 <Javran> can someone explain to me how to read this Coq proof? https://en.wikipedia.org/wiki/File:Coq_plus_comm_screenshot.jpg
17:31:05 <jroesch_> Javran: what part do you find confusing/hard to read? The whole thing?
17:31:40 <Dayne_Minor> http://i.imgur.com/zHl295b.jpg
17:31:48 <Dayne_Minor> You know you want one. Hi, this is Dayne Minor, General Manager of Freeman Toyota. And the 2014 Toyota Tundra Texas Edition, is here. It has everything you would want in a truck, and more. In Texas we use our trucks, and sometimes abuse them. And the Toyota Tundra has all the equipment and features you need in a truck. Check us out at www.freemantoyota.com or visit us in Hurst, Texas on Loop 820, just south of the Northeast Mall.
17:32:22 <Fuuzetsu> #haskell is the best place to market trucks
17:32:22 --- mode: ChanServ set +o geekosaur
17:32:30 --- mode: geekosaur set +b *!*Welles@162.216.0.*
17:32:30 --- kick: Dayne_Minor was kicked by geekosaur (Dayne_Minor)
17:32:38 --- mode: geekosaur set -o geekosaur
17:32:39 <Yaniel> definitely
17:32:40 <jle`> i have to wonder, is this an actually effective marketing strategy?
17:32:59 <geekosaur> effective doesn't really matter when it's free
17:33:02 <jle`> how many people near Hurst Texas are on freenode
17:33:07 <Fuuzetsu> Well, it made you think of trucks and Toyota so I guess?
17:33:11 <Eduard_Munteanu> Or inversely effective.
17:33:12 <Yaniel> doesn't sound like a very good marketing pitch in the first place
17:33:30 <jle`> yes but being interested in trucks and toyota only benefits them if i happen to live near Loop 820
17:33:53 <Javran> jroesch_: the whole thing, I don't even know which part is the "input" and which part "outputs"
17:33:53 <Fuuzetsu> Well, there's the ‘or’ there so you can visit their website.
17:34:20 <jle`> ah
17:34:57 * ij thinks doing that in some more job-y lang's channel would be more effective. Like python or php.
17:35:21 <jle`> ij: you can always /q him :P
17:35:28 <mirpa_> Is there some equivalent of Vector.findIndices in Repa?
17:37:27 <jroesch_>  You can look at it as the definition of a function and the right hand side is simply a anonymous function the represents the proof of the communativity of addition, the very final colon gives a type to the whole expression
17:37:52 <dagle> You can sell a car in #haskell, but only if it's functional?
17:38:01 * dagle hides.
17:38:14 <Yaniel> that's pretty much a requirement I think
17:38:17 <ij> oh, boy
17:38:32 <jroesch_> the overall expression has the type n m : nat, n + m = m + n
17:38:52 <mirpa_> at least they should advertise electric cars on #haskell
17:39:19 <jroesch_> the function definition provides a description of how to compute that these things are equal given any two nats
17:39:55 <pordan30> plus_comm :: forall n m :: nat, n + m = m + n is a theorem about natural numbers. because proofs are types, roughly speaking, the proof consists of a function that has the type of plus_comm. the proof is structured around an induction principle for the natural number type in coq. you can see the program that proves the base case: plus_n_0 :: forall n : n + 0 = 0 + n. if you recall the standard inductive proof of the commutative law
17:39:55 <pordan30>  on peano numerals, you should be able to work out the inductive case, although it relies on the induction principle for eq and other assorted functions. hope this helps!
17:40:11 <jroesch_> Javran: you will notice that the body begins with nat_ind which corresponds to induction on naturals
17:46:00 <dwcook> Propositions are types, proofs are values
17:46:33 <Javran> so the last line is saying for any given n.m :: nat, m + n = n + m holds?
17:46:34 <pordan30> right
17:46:39 <pordan30> my mistake
17:47:12 <Javran> ok, I got this part.
17:47:17 <jroesch_> Javran: yes and the way we prove that is via the function definition
17:47:22 <pordan30> forall n m :: nat, n + m = m + n is the type of plus_comm
17:47:32 <pordan30> so yes
17:47:41 <Javran> but what are these plus_n_xxxxx ?
17:47:59 <jroesch_> the pieces of the proof
17:48:27 <jroesch_> if you look at the type of nat_ind it becomes more clear
17:48:47 <Javran> `plus_n_xxx` are defined somewhere else?
17:48:56 <jroesch_> it should have a type like this: nat_ind : forall P : nat -> Prop, P O -> (forall n : nat, P n -> P (S n)) -> forall n : nat, P n
17:49:22 <jroesch_> plus_n_0 is most likely the proof that forall n: nat, n + 0 = n
17:49:27 <pordan30> plus_n_Sm :: forall n m :: nat, S (n + m) = n + S m is a technical lemma that lets you decompose the successor of a sum of numbers.
17:49:45 <Javran> i see
17:50:03 <Cale> That is sort of a weirdly-written proof (but a tactics-based proof would be impossible to really read from a screenshot).
17:50:05 <Javran> (plus_n_0 m) so this is the base case?
17:50:14 <jroesch_> yes
17:50:22 <pordan30> it's really helpful to load coqtop and step through the proof yourself, since then you can see how theorems are proven, how functions are constructed from tactics, and so on.
17:50:37 <jroesch_> Javran: nat ind says given a proposition you will provide me a proof of both the base case and the inductive case
17:51:45 <Javran> what about (fun n0 : nat => n0 + m = m + n0) ?
17:53:54 <pordan30> Recall that nat_ind : forall P : nat -> Prop, P 0 -> (forall n : nat, P n -> P (S n)) -> forall n : nat, P n. so fun n : nat => n + m = m + n is the first argument to nat_ind (P : nat -> Prop). the proof is showing that P holds for all n.
17:54:20 <pordan30> *nat_ind, that is, ...
17:56:33 <Cale> http://lpaste.net/100813
17:56:33 <Javran> ok, so nat_ind needs 3 arguments: hypothesis, proof for base case and also an inductive case?
17:56:44 <Cale> ^^ something closer to what you'd actually type into coq
17:57:13 <Cale> Though, this style of proof is terrible from a screenshot :)
17:57:22 <pordan30> the first argument is the proposition you are trying to prove (P : nat -> Prop is a proposition named P parameterized over nat), but otherwise yes.
17:57:37 <Cale> It's pretty hard to understand what's going on without coqide or similar to be able to step through and see what's going on.
17:57:51 <Cale> (i.e. see the goals and context at each step)
17:58:19 <Javran> ok, I'll bring up coqide and have a try
17:58:53 <Cale> Yeah, if you paste that in, and then press the down arrow button in the toolbar a bit, you'll see the steps take place
18:00:38 <Cale> and then at the end, you should be able to put in  Print plus_comm.  and step down over it, and it'll print the generated proof term
18:02:55 <Javran> thanks, that helps a lot
18:04:30 <Javran> Cale: what does the first "reflexivity" do? I see the first subgoal is "0 + 0 = 0", isn't reflexivity means something like "0 + 0 = 0 + 0"?
18:05:09 <Cale> It does a small amount of evaluation to try to get both sides to match
18:05:45 <Cale> (it will evaluate both sides as far as possible, but since they may have variables in them, that often won't be much, but in this case, 0 + 0 will indeed reduce to 0.
18:05:48 <Cale> )
18:05:54 <Javran> Cale: and the right hand side got evaluated in this case?
18:05:58 <Cale> yeah
18:06:19 <Cale> You can stick in a simpl before the reflexivity if it helps :)
18:07:50 <Cale> (especially in plus_n_Sm where it's a little less obvious than with the 0 + 0 = 0 case
18:07:51 <Cale> )
18:09:27 <zoku> least useful error message ever?
18:09:28 <zoku> cabal: Package accelerate-examples-0.15.0.0 can't be built on this system.
18:09:28 <zoku> can't be built why..?
18:11:16 <dcoutts_> zoku: try enabling one of the backends, using the flags
18:11:41 <dcoutts_> see the flags defined in the .cabal file
18:11:50 <zoku> Ah, thanks
18:12:36 <Javran> Cale: what just happened between "S n + 0 = S n" => "S (n + 0) = S n"?
18:12:54 <Cale> Reduction using the definition of +
18:14:39 <Cale> If you do "Print plus." you'll see the (slightly uglified) definition, it's defined by pattern matching on n.
18:15:26 <Cale> (its first argument)
18:17:07 <Cale> Javran: Because it's defined by pattern matching on the first argument, we get 0 + n = n and S n + m = S (n + m)  for free, but the other ones have to be proven as theorems.
18:17:20 <Cale> (i.e. my two lemmas there)
18:18:48 <Cale> Javran: and the reason we need those lemmas is that our base case and inductive case for commutativity are going to look like n + 0 = 0 + n and n + S m = S m + n respectively.
18:19:19 <Cale> (that's assuming we do induction on m, but it's similar even if we try induction on n)
18:20:13 <Cale> So, one side of those equations will reduce nicely because of how addition is defined, but the other, we'll need to tackle in a more subtle way.
18:20:24 <Javran> I see, plus (S n')  0 => S (plus n' 0)
18:21:26 <L8D> @pl f = fmap g where g s = s ++ "something ++ s ++ "asdf"
18:21:26 <lambdabot> (line 1, column 23):
18:21:26 <lambdabot> unexpected " "
18:21:26 <lambdabot> expecting operator
18:21:32 <L8D> @pl f = fmap g where g s = s ++ "something" ++ s ++ "asdf"
18:21:32 <lambdabot> (line 1, column 23):
18:21:32 <lambdabot> unexpected " "
18:21:32 <lambdabot> expecting operator
18:21:40 <Cale> L8D: @pl doesn't know about where
18:21:46 <L8D> wat
18:22:23 <L8D> @pl f s = s ++ "something" ++ s ++ "asdf"
18:22:23 <lambdabot> f = ap (++) (("something" ++) . (++ "asdf"))
18:22:41 <L8D> ap is what I'm looking
18:22:43 <L8D> for
18:22:53 <L8D> What module is it in?
18:22:54 <Cale> heh
18:22:56 <L8D> :t ap
18:22:57 <lambdabot> Monad m => m (a -> b) -> m a -> m b
18:22:59 <Cale> It's in Control.Monad
18:23:06 <Javran> thanks all of you, it makes sense now!
18:23:07 <Cale> But don't do that to your code :P
18:23:22 <L8D> Well, I'm doing something _like_ that.
18:23:29 <jle`> :t ap
18:23:30 <lambdabot> Monad m => m (a -> b) -> m a -> m b
18:23:33 <jle`> :t (<*>)
18:23:34 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
18:23:42 <L8D> wait
18:24:18 <L8D> Is a list a monad?
18:24:35 <joelteon> [] is a monad
18:24:37 <L8D> no
18:24:40 <L8D> I mean yes
18:24:41 <jle`> it is, but the ap here is referring to the function instance
18:24:45 <L8D> I said no to my own question
18:24:55 <L8D> Using a function as a monad?
18:25:02 <jle`> well as an applicative
18:25:04 <jle`> but yeah
18:25:21 <L8D> What is the type of ap in lamen terms?
18:25:32 <L8D> (a -> b) -> a -> b ?
18:25:33 <jle`> > let f = (++) <$> (++ "something") <*> (++ "asdf") in f "hello"
18:25:35 <lambdabot>  "hellosomethinghelloasdf"
18:25:38 <haasn> I swear, @pl seems a lot more popular lately. I've said this a few times before but I'm sure something's unusual
18:26:02 <jle`> ap takes a wrapped function and a wrapped value and applies it to the value, wrapped
18:26:10 <haasn> lots of people joining #haskell only to use @pl on some expression that looks like garbage afterwards (unsurprisingly)
18:26:13 <Cale> L8D: It's using the function monad there, m a = (e -> a)
18:26:26 <Javran> Reader monad
18:26:32 <jle`> > Just (*4) <*> Just 5
18:26:33 <lambdabot>  Just 20
18:26:45 <Cale> so ap's type specialises to (e -> (a -> b)) -> (e -> a) -> (e -> b)
18:26:47 <joelteon> You can't section type operators, right?
18:26:47 <L8D> interesting
18:26:49 <jle`> same instance as the reader monad, but without the meaningless newtype ;)
18:26:54 <haasn> joelteon: right
18:26:58 <joelteon> rats
18:27:18 <quchen>  @pl is either useless because it produces gibberish, or useless because it does something obvious. Not sure why it's even there.
18:27:36 <joelteon> @pl \f x y -> f x + f y
18:27:36 <lambdabot> flip =<< (((.) . (+)) .)
18:27:37 <haasn> joelteon: the only thing I could think of that would make sense is (x +) with PostfixOperators TypeOperators
18:27:45 <joelteon> oh, right
18:27:45 <cdh473_> good lord
18:27:49 <Hafydd_> It's sometimes useful.
18:27:50 <haasn> joelteon: expanding to (+) x, but (+ x) would not even make sense in the type system
18:27:54 <haasn> oh looks, more netsplits
18:28:00 <L8D> @pl f (x, y) = y * 2
18:28:00 <lambdabot> f = (2 *) . snd
18:28:04 <Cale> Those aren't netsplits
18:28:18 <Hafydd_> Internetsplits.
18:28:18 <haasn> oh, indeed they aren't. I just saw the member count rapidly dropping
18:28:24 <Cale> Those are clients being dropped
18:28:26 <haasn> there we go
18:28:33 <haasn> netsplits this time
18:28:34 <Cale> Now *those* are netsplits :)
18:28:35 <Cale> hehe
18:28:37 <cdh473_> netpirrouhettes or however it's spelled
18:29:05 <jle`> L8D: for the ((->) a) Applicative, <*> is ((->) a (b -> c)) -> ((->) a b) -> ((->) a c)
18:29:35 * Cale sets his IRC client not to print joins and parts for now
18:29:37 <jle`> or for infix (->), (a -> (b -> c)) -> (a -> b) -> (a -> c)
18:31:33 <jle`> and (<$>) is (b -> c) -> (((->) a b) -> ((->) a c))
18:31:45 <jle`> idk if that helps but try making all of the types match
18:31:51 <jle`> and then you'll see why/how it does what it does
18:32:04 <jle`> it's a little weird when a, b, and c are all [Char] though
18:32:57 <Cale> Javran: We can define our own notion of equality in Coq like this: http://lpaste.net/100816
18:33:42 <Cale> Javran: This is similar to a Haskell datatype declaration (especially in GADT style), only somewhat more general in terms of what's allowed.
18:34:40 <Cale> Here, we say that Equal A is a function which takes two parameters of type A (which is a Type), and produces a Type.
18:35:08 <Cale> and there's one constructor for that type: for each x of type A, we have that  refl x : Equal A x x
18:36:29 <Cale> Javran: Ah, this is actually a little different from Coq's definition, which is:
18:36:34 <Cale> Inductive eq (A : Type) (x : A) : A -> Prop :=  eq_refl : eq x x
18:38:21 <Cale> (don't worry too much about the difference between Prop and Type for now)
18:40:27 <SJSUNoob> Going through a tutorial and they're are having me run this: 20 :: Integer
18:40:31 <SJSUNoob> where the output is 20
18:40:35 <SJSUNoob> What exactly does that mean?
18:41:07 <Cale> SJSUNoob: Well, numbers evaluate to themselves.
18:41:12 <Javran> Cale: thanks for the information, though I think it'll take me some time to understand ..
18:41:26 <SJSUNoob> What does the :: mean?
18:41:32 <Cale> "has type"
18:41:38 <SJSUNoob> I've seen it used in the type command :type
18:41:45 <SJSUNoob> But I never saw it used as an expression you type
18:41:51 <Cale> You can specify that some subexpression is supposed to have a specific type using it
18:42:00 <SJSUNoob> Example?
18:42:26 <Cale> Well, there are cases where the type is ambiguous, and it becomes useful to specify exactly which type you want
18:42:33 <Cale> For instance, since we have:
18:42:35 <Cale> :t read
18:42:36 <lambdabot> Read a => String -> a
18:42:49 <Cale> The type of read's result can't be determined from its input
18:43:36 <Cale> It can only be determined from how it's used (and it's important for that type to be figured out, because it determines which parser is used)
18:43:56 <Cale> So, sometimes that becomes ambiguous, and it's nice to be able to say which type you really want:
18:44:03 <Cale> > read "47.34783" :: Double
18:44:05 <lambdabot>  47.34783
18:44:09 <Cale> > read "47" :: Double
18:44:10 <lambdabot>  47.0
18:44:16 <Cale> > read "47" :: Integer
18:44:17 <lambdabot>  47
18:44:22 <Cale> > read "[1,2,3]" :: Integer
18:44:23 <lambdabot>  *Exception: Prelude.read: no parse
18:44:26 <Cale> > read "[1,2,3]" :: [Integer]
18:44:27 <lambdabot>  [1,2,3]
18:44:30 <SJSUNoob> Oh, read it as a double
18:44:33 <SJSUNoob> Almost like casting
18:45:41 <Cale> Yeah, kind of, except that nothing is actually done to change or reinterpret the resulting data in any way, we're changing which type the expression is meant to have in the first place.
18:46:07 <Cale> and that's (statically) determining which parser gets applied to parse the string
18:46:15 <SJSUNoob> Hmmm... ok
18:46:24 <SJSUNoob> Didn't quite grasp all that but I understand the concept a bit
18:46:50 <Cale> You can't take something which is an Integer, for instance, and say :: Double
18:46:56 <Cale> > (5 :: Integer) :: Double
18:46:58 <lambdabot>  Couldn't match expected type `GHC.Types.Double'
18:46:58 <lambdabot>              with actual type `GHC.Integer.Type.Integer'
18:47:18 <Cale> The types actually have to match
18:47:26 <SJSUNoob> so your saying in that last expression is.... Try and treat this Integer as a Double
18:48:00 <Cale> I'm saying that the Integer *is* a Double, and the compiler calls me on it and says "no, it's not"
18:48:28 <Cale> > "hello" :: Integer -- similarly, this will fail
18:48:30 <lambdabot>  Couldn't match expected type `GHC.Integer.Type.Integer'
18:48:30 <lambdabot>              with actual type `[GHC.Types.Char]'
18:48:43 <Cale> > "hello" :: String -- this works (even if it's redundant)
18:48:45 <lambdabot>  "hello"
18:49:11 <Cale> Now, numeric literals like 5 are also polymorphic:
18:49:14 <Cale> :t 5
18:49:14 <lambdabot> Num a => a
18:49:28 <nisstyre> > 5 :: Integer
18:49:30 <lambdabot>  5
18:49:36 <Cale> 5 could represent a number of any type which is an instance of Num
18:49:39 <Cale> > 5 :: Double
18:49:40 <lambdabot>  5.0
18:49:41 <nisstyre> > (5 :: Int) + (4 :: Integer)
18:49:42 <lambdabot>  Couldn't match expected type `GHC.Types.Int'
18:49:42 <lambdabot>              with actual type `GHC.Integer.Type.Integer'
18:49:44 <Cale> > 5 :: Complex Double
18:49:45 <lambdabot>  5.0 :+ 0.0
18:49:51 <Cale> > 5 :: Rational
18:49:52 <lambdabot>  5 % 1
18:50:31 <jle`> it's like polymorphic functions... they can work on many types but when you actually use/call them they are just that specific type.
18:50:37 <Cale> If unspecified, the Haskell compiler will default to Integer, and failing that, Double
18:50:58 <SJSUNoob> OK
18:51:02 <nisstyre> > 3567 / 43 :: Rational
18:51:03 <lambdabot>  3567 % 43
18:51:21 <Cale> > 4 / 8 :: Rational
18:51:22 <lambdabot>  1 % 2
18:51:23 <jle`> + can work on any Number, that's like saying there is a + for Int, a + for Double, a + for Integer, etc.
18:51:48 <nisstyre> Rational is cool because it will give you it in lowest terms
18:52:08 <nisstyre> well, if you find that sort of thing cool
18:53:27 * hackagebot rainbow 0.10.2.0 - Print text to terminal with colors and effects  http://hackage.haskell.org/package/rainbow-0.10.2.0 (OmariNorman)
19:08:40 <thsutton> Someone wrote a blog post about setting up all the Haskell things on emacs recently. I can't find it in my history, anyone have a link?
19:12:13 <Galactic> if I have a file that only has two integers separated by a space how could I read each integer? readLn can read the whole line but how could I separate them?
19:12:43 <thsutton> words
19:12:45 <thsutton> ?
19:13:38 <jle`> > map (read :: String -> Int) . words $ "1 2"
19:13:40 <lambdabot>  [1,2]
19:14:36 <Galactic> :t words
19:14:37 <lambdabot> String -> [String]
19:20:00 <Platz> I think this is out of date http://www.haskell.org/haskellwiki/Emacs
19:20:11 <Platz> but probably can't go wrong with ghc-mod http://www.mew.org/~kazu/proj/ghc-mod/en/
19:23:25 <Galactic> :t mapM_
19:23:26 <lambdabot> Monad m => (a -> m b) -> [a] -> m ()
19:37:27 <ski> > (sequenceData . fromJust . lookupSequence) [0,1,3,6,10,15,21,28]
19:37:30 <lambdabot>  [0,1,3,6,10,15,21,28,36,45,55,66,78,91,105,120,136,153,171,190,210,231,253,2...
19:37:43 <ski> > (drop 30 . sequenceData . fromJust . lookupSequence) [0,1,3,6,10,15,21,28]
19:37:46 <lambdabot>  [465,496,528,561,595,630,666,703,741,780,820,861,903,946,990,1035,1081,1128,...
19:38:33 <ski> > (drop 50 . sequenceData . fromJust . lookupSequence) [0,1,3,6,10,15,21,28]
19:38:35 <lambdabot>  [1275,1326,1378,1431,0,1,3,6,10,15,21,28,36,45,46,48,51,55,60,66,73,81,90,10...
19:39:02 <copumpkin> ski: something fishy there
19:39:06 <copumpkin> can't put my finger on it though
19:59:10 <Galactic> f list = gcd' (abs (head list)) (abs (last list))
19:59:10 <Galactic>         where gcd' a 0 = a
19:59:10 <Galactic>         gcd' a b = g b (a `rem` b)
19:59:20 <Galactic> why do I get: parse error on input `gcd''
19:59:36 <Guest63374> hi Haskell Gurus!! I need some advice from you.., I am giving a talk about functional programming, especially on Haskell.., but the audience dont have any functional programming bg. how to rewire their brain from imperative to functional? i mean, i am looking for some intersting analogy to explain the difference between Imperative to functional
19:59:43 <Galactic> list is just [1,5]
20:02:40 <enthropy> Guest63374: does your audience know how to use a spreadsheet?
20:03:12 <Guest63374> <Enthropy> yes. they know
20:03:42 <Guest63374> how can i use it?
20:04:25 <khumba> Galactic, I think your third line needs to be indented more than your second line, since it's within the where clause.
20:04:38 <enthropy> cells on a spreadsheet are generally immutable, but they are calculated in terms of other cells
20:05:08 <enthropy> variables in haskell are like that
20:06:04 <Guest63374> I can take this examples when I talk about type systems.., but before getting into that, I need to make them to make a smooth transition on how to think as a functional programming
20:07:52 <enthropy> dunno how that analogy helps with type systems
20:08:08 <enthropy> there aren't very fancy types in a spreadsheet if you just look at one cell
20:08:25 <enthropy> anyways, I'm pretty sure that analogy was done by SPJ in http://www.youtube.com/watch?v=jLj1QV11o9g
20:08:36 * hackagebot happstack-fastcgi 0.1.5 - Happstack extension for use with FastCGI.  http://hackage.haskell.org/package/happstack-fastcgi-0.1.5 (tomberek)
20:10:22 <Galactic> khumba: I tried:
20:10:53 <Galactic> f l = gcd' (abs (head l)) (abs (last l))
20:10:53 <Galactic>         where gcd' 0 a = a
20:10:53 <Galactic>                 gcd' a b = gcd' b (a `rem` b)
20:11:04 <Galactic> but I get the same error
20:11:50 <Guest63374> <enthropy> You helped me!!
20:11:55 <Guest63374> Thanks
20:12:07 <enthropy> Galactic: you don't have the two gcd' aligned
20:12:55 <Galactic> even after they are aligned I get the same error
20:19:17 <haasn> Guest63374: explain the difference between imperative and declarative
20:19:32 <haasn> I think “functional” is a misused label
20:20:26 <khumba> Galactic, works for me when the two gcd' definitions are aligned (i.e. the latter two '='s are aligned).
20:22:56 <Galactic> khumba: hummm, in my case when I align them I get: parse error on input `='
20:24:28 <khumba>         where gcd' 0 a = a
20:24:29 <khumba>               gcd' a b = gcd' b (a `rem` b)
20:24:49 <khumba> I don't know what else to say :)
20:25:53 <Galactic> khumba: lol I copied what you typed and it worked...omg
20:25:55 <Galactic> wtf
20:26:24 <Galactic> what editor are you using?
20:30:10 <khumba> Heh.  Just emacs, and I originally copied what you typed here.  Maybe you ended up with some weird Unicode char in there somehow?
20:30:44 <Yaniel> random non-breaking spaces ftw
20:32:42 <Galactic> lol
20:33:47 <Yaniel> not kidding
20:34:00 <Yaniel> they screw up my code every now and then when coding on my laptop
20:34:48 <Yaniel> type fast and accidentally hold down shift or alt (not sure which) when pressing space -> bam, nbsp
20:35:19 <Yaniel> indistinguishable from a normal space except in xcode and a couple of other places
20:35:32 <Yaniel> until I try to compile
20:38:34 <Galactic> yea is frustrating
20:38:41 <khumba> Yeah, or something copied from a blog that decided it should be fancy spaces and hyphens for rendering code.
20:39:11 <Yaniel> always fun to play the guessing game with gcc
20:39:41 <Yaniel> "now which of these && or || clauses has the stray \x355 next to it"
20:40:19 <Yaniel> whatever the character code was
21:21:07 <Platz> "Haskell ... is the most advanced of the obsolete languages" — GJS
21:33:33 <Platz> actually this GJS guy is kind of weird
22:02:23 <Hafydd_> "actually"?
22:04:39 <vivaldi> hello. I have a question : I have a function that gets two lists : f l1 l2 . I am recursively iterating on l1 until it gets empty. I also need a full version of l1. How can I achieve that?
22:05:55 <vivaldi> I mean how can I keep a full version of l1 in somewhere in the code?
22:06:17 <shachaf> f l1 l2 = g l1 l2 where { g [] ys = ...l1...; g (x:xs) ys = ...l1... }
22:08:50 <Galactic> how does this work?  map fst $ iterate (\(a,b) -> (b, a+b)) (0,1)
22:09:51 <Cale> Galactic: Well, look at the result without the map fst
22:09:58 <Cale> > iterate (\(a,b) -> (b, a+b)) (0,1)
22:09:59 <lambdabot>  [(0,1),(1,1),(1,2),(2,3),(3,5),(5,8),(8,13),(13,21),(21,34),(34,55),(55,89),...
22:10:21 <Cale> Each pair is obtained from the last by applying the given function
22:10:41 <Cale> @src iterate
22:10:41 <lambdabot> iterate f x =  x : iterate f (f x)
22:12:17 <Galactic> humm, ok...what about the   (\(a,b) -> (a, a+b))  I know what it does but how does it work?
22:13:16 <Cale> Well, it's just the function which given a pair (a,b), produces the pair (b,a+b) (you had a typo there)
22:14:47 <Galactic> what is that called... a lamda expresion?
22:14:49 <Cale> So, it takes apart the pair that it's given into a and b, and then builds a new one
22:14:59 <Cale> Yeah, a lambda expression
22:15:18 <Cale> > (\(a,b) -> (b,a+b)) (5,10)
22:15:19 <lambdabot>  (10,15)
22:15:30 <Galactic> wow
22:16:28 <Galactic> so is the  (5, 10) part of the lambda expresion?
22:16:50 <Cale> no, that's what I provided as an argument to the function that the lambda expression built
22:17:21 <Cale> We could apply this function to a list of pairs:
22:17:27 <Galactic> oo I see
22:17:39 <Cale> > map (\(a,b) -> (b,a+b)) [(1,2),(3,4),(5,6),(7,8)]
22:17:40 <lambdabot>  [(2,3),(4,7),(6,11),(8,15)]
22:17:57 <vivaldi> @shachaf what do the dots do?
22:17:57 <lambdabot> Unknown command, try @list
22:18:20 <Cale> vivaldi: shachaf means that you will fill that part in
22:18:34 <Cale> vivaldi: and l1 is in scope there, so you can still use it
22:18:58 <Cale> ...l1... is meant to suggest some arbitrary bit of code which might mention l1, like you wanted to
22:19:22 <vivaldi> I see, thanks
22:19:37 <Cale> Galactic: we don't have to destructure pairs of course:
22:19:41 <Cale> > (\x -> x^2) 5
22:19:43 <lambdabot>  25
22:19:59 <Cale> Galactic: and there can be multiple arguments:
22:20:07 <Cale> > (\x y -> x^2 + y^2) 3 4
22:20:08 <lambdabot>  25
22:20:16 <Galactic> wow
22:20:44 <Cale> It's just a way of writing functions without having to give them names all the time
22:21:13 <Cale> It's often the case that you want a little function for something which isn't worth giving a name to.
22:21:28 <Galactic> yea
22:21:29 <Cale> Often as an argument to yet another function
22:21:49 <Cale> (like map or filter)
22:22:10 <Galactic> thanks for the help :)
22:24:55 <Galactic> > (\(a,b) -> (b, a+b)) (0,1)
22:24:57 <lambdabot>  (1,1)
22:25:37 <Galactic> > iterate (\(a,b) -> (b, a+b)) (0,1)
22:25:38 <lambdabot>  [(0,1),(1,1),(1,2),(2,3),(3,5),(5,8),(8,13),(13,21),(21,34),(34,55),(55,89),...
22:25:48 <Galactic> why is the first element different?
22:26:07 <Cale> The first element of iterate f x is always x
22:26:19 <Galactic> aaa ok
22:26:28 <Galactic> :t iterate
22:26:29 <lambdabot> (a -> a) -> a -> [a]
22:26:40 <Galactic> @src iterate
22:26:41 <lambdabot> iterate f x =  x : iterate f (f x)
22:26:41 <Cale> iterate f x = [x, f x, f (f x), f (f (f x)),...]
22:27:03 <Kneiva> > (\(a,b) -> (a, b, a+b)) (1,2)
22:27:04 <lambdabot>  (1,2,3)
22:27:44 <Galactic> is so "simple" but it fucking amazes me haha
22:28:22 <Nyyx> it's not so simple for other things, but it's still beautiful imo
22:42:55 <haasn> > iterate f x :: [Expr]
22:42:56 <lambdabot>  [x,f x,f (f x),f (f (f x)),f (f (f (f x))),f (f (f (f (f x)))),f (f (f (f (f...
22:54:48 <Galactic> is there a way to see how the functions like iterate are acutlly implemented in code?
22:55:16 <Galactic> actually*
22:55:30 <Hafydd> Galactic: you can look at the source code of your interpreter/compiler.
22:55:40 <Hafydd> Or you can look at the sample implementation in the Haskell report.
22:55:51 <Hafydd> @src iterate -- or use this
22:55:51 <lambdabot> Source not found. :(
22:55:54 <Hafydd> @src iterate
22:55:55 <lambdabot> iterate f x =  x : iterate f (f x)
22:56:26 <Galactic> but I am talking about the low level implementation.
22:56:31 <Hafydd> Although @src's suggestions seem to be arbitrary.
22:56:42 <Hafydd> What makes you think there's a "low-level implementation"?
22:56:48 <Galactic> is haskell written in C
22:56:57 <Galactic> part of it?
22:57:01 <Kneiva> haasn: from what module is that Expr from?
22:57:03 <Hafydd> Haskell is a language. It isn't written in anything.
22:57:46 <monochrom> the Haskell Report is written in English :)
22:57:52 <Hafydd> GHC, for example, is mostly written in Haskell. There might be some Prelude functions written in C.
22:58:01 <haasn> Kneiva: SimpleReflect
22:58:02 <Nyyx> the runtime is also written in C
22:58:09 <Kneiva> thanks
22:58:21 <haasn> Hafydd: does it still include bits written in perl?
22:58:36 <Hafydd> I don't know.
22:58:37 <haasn> or is that just for the compile process
22:58:47 <Galactic> so it does have C implementation
22:58:56 <haasn> parts of the RTS are also written in Cmm I think
22:59:11 <Nyyx> the runtime which does memory allocation and garbage collecting among other things is written in C
22:59:42 <Nyyx> the compiler itself is written in haskell with ffi bindings to platform system calls
23:17:16 <milfjord> tessier: ah. yes, of course
23:53:24 <no-n> what members of the RandomGen class are there but StdGen?
23:54:24 <no-n> or a more practical version of my question: when type-declaring functions that take gens should I use (RandomGen a) => a -> ... or StdGen -> ...?
23:58:57 <joelteon> there we go
23:59:54 <joelteon> @pl \f -> fmap (fmap f)
23:59:54 <lambdabot> fmap . fmap
