00:02:00 <johtso> jrmithdobbs, it seems to be just type constraints on the property itself
00:07:24 <shachaf> jrmithdobbs: Returning False is very different from guaranteeing the input won't be empty in the first place.
00:11:41 <tranma> has anyone had trouble with the bootstrap script for cabal-install recently? on ghc 7.6.2 (os x 10.9), I got this error http://pastebin.com/PFg9RWJf
00:13:40 <pavonia> Someone asked about a similar problem before
00:14:10 <pavonia> hhm, was is related to haddock? I don't recall
00:14:37 <Dementhor> Hi! I have a question: if I have a data declaration like " data MyType a = MyType [a] deriving (Show, Eq, Ord) " when I use function f :: MyType a -> Bool, f (MyType xs) = (xs == xs) why should I justify the constraint (Eq a) since MyType is deriving Eq. And other question can I say in data declaration data (Eq a, Ord a) => MyType a = MyType [a] deriving ... without GADT?  http://lpaste.net/100679
00:16:12 <pavonia> Dementhor: The derived Eq instance looks like "Eq a => Eq (MyType a)", so you still need the Eq constraint for the parameter type
00:17:31 <pavonia> Dementhor: For instance, if you replace "MyType [a]" by "MyType [IO a]" in the definition, GHC will refuse to derive an instance for Eq
00:18:53 <Dementhor> pavonia: And is there another way to say that instead of adding constraints to all functions? By this I mean if i want to use ord and eq in 10 (/all) functions should I say for each function (Eq a, Ord a) => ?
00:19:33 <pavonia> No good way, I think
00:19:54 <Dementhor> Ok, thanks for your help :)
00:20:02 <pavonia> no problem
00:20:13 <codygman> I'm unsure why this json won't parse. When I generate the json it looks exactly the same as my input data: http://lpaste.net/100680
00:20:33 <kazagistar> so I totally don't understand the magic behind "deriving", but it seems any class of the wrapped data should be something I can use "deriving" with, right? why not?
00:21:59 <johtso> hmm, what would be the best way to pattern match against a list with arbitrary order?
00:22:23 <adas1> johtso: arbitrary order or length?
00:23:00 <johtso> adas1, order, I have a list, and I've got the essence of it using nub, and I want to make sure that it is two elements of specific types, and I want to unpack the type
00:28:49 <joejev> I am wondering why I am getting a pattern overlap warning here, I am kind of sleepy:http://lpaste.net/100681
00:30:30 <adas1> > :t add
00:30:31 <lambdabot>  <hint>:1:1: parse error on input `:'
00:30:47 <adas1> :t (+)
00:30:48 <lambdabot> Num a => a -> a -> a
00:31:33 <adas1> > on (+) (+3) 1 10
00:31:34 <lambdabot>  17
00:32:24 * hackagebot LambdaHack 0.2.12 - A roguelike game engine in early and active development  http://hackage.haskell.org/package/LambdaHack-0.2.12 (MikolajKonarski)
00:32:26 * hackagebot Allure 0.4.12 - Near-future roguelike game in very early and active development  http://hackage.haskell.org/package/Allure-0.4.12 (MikolajKonarski)
00:37:54 <jle`> Dementhor: deriving Eq doesn't mean that MyType a is Eq
00:38:17 <jle`> for all a
00:38:20 <jle`> for ex
00:38:32 <jle`> *for example, what if you called f on MyType (something not Eq) ?
00:38:56 <jle`> how would f even behave?  you can't do xs == xs
00:40:08 <jle`> the only thing that makes sense would be to require that the a in MyType a (that you are using (==) on) is Eq
00:41:33 <jle`> kazagistar: you can use -XGeneralizedNewtypeDeriving
00:42:09 <jle`> that works for newtype's, which are just dumb wrappers over a single value
00:42:27 <jle`> but it doesn't make sense for arbitrary data/ADT's
00:43:00 <aleator_> Silly question, but I remember reading some article about implementing diff/merge generically for plain algebraic datatypes. Does anyone here remember name for such paper?
00:48:10 <Dementhor> jle: Ok, thanks for the info. I'll use type constraints for the functions since GADT is ugly IMHO.
00:48:57 <cebewee> Ã¼,i
00:50:01 <haasn> kazagistar: http://joyoftypes.blogspot.de/2012/08/generalizednewtypederiving-is.html
00:56:41 <apples> aleator_, the only thing i can think of is this: http://dlicata.web.wesleyan.edu/pubs/l13git/git.pdf
00:57:20 <codygman> Can anyone tell me why I'm getting this FromJSON instance error using GHC.Generics? http://lpaste.net/100682
01:02:46 <klrr2> :t join . sort
01:02:47 <lambdabot> Ord a => [[a]] -> [a]
01:02:57 <klrr2> :t join
01:02:58 <lambdabot> Monad m => m (m a) -> m a
01:03:35 <klrr2> :t join ((==) . sort)
01:03:36 <lambdabot> Ord a => [a] -> Bool
01:04:19 <klrr2> > (join ((==) . sort)) [1,2,3]
01:04:20 <lambdabot>  True
01:04:49 <klrr2> (join ((==) . sort)) [2,3,4]
01:04:51 <ion> > let isSorted xs = xs == sort xs in isSorted (1:0:repeat 2)
01:04:57 <lambdabot>  mueval: ExitFailure 1
01:04:57 <lambdabot>  mueval: Prelude.undefined
01:05:43 <kadoban> codygman: i'm no expert, but i think you still have to declare the FromJSON instance, don't you? you just don't have to give a definition of parseJSON or whatever it is
01:06:31 <klrr2> > (join ((==) . sort)) [1,4,3]
01:06:32 <lambdabot>  False
01:06:37 <codygman> kadoban: Duh... you are right
01:10:07 <haasn> > let isSorted (x:xs@(y:_)) = x <= y && isSorted xs; isSorted _ = False in isSorted (1:0:repeat 2)
01:10:08 <lambdabot>  False
01:22:55 <Fuuzetsu> tranma: see http://trac.haskell.org/haddock/ticket/284 ; it'd be great if you could provide any and all relevant information on the ticket
01:24:24 <mm_freak> hi everybody
01:24:59 <Fuuzetsu> salutations
01:25:06 <seksifemale> hi
01:25:24 <mm_freak> which widget GUI library is easy to set up on windows?  i'm inclined to use a web-based solution because of the difficulty to get stuff working there
01:25:45 <mm_freak> but at this point there is no nice FRP library that covers this =/
01:27:24 <Fuuzetsu> Nothing is easy to set up on Windows.
01:30:15 <codygman> Is there a better way of parsing this nested json? http://lpaste.net/100685
01:30:56 <mm_freak> codygman: looks nice to me
01:31:16 <mm_freak> if you want to write less code, use the TH helper
01:31:26 <codygman> mm_freak: Alright, I found this actually.... though not sure it's better: http://the-singleton.com/2012/02/parsing-nested-json-in-haskell-with-aeson/
01:32:27 <mm_freak> codygman: yeah, looks like the right approach
01:32:52 <mm_freak> if you consider JSON to be "locally flat", then just use the usual applicative style
01:32:58 <codygman> mm_freak: Mine or his? and okay
01:33:05 <mm_freak> codygman: both
01:33:34 <supki_> I tend to parse to Value and then use lens to get parts I really want
01:34:10 <klrr2> mm_freak: hey, will you be online later today?
01:34:23 <mm_freak> klrr2: i'm always online, just not on any channels =)
01:34:34 <mm_freak> klrr2: feel free to /query me, if i'm not here
01:35:10 <klrr2> okey :) i got some questipn regarding irc frp thingy but im in school atm
01:35:21 <mm_freak> sure
01:42:32 * hackagebot network-simple-sockaddr 0.1 - network-simple for resolved addresses  http://hackage.haskell.org/package/network-simple-sockaddr-0.1 (jdnavarro)
01:42:34 * hackagebot pipes-p2p 0.1 - P2P network nodes with pipes  http://hackage.haskell.org/package/pipes-p2p-0.1 (jdnavarro)
01:42:36 * hackagebot pipes-p2p-examples 0.1 - Examples using pipes-p2p  http://hackage.haskell.org/package/pipes-p2p-examples-0.1 (jdnavarro)
01:47:05 <merijn> klrr2: FWIW there's also lambdabot's @tell command that lets you store messages for someone until they're back online
01:48:05 <klrr2> oh, not the reason i used it above (i did since im on my phone), but that is surelu useful thanks!
01:48:31 <mm_freak> merijn: might take days or weeks until i read that
01:48:40 <mm_freak> it's better just to use /query in my case =)
01:48:59 <merijn> mm_freak: I'll remember that :p
01:49:11 <mm_freak> =)
01:49:15 <mm_freak> alright, bye everybody
01:54:43 <d3lxa> why does Data.Regex takes String as arguments :( Do I really need to (un)pack myself?
01:55:10 <d3lxa> *Text.Regex, these kind of modules shouldn't use Text if it's not using Text
01:57:33 * hackagebot pcre-utils 0.1.3 - Perl-like substitute and split for PCRE regexps.  http://hackage.haskell.org/package/pcre-utils-0.1.3 (SimonMarechal)
01:59:00 <zgredzik> good morning! has anyone tried out the examples from sodium package? have they been working properly?
01:59:17 <klrr2> d3lxa: perhapa Text.* is bot intended to be the aame as Data.Text.*
02:22:37 * hackagebot persistent-postgresql 1.3.0.2 - Backend for the persistent library using postgresql.  http://hackage.haskell.org/package/persistent-postgresql-1.3.0.2 (MichaelSnoyman)
02:35:39 <pharaun> any way to avoid requiring id = int column for persistent? i will be migrating from that schema but i have a old table schema that has a varchar as the primary key
02:45:08 <spacekitteh> ok so, if I understand the reflection package properly... I can use it to specify tolerances in numerical code without having to include the tolerance as a parameter in the function?
02:45:57 <d3lxa> why does shakespeare text doesn't support $forall, all these and even not _{} too bad :(
02:50:04 <shachaf> spacekitteh: Well, it's a type-class parameter rather than a value parameter.
02:52:40 * hackagebot chuchu 0.4.4 - Behaviour Driven Development like Cucumber for Haskell  http://hackage.haskell.org/package/chuchu-0.4.4 (FelipeLessa)
02:55:10 <zipper> Is it just me or is trying to read the chapter on concurrency and parallelism in real world haskell a bit of a blur immidiately after reading learn you a haskell?
02:55:49 <Maior> zipper: so, I actually read "bits of LYAH" -> P&CP -> RWH; it was a bit of a blur but still good
02:56:56 <spacekitteh> shachaf: is that saying yes i can or no i can't?
02:57:12 <zipper> I am looking at P&CP instead. I don't know why I can't get what's going on in RWH on parallelism and concurrency.
02:57:12 <merijn> zipper: tbh, I just read the Control.Concurrent docs after LYAH, assuming you've done concurrent programming in another language those docs plus the observation that haskell's threads are lightweight can get you quite far already
02:57:41 <zipper> I have not done concurrency or parallelism in another language.
02:57:54 <Maior> zipper: I confess to skimming over P&C in RWH having read P&CP
02:58:00 <shachaf> spacekitteh: The answer depends on the question.
02:58:15 <Maior> zipper: I've done it in lots of other languages and I _adore_ the P&CP explanations and handling
02:58:39 <zipper> So I guess I should read P&CP instead?
02:59:00 <merijn> zipper: Then I suspect your problem is really "parallel/concurrent programming is really confusing", rather than "parallel/concurrent programming IN HASKELL is confusing"
02:59:39 <spacekitteh> :v
02:59:39 <merijn> zipper: I don't remember how much P&CP goes into the basics of multithreadig, but I remember it was more in-depth than RWH, which I think assumes that the entire notion of multithreading is already "obvious"
02:59:40 <zipper> merijn: What can I do to fix that?
03:00:16 <shachaf> spacekitteh: What I mean is that I don't know what you're asking. So you should clarify.
03:00:20 <merijn> zipper: Lots of practice and losing your sanity is the usual approach to grokking concurrency :>
03:00:29 <zipper> spacekitteh: NIce nick. Attractive.
03:00:33 <Maior> merijn: but Haskell seems to make it so beautiful
03:00:47 <zipper> merijn: lol that's far from encouraging. :(
03:00:50 <merijn> zipper: tbh, concurrency in haskell is probably the least confusing kind you will encounter in any language
03:01:07 <zipper> It's not that confusing actually
03:01:27 <zipper> It's that the book starts using these types not having explained them.
03:01:37 <spacekitteh> zipper: attractive? o.O
03:01:51 <merijn> zipper: Do you have an example type?
03:02:01 <zipper> types like ThreadManager
03:02:40 <merijn> zipper: ThreadManager is defined in that chapter, it's not an existing type
03:03:04 <awestroke> how do I understand lenses?
03:03:15 <merijn> zipper: The page has "newtype ThreadManager = Mgr (MVar (M.Map ThreadId (MVar ThreadStatus)))"
03:03:15 <zipper> merijn: I saw no data TreadManager anywhere
03:03:37 <zipper> ok let me check
03:03:47 <merijn> zipper: 3rd code block after the heading "The main thread and waiting for other threads"
03:03:53 <zipper> They have defined it below
03:04:16 <zipper> but have used it in a diagram aboove it's definition
03:04:43 <zipper> s/diagram/code\ block/
03:04:56 <merijn> zipper: Yeah, tbh, that's a common (at least in my anecdotal experience) way to design haskell programs
03:05:12 <merijn> zipper: i.e. first write down some opaque type for handling something and worry later about how you implement it
03:05:54 <merijn> zipper: i.e. first you decide you want some ThreadManager and the following operations (see those type signatures) on it, then after you've written down the types you want, you figure out which datatype would make implementing those types easiest
03:06:17 <skypers_> hi
03:06:28 <zipper> hmmm not sure I saw it happening like that in LYAH
03:06:33 <skypers_> is there a solid haskell to javascript lib somewhere?
03:06:40 <skypers_> like emscripten?
03:07:06 <zipper> merijn: "<zipper> hmmm not sure I saw it happening like that in LYAH"
03:08:10 <merijn> zipper: Sure, but LYAH is more of a "let's figure out what this means" approach, which does show and tell. Whereas RWH chapters tend to be more "how do we construct a program for X?" narrative, i.e. first determine what you want, then implement it
03:10:12 <fredyr> skypers_: have you seen http://www.haskell.org/haskellwiki/The_JavaScript_Problem?
03:10:35 <zipper> merijn: Where can I get info on concurrency and parallelism?
03:11:05 <zipper> merijn: Since it seems it itself is a problem and not how RWH explins it.
03:11:12 <skypers_> fredyr: yeah
03:11:19 <skypers_> I think Iâm gonna just compile to LLVM
03:11:22 <skypers_> and use emscripten
03:13:59 <Iceland_jack> zipper: Check out Simon Marlow's book
03:14:35 <hyperthunk> zipper: what Iceland_jack said. It's well worth getting!
03:15:49 <zipper> Iceland_jack: I am reading it right now.
03:15:56 <zipper> Too bad it is not a small book.
03:16:19 <Iceland_jack> zipper: Concurrency and parallelism are not small topics
03:16:24 <zipper> Why can't one just read a blogpost and know everything? FML
03:16:58 <Maior> can't tell if trolling or not
03:17:23 <zipper> Maior: not trolling, wishful thinking.
03:18:28 <shiona> is curses + frp a sane idea?
03:18:39 <zipper> Thanks and bye
03:18:59 <Iceland_jack> I don't see why not
03:21:41 <shiona> I guess I would start by finding a suitable curses library, a suitable frp library and learning both of them?
03:22:31 <Iceland_jack> If you're not familiar with either then it may be a daunting task, but that sounds like a good plan :)
03:22:55 <shiona> I thought I would use it to learn both.
03:23:32 <shiona> frp doesn't seem too useful without some unexpected events (ui) and generic ncurses is so non-functional
03:23:40 <awestroke> why doesn't hoogle index lens functions like ?~
03:24:31 <shachaf> Hoogle only indexes a few packages.
03:24:35 <shachaf> Try Hayoo.
03:24:48 <shachaf> Or maybe you can add +lens to your query or something, I don't remember.
03:25:51 <awestroke> shachaf: ah, thanks.
03:26:34 <bahamas> why is this wrong? nub . sort [2,1]? nub expects a list and sort returns a list
03:26:45 <bergmark> fp complete has a good hoogle, but i forgot the url
03:26:49 <Maior> :t nub
03:26:52 <lambdabot> Eq a => [a] -> [a]
03:26:55 <Maior> :t sort
03:26:57 <lambdabot> Ord a => [a] -> [a]
03:26:59 <Iceland_jack> > (nub . sort) [2,1]
03:27:01 <lambdabot>  [1,2]
03:27:04 <shiona> is there a notation of the kind "import UI.NCurses (Event as CEvent)"
03:27:08 <Iceland_jack> bahamas: Just needed parentheses
03:27:13 <Iceland_jack> > nub (sort [2,1])
03:27:15 <lambdabot>  [1,2]
03:27:32 <bahamas> Iceland_jack: hm, I'm trying to understand why
03:27:36 <Iceland_jack> Your original version was parsed as follows
03:27:36 <Iceland_jack>     nub . (sort [2,1])
03:27:37 <bergmark> bahamas: association is wrong, nub . sort [2,1] = nub . (sort [2,1])
03:27:38 <awestroke> > nub.sort $ reverse [1..2]
03:27:39 <lambdabot>  [1,2]
03:28:11 <bergmark> sort [2,1] is not a function so you can't compose it with (.)
03:28:23 <Iceland_jack> benmachine: Function application binds the tightest
03:28:56 <bahamas> bergmark: so sort [2,1] returned a type that nub didn't expect? if I can put it that way
03:29:17 <Iceland_jack> bahamas: No, it returned a type that (.) didn't expect
03:29:53 <Iceland_jack> (.) expects two functions, (sort [2,1]) is not a function
03:30:26 <bahamas> Iceland_jack: oh, right
03:30:42 <Iceland_jack> bahamas: Just to drive the point home, when you see something like
03:30:42 <Iceland_jack>     a b * c d
03:30:42 <Iceland_jack> it gets parsed as
03:30:42 <Iceland_jack>     (a b)
03:30:48 <Iceland_jack>     (a b) * (c d)
03:30:56 <Iceland_jack> Ignore the penultimate line
03:32:19 <bahamas> Iceland_jack: actually I wanted to ask something about infix notation for functions, but I forgot what it was
03:32:32 <Iceland_jack> `this`?
03:33:10 <bahamas> Iceland_jack: yes
03:33:15 <Iceland_jack> What about it?
03:33:38 <Iceland_jack> > let plus = (+) in 1 `plus` 2 `plus` 3
03:33:40 <lambdabot>  6
03:34:46 <Taneb> > let foo = foo in (0$0`foo`)
03:34:47 <lambdabot>  The operator `foo' [infixl 9] of a section
03:34:47 <lambdabot>      must have lower precedence than that of the operand,
03:34:47 <lambdabot>        namely `GHC.Base.$' [infixr 0]
03:34:47 <lambdabot>      in the section: `0 $ 0 `foo`'
03:34:52 <Taneb> Hmm
03:35:29 <bahamas> Iceland_jack: so, when we write div 12 4, 12 is applied to div and a new function is returned. then 4 is applied to the returned function which returns a result. what is the order of application when writing 12 `div` 4?
03:36:04 <Iceland_jack> bahamas: (Normally you say âf is applied to xâ when you have âf xâ btw)
03:36:11 <Iceland_jack> It is exactly the same
03:36:28 <Iceland_jack> You can think of
03:36:28 <Iceland_jack>     12 `div` 4
03:36:28 <Iceland_jack> turning into
03:36:28 <Iceland_jack>     div 12 4
03:36:30 <bahamas> Iceland_jack: ah really. I understood that the argument is applied to the function
03:36:38 <Maior> bahamas: other way round
03:36:38 <bahamas> s/really./really?/
03:37:42 <ion> A hammer is applied to a nail. A subject is applied to an object. A function is applied to a value.
03:37:53 <Iceland_jack> bahamas: Think of it this way
03:37:54 <Iceland_jack>     4 * 10
03:37:54 <Iceland_jack> is the same as
03:37:54 <Iceland_jack>     (*) 4 10
03:38:04 <bahamas> yes, you are right. I read it incorrectly
03:38:17 <Iceland_jack>     15 / 8
03:38:17 <Iceland_jack> is the same as
03:38:17 <Iceland_jack>     (/) 15 8
03:38:17 <bahamas> Iceland_jack: yes, I understand this part
03:38:19 <Iceland_jack> Okay
03:39:01 <awestroke> > (* 5) . (* 3) . (* 8) $ 4
03:39:02 <lambdabot>  480
03:39:30 <Iceland_jack> bahamas: Does awestroke's example make some sense?
03:39:50 <Iceland_jack> Do you understand that notation? (called operator sections)
03:39:54 <ion> > (* 5) `fmap` (* 3) `fmap` (* 8) `asks` 4
03:39:55 <lambdabot>  480
03:40:16 <Iceland_jack> ion: Let's obfuscate things a little more shall we :)
03:40:25 <lattenwald> > :t asks
03:40:26 <lambdabot>  <hint>:1:1: parse error on input `:'
03:40:34 <Iceland_jack> @ty asks
03:40:36 <lambdabot> MonadReader r m => (r -> a) -> m a
03:40:46 <Iceland_jack> It just uses the reader monad
03:40:50 <bahamas> Iceland_jack: yeah, it's the same as the less readable (*3) ((*8) 4)
03:40:56 <ski> environment monad
03:41:06 * lattenwald nods
03:41:31 <Iceland_jack> bahamas: yes with a missing (* 5) :)
03:41:58 <bahamas> Iceland_jack: yeah, I was too lazy to write all the parentheses :)
03:42:03 <Iceland_jack> fair enough
03:42:23 <awestroke> > (5*) . (*5) . ((*) 5) . (\x -> 5*x) $ 5
03:42:25 <lambdabot>  3125
03:43:06 <bahamas> ok, I think it's safe to assume from this that the argument to composed functions is applied with $
03:43:10 <Iceland_jack> > length (replicateM_ 5 "hello")
03:43:11 <lambdabot>  3125
03:43:13 <bahamas> to avoid issues like the one I had
03:43:15 <awestroke> why have only one way to write a function when you can have a billion?
03:43:44 <bahamas> awestroke: to use less brain power for reading
03:44:05 <ion> bahamas: Or just parentheses.
03:44:19 <bahamas> ion: yes
03:45:49 <ion> bahamas: $ can make the structure of an expression much less obvious when skimming code.
03:46:26 <bahamas> btw, I hope lyah explains instances at some point, because I'm confused about what they are
03:46:38 <Iceland_jack> bahamas: Type class instances? It does
03:46:59 <bahamas> ion: oh? as I understood it, apply everything to the right of $ to the part on the left
03:47:15 <bahamas> Iceland_jack: the instances mentioned here http://www.haskell.org/ghc/docs/latest/html/libraries/base-4.6.0.1/Data-Char.html
03:47:23 <bahamas> I assume they are type class instances
03:47:32 <Iceland_jack> they are
03:47:41 <merijn> ion: I don't agree with that, unless you're referring to multiple $ in the same expression
03:47:59 <Iceland_jack> bahamas: when you see
03:47:59 <Iceland_jack>     instance Eq Char where ...
03:47:59 <Iceland_jack> it means that you can use (==) and (/=) on values of type Char
03:48:05 <Iceland_jack> that's all, simple right?
03:48:11 <Iceland_jack> > 'a' /= 'b'
03:48:13 <lambdabot>  True
03:49:17 <bahamas> Iceland_jack: that part is clear, but I don't understand to what instance is referring in this case? Eq or Char or something else?
03:49:20 <merijn> bahamas: It does, the first mention of typeclasses is in chapter 3 and then 8 has an in-depth explanation of how to define your own, etc.
03:49:35 <bahamas> merijn: ah. ok
03:49:37 <Iceland_jack> bahamas: I don't understand your question
03:49:39 <merijn> bahamas: It's saying that there is an instance of the Eq typeclass for the Char type
03:49:56 <Iceland_jack> It just says that the data type "Char" is an instance of the Eq type class
03:50:19 <bahamas> ah, ok. so "Char" is an instance of "Eq"
03:50:19 <merijn> bahamas: Typeclasses have little to nothing to do with the OO notion of classes and as such the notion of an instance is also very different from the OO notion of an instance
03:50:19 <Iceland_jack> Being an instance of the Eq type class means the operators (==) and (/=) work on it
03:50:40 <merijn> bahamas: Char *has* an instance for Eq
03:50:41 <Iceland_jack> banjiewen: That's right, also what merijn said: not OO classes
03:50:43 <bahamas> merijn: yep, something explained that, so I'm not trying to think of OO any more
03:51:25 <ion> bahamas: This may or may not be helpful: https://gist.github.com/ion1/7867056
03:51:33 <Iceland_jack> bahamas: You should be able to guess what some of those type classes do:
03:51:33 <Iceland_jack>     instance Ord Char where ...
03:51:33 <Iceland_jack> means that you can compare characters using (>), (<), (>=) etc.
03:51:39 <Iceland_jack> > 'a' < 'A'
03:51:41 <lambdabot>  False
03:51:41 <bahamas> merijn: Char has an instance? how does it have it? it has different instances for different type classes?
03:52:08 <merijn> bahamas: Unlike OO instances, typeclass instances are not tied to the datatype. To illustrate, when I have a class Foo and someone later implements a Bar interface, then Foo can't implement Bar without changing the code of Foo, right?
03:52:14 <Iceland_jack> bahamas: âHow does it have it?â It's defined as an instance for Char
03:52:18 <Iceland_jack> *instance of Eq
03:52:55 <bahamas> ion: it doesn't help unfortunately, because there is a lot of notation that I don't know
03:53:00 <merijn> bahamas: Typeclass instances are separate from the actual data, so if I have a type Foo and someone later implements a typeclass Bar (plus an instance of Bar for type Foo), things will work without needing to modify the definition of Foo
03:53:29 <ion> bahamas: I suppose it would be a good idea to continue reading LYAH.
03:53:54 <merijn> bahamas: So saying the type *is* an instance of Bar makes little sense, as the existence of a "Bar" instance is not intrinsically tied to the definition of the original type
03:54:09 <bahamas> merijn: ok. I understand
03:54:48 <bahamas> so instance Ord Char defines an istance of "Ord" for "Char"?
03:54:59 <ion> yes
03:55:07 <merijn> bahamas: Well, there is an actual implementation you need to provide too, but that's not shown in the docs
03:55:23 <Iceland_jack> and 'instance Show Char' defines a way to turn a Char into a String
03:55:26 <Iceland_jack> > show 'u'
03:55:27 <lambdabot>  "'u'"
03:55:28 <merijn> bahamas: You'd implement it as "instance Ord Char where {- define the functions of Ord here -}"
03:55:56 <Iceland_jack> bahamas: You should catch up on the fundamentals with LYAH, I believe it covers type classes quite early on
03:56:07 <kazagistar> bahamas: from the OOP perspective, a way to think about it is that you can "implement the interface" of the typeclass, which is what is called an instance of a typeclass
03:56:12 <bahamas> merijn: the functions being > < = and others
03:56:22 <merijn> bahamas: Indeed
03:56:32 <merijn> bahamas: Although some of them may have default implementations
03:56:34 <bahamas> Iceland_jack: yeah, I am. I'm at the chapter about modules
03:57:01 <merijn> bahamas: You can just gloss/skip that, it exists as a reference to acquaint you with the more commonly used modules, but doesn't explain all that much
03:57:10 <bahamas> I noticed
03:57:20 <ski> kazagistar : yes. except that you can also have a value (object) with type being an OO interface, but you can't have a value with type being a type class
03:57:29 <merijn> Well, the "making you own module" section is useful
03:57:53 <merijn> kazagistar: There are several differences between OO interfaces and typeclasses, though
03:58:24 <bahamas> ok, thanks guys for the explanations
03:58:53 <merijn> kazagistar: 1) "bool compare(Comparable a, Comparable b)" compares two (potentially different) Comparables, whereas "(==) :: Eq a => a -> a -> Bool" only compares two comparable things of the same type, this is hard to encode using interfaces
03:59:15 <merijn> kazagistar: 2) Interfaces can't have polymorphic values, like "maxBound :: Bounded a => a"
03:59:46 <merijn> kazagistar: 3) Typeclasses can be polymorphic in return values, like "read :: Read a => String -> a"
04:00:25 <merijn> And 4) Typeclasses can have multiple parameters, i.e. "class Convertable a b where convert :: a -> b"
04:00:49 <ski> merijn : 2) being a case of 3), yes ?
04:01:06 <merijn> ski: Kinda, maybe
04:01:25 <merijn> ski: I try to avoid subtly luring people into the "values are nullary functions!" trap
04:01:31 <ski> there's also some more or less unrelated strictness differences
04:01:54 <merijn> ski: So I don't like referring to "maxBound" as a return value
04:02:00 <kazagistar> merijn: why is that a "trap"?
04:02:13 <Iceland_jack> kazagistar: because they aren't :)
04:02:13 <merijn> kazagistar: Because it's not true
04:02:25 <merijn> @google conal everything is a function in haskell
04:02:28 <lambdabot> http://conal.net/blog/posts/everything-is-a-function-in-haskell
04:02:28 <lambdabot> Title: Conal Elliott Â» âEverything is a functionâ in Haskell?
04:02:38 <merijn> kazagistar: If you're interested, read that :)
04:02:44 <kazagistar> I am and I will
04:03:03 <ski> (merijn : strictly speaking, your "return values" there is vague, unless you mean the type of the return value of `inRange :: Ix a => (a,a) -> a -> Bool' is `a -> Bool')
04:03:33 <merijn> ski: Don't ruin my "simple" explanations! :p
04:04:31 <ski> just saying that if we want to use the vague term, then it seems to me it makes more sense to also include the case with an operation being applied zero times to a sequence of zero arguments
04:05:07 <ski> (perhaps one could argue against including the nullary case here. i'm interested in hearing any counter-arguments)
04:07:12 <ski> merijn : anyway, considering records being used for OO, i think it can make sense to have the fields/methods be non-strict, even in an otherwise strictly evaluated language
04:07:59 <merijn> ski: I don't remember having a discussion about that? But sure :p
04:08:56 <ski> iow `A minBound();' in `Bounded<A>' could be seen as a non-curried spelling of `minBound :: a' in `Bounded a'
04:10:00 <merijn> ski: Right, but that encourages thinking of "minBound" as a function, whereas minBound really is a value that can frequently be inlined so there's not even any class overhead
04:10:18 <ski> (i think in OCaml, you can have non-function-typed methods in an object, and they're still non-strictly evaluated (and OCaml typically curries most things (not constructors, though)))
04:10:36 <merijn> ski: So, I agree that you could model things like that, but I don't think it's a model is good for newbies to learn :)
04:10:55 * ski doesn't see what inlining has to do with it
04:11:07 <ski> (surely functions can be inlined as well ?)
04:11:24 <merijn> ski: Not with the way most of interfaces are implemented in OO
04:11:41 <merijn> ski: Or rather, you could inline the function call, but not the result
04:12:03 <ski> oh, but now you seem to be talking about implementation inheritence, which is something completely different, yes
04:12:06 <merijn> Whereas GHC can frequently just inline the actual value (if the type is monomorphic)
04:12:45 <merijn> Completely unrelated
04:13:01 <ski> hm, perhaps i misunderstand your last argument here
04:13:14 <ski> elaborate on the "inline the function call, but not the result" part ?
04:13:25 <merijn> Is their any literature on parallel functional graph processing? The wiki lists mostly papers on sequential functional graph processing
04:14:06 <merijn> ski: The design of many OO languages means that the A return type is dynamically dispatched at runtime, which means the compiler won't know which minBound() you're calling until runtime. Which means it can't inline the result
04:14:27 <merijn> ski: iow, with most OO implementations I'm aware of the compiler can't determine whether A is monomorphic
04:15:48 <merijn> There's the ana/cata/hylo bananas, lenses, envelopes and barbed wire paper, but that seems to mostly be algebraic proofs and no attention to how to parallelise this
04:16:35 <merijn> Or is the answer that I will have to go invent the field of paralle functional graph processing myself first?
04:16:41 <awestroke> what's a banana and how do I use it
04:16:49 <ion> FWIW, i added another example: equality. https://gist.github.com/ion1/7867056
04:17:56 <awestroke> createBananas :: Bananable a => a -> Banana a
04:21:07 <awestroke> does GHC perform any kind of automatic parallelization, for example splitting list mapping over multiple threads?
04:21:38 <prophile> awestroke: not to my knowledge, that would be counterproductive in many cases (for short lists)
04:21:53 <ski> lists generally are sequential in nature
04:22:36 <prophile> if you want to explicitly use parallel mapping you can do so with the 'parallel' package
04:22:46 <prophile> http://hackage.haskell.org/package/parallel
04:22:55 <awestroke> prophile: I looked it up, it's hard to grasp, will try again
04:23:44 <ski> @wiki GHC/Data Parallel Haskell
04:23:44 <lambdabot> http://www.haskell.org/haskellwiki/GHC/Data_Parallel_Haskell
04:24:05 <ski> prophile : ^ that might be interesting
04:24:21 <prophile> ski: ah yes
04:24:37 <merijn> awestroke: No, mostly because when it was tried the performance wasn't very good. There's work going into Data Parallel Haskell, though. And there's also the various things like Strategies and sparks for deterministic parallel code in haskell
04:24:39 <prophile> I remember watching an SPJ talk on the very same
04:25:20 <ski> awestroke : sorry, that ^ was meant for you
04:25:25 <merijn> awestroke: The paper I mentioned (with bananas, etc.) introduces a bunch of brackets with silly names to discuss algebraic properties of several recursion schemes and how to prove things about them
04:26:24 <merijn> But I'll take the silence as a hit that I will have to invent this field myself >.>
04:26:31 <prophile> http://eprints.eemcs.utwente.nl/7281/01/db-utwente-40501F46.pdf
04:27:01 <merijn> Fair warning, that paper is not for the faint of heart and those with odd syntax allergies
04:27:43 <prophile> or with allergies to poor typesetting ^.^
04:28:11 <merijn> prophile: I didn't notice at first, but ouch
04:28:16 <merijn> The kerning is terrible :(
04:28:34 <awestroke> ski: look very hacky in its current state..
04:29:04 <merijn> awestroke: It's research in progress, yes
04:29:32 * ski doesn't find the letters particularly bad
04:30:16 <merijn> ski: page 3, second line the "as" in ""upwards" as in anabolism"", for example
04:30:40 <merijn> Or the "he" in "then" in the first line of the catamorphism section
04:31:12 * ski isn't sure what the problem in those cases are
04:31:43 <merijn> The kerning is terrible, the letters are way to close
04:31:50 <awestroke> do I need to explicitly create a module and export all names to use them in ghci? I always have trouble using functions in my Main (implicit) module when doing :load file.hs in ghci
04:32:18 <merijn> awestroke: ":load" should load everything
04:32:21 <awestroke> or I think functions are fine, but not values
04:32:23 <merijn> awestroke: Shouldn't need a module
04:32:42 <merijn> awestroke: What's going wrong? (I have a suspicion already)
04:32:53 * hackagebot esqueleto 1.3.5 - Bare bones, type-safe EDSL for SQL queries on persistent backends.  http://hackage.haskell.org/package/esqueleto-1.3.5 (FelipeLessa)
04:33:42 <bahamas> I notice sometimes that function composition can be replaced with function application. is there any reason to prefer one over the other in general?
04:33:56 <merijn> bahamas: Yes, readability
04:34:06 <merijn> bahamas: i.e. go with whatever is more readable
04:34:11 <bahamas> merijn: which one increases it?
04:34:15 <bahamas> ah
04:34:18 <merijn> bahamas: Depends on context :)
04:34:26 <bahamas> merijn: got it.
04:34:31 * ski doesn't notice any particular problem with kerning in those two cases, neither in `gv', nor in `xpdf'
04:34:41 <bahamas> although this is subjective
04:34:52 <merijn> for example "concatMap f xs = concat (map f xs)" or "concatMap f = concat . map f"
04:34:59 <bahamas> I find some things that lyah says to be readable to be opposite and the other way around
04:35:18 <merijn> bahamas: What you find readable will evolve over time as you get more comfortable with haskell
04:35:33 <merijn> bahamas: I would guess complete newbies find the first more readable, but I would prefer the second
04:35:55 <bahamas> merijn: sure. for example, I would say concatMapf xs = concat $ map f xs right now
04:36:29 <ski> the second emphasizes `map :: (a -> b) -> ([a] -> [b])' seen as a transformation of functions, over `map :: (a -> b) -> [a] -> [b]' seen as taking a function and a list and producing a list
04:37:04 <ski> bahamas : don't fear the brackets. i would prefer either of merijn's two versions over than one with `$'
04:37:09 <bahamas> ski: indeed. the example that made me ask the question was using filter in the same way
04:37:32 <bahamas> ski: interesting. you're the second person who speaks against $
04:37:57 <ski> there are some cases where `$' is ok, but it's way overused (especially by newbies, it seems), imho
04:38:10 <merijn> bahamas: I'll increase confusion by prefering "concat $ map f xs" over "concat (map f xs)" :p
04:38:24 <bahamas> heh
04:39:08 <prophile> merijn: no love for concatMap then? :)
04:39:22 <ski> prophile : heh, that's not the point here :)
04:39:28 <merijn> Well, I'd prefer concatMap over any of them :p
04:39:31 <bahamas> prophile: that's how he started :)
04:39:36 <SLi> I did cabal init for an existing project (which builds), and when building get "Warning: This package indirectly depends on multiple versions of the same package. This is highly likely to cause a compile failure. package template-haskell-2.8.0.0 requires pretty-1.1.1.0; package GenericPretty-1.2.1 requires pretty-1.1.1.1". How do I survive this?
04:40:04 <merijn> SLi: Most likely by using a different version of GenericPretty
04:40:18 <bahamas> it's a shame that there is no access to documentation in the interpreter. it's very handy
04:40:21 <SLi> Doesn't hlint tell newbies to turn ()s into $?
04:40:30 <ski> in some cases, `$' is required (lest you end with lonesome ending brackets) because what follows starts with (usually) one of `\',`do',`case',`let'
04:40:30 <merijn> SLi: As TH is tied to GHC and you can't change it's version (and thus not change it's pretty dependency) without changing GHC versions
04:40:42 <SLi> merijn: hmm, ok.
04:40:44 <ski> SLi : possibly (except s/newbies //)
04:41:52 <awestroke> can anybody throw me a good trivial cpu-intensive function for benchmarking?
04:42:07 * ski has grown to prefer `(foo . bar x y . baz z) a' over `foo . bar x y . baz z $ a', for "short pipelines"
04:42:39 <SLi> Hmm, GenericPretty.cabal says only "base >= 3 && < 5, ghc-prim, pretty". Where does cabal get the idea it requires pretty-1.1.1.1?
04:42:55 <ski> awestroke : naive fibonacci seems to be popular
04:46:43 <tdammers> ski: isn't that more space-intensive than cpu-intensive?
04:46:56 <tdammers> ski: I'd expect at the very least you'd have to make it strict
04:47:02 <twomashi2> Hey all. Could someone take a quick look at an issue for me? I'm missing something here: http://stackoverflow.com/questions/22167069/haskell-making-snap-and-leveldb-play-nice
04:47:53 <ski> tdammers : wouldn't the natural formulation of it be strict enough ?
04:48:29 <tdammers> ski: in Haskell? I don't think so. I think it'd build up thunks exponentially.
04:49:03 <tdammers> fib 0 = 1; fib 1 = 1; fib n = fib (n - 1) + fib (n - 2)
04:49:03 <ski> @let nfib 0 = 0; nfib 1 = 1; nfib n = nfib (n-1) + nfib (n-2)
04:49:06 <lambdabot>  Defined.
04:49:27 <tdammers> the recursive case just creates two thunks
04:49:28 <ski> matching on `0' forces `n-1' and `n-2'
04:49:47 <tdammers> hmm
04:49:57 <ski> forcing the result in the recursive case forces the addition, which forces the recursive calls
04:52:59 <ski> there'd be some stack traffic, but probably not touching enough memory in comparision with the number of calls, and additions
04:53:29 <tdammers> I'd expect it to blow the stack eventually
04:54:25 <ski> the maximum stack depth should be proportional to the input number, since there's no delayed computation, no ?
04:54:36 <twomashi2> if you call liftIO, how do you run something in the previous monad context?
04:54:49 <merijn> twomashi2: How do you mean?
04:55:26 <twomashi2> if I have maybeT IO.. I can call liftIO $ print "hi"... but from inside the call to liftIO can I run something in the context of the maybeT
04:58:02 <ski> twomashi2 : you could use `runMaybeT' inside ..
04:58:13 <b80905> how do you generate a random number in haskell?
04:58:20 <ski> @type random
04:58:22 <lambdabot> (RandomGen g, Random a) => g -> (a, g)
04:58:23 <ski> @type randomIO
04:58:24 <lambdabot> Random a => IO a
04:58:37 <twomashi2> ski: in my scenario that doesnt help :/ if you could take a look I'd appreciate it... http://stackoverflow.com/questions/22167069/haskell-making-snap-and-leveldb-play-nice
04:58:40 <ski> @type randoms
04:58:41 <lambdabot> (RandomGen g, Random a) => g -> [a]
04:58:54 <ski> @type newStdGen
04:58:55 <lambdabot> IO StdGen
04:59:21 <twomashi2> I have to call liftIO from within my MonadResource to run snap, but then I need to get back to my MonadResource to query the database
04:59:26 <b80905> ski: can you give me an example?
04:59:42 <ski> b80905 : for the basic idea, you start from some given pseudo-random bits generator state
05:00:32 <ski> b80905 : if you're in `IO', you can use the shorthand `randomIO' (and `randomRIO' for random values in a particular range)
05:01:36 <ski> b80905 : otherwise, you typically use `newStdGen' to get a `StdGen' (which is an instance of class `RandomGen'), and then you pass that to whatever function wants to use `random' or `randoms' (or `randomR
05:01:40 <ski> ')
05:02:24 <ski> b80905 : `random' will give you a pseudo-randomly generated value, and a new generator state, which you're supposed to use for the next random generation operation
05:02:51 <ski> b80905 : `randoms' will give you an infinite list of pseudo-randomly generated values, from which you can take as many as you need
05:03:33 <ski> b80905 : in both cases will you need to pass around something, either the generator state, or the infinite supply of pseudo-random values, to all places needing access to it
05:03:39 <ski> this can be hidden inside a state monad
05:05:09 <ski> > replicateM 4 (state (randomR (-9,9))) `evalState` mkStdGen 1234
05:05:10 <zgredzik> I'm having trouble installing ghcjs, I've downloaded the contents of github.com/ghcjs/ghcjs.git, but when running `cabal install` on it I end up with http://bpaste.net/show/mEXJPBTqRGgdBHYhCua3/ and when installing vector it fails with http://bpaste.net/show/nze0ezTY7awOQygQI6rX/ (using cabal 1.16 and ghc 7.9) - can anyone help?
05:05:10 <lambdabot>  [8,-5,-3,5]
05:05:14 <ski> > replicateM 20 (state (randomR (-9,9))) `evalState` mkStdGen 1234
05:05:15 <lambdabot>  [8,-5,-3,5,4,-2,2,9,-6,1,5,-1,-5,-3,-5,1,2,-3,-2,7]
05:05:19 <ski> b80905 : that
05:06:03 <ski> 's two examples of using `randomR' -- here i used `mkStdGen' to provide an initial generator state. in a real program, you should use `newStdGen' or something similar (but i can't do that in lambdabot, since it requires `IO')
05:06:31 <ski> @type do gen <- newStdGen; return (replicateM 20 (state (randomR (-9,9))) `evalState` gen)
05:06:33 <lambdabot> (Num a, Random a) => IO [a]
05:06:45 <ski> b80905 : is how one could do it with `newStdGen'
05:07:01 <ski> b80905 : does that help ?
05:07:23 <b80905> ski: thanks very much
05:08:23 <ski> b80905 : i used `replicateM' in the state monad to run `randomR (-9,9)' some number of times, implicitly threading the output pseudo-random generator state from one generation as input for the next
05:09:19 <ski> b80905 : instead, you can use `randomRs', if you want an infinite list (good for when you don't know beforehand how many random values you want -- unless you're in `IO', since then you can just use `randomIO' and `randomRIO' when you need it)
05:09:42 <ski> @type do gen <- newStdGen; return (randomRs (-9,9) gen)
05:09:44 <lambdabot> (Num a, Random a) => IO [a]
05:09:59 <ski> > randomRs (-9,9) (mkStdGen 1234)
05:10:01 <lambdabot>  [8,-5,-3,5,4,-2,2,9,-6,1,5,-1,-5,-3,-5,1,2,-3,-2,7,5,1,5,8,2,2,-3,-2,0,-2,-8...
05:11:03 <ski> b80905 : that shows how one can use `randomRs' (but you'll still need then to pass the infinite list around to the places that need pseudo-randomly generated values, each place picking off as many as it needs, returning the rest of them for later consumption by other parts)
05:11:13 <ski> b80905 : also, there's a splitting operation
05:11:29 <ski> @type System.Random.split
05:11:30 <lambdabot> RandomGen g => g -> (g, g)
05:12:47 <ski> b80905 : this can be used to *split* a pseudo-random generator state in two. this is good if you have two subcomputations that both need to consume random sources of bits, but where you don't want to have to wait for one of the two computations to finish (by returning the "left-over" state) before the other can really start
05:12:57 <awestroke> what am I doing wrong? https://gist.github.com/awestroke/bfc63344f5b3d521d48a
05:15:34 <ski> awestroke : i don't know very much about the parallel stuff, but are you sure `pf x acc = par y (y : acc) where y = f x' wouldn't be better for `par_map' ?
05:16:52 <awestroke> ski: I'll try, thanks
05:17:45 <ski> awestroke : at least i suppose the intent was to spawn off a spark for each application of `f' to the elements of the input list
05:18:06 <asterblaster> Hello, I have problem with this StateT code
05:18:07 <asterblaster> http://lpaste.net/100688
05:18:08 <awestroke> ski: yes, exactly
05:18:14 <asterblaster> uncomment line 14
05:18:30 <asterblaster> and I'm getting error that says, I should send a bug report
05:18:44 <asterblaster> it's my understanding that this is correct, am I missing something?
05:20:09 <ski> asterblaster : `StateT s IO' is not `State s'
05:20:34 <asterblaster> ski: so i should change types of push and pop?
05:21:06 <bahamas> can anyone explain what I'm doing wrong here http://lpaste.net/100689?
05:21:13 <asterblaster> ski: don't get me wrong, i want to use both IO and State so this is why I'm having StateT
05:21:48 <prophile> asterblaster: maybe make push and pop work on MonadState then
05:21:50 <ski>   push :: Monad m => a -> StateT [a] m ()
05:21:57 <ski>   pop :: Monad m => StateT [a] m a
05:22:06 <ski> asterblaster : should be enough
05:22:20 <ski> (if you want to, you can remove `Monad m => ', and replace `m' with `IO')
05:22:28 <prophile> or push :: MonadState [a] m => a -> m ()
05:22:40 <Dodek> the fact that he uses State incorrectly isn't the point here
05:22:40 <prophile> pop :: MonadState [a] m => m a
05:22:47 <Dodek>     The function `lift'ghc: panic! (the 'impossible' happened)
05:22:47 <Dodek>   (GHC version 7.6.3 for x86_64-unknown-linux):
05:22:47 <Dodek>         kindFunResult ghc-prim:GHC.Prim.*{(w) tc 34d}
05:22:54 <Dodek> this is what i get when i try to compile asterblaster's code
05:22:56 <ski> yes, prophile's versions are yet more general
05:23:17 <prophile> ...
05:23:21 <prophile> okay, that's interesting
05:23:44 <Cale> bahamas: If find is successful, it will produce Just x, where x is the element of the list which satisfies the condition you gave
05:23:57 <Cale> bahamas: In this case, that x will be a pair, because your list is a list of pairs
05:24:38 * prophile backs away slowly
05:24:48 <asterblaster> cool...
05:24:50 <Cale> bahamas: But the type signature of your function says that it should be a value of type v, not (k,v), and the compiler won't allow v = (k,v) = (k,(k,v)) = ...
05:25:09 <prophile> asterblaster: your types are wrong, see the things ski and I said earlier
05:25:24 <prophile> although GHC should probably show a useful error message in that case rather than crashing
05:25:46 <Cale> bahamas: So the answer is that you need to apply snd to that result. One way is just to apply fmap snd
05:25:52 <ski> Dodek : with `lift push c' or `lift (push c)' ?
05:26:02 <Dodek> lift push c, no parens
05:26:06 <asterblaster> prophile: it still gives an error
05:26:11 <asterblaster> after fixing types
05:26:13 <Cale> Or if that's not comfortable, you could use case to match.
05:26:23 <Dodek> http://wklej.org/id/1289509/
05:26:27 <Dodek> this is what i'm using
05:26:28 <ski> asterblaster : you need more brackets
05:26:31 <prophile> I'll leave this to people who are smarter than me
05:26:33 <Cale> bahamas: I don't think you need a special case for the empty list here, btw
05:26:36 <Dodek> compile with mtl, not monads-tf
05:27:14 <asterblaster> ski: now it works, but it dosen't seem to be correct
05:27:19 <ski> asterblaster : iow, as i hinted at above, you want `lift (push c)'
05:27:31 <ski> or, hmm
05:27:35 <ski> actually you don't
05:27:47 <asterblaster> ski after setting types after yours advice, it works without the lift
05:28:11 <ski> asterblaster : `lift' here is for lifting an `IO'-action into an `StateT s IO'-action (where `s' happens to be `[a]' in your case)
05:28:31 <asterblaster> ski: http://lpaste.net/100690
05:28:45 <ski> asterblaster : since `push c' and `pop' are already `StateT s IO'-action, you don't need to, and actually, shouldn't use `lift' here
05:28:58 <asterblaster> ski, yep, and after setting type for StateT instead of State it's not neccessety anymore to use lift with push/pop
05:29:02 <asterblaster> :)
05:29:40 <ski> asterblaster : also, for `IO'-actions, it might be nicer to use `liftIO' instead. it'll do the same, but will still continue to work if you add any more levels on top of the base `IO' level
05:29:55 <asterblaster> ski: ok, thanks :)
05:30:41 <ski> asterblaster : btw, your `pop' will halt the program if the stack is empty -- you may or may not want to do something about that
05:31:15 <asterblaster> ski, yep i know, it's just an exercise :)
05:32:37 <bahamas> Cale: ah, because I'm using find
05:32:57 <awestroke> I know it's using multiple threads (or sparks or w/e) now, but I still get zero performance improvement... https://gist.github.com/awestroke/bfc63344f5b3d521d48a
05:33:01 <bahamas> Cale: yeah, I actually tried to implement the function by myself but also took a peak a how lyah does it
05:33:16 <bahamas> that's where the special case for empty list comes from
05:33:56 <Cale> bahamas: Right, you could also tidily implement findKey in a recursive way
05:34:03 <Cale> (and for that you'd need the base case)
05:34:41 <bahamas> Cale: yeah, that's how lyah does it and it uses Just v, which I didn't know about
05:37:23 <bahamas> Cale: thanks
05:37:35 <Cale> no problem :)
05:37:36 <Walther> Hmm. Why isn't there highlighting in ghci? I only found this http://www.haskell.org/haskellwiki/GHCi_in_colour but it seems only hypothetical pondering and a proof-of-concept thingy hacked together with sed
05:38:34 <Cale> Walther: You could in fact do better than sed ever could, because ghc knows which things are types, and which things are data constructors, for example
05:39:12 <Walther> Cale: exactly, i was thinking this should be implementable in a way more ...eh, "correct" way
05:40:18 <Walther> just because something is CLI doesn't mean it has to be ugly ;) Even just using ansi codes to get the terminal's set 16 colors used would be better than no color at all
05:41:16 <Cale> Idris does it, and so does Agda (though for Agda, it's via Emacs, the Agda executable tells Emacs what things are so that it can colour them properly, I've never tried the commandline tools there)
05:47:00 <skrio> I've been working on an algorithm problem for some time now, is there any chance I could bend your ears for a bit?
05:47:19 <Cale> go for it
05:47:42 <skrio> I'm trying to find the longest path through an acyclic directed graph
05:48:25 <skrio> I've come close, but always end up with edge cases where it fails
05:48:46 <Cale> Longest path which doesn't reuse any given edge?
05:48:53 <Cale> Or which doesn't reuse any given vertex?
05:49:32 <skrio> It can't reuse any since the graph must be acyclic, and being able to reuse vertexes or edges would make it cyclic
05:49:51 <Cale> oh, I somehow missed the word acyclic :)
05:49:57 <Cale> okay
05:50:42 * ski ponders graphs of infix operators
05:50:53 <skrio> I've defined a graph as a collection of vertices and edges
05:51:26 <Cale> What I'd do is to find all the vertices with no incoming edges and label them all 0. Then iteratively label all the neighbours of vertices labelled n with n+1 until there are no vertices left.
05:52:20 <skrio> I've tried it, but never managed to get a working solution since I'm very new to haskell (and functional programming whatsoever)
05:52:35 <companion_cube> if it's acyclic, you can try a shortest path algorithm with negative edge weights?
05:52:39 <Cale> Well, it might be best to include in each label a predecessor, just so that you can more easily collect up the path at the end.
05:52:53 <magneticduck> companion_cube: that's what cale's idea essentially is
05:53:36 <Cale> skrio: Are you using Data.Map at all? :)
05:53:40 <magneticduck> silly syntax question: is there a cooler way to write (flip (-) 1)?
05:53:45 <skrio> No, how would that help?
05:53:48 <Cale> subtract 1
05:53:52 <ski> magneticduck : `subtract 1' ?
05:54:00 <magneticduck> oh cool
05:54:01 <magneticduck> that works
05:54:10 <Cale> skrio: Well, it's just a useful data structure to store sets of key/value pairings
05:54:24 <Cale> skrio: For instance, the labels
05:55:30 <skrio> Yeah, looked it up on hoogle now :) It seems like maybe my strategy for representing the graph might've been somewhat ... how shall i say.. terrible?
05:55:41 <Cale> hehe
05:55:45 <eacameron> what is the most generic form of "filter"?
05:56:00 <magneticduck> boy, my life as a programmer got a LOT cooler after I discovered syntastic and vim folding x)
05:56:04 <magneticduck> how did I live without this
05:56:09 <dwcook> eacameron, foldr. Just kidding, what do you mean "most generic"?
05:56:23 <companion_cube> what is the most generic genericity?
05:56:40 <dwcook> (You can of course go more generic than foldr)
05:56:46 <eacameron> :t filter
05:56:48 <lambdabot> (a -> Bool) -> [a] -> [a]
05:56:55 <magneticduck> eacameron: does http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Foldable.html help?
05:57:27 <magneticduck> you can define a filter function for any foldable data type...
05:57:38 <eacameron> right, but does such a def already exist?
05:57:39 <magneticduck> and I don't think there are data types that are "filterable" yet aren't foldable
05:57:46 <magneticduck> eacameron: probably!
05:58:16 <magneticduck> eacameron: http://www.haskell.org/hoogle/?hoogle=%28Foldable+a%29+%3D%3E+a+b+-%3E+%28b+-%3E+Bool%29+-%3E+a+b
05:58:25 <magneticduck> learn to love Hoogle
05:58:43 <magneticduck> well Find isn't really a filter
05:58:48 <magneticduck> s/F/f
05:59:04 <tdammers> find is more like a scripting language in its own right :x
05:59:16 <magneticduck> well, of course, there isn't always a good way of presenting the data in the foldable data structure
05:59:29 <magneticduck> you might not want to use the data structure in question to hold the filtered data
05:59:43 <magneticduck> ...I guess. Or someting
05:59:46 <magneticduck> eacameron: what's it mean ta you?
06:00:09 <dwcook> It might not be possible to write filter :: (Foldable f) => (a -> Bool) -> f a -> f a but it's definitely possible to get filter :: (Foldable f) => (a -> Bool) -> f a -> [a]
06:00:27 <dwcook> You just need the original filter and toList
06:01:12 <magneticduck> oh yeah, Foldable doesn't have crescention of data to a data structure as a method
06:01:13 <magneticduck> just folding
06:01:31 <ski> @wn crescention
06:01:32 <lambdabot> No match for "crescention".
06:01:42 <magneticduck> yeah, they don't ues that word
06:01:44 <magneticduck> use*
06:01:58 <magneticduck> maybe it's just me =P
06:02:01 <magneticduck> uh, maybe it's not even a word
06:02:33 <magneticduck> .........
06:02:39 <ski> related to "crescent" ?
06:03:03 * hackagebot egison 3.2.24 - Programming language with non-linear pattern-matching against unfree data types  http://hackage.haskell.org/package/egison-3.2.24 (SatoshiEgi)
06:03:04 <magneticduck> there's a word that sounds a bit like that word that could mean to put a piece of data on a stack..?
06:03:18 <magneticduck> non-linear pattern-matching eh
06:03:32 * ski blinks
06:04:03 <dwcook> That languages needs better syntax
06:05:06 <ski> yeah, needs more round brackets
06:05:26 <dwcook> I was thinking about how much cons noise there is
06:05:47 <dhrosa>  @pl \(x, n) -> replicate n x
06:05:57 <dhrosa> @pl \(x, n) -> replicate n x
06:05:57 <lambdabot> uncurry (flip replicate)
06:06:05 <magneticduck> dhrosa: hard one =P
06:07:02 <ski> dwcook : they should allow defining macros for the patterns, which would solve that problem
06:07:04 <tdammers> crescention: 1. the process of transforming into a crescent 2. the amount to which something has transformed into a crescent or crescent-like shape
06:07:09 <tdammers> that'd be my guess
06:07:28 <ski> seeing unquote without quasiquote looks confusing, imho
06:07:30 <tdammers> "related to crescent" would be "crescential" or "crescentious" or something like that
06:08:11 <ski> tdammers : hehe, but i said "related to \"crescent\"", not "\"related to crescent\"" :)
06:08:13 <magneticduck> acrescention or something
06:08:27 <dwcook> "Very important because of its moon shape" would be cressential
06:08:31 <magneticduck> phryk: long lunch break
06:10:06 <phryk> magneticduck: Well, what can I say, I got good metabolismâ¦
06:10:33 <magneticduck> you have to stop wasting so much time with your food
06:10:38 <magneticduck> just eat it and get done with it
06:10:47 <magneticduck> 9 seconds.
06:10:49 <magneticduck> pft.
06:10:57 <phryk> magneticduck: Eh, today is a day off. So I'm taking it slow.
06:11:38 <makalu> if I have multiple executables with different dependencies in a cabal file, cabal will link all executables to all dependencies. Is there any way to avoid this?
06:12:24 <dcoutts> makalu: specify a later cabal version in the .cabal file. The behaviour you're seeing is for backwards compatibility (ie an old bug).
06:12:58 <makalu> dcoutts: do you have an idea which minimum version would fix it?
06:13:29 <dcoutts> makalu: I don't, but if you specify 1.10 then you're hardly excluding anyone
06:14:09 <eacameron> dwcook: interesting, that's neat
06:14:35 <makalu> dcoutts: thanks
06:15:35 <dcoutts> makalu: so old versions of cabal had that wrong behaviour, but it turned out we couldn't change it without breaking old packages, so we do it based on the version of the cabal spec that the .cabal file says it's using
06:19:08 <dhrosa> @pl fmap sum . sequence
06:19:08 <lambdabot> fmap sum . sequence
06:20:20 <dhrosa> @src sequence
06:20:20 <lambdabot> sequence []     = return []
06:20:20 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
06:20:20 <lambdabot> -- OR: sequence = foldr (liftM2 (:)) (return [])
06:20:36 <skrio> is there any easy way to create heterogenous lists in haskell?
06:20:46 <magneticduck> dhrosa: "point-free" doesn't mean "no dots" ^^
06:20:58 <magneticduck> dhrosa: btw you can get all of that cool lambdabot functionality offline
06:21:24 <magneticduck> @faq can haskell easily create heterogenous lists
06:21:24 <lambdabot> The answer is: Yes! Haskell can do that.
06:21:30 <magneticduck> skrio: now all we have to figure how is how
06:21:54 <fizruk> skrio: how would you work with it's elements?
06:22:17 <dhrosa> magneticduck: I know that the points don't refer to (.), but I was wondering if there was a  built-in synonym for fmap f . sequence, it looks like sequence . map f, which is just mapM
06:22:32 <prophile> traverse, no?
06:22:36 <prophile> http://hackage.haskell.org/package/hetero-map
06:26:02 <ski> skrio : depends on what you mean by "heterogenous lists"
06:27:42 <ski> hm, `HeteroMap.Map.newKey' is interesting
06:29:10 <predator217> skrio: there is hlist: http://hackage.haskell.org/package/HList
06:29:46 <predator217> it also has heterogeneous map/filter/fold
06:29:57 <predator217> and lots of other things
06:30:01 <ski> skrio : one possible interpretation is to use a list of `Dynamic's. another is to use a list of existentially wrapped elements, all of which satisfy some common element. another is what predator217 is suggesting
06:30:28 <ski> skrio : another is to use some fixed way of specifying the types of the elements, like e.g. they being of form `a',`f a',`f (f a)',`f (f (f a))',&c.
06:31:06 <ski> skrio : another is to use existential associations with a GADT type as the key type
06:31:49 <ski> (and another is possibly also the `hetero-map' prophile suggested above, which i'm not familiar with)
06:31:58 <ski> there's probably more variants, depending on what you actually want to do
06:33:46 <prophile> hetero-map uses the power of stopping types escaping through forall hackery
06:33:47 <prophile> like ST
06:37:08 <ski> yes. i was mostly interested in how they implemented it
06:37:25 <ski> seems like the magic (as it is) happens in `In'
06:38:18 <psquid> Well this is bizarre. I can do `echo $COLUMNS` just fine in my shell, but any Haskell program I run from the exact same shell has no 'COLUMNS' entry in getEnvironment. Any ideas where I should start investigating?
06:39:40 <Clint> psquid: does it show up in the output of `env`?
06:39:42 <c_wraith> psquid: in your shell, export COLUMNS
06:39:53 <ski> psquid : looks like Bash-magic ?
06:40:11 <c_wraith> oh, is COLUMNS magic?  I was just assuming it was a non-exported shell variable
06:40:22 <ski> psquid : try `tput cols' instead ?
06:40:23 <geekosaur> it's not magic
06:40:34 <geekosaur> but it may well not be exported
06:40:44 <psquid> Clint, c_wraith: Aah, that's it. It's not exported. That would explain it.
06:41:01 <Clint> there you go
06:41:17 <ski> geekosaur : seems to be at least somewhat magic, as it's automatically updated when the terminal dimensions change
06:41:30 <psquid> And also means yeah, looks like tput cols is gonna have to be my goto here, since I can't have my code reach out and export someone's shell variables. xD
06:49:01 <SLi> Is there a way to prevent cabal build from printing a screenful of "Loading package ..." when building TH programs?
06:52:55 <c_wraith> SLi: that output come from ghc itself.  There doesn't seem to be any way to suppress it
06:57:15 <Dinkar> How do I list properties inside the module (not as part of the quick check test case?)
06:57:36 <Dinkar> is there a way to represent invariants as properties: conventional or a library?
07:06:26 <Cale> Dinkar: I don't understand your questions
07:06:53 <Dinkar> Sorry about that let me elaborate a bit:
07:07:03 <Dinkar> I have a data constructor with rate and factor.
07:07:14 <Dinkar> and by design rate - 1/ factor < 0.0001
07:07:32 <Dinkar> I can add this as a quick check property to test..but is there a better way where the
07:07:52 <Dinkar> Cale: invariant is obvious by looking at the code.
07:08:18 <Dinkar> Cale: Is there a convention to express this or is there a library that wont be importing quickchk?
07:09:16 <Cale> It's hard to enforce things like that statically in Haskell.
07:10:17 <Dinkar> Cale: I see..in eiffel there used to be a clause call invariant for the class (of course that is different in haskell context) but I was hoping to see if a similar convention exists..so quick check can pick these up during test?
07:10:41 <Dinkar> Cale: btw...i dont need to enforce simply state it..it will still need to be tested..
07:11:26 <Cale> Well, quickcheck tests are a good way to state it in a way that can be tested.
07:12:11 <Cale> To enforce such a property at the module level, you'd normally not export the data constructor for your type, and instead only export functions which make valid values.
07:12:15 <Dinkar> Cale: That would be my approach..and I was trying to capture the property in the test. Though wanted to ensure that a better way did not already exist that is being followed by convention.
07:12:39 <Dinkar> Cale: That is true too..
07:12:56 <Dinkar> Cale: Thank you for the pointers. I have a road map now.
07:14:54 <foobar_> hey! how can I do pattern matching with Text
07:14:59 <ski> Dinkar : i suppose you could possibly try to build a value in some arbitrary way using the published operations in the interface, then check the invariant for that value
07:15:20 <foobar_> I used to do something like this for string ('p':'a':'t':'t':'e':'r':'n':_) -> do something. but this doesn't work for text
07:15:29 <ski> Dinkar : though it would probably make sense to check the invariant at each intermediate step, stopping as soon as you get to an inadmissible value
07:15:58 <ski> @hoogle stripPrefix
07:15:58 <lambdabot> Data.List stripPrefix :: Eq a => [a] -> [a] -> Maybe [a]
07:15:58 <lambdabot> Data.Text stripPrefix :: Text -> Text -> Maybe Text
07:15:58 <lambdabot> Data.Text.Lazy stripPrefix :: Text -> Text -> Maybe Text
07:16:07 <ski> foobar_ : perhaps you could use that ^
07:16:21 <Dinkar> ski:hmm..I dont completely follow the intermediate checks because in my application I parse json files to create these objects..so the errors are thrown up front.
07:16:48 <ski> @let dual (stripPrefix "co" -> Just s) = s; dual s = "co" ++ s
07:16:48 <lambdabot>  Parse failed: ViewPatterns is not enabled
07:17:00 <Dinkar> ski: What I am going to do is to add some valid___ methods for checking and testing.
07:17:33 <ski> > let dual (stripPrefix "co" -> Just s) = s; dual s = "co" ++ s in (unwords . map dual . words) "coffee product"
07:17:34 <lambdabot>  "ffee coproduct"
07:17:49 <ski> foobar_ ^
07:18:18 <foobar_> thanks ski :)
07:18:57 <ski> Dinkar : not sure what you mean by "follow the intermediate checks"
07:20:11 <ion> > let dual (stripPrefix "co" -> Just s) = s; dual s = "co" ++ s in "coffee product" ^. iso words unwords . traverse . iso dual dual %~ reverse
07:20:12 <lambdabot>  Couldn't match type `[GHC.Types.Char]'
07:20:12 <lambdabot>                with `Control.Lens.Setter.Setting (->) s0 t0 [a0] [a0]'
07:20:12 <lambdabot>  Expected type: (Control.Lens.Setter.Setting (->) s0 t0 [a0] [a0]
07:20:12 <lambdabot>                  -> Control.Lens.Internal.Getter.Accessor
07:20:12 <lambdabot>                       (Control.Lens.Setter.Setting (->) s0 t0 [a0] [a0])
07:20:45 <Dinkar> ski: "check the invariant at each intermediate step" part in your response...it seems to make sense..but that might mean i cant use pure functions..i need to think about t.
07:21:08 <ion> > let dual (stripPrefix "co" -> Just s) = s; dual s = "co" ++ s in "coffee product" & iso words unwords . traverse . iso dual dual %~ reverse
07:21:09 <lambdabot>  "coeeff cotcudorpoc"
07:21:40 <ion> > let dual (stripPrefix "co" -> Just s) = s; dual s = "co" ++ s in "ad hoc coffee product" & iso words unwords . traverse . iso dual dual %~ reverse
07:21:42 <lambdabot>  "codaoc hoc coeeff cotcudorpoc"
07:23:28 <zipper`> I'm having trouble with the use of handle frim Control.Exception in compressor.hs as used in real world haskell. Here is a gist of the code and the error https://gist.github.com/urbanslug/9348351
07:23:41 <ski> Dinkar : i don't mean that your operations should check the invariant at each intermediate step. just that the QC stuff would
07:23:43 <haskellelephant> Hey, does anyone know if there is a library function to check if there is a line ready to be read from stdin?
07:24:08 <Dinkar> ski: oh ok..understood..i knew i missed something in that statement :)
07:24:43 <t4nk791> is there a rational/integer arithmetic library in haskell, which doesn't require you to catch divide by zero etc exceptions?
07:27:05 <fffej> haskellelephant: there's hReady which indicates whether there is at least one element to read from the given handle
07:27:32 <haskellelephant> fffej: So that would work if buffering is set to linebuffering right?
07:27:52 <geekosaur> no
07:29:48 <dwcook> t4nk791, what would it do with division by zero?
07:29:54 <fffej> haskellelephant: not sure I'm afraid
07:30:27 <haskellelephant> fffej: Fortunately I think it is good enough in my case :)
07:30:36 <geekosaur> hReady tells you there is either at least one character or an error condition, such that read won't block
07:30:53 <geekosaur> lines are not independent entities and can't be tested for as such
07:31:52 <t4nk791> dwcook: either return a Maybe or an Either?
07:32:00 <haskellelephant> If the input is sent from a terminal, than you are more or less guaranteed that it is sent at least one line at a time right?
07:32:13 <haskellelephant> geekosaur: ^^
07:33:14 <geekosaur> only if it's in line mode, which it won't be if you're using e.g. gnu readline
07:33:26 <geekosaur> also as long as you don't hit various corner cases
07:33:50 <dwcook> t4nk791, not that I know of, though I suppose you could specifically check for division by 0 beforehand and if so give Nothing
07:34:49 <fizbin> Is ghci available as a module one can import? I'd like to write a short program that invokes ghci with a bunch of bindings and imports active and then hands the user a REPL.
07:35:13 <haskellelephant> geekosaur: Good enough for now, I should have something real anyways.
07:35:19 <geekosaur> fizbin: not like that, no
07:36:14 <geekosaur> hint can evaluate expressions, ghc-api can do anything but does not have convenience wrappers for anything. ghci itself uses ghc-api, and you might be able to lift the source and turn it into a library
07:37:42 <t4nk791> dwcook: right. i'm playing with the safe library, and was wondering if someone has done something similar for Numerics
07:44:32 <urbanslug> Could someone help me with this piece of code copied from RWH but won't work. https://gist.github.com/urbanslug/9348351
07:44:49 <urbanslug> I don't get how haskell books have code that fails.
07:45:01 <Maior> urbanslug: because code changes
07:45:10 <Maior> urbanslug: and the book doesn't state precise dependency versions
07:45:13 <artyomkazak> RWH is fairly old and hasn't been updated for changes in base
07:45:26 <urbanslug> Maior: I fixed dependancy issues.
07:45:52 <Maior> urbanslug: I don't think you did - you seem to be using a newer base
07:45:55 <urbanslug> Maior: It was an issue with types from Control.Exception
07:46:03 <geekosaur> the exception system went through significant changes after RHW was published
07:46:21 <geekosaur> the problem with paper books is it's hard to update them after printing...
07:46:22 <urbanslug> FML!
07:46:38 <urbanslug> geekosaur: I am reading the online version.
07:46:59 <geekosaur> in that case I would expect the updated one is in the comments section?
07:47:07 <geekosaur> (if I recall how the online one works)
07:47:11 <urbanslug> I tried adding a type signature to it but failed. Most probably because I hardly use exceptions.
07:47:29 <urbanslug> geekosaur: I read the comments. They hardly helped.
07:48:00 <quicksilver> can't you jsut use Control.OldException(s) or something?
07:48:15 <geekosaur> I think that module got dropped at some point
07:48:16 <quicksilver> the Exceptions breakage is by far the worst I can remember, anyway
07:48:17 <urbanslug> Is there OldExceptions?
07:48:21 <quicksilver> it's not normally that bad
07:48:25 <geekosaur> so too new a ghc wouldn't have it
07:48:50 * benj_ looks at robj_ 
07:48:54 <urbanslug> I'll just try to get rid of the exception in the code.
07:52:15 <artyomkazak> urbanslug: I've been able to fix the type error by specialising âprintâ to âprint :: SomeException -> IO ()â
07:52:57 <artyomkazak> urbanslug: see the âCatching all exceptionsâ section in Control.Exception module haddocks
07:56:55 <urbanslug> artyomkazak: SomeException?
07:57:46 <geekosaur> RWH was written with the older value-based exceptions. the modern exception system is type-based
07:58:02 <geekosaur> SomeException is a type that can represent any exception
07:58:22 <urbanslug> I read that in catching all exceptions
07:58:48 <urbanslug> but it's like Control.Exception doesn't export that type
07:58:53 <urbanslug> Yet I expect it to
07:58:57 <urbanslug> wait
07:59:01 <geekosaur> anyway if you don't specify a type when catching an exception now, you get a type error.
07:59:27 <artyomkazak> it most certainly does. Maybe you've forgotten to add it to imports?
07:59:39 <adas> I'm not able to find documentation for Control.Monad.Trans.State ..
07:59:55 <adas> the docs I see only have Control.Monad.ST.Lazy et.all
08:00:47 <urbanslug> I guess I added the type signature in the wrong place https://gist.github.com/urbanslug/9349148
08:01:18 <artyomkazak> âhandle (print :: SomeException -> IO ()) $ doâ
08:01:59 <urbanslug> I never saw code written like that :(
08:03:14 <urbanslug> artyomkazak: Thanks it works
08:05:14 <cariveri> Hi. can anymore help me with the threepenny-gui ? I got trouble using a costumHTML
08:07:00 <urbanslug> artyomkazak: http://book.realworldhaskell.org/admin/comments/comment/16572/
08:07:28 <artyomkazak> urbanslug: the link is broken for me
08:08:18 <urbanslug> artyomkazak: Oh it expects you to log in. ANyhoo I added a comment with working code.
08:08:33 <urbanslug> No way to link to it though :C
08:12:27 <cariveri> levi: Hey. you suggest to use threepenny. can you give me a hand on it?
08:16:59 <ski> urbanslug : "FML" ?
08:17:46 <artyomkazak> âfunctor my lifeâ, I thought
08:18:23 * ski was thinking about "Fermat's Last Marginâ¢"
08:18:48 <prophile> a combination of F# and ML
08:18:49 <prophile> lovely language
08:19:01 <prophile> practical too
08:19:09 <ski> which ML ?
08:19:19 <Maior> SML, the one true ML
08:19:37 <ski> not Alice ML then ?
08:19:38 <prophile> mL, the only ML endorsed by SI
08:22:02 <Cale> cariveri: I've never used threepenny, but what problem are you having?
08:24:32 <c_wraith> appEndo still looks like a joke name to me.
08:25:31 <cariveri> Im trying to use a different html file to start with reusing its own javascripts additionally. problem is that the normal script and ccss behaviour isnt turn on it seems, compared to launching the html file directly to firefox.
08:25:56 <cariveri> Cale: so its seems, there is a directory problem in it.
08:26:22 <tomejaguar> ML is also endorsed by SI.  1 billion times better than mL.
08:26:55 <cariveri> Cale: using html only works fine. using threepenny with default html works too. but the combination doesnt.
08:26:55 <c_wraith> tomejaguar: that's a lot better.
08:27:50 <danilo2_> Hello! I'm trying to use ghcjs - I downloaded ghc 7.9 (from head) and while running "cabal install ./ghcjs" (according to https://github.com/ghcjs/ghcjs) I got dependency resolution error. Here is the install log: http://bpaste.net/show/0vteX4wvYxTknhZduniA/
08:28:20 <Earnestly> Wait, 7.9?
08:28:24 <danilo2_> Could anybody help me with this issue? I think there are some people using ghcjs with ghc 7.8 or 7.9
08:28:45 <danilo2_> Earnestly: yes, if you download the master branch and compile it, it is 7.9.1040303
08:28:55 <Earnestly> Ah
08:28:55 <geekosaur> danilo2, if you;'re running HEAD then it already has ghcjs
08:30:04 <geekosaur> oh, hm, maybe not. thought it was supposed to be actually in there, not just the minimal hooks
08:30:33 <danilo2_> geekosaur: it is not - as far as I see, there is no "ghcjs" binary and cabal does not support the --ghcjs flag
08:31:42 <bergmark> i don't think it's meant to ship with ghc, but i could be wrong
08:32:06 <danilo2_> bergmark: It is meant - I saw a long topics a long time ago according to that fact
08:32:32 <danilo2_> Anyway, how can I use ghcjs now if we cannot install it right now? :(
08:32:58 <geekosaur> in any case all three of the failures are the same TH issue
08:35:01 <danilo2_> geekosaur: Ok, I will file a bug :)
08:35:38 <geekosaur> it's failing to find ClassP
08:50:32 <danilo2_> geekosaur: do you think it is ghc bug? does TH api changed somehow and it breaks the names?
08:51:18 <geekosaur> I have no idea
08:51:54 <sclv_> so if we don't have preflex around and lambdabot doesn't do it anymore
08:51:58 <sclv_> is there any way to do an @see ?
08:52:04 <sclv_> to do an @seen rather?
08:53:21 <danilo2_> geekosaur: Ok, thank you :) I'll try to figure it out and let you know what is the status :)
08:53:36 <geekosaur> ...
08:53:50 <geekosaur> when did I say that I needed to know the status?
08:55:30 <danilo2_> geekosaur: You did not - I thought it would be just nice to inform you about it. But in this case I will not, sorry
09:10:39 <cariveri> levi: are you in? I need help on this.
09:16:39 <ReinH> oh hai
09:41:21 <suppi> hello
09:42:48 <suppi> can anyone help me understand why the following happens and what it means?
09:42:51 <suppi> http://pastebin.com/XZVJqi6A
09:43:36 <byorgey> suppi: that is the monomorphism restriction in combination with ghci's aggressive type defaulting
09:44:06 <byorgey> suppi: the standard recommendation is to turn off the monomorphism restriction, e.g. by putting   :set -XNoMonomorphismRestriction  in your .ghci file
09:44:54 <suppi> thanks
09:45:39 <suppi> I'll read about it in haskell.org :)
09:47:06 <dhrosa> @pl \(f, x, y) -> f x y
09:47:06 <lambdabot> (line 1, column 9):
09:47:06 <lambdabot> unexpected "y"
09:47:06 <lambdabot> ambiguous use of a non associative operator
09:47:09 <dhrosa> what's wrong with that?
09:47:38 <theorbtwo> @pl \(f x y) -> f x y
09:47:38 <lambdabot> (line 1, column 5):
09:47:38 <lambdabot> unexpected "x"
09:47:38 <lambdabot> expecting operator or ")"
09:48:03 <geekosaur> there is in general no way to render a 3-tuple pointfree
09:48:05 <byorgey> dhrosa: nothing is wrong with it, I think @pl is just confused
09:48:16 <geekosaur> and @pl is actually fairly limited anyway
09:50:44 <byorgey> dhrosa: if you define  fst3 : (a,b,c) -> a  and snd3, thd3 similarly, then you could write your function as   fst3 <*> snd3 <*> thd3
09:51:00 <byorgey> using the Applicative ((->) e)   instance
09:53:13 <dhrosa> oo I see, thanks!
09:56:55 <ski> @type fst3 <*> snd3 <*> thd3
09:56:56 <lambdabot> (b1 -> c -> b, b1, c) -> b
09:57:52 <dhrosa> @src fst3
09:57:52 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
09:58:01 <Maior> ...
09:58:29 * hackagebot haskell-names 0.3.2.6 - Name resolution library for Haskell  http://hackage.haskell.org/package/haskell-names-0.3.2.6 (RomanCheplyaka)
09:58:33 <dhrosa> yes I know it's just fst3 (a, _, _) = a, but I  was  wondering where lambdabot was  getting its  fst3 frmo
09:59:38 <yitz> dhrosa: either someone defined it using @let, or it's part of lambdabot's "extended" Haskell.
10:01:34 <pavonia> @hoogle fst3
10:01:34 <lambdabot> No results found
10:01:48 <pavonia> @hayoo fst3
10:01:48 <lambdabot> Unknown command, try @list
10:01:59 <pavonia> Too bad we don't have that command
10:02:43 <artyomkazak> @let randomname5783 = undefined
10:02:45 <lambdabot>  Defined.
10:02:53 <artyomkazak> @src randomname5783
10:02:53 <lambdabot> Source not found. My pet ferret can type better than you!
10:02:57 <ski> <ski> @let thd3 :: (a,b,c) -> c; thd3 (_,_,c) = c
10:02:57 <artyomkazak> I see
10:03:14 <ski> mutatis mutandis for the other ones
10:04:58 <AleXoundOS_> Hi. I'm trying to write "get_menu_items" function http://pastebin.com/9JwXiqiC but get this error: http://pastebin.com/ZvWFaq6B
10:05:10 <AleXoundOS_> What am I doing wrong?
10:07:49 <pavonia> AleXoundOS_: You probably need to wrap your result type in IO
10:08:21 <AleXoundOS_> IO Markup instead of Markup ?
10:08:30 * hackagebot http-server 1.0.4 - A library for writing Haskell web servers.  http://hackage.haskell.org/package/http-server-1.0.4 (IavorDiatchki)
10:09:11 <ski> AleXoundOS_ : sounds likely
10:09:14 <pavonia> yeah
10:09:28 <AleXoundOS_> http://pastebin.com/hCbKSjF1
10:10:14 <pavonia> You're not returning a Markup value from that function
10:13:30 * hackagebot machines 0.2.4 - Networked stream transducers  http://hackage.haskell.org/package/machines-0.2.4 (EdwardKmett)
10:13:35 <AleXoundOS_> pavonia, but html_menu should return Markup and I explicitly pointed that
10:14:06 <urbanslug> Is there a book comparable to  Real World Haskell but one whose sample code doesn't blow up in my face all the time? :(
10:14:20 <pavonia> Oh, Markup is a monad
10:15:37 <pavonia> AleXoundOS_: The mapM_ is working on the Markup monad, but is used in an IO monad, so you have to use return to yield the Markup as a result from that function
10:17:07 <AleXoundOS_> pavonia, thanks, "return (mapM_ (html_menu . fromList) response_from_db)" worked
10:20:09 <joelteon> wow, machines is hurting my headh
10:22:11 <edwardk> joelteon: take 2 tylenol and call me in the morning (with any questions)
10:22:33 <joelteon> oh did you make that
10:22:42 <joelteon> oh, there's your namee.
10:22:48 <joelteon> my typos are pretty bad today
10:23:55 <prooftechnique> Machines are pretty cool. Glad to see the library getting an update
10:24:04 <joelteon> so is machines like pipes/conduit, or is it more general
10:26:45 <urbanslug> I went offline before I got my question answered.
10:28:27 <shergill> is there a way to make ghc-mod be aware of locally installed packages (installed inside an hsenv environment in this case)
10:28:32 * hackagebot zippers 0.2 - Traversal based zippers  http://hackage.haskell.org/package/zippers-0.2 (EdwardKmett)
10:28:34 <prooftechnique> I just wish I could find video of Runar's talk
10:28:57 <Apocalisp> which one?
10:29:06 <prooftechnique> Apocalisp: The one on Machines
10:29:07 <edwardk> joelteon: it is a very slow exploration of the design space around pipes/conduit searching for a simpler API.
10:29:42 <shergill> ah there's PACKAGE_DB_FOR_GHC_MOD
10:29:49 <yitz> shergill: is there no way to specify a package-db path for ghc-mod as for regular ghc?
10:29:56 <edwardk> joelteon: on the plus side it can represent things like non-deterministic blocking on multiple sources that just aren't in the vocabulary of those at all, on the downside, they've thought a _lot_ more about resource management.
10:30:01 <ReinH> edwardk: oh hai
10:30:13 <Apocalisp> prooftechnique: I don't think there is such a video
10:30:21 <Apocalisp> prooftechnique: were you there?
10:30:26 <prooftechnique> Oh, I was hoping there was video to go with the slides
10:30:32 <prooftechnique> https://dl.dropboxusercontent.com/u/4588997/Machines.pdf
10:31:28 <shergill> yitz: i think i found the variable which does that
10:31:38 <prooftechnique> Ah, just found a blog entry that mentions that it was no recorded
10:31:40 <prooftechnique> Shucks
10:31:44 <prooftechnique> *not
10:31:53 <pavonia> urbanslug: Code changes quite frequently for some packages, so it's likely that would be a problem for any printed book. What issues are you having?
10:32:18 <acowley> I will push machines-concurrent to hackage one fine day
10:32:41 <edwardk> not concurrent-machines ?
10:32:45 <prooftechnique> urbanslug: You may have some success on the RWH website. The comment section usually has corrections.
10:32:46 <joelteon> edwardk: here's hoping it goes somewhere
10:32:53 <joelteon> I think I'll try and use it
10:32:58 <acowley> Man, I walked right into that bike shed
10:33:03 <urbanslug> prooftechnique: I was using the online version
10:33:06 <joelteon> the blocking on multiple sources seems useful
10:33:06 <djahandarie> Haha
10:33:33 * hackagebot machines 0.2.5 - Networked stream transducers  http://hackage.haskell.org/package/machines-0.2.5 (EdwardKmett)
10:33:42 <edwardk> joelteon: well, it has been an agent for change within pipes itself over time, so its work has been more... indirect
10:33:45 <djahandarie> @remember acowley < acowley> I will push machines-concurrent to hackage one fine day < edwardk> not concurrent-machines ? < acowley> Man, I walked right into that bike shed
10:33:46 <lambdabot> I will never forget.
10:33:56 <urbanslug> Uh my main issue is moving from LYAH to writing real world programs
10:34:16 <shachaf> djahandarie: I found out how your last name is pronounced. Bizarre.
10:34:26 <artyomkazak> urbanslug: there was some recent book about using Haskell for a real-world project
10:34:29 <urbanslug> but I have found this http://www.haskell.org/haskellwiki/Real_World#haskell
10:34:32 <edwardk> says the boy named shachaf
10:34:34 <acowley> It doesn't even have a "b" in it
10:34:38 <prooftechnique> urbanslug: Well, what do you want to write? Maybe we can poin you in the right direction
10:34:49 <geekosaur> has anyone managed to convince dons to stop shooting pictures of sunsets for long enough to revamp rwh? :p
10:34:50 <urbanslug> Real World #haskell not to be confused with Real World Haskell.
10:35:13 <djahandarie> shachaf, yes, it is pretty bizarre that you found that out.
10:35:20 <artyomkazak> urbanslug: www.apress.com/9781430262503â
10:35:57 <joelteon> hashtag haskell
10:35:58 <acowley> Is writing a real world Haskell program that different from other languages?
10:36:03 <urbanslug> prooftechnique: I don't know yet. I just want to feel confident when I say I can write something when needed.
10:36:08 <edwardk> geekosaur: The sunsets are all dons has to console himself with these days. Well, those and heaping piles of money.
10:36:13 <urbanslug> artyomkazak: Thanks
10:36:32 <shachaf> djahandarie: You should be in #-blah or #-lens or something.
10:36:45 <prooftechnique> urbanslug: The first semiserious program I wrote was a webscraper for a client. I wrote it in 10 minutes during a meeting with them :D
10:36:51 <acowley> The piles of money offer good vantage points
10:36:55 <prooftechnique> I didn't think I could do it, and it just happened
10:37:14 <acowley> Did you apologize?
10:37:48 <acowley> "I don't know where that came from... I didn't plan on any of this!"
10:37:50 <edwardk> acowley: Well, it is a lot easier to look down on the little people when you're sitting on a pile of money, as long as the pile is big enough anyways.
10:37:57 <prooftechnique> acowley: Hahaha
10:38:02 <djahandarie> shachaf, I'm in #agda, does that count?
10:38:04 <prooftechnique> Oh, god, what have I done!
10:38:06 <prooftechnique> ?
10:39:07 <prooftechnique> edwardk: The key is finding the optimal money pile height to still be able to see the little people but not hear them
10:39:57 <ystael> i have a very stupid question.  ghc --make doesn't build a binary.  ghc MainModule.o complains about a bunch of unresolved dependencies.  what standard error am I committing?
10:40:08 <ystael> (runghc works fine.)
10:40:18 <edwardk> prooftechnique++
10:40:42 <yitz> 2011-02-19 03:42:46 +0100, <tnks>, how do I pronounce <*>? 2011-02-19 ... 2011-02-19 03:44:03 +0100, <djahandarie>, "leshanstareatehan"
10:41:02 <joelteon> i'm getting PHP flashbacks
10:41:09 <edwardk> yitz: 'ap'
10:41:19 <prooftechnique> ystael: Can you lpaste the error?
10:41:23 <magneticduck> uhmm... how would one write an application in haskell that, when run in a terminal, changes the working directory of the terminal it's being run in?
10:41:33 <davidfetter_disq> 'sup, edwardk
10:41:36 <edwardk> oh, ooold paste
10:41:37 <prooftechnique> ystael: Also, is your main module called Main or MainModule?
10:41:58 <johnw> yitz: <*> is almost the same thing as " " (function application space), just that it applies within an Applicative context
10:42:01 <magneticduck> it seems like changeWorkingDirectory or system "cd <filepath>" doesn't work; it changes working directory of the process
10:42:08 <magneticduck> but how would I change the working directory of the parent process?
10:42:14 <magneticduck> it's possible right? :<
10:42:19 <ystael> prooftechnique: MainModule, in MainModule.hs.  I can't paste the error from ghc MainModule.o easily; I will reduce the example and come back.
10:42:19 <magneticduck> I sure hope it's possible
10:42:21 <Maior> magneticduck: ew what why?
10:42:21 <yitz> edwardk: it's what google came up with for "djahandarie pronunciation"
10:42:33 <johnw> magneticduck: I really don't think that's possible
10:42:33 <prooftechnique> ystael: Does it work if you change the name to Main?
10:42:34 <djahandarie> Haha.
10:42:44 <ystael> prooftechnique: Haven't tried that.
10:42:46 <edwardk> yitz: ah
10:42:46 <johnw> magneticduck: you'd have to send some kind of message to the parent asking it to change it's working directory
10:42:52 <edwardk> davidfetter_disq: hello
10:42:53 <AlainODea> magneticduck: I'm pretty sure it's not possible without the parent process cooperating.  It would be a privilege escaltion risk
10:42:54 <magneticduck> Maior: I"m writing a little convenience utility, essentially it's a "smart bookmark" program
10:42:55 <Maior> magneticduck: (I don't believe it's possible beyond "frob the memory"-type haxx)
10:42:58 <ystael> I'll do more analysis and come back if it still doesn't work.
10:43:06 <ystael> I hoped my issue was a standard noob mistake.
10:43:07 <magneticduck> yeah
10:43:28 <magneticduck> is there any way of setting things up so I could do it?
10:43:38 <magneticduck> or make something that looks like it's changing the directory?
10:43:43 <Maior> magneticduck: higher level, what are you trying to do?
10:43:51 <magneticduck> short of starting a terminal as a child process to the program?
10:43:51 <prooftechnique> ystael: I'm pretty sure ghc looks for Main specifically if it's supposed to generate a binary
10:43:58 <magneticduck> as I said, I'm making a ... smart bookmark tool
10:44:03 <Maior> yes
10:44:05 <Maior> what's one of those
10:44:11 <prooftechnique> I can't remember if main-is is a ghc flag or if it's just for cabal
10:44:12 <magneticduck> to try to reduce use of cd and the tab key =P
10:44:41 <Maior> magneticduck: you know cd is a shell builtin?
10:44:42 <dcoutts> prooftechnique: unfortunately it's a name clash, it means different things in the two cases
10:44:43 <prooftechnique> magneticduck: So something like z?
10:44:45 <Maior> (normally)
10:44:59 <magneticduck> prooftechnique: what's z? xD
10:45:02 <prooftechnique> dcoutts: Oh, how unpleasant
10:45:21 <prooftechnique> magneticduck: https://github.com/rupa/z
10:45:22 <davidfetter_disq> edwardk, re: morton ordering, my colleague tells me that it's not a 100% reliable replacement for JOINs. are there definable subsets of the problem space where it is?
10:45:46 <magneticduck> but there's no way of getting the parent terminal to execute a piece of bash produced by my program?
10:45:58 <magneticduck> like... if "cd" accepted stdin, myprogram | cd
10:46:04 <magneticduck> how could I accomplish something like that?
10:46:06 <johnw> magneticduck: wow, think about the security hole that would be
10:46:09 <magneticduck> eah
10:46:11 <magneticduck> *yeah
10:46:15 <ystael> prooftechnique: aha, that is precisely the problem.  i didn't realize that 'Main' in the ghc help text was a literal, not a metasyntactic variable :)
10:46:18 <ystael> thank you!
10:46:21 <magneticduck> :/
10:46:25 <edwardk> davidfetter_disq: it isn't as good as a good join can be, but it is never as bad as the worst they can be.
10:46:30 <yitz> magneticduck: cd $(myprogram)
10:46:36 <magneticduck> oh yes that's right
10:46:41 <prooftechnique> ystael: No problem. Definitely a common early issue
10:46:42 <AlainODea> magneticduck: : set PWD environment that you hand to the child process.  Your haskell program would launch the shell process
10:47:22 <magneticduck> yes that's what I was thinking
10:47:27 <prooftechnique> magneticduck: Make your program emit a bash script. Then use eval
10:47:31 <prooftechnique> What could possibly go wrong?~
10:47:34 <davidfetter_disq> edwardk, in the case of PostgreSQL, "only sometimes" is an enormous hassle...unless of course i've been misinformed, or Snow-Man over in #postgresql has missed something
10:47:38 <magneticduck> prooftechnique: nothing! :D
10:47:41 <magneticduck> eval is great!
10:47:47 <magneticduck> it's really hard to exploit!
10:47:55 <prooftechnique> Hehehe
10:48:01 <davidfetter_disq> and by "really hard," you mean "trivial."
10:48:21 <magneticduck> ..yes!
10:48:36 <edwardk> davidfetter_disq: well, this is why i wasn't advocating it for postgresql in general at first =)
10:48:40 <yitz> davidfetter_disq: it's really hard because a script kiddie looking for a download that will exploit it probably wouldn't find one.
10:49:19 <davidfetter_disq> yitz, well, the difference between there not being such a download and there being one is pretty tiny
10:49:32 <davidfetter_disq> ...and worse still, totally unpredictable
10:49:41 <suppi> can someone help me understand why (zipWith (==) <*> tail) is a function that takes only one list and returns a list of Bool?
10:50:17 <magneticduck> @type flip (<*>) tail
10:50:18 <lambdabot> ([a] -> [a] -> b) -> [a] -> b
10:50:19 <edwardk> davidfetter_disq: hop over to #haskell-lens? quieter there and analytics stuff is more on topic
10:50:22 <magneticduck> taa daa
10:50:31 <Saizan> suppi: <*> is for the (r ->) applicative
10:50:35 <davidfetter_disq> edwardk, well, i suppose we can try something, but anything that's of more general applicability will get more resources than research projects, which we're only getting a glimmer of how to set up the infrastructure to do
10:51:26 <suppi> oh, I understand
10:51:35 <suppi> I was reading about (r ->) in LYAH
10:51:46 <suppi> but I was looking at the functor chapter
10:52:09 <suppi> by mistake
10:52:14 <suppi> thanks Saizan
10:53:20 <shachaf> djahandarie: Logged channels don't count.
10:53:34 <djahandarie> All channels are logged!
10:56:45 <ski> edwardk : "morton ordering" ?
10:57:30 * ReinH sighs
10:57:39 <ReinH> Yet another paper I really want to read locked behind a paywall
10:58:19 * ski imagines the shell passing itself as a continuation to the child process, thereby simulating state through environment
10:58:27 <ski> ReinH ?
10:58:47 <ReinH> ski: http://link.springer.com/chapter/10.1007/BFb0030293
10:59:55 <prooftechnique> ReinH: I can check if my university has a subscription
11:00:08 <magneticduck> http://ix.io/aVE
11:00:14 <magneticduck> ....
11:00:19 <magneticduck> why the error?
11:00:24 <magneticduck> uh, I'll paste the error too
11:00:26 <ReinH> prooftechnique: awesome thanks
11:00:50 <magneticduck> http://ix.io/aVF
11:01:13 <acowley> I think you want readFile "blah" >>= putStrLn
11:01:14 <magneticduck> I feel like I'm not thinking straight
11:01:20 <magneticduck> oh yes ofc
11:01:34 <magneticduck> error is still there though
11:02:31 <acowley> Well, system apparently gives you an IO ExitCode
11:02:35 <acowley> putStrLn doesn't
11:03:03 <magneticduck> okay... but I return () at the end
11:03:09 <acowley> so you may want to swallow that ExitCode with Control.Monad.void, or you could just move your return () to the case branch where you call system
11:03:20 <magneticduck> and if I put (\str -> system str >> return ()) instead of system, same error
11:03:37 <magneticduck> (which is obvious, it's what's happening in the code even without the substitution)
11:04:07 <magneticduck> oh wait huh
11:04:23 <magneticduck> I guess the value in the case has to have the same type as the other one
11:04:35 <magneticduck> uhm.
11:04:39 * ski still thinks `Control.Monad.void' should be either renamed or moved
11:04:58 <acowley> ski: To what/where?
11:05:15 <acowley> ski: My only gripe is that it's not exported by Prelude, and adding an import for it chafes a bit
11:05:30 <ski> well, possibly renamed to something like `ignore', or relegated to FFI modules (only)
11:05:58 <ski> (i suppose `unit' might also work, if you insist)
11:06:18 <ski> however, `void' is for `Void -> a', imho
11:06:32 <acowley> I prefer absurd for that
11:06:45 <ski> it doesn't make sense to mix the C / C++ / Java / C# meaning of `void' into Haskell, proper
11:06:49 <ski> acowley : also fine
11:06:50 <acowley> void is too innocuous
11:07:03 <ski> why is innocuous bad ?
11:07:07 <acowley> Yeah, I didn't love void when I first encountered it
11:07:15 <acowley> because you really shouldn't have a value of type Void
11:07:43 <ski> how is it any different from a value passed to `either' which is neither of `Left ..' or `Right ..' form ?
11:08:06 <acowley> Whereas the idea of ignoring a return value is pretty common in programming, right or wrong
11:08:37 * ski has used `M Void', for `M' a monad, to good effect
11:08:58 <acowley> I think eliminating Void indicates a qualitative difference in the code you're writing as compared to working with inhabited types
11:09:08 <acowley> Yes, I use m Void, too
11:10:37 <ski> ("it doesn't make sense to .." -- or perhaps rather, it makes sense, only we spell the type `()' and pronounce it "unit")
11:11:02 <joelteon> forever should be type m a -> m Void
11:11:20 <prooftechnique> ReinH: I think I found it
11:11:39 <prooftechnique> I'll post a link when I have it
11:11:41 <c_wraith> joelteon: I disagree.  m a -> m b allows better unification if there is branching
11:11:55 <joelteon> yeah I thought of that RIGHT after I said that
11:11:59 <joelteon> ignore me
11:12:48 <ski> similarly with `subst :: Monad m => m a -> (a -> m a) -> m b'
11:16:20 <magneticduck> hmmm, is there a good haskell module to deal with filepaths?
11:16:41 <magneticduck> like, I'm at $HOME/blah/blah and user wants to go to ../././../testing/blah
11:16:47 <magneticduck> where's the absolute directory of the result
11:17:08 <magneticduck> ops, spoke too soon, library is pretty easy to find
11:17:36 <magneticduck> uh, or not.... any ideas?
11:17:48 <magneticduck> oh wait never mind -_-
11:17:54 * magneticduck has to think before typing
11:20:11 <prooftechnique> ReinH: You okay with djvu?
11:21:25 <dhrosa> @pl \x y -> compare (maximum x) (maximum y)
11:21:25 <lambdabot> (. maximum) . compare . maximum
11:21:29 <dhrosa> meh
11:22:03 <sie> @pl ((f x), (f y))
11:22:03 <lambdabot> (f x, f y)
11:22:22 <b80905> can anyone help me? ghc complains about this code `coprime = (== 1) . gcd': `No instance for (Num (a0 -> a0)) arising from the literal `1''
11:22:27 <artyomkazak> good job, lambdabot
11:22:42 <ski> sie : `(f *** f) (x,y)'
11:23:17 <ski> b80905 : you want `coprime = ((1 ==) .) . gcd' -- or possibly more points
11:24:57 <supki_> dhrosa: compare `on` maximum
11:25:10 <ski> @Ã¾l \f (x,y) -> ((f x), (f y))
11:25:10 <lambdabot> Maybe you meant: url pl
11:25:18 <ski> @pl \f (x,y) -> ((f x), (f y))
11:25:18 <lambdabot> (`ap` snd) . (. fst) . (flip =<< (((.) . (,)) .))
11:25:21 <ski> yuck !
11:25:54 <Hafydd> You like using unnecessary punctuation, don't you?
11:25:55 <ski> dhrosa : aka `comparing maximum'
11:26:20 <dhrosa> ah
11:26:36 <dhrosa> I'm learning so much from doing these one-haskell-a-days
11:27:25 <ski> Hafydd : `pointless' often does, yes
11:27:37 <Hafydd> ski: no, I mean you yourself.
11:27:46 <ski> oh
11:27:57 <ski> sometimes, i suppose
11:29:05 <Currier> one-haskell-a-day? sounds like fun, what's that?
11:29:20 <path[l]> yeah, what is this
11:29:58 <acowley> twitter
11:30:36 <acowley> https://twitter.com/1HaskellADay
11:31:13 <suppi> a haskell a day will keep the doctor away
11:32:54 <Hafydd> :t uncurry . on (,)
11:32:55 <lambdabot> (b -> b1) -> (b, b) -> (b1, b1)
11:33:07 <path[l]> ah interesting
11:33:15 <Currier> that does look fun!
11:36:17 <ski> @type join (***)
11:36:18 <lambdabot> Arrow a => a b c -> a (b, b) (c, c)
11:36:35 <ski> > join (***) (^2) (3,4)
11:36:36 <lambdabot>  (9,16)
11:36:44 <ski> > join (***) (^2) (3 :: Integer,4 :: Double)
11:36:45 <lambdabot>  Couldn't match type `GHC.Integer.Type.Integer'
11:36:45 <lambdabot>                with `GHC.Types.Double'
11:36:45 <lambdabot>  Expected type: (GHC.Integer.Type.Integer
11:36:45 <lambdabot>                  -> GHC.Integer.Type.Integer)
11:36:45 <lambdabot>                 -> (GHC.Integer.Type.Integer -> GHC.Integer.Type.Integer)
11:38:02 <zenon> ok, so join allows you do distribute a function over elements in 2-tuples
11:38:51 <ski> @pl \x -> f x x
11:38:51 <lambdabot> join f
11:39:37 <zenon> mhm, I see.
11:47:50 <magneticduck> grrrr... I find myself using haskell and runhaskell as a kind of scripting language because I find it so much more fluent than the (little) bash that I know
11:47:56 <magneticduck> am I alone? xD
11:48:11 <Cale> No, that's a good thing
11:48:13 <magneticduck> yay
11:48:35 <AlainODea> magneticduck: that's a good place to be. Much harder to go the other way.  Trust me.  I'm trying to wean myself off bash.  It's a rough addiction to kick
11:48:47 <magneticduck> AlainODea: it's fast and handy
11:48:52 <magneticduck> but it's not cool >:|
11:48:55 <Cale> Writing anything nontrivial in bash is a good way to end up with an unmaintainable mess.
11:49:09 <AlainODea> Cale: +1
11:49:39 <magneticduck> hehe
11:49:49 <Cale> Before I knew about Haskell, I once wrote an entire IRC bot as what was effectively a single long bash pipeline with netcat at one end and a fifo to tie the knot.
11:50:00 <magneticduck> http://ix.io/aVN is an example of something that other people would do with a script
11:50:03 <Cale> It was cute, but making any kind of change to it was ridiculous :)
11:50:05 <Currier> I tend to only use bash when writing intricate command lines and rarely for scripting. My goto scripting languages are haskell and common lisp.
11:50:18 <magneticduck> it uses xinput to configure my default mouse in the way I like it
11:50:25 <AlainODea> magneticduck: Check out shelly.  It's a handy Haskell DSL for managing external command line calls. http://hackage.haskell.org/package/shelly
11:50:30 <magneticduck> (because I didn't want to learn how to set a default with xinput xD)
11:50:36 <johnw> shelly++
11:50:36 <magneticduck> it's suprisingly long though!
11:50:44 <magneticduck> lambdabot: mm sounds fun
11:51:25 <magneticduck> someday I'm going to really learn me a pipe / machines / io-stream
11:51:34 <magneticduck> >_><
11:51:39 <johnw> / conduit
11:52:13 <joelteon> use machines!!!!
11:52:15 <magneticduck> xD
11:52:22 <magneticduck> ^ a reason why I haven't started yet
11:52:30 <magneticduck> I'll have to learn all... 7 of them
11:52:32 <magneticduck> -=P
11:52:56 <johnw> in their basic forms of use, pipes/conduit are very simple
11:53:12 <johnw> if you've ever used await/yield in Python, then you know how to use them
11:53:54 <magneticduck> I can't say I have
11:54:10 <magneticduck> but I don't expect they're extremely complicated, having read the docs more or less
12:19:42 <FireFly> johnw: are they coroutiney?
12:20:37 <slack1256> pipes seems to be always at the top of the monad stack. That way you can uses their operators like >-> and friend. But if the pipes is in the middle of the stack, how to I compose them?
12:22:41 <nadirs> Hello everyone! One question about ".ghci" files: can I pass ghc flags (specifically the "-package-db" flag) via the ".ghci" file?
12:23:37 <tmhedberg> nadirs: You should be able to do that with the :set command
12:24:15 <tomejaguar> slack1256: Could use use 'hoist' from mmorph?
12:25:29 <nadirs> tmhedberg: I've created a cabal sandbox, so I added ":set -package-db=.cabal-sandbox/x86_64-linux-ghc-7.6.3-packages.conf.d" to the folder's .ghci, but it doesn't work
12:25:39 <tomejaguar> Or maybe you want to use 'liftM2 (>->)'.  Could you be more specific about what you're trying to do?
12:26:21 <tmhedberg> nadirs: I think you can launch ghci with "cabal repl" to make it work in a sandbox
12:27:27 <nadirs> tmhedberg: spot on! Thank you :D
12:29:49 <slack1256> tomejaguar: I just want to know the standard use when the pipe is in the middle of the stack instead of on top
12:30:10 <slack1256> although 'liftM2 (>->)' works
12:32:40 <NemesisD> hey guys. i'm having a weird issue where the haddocks disagree with ghc about the instances thyme's NominalDiffTime expose http://lpaste.net/100694
12:32:45 <NemesisD> anyone know what's going on?
12:33:55 <shiona> yesterday there was some talk about some extension that enabled question mark notation in types for holes. what was it?
12:35:09 <shiona> :t (==) :: Int -> ?a
12:35:10 <lambdabot>     parse error (possibly incorrect indentation or mismatched brackets)
12:35:13 <tomejaguar> NemesisD: If you click on the source for NominalDiffTime you will find the instance for Num is not defined in that module.
12:36:17 <geekosaur> shiona: ImplicitParameters
12:36:40 <shiona> geekosaur: thanks, what was my mistake in using it?
12:36:52 <NemesisD> tomejaguar: so i need to find where its coming from then?
12:36:56 <johnw> FireFly: yes
12:37:02 <geekosaur> you don;'t use it as a type, but as a value
12:37:25 <geekosaur> and the type of that value shows up in the inferred type
12:37:32 <geekosaur> TypeHoles is a different thing
12:37:41 <geekosaur> and doesn't use ?, it uses _
12:37:53 <geekosaur> :t ?a == ?b
12:37:55 <lambdabot> (Eq a, ?a::a, ?b::a) => Bool
12:38:00 <tomejaguar> NemesisD: Perhaps.  The meaning of the instance is unclear.  How do you multiply two NominalDiffTimes?
12:38:04 <levi> It's called TypedHoles now, isn't it?
12:38:05 <shiona> ah, right
12:38:08 <geekosaur> :t ?a == "foo"
12:38:09 <lambdabot> (?a::[Char]) => Bool
12:39:10 <NemesisD> tomejaguar: not sure. i'm looking for a way to get a POSIXTime from a literal, or even to produce a value of POSIXTime at all that isn't via the current clock
12:39:13 <tomejaguar> NemesisD: I guess it comes from INSTANCES_MICRO, which I guess is a CPP macro.
12:40:08 <NemesisD> tomejaguar: yeah i did see that. don't know why that isn't appearing to ghc/ghci
12:41:05 <tomejaguar> NemesisD: "Num, Real, Fractional and RealFrac instances for DiffTime and NominalDiffTime are only available by importing Data.Thyme.Time."
12:41:25 <tomejaguar> From the top of the Data.Time.Clock haddock.
12:41:40 <NemesisD> tomejaguar: man that's weird
12:41:43 <tomejaguar> But I'm not certain that really helps you.
12:41:55 <joejev> is there a standard way to get a [Word8] from a Word16, like doing something like: unsigned short s = 0xffff; unsigned char *c = &s;
12:42:02 <NemesisD> i think it does. i imported it and i see a num instance now
12:43:02 <tomejaguar> Sure, but it doesn't seem right somehow to use a Num instance for NominalDiffTime.
12:43:11 <tomejaguar> It makes the units implicit, for one thing.
12:43:22 <tomejaguar> But at least it gets you started.
12:44:07 <NemesisD> units are implicit for unix timestamps aren't they? seconds
12:44:31 <NemesisD> i'm using posix for serialization/deserialization from json
12:47:20 <tomejaguar> I guess for POSIXTime it makes more sense.
12:53:52 * hackagebot math-functions 0.1.5.1 - Special functions and Chebyshev polynomials  http://hackage.haskell.org/package/math-functions-0.1.5.1 (BryanOSullivan)
12:54:54 <johnw> NemesisD: I have a better way to serialize UTCTime to/from JSON
12:55:39 <johnw> NemesisD: https://gist.github.com/9355397
12:56:56 <mrgoodcat> anybody have a moment to help a newbie understand why his program isn't working?
12:57:34 <solarus> @where lpaste
12:57:34 <lambdabot> http://lpaste.net/new/haskell
12:58:16 <mrgoodcat> actually the code is already on the haskell wiki. http://www.haskell.org/haskellwiki/Roll_your_own_IRC_bot doesn't seem to work on my machine
12:58:56 <mrgoodcat> i can't even get networking working
13:00:12 <solarus> mrgoodcat: you probably need the network cabal package
13:00:31 <solarus> or why is it failing?
13:00:56 <mrgoodcat> i have the network package
13:01:01 <mrgoodcat> i'm just getting no output at all
13:01:47 <solarus> ok let me see
13:03:46 <solarus> hmm worked fine for me :)
13:04:18 <mrgoodcat> could it be specific to my machine for some reason? i copy pasted directly from the wiki when it didn't work the first time
13:04:25 <mrgoodcat> The Glorious Glasgow Haskell Compilation System, version 7.6.3
13:05:01 <solarus> It may be machine related but you figure that network should work on all platforms
13:05:50 <solarus> what do you get with "telnet irc.freenode.org 6667" from a terminal?
13:07:09 <mrgoodcat> trying 208.80.155.68...
13:07:12 <mrgoodcat> and stuck there
13:07:25 <zebr> @pl \f t (b,u) -> f b t u
13:07:25 <lambdabot> flip flip snd . (ap .) . flip flip fst . ((.) .) . flip
13:07:38 <zebr> maybe not, then :p
13:08:20 <milfjord> mrgoodcat: are you behind a firewall that blocks port 6667?
13:08:30 <jle`> zebr: lol
13:08:51 <jle`> maybe try something with uncurry/curry
13:08:53 <mrgoodcat> it is possible. i'm at school
13:08:56 * hackagebot Cabal 1.18.1.3 - A framework for packaging Haskell software  http://hackage.haskell.org/package/Cabal-1.18.1.3 (JohanTibell)
13:09:38 <jle`> mrgoodcat: how are you connecting to irc to chat?
13:10:09 <mrgoodcat> i'm ssh'd to a personal server
13:10:16 <mrgoodcat> irssi runs on it
13:10:25 <jle`> can you telnet on your server?
13:10:26 <solarus> so 6667 is probably blocked then
13:10:27 <mrgoodcat> the code runs fine on ther server
13:10:30 <jle`> ah
13:10:34 <mrgoodcat> must be blocked
13:10:38 <solarus> aha
13:10:39 <mrgoodcat> thanks for the help troubleshooting
13:11:51 <t4nk177> can haskell turn indirect tail recursion to loop?
13:12:18 <jle`> @faq can haskell turn indirect tail recursion to loop?
13:12:18 <lambdabot> The answer is: Yes! Haskell can do that.
13:13:00 <milfjord> function calls don't use the stack
13:13:32 <khyperia> does anybody know how GHC's (or any other HS compiler) parser works, specifically, parsing the whitespace-based nature of HS?
13:14:47 <jle`> khyperia: can yu be more specific? are you talking about the rules or the implementation?
13:14:50 <heatsink> The Haskell Report describes that in detail, khyperia.  Basically, the parser inserts braces and semicolons based on whether indentation increases, decreases, or stays the same.
13:15:30 <khyperia> Right. Forgot to add I'm making my own compiler that I'd like to be whitespace-based
13:15:41 <khyperia> and I'm trying to figure out how to implement it
13:15:48 <heatsink> IIRC, GHC's lexical analyzer tags each token with its indentation level
13:17:16 <heatsink> and the parsing rules match only if a constraint on the indentation level is satisfied
13:17:27 <khyperia> Right.
13:18:54 * hackagebot math-functions 0.1.5.2 - Special functions and Chebyshev polynomials  http://hackage.haskell.org/package/math-functions-0.1.5.2 (BryanOSullivan)
13:27:36 <heatsink> Hmm, it looks like the lexer also inserts braces.  The token name is vccurly.
13:28:55 * hackagebot cabal-install 1.18.0.3 - The command-line interface for Cabal and Hackage.  http://hackage.haskell.org/package/cabal-install-1.18.0.3 (JohanTibell)
13:39:53 <Xashie> hi
13:40:11 <artyomkazak> greetings, earthling
13:40:24 <Xashie> what is the best lib for date/time manipulation for haskell newbies?
13:40:32 <kadoban> does anyone use haskellmode-vim? i'm having this issue with it where every time I restart vim, it has to rebuild its haddock index, which takes forever, before i can use any of the haddock-ish features
13:40:49 <Xashie> basically my use case will be iteration through dates and manual creation of dates
13:41:11 <kadoban> Xashie: Data.Time has quite a bit of useful stuff in it, depending on what you need
13:41:30 <kadoban> Data.Time.Clock and Data.Time.Calendar i've used often enough, for simple stuff
13:41:50 <Xashie> okay, thanks
13:42:34 <artyomkazak> kadoban: is there some agreed-upon âbest replacement for Data.Timeâ?
13:42:39 <artyomkazak> like text for Strings
13:43:12 <kadoban> artyomkazak: i wouldn't know, that's the extent of the date/time functionality i've ever used in haskell
13:43:57 * hackagebot pipes-binary 0.4.0.1 - Encode and decode binary streams using the pipes and binary libraries.  http://hackage.haskell.org/package/pipes-binary-0.4.0.1 (RenzoCarbonara)
13:43:59 * hackagebot digestive-functors-heist 0.8.5.0 - Heist frontend for the digestive-functors library  http://hackage.haskell.org/package/digestive-functors-heist-0.8.5.0 (JasperVanDerJeugt)
13:46:06 <chrisw__> I just got into GUI programming with GTK and I'm wondering how to save the state of the program across callbacks and how to redraw when a mouse click happens.
13:48:29 <Xashie> what do you think about fgl vs data.graph from containers?
13:51:43 <jle`> artyomkazak: it is going to be the one that you make :)
13:52:01 * jle` plays inspirational music
13:53:58 * hackagebot fixedprec 0.2.2.0 - A fixed-precision real number type  http://hackage.haskell.org/package/fixedprec-0.2.2.0 (PeterSelinger)
13:54:36 <slack__> how can pipes have 5 categories and I can't understand any on them
13:55:20 <tomejaguar> slack__: You can definitely understand the one that's just gluing pipes end to end.
13:55:55 <slack__> the >-> one?
13:58:04 <johnw> all that it takes to be a category is to have associative composition and an identity.  So, >-> and idP form a category.  There's not much more to it than that
13:58:10 <johnw> I really solicited
13:58:22 <tomejaguar> slack__: I believe >-> is the one.
13:58:25 <johnw> sorry, speech-to-text caught something from a TV show :)
13:58:51 <Xashie> anyone?
13:59:10 <johnw> Xashie: I am without opinion on that one
13:59:49 <tomejaguar> johnw: You use speech-to-text for IRC?
13:59:54 <slack__> graphs are complicated
13:59:58 <slack__> let's use arrays
14:00:03 <slack__> wait those are also complicated
14:00:08 <johnw> tomejaguar: at times
14:00:22 <Xashie> used fgl previously it was not bad but now it's dead :/
14:02:04 <Xashie> Data.Graps types are awful
14:02:30 <Xashie> (Graph, Vertex -> ([Char], [Char], [[Char]]), [Char] -> Maybe Vertex) stinks
14:02:35 <tomejaguar> Pipes.Core claims that >-> isn't one of its five categories, but maybe it's talking only about Proxy
14:02:51 <Xashie> i'd like to wirte something like Graph String String
14:02:54 <prinsen> apis'' <- mapM (\exp -> $(exp)) apis' makes GHC panic
14:03:04 <prinsen> nameModule exp{v abZub}
14:03:59 * hackagebot statistics 0.11.0.0 - A library of statistical types, data, and functions  http://hackage.haskell.org/package/statistics-0.11.0.0 (BryanOSullivan)
14:04:01 * hackagebot monoid-extras 0.3.3 - Various extra monoid-related definitions and utilities  http://hackage.haskell.org/package/monoid-extras-0.3.3 (BrentYorgey)
14:04:37 <joejev> Can someone explain why I am getting overlap warnings? http://lpaste.net/100681
14:04:52 <Xashie> i probably go with dead one rather than bad one
14:05:40 <prinsen> Can I post questions about GHC panics here?
14:06:14 <joneshf-work> is there a standard way to add sandboxes to the path when you enter a folder with sandboxes?
14:06:40 <Xashie> prinsen: it's probably will be more productiove to post it on #ghc
14:08:37 <Xashie> johnw: you're nice guy, thanks anyways
14:08:41 <koala_man> joejev: you have definitions for 0, 1, 2 and 3+ parameters, and then a catch-all for the rest
14:09:34 <jonsterling> Digestive Functors question. I'm trying to do a choice form (with a select control), where depending on the current state, only a subset of the options will be given. The problem is that I can't figure out how to propagate the information about which of the options when I'm trying to interpret the form's post request.
14:09:39 <joejev> koala_man, so just drop the wildcard?
14:09:42 <jonsterling> Any ideas on what the right way to do what I'm trying to do is?
14:10:08 <koala_man> joejev: yes, it'll never match anything so ghc warns about it
14:10:30 <joejev> koala_man: ty, sleepy code makes magic and headaches
14:14:32 <prinsen> How would one transform a [Exp] to Exp?
14:16:27 <geekosaur> prinsen: how many entries in the [Exp]?
14:16:46 <jonsterling> Oh, looks like `choiceWith` will suffice...
14:17:43 <prinsen> geekosaur: let me give some context, Im writing a function that takes a 'TH' object (with some Name fields) and creates a 'Runtime' object (with fields = $(NameField))
14:18:27 <prinsen> geekosaur: so my transformfunction should have the type THType -> Q Exp
14:18:49 <prinsen> I have a list of THTypes so i mapM over it, resulting in a [Exp]
14:19:01 <prinsen> which i can't do anything with :p
14:19:15 <geekosaur> yes. you have a list. you want a single item.
14:19:27 <zcd> hi
14:19:32 <zcd> what does it mean to deifne something as an operator?
14:19:36 <t4nk232> are there examples of edwardk 's reflection library being used to read/set configurations based on a file?
14:19:42 <zcd> i'm working on the 99 problems and not quite understanding what 47 is asking for
14:19:44 <prinsen> Well its a list of Exp representing items, I want an Exp representing a list
14:19:53 <geekosaur> the trivial answer is head, but that gets you the first element... and I have no way of knowing if you want that, or some way of picking a specific item from the list, or somehow combining them
14:20:15 <joelteon> isn't that listE?
14:21:09 <prinsen> joelteon: You might by a hero, 2 secs
14:21:11 <Lee_Dunn> email me.. I like gay sex...    dunn1055@gmail.com
14:21:29 <ski> zcd : `xs /\/ ys = ..xs..ys..' as opposed to `interleave xs ys = ..xs..ys..' ?
14:21:37 <kadoban> zcd: it might mean just give them precidence that will make them function in the normally expected way, using infixl, infixr or the like
14:21:43 <davd> prinsen: either you're looking for something like "[m a] -> m [a]" or wrapping [Exp]Â with a constructor.
14:22:12 <kadoban> precedence*
14:22:28 <prinsen> davd: joelteon thanks, I somehow tought that ListE wants a Exp
14:22:56 <davd> is 'tel' active in here? I've a few questions regarding his latest comment in the pipes-thread on reddit.
14:23:03 <fizbin> zcd: It's asking for precedence. However, to know that I cheated and looked at the solution.
14:23:10 * ski . o O ( "predecency" )
14:23:32 <fizbin> Because the question uses enough parens that precedence doesn't come up.
14:24:19 <zcd> oh thanks
14:24:32 <zcd> fizbin: i was hoping to solve without the solution hehe
14:26:16 <ski> davd : seems to be online ..
14:26:28 * ski vaguely str seeing `tel' somewhere
14:26:35 <fizbin> Though it might be nice to recast questions 46-48 as questions for learning template haskell, where for "table" in question 46 you need to write a custom quasiquoter that emulates what the lisp version does.
14:27:16 <davd> ski: yeah, I'll reach out to that nick.. assumed that he would be in here. thanks!
14:27:28 <merijn> fizbin: Implementing TH quasiquoters isn't really a beginner haskell assignment, though :p
14:27:35 <fizbin> No.
14:29:11 <jml> when I run 'cabal update' or try to cabal install a package on my laptop, I get this:
14:29:13 <jml> Warning: http error: Network.Browser.request: Error raised ErrorParse "Invalidcabal: Char.intToDigit: not a digit -1
14:29:29 <jml> what's going on?
14:29:52 <jml> not sure how I can debug it
14:29:53 <fizbin> merijn: Though the lisp original seems to think that defmacro is a beginner lisp assignment.
14:32:13 <merijn> fizbin: Well, I guess it depends on the masochism theshold of the person practicing ;)
14:33:24 <fizbin> Also, defmacro (especially if you don't care about making it hygenic with gensym) is really not much more difficult to wrangle than defun, whereas the jump from haskell functions to template haskell is a bit extreme.
14:37:09 <ski> (also, `gensym' isn't enough to make things hygienic)
14:40:45 <mljsimone> https://gist.github.com/mljsimone/df00fbaa43878fe9e2cc
14:40:48 <mljsimone> any ideas?
14:40:54 <fizbin> ski: True, it's not sufficient by itself, but if you don't care enough to use gensym when you should I doubt you care about anything else macro-hygiene-related either.
14:41:45 <geekosaur> mljsimone, your ghc is too old for that package
14:42:07 <geekosaur> "base" is the ghc runtime, it can't be upgraded without upgrading the compiler. that package wants base-4.6
14:42:22 <geekosaur> your ghc came with base-4.5
14:43:04 <dwat3r> hi,has anyone experience with Network.Pcap module? I'm trying to write simple ping utility.
14:43:11 <mljsimone> geekosaur: oh!
14:43:35 <mljsimone> geekosaur: so, I need to get an updated haskell-platform?
14:43:41 <geekosaur> updated ghc
14:43:42 <Currier> I've been playing around with Persistent for a bit, but the example code (from the Yesod book) keeps giving me a parse error on line 15 that has to do with quasi-quting and template haskell, I'd imagine. does anyboy have any clue what might be causing it? code here: http://lpaste.net/6110020282016071680
14:43:51 <geekosaur> (you'd probably need an updated platform to go with it, yes)
14:44:07 <Currier> parse error (possibly incorrect indentation)
14:44:19 <krgn> good evening
14:44:27 <mljsimone> yeah, ghc is coming from that package (ubuntu rep.)
14:44:49 <benmachine> Currier: if it helps, it is widely agreed that that error message should say "parse error (probably not incorrect indentation)"
14:45:30 <benmachine> Currier: which version of GHC are you using? the syntax for this changed not so long ago
14:46:03 <benmachine> Currier: if you're on something sufficiently old, you might try wrapping from "share" to the closing |] in $(...)
14:46:15 <joelteon> is there a library that can parse distinguished names
14:46:17 <benmachine> Currier: that should work on new things as well, I think, it's just uglier
14:46:21 <Currier> benmachine: 7.4.2
14:46:25 <joelteon> from X509 certificates?
14:46:27 <Currier> I'll give it a try
14:46:27 <benmachine> Currier: oh, there goes that theory
14:46:32 <benmachine> sure, can't hurt
14:46:36 <joelteon> I tried asn1-parser but it takes binary (only?)
14:46:37 <benmachine> might at least get you a better error
14:47:04 <benmachine> joelteon: oh, that kind of distinguished name
14:47:17 <benmachine> not, like, Professor Sir Roger Penrose
14:47:24 <Currier> benmachine: nope, still the same error message, I'm afraid
14:47:27 <benmachine> Currier: :(
14:47:35 <joelteon> Yeah, I'm talking about a string like /C=AU/CN=localhost/...
14:47:52 <joelteon> like I would be able to write a parser myself but I'd like to use an existing library if I could
14:47:54 <joelteon> NIH
14:49:04 * hackagebot Spock 0.4.2.1 - Another Haskell web toolkit based on scotty  http://hackage.haskell.org/package/Spock-0.4.2.1 (AlexanderThiemann)
14:49:35 <Currier> benmachine: as far as I unsderstand, [...| ... |] is quasiquotation, is that right?
14:49:42 <joelteon> yep
14:49:57 <benmachine> Currier: as long as the [...| bit has a name jammed in there with no spaces
14:50:08 <benmachine> as it indeed does in your case
14:50:25 <benmachine> Currier: actually no I guess it always i
14:50:26 <benmachine> s
14:50:42 <benmachine> but they look very similar to list comprehensions
14:50:53 <Currier> hm, might just look into that some more to start off with, it's something that looks interesting in any case. I was just hoping to get the whole databases thing working tonight, but I can put that off and do some more studying, I guess. should do me good.
14:55:42 <Currier> in any case, thanks. I'll try to figure it out, but do let me know if an epiphany strikes
14:55:47 <krgn> I have a question: I'm receiving some xml response via Network.HTTP.Conduit (simpleHttp) and transform the result into a strict bytestring. when I convert the it from bytestring to utf8 string with the toString function, the umlauts etc are still borked
14:55:48 <krgn> I though that if I convert a bytestring into string via utf8-string it should show up correctly, by apparently not
14:56:38 <kgadek> hi all. Wannabe-haskeller here. Friend asked me 'how come naive factorial is so fast?'. Impossible as it looks, but... it is indeed. Where's the magic? Here are results from Criterion, source files and Core dumps: https://gist.github.com/kgadek/9357070#file-results-txt . How can I verify & why did TCO happened?
14:57:12 <kgadek> https://gist.github.com/kgadek/9357070#file-naive-core-hs-L21 <-- here is some counterproof to TCO... or is it?
14:58:11 <geekosaur> TCO is kinda not a thing
14:58:33 <geekosaur> more precisely, it is only meaningful in the context of imperative evaluation
14:59:11 <geekosaur> haskell does not use an imperative call stack, so an optimization pertaining to imperative call stacks is not meaningful
14:59:17 <Cale> Er, strict evaluation, you mean
14:59:24 <geekosaur> yeh
14:59:56 <kgadek> oh, ok. so what does happen then?
14:59:58 <Cale> (i.e. innermost-first, rather than lazy evaluation which is outermost-first + sharing)
15:00:28 <Cale> However, if you're compiling with optimisations, GHC will do strictness analysis and reorder things.
15:02:25 <kgadek> so GHC can add accumulator by itself then?
15:03:29 <Axman6> usually no, I'd expect that to take a long time to evaluate in haskell or cause a stack overflow
15:04:06 * hackagebot Spock-worker 0.1.0.0 - Background workers for Spock  http://hackage.haskell.org/package/Spock-worker-0.1.0.0 (AlexanderThiemann)
15:04:37 <Cale> Well, it's only 10000
15:04:55 <Cale> There's no way that's causing a stack overflow :P
15:05:09 <Cale> The integer multiplication is going to take *most* of the time in this program
15:05:22 <Cale> Regardless of how you manage everything else
15:05:38 <Axman6> yeah, my thinking was that 10000 is too low too
15:06:22 <kgadek> okay, right... incremented 100x and
15:06:22 <kgadek> Stack space overflow: current size 8388608 bytes.
15:06:23 <kgadek> Use `+RTS -Ksize -RTS' to increase it.
15:06:30 <kgadek> so this is it then.
15:06:39 <Cale> Provided the stack doesn't overflow, any costs associated with that will be dwarfed by the costs of dealing with the large numbers
15:06:41 <Axman6> yes
15:08:02 <kgadek> ok, this now makes sense. Thanks!
15:08:04 <Cale> (Those costs are linear in n, while the size of the output is exponential in n.)
15:08:50 <kgadek> yes, I had fib in the back of my mind so... stupid me. thanks again :)
15:08:58 <Cale> Er, is that true? n! is exponential in n, so no, its size is again linear in n.
15:09:07 <benmachine> Cale: super-exponential, no?
15:09:07 * hackagebot Spock-worker 0.1.0.1 - Background workers for Spock  http://hackage.haskell.org/package/Spock-worker-0.1.0.1 (AlexanderThiemann)
15:09:15 <kgadek> O(n log n) probably
15:09:53 <Cale> oh, right it's O(n^n)
15:09:56 <benmachine> ish
15:10:04 <Cale> which when you take the log will be O(n log n)
15:10:04 <Feuerbach> log(n!)=sum from 1 to n which is ~ n^2/2
15:10:25 <kgadek> ok, you're right
15:11:00 <kgadek> so this is O(n^3), isn't it
15:11:39 <Cale> log(n!) = sum over k = 1 to n of log(k) <= sum over k = 1 to n of log(n) = n log(n)
15:11:58 <kgadek> I mean the whole algorithm
15:12:34 <Cale> Right, that's just the size in bits of the result... so, we have to consider the work which will be done to multiply those numbers
15:12:35 <Feuerbach> Cale: oops, sure
15:14:35 <quchen> There is no `sort` in the vector package!?
15:14:47 <quchen> Am I missing something?
15:14:50 <artyomkazak> quchen: yep :(
15:14:53 <Cale> GMP uses a whole litany of algorithms for integer multiplication depending on the sizes of the arguments
15:15:01 <artyomkazak> quch
15:15:05 <artyomkazak> oops
15:15:24 <artyomkazak> quchen: use vector-algorithms
15:15:38 <benmachine> log(n!) = n log n - n + O(log n), apparently
15:16:30 <quchen> benmachine: See Stirling's formula
15:16:46 <benmachine> quchen: if by "see" you mean "lift directly from the wikipedia page of", then yes
15:16:58 <jle`> i wish there was a way for ad-hoc type synonyms...'where' clauses for type signatures
15:17:08 <quchen> n log(n) is already a very good approximation for log(n!)
15:17:09 <jle`> maybe throw-away is a better word
15:17:13 <benmachine> jle`: me too
15:17:26 <benmachine> jle`: actually I wish you could have data types in where as well, but that's a bit bolder
15:17:30 <benmachine> your thing is also good
15:17:35 <benmachine> not sure how you'd pretty-print them though
15:18:02 <jle`> data types?
15:21:02 <benmachine> jle`: sure
15:21:09 <jle`> how do you mean
15:21:20 <benmachine> let data Maybe a = ... in ...
15:21:22 <jle`> data types declared in scope for a single function?
15:21:24 <jle`> ah
15:21:25 <benmachine> not sure what for :P
15:24:09 * hackagebot pipes-text 0.0.0.10 - Text pipes.  http://hackage.haskell.org/package/pipes-text-0.0.0.10 (MichaelThompson)
15:25:24 <quchen> Is there a library for an aging bloom filter, i.e. one that eventually forgets previously set values?
15:40:44 <chrisw__> Does anyone know how to rotate and render to a GTK Image using Cairo? I have loaded an image to a Pixbuf from file, but I don't know how to get it into Cairo and back.
15:44:23 <Galactic> Hello...is anyone here from Orlando Florida (USA)?
15:50:16 <ski> jle` : locally declared types could be very nice
15:50:34 <Twey> benmachine: What's the type of: let data Foo a = Bar a | Baz Int in Baz 3  ?
15:50:54 <ski> even if only used with an SML-like `local'-type construct, rather than properly inside `let'/`where'
15:50:55 <benmachine> Twey: probably an error
15:51:11 <benmachine> Twey: maybe a type that you can't actually name from outside
15:51:12 <ski> Twey : type error in SML, local type escapes
15:51:21 <ski> it basically behaves as an existential
15:52:00 <Twey> Ahuh
15:52:54 <Twey> I suppose ideally it should just be an opaque type
15:52:57 <ski> (by which i mean that `Foo' itself is existentially quantified. not that one of its data constructors has an essentially existentially quantified argument type)
15:53:17 <Twey> Aye
15:54:03 <ski> Twey : what about `foo :: forall a. ..a.. -> ..a..; foo ..x.. = ..x..Foo.. where data Foo = Bar a | Baz Int' ?
15:54:20 <ski> (note that since `a' is already in scope, it needn't be a parameter of `Foo')
15:55:46 <ski> also, depending on the arguments of `foo', which decide in which defining equation of `foo' we end up in, we could use different definitions of `Foo' (or none at all, in some cases)
15:55:47 <benmachine> Twey: it would be neat if you could pass the value around but not do anything with it except give it back to the function that knows about it
15:55:55 <Dinkar_> a general question on using desktop ui: I am debating to using wxHaskell or wxPython (only because it seems to be better supported). Does anyone have an opinion on wxHaskell: pain points or are things smooth after the initial install?
15:56:12 <ski> so `Foo' may depend not only on type parameters, but also on value parameters
15:56:38 <ski> (you can do something similar with existentials)
15:57:53 <Twey> ski: Yeah, I was about to respond to benmachine with that :Ã¾
15:58:23 <ski> benmachine : ok, like an `abstype' declaration in SML, or like restricted type synonyms in Hugs <http://cvs.haskell.org/Hugs/pages/hugsman/exts.html#sect7.3.5>
15:58:40 <benmachine> ski: yes, I suppose so
15:58:45 <benmachine> well
15:58:50 <benmachine> I've not used SML, but sure
15:58:58 <Twey> I guess you can say something like foo 3 â· foo@Int.Foo
15:59:18 <benmachine> no because that's weird
15:59:34 <ski> (`abstype' is like `data' in Haskell, while restricted type synonyms is like `type' -- otherwise they are similar)
15:59:59 <Twey> benmachine: But it's a different type depending on the parameter passed in (I don't mean that type to be usable from outside, mind â that would be weird, indeed)
16:01:16 <ski> Twey : with `foo :: (n :: Integer) -> (t :: *,t)', `snd (foo 3) :: fst (foo 3)' would make sense, more or less
16:02:46 <ski> Twey : .. though being able to refer to the type from outside could be useful in the interactor, or some other debugger (or perhaps only have it visible if you "step into" the function, ior set a breakpoint inside it, and then inspect the environment at that point)
16:03:21 <carter> hey all
16:03:45 <Twey> ski: That's true.  I've often felt âwhereâ clauses harm GHCi-based debugging.
16:04:01 <Twey> But that's not restricted to local types
16:04:07 * ski nods
16:04:13 <carter> i have a weird type error when trying to write a statically sized list Fold
16:04:13 <carter> http://lpaste.net/100696
16:04:16 * hackagebot wai-predicates 0.1 - WAI request predicates  http://hackage.haskell.org/package/wai-predicates-0.1 (ToralfWittner)
16:04:21 <carter> anyone around to help?
16:04:33 <carter> or should i pester on other channels?
16:04:58 <carter> dcoutts: any chance i can get your attention?
16:04:59 <Rembane> carter: Wait a moment with the pestering
16:05:10 <carter> Rembane: who are yah :p
16:05:34 <carter> i can switch to #*lens or #numerical*
16:05:53 <Rembane> carter: The anti-pestering bot. :D
16:05:58 <carter> lies
16:08:27 <carter> ok
16:08:29 <carter> anyone around
16:09:02 <carter> who wants to help debug why writing some GADT code direct style type checks, but work wrappered it doesnt
16:09:36 <Twey> carter: Monomorphism?
16:09:40 <carter> ohhhh
16:09:56 <Twey> carter: âgoâ gets its type inferred to be â¦ Shape n a â¦ and then you call it with a Shape r a
16:10:09 <carter> Twey: i've tried with explaicit types too...
16:10:21 <Twey> Stick the explicit type in and re-paste?
16:10:39 <Twey> The error might be more helpful
16:15:56 <joelteon> GHC 7.8's memory usage is pretty impressive
16:16:07 <joelteon> 12.59GB
16:16:45 <mirpa> joelteon: why, where?
16:16:49 <heatsink> Is that how much disk space you need to build it from source?
16:17:01 <jle`> lmao
16:17:10 <joelteon> looks like it's building thyme
16:17:18 <Javran> I'm trying to understand what is CoArbitrary in QuickCheck, can someone point me to some related articles?
16:17:29 <carter> Twey: switching to #haskell-lens
16:17:31 <carter> http://lpaste.net/100696
16:17:52 <joelteon> I need to build a computer with 64GB of RAM
16:17:54 <joelteon> that should do it
16:18:10 <carter> joelteon: that sounds like a bug.....
16:18:24 <joelteon> i'll try to reproduce it
16:18:37 <joelteon> there are bugs I can't file because I can't reproduce them
16:18:39 <joelteon> they're the worst
16:18:42 <Twey> carter: Why?  You haven't even used lenses :Ã¾
16:18:43 <heatsink> carter: The 'b's in the outer and inner type signatures are different type variables
16:19:01 <carter> heatsink: but they're scoped type variables....
16:19:22 <heatsink> I'm pretty sure you need an explicit forall in at least one of the two type signatures
16:19:31 <Twey> carter: No they aren't â you didn't introduce b with a â
16:20:55 * heatsink can't remember how ScopedTypeVariables works without explicit forall
16:21:25 <carter> gahhhhhh
16:21:25 <carter> ok
16:21:27 <carter> thanks
16:21:32 <carter> i feel less crazy now
16:22:04 <Twey> heatsink: It doesn't
16:22:05 <ski> heatsink : with no explicit `forall', no scoped type variables, simple as that :(
16:22:24 <heatsink> o i c
16:23:11 <carter> thanks everyone
16:23:18 <carter> i thought i was going insane
16:23:35 <benmachine> isn't there something about type variables in class declarations as well?
16:23:36 * ski thinks it doesn't make any sense that *with* an explicit `forall', the variables are in scope in the defining equations, but *without* it, they aren't
16:23:43 <ski> (it's completely backwards)
16:24:12 <carter> benmachine: yeah... they dont need a forall :(
16:24:55 <ski> yes, type variables from the header for `class' is in scope in the method signatures
16:25:09 <ski> iirc the ones from the header for `instance' is in scope in the method bodies ?
16:25:09 <Twey> Even without a â?
16:25:14 <carter> yup
16:25:20 <ski> surely for the former, at least
16:25:37 <ski> (not sure about default implementations)
16:34:19 * hackagebot system-command 0.0.8 - A replacement for System.Exit and System.Process  http://hackage.haskell.org/package/system-command-0.0.8 (TonyMorris)
16:39:20 * hackagebot purescript 0.4.3 - PureScript Programming Language Compiler  http://hackage.haskell.org/package/purescript-0.4.3 (PhilFreeman)
16:42:30 <Javran> Hi, can some one point me to documents that can help me understand CoArbitrary from QuickCheck?
16:44:31 <quchen> Javran: How would you generate an Arbitrary instance for (a -> b)?
16:45:06 <ski> .. anyway, i think the `PatternSignatures' version where type variables are bound by the definiendums in the defining equations generally makes more sense, since type signatures can be separated from the corresponding defining equations, and a type signature can simultaneously specify the type for several values at the same time
16:45:34 <quchen> Javran: Arbitrary provides a function `arbitrary :: Arbitrary a => Gen a`. This allows you to access a random value of some type.
16:45:51 <quchen> But when you want to have a random function, you can't draw a single random value.
16:46:06 <quchen> What you need is a function that randomly, but deterministically, gives you some output for some input.
16:46:21 <ski> (and since the defining equations are logically independent, i think it makes sense to allow differently named type variables to be in scope in different defining equations of the same value -- this could make even more sense if we had (nontrivial) examples of a defining equation defining multiple things)
16:46:49 <ski> (.. also, i miss being able to attach result types for `PatternSignatures')
16:47:51 <letrec> Any good way to have something similar to mapM_ but with an index? I came up with  mapMI_ f l = mapM_ (uncurry f) (Prelude.zip l [0..])
16:49:21 * hackagebot purescript 0.4.3.1 - PureScript Programming Language Compiler  http://hackage.haskell.org/package/purescript-0.4.3.1 (PhilFreeman)
16:50:02 <ski> letrec : iirc, there's some lens thing for that
16:50:23 <levi> An indexed traversal or something?
16:50:31 <merijn> letrec: Well, the uncurry + zip isn't particularly bad, IMO
16:50:48 <ski> letrec : otherwise, `mapMI_' sounds fine, except i'd change the ordering to index-element, `mapIM_'
16:51:38 <merijn> letrec: Basically, I think it doesn't exist because it's so easy to define...
16:51:57 <letrec> ski: merijn: Ok, thanks :)
16:52:41 <ski> e.g. in OCaml we have
16:52:43 <ski>   val mapi : (int -> 'a -> 'b) -> 'a array -> 'b array
16:52:45 <ski> and in SML
16:52:48 <ski>   val mapi : (int * 'a -> 'b) -> 'a vector -> 'b vector
16:53:28 <Javran> quchen: thanks, is that saying for `coarbitrary ::  a -> Gen c -> Gen c`, use the first argument as a "seed" to perturb the second argument, so we end up with a deterministic `Gen c`?
16:53:36 <k_89> can someone please help with this : http://lpaste.net/100700
16:53:58 <quchen> Javran: Exactly.
16:54:40 <Javran> quchen: thanks, this is helpful!
16:54:52 <quchen> You can also think of it as generating a function by randomly filling out the table of values.
16:55:13 <quchen> And since you're using a pseudo-RNG with known seen, that "random" filling can be seen as a function.
16:55:20 <quchen> s/seen/seed/
16:55:33 <letrec> k_89: http://lpaste.net/100701 ?
16:55:33 <ski> Javran : to make a random function of type `a -> b', start with a pseudo-random generator of type `Gen b' for making results of type `b' (independent of the input of type `a'); then for any actual input of type `a', perturb the generator of type `Gen b' into a new one, using the input of type `a', before using the generator to generate a `b'
16:56:13 <k_89> oh
16:56:18 <k_89> ...
16:56:27 <letrec> :)
16:56:31 <k_89> thanks
16:56:46 <letrec> Sure
16:56:58 <quchen> Or yet another way to look at it,  flip coarbitrary generator :: a -> Gen c
16:57:58 <quchen> ~ a -> c   for some value of ~
17:01:08 <Javran> ski: I see, so `Gen b` now also depends on `a`.
17:01:49 <Javran> quchen: what do you mean by "coarbitrary generator" ?
17:02:27 <Javran> isn't that `coarbitrary ::  a -> (Gen c -> Gen c)` ?
17:03:02 <quchen> I meant that "flip coarbitrary"'s type almost looks like a function "a -> c".
17:04:22 <letrec> In the signature uncurry :: (a -> b -> c) -> (a, b) -> c , can c really be a Monad (like IO d) ? I thought c was supposed to be an actual value (Like Int, String...)
17:04:45 <quchen> c can be anything.
17:04:49 <ski> letrec : `IO d' isn't a monad, `IO' is a monad
17:05:07 <ski> letrec : also, `c' is a type, as are `Int',`String'. those are not actual values
17:05:09 <Maxdamantus> though it can't be IO
17:05:21 <letrec> Yes sorry. So c can be IO d?
17:05:43 <quchen> :t uncurry (undefined :: a -> b -> IO c)
17:05:43 <lambdabot> (a, b) -> IO c
17:06:02 <ski> letrec : generally `c' is to be the value of some type -- or a "concrete type" also sometimes called an "inhabitable type"
17:06:20 <dwcook> letrec, values :: IO d aren't "not real" in any sense; they're quite real, but you might be confused about what they are.Â They're simply descriptions of computations that result in a d.
17:06:22 <Maxdamantus> :t uncurry (undefined :: a -> b -> IO)
17:06:23 <lambdabot>     Expecting one more argument to `IO'
17:06:23 <lambdabot>     In an expression type signature: a -> b -> IO
17:06:23 <lambdabot>     In the first argument of `uncurry', namely
17:06:37 <ski> letrec : `IO',`Maybe',`Either' (and `Either String') are all incomplete types, they are not concrete, you can't have a value of any of those types
17:07:12 <Javran> quchen: but flipping coarbitrary gives me `Gen c -> a -> Gen c` ?
17:07:32 <ski> letrec : otoh, `IO d',`Maybe Integer',`Either (String,s) Double' are all concrete types (given a concrete choice of a type for `d' and for `s')
17:07:34 <quchen> Javran: Right, and when you apply that to "generator :: Gen c" you get a `a -> Gen c`.
17:07:43 <quchen> Hence the "generator" after my first flip :-)
17:08:09 <Javran> quchen: oh, I see your point, that makes sense!
17:08:22 <ski> letrec : a value of type `IO d' for some type `d' is often known as a "monadic action" or an "`IO'-action"
17:08:42 <quchen> Maybe I didn't phrase it in a very helpful way above. ski's answer probably said the same but better.
17:09:15 <Javran> quchen: I understand that one too.
17:09:18 <ski> letrec : an `IO'-action, like `getLine', which has type `IO String' btw, is a real actual value -- however it is distinct from any `String' you might get by *executing* that action value
17:09:30 <ski> @quote /bin/ls
17:09:31 <lambdabot> shachaf says: getLine :: IO String contains a String in the same way that /bin/ls contains a list of files
17:09:42 <ski> letrec : does that help ?
17:09:52 <darkf> I'm trying to implement an interpreter for the lambda calculus, but I'm stuck on applying applications. that is, ((Î»x.Î»y.x) 10) 20 since, when applying an application, I don't know what to bind my value to, since it's not an abstraction. How to approach this?
17:10:19 <Javran> I thought fliping a -> (Gen c -> Gen c) would give me (Gen c -> Gen c) -> a ...but GHCi just told me I was wrong ...
17:10:38 <Cale> darkf: reduce the application first, and hope that it'll turn into an abstraction
17:10:52 <ski> darkf : first reduce â(Î» x. Î» y. x) 10â
17:11:07 <quchen> Javran: If flip would invert any function Haskell would be a lot more popular ;-)
17:11:09 <geekosaur> Javran, (->) is right associative
17:11:44 <geekosaur> a -> (Gen c -> Gen c) is the same as a -> Gen c -> Gen c
17:11:54 <Javran> quchen: just out of curiosity, what does the "Co-" mean in this sense?
17:13:25 <Javran> geekosaur: I added that parentheses on purpose, because I wrongly thought fliping means "foo -> bar" -> "bar -> foo"
17:13:31 <darkf> Cale, ski: currently when I encounter a variable I just try to look it up in the environment, instead of treating it like a free var; so, if I evaluate the term first, it will get caught on the free var. should I just leave free vars unevaluated?
17:14:05 <quchen> That's probably a question for Cale. My guess would be that while Arbitrary maps to values, CoArbitrary maps from them. But there's probably a deeper truth behind it. There is always one.
17:15:09 <Cale> darkf: All your variables should be bound...
17:15:21 <Cale> darkf: In fact, you won't even encounter a variable in this case
17:15:44 <Javran> quchen: I heard Haskeller just Co-everything, but I just started looking at typeclassopedia, might be that topic is far from accessible for me.
17:16:50 <Cale> darkf: Remember that (\x.\y.x) means (\x. (\y. x))
17:18:01 <quchen> Javran: Some libraries are based on mathematical models from category theory and actually use co-things. Most likely you'll never need to know much more about it than that it means something like "opposite" or "in the other direction".
17:18:05 <steamboat> I'm fooling around with Netwire and I'm running into the limits of my comprehension vis-a-vis Arrows. http://lpaste.net/100703
17:18:13 <kadoban> anyone use haskellmode-vim and know how to get it to stop having to rebuild its whole haddock index every time i restart vim? it sure takes forever
17:18:27 <steamboat> I know that Wire s e m should be an arrow, but I'm not quite sure how to express that
17:18:32 * ski stares at letrec
17:18:48 <quchen> à² _à²  The internet conversation end problem
17:18:52 <kadoban> or anyone have any general haskell vim integration suggestions maybe?
17:19:34 <darkf> Cale: hm, when evaluating ((Î»x.Î»y.x) 10) 20 it will evaluate (Î»x.Î»y. x) 10, which comes out as Î»y.x with x bound to 10, but when it's passed back up to the outer application, x is no longer in the environment. should I also have a substitition function which replaces all instances of x with their bound value? :D
17:20:10 <quchen> Javran: The only thing I can come up with that one might end up using every once in a while is comonad, and even for that you don't need to know what the co means.
17:20:27 <Javran> quchen: oh .. category theory again ... I'd better keep that part as a thunk for now : (
17:20:42 <quchen> Also see this. https://gist.github.com/quchen/5284753
17:20:43 <ski> darkf : you should either do explicit substitution of variables inside lambdas, or bundle the lambda with the environment in force when evaluating it (iow a closure)
17:21:13 <ski> darkf : the latter is "merely" an optimization, delaying the substitution until you look up the variables in the body of the lambda
17:21:35 <darkf> ski: alright, that makes more sense (this is weird to me because I _have_ implemented languages with closures before, I just get stuck onLC :))
17:21:53 <darkf> thanks :)
17:21:56 <Javran> quchen: these two lists are eqivalent!
17:22:47 <ski> darkf : then, when you have an application, the operator should reduce to a closure, and you should then use the stored environment (after augmenting it with a binding for the formal parameter to the actual parameter). *not* the actual environment in force for the application (though you should still use that for the actual parameter, the operand)
17:24:24 <darkf> ski: alright, thanks!
17:25:32 <letrec> ski: I get it, thanks!
17:25:56 <ski> letrec : yw
17:26:07 <ski> letrec : if anything is unclear, just ask
17:27:33 <Galactic> does someone uses https://www.hackerrank.com ?
17:30:10 <quchen> Javran: Identical even!
17:35:07 <emilianog> hey guys
17:35:13 <emilianog> I have a couple of questions about lens
17:35:24 <emilianog> so I am pretty new
17:35:50 <emilianog> and I can use set and modify
17:36:07 <emilianog> but I want to set two things at once
17:36:25 <emilianog> as in I want to set the value of two things
17:36:38 <emilianog> but one of them depends on the other
17:36:48 <emilianog> and I don't know a good way to do that
17:36:54 <emilianog> can anyone help?
17:37:42 <Fuuzetsu> I don't get it, I have a project that needs convertible so convertible-1.0.11 gets pulled in but it errors: âData/Convertible/Utils.hs:58:31: Not in scope: âmkTyConâ Perhaps you meant âmkTyCon3â (imported from Data.Typeable)â. But I'm using GHC 7.8-rc2 and I know that Data.Typeable exports âmkTyConâ, after all there was all that fuss about polykinded Typeable a while agoâ¦
17:37:42 <Fuuzetsu>  
17:39:50 <Fuuzetsu> oh, I guess base 4.7 could have removed the deprecated mkTyCon
17:42:53 <acowley> emilianog: I don't think there's a great way of doing that.
17:43:42 <emilianog> hm... okay
17:44:16 <acowley> That is, you'll probably want a point
17:44:20 <acowley> so you can refer to it
17:45:12 <emilianog> what do you mean?
17:45:44 <acowley> I mean you will probably want to bind an identifier to the thing you're operating on
17:46:19 <emilianog> okay
17:46:26 <emilianog> let me ask a simpler question
17:46:36 <emilianog> so far I have been doing this:
17:46:54 <emilianog> set x 5 rec
17:47:05 <emilianog> is there a better syntax for that?
17:47:13 <acowley> x .~ 5
17:48:18 <acowley> The idea is to drop the rec identifier (eta reduction), then use the operator for set
17:48:54 <emilianog> wait so
17:49:06 <emilianog> (x .~ 5) rec wouldn't work?
17:49:44 <acowley> e.g, rather than write: "f rec = set x 5 rec", you can write "f = set x 5", which you can also write "f = x .~ 5"
17:50:12 <emilianog> oh okay yeah
17:50:26 <emilianog> for some reason I was under the impression that
17:50:26 <acowley> It would work, and you will possibly need to have a name for rec to address your original question
17:50:35 <emilianog> i could do something like this:
17:50:41 <emilianog> rec.x .~ 5
17:50:52 <acowley> But most of lens is structured to support the kind of reduced point style I just showed
17:51:14 <acowley> If you like that order of things, you can do "rec & x .~ 5"
17:51:15 <emilianog> okay that makes sense
17:51:42 <emilianog> okay that's great!
17:52:21 <emilianog> is there a similar simple syntax for getting values?
17:52:36 <acowley> rec ^. x
17:52:45 <emilianog> okay awesome!
17:52:48 <emilianog> thanks a lot
17:52:52 <emilianog> very helpful
17:52:58 <acowley> np!
17:54:22 <Fuuzetsu> HDBC seems to not be maintained anymore (last update year ago), is there anything else that I should be using?
17:54:56 <Clint> persistent? esqueleto?
17:56:54 <Fuuzetsu> I'll have a look. I have no idea what I'm doing when it comes to this so I just picked HDBC because I saw it mentioned in RWH
17:57:36 <acowley> RWH is rather out of date unfortunately
17:57:46 <acowley> Luckily, #haskell is cutting edge!
17:58:26 <prooftechnique> Just got my copy of that new Haskell book
17:58:37 <acowley> Is it a bunch of #haskell logs?
17:58:44 <prooftechnique> Hahaha, if only
17:59:15 <prooftechnique> Still, it's filling in well in lieu of RWH 2e
17:59:24 <Fuuzetsu> is there a new Haskell book?
17:59:42 <prooftechnique> http://www.apress.com/9781430262503
18:00:13 <Fuuzetsu> oh, another beginner book
18:00:15 <prooftechnique> It says beginning Haskell, but it covers testing and engineering and all that once you get through the usual baby's first Haskell stuff
18:00:25 <Fuuzetsu> I wonder what it says about QuickCheck
18:01:06 <prooftechnique> Fuuzetsu: There's a section on it and some example properties for binary trees
18:01:21 <prooftechnique> I think HaskellCraft is better for QuickCheck, really
18:02:00 <prooftechnique> Fuuzetsu: There're also a couple of sections on Idris
18:02:44 <Fuuzetsu> bleh, I'm not forking out Â£43 to read about QuickCheck
18:03:04 <Fuuzetsu> Idris is dead to me unless they rethink their unicode situation
18:03:24 <acowley> What'd they do?
18:03:38 <acowley> I really wish Idris integrated with Haskell in some useful way :(
18:03:58 <Fuuzetsu> acowley: they don't let you define unicode operators for completely inane reasons
18:04:24 <Fuuzetsu> one of which is âI can't read Agda mailing list properly on my phone!â and âPeople would struggle with inputting unicodeâ
18:04:24 <prooftechnique> Fuuzetsu: It's the first book I've seen that uses lenses
18:04:33 <acowley> If those inane reasons are simply knee jerk against idiomatic agda, I sympathise with them.
18:04:35 <Fuuzetsu> apparently the world is not ready for unicode, according to the Idris folk at least
18:04:42 <acowley> hah
18:05:06 <hpc> man, agda's unicode puts even mathematicians to shame
18:05:11 <Fuuzetsu> acowley: It got to the point where agda-mode for emacs has a special binding to insert _|_ (which is so pretty and much more readable than â¥)
18:05:19 <acowley> I love unicode operators, but find so much Agda code really grating
18:05:26 <Fuuzetsu> if you don't want to use or insert unicode, no one is forcing you
18:05:38 <hpc> Fuuzetsu: except the library authors ;)
18:05:53 <acowley> Fuuzetsu: I like the unicode of things like _|_, what I don't like is when people use little superscript brackets and dots and such
18:06:30 <hpc> if there was some canonical ascii-ization for every unicode codepoint that wasn't complete hell to read
18:06:31 <Fuuzetsu> hpc: As I said, if I want to release a library which uses unicode to denote things like they are in denoted in the wild, I should well bloody be able to di it
18:06:33 <Fuuzetsu> do it*
18:06:36 <acowley> I find them hard to see, and impossible to pronounce, and there seems to be little that is systematic about how they are chosen
18:06:48 <prooftechnique> "Is that superscript o or superscript Ï?"
18:06:52 <hpc> Fuuzetsu: what if someone wants to use your library without having to muck about with unicode?
18:06:59 <Fuuzetsu> https://github.com/idris-lang/Idris-dev/wiki/Unofficial-FAQ here are some Officialâ¢ reasons
18:07:05 <Fuuzetsu> or Unofficial I guess
18:07:34 <hpc> prooftechnique: oh dear god, yes
18:07:45 <hpc> prooftechnique: or better, agda uses two different kinds of ':'
18:07:57 <Fuuzetsu> hpc: I guess I could e-mail them http://media.catmoji.com/post/hox/you-came-to-the-wrong-neighborhood.jpg
18:07:58 <hpc> one is syntax, the other is a valid identifier and is used for Î£[] notation
18:08:10 <prooftechnique> Haha, yes. I've also been bitten by \:: and :: looking almost identical
18:08:21 <hpc> prooftechnique: oh, that too
18:08:23 <Fuuzetsu> â· and :: look nothing like each other
18:08:34 <hpc> but the two ':' are homoglyphs
18:08:40 <Fuuzetsu> there's a joke in my household about the Agda experience, where you make your font really big ;)
18:09:00 <acowley> You live in the wrong/right household
18:09:10 <hpc> with default debian emacs settings, the two colons differ by exactly zero pixels
18:09:18 <bitemyapp> Fuuzetsu: your household talks about Agda?
18:09:33 <Fuuzetsu> bitemyapp: I live with Twey
18:09:35 <bitemyapp> also, I watched a presentation about Agda and spent the entire talk squinting.
18:09:54 <Twey> bitemyapp: It's a pretty Agda-friendly household
18:09:57 <bitemyapp> Fuuzetsu: did one of you recruit the other?
18:10:04 * Twey raises a hand.
18:10:09 <hpc> it's great when all you have to deal with are \-> and Î£ and the very limited set of "this is clearly a distinct character"
18:10:11 <Fuuzetsu> in any case, I think Idris doesn't have mixfix which makes the whole situation much less strenuous on the reader
18:10:17 <acowley> hpc++
18:10:19 <hpc> but for the love of god stop there
18:10:26 <acowley> hpc+++++++
18:10:29 <sipa> hp c++
18:10:45 <bitemyapp> hpc++
18:10:50 <hpc> let me find a random example
18:10:59 <bitemyapp> APL-da
18:11:02 <Fuuzetsu> hpc: â£ is the best character, especially considering Firefox doesn't seem to render it until you zoom right in ;P
18:11:03 <bitemyapp> hyuk hyuk
18:11:18 <k_89> haskell is wonderful
18:11:27 <hpc> _ââ¨_â©_ : â x {y z} â x â y â y IsRelatedTo z â x IsRelatedTo z
18:11:29 <hpc> yep
18:11:32 <hpc> unicode parens
18:11:33 <acowley> Is it still the case that you need spaces around commas in Agda, too?
18:11:41 <Twey> hpc: Those are angle brackets
18:11:43 <acowley> I've seen some funny bugs due to that
18:11:47 <Fuuzetsu> hpc: they are \< and \> (because you can't use ( and ) )
18:11:48 <Twey> hpc: Your font is wonky
18:11:49 <hpc> _â : â x â x IsRelatedTo x -- this is a box
18:11:59 <Fuuzetsu> \qed
18:12:02 <Twey> No, because angle brackets are the standard notation there
18:12:07 <hpc> Twey: my font is perfectly damn fine ;)
18:12:24 <Twey> hpc: But round brackets and angle brackets look the same?  :Ã¾
18:12:25 <Fuuzetsu> you could do much better than those examples
18:12:29 <quchen> Guys, the unmaintainable Haskell article was a joke :-C
18:12:52 <Fuuzetsu> Twey: Maybe he's on OSX where corners are the devil
18:13:05 <Twey> hpc: Once I came across some code that used â¶ (but not :, which is syntax in Agda)
18:13:23 <Twey> hpc: Took me a long time to track that syntax error down
18:13:52 <quchen> > let map mÐ°Ñ maÑ = mÐ°Ñ : map mÐ°Ñ maÑ; mÐ°p mÐ°Ñ = map mÐ°Ñ mÐ°Ñ in mÐ°p "map" -- ;-)
18:13:53 <lambdabot>  ["map","map","map","map","map","map","map","map","map","map","map","map","ma...
18:14:01 <Fuuzetsu> quchen: that's a good example ;P
18:14:41 <hpc> Twey: they are some weird unicode brackets with an extremely shallow corner
18:15:05 <Twey> hpc: They're clearly distinct for me from () for me.
18:15:13 <Twey> s/ for me//
18:15:15 <quchen> For some value of "clearly".
18:15:39 <acowley> They are Tweyly distinct
18:15:49 <Twey> For the value of âclearlyâ that means when I glance at them I can say, âoh, that's an angle bracketâ :Ã¾
18:15:58 <quchen> For some value of glance.
18:16:09 <hpc> for the value of 'clearly' that means when anyone else glances at them it's a coin toss
18:16:09 <prooftechnique> Are there Tweyly graphs?
18:16:13 <quchen> We can play this game until Ï.
18:16:31 <hpc> because they don't memorize the minutest of subpixel differences between \x817235 and \x761253
18:16:35 <shachaf> > let x x = x in x 'x'
18:16:36 <lambdabot>  'x'
18:16:53 <hpc> how am i supposed to know they aren't parens?
18:17:00 <hpc> i don't even know if there are unicode parens at all!
18:17:02 <hpc> there could be!
18:17:09 <hpc> maybe you are wrong, those are it
18:17:11 <hpc> and your font is wrong
18:17:24 <prooftechnique> shachaf: Unusually, that parses just fine in my head.
18:17:37 <Fuuzetsu> emacs can tell you what something is when in doubt
18:17:46 <hpc> IDE TO THE RESCUE!
18:17:51 <Fuuzetsu> >IDE
18:17:52 <Fuuzetsu> come on now
18:17:59 <hpc> let's just do that for all thousand lines of code in a typical file
18:18:13 <hpc> Fuuzetsu: it's a damn ide
18:18:18 <prooftechnique> Agda users should just standardize on DejaVu fonts
18:18:19 <hpc> it is a development environment
18:18:24 <hpc> and it is integrated into the agda binary
18:18:26 <hpc> IDE
18:18:39 <hpc> it is no small amount of integration either
18:18:39 <Fuuzetsu> hpc: is it? Where's my debugger and compiler built-in? FYI I'm posting this from emacs
18:18:59 <Fuuzetsu> and no, the âwhat is this characterâ functionality is not an Agda thing
18:19:17 <hpc> Fuuzetsu: let me know when agda gets a debugger
18:19:43 <Fuuzetsu> anyway, this argument is silly, just because people can use characters that look exactly the same doesn't mean they will. It's like not selling steel because people might go and make weapons out of it
18:20:03 <hpc> but they just did
18:20:10 <hpc> those angle brackets looked like parens
18:20:16 <hpc> and they could have just used <> or something
18:20:18 <Fuuzetsu> By the way, you can have unicode operators in Haskell and I don't see you in the uproar about it
18:20:26 <quchen> Murphy's law etc. There's always *that* person.
18:20:40 <hpc> Fuuzetsu: how many people are using it?
18:20:55 <Fuuzetsu> 2 out of 2 in my household which makes for 100%
18:21:00 <hpc> there's two acme packages, and maybe a few others that define Ï
18:21:00 <Fuuzetsu> check mate
18:21:18 <quchen> I've seen a couple using â¤ for whatever reason
18:21:32 <Fuuzetsu> because it's shorter than Int(eger) probably
18:21:58 <Fuuzetsu> or because they defined their own numbers and needed something that's not taken
18:21:59 <Fuuzetsu> or something
18:22:08 <quchen> "Z" would require even less source code bytes.
18:22:33 <quchen> type â¤ = Integer -- That's what it was.
18:22:34 <Fuuzetsu> Are we turning this into disk space argument now?
18:22:38 <hpc> if they need it to be short, they can use 'I' and pick a sans-serif variable-width font
18:22:56 <artyomkazak> oh but we don't want to take âZâ because it's a Premium Typeclass and somebody else might need it
18:23:01 <Fuuzetsu> quchen: It's fairly obvious what â¤ is when you see it in whatever context but Z could be anything
18:23:09 <acowley> I like uses of unicode like that but i have trouble with losing monospace alignment because I'm apparently terrible at preferring one font over another
18:23:14 <hpc> Integer is obvious!
18:23:18 <quchen> Fuuzetsu: Is Int â¤?
18:23:25 <artyomkazak> ...and then nobody uses it because everybody thinks like that. Same with âzeroâ
18:23:32 <quchen> Which brings us back to "for some value of 'obvious'".
18:23:41 <Fuuzetsu> Integer is â¤ but yes, for some value of obvious
18:23:49 <Fuuzetsu> see the word âfairlyâ
18:23:59 <hpc> for some value of 'fairly'?
18:24:13 <Fuuzetsu> âIt's fairly obviousâ¦â
18:24:30 <prooftechnique> I think this is straying into -blah territory
18:24:37 <Fuuzetsu> anyway, I see cabal is finished so I'm out of this
18:24:38 <Fuuzetsu> indeed
18:24:47 <Fuuzetsu> tl;dr unicode _not_ considered harmful
18:25:14 <hpc> but it can be used to cause such spectacular harm when abused
18:25:28 <Fuuzetsu> Yes, as can pretty anything.
18:25:54 <hpc> and you call out abuse when you see it, as i have
18:27:01 <hpc> but apparently i need to keep 10 different kinds of matching parens in my head with agda and that's just normal
18:27:04 <Fuuzetsu> You didn't call out anything, you just pointed out that it can be abused to which I don't disagree. Your examples of â¨, â© and â are hardly abuse.
18:27:16 <hpc> so i will just stick to languages that can be parsed by human eyeballs
18:27:29 <Twey> hpc: I think if you have trouble telling () from â¨â© you'll also have trouble telling u from v, so Haskell might be off the table :Ã¾
18:27:47 <Fuuzetsu> Stick to better fonts which can show two characters which are meant to look different, differently.
18:28:04 <prooftechnique> All right, all right
18:28:09 <prooftechnique> -blah time
18:32:05 <flazz> what does "import X ()" mean?
18:32:23 <acowley> import only instances declared in X
18:32:49 <flazz> regardless of what X exports?
18:32:57 <Fuuzetsu> yes
18:33:31 <Fuuzetsu> Well, you can't import what it doesn't export anyway
18:33:42 <flazz> thrift code-gen imports Thrift.Types (), but that module doesn't seem to exist
18:35:32 <Fuuzetsu> it must exist, maybe it's internal so it doesn't show up in the docs
18:38:20 <steamboat> Anyone want to help me with Arrows and Netwire?
18:38:46 <Tekmo> Sure
18:38:55 <steamboat> I'm trying to combine two wires for x and y coords into a wire for the vector
18:39:00 <codygman> What is the haskell equivalent of this library in Go: http://golang.org/src/pkg/crypto/x509/x509.go Would it be: http://hackage.haskell.org/package/certificate-1.0.1/docs/src/Data-Certificate-X509.html#X509?
18:39:04 <steamboat> but I'm not quite sure on syntaxy stuff
18:39:07 <Tekmo> steamboat: What are the exact types?
18:39:13 <steamboat> http://lpaste.net/100703
18:39:39 <Tekmo> My first guess is something like: liftA2 (,) xWire yWire
18:39:42 <flazz> Fuuzetsu: just grep in .cabal-sandbox?
18:41:51 <steamboat> I'm probably slightly hampered by using custom types
18:41:59 <Fuuzetsu> flazz: I don't know how you'd find it but if something imports it and it succeeds, it must be coming from somewhere.
18:42:34 <Tekmo> steamboat: Wait, something is confusing me about the types
18:42:42 <steamboat> but I've been trying something like
18:42:42 <steamboat> b c >>> arr Vec
18:42:43 <steamboat> knowing that b and c are wires
18:42:56 <Fuuzetsu> flazz: You say code-gen, maybe it's generated on the fly or something?
18:43:12 <steamboat> but that's not right because  I'm not clear where I'm making sure they're an arrow
18:43:14 <Tekmo> steamboat: mkSF_ returns a `Wire`, yet you are applying it to something else as if it were a function
18:43:15 <flazz> Fuuzetsu: yeah, the thrift compiler generates haskell
18:43:30 <steamboat> Tekmo: yeah, I want that to be the second wire
18:43:45 <steamboat> I'm not sure how to specify that its an arrow
18:43:53 <Fuuzetsu> Sure then, it probably makes the module you're after for you. No idea where it puts it but it ought to be there somewhere. Look for Types.hs I guess.
18:44:03 <steamboat> although Wire s e m should be
18:45:34 <steamboat> maybe the problem is I don't know the Arrow 'box' they should be in
18:46:11 <Tekmo> steamboat: I think you want something like: fmap (\x -> Vec (X x) (Y 0)) (integral 0 . velocity)
18:46:23 <Tekmo> steamboat: Or alternatively you can write that as:
18:46:38 <Tekmo> steamboat: integral 0 . velocity >>> arr (\x -> Vec (X x) (Y 0))
18:47:28 <steamboat> Tekmo: thanks, that makes more sense
18:47:33 <Tekmo> steamboat: You're welcome
18:48:11 <Tekmo> steamboat: So there's a way you can derive that starting from something similar to what you had
18:48:51 <Tekmo> steamboat: Oh wait, I have to eat dinner
18:48:59 <Tekmo> steamboat: I'll be back in a bit
18:49:03 <steamboat> Tekmo: cool
18:49:17 <steamboat> Tekmo: I'll be interested to hear later
18:49:53 <Fuuzetsu> are there any network-conduit examples around? I don't get how to create AppData, the constructor isn't exposed and there seems to be no intermediate functions to do it for me
18:50:35 <Fuuzetsu> ah, found http://www.yesodweb.com/blog/2012/06/conduit-0-5
18:54:26 <Tekmo> steamboat: Okay, so first I split up your x and y wires into two separate definitions
18:54:57 <Tekmo> steamboat: xWire = arr X <<< interval 0 <<< velocity
18:55:03 <Tekmo> steamboat: yWire = arr Y <<< pure 0
18:55:31 <Tekmo> steamboat: Now, the next step was knowing that every `Arrow` has a valid `Applicative` instance
18:55:44 <Tekmo> steamboat: You don't get this for free, though.  THe library author has to know this and provide it
18:55:49 <Tekmo> steamboat: Fortunately, netwire does
18:56:06 <Tekmo> steamboat:: Now let's look at the types of your two wires:
18:56:26 <Tekmo> steamboat: xWire :: Wire ... X
18:56:31 <Tekmo> steamboat: yWire :: Wire ... Y
18:56:47 <Tekmo> So I assumed that your `Vec` constructor has type:
18:56:51 <Tekmo> steamboat: Vec :: X -> Y -> Vec
18:56:58 <steamboat> yeah
18:57:09 <Tekmo> steamboat: ... which means that you can lift it over both wires using the relevant applicative instance
18:57:18 <Tekmo> steamboat: liftA2 Vec xWire yWire :: Wire ... Vec
18:57:29 <Tekmo> steamboat: However, we're not done there
18:57:51 <Tekmo> steamboat: Another property that `Arrow`s have is that they are always `Functor`s, using the following definition:
18:58:05 <Tekmo> steamboat: fmap f theArrow = arr f <<< theArrow
18:58:26 <Tekmo> steamboat: So I applied that definition in reverse to rewrite `xWire` and `yWire` in terms of `fmap` instead of `arr`
18:58:34 <Tekmo> xWire = fmap X (interval 0 <<< velocity)
18:58:43 <Tekmo> yWire = fmap Y (pure 0)
18:59:07 <Tekmo> steamboat: So now you can inline those two definitions to get:
18:59:25 <Tekmo> steamboat: liftA2 Vec (fmap X (interval 0 <<< velocity)) (fmap Y (pure 0))
18:59:54 <Tekmo> steamboat: You can then simplify that using the applicative laws, which you can use to prove that:
19:00:28 <Tekmo> steamboat: liftA2 f (fmap g a) (fmap h b) = liftA2 (\x y -> f (g x) (h y)) a b
19:00:46 <Tekmo> steamboat: This lets you effectively move the `fmap` logic into the applicative logic
19:00:53 <Tekmo> steamboat: That simplifies the code to:
19:01:09 <Tekmo> steamboat: liftA2 (\x y -> Vec (X x) (Y y)) (interval 0 <<< velocity) (pure 0)
19:01:25 <Tekmo> steamboat: You can also prove using the applicative laws that:
19:01:58 <Tekmo> steamboat: liftA2 f g (pure y) = fmap (\x -> f  x y) g
19:02:05 <Tekmo> steamboat: So that gives you:
19:02:25 <Tekmo> steamboat: fmap (\x -> Vec (X x) (Y 0)) (interval 0 <<< velocity)
19:02:38 <Tekmo> steamboat: The last step is to apply the `fmap`/`arr` equivalent in reverse, giving:
19:02:54 <Tekmo> steamboat: arr (\x -> Vec (X x) (Y 0)) <<< interval 0 <<< velocity
19:03:26 <Tekmo> steamboat: Note, you will get the hang of these applicative/functor rearrangements the more you use the applicative/functor type classes.  It's okay if you don't completely get why they work right now
19:03:44 <steamboat> Tekmo: yeah, right now I can follow it, but not quite grok it
19:04:03 <Tekmo> steamboat: This is one of the reason why equational reasoning is a big deal in Haskell
19:04:22 <Tekmo> steamboat: You can take code that initially looks really complicated and use equations to simplify it down into something more intuitive
19:05:04 <steamboat> Tekmo: thanks, that was really helpful
19:05:13 <Tekmo> steamboat: You're welcome!
19:05:31 <Galactic> question: why when I do...  concat . map (replicate 3) [1,2,3]   I get an error but when I do   concat $ map (replicate 3) [1,2,3]  it works fine? I though it should work in both cases.
19:05:59 <Tekmo> Galactic: `$` is not the same thing as `(.)`
19:06:09 <Tekmo> Galactic: I'll translate the left version to illustrate why
19:06:27 <Tekmo> concat . map (replicate 3) [1,3,4] = \x -> concat $ map (replicate 3) [1,3,4] y
19:06:29 <Tekmo> Oops
19:06:31 <Tekmo> concat . map (replicate 3) [1,3,4] = \x -> concat $ map (replicate 3) [1,3,4] x
19:06:41 <flebron> Hi. In the formal definition of a monad in http://en.wikipedia.org/wiki/Monad_(category_theory) , where \mu is join, what is \mu T supposed to mean? (With T the endofunctor).
19:07:10 <Tekmo> Galactic: The left-version is telling the compiler that you are composing two functions, one of which is `concat` and the other of which is `map (replicate 3) [1,2,3]`
19:07:21 <flebron> It's not \mu(T) since that doesn't type, and it's not \mu . T since that doesn't type either.
19:07:24 <Tekmo> Galactic: However, that's probably not what you intended, because `map (replicate 3) [1,2,3]` is not a function
19:08:17 <Galactic> Tekmo: aaa I see...Thanks.
19:08:56 <Tekmo> flebron: You can think of `mu T` as having type :: T (T (T a)) -> T (T a)
19:09:20 <Tekmo> flebron: It's basically saying that it's like `T (T b)) -> T b`, where `b` is `T a`
19:09:30 <flebron> OK so it really is \mu . T.
19:09:41 <Galactic> Tekmo: then how could it work in here...take a look at this... https://www.hackerrank.com/rest/contests/master/challenges/fp-list-replication/hackers/Boerworz/download_solution
19:09:50 <Tekmo> flebron: Think of the `T` as being just a type annotation (although that's not totally correct)
19:10:09 <flebron> Oh, no, it's not \mu . T.
19:10:19 <Tekmo> flebron: The `T` is there just there as an explicit placeholder to specify that there is a `T` layer there that we are allowing to pass through
19:10:25 <flebron> Right, I was thinking it as a type annotation.
19:10:28 <Fuuzetsu> I love LambdaCase â¥
19:10:37 <flebron> Because in actual Haskell that just means join . fmap join = join . join
19:10:57 <Tekmo> Galactic: That link doesn't work for me.  Can you copy the code to lpaste.net?
19:11:02 <flebron> But if I read that T as "fmap", that says "join . join fmap", which is clearly wrong.
19:11:03 <Tekmo> Galactic: I get `Access Denied`
19:11:15 <Galactic> Tekmo: yeap one sec...
19:11:16 <Tekmo> flebron: Yeah, so on the left-hand side it definitley means fmap
19:11:35 <Tekmo> flebron: Think of the category theory notation as sort of always specifying which functors we pass through
19:11:44 <Tekmo> flebron: fmap is just the special case where we let the left functor pass through
19:12:13 <flebron> Why not write \mu \circ \mu?
19:12:20 <Tekmo> flebron: Note that unlike Haskell there is no notion of one of these T's being on the "outside"
19:12:50 <Tekmo> flebron: It's more appropriate to think of them as all being on an even footing.  They are just to the left and right of each other
19:12:55 <Galactic> Tekmo: http://lpaste.net/100710
19:13:08 <Tekmo> flebron: It's more analogous to how `first` and `second` behave from `Control.Arrow`
19:13:26 <flebron> If I understood arrows I wouldn't be trying to understand monads haha
19:13:29 <Tekmo> flebron: Writing something like `T f` is like writing `second f`
19:13:37 <Tekmo> flebron: Writing something like `f T` is like writing `first f`
19:13:45 <flebron> (Well, I already ostensibly understand them, I just want to solidify it mathematically.)
19:14:29 <Tekmo> Galactic: It helps to translate `$` to explicit parentheses
19:14:29 <levi> Galactic: concat . map (replicate 3) $ [1,3,4]
19:14:45 <Tekmo> Galactic: When you write something like `f $ g $ h x` it translates to: `f (g (h x))`
19:15:04 <Tekmo> Galactic: This is analogous to `(f . g . h) x`, but not the same thing as `f . g . h x`
19:15:22 <Tekmo> Galactic: Or you could write it as `f . g . h $ x`
19:15:38 <levi> Galactic: The thing to remember is that function application is the tightest-binding operation.
19:15:44 <Tekmo> Galactic: This latter form sometimes confuses people.  It makes them think that `(.)` and `$` are interchangeable although they are not
19:16:26 <Galactic> o wao...thanks guys
19:16:31 <Tekmo> You're welcome!
19:16:44 <jfischoff> that confused me for the longest time
19:17:15 <levi> I usually wrap a composition of functions in parentheses if I need to apply the resulting function to a value, at least unless I've already got a lot of parens.
19:17:37 <Tekmo> levi: Me, too
19:18:02 <flazz> if a vendor ships a haskell module, how can i use that in a cabal sandbox based project?
19:19:27 <levi> So, I'd prefer (f . g . h) x, unless that was a sub-expression, in which case I'd do (f . g . h $ x). But preferences vary a lot, so it's best to get the precedence rules down.
19:19:33 <Tekmo> I remember that Greg Weber maintained a tool for depending on things other than Hackage pages like Github repos or source tarballs
19:19:36 <Tekmo> I forgot the name
19:21:15 <levi> Galactic: Another thing that's often confusing is when you see code like: f . g x . h y $ z
19:21:23 <mgsloan> cabal-meta!  I think the new cabal sandboxes also support depending on repos, though
19:21:54 <levi> Galactic: Since function application binds tighter than composition, it's like (f . (g x) . (h y)) z
19:22:01 <Tekmo> mgsloan: Thank you!  That's what I was thinking of
19:22:07 <Galactic> :levi yea I am still trying to wrap my head around that. haha
19:22:35 <prooftechnique> I seem to remember cabal-src and cabal-meta-src, too
19:27:40 <Galactic> so if I have    take 3 $ repeat 4    the parenthesis goes like this:  take 3 (repeat 4)  or like this   (take 3) repeat 4   or is it the same....well I just tried the second one and it gave me an error.
19:28:09 <shachaf> It goes like this: (take 3) (repeat 4)
19:28:41 <Galactic> o wao
19:29:02 <Galactic> I thought it was only one parenthesis
19:29:09 <mgsloan> (which is the same as: take 3 (repeat 4))
19:29:18 <Tekmo> Galactic:  a b c $ d e f = (a b c) (d e f)
19:30:24 <Galactic> nice thanks...that helps a lot now.
19:30:24 <shachaf> Which in turn means ((a b) c) ((d e) f)
19:30:58 <shachaf> "a b c" means "(a b) c" -- that's probably the most important associativity rule.
19:32:14 <Galactic> but is  "a" a function with two parameters   b and c?
19:32:34 <Tekmo> Galactic: To be totally precise, it's a function with one parameter that returns another function with one parameter
19:33:01 <Galactic> I see
19:33:05 <Tekmo> Galactic: Whenever you see a type like: foo :: a -> b -> c, you can mentally group it like: foo :: a -> (b -> c)
19:33:08 <ski> `a' is, strictly speaking, a function taking `b' as argument, and returning a function that takes `c' as argument, and returning a function that takes (the result of) `d e f' as argument, and returning whatever result the whole expression has
19:33:25 <ski> strictly speaking, every function in Haskell takes exactly one argument, no more, no less
19:33:47 <Tekmo> Galactic: This is known as "currying", meaning simulating functions of multiple arguments by defining functions that return functions
19:34:05 <ski> however, when using curried style, we often think of `foo 2 3' as passing two arguments to `foo', given say `foo :: Integer -> Integer -> String'
19:34:07 <Tekmo> Galactic: When you write something like: f x y = z, the compiler desugars it to: f = \x -> \y -> z
19:34:28 <Tekmo> Galactic: This is why you can apply functions to just one parameter
19:34:36 <ski> and, when using tuples style, we often think of `bar (2,3)' as passing two arguments to `bar', given say `bar :: (Integer,Integer) -> String'
19:34:47 <ski> s/tuples/tupled/
19:35:02 <Tekmo> Galactic: That's why you can write things like `map (1 +) [0..]`
19:35:04 <ski> curried style is more common than tupled style in Haskell, but both occurs
19:35:16 <Galactic> interesting
19:35:30 <ski> both are ways to simulate passing multiple arguments in a language where every function takes a single argument
19:35:41 <Tekmo> Galactic: (+) can be applied to just one argument, because the outer function only expects one argument (and then returns a function waiting to take another argument)
19:35:52 <pordan30> is there a good reference on free monads and their applications (perhaps at the difficulty level of the functional pearl series, which i've found helpful in the past)?
19:36:11 <ski> they are slightly different from each other. sometimes one is to be preferred to the other, sometimes the other way around. sometimes it doesn't matter much, and then curried style usually is less to write in Haskell
19:36:27 <Tekmo> Galactic: The key point is that whether or not you use tuples or currying, all Haskell functions only take exactly one argument.  There really is no such thing as "partial function application" because every function is fully saturated with just one argument
19:36:39 <shachaf> @quote ddarius partial
19:36:39 <lambdabot> ddarius says: (f x) is a partial application iff f x == (curry (uncurry f) x)
19:36:41 <Tekmo> Galactic: This makes Haskell much more internally consistent
19:36:48 <shachaf> I like that definition for several reasons.
19:37:15 <flebron> Tekmo: It really is a type annotation.
19:37:21 <levi> Oddly, SML style seems to prefer tupled arguments, while Ocaml and Haskell prefer curried arguments.
19:37:38 <flebron> Because a natural transformation is just indicating the polymorphism, and the T there is saying which component of the natural transformation to look at.
19:37:46 <flebron> In other words, which type to fix the polymorphic function at.
19:37:49 <Tekmo> flebron: Yes
19:37:52 <Tekmo> flebron: That's correct
19:37:59 <Tekmo> flebron: It's a type specialization of a natural transformation
19:38:07 <ski> partial application only really makes sense if you already have multiple arguments (in either curried or tupled style, or in a language where there's a built-in notion of "multiple arguments)
19:38:18 <Tekmo> flebron: I like that description
19:38:22 <flebron> Total Neo "I know kung-fu" moment.
19:38:28 <Tekmo> flebron: :)
19:38:59 <ski> levi : i recall hearing that that would be because at the time the standard was set, it wasn't known how to compile curried style as efficiently as tupled style
19:39:28 <copumpkin> what's the difference between Data.Binary.Builder and Data.Binary.Put? just an API difference?
19:39:32 <ski> levi : still, SML uses curried style for `map' and `foldr', e.g.
19:39:38 <copumpkin> Put seems to be effectively Writer Builder
19:39:46 <Tekmo> Galactic: An example of how this makes Haskell more consistent is to consider a function in another language that accepts a tuple as an argument
19:39:50 <copumpkin> back in my day Put was the only one
19:40:07 <Tekmo> Galactic: For example, in a language that has functions of multiple arguments, something like f ((x, y)) is not the same thing as f (x, y)
19:40:28 <Tekmo> Galactic: The left-hand side is a function that takes one tuple as an argument, whereas the right-hand side is a function that takes two arguments
19:40:35 <Tekmo> Galactic: In Haskell, there is no distinction between these two
19:40:38 <Tekmo> Galactic:
19:40:40 <Tekmo> Oops
19:40:58 <Tekmo> Galactic: In Haskell, both sides would be a function taking one tuple as an argument, leaving no room for ambiguity
19:41:28 <Tekmo> Galactic: However, we still usually prefer to curry functions instead of passing arguments as tuples
19:42:58 <Galactic> thanks, I really appreciated all the explanations from everyone.
19:48:24 <ski> flebron : âÎ¼ Tâ is âÎ A. Î¼ [T A]â and âT Î¼â is âÎ A. T (Î¼ [A])â -- where âÎ A. â¯Aâ¯â is type abstraction over a term (implicit in Haskell); âÎ¼ [A]â is type application in a term (implicit in Haskell), often written as âÎ¼_Aâ
19:49:26 <flebron> Right, yeah, I found that in http://en.wikipedia.org/wiki/Natural_transformation#Operations_with_natural_transformations . (\mu T)(x) = \mu_{T(x)}.
19:49:42 <flebron> So the n.t. is the same one, \mu, you've just specified which component you'll use it at.
19:50:58 <flebron> Perhaps better written as (\mu T)_x = \mu_{T(x)}, since \mu T is itself a n.t.
19:51:16 <ski> flebron : another way to look at it is you apply an implicit lifting from âTâ to the identity natural transformation on âTâ, and then âÎ¼ Tâ and âT Î¼â are just "horizontal composition" of two natural transformations
19:52:00 <flebron> Ah yes, that's sensible :)
19:52:23 <levi> Galactic: There are actually functions called 'curry' and 'uncurry' to adapt functions from one way of accepting multiple parameters to the other.
19:53:49 <Galactic> I am reading http://www.haskell.org/haskellwiki/Higher_order_function
19:54:21 <ski>   mu : T . T >---> T
19:54:31 <ski>   mu . T : T . T . T >---> T . T
19:54:39 <ski>   T . mu : T . T . T >---> T . T
19:57:30 <ski> perhaps those would be clearer as
19:57:54 <ski>   Î¼ : T â T â¤â¯â T
19:58:03 <ski>   Î¼ â T : (T â T) â T â¤â¯â T â T
19:58:13 <ski>   T â Î¼ : T â (T â T) â¤â¯â T â T
19:59:43 * hackagebot webify 0.1.5.0 - webfont generator  http://hackage.haskell.org/package/webify-0.1.5.0 (ananthakumaran)
20:00:44 <carter> tekmo's gone?
20:00:45 <carter> darn
20:01:02 <carter> @lastseen bonus
20:01:03 <lambdabot> Unknown command, try @list
20:01:42 <artyomkazak> @seen bonus
20:01:42 <lambdabot> 80NuS
20:01:47 <artyomkazak> what
20:02:19 <enthropy> @leet lambdabot
20:02:19 <lambdabot> LA/\/\bd4b0+
20:02:32 <artyomkazak> note to self: lambdabot is *not* intuitively understandable
20:03:22 <mrgoodcat> absolutely not
20:03:32 <mrgoodcat> not that i'm any big expert
20:03:58 <carter> auto correct is kinda a troll
20:04:03 <mrgoodcat> @list
20:04:03 <lambdabot> What module?  Try @listmodules for some ideas.
20:04:25 <carter> ski: so mebe we shoud file a feature request to improve the scoped type variables errors
20:06:05 <enthropy> in what way?
20:09:59 <c_wraith> Is it possible to write an Applicative instance for something shaped like StateT with only an Applicative constraint on the inner type?
20:11:23 <c_wraith> Hmm.  Control.Monad.State says (Functor m, Monad m) => Applicative (StateT s m)
20:11:28 <c_wraith> So, I'll take that as a no.
20:13:04 <drbean> I had a list ['a'..'z'] but now want to include a single quote mark. But ['\'', 'a'..'z'] doesn't work. It just gives me the quote mark and 'a'
20:13:30 <c_wraith> drbean: that syntax says to use the difference between the first two as the step
20:13:46 <c_wraith> drbean: you really just want '\'' : ['a' .. 'z']
20:14:09 <artyomkazak> drbean: like [1,3..7] doesn't mean [1,3,4,5,6,7]
20:14:45 * hackagebot webify 0.1.6.0 - webfont generator  http://hackage.haskell.org/package/webify-0.1.6.0 (ananthakumaran)
20:15:02 <Iceland_jack> > '\'' : ['a' .. 'z']
20:15:03 <lambdabot>  "'abcdefghijklmnopqrstuvwxyz"
20:17:57 <enthropy> c_wraith: there is a http://hackage.haskell.org/package/applicative-extras-0.1.8/docs/Control-Applicative-Compose.html
20:19:08 <jfischoff> if you a function where IO is in the negative position like: withFoo :: Config -> (Foo -> IO a) -> IO a, is there anyway to use liftIO to turn into a function like withFoo :: MonadIO m => Config -> (Foo -> m a) -> m a?
20:19:27 <jfischoff> I don't think there is, but maybe I have overlooked something
20:19:45 * hackagebot system-command 0.0.9 - A replacement for System.Exit and System.Process  http://hackage.haskell.org/package/system-command-0.0.9 (TonyMorris)
20:20:03 <c_wraith> jfischoff: that's what the monad-control package (and related things) are intended to solve.
20:20:54 <c_wraith> jfischoff: but not every type that can be an instance of MonadIO can be made to work with that approach.
20:21:04 <jfischoff> c_wraith: but don't you have to already have the function in the correct form?
20:22:12 <joelteon> is there a library function for URL-encoding strings?
20:22:22 <joelteon> well no there wouldn't be
20:22:24 <joelteon> what package is that in
20:23:22 <joelteon> oh...Network.HTTP.Base
20:23:24 <joelteon> of course
20:23:26 <jfischoff> c_wraith: I see
20:24:28 <Galactic> preflex: karma levi
20:25:51 <joelteon> isn't there a package that takes [IO a] and runs all the actions concurrently, waiting for them to finish?
20:26:04 <c_wraith> async should do that.
20:26:14 <c_wraith> there are probably some other packages that do it, too
20:26:24 <Galactic> what happend to the preflex bot ?
20:27:05 <c_wraith> joelteon: yeah, mapConcurrently in async does that
20:27:22 <joelteon> ok cool
20:27:25 <c_wraith> joelteon: well.  It does that, and other stuff
20:31:00 <c_wraith> Wow.  For the amount of boilerplate in writing a full definition of WST, I really think mtl should have RWT, RST, and WST
20:31:42 <enthropy> it has a WST?
20:31:53 <c_wraith> no.  I wrote it because I wanted it
20:31:56 <c_wraith> And it was painful
20:32:02 <enthropy> type WST = RWST ()
20:32:10 <c_wraith> Meh.  that has extra overhead!
20:32:46 <enthropy> are you going to the effort of measuring it?
20:33:05 <c_wraith> admittedly, it at least won't leak space, unlike type RST r s = RWST r () s
20:34:34 <mrgoodcat> what is the best way to install hackage packages without cabal?
20:35:30 <c_wraith> mrgoodcat: the only other way to install them that isn't completely terrible is using arch linux's package manager.
20:35:52 <mrgoodcat> i'm on ubuntu
20:35:54 <c_wraith> then use cabal
20:35:59 <mrgoodcat> and the reason i' don't have cabal is because  i don't have sudo access
20:36:06 <c_wraith> so?
20:36:06 <mrgoodcat> so i can't install cabal
20:36:11 <c_wraith> You can install it locally
20:36:38 <mrgoodcat> i'd rather just use my own machine instead of the university server
20:37:12 <mrgoodcat> thanks though
20:48:44 <Apocalisp> > let x ðº y = x - y in 99 ðº 1
20:48:45 <lambdabot>  98
20:48:53 <Apocalisp> This is Haskell's most important feature
20:49:58 <AshyIsMe> strange unicode chars?
20:50:03 <Apocalisp> This isn't just any old beer operator. This bitch is call by need!
20:51:00 <AshyIsMe> ðº
20:51:30 <AshyIsMe> hmm, must be something wrong with unicode rendering in my chain of bash -> screen -> mosh -> ssh -> tmux -> iTerm2
20:51:37 <Apocalisp> SkÃ¥l
20:52:31 <AshyIsMe> i can see heaps of other unicode chars: Ã¦â¤â¥Ï{}Â®Ã¥Â¬Ã¥Ã¸Â´Â¨Ë]Ëï£¿ï£¿ etc.
20:52:44 <AshyIsMe> the beermug is a ? in a diamond though
20:53:01 <Apocalisp> your screen font is just missing it then
20:53:20 <AshyIsMe> bare iterm works, as does local tmux
20:53:26 <AshyIsMe> must be screen on the server
20:53:50 <lispy> copumpkin: I don't know if you were trolling about the bitcoin thing or not, but I hope the link I gave you answered your question
20:53:54 <AshyIsMe> mosh or ssh is losing the char
20:53:58 <Apocalisp> That sounds like a hairy yak in need of shaving
20:54:14 <copumpkin> lispy: I wasn't, and I was mostly proposing something like that bitpay thing you mentioned in your comment
20:54:49 * hackagebot system-command 0.0.10 - A replacement for System.Exit and System.Process  http://hackage.haskell.org/package/system-command-0.0.10 (TonyMorris)
20:55:23 <Fuuzetsu> what are the consequences of trying to Char8.unpack random binary junk? Does âs == pack . unpack $ sâ for all s â· ByteString?
20:56:35 <joelteon> i seriously doubt it
20:57:35 <lispy> copumpkin: I don't know if the SPI bank account is compatible with bitpay. Someone needs to look into it.
20:58:06 <copumpkin> hrm, who knows, might not be worth it, but it doesn't seem like it can hurt to accept more payment methods
20:58:07 <copumpkin> :)
20:59:10 <Fuuzetsu> joelteon: I'd love to carry some ByteString data using JSON but I can't think of a wayâ¦ I might have to go with a different solution but I was just wondering whether I'd be able to get away with it by converting it to String (no matter how crippled) first and then back to ByteString once it's deserialised
21:01:22 <Fuuzetsu> Guess I'll think of a different approach
21:06:03 <mgsloan> Fuuzetsu: Best thing to do is to avoid putting bytestrings in json, but when it's unavoidable: https://gist.github.com/mgsloan/bfe4bf2250c1d656a2b1
21:07:14 <Fuuzetsu> mgsloan: ah, that's a much better idea although same principle; I'll keep it in mind but I think I can get away without putting ByteString inside of JSON, I'll just have to think about it
21:07:26 <Fuuzetsu> (base64 being the better idea that is)
21:08:14 <mgsloan> Yup! Ideally aeson would do this, but there's the possibility that people already depend on the broken behavior
21:08:35 <enthropy> they removed those instances
21:08:37 <Fuuzetsu> mgsloan: actually, the ByteString instances were removed
21:08:56 <mgsloan> Ahh, right!  Well that's probably the best way to go
21:09:31 <mgsloan> Maybe a few major versions from now the base64 instances can be added in :)
21:10:03 <flazz> if I have a constructor "C (Maybe a) (Maybe b)" is there somewhat via reflection or something like it to make "C2 a b" ?
21:13:03 <johnw> just change the type?  I'm pretty you could do that if C were an instance of Typeable
21:13:23 <Fuuzetsu> Why do you need an extra constructor? Won't an alias like âtype C2 a b = C (Maybe a) (Maybe b)â do? Maybe a helper function âc2 a b = C (Just) (Just b)â or something.
21:13:43 <Fuuzetsu> C (Just a)*
21:15:59 <flazz> Fuuzetsu: sorry let me further explain, i have a bunch of code-gened types where all constructors take Maybies for every field. I'd like a convenient way to code-gen the function that takes C -> Either String C2 (assuming C and C2 are different types)
21:17:00 <Fuuzetsu> mgsloan: https://github.com/bos/aeson/issues/187
21:17:33 <flazz> s/are/construct
21:18:33 <mgsloan> IIRC it's actually snoyberg that wrote ByteString64 :)
21:18:54 * mgsloan adds a comment giving credit where it's due
21:19:30 <Fuuzetsu> sure
21:38:06 <julianb> Hello!. I'm looking for an http library with good documentation. I've been trying to use http-conduit, but its documentation is kind of lacking...
21:47:57 <Cale> julianb: Have you tried the one just called HTTP?
21:48:21 <jle`> can anyone help me with this pipes problem?  i have a pipe that awaits for chunks of 8 incoming things at a time and outputs an aggregation after all eight are received
21:48:31 <jle`> how do i have it handle the case where the stream stops, and i 'clean up' ?
21:48:36 <jle`> it's a bytestream from a file
21:48:59 <jle`> if the file runs out of bytes, i'd like to be able to not lose the data i got before it reaches 8
21:52:31 <johnw> this is called the "upstream termination" problem
21:52:38 <johnw> conduit has specific support for this; I forget how pipes handles it
21:55:30 <levi> I believe pipes-parse was created to handle leftovers and such.
21:58:05 <jle`> levi: thanks, i'll look into that
21:58:09 <johnw> yeah, but this isn't a leftovers problem
21:58:38 <jle`> i saw in a recent Tekmo article that io-streams handles this by being pull-based and getting a Nothing after things are over
21:58:49 <johnw> in conduit, await returns a Maybe a, so that if it's Nothing you know that upstream has terminated; in pipes he uses a different mechanism for this, maybe FreeT?
22:02:13 <levi> Oh, right, leftovers are when you don't terminate but have some partial data that hasn't been consumed yet.
22:02:43 <c_wraith> sometimes you want to throw them in the fridge and consume them tomorrow.
22:02:46 <johnw> right, when downstream awaits and then decides "oh yeah, I didn't want that"
22:03:17 <jle`> according to http://hackage.haskell.org/package/pipes-parse-3.0.1/docs/Pipes-Parse-Tutorial.html pipes-parse also handles end-of-input
22:03:38 <levi> I think pipes-parse includes the FreeT stuff.
22:03:58 <levi> Now with more lenses!
22:04:09 <jle`> what is FreeT ?
22:04:22 <c_wraith> A free monad transformer.
22:04:50 <jle`> ah
22:05:19 <c_wraith> I actually just wrote some code that uses the church-encoded form of it.
22:05:51 <jle`> that is...a free monad with lift?
22:06:13 <levi> 'draw' returns a 'Maybe a', and it works on a FreeT wrapper over the producer.  I think.
22:06:17 <johnw> it's a free monad with a different base monad than implicit identity
22:06:33 <c_wraith> well, lift and the process of peeling off layers requiring a monadic action
22:06:43 <jle`> ah
22:06:47 <jle`> oh yeah, the monad transformer laws.
22:06:52 <jle`> um
22:06:57 <levi> Actually, no, it's a StateT wrapper.
22:06:57 * jle` tries to remember them from the top of his head
22:07:32 <c_wraith> I only can remember return = lift . return
22:07:59 <jle`> there's some kind of distributive law i think
22:08:04 <levi> FreeT is for delimiting chunks of the input.
22:08:07 <c_wraith> yeah, there must be
22:08:10 <johnw> jle`: this is the definition I always use: http://hackage.haskell.org/package/free-4.5/docs/Control-Monad-Trans-Free.html
22:08:41 <jle`> lift (m >>= f) = lift m >>= (lift . f)
22:08:43 <c_wraith> jle`: anyway, the thing I meant about FreeT is that there's an outer m wrapper
22:09:40 <c_wraith> Peeling away the layers requires building up a computation in the base monad.
22:09:51 <jle`> why can't monad transformers also come parameterized with a type for their unwrapping function
22:10:18 <levi> jle`: What do you mean?
22:10:39 <johnw> lift is not an unwrapping function
22:10:46 <johnw> it's a wrapping function
22:10:47 <jle`> i mean, aside from lift
22:10:59 <johnw> :t lift
22:11:00 <lambdabot> (Monad m, MonadTrans t) => m a -> t m a
22:11:23 <johnw> you don't get an unwrapping function, unless you know which transformer you're working with (and maybe not even then)
22:11:32 <jle`> for example, runIdentity is Identity a -> a...so ...it'd have a type (m a -> a)
22:11:51 <johnw> yeah, people have asked for this, but you aren't ever going to get it in a principled, general way :)
22:11:53 <jle`> runState would be State s a -> s -> (a, s), so it'd have type (m a -> s -> (a, s)) maybe
22:12:06 <jle`> hm
22:12:08 <johnw> not unless what you want is a Comonad
22:12:09 <jle`> so then it'd have lift
22:12:11 <jle`> and also unwrap
22:12:48 <jle`> so for Random, it'd be Random g a -> g -> (a, g), so you'd have (m a -> g -> (a, g))
22:13:01 <levi> Well, if that was the only wart that monad transformers had...
22:13:06 <jle`> and that's a part of the parameterization of the Transformers
22:13:18 <jle`> hm
22:13:49 <levi> As it is, changing your stack is likely to require more changes than just the unwrapper function.
22:14:58 * hackagebot attoparsec 0.11.2.1 - Fast combinator parsing for bytestrings and text  http://hackage.haskell.org/package/attoparsec-0.11.2.1 (BryanOSullivan)
22:15:00 * hackagebot hopfli 0.2.0.0 - zlib compatible compression using Zopfli Compression Algorithm  http://hackage.haskell.org/package/hopfli-0.2.0.0 (ananthakumaran)
22:15:42 <johnw> jle`: why would you need to generically unwrap?
22:16:34 <jle`> i had a problem the other week
22:16:41 <johnw> what was it?
22:16:41 <jle`> where i needed to turn an IO a -> IO a
22:16:48 <jle`> into a MonadIO m => m a -> m a
22:16:52 <jle`> er, a and b
22:17:25 <jle`> so i would...unwrap the input, feed it into the IO a -> IO a, and then re-wrap it when it comes out
22:17:25 <johnw> IO a unifies with MonadIO m => m a
22:17:29 <c_wraith> jle`: this is the whole point of monad-control and related libraries
22:17:35 <jle`> oh no, i wanted it for a general MonadIO
22:17:45 <johnw> yeah, monad-control does just this
22:17:48 <jle`> ah
22:18:08 <jle`> so it is a desired functionality, just not mashed in together with MonadTrans?
22:18:27 <jle`> also who makes an IO a -> IO b function anyway
22:18:27 <c_wraith> not everything can be an instance of MonadControl that can be an instance of MonadTrans
22:18:29 <jle`> c'mon man
22:18:39 <johnw> f g x = control $ \runInIO -> runInIO (g x), where g :: IO a -> IO b, and f is MonadIO m => m a -> m b
22:18:40 <jle`> c_wraith: yeah, that makes sense
22:18:53 <johnw> c_wraith: you mean, MonadBaseControl?
22:18:58 <c_wraith> err, yes
22:19:05 <c_wraith> I don't use the library myself
22:19:10 <jle`> :t control
22:19:11 <lambdabot> Not in scope: `control'
22:19:24 <johnw> @let import Control.Monad.Trans.Control
22:19:25 <lambdabot>  .L.hs:53:1:
22:19:25 <lambdabot>      Control.Monad.Trans.Control: Can't be safely imported!
22:19:25 <lambdabot>      The package (monad-control-0.3.2.2) the module resides in isn't trusted.
22:19:56 <jle`> so shady
22:19:59 * hackagebot hopfli 0.2.1.0 - zlib compatible compression using Zopfli Compression Algorithm  http://hackage.haskell.org/package/hopfli-0.2.1.0 (ananthakumaran)
22:20:03 <jle`> such untrust
22:20:06 <johnw> hehe
22:20:21 <jle`> anyways, found it
22:20:22 <johnw> monad-control won't work with pipes
22:20:24 <jle`> on hackage
22:20:29 <johnw> or anything coroutiney
22:20:32 <jle`> oh don't worry, this was a separate problem
22:20:36 <jle`> unrelated to my pipes one
22:20:43 <johnw> ah, in that case, I use monad-control very often
22:20:48 <pordan30> dumb question, but 'putStr "\a"' should sound the default alert (bell), no?
22:21:26 <c_wraith> pordan30: I don't know that GHC uses that escape.
22:21:31 <jle`> johnw: thanks for the tip :) i had seen monad-control and looked at it but was not sure how to use it in my case
22:21:44 <jle`> luckily though not knowing how to do it forced me to find a better solution
22:21:53 <jle`> and refactor
22:22:08 <johnw> between the monad-control and mmorph packages, you can pretty much do anything you want with transformers that aren't like ContT :)
22:22:19 <pordan30> c_wraith: Good to know. It's listed as the escape sequence for alert in Real World Haskell.
22:22:41 <jle`> ah yeah i was also looking at mmorph
22:22:54 <johnw> they do very different things
22:23:05 <johnw> mmorph lets you apply monad morphisms under the transformer
22:23:08 <johnw> t m a -> t n a
22:23:32 <jle`> that sounds useful too
22:23:37 <johnw> it sure is
22:23:43 <johnw> "hoist liftIO" is pretty common in my code
22:24:08 <jle`> yeah, i was looking at my type signature, MonadIO m => (IO a -> IO b) -> m a -> m b, and was thinking i wanted some kind of monad functor of some sort.
22:24:18 <jle`> it set me off on a red herring
22:24:34 <c_wraith> pordan30: you're right.  \a is defined as being alert
22:24:35 <jle`> johnw: what does hoist liftIO do? it turns a t Identity a into a t IO a?
22:24:47 <johnw> it turns t IO a into t m a
22:25:08 <jle`> hm
22:25:12 <jle`> any m?
22:25:14 <jle`> or MonadIO
22:25:16 <johnw> whatever m you're in
22:25:26 <mgsloan> Definitely MonadIO m :)
22:25:31 <jle`> ah
22:25:33 <johnw> doesn't have to be
22:25:35 <jle`> so i'm in an m
22:25:36 <c_wraith> pordan30: It could be the case that your terminal isn't responding to it, or putStr/putStrLn could be corrupting it.  Not sure.
22:25:38 <jle`> and i have a t IO a
22:25:42 <jle`> er
22:25:46 <jle`> i'm in a t m
22:25:51 <jle`> and i have a t IO
22:25:51 <johnw> you're in a t m a, like ResourceT m a
22:25:57 <jle`> and i can use the t IO in my t m
22:26:02 <mgsloan> johnw: It does if you're using liftIO!
22:26:03 <johnw> right
22:26:06 <johnw> exactly like liftIO
22:26:10 <johnw> oh, duh, you're right mgsloan
22:26:21 <jle`> duh!
22:26:29 <jle`> :)
22:26:29 <johnw> but hoist works anywhere
22:26:32 <jle`> sorry that was uncalled for.
22:26:47 <johnw> a monad morphism is a natural transformer that also preserves the monad operations and laws
22:26:52 <johnw> natural transformation
22:27:08 <johnw> you could call a natural transformation a "functor morphism"
22:27:16 * mgsloan admits to only recently learning about hoist due to johnw using it in some code :)
22:27:20 <jle`> a morphism between functors?
22:27:21 <johnw> and regular functions "value morphisms"
22:27:24 <johnw> right
22:27:37 <johnw> forall x f g. Functor f, Functor g => f x -> g x
22:27:42 <jle`> i just know of natural transformations from hearing them suddenly in the first couple of catsters
22:27:50 <jle`> m (m x) -> m x
22:27:56 <jle`> (is that one?)
22:27:59 <jle`> that turns m^2 into m?
22:28:07 <johnw> yes, it is
22:28:11 <jle`> woo hoo
22:28:21 <jle`> i wonder what's so natural about it
22:28:29 <c_wraith> it doesn't care what x is
22:28:31 <johnw> naturality means it preserves identity and composition
22:28:45 <jle`> ah
22:28:48 <jle`> hm
22:28:56 <jle`> what is composition in this sense?
22:29:01 <jle`> morphism composition?
22:29:04 <johnw> yes
22:29:36 <johnw> it naturally transformers the function, meaning that the result also supports fmap and the functor laws
22:29:41 <johnw> the functor*
22:29:44 <jle`> ah okay
22:29:44 <johnw> transforms*
22:29:49 <jle`> functor laws
22:29:55 <jle`> i guess functors are fundamentally important or something
22:30:00 <johnw> monad morphisms are natural too
22:30:10 <c_wraith> functors just appear everywhere.
22:30:19 <johnw> yeah, functors are *incredibly* fundamental
22:30:49 <johnw> from Wikipedia: "In category theory, a branch of mathematics, a natural transformation provides a way of transforming one functor into another while respecting the internal structure (i.e. the composition of morphisms) of the categories involved. Hence, a natural transformation can be considered to be a "morphism of functors". Indeed this intuition can be formalized to define so-called functor categories. Natural transformations are,
22:30:49 <johnw> after categories and functors, one of the most basic notions of category theory and consequently appear in the majority of its applications."
22:30:52 <jle`> natural transformations seem almost too general to be a useful concept
22:31:10 <jle`> but i guess my intuition is deceiving
22:31:22 <c_wraith> no moreso than category
22:31:56 <jle`> yeah, felt that way about category too
22:31:59 <jle`> at first
22:34:04 <levi> Well, the concepts of category, functor, and natural transformation are at the foundation level of category theory.
22:34:28 <johnw> right, and monads are one of the things you get by combining some of those concepts
22:34:36 <johnw> the power lies in the implication
22:35:21 <jle`> it reminds me of why i got into physics as a discipline
22:35:36 <jle`> axioms that are deceptively simple but with profound implications
22:35:45 <johnw> jle`: you probably already use some natural transformations
22:35:58 <jle`> well i use join :)
22:36:15 <johnw> yep
22:36:20 <johnw> listToMaybe is another one
22:36:20 <jle`> and i guess fmap is a natural transformation if there is an implicit Identity?
22:36:41 <jle`> oh yeah. that preserves identity and all the functor laws...but...
22:36:45 <jle`> it does not preserve structure
22:36:48 <jle`> ?
22:36:49 <jle`> it's not reversible
22:37:00 <johnw> who said it had to preserve structure?
22:37:00 <jle`> but then again neither is bind
22:37:17 <jle`> what is a natural transformation that preserves structure?
22:37:19 <jle`> projection?
22:37:23 <johnw> fmap is not a natural transformation, to my knowledge
22:37:45 <johnw> mapping [a] to NonEmpty a would preserve structure
22:37:51 <johnw> err, the other way around
22:37:52 <jle`> johnw: actually thinking about it, i think i was just a little confused.
22:38:07 <johnw> so, anytime you turn a -> b, you have a morphism
22:38:23 <jle`> is there a word for a nat trans that preserves structure?
22:38:26 <jle`> and is reversible?
22:38:27 <johnw> and anytime you have f a -> g a, where both are functors, you have a natural transformation
22:38:45 <johnw> if only one is a functor, then you probably just have a fold or unfold
22:38:50 <jle`> johnw: well..if it preserves the functor laws, right?
22:38:53 <johnw> isomorphism
22:38:57 <jle`> or i guess it has to
22:39:00 <jle`> due to parametricity
22:39:23 <johnw> right
22:39:52 <jle`> hmm. interesting, thanks
22:40:04 <johnw> n/p, it's all a lot easier than it sounds
22:40:15 <johnw> most of this is just terminology, not anything actually complicated
22:40:26 <jle`> yeah :) i think i can see that part
22:40:33 <jle`> but putting names to things is a powerful act
22:40:54 <johnw> and becoming facile with some of these abstractions changes how you think of things
22:41:16 <johnw> i think that 90% of the time people spend on monads should be spent on functors
22:41:21 <johnw> then the remaining 10% is all they'd need
22:42:36 <levi> I definitely didn't really understand Monads (at least as much as I undertstand them now) until I understood Functors.
22:43:08 <johnw> and anytime people see them as separate concepts, they have been done a disservice
22:55:03 * hackagebot libnotify 0.1.0.0 - Bindings to libnotify library  http://hackage.haskell.org/package/libnotify-0.1.0.0 (MatveyAksenov)
22:56:25 <jle`> hm, having trouble with pipes-parse
22:56:31 <jle`> i understand how to make the parse that i need
22:56:34 <jle`> but
22:56:45 <jle`> i want to be able to streamingly write the parse results to a file
22:56:50 <jle`> as the parse results get popped out
22:57:06 <jle`> it sounds like with just the tutorial i can get the result as one big chunk and then write them at the end
22:57:55 <jle`> but taht seems to defeat the whole purpose of pipes
22:58:25 <johnw> in conduit that would be calling a ZipSink
22:58:40 <johnw> so that you could send parse results downstream to both a consumer and a file-writer
22:59:04 <johnw> someday I should just build a pipes<->conduit lexican
22:59:05 <johnw> lexicon
22:59:45 <jle`> hm
22:59:49 <levi> Listening to the last Haskell Cast, you'd think they were well-nigh identical already.
22:59:54 <mgsloan> In the haskell cast, tekmo was suggesting that it'd be feasible to wrap a Pipe as a Conduit
23:00:18 <jle`> ah yah the latest one is tekmo and snoyman isn't it
23:00:42 <mgsloan> Nah, it was both of them :D
23:00:46 <jle`> also a slightly unrelated question, can i turn my haskell-cafe subscription from digest into individual? i can't seem to find the place
23:00:55 <jle`> the form
23:01:10 <jle`> i tried re-subscribing as individual but it chastised me
23:01:33 <jle`> do i have to just unsubscribe and re-subscribe?
23:02:14 <johnw> go to the mailman console for that group
23:02:38 <jle`> oh! it turns out that pipes-parse returns the used things as a Producer
23:02:46 <jle`> not as a big chunk
23:02:50 <jle`> so i get streaming results for free
23:02:58 <levi> jle`: In my use of pipes for parsing incoming data, I just have my producer emit bits of parsed data as it finishes parsing them. If you're parsing something like a big structured document that isn't finished until the stream finishes, though, I am not sure how you'd chunk it.
23:03:23 <jle`> levi: i was looking at result <- evalState something something
23:03:39 <jle`> hm
23:03:42 <jle`> wait
23:04:09 <jle`> levi: how would you compose that?
23:04:42 <jle`> if i do result <- evalState parserpipe producer
23:05:04 <jle`> how would i write result to a file as it gets emitted?
23:05:20 <jle`> or am i structuring wrong
23:05:44 <jle`> where my parserpipe does emit as it goes along
23:06:16 <jle`> (my previous revelation was actaully a misled one so i am actually still lost :) )
23:10:15 <levi> Well, result is then antother producer.
23:10:38 <jle`> evalStateT :: Parser a m r -> Producer a m x -> m  r
23:10:45 <jle`> it looks like the result is just the produced r ?
23:11:27 <levi> You want runStateT
23:11:50 <jle`> runStateT  :: Parser a m r -> Producer a m x -> m (r, Producer a m x)
23:11:56 <jle`> still i get the result as r ?
23:12:02 <levi> That's the leftovers.
23:12:02 <jle`> i don't mean to be facetious
23:12:31 <jle`> the producer is the producer of leftovers, right?
23:13:05 <levi> No, the Producer emits the stuff you parsed in its new form.
23:13:20 <jle`> so what is r?
23:13:24 <levi> The leftovers.
23:13:36 <levi> Think of a regular Monadic parser.
23:14:07 <jle`>  -- Feed a 'Producer' to a 'Parser', returning only the result
23:14:10 <jle`>  
23:14:14 <jle`> evalStateT :: Parser a m r -> Producer a m x -> m  r
23:14:18 <jle`> hm
23:14:21 <jle`> i'll try it out
23:15:03 <jle`> i think i am just fundamentally structuring this weirdly
23:16:12 <levi> Maybe I'm confused about this. I probably am.
23:16:47 <jle`> basically i have a terminating stream of Bools that i want to turn into a stream of Word8's
23:16:58 <jle`> which i turn into a stream of Bytestrings
23:17:02 <jle`> that i write as they come
23:17:12 <levi> You're right, the producer is for the leftovers.
23:17:35 <levi> But, like a normal pipe, *returning* is not the normal way that data flows.
23:17:45 <jle`> so if i do (result,leftovers) <- runStateT boolsToWord8Parser boolStream
23:17:51 <jle`> then i can't use the results until the very end, right?
23:17:58 <jle`> or maybe there is some magic here
23:18:00 <jle`> some pipes magic
23:18:27 <levi> Think about how you normally move data through pipes.
23:18:43 <jle`> i usually compose a bunch of pipes with >->
23:18:47 <levi> You await inputs and yield outputs
23:18:58 <levi> Only when the pipeline terminates do you actually return.
23:19:09 <jle`> ah yeah.
23:19:18 <jle`> so the return value isn't even what i want?
23:19:31 <jle`> because right now my naive non-termination-aware pipe chain just returns ()
23:19:42 <levi> That's how it seems to me at the moment.
23:19:51 <jle`> well it does what i want, at the moment
23:20:11 <jle`> except i lose the last few bits
23:20:14 <jle`> hm
23:20:18 <jle`> yeah, the result isn't what i want?
23:20:23 <jle`> but how do i do this then?
23:20:26 <jle`> :|
23:20:40 <jle`> Tekmo used to always be here, why did he have to get a job at Twitter :'(
23:20:47 <jle`> although i am very happy for him :)
23:21:30 <levi> Well, you want to parse a widget out of your stream. So you get a widget as a return value from runStateT, and then you yield it, and loop to parse another widget.
23:22:19 <jle`> so i have a pipe in my pipe?
23:22:26 <jle`> i runStateT within my pipe?
23:22:51 <johnw> o noes, there's a pipe in my pipe!
23:22:53 <jle`> and then compose it with normal pipe stuff?
23:22:59 <jle`> yo dawg.
23:24:00 <jle`> this seems a bit complex for something simple, but it might just be my lack of familiarity with the pipe idioms
23:24:37 <levi> jle`: No, it's more of a producer transformer.
23:24:55 <jle`> hm.
23:25:00 <johnw> jle`: I would agree that it's a bit complex for something simple
23:25:03 <jle`> one day i want to write a conduit/pipes with an arrow interface
23:25:09 <levi> You transform a producer of bytestrings to a producer of widgets.
23:25:09 <jle`> that way everything will be simple.
23:25:42 <jle`> i just want to transform a producer of bits into a producer of bytes, handling early termination
23:26:10 <jle`> is there an Arrowized Stream library?
23:26:15 <jle`> Arrows are out of fashion these days though
23:26:23 <jle`> if there was one it must be a decade old
23:27:02 <levi> Applicative functors are the new hotness.
23:27:15 <jle`> oh
23:27:23 <levi> One of these days we'll get official idiom brackets in the syntax.
23:27:39 <jle`> i think edwardk / runar bjarnason's machines library
23:27:46 <jle`> might be usable with an arrow interface
23:28:00 <jle`> because their streamers are all arrows
23:28:10 <jle`> but i think it's not in active development
23:29:40 <jle`> maybe this is my chance to contribute
23:31:07 <levi> It does seem like a nice library.
23:33:17 <jle`> i think edwardk just said that he didn't have the time to refine it to the point of industry-ready
23:35:27 <levi> Yeah, I recall him saying something like that.
23:35:58 <jle`> i can't quite blame him
23:36:25 <jle`> it looks like it takes a lot of time and affection/care to optimize a library like pipes/conduit
23:36:57 <levi> No kidding.
23:37:33 <jle`> i'm not even sure how snoyman has enough time/attention to be intimately involved in so many 'industrial' projects
23:38:42 <jle`> much respect for both men.
23:43:04 <codygman> I've heard that hxt is slow and uses a lot of memory, is this true?
23:45:10 <levi> I dunno.
23:48:26 <tdammers> edwardk deserves "hero" status for lens alone
23:50:15 <johnw> jle`: they get used, every day
23:52:03 <klrr_school> okey, anyone got an idea how to model a irc in an extendible way using FRP? im thinking of a callback solution so you simply create a handler function ("[Text] -> IO Text") put it in a map and then the eventhandler exectutes it when it parses a command that someon send from irc, but ive heard that this will hit "the complexity wall" and that FRP is a better solution, while i could write it using FRP i cant really figure out an a
23:52:15 <klrr_school> (i.e. easy to add more "commands" to the bot)
23:52:22 <klrr_school> s/irc/irc bot
23:52:37 <jle`> johnw: they?
23:52:50 <johnw> all those industrial libraries
23:53:01 <johnw> at fpcomplete, we used most of them, daily
23:53:39 <jle`> yeah, that probably motivates him to invest more time in them :)
23:54:23 <klrr_school> found this in logs: http://conal.net/blog/tag/bot
23:54:42 <johnw> I really enjoy programming with conduit
23:54:47 <johnw> but, then, I loved SERIES in Common Lisp too
23:57:51 <klrr_school> okey i think the link above is unreletaed
