00:06:49 <jle`> math? in my programming languages?  and not discrete math/category theory?  blasphemy.
00:09:16 <johnw> ion: that's pretty cool
00:09:53 <johnw> but that costs a division for each number, rather than simple addition
00:17:21 <Ghoul_> cmake/haskell https://github.com/kvanberendonck/cmake-haskell :)
00:21:42 <ion> > let phi = (1 + sqrt 5)/2 in unfoldr (\n -> Just (n - phi, 1/(1+n))) 0
00:21:43 <lambdabot>  [-1.618033988749895,-0.6180339887498949,-1.118033988749895,-0.95136732208322...
00:21:54 <ion> > drop 20 $ let phi = (1 + sqrt 5)/2 in unfoldr (\n -> Just (n - phi, 1/(1+n))) 0
00:21:55 <lambdabot>  [-1.000000003732537,-0.9999999985742978,-1.0000000005445697,-0.9999999997919...
00:22:12 <ion> whoops
00:22:14 <ion> > drop 20 $ let phi = (1 + sqrt 5)/2 in unfoldr (\n -> Just (n - phi, 1/(1+n))) 1
00:22:15 <lambdabot>  [-0.9999999985742978,-1.0000000005445697,-0.9999999997919929,-1.000000000079...
00:22:36 <ion> Wait, still not right. Meh.
00:23:06 <ion> Should have been 1+1/n
00:24:30 <ion> The sequence of Rationals (which were shown without the denominator) converges to phi.
00:24:37 <ion> s/to/toward/
00:27:52 <no-n> is there some ghci command to get it back the way it was when you begin ghci, rather than quitting and starting it agin?
00:28:08 <jle`> http://www.evanmiller.org/mathematical-hacker.html
00:30:14 <Cale> no-n: Well, there's  :load
00:30:18 <Cale> (with no modules)
00:30:24 <no-n> aha
00:30:28 <no-n> ty
00:39:48 <kadoban> is there something cute i can do with a type like Either a (Either b c) ?  I'm really only interested in c,'a' and 'b' are just different types of errors...
00:40:08 <kadoban> can i like, combine that somehow into...something less crap to work with?
00:40:10 <johnw> you could use lens
00:40:36 <kadoban> hmm, i've heard of that, but that's the extent of my knowledge...
00:40:41 <johnw> > Right (Right "Hello") ^? _Right._Right
00:40:43 <lambdabot>  Just "Hello"
00:40:53 <Fuuzetsu> there's a function arrow missing in type of ‘index’ at section 13.1 of http://www.haskell.org/tutorial/arrays.html so it'd be great if someone with power could fix it up
00:41:01 <kadoban> wow, that looks super cool
00:41:11 <johnw> it is!
00:41:19 <johnw> > Left "Uh oh" ^? _Right._Right
00:41:20 <lambdabot>  Nothing
00:41:52 <kadoban> johnw: thanks a bunch, i'll look that up...sure looks like exactly what i want
00:42:59 <jle`> Fuuzetsu: oops
00:43:26 <jle`> kadoban: why not join?
00:43:40 <jle`> > join (Right (Right "hello"))
00:43:41 <lambdabot>  Right "hello"
00:43:56 <jle`> > join (Right (Left "Uh oh"))
00:43:56 <johnw> join needs Either a (Either a b)
00:43:57 <lambdabot>  Left "Uh oh"
00:44:02 <johnw> doesn't it?
00:44:05 <jle`> oh, i missed that
00:44:08 <jle`> yeah, it does
00:44:20 <kadoban> oh, darn, i was hoping i missed something, heh :)
00:44:20 <jle`> cause of instance Monad (Either a)
00:44:37 <johnw> and wouldn't a need a Monoid constraint toO?
00:45:15 <jle`> i don't think the default monad instance for either combines the errors
00:46:14 <jle`> and i don't think monad instances can combine errors either >.>
00:46:17 <jle`> only applicatives?
00:46:26 <jle`> unless i'm misunderstanding you
00:46:48 <johnw> oh, never mind me
00:46:59 <johnw> I was thinking of a product type, not a sum type
00:47:56 <eatman> Ola
00:48:06 <jle`> howdy
01:17:13 <makalu> is there a common short way to say "exception"?
01:17:22 <makalu> write not say
01:17:41 <Cale> Not sure what you mean?
01:18:21 <makalu> my code deals a lot with exceptions and I'm looking for a way to have shorter variable names :)
01:18:27 <johnw> exc
01:18:40 <johnw> or suffix with Ex
01:18:50 <makalu> thank you
01:19:07 <Yaniel> SpecialCaseOfAGenericNamedException
01:19:12 <luite> x@pn
01:19:20 <Yaniel> oh right, it's not java
01:21:12 <johnw> lol
01:21:23 <_arch> DD
01:41:55 <makalu> in an imperative programming language with loops, should a "break" outside of a loop be detected while parsing?
01:42:14 <makalu> (I'm sorry that I'm asking on the wrong channel :)
01:44:38 <makalu> I think with parsec's user state I could check it while parsing
01:46:02 <Jaxan> I think it's a syntax error in Python
01:46:37 <Jaxan> but it doesn't really matter where you detect it, right?
01:49:48 <makalu> it does matter. If I detect it during parsing/compilation vs runtime.
01:50:54 <_ikke_> It should be detected during parsing
01:51:14 <Jaxan> I assumed you're writing a compiler, so I didn't think of runtime detection
01:51:33 <makalu> ok thanks
01:51:58 <makalu> I'm writing a small prototype interpreter for a dynamically typed language
02:10:21 <awestroke> how would I (with Parsec) parse each line as a k: v pair until an empty line, then parse the rest of the text as a string value?
02:10:39 <awestroke> is it possible?
02:10:57 <Athas> Yes.
02:11:22 <Athas> do { pairs <- many kvPair; rest <- satisfy (const True) }
02:11:55 <Athas> 'many kvPair' will parse as much as it can, and then you can just do whatever you want with what remains.
02:13:37 <johnw> i think many anyChar may be easier to read
02:39:20 <awestroke> I get parseerror for the end of file from my parser: parseMList = endBy (sepBy parseM (string "-------------- next part --------------\n")) eof
02:40:03 <awestroke> does the parseM have precedence or can I be sure that the splitting on "-------..." is done before parseM is run on each block?
02:45:22 <awestroke> nevermind... that wasn't the problem
02:57:01 * hackagebot classy-prelude 0.8.2 - A typeclass-based Prelude.  http://hackage.haskell.org/package/classy-prelude-0.8.2 (MichaelSnoyman)
02:58:23 <asQuirreL> ski: Sorry, I left just as you made your last point, but that's exactly right :P I think I did mean extensional equivalence
03:01:50 <awestroke> Athas: pairs  <- many kvPair only parses one kv pair
03:02:02 * hackagebot mono-traversable 0.4.0.4 - Type classes for mapping, folding, and traversing monomorphic containers  http://hackage.haskell.org/package/mono-traversable-0.4.0.4 (MichaelSnoyman)
03:03:01 <Athas> awestroke: does kvPair remove trailing whitespace?
03:03:12 <Athas> Maybe you need to use sepBy to remove the linebreaks, then.
03:06:46 <awestroke> Athas: https://gist.github.com/awestroke/16dc6732e69649e98b32
03:07:00 <awestroke> look at the comment by kvPair
03:09:10 <Athas> Okay, so it does not.  You need kvPair `sepBy` newline, probably.
03:10:30 <angerman> Hi. I'm not yet vested in Haskell. I intend to do some http(s) posting, which library would I use? Network.Http.Client?
03:18:45 <Axman6> anyone know a good introduction to working with type level lists? I need to be able to check if a list contains a certain type, add a type to the list if it doesn't already exist in it, and remove a given type from the list
03:19:15 <Axman6> currently I'm working on the Contains part of it, and GHC doesn't like instance Contains e '[] 'False
03:20:04 <Axman6> (the '[] part is what it's complaining about)
03:20:29 <Axman6> angerman: I'd have a look at the conduit stuff, I thing there's a conduit http client library somewhere
03:21:53 <angerman> Axman6: thanks. I'll take a look.
03:22:20 <Axman6> angerman: no guarantee that's what you want, but thought i should say something because there's not many people around
03:23:00 <Axman6> angerman: https://hackage.haskell.org/package/http-client
03:23:48 <Axman6> might be a little advanced if you're new to haskll
03:23:53 <Axman6> +e*
03:24:29 <Axman6> http://hackage.haskell.org/package/HTTP looks easier
03:24:41 <angerman> Axman6: http://hackage.haskell.org/package/http-streams-0.4.0.0/docs/Network-Http-Client.html
03:24:46 <angerman> that's what I was looking at, at first.
03:25:17 <Axman6> yeah that looks pretty nice too
03:26:13 <angerman> alright. I think I just have to pick one and go with it for now. :)
03:27:05 * hackagebot resourcet 0.4.10.2 - Deterministic allocation and freeing of scarce resources.  http://hackage.haskell.org/package/resourcet-0.4.10.2 (MichaelSnoyman)
03:36:39 <eyem> Im fetching json from api, problem is that it's in this form: Chunk {json} Empty, in which step could I extract the json from that list?
03:40:16 <eyem> Oh nvm it's part of the ByteString ?
03:45:52 <awestroke> how can I change "manyTill anyChar (test newline)" to continue parsing if the newline is followed by indentation?
04:02:14 <byorgey> carter: no hac phi this year, I think
04:02:39 <byorgey> carter: all the organizers are frantically trying to get jobs and/or graduate, ideally both.
04:14:36 <Heather> how to remove an value from list?
04:16:07 <bartavelle> Heather, filter might be what you are looking for
04:17:22 <angerman> Hm. So I'm using emacs with the interactive-haskell mode. Is there a switch to get arrow-up arrow-down like history?
04:17:29 <awestroke> I tried: value <- manyTill anyChar $ newline >> (lookAhead $ try (notFollowedBy $ string "  "))
04:18:23 <Heather> bartavelle: right
04:23:13 <r0ly> Hi there
04:24:00 <r0ly> I just wrote my first lines of haskell
04:24:06 <jle`> r0ly: congrats :)
04:24:06 <r0ly> and that was really hard
04:24:20 <r0ly> I'm interested in getting some feedback
04:24:37 <r0ly> https://github.com/OlivierGonthier/daylistCSV-generator
04:25:24 <r0ly> sources from pandoc on github helped me a lot :)
04:27:00 <r0ly> I found it really painful to dive into haskell/functional, coming from a java world
04:27:12 <r0ly> but so much interesting
04:34:21 <Cale> r0ly: cool :)
04:34:36 <flebron> Hi. So it's not really true that if I have a natural transformation n :: Identity -> Identity, then n must be the identity function at each component. So barring bottom and const bottom, why can I conclude that f :: a -> a is the identity?
04:35:23 <DR6> let's see
04:35:31 <Cale> flebron: I don't have a really good category theoretical explanation of that
04:35:39 <DR6> f :: forall a. a -> a
04:35:45 <Cale> flebron: But there's something called free theorems :)
04:35:49 <Cale> @free id
04:35:50 <lambdabot> f . id = id . f
04:36:09 <Cale> ^^ this is a theorem computed from the type of id
04:36:12 <flebron> Right, I assume all free theorems are just the diagrams for those natural transformations (I should really read the aper)
04:36:35 <flebron> Right, si f . id = id . f, but these needn't equal f, right?
04:36:44 <flebron> s/si //;
04:36:59 <Cale> Oh, hm, good point.
04:37:23 <merijn> flebron: In haskell they do need to equal f
04:37:33 <merijn> flebron: Haskell differs from CT here
04:37:48 <Cale> Well, it's that parametricity differs from naturality
04:37:58 <merijn> flebron: Parametricity of id's type requires "f . id = f = id.f"
04:38:27 <flebron> Is the free theorems paper the place to read to learn about parametricity? (I'm guessing it's stronger than naturality?)
04:39:32 <merijn> flebron: Well, the thing is that "id :: forall a . a -> a", however, in CT you have id_A and id_B and you get "id_B . f = f . id_A"
04:40:42 <merijn> flebron: So it's hard to argue that "id_B . f = f" because we don't know anything about id_B, however in Haskell id's type tells us that "id_B = id_A"
04:42:17 <Cale> For some weird notion of equality :)
04:42:31 <flebron> How does the latter equality allow us to know id_B . f = f?
04:42:36 <Cale> (but it's true, they really are the same)
04:42:47 <flebron> RIght, I was going to ask which notion of "=" was being used in the last one.
04:43:10 <merijn> Intensional and extensional equality :p
04:44:40 <Cale> flebron: I don't know how to treat this 100% satisfactorily in an abstract way, but operationally, there is only one id function, not one for each type, and hence its implementation is not allowed to assume anything about the type of its argument
04:45:35 <flebron> Right, yeah, that much is clear, though it would seem one would need to quotient by generated Core code to get the "=" then :p
04:46:06 <eyem> Quick question how do you dig into third lvl of json, I'm using >>= to get to second, where do i go from here?
04:46:20 <Cale> eyem: What?
04:46:40 <Cale> eyem: Which JSON library are you using?
04:46:50 <eyem> Cale: Aeson
04:47:07 <eyem> ((o .: "data") >>= (.: "username")) but i need to get 1 lvl deeper into json object
04:48:04 <Cale> (.:) :: FromJSON a => Object -> Text -> Parser a
04:48:22 <Cale> and Parser is a monad
04:48:31 <Cale> So, you can equivalently write
04:48:49 <Cale> do d <- o .: "data"
04:49:02 <Cale>    u <- d .: "username"
04:49:07 <Cale>    return u
04:49:28 <Cale> and then it's obvious how to stick in more requests :)
04:49:38 <eyem> Cale: yes, thanks! :D
04:50:31 <flebron> merijn: Is there a paper which could help understanding this? (This stems from me discussing a talk I'll be doing on some Haskell topics, and a mathematician friend noting that if one is in, say, the category of R-modules, multiplying by 3 is a natural transformation from Id to Id, but isn't the identity.)
04:51:13 <Cale> flebron: Let me know if you find something especially good
04:51:34 <Cale> It's informally clear that parametrically polymorphic types are much stronger than plain naturality
04:51:40 <Cale> (I think?)
04:51:55 <Cale> But formally, I'm not sure exactly the extent to which this is the case.
04:52:25 <merijn> flebron: If there is such a paper, I dunno
04:52:57 <merijn> flebron: I still understand jack-all about CT other than basic definitions of a category, arrows, objects
04:53:13 <merijn> flebron: The parametricity has always been "obvious" to me
04:55:08 <Cale> If you want to construct a value of an unknown type, your only option is _|_ (or if you want to be especially picky and Haskell-specific, then you have to account for applying seq to any subset of the variables in context)
04:55:13 <Axman6> @hoogle catch
04:55:13 <lambdabot> Prelude catch :: IO a -> (IOError -> IO a) -> IO a
04:55:13 <lambdabot> System.IO.Error catch :: IO a -> (IOError -> IO a) -> IO a
04:55:13 <lambdabot> Control.OldException catch :: IO a -> (Exception -> IO a) -> IO a
04:55:56 <Axman6> @hoogle Exception e => IO a -> (e -> IO a) -> IO a
04:55:56 <lambdabot> Control.Exception.Base catch :: Exception e => IO a -> (e -> IO a) -> IO a
04:55:56 <lambdabot> Control.Exception catch :: Exception e => IO a -> (e -> IO a) -> IO a
04:55:56 <lambdabot> Control.Exception.Base handle :: Exception e => (e -> IO a) -> IO a -> IO a
04:55:58 <Cale> If you have a value of an unknown type, there is very little you can actually do with it, other than pass it around.
04:56:17 <Cale> In particular, not knowing what type it is, you can't case match on it.
04:56:51 <Cale> But there really is another function in Haskell of type a -> a which isn't id
04:56:56 <Cale> there's const undefined
04:57:08 <flebron> Right, which except for seq is just undefined.
04:57:13 <Cale> as well as undefined (which seq can tell apart from const undefined, but otherwise those are the same)
04:57:22 <Cale> right
04:58:15 <Cale> In a total setting, you needn't worry about _|_, and there's no primitive way to get a value of an arbitrary type (assuming that the system is consistent)
04:58:33 <Cale> and then id really is the only thing
04:58:55 <Cale> Actually, I lied, I do have a way to discuss this, homotopy theoretically ;)
04:59:31 <Cale> But it's weird, because you have to consider fibrations whose base space is a universe
04:59:48 <flebron> Ah yes, that subject of which I know even less about than parametricity :)
05:01:45 <Cale> (and besides, that's a whole other type system)
05:02:20 <flebron> Does GHC use free theorems for optimization?
05:04:11 <Cale> I don't believe so
05:04:20 <Cale> Well, not on its own
05:04:28 <Cale> There are RULES pragmas in the libraries
05:04:50 <Cale> which encode optimisation rewrites, some of which might be justified by free theorems
05:05:08 <Cale> (in fact, some of which definitely are justified by free theorems)
05:06:57 <flebron> Right, like the ones used in Vector?
05:07:17 <flebron> Any particular reason why deriving these free theorems wouldn't be a Good Thing (tm)?
05:09:02 <c_wraith|N10> Many free theorems don't hold up in the face of bottoms.
05:09:42 <flebron> Ah, good point.
05:11:21 <awestroke> what am I doing wrong here? It should split at ---- : https://gist.github.com/awestroke/e7afdd544170f49efe49
05:12:11 <angerman> I'm doing it wrong when ghci seg faults, right?
05:16:01 <haasn> I wonder if compilers for total languages otherwise similar to Haskell could use free theorems for optimization
05:17:17 * hackagebot xml-picklers 0.3.5 - XML picklers based on xml-types, ported from hexpat-pickle  http://hackage.haskell.org/package/xml-picklers-0.3.5 (PhilippBalzarek)
05:18:24 <quicksilver> awestroke: 'many' is basically greedy
05:18:33 <quicksilver> oh, did that get through?
05:18:38 <quicksilver> awestroke: 'many' is basically greedy
05:18:54 <quicksilver> the 'many anyChar' part will happily match all those ----
05:18:57 <dmwit> angerman: Unless you are writing FFI code, chances are you're fine and some library or GHC author is doing it wrong.
05:19:31 <angerman> dmwit how do i figure out what's wrong?
05:20:27 <dmwit> Is it reproducible?
05:20:32 <dmwit> If so, minimize the reproducing examyle.
05:23:00 <awestroke> quicksilver: is there a non-greedy version of many?
05:23:27 <quicksilver> awestroke: no, that doesn't really make sense.
05:23:41 <quicksilver> awestroke: you need to think, how is the parser supposed to work?
05:23:53 <quicksilver> is it just four dashses on its own on a line which divides blocks?
05:24:02 <quicksilver> are dashes completely forbidden in blocks?
05:24:03 <awestroke> quicksilver: then what good is sepBy ?
05:24:35 <quicksilver> awestroke: for example: 1,2,3,4,5 or a::b::c::d::e
05:25:48 <quicksilver> one question you might ask yourself is: how should "------" parse? how should "ab-----cd" parse?
05:25:59 <quicksilver> that being 6 and 5 dashes respectively. And yes, that was two questions.
05:26:19 <angerman> dmwit: https://gist.github.com/angerman/2f1f317784f3e271ce4d
05:26:53 <angerman> It maybe not so smart to submit an empty request, but that was the example reduced to as little as I could.
05:26:56 <angerman> still crashes :(
05:27:52 <awestroke> quicksilver: so what's the solution if the separating line is always "\n----\n" ?
05:28:43 <quicksilver> awestroke: personally, for that case, I wouldn't use parsec. I'd just use "lines" to split the input into lines
05:28:58 <quicksilver> and then split into blocks by checking for "----"
05:29:01 <dmwit> angerman: At a guess, I would blame the guy who wrote Network.Http.Client. What package is that from? I'll be happy to tell you if things crash here as another data point fo ryou.
05:29:51 <awestroke> quicksilver: some things are split over 2 lines
05:30:03 <quicksilver> awestroke: which is fine.
05:30:05 <angerman> dmwit: http-streams
05:30:16 <awestroke> and a chunk of text follows k/v values
05:30:18 <quicksilver> awestroke: in my method, you have a series of blocks (each block is a list of strings)
05:30:24 <quicksilver> awestroke: and they're split by ----
05:30:33 <awestroke> quicksilver: my example code is simplified
05:31:05 <awestroke> quicksilver: I am parsing the mbox format
05:31:30 <awestroke> so I can't just do: split "--------- next part ---------" $ lines content    and call it a day
05:31:42 <GaveUp> trying to think through a particular problem and could use some ideas.  I'm looking to create an infinite series that contains all the numbers that contain just 0's and 9's in sorted order ... there's a fairly obvious pattern to the numbers but I'm not coming up with a good way to generate the list without some ugliness
05:31:54 <quicksilver> > splitOn ["----"] . lines $ "hello\nthis is a block\n----\nthis is another block"
05:31:55 <lambdabot>  [["hello","this is a block"],["this is another block"]]
05:31:58 <quicksilver> awestroke: ^^
05:32:27 <awestroke> quicksilver: exactly, that insn't good enough
05:32:30 <awestroke> each email is parsed
05:32:40 <quicksilver> In what sense is that not good enough?
05:32:51 <quicksilver> what part of that isn't what you want?
05:33:07 <dmwit> angerman: Yes, it segfaults here, too. So I would file a bug on the http-streams bug tracker.
05:33:24 <quicksilver> that gives the blocks parser you asked for, subject to clarification about what the separator really is.
05:33:38 <dmwit> angerman: If you're feeling particularly motivated, you could continue trying to minimize the example by substituting in code from the http-streams library to try to track down exactly what's going wrong yourself.
05:33:49 <dmwit> angerman: Or you can hope the http-streams author will do that. =)
05:34:05 <angerman> dmwit: first day with haskell.
05:34:28 <awestroke> quicksilver: I first parse and discard all lines until (with lookahead) a line starting with "From:", when I parse each line as a "key: value" tuple until  there's no more of those, then I use the rest as the messsag
05:34:40 <awestroke> message
05:34:48 <dmwit> angerman: what a day, huh? sorry about that =P
05:35:02 <quicksilver> awestroke: ok
05:35:08 <angerman> dmwit: yea, great start :) Now I need a better HTTP lib.
05:35:10 <quicksilver> awestroke: but you could still use this method on the message bodys.
05:35:38 <quicksilver> awestroke: parsing doesn't have to be a monolithic task; you can do modular parsing and re-parse certain bits with different tools.
05:35:44 <quicksilver> the right tool for the right part of the job
05:35:48 <quicksilver> are you trying to split mime parts?
05:35:54 <awestroke> alright
05:35:58 <awestroke> mime parts?
05:36:03 <quicksilver> I'm guess.
05:36:11 <quicksilver> MIME parts have separators a bit like what you asked for :)
05:36:16 <quicksilver> but if not, then not.
05:36:59 <dmwit> angerman: I don't really know much about the different HTTP libraries.
05:37:06 <dmwit> Perhaps there's something on the wiki comparing them.
05:38:54 <Galactic> anyone knows if the function isInfixOf uses the KMP algorithm?
05:39:01 <dmwit> It does not.
05:39:16 <Galactic> aaa k, thanks
05:39:18 <dmwit> (I'm not really sure KMP makes sense for linked lists anyway.)
05:39:20 <awestroke> quicksilver: it's a solution, but the separator is not always the same
05:39:35 <quicksilver> http://hackage.haskell.org/package/KMP-0.1.0.2 exists, though.
05:39:37 <angerman> dmwit: will figure it out :)
05:39:45 <quicksilver> whether it makes sense or not :)
05:40:19 <quicksilver> awestroke: that's the great thing about function parameters, you can pass a calculated value to them ;)
05:40:34 <quicksilver> splitOn currentSeparato . lines $ theseBlocks
05:41:04 <Galactic> why the name "Syntactic sugar"... why "sugar"?
05:41:18 <quicksilver> makes it sweeter
05:41:36 <quicksilver> it makes the syntax more palatable without really changing what it is underneath
05:41:49 <Galactic> I see
05:42:54 <angerman> dmwit: seems the isseu is with openssl :(
05:43:53 <Galactic> haha and then "Syntactic salt" which is the opposite... I did not know that.
05:45:19 <Galactic> the people who name this where thinking about food ingredients... "Syntatic syrup"  haha
05:45:44 <awestroke> quicksilver: I mean the separator can be many different things in the same text...
05:46:23 <awestroke> also, how do I stop parsec from smacking head first into the end of the string at full speed? I use "manyTill parseM eof" but it doesn't help
05:48:02 <awestroke> oh, "try"
05:53:09 <angerman> dmwit: wow... reading is not my strength :)
05:53:26 <angerman> "These convenience functions work with http and https, but note that if you retrieve an https URL, you must wrap your main function with withOpenSSL to initialize the native openssl library code."
05:54:35 <dmwit> oh snap
05:55:28 <dmwit> "Did you RTFM?", haha, oldest trick in the book and I missed it
05:55:39 <dmwit> angerman++ for figuring it out
05:56:57 <angerman> I can do it! Yes! :D
06:02:43 <angerman> if it's once IO, it's always IO, right? I don't get it back out, no?
06:05:14 <ski> angerman : right
06:05:46 <ski> angerman : if you just need mutable state, you can sometimes use the `ST' monad instead, and then you can "get out"
06:06:11 <angerman> no. It's network. so IO is probably right :)
06:06:36 * ski nods
06:07:33 <ski> the `IO' in the result ensures that the described computation(al effects) needs to be performed in a certain context, correctly sequenced with other operations
06:08:51 <ski> if you cheat and use `unsafePerformIO', then you lose the specification of the relative sequencing, and then the run-time system could possibly execute your effects at an unexpected time (due to the difficulty with determining exactly when thunks will be forced)
06:10:44 <ski> also, if you do that, then since the result looks like a normal `String' (or whatever the result is), the implementation will be licensed to apply normal equational laws to rewrite the program (e.g. for optimization, or changing the internal ABI), and this might cause side-effects to unexpectedly be performed more times that you intended .. or less times
06:11:01 <Eduard_Munteanu> Can Happy attribute grammars be used to get an unparser / printer for free? I'm thinking of parsing the input as text and assigning data structures as attributes, rather than parsing to an AST. Or perhaps the other way around.
06:13:52 <ski> the same equational laws holds for `IO'-actions -- but the difference is that with the I/O component being kept track of *explicitly* in the type, there is now a difference between `do x <- getLine; y <- getLine; return (act)' and `do xy <- getLine; let {x = xy; y = xy}; return (x,y)' .. while the former is still (by normal equational reasoning) equal to `do let {act = getLine}; x <- act; y <- act; return (x,y)'
06:14:26 <ski> s/act/xy/
06:15:42 <ski> if `xy' and `getLine' had the same type in the first two, then equational reasoning would naively claim those two equal -- while they wouldn't be, in a hypothetical variant of Haskell where the `xy <- getLine' there performed the effect once
06:28:57 <killy971> Hi
06:30:29 <killy971> Is there an easy way to run an external process and read its output in "real time" line by line?
06:31:26 <killy971> (well, I'm sure there is a way, but I'm wondering what is the idiomatic way to do it)
06:31:28 <heatsink> I think readProcess does that
06:32:15 <heatsink> There's also runInteractiveProcess.  It returns the output as a Handle
06:32:37 <killy971> readProcess seems to block until the process exits
06:33:59 <angerman> ski: thanks
06:35:02 <killy971> but indeed, it seems that someting like runInteractiveProcess may be what I'm looking for
07:08:16 <Newbie200> Hey, wonder if someone could answer a quick question?
07:08:35 <geekosaur> @where justask
07:08:35 <lambdabot> Just ask your question. If somebody knows, they'll answer. If not, they won't, and you'll wait around; it will be no worse than having nobody who wants to claim expertise.
07:08:37 <angerman> I think, asking to ask is not getting us anywhere ;)
07:08:51 <angerman> how do I drop \r and \n from a string?
07:09:01 <Newbie200> myFunc :: Int -> Float -> Float
07:09:06 <Newbie200> Doesn't compile
07:09:15 <Newbie200> I want to add an integer and float, returning a float.
07:09:17 <angerman> e.g. I expect base64 data, but it comes with \n \r intersperred.
07:09:29 <DR6> what definition did you give?
07:09:40 <Newbie200> myFunc x y = x+y
07:09:47 <haasn> Newbie200: check the type of (+)
07:09:49 <DR6> yeah that doesn't work
07:09:55 <haasn> :t (+)
07:09:56 <DR6> + is for equal ones
07:09:57 <lambdabot> Num a => a -> a -> a
07:09:59 <no-n> DR6 use fromIntegral on the Int
07:10:01 <haasn> Newbie200: the ‘a’s have to be the same
07:10:07 <Newbie200> I see
07:10:09 <haasn> so you need to convert from an Int to a Float
07:10:17 <haasn> fromIntegral is a good way, yes
07:10:35 <byorgey> angerman: filter (`notElem` "\r\n")
07:11:11 <Newbie200> Thanks
07:11:14 <Newbie200> I'll take a look at that
07:11:16 * haasn .oO( Are there more newlines in Unicode than \r and \n? )
07:11:28 <fizbin> haasn: Yes.
07:11:33 * flebron wonders, instead, if the number of newlines in Unicode is countably infinite.
07:11:37 <b80905> how do you use the `groupBy' function?
07:11:53 <haasn> flebron: uncountably, perhaps :)
07:12:13 <haasn> flebron: I only know about all of the different whitespace characters (for various width, nonbreaking, layout, etc.)
07:12:19 <byorgey> > groupBy (==) [1,2,2,3,3,3,2,2,2,2,3,4]
07:12:20 <haasn> which newlines are there, for example?
07:12:21 <lambdabot>  [[1],[2,2],[3,3,3],[2,2,2,2],[3],[4]]
07:12:27 <flebron> > groupBy ((==) `on` fst) [(1,2), (1,3), (2, 3), (3, 4), (3, 5), (1, 2), (1, 8)]
07:12:28 <lambdabot>  [[(1,2),(1,3)],[(2,3)],[(3,4),(3,5)],[(1,2),(1,8)]]
07:13:02 <byorgey> haasn: http://en.wikipedia.org/wiki/Newline#Unicode
07:13:07 <fizbin> haasn: Trivially, there's \u0085
07:13:20 <haasn> byorgey: thanks!
07:13:21 <fizbin> There are more though. I had to look that up once...
07:13:32 <haasn> I wonder if there's an isNewLine :: Char -> Bool though
07:14:23 <fizbin> ah, \u2028 - the character that makes it so that valid, spec-conforming JSON can be invalid as javascript source code.
07:14:46 <fizbin> Well, \u2029 as well.
07:15:27 <haasn> wouldn't be the first time javascript is incompatible with JSON (perhaps not syntactically, but semantically)
07:17:07 <fizbin> \u2028 and \u2029 are the only incompatibilities listed on http://timelessrepo.com/json-isnt-a-javascript-subset - what else did you have in mind?
07:19:45 <haasn> fizbin: I was thinking of number parsing; json allows any rational number (like Haskell integer/rational literals) including arbitrarily large and arbitrarily precise ones
07:20:11 <haasn> but JS, technically, interprets almost all inputs incorrectly
07:20:29 <fizbin> Ah.
07:21:17 <fizbin> At least there though, you don't have valid JSON that's flat-out invalid javascript, just that javascript rounds all the numbers to its limited numerical model.
07:29:31 <hexagoxel> how do I create a "thing" of kind "*->Constraint" ? (thing=constraintconstructor?)
07:29:58 <banister> is there anything like heroku for haskell?
07:30:05 <hexagoxel> i want "const ()", where const is type-level and () is the empty constraint
07:30:14 <hexagoxel> but i do not know how to express this
07:32:11 <south> Is there an easy way to completely uninstall the haskell platform on osx?
07:32:22 <merijn> hexagoxel: Type Families!
07:32:25 <south> I'm getting a stupid error with cabal and need to just wipe everything and reinstall
07:32:31 <merijn> south: Yes, there's an uninstaller, gimme a sec
07:32:42 <south> merijn: thanks!
07:32:54 <merijn> hexagoxel: The ConstraintKinds extension will let you return constraints and TypeFamilies lets you write type level functions
07:33:12 <merijn> hexagoxel: For an accessible introduction, I recommend grabbing the "Fun with Type Functions" paper
07:33:43 <c_wraith|N10> I don't think that even needs a type family.
07:33:45 <merijn> south: There should be an Uninstaller script in /Library/Frameworks/GHC.framework/Versions/Current/Tools/
07:33:54 <merijn> c_wraith|N10: Perhaps not?
07:34:05 <south> merijn: I'll check it out. Thank you!
07:36:19 <merijn> c_wraith|N10: I think you do
07:36:46 <merijn> For example, this doesn't work: http://lpaste.net/101943
07:39:47 <merijn> hexagoxel: These two solutions work: http://lpaste.net/101943
07:39:58 <merijn> The second is conceptually nicer, but only works in >7.8
07:40:03 <south> merijn: That seems to have worked, hopefully it fixes my issue
07:40:18 <no-n> @pl maternal s = mother s >>= liftM2 mplus mother father
07:40:18 <lambdabot> maternal = (liftM2 mplus mother father =<<) . mother
07:40:25 <merijn> hexagoxel: The first should work with 7.6 (and potentially 7.4?) but is less elegant
07:40:57 <thebnq> What are the ' in types?
07:41:02 <ron__> good morning
07:41:08 <merijn> thebnq: Disambiguation for DataKinds
07:41:39 <Axman6> thebnq: lifts a data constructer/type into a type (I'm sure there's a better name)
07:41:49 <thebnq> aha thanks, thats easier to google than ' :D
07:41:57 <merijn> Axman6: It doesn't lift it, the DataKinds extension already does, it disambiguates
07:42:03 * Axman6 yeilds to merijn who has in the last few hours taught him everything he knows about this stuff
07:42:17 <Axman6> right, that makes sense
07:42:49 <merijn> thebnq: For example, [Int] can be 1) a type of kind * (i.e., the standard list of Int) or 2) a type level list of types of kin [*]
07:43:15 <merijn> The ' disamabiguates and tells GHC "I meant a type level list of kind [*]"
07:43:43 <thebnq> What is a type level list [Int]?
07:43:54 <c_wraith|N10> merijn: I got «type Const (a :: Constraint) b = a» to work.
07:44:06 <Axman6> testTrue :: Throws '[Bool, Char, Int] a for example
07:44:16 <merijn> c_wraith|N10: Oh? I tried that too, but it failed. Admittedly I think I only tried that with 7.6
07:44:31 <merijn> thebnq: Well, a list, but on the type level :)
07:44:53 <merijn> thebnq: Like "[Int, Char, Bool]" is a type level list that contains types
07:45:34 <merijn> Is there a good DataKinds introduction? Or is that something I should write myself to answer these questions :p
07:45:54 <Axman6> if there isn't, yes!
07:45:59 <thebnq> hmmm is this a dependant type?
07:46:08 <merijn> thebnq: No, but it's haskell's attempt to fake them
07:46:14 <merijn> Or rather
07:46:16 <Axman6> I'm having a lot of fun with this, I'll show you what I've got so far merijn (seems somewhat complete)
07:46:20 <merijn> Related too haskell's attempts at faking them
07:46:29 <mornfall> :-)
07:46:32 <Axman6> https://gist.github.com/axman6/9830049
07:46:33 <bahamas> merijn: thanks for the explanation regarding guard and MonadPlus yesterday. I think I finally got it
07:46:35 <c_wraith|N10> Giving types a promotion? That's the original paper. Don't know how well it answers these questions, though.
07:46:37 <mornfall> merijn: it's not faking if it's undecidable ;-)
07:47:01 <merijn> Axman6: I've been planning to give a talk on advanced type hackery here, but I had to postpone until the FP meetup here had had their "basic haskell" intro this week :p
07:47:04 <c_wraith|N10> Or was it Giving data a promotion? One of them.
07:47:07 <merijn> bahamas: \o/
07:47:20 <Axman6> merijn: heh, excellent =)
07:47:34 <Axman6> thebnq: you might also be interested in that gist of mine above
07:48:28 <merijn> Axman6: Basically, my talk title will be "ever open a file starting like your paste and wonder WTF is going on?" :p
07:48:31 <thebnq> (>_< it ruins highlighting)
07:48:31 <hexagoxel> merijn: thanks for the help. had to import GHC.Exts, not Prim in 7.6. i still can not use (Const ()), because "Type synonym `Const' should have 2 arguments, but has been given 1".
07:48:34 <mornfall> ConstraintKinds are a cool addition regardless...
07:48:46 <hexagoxel> but i might want to read that paper first before i continue on my specific problems :)
07:49:00 <merijn> hexagoxel: "Const ()" is missing an argument
07:49:12 <hexagoxel> yeah i want partial application
07:49:19 <merijn> hexagoxel: You can't
07:49:31 <merijn> hexagoxel: Haskell's type system is advanced enough
07:49:33 <Axman6> the Merge data family is less efficient than it should be, but I wanted to make sure that the order was maintained for the elements in both lists, and the elements of rs is at the end
07:49:53 <hexagoxel> <hexagoxel> how do I create a "thing" of kind "*->Constraint"
07:50:10 <merijn> Right, but you can't have partially applied types in haskell
07:50:18 <hexagoxel> hmm ok
07:50:25 <haasn> :t unfold
07:50:26 <lambdabot>     Not in scope: `unfold'
07:50:26 <lambdabot>     Perhaps you meant one of these:
07:50:26 <lambdabot>       `BS.unfoldr' (imported from Data.ByteString),
07:50:30 <Axman6> github does not like random "'"'s
07:50:40 <mornfall> merijn: you can fake that too, to a degree
07:50:44 <merijn> "Const () :: * -> Constraint", but you always have to apply it fully OR use it as argument to something that will apply it fully
07:50:56 <merijn> mornfall: Oh? Enlighten me, I've tried for weeks
07:51:46 <no-n> is there a better way to write > liftM2 f (g . h) (g . i) x
07:52:02 <merijn> Axman6: FYI
07:52:32 <merijn> Axman6: Your type family for Contains could just return Bool and then you could implement a Not type family instead of a separate DoesntContain
07:52:33 <hexagoxel> i could write "class Any a; instance Any a", and now Any has kind *->Constraint and is effectively empty
07:53:23 <hexagoxel> (rather, the constraint returned is effectively empty)
07:53:36 <merijn> hexagoxel: Well, I think you may have understood my question
07:53:45 <Axman6> merijn: it wouldn't be a constraint then right? how do I use it?
07:53:54 <merijn> hexagoxel: Did you intend "Const :: * -> Constraint" or "Const () :: * -> Constraint"
07:54:09 <merijn> Axman6: Write a "type family If (b :: Bool) :: Constraint"? :)
07:54:24 <Axman6> hmm, that could also work
07:54:39 <Axman6> This is like learning Haskell all over again!
07:54:39 <merijn> hexagoxel: My example does the latter
07:54:53 <merijn> Axman6: There's a reason the paper is called "Fun with Type Functions" ;)
07:55:41 <Iceland_jack> Because "Fun" `isInfixOf` "Function"? :)
07:56:48 <c_wraith|N10> Prefix!
07:56:56 <dbeacham> join #haskell
07:57:10 <Iceland_jack> Because "Fun" `isPrefixOf` "Functions"* ;)
07:57:24 <Iceland_jack> Well one implies the other :)
07:57:48 <c_wraith|N10> I was just saying it's even stronger than in fix.
07:57:50 <Axman6> merijn: I kind of like your trick using ("Error" ~ "Error message"); using that idea would remove the ability to do that right?
07:58:09 <mornfall> merijn: I don't remember :\ it is probably too ugly to be practical anyway
07:58:27 <merijn> Axman6: Yes, but then you can just return "False" for not matching
07:58:51 <Axman6> merijn: and If 'False = ("Error" ~ "If: False") doesn't give you as much info (or does the error message show what returned False...)
07:58:58 <no-n> @pl \x -> f x >>= g
07:58:58 <lambdabot> (g =<<) . f
07:59:16 <Axman6> no-n: also f >=> g
07:59:18 <merijn> True
07:59:21 <no-n> o
07:59:24 <mornfall> merijn: can you promote TypeRep?
07:59:28 <Axman6> :t \f g -> f >=> g
07:59:28 <lambdabot> Monad m => (a -> m b) -> (b -> m c) -> a -> m c
07:59:29 <no-n> thanks :)
07:59:42 <supki> :t \f g h i x -> liftM2 (f `on` g) h i x
07:59:43 <lambdabot> Monad ((->) t) => (b -> b -> r) -> (a2 -> b) -> (t -> a2) -> (t -> a2) -> t -> r
07:59:48 <merijn> mornfall: I'm not sure about the restrictions for promoting
08:00:00 <hexagoxel> merijn: yeah i wanted the latter
08:00:17 <Iceland_jack> (>=>) should get more attention, it's more symmetrical than (>>=) and often much nicer
08:00:27 <hexagoxel> the thing is, i can use Any (without providing a parameter), but not (Const ())
08:00:42 <b80905> how do i write a function that splits a given list into a list of lists of increasing adjacent elements? for instance, [1,4,7,1,2,3,10,9,11] -> [[1,4,7], [1,2,3,10], [9,11]]
08:00:58 <merijn> hexagoxel: No you can't
08:01:09 <hexagoxel> in my usecase at least..
08:01:12 <merijn> hexagoxel: "foo :: Any => a -> a" won't work either
08:03:21 <merijn> hexagoxel: http://lpaste.net/101946
08:03:33 <Iceland_jack> b80905: Look at 'groupBy'
08:03:35 <Iceland_jack> @ty groupBy
08:03:36 <lambdabot> (a -> a -> Bool) -> [a] -> [[a]]
08:03:39 <Axman6> merijn: any comments on my Throws stuff? any obvious issues with it? Obviously the next thing to do would be take the prelude functions and lable them with the exceptions they can throw)
08:03:44 <hexagoxel> merijn: let me prepare a paste, one mom
08:03:50 <Axman6> label*
08:03:53 <no-n> hmm, anybody want to improve this? :P > grandparents s = concatMap (maybeToList . ($s)) $ liftM2 (>=>) [mother,father] [mother,father]
08:04:23 <banister> are there any good/free haskell web hosting services?
08:04:29 <banister> like heroku
08:05:16 <eyem> banister: Digital ocean, though u have to do eveything your self ^^
08:05:35 <Axman6> nearlyfreespeech.net is damn cheap and supports GHC
08:05:36 <banister> eyem ah ok, theres' nothing out there that makes it a little easier though? :)
08:05:51 <merijn> Axman6: You may be interested in the notion of Indexed Monads?
08:05:52 <eyem> banister: not that i've liked
08:06:26 <Axman6> merijn: haven't heard of them, but that sounds closely aligned with what I've tried to do.
08:06:28 <merijn> Axman6: It looks mostly sensible, although doesn't deal with the case of exceptions in pure code yet :)
08:06:34 <b80905> Iceland_jack: why does `groupBy (<) [1,4,7,1,2,3,10,9,11]' return [[1,4,7],[1,2,3,10,9,11]]?
08:06:58 <joelteon> b80905: because 1 < 7
08:07:01 <hexagoxel> merijn: http://lpaste.net/101947
08:07:05 <peteretep> b80905: It breaks the list at each point where it's true
08:07:08 <heatsink> no-n: grandparents = parents >=> parents
08:07:18 <no-n> :o
08:07:21 <no-n> nice
08:07:22 <joelteon> > groupBy (,) [1,4,7,1,2,3,10,9,11]
08:07:24 <lambdabot>  Couldn't match type `(a0, a0)' with `GHC.Types.Bool'
08:07:24 <lambdabot>  Expected type: a0 -> a0 -> GHC.Types.Bool
08:07:24 <lambdabot>    Actual type: a0 -> a0 -> (a0, a0)
08:07:27 <joelteon> > groupBy (<) [1,4,7,1,2,3,10,9,11]
08:07:28 <lambdabot>  [[1,4,7],[1,2,3,10,9,11]]
08:07:29 <bahamas> huh. didn't know that maybeToList actually exists as a function
08:07:29 <joelteon> typo
08:07:44 <bahamas> > maybeToList (Just 4)
08:07:45 <hexagoxel> merijn: i forgot to add the extensions to the paste, should be inferrable
08:07:45 <lambdabot>  [4]
08:07:53 <c_wraith|N10> Because groupBy doesn't work right unless it gets an equivalence class, which < is not
08:08:02 <Axman6> merijn: yeah, I thought I might add a function pureExceptions :: Throws es a -> Thows (Merge es [ArithmeticException, InterruptException, ...]) a
08:08:48 <no-n> bahamas another interesting one is fromMaybe
08:09:10 <heatsink> I didn't know you could use groupBy with asymmetric relations
08:09:19 <no-n> > map (fromMaybe 0) [Nothing,Just 1]
08:09:20 <lambdabot>  [0,1]
08:09:32 <b80905> joelteon: 10 > 9, yet groupBy doesn't break the list there
08:09:48 <bahamas> no-n: where are they defined?
08:09:53 <no-n> Data.Maybe
08:10:03 <bahamas> :t fromMaybe
08:10:04 <lambdabot> a -> Maybe a -> a
08:10:09 <Axman6> groupBy uses the first element in the run for find all others to add to the group
08:10:19 <heatsink> oh
08:10:45 <Axman6> so groupBy (<) [1,2,3,2,3,2,3,2] = [[1,2,3,2,3,2,3,2]] because 1 < 2 and 1 < 3
08:10:50 <c_wraith|N10> b80905: like I said. groupBy only works properly with an equivalence class. That is, but the operation must be symmetric, transitive, and reflexive.
08:10:59 <Axman6> which is really annoying
08:11:01 <merijn> hexagoxel: I dunno how to fix that, unfortunately
08:11:36 <prooftechnique> groupBy (>) is kinda fun, though
08:11:39 <hexagoxel> merijn: well i was only interested in a "better" solution than using Any.
08:12:00 <hexagoxel> but if there is not, i will just use it.. :)
08:12:33 <b80905> c_wraith|N10: so what do i do?
08:13:01 <joelteon> b80905: groupBy only breaks the list once
08:13:19 <prooftechnique> bahamas: You can sort of think of Maybe as a list that either has exactly one element or none
08:13:21 <joelteon> or maybe not.
08:13:23 <joelteon> I don't remember
08:13:26 <c_wraith|N10> b80905: don't use groupBy
08:13:51 <hexagoxel> maybe "Any" should be added to official libs, for as long as there is stuff that can only be expressed using it?
08:13:54 <bahamas> prooftechnique: yup, people have told me that before
08:14:11 <prooftechnique> Oh, well I guess add one more person to that list :D
08:14:28 <bahamas> no-n: so fromMaybe allows you to extract a value from a Maybe value, but have a default in case of Nothing?
08:14:40 <no-n> ya
08:14:54 <bahamas> cool
08:16:13 <bahamas> >=> is interesting. looks like some sort of monad composition
08:17:53 <heatsink> yes, analogous to (.)
08:18:02 <no-n> mmmm
08:18:05 <heatsink> There is also <=< which puts things in the same order as (.)
08:18:17 <ron__> i encounter a strange situation in GHCI, don't know if anyone observed similar: for some modules, when I have it in the search path both by -package-conf, and also by -i, GHCI fail when I try to import the module with 'module is not loaded'
08:18:18 <prooftechnique> Yeah, I was gonna mention that it's backwards :D
08:18:33 <ron__> :module loads it fine however
08:18:51 <bahamas> :t (<=<)
08:18:51 <lambdabot> Monad m => (b -> m c) -> (a -> m b) -> a -> m c
08:18:59 <prooftechnique> :t (.)
08:19:00 <lambdabot> (b -> c) -> (a -> b) -> a -> c
08:19:06 <bahamas> yup
08:19:07 <prooftechnique> See the similarities?
08:19:19 <prooftechnique> :)
08:19:41 <bahamas> I can anticipate questions. I'm like bill murray
08:20:03 <ron__> tracked this to be the `otherwise -> modNotLoadedError m loc` case in http://www.haskell.org/ghc/docs/7.4.1/html/libraries/ghc/src/GHC.html, where "otherwise" ~ modulePackageId = this_pkg (the meaning of which I don't know)
08:20:13 <prooftechnique> bahamas: So you hate Ghostbusters 2?
08:20:14 <flebron> Hi. How can I hide Prelude in my file? (Not in importing some other module, just in my file.)
08:20:28 <heatsink> import Prelude()
08:20:47 <bahamas> prooftechnique: I don't remember seeing it
08:20:54 <prooftechnique> flebron: Also -XNoImplicitPrelude
08:20:57 <Axman6> it's also relates to Kleisli: Kliesli m a b -> Kleisli m b c -> Kleisli m a c
08:21:07 <Axman6> @hoogle Kleisli
08:21:07 <lambdabot> Control.Arrow Kleisli :: (a -> m b) -> Kleisli m a b
08:21:07 <lambdabot> Control.Arrow newtype Kleisli m a b
08:21:07 <lambdabot> package Kleislify
08:21:56 <Axman6> so... (.) from Category is >=> for Kleisli... whooo, that's the most CT(ish) stuff I've ever said
08:22:08 <Axman6> I guess finally reading the typeclassopedia helped
08:22:47 <flebron> Thanks :) Is there a way to say "instance Functor (a,)", maybe using TupleSections? (I know I can say ((,) a))
08:23:09 <merijn> flebron: Nope
08:23:11 <Axman6> I don't think so
08:23:18 <Axman6> it would be nice though
08:23:22 <merijn> flebron: Just like you can't write (->) sections
08:23:23 <flebron> How about (,b)?
08:23:29 <merijn> flebron: Nope
08:23:35 <merijn> flebron: Requires a newtype
08:23:46 <flebron> Ah, because I can't say like, flip (,) b :p
08:23:52 <flebron> Thanks!
08:23:52 <merijn> Yeah
08:23:52 <Axman6> or... a type family?
08:23:59 <merijn> Axman6: Nope
08:24:19 <merijn> Axman6: Because you can't make partially applied type families instances
08:24:23 <Axman6> type family Tuple a b where Tuple a b = (a,b), then you can do (Tuple a) no?
08:24:28 <Axman6> ahhh
08:24:40 <merijn> Axman6: Right, but that's just "instance ((,) a)"
08:25:17 <merijn> Axman6: "type family FlipTuple a b where FlipTuple a b = (b, a)" "instance FlipTuple a" <- partially applied, won't work
08:25:25 <Axman6> and then... another type fmaily! type family Flip (t :: * -> * -> *) a b where Flip t a b = t b a
08:25:46 <indigo> Yikes, I wonder what happened to Happstack's website.
08:25:50 <angerman> So I have data A = A and data B = B [A], and I want to have also data D = D [A | B], I tried to make data C = A | B and D = D [C]
08:25:51 <merijn> Axman6: Right, but you can't partially apply the Flip type function :)
08:25:54 <angerman> but that does not work :(
08:26:19 <Axman6> angerman: yeah that doesn't work
08:26:40 <angerman> Axman6: how would I go about making it work? :-)
08:26:59 <angerman> I somehow need a data that can be A or B
08:27:07 <merijn> angerman: Use Either?
08:27:07 <Axman6> well data D = D [Either A B] is anagous to what you seem to be after
08:27:18 <Axman6> l*
08:27:40 <merijn> @quote Neither
08:27:40 <lambdabot> Baughn says: Those who would give up essential laziness for a little ephemeral performance, deserve neither laziness nor performance.
08:27:44 <merijn> aww
08:27:49 <merijn> @quote data.Neither
08:27:49 <lambdabot> Berengal says: data Neither a b = Left | Right
08:27:51 <merijn> <3
08:28:10 <angerman> huh?
08:28:14 <Axman6> what's the product type version of that
08:28:15 <angerman> Axman6: thanks.
08:28:19 <Axman6> angerman: it's a joke
08:34:41 <Baughn> angerman: Either sounds like what you're wanting.
08:34:47 <prooftechnique> indigo: Yikes
08:34:51 <makalu> I have a monad "InputT (StateT [String] IO)" (InputT is from Haskeline). I import System.Console.Haskeline.MonadException and I still get "No instance for (MonadException (StateT [String] IO))" why is that?
08:34:54 <prooftechnique> I hope that means Happstack 8 is coming :D
08:35:39 <indigo> prooftechnique: Maybe. I'm still unfamiliar with the differences between all of the major web frameworks in Haskell :P
08:35:59 <indigo> (other than Yesod is more complicated than Snap and Happstack)
08:36:55 <Axman6> makalu: have you searched for MonadException?
08:37:01 <prooftechnique> Happstack could probably be characterized as doing the least magic
08:37:14 <prooftechnique> Or giving you the option to implement magic at your discretion
08:37:41 * hackagebot HList 0.3.4.1 - Heterogeneous lists  http://hackage.haskell.org/package/HList-0.3.4.1 (AdamVogt)
08:38:06 <makalu> Axman6: why? It's right there in that module.
08:38:25 <Axman6> makalu: do you have a link for me to see the docs?
08:38:32 <indigo> prooftechnique: I see.
08:38:39 <Axman6> this makes me chuckle: handle (\NonTermination -> exitWith (ExitFailure 1))
08:38:43 <makalu> http://hackage.haskell.org/package/haskeline-0.7.1.2/docs/System-Console-Haskeline-MonadException.html
08:38:52 <fizbin> makalu: The issue is that System.Console.Haskeline.MonadException doesn't have an instance for the lazy StateT, just the strict one.
08:39:04 <fizbin> I suspect that you are using the lazy StateT.
08:39:26 <makalu> fizbin: you are correct! Thank you
08:39:33 <makalu> how was I supposed to know that?
08:39:37 <fizbin> Try changing your import for Control.Monad.State to Control.Monad.State.Strict
08:39:51 <prooftechnique> stepkut`: What's up with the happstack site?
08:40:15 <fizbin> That's a good question. When modules define symbols with identical names but different meanings, I'm not sure what to do.
08:40:28 <fizbin> I knew that from http://stackoverflow.com/questions/16944016/monadexception-instance-is-not-deduced
08:43:50 <r0ly> If anyone is interested, I just made an extension for Chrome
08:43:56 <r0ly> to search directly on hoogle
08:44:01 <r0ly> from the searchbar
08:44:04 <r0ly> https://chrome.google.com/webstore/detail/haskell-inspector/fkopdhccgfgifcpkgndkohcpllhelhph
08:45:16 <vlatkoB> Is there a way to convert JuicyPixels grayscale "Image Pixel8" to CV's "Image GrayScale D8"? Pixel8 and D8 are Word8.
08:45:49 <vlatkoB> JuicyPixels is Vector Word8
08:46:59 <Axman6> vlatkoB: if you can find a way to tirn a Vector Word8 into a CV Image then you should be good to go
08:49:30 <vlatkoB> Axman8: I meant, is there a way for CV to use the ptr of vector? Those are just Word8 bytes stored in line, aren't they?
08:49:36 <vlatkoB> Ups, 6
08:50:05 <Axman6> can you link me to the CV docs?
08:50:41 <vlatkoB> Axman6: http://hackage.haskell.org/package/CV-0.3.7/docs/CV-Image.html
08:51:53 <prooftechnique> Anyone know how to limit hoogle results in Emacs? Changing hoogle command to, e.g., hoogle -n 10 doesn't seem to work
08:52:19 <vlatkoB> Axman6: JucyPixel data is in Storable Vector     imageData :: Vector (PixelBaseComponent a) which is Pixel8 i.e. Word8
08:52:51 <thebnq> prooftechnique: maybe --count=10 ?
08:53:07 <prooftechnique> I'll give that a shot. Thanks
08:53:29 <thebnq> hm -n worked for me =s
08:53:36 <prooftechnique> Hmm
08:54:14 <Axman6> vlatkoB: I'm sure there is a way to do it... but it's very late here and I can;t think straight enough to figure it out :P the stuff in Low Level Access operations is what you need to look at
08:54:55 <vlatkoB> Axman6, Thanks, I'll take a look at it. Good night. :-)
08:56:32 <remdezx> Hello! How can I modify last element of the list using lens?
08:56:59 <supki> > [1..10] & _last %~ negate
08:57:01 <lambdabot>  [1,2,3,4,5,6,7,8,9,-10]
08:57:16 <remdezx> supki: thanks a lot!
08:58:04 <Axman6> > [1..10] & _last . _init %~ negate
08:58:05 <lambdabot>  No instance for (Control.Lens.Cons.Snoc
08:58:05 <lambdabot>                     (->) Control.Lens.Internal.Setter.Mutator t0 t0 a0 a0)
08:58:05 <lambdabot>    arising from a use of `e_1110'
08:58:05 <lambdabot>  The type variables `t0', `a0' are ambiguous
08:58:05 <lambdabot>  Possible fix: add a type signature that fixes these type variable(s)
08:58:17 <Axman6> ... yup
08:58:40 <Axman6> > [1..10] & _init .  _last %~ negate
08:58:41 <lambdabot>  [1,2,3,4,5,6,7,8,-9,10]
08:58:55 <Axman6> oh right, lens' compose backwards
08:59:04 <supki> > [1..10] & upon (last.init) %~ negate
08:59:05 <lambdabot>  [1,2,3,4,5,6,7,8,-9,10]
09:00:34 <Axman6> :t upon
09:00:35 <lambdabot> (Data s, Data a, Applicative f, Indexable [Int] p) => (s -> a) -> p a (f a) -> s -> f s
09:12:01 <angerman> :t foldl
09:12:02 <lambdabot> (a -> b -> a) -> a -> [b] -> a
09:12:16 <angerman> hmm... where is (a -> b -> a) -> [a] -> a?
09:14:11 <angerman> t: foldl1
09:14:16 <angerman> :t foldl1
09:14:17 <lambdabot> (a -> a -> a) -> [a] -> a
09:14:20 <angerman> ahh.
09:18:49 <south> Are there any non-proof-assistant dependently typed functional languages out there?
09:18:59 <klrr_> idris?
09:19:26 <klrr_> (i dont actually know, but ive heard it tries to be good for general programming)
09:19:31 <south> klrr_: Ah, I didn't realize it was general purpose
09:19:54 <south> klrr_: Just want to get my feet wet but not super interested in assisted proofs at this time
09:20:10 <Redz> i still dont understand the question. :p
09:21:14 * no-n has been thinking about the different ways with which to combine sheep for too long :P
09:22:23 * Axman6 interprets the question as "I want a dependantly typed language whose implementation isn't as helpful a proof assisstant"
09:22:29 <Kron> at what point does a Map become faster than a linear assoclist?
09:22:51 <Kron> I assume for tiny sets the assoclist is faster to traverse than computing the hash function or trie index
09:23:03 <Axman6> Map doesn't use hashes
09:23:06 <south> Axman6: Haha, I just want to 'get' what Dependent Types are about, but not super motivated to learn a proof-assistant
09:23:09 <Axman6> Map uses Ord
09:23:21 <south> Axman6: Not that learning one would be a bad thing :)
09:23:24 <Axman6> south: yeah I understand. I'm somewhat the sa,e
09:23:25 <Axman6> m*
09:23:41 <Kron> right, it's a trie, I remember now
09:23:52 <thebnq> south: dependent types are about proofs, unavoidable :b
09:24:08 <Kron> hmmm, I guess that would automatically make the Map faster for practically every set larger than 1?
09:24:22 <Axman6> well no
09:24:29 <Kron> you still need to do equality comparison for assoclists, and a compare operation is used per trie depth
09:24:30 <angerman> so I have some data types. And I want to write a function which applies to any of them. I'm getting type issues. Again.
09:24:44 <angerman> myFun (A x) = x
09:24:49 <Axman6> GHC does a lot of work to make lists fast. but it will eventually be faster to use map
09:24:59 <Kron> Axman6: okay
09:25:12 <Axman6> Kron: Criterion would be able to tell you =)
09:25:13 <prooftechnique> angerman: Can you paste your code?
09:25:13 <angerman> myFun (B x) = foldl1 (+) $ map myFun $ x
09:25:15 <prooftechnique> @paste
09:25:15 <lambdabot> Haskell pastebin: http://lpaste.net/
09:25:18 <Kron> angerman, that sounds reasonable, assuming A is a type constructor
09:25:53 <Kron> Axman6, what's Criterion?
09:26:07 <angerman> Kron: I think the basic issue I have is that I have two data items, that do not have the same type.
09:26:22 <Axman6> Brion O'Sullivan's excellent benchmarking library. I've never seen anything like it in any other language
09:26:28 <Axman6> @hackage criterion
09:26:28 <lambdabot> http://hackage.haskell.org/package/criterion
09:26:32 <Kron> what are the data items?
09:26:39 <Kron> you could make them the same type
09:26:43 <Kron> data Thingy = A | B
09:26:52 <Kron> this makes A and B constructors of the same type; Thingy
09:27:04 <Kron> or well
09:27:06 <Kron> in your case
09:27:07 <angerman> prooftechnique, Kron: http://lpaste.net/8292627189015248896
09:27:14 <Kron> data Thingy x = A x | B x
09:27:18 <Kron> since your type has a type variable
09:27:30 <prooftechnique> Ah
09:27:47 * hackagebot creatur 5.2.10 - Framework for artificial life experiments.  http://hackage.haskell.org/package/creatur-5.2.10 (AmyDeBuitleir)
09:27:59 <Kron> hmmm
09:28:23 <angerman> I thought I could dispatch on type.
09:28:38 <Kron> sadly, no
09:28:51 <Kron> I'll try to give an intuitive explanation: 'types' do not exist at runtime
09:29:01 <prooftechnique> You could phrase it as data Group = Element String | Group [Element], though that would require reworking the other types
09:29:05 <Kron> types are just compiler-security labels of sorts to keep your code sane
09:29:15 <Kron> for actual metadata on your data, you want to use constructors
09:29:31 <triliyn> angerman: you could make myFun a typeclass function
09:29:36 <Kron> so data TheTypeYouWantToDealWith = Constructor1 blah blah | Constructor2 blah blah...
09:29:48 <Kron> I'm not quite sure he wants to make it a typeclass in this case?
09:30:04 <Kron> angerman: a typeclass is basically a java interface, or C# abstract class
09:30:15 <prooftechnique> Actually, I guess you couldn't say it quite that way. You'd want data Element = ...
09:30:15 <Kron> a kind of contract of behaviour that several types can be expected to obey
09:30:30 <angerman> I'm basically trying to encode a message format.
09:30:42 <angerman> Kron, well I expect them all to obey to assemble.
09:31:17 <Kron> here's a useful mental model I use; do you think it's sane to put them all in a big list or collection?
09:31:25 <Kron> [Group this, Element that, etc.]
09:31:33 <Kron> if yes, then make them all the same type
09:31:42 <Kron> if that's crazy and they shouldn't be mixed, typeclass
09:31:53 <Kron> with typeclasses you can define functions that do in fact dispatch on type
09:33:27 <angerman> hmm. I'm tending towards typeclasses. Though maybe I'm just not experienced with haskell.
09:34:06 <prooftechnique> angerman: You may want to look into Parsec
09:34:33 <angerman> prooftechnique, for what specifically?
09:34:35 <prooftechnique> You'll still have to come up with a type model, but it'll be easier to extract things if the format is regular
09:36:55 <Kron> as a sanity based rule of thumb, you want to try to stick to types and only move into typeclasses with a lot of deliberation
09:37:14 <Kron> also, if you are just learning haskell and using these groups/elements as learning exercises, I recommend you don't whip out an advanced library
09:37:27 <Kron> Parsec is an advanced parser, built specifically to do the thing you're doing
09:37:43 <Kron> it's there for serious business parsing when you're not trying to feel your way around haskell and you just want stuff done
09:37:44 <tac> Is there a filter-like function in Data.Text?
09:37:53 <tac> @hoogle Text -> (Char -> Bool) -> Text
09:37:53 <lambdabot> Data.Text dropAround :: (Char -> Bool) -> Text -> Text
09:37:53 <lambdabot> Data.Text.Lazy dropAround :: (Char -> Bool) -> Text -> Text
09:37:53 <lambdabot> Data.Text dropWhile :: (Char -> Bool) -> Text -> Text
09:38:03 <tac> @hoogle (Char -> Bool) -> Text -> Text
09:38:03 <lambdabot> Data.Text dropAround :: (Char -> Bool) -> Text -> Text
09:38:03 <lambdabot> Data.Text.Lazy dropAround :: (Char -> Bool) -> Text -> Text
09:38:03 <lambdabot> Data.Text dropWhile :: (Char -> Bool) -> Text -> Text
09:38:22 <bartavelle> (not sure how interesting this is to the general crowd, but my church-encoded either is a bit faster than plein Either for a stupid monadic computation, but only with llvm)
09:38:31 <bartavelle> s/plein/plain/
09:38:39 <prooftechnique> Kron: I dunno, most of the basic combinators are pretty intuitive, but I see your point
09:39:00 <Kron> prooftechnique: I realize, but I don't even recommend poking at Data.Foldable and stuff when you're new
09:39:08 <Kron> it's much better to just write it all yourself
09:39:16 <Kron> I myself didn't get basic folds until I wrote them myself
09:39:37 <angerman> Kron, ohh, I don't try to parse anything.
09:40:26 <Kron> angerman: you're constructing these, in a way: http://en.wikipedia.org/wiki/Parse_tree
09:40:40 <Kron> the systems you're constructing are quite analogous
09:41:14 <Kron> even if you aren't literally turning it into program code or a webpage or whatever, parsec would still be useful for just fiddling with parse trees
09:41:31 <Kron> I still recommend you don't bother with parsec and just keep doing your own thing
09:43:57 <angerman> Kron: thanks.
09:45:35 <joseph07> angerman: You might want consider creating a typeclass in this case
09:46:16 <joseph07> angerman: But bear in mind that if a typeclass is defined in a module, and all of its instances are also in that module it's just a naming convenience
09:46:46 <Kron> it's quite a nice naming convenience
09:47:06 <joseph07> angerman: I.e you could write assembleElement, assembleGroup, etc. Or you could say that all those types are assemblable and use one function name assemble
09:47:18 <joseph07> *named
09:48:18 <angerman> That assmeble thing a like marshalling a dataobject. And my data elements try to model that object with some constraints.
09:48:24 <angerman> Am I doing it wrong?
09:50:54 <joseph07> angerman: Well I don't know 100% what your end goal is, but I don't think you're doing anything wrong per se. Keep on going and see where you end up
09:51:19 <angerman> ok.
09:52:00 <angerman> So about that Either. if I have [Either A B], what do I get if I map over it?
09:56:23 <davidthomas> angerman: Depends what you map over it.
09:56:48 <davidthomas> angerman: Whatever function you pass to map has to accept an Either A B
09:56:53 <angerman> I need a type that is either a string or a number.
09:57:10 <Lethalman> angerman, Num a => Either String a
09:57:11 <Lethalman> :)
09:57:28 <levi> Any kind of number, or a specific kind of number (integer, floating point, etc?)
09:58:03 <angerman> I assume integer would be sufficient.
09:58:22 <davidthomas> If there's no additional context, and especially while prototyping, Either String Integer is exactly that
09:59:02 <davidthomas> If there's additional semantic meaning to why it's a String or an Integer, I'd weakly recommend eventually implementing your own Either that names them something clearer than Left and Right
09:59:28 <davidthomas> (which will also let you add other representations, &c)
09:59:31 <levi> What Lethalman said lets you use any of the numeric type classes, but it's probably easier if you start with Either String Integer.
09:59:46 <davidthomas> But when exploring, Either is more than fine
10:00:45 <davidthomas> Either String Integer is a type like any other
10:00:52 <davidthomas> so it can be the input to a function
10:01:18 <davidthomas> If you call (map foo) on a [Either String Integer)
10:01:31 <davidthomas> then foo needs to expect Either String Integer as its argument
10:01:44 <davidthomas> You can either write such a function by hand
10:02:08 <davidthomas> or you can use either to build one out of a function that takes a String and a function that takes an Integer
10:02:17 <angerman> alright.
10:02:21 <angerman> I'll have to explore further
10:03:26 <davidthomas> For instance, (either read (+1))
10:03:58 <davidthomas> would turn a [Either String Integer] into a [Integer]
10:04:05 <davidthomas> if the strings could be read as integers
10:04:55 <prooftechnique> > map (either read (+1)) [Left "5", Right 5]
10:04:56 <lambdabot>  [5,6]
10:05:53 <gdoteof> is it possible to inspect/print a conduit without consuming it?  i know that is a weird question.  but i am trying to debug some request within Yesod; and by inspecting/printing the request i am breaking things
10:07:03 <gdoteof> http://lpaste.net/101951   so, if i send a message using the little form at /test it responds with my childish response
10:07:37 <gdoteof> but if i uncomment line #52, it fails.. presumably because the request has already been consumed before runInputPost has a chance to read it
10:09:48 <test12390> What are some good tutorials for Haskell?
10:10:50 <thebnq> learn you a haskell
10:12:52 * hackagebot cabal-cargs 0.3.1 - A command line program for extracting compiler arguments from a cabal file.  http://hackage.haskell.org/package/cabal-cargs-0.3.1 (DanielTrstenjak)
10:22:45 <athan> Can someone help me understand Constraint Kinds? What's their placement in type classes? What used to be the alternative? Are there other variations of a kind?
10:26:04 <merijn> athan: ConstraintKinds let you write your own constraints
10:26:37 <merijn> athan: They are (mostly) orthogonal to type clases, there was no alternative
10:26:51 <athan> marijn: Isn't a typeclass's existence, and it's use seen as a "constraint", but from an ambigious, logical design point of view?
10:27:35 <athan> merijn: Thank you! I still need to get GADT's in my code
10:32:54 * hackagebot snap-core 0.9.6.2 - Snap: A Haskell Web Framework (core interfaces and types)  http://hackage.haskell.org/package/snap-core-0.9.6.2 (GregoryCollins)
10:37:55 * hackagebot snap-server 0.9.4.1 - A fast, iteratee-based, epoll-enabled web server for the Snap Framework  http://hackage.haskell.org/package/snap-server-0.9.4.1 (GregoryCollins)
10:38:05 <Kron> :i hPutStrLn
10:38:17 <Kron> where IS hputstrln defined?
10:38:34 <Axman6> @hoogle hPutStrLn
10:38:34 <lambdabot> System.IO hPutStrLn :: Handle -> String -> IO ()
10:38:34 <lambdabot> Data.ByteString hPutStrLn :: Handle -> ByteString -> IO ()
10:38:34 <lambdabot> Data.ByteString.Char8 hPutStrLn :: Handle -> ByteString -> IO ()
10:54:01 <south_> What does "type equation" mean here? http://www.haskell.org/haskellwiki/Maybe
10:55:31 <quicksilver> it means that two types are equal
10:55:38 <quicksilver> as in there is a bijection between them
10:55:57 <asQuirreL> south_: I'm guessing here, but I think the (+) in that context reads more like "or"
10:56:32 <south_> Oh of course, 1 corresponds to Nothing, the unit, and Just a corresponds to X
10:57:02 <south_> Thanks quicksilver  and asQuirreL
11:03:33 <gdoteof> it seems like ineed to inject a `leftover` somewhere into my stream to be able to view the conduit and still use it within the ysod handler
11:16:02 <yogert1> I'm having a bit of trouble with the Hxt library. I'm not sure I quite understand it conceptually, here is an example demonstrating the particular problem i have at the moment
11:16:03 <yogert1> http://lpaste.net/16610700117934080
11:16:34 <yogert1> I want to parse several different datatypes from sibling elements
11:17:05 <yogert1> However, every approach I've tried thus far seems to operate on all sibling nodes
11:17:16 <yogert1> which of course leads to problems
11:17:37 <yogert1> Should i not think of it as consuming nodes in sequence?
11:21:43 <yogert1> Something like this won't work...
11:21:44 <yogert1> http://lpaste.net/16610700117934080
11:27:46 <Javran> hi, I want to get started about GADTs, could you point me to some good materials?
11:28:09 <yogert1> Should I just extract the text, and then derive meaning?
11:28:16 <yogert1> So not like Parsec?
11:37:40 <athan> for an operator to be "invertable", does that mean that it's an isomorphism, or that there's some combinator `invert` that can create it's inverse (ie: f^-1(x) )
11:37:41 <athan> ?
11:39:56 <yzb3> hi, I have a question: when reading a UTF-8 encoded file containing an o-umlaut char (U+00F6) in Linux I would expect the string to print "\195\182", but I get "\246", as if I was reading Latin1; is the default read mode in Haskell not UTF-8 or is it not the default for Strings?
11:40:09 <johnw> athan: usually the prior
11:40:34 <johnw> if f . g = id, you don't necessarily need a third function which is able to return you g given f
11:40:48 <johnw> (f . g = id, *and* g . f = id)
11:40:52 <athan> johnw: Ah, that makes a lot more sense. I'm trying to learn exactly what a "group" is
11:41:26 <johnw> in a group, the inversion is more applicable to values
11:41:26 <athan> ahhhh okay
11:41:28 <athan> great
11:41:38 <johnw> it's also applicable to morphisms, if you view the group as a single object category
11:41:38 <athan> see that's what I'm wondering
11:41:54 <athan> does the pivot happen through a combinator?
11:41:58 <athan> er.. could?
11:42:02 <johnw> not that I'm aware of
11:42:15 <athan> hmm
11:42:17 <athan> interesting
11:42:28 <johnw> in a group, every member A of the set X has an inverse, A^-1
11:42:36 <athan> that would allow for a shortcut of computation, right?
11:42:44 <athan> if you have two inverses, they can get cut out
11:42:53 <athan> ahhh okay
11:42:54 <johnw> yes
11:42:58 <athan> great!!
11:43:06 <athan> thank you!!!
11:49:03 <Javran> is there a "null" function for Data.DList?
11:50:16 <mr-> Javran: empty?
11:50:33 <mr-> ah, sorry.. misunderstood
11:50:51 <Rufflewind_> Javran: i don't think you can do that without applying it to a list and checking if it's null
11:51:13 <Javran> Rufflewind_: is this process lazy?
11:51:17 <Rufflewind_> Javran: it's equivalent to asking is `f == id`
11:51:27 <Rufflewind_> s/is/if/
11:51:32 <Javran> I see
11:54:46 <awestroke> is there any reason to use a web framework in haskell for a small-scale app with static content + haskell API?
11:55:27 <statusfailed> awestroke: what kind of API?
11:55:59 <yzb3> I would like to create a padding function that would treat multi-byte UTF-8 chars as single characters - can someone suggest how I shuld do it?
11:56:13 <awestroke> statusfailed: simple API with index-only requests
11:56:29 <statusfailed> awestroke: API as in REST API?
11:57:03 <awestroke> statusfailed: sure, but saying RESTful feels weird if it only has one method ;)
11:57:11 <statusfailed> heh
11:57:16 <awestroke> I checked out scotty but the huge list of dependencies scare me
11:57:29 <awestroke> in the cabal file
11:57:30 <statusfailed> I typically like going nginx + reverse proxy + haskell api for that sort of thing
11:57:30 <yzb3> would just reading files as ByteString.Char8 work?
11:57:33 <statusfailed> like a SPA right?
11:57:49 <awestroke> SPA?
11:57:54 <statusfailed> single-page-application
11:58:05 <awestroke> I think so, yes
11:58:22 <ReinH> athan: you might be interested to learn about sections and retractions
11:58:26 <statusfailed> So I guess it really depends entirely on what a framework gets you for the API
11:58:29 <yzb3> I think then I would be able to interpret the input as proper UTF-8
11:58:48 <athan> ReinH: It sounds interesting!! Can you tell me more?
11:59:03 <ReinH> in the case of f . g = id, g is a section of f and f is a retraction of g
11:59:04 <awestroke> statusfailed: it would be great with automatic asset compilation during development, and asset cache tagging in production is great
11:59:18 <awestroke> but that would also be really fun to do myself
11:59:22 <statusfailed> awestroke: stuff like LESS?
11:59:27 <awestroke> statusfailed: yeah
11:59:41 <statusfailed> Ah ok, I've never looked into that so I'm not sure what kind of support exists
12:01:25 <mm_freak> hi there
12:01:36 <mm_freak> is there a name for ComonadStore + poke?
12:01:48 <edwardk> ?
12:01:59 <mm_freak> ComonadStore itself only supports peek and seek, but i need poke as well
12:02:17 <athan> ReinH: See that's what I was wondering
12:02:36 <edwardk> poke just changes the answer to peek for a particular answer, right?
12:02:45 <edwardk> :t Control.Comonad.Store.peek
12:02:46 <lambdabot> Control.Comonad.Store.Class.ComonadStore s w => s -> w a -> a
12:02:46 <athan> ReinH: if the inversion of the composition is still `id`, then they invert, correct?
12:02:49 <athan> er
12:02:59 <athan> the commution of the composition operator
12:03:23 <mm_freak> edwardk: yeah:  poke :: (a -> a) -> w a -> w a
12:03:24 <edwardk> so you want something like poke :: Eq s => s -> a -> w a -> a
12:03:38 <mm_freak> or that
12:03:42 <ReinH> athan: given f : X -> Y, g : Y -> X is a section iff f . g is the identity arrow for X
12:03:53 <edwardk> that is implementable via the existing operations
12:04:29 <edwardk> poke s a w | pos w == s = a        | otherwise = peek s w
12:04:32 <mm_freak> edwardk: unfortunately my case requires that i make no assumptions about s
12:04:41 <athan> ReinH: Ah!
12:04:55 <edwardk> then no, there isn't a general name for this construction
12:04:57 <ReinH> athan: section basically means right-inverse
12:05:13 <athan> ReinH: and if you have both right and left, you have an isomorphism?
12:05:34 <mm_freak> edwardk: data T a b = forall w. (ComonadStore b w) => C (w a)
12:05:54 <mm_freak> you could think of it as a container-agnostic probability monad
12:06:15 <mm_freak> and i'm having a hard time making this an actual monad, but ComonadStore seems to work
12:06:23 <ReinH> athan: do you? :)
12:06:49 <edwardk> you can of course always just bolt your poke inside there
12:06:55 <szuja> hi, i've problem, maybe someone know whats going on https://github.com/k0001/network-simple/issues/7
12:06:58 <mm_freak> yeah, indeed
12:06:58 <athan> ReinH: lol
12:07:00 <ReinH> athan: hint: if f is both a left- and right-inverse then it is both injective and surjective
12:07:12 <edwardk> data T a b = forall w. ComonadStore b w => C (w a) (s -> a -> w a -> a)
12:07:14 <athan> ReinH: O.o
12:07:29 <fizbin> At some point I really should try to figure out what it is about HXT and the way I'm using it that makes even the simplest error so completely undebuggable.
12:07:38 <edwardk> then use the poke above as a default for when s is knowable and Eq
12:08:03 <mm_freak> i'll try that
12:08:07 <ReinH> athan: sorry, that's true but not quite helpful
12:08:38 <mm_freak> fizbin: hxt has a number of conceptual problems
12:08:56 <ReinH> athan: sorry, let me try again :)
12:09:09 <fizbin> And yet, there isn't any better XML processing framework.
12:09:21 <mm_freak> fizbin: xml-conduit works very well for me
12:09:29 <ReinH> athan: a function f with a right-inverse is surjective. A funciton g with a left-inverse is injective.
12:09:44 <fizbin> And I kind of like the type hierarchy for HXT's pickling/unpickling combinators.
12:10:04 <ReinH> athan: so CSB implies that you have a bijection
12:10:05 <athan> ahhh okay
12:10:20 <athan> and when they're used, they become the section and retraction, ReinH
12:10:27 <mm_freak> fizbin: not sure what you mean…  the types are precisely what's wrong with hxt =)
12:10:44 <ReinH> athan: But I think you need the axiom of choice, at least to construct the bijection?
12:10:47 <athan> ReinH: CSB?
12:10:49 <fizbin> The pickling library isn't full of arrows.
12:10:56 <ReinH> athan: https://en.wikipedia.org/wiki/Cantor%E2%80%93Bernstein%E2%80%93Schroeder_theorem
12:11:02 <ReinH> Cale: halp
12:11:38 <athan> I think you're right
12:11:50 <athan> im not sure though
12:11:53 <ReinH> me neither :)
12:11:55 <mm_freak> fizbin: anyway, xml-conduit has an elegant combinator library for taking XML apart
12:11:56 <tsou> ReinH: no AC needed, it's on the link you sent ;)
12:11:56 <athan> I haven't even gone to college man lol
12:12:02 <jle`> no excuse!
12:12:08 <athan> i agree!
12:12:18 <athan> it's just a more submersive environment
12:12:20 <ReinH> tsou: CSB says that such a function exists, it doesn't say that you can construct it, right?
12:12:24 <athan> so I would use it more often
12:12:30 <athan> and integrate it
12:12:42 <tsou> ReinH: ah, sorry, i missed the 'construct', yes right ;)
12:12:49 <ReinH> tsou: :)
12:13:12 <kadoban> I feel like I should know this, but can't figure it out... I have a 'Maybe (a -> a)' and a 'Maybe a'.  How do I combine them into a 'Maybe a' ?
12:13:25 <mm_freak> kadoban: (<*>)
12:13:31 <ReinH> or ap
12:13:42 <kadoban> Ahhh, thanks.  I'll look at those
12:14:06 <ReinH> :t (<*>)
12:14:07 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
12:14:12 <mm_freak> kadoban: conceptually they are identical…  but since Maybe is an Applicative, you should probably just use (<*>) right away =)
12:14:40 <ReinH> mm_freak: I just recommend ap to mildly troll people. kadoban you should use <*>
12:14:50 <kadoban> Haha, okay :)
12:14:58 <jle`> i use ap sometimes for srs.
12:15:00 <ReinH> kadoban: I do wish pointfree used <*>
12:15:05 <jle`> because i don't want to add an applicative constraint
12:15:18 <jle`> but you're on Maybe, so..
12:15:22 <mm_freak> jle`: i end up using liftM* most of the time
12:15:28 <Javran> @pl \f (x,y) -> [x,y]
12:15:28 <lambdabot> const (uncurry ((. return) . (:)))
12:15:37 <ReinH> Javran: oh god not this again
12:15:47 <kadoban> It's hard getting used to these different functions that have almost the same type, but one is used and one isn't
12:15:59 <Javran> ReinH: ?
12:16:03 <jle`> i do something like return f `ap` x `ap` y `ap` z
12:16:11 <mm_freak> kadoban: that will become easier soon, when the AMP is fully implemented =)
12:16:17 <ReinH> Javran: this is an exercise right? Someone else was asking about it.
12:16:26 <ReinH> jle`: o_O
12:16:30 <kadoban> AMP?
12:16:31 <mm_freak> kadoban: Applicative will become a superclass of Monad in the near-to-mid future
12:16:31 <jle`> writing liftM4+ always makes me feel a little silly
12:16:38 <ReinH> mm_freak: finally :)
12:16:40 <mm_freak> kadoban: Applicative-Monad-Proposal
12:16:42 <tsou> ReinH: some interesting stuff in http://mathoverflow.net/questions/123482/is-there-a-constructive-proof-of-cantorbernsteinschroeder-theorem
12:16:48 <ReinH> tsou: :)
12:16:49 <kadoban> Ahh, that sounds interesting
12:16:59 <tsou> ReinH: (heh, you wet my appetite so thought you might enjoy that read like i just did)
12:17:02 <mm_freak> so no more (Applicative m, Monad m) =)
12:17:07 <jle`> woo hoo
12:17:09 <ReinH> tsou: indeed. I like the proof of non-proof.
12:17:27 <tsou> ReinH: heh, i thought this was #math, btw :P
12:17:34 <ReinH> tsou: close enough ;)
12:17:51 <Javran> ReinH: I'm just curious about what the point-free version would look like. won't use that in real code for obvious reason :)
12:18:29 <prooftechnique> I'll bet there's a lens combinator that does that
12:18:30 <ReinH> Javran: yeah there isn't a good pointfree version, which is why it's weird that the exercise was to find one
12:19:02 <ReinH> Javran: did you intend to put the f there?
12:19:21 <Javran> ReinH: I'm not doing exercise, I'm playing around with quicksort
12:19:30 <Javran> ReinH: http://codepad.org/4Ik62BnF
12:19:42 <mm_freak> i bet ∀ task → Σ LensCombinator (λ c → c does task)
12:19:56 <ReinH> mm_freak: :)
12:20:21 <jle`> > let f = uncurry (:) . fmap return in f (1,2)
12:20:22 <lambdabot>  [1,2]
12:20:23 <Javran> ReinH: that "lSorted ++ [x] ++ rSorted" might have a more compact form I guess, using Data.List.intercalate
12:20:23 <ReinH> mm_freak: the median length of which will be 4 characters
12:20:30 <jle`> Javran: ^^
12:20:34 <mm_freak> lol
12:20:54 <jle`> :t uncurry (:) . fmap return
12:20:55 <lambdabot> (a, a) -> [a]
12:21:16 <mm_freak> :t liftA2 (<|>) (pure . fst) (pure . snd)
12:21:17 <lambdabot> Alternative f => (b, b) -> f b
12:21:28 <Javran> cool
12:21:30 <jle`> :)
12:22:04 <mm_freak> that's actually sufficiently readable that i'd be tempted to use it…  but i'd probably use the pointed version anyway =)
12:22:13 <mm_freak> :t \(x, y) -> pure x <|> pure y
12:22:14 <lambdabot> Alternative f => (a, a) -> f a
12:22:24 <Javran> :t uncurry (:) . fmap (:[])
12:22:25 <lambdabot> (a, a) -> [a]
12:22:39 <jle`> return is (:[]) tho so
12:22:50 <jle`> but robot monkey is nice
12:22:58 <Javran> jle`: yeah, monkey looks funny
12:23:02 <mm_freak> btw, this is a lot easier if you use proper types in the first place
12:23:06 <mm_freak> V2 a -> [a]
12:23:18 <jle`> who uses types
12:23:22 <mm_freak> then it's just F.toList, where F = Data.Foldable =)
12:23:24 <jle`> what is this, java
12:23:41 <ReinH> jle`: mixing (:) with return seems like switching levels to me
12:23:52 <ReinH> but I'm not sure (:[]) is better than return
12:24:33 <jle`> i did feel weird when i first started using return for a singleton list
12:24:38 <jle`> pure sometimes feels less weird
12:24:51 <mm_freak> jle`: i read both "pure" and "return" as "singleton"
12:25:07 <mm_freak> or its synonym "unit" =)
12:25:37 <jle`> that's why i say we should just use return = η
12:25:58 <jle`> > let return = η in (uncurry (:) . fmap η) (1,2)
12:25:59 <lambdabot>  Not in scope: `η'Not in scope: `η'
12:26:03 <jle`> oops
12:26:10 <jle`> > let η = return in (uncurry (:) . fmap η) (1,2)
12:26:11 <lambdabot>  [1,2]
12:26:15 <mm_freak> class Singleton f where singleton :: a -> f a;  class ConcatMap f where concatMap :: (a -> f b) -> f a -> f b
12:26:29 <mm_freak> uh
12:26:36 <mm_freak> yeah
12:26:46 <mm_freak> class (Singleton f, ConcatMap f) => Monad f
12:27:22 <ReinH> Singleton a.k.a. Pointed?
12:27:27 <ReinH> ConcatMap a.k.a. Bind?
12:27:31 <mm_freak> yeah
12:28:15 <mm_freak> i'd really like if (=<<) had a prefix name like joinMap
12:28:33 <mm_freak> then fmap, (<*>), (=<<) and (<<=) would all line up nicely
12:28:58 <jle`> <<=
12:29:05 <jle`> is that the evergreen tree?
12:29:11 <mm_freak> jle`: it's 'extend'
12:29:38 <absence> kleisli spruce :)
12:29:52 <mm_freak> given f a, functors map a -> b, applicatives map f (a -> b), monads map a -> f b and comonads map f a -> b
12:30:14 <ReinH> mm_freak: add in algebra and coalgebra?
12:30:41 <mm_freak> ReinH: aka unfold and fold?
12:31:06 <ReinH> well, monads and comonads give you a -> f a and f a -> a
12:31:12 <ReinH> so that's that
12:31:14 <yogert1> I'm having a bit of trouble with the Hxt library. I'm not sure I quite understand it conceptually, here is an example demonstrating the particular problem i have at the moment http://lpaste.net/16610700117934080 . I want to parse several different datatypes from sibling elements
12:32:54 <yogert1> Every approach ive tried thus far seems to work across a sibling elements
12:33:02 <yogert1> Am I approaching this wrong?
12:33:35 <absence> mm_freak: out of curiousity, can netwire be used without the arrow instance, and if so, would that make it classic frp rather than arrowised?
12:34:40 <Javran> @pl join (***)
12:34:40 <lambdabot> join (***)
12:34:47 <joelteon> :t join (***)
12:34:48 <lambdabot> Arrow a => a b c -> a (b, b) (c, c)
12:35:09 <joelteon> (b `a` c) -> ((b,b) `a` (c,c))
12:35:15 <prooftechnique> > (1,2) ^.. both
12:35:17 <lambdabot>  [1,2]
12:35:18 <joelteon> I wish type signatures could be written infix
12:35:19 <prooftechnique> There
12:35:24 <jle`> me too
12:35:30 <Javran> lens?
12:35:32 <jle`> it'd also be nice to have infix operators
12:35:36 <prooftechnique> Javran: Yeah
12:35:41 <jle`> (b ~> c) -> ((b,b) ~> (c,c))
12:35:41 <joelteon> yeah
12:35:45 <Javran> :t (^..)
12:35:46 <lambdabot> s -> Getting (Endo [a]) s a -> [a]
12:35:48 <joelteon> type operators?
12:35:51 <joelteon> they just have to start with : don't they?
12:35:55 <joelteon> or something like that.
12:35:56 <Javran> I see, cool!
12:36:02 <jle`> those are constructors i think?
12:36:08 <jle`> hm
12:36:11 <jle`> i'm probably wrong
12:36:19 <prooftechnique> Javran: If reading that type signature makes you see anything, you're a better mind than I :D
12:37:16 <prooftechnique> :t (^.. both) -- this is at least a little more informative
12:37:17 <lambdabot> (a, a) -> [a]
12:37:29 <Javran> prooftechnique: I don't get anything from that signature :(
12:37:36 <jle`> Javran: oh yeah, you can use : for concrete type constructors, but not for type variables.
12:38:10 * hackagebot sequor 0.7.2 - A sequence labeler based on Collins's sequence perceptron.  http://hackage.haskell.org/package/sequor-0.7.2 (GrzegorzChrupala)
12:38:48 <prooftechnique> Javran: That's normal. No worries :)
12:40:18 <Javran> the first idea I can think about is to do the replace: "(,) a b" becomes "(:) a (return b)"
12:40:49 <Javran> might need something "contravariant" on b then?
12:42:09 <mmmm> hey guys, anyone know where I can find a copy of haskell.y?
12:44:21 <awestroke> mmmm: I don't think haskell has a context free grammar
12:46:06 <awestroke> very few programming languages have
12:46:25 <mmmm> I'm trying to work out how to string alex + happy together
12:46:32 <ByteEater> Hello, everybody! Could you help me understand the difference between consuming any input and not consuming it in parsers of type String -> [(s, String)]? Why doesn't (<|>) backtrack but (try) does?
12:47:25 <awestroke> ByteEater: does it? I thought you always needed readAhead
12:48:13 <awestroke> mmmm: you create a bnfc grammar, compile it and then compile the .y to hs with happy and the .x to hs with alex
12:48:39 <ByteEater> readAhead? I didn't know it existed; where is it defined?
12:48:47 <Javran> how about this:
12:48:49 <prooftechnique> @hoogle readAhead
12:48:49 <lambdabot> No results found
12:48:55 <Javran> > (uncurry (:) . (second return)) (10,2)
12:48:56 <lambdabot>  [10,2]
12:49:00 <awestroke> @hoogle lookAhead
12:49:00 <lambdabot> Text.Parsec.Prim lookAhead :: Stream s m t => ParsecT s u m a -> ParsecT s u m a
12:49:00 <lambdabot> Text.Parsec.Combinator lookAhead :: Stream s m t => ParsecT s u m a -> ParsecT s u m a
12:49:00 <lambdabot> Text.ParserCombinators.Parsec.Combinator lookAhead :: Stream s m t => ParsecT s u m a -> ParsecT s u m a
12:50:40 <jle`> bartavelle: i think it depends on the implementation
12:50:46 <awestroke> ByteEater: (lookAhead . try) is great for manyTill when you don't want to consume the text you are stopping at
12:51:06 <jle`> bartavelle: the first parser i wrote of that type had everything backtracking
12:51:13 <jle`> sorry, ByteEater ^^
12:51:26 <Javran> :t second
12:51:27 <lambdabot> Arrow a => a b c -> a (d, b) (d, c)
12:51:30 <Javran> :t fmap
12:51:32 <lambdabot> Functor f => (a -> b) -> f a -> f b
12:53:37 <Javran> :t fmap return (10,2)
12:53:38 <lambdabot> (Monad m, Num t, Num a) => (t, m a)
12:53:44 <Javran> :t second return (10,2)
12:53:44 <lambdabot> (Monad m, Num d, Num a) => (d, m a)
12:56:51 <jle`> :t Data.Bifunctor.second return (10,2)
12:56:52 <lambdabot> (Monad m, Num a, Num b) => (a, m b)
12:57:17 <yogert1> what is (-<) I look for it on hoogle, and it just says "keyword"
12:57:25 <jle`> yogert1: because it's language syntax
12:57:28 <jle`> like <-
12:57:45 <kylcarte> yogert1: It's from the Arrows extension.
12:57:57 <jle`> a <- b -< c
12:58:13 <yogert1> okay… so its like (<-) but for arrows..?
12:58:16 <jle`> represents running `c` through the Arrow `b`, and binding the result in the value `a`
12:58:26 <jle`> it looks like a little ascii arrow :)
12:58:43 <prooftechnique> Haha, I just noticed that
12:58:45 <kylcarte> yogert1: http://www.haskell.org/ghc/docs/7.6.3/html/users_guide/arrow-notation.html
12:58:46 <prooftechnique> It's very cute
12:59:36 <jle`> there's also a <- b -<< c
12:59:53 <mm_freak> absence: i use the term "classic FRP" to refer to the traditional monadic API
12:59:57 <jle`> which is like an arrow with extra fletches
12:59:59 <mm_freak> absence: both are just regular "FRP"
13:00:03 <awestroke> can anyone give me a tl;dr of why I should read about bifunctors, comonads, arrows etc?
13:00:07 <edwardk> ByteEater: letting <|> backtrack all the time is a perfectly viable way to write a parser, it is however, a.) potentially incredibly slow, because you always have to worry that you have to start all the way over at any previous (<|>) and resume, so you leak memory like crazy and b.) leads to no useful error messages, which of the (<|>) branches went 'wrong'?
13:00:24 <prooftechnique> jle`: I assume that's more accurate over long distances, then
13:00:26 <mm_freak> absence: and no, you can't get monadic FRP out of netwire
13:00:35 <jle`> awestroke: because they're useful?
13:00:46 <awestroke> jle`: for what?
13:00:46 <jle`> bifunctors aren't anthing difficult
13:00:57 <jle`> they're just functors with two things to map over
13:00:58 <mm_freak> absence: in monadic FRP behaviors and events are first class, in AFRP they're not
13:01:05 <pyon> awestroke: because lots of things are bifunctors, comonads, arrows... and by refusing to acknowledge the existence of those structures, you are just forcing yourself to work of particular bifunctors, comonads, arrows, etc. on an ad-hoc basis
13:01:15 <prooftechnique> awestroke: For the same reason you should read about any abstraction. When you start noticing the shape of things, you can save yourself effort
13:01:16 <awestroke> jle`: are there trifunctors too?
13:01:27 <pyon> awestroke: there are n-functors
13:01:29 <jle`> their answers were better than mine.
13:01:47 <jle`> > Data.Bifunctor.first (*2) (4,2)
13:01:48 <lambdabot>  Not in scope: `Data.Bifunctor.first'
13:01:56 <awestroke> alright, I'm convinced, thanks
13:02:05 <prooftechnique> :)
13:02:11 <prooftechnique> If only everyone were so easily convinced
13:02:40 <edwardk> awestroke: bifunctors pop up all over the place when you start talking about recursion patterns. you need at least 2 cases to discriminate, and can build higher 'k-functors' out of bifunctor parts, so they are really a necessay step above functor, but the only critical step up you _have_ to take for some patterns.
13:02:43 <ByteEater> edwardk, I understand why it's desirable to have try specifically for backtracking and avoid it in other combinators intended for common use; what I'm trying to understand is how it works, i.e. what in their definitions (in the simplest case String -> [(s,String)]) makes them behave this way
13:03:40 <edwardk> comonads? harder sell. i like them. they inform my thinking about automata, stream processing, decorating structures and syntax trees with meta-information, etc. all in one convenient pattern
13:04:22 <mm_freak> i see a strong relationship between comonads and topologies, but haven't formalized it yet
13:04:29 <edwardk> ByteEater: its harder to implement try in String -> [(s, String)] style parsing, because such a parser is actually bigger than the 'simplest case'! it permits you to 'push back' any state you want, so its more powerful than it should be in some ways
13:04:31 <mm_freak> might be part of my topological visibility testing work
13:04:48 <bitemyapp> edwardk: I don't totally understand the resistance to reify structures as long as the process is principled rather than ad-hoc.
13:04:49 <lpsmith> Hmm, is there a way to disable redundant import warnings on a specific module?
13:04:59 <edwardk> ByteEater: you can of course check to see if the string you started with is the same string you ended with, but that isn't terribly effective
13:05:20 <lpsmith> As in, a specific import,  not for the entire module that has the redundant import
13:05:28 <mm_freak> lpsmith: import X ()
13:05:32 <edwardk> bitemyapp: A String -> [(s, String)] parser is a decent starting point to understand parsing, but it has terrible error message behavior. it is called a list of successes parser
13:05:43 <lpsmith> mm_freak, the problem is that these are haddock-only imports
13:05:52 <edwardk> er byteeater
13:05:58 <lpsmith> So that doesn't work,  IIRC,  but let me try quick
13:06:17 <mike1127> question pasted at http://lpaste.net/101955
13:06:36 <edwardk> bitemyapp: the way i usually implement a parser with try is to treat 4 distinct cases, not 2.
13:06:38 <mike1127> beginner here trying to make a class of monads that include random generators, but don't really know what I'm doing
13:06:53 <mm_freak> lpsmith: that's more difficult, but IIRC you can always write fully qualified names in haddock, even if the module isn't imported
13:07:03 <mm_freak> lpsmith: 'Data.Maybe.fromMaybe'
13:07:11 <edwardk> did you succeed without consuming anything? did you succeed and consume something and therefore there is a new state? did you fail without consuming anything and so could backtrack? did you fail after consuming something?
13:07:17 <lpsmith> ahh,  thanks mm_freak
13:07:25 <edwardk> those 4 cases are what a parsec style parser needs to handle
13:07:37 <mm_freak> lpsmith: you should test…  don't take my word for granted there =)
13:07:38 <lpsmith> given that it appears Haddock can't deal with haddock-only {-# SOURCE #-} imports anyway
13:07:48 <lpsmith> mm_freak, I will :-)
13:08:17 <mm_freak> mike1127: "make a class"?  as in write a type class?
13:08:37 <jle`> mike1127: what have you tried?
13:08:44 <jle`> oh, the lpaste
13:08:48 <mike1127> mm_freak: something like "class Monad m => MonadRandom m where"
13:08:51 <edwardk> newtype Parser a = Parser { runParser ::  String -> Result a }   data Result a = Pure a | Commit a String | Fail ErrorMessage | Err ErrorMessage
13:09:13 <edwardk> then the monad for the parser needs to keep the current state if you bind after a pure, upgrade a pure to a commit after a commit, etc.
13:09:13 <mm_freak> oh, i missed the paste, too =)
13:09:24 <lpsmith> mm_freak, that worked, thanks
13:09:30 <edwardk> the fact that we usually cps this is to fix the asymptotics of this approach
13:09:52 <mm_freak> lpsmith: you're welcome
13:09:58 <mm_freak> mike1127: why the ErrorT?
13:10:02 <jle`> mike1127: check the type of get
13:10:06 <zenkeku> Is there an easy way to find where a function is defined?
13:10:10 <lpsmith> which honestly makes my life a lot simpler,  since (even if the haddock {-# SOURCE #-} imports worked),  it would involve a lot of changes to the .hs-boot files just for haddock purposes
13:10:11 <edwardk> when you only have String -> [(s, String)]  -- you don't have a fast check to see if you changed the string other than comparing the whole massive thing
13:10:13 <zenkeku> In the main haskell files, I mean.
13:10:23 <mm_freak> zenkeku: :i in ghci
13:10:30 <mm_freak> load your modules, then use :i
13:10:35 <edwardk> you also don't have a place to put the parse errr
13:10:41 <jle`> mike1127: look at the type of get, hopefully that'll help you
13:10:46 <zenkeku> Er.. Is there a way to determine what module a function is in?
13:10:55 <mm_freak> zenkeku: :i
13:11:05 <Kam_> ++
13:11:17 <zenkeku> mm_freak: With out already having the module loaded?
13:11:33 <mm_freak> zenkeku: then not really, unless your editor supports tags or something
13:11:47 <jle`> what do you mean by main ahskell files?
13:11:55 <jle`> in your Main module?
13:11:59 <jle`> or in base?
13:12:04 <zenkeku> The libraries shipped with haskell
13:12:11 <jle`> hoogle searches base
13:12:19 <jle`> hayoo searches the entire HP i think
13:12:25 <mike1127> jle': well somehow I need to make BT an instance of MonadState, but I don't know how to do that
13:12:27 <jle`> hoogle searches base + useful things
13:12:29 <zenkeku> Where is hing?
13:12:45 <jle`> mike1127: do you know how to make x an instance of y?
13:12:47 <ReinH> mike1127: what is BT?
13:13:01 <jle`> instance Y X where function1 = ...; function2 = ...
13:13:07 <ByteEater> edwardk, that's exactly my current goal - to understand monadic parsing, starting with String -> [(s, String)] for simplicity; I wrote an implementation of <|> which doesnt't backtrack but to me it looks like it should; maybe I'll try to put it on lpaste.net and ask another question; thanks for your useful explanations so far
13:13:15 <ReinH> mike1127: use GeneralizedNewtypeDeriving
13:13:27 <mike1127> ReinH: I am
13:13:31 <mm_freak> mike1127: start with:  instance MonadState BTState BT where
13:13:40 <ReinH> so deriving (MonadState BTState) should work
13:13:47 <mm_freak> GeneralizedNewtypeDeriving likely won't work for that one
13:13:52 <ReinH> mm_freak: why not?
13:13:52 <jle`> wouldn't it?
13:13:53 <ReinH> works for me
13:13:54 <mm_freak> StandaloneDeriving might, but i doubt it
13:13:55 <jle`> ErrorT is a MonadState
13:14:06 <mike1127> okay everyone I think I know what I'll try, give me a minute to figure it out
13:14:06 <jle`> but i think this would be missing a good learning opportunity
13:14:16 <mm_freak> ReinH: because GNT often doesn't work for multi-param type classes =)
13:14:21 <jle`> because writing the MonadState instance here is pretty straightforward
13:14:25 <ReinH> mm_freak: it works for MonadState because I've used it :)
13:14:33 <mm_freak> and yes, don't use GNT
13:14:36 <ReinH> jle`: writing any instance for a newtype is straightforward
13:14:41 <awestroke> can I even learn about comonads and contravariantfunctors without learning category theory?
13:14:47 <ReinH> jle`: straightforward enough, in fact, that you can just tell a computer to do it ;)
13:14:49 <jle`> awestroke: yes
13:14:56 <awestroke> the explanations I find refer to category theory
13:15:06 <jle`> awestroke: what kind of category theory
13:15:11 <benmachine> awestroke: what's wrong with category theory? :(
13:15:13 <lpsmith> Hmm, ok, so a fully qualified Haddock reference always results in #t:identifier fragments,  what about #v:identifier fragments?
13:15:16 <jle`> http://ocharles.org.uk/blog/guest-posts/2013-12-21-24-days-of-hackage-contravariant.html
13:15:28 <lpsmith> Is there any way to link to a value in haddock without importing the module?
13:15:31 <stephenmac7> Is there any reason to use getStdGen over newStdGen?
13:15:42 <mm_freak> awestroke: you could read "extract" as "theValueHere" and "extend" as "mapFunctionThatLooksAtNeighbourhood" =)
13:15:51 <davidthomas> Since comonads and contravariant functors are concepts in category theory, by learning about them you'll necessarily be learning some category theory...
13:15:53 <awestroke> benmachine: I assume it's quite hard to grasp and I have doubts I can intuitively understand all of it
13:16:12 <awestroke> benmachine: but if you know of a good book, please recommend it to me
13:16:22 <jle`> why would you have doubts?
13:16:27 <jle`> or assume it's hard to grasp?
13:16:30 <jle`> don't you know what a functor is?
13:16:38 <jle`> don't you know what function composition is?
13:16:42 <awestroke> jle`: it seems very complicated.
13:16:48 <awestroke> yes, but those don't have fancy names
13:16:48 <jle`> have you ever used a functor?
13:16:57 <jle`> 'fancy names'
13:17:05 <jle`> go to #ruby and ask people if functor is a fancy name :P
13:17:09 <mm_freak> awestroke: you don't need to learn "category theory"…  most of us don't know "category theory", but only the relevant parts
13:17:29 <jle`> you are alreay learning category theory, congrats.
13:17:31 <mm_freak> awestroke: understanding categories and functors gives you most of haskell
13:18:33 <mike1127> I tried 'instance MonadState BTState BT where' -- required adding MultiParamTypeClasses and FlexibleContexts, then tried to define get = gets insideBT but that didn't work. I'm utterly confused.
13:18:55 <jle`> 'arithmetic is hard!' 'why?' 'because they have fancy names and i don't think i will be able to understand.' 'do you know how to add?' 'well yeah duh.' 'do you know how to multiply?' 'obviously.' 'that's already arithmetic.' 'oh. well...it's still hard okay.'
13:19:08 <mm_freak> mike1127: remember that the result is a BT
13:19:11 <awestroke> then how do I learn what a comonad is? Wikipedia is useless if I don't know category theory notation, the github comonads repo refers to category theory, the hackage docs only tell me how I define a comonad
13:19:21 <mm_freak> mike1127: get = BT (… get …)
13:19:24 <jle`> awestroke: just look at the type signatures
13:19:49 <jle`> awestroke: extract :: w a -> a
13:19:53 <jle`> what does that mean?
13:19:55 <edwardk> awestoke: a monad is 2 combinators + 3 laws. a comonad is 2 different combinators with 3 laws
13:20:19 <mm_freak> mike1127: and within BT is an ErrorT (and i still don't understand why you have the ErrorT there)
13:20:31 <edwardk> awestroke: 'learning what a monad is' involves getting your head around what those laws mean for a lot of examples and generalizing.
13:20:38 <edwardk> learning what a comonad is is the same process
13:20:53 <briennetheblue> if i have a list of indices, can i make a traversal from them?  if so, how?
13:21:26 <edwardk> briennetheblue: well, the concern is the types can't verify that that list of indices is _unique_
13:21:27 <mr-> 21
13:21:36 <awestroke> edwardk: the difference being that monads are everywhere, but I have yet to see a comonad
13:21:46 <edwardk> briennetheblue: if you could have repeats in the list you can't pass the laws
13:21:55 <edwardk> awestroke: let's define a comonad between us right now.
13:21:59 <mike1127> mm_freak: have ErrorT because in my application I want to have good error handling as well as passing a random generator around
13:22:10 <briennetheblue> i see...
13:22:11 <edwardk> awestroke: can you write a function extract :: (e, a) -> a   ?
13:22:23 <awestroke> snd
13:22:26 <mike1127> mm_freak: "get = BT get" compiled. hmm now I'm try put
13:22:31 <edwardk> awestroke: good. now, lets do extend
13:22:47 <edwardk> awestroke: extend :: ((e, a) -> b) -> (e, a) -> (e, b)
13:23:02 <edwardk> bit trickier, but not too much harder
13:23:05 <mm_freak> mike1127: you should keep those separate
13:23:52 <awestroke> extend f (x, y) = (x, f y)
13:23:57 <mike1127> mm_freak: sorry, keep what seperate?
13:24:08 <edwardk> awestroke: congratulations on defining your first comonad. now you'v seen one.
13:24:10 <mm_freak> mike1127: error handling and random number generation
13:24:24 <edwardk> lets check one of the laws. convince yourself that extend extract = id
13:24:25 <mike1127> mm_freak: I'm taking inspiration from the paper "Monad Transformers Step by Step"
13:24:40 <edwardk> er you had an error
13:24:41 <awestroke> edwardk: Could you point me to an example of a real usage of a comonad?
13:24:46 <iteratee> awestroke: shouldn't that be: extend f p@(x, y) = (x, f p)
13:24:49 <mm_freak> mike1127: yes, yet keep them separate =)
13:24:49 <edwardk> extend f (x, y) = (x, f (x, y))
13:24:54 <edwardk> iteratee: yes
13:25:01 <awestroke> ah, yes
13:25:05 <mm_freak> mike1127: newtype BT m a = BT { runBT :: StateT BTState m a }
13:25:25 <edwardk> awestroke: sure. lens uses comonad coalgebras all over the place.
13:25:34 <mm_freak> mike1127: your very own monad transformer (which is essentially just a specialized StateT)
13:25:42 <ystael> edwardk: that looks suspiciously like, but not exactly like, a fiber bundle projection
13:25:46 <edwardk> awestroke: many of the hardest to write combinators in there are only possible from the insights gaine that way
13:26:14 <prooftechnique> edwardk: When are you going to do another talk, anyway? :D
13:26:19 <mm_freak> mike1127: your application code should be feature-based and transformer-stack-agnostic, otherwise your eyes will hurt
13:26:21 <edwardk> awestroke: more down to earth ones, lets see. cellular automata: https://www.fpcomplete.com/user/edwardk/cellular-automata
13:26:54 <mm_freak> mike1127: myFunction :: (MonadRandom m, MonadError SomeException m) => String -> m Integer
13:27:11 <jle`> awestroke: have you ever used runIdentity
13:27:18 <jle`> to get a value out of an Identity monad
13:27:26 <edwardk> prooftechnique: i'm giving a talk at johns hopkins in 2-3 weeks, one in germany next month, one in zurich after that, possibly lambdajam, probably doing a lens tutorial for cufp...
13:27:37 <mike1127>    mm_freak: don I have to put those class constraints on every function?
13:28:00 <mm_freak> awestroke: i found store comonads very useful for image processing
13:28:15 <mm_freak> mike1127: yes
13:28:29 <jle`> mike1127: yes, but now you are dealing with something a little less fragile than a transformer stack
13:28:35 <mr-> edwardk: where in germany?
13:28:36 <jle`> you can modify the stack you use
13:28:43 <jle`> add layers, take them out, rearrange them
13:28:47 <jle`> and still use the same functions
13:28:58 <mm_freak> mike1127: it will be easier in the end, and if you really want to save a few keystrokes, you can always use the ConstraintKinds extension
13:29:01 <jle`> well i guess using a type alias offers the same advantage
13:29:12 <edwardk> awestroke: cellular automata: https://www.fpcomplete.com/user/edwardk/cellular-automata      making resumable folds so i can 'reopen' streaming calculations: https://www.fpcomplete.com/user/edwardk/cellular-automata/part-2    parallelizing CRC calculations: https://www.fpcomplete.com/user/edwardk/parallel-crc
13:29:16 <mm_freak> mike1127: type MonadMyApp m = (MonadRandom m, MonadError SomeException m)
13:29:16 <jle`> but it's more like dealing with abstractions instead of concrete
13:29:31 <awestroke> jle`: Never seen the Identity monad before
13:29:46 <mike1127> mm_freak: so are you saying I explicitly derive MonadError and MonadRandom and MonadState rather than use monad transformers?
13:29:52 <awestroke> edwardk: reading, thanks
13:30:06 <edwardk> awestroke: working around type inference sucking in scala when writing complex parsers... https://github.com/ermine-language/ermine-legacy/blob/master/src/main/scala/com/clarifi/reporting/ermine/parsing/Localized.scala#L10
13:30:08 <angerman> how would one parse smething lie [alphanum]:[alphanum]:[alphanum]:...:[alphanum] with parsec?
13:30:12 <mm_freak> mike1127: no, you still use monad transformers, but your actual application code isn't aware of the precise structure of your monad
13:30:14 <jle`> awestroke: data Identity a = Identity a, it's just a plain dumb wrapper around an item
13:30:18 <jle`> angerman: parse it as what?
13:30:28 <mm_freak> mike1127: only at one point you actually define what your monad looks like:  your run-function
13:30:28 <jle`> a list of alphanums?
13:30:30 <edwardk> mr-: munich
13:30:36 <angerman> jle`: yep
13:30:41 <edwardk> mr-: http://www.tngtech.com/en/events-bigtechday07.html
13:30:50 <mike1127> mm_freak: your newtype example didn't have ErrorT in it, so I don't know where I am supposed to put that
13:31:28 <jle`> angerman: sepBy1 alphanum (char ':')
13:31:32 <mm_freak> mike1127: example: runErrorT . evalStateT seed . runBT
13:31:38 <jle`> or sepBy to match zero occurrences
13:31:40 <mm_freak> mike1127: at the point where you're running your application
13:31:50 <jle`> http://hackage.haskell.org/package/parsec-3.1.5/docs/Text-Parsec-Combinator.html#v:sepBy
13:31:59 <absence> mm_freak: ok, thanks for clearing that up :)
13:32:06 <mm_freak> mike1127: that code would specify your monad to be something like:  BT (ErrorT SomeException)
13:32:22 <awestroke> jle`: yeah I understand it, why?
13:32:28 <mike1127> mm_freak: my head hurts but I'll go study it and see what I can learn
13:32:33 <mm_freak> mike1127: but see how wrapping that around doesn't actually require you to change your application
13:32:46 <mr-> edwardk: Oh, nice. I've been meaning to go there for some time
13:32:47 <mm_freak> you can use ErrorT SomeException (BT IO) instead
13:33:08 <mm_freak> oh, i missed an IO above =)
13:33:09 <kadoban> Anyone know if, in test-framework there's a way to allow some specific testGroups to fail and have it still report success (like, the error code in the shell succeed, I'd like the failing tests to still be reported of course)
13:33:13 <jle`> awestroke: well, you know about 'return', right?
13:33:21 <jle`> awestroke: return puts an item into an Identity
13:33:29 <jle`> and...how about an 'unreturn'?
13:33:40 <jle`> which gets an item out of the Identity?
13:33:57 <jle`> normally we use runIdentity, Identity a -> a
13:34:14 <edwardk> prooftechnique: i may do something more off-the-cuff about ermine at hac nyc as well
13:34:24 <jle`> but deoesn't that look a lot like .... ?
13:34:34 <edwardk> prooftechnique: now that the new compiler is starting to shape up
13:34:36 <mm_freak> awestroke: you haven't seen Identity because we seldomly use it explicitly, but whenever you use transformers/mtl you use Identity implicitly all over the place =)
13:34:58 <awestroke> mm_freak: aaaah, yeah, I've seen that now that you mention it
13:35:40 <briennetheblue> i'm guessing     indices (`elem` [1,2,3])     isn't a very efficient way to traverse those indices in a big Map... is there any way if i'm willing to assert that the indices are unique and suffer the terrible consequences if i lied
13:35:47 <awestroke> jle`: but >>= extracts already, in a way
13:35:48 <mm_freak> awestroke: btw, the name has a reason:  it's the identity functor on Hask =)
13:36:01 <jle`> awestroke: really?
13:36:12 <jle`> awestroke: can you define Identity a -> a using (>>=) ?
13:36:23 <mm_freak> awestroke: (>>=) doesn't extract any more than fmap extracts
13:36:25 <awestroke> jle`: no, but I can define >>= using runIdentity
13:36:28 <mm_freak> awestroke: it maps
13:36:36 <jle`> awestroke: but how do you define runIdentity?
13:36:42 <jle`> that's what i'm referring to.
13:36:43 <angerman> jle`: thanks!
13:36:51 <mm_freak> if you flip its arguments around, (>>=) and fmap don't look too different =)
13:36:51 <awestroke> jle`: it's just the record getter
13:36:53 <jle`> runIdentity is the generalizable function
13:37:13 <jle`> awestroke: that's like saying 'return is just a constructor application'
13:37:16 <mm_freak> fmap  :: (a ->   b) -> (F a -> F b)
13:37:27 <mm_freak> (=<<) :: (a -> F b) -> (F a -> F b)
13:37:40 <jle`> note, runIdentity :: Identity a -> a
13:37:45 <jle`> we can generalize this
13:37:54 <mm_freak> (<<=) :: (F a -> b) -> (F a -> F b)
13:38:02 <mm_freak> (<*>) :: F (a -> b) -> (F a -> F b)
13:38:05 <jle`> and note that 'runIdentity-like functions' share lots of neat properties with eachother.
13:38:06 <mm_freak> they are all just fancy mappers =)
13:38:18 * hackagebot simple 0.8.0.1 - A minimalist web framework for the WAI server interface  http://hackage.haskell.org/package/simple-0.8.0.1 (AmitLevy)
13:38:20 <jle`> runIdentity is extract
13:38:22 <jle`> :t extract
13:38:23 <lambdabot> Not in scope: `extract'
13:38:26 <jle`> damn
13:38:40 <mmmm_> Is there no read instance for String?
13:38:42 <jle`> extract :: w a -> a
13:38:54 <yesthisisuser> I am trying to cabal install scotty under a sandbox but get an error "Could not find module Control.Monad.Trans.Resource"
13:38:54 <jle`> mmmm_: there is for me?
13:39:06 <mmmm_> read "aa" :: String is right ye?
13:39:10 <jle`> er
13:39:12 <jle`> no
13:39:16 <prooftechnique> > read "\"string\"" :: String
13:39:17 <lambdabot>  "string"
13:39:18 <jle`> > show "aa"
13:39:18 <lambdabot>  "\"aa\""
13:39:27 <prooftechnique> > read . show $ "string"
13:39:28 <lambdabot>  *Exception: Prelude.read: no parse
13:39:30 <jle`> > read (show "aa")
13:39:31 <lambdabot>  *Exception: Prelude.read: no parse
13:39:33 <jle`> oh
13:39:38 <jle`> becuase of that monomorphism restriction thingy
13:39:40 <mike1127> mm_freak: I don't understand this well enough to figure it out. Is there a written-out example somewhere?
13:39:57 <mm_freak> mike1127: do you have a specific application in mind?
13:40:23 <jle`> > read (show "aa") :: String
13:40:25 <lambdabot>  "aa"
13:40:31 <awestroke> jle`: I really appreciate the explanations, but I need to put it into a context of how it is used... I might attempt to read the Lens package source
13:40:42 <mike1127> mm_freak: eventually this will do backtracking search to find musical counterpoint that fits certain constraints
13:40:44 <mm_freak> awestroke: don't!
13:40:49 <jle`> awestroke: try edwardk's cellular automata tutorial
13:41:10 <jle`> awestroke: well at least you now fully understand what a comonad is :)
13:41:12 <prooftechnique> Try all of edwardk's tutorials
13:41:19 <mm_freak> mike1127: can you give me a simple example of a function that you would need to write?  just in words
13:41:19 <beaky> hello
13:41:21 <edwardk> reading the lens source is a quick path to either mastery or madness, though it more often than not leads to the latter.
13:41:24 <jle`> hello beaky
13:41:26 <beaky> what is the difference between bind and join
13:41:31 <jle`> :t (>>=)
13:41:32 <lambdabot> Monad m => m a -> (a -> m b) -> m b
13:41:32 <jle`> :t join
13:41:33 <lambdabot> Monad m => m (m a) -> m a
13:41:47 <jle`> assuming you know enough haskell to understand type signatures
13:42:37 <jle`> they are different enough things in that it's hard to really compare them
13:42:49 <jle`> join 'squashes' nested data
13:42:49 <awestroke> jle`: I don't truly understand something until I can think of a concrete, useful application
13:42:56 <beaky> isnt bind just flip of fmap of join
13:42:56 <mm_freak> add fmap to the mix, then they aren't really that difficult
13:43:06 <mm_freak> fmap ~ map, join ~ concat
13:43:06 <mike1127> mm_freak: I don't know if I have a simple example. there will be a "backtrack" function that takes an intial state of the counterpoint, tries adding notes using pseudorandomness at times to select possibilities rather than ..
13:43:11 <mm_freak> bind ~ concatMap
13:43:24 <jle`> beaky: a >>= b = join (fmap b a), yeah
13:43:36 <mm_freak> please use 'f' for functions =)
13:44:01 <mike1127> ... try every possibilty, and has good error handling and also keeping a record of its operations that explains the context of the error or operations ...(because I want to do some experiments
13:44:08 <jle`> a >>= f = join (fmap f a) :)
13:44:17 <mike1127> ... and get visibility into how it's functioning
13:44:30 <mm_freak> mike1127: in your current framework you would probably write something like this:  backtrack :: Arg -> BT Result
13:45:10 <mm_freak> mike1127: this function relies on a specific monad transformer stack to do its work…  but how about:  backtrack :: (Monad m) => Arg -> m Result
13:45:16 <mm_freak> mike1127: doesn't work, because you need randomness
13:45:25 <mm_freak> mike1127: (MonadRandom m) => Arg -> m Result
13:45:32 <mm_freak> still doesn't work, because the function might fail
13:45:39 <mm_freak> mike1127: (MonadRandom m, MonadError MyError m) => Arg -> m Result
13:45:41 <mm_freak> works now
13:45:51 <mm_freak> but doesn't know what the underlying monad actually looks like
13:46:01 <mm_freak> all it knows is that it can get random numbers and that it can fail
13:47:14 <mike1127> mm_freak: okay I understand that part. what I don't know how to do is declare my types and what instances I need to derive
13:47:42 <mm_freak> mike1127: notice that i added a monad argument to your BT type
13:47:53 <mm_freak> newtype BT m a = BT { runBT :: StateT BTState m a }
13:48:05 <mm_freak> whenever 'm' is a MonadError, BT m is also a MonadError
13:48:16 <mm_freak> in other words:  instance (MonadError e m) => MonadError e (BT m)
13:48:18 <jle`> BTT :)
13:48:52 <mm_freak> to be honest i'm not overly fond of that T suffix =)
13:49:04 <mm_freak> i'd prefer State and StateP over StateT and State respectively
13:50:01 <mike1127> mm_freak: then do I define "throwError" as part of that instance?
13:50:08 <mm_freak> mike1127: exactly
13:50:45 <jle`> P?
13:51:16 <luvfp> is there an equivalent to the stringizing operator in Haskell?
13:51:26 <mike1127> is it "throwError x = BT (throwError x)"?
13:52:00 <mm_freak> jle`: "Pure", "Poor", "suPercalifragilisticexpialidocious", …
13:52:05 <mm_freak> jle`: pick =)
13:52:16 <mm_freak> luvfp: what's that?
13:52:19 <mm_freak> mike1127: yeah, i think so
13:52:49 <jle`> you could also instance BT as a MonadTrans, right?
13:52:58 <jle`> and then all of your instances are pretty easy
13:52:58 <mm_freak> you could and should
13:53:07 <jle`> throwError = lift throwError
13:53:08 <mm_freak> jle`: not all
13:53:09 <jle`> get = lift get
13:53:20 * hackagebot postie 0.4.0.0 - SMTP server library to receive emails from within Haskell programs.  http://hackage.haskell.org/package/postie-0.4.0.0 (alexbiehl)
13:53:20 <jle`> er well not get
13:53:29 <jle`> because it's already a StateT
13:53:36 <jle`> mm_freak: hm, not all?
13:53:47 <itzurabhi> How well does Haskell map to assembly compared with C++
13:53:55 <luvfp> mm_freak: in my C code i have a macro like this: CFG_GET( sec, opt, def) ( GetConfigItem( cfg_file_fp, sec, #opt, def )
13:53:57 <mike1127> mm_freak: I'm gett "illegal instance declaration" on the line "instance (MonadError e m) => MonadError e (BT m) where"
13:54:09 <mm_freak> functions like catchError, listen, local
13:54:12 <mm_freak> @ jle`
13:54:15 <jle`> ah yeah
13:54:24 <beaky> qhRA RHW SIDDWRNW BWRRW AWA
13:54:26 <beaky> oops
13:54:35 <beaky> whats is the difference between applicatives and monads
13:54:45 <jle`> itzurabhi: almost incomparable
13:55:01 <mm_freak> luvfp: that doesn't even make sense in haskell
13:55:18 <beaky> if monads are just glorified functors, what are applicatives
13:55:30 <mm_freak> beaky: glorified functors
13:55:34 <itzurabhi> @jle` runtime performance?
13:55:34 <lambdabot>  Parse failed: Parse error: EOF
13:55:45 <mm_freak> luvfp: if cfgFileFp is in scope you can always define:  cfgGet = cfgGetItem cfgFileFp
13:55:52 <jle`> itzurabhi: it can be just as efficient/performant as C
13:56:11 <luvfp> mm_freak: so the #opt makes it a string so I can call it like CFG_GET( "host", address, "127.0.0.1" )  it will be replaced by GetConfigItem( cfg_file_fp, "host", "address", "127.0.0.1" )
13:56:18 <jle`> it depends on how you write your code of course.  you can write both efficient and inefficient code in both C++ and Haskell
13:56:27 <jle`> knowing the difference takes some experience, for both
13:56:35 <mm_freak> luvfp: that's not possible in haskell
13:56:39 <luvfp> mm_freak: yeah but i was wondering if there is a way to do something equivalent
13:56:49 <mm_freak> luvfp: or at least putting those quotes around the string is the shortest code you can get
13:56:51 <ReinH> luvfp: you could pass the string "address" :)
13:56:56 <itzurabhi> :) thanks
13:57:14 <jle`> beaky: this might help you http://adit.io/posts/2013-04-17-functors,_applicatives,_and_monads_in_pictures.html
13:57:17 <luvfp> basically the macro lets me avoid some repetition and typos
13:57:34 <mm_freak> luvfp: but in haskell you probably wouldn't use stringly typed item names…  you would rather define a certain class instance for your run-time configuration type
13:57:39 <brisbin> beaky: i like to think of Monad as series while Applicative is parallel. Monad is for sequencing dependent actions while Applicative is for pulling many actions into a composite action
13:57:50 <luvfp> say i have a record value now i can set the correct field from the config by using the field name
13:58:14 <brisbin> that's another "this description only makes sense if you already know the answer" statement common to Monad discussions though
13:58:24 <prooftechnique> luvfp: You'd say config = Config { field = value }
13:58:47 <fizbin> brisbin: Monad is "Applicative plus join", so if you view "join" as "sequence this collection of actions", that works.
13:59:00 <mm_freak> itzurabhi: recently i wrote a sieve of eratosthenes that outperforms every attempt i made in C
13:59:02 <prooftechnique> Or if there's one already defined, config2 = config { field = value }
13:59:14 <luvfp> prooftechnique: i'm tyring to use http://hackage.haskell.org/package/ConfigFile-1.0.5/docs/Data-ConfigFile.html
13:59:22 <brisbin> fizbin: nice
13:59:35 <mm_freak> itzurabhi: https://twitter.com/ertesx/status/446662199843782656
13:59:38 <johnw> brisbin: another way to say that is that Monad combines f1 * f2 -> f' (the union of the contexts), while Applicative composes f1 * f2 -> (f1, f2) (the product of the contexts).  That difference would be exactly 'join'
14:00:01 <itzurabhi> Any sample code available?
14:00:26 <mm_freak> itzurabhi: in most cases number crunching in haskell will be a bit slower than C++, but not by much
14:00:29 <luvfp> so when i say get cp "host" "address"  I will get a value from the file cp was readfrom
14:00:32 <mm_freak> itzurabhi: code is linked in the tweet
14:01:03 <jle`> itzurabhi: here is an exaxmple of haskell code and its corresponding assembly, http://neilmitchell.blogspot.com/2014/01/optimising-haskell-for-tight-inner-loop.html
14:01:05 <prooftechnique> luvfp: Can you paste an example so I can see what you're trying to do?
14:01:08 <mm_freak> luvfp: well, ConfigFile is a bit simplistic…  i usually use aeson for configuration
14:01:11 <luvfp> but then i have to manually construct the record it goes into .
14:01:16 <acowley> Is it possible to work with a test suite using cabal repl in emacs via interactive-haskell mode?
14:01:24 <acowley> It only loads the default target afaics
14:01:30 <mm_freak> luvfp: so my application configuration is not a map of strings, but actually a native haskell value
14:01:32 <acowley> So I have to use cabal repl from the command line
14:01:33 <johnw> did you try "cabal repl test"?
14:01:45 <johnw> usually specifying a target works with most cabal subcommands
14:01:50 <luvfp> mm_freak: I already have several cfg files in a format similar to .ini
14:01:53 <acowley> johnw: That's what I do from the command line
14:02:03 <johnw> ah, can you set cli opts for interactive-haskell?
14:02:08 <acowley> johnw: But within emacs, I juse use C-C C-L
14:02:13 <johnw> right
14:02:14 <acowley> Yeah, probably
14:02:19 <luvfp> prooftechnique: still have to write the Haskell code, just finished scannin through the C code now
14:02:19 <johnw> C-u C-c C-l?
14:02:21 <mm_freak> luvfp: unfortunately i haven't find any nice libraries for ini files =/
14:02:26 <acowley> I was hoping one of the questsions interactive-haskell asks me would do it
14:02:26 <brisbin> johnw: very recently, this would've been all above my head. feels good to start to "get it"
14:02:31 <mike1127> mm_freak: getting errors, pasted information at http://lpaste.net/101955
14:02:36 <johnw> brisbin: I know just how you feel!
14:02:36 <luvfp> Data,ConfigFile looks like it should work
14:03:00 <mm_freak> luvfp: ConfigFile doesn't really qualify as "nice" for me =)
14:03:00 <johnw> brisbin: btw, your insight makes me think that there is more of a connection between applicatives and free monads than I had realized
14:03:23 <brisbin> i need to read up on free monads, they've popped up a few times recently
14:03:24 <acowley> johnw: Ah, I think that will do it! Thank you!
14:03:32 <prooftechnique> luvfp: Ah, okay
14:03:55 <acowley> Oof
14:03:59 <acowley> It's a little buggy
14:04:04 <luvfp> mm_freak: why?
14:04:06 <johnw> brisbin: if a monad maintains a "context" around a type, then a free monad is a "list/tree/structure of contexts" around a type, where you decide which algebra to process that list/tree/structure with after the fact
14:04:15 <joelteon> you can reference not-in-scope identifiers using TH, right?
14:04:22 <acowley> It offered to add a build-depends, then added it to the wrong target
14:04:35 <johnw> brisbin: it can be illuminating to see what thing are equivalent to free monads
14:04:50 <johnw> for example, List a ~ Free ((,) a) ()
14:04:50 <brisbin> indeed, thanks for the breif description
14:05:18 <ReinH> johnw: and, conversely, to cofree comonads ;)
14:05:22 <johnw> right
14:05:37 <mm_freak> luvfp: if you look at the interface, it's completely imperative
14:05:45 <johnw> just as a monoid compares to a free monoid at the value level, a monad compares to a free monad at the "context" level
14:06:00 <itzurabhi> jle`: the Haskell code runs faster!! That's awesome.
14:06:03 <mm_freak> luvfp: i should be able to get a configuration /value/ and use regular functions on that
14:06:19 <acowley> And after all that, colorized output doesn't work
14:06:23 <ReinH> johnw: I'm using comonoids now. You've probably never heard of them. </hipster>
14:06:25 <acowley> Back to the shell for me
14:06:32 <johnw> I've heard of them, but I thought they weren't very useful?
14:06:39 <mm_freak> itzurabhi: not in general…  well written haskell code is usually a bit slower or on par with C++
14:06:39 <ReinH> johnw: afaik they're just monoids?
14:06:51 <jle`> comonoids, as in splittable data?
14:07:03 <luvfp> Data.ConfigFile's get functin returns an Either Value so it is a regular value right?
14:07:06 <mm_freak> itzurabhi: parallel/concurrent code sometimes outperforms equivalent C++ code
14:07:08 <johnw> a comonoid would be a -> (), which is just const () in all cases, and a -> (a, a), which "undoes" a multiplication
14:07:25 <beaky> what are comonads and why are they useful
14:07:27 <ReinH> johnw: er.
14:07:52 <jle`> beaky: if only you were here half an hour ago :)
14:07:54 <ReinH> johnw: a comonoid would be a single object with all arrows reversed. Which is still a monoid?
14:07:56 <itzurabhi> I feel we can optimize Haskell more due to the decoupling
14:08:03 <johnw> a comonad allows for duplication of contexts, just as monads allow for combining of contexts; comonads allows for extract from a context, just as monads allow for embedding in a context
14:08:19 <jle`> beaky: note that return :: a -> m a
14:08:20 <johnw> ReinH: but a monoid isn't an object, it's an algebraic structure
14:08:25 <jle`> beaky: extract :: m a -> a
14:08:32 <ReinH> johnw: I didn't say that a monoid is an object.
14:08:37 <jle`> note that join :: m (m a) -> m a
14:08:39 <beaky> so comonads are like antimonads?
14:08:44 <johnw> "a comonoid would be a single object"?
14:08:46 <ReinH> It's an object equipped with some arrows, one of which is the identity arrow.
14:08:50 <mike1127> what's wrong with "instance MonadError e m => MonadError e (BT m)" ? I'm getting "the coverage conditon fails for one of its dependencies"
14:08:55 <jle`> note that duplicate :: m a -> m (m a)
14:08:58 <mm_freak> luvfp: oh, indeed…  but still, the key-value indexing concept isn't really what i consider "nice"
14:09:00 <triliyn> johnw: in category theoretic terms, a monoid is a category with only one object. If you take that category and reverse all the arrows, it's still a monoid
14:09:04 <johnw> right, the monoid arrows are () -> a, and (a, a) -> a; so the comonoid flips those
14:09:18 <ReinH> johnw: no, the monoid arrows are all a -> a
14:09:19 <jle`> beaky: yes, with goatees
14:09:24 <mm_freak> mike1127: that's a bit weird
14:09:26 <johnw> triliyn: I see what you mean; I was thinking of the monoidal algebra
14:09:31 <luvfp> mm_freak: aah.  /me back to coding
14:09:33 <ReinH> and so are the comonoid arrows
14:09:42 <beaky> is IO also a comonad?
14:09:50 <johnw> no, IO is most emphatically *not* a comonad
14:09:50 <ReinH> johnw: two different definitions. I'm using the CT one :)
14:09:56 <jle`> beaky: it's a good example of a non-comonad
14:09:58 <johnw> ReinH: gotcha
14:10:00 <jle`> IO a -> a
14:10:02 <jle`> is kinda silly
14:10:11 <johnw> IO a -> IO (IO a) is also silly
14:10:17 <beaky> i guess unsafePerformIO is a comonad
14:10:20 <edwardk> johnw: 'return' =)
14:10:21 <johnw> you go from a world to a world within worlds?
14:10:21 <beaky> or  not
14:10:27 <edwardk> beaky: fails the laws
14:10:31 <mm_freak> luvfp: let me put it this way:  once you have a configuration, accessing it should never fail
14:10:44 <johnw> edwardk: true!
14:10:51 <beaky> what about lenses are they comonads
14:10:52 <shachaf> IO a -> IO (IO a) is a perfectly reasonable type.
14:11:02 <johnw> but duplicate is rarely duplicate = return
14:11:06 <edwardk> lenses are comonad coalgebras, not comonads per se
14:11:24 <johnw> shachaf: as a type, yes, but having the semantics of duplicate, is it also then?
14:11:31 <mike1127> mm_freak: do you know what's wrong?
14:11:34 <edwardk> johnw: it is for Identity =)
14:11:43 <mm_freak> johnw: 'join' acts like 'extract' for the upper layers
14:11:46 <johnw> edwardk: fair enough
14:11:55 <edwardk> johnw: (and only Identity)
14:12:14 <triliyn> Are there any types other than Identity that are both monads and comonads?
14:12:27 <hpc> []
14:12:36 <johnw> triliyn: Const?
14:12:40 <mm_freak> dup :: IO a -> IO (IO a)
14:12:44 <mm_freak> join :: IO (IO a) -> IO a
14:12:53 <mm_freak> join . dup = id
14:13:05 <mm_freak> but that 'dup' would be quite useless =)
14:13:13 <apples> non-empty lists
14:13:14 <triliyn> Const doesn't have a valid return and [] doesn't have a valid extract, I think
14:13:17 <ReinH> mm_freak: is that the canonical adjunction?
14:13:21 <triliyn> hmm
14:13:23 <hpc> Const has a valid return
14:13:30 <hpc> er... derp
14:13:35 <hpc> Const has neither actually
14:13:43 <ReinH> Hmm no.
14:13:46 <triliyn> hah, I didn't even notice that
14:13:46 <haasn> mm_freak: but is it associative? :)
14:13:51 <triliyn> Of course Const has no extract
14:13:58 <mm_freak> haasn: "associative"?
14:13:59 <johnw> right
14:14:08 <haasn> mm_freak: dup . dup = fmap dup . dup
14:14:24 <ReinH> fmap dup dup
14:14:32 <jle`> dup dup
14:14:33 <haasn> fmap fmap fmap dup dup
14:14:37 <ReinH> right
14:14:48 <jle`> i think mine is wrong
14:14:58 <beaky> if monads are extremely useful in programming, what are arrows useful for
14:14:59 <jle`> triliyn: tuples
14:15:01 <mm_freak> jle`: yours is a type error
14:15:06 <jle`> :t dup
14:15:07 <lambdabot> Not in scope: `dup'
14:15:13 <mm_freak> oh, no
14:15:17 <mm_freak> there is the reader monad of course =)
14:15:29 <jle`> beaky: in programming :P
14:15:31 <triliyn> jle`: tuples don't have return either, do they? return 5 :: (Int, String)
14:15:37 <johnw> Const isn't even a Monad, derp
14:15:40 <jle`> triliyn: oh yeah
14:15:42 <mm_freak> :t let dup :: IO a -> IO (IO a); dup = return in dup dup
14:15:43 <lambdabot>     Couldn't match expected type `IO a0'
14:15:43 <lambdabot>                 with actual type `IO a1 -> IO (IO a1)'
14:15:43 <lambdabot>     In the first argument of `dup', namely `dup'
14:15:50 <haasn> > return 5 :: (String, Int)
14:15:51 <lambdabot>  No instance for (GHC.Base.Monad ((,) GHC.Base.String))
14:15:52 <lambdabot>    arising from a use of `GHC.Base.return'
14:15:52 <lambdabot>  Possible fix:
14:15:52 <lambdabot>    add an instance declaration for
14:15:52 <lambdabot>    (GHC.Base.Monad ((,) GHC.Base.String))
14:15:58 <haasn> aaw, why not?
14:15:58 <mm_freak> still wrong =)
14:16:08 <mm_freak> :t let dup :: IO a -> IO (IO a); dup = return in fmap dup dup
14:16:09 <lambdabot> IO a -> IO (IO (IO a))
14:16:19 <ReinH> what do I win? :)
14:16:25 <mm_freak> nothing =)
14:16:29 <haasn> > runWriter (return 5) :: (Int, String)
14:16:30 <lambdabot>  (5,"")
14:16:31 <ReinH> Deal.
14:16:31 <johnw> http://stackoverflow.com/questions/16551734/can-a-monad-be-a-comonad
14:16:31 <triliyn> haasn: you can't invent a string from nothing
14:16:35 <haasn> triliyn: ^
14:16:47 <ReinH> triliyn: sure I can. I get "" for free. :p
14:16:50 <haasn> triliyn: sure you can, "", "hello", "triliyn"
14:16:53 <triliyn> hmmm, I guess maybe Monoid m => Monad (,) m works
14:16:56 <mm_freak> triliyn: (,) ≃ Writer
14:16:56 <ReinH> Oh you mean in this case.
14:16:59 <haasn> triliyn: precisely
14:17:02 <beaky> I guess trees are comonads?
14:17:04 <mm_freak> triliyn: so yes, you can invent a string from nothing ;)
14:17:06 <mm_freak> it's called mempty =)
14:17:11 <triliyn> hehe, right
14:17:13 <haasn> I prefer "mm_freak"
14:17:20 <ReinH> beaky: Cofree [] is a rainbow tree
14:17:35 <ReinH> Cofree [] a ~ Tree a
14:17:36 <haasn> ReinH: rose tree?
14:17:39 <ReinH> rose tree
14:17:42 <ReinH> something with an "r"
14:17:44 <ReinH> stupid brain
14:17:45 <haasn> although I do like rainbows
14:17:59 <jle`> trees with non-null roots are comonads
14:18:08 <jle`> but if you have a BST or something then you're in trouble
14:18:28 <jle`> rainbow trees are a much better name
14:18:39 <beaky> how does haskell implement purely functional bsts isn't that hard to implement
14:18:48 <haasn> jle`: thankfully, those are free monads
14:18:57 <jle`> bsts are pretty easy to implement functionally
14:18:59 <asQuirreL> beaky: no, it's not...
14:18:59 <beaky> ditto for purely functional hashtables
14:19:01 <beaky> oh
14:19:02 <jle`> self-balancing bst's are trickier
14:19:08 <beaky> yes self-balancing bsts*
14:19:40 <jle`> beaky: you might be interested in http://www.amazon.com/Purely-Functional-Structures-Chris-Okasaki/dp/0521663504
14:19:53 <prooftechnique> brew info opam
14:20:05 <prooftechnique> Whoops, wrong window
14:20:17 <asQuirreL> beaky: I think Okasaki has a nice RB tree implementation
14:20:31 <companion_cube> without the removal operation
14:21:09 <beaky> i wonder why removal is so hard
14:21:39 <asQuirreL> beaky: but something like the randomised binary search tree might be a difficult to implement neatly, because you would have to carry around the state of the StdGen around
14:21:51 <jle`> asQuirreL: it wouldn't actaully be
14:21:57 <jle`> if you used unsafePerformIO
14:21:59 <jle`> and exported a pure interface
14:22:00 <asQuirreL> :|
14:22:17 <jle`> all of your interface functions would be pure
14:22:22 <asQuirreL> heh :P yes
14:22:27 <asQuirreL> but I would know I was being dirty
14:22:43 <jle`> but maybe your library users wouldn't :)
14:22:52 <jle`> but
14:23:07 <jle`> there are nice pure/referentially transparent randomized data algorithms
14:23:09 <jle`> data stuctures
14:23:16 <jle`> there is SkipList, which is in STM
14:23:25 <beaky> woah skiplists sound cool
14:23:26 <jle`> http://hackage.haskell.org/package/tskiplist
14:23:35 <beaky> cabal install tskiplist
14:23:37 <beaky> oops wrong window
14:23:43 <jle`> it's a concurrency-safe randomized data structure
14:23:49 <prooftechnique> Haha, it's an epidemic
14:24:20 <jle`> without any unsafe magic i think
14:24:44 <triliyn> jle`: isn't the ST monad a formalization of that idea?
14:25:44 <triliyn> I haven't used it, but it can construct objects (possibly mutating them) and then return them to pure code later
14:26:43 <mm_freak> "purely functional hash table"
14:26:56 <mm_freak> you mean like "dry water"…
14:27:08 <jle`> triliyn: yeah, that's probably a better way to do it with all the safety and no magic
14:27:39 <jle`> but you can't jump out of a ST monad and re-continue it later without keeping track of the explicit state.  but that isn't as big as a problem in real life
14:27:51 <prooftechnique> mm_freak: http://en.wikipedia.org/wiki/Dry_water
14:28:27 <mm_freak> alright, alright…  you mean like "composite primes"
14:28:41 <jle`> but yeah you can use ST to implement mutable and randomized data structures, if you are willing to stay inside it the entire time.  but that's definitely better than staying inside IO
14:28:42 <prooftechnique> Better :D
14:29:34 <mm_freak> prooftechnique: i could probably intuitionistically prove that that article is nonsense anyway =P
14:30:22 <prooftechnique> Them's fightin' conjectures
14:31:15 <mm_freak> i have a natural fondness for formal linguistics…  does that make me proud or sad?
14:32:19 <prooftechnique> Depends on the grammar in use
14:32:55 <asQuirreL> mm_freak: can you not be both?
14:37:56 <luvfp> prooftechnique: is there a way that gives a default show instance for all functions in the current module?
14:38:43 <luvfp> for example,  if you define func1 = 10 func2 = 20 is there a way to say as_string func1 == "func1"
14:39:16 <eacameron> is there a monad-based logging system out there? I looked at hslogger but it seems to be simply IO based
14:39:20 <prooftechnique> > show func1
14:39:21 <lambdabot>  Not in scope: `func1'
14:39:26 <ReinH> luvfp: still no :)
14:39:29 <prooftechnique> Nope
14:39:30 <ion> eacameron: Writer?
14:39:38 <luvfp> prooftechnique: i tried that already
14:39:57 <luvfp> ReinH:  :) now i phrased the question more carefully didnt I ?
14:40:02 <prooftechnique> I don't think we can do that kind of introspection
14:40:10 <prooftechnique> I also don't really see the use case
14:40:13 <eacameron> ion: I suppose that could work
14:40:24 <luvfp> then how does :browse work inghci ?
14:40:27 <jle`> eacameron: how about http://www.haskellforall.com/2014/02/streaming-logging.html ?
14:40:45 <luvfp> it is able to give me all the functions and types defined in the currently loaded module
14:40:50 <mm_freak> Writer is inefficient though
14:41:09 <nbl_> Hey =)
14:41:34 <geekosaur> luvfp: it can determine that from an interface file. it cannot reconstruct source from that file
14:41:52 <eacameron> jle`: neat! thanks for the link
14:42:04 <nbl_> I'm a begginer in haskell I love this language but I'm meeting difficult issue, I don't know the difference between guard and motif
14:42:10 <eacameron> I thought Writer actually could be used for streammed IO output
14:42:13 <prooftechnique> luvfp: I imagine there's something in the GHC API that lets you determine what's in scope along with some other information
14:42:22 <flebron> If F is a functor, and T is a type, F T -> T is called an F-algebra for T. What if we have a natural transformation F a -> a? Is this a "universal algebra" in some sense?
14:42:24 <prooftechnique> I don't really know, though
14:42:26 <eacameron> someone recently demonstrated it to me
14:42:33 <geekosaur> also that is only available at compile time. because of the way ghci works, it has access to compile time. a compiled program does not have access to compile time information, in fact at runtime there are no types
14:42:39 <jle`> nbl_: motif?
14:42:40 <prooftechnique> nbl_: motif?
14:42:58 <luvfp> geekosaur: so ghci can do it because it has compiled/interpreted  the file already ? hmm makes sense ..
14:43:08 <nbl_> I came bna
14:43:19 <nbl_> two seconds, I come back sorry =)
14:43:23 <luvfp> could there be some template haskell trick to do this?
14:43:25 * hackagebot linear-accelerate 0.1 - Instances to use linear vector spaces on accelerate backends  http://hackage.haskell.org/package/linear-accelerate-0.1 (EdwardKmett)
14:43:39 <geekosaur> it can do it because it's invoking the compiler immediately on stuff as needed
14:43:58 <geekosaur> so it's kinda a hybrid compile-time/run-time environment, and can introspect the compile time part
14:44:26 <prooftechnique> geekosaur: Is it the same technique used in stuff like ghc-mod?
14:44:31 <geekosaur> there *are* ways to do this at run time, via ghc-api (which ghci uses) or hint (a somewhat more convenient wrapper for many uses, but less capable than direct ghc-api)
14:44:33 <eacameron> jle` ion: this works: mapM_ putStrLn . execWriter $ forever (tell ["hello"])
14:44:41 <geekosaur> yes, that also uses ghc-api
14:44:44 <prooftechnique> Ah, so it is ghc-api
14:44:51 <prooftechnique> I thought so
14:46:02 <geekosaur> the downside is you've got the whole compiler in your program, effectively, and you're loading and interpreting stuff at runtime. ghc-api cannot tell you anything about the already compiled program though, to introspect "yourself" you need to load your program a second time via ghc=api
14:48:57 <mm_freak> flebron: "universal" = initial
14:49:26 <flebron> mm_freak: What is it good for?
14:49:58 <flebron> (I'm assuming bananas will be involved.)
14:50:08 <kadoban> How do instances work in modules?  If I import a module, do I always get all of the instances in it?  How about if I import only specific things, do I still get the instances?
14:50:27 <geekosaur> you get all instances, you cannot prevent this
14:50:39 <mm_freak> flebron: indeed…  it captures the notion of a recursive data structure, and an algebra morphism from every initial algebra is a fold (aka catamorphism)
14:50:51 <kadoban> Cool, thanks.  That was actually what I was hoping for in this case, although I could see where that could be a problem.
14:56:06 <davidthomas> eacameron: There's monad-logger
14:56:34 <davidthomas> http://hackage.haskell.org/package/monad-logger-0.3.4.1/docs/Control-Monad-Logger.html
14:56:54 <eacameron> davidthomas: now that's what I'm talking about!
14:56:55 <davidthomas> relies on some template haskell to get file and line info, for good and ill
14:57:10 <eacameron> heh, can that be disabled?
14:57:51 <davidthomas> eacameron: seems so, just using the ...N functions at the bottom there
14:58:51 <eacameron> davidthomas: oh, indeed. this is exactly what I was hoping for, thanks for the link
14:59:19 <davidthomas> eacameron: you're most welcome :)
15:00:04 <eacameron> davidthomas: and it's written by the venerable Snoyman, another plus ;)
15:01:15 <carter> byorgey: soooo no hacphi is likely?
15:01:17 <carter>  sadn
15:03:27 * hackagebot quadratic-irrational 0.0.5 - An implementation of quadratic irrationals  http://hackage.haskell.org/package/quadratic-irrational-0.0.5 (ion)
15:03:57 <Saizan> quick, someone give me some bit haskell record as printed by a default Show
15:04:04 <Saizan> *big
15:08:27 <edwardk> carter: clearly it is not incumbent upon me to try to organize another hac boston to slot in where hac phi has fallen
15:08:28 * hackagebot intervals 0.5 - Interval Arithmetic  http://hackage.haskell.org/package/intervals-0.5 (EdwardKmett)
15:08:33 <edwardk> er now =)
15:08:43 <carter> huh
15:08:50 <carter> i've not been to boston for a while too
15:08:56 <carter> yay
15:09:12 <carter> yoda grammar with double negation
15:09:56 <awestroke> Saizan: https://gist.github.com/awestroke/3cc0764fb1ad3717197e
15:11:49 <Saizan> awestroke: not that big, but will do, thanks!
15:12:00 <eacameron> does using Data.ByteString.Lazy introduce lazy IO into my program?
15:12:30 <Saizan> readFile or hGetContents from there do
15:13:05 <eacameron> Saizan: yikes! did not know that
15:13:30 <eacameron> how do they handle changes in the file during streaming?
15:13:35 <Welkin> eacameron, should have read LYAH
15:14:02 <eacameron> Welkin: I read most of it ... ;) I guess not this part
15:18:48 <Saizan> eacameron: well, they should still give you the contents that were there when you opened the file
15:19:12 <eacameron> Saizan: how can they if the file changes before a chunk is read?
15:19:52 <Saizan> eacameron: the OS caches the old version, afaiu
15:21:12 <c_wraith|N10> I don't think so
15:21:13 <c_wraith|N10> I think they get the file contents of a particular chunk when the do the read.
15:22:36 <c_wraith|N10> eacameron: do you understand how lazy IO works? If you do, these questions should all be easy to answer on your own.
15:26:05 <circ-user-G8fMG_> I was going though the golang tutorial, and it seems that Control.Concurrent.Chan doesn't have closable channels, and it doesn't have any way to select() on set of channels. Am I missing something?
15:26:24 <Saizan> there might be some differences between OSes/file systems, and also between modifications in the same process vs. different ones
15:29:41 <identity> circ-user-G8fMG_: As far as as I can see, you're not missing anything. But the stm package, namely TChan, has tryReadTChan which you could use to implement select
15:30:11 <c_wraith|N10> circ-user-G8fMG_: Chan is just one of many things you can build on the MVar primitive. They aren't closable because that's extra complexity when you could use in-band signaling. You can't multiplex reads because that's not something MVar makes easy.
15:30:29 <geekosaur> haskell uses lightweight threads instead of exposing select
15:31:32 <_ikke_> Is a functor a function that can 'iterate' over any type?
15:31:42 <_ikke_> function / type
15:32:52 <circ-user-G8fMG_> Alright, thanks everybody.
15:32:59 <c_wraith|N10> identity: no need for anything more complex than orElse and ready Chan. Remember that if something would block, it tries the next alternative in that transaction.
15:33:17 <c_wraith|N10> *readTChan
15:33:31 * hackagebot intervals 0.5.1 - Interval Arithmetic  http://hackage.haskell.org/package/intervals-0.5.1 (EdwardKmett)
15:35:13 <identity> c_wraith|N10: yeah I guess
15:35:16 <c_wraith|N10> circ-user-G8fMG_: by the way, if you want super heavyweight features, check out Communicating Haskell Processes. It's far more complete than go's channels, for something similar.
15:35:40 <circ-user-G8fMG_> CHP looks like a mess.
15:35:47 <awestroke> I want to use the FSNotify package to do things when files change. I want to do this at the same time as I serve HTTP connections. how would I structure my main? Should I use forkIO or can I do all of it in the same thread?
15:36:56 <d3lxa> I'm searching a very simple and similar package like map-reduce in haskell, would like to compare perfs with hadoop, any hint please? thx
15:39:13 <awestroke> nevermind, found https://github.com/ehamberg/fswatcher/blob/master/fswatcher.hs, it seems very close to what I had in mind
15:45:31 <ReinH> d3lxa: hadoop is a pretty large and complicated thing...
15:47:38 <d3lxa> ReinH: like this https://github.com/Julianporter/Haskell-Mapreduce it's just a monad simple implementation but it won't compile here
15:48:06 <ReinH> d3lxa: I'm just saying that any simple Haskell package is not going to compare fairly against hadoop
15:48:27 <ReinH> Hadoop involves a significant amount of infrastructure, etc
15:49:16 <d3lxa> yes I do know, but still I'm curious how it could be expressed in Haskell and how well it performs considering the difference
15:51:05 <d3lxa> I tried to compile it with cabal but "cabal: can't find source for Parallel/MapReduce in src," altough there was this folder right inside src
15:53:33 * hackagebot system-filepath 0.4.10 - High-level, byte-based file and directory path manipulations  http://hackage.haskell.org/package/system-filepath-0.4.10 (JohnMillikin)
15:58:23 <bahamas> if I install a newer version of cabal from the git repo, what's the best way to get rid of the old binary?
15:58:38 <bahamas> do I simply replace it with the new one, or do I uninstall the system cabal?
16:14:34 <sylvanica> Hmm, I have two "text" cabals installed, and when I compile it's trying to use the wrong one. Help? :(
16:19:04 <prooftechnique> bahamas: You can just delete the old binary, though it may already have been overwritten depending on how you built it
16:19:40 <bitemyapp> sylvanica: do you have a cabal file enforcing a particular version of Text?
16:19:55 <bitemyapp> sylvanica: are you using sandboxes? If so, do you have a global copy of Text installed? (it could be getting shadowed)
16:20:18 <bitemyapp> sylvanica: I generally use cabal sandboxes, but if you need to complete ghost the global environment, you could use hsenv.
16:20:22 <bitemyapp> completely*
16:20:44 <sylvanica> bitemyapp: I understood some of those words
16:21:09 <sylvanica> bitemyapp: I was following a guide / tutorial for intro Haskell grabbing site HTML
16:21:24 <sylvanica> bitemyapp: so I had to install some modules to get it to run
16:21:28 <bitemyapp> sylvanica: so, given that, I'm going to assume you were cabal install'ing into the global environ. That's not kosher.
16:21:38 <sylvanica> bitemyapp: yes I was
16:21:41 <bitemyapp> sylvanica: generally you want a one-off cabal sandbox for your project/experiment so installed packages don't conflict.
16:21:48 <bitemyapp> sylvanica: are you using Cabal 1.18?
16:21:59 <sylvanica> bitemyapp: 1.16
16:22:21 <SrPx> You guys should've linked me this much earlier: http://www.haskell.org/definition/haskell2010.pdf (:
16:22:28 <SrPx> This is great.
16:22:50 <bitemyapp> sylvanica: cabal update && cabal install cabal-install
16:23:09 <bitemyapp> sylvanica: then you should have 1.18, when you do, you'll have sandboxes. Then make a directory and cabal sandbox init.
16:23:20 <bitemyapp> sylvanica: http://coldwa.st/e/blog/2013-08-20-Cabal-sandbox.html
16:23:27 <bitemyapp> sylvanica: http://chromaticleaves.com/posts/cabal-sandbox-workflow.html
16:23:43 <sylvanica> bitemyapp: oh okay great! what do I do if I want to get rid of what I already installed?
16:23:57 <bitemyapp> sylvanica: ghc-pkg unregister, but be careful.
16:24:16 <sylvanica> bitemyapp: it won't let me do that
16:24:16 <bitemyapp> sylvanica: Cabal really just handles resolving dependencies and fetching stuff, the underlying "package management" is ghc-pkg.
16:24:28 <bitemyapp> sylvanica: just...leave the stuff you have installed alone for now.
16:24:35 <bitemyapp> sylvanica: get 1.18 installed and a sandbox rolling first.
16:24:49 <sylvanica> bitemyapp: it's downloading :D thanks for the help
16:24:51 <bitemyapp> SrPx: stuff like that jives with some but not all people.
16:24:53 <bitemyapp> sylvanica: np
16:25:45 <bahamas> prooftechnique: it wasn't overwritten. that's what I asked. the new binary was put in ~/.cabal/bin, while the old one is in /usr/bin/
16:26:37 <awestroke> bahamas: dpkg -l | grep cabal
16:26:40 <prooftechnique> Ah. Well, you can just rearrange your path, then
16:26:46 <prooftechnique> That's what I usually do
16:27:10 <prooftechnique> Just in case I have to nuke my .cabal, I'd like to have a working cabal install kicking around
16:27:38 <akurilin> Random question: do most people use 4 spaces in Haskell code? All the books I've looked at so far seem to use 4.
16:27:53 <bahamas> awestroke: ii  cabal-install                                  0.14.0-2
16:28:09 <bitemyapp> akurilin: I don't even think about it because I'm an Emacs user. I hit tab until it goes where I want it :P
16:28:17 <bitemyapp> akurilin: also, fuck coyotes.
16:28:23 <akurilin> bitemyapp: did you hit one?
16:28:27 <prooftechnique> akurilin: I think it's technically supposed to be 8 spaces, but I usually see 2 or 4
16:28:37 <bitemyapp> akurilin: no, but the fuckers didn't let me sleep a wink while I was camping. I was tempted to grab my mosin and go coyote hunting.
16:28:40 <bitemyapp> howling all around me.
16:28:54 <akurilin> prooftechnique: will I be burned at a stake if I use 2? I like my 80 col limits :(
16:29:00 <bitemyapp> akurilin: no.
16:29:07 <akurilin> prooftechnique: but I also want to be as kosher as possible.
16:29:09 <awestroke> bahamas: either put $HOME/.cabal/bin first in PATH as prooftechnique suggested or run apt-get remove cabal-install, which I have no idea what it will do but should be easily reversible with apt-get install
16:29:11 <prooftechnique> Haha, I use two, so I won't be lighting my torch any time soon
16:29:18 <bitemyapp> akurilin: I think people care more about having nice alignments between LHS/RHS than actual amount of spaces.
16:29:18 <mgsloan> prooftechnique: Well, that's how many spaces a tab character takes up (probably to discourage them from use)
16:29:47 <akurilin> I want to make sure that my code fits properly on a teletype ASR 33.
16:29:52 <mgsloan> (well, rounded to the nearest column where modulo 8 == 0)
16:30:03 <akurilin> bitemyapp, prooftechnique ok :)
16:30:31 <bitemyapp> akurilin: I usually stick to max widths of whatever half of a 1920x1080p monitor is.
16:30:36 <prooftechnique> bitemyapp: Have you tried structured-haskell-mode?
16:30:40 <bitemyapp> ~120 probably.
16:30:49 <bitemyapp> prooftechnique: no. I didn't like paredit when I hacked Clojure either.
16:30:52 <bahamas> awestroke: well, doing apt-get remove still leaves me the new binary in ~/.cabal. I'll go with putting the new binary first in PATH. it's the least disruptive solution
16:30:55 <identity> It looks like the guy who was behind light table just invented pure functional programming
16:30:57 <bitemyapp> prooftechnique: but I <3 Chris Done so I might give it a shot anyway.
16:31:07 <prooftechnique> bitemyapp: It's awesome, promise
16:31:14 <bitemyapp> bahamas: I usually symlink it.
16:31:17 <bitemyapp> prooftechnique: okay, you convinced me.
16:31:18 <bitemyapp> bugger.
16:31:21 <prooftechnique> As long as you're okay with Chris's particular formatting preferences
16:31:24 <identity> He's talking like simple data types and maps, folds, immutability are revolutionary concepts he just invented.
16:31:29 <bitemyapp> prooftechnique: I don't care up to a point.
16:31:35 <prooftechnique> identity: Link?
16:31:36 <bitemyapp> prooftechnique: I *do* care about how rigid it makes my editor though.
16:32:06 <akurilin> bitemyapp: well if you shave off 40 cols from each side you can fit 3 of those suckers on one screen.
16:32:08 <akurilin> great victory
16:32:10 <prooftechnique> bitemyapp: It's not particularly rigid. It just makes good style easier and adds some conveniences
16:32:21 <identity> prooftechnique: don't have copy paste capabilities on my terminal, but try youtubing "aurora strangeloop 2013"
16:32:46 <identity> well, it is from 2013 and he syas in a blog post that a lot has changed, but it basically looks like functional programming using an obnoxious UI
16:32:53 <identity> without any real well-defined semantics
16:33:27 <prooftechnique> I like whenever he does something "new" because it's usually just a rediscovery of something Haskell-y :D
16:33:30 <stephenmac7> How does deriving work for monads?
16:33:33 <prooftechnique> Light Table's pretty neat, though
16:34:09 <identity> Light table looked neat, yes. But it didn't really go anywhere, did it? IT didn't gain widespread acceptance or usage, did it?
16:34:18 <identity> I kind of feel like it fell of the eart. I never hear about it.
16:34:35 <prooftechnique> I dunno. I sometimes play with it. It's still updated fairly frequently
16:34:43 <prooftechnique> There's even a Haskell plugin, now
16:34:59 <identity> I guess the fact that you just "play with it" says a bit, though
16:34:59 <akurilin> bitemyapp: lol @ coyotes
16:35:00 <identity> heh
16:35:04 <prooftechnique> Though it doesn't do much
16:35:15 <prooftechnique> identity: Yeah. To put it lightly :D
16:35:17 <bitemyapp> akurilin: seriously fuck coyotes.
16:35:25 <bitemyapp> akurilin: Katya and I nearly went on expedition.
16:35:48 <akurilin> Is that your gun's name?
16:35:57 <prooftechnique> identity: I think the more interesting thing out of the Clojure folks is Om, but that's mainly just because the demos are cute
16:36:08 <bitemyapp> akurilin: Katya is my mosin.
16:36:20 <akurilin> You're assuming I know what a mosin is.
16:36:26 <akurilin> Is that like a functor?
16:36:27 <prooftechnique> Mosin Nagant
16:36:27 <akurilin> :P
16:36:33 <prooftechnique> bang bang
16:36:39 <bitemyapp> akurilin: russian rifle. Fascist smasher.
16:36:48 <bitemyapp> akurilin: used from late 19th century through WWII
16:37:08 <akurilin> Fair enough.
16:37:16 <identity> prooftechnique: I came upon that youtube video through a blog post of his that was about 'reinventing' programming, that wasn't all the stupid and made sense for the most part
16:37:47 <identity> But he seems to be ignoring that the tools he's creating are only as good and extensive as people have made them using the normal, down in the dirt 'broken' way of programming
16:38:08 <identity> i.e. he's probably writing javascript to make that aurora stuff work.
16:38:37 <identity> Oh. He said "functional" so he knows he's doing functional programming.
16:39:05 <prooftechnique> Isn't that how you do it? That's why I write all this functional Forth
16:41:31 <prooftechnique> I mainly want to see lamdu happen
16:42:22 * mgsloan too
16:42:32 <saml_> @google what is lamdu
16:42:33 <lambdabot> http://www.gomapper.com/travel/where-is/lam-du-located.html
16:42:33 <lambdabot> Title: Where is Lam Du in Vietnam located?
16:42:43 <prooftechnique> https://github.com/Peaker/lamdu
16:42:56 <aspidites> does using a Free Monad force the excessive use of TypeClasses?
16:42:56 <saml_> you want ide?
16:43:19 <saml_> i can't imagine haskell without typeclasses
16:43:20 <mgsloan> A little bit concerned that lamdu is fighting too many battles at once (new code representation, new version control, new language, new type system, new UI system, etc etc)
16:43:31 <aspidites> i'm using free-game and looking at the documentation i'm having trouble understanding why certain things are implemented as a typeclass rather than functions themselves, perhaps in a record
16:43:38 <mgsloan> But all the ideas in there are really awesome :)
16:44:02 <aspidites> for instance -> https://hackage.haskell.org/package/free-game-1.0.4/docs/FreeGame.html
16:44:07 <mgsloan> And if I understand correctly, some of the novel type system ideas actually require a structural format for the code
16:44:12 <saml_> if ghc is restful api service, then there will be loads of node.js ide
16:44:15 <prooftechnique> aspidites: I'll be thrilled if any of those ideas can be poached, honestly :D
16:44:19 <prooftechnique> er, mgsloan
16:44:20 <aspidites> why are circle, polygon, etc members of  typeclass?
16:44:36 <aspidites> prooftechnique: haha. felt important for a second
16:45:02 <mgsloan> prooftechnique: Indeed!  It's a great research project.  I'd love to try to pitch in some day
16:45:15 <Hafydd> Nobody's going to make me program using something akin to a PowerPoint presentation.
16:45:20 <prooftechnique> If I can get it to build, I may do the same
16:46:07 <saml_> aspidites, circle :: Double -> p ()
16:50:55 <bahamas> bitemyapp: I did symlink it, but if remove ~/.cabal/ I won't have any cabal binary. changing PATH is the best solution
16:52:41 <bitemyapp> bahamas: cool.
16:54:10 <aspidites> saml_: right, i got that, but circle is implemented as a member of a typeclass, not a type constructor
16:55:16 <aspidites> so in the absense of a rectangle method, you have to write a function such as (Monad m, Picture2D m) => m ()
16:55:41 <aspidites> rectangle :: (Monad m, Picture2D m) => m ()*
16:55:54 <aspidites> or the less generic rectangle :: Frame ()
16:56:55 <aspidites> the latter i had to find out through experimentation (eg. rectangle :: Game () type checks, but doesn't make sense)
17:26:11 <Algebr> Help with trivial thing. I'm in ghci, say I have let x = readFile "someFile.txt". Then doing x >>= (\a -> lines a), and that doesn't work, also tried various variations of that. Help appreciated.
17:26:46 <khyperia> what exactly doesn't work, Algebr?
17:27:46 <khyperia> Also, note that ghci is a bit special and ocasionally confusing about IO. That might have something to do with it.
17:27:50 <Algebr> I keep getting `can't match IO String with with [Char]`, which yes, I understand that my readFile result is an IO String.
17:27:54 <khyperia> ah
17:27:59 <Algebr> That's why I'm using bind
17:28:05 <pavonia> (\a -> lines a) doesn't have result type IO something
17:28:11 <khyperia> you probably want "
17:28:13 <khyperia> argh
17:28:22 <khyperia> you probably want "fmap (\a -> lines a) x"
17:28:34 <khyperia> because bind's argument needs to return the monad
17:28:40 <ion> (\a -> lines a) = lines
17:28:44 * hackagebot csv-conduit 0.6.2 - A flexible, fast, conduit-based CSV parser library for Haskell.  http://hackage.haskell.org/package/csv-conduit-0.6.2 (OzgunAtaman)
17:28:49 <khyperia> ... I am a dumb, ion.
17:29:13 <bitemyapp> Algebr: I cover a caveat of lifting functions against IO here: http://bitemyapp.com/posts/2014-03-24-monads-bind-join-actions.html
17:29:35 <bitemyapp> Algebr: as long as you're lifting/fmap'ing pure functions against the IO blah, you're fine, but if you nest side effects, read my post.
17:30:10 <Algebr> Okay, will read the post, but relating to my problem at hand, I need to use fmap?
17:30:19 <khyperia> you don't *need* to
17:30:27 <bitemyapp> Algebr: or liftM, or bind it, sure.
17:30:45 <khyperia> you *could* use: x >> (\a -> return (lines a)), but that's a silly redundant thing that you shouldn't use
17:30:51 <khyperia> err, that >> is a >>=
17:31:12 <bitemyapp> Algebr: liftM and fmap are for your purposes identical, but come from two different instances of IO (Monad vs. Functor)
17:31:24 <bitemyapp> Algebr: regardless you have to lift your function into being able to touch what's inside the IO a
17:32:02 <Algebr> bitemyapp: much appreciated, thank you
17:32:30 <aspidites> bookmarked
17:32:35 <bitemyapp> Algebr: the caveat I cover in my post is, "I lifted a function and it didn't execute my side effect - why?"
17:32:46 <Algebr> So basically once something has IO associated with it, it can't ever be rid of it?
17:32:47 <khyperia> basically, Algebr, look at the type signature of (>>=), specifically, the second argument: it returns an IO a, not an a (which is where your `IO String` vs. `String` error comes from)
17:32:54 <khyperia> Exactly, Algebr
17:33:38 <bitemyapp> Algebr: technically you could do something dirty to make it go away, but you don't want that.
17:33:45 * hackagebot Win32-errors 0.1 - Alternative error handling for Win32 foreign calls  http://hackage.haskell.org/package/Win32-errors-0.1 (MichaelSteele)
17:33:57 <bitemyapp> Algebr: if you want to have more your code be pure, you just separate logic from side-effecting actions.
17:41:09 <Axman6> Anyone familliar with Control.Monad.Indexed from category-extras? I don't understand the point of the indexing parameters... though I think they would be useful for my code
17:41:21 <indigo> Yay, Happstack's website is back!
17:41:51 <Axman6> actually, this is really cool, I see how this works now!
17:42:42 <blipped> I know it's sloppy not to do so, but what is the reason imports have to come at the start of a file?
17:42:54 <hpc> blipped: do they?
17:43:03 <dolio> They do.
17:43:18 <hpc> weird
17:43:26 <Algebr> FWIW, my original logic worked fine in a regular main, it was just messing up in ghci. I was trying to emulate my workflow in python shell.
17:43:28 <hpc> probably copying the report
17:43:38 <hpc> which might have put that restriction to help compiler authors?
17:44:02 <Axman6> makes writing anything that needs to build a module graph easier I guess
17:44:41 <hpc> i appreciate it coming from perl's module system
17:44:48 <hpc> where you can put imports inside functions
17:45:23 <dolio> There's one big reason I can think of.
17:45:25 <blipped> I mean, yah it makes code much cleaner looking.
17:45:29 <dolio> Type classes must be global.
17:45:40 <blipped> That makes sense.
17:45:47 <heatsink> Is this about modules being at the top of the file, or being at global scope?
17:45:48 <Axman6> hpc: ew
17:45:50 <heatsink> imports
17:45:50 <dolio> So, even if you had 'local' imports, they would have global effect.
17:46:15 <hpc> i would figure imports lower in the file would have an effect on code above it
17:46:35 <hpc> foo = intercalate "," nums
17:46:39 <hpc> import Data.List
17:47:04 <Axman6> I quite like Ada's module system, modules can be generic and you create concrete instances by passing descriminants at import and giving it a new name:
17:47:16 <mmmm_> If anyone has experience using the alex monad, how do you fold over the input with "alexMonadScan"?
17:47:42 <h_noob> ok I'm wanting to calculate frames/sec, a calculation involving 100 and a NominalDiffTime
17:47:52 <h_noob> how do I convert this thing??  argh
17:48:22 <Axman6> generic \n type Datum is private; package Queue is ... end package;   with Queue; use Queue; procedure Foo is type NaturalQueue is new Queue(Natural); ...
17:48:49 <dolio> h_noob: NominalDiffTime is a Real.
17:48:54 <dolio> You can turn it into a Rational.
17:49:31 <Axman6> though interestingly I believe it's designed in a way such that the implementation of all instances is the same, reducing the amount of code produced a la C++
17:49:35 <h_noob> I have this:  putStrLn (show (count / (toRational dt)))
17:49:43 <dolio> It's also a RealFrac, so you can floor, ceil, round, truncate.
17:49:52 <h_noob> where count is a float.  I guess I can change count to a rational
17:51:31 <Rarrikins> @let isInteger = (floor x :: Integer) == ceil x
17:51:31 <lambdabot>  .L.hs:144:37: Not in scope: `ceil'
17:51:36 <Rarrikins> @let isInteger = (floor x :: Integer) == ceiling x
17:51:36 <lambdabot>  .L.hs:144:14:
17:51:37 <lambdabot>      No instance for (RealFrac Expr) arising from a use of `floor'
17:51:37 <lambdabot>      Possible fix: add an instance declaration for (RealFrac Expr)
17:51:37 <lambdabot>      In the first argument of `(==)', namely `(floor x :: Integer)'
17:51:37 <lambdabot>      In the expression: (floor x :: Integer) == ceiling x
17:51:48 <Rarrikins> @let isInteger x = (floor x :: Integer) == ceiling x
17:51:49 <lambdabot>  Defined.
17:51:52 <dolio> h_noob: You can use realToFrac to turn it into a Float.
17:52:37 <Rarrikins> > isInteger (0/0)
17:52:38 <lambdabot>  True
17:52:53 <Rarrikins> Bad Haskell!
17:53:16 <heatsink> mmmm_: Personally I don't think alex's wrappers are that useful.  I use the basic interface
17:53:25 <Welkin> > isInteger (1/0)
17:53:26 <lambdabot>  True
17:53:47 * hackagebot intervals 0.5.1.1 - Interval Arithmetic  http://hackage.haskell.org/package/intervals-0.5.1.1 (EdwardKmett)
17:53:53 <Rarrikins> > map isInteger [0.0, 0.1..1.0]
17:53:55 <lambdabot>  [True,False,False,False,False,False,False,False,False,False,True]
17:53:55 <h_noob> ah ok that did it.  realToFrac, thx.
17:54:34 <Welkin> > fracToReal (1/0)
17:54:35 <lambdabot>  Not in scope: `fracToReal'
17:54:41 <haasn> > floor (0/0)
17:54:41 <lambdabot>  -269653970229347386159395778618353710042696546841345985910145121736599013708...
17:54:43 <haasn> > floor (1/0)
17:54:44 <lambdabot>  1797693134862315907729305190789024733617976978942306572734300811577326758055...
17:54:46 <haasn> cute
17:54:46 <Welkin> hah
17:54:54 <haasn> not sure who to blame here :)
17:55:11 <hpc> extra credit if you can produce the rest of the number with pen and paper
17:55:18 <Welkin> > floor 1
17:55:19 <lambdabot>  1
17:55:24 <Welkin> > floor 0
17:55:25 <lambdabot>  0
17:55:31 <dolio> I know who to blame.
17:55:41 <dolio> > decodeFloat (0/0)
17:55:42 <lambdabot>  (-6755399441055744,972)
17:55:43 <ion> IEEE
17:55:48 <hpc> hahaha
17:55:50 <dolio> > decodeFloat (1/0)
17:55:51 <lambdabot>  can't find file: L.hs
17:55:56 <heatsink> what
17:55:57 <dolio> wat
17:56:01 <Rarrikins> It lost L.hs
17:56:06 <dolio> > decodeFloat (1/0)
17:56:07 <lambdabot>  (4503599627370496,972)
17:56:10 <hpc> that happens sometimes
17:56:12 <Rarrikins> Don't decodeFloat (1/0)!
17:56:14 <Rarrikins> Bug!
17:56:31 <hpc> lambdabot's mueval takes a stock L.hs and adds extra @lets to it before running
17:56:34 <hpc> it's rather goofy
17:57:39 * heatsink found this Library Writer's Guide to Shortcut Fusion paper
17:58:02 <dolio> > uncurry encodeFloat (-6755399441055744,972)
17:58:03 <lambdabot>  -Infinity
17:58:03 <heatsink> It describes two ways to do loop fusion.  It leaves out the (key -> value) way though.
17:58:23 <heatsink> I don't suppose anyone has compared that to the other approaches?
18:00:46 <edwardk> dolio: you've found infinity, the ultrafinitists will be pleased ;)
18:01:48 <mmmm_> heatsink: I've come to realise that I would rather just use parsec
18:01:52 <heatsink> > encodeFloat 4503599627370497 972
18:01:53 <lambdabot>  Infinity
18:01:58 <haasn> > decodeFloat (-1 / 0)
18:01:59 <lambdabot>  (-4503599627370496,972)
18:02:03 <mmmm_> but I'm reimplementing some ocaml into haskell and the model is lex -> yacc
18:02:18 <haasn> now I'm confused
18:02:32 <haasn> why is encodeFloat (-6755399441055744,972) not NaN?
18:02:33 <johnw> mmmm_: there is always alex and happy
18:02:38 <heatsink> > let f x = encodeFloat (450359962737049 + x) 972 in f 0 - f 0
18:02:39 <lambdabot>  0.0
18:02:43 <heatsink> > let f x = encodeFloat (450359962737049 + x) 972 in f 1000000 - f 0
18:02:44 <lambdabot>  3.9916806190694396e298
18:02:59 <heatsink> There's a number greater than infinity!
18:03:05 <mmmm_> That's what (i'm trying) to use
18:03:12 <Welkin> infinity is NaN
18:03:41 <heatsink> mmmm_: Do you want alex to make a list of tokens?
18:03:47 <c_wraith|N10> > 0/0
18:03:48 <lambdabot>  NaN
18:03:49 <mmmm_> I need line no. information as well
18:04:10 <mmmm_> so I went with the monad but I honestly don't have any real idea of what's going on
18:04:16 <Welkin> > 1/0
18:04:17 <lambdabot>  Infinity
18:04:27 <Welkin> > 0/0
18:04:28 <lambdabot>  NaN
18:04:40 <Axman6> not really...
18:04:50 <heatsink> mmmm_, I use alexScan, described here: http://www.haskell.org/alex/doc/html/basic-api.html
18:05:14 <heatsink> alexScan does one step of scanning
18:05:31 <heatsink> You'd write a function that calls alexScan repeatedly to process the entire input
18:06:49 <blipped> why would it say "ambigious" occurence of something when I have an import as qualified?
18:06:56 <blipped> sorry, new to Haskell.
18:07:03 <blipped> Trying to use foldr
18:07:19 <DarkTiger> Multiple imports with the same qualified name?
18:07:28 <heatsink> The error message should tell you where two of the names come from
18:07:45 <dwcook> blipped, a common mistake is to import something with a binding name that already exists in the Prelude, such as lookup from Data.Map
18:07:56 <blipped> yah, comes from Prelude or Data.Map, but I have import qualified Data.Map as Map
18:08:21 <haasn> blipped: it would help a lot if you pasted the code that is causing you problems.
18:08:24 <Axman6> and you're using foldr just by itself to get the list version?
18:08:27 <dwcook> blipped, odd that it should do that then. What does the error message actually say? (Use lpaste as mentioned in the topic)
18:09:40 <Welkin> what is with haskell-mode?
18:09:50 <Welkin> indent is set to 4, but it still only indents 2
18:10:20 <Enigmagic> 2 is the best.
18:10:35 <Welkin> I don't want 2
18:10:43 <Axman6> I like 4 but am starting to like 2
18:10:58 <mmmm_> ok I needed replicateM heatsink
18:11:03 <mmmm_> thanks for your help
18:11:06 <blipped> farking china internet blocking lpaste. I'll play with it a bit.
18:11:57 <heatsink> ok
18:12:47 <Rarrikins> blipped: Tor with a bridge FTW.
18:13:08 <blipped> They knock out tor nodes quickly around here unfortunately.
18:13:51 <Rarrikins> Ahh
18:14:27 <mmmm_> :q
18:14:41 <blipped> Yah, I can watch pirated movies on sites partially owned by the Chinese government, but damn if I want to paste code somewhere...
18:15:17 <blipped> And my VPN is no longer working and I don't want to throw money at another one.
18:15:38 <Rarrikins> We need some sort of bot where you can paste code to it and it gives a URL.
18:16:02 <blipped> I'm guessing 99% of the people here have no problem though.
18:16:32 <blipped> A bot would be cool though.
18:19:43 <DarkTiger> Rarrikins: Freenode flood limit
18:20:33 <Rarrikins> Hmm.
18:20:59 <Axman6> who runs lpaste?
18:21:19 <Rarrikins> It'd have to be a DCC thing.
18:23:51 * hackagebot monad-unify 0.2.1 - Generic first-order unification  http://hackage.haskell.org/package/monad-unify-0.2.1 (PhilFreeman)
18:27:49 <prooftechnique> Axman6: I think it's chrisdone
18:27:58 <prooftechnique> er, Chris Done
18:28:45 <prooftechnique> Axman6: https://github.com/chrisdone/lpaste
18:28:48 <Axman6> right, that sounds right
18:28:51 * hackagebot purescript 0.4.10 - PureScript Programming Language Compiler  http://hackage.haskell.org/package/purescript-0.4.10 (PhilFreeman)
18:31:48 <Welkin> there are dozens, if not hundreds, of code pasting sites
18:34:33 <Welkin> the indenting in haskell-mode is ridiculous
18:34:44 <no-n> what's haskell mode?
18:34:47 <no-n> emacs?
18:35:00 <Welkin> yes
18:44:50 <prooftechnique> Welkin: Which indent style are you using?
18:45:00 <Welkin> haskell-indent
18:45:05 <prooftechnique> Also, you might like structured-haskell-mode
18:46:07 <prooftechnique> Welkin: Also, I find that haskell-indentation's a little more sensible than haskell-indent
18:54:06 <Welkin> I still don't understand why it only indents by 2 when it is set to 4 in the editing mode...
18:57:18 <no-n> @hoogle maybeToMonad
18:57:18 <lambdabot> No results found
18:57:37 <no-n> :t maybeToMonad
18:57:38 <lambdabot> Not in scope: `maybeToMonad'
18:58:15 <Axman6> no-n: what type are you looking for?
18:58:36 <no-n> Axman6: maybeToMonad :: (MonadPlus m) => Maybe a -> m a
18:58:48 <Axman6> @hoogle (MonadPlus m) => Maybe a -> m a
18:58:49 <lambdabot> Control.Monad mfilter :: MonadPlus m => (a -> Bool) -> m a -> m a
18:58:49 <lambdabot> Control.Monad mplus :: MonadPlus m => m a -> m a -> m a
18:58:49 <lambdabot> Control.Monad msum :: MonadPlus m => [m a] -> m a
18:58:52 <no-n> I don't need it I just saw it in an exercise and wondered if it was actually in the lib
18:58:55 <Axman6> hmm
18:59:05 <Axman6> I don't believe so
19:01:06 <Rufflewind> has anyone seen a good article that evaluates the performance of various garbage collectors in different languages (incl. ghc)?
19:03:15 <hpc> i vaguely remember having seen one that compared ghc's to a bunch of JVM GC styles
19:03:17 <edwardk> Rufflewind: it is very hard to compare them across languages. different pressures, different user patterns, different needs, threadng models, etc.
19:04:54 <Rufflewind> yea i figured it wouldn't be easy :\
19:11:27 <camlorn> So, I'm interested in learning haskell with the specific goal of writing a compiler.  But I'm on windows.  Can anyone tell me what I need to get llvm working?
19:11:48 <camlorn> And for the curious: two things I want to do: write a compiler and learn haskell. So why not combine them?
19:12:12 <Averell> because one is already hard enough
19:12:25 <Rarrikins> camlorn: Is your compiler using LLVM?
19:12:29 <camlorn> No.
19:12:34 <camlorn> I installed the haskell platform.
19:12:42 <Rarrikins> camlorn: You shouldn't need LLVM then.
19:12:47 <camlorn> O.
19:12:57 <camlorn> Thought you meant my haskell compiler.
19:13:01 <Rarrikins> camlorn: The Haskell Platform will be good enough.
19:13:09 <camlorn> I want to use llvm, as it's got a big tutorial on how to use llvm for compiler development.
19:13:09 <Rarrikins> camlorn: No, your produced compiler.
19:13:16 <Rarrikins> camlorn: Ahh, I see.
19:13:43 <camlorn> And as for difficulty, this falls into hobby and-well, you learn from the failure, too.
19:14:27 <Welkin> write a brainfuck compiler
19:14:35 <Rufflewind> LLVM should have windows binaries by now
19:14:52 <camlorn> heh. Brainfuck might be an interesting place to start.
19:15:11 <camlorn> I've built LLVM successfully with the microsoft toolchain myself.
19:15:17 <Welkin> that is a common coding challenge question
19:15:20 <Welkin> or interview question
19:15:28 <Rufflewind> Welkin: really?
19:15:42 <Welkin> brainfuck is just 8 opcodes
19:16:10 <Rarrikins> Write a BF -> Haskell converter that optimizes for readability.
19:16:10 <camlorn> The best I can find via Google is: install minGW (but will this break the haskell platform, which appears to have its own?), build llvm, use cabal and play with the options until things work.
19:16:40 <camlorn> And yes, Brainfuck is a very good place to start.  I'm doing this for my personal learning, not anything else.
19:17:16 <Rufflewind> camlorn: you'll need haskell bindings for llvm though
19:17:23 <Axman6> http://hackage.haskell.org/package/llvm-tf-3.0.1
19:17:34 <camlorn> Rufflewind: That's what I can't quite get to work.
19:17:46 <Rufflewind> ah
19:17:57 <Rufflewind> what error are you getting then?
19:18:19 <camlorn> I've successfully built my own llvm package, and am currently beginning to use it to autogenerate a C++ library for me via Python.
19:19:10 <camlorn> Llvm-general-pure installs, obviously.  Llvm-general doesn't like my version, because it's too new.  Llvm complains about, as I recall, buildinfo.windows.in being missing.
19:19:40 <camlorn> I do not believe Llvm-general is going to work with my current llvm anyway, as it's built with MSVC++ 2013, and (unless i'm mistaken), haskell is using MinGW.
19:20:02 <camlorn> Configuring llvm-base-3.2.0.2...
19:20:03 <camlorn> setup.exe: llvm.buildinfo.windows.in: does not exist
19:22:24 <Rufflewind> http://projects.haskell.org/pipermail/haskell-llvm/2012-August/000265.html
19:23:07 <Rufflewind> according to that, seems it's a bug of some kind; you may have to "manually write" the *.windows.in file (with an existing one as a template)
19:24:24 <camlorn> I'll have to try this.
19:25:08 <Rufflewind> if you do find something that works, might be a good idea to submit a ticket for it too :P seems like the llvm bindings weren't really tested all that much on windows
19:25:16 <camlorn> I'm not surprised.
19:25:39 <camlorn> Llvm is fine on windows, as far as I'm aware, but the higher level tools aren't.  Llvm itself isn't much tested on windows.
19:26:13 <camlorn> Ironically, installing Llvm looks like it's going to teach me about Haskell in and of itself
19:26:35 <Welkin> why does anyone even try to develop on windows, unless they are developing windows-specific software?
19:27:05 <camlorn> Does anyone know how llvm compares to llvm-general?  The tutorial i found uses llvm-general, which might be a better option just for that, but...meh. I can probably manage.
19:27:24 <Welkin> the easiest solution is to run linux
19:27:28 <camlorn> In my case? Because I know windows well.  Because accessibility on Linux sucks a lot.
19:27:55 <Welkin> either remotely, in a VM, or installed locally
19:28:40 <camlorn> perhaps. I'm not sold on it.  I'm visually impaired. The accessibility of that particular setup sucks,and in this case that doesn't matter; I'd like it to compile on windows anyway.
19:29:30 <camlorn> I'd have to run it as a vm, ssh in, set up an ftp client and download/upload from the vm.  I do not want to do this, but will if it comes to it.  I can work with the setup, but would prefer not to.
19:32:35 <Welkin> you could just run it on ec2
19:44:00 * hackagebot purescript 0.4.10.1 - PureScript Programming Language Compiler  http://hackage.haskell.org/package/purescript-0.4.10.1 (PhilFreeman)
19:53:38 <copumpkin> does cabal have any support for downloading/extracting a tarball as part of its build process, or do I need to do that myself?
19:54:13 <heatsink> There's cabal unpack
19:54:23 <copumpkin> I don't mean a haskell one
19:54:39 <copumpkin> I need some external code in my own package before I can build it
19:54:42 <prooftechnique> It's also cabal get in recent versions
19:54:52 <Clint> seems like a bad idea to depend on network connectivity
19:54:59 <copumpkin> Clint: doesn't all of cabal do that anyway?
19:55:23 <heatsink> Why wouldn't you put all the data in the package source?
19:55:26 <prooftechnique> copumpkin: What about cabal sandbox add-source? Or are you looking for something in Setup.hs?
19:55:42 <copumpkin> heatsink: it's a lot of unrelated C code from a module I'm binding to
19:55:48 <Clint> copumpkin: not inherently
19:56:00 <heatsink> copumpkin: Is it a separate C library?
19:56:11 <copumpkin> yes, but I explicitly don't want to link to the system version
19:56:26 <copumpkin> it's also bulky and annoying
19:56:55 <heatsink> I just put a tarball in the package and make Setup.hs call its configure/make scripts
19:57:09 <copumpkin> the tarball is 29M :(
19:57:43 <copumpkin> I guess I should just do that or something
19:57:50 <prooftechnique> copumpkin: This might be a job for shake :)
19:58:11 <copumpkin> I want this to be pleasant and easy for end users to install :P
19:58:28 <copumpkin> I think I'll write a little script that scrubs the unnecessary crap out of the tarball then includes it
19:58:32 <copumpkin> and include the script in my repo
19:59:39 <no-n> gonna continue reading "All About Monads" today.
19:59:55 <no-n> I spent a long time thinking about sheep last night :|
20:55:31 <Javran> could someone explain what is "applicative side effect"?
20:56:50 <ion> A bad term
20:57:32 <shachaf> I don't think it's really worse than "monad side effect" (though the word "side" probably shouldn't be there).
20:57:53 <ion> indeed
20:59:11 <Javran> I heard that in video "Lenses, Folds, and Traversals"..
21:00:10 <ion> What was meant was probably just “applicative effect”.
21:01:07 <Javran> ion: so what's that?
21:01:21 <Javran> :t <*>
21:01:22 <lambdabot> parse error on input `<*>'
21:01:31 <ion> The “effect” of the [] Applicative instance can be seen here:
21:01:35 <artyomkazak> :t (<*>)
21:01:35 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
21:01:39 <Javran> :t (<*>)
21:01:40 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
21:01:42 <ion> > [f, g, h] <*> [1, 2, 3]
21:01:43 <lambdabot>  No instance for (Debug.SimpleReflect.Expr.FromExpr b0)
21:01:43 <lambdabot>    arising from a use of `e_1123'
21:01:43 <lambdabot>  The type variable `b0' is ambiguous
21:01:43 <lambdabot>  Possible fix: add a type signature that fixes these type variable(s)
21:01:43 <lambdabot>  Note: there are several potential instances:
21:01:53 <ion> > [f, g, h :: Expr -> Expr] <*> [1, 2, 3]
21:01:54 <lambdabot>  [f 1,f 2,f 3,g 1,g 2,g 3,h 1,h 2,h 3]
21:03:48 <ion> The “effect” of the Maybe Applicative is a Nothing value on either side short-circuiting the computation and just returning Nothing.
21:03:50 <Javran> > getZipList (ZipList [f, g, h :: Expr -> Expr] <*> ZipList [1, 2, 3])
21:03:51 <lambdabot>  [f 1,g 2,h 3]
21:04:33 <ion> The “effect” of the IO Applicative is the generation of a new IO action that upon execution does both parameter IO actions in sequence and applies the result from the first to the result of the second.
21:06:18 <Mikicacarica> MUST SEE ---> http://interesting-animals.com/kitten-meets-hedgehog-2
21:07:38 <Welkin> I wonder if that is a virus/scam/shock site
21:08:54 <StoneCypher> probably
21:09:07 <prooftechnique> It is not, surprisingly
21:09:31 <prooftechnique> It's a link to this video: https://www.youtube.com/watch?feature=player_embedded&v=D36JUfE1oYk
21:10:00 <prooftechnique> Kitten meets Hedgehog, accompanied by a breathy acoustic rendition of "You've Got a Friend In Me"
21:11:07 <Javran> just make an example to myself: "(++) <$> getLine <*> getLine", so that will perform IO in sequence and in return the first line and second line read in get glued together
21:11:44 <Javran> so this is the "effect" of IO applicative, right?
21:12:24 <ion> With IO the meaning gets a bit more ambiguous because people also talk about IO effects and that means what happens when the IO action is finally executed.
21:13:19 <oscarvarto> Hi! I’m trying to install https://github.com/ermine-language/ermine but getting ld: library not found for -lHStransformers-0.3.0.0-ghc7.6.3, what am I missing?
21:13:48 <prooftechnique> oscarvarto: What does ghc-pkg list transformers say?
21:14:39 <oscarvarto> prooftechnique: /usr/local/Cellar/ghc/7.6.3/lib/ghc-7.6.3/package.conf.d
21:14:40 <oscarvarto>    transformers-0.3.0.0
21:15:10 <prooftechnique> Hmm
21:15:29 <oscarvarto> prooftechnique: /Users/oscarvarto/.ghc/x86_64-darwin-7.6.3/package.conf.d
21:15:36 <oscarvarto> and that’s all
21:16:01 <prooftechnique> Depending on activity, you might be able to get an answer in #ermine, but I'll see if I can think of something
21:16:28 <Javran> > ((-) <*> (* 10)) 20
21:16:29 <lambdabot>  -180
21:16:34 <oscarvarto> prooftechnique: I asked in #ermine, but no activity
21:16:56 <Javran> and this is a reader applicative saying "20 - (20 * 10)"?
21:19:05 <prooftechnique> oscarvarto: Are you building with the suggested changes to your cabal config?
21:19:15 <oscarvarto> yes
21:19:35 <prooftechnique> I seem to remember some sort of issue with dynamic linking on OS X, so you might try switching executable-dynamic to false
21:20:08 <prooftechnique> I'm building it now, just to check
21:20:21 <oscarvarto> prooftechnique: OK. Thanks. I’m going to try
21:21:51 <oscarvarto> nope
21:22:57 <prooftechnique> Can you paste the full error log?
21:22:58 <prooftechnique> @paste
21:22:59 <lambdabot> Haskell pastebin: http://lpaste.net/
21:24:26 <oscarvarto> http://lpaste.net/101966
21:26:42 <prooftechnique> Hmm
21:26:48 <prooftechnique> That one built for me
21:26:57 <prooftechnique> Can you run ghc-pkg check and let me know what it says?
21:27:23 <prooftechnique> Warnings about haddock interfaces can be safely ignored
21:28:10 <oscarvarto> only warnings
21:29:10 <oscarvarto> (about haddock-interfaces & haddock-html)
21:29:22 <prooftechnique> Well, that's all I can think of. Hmm.
21:29:45 <oscarvarto> prooftechnique: Thanks a lot for helping me. I am really grateful.
21:29:52 <oscarvarto> For your time
21:30:04 <prooftechnique> No worries. Definitely check in #ermine tomorrow
21:30:15 <Welkin> does anyone own time?
21:30:18 <prooftechnique> edwardk is usually around and he'll know more about it than I do
21:30:21 <Welkin> time is not something you can give or take
21:30:43 <edwardk> ?
21:30:49 <prooftechnique> Oh, look at that
21:31:01 <Welkin> like a prairie dog
21:31:21 <prooftechnique> edwardk: oscarvarto is getting an unusual error when trying to build ermine
21:31:29 <prooftechnique> http://lpaste.net/101966
21:31:33 <prooftechnique> Seen anything like it?
21:31:49 <prooftechnique> I couldn't reproduce it
21:32:09 <edwardk> what ghc version is that 7.8rc2?
21:32:25 <prooftechnique> oscarvarto is on 7.6.3, I'm on RC2
21:32:41 <edwardk> i've never seen a problem with transformers-compat
21:32:48 <edwardk> that is a new one on me
21:32:48 <prooftechnique> Hmm
21:33:53 <edwardk> transformers-compat is used by lens an a bunch of other packages as a dependency, so if it had a systemic problem i'd think i'd have heard about it.
21:34:35 <edwardk> strange. if you blow away ~/.ghc/* an reinstall does the problem go away?
21:34:49 <edwardk> gah, d. i ned to take this keyboard in
21:34:55 <oscarvarto> edwardk: Thanks for helping complete newbies
21:35:16 <oscarvarto> edwardk: I can try removing ~/.ghc/*
21:35:41 <oscarvarto> edwardk: By the way, I am a Scala programmer looking for something better in Ermine
21:35:48 <oscarvarto> tied to the JVM now
21:35:49 <Clint> is there a shared transformers lib on your system?
21:36:26 <edwardk> anyways, the new ermine compiler is coming along, but it isn't anywhere near production ready. it is a work in progress. the older ermine-language/ermine-legacy compiler actually works and we use it in production
21:36:54 <edwardk> that said the new typechecker is much sexier than the old one
21:37:13 <edwardk> but getting out of scala was one of the many motivations for writing ermine ;)
21:38:19 <edwardk> oscarvarto: did you see the video runar captured of the talk we gave at boston haskell pretty much the day after we were able to open source the code?
21:38:43 <edwardk> http://www.youtube.com/watch?v=QCvXlOCBe5A
21:38:45 <oscarvarto> edwardk: No I still haven’t
21:39:02 <edwardk> that may give a better sense of what it can do and can't do so far
21:39:39 <edwardk> but if you want to actualy play with it, the ermine-legacy compiler will give you a usable repl as shown in that video
21:40:06 <oscarvarto> edwardk: Right now I am feeling a little depressed, because my current employer thinks scalaz is “too hipster”
21:40:12 <edwardk> an is in scala, using sbt, which is a bit easier to get going with if you already have a scala background
21:40:15 <edwardk> hah
21:40:28 <oscarvarto> leading to “unreadable code"
21:40:35 <edwardk> sounds like a good excuse to find a new employer ;)
21:41:35 <edwardk> i'll say i find some parts of scalaz lead to hard to read code, but i find it hard to blame that on a library when the reasons mostly fall on the language we had to write it in ;)
21:42:06 <oscarvarto> edwardk: I live in Mexico, and have little professional coding experience. Currently working as a freelancer. So, job offers are scarce
21:42:15 <edwardk> fair enough
21:42:47 <oscarvarto> But I am wanting more real functional programming
21:42:56 <edwardk> just don't let your day job dictate what tools you learn in your off time and you'll be fine
21:43:17 <oscarvarto> edwardk: Thanks for the advice. I’ll keep that in mind.
21:44:03 <oscarvarto> Well, my wife is waiting for me. Good bye :-)
21:44:12 <edwardk> later. take care
21:44:22 <edwardk> i'll try to watch #ermine more closely
21:44:33 <oscarvarto> Thanks.
21:45:52 <itzurabhi> Is Haskell function argument s are passed around like move semantics from C++11 ?
21:49:23 <dwcook> itzurabhi, nothing so low level. At the language level, Haskell doesn't care about memory like C++ does
21:49:23 <itzurabhi> dwcook: then how does it avoid copies?
21:50:15 <dwcook> itzurabhi, one part of the answer is that that's part of the beauty of pure data structures – You can, for example, at the implementation level, pass a reference to a structure around without any fear that it will be mutated elsewhere
21:51:26 <dwcook> More specifically, let bindings and things that translate to them (which the compiler will in many cases do for you) let you share some pieces of data across multiple places in an expression
21:51:51 <dwcook> let foo = bar in baz foo (quux foo)
21:52:30 <dwcook> That's not the only way to get sharing but it's one way
21:52:51 <dwcook> I'm not the best person to talk to about the implementation of a Haskell compiler but I can tell you a fair amount about the language semantics themselves
21:53:51 <dwcook> s/pure data structures/immutable data structures/
21:55:26 <itzurabhi> dwcook: thanks :)
21:56:22 <dwcook> No problem
22:17:58 <Aetherspawn> actually
22:18:10 <Aetherspawn> there's this optimization you can do related to sharing
22:18:34 <Aetherspawn> say you have a heap of ADTs like data Bool = True | False or data Ord = LT | EQ | GT
22:19:08 <Aetherspawn> you can produce a heap of functions like true :: Bool and false :: Bool and then replace all constructors with those functions (since they don't take arguments)
22:19:55 <Aetherspawn> then if you /must/ box them, you can simply take the shared copy and as an extension you can check if they are equal using only pointer comparisons and not value comparisons /ot
22:21:00 <copumpkin> Aetherspawn: ?
22:21:03 <dolio> Those aren't functions. And nullary constructors are shared anyway.
22:21:04 <copumpkin> True is a singleton
22:21:44 <Aetherspawn> correct
22:21:56 <copumpkin> so what does true = True buy you?
22:22:25 <Aetherspawn> are you saying GHC already performs that, or are you talking about specialization?
22:22:44 <Aetherspawn> what if you have Eq a -> a -> a -> b
22:22:46 <copumpkin> I'm saying there's only ever one True in memory, and same with all your other examples
22:23:01 <copumpkin> and in fact, GHC does weirder things like pointer tagging
22:23:02 <Aetherspawn> and you call that function with True and False
22:23:15 <Aetherspawn> are you saying it already doesn't heap allocate a new True/False ?
22:23:23 <copumpkin> yes
22:23:43 <Aetherspawn> I remember reading about it in some ticket on the trac
22:23:51 <Aetherspawn> does it do that for all singleton values or just hardcoded ones?
22:24:01 <copumpkin> should be for all of them
22:24:07 <copumpkin> same with Nothing
22:24:14 <dolio> What does "hardcoded" mean?
22:24:34 <Aetherspawn> like, just some set list of
22:29:20 * hackagebot clifford 0.1.0.14 - A Clifford algebra library  http://hackage.haskell.org/package/clifford-0.1.0.14 (spacekitteh)
22:29:58 <copumpkin> Aetherspawn: very little is built into GHC
22:30:25 <Aetherspawn> well, certain things are kind of awkwardly built in
22:30:31 <Aetherspawn> like hte Bool/Int primop story
22:32:31 <bitemyapp> Sounds like there should be a GHC FAQ.
22:32:40 <bitemyapp> I bet there already is one.
22:42:59 <no-n> @src (>=>)
22:42:59 <lambdabot> Source not found. I've seen penguins that can type better than that.
22:43:11 <no-n> @src (Maybe) (>=>)
22:43:11 <lambdabot> Source not found. My brain just exploded
22:46:10 <jle`> look what you went and did.
22:50:13 <prsteele> I have an algorithm describing a dynamic program (largely unimportant). In Python it runs in < 1 second with nearly zero memory, but the Haskell version eats all memory. I'm probably building thunks. What is the best way to try to figure out where I am doing so?
22:51:30 <Cale> prsteele: Probably to post your code on lpaste and let us at it ;)
22:52:16 <Cale> prsteele: If you're writing a recursive loop, look for variables which are not pattern matched on until after the whole process finishes
22:53:09 <prsteele> Cale: http://lpaste.net/101969 if you're actually interested
22:54:04 <Cale> Ah, !! is a horrible operation
22:54:41 <prsteele> Cale: yes, I know it is linear time. My goal was to memoize all other entries, but maybe it really is just that
22:55:04 <prsteele> Cale: quadtratic _time_ shouldn't have eaten 8 gigs of ram though
22:55:05 <Cale> xs !! n takes O(n) steps to reduce, and if you're walking through a list which is iteratively defined, it doesn't necessarily force the list elements as it goes, only the cons cells
22:56:19 <Cale> Well, how far are you running this list along? For some initial values, the iterates of the Collatz map get very large before they start falling again
22:56:35 <prsteele> Cale: 1000000, although it crashes around 10000.
22:57:37 <prsteele> Cale: I understand why !! is bad, I really should be using something more clever (binary tree, etc) but what I'm really interested in is 1) identifying where thunks are accumulating and 2) figuring out the best way to eliminate them
22:57:46 <prsteele> Cale: 2) is probably just a seq somewhere
22:58:14 <prsteele> Cale: and, 3), tools to generically approach (1)
22:58:26 <Cale> Well, what's happening is that !! is going to request a much larger, as yet uncomputed element of the collatz list there, many times over
22:59:17 <Cale> and as that happens, you're going to be allocating lots of memory for cons cells and for the unevaluated expressions at each position
23:02:20 <prsteele> Cale: hm. yes. Evaluating to 1000000 will hit... 1570824736. 1570824736 bytes is over a gig, so even a few bytes per item would kill it if it is being really lazy
23:04:58 <prsteele> Cale: thanks
23:06:02 <Cale> You might prefer to use a fixed size array as a memo table. Data.MemoCombinators is a really nice library for that kind of thing
23:06:32 <prsteele> Cale: I'll look into it.
23:07:45 <jle`> does fpcomplete really only have containers-0.4.2.1 ?
23:07:50 <Cale> http://lpaste.net/101970 -- here's with an unbounded memo table
23:07:56 <johnw> the standard stackage uses GHC 7.4.2
23:08:07 <Cale> The allocation is a bit bad, because you end up memoising many very large entries which are unlikely to show up again
23:08:09 <johnw> or rather, the default environment I should say
23:08:13 <jle`> johnw: ah i see
23:09:30 <Cale> http://lpaste.net/101970 -- and here it is using a bounded memo table
23:11:05 <Cale> (ah, guess there's no annotation-specific links now)
23:11:15 <Cale> prsteele: ^^
23:11:55 <Cale> I decided to give 0 for col 1, because usually that's where you stop iterating :)
23:12:12 <Cale> So the result may be off by one from your code
23:13:14 <Cale> prsteele: The important thing to note here is that col' is defined in terms of col, and col is defined as a memoisation combinator applied to col'
23:14:27 <bitemyapp> edwardk: you suggested morton order for my n-to-1 dimensional problem, which looks like it'll work, but what about turning a relative ordering into something indexable?
23:15:09 <prsteele> Cale: (one second, trying before looking at your link ;)
23:17:45 <Cale> My fixed range version takes 0.75s
23:17:52 <Cale> (on my machine at least)
23:20:17 <prsteele> Cale: ya, this works. Still slower than Python by a factor of 2-3, but a massive improvement over system lock
23:21:14 <prsteele> Cale: heh. Just realized you added on a max without me mentioning it
23:21:31 <Cale> Yes
23:21:37 <Cale> I know what you're up to :)
23:21:51 <prsteele> Cale: ya. I'm working back through them in Haskell.
23:23:18 <Cale> Unfortunately it doesn't seem to parallelise very well
23:23:34 <Cale> Well, maybe it'd be possible to compute the maximum somehow better
23:24:08 <Cale> btw, you're compiling with -O2 ?
23:24:38 <prsteele> Cale: no, only because I decided to learn cabal and I haven't bothered reading how to flip 02
23:24:49 <Cale> oh, that's very important
23:25:02 <Cale> performance results are pretty meaningless if you don't have -O2 on
23:25:08 <Cale> Or at least -O
23:26:02 <Cale> Perhaps  ghc-options: -O2
23:26:29 <Cale> cabal might automatically turn on -O at least
23:28:32 <prsteele> Cale: it appears -O is standard
23:28:52 <Cale> Well, that's good :)
23:39:44 <bitemyapp> *rubs forehead* so why does Conduit use Strings for host/path stuff?
23:40:05 <bitemyapp> It means I can't really use Network.HTTP.Types properly
23:40:10 <bitemyapp> all of its stuff is Text and ByteString.
23:40:23 <bitemyapp> sorry, http-conduit specifically.
23:40:55 <bitemyapp> conal: ahoy. Thanks for that Haskell meetup I caught in Feb right before I left the bay area.
23:50:16 <orzo> hey, cant recall.. What was it called when the compiler takes what looks like multiple passes and actually does it as one pass, due to laziness?
23:50:29 <orzo> something reduction
23:50:31 <orzo> i think
23:50:46 <athan> :t (->)
23:50:47 <lambdabot> parse error on input `->'
23:50:58 <athan> :t ((->) Int)
23:50:59 <lambdabot> parse error on input `->'
23:51:14 <athan> :t ($)
23:51:15 <lambdabot> (a -> b) -> a -> b
23:51:29 <athan> :t ($ 1)
23:51:30 <lambdabot> Num a => (a -> b) -> b
23:52:00 <athan> is this because `$` is right associative?
23:52:15 <bitemyapp> $ is made of sparkles and awesome.
23:52:15 <athan> :t (($) 1)
23:52:16 <lambdabot> Num (a -> b) => a -> b
23:52:19 <bitemyapp> but I should probably use it less.
23:52:34 <athan> WOAH
23:52:44 <orzo> When map f . map g is done as map (f . g), what is that called?
23:52:50 <athan> Look at that typeclass instance...
23:52:58 <no-n> wut
23:53:15 <athan> ooh!
23:53:16 <crisptrutski> @orzo stream fusion
23:53:16 <lambdabot> Unknown command, try @list
23:53:19 <no-n> numbers can take parameters?
23:53:41 <no-n> oh, it's multiplication, isn't it?
23:53:46 <trillioneyes> no-n: if you write a Num instance for functions, they can
23:53:52 <athan> no-n: a function to equate to a number
23:54:00 <no-n> > (2 :: (a -> b)) 5
23:54:01 <lambdabot>  No instance for (GHC.Num.Num (a -> b1))
23:54:01 <lambdabot>    arising from the literal `2'
23:54:01 <lambdabot>  Possible fix:
23:54:01 <lambdabot>    add an instance declaration for (GHC.Num.Num (a -> b1))
23:54:07 <trillioneyes> Generally people don't do that
23:54:24 <trillioneyes> But there is a potential instance that is at least halfway sensible
23:54:37 <athan> orzo: a functor that obeys category laws?
23:55:07 <trillioneyes> instance Num b => Num (a -> b) where fromInteger = const; (f + g) x = f x + g x
23:55:12 <trillioneyes> And so on
23:55:15 <athan> ($) 1 (*)
23:55:19 <athan> :t ($) 1 (*)
23:55:20 <lambdabot> (Num ((a -> a -> a) -> b), Num a) => b
23:55:28 <athan> :t (($) 1) (*)
23:55:28 <lambdabot> (Num ((a -> a -> a) -> b), Num a) => b
23:55:30 <orzo> hm, i mean, due to laziness map f . map g is actually one pass.  There's a name for that that i am trying to use and cant recall
23:55:35 <trillioneyes> I think some of the Num functions can't be implemented for functions though
23:55:40 <athan> woah
23:55:44 <bitemyapp> orzo: due to fusion you mean?
23:55:47 <orzo> fusion
23:55:50 <orzo> thanks
23:55:52 <trillioneyes> (Num in general is kind of weird)
23:55:53 <bitemyapp> np
23:55:58 <bitemyapp> but laziness does help with fusion, IIR
23:56:00 <orzo> is there a longer name?
23:56:00 <bitemyapp> IIRC*
23:56:03 <orzo>  a particular type of fusion
23:56:10 <bitemyapp> orzo: stream fusion?
23:56:16 * bitemyapp shrug
23:56:19 <athan> wouldn't you have to explicitly allow fusion to the compiler to make it happen?
23:56:46 <bitemyapp> I haven't even touched the fusion stuff. I just know it's "out there" somewhere.
23:56:54 <crisptrutski> http://research.microsoft.com/en-us/um/people/simonpj/papers/ndp/haskell-beats-C.pdf
23:56:59 <athan> I need to learn ranked types
23:57:02 <jle`> nah
23:57:21 <bitemyapp> nah
23:57:25 <athan> Is a comonad like a type monad or something?
23:57:35 <bitemyapp> athan: it's the dual of a monad.
23:57:37 <trillioneyes> It's more like a reverse monad
23:57:43 <athan> okay
23:57:46 <athan> like the inverse?
23:57:51 <jle`> athan: monad has return :: a -> m a
23:57:53 <trillioneyes> Monads let you put things IN and collapse multiple contexts into one
23:57:54 <bitemyapp> athan: "co" prefix usually means dual. a dual in category theory means all the arrows/morphisms are flipped around.
23:57:57 <athan> if monads were elements of a group or something?
23:57:57 <jle`> athan: comonad as extract :: m a -> a
23:58:05 <trillioneyes> Comonads let oyu take things OUT and extend a single context into two
23:58:10 <jle`> monad has join :: m (m a) -> m a
23:58:11 <johnw> athan: no, not like the inverse at all in that sense
23:58:13 <athan> like an isomorphism
23:58:29 <athan> ahhhh okay
23:58:36 <jle`> comonad has duplicate :: m a -> m (m a)
23:58:42 <athan> would the monad still retain past state?
23:58:47 <jle`> what monad
23:58:47 <bitemyapp> athan: don't throw out a bunch of nouns, you'll confuse yourself. stick to the types.
23:58:49 <trillioneyes> The "co" prefix normally talks about categorical reversal
23:58:54 <athan> I could see an IO comonad still cause statefulness on it's return
23:59:00 <athan> or something along those lines
23:59:05 <jle`> IO cannot really be a comonad
23:59:07 <bitemyapp> athan: monads don't have anything to do with statefulness.
23:59:08 <jle`> there is no IO a -> a
23:59:14 <trillioneyes> Take the category theory concept of a monad and reverse all the arrows/morphisms
23:59:22 <bitemyapp> athan: IO doesn't even real. Don't bother.
23:59:28 <bitemyapp> you get a functor and a monad for IO, that's about it.
23:59:30 <athan> bitemyapp: I was loosing it lol
23:59:42 <jle`> athan: can you think of a few comonads?
23:59:43 <trillioneyes> (Which is why we have to reverse the join arrow rather than the bind one)
23:59:49 <athan> trillioneyes: aahhhhhh okay
