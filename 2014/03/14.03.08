00:00:05 <gamegoblin> I know that, but I don't know it's implications in terms of my problem
00:02:22 <liyang> When the main thread exits, forked threads are killed.
00:02:34 <gamegoblin> ahhhhh
00:02:41 <gamegoblin> How do I wait for them to finish?
00:03:21 <gamegoblin> nevermind, found it on Stack overflow
00:03:24 <liyang> You can probably use http://hackage.haskell.org/package/async-2.0.1.5/docs/Control-Concurrent-Async.html#v:mapConcurrently
00:03:24 <gamegoblin> thanks for pointing that out though
00:03:47 <liyang> (Or Async in general.)
00:05:00 <johnw> gamegoblin: parallel-io
00:05:10 <johnw> it does exactly what you're asking for
00:05:24 <liyang> If the StackOverflow answer says to use MVars, sure you could do that, but it's not particularly composable.
00:05:44 <liyang> gamegoblin: in fact, read this: http://chimera.labs.oreilly.com/books/1230000000929/ch11.html
00:11:03 <jle`> :t await
00:11:04 <lambdabot> Not in scope: `await'
00:12:41 * hackagebot haskell-names 0.3.2.7 - Name resolution library for Haskell  http://hackage.haskell.org/package/haskell-names-0.3.2.7 (RomanCheplyaka)
00:18:14 <arboris> what is the recommended way to allocate n bytes of memory in haskell, call a foreign function and retain the result as a ByteString?
00:18:42 <johnw> alloca the memory, and then pack the result into a ByteString
00:18:55 <johnw> there may be a way to do it without copying
00:19:02 <johnw> by malloc'ing and unsafe packing into a ByteString
00:19:15 <arboris> johnw, I was looking for a way without copying
00:19:15 <johnw> i'm just not sure if teh ByteString will know to call free...
00:19:39 <milfjord> arboris: why?
00:19:42 <arboris> johnw, precisely I am searching for a way to get safe deallocation
00:20:09 <johnw> ah, unsafePackCString says "This value will have no finalizer associated to it, and will not be garbage collected by Haskell."
00:20:10 <milfjord> I'd do it with copying first, then check if it's a bottleneck
00:20:29 <johnw> you could create a data type that carries aruond a ByteString and a ForeignPtr Char
00:20:40 <arboris> milfjord: in this case just as a matter of principle, I am just curious if it can be done without copying
00:20:40 <johnw> oh!
00:20:51 <johnw> unsafePackMallocCString
00:20:57 <johnw> hmmm... but you need to have the String beforehand...
00:21:26 <johnw> arboris: unsafePackCStringFinalizer looks promising
00:21:33 <johnw> "Construct a ByteString given a Ptr Word8 to a buffer, a length, and an IO action representing a finalizer."
00:21:38 <milfjord> arboris: yes, with unsafePackMallocCString
00:21:58 <johnw> milfjord: he wants to pre-allocate the CString buffer
00:22:03 <jle`> ffi is such a strange world
00:22:05 <milfjord> johnw: and?
00:22:28 <johnw> oh, duh
00:22:31 <johnw> milfjord is right
00:22:46 <milfjord> the tricky part is making the code exception safe
00:23:31 <arboris> unsafePackMallocCString has O(n) complexity
00:23:38 <arboris> then i might aswell copy it.
00:23:55 <johnw> arboris: unsafePackCStringFinalizer
00:24:06 <arboris> what it the finalizer I would pass to unsafePackCStringFinalizer
00:24:12 <johnw> free
00:24:13 <arboris> *is
00:24:20 <johnw> closed over the Ptr
00:24:20 <milfjord> arboris: oops, I mean the ...Len variant
00:24:31 <liyang> I think you're supposed to use unsafePackMallocCStringLen
00:25:08 <johnw> ptr <- mallocBytes 1024; unsafePackCStringFinalizer ptr 1024 (free ptr)
00:25:10 <arboris> liyang, but that is O(n), so that kind of defeats the purpose
00:26:39 <arboris> johnw, thanks i was not sure how the finalizers worked
00:26:40 <liyang> The O(n) is due to having to figure out the length of the NUL-terminated CString (i.e. calling strlen()). The *Len variants lets you specify the length. (Also what milfjord said.)
00:27:05 <milfjord> doc bug?
00:27:26 <arboris> liyang, well at least in the documentation even for unsafePackMallocCStringLen there is O(n) complexity
00:27:31 <johnw> my docs don't show unsafePackMallocCStringLen
00:27:37 <liyang> I think that's a documentation bug. Look at the source...
00:28:01 <milfjord> http://hackage.haskell.org/package/bytestring-0.10.4.0/docs/Data-ByteString-Unsafe.html#v:unsafePackMallocCStringLen
00:28:17 <johnw> huh.. I was looking at 0.10.2.0
00:28:20 <arboris> liyang, oh ok thanks
00:29:12 <arboris> i had a guess that you could use newForeignPtr, and the source confirms
00:29:13 <liyang> Yeah, I didn't notice the O(n) in the unsafePackMallocCStringLen documentation. But unlike the sans-Len variants, it doesn't call c_strlen.
00:29:57 <johnw> arboris: unsafePackMallocCStringLen does almost exactly what the code I pasted above does, it just knows which finalizer to call, and does the casting for you
00:30:47 <fly2web> prelude>   ---> *Main    then how can i changen to prelude> from *Main>
00:32:29 <skeuomorf> http://www.haskell.org/crypto returns a 404 o_O
00:32:39 <jle`> oops
00:32:44 <arboris> johnw: yes, I agree.
00:34:18 <jle`> http://www.haskell.org/ghc/docs/latest/html/users_guide/type-class-extensions.html#functional-dependencies
00:34:27 <jle`> "There should be more documentation, but there isn't.  Yell if you need it."
00:34:29 <jle`> lol
00:34:46 <skeuomorf> heh
00:46:03 <arboris> Wouldn't it actually be better to just use mallocForeignPtrBytes, since that's what the ByteString Constructor expects?
00:47:09 <arboris> and then pass the ForeignPtr to the foreign function with withForeignPtr
00:47:16 <makalu> why does lens depend on aeson, text, vector, utf8-string etc? Not every program needs these libraries.
00:48:03 <Feuerbach> makalu: because its author has decided to do so. I don't like it either
00:48:29 <Feuerbach> his argument is that those packages are in the platform anyway
00:49:17 <makalu> the haskell platform?
00:49:30 <Feuerbach> yes
00:49:41 <makalu> but not anyone uses haskell platform
00:49:46 <makalu> everyone*
00:49:50 <Feuerbach> indeed
00:50:18 <makalu> I don't know how cabal + ghc works but if lens depends on those, they will be compiled into my program as well?
00:50:31 <makalu> so I will have a 20mb binary :)?
00:50:43 <Feuerbach> no
00:50:56 <Feuerbach> the linker decides what to include
00:53:55 <bennofs> makalu: if you just want lenses, you could use lens-family. Lens-family uses the same underlying abstraction of lens, so lenses written for 'lens' also work for 'lens-family' and vice-versa. 'lens-family' does not provide so much other stuff as 'lens', though
00:54:19 <makalu> bennofs: thanks. I was secretly hoping there was an alternative.
00:54:38 <bennofs> makalu: also, 'lens-family' doesn't have Prisms or Isos
00:56:50 <makalu> maybe if there was a binary package manager for haskell things it would be less of a nuisance to have so many dependencies
00:57:30 <bennofs> makalu: there is nix
00:57:57 <bennofs> http://nixos.org/nix . It provides binary packages for most of hackage
00:58:29 <makalu> I'm aware of nix but does it have sandboxes?
00:58:45 <bennofs> makalu: what do you mean by "sandboxes"?
00:58:59 <makalu> like cabal sandboxes
00:59:51 <bennofs> makalu: If you have a default.nix for your project, you can use 'nix-shell' to create an environment that only contains your project's dependencies. Bonus points: Packages are shared, you only need to compile each package once (or download if you use binary packages) even if you use it in multiple projects
01:00:14 <supki> makalu: otherwise you'd end up with a dozen of packages of orphan instances
01:00:32 <supki> I'd rather depend on the stuff in platform
01:01:21 <makalu> why are orphan instances bad?
01:01:50 <johnw> I wouldn't call them bad
01:03:26 <supki> makalu: they make libraries non-composable
01:03:40 <makalu> what does that mean?
01:03:41 <supki> you can't use two libraries that define the same instance
01:03:53 <johnw> i only use them in applications, not libraries
01:03:54 <supki> you don't have any way to choose one of them
01:22:28 <no-n> :t void
01:22:29 <lambdabot> Functor f => f a -> f ()
01:22:55 <no-n> @src void
01:22:56 <lambdabot> Source not found. That's something I cannot allow to happen.
01:24:59 <milfjord_> :t fmap (const ())
01:25:00 <lambdabot> Functor f => f a -> f ()
01:32:51 * hackagebot cantor 0.1 - Analiza Java source code  http://hackage.haskell.org/package/cantor-0.1 (klangner)
01:33:09 <jle`> which there was a Monad void!
01:33:14 <jle`> but perhaps all will be okay after 7.10
01:33:34 <jle`> s/which/wish
01:43:54 <jle`> for now i just >>= return ()
01:46:09 <jle`> >>
01:46:21 <jle`> (is there a better way?)
01:46:35 <hc> void $ ...? perhaps
01:46:42 <jle`> hc: for Monad m
01:46:47 <jle`> without adding a Functor m constraint as well
01:59:04 <jle`> Num is no longer a superclass of Bits
01:59:10 <jle`> :/
02:00:47 <jle`> hm it wasn't for a while
02:00:57 <jle`> (2012)
02:01:02 <jle`> i wonde rwhy this library has been relying on it
02:01:10 <jle`> i must have grabbed an out of date repository
02:01:21 <jle`> but it's the one linked on the hackage page :/
02:10:12 <troydm> how do i output Data.Text to stdout?
02:11:21 <Rembane> troydm: What happens when you use print?
02:11:26 <ClaudiusMaximus> troydm: http://www.haskell.org/hoogle/?hoogle=putStr%20%2Btext
02:12:37 <troydm> ClaudiusMaximus: ahh ic , thx
02:12:55 * hackagebot newtype-generics 0.4 - A typeclass and set of functions for working with newtypes, with generics support.  http://hackage.haskell.org/package/newtype-generics-0.4 (jcristovao)
02:15:06 <jle`> @hoogle Text -> IO (
02:15:06 <lambdabot> Parse error:
02:15:07 <lambdabot>   Text -> IO (
02:15:07 <lambdabot>              ^
02:15:09 <jle`> @hoogle Text -> IO ()
02:15:09 <lambdabot> Data.Text.IO putStr :: Text -> IO ()
02:15:09 <lambdabot> Data.Text.Lazy.IO putStr :: Text -> IO ()
02:15:09 <lambdabot> Data.Text.IO putStrLn :: Text -> IO ()
02:19:24 <troydm> how do i import data constructors of a data type into a module without specifying their names
02:19:39 <troydm> something like import Module (Datatypename ( * ) )
02:19:50 <troydm> but that above doesn't works
02:20:02 <troydm> i need to specify all the names
02:22:02 <hellwolf> is STUArray allocated on stack, thus cannot be used for larger than stack size data?
02:22:16 <troydm> ohh nvm
02:22:20 <troydm> it's (..)
02:23:45 <troydm> so i'm appending a Char to Text from both sides using  cons '"' s `append` pack "\""
02:23:52 <troydm> is this the right way doing it ?
02:23:59 <troydm> or am i just doing something wrong
02:24:19 <troydm> note: cons and append are Data.Text (cons,append)
02:29:09 <supki> :t Data.Text.snoc
02:29:10 <lambdabot> Data.Text.Internal.Text -> Char -> Data.Text.Internal.Text
02:29:30 <ScriptDevil> Hi, (noob question). In Data.Monoid, instance Monoid (a -> b)'s mappend is defined as mappend f g x = f x `mappend` g x. My question is that mappend is defined over two arguments. mappend :: a -> a -> a. How is this definition type-checking?
02:30:08 <jle`> ScriptDevil: it might be easier when it is written as
02:30:16 <jle`> mappend f g = \x -> f x `mappend` g x
02:30:59 <supki> ScriptDevil: mappend :: (a -> b) -> (a -> b) -> (a -> b)
02:31:04 <jle`> so if you mappend two (a -> b)'s, you must return a new (a -> b)
02:31:05 <supki> ScriptDevil: mappend :: (a -> b) -> (a -> b) -> a -> b
02:31:21 <ScriptDevil> jle`: Thanks. That is exactly how I would have written it. I am amazed how pattern matches work.
02:31:41 <jle`> ScriptDevil: supki's phrasing of it makes sense too
02:31:48 <jle`> if you drop the parentheses of the last thing
02:31:50 <jle`> but
02:31:54 <jle`> remember that something like f x = ...
02:32:05 <jle`> is desgured as f = \x -> ...
02:32:44 <jle`> so really when it is compiled it is no different than mappend = \f g -> \x ->  which is equivalnent to mappend = \f g x -> ...
02:32:56 <ScriptDevil> That is really really useful as a tip. I did not think of it that way. Eta reduction is easy but this is like anti-eta addition :P
02:33:07 <jle`> haha yeah.
02:33:15 <jle`> actually due to some compiler funniness
02:33:24 <jle`> sometimes moving the parameter to a lambda introduces changes to the semantics
02:33:36 <jle`> depending on what compiler flags/extensions you have on
02:34:16 <ScriptDevil> ok. I am assuming that at the current level of my journey, I do not need to know about those extensions.
02:34:29 <jle`> actually by default the behavior is weird :/
02:34:52 <jle`> if you aren't using ghc 7.8
02:34:56 <jle`> open up ghci
02:35:03 <jle`> let f x = show x
02:35:03 <ScriptDevil> Ok. Have it ready
02:35:08 <jle`> let g = \x -> show x
02:35:12 <jle`> and :t both of them
02:35:34 <ScriptDevil> errr.. () -> String...
02:35:52 <jle`> hopefully it's like that for g and not for f
02:35:55 <ScriptDevil> That doesn't seem right
02:36:06 <jle`> when you write something like g = ...
02:36:16 <jle`> ghc assumes it's a 'constant' of some sort
02:36:21 <jle`> because it's written like a constant sorta
02:36:44 <jle`> and if it has no type signature, ghc infers a concrete/actual type
02:36:49 <jle`> for it
02:36:49 <ScriptDevil> jle`: It gets a bit worse. The alias let s = show
02:36:56 <ScriptDevil> has a type of () -> Stirng
02:37:06 <jle`> yeah, it's the same deal as g = \x -> show x
02:37:08 <jle`> when you say s = ...
02:37:12 <jle`> it 'looks' like a constant
02:37:20 <jle`> and so for efficiency, GHC makes it monomorphic/have only one type
02:37:22 <ScriptDevil> jle`: So lesson of the day, always add type signatures?
02:37:24 <jle`> :t show
02:37:25 <lambdabot> Show a => a -> String
02:37:27 <jle`> show works for any a
02:37:32 <jle`> so the default "any" type is ()
02:37:35 <ScriptDevil> And () is a valid a
02:37:37 <ScriptDevil> Got it.
02:37:46 <jle`> yeah, there is actually a hierarchy of 'default' instances for types.
02:37:53 <jle`> for example if you type let n = 1
02:38:00 <jle`> it'll probably show up as Integer
02:38:08 <jle`> even though it is technically Num a => a
02:38:20 <jle`> @where dmr
02:38:20 <lambdabot> http://www.haskell.org/haskellwiki/Monomorphism_restriction
02:38:26 <jle`> more on this peculiarity
02:38:48 <ScriptDevil> jle`: Off-topic question. What is the d in dmr?
02:38:56 <jle`> it's mostly for efficiency, because if something is of type Num a => a, ghc has to recompute it every time you want it, depending on what type you 'want'
02:38:59 <jle`> ScriptDevil: dreaded :P
02:39:04 <ScriptDevil> Nana
02:39:06 <ScriptDevil> Haha!
02:39:18 <jle`> whether it should be enabled by default or not is a topic of contention
02:39:26 <jle`> because either way, you have unexpected behavior
02:39:41 <jle`> you can turn it off with -XNoMonomorphimRestriction
02:39:57 <jle`> but now if you type something like pi = 3.14 as a "constant"
02:40:08 <jle`> it will be recomputed every time you ask for it, unless you give it a type signature
02:40:21 <jle`> because pi is really a function that generates a pi for a given 'output type'
02:40:34 <jle`> (for your custom pi)
02:40:43 <jle`> but with DMR on, it'll pick one and stick with it
02:40:48 <jle`> in normal programs it's not that much of a problem
02:40:53 <jle`> because you will probably *use* it somewhere
02:40:54 <ScriptDevil> jle`: Why isn't this used for toString a -> a rather than using OverloadedStrings?
02:40:55 <liyang> It's not bad practice to always give type signatures.
02:41:22 <jle`> liyang: yeah, at the top level.  but inside let's and where's people usually leave them off
02:41:33 <jle`> ScriptDevil: hm?
02:42:10 <jle`> anyways usually in a normal program you will end up using whatever 'constant' you define somewhere and GHC will infer a sensible type, and not ()
02:42:15 <liyang> jle`: not giving signatures at the top level is a criminal offence.
02:42:59 <jle`> ScriptDevil: but this functionality is most useless at ghci, so most people turn the DMR off for ghci...in 7.8 it is off by default
02:43:20 <ScriptDevil> jle`: Ok. Thanks. :D
02:44:12 <jle`> and do always use type signatures in appropriate places :)  that way you don't have to rely on the compiler to make guesses like this and the DMR would be irrelevant
02:44:28 <jle`> but yeah i always thought it was really weird
02:44:36 <jle`> that f x = ... and f = \x -> ... behave differently by default
02:44:38 <jle`> oh well.
02:44:53 <jle`> (without type signatures)
02:44:53 <ScriptDevil> jle`: I was referring to the OverloadedStrings Extension where IsString is used instead of String so that I can use Data.Text instead. Why not have a root String type like Num and use NoMR instead?
02:45:35 <jle`> not quite sure what you are asking, sorry
02:45:41 <jle`> but with OverloadedStrings
02:45:51 <jle`> IsString is the same kinda deal as Num, Fractional
02:46:17 <jle`> if you do not specify the type actually, ghc should warn you
02:46:41 <jle`> with -Wall
02:46:43 <jle`> i think
02:46:55 <jle`> or if the type is not inferrable
02:47:08 <jle`> same for Num and Fractional
02:47:09 <ScriptDevil> ok. Thanks.
02:47:30 <jle`> but I guess with NoMR it wouldn't be a big deal?
02:47:35 <jle`> because it doesn't force them to be one type anyway.
02:47:40 <jle`> idk i never turn it off for real programs
02:51:56 <hc> quick attoparsec question:
02:52:09 <hc> i'm getting the suggestion "use string literal" for
02:52:10 <hc> _ <- choice $ map char ['=', '$']
02:52:24 <hc> i don't understand how i should change this
02:52:28 <milfjord> "=$"
02:52:45 <hc> oh, right
02:52:49 <milfjord> char '=' <|> char '$'
02:52:50 <hc> thanks :)
02:53:13 <milfjord> > ['=', '$']
02:53:14 <lambdabot>  "=$"
03:00:01 <osa1> why this view pattern does not work: ref@(readSTRef -> selectedTbl) it says selectedTbl is a ref, it should have been an int after applying readSTRef
03:04:43 <ziman> :t readSTRef
03:04:44 <lambdabot> STRef s a -> ST s a
03:04:59 <pharaun> http://lpaste.net/100878 <- anyone here familiar with linking failure with persistent-sqlite ? i'm trying to build my binary and i'm having issues, but when i run it in ghci it works
03:05:07 <ziman> after applying, it's an ST-value
03:05:13 <osa1> of course
03:05:30 <pharaun> feel like i may be missing a linking opt somewhere
03:05:42 <osa1> that's how view patterns work, it applies readSTRef and binds result to selectedTbl
03:05:43 <ziman> and it says it's an STRef?
03:05:48 <osa1> yes
03:06:37 <ziman> anyway, I guess you're aware that the part "it should have been an int" is not true
03:07:09 <osa1> ziman: no, why?
03:07:40 <ziman> the closest you can get is "ST s Int"
03:08:35 <osa1> right.
03:08:59 <ziman> but getting an STRef is indeed weird
03:10:43 <ziman> btw, where does it say it's an STRef? where do you use selectedTbl?
03:14:21 <osa1> lol. I just replaced all functional code in my GUI library with STRef based one and now my code is more clean and easy to understand. :)
03:14:26 <osa1> ziman: ahh, I just deleted that code.
03:27:23 <ziman> sometimes that's just the easiest way to fix stuff :P
03:33:05 * hackagebot haskell-names 0.3.2.8 - Name resolution library for Haskell  http://hackage.haskell.org/package/haskell-names-0.3.2.8 (RomanCheplyaka)
03:38:06 * hackagebot time-exts 2.1.0 - Efficient Timestamps  http://hackage.haskell.org/package/time-exts-2.1.0 (EnzoHaussecker)
03:46:35 <xintron> Is there any way of showing the data constructor as a string? Making it an instance of show?
03:47:29 <milfjord> > show True -- like this?
03:47:30 <lambdabot>  "True"
03:48:13 <Shammah> > 5 * pi
03:48:14 <lambdabot>  15.707963267948966
03:48:15 <Shammah> cool
03:48:19 <merijn> xintron: You mean "how do I do that automatically?"
03:48:45 <merijn> @let data Foo = MyFooConstructor | AnotherFooConstructor deriving (Show)
03:48:46 <lambdabot>  Defined.
03:48:52 <merijn> > show MyFooConstructor
03:48:55 <lambdabot>  "MyFooConstructor"
03:49:09 <merijn> xintron: Just add "deriving (Show)" to the definition
03:49:18 <xintron> The problem is that show will also give you the values
03:49:28 <xintron> data Foo = Foo String; show $ Foo "bar"
03:49:29 <merijn> Well, yes, that's the point
03:49:37 <xintron> I just want the "Foo" in that case
03:49:54 <merijn> xintron: Well, what's stopping you from defining "myShow (Foo _) = "Foo""?
03:49:55 <milfjord> > toConstr (Just 42)
03:49:57 <lambdabot>  Just
03:50:05 <xintron> merijn, true, nothing :)
03:50:07 <milfjord> > show (toConstr (Just 42))
03:50:08 <lambdabot>  "Just"
03:50:10 <merijn> :t toConstr
03:50:11 <lambdabot> Data a => a -> Constr
03:51:11 <xintron> And if I want to show the name of a funciton? [func1, func2] and I want to loop over and match the function against a string "func1"?
03:51:30 <xintron> (or I could just as well match it against the actual function... well, nvm :) )
03:51:47 <milfjord> functions don't have names
03:51:52 <milfjord> and can't be compared
04:40:26 <suppi> hello
04:41:13 <wilfredh> I have cabal 1.16 installed on my server, and I'd like to upgrade to 1.18. `sudo cabal install cabal-install` gives the error `cabal: There is no package named 'cabal-install'`. What am I doing wrong? I thought that was the correct package to use?
04:41:38 <milfjord> did you run cabal update?
04:42:22 <wilfredh> yep, I've run `cabal update`.
04:45:06 <wilfredh> I suppose I could manually download and install cabal 1.18, but I'm surprised the normal approach isn't working
04:45:11 <jle`> why are you sudo?
04:45:19 <suppi> I once saw a github project with implementation of various unix commands in haskell but I lost the link. can anybody link me to it?
04:45:51 <jle`> suppi: could it be http://www.haskell.org/haskellwiki/Simple_Unix_tools ?
04:46:13 <wilfredh> jle`: good point. Looks like my ~/.cabal has ended up owned as root, but removing it and repeating as a normal user doesn't change the behaviour
04:46:30 <suppi> I don't think so, jle`
04:47:10 <jle`> xintron: show was "sort of" designed to be a sort of way to print strings that you can paste into source code and it'll load appropriately, so the auto-derived Show instances reflect that for the most part
04:47:33 <suppi> but maybe it is and i'm just confusing it with something else
04:50:09 * wilfredh manually installs according to http://coldwa.st/e/blog/2013-08-20-Cabal-sandbox.html
05:07:48 <no7hing> is there a simple way to get a string from a function name? (Data.Map.lookup) to "Data.Map.lookup" ?
05:11:34 <HugoDaniel> no7hing: use the template haskell ''
05:16:17 <no7hing> maybe i'll need to approach this from a different angle; all i need is memoization with the twist of changing the stored calls
05:20:15 <ClaudiusMaximus> no7hing: something like  Map k (IORef v)  or  Map k (STRef s v)  might work?  but i don't see how memoization and mutation are usefully compatible, especially if you have recursion
05:20:23 <osa1> does anyone have any working examples using alex+happy and reporting parse error locations?
05:20:45 <shiona> aleator: is there going to be haskell stuff in instanssi this year?
05:28:43 <no7hing> thanks HugoDaniel and ClaudiusMaximus. i'am a beginner and try to keep away from monads yet
05:29:03 <klrr_> anyone manage to have 2 spaces indent with haskell-mode and shm? emacs always align at the "=" symbol instead of simply two spaces as ive specified...
05:48:34 <kuribas> Is it possible to test against a constructor?  For example "if a == A _ || a == B _ then ..."
05:49:19 <kuribas> test if a variable matches a pattern...
05:49:28 <irssi> case a of A _ -> ... B _ -> ...
05:49:59 <kuribas> irssi: Yes, but without duplicate what comes after ->
05:50:24 <irssi> not that i know of (there probably is)
05:50:32 <irssi> you can pull what's after the -> into a let or where
05:50:43 <kuribas> hm, true...
05:58:19 <animesh> any good statistics module ?
06:02:43 <fly2web> i think haskell is so difficult.
06:02:52 <fly2web> how can i?
06:04:19 <kuribas> fly2web: how can you what?
06:04:33 <fly2web> haskell is difficult.
06:05:09 <kuribas> fly2web: that's not a question...
06:05:39 <fly2web> so i don't know whether studying or stoping ?
06:05:51 <kuribas> fly2web: study of course :)
06:06:00 <fly2web> kuribas: yes
06:06:03 <Zag> In doubt, study.
06:06:21 <fly2web> it is different with python.
06:06:53 <kuribas> fly2web: and practice
06:07:05 <fly2web> ok thanks kuribas
06:07:16 <kuribas> np :)
06:08:49 <kuribas> Could the emacs-indentation mode be improved by using ghc language parsing, instead of emacs lisp?
06:09:50 <kuribas> It uses an ad-hoc recursive descend parser, but it can fail to parse correct code, and it's slow.
06:10:26 <fly2web> kuribas: can i hack with 'haskell'?
06:10:38 <kuribas> fly2web: yes you can.
06:11:01 <fly2web> python vs haskell, which is good for hacking? kuribas
06:11:14 <kuribas> fly2web: depends on what you want to do.
06:11:23 <fly2web> i want web hack
06:11:48 <kuribas> fly2web: I never did web programming in either haskell or python, so I cannot say.
06:12:29 <kuribas> fly2web: There is yesod which is getting quite popular, but I never used it...
06:12:33 <fly2web> i will study haskell for hacking. some one said to me haskell is good for hacking.
06:12:58 <vanila> what is hacking to you?
06:14:03 <kuribas> fly2web: The advantage of haskell is type-safety, more robust programs, and better reasoning about programs.  On the other hand, python may have a easier learning curve.
06:14:31 <fly2web> i know python also.
06:14:51 <fly2web> hacking is correcting information.
06:15:52 <kuribas> fly2web: Nobody can decide for you what is best, but if you want to expand your programming skills, learning haskell will be rewarding.
06:16:16 <fly2web> ok i see.
06:16:19 <Sculptor> yes, but if you don't use it regularly, you'll forget pretty much everything
06:16:37 <fly2web> ok
06:16:39 <fly2web> i see.
06:17:05 <Sculptor> i'm there. used to know a little, but now i know nothing
06:17:18 <vanila> haha
06:17:31 <fly2web> i studied prosedual -> objective -> functional
06:17:49 <kuribas> Sculptor: maybe, but what you learn when coding purely functionally will help you even when coding in other languages.
06:18:06 <fly2web> ok i see.
06:18:06 <kuribas> Sculptor: It made me more aware about side-effects, and handling state, etc...
06:18:16 <Sculptor> ok, tx
06:18:28 * hackagebot hspec2 0.0.1 - Alpha version of Hspec 2.0  http://hackage.haskell.org/package/hspec2-0.0.1 (SimonHengel)
06:21:44 <fly2web> i can use ':l function' but i can't use ':r function'. how can i?
06:22:39 <vanila> I think :r is to reload a whole file, so pick the one with your function in it
06:23:15 <fly2web> thanks vanila
06:23:26 <vanila> oh, it's just :r without any arguments
06:23:41 <fly2web> no argument.
06:23:45 <fly2web> ok i see
06:24:43 <fly2web> Ok, modules loaded: none.
06:25:06 <fly2web> :l baby
06:25:06 <fly2web> [1 of 1] Compiling Main             ( baby.hs, interpreted )
06:25:07 <fly2web> Ok, modules loaded: Main.
06:25:17 <fly2web> :r
06:25:18 <fly2web> Ok, modules loaded: none.
06:25:40 <fly2web> what's wrong?
06:28:29 * hackagebot alsa-mixer 0.2.0.1 - Bindings to the ALSA simple mixer API.  http://hackage.haskell.org/package/alsa-mixer-0.2.0.1 (ThomasTuegel)
06:48:35 <no-n> > pi
06:48:36 <lambdabot>  3.141592653589793
07:11:43 <jml> hello! I have freshly re-installed Haskell Platform on my OS X mavericks laptop. When I run 'cabal update', I get this:
07:11:44 <jml> $ cabal update
07:11:45 <jml> Downloading the latest package list from hackage.haskell.org
07:11:45 <jml> Warning: http error: Network.Browser.request: Error raised ErrorParse "Invalid
07:11:45 <jml> cabal: Char.intToDigit: not a digit -1
07:13:30 <bennofs> jml: what does 'cabal --version' print?
07:13:43 <jml> cabal-install version 1.16.0.2
07:13:43 <jml> using version 1.16.0 of the Cabal library
07:13:49 <jml> bennofs: that.
07:13:52 <milfjord> random idea: proxy
07:14:28 <jml> milfjord: I'm _fairly_ certain I don't have one, and my ISP makes a big deal about how they don't use one.
07:14:54 <jml> it's possible my router's firewall is getting in the way, but that's not the case for any other command-line tool.
07:15:13 <milfjord> does it really stop after "Invalid?
07:17:49 <jml> back. just restarted the router to disable local url filterin.
07:17:50 <jml> the error persists
07:18:33 <jml> milfjord: not sure if it got through, but yes, the message stops at '"Invalid'. I tried resizing the terminal and it still cuts off at that point.
07:19:45 <milfjord> at this point I'd break out strace
07:20:06 <jml> it's a mac, so I think I have to use dtruss
07:21:47 <geekosaur> and you'd have to do it as root or manage to attach to it very quickly
07:25:32 <jml> 'dtrace: error on enabled probe ID 1834 (ID 268: syscall::execve:return): invalid address (0x7f9c02d004e0) in action #12 at DIF offset 24'  appears in the output
07:28:37 * hackagebot pipes-bytestring 2.0.1 - ByteString support for pipes  http://hackage.haskell.org/package/pipes-bytestring-2.0.1 (GabrielGonzalez)
07:28:56 <jml> http://lpaste.net/100879 – I can't see any smoking guns
07:29:09 <jml> but I'm not familiar enough w/ either cabal code or OS X
07:37:51 <jml> I don't understand dtrace, I think
07:40:04 <geekosaur> to me it looks like that chops off early, but I'm not seeing a fork()
07:51:11 <jml> geekosaur: yeah, I was wondering about that. I've tried again with '-f' which ought to follow forks but am getting similar cutting off behaviour.
07:51:26 * jml is now reading & learning about dtruss, dtrace & friends.
07:52:19 <jml> ah hah. running cabal.real directly seems to get better trace
07:54:49 <jml> http://lpaste.net/100881
07:54:55 * jml is going to try a pcap
08:07:55 <jml> it just GETs /packages/archive/00-index.tar.gz from hackage.haskell.org, gets a 301 & then dies.
08:14:45 <akahn> if I have this function that generates a random string whose type is IO String, is there a way to make the function return just String? so that functions who want to call this don't have to deal with IO, but rather just String?
08:15:06 <Iceland_jack> akahn: Yes but you shouldn't
08:15:22 <milfjord> akahn: no
08:15:38 <Iceland_jack> you should rather have an impure function where you draw the value from your 'IO String' and pass the pure String value to other functions
08:16:20 <Iceland_jack>     foo = do
08:16:21 <Iceland_jack>       str <- randomString
08:16:21 <Iceland_jack>       otherFn1 str
08:16:21 <Iceland_jack>       otherFn2 str
08:16:29 <akahn> oh, forgot to include my link http://codepad.org/cyrAP4EM
08:17:01 <c_wraith> akahn: the basic idea of haskell's IO system is that you can operate on IO values with pure functions, but you can never do so without escaping from IO in the bigger context - ie, the final result of the calculation needs to stay in IO
08:17:07 <akahn> okay, thanks. that's essentially what i've been doing, just in main
08:17:12 <Iceland_jack> akahn: There are several approaches here, first of all look into randoms and randomRs
08:17:15 <Iceland_jack> @ty randomRs
08:17:17 <lambdabot> (RandomGen g, Random a) => (a, a) -> g -> [a]
08:17:17 <Iceland_jack> @ty randoms
08:17:17 <lambdabot> (RandomGen g, Random a) => g -> [a]
08:17:52 <c_wraith> akahn: look into liftM/fmap as a shortcut for certain patterns, too.
08:18:19 <Iceland_jack> second of all, look into either passing the generator into the function (like is happening in 'randomRs' and 'randoms' above) making it return only a 'String', not 'IO String'
08:18:32 <Iceland_jack> third, look into http://hackage.haskell.org/package/MonadRandom-0.1.3/docs/Control-Monad-Random.html if you'll be doing this a lot
08:18:43 * hackagebot lifted-base 0.2.2.1 - lifted IO operations from the base library  http://hackage.haskell.org/package/lifted-base-0.2.2.1 (BasVanDijk)
08:19:30 <jml> so, if I had to guess, the cabal I've got is failing to follow redirects
08:19:38 <jml> perhaps I shouldn't be using the one in haskell platform?
08:21:45 <jml> except, the problem with that is that it would seem unusual that I'm the first & only person to have experienced this problem.
08:23:43 * hackagebot rainbow 0.12.0.0 - Print text to terminal with colors and effects  http://hackage.haskell.org/package/rainbow-0.12.0.0 (OmariNorman)
08:23:48 <ij> Couldn't it be rewritten with Data.Maybe.maybe? https://www.haskell.org/ghc/docs/6.12.2/html/libraries/containers-0.3.0.0/src/Data-Map.html#findWithDefault
08:23:52 <ij> If so, why isn't it?
08:24:06 <Galactic> what is the purpose of  the function  id    you give it a value and returns the same value, in what circumstances would this be usefull
08:24:35 <ij> if condition then (+1) else id
08:24:54 <c_wraith> :t foldr (.) id
08:24:55 <lambdabot> [b -> b] -> b -> b
08:24:55 <Iceland_jack> ij: it could, just a matter of taste
08:25:16 <geekosaur> @src fromMaybe
08:25:16 <lambdabot> fromMaybe d x = case x of {Nothing -> d;Just v  -> v}
08:25:18 <c_wraith> Galactic: there are lots of times when you need a "do nothing" edge case for functions.
08:25:24 <geekosaur> hm, thought that used `maybe`
08:25:34 <Galactic> aa I see
08:25:46 <geekosaur> but yes, the main use is to substitute a no-op for a transformer in some cases
08:26:31 <ij> Processors have a nop too.
08:26:37 <jml> ok. how insane is it to install haskell via brew?
08:26:46 <FireFly> > map (`id` 3) [(+1), (*2)]   -- :D
08:26:47 <lambdabot>  [4,6]
08:27:11 <ij> huh
08:27:24 <akahn> Iceland_jack: you're saying if I pass the generator into my function, that would make it return a raw String rather than IO String? That doesn't seem to be the case here http://codepad.org/u7CCK9vl ghci says generateLine is (Monad m, RandomGen g) => g -> m [Char]
08:27:58 <ij> Ah, I see what's going on there.
08:28:06 <ij> Same can be done with $, though.
08:28:10 <FireFly> Yeah
08:28:21 <FireFly> and it'd probably be easier to understand with $
08:28:41 <Galactic> interesting
08:30:40 <c_wraith> ij: in fact, id is just a generalization of ($)
08:30:57 <Iceland_jack> akahn: That's because of the "return" :)
08:31:29 <akahn> Iceland_jack: ah, awesome!
08:33:31 <akahn> Iceland_jack: and that works because the IO action of g has been executed in main when I used <-?
08:33:48 <Iceland_jack> akahn: yeah basically
08:34:10 <Iceland_jack> 'newStdGen' is the effectful function
08:34:45 <Iceland_jack> randomRs generates pseduorandom numbers, you'll always get the same numbers from the same seed
08:35:55 <Iceland_jack> akahn: If you only need to generate a handful of random values it's fine generating them impurely using randomIO/randomRIO (rather than getting the generator impurely) and then passing their values into a function
08:36:26 <Iceland_jack> Sometimes it feels easier, but it can bite you when you need to test your functions
08:36:53 <akahn> and what if I need more secure randomness?
08:37:36 <Iceland_jack> You can use http://hackage.haskell.org/package/crypto-random-api-0.2.0/docs/Crypto-Random-API.html
08:38:16 <akahn> good to know, thanks
08:39:06 <akahn> oh wow randomIO does seem easier! how do I tell randomIO that I want a random value of a particular type?
08:39:24 <Iceland_jack> Often times you don't have to :)
08:39:56 <akahn> but in this case I'm playing in ghci
08:40:18 <Iceland_jack> @ty randomIO :: IO Int
08:40:19 <lambdabot> IO Int
08:40:35 <Iceland_jack> You can do
08:40:35 <Iceland_jack>     ghci> value <- randomIO :: IO Int
08:40:35 <Iceland_jack> or
08:40:35 <Iceland_jack>     ghci> value :: Int <- randomIO
08:41:05 <akahn> of course, I was trying `randomIO :: Bool`
08:41:31 <akahn> and the error message was telling to do exactly what you suggested doing, but I'm not very good at reading and understanding the type checking error messages yet
08:42:10 <Iceland_jack> They'll be natural to read in no time
08:42:38 <akahn> thanks for your guidance
08:42:44 <Iceland_jack> Note that in actual code the type of randomIO may well be inferred
08:43:22 <Iceland_jack> @ty do bool <- randomIO; int <- randomIO; return (if bool then int else 5)
08:43:23 <lambdabot> (Num b, Random b) => IO b
08:44:08 <Iceland_jack> so you can have
08:44:08 <Iceland_jack>     foo :: IO Int
08:44:08 <Iceland_jack>     foo = do
08:44:08 <Iceland_jack>         bool <- randomIO
08:44:11 <Iceland_jack>         int  <- randomIO
08:44:14 <Iceland_jack>         return (if bool then int else 10)
08:44:29 <Iceland_jack> where the first randomIO has type IO Bool and the other has type IO Int
08:45:19 <ij> I haven't used do much, could you tell me how could I doify this? x >>= (\x -> y >>= (\y -> either error (output y) . decodeImage x))
08:45:28 <ij> Almost at all, really.
08:45:48 <Iceland_jack> You can use '@undo' but let's wait with that :)
08:46:29 <Iceland_jack> http://www.haskell.org/onlinereport/exps.html look for '3.14 Do Expressions'
08:47:12 <Iceland_jack> There are 4 basic rules for desugaring do-notation
08:48:48 <ij> Ah, sweet! It works.
08:49:28 <Iceland_jack> ij: When you see '... >> x >>= \y -> rest' it's the same as
08:49:29 <Iceland_jack>     do ....
08:49:29 <Iceland_jack>        y <- x
08:49:29 <Iceland_jack>        rest
08:50:24 <Iceland_jack> so
08:50:24 <Iceland_jack>     getLine >>= (\line -> putStrLn line)
08:50:24 <Iceland_jack> is the same as
08:50:27 <Iceland_jack>     do line <- getLine
08:50:30 <Iceland_jack>        putStrLn line
08:50:33 <Iceland_jack> but can also be written as
08:50:37 <Iceland_jack>     getLine >>= putStrLn
08:51:08 <Earnestly> ❤
09:03:06 <Peaker> what robust in-process key/value store has Haskell bindings? Berkeley DB is dependency hell and its API is annoying :(   Sophia (which I made bindings for) seems non-robust, and gets DB corruption after process dying uncleanly a few times
09:03:48 * hackagebot HGamer3D 0.3.3 - A Game Engine for the Haskell Programmer  http://hackage.haskell.org/package/HGamer3D-0.3.3 (PeterAlthainz)
09:05:52 <ClaudiusMaximus> Peaker: sqlite ? in my tests it was slow as hell with on-disk db but using an in-memory db copying contents to disk occasionally worked better for me
09:06:13 <Peaker> ClaudiusMaximus: it's much more than a key/value store, though
09:06:29 <Peaker> ideally the interface is  setKey & getKey
09:06:54 <ClaudiusMaximus> Peaker: ok.  i was never really sure what key-value store meant until your explanation, thanks
09:07:37 <Peaker> also, if there's an "out-of-the-box" solution that just works reliably and with decent (read: not necessarily great) performance, that would be much nicer
09:07:47 <Peaker> but I might fall back on sqlite + on-disk db
09:08:18 <levi> Peaker: I guess you have some reason not to use AcidState?
09:08:49 * hackagebot HGamer3D-GUI 0.3.1 - GUI Functionality for HGamer3D  http://hackage.haskell.org/package/HGamer3D-GUI-0.3.1 (PeterAlthainz)
09:08:51 * hackagebot HGamer3D-Wire 0.3.0 - Wire Functionality for HGamer3D  http://hackage.haskell.org/package/HGamer3D-Wire-0.3.0 (PeterAlthainz)
09:09:31 <Peaker> levi: I don't want the database to always grow.. does AcidState let you kill older stuff?   Also, I dislike the idea that everything has to always be in memory, as a Haskell value (which has quite large overheads)
09:19:15 <jml> brew install of cabal gives me the same error :(
09:19:21 <hc> i need to encrypt and decrypt small payloads for transfer via a network
09:19:26 <hc> which crypto library is recommended for this?
09:19:34 <hc> (shared key)
09:30:33 <bennofs> @tell heatsink Have you tried the program without profiling enabled? If I enable profiling, I don't get an error from hp2ps
09:30:33 <lambdabot> Consider it noted.
09:35:11 <jml> I'm now trying a minimal ghc install via brew, and using cabal bootstrap.
09:36:18 <c_wraith> jml: why are you installing it via a package manager at all?
09:36:39 <jml> c_wraith: because no matter how I run cabal update, I get this error message:
09:36:42 <jml> Downloading the latest package list from hackage.haskell.org
09:36:42 <jml> Warning: http error: Network.Browser.request: Error raised ErrorParse "Invalidcabal: Char.intToDigit: not a digit -1
09:37:15 <jml> which is making it very difficult for me to use this laptop for haskell work.
09:37:52 <c_wraith> I don't see changing GHC installs fixing anything...
09:38:01 <c_wraith> Reinstalling cabal-install might, though
09:38:05 <jml> done that.
09:38:20 <jml> still doesn't work.
09:38:43 <hc> question about System.Process: is it possible to pass to a child process an additional fd such as a pipe
09:38:48 <hc> ?
09:38:57 * hackagebot penny 0.32.0.6 - Extensible double-entry accounting system  http://hackage.haskell.org/package/penny-0.32.0.6 (OmariNorman)
09:39:12 <hpc> hc: one way to do that would be with a named pipe
09:39:18 <jml> have tried haskell platform dmg install, brew install of haskell-platform, brew install of ghc + bootstrapped cabal, none of these work
09:39:19 <c_wraith> hc: I don't think that's a System.Process question so much as a unix question.
09:39:29 <hc> c_wraith: i know how to do it in C ;)
09:39:30 <hpc> (ie, find a library that does something like mkfifo /tmp/myhspipe
09:39:32 <hpc> )
09:39:40 <hc> and i prefer not to use named pipes
09:39:52 <jml> dtracing indicates that cabal connects to hackage.haskell.org & gets the redirect, gets a 301, and then doesn't seem to do anything beyond that.
09:40:00 <Peaker> https://www.sqlite.org/cvstrac/wiki?p=KeyValueDatabase seems to suggest SQLite sucks as a k/v store
09:40:09 <hc> so the problem i'm trying to solve is pass to gpg both a payload and a passphrase
09:40:42 <SwashBuckla> anyone have an idea about what might be going on here? http://share-elm.com/sprout/531b5502e4b0f7cc0dd4e241 (I know it is Elm, not Haskell, but I thought the error might be similar to those possible in Haskell)
09:41:52 <hc> hmm, i'll try a different approach
09:42:15 <vanila> looks like it wants a record rather than a pair
09:43:48 <ParahSailin> hc: you would probably have to do it manually, opening the fd3 before execve, then closing in parent
09:43:50 <Iceland_jack> SwashBuckla: input appears to have type 'Signal (Int, Int)'?
09:44:55 <Iceland_jack> SwashBuckla: I'm not sure though, can you add annotations to top-level expressions in Elm?
09:45:08 <SwashBuckla> type annotations?
09:45:32 <jml> Is anyone actually using cabal on OS X 10.9.2?
09:46:02 <jml> or can help me figure out what is causing that error message?
09:46:04 <fizruk> jml: i do
09:46:22 <SwashBuckla> Iceland_jack: I'll add type annotations for clarity (even if it's just for myself) :P
09:46:55 <jml> fizruk: and it works for you? how'd you install it?
09:47:10 <Iceland_jack> Keyboard.arrows has type Signal { x:Int, y:Int } anyway
09:48:13 <Iceland_jack> Which is what your error message mentioned
09:48:17 <fizruk> jml: I believe I've installed it before updating to 10.9.2, from this page: http://www.haskell.org/platform/mac.html
09:48:25 <jml> fizruk: thanks.
09:48:38 <ParahSailin> hc: looks like you would createPipe here http://hackage.haskell.org/package/unix-2.7.0.0/docs/System-Posix-IO.html
09:49:10 <Iceland_jack> 'sampleOn ⊥ Keyboard.arrows' has type Signal { x:Int, y:Int} as well
09:49:55 <bitraten> whats the best way to parse hashtags with attoparsec?
09:50:40 <Iceland_jack> SwashBuckla: I guess that's your problem
09:50:49 <SwashBuckla> Iceland_jack: yeah, if I substitute in ((\{x,y} -> (x,y)) <~ Keyboard.arrows) instead of Keyboard.arrows, it compiles
09:50:54 <Iceland_jack> right
09:51:02 <Iceland_jack> since Tick accepts a tuple of Time and (Int, Int)
09:51:09 <SwashBuckla> because everything else expects (Int, Int)
09:51:12 <SwashBuckla> yarr
09:51:26 <Iceland_jack> yarr, how's your thesis going mate?
09:51:41 <SwashBuckla> I am not really doing it
09:51:48 <SwashBuckla> but I suppose I am flirting with Elm
09:51:52 <SwashBuckla> (related)
09:51:52 <vanila> SwashBuckla, why is it that way around given the error says it expected a record?
09:51:57 * vanila confused
09:52:23 <vanila> oh it's talking about the context,  not the value
09:53:05 <Iceland_jack> SwashBuckla: I just assumed this had to do with your thesis since it's a question on Elm
09:56:07 <SwashBuckla> Iceland_jack: yeah. This is giving me more confidence in working with it I spose. It's not central to the theme, but I'm getting ideas
09:57:12 <michaelt> jml I wonder if the new ghc-7.8 almost-out version, which has build for mavericks, would solve this?  http://www.haskell.org/ghc/dist/7.8.1-rc2/
09:57:17 <SwashBuckla> Elm is really nice
09:57:39 <Iceland_jack> yeah it is
09:57:54 <Iceland_jack> Is the #elm channel active?
09:58:02 <jml> michaelt: I'll give that a try. right now I'm digging through cabal-install code to see if I can figure something out.
09:58:20 <jml> my guess is that there's an error, and then another error during the attempt to display the error
09:58:43 <SwashBuckla> Iceland_jack: there's often a long wall of JOIN/PARTS, but I've always gotten answers quickly
09:58:46 <jml> I would love a stack trace :\
09:58:53 <michaelt> jml oh, yeah i was going to suggest the git repo for that, let me look for one of the little guides to installing with these tarballs.
09:58:59 * hackagebot inflections 0.1.0.6 - Inflections library for Haskell  http://hackage.haskell.org/package/inflections-0.1.0.6 (jsl)
10:22:28 <iduhetonas> carter: Do you have a repo where you keep updated on the scipy/numpy equivalent to Haskell?
10:22:29 <Cale> jml: What problem are you having? You're aware of the XCode 5 issues?
10:22:36 <fntr> lol
10:22:46 <carter> iduhetonas: you mean where my stuff is?
10:22:56 <iduhetonas> Yeah
10:23:01 <carter> i'm about to do a public release of a baby alpha soon
10:23:11 <iduhetonas> Awesome!
10:23:15 <carter> the repos aren't public yet
10:23:31 <fntr> lol
10:23:32 <carter> because 'm doing enough breaking changes every few days that i don't wannna have to keep on writing the docs / explaining every frew days :)
10:23:38 <carter> iduhetonas: BUT
10:24:04 <carter> a) i have an announce list you can signup for on wellposed.com (the stuff i'm going to put in public alpha soonn with be BSD3)
10:24:27 <carter> b) theres a #numerical-haskell  channel you can lurk on
10:24:31 <jml> Cale: yes, I am aware.
10:24:47 <carter> c) i'll announce to all of the standard places like /r/haskell and cafe lists
10:24:53 <carter> d) i'm really loud
10:24:56 <carter> iduhetonas: k?
10:24:59 <jml> Cale: problem is weird error on 'cabal update'. fetching paste now.
10:25:05 <jml> Downloading the latest package list from hackage.haskell.org
10:25:05 <jml> Warning: http error: Network.Browser.request: Error raised ErrorParse "Invalidcabal: Char.intToDigit: not a digit -1
10:25:13 <iduhetonas> carter: a) Is it here? http://wellposed.us5.list-manage.com/subscribe?u=0a80fab0bc8e5f476e37b7ea3&id=2129e511af I wasn't sure if it was updated since it refers to fall 2012
10:25:16 <carter> yes
10:25:22 <carter> iduhetonas: life got busy :)
10:25:28 <carter> i should change the blurb
10:25:36 <jml> Cale: I don't *think* that's an xcode issue, since it's well before we reach the compile stage.
10:25:41 <Cale> yeah
10:25:43 <carter> lemme update it
10:25:44 <iduhetonas> carter: Hey it happens
10:26:19 <ClaudiusMaximus> jml: random guess, is there a file already there that can't be overwritten due to permissions?
10:26:23 <carter> iduhetonas: also took 1.5 years to figure out some sane api defaults
10:26:53 <jml> ClaudiusMaximus: possibly. I don't know a) how I'd find out which file; b) why it would have survived multiple uninstall / nuke attempts
10:27:05 <jml> ClaudiusMaximus: also, I didn't see any evidence of that in the dtrace
10:27:09 <carter> iduhetonas: one thing i'm doing the next two weeks is before release writing a bunch of basic linear algebra solvers
10:27:32 <carter> and making sure they're not *much* slower than lapack
10:27:37 <iduhetonas> carter: Awesome!
10:27:43 <jml> http://lpaste.net/100881
10:27:48 <jml> ^^ the dtrace
10:27:50 <carter> iduhetonas: the core stuff is will be really small
10:27:52 <carter> BUT
10:27:59 <carter> its supposed to be a *nice* coore
10:28:19 <iduhetonas> carter: Reason why I ask is because I'm doing a bunch of IMU calibration stuff for MEMs accel/gyro/mag parts
10:28:28 <carter> IMU ==?
10:28:40 <carter> iduhetonas: lets switch to #numerical-haskell (other lurkers welcome)
10:28:48 <iduhetonas> carter: Oops, alright
10:28:52 <carter> nah
10:29:06 <carter> its just more fun to have an applied math irc channel :)
10:30:39 <jml> I've been banging my head against this problem for hours. Time for a break
10:30:44 <jml> thanks all for the help
10:31:21 <flazz> how is one meant to use Data.Text.Lazy.Internal with Data.Text ? some functions (IO ones) work only on the *Internal* versions
10:34:28 <fntr> Justin Bieber is gay
10:36:22 --- mode: ChanServ set +o milfjord
10:37:12 <Cale> jml: Do this:  wget -O- http://hackage.haskell.org/00-index.tar.gz | md5sum  and see if you get  d17fdac0938d41c0ae2eedf66a5a7b21
10:37:13 <jml> OK. If I change FetchUtils.hs to get the index from /packages/index.tar.gz rather than /packages/archive/00-index.tar.gz it successfully downloads the index.
10:37:44 <Cale> hmm
10:38:08 <Cale> http://hackage.haskell.org/packages/archive/00-index.tar.gz  also works for me
10:38:23 --- mode: milfjord set -o milfjord
10:38:58 <jml> Cale: that wget gives me: ERROR: Redirection (301) without location.
10:39:07 <Cale> jml: That's interesting
10:39:16 <jml> as does /packages/archive
10:39:21 <jml> Cale: indeed!
10:39:36 <Cale> jml: I wonder if there's something in between you and the Internet which is messing with http requests
10:39:43 <jml> Cale: especially since I've actually observed the Location: header in network captures
10:40:40 <jml> Cale: hmm. hmm. hmm.
10:42:34 <jml> it works with 'curl -L'
10:43:45 <jml> anyway, I'll try with a 3G dongle instead of my wifi & see if that changes the results. (will be off IRC for a bit)
10:48:02 <iduhetonas> Anybody going to ICFP this year?
11:10:24 <jkarni> anyone know of DAG-to-arrow translation tools?
11:16:58 <jbracker> I am trying to use esqueleto to write my SQL queries but I get a type error I can not decipher: http://lpaste.net/2423470597104205824
11:17:10 <jbracker> I am trying to do a projection to a certain column
11:18:08 <jbracker> It compiles if I just get the complete entries instead of projecting by "return tr" instread of "return $ tr ^. TransactionAmount"
11:20:30 <niotepx> I see that there are lots of people on, but does everyone use private chat?
11:21:13 <jbracker> I guess it has to do with returning some "expr a" instead of an "a", but I can't find another way to project
11:21:42 <Iceland_jack> niotepx: Many people lurk, there is generally something going on in the channel though
11:22:50 <niotepx> Iceland_jack: Okay. Didn't know, thanks.
11:26:33 <niotepx> @help
11:26:33 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
11:26:43 <niotepx> help list
11:26:54 <niotepx> @help list
11:26:54 <lambdabot> list [module|command]. Show commands for [module] or the module providing [command].
11:27:05 <Iceland_jack> You can evaluate commands with > and check their type with :t
11:27:06 <Iceland_jack> > 5 + 10
11:27:06 <niotepx> list
11:27:07 <lambdabot>  15
11:27:11 <niotepx> @list
11:27:11 <lambdabot> What module?  Try @listmodules for some ideas.
11:27:13 <Iceland_jack> :t head [1..]
11:27:14 <lambdabot> (Enum a, Num a) => a
11:28:39 <shergill> hmm i'm looking for generic functions to traverse GADTs eg. given a tree structure and say depth first traversal, find/replace the n'th element in that traversal. what part of lens (or another library), should i be looking at?
11:28:41 <niotepx> > (12341*6)/2
11:28:42 <lambdabot>  37023.0
11:28:45 <eacameron> I just wrote a small tool (https://github.com/CovenantEyes/libget-hs) for my company and some are less than excited that I used haskell because noone else knows it well. That's a reasonable complaint. Is there some very brief video/tutorial that I can use to take away some of thy mystery for this code?
11:29:20 <eacameron> it's probably pretty bad HS code, but i haven't spent much time on it, and I'm not a pro
11:30:35 <niotepx> eacameron: What does is lib(get)?
11:30:50 <niotepx> it*
11:30:53 <Iceland_jack> eacameron: Be aware that introducing Haskell to a company where people don't know or care for Haskell can backfire
11:31:20 <Iceland_jack> other than that you can try to avoid applicative and pointfree style if you intend non-Haskellers to maintain it
11:32:53 <niotepx> Iceland_jack: Oh, I do have another question. What does "-<" do, and how should one use it?
11:33:14 <Iceland_jack> niotepx: Do you mean '<-' or are you using Arrows?
11:33:18 <niotepx> No
11:33:41 <niotepx> Iceland_jack: I've seen '-<' used before, and it made no sense.
11:34:04 <Iceland_jack> Did it look like the '-<' in here: http://www.haskell.org/haskellwiki/Arrow?
11:34:17 <niotepx> Yes!
11:34:39 <milfjord> then why did you say no?
11:35:00 <niotepx> milfjord: Because he said '<-'.
11:35:13 <Iceland_jack> niotepx: I also asked 'or are you using Arrows?'
11:35:46 <geekosaur> I think to have answered that they would need to know about Arrows
11:36:00 <geekosaur> [08 19:30] <niotepx> Iceland_jack: I've seen '-<' used before, and it made no sense.
11:36:17 <geekosaur> implies they aren't familiar with Arrows so that question wouldn't have been answerable
11:36:26 <Iceland_jack> That's right
11:36:29 <niotepx> Iceland_jack: I should've let you know that I'm 4 weeks into the language, and the only use of the word "Arrows" I've seen uses '<-' or '->'
11:36:49 <Iceland_jack> eacameron: Otherwise I don't know of any one video that explains enough Haskell to be able to understand applicative functors, monads but if they're interested in learning Haskell Chalmers' introduction is quite nice
11:37:04 <Iceland_jack> http://www.cse.chalmers.se/edu/year/2013/course/TDA452/FPLectures/Vid/
11:37:20 <geekosaur> Arrow notation is a bit different from everything else and you should probably ignore it for now
11:37:35 <milfjord> niotepx: those are arrows, not Arrows
11:38:05 <geekosaur> (also, it's not very widely used; Applicative has largely replaced it)
11:39:36 <niotepx> Hmmm.....so, '<-' and '->' are not Arrows, but arrows, and Arrows are not necessary?
11:40:00 <Iceland_jack> niotepx: It depends on context
11:40:24 <Iceland_jack> niotepx: http://www.haskell.org/haskellwiki/Keywords check this out
11:40:53 <niotepx> (O.O) -> (-_-) -> (?_?)...How very...interesting.
11:41:04 <geekosaur> Arrows have some use. Arrow notation doesn't really; it requires a combinator that turns out to be rather limited (arr).
11:42:19 * Iceland_jack . o O ( Am I crazy for wanting: print :: a -> IO () where a has Show )
11:42:35 <geekosaur> ?
11:42:46 <JamT12> Can anyone explain why the following problem happens? http://lpaste.net/100883
11:42:47 <Iceland_jack> as an alternative to
11:42:47 <Iceland_jack>     Show a => ...
11:42:47 <geekosaur> :t print
11:42:48 <lambdabot> Show a => a -> IO ()
11:42:51 <FireFly> <- is syntax used in list comprehensions and do-notation (Monad syntax).  -> is syntax used for lambdas and function types.  -< is syntax used as sugar for Arrows stuff
11:42:51 <dwcook> Iceland_jack, yes, since it already exists :P
11:43:08 <Iceland_jack> dwcook: The syntax doesn't
11:43:18 <geekosaur> oh, you meant that where syntax
11:43:24 <Iceland_jack> Yes
11:43:33 <geekosaur> and that has a couple problems I think
11:43:46 <dwcook> Iceland_jack, what would that syntax be good for that existing contraint syntax isn't as good at?
11:44:03 <geekosaur> not to mention that the constraint notation acts like, and under the covers *is*, a parameter
11:44:20 <enthropy> might be worthwhile to write a quasiquote that'll do such notation?
11:44:35 <Iceland_jack> geekosaur: That seems like an implementation argument
11:44:45 <enthropy> print :: [s| a -> IO () where a has Show |]
11:45:19 <geekosaur> and I think I just answered JamT12's question as well with that... because all you told it was to pass a dictionary including (==) for [x] but not one including (==) for x
11:45:56 <Iceland_jack> dwcook: Nothing, it would be pronounced the way it's written though
11:46:17 <Iceland_jack> of course it shouldn't be changed for Haskell, it's a standardized language
11:46:21 <geekosaur> yes in some sense this is implementation detail. But I don't think you can reliably get away from that implementation detail
11:46:31 <diribative> Sorry to interrupt. I am brand new to Haskell, and I don't understand why one thing gives me a parse error even though a similar thing doesn't. Should I go to Stackoverflow or ask here or some other forum?
11:46:46 <geekosaur> you can ask here
11:46:49 <geekosaur> @paste
11:46:49 <lambdabot> Haskell pastebin: http://lpaste.net/
11:48:09 <geekosaur> JamT12, so the problem is that it cannot find (==) for x given (==) for [x], except by the rather slow mechanism of promoting an x to a [x] by wrapping it in a list and then using the (==) you gave it
11:48:30 <Iceland_jack> diribative: Feel free to ask here
11:49:01 <geekosaur> and it won't and shouldn't do that
11:49:29 <w4tg> تحذير     قد تكون مراقب
11:49:39 <JamT12> geekosaur: I am a bit confused, doesn't the instance declaration "instance  Eq x => Eq [x] where" mean where ever we have Eq [x] we have Eq x?
11:49:57 <diribative> Here's as minimal as I understand how to make my example/confusion: http://lpaste.net/100886
11:50:13 <kadoban> huh, i had no idea that my irc client could handle rtl languages like that
11:50:18 <geekosaur> it does. it does not, however, mean that when you have Eq [x] you can readily *find* Eq x; only that you can readily *make* Eq [x] given Eq x
11:50:24 <geekosaur> it goes the wrong direction
11:50:25 <dwcook> JamT12, other way around, actually
11:50:30 <Iceland_jack> diribative: You need an arrow in the anonymous function
11:50:50 <Iceland_jack> alos you should probably group (head x)
11:51:03 <geekosaur> You know it exists, you only know how to use it by starting from a list
11:51:18 <dwcook> JamT12, it might help if you read => as "implies"
11:51:20 <geekosaur> It doesn't go both ways
11:51:21 <JamT12> if Eq [x] is provided then Eq x should be automatically provided, since you cannot make Eq [x] without Eq x, instance declarations are unique
11:51:49 <niotepx> Has anyone here used Ajhc? I'd like help with some coding problem, if possible.
11:52:08 <dwcook> JamT12, you would be right if the constraint were in the class rather than the instance
11:52:09 <geekosaur> mm, not exactly. In an interpreted only language maybe but if you compile your code then it cannot *decompile* it to get Eq x from Eq [x]
11:52:21 <geekosaur> since you explicitly gave it only Eq [x]
11:52:33 <diribative> Iceland_jack: Thanks, "Sil x <= Sil y = (\p -> Sil y <= p) (head x)" works fine.
11:52:37 <geekosaur> and explicitly did *not* give it Eq x
11:52:39 <vanila> instance Eq [x] => Eq x where a == b = [a] == [b] :P
11:52:39 <dwcook> For example, in all cases where you have Applicative you also have Functor, so you don't need a Functor constraint if you have an Applicative one
11:52:59 <geekosaur> vanila, I actually said that earlier, not in quite that form
11:53:40 <geekosaur> remember also that the code for Eq x may not be visible when it's compiling Eq [x], much less when it's using it
11:54:09 <dwcook> geekosaur, I think that particular argument might rely too much on implementation
11:54:54 <shergill> is there a generic length function for tree like data types already implemented somewhere?
11:55:10 <geekosaur> that could be argued. unfortunately the counter is "Haskell must therefore be implemented only in slow ways that let us get away with running stuff backwards"
11:55:10 <lilred> hey guys, I'm writing a parser combinator package for Ocaml, and I'd like to generate the combinators from a struct. What's the minimal definition I need to be able to generate many, many1, sepBy, sepBy1? I know a monoid suffices for many/many1 but I don't know about sepBy
11:55:42 <geekosaur> pretty sure the language definition was avoiding backing implementers into that particular corner
11:56:05 <JamT12> geekosaur: I am fine with having a slower Haskell with more straightforward overloading semantics
11:56:14 <dwcook> shergill, I don't know if it exists, but you can write (Foldable t) => t a -> Int or the like
11:56:18 <geekosaur> that's nice
11:56:57 <milfjord> lilred: where do you need a monoid?
11:57:00 <dwcook> foldr (\_ n -> n + 1) 0
11:57:08 <iduhetonas> Anybody know if there's a predefined function to get the longest sublist inside of a list? I.e. [1,2,3] in a list with [[1],[1,2],[1,2,3]]
11:57:27 <lilred> milfjord: I can define many1 using reduce, and many using reduce with the zero element at the tail
11:57:31 <Iceland_jack> iduhetonas: maximumBy (comparing length)
11:57:41 <iduhetonas> Iceland_jack: Thanks!
11:57:46 <Iceland_jack> > maximumBy (comparing length) [[1],[1,2],[1,2,3]]
11:57:47 <lambdabot>  [1,2,3]
11:57:54 <milfjord> lilred: huh?
11:58:16 <Iceland_jack> iduhetonas: And if you need to find where a function is (if you don't know already) you can use Hoogle
11:58:17 <niotepx> Well, I've had no luck on SO, so if anyone can: lpaste.net/1991163172186226688
11:58:17 <Iceland_jack> @hoogle maximumBy
11:58:18 <lambdabot> Data.List maximumBy :: (a -> a -> Ordering) -> [a] -> a
11:58:18 <lambdabot> Data.Foldable maximumBy :: Foldable t => (a -> a -> Ordering) -> t a -> a
11:58:26 <Iceland_jack> @hoogle comapring
11:58:27 <lambdabot> No results found
11:58:30 <Iceland_jack> @hoogle comparing
11:58:30 <lambdabot> Data.Ord comparing :: Ord a => (b -> a) -> b -> b -> Ordering
11:58:31 <shergill> dwcook: right. it just seems like something a generics library would've tackled already, wouldn't it?
11:58:45 <lilred> milfjord: actually I think I'm not completely clear about what I'm trying to do, so I'll probably come back later :o)
11:58:46 <milfjord> many p = many1 p <|> pure []; many1 p = (:) <$> p <*> many p
11:59:00 <lilred> yeah pretty much
11:59:09 <dwcook> shergill, I would've thought so. I didn't find anything in a quick search though
11:59:10 <iduhetonas> Iceland_jack: Cool cool! I did a bunch of searches in Hoogle, but I was asking the wrong thing =)
11:59:59 <diribative> Is there a slick way to get Eq from Ord or do I have to type something like a == b = a `compare` b == EQ
12:00:20 <Iceland_jack> diribative: If it's an Ord it's already an Eq :)
12:00:21 <geekosaur> you can't because that will call (==)
12:00:37 <geekosaur> because Ord is implemented using Eq
12:00:44 <Iceland_jack>     class Eq a => Ord a where
12:00:44 <Iceland_jack>         ...
12:01:03 <iduhetonas> diribative: geekosaur is right. See http://hackage.haskell.org/package/base-4.6.0.1/docs/Prelude.html#t:Ord
12:01:52 <milfjord> diribative: your code looks like the best way
12:02:45 <diribative> I'm confused. If I make a type an instance of Ord without making it an instance of Eq, I get an error saying "hey it's not an instance of Eq". But it seems I can fix that by saying "get the Eq structure from the Ord structure in the required way". I was wondering if that was common enough that there was another way to write it
12:03:20 <geekosaur> no? becuase it's only in the Ord structure if you already have it
12:03:35 <milfjord> geekosaur: ?
12:03:37 <magneticduck> http://ix.io/aZN
12:03:39 <magneticduck> any ideas?
12:03:54 <magneticduck> part of a program with GLUT and OpenGL
12:03:59 <geekosaur> <<loop>>
12:04:25 <dwcook> diribative, anytime you're defining a valid Ord instance, you will always have (==) available. If you don't, you can't even make the Ord.
12:04:31 <magneticduck> $= is a thing in the OpenGL package, used to set settable state vars
12:04:32 <milfjord> geekosaur: ??
12:04:37 <milfjord> dwcook: wrong
12:04:59 <dwcook> milfjord, no? But isn't that what it means to have the Eq constraint?
12:05:01 <milfjord> magneticduck: I don't understand your misinterpretation of the error message
12:05:07 <magneticduck> hm
12:05:09 <magneticduck> I'll read it again =P
12:05:25 <Shammah> Is Integer prefered only above Int if you really need to squish out performance? Such that in general it is adviced to use Integer?
12:05:32 <Shammah> erm
12:05:35 <milfjord> magneticduck: the problem is that $ has low precedence
12:05:37 <magneticduck> Shammah: Int is faster than Integer
12:05:40 <magneticduck> milfjord: m
12:05:43 <Shammah> *Is Int only prefered above Integer when you need the performance
12:05:48 <Shammah> Got it the wrong way around lol
12:05:56 <magneticduck> yes I'm seeing it now (after typing up my problem and uploading it)_
12:06:01 <geekosaur> diribative, let's say you have decided to implement a from scratch Ord that does Eq internally but does not advertise it. The question is, why would you do that instead of using a common Eq, so that the only way to get that Eq is to burrow inside of Ord? Eq is more commonly used, an extra layer of abstraction to pull the more common operation out of the less common and more expensive one does not make sense
12:06:10 <milfjord> magneticduck: a $= b $ c parses as (a $= b) $ c
12:06:26 <magneticduck> right.
12:06:34 <magneticduck> I wasn't very familiar with that aspect of the $ operator
12:06:54 <magneticduck> I'm used to using it as a $ b $= c == a $ (b $= c)
12:07:01 <magneticduck> ofc. thanks
12:07:04 <milfjord> geekosaur: to remove code duplication
12:07:25 <milfjord> the central thing to define is compare
12:07:36 <diribative> geekosaur: "instance Eq Mytype where a == b = a <= b && b<= a" appears to work just fine.
12:07:41 <milfjord> from that you can get <, >, <=, >=, etc
12:07:49 <milfjord> and ==
12:07:51 <dwcook> milfjord, can you at least give an example of where what I said is wrong?
12:08:09 <Iceland_jack> diribative: It's possible to define Eq in terms of Ord even though Ord depends on Eq
12:08:15 <milfjord> but for == you need an explicit definition like a == b = compare a b == EQ
12:08:39 <diribative> Iceland_jack: And that's exactly what I wanted to do, and it seems to work. I just thought geekosaur was saying I couldn't.
12:09:09 <milfjord> dwcook: you don't need to have Eq "first". you can define them simultaneously
12:09:26 <dwcook> milfjord, I didn't say anything about having Eq first.
12:09:30 <Iceland_jack> diribative: I believe geekosaur was recommending against it, Eq is generally more straightforward to define
12:10:22 <milfjord> what's more straightforward than a == b = compare a b == EQ?
12:10:59 <Iceland_jack> milfjord: I didn't say define in terms of Ord
12:11:13 <diribative> milfjord: Actually, that gives me a stack overflow error somehow.
12:11:28 <Iceland_jack> But if you have
12:11:28 <Iceland_jack>     data Foo = A | B
12:11:28 <Iceland_jack> you can define
12:11:28 <Iceland_jack>     instance Eq Foo where a == b = compare a b == EQ
12:11:29 <milfjord> diribative: how did you define compare?
12:11:31 <Iceland_jack> and
12:11:32 <diribative> a <= b && b<= a works but compare a b == EQ
12:11:34 <Iceland_jack>     instance Ord Foo where { compare A A = EQ; compare B B = EQ;
12:11:34 <diribative> doesn't
12:11:37 <Iceland_jack>                              compare A _ = LT; compare B _ = GT; }
12:11:41 <Iceland_jack>  
12:12:28 <dwcook> milfjord, I think I see where you thought what I said was misleading, even though it might not be wrong per se. I'll concede the point, however.
12:12:53 <eacameron> niotepx: right now libget just "gets" anything in the <packages>/<package-name>/<package-ver> folder and copies it to a local project-specific folder; one day it might actually build packages on the fly or download them from a server, etc. It will/should also support a dependency resolution at some point and version ranges
12:13:18 <eacameron> Iceland_jack: you say it might backfire, have you experienced that? (thanks for the link)
12:13:30 <ion> What’s the best way to make Haskell bindings for a C++ library at the moment?
12:13:32 <niotepx> eacameron: Ah, alright. Neato.
12:13:42 <milfjord> dwcook: you won't necessarily have == "available" because it might be defined in terms of Ord
12:13:49 <milfjord> is what I meant
12:14:09 <milfjord> ion: C api
12:14:13 <eacameron> niotepx: we needed "package management" for our internal "packages" but we use C++ and there is no package manager for it
12:14:14 <dwcook> milfjord, agreed.
12:14:45 <niotepx> ask eacameron
12:14:51 <ion> milfjord: Would you mind elaborating on that? Do you mean a C wrapper?
12:15:12 <diribative> Here is the stack overflow I was talking about. Sorry if <= looks terrible. http://lpaste.net/100888
12:15:32 <Iceland_jack> eacameron: No but generally companies have enough languages to support already and adding a new language/ecosystem/environment often requires permission, the non-Haskeller who needs to maintain that program later on might leave with a not-so-nice view of Haskell :)
12:15:38 <milfjord> diribative: ah, you didn't define compare
12:15:47 * ion sees http://anttisalonen.github.io/cgen/
12:16:16 <geekosaur> diribative: while it's not strictly necessary, most implementations let the definition of compare be defaulted. the default implements EQ by calling (==)
12:17:06 <milfjord> it's a set of mutually recursive definitions
12:17:17 <akahn> is there a version of map where the function that's being mapped over the list has both the list element and the index in the list of the current element?
12:17:32 <milfjord> akahn: zipWith f [0 ..] xs
12:17:43 <mm_freak> hi there
12:17:45 <akahn> ah, nice. thank you
12:17:46 <Iceland_jack> So if you believe non-Haskellers may maintain it you may want to change
12:17:46 <Iceland_jack>     whenM (not <$> doesDirectoryExist src) $ … where
12:17:46 <Iceland_jack>         whenM s r = s >>= flip when r
12:17:47 <Iceland_jack> to
12:17:49 <Iceland_jack>     dirExists ← doesDirectoryExist src
12:17:52 * ion also sees https://github.com/wavewave/fficxx
12:17:53 <Iceland_jack>     unless dirExists (throwError "source does not exist")
12:17:58 <Iceland_jack>  
12:18:02 <mm_freak> haasn: i'm happy to receive patches =)
12:18:24 <mm_freak> haasn: i have a feeling that people are actually using acme-schoenfinkel for real…
12:18:34 <BMeph> BBIAB: Have to restart my "Ween-Doze"... ;þ
12:18:35 <eacameron> Iceland_jack: yeah...I see that
12:18:37 <diribative> geekosaur: Thanks. I suppose that clears that up, then.
12:18:40 <Iceland_jack> they won't know what 'capital M suffix' means (understandably), and they'll see (>>=) as some linenoise
12:18:43 <eacameron> Iceland_jack: I'm trying to slowly work it in....
12:18:58 <Iceland_jack> eacameron: no problem :)
12:19:09 <eacameron> Iceland_jack: yeah..I have my worries
12:19:17 <eacameron> Iceland_jack: so far haven't gotten much traction :(
12:19:32 <mm_freak> it's a funny feeling to be the author of two actively used libraries, one of them originally intended as a bad joke =P
12:20:15 <ion> hah
12:20:18 <Iceland_jack> Well you don't want to ‘force’ a language into production just because it's your favourite, unless you need its benefits badly enough to warrant using it when nobody else knows it
12:20:30 <geekosaur> that is actually what I was trying to get at earlier. it is possible to define your own compare but you end up doing more work in most cases; you can get Eq and Ord by defining (==) and (<=) and everything else falls out from those, so that's the route usually taken
12:20:33 <dwcook> It looks like the Hackage website doesn't like Unicode source: http://hackage.haskell.org/package/acme-schoenfinkel-0.1.1/docs/src/Control-Category-Schoenfinkel.html
12:20:58 <prophile> dwcook: looks fine here
12:21:13 <mm_freak> Iceland_jack: i do that, too
12:21:20 <ion> Seems to work for me. Perhaps it doesn’t provide a hint about the charset and our browsers make different guesses.
12:21:30 <diribative> geekosaur: Understood. The Surreal numbers are probably not like most cases.
12:21:32 <dwcook> prophile, no "SchÃ¶nfinkel"?
12:21:33 <mm_freak> "huh?  what language is that?  it looks weird" — "uh, haskell"
12:21:36 <prophile> nope
12:21:52 <dwcook> Odd. I wonder where the problem is then.
12:21:55 <prophile> it's UTF-8, your browser must have interpreted something different
12:22:03 <ion> dwcook: What i said, probably. :-P
12:22:16 <dwcook> Ah, could be.
12:22:23 <mm_freak> dwcook: it's probably just server configuration…  haddock doesn't seem to specify the character set in its output
12:22:42 <eacameron> Iceland_jack: agreed, so far I've only been using it for non-core things, like little tools and such
12:22:44 <prophile> <?xml version="1.0" encoding="UTF-8"?>
12:22:46 <dwcook> Yyyep that's it. It's got an XML thing at the top? And an old doctype
12:22:47 <mm_freak> my browser uses UTF-8 by default, so it renders fine here, but many browsers use latin-1 by default
12:22:48 <prophile> is the first line of source of that page
12:23:01 <dwcook> Well maybe the latter doesn't hurt
12:23:11 <prophile> so the browser is in the wrong here
12:23:13 <eacameron> Iceland_jack: the nice thing about HS is that I can compile it and hand people exes and they're none the wiser
12:23:15 <eacameron> ;)
12:23:22 <mm_freak> but yeah, i live in europe, so i had to configure my firefox to do that…  it defaulted to latin-1
12:23:22 <prophile> no, take it back
12:23:29 <prophile> it's sending Content-type: text/html
12:23:34 <milfjord> prophile: <? is not valid in html
12:23:35 <dwcook> prophile, I don't think it should interpret XML things if it receives HTML content
12:23:36 <prophile> so the server is quite badly in the wrong
12:23:46 <prophile> dwcook: well, the document claims to be XHTML
12:23:46 <geekosaur> diribative, there is also that Eq is in some sense a more primitive operation; for example, complex numbers have Eq but you cannot meaningfully define Ord
12:23:47 <prophile> rather than HTML
12:23:47 <mm_freak> prophile: the XML declaration is not used for text/html
12:23:56 <prophile> the problem is the content-type is wrong
12:23:59 <prophile> document looks fine
12:24:10 <dwcook> So then the main problem is that the server sends the wrong content type
12:24:11 <prophile> which may be exactly what everyone's been saying
12:24:17 <Iceland_jack> eacameron: True but who will add the new features after you quit? :)
12:24:20 <mm_freak> prophile: if you deliver it as text/html it is interpreted as HTML rather than XHTML, regardless of the <?xml ?> instruction
12:24:38 <dwcook> mm_freak, yes but the XML directive is the only place it specifies it's UTF8
12:24:40 <prophile> mm_freak: precisely
12:24:51 <prophile> so the problem is that it should be content-type: application/xhtml+xml
12:24:52 <mm_freak> if you want it to be interpreted as XHTML, you have to actually deliver it as application/xhtml+xml, but then most versions of IE have trouble with it
12:25:08 <mm_freak> so that's probably why most documents are delivered as HTML anyway
12:25:15 <Iceland_jack> defining things like 'orM' to apply to a two-element list seems a little overkill anyway ;)
12:25:17 <mm_freak> dwcook: yeah, that's my point =)
12:25:18 <prophile> one would imagine you'd dig into the user-agent for that
12:25:47 <dwcook> So you're suggesting my browser is being lied to to appease IE
12:25:49 <mm_freak> prophile: this is one of the rare cases when the user agent actually performs correct behavior =)
12:25:56 <mm_freak> dwcook: pretty much
12:26:05 <dwcook> Great
12:26:14 <prophile> IMO the actual answer is not to use XHTML :)
12:26:28 <dwcook> Yeah that's what I was going to suggest :P
12:26:30 <mm_freak> well, XHTML is great, and there is actually XHTML5 =)
12:26:46 <mm_freak> and most of the time you would want to write XHTML anyway
12:26:51 <prophile> I've heard many arguments against XHTML
12:26:51 <ion> Reminds me of when bots abuse PRIVMSG to appease the broken default config in mIRC and Irssi at the expense of users of other clients and users of said clients who fixed the config.
12:27:31 <mm_freak> prophile: and i have many arguments against XHTML as well, but XHTML in this case refers to XHTML 1.* and 2.*
12:27:35 <diribative> geekosaur: For most other structures, Eq is more primative. But for the mathematical structure I'm building, equals is conventionally a coarser equivalence relation than...identical to, which I could implement with (deriving Eq) if I set things up right, but then == wouldn't be the coarser equivalence relation I want it to be.
12:27:40 * prophile looks for sources
12:27:40 <mm_freak> but XHTML5 is really just HTML5 + XML + namespaces
12:27:43 <mm_freak> so it's a good idea
12:27:57 <prophile> even in the HTML5 context I've seen arguments against XHTML
12:27:58 <mm_freak> it's pretty much just a syntactic subset of HTML5
12:28:06 <mm_freak> i'd be interested in those
12:28:19 <prophile> me too, yet neither my memory nor google are being forthcoming
12:28:45 <mm_freak> prophile: i can't really imagine any arguments against it, because it's really just a syntactic subset that forces you to use namespaces properly
12:29:03 <dwcook> It's not a subset if it's got XML directives, which aren't in HTML
12:29:12 <prophile> the content-type jiggery was an argument against it
12:29:15 <mm_freak> dwcook: they are optional
12:29:28 <prophile> as was something about parsing speed vs tag soup parsers, though I thought that was extremely suspect
12:29:35 <eacameron> Iceland_jack: I copied that from SO. ;) I thought the same thing
12:29:36 <mm_freak> prophile: yes, there are practical arguments against it, but that's not really XHTML's fault
12:29:36 * prophile hunts
12:29:47 <dwcook> A nice compromise here would be to also specify the page as UTF8 the HTML way
12:29:51 <prophile> mm_freak: practical arguments are what actually matters, no?
12:29:53 <mm_freak> prophile: parsing speed can actually suffer
12:29:56 <mm_freak> XML is hard to parse
12:30:00 <dwcook> Though for all I know someone thought of that already and decided against for some reason I can't imagine
12:30:56 <prophile> I remember reading a really good article though those and exceptions where one would want XHTML are all I can remember from it
12:31:01 <eacameron> Iceland_jack: yeah, no one will add features/fix bugs; but so far the tools aren't widely used, maybe even only by me. My hope is that I can make something valuable *enough* that people in my company start *wanting* to contribute...then I have won! but still waiting for that day
12:31:42 <mm_freak> prophile: the problem is the xmlns attribute, which applies not only to children, but to the very element it's part of
12:31:49 <mm_freak> prophile: <blah:blubb … xmlns:blah="…">
12:31:53 <eacameron> Iceland_jack: I was hoping for a 5 min video explaning ithngs like <$>, *M functios, *M_ functions, etc
12:31:54 <enthropy> eacameron: do you actually have a case showing all the alternatives that don't work for your situation?
12:31:59 <mm_freak> you don't really know what the element is, until you encounter the namespace attribute
12:32:41 <eacameron> enthropy: thus far, no; except that we use python heavily so if I want something quick and dirty *with* threads, python is not very good for that
12:33:08 <Iceland_jack> eacameron: Or you can just not use those functions and stick to do-notation which should be clear to any imperative programmer
12:33:48 <eacameron> Iceland_jack: yeah, that's always an alternative...but then I might as well write it in Python (sigh...) ;)
12:33:57 <Iceland_jack> But it feels like you're forcing the language on other people until they like it and want to learn it
12:34:13 <Iceland_jack> Python is a fine choice
12:34:31 <eacameron> Iceland_jack: "forcing" is a strong word; they don't *have* to use these tools. they're not necessary for our work
12:34:39 <mm_freak> Iceland_jack: when i'm the decisionmaker i usually force haskell upon people as well for new projects =)
12:34:42 <eacameron> Iceland_jack: gently suggesting maybe
12:35:01 <mm_freak> there is nothing wrong with that
12:35:08 <mm_freak> haskell is a sensible choice for many things
12:35:52 <Iceland_jack> Like I said, it depends on the company and I expect eacameron to be able to weight things themself
12:36:14 <mm_freak> and under my authority python is only allowed for code that does not end up in production =P
12:36:21 <mm_freak> build scripts, etc.
12:37:01 <Iceland_jack> Some companies have a list of allowed languages + strict compiler versions etc., some companies don't really care, …
12:37:02 <eacameron> Iceland_jack: it does depend; we're pretty free here; recently someone just up and started using Node.js; but Haskell scares people way more than JS/Ruby/Python/etc.
12:37:18 <eacameron> it's so different
12:37:28 <eacameron> they can't just pick it up in an afternoon like everything else
12:37:49 <Iceland_jack> Yes, and I'd argue you could change your code to make it less scary
12:37:57 <vanila> tell them haskell is like BASIC
12:38:06 <eacameron> Iceland_jack: most assuredly
12:38:17 <mm_freak> vanila: that will scare away JS/ruby/python/… fans ;)
12:38:31 <kadoban> vanila: so they completely lose interest immediately?
12:38:36 <Iceland_jack> then people try to insert a print statement into a pure function and give up!
12:38:56 <mm_freak> tell them it looks like perl =P
12:39:01 <mm_freak> unless noLogging (log "blah")
12:39:30 <Iceland_jack>     unless noLoggin $ log "blah"
12:39:30 <Iceland_jack>     => "wtf is $?"
12:39:44 <Iceland_jack> Then they get directed to ##bash :)
12:40:39 <Kreap> why isn't there any function in Data.List that does what you might intuitively guess what group does? A function called something like classify where classify "Mississippi" = ["M","iiii","pp","ssss"]
12:41:05 <ion> > (group . sort) "Mississippi"
12:41:05 <Iceland_jack> > group (sort "Mississippi")
12:41:06 <lambdabot>  ["M","iiii","pp","ssss"]
12:41:06 <lambdabot>  can't find file: L.hs
12:41:38 <Kreap> that works for strings, but does it generalise well?
12:41:47 <Iceland_jack> Kreap: What do you mean?
12:41:51 <Iceland_jack> @ty group . sort
12:41:51 <lambdabot> Ord a => [a] -> [[a]]
12:42:02 <julianb> Uhm hi... I was wondering about how to detect -and convert- encoding on a ByteString. It seems that there aren't any solutions for this
12:42:03 <Iceland_jack> works for any list of orderables
12:42:20 <Iceland_jack> > group (sort (map ord "Mississippi"))
12:42:21 <lambdabot>  [[77],[105,105,105,105],[112,112],[115,115,115,115]]
12:42:28 <milfjord> you can't really "detect" encoding
12:42:36 <kadoban> Kreap: It's not particularly performant with big lists, in that case you can usually do something with Data.Map.Strict's fromListWith and etc, but it's not as cute
12:42:37 <Kreap> How would you do something for an input like ["tsar", "rat", "tar", "star", "tars", "cheese"]  and an output like [["tsar", "star", "tars"],["rat", "tar"],["cheese"]]
12:42:46 <Kreap> where you want to group by a hash
12:42:55 <julianb> then how can you read say, a website?
12:43:17 <Iceland_jack> Kreap: What kind of hash?
12:43:17 <kadoban> Kreap: groupBy and sortBy, probably using 'comparing'
12:43:25 <milfjord> julianb: by looking at the encoding it specifies
12:43:26 <Iceland_jack> @ty groupBy work work
12:43:26 <lambdabot> Not in scope: `work'
12:43:27 <lambdabot> Not in scope: `work'
12:43:28 <Iceland_jack> oops
12:43:30 <Iceland_jack> @ty groupBy
12:43:30 <lambdabot> (a -> a -> Bool) -> [a] -> [[a]]
12:43:31 <kadoban> although...hash, actually i'm not sure that would work
12:43:37 <julianb> what I am actually interested in is converting a ByteString to a String (I'm fetching data through http)
12:43:59 <milfjord> julianb: Content-Type header
12:44:12 <mm_freak> julianb: you could review the text-icu package…  it probably has UTF-8 detection
12:44:24 <mm_freak> julianb: but detection should be your last resort
12:44:29 <kadoban> Kreap: if you're getting that complicated, why not use like Data.HashMap or something? Seems like a good idea
12:44:49 <julianb> alright, I'll check that out. Thanks!
12:45:09 <mm_freak> julianb: you should not do that when using HTTP
12:45:17 <mm_freak> julianb: HTTP gives you a content-type
12:45:47 <mm_freak> Kreap: Map Hash (Set Word)
12:45:51 <julianb> mm_freak, yeah, but isn't there any chance Content-Type is wrong?
12:45:51 <tel_> Anyone have any experience giving (Const b) an Alternative instance?
12:45:52 <mm_freak> from Data.Map and Data.Set
12:46:03 <milfjord> julianb: no
12:46:09 <dwcook> tel_, try to implement pure
12:46:16 <mm_freak> julianb: if it's wrong, then the server configuration is buggy
12:46:21 <milfjord> julianb: Content-Type is by definition correct
12:46:33 <milfjord> maybe the content is wrong, though
12:46:55 <benmachine> milfjord: that's silly
12:46:55 <mm_freak> julianb: you can safely assume it to be correct…  that's what most HTTP clients do
12:47:03 <benmachine> maybe
12:47:04 <tel_> dwcook I'm aware it's not possible with that type directly; I've been trying for something like Monoid b => Const (Rose b)
12:47:09 * benmachine catches up on conversation
12:47:23 <julianb> ok, seems fine. Also, is there any way to compare ByteString with String?
12:47:26 <shachaf> c_wraith: <<loop>> can happen with the threaded runtime.
12:47:36 <mm_freak> julianb: no (i'm lying, but believe it)
12:47:45 <milfjord> content type sniffing leads to browser exploits
12:47:46 <haasn> shachaf: when all threads are stuck in a white hole?
12:48:12 <tel_> dwcook I feel like it needs to be something like Semiring b => Alternative (Const b)
12:48:14 <Iceland_jack> julianb: There are many different ways of doing that since ByteStrings and Strings are quite different structures
12:48:20 <benmachine> julianb: there is more than one way to convert between bytestring and string, which is the problem
12:48:35 <c_wraith> shachaf: how does that work?  In my experience, the threaded runtime just hangs instead of spitting out <<loop>>
12:48:36 <shachaf> haasn: White holes? Where do those come up here?
12:48:52 <mm_freak> julianb: if you get a ByteString that you need to compare, you should have generated that other value as a ByteString in the first place
12:48:54 <shachaf> c_wraith: Should be enough to verify.
12:49:02 <mm_freak> julianb: alternatively interpret the incoming ByteString into a Text
12:49:06 <shachaf> c_wraith: I think it won't happen immediately but only during a GC.
12:49:07 <mm_freak> julianb: by using the Content-Type
12:49:10 <haasn> shachaf: I thought the threaded RTS replaces entered closures by a “while hole”, not a black hole; which only causes threads to hang when waiting on them
12:49:16 <mm_freak> julianb: remember that ByteString is /not/ text!
12:49:21 <mm_freak> it's an array of Word8
12:49:23 <haasn> white*
12:49:53 <benmachine> julianb: you could construct a String which was one bytestring when encoded one way and another when encoded another way
12:50:04 <benmachine> likewise, you can have bytestrings which decode to one string one way or another string another way
12:50:18 <shachaf> haasn: Why not a black hole?
12:50:23 <Iceland_jack> julianb: It seems like you're a bit unclear about encodings
12:50:31 <dwcook> tel_, have you verified that the functor/applicative/monoid laws hold there?
12:50:53 <julianb> well, I have a list of (ByteString, ByteString), where the fst is the header name, the second is the content. Hence I need to get the Content-Type before being able to retrieve the charset
12:51:02 <tel_> dwcook Nope, I'm just starting to take a look at this.
12:51:14 <mm_freak> julianb: first of all that is already wrong
12:51:14 <julianb> I think encoding for headers is ISO-8859-1
12:51:22 <milfjord> julianb: ascii
12:51:24 <mm_freak> julianb: it should be (CI ByteString, ByteString)
12:51:33 <mm_freak> julianb: with CI from the case-insensitive package
12:51:46 <mm_freak> julianb: then (==) will do the right thing for headers
12:51:47 <benmachine> mm_freak: that's just one way of implementing case-insensitivity
12:52:07 <julianb> mm_freak, you're right, its CI ByteString
12:52:07 <mm_freak> benmachine: regardless, ByteString is wrong
12:52:11 <dwcook> tel_, good place to start at least. I suspect you'll have problems with the monoid requirement of Alternative but I haven't checked
12:52:12 <benmachine> CI ByteString is kind of a nonsense idea in the first place
12:52:18 <mm_freak> it is
12:52:21 <milfjord> you can't talk about case without encoding
12:52:27 <dwcook> tel_, though I suppose it depends on what you want the instance for
12:52:29 <julianb> well... http://hackage.haskell.org/package/http-types-0.8.3/docs/Network-HTTP-Types-Header.html#t:ResponseHeaders
12:52:31 <mm_freak> CI ByteString assumes ASCII
12:52:48 <mm_freak> julianb: anyway, you can safely use 'lookup' from Prelude
12:52:49 <benmachine> I suppose that's reasonable in a sense
12:53:18 <mm_freak> benmachine: it's a tradeoff between speed and correctness…  i'd probably have implemented an opaque Header type for that
12:53:23 <mm_freak> but http-types is very transparent
12:53:34 <benmachine> mm_freak: mm, I think it's not obscene to do it either way
12:53:48 <tel_> dwcook Well, the general idea is that I'm representing a kind of parser as a free alternative and I'd like to be able to build a tree purely which provides information about what information is required in order to prevent failures
12:54:00 <mm_freak> well, exposing ByteString for text strings almost always calls for trouble =)
12:54:30 <erisco> I am just starting with arrows. How can I write an arrow instance that would allow me to perform this kind of optimisation? https://docs.google.com/drawings/d/1Cd1pxktyeH8A6YrQ3tKWpPTs3MFQ2x5zqaWPVVnvDqQ/edit?usp=sharing
12:54:39 <tel_> raise (\f -> Const (reqs f)) :: Reqs f => FreeA f a -> Const [Reqs] a
12:54:47 <tel_> is sufficient for applicatives
12:54:49 <c_wraith> shachaf: hmm.  It does indeed detect it only during GC passes.
12:54:53 <tel_> I'd like to generalize that to alternatives
12:54:55 <c_wraith> shachaf: is that new?
12:55:05 <shachaf> It's been that way for a few years at least.
12:55:12 <julianb> well, thanks for the insight. Will be trying to get this right
12:55:14 <erisco> one problem seems to be that you'd have to resort to dynamic typing to build the graph
12:55:18 <shachaf> I can't remember it not being that way, but I don't know.
12:55:23 <mm_freak> erisco: are you sure you want Arrow?
12:55:26 <c_wraith> Pfft.  A few years is new.  I know it didn't do that on GHC 6.10
12:55:32 <mm_freak> erisco: remember that Arrow wants you to implement 'arr'
12:55:45 <ion> yarr
12:55:50 <erisco> mm_freak, yes I know, which is what each node is representing
12:55:56 <erisco> some function A -> B
12:56:04 <erisco> and the edges are composition
12:56:10 <mm_freak> erisco: if it's really just functions, write a type for functions that exposes composition
12:56:32 <erisco> it is possible I am not understanding the usage of arrows correctly
12:56:45 <mm_freak> data Func :: * -> * -> * where Arr :: (a -> b) -> Func a b; Comp :: Func b c -> Func a b -> Func a c
12:57:18 <mm_freak> you can add more constructors to expose more of the structure
12:57:29 <tel_> dwcook tbh, I don't think I understand enough how that should work in order to implement it, but I'd at least like to see the space of options. If Semiring b => Alternative (Const b) is at least close to the right idea then I'll just experiment with it on example to learn more
12:57:51 <dwcook> tel_, I think I understand even less than you do :) I probably won't be of much help
12:57:57 <tel_> dwcook So I'm really just looking for ideas : )
12:58:00 <mm_freak> erisco: alternatively you can use a free-style approach =)
12:58:16 <mm_freak> write a functor Comp
12:58:21 <shachaf> Semiring b => Alternative (Const b)?
12:58:25 <erisco> mm_freak, is that a GADT you just defined?
12:58:30 <mm_freak> erisco: yes
12:58:36 <erisco> ah, I have not worked with those yet
12:58:40 <haasn> shachaf: hmm, I couldn't find any resource that mentions “white hole”. I wonder where I picked up the term from?
12:58:43 <benmachine> wouldn't you need Monoid?
12:58:46 <tel_> dwcook Ha—that's unlikely to be true, but I'm happy to believe there's a small chance I know what I'm doing here
12:58:50 <shachaf> I haven't seen most of the discussion up to now but I think you have to be careful there.
12:58:59 <benmachine> you need it for Applicative, anyway
12:59:03 <mm_freak> erisco: data Comp :: (* -> * -> *) -> (* -> * -> *) where Lift :: cat a b -> Comp cat a b; Compose :: Comp cat b c -> Comp cat a b -> Comp cat a c
12:59:15 <shachaf> haasn: "white hole" is a thing in GHC, but it doesn't mean "that thing we used to call black hole in the non-threaded RTS"
12:59:17 <mm_freak> erisco: that's probably even easier to implement
12:59:24 <shachaf> There are both black holes and white holes.
12:59:30 <tel_> benmachine Yeah... but I can make my own classes Monoid a => Semigroup a if I need
12:59:38 <mm_freak> erisco: and more powerful, because now you can expose the composition structure of other arrows like Kleisli
12:59:44 <benmachine> tel_: but I mean, conceptually
12:59:44 <tel_> benmachine This will likely always be private, probably my own Const type as well.
12:59:48 <haasn> shachaf: what are white holes?
12:59:53 <tel_> benmachine Oh, yeah, definitely
13:00:18 <prophile> http://en.wikipedia.org/wiki/White_hole
13:00:28 <erisco> mm_freak, okay thanks! I'll have to read about GADTs first
13:00:32 <benmachine> tel_: oh, I'm dense, was reading "semigroup"
13:00:37 <haasn> “I can't explain precisely what a WHITEHOLE means, but they're used for spin locks or wait-free synchronization in various places. For example, the MVar primitives are synchronized by the lockClosure spinlock routine, which uses WHITEHOLEs.”
13:00:42 <tel_> benmachine : )
13:00:53 <mm_freak> erisco: GADTs pretty much allow you to write the types of constructors (instead of just the arguments)
13:00:58 <tel_> benmachine I may have actually written that, if so, typo, apologies : )
13:01:10 <mm_freak> erisco: but that allows a few extra things…  in the type above there are implicit existentials =)
13:01:10 <shachaf> haasn: Spin locks, it looks like.
13:01:20 <benmachine> tel_: no, purely my imagination, I think
13:01:23 <tel_> benmachine actually, yeah, I literally just did right before you said that, haha
13:01:26 <mm_freak> erisco: data Maybe :: * -> * where Nothing :: Maybe a; Just :: a -> Maybe a
13:01:27 <benmachine> oh
13:01:27 <benmachine> ok
13:01:29 <benmachine> fair enough :P
13:01:32 <tel_> benmachine Monoid a => SemiRING a
13:01:36 <erisco> mm_freak, what does exponential mean in the abstract sense?
13:01:49 <benmachine> tel_: ah, yeah
13:01:52 <benmachine> oh well
13:02:04 <benmachine> we're both bad at algebraic nomenclature
13:02:08 <benmachine> which is reasonable because it's pants
13:02:14 <mm_freak> erisco: existentials…  in haskell it really just means a constructor type that does not show up as a type argument
13:02:32 <erisco> oh sorry... misread
13:02:35 <shachaf> That can describe universals too.
13:02:35 <tel_> benmachine very pants
13:02:41 <mm_freak> erisco: Comp :: Comp cat b c -> Comp cat a b -> Comp cat a c
13:02:57 <mm_freak> erisco: 'b' does not show up as a type argument of the resulting value
13:03:31 <tel_> Maybe here's a better question: does anyone know a good resource for reading about the debates around the Alternative laws?
13:03:32 <erisco> it looks like this is the magic necessary so that one does not have to resort to dynamic typing to build the graph
13:04:20 <mm_freak> erisco: resorting to Dynamic should not be necessary in general
13:04:58 <mm_freak> i believe that you can always go without existentials, but they are just a lot nicer in this case =)
13:05:07 <tel_> And, in particular, I'd love to hear a summary like "If you have Alternative f and imagine f is phantom in its parameter, then they're the same as the variation in different kind of Semirings"
13:05:12 <tel_> that'd be awesome : )
13:06:03 <tel_> mm_freak How can you get rid of existentials there? Where does the `b` go?
13:08:23 <Iceland_jack> tel_: For a simple example see
13:08:23 <Iceland_jack>     data Foo a where
13:08:23 <Iceland_jack>       Bar :: b -> (b -> a) -> Foo a
13:08:24 <Iceland_jack>  
13:08:30 <Iceland_jack> where 'b' is an existential
13:08:48 <Iceland_jack> You can use it with
13:08:48 <Iceland_jack>     apply :: Foo a -> a
13:08:48 <Iceland_jack>     apply (Bar x f) = f x
13:09:20 <joogi> is there a haskell offtopic channel?
13:09:20 <niotepx> te
13:09:30 <tel_> Iceland_jack Yeah, perhaps I misunderstood mm_freak's point. I thought he was saying you could express something like that without using an existential
13:09:32 <erisco> joogi, #haskell-blah
13:09:40 <mm_freak> tel_: i didn't really think this through, but:  Comp cat a b = cat a b + (λt -> (cat a b ^ cat t b)^(cat a t))
13:09:44 <joogi> erisco: ah thanks :)
13:10:45 <mm_freak> tel_: if cat = (->), this should be fairly easy to resolve
13:10:54 <mm_freak> but general cat i'm not sure
13:11:02 <mm_freak> but at least you can go from existential to rank-1
13:11:21 <mm_freak> uhm
13:11:22 <mm_freak> rank-2
13:11:29 <tel_> mm_freak Ooh, that's interesting
13:11:33 * mm_freak always counts from zero =)
13:13:09 <n4l> im trying to do a union of two lists in ghci....
13:13:27 <n4l> [ x | x <- [1..], x `elem` [1,2,3,4] || x `elem` [2,4,6,8] ] prints out [1,2,3,4,6,8
13:13:31 <n4l> and hangs.
13:13:39 <mm_freak> n4l: \xs ys -> F.toList (S.fromList xs `S.union` S.fromList ys)
13:13:46 <mm_freak> where S = Data.Set, F = Data.Foldable
13:13:55 <milfjord> n4l: what did you expect it to do?
13:14:27 <levi> n4l: It's continuing to look for elements in the infinite list you gave it that satisfy your critera.
13:14:31 <mm_freak> or perhaps nicer…
13:14:39 <mm_freak> \xs ys -> F.toList (S.fromList xs <> S.fromList ys)
13:14:44 <mm_freak> =)
13:14:51 <n4l> milfjord: was expecting [1,2,3,4,6,8]...
13:15:04 <milfjord> n4l: but you're scanning the infinite list [1 ..] for matches
13:15:10 <milfjord> n4l: why do you expect it to stop?
13:15:23 <mm_freak> n4l: is 1 an element of [2..]?
13:15:23 <n4l> milfjord: im a noob
13:15:52 <n4l> so what the most haskell way of doing this?
13:15:52 <Iceland_jack> > union [1,2,3,4] [2,4,6,8]
13:15:53 <lambdabot>  [1,2,3,4,6,8]
13:16:02 <Iceland_jack> For small lists, 'union' is good enough
13:16:18 <[2]grant> In parsec, what's the best way of saying "return all of the remaining string"
13:16:24 <mm_freak> n4l: the haskell way is not to use lists here =)
13:16:26 <[2]grant> Of course "many anyChar" is easy
13:16:34 <[2]grant> but is there a more efficient way?
13:16:50 <n4l> mm_freak: oh?
13:16:53 <levi> n4l: Haskell is not actually very smart, despite some appearances to the contrary sometimes. It still only does what you ask it to do, and you asked it to search an infinite list without giving it specific ending criteria.
13:17:03 <Iceland_jack> mm_freak: Not use lists? The language is called LISP for a rea… no nvm
13:17:05 <mm_freak> n4l: but if you use lists, probably the easiest method is to just concatenate the two lists and then optionally perform a 'nub' pass
13:17:25 <mm_freak> > nub ([1..5] ++ [3..10])
13:17:27 <lambdabot>  [1,2,3,4,5,6,7,8,9,10]
13:18:11 <mm_freak> n4l: anyway, there is a Set type in Data.Set that is designed for single-occurrence sets
13:18:19 <mm_freak> they are represented as a tree internally, so very fast
13:18:30 <levi> n4l: Taking a look through the docs for Data.List (and the Prelude, of course) will reveal all sorts of handy general-purpose tools that will save you a lot of time.
13:18:38 <mm_freak> n4l: and you get a predefined 'union' function for those
13:18:41 <Iceland_jack> mm_freak: Why is the 'nub .: (++)' approach better than Data.List.union?
13:18:58 <mm_freak> Iceland_jack: mainly because i didn't even know that there is a predefined 'union' for lists =)
13:19:10 <Iceland_jack> oh :) never mind
13:20:59 <n4l> thanks!
13:21:33 <osa1> can anyone point me some example alex+happy parsers with position reporting in errors?
13:21:47 <mm_freak> perhaps we should finally start making "::" less rigid =)
13:21:53 <osa1> there are lots of examples but all of uses "basic" wrapper in lexer, so no position reporting in errors..
13:21:56 <Iceland_jack> osa1: Is the GHC parser too complicated?
13:22:06 <mm_freak> type Set a = a -> *
13:22:07 <mm_freak> =)
13:22:45 <osa1> Iceland_jack: I considered that but looked to complicated.. I'll check that again if I can't find any other programs.
13:23:41 <erisco> hm, GADTs for dummies is fairly effective for demonstrating the concepts
13:23:53 <Iceland_jack> mm_freak: Hm, I was wondering if there are any uses for capitalized identifiers at the beginning of a line
13:24:06 <levi> osa1: I'm not sure if you're set on using alex+happy, but there are a lot more examples out there for parser combinator libraries and probably a lot more people with helpful knowledge here.
13:24:11 <Iceland_jack> but sadly it seems there is for stupid things like
13:24:11 <Iceland_jack>     True = True
13:24:23 * hackagebot snaplet-stripe 0.2.0 - Stripe snaplet for the Snap Framework  http://hackage.haskell.org/package/snaplet-stripe-0.2.0 (LukeHoersten)
13:24:35 <Iceland_jack> wait.. why does
13:24:35 <Iceland_jack>     True = False
13:24:35 <Iceland_jack> even compile..
13:25:15 <Iceland_jack> I was wondering if it could be hijacked for type families
13:25:16 <Iceland_jack>     IsZero (n :: Nat) :: Bool
13:25:16 <Iceland_jack>     IsZero 0 = True
13:25:16 <Iceland_jack>     IsZero n = False
13:25:16 <osa1> levi: I know, I'm using parsec for years. I just want to use happy for this particular grammar I need to parse right now. (it's full of left recursive productions and even if I fix these I need to place try's very carefully otherwise parsing time gets too high)
13:25:18 <Iceland_jack>  
13:26:37 <k00mi> Iceland_jack: why shouldn't that compile?
13:26:48 <osa1> basically it's very hard to convert grammar to LL(1) and so it's hard to parse it using parsec(without having very inefficient parser, of course. otherwise I can place try's everywhere after eliminating left recursive productions)
13:27:25 <Iceland_jack> k00mi: What is it defining?
13:28:36 <osa1> I already wrote the alex lexer that annotates every token with position information but now I can't use it in happy :-)
13:29:22 <erisco> osa1, pita isn't it? I hear your pains
13:30:37 <osa1> yup
13:31:24 <osa1> I wish we had a GLR parser combinator library :)
13:31:34 <erisco> osa1, we do
13:31:36 <k00mi> Iceland_jack: nothing, but a pattern match doesn't have to define anything
13:31:41 <osa1> erisco: where?
13:31:48 <mm_freak> Iceland_jack: try this:  x@True = False
13:31:50 <k00mi> and True = True doesn't define anything either for that matter
13:31:51 <mm_freak> then evaluate x
13:32:01 <erisco> osa1, um, actually I am not 100% sure where it is... one of my profs and his grad students developed it
13:32:06 <mm_freak> True = False is the same thing, except that you're not giving it a name =)
13:32:20 <erisco> osa1, oh sorry you said LR... misread
13:32:22 <osa1> erisco: yeah probably lots of people developed it (including me). but none of them is usable.
13:32:22 <mm_freak> so you're defining something you can't refer to
13:32:25 <Iceland_jack> I see, never thought doing that
13:32:28 <erisco> for some reason my sight reading is off today
13:32:40 <osa1> erisco: yeah, I mean GLR. even happy had option for GLL I think.
13:32:42 <Iceland_jack> I guess this breaks my hypothetical syntax for type families
13:32:45 <Iceland_jack> too bad
13:32:51 <erisco> yeah his is top-down
13:32:54 <osa1> yup, it parses GLR http://www.haskell.org/happy/doc/html/index.html
13:33:02 <osa1> sorry, GLL
13:33:55 <osa1> happy actually looks good .. the problem is I have no idea how to wire my location-annotating lexer to it.
13:33:56 <erisco> osa1, why GLR? I want to point out that I was able to make a general top-down parser that efficiently does left recursion
13:34:20 <osa1> erisco: can you share it?
13:34:25 * hackagebot bytestring-lexing 0.4.3.1 - Parse and produce literals efficiently from strict or lazy bytestrings.  http://hackage.haskell.org/package/bytestring-lexing-0.4.3.1 (WrenThornton)
13:34:26 * hackagebot data-fin 0.1.1 - Finite totally ordered sets  http://hackage.haskell.org/package/data-fin-0.1.1 (WrenThornton)
13:34:28 * hackagebot prelude-safeenum 0.1.1 - A redefinition of the Prelude's Enum class in order to render it safe.  http://hackage.haskell.org/package/prelude-safeenum-0.1.1 (WrenThornton)
13:35:07 <osa1> erisco: damn I completely confused that terms. I'm looking for GLL because it's possible to have combinator library for it .. unlike GLR parsers.
13:35:17 <osa1> erisco: I prefer combinators over generators.
13:35:53 <erisco> osa1, I wrote it for my undergrad project. I could upload it... it is not ready for practical use but you could adapt the concept I developed for left-recursion if it appeals
13:35:56 <osa1> and I'm looking for "generalized" ones because most of the time all I want to do is to have a prototype very fast, I don't care about run times very much and generalized parsers look good for this.
13:36:33 <osa1> erisco: I guess it's memoizing parser calls with locations that the parser is called, right?
13:36:54 <erisco> osa1, my combinators are exponential on ambiguous grammars because I did not do any memoisation (I didn't even know monads at that point)
13:37:33 <osa1> oh, you handle left-recursion without memoizing? it sounds interesting, I'd like to see it.
13:37:41 <erisco> yes I do
13:38:56 <jody2323> any new library available for linear programming (besides hmatrix-glpk)?
13:39:05 <erisco> osa1, sure just give me a few minutes to dig it up and upload it
13:39:09 <jody2323> that preferably use vectors
13:39:12 <osa1> okay
13:42:05 <osa1> I guess I'll send an email to haskell-cafe about example alex+happy program that uses location-annotated tokens and locations in parse errors
13:51:32 <erisco> osa1, okay all done :)
13:51:39 <prinsen> Is there any way of avoiding double quotes when doing encode on a Data.Aeson.Value(String)?
13:52:52 <erisco> osa1, https://github.com/erisco/acrid-parser you can read doc/paper.pdf for my explanation of what is going on. you should find it relatively an easy read ... I was only starting to learn Haskell
13:53:18 <erisco> I imagine there are lots of good things I could improve upon now... including memoisation, because then it could parse ambiguous grammars in polynomial time
13:54:27 * hackagebot language-c-comments 0.3 - Extracting comments from C code  http://hackage.haskell.org/package/language-c-comments-0.3 (GeoffHulette)
13:54:39 <erisco> osa1, section 4 is where you want to begin if you want the quick answers
13:55:02 <erisco> otherwise I spend time making sentence and parse tree generators for languages
13:57:52 <osa1> erisco: thanks, I'm looking now
13:58:37 <erisco> and examples of what the left-recursive executable grammars look like are in doc/examples.hs
13:59:27 * hackagebot stm-conduit 2.2.2 - Introduces conduits to channels, and promotes using  conduits concurrently.  http://hackage.haskell.org/package/stm-conduit-2.2.2 (ClarkGaebel)
14:02:30 <haasn> Can I use a cabal sandbox to sandbox a new version of Cabal that I want to use to build my package with? (inside the cabal sandbox)?
14:02:56 <ion> Xzibit?
14:03:27 <haasn> ion: :)
14:04:51 <jle`> i'd imagine you can just use the cabal binary in the .cabal-sandbox directory
14:05:05 <BMeph> haasn: SUP DAWG I HERD U LIEK... ;þ
14:08:30 <erisco> applicative requires functor, and this is justified because given an applicative alone you can implement functor
14:08:50 <erisco> why does arrow require category? I cannot figure out how you would implement composition using arr and first
14:09:10 <osa1> erisco: I just skimmed through the paper and it looks really interesting. I need to study the part where you moved from matching the input by generating all the language and searching in generated sentences to actually building a parse tree.
14:09:45 <jle`> erisco: i think it is the idea that arrow is a "specialized category", or category + more
14:09:46 <jle`> but
14:09:55 <erisco> osa1, happy to hear :) thanks
14:10:29 <jle`> yeah
14:10:37 <haasn> jle`: oh I can build cabal-install inside a sandbox against an add-source'd version of Cabal
14:11:04 <jle`> Arrow doesn't make sense without Category because iirc the arrow laws involve arrow composition
14:11:18 <erisco> jle`, okay, good to know, thanks
14:11:28 <erisco> just wanted to make sure I was not missing something there
14:11:29 <b0bbi10> hello, I know the answer to that question is somewhat biased in here, but is the (current) hype around Haskell justified and is it worth learning? do you have some objective thoughts on that topic?
14:11:33 <jle`> it's sort of like Applicative is a Functor + more
14:11:41 <jle`> Monad is Applicatie + more
14:12:11 <Hafydd> b0bbi10: where did you learn about Haskell's "current hype"?
14:12:51 <parc> personally i feel like a better programmer since ive been learning haskell. kind of hard to have objective thoughts on the topic though
14:13:25 <b0bbi10> Hafydd: it is being mentioned many times these days on the Internet and often recommended as 2nd or 3rd programming language to learn
14:13:51 <jle`> b0bbi10: it isn't too much effort to learn in either case, just give LYAH a quick read through
14:14:06 <Hafydd> I think the hype surrounding LYAH is unjustified.
14:14:19 <Hafydd> It's annoyingly written.
14:14:37 <erisco> b0bbi10, objectively the job prospects on Haskell alone are non-existent (at least local to me -- and I hear similarly from others)
14:14:38 <parc> there's also real world haskell, and another book that just came out that leans towards the practical side...
14:14:56 <erisco> b0bbi10, but objectively functional programming can teach you abstracts that you will learn nowhere else
14:15:03 <erisco> teach you abstractions*
14:15:22 <dmj`> jle`: not too much effort ay :)
14:15:38 <Hafydd> It will also teach you abstracts (of academic papers). Huheuehauh.
14:15:45 <erisco> :P
14:15:46 <jle`> i really think that Haskell is a good language in its own right.  you get exposed to compiled performance, great type safety with no explicit type overhead, non-strictness...
14:15:51 <jle`> dmj`: :P
14:16:06 <parc> beginners haskell i think? it seems decent, and covers a lot of practical libraries, though it could have used a more thorough editor.
14:16:15 <jle`> Hafydd: not meaning to push the hype, just wanted to give a quick resource :)
14:16:39 <jle`> b0bbi10: also functional programming too
14:16:42 <jle`> in addition to all of those
14:16:51 <erisco> osa1, I will be gone for a a short while. If you have any questions please PM me, because I'll likely lose your message in this channel
14:17:02 <parc> beginning haskell: a project based approach
14:17:07 <dmj`> jle`: completely agreed, haskell is for people who like algorithms, protocols, compilers, beauty, etc.
14:17:20 <parc> though LYAH and real world haskell are both available free online, so they have that for them
14:17:25 <osa1> erisco: okay.
14:17:30 <jle`> i think...one thing is...in haskell the style is you say how things 'are', and you have abstractions that are powerful enough to make it happen
14:17:38 <b0bbi10> jle`: I would learn Haskell for that functional paradigm aspect. I know that here in my region (Germany) I haven't seen any job description that requires Haskell
14:18:08 <dmj`> I say cut the bs and go straight to the typeclassopedia
14:18:11 <jle`> instead of saying 'i want to double every element in this list', instead of low-level looping through and incrementing a counte rand doubling every element, you can just say "map (*2) list"
14:18:18 <b0bbi10> so I would just learn it for the sake of knowing and/ or improving my programming skills ;)
14:18:22 <jle`> which isn't really a "do this"
14:18:24 <jle`> it's more of
14:18:30 <jle`> "this is what that thing looks like."
14:18:41 <Maerten> Hi, beginner question here: if i have a Haskell record with 10 fields (fieldA up to fieldJ), and i want to copy all fields+values to a new record, of a different type, that could contain 20 fields (fieldA up to fieldT), how would that work? I come from PHP and JS, and I would do that with a quick loop..  I hope my question is clear enough. Anyone here who has a suggestion? Thanks!
14:19:04 <jle`> and then you have abstractions are able to optimize what you want into things that work at the low level
14:19:29 <jle`> the advantage is that when you don't have to worry about low-level stuff, you are freed with more time to just think about what your code is supposed to do at a high level
14:19:48 <jle`> and using abstractions, think in new ways and approach problems in ways you have not dared of before.
14:20:16 <jle`> it's a lot easier to phrase ideas and "think" about the problem at hand in C even, than in Assembly
14:20:24 <jle`> it can be done either way
14:20:33 <dmj`> Maerten: data Person = P { pName :: String }, data Dog = D { dogName :: String }. fromPersonToDog = let a = P "dude" in D (pName a).
14:20:39 <jle`> but if your abstraction implementatoins are trustworthy, you also have less room for bugs
14:20:40 <k00mi> Maerten: why do you have so many records? are they all of the same type?
14:21:00 <dmj`> Maerten: there is a simple example of taking the values out of one record and putting them into another
14:21:02 <jle`> haskell will teach you functional paradigm stuff but it actually is a lot more
14:21:34 <jle`> it'll teach you a lot more than just functional programming
14:21:41 <dmj`> jle`: preach
14:21:46 <Maerten> dmj`: thanks, so i'd have to specify each field i want to copy? there is no copyAllFields function?
14:22:04 <jle`> Maerten: copy them to what?
14:22:06 <Twey> Maerten: You wouldn't, because neither PHP nor JS has records — only Maps.  Perhaps you ought to be using a Map for this too?
14:22:12 <prophile> Maerten: what fields are there that are common?
14:22:15 <k00mi> Maerten: you're using records in a way they aren't ment to be used
14:22:18 <prophile> what actually are these two records
14:22:21 <dmj`> Maerten: I'd really think about what you're trying to do. What are you trying to do btw
14:22:30 <jle`> you can't have two records with fields having the same name
14:22:34 <jle`> you do probably want a Map
14:23:50 <dmj`> if you want to be sexy you could use RecordWildCards let Person{..} = a in D pName
14:23:57 <Twey> Maerten: The closest thing you'd be used to that's like a record would be a PHP ‘object’.  That's still a Map, but it's at least dressed up to look like a record.
14:24:04 <Maerten> k00mi: i am working with Database.Persist to retrieve some records, but i want to make some changes on the objects (adding some data to each object), and then store it back into the DB. the Database.Persist datastructure doesnt allow me to add extra fields so i thought i'd make a seperate Record
14:25:22 <Twey> Maerten: Is this some kind of zany NoSQL database?
14:25:32 <jle`> Persistent is SQL
14:25:39 <jle`> but
14:25:44 <jle`> this is a migration
14:25:50 <Twey> You can't just add fields to rows in SQL-based databases, as far as I know (though I wouldn't be surprised if it made it into MySQL some day)
14:25:51 <jle`> you're changing the number of columns
14:26:04 <k00mi> Persistent can handle non-SQL databases aswell
14:26:10 <jle`> ah
14:26:23 <dmj`> speaking of SQL, this project looks sweet: Groundhog: https://github.com/lykahb/groundhog
14:26:37 <jle`> this does look a bit like a migration
14:26:40 <jle`> (is it?)
14:26:50 <dmj`> looks like persistent
14:27:08 <jle`> oh wait
14:27:11 <jle`> gr
14:27:13 <jle`> sorry
14:27:24 <jle`> misread Persist asn Postgres
14:27:27 <jle`> it must be too early
14:28:22 <enthropy> on the topic of records http://lpaste.net/100889
14:29:15 <enthropy> I'd like to avoid having to list the field names again
14:29:28 <Maerten> it's a mysql database. the script i'm trying to convert from PHP to Haskell just loads a bunch of lets say pageviews on a webpage from the database, and then it adds some metadata to each pageview, like "should be counted as a visitor", or "this visit should be ignored", etc. all this extra data will be used to in the end to make a summary: numbers of visits, etc. The summary will then be stored in the Database, as well as the metadata
14:29:29 <Maerten> will be written back to the original table with pageviews, so the analysis doesnt have to be run again.
14:29:30 * hackagebot snaplet-postmark 0.2.0 - Postmark snaplet for the Snap Framework  http://hackage.haskell.org/package/snaplet-postmark-0.2.0 (LukeHoersten)
14:30:39 <Maerten> so the original data is modified, and also new data (the summary) is created. that's why i wanted to use Database.Persist for a Pageview entity, and also a PageviewAnalysis Record, that can contain extra fields
14:30:47 <Twey> dmj`: Pretty nice library!
14:31:31 <enthropy> Maerten: put the smaller record inside the one that has extra fields
14:31:54 <Maerten> mind=blown
14:32:26 <Maerten> thanks enthropy
14:32:32 <enthropy> that leads to lots of pain if you want to update things in the smaller record
14:32:46 <Twey> Maerten: So you have a ‘pageviews’ table, and you want to load an object from a ‘pages’ table, get all its related ‘pageviews’, calculate some data, and store the result back into the appropriate ‘pages’ row?
14:32:46 <dmj`> Twey: I know right? Gonna play with it a little :)
14:33:02 <Twey> dmj`: Even does migrations!
14:33:46 <Maerten> Twey: yes and also write back to the pageviews table, if a pageview has (for example) been counted as a valid pageview, or if it was a duplicate, etc
14:33:58 <Twey> Maerten: Aha!
14:34:16 <enthropy> since you end up writing stuff like:   outer' = outer { innerRecord = innerRecord outer { innerField = f (innerField (innerRecord outer)) }}
14:34:19 <dmj`> Twey: yea, It might need more publicity. Has been on reddit 3 times tho
14:35:00 <Twey> Maerten: Okay, so you have *optional* fields.  So you might have a ‘Maybe PageViewStatus’ field in your PageView record, and a ‘Maybe PageViewCount’ field in your Page record
14:35:03 <enthropy> which if you had lens for those fields would be    outer' = outer& innerRecord . innerField %~ f
14:36:12 <edwardk> and then if you had used makeClassy to enable the direct use of innerField it would be outer & innerField %~ f  ;)
14:36:17 <Twey> Maerten: Alternatively, you can have two different data types, one of which stores e.g. the Page without the PageViewCount, and one of which stores a Page and a PageViewCount
14:36:28 <Maerten> enthropy: i guess that could work, just need some kind of datatype that doesnt require me to duplicate all kind of things. thanks
14:36:55 <Twey> Maerten: And then persuade Persist to store them in the same table, which I assume it can do but I don't know how :þ
14:37:28 <Twey> Maerten: I would probably go for the former for simplicity's sake, in your case
14:37:39 <dmj`> just use acid-state
14:37:41 <Twey> Maerten: Though the latter is probably better design, strictly speaking
14:37:45 <dmj`> make life easier for you
14:37:48 <Maerten> Twey: yeah that's a good idea. the thing is that i want to also store some intermediate data on the record that will not get written to the database, so i guess a Record with the Entity stored inside it will work
14:37:58 <Maerten> i'm trying to learn haskell it doesnt need to really make sense what i'm doing right now
14:37:59 <Maerten> :D
14:38:04 <Twey> Maerten: Yeah, that's absolutely fine
14:38:20 <Twey> Maerten: You can probably even put the data directly in the record and just tell Persist to ignore it
14:38:38 <Maerten> yeah that would be better but i couldnt find how
14:39:04 <Maerten> i just found out that persist uses Records anyway, thats why i came here to ask how to copy the fields to another record..
14:39:25 <Twey> It's probably better to separate them, but could get messy if you don't know how to use lens yet
14:40:32 <Maerten> hm well i'll try some of the suggestions you all gave me
14:40:42 <Maerten> thanks a lot!
14:41:23 <haasn> jle`: so I herd you like ~/dev/ghc/libraries/Cabal/cabal-install/.cabal-sandbox/bin/cabal haddock --hyperlink-source --with-haddock=/home/nand/dev/haddock/.cabal-sandbox/bin/haddock ...
14:42:53 <Twey> Maerten: If you did go down that route, I think you'd do it by writing your own instance of PersistEntity that didn't produce a SomePersistField for the record field in toPersistFields: http://hackage.haskell.org/package/persistent-1.2.3.0/docs/Database-Persist-Class.html#g:5
14:44:28 <Maerten> Twey: ok, i'll try that first.
14:45:01 <Twey> Maerten: I think just wrapping your record in another record would be the better and easier option
14:45:53 <dmj`> If I have 2 pkg's, one for the app, one for the types and I keep adding types etc that the app depends on. What's the best way to rebuild the app or manage that scenario? ghc-pkg unregister types, cabal install, the cd app and cabal build gets old
14:46:03 <dmj`> then*
14:46:22 <Maerten> Twey: ok i'll try that when creating a custom persistentity instance fails :-)
14:54:58 <andkore> Does anyone know of a good overview of types in Haskell?
14:55:12 <niotepx> dmj`: Did you want to keep the older versions of the "types"?
14:57:01 <b0bbi10> speaking of LYAH: "    doubleSmallNumber' x = if x > 100 then x else x*2 + 1  " that piece of code would only add one if 'x' isn't greater than 100. does it have something to do with operator precedence? otherwise I can't see why that would behave the way it does
14:57:53 <ion> if…then…else… is syntax
14:58:22 <dmj`> niotepx: no
14:58:50 <dmj`> andkore: typeclassopedia, http://www.haskell.org/haskellwiki/Typeclassopedia
14:59:40 <andkore> dmj`: I actually just meant the... kinds of types that are available in the language, not what's in the standard library
15:00:11 <b0bbi10> ion: one would only be added if 'else x*2' is evaluated. when x > 100, will x immediately be returned (and hence one will not be added) ?
15:00:14 <haasn> andkore: the haskell report
15:00:22 <haasn> andkore: it's very readable here, it has a section of the Prelude
15:00:32 <haasn> well, it's also very readable everywhere else
15:00:35 <andkore> OK, I'll check that out, thanks.
15:00:54 <andkore> I mean Haskell, not being OO, only really has functions and what you feed into functions.
15:01:03 <ion> b0bbi10: That’s parsed as if (x > 100) then (x) else (x*2 + 1)
15:01:08 <andkore> My grasp of the various kinds of data types is very weak.
15:01:40 <b0bbi10> ion: ah ok. got it, thanks
15:02:29 <niotepx> dmj`: I would say just write a script to handle that. Though, in my limited knowledge of cabal, I don't think there are many other ways, and I know them not.
15:02:50 <b0bbi10> Haskell is strange and weird at the beginning :/
15:03:18 <k00mi> andkore: no, haskell has other things than functions aswell, you can define your own datatypes etc.
15:03:36 <ion> b0bbi10: Compared to the first language you ever learned from the other group of closely related languages?
15:03:57 <andkore> k00mi: right. functions and stuff you pass into functions.
15:04:12 <andkore> my grasp of the everything falling into the second category is weak.
15:05:22 <niotepx> andkore: Here is what I used to learn datatypes: http://learnyouahaskell.com/making-our-own-types-and-typeclasses
15:05:45 <b0bbi10> ion: yep. learned a bit of C, then moved to Java and Python
15:05:45 <andkore> niotepx: thanks.
15:06:00 <niotepx> And then, just play with it. Try building some simple ones.
15:06:08 <Iceland_jack> b0bbi10: You're going to experience a lot of different things in Haskell, that doesn't mean worse though :)
15:06:09 <niotepx> andkore: no prob
15:06:38 <k00mi> andkore: it's also important that, in haskell, functions are also things you can pass to other functions
15:06:48 <b0bbi10> ion: although I have to say that the transition from C (imperative) to Java (OO) wasn't that much of a stress (probably because imperative and OO are 'more natural?)
15:07:19 <b0bbi10> Iceland_jack: looking forward to that challenge ;)
15:07:20 <andkore> k00mi: right. What I said incorrectly implied that that's not the case.
15:07:28 <Iceland_jack> b0bbi10: That's the spirit!
15:09:06 <__pyon__> I am reading the documentation for Control.Applicative, and this has been bugging me for quite a while. Doesn't "f <$> x = pure f <*> x" automatically imply the first two laws (identity and composition)?
15:09:21 <kuribas> I tried importing a module twice, once qualified, and once not qualified.  It seems to work!  Is this supported by the standard?
15:09:50 <Twey> kuribas: Yes
15:10:10 <kuribas> Twey: nice!  This way I can use qualified only for duplicate names.
15:10:31 <Twey> Yep
15:10:47 <mzero> any of the maintainers for haskell-src around?
15:11:18 <__pyon__> kuribas: Yeah, it is not uncommon to import a module unqualified, hiding duplicate identifiers, and then import it again qualified, for the duplicate identifiers only.
15:11:57 <niotepx> :t <*>
15:11:58 <lambdabot> parse error on input `<*>'
15:12:07 <__pyon__> :t (<*>)
15:12:08 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
15:12:23 <niotepx> __pyon__: Ah, thanks.
15:12:41 <milfjord> :t (id <*>)
15:12:42 <lambdabot> ((a -> b) -> a) -> (a -> b) -> b
15:13:40 <__pyon__> :t (pure id <*>)
15:13:41 <lambdabot> Applicative f => f b -> f b
15:13:41 <milfjord> that doesn't seem logically sound
15:14:07 <n4l> I can't get ghci multilien to work, tried all the examples on stackoverflow.
15:14:10 <n4l> Prelude> :set +m
15:14:11 <n4l> Prelude> let addTwo :: Int -> Int -> Int
15:14:11 <n4l> Prelude| addTwo a b = a + b
15:14:11 <n4l> <interactive>:16:1: parse error on input `addTwo'
15:14:23 <geekosaur> indentation still matters
15:14:27 <n4l> single line works fine
15:15:01 <n4l> geekosaur: two spaces?
15:15:18 <__pyon__> n4l: the second "addTwo" has to be exactly below the one above, me thinks.
15:15:21 <milfjord> you don't seem to know how indentation works in haskell
15:15:29 <geekosaur> 4, presumably. same column position as the first instance of addTwo
15:15:59 <Iceland_jack> n4l:
15:16:00 <Iceland_jack> ghci> let addTwo :: Int -> Int -> Int
15:16:00 <Iceland_jack> ghci|     addTwo a b = a + b
15:16:00 <Iceland_jack> ghci|
15:16:03 <Iceland_jack> ghci> addTwo 2 4
15:16:06 <Iceland_jack> 6
15:17:45 <n4l> thank! reading the indentation article...
15:23:21 <ij> By what factor is folding (+) [Integer] would be slower than [Word32] or [W16]?
15:24:34 <copumpkin> ij: measure it and find out!
15:24:39 <c_wraith> ij: benchmark.  It's usually pretty small of a difference, unless the numbers are too big to fit in a native word
15:24:44 <copumpkin> ij: criterion is an amazing package in haskell if you haven't used it
15:25:35 <joneshf-laptop> is there a standard data type that will accumulate failures while also ignoring them?
15:25:38 * ij opens criterions docs.
15:25:58 <copumpkin> ij: it's pretty lightweight and blows other benchmarking tools out of the water
15:26:02 <c_wraith> ij: the Criterion.Main module has all you need for simple stuff
15:26:16 <joneshf-laptop> like: foo >>= bar >>= baz, if bar fails, i get to know how it failed, but foo and baz still do their thing
15:26:37 <ij> If baz can still work, those are just warnings, not errors.
15:27:08 <c_wraith> joneshf-laptop: that implies baz needs the output from bar.  If bar failed, how is it producing output?
15:27:26 <joneshf-laptop> s/>>=/>>/g
15:27:29 <joneshf-laptop> :)
15:27:46 <kuribas> A writer monad maybe?
15:28:06 <ij> That changes things. :)
15:28:16 <c_wraith> Oh.  If you want to do it with an Applicative interface, there's a package that does that.  validations?
15:29:17 <c_wraith> yeah, the Validation data type from http://hackage.haskell.org/package/validation-0.3.1/docs/Data-Validation.html
15:29:57 <c_wraith> err, AccValidation is the one you want
15:30:08 <c_wraith> it accumulates errors, rather than just taking the first on
15:30:09 <c_wraith> e
15:31:30 <joneshf-laptop> c_wraith, oh nice!
15:31:40 <joneshf-laptop> c_wraith, thanks
15:31:40 <edwardk> c_wraith: alas such a thing can't extend to a nice monad =(
15:32:31 <c_wraith> edwardk: nope. It needs less flexibility than Monad provides
15:35:13 <mzero> coding with ragtime music in the background is rather amusing
15:38:14 <Flonk> Does anyone know when exactly I can omit the parentheses of a \lambda term? "let u = \x -> succ x in u 4" seems to parse fine whereas "\x -> succ x $ 4" doesn't
15:39:21 <Clint> Flonk: are you asking about the precedence of $ ?
15:40:45 <k00mi> Flonk: the lambda generally includes the rest of the line
15:40:56 <k00mi> well, that's a horrible way to put it
15:41:21 <Flonk> k00mi: Haha, what do you mean?
15:41:34 <Flonk> Clint: No what k00mi is saying I think :)
15:42:07 <k00mi> it includes the entire expression after the ->
15:42:27 <mzero> actually, the issue here is the let
15:42:27 <magicman> The lambda goes "as far right as it can without resulting in an invalid parse", or something like that.
15:42:36 <mzero> the    let --- in     is a sort of bracket
15:42:37 <Flonk> Which means it stops at keywords like in and else
15:42:45 <Flonk> Yup I think I understand
15:42:50 <mzero> that is protecting the  "u 4" from the lambda
15:43:38 <mzero> where as $ is just a plain ol' operator, part of the expression syntax, and therefore part of the expression after the ->
15:44:58 <Flonk> Kind of a shame, I was hoping to shave another few bytes off the script I'm writing
15:45:06 <Flonk> But good to know, thanks!
15:45:12 <Flonk> *golfing
15:46:50 <bjorkintosh> Flonk, shave a few bytes?
15:46:59 <bjorkintosh> what're scared of? just truncate the file!
15:47:14 <bjorkintosh> yeah. tail file.hs > newfile.hs!
15:47:19 <bjorkintosh> bytes? gone!
15:49:19 <Flonk> haha, that seems a bit radical
15:49:31 <bjorkintosh> wouldn't that be sweet? *sigh*
15:50:59 <geekosaur> taking a few bytes out of comprehensibility?
15:51:34 <bjorkintosh> wishful thinking, geekosaur.
15:52:06 <jle`> Flonk: why can't you just do let u = succ in u 4
15:52:45 <geekosaur> depends on whether the real use case requires avoiding the DMR...
15:52:58 <jle`> geekosaur: he is code golfing i think
15:53:00 <Flonk> jle`: I'm codegolfing with a friend, trying to get the mandelbrot set as small as we can (ascii output)
15:53:06 <Flonk> casual coding saturdays
15:53:34 <jle`> consider not using a lambda at all, if possible :)
15:53:41 <bjorkintosh> hmm. do it in j. can't get smaller. then see if it translates to haskell.
15:54:22 <mzero> just burn a global name, and skip the lambda altogether
15:54:32 <mzero> u=succ\n
15:55:01 <Flonk> nah, succ was just an example, http://lpaste.net/100896
15:55:12 <Flonk> function m is 183 chars and I can't really get it smaller at this point
15:55:41 <jle`> plop it into @pl :P
15:55:48 <prophile> concatMap is longer than >>=
15:55:56 <jle`> actually for that it might make it longer
15:56:46 <prinsen> I need to derive Typeable for Effect IO (Maybe Value), how would that stand-alone deriving look like?
15:57:18 <Flonk> prophile: how do those 2 relate?
15:57:28 <jle`> Flonk: (>>=) for lists is concatMap
15:57:29 <mzero> Flonk  - l=length and g="..." should just be at top level - skip the let
15:57:32 <prophile> (>>=) is flip concatMap
15:57:35 <prophile> for lists at leat
15:57:41 <prophile> *lists at least
15:57:45 <jle`> @src (>>=) []
15:57:45 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
15:57:46 <jle`> darn
15:57:49 <Flonk> jle`: It is? cool beans!
15:58:18 <geekosaur> @src [] (>>=)
15:58:18 <lambdabot> xs >>= f     = concatMap f xs
15:58:18 <jle`> > [1,10,100] >>= \x -> [x,x+1,x+2]
15:58:19 <lambdabot>  [1,2,3,10,11,12,100,101,102]
15:59:45 <Flonk> Hah well I'll consider it done since asking others for help is cheating, but I'll try to get it smaller
15:59:45 <k_89> > [1..]
15:59:47 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
16:00:06 <k_89> ah, i thought that might mess up the bot :P
16:00:15 <Iceland_jack> k_89: Yet you did it anyway?!
16:00:16 <Iceland_jack> :)
16:00:17 <prinsen> I need to derive Typeable for Effect IO (Maybe Value), how would that stand-alone deriving look like?
16:00:20 <k_89> hehe
16:00:20 <prinsen> sry repost
16:00:43 <c_wraith> prinsen: what version of GHC?
16:00:46 <jle`> > fix (1:)
16:00:47 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
16:01:08 <Iceland_jack> lambdabot can deal with ‘infinite’ lists just fine
16:01:12 <jle`> > fix error
16:01:13 <lambdabot>  "*Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *Ex...
16:01:25 <prinsen> c_wraith: 7.6.3
16:01:28 <c_wraith> prinsen: That won't even be possible to automatically derive below GHC 7.8, actually
16:01:39 <prinsen> c_wraith: why?
16:01:57 <jle`> @src error
16:01:57 <lambdabot> error s = throw (ErrorCall s)
16:03:05 <c_wraith> prinsen: GHC's ability to derive Typeable is pretty limited before the complete reworking in the Typeable interface for GHC 7.8
16:04:33 <prinsen> c_wraith: Before I start compiling 7.8, do you have it running? :)
16:04:59 <c_wraith> prinsen: there are release candidate binaries available.  7.8 hasn't been released yet.
16:06:48 <prinsen> c_wraith: just wondered if you can verify that it works
16:07:21 <haasn> Iceland_jack: “just fine”
16:07:35 <haasn> Iceland_jack: the semantics are a bit stupid, unfortunately
16:07:50 <Iceland_jack> haasn: Well it doesn't blow up s'what I meant :)
16:07:52 <haasn> it still renders out the first 2000 or whatever characters of the string even though it only displays 100
16:08:44 <jle`> > take 10 . show $ fix (1:)
16:08:45 <lambdabot>  "[1,1,1,1,1"
16:08:52 <jle`> yay for laziness
16:11:41 <joelteon> > take 10 . show $ 2 ^ 10000
16:11:42 <prinsen> c_wraith: any chance? :)
16:11:42 <lambdabot>  "1995063116"
16:12:08 <joelteon> > take 10 . show $ 2 ^ 1000000
16:12:09 <lambdabot>  "9900656229"
16:12:21 <prinsen> c_wraith: i have to move my env. to a new VM to compile GHC 7.8, bit of a hazzle
16:13:02 <c_wraith> prinsen: alternatively, you could write a Typeable instance by hand and stay with your current setup - you'd just have to be aware it's not compatible with GHC after 7.6
16:14:42 * hackagebot sloane 1.3 - A command line interface to Sloane's On-Line Encyclopedia of Integer Sequences  http://hackage.haskell.org/package/sloane-1.3 (AndersClaesson)
16:15:29 <prinsen> c_wraith: cool ill try it
16:20:06 <mzero> anyone familiar enough with Happy to know what HAPPY_ARRAY is?
16:20:28 <bjorkintosh> ['h','a','p','p','y']
16:20:33 <bjorkintosh> si o non?
16:21:23 <mzero> mom
16:21:25 <mzero> non
16:21:32 <mzero> ooo
16:25:22 <Iceland_jack> > map (\x -> [x,'o',x]) "mno"
16:25:23 <lambdabot>  ["mom","non","ooo"]
16:25:27 <hexagoxel> is there a way to list the methods in a class on the commandline / in ghci?
16:25:57 <Iceland_jack> hexagoxel: :info
16:28:33 <hexagoxel> Iceland_jack: ty
16:36:51 <hexagoxel> man, my hoogle --info shows docs from ghc 6.12
16:36:58 <hexagoxel> annoying.. why is that so out-of-date
16:38:31 <Earnestea> Update your hoogle docs?
16:38:52 <Earnestea> (as in, hoogle data)
16:40:08 <hexagoxel> did that, no change in output from hoogle --info
16:41:06 <hexagoxel> (and the hoogle package version is also pretty recent)
16:43:56 <hexagoxel> what does "hoogle --info Applicative" print for you"? is it equivalent to the doc. at http://hackage.haskell.org/package/base-4.6.0.1/docs/Control-Applicative.html#t:Applicative?
16:44:36 <hexagoxel> or more like http://www.haskell.org/ghc/docs/6.12.1/html/libraries/base/src/Control-Applicative.html#Applicative
16:44:46 * hackagebot sloane 1.4 - A command line interface to Sloane's On-Line Encyclopedia of Integer Sequences  http://hackage.haskell.org/package/sloane-1.4 (AndersClaesson)
16:46:01 <ozataman> Anybody know of an example of how to use Parsec's expression parser to parse haskell-style function application (i.e. juxtaposition)?
16:46:53 <k_89> what'd a simple graph datastructure look like ?
16:47:40 <haasn> k_89: depends on whether you need to observe cycles or not ;)
16:47:41 <k_89> neverming
16:47:48 <k_89> observe cycles :p
16:47:53 <k_89> what are they ?
16:47:58 <k_89> oh cycles
16:48:21 <k_89> http://lpaste.net/100898
16:48:42 <ozataman> for more background, I tried making empty space look like an operator, but it seems to throw something off
16:48:50 <haasn> I think the most straightforward way to define a useful graph structure is to use a [(Index, Value)] for the nodes and [(Index,Index)] for the edges
16:49:03 <Flonk> > (length [1..]) > 4
16:49:07 <lambdabot>  mueval-core: Time limit exceeded
16:49:11 <johnw> ozataman: do you know appositive nouns in English?
16:49:12 <haasn> (or perhaps [(Index,[Index])])
16:49:35 <johnw> ozataman: just parse the terms; any two terms that are directly adjacent (no intervening operator) constitutes application
16:49:41 <k_89> haasn, but that won't exactly be a "graph", that'd be something behaving like a graph
16:50:12 <k_89> because of its indexes, instead of actual .. "data?"
16:50:29 <k_89> trying to make a simple graph and implementing shortest distance algo
16:50:30 <ozataman> johnw: not sure if I follow your suggestion. I would also like to use the machinery in "http://hackage.haskell.org/package/parsec-3.1.5/docs/Text-Parsec-Expr.html" to handle all the other operator precedences for me
16:50:42 <ij> Someone said that integer could be optimized into an Int by ghc, if the numbers are small enough. Can I prevent that from happening?
16:51:00 <ozataman> Otherwise, simple token parsing and considering adjacency function application would be fairly easy
16:51:01 <johnw> ozataman: what I mean is that two values directly next to each other implies application
16:51:10 <k_89> based on this hypothesis : node is just a "node", the Graph knows about its edges
16:51:19 <k_89> and an Edge, is an Edge
16:51:21 <geekosaur> ij: maybe by building it manually but you'll need an extension and a special import
16:51:50 <johnw> s/values/terms
16:52:37 <ozataman> johnw: I understand, but that ends up being quite hard to get working if you're also trying to fit into that operator table + term interface
16:52:38 <luite_> ij: there are two Integer constructors for integer-gmp, S# (small ints) and J# (big ints), usually when something's a big int, operations on it will result in a new big one, but is that really what you want?
16:53:21 <ij> Yup.
16:54:00 <ozataman> johnw: which is why I was wondering if anybody had examples
16:54:54 <Hermit> hmmm, what is generally preferred? github+fork+merge-request or patch through email?
16:55:09 <johnw> depends on the person
16:55:15 <johnw> i _greatly_ prefer the former
16:55:32 * Hermit does so too
16:56:27 <Hermit> johnw: should you know what nick the mantainer of unix-compat goes by (if any), I could ask him directly
16:56:40 <johnw> i don't know
16:57:12 <Hermit> well, patch it is!
16:57:15 <luite_> ij: why? for benchmarks?
16:57:28 <ij> Yup.
16:58:25 <ij> Playing around with some numbers, trying to make it a bit faster.
16:58:39 <luite_> hm okay
17:13:01 <f-a> hello gents. I am looking for an article (or maybe an interview), probably by a guy involved with writing the H98 spec. Basically he was saying that record access syntax shouldn't have been there in the first place (only pattern matching) and it has been introduced because guys coming from other languages demanded it. Alas, I cannot find it searching online. By chance anyone of you know what I am talking about?
17:13:42 <irssi> is it possible to use template haskell to compile time evaluate an array?
17:14:13 <irssi> i could do it for the list, but when trying to use an array and then doing the deriveLift, i get error evaluating compile time expression
17:16:50 <enthropy> f-a: have you looked at the various proposals/discussions that are looking into improving the records situation?
17:16:53 <enthropy> https://ghc.haskell.org/trac/haskell-prime/wiki/TypeDirectedNameResolution
17:17:14 <enthropy> probably you can find somebody famous weighing in
17:17:29 <f-a> thanks, I will look there
17:17:34 <[1]grant> Is there a way in parsec to get the remaining input stream (that has no yet been parsed) as a whole?
17:17:39 <[1]grant> Without say, "many anyChar"
17:17:46 <[1]grant> (is there a cleaner way, that is)
17:18:28 <gamegoblin> Enthropy: Are you by chance from germany?
17:18:39 <enthropy> nope
17:19:09 <gamegoblin> Have a lot of german friends who use the sentence construction "probably ____"
17:19:25 <gamegoblin> e.g. "probably you can do it" vs "you can probably do it"
17:19:54 <kgadek> hi all. what is the package naming scheme here: http://www.haskell.org/ghc/dist/7.8.1-rc2/ ? I don't recognise the one-but-last field that contains unknown/apple/portbld
17:21:33 <pavonia> gamegoblin: probably getInput :p
17:22:23 <f-a> gamegoblin: regarding parsec, I guess you could put in the state the number of parsed items
17:22:26 <gamegoblin> pavonia: precisely what I was looking for, thanks
17:22:47 <f-a> oh, nice one pavonia
17:23:14 <geekosaur> afaik that's a modified(?) configure triple
17:24:10 <geekosaur> cpu-manufacturer-os[-revision]
17:24:50 * hackagebot vector-space-points 0.2 - A type for points, as distinct from vectors.  http://hackage.haskell.org/package/vector-space-points-0.2 (BrentYorgey)
17:25:06 <k_89> how do i achieve something like this in haskell ?
17:25:30 <k_89> (ie, java/scala style polymorphism of functions)
17:25:35 <joelteon> I think haskell could do with more top-level module namespaces
17:25:53 <k_89> http://lpaste.net/100899
17:25:57 <joelteon> or maybe fewer...I'm not sure which one I'm talking about
17:26:20 <geekosaur> k_89: you don't as such
17:26:29 <k_89> you make a typeclass ?
17:26:29 <Cale> k_89: class Val f where val :: f a -> a
17:26:45 <Cale> instance Val Foo where val (Foo a) = a
17:26:48 <geekosaur> typeclasses can do it but not quite like that and there are some gotchas
17:26:52 <Cale> instance Val Bar where val (Bar a) = a
17:27:10 <geekosaur> gadts can do it in some circumstances but are not realy different types in the way you mean
17:27:34 <Cale> Well, yeah, it would be better to know what you're actually trying to abstract over
17:27:38 <haasn> instance Comonad Foo where extract (Foo a) = a; duplicate = Foo
17:27:41 <haasn> ;)
17:27:45 <Cale> But the example there is easy to capture with a type class.
17:28:33 <Cale> I wouldn't call this Java-style polymorphism. Java can't even do this.
17:29:17 <k_89> it kind of can, you can define methods with same name but arguments of different type
17:29:24 <Cale> Yeah, that's not what this is
17:29:44 <k_89> yeah ..
17:30:03 <k_89> here val is a value
17:30:17 <k_89> and i am trying to redefine that value
17:30:21 <Cale> Though I guess it's kind of similar from the perspective that we're determining the implementation of something based on types somewhere
17:30:28 <Cale> But that's where the similarity ends
17:30:39 <Cale> If you look at the type of our resulting val
17:30:45 <Cale> It's (Val f) => f a -> a
17:31:10 <Cale> Java can't express polymorphism like that, where a type parameter itself takes a type argument
17:31:27 <Cale> (unless I'm not aware of some new extension :)
17:32:53 <kgadek> if anyone's interested: this unknown/apple/portbld is a vendor (according to ftp://ftp.geoinfo.tuwien.ac.at/frank/Glorious_Glasgow_HaskellCompilationSystemUsersGuideVersion6_10_2.pdf page 142 )
17:33:56 <geekosaur> [09 01:20] <geekosaur> afaik that's a modified(?) configure triple
17:33:56 <geekosaur> [09 01:21] <geekosaur> cpu-manufacturer-os[-revision]
17:34:02 <geekosaur> kgadek ^^
17:36:18 <kgadek> oh, sorry. did not spot that
17:36:38 <kgadek> thanks anyway
17:37:27 <geekosaur> and "portbld" is hardwired by freebsd port builds
17:39:52 * hackagebot diagrams-builder 0.5.0.3 - hint-based build service for the diagrams graphics EDSL.  http://hackage.haskell.org/package/diagrams-builder-0.5.0.3 (BrentYorgey)
17:39:54 * hackagebot diagrams-haddock 0.2.2.3 - Preprocessor for embedding diagrams in Haddock documentation  http://hackage.haskell.org/package/diagrams-haddock-0.2.2.3 (BrentYorgey)
17:39:56 * hackagebot diagrams-core 1.1 - Core libraries for diagrams EDSL  http://hackage.haskell.org/package/diagrams-core-1.1 (BrentYorgey)
17:40:42 <k_89> just want to check my understanding of "deriving" .. basically, it tells haskell to "derive" the behavior of a data-type for the functions of a type-class from the components of that data-type ?
17:40:55 <Iceland_jack> k_89: yeah basically
17:41:00 <k_89> cool !
17:41:33 <Iceland_jack> If you have
17:41:33 <Iceland_jack>     data Foo = Foo A B deriving Show
17:41:33 <Iceland_jack> then 'instance Show Foo' will be derived using the Show instances for A and B
17:41:45 <Iceland_jack> You can add
17:41:55 <Iceland_jack> the '-ddump-deriv' flag to GHC to see the actual code GHC produces
17:43:02 <k_89> okay
17:44:15 <k_89> and is there some way to check whether variables a & b are the same instance ?
17:44:47 <k_89> http://lpaste.net/100902
17:44:49 <Iceland_jack> You can give them the same variable?
17:44:54 * hackagebot diagrams-lib 1.1 - Embedded domain-specific language for declarative graphics  http://hackage.haskell.org/package/diagrams-lib-1.1 (BrentYorgey)
17:44:56 * hackagebot diagrams-contrib 1.1.1 - Collection of user contributions to diagrams EDSL  http://hackage.haskell.org/package/diagrams-contrib-1.1.1 (BrentYorgey)
17:44:58 * hackagebot diagrams-cairo 1.1 - Cairo backend for diagrams drawing EDSL  http://hackage.haskell.org/package/diagrams-cairo-1.1 (BrentYorgey)
17:45:00 * hackagebot diagrams-gtk 1.0.1 - Backend for rendering diagrams directly to GTK windows  http://hackage.haskell.org/package/diagrams-gtk-1.0.1 (BrentYorgey)
17:45:02 * hackagebot diagrams-postscript 1.0.2 - Postscript backend for diagrams drawing EDSL  http://hackage.haskell.org/package/diagrams-postscript-1.0.2 (BrentYorgey)
17:45:37 <haasn> k_89: that's an error
17:45:41 <Tekmo> Sorry, I missed the first part of the question.  What do you mean by checking if they are the same instance?
17:45:52 <haasn> Node :: * -> * but Eq requires a parameter of kind *
17:46:08 <k_89> Iceland_jack, like that data-type Node in the paste ( http://lpaste.net/100902 ) , i would like Eq to behave on adt Node in such a way that it returns true when
17:46:12 <haasn> you may have meant “instance Eq (Node a)” or similar
17:46:20 <k_89> the Node's being matched are essentially the same node
17:46:35 <k_89> haasn, oh, okay, will fix that
17:47:22 <Tekmo> k_89: (Node a) == (Node a) = a == a
17:48:08 <k_89> but that'd return true even when the nodes contain the same value
17:48:15 <k_89> ie Node 1 == Node 1
17:48:19 <Tekmo> k_89: Do you mean you want reference equality?
17:48:22 <k_89> yeah
17:48:25 <k_89> phew
17:48:27 <haasn> not possible in haskell
17:48:28 <Tekmo> k_89: That's a no-no in Haskell
17:48:35 <k_89> hmm
17:48:36 <k_89> why
17:48:37 <haasn> haskell doesn't have references
17:48:49 <haasn> so there can be no concept of reference equality
17:49:29 <Tekmo> Explain the reason you want reference equality and I can try to translate it to the equivalent Haskell idiom
17:49:34 <k_89> haasn, hence you put that index thing in the graph adt :P
17:49:42 <haasn> k_89: exactly
17:50:00 <Cale> IORefs are an instance of Eq :)
17:50:04 * hackagebot diagrams-svg 1.0.2 - SVG backend for diagrams drawing EDSL.  http://hackage.haskell.org/package/diagrams-svg-1.0.2 (BrentYorgey)
17:50:06 * hackagebot diagrams 1.1 - Embedded domain-specific language for declarative vector graphics  http://hackage.haskell.org/package/diagrams-1.1 (BrentYorgey)
17:50:40 <k_89> Tekmo, basically i am trying to make a graph data structure in haskell, and say i want to check whether an Edge contains a Node, then i need referential equality
17:51:00 <haasn> Cale: I think you would much rather use something like a StablePtr than an actual IORef, no?
17:51:09 <Cale> k_89: My usual graph representation is something along the lines of Map Vertex (Set Vertex)
17:51:10 <haasn> oh, unless you want to actually modify references too :)
17:51:57 <Cale> I only brought it up because you said Haskell doesn't have references :)
17:52:21 <Clint> k_89: you could use fgl
17:52:26 <Tekmo> k_89: The most common way to do this is to not actually store the nodes as neighbors, but rather to store their IDs
17:52:46 <Tekmo> k_89: See `Data.Graph` from the `containers` library for an example of how to do this
17:52:51 <escondida> Hey, folks...I'm teaching myself VtyUi, and I'm running into an issue trying to define a keymap. Specifically, the newGroup and addToGroup functions, which return a "widget group" and a function to switch to a specific widget in said group, respectively, seem to need to be run from main, so the switcher functions aren't in scope for the keymap. Thoughts? Code here: http://sprunge.us/GdNe
17:53:20 <k_89> Tekmo, i can see how it can work witth ids
17:53:24 <Tekmo> k_89: The ids behaves like the references you want
17:53:34 <escondida> I feel like I'm missing an obvious solution, of course, that's the problem with missing an obvious solution: you've missed it.
17:54:15 <Cale> k_89: Data.Graph unfortunately uses an Array instead of a Map though, which means that it doesn't efficiently support as many operations.
17:54:33 <Cale> (But it's easy enough to implement that stuff in terms of Map)
17:54:53 <k_89> Cale, yeah your Map solution kinda looks most straightforward one
17:55:03 <Tekmo> Yeah, I personally like the map solution myself
17:55:09 <haasn> Or []. I keep surprising myself by how efficient [] can be for list sizes smaller than the constant factor of Map operations
17:55:14 <haasn> time complexity isn't everything :)
17:55:29 <Tekmo> The `Data.Graph` solution makes more sense if your graph is static
17:55:33 <no-n> what's the diff. between newtype and data?
17:55:49 <pordan30> there was a paper/blog post/tutorial concerning propagating information up and down trees using combinations of foldr and foldl (e.g. the value of some node depends on values above and below it, which depend on the fold operations) - perhaps someone knows what I'm talking about?
17:56:11 <Tekmo> no-n: newtype is basically "free" and only changes the type
17:56:15 <haasn> no-n: apart from the number-of-constructors and number-of-fields restrictions, newtypes can be nonstrictly deconstructed
17:56:21 <Tekmo> no-n: There is no overhead for wrapping or unwrapping a newtype
17:56:33 <Cale> no-n: newtypes are only allowed to have one constructor with one field, and the semantics of pattern matching on a newtype are adjusted so that the newtype can be represented at runtime with values of the underlying type
17:56:34 <Tekmo> no-n: The main purpose of a newtype is just to change something's type
17:56:36 <haasn> no-n: which basically means you don't need to inspect a value to “take off” the newtype wrapper
17:56:38 <Cale> (the type of that single field)
17:56:58 <Iceland_jack> no-n: You can use 'data' instead of 'newtype' (ignoring some strictness issues), 'newtype' is used for efficiency
17:57:21 <haasn> Iceland_jack: strictness isn't just about efficiency
17:57:25 <haasn> In fact it's not about efficiency at all ;)
17:57:30 <Tekmo> no-n: Typically you use newtypes to either (A) create an opaque wrapper around something, (B) to make something fit the shape that a type class expects, or (C) provide an alternative type class instance for a type
17:57:36 <Iceland_jack> haasn: That's not what I meant
17:57:42 <haasn> ah, okay
17:57:48 <no-n> heh.. thanks :}
17:57:53 <Tekmo> no-n: `data` is more powerful than a `newtype`, but it's not free, performance-wise, like newtype is
17:58:00 <no-n> *nod*
17:59:56 * hackagebot music-util 0.5 - Utility for developing the Music Suite.  http://hackage.haskell.org/package/music-util-0.5 (HansHoglund)
18:00:10 <k_89> question : why is straightforward referential equality not there in haskell
18:00:18 <k_89> is there some reason behind this ?
18:00:39 <haasn> k_89: so we get referential transparency
18:00:49 <k_89> what ... :P
18:00:50 <haasn> k_89: there is no way to distinguish values that evaluate to the same normal form
18:01:06 <k_89> okay
18:01:07 <haasn> k_89: this lets us specify and reason with equality laws
18:01:13 <k_89> oh
18:01:16 <Tekmo> k_89: Haskell goes a long way to make sure that referential transparency and purity "just work" so that equational reasoning is (mostly) valid
18:01:38 <haasn> like x ++ (y ++ z) = (x ++ y) ++ z or similar. If we had the ability to distinguish between those expressions because live in different references, the law would be broken
18:01:53 <k_89> so with haskell, you forget you are on a "computer", and work in the realm of "logic"
18:02:01 <Tekmo> k_89: That's a good way to think about it
18:02:11 <k_89> hmm
18:02:16 <haasn> I would place Haskell somewhere in between
18:02:26 <Cale> Also, there actually is a reallyUnsafePtrEquality# in GHC, but because the garbage collector moves things around, it can give both false positives and false negatives.
18:02:27 <haasn> it's not entirely abstract from computation
18:02:56 <k_89> that's interesting though
18:02:57 <Tekmo> k_89: Equational reasoning is one of the big advantages of Haskell
18:02:59 <k_89> the idea
18:03:05 <Cale> Testing whether things are at the same memory location isn't an operation the GHC runtime was built for
18:03:16 <Tekmo> k_89: It lets you prove very high-level correctness properties about your code
18:03:24 <k_89> Tekmo, yeah, i can kind of get the situations where it can be powerful
18:03:59 <haasn> it also lets you abstract implementation details
18:04:02 <Tekmo> k_89: So you can definitely simulate references in Haskell (using ints, or whatever), but Haskell explicitly forces you to opt in to that sort of thing, rather than providing it as the baseline
18:04:12 <Cale> (So even if you say "screw referential transparency, I'll just expose an operation to look at the pointers anyway" you run into trouble.
18:04:26 <Tekmo> k_89: This is a pretty common theme in Haskell where complex features require an explicit opt-in.  `IO` is another example of this: you have to explicitly opt in to effects
18:04:36 <Tekmo> k_89: Same thing for nulls.  You have to explicitly opt into them using `Maybe`
18:04:58 <Tekmo> k_89: By providing a simpler default baseline, we can guarantee more properties about Haskell code than we could in other languages
18:05:15 <Cale> There are StableNames for this purpose though, if you want to implement memoisation and such -- they can only give false negatives)
18:05:20 <Tekmo> k_89: This makes Haskell code easier to reason about both for humans (proving correctness) and machines (optimizing)
18:05:40 <Cale> http://www.haskell.org/ghc/docs/latest/html/libraries/base/System-Mem-StableName.html
18:05:50 <Cale> I have never seen anyone actually use StableNames in practice
18:05:57 <Cale> But they're there
18:06:08 <k_89> wow ... my standard way of thinking about programs becomes way too meta with haskell :P
18:06:20 <Tekmo> Haha
18:06:35 <k_89> like in that graph example, in any other lang, i'd check for referential equality of nodes
18:06:36 <haasn> Cale: I think a false negative for a graph operation would be quite disastrous!
18:06:48 <Cale> haasn: yep!
18:07:09 <k_89> because that's what langs already do, but with haskell, two nodes are same if all their inner components are same
18:07:11 <Cale> They're really only useful for memoisation, but much better memoisation strategies exist.
18:07:12 <Iceland_jack> k_89: It may seem strange but it's easier to think of Haskell removing features until you ask for them (making them opt-in as Tekmo) rather than Haskell adding new stuff
18:07:51 <k_89> its like two humans are completely same if everything atom, and its arrangement in them is same
18:07:54 <haasn> I really wonder how StableNames actually work.
18:08:22 <Iceland_jack> k_89: Is their location a part of that comparison? Are you the same person you were a second ago?
18:08:31 <k_89> exactly my point
18:08:37 <k_89> that's what i was getting to
18:08:51 <k_89> so for the nodes, i need some information at the moment of their creation
18:09:01 <k_89> that way i can separate them
18:09:06 <Tekmo> Right
18:09:11 <haasn> k_89: Haskell also doesn't actually have any way to test for “sameness”. You can certainly define (==) :: Node -> Node -> Bool; though - but not only can you define that in a way that returns True for objects that have different normal forms (or vice versa), but you also can't readily, say, compare functions
18:09:25 <Tekmo> The same way we give humans "names" to distinguish them (assuming we don't have atom equality) :)
18:09:47 <Iceland_jack> k_89: By the way, think of how many ways you have of defining 'equality' in other langauges: if you're familiar with Common Lisp you'll know what a nightmare that was
18:10:12 <Iceland_jack> http://stackoverflow.com/questions/547436/whats-the-difference-between-eq-eql-equal-and-equalp-in-common-lisp
18:10:13 <haasn> Iceland_jack: or JavaScript.
18:10:19 <Iceland_jack> or that..
18:10:20 <k_89> i am not familiar with lisp .. haskell is my first foray into purely functional lang
18:10:27 <Iceland_jack> k_89: List isn't purely functional
18:10:31 <Iceland_jack> and not very functional either
18:10:36 <k_89> heh
18:10:41 <Cale> k_89: Right, depending on how you're building the graph, you might want to keep track of the next node ID (or use a library like monad-supply which does this kind of thing for you)
18:10:42 <k_89> its "legendary" for sure
18:10:56 <Iceland_jack> (I don't say that as a negative thing)
18:11:32 <Cale> I actually found programming in a functional way in Common Lisp to be pretty challenging and borderline intolerable in cases.
18:11:34 <Iceland_jack> Not that 'functional programming' has much of a precise meaning anyway
18:11:51 <Iceland_jack> http://letoverlambda.com/index.cl/guest/chap5.html 'Lisp Is Not Functional' from Let Over Lambda
18:11:58 <Cale> Though other lisps do a better job of that
18:12:13 <Iceland_jack> yes, I like Clojure
18:12:31 <Cale> Common Lisp puts functions and other values in separate namespaces
18:12:46 <Iceland_jack> I like Common Lisp as well actually but only because it hurt me
18:13:30 <escondida> Hey, folks...I'm teaching myself VtyUi, and I'm running into an issue trying to define a keymap. Specifically, the newGroup and addToGroup functions, which return a "widget group" and a function to switch to a specific widget in said group, respectively, seem to need to be run from main, so the switcher functions aren't in scope for the keymap. Thoughts? Code here: http://sprunge.us/GdNe
18:14:18 <Tekmo> escondida: I'll help.  Just give me a second to study the code
18:14:27 <k_89> Cale, still not familiar with monads, but its like i automatically need a nodeFactory now, which keeps a list of id of nodes it has created and supplies new ids to new nodes it makes
18:14:27 <escondida> Tekmo: Much appreciated!
18:14:31 <Iceland_jack> escondida: You can add the values from 'newGroup' as an argument
18:15:15 <Cale> k_89: The basic idea that this kind of library is a thin abstraction around is that you can take a list of remaining labels (which might be infinite) as a parameter to your function(s), and deplete that list as you pass it around.
18:15:41 <Iceland_jack> Or you can make a function that generates a key map something like
18:15:41 <Iceland_jack>     makeKeymap :: IO Keymap
18:15:41 <Iceland_jack>     makeKeymap = do g <- newgroup
18:15:41 <Iceland_jack>                     ...
18:15:45 <escondida> Iceland_jack: Hmm. That is true, I suppose. I'd need to add more args to the keymap any time I changed the UI, though...
18:15:51 <Iceland_jack> escondida: If I udnerstand the problem correctly
18:16:30 <Iceland_jack> escondida: You could do that couldn't you?
18:16:31 <Tekmo> escondida: Not necessarily
18:16:37 <escondida> Oh?
18:16:42 <Tekmo> escondida: What you do is pass a `Config` type to the keymap
18:16:50 <Cale> k_89: i.e. whenever you need another label, you just match the list of remaining labels against (x:xs), and use x as the label, and you pass xs along as the list of remaining labels to whatever happens next
18:16:53 <Tekmo> escondida: Think of it as a record of all the arguments you want to pass
18:16:56 <escondida> Tekmo: Oh, of course!
18:17:16 <Tekmo> escondida: That makes it easy to modify the number of fields of the config without breaking your keymap function
18:17:26 <escondida> It would get all the top-level stuff for free, and any UI nonsense I had to define in main I could just add to the config
18:17:53 <escondida> Tekmo: Iceland_jack: Thank you both for your help.
18:18:01 <Tekmo> You're welcome!
18:18:40 <k_89> Cale, cool, thanks !
18:19:33 <Cale> k_89: Of course, that opens up the possibility for some bugs, especially reusing the old label list (which results in duplicate labels which were supposed to be unique)
18:20:02 <Tekmo> Cale: This is a case where I wish Haskell had a good way to model releasing values
18:20:33 <Iceland_jack> http://web.engr.oregonstate.edu/~erwig/papers/InductiveGraphs_JFP01.pdf this is also relevant to the previous discussion
18:20:39 <Cale> k_89: So, those libraries wrap things up and do the parameter passing for you, so that you can't get it wrong
18:28:34 <escondida> Tekmo: This is a little embarrassing, but I don't suppose you have a reference for the Config type? I've been googling and hoogling, and finding quite a bit about xmonad configuration and other config libraries, but I could've sworn I remembered running across a Config type somewhere that was like what you described.
18:29:07 <Tekmo> escondida: It's okay! :)  There is no standard config type.  I was just referring to Haskell's support for defining records.  I'll give you an example
18:29:14 <escondida> Ah, I see
18:29:27 <Tekmo> escondida: data Config = Config { someField :: Double, anotherField :: Int }
18:29:43 <Tekmo> escondida: That defines a record which holds two values, a `Double` and `Int`
18:29:57 <Tekmo> escondida: It also creates two accessor functions named `someField` and `anotherField` that have these types:
18:30:02 <Tekmo> escondida: someField :: Config -> Double
18:30:08 <Tekmo> escondida: anotherField :: Config -> Int
18:30:27 <escondida> Cool beans; that sounds exactly right
18:30:31 <escondida> Thank you, again
18:30:38 <escondida> You're a gentleperson and a scholar.
18:30:42 <haasn> I wonder how easy it would be to liberate ghc from IO
18:30:44 <Tekmo> escondida: No problem!  Feel free to ask questions, even if you think they are silly :)
18:30:54 <Iceland_jack> escondida: The sillier the better!
18:30:58 <escondida> Heh
18:31:01 <Tekmo> haasn: You mean using the free monad representation for `IO`?
18:31:31 <escondida> Well, I've been dabbling in haskell for a while, but I'm a bit rusty, and I'm notoriously terrible at making UI stuff work.
18:31:46 <escondida> (quite a bit rusty)
18:32:04 <Tekmo> escondida: You may want to check out `threepenny-gui`
18:32:19 <haasn> Tekmo: perhaps, if that's feasible; what I ultimately would like to see is the ability to create Core or X86 or static module descriptions or whatever from a ByteString module source without requiring IO
18:32:30 <FreeFull> When you have IO as a free monad, do you need to have most possible operations declared in the data declaration for the type?
18:33:00 <haasn> FreeFull: you certainly need support for all of the IO operations specified in Haskell, if you want to be Haskell-conforming
18:33:18 <FreeFull> Well, I suppose you'd only need to have the primitives
18:33:21 <Tekmo> FreeFull: All primitive operations have to be declared
18:33:22 <escondida> Tekmo: That does look cool, but I have my heart set on a terminal UI if it kills me
18:33:26 <FreeFull> But that would still be a lot of primitives
18:33:26 <Iceland_jack> haasn: On a slightly related note, would it make sense to allow users to embed Core expressions into Haskell code like you can with assembly in C
18:33:32 <Tekmo> escondida: Got it
18:33:56 <Tekmo> FreeFull: The idea is that presumably the compiler would handle converting all FFI calls to terms in the free monad
18:34:27 <Iceland_jack> I haven't actually run into problems where pragmas or strictness annotations couldn't solve it, for it but it would be interesting
18:37:36 <shergill> is there some small-ish example usage for the reflection package?
18:37:59 <haasn> Iceland_jack: hang on, I think I stumbled across something similar to that while digging through the GHC docs earlier
18:38:19 <haasn> Iceland_jack: and while trying to find that just now, I actually finally found something that would make a completely unrelated problem I was having possible, neat!
18:38:32 <Iceland_jack> you're welcome! (((I guess)))
18:39:12 <Iceland_jack> haasn: I think it's possible to somehow link to a .hcr core file
18:39:21 <haasn> Iceland_jack: yes exactly that sounds like what I found
18:40:12 <Iceland_jack> It might be possible to add it as an expression via TH
18:40:16 <johnw> shergill: what do you want to do with it?
18:40:51 <Iceland_jack> adding a GHC options pragma and.. hm
18:41:08 <Iceland_jack> haasn: Out of curiosity, what was that other thing? :)
18:41:23 <haasn> Iceland_jack: how to figure out whether a declaration came from a TH splice or not
18:41:35 <Iceland_jack> oh.. you can do that?
18:44:23 <haasn> bleh, I can't link to documentation on my local filesystem
18:44:24 <shergill> johnw: i'm somewhat familiar with oleg's paper on which it's based. and currently i'm just looking to get more familiar with the library. the toy example i am thinking of is where i have a number of functions where one of the parameters is some 'global' shared value. iirc this is the problem domain the library is intended to tackle though i'm blurry on the specifics
18:44:49 <haasn> Iceland_jack: the documentation for ModSummary mentions that a single node of the ModuleGraph is either a regular haskell source file, a hi-boot source file or an external-core source file
18:45:12 <haasn> and HscSource has those three constructors
18:45:12 <johnw> it uses a phantom type, and a constraint on that type, to carry the reified value through the set of functions
18:45:38 <Iceland_jack> interesting
18:45:39 <johnw> if your functions all operate on a certain data type, and that data type can have a phantom type, then reflection becomes very easy to use
18:46:21 <johnw> if not, if you're using it to simply emulate Reader, then you're going to need to pass a proxy around -- which is pretty much the same thing as just passing the value itself
18:47:07 <johnw> where reflection becomes truly useful is when you want to get an environment argument for your data type into instances like Num
18:47:21 <haasn> Iceland_jack: as for the thing I found; there's a data Origin = FromSource | Generated
18:47:34 <haasn> It seems to show up in TypecheckedSource, not sure where else
18:47:38 <Iceland_jack> haasn: How do you access..
18:47:40 <johnw> instance Num (Foo a) where x + y = reflect $ \p -> x * p + y * p, for example
18:47:40 <Iceland_jack> ah
18:48:05 <johnw> err, instance Reifies Int a => Num (Foo a) where
18:48:13 <haasn> so I'm not immediately sure how “useful” it is, yet
18:48:39 <shergill> johnw: hmm when wouldn't you be able to add a phantom type?
18:49:12 <no-n> @src sequence
18:49:12 <lambdabot> sequence []     = return []
18:49:13 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
18:49:13 <lambdabot> -- OR: sequence = foldr (liftM2 (:)) (return [])
18:49:20 <johnw> well, if all the functions which require the constraint do not have a value whose type carries that phantom as a parameter
18:49:38 <haasn> Hmm. I'm suddenly not sure what a TypecheckedSource actually *is*
18:49:44 <Iceland_jack> > sequence [Just 1, Just 2, Just 3]
18:49:45 <lambdabot>  Just [1,2,3]
18:49:53 <johnw> you'd need to then plumb a Proxy through those calls
18:49:53 <Iceland_jack> > sequence ["Just 1", "Just 2", "Just 3"] -- :)
18:49:54 <lambdabot>  ["JJJ","JJu","JJs","JJt","JJ ","JJ3","JuJ","Juu","Jus","Jut","Ju ","Ju3","Js...
18:50:03 <johnw> any, for what it does, reflection can be invaluable
18:50:09 <johnw> but it's not as "general use" as I had once thought it would be
18:51:02 <shergill> johnw: gotcha. what about tradeoffs between reflection and reader? when do i want to use which? you may have already answered this above implicitly...
18:51:07 <haasn> Iceland_jack: I think I was misinterpreting the Origin, maybe that's the Origin for a type variable? as-is in the source vs. generated by GHC
18:51:09 <haasn> not sure
18:51:33 <johnw> shergill: Reader is a lot more straightforward, but the two are isomorphic
18:52:34 <shergill> johnw: hmm i don't remember off the top of my head but i thought there were certain advantages to the reflection approach. i should probably just re-read the paper
18:52:40 <johnw> either way, an argument is being passed to the final function carrying the value; it either gets done with a hidden parameter ala Reader, or in the instance dictionary ala reflection
18:52:53 <shergill> right
18:53:06 <johnw> reflection does have an optimization potential over REader
18:53:10 <johnw> I don't fully remember the details
18:53:34 <johnw> because Reader imposes the use of >>=
18:55:27 <shergill> right even on functions that may make use of configuration data implicitly
18:56:15 <shergill> johnw: thanks :) you're an indispensable resource
18:56:18 <johnw> another thing which is equivalent is implicit params, but the inference/type errors can be much worse
18:56:30 <shergill> johnw: yeah, i avoid those
18:56:35 <shergill> for the same reason
18:57:11 <escondida> Tekmo: Okay, this might be an obvious question, but on reviewing learnyouahaskell's chapter on defining types, I'm still stumped. When defining a new data type that takes a function--any function--what sort of type should I use for that?
18:57:40 <escondida> data KeyableFunction = KFunc { name :: String, f :: (???) }
18:57:41 <Tekmo> escondida: Here's an example: data HoldsAFunction = H (Int -> INt)
18:57:55 <Iceland_jack>     data IntFromInt = IFI (Int -> Int)
18:58:04 <Tekmo> escondida: Basically `a -> b` is the type of a function that has an argument of type `a` and a result of type `b`
18:58:08 <johnw> so, in scenarios where you can't pass an argument, and you can't introduce a Monad, and yet you can introduce a constraint (i.e., such as when an instance), then reflection is really the way to go
18:58:55 <Iceland_jack> escondida: Here is a list of functions and list of arguments
18:58:55 <Iceland_jack>     data FunsNArgs a b = FunsNArgs [a -> b] [a]
18:58:56 <johnw> such as when defining*
18:59:15 <Iceland_jack> @let data FunsNArgs a b = FunsNArgs [a -> b] [a]
18:59:17 <lambdabot>  Defined.
18:59:43 <Iceland_jack> @let applyFuns (FunsNArgs funs args) = zipWith ($) funs args
18:59:43 <lambdabot>  Defined.
19:00:19 <Iceland_jack> > applyFuns (FunsNArgs [show.(+1), show, show.(*10)] [10,20,30])
19:00:20 <lambdabot>  ["11","20","300"]
19:00:26 <escondida> Tekmo: Iceland_jack: You're right; I should give it a specific type of function instead of keeping it arbitrary, since the idea was just to have this for things I couldn't have at top-level. Thanks again.
19:00:50 <Tekmo> escondida: You're welcome!
19:01:11 <johnw> hi Tekmo!  Nice job with the Haskell cast
19:01:27 <Iceland_jack> yeah from me too Tekmo, it was a fun discussion
19:01:34 <escondida> Of course, that still leaves the question of figuring out the type of this thing, since I can't get it to the top to look at it, but I'll figure it out (-:
19:01:48 <Tekmo> johnw Iceland_jack: Thanks! :)
19:01:57 <Iceland_jack> escondida: You may work with storing it in a tuple first
19:02:11 <Iceland_jack> and then storing a list of those tuples (like I believe you did in the code example)
19:02:30 <Iceland_jack> then you can just check the type of that list and use that type :)
19:02:47 <escondida> Hmm, that's a good idea!
19:03:43 <Tekmo> escondida: Note that you can parametrize data types if you don't know in advance what they will hold
19:03:48 <haasn> Iceland_jack: never mind about my idea, I tested it and definitions that come from TH splices are actually marked as FromSource, too!!
19:03:54 <escondida> Tekmo: Interesting
19:03:56 <Tekmo> escondida: data Example a b = AnExample { someField :: a -> b }
19:04:00 <haasn> I'm guessing Generated might refer only to stuff like derived instances
19:04:38 <Iceland_jack> escondida: Similar to an example above where you could store functions of any type
19:04:38 <Iceland_jack> <Iceland_jack>     data FunsNArgs a b = FunsNArgs [a -> b] [a]
19:04:45 <Iceland_jack> haasn: cool!
19:04:58 <escondida> Nice
19:05:16 <Iceland_jack> escondida: You can also store ‘inverted’ functions
19:05:17 <Iceland_jack>     data FlippyFun a b = FF (b -> a)
19:05:26 <haasn> Iceland_jack: uncool* :)
19:05:47 <Iceland_jack> haasn: no it's cool to know that!
19:05:52 <Iceland_jack> I was just about to test it
19:05:54 <haasn> ah
19:06:04 <haasn> Iceland_jack: unfortunately this puts me back at square 1 :(
19:06:16 <haasn> I really want to find out whether a declaration came from inside a TH splice or not
19:06:46 <Iceland_jack> You could file a feature request on Trac, if they close it they'll probably mention whehter it exists or not ;)
19:06:53 <Iceland_jack> *whether
19:11:48 <parc> with data.typeable, suppose you have a typerep y like (Int->Bool) and a typerep x for Int, is there a way to infer that y x will have typerep == Bool?
19:18:34 <enthropy> parc: funResultTy might be helpful here
19:19:29 <parc> ooh, i didn't see that. exactly what i was looking for
19:20:22 <Iceland_jack> 15% of people thought that ‘software’ is comfortable clothing, that's actually a fantastic word
19:20:31 <Iceland_jack> or rather meaning
19:22:25 <erisco> I am trying to understand ArrowApply. I think that sequence can be written [a () b] -> a () [b] but I am not certain how or if it is possible
19:23:03 <Qu4tro> @pl \(x, y) -> (x - 1, y + 1)
19:23:04 <lambdabot> subtract 1 *** (1 +)
19:23:43 <Iceland_jack> > ((-1 +) *** (1 +)) (8, 10)
19:23:44 <lambdabot>  (7,11)
19:23:50 <Iceland_jack> to make it look a bit more symmetric
19:24:16 <Qu4tro> ty
19:24:17 <Iceland_jack> Hm or then maybe
19:24:17 <Iceland_jack> @ty (-1 +) *** (+ 1)
19:24:17 <lambdabot> (Num a, Num a1) => (a, a1) -> (a, a1)
19:24:24 <Qu4tro> I was trying to avoid arrows
19:24:36 <haasn> (_1 +~ 1) . (_2 +~ 1)
19:24:40 <haasn> err -~ for the first
19:24:45 <liyang> > (pred *** succ) (8,10) -- looks even better
19:24:47 <lambdabot>  (7,11)
19:24:56 <Iceland_jack> Well (***) really doesn't require arrows
19:24:56 <Qu4tro> yap
19:24:57 <haasn> oh that one is nice
19:24:58 <liyang> (But Enum.)
19:25:14 <Qu4tro> thanks
19:25:19 <Iceland_jack> I mean, it has arrows in the context but it's a very useful operator (pairing, copairing)
19:25:50 <Iceland_jack> > (pred *** succ) (minBound :: Word8, maxBound :: Word8)
19:25:51 <lambdabot>  (*Exception: Enum.pred{Word8}: tried to take `pred' of minBound
19:25:57 <haasn> erisco: sequenceA with WrappedArrow ;)
19:26:16 <Iceland_jack> > ((-1 +) *** (+ 1)) (minBound :: Word8, maxBound :: Word8)
19:26:17 <lambdabot>  (255,0)
19:26:24 <Iceland_jack> Depends on which output you want
19:27:58 <erisco> haasn, okay thanks I will look at those definitions to try and understand
19:31:38 <haasn> Iceland_jack: I think I don't actually need it; if I can figure out which SrcSpans correspond to TH splices then I can just look it up manually
19:31:58 <haasn> Iceland_jack: however, for some reason, the hs_splcds :: [LSpliceDecl id] field of HsGroup id is empty for my program
19:32:02 <haasn> even though it contains a TH splice!
19:32:37 <Iceland_jack> I'm not familiar enough with TH to speculate what the reason is
19:33:14 <Iceland_jack> should look up more info on HsGroup
19:40:46 <erisco> :t uncurry id
19:40:47 <lambdabot> (b -> c, b) -> c
19:41:02 <erisco> I do not understand this
19:41:32 <Iceland_jack> erisco: What is the type of the first argument of uncurry?
19:41:38 <erisco> :t uncurry
19:41:39 <lambdabot> (a -> b -> c) -> (a, b) -> c
19:42:19 <pavonia> so unify (a -> b -> c) with (d -> d)
19:42:28 <Iceland_jack> erisco: I'm sorry, I forgot the fixity of the type arrow (->), how does it get parsed?
19:42:37 <erisco> Iceland_jack, I do not know
19:42:55 <Iceland_jack>     a -> b -> c -> d
19:42:55 <Iceland_jack> is the same as
19:42:55 <Iceland_jack>     a -> (b -> (c -> d))
19:42:59 <erisco> sure
19:43:08 <erisco> oh
19:43:23 <Iceland_jack> which is why 'binary' functions in Haskell aren't really binary functions
19:43:27 <erisco> that was very difficult to see
19:43:40 <Iceland_jack> erisco: Does it make sense now?
19:44:13 <erisco> Iceland_jack, yes
19:44:36 <Iceland_jack> Also note that the type arrow associates to the right while application associates to the left
19:44:36 <Iceland_jack>     a → b → c     is    a → (b → c)
19:44:36 <Iceland_jack> while
19:44:36 <Iceland_jack>     f x y z       is    ((f x) y) z
19:44:36 <erisco> but reasoning about it is... confusing
19:44:50 <samba1> erisco, the exercises at the bottom of http://www.haskell.org/haskellwiki/Currying were enlightening to me
19:45:13 <Iceland_jack> Well the type of 'id' is
19:45:13 <Iceland_jack>     id :: a -> a
19:45:13 <Iceland_jack> for *any* a
19:45:40 <Iceland_jack> So the type of 'id' can be specialized to be
19:45:40 <Iceland_jack>     id :: Bool -> Bool
19:45:40 <Iceland_jack>     id :: Int  -> Int
19:45:40 <Iceland_jack>  
19:46:13 <Iceland_jack> but also
19:46:13 <Iceland_jack>     id :: (Int -> Bool) -> Int -> Bool    -- (remember right associative)
19:46:13 <Iceland_jack> or
19:46:13 <Iceland_jack>     id :: (a -> b) -> (a -> b)
19:46:20 <haasn> Iceland_jack: aha! I can access the underlying HsModule and look at its hsmodDecls :: [LHsDecl name] which contains the raw SpliceDs as they appear in the source; together with their SrcSpans! I can then build a map of those SrcSpans to figure out whether they refer to splice locations or actual definitions
19:46:47 <Iceland_jack> haasn: But you have to construct them yourself to gather that?
19:46:57 <haasn> Iceland_jack: not sure what you mean
19:47:09 <Iceland_jack> ah just misunderstood what you meant
19:48:03 <no-n> > take 100 [1,2,3]
19:48:04 <lambdabot>  [1,2,3]
19:50:08 * hackagebot identifiers 0.4.0.0 - Numeric identifiers for values.  http://hackage.haskell.org/package/identifiers-0.4.0.0 (awagner83)
19:51:52 <samba1> would anyone be willing to give me some commentary on a beginner's assignment?
19:52:07 <erisco> so.. uncurry id = uncurry ($)
19:52:11 <samba1> I was referred to try this old class http://www.seas.upenn.edu/~cis194/lectures.html
19:52:43 <samba1> I did assignment 12, simulating a board game Risk
19:52:49 <samba1> http://lpaste.net/2204267457865056256
19:53:01 <samba1> there's the code (my stuff starts after a comment)
19:53:09 <samba1> it works, but it's uglier than what i see elsewhere
19:53:14 <samba1> the tuples all over battle
19:53:23 <samba1> the if statement in successProb
19:53:56 <samba1> i was wondering if anyone had ideas for what would make it more cleaner
19:54:08 <levi> I'll take a quick look
19:54:57 <Iceland_jack> erisco: Yes, check this out
19:54:58 <Iceland_jack> > succ $ 10
19:54:59 <lambdabot>  11
19:55:02 <Iceland_jack> > succ `id` 10
19:55:03 <lambdabot>  11
19:55:17 <erisco> perplexing
19:55:24 <Iceland_jack> :)
19:56:16 <Iceland_jack> It twists your mind a little because one is so used to thinking of 'a' in
19:56:16 <Iceland_jack>     id :: a -> a
19:56:16 <Iceland_jack> being a non-function value
19:56:45 <erisco> no it is just that the types are inferred in the other direction
19:56:57 <Iceland_jack> What do you mean in the other direction?
19:57:04 <hcaulfield57> I'm trying to understand bind for the Cont monad, but I don't understand where the \x comes from? How does that lambda ever get it's argument?
19:57:07 <hcaulfield57> s >>= f  = cont $ \c -> runCont s $ \x -> runCont (f x) c
19:57:07 <no-n> @pl g x = not . f x
19:57:08 <lambdabot> g = (not .) . f
19:57:27 <geekosaur> :t runCont
19:57:28 <lambdabot> Cont r a -> (a -> r) -> r
19:57:48 <erisco> "id 5"  the argument is 5, so the return type is 5.  \a b -> id a b   well the return value is applied to 'b', so the argument must have been some b -> a
19:58:25 <Iceland_jack> you're using the same identifiers for types and values, but sure
19:58:34 <Iceland_jack> that's just normal type inference though
19:59:29 <hcaulfield57> geekosaur: Is the \x lambda end up being the argument to runCont s?
19:59:36 <erisco> sure, but I am not used to reasoning in that way
20:00:24 <geekosaur> it's a bit more complex and brain twisting than that. the Cont monad passes a manufactured function which "short-circuits" evaluation when invoked, producing a value immediately
20:00:40 <levi> samba1: Doesn't look that bad to me. Nothing wrong with tuples. Perhaps it could be cleaned up, but I'm afraid I don't have any advice.
20:01:00 <geekosaur> as such it has to be produce the same type as the result type of the computation (a in Cont r a)
20:02:10 <hcaulfield57> I keep looking at it, but I can't seem to grasp what it's saying, I understand bind in most of the other monads, but this one is elusive.
20:02:13 <levi> hcaulfield57: Are you familiar with continuation-passing-style in general?
20:02:26 <hcaulfield57> levi: No, I just wanted to test my knowledge of monads, and Haskell's type system.
20:02:38 <Tekmo> hcaulfield57: Which monad is this?
20:02:52 <geekosaur> it is difficult, yes
20:02:54 <geekosaur> Cont
20:03:10 <hcaulfield57> Tekmo: Which monad is what?
20:03:11 <geekosaur> I found a description/walkthrough once that helped me understand what was going on
20:03:12 <levi> Well, it would probably help to read up on continuation passing style first; it might help to have some idea of the semantics it's trying to model.
20:03:23 <geekosaur> Tekmo, they're trying to decipher Cont
20:03:52 <escondida> Okay, so kfLookup returns Maybe (IO ()), but GHC doesn't like it when I try to do anything with that: getFunction | kfLookup keys name /= Nothing = fromJust kfLookup keys name -> No instance for (Eq (IO ())) arising from a use of `/='
20:04:08 <hcaulfield57> levi: Probably true, I doing think I need it, I just wanted to 'test' myself like I said.
20:04:17 <hcaulfield57> Tekmo: Sorry, I didn't notice that you just joined.
20:04:21 <escondida> But...but...I don't want to check for IO equality! I just want to check whether a Maybe returned Nothing!
20:04:31 <Tekmo> escondida: That's because the `Eq` instance for `Maybe a`, requires that there is an `Eq` instance for `a` (i.e. `IO ()`) in your example, which there isn't
20:04:37 <Tekmo> escondida: However, you don't need to use equality
20:04:43 <escondida> No?
20:04:44 <escondida> Oh
20:04:46 <Tekmo> escondida: The correct solution is to use pattern matching
20:04:46 <escondida> Right
20:04:50 <escondida> Oh
20:04:59 <levi> hcaulfield57: Well, continuations are a very useful thing to know about anyway, so I would recommend reading up on them.
20:05:01 <Tekmo> case kfLookup keys name of Nothing -> ...
20:05:10 * hackagebot network-api-support 0.1.0 - Toolkit for building http client libraries over Network.Http.Conduit  http://hackage.haskell.org/package/network-api-support-0.1.0 (MarkHibberd)
20:05:21 <Tekmo> escondida: In fact, you should try to limit use of equality a lot when programming in Haskell.  Pattern matching is generally more idiomatic
20:05:33 <escondida> Tekmo: Fair enough
20:05:35 <hcaulfield57> levi: Oh, okay I will then, maybe I'll wait a little though, I'm still pretty fresh with the other monads, I just feel like I'm beginning to get the hang of it.
20:05:39 <escondida> Thanks again!
20:05:45 <Tekmo> escondida: You're welcome!
20:06:04 <escondida> I'm probably waaaaaaay overthinking all this, but hey, it's a learning exercise.
20:06:14 <levi> hcaulfield57: Well, I would look at continuations by themselves instead of trying to grasp the continuation monad.
20:07:00 <hcaulfield57> Okay I will
20:07:11 <Tekmo> hcaulfield57: Let me put together a paste that might help illustrate how bind works.  I can't do it in IRC because it's hard to show without formatting
20:07:12 <geekosaur> how Cont works is brainbending; much like IO, better off just learning how to use it and come back to how it works later
20:07:27 <levi> Tekmo: So, I am trying to use Pipes, Pipes.Parse, and Pipes.Group to do some parsing of a text markup format. And my poor brain does not seem to get along with the Pipes types.
20:07:28 <Tekmo> Cont is not brainbending once you know "the trick"
20:07:33 <Tekmo> It's just hard to explain "the trick" in words
20:08:00 <samba1> okay, thank you
20:08:35 <Tekmo> levi: Can you give me an example?
20:09:33 <levi> Tekmo: I would like to parse the text file a line at a time.  But my attempts to delimit by lines via FreeT and then parse via an Attoparsec or some other sort of parser have not gone very well.
20:10:09 <Tekmo> levi: There's already a line-delimited in `pipes-text` called `lines`
20:10:20 <levi> Well, yes, I saw that.
20:10:37 <Tekmo> levi: So are you trying to limit the parser to a single line of input?
20:10:41 <levi> But I haven't been able to *use* it for anything except trivial things like uppercasing all the characters.
20:11:43 <hcaulfield57> geekosaur: Yea, a lot of Haskell is brainbending
20:11:55 <levi> I may just give up on trying to limit it to a single line at a time and just have Pipes do basic input chunking.
20:11:56 <hcaulfield57> too many smart people use Haskell
20:13:25 <hcaulfield57> Tekmo: Thanks :)
20:13:32 <Tekmo> geekosaur hcaulfield57: This might help: http://lpaste.net/100904
20:14:09 <Tekmo> Oops, there is one small typo, but you should probably still be able to follow it
20:14:12 <levi> Tekmo: All the tutorial material you've written is very nice, but it illustrates a bunch of trivial tasks of little practical utility. There are so many different ways to combine things that it's not clear what ways make sense for solving actual problems.
20:14:28 <Tekmo> levi: That's why you need to explain what you are trying to do
20:14:57 <levi> I thought I did, but I guess it did not come out very clearly.
20:15:14 <Tekmo> Okay, I fixed the lpaste typo.  It's correct now
20:15:52 <Tekmo> levi: The part I didn't understand was how the line stuff interacts with attoparsec
20:16:46 <levi> Bascially, I want to parse a macro-based markup format (asciidoc). Everything can be parsed a line at a time; all the important markup happens at the beginning of a line.  So I want to be able to match certain patterns at the beginning of lines to determine what the lines mean.
20:18:12 <Tekmo> levi: So the simplest thing to do is not use the `FreeT` stuff at all
20:18:48 <levi> Yeah, I think the simplest thing at this point would be to just use parsing combinators and handle newlines there.
20:19:19 <Tekmo> levi: You write an `attoparsec` parser for one line of the ascii doc and then used `parsed` from `pipes-attoparsec`
20:19:36 <Tekmo> levi: I think I can make an analogy that will help you know when to use `pipes-attoparsec` and when to use `pipes-group`
20:20:01 <Tekmo> levi: Consider the normal case of simple `Text` (either pure or using lazy IO)
20:20:06 <levi> But it seemed so *nice* to think about splitting by lines, then transforming lines based on matching their beginnings, etc. So I went in that direction, and found lots of fighting with types.
20:20:10 <Tekmo> levi: There are two ways that you would normally process that text
20:20:25 <Tekmo> levi: Either you would do it using Data.List/Data.Text utilities to process it
20:20:31 <Tekmo> levi: Or you would use a parser combinator librar
20:20:34 <hcaulfield57> Tekmo: That seems relatively simple, at least without all the runCont boilerplate, I saved it on my computer, I'm going to have to look at it later, when I'm not so tired.
20:20:34 <Tekmo> levi: Typically not both
20:20:41 <hcaulfield57> Tekmo: Thank you
20:20:44 <Tekmo> levi: There's a similar analogy to pipes
20:20:47 <Tekmo> hcaulfield57: You're welcome!
20:21:12 <Tekmo> levi: `pipes-group` is analogous to the `Data.Text`/`Data.List` approach where you're doing everything by hand (i.e. splitting/transforming/grouping things yourself)
20:21:22 <Tekmo> levi: `pipes-attoparsec` is analogous to the parser combinator approach
20:21:37 <Tekmo> levi: You typically don't use both approaches at the same time, for the same reason that you don't typically do so on pure text
20:23:23 <escondida> Iceland_jack: Tekmo: I just wanted to thank you both again for your help. Thanks to your advice, I finally got it figured out, so maybe there's hope for this project after all. Much appreciated.
20:23:31 <levi> asciidoc is one of those screwy formats, like markdown, that was originally created by munging a line at a time with a bunch of regular expressions.
20:23:51 <Iceland_jack> escondida: No problem, don't hesitate to ask in the future
20:24:02 <escondida> I won't, thanks (-:
20:24:24 <Tekmo_> levi: Sorry about that
20:24:32 <Tekmo_> levi: What was the last thing you heard me say?
20:24:55 <levi> Tekmo_: "You typically don't use both approaches at the same time..."
20:25:04 <Qu4tro> hey. what would you guys use to check the existence of a word in a large dictionary?
20:25:07 <Tekmo_> Okay, that was the important bit
20:25:27 <levi> I explained a bit about why I thought about doing things that way.
20:25:41 <escondida> Qu4tro: Well, there's the lookup function
20:25:44 <Tekmo_> levi: so there is one interaction between them that you may find useful
20:25:47 <Tekmo_> levi: You may want to do this:
20:26:07 <Tekmo_> levi: zoom Pipes.Text.line (Pipes.Attoparsec.parse yourParser)
20:26:18 <Tekmo_> levi: That will limit your parser to a single line of input
20:26:25 <Tekmo_> levi: Note that it is `line` without an `s`
20:26:55 <Qu4tro> I was looking for something faster
20:27:08 <escondida> Ah, fair enough
20:27:14 <levi> Ahh, I thought zoom might come into play while I was reading through some of the haddocks, but it didn't occur to me while actually playing with the code.
20:27:16 <Tekmo_> Qu4tro: A hashset
20:27:40 <imalsogreg> I've been playing with 7.8 rc2 and finding (of course) a lot of hackage doesn't build.  I don't know the community history enough - is now the right time to be sending pull requests for the packages I use, or is it too early?
20:27:55 <Tekmo_> levi: `line` is a lens that points to the first line of input
20:28:12 <Tekmo_> levi: `zoom line parser` limits that parser to one line of input
20:28:43 <Tekmo_> levi: Note that it is the line without the terminating newline.  I'm not sure whether or not I should change that behavior, though
20:28:51 <levi> The thing is, asciidoc is interesting to me because it's an extensible markup, where you can specify new kinds of markup in config files via regular expressions. I wanted to do something similar, but using haskell modules and parser combinators.
20:29:07 <Qu4tro> Tekmo_: thanks
20:29:18 <Tekmo_> Qu4tro: Check out the `unordered-containers` library
20:29:31 <Tekmo_> Qu4tro: It contains very fast implementations of hashsets and hashmaps
20:30:03 <Tekmo_> levi: Can you elaborate on the last part (i.e. haskell modules and parser combinators)?
20:30:12 * hackagebot LogicGrowsOnTrees 1.1.0.2 - a parallel implementation of logic programming using distributed tree exploration  http://hackage.haskell.org/package/LogicGrowsOnTrees-1.1.0.2 (GregoryCrosswhite)
20:30:15 * hackagebot postmark 0.1.1 - Library for postmarkapp.com HTTP Api  http://hackage.haskell.org/package/postmark-0.1.1 (MarkHibberd)
20:30:17 <Tekmo_> levi: Oh wait, I think I get the idea
20:30:28 <Tekmo_> levi: You want Haskell to "be the configuration", right?
20:31:04 <levi> Being able to match stuff via parsing combinators stored in a data structure, which would be applied by the engine to each line to see if the line should follow the markup rules defined by that structure.
20:31:26 <Tekmo_> levi: Oh, that sounds like a neat problem!
20:31:54 <Tekmo_> levi: May I suggest one thing that you might find useful
20:32:03 <niotepx> Would it be possible for anyone to lend assitance to my problem here: http://stackoverflow.com/questions/22265724/haskell-android-opengl
20:32:14 <levi> So you see, I was not completely off my rocker in wanting to split things into lines via pipes. :)
20:32:28 <Tekmo_> levi: Let's say that you have a data structure that holds a parser that parses some markup that returns a value of type `a`
20:32:38 <Tekmo_> levi: Let's say that we parametrize your data structure on the parsed type
20:32:48 <Tekmo_> levi: i.e. HeaderParser a
20:33:01 <levi> OK
20:33:06 <Tekmo_> levi: Then it makes sense for `HeaderParser` to implement `Alternative` (like parsers do)
20:33:22 <Tekmo_> levi: That way, if you have two header parsers of two separate types, there is a neat way to unify them
20:33:24 <hcaulfield57> Could someone take a look at this, and tell me if it's the type of thing you may use the Reader monad for, it seemd unnecessary to me, but I was just trying things out.
20:33:25 <Tekmo_> What I mean by that is:
20:33:34 <hcaulfield57> http://lpaste.net/100906
20:33:34 <Tekmo_> levi: headerParserA :: HeaderParser A
20:33:41 <Tekmo_> levi: headerParserB :: HeaderParser B
20:33:53 <Tekmo_> levi: both :: HeaderParser (Either A B)
20:34:01 <Tekmo_> levi: both = fmap Left headerParserA <|> fmap Right headerParserB
20:34:19 <Tekmo_> levi: ... and you can generalize that to more than two by just using a larger ADT than `Either`
20:35:08 <Tekmo_> levi: I still think for your purpose that `pipes-attoparsec` suffices
20:35:11 <levi> Right, but to be a truly open type, you'd need to wander into crazy Data Types A La Carte territory, wouldn't you?
20:35:13 * hackagebot LogicGrowsOnTrees-processes 1.0.0.2 - an adapter for LogicGrowsOnTrees that uses multiple processes for parallelism  http://hackage.haskell.org/package/LogicGrowsOnTrees-processes-1.0.0.2 (GregoryCrosswhite)
20:35:15 * hackagebot LogicGrowsOnTrees-network 1.0.0.3 - an adapter for LogicGrowsOnTrees that uses multiple processes running in a network  http://hackage.haskell.org/package/LogicGrowsOnTrees-network-1.0.0.3 (GregoryCrosswhite)
20:35:17 * hackagebot LogicGrowsOnTrees-MPI 1.0.0.1.1 - an adapter for LogicGrowsOnTrees that uses MPI  http://hackage.haskell.org/package/LogicGrowsOnTrees-MPI-1.0.0.1.1 (GregoryCrosswhite)
20:35:24 <Tekmo_> levi: What do you mean by open type?
20:36:04 <levi> Well, the parent grammar has to have a sum type that encompasses all the possible alternatives, right?
20:36:35 <levi> Whenever I added a new alternative, I'd have to modify that grammar element with the new alternative.
20:39:17 <levi> The idea is that a user of the program can supply a new kind of custom element without having to modify the core of the parser.
20:40:38 <levi> In the original Python implementation, *most* of the markup is specified in configuration files based on a few core bits of syntax and parsing logic, though it took me a while to realize that.
20:41:00 <levi> Ahh, I'm afraid I've been talking to myself again.
20:43:44 <Tekmo> levi: Sorry about that.  My internet had problems
20:44:10 <Tekmo> Please block nowis.  He's messaging people with spam
20:46:53 <hcaulfield57> Comments anyone? http://lpaste.net/100906
20:48:20 <levi> Tekmo: What was the last you saw from me?
20:49:27 <levi> "had"? Such optimism.
20:50:27 <levi> hcaulfield57: Yeah, that looks like a typical use of Reader to me.
20:52:00 <hcaulfield57> levi: Thanks, okay I wasn't sure, I never know
20:52:25 <kloplop321> levi, feel free to send Tekmo this grep'ed log entry when his network isn't dying. http://pastebin.com/rpCuihX5
20:52:42 <levi> Although the utility of it in that particular example is arguable.  Usually you'd need a whole bunch of actions that required a bunch of parameters to justify the Reader, otherwise you'd just pass the parameter manually.
20:53:44 <hcaulfield57> levi: Right, okay, I imagined as much, it was more an example for me to learn, I suppose
20:53:53 <levi> I actually need to go AFK for a while.  Laundry just finished.
21:00:07 <erisco> still twisting my head around arrows... I am not sure I am using ArrowApply correctly. Particularly, I have no idea how to make my run function work http://lpaste.net/100907
21:00:49 <kloplop321> Tekmo: http://pastebin.com/rpCuihX5 Here's what you have missed
21:01:22 <Tekmo> kloplop321: Thank you so much!
21:01:35 <erisco> there is no information on the app value... so I don't know what you are supposed to do with it
21:02:31 <Tekmo> levi: For when you getback: The idea is that it's not your responsibility to unify things at all.  The end user is responsible for unifying things at the last moment.
21:04:58 <hcaulfield57> Tekmo,levi: thanks again
21:13:52 <mdjnewman> Hi all, does anyone here use vim-hdevtools? I'm having trouble getting it set up
21:22:25 <TallerGhostWalt> So what does ({...}) with 3 dots mean?
21:22:50 <michaelt> is this RecordWildCards?
21:22:55 <Tekmo> TallerGhostWalt: Yeah, I think so
21:23:06 <TallerGhostWalt> isn't that {..}
21:23:10 <TallerGhostWalt> ?
21:23:14 <Tekmo> TallerGhostWalt: The RecordWildCards extensions uses that to bring all fields of that record into scope as variables of the same name
21:23:15 <michaelt> oh
21:23:38 <TallerGhostWalt> https://www.fpcomplete.com/school/to-infinity-and-beyond/pick-of-the-week/a-little-lens-starter-tutorial#okay--what-are-prisms-
21:23:59 <TallerGhostWalt> they run a lens over a ({...})
21:24:14 <TallerGhostWalt> I can't find it and searching for {...} is a futile endeavor
21:24:25 <Tekmo> TallerGhostWalt: First, it looks like that is just pseudocode
21:24:37 <haasn> (I can't find it in the page you mentioned)
21:24:42 <Tekmo> TallerGhostWalt: However, even if it weren't, that would bind tighter to the constructor than the lens operator
21:24:48 <haasn> oh, spaces
21:25:06 <haasn> TallerGhostWalt: yes, that's not actual Haskell
21:25:18 <haasn> Or maybe it is? Is . a valid Module name?
21:25:22 <iduhetonas> I did, but I switched to ghc-mod for vim
21:25:22 <iduhetonas> mdjnewman: What's the problem?
21:25:23 <TallerGhostWalt> Right I mean it made no sense but you know when you are learning stuff it is hard to tell
21:25:30 <haasn> If so that would be a qualifier operator named (.) in the module .
21:25:47 <haasn> Oh, that would still be invalid, missing a =
21:26:03 <TallerGhostWalt> Is there a way to traverse all the methods of a record type without explicitly naming them then?
21:26:33 <haasn> To answer my own question: . is not a valid module name
21:26:56 <haasn> TallerGhostWalt: assuming they have the same type?
21:26:58 <TallerGhostWalt> I am writing a custom instance for an encoding.. Each field will be encoded the same way so I have a toEncoding typeclass
21:27:10 <michaelt> TallerGhostWalt: yeah, I see that is a little confusing, espcially where he puts in the braces.
21:27:29 <haasn> if it's polymorphic, you may want the standard Traversable
21:27:54 <haasn> if it's monomorphic, lens actually provides an ‘Each’ type class to abstract over traversals like that
21:27:54 <Iceland_jack> Tekmo_: Types that you could add variants too in different files/modules and add cases to functions while retaining type safety
21:27:54 <Iceland_jack> *to
21:27:54 <Iceland_jack> levi: There are nicer ideas for how you could encode that like http://www.andres-loeh.de/OpenDatatypes.pdf
21:27:54 <Iceland_jack> Data types à la carte is a pretty heavy approach
21:27:54 <Iceland_jack> even (especially…?) using something like 'compdata'
21:28:03 <TallerGhostWalt> okay I had no idea you could use traversable like that
21:28:03 <haasn> Iceland_jack: is your connection dodgy?
21:28:03 <mdjnewman> iduhetonas: I've followed the steps on the readme but I get "Not an editor command: HdevtoolsClear" or similar when I try any of the vim-hdevtools commands
21:28:18 <Iceland_jack> What do you mean by grammar element?
21:28:18 <Iceland_jack> According to the paper you could do
21:28:18 <Iceland_jack>     open data Expr :: *
21:28:18 <Iceland_jack>     open eval :: Expr -> Int
21:28:18 <Iceland_jack> and
21:28:18 <Iceland_jack>     Num :: Int -> Expr
21:28:18 <Iceland_jack>     eval (Num n) = n
21:28:18 <Iceland_jack> and
21:28:18 <Iceland_jack>     Plus :: Expr -> Expr -> Expr
21:28:18 <Iceland_jack>     eval (Plus a b) = eval a + eval b
21:28:18 <Iceland_jack> all in different files or modules
21:28:23 <Iceland_jack> levi: You should be able to implement something like that with the techniques from Data types à la carte
21:28:24 <Iceland_jack> If it's not recursive then it's trivial, just adding a new variant to the sum type
21:28:24 <Hodapp> Oh God, he's talking to himself again.
21:28:24 <Iceland_jack> Talking to themselves about talking to themselves, that can't be good…
21:28:25 <mdjnewman> iduhetonas: I don't think vim-hdevtools is loaded (doesn't appear in scriptnames) but I don't know why
21:28:37 <mdjnewman> iduhetonas: hdevtools is on the path and working fine
21:28:47 <Iceland_jack> haasn: hm, I don't think so, maybe my remote server is acting up
21:29:04 <haasn> Iceland_jack: it might be related to the large paste you just made and some sort of internal throttling
21:29:14 <haasn> Iceland_jack: but about two dozen messages just arrived simultaneously from you
21:29:19 <Iceland_jack> haasn: What?
21:29:27 <Iceland_jack> What paste did I make? I'm not seeing any in my log
21:29:28 <iduhetonas> mdjnewman: What's the output of :filetype ?
21:29:43 <mdjnewman> iduhetonas: "filetype detection:ON  plugin:OFF  indent:OFF"
21:29:55 <Iceland_jack> are you talking about the open type thing around 20 minutes ago?
21:29:59 <haasn> Iceland_jack: http://lpaste.net/100908
21:30:32 <haasn> freenode might also be acting up. My ping is unusually high
21:30:41 <Iceland_jack> oh, that happened quite some time ago
21:30:47 <iduhetonas> mdjnewman: Do :filetype plugin indent on
21:30:50 <k_89> so someone pointed me to some article here that lisp is not functional .. its very much like ruby
21:30:51 <Iceland_jack> odd
21:31:07 <Iceland_jack> k_89: Are you referring to my post?
21:31:10 <k_89> it was just the first one to be that way
21:31:12 <iduhetonas> mdjnewman: In particular, do :filetype plugin. You may need to do it in your vimrc
21:31:13 <k_89> Iceland_jack, i think so
21:31:16 <k_89> yeah
21:31:43 <iduhetonas> mdjnewman: Oops, I mean, :filetype plugin on
21:31:44 <Iceland_jack> Whether a language is functional doesn't have much meaning, it's depends on the culture as much as the language imo
21:32:32 <k_89> but then there are langs like java, which *cannot* have a culture different from the one it has
21:32:43 <mdjnewman> iduhetonas: Thanks! putting that in my vimrc seems to have fixed it
21:32:43 <haasn> I prefer to promote declarative programming (as opposed to imperative programming), rather than functional programming (as opposed to programming without functions)
21:32:53 <Iceland_jack> Why couldn't Java have a different function?
21:32:54 <k_89> its made in such a way that it'd result in what it resulted in
21:33:00 <iduhetonas> mdjnewman: No problem!
21:33:14 <k_89> Iceland_jack, not a different function, but a different ecosystem
21:33:17 <mdjnewman> iduhetonas: Still having some issues with sandboxes but I think I read something about that elsewhere
21:33:26 <haasn> (doesn't Java 8 have something like first class functions now?)
21:33:29 <k_89> same with haskell, or any other purely functional language
21:33:36 <k_89> haasn, they suck hard
21:33:39 <k_89> very hard
21:33:56 <k_89> they are just so damn verbose to use
21:34:02 <k_89> scala is much better
21:34:04 <haasn> I wasn't planning on using them :)
21:34:07 <Iceland_jack> k_89: They are quite verbose in Common Lisp
21:34:12 <iduhetonas> mdjnewman: Yeah, I had a bunch of issues with hdevtools. ghc-mod for vim works much better, but it requires a few more extra steps. And it works for sandboxes
21:34:17 <Iceland_jack> and Common Lisp is a Lisp-2
21:34:44 <Iceland_jack> Anyway, Common Lisp is a 'multiparadigm' programming language
21:35:12 <Tekmo> Haskell is unique in a lot of ways, even among functional languages
21:35:25 <Iceland_jack> discussing the extent of which that languages are functional has been done to death on the Internet I believe :)
21:35:32 <Tekmo> One of the things I love the most about Haskell are all the mathematical abstractions (i.e. Functor/Monad/Monoid/Category/etc.)
21:35:33 <mdjnewman> iduhetonas: Thanks again, will look into ghc-mod if I don't have any luck with hdevtools
21:35:36 <Iceland_jack> Can someone block kb nowis?
21:35:38 <mdjnewman> iduhetonas++
21:35:48 <Tekmo> You just don't see those mathematical abstractions very much in other languages
21:35:48 <haasn> I think the most unique feature Haskell has is type classes
21:36:00 <Tekmo> That I think is the real loss when you switch from Haskell to other functional languages
21:36:09 <haasn> and among the other “unpopular” (in terms of languages) features are purity and nonstrictness
21:36:12 <k_89> php is kind of the best example of a multi-paradigm language used a lot in real world
21:36:20 <Tekmo> The other major loss is the lack of equational reasoning in other languages
21:36:39 <k_89> you have several parallel ecosystems existing in php, each with different style of programming
21:37:08 <nisstyre_> k_89: any other paradigm than procedural templates is poorly supported though
21:37:16 <k_89> not really
21:37:17 <nisstyre_> because the earlier features cancel out better features
21:37:29 <nisstyre_> e.g. you cannot do lexical closures in PHP
21:37:35 <nisstyre_> without it breaking things
21:37:54 <k_89> well, you need to import variables into closures
21:37:56 <nisstyre_> so they hacked around it by making the programmer specify which variables to use in the closed function
21:38:10 <nisstyre_> k_89: because it's impossible to calculate the set of free vars in a function
21:38:12 <nisstyre_> in php that is
21:38:19 <nisstyre_> in Haskell it's pretty simple
21:38:22 <k_89> yeah, but it doesn't get in the way much, because $this
21:38:30 <k_89> haskell is leagues apart that way
21:38:46 <levi> iduhetonas: hdevtools can be made to work with sandboxes, you just have to pass it the correct ghc command line options.
21:39:14 <k_89> but my point was php is kind of the most widely used language which supports several different paradigms and all of them are used professionally by different sections
21:39:22 <k_89> of its developer base
21:39:34 <nisstyre_> there are professional PHP programmers programming in a heavily functional style?
21:39:45 <iduhetonas> levi: Good to know. I haven't tried, since I had issues with hdevtools before I started using sandboxes.
21:40:14 <zomg> nisstyre_: I don't think the language bends too well to that, but I've written a bunch of helpers for it to do fp style stuff
21:40:20 <k_89> nisstyre_, well, sort of, there is functional style code scattered across several "modern" php libs
21:40:21 * hackagebot conduit-combinators 0.2.0.1 - Commonly used conduit functions, for both chunked and unchunked data  http://hackage.haskell.org/package/conduit-combinators-0.2.0.1 (MichaelSnoyman)
21:40:21 <zomg> which certainly can make some things less painful to do
21:40:29 <levi> iduhetonas: The big upside to hdevtools is that it's much faster than ghc-mod. It makes a good on-the-fly checker that updates whenever you take a break from typing.
21:40:32 <nisstyre_> zomg: I implemented trampolining in PHP one time
21:40:37 <nisstyre_> it was pretty hilarious
21:40:39 <zomg> scary =)
21:40:53 <nisstyre_> much more verbose and ugly than the equivalent python
21:41:03 <michaelt> Tekmo: I tried to write some of the little networking hello-worlds Michael put up for conduit the other day.  The only interesting one, though I couldn't figure out how best to express.  its `checkAuth` here
21:41:07 <k_89> i made a monad of sorts over orm which is kinda pretty cool, lets you define your own data query lanugage
21:41:28 <k_89> i mean like from whatever i have read about monads, its a monad
21:41:28 <iduhetonas> levi: Definitely. Though it tends to occasionally spawn a bunch of extra processes. Which isn't really much of a problem, honestly
21:41:50 <nisstyre_> zomg: I could have used a while loop for what I needed to do, but I was feeling particularly pissed off
21:42:23 <michaelt> Tekmo its supposed to be a pipe, but it does some parsing at the same; I became alittle confused
21:42:25 <levi> Modern PHP seems fairly indistinguishable from your average dynamically typed object-oriented language. I'm not sure what its purpose for being is anymore.
21:42:41 <nisstyre_> levi: things like wikipedia and facebook
21:42:45 <nisstyre_> and, sadly, wordpress
21:42:54 <Tekmo> michaelt: Can you link to the example?
21:43:18 <iduhetonas> Does PHP have a language specification yet? Last I tried to find, it was a spaghetti nightmare underneath
21:43:20 <levi> Well, yeah, they all chose PHP back when it was a fairly unique thing.
21:43:24 <nisstyre_> iduhetonas: hahahaha
21:43:34 <zomg> iduhetonas: it's probably in rasmus' head if it exists
21:43:36 <michaelt> sorry I thought I did http://lpaste.net/6677225920962494464  paste messup.  its from the post http://www.yesodweb.com/blog/2014/03/network-conduit-async
21:43:45 <nisstyre_> iduhetonas: the syntactic spec is basically the parser generator code
21:43:49 <zomg> iduhetonas: there are attempts to standardize some things in the PSR specs though
21:43:50 <nisstyre_> there is no semantic spec
21:43:53 <Iceland_jack> I believe the PHP standard is formally verified in Agda
21:43:56 <nisstyre_> that would be a huge undertaking
21:44:05 <k_89> php has no spec
21:44:23 <haasn> Haskell has no formal semantics :(
21:44:38 <zomg> Yeah, the PSR ones are for PHP code you write rather than PHP itself so yeah I guess not =)
21:44:41 <nisstyre_> haasn: you could probably put one together in SML no?
21:45:34 <haasn> well, Haskell has no formal semantics the way there's no no description of particle physics
21:45:37 <k_89> however several interesting things are happening around php, facebook people are developing hhvm JIT for php
21:45:55 <michaelt> Tekmo: this isn't correct, to judge from the behavior but it was my first attempt; it's a little unpleasant apart from being wrong somewhere http://lpaste.net/100909
21:45:57 <Tekmo> michaelt: Okay, I understand the question now
21:46:03 <k_89> which offers some pretty good improvements
21:46:15 <k_89> via their own dialect of php, called "hack"
21:46:26 <haasn> great name
21:46:34 <zomg> vkontakte claims their php vm is even faster
21:46:35 <Tekmo> michaelt: So you are on the right track with the way you wrote it
21:46:40 <zomg> kphp or whatever it was called
21:46:50 <Tekmo> michaelt: It would be a function from Producers to Producers and use `runStateT` for each parsing step
21:46:58 <Tekmo> michaelt: Let me see if I can find any logical problems
21:47:01 <levi> Haskell has a fairly detailed informal specification of its semantics, though.  PHP just has a manual.
21:47:16 <levi> k_89: Facebook has some static analysis tools for PHP, too.
21:47:20 <etqqkoiflwhb> What would be a good book (http://www.haskell.org/haskellwiki/Books), which isn;t aimed at beginner programmers to start learning Haskell?
21:47:26 <Tekmo> michaelt: Found it
21:47:30 <Iceland_jack> etqqkoiflwhb: Learn you a Haskell
21:47:32 <Iceland_jack> @where lyah
21:47:32 <lambdabot> http://www.learnyouahaskell.com/
21:47:39 <Tekmo> michaelt: So the issue here is that I think I chose the wrong default for `Pipes.ByteString.line`
21:47:50 <Tekmo> michaelt: RIght now it currently defaults to not including the newline character
21:47:56 <michaelt> oh
21:47:58 <Tekmo> michaelt: However, this has tripped up a lot of people (including myself)
21:48:02 <Iceland_jack> LYAH may seem simle at times but it isn't really aimed at beginner programmers and is a good place to start
21:48:04 <Tekmo> michaelt: I think I will push a patch to change this
21:48:28 <k_89> levi, hack is pretty interesting though .. http://www.sitepoint.com/hhvm-hack-part-1/
21:48:32 <haasn> LYAH quite explicitly states its intentions to be aimed at those with imperative experience but new to nonstrict pure functional programming
21:48:33 <michaelt> right, I was just now mentioning that it was wrong, but yes I was on the path to discover that, now that I think of it
21:48:38 <levi> k_89: They are written in Ocaml. I read through a bit of the code; they seemed pretty insecure about how their language features compared to Haskell's. ;)
21:48:45 <k_89> basically a staticaly type interpreted lang
21:48:51 <k_89> hehe
21:49:04 <Tekmo> michaelt: Yeah, let me write up a replacement one that you can temporarily use and if it works then I'll patch `pipes-bytestring`
21:49:07 <michaelt> Tekmo: the error was it rejects you immediately after getting the username, before it hears the password, as you already inferred
21:49:18 <Tekmo> michaelt: Yeah, that would make sense
21:49:37 <Tekmo> michaelt: Yeah, the more I think about it the more I'm sure that `line` should include the newline
21:50:13 <etqqkoiflwhb> Iceland_jack: thanks, any other book which progresses at a slightly higher place?
21:50:49 <Iceland_jack> I suppose, but you can always skipt parts of LYAH if you feel it goes too slow: a good thing about LYAH is the order in which it presents concepts
21:50:54 <michaelt> Tekmo: I see, but the approach is more or right apart from the line difficulty.  Thats more what I was wondering about.
21:51:07 <michaelt> more of less right
21:51:10 <michaelt> bah
21:51:18 <no-n> lyah is great
21:51:47 <no-n> i might read real world haskell afterwards but idk
21:52:58 <etqqkoiflwhb> yea, i read a few pages of RWH, detailed examples, didn;t seem structured though
21:53:51 <levi> k_89: You'd think that with all the resources they invested in re-writing PHP, they could have re-written their codebase to use OCaml or something instead, which already has all those features they're adding to PHP. :P
21:54:27 <Hodapp> levi: Greenspun's Tenth Rule and the Second System Effect don't seem to combine for good results there.
21:54:53 <zomg> Yeah it's curious how they spend so much time to do that.. I guess it's because they have a very significant amount of PHP code
21:57:38 <levi> Hodapp: Well, it has been done successfully before. Twitter completely rid itself of its Ruby on Rails frontend.
21:58:30 <Hodapp> levi: Yeah... I'm just saying that the mere presence of Greenspun's Tenth Rule doesn't mean someone's going to try to make anything elegant out of it :)
21:59:00 <zomg> If you think of what twitter does, they do a lot less than say FB
21:59:11 <zomg> so for them, migrating languages would be much less of a thing than for FB
22:01:02 <erisco> what is an instance of ArrowApply that is not (->) or some newtype wrapper?
22:01:34 <Tekmo> Kleisli, I think
22:02:28 <levi> Well, it's a bit moot now that FB has invested so heavily in evolving PHP.  I'm curious whether their usage of Haskell in the back end will increase, and how the Haxl stuff is going.
22:02:41 <erisco> Tekmo, Kleisli is a newtype
22:03:06 <Tekmo> erisco: Oh, I misunderstood your question.  Sorry!
22:03:15 <Tekmo> michaelt: Try this version: http://lpaste.net/100911
22:03:22 <erisco> I don't see how you can instance Apply without function application
22:03:32 <erisco> I can't think of any other way to.. well.. do application
22:03:58 <hellwolf> Hi, as in this example: http://pastebin.com/E6qMmygV , I would like to call toMArray in a function regardless of what instance p belongs to, how I can do that?
22:05:22 <Tekmo> hellwolf: So your current code does not compile?
22:05:29 <hellwolf> no
22:05:40 <hellwolf> Could not deduce (MPacket p a0 (ST s))       arising from a use of `toMArray'
22:05:51 <Tekmo> You need to add that as a constraint to your function's type signature
22:06:10 <Tekmo> Notice how the example you gave has a `MPacket p a m` constraint on the type signature
22:08:25 <hellwolf> What more should I add in this case?
22:08:55 <Tekmo> hellwolf: Can you show what your code currently looks like?
22:09:34 <hellwolf> sure http://pastebin.com/c4e0YXSG
22:09:47 <hellwolf> with {-# LANGUAGE MultiParamTypeClasses, FlexibleContexts #-}
22:10:25 * hackagebot http-reverse-proxy 0.3.1 - Reverse proxy HTTP requests, either over raw sockets or with WAI  http://hackage.haskell.org/package/http-reverse-proxy-0.3.1 (MichaelSnoyman)
22:10:26 * hackagebot mono-traversable 0.4.0.1 - Type classes for mapping, folding, and traversing monomorphic containers  http://hackage.haskell.org/package/mono-traversable-0.4.0.1 (MichaelSnoyman)
22:10:28 * hackagebot wai 2.1.0 - Web Application Interface.  http://hackage.haskell.org/package/wai-2.1.0 (MichaelSnoyman)
22:10:30 * hackagebot wai-app-static 2.0.0.3 - WAI application for static serving  http://hackage.haskell.org/package/wai-app-static-2.0.0.3 (MichaelSnoyman)
22:10:33 * hackagebot wai-eventsource 2.0.0.1 - WAI support for server-sent events  http://hackage.haskell.org/package/wai-eventsource-2.0.0.1 (MichaelSnoyman)
22:10:41 <Tekmo> hellwolf: May I suggest that you use `vector` instead of arrays?
22:11:02 <Tekmo> hellwolf: `vector` is usually the standard solution for this sort of thing
22:11:31 <michaelt> Tekmo: I get to enter my password! but it still rejects me; there may be some simple error elsewhere I'm using http://lpaste.net/100912 at the moment
22:13:40 <hellwolf> Tekmo: ok sounds a good suggestion. In that case, I probably don't need this level of complication.
22:13:57 <Tekmo> hellwolf: There is something similar in `Data.Vector.Mutable`, but it's easier to work with
22:14:04 <Tekmo> hellwolf: Also, in most cases you don't need the mutable API at all
22:14:16 <Tekmo> hellwolf: You will get equivalent performance using the pure API most of the time
22:15:35 * hackagebot wai-extra 2.1.0 - Provides some basic WAI handlers and middleware.  http://hackage.haskell.org/package/wai-extra-2.1.0 (MichaelSnoyman)
22:15:37 * hackagebot wai-frontend-monadcgi 2.0.0.1 - Run CGI apps on WAI.  http://hackage.haskell.org/package/wai-frontend-monadcgi-2.0.0.1 (MichaelSnoyman)
22:15:39 * hackagebot wai-handler-fastcgi 2.0.0.1 - Wai handler to fastcgi  http://hackage.haskell.org/package/wai-handler-fastcgi-2.0.0.1 (MichaelSnoyman)
22:15:41 * hackagebot wai-handler-launch 2.0.1.1 - Launch a web app in the default browser.  http://hackage.haskell.org/package/wai-handler-launch-2.0.1.1 (MichaelSnoyman)
22:15:43 * hackagebot wai-handler-scgi 2.0.0.1 - Wai handler to SCGI  http://hackage.haskell.org/package/wai-handler-scgi-2.0.0.1 (MichaelSnoyman)
22:16:11 <Tekmo> michaelt: What is the exact failure that you get?
22:16:21 <Tekmo> michaelt: Oh, I think I know
22:16:34 <Tekmo> michaelt: So now the issue is that it is including the newline in your username and password! :)
22:16:42 <michaelt> just the obvious error, i enter spaceballs, then 12345 and it pretend not to know me
22:16:56 <Tekmo> michaelt: Damned if we do and damned if we don't! :)
22:17:07 <hellwolf> Tekmo: I'm doing a block encoding library, which seems to me doing mutable-structure/un-boxed-value-update would be more efficient. And still, in general how can I achieve this: I define a typeclass A with a function f, some other functions on A "a" which use f to do something regardless what instance of A is "a" from
22:17:15 <Tekmo> michaelt: You need to drop the last character for both the username and password and then it will work
22:17:19 <michaelt> yes i included the blank user and password with the same result
22:17:35 <Tekmo> michaelt: Drop the trailing newline from both of them and then it will work
22:17:40 <michaelt> oh wait, right, I didn't adjust my reasoning
22:18:30 <Tekmo> michaelt: So you see, this was the original reason I removed the newline from `line`
22:18:36 <Tekmo> michaelt: To prevent what just happened
22:19:01 <Tekmo> michaelt: However, it just occurred to me that there is a simple workaround that doesn't involve defining a new `line'` function
22:19:19 <Tekmo> michaelt: Give me a second to rework your paste and simplify it
22:19:20 <michaelt> oh wait it's still not working. I just applied B.init to the two concatenated snippets, was that wrong?
22:20:13 <Tekmo> michaelt: Print out the username and password to see what is going into the authorization
22:20:37 <Tekmo> michaelt: Give me a second to simplify your code.  You actually have a lot of unnecessary state passing that can be abstracted away by keeping more things in the parser
22:20:45 * hackagebot wai-test 2.0.0.2 - Unit test framework (built on HUnit) for WAI applications.  http://hackage.haskell.org/package/wai-test-2.0.0.2 (MichaelSnoyman)
22:20:47 * hackagebot wai-websockets 2.1.0 - Provide a bridge betweeen WAI and the websockets package.  http://hackage.haskell.org/package/wai-websockets-2.1.0 (MichaelSnoyman)
22:20:49 * hackagebot warp 2.1.0 - A fast, light-weight web server for WAI applications.  http://hackage.haskell.org/package/warp-2.1.0 (MichaelSnoyman)
22:20:51 * hackagebot warp-static 2.0.1 - Static file server based on Warp and wai-app-static  http://hackage.haskell.org/package/warp-static-2.0.1 (MichaelSnoyman)
22:20:53 * hackagebot warp-tls 2.0.3.1 - HTTP over SSL/TLS support for Warp via the TLS package  http://hackage.haskell.org/package/warp-tls-2.0.3.1 (MichaelSnoyman)
22:21:14 <Tekmo> michaelt: Oh wait, never mind, you have `yield`s interspersed, so it can't be simplified that much
22:22:39 <kloplop321> Has anyone done anything with WAI like listening *also* on UDP but with a null response sink?
22:25:55 * hackagebot yesod-auth 1.2.7 - Authentication for Yesod.  http://hackage.haskell.org/package/yesod-auth-1.2.7 (MichaelSnoyman)
22:25:57 * hackagebot yesod-bin 1.2.7 - The yesod helper executable.  http://hackage.haskell.org/package/yesod-bin-1.2.7 (MichaelSnoyman)
22:25:59 * hackagebot yesod-core 1.2.7 - Creation of type-safe, RESTful web applications.  http://hackage.haskell.org/package/yesod-core-1.2.7 (MichaelSnoyman)
22:26:01 * hackagebot yesod-form 1.3.6 - Form handling support for Yesod Web Framework  http://hackage.haskell.org/package/yesod-form-1.3.6 (MichaelSnoyman)
22:26:03 * hackagebot yesod-websockets 0.1.0.0 - WebSockets support for Yesod  http://hackage.haskell.org/package/yesod-websockets-0.1.0.0 (MichaelSnoyman)
22:27:29 <Tekmo> michaelt: Out of curiosity, why do you `tail` the password?
22:28:02 <michaelt> Tekmo: oh yeah I noticed that but omitted it; it must have been when I was realizing it was newlines at stake
22:28:10 <michaelt> with the opposite idea of the right one
22:28:27 <michaelt> this was yesterday morning, I think
22:29:01 <Tekmo> michaelt: So what happens if you print out the username and password?  Do they parse correctly?
22:30:05 <michaelt> oh I see them now, of course the interpolated debug strings are going to the other terminal
22:30:23 <Tekmo> Are they correct?
22:31:36 <michaelt> http://lpaste.net/9037444573353213952 Tekmo
22:31:58 <Tekmo> Oh, that's because `line` only looks for '\n'
22:33:15 <Tekmo> michaelt: All the `pipes-bytestring` functions copy the behavior of the `bytestring` library (which also only looks for '\n' and not '\r\n')
22:34:51 <Tekmo> All you have to do to fix it is to change the `to` function of `line'`: to p = p ^. break (== cr) >>= \p' -> p' ^. splitAt 2 where cr = iForgotTheAsciiCode
22:35:09 <michaelt> ah, okay it is becoming clearer.  Now that I think of it, snoyman's original should have led me to expect this
22:35:29 <michaelt> but i couldn't to the point of entering my password!
22:36:40 <hellwolf> I made an abstract sample of what I would like to have: http://pastebin.com/U3gXm3ZM  -- line 13 doesn't ocmpile
22:37:04 <Tekmo> michaelt: I have to head out now, but if you have any other questions feel free to e-mail me
22:45:28 * hackagebot keter 1.2.0 - Web application deployment manager, focusing on Haskell web frameworks  http://hackage.haskell.org/package/keter-1.2.0 (MichaelSnoyman)
22:46:19 <hellwolf> this version: http://pastebin.com/68ntZSPC how can I achieve g2 function?
22:48:41 <ezrios> hellwolf: doesn't compile, why?
22:48:46 <ezrios> why not paste the error as well
22:50:29 * hackagebot http-conduit 2.0.0.8 - HTTP client package with conduit interface and HTTPS support.  http://hackage.haskell.org/package/http-conduit-2.0.0.8 (MichaelSnoyman)
22:50:49 <hellwolf> right: http://pastebin.com/tR7UhJDK
22:52:48 <ezrios> hellwolf: is iA not a typo?
22:52:51 <ezrios> on like 9
22:52:54 <ezrios> s/like/line
22:53:20 <mirpa> hellwolf: how do you know that 'v' in (B v) is an instance of ClassA?
22:54:28 <hellwolf> ezrios: I don't think so, at least compiler doesn't think so too
22:55:55 <hellwolf> mirpa: v is not, but return value of toClassA in B is (A v v), which should be
22:57:27 <mirpa> try to define 'f (B v) = A v v' as standalone function and ask compilere what is type of f
22:58:16 <hellwolf> k :: B -> A
22:59:28 <jle`> aw just missed Tekmo
22:59:38 <hellwolf> maybe I have misunderstanding of typeclass, I'm beginner, I thought A is an instance of ClassA so if B -> A then B -> ClassA should also be the case.
23:00:00 <hellwolf> mirpa: is there a way of "casting" A to ClassA?
23:01:04 <ezrios> hellwolf: why do you have the context ClassA iA on line 9?
23:02:22 <hellwolf> ezrios: trying to express the idea that the result should be an instance of ClassA
23:03:14 <ezrios> hellwolf: which instance?
23:04:56 <ezrios> ah nevermind
23:06:15 <mirpa> hellwolf: replacing toClassA with 'undefined' and getting its type gives: toClassA :: (ClassB b, ClassA iA) => b -> iA
23:10:31 * hackagebot buildbox 2.1.4.1 - Rehackable components for writing buildbots and test harnesses.  http://hackage.haskell.org/package/buildbox-2.1.4.1 (BenLippmeier)
23:14:01 <mirpa> hellwolf: I would guess that problem is that in (B v) you don't know that 'v' is an Int
23:14:07 <iduhetonas> Could anybody give me an example for the "maybe" function?
23:14:17 <iduhetonas> @hoogle maybe
23:14:18 <lambdabot> Prelude maybe :: b -> (a -> b) -> Maybe a -> b
23:14:18 <lambdabot> Data.Maybe maybe :: b -> (a -> b) -> Maybe a -> b
23:14:18 <lambdabot> Foreign.Marshal.Utils maybeNew :: (a -> IO (Ptr a)) -> (Maybe a -> IO (Ptr a))
23:14:34 <jle`> iduhetonas: for uses?
23:14:36 <andkore> So I'm reading http://blog.tmorris.net/posts/haskell-functions-take-one-argument/index.html. Having trouble understanding this bit: filter f =
23:14:36 <andkore>   foldRight (\a -> if f a then (a:.) else id) Nil
23:14:53 <jle`> > maybe "no number found" show (Just 10)
23:14:54 <lambdabot>  "10"
23:14:55 <andkore> He says: "I will hear this question:
23:14:55 <andkore> The argument to foldRight (which is itself a function) takes two arguments, however, the function you passed to foldRight has been specified to take only one (which you have called a). How could this even work?" <-- I don't see how that's wrong.
23:14:57 <jle`> > maybe "no number found" show Nothing
23:14:58 <lambdabot>  "no number found"
23:14:59 <geekosaur> simple example: if you want to substitute a default value for Nothing, you could use something like: maybe 0 id $ some computation that produces Just a number or Nothing
23:15:00 <iduhetonas> jle`: Nah, more just a computation that it'll accept. I'm having a hard time wrapping my head around it
23:15:08 <iduhetonas> jle`: Awesome, that works. Thanks!
23:15:25 <jle`> iduhetonas: it's a very common pattern if you ever do something like
23:15:36 <jle`> case x of Just x' -> f x'; Nothing -> something
23:15:48 <jle`> also consider fromMaybe from Data.Maybe
23:15:57 <jle`> which is fromMaybe d = maybe d id
23:16:07 <jle`> > fromMaybe 0 (Just 10)
23:16:08 <lambdabot>  10
23:16:12 <jle`> > fromMaybe 0 Nothing
23:16:13 <lambdabot>  0
23:16:25 <iduhetonas> jle`: Good to know. I've been using the Maybe data type for a year, but I had no idea about these helper functions
23:17:11 <jle`> iduhetonas: :) those are the more useful ones besides the applicative and monad and functor interfaces of course.
23:17:34 <jle`> also handy is its foldable and traversable instances
23:17:34 <iduhetonas> jle`++
23:17:38 <jle`> which let you treat Maybe's as a list with 0 or 1 elements
23:17:41 <jle`> i use forM_ all the time
23:17:42 <mzero> b.t.w.: There is some logic to maybe being in the Prelude, whereas fromMaybe isn't.  It may seem that fromMaybe is the more useful (I certainly thought so when I first came to Haskell)... but actually, maybe is generally what you want!
23:18:01 <jle`> or mapM_
23:18:06 <jle`> or sequence
23:18:12 <mzero> or >>= for that matter!
23:18:23 <iduhetonas> I do really like mapM_ and forM_. Big day when I discovered those
23:18:53 <jle`> yeah, Data.Foldable/Data.Traversable are great
23:19:07 <jle`> it won't be long before the Foldable/Traversable mapM and forM's are in Prelude
23:19:10 <jle`> instead of the list ones
23:19:15 <gamegoblin> Best way to do from [IO String] to IO [String] ?
23:19:17 <gamegoblin> go from*
23:19:22 <jle`> gamegoblin: sequence?
23:19:24 <jle`> :t sequence
23:19:25 <lambdabot> Monad m => [m a] -> m [a]
23:19:32 <jle`> @src sequence
23:19:33 <lambdabot> sequence []     = return []
23:19:33 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
23:19:33 <lambdabot> -- OR: sequence = foldr (liftM2 (:)) (return [])
23:19:34 <gamegoblin> will that concat my strings?
23:19:40 <jle`> gamegoblin: no, it'll leave them as a list
23:19:45 <jle`> see the type
23:19:48 <gamegoblin> Gotcha
23:20:00 <gamegoblin> I have a list of IO Strings and want to concat them all into 1 IO String
23:20:08 <gamegoblin> is there a base function for that or should I roll my own?
23:20:29 <jle`> fmap concat . sequence
23:20:31 <jle`> but
23:21:02 <jle`> hm
23:21:09 <jle`> that's probably the simplest way that i know.
23:21:13 <gamegoblin> looks good to me
23:21:31 <mzero> it would be common to incorporate the concat into the next expression that is going to use that result
23:21:41 <mzero> so that one didn't need to fmap it
23:21:46 <gamegoblin> gotcha
23:21:50 <jle`> ^^
23:22:04 <jle`> by the way preflex is gone
23:22:07 <jle`> i wonder what happend to it
23:23:38 <geekosaur> there were some netsplits earlier
23:24:09 <geekosaur> several bots in various channels I'm in seem to have been confused or disconnected by it
23:24:24 <gamegoblin> not sure if any of you guys are Miyazaki fans but I just saw the new film The Wind Rises. Highly recommend.
23:24:50 <mzero> I am, and we plan to see it soon
23:24:54 <mzero> so, yay!
23:25:28 <gamegoblin> It was just as great as the other great Miyazakis
23:25:50 <pavonia> geekosaur: When "earlier"? It's already gone for several days or even weeks
23:26:21 <Javran> :t fmap . fmap . fmap
23:26:22 <lambdabot> (Functor f, Functor f1, Functor f2) => (a -> b) -> f (f1 (f2 a)) -> f (f1 (f2 b))
23:26:27 <geekosaur> sorry, I don't track bots that finely
23:26:42 <Javran> :t (fmap . fmap . fmap) _ (,,)
23:26:43 <lambdabot> Pattern syntax in expression context: _
23:26:57 <Javran> :t (fmap . fmap . fmap) undefined (,,)
23:26:58 <lambdabot> a -> b1 -> c -> b
23:27:08 <gamegoblin> What the hell javran :P
23:27:41 <Javran> gamegoblin: reading that "semantic editor combinators"
23:28:01 <gamegoblin> Man this guy in this channel named "nowis" keeps PMing me webcam spam
23:28:37 <mzero> guy is a 'bot
23:28:52 <gamegoblin> I figured
23:28:55 <mzero> I got it too, I just closed the message
23:29:03 --- mode: ChanServ set +o geekosaur
23:29:06 <gamegoblin> I've gotten it 4 times now
23:29:10 --- mode: geekosaur set +b *!*ircap@90.174.1.*
23:29:10 --- kick: nowis was kicked by geekosaur (nowis)
23:29:22 --- mode: geekosaur set -o geekosaur
23:29:45 <jle`> i can't imagine this actually working on people who are technically aware enough to be on freenode
23:29:46 <geekosaur> not that thats likely to help for anyone it's already noticed :/
23:30:09 <geekosaur> thing is, it's free; even a tiny fraction of a percent of responders makes it worth it
23:31:16 <jle`> tiny fraction has to be bigger than 1/# of people on freenode
23:31:30 <jle`> which is a small but finite fraction
23:31:33 <hellwolf> mirpa: I still can't make the function work.
23:31:37 <jle`> nonzero?
23:31:38 <hellwolf> I got a shorter verison of the question: http://pastebin.com/zQCqy8bL
23:32:08 <hellwolf> How can I cast from A1 to ClassA?
23:33:18 <geekosaur> "cast" is not a thing and typeclasses are not types
23:33:55 <mzero> hellwolf: that function can't possibly be needed!
23:34:11 <mzero> if you have an A1, then you already have something which is   ClassA x => x
23:34:20 <mirpa> hellwolf: you are trying to say that any instance of ClassA could be converted to any other instance of ClassA
23:34:27 <gamegoblin> hellwolf: If you are coming from a OOP world, think of typeclasses like java interfaces
23:34:48 <jle`> i think you can coerce typeclasses in java?
23:34:55 <gamegoblin> You can
23:35:00 <gamegoblin> It's a loose analogy
23:35:35 <gamegoblin> typeclasses are both stricter and more powerful
23:35:40 <mirpa> hellwolf: what are you trying to do?
23:36:06 <mzero> or to put in another way, if you have an A1, then you do not have a value that "good for" any type x where ClassA x => x
23:36:19 <hellwolf> that's where I come from and trying to achieve, a longer version why I think it's needed: http://pastebin.com/XixCsPFR . I'd like to have a function gg that only relies on ClassA's f function
23:37:14 <hellwolf> ClassB has a toClassA function, and ClassA has a f function, gg uses toClassA then use f to get the value
23:37:14 <mirpa> hellwolf: then gg :: (ClassA a) => a -> Int
23:38:04 <mzero> hellwolf - toA1, for any ClassB x => x value gives you an A1, to which you can apply f
23:38:20 <mzero> In other words, if you simply uncomment out gg it should work
23:38:36 <mzero> oh oh
23:38:37 <mzero> I see
23:38:40 <geekosaur> if ClassB is to be able to use ClassA then you do not want to cast, you want: class ClassA a => ClassB a where ...
23:38:41 <mzero>  you want toClassA!
23:39:03 <geekosaur> and now you know that if the type is a member of ClassB, it is also a member of ClassA
23:39:04 <mzero> ah, here
23:39:15 <mzero> look at line 12 - that is probably your problem
23:39:51 <hellwolf> mirpa: I could, but the point is to make gg "out of box" available for all instance of B who have toClassA function
23:40:05 <mzero> that says: "to be an type of ClassB, there must be a function, toClassA, that takes values of your type, and converts them to ANY TYPE of ClassA that is needed"
23:40:20 <geekosaur> you cannot "cast" a ClassB to a ClassA; aside from the fact that casting is not a thing, you would need to tell it that ClassB requires an instance of ClassA
23:40:36 <mzero> You almost certainly cannot write that function for, say, type B
23:41:32 <geekosaur> conversely, if you use `class ClassA b => ClassB b where ...` then no "casting" is needed since you have said that a ClassA instance must exist for a ClassB instance to be made
23:41:37 <mzero> because I can come along any time, and add a new type, Q, make it an instance of ClassA, and your implementation of toClassA for B better well convert to my type Q if I want it
23:43:30 <mzero> I suspect what you are thinking is this: For any particular type that is of ClassB, there is an appropriate type that is of ClassA, and toClassA will pick that one.
23:44:01 <mzero> But really, you can't do that without something beyond intro Haskell... (you need fundeps or type families... but please, let's not go there)
23:44:54 <mzero> Because, really, this isn't generally the "functional" way to decompose a problem, and there are much more natural ways to do this than to mimic the object oriented ways in Haskell
23:46:14 <mirpa> It would be better to see actual problem which you are trying to solve with this.
23:46:54 <geekosaur> they just pinged out
23:47:04 <mzero> I think we scared them!
23:47:13 <mirpa> ah...
23:47:46 <jle`> we need a better neutral pronoun
23:52:37 <gamegoblin> Shakespeare used they/them
23:52:41 <gamegoblin> as a singular pronoun
23:52:56 <mzero> well, that is accepted English usage
23:53:22 <gamegoblin> I am fine with they/them as neutral singular
23:53:28 <gamegoblin> I was a better plural second person
23:53:31 <gamegoblin> "you guys" "y'all"
23:53:33 <gamegoblin> bleh
23:53:38 <gamegoblin> I want*
23:53:53 <mzero> http://en.wikipedia.org/wiki/Spivak_pronoun
23:54:13 <mzero> http://en.wikipedia.org/wiki/Gender-specific_and_gender-neutral_pronouns#Alternatives_to_generic_he
23:54:39 <gamegoblin> Meh, I'll just keep speaking mandarin
23:54:43 <gamegoblin> he/she/it == "ta"
23:54:51 <gamegoblin> they have different characters, but pronounced the same
23:55:36 * hackagebot ddc-base 0.4.1.1 - Disciplined Disciple Compiler common utilities.  http://hackage.haskell.org/package/ddc-base-0.4.1.1 (BenLippmeier)
23:55:38 * hackagebot ddc-core 0.4.1.1 - Disciplined Disciple Compiler core language and type checker.  http://hackage.haskell.org/package/ddc-core-0.4.1.1 (BenLippmeier)
23:55:40 * hackagebot ddc-core-simpl 0.4.1.1 - Disciplined Disciple Compiler code transformations.  http://hackage.haskell.org/package/ddc-core-simpl-0.4.1.1 (BenLippmeier)
23:55:42 * hackagebot ddc-core-eval 0.4.1.1 - Disciplined Disciple Compiler semantic evaluator for the core language.  http://hackage.haskell.org/package/ddc-core-eval-0.4.1.1 (BenLippmeier)
23:55:45 * hackagebot ddc-core-salt 0.4.1.1 - Disciplined Disciple Compiler C code generator.  http://hackage.haskell.org/package/ddc-core-salt-0.4.1.1 (BenLippmeier)
23:55:56 <zomg> gamegoblin: good example why chinese is p crazy :p
23:56:44 <gamegoblin> zomg: nah it's just super simple
23:56:55 <andkore> How does show 1 work? The only thing we know about 1 is that its type is in the Num typeclass. But show is defined for actual types.
23:57:03 <milfjord> andkore: defaulting
23:57:16 <zomg> gamegoblin: wait, are you saying chinese is... super simple? :P
23:57:35 <andkore> milfjord: OK, I will search defaulting. Thanks.
