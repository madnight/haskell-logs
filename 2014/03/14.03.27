00:08:30 * hackagebot cryptohash 0.11.3 - collection of crypto hashes, fast, pure and practical  http://hackage.haskell.org/package/cryptohash-0.11.3 (VincentHanquez)
00:08:30 * hackagebot cryptohash 0.11.4 - collection of crypto hashes, fast, pure and practical  http://hackage.haskell.org/package/cryptohash-0.11.4 (VincentHanquez)
00:24:46 <hunt> whats your favorite thing about haskell
00:28:27 * hackagebot equational-reasoning 0.0.4.0 - Proof assistant for Haskell using DataKinds & PolyKinds  http://hackage.haskell.org/package/equational-reasoning-0.0.4.0 (HiromiIshii)
00:29:31 <Nyyx> hunt: having code work the way you expect it
00:30:07 <ion> The syntax, the type system, type inference, first-class IO, …
00:31:35 <athan> first-class?
00:31:57 <athan> Are you talking about adga or something?
00:32:25 <ion> You can put ten ‘print "hello"’s into a list and work on them as with any other value and then choose to have zero or more of them executed.
00:33:05 <_ikke_> So basically a sort of command pattern?
00:33:06 <athan> side note, though - why does the wikipedia def_n of ADT's call them "variant types"? I thought all values of any data type in haskell were invariant...
00:33:28 <jle`> _ikke_: yeah, that all IO in haskell is first-class
00:33:30 <athan> Is it because of the accessor morphism that make the data type appear to transform, from the record getting functions?
00:33:34 <dmj`> hunt: type safety, concurrency, ghci (repls are a huge productivity boot)
00:33:37 <dmj`> boost
00:33:51 <jle`> there are no such things as rogue IO, all IO commands are actual values you can manipulate
00:33:56 <jle`> just like normal variables
00:34:05 <ion> That also means the type of a value will indicate it does IO.
00:34:06 * jle` sighs with satisfaction
00:34:19 <athan> also, categories
00:34:27 <athan> beautiful coding construct right there
00:34:46 <jle`>  
00:36:14 <athan> so wikipedia refers to "variants" as constructors / discrete possabilities for a data type
00:36:22 <jle`> athan: variant types are tagged "tagged unions"
00:36:34 <athan> while invariance means memory spaces that don't change their value over time
00:36:36 <jle`> basically, i can have either an Int, or a String
00:36:42 <jle`> and i know what i have
00:36:50 <athan> hmm
00:36:57 <jle`> data IntOrString = ItsAnInt Int | NoWaitItsAString String
00:37:14 <jle`> you can decide to treat an IntOrString differently
00:37:20 <athan> AH'
00:37:21 <hunt> can someone explainto me why foldl is so much worse than foldr or at least ;oint me towards an explanation
00:37:22 <athan> WOW
00:37:25 <athan> holy shitcakes
00:37:26 <athan> the type
00:37:27 <jle`> depending on whether it is 'tagged' with an ItsAnInt or an NoWaitItsAString
00:37:29 <athan> the underlying type
00:37:30 <athan> changes
00:37:31 <athan> wtf
00:37:40 <jle`> note that in java
00:37:50 <athan> holy crap
00:37:54 <jle`> every non-primitive is implicitly an union type
00:38:18 <jle`> MyClass is an IsNotNull MyClass | Null
00:38:34 <athan> jle`: I'm gonna bill you for my therapy sessions from how much you've blown my mind
00:38:35 <MP2E> hunt : http://www.haskell.org/haskellwiki/Foldr_Foldl_Foldl%27
00:38:49 <jle`> this is referred to as 'the billion dollar mistake'
00:38:52 <ion> hunt: foldl' and foldr are both very useful for different purposes. foldl is usually bad, though.
00:38:54 <jle`> by some famous somebody someperson
00:39:02 <athan> ?
00:39:08 <athan> why such a mistake?
00:39:09 <athan> beacuse it
00:39:14 <athan> stack overflows?
00:39:20 <athan> infinite access?
00:39:22 <jle`> how every type is an implicit union between the type and null
00:39:25 <jle`> so you have to do null checking
00:39:28 <jle`> every time you want to use anything
00:39:30 <athan> unless you pattern match via IsAString _?
00:39:34 <jle`> in Java
00:39:59 <jle`> in Haskell, every union is explicit
00:40:05 <jle`> Maybe Int = Just Int | Nothing
00:40:17 <jle`> in Java, every non-primitive is an implicit union
00:40:19 <athan> oh oh oh okay
00:40:21 <athan> sorry lost me there
00:40:36 <jle`> have you used Java or C?
00:40:40 <athan> I've subliminally trained myself to literally not consider ideas when the term Java is parsed
00:40:45 <athan> C lol
00:40:52 <MP2E> hahaha
00:40:59 <jle`> Java is statically typed...so if you get a... MyObject
00:41:11 <athan> I'm joking man I can keep up haha
00:41:11 <jle`> it's actually always a Maybe MyObject
00:41:14 <athan> I did a lot of C++
00:41:17 <jle`> but the maybe is implicit
00:41:27 <jle`> C++ handles this slightly better but it's still troublesome
00:41:27 <athan> because it's dynamically typed, right?
00:41:36 <athan> it has to handle the occourance of it not happening
00:41:38 <jle`> no, it's staically typed
00:41:42 <athan> erm
00:41:43 <hunt> jle` thats a really nice way of explaining all of that
00:41:43 <jle`> but you have null pointers
00:41:52 <jle`> in C++/C
00:41:56 <jle`> and null in Java
00:42:37 <athan> hmmm
00:42:41 <jle`> because the data MyObject = MyObject | Null is 'implicit', you basically do a fromJust every time you access it
00:42:54 <athan> I see
00:42:59 <athan> the thing that gets me
00:43:01 <athan> though
00:43:08 <jle`> um. yeah that's what type unions are.
00:43:11 <jle`> they're also called products.
00:43:27 <jle`> er
00:43:28 <jle`> sums
00:43:29 <athan> is that the type matching is now variant under the runtime value accessed
00:43:30 <jle`> sorry
00:43:33 <hunt> with foldr f x list
00:43:39 <hunt> is x used at the right end
00:43:41 <hunt> or the left end
00:43:57 <jle`> hunt: you can check :)
00:44:00 <jle`> @src foldr
00:44:00 <lambdabot> foldr f z []     = z
00:44:00 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
00:44:14 <hunt> which would indicate its used at the left end
00:44:15 <hunt> oh wait
00:44:16 <hunt> nevermin
00:44:17 <hunt> d
00:44:23 <jle`> unroll some of it by hand
00:44:30 <jle`> and the answer will be apparent.
00:44:31 <hunt> i was thinking x:xs started with x as the last element
00:44:32 <jle`> equational reasoning, man
00:44:39 <hunt> because foldr was right and magical or something
00:44:48 <athan> i was just gonna say... lol
00:44:51 <athan> so the type matching
00:44:54 <athan> from the compiler
00:45:04 <athan> happens on the left of the `=`, correct?
00:45:23 <jle`> for Java? or Haskell? or idk
00:45:32 <athan> while runtime data ("extras", I call them) are plugged in without worry?
00:45:36 <athan> haskell
00:45:37 <athan> sorry
00:45:48 <jle`> pattern matching is done at runtime, yeah
00:45:50 <athan> on the right
00:45:51 <jle`> if that's what you're asking
00:45:55 <athan> yep!
00:46:00 <athan> so thats done at run time
00:46:06 <jle`> yeah..but
00:46:13 <jle`> it's basically like an implicit 'if then else' kinda thing
00:46:14 <athan> and in the presense of an ADT that has an extra value
00:46:17 <athan> a tagged value
00:46:39 <athan> has the runtime wrapper and type matching too
00:46:48 <athan> yeah I'd imagine
00:46:55 <athan> extra effort
00:47:01 <jle`> at the low level think of it as a box with some kind of tag indicating the type, and you can fork and do things based on what the box is tagged with
00:47:05 <athan> but my claim, or intuition at least
00:47:29 <athan> is that a type that's matched on the left doesn't have to do the runtime type matching on the right
00:47:42 <athan> yes!!
00:48:08 <jle`> well, you can 'unwrap' a different type, based on what the constructor holds
00:48:13 <athan> i mean... unless haskell can actually figure all that out ahead of time... ha
00:48:15 <athan> it probably can
00:48:24 <jle`> but this is all handled in a tpyesafe way
00:48:29 <athan> via pattern matching, right?
00:48:33 <jle`> if you use the ItsAnInt constructor
00:48:35 <jle`> the value that you get out
00:48:35 <athan> yowza
00:48:36 <jle`> is an Int
00:48:45 <jle`> and it'll be trated like an Int for typechecking
00:48:48 <athan> and that's known at compile time
00:48:54 <athan> so any calls to the function must match
00:48:56 <athan> dayum
00:49:20 <athan> because all calls to the data type are known in advance
00:49:45 <athan> ... unless... lax runtime-loaded callbacks... that aren't compiled O.o
00:49:58 <jle`> take a moment to familiarize yourself with type inference
00:50:01 <jle`> a day or so
00:50:06 <jle`> and it'll sort of make more sense
00:50:14 <athan> you mean like type holes?
00:50:26 <jle`> no, like how haskell deduces what values are what types
00:50:39 <athan> I'm just still having trouble believing that it can all be deduced and matched ahead of time lol
00:50:45 <jle`> my point exactly :)
00:50:54 <jle`> there are a couple of good lectures/articles on this subject
00:51:01 <athan> oh I believe it
00:51:03 <jle`> but...it's a pretty good thing to have understood
00:51:07 <athan> i need to read the type theory books
00:51:12 <jle`> no, you don't :)
00:51:12 <athan> yeah
00:51:22 <jle`> you don't have to learn too much about type theory
00:51:28 <athan> technically I don't need to live
00:51:30 <athan> :P
00:51:37 <jle`> i did not qualify
00:51:44 <jle`> you don't have to learn too much about type theory to understand type inference
00:51:53 <jle`> it's actually pretty straightforward
00:51:54 <athan> hmm
00:51:58 <jle`> and you will wonder why you didn't think of it yourself
00:52:02 <athan> im just trying to apply that to a categorical sense, too
00:52:09 <athan> right hahaha
00:52:43 <jle`> for some practice, just write a random function
00:52:47 <jle`> maybe even with some pattern matches
00:52:51 <jle`> and try to deduce the types by hand
00:53:26 <jle`> you'll find that for most cases, deducing all types (to the most general case) is completely decidable and unambiguous
00:53:30 * hackagebot equational-reasoning 0.0.4.1 - Proof assistant for Haskell using DataKinds & PolyKinds  http://hackage.haskell.org/package/equational-reasoning-0.0.4.1 (HiromiIshii)
00:54:04 <athan> hmm yeah I've done that before
00:54:13 <athan> I just get kinda lost when I see tildas lol
00:54:34 <jle`> if you see ~(something), you can just imagine it is_
00:54:37 <jle`> *it is _
00:54:41 <athan> so let me verify my terminology real quick just to make sure:
00:54:56 <jle`> actually wait, ~(Just x) has type information but yeah.
00:55:04 <athan> data Foo = Bar | Baz Int | Boff String String
00:55:17 <athan> each [] | [] | [] is a variant
00:55:33 <_ikke_> It's a value of the type
00:55:35 <athan> while (Baz Int), and (Boff String) are products?
00:56:15 <jle`> here is a good article series i reocmmend
00:56:16 <athan> oh woah
00:56:19 <jle`> to clearify this up
00:56:20 <jle`> http://chris-taylor.github.io/blog/2013/02/10/the-algebra-of-algebraic-data-types/
00:56:22 <athan> the value of the type?
00:56:47 <athan> Awesome! Thank you!!
00:56:59 <jle`> a product is a tuple
00:57:15 <jle`> so Foo = () + Int + String * String
00:57:24 <athan> Hey jle`, I hope you don't mind me asking, but what do you do for a living?
00:57:27 <athan> hmm
00:57:33 <jle`> um i'm a grad student
00:57:46 <athan> ahh damn
00:57:50 <jle`> or well, not yet
00:57:54 <jle`> i'm finishing up undergrad now
00:58:02 <athan> good work man
00:58:02 <jle`> so i am a normal person, for now
00:58:08 <athan> keep it up
00:58:08 <athan> hahaha
00:58:11 <athan> no such thing
00:58:11 <hunt> i still dont understandwhat makesfoldr better than foldl\
00:58:22 <athan> encapsulation
00:58:29 <jle`> hunt: foldr and foldl/foldl' are different beasts altogether
00:58:31 <athan> and the work required to undo it
00:58:31 * hackagebot smtps-gmail 1.1.0 - Gmail SMTP Client  http://hackage.haskell.org/package/smtps-gmail-1.1.0 (EnzoHaussecker)
00:58:32 <johnw> foldr, when used with functions that are non-strict in their second argument, allows for lazily production of values
00:58:33 <jle`> not better/worse
00:58:38 <hunt> is it because foldl has to go through an initial phase of laying out operators
00:58:51 <hunt> jle` but i read that foldr is much faster than f oldl
00:58:58 <hunt> jle` and i dont understand why
00:59:06 <johnw> when dealing with functions that are strict in both arguments, there is little difference between them, and foldl' should be used
00:59:28 <hunt> johnw ok thats cool
00:59:41 <johnw> the *other* difference is that they associate differently
00:59:43 <athan> hunt: It has to do with your computation requirements: do you expect to work with infinite data, or not?
00:59:55 <johnw> a + (b + (c + d)), vs ((a + b) + c) + d
01:00:06 <johnw> and that can matter for non-associative operators
01:00:15 <spacekitteh> how can i turn a concatMap to a mapAccum?
01:00:17 <hunt> johnw sure hence the r vs the w
01:00:18 <jle`> hunt: try writing a function that says if any of the items in a list are True, and short-circuiting as soon as it finds the first True
01:00:24 <hunt> by w i mean l
01:00:28 <johnw> :)
01:00:33 <hunt> its 4 am here
01:00:38 <johnw> 3am here
01:00:52 <athan> does this make sense:
01:00:54 <jle`> foldl/foldl' can't short-circuit
01:00:57 <athan> data Foo Int = Foo Int
01:01:12 <athan> 2 am yo's
01:01:22 <hunt> jle` with folds? or my own function
01:01:32 <jle`> hunt: try both
01:01:46 <jle`> write your own function and see which fold matches what you write the most
01:01:55 <jle`> but also see why it's impossible with foldl/foldl'
01:01:58 <johnw> athan: that does not make sense
01:02:05 <pyon> athan: "data Foo Int" <-- that Int looks misplaced
01:02:08 <johnw> data Foo a = Foo Int does
01:02:12 <jle`> foldr being faster than foldl is sort of an irrelevant issue
01:02:12 <johnw> or data Foo = Foo Int
01:02:40 <jle`> also, if you want to see why foldl is bad...read that article that was posted
01:02:45 <athan> johnw: THANK YOU!!! Is that because left of the =, it's purpose is type labeling and creation of type arity through ONLY type variables?
01:02:49 <hunt> jle` let findTrue (x:xs) | x == True = True |otherwise = findTrue xs; findTrue [] = False
01:03:15 <johnw> athan: yes, left of = needs type variables, not concrete types
01:03:21 <johnw> in the same way that a function wants parameter names
01:03:32 <jle`> hunt: note that f x | x == True = something is just f True = something
01:03:40 <athan> however the first term is your concrete type's name too
01:03:44 <athan> so you couldn't do something like
01:03:48 <jle`> and alos | x == True is just | x
01:03:50 <johnw> yeah, but that's not actually a type yet :)
01:03:56 <jle`> why do we have booleans again?
01:04:00 <athan> data Foo List a = ...
01:04:02 <jle`> maybe we should just get rid of them
01:04:02 <athan> either
01:04:05 <johnw> jle`: so that we can forget what True meant
01:04:20 <jle`> undefined <$ Just 6
01:04:22 <jle`> problem solved :)
01:04:52 <athan> hahahaha
01:04:59 <hunt> jle` im not sure how to do it with foldr
01:06:05 <jle`> hunt: consider what your result type is, and that's the type of your accumulator.  then consider what the binary operator must be.  then consider what the base case is.
01:06:39 <hunt> let acc True _ = True; acc _ x = x in foldr acc False list?
01:07:14 <jle`> hm.
01:07:22 <jle`> your acc function
01:07:24 <jle`> has a more familiar name
01:07:33 <hunt> id
01:07:35 <hunt> no
01:07:36 <hunt> wait
01:07:40 <hunt> or
01:07:42 <hunt> !!
01:07:55 <jle`> yeah
01:08:05 <jle`> @src or
01:08:05 <lambdabot> or    =  foldr (||) False
01:08:26 <Mie9> hi
01:08:28 <hunt> or [True,False,False]
01:08:32 <hunt> >or [True,False,False]
01:08:35 <hunt> > or [True,False,False]
01:08:36 <lambdabot>  True
01:08:43 <jle`> try evaluating it on something like [False,True,False,False,False], and see why it returns immediately after the first True
01:08:57 <hunt> how could i tell when it returns though
01:09:00 <jle`> be a person that actually takes advantage of equational reasoning :)
01:09:02 <Mie9> how do you thing that monad "We built a custom monad that lets us “switch off” side effects in our tests" from http://engineering.imvu.com/2014/03/24/what-its-like-to-use-haskell/ could look like?
01:09:08 <Mie9> think*
01:09:24 <johnw> Mie9: Free monads
01:09:24 <jle`> remember that haskell evaluation is for the most part evaluation by substitution
01:09:27 <jle`> @src foldr
01:09:28 <lambdabot> foldr f z []     = z
01:09:28 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
01:09:37 <jle`> every time you see foldr x y z, replace it with the definition of foldr
01:09:54 <jle`> get a nice pencil and paper
01:09:58 <johnw> A free monad effectively builds a list of effects, which you can then execute, observe or ignore
01:10:17 <Mie9> johnw: interesting
01:10:22 <jle`> Mie9: http://www.haskellforall.com/2012/07/purify-code-using-free-monads.html
01:10:23 <hunt> jle` ok yea i think i understand why it shortcircuits
01:10:33 <jle`> hunt: now try foldl (||) False
01:10:35 <Mie9> thanks!
01:10:36 <jle`> and see why it doesn't
01:11:07 <jle`> > foldr (||) False (repeat True)
01:11:08 <lambdabot>  True
01:11:18 <jle`> > foldl (||) False (repeat True)
01:11:21 <lambdabot>  mueval-core: Time limit exceeded
01:11:23 <hunt> @src foldl
01:11:23 <lambdabot> foldl f z []     = z
01:11:23 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
01:11:25 <jle`> > foldl' (||) False (repeat True)
01:11:30 <lambdabot>  mueval: ExitFailure 1
01:11:30 <lambdabot>  mueval: Prelude.undefined
01:11:41 <jle`> why did i get an undefined error >.>
01:11:54 <hunt> @src foldl'
01:11:54 <lambdabot> foldl' f a []     = a
01:11:54 <lambdabot> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
01:12:04 <no-n> @hoogle Show a => a -> Text
01:12:04 <lambdabot> Data.Text.Lazy unfoldr :: (a -> Maybe (Char, a)) -> a -> Text
01:12:05 <lambdabot> Data.Text unfoldr :: (a -> Maybe (Char, a)) -> a -> Text
01:12:05 <lambdabot> Debug.Trace traceShow :: Show a => a -> b -> b
01:12:17 <no-n> wut
01:12:35 <no-n> i guess i would have to use pack.show?
01:12:35 <johnw> no-n: classy-prelude has a 'tshow' function
01:12:37 <no-n> no wait
01:12:40 <johnw> yeah, pack.show
01:12:44 <no-n> :t pack
01:12:45 <lambdabot>     Not in scope: `pack'
01:12:45 <lambdabot>     Perhaps you meant one of these:
01:12:45 <lambdabot>       `BS.pack' (imported from Data.ByteString),
01:13:04 <johnw> just define tshow = pack.show, where pack is from Data.Text
01:13:13 <jle`> hunt: did you read that article from earlier?  it sort of explains the difference between foldl' and foldl pretty well.
01:13:15 <no-n> but pack takes [Word8]
01:13:36 <hunt> jle` yea i did, and i think i fully graspe it now
01:13:47 <johnw> ByteString pack does
01:13:50 <hunt> jle` it all comes down to foldr calling the function on its recursion
01:13:51 <johnw> not Text pack
01:14:11 <jle`> basically when you foldl, and you do something like foldl (+) 0 [1,2,3], it actually builds up a to-be-evaluated thunk, 1+2+3+0
01:14:14 <jle`> er
01:14:21 <jle`> did i put the 0 in the wrong place
01:14:30 <hunt> jle` lol yes
01:14:32 <jle`> anyways, a thunk is a data structure
01:14:41 <jle`> so it carries along a data structure the entire way
01:14:51 <hunt> jle` the special haskell to be evaluated structure
01:14:55 <jle`> it's not a free or cheap data structure when you foldl over a hundred thousand items
01:15:07 <jle`> it's a pretty gnarly tree
01:15:11 <johnw> plus, a thunk can reference data, preventing it from being GC'd
01:15:20 <johnw> so even one thunk can be expensive
01:15:30 <jle`> ^^
01:15:37 <hunt> jle` whats confusing is that i was introduced to foldr as though it actually started at the right end and worked its way back but its not doing that at all
01:15:38 <jle`> foldl' says 'don't build a thunk, evaluate it as it goes along
01:15:47 <jle`> so instead of storing a 1+2 thunk, it stores the actual value 3
01:15:51 <johnw> like, x || (length <some gigantic ByteString>)
01:22:38 <bartavelle> with "type Churchlist t u = (t->u->u)->u->u", I can write "isNull :: Churchlist t Bool -> Bool", but I can't seem to be able to write "isNull :: Churchlist t u -> Bool". Is that right ?
01:25:53 <pavonia> bartavelle: How would you write the first version?
01:26:04 <bartavelle> isNull l = l (\_ _ -> False) True
01:26:07 <lyxia> bartavelle: That's right, because the variables are quantified outside like "forall t, u. Churchlist t u -> Bool" And that would mean your function works on things like Church String String
01:26:30 <lyxia> which very likely isn't what you want
01:26:34 <bartavelle> so I should use another encoding of lists, right ?
01:27:12 <Cale> Perhaps you wanted forall t. (forall u. Churchlist t u) -> Bool
01:27:25 <bartavelle> Cale, I am not sure I see how it helps me
01:27:40 <lyxia> Why is "Chrchlist t Bool -> Bool" unsatisfactory ?
01:27:55 <bartavelle> lyxia, because I can't use isNull in arbitrary church list computation
01:28:49 <Cale> bartavelle: sure you can -- all your actual Church lists will be polymorphic in their 'u' parameter
01:28:59 <bartavelle> ohhh
01:33:43 <bartavelle> Cale, this works perfectly, thanks for the hint
01:34:19 <bartavelle> (also if someone knows why church encoding my algebraic type would help with performance, I am all ears)
01:38:36 * hackagebot equational-reasoning 0.1.0.0 - Proof assistant for Haskell using DataKinds & PolyKinds  http://hackage.haskell.org/package/equational-reasoning-0.1.0.0 (HiromiIshii)
01:45:29 <no-n> hmm. no get* functions for Text -- would the thing to do be to get as a ByteString and then convert?
01:46:17 <no-n> oh woops
01:46:29 <no-n> Data.Text.Lazy.IO.getContents/getLine
01:46:41 <tero-> what is the recommended way to organize functions in a Haskell module? should I introduce the public functions first and the rest would follow? or should I ensure that there are no forward-references?
01:47:14 <johnw> you can put them in any order
01:47:22 <johnw> whatever reads most naturally, I'd say
01:49:03 <kadoban> tero-: I like to put the interesting/important/public things first, then the utility stuff.  Keeps from having to scroll past a bunch of gunk to get to the things I probably care about.
01:50:18 <jle`> hm.
01:50:22 <tero-> okay, until now I have not been very consistent about this
01:50:35 <jle`> so i think it's impossible to use Arrows to compose parallel computation
01:51:18 <jle`> in a way that merges (a,b) -> (c,d), (c,d) -> (e,f) into one big (a,b) -> (e,f)
01:51:22 <tero-> kadoban: I think I'll adopt this style. it makes sense
01:51:24 <jle`> "fusing" together the threads
01:51:35 <jle`> or well
01:51:37 <jle`> it's possible
01:51:43 <jle`> but you can't have any pure functions in that chain
01:52:14 <jle`> that operate on the tuple as a hole
01:52:30 <jle`> so you'll have to break up the fusion
01:52:48 <jle`> but because of the way proc/do notation is de-sugared
01:53:05 <jle`> it throws in random pure functions just to implement things like (&&&) and (***)
01:53:10 <jle`> in the middle of everything
01:53:17 <jle`> so all proc/do stuff would be unfusable :/
01:53:20 <jle`> i'm sad.
01:54:19 <jle`> i was hoping to be able to compose parallel computations using proc/do notation
01:54:46 <jle`> they compose and fuse perfectly if you always use (&&&), (***), first, second, and arr
01:54:54 <jle`> and even id, (.)
01:55:32 <jle`> but proc/do notation doesn't use (&&&), (***), second...it uses \(x,y) -> (y,x) and first to implement second, (***), *and* (&&&)
01:55:48 <jle`> why can't it be smart enough to just use (***), (&&&), and second :'(
01:58:37 * hackagebot monomorphic 0.0.3.1 - Library to convert polymorphic datatypes to/from its monomorphic represetation  http://hackage.haskell.org/package/monomorphic-0.0.3.1 (HiromiIshii)
02:08:17 <quicksilver> jle`: the laws say it shouldn't matter ;)
02:08:52 <quicksilver> maybe with some well-chosen rules you can convert back?
02:10:16 <bezirg> hi, question: I use {-# OPTIONS_GHC -threaded #-} and the compiler complains with:  unknown flag in  {-# OPTIONS_GHC #-} pragma: -threaded
02:10:31 <bezirg> on ghc-7.6.3
02:12:59 <athan> is Either a tagged union, but of 2 types (that are known only at compile time)?
02:13:15 <quicksilver> bezirg: -threaded isn't a compiler option
02:13:24 <quicksilver> bezirg: it's a linker option, effectively - a whole program option
02:13:32 <quicksilver> it doesn't affect the compilation of individual modules.
02:13:48 <quicksilver> athan: Either is a tagged union, yes.
02:14:55 <johnw> Either is also called a "sum type", because algebraically stated it is "a + b"
02:15:04 <athan> quicksilver: Here's my concept of haskell at the moment: You compose functions ahead of time, compile it all, then you have a running program that can evaluate...?
02:15:37 <bezirg> quicksilver: thx
02:16:30 <quicksilver> athan: maybe. It depends what you think 'compose', 'compile' and 'evaluate' mean, so I'm not quite sure about your point.
02:16:42 <quicksilver> but it might be a reasonable intuition.
02:16:43 <jle`> quicksilver: yeah, the laws say it shouldn't matter, but i do not have a lawful instance.  it's impossible because you can say, have a pure function that swaps the two values of a tuple
02:17:06 <quicksilver> jle the outlaw.
02:17:11 <jle`> and i'm using first, second, (***), etc. to represent parallel computation
02:17:20 <jle`> so...swapping two values in a tuple
02:17:23 <jle`> makes no sense
02:17:24 <athan> quicksilver: Type check -> ??? -> functions composed together, ready to take input (or the whole expression evaluates to a value)
02:17:50 <jle`> athan: functions or values, too.
02:18:00 <jle`> and you have a compiled program you can execute
02:18:00 <athan> which would lead me to believe the IO monad reduces to a value (a state in time/space) as a running machine
02:18:02 <athan> hmm
02:18:03 <athan> wait
02:18:09 <athan> so the "running" of the machine
02:18:17 <jle`> athan: you can think of an IO object as a little packet of C code, perhaps
02:18:17 <Walther> Is there something akin to a haskell ncurses module?
02:18:19 <athan> is really just reducing an expression (automatically)?
02:18:32 <jle`> so putStrLn "hello" is a little packet of C code that puts "hlelo"
02:18:41 <jle`> putStrLn "world" is a little packet of C code that puts "world"
02:18:49 <jle`> and putStrLn "hello" >> putStrLn "world"
02:18:55 <jle`> what (>>) does it it takes two little packets
02:19:04 <jle`> and it 'efficiently' merges them into one big packet
02:19:06 <jle`> that does both
02:19:18 <jle`> you might be able to think of it like a code generation/macro system
02:19:20 <athan> i know all that stuff
02:19:22 <athan> thanks
02:19:28 <athan> hmm
02:19:35 <athan> see that's what I mean
02:19:39 <jle`> yeah, so your IO action is created
02:19:41 <jle`> it's evaluated
02:19:44 <pordan30> athan: if you want a slightly more detailed overview, you might consider skimming this link: <http://www.aosabook.org/en/ghc.html> it covers the ghc compiler
02:19:45 <jle`> and *then* it's executed
02:19:45 <athan> :t putStrLn
02:19:46 <lambdabot> String -> IO ()
02:19:51 <athan> :k IO
02:19:51 <lambdabot> * -> *
02:19:59 <mr-> Walther: sure: http://hackage.haskell.org/package/ncurses
02:20:03 <Walther> :t print
02:20:04 <quicksilver> Walther: hscurse, ncurses, nanocurse, vty
02:20:04 <lambdabot> Show a => a -> IO ()
02:20:20 <jle`> first your IO compositions (>>, etc.) are evaluated --- the (>>) and the (>>=) are evaluated in normal haskell functions, to create new IO ()'s
02:20:20 <mr-> Walther: what exactly are you trying to do?
02:20:25 <quicksilver> Walther: see the answer here: http://stackoverflow.com/a/6924858
02:20:34 <jle`> and then that newly created IO () is executed.
02:20:45 <athan> I know IO has like a... Time / Senses / Universe record or something
02:21:01 <jle`> it's like how when you say show (1+2)...1 is first added to 2 (evaluation), then it is turned into a string ("executed", in loose analogy)
02:21:16 <Walther> mr-: wondering if it'd be easy to create a cli ui for something in a sane way
02:21:19 <jle`> athan: well, an IO () can represent a time-sensitive, universe-sensitive computation
02:21:27 <jle`> anything can represet anything
02:21:35 <jle`> i can say that data Foo = Bar represents an ice cream cone
02:21:54 <jle`> it's up to the compiler to turn the pure representation into machine code
02:22:35 <athan> ahhh nice
02:22:41 <jle`> IO () itself is not time/universe-sensitive
02:22:43 <athan> why isn't concurrency natively an IO Arrow?
02:22:54 <johnw> what do you mean?
02:22:58 <athan> not concurrency
02:23:05 <athan> strict parallelism
02:23:14 <athan> like
02:23:19 <athan> hmm
02:23:23 <athan> actually, nvm
02:23:26 <athan> er...
02:23:27 <jle`> heh
02:23:41 <athan> it's only one state of being...
02:23:41 <athan> hmm
02:24:01 <athan> can you have an arrow inside the monad, to represent parallel execution at any instance of time
02:24:15 <johnw> what is an "arrow inside the monad"?
02:24:17 <athan> or would you have to have multiple io monad threads per arrow superset?
02:24:29 <athan> IO ( Arrow () )
02:24:32 <athan> er
02:24:41 <jle`> :k Arrow
02:24:42 <lambdabot> (* -> * -> *) -> Constraint
02:24:53 <jle`> it's a typeclass
02:25:15 <athan> IO ( (a,b) )
02:25:23 <athan> you know what I mean
02:25:28 <johnw> no, I really do not
02:25:29 <athan> like for instance a gpu
02:25:41 <athan> could be represented by having an arrow of thousands of cores
02:26:11 <athan> "inside" a descrete watchdog stateful sequence (the monad)
02:26:29 <jle`> would you be able to explain this in types?
02:26:40 <athan> not yet lol
02:26:46 <mr-> Walther: if a repl is enough, haskeline is my first choice
02:26:50 <athan> Arrow a => IO a
02:26:55 <jle`> it really doesn't seem to make too much sense, sorry
02:26:56 <athan> vs
02:27:04 <jle`> Arrow takes two types
02:27:08 <athan> Arrow a => a ( IO () )
02:27:22 <athan> yeah you're totally right
02:27:25 <jle`> you can't have an Arrow a
02:27:30 <athan> an arrow is a continuation of sorts
02:27:32 <jle`> er wait
02:27:34 <jle`> you can
02:27:41 <jle`> but you can't have it as a (IO ())
02:27:43 <athan> but...
02:27:50 <jle`> and you definitely can't have IO a
02:28:02 <athan> the type inside the monad should actually be that of the returned type
02:28:32 <athan> is it parametric?
02:28:37 <athan> the arrow typeclass
02:28:45 <athan> like a monad has a 2-ary kind?
02:28:50 <jle`> :k Arrow
02:28:51 <lambdabot> (* -> * -> *) -> Constraint
02:28:51 <athan> like how*
02:28:52 <jle`> :k Monad
02:28:53 <lambdabot> (* -> *) -> Constraint
02:28:56 <athan> ahhhhhh
02:29:05 <athan> it's starting to make sense now hahaha
02:29:29 <athan> are the two inputs for starting type and ending type
02:29:42 <jle`> roughly
02:29:45 <athan> so a morphism between A and B would just be like
02:30:40 <athan> data Errow a b = Errow a b deriving (Arrow)
02:30:48 <athan> and you'd have a value somewhere
02:30:52 <athan> of Errow A B
02:30:58 <athan> ?
02:31:00 <jle`> of type Errow a b
02:31:15 <jle`> and yeah, value Errow A B
02:31:17 <jle`> but
02:31:26 <jle`> i'm not sure you could make a lawful arrow instance out of that
02:32:01 <jle`> out of that data type
02:32:07 <athan> because there's no functor between 'a' and 'b'?
02:32:13 <jle`> how would you implement arr?
02:32:15 <jle`> :t arr
02:32:16 <lambdabot> Arrow a => (b -> c) -> a b c
02:32:17 <athan> that can be mapped upon?
02:32:24 <jle`> (a -> b) -> Err a b
02:32:32 <jle`> (a -> b) -> Errow a b
02:32:42 <athan> ahhhhhh
02:32:48 <athan> :t arr id
02:32:49 <lambdabot> Arrow a => a c c
02:33:07 <jle`> but this is probably besides the point
02:33:38 <jle`> for Arrow r, a `r` b roughly represents a mapping from a to b.  and you have to be able to lift a function to that mapping, among other things.
02:33:39 <athan> the arr combinator lifts the function into a correctly functioning arrow
02:33:42 <athan> hmm
02:33:50 <jle`> a good example is Kleisli
02:33:56 <jle`> Kleisli is not an arrow
02:33:59 <jle`> Kleisli m is an arrow
02:34:06 <athan> ahhhh
02:34:10 <athan> very interesting
02:34:16 <jle`> (Kleisli IO) Int String is a newtype wrapper around Int -> IO String
02:34:19 <athan> that lifts a monad into an arrow?
02:34:33 <jle`> it...gives a free Arrow instance for every monad
02:34:44 <athan> sexy
02:34:48 <jle`> it's just a newtype wrapper
02:34:52 <jle`> so we can define instances on it
02:34:57 <athan> ahhh
02:35:05 <jle`> it's because we can't actually instance (a -> m b) as an Arrow
02:35:13 <jle`> so we have to wrap it in a newtype wrapper
02:35:26 <athan> ahh!
02:35:29 <athan> awesome!!
02:35:30 <jle`> similar to why we have the State newtype wrapper, which is just a dumb wrapper around s -> (a, s)
02:35:36 <jle`> it's kinda annoying actually :/
02:35:50 <athan> i believe it
02:35:56 <athan> gets in the way of the underlying logic
02:36:06 <athan> and dependancies
02:36:31 <athan> so
02:36:36 <jle`> it just obscures the actual type :/
02:36:51 <jle`> and confuses people
02:37:50 <athan> ( Kleisli IO ) *** ( Kleisli IO )?
02:38:06 <athan> er
02:38:14 <jle`> the compiler sees State s a as identical to s -> (a, s) (forgetting about StateT-implemented states)
02:38:20 <jle`> identical for the most part
02:38:37 <jle`> athan: (***) is a value-level function
02:38:52 <jle`> but Kleisli IO is not even a type...it's a type constructor awiating two types
02:39:01 <athan> yeah lol
02:39:09 <athan> just kinda b.s.ing with the actual functionality
02:39:25 <athan> I'm just trying to understand the goal behind the constructs, and their uses
02:39:38 <jle`> but you can have f *** g, where f and g are both Kleisli m a b's
02:39:48 <jle`> :t (***)
02:39:48 <lambdabot> Arrow a => a b c -> a b' c' -> a (b, b') (c, c')
02:39:56 <jle`> so if you unwrap the newtype wrappers
02:39:59 <jle`> this looks like
02:40:08 <athan> Kleisli IO () ()'s?
02:40:25 <jle`> (a -> m b) -> (c -> m d) -> ((a,c) -> m (b,d))
02:40:37 <athan> ahhhhh
02:40:51 <jle`> it takes two (a -> m b)'s and turns them into an ((a,c) -> m (b,d))
02:41:05 <jle`> this is actually nothing magical
02:41:09 <athan> yeah
02:41:12 <jle`> you can write it yourself
02:41:12 <athan> no i can tell
02:41:14 <athan> just tuples
02:41:20 <jle`> yeah
02:41:40 <no-n> is this an okay way to empty an entire TChan into a list? http://lpaste.net/2063110299665301504
02:41:49 <athan> good stuff good stuff
02:41:53 <jle`> it's actaully supposed to be equivalent to second g . first f
02:42:11 <jle`> which is supposed to be equal to arr swap . first g . arr swap . first f
02:42:17 <jle`> swap (x,y) = (y,x)
02:42:35 <athan> hmm
02:42:43 <jle`> it's a part of the arrow laws i think
02:42:59 <jle`> so really to implement all the arrow functions, you only have to implement arr and first
02:43:02 <athan> :t first
02:43:03 <lambdabot> Arrow a => a b c -> a (b, d) (c, d)
02:43:13 <athan> ahhh
02:43:14 <athan> derp
02:43:18 <athan> it creates a new one
02:43:37 <jle`> can you write out first for Kleisli m, unwrapping the newtypes?
02:43:43 <jle`> the type of first
02:44:04 <quicksilver> no-n: there is already a function which does that.
02:44:07 <quicksilver> erm...
02:44:34 <athan> Monad m => (a -> b) -> a -> m b
02:44:34 <athan> ?
02:45:14 <quicksilver> no-n: apologies, the function I was thinking of was for plain Chan, not TChan, I misremembered.
02:45:18 <jle`> hm
02:45:19 <athan> erm
02:45:23 <ion> no-n: You can also write “do { x <- readTChan chan; xs <- makeList chan; return (x:xs) }” as “(:) <$> readTChan chan <*> makeList chan” or “liftA2 (readTChan chan) (makeList chan)”. But what you wrote is fine, too.
02:45:29 <jle`> it's a little annoying because of using 'a' for Arrow
02:45:50 <ion> no-n: Uh. liftA2 (:) (readTChan chan) (makeList chan)
02:46:01 <no-n> ahh
02:46:08 <athan> I don't want the instance
02:46:15 <jle`> i like writing it as Arrow r => a `r` b -> (a, d) `r` (b, d)
02:46:15 <athan> if that's what you're asking :P
02:46:18 <athan> I agree though haha
02:46:26 <athan> ahh nice
02:46:27 <athan> okay
02:46:43 <jle`> some people use ~>
02:46:46 <jle`> (~>)
02:46:49 <jle`> even though it's not valid syntax
02:46:50 <athan> Monad m => a -> m b
02:46:55 <athan> I've seen <~ from elm
02:47:00 <athan> for applicative
02:47:07 <jle`> Arrow (~>) => (a ~> b) -> ((a,d) ~> (b,d))
02:47:11 <no-n> ion: doesn't using liftA2 like that lack an edge condition?
02:47:25 <athan> a -> ~> b?
02:47:28 <jle`> (~>) would be a type-level function, here
02:47:33 <athan> ahh
02:47:36 <jle`> it's the same as saying (+) 1 2
02:47:38 <jle`> is 1 + 2
02:47:47 <jle`> ignore it if it confuses you :)
02:47:57 <ion> no-n: It does the same thing as the do block i wrote.
02:47:58 <athan> it's all good
02:48:02 <athan> i get it
02:48:06 <athan> i know type families
02:48:09 <athan> but that's different
02:48:35 <jle`> do what i did for (***)
02:48:39 <jle`> but for first
02:48:46 <quicksilver> jle`: ~> isn't a type-level function there. It's just an infix type variable.
02:48:51 <athan> I keep saying it lol
02:49:00 <jle`> quicksilver: ah you're right, sorry
02:49:09 <no-n> ion: oh, I see.
02:49:12 <athan> er wait
02:49:17 <athan> no, I'm good
02:49:18 <quicksilver> it's a higher-kinded type variable and arguably they are functions in a sense ;)
02:49:19 <jle`> quicksilver: thanks
02:49:26 <quicksilver> but no more or less than the 'm' in "return :: m a"
02:49:31 <no-n> the edge condition is still outside it
02:49:38 <athan> Monad m => (a -> b) -> a -> m b
02:49:48 <jle`> athan: that's `arr` :)
02:49:48 <athan> or would it be
02:50:07 <athan> Monad m => (a -> b) -> m a -> m b
02:50:19 <quicksilver> and type variables are constrained to match structurally, so they always actually match type *constructors*
02:50:20 <jle`> keep your parentheses
02:50:22 <athan> oh sheit
02:50:25 <quicksilver> not arbitrary type functions.
02:51:07 <athan> wait hold on
02:51:22 <athan> so kleisli m creates something similar to arr?
02:51:37 <jle`> quicksilver: ah :/  i always like thinking of type constructure sas type functions, but i guess i should remember they aren't arbitrary functions
02:51:38 <athan> or something similar to what arr creates after 1 input?
02:52:02 <jle`> athan: Kleisli m a b at the type level is a newtype wrapper around (a -> m b)
02:52:27 <athan> so the definition would be
02:52:29 <jle`> Kleisli m at the data level is not directly related to arr
02:52:57 <jle`> you already wrote the type of arr, though
02:53:13 <jle`> (a -> b) -> (a -> m b)
02:53:41 <athan> type Kleisli m a b = (a -> b) -> (a -> m b)
02:53:50 <athan> @src Kleisli
02:53:50 <lambdabot> Source not found. Have you considered trying to match wits with a rutabaga?
02:53:58 <jle`> newtype Kleisli m a b = Kleisli (a -> m b)
02:54:01 <athan> hahahahaha
02:54:04 <jle`> sort of...literally what i wrote
02:54:18 <jle`> actually in the real definition, there is a record accessor for convenience
02:54:20 <merijn> jle`: Well, it has a runKleisli getter, but yeah :p
02:54:24 <merijn> Curses
02:54:25 <merijn> To slow
02:54:41 <jle`> newtype Kleisli m a b = Kleisli { runKleisli :: a -> m b }
02:54:55 <jle`> merijn: :P
02:55:13 <athan> hmm
02:55:18 <jle`> i always felt like runX/getX record getters were kind of hacks
02:55:20 <athan> so newtypes only act on the type level?
02:55:28 <athan> garunteed to not add runtime complexity?
02:55:37 <jle`> yes, for the most part
02:55:41 <jle`> or well
02:55:44 <jle`> they are on the data level too
02:55:50 <jle`> but they are compiled to the same thing as what they wrap
02:55:52 <jle`> for the most part
02:56:00 <athan> ahh
02:56:04 <jle`> there are some slight semantic issues/edge cases for usage, but...
02:56:05 <athan> they just get an extra key?
02:56:23 <jle`> well, when you first use them, they are for type safety
02:56:39 <jle`> say i have two types of strings, GoodString and BadString
02:56:45 <jle`> and i want a functio that only takes GoodStrings and BadStrings
02:56:53 <jle`> er, one that only takes good strings and one that only takes bad strings
02:56:57 <jle`> if i did a type alias
02:57:00 <jle`> type GoodString = String
02:57:06 <jle`> it's only mostly a lexical alias
02:57:14 <jle`> so i can still use a GoodString in my bad-string-only function
02:57:19 <athan> (mostly) lol
02:57:28 <athan> ahhh!
02:57:28 <jle`> newtype GoodString = GoodString String, however
02:57:32 <jle`> works the "same way"
02:57:33 <athan> oh wow
02:57:35 <jle`> at the compiled level
02:57:54 <athan> but is type safe
02:57:56 <jle`> but now GHC/the typechecker will not allow you to use a GoodString on a function that takes BadStrings
02:58:09 <jle`> it's mostly for your own convenience...give a type extra flags to help yourself
02:58:10 <athan> and the language sees that as a discrete type object to restrict against
02:58:19 <jle`> yeah, but it's compiled to the same thing (more or less)
02:58:20 <athan> or use in the restriction of application + whatnot
02:58:32 <jle`> in our usage, we are using newtypes for something different
02:58:33 <tdammers> also, implementation hiding
02:58:48 <jle`> yeah, that too
02:59:23 <jle`> well, you could do the same with data, right?
02:59:34 <jle`> but except, yeah...it's compiled to the same thing
02:59:36 <jle`> as without the wrapper
02:59:56 <jle`> in our usage, we are using newtypes purely as things to define instances on
02:59:59 <jle`> for Kleisli
03:00:10 <jle`> we can't define an Arrow instance on (a -> m b)...
03:00:26 <jle`> but if we wrap an (a -> m b) in a Kleisli m a b newtype, then we can define an arrow instance on that.
03:00:35 <jle`> so newtypes are handy.
03:00:39 <athan> ahhh wow
03:00:44 <athan> I see
03:00:44 <jle`> but i think i already explained this
03:00:49 <jle`> i kind of ramble :|
03:01:07 <athan> no no no!
03:01:10 <athan> I finally got it actually!
03:01:17 <jle`> it's the same case for the State monad, if you've ever used it
03:01:35 <athan> so do you have to write the newtype?
03:01:41 <jle`> newtype State s a = State (s -> (a, s))
03:01:49 <athan> that's all
03:01:50 <athan> wow
03:01:53 <jle`> really, you want to define a Monad instance for s -> (a, s)
03:01:56 <jle`> but you can't do that
03:02:05 <jle`> so you wrap it around a newtype, and define a monad intance for that
03:02:15 <athan> ahh!!!
03:02:19 <athan> WOW
03:02:20 <athan> wait
03:02:30 <athan> holy-d up-christ
03:02:52 <merijn> The sound of enlightenment :p
03:02:56 <jle`> oh yeah another usage of newtypes is to define multiple instances for the same type
03:03:09 <athan> so you can't make monad instances for variable functions like that
03:03:16 <athan> they have to have a type-bound reference term
03:03:27 <athan> huh...
03:03:37 <jle`> athan: you know about Monoids right?
03:03:37 <merijn> athan: Are you familiar with the term kind?
03:03:53 <athan> yes!
03:04:06 <athan> =<<
03:04:07 <athan> lol
03:04:22 <athan> that was me applying both questions to the same answer
03:04:23 <jle`> we both asked yes/no questions at the same time :|
03:04:25 <athan> but anyway
03:04:26 <jle`> ah
03:04:26 <merijn> athan: The problem you have is that the Monad typeclass demands a type of kind "* -> *", however, "s -> (a, s)" has kind *
03:04:28 <jle`> heh
03:04:45 <athan> ahhhhh
03:04:53 <merijn> athan: So the problem you have to solve is "how to turn "s -> (a, s)" into something of kind * -> *
03:05:03 <athan> so technically, you don't need the "term"
03:05:14 <merijn> athan: By defining "newtype State s a = State (s -> (a, s))" we get "State :: * -> * -> *"
03:05:14 <athan> the -> patterns become the term, correct?
03:05:32 <athan> OH WAIt
03:05:35 <jle`> or State s :: * -> *
03:05:37 <merijn> Now we partially apply State and get "State s :: * -> *", exactly what the Monad typeclass wants
03:05:42 <athan> wait I was thinking of this earlier
03:06:12 <athan> because (s -> (a, s)) isn't requiring a definition...?
03:06:45 <jle`> (my point about multiple instances was a bit of a tangent; Bools famously have two monoid instance --- under (||) with False as the identity, and (&&) with True as the identity.  so we can wrap Bool in a newtype and define separate monoid instances for both newtypes)
03:06:49 <jle`> :k s -> (a, s)
03:06:50 <lambdabot> Not in scope: type variable `s'
03:06:50 <lambdabot> Not in scope: type variable `a'
03:06:50 <lambdabot> Not in scope: type variable `s'
03:06:52 <jle`> darn
03:07:18 <jle`> *we can wrap Bool in two different newtypes
03:07:25 <merijn> athan: Well, suppose haskell had type level lambda's (let's use \s ~> s" as lambda syntax for types) then we could write "instance Monad (\a ~> (s -> (a, s))) where"
03:07:40 <merijn> athan: But haskell doesn't have type level lambda's, so we use newtype to "fake it"
03:08:00 <athan> jle` so it's the combination of the operator and the data type
03:08:04 <athan> for that example
03:08:31 <athan> AH
03:08:36 <athan> that's what I was wondering
03:08:39 <athan> perfect sense now
03:08:43 <athan> well, sorta haha
03:08:49 <athan> something I saw strange
03:09:04 <athan> was how in a data declaration
03:09:06 <athan> a simple ll
03:09:17 <athan> data List a = Nil | Cons a (List a)
03:09:23 <athan> there's two a's in there
03:09:28 <athan> one representing the value
03:09:44 <athan> and one representing the datatype associated with the kind function * -> *
03:10:04 <athan> they hold different meanings in my eyes
03:10:05 <merijn> athan: I can frequently help to write data types in GADT Syntax
03:10:12 <merijn> Your linked list would be:
03:10:15 <merijn> data List a where
03:10:20 <merijn>     Nil :: List a
03:10:20 <athan> ~.O
03:10:26 <jle`> yes merijn represents a GADT syntax data type consulting firm
03:10:28 <merijn>     Cons :: a -> List a -> List a
03:11:10 <athan> I love it
03:11:24 <athan> I need to master that
03:11:32 <athan> er really, just utilize it more often
03:11:42 <athan> and see how it can have the same functionality
03:11:54 <merijn> athan: GADTs can actually do more than normal data types
03:11:57 <athan> regardless, though, the type level lambdas cleared up a lot
03:11:59 <athan> thank you
03:12:06 <athan> oh i bet
03:12:13 <merijn> athan: You may want to read the GADT wikibook on that topic: https://en.wikibooks.org/wiki/Haskell/GADT
03:12:19 <athan> the pattern is like
03:12:28 <athan> kind-based or something
03:12:32 <athan> it's more comprehensive
03:12:43 <athan> adt's are a subset it seems
03:12:48 <merijn> athan: Well, yes
03:12:59 <merijn> athan: GADTs are *Generalised* ADTs :)
03:13:03 <athan> i really need to get profiling habbits in place :(
03:13:22 <athan> all my derp
03:13:32 <merijn> So ADTs are literally a subset of GADTs :)
03:13:49 <athan> that's beautiful
03:14:01 <athan> is there a monomorphism between GADT and ADT's?
03:14:14 <athan> so there's no performance penalty for using them when it's a perfect subset?
03:14:33 <merijn> athan: If your GADT is just an ADT they should compile the exact same way
03:14:41 <merijn> So there should never be a performance penalty
03:14:42 <makalu> http://hackage.haskell.org/package/parsec3-1.0.0.7/docs/Text-Parsec-Token.html under the documentation about 'lexeme', it says 'lexeme p first applies parser p and than the whiteSpace parser'. I think it should be 'then'.
03:14:46 <athan> EFFF YEAAAAA
03:14:49 <athan> that's too cool
03:14:59 <merijn> athan: FYI, if you wanna read more cool stuff
03:16:17 <jle`> athan: hm. anyways, given that (***) :: (a -> m b) -> (c -> m d) -> ((a,b) -> m (c,d)), can you figure out `first`?  it's perhaps probably no longer too much of interest, granted.
03:16:41 <athan> oh, yeah haha sorry
03:16:44 <jle`> also how did it become 3:15 :/
03:17:16 <jle`> i'll probably head off now, night to all.
03:17:19 <athan> first :: (a -> m b) -> (a -> m (b, c))
03:17:28 <athan> hahaha
03:17:28 <jle`> :t first
03:17:29 <lambdabot> Arrow a => a b c -> a (b, d) (c, d)
03:17:33 <athan> night man, it was a pleasure
03:17:34 <athan> ahhh
03:17:45 <athan> yeah my brain is on reserves
03:17:55 <merijn> athan: I recommend the paper "Fun with Type Functions" :)
03:18:17 <jle`> when you're ready, http://lpaste.net/101830 :)
03:18:24 <athan> merijn: Thank you! I'll check it out!
03:18:25 <merijn> athan: If you got this past discussion it should be fairly easy to read and explains how to write type level functions in GHC :)
03:18:58 <prinsen> GHC is acting wierd, If I add a newline to a file, everything works, if I remove it, it breaks. I suspect some kind of cabal cache
03:19:05 <athan> merijn: Will do! I've learned a little about type families, but not in a structured or principaled / integrated way
03:19:35 <merijn> athan: The paper is a fairly good intro, IMO. It has like three simple examples that are explained and shown
03:19:42 <athan> merijn: But I'm going to head off too, thank you again for your help. I hope to see you here agian soon!
03:19:52 <no-n> heh... is there printf for Text or does printf work on Text?
03:19:55 <athan> I'll read it first thing tomorrow :)
03:19:57 <merijn> Me? I'm never here >.>
03:20:01 <athan> I've been stocking up haha
03:20:08 <athan> one page full of tabs
03:20:16 <athan> I've got the day off tomorrow, so I'll just sponge it all
03:20:24 <athan> hahah
03:20:35 <athan> :t print
03:20:36 <lambdabot> Show a => a -> IO ()
03:21:01 <athan> print ( "foo" :: Text )
03:21:07 <athan> > print ( "foo" :: Text )
03:21:08 <lambdabot>  Not in scope: type constructor or class `Text'
03:21:12 <athan> > print ( "foo" :: Data.Text )
03:21:13 <lambdabot>  Not in scope: type constructor or class `Data.Text'
03:21:25 <jle`> athan: that'll include the quotes, i'm afraid
03:21:25 <athan> shit
03:21:35 <jle`> same as when you do print "hello"
03:21:41 <merijn> prtinf is not the same as print
03:22:06 <merijn> > printf "Woah: %d. This stuff is evil voodoo: %f!" 10 3.0 :: String
03:22:07 <lambdabot>  "Woah: 10. This stuff is evil voodoo: 3.0!"
03:22:14 <merijn> > printf "Woah: %d. This stuff is evil voodoo: %f!" 10 3.0 :: IO ()
03:22:15 <lambdabot>  <IO ()>
03:22:26 <athan> wooo
03:22:29 <athan> woah
03:22:35 <athan> are those horns?
03:23:23 <jle`> it just means that it's a value of type IO ()
03:23:34 <athan> ahh woah
03:23:39 <athan> that's weird stuff lol
03:23:42 <athan> I'm out though
03:23:48 * hackagebot http-client 0.2.2.4 - An HTTP client engine, intended as a base layer for more user-friendly packages.  http://hackage.haskell.org/package/http-client-0.2.2.4 (MichaelSnoyman)
03:23:48 <athan> my brains are ded
03:23:50 * hackagebot json-fu 0.1.1 - Generic JSON serialization / deserialization  http://hackage.haskell.org/package/json-fu-0.1.1 (SimonHengel)
03:28:27 <Peaker> I have a concurrent build system in Haskell, where threads represent build jobs and wait for one another using the async's library wait.  there is some slowness, and strace -c is claiming I am wasting 98% of my time inside futex (even though "user" and not "sys" time is the majority)
03:31:42 <Peaker> Ideally, an empty build should take as much as "git status" does.  "git status" takes 0.003s, and the build takes 0.196s :(
03:32:05 <Peaker> hmm.. actually it should be slightly longer, as the build looks at more files than are in the git repo
03:32:17 <Peaker> but it's currently longer because of all the thread synchronization overhead, apparently :(
03:33:40 <Peaker> profiling doesn't show anything regarding thread synchronization.. I suspect it doesn't profile that properly
03:33:49 * hackagebot equational-reasoning 0.2.0.0 - Proof assistant for Haskell using DataKinds & PolyKinds  http://hackage.haskell.org/package/equational-reasoning-0.2.0.0 (HiromiIshii)
03:36:35 <Nightson> hey everyone
03:37:14 <Nightson> i have this problem: i can do "happy file.y" but then, when I try do do "ghc file.hs", it gives me some errors
03:37:24 <Nightson> Main.hs:173:19: Not in scope: data constructor `Int'
03:37:24 <Nightson> Main.hs:180:19: Not in scope: data constructor `Var'
03:37:24 <Nightson> Main.hs:189:19: Not in scope: data constructor `Brack'
03:37:41 <Nightson> I believe the problem is in some part of this code, in Main.y
03:37:41 <Nightson> http://pastebin.com/KzXznzxj
03:37:54 <Nightson> does anyone have an idea of why it's happening?
03:41:35 <prinsen> I get this when reinstalling my library
03:41:41 <prinsen> http://lpaste.net/2780601229460373504
03:41:53 <prinsen> how do I resolve this?
03:48:51 * hackagebot cabal-test-quickcheck 0.1.1 - QuickCheck for Cabal  http://hackage.haskell.org/package/cabal-test-quickcheck-0.1.1 (TimothyJones)
03:49:05 <merijn> prinsen: Basically, two libraries you are using have conflicting dependencies
03:49:19 <prinsen> merijn: supposedly yesod-platforms aims to solve these issues
03:50:03 <merijn> prinsen: If you uninstalled something only partially and are updating now you can have some libraries installed using some old version, whereas the new stuff you're trying to install needs something newer
03:50:23 <prinsen> merijn: i did rm -rf .ghc .cabal
03:50:50 <merijn> prinsen: hmmm
03:51:06 <prinsen> merijn: I think yesod-platform will solve it
03:51:12 <prinsen> merijn: installing right now, takes alot of time
03:51:30 <merijn> yeah, I'm not really sure what to do then
03:51:34 <merijn> consider asking #yesod?
03:52:08 <prinsen> merijn: had some really strange behavior, thats why im cleaning. If i added a space to a file, it worked (Hint compiled correctly), but If I removed the space, It gave a runtime error
03:52:21 <prinsen> maybe some cache
03:56:17 <tdammers> we're having some dependency trouble with yesod as well
03:56:20 <tdammers> but it's the other way around
03:56:32 <tdammers> apparently, some dependency requirements are too lax
03:56:50 <tdammers> causing older versions of them to be picked, and then the compilation of yesod-core fails
03:56:53 <tdammers> vOv
03:58:53 * hackagebot equational-reasoning 0.2.0.1 - Proof assistant for Haskell using DataKinds & PolyKinds  http://hackage.haskell.org/package/equational-reasoning-0.2.0.1 (HiromiIshii)
03:59:17 <k00mi> is there a package that provides lifted versions of file IO functions?
03:59:36 <k00mi> specifically I need withFile, so it's not just a matter of prepending liftIO
04:02:06 <Peaker> well, the performance of a full serial build is just 30% slower than optimal, and the performance of a parallel build is much better than optimal serial. And an empty build is still quite fast enough, so I guess I can leave it for now
04:08:52 <tdammers> there's not really a point in optimizing an empty build anyway, is there?
04:18:55 * hackagebot equational-reasoning 0.2.0.2 - Proof assistant for Haskell using DataKinds & PolyKinds  http://hackage.haskell.org/package/equational-reasoning-0.2.0.2 (HiromiIshii)
04:18:57 * hackagebot type-natural 0.2.1.0 - Type-level natural and proofs of their properties.  http://hackage.haskell.org/package/type-natural-0.2.1.0 (HiromiIshii)
04:27:47 <ast_> newbie question: I
04:28:42 <ast_> i'm trying to use Cairo+gtk for drawing and got some mismatch types, possible due to import problems
04:29:12 <ast_> wonder if somebody can help, where can I paste the error messages?
04:29:27 <dv-_> @paste
04:29:27 <lambdabot> Haskell pastebin: http://lpaste.net/
04:29:38 <ast_> @paste
04:29:38 <lambdabot> Haskell pastebin: http://lpaste.net/
04:29:49 <dv-_> yes, there
04:31:12 <ast_> http://lpaste.net/101831
04:31:14 <ast_> here's the code
04:31:42 <ast_> http://lpaste.net/101832
04:31:48 <ast_> and the error i'm getting
04:35:04 <dv-_> try removing the signature of myDraw
04:36:54 <ast_> dv-_: same
04:39:27 <ast_> and works fine with renderWith if I try to write pdf
04:39:44 <no-n> I had the Text literal "¯\\_(ツ)_/¯" but my bot sent it as ¯\_(Ä)_/¯ to IRC
04:40:35 <no-n> how do I made it utf-8 before sending?
04:40:38 <no-n> make*
04:40:48 <ion> @hoogle encodeUtf8
04:40:48 <lambdabot> Data.Text.Lazy.Encoding encodeUtf8 :: Text -> ByteString
04:40:48 <lambdabot> Data.Text.Encoding encodeUtf8 :: Text -> ByteString
04:40:57 <no-n> thanks
04:42:17 <no-n> hmm, it turns it into a ByteString
04:42:22 <no-n> I guess that's what I should be using then.
04:42:35 <no-n> ByteString, I mean
04:43:58 * hackagebot tidal 0.3 - Pattern language for improvised music  http://hackage.haskell.org/package/tidal-0.3 (AlexMcLean)
04:45:09 <no-n> man, I'm confused
04:45:18 <no-n> I thought Text was what you wanted for UTF-8
04:45:25 <no-n> but this is turning it into a ByteString anyway
04:45:46 <k00mi> no-n: yes, because bytes are what you send to IRC
04:46:17 <no-n> right
04:46:19 <ion> String and Text are representations of text using an opaque encoding. ByteString is a representation of an array of bytes. If you want to convert text into an array of bytes, you need to encode it using an explicit encoding, such as UTF-8.
04:46:24 <merijn> no-n: Text is what you want for unicode
04:46:46 <k00mi> you should use Text as your internal reperesentation, but once you send it to IRC you have to convert it into something IRC understands
04:46:53 <no-n> so I want to be beginning with Text and THEN encoding it?
04:47:03 <no-n> rather than ByteString all the way?
04:47:22 <merijn> no-n: Well, that depends on what you want to do
04:47:55 <no-n> make a bot talk on IRC, basically
04:48:26 <quicksilver> then you want to store the text in Text (hence the name)
04:48:32 <quicksilver> and encode it to utf8 for output
04:48:49 <ion> "ä" :: ByteString is always wrong. The IsString instance for ByteString is a bit of a kluge. It picks an encoding that utterly breaks any code point greater than 0xff.
04:48:51 <quicksilver> (and on input, deduce the utf8 you get in into Text)
04:50:44 <no-n> so use a ByteString getSomething function then decode to Text?
04:52:28 <merijn> ion: My mantra is that ByteString IsString only exists for writing string literals for ascii network protocols
04:52:55 <quicksilver> my mantra is that IsString is a benighted pox upon this language and I shall pretend it doesn't exist.
04:53:07 <no-n> lol
04:53:10 <merijn> quicksilver: You must be so happy with OverloadedLists :>
04:53:25 <quicksilver> I haven't thought about them enough to get annoyed yet
04:53:35 <no-n> so I want to be sending AND receiving as ByteString?
04:53:39 <quicksilver> I'll try to prepare some choice metaphors for when I do.
04:53:43 <quicksilver> no-n: yes
04:53:50 <no-n> okay. Strict or Lazy?
04:54:09 <quicksilver> probably strict if you're dealing with predictably small chunks
04:54:13 <quicksilver> like lines in an IRC conversation
04:54:21 <merijn> no-n: That's an efficiency/optimisation issue, rather than correctness
04:54:27 <no-n> yeah
04:54:50 <no-n> a chunk is 64 bytes iirc
04:55:00 <no-n> i.e. smaller than most IRC messages
04:59:08 <no-n> @hoogle hGetLine
04:59:09 <lambdabot> System.IO hGetLine :: Handle -> IO String
04:59:09 <lambdabot> GHC.IO.Handle hGetLine :: Handle -> IO String
04:59:09 <lambdabot> Data.ByteString hGetLine :: Handle -> IO ByteString
04:59:48 <no-n> why is there no hGetLine for lazy bytestrings?
05:05:08 <yitz> no-n: if it existed, it would be in Data.ByteString.Lazy.Char8 but you're right it doesn't seem to exist.
05:05:34 <quchen> I think BS chunks are significantly larger than 64 bytes.
05:05:43 <no-n> might be 64k
05:05:58 <quchen> Ah, the "k" matters :-)
05:05:59 <yitz> by default. they can be any size.
05:06:02 <no-n> lol yeah
05:06:22 <no-n> i guess that would mean lazy makes no diff. for lines over irc
05:07:41 <yitz> no-n: it would make a difference if someone sends you a malicious stream
05:07:51 <kamatsu> annoying issue with haskell mode
05:08:11 <kamatsu> if i have no indentation minor mode on, every time i type a newline it pops up the help for haskell mode hooks
05:08:13 <kamatsu> very strange
05:08:23 <no-n> a malicious stream?
05:09:25 <kamatsu> has anyone else experienced this?
05:09:27 <yitz> no-n: the fact that the result of your calculation is to report a line that is much too long would be a moot point if your computer runs out of memory before it gets to that result.
05:11:15 <yitz> kamatsu: indentation is the main reason i use haskell-mode. i do recall something like that one of the times when i installed haskell-mode, and that made sense to me.
05:12:13 <kamatsu> yitz: I'm using structured-haskell-mode
05:12:28 <kamatsu> indentation script interferes with it
05:12:40 <kamatsu> so i have it off at the moment
05:18:01 <kamatsu> in particular, having haskell-indentation on seems to disable gliding in shm
05:24:03 * hackagebot sized-vector 1.4.0.0 - Size-parameterized vector types and functions.  http://hackage.haskell.org/package/sized-vector-1.4.0.0 (HiromiIshii)
05:24:05 * hackagebot egison 3.3.4 - Programming language with non-linear pattern-matching with backtracking  http://hackage.haskell.org/package/egison-3.3.4 (SatoshiEgi)
05:24:14 <kamatsu> Ah, switching to haskell-simple indentation worked i think
05:29:03 * hackagebot egison-tutorial 3.3.4 - A tutorial program for the programming language Egison  http://hackage.haskell.org/package/egison-tutorial-3.3.4 (SatoshiEgi)
05:39:11 <ghorn> does anyone have a working GHC head? I found this panic in rc2 http://lpaste.net/101835
06:14:08 * hackagebot csound-expression-dynamic 0.0.3 - dynamic core for csound-expression library  http://hackage.haskell.org/package/csound-expression-dynamic-0.0.3 (AntonKholomiov)
06:14:10 * hackagebot csound-expression-typed 0.0.3 - typed core for the library csound-expression  http://hackage.haskell.org/package/csound-expression-typed-0.0.3 (AntonKholomiov)
06:19:09 * hackagebot csound-expression 3.2.1 - library to make electronic music  http://hackage.haskell.org/package/csound-expression-3.2.1 (AntonKholomiov)
06:19:11 * hackagebot temporal-csound 0.3.0 - library to make electronic music, brings together temporal-music-notation and csound-expression packages  http://hackage.haskell.org/package/temporal-csound-0.3.0 (AntonKholomiov)
06:19:13 * hackagebot cabal-debian 4.3.1 - Create a debianization for a cabal package  http://hackage.haskell.org/package/cabal-debian-4.3.1 (DavidFox)
06:48:18 <veryrandomname> is it ok to have an infinite amount of type class instances? http://lpaste.net/101838
06:52:45 <geekosaur> veryrandomname, it can be, but the real question is what you're trying to accomplish with it (that is, is a typeclass actually appropriate)
06:57:25 <veryrandomname> i want to check if two things collide physically/ are on the the same spot on the world, for a rougelike
06:58:32 <veryrandomname> and most things should be able to collide with other things, so I thought a type class would be ok
06:58:55 <beaky> hello
06:59:00 <beaky> why is church encoding useful
06:59:08 <quicksilver> veryrandomname: the idea doesn't seem unreasonable
06:59:09 <beaky> when there is data
06:59:14 * hackagebot streaming-commons 0.1.0.1 - Common lower-level functions needed by various streaming data libraries  http://hackage.haskell.org/package/streaming-commons-0.1.0.1 (MichaelSnoyman)
06:59:16 * hackagebot conduit-extra 1.0.0 - Temporary placeholder package.  http://hackage.haskell.org/package/conduit-extra-1.0.0 (MichaelSnoyman)
06:59:18 <quicksilver> although I have a feeling it's not as useful as you hope.
06:59:24 <quicksilver> however there is one detail which definitely won't work
06:59:26 <quicksilver> instance (Collide a b) => Collide b a where
06:59:33 <quicksilver> ^^ that's just not how instance selection works.
07:00:55 <veryrandomname> what's wrong there? I guessed that "instance (Collide a b) => Collide b a where" would create an infinite amount of instances, wouldn't that be ok?
07:01:27 <quicksilver> it overlaps with every instance
07:01:39 <quicksilver> "Collide b a" matches every possible pair of types
07:01:51 <quicksilver> so it overlaps with (Int,Int) (Int,Int)
07:01:55 <quicksilver> and overlaps with [a] [b]
07:01:57 <quicksilver> ...and everything else.
07:02:44 <veryrandomname> right
07:02:50 <veryrandomname> but why is that a problem?
07:03:06 <quicksilver> well, from one perspective it's a problem because that's not legal haskell.
07:03:13 <quicksilver> haskell forbids overlapping instances.
07:03:37 <quicksilver> from a more operational perspective it's a problem because, the language doesn't specify which one it would try to use, given two overlapping ones.
07:03:58 <veryrandomname> does the overlappingInstances extension handle that?
07:04:06 <quicksilver> there is a GHC extension which permits OverlappingInstances but it's surprisingly rarely useful in practice
07:04:15 * hackagebot authenticate 1.3.2.8 - Authentication methods for Haskell web applications.  http://hackage.haskell.org/package/authenticate-1.3.2.8 (MichaelSnoyman)
07:04:17 * hackagebot streaming-commons 0.1.0.2 - Common lower-level functions needed by various streaming data libraries  http://hackage.haskell.org/package/streaming-commons-0.1.0.2 (MichaelSnoyman)
07:04:19 * hackagebot project-template 0.1.4.1 - Specify Haskell project templates and generate files  http://hackage.haskell.org/package/project-template-0.1.4.1 (MichaelSnoyman)
07:04:22 <quicksilver> because it doesn't solve fundamental problems with how instances are chosen.
07:05:06 <veryrandomname> but how would I express "if A can collide with B, then B can collide with A" then?
07:05:23 <quicksilver> unfortunately you can't easily.
07:05:34 <quicksilver> you just have to list instance (schemes) both ways around
07:05:56 <veryrandomname> that's sad
07:06:02 * quicksilver nods
07:06:26 <quicksilver> personally I'd write your code more directly for now and then see if a typeclass will actually help
07:06:37 <quicksilver> I can't see enough context from that paste if a typeclass is going to simplify things
07:07:00 <veryrandomname> I first wrote everything without typeclasses and it was very annoying
07:07:01 <quicksilver> mostly typeclasses help where you have code you which to write polymorphically, not knowing which instances are going to be chosen
07:09:03 <quicksilver> that doesn't prove that typeclasses are the way to make it less annoying ;)
07:09:07 <quicksilver> other abstractions exist.
07:09:15 * hackagebot monad-logger 0.3.4.1 - A class of monads which can log messages.  http://hackage.haskell.org/package/monad-logger-0.3.4.1 (MichaelSnoyman)
07:09:17 * hackagebot yaml 0.8.8.1 - Support for parsing and rendering YAML documents.  http://hackage.haskell.org/package/yaml-0.8.8.1 (MichaelSnoyman)
07:09:28 <quicksilver> in fact, typeclasses are barely an abstraction at all, and they're certainly not a general purpose one.
07:12:01 <veryrandomname> They would already help me, only used as syntactic sugar, I think
07:13:16 <quicksilver> the great thing about haskell is that there are very few repeated or boilerplate patterns that you can't abstract
07:13:31 <quicksilver> but more often than not, the solution lies in well-chosen data-types and higher order functions
07:13:35 <quicksilver> (rather than typeclasses)
07:13:47 <k00mi> veryrandomname: one method is to pass the collide function around manually
07:13:59 <k00mi> that is, make a collide function for every possibility of collision
07:14:49 <beaky> in what ways is programming in haskell different from programming in another functional language like lisp
07:14:54 <veryrandomname> without or with typeclasses?
07:15:22 <k00mi> without a typeclass
07:16:05 <k00mi> the only thing your typeclass would provide is instance resolution, but that already doesn't work the way you'd need it to
07:18:49 <k00mi> beaky: for one, lisps are usually dynamically typed
07:19:21 * hackagebot persistent 1.3.0.5 - Type-safe, multi-backend data serialization.  http://hackage.haskell.org/package/persistent-1.3.0.5 (MichaelSnoyman)
07:19:23 * hackagebot persistent-mongoDB 1.3.0.4 - Backend for the persistent library using mongoDB.  http://hackage.haskell.org/package/persistent-mongoDB-1.3.0.4 (MichaelSnoyman)
07:19:25 * hackagebot persistent-mysql 1.3.0.2 - Backend for the persistent library using MySQL database server.  http://hackage.haskell.org/package/persistent-mysql-1.3.0.2 (MichaelSnoyman)
07:19:26 <ArneL> beaky: Most lisps are not statically typed (there is typed racket and cord.typed for clojure, though). Haskell is also non-stricts as opposed to many (all?) lisps
07:19:27 * hackagebot persistent-postgresql 1.3.0.4 - Backend for the persistent library using postgresql.  http://hackage.haskell.org/package/persistent-postgresql-1.3.0.4 (MichaelSnoyman)
07:19:29 * hackagebot persistent-sqlite 1.3.0.4 - Backend for the persistent library using sqlite3.  http://hackage.haskell.org/package/persistent-sqlite-1.3.0.4 (MichaelSnoyman)
07:19:34 <beaky> wow
07:19:50 <k00mi> in fact, it is quite a stretch to call some lisps functional at all
07:19:56 <Iceland_jack> what k00mi said
07:20:06 <beaky> but i thought programing with higher order functions is common in ever lisp
07:20:09 <beaky> every*
07:20:27 <Iceland_jack> beaky: The term functional programming is notoriously badly defined
07:20:54 <skypers> gosh
07:21:09 <beaky> right I dont know what it even means: sometimes it means "programming with values", somethimes it means using first-class ad higher order functions and map-reduce, etc.
07:21:11 <skypers> I’m so sick of people that don’t understand why weakly typed languages suck
07:21:20 <beaky> btw why do they suck
07:21:31 <Iceland_jack> beaky:
07:21:38 <Iceland_jack> When does it mean programming with values?
07:22:07 <c_wraith|N10> Many lisps use macros in place of higher-order functions, too.
07:22:35 <ArneL> beaky: Haskell is a different kind of functional language, as it enforces a pure functional style via its type system. In mosts lisps you can just mutate some variable or do IO in a map function for example. Haskell very much would not allow that
07:23:32 <beaky> what about IORef and mapM
07:23:43 <beaky> those can do io in the IO monad
07:24:02 <nicoo> beaky: Yes, but mapM isn't map
07:24:25 <nicoo> If you are using mapM, the type tells you that you are (potentially) doing IO
07:24:31 * hackagebot persistent-template 1.3.1.3 - Type-safe, non-relational, multi-backend persistence.  http://hackage.haskell.org/package/persistent-template-1.3.1.3 (MichaelSnoyman)
07:24:33 * hackagebot pool-conduit 0.1.2.2 - Resource pool allocations via ResourceT.  http://hackage.haskell.org/package/pool-conduit-0.1.2.2 (MichaelSnoyman)
07:24:35 * hackagebot http-reverse-proxy 0.3.1.3 - Reverse proxy HTTP requests, either over raw sockets or with WAI  http://hackage.haskell.org/package/http-reverse-proxy-0.3.1.3 (MichaelSnoyman)
07:24:37 * hackagebot html-conduit 1.1.0.4 - Parse HTML documents using xml-conduit datatypes.  http://hackage.haskell.org/package/html-conduit-1.1.0.4 (MichaelSnoyman)
07:24:39 * hackagebot xml-conduit 1.2.0.1 - Pure-Haskell utilities for dealing with XML with the conduit package.  http://hackage.haskell.org/package/xml-conduit-1.2.0.1 (MichaelSnoyman)
07:24:53 <beaky> wow haskell is in active development :D
07:24:58 <skypers> :)
07:25:18 <skypers> 15:23 < nicoo> If you are using mapM, the type tells you that you are  (potentially) doing IO
07:25:21 <skypers> whaaaaaat?
07:25:24 <skypers> it doesn’t
07:25:54 <beaky> wont the context reveal that mapM can do IO
07:25:57 <tdammers> skypers: it tells you that you're in a monad
07:26:01 <skypers> yes
07:26:03 <beaky> oh
07:26:03 <skypers> and only that.
07:26:27 <tdammers> the first argument tells you which one\
07:26:31 <beaky> so mapM in the list monad only returns lists
07:26:37 <skypers> yes
07:26:41 <skypers> :t mapM
07:26:42 <lambdabot> Monad m => (a -> m b) -> [a] -> m [b]
07:26:46 <skypers> if m == IO
07:26:52 <tdammers> :t mapM print
07:26:52 <lambdabot> Show a => [a] -> IO [()]
07:26:53 <beaky> and in the reader monad does read action
07:26:54 <skypers> it’s indeed an I/O function
07:27:04 <nicoo> skypers: Yes. And if f is in the IO monad, you know it.
07:27:07 <skypers> :t mapM listToMaybe
07:27:07 <lambdabot> [[b]] -> Maybe [b]
07:27:11 <skypers> no IO here ;)
07:28:16 <nicoo> skypers: Of course. And it doesn't do IO. I feel like you read half of the words I typed.
07:28:17 <beaky> I love monads
07:28:57 <skypers> nicoo: no I read it all
07:29:14 <skypers> I just answered back to “using mapM means through IO”, which is incorrect
07:29:30 <skypers> the correct answer was given by tdammers
07:29:39 <skypers> I just thouth the same way
07:29:41 * hackagebot xml-hamlet 0.4.0.8 - Hamlet-style quasiquoter for XML content  http://hackage.haskell.org/package/xml-hamlet-0.4.0.8 (MichaelSnoyman)
07:31:52 <nicoo> skypers: And I didn't say that the only monad in which using mapM is IO. I said that if you are using mapM through IO, the type of its argument says so.
07:32:52 <skypers> yes yes nicoo
07:32:58 <skypers> sorry for the misunderstanding :)
07:33:08 <no-n> uhhh. i need ByteString.Lazy.getLine :/
07:33:28 <no-n> am I just supposed to use ByteString.Lazy.hGetContents and map over lines?
07:34:40 <merijn> no-n: Ideally you would not use lazy IO if you want deterministic resource usage
07:34:53 <merijn> no-n: So "it depends"
07:35:39 <merijn> no-n: If you don't care about resource leaks "hGetContents" + lines should work
07:35:53 <merijn> For more control over resource usage, look into either pipes, conduits or io-streams
07:35:55 <no-n> no-n: it would make a difference if someone sends you a malicious stream <-- was why I wanted lazy
07:36:24 <no-n> hmm
07:36:43 <no-n> merijn: well this is for a bot reading lines off IRC
07:36:47 <no-n> what would you recommend?
07:36:47 <merijn> maliciousness of the stream doesn't really matter here
07:36:57 <no-n> why not?
07:37:12 <merijn> no-n: Because even non-malicious streams cause the exact same problems :)
07:37:26 * no-n <- confused
07:38:15 <merijn> no-n: The problem with lazy IO is that the file descriptor cannot be closed until the data was garbage collected, additionally you may unintentionally keep all the data read from the socket/handle in memory unnecessarily long
07:38:35 <merijn> This depends on your code, not the input stream
07:39:02 <no-n> ok
07:39:10 <merijn> pipes and conduits try to provide abstraction for writing streaming applications that avoid these problems, at the cost of requiring you to learn some abstractions :)
07:39:21 <no-n> hehe
07:39:23 <merijn> no-n: However, for quick & dirty hacks that don't have to be very stable it should work
07:39:24 * hackagebot wai 2.1.0.1 - Web Application Interface.  http://hackage.haskell.org/package/wai-2.1.0.1 (MichaelSnoyman)
07:39:26 * hackagebot wai-eventsource 2.0.0.2 - WAI support for server-sent events  http://hackage.haskell.org/package/wai-eventsource-2.0.0.2 (MichaelSnoyman)
07:39:28 * hackagebot wai-extra 2.1.1.1 - Provides some basic WAI handlers and middleware.  http://hackage.haskell.org/package/wai-extra-2.1.1.1 (MichaelSnoyman)
07:39:30 * hackagebot wai-frontend-monadcgi 2.0.0.2 - Run CGI apps on WAI.  http://hackage.haskell.org/package/wai-frontend-monadcgi-2.0.0.2 (MichaelSnoyman)
07:39:32 * hackagebot wai-handler-launch 2.0.1.2 - Launch a web app in the default browser.  http://hackage.haskell.org/package/wai-handler-launch-2.0.1.2 (MichaelSnoyman)
07:39:34 <no-n> it what?
07:39:47 <merijn> no-n: Using lazy IO
07:39:50 <beaky> how do you begin to think about writing a haskel program
07:39:53 <merijn> no-n: (i.e. hGetContents)
07:39:59 <no-n> ok
07:40:04 <no-n> yeah, i don't want quick and dirty
07:40:04 <merijn> no-n: Worst case your bot will run out of memory/handles and crash :)
07:40:07 <beaky> I try to start with my types, but then I end up with complex data :(
07:40:45 <no-n> merijn: which would you recommend for a NON- quick and dirty approach? :)
07:44:16 <fragamus> hey edwardk how come when I use a V2 as a key to a hashmap i get _|_ on invoking insertWithKey
07:44:29 <fragamus> edwardk: I map them to pairs and everything is fine
07:44:34 * hackagebot wai-test 2.0.1.1 - Unit test framework (built on HUnit) for WAI applications.  http://hackage.haskell.org/package/wai-test-2.0.1.1 (MichaelSnoyman)
07:44:35 <edwardk> fragamus: did you pull the latest version?
07:44:36 * hackagebot wai-websockets 2.1.0.1 - Provide a bridge betweeen WAI and the websockets package.  http://hackage.haskell.org/package/wai-websockets-2.1.0.1 (MichaelSnoyman)
07:44:39 * hackagebot warp 2.1.3.1 - A fast, light-weight web server for WAI applications.  http://hackage.haskell.org/package/warp-2.1.3.1 (MichaelSnoyman)
07:44:40 * hackagebot warp-tls 2.0.3.2 - HTTP over SSL/TLS support for Warp via the TLS package  http://hackage.haskell.org/package/warp-tls-2.0.3.2 (MichaelSnoyman)
07:44:43 <fragamus> nope
07:44:44 <edwardk> there wasn't a Hashable instance before
07:44:54 <fragamus> far out dude
07:44:56 <edwardk> so i'm not sure how you were using it
07:45:05 <fragamus> thanks
07:45:14 <edwardk> i addd the Hashable instances after your comment the other day but you were offline
07:45:28 <quicksilver> edwardk: is there an evil hack to get reverse instances for free in a symettric two-parameter type class?
07:45:36 <fragamus> you are freaky responsive
07:45:40 <quicksilver> s/mett/mmet/;
07:46:54 <no-n> btw, where can i see the source for lambdabot?
07:47:05 <edwardk> quicksilver: not really. closest i have is breaking it apart like i did with Wrapped/Rewrapped in lens or including the backwards direction members in the main class itself, but that doesn't capture what you want. i tend not to define anthing MPTC that is truly symmetric, as instance selection for that is so brittle.
07:48:45 <quicksilver> edwardk: *nod*. I couldn't think of one. veryrandomname was looking for something but I suspect he'd be better off with something else anyway.
07:48:56 <edwardk> likewise =)
07:48:56 <quicksilver> which is the frustrating answer #haskell is famous for.
07:52:05 <veryrandomname> quicksilver: I made the Collide class work and its really annoying too, suprise! But I've got something nice now.  http://lpaste.net/101841
07:52:06 <geekosaur> go not to the #haskell for counsel, as they will say both no and yes
07:52:25 <geekosaur> s/as/for/
07:53:12 <quicksilver> veryrandomname: ok, that does look like a better approach
07:53:27 <quicksilver> "things which can be interpreted as lists of grid points" seems like a good typeclass.
07:53:32 <haasn> quicksilver: Edward Kmmet?
07:54:13 <quicksilver> haasn: I was just correcting my mispelling but the coincidence of consonants struck me also ;)
07:54:27 * hackagebot th-lift-instances 0.1 - Lift instances for template-hasell for common data types.  http://hackage.haskell.org/package/th-lift-instances-0.1 (BennoFuenfstueck)
07:55:06 <c_wraith|N10> @version
07:55:07 <lambdabot> lambdabot 5.0-int-e
07:55:07 <lambdabot> git clone git://github.com/int-e/lambdabot.git
07:55:25 <c_wraith|N10> no-n: there
07:55:29 <haasn> quicksilver: perhaps it was not a typo. we need a sykmettric type class
07:55:32 <haasn> or perhaps a cokmettric :)
07:55:36 <haasn> but lens is already full of those
07:55:45 <no-n> ty
07:59:27 * hackagebot warp 2.1.3.2 - A fast, light-weight web server for WAI applications.  http://hackage.haskell.org/package/warp-2.1.3.2 (MichaelSnoyman)
08:00:48 <beaky> what are lenses and why are they useful
08:01:13 <no-n> merijn: what about just using Data.ByteString.hGetLine?
08:10:59 <Nightson> hey guys, I have a Main.hi which I want to execute so when I type "2 + 3 * 5" it returns "Add(Num 2)(Mult (Num 3)(Num 5))"
08:11:12 <Nightson> however, after I type the expression, nothing happens
08:11:31 <Nightson> I think i have to input some symbol as an end of file, but I don't have an idea which one...
08:11:35 <Nightson> can someone help?
08:12:04 <haasn> Nightson: might be a buffering issue
08:12:19 <haasn> there's not much anybody can do to help you without pasting the code.
08:13:24 <Nightson> here it is, http://pastebin.com/RQjTWV4C
08:13:53 <Nightson> actually that is Main.y, but I believe the problem it's in there
08:15:04 <haasn> Nightson: have you tried closing the input stream, either by piping from a file or another program, or manually closing it with something like ^D?
08:15:13 <Nightson> yes i have
08:18:47 <Nightson> nevermind, I got it to work
08:18:51 <Nightson> thank you anyway
08:19:20 <haasn> what was the problem?
08:19:57 <Nightson> I did what you suggested
08:20:03 <Nightson> I tought I had tried it already
08:20:07 <Nightson> apparently not
08:20:09 <Nightson> thank you
08:20:10 <haasn> Ah okay
08:20:26 <Nightson> thought*
08:21:57 <haasn> Nightson: you could also try using something like getLine instead of getContents, which re..
08:21:59 <haasn> so much for that
08:22:21 <haasn> returns a finite string as soon as it's done reading, is what I was trying to say
08:23:49 <skypers> I love Kleisli composition <3
08:25:57 <kstt> Hi. Is anyone experienced with SQL and *sql-simple interfaces please ?
08:28:45 <kstt> My question is : In SQL, we need to decompose data in tables, and have relationships between tables. With *sql-simple interfaces, it is trivial to map a datatype to a table. From here, how should I proceed to read (and write) rich datatypes, that I manipulate in the application.
08:39:33 * hackagebot th-desugar 1.3.1 - Functions to desugar Template Haskell  http://hackage.haskell.org/package/th-desugar-1.3.1 (RichardEisenberg)
08:46:08 <sylvanica> I know this is a really simple question, but it has been bugging me. When I look at Haskell code, I see a bunch of functions, but I have NO CLUE where the code actually starts executing.
08:47:10 <dwcook> sylvanica, in a compiled Haskell program, there is a specific module that's the starting point, and whatever binding called 'main' it exports is the IO action that gets run.
08:47:10 <merijn> sylvanica: Every haskell program has "main :: IO ()" which is an IO action that gets executed
08:47:41 <merijn> sylvanica: It is somewhat comparable to, for example, the main function in C. Note, however, that main in haskell is not a function
08:48:25 <merijn> sylvanica: For example, c2hsc has: https://github.com/jwiegley/c2hsc/blob/master/Main.hs#L82-L83
08:48:38 <sylvanica> I feel like even having read through Do You A Haskell I have no clue what I'm doing, is this normal? Hehe.
08:49:14 <merijn> sylvanica: Yes, it's really only a sort of starting point, it can take a while to feel comfortable writing "real" code :)
08:49:37 <dwcook> sylvanica, out of curiosity, what project are you looking at?
08:49:41 <sylvanica> merijn: whew. I'm not sure where to start, sadly, I just have a headache
08:50:14 <sylvanica> dwcook: well, it's for a game I play (Kingdom of Loathing): kolproxy. https://github.com/houeland/kolproxy
08:50:34 <merijn> sylvanica: I think it took me 3 attempts at starting to learn haskell and when I got to that point I still was stuck messing around for quite a while before getting some understanding :)
08:51:02 <dwcook> sylvanica, look inside the .cabal file for the main-is field. That tells you what source file it starts in.
08:51:07 <merijn> sylvanica: Actually, there's another point than main where haskell code can start executing
08:51:20 <merijn> sylvanica: You can export functions using the FFI and have those called by C code
08:51:22 <sylvanica> merijn: coming from C/Java/PHP/etc. this is all confusing hehe
08:51:38 <sylvanica> merijn: ah okay, this actually uses cabal
08:51:50 <dwcook> sylvanica, on the other hand, this might not be a great example to look at – It looks kind of complicated
08:51:54 <sm> as mentioned in a recent HN haskell discussion, it's much easier to learn haskell from an existing project and team, than in a private green-field project
08:52:02 <merijn> sylvanica: The code starts here: https://github.com/houeland/kolproxy/blob/master/proxy.hs#L298-L305
08:52:03 <yogurt_truck> sylvanica: PHP people have the same problem you have when they go into both C and Java, btw
08:52:23 <yogurt_truck> "when does all of this execute?!"
08:52:25 <merijn> sylvanica: Although, sadly, this project seems to have no top-level type signatures, that's unfortunate
08:52:28 <sylvanica> yogurt_truck: but I look at code and have 0 idea what it does in Haskell hehe, I don't think that happens to them
08:52:58 <sylvanica> luckily I went from C to PHP and not vice versa, I suppose
08:53:08 <dwcook> What was the name of that project that implemented POSIX shell programs in Haskell?
08:53:17 <yogurt_truck> sylvanica: you have 2 different problems, then. 1. not knowing the entry point of a project, 2. not knowing the syntax/semantics/programming style of the language itself
08:53:24 <merijn> sylvanica: Personally I think program with no type signatures are really ahrd to read, even for experienced haskell programmers
08:53:26 <sylvanica> dwcook: oh I think I saw that somewhere
08:53:36 <sylvanica> dwcook: on the main website?
08:53:56 <dwcook> sylvanica, if you know what I'm talking about, that'd be a better place to start, I think
08:54:03 <dwcook> For one thing it's specifically written to be newcomer-friendly
08:54:12 <merijn> sylvanica: FYI, xmonad is not a terrible place to start, it's fairly short code
08:54:18 <dwcook> The programs are also much simpler than this KoL thing
08:54:32 <merijn> sylvanica: I think xmonad is only like 1200 lines of code
08:54:47 <sylvanica> merijn: what is xmonad?
08:55:01 <merijn> sylvanica: It's a tiling window manager for X11
08:56:24 <sylvanica> okay thanks, I'll have a look @_@
08:57:02 <merijn> I'm trying to think of other simple-ish standalone programs
08:57:43 <chirpsalot> xmonad is a recommend Haskell code reading for newbies?
08:57:53 <AmroPlay> @pl let makeDisplay s = show s ++ "%"
08:57:53 <lambdabot> (line 1, column 34):
08:57:53 <lambdabot> unexpected end of input
08:57:53 <lambdabot> expecting variable, "(", operator, ":", "++", "<+>", ";" or "in"
08:58:04 <merijn> chirpsalot: afaik the code is fairly readable and not overly complex
08:58:10 <Kinnison> chirpsalot: I found reading the xmonad source enlightening, but I was not a complete newbie when I tried
08:58:11 <chirpsalot> I always assumed it would have a lot of grossness in it because X... Maybe I should read it.
08:58:11 <AmroPlay> @pl \s -> show s ++ "%"
08:58:11 <lambdabot> (++ "%") . show
08:58:15 <merijn> chirpsalot: So after LYAH you should already be able to learn a lot from it
08:58:30 <chirpsalot> merijn: ah, cool :). I'll have to look into it.
08:58:51 <merijn> tbh I haven't read it myself aside from some blog posts discussing it's design
08:58:51 <chirpsalot> I can never get xmonad set up with gnome :(. Always explodes.
08:59:03 <merijn> I've just heard it was easy from others :)
08:59:25 <yogurt_truck> it's not just the complexity of functionality. this proxy.hs file isn't exactly the prettiest form of haskell programming I've seen
08:59:27 <chirpsalot> merijn: ah. For some reason I assumed a window manager would have gross / hacky code, y'know?
08:59:35 <yogurt_truck> 3 or 4 _huge_ functions
09:00:19 <chirpsalot> I don't even know how to write big functions in Haskell. Maybe letting where clauses get out of control is as far as I can get.
09:00:21 <merijn> sylvanica: Maybe take a look at this: http://rlgomes.github.io/work/haskell/2011/11/13/13.00-Writing-wc-command-line-tool-in-Haskell.html
09:00:38 <merijn> chirpsalot: You shouldn't write big functions in haskell :p
09:00:50 <sylvanica> merijn: ooh yes that is more manageable than a project, I think
09:01:05 <merijn> chirpsalot: I think the biggest stuff I've written is like 10-20 lines, maybe 40-50 if you include all where clauses with multi-line functions
09:01:33 <chirpsalot> merijn: well, obviously that's a good thing :P.
09:01:34 <AmroPlay> @help
09:01:34 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
09:01:56 <AmroPlay> @lis
09:01:56 <lambdabot> Maybe you meant: list listall listchans listmodules listservers
09:02:00 <AmroPlay> @list
09:02:00 <lambdabot> What module?  Try @listmodules for some ideas.
09:02:00 <chirpsalot> merijn: I'm saying that like... I don't even know if I can write a huge Haskell function. It pretty much forces you to break things up.
09:02:08 <AmroPlay> @listmodules
09:02:08 <lambdabot> activity base bf check compose dice dict djinn dummy elite eval filter free fresh haddock help hoogle instances irc karma localtime more oeis offlineRC pl pointful poll pretty quote search slap source spell system tell ticker todo topic type undo unlambda unmtl version where
09:02:09 <merijn> chirpsalot: For example, take pandoc (I just use this because it's the last real project I was hacking on), not many big things in there: https://github.com/jgm/pandoc/blob/master/src/Text/Pandoc/Readers/RST.hs
09:02:25 <AmroPlay> @djinn a -> a
09:02:26 <lambdabot> f a = a
09:02:29 <merijn> chirpsalot: That's the rST parser file, I think the biggest things is several 10s of lines
09:02:40 <merijn> AmroPlay: FYI lambdabot responds to private message too
09:02:43 <AmroPlay> @djinn Monad m => m a -> (a -> m b) -> m b
09:02:43 <lambdabot> f = (>>=)
09:02:53 <AmroPlay> @djinn Monad m => m a -> (m a -> m b) -> m b
09:02:54 <lambdabot> f a b = b a
09:02:54 <chirpsalot> merijn: yeah.
09:03:03 <AmroPlay> @djinn Monad m => a -> (m a -> m b) -> m b
09:03:03 <lambdabot> f a b = b (return a)
09:03:21 <merijn> (and it has top-level type signatures for ease of reading!)
09:03:24 <AmroPlay> @djinn Double -> Int
09:03:24 <lambdabot> Error: Undefined type Double
09:03:36 <chirpsalot> merijn: I guess some of this is pretty sizeable, though. All my stuff ends up being like... 5 lines tops.
09:03:42 <chirpsalot> But I'm new :D
09:03:45 <AmroPlay> @djinn (Fractional f, Integral i) => f -> i
09:03:46 <lambdabot> Error: Class not found: Fractional
09:04:13 <merijn> chirpsalot: Mostly the long stuff is actually just chaining lots of parsers in there
09:04:16 <quchen> AmroPlay: You can also /msg lambdabot to avoid spamming the channel. Lambdabot is really just here to show things to people, and not as a GHCi in IRC.
09:04:36 * hackagebot http-reverse-proxy 0.3.1.4 - Reverse proxy HTTP requests, either over raw sockets or with WAI  http://hackage.haskell.org/package/http-reverse-proxy-0.3.1.4 (MichaelSnoyman)
09:04:36 <AmroPlay> sorry
09:04:47 <AmroPlay> i didn't notice that :$
09:05:31 <merijn> chirpsalot: If you can get away with short stuff, then great :)
09:05:46 <quchen> You even get longer output in private mode, so if it's just for yourself that's another good reason to do it, AmroPlay :-)
09:06:08 <chirpsalot> merijn: yep! I haven't done anything with much complexity, though, so that might be why :P.
09:06:21 <chirpsalot> I find I have a problem with writing very long expressions, though.
09:08:15 <merijn> chirpsalot: Those should mostly be split into multiple while clauses anyway :p
09:09:30 <chirpsalot> merijn: while clauses? o_O
09:09:36 * hackagebot yesod 1.2.5.2 - Creation of type-safe, RESTful web applications.  http://hackage.haskell.org/package/yesod-1.2.5.2 (MichaelSnoyman)
09:09:38 * hackagebot yesod-auth 1.3.0.2 - Authentication for Yesod.  http://hackage.haskell.org/package/yesod-auth-1.3.0.2 (MichaelSnoyman)
09:09:40 * hackagebot yesod-bin 1.2.7.4 - The yesod helper executable.  http://hackage.haskell.org/package/yesod-bin-1.2.7.4 (MichaelSnoyman)
09:09:42 * hackagebot yesod-core 1.2.9.2 - Creation of type-safe, RESTful web applications.  http://hackage.haskell.org/package/yesod-core-1.2.9.2 (MichaelSnoyman)
09:09:45 * hackagebot yesod-eventsource 1.1.0.2 - Server-sent events support for Yesod apps.  http://hackage.haskell.org/package/yesod-eventsource-1.1.0.2 (MichaelSnoyman)
09:09:46 <merijn> eh
09:09:47 <merijn> where
09:09:51 <merijn> my brain is dying
09:09:53 <chirpsalot> merijn: OH. Okay :P.
09:09:56 <quicksilver> an entire program is really one long definition linked by an implicit where clause
09:10:07 <quicksilver> no need to get worried about large expressions per se
09:10:12 <chirpsalot> merijn: I thought I missed something big :P.
09:10:23 <quicksilver> but on the other hand it's nice to have separately testable parts
09:10:31 <merijn> quicksilver: s/testable/readable
09:10:58 <chirpsalot> quicksilver: well, the large expressions can be... Not very readable.
09:12:03 <klrr_> would it be feasable to make android app using websockets? e.g. use the webview and use HTML/CSS/JS for that and then do the rest of the business in haskell?
09:12:37 <tdammers> klrr_: you mean like phonegap?
09:12:44 <dwcook> klrr_, or do the JS in Haskell too! (with ghcjs or Fay or the like)
09:12:56 <merijn> klrr_: Why not just everything in haskell?
09:13:15 <Taneb> klrr_, yes
09:13:30 <Taneb> Well, at least Haskell doesn't stop you
09:14:10 <klrr_> merijn: i know that's possible, but im new to android and heard its "cutting-edge" ground, i want to see if there's a easy way to do it
09:14:19 <klrr_> hmm
09:14:22 <klrr_> okey
09:14:43 <chirpsalot> klrr_: I don't think that's cutting edge? A lot of apps are really just web goo.
09:14:46 <quicksilver> merijn: I reject that.
09:14:46 * hackagebot yesod-form 1.3.8.1 - Form handling support for Yesod Web Framework  http://hackage.haskell.org/package/yesod-form-1.3.8.1 (MichaelSnoyman)
09:14:48 * hackagebot yesod-newsfeed 1.2.0.2 - Helper functions and data types for producing News feeds.  http://hackage.haskell.org/package/yesod-newsfeed-1.2.0.2 (MichaelSnoyman)
09:14:50 * hackagebot yesod-static 1.2.2.4 - Static file serving subsite for Yesod Web Framework.  http://hackage.haskell.org/package/yesod-static-1.2.2.4 (MichaelSnoyman)
09:14:53 * hackagebot yesod-test 1.2.1.2 - integration testing for WAI/Yesod Applications  http://hackage.haskell.org/package/yesod-test-1.2.1.2 (MichaelSnoyman)
09:14:57 <chirpsalot> klrr_: OH. EVERYTHING IN HASKELL.
09:14:59 <chirpsalot> I understand.
09:15:00 <quicksilver> nothing inherently unreadable about large expressions.
09:15:07 <sm> go snoyberg
09:15:27 <quicksilver> looking at programming languages en masse 'expression' is a pretty arbitrary designator
09:15:29 <merijn> quicksilver: I dare say there is an upper bound to expression size after which they become unreadable
09:15:46 <quicksilver> languages exist where an entire program is necessarily a single expression
09:15:54 <quicksilver> you could read lisp that way
09:16:12 <quicksilver> nothing stops large expressions having internal modularity
09:16:19 <quicksilver> and proper structure.
09:16:23 <chirpsalot> quicksilver: depends how the lisp is written?
09:17:00 <chirpsalot> Wait... How is "expression" defined anyway.
09:17:17 <bahamas> in this chapter http://learnyouahaskell.com/a-fistful-of-monads the "guard" function is defined as returning m (), where "m" is a monad. why is the function allowed to return []?
09:17:38 <bahamas> did I miss something about how monads work?
09:17:57 <merijn> bahamas: Ah
09:17:58 <bahamas> actually sorry, "m" is a MonadPlus
09:18:09 <merijn> bahamas: Right, I was about to point that out :p
09:18:22 <merijn> bahamas: MonadPlus has extra requirements on top of Monad :)
09:18:25 <prophile> you could implement guard using fail!
09:18:27 * prophile runs
09:18:47 <dagle> You can implement it using undefined too.
09:18:50 <bahamas> merijn: is that relevant in relation to guard?
09:19:02 <merijn> bahamas: Yes!
09:19:32 <merijn> bahamas: In fact, "guard" *cannot* make sense for any non-MonadPlus monad, hence why it requires MonadPlus :p
09:20:09 <merijn> bahamas: You have MonadZero which has "mzero :: m a" and MonadPlus (which requires MonadZero) has "mplus :: m a -> m a -> m a"
09:20:34 <merijn> bahamas: Let's start with, what could "mzero :: m a" mean?
09:20:46 <bahamas> merijn: then I'm confused. I thought that if you define a certain type as the return of a function, only that type can be returned
09:21:09 <bahamas> merijn: well, LYAH says that it's like mempty in Monoid
09:21:29 <bahamas> mzero 4
09:21:31 <bahamas> >mzero 4
09:21:32 <merijn> bahamas: Right, we can't create a value of type 'a' from thin air, so what does this mean about mzero?
09:21:56 <bahamas> merijn: that we pass it a certain value to return a MonadPlus value?
09:22:10 <merijn> bahamas: No, look at it's type "mzero :: m a"
09:22:20 <bahamas> oh, sorry
09:22:32 <merijn> bahamas: In other words, mzero says we *can* create "m a" out of thin air, *even though* it's impossible to create an 'a' out of thin air
09:22:41 <merijn> Which tells us what?
09:23:06 <lavorno> merijn: that the air is getting polluted ?
09:23:10 <bahamas> *magick*
09:23:44 <merijn> bahamas: It means that the "m a" can't have an actual 'a' in it!
09:23:59 <merijn> "what does that even mean?!"
09:24:04 <merijn> > mzero :: Maybe Int
09:24:05 <lambdabot>  Nothing
09:24:08 <merijn> > mzero :: Maybe Char
09:24:09 <lambdabot>  Nothing
09:24:23 <bahamas> > mzero :: []
09:24:24 <lambdabot>  Expecting one more argument to `[]'
09:24:28 <merijn> bahamas: i.e. MonadZero is for Monads that have a notion of "being empty"
09:24:32 <bahamas> > mzero :: [Char]
09:24:33 <merijn> > mzero :: [Int]
09:24:33 <lambdabot>  ""
09:24:34 <lambdabot>  []
09:25:08 <dwcook> I guess mzero for a parser type would be a parser than always fails
09:25:12 <dwcook> that*
09:25:18 <merijn> bahamas: Similarly, MonadPlus is somewhat similar to Monoid in that MonadPlus defines "mplus :: m a -> m a -> m a" with the following laws
09:25:26 <bahamas> merijn: so monads can't be empty normally, but MonadPlus allows us to have empty monads
09:25:50 <dwcook> bahamas, you can easily not define an instance of MonadPlus for a Monad with a sense of "emptiness"
09:25:54 <merijn> bahamas: Well, Monad doesn't *require* the ability to be empty, but it does *allow* it
09:26:08 <merijn> bahamas: So knowing something is a Monad is not enough to know it can be empty
09:26:12 <bahamas> dwcook: "you can easily not define". sorry, I don't understand
09:26:21 <merijn> bahamas: MonadZero *does* tell it the monad can be empty
09:26:28 <dwcook> bahamas, never mind, listen to merijn :)
09:26:35 <lavorno> merijn: that's a great explanation
09:26:46 <merijn> bahamas: The laws for mplus are: "mplus mzero x = x" and "mplus x mzero = x" and "mplus x y = ??"
09:26:55 <merijn> > mplus Nothing Nothing
09:26:55 <lambdabot>  Nothing
09:26:59 <merijn> > mplus Nothing (Just 1)
09:27:00 <lambdabot>  Just 1
09:27:06 <merijn> > mplus (Just 1) Nothing
09:27:07 <lambdabot>  Just 1
09:27:15 <merijn> > mplus (Just 1) (Just 2) -- surprise!
09:27:16 <lambdabot>  Just 1
09:27:28 <bahamas> merijn: mplus is like >> or I'm mistaken
09:27:32 <mornfall> > foldl mplus mzero [[1], [2], [3]]
09:27:32 <lambdabot>  [1,2,3]
09:27:39 <merijn> bahamas: Only for Maybe
09:27:42 <zerokarmaleft> notice the difference between mplus and the monoidal mappend for Maybe
09:27:49 <merijn> > mplus [1,2] [3,4]
09:27:50 <lambdabot>  [1,2,3,4]
09:27:55 <k00mi> not even for Maybe
09:27:57 <merijn> > [1,2] >> [3,4]
09:27:58 <lambdabot>  [3,4,3,4]
09:28:00 <k00mi> > Just 1 >> Nothing
09:28:01 <lambdabot>  Nothing
09:28:06 <merijn> k00mi: Oh, right, yeah
09:28:08 <k00mi> > Just 1 `mplus` Just 2
09:28:08 <lambdabot>  Just 1
09:28:16 <k00mi> > Just 1 >> Just 2
09:28:17 <lambdabot>  Just 2
09:28:36 <merijn> bahamas: So for "Maybe" mplus takes the "first non-Nothing result"
09:28:48 <merijn> bahamas: However, for lists "mplus" is just concat
09:29:16 <merijn> bahamas: mplus just says "I have a way to combine two "m a" into one and if one of those two is mzero, then I just return the non-mzero value"
09:29:29 <mornfall> the fact mplus is not commutative is unfortunate, terminology-wise
09:29:40 <chirpsalot> merijn: got a link for the xmonad design blog thing? Was it this? http://xmonad.wordpress.com/2009/09/09/the-design-and-implementation-of-xmonad/ the actual pdf seems to be dead, though :(.
09:29:53 <merijn> chirpsalot: No, I couldn't find it last time I looked for it :\
09:29:59 <chirpsalot> The guided tour? http://www.haskell.org/haskellwiki/Xmonad/Guided_tour_of_the_xmonad_source
09:29:59 <Saizan> is there a tool for convenient display of haskell values? especially nested records, i'd like something that e.g. allows me to collapse fields i'm not interested in
09:30:06 <merijn> bahamas: Make sense so far?
09:30:18 <mornfall> Saizan: there was something to draw them, but can't remember the name
09:30:43 <Saizan> mornfall: you mean vacuum?
09:30:55 <mornfall> Saizan: guess so :-)
09:31:11 <lavorno> Saiizan: i believe there was something like repr-tree-syb (if i remember well)
09:31:13 <merijn> bahamas: Now, knowing mplus and mzero we can look at guard again
09:31:32 <bahamas> merijn: rereading everything
09:31:41 <k00mi> mornfall: well, commutativity is not a law for semigroups (or monoids, groups)
09:31:41 <lavorno> haven't played with if i remember well was claiming to do what u r asking for
09:31:42 <lavorno> --
09:32:13 <ClaudiusMaximus> chirpsalot: http://web.archive.org/web/20100113044540/http://galois.com/~dons/talks/xmonad.pdf perhaps?
09:32:16 <mornfall> k00mi: sure, but using + in particular for a non-commutative operation seems unusual
09:32:37 <c_wraith|N10> I wish vacuumLazy would provide info about the closure.. Like operating recursively on each value held in the closure.
09:32:57 <Saizan> lavorno: will google, thanks
09:33:09 <mornfall> k00mi: do you remember what's the motivating property for that naming?
09:33:13 <c_wraith|N10> If it could do that, it'd give all the necessary info for tracking down space leaks.
09:33:33 <sylvanica> merijn: I found a tutorial for C programmers. Section I: What the Heck is Going On?
09:33:37 <k00mi> mornfall: what naming?
09:33:42 <mornfall> k00mi: MonadPlus
09:33:44 <lavorno> saizan: please share if it workes the advertised way :)
09:33:57 <Saizan> in my case i really just want to read the actual data, not caring about the memory layout atm :)
09:34:12 <k00mi> mornfall: no
09:34:39 * hackagebot th-lift-instances 0.1.1 - Lift instances for template-hasell for common data types.  http://hackage.haskell.org/package/th-lift-instances-0.1.1 (BennoFuenfstueck)
09:34:45 <lavorno> right, that's what is supposed to do - i re-found it already http://hackage.haskell.org/package/repr-tree-syb-0.1.0/docs/ReprTree.html
09:35:12 <Saizan> https://github.com/nikita-volkov/repr-tree-syb <- a bit too simplistic, it seems
09:35:41 <lavorno> y
09:36:00 <lavorno> it uses generics, tapeable, etc
09:36:37 <lavorno> u can try it easily - would be interested how it holds for more complex structures than in the example
09:36:53 <c_wraith|N10> sylvanica: what tutorial is that?
09:37:04 <sylvanica> c_wraith|N10: http://www.haskell.org/haskellwiki/Haskell_Tutorial_for_C_Programmers
09:37:49 <mornfall> lavorno: tapeable, I really like that :D
09:38:06 <k00mi> mornfall: it's not unusual at all to denote the operand of a semigroup as + or *
09:38:08 <lavorno> :)
09:38:33 <lavorno> mornfall: going old school
09:39:08 <mornfall> k00mi: operation... maybe
09:39:48 <k00mi> uh, operator I meant
09:40:43 <mornfall> k00mi: I'd find . or juxtaposition a more likely candidate, but you can't use that for a name ;-)
09:40:46 <c_wraith|N10> sylvanica: hmm. I kinda don't like that intro. It seems like it's talking down quite a bit. It's not like low-level people have never seen SSA for when doing compiler optimizations.
09:41:31 <sylvanica> c_wraith|N10: maybe it's just me, then
09:41:40 <sylvanica> c_wraith|N10: Haskell makes zero sense to me at the moment, I need all the help I can get
09:42:05 <sylvanica> c_wraith|N10: I understand the motivation behind it but it doesn't click yet
09:44:19 <c_wraith|N10> sylvanica: one of the best lines I've ever seen said that mutability is like manual memory management. Sometimes it's meaningfully more efficient, but there's a huge mental overhead involved in not screwing it up.
09:47:05 <c_wraith|N10> sylvanica: in any case, the only way to get comfortable with haskell is to do stuff with it. Play with bits and pieces, and ask whenever you have questions. It's a lot different from most languages, in ways that are surprisingly useful.
09:47:27 <sylvanica> c_wraith|N10: I'm still at the popping-ibuprofen-for-the-massive-headache stage, hehe.
09:48:18 <lavorno> sylvanica:: don't pop ibuprofen - it has side effects (which are bad things)
09:48:37 <sylvanica> lavorno: I'm not actually taking anything, but it is giving me a headache :)
09:49:11 <merijn> sylvanica: Don't feel bad :)
09:49:14 <mornfall> sylvanica: he was making a joke about referential transparency ;-)
09:49:15 <c_wraith|N10> Don't force it. Discovery feels good, not bad. :)
09:49:16 <merijn> @quote conveniently.gloss
09:49:17 <lambdabot> cjeris says: Cale: I like how you conveniently gloss over the part where your head explodes.
09:49:20 <lavorno> sylvanica: i hope u don't - was just joking to make a point about how "side effect" things are bad for u
09:49:21 <sylvanica> mornfall: I got it afterward hahaha
09:49:34 <lavorno> mornmall: tx :)
09:49:36 <sylvanica> merijn: I feel bad anyway :(
09:49:43 <lavorno> mornfall : tx
09:50:10 <Dugar> What side effects does ibuprofen have?
09:50:11 <merijn> sylvanica: I think it's mandatory to feel your head exploded due to an aneurysm at least 3 times while learning haskell :p
09:50:17 <mornfall> sylvanica: you can write functional code in C just fine btw :)
09:50:18 <sylvanica> Dugar: liver damage!
09:50:25 <merijn> Dugar: It was a joke about side effects :p
09:50:27 <mornfall> sylvanica: or whatever your normal language is
09:50:57 <merijn> FYI, you need to consume ungodly amounts of ibuprofen to risk liver damage :p
09:51:00 <sylvanica> mornfall: I think it is the function part more than the Haskell part
09:51:00 <lavorno> mornfall: i respectfully disagree… maybe "functional like"..
09:51:04 <sylvanica> mornfall: functional*
09:51:35 <mornfall> sylvanica: ever read SICP?
09:51:50 <sylvanica> mornfall: newp
09:52:04 <mornfall> sylvanica: I'd give it a try :-)
09:52:18 <Earnestea> lavorno: http://rosettacode.org/wiki/Y_combinator#C :P
09:52:20 <bahamas> ok, I understood the distinction between ">>" and "mplus" at least
09:52:43 <lavorno> Dugar: besides liver damage, it has been found that can increase your chance for tachicardia and irregular heart beats
09:53:15 <bahamas> or not.
09:53:17 <mornfall> lavorno: what Earnestea says -- it sucks that you don't have a function literal, but other than that?
09:53:21 <bahamas> > [1,2] >> [3,4]
09:53:22 <lambdabot>  [3,4,3,4]
09:54:31 <lavorno> mornfall: are u looking at picking a fight ? (functional vs imperative) - i am not that kind of guy - i'm a pacifist dude.. i believe there is a place in 8G of ram for all von Neumann's creatures..
09:55:20 <mornfall> lavorno: not really, I'm just curious why you think it's impossible to write functional code in C (or other imperative languages)
09:55:44 <chirpsalot> Earnestea: uh... That's awful. XD
09:55:49 <Earnestea> chirpsalot: Yep :p
09:56:03 <chirpsalot> Earnestea: though I have done similar things to get partial application in C...
09:56:15 <mornfall> lavorno: nobody said it was particularly practical, but it can help you understand the ideas without also grasping new syntax and a type system all at once
09:56:53 <lavorno> Earnestea: have u ever chased a pointer to a pointer to a function ?
09:57:52 <Earnestea> lavorno: Perhaps?
09:57:53 <c_wraith|N10> mornfall: I don't know. It's really hard to write a function that takes two function pointers and returns a pointer to their composition in C
09:58:40 <chirpsalot> c_wraith|N10: especially if you want the pointer to be a function pointer, and not a pointer to some structure of functions.
09:58:45 <lavorno> Earnestea: sounds good - then u were just joking i guess :)
09:58:55 <chirpsalot> Which you then call like "apply" or something on.
09:59:07 <mornfall> function pointers are a very poor choice for representing functions in C ;-)
09:59:31 <c_wraith|N10> I'll give you that much. :)
09:59:34 <chirpsalot> mornfall: yeah, but how else do you represent a low level function?
10:00:23 <chirpsalot> I guess C++ has lambdas now :P.
10:00:29 <mornfall> chirpsalot: you need to represent closures somehow -- you can store the function pointer in a head of a structure... it makes for awkward call syntax though
10:00:31 <lavorno> mornfall: i like c and i believe it can be many things, but after getting more and more familiar with haskell (by the year :) ) c is no match for the beauty of haskell
10:00:39 <chirpsalot> mornfall: yeah.
10:00:52 <mornfall> of course, there's C++ :-)
10:01:02 <mornfall> especially C++14 ;-)
10:01:18 <chirpsalot> mornfall: somehow C++ manages to be even more disgusting...
10:01:25 <Earnestea> lavorno: C is null terminated.  :x
10:01:26 <chirpsalot> I like C, though.
10:01:43 <mornfall> chirpsalot: that's just fear of the unknown talking ;P
10:01:51 <lavorno> Earnestea: hey, at least you know where the forest ends..
10:02:07 <chirpsalot> mornfall: not sure if sarcasm :P.
10:02:10 <lavorno> Earnestea: but in haskell u can see both the forest and the trees
10:03:20 <chirpsalot> mornfall: but yeah, getting closures in C is... Very unpleasant.
10:05:47 <chirpsalot> lavorno: I'm kind of in the same boat. I am mostly a C programmer, but Haskell is sooooooo much more beautiful and well thought out. C is super gross in comparison.
10:07:46 <lavorno> chirpsalot: yeah.. after having the orgasmic experience of writing haskell code it doesn't feel the same when playing with your old imperative tOOls… :)
10:08:08 <chirpsalot> lavorno: I have kind of failed to find a "high level language" to use on silly tasks... I always end up writing stuff in C :|. Hopefully Haskell will take over soon :P.
10:09:56 <lavorno> chirpsalot: imo that's a really bad approach. haskell is not for silly tasks.. you can build very sophisticated stuff in an extremely compact way. much better than in any of the languages at least i am familiar with (assembler, c/c++/java/py and a bit of ruby)
10:10:08 <khyperia> I wish there were other really first-class supported languages for GPU programming other than C/Fortran
10:10:39 <prooftechnique> I thought there was some wacky dependently typed language for just that thing
10:11:35 <lavorno> chirpsalot: but if your name is about what u do (chirp - some dsp/radar stuff) probably c will be used in that area for the time being
10:15:57 <levi> khyperia: I expect that will happen shortly after some other language becomes dominant in HPC and/or game programming.
10:16:17 <khyperia> Hopefully that's soon.
10:16:37 <khyperia> I haaate writing my signal processing pipeline in C
10:17:53 <bahamas> > mplus (Just 3) (Just 4)
10:17:54 <lambdabot>  Just 3
10:18:09 <bahamas> can anyone explain why Just 3 is returned above?
10:18:16 <prooftechnique> :t mplus
10:18:17 <lambdabot> MonadPlus m => m a -> m a -> m a
10:18:26 <bahamas> for lists mplus = (++). what is it for Maybe?
10:19:44 <khyperia> @src Maybe mplus
10:19:45 <lambdabot> Nothing `mplus` ys = ys
10:19:45 <lambdabot> xs      `mplus` ys = xs
10:20:14 <khyperia> is that what you were asking?
10:20:42 <prooftechnique> Looks like First
10:20:47 <bahamas> khyperia: it's a good start. now I need to understand why the implementation is like that
10:21:01 <benbangert> is there a function which turns an Either into a Maybe?
10:21:07 <quicksilver> bahamas: Maybes are like lists where you can only see the first element.
10:21:45 <quicksilver> mplus for maybes could be defined as "mplus a b = listToMaybe (maybeToList a) (maybeToList b)"
10:22:45 <zerokarmaleft> do the MonadPlus laws constrain the solution space such that the existing implementation for Maybe is the only possible implementation?
10:22:55 <prooftechnique> It also behaves exactly like mappend for First a
10:22:56 <levi> benbangert: If you look at the errors package, it's got lots of little helpers like that.
10:22:59 <quchen> :t either (const Nothing) Just -- benbangert
10:23:00 <lambdabot> Either a a1 -> Maybe a1
10:23:19 <khyperia> benbangert, using fpcomplete's hoogle, I found Control.Errors.Safe.rightMay
10:23:38 <benbangert> quchen: ah cool, was just thinking that, and wondering how to make the first func ignore the e, didn't know about const. thanks
10:23:45 <levi> Of course they're relatively easy to define for yourself, but the errors package collects a bunch of common error-handling idioms.
10:24:10 <prooftechnique> @src First mappend
10:24:10 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
10:24:24 <prooftechnique> r@(First (Just _)) `mappend` _ = r First Nothing `mappend` r = r
10:25:15 <quchen> Lambdabot has a static database: https://github.com/mokus0/lambdabot/blob/master/lambdabot/State/source
10:25:19 <khyperia> So there's `const x _ = x`, is there a `something _ x = x`?
10:25:23 <quchen> For @src, that is
10:25:28 <bahamas> quicksilver: I don't understand, sorry. especially considering that mplus [1,2] [3,4] = [1,2,3,4]
10:25:34 <quchen> :t const id -- khyperia
10:25:34 <lambdabot> b -> a -> a
10:25:41 <khyperia> ah, cool, thanks
10:25:48 <quchen> :t flip const -- same thing
10:25:49 <lambdabot> b -> c -> c
10:25:50 <bahamas> quicksilver: ooh, now I understand :)
10:26:07 <klugez> benbangert: The version in errors is Control.Error.Util.hush
10:26:35 <benbangert> klugez: cool, think I'm gonna go with the either one just to avoid more deps
10:27:19 <prooftechnique> bahamas: It's really just dependent on which Monoid mplus and mzero form
10:27:22 <benbangert> don't need that much error handling in this particular thing, but thats a very handy package...
10:27:24 <prooftechnique> In the case of Maybe, that's First
10:27:45 <prooftechnique> It could just as easily have been Last, though
10:27:45 <quicksilver> that doesn't really answer the question, prooftechnique
10:27:49 <quicksilver> that just restates it
10:27:57 <quicksilver> there is a reason it's First not Last
10:28:14 <prooftechnique> Oh. Well, I don't know that reason, so please go on
10:28:19 <quicksilver> it's "like" exception handling
10:28:30 <quicksilver> `mplus` is "try this then try that if the first one didn't work"
10:28:37 <khyperia> quchen... `const id` is brilliant. I can see that the types check out, but it took me a bit to realize how it works.
10:28:38 <quicksilver> so it returns the first one (if the first one did work)
10:28:39 <prooftechnique> Ah, okay. That makes sense
10:29:15 <quicksilver> there isn't much agreement on what the laws for MonadPlus are supposed to be though
10:29:20 <quicksilver> but if there was, it might make it clearer
10:29:21 <quchen> khyperia: Yeah I found it surprisingly unclear as well when I first saw it
10:29:33 <quicksilver> http://en.wikibooks.org/wiki/Haskell/MonadPlus#The_MonadPlus_laws
10:29:35 <quchen> But I don't know why anymore now that it makes perfect sense :-D
10:29:52 <bahamas> quicksilver: this whole thing started, because I didn't understand the definition of "guard" in http://learnyouahaskell.com/a-fistful-of-monads and why it accepts return mzero
10:30:30 <bahamas> s/accepts return mzero/accepts mzero as a return value/
10:30:54 * quicksilver nods
10:31:33 <bahamas> so m () in the type definition actually includes both m () and mzero?
10:33:00 <quchen> I don't understand what the problem with standardizing MonadPlus properly is. Associativity/left zero seem to be undisputed; the third law makes everyone go bonkers and is generally ignored, done wrong on purpose, or whatever. Why we don't just drop the third law and require the first 3 is a mystery to me.
10:33:15 <quchen> First 2*
10:33:45 <quchen> Right now MonadPlus is a class without any laws because nobody obeys them.
10:34:30 <bahamas> quchen: can you answer my question?
10:34:38 <prooftechnique> I wonder how that reform proposal is going
10:34:41 <notdan> associativity == monoid w/ regards to mplus?
10:34:52 <quchen> Yes
10:35:18 <quchen> I should have written "monoid" because that includes laws with mplus/mzero.
10:35:18 <notdan> bahamas: mzero has type 'm a'
10:35:29 <notdan> so it also has type 'm ()'
10:35:58 <notdan> quchen: apparently there is also that 'left catch' rule...
10:36:00 <notdan> http://www.haskell.org/haskellwiki/MonadPlus
10:36:17 <quchen> Yes. That's one of the "third rules that should be ignored".
10:37:07 <prooftechnique> There's also http://www.haskell.org/haskellwiki/MonadPlus_reform_proposal, but no one's added anything since 2011
10:37:11 <quchen> The point of having a typeclass like Monad, Functor, MonadPlus is that there are laws you can rely on. When the laws depend heavily on the specific instance the abstraction is an obfuscation.
10:37:47 <bahamas> notdan: ok, I see. thank you
10:42:07 <kazagistar> yesterday I asked about generating random strings that match a regex (for use with Arbitrary) and was pointed at genex, which is pretty cool but unfortunately only generates small strings, which kinda sucks :P
10:43:13 <tac> > [id] == [(+0)]
10:43:14 <lambdabot>  No instance for (GHC.Num.Num a0) arising from a use of `GHC.Num.+'
10:43:14 <lambdabot>  The type variable `a0' is ambiguous
10:43:14 <lambdabot>  Possible fix: add a type signature that fixes these type variable(s)
10:43:14 <lambdabot>  Note: there are several potential instances:
10:43:14 <lambdabot>    instance GHC.Num.Num GHC.Types.Double
10:46:09 <narendraj9> > logs
10:46:10 <lambdabot>  Not in scope: `logs'
10:46:10 <lambdabot>  Perhaps you meant `log' (imported from Prelude)
10:46:30 <narendraj9> !logs
10:46:46 <prooftechnique> narendraj9: http://ircbrowse.net
10:47:02 <narendraj9> prooftechnique, thanks. :-)
10:47:10 <notdan> http://paste.hskll.org/get/1183 lawbreaking stuff!
10:47:35 <notdan> I swear I came up with a shorter example some time ago.. but couldn't remember it.
10:50:00 <Kaidelong> notdan: didn't distribution for MonadPlus only apply on the left side?
10:51:50 <notdan> Kaidelong: hm yes
10:52:06 <notdan> Kaidelong: mplus is on the left side, that's why it is called "left distribution" I guess
10:52:12 <notdan>      Left Distribution:
10:52:13 <notdan> mplus a b >>= k = mplus (a >>= k) (b >>= k)
10:52:43 <edwardk> right now monadplus is a class without laws because it is secretly two classes that are disturbingly similar but for most people reasoning about it casewise that never comes up as an issue
10:53:09 <notdan> I use the monadplus instance for maybe because I like the guard function
10:53:32 <edwardk> notdan: most folks would call that "left distribution" (sic) a right distribution law
10:53:42 <Kaidelong> that's what I was thinking yes
10:53:58 <Kaidelong> I was really surprised to see that
10:54:26 <notdan> hm it does make sense! You distribute bind from right to left
10:54:29 <notdan> or something
10:54:53 <Kaidelong> (a+b)*c = (a*c+b*c) is right distribution
10:55:00 <notdan> (a+b)*k = a*k + b*k <- is that right distribution?
10:55:02 <notdan> oh
10:55:05 <notdan> I see
10:55:07 <notdan> fair enough
10:55:09 <Kaidelong> that example is analogous to that because of where k is
10:55:14 <notdan> yes
10:55:29 <notdan> well another reason for getting rid of that law :P
10:56:06 <edwardk> woohoo! fully deamortized COLA inserts are finally faster than Data.Map!
10:56:59 <Kaidelong> http://winterkoninkje.dreamwidth.org/90905.html
10:57:37 <Kaidelong> so this guy does propose the "left distribution" law but he calls it "right distribution"
10:58:27 <edwardk> distribution vs catch will probably be with us forever, as most people don't 'feel' the issue.
10:59:03 <Kaidelong> is Alternative also schizophrenic about this?
11:00:28 <Kaidelong> blog post complains about MonadPlus with the current assumptions makes it akin to logic programming with backtracking which is "too stringent"
11:00:36 <Kaidelong> but I almost always use MonadPlus to do exactly that
11:12:44 <cdk_> edwardk: whats's COLA?
11:13:50 <edwardk> cache-oblivious lookahead array
11:14:14 <edwardk> it is a technique i've been using to build fast Map-like structures for Haskell that beat Data.Map for insert speed
11:14:20 <edwardk> and which unbox nicely
11:14:34 <cdk_> cool! is it on github?
11:14:43 <edwardk> yeah, structures.
11:14:43 <athan> edwardk: I just saw your structures library - is there a (probably obvious) advantage to the cache obliviousness?
11:14:44 <ski> chrisdotcode : function application acts (in relation to `showsPrec' and `readsPrec', e.g.) as if it has precedence `10' (dunno about `@',`~',`!', record aggregate and record update here)
11:14:59 <edwardk> Data.Vector.Map is the core implementation
11:15:04 <athan> edwardk: is it merely a design, or are there optimizations for when it gets implemented?
11:15:11 <edwardk> Data.Vector.Map.Ephemeral is 2-4x faster
11:15:15 <athan> edwardk: ah wow
11:15:17 <chrisdotcode> ski: is the anything higher? or is this mythical "10" the higest?
11:15:37 <chrisdotcode> s/the/there
11:15:45 <edwardk> athan: Data.Vector.Map inserts about 2-4x faster than Data.Map, the ephemeral version is faster still
11:16:13 <athan> edwardk: holy toleto
11:16:51 <edwardk> just hackaged it. have fun playing with it. it has a _very_ minimal API right now as I explore the design space
11:17:20 <chrisdotcode> edwardk: so will Data.Vector.Map replace Data.Map one day, or are they inherently different?
11:17:27 <edwardk> in the end it'll give you a structure with the same (even worst-case!) asymptotics as a b-tree for all caches, but with a fully persistent API.
11:17:33 <edwardk> chrisdotcode: very different
11:17:49 <edwardk> Map still has slightly faster lookups
11:18:13 <chrisdotcode> oh, so it's a tradeoff, as opposed to an overall improvement
11:18:19 <edwardk> think of Data.Vector.Map as useful for very big maps that you do write-mostly behavior
11:18:21 <edwardk> so far
11:18:32 <edwardk> we'll see if i can change that eventually
11:18:44 <ski> chrisdotcode : in terms of `showsPrec' and `readsPrec', a precedence is an `Int' -- and to implement left associativity of application, it uses `10 + 1', iow `11' as a precedence level.
11:18:51 <edwardk> but the deamortized version already effectively uses Data.Map as a nursery. ;)
11:19:28 <ski> chrisdotcode : in terms of parsing, `@',`~',`!',record aggregate and record update has higher precedence than function application
11:19:58 <edwardk> chrisdotcode: also Data.Map has a _much_ richer API right now
11:20:10 <edwardk> eventually this COLA stuff will feed back into my analytics project
11:20:15 <chrisdotcode> ski: do you know this off the top of your head, or is there a reference you're using (or which source file you're using)?
11:20:26 <chrisdotcode> edwardk: so how is the implementation *that* much faster for data.vector.map?
11:20:28 <ski> > Node {rootLabel = (),subForest = []} {rootLabel = (),subForest = []}
11:20:29 <lambdabot>  Node {rootLabel = (), subForest = []}
11:20:30 <ski> > let x = Node {rootLabel = (),subForest = []} in x {rootLabel = (),subForest = []} {rootLabel = (),subForest = []}
11:20:31 <lambdabot>  Node {rootLabel = (), subForest = []}
11:20:32 <edwardk> but having the fully deamortized version start to win benchmarks is very promising from a raw 'computer science' implementation.
11:20:35 <pearson> Hi, got a question regarding learn you a Haskell. Type this new data and ghci doesn't accept it at all : data Bool = False | True deriving (Ord)  -- Can't continue the tutorial  because of this.
11:20:42 <ski> .. and the two latter appear to be left associative
11:20:58 <ski> chrisdotcode : off the top of my head
11:21:17 <chrisdotcode> ski: that's incredibly impressive ._.
11:21:25 <ski> .. not really :|
11:21:56 <edwardk> chrisdotcode: Data.Map is excellent from the perspective of a pointer machine model, but it ignores cache behavior. stuff isn't nearby in memory. it makes decent use of L1, L2, but not the page cache, etc.
11:22:01 <ski> (just that i've implemented a few `Show' and `Read' instances manually, so that i understand how that is supposed to function (mostly))
11:22:22 <edwardk> chrisdotcode: a COLA gives you B-Tree asymptotics for all cache levels. I found a way to make that have a functional API.
11:22:41 <nadirs> pearson: what does ghci say?
11:22:46 <edwardk> B-Tree asymptotics are better than Data.Map asymptotics, because you can divide out the block size
11:23:04 <ski> chrisdotcode : the report probably includes language that function application has higher precedence than any defined operators (which excludes `@',`~',`!' in patterns, which have higher precedence)
11:23:19 <nadirs> I think you should probably do `deriving (Eq, Ord)`
11:23:20 <edwardk> in the small it loses out on constant factors, so i use a traditional Data.Map as a nursery
11:23:32 <chrisdotcode> edwardk: is this low-level optimization stuff, or are you just using better algorithms in pure haskell?
11:23:47 <edwardk> well, in the small, the fully deamortized form does, that is the innovation of this afternoon.
11:23:56 <edwardk> it is a fundamentally different algorithm
11:24:01 <khyperia> Okay, note to self, never execute `fix (forkIO >>= (>>))` ever again. Was trying to do a forkbomb, and, unsurprisingly, got very very out of control.
11:24:03 <athan> edwardk: do you have any suggested reading material for lenses? Maybe, the papers that revolutionized your p.o.v. when you first started learning...?
11:24:03 <chrisdotcode> ski: yeah, I'm probably gonna go rummaging through the report eventually :)
11:24:36 <edwardk> Data.Vector.Map is made literally out of vectors of key-value pairs, with a creative merge strategy
11:24:45 <edwardk> Data.Map is a binary tree
11:24:57 <athan> !
11:25:55 <athan> ....tryin to not be a pleb haha. Sorry :P
11:26:54 <edwardk> athan: for lenses its hard to make good recommendations. http://lens.github.io/ links to some of the early blog articles as we discovered the style
11:28:11 <athan> edwardk: That's perfect, thank you!!!
11:28:19 <k00mi> athan: I found Simon Peyton Jones' talk on lenses quite enlightening
11:28:29 <athan> edwardk: is a lens somewhat like a continuation?
11:28:39 <pearson> nadirs: This is the result http://lpaste.net/101861 . Yet I guess I need to do something else, since I tried the solutions on prior experimentations and it was something else all along.
11:29:08 <athan> edwardk: He touches the subject? Heck yeah! I've always had fun trying to enjoy his work, but he's on another level than me lol
11:29:13 <edwardk> athan: if you look at the style of a lens it is 'cps'd, but i'd hesitate to make that statement
11:29:56 <athan> edwardk: there's an underlying algebra? that relates downstream/upstream elements or something?
11:31:29 <edwardk> well, there are various ways to talk about lenses categorically, as algebras of a particular monad in a slice category over the value type for instance.
11:31:50 <ski> chrisdotcode : anyway, looking at source of `Show' and `Read' instances of basic simple types is instructive
11:31:51 <athan> hmm
11:31:54 <athan> interesting
11:32:10 <chrisdotcode> ski: any recommendations? :)
11:32:21 <edwardk> Mike Johnson out at Macquarie has a lot of good work in that direction. http://comp.mq.edu.au/~mike/pub2000.html
11:32:26 <athan> I see FRP implementations like elm seem to be simple cps's implemented on a signal
11:32:29 <chrisdotcode> (ski: also, thanks for answering my question, even it was a while later!)
11:35:47 <pearson> Well, I tried some stuff, but nothing ghci suggested worked, so I skipped it.
11:36:00 <nadirs> pearson: it works if you do this `data Bool = False | True deriving (Eq, Ord)`
11:37:16 <pearson> nadirs: Does it work because not only did I need the type class for Ord, but also Equation? Isn't it the same?
11:38:00 <nadirs> pearson: Ord instances must also be Eq instances
11:38:05 <nadirs> pearson: http://hackage.haskell.org/package/base-4.6.0.1/docs/Prelude.html#t:Ord
11:39:24 <duairc> Is it possible to write a function ([a] -> b) -> b -> [a] -> b using foldr?
11:39:26 <athan> would any Group have _both_ divisibility and invertibility, or are they mutually exclusive? ie: Once you gain one, you don't automatically gain the other
11:39:56 * hackagebot intern 0.9.1.3 - Efficient hash-consing for arbitrary data types  http://hackage.haskell.org/package/intern-0.9.1.3 (EdwardKmett)
11:40:31 <pearson> nadirs: So Eq is the class, but the Ord is the specification?
11:41:21 <dario> Ord is another class
11:41:53 <nadirs> pearson: Eq and Ord are two type class, where Ord is a sub-set of Eq
11:42:04 <nadirs> *type classes
11:44:24 <athan> does a quasigroup need to have an operator of type a -> [a]?
11:46:50 <bulletbill22> I've got a simple question, I hoge someone here can help
11:47:04 <bulletbill22> I'm trying to make a list of natural numbers
11:47:21 <bulletbill22> the line I typed is naturals = [1..]
11:47:48 <bulletbill22> But that results in compile errors
11:47:54 <peteretep> what's the error you get?
11:47:55 <shachaf> In Haskell, you'll have a better time if you call 0 a natural number too.
11:48:07 <bulletbill22> PA5.hs:14:11:     No instance for (Enum ((a0 -> a0 -> a0) -> a1 -> Bool))       arising from the arithmetic sequence `1 .. '     Possible fix:       add an instance declaration for       (Enum ((a0 -> a0 -> a0) -> a1 -> Bool))     In the expression: [1 .. ]     In an equation for `oneList': oneList = [1 .. ]  PA5.hs:14:12:     No instance for (Num ((a0 -> a0 -> a0) -> a1 -> Bool))       arising from the literal `1'     Possible
11:48:19 <Iceland_jack> bulletbill22: If you're in GHCi you need to preface it with let
11:48:19 <Iceland_jack>     ghci> let naturals = [1..]
11:48:22 <shachaf> The error isn't where you think it is.
11:48:31 <shachaf> You should go to hpaste.org and paste your full code and full error message.
11:48:35 <ski> chrisdotcode : <http://www.haskell.org/ghc/docs/latest/html/libraries/base/src/GHC-Show.html>,<http://www.haskell.org/ghc/docs/latest/html/libraries/base/src/Text-Show.html>,<http://www.haskell.org/ghc/docs/latest/html/libraries/base/src/GHC-Read.html>
11:48:46 <ski> chrisdotcode : <http://www.haskell.org/ghc/docs/latest/html/libraries/base/src/Text-Read.html>,<http://www.haskell.org/ghc/docs/latest/html/libraries/base/src/Text-Read-Lex.html>,<http://www.haskell.org/ghc/docs/latest/html/libraries/base/src/Numeric.html>,<http://www.haskell.org/ghc/docs/latest/html/libraries/base/src/GHC-Real.html>,<http://www.haskell.org/ghc/docs/latest/html/libraries/base/src/GHC-Float.html>
11:49:01 <ski> athan : no ?
11:49:06 <chrisdotcode> ski: awesome, thanks :)
11:49:43 <ski> chrisdotcode : i might have missed some interesting modules .. i was mostly looking at Hugs library sources when i looked into this, years ago
11:50:06 <bulletbill22> http://lpaste.net/101862
11:50:09 <chrisdotcode> ski: well I never understood how to implement a show or read instance by hand anyway, so this is a great starting point for me :)
11:50:14 <bulletbill22> That's the link to my code and the error
11:50:29 <shachaf> Oh.
11:50:41 <shachaf> You don't write "let x = y" at the top level of a file.
11:50:59 <shachaf> You just write "x = y", like you did for the two functions.
11:51:25 <luvfp> if my record has a field called minimum and it clashes with the one in prelude, what should i do?
11:51:32 <shachaf> Hmm, but that would cause a different error. Are you sure that's your code?
11:52:03 <shachaf> luvfp: Rename it, or refer to it qualified, or hide the one from Prelude or the one from your module.
11:52:11 <merijn> luvfp: You can 1) rename the field 2) "import Prelude hiding (minimum)"
11:52:42 <shachaf> bulletbill22: If you give type signatures to everything your errors will be much easier to find (and your code much easier to read).
11:52:46 <luvfp> how do i refer to it qualified ? in a function i have f $ minimum p
11:53:14 <merijn> luvfp: Write "f $ MyModule.minimum p"
11:53:44 <bulletbill22> shachaf: I'll do that and let you know when I'm done
11:53:46 <shachaf> bulletbill22: I see multiple errors, such as "mod" instead of "`mod`" (it's not an infix operator) and using (/) instead of "div" ((/) doesn't do integer division).
11:54:13 <shachaf> But adding type signatures is polite if nothing else.
11:54:23 <shachaf> It helps everyone.
11:55:08 <ski> chrisdotcode : the main point to remember is that both `showsPrec' and `readsPrec' expects to get the current precedence level of the *context* of the expression (to be shown/read)
11:55:14 <luvfp> merijn: thanks.  that helped
11:55:50 <chrisdotcode> ski: that one went a little over my head...
11:57:46 <athan> isn't a function a functor?
11:57:53 <athan> because mapping is just application?
11:58:40 <athan> @src (->)
11:58:40 <lambdabot> Source not found. There are some things that I just don't know.
11:58:42 <athan> lol
11:59:16 <johnw> a function maps between values; a functor maps between types (a -> F a) and the functions that operate on them ((a -> b) -> (f a -> f b))
11:59:51 <johnw> (while also preserving composition and identity)
12:00:01 <johnw> and that's speaking in terms of Haskell
12:00:04 <athan> ahhh
12:00:09 <athan> yeah
12:00:46 <athan> ...can a functor be a functor through kinds?
12:00:56 <athan> functor of functors*
12:01:24 <johnw> what would that look like?
12:01:25 <athan> so the pattern is the same
12:01:36 <athan> but it's necessary to draw the line of "value"
12:01:46 <ski> chrisdotcode : since we have e.g. `infixl 7 %', this means that if the current precedence level is greater than `7', then that means that we *require* wrapping round brackets when showing/reading (in case it's not greater than `7', then for showing we don't wrap, and for reading we *allow* (an arbitrary amount of) wrapping)
12:02:11 <athan> class Category lol
12:02:46 <chrisdotcode> ski: okay, I get it enough to understand what you're saying :)
12:02:47 <ski> chrisdotcode : the "toplevel" precedence leve, which things start at is `0'. also, whenever we enter any pair of round brackets, we restore the precedence level (inside there) to `0'
12:02:57 <ski> > (readsPrec 0 :: ReadS (Ratio Integer)) "2 % 3"
12:02:58 <lambdabot>  [(2 % 3,"")]
12:03:02 <ski> > (readsPrec 7 :: ReadS (Ratio Integer)) "2 % 3"
12:03:03 <lambdabot>  [(2 % 3,"")]
12:03:06 <ski> > (readsPrec 8 :: ReadS (Ratio Integer)) "2 % 3"
12:03:07 <lambdabot>  []
12:03:35 <chrisdotcode> okay, I think I get it enough now to understand a general gist :)
12:03:38 <ski> note how the last one failed reading, since the current precedence level (`8') is greater than the precedence level of the operator (`%', which is `7')
12:03:41 <chrisdotcode> right
12:03:47 <ski> > (readsPrec 7 :: ReadS (Ratio Integer)) "(2 % 3)"
12:03:49 <lambdabot>  [(2 % 3,"")]
12:03:51 <ski> > (readsPrec 7 :: ReadS (Ratio Integer)) "((2 % 3))"
12:03:52 <lambdabot>  [(2 % 3,"")]
12:03:56 <ski> > (readsPrec 8 :: ReadS (Ratio Integer)) "(2 % 3)"
12:03:57 <lambdabot>  [(2 % 3,"")]
12:04:00 <ski> > (readsPrec 8 :: ReadS (Ratio Integer)) "((2 % 3))"
12:04:01 <lambdabot>  [(2 % 3,"")]
12:04:31 <chrisdotcode> ski: oh, okay, parens have the highest precedence, and therefore it shows them
12:04:34 <chrisdotcode> that makes sense
12:04:36 <bulletbill22> shachaf: Here's my new code: http://lpaste.net/101862. I'm not sure I did the type signatures correctly; filterAB takes a function which returns a bool and two lists and returns a list. collatzItem takes an int and returns an int. It's giving me a new error now, though
12:05:01 <a3gis> hi! could anyone enlighten me on the relation between logical implication and functions? They seem to behave in the same way (you can prove that (forall x. Fx -> P) is not equivalent to forall x. (Fx -> P) but (P -> forall x. Fx) is equivalent to forall x. (P -> Fx) etc. I guess there must be a strong relation between the two concepts but I cannot pin it down
12:05:14 <ski> > showsPrec 0 (2 % 3) ""
12:05:15 <lambdabot>  "2 % 3"
12:05:17 <ski> > showsPrec 7 (2 % 3) ""
12:05:18 <lambdabot>  "2 % 3"
12:05:18 <ski> > showsPrec 8 (2 % 3) ""
12:05:20 <lambdabot>  "(2 % 3)"
12:06:42 <yogert1> Using HXT how would I drop the nth child of an element? I've been trying to use some of the methods found in ArrowTree with no luck
12:06:49 <ski> chrisdotcode : now, if we have an `infix' operator (no left or right associativity), like e.g. `infix 6 :+', then, regardless of the current precedence level outside the operator node, the precedence level of the two subexpressions will be the precedence level of the operator, *plus* one
12:06:56 <athan> a3gis: Although I haven't read this book completely, check this out fldit-www.cs.uni-dortmund.de/~peter/PS07/HR.pdf‎
12:07:34 <a3gis> athan: 404?
12:07:43 <ski> chrisdotcode : while, strictly speaking, for an `infixl', the precedence level of the *left* subexpression would omit the "plus one" part, to not *require* brackets if the thing on the left has the same operator precedence
12:07:45 <yogert1> specifically, I'd like to drop the nth <td> from a <tr>
12:07:55 <jonkri> How can I install the dependencies of a Test-Suite using cabal-dev? Even if I do "cabal-dev build", "cabal-dev test" gives me a error about missing dependencies.
12:08:04 <chrisdotcode> ski: well that's a bit more than I need to know right (I don't grok haskell's AST yet), but thank you for telilng me :)
12:08:14 <ski> chrisdotcode : similarly, for `infixr', the precedence level on the *right* subexpression would omit the "plus one" part
12:08:55 <bulletbill22> Can anyone please tell me about the error in my code? It's a quick read, I promise! http://lpaste.net/101862
12:10:05 <ski> chrisdotcode : the point is : each current operator that is being shown/read will "tell" the showing/reading for the two subexpressions which precedence level the *current* operator has. that allows the (code for showing/reading the) subexpressions to decide on their own whether to show result wrapped in brackets / require input to be wrapped in brackets
12:10:11 <bsdbeard> How do I import the "minus" function? I've tried importing Data.List and Data.Ord but ghci doesn't see it :/
12:10:40 <ski> chrisdotcode : the `showParen' and `readParen' functions are convenience functions for handling the "maybe do brackets"
12:11:11 <chrisdotcode> ski: right. that makes perfect sense. thanks! :)
12:11:16 <yogert1> bulletbill22, might it be the top level let expression on line 10?
12:12:24 <bulletbill22> yogert1 Yeah that got me along. I tried adding type signatures but I think they made things wors
12:12:51 <yogert1> huh? well is that the cause of the parse error?
12:12:53 <a3gis> athan: ?
12:12:55 <ski> chrisdotcode : let's say we define `data Expr = Lit Integer | Expr :<+> Expr | Expr :<*> Expr | Expr :<^> Expr | Expr :<==> Expr'
12:13:36 <ski> chrisdotcode : and we do `infixl 6 +; infixl 7 *; infixr 8 ^; infix 4 =='
12:13:49 <ski> chrisdotcode : and now we want to implement `Show' and `Read' for this
12:13:50 <supki> jonkri: cabal-dev install --enable-tests --only-dependencies, I think
12:13:59 <chrisdotcode> ski: so it'll show based on precedence automatically?
12:14:02 <supki> jonkri: haven't used cabal-dev for a while though
12:14:22 <ski> chrisdotcode : if we use `deriving (Show,Read)', then yes -- but let's do it manually
12:14:23 <jonkri> Thanks, supki. :)
12:14:33 <ski> chrisdotcode : for `instance Show Expr' we define
12:15:15 <yogert1> bulletbill22: well one problem seems to be that you are returning a list in filterab while your type says otherwise
12:15:48 <ski>   showsPrec p (Lit n) = showParen (p > 10)
12:15:50 <athan> a3gis: Really? I just downloaded it...
12:15:52 <ski>                       $ showString "Lit "
12:15:54 <ski>                       . showsPrec 11 n
12:16:16 <a3gis> athan: http://www.cs.tu-dortmund.de/~peter/PS07/HR.pdf, right?
12:16:19 <athan> a3gis: it's called "The Haskell Road to Logic, Maths and Programming"
12:16:22 <ski> chrisdotcode : we use `10' here because the current precedence level is `10', because the "operator" is function application (in `Lit n')
12:16:26 <bulletbill22> yogert1 I don't really understand type signatures. The arrows are confusing. I wasn't even aware that there was a list type
12:16:28 <Aetherspawn> bulletbill22: you need type sigs
12:16:43 <chrisdotcode> ski: so show all the function applications, and then show everything else?
12:16:47 <athan> http://homepages.cwi.nl/~jve/HR/
12:16:48 <a3gis> athan: ooh well that's even easier, I have a paper version of it. Standing in my shelve since about a moth ^_^
12:16:49 <athan> oop ._.
12:16:54 <a3gis> athan: thanks!
12:16:56 <Aetherspawn> when an error like this happens GHC can't really give you anything sane because it has no idea what you wanted
12:16:59 <athan> I think I just pirated it... D:
12:16:59 <ski> chrisdotcode : and we use `11' (`10 + 1'), because function application is left associative, but this is the *right*, not the left part of the application, so we need to increment by one
12:17:08 <Aetherspawn> the errors will get better (with line and column numbers!) if you give it some typesigs
12:17:12 <athan> a3gis: RIGHT
12:17:14 <ski> chrisdotcode : e.g. `n' might be a negative integer, which needs the brackets
12:17:15 <bulletbill22> Aetherspawn I tried adding them but I don't get them. Every tutorial ever has been entirely too nondescript.
12:17:22 <athan> a3gis: my bookshelf needs a flush
12:17:22 <bulletbill22> I've sort of given up on it
12:17:29 <Aetherspawn> did you try http://learnyouahaskell.com ?
12:17:51 <chrisdotcode> ski: okay,, I sorta get it. but it's still above my head for now. but that's cool, because I don't need it at the moment
12:17:53 <Aetherspawn> types take a little while
12:18:01 <a3gis> athan: haha I get the feeling
12:18:01 <jonkri> Does anyone know how I can test zero-argument "Bool" test case functions with Tasty?
12:18:03 <Aetherspawn> took me a couple days to get comfortable
12:18:07 <chrisdotcode> I get enough of what you'd told me to understand my current problem, though
12:18:24 <bulletbill22> I'll take another look at it
12:18:28 <Aetherspawn> and even after you're comfortable, monad transformer stacks still screw my brain and don't even get me started on lens types.
12:18:37 <Aetherspawn> it's all a linear skill building exercise! :)
12:18:53 <ski>   showsPrec p (augend :<+> addend) = showParen (p > 6)
12:18:57 <ski>                                    $ showsPrec 6 augend
12:18:58 <yogert1> oo
12:19:04 <ski>                                    . showString " :<+> "
12:19:05 <yogert1> bulletbill22
12:19:05 <ski>                                    . showsPrec 7 addend
12:19:19 <bulletbill22> ?
12:19:33 <Aetherspawn> yogert1: wrong person, I believe.
12:19:47 <ski> chrisdotcode : here, the precedence of `:<+>' is `6', so that's what we use in `showParen', we use `6' for the left argument since the operator is left associative, but we need `7' for the right on
12:19:52 <yogert1> one problem is that in collatzItem, you seem to be hoping that it implicitly casts your Integral to Bool
12:20:01 <yogert1> you have
12:20:11 <yogert1> | k `mod` 2 = ...
12:20:13 <ski> chrisdotcode : for `:<*>' it's basically the same thing, except `7' and `8' as levels instead
12:20:19 <yogert1> but that needs to be a bool
12:20:23 <ski> then, we get
12:20:32 <ski>   showsPrec p (augend :<^> addend) = showParen (p > 8)
12:20:33 <bulletbill22> I see
12:20:37 <bulletbill22> I didn't realize this
12:20:45 <yogert1> you can't do if 0 then foo else bar
12:20:46 <ski>                                    $ showsPrec 9 base
12:20:50 <ski>                                    . showString " :<^> "
12:20:58 <ski>                                    . showsPrec 8 exponent
12:21:23 <ski> chrisdotcode : with `8' for the *right* operand, since the operator is *right* associative, and then `9' for the left
12:21:27 <ski> chrisdotcode : finally
12:22:05 <bulletbill22> Wow thanks yogert1
12:22:10 <bulletbill22> That got me much further
12:22:21 <ski>   showsPrec p (comparand0 :<==> comparand1) = showParen (p > 4)
12:22:24 <ski>                                             $ showsPrec 5 comparand0
12:22:36 <ski>                                             . showString " :<==> "
12:22:37 <Aune> I'm using Data.Array.IArray to do some stuff. How do I best handle out of bounds error? Is there a way to convert that to a Nothing or similar?
12:22:41 <ski>                                             . showsPrec 5 comparand1
12:22:58 <yogert1> bulletbill22, Well that seemed to fix it for me
12:23:08 <ski> chrisdotcode : incrementing both precedence levels, since the operator is neither left- nor right- associative
12:23:32 <bulletbill22> Now there's some issue I don't think is a haskell thing, but maybe someone here has encountered it before. http://lpaste.net/101862
12:23:34 <ski> chrisdotcode : for reading, it's basically the same thing, with `readParen', except it's a little bit more complicated, due to parsing being more complicated
12:23:35 <yogert1> Along with removing the "let"
12:24:51 <yogert1> err, I'm not sure. What flags are you passing to the compiler?
12:25:42 <bulletbill22> None. My command is "ghc pa5_test.hs", which is a testing program my professor designed to test this homework
12:27:00 <yogert1> Hmm, I'm not sure whats going on, maybe i'd have to see pa5_test...
12:27:03 <shachaf> bulletbill22: That is not an error with your Haskell code.
12:27:30 <shachaf> bulletbill22: Are you using gold (the linker)?
12:27:34 <shachaf> This looks like https://ghc.haskell.org/trac/ghc/ticket/7201
12:27:46 <shachaf> Or rather https://ghc.haskell.org/trac/ghc/ticket/6063
12:28:10 <bulletbill22> Do you think I should install an older ghc package?
12:28:41 <shachaf> You could install the usual linker instead of gold, or you could look through the bug, I think maybe there's a workaround.
12:28:57 <klrr_somewhere> okey , i asked this earlier but i will ask again. What is the easiest way to use haskell in android dev? is it to use the FFI to the android C api or can i somehow use webview to make UI using html/css/js in hope of it being easier?
12:29:10 <jonkri> Got it. assertBool :)
12:35:50 <bulletbill22> shachaf yogert1 I just switched to hugs
12:35:53 <bulletbill22> that made it work
12:35:58 <bulletbill22> Thanks to both of you
12:36:26 <shachaf> I recommend not using hugs.
12:36:48 <shachaf> It is very old and GHC is much better for nearly anything you might want to do.
12:37:03 <shachaf> So making GHC work is probably worth it.
12:37:24 <bulletbill22> I'll ask my professor about that error. Hopefully it is reproducable on my laptop
12:37:43 <bulletbill22> I'll see about switching back to ghc if I can make it work
12:37:50 <bulletbill22> Thanks for the advice
12:38:38 <yogert1> Thats strange, i've nver seen tht before
13:05:24 <hcaulfield57> I'm working on the Write Yourself a Scheme Project, but I'm stuck on one of the exercises. You need to provide a way to parse escaped characters, as in '\n', but I'm stuck trying to figure it out, this is what I have. http://lpaste.net/101869
13:08:17 <SwashBuckla> hcaulfield57: I think this could be the problem: \n is not a char AFAIK. You may need to consume '\' and then lookahead for 'n'
13:08:18 <tdammers> hcaulfield57: Char and String are not the same type
13:08:43 <tdammers> at the lowest level, you need a parser that consumes one or two chars, and returns one char
13:09:33 <tdammers> split that up into two alternative parsers: one that consumes a backslash and one other character and returns a Char, and a second one that just consumes a character and returns it as-is
13:11:11 <hcaulfield57> tdammers: Okay, lemme see if I can give it a shot
13:16:39 <cdk_> I have a type family F x where F (F (F x)) ~ x, how can I convince GHC of this. I'm getting a type check error when GHC can't unify F (F (F x)) with x.
13:17:20 <hcaulfield57> Okay, this is what I have now, but I'm not sure it's working properly: http://lpaste.net/101869
13:17:25 <shachaf> What is the definition of F?
13:18:19 <cdk_> shachaf: using DataKinds: data Axis = X | Y | Z; type family Rot a where Rot X = Y; Rot Y = Z; Rot Z = X
13:18:39 <cdk_> I want a type level function that cycles through {X, Y, Z}
13:19:01 <dmwit_> hcaulfield57: Looks pretty good to me. One comment is that do { x <- foo; return x } is the same as do { foo }. (It's one of the monad laws!)
13:19:06 <cdk_> so clearly, Rot (Rot (Rot X)) ~ X, but GHC can't figure that out
13:20:15 <hcaulfield57> dmwit_: Right, and it takes input, it compiles, but if I do something like "hello\\" it doesn't show the '\'
13:20:43 <dmwit> Note that the Haskell source "hello\\" produces a string with only one backslash character in it.
13:20:51 <dmwit> Perhaps you want the Haskell source "hello\\\\" instead.
13:22:30 <dmwit> Perhaps it's better to ask what *exactly* you're trying, rather than try to make a guess.
13:22:48 <dmwit> "something like" isn't precise enough to know with this stuff where there's escaping at multiple levels.
13:23:11 <hcaulfield57> dmwit: I'm trying to have it print "hello\", so I enter in "hello\\", but it only prints "hello"
13:23:30 <dmwit> cdk_: You could put F (F (F x)) ~ x in your context. This will be true once the function is monomorphed to a particular value of x.
13:23:31 <shachaf> cdk_: What about F GHC.Exts.Any?
13:23:35 <hcaulfield57> This is for Write yourself a scheme
13:23:39 <shachaf> (Surprise!)
13:23:55 <dmwit> hcaulfield57: What does "I enter in" mean?
13:24:15 <dmwit> hcaulfield57: Can you give me a minimal, complete working example, including exactly what I should type at my terminal/in ghci to see the behavior you're seeing?
13:24:49 <hcaulfield57> dmwit: I'll just post the whole example, I'm running it through main, as in ./program "Hello\\"
13:24:51 <gdoteof> line #29 http://lpaste.net/101875  just trying to print the whole body request
13:24:55 <dmwit> Ugh, Any spoils everything.
13:25:16 <gdoteof> tryingt o parse a form field that is sort of a black box.  i am getting     Couldn't match expected type `IO' with actual type `ResourceT IO'
13:25:33 <hcaulfield57> http://lpaste.net/101869
13:25:33 <cdk_> shachaf: what happens with Any? My assumption Rot (Rot (Rot x)) ~ x doesn't hold?
13:28:01 <dmwit> cdk_: Correct. Rot Any doesn't reduce, so Rot (Rot (Rot Any)) doesn't reduce.
13:29:29 <dmwit> But I think that might be a red herring?
13:29:35 <triliyn> gdoteof: it sounds like your pipe expression there is already in the transformed monad, so you don't need the liftIO
13:29:35 <cdk_> hmm, what if the type x is monomorphic? Could I get it to unify then? Let me post an example
13:29:38 <dmwit> Since you could add a case for that.
13:29:54 <dmwit> cdk_: Yes, you can. That's why I suggested what I did. =)
13:30:31 <gdoteof> triliyn: this changes it to  Couldn't match expected type `Data.Void.Void'
13:30:31 <gdoteof>                 with actual type `IO ()'
13:32:03 <triliyn> hmmm, on the same line?
13:32:35 <gdoteof> triliyn: same line.  but on putStrLn instead of requestBody
13:34:45 <triliyn> hmmm, I'd love to try to figure this out but unfortunately I must leave
13:35:10 <gdoteof> http://lpaste.net/101875  annotation #2
13:35:31 <Aune> Is there a Type Class for "Cyclic" types. Meaning cyclic in the sense that the integer modulo seven are cyclic: [5 .. 3] = [5, 6, 0, 1, 2, 3]?
13:35:52 <jle`> Aune: what kind of functions would that typeclass define?
13:36:41 <Aune> jle`, some form of enumFromTo that "wraps around"
13:38:49 <Aune> such that if I defined a data type for the twelve hour clock I can always enumerate the time in a "forward" fashion
13:40:07 <jle`> what would stop you from just instancing an Enum for that type to be cyclic?
13:40:18 <jle`> does it break Enum specs/semantics/laws?
13:40:20 <jle`> hm...
13:42:16 <Aune> Dont know, I was just wondering if there was a standard one. When looking for lists of common type classes I can only find the predefined: http://en.wikibooks.org/wiki/Haskell/Classes_and_types#Standard_classes
13:42:36 <Aune> But I'm quite sure that there are more than those in common use in the community
13:43:26 <Aune> But being somewhat of a beginner I dont even know where to look for common type classes
13:43:49 <jle`> there's the typeclassopedia
13:45:09 <gdoteof> still stuck on http://lpaste.net/101875  trying to just inspect a Bytestring conduit source from network.wai
13:45:21 <hcaulfield57> Why does this never terminate, (its short) http://lpaste.net/101884
13:45:22 <gdoteof> literally all i want to do is print the requestbody
13:45:43 <gdoteof> but network.wai gives requestbody as a conduit
13:46:12 <gdoteof> so..i am trying to convert convert each bytestring toa  string and then print it out.  broken magic is #30
13:46:37 <Aune> jle`, true, and it is a great complement. But there ought to be more Type Classes still I think.
13:46:50 <jle`> hcaulfield57: um
13:47:12 <jle`> (tell (Sum 1) >> return x)) always returns Sum 1
13:47:33 <jle`> listen $ that, at least
13:47:36 <prooftechnique> gdoteof: Are you getting an error message?
13:47:49 <jle`> listen executes the given Writer thing on its own, isolated
13:47:52 <prooftechnique> Also, does changing putStrLn $ show to print help?
13:47:53 <gdoteof> prooftechnique: yeah if you look at that lpaste i embedded the errors in the annotations
13:47:59 <hcaulfield57> jle` Ah, okay
13:48:00 <jle`> wait, does it? >.>
13:48:00 <prooftechnique> Ah, okay
13:48:02 <jle`> let me check
13:48:21 <hcaulfield57> jle`: Yea, it seems like it should work to me, but I'm a beginner
13:48:23 <luvfp> http://lpaste.net/101885
13:48:49 <luvfp> what am i missing here? how can the example from the wiki book work but not mine with almost the same use case?
13:49:26 <jle`> Aune: new typeclasses are usually considered a layer of complexity that is best avoided if possible
13:49:29 <prooftechnique> luvfp: What's your error?
13:49:38 <jle`> Aune: so usually a design goal is to limit the amount of typeclasses you have
13:50:14 <johnw> jle`++
13:51:26 <luvfp> prooftechnique:  i added the error message to the link
13:51:28 <athan> does it make the container datatypes low-level have more general, and ambiguous wrappers? Possibly requiring runtime heap allocation for the varying container?
13:52:06 <zerokarmaleft> any recommended default GHC option flags besides -Wall?
13:52:13 <jle`> hcaulfield57: actually i think i was wrong
13:52:41 <Aune> jle`, Ok. Though it is nice to have sometimes. And a cyclic data type seems so standard to me. All modular arithmetic fits so well.
13:52:42 <luvfp> prooftechnique:  http://lpaste.net/101886
13:52:44 <hcaulfield57> jle`: That's okay, do you have any idea why it never terminates then?
13:52:46 <prooftechnique> gdoteof: Maybe try mapM_
13:53:09 <Aune> jle`, any good read on why excessive Type Classes are bad?
13:53:41 <prooftechnique> gdoteof: Specifically, CL.mapM_ putStrLn
13:53:48 <jle`> Aune: not specifically that i can think of, but here is an interesting article on a related subject http://www.haskellforall.com/2012/05/scrap-your-type-classes.html
13:54:24 <jle`> it drops in mentions of why typeclasses are needlessly complex in certain situations
13:54:37 <gdoteof> prooftechnique: i have tried that. the error gets more specific     Couldn't match expected type `IO' with actual type `ResourceT IO'
13:56:10 <johnw> gdoteof: you need to use runResourceT at some point
13:56:22 <gdoteof> http://lpaste.net/101887
13:56:38 <johnw> yes, a requestBody carries a resource
13:56:47 <johnw> liftIO $ runResourceT $ requestBody req $$ CL.mapM_ print
13:56:56 <prooftechnique> gdoteof: Okay, so that means you have to runResourceT
13:57:11 <johnw> wait
13:57:13 <prooftechnique> What johnw said
13:57:22 <johnw> even better: liftResourceT $ requestBody req $$ CL.mapM_ print
13:57:39 <prooftechnique> Ah, yeah, that is better
13:57:55 <johnw> I think that runResourceT is emphatically wrong, since it will end up trying to free the resource twice
13:59:38 <gdoteof> johnw: hmm thanks.  liftResourceT not in scope nor exported by data.conduit
13:59:49 <johnw> import Control.Monad.Trans.Resource
13:59:50 <prooftechnique> luvfp: I guess you could try adding an explicit signature to (r,g)
14:00:09 <supki> hcaulfield57: c is always 1
14:00:20 <Aune> jle`, that is a nice read. Thanks
14:00:48 <supki> > runWriter $ do tell "foo"; (_, w) <- listen (tell "bar"); (_, w') <- listen (tell "baz"); return (w, w')
14:00:49 <lambdabot>  (("bar","baz"),"foobarbaz")
14:00:53 <supki> hcaulfield57: ^
14:01:32 <hcaulfield57> supki: Okay, so it takes place in a different Writer?
14:01:48 <gdoteof> johnw: surprisingly, exact same error.
14:01:56 <johnw> who
14:01:58 <johnw> whoa
14:02:18 <johnw> it's there: http://hackage.haskell.org/package/resourcet-0.4.10.1/docs/Control-Monad-Trans-Resource.html
14:02:29 <supki> hcaulfield57: sure, it's isolated
14:02:40 <hcaulfield57> supki: Okay, thank you
14:03:13 <gdoteof> http://lpaste.net/101887  first annotation
14:03:28 <gdoteof> johnw: er, sorry.  it imported fine, the original error is the same
14:03:33 <gdoteof> type mismatch
14:03:34 <johnw> oh!
14:03:43 <gdoteof> i put error in annotation #2 ^
14:03:53 <johnw> ahh
14:03:57 <johnw> CL.mapM_ (liftIO . print)
14:04:08 <johnw> you don't need liftResourceT at all then
14:04:14 <johnw> sorry, I misread the problem
14:04:30 <johnw> an Application already provides a MonadResource environment
14:04:40 <gdoteof> !!  yup.  thanks.  i was trying to put that liftIO everywhere
14:04:45 <gdoteof> totally did it.. tyvm
14:05:09 <luvfp> prooftechnique:  (r::Int, g) did not help
14:05:27 <prooftechnique> Sorry, I meant for the right hand side
14:06:21 <prooftechnique> As in to the right of the equals sign
14:11:41 <thebnq> getting "You are using a new version of LLVM ..." how do i find what has been tested up to?
14:12:58 <prooftechnique> luvfp: What about  (r, g)         = random g :: (Int, StdGen)
14:14:10 <luvfp> prooftechnique:  No instance for (RandomGen (Int, StdGen))
14:14:31 <prooftechnique> luvfp: Or, for that matter, (r,g) = randomR (1,100) g :: (Int, StdGen)
14:14:50 <prooftechnique> Huh? It typechecks for me
14:15:05 <luvfp> prooftechnique:  this is what i have (r::Int, g)         = randomR (0, 100) ( g:: (Int,  StdGen ) )
14:15:36 <prooftechnique> Not really what I meant. Get rid of the annotation on the left hand side
14:15:50 <prooftechnique> The annotation on the right hand side is for the whole expression, not for g
14:15:59 <prooftechnique> So remove those parentheses
14:16:55 <luvfp> prooftechnique: (r, g)         = randomR (0, 100) g:: (Int,  StdGen )  this does not give an error but does not print anything either .. thanks for the help so far.
14:17:00 <prooftechnique> Also, I'm pretty sure all this does is print 10
14:17:13 <luvfp> i will try to understand this this.
14:17:30 <prooftechnique> luvfp: You have let result = 10 in result
14:17:31 <luvfp> yeah i changed it to evaluate to r instead .
14:17:36 <prooftechnique> Ah, okay
14:17:49 <luvfp> i had put in 10 for debugging
14:18:55 <luvfp> its weird, i t just hangs if i try to print r
14:19:15 <luvfp> but it prints 10 when the let .. in is result = 10
14:21:36 <skypers> why orphan instances are considered as a warning?
14:21:43 <skypers> because they can clash with each other?
14:22:27 <prooftechnique> skypers: Yeah, pretty much
14:22:46 <prooftechnique> They're fine in application code, but in library code they're a pretty serious don't
14:22:56 <skypers> arf, so I can’t really make (Num a) => (a,a) instance of Num
14:23:13 <skypers> ok prooftechnique, I see why
14:29:17 <prooftechnique> luvfp: It's because you used getStdGen
14:29:31 <prooftechnique> So you introduced IO into the computation but didn't carry it all throughout
14:29:49 <prooftechnique> For instance, replace g = getStdGen with g = mkStdGen 20 or something
14:33:39 <luvfp> prooftechnique:  same behavior with mkStdGen
14:34:53 <prooftechnique> luvfp: Try this http://lpaste.net/101892
14:36:15 <prooftechnique> luvfp: Because you were using getStdGen, you introduced IO, and you can't just print arbitrary IO (since that's meaningless)
14:37:26 <luvfp> prooftechnique: that worked, but now my gen function is also in in the IO Monad isn't it? I was hoping I could keep it out
14:37:27 <nbl_> Hey =)
14:37:50 <luvfp> and explicitly pass in the Random Generator that is needed
14:38:01 <acowley> I really, really wish 7.8 was out
14:38:03 <luvfp> but that probably wont ever work
14:38:18 <luvfp> becasue when i get a StdGen in main it is already IO StdGen
14:38:43 <monochrom> luvfp, you can. getting g from getStdGen requires IO. after that, pass g to pure functions
14:38:53 <monochrom> in fact I recomment newStdGen over getStdGen
14:39:38 <luvfp> monochrom: thats what I was trying, but  when i do runhaskell gRNS.hs it just hangs
14:39:55 <monochrom> ok, that depends on what other things you do
14:43:19 <luvfp> monochrom: plese see http://lpaste.net/101893
14:44:18 <monochrom> it's "g <- newStdGen"
14:44:50 <luvfp> even inside a let ?
14:45:00 <erisco> which package is there for generate Haskell source? preferably by constructing a syntax tree
14:45:01 <monochrom> no, take it outside
14:45:25 <prooftechnique> luvfp: Like this: http://lpaste.net/101894
14:45:48 <monochrom> (r,g) = blahblah g is an obvious infinite loop. clearly you must name the variables differently.
14:46:10 <monochrom> or rather, name the constants differently. they're all constants.
14:46:44 <beaky> hello
14:46:55 <luvfp> holy cow,
14:47:04 <beaky> in what ways is church encoding better than using data
14:47:04 <luvfp> monochrom: that was the reason for the hang., it should be g1
14:47:08 <luvfp> thanks alot!
14:47:10 <monochrom> ok good
14:47:18 <beaky> or is data a form of church encoding
14:47:31 <luvfp> prooftechnique: thank you too
14:47:40 <prooftechnique> No worries
14:47:40 <monochrom> beaky, is that question important?
14:48:15 <Mie9> hello, how do you call "data Foo = Bar | Baz" type scientifically?
14:48:34 <monochrom> typus summus  <duck>
14:48:36 <beaky> Mie9: sum type
14:48:56 <beaky> http://en.wikipedia.org/wiki/Tagged_union
14:49:14 <erisco> or a variant type
14:49:30 <Mie9> ok, and how do you call Bar and Baz parts of sum type?
14:49:57 <beaky> I call them cases
14:50:02 <`^_^v> constructors
14:50:29 <Mie9> is there scientific names for them? is it type invariants?
14:50:48 <`^_^v> haskell isnt a science
14:50:51 <MagneticDuck> uhm, hoogle says there is no function of type (Maybe a, Maybe b) -> Maybe (a, b) in all its packages
14:50:53 <`^_^v> they are called type constructors
14:50:55 <MagneticDuck> lols "scientific name"
14:50:58 <beaky> I guess variants are a scientific name for them too
14:51:03 <MagneticDuck> =P
14:51:13 <MagneticDuck> mathematicians invent all kinds of words
14:51:17 <MagneticDuck> just.. pick a few
14:51:21 <MagneticDuck> :D
14:51:26 <MagneticDuck> I learned that a while back
14:51:45 <monochrom> I think scientific name means latin name
14:51:46 <prooftechnique> @hoogle (m a, m b) -> m (a, b)
14:51:46 <lambdabot> No results found
14:51:47 <MagneticDuck> anyway, what's a cool fast way of getting to a function like that?
14:52:05 <Mie9> how product type constructed in haskell?
14:52:11 <Mie9> (A,B)
14:52:14 <Mie9> ?
14:52:17 <MagneticDuck> that's a tuple
14:52:20 <prooftechnique> Mie9: data T = T Int String
14:52:28 <MagneticDuck> data Tuple a b = Tuple a b
14:52:45 <MagneticDuck> (a, b) means "Tuple a b" both at the value level and at the type level
14:52:49 <Mie9> MagneticDuck: no, uppercase, look
14:52:55 <MagneticDuck> uhm
14:52:56 <Mie9> it's a type
14:52:59 <MagneticDuck> yes I know
14:53:15 <MagneticDuck> :type (1, 2)
14:53:21 <MagneticDuck> @type (1, 2)
14:53:21 <prooftechnique> Mie9: a and b are type variables
14:53:22 <lambdabot> (Num t, Num t1) => (t, t1)
14:53:53 <Mie9> "data Foo = Foo { fooBar :: Int }" is it a product type?
14:54:21 <MagneticDuck> prooftechnique: anyway, any ideas on what I could use for a function of type (Monad m) => (m a, m b) -> m (a, b)?
14:54:26 <erisco> well, uncurry (<|>) was a first thought but that is not quite right
14:54:26 <MagneticDuck> it's... kind of necessary
14:54:50 <MagneticDuck> @type <|>
14:54:51 <lambdabot> parse error on input `<|>'
14:54:57 <MagneticDuck> @type (<|>)
14:54:57 <lambdabot> Alternative f => f a -> f a -> f a
14:55:06 <Mie9> ?
14:55:20 * hackagebot quadratic-irrational 0.0.4 - An implementation of quadratic irrationals  http://hackage.haskell.org/package/quadratic-irrational-0.0.4 (ion)
14:55:36 <MagneticDuck> Mie9: we're doin' haskel
14:55:46 <MagneticDuck> =P
14:55:51 <prooftechnique> MagneticDuck: uncurry (liftM2 (,))
14:55:57 <MagneticDuck> beautiful
14:55:58 <prooftechnique> :t uncurry (liftM2 (,))
14:55:58 <lambdabot> Monad m => (m a1, m a2) -> m (a1, a2)
14:56:03 <erisco> ah got it
14:56:11 <erisco> :t uncurry (liftA2 (,))
14:56:12 <lambdabot> Applicative f => (f a, f b) -> f (a, b)
14:56:18 <prooftechnique> That also works
14:56:20 <Mie9> :t fmap . fmap
14:56:21 <lambdabot> (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
14:56:25 <erisco> prooftechnique, beat me to it :D
14:56:26 <Mie9> :t fmap . fmap . fmap
14:56:27 <lambdabot> (Functor f, Functor f1, Functor f2) => (a -> b) -> f (f1 (f2 a)) -> f (f1 (f2 b))
14:56:38 <prooftechnique> :t ((.) . (.))
14:56:38 <lambdabot> (b -> c) -> (a -> a1 -> b) -> a -> a1 -> c
14:57:04 <Mie9> :t fmap . (***) . fmap . (***)
14:57:04 <lambdabot> (Functor f, Functor f1, Arrow a) => a b c -> f (b' -> c') -> f ((f1 (a b'1 c'1), b') -> (f1 (a (b, b'1) (c, c'1)), c'))
14:57:10 <Mie9> prooftechnique: pathetic
14:58:03 <Mie9> so what kind of type scientifically speaking records in haskell are?
14:58:11 <MagneticDuck> uhm, are you the guy who was just confused by the type :: (a, b) ?
14:58:27 <MP2E> lololol
14:58:27 <MagneticDuck> Mie9: they're just... tuples
14:58:48 <MagneticDuck> with built-in accessors
14:58:53 <prooftechnique> MagneticDuck: The fact that I came up with that almost without thinking makes me think I'm starting to get Haskell :D
14:59:03 <MagneticDuck> lols
14:59:06 <MagneticDuck> I'm still not there
14:59:09 <MagneticDuck> :<
14:59:19 <MagneticDuck> I have to hone my haskell skills with a bit of lens-fu
14:59:23 <MagneticDuck> but there's so much useful stuff to do
14:59:28 <MagneticDuck> :D
14:59:28 <prooftechnique> Mie9: To answer your question, they're essentially product types
14:59:36 <prooftechnique> With some extra convenience
14:59:40 <Mie9> prooftechnique: yeah, i thought so, thanks
14:59:47 <MagneticDuck> tuples are product types
14:59:50 <prooftechnique> Right
14:59:53 <MagneticDuck> except, kind of
15:00:02 <MagneticDuck> well yeah
15:00:25 <MagneticDuck> technically a two-tuple represents a *product type*
15:00:35 <MagneticDuck> but I don't think it matters
15:00:37 <MagneticDuck> ....
15:01:08 <erisco> is there a package to construct haskell syntax trees?
15:01:33 <prooftechnique> @hackage haskell-src
15:01:33 <lambdabot> http://hackage.haskell.org/package/haskell-src
15:01:37 <prooftechnique> erisco: ^
15:02:01 <prooftechnique> And also
15:02:08 <prooftechnique> @hackage haskell-src-exts
15:02:08 <lambdabot> http://hackage.haskell.org/package/haskell-src-exts
15:02:15 <erisco> ah thank-you. I am converting HTML templates to Haskell source that includes reactive-banana data bindings
15:02:51 <prooftechnique> Neato
15:03:03 <erisco> I think so :D nothing like it really exists
15:03:05 <nisstyre> erisco: still not as good as sxml
15:03:27 <nisstyre> or xexprs, or whatever you wanna call em
15:03:35 <erisco> wait, what? how is that related?
15:03:45 <nisstyre> erisco: you can do html templating with that?
15:03:49 <nisstyre> i.e. quote/unquote
15:04:43 <erisco> well I suppose but why would you want to?
15:05:09 <nisstyre> erisco: because it's nicer than rolling your own template language, at least imo
15:05:18 <nisstyre> you get the full expressiveness of macros
15:05:22 <erisco> but... I don't have a template language
15:05:34 <nisstyre> oh, I thought you were converting from a template language
15:05:57 <nisstyre> erisco: I would still be interested in using template haskell maybe
15:06:03 <nisstyre> not sure how that would fare
15:06:11 <erisco> other than parsing HTML, the only "language" are placeholder variables of form '$[a-zA-Z]+' that can occur in an element position or attribute value position
15:06:37 <nisstyre> erisco: so substitution basically
15:06:59 <erisco> sort of. they are placeholders for data binding. for that facility I am using reactive-banana
15:07:43 <erisco> templating languages and compilers are typically setup such that all the variables are known ahead of time ... well that is not what I want :)
15:08:02 <erisco> angular-js is the closest I can find
15:08:04 <nisstyre> erisco: sounds like PHP
15:08:10 <erisco> not remotely close :P
15:08:23 <nisstyre> well, just from the "variables are known ahead of time" thing
15:08:25 <nisstyre> they're not in PHP
15:08:27 <prooftechnique> A NQIT compiler
15:08:33 <ski> MagneticDuck : tuple *types* are product types
15:08:36 <prooftechnique> "Not Quite In Time"
15:08:53 <nisstyre> prooftechnique: CLC, chronically late compiler
15:08:58 <prooftechnique> hahaha
15:09:03 <Ankhers> What is the simplest way to profile a simple Haskell program?
15:09:06 <erisco> I mean the compile function typically looks like  compileTpl :: Context -> Template -> String  where the Context is a map of all free variables in the template to their values
15:09:20 <erisco> after the String is obtained, that's it, you cannot change anything without recompiling the entire template
15:09:33 * ski . o O ( "Sufficiently Late Compiler" )
15:09:44 <erisco> this is lousy if you are building a GUI, where small things can change frequently
15:10:00 <nisstyre> Ankhers: time runghc foo.hs
15:10:17 <prooftechnique> nisstyre: The mathematician's answer
15:10:49 <erisco> so instead, my Context is a mapping of free variables to (IsNode n) => Behavior t (Maybe n)
15:11:16 <ski> erisco : for all `n' and `t' ?
15:11:21 <Ankhers> nisstyre: That works, thanks!
15:11:30 <erisco> ski, yes
15:12:12 <ski> erisco : have you looked into adaptive/incremental computation ?
15:12:12 <levi> Ankhers: If you need something a bit more precise, Criterion is not too difficult to set up.
15:12:51 <erisco> ski, and instead of returning String it returns [Node], which are the top-level nodes. at that point the dom elements are already 'wired up' to listen to changes in the Behaviors, so you can then append the node list to your document and away you go :)
15:13:30 <prooftechnique> Ankhers: The more complex way is here https://www.haskell.org/ghc/docs/7.6.3/html/users_guide/profiling.html
15:13:39 <erisco> ski, a little bit but it is not important just for data bindings
15:14:13 <levi> erisco: What you're saying reminds me of a combination of compiled heist and Facebook's react library.
15:14:25 <Flonk> How do I convert a Fractional to an Integral? floor, ceil etc. only work on RealFrac's
15:14:55 <ski> erisco : your templates are just structures with holes in them ?
15:15:02 <erisco> levi, *shrug* I dunno, I have not seen either of those. I did have a long look through many templating libraries available for javascript to no avail
15:15:12 <erisco> other than angular-js, but you buy into their whole setup by using it
15:15:47 <erisco> ski, you might look at it that way. there are no loops or branches or any control logic whatever because it is unnecessary
15:15:56 <prooftechnique> Flonk: Try floor . toIntegral
15:16:16 <prooftechnique> Wait, actually, what are you doing?
15:16:27 <prooftechnique> And I actually mean "fromIntegral"
15:16:32 <Flonk> There is toIntegral?
15:16:32 <prooftechnique> Because my brain is backward
15:16:33 <Flonk> Oh
15:16:51 <ski> erisco : .. and no computation whatsoever on the things plugged into the holes, i assume. just distribution of them to all the occurrences of each hole
15:17:12 <Flonk> prooftechnique: multiplying by a fractional (1.15, its literal), and needing the result as an int
15:17:18 <Flonk> *Integer
15:17:49 <ski> @type floor
15:17:50 <lambdabot> (Integral b, RealFrac a) => a -> b
15:17:52 <ski> @type ceiling
15:17:52 <lambdabot> (Integral b, RealFrac a) => a -> b
15:17:54 <ski> @type round
15:17:55 <lambdabot> (Integral b, RealFrac a) => a -> b
15:17:56 <ski> @type truncate
15:17:57 <lambdabot> (Integral b, RealFrac a) => a -> b
15:17:57 <prooftechnique> > floor (1.15 * 40)
15:17:58 <lambdabot>  46
15:18:04 <ski> Flonk ^
15:18:12 <ski> take your pick
15:18:22 <erisco> ski, the position that the variable occurs in determines the type of data binding
15:18:28 <levi> erisco: Well, compiled heist is a Haskell library that was developed for the Snap framework, so you'd need a haskell->js compiler to use it. But you might want to take a look at it.
15:18:30 <Flonk> ski: Fractional is not a RealFrac though, is it?
15:18:43 <erisco> levi, well I am using ghcjs
15:19:04 <prooftechnique> Flonk: RealFracs are Fractionals
15:19:14 <prooftechnique> class (Real a, Fractional a) => RealFrac a
15:19:44 <ski> Flonk : `RealFrac' is a subclass of `Fractional'
15:19:58 <Flonk> Hah oh man, it's going to take a while until I've memorized all this
15:20:05 <erisco> levi, I may at some point but at this time I already know what I have works well. I just have to write a new backend to generate Haskell + reactive-banana
15:20:06 <Flonk> ski, prooftechnique: Thanks for the help!
15:20:13 * ski hasn't memorized those classes
15:20:18 <prooftechnique> Flonk: I wouldn't worry too much about memorizing
15:20:24 <prooftechnique> Just make the types match and you'll be fine
15:20:57 <Flonk> prooftechnique: Well, its often not that easy with numbers in Haskell
15:20:59 <prooftechnique> Flonk: When in doubt, use :info in ghci
15:22:49 <erisco> ski, the reason logic is not needed in the template is because that logic can be removed to the application of the templates themselves
15:24:01 <erisco> ski, so for example, where there would typically be an if/else in the template, I would intead have two templates (one for each condition)
15:24:25 <Cale> I'm highlighted, was someone looking for me?
15:24:36 <Cale> (don't have enough scrollback to see)
15:25:19 <erisco> ski, and the parent template (that contains the free variable where the conditional template should go), will be constructed with a (IsNode n) => Behavior t (Maybe n), and the Behavior has the logic of the branch
15:25:30 <bulletbill22> I'm building a module for a class which calculates the median of a list, which is input one element at a time. Right now I've got an error that looks like my formatting might not be right, but I'm unsure. Here's my code (it's short): http://lpaste.net/101862. If someone can help that'd be great.
15:25:55 <ski> <merijn> @quote conveniently.gloss
15:25:58 <ski> <lambdabot> cjeris says: Cale: I like how you conveniently gloss over the part where your head explodes.
15:26:33 <beaky> hello
15:26:34 <ski> Cale : 06:36 ago
15:26:46 <prooftechnique> bulletbill22: That where block in sorted_median looks wrong
15:26:50 <Cale> ah, okay
15:26:55 <Cale> thanks ski!
15:26:58 <ski> np
15:27:40 <ski> erisco : mhm
15:28:17 <beaky> how does destructive update mesh with funcitonal programming? e.g. if I want to update a record in a database, I guess its impractical to make a copy of the entire database with the old field replaced by the new one
15:28:49 <erisco> so the only purpose of the template compiler is because constructing dom trees in Haskell plus wiring the data bindings is much more obscure than writing HTML with $variables
15:29:21 <ski> beaky : you'd share most, i think
15:29:48 <ski> beaky : tagging stuff with dates, so that given any date, you can determine the state of the DB at that time, e.g.
15:30:03 <prooftechnique> bulletbill22: Also, explicit type signatures would likely help you spot the errors
15:30:40 <bulletbill22> Type signatures are difficult for me to understand, I don't know how to compose them correctly.
15:30:53 <beaky> ski: so the old record is there, and the new one is simply appended to the database in a way that causes links to the old to refer to the new?
15:31:01 <bulletbill22> I'm trying to follow here http://www.haskell.org/haskellwiki/Let_vs._Where under section 4
15:31:22 <bulletbill22> But I get errors if I format my where like that
15:31:24 <ski> erisco : also, if you know you have the unique reference to some datum, then when constructing some new datum, possibly based on the old, and not having any longer a reference to the old datum, the system can make the optimization of reusing the same memory area, updating-in-place
15:31:29 <ski> er
15:31:32 <beaky> wow how do i implement such a persistent data structure
15:31:33 <ski> beaky ^
15:31:52 <ski> beaky : Clean and Mercury does that, based on uniqueness types/modes
15:31:53 <levi> bulletbill22: Maybe if you can explain the problems you're having with type signatures we can help you understand them better. They're pretty critical to getting the most help out of the haskell compiler.
15:32:10 <ski> beaky : i don't follow "in a way that causes links to the old to refer to the new"
15:32:18 <bulletbill22> I don't know the difference between -> and =>, and I'm unsure which order the variables go in
15:32:44 <bulletbill22> there's also no "list" type which is frustrating because I'm trying to work with lists
15:32:46 <levi> The '->' means there's a function type.
15:32:48 <ski> bulletbill22 : `=>' has class constraints on the left. `->' is for functions
15:33:08 <levi> And the list type has special syntax; it's just a type enclosed in square brackets.
15:33:12 <beaky> are typclasses like c++ concepts
15:33:22 <levi> For a list of type 'a', we use '[a]'
15:33:39 <bulletbill22> I see
15:33:43 <bulletbill22> that makes some sense
15:33:55 <levi> If we require that 'a' be a numeric type, we say 'Num a => [a]'
15:34:24 <erisco> hrm... haskell-src looks a bit off
15:34:28 <ski> levi : .. though only if `[a]' is the whole of the type in which we require `a' to be a numeric type in
15:34:37 <erisco> it contains 'srcLoc' fields which are nonsensical for generating haskell source
15:34:42 <erisco> I can't know what the srcLoc is
15:34:43 <levi> A function involving that type might have a signuature like: 'Num a => [a] -> a'
15:34:48 <bulletbill22> What do I put for the functions without variables? Would id be something like IO() -> [a]?
15:35:13 <shachaf> levi: That explanation seems to be misleading because "Num a => [a]" is hardly ever a thing you want to say.
15:35:14 <bulletbill22> without parameters I mean
15:35:24 <ion> There is no such thing as a function without a parameter in Haskell.
15:35:30 <shachaf> (Num a => [a]) -> a is very different from Num a => [a] -> a, and both are meaningful.
15:35:49 <kadoban> bulletbill22: you mean just a constant?  blah :: [a]  possibly?
15:36:08 <ski> every function in Haskell takes exactly one input argument
15:36:15 <ski> shachaf : indeed
15:36:34 <levi> OK, pedant patrol, I'll let someone else provide examples.
15:36:45 <shachaf> sigh
15:36:54 <ski> shachaf : i prefer to think of "`[a]', where we know `Num a'" as a kind of presupposition, the known presupposition for `a' here is `Num a'
15:37:47 <shachaf> ski: As long as the scoping is clear.
15:38:21 <shachaf> Similarly when people say something like "I have 'Functor f => f Int'".
15:38:24 <prooftechnique> bulletbill22: Here it is with type annotations: http://lpaste.net/101900
15:38:33 <ski> shachaf : in most cases, the presupposition would be inserted at the place of quantification, and of the same type as the quantification
15:38:39 <ski> shachaf : of course
15:38:41 <shachaf> What they mean is closer to "I have 'Functor f *> f Int'".
15:38:47 <prooftechnique> So the issue is that you're giving print_median a string, but it expects a list of numbers
15:39:29 <ski> (by "of the same type as the quantification" i mean with `=>' for `forall' and with `*>' for `exists')
15:39:35 <shachaf> But really it means -- yes, you know what I mean.
15:40:02 <bulletbill22> thanks! It looks like that's getting me somewhere
15:40:03 <shachaf> "f" is free, and people want the "Functor f =>" to go at the same place where f is being bound.
15:41:16 * ski is happy to see someone else is annoyed by this as well
15:41:20 <erisco> is there a more appropriate package for generating haskell source than haskell-src?
15:41:56 <ion> erisco: How about haskell-src-exts?
15:42:02 <bulletbill22> prooftechnique: So what's the point of the "Maybe" in "sorted_median :: Fractional a => [a] -> Maybe a"
15:42:23 <ski> bulletbill22 : no median for an empty input list
15:42:29 <beaky> are there better symbols for function aplication than $
15:42:43 <ski> beaky : `@' is sometimes used in papers
15:42:57 <erisco> ion, hm it uses srcLoc everywhere too
15:43:14 <erisco> I do not imagine the pretty printing makes use of srcLoc, so I may be okay in using a nonsense value
15:43:36 <bulletbill22> I see. So if the list is empty then it just returns nothing, and the compiler is cool with nothing as long as maybe is there
15:43:45 <ski> yes
15:43:50 <ski> that's the point of `Maybe'
15:44:14 <ski> bulletbill22 : having a `null' value in all, or most, types, would be a bad idea
15:45:24 <ski> the good thing with `Maybe' over `null' is that (a) you have to explicitly say what to do in the `Nothing' case, to use the contents (if any); (b) you avoid domain contagion
15:45:47 <erisco> but then I'd have to prefer wrapping the entire library just to apply the nonsense srcLoc
15:45:56 <erisco> better get started I suppose
15:46:06 <ski> possibly one can also regard the following as an advantage (c) you can *refrain* from using `Maybe'
15:46:33 <ski> .. but then there are some type systems for languages with `null', where the types can express that in some situations it's impossible for a value to be `null'
15:47:04 <bulletbill22> Sounds complicated. What's the "Ord" "in median :: (Ord a, Fractional a) => [a] -> Maybe a"? It looks like a is being defined as two different types
15:47:29 <jle`> bulletbill22: the left side of => is typeclass constraints
15:47:33 <jle`> meaning that a must be fractional
15:47:36 <jle`> and a must also be orderable
15:48:21 <bulletbill22> I see. thanks.
15:48:23 <jle`> bulletbill22: what would you expect to get if sorted_median of a list has no median?
15:48:46 <jle`> bulletbill22: some types that are both fractional and orderable include: Double, Rational, Float
15:49:14 <bulletbill22> Well I guess if it's fractional then it must be orderable, right? So why would you need to specify orderable if you already specified ractional?
15:49:18 <jle`> bulletbill22: you can use :info Fractional in ghci to see all types in scope that are Fractional, and :info Ord to see all orderable types
15:49:25 <jle`> bulletbill22: i could easily make a type that is fractional and not orderable
15:49:47 <jle`> for example
15:49:49 <jle`> Complex
15:50:03 <jle`> complex numbers are fractional, but there is no way to order them meaningfully
15:50:18 <jle`> but i could also construct one myself arbitrarily, too.
15:50:27 <luite_> jle`: depending on what you mean by 'meaningfully' :)
15:51:04 <jle`> luite_: :P
15:51:47 <luite_> but yeah, not an ordered field
15:52:33 <jle`> one could define a lawful Ord instance for complex i think...but i think you'd have to also redefine the default Eq instance
15:53:25 <jle`> actually
15:53:43 <jle`> yeah there are some you can define that don't involve overriding the default Eq instance
15:53:49 <jle`> maybe?
15:53:51 <jle`> hm.
15:54:13 <jle`> yeah, there's the lexical ordering thing.
15:54:53 <ski> but it's not a linear order on complex numbers ..
15:55:04 <jle`> but it's an Ord instance for Complex
15:55:11 <jle`> that is lawful
15:55:13 <jle`> right?
15:55:23 <ski> i think so
15:55:32 <jle`> not that it's a meaningful ordering >.>
15:55:49 <monochrom> the order does not play well with arithmetic. but you may be ok with it.
15:56:24 <ski> just implementing `Ord' and `Fractional' ought to require that whose play along nicely with each other
15:56:25 <jle`> hm
15:56:45 <jle`> it's useful if you what to, say, use Complex as a key for a map, or store it in a set
15:57:00 <ski> however, if there is a way to implement both so that they play along nicely with each other, you should probably pick that way over other ways
15:57:05 * ski nods
16:00:06 <bulletbill22> So now I have the error "Instance of Frcational Char required for definition of main. Someone suggested that I remove the definition for main so that I can see what the compiler thinks it chould be to get more information, but that just results in an "Unresolved top-level overloading" error
16:00:11 <erisco> is there something better than doing this? http://lpaste.net/101904 before I spend the next forever on it
16:00:14 <bulletbill22> http://lpaste.net/101900
16:00:31 * hackagebot network-transport-zeromq 0.1.0.0 - ZeroMQ backend for network-transport  http://hackage.haskell.org/package/network-transport-zeromq-0.1.0.0 (AlexanderVershilov)
16:01:00 <bulletbill22> Main shouldn't require any parameters, shoult it? IT's just printing and accepting input
16:01:44 <prooftechnique> bulletbill22: You don't need to return () at the end, just so you know
16:02:15 <bulletbill22> I see
16:02:23 <monochrom> you are, effectively, saying you divide a character such as 'x' by 2. what is that supposed to mean? (rhetorical question. answer: it means nothing. you are not supposed to do it.)
16:02:27 <yogert1> bulletbill22, on line 8 why is your condition [element] == ""?  That will always evaluate to false no?
16:02:27 <bulletbill22> thanks, that got rid of the unresolved top level error
16:03:21 <bulletbill22> hmm....
16:03:41 <bulletbill22> It should probably be a getLine rather than a char, but I'm trying to check if the input is empty
16:03:45 <thebnq> bulletbill22: print_mediun is being passed a string, [Char]
16:04:02 <yogert1> Well wouldn't it be a carriage return character or a newline?
16:04:16 <yogert1> so maybe element == '\n'
16:04:19 <thebnq> bulletbill22: but you typed it as [a] where a is a Fractional
16:04:55 <prooftechnique> thebnq: That's my doing. I just let GHC infer those types so the issues would be more obvious
16:05:42 <thebnq> ah, its ok on its own, but calling it with string won't work then
16:06:00 <bulletbill22> It won't allow me to use Char in the type signature, though. It's unrecognized
16:06:26 <bulletbill22> Oh, but I need fractional out of the input
16:06:42 <bulletbill22> rather than a string
16:06:52 <dmj`> is there a haskell solution for managing ip addresses amongst many compiled binaries?
16:09:47 <thebnq> bulletbill22: you need to explicitly turn string to something Fractional somewhere
16:15:04 <yogert1> yeah, you might try reading the characters to numbers as you get them making input_list  Fractional a => IO [a]
16:15:33 * hackagebot postgresql-simple 0.4.2.1 - Mid-Level PostgreSQL client library  http://hackage.haskell.org/package/postgresql-simple-0.4.2.1 (LeonSmith)
16:16:10 <yogert1> What does hackagebot do?
16:16:30 <yogert1> Does it post whenever someone makes an update to a package on hackage?
16:19:30 <erikd> yogert1: yes
16:24:35 <bulletbill22> I've got a new error, it's confusing me.
16:24:40 <bulletbill22> http://lpaste.net/101900
16:24:58 <bulletbill22> Like I can'd read in the function because of the type
16:25:35 * hackagebot group-with 0.1.0.0 - Classify objects by key-generating function, like SQL GROUP BY  http://hackage.haskell.org/package/group-with-0.1.0.0 (ulikoehler)
16:25:37 <bulletbill22> Or it doesn't know what ot read out, maybe?
16:28:13 <quchen> bulletbill22: Don't use tabs. https://github.com/quchen/articles/blob/master/fbut.md#tabs-vs-spaces
16:28:54 <jle`> bulletbill22: so you return a list of a's, right?
16:29:05 <jle`> bulletbill22: on like 7, you read a string into an a
16:29:16 <jle`> but you didn't say that a was read-from-a-string-able
16:29:24 <jle`> not all a's can be parsed from a string
16:29:32 <jle`> you have to say (Read a, Fractional a) => ...
16:29:43 <bulletbill22> So that's something that has to be difined alongside Fractional
16:29:47 <bulletbill22> I see
16:30:22 <bulletbill22> Sweet!
16:30:24 <jle`> it's not quite a definition, it's more like a constraint
16:39:29 <bulletbill22> Cool. So now the program works, but one issue is that I have ti accept anothe character as input when asking if they want to compute another median because otherwise (I'm guessing) it takes the newline as input. Is there a better way to handle this?
16:39:38 <bulletbill22> http://lpaste.net/101900
16:40:12 <jle`> you can use getLine
16:40:20 <jle`> to eat up stdIn until the next newline
16:40:44 <jle`> and then say "y" `isPrefixOf` option
16:41:41 <bulletbill22> Cool, thanks!
16:41:47 <Eduard_Munteanu> :t interact
16:41:48 <lambdabot> (String -> String) -> IO ()
16:42:05 <Eduard_Munteanu> :t interact (unlines . ?f . lines)
16:42:06 <lambdabot> (?f::[String] -> [String]) => IO ()
16:42:21 <Eduard_Munteanu> :t interact (unlines . map ?f . lines)
16:42:21 <lambdabot> (?f::String -> String) => IO ()
16:42:35 <Eduard_Munteanu> bulletbill22: for simple stuff the above may be enough
16:43:11 <Eduard_Munteanu> :t interact (unlines . concatMap ?f . lines)  -- or perhaps this
16:43:12 <lambdabot> (?f::String -> [String]) => IO ()
16:45:17 <Eduard_Munteanu> What are my options if I'm looking for attribute grammar parsers/unparsers, aside from Happy?
16:46:04 <ski> @let infixr 1 (~>); (~>) :: (a1 -> a0) -> (b0 -> b1) -> ((a0 -> b0) -> (a1 -> b1)); (f ~> h) g = h . g . f
16:46:04 <lambdabot>  Parse failed: Parse error: (
16:46:15 <ski> @let infixr 1 ~>; (~>) :: (a1 -> a0) -> (b0 -> b1) -> ((a0 -> b0) -> (a1 -> b1)); (f ~> h) g = h . g . f
16:46:16 <lambdabot>  Defined.
16:46:43 <ski> @let onLines :: ([String] -> [String]) -> (String -> String); onLines = lines ~> unlines
16:46:44 <lambdabot>  Defined.
16:47:06 <ski> @let perLine :: (String -> String) -> (String -> String); perLine = onLines . map
16:47:07 <lambdabot>  Defined.
16:48:32 <ski> @let fooLine :: (String -> [String]) -> (String -> String); perLine = onLines . concatMap
16:48:33 <lambdabot>  .L.hs:163:1:
16:48:33 <lambdabot>      The type signature for `fooLine' lacks an accompanying binding
16:48:33 <lambdabot>  
16:48:33 <lambdabot>  .L.hs:164:1:
16:48:33 <lambdabot>      Multiple declarations of `perLine'
16:48:38 <ski> @let fooLine :: (String -> [String]) -> (String -> String); fooLine = onLines . concatMap
16:48:39 <lambdabot>  Defined.
16:49:21 <ski> Eduard_Munteanu : not sure if UUAG does what you want
16:49:47 <ski> @where UUAG
16:49:47 <lambdabot> http://www.cs.uu.nl/wiki/HUT/AttributeGrammarSystem
16:50:06 * Eduard_Munteanu looks
16:51:35 <Eduard_Munteanu> ski: actually I want to write parsers in a more EBNF-like syntax and get unparsers for free, more or less
16:51:57 <Eduard_Munteanu> In contrast to parser combinators, that is.
16:55:26 <ski> Eduard_Munteanu : what about brackets ?
16:55:44 <Eduard_Munteanu> ski: what do you mean?
17:00:16 <ski> Eduard_Munteanu : i mean, if all of `2',`(2)',`((2))',... can be parsed to the same parse tree, then which do you want when unparsing ?
17:00:21 <ski> all of them ?
17:00:32 <ski> a minimal one (define minimal ?) ?
17:01:05 <zenkeku> @paste
17:01:05 <lambdabot> Haskell pastebin: http://lpaste.net/
17:01:05 <Eduard_Munteanu> ski: I'm interested in parsing URIs, there should be a normal / canonical form AFAICT.
17:01:32 <ski> hm, is that true, in the presence of unicode ?
17:02:15 <Eduard_Munteanu> ski: mm, I expect the input to be Text
17:02:17 <zenkeku> The more haskell I learn the more I see function pattern matching, like this: http://lpaste.net/101912 Is this common place in haskell code and is it good practice? Or is it simply being used as a teaching method?
17:02:49 <monochrom> it is common place and good practice
17:03:00 <monochrom> it is also a teaching method
17:03:15 <Eduard_Munteanu> zenkeku: it is normal, but for such cases it's more common to use higher-order functions like foldl
17:03:33 <zenkeku> Eduard_Munteanu: I figured by what the paste-site was recommending.
17:03:41 <zenkeku> monochrom: That's good to hear! I rather like the pattern matching.
17:04:03 <Eduard_Munteanu> zenkeku: foldr isn't a good idea there though, you want foldl', more specifically
17:04:22 <zenkeku> Eduard_Munteanu: Oh, why so?
17:04:22 <Eduard_Munteanu> :t sum   -- or use this directly
17:04:23 <lambdabot> Num a => [a] -> a
17:04:55 <Eduard_Munteanu> zenkeku: adding normal numbers is strict and foldr would blow the stack
17:05:40 * hackagebot tidal 0.3.1 - Pattern language for improvised music  http://hackage.haskell.org/package/tidal-0.3.1 (AlexMcLean)
17:06:11 <zenkeku> Eduard_Munteanu: The result of foldr with the aforementioned function would result in the same number assuming all the numbers were positive, but not of they were negative, correct?
17:06:43 <asQuirreL> zenkeku: foldr (+) 0 is existentially equivalent to foldl (+) 0
17:06:51 <Eduard_Munteanu> zenkeku: no... (+) is associative and it doesn't matter if you use foldl or foldr
17:07:06 <Eduard_Munteanu> As far as the correctness of the result is concerned.
17:07:28 <prooftechnique> > foldr (+) 0 [-1,3,-4,5,7]
17:07:30 <lambdabot>  10
17:07:31 <zenkeku> Eduard_Munteanu: What do you mean by strict and "blow the stack"?
17:07:32 <prooftechnique> > foldl (+) 0 [-1,3,-4,5,7]
17:07:33 <lambdabot>  10
17:07:56 <asQuirreL> zenkeku: the problem is that the size of the call stack for foldr is linear in the size of the list
17:07:58 <Eduard_Munteanu> zenkeku: but for larger lists, it builds a computation like a + (b + (c ... that simply builds up and can't be reduced step by step.
17:08:03 <prooftechnique> > foldr (+) 0 [1..100000000]
17:08:04 <lambdabot>  *Exception: stack overflow
17:08:10 <prooftechnique> ^ zenkeku
17:08:16 <prooftechnique> > foldl' (+) 0 [1..100000000]
17:08:19 <lambdabot>  mueval-core: Time limit exceeded
17:08:33 <prooftechnique> Well, it would work that way, anyway :D
17:08:44 <zenkeku> The result would be the same in a non-lazy-evaluation language, right?
17:08:46 <ski> asQuirreL : "existentially" ?
17:09:46 <ski> > foldr (+) 0 [1..1000000]
17:09:47 <lambdabot>  *Exception: stack overflow
17:09:47 <ski> > foldl' (+) 0 [1..1000000]
17:09:48 <lambdabot>  500000500000
17:09:49 <Eduard_Munteanu> zenkeku: if you used a non-strict operator like (:), actually foldr would be preferred, because it can be unwound step by step
17:10:04 <asQuirreL> ski: the mappings are equivalent
17:10:28 <jle`> zenkeku: pattern matching is used often and is one of the things you will be doing the most in haskell.  but explicit recursion is less common
17:10:39 <ski> asQuirreL : .. oh, i thought you meant something like "if both sides are defined, then they are equal"
17:10:40 <Eduard_Munteanu> > take 2 $ foldr (:) [] [1..]
17:10:41 <lambdabot>  [1,2]
17:10:49 <Eduard_Munteanu> > take 2 $ foldl (:) [] [1..]
17:10:50 <lambdabot>  Occurs check: cannot construct the infinite type: a0 = [a0]
17:10:50 <lambdabot>  Expected type: [a0] -> [[a0]] -> [a0]
17:10:50 <lambdabot>    Actual type: [a0] -> [[a0]] -> [[a0]]
17:10:54 <zenkeku> jle`: I should note that the aforementioned function is not my own and is taken from a book.
17:10:59 <Eduard_Munteanu> > take 2 $ foldl (flip (:)) [] [1..]
17:11:04 <lambdabot>  mueval-core: Time limit exceeded
17:11:05 <zenkeku> jle`: As a method of teaching, I am assuming.
17:11:20 <jle`> zenkeku: yeah, i noted that.  just explaining what parts of the function are common and what are not :)
17:11:36 <Eduard_Munteanu> zenkeku: in the above example, foldl will never work because it doesn't give you any piece of the result until it's done
17:11:43 <asQuirreL> ski: no, now that you've made me look at what I've said, it does seem quite odd though... I'm trying to remember the justification and I can't :P
17:11:46 <zenkeku> jle`: Okay, just wanted to make sure it wasn't thought that I was trying to reinvent the wheel! All input is welcome.
17:12:08 --- mode: monochrom set -b *!*@200.79.251.35
17:12:12 <ski> @let data Nat = Zero | Succ Nat deriving (Eq,Ord)
17:12:13 <lambdabot>  Defined.
17:12:13 <jle`> zenkeku: np!  explicit recursion is actually usually a smell that there is some higher order function you can use
17:12:14 --- mode: monochrom set -o monochrom
17:12:14 <Eduard_Munteanu> > (foldl (+) z [a,b,c,d], foldr (+) z [a,b,c,d])
17:12:15 <lambdabot>  (z + a + b + c + d,a + (b + (c + (d + z))))
17:12:41 <jle`> there are some cases where you will need explicit recursion, but before you actually use it, it's best to look for a higher order function that will do it for you
17:12:46 <zenkeku> Eduard_Munteanu: I see that now. Some of these concepts are really alien from imperative paradigms.
17:12:49 <Eduard_Munteanu> @src foldl
17:12:49 <lambdabot> foldl f z []     = z
17:12:49 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
17:12:51 <Eduard_Munteanu> @src foldr
17:12:51 <lambdabot> foldr f z []     = z
17:12:51 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
17:13:32 <zenkeku> Is that the actual source for those two functions? It seems incredibly simple.
17:14:02 <jle`> zenkeku: yup :)
17:14:04 <jle`> isn't that the feeling?
17:14:13 <jle`> i think ghc might have more efficient ones defined
17:14:24 <jle`> but in haskell you often wonder 'wait...isn't that kind of too simple?'
17:14:32 <zenkeku> Rather incredible.
17:15:18 <zenkeku> I apologize if I seem to lazy to google, but are there any serious limitations to the potential of haskell that isn't found in non-function languages?
17:15:20 <ski> @let instance Num Nat where Zero + n = n; Succ m + n = Succ (m + n); m - Zero = m; Succ m - Succ n = m - n; Zero * _ = Zero; Succ m * n = n + m * n; negate Zero = Zero; abs = id; signum Zero = Zero; signum (Succ _) = Succ Zero; fromInteger n | n >= 0 = genericIndex (iterate Succ Zero) n
17:15:21 <lambdabot>  Defined.
17:15:24 <Eduard_Munteanu> zenkeku: the relevant difference is foldl builds up the result in an accumulator parameter, while foldr leaves a "trail" of applications that build the result
17:15:39 <jle`> zenkeku: well, haskell can be used for imperative things too
17:15:50 <zenkeku> Eduard_Munteanu: That's because of the lazy-evaluation, right?
17:16:16 <ski> @let instance Show Nat where shows n = shows (to n) where to Zero = 0; to (Succ n) = 1 + to n
17:16:16 <Eduard_Munteanu> zenkeku: yes, though more accurately due to non-strict semantics
17:16:16 <lambdabot>  .L.hs:161:9: `shows' is not a (visible) method of class `Show'
17:16:38 <ski> @let instance Show Nat where showsPrec _ n = shows (to n :: Integer) where to Zero = 0; to (Succ n) = 1 + to n
17:16:39 <lambdabot>  Defined.
17:16:43 <zenkeku> Eduard_Munteanu: Duely noted.
17:16:44 <Eduard_Munteanu> zenkeku: which means the programmer expects things won't get fully forced
17:17:29 <ski> > case foldr (+) 0 (repeat 1) :: Nat of Succ _ -> "yes"; Zero -> "no"
17:17:31 <lambdabot>  "yes"
17:17:32 <ski> > case foldl (+) 0 (repeat 1) :: Nat of Succ _ -> "yes"; Zero -> "no"
17:17:37 <lambdabot>  mueval: ExitFailure 1
17:17:37 <lambdabot>  mueval: Prelude.undefined
17:17:41 <ski> asQuirreL : ^ not equivalent
17:17:49 <zenkeku> Thank you for all of the input, ski, Eduard_Munteanu and jle`. Much appreciated.
17:18:52 <asQuirreL> ski: okay, I've finally got it in my head straight, what I meant by existential equivalence
17:18:57 <ski> ok ?
17:20:16 <asQuirreL> f and g are existentially equivalent if, for any first order logic formula satisfied by a structure containing f as the definition for a function symbol
17:20:57 <asQuirreL> if a structure containing g as the definition of the same function symbol also satisfies the same formula
17:21:08 <Guest76991> hello guys. how do i force ghc to recompile even if the source did not change?
17:21:09 <asQuirreL> and the first order logic formula is an existential sentence
17:21:22 <Eduard_Munteanu> Guest76991: -fforce-recomp
17:21:25 <Fuuzetsu> Guest76991: there's a force… ^
17:21:36 <Guest76991> thanks!
17:23:17 <Eduard_Munteanu> ski: actually, hm... looks like URIs shouldn't contain arbitrary unicode, instead the codepoints can be percent-encoded in UTF-8 (specifically).
17:23:18 <ski> asQuirreL : hm, havinbg trouble parsing that
17:24:05 <asQuirreL> ski: saying you have an existential sentence (a FO Logic formula where the only quantifier used is the existential quantifier)
17:24:25 <ski> Eduard_Munteanu : yes. however istr there being problems with there being potentially many ways to encode the same unicode glyphs
17:24:36 <asQuirreL> and say you have a function symbol in the existential sentence: f'
17:24:47 <ski> asQuirreL : `Sigma_0^0' ?
17:25:07 <asQuirreL> ski: what on earth is that?
17:25:24 <ski> <http://en.wikipedia.org/wiki/Arithmetical_hierarchy>
17:25:39 <ski> and sorry, it ought to be `Sigma_1^0'
17:28:11 <asQuirreL> ski: yes, I believe so, (S_1^0) I've not seen the arithmetical heirarchy before though
17:28:47 <ski> asQuirreL : anyway, i still had trouble parsing your statement
17:29:20 <ski> what does "a structure containing f as the definition for a function symbol" and "a structure containing g as the definition of the same function symbol" mean
17:30:14 <asQuirreL> ski: a structure as in a First Order model, over a particular signature.
17:30:16 <ski> hm, oh, right, `f' isn't the function symbol here
17:30:43 <asQuirreL> no, it's the definition of the function symbol under some model
17:32:02 <greg`> im using emacs with cabal sandbox anyone know how to get flycheck to update modules in scope for cabal sandbox
17:32:16 <greg`> *from cabal sandbox
17:32:44 <ski> asQuirreL : "satisfied by a structure" -- satisfied by every structure ? or some structure ?
17:32:58 <yogert1> why is lambdabot drooling? http://www.haskell.org/haskellwiki/Lambdabot
17:33:53 <ski> yogert1 : she's a bit dulled by people asking her to evaluate lots of different things
17:34:27 <asQuirreL> ski: every structure, I think
17:34:58 <schell> i've got a bytestring and it has some unicode (i'm guessing) characters encoded as \\u0040 (which is an @) - what's the best way to decode this into an @?
17:35:22 <ion> Is it JSON?
17:35:25 <asQuirreL> the point is that if the definitions for a function symbol are interchangeable whilst still satisfying the same set of existential sentences, then the two definitions are existentially equivalent
17:36:08 <ski>   forall Phi. forall s. (forall M. def(s,f,M) -> |=_M Phi) -> (forall M. def(s,g,M) -> |=_M Phi)
17:36:13 <ski> asQuirreL : something like that ^
17:36:35 <ski> er, taking `Phi' from `Sigma_1^0', i.e.
17:36:56 <asQuirreL> what are s and M here?
17:36:59 <asQuirreL> and def
17:37:05 <asQuirreL> M is model?
17:37:10 <ski> `s' being the function symbol, and `M' being the model/structure
17:37:55 <asQuirreL> and def(s,f,M) means f defines s in M?
17:38:04 <ski> yep
17:38:12 <ski> (not standard notation)
17:39:12 <asQuirreL> (forall M. def(s,f,M) -> |=_M Phi) <-- should this be: (forall M. def(s,f,M) & M |= Phi) ?
17:39:50 <asQuirreL> here's the statement I'm trying to make, in this notation:
17:40:12 <ski> asQuirreL : surely not
17:40:25 <ski> (note that my `->' binds tighter than `forall')
17:40:36 <asQuirreL> ah wait, no the implication is correct, you're right
17:41:03 <asQuirreL> I want to say this instead though:
17:41:25 <ski> asQuirreL : and so i suppose "universally equivalent" would be the same, except now `Phi' is a `Pi_1^0' sentence ?
17:42:51 <asQuirreL> (forall Phi, s, M. def(s,f,M) -> M |= Phi && def(s,g,M) -> M |= Phi) |= f =_E g
17:44:03 <flebron> Hi. So it's not really true that if I have a natural transformation n :: Identity -> Identity, then n must be the identity function at each component. So barring bottom and const bottom, why can I conclude that f :: a -> a is the identity?
17:44:45 <asQuirreL> ski: potentially, it makes sense for that to be the case, but I've not seen a use for that
17:45:16 <asQuirreL> existential equivalence works quite nicely to capture this sort of "black box" equivalence of functions though
17:46:04 <yogert1> Does anyone use ghcmod-vim? I can't get any of the commands working...
17:46:46 <ski> asQuirreL : hm, why's that ?
17:47:22 <ski> asQuirreL : hm, is it somehow related to recursive/computably enumerability ?
17:47:23 <yogert1> This issue https://github.com/eagletmt/ghcmod-vim/issues/38 suggests that I ought to move some folders around, but that doesnt seem to help
17:48:40 <asQuirreL> ski: well this blackbox equivalence is coRE
17:49:37 <Eduard_Munteanu> Hm, I can't find anything on unparsing in Happy, it looks like its attribute grammars merely automate data declarations and such.
17:52:55 <schell> ion: yes, well, it's trying to be - but aeson can't decode it and i'm guessing it's because of this character
17:54:02 <schell> ion: i'm exactly sure of the original nature of the string, but it's either url encoded or json or...
17:54:14 <ski> asQuirreL : hm, elaborate ?
17:54:33 <ski> iirc, a coRE set is one whose complement is RE
17:54:40 <asQuirreL> ski: the language of pairs of functions (f,g) that are not equivalent is RE
17:55:16 <asQuirreL> ski: that's right
17:55:24 <ski> s/equivalent/existentially equivalent/ ?
17:55:38 <asQuirreL> ski: lol, yes :P
17:56:14 <ski> i'm not seeing how the "existentially" in "existentially equivalent" relates to coRE here
17:59:23 <super_teufel> hi, I looking for a way to auto complete pattern matching that are not fully implement , to prevent run-time error  ex.    YourFunction _  =  NotYetImplement
17:59:59 <asQuirreL> ski: for a pair (f,g), evaluate f at every value in x <- Dom(f) to produce some value y. Then construct a trivial existential formula, Phi: f(x) = y, and see if it holds true using g too
18:00:00 <Eduard_Munteanu> super_teufel: just omit it and pass -Wall to GHC
18:00:24 <asQuirreL> ski: if the two are not existentially equivalent, then at some point you will meet an incongruence
18:00:40 <asQuirreL> if they are, then you could go on forever, if the domain were (countably) infinite
18:00:54 <ski> hm, assumes `Dom(f)' can be enumerated
18:01:03 <asQuirreL> heh... yes :P
18:01:15 <Cale> super_teufel: Well, it won't prevent any runtime errors, but you can use 'error' with a custom error message
18:01:21 <ski> asQuirreL : ok
18:01:42 <Cale> super_teufel: You can of course have the function produce something of type Maybe t for some t.
18:01:51 <asQuirreL> seeing as we are talking about functions in haskell, I think we can take "countably infinite" as a comfortable upperbound
18:01:56 <ski> i still don't see where the fact that `Phi' being a `Sigma_1^0' formula comes in, though
18:04:46 <asQuirreL> ski: I'll have to think about it some more. "existential equivalence" was always just the phrase I used for "if you put the same arguments into these functions, you'll get the same values out"
18:05:13 <asQuirreL> It may be the case that existential equivalence is actually a stronger form of equivalence than that though
18:07:23 <schell> i think i'm going to have to write my own parser just to properly decode \u0040's and the like
18:08:17 <Eduard_Munteanu> schell: you could just run a simple Parsec or similar parser pass to replace that character
18:09:00 <schell> Eduard_Munteanu: i'm worried other characters will creep in down the line
18:09:18 <Eduard_Munteanu> schell: replace all \u sequences then
18:10:35 <schell> Eduard_Munteanu: i understand how i would find \u and then 0040, but how do i turn that into the correct character? 
18:11:08 <oio_> pure thread delay?
18:11:20 <schell> convert 0040 to 40 and hope it corresponds to a Char through Enum?
18:11:39 <cdk_> if I have an indexed typeclass with type family like "class C a where; type F; foo :: a -> F", is it possible to have a constraint on the type of F, something like "class C a where; Ord F => type F; foo :: a -> F"
18:12:16 <Eduard_Munteanu> schell: with attoparsec you can do something like  chr <$> string "\u" <*> decimal
18:12:29 <Eduard_Munteanu> Er, could be octal though
18:12:34 <schell> looks like it does, just not the right one!
18:12:51 <schell> > toEnum 40 :: Char
18:12:52 <lambdabot>  '('
18:13:19 <ski> asQuirreL : hm, i'd think of "if you put the same arguments into these functions, you'll get the same values out" as *extensional* (not existential) equivalence
18:13:27 <schell> ah, i see 0040 is an octal number
18:13:35 <Eduard_Munteanu> cdk_: not really, but you can place the constraint on methods
18:13:38 <schell> Eduard_Munteanu: okay, thanks
18:13:53 <ski> > chr 0x0040
18:13:54 <lambdabot>  '@'
18:14:10 <ski> > chr 0o0040
18:14:11 <lambdabot>  ' '
18:14:56 <schell> ski: that's it
18:15:05 <schell> hex
18:15:13 <Eduard_Munteanu> cdk_: or you could use a fundep and another typeclass parameter instead
18:15:36 <ski> > (readHex :: ReadS Integer) "0040"
18:15:37 <lambdabot>  [(64,"")]
18:15:39 <ski> > (map . first) chr ((readHex :: ReadS Int) "0040")
18:15:40 <lambdabot>  [('@',"")]
18:15:46 <ski> schell ^
18:15:55 <Eduard_Munteanu> schell: you can use the 'hexadecimal' parser then
18:16:20 <Eduard_Munteanu> schell: however you probably want to write a parser that handles all escapes correctly
18:16:34 <schell> awesome, i think attoparsec is already part of the dependencies so that's nice
18:17:37 <prooftechnique> Any TH developers around? Just curious about when 2.10 will hit Hackage
18:18:20 <prooftechnique> Igloo maybe
18:19:31 <Eduard_Munteanu> schell: say like...  concat <$> many ((:[]) <$> (string "\u" *> chr decimal  <|>  char '\\' *> char '\\') <|> takeWhile1 (/= '\\'))
18:20:47 <haasn> > "0040" ^? hex
18:20:48 <lambdabot>  Just 64
18:20:52 <haasn> IMPROPER PRISM ALERT
18:20:59 <haasn> > hex # 64
18:21:00 <lambdabot>  "40"
18:21:10 <haasn> > "0040" == "40" -- edwardk !!!!
18:21:11 <lambdabot>  False
18:21:13 <Eduard_Munteanu> Er, I keep saying "decimal".
18:21:14 <haasn> oh :(
18:21:43 <prooftechnique> haasn: Oh, snap
18:21:55 <prooftechnique> The mailing list is going to explode at this news
18:22:07 <ion> haasn: I think i’m to blame for this. D-:
18:22:48 <Eduard_Munteanu> (also a few other mistakes, but I should go get some sleep :D)
18:23:02 <haasn> ion: clearly, hex should fail if the number starts with extra 0s :)
18:23:36 <augur> haasn: improper prism alert?
18:23:47 <haasn> ion: I'll add a note to the documentation, though
18:29:39 <haasn> augur: if (s ^? p) = Just x then p # x = s  -- prism law
18:29:58 <haasn> but here we have s = "0040", p = hex, x = 64 and hex # 64 is "40", not "0040"
18:30:13 <haasn> that is, reading through the prism is lossy
18:30:33 <augur> haasn: interesting. what are these gadgets (^?) and (#)??
18:30:36 <augur> whats a prism?
18:30:54 <haasn> oh, you're not familiar with lens?
18:31:13 <augur> lens yes
18:31:14 <augur> prism no
18:31:51 <haasn> the most succinct way I can describe (^?) is: x ^? l = listToMaybe (x ^.. l)
18:31:53 <haasn> if that makes sense
18:32:03 <haasn> (^?) :: LensLike' s a -> s -> Maybe a
18:32:08 <haasn> Getting s a
18:32:10 <haasn> or something
18:32:12 <haasn> Getting a s a
18:32:14 <haasn> lens is complicated
18:32:24 <kazagistar> I am just starting to work with lens... what would be the easiest way to make a lens of a newtype around a Map (which already has lens support)?
18:32:47 <haasn> kazagistar: add a Wrapped instance and use _Wrapped.at or whatever
18:32:49 <haasn> for the combination
18:33:08 <ReinH> kazagistar: GeneralizedNewtypeDeriving?
18:33:12 <haasn> augur: oh, also the ‘s’ comes before the lenslike
18:33:45 <haasn> augur: (#) is sort of specific to prisms, (p # x) = review p x = view (re p) x
18:33:54 <haasn> augur: ‘re’ flips a prism around; but before that you have to understand what a prism is
18:34:01 <augur> haasn: how funky
18:34:03 <haasn> augur: a prism is basically like an iso that can fail in one direction
18:34:05 <augur> ill have to do some reading
18:34:13 <haasn> for example, here we have
18:34:18 <haasn> (String -> Maybe Int) and (Int -> String)
18:34:22 <haasn> for the ‘hex’ stuff
18:34:25 <augur> haasn: :x
18:34:31 <augur> you dont have to worry about it
18:34:35 <augur> i wont grok this right now
18:34:55 <haasn> augur: a motivating example of a prism is _Right;  because we have Either l r -> Maybe r but r -> Either l r
18:34:56 <haasn> okay
18:35:23 <haasn> similar analogies that you can think about when you get the time: a prism is also like a constructor
18:35:31 <haasn> a prism is to sums what lenses are to products
18:35:36 <haasn> a prism is the “dual” of a lens
18:41:32 <[swift]> i'm making a Haskell library for accessing a public RESTful API. should i file my module under 'Web'? 'Network'?
18:45:07 <johnw> what's the name of the service?
18:46:12 <[swift]> johnw: bugzilla
18:46:22 <johnw> you may just want to call the module "Bugzilla"
18:46:24 <johnw> Aws does this
18:46:45 <[swift]> that nicely avoids the problem =)
18:47:14 <johnw> great, if you get that working, I can write my Bugzilla -> GitHub conversion
18:47:41 <haasn> @fresh
18:47:42 <lambdabot> Hamb
18:47:44 <haasn> you're welcome
18:48:45 <[swift]> johnw: if my free time permits it should be up on hackage soon =)
18:48:54 <haasn> > (19839182938 :: Int) & partsOf bits %~ take 8
18:48:55 <johnw> nice
18:48:56 <lambdabot>  19839182938
18:49:03 <johnw> would you be at NYC Hac by any chance?
18:49:06 <haasn> aaw
18:49:27 <[swift]> johnw: nah, wrong coast =)
18:53:10 <haasn> > (19839182938 :: Int) & bits.indices (>=8) .~ False
18:53:12 <lambdabot>  Couldn't match expected type `(a0
18:53:12 <lambdabot>                                 -> Control.Lens.Internal.Setter.Mutator GHC.T...
18:53:12 <lambdabot>                                -> p0 GHC.Types.Bool (Control.Lens.Internal.Se...
18:53:12 <lambdabot>                                                        GHC.Types.Bool)'
18:53:12 <lambdabot>              with actual type `[i0]'Couldn't match expected type `GHC.Arr.Arr...
18:53:20 <haasn> oh screw your indices :(
18:53:50 <prooftechnique> @fresh
18:53:51 <lambdabot> Hamc
18:53:58 <prooftechnique> What does that do?
18:54:23 <prooftechnique> @fresh
18:54:23 <lambdabot> Hamd
18:54:47 <prooftechnique> Well, I guess I know what it does now, I suppose I actually want to know why
18:55:15 <haasn> So you can generate fresh identifiers when you really can't figure out what to name your module? :)
18:55:46 <prooftechnique> Haha, fair enough
18:57:05 <haasn> (it's not to be taken entirely seriously)
18:57:46 <haasn> (but then again, lambdabot is not the most serious bot out there, at times)
18:57:55 <haasn> > cake !! 40
18:57:57 <lambdabot>  Not in scope: `cake'
18:57:57 <lambdabot>  Perhaps you meant one of these:
18:57:57 <lambdabot>    `take' (imported from Data.List),
18:57:57 <lambdabot>    `Seq.take' (imported from Data.Sequence),
18:57:57 <lambdabot>    `BSLC.take' (imported from Data.ByteString.Lazy.Char8)
18:57:59 <haasn> WHAT
18:58:07 <haasn> Who got rid of cake from L.hs?
18:58:23 <haasn> The cake is a .. sorry
19:20:53 <prooftechnique> haasn: A Lie algebra?
19:38:38 <ski> @yhjulwwiefzojcbxybbruweejw
19:38:39 <lambdabot> "\""
19:39:25 <ski> @palomer
19:39:26 <lambdabot> (_|_)
19:39:31 <dwcook> @what
19:39:31 <lambdabot>  @where <key>, return element associated with key
19:39:47 <ski> @where @where
19:39:47 <lambdabot>  @where @where
19:39:57 <dwcook> @. @where @where @where
19:39:57 <lambdabot> Plugin `compose' failed with: Unknown command: "@where"
19:40:04 <ski> @ghc
19:40:04 <lambdabot> Too many parameters for class
19:40:07 <prooftechnique> What on earth is palomer?
19:40:13 <ski> s/What/Who/
19:40:20 <prooftechnique> Also fair
19:40:30 <ski> @help palomer
19:40:30 <lambdabot> palomer. Sound a bit like palomer on a good day.
19:40:39 <ski> @keal
19:40:39 <lambdabot> you need a Zh function in Haskell
19:40:51 <ski> @keal
19:40:51 <lambdabot> haskell always said undefined
19:40:53 <prooftechnique> Ah, now I get it
19:41:00 <prooftechnique> Thanks ircbrowse
19:41:08 <haasn> @help yhjulwwiefzojcbxybbruweejw
19:41:08 <lambdabot> V RETURNS!
19:41:16 <ski> ta-daa !
19:41:45 <dalaing> If I want to use the bound library with a GADT, am I out of luck?  am I right in thinking that an indexed monad would be needed for the GADT?
19:41:49 <ski> @yhjulwwiefzojcbxybbruweejw
19:41:49 <lambdabot> Exception: <<loop>>
19:43:33 <prooftechnique> I do not get the yhjulwwiefzojcbxybbruweejw joke, though
19:43:46 <prooftechnique> First reference 2006. Yeesh
19:43:48 <khyperia> what... the heck, lambdabot
19:44:34 <prooftechnique> Oh, now I do
19:44:41 <prooftechnique> @v
19:44:41 <lambdabot> Exception: <<loop>>
19:44:55 <prooftechnique> Though I guess I still don't know where it comes from
19:45:26 <ski> @yow
19:45:26 <lambdabot> Did I say I was a sardine?  Or a bus???
19:45:40 <prooftechnique> @b52
19:45:41 <lambdabot> It's a dreary downtown day, but at the end of my 40 foot leash is my little friend quiche.
19:46:25 <thebnq> @yarr
19:46:25 <lambdabot> Avast!
19:46:55 <Welkin> @lol
19:46:55 <lambdabot> Maybe you meant: yow url roll pl let do
19:47:04 <Welkin> @yow
19:47:05 <lambdabot> I left my WALLET in the BATHROOM!!
19:47:10 <Welkin> @yow
19:47:10 <lambdabot> Hmmm ... a CRIPPLED ACCOUNTANT with a FALAFEL sandwich is HIT by a
19:47:10 <lambdabot> TROLLEY-CAR ...
19:47:42 <ski> @arr
19:47:42 <lambdabot> I want me grog!
19:47:55 <Welkin> @das
19:47:56 <lambdabot> Maybe you meant: faq docs do ask
19:48:02 <Welkin> @help
19:48:03 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
19:48:08 <Welkin> @list
19:48:08 <lambdabot> What module?  Try @listmodules for some ideas.
19:48:27 <ski> @help list
19:48:27 <lambdabot> list [module|command]. Show commands for [module] or the module providing [command].
19:49:26 <thebnq> @help yarr
19:49:26 <lambdabot> yarr. Talk to a scurvy pirate
19:51:08 <thebnq> > let x = show x in x
19:51:09 <lambdabot>  "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\...
19:51:23 <khyperia> that's a lot of backslash
19:51:31 <thebnq> i don't even
19:52:06 <khyperia> > show "hello" ++ " and " ++ show "\"hello\"" -- these combine over and over again to produce that result
19:52:07 <lambdabot>  "\"hello\" and \"\\\"hello\\\"\""
19:52:38 <thebnq> yea, its weird to think about
19:52:41 <Welkin> ?
19:52:44 <Welkin> how does  that works?
19:52:47 <Welkin> work*
19:53:04 <geekosaur> let is recursive, so it's trying to solve the equation x = show x. which is a nonterminating but lazy expression giving you an infinitely nested set of quotes
19:53:04 <khyperia> the Show String instance adds quotes and escapes any quotes found
19:53:28 <haasn> > fix error
19:53:29 <lambdabot>  "*Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *Ex...
19:53:44 <khyperia> wahaha, I actually laughed out loud, haasn
19:54:57 <ski> > read (fix show) :: String
19:55:00 <lambdabot>  mueval-core: Time limit exceeded
19:55:16 <haasn> > fix read
19:55:20 <lambdabot>  mueval-core: Time limit exceeded
19:57:11 <ski> @. where where @where
19:57:11 <lambdabot>  @where @where
19:57:23 <ski> @@ @where @where @where
19:57:23 <lambdabot>  @where @where
19:57:27 <prooftechnique> > fix (+1)
19:57:28 <ski> dwcook ^
19:57:31 <lambdabot>  mueval-core: Time limit exceeded
19:57:38 <bms1> Okay, so I'm trying to make a combinator library for serialization to human-readable formats
19:57:48 <ski> > seq (fix Succ) ()
19:57:50 <lambdabot>  ()
19:57:53 <bms1> And I've run into a sort of syntax brick wall
19:58:15 <bms1> My code looks like this:
19:58:18 <bms1> http://lpaste.net/101913
19:58:51 <bms1> But it gets very hairy when you try to do a lot of things.
19:59:03 <bms1> Arrow syntax seems like it would almost be perfect for this
19:59:17 <bms1> But alas, my profunctor Seralizer is not an arrow
19:59:22 <khyperia> > succ True -- why does this fail? Why doesn't it go to False?
19:59:23 <lambdabot>  *Exception: Prelude.Enum.Bool.succ: bad argument
20:00:02 <ion> khyperia: Enum is bad in general.
20:00:04 <bms1> khyperia: succ and pred are used in range constructors, i.e. [1..10]
20:00:22 <Hafydd> Yes, you might even say that...
20:00:22 <ion> I agree with not going to False but i don’t agree with it being bottom.
20:00:22 <thebnq> enums don't wrap i guess
20:00:25 * Hafydd puts on sunglasses.
20:00:28 <Hafydd> It succs.
20:00:30 <geekosaur> yes, it's not cyclic
20:00:30 <haasn> khyperia: it's an Enum law that if a type is also Bounded, succ maxBound must result in an exception
20:00:32 <ion> YEEEEEEEEEEEEEAH
20:00:35 <bms1> oh
20:00:36 <haasn> > maxBound :: Bool
20:00:37 <lambdabot>  True
20:00:42 <khyperia> ah
20:00:59 <khyperia> Wow, Hafydd.
20:01:03 <geekosaur> there have been several attempts at refiguring Enum and Bounded, none of which are ever likely to happen. :(
20:01:12 <haasn> I actually like Ix.
20:01:19 <thebnq> haha, Hafydd
20:01:19 <geekosaur> (Enum and Bounded are conflating a bunch of distinct use cases incorrectly)
20:02:20 <haasn> > range (False, True)
20:02:21 <lambdabot>  [False,True]
20:02:59 <haasn> the major shortcoming is probably lack of an instance on Double, but I really don't like that instance either way. Wouldn't be too worried using iterate (+1) or whatever for Double
20:03:02 <khyperia> > [False..True] -- so, wait, does this work?
20:03:03 <lambdabot>  A section must be enclosed in parentheses thus: (False.. True)Not in scope: ...
20:03:09 <ski> > [False .. True]
20:03:10 <lambdabot>  [False,True]
20:03:12 <ski> > [() .. ()]
20:03:13 <lambdabot>  [()]
20:03:25 <thebnq> its a face!
20:03:56 <khyperia> so wait a minute, why did my thing fail?
20:04:08 <Hafydd> @src range
20:04:09 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
20:04:18 <haasn> @src Ix
20:04:19 <lambdabot> class (Ord a) => Ix a where
20:04:19 <lambdabot>     range           :: (a,a) -> [a]
20:04:19 <lambdabot>     index           :: (a,a) -> a -> Int
20:04:19 <lambdabot>     inRange         :: (a,a) -> a -> Bool
20:04:19 <lambdabot>     rangeSize       :: (a,a) -> Int
20:04:44 <bms1> khyperia: Because False is a data constructor. So it's looking for a module called False, with a function False..
20:04:57 <ski> bms1 : operator
20:05:51 <khyperia> ah
20:06:08 <ski> @type (Prelude.. cos)
20:06:09 <lambdabot> Floating b => (b -> c) -> b -> c
20:06:18 <ski> @type (False.. True)
20:06:19 <lambdabot> Couldn't find qualified module.
20:07:16 <zRecursive> :t cos
20:07:16 <lambdabot> Floating a => a -> a
20:07:43 <prooftechnique> @nixon
20:07:43 <lambdabot> You won't have Nixon to kick around anymore, because, gentlemen, this is my last press conference.
20:10:40 <bms1> So is anyone thinking about how to make a good syntax for something like this (http://lpaste.net/101913)?
20:10:52 <bms1> The andThen function is used to read/write things serially
20:11:15 <bms1> But if you use it repeatedly, you get nested tuples like (a, (b, (c, d)))
20:11:35 <bms1> It would be really nice to have some sort of pointful syntax that I could use, but I haven't found a way to do that
20:11:55 <dmj`> Is terminateProcess the only way to close a ProcessHandle?
20:12:06 <bms1> It's sort of the same problem that arrow syntax solves, but I need something more restrictive than arrows
20:13:19 <thebnq> bms1: maybe just an infix operator?
20:13:57 <bms1> thebnq: well the types are nasty; let me go write a quick example
20:18:01 <bms1> So I just updated it http://lpaste.net/101913 with an example of sequencing three different things. You have to do some annoying pre- and post-plumbing to get nice tuples. And more complicated structures makes these even worse
20:18:13 <bms1> the function is 'threeInARow' at the end there
20:34:11 <Cale> bms1: Have you looked at Control.Applicative?
20:34:34 <Cale> Well... hmm
20:34:43 <bms1> Cale: Sure... but I don't see what could help there
20:35:00 <Cale> In this case, you may need a generalisation of what's going on there, because you have two type parameters
20:35:32 <thebnq> you said repeated apps get (a, (b, (c, d))), but what do you want instead?
20:35:39 <bms1> Cale: Well I made it an instance of Profunctor, which sort of gets the input/output relationship of the types
20:36:04 <bms1> thebnq: Well, basically, I'd want (a,b,c,d). I think I'd want a sort of point-ful notation like arrow syntax
20:36:40 <bms1> let's say I want to build in a constant string to the text I write: that becomes a Serializer () (), since it's actually informationless
20:36:45 <thebnq> but then you could only sequence up to how big tuples can go
20:37:03 <bms1> Those tuples, with many of them simply being () would be very hairy
20:37:08 <Cale> Nobody really uses tuples larger than pairs anyhow
20:37:36 <Cale> (maybe there's the occasional triple, I suppose)
20:37:47 <bms1> Well, the idea is that you could have a data structure, pattern match the things you want, and put them in the appropriate places
20:37:59 <Cale> Really, when you start to have more fields, it becomes much better to define your own data types
20:38:11 <bms1> There's this real symmetry going on; like look at parseText and writeText
20:38:43 <thebnq> like lens?
20:38:50 <bms1> They're really similar, but in one, we produce a list xs, and in the other, we consume it
20:38:58 <bms1> thebnq: Yeah, very much like lens
20:39:20 <bms1> (both involve profunctors http://hackage.haskell.org/package/profunctors-3.1.2/docs/Data-Profunctor.html)
20:39:53 <xpika> does anyone know how to obtain the code that makeLens generates using template haskell in the lens library?
20:39:53 <thebnq> yea
20:39:53 <Cale> Have you seen http://research.microsoft.com/pubs/64036/picklercombinators.pdf ?
20:40:49 <bms1> Cale: No; that looks a whole lot like what I want looking really briefly!
20:41:45 <bms1> Cale: Yep, that's definitely what I'm looking for. Thanks for sharing the link!
20:42:36 <Cale> No problem! :)
20:43:19 <thebnq> Looks interesting
20:43:34 <prooftechnique> I do like a nice pearl
20:43:35 <thebnq> i wonder if pickling is a pun on something
20:44:54 <sjy> i don't think it's really a pun, but an analogy to the preservation of food by pickling
20:45:20 <thebnq> maybe, but thats a one way process :b
20:45:38 <sjy> haha, good point
20:46:06 <prooftechnique> Wiki suggests the term comes from Python
20:46:10 <sjy> this reminds me of a recent debate in another channel about the semantics of a flush action
20:46:18 * carter now knows more aobut the ghc build system than he wants to
20:46:27 <thebnq> it mentions oracle's DB first
20:46:46 <bms1> hmm, I thought maybe it was this http://en.wikipedia.org/wiki/Rundown (you run back and forth between the bases...)
20:47:06 <prooftechnique> carter: That's pretty neat, though :)
20:47:41 <Cale> bms1: For a use of the technique in a real library, you might also want to see hexpat-pickle
20:47:50 <carter> false
20:47:51 <carter> i hate it
20:47:56 <carter> prooftechnique: did you hear back yet?
20:48:07 <carter> prooftechnique: you should come to hac nyc if you can!
20:48:08 <prooftechnique> I thought it seemed most likely to come from Perl, honestly, but I couldn't find any references
20:48:19 <prooftechnique> carter: When is it? I was actually thinking the same
20:48:25 <carter> april 4-6
20:48:37 <carter> http://www.haskell.org/haskellwiki/Hac_NYC
20:48:43 <prooftechnique> Hmm. Might be able to pull it off
20:48:44 <carter> http://www.haskell.org/haskellwiki/Hac_NYC#Accommodation
20:48:49 <prooftechnique> Depends how much money I have
20:49:15 <carter> yeah
20:49:16 <carter> no pressure
20:49:31 <carter> theres gonna be hacphi this year i think, right byorgey ? :)
20:49:36 <prooftechnique> I would definitely love to go, though
20:49:44 <prooftechnique> Hac Phi might be more likely, really
20:50:45 <carter> haskell will be around next year
20:50:46 <carter> soooo
20:50:49 <carter> do other shit
20:50:50 <carter> :)
20:50:57 <carter> dont burn money you don't have
20:51:28 <copumpkin> Cale, bms1: you see my ridiculous pseudopicklers?
20:51:36 <prooftechnique> Hehe.
20:52:20 <bms1> copumpkin: I don't think so?
20:52:25 <copumpkin> https://github.com/copumpkin/java/blob/master/src/Java/Bytecode/Encoding.hs#L79
20:52:26 <prooftechnique> I joined the hackathon mailing list, so at least I'll be up to date on the goings-on. Maybe I'll try to start one in my area
20:52:35 <carter> what mailing list?
20:52:44 <copumpkin> bms1: I've never liked that pickler paper's approach to sums
20:52:45 <prooftechnique> hackathan@haskell
20:52:47 <Cale> copumpkin: I haven't
20:52:48 <prooftechnique> *thon
20:53:07 <copumpkin> bms1: I don't particularly like my implementation of sums either, but I like it better than theirs :)
20:53:26 <carter> copumpkin: egads
20:53:27 <bms1> sums as in Either?
20:53:38 <copumpkin> yeah, or arbitrary ones
20:53:46 <prooftechnique> copumpkin: Yeesh
20:53:48 <copumpkin> I didn't want to squeeze all my types through the funnel of pairs/either
20:54:02 <copumpkin> the motivation for my particular set up (as it is right now) is in the README in the root of the project
20:54:12 <copumpkin> still very much in flux and I don't like it much
20:57:03 <Heather> hi
20:57:13 <Heather> is it possible to have shared module in haskell?
20:57:13 <copumpkin> hi Heather
20:57:24 <copumpkin> shared module in what sense?
20:57:30 <Heather> alike dll
20:57:46 <Heather> I want to have one big dll and many exe programs which is using it
20:57:57 <Heather> e.g. I don't want to compile lib into all exe files
20:58:11 <jle`> you mean dynamic vs static linking?
20:58:17 <copumpkin> yeah, GHC supports dynamic libraries, but I don't know if that works well on Windows
20:58:22 <bms1> copumpkin: Ahh, it's those two definitions of gerr and putter in, for example, tableswitch and lookupswitch. In an ideal world, you could write the getter and putter in one go, and you'd have the safety of knowing that the getter matches the putter
20:58:23 <Heather> jle`: kind of
20:58:39 <copumpkin> bms1: no, that's what I'm doing there :)
20:59:02 <jle`> Heather: what makes it different from dynamic linking?
20:59:21 <copumpkin> bms1: tableswitch and lookupswitch were complicated so my framework didn't support doing getter/putter simultaneously, but everything else in that file is simultaneously defining both putters and getters
20:59:30 <luvfp> http://lpaste.net/101922  any help on how i can improve this please?
20:59:42 <copumpkin> bms1: if you look at my readme you'll see that I don't like that I have to even do those ones manually
20:59:42 <Heather> jle`: I don't know how it works in haskell
20:59:56 <copumpkin> bms1: but at least I'm minimizing the amount of duplication there
21:00:12 <Heather> jle`: should I simply install library with --enable-shared ?
21:00:43 <prooftechnique> luvfp: Any particular things you don't like about it?
21:01:28 <bms1> copumpkin: Right - you succeed in doing it where it's like a single type that you're pickling
21:02:03 <copumpkin> bms1: I can do simple products too, not just sums. It's the ones that do weird things that I can't do nicely :/
21:02:06 <luvfp> prooftechnique: Hi again.  I dont know, but it looks like there should be a way to make all those calls to randomR can be improved.  This is almost a literal translation from the C function I was trying earlier today
21:02:15 <copumpkin> bms1: and they all compose as one might expect
21:02:33 <Heather> jle`: copumpkin: is there some examples with shared libraries?
21:02:48 <luvfp> prooftechnique: without putting the gen function in IO
21:02:48 <copumpkin> I dunno, haven't used them myself, just know that people worked on making them work
21:02:51 <bms1> copumpkin: right
21:03:18 <prooftechnique> luvfp: Well, since you're just using newStdGen, you could make them all into randomRIO and not have to pass around the generators, I suppose
21:03:22 <copumpkin> bms1: you should see the ugly machinery that goes into even what you see there :P
21:04:01 <prooftechnique> I prefer your current purer implementation, though
21:04:24 <luvfp> prooftechnique:  the basic purpose of that function is to return a value in a desired range with a given probablity and outside the range with 1 - desiredProb
21:05:12 <luvfp> tomorrow I will change it to use a seed
21:05:52 <bms1> copumpkin: I do like your interesting lists, though I definitely don't understand them yet
21:06:02 <prooftechnique> luvfp: The only thing I would suggest is more a personal style thing, and that's ordering the definitions from highest level to lowest (i.e., result up top, then proceeding downward
21:06:42 <copumpkin> bms1: it's kind of a tough problem, since construction is more "first class" than destruction for any given type in Haskell
21:07:14 <jle`> luvfp: you can use guards instead of if/then
21:07:29 <copumpkin> lenses/prisms give you some notion of first-class pattern, but they don't really fall through efficiently
21:07:30 <prooftechnique> That's a good point, too
21:07:44 <edwardk> sadly
21:07:46 <luvfp> jle`: guards inside the function?
21:08:15 <jle`> luvfp: outval | rsel2 < minDesired p = rlower | otherwise = rhigher
21:08:49 <copumpkin> edwardk: could you do it better if you had an autogenerated eliminator like what I'm using?
21:08:57 <copumpkin> I still don't see how that'd work
21:09:00 <copumpkin> but perhaps you would :P
21:09:10 <edwardk> copumpkin: doing better really needs 'bokeh' prisms
21:09:16 <jle`> luvfp: have you considered using the Random monad or the State monad?
21:09:22 <copumpkin> lol
21:09:48 <edwardk> we know how to do lenses with an explicit bokeh, the prism construction would be dual.
21:09:48 <luvfp> As of now I dont know how to use those well
21:09:53 <jle`> luvfp: you're only doing 5 generations so it's not that bad...but...it makes it a little prone to bugs if you do it by hand
21:09:56 <jle`> luvfp: ah
21:09:58 <copumpkin> edwardk: bokeh being what here?
21:10:02 <prooftechnique> edwardk: What did you study when you went back to school for math? What texts did you like?
21:10:06 <jle`> luvfp: well, it's more or less exactly what you are doing now, except it handles the plumbing for you
21:10:18 <luvfp> jle`: I will have to do a lot more of those in other functions
21:10:32 <jle`> the best thing about random/state monad is composable
21:10:34 <luvfp> this is just the first function I considered for porting from old C code
21:10:35 <jle`> *is that it's composable
21:10:47 <jle`> meaning that if you have a bunch of separate random functions
21:10:51 <jle`> you can compose them into one giant one easily
21:10:56 <jle`> threading the state through every one sequentially
21:11:03 <edwardk> a lens for a set-like category winds up with something called a constant complement, the stuff not views by a lens s just a single existential ball of stuff with the same type regardless f the indices for s, t, etc.
21:11:20 <luvfp> jle`:  if its not much trouble could please show me a re write of the linked gen function using the Random Monad ?
21:11:21 <edwardk> that 'complement' is the bokeh of the lens, its all the stuff out of focus
21:11:34 <jle`> luvfp: no prob
21:11:46 <copumpkin> edwardk: lol, okay
21:11:50 <bms1> edwardk: Do you have a solution to this "pickling" problem? It would be nice to be able to define "getters" and "setters" for serialization, etc. in one go with some sort of "pointful" syntax
21:11:57 <prooftechnique> "the blur"
21:11:58 <luvfp> but how would I keep track of theintermediate generated values?
21:11:59 <prooftechnique> Neat
21:12:17 <bms1> my pseudo-example of how it gets hairy is here http://lpaste.net/101913 but apparently this is a well-traveled area perhaps
21:12:56 <prooftechnique> Also used in the sense of senility
21:13:03 <edwardk> prooftechnique: my math masters was a bit odd. doing it in a semester meant taking all the classes offered by the university, so there is no real rhyme or reason to my degree. ;) its half stats, some differential geometry, complex analysis, abstract algebra, fourier analysis, bioinformatics, etc.
21:13:42 <edwardk> prooftechnique: i also pretty much grabbed every math book i could get my hands on while i was there and read through at least the first few chapters until i blocked
21:13:57 <copumpkin> edwardk: not sure how bokeh prisms would help it be more efficient though
21:14:43 <edwardk> copumpkin: well it can at least start ruling out cases so you can know you've handled them all
21:14:44 <prooftechnique> edwardk: Neat. I studied a lot of that in my undergrad (which was also rather odd). Are there any texts in particular you recommend? I'm currently on a bit of a financial engineering kick, but I should probably get a little more differential geometry into my reading
21:14:51 <copumpkin> bms1: jmcarthur made some attempts the way you're doing in there
21:15:35 <copumpkin> edwardk: that'd certainly be nice, yeah
21:15:51 <jmcarthur> yeah that definitely looks a lot like mine
21:15:52 <edwardk> differential geometry i learned mostly by bouncing off kobayashi and nomizu over and over again with the help of easier books
21:16:05 <prooftechnique> Hahaha.
21:16:42 <edwardk> category theory i learned by bouncing off mac lane over and over again with the help of easier books
21:16:47 <prooftechnique> I feel like the defining characteristic of a good math education is sort of bouncing off of lots of things until things stick
21:16:56 <edwardk> abstract algebra by bouncing off serge lang's algebra..
21:17:12 <prooftechnique> edwardk: I like Lang and D&F for algebra
21:17:18 <copumpkin> jmcarthur: show your link! :D
21:17:27 <prooftechnique> Though anything Lang is pretty great
21:17:33 <xpika> edwardk: is it possible to extract the code generated from makeLenses?
21:17:40 <jle`> luvfp: why is rsel1 and rsel2 come from the same seed?
21:17:43 <prooftechnique> Having Dummit for algebra was definitely a boon
21:17:50 <jmcarthur> i don't remember it!
21:17:52 <edwardk> xpika: there is a command you can send to ghc that tells it to dump splices to stdout as well
21:18:09 <bms1> jmcarthur: So what were you doing?
21:18:14 <luvfp> they are random numbers indifferent ranges
21:18:31 <prooftechnique> xpika: -ddump-splices
21:18:43 <edwardk> prooftechnique: your asking me about books reminds me i need to unpack my math bookshelves. they are all sitting in boxes around me, and have been for months since i moved.
21:18:46 <copumpkin> bms1, jmcarthur: http://lpaste.net/100943
21:18:55 <luvfp> here is the logic. you have four numbers a <= b <=  c <= d [ all monotonically non decreasing
21:19:03 <copumpkin> bms1: that's jmcarthur's one
21:19:12 <jmcarthur> ah yeah there it is
21:19:20 <prooftechnique> edwardk: Haha, I'm in a similar position. I've taken to scanning some of them so I can back them up. OCR is helpful, too
21:19:22 <copumpkin> my general objection to that is all the "fixups" you need
21:19:28 <bms1> ahh! I tried to make my Serializer a Category, but failed miserably
21:19:39 <jmcarthur> i have many objections to it
21:19:55 <copumpkin> I have many objections to mine too :(
21:20:02 <Sgeo> http://www.happstack.com/
21:20:04 <copumpkin> we should just move to mercury
21:20:04 <Sgeo> :(
21:20:11 <luvfp> jle`: you specify a desired probability say 35% . that means you want a sample from [b,c] with a prob of 35% and a sample from [a,b) U (c,d] with prob 75%
21:20:11 <jmcarthur> it's awkward to use, hard to learn, and probably inefficient
21:20:23 <Sgeo> Why is Happstack site down
21:20:24 <Sgeo> ?
21:20:26 <prooftechnique> luvfp: "monotonically nondecreasing"?
21:20:27 <edwardk> prooftechnique: re category theory http://www.quora.com/Category-Theory/What-is-the-best-textbook-for-Category-theory?share=1
21:20:34 <copumpkin> Sgeo: I dunno, post to haskell-cafe asking?
21:20:56 <bms1> jmcarthur: But maybe it can have nice syntax!
21:21:00 <luvfp> prooftechnique:  oops.  non decreasing.   basically the numbers are either increasing or same.
21:21:13 <luvfp> as the previous number in the seq
21:21:20 <edwardk> for other domains i have very few unconditional recommendations in mathematics, calculus on manifolds, is about it ;)
21:21:20 <prooftechnique> edwardk: Yeah, I'm reading Lawvere along with MacLane. My background is mainly in algebra, so it's a pleasant combination
21:21:33 <prooftechnique> edwardk: Calc on manifolds is a great book
21:21:41 <tnks> alias ds="dirpersiststore"
21:21:41 <tnks> alias dc="dirpersistrestore"
21:21:46 <tnks> whoops.
21:21:59 <prooftechnique> edwardk: Spivak may be one of my favorite authors. His style is very approachable
21:22:05 <prooftechnique> Practically friendly
21:22:27 <edwardk> stein and shakarchi's fourier analysis stuck with me as well, but required more of the reader
21:22:57 <jmcarthur> bms1: perhaps, but not-quite-arrows (lacking arr) usually don't end up looking that great
21:23:07 <edwardk> bit niche-y though
21:23:11 <luvfp> jle`: so we draw one random from 0,100 to determine if we should pick from the desired interval, and another to determine if the sample is from the lower or upper range outside the desired interval
21:23:31 <bms1> jmcarthur: Right. That was the same problem I ran up against (though I couldn't even make my type a Category)
21:23:38 <prooftechnique> edwardk: I'll have to see if I can find a copy. I have to admit I let my analysis slip a little in favor of algebra, but I definitely enjoyed Apostol's analysis book
21:23:57 <copumpkin> I wonder if the garrow stuff would make it prettier
21:24:08 <edwardk> i try to do enough with actual concrete numbers to avoid losing knowledge of how to do it ;)
21:24:09 <copumpkin> adam megacz never responded to my email :(
21:24:13 <jmcarthur> i think garrow would make it a lot nicer, yes
21:24:17 <bms1> jmcarthur: I found that you basically could use an arrow-like syntax, but the arrows need to be something that operate different from Haskell's arrows. Like the entire inputs and outputs have to be totally separated, which is not how Arrow Syntax works in Haskell
21:24:38 <edwardk> e.g. https://github.com/ekmett/approximate/blob/master/cbits/fast.c and https://github.com/ekmett/compensated
21:24:39 <luvfp> jle`: so there is no compulsion to use the same generator but since the ranges are different, i thought using the same generator should not be a problem
21:25:03 <jle`> luvfp: i did a direct translation using monadrandom's Rand monad
21:25:04 <copumpkin> garrows are also nice because you can force a language with no discarding of values, which roughly forces it to be bidirectional
21:25:05 <jle`> http://lpaste.net/101924
21:25:06 <edwardk> even if i don't do much with actual analysis
21:25:06 <bms1> as far as math books, I like Shifrin's Multivariable Mathematics a lot as far as vector calculus
21:25:16 <prooftechnique> edwardk: Haha, I'm trying to get there. Concrete numbers are practically a distant memory for me :D
21:25:20 <luite_> luvfp: bleh your name looks way too similar to mine, i shape (only major difference a descender on the last letter), choose something else ;)
21:25:45 <edwardk> luite: there was edvardkk around here for a while. =P
21:26:18 <luite> hehe yeah i admit that's worse :)
21:26:29 <bms1> copumpkin: I'd never heard of Garrows before! Looks interesting
21:26:30 <jle`> also note that theres's also evalRandIO; evalRandIO m is the same as do { g <- newStdGen; evalRand m g }
21:26:41 <jle`> it pulls in the g for you automatically
21:27:00 <jle`> edwardk: i always think edk is you when you aren't online :/
21:27:09 <edwardk> heh him too
21:27:16 <prooftechnique> jle`: Oh, that's cool. I didn't know about that
21:28:17 <jle`> luvfp: added an example of evalRandIO
21:28:45 <luvfp> jle`: so the benefit is that i dont have to keep track of g,g1 etc right?
21:28:59 <jle`> luvfp: made another edit, left out p
21:29:06 <jle`> luvfp: yeah, that's the initial advantage
21:29:23 <jle`> the other big advantage is that random outputs are now composable
21:29:26 <jle`> random functions
21:29:49 <jle`> that you can sequence multiple random functions into one big random function easily, which can all be unwrapped/eval'd at the same time
21:30:26 <jle`> for example, say you made a giant myRandomInt that returned an Int, and a myRandomString that takes an int and returns a random string.
21:31:03 <jle`> instead of runRanding the myRandomInt, runRanding the myRandomString using the output of the first
21:31:16 <jle`> you can just evalRand (myRandomInt >>= myRandomString)
21:31:59 <jle`> and myRandomString will be run with the seed that popped out of myRandomInt.  you can compose random functions into bigger random functions, and the seed passing is handled for you behind the scenes
21:32:19 <prooftechnique> Is there something like mconcat for >>=?
21:32:38 <bms1> prooftechnique: mapM?
21:32:39 <jle`> well there's a (>>)
21:32:42 <jle`> sequence
21:32:52 <bms1> right I mean sequence
21:32:56 <jle`> sequence_, i mean
21:33:07 <prooftechnique> Ah, yeah
21:33:08 <bms1> Well, sequence to keep the results
21:33:30 <jle`> also the other big advantage is that you can now use all of Haskell's great monad combinators :)
21:33:43 <jle`> from Control.Monad.  mapM, sequence, forM, forever...all that fun stuff.
21:34:35 <bms1> As far as random sampling
21:34:56 <prooftechnique> Not to mention when
21:35:03 <prooftechnique> That's a nice one
21:35:13 <bms1> something that I wrote before:
21:35:16 <bms1> http://lpaste.net/5775149992708669440
21:35:17 <dmj`> prooftechnique: you mean like concatMapM?
21:35:24 <jle`> yea that too.  probably not as useful for Random though
21:35:29 <prooftechnique> dmj`: That might be the ticket, yeah
21:35:38 <prooftechnique> @hoogle concatMapM
21:35:39 <lambdabot> No results found
21:35:43 <dmj`> concatMapM        :: (Monad m) => (a -> m [b]) -> [a] -> m [b]
21:35:44 <dmj`> concatMapM f xs   =  liftM concat (mapM f xs)
21:35:47 <prooftechnique> Ah, okay
21:35:47 <bms1> (It's just the State monad really, but it's convenient)
21:35:52 <prooftechnique> That's pleasant
21:36:22 <jle`> oh yeah other neat functions you can do with monads is use Applicative style compositions
21:36:26 <prooftechnique> Learning to use all the lift* stuff has definitely made my code prettier
21:36:46 <jle`> luvfp: if you wanted a random ParamInfo
21:37:03 <jle`> you can do ParamInfo "random" <$> getRandom <*> getRandom <*> getRandom <*> getRandom
21:37:24 <jle`> and that'll give you a Rand StdGen ParamInfo, a random ParamInfo that you can get by eval/running the thing.
21:37:42 <luvfp> jle`:  but we need to enforce the order of the different limits
21:37:56 <jle`> luvfp: yeah, just showing an example of applicative syntax.
21:38:49 <jle`> > data Foo = Bar Int Double; randomFoo = Bar <$> getRandomR (0,100) <*> getRandomR (0,1)
21:38:49 <lambdabot>  <hint>:1:1: parse error on input `data'
21:39:02 <prooftechnique> @let data Foo = Bar Int Double
21:39:04 <lambdabot>  Defined.
21:39:13 <prooftechnique> @let randomFoo = Bar <$> getRandomR (0,100) <*> getRandomR (0,1)
21:39:14 <lambdabot>  .L.hs:166:21: Not in scope: `getRandomR'
21:39:14 <lambdabot>  
21:39:14 <lambdabot>  .L.hs:166:45: Not in scope: `getRandomR'
21:39:16 <jle`> and you can even throw that like foo <- randomFoo inside a do block, and it'll be composed, the seed passing effortlessly
21:39:23 <luvfp> jle`: lets try an example with record syntax so we can use names for the params
21:39:58 <jle`> well record assignment is sort of outside of regular syntax.
21:40:40 <jle`> but you could always do something like do { field1 <- getRandomR (0,100); field2 <- getRandomR (0,1); return (Bar field1 field2) }, which is equivalent.
21:40:51 <luvfp> @let data Foo = Foo { bar :: Int, baaz :: String }
21:40:52 <lambdabot>  .L.hs:167:6:
21:40:52 <lambdabot>      Multiple declarations of `Foo'
21:40:52 <lambdabot>      Declared at: .L.hs:165:6
21:40:52 <lambdabot>                   .L.hs:167:6
21:40:57 <prooftechnique> edwardk: compensated is neat. Is there existing work on which the idea is based?
21:41:07 <luvfp> @let data Quux = Quux { bar :: Int, baaz :: String }
21:41:08 <lambdabot>  Defined.
21:42:36 <edwardk> some. knuth's original result on how to turn a pair of floating point numbers (a,b) into (x,y) such that x = fl(a + b)  ,   x + y = a + b   and then there is a bunch of work on quad-double arithmetic. i need to fix up the Floating code. it is all horribly wrong
21:42:47 <luvfp> @let asdf = Quux { bar = getRandomR(0,100), baaz = "asdf" }
21:42:47 <lambdabot>  .L.hs:168:19: Not in scope: `getRandomR'
21:43:00 <edwardk> also i think there is an issue with my multiplier's least ulp in some cases at least someone told me there might be
21:43:20 <edwardk> i need to do a detailed analysis when i can remember how it worked
21:43:22 <luvfp> jle`: prooftechnique: thanks a lot ! i gotta go now. bye
21:43:28 <prooftechnique> edwardk: Hahaha.
21:43:37 <prooftechnique> luvfp: Glad to help.
21:43:40 <jle`> luvfp: yeah, it doesn't work there because getRandomR (0,100) is of type Rand g Double or something
21:43:54 <jle`> luvfp: you have to sequence it using >>=, >>, <*>, <$>, functions, etc.
21:47:19 <jle`> is the new typed holes syntax kinda silly?
21:47:28 <jle`> because _something is already a valid identifier
21:47:35 <jle`> the only thing that makes it a hole is if it's not yet in scope?
21:47:53 <copumpkin> the goal of holes is to get information out to you
21:48:02 <copumpkin> not to provide an identifier that fits
21:48:07 <jle`> i mean
21:48:11 <jle`> couldn't there be different syntax
21:48:18 <jle`> it shares syntax with identifier syntax
21:48:33 <jle`> and it's interpreted differently depending on what's in scope
21:48:51 <bms1> jle`: Isn't it just _? Like nothing can come after, right?
21:49:01 <prooftechnique> Yeah
21:49:11 <prooftechnique> I've been pretty thrilled with holes
21:49:30 <jle`> yeah but you can give them names too, like _hole1
21:49:34 <tryingLambdabot> @help
21:49:34 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
21:49:39 <tryingLambdabot> @list
21:49:39 <lambdabot> What module?  Try @listmodules for some ideas.
21:49:43 <tryingLambdabot> @listmodules
21:49:43 <lambdabot> activity base bf check compose dice dict djinn dummy elite eval filter free fresh haddock help hoogle instances irc karma localtime more oeis offlineRC pl pointful poll pretty quote search slap source spell system tell ticker todo topic type undo unlambda unmtl version where
21:49:44 <jle`> tryingLambdabot: you can /q lambdabot
21:50:00 <bms1> jle`: Oh, I didn't know that. That is tricky perhaps
21:50:01 <prooftechnique> I've already used them to explain some things to new Haskellers
21:50:17 <jle`> if you give them names then it overlaps syntax with identifier syntax...so...it's interpreted differently depending on what's in scope
21:50:36 <jle`> if _hole1 is in scope, it refers to _hole1; if it's not in scope, it is a typed hole
21:52:44 <dmj`> is there an iteratee library for System.Directory functions?
22:04:38 <Sgeo> :t (=$=)
22:04:39 <lambdabot>     Not in scope: `=$='
22:04:39 <lambdabot>     Perhaps you meant `==' (imported from Data.Eq)
22:06:59 <johnw> Sgeo: it wants a Conduit on both sides
22:07:21 <Sgeo> What if I don't want to care if something's a Conduit or Source or Sink?
22:07:26 <Sgeo> I want something more like >->
22:07:35 <Sgeo> Is there a reason that that shouldn't be possible in Conduit?
22:10:33 <prooftechnique> Oh, god, the bug I reported is blocking 7.8.1 according to reddit :(
22:10:37 <johnw> see Data.Conduit.Extra.Pipes
22:10:55 <jle`> prooftechnique: so you're *that* guy
22:11:06 <prooftechnique> Hahaha, it seems so
22:11:25 <Sgeo> johnw: neat, ty
22:11:30 <Javran> I have some question regarding cabal, is here the right place?
22:11:44 <prooftechnique> Javran: Sure, go for it
22:12:38 <Cale> prooftechnique: Well, better than having 7.8.1 released with awful bugs
22:12:44 <Cale> Which bug is it?
22:12:52 <prooftechnique> Cale: http://trac.haskell.org/haddock/ticket/284
22:13:43 <Javran> I have define a flag, say "vty", and I export a module name System.Foo.Bar.Vty, can I conditional export this module based on the flag?
22:13:57 <prooftechnique> Apparently Austin has a patch for it, though
22:17:15 <Sgeo> " Your cleanup function is provided a Bool parameter. If True, it means that the component ran to its normal completion. If False, it means that downstream terminated first."
22:17:30 <Sgeo> :/ Bools like that are considered ugly, aren't they?
22:17:36 <Javran> or is this the correct usage for cabal flags?
22:17:36 <Sgeo> Needing to remember which is which?
22:17:59 <johnw> Sgeo: a discrete data type is usually pretty nice
22:18:31 <prooftechnique> I suppose a more informative type could be helpful, though
22:19:02 <prooftechnique> Finished | Failed or something
22:23:52 <jle`> is there a way to wrap a tuple so that you can tell if a function applied it 'flips' the tuple?
22:24:42 <jle`> as in, you can apply a function into the wrapped tuple (like a functor)
22:24:58 <jle`> except if the function is something like (\(x,y) -> (y,x)), you can identify that it has been flipped?
22:25:03 <prooftechnique> That sounds awfully dependent type-y
22:25:28 <Hafydd> Do you mean like \(x,y) -> (Left x, Right y)?
22:25:38 <prooftechnique> Oh, that might work
22:25:59 <jle`> Hafydd: hm?
22:26:17 <jle`> do you mean i should compose that after all functions i apply?
22:26:23 <Hafydd> If a function flips a tuple like that of type (Either a a, Either a a), you will be able to tell.
22:26:40 <jle`> but could i interface it with normal functions?
22:26:51 <Hafydd> I don't know what you mean by that.
22:26:53 <jle`> could i do like (\(x,y) -> (x*2,y*2))
22:26:59 <jle`> and it'll double both items in the tuple
22:27:15 <zRecursive> why not ?
22:27:39 <Hafydd> If you wrote a functor instance for it, you could; but this seems like something you'd wrap it in temporarily.
22:28:01 <jle`> hm.
22:28:12 <jle`> i guess one problem is that if i allow people to use arbitrary functions on it
22:28:21 <jle`> then they could squash the tuple
22:28:28 <Hafydd> Er... or BiFunctor, rather.
22:28:53 <Hafydd> I think I still don't understand what you're trying to do.
22:28:58 <Hafydd> Do you have a concrete example?
22:31:01 <jle`> it's a wrapper over a tuple
22:31:21 <jle`> that you can "fmap" arbitrary functions onto, with an interface
22:31:35 <jle`> but i want to be able to tell if some mapping causes the items to be flipped
22:32:00 <jle`> specifically, if something like (\(x,y) -> (y,x)) is mapped onto it
22:32:11 <jle`> hm.
22:32:20 <prooftechnique> Trying to fill it in with holes suggests it'll be pretty wonky
22:32:20 <jle`> maybe i want to know the origin of each result
22:32:36 <jle`> so i can tell if something like (\(x,y) -> (x,x)) is mapped, too
22:33:24 <jle`> but i guess the problem is that if people can map arbitrary tuple functions onto it then you could do something like (\(x,y) -> x)
22:33:53 <jle`> and everything is out the window
22:34:40 <jle`> or even (\(x,y) -> 5)
22:34:41 <jle`> darn.
22:35:11 <prooftechnique> There might be some singleton magic you can work on it, but that's beyond me
22:35:33 <Hafydd> Or \(x,y) -> (x-y,x+y)
22:36:04 <jle`> alas
22:37:04 <jle`> maybe i can only allow certain types of functions to be mapped onto it, but then i lose the ability to take advantage of popular typeclasses
22:38:07 <Hafydd> Could you just accept two functions (f,g) which are applied like (f x, g y)?
22:40:08 <jle`> Hafydd: perhaps, but the interface has to expose the ability to use arbitrary functions on the tuple somehow.
22:40:22 <jle`> which makes this impossible kinda then
22:41:11 <Hafydd> Seemingly.
22:41:56 <prsteele> I know it is possible, but is it good form / common practice to define arbitrary sequences in terms of the Enum class?
22:42:56 <prsteele> as an egregious example, defining data Even = Even Int, succ (Even a) = (Even (a + 2)), etc
22:45:08 <jle`> i haven't seen it for Enum, but it is common to use newtypes to specify different instances for the same type
22:45:27 <jle`> Any, All, Product, Sum, etc.
22:45:35 <jle`> First, Last
22:45:50 <Hafydd> Have you not just answered your own question?
22:45:57 <Hafydd> Oh... never mind!
22:46:16 <prsteele> Hafydd: ya, I know its possible, just wasn't sure if it was tolerable
22:47:43 <Hafydd> It seems a bit foul to do it in exactly that way, given that something like [Even 1, Even 3 ..] :: [Even].
22:48:31 <prsteele> Hafydd: yes, that was a bad example. I was actually thinking about things like the Fibonacci sequence (or, harder, primes)
22:48:40 <jle`> maybe newtype DoubleSucc = DoubleSucc Int
22:48:52 <jle`> i always wanted to have a type called DoubleSucc
22:48:55 <prsteele> heh
22:49:06 <Hafydd> I can't think of a programmatic benefit of doing that for the primes.
22:49:34 <jle`> consider using instead a method dictionary of sorts
22:49:55 <jle`> data Enummber a = GetNext (a -> a)
22:50:03 <prsteele> Hafydd: neither can I. It was mostly curiosity
22:50:05 <jle`> enumAll :: Enummer a -> a -> [a]
22:50:44 <jle`> basically ever method where you need to enumerate something, pass in a data type containing information on how to enumerate it
22:51:15 <jle`> so you can have a fibEnummber with getNext getting the next fib
22:51:46 <jle`> er, data Enummer a = Enummber { getEnummber :: a -> a }
22:52:32 <jle`> getSucc
22:52:58 <jle`> you can add other methods, data Enummber a = Enummer { getSucc :: a -> a, getPrev :: a -> a }
22:56:22 * hackagebot persistent 1.3.0.6 - Type-safe, multi-backend data serialization.  http://hackage.haskell.org/package/persistent-1.3.0.6 (MichaelSnoyman)
22:56:24 * hackagebot persistent-postgresql 1.3.0.5 - Backend for the persistent library using postgresql.  http://hackage.haskell.org/package/persistent-postgresql-1.3.0.5 (MichaelSnoyman)
22:56:26 * hackagebot persistent-sqlite 1.3.0.5 - Backend for the persistent library using sqlite3.  http://hackage.haskell.org/package/persistent-sqlite-1.3.0.5 (MichaelSnoyman)
22:58:32 <dmj`> just beat 2048 :P
22:58:55 <prooftechnique> Nice
22:59:04 <prooftechnique> But can you beat the numberwang version
22:59:06 <prooftechnique> ?
22:59:40 <dmj`> http://bit.ly/1dzOUMr
22:59:48 <dmj`> numberwang version?
23:00:03 <ion> http://louhuang.com/2048-numberwang/
23:00:10 <jle`> also, http://doge2048.com/
23:00:57 <ion> http://www.sis.uta.fi/~ar72757/yhdet/
23:01:09 <Javran> I wrote a 2048 here: http://hackage.haskell.org/package/h2048 feel free to give me comments! :)
23:01:50 <ion> System.Game? :-)
23:02:29 <Javran> ion: I have no choice ..otherwise when I update to hackage candidate, there is a warning..
23:03:01 <Javran> it was Game.H2048 before..
23:03:13 <ion> Huh.
23:04:09 <jle`> hackage has that warning but i'm sure everyone ignores it
23:04:45 <pavonia> Is there an explanation on how to play that?
23:05:05 <jle`> pavonia: play what?
23:05:18 <pavonia> 2048
23:05:18 <ion> The fun is in figuring the strategy out, i think.
23:05:42 <pavonia> I'm just trying to find out what that game i all about
23:05:45 <pavonia> *is
23:06:02 <Javran> jle`: sure "Game.XXX" would be more natural, not sure if I can change the module name after I've done uploading it.
23:06:05 <dmj`> pavonia: you have to be disciplined in where and when you merge blocks
23:06:27 <jle`> pavonia: there are instructions on the main website, the original
23:06:43 <jle`> if two alike blocks touch, then they merge
23:06:44 <Javran> there's a minor bug in my game though, cannot proceed after you reach 2048 :(
23:07:32 <pavonia> jle`: Which is the original?
23:07:49 <jle`> http://gabrielecirulli.github.io/2048/
23:09:27 <pavonia> Gah, doesn't work in my browser, never mind
23:15:24 <Javran> I also want to write a GUI version, any recommended UI library?
23:16:01 <dv-> ncurses
23:16:23 <Javran> dv-: I meant GUI
23:17:02 <Javran> maybe a good chance to try FRP.. not sure ..
23:23:04 <kazagistar> I am struggling with monad transformers inside of a newtype, specifically with modifying something in a record http://lpaste.net/3287489825170522112
23:24:26 <dv-> why not derive MonadState?
23:24:35 <dmj`> Javran: http://bit.ly/1fqImdX
23:24:43 <dmj`> I'm not as good at your version :P
23:24:58 <dmj`> once those 2's pile up you're a goner
23:26:50 <kazagistar> dv-: I was trying to do some... information hiding? Where I would only provide a small subset of valid mutation operations for the stuff inside my Semantics?
23:27:56 <Javran> dmj`: I once won the game using my own version, but not lucky enough to beat the original one :(
23:28:19 <kazagistar> dv-: otherwise I would probably just use a type synonym... but maybe I misunderstood that advice from somewhere else?
23:28:36 <Javran> dmj`:  http://ww2.sinaimg.cn/large/712120efjw1eer6dzgdvcj20l40dzq3h.jpg
23:28:52 <dmj`> Javran: wow very nice. Good job on the game, it's cool
23:29:15 <Javran> dmj`: great that you enjoy it!
23:31:35 * hackagebot shakespeare-css 1.0.7.4 - Stick your haskell variables into css at compile time.  http://hackage.haskell.org/package/shakespeare-css-1.0.7.4 (MichaelSnoyman)
23:41:38 * hackagebot basic-prelude 0.3.7 - An enhanced core prelude; a common foundation for alternate preludes.  http://hackage.haskell.org/package/basic-prelude-0.3.7 (MichaelSnoyman)
23:42:08 <ion> > unfoldr (\n -> Just (numerator n, 1/(1+n))) 0
23:42:10 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
23:45:00 <dmj`> ion: nice
