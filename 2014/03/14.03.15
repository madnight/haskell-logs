00:01:23 <Twey> erisco: No, updates never block in FRP
00:01:33 <erisco> why? I don't see why that is inherent
00:01:36 <Twey> (… I think)
00:01:59 <erisco> I can certainly see plenty of undesirable things if you don't account for it
00:02:00 <Twey> I don't think it's inherent in the model, but it would be quite weird
00:02:29 <Twey> You wouldn't be able to re-order events any more
00:02:44 <Twey> (since only the currently-handled event would ever exist)
00:03:00 <erisco> not sure what you mean
00:04:14 <Twey> In reactive-banana at least, you can take a group of n events that occur ‘at the same time’ and re-order them
00:04:57 <erisco> that's one thing, but, imagine you have two threads polling two devices
00:05:09 <erisco> and updating the state of the program
00:05:12 <Twey> If updating blocked then there would never be such events; only one event would ever exist in the system at any one time, so whichever one was determined to fire first would have to be handled in its entirety before handling the next
00:06:54 <Twey> erisco: The network runs in a single thread; is that what you're asking?
00:07:03 <erisco> what do you mean by network?
00:07:39 <Twey> The system that handles dispatching and transforming events
00:07:47 <Twey> And tracking behaviours
00:08:05 <erisco> okay, so are you saying that updating blocks?
00:08:36 <Twey> … I don't know; is that your definition of ‘updating blocks’?
00:08:43 <akurilin> Hey folks, are there any "must have" vim plugins for Haskell? I'm thinking something that'd make indentation smarter etc.
00:08:46 <Twey> It's certainly not what I'd mean by that
00:09:06 <Nyyx> is there a portable haskell vm
00:09:21 <Nyyx> something that compiles to portable bytecode
00:09:51 <erisco> Twey, if only one change can propogate at a time, then I would consider that to be blocking
00:10:46 <Twey> erisco: It's possible to submit one event whilst or before another is being processed.  However, the events themselves, within the network, are necessarily handled in some defined order.
00:10:53 * hackagebot tianbar 0.3.3.0 - A desktop bar based on WebKit  http://hackage.haskell.org/package/tianbar-0.3.3.0 (AlexeyKotlyarov)
00:10:53 * hackagebot ghc-mod 3.1.7 - Happy Haskell Programming  http://hackage.haskell.org/package/ghc-mod-3.1.7 (KazuYamamoto)
00:10:59 <Twey> (or all hell would break loose)
00:11:00 <erisco> Twey, a defined order is one thing
00:11:33 <erisco> that does not mean that one update has to push all the way through before another is started
00:11:56 <Twey> erisco: Because that doesn't happen, like I said
00:12:14 <erisco> we seem to be talking past each other XD
00:14:11 <Twey> erisco: This is what I thought you were asking in the first place, but when I answered it originally you started talking about something else :þ
00:16:39 <erisco> Twey, I am particularly interested in the state being updated concurrently
00:17:41 <Twey> erisco: What do you mean by ‘the state being updated concurrently’?  You mean having two threads writing to the same behaviour at the same time?  You'd get invalid values in your behaviour
00:18:27 <Twey> erisco: You have to process the events one at a time (at each behaviour), i.e. the network has to run in a single thread
00:18:41 <Twey> Behaviour updates must be atomic
00:19:20 <Twey> OTOH you can most certainly have multiple events in the network at the same time
00:19:40 <erisco> otoh?
00:19:55 <Twey> On The Other Hand
00:21:30 <Twey> If behaviour updates aren't atomic, then you end up with half of one value and half of the other in the same memory cell, which might not even represent a valid value of the type the cell is supposed to contain — just like if you try to write into a block of memory with two threads at once
00:23:19 <erisco> that in particular would have to be atomic, yes
00:23:52 <Twey> Okay
00:23:58 <Twey> Does that answer your question?
00:24:32 <erisco> no
00:24:44 <erisco> but that's okay
00:25:55 <Twey> I'm not sure where else you expect concurrency to occur :þ
00:26:23 <erisco> in the propogation
00:28:44 <Twey> So, you have an event E in the network, that feeds into a behaviour B.  Two separate threads call E at the same time.  B gets a notification and reads the values given to the event, atomically in some order.
00:29:35 <Twey> Or rather, the network notices that B needs updating and sets it to some value depending on the event values
00:30:57 <Twey> There isn't really room for concurrency — despite the naming, there isn't actually a ‘wire’ along which two event values can travel at once.  They appear in the event, and then the behaviour gets set accordingly.
00:31:33 <erisco> I think there is but I suppose I'll have to do more thinking on it
00:32:49 <erisco> I thought there would have been more work done on this
00:40:52 * hackagebot tasty 0.8.0.2 - Modern and extensible testing framework  http://hackage.haskell.org/package/tasty-0.8.0.2 (RomanCheplyaka)
00:40:54 * hackagebot FTGL-bytestring 2.0 - Portable TrueType font rendering for OpenGL using the Freetype2 library  http://hackage.haskell.org/package/FTGL-bytestring-2.0 (seagull)
01:16:32 <pyon> Is there any parser combinator library that lets you process streams of actual tokens in your language (instead of streams of Chars or Word8s or whatever)? More specifically, if I backtrack, I do not mind having to reparse (after all, that is why I am backtracking), but I do not want to have to relex.
01:17:40 <Feuerbach> parsec can do that
01:21:09 <pyon> Mmm... Can Parsec be fed input incrementally?
01:21:48 <Feuerbach> no
01:31:02 * hackagebot haskell-names 0.3.3 - Name resolution library for Haskell  http://hackage.haskell.org/package/haskell-names-0.3.3 (RomanCheplyaka)
01:49:07 <kxra> are there any Gnome OPW or GSoC organizations that i could gain haskell eperience with?
01:52:09 <Javran> how can I read arrow keys? getChar gives me 'A','B','C','D's when I type arrow keys.
01:54:23 <Iceland_jack> Javran: getChar should give you more than just that
01:54:42 <Iceland_jack> If you really want to read arrow keys you probably want something similar to ncurses
01:55:11 <Iceland_jack> maybe you want Haskeline, who knows
01:55:29 <SrPx> So monads were kinda created to solve a problem that we didn't know we have
01:56:01 <tikhon> SrPx: not really
01:56:04 <Javran> Iceland_jack:  I see, thanks
01:56:44 <Iceland_jack> Javran: 'Up' should give you "\ESC[A" for example, which consists of three characters
01:57:10 <Iceland_jack> SrPx: (If you think monads are only useful for IO then that's wrong)
01:57:25 <SrPx> <it was a joke btw>
01:58:17 <Iceland_jack> SrPx: I see :) couldn't tell from context, that's why text is so good for conveying jokes /s
01:58:25 <tikhon> it falls afoul of Poe's law though—too close to what people actually believe
02:03:42 <Javran> Iceland_jack: ok, that works
02:06:02 <Iceland_jack> Javran: Why do you want to read the arrow keys from stdin?
02:08:03 <Javran> Iceland_jack: I'm writing a CLI toy game
02:08:07 <Iceland_jack> If you want a prompt which allows the user to go back and forward in what they've written you might want to look at Haskeline (Haskell version of ‘readline’)
02:09:31 <Javran> Iceland_jack: arrow keys in that game just mean movements, maybe I don't need a readline.
02:10:15 <tikhon> Javran: it sounds like what you're doing would benefit from a framework like ncurses rather than doing all the terminal management yourself
02:10:40 <Iceland_jack> Fair enough, it sounds like something like a TUI (‘text-based user interface’) is what you'd want
02:10:52 <tikhon> I've never used it myself, but this package is probably what you want: http://hackage.haskell.org/package/hscurses
02:11:11 <tikhon> I think most games that run in the terminal (roguelikes and such) are built using curses
02:12:01 <tikhon> it's probably different if you're making a primarily text based game like Zork—but for something like that, you wouldn't want to use the arrow keys
02:14:04 <Javran> well, the only key used is arrow keys and 'q', so I'm thinking about implementing it in a quick & dirty way, and then taking ncurses into account.
02:14:34 <tikhon> Javran: how do you update the display?
02:14:49 <tikhon> if you want an interactive map type thing, ncurses is definitely the way to go
02:16:00 <Javran> I just print that out for now, but yes that should be more comfortable to use ncurses or something like that.
02:16:45 <tikhon> ultimately, I think that trying to rebuild some of the ncurses functionality (like arrow key support) is going to be somewhat difficult and tedious without giving you much value
02:17:05 <tikhon> of course, I say this partly because I don't really know how to deal with arrow keys from stdin and because it seems pretty annoying
02:17:07 <Iceland_jack> It might be a nice way to learn
02:17:30 <tikhon> maybe I'm just young, but the innards of how terminals work isn't high on my list of things to learn :P
02:17:55 <Iceland_jack> ‘innards’ is an apt word
02:18:37 <tikhon> I'm also biased because I use a shell which doesn't even pass arrow keys on to the program. Then again, it doesn't work with curses either :/
02:20:56 <Iceland_jack> Javran: You may want to look at System.Posix.Terminal
02:21:48 <Iceland_jack> and ProcessInput
02:22:20 <Javran> Iceland_jack: ops..that looks complicated..
02:32:43 <u-ou> i never considered that (->) was a type constructor, but of course it is
02:33:32 <u-ou> :t (->)
02:33:33 <lambdabot> parse error on input `->'
02:33:48 <daniel-s> In lambda calculus, does arity just mean the number of parameters a function takes?
02:33:48 <tikhon> :k (->)
02:33:49 <lambdabot> * -> * -> *
02:33:58 <tikhon> daniel-s: yep
02:34:08 <tikhon> although, technically, all functions have *one* parameter
02:34:28 <tikhon> but functions can either be curried or take a tuple, which is what we usually call having multiple parameters
02:34:37 <u-ou> yes
02:36:46 <nisstyre> tikhon: I think there are some variants of LC that admit multiple parameters
02:36:54 <nisstyre> not sure how useful they are
02:37:39 <nisstyre> well, the transformation back and forth from curried/non-curried functions is easy enough
02:40:29 <tikhon> the nice thing about thinking of multiple arguments as a single tuple value is that they become first-class values. So if you have f(x, y) = x^2 + y^2, you can map it over [(1,2), (3,4), (5,6)].
02:40:42 <tikhon> the nice thing about currying, of course, is partial application
02:40:56 <tikhon> I'm not sure what the advantage of having multiple arguments built into the language would be
02:41:18 <tikhon> and I doubt it would compensate for the advantages of the uncurried and curried forms of functions
02:42:59 <daniel-s> tikhon: Could you say that a function that takes two parameters "f = \lambda v_0 v_1 e" could be broken down into two steps. So, "f 1 2" takes 2, replaces v_1 within e, which then creates a new funciton of 1 parameter, this function then takes the 1 and replaces v_0 in e?
02:43:42 <daniel-s> Then after this, the function is just evaluated down to a single expression?
02:44:30 <nisstyre> daniel-s: function application gets desugared to ((f a) b) and function definitions get desugared to f = \a -> \b -> body
02:44:43 <nisstyre> it's as simple as that
02:45:46 <jle`> tikhon: one advantage of non-curried is also easy default parameters
02:46:13 <jle`> i understand that ocaml, a curried language, has default arguments with some special syntax
02:46:43 <jle`> but i don't think it's as natural as the default arguments in normal languages without baked in partial pplication
02:47:26 <tikhon> hmm
02:47:37 <tikhon> in practice, default parameters are a bit of a pain unless you have named arguments
02:47:48 <tikhon> and named arguments work pretty well in OCaml
02:48:10 <tikhon> (although I feel like they have the propensity to overuse them)
02:48:32 <nisstyre> I don't miss them from Python
02:49:36 <nisstyre> a better way would be just to pass in `def`
02:49:46 <nisstyre> and make the type an instance of Default (obviously)
02:49:55 <jle`> there are pockets of the haskell community that questions curry-by-default
02:50:01 <jle`> *question
02:51:04 <nisstyre> jle`: I don't see what could possible be bad about it, it makes the compiler implementation simpler, there is no syntactic difference, it makes things easier to write
02:51:09 <nisstyre> *possibly
02:51:41 <nisstyre> if you're going to question something question lazy evaluation
02:51:46 <jle`> i am not one of those people, but one of their bigger arguments is default parameters, and having currying be explicit instead of implicit
02:51:52 <nisstyre> yeah I know
02:52:21 <nisstyre> jle`: well, then you end up witty "curry" repeated 100 times in your code
02:52:26 <companion_cube> jle`: there is no issue with default parameters and currying as long as you have at least one non-named argument
02:52:52 <eatman> Hello.
02:54:49 <jle`> i cannot defend them :/
02:54:51 <jle`> eatman: hello
02:57:19 <pyon> Why is there a functional dependency from the stream type on the token type in libraries like Parsec and Parsimony?
02:58:12 <Fuuzetsu> no curry by default makes writing such ‘exotic’ functions like flip a pain in the ass to write and makes anything point-free PITA as well
02:58:42 <tikhon> I've used Racket where currying is explicit, and it's absolutely *horrible*
02:59:35 <tikhon> consider how often higher-order functions are made much cleaner thanks to currying, for example
03:00:09 <Fuuzetsu> yes, I tried using Guile the other day and I basically ended up having to give up on any nice things that work with functions and type it all out myself
03:00:47 <pyon> tikhon: As long as the arguments you want to apply are the first ones. :-P
03:01:15 <tikhon> which happens surprisingly often, largely thanks to common Haskell conventions
03:01:17 <pyon> (Arguably, if you need to flip all the time you should rethink the order of your function's argument, though.)
03:01:32 <tikhon> or maybe have it be an operator instead
03:01:46 <Fuuzetsu> for those fairly rare cases, λ abstractions are easy to write
03:01:47 <tikhon> I also really don't mind things like (`elem` "foo")
03:01:55 <Fuuzetsu> and they are curried ;)
03:02:22 <tikhon> yeah, lambdas are nice, but I prefer not introducing any more names than I have to
03:02:50 <Fuuzetsu> I usually go with x y z or 1 or 2 of the first letters
03:02:59 <Fuuzetsu> or some mnemonic if I have overlap
03:08:04 <nisstyre> tikhon: are you talking about the (define ((f a) b) ...) syntax or (curry f a) ?
03:08:11 <nisstyre> (both work)
03:08:56 <tikhon> mostly (curry f a)
03:09:17 <nisstyre> tikhon: I don't find it that bad, I don't have to use it insanely often
03:09:17 <u-ou> functions as functors... interesting
03:09:22 <tikhon> and, to be fair, "absolutely horrible" is hyperbole, but it's still annoying
03:09:32 <wongdeyin> hello world, i am new
03:09:51 <nisstyre> (compose f g) is annoying, but it's nice when you have >2 functions so you can do (compose f g h ..)
03:09:57 <nisstyre> and put them on separate lines if need be
03:10:14 <tikhon> the combination of the two (compose and curry) is particularly annoying
03:11:17 <nisstyre> tikhon: sometimes I just use the explicit lambda
03:12:28 <tikhon> that's about as annoying—"lambda" isn't much shorter than "compose" or "curry"
03:12:50 <nisstyre> tikhon: but if it would be a combination of compose, curry, and whatever else, then sometimes it's clearer
03:12:54 <tikhon> and—importantly to me—I find it harder to scan through code that's just a bunch of words rather than using symbols for structure
03:13:00 <nisstyre> and you can use the unicode symbol too
03:13:16 <tikhon> ooh, didn't know that—I would probably have done it otherwise
03:13:19 <tikhon> I like Unicode
03:13:37 <nisstyre> in DrRacket I believe it's Ctrl+\
03:13:49 <nisstyre> yep
03:20:49 <Dethkat__> I love Haskell, shame I'm rubbish at it
03:21:01 <Dethkat__> :)
03:22:08 <tikhon> you'll get much better with a bit of practice
03:24:55 <merijn> iross: I found the bug, I blame undescriptive variable names
03:25:45 <merijn> iross: Someone typed s instead of s' as a variable name and through sheer coincidence that ends up producing the correct result for the common usecase
03:26:53 <Iceland_jack> merijn: Reminds me of the time when I had a key for an encryption algorithm which absolutely had to be an odd number and for some inexplicable reason, I'd added 3 after filtering out odd numbers
03:26:55 <jle`> if it compiles, it works
03:26:57 <Iceland_jack> And it somehow works..
03:27:48 <merijn> Iceland_jack: Well, this broke horribly in every non-trivial use case >.>
03:28:14 <merijn> It's one of these "I can't believe I'm the first person ever to run into this problem"-dealios
03:38:14 <klrr_> how does one handle exception in a Producer from pipes-network?
03:46:22 <u-ou> <fmap> do u even lift bro
03:46:23 * hackagebot laborantin-hs 0.1.5.0 - an experiment management framework  http://hackage.haskell.org/package/laborantin-hs-0.1.5.0 (LucasDiCioccio)
03:47:39 <xrz> Hi, does anybody know any examples of monadic quickCheck tests? (I am reading Claessen&Hughes paper and quickCheck source already...). I would like to create tests for some simplistic STM code.
03:48:41 <klrr_> anyone know how to write a Producer (pipes library) that produces ByteString from a socket and when the socket gets closed or similar it tries to reconnect adn the pipeline wont really notice anything?
03:48:42 <Iceland_jack> xrz: The basic layout is
03:48:42 <Iceland_jack>     prop_test = monadicIO $ do
03:48:42 <Iceland_jack>         run {- IO code -}
03:48:42 <Iceland_jack>         ...
03:48:45 <Iceland_jack>         assert something
03:49:08 <Iceland_jack> xrz: http://stackoverflow.com/questions/2259926/testing-io-actions-with-monadic-quickcheck this has nice examples
03:50:45 <mniip> is there any miniature haskell interpreter that is somewhat stand-alone?
03:50:47 <xrz> Iceland_jack: thanks, appreciated
03:51:00 <mniip> preferable statically linked and a few modules included in the binary
03:51:19 <mniip> preferably statically linked and with a few modules included in the binary*
03:59:05 <merijn> klrr_: Look into pipes-safe?
04:03:00 <klrr_> merijn: is that really what pipes-safe is for? i thought it was to close handles and such after a pipeline have ran
04:09:18 <merijn> klrr_: pipes-safe is for handling exceptions in pipes
04:09:40 <merijn> klrr_: What you do in your exception handler is up to you
04:09:50 <merijn> i.e. restart a new connection and continue from there, for example
04:10:37 <merijn> resource cleanup is just one application
04:48:13 <klrr_> merijn: okey, thanks
04:52:32 <skypers> hey
04:52:41 <skypers> I’d like to traverse a Map using a State
04:52:43 <skypers> something like
04:53:00 <skypers> flip evalStateT 0 . traverse traversor $ theMap
04:53:06 <skypers> it doesn’t typecheck
04:53:08 <skypers> I don’t get why
04:54:31 <merijn> :t evalStateT
04:54:32 <lambdabot> Monad m => StateT s m a -> s -> m a
04:54:35 <skypers> :t flip traverse (fromList $ zip [0..] [0..])
04:54:35 <lambdabot>     Not in scope: `fromList'
04:54:36 <lambdabot>     Perhaps you meant one of these:
04:54:36 <lambdabot>       `IM.fromList' (imported from Data.IntMap),
04:54:44 <skypers> :t flip traverse (Data.Map.fromList $ zip [0..] [0..])
04:54:44 <lambdabot> (Enum k, Enum a, Num k, Num a, Ord k, Applicative f) => (a -> f b) -> f (M.Map k b)
04:54:46 <merijn> skypers: Do you have the right traverse?
04:54:54 <skypers> merijn: Data.Traversable
04:55:15 <skypers> :t flip runStateT 0 . traverse
04:55:16 <lambdabot>     Couldn't match type `t0 a1 -> f0 (t0 b1)' with `StateT b0 m0 a0'
04:55:16 <lambdabot>     Expected type: (a1 -> f0 b1) -> StateT b0 m0 a0
04:55:16 <lambdabot>       Actual type: (a1 -> f0 b1) -> t0 a1 -> f0 (t0 b1)
04:55:53 <merijn> :t T.traverse print (M.empty)
04:55:54 <lambdabot> IO (M.Map k ())
04:56:01 <skypers> :t flip runStateT 0 <=< traverse
04:56:02 <lambdabot> (Num b, Traversable t) => (a -> StateT b ((->) (t a)) b1) -> t a -> (t b1, b)
04:56:04 <skypers> hhhm
04:56:19 <skypers> merijn: instead of print
04:56:24 <skypers> I want to do something like
04:56:35 <skypers> using get, put
04:56:41 <merijn> :t T.traverse (undefined :: a -> StateT s IO b) (M.empty)
04:56:41 <lambdabot> StateT s IO (M.Map k b)
04:57:03 <merijn> :t flip evalStateT undefined $ T.traverse (undefined :: a -> StateT s IO b) (M.empty)
04:57:04 <lambdabot> IO (M.Map k b)
04:57:15 <skypers> huh
04:57:31 <merijn> skypers: You must be bollocksing up typing your code somehow :p
04:57:43 <skypers> :t flip runStateT 0 $ traverse get
04:57:44 <lambdabot>     Couldn't match expected type `StateT b0 m0 a0'
04:57:44 <lambdabot>                 with actual type `t0 a1 -> f0 (t0 b1)'
04:57:44 <lambdabot>     In the return type of a call of `traverse'
04:57:55 <skypers> :t flip runStateT 0 $ traverse (const get)
04:57:56 <lambdabot>     Couldn't match expected type `StateT b0 m0 a0'
04:57:56 <lambdabot>                 with actual type `t0 a1 -> f0 (t0 b1)'
04:57:56 <lambdabot>     In the return type of a call of `traverse'
04:58:00 <skypers> damn that shit.
04:58:10 <merijn> :t flip runStateT 0 . traverse (const get)
04:58:11 <lambdabot> (Monad m, Functor m, Num b, Traversable t) => t a -> m (t b, b)
04:59:02 <skypers> ok
04:59:05 <skypers> so it works
04:59:25 <skypers> my issue is that I got a duplicated map
04:59:27 <skypers>     Expected type: M.Map String GPacket
04:59:27 <skypers>       Actual type: M.Map String (M.Map String GPacket)
04:59:35 <skypers> it’s really wrong :D
05:00:46 <skypers> merijn: http://lpaste.net/5540578408217444352
05:01:00 <skypers> meshPackets msh :: Map String Packet
05:01:05 <skypers> fyi
05:02:17 <Fuuzetsu> skypers: I recommend programming with holes (or more primitively, manually putting down signatures everywhere)
05:02:27 <Fuuzetsu> 7.8 even has hole support
05:03:20 <skypers> Fuuzetsu: yeah, signatures in where clauses is a bit ugly to me
05:03:24 <skypers> it makes the code more dense
05:03:34 <skypers> but it might be a good thing for debug-purposes indeed
05:03:37 <skypers> gonna try that
05:04:10 <merijn> skypers: In 7.8 typeholes are on by default, you can just write _ instead of an expression and GHC will output the type of _ :)
05:04:17 <Fuuzetsu> skypers: well, you don't have to leave them there after it actually does what you want but it's great for debugging
05:04:50 <FreeFull> Typeholes are awesome
05:04:58 <skypers> yeah
05:05:02 * Fuuzetsu likes Agda's holes more
05:05:04 <skypers> I read the paper about them
05:05:08 <skypers> gonna try that :
05:05:09 <skypers> :)
05:05:28 <skypers>     Pattern syntax in expression context: _
05:05:30 <skypers> NOOOOOOOO
05:05:42 <skypers> The Glorious Glasgow Haskell Compilation System, version 7.4.1
05:05:46 <skypers> arf
05:05:48 <Fuuzetsu> you need a newer compiler
05:05:53 <Fuuzetsu> get off Debian
05:06:05 <skypers> what distro do you use?
05:06:16 <skypers> I’ve been using archlinux for years
05:06:26 <skypers> but it always broke at some time…
05:07:06 <Fuuzetsu> you must be too stupid for Arch, if it breaks it's your fault /sarcasm
05:07:17 <Fuuzetsu> currently using Gentoo but I manage my Haskell stuff manually
05:07:39 <Fuuzetsu> i.e. cabal + install GHC versions to ~
05:07:43 <FreeFull> As an opposite anegdote, I always had (X)Ubuntu break when I updated it, but I haven't had Arch break at all yet
05:08:02 <skypers> 13:03 < Fuuzetsu> you must be too stupid for Arch, if it breaks it's your fault  /sarcasm
05:08:08 <skypers> you must be really naive :)
05:08:28 <Fuuzetsu> skypers: Why? Did you miss the “/sarcasm”
05:08:32 <skypers> even when using arch or gentoo, you still depend on others
05:08:35 <skypers> I have a quadro
05:08:40 <skypers> then I depend on… bumblebee
05:08:44 <skypers> and it ALWAYS breaks.
05:08:54 <skypers> I had to write my own kernel hooks
05:09:03 <skypers> when you just want to write haskell programs
05:09:06 <average> is bumblebee that thing for gfx cards ?
05:09:07 <skypers> it’s quite a waste of time
05:09:16 <skypers> it’s for nvidia optimus, average
05:09:21 <average> I'm using it
05:09:24 <average> and it works
05:09:24 <FreeFull> skypers: Is there any distro that wouldn't break with bumblebee, other than one specifically designed for it?
05:09:28 <skypers> so am I
05:09:41 <skypers> FreeFull: Debian doesn’t
05:09:45 <skypers> and you know why?
05:09:48 <skypers> because it’s stable.
05:09:48 <bennofs> What is the fastest way to do 'indicesOfSetBits :: Word64 -> [Int]' ?
05:09:48 <average> why ?
05:09:50 <Fuuzetsu> I want to move to NixOS but after checking it out some more yesterday, it seems that I'll have to write a ton of Nix packages before I even get to use it!
05:09:57 <average> skypers: switch to Ubuntu ?
05:10:05 <skypers> average: no, I’m on Debian now
05:10:08 <skypers> it’s a great distro
05:10:08 * bennofs is currently on NixOS
05:10:16 <skypers> lightweight, fast, mature, secure
05:10:40 <Fuuzetsu> bennofs: and you're managing to use it as you did the old distro? I find that there are a LOT of packages missing
05:10:47 <FreeFull> bennofs: Are you using it for something that needs to be particularly fast?
05:11:00 <Fuuzetsu> I also find their license system unsatisfactory but that's a different issue
05:11:02 <pyon> skypers: And you have to install any programs you want the latest version of from anywhere but Debian's repositories.
05:11:13 <FreeFull> Fuuzetsu: I think you meant to aim that at skypers
05:11:19 <skypers> pyon: not even close
05:11:40 * hackagebot clifford 0.1.0.0 - A Clifford algebra library  http://hackage.haskell.org/package/clifford-0.1.0.0 (spacekitteh)
05:11:40 <skypers> just use sid or jessie repo if you want latest
05:11:51 <Fuuzetsu> FreeFull: No, I meant to aim that at bennofs
05:12:05 <average> but I don't really see why you need your gfx drivers working...
05:12:10 <skypers> :D
05:12:16 <skypers> because I’m a demomaker maybe?
05:12:20 <average> a what ?
05:12:21 <skypers> I’m writting 3D engines
05:12:27 <skypers> a demomaker
05:12:27 <average> oh
05:12:29 <average> erm
05:12:32 <average> what's a demomaker ?
05:12:40 <FreeFull> skypers: Maybe you should use Rust
05:12:43 <skypers> http://en.wikipedia.org/wiki/Demomaker
05:12:48 <skypers> FreeFull: rust?
05:12:49 <skypers> why?
05:12:53 <skypers> Haskell is quite nice
05:12:55 <average> oh for demo parties ?
05:12:59 <skypers> yes, average
05:13:10 <average> but how is Haskell suited for that kind of thing ?
05:13:23 <average> I mean I read some code from demos and they were mostly C/C++ / OpenGl
05:13:27 <FreeFull> skypers: It doesn't separate IO like Haskell does, but it should be faster and is still quite nice
05:13:32 <FreeFull> Although it's not quite stable yet
05:13:32 <bennofs> FreeFull: Hmm, maybe I should make sure that it's really the bottleneck. Still wonder if there is a faster way than \w -> [ x | x <- [0..63], testBit w x ]
05:13:34 <Fuuzetsu> I wonder if demoscene will ever die
05:13:34 <skypers> it has FFI, abstractions, parallelism, quite okay for demo
05:13:51 <skypers> FreeFull: faster?
05:14:00 <skypers> I thought Haskell was already quite fast
05:14:06 <klrr_> it is?
05:14:08 <FreeFull> No garbage collection, for one
05:14:09 <skypers> some dudes write video games with it
05:14:12 <skypers> for rust?
05:14:13 <Fuuzetsu> Haskell is pretty fast
05:14:15 <average> skypers: but don't you need your language to be extremely fast, in order to render the whole thing at runtime, because I know demos usually have restrictions on the size of the program..
05:14:26 <skypers> average: yes
05:14:37 <skypers> it’s quite a challenge to me writing my next release in Haskell
05:14:44 <skypers> are you suggesting I’m facing a problem ther?
05:14:46 <skypers> there*
05:14:47 <FreeFull> ( Well, there is a Gc<T> that you can use, but the implementation doesn't do proper Gc yet )
05:14:48 <skypers> THAR* :D
05:15:04 <Fuuzetsu> microbenchmarks ahoy http://benchmarksgame.alioth.debian.org/u64q/benchmark.php?test=all&lang=rust&lang2=ghc&data=u64q
05:15:13 <average> skypers: I honestly have never made a demo ... so I guess you know better
05:15:30 <FreeFull> skypers: One thing, Rust is strict, while you might be used to laziness
05:16:03 <FreeFull> It does have a nice type system (Including traits, which are equivalent to Haskell's typeclasses)
05:16:19 <klrr_> haskell is implicitly lazy, you can still annotate code to be strict
05:16:26 <skypers> yeah, bang patterns
05:16:41 * hackagebot clifford 0.1.0.1 - A Clifford algebra library  http://hackage.haskell.org/package/clifford-0.1.0.1 (spacekitteh)
05:16:43 <skypers> FreeFull: why did you say it’s unstable?
05:16:45 <FreeFull> I don't think Rust has a Lazy<T> wrapper yet
05:17:04 <FreeFull> skypers: It hasn't reached 1.0 yet, so there are occasional breaking change
05:17:10 <c_wraith> It's so very weird to work in strict languages after getting used to haskell.
05:17:18 <skypers> yeah
05:17:20 <skypers> but seriously
05:17:33 <FreeFull> Recently, std::rng (random number generation) got moved into its own librng
05:17:34 <skypers> do you really thing Haskell is not suited for realtime applications like video games?
05:17:37 <c_wraith> Like, you can't just bind useful things without thinking of what will happen at the binding site.
05:17:55 <FreeFull> skypers: Depends on how much performance you need, and how much unsafe code you will tolerate
05:17:57 <skypers> is it compiled? how fast is it compared to C/C++ FreeFull?
05:18:05 <FreeFull> You could write Quake 3 in Haskell, sure
05:18:17 <FreeFull> It is compiled, and it is aimed as a competitor to C/C++
05:18:19 <c_wraith> and by "could", you mean "someone already has"
05:18:25 <FreeFull> The backend is LLVM
05:18:31 <skypers> c_wraith: I saw that
05:18:37 <skypers> FreeFull: hm, not native?
05:18:42 <iross> merijn: Thanks for the PR!
05:19:04 <FreeFull> skypers: LLVM produces native code
05:19:12 <FreeFull> GHC has an LLVM backend too
05:19:13 <c_wraith> Rust is a pretty cool language for cases where you need more control over memory management than haskell gives you.  They're actually making a go at creating a seriously modern low-level language.
05:19:58 <c_wraith> Instead of the other popular approach, which is creating a new laughably primitive low-level language.
05:19:59 <FreeFull> Rust is both low-level and high-level at the same time
05:20:12 <skypers> as well as C++, FreeFull
05:20:43 <skypers> you think it’s impossible to write a nextgen games in Haskell?
05:20:48 <skypers> game*
05:20:50 <FreeFull> Rust is probably the only memory-safe language that isn't garbage collected
05:20:51 <c_wraith> FreeFull: sure, but there's little reason to use Rust when you don't need the low-level control.  That's what makes it an interesting project.
05:20:54 <osa1> I have this expression `trace ("e1k : " ++ show e1k) (return ()) >> undefined` and undefined is evaluated before trace and program exits with error without printing string in trace ... how can I fix this?
05:20:59 <FreeFull> skypers: No
05:21:25 <skypers> FreeFull: arf :(
05:21:35 <FreeFull> I mean, it's not impossible
05:21:40 <ousado> FreeFull: check out ATS
05:21:41 <c_wraith> osa1: change the definition of >>
05:21:43 <Vbitz> skypers: as it stands right now the gaming industry writes most games using C++. This is because all the middleware exists for them
05:22:15 <osa1> c_wraith: what?
05:22:18 <FreeFull> ousado: Ah, a theorem prover
05:22:28 <Vbitz> anyone wanting to write a next gen game in Haskell would have a reinvent the wheel many times to catch up to modern engines
05:22:38 <osa1> I guess I need more strict version of >>, right?
05:22:41 <FreeFull> Aimed at also allowing general programming
05:22:57 <ousado> FreeFull: I'd phrase that the other way 'round
05:22:58 <c_wraith> osa1: or move the trace into the parens around the return ()
05:23:01 <ousado> but yes
05:23:04 <FreeFull> It doesn't seem to use uniqueness types for that
05:23:13 <ousado> linear types
05:23:19 <ousado> very similar
05:23:35 <FreeFull> Rust isn't dependently typed
05:23:39 <c_wraith> aren't uniqueness and linear the same property in opposite directions?
05:24:15 <merijn> Vbitz: I'm not even sure that's true
05:24:18 <c_wraith> Like..  One means "the value was only used in one place before this" and the other means "the value is only used in one place after this"?
05:24:18 <Fuuzetsu> ousado: shame about ATS looking like an abomination
05:24:23 <merijn> Vbitz: There's tons of games written in C# and Lua these days
05:25:15 <merijn> Vbitz: Also, people are reinventing modern engines every few years, so what difference does it make which language you do it in?
05:25:17 <ousado> c_wraith: I don't know where exactly the difference is, if there's any
05:25:26 <c_wraith> osa1: err.  too early for me.  My last suggestion does nothing.  To make it actually work, change the end to (return () >> undefined)
05:25:41 <Vbitz> merijn: The games written in lua run on top of infrastructure written in C++ and most C# engines are thin wrappers over C apis
05:25:42 <ousado> Fuuzetsu: well, I can live with that
05:25:49 <c_wraith> osa1: that actually will make the trace the first function called.
05:25:56 <Fuuzetsu> ousado: I can't ;P
05:26:00 <c_wraith> osa1: instead of >> being the first function called
05:26:24 <FreeFull> There would be no reason to write new C code when writing Rust code, since Rust is supposed to be as or more performant than normally written C
05:26:32 <c_wraith> osa1: sorry, it's early.  I'm only operating at half-speed right now. :)
05:26:48 <FreeFull> You can link in with existing C code no problems, of course
05:27:02 <vanila> wow
05:27:12 <vanila> I thought this "Rust" thing was just a new kind of javascript
05:27:15 <Vbitz> merijn: the amount of support and middleware provided in C++ is often depended apon even for the newest games
05:27:17 <vanila> I wonder where I got such a completely wrong idea
05:27:24 <Vbitz> vanila: your thinking of dart
05:27:28 <c_wraith> FreeFull: well. That's not always true.  There were stack space issues at some points in rust's history.  I think they solved those, though.
05:27:40 <Vbitz> which is made by google, rust is made by mozilla
05:27:47 <c_wraith> Yeah, Dart was pretty disappointing. Rust is totally unlike that.
05:27:52 <FreeFull> c_wraith: Well, it's not ready for production yet
05:27:58 <bjz_> vanila: folks get a little confused seeing that it comes from mozilla, which is known more for JS
05:28:04 <FreeFull> Once 1.0 comes out all of those sorts of issues should be gone
05:28:06 <merijn> c_wraith: "pretty disappointing"? You mean laughable, no?
05:28:08 <Vbitz> rust is more like Go and D from my reading
05:28:15 <thebnq> rust is pretty nice
05:28:17 <FreeFull> Go is disappointing
05:28:21 <merijn> Vbitz: No
05:28:25 <FireFly> I wouldn't really compare it with Go
05:28:34 <FreeFull> D is garbage collected
05:28:35 <merijn> Vbitz: go and D are boring and way conservative compared to Rust
05:28:54 <vanila> "Rust also supports generic programming and metaprogramming"
05:28:56 <merijn> Vbitz: Rust is more like C++ and advanced PLT features had a love child
05:28:58 <bjz_> Vbitz: Haskell + ML + C + a bit of C++
05:28:59 <vanila> I like the sound of this
05:29:07 <c_wraith> I hope Rust adds higher-kinded polymorphism.  It's really useful, once you get used to it.
05:29:15 <c_wraith> I hear they're discussing it now.
05:29:19 <FireFly> Rust seemed interesting, but a bit confusing to me (I haven't really dug into it too much though)
05:29:20 <bjz_> c_wraith: it will, but post 1.0 most likely
05:29:35 <FreeFull> c_wraith: Quite a few people really want higher-kinded polymorphism
05:29:39 <FreeFull> Including me
05:29:46 <Vbitz> go supports similar functionality
05:29:46 <bjz_> c_wraith: unless a committed contributor comes up with an RFC and implements it
05:30:02 <bjz_> c_wraith: the core devs have too much other stuff on their plate
05:30:25 <FreeFull> Go isn't suitable for system programming in the way Rust is
05:30:40 <Vbitz> true
05:30:54 <FreeFull> And Go has a disappointing type system
05:30:58 <Vbitz> rust runs much better and easier on bare metal
05:31:28 <FreeFull> Another thing that would be nice for Rust to have is STM, but that can come later
05:31:29 <vanila> oh cool it has lisp like if's
05:31:55 <FreeFull> vanila: Yeah, things are expressions a lot of the time
05:32:27 <vanila> clever to go with the curly braces so people actually try it out
05:33:14 <Taneb> I think Rust, D, and Go are similar in the sense in that they try to solve the problem of C++ not being all that fun
05:35:12 <bjz_> Taneb: fust is quite fun. linear types and regions ftw
05:35:17 <bjz_> *rust
05:36:21 <FreeFull> Rust probably covers the most reasons why people would use C++, out of the three
05:36:30 <bjz_> Hey, just wondering, is there a way to do the pattern matching thing with lambdas in haskell? Like, without a case statement?
05:36:51 <FreeFull> bjz_: \case?
05:36:54 <pyon> bjz_: -XLambdaCase
05:37:20 <bjz_> ah
05:37:27 <bjz_> yeah, this is my code: https://gist.github.com/bjz/9566481
05:38:04 <pyon> bjz_: "\case" stands for the whole of "\b1 -> case b1 of".
05:38:13 <pyon> bjz_: But you have to use the LambdaCase extension.
05:38:20 <bjz_> how do you use that?
05:38:31 <bjz_> with the language annotation thingy?
05:38:35 <pyon> Add {-# LANGUAGE LambdaCase #-} at the top of your file.
05:38:44 <pyon> s/file/source code file/
05:38:53 <bjz_> cheers!
05:38:58 <pyon> :-)
05:39:14 <bjz_> oh, wait, i'm using Hugs...
05:39:16 <vanila> bjz_, you could use do notation to write this without lambdas, not exactly what you were asking but see if you like it
05:39:22 * bjz_ kids
05:39:28 <bjz_> xD
05:39:31 <vanila> haha
05:40:01 <bjz_> vanila: yeah I was wondering if that was possible too
05:40:14 <bjz_> sorry, my haskell isn't that good
05:41:01 <bjz_> vanila: I was trying to search for pattern matching in do notation
05:41:10 <vanila> http://pastebin.com/H0iUubJv
05:41:11 <c_wraith> bjz_: eh. You're hear to learn more.  No need to apologize. :)
05:41:15 <c_wraith> *here
05:41:17 <vanila> like this
05:41:22 <c_wraith> damn it, why is spleling so hrad?
05:41:36 <bjz_> that looks prettier
05:46:14 <vanila> Note: Rust doesn't guarantee tail-call optimization
05:46:23 <vanila> i was sold up until that
05:46:33 <bjz_> vanila: sadly :(
05:46:50 <bjz_> vanila: the iterators are pretty good
05:47:00 <bjz_> you can still be quite declarative
05:47:04 <FreeFull> There are problems with tail call optimisation and some other stuff Rust does
05:47:10 <bjz_> but you do need mutable state
05:48:35 <Redz> has someone found an ssc? ;)
05:48:54 <bjz_> vanila: at least the mutable state is contained, and usually clearly visible
05:49:24 <vanila> yeah this looks really cool, maybe an improvement on C - pretty interesting
05:50:19 <ski> vanila,FreeFull : what are the reasons for not supporting "proper tail recursion" ?
05:50:55 <FreeFull> ski: https://mail.mozilla.org/pipermail/rust-dev/2013-April/003557.html
05:51:10 <bjz_> ski: I believe it slows down calls via the C ABI or something
05:51:17 <isaacbw> when would you need to be explicit about forall
05:51:40 <bjz_> ski: that isn't really something that can be compromised on
05:51:55 * hackagebot ampersand 3.0.1 - Toolsuite for automated design of business processes.  http://hackage.haskell.org/package/ampersand-3.0.1 (hanjoosten)
05:52:34 <Redz> sorry if i missing something, but why is rust faster than c?
05:52:47 <bjz_> ski: I'm sure if some folks could work out how to do it in the future they would be open to it
05:52:56 <bjz_> Redz: I don't think it is yet
05:53:04 <FreeFull> Redz: Theoretically, for the same reason Fortran would be
05:53:08 <bjz_> Redz: it is around the same
05:53:23 <ski> FreeFull : ty
05:53:28 <peteretep> Redz: If it is, it's likely to be because the more information you can give the compiler about your /intention/, the more clever things it can do to optimize
05:53:29 <isaacbw> I like everything about Rust but the name
05:53:30 <Redz> okay. ;)
05:53:32 <isaacbw> the name is offputting
05:53:33 <tiffany> are you referring to what vanila said? rust is meant to be an improvement in usability for a system's language
05:53:40 <bjz_> Redz: but there is a chance it could be, because the compiler know lots more invariants and lifetime information
05:53:48 <FreeFull> There are some things in C that impede optimisations, unless you give the compiler more info
05:54:25 <ski> even only having the ability to opt-in to tail-calls would be nice
05:54:39 <ski> isaacbw : why is it offputting ?
05:55:11 <Redz> and llvm could do something with this extra on information?
05:55:45 <isaacbw> ski: the emotions and feelings I associate with rust aren't really what I want to associate with a language
05:55:54 <ski> (it's not really comparable to "ScrotWM")
05:56:02 <Redz> or is some other backend required to guarantee better machine code?
05:56:06 <tiffany> the most obvious example of something which is slow in C without extensive optimization is probably case statements: you can't really directly convert them to a dispatch table, and a dumb compiler emits what amounts to a big if-then-else block
05:56:33 <bjz_> Redz: well, I think llvm needs abit more work done on it before we can fully optimise rust to its full potential
05:56:56 <bjz_> Redz: llvm is more designed for languages like C and C++
05:57:01 <FreeFull> You can always manually optimise C code, but that gives you ugly results
05:57:32 <thebnq> need a stronger typed IR :]
05:57:37 <bjz_> ski: yeah, having it opt-in might be nice, but I don't know the specifics. you'd have to ask on #rust-internals
05:57:48 <k00mi> isaacbw: you need explicit forall with some extensions like RankNTypes or ScopedTypeVariables
05:58:07 <bjz_> thebnq: it's kind of a case of, it's the best that's there at the moment
05:58:10 <Redz> if you write an own compiler, is it better to target C or llvm-code?
05:58:22 <tiffany> it's better to target llvm
05:58:26 <bjz_> Redz: llvm is great
05:58:34 <bjz_> Redz: offloads a ton of work
05:58:53 <Redz> thanks. good to know. ;)
05:58:59 <ski> isaacbw : i suppose for me, that they choose a name that's not obviously trying to optimize for sounding attractive, is a plus ..
05:59:20 <thebnq> bjz_: i know, just idealizing a bit
05:59:30 <bjz_> thebnq: of course
05:59:41 <bjz_> :)
06:00:16 * ski once considered naming a pet language "contagion"
06:00:31 <thebnq> i'm sure it would go viral
06:00:39 <bjz_> thebnq: so much more awesomeness to be done in the realms of close-to-the-metal computing
06:02:14 <isaacbw> someone should just build haskell machine
06:02:40 <thebnq> there is people working on graph reduction machines
06:02:42 <vanila> what is the compiler written in?
06:02:59 <hpc> some researchers came up with the reduceron
06:03:16 <hpc> which obviously doesn't perform like a commercial processor, but it is pretty neat as a concept
06:03:31 <Redz> well i would be happy when someone writes a simple machine. because its easier to optimize code for a simple machine.
06:03:40 <bjz_> vanila: which compiler?
06:03:52 <vanila> oh, rust - it does self host!
06:03:58 <bjz_> vanila: indeed
06:03:58 <thebnq> yep
06:04:03 <vanila> that's a good sign
06:04:19 <bjz_> vanila: for several years actually - bootstrapped from Ocaml
06:04:56 <tdammers> ocaml, really
06:05:05 <Redz> our processors fix compiler bugs, i think.
06:05:08 <tdammers> seems to crop up everywhere in my path recently
06:05:52 <tiffany> redz: simple machines tend to be slow, though
06:06:42 <tdammers> depends... simple special-purpose machines can be very fast for their particular purpose
06:06:47 * bjz_ is getting confused with church encodings
06:06:53 <vanila> #[deriving(Clone, Eq, Hash)]
06:07:05 <vanila> where did they get that idea
06:07:12 <thebnq> hmmmm :b
06:07:12 <bjz_> vanila: Haskell
06:07:14 <bjz_> :D
06:09:22 <bjz_> vanila: bear in mind when you are looking, there is still much to be done in the way of polishing it
06:11:23 <Redz> tiffany: looks like the neumann-harvard debate. ;)
06:11:25 <Redz> you could execute more parallel code on a "simple machine". maybe like an graphics processor.
06:12:06 <tiffany> the implementation of the simple machine would gain complexity in detecting patterns that can be parallelised, though
06:12:44 <Ankhers> I am having a type error. Would anyone be able to explain why this is happening? http://lpaste.net/101237
06:13:58 <ski> Ankhers : looks like `s' in `transform' is a `Char' ?
06:14:24 <isaacbw> are Snap and MonadSnap the same thing?
06:14:52 <Ankhers> ski: I am expecting it to be a `String`. How would I go about doing that?
06:15:09 <isaacbw> oh, Snap is an instance of MonadSnap, perhaps?
06:15:26 <ski> Ankhers : hm, no, ignore that. i missed the list brackets. still `foldl' wants to pass a `String', not a list of `String's
06:15:38 <k00mi> isaacbw: yep
06:16:13 <ski> Ankhers : iow, the `(s:_)' should still be just `s' -- only that the type of `transform' isn't what you want it to be, to be able to use it with `foldl' like that
06:16:49 <ski> Ankhers : so : replace `(s,_)' with `s' and `[String]' with `String'
06:17:03 <Ankhers> ski: Thank you so much!
06:17:37 <ski> the `_' alone there should suggest to you something is fishy, unless you really intend to throw away input (which you didn't herE)
06:18:15 <ski> Ankhers : `wordList' is of type `[String]', each element of that will be passed to `transform', in turn
06:18:33 <ski> Ankhers : so the type of that parameter of `transform' should be `String', not `[String]'
06:19:18 <ski> Ankhers : and therefore, since you want to insert with a `String' as the key into the map, you should use just `s' as a pattern, rather than `(s:_)' (which would in that case make `s' a `Char', like i initially thought)
06:19:22 <ski> Ankhers : ok ?
06:19:44 <Ankhers> ski: Aye, I should have caught that. Thanks again.
06:20:37 <isaacbw> thanks k00mi
06:20:42 <ski> Ankhers : np
06:20:46 <isaacbw> anyone know if snap init will respect cabal sandboxes?
06:20:54 <isaacbw> or maybe it doesn't matter
06:34:35 <bjz_> what do folks here think of PureScript? http://docs.purescript.org/en/latest/
06:36:28 <isaacbw> http://www.haskell.org/pipermail/haskell-cafe/2010-June/079044.html
06:36:55 <isaacbw> bjz_: I know a few people who work on it, but from what I've been told it's pretty basic
06:37:04 <isaacbw> they're about to rewrite it in Purescript though, which is neat
06:37:27 <bjz_> Ah nice
06:37:47 <bjz_> is it lazy or eager?
06:38:10 <isaacbw> actually, maybe you guys would be a good group to ask about an idea I had. Rather than writing a whole new ->js language, what about introducing pure functions on top of it (kind of like D)? Pure functions can only call other pure functions, but impure functions (anything created with the function keyword) can call pure functions, which are curried, etc
06:38:32 <isaacbw> it obviously wouldn't be as nice as something pure all the way through, but you could leverage existing code bases and just build FP on top of them
06:38:50 <isaacbw> kind of like Typescript, which lets you pick and choose where you want types
06:39:02 <isaacbw> s/on top of it/on top of js
06:39:59 <isaacbw> it could even be statically typed, at least for pure functions calling pure functions
06:40:30 <isaacbw> it would be nearly impossible to enforce impure->pure static typing though
06:40:33 <bjz_> re. purescript, I thought row polymorphism was a really smart way of handling javascript objects
06:40:57 <isaacbw> bjz_: no idea about lazy/eager
06:41:13 <isaacbw> my suspicion is it's not lazy
06:41:34 <isaacbw> Sorella would know
06:41:40 <bjz_> tbh I prefer that :]
06:41:58 <bjz_> just curious though
06:42:04 * hackagebot chain-codes 0.2.0.0 - Library decoding chain codes from images  http://hackage.haskell.org/package/chain-codes-0.2.0.0 (MateuszKowalczyk)
06:42:21 <bjz_> I would assume it would be eager, because they want to be very lightweight on top of JS
06:42:45 <isaacbw> yea
06:42:51 <isaacbw> I've been eyeing elm
06:43:06 <isaacbw> what would be nice is one of these languages with xml literals
06:44:25 <isaacbw> if any of them had that, I would use it immediately
06:44:46 <isaacbw> Sorella: *wink* *wink*
06:48:06 <mniip> is there any miniature haskell interpreter that is somewhat stand-alone?
06:48:42 <isaacbw> does anyone remember the slides that were on HN re: haskell web development which ended with "Seriously, why isn't everyone doing this?"
06:49:35 <isaacbw> I'm having trouble rationalizing the use of a strict type system for a platform which is inherently untyped
06:49:35 <companion_cube> mniip: hugs?
06:49:39 <isaacbw> (the web)
06:50:12 <companion_cube> isaacbw: native assembly is untyped, yet haskell can be compiled to it
06:51:01 <isaacbw> companion_cube: yea, I'm not actively trying to stop myself from liking the idea. In fact, I really want to like the idea. Just having a bit of trouble seeing the big picture I guess
06:51:17 <isaacbw> would love some help getting me super excited about web development with haskell (other computation, I'm already excited about)
06:51:34 <mniip> companion_cube, can hugs be built including prelude in the binary?
06:52:24 <companion_cube> isaacbw: the web is typed, you exchange html messages
06:52:36 <companion_cube> mniip: it's an interpreter
06:52:53 <mniip> companion_cube, yes, the interpreter reads the file containing prelude
06:53:04 <companion_cube> I don't know
06:53:05 <isaacbw> companion_cube: everything is just strings
06:53:09 <mniip> I'd like to avoid that by including it in the interpreter binary
06:53:22 <companion_cube> isaacbw: no, there is valid html, valid http request, valid json...
06:53:23 <isaacbw> you can have any attribute in your html, any query string in your url
06:53:26 <Iceland_jack> isaacbw: So is a Haskell source file :)
06:54:19 <isaacbw> so maybe there's a layer where you go from a strongly typed representation and serialize it into plain old strings, and you try to reduce the surface area of that layer?
06:54:27 <isaacbw> and the other way around?
06:55:36 <isaacbw> companion_cube: you can have properly formed json, but for example say you have a "date" field
06:55:42 <isaacbw> you can put whatever the hell you want in the value
06:55:47 <isaacbw> even an array of numbers if you wanted
06:55:54 <k00mi> isaacbw: types are a way to enforce invariants
06:55:55 <matheus23> is there some prelude function of type :: a -> b -> (a, b) ? (Just like zip, but only for a single value, not lists)
06:56:05 <mniip> matheus23, (,)
06:56:05 <k0ral> Hello, I've somewhat reached a paradoxal state using Parsec: the parsing error is "unexpected end of input; expecting new-line or end of input"; my parser is basically "manyTill anyChar (lookAhead $ newline <|> eof)"; any clue ?
06:56:09 <Iceland_jack> matheus23: (,)
06:56:16 <companion_cube> isaacbw: validate :: String -> Maybe GoodJSON
06:56:16 <Iceland_jack> @ty (,)
06:56:17 <lambdabot> a -> b -> (a, b)
06:56:18 <Iceland_jack> @ty (,,,,,)
06:56:19 <lambdabot> a -> b -> c -> d -> e -> f -> (a, b, c, d, e, f)
06:56:22 <k00mi> the web has a lot of those, but usually they aren't expressed as types but as a description of what this thing does/is
06:56:23 <matheus23> Iceland_jack: mniip: I can use that? Oh thanks! :)
06:56:57 <k0ral> to be exact, my parser is "manyTill anyChar (lookAhead $ void newline <|> eof)" (forgot the "void" previously)
06:57:35 <k0ral> also, the string I'm trying to parse is a sequence of chars without any newline
06:57:36 <FreeFull> > (,) 3 4
06:57:37 <lambdabot>  (3,4)
06:58:37 <isaacbw> bcompanion_cube: okay, how do you go from "date": "3/15/14" to Date 3 15 14. You would need something like Maybe WellFormed Date 3 15 14, where WellFormed is something like data WellFormed = WellFormed m | Malformed, right?
06:59:15 <companion_cube> well if you expect a date you have no choice but to check whether the JSON contains it
06:59:17 <mniip> isaacbw, wouldn't WellFormed be just another Maybe?
06:59:18 <k00mi> isaacbw: in fact most interactions with "the real world" are untyped, but by expressing the invariants as types, we can be sure to not mess up, assuming the translation from haskell to text data or whatever is correct
06:59:24 <companion_cube> (and also in the correct format, because to me this is not a valid date)
06:59:32 <companion_cube> (ugly american convention...)
06:59:48 <isaacbw> I guess that isn't so bad, but (and I'm seriously looking for someone to convince me otherwise, and so far so good) why wouldn't I just use Clojure where I can pump something out in a few hours without worrying about types. This is a probably a philisophical question about types at this point :P
07:00:21 <vanila> how do you dea with this aspect in clojure?
07:00:38 <vanila> deal*
07:01:20 <isaacbw> I suppose I would have a validate function that short circuits the response it it fails and return an error
07:01:56 <isaacbw> hmm, okay
07:02:02 <isaacbw> you've helped me convince myself, almost
07:02:35 <k00mi> isaacbw: because clojure won't help you prevent mistakes the way a strong static type system will
07:02:39 <isaacbw> mniip: could I just use type WellFormed = Maybe to do the same thing?
07:03:16 <vanila> String -> Maybe Date
07:04:20 <isaacbw> yea, I guess if I were to pump out the thing in clojure, it would be pretty damn unsafe (it would work for valid input). Haskell won't *let* me pump out an unsafe solution in a few hours
07:04:45 <vanila> oh im sure you can write horrible broken web apps in haskell
07:04:50 <isaacbw> lol
07:05:10 <thebnq> well it does, you can optionally run code without full pattern matching etc
07:05:11 <Flonk> How would I read files via http in Haskell?
07:05:32 <isaacbw> so would type Wellformed = Maybe do what I was talking about?
07:05:39 <vanila> yes
07:05:44 <isaacbw> cool
07:06:45 <k0ral> I also tried "manyTill anyChar (lookAhead . try $ void newline <|> eof)" but it doesn't work either
07:06:51 <isaacbw> is there a way to do it and rename Just to Wellformed and Nothing to Malformed?
07:06:56 <isaacbw> but still have all the instances of Maybe?
07:07:17 <isaacbw> (not that I plan on doing this, just curious at this point)
07:07:47 <geekosaur> no, it aliases types, not constructors
07:08:11 <isaacbw> so is it possible to alias constructors?
07:09:03 <thebnq> > let foo = Just in foo 3 --this?
07:09:04 <lambdabot>  Just 3
07:09:12 <Fuuzetsu>  what's a good package that provides easy to use FFT? I'm looking for something as easy to use as MATLAB's ‘fft’
07:09:17 <Fuuzetsu> the fft package on hackage looks scary
07:09:21 <Iceland_jack> isaacbw: You can in a much more real way using PatternSynonyms
07:09:45 <Iceland_jack> with
07:09:45 <Iceland_jack>     pattern WellFormed = Just
07:09:45 <Iceland_jack>     pattern Malformed  = Nothing
07:10:19 <Iceland_jack> you can pattern match and construct values
07:11:29 <Fuuzetsu> pure-fft looks nice
07:11:31 <Iceland_jack> I suppose you need
07:11:31 <Iceland_jack>     pattern WellFormed a = Just a
07:18:06 <isaacbw> Iceland_jack: ooh, cool
07:18:20 <Iceland_jack> This is a recent addition to GHC 7.8
07:19:48 <isaacbw> is it a language extension, or prelude?
07:19:55 <isaacbw> (or something else?)
07:19:58 <Iceland_jack> Language extension
07:20:18 <isaacbw> how do you describe core features. Core?
07:20:26 <Iceland_jack> http://www.haskell.org/ghc/docs/7.8.1-rc1/html/users_guide/syntax-extns.html#pattern-synonyms
07:20:50 <Iceland_jack> You can name the standard they're in, like Haskell98
07:21:05 <geekosaur> "Report" if I'm being short. "Core" usually refers to the intermediate language used by GHC
07:21:17 <geekosaur> so other uses can be confusing
07:22:34 <isaacbw> hmm, having a whole hackage package for snap init seems a waste. Really ought to just be a shell script
07:22:43 <isaacbw> or a clonable repository
07:24:57 <isaacbw> unless it does more than it seems
07:30:05 <Sorella> isaacbw, yes, PureScript is eager.
07:30:52 <isaacbw> bjz_: ^^
07:32:24 <isaacbw> Sorella: are there any language features of Elm that make it good for FRP, or is it all the kind of thing you could do in userspace?
07:32:50 <isaacbw> as in, could you do FRP with Purescript in userspace
07:34:49 <Firebox> (\x -> length x >15) vs (\x -> length x >15)  <---- which is right?  tutorial written like this 'then we write the parameters, separated by spaces.'.
07:35:00 <Firebox> (\x -> length x >15) vs (\  x -> length x >15)  <---- which is right?  tutorial written like this 'then we write the parameters, separated by spaces.'.
07:36:09 <peteretep> Firebox: I don't put a space after \
07:36:25 <k00mi> Firebox: doesn't matter
07:36:32 <Firebox> ok thanks
07:37:16 <k00mi> Firebox: if you have more than one parameter you seperate them by spaces, e.g. (\x y -> x > y)
07:37:40 <Firebox> ok i see. thanks
07:38:03 <Sorella> isaacbw, well, Elm is strict and uses regular push-based FRP. You could do it in any language in userspace, but since Elm has been designed for this, you can expect the compiler to optimise things around for you (like graph relationships and stuff).
07:38:15 <Sorella> s/graph/node/, even
07:39:28 <Flonk> You pass the number of threads as a command line arg (-N). Is there a way to read that value?
07:39:41 <isaacbw> Sorella: did you see my comment about xml literals? That would be a pretty great feature to give Purescript an edge
07:40:33 <hvr> does anyone here know of a simple hello-world using http://hackage.haskell.org/package/gitlib-3.0.0 ?
07:40:37 <isaacbw> like hsx
07:43:21 <ClaudiusMaximus> Flonk: getNumCapabilities or something like that
07:44:23 <Flonk> ClaudiusMaximus: Ah yes, that seems to be it! Thanks :)
07:48:33 <SrPx_> Hello, would you guys provide me a very good and complete resource for learning about types, from a programmer point of view? I'd like to deeply explore this, starting from explaining the simply typed lambda calculus all the way to dependent types. Explaining how they relate, and how everything relates to logic programming. Is there anything like that?
07:48:49 <klrr_> @where tapl
07:48:49 <lambdabot> http://www.cis.upenn.edu/~bcpierce/tapl/
07:48:52 <klrr_> SrPx_: ^
07:49:05 <SrPx_> Thaanks!
07:49:12 <beaky> hello
07:49:28 <beaky> what is the haskell way to program state machines
07:49:50 <klrr_> anyone know what the best way to store a progressivly growing mutable state which after being "full" it removes the last bit?
07:50:09 <matheus23> when I have an ambigious module name while loading something into GHCI, how can I tell it to use the right one?
07:50:09 <matheus23> I'm currently having the issue, that I want to load a file into GHCI that imports GLFW. But GLFW is present in both the packages GLFW and GLFW-b. I want to tell it to use GLFW
07:50:19 <Iceland_jack> SrPx_: Read Types and Programming Languages (TaPL)
07:51:07 <SrPx_> Iceland_jack: thanks too, I love when there is a consensus on something!
07:52:24 <ClaudiusMaximus> klrr_: something like  atomicModifyIORef' mutable (\oldState -> (take maxSize (newThing:oldState), ())  perhaps?
07:52:30 * hackagebot sloane 1.5.1 - A command line interface to Sloane's On-Line Encyclopedia of Integer Sequences  http://hackage.haskell.org/package/sloane-1.5.1 (AndersClaesson)
07:53:05 <isaacbw> React isn't a form of FRP is it?
07:54:49 <klrr_> ClaudiusMaximus: to clarify what i mean: is State sufficient for such a task or are there perhaps a better way to do it? the program will probably run for a whole year so i dont want to memory usage to change drastically
07:55:10 <Sorella> isaacbw, I did not. TBF, I'm not much into XML literals. I've thought about designing a language with them before, but with a sufficiently powerful language they're basically useless.
07:55:36 <Sorella> isaacbw, React is just reactive. There are plenty of formulations of reactive things, including data flow languages.
07:57:55 <darthdeus> guys, if i have a main function using System.Environment.getArgs, is there a way to call main from GHCi with aprameters in a way that they'd be parsed by getArgs?
07:59:51 <darthdeus> also if i have a file with a module Something that isn't module Main, how can i compile it s othat it produces a binary as if it was module Main?
08:01:07 <geekosaur> darthdeus, :main
08:01:32 <geekosaur> and the other is -main-is, IIRC
08:03:24 <darthdeus> thanks :)
08:03:42 <darthdeus> and one more question :P if i'm getting Prelude.(!!): index too large, can i somehow get a line number?
08:04:04 <edwardk> @remember malc I have a coworker who constantly reads haskell stuff at work, nudged him towards the lens talk, that should push him towards actually doing work at work.
08:04:04 <lambdabot> Nice!
08:04:08 <geekosaur> not easily due to laziness
08:04:49 <darthdeus> edwardk: are there any good talks about lenses online? i keep hearing about them but still not sure how to use them
08:05:01 <darthdeus> geekosaur: and not-easily? my program is very trivial
08:06:03 <Earnestly> malc_: Are you llpp dev?
08:06:17 <Iceland_jack> darthdeus: grep -n '!!' :)
08:06:30 <malc_> Earnestly: aye
08:06:31 <geekosaur> I have this recollection that there are some things on hackage that try to help with this but I'm not spotting them immediately
08:06:39 <Earnestly> malc_: \o/, please accept the Makefile :D
08:06:51 <Earnestly> malc_: (I'm not holo)
08:07:01 <geekosaur> and I think you end up with overriding (!!) with your own version anyway, or something like that
08:07:13 <Earnestly> malc_: But otherwise, best damn pdf reader I've found.  Thanks
08:07:34 <malc_> Earnestly: thanks :) now please enlighten me wtf is holo?
08:07:53 <Earnestly> malc_: The guy who mailed you about using XDG and wrote a makefile for you
08:07:57 <companion_cube> isn't a coworker supposed to cowork anyway?
08:07:59 <FreeFull> One important thing to realise is that lens is a huge library, and you probably will need less than half of it for your program
08:08:03 <malc_> Earnestly: Mark?
08:08:07 <Earnestly> Instead of using the build script
08:08:30 <geekosaur> (also if I find myself using (!!) I will generally reconsider what I am doing anyway because lists are probably the wrong type...)
08:09:00 <Earnestly> Yeah, packaging llpp is a bit of a pain, so he wrote a makefile and patched it to use mupdf 1.3, now it builds and updates in a few seconds
08:09:13 <Earnestly> Without having to download snapshots
08:10:10 <Iceland_jack> geekosaur: You mean there's a nicer way of writing this?!
08:10:10 <Iceland_jack> > let xs = "list" in [ ord (xs !! i) | i <- [0..length xs - 1] ]
08:10:11 <lambdabot>  [108,105,115,116]
08:10:18 <edwardk> llpp is still going strong, eh?
08:10:20 <malc_> Earnestly: as i explained to him - i had a script which didn't, it suffered from bitrot so it was taken down, unless someone tends the stuff it's pointless
08:10:47 <Earnestly> Yeah, so maintainers have to
08:11:14 <malc_> edwardk: sorta depends on the definition of strong :)
08:13:04 <Earnestly> You hardcoded .config as well, which is not where I set XDG_CONFIG_HOME to, so that he also fixed that too \o/
08:14:08 <Earnestly> (Less 'that's)
08:15:53 <malc_> Earnestly: llpp ${XDG_CONFIG_HOME:+-c $XDG_CONFIG_HOME/config}
08:16:01 <malc_> would work as an alias or something
08:16:03 <Earnestly> Ew
08:16:18 <Earnestly> Three line patch is better
08:25:17 <Fristi_> hello
08:26:33 <Fristi_> i want to deploy an app to a ubuntu machine. the app itself is developed on macosx.. what are my options to bring the binary over to macosx?
08:26:44 <Fristi_> i mean ubuntu
08:27:00 <Yaniel> cross-compiling?
08:27:11 <Fristi_> via -static?
08:27:40 <hakujin> Fristi_: alternatively, set up a VM of the Ubuntu version/arch you're targeting on OSX and compile your binary there
08:30:12 <Fristi_> Yaniel: do you have any good resource on how to do that? cross compiling
08:30:29 <SrPx_> OK I'm reading the book, came to a quick question, isn't it possible to separate the type system from the language? In a way that you could use whatever type system you fnd best?
08:30:32 <Fristi_> hakujin: Thought of that, but would take that as last resort :)
08:31:43 <Yaniel> a VM is likely to be the easiest way out
08:31:46 <Yaniel> and safest
08:33:33 <Fristi_> Yaniel: i see.. oke guess that will be the case
08:41:01 <isaacbw> found those slides I was talking about! http://mth.io/talks/haskell-in-production/#/
08:42:27 <isaacbw> how's the NLP scene in haskell? Any good implementations of dependency trees?
08:43:24 <klrr_> in pipes is there a way to check if there is a value to await, if its not there then just ignore it?
08:43:34 <klrr_> so you dont need to block it so to speak
08:44:18 <jmcarthur> klrr_: I think that is nonsensical in pipes. If you have control then by construction there is nothing currently offering you a value.
08:45:38 <bennofs> klrr_: if you want to do that, look at pipes-parse
08:45:58 <jmcarthur> that's not quite the same thing either though
08:46:17 <jmcarthur> pipes-parse just gives you messages in chunks and allows you to not consume all of the chunk at once
08:46:44 <bennofs> draw :: Monad m => Parser a m (Maybe a)
08:47:24 <bennofs> Yes, pipes-parse is a new abstraction, but it provides these features like "check if there is still input"
08:47:47 <jmcarthur> what i mean is that there's still no chance for some other stage of the pipeline to run while you are running. if there's nothing to consume there will never be anything to consume until you actually yield control again
08:48:13 <jmcarthur> so if all you want is polling without that chunking i described then pipes is the wrong abstraction, probably
08:48:56 <klrr_> bennofs: so, if its nothing there it will retrieve nothing? or will it wait till there is something and if its an exception it will return nothing?
08:50:08 <bennofs> jmcarthur: but you can write Producer a -> (Maybe a, Producer a)
08:50:34 <klrr_> jmcarthur: well, im writing a IRC bouncer, and the client yields to a pipe which handles the logic and then that pipe yields to the server, i also somehow need to keep the connection alive at the server
08:51:20 <bennofs> jmcarthur: so if your consumer is the last part of the pipeline, you can just use evalStateT :: Parser a m r -> Producer a m x -> m r to connect your parser (which can use draw)
08:51:38 <klrr_> basically, i have a pipe that retrieves values from several places
08:51:47 <klrr_> two to be precise
08:51:54 <klrr_> one "internal" and one is just a producer
08:52:15 <klrr_> basically, i dont want the producer to block if i need to send a pingpong downstream
08:53:28 <bennofs> klrr_: maybe you can implement your logic using some kind of "concurrency"?
08:55:23 <klrr_> yeah
08:56:02 <bennofs> klrr_: there is pipes-concurrency
08:56:39 * Iceland_jack read that as ‘pipes-conspiracy’
08:56:46 <jmcarthur> bennofs: yeah, but that's just writing your own interpreter
08:57:14 <klrr_> im already using it
08:57:32 <klrr_> not sure how i can use it to solve this particular problem though
08:57:44 <ski> SrPx_ : here's some things which could be interesting to check out
08:57:50 <ski> "Crash Course on Notation in Programming Language Theory" by Jeremy Siek in 2012-07-16 at <http://siek.blogspot.com/2012/07/crash-course-on-notation-in-programming.html>
08:57:57 <ski> "Polymorphic Type Inference" by Michael I. Schwartzbach in 1995-03 at <http://web.cecs.pdx.edu/~antoy/Courses/TPFLP/lectures/TYPE/typeinf.p(s|df)>
08:58:06 <klrr_> jmcarthur: what you mean with that statement?
08:58:09 <Eduard_Munteanu> What's a nice package that provides a trie-based map, if I intend to use Text keys?
08:58:12 <ski> "Basic Polymorphic Typechecking" by Luca Cardelli in 1987-04 - 1988-06-21 at <http://lucacardelli.name/Papers/BasicTypechecking.pdf> (someone else mentioned this, i haven't checked it out yet)
08:58:17 <ski> "On Understanding Types, Data Abstraction, and Polymorphism" by Luca Cardelli,Peter Wegner in 1985-12 at <http://lucacardelli.name/Papers/OnUnderstanding.A4.pdf>
08:58:20 <ski> "Interactive Tutorial of the Sequent Calculus" by Edward Z. Yang (ezyang) in 2012 at <http://logitext.mit.edu/logitext.fcgi/tutorial>
08:58:23 <bennofs> klrr_: you want to "await" input from two places concurrently? (you don't want to first wait for input from the first producer, then from the second)
08:58:24 <Eduard_Munteanu> Or even bytestring, really.
08:58:36 <Iceland_jack> Those are excellent resources ski
08:58:40 <jmcarthur> klrr_: in response to "<bennifs> jmcarthur: but you can write Producer a -> (Maybe a, Producer a)"
08:58:45 <ski> SrPx_ : oh, and TaPL, but that was already mentioned :)
08:58:55 <klrr_> jmcarthur: okey
08:58:57 <ski> Iceland_jack : which is why i mention them ;)
08:59:00 <klrr_> bennofs: yes
08:59:01 <Iceland_jack> hah
08:59:20 <klrr_> bennofs: basically, i need to communicate with a client and a server and making those two communicate
08:59:37 <klrr_> if a client is connected that is
08:59:55 <Iceland_jack> SrPx_: After you've researched all of those you'll be happy to know there is an Advanced Topics in Types and Programming Languages which is a continuation of TaPL
09:00:01 <jmcarthur> klrr_: for that the first tools i'd probably reach for (lacking context, at least) is async
09:00:08 <bennofs> klrr_: so you just fork two threads, one that always awaits from the first source and one that always awaits from the second source. If you want to merge the results, just let them both write their results to the same channel.
09:00:16 <Eduard_Munteanu> Actually I wonder if 'Map [Text] a' is good enough.
09:00:44 <jmcarthur> klrr_: async allows you to do stuff like fork two concurrent jobs and await their results at once
09:00:48 <klrr_> channel is same "spawn mailbox"?
09:00:53 <jmcarthur> klrr_: getting control back when either of them returns
09:00:59 <darthdeus> guys are there some haskell conferences with videos available online?
09:01:05 <SrPx_> Iceland_jack: ski oh okay guys I'm on my way through it (:
09:01:10 <klrr_> jmcarthur: hmm, perhaps what i want gonna look into it
09:01:38 <Iceland_jack> SrPx_: We expect a report by next week
09:01:53 <SrPx_> haha ok ?
09:02:05 <Iceland_jack> Well, I do at least
09:02:21 <bennofs> klrr_: maybe you can fork one thread for server -> client communication and another for client -> server communication?
09:02:33 <ski> SrPx_ : seriously, it'd be nice to hear what you think about them
09:02:51 <ski> whenever you've found the time to check them out
09:03:37 <klrr_> bennofs: yeah, that's sounds like a good idea. one only concerned with passing messages and answering pingpongs, one listening and handling the client and one that start working if a client is connected
09:05:18 <gwz> hey, if I ave something like data tree = Rows[Int] [tree] how can I get the Rows from the type tree
09:05:46 <Eduard_Munteanu> gwz: do a breadth-first traversal
09:06:17 <Eduard_Munteanu> You should be a little more careful about capitalization there, though.
09:06:35 <ski> gwz : is the list of `Int's your "rows" ?
09:06:49 <gwz> yes
09:06:50 <SrPx_> ski: ok!
09:07:01 <Firebox> d
09:07:24 <ski> gwz : it's also not clear whether you want to get all the rows in a tree, or just the ones in the top (root) node of the tree, or perhaps some other selection
09:07:43 <ski> gwz : if you just want the rows of the top node, then it's just a basic pattern-matching
09:08:36 <ski> @let data GwzTree = Rows [Int] [GwzTree] deriving (Show,Eq)
09:08:38 <lambdabot>  Defined.
09:09:05 <ski> @let rootRows :: GwzTree -> [Int]; rootRows (Rows rows children) = rows
09:09:05 <lambdabot>  Defined.
09:09:11 <ski> gwz : e.g. like that
09:09:35 <gwz> got it thanks
09:09:41 <ski> gwz : to get all rows in the tree, you'd need to traverse the whole tree, boiling down to recursion in the end
09:10:05 <isaacbw> hmm, how would you implement something like a file tree with FRP. Surely somewhere you need to store the state of which folders are expanded and which aren't
09:16:48 <gwz> @let data GwzTree = Val Int | Rows [Int] [GwzTree] deriving (Show,Eq)
09:16:48 <lambdabot>  .L.hs:157:6:
09:16:48 <lambdabot>      Multiple declarations of `GwzTree'
09:16:48 <lambdabot>      Declared at: .L.hs:152:6
09:16:48 <lambdabot>                   .L.hs:157:6
09:16:48 <lambdabot>  
09:18:09 <gwz> @let data GwzTree2 = Val Int | Rows [Int] [GwzTree2] deriving (Show,Eq)
09:18:10 <lambdabot>  .L.hs:158:17:
09:18:10 <lambdabot>      Multiple declarations of `Rows'
09:18:10 <lambdabot>      Declared at: .L.hs:152:16
09:18:10 <lambdabot>                   .L.hs:158:17
09:18:48 <tibbe> Criterion reports different runtime for two pieces of code but the assembly generate for the two pieces are the same, modulo label names :(
09:20:14 <isaacbw> @help
09:20:14 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
09:20:17 <isaacbw> @list
09:20:17 <lambdabot> What module?  Try @listmodules for some ideas.
09:20:22 <isaacbw> @help list
09:20:22 <lambdabot> list [module|command]. Show commands for [module] or the module providing [command].
09:20:25 <isaacbw> list
09:20:28 <gwz> what if I have a tree with a Int value and rows of [int][[tree], wouldn't my rootRows method now need to handle both Int and [Int]
09:20:33 <isaacbw> @unwrap do { getLine }
09:20:33 <lambdabot> Unknown command, try @list
09:20:39 <isaacbw> @listmodules
09:20:39 <lambdabot> activity base bf check compose dice dict djinn dummy elite eval filter free fresh haddock help hoogle instances irc karma localtime more oeis offlineRC pl pointful poll pretty quote search slap source spell system tell ticker todo topic type undo unlambda unmtl version where
09:20:48 <isaacbw> @undo do { getLine }
09:20:48 <lambdabot> getLine
09:21:02 <isaacbw> @undo getLine >>= printLn
09:21:02 <lambdabot> getLine >>= printLn
09:21:13 <isaacbw> @undo do { l <- getLine; printLn l }
09:21:13 <lambdabot> getLine >>= \ l -> printLn l
09:21:22 <Eduard_Munteanu> tibbe: how do you compare the code?
09:21:24 <gwz> rootRows :: Tree -> [Int];  rootRows (Val val ) = val; rootRows (Rows rows children) = rows
09:21:34 <isaacbw> @undo do { l <- getLine; printLn l; printLn l }
09:21:34 <lambdabot> getLine >>= \ l -> printLn l >> printLn l
09:21:49 <ski> gwz : yes
09:21:50 <dwcook> @. pl undo do { l <- getLine ; printLn l }
09:21:50 <lambdabot> printLn =<< getLine
09:22:08 <gwz> ski: but Val returns Int
09:22:11 <ski> gwz : but `val' has type `Int', not type `[Int]', so you need to fix it
09:22:13 <gwz> and the function expects [Int]
09:22:15 <isaacbw> dwcook: what was that
09:22:22 <dwcook> isaacbw, @. is plugin composition
09:22:29 <ski> @undefine
09:22:29 <lambdabot> Undefined.
09:22:32 <ski> @let data GwzTree = Val Int | Rows [Int] [GwzTree] deriving (Show,Eq)
09:22:33 <lambdabot>  Defined.
09:22:45 <ski> @let rootRows :: Tree -> [Int];  rootRows (Val val) = val; rootRows (Rows rows children) = rows
09:22:45 <lambdabot>  .L.hs:147:13:
09:22:46 <lambdabot>      Expecting one more argument to `Tree'
09:22:46 <lambdabot>      In the type signature for `rootRows': rootRows :: Tree -> [Int]
09:22:48 <isaacbw> @help pl
09:22:48 <lambdabot> pointless <expr>. Play with pointfree code.
09:22:48 <tibbe> Eduard_Munteanu: -ddump-opt-cmm and then opendiff the two versions
09:22:52 <ski> er
09:23:01 <ski> @let rootRows :: GwzTree -> [Int]; rootRows (Val val) = val; rootRows (Rows rows children) = rows
09:23:01 <lambdabot>  .L.hs:151:22:
09:23:02 <lambdabot>      Couldn't match expected type `[Int]' with actual type `Int'
09:23:02 <lambdabot>      In the expression: val
09:23:02 <lambdabot>      In an equation for `rootRows': rootRows (Val val) = val
09:23:08 <isaacbw> is pointfree code stuff without parameters?
09:23:08 <ski> gwz : there ^
09:23:16 <dwcook> isaacbw, no explicit parameters, yes
09:23:20 <isaacbw> right
09:23:22 <isaacbw> cool
09:23:42 <Eduard_Munteanu> tibbe: I suspect a lot of other stuff matters, like whether the binary is statically or dynamically-linked, and how many libs it links to
09:23:43 <gwz> ski: so there is no way to define that without changing the Val to be also of [int]
09:23:48 <Iceland_jack> isaacbw: and is generally more for fun than for actual use, people tend to go overboard with it :)
09:24:26 <ski> gwz : yes there is. just wrap `val' in a list ?
09:24:58 <ski> gwz : or, if you want to ignore `val', you could return an empty list
09:25:13 <ski> gwz : several ways, depending on what you want to do, exactly
09:25:38 <gwz> well for the traversal, I want to get the val and then the rows etc
09:26:26 <tibbe> Eduard_Munteanu: should be the same. The core is the same too.
09:26:39 <tibbe> Eduard_Munteanu: doesn't bode well for the reproducibility of this benchmark
09:28:20 <Eduard_Munteanu> tibbe: try longer runs, that should lower the significance of startup delays and such
09:30:40 <tibbe> trying now
09:31:53 <ski> gwz : consider e.g. `Rows [0,1] [Rows [2] [],Leaf 3]' -- what would you like `rows' applied to this value to evaluate to ?
09:32:17 <Eduard_Munteanu> tibbe: btw, if you compare to a binary that isn't rewritten between runs you may get cache effects
09:32:38 <Eduard_Munteanu> (rewritten as in recompiled for example)
09:35:30 <isaacbw> I'm not sold on using haskell-like languages for clientside web development
09:35:55 <u-ou> <lambdabot> can't find file: L.hs --?
09:36:00 <isaacbw> it seems like pretty much *everything* is state there, so instead of having state be a small part of a larger stateless system, all of your FP is modeling state
09:36:12 <isaacbw> might as well use a stateful language and cut down on cruft
09:36:35 <isaacbw> unless someone can convince me otherwise :D
09:36:50 <Eduard_Munteanu> isaacbw: there isn't much cruft in using stateful code in Haskell, really
09:36:51 <Iceland_jack> isaacbw: I could think of some reasons against FP wor client-side web development but ‘statefulness’ would not be one of them
09:37:37 <Eduard_Munteanu> isaacbw: do you have some code you consider clunky and want tips on improving it?
09:38:05 <Iceland_jack> isaacbw: How much experience have you got with Haskell btw?
09:38:57 <isaacbw> Iceland_jack: only a few weeks
09:39:00 <tibbe> Eduard_Munteanu: yeah
09:39:13 <isaacbw> I'm just looking over elm examples
09:39:28 <isaacbw> and it seems like a roundabout way to solve the same problem for minimal gain
09:39:32 <Iceland_jack> isaacbw: Elm is very nice, it's similar to Haskell but differs in some fundamental ways
09:39:38 <Iceland_jack> isaacbw: Why do you say that?
09:41:18 <Eduard_Munteanu> isaacbw: it is sort of roundabout if you just started using Haskell, it's not quite the programming language you can learn and apply quickly.
09:41:21 <isaacbw> well, I'm a little put off by the fact that the examples are all clever graphics, and no real UIs
09:41:36 <Eduard_Munteanu> isaacbw: are you talking about FP or FRP?
09:41:43 <Iceland_jack> isaacbw: look at this http://elm-lang.org/learn/Escape-from-Callback-Hell.elm
09:41:43 <isaacbw> perhaps that just because the elm folks don't care about real UIs, and isn't a factor of the language itself
09:41:48 <isaacbw> Eduard_Munteanu: FRP I guess
09:41:50 <isaacbw> not FP
09:41:56 <Iceland_jack> FRP ≠ FP :)
09:42:06 <Iceland_jack> FRP is still a topic of research
09:42:19 <isaacbw> I figured FRP was the only real way to apply FP to UIs
09:42:32 <Eduard_Munteanu> isaacbw: if you started using Haskell recently, FRP should likely be left alone until you get comfortable.
09:42:32 <isaacbw> are there other avenues I can explore?
09:42:42 <Iceland_jack> isaacbw: You can use the normal imperative way
09:42:43 <isaacbw> Eduard_Munteanu: well, I definitely understand the concepts
09:42:49 <Eduard_Munteanu> isaacbw: sure, gtk2hs is rather alright
09:42:49 <isaacbw> if not the implementations
09:42:55 <hpc> isaacbw: understanding the libraries is quite different from the concept ;)
09:43:18 <Iceland_jack> isaacbw: Look at the link I sent you, I believe all the webpages on elm-lang.org are written in Elm
09:43:35 <isaacbw> but what do you gain from it? Doesn't seem like type safety is a big thing. Is it just so you can think the way you're used to thinking with haskell?
09:44:28 <Eduard_Munteanu> isaacbw: if it wasn't clear what I said earlier, Haskell isn't about FRP in particular.
09:44:46 <isaacbw> no, I understand that
09:45:01 <Iceland_jack> isaacbw: The rationale is explained quite nicely on elm-lang.org and in the Elm paper http://www.seas.harvard.edu/sites/default/files/files/archived/Czaplicki.pdf :) don't expect #haskell to sell the concept of Elm or FRP to you though
09:45:12 <isaacbw> hah, okay
09:45:18 <isaacbw> I guess I *was* hoping someone would sell it to me
09:45:34 <Eduard_Munteanu> isaacbw: what are you interested in using it for?
09:45:59 <Iceland_jack> isaacbw: I would've thought that the page I sent kind of sells itself :)
09:46:43 <Iceland_jack> You can do
09:46:44 <Iceland_jack>     (tagField, tags) = field "Tag"
09:46:44 <Iceland_jack> and then you can manipulate "tags" as a value, which changes with time
09:47:04 <isaacbw> well, I've got a few web projects that I'm sitting on. One is a longer-term project and the other is a quick 1-2 month application. We'll be using haskell for the backend for sure, but I'm exploring options for the frontend that aren't Polymer, which is probably what I would use otherwise
09:47:20 <isaacbw> the 1-2 month one is practice using haskell for web development
09:47:39 <Eduard_Munteanu> isaacbw: if you're interested in web stuff, look at Yesod or Snap
09:47:49 <isaacbw> yea, snap is what I've been delving into
09:47:50 <Eduard_Munteanu> (as Haskell web frameworks)
09:48:02 <isaacbw> yesod seems a bit too esoteric for my experience level
09:48:07 <Iceland_jack> isaacbw: I would respectfully suggest getting more familiar with Haskell and putting Elm and FRP on the backburner for now
09:48:20 <isaacbw> Iceland_jack: that seems like sound advice
09:48:36 <isaacbw> can you have reactive programming with a functional language that *isn't* frp?
09:49:28 <Eduard_Munteanu> isaacbw: languages don't quite have an FRPness attribute
09:49:52 <Firebox> length (filter (\xs -> length xs > 1) [1,2,3])    <---- this is not work?
09:50:16 <bennofs> Firebox: what is the type of xs?
09:50:19 <Eduard_Munteanu> Firebox: the filtering predicate applies to each element, not the whole list
09:50:40 <Iceland_jack> > filter (\x -> x > 1) [1,2,3] -- This works?
09:50:40 <lambdabot>  [2,3]
09:50:41 <Eduard_Munteanu> Firebox: so that ends up as, e.g.  length 1 > 1   which is meaningless
09:50:58 <isaacbw> Eduard_Munteanu: what I mean is, if you do reactive programming in a functional language, is it by virtue of being reactive, and fp, frp?
09:51:05 <Firebox> but why length not work?
09:51:18 <Iceland_jack> Firebox: filter applies the function to each *element* of the list
09:51:21 <conal> isaacbw: to give you some background about the intent and philosophy of FRP, see http://stackoverflow.com/questions/5875929/specification-for-a-functional-reactive-programming-language and follow links. hopefully you'll get a sense of a space of possibilities around FRP as well.
09:51:25 <Eduard_Munteanu> Firebox: what's 'length 2' ?
09:51:33 <Firebox> Iceland_jack: ok i understand
09:51:35 <Firebox> each
09:51:40 <absence> isaacbw: yes, frp is doing reactive programming in an fp
09:51:47 <Iceland_jack> fridim_: What do you want to accomplish?
09:51:51 <klrr_> isaacbw: i dont know what reactive programming is, but FRP is specifically programming with evenst and behaviours
09:52:00 <absence> isaacbw: you don't need an "frp language" to do it
09:52:04 <klrr_> classic FRP*
09:52:10 <Iceland_jack> isaacbw: You may want to listen to conal instead of me on the issue of FRP :)
09:52:17 <absence> isaacbw: haskell has several frp libraries
09:52:25 <isaacbw> oh, conal
09:52:31 <isaacbw> I was just reading through your stuff
09:52:51 <conal> isaacbw: warning: recently many folks use "FRP" to mean something quite different from the original work, ie they use it to mean vaguely "functional" and "reactive".
09:52:54 <Eduard_Munteanu> isaacbw: that's the nice thing about #haskell, you sometimes meet the researchers in here :D
09:58:23 <conal> isaacbw: i'm happy to answer specific questions that come up in your reading. you can often find me on #haskell
09:59:49 <Iceland_jack> isaacbw: Have you looked at Learn You a Haskell?
09:59:49 <Iceland_jack> @where lyah
09:59:49 <lambdabot> http://www.learnyouahaskell.com/
10:06:33 <isaacbw> Iceland_jack: yea, though I kind of skip around. I just learned about the State monad last night
10:06:43 <isaacbw> conal: cool! thank you
10:06:58 <conal> :)
10:07:31 <Iceland_jack> isaacbw: So just to be clear, even though Haskell provides abstractions like the State monad that does not mean that you'd use the State monad when languages like C use state
10:08:21 <mzero> I just heard a talk by Erik Meijer yesterday about Rx, his reactive dual to SQL ... it was a great talk
10:10:03 <simon`> Has anyone encountered a cabal error like this: "happy: /tmp/yaourt-tmp-simon/aur-haskell-platform/pkg/haskell-platform/usr/share/happy-1.18.10/HappyTemplate-arrays-coerce: openFile: does not exist (No such file or directory)"
10:10:03 <simon`>  
10:10:04 <simon`>  
10:10:13 <Iceland_jack> mzero: Have you got the link?
10:10:13 <isaacbw> Iceland_jack: sure, I think I undestand how State is useful
10:10:20 <simon`> trying to install package "pretty-show"
10:10:35 <mzero> Iceland_jack: it was a live talk at Google
10:10:38 <Iceland_jack> ah
10:10:43 <isaacbw> I have a fair bit of Clojure and Scheme experience before Haskell, so I understand (impure & untyped) FP
10:10:49 <Iceland_jack> isaacbw: The point is that you don't really need it that often :)
10:10:52 <isaacbw> so I don't look for problems to solve with State :P
10:11:19 <heaumer_> mzero: what's Rx btw?
10:11:35 <JoaoPortela> j #archlinux
10:11:37 <mzero> simon`: looks like you need    --happy-options=--template=<someplace>
10:11:45 <SaBer> heaumer_: Reactive Extenstions
10:11:48 <mzero> if you are using a cusom happy build
10:12:00 <SaBer> heaumer_: https://rx.codeplex.com/
10:12:14 <heaumer_> SaBer: ok thanks :-)
10:13:02 <simon`> mzero: I'm not, I've built this same project before on other machines and it's never been a problem
10:14:02 <mzero> Is the path from /tmp suspicious to you? I'm wondering if, on this machine, there are two versions of happy and they are not playing well
10:14:03 <mmachenry> I am having trouble figuring out how to create a Data.Text.Internal.Text. I am using simpleMail from Network.Mail.Mime and the examples show String being passed but the examples don't compile. I tried adding a pack from Data.Text but that's not "internal" http://lpaste.net/101242
10:15:26 <isaacbw> does cabal-dev do anything that cabal 1.18 doesn't?
10:15:51 <bennofs> mmachenry: replace Data.Text.Lazy by just Data.Text
10:15:59 <bennofs> mmachenry: Data.Text.Internal.Text is a strict text
10:16:15 <bennofs> mmachenry: btw, you can avoid the pack by using {-#
10:16:23 <bennofs> {-# LANGUAGE OverloadedStrings #-}
10:16:31 <bennofs> at the very top of the file
10:17:10 <mmachenry> bennofs: I get the same error if I keep the pack and just do the replace of my import
10:17:52 <mmachenry> I get a different error if I include overloaded strings though
10:18:43 <bennofs> mmachenry: that's weird
10:18:52 <bennofs> mmachenry: (that you get the same error)
10:19:13 <bennofs> mmachenry: because Data.Text just reexports Text from Data.Text.Internal
10:20:03 <mmachenry> When I overload strings with that language pragma in complains that string is not an instance of address.
10:20:06 <simon`> mzero: yes, it does seem odd, don't know why it would be using some yaourt tmp dir (I'm on arch). ghc-pkg list complains there aresome broken packages but it's difficult to make out what's actually wrong, but the conclusion seems to be that ghc-7.6.3 and bin-package-db-0.0.0.0 are broken
10:21:47 <bennofs> mmachenry: oh hmm, simpleMail takes part of it's argument as a lazy text, and other parts as strict texts. So you need both if you don't use overloaded strings :)
10:22:25 <bennofs> mmachenry: the Address error is because simpleMail takes an Address as the first/second argument, not a String or Text
10:22:35 <zerokarmaleft> isaacbw: best answer there is probably "try both and see"...in my experience, the new sandboxing has been sufficient
10:22:51 <mmachenry> Hm...
10:23:08 <isaacbw> zerokarmaleft: I was about to throw a fit until I discovered cabal repl
10:24:03 <bennofs> mmachenry: so simpleMail (Address (Just "My Name") "my@mail.com") (Address (Just "My Name") "my@mail.com) ...
10:24:17 <bennofs> mmachenry: or use Nothing if you don't want to provide a name
10:24:42 <zerokarmaleft> isaacbw: if you ever want to go beyond project-level sandboxing http://ocharles.org.uk/blog/posts/2014-02-04-how-i-develop-with-nixos.html seems to be the way to go
10:24:59 <guymann> h
10:25:57 <mmachenry> That works bennofs
10:25:59 <mmachenry> Thanks.
10:26:00 <isaacbw> I just need to figure out how to get emacs inferior-process to use cabal repl instead of ghci
10:26:14 <mmachenry> I think the docs I got are out of date or something.
10:27:34 <newbieJoe> I'd like some advice on the best place to discuss haskell papers. I imagine it's a bit much for IRC, but maybe not.
10:27:54 <isaacbw> newbieJoe: #haskell is special
10:28:10 <newbieJoe> I frequently read haskell papers and understand between 75 and 90 percent of the haskell and/or the type theory and/or the semantics. I'm hoping to get closer to 100%.
10:28:17 <prophile> little #haskell wasn't like the other IRC channels
10:29:45 <isaacbw> does IO have to be a top level monad?
10:29:47 <Kron> from quchen's article: "
10:29:47 <Kron> If you're not a beginner, don't fear! I have yet to find an advanced topic nobody in #haskell is able to write an essay about"
10:29:54 <Kron> so true
10:30:08 <Kron> isaacbw, not quite, it's just that main is always IO ()
10:30:24 <Kron> the way the top level of the program works is that it evaluates a constant, known as main. (main :: IO ())
10:30:24 <prophile> isaacbw: what do you mean by that?
10:30:29 <Kron> so I guess you could just do other things
10:30:33 <Kron> and then return IO ()
10:30:34 <isaacbw> prophile: I don't know :(
10:30:48 <Kron> ... well I guess for all intents and newbie purposes, yeah
10:30:55 <isaacbw> could you somehow have IO within a non-IO function and evaluate it by hand
10:30:58 <enthropy> it can be (IO a)
10:31:01 <Kron> IO is the top level monad in a fully standalone compiled haskell program
10:31:05 <Kron> oh yes
10:31:07 <hpc> isaacbw: try not to think of IO as a monad first
10:31:13 <Kron> you can have IO all over the place
10:31:20 <hpc> (think of it as a type first - it will save you some learning pains)
10:31:32 <Kron> > length [IO (), IO (), IO ()]
10:31:33 <lambdabot>  Not in scope: data constructor `IO'
10:31:33 <lambdabot>  Perhaps you meant `In' (imported from Lambdabot.Plugin.Haskell.Eval.Trusted)...
10:31:33 <lambdabot>  Perhaps you meant `In' (imported from Lambdabot.Plugin.Haskell.Eval.Trusted)...
10:31:33 <lambdabot>  Perhaps you meant `In' (imported from Lambdabot.Plugin.Haskell.Eval.Trusted)
10:31:38 <Kron> bah
10:31:40 <Iceland_jack> haha
10:31:48 <vozz> Why am I getting this error? https://gist.github.com/ollieh/cc5f88284f5bade188bb
10:31:51 <Kron> I need to do a return statement and properly typecast it
10:31:56 <Iceland_jack> isaacbw: Kron and hpc are right, ignore anything about Monads. If you use something of type 'IO a' the IO part ‘infects’ the rest of the program :)
10:32:07 <Iceland_jack> I think that's basically what you were asking?
10:32:11 <Kron> well, not exactly, not always
10:32:21 <Kron> my usual example is that you can calculate the length of a list of IO actions
10:32:24 <Kron> and it's just a normal number
10:32:24 <isaacbw> I suppose. Could you have (right arrow indicates depth) IO->non IO->IO
10:32:34 <Kron> you can still reason in pure abstract ways about io-y things, ish
10:32:36 <bennofs> > length [return (), return(), return ()]
10:32:37 <Iceland_jack> Kron: That's right but for simple purposes
10:32:37 <lambdabot>  No instance for (GHC.Base.Monad m0)
10:32:38 <lambdabot>    arising from a use of `GHC.Base.return'
10:32:38 <lambdabot>  The type variable `m0' is ambiguous
10:32:38 <lambdabot>  Possible fix: add a type signature that fixes these type variable(s)
10:32:38 <lambdabot>  Note: there are several potential instances:
10:32:45 <Iceland_jack> isaacbw: sure
10:32:47 <Kron> yeah, for simple purposes sure
10:32:57 <isaacbw> could you *use* that deep, orphaned IO
10:33:11 <bennofs> > length [putStrLn "", return(), return ()]
10:33:12 <lambdabot>  3
10:33:18 <isaacbw> can you maybe simulate an IO environemnt
10:33:23 <isaacbw> or is IO somehow special in GHC
10:33:31 <ion> vozz: Network.HTTP.Conduit does not export def.
10:33:33 <prophile> you mean turning a non-IO computation into something with IO?
10:33:41 <Kron> thanks, bennofs
10:33:48 <Iceland_jack> isaacbw: You can have
10:33:48 <Iceland_jack>     useBoth :: IO a -> IO b -> IO (a, b)
10:33:48 <Iceland_jack>     useBoth oneIO twoIO = do
10:33:48 <Iceland_jack>         one <- oneIO
10:33:51 <Iceland_jack>         two <- twoIO
10:33:55 <Iceland_jack>         return (one, two)
10:34:06 <Iceland_jack> that function can also accept any number of non-IO arguments
10:34:16 <isaacbw> no, I guess I mean turning an IO computation into a pure computation by means of creating the surface area of an outside environment
10:34:35 <prophile> ah, so some kind of sandboxing?
10:34:36 <Iceland_jack> isaacbw: In general it's not possible and doesn't need to be done
10:34:37 <Kron> a tiny sandbox to IO things into? I'm pretty sure you can
10:34:41 <Kron> oh.
10:34:41 <Kron> huh.
10:34:45 <Kron> I didn't realize it wasn't
10:34:52 <prophile> it's an interesting idea
10:34:54 <Kron> can't you just IO to a virtual file or something?
10:35:03 <prophile> isaacbw: there's the ST monad which is sort of that idea restricted to just variables
10:35:14 <Kron> anyway, a great description/non-description of the IO Monad is one here: http://staff.science.uva.nl/~poss/haskell-for-ocaml-programmers.html
10:35:21 <Kron> it just calls them "lists of statements" and that's fairly accurate
10:35:27 <Iceland_jack> isaacbw: You can model IO purely and do all sorts of crazy things, but I'd keep it simple for now :)
10:35:31 <isaacbw> so IO operations are implemented "natively"
10:35:33 <Kron> there are also IOrefs...
10:35:34 <Iceland_jack> (as a data type)
10:35:49 <prophile> isaacbw: essentially, yes
10:36:18 <prophile> the actual IO operations are - by and large - deep magic
10:36:24 <isaacbw> alright :)
10:36:27 <Kron> I think the ultimate purpose of the IO system is just to act as a structured way to hand a list of Things To Do to the operating system to do
10:36:28 <triliyn> Kron: providing an environment to IO is hard because it can't just be a file
10:36:33 <isaacbw> Iceland_jack: yea, I wasn't thinking about actually doing it
10:36:38 <isaacbw> just trying to understand IO better
10:36:39 <triliyn> You also need a virtual internet and array of sockets and things like that
10:36:40 <Kron> you can treat the entire  haskell program as a completely pure and deterministic construction
10:36:46 <Kron> of a big list of IO statements
10:37:01 <Kron> and it evaluates and constructs that system during the runtime and runs it 'outside' haskell
10:37:01 <ion> “What is inside Haskell IO?” https://gist.github.com/ion1/7154691 may or may not be helpful.
10:37:03 <Kron> so haskell remains pure
10:37:10 <triliyn> IO encapsulates every type of side effect possible
10:37:12 <Kron> triliyn: hmmm, ok
10:37:13 <isaacbw> might be "interesting" to implement a complete VM conext in Haskell in which to execute IO
10:37:16 <Iceland_jack> isaacbw: Just play around with IO actions a bit, you'll get an intution for them in no time (rather than trying to learn them by having people explain them)
10:37:21 <Kron> yeah I do like the idea of an IO VM
10:37:25 <Kron> it can be very useful I think
10:37:29 <Iceland_jack> isaacbw: It's been done :)
10:37:31 <isaacbw> ooh
10:37:32 <Iceland_jack> IOSpec
10:37:38 <prophile> if you restrict your IO to a restricted set of operations you can do that easily enough with free monads too
10:37:42 <Kron> ooh I didn't know abotu IOSpec
10:37:50 <Iceland_jack> Using stuff from Data types à la carte
10:38:04 <bennofs> http://hackage.haskell.org/package/IOSpec
10:38:20 <Iceland_jack> I use a similar idea in
10:38:20 <Iceland_jack> @hackage Capabilities
10:38:20 <lambdabot> http://hackage.haskell.org/package/Capabilities
10:38:26 <Iceland_jack> from Data types à la carte as well
10:38:37 <joelteon> QuickCheck might be the coolest thing of all time
10:38:45 <Iceland_jack> joelteon: Agreed :)
10:39:10 <vozz> ion: http://hackage.haskell.org/package/http-conduit-1.8.2/docs/Network-HTTP-Conduit.html#v:def ?? How do I access this then?
10:39:48 <Iceland_jack> isaacbw: But for now, if you understand examples like this you're off to a fine start
10:39:48 <Iceland_jack>     foo :: IO () -> IO ()
10:39:48 <Iceland_jack>     foo action = do putStrLn "Going to run action"
10:39:48 <Iceland_jack>                     action
10:39:51 <Iceland_jack>                     putStrLn "Done."
10:39:54 <Iceland_jack>  
10:41:09 <isaacbw> @undo foo action = do putStrLn "Going to run action"; action; putStrLn "Done"
10:41:09 <lambdabot> foo action = putStrLn "Going to run action" >> action >> putStrLn "Done";
10:41:26 <Iceland_jack> (>>) is read as 'then'
10:41:35 <Iceland_jack>     print 1 >> print 2 >> print 3
10:41:36 <isaacbw> :t (>>)
10:41:36 <lambdabot> Monad m => m a -> m b -> m b
10:41:46 <Iceland_jack> :t (>>) :: IO a -> IO b -> IO b
10:41:47 <lambdabot> IO a -> IO b -> IO b
10:42:00 <bennofs> :t (>>) `asAppliedTo` putStrLn "Going to run action"
10:42:01 <lambdabot> IO () -> IO b -> IO b
10:42:10 <Firebox> flip' :: (a -> b -> c) -> b -> a -> c
10:42:10 <Firebox> flip' f = \x y -> f y x   <------  flip' f = (\x y -> f y x)   <---- right?
10:42:27 <isaacbw> bennofs: ah, I've been looking for something like asAppliedTo
10:42:40 <isaacbw> :t return `asAppliedTo` 0
10:42:40 <Iceland_jack> Firebox: Yes
10:42:40 <lambdabot> (Monad m, Num a) => a -> m a
10:42:47 <Iceland_jack> @src flip
10:42:47 <lambdabot> flip f x y = f y x
10:43:03 <bennofs> isaacbw: it's defined in lambdabot though, so it won't work in GHCi :)
10:43:09 <isaacbw> ah
10:43:11 <isaacbw> darn
10:43:17 <Iceland_jack> The definition is simple enoguh
10:43:20 <Iceland_jack> *enough
10:43:30 <ion> vozz: Are you using http-conduit 1.8.2?
10:43:37 <bennofs> @let myAsAppliedTo f a = let _ = f a in f
10:43:38 <lambdabot>  Defined.
10:43:39 <Firebox> thanks Iceland_jack
10:43:48 <newbieJoe> isaacbw: Thanks. I'll stop by again when I have some coherent questions (I'm currently reading http://conal.net/papers/beautiful-differentiation/ )
10:44:00 <bennofs> > return `myAsAppliedTo` 0
10:44:01 <lambdabot>  No instance for (Data.Typeable.Internal.Typeable1 m0)
10:44:01 <lambdabot>    arising from a use of `M576149529628945024532675.show_M5761495296289450245...
10:44:01 <lambdabot>  The type variable `m0' is ambiguous
10:44:01 <lambdabot>  Possible fix: add a type signature that fixes these type variable(s)
10:44:01 <lambdabot>  Note: there are several potential instances:
10:44:02 <Iceland_jack> You're welcome Firebox
10:44:12 <isaacbw> newbieJoe: I'm much more a noob than you are
10:44:17 <isaacbw> I'm a noob
10:44:19 <isaacbw> you're not a noob
10:44:35 <isaacbw> I couldn't hope to read a Haskell paper and understand a word of it right now :P
10:44:47 <vozz> ion: I think I figured it out, I imported Data.Default and used def instead of Conduit.def
10:45:09 <newbieJoe> Ha! OK, well maybe it'll be others.
10:45:30 <u-ou> is there an English name for <*>
10:45:43 <dwcook> u-ou, ap
10:45:48 <u-ou> ty
10:46:06 <ion> vozz: The documentation for newManager suggests to use defaultManagerSettings, not def. It doesn’t seem to have a Default instance in the current version.
10:46:09 <Iceland_jack> u-ou: http://stackoverflow.com/questions/7746894/are-there-pronounceable-names-for-common-haskell-operators and http://www.haskell.org/haskellwiki/Pronunciation
10:46:42 <u-ou> thanks :3
10:46:46 <ion> Actually, perhaps it does, the Haddock page might just not see it.
10:48:52 <newbieJoe> quit
10:52:27 <vozz> ion: Thanks, that was it, I was reading old documentation :(
10:57:59 <Firebox> addThree = \x -> \y -> \z -> x + y + z  <----- addThree = (\x -> (\y -> (\z -> x + y + z))) <------ right?
10:58:29 <pavonia> yes
10:58:39 <Firebox> thanks pavonia
10:59:01 <isaacbw> what is a list that's been "unwrapped"
10:59:09 <isaacbw> as in [1 :: Int, 2, 3] >>= (\x -> [x])
10:59:11 <isaacbw> what is x
10:59:16 <pavonia> Firebox: It's also equal to \x y z -> x + y + z
10:59:26 <Firebox> ok i see.
10:59:29 <Firebox> thanks pavonia
10:59:35 <pavonia> no problem
10:59:43 <Firebox> :D
11:00:29 <pavonia> isaacbw: x is each number in that list
11:00:54 <isaacbw> oh, right! list's >>= uses  concatMap
11:01:10 <isaacbw> I keep learning things and immediately forgetting them and getting confused again :P
11:01:28 <pavonia> > [1 :: Int, 2, 3] >>= (\x -> [x, 10*x, 100*x])
11:01:29 <lambdabot>  [1,10,100,2,20,200,3,30,300]
11:01:36 <Iceland_jack> Firebox: all these definitions are equivalent :)
11:01:36 <Iceland_jack>     addThree x y z =                   x + y + z
11:01:36 <Iceland_jack>     addThree x y   =             \z -> x + y + z
11:01:36 <Iceland_jack>     addThree x     =       \y -> \z -> x + y + z
11:01:39 <Iceland_jack>     addThree       = \x -> \y -> \z -> x + y + z
11:01:58 <Iceland_jack> > do x <- [1,2,3]; y <- "hello"; return (x, y)
11:01:59 <lambdabot>  [(1,'h'),(1,'e'),(1,'l'),(1,'l'),(1,'o'),(2,'h'),(2,'e'),(2,'l'),(2,'l'),(2,...
11:02:02 <Iceland_jack> > do x <- [1,2,3]; y <- "hello"; [(x, y)]
11:02:03 <lambdabot>  [(1,'h'),(1,'e'),(1,'l'),(1,'l'),(1,'o'),(2,'h'),(2,'e'),(2,'l'),(2,'l'),(2,...
11:02:07 <isaacbw> can you specify the type of a lambda?
11:02:20 <Firebox> thanks Iceland_jack
11:02:22 <Iceland_jack> isaacbw: do you mean
11:02:22 <Iceland_jack> :t \(x :: Int) -> x
11:02:23 <lambdabot> Int -> Int
11:02:23 <isaacbw> Iceland_jack: ooh
11:02:28 <Firebox> good to me
11:02:38 <isaacbw> @undo do x <- [1,2,3]; y <- "hello"; return (x, y)
11:02:38 <lambdabot> [1, 2, 3] >>= \ x -> "hello" >>= \ y -> return (x, y)
11:02:39 <bennofs> Iceland_jack: That needs -XScopedTypeVariables
11:02:40 <dwcook> Iceland_jack, up to DMR, right?
11:02:50 <Iceland_jack> bennofs: yes
11:03:22 * hackagebot pipes-csv 1.3.0 - Fast, streaming csv parser  http://hackage.haskell.org/package/pipes-csv-1.3.0 (WilliamCasarin)
11:03:59 <Iceland_jack> isaacbw: If you want to use that in GHCi you need to do
11:04:00 <Iceland_jack>     ghci> :set -XScopedTypeVariables
11:04:00 <Iceland_jack>     ghci> (\(x :: Int) -> x + x) 5
11:04:00 <Iceland_jack>     10
11:04:33 <Iceland_jack> You can also do
11:04:33 <Iceland_jack> :t (\x -> (x :: Int) + x)
11:04:33 <Iceland_jack> without the extension
11:04:34 <lambdabot> Int -> Int
11:04:49 <Iceland_jack> or
11:04:50 <Iceland_jack> :t \x -> x + x :: Int -> Int
11:04:50 <lambdabot>     No instance for (Num (Int -> Int)) arising from a use of `+'
11:04:50 <lambdabot>     Possible fix: add an instance declaration for (Num (Int -> Int))
11:04:50 <lambdabot>     In the expression: x + x :: Int -> Int
11:04:55 <Iceland_jack> oops
11:05:00 <Iceland_jack> :t (\x -> x + x) :: Int -> Int
11:05:01 <ion> :t (\x -> (x + x) `const` (x :: Int))
11:05:01 <lambdabot> Int -> Int
11:05:01 <lambdabot> Int -> Int
11:05:34 <Iceland_jack> or
11:05:34 <Iceland_jack> :t \x -> let _ = x :: Int in x + x
11:05:35 <lambdabot> Int -> Int
11:05:44 <isaacbw> :t concatMap
11:05:44 <lambdabot> (a -> [b]) -> [a] -> [b]
11:05:50 <Iceland_jack> there are a million ways of doing that :)
11:06:01 <Iceland_jack> :t (=<<)
11:06:02 <lambdabot> Monad m => (a -> m b) -> m a -> m b
11:06:11 <Iceland_jack> :t (=<<) :: (a -> [b]) -> [a] -> [b]
11:06:12 <lambdabot> (a -> [b]) -> [a] -> [b]
11:06:23 <Iceland_jack> Hm those types look kind of similar
11:06:27 <isaacbw> > concatMap (\x -> concatMap (\y -> [x, y]) [1, 2, 3]) [10 20 30]
11:06:28 <lambdabot>  Could not deduce (GHC.Num.Num
11:06:28 <lambdabot>                      (GHC.Integer.Type.Integer -> GHC.Integer.Type.Integer ->...
11:06:28 <lambdabot>    arising from the ambiguity check for `e_1123102030'
11:06:28 <lambdabot>  from the context (GHC.Num.Num b,
11:06:28 <lambdabot>                    GHC.Num.Num (a -> a1 -> b),
11:06:38 <isaacbw> > concatMap (\x -> concatMap (\y -> [x, y]) [1::Int, 2, 3]) [10 20 30]
11:06:39 <lambdabot>  No instance for (GHC.Num.Num a1) arising from the literal `30'
11:06:39 <lambdabot>  The type variable `a1' is ambiguous
11:06:39 <lambdabot>  Possible fix: add a type signature that fixes these type variable(s)
11:06:39 <lambdabot>  Note: there are several potential instances:
11:06:39 <lambdabot>    instance GHC.Num.Num GHC.Types.Double
11:06:41 <isaacbw> :C
11:06:45 <Iceland_jack> isaacbw: [10, 20, 30] :)
11:06:50 <Iceland_jack> > concatMap (\x -> concatMap (\y -> [x, y]) [1, 2, 3]) [10, 20, 30]
11:06:51 <isaacbw> oh :P
11:06:52 <lambdabot>  [10,1,10,2,10,3,20,1,20,2,20,3,30,1,30,2,30,3]
11:06:56 <isaacbw> my lisp was acting up
11:06:56 <Iceland_jack> This isn't Clojure :)
11:07:02 <isaacbw> lol
11:08:05 <Iceland_jack> You can write a GHC extension called ListsWithoutCommaDelimiters if you like!
11:08:35 <bitemyapp> Iceland_jack: I would actually like this.
11:08:44 <isaacbw> how about PretendHaskellIsLisp
11:08:56 <Iceland_jack> bitemyapp: The problem is that Haskell uses juxtaposition for function application
11:08:58 <isaacbw> with s expressions
11:09:04 <Iceland_jack> isaacbw: already exists :)
11:09:07 <isaacbw> haha
11:09:12 <Iceland_jack> Liskell et al
11:09:13 <isaacbw> that's pretty awesome, actually
11:10:01 <dwcook> instance Num (a -> b) where …
11:10:02 <Iceland_jack> bitemyapp: In Clojure you have to parenthesize your expressions, so it would really offer nothing to write
11:10:02 <Iceland_jack>     [(+) (+1) (+ 1 2) (+ 1 2 3)]
11:10:02 <Iceland_jack> as
11:10:02 <Iceland_jack>     [(+), (+1), (+ 1 2), (+ 1 2 3)]
11:10:06 <Iceland_jack>  
11:10:19 <Iceland_jack> *(+ 1)
11:10:39 <isaacbw> one of the things I do really like about lisp syntax is structural editing
11:10:45 <Iceland_jack> Yes that's very nice
11:10:47 <isaacbw> there's structural-haskell-mode but it isn't the same
11:11:35 <Iceland_jack> Lisp simplifies a lot of things, no dealing with fixity errors and so forth
11:12:05 <Iceland_jack> isaacbw: I actually submitted this ticket for GHCi but I suppose it didn't interest people https://ghc.haskell.org/trac/ghc/ticket/8751
11:12:24 <Iceland_jack> feature request + patch
11:12:55 <Iceland_jack> Since I'm not smart enough to keep all the precedence levels and associativities in my head
11:13:36 <isaacbw> I feel like Haskell is missing a lot of tooling to make developers' lives easier. A lot of it assumes you're smart enough to know what's going on
11:13:53 <Iceland_jack> > liftA2 (\x y -> [x, y]) [1,2,3] [10,20,30]
11:13:54 <lambdabot>  [[1,10],[1,20],[1,30],[2,10],[2,20],[2,30],[3,10],[3,20],[3,30]]
11:13:55 <isaacbw> in particular I'm thinking of a proper interactive haskell mode, like cider or slime are to clojure and lisp
11:14:19 <isaacbw> does ghci have type-aware autocomplete?
11:15:03 <Iceland_jack> no
11:15:04 <isaacbw> i guess not. Would probably be a hard problem to solve
11:15:20 <bennofs> isaacbw: just check for each autocompletion if the resulting expression type checks?
11:15:33 <isaacbw> bennofs: efficiently, I guess
11:15:39 <Firebox> flip' :: (a -> b -> c) -> b -> a -> c
11:15:39 <Iceland_jack> it's a bit more involved than that
11:15:40 <Firebox> flip' f = \x y -> f y x     <------ \x y is (a->b-c) or f y x is (a->b->c)?
11:16:02 <isaacbw> might be nice though to type [1, 2, 3] >>= <tab> and get all the functions that can map Nums
11:16:05 <isaacbw> to [Nums]
11:16:22 <isaacbw> nah, nevermind
11:16:28 <isaacbw> I'm seeing the overwhelming complexity now
11:16:39 <isaacbw> it would also have to list all the functions that may return functions that do that
11:16:39 <bennofs> isaacbw: actually, you'll get all functions of type Num a => a -> b
11:16:40 <isaacbw> and so on
11:16:57 <bennofs> right, and even that
11:17:10 <nomeata> Iceland_jack: maybe people are interested, but noone feels responsible. Don’t be to shy to nag and ask about the state of the tickets every once in a while, until you get a some response from someone with authority.
11:17:39 <isaacbw> does haskell let you put in a type and fill it in with options that match that type?
11:17:46 <Iceland_jack> nomeata: It was my first patch so I didn't want to rock the boat in case it was a bad idea :)
11:18:14 <isaacbw> so I could do [1, 2, 3] >>= <Num -> [Num]> <tab>
11:18:16 <isaacbw> or something like that
11:18:24 <nomeata> Iceland_jack: what’s there to lose? Worst can happen is that someone says “shut up, we don’t want the patch”; which at least is an answer :-)
11:18:35 <isaacbw> I read somewhere (long before I started playing with haskell) that you could leave holes in your program and ghc would help you fill them in
11:18:38 <Iceland_jack> nomeata: true :) I'll nag a bit later
11:19:13 <Iceland_jack> isaacbw: Agda lets you do something like that with editor support, GHC is in the process of getting support for type holes which effectively tell you the type of a ‘hole’ in your program
11:19:34 <Iceland_jack> To offer all possible solutions might get noisy since there are so many options
11:19:44 <jmcarthur> isaacbw: we are approaching the point where we can easily add such support to editors, but we aren't there yet
11:19:57 <Iceland_jack> for example you can always take a candidate ‘FOO’ and write ‘const FOO anything’
11:20:11 <Iceland_jack> also ‘id FOO’
11:20:36 <nomeata> Iceland_jack: reading through the patch I wonder if the PprParen should maybe be a parameter to UserStyle instead of a constructor of its own
11:20:40 <isaacbw> jmcarthur: really? What's missing?
11:21:00 <jmcarthur> isaacbw: holes are such a new feature of ghc that they aren't in a stable release yet
11:21:08 <isaacbw> oh, I see! You meant for holes
11:21:09 <jmcarthur> isaacbw: almost, though. just waiting for 7.8
11:21:10 <nomeata> And I’m surprised that in ghciCommands your command uses completeIdentifier – without knowing the code, I would have expected completeExpression
11:21:19 <isaacbw> not in general
11:21:21 <jmcarthur> isaacbw: then editor support might make some sense
11:21:30 <jmcarthur> isaacbw: "in general"?
11:21:41 <Iceland_jack> nomeata: yes that's a good remark, I'm not sure about the completeExpression thing: this was my first foray into GHC mind you :)
11:21:54 <isaacbw> jmcarthur: you don't mean editor support for haskell in general, like checking the type of an expression in your buffer, for example
11:22:07 <isaacbw> which seems simple enough if you have access to a ghci process
11:22:18 <jmcarthur> isaacbw: you can do that using holes:     <my expression> `asTypeOf` _
11:22:53 <jmcarthur> isaacbw: so presumably it wouldn't be hard to add editor support that just does that
11:23:09 <nomeata> Iceland_jack: and I’m not an expert either, just sharing some questions that you should be able to answer in case simon looks at your patch :-)
11:23:23 <jmcarthur> isaacbw: even now you can do something kind of similar using ImplicitParams, but it's a really ugly hack and not as powerful as holes
11:23:33 <Iceland_jack> nomeata: I'll look into that when I have time :) apparently GHC < thesis
11:23:40 <bitemyapp> jmcarthur: ImplicitParams is a terrible idea.
11:23:43 <jmcarthur> :t map (+1) `asTypeOf` ?foo
11:23:44 <lambdabot> (Num b, ?foo::[b] -> [b]) => [b] -> [b]
11:24:03 <jmcarthur> :t (map (+1) `asTypeOf` ?foo) [1..]
11:24:04 <lambdabot> (Enum b, Num b, ?foo::[b] -> [b]) => [b]
11:24:21 * Iceland_jack tries to avoid Num's in examples since they clutter the intent
11:24:30 <Iceland_jack> :t map not `asTypeOf`
11:24:30 <lambdabot>     parse error (possibly incorrect indentation or mismatched brackets)
11:24:33 <Iceland_jack> :t map not `asTypeOf` ?foo
11:24:34 <lambdabot> (?foo::[Bool] -> [Bool]) => [Bool] -> [Bool]
11:25:05 <isaacbw> anyone know if inf-haskell.el is still maintained, and if so, where it's hosted?
11:25:16 <bennofs> isaacbw: there is haskell-mode now
11:25:29 <bennofs> isaacbw: it provides two different inferior haskell modes
11:25:32 <isaacbw> oh
11:25:57 <bennofs> https://github.com/haskell/haskell-mode
11:26:52 <isaacbw> yea, I have that. Didn't realize it could interface with ghci
11:28:42 <Iceland_jack> isaacbw: How is LYAH going?
11:29:33 <Iceland_jack> Did you ask about typing the variable because of something you saw there?
11:29:33 <Iceland_jack> > (\(x :: Bool) -> not x) False
11:29:34 <lambdabot>  True
11:29:41 <isaacbw> Iceland_jack: I should probably spend more time with it, and less trying to make sense of Snap's types
11:29:47 <Iceland_jack> oh absolutely
11:30:24 <isaacbw> bennofs: so I tried haskell-inferior-mode and haskell-interactive-mode, the former of which seems nonfunctional and the latter is just a GCHi REPL in emacs
11:30:46 <bennofs> isaacbw: hmm, I though inf-haskell was GHCi mode for emacs?
11:31:08 <isaacbw> inf-haskell apparently runs ghci in the background and lets you send expressions from your buffer
11:31:11 <isaacbw> and check types, etc
11:31:19 <Iceland_jack> I would discourage you from trying to obtain a ‘Lisp’ experience for Haskell and take the ecosystem for that it is for now, Haskell is a language where you really need to grasp the foundations first
11:31:35 <isaacbw> which is neat, it shouldn't really be a major mode though
11:31:57 <isaacbw> Iceland_jack: the alternative is just sitting in GHCi typing :l a bunch though, right?
11:32:09 <isaacbw> would be nice to just have that repl in emacs and a command in my buffer to :l it into the repl
11:32:22 <Iceland_jack> isaacbw: well, that's basically what inf-mode does
11:35:04 <isaacbw> inferior-haskell-mode?
11:35:21 <Iceland_jack> inf-haskell I believe it's called
11:35:28 <beaky> haskell is a nice programming language
11:35:31 <Iceland_jack> from haskell-mode
11:36:04 <isaacbw> there's no inf-haskell with haskell-mode afaict. There's a script from 2011 called inf-haskell: http://code.haskell.org/haskellmode-emacs/inf-haskell.el
11:36:36 <Iceland_jack> I'm probably using some old version, the days of micromanaging my .emacs are gone
11:37:06 <Fuuzetsu> huh, didn't know there was haskell-cafe twitter, the utility seems… limited
11:38:02 <isaacbw> Iceland_jack: whatever haskell-mode has seems to be a regression from inf-haskell. Whatever, beck to LYAH!
11:38:07 <isaacbw> s/beck/back
11:51:36 <Firebox> flip' :: (a -> b -> c) -> b -> a -> c
11:51:36 <Firebox> flip' f = \x y -> f y x      <----- i don't know this mean i think it likely to 'flip' :: a -> b ->c'
11:52:13 <frontend1oader> This puts the currying into reverse gear
11:53:18 <triliyn> Firebox: the type declaration you gave is for flip', but the definition is for flip' f
11:53:29 <Taneb> How much do I want to go to ZuriHac
11:53:57 <triliyn> flip' f :: a -> b -> c, but f :: b -> a -> c (because y is passed first)
11:54:35 <Firebox> triliyn: thanks
11:54:57 <jmcarthur> :t \f -> curry $ uncurry f . swap
11:54:58 <lambdabot> (a -> b -> c) -> b -> a -> c
12:00:52 <matheus23> @where talp
12:00:52 <lambdabot> I know nothing about talp.
12:01:08 <matheus23> @where you
12:01:08 <lambdabot> I'm right here, silly.
12:01:25 <matheus23> @help
12:01:25 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
12:01:31 <matheus23> @list
12:01:31 <lambdabot> What module?  Try @listmodules for some ideas.
12:01:37 <matheus23> @listmodules
12:01:38 <lambdabot> activity base bf check compose dice dict djinn dummy elite eval filter free fresh haddock help hoogle instances irc karma localtime more oeis offlineRC pl pointful poll pretty quote search slap source spell system tell ticker todo topic type undo unlambda unmtl version where
12:01:56 <matheus23> @list unlambda
12:01:56 <lambdabot> unlambda provides: unlambda
12:02:02 <matheus23> @help ulambda
12:02:02 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
12:02:04 <matheus23> @help unlambda
12:02:04 <lambdabot> unlambda <expr>. Evaluate an unlambda expression
12:02:35 <Eduard_Munteanu> matheus23: it might be appropriate to talk with lambdabot privately for longer sessions
12:03:43 <matheus23> okay :D though a short question: In simon peyton jones' talk he refers to the funtionality of the lambdabot of being able to translate haskell expressions into 'variable free' code. Can the lambdabot still do this?
12:03:47 <matheus23> If yes, how? Eduard_Munteanu
12:04:15 <Eduard_Munteanu> @pl f x == f y
12:04:15 <lambdabot> f x == f y
12:04:25 <bennofs> @pl \f x y -> f x == f y
12:04:25 <Eduard_Munteanu> @pl \f x y -> f x == f y
12:04:25 <lambdabot> flip =<< (((.) . (==)) .)
12:04:25 <lambdabot> flip =<< (((.) . (==)) .)
12:04:29 <bennofs> :)
12:04:34 <Eduard_Munteanu> @pl \x y -> f x == f y
12:04:34 <lambdabot> (. f) . (==) . f
12:04:55 <bennofs> :o that's actually a pretty nice feature to "partially" pl
12:05:01 <dwat3r> hi guys, what is the fastest implementation of the famous quicksort in haskell?
12:05:13 <dwat3r> i mean fastest running
12:05:54 <Eduard_Munteanu> @pl \x -> f (g x)
12:05:54 <lambdabot> f . g
12:06:16 <bennofs> @pl \x -> f y $ g x
12:06:16 <lambdabot> f y . g
12:06:56 <Eduard_Munteanu> dwat3r: the "famous quicksort" isn't quite quick or even quicksort :)
12:07:55 <nisstyre> Eduard_Munteanu: I think he/she meant the version most people have in mind
12:08:27 <nawal> Hi guys
12:08:29 <dwat3r> i know that's not the in-place sorting quicksort
12:08:33 <Eduard_Munteanu> nisstyre: not sure what you mean
12:08:43 <matheus23> Eduard_Munteanu: nice! :D
12:09:12 <Eduard_Munteanu> nawal: hi
12:09:23 <nawal> I'm a haskell noob, and I have a lot of unlearning to do from C/Python.
12:09:42 <nawal> I was wondering if I could ask a quick question on how to structure the code please?
12:10:07 <Eduard_Munteanu> nawal: sure... no need to metaask first :)
12:10:20 <nawal> I want to write a simple game program, that uses the bullet physics library (as wrapped for Haskell), and OpenGL for displaying the result.
12:10:23 <nawal> For example, I have a floor, and a ball falls out of the sky onto the floor, over 10 seconds. (I can probably do that now, although I have not tried specifically.)
12:10:30 <nawal> I want to press a key on the keyboard, and a second ball appears, and falls out of the sky next to the original.
12:10:34 <nawal> In C/Python, I'd define a domain specific language by building a bunch of classes. Ball, would wrap around the bullet physics, and would have some code for displaying the ball on screen at each iteration.
12:10:41 <nawal> I'd have a World class, where I would do something like world.add(ball), when a key is pressed (e.g. GLUT callback).
12:10:42 <dwat3r> i think he meant the example which can be found in the books ( quicksort l@(x:xs) | l == [] = [] | quicksort (filter (<=x) xs) ++ [x] ++ quicksort (filter (>x) xs)
12:10:47 <nawal> I'm trying to think how I would do this in Haskell, and I have no idea where to start. I could start playing with the "mutable state" stuff, but doesn't that defeat the point of functional programming?
12:11:01 <Firebox> flip' :: (a -> b -> c) -> b -> a -> c
12:11:02 <Firebox> flip' f = \x y -> f y x     <--------- f == (a->b->c) , y == b, x == a  triliyn, right?
12:11:50 <benmachine> nawal: mutable state is sometimes necessary when dealing with stateful libraries
12:11:59 <triliyn> Well, it should be ::, not ==
12:12:02 <triliyn> But otherwise, yes
12:12:11 <benmachine> nawal: it doesn't completely defeat the point since it's still explicitly marked as what it is
12:12:11 <triliyn> You can also write it as "flip' f x y = f y x"
12:12:12 <nisstyre> Eduard_Munteanu: I mean the version that Tony Hoare came up with
12:12:19 <triliyn> Or "flip' = \f x y -> f y x"
12:12:25 <benmachine> nawal: it's easy to write parts of your code that do or do not depend on it
12:12:30 <nisstyre> implemented "faithfully" in Haskell
12:12:46 <cwvh> nawal: have you played around with Data.Map yet? I think that would help you structure your 'world.add(ball)'-like logic.
12:12:48 <nawal> <benmachine>: yeah, basically the opengl tuts I have looked at, use displayCallback $= display to set a callback
12:13:25 <benmachine> nawal: Haskell is an excellent language for imperative programming, too
12:13:44 <benmachine> nawal: it's best when you can avoid using it like that, but it's better to use it imperatively than not at all :)
12:14:07 <nawal> cwvh, yeah a little bit. Do I pass the latest version of this map around?
12:14:35 <benmachine> nawal: you can do
12:14:41 <nawal> benmachine, yeah I'm trying to figure out which bits must be absolutely imperative (e.g. the opengl), and how I can move the other bits into pure functions
12:14:53 <dwat3r> so, my quicksort orders this beast : [10000,9999..1] in 7 secs. how can i make it faster?
12:15:12 <thebnq> reverse
12:15:16 <thebnq> xD
12:15:36 <cwvh> nawal: Yes, you can think of it that way. Don't be afraid to have long function argument lists when first getting started in Haskell.
12:16:01 <cwvh> nawal: as you keep working in the language you'll learn of fancier ways to "pass" things around with less bookkeeping.
12:17:03 <benmachine> you can also package up arguments in records
12:17:09 <nawal> cwvh, ok, I can try that - is there anything in particular I should look out for, that will help with this bookkeeping? (any keywords to help my eyes jump to them in tutorials/docs/books would be helpful :-)
12:17:41 <nawal> benmachine, thanks I think I know how to do that
12:17:45 <cwvh> nawal: benmachine just dropped one, the next would be monad transformers
12:18:11 <Eduard_Munteanu> dwat3r: you'll have to show the code first
12:18:24 <cwvh> I think when the proper motivation is in place the more advanced concepts naturally fall out, so don't feel compelled to bang your head against a monad tutorial if you can get started with record passing for now. At least, that's my opinion.
12:18:43 <nawal> oh god monads. I've read a number of articles on them, and have decided that for now, I'll understand "monads let you use the do notation to do imperative programming when you really need to"
12:19:00 <nawal> cwvh, okay, will do that :-)
12:19:02 <nawal> thanks guys!
12:20:10 <stolaruk> When writing a QC property to test a function that takes polymorphic types, should I expect that my QC property function will not/cannot itself be polymorphic?
12:20:38 <bennofs> stolaruk: you have to monomorphize your function (choose a type) in order to test it, yes
12:21:44 <benmachine> it's probably OK to have fully-polymoprhic stuff, but type-class polymorphic stuff you need to choose
12:21:52 <benmachine> I say probably, I haven't checked
12:21:57 <stolaruk> bennofs: Right, so to cite a specific example, the function I want to type is "(Eq a) => [a] -> [a] -> [a]", and I made my property function type "[a] -> [a] -> Property"... is this to be expected?
12:22:11 <stolaruk> woops
12:22:13 <stolaruk> sorry no
12:22:28 <stolaruk> the property is of type "[Int] -> [Int] -> Property "
12:22:38 <benmachine> that's expected
12:22:42 <stolaruk> ok cool
12:22:46 <benmachine> you have to say which == you want to test with
12:22:57 <stolaruk> ok
12:22:58 <benmachine> if it guessed that would be bad
12:23:02 <bennofs> stolaruk: yes. You can write multiple properties if you want to test multiple types
12:23:37 * hackagebot email-validator 0.0.3 - Perform basic syntax and deliverability checks on email addresses.  http://hackage.haskell.org/package/email-validator-0.0.3 (MichaelOrlitzky)
12:23:44 <stolaruk> Thanks guys, this channel is always such a tremendous help
12:29:49 <jmcarthur> i always define my properties polymorphically and just monomorphize them when i run them
12:30:15 <mmmm> Are there benchmarks of String vs Data.Text anywhere?
12:31:12 <jmcarthur> mmmm: for most uses (when used like strings are typically used and not like lists are typically used) Text is going to destroy String. i doubt this is an interesting enough result for people to write extensive benchmarks.
12:32:22 <mmmm> what sort of destruction are we talking about here? 5x? 10x?
12:34:12 <Eduard_Munteanu> Is there a (simple) Good-Turing estimator implemented in Haskell?
12:36:21 <dwat3r> okay Eduard_Munteanu, here it is: http://pastebin.com/e144ycgp
12:38:39 * hackagebot chatty 0.3.1.4 - Some monad transformers and typeclasses to simplify I/O on a transformer stack.  http://hackage.haskell.org/package/chatty-0.3.1.4 (implementation)
12:38:41 * hackagebot antisplice 0.11.0.3 - An engine for text-based dungeons.  http://hackage.haskell.org/package/antisplice-0.11.0.3 (implementation)
12:38:43 * hackagebot ironforge 0.1.0.8 - A technical demo for Antisplice.  http://hackage.haskell.org/package/ironforge-0.1.0.8 (implementation)
12:56:42 <SrPx> How can I make a type that uses itself? data Foo = Aaa Int | Bbb (Aaa Int) Foo | Ccc Foo Foo
12:57:41 <pavonia> You can't use a data constructor like that in the definition
12:57:51 <geekosaur> you can't use just one constructor, only the whole type
12:58:25 <SrPx> Using data Foo = Aaa Int | Bbb Foo Foo | Ccc Foo Foo works, but I don't want (Bbb (Ccc ...) ...) to be valid...
12:58:48 <geekosaur> you can't do it that way
12:58:54 <SrPx> yes, but what way?
12:58:58 <geekosaur> Aaa is not a type, neither is Bbb
12:59:12 <geekosaur> you have to declare them as separate types and then wrap them
12:59:40 <pavonia> "data Foo = FooAaa Aaa | Bbb Aaa Foo | Ccc Foo Foo; data Aaa = Aaa Int" would work
13:01:58 <bennofs> Is there a way to load a .o file in GHCi from a .ghci file?
13:02:44 <SrPx> Paoh ok I tried that but I got it wrong
13:03:20 <augur_> or!
13:03:24 <augur_> you could use GADTs!
13:03:42 <augur_> data Tags = ATag | BTag | CTag
13:03:52 * hackagebot clash-lib 0.2.2 - CAES Language for Synchronous Hardware - As a Library  http://hackage.haskell.org/package/clash-lib-0.2.2 (ChristiaanBaaij)
13:04:30 <SrPx> Oh wait, that wouldn't work.. this would make (Ccc (Aaa 5) (Aaa 6)) invalid
13:04:36 <augur_> data Foo t :: * where { Aaa :: Int -> Foo ATag ; Bbb :: Foo ATag -> Foo t -> Foo BTag ; Ccc :: Foo t -> Foo t' -> Foo CTag }
13:04:49 <augur_> but thats silly
13:04:49 <bitemyapp> ReinH: a haskellcast about Yesod with Snoyman would be pretty cool.
13:04:53 <augur_> SrPx: what do you want to do this for
13:05:24 <pavonia> SrPx: Btw, as Aaa only holds an Int, why not use Bbb Int Foo?
13:05:41 <b0bbi10> hi, 'map func [a, b, c]' is translated to '[func a, func b, func c]'. what would 'map ($ func) [a, b, c]' translated into?
13:06:02 <SrPx> augur_: ah just an example but I'm trying to create a lambda calculator for an exercise, so it was like: data Term = Var Int | Lam (Var Int) Term | App Term Term...
13:06:16 <augur_> SrPx: ahh i see what you're doing
13:06:17 <pavonia> b0bbi10: "$ func" is equivalent to "\x -> x $ func"
13:06:24 <Vendethiel-> b0bbi10: I'd say `[a func, b func, c func]`
13:06:37 <augur_> SrPx: no, we dont do that. usually you would just do   data Term = Var Int | Lam Int Term | App Term Term
13:07:00 <b0bbi10> pavonia, Vendethiel-: thanks
13:07:15 <SrPx> augur_: hmm ok seems good to me
13:07:16 <SrPx> thanks
13:07:19 <augur_> SrPx: there's no reason to want a "var" tag there anyway. the Var constructor is supposed to inject from variable names into lambda terms
13:07:51 <SrPx> pardon?
13:07:52 <augur_> SrPx: similarly, the lambda constructor mentions variable names
13:08:26 <augur_> SrPx: the Var constructor turns a variable name into a variable term
13:08:52 * hackagebot clash-ghc 0.2.2 - CAES Language for Synchronous Hardware  http://hackage.haskell.org/package/clash-ghc-0.2.2 (ChristiaanBaaij)
13:09:15 <SrPx> hmm
13:09:23 <augur_> SrPx: using GADTs actually makes it clearer whats going on, sort of. but dependent types can make it clearer still.
13:10:42 <Eduard_Munteanu> Is there a package providing smoothing methods for n-gram models, say Katz backoff? (/me pretends he hasn't seen augur_ :D)
13:10:46 <dwat3r> Eduard_Munteanu, i pasted the code
13:11:06 <augur_> Eduard_Munteanu: i wouldnt know, cause thats not linguistics. :)
13:11:34 <Eduard_Munteanu> Aww. :D
13:11:53 <dwat3r> is there a list data structure that performs head : O(1), tail O(1), and also list appending, and can be force evaluated O(n) ?
13:12:15 <Eduard_Munteanu> dwat3r: yeah, I looked at it earlier, but I was a bit busy... the issue is the algorithm itself, it's a pretty bad one.
13:13:09 <Eduard_Munteanu> dwat3r: Data.Sequence's Seq.
13:13:12 <startling> dwat3r: finger trees?
13:13:15 <startling> yeah, Seq.
13:13:37 <dwat3r> i see,i read about it,so it's look like i have to just leave it. It was actually a homework, to parallelize quicksort with the Par monad. and sorry for poking you.
13:13:44 <SrPx> augur_: ook but this is actually an exercise from a book to get there so not for now (:
13:13:49 <dwat3r> oh,i'll look into those,thanks :)
13:15:25 <augur_> SrPx: the key thing to keep in mind anyway is that `Var n` is supposed to tell you "this is a variable, and its identifier is n"
13:15:43 <augur_> SrPx: so something like lambda abstraction just needs to know the identifier that it's associated with
13:16:04 <augur_> `Lam n b` is "abstract the variable identified by n in b"
13:16:15 <Eduard_Munteanu> augur_: btw, how would you classify this thing, if not under linguistics? It does seem a CS thing but that's too general.
13:16:31 <augur_> Eduard_Munteanu: NLP
13:16:38 <SrPx> augur_: uh huh, that makes sense (:
13:16:48 <Eduard_Munteanu> augur_: I mean, how do you call an NLP-ist? :)
13:17:10 <augur_> i just NLPer, but i dont think they have a special name. its a branch of software engineering.
13:17:28 <Eduard_Munteanu> Ah, alright. Thanks.
13:17:37 <SrPx> this might be a really silly/small detail but GHC should suggest "/=" when you try "!=", instead of suggesting "==", ">=" and "<="
13:17:58 <augur_> yes, that seems like a good idea
13:19:24 <SrPx> I should remember that when I embrace my quest to explore GHC's source code (:
13:19:44 <augur_> why are you upside down
13:20:30 <SrPx> wat
13:20:43 <SrPx> oh, lol. well, anyway... another question, can I?
13:20:55 <Firebox> maximum' :: (Ord a) => [a] -> a
13:20:56 <Firebox> maximum' = foldr1 (\x acc -> if x > acc then x else acc)   <----- maximum' [1,2,3] will be 6 because of acc is 1+2+3 but response is 3?
13:21:21 <augur_> SrPx: no, we have a one question maximum before we start charging fees. initial price is 10trillion dogecoin
13:21:26 <Eduard_Munteanu> Firebox: there's no addition in there
13:21:35 <SrPx> Does everything in Haskell actually become that -> https://ghc.haskell.org/trac/ghc/wiki/Commentary/Compiler/CoreSynType ...? Everything, everything? From the prelude to repa to the sockets.io package I just downloaded? Makes no sense
13:21:58 <augur_> yes, SrPx
13:22:02 <startling> SrPx: how doesn't that make sense?
13:22:14 <Eduard_Munteanu> > foldr1 (\x acc -> if x > acc then x else acc) [a, b, c]
13:22:14 <lambdabot>  c
13:22:22 <SrPx> augur_: I have 100 dogecoins and a gif of a man answering the iron by accident
13:22:30 <augur_> SrPx: deal
13:23:01 <Eduard_Munteanu> > foldr1 (\x acc -> if x >= acc then x else acc) [a, b, c]
13:23:02 <lambdabot>  c
13:24:06 <augur_> SrPx: as startling said, why is this hard to believe?
13:24:09 <Firebox> Eduard_Munteanu: oh i see thanks.  and then acc first element and x is just second element?
13:25:06 <SrPx> augur_ haha that was easy, well I actually don't because I didn't accept those reddit tips :/ but I have the video and the equivalent in btc. pmed you
13:25:25 <Eduard_Munteanu> :t foldr1
13:25:26 <lambdabot> (a -> a -> a) -> [a] -> a
13:25:35 <Eduard_Munteanu> :t foldr
13:25:35 <lambdabot> (a -> b -> b) -> b -> [a] -> b
13:25:42 <SrPx> augur_: I don't know, how Core deals with IO, sockets etc
13:26:08 <Eduard_Munteanu> Firebox: acc is the accumulator and x is the current element you're looking at
13:26:11 <augur_> SrPx: IO is just another data type
13:26:15 <geekosaur> SrPx: why would it?
13:26:20 <augur_> its just one that the compiler knows how to handle
13:26:25 <Eduard_Munteanu> > foldr1 (+) [a, b, c]
13:26:26 <lambdabot>  a + (b + c)
13:26:40 <SrPx> ...? I don't understand but nevermind (:
13:27:03 <Firebox> Eduard_Munteanu:  accumulator is auto increased by current element?
13:27:36 <geekosaur> a language that hardcodes I/O into itself like that is kinda bad, because you can't change how I/O works without redesigning the language. (see PL/I for the classic example of hardwired stuff that belongs in libraries)
13:27:38 <augur_> SrPx: essentially you could view IO something like this type:    data IO a where   PutStr :: String -> IO ()   ;   GetStr :: IO String   ;   Return :: a -> IO a   ;   Bind :: IO a -> (a -> IO b) -> IO b
13:27:56 <Eduard_Munteanu> Firebox: there, foldr1 starts with acc = a, and looks at b, then at c
13:27:57 <augur_> thats a minimalist version with just string IO
13:28:13 <Platz> bouncy folds are mind boggling.  Thought I understood foldr but I was wrong
13:28:33 <Eduard_Munteanu> Er.
13:28:42 <augur_> SrPx: then all your IO programs are secretly just elements of that type, and the executor interprets them
13:28:59 * hackagebot GLMatrix 0.1.0.0 - Utilities for working with OpenGL matrices  http://hackage.haskell.org/package/GLMatrix-0.1.0.0 (fiendfan1)
13:29:05 <geekosaur> note that the executor is in the runtime, not the compiler
13:29:09 <Eduard_Munteanu> Firebox: sorry, it's not quite an accumulator, that'd be more foldl1-like.
13:29:09 <augur_> right
13:29:19 <augur_> the executor is "outside" haskell
13:29:20 <Firebox> Eduard_Munteanu then  accumulator is save previous thing?
13:29:52 <Eduard_Munteanu> @src foldr1
13:29:52 <lambdabot> foldr1 _ [x]    = x
13:29:52 <lambdabot> foldr1 f (x:xs) = f x (foldr1 f xs)
13:29:52 <lambdabot> foldr1 _ []     = undefined
13:30:13 <Eduard_Munteanu> Firebox: the acc would be the rest of the computation
13:30:37 <augur_> essentially, SrPx, there is always some level of your programming language which has to be primitive. usually this is IO-related stuff.
13:30:39 <Eduard_Munteanu> Firebox: let's consider foldl first...
13:30:55 <Firebox> i think acc save previous computation. and x is current element.
13:31:07 <SrPx> augur_: and the compiler knows it is IO because there is a Type type on core. I thought that information was lost. OK I guess I get it. I still don't get how sockets.io would get implemented, though, but okay
13:31:25 <geekosaur> libraries
13:31:27 <Firebox> thanks Eduard_Munteanu
13:31:28 <Eduard_Munteanu> Firebox: there isn't a previous computation in right folds like in left folds
13:31:33 <Eduard_Munteanu> > foldl (+) z [a,b,c]
13:31:33 <geekosaur> it's not like it needs specific *language* support
13:31:34 <lambdabot>  z + a + b + c
13:31:43 <augur_> SrPx: im not entirely sure what you mean by that
13:31:53 <Firebox> Eduard_Munteanu: ok thanks
13:32:02 <geekosaur> I don't even think it has runtime support beyond the normal I/O support, it just goes through IO to invoke standard system library operations
13:32:03 <Eduard_Munteanu> > scanl (\acc x -> acc + x) z [a,b,c]   -- this gives you all foldls
13:32:04 <lambdabot>  [z,z + a,z + a + b,z + a + b + c]
13:32:38 <zlatan> just discovered <$> and <*> and I now how LSD moments :D
13:32:42 <Eduard_Munteanu> > scanr (\x acc -> x + acc) z [a,b,c]   -- this gives you all foldrs
13:32:43 <lambdabot>  [a + (b + (c + z)),b + (c + z),c + z,z]
13:33:10 <Eduard_Munteanu> @src foldl
13:33:11 <lambdabot> foldl f z []     = z
13:33:11 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
13:33:13 <geekosaur> SrPx: the thing to remember here is that a compiler does not execute anything, it just generates something that can be executed by something else
13:33:31 <SrPx> augur_: ah nevermind I was just wondering how that would do IO as it was pretty much system F. I knew IO could be easily encoded on it, obviously, but how would it differ what terms are IO and what are not? Then I just noticed the type information is preserved so that is how. Just me being stupid, nevermind.
13:33:43 <Eduard_Munteanu> Firebox: as you can see above, foldl applies the function and passes it on to the next iteration, but there's no such thing in foldr's case.
13:34:25 <Firebox> thanks you are kind.
13:34:26 <augur_> SrPx: i still dont quite know what you mean. the type checker enforces type safety. once you know it type checks, you can discard the type info (at least here)
13:34:28 <Firebox> Eduard_Munteanu:
13:34:33 <geekosaur> it's all about the types, of course they are preserved :) they may look rather different from what you expect inside the compiler, though
13:34:42 <augur_> SrPx: you dont need to know the type to run the program, since the type no longer affects execution
13:35:11 <SrPx> augur_: ... so the core doesn't have access to the type information? Then how it knows that a term (say, a lambda abstraction in pure system F) is meant to do IO, not something else?
13:35:40 <geekosaur> it doesn't; the upper level knows that and has ensured that the right thing will happen
13:35:48 <geekosaur> the type checker, in this case
13:35:59 <augur_> SrPx: like i said, the type checker checks to make sure it all works out. and once you've checked, you can ignore the types
13:36:27 <augur_> SrPx: there's no way to get a type error from the raw, untyped terms, once you've type checked.
13:37:20 <SrPx> No that's not the point,  pretty much don't get how the compiler from Core -> C-- knows what is supposed to be converted into a printf, for example. But nevermind that for now, seriously, this is a topic for me to get later on
13:37:25 <geekosaur> it doesn't
13:37:27 <Eduard_Munteanu> Firebox: just ask more questions if you need to, so I don't bother you too much :)
13:37:44 <geekosaur> what a function *does* is not the compielr's problem. it just knows it has a function
13:37:45 <Firebox> ok thanks Eduard_Munteanu
13:37:51 <augur_> SrPx: i dont know what that means
13:38:48 <SrPx> Look I'll just read the core for `main = putStrLn "hi"` later on and that will answer my question, seriously no worries mate (: I have to finish that exercise now
13:40:08 <augur_> void execute(Cmd c) { if (c->tag == putStrLn) { printf(c->strContent); }
13:40:30 <dwat3r> :t >fromList $ Prelude.take 10000 $ randoms (mkStdGen 10) :: [Int]
13:40:31 <lambdabot> parse error on input `>'
13:41:17 <dwat3r> sorry,i thought lambdabot works just like ghci. i cant figure out what is wrong with this type. the fromList is from Data.Sequence
13:41:39 <bennofs> :t randoms
13:41:39 <lambdabot> (RandomGen g, Random a) => g -> [a]
13:42:03 <bennofs> dwat3r: the :: [Int] applies to the whole expression
13:42:08 <augur_> SrPx: ^
13:42:12 <bennofs> dwat3r: the whole expression is of type Sequence Int though
13:42:32 <bennofs> dwat3r: s/Sequence/Seq
13:43:33 <dwat3r> :t fromList $ Prelude.take 10000 $ randoms (mkStdGen 10) :: [Int]
13:43:34 <lambdabot>     Not in scope: `fromList'
13:43:34 <lambdabot>     Perhaps you meant one of these:
13:43:34 <lambdabot>       `IM.fromList' (imported from Data.IntMap),
13:43:38 <h_nooob> I'm trying to make a .cabal file that links a static C library into my project.
13:43:39 <h_nooob> so, this commandline works:
13:43:39 <h_nooob> ghc --make -o kt keyosc.hs libmahtest.a
13:43:52 <bennofs> :t Data.Sequence.fromList
13:43:53 <lambdabot> [a] -> Seq.Seq a
13:44:06 <bennofs> :t Data.Sequence.fromList $  Prelude.take 10000 $ randoms (mkStdGen 10) :: [Int]
13:44:07 <lambdabot>     Couldn't match expected type `[Int]' with actual type `Seq.Seq a0'
13:44:07 <lambdabot>     In the expression:
13:44:07 <lambdabot>         Seq.fromList $ take 10000 $ randoms (mkStdGen 10) :: [Int]
13:44:11 <bennofs> :t Data.Sequence.fromList $  Prelude.take 10000 $ randoms (mkStdGen 10) :: Seq Int
13:44:12 <lambdabot>     Not in scope: type constructor or class `Seq'
13:44:12 <lambdabot>     Perhaps you meant one of these:
13:44:12 <lambdabot>       `Seq.Seq' (imported from Data.Sequence),
13:44:16 <bennofs> :t Data.Sequence.fromList $  Prelude.take 10000 $ randoms (mkStdGen 10) :: Seq.Seq Int
13:44:16 <lambdabot> Seq.Seq Int
13:44:50 <bennofs> dwat3r: See? The :: refers to the (Seq.fromList $ Prelude.take 10000 $ randoms (mkStdGen 10))
13:45:00 <h_nooob> but I can't figure out how to configure myproj.cabal so that it links in the libmahtest.a
13:45:29 <dwat3r> i see,thanks
13:45:33 <augur_> Eduard_Munteanu: its kind of accumulator like
13:46:39 <geekosaur> h_nooob, probably extra-libraries (possibly with extra-lib-dirs)
13:46:49 <augur_> at least in that you can view it sort of in a loopy way:   foldr f z xs   is kind of like   acc = z; for (i = 0; i <= xs.length; i++) { acc = f(acc,xs[i]); }
13:46:58 <jle`> do i have to worry while using swapMVar ?
13:47:09 <augur_> oh wait, thats actually foldl, do that in reverse :)
13:47:21 <jle`> about deadlocks and race conditions and stuff like that
13:47:31 <augur_> there, you see, its so accumulator like, i accidentally reversed the traversal and got foldl
13:47:32 <augur_> doh.
13:47:58 <Eduard_Munteanu> I suppose you could say in foldr the accumulator is the result itself.
13:48:01 <acomar> man this is weird... linker issue with undefined symbols that are most definitely defined in one of the archives that's showing up on the linker command line when looking at it with "cabal build -v3"
13:48:15 <acomar> verified that they're present with nm :/
13:48:47 <irene-knapp> acomar: you forgot to list the modules they originate from in the other-modules: field
13:48:52 <augur_> Eduard_Munteanu: it is. list recursion _just is_ loops with accumulators
13:48:56 <Eduard_Munteanu> :t (foldl, foldr)
13:48:57 * irene-knapp returns to #haskell :)
13:48:57 <lambdabot> ((a -> b -> a) -> a -> [b] -> a, (a1 -> b1 -> b1) -> b1 -> [a1] -> b1)
13:48:58 <geekosaur> beware of ordering
13:49:04 <h_nooob> thx geekosaur - I've tried extra-libraries with "mahtest", "libmahtest.a", "libmahtest", etc, but no luck.
13:49:10 <acomar> irene-knapp: they're from an external C library :/
13:49:26 <irene-knapp> oh, did you list them in the appropriate field which I remember the name of?  might be extra-libs: ?
13:49:30 <geekosaur> it may need to be -lmahtest and `extra-lib-dirs: .` or something
13:49:30 <irene-knapp> *don't remember the name of
13:49:55 <acomar> irene-knapp: using pkgconfig-depends right now, and I verified that the specific archive I need is showing up on the linker command line
13:49:58 <irene-knapp> there is actually a field to tell it about the libraries - you shouldn't be using the -l linker option directly
13:50:14 <irene-knapp> Cabal does more than one compilation pass, to verify things aren't broken in more-subtle ways
13:50:18 <acomar> yea, I tried it with -l directly as well just to see if I could trick it into working :/
13:50:22 <geekosaur> acomar: beware of link ordering. if a name is referred to in a later library, ld will not go back to an earlier one to find it (but if it's a shared library, it may be found anyway because you get the whole thing no matter what)
13:50:32 <tdammers> \o/ irene-knapp
13:50:35 <geekosaur> static libs, it takes only what it knows it needs at the point it encounteres it
13:50:38 <irene-knapp> and the options field is not necessarily used in all of those passes
13:50:40 <geekosaur> *encounters
13:50:44 <irene-knapp> tdammers: ^_^
13:51:09 * tdammers is annoyed at the fact that ScopedTypeVariables is an extension
13:51:11 <acomar> geekosaur: I've tried compiling the C library as both static and dynamic already -- I actually went to try static to see if that'd fix the issue
13:51:33 <acomar> geekosaur: and I tried running the linker command manually (after telling ghc not to kill its temp files)
13:51:34 <Eduard_Munteanu> :t \op z xs -> ?f (foldr op z xs)
13:51:34 <lambdabot> (?f::b -> t) => (a -> b -> b) -> b -> [a] -> t
13:51:47 <Eduard_Munteanu> :t \op z xs -> ?f (foldl op z xs)
13:51:48 <lambdabot> (?f::a -> t) => (a -> b -> a) -> a -> [b] -> t
13:51:50 <irene-knapp> ah, the appropriate field is extra-libraries:
13:51:53 <acomar> geekosaur: so I specified the necessary archive at the very end of the command, and at the very beginning
13:52:01 <tdammers> also, I have somehow modularized my project to the point that about half of it is imports
13:52:29 <acomar> irene-knapp: yep, I'm just using pkgconfig-depends because it's a little more correct in this case. I've tried listing just the libraries I need via extra-libraries as well.
13:52:32 <irene-knapp> or if it's a pkg-config library, you can use pkgconfig-depends:
13:52:33 <irene-knapp> right okay
13:52:45 <jmcarthur> jle`: swapMVar is only atomic if the stable state of the MVar is to be full and all other threads only ever access it by taking and then putting, never just putting without taking first.
13:52:58 <irene-knapp> well, why don't you hpaste both your .cabal file and your transcript of build output failing at some appropriate verbosity level?
13:53:19 <acomar> irene-knapp: sure, one sec
13:53:20 <jmcarthur> jle`: well, the first condition is necessary for your program not to deadlock. the second is necessary for swapMVar to be atomic
13:53:21 <Eduard_Munteanu> tdammers: I suspect merging it with ExplicitForall and Rank{2,N}Types can be argued for
13:53:23 <irene-knapp> http://lpaste.net seems to be where we keep the paste bot nowadays
13:53:50 <tdammers> Eduard_Munteanu: well, I don't see what harm could come from it
13:54:03 * hackagebot GLMatrix 0.1.0.1 - Utilities for working with OpenGL matrices  http://hackage.haskell.org/package/GLMatrix-0.1.0.1 (fiendfan1)
13:54:04 <jle`> jmcarthur: thanks
13:54:15 <Eduard_Munteanu> It would break existing code, though.
13:54:43 <jmcarthur> jle`: if you want to not be so concerned with such matters, you should look at STM (or try to avoid shared memory concurrency, I suppose)
13:54:45 <acomar> irene-knapp: here's the cabal file: http://lpaste.net/101246 -- it's the Test executable that fails to link
13:54:50 * irene-knapp nods
13:55:07 <jle`> jmcarthur: i'm writing something fairly low-level so stm might be a bit overkill, i'm doing pretty simple operators
13:55:09 <jle`> but thanks
13:55:12 <jle`> :)
13:55:23 <jmcarthur> jle`: interestingly, you can also get atomic swapping if you use IORef instead of MVar
13:55:33 <acomar> irene-knapp: the symbols I want are in libopencv_c.so which is available on the LD_LIBRARY_PATH
13:55:39 <jmcarthur> jle`: i would not reject STM just because you are doing something "low level"
13:55:51 <irene-knapp> hmm, can you give me the output of pkg-config opencv --libs ?
13:55:58 <jmcarthur> jle`: but back on the IORef suggestion... with IORef, you can use atomicModifyIORef
13:56:20 <jmcarthur> jle`: if you never need to actually block, IORef may be all you need
13:56:40 <jle`> jmcarthur: hm. and IORefs can normally be used in concurrent settings too?
13:56:48 <jle`> MVars are only for blocking and things?
13:56:55 <jmcarthur> jle`: you should make sure to use only atomic operations on them for concurrent settings, but yet
13:56:56 <jmcarthur> *yes
13:57:13 <jle`> i'm hesitant to use STM because I'm writing an ffi wrapper in ghcjs
13:57:17 <jmcarthur> jle`: MVars are like channels with maximum size 1
13:57:26 <jmcarthur> jle`: doesn't ghcjs support STM?
13:57:29 <jle`> it does
13:57:32 <jle`> but
13:57:32 <acomar> irene-knapp: and here's the build error at low verbosity (high verbosity doesn't seem to change the error output at all, and I can replicate the error manually by running the linker command)
13:57:36 <acomar> http://lpaste.net/101247
13:57:38 <irene-knapp> okay, excellent
13:57:38 <jle`> just wanted to stay safe
13:57:58 <jmcarthur> not sure what you mean by "safe" here. STM should be pretty safe in most ways I can think of
13:58:39 <acomar> irene-knapp: it almost doesn't matter what the pkgconfig output is, I can specify the archive by hand on the linker command line and it fails with the exact same error output
13:58:51 <irene-knapp> okay.  what linker command line are you using?
13:58:57 <acomar> it's massive
13:59:06 * hackagebot language-ecmascript 0.16 - JavaScript parser and pretty-printer library  http://hackage.haskell.org/package/language-ecmascript-0.16 (AndreyChudnov)
13:59:14 <irene-knapp> well, lpaste that too :)
13:59:15 <acomar> ran cabal build -v3, and copied the linker command that's failing
13:59:17 <geekosaur> now I'm tempted to wonder if it found the wrong kind of library (32 vs 64 bit)
13:59:18 * irene-knapp nods
13:59:43 <jle`> jmcarthur: is there much of an overhead?
13:59:47 <jle`> wanted to keep the 'binary' size down
14:00:03 <acomar> http://lpaste.net/101248
14:00:05 <jmcarthur> jle`: the generated javascript probably already has all the STM runtime code anyway
14:00:09 <jmcarthur> jle`: even if you don't use it
14:00:13 <acomar> wow, lpaste put that all on one line o.O
14:00:14 <jle`> but actually i realized that all i ever do is read and modify and put, so i don't think i need blocking things
14:00:17 <jle`> but
14:00:23 <jle`> if i ever do, then i'll probably consider STM instead
14:00:27 <irene-knapp> oh >< so it did heh
14:00:29 <jle`> thanks
14:00:31 <jmcarthur> np
14:00:31 <irene-knapp> well, I can see what I need to
14:00:55 <acomar> irene-knapp: I think this is with the static archive rather than the dynamic one, but the results are the same
14:01:03 * irene-knapp nods
14:01:05 <acomar> I'm going to swap back to the static archive
14:01:08 <acomar> *dynamic
14:01:28 <irene-knapp> I find this a very odd command line - the library is actually installed, right?
14:01:30 <irene-knapp> it should be using -l
14:01:35 <irene-knapp> not listing the .so files individually
14:01:41 <irene-knapp> right?
14:01:53 <acomar> irene-knapp: it's because of how the pkgconfig file is written for opencv
14:01:56 <irene-knapp> ahh
14:01:59 <irene-knapp> that may be relevant
14:02:01 <acomar> it specifies the libraries out archive by archive
14:02:31 <irene-knapp> one sec, let me dig up that file
14:03:48 <irene-knapp> wow, so it does.  huh.
14:04:17 <acomar> yep
14:04:17 <SrPx> Holy shit I actually managed to implement that beta reducer and it worked in the first run. Not a bad first impression. Wow. Maybe Haskell is actually as good as you guys make it...
14:04:21 <jmcarthur> jle`: be sure to pay attention to the memory model documentation on Data.IORef. it's mainly talking about x86, but probably it's worth thinking about what the ghcjs memory model might be. IORef doesn't specify much except that if you write and then read *in the same thread* then they should take place in the order you did them in
14:04:23 <acomar> the -l syntax isn't all that special
14:04:25 <irene-knapp> but it doesn't genuinely spew all those .so files into /usr/lib, does it?  they're actually within a .a?
14:04:41 <irene-knapp> it's not all that special, but I suspect that Cabal understands it whereas it doesn't necessarily understand this notation
14:04:43 <acomar> depends on how/where you install it, but yes, it does
14:04:46 <irene-knapp> not totally sure of that
14:04:47 <irene-knapp> hmmm okay
14:05:00 <jmcarthur> jle`: i apologize if i just made things more murky instead of less
14:05:03 <acomar> I think most distros put it under /usr/local/lib for that reason
14:05:06 <geekosaur> what?
14:05:07 <jmcarthur> jle`: this is yet another reason STM is pretty awesome...
14:05:09 <geekosaur> .so does not go in .a
14:05:14 <jle`> jmcarthur: no worries :)
14:05:15 <irene-knapp> I see I see
14:05:19 <geekosaur> you're thinking .o
14:05:52 <augur_> SrPx: reveal to use your code!
14:06:00 <irene-knapp> geekosaur: true, okay
14:06:41 <jle`> all i ever do is read, put, and modify
14:06:57 <acomar> I really hope I'm just missing something stupid and obvious
14:07:08 <irene-knapp> I doubt it's obvious.  It may be stupid :)
14:07:18 <acomar> hah
14:07:30 <Firebox> i think . and $ is similar?
14:07:56 <Yaniel> only slightly
14:08:16 <acomar> Firebox: (.) is function composition and ($) is function application -- they're similar where composition looks like application
14:08:30 <irene-knapp> acomar: I'm googling a bit to refresh my memory on a few things related to this
14:08:33 <jmcarthur> jle`: yes, but (under the x86 memory model at least) if you read ref1 then write ref2 in thread1 and read ref2 then write ref1 in thread 2, thread1 and thread2 might *both* see each others' writes. that can be very tricky to think about.
14:08:35 <Firebox> acomar: thanks/
14:08:43 <acomar> irene-knapp: let me know if you find anything interesting
14:08:46 <irene-knapp> absolutely
14:08:48 <Firebox> Yaniel:  you too.
14:09:12 <SrPx> augur_: really? It is probably horrible, it is my first thing. But it shouldn't have bugs, right? If it does you guys lied to me and I'm automatically mad with you. (I only tested one case)
14:09:17 <SrPx> augur_: http://lpaste.net/101249
14:09:56 <jmcarthur> i wonder if it would be possible to design IORef's interface to better reflect this possibility without any sacrifice in power and without making it (much?) less convenient to use
14:10:18 <augur_> SrPx: congratulations, you've captured variables :)
14:10:20 <jmcarthur> or maybe this would be a thread interface thing
14:10:36 <jle`> jmcarthur: i noticed that the IORef api offers 'atomically-' variants
14:10:49 <SrPx> augur_: I told you lol. I might have used bruijn indices but I was lazy
14:10:59 <jmcarthur> jle`: yes, this is what i said earlier :)
14:10:59 <SrPx> augur_: so you are admiting you lied to me
14:11:10 <jle`> ah, sorry
14:11:11 <jle`> :)
14:11:14 <jmcarthur> jle`: they have stronger memory guarantees
14:11:16 <augur_> SrPx: lied how?
14:11:19 <jmcarthur> and are good to use :)
14:11:28 <augur_> SrPx: if you DIDNT post it, noone wouldve noticed the capture problem!
14:12:03 <augur_> SrPx: also why not just use strings instead of ints, since you're using names
14:12:11 <SrPx> augur_: eh I was just kidding
14:12:16 <augur_> ints only make sense if you're using debruijn indices, and those are evil
14:12:39 <jmcarthur> i think debruijn indices are fine, especially if you are using the type system to ensure that you are using them correctly
14:12:55 <jmcarthur> just plain ints are a pain, for sure
14:13:08 <haasn> augur_: what's evil about debruijn indices?
14:13:16 <SrPx> augur_: lets just suppose I ran a gensymifier before it
14:13:52 <irene-knapp> acomar: Are you building your own wrapper to opencv?  because I see that there are three of them on Hackage already; you might wish to, at the least, see how they solve this problem.
14:14:04 <acomar> irene-knapp: at least one of them is mine :)
14:14:08 <irene-knapp> ahh :)
14:14:40 <irene-knapp> https://github.com/aleator/CV/blob/master/CV.cabal
14:14:42 <acomar> I'm wrapping a whole lot more of the API than the others manage atm, and I'm headed for inclusion with the main library
14:14:50 <irene-knapp> understood, and good reason to be doing your own
14:15:06 <irene-knapp> this one seems to have given up on pkgconfig-depends and enumerated each .so in extra-libraries
14:15:12 <acomar> so opencv will have (primitive) haskell bindings soon -- as soon as I can get these bugs sorted out
14:15:15 <augur_> haasn: nothing, as long as you dont have type binders.
14:15:16 <irene-knapp> I suspect this is a Cabal incompatibility with this type of pkg-config output
14:15:33 <irene-knapp> digging into the code of Cabal itself would probably make things clearer, but I don't suggest doing that :)
14:15:33 <acomar> irene-knapp: it might be, but swapping to the extra-libraries approach doesn't solve much
14:15:39 <tdammers> hmm, does anyone know how I can set data-something attributes with blaze?
14:15:48 <irene-knapp> hmm
14:15:52 <acomar> everything I need happens to come out of the one module I defined so it's easy enough
14:15:56 <jle`> jmcarthur: my threads are likely to use multiple IORefs during their lifetime
14:15:56 <copumpkin> tibbe: is there a clean way to ask Data.Binary.Get/Builder to be aligned to some size?
14:16:06 <jle`> should i just switch to STM?
14:16:10 <copumpkin> tibbe: inserting padding in Builder or ignoring padding in Get
14:16:21 <acomar> irene-knapp: trying once more with "extra-libraries: opencv_c"
14:16:27 <acomar> in place of pkgconfig-depends
14:16:58 <acomar> yep, identical set of errors :/
14:17:50 <acomar> there actually was a bug earlier today where the symbols weren't really in that archive (go cmake!) and I naively assumed fixing that problem would solve everything
14:18:04 <tibbe> copumpkin: I'm afraid not
14:18:06 <acomar> apparently I got ahead of myself because it turned out to be coincidental
14:18:54 <copumpkin> tibbe: does the underlying representation not allow it or are the combinators just not written?
14:19:16 * hackagebot diagrams-builder 0.5.0.4 - hint-based build service for the diagrams graphics EDSL.  http://hackage.haskell.org/package/diagrams-builder-0.5.0.4 (BrentYorgey)
14:19:34 <jmcarthur> jle`: honestly, i consider STM a good *default* for shared memory concurrency, and say you should only switch to anything else after strong consideration of why you want to do so.
14:19:40 <jmcarthur> jle`: rather than the other way around
14:19:41 <irene-knapp> acomar: well, if you look at what the .cabal file I linked does, it needs to enumerate all the libraries, not just opencv_c
14:19:56 <irene-knapp> https://github.com/aleator/CV/blob/master/CV.cabal#L98 specifically
14:20:53 <copumpkin> tibbe: looking at it, it seems to have "bytes read" as a piece of state in the parse state
14:21:22 <copumpkin> that seems promising
14:21:35 <copumpkin> the docs don't really scope it much though
14:22:09 <copumpkin> I assume it's delimited to the runGet
14:22:27 <copumpkin> yup!
14:23:18 <acomar> irene-knapp: the symbols are only from opencv_c -- there are no referenced symbols from the other archives
14:23:28 <acomar> by design
14:23:36 <acomar> and checked via nm
14:25:09 <tibbe> copumpkin: you don't know the alignment of the underlying ByteString input
14:25:29 <copumpkin> oh, I'm just talking about alignment in data terms
14:25:32 <tibbe> copumpkin: wait, I'm confused
14:25:36 <copumpkin> with respect to the beginning of the thing being read
14:25:40 <tibbe> copumpkin: we're talking about Builder, not Get
14:25:51 <SrPx> augur_: is this correct now? http://lpaste.net/101249
14:26:07 <copumpkin> tibbe: oh, my original question was about both sides of it. It looks like I can get what I want for Get, but not for Builder
14:26:22 <copumpkin> I'll need to maintain some additional state on top of Builder to keep that information
14:26:25 <tibbe> copumpkin: so you want to know the current number of bytes written?
14:26:38 <tibbe> copumpkin: it seems reasonable to expose it I think
14:26:38 <copumpkin> yeah
14:26:38 <augur_> SrPx: i dont know, i dont like de bruijn. x3
14:26:43 <tibbe> copumpkin: check the bytestring builder
14:26:50 <tibbe> copumpkin: it will replace the data.binary one
14:26:54 <SrPx> augur_: ):
14:27:00 <copumpkin> oh
14:27:04 <tibbe> copumpkin: it could be that it has a different design that no longer tracks the number of bytes written
14:27:17 <augur_> SrPx: it looks about right
14:27:24 <SrPx> augur_: what is a type binder and why it makes bruijn bad
14:27:34 <acomar> irene-knapp: and just to verify, I added the other libraries, and no luck (and I'm pretty sure cabal handles the pkgconfig output ok because it spits out the correct linker command)
14:27:35 <copumpkin> tibbe: so Builder will live bytestring and Get in data.binary?
14:27:49 <SrPx> also, tips about the code style? other than proper identation on guards
14:27:55 <tibbe> copumpkin: we'll probably rexport the builder from binary to to not break code
14:28:00 <tibbe> copumpkin: but yes
14:28:01 <copumpkin> I see
14:28:11 <copumpkin> anyway, a monoidal interface doesn't really allow me to "ask" things
14:28:13 <augur_> SrPx: like a forall, or a lambda for types
14:28:24 <copumpkin> so I think it's sort of inherent that I won't be able to do this on the builder side
14:29:09 <copumpkin> not the end of the world, I can layer a Writer on top of it
14:29:10 <augur_> its actually probably not _too_ bad if you have separated types and values i bet, but its a pain in the but when you have dependent types that make no distinction
14:29:24 <copumpkin> actually State :/
14:30:24 <irene-knapp> acomar: hmmm, okay...  well, I guess you have stumped me on this one, sorry
14:30:33 <SrPx> augur_: Hmm I see...! That makes sense.
14:30:35 <acomar> irene-knapp: :/ yea, thanks a ton for your help
14:30:42 <irene-knapp> anytime
14:30:48 <augur_> SrPx: well, the reason why is subtle, and only shows up in type checking
14:30:59 <mindleyhilner> '
14:31:06 <augur_> SrPx: i mean, the reason why de bruijn is a pain in those situations
14:40:59 <kardboardb> Is there a built-in function to create a singleton list, or do I have to write one whenever I want one?
14:41:20 <kardboardb> For dot-free notation -- so I can do something like: Left . []
14:41:23 <startling> :t (:[])
14:41:23 <lambdabot> a -> [a]
14:41:54 <kardboardb> Hm, that doesn't seem to work.
14:42:04 <startling> > (:[]) 12
14:42:05 <lambdabot>  [12]
14:42:10 <startling> > 12 : []
14:42:11 <kardboardb> Ah! ([]).
14:42:11 <lambdabot>  [12]
14:42:16 <artyomkazak1> > pure 12 :: [Int]
14:42:17 <lambdabot>  [12]
14:42:29 <startling> oh, yeah, pure and return also work
14:42:40 <startling> (but may need some help with inference)
14:43:10 <kardboardb> Thanks. What's the logic behind the colon in (:[]) ?
14:43:28 <kardboardb> Oh, because it's cons with an empty list.
14:43:31 <kardboardb> Okay, thanks.
14:44:28 <startling> kardboardb: yeah.
14:44:55 <startling> the parens make it a section, but you can use it as a normal operator call too.
14:45:04 <startling> > map (:[]) [1, 2, 3]
14:45:05 <lambdabot>  [[1],[2],[3]]
14:45:22 <Fuuzetsu> > map return [1, 2, 3]
14:45:23 <lambdabot>  No instance for (GHC.Show.Show (m0 a0))
14:45:23 <lambdabot>    arising from a use of `M3661009632677072146841.show_M3661009632677072146841'
14:45:23 <lambdabot>  The type variables `a0', `m0' are ambiguous
14:45:23 <lambdabot>  Possible fix: add a type signature that fixes these type variable(s)
14:45:23 <lambdabot>  Note: there are several potential instances:
14:45:31 <Fuuzetsu> > map return [1, 2, 3] :: [[Int]]
14:45:32 <lambdabot>  [[1],[2],[3]]
14:45:34 <startling> > map (+2) [1, 2, 3]
14:45:35 <lambdabot>  [3,4,5]
14:54:24 * hackagebot antagonist 0.1.0.0 - A web interface to Antisplice dungeons.  http://hackage.haskell.org/package/antagonist-0.1.0.0 (implementation)
14:59:02 <Nafai> Where in GHC source is the Bool type defined?
14:59:58 <thebnq> @src Bool
14:59:59 <lambdabot> data Bool = False | True deriving (Eq, Ord)
15:01:24 <haasn> Nafai: ghc-prim most likely
15:01:25 <gwz> hey, If I am doing recursion, how would I accomplish something like this,  walk (Group (headV:tailV)) = doSomethingWith head; walk(Group(tailV))
15:01:26 <Fuuzetsu> GHC.Prim or something IIRC
15:01:29 <shachaf> :i can probably tell you the module name.
15:01:32 <Nafai> ok, looking
15:01:38 <Fuuzetsu> data Bool = False | True        -- Defined in ‘GHC.Types’
15:01:57 <shachaf> No particular reason for it to be in ghc-prim, I think.
15:02:09 <shachaf> Maybe for some other primitives that use it.
15:02:45 <haasn> GHC.Types is in ghc-prim, and it exports it, but it's not defined there. The only import is GHC.Prim, which I don't think has an actual source file
15:02:48 <shachaf> I guess that's the package, not the module.
15:02:55 <haasn> Err, I just missed the definition
15:03:06 <haasn> It's defined there
15:03:57 <shachaf> https://github.com/ghc/packages-ghc-prim/blob/master/GHC/Types.hs
15:04:23 <shachaf> Anyway, there are alll sorts of jams involved in the definitions of "primitive" types like that.
15:05:02 <Nafai> Thanks.  I was just trying to answer someone's question on Twitter.  This helps.
15:10:23 <acomar> irene-knapp: solved it manually!
15:10:29 <irene-knapp> oh!  what was the fix?
15:10:44 <acomar> irene-knapp: had it compile as a static lib and put that on the end of the command line
15:11:03 <fizruk> I apologise, but how do you pronounce Wouter Swierstra?
15:11:09 <acomar> that, along with the pkg-config output (so that it can find the symbols it references), was enough to get it to link
15:11:17 <irene-knapp> ah!  okay :/
15:11:26 <irene-knapp> that is distressingly fragile wrt upgrades
15:11:27 <acomar> now... gotta figure out how to get cabal to put the archive at the *end* of the linker command line
15:11:28 <irene-knapp> but at least it works
15:11:31 <irene-knapp> yeah
15:11:35 <acomar> yea
15:11:38 <BMeph> fizruk: VOO-ter SVEER-struh.
15:11:47 <acomar> at least I found *something* that works
15:12:13 <BMeph> fizruk: Keep in mind, that's how -> I <- pronounce it. That doesn't mean that's how HE does. ;)
15:12:42 <copumpkin> tibbe: seems unfortunate that Data.ByteString.Builder is adopting a different convention from the mainstream one for its builders
15:12:50 <copumpkin> tibbe: word64LE vs. word64be
15:12:53 <tdammers> ah, hehe... dataAttribute, obviously :x
15:12:57 <copumpkin> le, I mean
15:13:07 <fizruk> BMeph: that's how I though it should be pronounced, so would be my fault if I misspell it :)
15:13:09 <tibbe> copumpkin: oh, I didn't notice that
15:13:14 <tibbe> copumpkin: that is unfortunate
15:13:37 <copumpkin> I also personally prefer the lowercase naming :)
15:13:51 <haasn> Does somebody know where I can contact the author of HsColour (http://hackage.haskell.org/package/hscolour)?
15:13:52 <copumpkin> it'll also be extra ugly if the getters have lowercase and the putters have uppercase
15:14:28 * hackagebot antagonist 0.1.0.1 - A web interface to Antisplice dungeons.  http://hackage.haskell.org/package/antagonist-0.1.0.1 (implementation)
15:14:43 <ion> http://codegolf.stackexchange.com/a/24289/1621
15:14:54 <BMeph> fizruk: "Wouter" is the Dutch version of my given name, so I ought to pay more attention to it than I do. :)
15:17:24 <haasn> forever $ mapM_ (print.ord) "\EOT\b\SI\DLE\ETB*" -- simple version
15:17:34 <haasn> (also very slow)
15:19:33 <copumpkin> tibbe: I filed a ticket :)
15:20:41 <acomar> anyone know of a way to specify a static lib to cabal for linking?
15:21:24 <tibbe> copumpkin: saw
15:23:12 <meditans> hi, I wanted to give a try at Dysinger's tutorial for setting up emacs with haskell at http://tim.dysinger.net/posts/2014-02-18-haskell-with-emacs.html
15:23:49 <meditans> the problem is that, if I open a simple file, and type C-c C-l as I used to, in order to compile it
15:24:06 <meditans> emacs respond with a series of question, and then:
15:24:30 <meditans> The haskell process 'haskell' has died. Restart (y or n)
15:25:06 <meditans> if I hit y it continues with the same question. I think I have a problem in haskell-interactive, but don't know how to solve it
15:25:27 <meditans> any suggestion?
15:26:14 <carter> meditans: email dysinger? or ask johnw  :)
15:26:53 <meditans> carter: in the contact section of dysinger is written: I live in a small hut in the mountains of Kumano Kodō on Kii Hantō and would not like to be contacted.
15:27:01 <carter> screw that
15:27:03 <carter> tweet at him
15:27:04 <carter> :)
15:27:47 <meditans> carter: you're right, I'm dumb. I saw the twitter account googling for him. Sorry xd
15:28:12 <carter> not dumb, just lazy like haskell
15:28:50 <BMeph> I prefer Just-In-Time processing, to lazy. But then, I'm lazy, as well. ;)
15:29:31 * hackagebot antisplice 0.11.0.4 - An engine for text-based dungeons.  http://hackage.haskell.org/package/antisplice-0.11.0.4 (implementation)
15:33:01 <colDrMcBeardman> does Parsec generally have a hard time giving the right column number?
15:38:11 <mietek> Is there a Haskell web server based on pipes?
15:39:02 <acomar> no, not yet
15:39:04 <haasn> mietek: I found http://hackage.haskell.org/package/pipes-http-1.0.0/docs/Pipes-HTTP.html
15:39:23 <acomar> that's just a http client library if I understand correctly
15:39:41 <haasn> Indeed, you are right
15:39:43 <mietek> It's hardly even a library
15:43:22 <gamegoblin> I've never actually dug into ghc source or any generated assembly. Does it represent data types with multiple constructors and values kind of like a (C) union of structs?
15:45:09 <haasn> gamegoblin: if you're interested in the internal implementation of ADTs, pattern matching and function application in general; you may wish to look up the various publications (co-)authored by SPJ
15:45:19 <haasn> like https://research.microsoft.com/apps/pubs/default.aspx?id=67083
15:45:39 <haasn> or https://research.microsoft.com/en-us/um/people/simonpj/Papers/pj-lester-book/
15:46:49 <colDrMcBeardman> gamegoblin, https://ghc.haskell.org/trac/ghc/wiki/Commentary/Compiler/DataTypes
15:46:53 <colDrMcBeardman> may be of use to you
15:52:14 <rex1> I was thinking about how to write a program that takes some data type and automatically generates a GUI form to create/modify structures of that type
15:53:21 <rex1> would template haskell be good for that kind of thing?
15:53:31 <rex1> it seems like it is recommended against a lot of the time
15:53:45 <gwz> hey, If I am doing recursion, how would I accomplish something like this,  walk (Group (headV:tailV)) = doSomethingWith head; walk(Group(tailV))
15:54:30 <haasn> depends on what “doSomethingWith” is doing
15:54:37 <haasn> is it an IO action?
15:55:02 <gwz> no just some computation like gettinga  value from head and storing it somewhere
15:55:17 <haasn> why would you want to store it elsewhere?
15:55:21 <haasn> Why not just return a list of the computed values?
15:56:14 <pavonia> rex1: Should that work for any data type or a specific one?
15:57:24 <rex1> any data type
15:58:05 <haasn> rex1: I don't think template haskell would be necessary
15:58:09 <pavonia> Not sure if TH is what you want here, you might want to look at the Data.Data module instead
15:58:17 <haasn> rex1: you could probably use something like Data.Data.Data or GHC.Generics to inspect the structure of the data type
15:58:20 <haasn> and generate appropriate forms
15:58:59 <rex1> ok
15:59:06 <rex1> thanks!
15:59:16 <rex1> I will look at those modules
16:03:23 <roboguy_> gwz: where do you want to store it and what do you want to do with it?
16:05:14 <merijn> gwz: The idea of "store somewhere" doesn't make a lot of sense in haskell, tbh
16:06:17 <Twey> What's a nice library for pretty-printing things in a textual (nested) grid layout?
16:06:17 <zenkeku> @paste
16:06:17 <lambdabot> Haskell pastebin: http://lpaste.net/
16:08:35 <zenkeku> http://lpaste.net/101253 -- Could someone explain to me why this is happening? It is a very short script, I am just very new to haskell.
16:08:36 <mietek> @hoogle [(a -> Bool)] -> a -> Bool
16:08:37 <lambdabot> Data.Foldable all :: Foldable t => (a -> Bool) -> t a -> Bool
16:08:37 <lambdabot> Data.Foldable any :: Foldable t => (a -> Bool) -> t a -> Bool
16:08:37 <lambdabot> Prelude all :: (a -> Bool) -> [a] -> Bool
16:09:09 <roboguy_> zenkeku: it's because you can return either head xs or xs
16:09:18 <roboguy_> head xs and xs cannot have the same type
16:09:34 <roboguy_> so it can't type check that if-then-else
16:09:47 <zenkeku> Ah, so even in recursion (as in it hasn't finished) you need to return the same type? I hadn't thought of that.
16:10:19 <roboguy_> zenkeku: well, all branches of a function must return the same type, regardless of whether or not it's recursive
16:10:36 <roboguy_> also, you should always give an explicit type signature to top-level functions. it makes errors nicer to read
16:10:44 <zenkeku> roboguy_: Thinking about that I realize it now. I haven't fully wrapped my head around recursion just yet.
16:10:56 <merijn> More importantly, many people in here can't be arsed to debug your code without types
16:10:58 <zenkeku> roboguy_: Will do, thanks for the tip.
16:11:01 <merijn> (i.e. me)
16:11:26 <zenkeku> Haha, sorry about that. I will remember that for future pestering.
16:11:29 <roboguy_> zenkeku: no problem. also, you don't need some of those parentheses (particularly around the length calls and head)
16:11:46 <merijn> zenkeku: I appreciate that many beginners don't feel like that, but for all the experienced people types are like the lifeline to understand what's going on without having to guess :)
16:12:34 <zenkeku> merijn: That makes sense. I imagine it also helps with trying to find the intention of the author.
16:12:34 <roboguy_> merijn: to be fair, zenkeku did provide the type error
16:12:52 <merijn> roboguy_: Yeah, that's already better than usual :)
16:13:10 <merijn> zenkeku: tbh, I would probably eliminate the if/else and use pattern matching instead to write this
16:14:02 <zenkeku> merijn: Patter matching with cases or guards? Also -- I'm explicitely using if/else because the book I am reading hasn't yet used if/elses. This is an exercise inside of the book and I assume that this sort of error was meant to happen.
16:14:25 <zenkeku> While I'm here: Why does haskell like indenting if/else's like that?
16:14:47 <merijn> zenkeku: For example, something like this: http://lpaste.net/101253
16:15:03 <roboguy_> zenkeku: it has a off-to-the-right whitespace rule
16:15:15 <merijn> zenkeku: I recommend reading this: https://en.wikibooks.org/wiki/Haskell/Indentation
16:15:16 <roboguy_> zenkeku: also, nested ifs are pretty much never used in haskell
16:15:33 <merijn> zenkeku: That explains *exactly* how haskell layout works and will teach you exactly what you can and cannot do
16:15:38 <dwat3r> if and haskell are enemies
16:16:10 <zenkeku> merijn: I will certainly read that.
16:16:22 <merijn> Oh, that pattern matching probably needs a _ pattern for the last clause
16:16:23 <zenkeku> roboguy_: I'm really glad that I won't be using them all that often, then.
16:16:28 <merijn> But anyway, that should be sufficient
16:16:44 <zenkeku> Like : lastButOne _ = error ?
16:16:56 <merijn> zenkeku: Yeah
16:17:04 <dwat3r> :t lastButOne _
16:17:05 <lambdabot> Not in scope: `lastButOne'
16:17:05 <lambdabot> Pattern syntax in expression context: _
16:17:12 <roboguy_> merijn: I think i'd use a pattern [x,_]
16:17:18 <zenkeku> merijn, roboguy_: Thank you very much for your help.
16:17:19 <merijn> zenkeku: Because (I think, I didn't test this) all patterns should have the same number of elements
16:17:26 <dwat3r> you mean x:_
16:17:40 <merijn> eh, patterns, not elements
16:17:46 <merijn> dwat3r: No, that means something different
16:18:04 <merijn> dwat3r: roboguy_'s pattern matches a list of two elements, yours a list of >1 elements
16:18:15 <dwat3r> yea,sorry bout that
16:20:05 <quchen> :t flip (\xs -> all ($ xs)) -- mietek
16:20:06 <lambdabot> [a -> Bool] -> a -> Bool
16:20:36 <mietek> quchen: ;)
16:20:55 <zenkeku> merijn: Adding a _ to the error clause was indeed correct. I also added a type signature. Thank you very much.
16:21:29 <merijn> zenkeku: Now understand how it works and why it's correct :)
16:21:39 <zenkeku> merijn: Haha working on it.
16:21:44 <merijn> zenkeku: Alternatively, if you wanna be nicer than throwing an error, change it to return "Maybe a"
16:21:57 <merijn> SO "lastButOne :: [a] -> Maybe a"
16:22:37 <zenkeku> Maybe a?
16:23:25 <startling> zenkeku, data Maybe a = Just a | Nothing
16:23:27 <merijn> zenkeku: Ah, you've never encountered Maybe?
16:23:41 <merijn> zenkeku: What are you reading to learn? I might be racing ahead of your text :p
16:24:18 <zenkeku> merijn: I'm reading "Real World Haskell"
16:25:19 <merijn> zenkeku: Also check out Learn You a Haskell, it explains things at a slightly slower pace. I tend to recommend LYAH first and then RWH haskell as a follow up (skipping the first few syntax explanation chapters of RWH)
16:25:24 <merijn> @where lyah
16:25:24 <lambdabot> http://www.learnyouahaskell.com/
16:25:49 <zenkeku> I have read a decent chunk of LYAH and found it to be a bit too slow paced.
16:25:57 <zenkeku> RWH seems to be good enough for me
16:26:39 <merijn> ok :)
16:26:42 <zenkeku> Thank you all for your help, but I must go. I need to make dinner.
16:26:42 <quchen> There's also "Programming in Haskell" by Hutton.
16:26:51 <quchen> But it's even slower I think.
16:27:00 <merijn> Is it? How do you manage that? :p
16:27:19 <shachaf> I don't think _Programming in Haskell_ is long enough to manage to be slow.
16:27:42 <shachaf> Anyway, I remember it as a good introduction.
16:30:46 <acomar> anyone know how to control linking order with cabal? I have a static archive I need passed late, but it's uniformly getting passed at the beginning.
16:31:06 <acomar> I'd use a dyanmic archive if I could, but that just outright doesn't link regardless of placement
16:31:22 <merijn> acomar: Old linux linker?
16:31:47 <acomar> merijn: no, modern ld :/
16:31:54 <merijn> acomar: Really? That's odd
16:32:07 <merijn> acomar: Stuff like gold should do multipass linking, no?
16:32:13 <acomar> haven't figured out why the dynamic archive doesn't resolve
16:32:16 <merijn> Order shouldn't really matter
16:32:26 <acomar> yea, that's what I assumed at the start
16:32:51 <acomar> but I can get it to link late on the command line (after haskell packages) but not early like cabal inserts it
16:33:46 <merijn> I'm not sure then :\
16:34:16 <acomar> hmm... ld has a feature called group archives
16:34:25 <acomar> let me see if that makes it work at the beginning
16:34:27 <startling> does anyone here have haskell-inf-mode working with cabal repl?
16:35:55 <Twey> Is there a class for a group somewhere?
16:36:24 <shachaf> Taneb has one.
16:36:34 <shachaf> @hackage groups
16:36:34 <lambdabot> http://hackage.haskell.org/package/groups
16:36:55 <Twey> Ah, thanks
16:37:24 <haasn> It is possible to have criterion apply a function to multiple different parameters and collect all of the results as if they came from the same function? Or do I have to test something like nf (map f) [0..n] ?
16:37:34 <acomar> oh wow, cabal doesn't pass ld-options to the linker command line...
16:37:51 <haasn> I want to more accurately compare a function with an O(1) complexity to a function with an O(n) complexity, for some average sample of input values
16:39:08 <iota_> hmm, I was playing around with Data.Array and there seems to be a Traversable instance for Arrays, but I didn't find it in the haddocks, so I'm becoming curious about where it comes from...
16:39:08 <SrPx> hastec: can't find a package database at - does anyone know what I can do? I'm clueless
16:42:35 <roboguy_> iota_: did you do :i in ghci?
16:42:44 <pyon> Is there any "force :: a -> a" ?
16:42:51 <SrPx> Also I installed sockets.io and it made fay break! Whyyyy
16:42:54 <bennofs> pyon: what should that do?
16:43:05 <pyon> bennofs: a `seq` a
16:43:09 <bennofs> öy
16:43:20 <bennofs> pyon: a `seq` a is the same as just a
16:43:49 <pyon> Oh.
16:44:02 <enthropy> rnf a `seq` a -- is possibly useful
16:44:24 <bennofs> x `seq` y says: evaluate x when/right before y is evaluated. a `seq` a says: evaluate a before a is evaluated. That is the same as a
16:44:34 <Twey> import Data.Group; import Control.Comonad; import Data.Monoid; import Control.Applicative -- this makes me sad
16:44:39 <roboguy_> iota_: it looks like it actually is defined in Data.Traversable
16:44:56 <edwardk> ?
16:45:04 <roboguy_> Twey: why would that make you sad/
16:45:06 <haasn> Does edwardk have a highlight on comonad?
16:45:09 <Twey> Yes
16:45:14 <pyon> bennofs: Oh, silly me was thinking "x `seq` y" meant "force x NOW", completely forgotting there is no notion of "now" whatsoever.
16:45:18 <Twey> The sheer arbitrariness of Control/Data
16:45:23 <roboguy_> ah
16:45:30 <quchen> bennofs: seq does not specify an evaluation order. Evaluating `b` first in `seq a b` is a valid implementation.
16:45:34 <Twey> Especially when it makes my imports not line up prettily :þ
16:46:09 <pyon> Anyway, I guess it is best not to be concerned with strictness vs. laziness issues so early in my project. :-)
16:46:19 <bennofs> quchen: ok, well, but everyone is lazy and doesn't import Control.Parallel just to get the more correct pseq :)
16:46:38 <roboguy_> Twey: I guess the Data stuff is more "data structure-like" and the Control stuff is more "control structure-like". but it is a little arbitrary
16:46:41 <quchen> It's not more correct, it's a function with an additional promise.
16:46:49 <haasn> pyon: force x when you type the source code? :)
16:47:13 <bennofs> quchen: but most code i've seen uses seq where really pseq is meant
16:47:24 <haasn> What does pseq do?
16:47:55 <quchen> haasn: seq, but with evaluation of the first argument first
16:47:57 <edwardk> pseq a b connotes that a will be evaluated _before_ b.
16:48:13 <haasn> how does it differ from seq in terms of semantics?
16:48:30 <merijn> haasn: Evaluation order of seq is not defined
16:48:31 <quchen> `seq = pseq` is a valid implementation
16:48:53 <haasn> merijn: and how much of a problem is that?
16:48:58 <edwardk> well you can only distinguish them if you observe side-effects and if seq takes advntage  of the extra flexibility it is offered
16:49:09 <merijn> haasn: Semantics of "seq x y" are: IFF neither x nor y are bottom, then once "seq x y" is evaluated, both x and y will have been evaluated"
16:49:14 <quchen> seq is defined in terms of "what to be when the first argument is bottom", and that can be "determined" before or after the second one is evaluated
16:49:48 <merijn> haasn: If x and y are both bottom, you cannot assume "which" bottom you get (not that there's a difference according to haskell, but still)
16:50:12 <haasn> merijn: I thought if ‘x’ and ‘y’ both, say, throw an error; you would always get the one from x?
16:50:13 <bennofs> So seq x y = y `pseq x `pseq` y is a valid implementation?
16:50:18 <haasn> is this not correct, then?
16:50:46 <merijn> haasn: I don't think that's defined
16:52:31 <Twey> http://lpaste.net/7650775224622776320 — why does this simple class instance say I need FlexibleInstances?
16:52:49 <haasn> merijn: seems like you are right, the report only cares about it being ⊥
16:53:15 <haasn> although it does define “seq ⊥ b = ⊥” which sort of suggests you get the left bottom
16:53:24 <haasn> but it's certainly hairy
16:53:33 <copumpkin> Twey: because concrete types in typeclasses require it
16:53:39 <merijn> Twey: According to the report class your Int and String should be type variables
16:53:40 <bennofs> Twey: I think you cannot have non-type variables as arguments to constructors in instance definitions without FlexibleInstances
16:54:05 <enthropy> if you use Double instead of String, it'll probably be ok
16:54:31 <roboguy_> enthropy: why?
16:54:35 <enthropy> type String = [Char], gets substituted in
16:54:37 <haasn> Twey: Haskell98 class instances must be of the form (Con a b c ...) where Con is a type constructor and a .. are variables
16:54:40 <iota_> roboguy_: strange, it didn't show up the first time
16:54:40 <Twey> enthropy: It's not
16:54:42 <merijn> enthropy: Not the problem
16:54:42 <roboguy_> enthropy: why does that matter?
16:55:00 <Twey> haasn: Haskell2010 too, apparently
16:55:04 <Twey> That's… weird
16:55:09 <roboguy_> iota_: it's sort of hidden for some reason. I think Array isn't part of haskell10 and that might be the reason. or something like that
16:55:21 <roboguy_> *haskell2010
16:55:22 <merijn> Twey: It's really up tight without FlexibleInstances, yes
16:55:37 <haasn> or flexiblecontexts.
16:55:47 <merijn> Twey: Hence why FlexibleInstances is widely used :p
16:55:50 * Twey turns FlexibleInstances on and forgets about it
16:55:51 <haasn> which is arguably even saner than flexibleinstances
16:56:02 <enthropy> Twey, merijn, roboguy_ yes you're right
16:56:08 <haasn> Twey: you can forget about it until you run into ambiguous type errors :)
16:56:24 <haasn> Twey: you can also use a newtype, which is the haskell98 thing to do
16:56:25 <iota_> roboguy_: it only shows up in ghci if I also import Data.Foldable
16:56:31 <iota_> very strange
16:56:34 <merijn> Twey: IMO the "did you mean to turn on FlexibleInstances/FlexibleContexts" warnings are the only ones where you should probably just ineeded blindly enable the extension when GHC suggests it :p
16:56:47 <merijn> s/ineeded/indeed
16:56:48 <haasn> UndecidableInstances \o/
16:57:19 <roboguy_> iota_: that is strange. in ghci 7.8 it imports it if I just import Data.Array and Data.Traversable
16:57:38 <pyon> Is there any situation in which MultiParamTypeClasses can be used without FlexibleInstances?
16:57:39 <merijn> haasn: Actually, randomly deciding to evaluate either x OR y first would be valid seq semantics :)
16:57:49 <bennofs> merijn: ScopedTypeVariables too, sometimes TemplateHaskell
16:57:55 <merijn> pyon: Sure
16:58:08 <merijn> pyon: If none of your instances ever mention explicit types
16:58:11 <roboguy_> iota_: actually, in ghci 7.6.3 it seems like I can actually use the Array instance of Traversable without :i actually saying it exists...
16:58:45 <merijn> bennofs: ScopedTypeVariables won't have effect without changing the code you wrote
16:58:53 <pyon> I am trying to understand why I need FlexibleInstances here: http://lpaste.net/101262
16:59:03 <Twey> merijn: I don't know, I think there are quite a lot of those.  Like ViewPatterns.
16:59:04 <iota_> roboguy_: yep, same here (ghci 7.6.3)
16:59:19 <pyon> Namely, without FlexibleInstances, GHC complains about the instance at line 74.
16:59:25 <roboguy_> iota_: must be some kind of bug they fixed in 7.8
16:59:25 <Twey> You should already have ScopedTypeVariables on, of course.  :þ
16:59:55 <haasn> pyon: because the parameters still aren't in the form (T a b c ...)
16:59:59 <haasn> pyon: namely, there's no T
17:00:05 <haasn> I think that's not possible without flexibleinstances
17:00:35 <pyon> Oh.
17:01:13 <pyon> haasn: So, without FlexibleInstances, I could not make an "instance Monad m => Applicative m" either, right? (Not that I want to.)
17:01:30 <haasn> pyon: correct
17:03:21 <dwcook> Has someone written a datatype that models logic circuits? Operations I'd like to support are to find out how many inputs and outputs there are, run the circuit with given inputs, and introspect the entirety of the circuit.
17:03:39 <dwcook> I guess the first falls under the third.
17:04:01 <startling> dwcook, sounds like a graph
17:04:27 <merijn> dwcook: Some colleagues at Twente are working on designing circuits in haskell, not sure whether they support operations like that, though
17:04:30 <haasn> dwcook: ask edwardk
17:04:36 <haasn> iirc he has something related to this
17:04:48 <dwcook> startling, a subset of graphs, I guess.
17:05:10 <dwcook> merijn, do you have a relevant link?
17:05:35 <merijn> @hackage clash-ghc
17:05:35 <lambdabot> http://hackage.haskell.org/package/clash-ghc
17:05:51 <quchen> I'm wondering about how catching `error`s works. Is it magic the runtime allows the programmer to do, or is it an actual feature of the IO type (or something else)?
17:06:08 <dwcook> merijn, thanks, I'll take a look.
17:06:28 <merijn> quchen: error just throws an exception, no?
17:06:43 <bennofs> @src error
17:06:43 <lambdabot> error s = throw (ErrorCall s)
17:06:45 <quchen> merijn: Yes, it's a CustomError exception or something like that.
17:06:54 <merijn> There you go
17:07:03 <merijn> So it works the exact same way as normal exceptions
17:07:22 <quchen> So there's my new question then, how do exceptions from pure code work
17:07:33 <quchen> Pure = non-IO in this case
17:07:36 <dwcook> merijn, hmm, seems a little bit lower level than what I wanted, so perhaps I should be more specific.
17:07:54 <bennofs> quchen: unsafePerformIO ?
17:08:09 <roboguy_> quchen: they probably cheat a little bit
17:08:20 <quchen> bennofs: I doubt that.
17:08:28 <bennofs> @src throw
17:08:28 <lambdabot> throw exception = raise# exception
17:08:37 <dwcook> Inputs and outputs should be on or off. I don't need any other possible values. Also, circuits should be composable so that you can use one circuit somewhere within another.
17:09:01 <dwcook> I don't need an actual correspondence to hardware. This is just an abstract thing I want to play with.
17:09:40 <merijn> quchen: What is the problem with how they work?
17:09:54 <merijn> quchen: Attempting to evaluate an exception thunk will cause it to be thrown
17:09:57 <pyon> The only way to make a type synonym abstract outside of a module is to use newtype, right?
17:10:05 <pyon> (Well, "type synonym".)
17:10:07 <bennofs> quchen: There is no difference between IO and non-IO at the C-- level, I think
17:10:24 <merijn> quchen: Which is why it's recommend to use throwIO instead of throw, laziness may let the "throw" exception escape your catch due to not being evaluated
17:10:37 <merijn> pyon: Right
17:10:38 <dwcook> Perhaps I'll write my own type for it. Directed graphs seem like the way to go.
17:10:45 <merijn> pyon: type synonyms are just aliases
17:10:47 <dwcook> Implementing using those, I mean.
17:11:53 <merijn> quchen: (with throwIO the IO will enforce sequencing, ensuring the throw is executed before leaving the scope of your catch)
17:12:02 <pyon> merijn: Yeah, but I like how in ML I can use opaque ascription to hide aliases outside of a module. It is particularly helpful when lots of these type synonyms stand for function types.
17:12:25 <merijn> pyon: Sure, but then what's the trouble with newtype?
17:12:37 <quchen> merijn: I was just wondering about how `seq (error "x") (error "y")` lets you determine which bottom was evaluated first. They're identical from the program's perspective, so there must be something outside of the program that prints something with x/y when running it.
17:12:57 <quchen> Hence the question about how exceptions are handled.
17:13:08 <merijn> quchen: Sure, the RTS runs main within an implicit "catch", I'd say
17:13:14 <roboguy_> pyon: you'll probably want some sort of abstracted way to introduce values into the type though right? so what's the downside to newtype in this case?
17:14:03 <pyon> roboguy_: merijn: I have two type synonyms "type Parser stream pos a = Maybe Chunk -> Reply stream pos a" and "type Lexer stream pos token = pos -> Parser stream pos token", and lots of combinators that manipulate these function types.
17:14:38 <pyon> Turning these into newtypes and inserting wrappers/unwrappers everywhere is going to make these combinators a lot less fun to define.
17:14:50 <roboguy_> pyon: would a Functor instance help?
17:15:08 <roboguy_> and a Contravariant instance for Lexer
17:15:28 <roboguy_> well, if you changed the order of the type arguments
17:15:42 <pyon> What would the order of the arguments have to be?
17:15:45 <pyon> pos stream token?
17:16:03 <roboguy_> pyon: well, to make Lexer an instance of Contravariant, the function argument type needs to come last
17:16:07 <roboguy_> that's what I mean
17:16:35 <roboguy_> then you can do instance Contravariant (Lexer stream token) where ...
17:17:12 <merijn> roboguy_: No you can't
17:17:24 <merijn> roboguy_: You can't make partially applied type synonyms instances
17:17:27 <merijn> Sadly
17:17:38 <merijn> I wish you could :)
17:18:55 <pyon> In Lexer's case, I guess it is not such a pressing need to make it abstract. But, in Parser's case, it is.
17:21:31 <roboguy_> merijn: I meant if it was a newtype
17:24:23 <startling> hvr: are you around? I have some questions about a commit you made to haskell-mode. :)
17:24:38 <roboguy_> pyon: well, you could probably at least make Parser an instance of Functor, depending on what Reply is
17:26:10 <roboguy_> pyon: what sort of manipulations do you need to do?
17:26:24 <roboguy_> actually, there are libraries that make newtype wrapping/unwrapping easier too
17:41:11 <ElectroStatik> d
18:30:01 * hackagebot tianbar 0.3.4.0 - A desktop bar based on WebKit  http://hackage.haskell.org/package/tianbar-0.3.4.0 (AlexeyKotlyarov)
18:41:48 <mike616> some nice girl want to having fun
18:43:04 <mike616> some girl on this channel want to having fun
18:43:21 <bergey> @where ops
18:43:21 <lambdabot> arjanb bos byorgey Cale conal copumpkin dcoutts dibblego dmhouse dolio dons edwardk elliott geekosaur glguy Heffalump Igloo jmcarthur johnw kosmikus Lemmih monochrom nyc Philippa Pseudonym quicksilver roconnor Saizan shachaf shapr sjanssen ski sorear SyntaxPolice xerox
18:43:29 <mike616> im a sexy guy from quebec
18:43:34 --- mode: ChanServ set +o geekosaur
18:43:38 --- kick: mike616 was kicked by geekosaur (mike616)
18:44:05 --- mode: geekosaur set -o geekosaur
18:44:20 --- mode: ChanServ set +o geekosaur
18:46:50 <joelteon> i don't think this is the place for you, mike616
18:49:27 <ElectroStatik> anyone in here know some scala?
18:50:08 <Twey> It would be nice if there were a GHCi command to print Haskell source of functions…
18:50:27 <Twey> Hm, I guess that's what SimpleReflect is for
18:51:35 <geekosaur> it's just difficult enough to be annoying to write, without being difficult enough to justify a paper :p
18:51:57 <Twey> Heh, indeed
18:52:22 <aristid> paper-driven compiler development?
18:52:54 <Twey> aristid: I think that's how most compiler development happens
18:54:02 <aristid> Twey: for ghc
18:54:18 <aristid> i would be surprised if it was also the case for, say, clang
18:56:39 <Twey> aristid: Okay, compiler development that isn't funded by a large company :þ
18:56:55 <Twey> Though I think there were some papers in LLVM, weren't there?
18:57:03 <aristid> maybe
18:57:40 <geekosaur> Microsoft was in some sense funding ghc dev for a while
18:58:37 --- mode: geekosaur set -o geekosaur
18:59:34 <Twey> geekosaur: No longer?
18:59:56 <aristid> isn't spj still there?
19:00:16 <geekosaur> but large parts of ghc dev are now done by people not at MSR
19:07:29 <Rufflewind> is there a way to get haddock to generate docs for unexported definitions?
19:10:07 <Eduard_Munteanu> Rufflewind: make an internal module exporting everything and another one that re-exports what you want?
19:11:21 <Rufflewind> that would work ... but it's a bit more effort than I was expecting. i was hoping maybe a flag or something?
19:12:27 <Rufflewind> fyi it's for the purposes of generating an internal documentation of the project
19:26:19 <hasmania> Hello everyone.
19:27:34 <Eduard_Munteanu> hasmania: hi
19:28:32 <hasmania> Hi Eduard_Munteanu
19:29:44 <hasmania> I lost touch with programming eons ago. I am trying to relearn "programming". Would you recommend Haskell as a "first" language? Also, I was looking at FPcomplete.com
19:30:09 <augur_> hasmania: yes, haskell is a good place to start
19:30:27 <Eduard_Munteanu> Might even be an advantage.
19:30:34 <hasmania> Is there a way to emulate what fpcomplete does locally? Emacs and soothing else?
19:30:40 <hasmania> *something
19:31:07 <Twey> hasmania: You can use FPComplete via emacs, I believe
19:31:18 <hasmania> Twey: really?
19:31:30 <hasmania> Hmmz you mean using the emacs browser?
19:31:39 <Twey> Well, chrisdone said he'd put it in, and I have no reason to believe he was lying
19:31:47 <Twey> No, as an emacs mode
19:32:13 <Twey> https://www.fpcomplete.com/page/api
19:33:06 <Twey> https://www.fpcomplete.com/blog/2013/12/api-emacs
19:33:13 <hasmania> Why should I use fpcomplete and why should I not? {Sorry I am just trying to see why I should go one way or another and apologize if my questions are too basic.}
19:34:54 <Twey> FPComplete is a nice service that also provides integrated Web development facilities to shorten the development cycle if you're doing that
19:35:24 <Twey> On the negative side, it's mostly proprietary software that runs on their servers
19:36:16 <hasmania> Ok so fpcomplete is like a cloud service, with haskell bits which are nice for rapid prototyping the web.
19:36:23 <Twey> And I don't know how mature it is, not being a serious user of it myself.  It hasn't been around as long as some of the other offerings.
19:36:25 <hasmania> *web application.
19:37:02 <Twey> Not *just* the Web, but mostly, I suppose.  It also gives you the usual stuff you get from ghc-mod &c.
19:37:49 <Twey> And a couple of other niceties, like Haddock integration
19:38:16 <zomg> I'd guess fpcomplete is nice for starting out as you don't have to think so much about setting up ghc, cabal hell and all that :)
19:38:35 <zomg> so you can get into doing stuff a bit faster esp with those haddock integrations as sometimes looking that stuff up is a bit of a pain
19:38:39 <hasmania> Twey: What does Haddock integration do ?
19:38:59 <Twey> hasmania: Read https://www.fpcomplete.com/blog/2013/12/api-emacs
19:41:33 <hasmania> Thanks Twey.
19:44:26 <pyon> Is there any way, given a Data.Text.Text, to get another Data.Text.Text that starts at the i-th byte from the original Data.Text.Text?
19:44:28 <hasmania> Is there anything similar to fpcomplete but is open source ?
19:44:46 <haasn> pyon: what if ‘i’ is in the middle of a code point?
19:45:07 <pyon> haasn: I am fully responsible for ensuring that does not happen.
19:45:41 <haasn> more pressing question: what is the i'th byte of a Text?
19:45:42 <Eduard_Munteanu> pyon: use Data.Text.Encoding to convert it to a ByteString with a particular encoding.
19:46:07 <pyon> Ah!
19:46:18 <pyon> Eduard_Munteanu: Thanks.
19:46:58 <Eduard_Munteanu> pyon: you might still want to answer haasn question though
19:47:40 <pyon> Eduard_Munteanu: Actually, what I really need is a substring type that lets me recover the string it was taken from.
19:47:44 <Twey> hasmania: emacs + ghc-mod or hdevtools give you most of the same features
19:47:50 <pyon> Eduard_Munteanu: For parsing with backtracking purposes.
19:48:03 <Twey> hasmania: But not the bits that run your program on FPCo's servers, obviously
19:48:47 <hasmania> That's all right Twey, don't want to be dependent on them. Maybe I will start with fpcomplete and move out as soon as I know what I want.
19:49:16 <hasmania> Thank you Twey and zomg and augur_ and Eduard_Munteanu
19:51:03 <Eduard_Munteanu> pyon: then you merely want the nth character of the Text, not byte, no?
19:52:50 <pyon> Eduard_Munteanu: Getting the n-th character of a Text is rather costly.
19:53:36 <pyon> Eduard_Munteanu: If I could remember what byte that character is located at, then I could slice the Text at that byte, without having to traverse it from the beginning.
19:54:14 <Eduard_Munteanu> pyon: what I'm saying is you want to slice in terms of characters rather than bytes
19:54:45 <pyon> Eduard_Munteanu: Yeah. At no point do I want to slice at the middle of a codepoint.
19:55:18 <Eduard_Munteanu> pyon: sure, then just slice using Data.Text stuff
19:55:41 <shachaf> I think bytes in particular aren't the issue here, just being able to keep an index into a Text that you can access (relative to) at constant time or something along those lines.
19:55:58 <pyon> Pretty much.
19:56:27 <Eduard_Munteanu> :t Data.Text.split
19:56:28 <lambdabot> (Char -> Bool) -> Data.Text.Internal.Text -> [Data.Text.Internal.Text]
19:56:31 <shachaf> A character index won't let you do that, since Text uses UTF-16. Bytes let you do that but are not a very good abstraction.
19:56:33 <Eduard_Munteanu> :t Data.Text.splitAt
19:56:33 <lambdabot> Int -> Data.Text.Internal.Text -> (Data.Text.Internal.Text, Data.Text.Internal.Text)
19:57:04 <shachaf> Splitting the Text into multiple Texts is an option, but sometimes it's not so great since you now might have to manage multiple Texts.
19:57:46 <Eduard_Munteanu> shachaf: I don't understand your remark about character indexes, why would UTF-16 matter if you only care about the index of a character?
19:58:07 <haasn> because indexing UTF-16 by character id isn't O(1)
19:58:11 <shachaf> Yes.
20:00:20 <Eduard_Munteanu> You can split before each parse... hopefully the user doesn't use inefficient, char-wise parsers.
20:01:43 <Eduard_Munteanu> (similar to what attoparsec suggests you to do)
20:03:48 <vozz> Is there a way to tell cabal to install all the imports in a single haskell file without having to define a cabal file?
20:03:55 <vozz> or manually cabal install each one
20:04:18 <haasn> there's no unique way to determine from the module import list which packages you need to install
20:04:39 <haasn> even in a .cabal file it relies on the author manually writing out the list of packages that the program depends on
20:05:42 <vozz> Hmm, okay, thanks
20:12:39 <no-n> what's a concrete example of when Applicative is useful?
20:12:46 <haasn> parsec
20:13:06 <haasn> or applicative-style parsers in general
20:13:32 <haasn> ziplist
20:14:53 <no-n> ok
20:15:33 <copumpkin> no-n: when you want more introspection on the constructed computation than Monad allows, with more power than Functor
20:15:50 <copumpkin> no-n: another way to think about it is a Functor that supports mapping over multiple things at once
20:15:57 <no-n> ahh, yep
20:16:05 <copumpkin> (or nothing at all!)
20:16:09 <no-n> :}
20:16:49 <pyon> Is there a type-level function composition operator?
20:17:08 <copumpkin> pyon: it tends to be really verbose :/
20:17:20 <Eduard_Munteanu> pyon: not really, you can define a newtype for it
20:17:29 <pyon> Dang. :-(
20:17:47 <haasn> newtype (f $ a) = App (f a)
20:17:53 <haasn> Oh, composition
20:17:54 <Eduard_Munteanu> newtype Compose f g x = Compose (f (g x))
20:18:01 <haasn> newtype (f . g) a = Comp (f (g a))
20:19:09 <pyon> Whoa. :-|
20:20:54 <ion> What i used to generate the coefficients for the codegolf Lost thing https://gist.github.com/ion1/9578025
20:21:19 <SrPx> OK I give up, I could not manage to use a single one of the Haskell->JS libs. Only fay, but seems like it isn't very compatible with node.js so I wasn't able to test it yet :/
20:21:35 <haasn> SrPx: have you tried ghcjs?
20:21:40 <SrPx> So just tell me, please, of the hs->js solutions out there, what is supposed to be faster?
20:22:00 <SrPx> haasn: oh if I did, I installed 2 VMs with vagrant or something like that just for it and it failed miserably in so many ways I just gave up
20:22:12 <SrPx> I don't understand why installing libraries for haskell should be so hard :(
20:22:30 <haasn> Hmm. I don't remember having to do anything unusual
20:23:17 <SrPx> )=
20:23:40 <SrPx> it even requires the new version of ghc that is not even available
20:25:04 <tikhon> SrPx: how about Haste?
20:25:10 <tikhon> I think that should just be cabal-installable
20:25:12 <augur_> SrPx: wtf are you writing? lmfao
20:25:43 <SrPx> tikhon: getting many errors, opened an issue
20:25:54 <tikhon> shame
20:25:57 <SrPx> augur_: wtf are you writing about wtf im writing
20:26:12 <augur_> SrPx: you and your crazy requirements
20:26:15 <SrPx> tikhon: \= which of them is the fastest , though?
20:26:24 <SrPx> augur_: "working" is a hard requeriment nowadays lol
20:28:39 <gwz> hey, I keep on getting issues with this line, (maximum int > maxVal) = maximum int  something about Couldn't match expected type `Int' with actual type `Int -> Int'
20:29:16 <Eduard_Munteanu> :t maximum
20:29:17 <lambdabot> Ord a => [a] -> a
20:29:54 <gwz> int is a list here
20:30:13 <Eduard_Munteanu> gwz: and where do you get it from?
20:30:47 <gwz> http://lpaste.net/4724424988642246656
20:32:24 <Eduard_Munteanu> gwz: you're missing an argument to the recursive call to getMAxRowValue
20:33:48 <gwz> oh oops thanks
20:34:12 <Eduard_Munteanu> gwz: also the where clause maxVal shadows your parameter maxVal, I don't think you intended that
20:35:22 <Eduard_Munteanu> gwz: note that 'where' applies to the entire declaration
20:35:51 <SrPx> hastec vec.hs vec.hs:3:18: Could not find module `Prelude' <- a different error now, at least
20:36:49 <SrPx> how can I just uninstall everything haskell-related from mac and try it again?
20:37:48 <gwz> Eduard_Munteanu: I don't understand
20:39:30 <SrPx> after calling sudo uninstall-hs and following instructions I can still call GHC...
20:44:03 <Galactic> can someone give me a quick example of   fmap?
20:44:15 <haasn> > fmap (*2) [1,3,2]
20:44:16 <lambdabot>  [2,6,4]
20:44:24 <startling> > fmap (* 2) (Just 12)
20:44:25 <lambdabot>  Just 24
20:44:29 <Galactic> but that is the same as map
20:45:00 <tikhon> Galactic: it's just a version map that works on multiple different types, not just lists
20:45:13 <Galactic> ahh ok
20:45:29 <tikhon> fmap (* 2) Nothing
20:45:29 <Twey> > fmap (+ 1) (* 2) $ 3
20:45:31 <lambdabot>  7
20:45:36 <tikhon> > fmap (* 2) Nothing
20:45:37 <lambdabot>  Nothing
20:46:03 <Galactic> :type fmap
20:46:55 <tikhon> :t fmap
20:46:56 <lambdabot> Functor f => (a -> b) -> f a -> f b
20:47:34 <tikhon> Functor just means "mappable", really
20:47:44 <Galactic> how would you read that
20:48:01 <tikhon> there's three variables: f, a and b
20:48:11 <tikhon> Functor f => means that f can be any type that is a functor
20:48:15 <tikhon> a and b can be anything
20:48:16 <haasn> fmap takes a function (a -> b) and gives you a function f a -> f b, for some types a, b, f where f is an instance of Functor
20:48:53 <tikhon> for example, when you use fmap over a list, f gets replaced with []
20:48:54 <tikhon> and you get
20:49:00 <tikhon> (a -> b) -> [a] -> [b]
20:49:06 <tikhon> :t map
20:49:06 <lambdabot> (a -> b) -> [a] -> [b]
20:49:11 <tikhon> voilà
20:49:15 <Galactic> wow
20:49:19 <Galactic> I see
20:49:23 <Galactic> thanks
20:49:29 <tikhon> similarly, you can replace f with Maybe
20:49:36 <startling> ("[a]" is the same as "[] a")
20:49:50 <startling> ("[]" is the Functor, not "[a]")
20:50:05 <tikhon> (a -> b) -> Maybe a -> Maybe b
20:50:06 <Galactic> > [] 4
20:50:07 <lambdabot>  Couldn't match expected type `a1 -> t0' with actual type `[a0]'
20:50:27 <Galactic> > [] "3"
20:50:28 <lambdabot>  Couldn't match expected type `[GHC.Types.Char] -> t0'
20:50:28 <tikhon> Galactic: that syntax works for types
20:50:28 <lambdabot>              with actual type `[a0]'
20:50:29 <haasn> Galactic: that's only valid for the type []
20:50:29 <startling> Galactic: sorry, should have been more clear -- that's for the type of lists, not lists
20:50:35 <tikhon> > [1] :: [] Int
20:50:36 <lambdabot>  [1]
20:50:40 <tikhon> > [1] :: [Int]
20:50:41 <lambdabot>  [1]
20:50:46 <Galactic> aa ok
20:51:09 <tikhon> it's just built into the language to make signatures for lists prettier, since we use lists a lot
20:52:34 <Platz> suprised that there is no function in prelude or data.list  that updates a list at an index http://lpaste.net/101265
20:52:44 <Platz> is that a subtle hint to use vector or something?
20:52:47 <haasn> Platz: it's a pretty expensive and uncommon operation
20:52:49 <tikhon> yeah
20:52:56 <tikhon> or a Map
20:52:56 <haasn> perhaps, yes
20:53:27 <haasn> or a function
20:53:42 <tikhon> I think lens has something for updating lists like that, but I wouldn't recommend doing it anyhow
20:53:58 <tikhon> especially if you haven't learned about lenses yet
20:54:07 <edwardk> > "hello" & ix 3 %~ succ
20:54:08 <Platz> hrmm, a vector vs a map is an interesting question
20:54:09 <lambdabot>  "helmo"
20:54:39 <tikhon> IntMap has good asymptotics, I believe, and works well if your indices are sparse
20:54:45 <startling> > over (ix 0) (+ 2) [1, 2, 3]
20:54:46 <lambdabot>  [3,2,3]
20:54:48 <Platz> the syntax of that (lens) is nice but it is necessarly more performant than the take/drop method?
20:54:49 <edwardk> > "hello" & ix 0 .~ 'j'
20:54:50 <lambdabot>  "jello"
20:55:03 <startling> aw, edwardk beat me
20:55:13 <edwardk> Platz: actually take/drop will do two walks of the list, the lens version will do one.
20:55:32 <Platz> thats nice
20:55:34 <edwardk> so it should actually run bout 2x faster ;)
20:55:49 <haasn> (you can also use splitAt to avoid the edwardk dependency)
20:56:20 <Platz> I had splitAt and refactored to take/drop, i guess that was a mistake ;)
20:56:41 <tikhon> if performance actually mattered, you wouldn't be using this approach in the first place
20:56:56 <edwardk> both the splitAt and take/drop versions ay a lot for the extra (,)'s
20:57:03 <edwardk> er pay
20:57:07 <edwardk> but YMMV
20:57:12 <Platz> tikhon: fair enough, in this case it doesn't matter at all, but interesting nontheless
20:57:18 <tikhon> fair enough
20:57:36 <tikhon> so yeah, the lens version is prettier and better
20:58:03 <edwardk> tikhon: that is kind of the mission of lens ;)
20:58:20 <Platz> finally time to learn lens then, I just might finally be ready
20:58:35 <haasn> I think take+drop is even more disastrously bad for performance because it forces the GC to keep around the entire list until “take” reaches its end
20:59:06 <no-n> are/will haskell jobs becom(ing) more numerous?
20:59:06 <edwardk> yep
20:59:08 <tikhon> a fun exercise to do once you've got the basics is to write your own little clone of lens—I found it really helped me appreciate the design choices in the acutal library
20:59:13 <thirsteh> is there a reason -j isn't on by default in recent cabals?
20:59:35 <tikhon> no-n: it looks like they're becoming more common, but not super quickly
20:59:37 <edwardk> tikhon: that was how i figured it out ;)
21:00:21 <edwardk> no-n: based on the contents of my inbox, yes.
21:00:23 * hackagebot clifford 0.1.0.3 - A Clifford algebra library  http://hackage.haskell.org/package/clifford-0.1.0.3 (spacekitteh)
21:00:26 <tikhon> right now, if you really want one, you can probably find a Haskell job but it'll take some effort and might involve moving
21:00:45 <thirsteh> no-n: a lot of the haskell jobs that are available are generally high quality, though
21:00:54 <no-n> edwardk :)
21:01:10 <haasn> I hear bernalex is looking for some Haskell programmers ;)
21:01:33 <no-n> hehe
21:01:36 <no-n> i'm not looking for a job yet
21:01:39 <no-n> still learning
21:01:44 <haasn> same
21:01:53 <tikhon> hmm
21:01:55 <no-n> kind of falling in love tho
21:02:05 <haasn> even though http://functionaljobs.com/jobs/8678-haskell-developer-at-zalora looked really interesting :)(
21:02:07 <haasn> :( *
21:02:18 <Platz> I'm hoping chicago has something but haven't seen much. you'd think with all the finance there would be a chance
21:02:24 <edwardk> haasn: the team there is pretty good
21:02:35 <haasn> edwardk: solirc told me to apply!
21:02:38 <tikhon> I've heard Allston Trading uses some Haskell? Maybe.
21:02:45 <no-n> haasn that does look cool
21:03:04 <tikhon> spending some time in Singapore would be interesting
21:04:12 <no-n> most expensive city in the world apparently
21:04:21 <tikhon> is it?
21:05:24 * hackagebot clifford 0.1.0.4 - A Clifford algebra library  http://hackage.haskell.org/package/clifford-0.1.0.4 (spacekitteh)
21:05:38 <no-n> idk, they said so on democracy now or something :s
21:05:56 <no-n> depends though
21:06:05 <no-n> how you live there :p
21:07:30 <tikhon> I'm not sure Zalora is doing things I'm interested in though
21:07:35 <tikhon> I guess it's mostly data sciency stuff?
21:07:58 <haasn> (you mean like information science?)
21:08:19 <tikhon> Information science? I haven't heard that term before.
21:08:39 <haasn> crude translation of “informatik” I guess
21:08:51 <haasn> also known as “computer science” in english-speaking countries
21:09:09 <tikhon> oh no, that's too general
21:09:23 <tikhon> data science is more like analyzing large amounts of data with statistics and maybe some machine learning
21:09:31 <haasn> ah okay
21:09:32 <tikhon> or something—it's not a field I care for much
21:10:01 <tikhon> still, it's cool to see Haskell being used for that sort of thing
21:10:03 <haasn> I don't like anything involving “large amounts of data” because that suggests to me I have to worry about performance to the point where I can't use the most elegant concise lensy abstraction I can come up with :(
21:10:23 <tikhon> eh, it depends
21:10:29 <edwardk> there is a certain elegance you can attain when the numbers get _big_ enough at least
21:10:42 <tikhon> often scalability is more important than absolute performance: see Hadoop
21:11:15 <haasn> hmm fair enough
21:11:18 <tikhon> and Haskell's pretty good for some high performance stuff
21:11:19 <edwardk> tikhon: data science, but really it comes down to rebuilding their entire infrastructure in haskell, not just data science
21:11:27 <tikhon> like what Carter's been working on
21:11:48 <edwardk> for me i like haskell for high performance applications because i can write things to be more composable and still fast
21:12:04 <carter> tikhon: i needto reply to an email from them
21:12:09 <carter> what edwardk  jsut said :)
21:12:14 <tikhon> hmm
21:12:37 <tikhon> lately I've been using Haskell more like a metaprogramming language, with the performance heavy lifting done by other tools
21:12:53 <tikhon> a similar approach seems very good for things like embedded computing with the right DSL
21:12:54 <edwardk> better i can just keep throwing building blocks in the bin and finish assembling something once i know all the trade-offs
21:13:29 <carter> edwardk: i've learned A LOT from seeing you do that
21:15:36 <no-n> http://lpaste.net/7896349291260674048 <-- is there a language extension that would have the n on line mean the n on line 1?
21:16:03 <tikhon> no
21:16:15 <AfC> Application we've built spends a lot of time in two particular foreign libraries. Both of which are thread heavy. Sometimes I wonder if I should be trying to get more insight into the interaction between the RTS and these C++ monsters.
21:16:16 <tikhon> but you could do f  (n', x) | n' == n
21:16:17 <haasn> no-n: do you just want to use the ‘n’ from line 1 everywhere?
21:16:26 <tac> Any ideas why I'm getting this cabal error?
21:16:27 <tac> http://lpaste.net/1845640162550218752
21:16:28 <tikhon> assuming I understood your question correctly
21:16:40 <haasn> oh, I think tikhon's interpretation may be more realistic
21:16:46 <AfC> [and trying to avoid the temptation to reimplement them in 100% Haskell just so I can let the I/O manager do its thing :)]
21:16:52 <no-n> haasn: everywhere?
21:17:00 <no-n> not if you mean module level
21:17:21 <haasn> I meant everywhere as in “within the right hand side of every application of f”
21:17:37 <no-n> sorry brb
21:25:14 <zipper> Uh anyone know a channel name close to "no type haskell"?
21:25:26 <startling> zipper: what do you mean?
21:26:01 <zipper> startling: A channel on freenode about typesystems but it's name has haskell in it if I remember right
21:26:09 <zipper> Saw about it in a tweet
21:26:19 <startling> hm, I don't know, sorry.
21:26:34 <haasn> I believe there's a query you could use to try querying the names of all channels present on freenode
21:26:38 <haasn> perhaps /list
21:27:18 <startling> I don't think freenode lets you /list.
21:27:28 <no-n> there's actually a search thing
21:27:32 <thirsteh> it lets you, but doesn't show channels with +s (which is the default), iirc
21:27:35 <zipper> Oh man /list haskell is bad
21:27:46 <zipper> Lot of text I don't understand
21:27:54 <no-n> Welcome to #wolfgame! | This channel has been inactive lately. See /msg alis list *wolf* -min 25 for some alternatives.
21:28:10 <no-n> zipper ^
21:30:48 <Platz> tikhon: know of any good arduino DSLs?
21:31:27 <tikhon> not really
21:31:30 <zipper> Found it thanks no-n
21:31:36 <no-n> np
21:31:48 <no-n> zipper: i'm interested. what's it called?
21:31:48 <zipper> 60 haskell related channels shock on me
21:31:55 <no-n> haha yea
21:32:00 <no-n> that's capped too
21:32:12 <zipper> no-n: I was being forgetful it is #nothaskell
21:32:16 <no-n> ahh
21:32:29 <zipper> but they said they talk about typesystems or something
21:32:47 <no-n> neato
21:32:53 <tikhon> I know there are some DSLs that just compile to C; you could probably use one of those on an Arduino
21:33:05 <jle`> why isn't there a default Binary instance for Text?
21:33:15 <no-n> #numerical-haskell might be interesting
21:33:17 <jle`> wouldn't encode just be encodeUtf8 ?
21:33:22 <startling> no-n: it is!
21:33:25 <Platz> tikhon: that's a good idea
21:33:28 <no-n> :D
21:33:36 <no-n> many of them are just alt-language ones
21:33:55 <no-n> i don't see #haskell-hs though :p
21:34:32 <carter> no-n: how would #numerica-haskell help?
21:35:00 <no-n> I meant it might be interesting in general, not specifically with zipper's problem
21:35:05 <carter> *numerical-haskell
21:35:47 <carter> oh yeah
21:36:02 <carter> it has some stuff thats interesting when i'm not there :)
21:36:17 <no-n> :P
21:36:47 <zipper> carter: I thought you started numerical haskell
21:37:09 <carter> i did :)
21:37:09 <carter> i'm the boring one there
21:37:09 <carter> loud + boring
21:37:32 <zipper> carter: At least I saw a person with a similar name and a hat on twitter talk about it.
21:37:42 <zipper> Ah my memory serves me right
21:38:09 <carter> zipper: yup
21:38:11 <carter> tis i
21:38:12 <carter> carter == @cartazio on github/twitter
21:38:22 <carter> some people took @carter on thoe
21:38:23 <carter> those
21:38:56 <Galactic> is there a readInt function...I have been looking and I found http://hackage.haskell.org/package/base-4.6.0.1/docs/Numeric.html but how can I import that? What is the library?
21:39:20 <startling> > (read :: Int -> String) "12"
21:39:21 <lambdabot>  Couldn't match type `[GHC.Types.Char]' with `GHC.Types.Int'
21:39:21 <lambdabot>  Expected type: GHC.Types.Int -> GHC.Base.String
21:39:21 <lambdabot>    Actual type: GHC.Base.String -> GHC.Base.StringCouldn't match expected typ...
21:39:21 <lambdabot>              with actual type `[GHC.Types.Char]'
21:39:22 <startling> er
21:39:30 <startling> > (read :: String -> Int) "12"
21:39:31 <lambdabot>  12
21:39:31 <tikhon> import Numeric
21:39:32 <tikhon> it's from base, so you have the package alread
21:39:32 <tikhon> y
21:39:39 <no-n> now my channels list has a scroll bar :p
21:39:48 <Galactic> thanks
21:40:51 <tikhon> readInt is useful if you want to support a different base (ie binary or something); you can use read for normal ints
21:40:52 <tikhon> which includes decimal numbers and hexadecimal, if I'm not mistaken
21:41:11 <tikhon> > read "0x10" :: Int
21:41:12 <lambdabot>  16
21:41:18 <startling> Galactic, if you're using something that only expects Int, you can just use "read".
21:41:30 <tikhon> well, that should have worked, anyhow
21:41:33 <Galactic> k, yea I just need ints
21:41:43 <startling> Galactic: the issues is that the return type isn't uniquely determined by the argument type, so you need to help inference somehow
21:41:49 <startling> otherwise it defaults to () iirc
21:41:52 <startling> > read "()"
21:41:53 <lambdabot>  ()
21:41:56 <startling> yeah.
21:41:59 <Galactic> I see
21:42:06 <startling> > read "12"
21:42:07 <lambdabot>  *Exception: Prelude.read: no parse
21:42:17 <startling> ^ because it's trying to parse a ()
21:42:44 <tikhon> > read "10" + 10
21:42:44 <startling> > words "but this works" !! read "2"
21:42:45 <lambdabot>  20
21:42:45 <lambdabot>  can't find file: L.hs
21:42:53 <startling> > words "but this works" !! read "2"
21:42:53 <lambdabot>  "works"
21:43:21 <Galactic> > (read :: String -> Bool) "True"
21:43:22 <lambdabot>  True
21:43:30 <startling> defaulting is widely-regarded to have been a mistake, but so it goes.
21:44:02 <tikhon> well, it's very useful in GHCi
21:44:09 <tikhon> > if read "True" then 1 else 2
21:44:10 <lambdabot>  1
21:44:25 <tikhon> hmm, lambdabot doesn't seem to like me very much
21:44:57 <tikhon> the point is: the compiler needs to know what type to read *somehow*, but it can usually infer it from the rest of your code
21:45:48 <enthropy> @type (^)
21:45:49 <lambdabot> (Integral b, Num a) => a -> b -> a
21:47:39 <tikhon> > 7^3
21:47:40 <lambdabot>  343
21:47:43 <mindleyhilner> accursedUnutterablePerformIO :: IO a -> a
21:47:44 <startling> it *should* be an ambiguous-type error, but it's not, so you have to write code defensively.
21:47:53 <mindleyhilner> hurrr.
21:49:05 <Galactic> what is wrong with this...I get Prelude.read: no parse.
21:49:07 <Galactic> main = do
21:49:07 <Galactic>   content <- getContents
21:49:07 <Galactic>   let (x:xs) = lines content
21:49:07 <Galactic>       k = (read :: String -> Int) x
21:49:07 <Galactic>   putStrLn (show k)
21:49:38 <startling> Galactic: x doesn't parse as an Int
21:50:02 <startling> Galactic: you might want to try sticking a "print x" in there to see what x is at runtime
21:50:26 <Galactic> yea you are right x is "1 5" lol haha my bad.
21:50:50 <Galactic> I need to use words to separate them and get the 5.
21:51:35 <startling> yep.
21:52:54 <Galactic> nice, now it works... I added  k = (read :: String -> Int) (words x !! 1)
21:53:25 <SrPx> Just wondering, as I can't manage to install haste/ghcjs, is it a good idea to just use emscripten? Should I get huge performance drops for doing so?
21:54:04 <startling> emscripten will probably make FFIing to js a pain in the ass.
21:57:44 <trap_exit> has anyone ever succeeded in trolling #haskell ?
21:59:39 <startling> trap_exit: I'm not sure there's a well-defined difference between trolling #haskell and asking a real question.
21:59:48 <no-n> lol
22:00:06 <thirsteh> SrPx: your time is better spent building ghcjs or any of the others than trying to compile LLVM via emscriptem. You'd have to port much of the runtime, which others have already done
22:00:13 <trap_exit> i'm not sure what would be more effective
22:00:18 <trap_exit> arguging that clojure > haskell or coq > haskell
22:00:33 * hackagebot snap-utils 0.1.2 - Snap Framework utilities.  http://hackage.haskell.org/package/snap-utils-0.1.2 (LukeHoersten)
22:01:14 <Galactic> read   reads from standar input/output...what about if I have a list like   ["2","45","12","78"]  how can I convert those numbers to int. Lets say I want to see how many of those numbers are divisible by a number x...so I was thinking creating a function like  isFactor :: Maybe Int -> Maybe Int -> Bool
22:01:19 <SrPx> thirsteh: okay but this is frustrating, it just wont work
22:01:40 <thirsteh> SrPx: have you tried using their vagrant box? It might be a little outdated now, but it worked perfectly for me
22:01:46 <Galactic> how could I implement that
22:01:53 <startling> > map read ["2","45","12","78"] :: [Int]
22:01:54 <lambdabot>  [2,45,12,78]
22:02:00 <thirsteh> SrPx: see the comments here http://www.reddit.com/r/haskell/comments/1fvv5q/ghcjs_introduction_concurrent_haskell_in_the/
22:02:20 <tikhon> Galactic: why the Maybe?
22:02:23 <Galactic> but is   read  fast?
22:02:48 <Galactic> what do you guys think about this:
22:02:50 <Galactic> isFactor :: Maybe Int -> Maybe Int -> Bool
22:02:50 <Galactic> isFactor n m = (pure rem <*> m <*> n) == pure 0
22:02:53 <startling> Galactic: I think it's about as fast as it can be expected to be.
22:03:34 <erisco> how do you conveniently work with types of IO (Maybe a)? ie how can you use do-notation to take away the explicit unpacking of all the maybes?
22:03:42 <startling> Galactic: it might make more sense to have an Int -> Int -> Bool and liftM2 or LiftA2 it
22:03:52 <startling> erisco, it depends what you're doing.
22:04:26 <erisco> startling, well I am working with ghcjs-dom and most of the interactions with the dom may fail, so the operations return, for some 'a', IO (Maybe a)
22:04:42 <startling> erisco: oh. you might look at MaybeT
22:05:17 <Galactic> I saw someone doing this, so I thought that might be more efficient using Maybe Int
22:05:54 <startling> Galactic: I don't think so.
22:07:28 <erisco> has haskell.org been having troubles? connection keeps timing out
22:08:56 <erisco> startling, there seems to be more than one version lying around... which one is used?
22:09:33 <startling> erisco, 'transformers'.
22:09:54 <startling> I think the other ones predate MaybeT's inclusion in transformers.
22:10:04 <erisco> this one? http://hackage.haskell.org/package/transformers-0.3.0.0/docs/Control-Monad-Trans-Maybe.html
22:10:12 <startling> yeah.
22:10:19 <erisco> okay thanks
22:25:29 <tomboy64> i need to do computations with e and ln with about 100 digits precision (120 to be safe)
22:25:41 <tomboy64> any suggestions what to use for that?
22:26:03 <verement> Mathematica is nice
22:26:23 <tomboy64> :) i want to do it in haskell.
22:26:32 <nisstyre> tomboy64: use a bignum library?
22:26:39 <tomboy64> should be reasonably easy since it's using gmp under the hood
22:27:12 <tomboy64> hm so there's no ready-to-use way with gmp built in?
22:27:28 <dmj`> in lens is there an infix operator for view?
22:27:30 <copumpkin> ugh, there isn't a replicateM for ByteString?
22:27:33 <haasn> dmj`: (^.)
22:28:20 <haasn> tomboy64: you could try using Fixed with a custom exponent
22:28:31 <dmj`> haasn: I'm unsure because f = do { x <- ask; return x ^. y } is the same as f = view y
22:28:33 <haasn> or CReal. Depending on your use case
22:28:41 <haasn> dmj`: return (x ^. y)
22:28:47 <haasn> dmj`: yours is (return x) ^. y
22:29:29 <dmj`> haasn: ok sure, but I'd have to do (^. y) <$> ask
22:29:39 <dmj`> haasn: and use an explicit ask still
22:29:49 <haasn> Oh, I understand
22:29:55 <haasn> view is more general than (^.)
22:30:09 <haasn> you are asking if there is a version of (^.) generalized to MonadReader?
22:30:49 <haasn> If so, I think the answer is “no”
22:30:56 <haasn> other than, well, `view`
22:31:01 <dmj`> yea, I think my ? might not make sense since view takes on arg and an infix op needs 2 params
22:31:04 <dmj`> 2 args*
22:31:13 <dmj`> an arg*
22:31:33 <dmj`> @typ (^.)
22:31:33 <lambdabot> s -> Getting a s a -> a
22:31:34 <haasn> that too
22:31:39 <dmj`> @typ view
22:31:40 <lambdabot> MonadReader s m => Getting a s a -> m a
22:31:56 <tomboy64> haasn: thank you, looking at that now
22:32:05 <dmj`> so view is probably defined in terms of (^.)
22:32:11 <dmj`> @src view
22:32:12 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
22:34:57 <dmj`> haasn: also, is there a version of (.=) that isn't an infix operator
22:34:59 <haasn> view :: MonadReader s m => Getting a s a -> m a
22:35:01 <haasn> view l = Reader.asks (getConst #. l Const)
22:35:49 <haasn> dmj`: ‘assign’, apparently
22:35:51 <haasn> I had to look that one up
22:35:58 <haasn> did not know about it, cool
22:36:06 <no-n> @pl \x a -> x:x:a
22:36:06 <lambdabot> liftM2 (.) (:) (:)
22:36:28 <Rylee> that's so haskell
22:36:42 <no-n> hehe
22:36:47 <dmj`> haasn: that is so awesome, thanks
22:36:51 <haasn> join (liftA2 fmap) -- haskeller?
22:37:12 <haasn> oh, missing a (:) at the end
22:37:19 <dmj`> haasn: went from this
22:37:21 <startling> wow, that is cool
22:37:22 <dmj`> forM_ apiKey $ \key -> mailChimpAPIKey .= key
22:37:42 <dmj`> to this: forM_ apiKey $ assign mailChimpAPIKey
22:37:47 <haasn> hmm..
22:38:29 <startling> :t assign
22:38:30 <lambdabot> MonadState s m => ASetter s s a b -> b -> m ()
22:38:39 <startling> oh, it's set on State
22:39:34 <haasn> apiKey^!folded.act (mailChimpAPIKey .=) -- ?
22:39:36 <haasn> no, not much cleaner
22:39:38 <haasn> stick with yours ;)
22:40:14 <haasn> dmj`: wait a minute. Why are you assigning to mailChimpAPIKey multiple times?
22:40:31 <haasn> the last one will just take precedence, it's a setter law
22:41:06 <haasn> so that's pretty much the same as mailChimpAPIKey .= last apiKey -- assuming apiKey is nonempty
22:41:20 <dmj`> haasn: It's the forM_ from Data.Foldable applied to a Maybe type
22:41:27 <haasn> ah :)
22:41:31 <startling> it could be a weird MonadState.
22:41:58 <dmj`> startling: it's Update from acid-state so it's basically a sugared state monad
22:42:04 <startling> got it.
22:42:09 <dmj`> setMailChimpKeys :: Maybe Text -> Maybe Text -> Update Backend ()
22:42:09 <dmj`> setMailChimpKeys apiKey listId = do
22:42:09 <dmj`>   forM_ apiKey $ assign mailChimpAPIKey
22:42:12 <dmj`>   forM_ listId $ assign mailChimpAPIKey
22:42:15 <dmj`>  
22:42:37 <haasn> that is actually quite nice
22:42:40 <dmj`> well, glad I pasted that, found a bug :)
22:42:49 <haasn> same lens twice? :)
22:42:51 <dmj`> I *am* setting it twice
22:42:53 <dmj`> :)
22:43:02 <haasn> this is why you use types!
22:43:05 <dmj`> forM_ listId $ assign mailChimpListId
22:43:08 <haasn> newtype APIKey = API Text
22:44:01 <dmj`> True, but if serialized wouldn't it suck up more space on disk and therefore RAM?
22:44:17 <dmj`> oh crap newtype is just for compile time, forgot
22:44:34 <haasn> depends on your Serializable instance, most likely
22:46:10 <dmj`> I guess my priorities are wrong, correctness should come before perf
22:46:47 <erisco> startling, how do I get the IO (Maybe a) value into the MaybeT monad?
22:47:23 <startling> :t MaybeT
22:47:24 <lambdabot> Not in scope: data constructor `MaybeT'
22:47:38 <dmj`> :t lift
22:47:39 <lambdabot> (Monad m, MonadTrans t) => m a -> t m a
22:47:40 <no-n> bad lambdabot!
22:47:50 <startling> MaybeT :: m (Maybe a) -> MaybeT m a
22:47:58 <startling> dmj`: lift isn't the right thing
22:49:51 <erisco> startling, ah okay, so I just use the constructor
22:49:53 <erisco> thanks
22:49:58 <startling> erisco: right.
22:50:13 <dmj`> :t liftIO $ return Nothing :: MaybeT IO (Maybe Int)
22:50:14 <lambdabot>     Not in scope: type constructor or class `MaybeT'
22:50:14 <lambdabot>     Perhaps you meant `Maybe' (imported from Data.Maybe)
22:50:38 <dmj`> startling: why not lift?
22:50:49 <dmj`> just curious
22:50:54 <joelteon> is there a way to make ghci tell me what an associated type is instantiated to for some type?
22:51:03 <startling> dmj`, lift :: m (Maybe a) -> MaybeT m (Maybe a)
22:51:15 <erisco> dmj`, because 'a' will still be some Maybe type
22:53:09 <erisco> using MaybeT everywhere is a bit noisy
22:54:50 <EponymicCycloid> Hello. Why am I getting this? "Not in scope: type constructor or class `Int64'"
22:55:01 <EponymicCycloid> For, for example, "x = 5 :: Int64
22:55:03 <EponymicCycloid> "
22:55:22 <Axman6> EponymicCycloid: have you imported Data.Int?
22:55:53 <EponymicCycloid> D'oh. I'm tired and imported Data.Char for some reason
22:55:59 <EponymicCycloid> Thanks haha
22:56:13 <dmj`> startling: oh I see
22:56:27 <Axman6> I was going to say Data.Word initially, so you're not alone :P
22:58:25 <EponymicCycloid> Where do I import Foldl' from?
22:58:32 <dmj`> data.list
22:58:40 <startling> erisco: ideally you should only be using it in a handful of places, but it can be a pain when working with other peoples' code.
23:00:06 <erisco> most operations return IO (Maybe a) ... I guess it would have been better if the library already used MaybeT
23:01:10 <startling> well, then people who wanted IO (Maybe a) would need a runMaybeT everywhere. :<
23:01:43 <erisco> I don't see how that would be useful to have... at least in context of ghcjs-dom
23:08:41 * startling shrugs
23:10:46 * hackagebot tianbar 0.3.4.1 - A desktop bar based on WebKit  http://hackage.haskell.org/package/tianbar-0.3.4.1 (AlexeyKotlyarov)
23:13:50 <gamegoblin> Do any of you guys use Control.Arrow?
23:14:12 <startling> It's not very popular.
23:14:18 <startling> :t (&&&) -- this is sometimes useful
23:14:19 <lambdabot> Arrow a => a b c -> a b c' -> a b (c, c')
23:14:33 <startling> + hakyll uses it pretty extensively iirc
23:15:13 <dmj`> gamegoblin: I do, I like it
23:15:22 <dmj`> > first (+1) (1,2)
23:15:23 <lambdabot>  (2,2)
23:16:22 <startling> well, does anyone use the non-(->) instances?
23:23:45 <shachaf> If you only ever use an abstraction in one concrete way, it might not be a very useful abstraction.
23:24:11 <startling> ^
23:30:31 <bluepenguin> you use the abstraction to feel like a better programmer, there's no better procrastination than refactoring code without a purpose
23:31:05 <erisco> onclick callback must be of type (a -> ()), but reactive-banana seems to require (a -> IO ()) for its event handlers... how can I make this work?
23:33:17 <Platz> are there concrete versions of Arrow for (->) that aren't in Arrow?
23:33:34 <Platz> or just roll your own
23:42:08 <iduhetonas> Is a Map from Data.Map a good solution for *lots* of *fast* insertions and removals of elements in a (k,v) pair?
23:43:07 <startling> Platz, I think Arrow was originally intended for parsers.
23:51:56 <erisco> is it possible to IO () -> () ?
23:52:13 <joelteon> no
23:52:54 <erisco> I must be missing something =\
23:53:58 <erisco> I have to come up with the type 'ReaderT a IO ()' which means (I think), I have to make a function of type 'a -> ()'
23:54:28 <erisco> but how do I do any side-effects?
23:54:40 <startling> erisco: const ()
23:54:55 <startling> @unmtl ReaderT a IO ()
23:54:55 <lambdabot> a -> IO ()
23:54:59 <startling> erisco: ^
23:55:11 <erisco> I don' tknow what that means
23:55:36 <startling> ReaderT a IO () is a -> IO ().
23:56:00 <startling> re: "< erisco> is it possible to IO () -> () ?" -- yes, "const ()".
23:56:15 <erisco> :t reader
23:56:15 <lambdabot> MonadReader r m => (r -> a) -> m a
23:56:21 <startling> :t ReaderT
23:56:22 <lambdabot> (r -> m a) -> ReaderT r m a
23:56:25 <erisco> ahh
23:56:36 <haasn> :t runReaderT `asAppliedTo` (undefined :: ReaderT a IO ())
23:56:37 <lambdabot> ReaderT r IO () -> r -> IO ()
23:56:47 <startling> erisco, "reader" just lifts pure functions into ReaderT
23:57:19 <erisco> the generated docs do not seem to say what the constructors do
23:57:21 <erisco> so I did not know
23:57:42 <startling> erisco: they can be hard to read -- they're presented the same way the source code presents them.
23:59:09 <erisco> cannot find Control.Event.Handler ...
23:59:25 <erisco> reactive-banana-0.8.0.0 is installed
23:59:51 <MP2E> best package name ever
