00:00:21 <mirpa> zomg: esperanto is quite simple
00:00:46 * hackagebot ddc-core-llvm 0.4.1.1 - Disciplined Disciple Compiler LLVM code generator.  http://hackage.haskell.org/package/ddc-core-llvm-0.4.1.1 (BenLippmeier)
00:00:48 * hackagebot ddc-core-flow 0.4.1.1 - Disciplined Disciple Compiler data flow compiler.  http://hackage.haskell.org/package/ddc-core-flow-0.4.1.1 (BenLippmeier)
00:00:50 * hackagebot ddc-core-tetra 0.4.1.1 - Disciplined Disciple Compiler intermediate language.  http://hackage.haskell.org/package/ddc-core-tetra-0.4.1.1 (BenLippmeier)
00:00:52 * hackagebot ddc-source-tetra 0.4.1.1 - Disciplined Disciple Compiler source language.  http://hackage.haskell.org/package/ddc-source-tetra-0.4.1.1 (BenLippmeier)
00:00:54 * hackagebot ddc-build 0.4.1.1 - Disciplined Disciple Compiler build framework.  http://hackage.haskell.org/package/ddc-build-0.4.1.1 (BenLippmeier)
00:05:44 <etqqkoiflwhb> What would be a good to learn haskell, coming from ruby?
00:05:48 <etqqkoiflwhb> good book*
00:05:56 * hackagebot ddc-interface 0.4.1.1 - Disciplined Disciple Compiler user interface support.  http://hackage.haskell.org/package/ddc-interface-0.4.1.1 (BenLippmeier)
00:05:58 * hackagebot ddc-driver 0.4.1.1 - Disciplined Disciple Compiler top-level driver.  http://hackage.haskell.org/package/ddc-driver-0.4.1.1 (BenLippmeier)
00:06:00 * hackagebot ddc-code 0.4.1.1 - Disciplined Disciple Compiler base libraries.  http://hackage.haskell.org/package/ddc-code-0.4.1.1 (BenLippmeier)
00:06:01 <ChongLi> LYAH
00:06:02 * hackagebot ddc-tools 0.4.1.1 - Disciplined Disciple Compiler command line tools.  http://hackage.haskell.org/package/ddc-tools-0.4.1.1 (BenLippmeier)
00:06:20 <ChongLi> @where lyah
00:06:20 <lambdabot> http://www.learnyouahaskell.com/
00:06:34 <etqqkoiflwhb> ChongLi: Isn't LYAH aimed at beginner programmers?
00:06:39 <ChongLi> no
00:07:12 <ChongLi> though to be fair, Haskell will make you feel like a beginner programmer no matter which book you use
00:07:23 <etqqkoiflwhb> oh
00:08:11 <etqqkoiflwhb> I was looking for a book with fairly complicated example, especially those with a focus on thinking in Haskell, just like 'Thinking in C++'
00:08:18 <etqqkoiflwhb> examples*
00:08:46 <andkore> How much do you know about Haskell?
00:09:16 <zomg> Real World Haskell is another
00:09:30 <etqqkoiflwhb> little, but i'm familiar with the concepts of pattern matching, currying etc and for most part, with a bit of effort, I can understand the code
00:09:35 <etqqkoiflwhb> except places which involve IO
00:09:51 <andkore> LYAH will be useful then.
00:10:05 <andkore> You could skip some of the first chapters if you really want to.
00:10:13 * hackagebot ddc-war 0.4.1.1 - Disciplined Disciple Compiler test driver and buildbot.  http://hackage.haskell.org/package/ddc-war-0.4.1.1 (BenLippmeier)
00:10:13 * hackagebot hspec2 0.1.0 - Alpha version of Hspec 2.0  http://hackage.haskell.org/package/hspec2-0.1.0 (SimonHengel)
00:10:20 <zomg> Yeah LYAH is pretty good for all that and you can look at RWH for some more concrete examples and such
00:10:28 <etqqkoiflwhb> ok
00:10:28 <mirpa> etqqkoiflwhb: try to solve Euler project with Haskell - that could be good start
00:11:01 <etqqkoiflwhb> yea, thats a good idea, what should the be next step, after LYAH, I was looking to use haskell for atleast a few toy projects
00:12:20 <zomg> you could probably start hacking away at stuff while reading LYAH and then it's really just a matter of googling (and/or asking here) about topics you get stuck on
00:12:33 <zomg> there's some good stuff on wikibooks iirc about a variety of haskell topics
00:12:39 <Fuuzetsu> mirpa: Euler is terrible for learning a language and you should feel bad for recommending it as such.
00:13:13 <mirpa> Fuuzetsu: I don't
00:13:19 <Fuuzetsu> You should!
00:13:26 <mirpa> Fuuzetsu: I don't :-)
00:13:37 <Fuuzetsu> It will haunt you eventually.
00:14:50 <etqqkoiflwhb_> Fuuzetsu: If not Euler, what els
00:15:00 <n4l> Fuuzetsu: why is Euler bad for learning a new language?
00:15:29 <Fuuzetsu> etqqkoiflwhb: Writing some actual programs rather than trying to solve 1-10 line number theory problems;
00:16:02 <milfjord> etqqkoiflwhb_: if you just want random problems, look at http://www.spoj.com/
00:16:18 <Fuuzetsu> n4l: because it's not about programming but solving (mostly) number theory problems. You solve the first 5 or 10 and you get stuck and you haven't learned much of what the language is about at all.
00:16:21 <mirpa> Fuuzetsu: it will teach you something about time/space complexity of Haskell programs
00:16:23 <Fuuzetsu> @where 99 haskell problems
00:16:23 <lambdabot> http://www.haskell.org/haskellwiki/H-99:_Ninety-Nine_Haskell_Problems
00:16:40 <milfjord> mirpa: I doubt that
00:16:49 <milfjord> because it didn't teach me
00:17:01 <mirpa> milfjord: It did for me
00:17:03 <etqqkoiflwhb_> milfjord: spoj is algorithmic, for solving challenges, I like building, one idea I add was understand the source of xmonad
00:17:24 <Fuuzetsu> mirpa: No, it might teach you that your approach to the problem was good or bad, the language won't have that much to do with the problem. This is why there's ‘pen and paper’ category on Euler too ;)
00:17:42 <milfjord> mirpa: maybe you just did it wrong
00:18:21 <mirpa> Fuuzetsu: it allowed me to appreciate ghci so I was able to derive some vital info for my solution
00:18:29 <milfjord> I solved my euler problems by writing a quick program and letting it run for a few days
00:18:57 <mirpa> it should run withing ~1 minute
00:19:04 <mirpa> *within
00:19:50 <milfjord> only if you put thought into it
00:20:16 <Fuuzetsu> mirpa: OK, you got to play with GHCi but you would if you were writing anything else as well. Writing some actual programs is of much more benefit than writing 5 lines in a specific domain letting it run for 3 days (Haskell must be slow!). After all, pretty much all problems on Euler can be solved with Double and []/Trees if you know the method. It won't push you to actually use any Haskell-specific features.
00:21:18 <mirpa> Fuuzetsu: I disagree with you and I will not argue with you anymore.
00:21:20 <Fuuzetsu> Isn't the idea here to learn Haskell rather than to learn to solve numerical problems? Don't get me wrong, Euler is great for that, it's just not a good place to go and learn about your language
00:21:44 <Fuuzetsu> mirpa: If you're not going to argue then don't start to do so to begin with.
00:23:19 <zomg> I kinda agree with Fuuzetsu about Euler
00:23:35 <zomg> I'm not great at solving that sorta problems and every time I've attempted to solve Euler stuff, I get stuck because of that
00:23:41 <zomg> not because I can't use the language properly =)
00:24:14 <Fuuzetsu> Oh, Euler might be great if you're learning a language specifically designed for such tasks, such as APL or something.
00:25:07 <chirpsalot> Fuuzetsu: that said if you want to do an Euler problem it wouldn't hurt to do it in a new language either.
00:26:10 <Fuuzetsu> chirpsalot: I agree. I simply disagree with doing Euler for the sake of learning a new language.
00:26:42 <chirpsalot> I'd agree it's not really for that. It can still be a good exercise, but definitely not the main thing you should focus on.
00:28:14 <chirpsalot> I mean, a lot of people have troubles finding stuff to do once they've sort of worked through the syntax... So it's better than nothing.
00:37:36 <etqqkoiflwhb_> I'll give LYAH a fair try for a few days, thanks for the inputs everyone
00:38:00 <Fuuzetsu> Good luck.
00:38:35 <andkore> I'm a firm believer in working on things that you have a practical interest in
00:39:11 <andkore> If you're going to write a program, you might as well write one that does something useful
00:39:38 <Fuuzetsu> I second that notion, working on things you use or want to use is the best motivation.
00:39:46 <erisco> fmap = (>>^) so why does Arrow not require Functor?
00:40:26 <Fuuzetsu> ‘x >>^ f = x >>> arr f’, no?
00:40:32 <jle`> erisco: that's only the case for the (-> a) functor
00:40:39 <jle`> in any case Arrow and Functor are different kinds
00:40:44 <jle`> so they aren't quite interchangeable things
00:40:52 <jle`> Arrows all take two type inputs, functors only take one
00:41:09 <etqqkoiflwhb_> andkore: yep, agree on that
00:42:22 <jle`> erisco: however, Category + Applicative is enough to give you Arrow....I think....or enough to give you (>>^) at least
00:42:23 <erisco> ah sorry fmap = (^<<)  I don't see why it is only for (-> a) though I do agree the kinds are different
00:43:34 <erisco> ie if you have Arrow you can just use ^<< as your fmap definition
00:43:35 <jle`> erisco: it doesn't make sense for Arrow to require Functor because they are different kinds...how would you even write that constraint?
00:43:51 <erisco> yeah I agree the kinds are different. I did not consider that
00:44:12 <jle`> i think all Arrow a's are functors
00:44:22 <jle`> as in having an Arrow a gives you a free functor instance
00:45:04 <jle`> because using >>^ as an fmap satisfies the functor laws
00:45:34 <jle`> but superclass/requirements isn't necessarily a property of what can implement what, it is more a mathematical thing.
00:46:33 <jle`> but i do see that it might be convenient so that you can use Functor combinators without requiring a Functor constraint.  but mathematically those two aren't really related enough to justify them as requiring eachother.
00:46:58 <jle`> erisco: you're right, i was wrong with it only being for the (-> a) functor
00:47:50 <jle`> hm. i would not mind having a free pure with Arrow.
00:48:00 <jle`> but yeah
00:53:34 <jle`> :| the more i think about it the more it would be nice
00:54:07 <jle`> all Arrows are at least Pointed
00:54:37 <jle`> why should I have to also specify a Pointed constraint
00:54:52 <jle`> i guess the main thing is because then you have to write a Pointed instance
00:54:56 <jle`> every time you write an Arrow instance
00:55:03 <jle`> and that's just unnecessary boilerplate
00:55:38 <jle`> same for Functor presumably
00:59:53 <BasDirks1home> Wouldn't it make sense for pack/unpack to be a Class?
01:10:31 <Ayadew> I'm a C# dev using visual studio a lot, is there a Haskell IDE around that i'd feel comfortable with
01:12:02 <aristid> Ayadew: perhaps eclipsefp?
01:14:06 <aristid> BasDirks1home: http://hackage.haskell.org/package/lens-4.0.5/docs/Data-ByteString-Lens.html
01:14:13 <Ayadew> aristid ok ill try thanks
01:14:21 <veryrandomname> Is there any shortest path function for grids, i.e. pathfinding in haskell? I found http://hackage.haskell.org/package/grid-7.6.1 but it doesn't allow for nodes to be blocked
01:28:38 <Cale> veryrandomname: I wrote a little package called astar you could probably use
01:29:12 <Cale> http://hackage.haskell.org/package/astar
01:38:56 <jle`> Cale: Cale is our real name?
01:38:58 <jle`> *your
01:39:08 <Cale> jle`: yes
01:39:26 <johnw> i've used astar
01:39:37 <jle`> ah it is not that uncommon of a name
01:39:40 <johnw> but I had to change it to run over a monad
01:39:41 <jle`> according to wolfram alpha
01:39:49 <johnw> (for my uses)
01:40:15 <Cale> johnw: aStarM wasn't enough?
01:40:25 <johnw> no, it was too inefficient
01:40:33 <Cale> ah, okay
01:41:13 <johnw> I changed it to use IntMaps, and a few other things: https://github.com/ledger/ledger4/blob/master/commodities/Ledger/Commodity/History.hs#L55
01:41:40 <johnw> i wanted to reduce it from calculating unnecessarily
01:44:49 <ion> jle: Yes, Cale is our real name.
01:45:04 <ion> but johnw had to change it to run over a monad.
01:45:16 <jle`> what did that monad ever do to you
01:45:19 <jle`> :(
01:45:28 <johnw> it incited people to write tutorials about it
01:45:45 <jle`> hm. sounds fair enough
01:45:49 <jle`> justice served.
01:45:53 <veryrandomname> Cale: thanks! I will try astar!
01:47:10 <ion> A* is the algorithm you’ll want to look at first for pathfinding in general.
01:48:58 <johnw> A* is Dijkstra's Shortest Path + heuristics
01:49:13 <johnw> if you don't have a heuristic, you don't need A*< just dsp
01:49:40 <jle`> you mean i shouldn't use my dfs
01:49:55 <jle`> on my cyclic graphs
01:50:13 <jle`> ?
01:50:13 <johnw> it's certainly not as efficient
01:50:22 <johnw> but there may be data sets for which it's appropriate
01:51:04 <jle`> joking, but point noted.
01:52:39 <veryrandomname> I certainly need A*, I want to write a rougelike
01:53:13 <jle`> you have a very handy heuristic then
01:53:57 <aristid> namely?
01:54:29 <veryrandomname> Cale: what kind of Ordering do my nodes need for you astar package?
01:54:50 <Cale> veryrandomname: any total ordering will do
01:54:55 <veryrandomname> fine
01:54:59 <jle`> aristid: shortest direct path?
01:55:02 <Cale> (It just needs to be a valid instance of Ord)
01:55:27 <jle`> taxicab or euclidean distance works.
01:55:45 <aristid> jle`: roguelikes usually have the direct paths being shortest?
01:55:58 <jle`> well it's the heuristic
01:56:06 <jle`> "better-ish"
01:56:19 <milfjord> |x1-x2|+|y1-y2|
01:57:10 <aristid> milfjord: that's manhattan distance, right?
01:57:28 <milfjord> yes
01:57:34 <milfjord> any more names for it? :-)
01:57:39 <Qfwfq> There's an infinite loop in this definition of kmeans. I can't spot it, is it obvious to anyone here? http://lpaste.net/100914
01:57:57 <jle`> rectilinear :)
01:58:05 <jle`> oh yes and l1 norm
01:58:11 <jle`> from my num analysis class
01:58:26 <veryrandomname> I tried to understand A* so often, I still don't really get why its optimal, or why dijkstra is optimal. :P
01:58:47 <jle`> veryrandomname: one thing you can do is manually perform it on a simple graph
01:58:57 <jle`> it just sort of 'makes sense'
01:59:09 <jle`> we proved it in a class once but if you do it by hand then it sort of clicks.
01:59:22 <veryrandomname> yeah I did that, felt that, revisited it, realised I didn't understand anything
01:59:29 <jle`> heh
01:59:50 <milfjord> do you understand why DFS finds the shortest path?
03:00:03 <veryrandomname> what is DFS?
03:00:14 <johnw> Depth First Search
03:00:18 <jle`> that trick you do on a maze where you always hug the right wall
03:00:22 <milfjord> er
03:00:27 <milfjord> I don't mean DFS!
03:00:29 <jle`> i got stuck in a cornfield maze once because there was a cycle :/
03:00:45 <veryrandomname> DFS just tries everything, of course its optimal
03:00:50 <milfjord> BFS is where you go in all directions simultanously, right?
03:00:56 <veryrandomname> also just tries everything
03:01:16 <milfjord> DFS doesn't find the shortest path, though
03:01:19 <jle`> DFS won't find the shortest path
03:01:49 <jle`> consider the graph A -> B, B -> C, C -> Goal, A -> Goal.
03:02:05 <veryrandomname> oh right, ok, if you stop after you found the goal, yeah
03:02:13 <veryrandomname> which makes sense
03:02:38 <milfjord> BFS tries all paths of length 1, then length 2, then length 3, ...
03:02:39 <aristid> and BFS will find the shortest path?
03:02:46 <aristid> ah yeah makes sense
03:03:21 <milfjord> the heuristic tries to create a directed BFS
03:04:07 <jle`> it helps if you think of the heuristic function as a "best possible case" function i think
03:04:29 <jle`> if you are going from point A to point B then the best possible case is a straight line, and no obstacles
03:05:26 <jle`> and so you want some way to expand the 'most likely to be best' node, based on some sort of weighted consideration of both its current cost so far, and the best possible time it could get to the end
03:06:12 <jle`> as it turns out, just adding them together makes sense
03:06:38 <jle`> because the sum of cost so far + best case time to rest is basically the total best-case time of that potential path
03:07:13 <jle`> so at every iteration you expand the node with the "best" best-case-total-time
03:07:25 <jle`> it's guarunteed to be optimal and the intuition checks out if you do the math
03:07:41 <jle`> i think you can prove it by contradiction
03:07:50 <veryrandomname> you can prove it directly
03:08:06 <jle`> even better :)
03:08:52 <jle`> A* only makes sense when you have a heuristic you can use as a meaningful 'best possible case'
03:09:04 <jle`> i mean
03:09:07 <jle`> okay you can use it otherwise
03:09:09 <kqr> if i have a data Person = Person { _name :: String, ownedCars :: [Car] }, and I have a FromJSON instance for Car, how can I create a FromJSON instance for Person?
03:09:25 <kqr> (this is using Data.Aeson)
03:09:30 <aristid> kqr: a very car-centric philosophy you have there
03:09:55 <veryrandomname> cost so far + heursitic is always lower than any other path, so even if you go some wrong directions, you'll end up trying the "best case" path at some point because of that
03:10:20 <jle`> veryrandomname: ah :)
03:11:24 <veryrandomname> but still doesn't feel easy in my mind. its just these weird language constructs/maths. not so much intuition
03:11:24 <kqr> aristid, for sure!
03:12:28 <jle`> that strange unnameable nagging feeling?
03:12:38 <veryrandomname> yeah something like that
03:12:40 <veryrandomname> I probably just need more time with mathematics
03:13:15 <jle`> the proof you offered did not seem very mathsy to me :)
03:14:30 <veryrandomname> oh its very near, you just need to ad math glue. the actual proof is like 4 lines of equations and a few sentences.
03:15:27 <aristid> kqr: you might want to consider making it a NonEmptyList though. for is it possible to be a true person without a car?
03:15:50 <veryrandomname> the glue is what makes it mathy, though^^
03:15:52 <nomeata> luite_: Hi. Is hdiff down?
03:16:58 <aristid> kqr: you could possibly just use the Generic aeson stuff, actually
03:17:13 <Qfwfq> [repost] There's an infinite loop in this definition of kmeans. I can't spot it, is it obvious to anyone here? http://lpaste.net/100914
03:17:30 <ion> Re: roguelikes, i have yet to see one with square tiles with diagonal movement moving the universe forward by √2 time units. It would be nice to see someone experiment with that. It would also be nice to see a roguelike with the grid warped to physically match both non-diagonal and diagonal movement taking the same amount of time.
03:18:26 <FireFly> What about simply using a hexagonal grid instead?
03:18:27 <veryrandomname> sounds cool. But I'll probably won't do that, I just have a few days
03:18:44 <aristid> kqr: otherwise, something like parseJSON (Object p) = Person <$> p .: "name" <*> p .: "cars"; parseJSON _ = mzero
03:18:55 <ion> firefly: Yes, it would be nice to see that in a roguelike, too.
03:19:05 <veryrandomname> I could actually do that
03:20:10 <luite_> nomeata: oh is it?
03:20:19 <kqr> aristid, i tried that, but it returns Nothing... maybe i should enable some sort of more detailed error reporting...
03:20:30 <nomeata> luite_: I get a friendly ngix error message
03:20:37 <luite_> nomeata: looks like the fastcgi daemon is acting up, one moment
03:20:47 <kqr> aristid, (the parser for Car works just fine, that much i know at least)
03:21:43 <joogi> what is a good example for a functor which is no monad?
03:22:05 <johnw> ZipList is one
03:23:33 <luite_> nomeata: hm, restarting didn't help, i'll investigate
03:24:12 <nomeata> luite_: thx
03:24:30 <luite_> tnx for reporting :)
03:24:42 <ion> joogi: Map, too
03:24:51 <nomeata> luite_: you’re welcome. it is a cruicial part of my Debian packaging workflow
03:24:51 <ion> johnw: Map is not Applicative either.
03:25:00 <ion> Uh. sorry
03:25:25 <milfjord> (a, )
03:25:29 <joogi> ah thanks :)
03:26:05 <johnw> milfjord: thanks.  It would need a Monoid constraint on a to be a Monad
03:26:46 <kqr> aristid, i'm stupid. using decodeEither was much better and suddenly what was wrong became apparent!
03:28:24 <luite_> nomeata: :) hmm, looks likes one of the hdds in the server is having trouble
03:29:45 <luite_> wonder if i should request a hdd swap or just a new server and copy everything over
03:40:25 * hackagebot numeric-tools 0.2.0.1 - Collection of numerical tools for integration, differentiation etc.  http://hackage.haskell.org/package/numeric-tools-0.2.0.1 (AlexeyKhudyakov)
03:56:20 <luite_> nomeata: ok i removed the faulty drive from the array, it should work again
03:57:04 <luite_> i should get a replacement server though :)
03:59:15 <veryrandomname> re: rougelike, how should I save the position of entities? "Entity Position", "Map Position Entity", both or something different?
04:09:20 <jle`> veryrandomname: depends on a lot of things about how the rest of your game is structured
04:11:38 <prinsen> Im trying to install GHC-7.8, but cabal install ghc-mtl fails
04:11:46 <prinsen> Ghc.hs:43:15: Not in scope: ‘GHC.gblock’
04:11:58 <prinsen> ghc-mtl-1.0.1.2
04:15:26 <veryrandomname> my game doesn't have much structure yet. I have a grid for the environment, I want to add a grid for the entities and I can draw these grids and call functions on them with some keyboard input
04:17:53 <veryrandomname> I think it would be cool if all state was in grids/map, but It's kind of ugly to move entities on these maps :P
04:18:39 <jle`> i'm assuming you don't have a realtime roguelike?
04:18:44 <veryrandomname> nope
04:19:27 <veryrandomname> turn based
04:19:57 <jle`> i think generally if you have things that don't move, then have a map or 2d vector
04:20:13 <jle`> if you have things that move then probably Entity Position is easier to move things around
04:20:19 <jle`> the only reason you would do it otherwise is for performance i think
04:20:48 <jle`> but performance is probably irrelevant here
04:21:01 <veryrandomname> performance is irrelevant
04:21:02 <jle`> unless you do complex AI perhaps
04:21:24 <jle`> if performance is relevant then consider a quadtree kind of structure
04:23:38 <osfameron> is there a good introductory article on quadtrees?
04:24:56 <jle`> in Haskell?
04:25:00 <jle`> or in general
04:26:19 <osfameron> in general (though in haskell no doubt interesting also)
04:26:44 <osfameron> I've previously attempted to read the Wikipedia article on it and it looked fascinating but confused me
04:27:29 <jle`> i don't think the idea of a quadtree is anyhting too deep and you probably could have thought of it yourself at some point :)
04:28:12 <jle`> the idea is that you start out with your entire map as one cell...and insert things. and as soon as your cell has more than a maximum amount of items in it, you break it into quarters and redistribute your items into each quarter
04:28:26 <jle`> and so now you have four cells, each hopefully with less than the maximum
04:28:57 <jle`> and you keep on adding items, putting them in the proper cell, and when any of those smaller cells exceeds the maximum item count, you break them up into smaller quarters
04:29:36 <jle`> it's a fast way of asking "what items are in *this* region?" --- you only have to query the cells that overlap with the region in question
04:30:35 <jle`> you recursively break up cells as soon as they exceed the capacity
04:30:45 <FireFly> It's essentially like a binary tree, but for two dimensions instead of one (and thus four branches on each level instead of two)
04:31:10 <osfameron> yeah.  I guess I probably just need to sit down and try to implement to understand it
04:35:31 * hackagebot sloane 1.5 - A command line interface to Sloane's On-Line Encyclopedia of Integer Sequences  http://hackage.haskell.org/package/sloane-1.5 (AndersClaesson)
04:40:28 <veryrandomname> I will try Entity Positon, though I'm not fully convinced.
04:40:56 <k_89> what'd be the type of a function that returns a lambda which takes no arguments
04:40:57 <k_89> ?
04:42:05 <Cale> k_89: Lambdas always take exactly one argument
04:42:15 <k_89> okay
04:42:26 <Cale> k_89: There's (\x y -> ...) but that's just syntax sugar for (\x -> (\y -> ...))
04:42:41 <k_89> that way, all haskell functions take one arg :p
04:42:48 <Cale> yes
04:42:49 <k_89> hence the partial function application thingy
04:42:58 <k_89> pretty cool, IMO
04:44:27 <FreeFull> You can have \_ -> ...
04:44:39 <FreeFull> Which takes one argument but ignores it
04:45:20 <jle`> we should have made lambda syntax (,\x -> ...)
04:45:23 <jle`> looks more like a lambda :)
04:45:33 <jle`> actually that is a bad idea.
04:45:43 <Ayadew> lol
04:46:06 <FreeFull> \ is good
04:46:14 <jle`> too much squinting required
04:46:21 <jle`> haskellers squint enough as it is
04:46:27 <k_89> ,\
04:46:34 <k_89> it looks better , definitely :P
04:47:03 <jle`> i guess we could also go agda and require the unicode λ
04:47:14 <k_89> hehe
04:47:16 <FreeFull> That'd be a pain
04:47:19 <pordan30> it's not just syntax, since in the simplest case, you have: if G, \x :: t1 |- \y :: t2 then G |- \x -> y :: t1 -> t2. so all abstractions have type t1 -> t2 for some t1, t2
04:47:35 <jle`> no, all you have to do is use the specialized emacs mode :P
04:47:48 <k_89>   /l
04:47:55 <k_89> heh
04:48:05 <FireFly> Or modify your X layout to have a modifier key for greek characters
04:48:32 <FireFly> I think \ is fine though, it works even if it isn't too λ-like
04:49:22 <mniip> [15:39:54] <FreeFull> You can have \_ -> ...
04:49:30 <nomeata> luite_: thx
04:49:32 <mniip> IMO you'd better use const $ ... in this case
04:49:47 <nomeata> luite_: have you considered asking haskell.org for hosting it, if hosting is a trouble for you?
04:51:13 <FreeFull> mniip: I'd use whichever is more convienient
04:51:24 <FreeFull> \_ -> is pretty clear about what it does
04:52:13 <luite_> nomeata: nah i need a server for development and some other sites that run in a vm. the old server had 16GB RAM and ran out of memory from time to time due to the VMs, I just activated a 32GB one and will just copy everything over and updated DNS in a few weeks
04:52:26 <mniip> const is clear enough too, and you can chain them like
04:52:30 <nomeata> luite_: allright
04:52:31 <mniip> const . const . const $ ...
04:52:46 <mniip> also that would be point-free
05:00:04 <jle`> mniip: he's saying that it depends on the context :)
05:05:34 * hackagebot hspec2 0.1.1 - Alpha version of Hspec 2.0  http://hackage.haskell.org/package/hspec2-0.1.1 (SimonHengel)
05:16:44 <prinsen> intRep = typeOf Int yields Not in scope: data constructor `Int'
05:17:24 <jle`> prinsen: Int is a type, not a data value
05:17:33 <jle`> or well, you could make one yourself
05:17:37 <prinsen> jle`: sure, but how do I write it?
05:17:39 <jle`> but that's not what you want
05:17:46 <jle`> what are you trying to do?
05:17:49 <jle`> :t typeOf
05:17:50 <lambdabot> Typeable a => a -> TypeRep
05:17:57 <jle`> ah
05:17:59 <prinsen> Im writing a Typeable instance for Pipes.Effect IO Int
05:18:08 <prinsen> that cant be derived automagically
05:18:39 <prinsen> until 7.8, but some of my packages won't compile under 7.8 so I have to write the instance myself
05:19:09 <jle`> > typeOf (undefined :: Int)
05:19:10 <lambdabot>  Int
05:19:16 <jle`> but that's probably not the best way
05:19:34 <jle`> :t asTypeOf
05:19:35 <lambdabot> a -> a -> a
05:19:48 <jle`> hm.
05:20:03 <jle`> http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Typeable.html
05:20:08 <jle`> suggests that doing undefined :: Int is ok
05:20:20 <prinsen> haha cool
05:20:23 <prinsen> will try it
05:22:26 <prinsen> jle`: works! Now i need a Typeable1 instance for Effect IO
05:25:37 * hackagebot jsaddle 0.1.1.3 - High level interface for webkit-javascriptcore  http://hackage.haskell.org/package/jsaddle-0.1.1.3 (HamishMackenzie)
05:42:28 <hellwolf> what is the difference between: foo :: forall a. (a -> a) -> (Char, Bool) foo :: (forall a. a -> a) -> (Char, Bool)
05:43:15 <milfjord> only one of them accepts show
05:43:27 <nomeata> hellwolf: "foo1 not" types, "foo2 not" does not
05:45:18 <hellwolf> hmm, foo f = (f 'c', f True) -- for this
05:45:25 <hellwolf> first one ok, the second one note
05:45:32 <hellwolf> sorry, reverse
05:45:36 <hellwolf> first one not ok
05:46:02 <hellwolf> Couldn't match type `Char' with `Bool'
05:46:04 <milfjord> yes
05:46:16 <milfjord> because in the first one the caller gets to choose 'a'
05:47:08 <hellwolf> who chooses the second one?
05:47:22 <hellwolf>  /in the
05:47:32 <milfjord> foo, for each invocation of the function
05:47:49 <milfjord> because in the second version f is polymorphic inside foo
05:48:20 <k00mi> hellwolf: http://www.haskell.org/haskellwiki/Rank-N_types
05:50:56 <k00mi> hellwolf: basically with normal polymorphism, foo gets passed a function that works for some specific a, while the second version expects a function that works for all a, foo can choose what a to use
05:51:04 <pordan30> when a type 't' is bound to 'a' in the first foo, '(a -> a) -> (Char, Bool)' is instantiated to '(t -> t) -> (Char, Bool)' ('forall a' quantifies over (a -> a) -> (Char, Bool)); there is no outer quantification in the second foo; it is a function with type (forall a . a -> a) -> (Char, Bool); it accepts functions of type (a -> a).
05:53:51 <kuribas> Is there a function to apply a Maybe value on an IO computation?
05:54:01 <kuribas> And return () if Nothing?
05:54:15 <prinsen> Im trying to write an Typeable1 instance, http://lpaste.net/100920, can someone give guidance?
05:54:59 <k00mi> kuribas: you can use for_ from Data.Foldable
05:55:50 <k00mi> for_ :: Maybe a -> (a -> IO b) -> IO ()
05:56:40 <kuribas> k00mi: nice, thanks!
05:57:20 <b0bbi10> hi, how would I get all the possible combinations of the three sequences? [a ++ b ++ c | a <- 'abc', b <- 'def', c <- 'ghi']
05:57:39 <b0bbi10> doesn't work and double quotes won't work either
05:58:23 <pranz> a:b:[c] and double quotes
05:58:36 <pranz> I think
05:58:37 <milfjord> > [ [a, b, c] | a <- "abc", b <- "def", c <- "ghi" ]
05:58:38 <lambdabot>  ["adg","adh","adi","aeg","aeh","aei","afg","afh","afi","bdg","bdh","bdi","be...
05:59:12 <milfjord> > sequence ["abc", "def", "ghi"]
05:59:13 <lambdabot>  ["adg","adh","adi","aeg","aeh","aei","afg","afh","afi","bdg","bdh","bdi","be...
05:59:42 <klrr_> anyone know what is the best way do do android dev using haskell? is it ajhc or is it ghc-android?
05:59:59 <hellwolf> k00mi: thanks, I get it now
06:00:26 <klrr_> also, in terms of difficulty, is it perhaps a bit hard for a first "app" project, or is it sane to do if you've never created an anroid app before?
06:00:28 <b0bbi10> thanks pranz & milfjord
06:00:54 <hellwolf> Can I define a function that returns anthing of typeclass A:    g :: (A a) => Int -> a
06:01:10 <pordan30> if you want combinations of the sequences, rather than combinations of elements of the sequences, you can map concat over Data.List.permutations ["abc", "def", "ghi"]
06:01:17 <hellwolf> like I would do in OOP language, returns an reference to an abstract interface
06:01:42 <milfjord> hellwolf: not easily
06:02:02 <jle`> :t read
06:02:03 <lambdabot> Read a => String -> a
06:03:11 <pranz> hellwolf: if you want subtyping, that can be done with existential quantification
06:03:13 <hellwolf> milfjord: what should I look to achieve this?
06:03:16 <pranz> hellwolf: but it can be a little messy
06:03:59 <milfjord> hellwolf: why do you need that?
06:04:00 <hellwolf> pranz: is there any example I can look up?
06:04:33 <pranz> hellwolf: heterogenous lists on the haskell wiki, there is an example which uses subtyping
06:04:45 <pranz> hellwolf: but I don't know if I understood exactly what you want
06:05:10 <pranz> you can make a typeclass A that requires a function (A a) => Int -> a to be implemented
06:06:02 <milfjord> but what good is a value of type 'a' then?
06:09:18 <hellwolf> let's say "g :: (A a) => Int -> a" is the only way I can get an type a value, and function "h :: (A a) => a -> ..." uses some functions of typeclass A. i'm just stuck with my OOP thinking of typeclass as an interface ..
06:10:18 <hellwolf> jle`: maybe I should look at how read is done
06:10:21 <milfjord> hellwolf: why doesn't h take an Int?
06:10:31 <milfjord> read is a class method
06:10:34 <milfjord> basically
06:12:32 <pordan30> you can write a class with a method g :: T a => Int -> a and another function h : T a => a -> ..., the class constraint on h says: forall types a, if a is an instance of T, then h has type a -> ...; i'm not sure you need existential types
06:13:34 <Kinokkory> excuse me, but do you know
06:13:41 <pranz> yeah if that is the sole thing he wants
06:14:03 <pranz> but then I would recommend to just have a datatype, if the (A a) just depends on an Int
06:15:05 <pordan30> right, but i'm commenting on his example ("let's say...", above)
06:15:16 <pordan30> his/her
06:15:43 * hackagebot network-conduit 1.0.3 - Stream socket data using conduits.  http://hackage.haskell.org/package/network-conduit-1.0.3 (MichaelSnoyman)
06:16:08 <no-n> @hoogle [a] -> [a]
06:16:09 <lambdabot> Prelude cycle :: [a] -> [a]
06:16:09 <lambdabot> Data.List cycle :: [a] -> [a]
06:16:09 <lambdabot> Prelude init :: [a] -> [a]
06:16:21 <no-n> @hoogle [a] -> [b]
06:16:21 <lambdabot> Prelude map :: (a -> b) -> [a] -> [b]
06:16:21 <lambdabot> Data.List map :: (a -> b) -> [a] -> [b]
06:16:21 <lambdabot> Prelude concatMap :: (a -> [b]) -> [a] -> [b]
06:16:45 <no-n> @hoogle a -> [a]
06:16:46 <lambdabot> Prelude repeat :: a -> [a]
06:16:46 <lambdabot> Data.List repeat :: a -> [a]
06:16:46 <lambdabot> Test.QuickCheck.Arbitrary shrinkNothing :: a -> [a]
06:16:58 <Kinokkory> Excuse me, but do you know if "type T (+) = Int + Int" is a proper code? My GHC 7.6.3 said "Unexpected type `+' where type variable expected", while the user's guide said it's correct http://www.haskell.org/ghc/docs/7.6.3/html/users_guide/data-type-extensions.html
06:17:25 <no-n> @hoogle a -> [b]
06:17:26 <lambdabot> Data.List unfoldr :: (b -> Maybe (a, b)) -> b -> [a]
06:17:26 <lambdabot> Prelude repeat :: a -> [a]
06:17:26 <lambdabot> Data.List repeat :: a -> [a]
06:18:31 <no-n> @hoogle a -> b -> [c]
06:18:32 <lambdabot> Data.List genericReplicate :: Integral i => i -> a -> [a]
06:18:32 <lambdabot> Prelude flip :: (a -> b -> c) -> b -> a -> c
06:18:32 <lambdabot> Data.Function flip :: (a -> b -> c) -> b -> a -> c
06:19:20 <pranz> no-n: you can start a query with lambdabot
06:19:26 <no-n> sorry
06:22:24 <klrr_> anyone got an idea why i get this errors when using pipes? https://gist.github.com/klrr/8da07c1ab190ac590b88
06:24:13 <kuribas> Kinokkory: Since it's an extension, did you enable the extension?  (With the -XEmptyDataDecls flag (or equivalent LANGUAGE pragma))
06:25:51 <Kinokkory> kuribas: with "{-# LANGUAGE TypeOperators, ScopedTypeVariables, EmptyDataDecls #-}", it doesn't work...
06:27:39 <Kinokkory> I would appreciate it if you know how "type T (+) = Int + Int" will work on your ghci with -XTypeOperators
06:28:59 <pranz> :t for
06:29:00 <lambdabot>     Not in scope: `for'
06:29:00 <lambdabot>     Perhaps you meant one of these:
06:29:01 <lambdabot>       `T.for' (imported from Data.Traversable),
06:29:09 <pranz> :t T.for
06:29:10 <lambdabot> (Applicative f, Traversable t) => t a -> (a -> f b) -> f (t b)
06:29:25 <pranz> klrr_: what is the type signature of 'for'?
06:30:45 <hellwolf> milfjord: basically i want to remove the duplicated code from http://pastebin.com/n5CGXpQT   .. if typeclass ClassB  allows definition of a toClassA function, and I would remove a lot of duplicated logic by providing default implementation of h1 h2 for all instances of ClassB
06:31:23 <hellwolf> trying not to writing repeative code
06:31:57 <jiajun> Could you tell me (5 :: Int) * (6.0 :: Double) is wrong but 5 * 6.0 is right?
06:32:47 <pordan30> you can give default implementations in the class declaration
06:32:49 <pranz> jiajun: yes
06:33:23 <pordan30> class T a where f :: a -> Int; f = const 1 for instance
06:34:42 <ion> jiajun: “5 * 6.0” is sugar for “fromInteger (5 :: Integer) * (fromRational (6 % 1))”. The fromRational dictates it’s a Fractional value. If you don’t specify a type it’ll default to Double.
06:35:00 <ion> jiajun: (*) :: Num a => a -> a -> a; both arguments must have the same type.
06:36:13 <k00mi> Kinokkory: I think there were some changes to type operators recently, but I would expect the users guide to be up to date
06:37:03 <jiajun> Thanks :)
06:38:12 <klrr_> pranz: its base type is a bit scary, not sure if it will help, but in this context it is a Monad m => Pipe b b m () -> (a -> Producer b m ()) -> Pipe a b m ()
06:38:46 <klrr_> pranz: well, omit b , just a's
06:42:44 <meditans> Hi, I'm experiencing problems when installing ihaskell: http://lpaste.net/100919
06:42:53 <meditans> they are related to mono-traversable, so I tried to bypass the problem with: cabal install ihaskell --constraint='mono-traversable < 0.2'
06:43:03 <meditans> but then I experience some problems because it searches a version of libzmq < 4.0, while I, following the installation guide, cloned from git a 4.* version
06:43:35 <k00mi> Kinokkory: second bullet point under Language http://www.haskell.org/ghc/docs/7.6.1/html/users_guide/release-7-6-1.html
06:45:04 <Kinokkory> k00mi: Oh, I see. Thanks a lot!
06:45:16 <k00mi> Kinokkory: here's a discussion about the change: http://haskell.1045720.n5.nabble.com/Type-operators-in-GHC-td5154978.html
06:50:02 <no-n> where can I find the source of instance Monad [] where...?
06:50:46 <notdan> no-n: GHC.Base
06:50:54 <notdan> no-n: http://hackage.haskell.org/package/base-4.6.0.1/docs/src/GHC-Base.html#Monad
06:51:32 <ion> no-on: To teach a man to fish: “:i Monad” or “:i []” in ghci
06:51:38 <no-n> thanks dan
06:51:44 <ion> no-n even
06:51:56 <no-n> oh, of course
06:51:59 <no-n> i was doing :info []
06:52:16 <ion> That works, too.
06:52:50 <no-n> so it does. but i looked in GHC.Types, stupidly
06:53:51 <Kinokkory> k00mi: I read the discussion. You really saved me. Thanks.
06:56:10 <k00mi> glad to help :-)
06:57:20 <nomeata> luite_: seems to be down again.
06:58:11 <no-n> instance Functor ((->) r) where -- I don't know how to read what's within the outermost pair of parentheses here
06:58:36 <milfjord> no-n: X -> Y is (->) X Y
06:58:37 <ion> no-n: (+) 4 5 = 4 + 5
06:58:48 <ion> no-n: (->) a b = a -> b
06:58:54 <no-n> ahh
06:59:34 <no-n> didn't know you could do that with ->
07:00:02 <ion> Functor (r ->) would be more readable but Haskell doesn’t support section sugar for types.
07:00:03 <merijn> no-n: So the "Functor f => f a" is the same as (using that functor instance) "(->) r a" is the same as "r -> a"
07:00:33 <luite_> nomeata: urk :/
07:00:40 <milfjord> :t length :: (->) ([] a) Int
07:00:41 <lambdabot> [a] -> Int
07:01:13 <no-n> heh :)
07:01:14 <ion> :t undefined :: (->) ([] a) Int
07:01:15 <lambdabot> [a] -> Int
07:01:40 <milfjord> :t zip :: ((->) ([] a)) ((->) ([] b) ([] ((,) a b)))
07:01:40 <lambdabot> (->) [a] ([b] -> [(a, b)])
07:02:07 <milfjord> :t zip :: (->) ([] a) ((->) ([] b) ([] ((,) a b)))
07:02:08 <lambdabot> [a] -> [b] -> [(a, b)]
07:02:10 <milfjord> interesting
07:02:14 <ion> no-n: This may or may not be helpful: http://heh.fi/haskell/functors/#function-instance
07:03:33 <luite_> nomeata: hmm, another cgit process hanging on IO
07:04:11 <milfjord> :t length :: ((->)) ([] a) Int
07:04:11 <lambdabot> (->) [a] Int
07:04:17 <milfjord> :t length :: ((->)) (([]) a) Int
07:04:18 <lambdabot> (->) [a] Int
07:05:24 <bennofs> :t length
07:05:24 <lambdabot> [a] -> Int
07:11:49 <luite_> nomeata: i'll reboot when the rsync of the data to the new server is done
07:12:27 <nomeata> luite_: thx
07:22:38 <kuribas> Is it just my impression that wxhaskell is still very low level in many places?
07:23:44 <kuribas> I mean stuff like graphicsContextCreate and graphicsContextDelete.
07:29:40 <merijn> kuribas: That impression is probably right
07:30:51 * hackagebot music-util 0.6 - Utility for developing the Music Suite.  http://hackage.haskell.org/package/music-util-0.6 (HansHoglund)
07:35:51 * hackagebot ltk 0.13.1.0 - Leksah tool kit  http://hackage.haskell.org/package/ltk-0.13.1.0 (HamishMackenzie)
07:35:53 * hackagebot leksah-server 0.13.1.0 - Metadata collection for leksah  http://hackage.haskell.org/package/leksah-server-0.13.1.0 (HamishMackenzie)
07:35:55 * hackagebot leksah 0.13.3.0 - Haskell IDE written in Haskell  http://hackage.haskell.org/package/leksah-0.13.3.0 (HamishMackenzie)
07:41:38 <no-n> <$> should be in Prelude imo
07:46:47 <absence> does anyone know how to test ghc 7.8 rc windows binaries? i tried using the cabal that came with haskell-platform and updated the path so that ghc --version says 7.8, but cabal install cabal-install seems to configure haskell platform's versions of mtl etc instead of downloading new versions, and fails
07:55:40 <absence> ah, 64-bit ghc does not like 32-bit gcc in path :)
07:56:29 <prinsen> I get module is not loaded: .. when importing a module in Hint, any idea why?
08:01:52 <nadirs> Hello all. I'm having a bit of trouble figuring out an issue inside ghci
08:02:01 <nadirs> I've added the following line in my .ghci:    `:def hoogle \x -> return $ ":!hoogle \"" ++ x ++ "\""`
08:02:39 <nadirs> If I run `:hoogle <something>` in a ghci session a get "hoogle: Wrong hoogle database version: found 4.2.23.0, expected 4.2.29.0"
08:03:15 <nadirs> I tried "unregister"ing and re-installing hoogle via ghc-pkg + cabal
08:04:14 <nadirs> Does anyone know where the local hoogle database (the one the error message refers to) might be located?
08:06:02 <nadirs> (on a side note, I did run `hoogle data` in order to "generate Hoogle databases")
08:07:42 <aspidites> #kivy
08:10:57 * hackagebot courier 0.1.0.11 - A message-passing library for simplifying network applications  http://hackage.haskell.org/package/courier-0.1.0.11 (PhilHargett)
08:13:22 <nadirs> I realised the issue is actually not related to ghci, since hoogle throws gives that error message in a normal shell session too
08:25:20 <hc> what's the recommended way to write line oriented attoparsec parsers?
08:25:31 <hc> i.e., i have a file that i want to parse line by line
08:25:52 <hc> sepBy1' ... endOfLine is probably not a good idea?
08:29:19 <prinsen> How the hell do I use set in Hint, there is some strange types. I want to add a language extension, http://hackage.haskell.org/package/hint-0.3.3.7/docs/Language-Haskell-Interpreter.html
08:46:01 * hackagebot network-simple-tls 0.2.1 - Simple interface to TLS secured network sockets.  http://hackage.haskell.org/package/network-simple-tls-0.2.1 (RenzoCarbonara)
09:19:42 <troydm> :t Just . (>)
09:19:43 <lambdabot> Ord a => a -> Maybe (a -> Bool)
09:20:01 <troydm> how do i get (a -> a -> Maybe Bool) instead of this?
09:20:24 <Umschwung> :t Just (>)
09:20:24 <lambdabot> Ord a => Maybe (a -> a -> Bool)
09:20:37 <troydm> ohh right, silly me :)
09:20:49 <Umschwung> troydm: No, sorry, that's not right.
09:21:23 <Umschwung> troydm: You want a function that compares two Ord a values and returns a Maybe a?
09:22:23 <troydm> Umschwung: nah, was just curios about . composition
09:22:46 <troydm> i tend to have a habit messing up code with explicit .'s
09:23:11 <troydm> to the point when nothing makes sense and compiler refuses to compile it
09:23:41 <dhrosa> Just .: (>)
09:23:43 <dhrosa> oops
09:23:47 <dhrosa> :t Just .: (>)
09:23:48 <lambdabot>     Not in scope: `.:'
09:23:48 <lambdabot>     Perhaps you meant one of these:
09:23:48 <lambdabot>       `.' (imported from Data.Function),
09:24:49 <Umschwung> :t ((.) . (.))
09:24:50 <lambdabot> (b -> c) -> (a -> a1 -> b) -> a -> a1 -> c
09:25:08 <troydm> :t Just $ (>)
09:25:09 <lambdabot> Ord a => Maybe (a -> a -> Bool)
09:25:36 <troydm> hmm how do i get a -> a -> Maybe Bool signature
09:25:59 <Umschwung> troydm: Well, you'd need to wrap the Ordering returned in a Maybe.
09:26:06 * hackagebot snap-utils 0.1.0 - Snap Framework utility funtions.  http://hackage.haskell.org/package/snap-utils-0.1.0 (LukeHoersten)
09:26:10 <dhrosa> @pl \x y -> Just (x > y)
09:26:11 <lambdabot> (Just .) . (>)
09:27:12 <troydm> :t (Just .) . (>)
09:27:13 <lambdabot> Ord a => a -> a -> Maybe Bool
09:27:13 <Umschwung> :t (\x y -> Just $ x < y)
09:27:14 <lambdabot> Ord a => a -> a -> Maybe Bool
09:27:17 <troydm> ahh cool
09:27:29 <Umschwung> troydm: Hah, yours is cooler.
09:32:22 <Umschwung> :t (Just .)
09:32:23 <lambdabot> (a -> b) -> a -> Maybe b
09:32:37 <dhrosa> troydm: Data.Composition has a (.:) operator that  makes the above cleaner
09:32:47 <dhrosa> then you can write it as Just .: (>)
09:33:00 <dhrosa> or you can define it yourself trivially
09:33:06 <Umschwung> dhrosa: Sweet.
09:33:08 <troydm> dhrosa: ahh, cool didn't knew about that operator
09:33:13 <dhrosa> composes a binary function  with a unary function to form another binary function
09:33:19 <troydm> :t Just :. (>)
09:33:20 <lambdabot>     Not in scope: data constructor `:.'
09:33:20 <lambdabot>     Perhaps you meant one of these:
09:33:20 <lambdabot>       `Seq.:>' (imported from Data.Sequence),
09:33:26 <troydm> :t Just . (>)
09:33:27 <dhrosa> lambdabot doesn't know about it though
09:33:27 <lambdabot> Ord a => a -> Maybe (a -> Bool)
09:33:30 <troydm> :t Just .: (>)
09:33:31 <lambdabot>     Not in scope: `.:'
09:33:31 <lambdabot>     Perhaps you meant one of these:
09:33:31 <lambdabot>       `.' (imported from Data.Function),
09:34:13 <Umschwung> :t ((.) . (.)) Just (<)
09:34:14 <lambdabot> Ord a => a -> a -> Maybe Bool
09:34:43 <Umschwung> dhrosa: So the (.:) operator is equivalent to the "boobs operator", then? :P
09:34:58 <dhrosa> yes
09:36:02 <thrakcat1ack> :t maybe
09:36:03 <lambdabot> b -> (a -> b) -> Maybe a -> b
09:36:21 <Umschwung> I wonder why those modules are located under Data instead of Control, though.
09:38:17 <Umschwung> Then again, a function by itself isn't really a mechanism for controlling program flow.
09:43:48 <merijn> Umschwung: The entire Data/Control distinction in the modules is rather arbitrary, I wouldn't put too much significance on their name
09:49:06 <troydm> let's say i have some list defined as a = []
09:49:21 <troydm> well to be precise a a =[somefun a]
09:49:33 <troydm> will this somefun be called on startup ?
09:49:45 <merijn> troydm: No
09:49:52 <troydm> or will it be called each time some function needs that list?
09:49:53 <merijn> troydm: In fact, it may never be called at all
09:50:14 <Umschwung> troydm: Only necessary computations are performed, so basically, everything that falls into main.
09:50:19 <merijn> troydm: Assuming the result is monomorphic, it will be called only once, and only when required
09:50:44 <troydm> ahh okey let's hope it works that way
09:51:21 <merijn> troydm: monomorphic meaning that it has one concrete type, i.e. "foo :: Num a => [a]" <- not monomorphic, "foo :: [Int]" <- monomorphic
09:52:48 <Umschwung> :t (<*>)
09:52:49 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
09:53:01 <Umschwung> :t ((.) . (.))
09:53:02 <lambdabot> (b -> c) -> (a -> a1 -> b) -> a -> a1 -> c
09:53:39 <Umschwung> :t flip ((.) . (.))
09:53:40 <lambdabot> (a -> a1 -> b) -> (b -> c) -> a -> a1 -> c
09:54:40 <kqr> shouldn't { x <- mapM f xs; let y = g <$> x; ... } be equivalent to { y <- g <$> mapM f xs; ... }?
09:56:06 <merijn> kqr: Yes
09:56:13 <merijn> Wait
09:56:14 <merijn> no
09:56:24 <thebnq> would need to be fmap f <$>, right?
09:56:30 <merijn> Yeah
09:56:48 <kqr> oh yeah i see
09:56:50 <merijn> kqr: The second example <$> maps over the monad that <- extracts from in the first
09:57:01 <kqr> yeah, just realised that
09:57:05 <troydm> merijn: ic, thx
09:57:55 <kqr> the type checker liked the new version much more!
09:57:57 <kqr> thanks
09:58:17 <kuribas> wxhaskell is hopelessly behind...
10:22:56 <no-n> is there a putChar for Word8?
10:25:43 <ClaudiusMaximus> no-n: you could wrap hPutBuf or something equally horrible
10:25:54 <no-n> hehe
10:28:02 <nadirs> I'm just wondering: is there a way to express a function like zip without explicit recursion? Like, using applicatives or arrows?
10:28:53 <magicman> > runZipList $ (+) <$> ZipList [1..4] <*> ZipList [5..8]
10:28:54 <lambdabot>  Not in scope: `runZipList'
10:28:54 <lambdabot>  Perhaps you meant `getZipList' (imported from Control.Applicative)
10:29:03 <magicman> > getZipList $ (+) <$> ZipList [1..4] <*> ZipList [5..8]
10:29:04 <lambdabot>  [6,8,10,12]
10:29:20 <nadirs> @ty getZipList
10:29:21 <lambdabot> ZipList a -> [a]
10:29:58 <no-n> @hoogle Int -> Char
10:29:58 <lambdabot> Data.Char chr :: Int -> Char
10:29:58 <lambdabot> Data.Char intToDigit :: Int -> Char
10:29:58 <lambdabot> Data.Text index :: Text -> Int -> Char
10:31:11 <nadirs> magicman: thanks, I'll go reading some ZipList docs :)
10:33:21 <merijn> The implementation of ZipList still uses explicit recursion
10:33:31 <merijn> nadirs: In the end you have to have explicit recursion *somewhere*
10:34:53 <magicman> Yeah. This is just a newtype wrapper with an Applicative instance. There's also -XParallelListComp, but that probably desugars into some explicit recursion as well. (and requires an extension)
10:34:56 <nadirs> merijn: I see. I was thinking maybe you could abstract the part "map on this list, and then, in parallel, map to this other list", without having to deconstruct the two lists
10:40:28 <nadirs> anyway ZipList does a nice work, since you can work with n-ary functions in a nice, applicative style
10:48:46 <carter> o/
10:50:54 <carter> is there no topic or my irc buggy?
10:51:11 <BasDirks_home> the latter
10:54:03 <carter> htesting
10:56:00 <carter> ok
10:56:01 <carter> hello
10:56:12 <carter> it works1
10:59:56 <beaky> hello
11:00:02 <beaky> i am building vector
11:00:04 <beaky> but i get an error
11:00:13 <beaky> ghc: panic! (the 'impossible' happened)
11:01:15 <beaky> what do i do
11:01:17 * hackagebot wai-predicates 0.2.1 - WAI request predicates  http://hackage.haskell.org/package/wai-predicates-0.2.1 (ToralfWittner)
11:01:25 <joelteon> beaky: first, give us the full error message :)
11:01:33 <joelteon> there are a lot of reasons GHC can panic
11:01:43 <joelteon> also we need to know the version of vector, the version of GHC, and what OS you're on
11:02:17 <beaky> http://lpaste.net/100923 here
11:02:42 <beaky> this is my system: Linux chickenpotpi 3.10.25+ #622 PREEMPT Fri Jan 3 18:41:00 GMT 2014 armv6l GNU/Linux
11:03:07 <beaky> Raspbian OS on the raspberry pi
11:03:12 <beaky> ARMv6 cpu
11:03:43 <joelteon> ok, you're gone beyond my realm of knowledge
11:03:43 <beaky> the thing is there is no ghci on the raspberry pi
11:04:31 <carter> beaky: oooo
11:04:37 <carter> beaky: you're using 7.6
11:04:37 <carter> use 7.8
11:04:55 <joelteon> beaky is using 7.4
11:05:27 <beaky> yeah the Glorious Glasgow Haskell Compiler version 7.4.1
11:05:38 <carter> well
11:05:39 <carter> yeah
11:05:42 <carter> that'd be why your'e sad
11:05:50 <beaky> :( i guess no haskell for me
11:06:08 <joelteon> maybe go with 7.6
11:06:12 * beaky packs his monads and lambdas away
11:06:18 * hackagebot purescript 0.4.5 - PureScript Programming Language Compiler  http://hackage.haskell.org/package/purescript-0.4.5 (PhilFreeman)
11:06:29 <carter> you can't build unpatched vector with no ghci
11:06:34 <carter> 7.8 has vector for stage1
11:06:42 <carter> you can patch vector to work on stage 1
11:06:46 <beaky> oh
11:06:59 <beaky> so i should build haskell from source?
11:07:03 <carter> yes
11:07:11 <carter> use your 7.4 to build 7.8
11:07:12 <carter> OOOO
11:07:19 <beaky> how do i do that
11:08:57 <carter> you read the building directions
11:09:02 <beaky> oh
11:09:07 <beaky> cant i just cabal install ghc
11:09:10 <carter> NOPE
11:09:33 <carter> beaky: ask bgamari or thoughtpolice  if they have an RPI 7.8 build lying around
11:09:55 <carter> building ghc from source on an RPI is time consuming i gather
11:09:59 <beaky> right
11:10:04 <beaky> building node.js took me a whole night
11:10:15 <bgamari> beaky, I think I might have something for you
11:10:16 <carter> also RPI is ARM6 .. with weird bits
11:10:18 <beaky> i think building haskell will take me a whole weekend
11:10:19 <bgamari> oh
11:10:21 <bgamari> perhaps not then
11:10:31 <bgamari> I have an armv7 image
11:10:32 <carter> bgamari: lets find out!
11:10:41 <carter> beaky: yeah.. rpi is weird
11:10:44 <bgamari> beaky, want to try it?
11:10:50 <bgamari> I can tar it up
11:10:52 <beaky> nope pi only likes armv6 :(
11:11:01 <Ayadew> people say that once you learn haskell youll be depressed with languages like C#.. so i dunno if i should learn it lol
11:11:25 <bgamari> sad
11:11:30 <beaky> Ayadew: yes learning haskell made me look at other programing lnaguages differnetly
11:11:45 <Ayadew> did it make you a better person
11:11:58 <beaky> it has made me a better programmer
11:11:59 * bgamari can still write embedded C without wanting to throw himself off the building
11:12:14 <beaky> who knows how long until embedded haskell comes along
11:12:14 <Ayadew> bgamari ok, thats great :P
11:12:17 <carter> Ayadew: no, it justs makes you realize how richer the ways to engineer are
11:12:24 <Ayadew> fine ill try then
11:12:26 <Ayadew> you haskell fanboys
11:12:27 <Ayadew> ;)
11:12:31 <carter> Ayadew: nope
11:12:53 <carter> Ayadew: bgamari, and to a lessor extent I, contribute to the compiler to help out our needs
11:13:06 <carter> its kinda cool that if you just put in the effort, you can get patches into ghc
11:13:15 <Ayadew> interesting
11:13:25 <beaky> you too can be a compiler wizard if you master haskell!
11:13:38 <Ayadew> ill just put on my robe and wizard hat
11:14:08 <iduhetonas> beaky: I'm trying to get embedded Haskell off of the ground!
11:14:31 <carter> iduhetonas: the EDSL approach
11:14:33 <bgamari> beaky, shepheb was trying to build an rpi image a few days ago
11:14:39 <carter> or a restricted haskel fragment?
11:16:15 <bgamari> iduhetonas, you've seen ivory?
11:16:19 * hackagebot wai-routing 0.4.1 - Declarative routing for WAI.  http://hackage.haskell.org/package/wai-routing-0.4.1 (ToralfWittner)
11:16:30 <Vei9> Hi, how can i update one field of huge record with Lens?
11:17:16 <iduhetonas> bgamari: Oh yes. I've been digging through their work this weekend.
11:17:42 <carter> bgamari: are you coming to HAC NY?
11:17:46 <carter> i can lend you a couch mebe
11:17:53 <carter> you should come to hac nyc
11:18:00 <carter> or reid
11:18:02 <carter> heck both of you!
11:18:18 <bgamari> iduhetonas, if you are interested in building a compiler
11:18:18 <bgamari> http://bgamari.github.io/posts/2014-03-06-compiling-ghc-7.8-on-arm.html
11:18:28 <bgamari> you'll probably want to have a look at that
11:18:40 <Vei9> So basically what i want is HugeRecord -> Stuff -> HugeRecord. In this function i want to just assign Staff to one field of HugeRecord without Manually reconstructing HugeRecord.
11:18:41 <bgamari> unfortunately things are still a little rough
11:18:50 <carter> Vei9: lenses
11:18:52 <bgamari> although it's mostly not GHC's fault
11:19:04 <Vei9> carter: Yes, how?
11:19:15 <carter> i'm terrible at lenese
11:19:20 <bgamari> carter, Thanks for the offer!
11:19:23 <bgamari> carter, I really don't know
11:19:23 <carter> but thats a great question to ask on #haskell-lens
11:19:27 <carter> bgamari: no pressure
11:19:36 <bgamari> carter, I'm trying to get a thesis proposal done so I can get out of Amherst
11:19:39 <carter> OK
11:19:40 <carter> yes
11:19:42 <carter> focus on that
11:19:48 <carter> bgamari: gtf out of grad school
11:19:50 <iduhetonas> bgamari: Awesome! Still a great kick-off point. Thanks a ton
11:19:51 <bgamari> heh
11:19:58 <bgamari> carter, that's the plan
11:20:11 <bgamari> I've enjoyed it, but it needs to end soon ;)
11:20:25 <carter> yes
11:20:27 <carter> well
11:20:31 <carter> congrats that its been positive
11:20:54 <iduhetonas> I'm the opposite. I'm super excited for grad school
11:21:03 <carter> bgamari: if my numerical haskell *program* of hacking shakes out over the next year, i'll probably wanna figure out how to post hoc get a phd
11:21:13 <carter> iduhetonas: grad school when it works out is amazing
11:21:16 <carter> but when it doesn't
11:21:18 <carter> its terrible
11:21:25 <carter> i kinda had ptsd the first tiem
11:21:40 <bgamari> carter, that's a good way to do it
11:21:49 <iduhetonas> carter: What'd you go for? Ph.D or MA?
11:21:51 <carter> phd
11:22:15 <iduhetonas> I don't blame you ;)
11:22:20 <iduhetonas> For feeling the ptsd
11:22:44 <carter> i had a verbally abusive advisor i was stuck with for a year
11:24:35 <iduhetonas> That's rough.
11:24:51 <iduhetonas> I'm going to a different country, so hopefully, if I have a verbally abusive advisor, I won't be able to understand :)
11:26:20 * hackagebot purescript 0.4.5.1 - PureScript Programming Language Compiler  http://hackage.haskell.org/package/purescript-0.4.5.1 (PhilFreeman)
11:29:30 <no-n> @hoogle hSetBuffering
11:29:31 <lambdabot> System.IO hSetBuffering :: Handle -> BufferMode -> IO ()
11:29:31 <lambdabot> GHC.IO.Handle hSetBuffering :: Handle -> BufferMode -> IO ()
11:33:08 <veryrandomname> I figured you people may know, were you guys able to pick up advanced mathematical skills even when studying computer science? Or how much mathematics is needet do code "cool" things?
11:35:32 <carter> veryrandomname: yes
11:35:34 <carter> :)
11:35:42 <carter> learning math is valuable
11:35:50 <carter> and its done both way
11:35:52 <carter> s
11:36:23 <veryrandomname> carter: you mean cs people do math and math people do cs?
11:36:29 <carter> they should :)
11:36:31 <carter> both
11:36:38 <carter> they're very complimentary areas
11:36:39 <veryrandomname> carter: sure, but to what extend?
11:36:53 <carter> as much as you have the cognitive budget for
11:36:54 <Chousuke_> CS pretty much is math
11:36:57 <carter> yes
11:37:04 <carter> and math is pretty much computation
11:37:20 <Chousuke_> programming is less math-y, but math is still useful
11:37:27 <carter> depends on the programs
11:37:35 <Chousuke_> well I guess.
11:39:37 <yac> veryrandomname: depends what you are coding. Actually most cs work requires only basic, rudimentary knowledge of math
11:39:55 <yac> s/cs/coding/
11:41:31 <carter> coding != CS, it just benefits from it
11:42:52 <veryrandomname> Say I wanted to do a lot of theoretical CS someday, would studying mathematics be better?
11:43:15 <carter> both
11:43:26 <carter> areyou in high school/
11:43:47 <Chousuke> mathematics supports pretty much any field of study.
11:44:11 <veryrandomname> carter: no I studied mathematics for one month and stopped because of depression
11:44:19 <yarou> lol
11:44:36 <Chousuke> maybe you picked the wrong sort of maths :P
11:45:16 <yarou> "theoretical CS" is a broad brush, i guess abstract algebra is something worth knowing though
11:45:49 <veryrandomname> Chousuke: What kind of math should I have chosen?
11:45:59 <Chousuke> I don't know
11:46:05 <Chousuke> not the sort that makes you depressed
11:46:25 <veryrandomname> its not clear if math really made me depressed or studying itself was the problem
11:47:24 <veryrandomname> I just wonder how much I miss out if I'm studying cs instead of mathematics, how limited I will be
11:47:57 <Chousuke> you won't miss much if you're actually interested in CS
11:48:48 <Chousuke> it's more that as you study CS, you will *have* to learn some maths to be able to understand some things.
11:49:33 <Chousuke> and you might find something in there that you want to know more about.
11:49:47 <veryrandomname> sounds good
11:50:18 <Chousuke> in general it's not really possible to decide beforehand what you want to learn, since there's way too much to ever learn it all
11:50:39 <Chousuke> so you'll have to pick a direction
11:51:22 * hackagebot monoid-extras 0.3.3.1 - Various extra monoid-related definitions and utilities  http://hackage.haskell.org/package/monoid-extras-0.3.3.1 (BrentYorgey)
11:51:38 <Chousuke> and even if you pick the wrong one (ie. find that you're not really that interested in the topics after all), learning anything is rarely a waste.
11:52:02 <carter> all of it
11:53:05 <veryrandomname> that sounds very positive! I like that ;)
11:53:48 <Chousuke> I'm pretty certain I'm never going to speak much swedish, but I suppose learning it at school has some positive effect on my ability to learn or discuss other languages
11:54:20 <beaky> im building ghc
11:54:26 <beaky> and its taking ages :(
11:54:39 <beaky> half an hour and im still at ./configure
11:54:55 <beaky> my cpu is an 700MHz armv6
11:55:16 <Chousuke> see you next year
11:55:21 <geekosaur> arm will take a while
11:55:32 <geekosaur> rpis are not known for their blazing speed
11:55:42 <carter> beaky: geekosaur  couldn't you build it in a QEMU VM?
11:55:50 <Chousuke> honestly, you'll save time setting up a cross-build environment
11:55:50 <yarou> haha
11:56:08 <veryrandomname> Chousuke: I always had a hard time learning stuff I didn't really want to learn. I got through a 3 year high school course of russia not knowing a 5 words :P
11:56:30 <veryrandomname> russian*, not russia
11:56:34 <Chousuke> heh
11:56:42 <Chousuke> I kind of have the same problem
11:57:56 <Chousuke> I've always liked English so learning it wasn't much of a problem but I just don't see much value in swedish.
11:58:09 <Chousuke> all the swedes I communicate with can speak English anyway :P
11:58:17 <veryrandomname> right
11:58:23 <Chousuke> and they're much better at it than I'm at Swedish
11:58:38 <beaky> the raspberry pi is blazing fast
11:58:43 <carter> lies
11:58:47 <carter> slower than my laptop
11:58:55 <carter> just get a beefy x86 server with many cores
11:59:03 <carter> then do a qemu vm?
11:59:39 <Chousuke> there should be instructions for setting up a crossbuild environment for the RPI.
11:59:47 <Chousuke> somewhere
12:00:05 <aristid> i think the raspberry pi is about as fast as a pentium II or so
12:00:13 <Chousuke> I set one up in a virtual machine but it was for FreeBSD
12:00:15 <aristid> remember the funny cartridges those came in? :D
12:00:30 <Chousuke> unfortunately FreeBSD on the rpi has terrible networking performance
12:01:21 <Hodapp> Chousuke: I'd love to tell you that it's better on Linux, but it's not
12:01:31 <Chousuke> Hodapp: it is, though.
12:01:39 <aristid> carter: btw got around to playing with haswell TSX yet?
12:01:47 <Hodapp> Chousuke: how? it still runs through their USB and uses tons of CPU
12:02:04 <carter> aristid: nope
12:02:05 <Chousuke> Hodapp: on FreeBSD my ping to the rpi was 10ms over ethernet.
12:02:08 <carter> no ones given me a new computer yet :)
12:02:19 <Hodapp> Chousuke: hummm, 0.5 msec for me, weird
12:02:20 <carter> Chousuke: coudl that be becaue of shitty drivers?
12:02:25 <Chousuke> carter: possibly.
12:02:26 <aristid> carter: i'm still a little angry that intel disabled TSX on my 4770K
12:02:34 <carter> aristid: which models have it?
12:02:38 <Chousuke> non-K ones
12:02:40 <aristid> carter: the non-K
12:02:51 <aristid> carter: the K are more expensive btw
12:02:52 <Hodapp> beaky: My Pi still performs a good bit lower on a lot of things than an old Power Mac G4 I've kept using; it's over a decade old and 400 MHz.
12:02:53 <Chousuke> I'm probably getting a non-K core i5
12:03:10 <Chousuke> just for VT-d and TSX
12:03:11 <Hodapp> Pi is usable for a lot of stuff and rather neat, but I'd hardly call it blazing fast.
12:03:16 <carter> vt-d?
12:03:24 <Chousuke> IOMMU stuff.
12:03:25 <carter> Hodapp: is the beagle board the fast one?
12:03:26 <aristid> Chousuke: why not a non-K i7? to save money?:)
12:03:32 <Hodapp> carter: dunno, maybe
12:03:36 <Chousuke> aristid: yeah.
12:04:03 * fryguybob is sad that TSX isn't in more models.
12:04:26 <Chousuke> carter: vt-d allows pci passthrough to a virtual machine... ie. I could give a windows VM full access to the GPU
12:04:30 <aristid> is it in the i3s btw?
12:04:52 <carter> fryguybob: i do think ghc needs a good way of dynamic switching code paths on feature flags
12:05:06 <Chousuke> carter: so I could run Linux off the integrated intel chip and then play windows games on a secondary monitor :)
12:05:11 <aristid> Chousuke: could you have a second gpu attached to a separate monitor that the windows vm has full access to?:D
12:05:16 <carter> which version has the L4 cache?
12:05:28 <aristid> carter: sounds like xeon stuff?
12:05:30 <carter> the oem / mobile boards right?
12:05:35 <aristid> oh you mean crystallwell
12:05:49 <aristid> carter: i think there's actually a 4770R which has that
12:06:07 <carter> http://ark.intel.com/products/codename/51802/Crystal-Well
12:06:08 <aristid> carter: but it's not a normal chip
12:06:16 <carter> aristid: not normal how?
12:06:57 <aristid> carter: it's bga i think
12:07:00 <carter> ok
12:07:04 <carter> and whats that mean for me/
12:07:22 <Hodapp> beaky: what brings you to #haskell?
12:07:43 <aristid> carter: harder to buy, and more mobile-like enclosure
12:07:53 <aristid> carter: can't get them separately i think
12:08:00 <carter> baked into teh board?
12:08:11 <aristid> yep that's bga pretty much
12:08:24 <carter> ok
12:08:31 <carter> so once i have money to do crazy benchmarking
12:08:34 <carter> i'll need to get boht!
12:08:35 <carter> bah
12:08:36 <carter> ok
12:08:50 <beaky> Hodapp: i want to learn how to be a good programmer
12:08:59 <carter> beaky: we all do
12:09:10 <aristid> carter: do you think the crystalwell would benefit your applications outside graphics a lot?
12:09:19 <carter> aristid: l4 is shared with cpu
12:09:25 <aristid> i know
12:09:25 <Chousuke> aristid: http://youtu.be/Qi1LdFkRzIs here's a video of crysis running in KVM. pretty interesting. (sound is screwed for some reason)
12:09:36 <carter> aristid: more layers of fast memory == faster codes
12:10:14 <aristid> carter: yes but how much faster?
12:10:23 <carter> aristid: depends
12:10:29 <aristid> carter: i presume there's a reason why intel doesn't do this on regular cpus
12:10:30 <carter> i need to lknow what the CPU read/write latency is
12:11:49 <beaky> how long does ghc normally take to compile for you guys?
12:12:07 <carter> beaky: depends on the computer :)
12:12:44 <gamegoblin> Here is a partial block of code
12:12:45 <gamegoblin> http://lpaste.net/100926
12:12:50 <prophile> "newtype Hyper b c = H (Hyper c b -> c) can be shown to be an arrow"
12:12:51 <prophile> wat
12:12:58 <gamegoblin> it fails though on the hIsEOF stuff because the handle is closed
12:13:02 <prophile> backed up only by two dead links
12:13:04 <gamegoblin> but should it never get there since the if statement?
12:13:45 <beaky> how do i be a better haskll programmer
12:13:50 <geekosaur> EOF is not the same as closed
12:13:50 <carter> build stuff
12:13:51 <carter> try stuff
12:13:52 <carter> learn
12:13:53 <carter> ask
12:13:54 <carter> do
12:13:55 <carter> tell
12:13:56 <carter> share
12:13:58 <carter> iterate
12:14:01 <heaumer> D:
12:14:03 <beaky> my haskell code is purely functional but awfully inelegant
12:14:03 <Earnestea> Stop pressing Enter
12:14:08 <carter> Earnestea: nope
12:14:09 <carter> :)
12:14:10 <geekosaur> cardboard
12:14:11 <hseg> Does anyone have a cleaner/better solution for http://lpaste.net/100927
12:14:11 <hseg>  ? My current solution is ugly.
12:14:11 <prophile> carter is the dispatcher from half-life
12:14:22 <prophile> contain, eliminate, pacify
12:14:24 <gamegoblin> geekosaur: I know, but I call hIsClosed first and then if then else the isEOF
12:14:27 <artyomkazak> carter: great double ladder, btw
12:14:29 <hseg> Works, but is ugly.
12:14:30 <geekosaur> and?
12:14:38 <carter> artyomkazak: what ladder?
12:14:52 <geekosaur> if the channel were closed, hIsEof would not work
12:14:53 <fryguybob> aristid: Look at the first graph here: http://www.anandtech.com/show/6993/intel-iris-pro-5200-graphics-review-core-i74950hq-tested/3
12:15:04 <artyomkazak> lengths of your suggestions first decreased continuously, then increased continuously
12:15:13 <gamegoblin> geekosaur: So if hIsClosed returns true, is should never call hIsEof, but it still seems to be calling it, hence my error...
12:15:27 <fryguybob> aristid: If your application can benefit from the range where the red line stays low then it will benefit greatly.
12:15:33 <gamegoblin> geekosaur: http://lpaste.net/100926
12:15:35 <geekosaur> how do you expect hIsClosed to return true if you have not closed it?
12:15:36 <carter> fryguybob: ok that is nice
12:15:49 <geekosaur> yes, I have your paste up
12:15:50 <carter> fryguybob: matrix mult can def benefit fromthat
12:15:56 <fryguybob> carter: Yes
12:15:57 <carter> artyomkazak: ooo
12:16:24 <aristid> fryguybob: hmm yeah i guess for some workloads it'd be pretty nice
12:16:31 <gamegoblin> geekosaur: I am just wondering how I can say "Is it closed? No? Ok, then is it eof?" but then the eof call says "woah can't do that, it's closed"
12:16:32 <geekosaur> gamegoblin: hIsEof indicates that it is now time to close it. it does not close it
12:17:21 <geekosaur> actually I think Id need to see more code than that, then
12:17:21 <artyomkazak> carter: when I was a kid, I would sort all songs in WinAMP by rendered-title-length-in-pixels and then wish it was default method of sorting instead of boring ones like “by artist” or “by duration”
12:17:29 <gamegoblin> geekosaur: I am not closing it. I am seeing if it is closed or eof already. When I test for closed, it says it is not closed, when I test for eof, it errors saying it's closed
12:17:41 <carter> heheh
12:17:48 <geekosaur> did you use hGetContents or something?
12:17:56 <geekosaur> haskell handles have a "half closed" state
12:18:09 <gamegoblin> Oh jesus
12:18:17 <gamegoblin> What's that mean?
12:18:41 <carter> @source hClose
12:18:42 <lambdabot> Unknown command, try @list
12:18:42 <geekosaur> and most of the usual handle manipulating functions won't work in that state, because the handle is owned by a lazy computation
12:18:48 <carter> @hoogle hClose
12:18:48 <lambdabot> System.IO hClose :: Handle -> IO ()
12:18:49 <lambdabot> GHC.IO.Handle hClose :: Handle -> IO ()
12:18:49 <lambdabot> GHC.IO.Handle hClose_help :: Handle__ -> IO (Handle__, Maybe SomeException)
12:19:33 <hseg> Does anyone have a cleaner/better solution for http://lpaste.net/100927 ? My current solution is ugly.
12:19:51 <carter> hseg: whats the goal
12:19:53 <geekosaur> so if you use something like hGetContents or one of the other lazy I/O interfaces, the handle is "half closed" and trying to use it directly will generally throw an exception
12:20:50 <gamegoblin> geekosaur: http://lpaste.net/100928
12:20:51 <carter> hseg: its hard to help if we don't know what the big picture goal is
12:21:20 <hseg> The idea is that I have a function that works for Eq instances, to which I wish to pass a type that can be projected to an Eq instance. I'd like the function to use that projection in order to decide equality.
12:21:51 <geekosaur> right, you're using hGetContents
12:22:08 <gamegoblin> geekosaur: so any idea of what I should do to accomplish the goal?
12:22:09 <geekosaur> you cannot use hIsEof or hisClosed
12:22:40 <geekosaur> if you use hGetContents you are disabling all normal handle control, the only thing that will work is hClose and that will screw up the hGetContents
12:22:52 <gamegoblin> so rather than doing take n . hGetContents
12:22:58 <gamegoblin> should I just take n hGetChars?
12:23:12 <gamegoblin> so I take the specific number of chars I want
12:23:35 <geekosaur> not take, no. hGetChar produces an IO Char
12:23:38 <geekosaur> not IO [Char]
12:23:52 <gamegoblin> Not take, but you get the idea
12:23:58 <gamegoblin> should I just iterate and grab some chars
12:24:04 <gamegoblin> rather than lazily take from the whole contents
12:24:23 <gamegoblin> That's actually how I was doing it originally but someone on this channel said that since it's lazy I could just take from the whole contents T_T
12:24:52 <geekosaur> did you show them the part where you're manipulating the handle directly, and where you're doing a timeout?
12:25:02 <geekosaur> if you use lazy I/O, you cannot do any of that
12:25:27 <gamegoblin> Alrighty. So, does grabbing individual chars work?
12:25:43 <geekosaur> tbh if you're getting into this level of control you may be better off with conduit or pipes
12:25:58 <geekosaur> grabbing individual chars should work, yes
12:25:58 <gamegoblin> I want to know how they work underneath the hood, though
12:26:27 * hackagebot MissingH 1.2.1.0 - Large utility library  http://hackage.haskell.org/package/MissingH-1.2.1.0 (JohnGoerzen)
12:26:56 <geekosaur> although hGetBuf or hGetBufSome might work better
12:27:35 <gamegoblin> Will read those, one sec
12:27:59 <gamegoblin> By work better do you mean faster, more elegant, or both?
12:29:21 <gamegoblin> geekosaur: reading individual chars works perfectly, good call
12:29:56 <geekosaur> the problem with individual reads is if you mishandle the timeout you may interrupt only one of those reads, but then the next one happens and blocks so your timeout did nothing
12:30:21 <geekosaur> hGetBuf is also more efficient but probably not by enough to matter
12:31:24 <carter> indexedPure :: A.Applicative (Shape n)=> SNat n -> a -> Shape n a
12:31:24 <carter> indexedPure _ = \val -> A.pure val
12:31:27 <carter> i like this cute hack
12:31:40 <carter> hrm
12:31:42 <carter> i should use proxy
12:32:10 <Kron> hmmm
12:32:19 <carter> or not
12:32:23 <carter> SNat is fine too
12:32:34 <carter> also can be done as a term
12:32:45 <Kron> is it possible to say something like "instance Functor (QuadTree a) where" the fmapping function has to be "Eq b => a -> b"?
12:33:00 <Kron> I want to make a quadtree a functor but I need equality comparisons to fuse elements
12:33:54 <c_wraith> Kron: no.  That's very much not possible.  Same reason why Set isn't a Functor instance, etc
12:34:53 <Kron> okay
12:36:06 <carter> you need a sort of equality morphism
12:36:18 <carter> bijection
12:36:19 <carter> thingy
12:37:59 <SrPx> Performance question. I want a function that returns a number between 0 and 100. If, inside that function, I create a list from 0 to 100, and pick one at random, will GHC be able to eliminate it? (Yes that is stupid for this case, just an example)
12:38:58 <SrPx> Even worse: if I create a list from 0 to 100, shuffle it and return the first number... will GHC be able to eliminate all that ?
12:39:34 <SrPx> and finally, how do I know if it does eliminate ? Other than asking here, obviously?
12:41:03 <carter> SrPx: read the core
12:41:05 <carter> and also benchmark
12:41:12 <carter> benchmark and read the core
12:41:24 <carter> SrPx: before assumign compiler magic
12:41:28 <SrPx> Is the core after every compiler optimization?
12:41:29 <carter> always always have benchmarks
12:41:39 <carter> i assume so
12:41:45 <carter> i've been bad about it :)
12:41:46 <SrPx> cool (:
12:41:49 <carter> i just use benchmarks and read the asm
12:41:58 <carter> @hackage criterion is your friend too
12:41:58 <lambdabot> http://hackage.haskell.org/package/criterion is your friend too
12:42:04 <carter> theres a few tools for pretty printing core too
12:42:08 <SrPx> wow, the asm? isn't the asm a direct map from the core?
12:42:09 <hseg> carter, OK, I just added the big picture analysis here: http://lpaste.net/100927
12:42:40 <carter> SrPx: nope
12:42:43 <gamegoblin> I've never taken a look at the asm generated by ghc
12:42:45 <carter> it also captures what hapepns later
12:42:56 <gamegoblin> Is it really different from the asm generated by a C program and gcc?
12:43:04 <carter> hehee
12:43:07 <carter> sometimes yes
12:43:09 <carter> sometimes no
12:43:11 <carter> depends on the code
12:43:17 <gamegoblin> I imagine mapping functional abstractions to asm is hairy
12:43:28 <SrPx> some day it will be always "yes" ? (:
12:43:38 <carter> SrPx: nah, C is slow
12:43:44 <SrPx> carter: haha C is slow now?
12:43:57 <carter> its really hard to get  C to generate *good* code that leverages poewrs of modern hardware
12:44:09 <carter> you have to use lots of intrinsics and copy hacks to give the GCC / clang the right hints
12:44:20 <SrPx> lol seriously? then why it always score first in every kind of benchmark you try ? :P
12:44:24 <carter> it kinda turns into writing the damn assembly yourself
12:44:33 <carter> SrPx: good C code != fast c code
12:44:53 <tiffany> gamegoblin: writing functional-style code in a language like rust usually compiles pretty efficiently
12:45:02 <tiffany> also, C isn't always on top of the benchmarks
12:45:11 <carter> tiffany: well, LLVM IR is kinda single assignment code
12:45:11 <tiffany> weird compiler quirks can push it below other languages
12:45:29 <carter> tiffany: in most cases the same applies to carefully written haskell + -fllvm
12:45:45 <carter> tiffany: i may be planing to give the NCG some love this summer
12:46:03 <carter> ok
12:46:05 <carter> g2g
12:46:29 * hackagebot HaRe 0.7.1.4 - the Haskell Refactorer.  http://hackage.haskell.org/package/HaRe-0.7.1.4 (AlanZimmerman)
12:51:18 <hseg> Does anyone have a cleaner/better solution for http://lpaste.net/100927 ? My current solution is ugly.
12:51:30 * hackagebot BlogLiterately-diagrams 0.1.4.2 - Include images in blog posts with inline diagrams code  http://hackage.haskell.org/package/BlogLiterately-diagrams-0.1.4.2 (BrentYorgey)
12:51:32 * hackagebot diagrams-lib 1.1.0.1 - Embedded domain-specific language for declarative graphics  http://hackage.haskell.org/package/diagrams-lib-1.1.0.1 (BrentYorgey)
12:53:47 <SrPx> carter: haha ok
12:53:51 <SrPx> if you say so, that's new to me
12:56:30 * hackagebot diagrams-contrib 1.1.1.1 - Collection of user contributions to diagrams EDSL  http://hackage.haskell.org/package/diagrams-contrib-1.1.1.1 (BrentYorgey)
12:56:32 * hackagebot force-layout 0.3.0.2 - Simple force-directed layout  http://hackage.haskell.org/package/force-layout-0.3.0.2 (BrentYorgey)
13:08:41 <Shammah> I was just experimenting with the type system: data Client i = Client { id :: i, name :: String }, and when I invoked ':t Client' I got Client :: i -> String -> Client i. Does that mean that even abstract data types are functions at the lowest level?
13:09:27 <Shammah> Oh wait, it's actually a constructor, that's why it's a function
13:09:35 <Shammah> Nevermind :)
13:09:38 <Twey> Shammah: The type given to you by Type is the type of the Client value constructor, not the Client type constructor
13:09:48 <Twey> Er, by :t
13:09:53 <Twey> Shammah: You can see the kind of a type constructor by using :k
13:10:07 <Twey> Which will give you ★ → ★
13:10:13 <Shammah> I cannot see that, ascii only
13:10:20 <Shammah> Client :: * -> * is what I get
13:10:38 <Twey> Shammah: You might want to fix your encoding; most of Freenode is UTF-8
13:10:42 <Twey> Yes, that's right
13:11:03 <Shammah> I'll guess my book will cover that later
13:11:06 <Shammah> *I
13:11:07 <benmachine> Twey: to be fair, most of GHC output isn't :P
13:11:19 <benmachine> or at least, not as such
13:11:21 <greg> whats your book Shammah
13:11:30 <Shammah> Uhm, it's fairly new
13:11:37 <Twey> benmachine: Depends how you name your identifiers ;)
13:11:47 <greg> Shammah: ?
13:11:57 <Shammah> http://www.amazon.com/Beginning-Haskell-A-Project-Based-Approach/dp/1430262508/
13:12:01 <greg> i presume its about haskell
13:12:30 <greg> ah , looks great
13:12:41 <Twey> Ah, serras' book
13:12:44 <Twey> Is it good?
13:12:53 <Hexagenic> Does anyone here have experience using cabal-install on low-memory systems? I'm trying to build happstack in raspbian on a 128 mb raspberry pi.
13:12:53 <Shammah> It got some few typos here and there being a first edition, and I'm only at chapter 3 atm
13:12:57 <Shammah> But so far it's a good book
13:13:18 <greg> quick question, wrt Arrows, is there such a thing as an Arrow that is not composed of functions?
13:13:20 <Shammah> It gives practical examples and exercises, which I thought were lacking in LYAH, which is why I never really got into it
13:13:21 <bennofs> Hexagenic: I guess GHC is more of a problem than cabal
13:13:34 <Twey> Hexagenic: ‘Have swap space ready’ :þ
13:13:47 <Hexagenic> bennofs, Probably, yes.
13:13:52 <benmachine> greg: depends what you mean by "composed of"; because of "arr" it tends to be the case that an arrow type has to be able to contain a function in some way
13:13:52 <Twey> Hexagenic: Using gold instead of ld is supposed to help, too, though I've never tried it
13:13:54 <greg> Hexagnic, i built ghc for my samsung arm, it took ages
13:13:57 <benmachine> greg: but it can also do other things
13:14:59 <dcoutts_> Hexagenic: the normal practical lower limit is ~500mb
13:15:15 <dcoutts_> Hexagenic: you can get lower by building ghc without "splitobjs"
13:15:23 <greg> benmachine: yes , but the arrow definition says that functions are an instance of arrow , my question what else can be an instance of arrow
13:15:36 <dcoutts_> Hexagenic: but you'd be best advised to build on a more powerful machine and copy the binary over
13:15:45 <benmachine> greg: have you seen Kleisli m?
13:16:33 <greg> Hexagenic: yes thats the better idea, build on a better machine then copy over, the word on the street is that Amazon have an ARM cloud image
13:16:42 <greg> so you could whack up the memory
13:17:08 <greg> benmachine: no i havent have you got a link for kleisli
13:17:43 <benmachine> greg: http://hackage.haskell.org/package/base-4.6.0.1/docs/src/Control-Arrow.html#Kleisli
13:17:59 <Hexagenic> greg, Hopefully I can use my current desktop which I assembled specifically for compiling/rendering :P I'll probably just have to figure out how to do ghc/gcc crosscompilation which I've never done before.
13:19:14 <greg> perhaps , but really it makes sense to rent a powerful prebuilt arm server
13:19:30 <greg> then copy your binaries over
13:20:21 <Shammah> Hmm, somehow instead of (a, b, c) my type gets infered as (t2, t1, t), I don't remember this happening in Haskell a few years ago... Did something change?
13:20:26 <greg> unless you can get the cross compilation working nicely that is
13:21:00 <benmachine> Shammah: those look like they are the same up to renaming
13:21:17 <Shammah> They are
13:21:37 <benmachine> Shammah: GHC may once upon a time have generated new names by starting at the beginning of the alphabet, while nowadays it tries to stay true to existing names
13:21:47 <benmachine> or something like that
13:21:54 <Shammah> Well, this way you can have more than 27 different types
13:21:58 <Shammah> if you ever need that ...
13:22:01 <greg> ah i see monads can be instance of arrow too.....ooooh
13:22:51 <hseg> Ended up managing to factor out the boolean pairing. Still, if someone finds a better way of implementing http://lpaste.net/100927
13:22:51 <hseg> , I'd be glad to hear it.
13:23:20 <Shammah> Actually benmachine: let nothing _ = Nothing, and then :t nothing returns me nothing :: t -> Maybe a
13:23:22 <greg> t1,t2,t3 is better than a,b,c as a b c could imply the types are necesarilly different
13:23:29 <Shammah> Not sure what the consistence is there
13:23:38 <Shammah> *consistency
13:23:58 <benmachine> Shammah: what's being inferred (t2, t1, t)?
13:24:21 <Shammah> "swapTriple (x, y, z) = (y, z, x)"
13:24:24 <benmachine> ah
13:24:32 <benmachine> yeah I dunno :P
13:24:49 <benmachine> the way GHC does things is better sometimes and confusing other times
13:24:57 <Shammah> I know it doesn't really matter whether it's t, or a, I was just curious to the underlying mechanics :)
13:25:18 <bennofs> :t let { x = y; z = y; y = x; } in (x,y,z)
13:25:19 <lambdabot> (t, t1, t2)
13:25:24 <bennofs> benmachine: ^^
13:25:37 <Shammah> :t let nothing _ = Nothing
13:25:38 <lambdabot> <no location info>: not an expression: `let nothing _ = Nothing'
13:25:43 <Shammah> hmm
13:26:01 <thebnq> :t nothing _ = nothing
13:26:02 <lambdabot> parse error on input `='
13:26:08 <geekosaur> :t let nothing _ = Nothing in nothing
13:26:09 <lambdabot> t -> Maybe a
13:26:41 <Shammah> I expected a -> Maybe b
13:26:50 <ion> That *is* a -> Maybe b. :-P
13:26:55 <Shammah> haha well yes it is ;D
13:26:57 <haasn> Why not t2 -> Maybe t1 :P
13:27:10 <Shammah> haasn, t -> Maybe t1 if anyhing :D
13:27:57 <haasn> bool -> Maybe int
13:31:54 <pyon-iterator> Is there any use for type variables longer than one character?
13:32:26 <pyon-iterator> That is, beyond making the code confusing.
13:32:52 <ski> `Map key value' can be nice to read
13:33:02 <Shammah> t1, t2, ... are all longer than 1 character ;)
13:33:08 <bennofs> although i'd rather use Map k v
13:33:15 <ziman> you have "tok" in Parsec
13:33:18 <ij> pyon-iterator, How does the cae in question look?
13:33:19 * ski sometimes uses `ExprF expr'
13:33:56 <pyon-iterator> ski: Only to then take its fixpoint?
13:34:11 <hseg> And the factoring I found doesn't work well. Surely there is a better way of implementing http://lpaste.net/100927
13:34:11 <hseg>  ?
13:34:23 <ski> pyon-iterator : either directly, or after first composing it with other functors, yes
13:34:52 <ski> @where IndirectComposite
13:34:52 <lambdabot> <http://web.archive.org/web/20051126141834/http://haskell.org/hawiki/IndirectComposite>
13:35:18 <David> Has anyone gotten ghc to work with gcc 4.8 on osx? I'm trying https://gist.github.com/cartazio/7131371 solution and I get this error: Loading package base ... <command line>: can't load .so/.DLL for: /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.9.sdk/usr/lib/libiconv.dylib
13:35:18 <caseof> How do I convert Data.Text.Internal.Text to standard Text?
13:35:19 <David> (dlopen(/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.9.sdk/usr/lib/libiconv.dylib, 9): no suitable image found.  Did find:
13:35:21 <David>  /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.9.sdk/usr/lib/libiconv.dylib: mach-o, but wrong filetype)
13:35:30 <pyon-iterator> What is the type-level composition operator? :-O
13:35:40 <pyon-iterator> Is it kind-polymorphic? :-O
13:36:13 <hseg> All I want is to pass a custom, single-use Eq dictionary to a function without incurring the boilerplate of creating a newtype, writing an Eq instance for it and wrapping/unwrapping my data in it.\
13:37:22 <ski> pyon-iterator : it ought to be
13:37:43 <ski> (finally a correct use of the term "kind-polymorphic" ;)
13:40:16 <pyon-iterator> ski: Have there been lots of incorrect uses recently? :-O
13:41:31 <Kron> hmm
13:41:48 <Kron> I wonder what's the best way to sort the elements of a quadtree into a big list
13:41:54 <Kron> a kind of modified 4 way mergesort?
13:42:00 <SrPx> Quick question, guys. (let x=5, y=6 in x*y) and (x*y where x=5, y=6) are the same, right? Is the monadic (do) version the same too? What is its syntax?
13:42:16 <Kron> yeah they're the same
13:42:21 <milfjord> both are syntax errors
13:42:26 <milfjord> HTH HAND
13:42:37 <bennofs> SrPx: where syntax only works in functions
13:42:41 <nicoo> Kron: Sort for which order relationship ?
13:42:51 <Kron> anything, hand a relationship function in
13:42:55 <Kron> sortBy etc.
13:43:18 <bennofs> SrPx: let syntax can use variables bound in do notation prior to it's definition. For example, you can write do { a <- b; let x = a + ...; .... }
13:43:20 <jle`> SrPx: for lets you need semicolons, not commas
13:43:21 <SrPx> bennofs: hm so it is not an expression? Weird.
13:43:24 <Kron> I know all about sorting linear lists of elements, but not quadtrees
13:43:34 <jle`> let ... in ... is expression syntax
13:43:39 <jle`> but where is a part of declaration syntax
13:43:39 <bennofs> SrPx: yes,`where` is not an expression, but let ... in ... is
13:43:48 <Kron> let works in function expressions
13:43:52 <Kron> it's the purpose of let
13:43:59 <Kron> to be the expression equivalent of a where block
13:44:01 <SrPx> hmm okay jle`
13:44:21 <ski> pyon-iterator : well, often people in here seem to have been using it incorrectly
13:44:22 <SrPx> Kron: I see
13:44:39 <jle`> (let ... in ...) can be used anywhere an expression is, but where is not a part of expression syntax
13:45:00 <ski> hseg : it's perhaps not so clear what the scopes of your type variables are
13:45:10 <jle`> it's specifically a part of declaration syntax
13:45:12 <SrPx> so, aand what about the "do" ? How is that code in the "do" form? Also, do let bindings happen sequentially? (let x=5; y=x*2 in x+y) ?
13:45:32 <jle`> let in do blocks and let in expressions are slightly different
13:45:35 <ski> SrPx : `let' bindings in a single `let' are recursive
13:45:47 <nisstyre> ski: do people incorrectly call * polymorphic at the kind level?
13:45:51 <hseg> ski, In the first case? The f is shared by everyone, the a is polymorphic.
13:45:52 <ski> > let { x = y; z = y; y = x; } in (x,y,z)
13:45:56 <lambdabot>  mueval-core: Time limit exceeded
13:45:59 <jle`> also in Haskell we don't have that kind of notion of evaluation order
13:46:02 <Kron> almost nothing happens sequentially in haskell
13:46:07 <hseg> I probably wrote much too informally.
13:46:15 <Kron> you have to very specifically do 'seq' calls and stuff to enforce sequentiality
13:46:18 <jle`> 'bind' is not really a verb in that sense
13:46:21 <Kron> everything's parallel and non strict
13:46:26 <jle`> it's more like in mathematics
13:46:31 <ski> hseg : i presume you mean `a' is `forall'ed on each of the type signatures
13:46:42 <jle`> where if you write y = x * 2; x = 3 on a blackboard, nobody is going to yell at you
13:46:48 <hseg> ski, however, the annotation at the bottom gives a much clearer view of the problem. And yes.
13:46:54 <jle`> they aren't assignments, they are definitions
13:47:14 <pyon-iterator> denotational semantics ftw!!!
13:47:19 <ski> hseg : `newtype Wrapper a = Wrap {unwrap :: F a}' with `instance Eq a => Eq (Wrapper a) where Wrap x == Wrap y = ((==) `on` proj) x y' would seem better to me
13:47:29 <jle`> you can think of it as
13:47:35 <jle`> if you write let x = 5; y = x*2 in x+y
13:47:40 <jle`> "every time you see x, replace with 5"
13:47:45 <jle`> "every time you see y, replace with x*2"
13:48:00 <jle`> like a fancy sed.
13:48:23 <hseg> ski, How is that different from what I wrote? Also, that's quite a bit to write each time I'd like such functionality.
13:49:00 <ski> hseg : you had `newtype Wrapper a = Wrap {unwrap :: a}' with `instance Eq a => Eq (Wrapper (F a)) where ...', which require `FlexibleInstances' if nothing else
13:49:37 <rusk101> Can somebody help me write the algorithm for converting string to integer? http://lpaste.net/100930
13:50:19 <jle`> SrPx: let in do blocks works slightly different, do blocks are syntactic sugar and the let binding is in scope for the remainder of the do block (so you can leave off the "in")
13:50:29 <hseg> ski, Oh. OK. Still, it has the same problem the original had, which is that it is (comparatively) a lot of boilerplate to write for each such projection.
13:50:46 <jle`> @undo do { x <- return 5; let y = x+3; return (x,y) }
13:50:46 <lambdabot> <unknown>.hs: 1: 47:Parse error: }
13:50:56 <ski> hseg : perhaps what you'd really prefer is to write something like `g :: forall a. Eq a => [F a] -> [F a]; g :: [F a] -> [F a] = map unwrap . f . map Wrap where instance Eq (F a) where (==) = (==) `on` proj' ?
13:51:19 <ski> @undo do x <- return 5; let {y = x+3}; return (x,y)
13:51:19 <lambdabot> return 5 >>= \ x -> let { y = x + 3} in return (x, y)
13:51:23 <ski> jle` ^
13:51:27 <jle`> ty ski
13:51:59 <SrPx> jle`: hmkay, makes sense to me
13:52:04 <Kron> is there any 'sortable' typeclass?
13:52:06 <hseg> ski, Yeah. More or less.
13:52:14 <jle`> SrPx: where bindings are a part of function delcaration syntax
13:52:16 <hseg> Kron, Ord
13:52:24 <Kron> well I mean for collections
13:52:37 <hseg> Kron, What do you mean?
13:52:39 <Kron> the type itself is not orderable in comparison to other instances of the same type
13:52:44 <Kron> but it, itself, can be sorted
13:52:44 <jle`> SrPx: (f x = y where y = 4), for example
13:52:47 <Kron> like...
13:52:53 <Kron> instance Sortable (QuadTree a) where
13:52:56 <jle`> you use them when you are defining a function
13:53:00 <Kron> so someone can say "sort tree"
13:53:03 <SrPx> jle`: you defined a named function in an expression?
13:53:28 <jle`> SrPx: no
13:53:37 <SrPx> oh ok
13:53:43 <hseg> Kron, So you mean a container type containing Ord-instance types?
13:53:48 <jle`> http://www.haskell.org/onlinereport/exps.html
13:53:49 <Kron> yes!
13:53:50 <Kron> I do
13:54:03 <Kron> Ord a => QuadTree a
13:54:04 <jle`> for a full description
13:54:14 <SrPx> jle`: do you read the haskell report?
13:54:26 <jle`> also http://www.haskell.org/onlinereport/haskell2010/
13:54:38 <ski> hseg : i believe that approach can possibly run into incoherence
13:54:46 <jle`> i've never read the whole thing all the way through, but it is a good reference
13:54:52 <jle`> its style is very concise and readable
13:55:15 <hseg> ski, Oh? How so? All I'm trying to do is to define a local Eq instance
13:56:26 <jle`> (you can use where while declaring a constant too, not a function, sorry)
13:56:29 <SrPx> jle`: I see
13:56:33 <jle`> > let x = y where y = 4 in x
13:56:35 <lambdabot>  4
13:56:45 <jle`> > let f x = y where y = 2*x in f 5
13:56:46 <lambdabot>  10
13:56:53 <jle`> but you have to use where with a declaration of some kind
13:57:06 <jle`> you can't throw it into an expression randomly because declarations aren't expressions
13:59:20 <jle`> people...don't usually put where's inside lets...that was mostly for demonstration :)
13:59:23 <SrPx> hmm intersting
13:59:44 <SrPx> > let x = y; y = 5; z = x+y; in z
13:59:45 <lambdabot>  10
13:59:45 <hseg> Kron, I'm not sure. The shape of the problem seems to suggest using Type Families, but I'm not proficient enough in them to be able to be of much use.
13:59:47 <SrPx> yay
13:59:51 <jle`> hoorah
13:59:55 <jle`> :)
14:00:19 <SrPx> just for curiosity
14:00:53 <hseg> ski, So how does this kind of local Eq instance bring in incoherence?
14:00:54 <SrPx> > let z = (y where y = 2) in (x where x = z)
14:00:55 <lambdabot>  <hint>:1:12: parse error on input `where'
14:01:05 <jle`> let (declarations) in (expression)
14:01:10 <SrPx> okay
14:01:15 <SrPx> > let z = (y where y = 2) in z
14:01:17 <lambdabot>  <hint>:1:12: parse error on input `where'
14:01:21 <SrPx> > let z = y where y = 2 in z
14:01:22 <lambdabot>  2
14:01:25 <SrPx> curious
14:01:37 <SrPx> > let z = y where y = 2 in x where x = z
14:01:39 <lambdabot>  <hint>:1:28: parse error on input `where'
14:01:40 <jle`> declarations are (something = expression)
14:01:42 <SrPx> ok.
14:02:03 <SrPx> jle`: so it is not like statements vs expressions
14:03:08 <jle`> haskell doesn't really have statements at the language level
14:03:26 <scshunt> ^
14:03:32 <jle`> if you're referring to statements as imperative commands
14:03:46 <scshunt> this is because haskell doesn't have an in-built notion of sequentialism
14:04:00 <scshunt> everything is reduction
14:04:03 <carter> SrPx: try {  } rather than ()
14:04:10 <scshunt> at least from a theoretical standpoint
14:04:15 <hseg> ski, A possible alternative would be something like a function-indexed type. So data Wrapped_f a = ... instance Eq (Wrapped_f a) where (==) = ((==) `on` f) <$> unwrap <*> unwrap
14:04:24 <carter> > let z = {y where y= 2} in z
14:04:25 <lambdabot>  <hint>:1:9: parse error on input `{'
14:04:29 <carter> darn
14:04:55 <hseg> Maybe some Template Haskell could create the type and the instance?
14:05:52 <Kron> is there any way to import a module and let it just overwrite prelude?
14:05:59 <Kron> I want the Foldable foldr to be the default, not the Prelude one
14:06:17 <hseg> Kron, {-# LANGUAGE NoImplicitPrelude #-}
14:06:24 <Kron> okay, thanks
14:06:38 * hackagebot tf-random 0.2 - High-quality splittable pseudorandom number generator  http://hackage.haskell.org/package/tf-random-0.2 (MichalPalka)
14:06:39 <jle`> SrPx: see http://www.haskell.org/onlinereport/haskell2010/haskellch4.html 4.4.3 for a full detail of function/variable declaration syntax
14:06:41 <jle`> but
14:07:04 <jle`> in the simplest case, you can think of it as (name) (pattern to match) = (expression) (optional where with declarations)
14:07:21 <jle`> and that's almost all of it i think, if you ignore guards
14:07:33 <jle`> remember that in haskell, for the most part, evaluation is done by substitution
14:07:35 <hseg> Is there some way to write in template haskell something like funkyMap :: Eq a => (f a -> a) -> someType -> someType[a/f a]
14:07:58 <hseg> Where t[a/b] is the type t where a is replaced by b.
14:08:04 <jle`> for example, if you have a function f 0 = 1; f x = x * (f (x-1))
14:08:09 <jle`> then to solve someothing like f 3
14:08:14 <ski> hseg : your `Eq' instance for `F' could be different from someone else's instance. `g' might be calling some operation that relies on that someone else's instance to be in force
14:08:38 <ski> hseg : "define a local Eq instance" is the problematic part
14:08:49 <jle`> you would do f 3 ===> 3 * (f 2) ===> 3 * (2 * f 1) ==> 3 * (2 * (1 * f 0)) ==> 3 * (2 * (1 * 1))
14:08:54 <ski> hseg : there is a reason for why instances can't be not exported from a module
14:08:59 <jle`> sort of like a fancy find-and-replace
14:09:24 <jle`> this is unique in haskell because we have something called referential transparency, which imperative languages don't have
14:09:33 <Kron> hmmm, how would you import Show
14:09:38 <Kron> import Prelude (Show)?
14:09:46 <Kron> I don't think Show has its own module
14:09:46 <jle`> meaning you can always replace a function call by its definition and everything will behave the same
14:10:07 <ski> @index Show
14:10:08 <lambdabot> Text.Show, Prelude
14:10:13 <ski> Kron : yes
14:10:20 <Kron> okay!
14:10:29 <Kron> do I have to import all the necessary typeclass implementation functions too?
14:10:31 <Kron> (Show, show)?
14:10:32 <jle`> whereas in an imperative language, because you have side effects, this might not always be the case.  f might increment a global variable of some sort while calculating it, and you can no longer 'evaluate by substitution'
14:10:44 <ski> Kron : or `import Prelude (Show(..))' if you want to import (only) `Show', and all the members of `Show'
14:10:49 <hseg> ski, So basically you're saying that one cannot override an instance locally? However, what I'm suggesting is to create some new unique wrapper type, and do the wrapping/unwrapping there.
14:10:50 <Kron> ahhhh nice
14:10:52 <Kron> thank you
14:11:20 <ski> Kron : `(Show,show)' would import both the class name `Show', and the operation `show' (but not `shows' and `showsPrec' which are methods of `Show')
14:11:30 <SrPx> jle`: oh sure, there are guards too
14:11:31 <Kron> gotcha
14:11:45 <ski> Kron : btw, if you're doing manual instances of `Show', then you should probably define `showsPrec' (only)
14:12:13 <hseg> ski, However, a more practical solution would be the following. Using Template Haskell, is it possible to write a function funkyMap :: (f a -> a) -> T -> T[a/f a], where T is an arbitrary type and T[a/f a] means to replace all occurences of a in T by f a?
14:12:15 <SrPx> jle`: so now that we're on that topic
14:12:30 <ski> hseg : "one cannot override an instance locally" -- yes. apart from creating a new "wrapper" type with `newtype' or `data'
14:13:05 <jle`> SrPx: http://learnyouahaskell.com/syntax-in-functions should answer most of your questions about declaration syntax if you have any
14:13:08 <ski> hseg : it's not clear that `T[a/f a]' is well-defined
14:13:16 <Kron> can you import a module /except/ for some function?
14:13:28 <ski> hseg : and even if it is, it's not clear that it will do what you intend/want it to do
14:13:29 <SrPx> jle`: are Haskell programs ultimately translated to graph-reduction machines in assembly? And if that is the case, isn't there a little bit of performance payoff by having to keep the tags, read them and, well, just process them in general?
14:13:38 <SrPx> jle`: ok (:
14:13:53 <jle`> SrPx: what haskell programs are compiled to is up to the implementation
14:14:00 <ski> hseg : you'd have to elaborate on what you had in mind with this `T[a/f a]'
14:14:10 <beaky> yess now im linking ghc!
14:14:14 <jle`> the language and its specs are separated from their implementations
14:14:18 <beaky> finally after 3 hours i compiled ghc on my raspberrypi
14:14:23 <ski> Kron : yes, `import Prelude hiding (lookup)', e.g.
14:14:27 <jle`> they are basically big abstractions
14:14:35 <jle`> and implementing the abstraction is up to you
14:14:47 <Kron> gotcha
14:14:47 <SrPx> but GHC
14:15:02 <SrPx> beaky: cool (:
14:15:11 <jle`> GHC attempts to translate Haskell into efficient imperative assembly code
14:15:21 <Kron> thanks!
14:15:25 <rusk101> Can somebody take a look at this? Problem with Int/Integer types. http://lpaste.net/100930
14:15:43 <jle`> SrPx: you can actually inspect the assembly yourself
14:15:43 <hseg> ski, OK. First, let's restrict a to instances of Eq, for simplicity's sake. funkyMap proj f would create the wrapper type and Eq instance as discussed above, then evaluate to map unwrap . f . map Wrap
14:15:50 <jle`> it can dump it out for you
14:16:34 <jle`> SrPx: GHC translates Haskell into a more explicit compiler-friendly Haskell (Core), which is then translated into an efficient compiler-friendly C, which is then compiled;optimized further into Assembly from that C variant
14:16:54 <ClaudiusMaximus> :t ord -- rusk101
14:16:55 <lambdabot> Char -> Int
14:17:12 <jle`> the resulting assembly and even the resulting C-- (as it is called) might not look anything like the graph-y haskell source code
14:17:13 <ClaudiusMaximus> needs more fromIntegral
14:17:31 <beaky> oh wait
14:17:38 <beaky> im still on stage 0 of compiling ghc! :(
14:18:05 <SrPx> jle`: it has a C stage?
14:18:08 <ski> hseg : i'm still not sure what the `T' type would be in your more concrete example
14:18:15 <jle`> SrPx: it's a specialized C variant called C-- :)
14:18:26 <SrPx> I thought it wasn't true anymore, interesting
14:18:34 <jle`> it used to have a C outputter
14:18:39 <jle`> into actual C
14:18:45 <jle`> but that is no longer supported
14:18:53 <rusk101> ClaudiusMaximus: can you show me what you mean?
14:18:54 <jle`> (i think you can still do it though if you tried hard enough)
14:19:20 <jle`> SrPx: you can sort of see a sample of the stages here http://neilmitchell.blogspot.com/2014/01/optimising-haskell-for-tight-inner-loop.html
14:19:44 <SrPx> were you guys working in a LLVM backend?
14:20:16 <ClaudiusMaximus> rusk101: annnotated the paste
14:20:17 <geekosaur> that's already there? (also was -fvia-C actually removed now? it was still there in 7.6)
14:20:29 <jle`> LLVM is already supported
14:21:04 <rusk101> thats what i thought. thx
14:21:10 <jle`> geekosaur: it's still there, but not 'supported' from a maintained standpoint sorta maybe
14:21:16 <jle`> and not encouraged
14:21:32 <geekosaur> that I knew
14:22:01 <jle`> mhm. was mostly said to clarify :)
14:22:03 <SrPx> jle`: Update: It appears on 64bit x86 GHC already produces the minimal assembly. <- wow
14:23:04 <hseg> ski, I expanded the thought here: http://lpaste.net/100927
14:23:05 <hseg>  (it's the bottom-most annotation).
14:23:09 <jle`> did not notice that update :)  that's cool
14:24:03 <SrPx> jle`: is this serious, it does produce the minimal assembly from the original example? so all that mumbo jumbo was useless? and the post ins't evne that old, 2 months ago
14:24:27 <jle`> well 7.8 isn't even officially released for another week or so
14:24:32 <jle`> and the first RC was about a month ago
14:34:09 <iduhetonas> Quick semantics question: Is () supposed to be an empty tuple, or is it considered a different type?
14:34:50 <kixcereal> Hey Haskellers, can someone explain the syntax of myButLast''' on this page to me? http://www.haskell.org/haskellwiki/99_questions/Solutions/2
14:34:52 <Iceland_jack> iduhetonas: Different size tuples have different types so it doesn't really matter
14:34:57 <Ralith> iduhetonas: how would "a different type" be distinguishable from an empty tuple?
14:35:12 <boogie> λ: :t ()
14:35:13 <boogie> () :: ()
14:35:19 <kixcereal> I'm completely confused by (x:(_:[]))
14:35:27 <Iceland_jack> kixcereal: (x:(_:[])) is the same thing as [x, _]
14:35:44 <Iceland_jack> It's just a needlessly ugly way of writing it, otherwise it's the same as myButLast''
14:35:55 <boogie> iduhetonas: () is in the only value of the unit type
14:36:01 <Iceland_jack> kixcereal: Let's go through list syntax real quick,
14:36:18 <kixcereal> Thanks, Iceland_jack
14:36:22 <Iceland_jack> When you write
14:36:22 <Iceland_jack>     [1,2,3,4]
14:36:22 <Iceland_jack> it the same as
14:36:22 <Iceland_jack>     1:(2:(3:(4:[])))
14:36:28 <SrPx> silly question, is there any OS written in Haskell or a similar language?
14:36:29 <kixcereal> Right
14:36:31 <Iceland_jack> Which is the same as
14:36:32 <Iceland_jack>     1:2:3:4:[]
14:36:58 <Iceland_jack> So if you want to pattern match on a list of length two you can do
14:36:58 <Iceland_jack>     foo [x, y] = ...
14:37:00 <hseg> ski, So what do you think of my Template Haskell suggestion? A) can it be written B) is it sane? http://lpaste.net/100927
14:37:04 <iduhetonas> Hmmm
14:37:12 <Iceland_jack> or you can do
14:37:12 <Iceland_jack>     foo (x:y:[]) = ...
14:37:12 <Iceland_jack> which is the exact same thing
14:37:27 <kixcereal> Ahhhhhhhh
14:37:32 <kixcereal> I get it
14:37:37 <kixcereal> Thank you!
14:37:39 <Iceland_jack> Since (:) is right associative,
14:37:39 <Iceland_jack>     foo (x:y:[])   = ...
14:37:39 <Iceland_jack>     foo (x:(y:[])) = ...
14:37:39 <Iceland_jack> are the same thing
14:37:40 <iduhetonas> boogie: My premise may be flawed, but am I correct in assuming that [a] is to [] as (a) is to ()?
14:37:43 <Iceland_jack> kixcereal: No problem :)
14:37:56 <jle`> iduhetonas: not too correct
14:38:02 <jle`> sorry.
14:38:13 <iduhetonas> jle`: No worries! How would you describe it?
14:38:16 <ClaudiusMaximus> SrPx: house (haskell operating system), halvm (haskell on bare metal), some hardware driver for a bsd too (using ajhc), maybe some other things somewhere
14:38:18 <hseg> SrPx, Well, you can trivially run the RTS of some functional language as the kernel for some Xen VM
14:38:31 <Iceland_jack> iduhetonas: [] is an object of type [a]
14:38:34 <jle`> well, [] means two different things
14:38:38 <jle`> but at the type level
14:38:42 <Iceland_jack> [] can also be a type constructor
14:38:50 <jle`> ^
14:38:54 <Iceland_jack> iduhetonas:
14:38:55 <Iceland_jack>     [] a
14:38:55 <Iceland_jack> is just another way of writing
14:38:55 <Iceland_jack>     [a]
14:38:58 <jle`> [a] is equivalent to [] a, just like Maybe a
14:39:01 <jle`> :k []
14:39:02 <lambdabot> * -> *
14:39:17 <ski> @kind Maybe
14:39:18 <charles1987> Hey all
14:39:18 <lambdabot> * -> *
14:39:21 <jle`> :k ()
14:39:21 <lambdabot> *
14:39:24 <Iceland_jack> @kind forall a. [] a
14:39:25 <lambdabot> *
14:39:28 <Iceland_jack> @kind forall a. [a]
14:39:29 <lambdabot> *
14:39:33 <jle`> charles1987: hello charles
14:39:33 <charles1987> I'm going through the learn you a haskell book and I have a question from chapter three
14:39:41 <Iceland_jack> charles1987: Fire away :)
14:39:41 <ski> @kind [] Integer
14:39:42 <lambdabot> *
14:39:43 <guymann> hi
14:39:53 <iduhetonas> Iceland_jack: Cool, that makes more sense. Thanks!
14:40:03 <jle`> iduhetonas: () and [] at the type level are different things; [] is a type constructor and () is an actual type
14:40:12 <Iceland_jack> iduhetonas: There are arbitrarily many elements of type [a]
14:40:20 <charles1987> it's on pattern matching
14:40:23 <Iceland_jack> But only a *single* thing that has type ()
14:40:29 <charles1987> They ask me to write this file
14:40:35 <charles1987> head` :: [a] -> a
14:40:38 <ski> iduhetonas : the value `()' is to be thought of as the empty tuple. the type `()' is to be thought of as the empty tuple type; the nullary product type
14:40:47 <charles1987> head` [] = error "..."
14:40:54 <charles1987> head` (x:_) = x
14:40:54 <jle`> iduhetonas: for example, [Int] has [], [1], [2], [1,2], etc.
14:40:58 <Iceland_jack> charles1987: yes
14:41:01 <charles1987> when I load it I get a rather odd error
14:41:03 <geekosaur> I expect it's ' not `
14:41:05 <theorbtwo> Well, type () has two values -- () and _|_.
14:41:12 <geekosaur> (look closely)
14:41:13 * ski thinks it's unfortunate that tuples (and lists) use similar notation on the value level and on the type level
14:41:14 <Iceland_jack> charles1987: You should have an apostrophe
14:41:16 <Iceland_jack> not a tick
14:41:33 <charles1987> head [] =Couldn't match expected type `a' with actual type `[Char]'
14:41:42 <iduhetonas> I see. That clears it up. Fantastic explanations ski, jle`, and Iceland_jack =)
14:41:49 <charles1987> I changed that to headd
14:41:53 <charles1987> and got the same error
14:41:54 <jle`> iduhetonas: [1,2] is the same type as [1]
14:42:02 <jle`> and [1,2,3]
14:42:09 <Iceland_jack> charles1987: Did you replace both to headd?
14:42:12 <jle`> but (1), (1,2), and (1,2,3) are all different types
14:42:13 <Iceland_jack> *with
14:42:14 <charles1987> yes
14:42:20 <charles1987> I just did a find replace
14:42:27 <jle`> one is Int, the other is (Int,Int), the other is (Int,Int,Int)
14:42:31 <hseg> charles1987, Did you perhaps define your own error?
14:42:31 <jle`> whereas for the list, they are all [Int]
14:42:33 <SrPx> hseg: I don't know what a xen vm is
14:42:41 <Iceland_jack> charles1987:
14:42:42 <Iceland_jack>     headd []    = error "..."
14:42:42 <Iceland_jack>     headd (x:_) = x
14:42:42 <Iceland_jack> should work just fine
14:42:54 <charles1987> Yeah that's why I dropped in
14:43:04 <Iceland_jack> @src head
14:43:04 <lambdabot> head (x:_) = x
14:43:04 <lambdabot> head []    = undefined
14:43:07 <jle`> charles1987: care to paste your coade on lpaste or something?
14:43:10 <charles1987> I don't understand the error. The type variable shouldn't have any problem
14:43:21 <Iceland_jack> charles1987: What type variable?
14:43:22 <charles1987> Sure one moment
14:43:31 <charles1987> head' :: [a] -> a
14:43:39 <charles1987> why is the compiler barking at me
14:43:53 <Iceland_jack> charles1987: Paste the code and we just might tell you :)
14:43:57 <charles1987> kk
14:44:11 <hseg> SrPx, loosely speaking, Xen is a psuedo-operating system that allows you to run multiple virtual computers on your computer. You could use the RTS of a language as the operating system for that computer. Just like in the old '80s computers.
14:44:41 <SrPx> interesting .
14:45:11 <charles1987> lpaste.net/100938
14:45:31 <milfjord> charles1987: wrong type signature
14:45:33 <Iceland_jack> charles1987: that's not the same type as you posted
14:46:04 <Iceland_jack> If you write
14:46:04 <Iceland_jack>     head' :: [a] -> a
14:46:04 <Iceland_jack> it compiles :)
14:46:23 <charles1987> Let me try to load it into ghci again
14:46:27 <Iceland_jack> It's hard to help if you show us correct code ;)
14:46:34 <charles1987> one moment, I'll post the error if it doesn't compile
14:46:43 <jle`> > let head' [] = error "hi"; head' (x:_) = x in head [1,2,3]
14:46:44 <lambdabot>  1
14:47:18 <jle`> > let head' :: [a] -> a; head' [] = error "hi"; head' (x:_) = x in head [1,2,3]
14:47:18 <milfjord> > let head' :: [a] -> a; head' [] = error "..."; head' (x:_) = x in head' "hi"
14:47:19 <lambdabot>  1
14:47:19 <lambdabot>  can't find file: L.hs
14:47:23 <milfjord> > let head' :: [a] -> a; head' [] = error "..."; head' (x:_) = x in head' "hi"
14:47:24 <lambdabot>  'h'
14:47:37 <charles1987> now it compiles
14:47:39 <charles1987> ugh
14:47:46 <Shammah> Hmm, why exactly is the 'where' keyword needed when declaring a module? Why can't we omit 'where'?
14:47:52 <milfjord> > let head' = error "..." in head [1,2,3]
14:47:53 <charles1987> thanks guys
14:47:53 <lambdabot>  1
14:48:09 <Iceland_jack> charles1987: Next time you can omit the type signature, and ask the compiler what it should be :)
14:48:10 <jle`> Shammah: it's just a part of syntax :P
14:48:20 <Shammah> jle`, but  abit unnecessary? :)
14:48:26 <jle`> i like that it unifies things kinda
14:48:30 <jle`> class blah where....
14:48:32 <jle`> instance blah where...
14:48:40 <Iceland_jack> By writing
14:48:40 <Iceland_jack>     ghci> :t head'
14:48:40 <Iceland_jack>     head' :: [a] -> a
14:48:40 <Iceland_jack> you can get the type of "head'"
14:48:41 <jle`> module blah where ...
14:48:45 <ion> jle: It has different layout rules though. :-P
14:49:11 <jle`> oh yeah
14:49:27 <milfjord> does it?
14:49:47 <jle`> i think for class/instance you have to indent
14:50:06 <milfjord> not really
14:51:48 <jle`> if you don't indent i think it is treated as an empty class/instance declration?
14:52:44 <jle`> "class Foo a where\ntoInt :: a -> Int"
14:52:58 <jle`> Foo is just a class with no functions
14:53:15 <ski> jle` : i think it depends on whether you have any explicit `module' heading or not
14:53:19 * ski isn't sure
14:53:29 * ski indents the whole of the module following the `module Blah (...) where' part
14:53:37 <jle`> oh, really?
14:53:45 <ski> yeah, i'm crazy like that
14:53:47 <jle`> i have never done that, oops.
14:54:24 <jle`> idk i think the were is a nice 'open bracket' 'here is what is in the module' thing.  it doesn't add too much syntactical noise but i can imagine a world where it is not there.
14:54:55 <jle`> and it sort of unifies all of the declaration syntax
14:55:06 <milfjord> jle`: http://lpaste.net/100939
14:55:08 <augur> anyone familiar with functional DBs might want to comment here: http://www.reddit.com/r/programming/comments/1zyt6c/why_functional_programming_matters/cfy96b8
14:55:42 <ion> I tried "class Foo a where\nfoo :: a\n" without a module header, it was parsed as an empty class and a type signature without a binding.
14:56:02 <jle`> i guess it depends on the module header :|
14:56:07 <milfjord> ion: http://lpaste.net/100939
14:56:30 <ion> milfjord: We’re talking about the layout rules.
14:56:38 <ion> You’re turning layouting off.
14:56:44 <enthropy> there is layout in milfjord's paste
14:57:02 <milfjord> I'm talking about an instance declaration with an unindented body
14:58:40 <jle`> augur: what is even going on in what he is saying, i don't even know where to start
14:59:09 <tbelaire> I was wondering if anyone could help me escape cabal hell
14:59:09 <tbelaire> https://github.com/tbelaire/http-pokemon/tree/records
14:59:17 <tbelaire> I'm trying to use Data.Records
14:59:26 <tbelaire> and the records-th package
14:59:37 <tbelaire> but it's trying to depend on base==4.5
14:59:42 <tbelaire> and that causes some problems
14:59:48 <tbelaire> I'm using a cabal sandbox
15:00:07 <tbelaire> I already tried deleting the sandbox and making a new one
15:00:08 <enthropy> tbelaire: get an older ghc if you want to run the package without changing it at all
15:01:03 <tbelaire> if I wanted to get a copy of it into the sandbox to see what happens if I bump the version up, how would I do so?
15:01:29 <tbelaire> I tried cabal fetch, but it fails because of the dependancy issue
15:01:45 <jle`> download the source somewhere on your system
15:01:51 <dcoutts_> tbelaire: cabal unpack
15:01:52 <jle`> and then in your http-pokemon directory
15:02:07 <jle`> cabal sandbox add-source path/to/local/source
15:03:36 <tbelaire> ah, thanks
15:04:46 <jle`> if you wnat to save yourself some possible extra work in a couple of weeks, consider doing this all with 7.8 :)
15:06:25 <tbelaire> I might do that
15:06:40 <tbelaire> do you know what's the best way to switch if I installed with homebrew?
15:07:26 <ski> hseg : doing a local datatype and a local instance declaration for it could be ok
15:07:36 <b_jonas> jle`: is "pokemon" like "pacman", a funny name multiple software uses for package manager
15:07:40 <b_jonas> ?
15:08:17 <hseg> ski, Is it possible to declare a local type+instance? Apart from that, is the idea workable and sane?
15:08:19 <ski> hseg : it looks like for your `f a' you really mean any type expression that may involve `a' as a free tyvar
15:08:29 <jle`> b_jonas: it is the name of his specific project :)
15:08:35 <ski> hseg : "Is it possible to declare a local type+instance?" -- no, but i think it ought to be
15:08:52 <jle`> i wouldn't mind at laest a local type alias
15:09:00 <ski> local instance for an existing type is much more problematic
15:09:09 <b_jonas> jle`: I think local type aliases exist as a ghc extension,
15:09:15 <ski> local type alias would also be very nice
15:09:28 <ski> (which could mention nonlocal tyvars in the definiens)
15:09:34 <hseg> ski, Actually, come think of it, f a can be any type for which there exists a projection to a.
15:09:44 <ski> b_jonas : hm, which extension ?
15:09:59 <hseg> ski, So the type of funkyMap can be changed to (r -> a) -> T -> T[a/r]
15:10:31 <ski> hseg : anyway, it would be clearer if you put in explicit quantifiers. or otherwise wrote say `F a' instead of `f a', or used obvious meta-notation like `..a..'
15:10:38 <b_jonas> ski: searching, wait
15:10:56 <ski> hseg : i was pondering if instead of `T -> T[a/r]' you could say `U a -> U r'
15:10:57 <hseg> ski, Right. Anyway, comments re: sanity of the idea?
15:11:18 <ski> hseg : i don't know yet, because i have trouble interpreting `funkyMap :: Eq a => (f a -> a) -> T -> T[a/f a]'
15:11:19 <hseg> ski, Actually, that could work.
15:11:58 <hseg> ski, That is, funkyMap :: Eq a => (r -> a) -> T a -> T r
15:12:00 <ski> hseg : i suspect that you actually want `funkyMap :: Eq a => (forall a. f a -> a) -> ..a..', but i'm not sure
15:12:44 <ski> hm
15:13:02 <ski> `T' looks a bit contravariant there
15:13:18 <b_jonas> ski: http://www.haskell.org/ghc/docs/latest/html/users_guide/other-type-extensions.html#scoped-type-variables
15:13:19 <hseg> ski, Wait. Whoa. This last rewrite has shown me that all I need is to write an instance of T as a contravariant functor.
15:14:12 <b_jonas> ski: I'm not quite sure that really lets you make scoped type synonums though
15:14:40 <jle`> b_jonas: ah, i meant more like "type Age = Int" being only locally applied inside a specific function or type signature
15:14:45 <jle`> and nowhere else
15:15:12 <b_jonas> jle`: yes, I'm not saying it has such a convenient syntax
15:15:22 <b_jonas> jle`: I just think it might be possible, but now I'm not sure about that either
15:15:46 <hseg> ski, Basically, functions with a type variable a that's an instance of some typeclass are contravariant functors.
15:16:52 <hseg> ski, i.e. f :: Constraint a => S a -> T a is a contravariant functor, where the types it takes on are restricted to satisfy the Constraint typeclass.
15:17:20 <gamegoblin> geekosaur: you around?
15:18:19 <ski> b_jonas : doesn't seem to work, as i thought
15:18:54 <ski> hseg : types can be contravariant functors
15:19:14 <hseg> ski, What do you mean?
15:19:32 <ski> "f :: Constraint a => S a -> T a is a contravariant functor" sounds like nonsense to me
15:20:19 <ieHae> hello, i have record with StdGen field and based on that StdGen i want to generate many random numbers without involoving IO, how can i do it?
15:20:28 <ski> if you define `data IOWriteRef a = forall b. IOWR (a -> b) (IORef b)', then `IOWriteRef' (of kind `* -> *') is a contravariant functor
15:20:40 <ieHae> I have troubles because i have to renew StdGen fields each time i use random.
15:20:47 <hseg> ski, OK. What I actually meant was that the type S a -> T a, for a restricted to instances of some typeclass, is a contravariant functor.
15:20:51 <ieHae> otherwise all my random numbers will be the same
15:21:07 <hseg> ski, Or at least seems to be.
15:21:18 <ski> if you define `newtype To a b = T (b -> a)', then `To a' is a contravariant functor
15:21:56 <ieHae> so my question is what are best practices to handle my case?
15:22:01 <ski> hseg : it looks to me like the type `S a -> T a' has kind `*' -- perhaps you mean a type `\a -> (S a -> T a)' ?
15:22:48 <hseg> ski, I did quantify the expression to all a restricted to instances of some typeclass.
15:23:16 <ski> ieHae : `randomRs' gives an infinite list of random values of some given type. `split' splits a `StdGen' into two
15:23:43 <ski> hseg : yes, but you didn't abstract it over `a'
15:24:00 <ski> (also, s/quantify/constrain/)
15:24:07 <hseg> ski, OK, OK.
15:25:34 <bennofs> hseg: do you mean newtype F a = F (S a -> T a) is a contravariant functor, but only if you could put a constraint on the a's ?
15:26:31 <hseg> bennofs, It seems so. I have not yet checked whether this would actually be a lawful cofunctor.
15:26:39 <ieHae> ski: excuse me? i can store infinite list of random values in pace of StdGen field, right, but what it changes? I still have to renew state of that list because otherwise  i don't know how much of that list was used
15:26:40 <ski> `F' there could be a contravariant functor, in case `S' is covariant and `T' contravariant
15:26:47 * hackagebot snap-utils 0.1.1 - Snap Framework utilities.  http://hackage.haskell.org/package/snap-utils-0.1.1 (LukeHoersten)
15:27:12 <ski> ieHae : i'm not sure why you're storing `StdGen's at all
15:28:03 <hseg> ski, Are you saying that for all covariant S, contravariant T, newtype F a = F (S a -> T a) is contravariant?
15:28:16 <bennofs> ieHae: I think you need to pass around that list manually, or use some state monad
15:28:21 <ieHae> ski: i just what to make my progam(which is involves a lot of random) reproducible
15:28:36 <bennofs> ieHae: then let your program take a "seed"
15:28:52 <ieHae> bennofs: that what StdGen does.
15:29:40 <bennofs> ieHae: then you need to write all your functions in the style StdGen -> {some inputs} -> (StdGen, {some outputs})
15:29:55 <ieHae> i'm creating record with seeded StdGen field and then based on that StdGen randoming by way
15:30:00 <ieHae> bennofs: that sucks
15:30:14 <ieHae> so i need to use StateMonad afterall
15:30:16 <bennofs> ieHae: well, you can use a state monad
15:33:19 <ieHae> everything in state monad, so horrible
15:34:00 <bgamari> Does attoparsec have a nice combination of manyTill and sepBy?
15:34:09 <bgamari> for, e.g., parsing argument lists of a C-like language
15:34:42 <hseg> Thanks for the help. Good night guys.
15:36:06 <jle`> ieHae: actually
15:36:11 <jle`> you might onoly have to use the Applicative instance
15:36:13 <jle`> so that's not so bad.
15:36:22 <bgamari> carter, any idea about the above?
15:36:22 <jle`> if state monad is bad at all to you
15:36:35 <carter> bgamari: huh
15:36:46 <carter> bgamari: whats the parsec version?
15:36:48 <jle`> ie, for a tuple with two random values
15:36:54 <carter> bgamari: is this for binary or human formats?
15:36:56 <bgamari> carter, I'm not seeing a nice way to parse something of the form (thing, thing, thing)
15:36:59 <bgamari> carter, attoparsec
15:37:00 <jle`> (,) <$> random <*> random
15:37:09 <bgamari> carter, recent version
15:37:14 <bgamari> carter, it's a C-like language
15:37:18 <carter> ok
15:37:34 <gamegoblin> Greetings all. Handle reading timeout question. Quesiton in lpaste: http://lpaste.net/100940
15:37:37 <jle`> ieHae: for data Foo = Foo Int Double Int, you can do Foo <$> random <*> random <*> random
15:37:37 <carter> hrmm
15:37:54 <bgamari> carter, Ideally I'd use something like, between (char '(') (char ')') $ parseThing `sepBy` char ','
15:38:13 <carter> bgamari: have you considered first doing the dumb monadic version?
15:38:14 <carter> :)
15:38:27 <bgamari> carter, meh, building the list in the right order is a pain
15:38:33 <bgamari> I might resort to that though
15:38:38 <jle`> that's random from MonadRandom
15:39:01 <jle`> i guess it's getRandom there
15:39:11 <donri> :t state random
15:39:12 <lambdabot> (MonadState s m, RandomGen s, Random a) => m a
15:39:51 <jle`> yeah plain ol State works too
15:39:52 <carter> bgamari: start with the dumb monadic one
15:39:56 <carter> then get clever on the cleanup!
15:39:57 <donri> :t random & state
15:39:58 <lambdabot> (MonadState g m, RandomGen g, Random a) => m a
15:40:01 <carter> are you parsing arduino code?
15:40:02 <donri> ;)
15:40:06 <carter> (c like lang)
15:40:27 <ieHae> jle`: http://hackage.haskell.org/package/MonadRandom-0.1.13/docs/Control-Monad-Random.html thats coool, thanks!
15:40:50 <jle`> ieHae: you don't quite need it even
15:40:55 <pavonia> gamegoblin: For making IO lazy you usually use unsafeInterleaveIO, not sure if that helps here
15:41:06 <jle`> > evalState ( Just <$> state random ) (mkStdGen 1)
15:41:07 <lambdabot>  Just 7917908265643496962
15:41:23 <gamegoblin> pavonia: Never used anything unsafe in haskell, sounds scary! I'll look it up.
15:41:26 <jle`> > evalState ( (,) <$> state random <*> state random <*> state random ) (mkStdGen 1)
15:41:27 <lambdabot>  Couldn't match type `(a3, a2)' with `a1 -> a0'
15:41:28 <lambdabot>  Expected type: a3 -> a2 -> a1 -> a0
15:41:28 <lambdabot>    Actual type: a3 -> a2 -> (a3, a2)
15:41:32 <jle`> oops
15:41:36 <jle`> > evalState ( (,,) <$> state random <*> state random <*> state random ) (mkStdGen 1)
15:41:37 <lambdabot>  (7917908265643496962,-1017158127812413512,-1196564839808993555)
15:41:49 * hackagebot rdf4h 1.2.5 - A library for RDF processing in Haskell  http://hackage.haskell.org/package/rdf4h-1.2.5 (RobStewart)
15:42:21 <jle`> what is a common product type that is not a tuple
15:42:44 <donri> > evalState (replicateM 3 (state random)) (mkStdGen 123) :: [Bool]
15:42:45 <jle`> @let data Foo = Foo Int Double Int
15:42:46 <lambdabot>  [True,True,True]
15:42:46 <lambdabot>  Defined.
15:42:56 <donri> what are the odds!
15:42:57 <jle`> > evalState ( Foo <$> state random <*> state random <*> state random ) (mkStdGen 1)
15:42:58 <lambdabot>  No instance for (GHC.Show.Show L.Foo)
15:42:59 <lambdabot>    arising from a use of `M682624454008726164724615.show_M6826244540087261647...
15:42:59 <lambdabot>  Possible fix: add an instance declaration for (GHC.Show.Show L.Foo)
15:43:03 <jle`> :|
15:43:07 <jle`> @let data Foo = Foo Int Double Int deriving Show
15:43:07 <lambdabot>  .L.hs:153:6:
15:43:08 <lambdabot>      Multiple declarations of `Foo'
15:43:08 <lambdabot>      Declared at: .L.hs:151:6
15:43:08 <lambdabot>                   .L.hs:153:6
15:43:08 <lambdabot>  
15:43:13 <jle`> @unset Foo
15:43:13 <lambdabot> Unknown command, try @list
15:43:16 <jle`> you get the picture
15:43:42 <ieHae> yeah, thanks
15:43:47 <donri> (they are 1/1 because mkStdGen is pure ;))
15:43:48 <jle`> @let data Foo2 = Foo2 Int Double Int deriving Show
15:43:49 <lambdabot>  Defined.
15:43:57 <jle`> > evalState ( Foo2 <$> state random <*> state random <*> state random ) (mkStdGen 1)
15:44:00 <lambdabot>  Foo2 7917908265643496962 7.276268180407097e-2 (-1196564839808993555)
15:44:43 <jle`> you only need the monad if you want to make decisions based on the result of a previous random result
15:44:58 <jle`> but for something like populating a random data structure, you can use Applicative
15:45:13 <donri> @hoogle replicateA
15:45:14 <lambdabot> Data.Sequence replicateA :: Applicative f => Int -> f a -> f (Seq a)
15:45:26 <donri> uh OK
15:45:37 <jle`> lol
15:46:13 <donri> :t fmap sequenceA . replicate
15:46:14 <lambdabot>     Not in scope: `sequenceA'
15:46:15 <lambdabot>     Perhaps you meant one of these:
15:46:15 <lambdabot>       `T.sequenceA' (imported from Data.Traversable),
15:46:19 <donri> :t fmap T.sequenceA . replicate
15:46:20 <lambdabot> Applicative f => Int -> f a -> f [a]
15:46:24 <donri> :t replicateM
15:46:25 <lambdabot> Monad m => Int -> m a -> m [a]
15:46:39 <jle`> :t T.sequence
15:46:40 <lambdabot> (Monad m, Traversable t) => t (m a) -> m (t a)
15:47:06 <jle`> can we get 7.10 already
15:47:14 <donri> yes plz
15:47:57 <jle`> :t random
15:47:58 <lambdabot> (RandomGen g, Random a) => g -> (a, g)
15:48:08 <jle`> i wonder why it was inferred as Int for some reason
15:48:25 <jle`> > evalState ( Just <$> state random ) (mkStdGen 1)
15:48:27 <lambdabot>  Just 7917908265643496962
15:48:31 <jle`> :t evalState ( Just <$> state random ) (mkStdGen 1)
15:48:32 <lambdabot> Random a => Maybe a
15:49:27 <jle`> i guess Int is a default Random
15:49:58 <artyomkazak> > :t it
15:50:00 <lambdabot>  <hint>:1:1: parse error on input `:'
15:50:05 <artyomkazak> :t it
15:50:07 <lambdabot>     Not in scope: `it'
15:50:07 <lambdabot>     Perhaps you meant one of these:
15:50:07 <lambdabot>       `id' (imported from Data.Function),
15:50:13 <artyomkazak> why, lambdabot
15:50:20 <artyomkazak> why
15:50:30 <jle`> i think all commands are compiled and executed in their own environment
15:50:41 <jle`> so it functionality would have to be built in separately
15:52:33 <jle`> > evalState (replicateM 18 (state (randomR ('0','z'))) (mkStdGen 1)
15:52:34 <lambdabot>  <hint>:1:66:
15:52:35 <lambdabot>      parse error (possibly incorrect indentation or mismatched brackets)
15:52:41 <jle`> > evalState (replicateM 18 (state (randomR ('0','z')))) (mkStdGen 1)
15:52:42 <lambdabot>  "_=dMvpJFFX3d6yyb\\A"
15:52:46 <jle`> secure password generator?
15:52:52 <Tekmo> Haha
15:53:22 <Tekmo> It's probably more efficient to use `randoms` (or whatever it is called)
15:54:04 <jle`> > take 18 $ randomRs ('0','z') (mkStdGen 1)
15:54:05 <lambdabot>  "_=dMvpJFFX3d6yyb\\A"
15:54:09 <Tekmo> Something like: fmap (take 18 . randoms) (mkStdGen 1)
15:54:22 <donri> jle`: this is the same password as "1"
15:54:35 <donri> @hoogle entropy
15:54:36 <lambdabot> package entropy
15:55:39 <jle`> > take 18 $ randomRs ('0','z') (mkStdGen 12345)
15:55:40 <lambdabot>  "V;N4g[9xpjCEe07md@"
15:55:41 <jle`> better?
15:56:04 <Tekmo> Much better!
15:56:24 <jle`> Tekmo: congrats on the job at Twitter btw!
15:56:30 <Tekmo> jle`: Thanks! :)
15:57:03 <jle`> is Twitter going to become a Haskell shop soon?
15:57:10 <pharaun> hehe
15:57:11 <jle`> i hear they are already moving a lot to Scala.
15:57:29 <Tekmo> Yeah
15:57:36 <Tekmo> I currently program in Scala
15:57:45 <Tekmo> I would have never accepted a job programming in Ruby
15:57:55 <jle`> haha
15:58:30 <jle`> SPJ joined facebook and day 1 switched their entire spam engine to Haskell.
15:58:37 <jle`> yup.
15:58:38 <Tekmo> Simon Marlow, you mean
15:58:45 <jle`> oh yeah, marlow.
15:58:49 <beaky> i thought SPJ worked at microsoft research
15:58:54 <Tekmo> Actually, that's now how it went down
15:58:56 <Tekmo> *not how
15:59:03 <Tekmo> He wasn't expressly hired for that purpose
15:59:05 <jle`> that is my idealized fantasy that plays out in my head
15:59:22 <Tekmo> It was a side project of his that ended up being more successful than whatever he was working on at the time
15:59:40 <jle`> he walked into the room and lightning bolts of Core struck from the celing
15:59:43 <Tekmo> lol
15:59:55 <donri> i thought he was hired because bos and because haskell
16:00:04 <Tekmo> I have some colleagues at Twitter who were pissed about that
16:00:21 <Tekmo> Because they basically invented something internally that was identical, but didn't catch on
16:00:42 <fizruk> do any intermediate user-defined structures get eliminated with fusion in GHC ?
16:00:56 <Tekmo> fizruk: No.  You need to explicitly define fusion rules
16:01:02 <jle`> Tekmo: at facebook?
16:01:13 <Tekmo> jle`: What do you mean?
16:01:27 <Tekmo> fizruk: Let me clarify
16:01:32 <jle`> they invented something internally at Twitter?
16:02:01 <Tekmo> jle`: It was basically the same thing as Haxl, except for some other purpose
16:02:04 <pharaun> sounds like nih :)
16:03:02 <copumpkin> national institutes of health!
16:03:14 <Tekmo> The good news is that now that Haxl is out this concept has more street cred within Twitter because the great Simon Marlow did it :)
16:03:29 <jle`> haha
16:03:31 <fizruk> Tekmo: I am truly surprised, why not?
16:03:33 <jle`> well you know what appeals to management.
16:03:38 * ski . o O ( "Nonsinkable Integumental Hypophloeous" )
16:03:45 <Tekmo> fizruk: The same reason why a lot of libraries don't catch on: poor marketing
16:05:29 <jle`> Tekmo: i'm sort of glad in a way that you decided to take that break from #haskell when i was taking my baby steps with pipes
16:05:35 <Tekmo> Haha
16:05:47 <Tekmo> You have to realize that I almost never get on IRC normally
16:05:56 <jle`> i also went on multiple rants on inventing an Arrow interface-based abstraction to replice pipes and conduit
16:05:58 <Tekmo> I only get on when I need to unwind, but normally I try to stay off of it
16:06:07 <iduhetonas> Tekmo: This isn't you, is it? https://twitter.com/Tekmo
16:06:15 <ski> @tell hseg i'm saying that for all covariant `S', contravariant `T', if we define `newtype F a = F (S a -> T a)' then `F' is contravariant (it doesn't make sense to say `newtype F a = F (S a -> T a)' is contravariant. it's a declaration, not a type)
16:06:15 <lambdabot> Consider it noted.
16:06:16 <Tekmo> iduhetonas: No.  I'm @GabrielG439
16:06:25 <jle`> haha
16:06:36 <iduhetonas> Tekmo: Ha! Okay. I couldn't figure out why your name sounded familiar
16:06:42 <iduhetonas> Tekmo: That clearly wasn't it...
16:06:44 <Tekmo> iduhetonas: :)
16:07:08 <fizruk> Tekmo: are there at least some rules for basic types other than lists?
16:07:20 <jle`> Tekmo: that's probably a good idea...this channel is such a weird time/productivity black hole for me.
16:07:33 <Tekmo> Yes, it is
16:07:36 <Tekmo> That's why I try to stay off of it
16:07:38 <ski> @type GHC.Exts.build
16:07:39 <lambdabot> (forall b. (a -> b -> b) -> b -> b) -> [a]
16:07:57 <Tekmo> I actually consider it a bit selfish to get on IRC
16:08:17 <Tekmo> Because in the time it takes me to help like 10 people I could be writing a post that will help a much larger number of readers
16:09:14 <FreeFull> > GHC.Exts.build (\f -> f 3)
16:09:16 <lambdabot>  Not in scope: `GHC.Exts.build'
16:10:13 <fizruk> FreeFull: build g = g (:) []
16:10:26 <Tekmo> fizruk: Wait, I didn't understand the question
16:10:27 <jle`> that's an interesting way to think about it.  perhaps that's the motivation i need to sign off every once in a while.
16:10:29 <Tekmo> fizruk: Rules for what?
16:11:31 <Tekmo> fizruk: Oh wait, now I understand
16:11:32 <Tekmo> fizruk: Yes
16:11:55 <carter> Tekmo: hows my marketing>
16:11:55 <Tekmo> fizruk: http://www.haskellforall.com/2014/01/stream-fusion-for-pipes.html
16:12:00 <Tekmo> carter: Terrible :)
16:12:02 <carter> :P
16:12:07 <carter> true
16:12:21 <Tekmo> carter: So generally, for libraries, the priority is:
16:12:29 <carter> get it out
16:12:32 <carter> then market it :)
16:12:33 <carter> :P
16:12:34 <fizruk> Tekmo: so each library provides its rules?
16:12:39 <FreeFull> fizruk: Oh, so it's just (:[])?
16:12:42 <Tekmo> carter: Killer app > web site > blog posts > comments on social networking sites > IRC
16:12:47 <Tekmo> fizruk: That's right
16:12:55 <carter> Tekmo: well, some of those are blocked on me getting it public :)
16:12:59 <FreeFull> :t (:[])
16:13:00 <lambdabot> a -> [a]
16:13:05 <Tekmo> carter: That's what blog posts are for
16:13:07 <FreeFull> Oh, no
16:13:10 <FreeFull> Nevermind
16:13:15 <Tekmo> carter: They are a great way to gather interest during the development process
16:13:16 <carter> Tekmo: thats next week :)
16:13:20 <Tekmo> carter: :)
16:13:31 <carter> i'm trying to have at least some dumb LU solvers working this evening
16:13:36 <carter> or i'll nibble on my hat
16:13:43 <Tekmo> carter: Haha
16:13:55 <FreeFull> :t \g -> g (:) []
16:13:56 <lambdabot> ((a -> [a] -> [a]) -> [a1] -> t) -> t
16:14:05 <FreeFull> The type isn't the same
16:14:07 <fizruk> FreeFull: [1, 2, 3] == build (\c n -> c 1 (c 2 (c 3 n)))
16:14:08 <Tekmo> fizruk: The topic of rewrite rules is actually really interesting
16:14:20 <carter> fusion is a fickle mistrress
16:14:49 <Tekmo> I really think Haskell needs to specifically distinguish fusion rewrite rules (meaning those that correspond to some sort of functor law)
16:14:57 <fizruk> carter: why fickle?
16:14:59 <Tekmo> You could get some really fucking crazy performance optimizations if you did so
16:15:08 <carter> Tekmo: on the workloads that benfit it
16:15:15 <carter> Tekmo: matrix mult dont care about no fusion
16:15:52 <Tekmo> carter: Even something as simple as distributivity is a functor law
16:15:56 <Tekmo> carter: Consider this equation
16:16:03 <Tekmo> carter: x * (y + z) = x * y + x * z
16:16:07 <carter> yeah
16:16:08 <Tekmo> carter: Now define:
16:16:09 <carter> thats pointwise stuff
16:16:13 <Tekmo> carter: fmap = (x *)
16:16:18 <Tekmo> carter: (.) = (+)
16:16:22 <Tekmo> carter: id = 0
16:16:47 <Tekmo> carter: `fmap (f . g) = fmap f . fmap g` translates to `x * (y + z) = x * y + x * z`
16:17:00 <Tekmo> carter: ... and `fmap id = id` translates to `x * 0 = 0`
16:17:55 <fizruk> Tekmo: that's too huge a leap
16:18:14 <carter> fizruk: if you look at how people write code in repa / acceleate
16:18:18 <carter> you'll find out a few things
16:18:20 <carter> namely
16:18:31 <fizruk> Tekmo: don't you need types for x, y, z?
16:18:41 <carter> they actually have non robust performance charactistics  as you vary the GHC version
16:18:53 <Tekmo> fizruk: In this case the domain and codomain of the functor are monoids
16:18:54 <carter> in the case of matrix product, there *are* algebraic simplfication rules,
16:18:56 <carter> BUT
16:19:04 <carter> normal pointwise fusion optimizations are a bad idea
16:19:07 <Tekmo> fizruk: Specifically, the monoid where composition is addition and the identity morphism is 0
16:19:30 <Tekmo> fizruk: The idea is that a monoid is a category with one anonymous object
16:19:45 <Tekmo> fizruk: And the elements of the monoid are morphisms that begin and end on that single anonymous object
16:19:56 <Tekmo> fizruk: The monoid multiplication then is just composition of morphisms
16:20:02 <fizruk> Tekmo: f and g may not be endomorphisms, which monoids are you referring to?
16:20:03 <Tekmo> fizruk: And the monoid unit is the identity morphism
16:20:37 <carter> fizruk: basically i want to have my performance cost models be transparaent and mostly deterministicic to the end user
16:20:40 <Tekmo> fizruk: In a monoid, all morphisms are endomorphisms because there is only one object
16:21:13 <carter> theres some tricky bits to that when you lean on fusion
16:21:30 <carter> if fusion can happen + your perf doesn't depend on it, then its just bonus points
16:21:55 <fizruk> Tekmo: I meant in fmap (f . g) = fmap f . fmap g   --   g :: a -> b, f :: b -> c
16:22:21 <copumpkin> a = b = c = ()
16:22:42 <copumpkin> the morphisms are the elements of the set
16:22:45 * ski would like "unboxed ADTs" for fusion
16:23:31 <Tekmo> fizruk: The morphisms would all have type `Mon A A`, where `A` is the single object of the monoid
16:24:11 <carter> ski: dataFamilies!
16:24:11 <fizruk> Tekmo: so you'd get a specialised version of functor law?
16:24:30 <carter> ski: copumpkin  i'm on a data families for fun optimization ftw bender
16:24:33 <ski> carter : i don't think that's what i want ?
16:24:43 <carter> if you want a family of unboxed ADTS
16:24:48 <carter> you can get it with ghc today
16:24:54 <copumpkin> fizruk: categories are allowed to have one object
16:24:59 <carter> with a type class + associated data family
16:25:44 <copumpkin> fizruk: in which case, the fact that your law has three degrees of freedom is irrelevant, since each of them gets to pick from a set of one element
16:25:49 <ski> carter : i want types which entail multiple alternative continuations being passed around at run-time
16:26:06 <carter> so typeclasse dictionaries :)
16:26:30 <carter> are how you'd do that
16:26:31 <carter> currently
16:26:41 <Tekmo> The one part where I'm playing fast and loose with the theory is saying that `fmap = (x *)`, since technically that would be a functor indexed on the value of `x`
16:26:53 <fizruk> copumpkin: isn't this a specialisation?
16:27:30 <copumpkin> fizruk: it's the fully general functor law the way it's usually stated
16:28:03 <fizruk> i don't get it :(
16:28:36 <Tekmo> fizruk: compumpkin is saying that `fmap` doesn't care whether the domain or codomain categories have 1 or many objects
16:29:09 <Tekmo> fizruk: fmap keeps its type general and lets the categories decide how what things will type-check as morphisms for fmap
16:29:30 <Tekmo> fizruk: So the answer to your question is "it depends what you mean by specialization"
16:31:16 <fizruk> Tekmo: okay, but how this "lifts" functor law over endomorphisms to a law over arbitrary functions?
16:32:30 <fizruk> Tekmo: iiic, you get "endomorphism" version of law after substituting (x *) = fmap, (+) = (.)
16:32:41 <fizruk> *iiuc
16:34:55 <fizruk> the fact that `fmap` does not care does not mean (at least to me) that we can prove/state something for a specialised version and then lift it to the general one
16:35:46 <Tekmo> fizruk: Right
16:35:46 <fizruk> am I thinking in totally wrong direction?
16:35:57 <Tekmo> fizruk: However, you can lift it to the more general form for matrices and it still works
16:36:24 <Tekmo> fizruk: You just have to be precise about what the morphisms are
16:37:02 <Tekmo> fizruk: So the idea is that when we talk about this law in the context of matrices there are two separate categories at play
16:37:17 <fizruk> Tekmo: what do you mean by "more general form for matrices"?
16:37:42 <Tekmo> fizruk: The form where `(*)` represents matrix multiplicatoin and `(+)` represents matrix addition
16:42:57 <fizruk> I guess, I'll have to think a bit more about that
17:00:08 <tar_> Hello! Is there an environment for writing Haskell expressions where you can see all the types and type substitutions that are going on as you go?
17:00:42 <Rarrikins> tar_: ghci
17:01:17 <Iceland_jack> tar_: You can either type
17:01:17 <Iceland_jack>     ghci> :t 'a'
17:01:17 <Iceland_jack>     'a' :: Char
17:01:17 <Iceland_jack> or set
17:01:20 <Iceland_jack>     ghci> :set +t
17:01:20 <Rarrikins> tar_: You can use :set +t for types.
17:01:23 <Iceland_jack>     ghci> 'a'
17:01:26 <Iceland_jack>     'a'
17:01:30 <Iceland_jack>     it :: Char
17:01:58 * hackagebot xmobar 0.20 - A Minimalistic Text Based Status Bar  http://hackage.haskell.org/package/xmobar-0.20 (JoseAntonioOrtegaRuiz)
17:02:02 <tbelaire> You can also use :step, right?
17:02:09 <tbelaire> I can't test right now, re-installing ghc
17:02:36 <Rarrikins> tbelaire: Yes. You can use :? to see all the :thingies.
17:03:04 <tar_> Ah, :set +t is good. Can I have it show the type even when it fails to Show?
17:04:00 <Rarrikins> tar_: It should do that.
17:04:41 <Rarrikins> tar_: If not, :t expr
17:05:09 <Iceland_jack> tar_: It doesn't show the type if it's not an instance of Show (except in the error message)
17:05:24 <Iceland_jack> but using ':t expr' is probably a better idea
17:05:28 <tar_> oh right, it is right there in the error
17:05:41 <tar_> Thanks!
17:05:46 <Iceland_jack> You're welcome
17:09:07 <andkore> How does ["Test"] == [] work? [] is of type [a]
17:09:11 <tar_> oh cool, holes work in ghci too
17:09:43 <Iceland_jack> andkore: ["Test"] has type [String] so [] will also have type [String]
17:09:46 <geekosaur> andkore: it's not a rigid type so it can be inferred from the other one
17:09:51 <geekosaur> by the type of (==)
17:09:52 <Iceland_jack> since 'a' can unify with 'String'
17:10:03 <shachaf> andkore: [] is of type [a] for each type a
17:10:17 <shachaf> For example, [] :: [Int] and [] :: [String]
17:10:26 <andkore> Ah, right
17:10:35 <Iceland_jack> > [] :: String
17:10:37 <lambdabot>  ""
17:10:39 <Iceland_jack> > [] :: [Int]
17:10:39 <andkore> So it's like a "polymorphic constant"? (in the terminology of LYAH)
17:10:40 <lambdabot>  []
17:10:41 <Iceland_jack> > [] :: [String]
17:10:42 <lambdabot>  []
17:10:46 <shachaf> You can write that as [] :: forall a. [a] in GHC, to be explicit.
17:10:52 <shachaf> Well, everything is a constant.
17:11:01 <shachaf> But sure, it's polymorphic.
17:11:11 <andkore> OK. Thanks guys.
17:11:21 <pjdelport> What exactly happens when you say "otherwise" in a case pattern?
17:11:29 <andkore> otherwise is a synonym for True
17:11:31 <Iceland_jack> pjdelport: "otherwise" is just True
17:11:32 <Iceland_jack> > otherwise
17:11:33 <lambdabot>  True
17:11:41 <Iceland_jack> Just a regular ol'Boolean
17:11:42 <pjdelport> I know, but does case treat it specially?
17:11:45 <geekosaur> no
17:11:46 <Iceland_jack> no
17:12:02 <Iceland_jack> why would it if it's defined
17:12:02 <Iceland_jack>     otherwise = True
17:12:03 <geekosaur> a guard is a boolean expression
17:12:07 <artyomkazak> in fact, case doesn't treat it at all
17:12:14 <pjdelport> Saying "otherwise" in a case pattern seems to work as expected.
17:12:23 <shachaf> If you match on it like this -- case x of otherwise -> ... -- it doesn't use otherwise as True at all.
17:12:25 <pjdelport> But True does not.
17:12:25 <geekosaur> in a case pattern?
17:12:26 <shachaf> It shadows it.
17:12:35 <shachaf> > case 5 of otherwise -> (otherwise, otherwise)
17:12:37 <lambdabot>  (5,5)
17:12:37 <pjdelport> shachaf: Hah, oh right.
17:12:39 <pjdelport> yeah
17:12:43 <pjdelport> yep
17:12:44 <geekosaur> it defines a new local name which is an irrefutable pattern that matches anything
17:13:04 <pjdelport> pun all the things
17:13:09 <geekosaur> so it just happens to behave the way you might expect an "otherwise" to work, as long as it is the only thing in that pattern
17:13:29 <shachaf> Probably GHC should warn for a bunch of things by default.
17:13:41 <geekosaur> except that if the corresponding expression itself uses case with a guard using otherwise you may get an unpleasant surprise
17:13:45 <shachaf> Like incomplete patterns and shadowing.
17:14:00 <shachaf> geekosaur: As long as?
17:14:20 <shachaf> > case "hi" of (x:xs) -> (x,xs); otherwise -> ('a',"bcd")
17:14:22 <lambdabot>  ('h',"i")
17:14:39 <geekosaur> case x of otherwise -> ... -- works. case x of (otherwise:_) -> ... --- a problem
17:14:51 <geekosaur> potentially
17:15:22 <geekosaur> (actually I guess even that would work, just be really confusing)
17:18:48 <ski> > case "hi" of _ | otherwise -> otherwise
17:18:49 <lambdabot>  True
17:19:23 <ski> > case all isLower "hi" of otherwise | otherwise -> otherwise
17:19:25 <lambdabot>  True
17:20:03 <joelteon> > let x = x in x
17:20:06 <lambdabot>  mueval-core: Time limit exceeded
17:20:08 <ski> > case all isLower "Lo" of otherwise | not otherwise -> otherwise
17:20:09 <lambdabot>  False
17:22:22 <artyomkazak> wait, why does this work
17:22:55 <shachaf> > (let otherwise otherwise = otherwise in case otherwise of otherwise -> otherwise) otherwise
17:22:56 <lambdabot>  True
17:23:24 <magicman> Dawg.
17:24:09 <artyomkazak> ah, right. Nevermind
17:31:40 <f-a> just to say that after a good 2 years I am finally back on a platform with ghci. And. It. Is. Great.
17:32:02 <charles1987> I'm running GHCI on windows 8
17:32:05 <charles1987> ah yeha
17:37:16 <mgomezch_> wow, didn’t know parameter patterns could shadow the function name.  that’ll make for some cute obfuscation :)
17:42:02 * hackagebot mighttpd2 3.0.4 - High performance web server on WAI/warp  http://hackage.haskell.org/package/mighttpd2-3.0.4 (KazuYamamoto)
17:46:36 <chrisyoung> Hello, I'm a n00b playing around with 1HAD. In the 02/25 exercise, the idea is to implement a very simple RLE algorithm.
17:46:48 <chrisyoung> So I started by playing around in ghci
17:46:51 <augur> whats the standard go-to for parenthesization and pretty printing?
17:47:11 <chrisyoung> Eg., -- >>> compress "Hello"
17:47:15 <chrisyoung> -- [('H',1),('e',1),('l',2),('o',1)]
17:47:37 <chrisyoung> let summarize = all@(x:xs) = (x, (length all))
17:48:03 <Iceland_jack> chrisyoung: are you allowed to use library functions?
17:48:05 <chrisyoung> That will summarize each element in a list for me if it's in the form [1, 1, 1].
17:48:11 <chrisyoung> In that case it would be [1, 3]
17:48:27 <Iceland_jack> > group "hello"
17:48:28 <lambdabot>  ["h","e","ll","o"]
17:48:30 <chrisyoung> And group from Data.List will group the elements for me nicely
17:48:37 <chrisyoung> Right.
17:48:50 <chrisyoung> And so all I need to do is map summarize across the result of group?
17:49:05 <chrisyoung> map summarize $ group "hello"
17:49:17 <chrisyoung> Which gives me [('h',1),('e',1),('l',2),('o',1)]
17:49:21 <chrisyoung> Which is what I want!
17:49:24 <chrisyoung> However!
17:49:36 <chrisyoung> when I write this in the file:
17:49:38 <chrisyoung> compress = map summarize $ group where
17:49:38 <chrisyoung>   summarize all@(x:xs) = (x, (length all))
17:49:38 <chrisyoung>  
17:49:53 <Iceland_jack> you need (.) instead of ($)
17:49:57 <chrisyoung> I get a Couldn't match expected type `[[a0]]'
17:49:57 <chrisyoung>                 with actual type `[a1] -> [[a1]]'
17:50:01 <chrisyoung> Ugh.
17:50:03 <ski> -- > compress 720
17:50:04 <ski>   -- [4,2,1]
17:50:38 <chrisyoung> Ah!
17:50:42 <chrisyoung> Thank you.
17:50:59 <Iceland_jack> chrisyoung: Get it to work in the ‘point-ful’ style before trying pointfree :)
17:51:06 <chrisyoung> I see.
17:51:19 <Iceland_jack> i.e.
17:51:19 <Iceland_jack>     compress xs = map summarize (group xs)
17:51:50 <Iceland_jack> you can also write it as something like
17:51:50 <Iceland_jack>     compress xs = [ (head x, length x) | x <- group xs ]
17:51:50 <Iceland_jack> if you prefer
17:52:05 <chrisyoung> Ok, really dumb question, I don't understand why this doesn't work:
17:52:16 <chrisyoung> compress = map summarize $ group
17:52:26 <Iceland_jack> chrisyoung: What is the type of ($)?
17:52:43 <Iceland_jack> (next two questions, what are the types of 'map summarize' and 'group') :)
17:52:48 <chrisyoung> (a -> b) -> a -> b
17:52:50 <ski> chrisyoung : `map summarize $ group' is equal to `(map summarize) (group)' is equal to `map summarize group' -- which is a type error
17:53:39 <chrisyoung> Oh.
17:53:44 <chrisyoung> Whoops.
17:53:49 <chrisyoung> Thank you very much.
17:58:08 <flebron> Hi, what would be a pointfree recursive combinator? A bunch of things I'm trying don't typecheck as the usual fix f = f (fix f) does.
17:58:11 * zlatan is away: Monads affect me :O
17:58:32 <flebron> i.e. let y = \f -> (\x -> f (x x)) (\x -> f (x x))
17:58:49 <shachaf> That's not point-free.
17:59:00 <shachaf> Do you mean one that doesn't use recursion?
17:59:13 <flebron> Err, sorry, yes, that's what I meant.
17:59:18 <flebron> No explicit recursion.
17:59:43 <shachaf> Nope, impossible.
17:59:58 <shachaf> (You can use type-level recursion rather than value-level recursion to make Y type-check, though.)
18:00:14 <flebron> How can you conclude it's impossible?
18:00:15 <Iceland_jack> You can implement the Y combinator with newtpes
18:00:38 <flebron> I know about the Rec a -> a type, was trying to make it "just work" :)
18:01:00 <jle`> where does the default "maintainer email" from cabal init come from?
18:01:08 <shachaf> Part of the point of a type system like Haskell's is to prevent things like that.
18:01:26 <dcoutts_> jle`: iirc, from the darcs/git repo info
18:01:35 <flebron> Well fix f = f (fix f) would amount to the same thing and that's allowed.
18:02:10 <jle`> dcoutts_: ah, thanks
18:02:27 <jle`> you're right, that checks out
18:03:07 <shachaf> Using recursion, you can implement recursion.
18:03:29 <shachaf> I mean, if you want point-free, that's easy enough:
18:03:33 <shachaf> @pl fix f = f (fix f)
18:03:33 <lambdabot> fix = fix (ap id)
18:03:44 <flebron> shachaf: I mean, what is it about the type (a -> a) -> a that does not allow one to write a non-explicitly-recursive implementation?
18:04:39 <flebron> (And how does one formalize the notion of "Those things which can be written without mentioning explicit recursion"?)
18:05:13 <Iceland_jack> flebron: Check out Types and Programming Languages
18:05:44 <shachaf> Well, using recursion you can implement any type.
18:05:50 <ski> @let newtype Santa a = MkS {unS :: Santa a -> a}
18:05:51 <lambdabot>  Defined.
18:05:59 <shachaf> (let x = x in x) :: a
18:06:57 <shachaf> So types that are inhabited *with* arbitrary recursion is a pretty boring thing.
18:09:32 <ski> @type let fixSanta :: (a -> a) -> a; fixSanta f = s `unS` s where s = MkS (\g -> f (g `unS` g)) in fixSanta
18:09:33 <lambdabot> (a -> a) -> a
18:09:35 <ski> @type let fixSanta :: (a -> a) -> a; fixSanta f = s (MkS s) where s = \g -> f (g `unS` g) in fixSanta
18:09:36 <lambdabot> (a -> a) -> a
18:09:56 <augur> such ridiculousness
18:10:06 <shachaf> This type has already been mentioned and rejected by flebron.
18:10:36 <flebron> I was trying to do it with the standard polymorphism, just like fix f = f (fix f) has.
18:11:34 <FreeFull> flebron: What is your proposed implementation?
18:11:54 * ski thought "make it \"just work\"" meant making the recursive type version work
18:12:21 <Iceland_jack> You should be able to have equirecursive types in OCaml
18:12:49 <haasn> What's the issue with supporting infinite types in Haskell, by the way?
18:12:55 <haasn> implicitly
18:12:55 <flebron> FreeFull: I've never had one.
18:13:03 <Iceland_jack> the 'just work' criteria sounds very vague thoguh :)
18:13:04 <Iceland_jack> *though
18:13:25 <shachaf> haasn: Infinite types mean that a lot of things type-check.
18:15:17 <FreeFull> > let x = x x in x
18:15:18 <lambdabot>  Occurs check: cannot construct the infinite type: t1 = t0 -> t1Occurs check:...
18:15:30 <FreeFull> What would x even mean
18:16:48 <Cale> haasn: Nothing except that they *usually* indicate a type error
18:17:46 <Cale> :t let x = out x x in x
18:17:47 <lambdabot>     Occurs check: cannot construct the infinite type: f0 = (->) (Mu f0)
18:17:47 <lambdabot>     Expected type: Mu f0 -> Mu f0
18:17:47 <lambdabot>       Actual type: f0 (Mu f0)
18:17:49 <Cale> oh
18:17:51 <Cale> :t let x = outR x x in x
18:17:52 <lambdabot>     Occurs check: cannot construct the infinite type: a0 = Rec a0
18:17:52 <lambdabot>     In the first argument of `outR', namely `x'
18:17:52 <lambdabot>     In the expression: outR x x
18:17:55 <Cale> hm
18:18:03 <Cale> :t outR
18:18:04 <lambdabot> Rec a -> Rec a -> a
18:18:07 <Cale> ah
18:18:16 <Cale> :t InT
18:18:17 <Cale> :t InR
18:18:18 <lambdabot>     Not in scope: data constructor `InT'
18:18:18 <lambdabot>     Perhaps you meant one of these:
18:18:18 <lambdabot>       `In' (imported from Lambdabot.Plugin.Haskell.Eval.Trusted),
18:18:18 <lambdabot> (Rec a -> a) -> Rec a
18:30:00 <Cale> Well, you can do this:
18:30:07 <Cale> > (\x -> x (InR x)) (\x -> outR x x)
18:30:11 <lambdabot>  mueval-core: Time limit exceeded
18:30:14 <Cale> :t (\x -> x (InR x)) (\x -> outR x x)
18:30:15 <lambdabot> a
18:30:43 <shachaf> Four different people have already brought up this trick with three different names.
18:30:46 <Cale> But I'm not sure there's anything straightforwardly analogous to x = x x
18:30:59 <shachaf> I like to call it Curry.
18:31:20 <Iceland_jack> > (\f -> let term = InR (\x -> f (outR x x)) in outR term term) (\f n -> if n == 0 then 1 else n * f (n-1)) 6
18:31:22 <lambdabot>  720
18:31:51 <Cale> > (\f -> (\x -> f (out x x)) (In (\x -> f (out x x)))) (\f n -> if n == 0 then 1 else n * f (n-1)) 6
18:31:53 <lambdabot>  Couldn't match type `Lambdabot.Plugin.Haskell.Eval.Trusted.Mu f0'
18:31:53 <lambdabot>                with `a0 -> a0'
18:31:53 <lambdabot>  Expected type: Lambdabot.Plugin.Haskell.Eval.Trusted.Mu f0
18:31:53 <lambdabot>                 -> a0 -> a0
18:31:53 <lambdabot>    Actual type: f0 (Lambdabot.Plugin.Haskell.Eval.Trusted.Mu f0)Couldn't matc...
18:31:59 <Cale> oops
18:32:05 <Cale> > (\f -> (\x -> f (outR x x)) (InR (\x -> f (outR x x)))) (\f n -> if n == 0 then 1 else n * f (n-1)) 6
18:32:07 <lambdabot>  720
18:32:12 <Cale> Keep forgetting the R's :)
18:32:45 <Cale> flebron: ^^
18:33:19 <Cale> flebron: that's your \f -> (\x -> f (x x)) (\x -> f (x x))  with some InR's and outR's stuck in (they're isomorphisms)
18:33:22 <flebron> Right, with the newtype for InR and outR.
18:44:20 <khyperia> Is there such thing as "Hindley-Milner for System F"? Any papers I could read?
18:47:41 <ski> i don't there's any principal type inference for System F
18:47:56 <ski> (s/type/typing/ ? can't recall which is which)
18:48:32 <nisstyre> khyperia: here you go http://research.microsoft.com/en-us/um/people/simonpj/papers/higher-rank/putting.pdf
18:48:36 <khyperia> thanks!
18:48:41 <nisstyre> like ski said you can't always get a principal type
18:49:18 <nisstyre> and the actual type system GHC uses is like System-F with some weird symbol
18:49:48 <ski> ⌜ω⌝ ?
18:50:22 <nisstyre> yeah
18:50:31 <geekosaur> "omega"
18:50:38 <nisstyre> there you go :)
18:52:19 <zil> > 90*0.3
18:52:20 <lambdabot>  27.0
18:54:09 <David> I just ran ghc-pkg check and I'm getting a few screenfuls of Warning: haddock-interfaces: [package] doesn't exist or isn't a file
18:54:19 <David> is this a problem, and if so, how do I fix it?
18:56:43 <geekosaur> just means you didn't have documentation turned on when you installed the package
18:56:49 <geekosaur> (it defaults off)
18:57:10 * hackagebot validation 0.3.2 - A data-type like Either but with an accumulating Applicative  http://hackage.haskell.org/package/validation-0.3.2 (TonyMorris)
18:57:55 <David> Ah. thanks geekosaur
19:27:14 * hackagebot groundhog 0.4.2 - Type-safe datatype-database mapping library.  http://hackage.haskell.org/package/groundhog-0.4.2 (BorisLykah)
19:27:16 * hackagebot groundhog-sqlite 0.4.2 - Sqlite3 backend for the groundhog library  http://hackage.haskell.org/package/groundhog-sqlite-0.4.2 (BorisLykah)
19:27:18 * hackagebot groundhog-postgresql 0.4.2 - PostgreSQL backend for the groundhog library.  http://hackage.haskell.org/package/groundhog-postgresql-0.4.2 (BorisLykah)
19:27:20 * hackagebot groundhog-mysql 0.4.2 - MySQL backend for the groundhog library.  http://hackage.haskell.org/package/groundhog-mysql-0.4.2 (BorisLykah)
19:32:14 * hackagebot groundhog-th 0.4.2 - Type-safe datatype-database mapping library.  http://hackage.haskell.org/package/groundhog-th-0.4.2 (BorisLykah)
19:33:35 <Hermit> it seems to me assuming success prematurely is like asking for failure.... been compiling latest git ghc + latest mingw toolchain for like 20 mins, and when I started to grin from ear to ear about it, BAM, error
19:34:19 <simon> Hermit, formally known as "Don't jinx it!"
19:34:45 * Hermit takes note
19:35:02 <Hermit> a wtf BOOM video comes to mind
19:36:34 <jana> Can I write "(\f -> (feedId f, numEpisodes f))" without an lambda expression? feedId and numEpisodes are functions acting on f and return a String or an Int respectively
19:38:36 <geekosaur> @pl \f -> (feedId f, numEpisodes f)
19:38:36 <lambdabot> liftM2 (,) feedId numEpisodes
19:38:38 <joelteon> feedId &&& numEpisodes
19:38:42 <joelteon> or that
19:38:52 <dmj`> (&&&) is it
19:39:45 <dmj`> > ((+1) &&& (+2)) 4
19:39:46 <lambdabot>  (5,6)
19:40:34 <Datsundere> > let 2+2 = 5
19:40:35 <lambdabot>  not an expression: `let 2+2 = 5'
19:40:59 <Iceland_jack>     (×) = (&&&)!
19:41:14 <pavonia> > let 2+2 = 5 in map (+2) [1..5]
19:41:14 <Datsundere> > let 2+2 = 5 in 2 + 2
19:41:15 <lambdabot>  [*Exception: <interactive>:3:5-11: Non-exhaustive patterns in function +
19:41:15 <lambdabot>  5
19:41:38 <Datsundere> > 2 + 2
19:41:40 <lambdabot>  4
19:42:33 <Datsundere> > cycle "te"
19:42:34 <lambdabot>  "tetetetetetetetetetetetetetetetetetetetetetetetetetetetetetetetetetetetetet...
19:45:20 <hiptobecubic> > cycle "hue"
19:45:21 <lambdabot>  "huehuehuehuehuehuehuehuehuehuehuehuehuehuehuehuehuehuehuehuehuehuehuehuehue...
19:45:31 <jana> @dmj` thx!
19:45:31 <lambdabot> Unknown command, try @list
19:47:27 <Datsundere> > > 1,2..10
19:47:28 <lambdabot>  <hint>:1:1: parse error on input `>'
19:47:32 <Datsundere> > 1,2..10
19:47:33 <lambdabot>  <hint>:1:2: parse error on input `,'
19:49:05 <Iceland_jack> > [1,2..10]
19:49:06 <lambdabot>  [1,2,3,4,5,6,7,8,9,10]
19:51:45 <Datsundere> > > [1,2..100]
19:51:46 <lambdabot>  <hint>:1:1: parse error on input `>'
19:51:49 <Datsundere> > [1,2..100]
19:51:50 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
20:15:03 <augur> de bruin indices are a pain in the ass
20:15:16 <prooftechnique> Factual
20:15:59 <augur> consider:   \(A : Type) -> \(x : A) -> x   :   (A : Type) -> (x : A) -> A
20:16:47 <augur> with debruijn indices:   \Type -> \0 -> 0   :   Type -> 0 -> 1
20:19:52 <augur> but if you try to infer the type of this, its tricky. you want to infer the type of this 0:
20:19:53 <augur>  \Type -> \0 -> 0   :   Type -> 0 -> 1
20:19:53 <augur>                 ^
20:19:54 <augur> to be 1, because the context for it is Type,0, and since it points to the first var in the context, which has type 0 in its context
20:21:22 <augur> but if you just look up the type of the first var in the context, it has type 0 in its context, so you have to increment that by 0 (the index of that var) + 1 (to get beyond that var in the context)
20:22:06 <augur> so you cant just say that the type of index i in context G is the ith type in G
20:23:12 <rocketman> Hi. I'm a Haskell noob. Wondering about best way to set up a dev environment on Mac OSX 10.9. Should I wait for GHC 7.8? Should I use the wrapper script?
20:24:25 <prooftechnique> Haskell platform pkg from haskell.org, then brew install gcc and modify settings.
20:24:35 <prooftechnique> That's what I do, anyway
20:24:48 <ij> Can't you simply brew ghc?
20:25:23 <prooftechnique> You can, the cabal with the platform pkg just sets up more sensible defaults than the brew one
20:26:29 <dmj`> rocketman: http://www.haskell.org/platform/mac.html
20:26:33 <pavonia> augur: Why is it "\Type -> \0 ->" and not "\A -> \0 ->"?
20:26:34 <rocketman> Apparently, it's not completely trivial because XCode 5 no longer includes gcc.
20:27:39 <augur> pavonia: the type next to the lambdas in the de bruijn version is the type of the argument
20:28:20 <prooftechnique> rocketman: All you need to do is install a real gcc with brew, then edit the ghc settings file
20:28:27 <prooftechnique> Mine's at /Library/Frameworks/GHC.framework/Versions/7.6.3-x86_64/usr/lib/ghc-7.6.3/settings, for instance
20:28:49 <steamboat> is there a good place to report inaccuracies in cabal package dependencies?
20:29:32 <dcoutts_> steamboat: the bug-report url or maintainer of the package in question (listed in the .cabal file and on the hackage page)
20:29:46 <steamboat> dcoutts_: thanks
20:34:39 <binroot> Does anyone know how I can register for an account on the haskell wiki? I would like to add a resource but I currently don't have an account.
20:35:48 <prooftechnique> binroot: Email nominolo <at> gmail
20:36:06 <binroot> prooftechnique: I did this morning. What's the wait time?
20:36:14 <binroot> thanks
20:36:17 <rocketman> Thanks for your help, prooftechnique.
20:36:23 <rocketman> prooftechnique++
20:36:25 <prooftechnique> Dunno. Whenever an admin gets to it, I guess. :
20:36:27 <prooftechnique> *:D
20:36:37 <prooftechnique> rocketman: Haha, no worries. Let me know if you hit any trouble.
20:37:15 <binroot> Does anyone here hold a Haskell wiki account?
20:37:28 <carter> yup
20:39:05 <binroot> carter: Hey, I have a 12-lecture course on Haskell http://shuklan.com/haskell that I would like to add as a learning resource to the wiki. While I wait to obtain an account, could you please add this in?
20:39:19 <binroot> carter: perhaps somewhere in http://www.haskell.org/haskellwiki/Tutorials
20:39:58 <prooftechnique> binroot: Oh, that's you? Your course was awesome!
20:40:14 <binroot> thanks prooftechnique!!
20:40:22 <carter> binroot: i'll look at it tomorrow
20:40:29 <carter> i like to read content before i post it :)
20:40:45 <binroot> carter: Of course! Thank you for your help!
20:41:02 <carter> binroot: don't fuck up the data analysis book btw
20:41:15 <carter> i have a vested interest in quantiative haskel tooling
20:41:23 <binroot> holy shit, carter how did you know?
20:41:29 <carter> its on your website
20:41:33 <binroot> ... lol
20:41:34 <binroot> k
20:41:42 <carter> binroot: do you know who i am?
20:41:50 <binroot> nope
20:42:09 <carter> do you ever see the math thread on /r/haskell?
20:42:10 <prooftechnique> If it's even slightly better than that financial analysis book, you've done well
20:42:11 <binroot> carter: more info on the 12-lecture resource: http://ureddit.com/blog/2013/02/23/featured-class-introduction-to-haskell/
20:42:23 <binroot> carter: yea I think so!
20:42:37 <carter> binroot: do you ever see any one who goes by cartazio/carter on those threads?
20:43:09 <binroot> carter: sorry, I guess I haven't been paying much attention to the names
20:43:24 <prooftechnique> Of particular interest: Receive and map high-frequency data in real time
20:43:26 <prooftechnique> Neato
20:43:38 <carter> binroot: did you read http://www.reddit.com/r/haskell/comments/1zowv1/whats_your_killer_app_for_your/
20:43:56 <carter> grep for carter
20:44:36 <carter> binroot: tl;dr i'm writing "numerical haskell" the library
20:44:40 <binroot> carter: I see you cartazio
20:45:31 <binroot> carter: interactive data analysis eh? If you want, I can include a bit of your work in the haskell data analysis book
20:45:42 <carter> binroot: read more closely :)
20:45:55 <carter> i'm working on the haskell analogue of numpy / scipy / etc etc
20:45:59 <carter> but less shitty
20:46:01 <carter> :)
20:46:10 <carter> i'm tired and brusque this evening
20:46:16 <carter> join #numerical-haskell and lurk
20:46:32 <binroot> I do love numpy
20:46:37 <carter> i don't
20:46:40 <carter> its not extensible
20:46:52 <carter> it doesn't give you the write idioms for wting good lcoality code in a high level way
20:46:54 <carter> because of htings
20:47:00 <carter> i agree its the best of the current toosl
20:47:05 <carter> but theres room for so much more
20:47:10 <binroot> I see
20:47:16 <carter> you should ask iross about his haskell data analysis book
20:47:31 <carter> what topics will you cover?
20:48:21 <binroot> covering data obtaining, data cleaning, ngrams, statistical things like running average, perceptron, intro to parallel design, trees, graphs, visualization of data
20:48:31 <carter> ok
20:48:32 <carter> cool
20:48:41 <carter> we need more good intro books that tie into quantitative things
20:48:53 <carter> be sure to get lots of feedback by folks in the community on the drafts
20:49:01 <carter> the better quality any books are
20:49:04 <carter> the better for everyone
20:49:12 <carter> not just your bank account :)
20:49:37 <prooftechnique> binroot: Do you touch on HLearn, at all?
20:49:45 <binroot> Totally agree! I'm working on the 3nd draft of chapters 1 and 2 (due April 7) and I'll be sure to ask /r/haskell and #haskell for feedback
20:49:47 <carter> prooftechnique: hlearn sin't for non expert use
20:49:51 <binroot> prooftechnique: I don't
20:49:51 <carter> its very cool
20:49:54 <carter> very elegant
20:50:03 <carter> its a brilliant research show case
20:50:07 <carter> of "we can build better libs"
20:50:11 <luite> oh i might need to look at hlearn
20:50:15 <carter> its not what you want to start with
20:50:15 <carter> :)
20:50:18 <carter> luite: for what?
20:50:31 <luite> for fun
20:50:47 <prooftechnique> carter: Well, maybe for an appendix, then :D
20:50:52 <carter> prooftechnique: nah
21:04:51 <pyon> Is there any GHC extension that lets me import a module minus a specific type class instance?
21:06:00 <shachaf> No.
21:06:55 <pyon> I want to make my own Text.Parser.Token.TokenParsing instance for Text.Trifecta.Parser.Parser. The only solution would be using a newtype and deriving all instances except that of Text.Parser.Token.TokenParsing, right?
21:06:57 <prooftechnique> How horrific would the work be to get a more powerful module system in GHC?
21:07:14 <prooftechnique> I always hear that OCaml's is much more powerful, but I don't really know what that entails
21:07:50 <prooftechnique> pyon: Orphan instances are evil, so that would be the nice thing to do, anyway :D
21:08:29 <pyon> prooftechnique: Opaque signature ascription is a very powerful thing in ML. You do not need to make newtypes - just make the module export an opaque type.
21:09:21 <pyon> prooftechnique: So, inside the module, the type t could be int or whatever (not a newtype wrapper), and outside the module t is an abstract type.
21:10:31 <prooftechnique> That does sound useful
21:11:07 <dmj`> prooftechnique: might want to check out spj's backpack project
21:11:12 <dmj`> http://www.mpi-sws.org/~skilpat/papers/backpack-paper.pdf
21:12:03 <pyon> prooftechnique: And, of course, functors (functions from modules to modules) are incredibly powerful. Ironically, I think the main thing preventing ML modules from reaching their fullest potential is the lack of purity.
21:12:05 <prooftechnique> dmj`: I definitely will. Thanks for the link. I've seen references to the paper before but haven't actually read it.
21:12:05 <carter> backpack is a first epxloration
21:12:20 <carter> prooftechnique: backpack is a first foray
21:12:25 <carter> not the final answer
21:12:41 <prooftechnique> Right
21:15:09 <enthropy> pyon: I think you're supposed to make a newtype of Parser to write the TokenParsing instance
21:15:19 <caseof> HM.map :: (v1 -> v1) -> HashMap k v1 -> HashMap k v2 but I need  Monad m => (v1 -> m v2) -> HashMap k v1 -> m (HashMap k v2)      Is there hope :) ?
21:15:42 <enthropy> with -XGeneralizedNewtypeDeriving, you don't have to re-write all of the instances you don't need changed
21:15:49 <caseof> How can I construct this function?
21:15:55 <erisco> how can I identify the fanouts and splits? https://docs.google.com/drawings/d/1Cd1pxktyeH8A6YrQ3tKWpPTs3MFQ2x5zqaWPVVnvDqQ/edit?usp=sharing
21:15:57 <pyon> enthropy: Yeah. I just wanted to know if I could avoid doing that.
21:17:00 <erisco> I need to uniquely identify the nodes. This would seem to require A) a global, mutable variable to keep an incrementing unique index or B) the nodes be mutable so they can be re-indexed to be unique (which would be expensive)
21:17:26 * hackagebot zip-archive 0.2.2 - Library for creating and modifying zip archives.  http://hackage.haskell.org/package/zip-archive-0.2.2 (JohnMacFarlane)
21:18:03 <carter> @hackage data-reify is your friend @erisco
21:18:03 <lambdabot> http://hackage.haskell.org/package/data-reify is your friend @erisco
21:19:44 <erisco> carter, thanks. can you briefly describe how it will help? their website is down
21:19:55 <carter> erisco: the github repo is better
21:22:04 <erisco> carter, I presume this package helps with the unique labelling of nodes by use of mutable labels?
21:22:10 <carter> yes
21:22:15 <carter> and uses ghc stable-names to help
21:22:20 <erisco> and if graphs A and B are combined, I presume it helps with re-labelling
21:22:40 <carter> https://github.com/ku-fpg/data-reify/blob/master/examples/simplify.hs  https://github.com/ku-fpg/data-reify/blob/master/examples/example1.hs
21:22:41 <carter> no
21:22:50 <erisco> ah, so stable names use memory addresses
21:23:28 <erisco> that is quite ideal. thanks
21:24:58 <erisco> other than I presume it makes the garbage collector unhappy
21:26:31 <carter> erisco: nope, stable === they stay the same
21:26:36 <carter> GHC has magic powers
21:26:44 <carter> and stable-names are supported by tghc\
21:44:46 <erisco> carter, yes which would probably mean the GC cannot move the objects
21:44:53 <carter> erisco: no
21:44:56 <carter> they can ge moved
21:45:00 <carter> stable names don't pin
21:45:18 <carter> stablenames track the moved objects ;)
21:45:28 <erisco> carter, ah, smart
21:45:35 <carter> thers a paper on it even
21:45:37 <carter> if you google
21:55:07 <arboris> what is a reasonable way to do bit blitting in haskell?
21:55:27 <carter> arboris: which thing?
21:55:51 <mzero> as in pixmap to pixmap? or pixmap to screen?
21:56:01 <arboris> pixmap to pixmap
21:56:12 <arboris> i want to create a texture atlas
21:56:17 <mzero> I suppose I'd use Vector
21:56:43 <mzero> or are you looking for existing libs?
21:56:46 <arboris> i guess i could use OpenGL directly
21:57:23 <arboris> mzero, not necessarily I would be happy to find out how to write something like that without resorting to just manipulating pointers like in C
21:57:39 <arboris> it does seem to me that the vector libraries don't provide the right abstraction
21:58:54 <mzero> they would be for underlying data storage
21:59:04 <mzero> there are higher level things: JuicyPixels is one such lib
21:59:49 <mzero> There's a binding to GD
22:00:00 <mzero> http://hackage.haskell.org/packages/search?terms=image
22:00:53 <mzero> joy - another build of Haskell Platform --- "only" 25 min.
22:01:06 <mzero> sigh... working on a build system for a big build is somewhat frustrating!
22:03:23 <arboris> mzero: JuicyPixel does only provide writePixel as far as I can tell, it would be very inefficient to do the blitting pointwise.
22:04:18 <mzero> gotcha - well... dunno - there does seem to be a zillion image packages...
22:04:26 <mzero> .... hackage search isn't really that useful, eh?
22:04:32 <arboris> mzero, no not really :(
22:07:03 <arboris> all you really need is slicewise copying, a[x0:x1,y0:y1] = b
22:07:05 <mzero> arboris: http://www.haskell.org/haskellwiki/Applications_and_libraries/Graphics
22:11:09 <AfC> >< is an infix operator in Data.Sequence. I have imported it qualified, as Seq
22:11:37 <AfC> If I want to use it prefix, as a function, how does one do that qualified? I tried
22:11:44 <AfC> Seq.(><) but that barfed
22:12:51 <enthropy> (Seq.><)
22:13:01 <enthropy> if you want it prefix
22:13:09 <enthropy> > 1 Prelude.+ 1
22:13:10 <lambdabot>  2
22:14:16 <enthropy> probably you can import Data.Monoid and use <> instead
22:16:53 <arboris> mzero, I think my best bet is to just implement the functionality in c and write a foreign function wrapper
22:22:33 * hackagebot language-openscad 0.1.2 - A simple parser for OpenSCAD  http://hackage.haskell.org/package/language-openscad-0.1.2 (BenGamari)
22:24:45 <niotepx> If I were to put `let` into a function that is run in a loop, how many times would the variable used with `let` be allocated/deallocated?
22:25:17 <niotepx> example: let x = 2
22:25:42 <niotepx> runAdd x 2 = do
22:25:42 <scshunt> that's an implementation detail, really
22:25:46 <niotepx> oh?
22:27:22 <niotepx> If the loop were run 5 times, would that variable be allocated/deallocated 5 times?
22:27:34 * hackagebot cryptohash-cryptoapi 0.1.1 - Crypto-api interfaces for cryptohash  http://hackage.haskell.org/package/cryptohash-cryptoapi-0.1.1 (VincentHanquez)
22:27:36 * hackagebot cryptohash-cryptoapi 0.1.2 - Crypto-api interfaces for cryptohash  http://hackage.haskell.org/package/cryptohash-cryptoapi-0.1.2 (VincentHanquez)
22:32:34 * hackagebot packer 0.1.5 - Fast byte serializer and unserializer  http://hackage.haskell.org/package/packer-0.1.5 (VincentHanquez)
22:37:10 <jle`> writing my first control flow monad
22:37:14 <jle`> such disorient
22:42:36 * hackagebot x509 1.4.11 - X509 reader and writer  http://hackage.haskell.org/package/x509-1.4.11 (VincentHanquez)
22:47:36 * hackagebot egison-tutorial 3.3.1 - A tutorial program for the programming language Egison  http://hackage.haskell.org/package/egison-tutorial-3.3.1 (SatoshiEgi)
22:50:17 <ski> jle` ?
22:51:58 <jle`> sort of like Process from distributed-process
22:52:03 <jle`> um
22:52:08 <jle`> writing a websockets wrapper for ghcjs
22:52:22 <jle`> that sort of mimics distributed-process's api
22:52:41 <jle`> well, just the monad part.
22:53:02 <jle`> so you would do withConn :: Text -> Process ()
22:53:22 <jle`> where in a Process monad you can "expect"/await new things from the web socket
22:53:37 <jle`> or send things back
22:53:39 <jle`> and liftIO into IO
22:53:52 <jle`> i think...i might be reimplementing pipes or something.
22:54:49 <jle`> echoProcess = forever $ do { inp <- expect; liftIO $ putStrLn inp }
22:56:09 <AfC> enthropy: Ah. Works. I tried (Seq.(><)), which didn't.
22:56:10 <jle`> yeah...i could just use pipes haha.
22:56:23 <AfC> enthropy: thanks
22:56:25 <jle`> and have an emitter that emits the websocket inputs
22:56:30 <jle`> *messages
22:56:36 <jle`> *Producer
22:57:37 * hackagebot engineering-units 0.0.0 - A numeric type that automates engineering units.  http://hackage.haskell.org/package/engineering-units-0.0.0 (TomHawkins)
22:57:49 <jle`> but where is the fun in that
23:16:13 <augur> whats the pretty printing function that handles parens?
23:55:21 <czro_> how can I make function that has the signature a -> Maybe Double to work with maybe a as first argument? I
23:56:06 <Iceland_jack> :t (>>=)
23:56:07 <lambdabot> Monad m => m a -> (a -> m b) -> m b
23:57:13 <czro_> Iceland_jack: gaaah! I feel soo stupid. Thanks.
23:57:32 <Iceland_jack> :)
