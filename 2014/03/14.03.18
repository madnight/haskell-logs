00:11:44 <vivaldi> :t foldr
00:11:45 <lambdabot> (a -> b -> b) -> b -> [a] -> b
00:12:11 <vivaldi> hello, I don't understand the (a->b->b) part in :t foldr
00:12:27 <vivaldi> why isn't it (a->a->a)
00:12:27 <MP2E> that means foldr takes a function that itself takes two arguments
00:12:40 <MP2E> because and b could be different types(and in fact, usually are)
00:12:44 <MP2E> a and b*
00:12:44 <tikhon> vivaldi: it doesn't have to be: you start out with a "seed" b value and keep on adding to it
00:12:56 <tikhon> :t foldr
00:12:57 <lambdabot> (a -> b -> b) -> b -> [a] -> b
00:13:04 <ion> > foldr (:) [] [a,b,c,d,e]
00:13:06 <lambdabot>  [a,b,c,d,e]
00:13:07 <tikhon> note the extra -> b argument right before the -> [a] part
00:13:13 <ion> @type foldr `asTypeIn` \f -> f (:) []
00:13:14 <lambdabot> (a -> [a] -> [a]) -> [a] -> [a] -> [a]
00:14:34 <vivaldi> I still couldn't imagine a case that f takes two arguments of different types..
00:15:03 <vivaldi> and returns a type of 2nd argument
00:15:03 <ion> The identity foldr (seen above) takes (:) :: a -> [a] -> [a] as the first parameter.
00:15:05 <MP2E> take sum for instance, if you were to implement that type a would be the list and type b would be the count
00:15:08 <tikhon> consider combining numbers into a string with show
00:15:08 <MP2E> so it would be an Int
00:15:40 <tikhon> foldr (\ n str -> show n ++ " " ++ str) "" [0..4]
00:15:43 <tikhon> > foldr (\ n str -> show n ++ " " ++ str) "" [0..4]
00:15:44 <lambdabot>  "0 1 2 3 4 "
00:15:49 <tikhon> does that make sense?
00:15:55 <tikhon> note:
00:15:59 <tikhon> :t (\ n str -> show n ++ " " ++ str)
00:16:01 <lambdabot> Show a => a -> [Char] -> [Char]
00:16:18 <tikhon> well, think of it as Int -> String -> String
00:16:32 <tikhon> we start with an empty String and produce a String at the very end
00:16:37 <tikhon> but every element in the list is a number
00:17:34 <vivaldi> for example :
00:17:47 <vivaldi> foldr (*) 1 [1..6]
00:18:00 <vivaldi> is it the same here?
00:18:12 <ion> Yes because
00:18:14 <ion> @type (*)
00:18:16 <lambdabot> Num a => a -> a -> a
00:18:26 <akurilin> Any of you guys here done the Tony Morris course? I'm wondering why in this one case it looks like their custom fmap takes 3 params rather than just 2 as per definition. https://github.com/AKurilin/course/blob/alex/src/Course/Functor.hs#L57
00:19:04 <vivaldi> ok thanks a lot to everyone
00:20:00 <apples> akurilin, does it help to take the x off of the LHS? (<$>) f g = \x -> f $ g x
00:20:23 <ion> akurilin: “instance Functor ((->) t)”. That is, “fmap :: Functor f => (a -> b) -> f a -> f b” instantiated with f = (->) t: “fmap :: (a -> b) -> (t -> a) -> (t -> b)”. Can you come up with the correct definition for that type?
00:20:24 <tikhon> akurilin: that's defining an *instance* for the type (->) r
00:20:24 <tikhon> you can think of it as the type (r ->)—functions from a given argument
00:20:33 <ion> @quote stereo
00:20:33 <lambdabot> xplat says: Welcome to #haskell-blah, where your bot commands are executed in triumphant stereo!
00:21:06 <tikhon> consider this:
00:21:07 <tikhon> :t fmap
00:21:08 <lambdabot> Functor f => (a -> b) -> f a -> f b
00:21:15 <tikhon> now we replace f by (r ->)
00:21:24 <tikhon> (a -> b) -> (r -> a) -> (r -> b)
00:21:28 <tikhon> does it make more sense now?
00:21:57 <akurilin> Let me think about what you guys just wrote, still pretty fresh here.
00:22:24 <tikhon> a really cool thing is that they *could* have written it as
00:22:32 <tikhon> (f <$> g) x = f $ g x
00:22:44 <tikhon> @let (f ∘ g) x = f $ g x
00:22:44 <lambdabot>  Parse failed: Illegal character ''\136''
00:22:46 <tikhon> aww
00:22:47 <tikhon> weak!
00:22:51 <tikhon> no Unicode :(
00:23:17 <tikhon> @let (f .$. g) x = f $ g x
00:23:19 <lambdabot>  Defined.
00:23:22 <tikhon> :t (.$.)
00:23:23 <lambdabot> (t1 -> t) -> (t2 -> t1) -> t2 -> t
00:23:27 <tikhon> voilà
00:30:31 * hackagebot egison 3.3.3 - Programming language with non-linear pattern-matching with backtracking  http://hackage.haskell.org/package/egison-3.3.3 (SatoshiEgi)
00:31:01 <Javran> @hoogle (Bounded e, Enum e) => [e]
00:31:04 <lambdabot> Prelude enumFrom :: Enum a => a -> [a]
00:31:04 <lambdabot> Prelude maxBound :: Bounded a => a
00:31:04 <lambdabot> Prelude minBound :: Bounded a => a
00:31:34 <Javran> is there a shorthand for [minBound .. maxBound] ?
00:31:45 <no-n> are there any good little exercises that are good for building skill/intuition with applicative functors?
00:31:47 <akurilin> Well the part I'm not sure about is how you can go from fmap taking one function and something that's a functor to taking two functions and a functor. Wouldn't you need to compose the two functions before passing them in as the first param for this to work?
00:33:02 <ion> javran: [minBound ..] or Data.Universe.universe for its instances or Data.Universe.Helpers.universeDef for any Bounded + Enum.
00:33:57 <ion> akurilin: You can substitute “(->) r” for “f” mechanically in “(a -> b) -> f a -> f b” and the only sensible implementation of that type is the one you have seen.
00:35:30 <Javran> ion: I see, thanks.
00:35:32 * hackagebot egison-tutorial 3.3.3 - A tutorial program for the programming language Egison  http://hackage.haskell.org/package/egison-tutorial-3.3.3 (SatoshiEgi)
01:10:31 <haasn> no-n: you could try reasoning about why (Const x) can't be a Monad (no matter how many constraints you place on x)
01:10:45 <haasn> but it can be an applicative given sufficient constraints on x (write the instance!)
01:11:58 <supki> haasn: what about  x ~ ()
01:12:17 <haasn> supki: same
01:12:28 <haasn> (try it!)
01:12:57 <supki> really?
01:13:07 <favetelinguis> hi all
01:13:11 <supki> I think Const () is isomorphic to Proxy and Proxy is a Monad
01:13:12 <haasn> well, it depends on how lenient you're being; you could cheat and define everything as = Const ()
01:13:18 <haasn> but that's distinct from Const _|_
01:13:19 <supki> yes
01:13:55 <favetelinguis> i have problems with syntastic any one good with that_
01:14:32 <haasn> so the monad laws would technically be violated for Const () >>= \_ -> return undefined
01:14:32 <pyon> When using associated families, if a class "Foo s" has a type member "Bar s", is it possible to require that there must be an instance "Baz (Bar s)"?
01:16:07 <pyon> Namely, I have two classes "Stream s" and "Backtrack p". The latter has a type member "UnderlyingStream p", and I want to make sure that there is a Stream instance for "UnderlyingStream p".
01:16:23 <pyon> Or perhaps functional dependencies are better suited for this problem?
01:17:01 <haasn> pyon: what about: class Stream (UnderlyingStream s) => Stream s where
01:17:26 <haasn> but I'm not sure if that terminates sanely
01:17:46 <pyon> haasn: You mean "class Stream (UnderlyingStream p) => Backtrack p where..."?
01:17:52 <haasn> oops, yes
01:17:59 <haasn> then it should terminate too, I think
01:18:07 <haasn> rather than the recursive case I was thinking of ;)
01:18:09 <poucet> How do I define Eq and Show for the following type: data Fix f = Fix (f (Fix f))
01:18:26 <poucet> Auto-deriving doesn't seem to work and I'm not quite sure how to set up the constraints, as f has kind '* -> *'
01:19:00 <pyon> haasn: Whoa, I did not know that was possible. (With -XFlexibleContexts)
01:19:16 <haasn> poucet: have you tried: deriving instance Show (f (Fix f)) => Show (Fix f) -- ?
01:19:22 <haasn> with -XStandaloneDeriving
01:19:44 <pyon> Now I only have to come up with a better (shorter) name than UnderlyingStream. :-P
01:20:07 <poucet> haasn: that needs Flexible contexts
01:21:44 <haasn> poucet: so enable flexible contexts :P
01:21:55 <poucet> fair enough :)
01:22:19 <poucet> Do you happen to know the default generated show instance? I'd like to match it.
01:23:14 <haasn> poucet: you can invoke ghc with -ddump-deriv to show derived instances
01:23:21 <poucet> ty
01:24:16 <poucet> haasn: Seems I also need undecideableinstances
01:24:26 <poucet> And lats I checked, those aren't too kosher
01:24:36 <poucet> instance (Eq (f (Fix f))) => Eq (Fix f) where (Fix a) == (Fix b) = a == b
01:24:45 <poucet> ariable occurs more often in a constraint than in the instance head in the constraint: Eq (f (Fix f))
01:28:09 <fredder> Rum daddy doo daddy dee.
01:28:11 <fredder> blaggy bluck to the bluck a leckel blickel!  Trax a mix reg norge.  Chak chip chilli lip.  Maggity heg hole potatoe.  bluggity blik bag to the bluk a blicky bluk.  Wunna mah loe mic tatum.  wunna mah low mic tatum!  reggity dick ash.  busta hurts o dip we dip, my oh my we flip we  dip.  put the foon most own your blip, when I dip you dip we dip
01:28:14 <fredder> i waas skoggin along when something took my eyes away from the ground  kind of like mad debbies banana cake 8 marks out of ten (as near pefection as human can achieve), when she gets manic-2 she cooks twenty at a time, and then brings them to the homeless shelter at 5am in the morning.
01:28:16 <fredder> Yo'in what we saying with our chimp out spam!  Is anyone out there a rump rastin rider?  Rem dem lie-card.  Shodie Shum Bam.  Ego shocking shim sham  Ralla glecky glue barg.  To jella, too jealous, to jellify you  Has anyone juckered the bloopa licta lupper?
01:28:18 <fredder> Fredder reader roadie!  Fredder, reeder!  Freeder reader roadie!  Choo Fornex Moon!  Grime Read Blagh.  Hucka Lucka Jenkinship.  Rooby boop bab   Snow snaw snobophone   Hells a fuckin foo!  My suddenly chucka lucka ling way!  Blub up your room, black ass bloom!  Rye demminy yay!  Fuckin buckin bitchhole!
01:28:20 <fredder> get a electric egg cooker and get a power inverter. regger duck a licker!  Ridin my jolts, ridin my shoes.   Anyone got an electrifier chubber?  i got the ab doer!   I've got an electric egg dicker!  Egga trella licker!  Fuck duck dick dad!
01:28:23 <fredder> Reckity knick knack the rep tep hegger.  Isn't it awful how it's jeckally jewish?  Poona mah nuff miff the peenified   Tank the teeius tanker.  The shiny dot in the middle of a line, ruck tuck tegger, ruck tuck time.  Gigga McKompfrin.  Rum dicka day material map.
01:28:27 <fredder> Partinks spee spaga speel scrap.  Ruda Trooda.  Ejection request.  Heffy the jello wup.  Juffo-wup!  rab locid rebbasmoth.  The Proteus Animal Plannable.  Poo da Boo!  need 10-15 people straight  Groaning my grurch nords.  Ruh ninna knaw knife
01:28:29 <fredder> agrillio mellish.  Blakes my bog.  kedda mah go go mageezik  Renna manuck to the ruthafied sneffal  The Rump Shaking Rider Crew - Fuck You!  Wren a men a menna menna moo, filling my jolts and filling my shoe, plenk a  peek a pokie zal nawl knife
01:28:31 <fredder> Shaar nag lililly linomp nip.  Many mini minotaur taurs, hate tar tar sauce.  I am a robibbob meme.  Have you ever thought about where the bird goes?  Squirnish Mernish.  Jelly jolaggalan joo!  Chuh lap lap rillip.  Oh I grew three years.  I'm old now.
01:28:33 <fredder> Does anyone heck teck the rooga beega bagga?  Hebber master hoon a ferr fee.  Hilly a mackhole.  The shiny dot in the middle of a liddle light, of the middle of a lep lep lains!  Gotta get that schit ass shcrap  biteoad.  Ruproudj a malef loo
01:28:35 <fredder> Moistie bather.  riberian schmecklef  Mulla Malee loo lup the new flood wars.  Chuddy dip, chuddy dip, chuddy microchip.  Bucka lucka loo, bucky lucky blay.  Bucka lucky blay lee.
01:28:37 <fredder> Burpaline: The wonder world.  Salmy magoo goal greggats  Rump duh duh duh dump, duh duh duh demp doop dump, runna nuh nah  Riggity ass gaggags  i nick  Roddan raldwell  Roady carewell reggal mahole  Rup tup shmelly smelly shmebb ub.  Roady farewell rose bose mahaggal.  A pocahontas watch
01:28:40 <fredder> Blubbity ash hoosh her mellopath.  a Maticake for my buddy andy  Oh we-heh-heh-hell I'm thinking about the greg nargs, I'm thinkin about you!  End midal too walkin' with a dolphin.  I went up that street, you went up another street, we all up the presidio.  I'm goin out with arsenio!
01:28:42 <fredder> fuckin bone screllalidge moink.  ruggity fucker fagger. rum dum dacka lacka rum dum jay  Go out with jay, another blue jay we fixed my astercoil plather  I'm hickin' my dagger  Rum dickily toon witherspoons.  I'm a falcons baleiva work with the yake my 7'9'er forever tumchy tither
01:28:45 <fredder> i wrote my life story on my poop pad.  one of the greatest art exhibits of 1999 was in a new york museum of art.  In it, cow poop or fecal matter was put on a copy of the painting called "The Last Supper".  This was thought to be a form of modern art.  chumpin up the rears.  Rubb blillick bath.
01:29:12 --- mode: ChanServ set +o Cale
01:29:19 <poucet> @op
01:29:19 <lambdabot> Maybe you meant: yow wn v rc pl id do bf @ ? .
01:29:31 <Cale> oh, already left, and I don't have joins/parts turned on
01:29:38 <Cale> @where ops
01:29:38 <lambdabot> arjanb bos byorgey Cale conal copumpkin dcoutts dibblego dmhouse dolio dons edwardk elliott geekosaur glguy Heffalump Igloo jmcarthur johnw kosmikus Lemmih monochrom nyc Philippa Pseudonym quicksilver roconnor Saizan shachaf shapr sjanssen ski sorear SyntaxPolice xerox
01:29:43 <poucet> lost ops :D
01:29:49 <Cale> Anyone else around who can see who to ban? :)
01:30:05 --- mode: Cale set -o Cale
01:30:11 <poucet> I have a whowas
01:30:12 <Zer000> fredder
01:30:13 <poucet> fredder [~radder@119.56.235.83]
01:30:13 <Zer000> ?
01:30:17 <peteretep> He got k-lined
01:30:19 <peteretep> he's noit coming back
01:30:22 <Cale> ah, okay, no need then
01:30:27 <Zer000> what does k-lined mean?
01:30:34 <poucet> Zer000: banned from irc-server
01:30:35 <peteretep> Zer000: It means he was banned at a server level
01:30:45 <Zer000> oh wow, is that automatic?
01:30:52 <peteretep> Can be, but not normally
01:31:07 <peteretep> Zer000: Depends on the ircd
01:46:49 <bahamas> can anyone give me some feedback on this code? http://lpaste.net/101380
01:47:24 <bahamas> for example, I see that the paste lint suggests a change, although I haven't learned about "break" yet
01:49:08 <fizruk> :t break
01:49:09 <lambdabot> (a -> Bool) -> [a] -> ([a], [a])
01:49:52 <saep> > span (not . isSpace) "A B C"
01:49:53 <lambdabot>  ("A"," B C")
01:49:58 <saep> > break isSpace "A B C"
01:49:59 <lambdabot>  ("A"," B C")
01:50:05 <bahamas> aah
01:50:46 <fizruk> bahamas: can removeSpaces be replaced with words?
01:50:49 <fizruk> :t words
01:50:49 <lambdabot> String -> [String]
01:51:22 <fizruk> > words " he  llo  there "
01:51:23 <lambdabot>  ["he","llo","there"]
01:51:27 <saep> > words "A B C\nd\re f"
01:51:28 <lambdabot>  ["A","B","C","d","e","f"]
01:53:06 <no-n> > words $ replicate 100 ' '
01:53:07 <lambdabot>  []
01:55:19 <fizruk> bahamas: I think running the whole program in a try-catch block is not very functional
01:55:36 <bahamas> fizruk: that's how LYAH does it
01:56:02 <bahamas> fizruk: you're right. I can use words. I had forgotten about it
01:56:49 <winobes> would someone please tell me how to convert a function of type a -> b -> c -> d to type a -> (b,c) -> d
01:57:29 <fizruk> winobes: uncurry (f x) (y, z)
01:57:48 <fizruk> :t \f x y z -> uncurry (f x) (y, z)
01:57:49 <lambdabot> (t -> a -> b -> c) -> t -> a -> b -> c
01:58:09 <fizruk> :t \f x t -> uncurry (f x) t
01:58:09 <lambdabot> (t -> a -> b -> c) -> t -> (a, b) -> c
01:59:06 <fizruk> bahamas: I would use readMaybe or readEither from Data.Text to handle invalid input
01:59:36 <winobes> ah ha -- thank you greatly fizruk
01:59:44 <bahamas> fizruk: ok. looking at them. so you would replace "catch" with that
02:01:46 <fizruk> bahamas: I guess compute would become something like `f <$> readMaybe x <*> readMaybe y`
02:02:53 <fizruk> bahamas: hm, I also don't understand why do you convert the result to String: you will need it in the next computation
02:04:09 <bahamas> fizruk: because my stack contains strings
02:04:34 <fizruk> bahamas: perhaps your stack should contain values instead (integrals in this case)
02:04:40 <bahamas> :t (<$>)
02:04:41 <lambdabot> Functor f => (a -> b) -> f a -> f b
02:04:55 <fizruk> bahamas: <$> and <*> come from Control.Applicative
02:05:28 <bahamas> fizruk: I think they were mentioned in LYAH but only in passing. I don't remember exactly what they do
02:05:45 <bahamas> fizruk: and yes, thinking about it now, it makes sense for the stack to contain values
02:06:10 <bahamas> fizruk: I thought it would contain strings that represented something other than numbers, but that's not the case
02:06:21 <bahamas> since mathematical operators aren't pushed on the stack
02:07:08 <fizruk> bahamas: Applicative is an abstraction to handle effects. Unlike Monads they don't allow further computations to depend on previous results.
02:07:41 <fizruk> bahamas: f <$> x <*> y is just like `f x y`, but where x and y carry some effects
02:08:12 <tdammers> an intuition for <$> and <*> that works for me is that they apply a function "inside" an applicative functor, that is, you have a function f, and you pass the arguments from "inside" the functor, then return the result back into the functor
02:08:46 <fizruk> bahamas: e.g. f <$> readMaybe x <*> readMaybe y is just like f (read x) (read y), but would return Nothing if any read fails
02:08:53 <tdammers> f <$> x <*> y is like f x y, but wrapped such that the arguments to f are pulled out of the functor and the resulted is injected back into it
02:09:24 <tdammers> do { x' <- x; y' <- y; return $ f x y }
02:09:31 <tdammers> do { x' <- x; y' <- y; return $ f x' y' }
02:09:34 <tdammers> rather
02:10:43 <fizruk> bahamas: in your program you have some effects: reading the input stream of words, working with stack and handling possible read failure
02:11:10 <bahamas> I'll have to revisit the LYAH chapter about this, because it's still not clear to me
02:11:36 <tdammers> try to understand just <$> first
02:11:47 <bahamas> yup
02:12:02 <tdammers> x <- f <$> y
02:12:16 <tdammers> y is an "action" (for the purpose of this discussion)
02:12:17 <tdammers> f is pure
02:12:24 <tdammers> now, you could do:
02:12:28 <tdammers> x' <- y
02:12:33 <tdammers> let x = f x'
02:12:43 <tdammers> something like that
02:12:55 <tdammers> but being able to just tack the pure function onto the action is convenient
02:13:09 <fizruk> bahamas: you could encode this effects in a parser monad with state (stack is your state), but you actually need only Applicative (+ Alternative for parser) here
02:13:40 <tdammers> hint: fmap, liftM, liftA, and <$> are really the same thing, more or less
02:18:37 <bahamas> a lot of what you guys are saying is new to me. anyway, thank you for the feedback. it's much appreciated
02:19:06 <pyon> I know instances are always global, but, can I can control what classes are exported from a module?
02:20:07 <fizruk> pyon: why would you need that?
02:20:48 <pyon> fizruk: Because I defined a couple of classes just to reduce the amount of boilerplate in my own internal code, but they are not meant to be used (or even seen) by anyone else.
02:22:28 <pyon> By the way, here is the code in question: http://lpaste.net/101386 -- if anyone knows how I could reduce the amount of boilerplate without using the Backtrack and Feeder classes, please tell me how!
02:24:35 <pyon> -XDeriveFunctor is great help. The Backtrack and Feeder classes "morally" add the same kind of boilerplate that the explicit Functor instances would add.
02:25:01 <fizruk> pyon: hm... I think you would need to declare classes in a separate module
02:25:15 <bahamas> can anyone explain the error at the bottom of the code here http://lpaste.net/101380?
02:25:17 <pyon> Dang. :-|
02:25:49 <tdammers> pyon: a common convention is to have a module Foo.Bar.Internal
02:25:57 <no-n> it's interesting to think of a function as a functor over a return value
02:26:07 <tdammers> pyon: import that into Foo.Bar, then explicitly re-export what you want to expose
02:26:25 <fizruk> bahamas: error ("..." ++ x)
02:26:28 <pyon> tdammers: Ah! Sounds like a good idea!
02:26:38 <fizruk> bahamas: what you wrote is (error "...") ++ x
02:26:46 <tdammers> pyon: it's still technically possible to import Foo.Bar.Internal from outside your own library, but the "Internal" name should be enough of a red flag to keep people from doing it carelessly
02:27:01 <bahamas> fizruk: oh, damn. I keep forgetting about that. thanks
02:27:16 <fizruk> bahamas: you could also write error $ "..." ++ x
02:27:25 <pyon> tdammers: So a cabal package always exposes ALL its modules, not just the ones I want to expose? :-O
02:28:10 <tdammers> pyon: hmm, no, don't think so - never actually tried it, really
02:28:15 <fizruk> pyon: expose Internal modules, or there'll be people who would hate you for hiding them
02:28:32 <tdammers> ah yes... good point
02:28:36 <bahamas> fizruk: yeah, that's what I use, when I don't forget about it
02:29:58 <pyon> fizruk: I am not against people being able to read the source for my internal modules, just against them breaking my abstractions in their code.
02:31:33 <bahamas> in the "process acc x" function above, why does ghc ask me to define a Read instance for x?
02:32:08 <quicksilver> bahamas: because you call 'read' on it
02:32:16 <bahamas> actually, it's talking about "Read a", so it assume x to be of type a
02:32:28 <bahamas> quicksilver: yes, but for me x is a String
02:32:35 <xpika> say i have two lists a and b both the same type and i want to zipwith them until which point the other runs out and the left over values are left unchanged. What is the bestway to do this?
02:32:43 <quicksilver> bahamas: sorry, I misspoke
02:32:50 <quicksilver> bahamas: it's not a read instance on x (which is a string as y ou say)
02:33:06 <quicksilver> bahamas: it's a read instance on your type 'a'
02:33:15 <quicksilver> the thing you are pushing into 'acc'
02:33:20 <fizruk> pyon: some other libraries may use your Internal modules. IIRC this is the situation with bytestrings. I'm not expert here though
02:34:13 <bahamas> quicksilver: this is the updated code and full error http://lpaste.net/101380
02:34:38 <fizruk> xpika: perhaps this'll help: http://hackage.haskell.org/package/these-0.3/docs/Data-Align.html
02:34:43 <xpika> example: let {a="###";b="st";f=const} ... => "st#"
02:34:58 <fizruk> xpika: could be an overkill though
02:35:22 <fizruk> xpika: but alignWith is conceptually what you want here
02:35:35 <bahamas> quicksilver: I don't understand what you mean.
02:36:11 <quicksilver> bahamas: push acc (read x)
02:36:24 <quicksilver> bahamas: you are adding something to the list acc, right?
02:36:32 <bahamas> quicksilver: correct
02:36:39 <quicksilver> bahamas: that thing needs a Read instance
02:36:44 <quicksilver> because you're reading it from a string
02:37:51 <bahamas> quicksilver: I thought you only needed to add Read instances to the things that you pass to "read" not also to what "read" returns
02:38:23 <quicksilver> bahamas: you had it exactly backwards.
02:38:27 <quicksilver> you always pass a String to read
02:38:33 <quicksilver> that doesn't vary
02:38:42 <quicksilver> it's the type returned that needs the instance
02:38:46 <bahamas> ah, you're right about that
02:39:02 <xpika> fizruk: a little overkill.
02:39:03 <fizruk> pyon: have you tried using Alternative instead of Backtrack and Feed?
02:39:20 <bahamas> quicksilver: thanks
02:39:33 <pyon> fizruk: Actually, I need this in order to make Alternative work.
02:40:33 <pyon> fizruk: Every individual parser is supposed to backtrack to the original position when it fails. So, in a sequenced parser "p <*> q", if q fails, I need to make sure I can go back to before p was attempted.
02:40:34 <fizruk> pyon: the paste you linked does not have Alternative instance
02:40:55 <pyon> fizruk: Yeah, I am still in the middle of coding it. (And I got distracted talking in ##programming.)
02:45:42 <jle`> (a -> IO b) -> Maybe a -> IO (Maybe b) ?
02:46:17 <jle`> fmap and sequence, maybe?
02:46:27 <jle`> i think i can probably do it using MaybeT
02:46:34 <jle`> @unmtl MaybeT IO
02:46:34 <lambdabot> Plugin `unmtl' failed with: `MaybeT IO' is not applied to enough arguments, giving `/\A. IO (Maybe A)'
02:46:39 <jle`> @unmtl MaybeT IO a
02:46:39 <lambdabot> IO (Maybe a)
02:46:49 <jle`> but that might be overkill
02:47:43 <fizruk> :t traverse
02:47:44 <lambdabot> (Applicative f, Traversable t) => (a -> f b) -> t a -> f (t b)
02:47:49 <fizruk> jle`: ^
02:48:00 <jle`> ah.
02:48:02 <jle`> ty
02:48:11 <jle`> actually fmap and sequence is just mapM
02:48:14 <jle`> @src mapM
02:48:14 <lambdabot> mapM f as = sequence (map f as)
02:48:17 <jle`> i'm silly
02:49:31 <pyon> What does @unmtl do? :-O
02:49:47 <Taneb> @unmtl Reader Int Bool
02:49:48 <lambdabot> Int -> Bool
02:49:54 <pyon> Oh.
02:50:04 <Taneb> @unmtl StateT Int Maybe Char
02:50:04 <lambdabot> Int -> Maybe (Char, Int)
02:50:56 <jle`> @help unmtl
02:50:56 <lambdabot> unroll mtl monads
02:54:05 <jle`> is join really not in prelude?
02:54:27 <Taneb> jle`, nope, it's in Control.Monad
02:55:16 <quchen> Stay tuned! :-D
02:55:53 <quchen> You'll have to wait for 7.10 for that. Wait and hope.
02:57:24 <merijn> pyon: mtl is the monad transformer library, so it translates monad transformer stacks :)
03:04:41 <pyon> merijn: Oh, I know what the mtl is... I just failed to see "unmtl" as "un-mtl".
03:05:50 * hackagebot Spock 0.4.3.3 - Another Haskell web toolkit based on scotty  http://hackage.haskell.org/package/Spock-0.4.3.3 (AlexanderThiemann)
03:06:31 <jle`> is Uhara next
03:18:27 <pyon> Is there an "instance Monoid e => Alternative (Either e)" ?
03:20:38 <quicksilver> no, because there is instance (Error e) => Alternative (Either e) , I think
03:20:41 <quicksilver> regrettably
03:21:20 <pyon> Aw. :-(
03:21:55 <supki> pyon: there's  Monad m, Monoid e => Alternative (EitherT e m)  in either package
03:26:09 <honza> Given: data Name = Name String --- how can I get at the contents of a value of type Name without using pattern matching? When using records syntax, you get a function with the same name but when it's like this?
03:27:06 <fizruk> honza: I don't think it's possible
03:27:17 <honza> fizruk: alright, thanks!
03:27:53 <honza> I have these weird monadic compositions like: f >>= \(Name n) -> print n
03:28:41 <kadoban> honza: you can of course just define your own function that does it, based on pattern matching
03:28:48 <honza> yes
03:30:08 <zomg> You could define a functor instance for it and use fmap or something =)
03:30:20 <zomg> Though that might be blatant abuse of how it works
03:31:24 <merijn> I have changed my mind, instead of "head :: [a] -> Maybe a", Prelude should clearly have "head :: (Foldable t, Alternative f) => t a -> f a"
03:32:23 <merijn> honza: You can use record syntax
03:32:25 <Taneb> merijn, head on a Set doesn't particularly make sense
03:32:32 <merijn> Taneb: Irrelevant!
03:32:35 <merijn> Taneb: Also it does
03:32:39 <merijn> They have a least element
03:33:07 <merijn> honza: "data Name = Name { getName :: String }", now "getName :: Name -> String"
03:33:22 <honza> merijn: yep, true
03:34:49 <merijn> honza: That's actually rather common, and in this case you may want to use newtype instead of data
03:35:01 <merijn> honza: Since newtype has no runtime overhead
03:35:16 <Taneb> @type headOf folded
03:35:17 <lambdabot> Foldable f => f a -> Maybe a
03:35:54 <Taneb> @type maybe empty pure . headOf folded
03:35:55 <lambdabot> (Foldable f1, Alternative f) => f1 a -> f a
03:36:11 <quicksilver> Taneb: "unfortunately" a Foldable instance creates a canonical order on the type
03:36:11 <honza> merijn: thanks, i always forget the difference between newtype and data, and data ends up being easier to type :)
03:36:35 <quicksilver> Taneb: so you can certainly do "head . toList" or "listToMaybe . toList"
03:36:39 <quicksilver> feels ugly.
03:36:49 <Taneb> :(
03:37:00 <quicksilver> then again Monoids are not (necessarily) commutative
03:37:08 <quicksilver> so fold does imply a choice of ordering.
03:37:13 <Taneb> I'd say some foldables only make sense with commutative monoids
03:37:20 * quicksilver nods
03:37:30 <quicksilver> don't think the type theory can represent that particularly well, though
03:37:33 <Taneb> But there isn't a commutative monoid class
03:37:42 <quicksilver> and the implementation would choose an order whatever you wanted to think of it
03:37:45 <merijn> honza: The difference between newtype and data is that data constructors exist at runtime, whereas newtype does not. Basically after typechecking all newtype constructors/unwrappers are eliminated and just replaced with their "actual" type
03:38:31 <honza> merijn: so why have data at all?
03:38:39 <merijn> honza: So at runtime "newtype Name = Name String" will just be String, since the typechecking phase will have already ensured that typing is done right. Which is also the reason you can only have exactly one constructor and one argument
03:38:49 <xpika> i find myself writing (\p f v-> if p then f v else v) white alot. is there a shorthand for this?
03:38:53 <Taneb> honza, data can have multiple constructors or fields
03:38:59 <Taneb> newtype is one constructor, one field
03:39:05 <merijn> honza: newtype can only have 1 constructor, it's constructor can only have 1 argument and it's strict
03:39:18 <quicksilver> it's a bit more than merely strict
03:39:38 <merijn> quicksilver: I know, but that's too subtle to summarise in a few words :)
03:39:43 <quicksilver> :)
03:40:21 <fizruk> xpika: can you provide more context?
03:40:25 <honza> oh right, thanks
03:40:38 <merijn> xpika: 7.8 has "cond"! :)
03:40:58 <Eduard_Munteanu> xpika: what is p usually?
03:41:06 <merijn> Or so I was told
03:41:11 <fizruk> 7.8 is not out yet?
03:41:25 <merijn> fizruk: RC2 is out, should be soon
03:41:28 <xpika> Eduard_Munteanu: a setting in my chord library on how to render the chord
03:43:46 <fizruk> merijn: that's good
03:44:18 <xpika> Eduard_Munteanu: boolean setting on wheteher to render the chord horizontally flipped.
03:45:07 <xpika> merijn: looking up cond
03:45:18 <quchen> I think 7.8 still has a few dealbreaking bugs (segfaults on Windows)
03:45:45 <quchen> https://ghc.haskell.org/trac/ghc/wiki/Status/GHC-7.8/RC2
03:45:59 <thungsten> about newtype having no runtime cost. I think that I read somewhere that if you for example convert a list of newtypes to its runtime type. It has some runtime cost. I can see if I can find where I read it
03:46:04 <lieven_> xpika: just make p either f or id
03:46:56 <quchen> thungsten: This conversion has a runtime cost the same way `map id` does.
03:46:56 <xpika> lieven_: can that shorten the code?
03:47:34 <thungsten> quchen: okay thanks.
03:48:49 <mmmm> Does anyone know why this is happening? http://lpaste.net/101394
03:50:40 <xpika> merijn: is it this one?
03:50:51 <xpika> > cond p f g x = if p x then f x else g x
03:50:52 <merijn> thungsten: Right, although 7.8 will have roles which will allow you to implement conversions like that without runtime costs
03:50:53 <lambdabot>  <hint>:1:14: parse error on input `='
03:50:57 <merijn> xpika: Yeah
03:51:38 <merijn> thungsten: Since roles will allow the implementation of a safe "coerce" function
03:51:49 <quchen> 7.8 has `bool :: a -> a -> Bool -> a` as far as I know.
03:52:34 <merijn> oh, right
03:52:42 <merijn> That's the one I was thinking of
03:52:53 <xpika> > let cond p f g x = if p x then f x else g x in cond (const True) (+1) id 99
03:52:55 <lambdabot>  100
03:52:56 <thungsten> merijn: Oh nice. I think that it's kind of weird that not all typed languages have this.
03:53:07 <merijn> thungsten: Well, it's rather complicated
03:53:53 <merijn> thungsten: The usual problem is that newtypes can have different class instances. Imagine I have Int and Age (Age being a newtype of Int, but with a different Ord instance)
03:54:30 <quchen> Imagine mapping the Down newtype over a Set.
03:54:49 <merijn> thungsten: "Map Char Int" and "Map Char Age" can be coerced safely with no issue. But since Map depends on the Ord instance of it's keys coercing "Map Int c" into "Map Age c" would break as the second would have a different Ord instance
03:55:12 <merijn> Which means Map's internal variants are broken by the coercion
03:55:29 <merijn> thungsten: The current (experimental) approach to solving this is: https://ghc.haskell.org/trac/ghc/wiki/Roles
03:57:41 <bahamas> I don't know if it's a coincidence but after seeing them implemented in haskell, I understand algorithms that I hadn't understood before
03:57:52 <thungsten> merijn: I see. I thught that it was just a typecheck followed by some kind of preprcessor substitution. Apperently It was a bit more complex.
03:57:58 <merijn> bahamas: \o/
03:58:18 <merijn> thungsten: Well you could do that, but that break some libraries and we haskellers don't like things breaking :)
03:59:08 <bahamas> merijn: maybe Haskell made me smarter :)
03:59:13 <thungsten> merijn: I hope nobody *likes* breaking libraries.
03:59:32 <tdammers> bahamas: Haskell doesn't make you smarter, it just helps you develop good taste
03:59:55 <bahamas> tdammers: then I became smarter through a different method :)
04:00:50 <bahamas> tdammers: I agree about the taste. haskell has elegance
04:01:49 <merijn> Any good tutorials/explanations of Fix/Mu/all that type level fixpoint stuff?
04:02:09 <luite> bahamas: but C has elegans
04:02:25 <bahamas> luite: what are those?
04:02:41 <luite> bahamas: http://en.wikipedia.org/wiki/Caenorhabditis_elegans
04:02:53 <luite> very well-studied nematode
04:06:02 <bernalex> what would an efficient way of doing "length $ dropWhile (==0) (reverse list)"?
04:06:12 <bahamas> luite: what's the connection? homophony?
04:06:15 <fizruk> merijn: I haven't seen one, only some sparse notes over the internet
04:06:24 <bernalex> the purpose is: given a list that is padded with 0s from the back of the list, how do you get the index of the first 0 of this padding
04:06:25 <pyon> bahamas: Look at the abbreviation of the scientific name. :-P
04:06:36 <pyon> bahamas: C. elegans
04:07:02 <bernalex> what I'm doing does reverse, and reverse is generally not very good, but IDK of a more efficient way of doing it off the top of my head.
04:07:13 <bahamas> pyon: yes and the only connection between that and what I said is that they are pronounced the same
04:07:36 <bahamas> if it was a joke, then whoosh
04:08:23 <bahamas> bernalex: first 0 from the start of the list or from the end?
04:08:49 <bernalex> bahamas: beginning.
04:08:54 <bernalex> [0, 1, 0, 1, 0, 0, 0] -- returns 4
04:09:09 <int-e> Twey: I try not to be around at 4 am ;-)
04:09:38 <luite> bahamas: hehe yeah commonly referred to as C. elegans, sorry for the poor joke :p
04:10:08 <bahamas> bernalex: ah, you may have zeros between the other elements, and you don't want the index of those
04:10:27 <bahamas> luite: homophony joke, sure :)
04:10:58 * hackagebot sodium 0.10.0.2 - Sodium Reactive Programming (FRP) System  http://hackage.haskell.org/package/sodium-0.10.0.2 (StephenBlackheath)
04:12:35 <kwstas> hi there! a question: A have a list of functions (Int -> String) and a list of Ints. What is the idiomatic way to apply the first function to the first element of the int list, the second function to the second element and so on? Currently i'm using the zipWith function, but is there any better?
04:12:54 <Iceland_jack> kwstas: zipWith ($)
04:12:59 <Iceland_jack> @ty zipWith ($)
04:13:00 <lambdabot> [b -> c] -> [b] -> [c]
04:13:03 <srenatus> kwstas: better...?
04:13:10 <bahamas> bernalex: you could have a function that goes through the list from left to right and holds the index of 0 but resets it if it encounters any element different from 0. does it make sense?
04:13:12 <srenatus> kwstas: in which metric? ;)
04:13:32 <kwstas> srenatus: s/better/beautiful
04:13:36 <kwstas> :)
04:13:53 <kwstas> Iceland_jack: so zipWith is the way to go?
04:13:53 <Iceland_jack> You can also do
04:13:54 <Iceland_jack>     [ f x | f <- fns | x <- xs ]
04:13:54 <Iceland_jack> or
04:13:57 <Iceland_jack>     [ f x | (f, x) zip fns xs ]
04:14:00 <Iceland_jack> which is clearer and more beautiful in my opinion
04:14:00 <srenatus> kwstas: oh, the highly subjective metric "beauty" ;)
04:14:04 <Iceland_jack> kwstas: basically
04:15:05 <kwstas> srenatus: yes exaclty, and if it is possible with beauty > 4 :D
04:15:08 <quchen> > let padIndex p = length . concat . init . groupBy p in padIndex (\x y -> (x,y) == (0,0)) -- bernalex
04:15:10 <lambdabot>  <[Integer] -> Int>
04:15:30 <bahamas> I like the list comp solution. it's more readable for me
04:15:34 <kwstas> Iceland_jack: thanks a lot!
04:15:48 <Iceland_jack> You're welcome :) the former one requires parallel list comprehensions
04:16:52 <kwstas> Iceland_jack: paraller l.c? is it and extension?
04:16:57 <Iceland_jack> Yes
04:17:11 <kwstas> ok!
04:17:48 <Iceland_jack> You enable it using
04:17:48 <Iceland_jack>     ghci> :set -XParallelLispComp
04:17:48 <Iceland_jack> in GHCi or using
04:17:48 <Iceland_jack>     {-# LANGUAGE ParallelListComp #-}
04:18:05 <akegalj> why is "a =<< b c" different from "a =<< b $ do\n c" ?
04:18:33 <Iceland_jack> akegalj: Because function application binds the tightest, so
04:18:33 <Iceland_jack>     a =<< b c
04:18:33 <Iceland_jack> is
04:18:33 <Iceland_jack>     a =<< (b c)
04:19:32 <Iceland_jack> The version with the do-notation is
04:19:32 <Iceland_jack>     (a =<< b) c
04:19:46 <akegalj> Iceland_jack: oh--
04:19:49 <kuribas> or a =<< b $ c
04:19:52 <akegalj> Iceland_jack: thank you :)
04:27:29 <Yuu_chan> Is there a generalization of zipWith for any Traversable?
04:28:40 <Iceland_jack> Maybe Control.Monad.Zip would be of interest
04:29:49 <Iceland_jack> Yuu_chan: It's used for parallel composition of monad comprehensions
04:29:55 <Iceland_jack> *parallel monad comprehension
04:30:09 <Saizan> Yuu_chan: i think you can write one by basically turning one argument into a list first and then traversing in the State [a] applicative
04:32:10 <Yuu_chan> I've come up with that my initial definition was incorrect, but thanks for your suggestions
04:33:35 <bahamas> Iceland_jack: is the paralel list comp that you used earlier an example of that?
04:34:33 <Iceland_jack> bahamas: That was just an example of a ‘regular’ parallel list comprehension, of course lists are monads too but they are the ‘default’ comprehension monad :)
04:35:32 <Iceland_jack> You can enable another extension to allow using arbitrary monads:
04:35:32 <Iceland_jack>     [ 2*x | x <- arbitrary ]
04:35:32 <Iceland_jack>  
04:36:56 <Yuu_chan> Iceland_jack: is it implemented already?
04:37:18 <Iceland_jack> sure
04:37:25 <aspidites> hello
04:37:27 <Iceland_jack> https://ghc.haskell.org/trac/ghc/wiki/MonadComprehensions
04:37:58 <Iceland_jack> You can write
04:37:59 <Iceland_jack>     [ x + y | x <- Just 5, y <- Nothing ]
04:37:59 <Iceland_jack> and it should give you ‘Nothing’
04:37:59 <fizruk> Iceland_jack: you broke my irc client, messages are now half-line higher
04:38:19 <Iceland_jack> fizruk: I will pay you for a new one
04:38:21 <Yuu_chan> In which version? I definitely remember I wanted to try it and got only compiler errors...
04:38:26 <aspidites> Iceland_jack: nice
04:38:46 <Yuu_chan> Hi aspidites :)
04:39:05 <Iceland_jack> Yuu_chan: Did you enable the extension? It got removed at one point but it's been in GHC for a long time now
04:39:28 <aspidites> though, i don't tend to see comprehensions around much
04:39:51 <Iceland_jack> aspidites: I'm actually considering using them quite a bit for a DSL I'm writing
04:39:57 <aspidites> i tend to see folds and maps more often
04:39:58 <Iceland_jack> I'll see how things go :)
04:40:20 <aspidites> and i don't know if its that they look sweet, or that i'm just biased because of python (yes, i know the irony in that statement)
04:40:36 <aspidites> good luck, Iceland_jack
04:40:48 <bernalex> bahamas: yes, I see. that's actually faster than doing reverse at least.
04:40:56 <bernalex> quchen: right, thanks
04:41:05 <Iceland_jack> Thanks aspidites, I'll need it
04:41:12 <quchen> bernalex: Careful because of the `init`. Also benchmark it, of course
04:41:14 <aspidites> now that i think about it, sometimes i'll write something as a comprehension because i understand them a bit better, then refactor using folds, maps, etc
04:41:35 <aspidites> has anyone had recent success compiling haskell for android?
04:41:44 <Yuu_chan> Iceland_jack: of course.
04:41:46 <Yuu_chan> ghci> :set -XMonadComprehension
04:41:46 <Yuu_chan> Some flags have not been recognized: -XMonadComprehension
04:41:49 <ZettaBlade> Holy crap, you can use multiple generators in a comprehension?
04:41:54 <aspidites> i've tried the ghc-android project on github, but the patches aren't compiling cleanly any more
04:42:05 <Yuu_chan> Oops, my bad
04:42:17 <Iceland_jack> Yuu_chan: Plural?
04:43:08 <Iceland_jack> :set MonadComprehensions or {-# LANGUAGE MonadComprehensions #-} should work
04:43:12 <Iceland_jack> *:set -XMonadComprehensions
04:44:06 <Yuu_chan> Iceland_jack: yes. But AFAIR I tried both variants in that older GHC.
04:44:15 <aspidites> the set -X method throws me for a loop, thanks to the XMonad window manager
04:44:30 <aspidites> i was thinking "There's a ghc flag for XMonad?"
04:44:43 <Yuu_chan> aspidites: :D
04:44:57 <bernalex> quchen: are you using Data.List's groupBy? I can't get it to typecheck
04:45:04 <bernalex> maybe I have a typo?
04:45:06 <bernalex> > let padIndex p = length . concat . init . groupBy p in padIndex (\x y -> (x, y) == (0, 0))
04:45:08 <lambdabot>  <[Integer] -> Int>
04:45:33 <bernalex> oh, right, I'm an idiot.
04:45:49 <bernalex> "No instance for (Show ([t0] -> Int])) was the relevant error msg, if I scrolled up a bit.
04:45:55 <aspidites> is anyone on NixOS?
04:46:02 * hackagebot Spock 0.4.3.4 - Another Haskell web toolkit based on scotty  http://hackage.haskell.org/package/Spock-0.4.3.4 (AlexanderThiemann)
04:47:33 <quchen> bernalex: Use `init' xs = zipWith const xs (tail xs)` to avoid the error on empty list
04:48:07 <bennofs> aspidites: yes me
04:49:17 <Yuu_chan> > [a + b | a <- Just 1 | b <- Just 1]
04:49:19 <lambdabot>  Couldn't match expected type `[t0]'
04:49:19 <lambdabot>              with actual type `Data.Maybe.Maybe a0'Couldn't match expected ty...
04:49:19 <lambdabot>              with actual type `Data.Maybe.Maybe a1'
04:49:57 <dv-> aspidites: yhc can build for android
04:50:13 <Iceland_jack> Yuu_chan: You can't use parallel comprehensions with the Maybe monad
04:50:18 <bernalex> quchen: yes, thanks.
04:51:06 <dv-> aspidites: er, ajhc even
04:54:34 <Yuu_chan> Iceland_jack: looks more like "You can't use parallel comprehensions with the lambdabot" :)
04:55:16 <Iceland_jack> > [ a + b | a <- [1,2,3] | b <- [10,20,30] ] -- really Yuu_chan?
04:55:17 <lambdabot>  [11,22,33]
04:55:22 <Iceland_jack> You can't use monadic comprehensions with lambdabot
04:56:26 <aspidites> dv-: i knew about ajhc but didn't see any clear instructions on the process
04:57:05 <aspidites> for instance, i wasn't sure if a lot of the stuff in the activities example repo was generated by jhc, or hand written
04:57:31 <aspidites> bennofs: before nix, what were you using? any hurdles in switching
04:57:42 <bennofs> aspidites: archlinux
04:57:53 <aspidites> the one i know of for instance is needing to use chroots for things like steam
04:57:58 <Yuu_chan> Iceland_jack: sorry, I meant monadic
04:58:07 <aspidites> ah, that's what i'm on now.
04:58:28 <Yuu_chan> Iceland_jack: guessing from "Couldn't match expected type `[t0]'"
04:58:37 <Iceland_jack> yeah :)
04:58:48 <aspidites> its nice and all, but seems like (and perhaps ocharles just spoiled me) nix would make haskell development easier -- i particularly like being able to install multiple versions of software
04:58:55 <aspidites> (painlessly)
05:00:02 <bennofs> aspidites: I use my laptop (with NixOS) mostly for browsing / programming, not gaming though :)
05:00:45 <aspidites> bennofs: thus avoiding the issue entirely :P. i think a few other non-game programs had the issue - something to do with hard-coded paths
05:01:10 <Brody> Hello guys, a few months ago I was introduced to haskell through John Carmacks speech at Quakecon. I am part way through the 'learn you a haskell for great good' tutorial. Last week I installed Linux for the first time. (debian). It occured to me during this time, why isnt there a Haskell Operating System?
05:01:12 <aspidites> how do nix expressions compare to say, bash?
05:01:42 <MP2E> Brody : not sure. I'd really like to see coreutils reimplemented in haskell, myself.
05:01:44 <aspidites> or if that's too broad, did you find it easy to learn how to make them when the repositories were lacking? for comparison, i'm thinking PKGBUILDs here
05:02:12 <aspidites> Brody: http://stackoverflow.com/questions/6638080/is-there-os-written-in-haskell
05:02:50 <aspidites> and the main ajhc guy was attempting to write a bsd kernel in haskell iirc but gave up recently
05:04:19 <merijn> MP2E: Why? And what's stopping you from doing it yourself? :)
05:05:04 <bennofs> aspidites: IMO, it's pretty easy. It took a bit of time until i understood how everything fits together. Generally, simple C/C++ programs are pretty easy to package. Gnome3 (Gtk3) apps are currently a bit of a problem and not so easy (you have to do a few tricks to get icons to work). Also, I haven't yet tried to package a program written in a scripting language like python or ruby :)
05:05:06 <MP2E> mostly to see how they would compare. I expect the haskell ones would be more fault tolerant and bug free
05:05:50 <MP2E> I dunno, maybe I'll tackle it at some point. Right now I've already got a few projects, though heh
05:05:54 <merijn> MP2E: I don't think so, mostly because the type of bugs here are environment/system's bugs which the type system doesn't help against. Plus existing coreutils have hade decades more testing/fixing for those
05:06:04 <MP2E> good point
05:06:06 <Brody> mp2e aspidites interesting stuff thanks
05:06:57 <bennofs> aspidites: but getting patches accepted upstream is just submitting a pull request :) You can find the repository at http://github.com/NixOS/nixpkgs
05:06:59 <aspidites> bennofs: tempting... i tried nix in a vm which didn't go over so well...i do have a spare hard drive partition though...
05:07:24 <aspidites> bennofs: really? wow. thats...not sure what word to use there-- neat
05:09:40 <merijn> Does the notion of a closed data family make sense? Or is it just type families for which closedness makes sense?
05:14:08 <aspidites> well thanks guys
05:14:19 <aspidites> bed time for me...yay unfulfilling job!
05:16:07 <bernalex> I thought I'd try to implement it like bahamas suggested as well, and ended up with something like: http://lpaste.net/1975721961598222336
05:16:13 <bernalex> ideas for making it less... erm not elegant?
05:16:38 <bernalex> (it's actually findPI not findpi, but I guess I hit something by a mistake in vi prior to copying, oops)
05:17:17 <Iceland_jack> bernalex: I assume you meant 'Just' and 'Nothing' where it says 'just' and 'nothing'?
05:17:33 <bernalex> Iceland_jack: yes, somehow vi made everything lowercase when I copied it, oops. :-)
05:17:49 <bernalex> is length O(n)?
05:17:52 <Iceland_jack> yes
05:18:01 <bernalex> so length, dropWhile and reverse is O(3n)?
05:18:03 <Iceland_jack> bernalex: Two quick notes, I would personally move the empty list case to the top and pattern match on n
05:18:19 <ciaranm> there is no such thing as O(3n)
05:18:28 <Iceland_jack> Sure there is! O(3n) = O(n)
05:19:09 <bernalex> ciaranm: feel free to suggest the correct notation then.
05:19:09 <kuribas> O(3n) = O(100000000000n) :)
05:19:28 <ciaranm> bernalex: O() can't deal with constant factors
05:19:32 <Iceland_jack> bernalex: You drop constant factors
05:19:49 <ciaranm> bernalex: you could use sedgewick's silly ~ notation if you really want
05:19:58 <Iceland_jack> so if you're going to think asymptotically using length once or twice is immaterial
05:20:17 <bernalex> so in big o, what's the difference between using length+dropwhile+reverse, vs doing just one iteration?
05:20:22 <merijn> Iceland_jack: Not true
05:20:22 <ciaranm> there is none
05:20:35 <bernalex> I see. what is a desirable notation for expressing this?
05:20:38 <merijn> Iceland_jack: Asymptotically != same complexity class
05:20:55 <ciaranm> bernalex: there isn't really one. you have to get very machine-specific if you want to do that.
05:21:00 <bernalex> I see.
05:21:17 <merijn> Iceland_jack: f is asymptotically better than g == "as input approaches infinity, f outperforms g"
05:21:37 <ciaranm> it's not even necessarily the case that three passes is slower than one. although it probably is if you've got more memory accesses than computation going on.
05:21:38 <merijn> Iceland_jack: f can be asymptotically better than g even if f and g have the same complexity class
05:21:45 <Iceland_jack> merijn: Right, thanks :)
05:22:38 <Iceland_jack> bernalex: You can basically make all those cases simpler using pattern matching
05:22:44 <ciaranm> now hang on. f and g don't have complexity classes.
05:22:56 <merijn> Iceland_jack: i.e. using length once is asymptotically better than using length 3 times, it's special connotation comes from 1000000000n is asymptotically better than 0.000001n^2, because as n approaches infinity the n will dominate the constant factor which means ^2 loses to ^1
05:23:07 <merijn> s/have the same/are in the same
05:23:20 <merijn> ciaranm: Bleh, that was completely clear >.>
05:23:22 <bernalex> Iceland_jack: open to suggestions
05:23:36 <ciaranm> merijn: problems have complexity classes. not functions!
05:23:37 <shiona> bernalex: At our uni on one course we spoke of complexity in number of element dereferences in array context. I guess something similar is best you can do if you want the constant factors to be there
05:23:55 <MingsPing> hi, quick question, how can i write the following function pointfree? func a b = f1 $ f2 a b
05:23:59 <shiona> or number of comparisons for sorts etc
05:24:05 <Iceland_jack> bernalex: http://lpaste.net/1975721961598222336 something like this
05:24:07 <bernalex> Iceland_jack: I assume you mean pattern matching on x and n?
05:24:16 <ciaranm> MingsPing: fmap fmap fmap f1 f2
05:24:31 <Iceland_jack> Mind you, using 4 parameters is kind of a red flag
05:24:46 <merijn> ciaranm: That depends on the setting we're discussing in, of course functions belong to a complexity class, given an implicit operational semantics for evaluating said functions
05:24:47 <bernalex> Iceland_jack: I know =/
05:24:56 <augur_> merijn: isnt it more precisely:  f is asymptotically better than g if there is some x, such that for all x' > x, g(x') >= f(x')
05:25:13 <augur_> which is to say, eventually, f is always better than g
05:25:15 <Iceland_jack> What are you trying to implement?
05:25:22 <shiona> @pl \a b -> f1 $ f2 a b -- MingsPing
05:25:22 <lambdabot> (f1 .) . f2
05:25:35 <merijn> augur_: Assuming you define order to be evaluation, then yes that'd be a good definition
05:25:53 <bernalex> Iceland_jack: I rewrote it now. it is al ot nicer.
05:25:56 <Iceland_jack> MingsPing: Sometimes people use (.:) = (.) . (.) for that
05:25:57 <Iceland_jack>     func = f1 .: f2
05:26:12 <Benzi-Junior> hey guys is there a website similar to codeacademy that teaches you haskell ?
05:26:14 <merijn> Iceland_jack: There you go, a nicer definition then mine :)
05:26:25 <benzrf> Benzi-Junior: just read lyah
05:26:25 <benzrf> :u
05:26:33 <Iceland_jack> merijn: :)
05:26:35 <MingsPing> shiona, Iceland_jack thanks :-)
05:27:19 <augur_> merijn: practical complexity is more important, i feel. i mean, if x is sufficiently large, you run into issues like, this wont matter because ill be dead before the program stops
05:27:21 <Iceland_jack> bernalex: Still, the code does not express the intent of the code: it looks like you just translated a piece of imperative code to Haskell and made all the variables into parameters
05:27:40 <augur_> merijn: iinm theres some lively research being done into practical, not asymptotic, complexity right now
05:27:43 <ciaranm> practical complexity is a pain in the ass
05:28:09 <bernalex> Iceland_jack: actually, no, I translated my length+dropwhile+reverse code to avoid three traversals
05:28:15 <augur_> ciaranm: is it? i would think its just complexity where you care about the constants
05:28:25 <ciaranm> practically, it's fairly easy to show that P = NP
05:28:34 <augur_> oh?
05:28:42 <merijn> augur_: Sure, see als PHK's "You're doing it wrong" essay in the ACM column
05:28:52 <ciaranm> you just pick an NP complete problem where the "really hard" instances are rare
05:28:57 <augur_> merijn: who's phk?
05:29:03 <Iceland_jack> bernalex: This is the problem fusion is supposed to solve, you can use Data.Vector or Data.Stream to get that
05:29:14 <merijn> augur_: Poul-Henning Kamp, well-known (Free)BSD kernel developer
05:29:16 <kuribas> complexity isn't about how fast an algorithm is, but how it scales.
05:29:30 <augur_> ahh
05:29:34 <ciaranm> and show that practically, your favourite trivial algorithm solves nearly all instances of an NP-complete problem quickly
05:29:42 <merijn> augur_: https://queue.acm.org/detail.cfm?id=1814327 <- interesting read
05:30:16 <ciaranm> which is in a way legitimate... i mean, it's pretty frickin' difficult to generate hard instances for most NP-complete problems if you don't know the trick
05:30:19 <merijn> kuribas: Oh? Why?
05:30:25 <augur_> ciaranm: hm. i wonder how that impacts on aaronson's comments on why  P /= NP  is the right answer
05:30:33 <merijn> kuribas: I dispute your assumption
05:30:43 <ciaranm> augur_: well does he know about the phase transition stuff?
05:30:51 <augur_> ciaranm: dunno. probably.
05:31:00 <kuribas> merijn: Because you can have an algorithm which has good complexity, but is very slow.
05:31:00 <merijn> @quote math.gnomes
05:31:00 <lambdabot> Cale says: But it's not like there's a council of math gnomes which get to decide which definitions everyone uses.
05:31:12 <merijn> kuribas: Define "good complexity"
05:31:28 <kuribas> merijn: Good asymptotic complexity.
05:31:29 <augur_> ciaranm: his main point tho is that if P = NP, then we would expect "creative leaps" and discovery of new/correct ideas to be _as easy_ as checking that they're correct
05:31:35 <merijn> kuribas: You seem blinded/railroaded by the assumption that "complexity == big-O"
05:31:55 <merijn> kuribas: Why would complexity analysis be restricted to asymptotic complexity?
05:32:02 <augur_> ciaranm: so i wonder then if that means all the hard NP problems are of that sort. because if they're not, then lots of "creative leaps" really are easily found
05:32:05 <ciaranm> augur_: the phase transition things support the idea that P != NP, even though it's really hard to find actually hard instances. it basically says that the really hard instances only lie in a very specific place. it's all waffle, of course, but it roughly holds in practice
05:32:25 <augur_> waffle... mmm
05:32:38 <ciaranm> augur_: if you want an utterly wooly intuitive view of it, hard problems are only actually hard for a half-way decent algorithm if the answer could plausibly be either yes or no with very high probability
05:33:10 <augur_> for some definition of plausible :)
05:33:33 <bernalex> Iceland_jack: hm. did you annotate my code? I just annotated it myself to show what I did, heh: http://lpaste.net/1975721961598222336
05:33:33 <augur_> i find it interesting when words like that are used
05:33:46 <bernalex> and I noticed someone else had already annotated it. :-)
05:33:48 <augur_> Wadler has similar word choices when talking about curry-howard
05:33:48 <Iceland_jack> Yeah I did bernalex :)
05:33:57 <kuribas> merijn: Well, I was refering mostly to asymptotic complexity, I didn't mean that other analysis is useless.
05:34:01 <bernalex> I didn't think to eliminate the if as well. I'll do that too.
05:34:07 <augur_> surely plausibility depends on cognitive framework!
05:34:10 <ciaranm> augur_: for example, if you ask me to 3-colour a really dense graph, i can tell you straight away that it's not possible by pointing out a 4-clique. and if you give me a really sparse graph, i can easily 3-colour it. but if you give me a graph with just the right edge density, the probability that it's 3-colourable is 0.5, and that's precisely where good algorithms struggle.
05:34:28 <Iceland_jack> But bernalex, you shouldn't write unreadable/unmaintainable code unless you have a good reason to!
05:34:31 <ciaranm> augur_: you can make "plausible" at least physics-precise for random inputs
05:34:40 <merijn> kuribas: "< kuribas> complexity isn't about how fast an algorithm is, but how it scales." <- you want to prefix that with *asymptotic*, then
05:34:42 <augur_> ciaranm: interesting
05:34:47 <merijn> kuribas: If you had done that I would've agreed
05:34:47 <bernalex> Iceland_jack: I don't think it's unreadable/unmaintainable. sure it needs a comment, but...
05:34:49 <kuribas> merijn: Yeah, my bad.
05:34:56 <Iceland_jack> bernalex: (not to put you down, it sounds like you already had a better version)
05:34:58 <augur_> so not plausible_1, but plausible_2
05:35:20 <bernalex> Iceland_jack: I liked my previous version better, I just did this to "look ma, only one traversal!"
05:35:25 <Iceland_jack> hah
05:36:08 <bernalex> Iceland_jack: a friend asked me how I would do the problem in Haskell. without braining I came up with the length+dropWhile+length example. then when braining I thought I'd give a one-traversal example too. :-)
05:36:20 <kuribas> merijn: Although that's normally what's meant by complexity, right?
05:36:25 <bernalex> also, I'm not put down by your comments. I harbour no illusions about being a master haskell hacker of any kind.
05:36:50 <bitraten> hey, i am getting some strange errors when trying to install scotty http://lpaste.net/4028008376741920768
05:38:25 <Iceland_jack> bernalex: Just wanted to make sure :)
05:38:46 <bernalex> Iceland_jack: also, I make a comment in my email that "if you want speed, you are likely not using a list", and that my one-traversal example is just to show how you could do it.
05:38:52 <merijn> bernalex: I have no clue what that code does without staring :>
05:39:22 <bernalex> merijn: a commend should help
05:41:09 <bernalex> merijn: like:
05:41:12 <bernalex>         -- findPI takes the current index, the value of it, a counter
05:41:14 <bernalex>         -- (what element in the list it's currently at), and the list.
05:41:15 <bernalex>         -- NB: DON'T DO THIS. Use something else than list. :-)
05:41:47 * quchen wonders what's wrong with his solution
05:45:18 <haasn> Iceland_jack: is “because we can” a good reason?
05:46:14 <Iceland_jack> haasn: sure :)
05:47:49 <haasn> bernalex: not sure what the problem is about but do note that differences in the number of traversals of lists can be the difference between your program crashing due to an out of memory error and not
05:47:58 <haasn> (and also lots of constant factor performance)
05:48:15 <haasn> because sometimes, multiple traversals will prevent the GC from collecting the list
05:48:22 <merijn> Anyone wanna contribute some test cases to my Haskell layout stress test? https://gist.github.com/merijn/9619318
05:48:39 <haasn> whereas a single traversal will cause it to collect elements as they're traversed, keeping memory usage constant
05:48:58 <merijn> I'm reworking my vim haskell indenter, so I wanna make sure I cover as many sensible layouts possible
05:49:01 <bernalex> haasn: I noted that, yes, you can do it in one traversal, here's one example... but don't use a list. ;-)
05:49:12 <merijn> (Where sensible means == I consider it an acceptable/reasonable layout)
05:50:22 <haasn> merijn: that actually sounds somewhat useful
05:50:35 <haasn> I've always wished for my editor to be better at laying things out without me having to do all the work manually :)
05:50:52 <haasn> merijn: is the indentation with flexible?
05:50:54 <haasn> width*
05:51:08 <merijn> haasn: Maybe
05:51:15 <quchen> merijn: You mean Github Haskell highlighting stress test?
05:51:24 <merijn> I have an old one that uses shiftwidth, but I'm not sure I'll keep it that way
05:51:30 <merijn> quchen: Yeah, that's been broken for ages
05:51:34 <fizbin> I really should find the system github uses for highlighting haskell code and see if I can fix its issue with single quotes.
05:51:37 <merijn> It's kinda dumb
05:51:40 <haasn> yeah it can't handle DataKinds
05:51:49 <quchen> Has anyone filed a bug report about it?
05:51:59 <merijn> quchen: I couldn't figure out where
05:52:09 <haasn> isn't there a github repository for, well, github?
05:52:21 <quchen> Click on "contact", complain.
05:52:27 <dv-> github isn't open source is it?
05:52:38 <quchen> Then click on "contact" again and complain about how the bug reporting button is missing.
05:52:39 <haasn> dv-: yeah but I guess they would still have a repo for the docs or API docs or something
05:53:05 <fizbin> github's syntax highlighter isn't written by github. They apparently use pygments (pygments.org)
05:53:09 <merijn> haasn: The biggest problem I have atm the moment is how to find the start of a top level definition
05:53:36 <merijn> haasn: i.e. how do I tell top level definitions from let/where
05:54:01 <haasn> merijn: anyway, what happens if you set the indentation width to 2 and type “let x = case y of” inside a do block? if you blindly indent it by 2 spaces here it will be a syntax error; you need to go at least past the ‘x’
05:54:02 <merijn> I may just take the ghetto approach of requiring top level to start at column 1, but that means it won't work within block comments
05:54:10 <haasn> or to the ‘x’, not sure
05:54:16 <haasn> past, I think
05:54:44 <haasn> merijn: make sure it works for .lhs source as well, including inside bird track code segments
05:54:55 <merijn> haasn: One problem at a time...
05:54:58 <fizbin> There's a failing test case on pygments.org at http://pygments.org/demo/58336/
05:55:13 <fizbin> In other words: it's been reported.
05:56:28 <quchen> merijn: Actually, this isn't really a Haskell issue, it's that GHC permits "'" in more places than Haskell, no?
05:56:45 <merijn> quchen: It's part of DataKinds, yeah
05:58:35 <haasn> quchen: it's a syntax error in the absence of the extension so there's no harm in highlighting it as if DataKinds were enabled
05:59:03 <c_wraith> the datakinds ' *really* screws up CPP
05:59:18 <quicksilver> the use of ' like that as a prefix-quoting modifier is an accidental slip revealing the hidden agenda to make haskell into a LISP
05:59:39 <haasn> the fix seems almost trivial, instead of making ' only valid within identifiers on the type level, make it also valid at the start
05:59:44 <haasn> (and treat it as a regular character)
06:00:07 <haasn> s/within/within-or-at-the-end-of/
06:00:08 <merijn> c_wraith: More so than just normal "foo x' = bar"?
06:00:46 <haasn> oh, it's not *that* simple, you need to account for TH quotation as well
06:01:11 <c_wraith> merijn: sometimes CPP actually manages to handle that.  somehow.
06:01:18 <merijn> Can anyone see any redeeming reason to allow GADTSyntax where "data" and "where" are not on the same line? (similar for closed type families)
06:01:49 <haasn> I think GHC's rule is: ' is valid at the start of capitalized identifiers in general, unless that ' is the start of a valid character literal
06:05:55 <fizbin> merijn: Does your indenter allow the closing ] of a multiline list to be on the same line as the last element? I see it allows that with a multiline tuple...
06:06:16 <merijn> fizbin: It doesn't allow anything at the moment
06:06:25 <fizbin> I'm not saying it should - I'm undecided at the moment.
06:06:31 <merijn> fizbin: That file is just a test case for what I want
06:06:58 <merijn> The old indenter I wrote is kinda stupid, it just uses regexes which means you can't do smart indent/dedent
06:07:19 <tdammers> I refuse to accept "dedent" as a word
06:07:27 <c_wraith> outdent?
06:07:33 <fizbin> unindent?
06:07:39 <merijn> I want to have flexible tabstops, because not all indents are the same width in haskell
06:07:43 <tdammers> "remove/reduce indentation", "indent less", ...
06:07:44 <fizbin> I'll take dedent over "unindent".
06:07:48 <jcarpenter2> inbump?
06:08:19 <merijn> The problem is that writing any form of decent "parsing" for this in vimscript is horrid
06:08:35 <fizbin> Every now and then when reading "newtype", my brain wants to pronounce it as "newt wipe". I don't know why.
06:08:46 <merijn> I'm seriously considering just writing a parser/indent computer in a different language and compiling to vimscript >.>
06:08:47 <tdammers> merijn: just hook it up as an equalprg?
06:09:12 <merijn> tdammers: What's equalprg?
06:09:18 <Taneb> Hmm, is it possible to embed diagrams in pandoc documents?
06:09:27 <tdammers> the program vim invokes when you use the = command
06:09:39 <tdammers> you can :set equalprg=whatever-you-like
06:09:45 <merijn> tdammers: I'm using this for automatic indenting as you type
06:09:54 <tdammers> merijn: ah, not quite useful then
06:10:13 <merijn> tdammers: Code layout like you're suggesting requires precognitiion in haskell
06:10:27 <mr-> Taneb: I seem to remember that that was announed at some point..
06:10:31 <merijn> I'm trying to get semi-useful autoindent/tabbing/backspace for haskell
06:10:31 <whald> is there already some datatype which is essentially a "ByteString of (compile-time) fixed size"?
06:10:46 <merijn> I might just take a hdevtools style approach
06:10:47 <t7> merijn: time for ast editor
06:10:56 <tdammers> I'd settle for something that guesses correctly most of the time, in a predictable manner
06:11:03 <merijn> Have a background daemon and dumping text to it
06:11:14 <merijn> tdammers: Yes, but that's insanely hard
06:11:20 <tdammers> yeah
06:11:29 <merijn> tdammers: Because to do that you'd want a list of potential tabstops
06:11:34 <tdammers> currently, I'm actually settling for nothing at all
06:11:35 <Taneb> Oooh https://github.com/bergey/diagrams-pandoc
06:11:41 <merijn> tdammers: Which in haskell essentially requires pseudo parsing quite a bit
06:11:44 <tdammers> yeah
06:11:46 <tdammers> I know
06:11:56 <merijn> Actually, this is probably not a bad idea
06:12:28 <merijn> Just grab code fragments and dump them to an external haskell process which parses and returns the info I need :p
06:12:52 <fizbin> If you have both DataKinds enabled and TemplateHaskell enabled, is it possible to reasonably have a lexeme in the program beginning with ''' ? (That is, say you have the type constructor ': defined and then you want to pass that as a Name to some TH thing, so you do: myTemplate ''':
06:13:07 <tdammers> and that external code would be just some glue around Language.Haskell.Whatever?
06:13:40 <merijn> tdammers: Naah, Language.Haskell would parse the haskell which means I'd lose indent info, I think? I'm not sure, I have to check what Language.Haskell returns
06:14:00 <tdammers> hmm, yeah, chicken-and-egg
06:14:14 <tdammers> basically the reason why auto-indenting python is impossible
06:15:00 <tdammers> if it weren't for layout, it'd be somewhat possible, at least if L.H can parse comments
06:16:20 <johannesbodannes> There seems to be a lot of talk going on at the moment about the problem of processors no longer getting faster, and of improvement in processing hardware coming in the form of multiple cores, and the need for that kind of processing power to meet big data problems. But similarly of the inadequacy of modern-day languages and every-day programmers to match the challenge of programming for parallel setups.
06:16:56 <merijn> tdammers: Auto-indenting python is trivial
06:17:07 <merijn> tdammers: Indent on new block, maintain indent until backspaced
06:17:16 <merijn> Works just fine
06:17:28 <johannesbodannes> Frequently functional languages come up as a solution to the problem of parallel programming, and I can fully see how quarantining side-effects in functional languages like Haskell help with that but
06:18:25 <tdammers> merijn: it works fine as long as you already know where to indent
06:18:33 <fizbin> merijn: A tiny bit more than that is needed, to handle things like multi-line lists and dictionary literals, but basically, yeah.
06:18:39 <johannesbodannes> Is a language like Haskell really an "effortless" solution to parallel execution? From what I've seen so far, at least -
06:18:57 <tdammers> johannesbodannes: are you familiar with the Free Lunch Theory?
06:19:07 <merijn> tdammers: Right, but in haskell that's much less easy as the layout is much more freeform
06:19:09 <johannesbodannes> Not at all no
06:19:09 <Itkovian> johannesbodannes I think it largely depends on what it is you wish to do and how you can express your problem
06:19:11 <mr-> (answer: there is none!)
06:19:32 <tdammers> what mr- said :D
06:19:35 <tdammers> "no such thing"
06:19:36 <monochrom> yikes, Free Lunch Theory, is that some universal construction in some category? :)
06:19:38 <merijn> johannesbodannes: The answer is: There is no "effortless" parallel execution model in existence yet
06:19:38 <Itkovian> If itcan easily be expressed in some embarassingly parallel way, it's a breeze
06:19:49 <whald> johannesbodannes, if there is an "effortless solution" for something, that something is not a problem in the first place :-)
06:19:58 <fizbin> johannesbodannes: Not effortless, no. Haskell and side-effect-free programming was supposed to be very auto-parallelization friendly and it's turned out that parallelization is trickier than that.
06:19:58 <merijn> Itkovian: Even embarassingly parallel is still hard
06:20:03 <tdammers> whald: whoa whoa whoa, hold the holism
06:20:16 <johannesbodannes> Oh well of course, yes. But it seems like every time we hit a problem in programming
06:20:23 <Itkovian> merijn at least you have no dependencies :)
06:20:30 <johannesbodannes> someone comes along and produces an abstraction that makes the problem disappear or become very small
06:20:40 <fizbin> That being said, there are many parallel-computation libraries in haskell that seem to make things much easier.
06:21:00 <tdammers> anyway; I'd say controlled side effects are a very useful thing to make your parallel life easier, but it's not a silver bullet
06:21:19 <tdammers> I'd prefer doing parallel stuff in Haskell over doing it in C
06:21:29 <Itkovian> obviously ^
06:21:29 <tdammers> but its' far from "effortless" still
06:21:42 <tdammers> Itkovian: or Java, for that matter
06:21:43 <fizbin> So... maybe? It's getting better, and haskell seems to be at the forefront of making general-purpose code parallelizable, but we aren't anywhere near where the compiler can just automatically do it for us.
06:22:04 <Itkovian> I think a major part of the problem is not how to express it in the language, but how can I mold my problem that it exposes parallelism
06:22:10 <monochrom> if you are not concerned about performance, parallelization of functional programs is easy and easily correct (gives the right answer)
06:22:16 <yesthisisuser> i would say hardware manufacturers are doing a better job than algorithm designers in that domain
06:22:29 <johannesbodannes> That's what I've heard myself
06:22:37 <fizbin> There was a haskell cast a while ago that touched on some of the efforts at better parallelization.
06:22:47 <k00mi> the problem with automatic parallelization is more about deciding when to do it, not how to do it
06:22:56 <merijn> monochrom: If you do care about performance parallelising functional programs is much easier than non-functional ones :)
06:23:14 <johannesbodannes> Or at least, hardware manufacturers are wanting to push better hardware, but there aren't software developers yet to incentivize it
06:23:47 <yesthisisuser> yes i shouldn't say "better job"..
06:23:50 <fizbin> Trying to remember which haskell cast that was - I did a long listen to all of them a bit ago on a plane trip and all I can remember is that it was one I heard while over Iowa somewhere.
06:24:13 <k00mi> fizbin: probably the one with simon marlow
06:24:18 <Itkovian> All right and you were flyng from where?
06:24:26 <Itkovian> and what wa the order of the episodes?
06:24:27 <fizbin> k00mi: Ah, yeah.
06:24:31 <yesthisisuser> but the lesson from development in recent years is that we probably should spend more time thinking about better algorithms rather than building faster computers
06:24:35 <Itkovian> We can deduct the correct one from there
06:24:47 <Itkovian> yesthisisuser +1
06:25:13 <int-index> Hi. I need some help with lenses. The `over` function takes a function of type (a -> a), but what if I have a function of type (a -> m a)? And I also need to compose those.
06:25:13 <fizbin> It even says Parallelism is the description. So haskell cast ep. 4, johannesbodannes. Go listen to that.
06:25:38 <int-index> Right now I just get the data using the `view` function, perform the monadic computation, and put it back using the `set` function. Not cool.
06:25:43 <int-index> Not composable.
06:25:58 <johannesbodannes> Thanks i'll take a look at this cast
06:26:08 <yogurt_truck> johannesbodannes: this is probably the best resource on the topic http://chimera.labs.oreilly.com/books/1230000000929/index.html
06:26:39 <johannesbodannes> oh man it's a book
06:26:50 <johannesbodannes> this is awesome omfg thanks
06:26:52 <fizbin> @type over
06:26:53 <lambdabot> Profunctor p => Setting p s t a b -> p a b -> s -> t
06:27:11 <merijn> ugh Language.Haskell works on String? >.<
06:27:13 <int-index> I think that Control.Lens.Action should solve my problem, but I didn't find any examples I could understand.
06:27:42 <fizbin> int-index: We'll try to help here, but #haskell-lens might answer your question faster.
06:27:43 <whald> is there a package providing something like this: "class (Binary a) => Block a where size :: Int" already?
06:27:55 <k00mi> johannesbodannes: it's a great book, written by the person who implemented most of GHC's parallel runtime (also the same guy as in the podcast)
06:27:59 <bennofs> int-index: just use the lens itself as a function!
06:28:40 <fizbin> bennofs: Oh, right. Duh.
06:29:04 <bennofs> :t _1 :: Monad m => (a -> m b) -> (a,x) -> m (b,x) -- Example
06:29:05 <lambdabot>     Could not deduce (Functor m1) arising from a use of `_1'
06:29:06 <lambdabot>     from the context (Monad m)
06:29:06 <lambdabot>       bound by the inferred type of
06:29:15 <bennofs> :t _1 :: Functor m => (a -> m b) -> (a,x) -> m (b,x) -- Example
06:29:16 <lambdabot> Functor m => (a -> m b) -> (a, x) -> m (b, x)
06:29:31 <bennofs> int-index: you can do this with any of your lenses
06:29:40 <fizbin> int-index: Assuming that your monad is itself a Functor (and it should be; the instance is trivial to add if you didn't yet), then...
06:30:20 <int-index> bennofs: it is a functor indeed. Well, I'm going to try your solution.
06:31:06 <int-index> Wait.
06:31:08 <k00mi> bennofs: that doesn't really compose though, does it?
06:31:16 <int-index> Should I compose those with >=> then?
06:31:44 <int-index> :t >=>
06:31:45 <lambdabot> parse error on input `>=>'
06:31:49 <int-index> :t (>=>)
06:31:49 <lambdabot> Monad m => (a -> m b) -> (b -> m c) -> a -> m c
06:32:15 <fizbin> :t _1 . _1 :: Functor m => (a -> m b) -> ((a, q),x) -> m ((b, q),x) -- Example
06:32:16 <lambdabot> Functor m => (a -> m b) -> ((a, q), x) -> m ((b, q), x)
06:32:28 <bennofs> int-index: yes, if you want to chain updates, use >=>
06:32:37 <int-index> Great. Thank you.
06:33:13 <fizbin> int-index: But if what you want is to use lens composition so that you access "lens a of thing pointed to by lens b", then use (.)
06:33:33 <fizbin> See my example chaining _1 . _1
06:34:13 <fizbin> Though I do agree that any day you can reasonably use the fish operator (>=>) is a good day.
06:34:48 <haasn> :t traverseOf -- int-index
06:34:49 <lambdabot> Over p f s t a b -> p a (f b) -> s -> f t
06:34:50 <haasn> note: traverseOf = id
06:35:05 <k00mi> it's amazing how lens types always work out :O
06:35:17 <int-index> The point is, I have multiple fields in a data stucture and I need to update all of them with a monadic computation
06:35:32 <int-index> (one computation for each field of different types)
06:35:32 <bennofs> yeah, then use >=> :)
06:35:40 <haasn> :t act
06:35:41 <lambdabot> (Conjoined p, Effective m r f) => (s -> m a) -> p a (f a) -> p s (f s)
06:36:29 <merijn> hmm, what's the nicest way to write multiline strings? Is there a nice way to fuse them without lots of (++) ?
06:36:42 <haasn> merijn: you can escape whitespace with \ \
06:36:44 <fizbin> merijn: Isn't that what \& is for?
06:36:46 <haasn> including newlines
06:36:48 <haasn> fizbin: no
06:37:04 <bennofs> merijn: everything between one \ and another \ is ignored
06:37:20 <d3lxa> merijn: seems same question there http://www.haskell.org/pipermail/haskell-cafe/2006-January/013911.html
06:37:22 <haasn> merijn: I also like “unlines”
06:37:25 <k00mi> merijn: unlines and a list of lines is what I usually do
06:38:00 <haasn> fizbin: \& is used as a separator, eg. "\SOH" vs "\SO\&H" (the former has length 1, the latter length 2)
06:38:10 <fizbin> Right, okay.
06:38:38 <haasn> or \x0A1" vs "\x0A\&1"
06:39:24 <merijn> d3lxa: That one eliminates the linebreak
06:39:36 <merijn> I want to write a string with linebreaks in it
06:39:49 <GregB> hallo
06:39:51 <fizbin> merijn: Then use \n\   and then \ on the next line.
06:40:04 <GregB> I have this code http://lpaste.net/101399
06:40:14 <GregB> how can I write this in a shorter way ?
06:40:40 <fizbin> Sadly, no, haskell does not have anything like python's or scala's """ .
06:40:59 <GregB> I need something like this
06:41:00 <GregB> disjunction “programming” “software” =>“pgminsftwe”
06:41:11 <GregB> but my code is to long
06:41:22 <d3lxa> merijn: oh, ok ^^
06:41:23 <GregB> can someone help ?
06:41:35 <merijn> tdammers: I just tested, haskell-src-exts won't really work as it expects actual correct haskell instead of snippets of partial haskell, I'll just write my own ghetto parser :)
06:42:02 <d3lxa> merijn: can't you use an external file and inline it into a variable?
06:42:06 <Iceland_jack> GregB: First of all 'elem' exists and does what 'contains' does
06:42:10 <Iceland_jack> @ty elem
06:42:11 <lambdabot> Eq a => a -> [a] -> Bool
06:42:16 <merijn> d3lxa: Maybe, I was just curious :p
06:42:43 <merijn> Oh well, good excuse to learn trifecta :p
06:42:43 <d3lxa> yeah, I'm certain haskell demands a lot of curiosity :)
06:42:50 <haasn> > let (a,b) = ("programming","software") in filter (`notElem` b) a ++ filter (`notElem` a) b
06:42:52 <lambdabot>  "pgmmingsftwe"
06:43:08 <haasn> > let (a,b) = ("programming","software") in nub $ filter (`notElem` b) a ++ filter (`notElem` a) b
06:43:09 <lambdabot>  "pgminsftwe"
06:43:25 <tdammers> merijn: yeah, obviously... it would work for a reindenter, but not as an indent-as-you-type helper
06:43:43 <merijn> Click on docs of an edwardk library: "unparser :: forall r. (a -> Err -> It Rope r) -> (Err -> It Rope r) -> (a -> Set String -> Delta -> ByteString -> It Rope r) -> (Doc -> It Rope r) -> Delta -> ByteString -> It Rope r"
06:43:48 <merijn> I dunno what I was expecting...
06:43:55 <tdammers> such math
06:44:03 <haasn> it rope
06:44:07 <haasn> much doc
06:44:17 <fizbin> many type
06:44:19 <fizbin> wow
06:44:23 <tdammers> http://cokmett.github.io/cokmett/
06:44:35 <tdammers> err...
06:44:42 <bennofs> hint: click on it
06:44:58 <merijn> I expect this library was from before edward's "writing docs" phase :)
06:44:58 <GregB> haasn: what does in nub mean ?
06:45:27 <haasn> GregB: “in” is part of the syntax of “let .. in ..” expressions
06:45:30 <haasn> GregB: nub is a function
06:45:36 <haasn> > nub "aaabbababbbaaabbcccbbccbbaaa"
06:45:38 <lambdabot>  "abc"
06:45:47 <GregB> doe I need a import ?
06:45:55 <GregB> Data.char maybe ?
06:46:06 <haasn> if it's not already in Prelude, Data.List
06:46:15 <monochrom> import Data.List
06:46:15 * hackagebot sloane 1.6 - A command line interface to Sloane's On-Line Encyclopedia of Integer Sequences  http://hackage.haskell.org/package/sloane-1.6 (AndersClaesson)
06:46:17 * hackagebot Spock 0.4.3.5 - Another Haskell web toolkit based on scotty  http://hackage.haskell.org/package/Spock-0.4.3.5 (AlexanderThiemann)
06:46:25 <kuribas> Some people say nub should never be used...
06:46:30 <bennofs> http://hackage.haskell.org/package/trifecta-1.4.1/docs/Text-Trifecta-Util-It.html -- ha
06:46:34 <haasn> kuribas: it's slow
06:46:45 <monochrom> it is not specific to Char. nub [3,1,3,3,7] works too
06:46:54 <kuribas> Yes, and even for small lists, using a set is better.
06:47:01 <kuribas> faster I mean.
06:47:01 <haasn> FSVO small
06:47:15 <haasn> asymptotically faster does not necessarily mean actually faster
06:47:22 <monochrom> I say: "should never be used" should never be used.
06:47:28 <GregB> haasn: Thank you I think I got it
06:47:36 <merijn> bennofs: I especially like this bit of the docs: "It is a cofree comonad"
06:47:39 <merijn> Such help
06:47:46 <kuribas> haasn: That's why I said, even for small lists.
06:48:00 <monochrom> such help. very cofree. :)
06:48:04 <haasn> merijn: just look at the documentation of the cofree comonads package ;)
06:48:54 <monochrom> oh! I have just figured out the Free Lunch Theory! it's the left adjoint (or was it right adjoint?) of forgetting to bring your lunch! :)
06:48:55 <haasn> GregB: if you're interested in more scaleable alternative, see http://hackage.haskell.org/package/containers-0.5.5.1/docs/Data-Set.html#v:difference
06:49:17 <quchen> http://theproofistrivial.com/ etc
06:49:24 <fizbin> haasn: Except that ekmett would never create such a package. He'd create a cofree and a comonad separately, and the combination CoFree CoMonad would then be a "natural" combination of the individual pieces.
06:50:20 <quchen> Are there free comonads?
06:50:27 <quchen> Or is that what "cofree" mentions explicitly
06:50:29 <bennofs> fizbin: There isn't even a cofree package, free contains it.
06:50:40 <haasn> quchen: trivially, for f = Const Void
06:50:42 <kuribas> Or a hashset: http://hackage.haskell.org/package/unordered-containers-0.2.1.0/docs/Data-HashSet.html
06:50:46 <haasn> since that makes Free f = Identity
06:50:55 <haasn> quchen: cofree is a different construction
06:51:04 <haasn> (there are also cofree monads)
06:51:09 <quchen> haasn: Ah, so the "free" in "free comonad" refers to the "pure or wrap" construction
06:51:10 <Hodapp> COFFEE MONAD?
06:51:10 <haasn> (I think)
06:51:13 <kuribas> You have to have a hashable instance for a hashset, but the package provides several.
06:51:18 <haasn> (oh, yes, equally trivially)
06:52:00 <haasn> quchen: well, they are both “free” in the sense that you get them automatically from some functor
06:52:16 <haasn> but one is called Free and the other is called Cofree just to distinguish it from Free
06:52:44 <haasn> so every Cofree comonad is really a free comonad
06:52:50 <haasn> but my answer was for a Free comonad
06:52:51 <merijn> ok, so maybe I should just use parsec instead of learning trifecta >.>
06:53:40 <merijn> Some people appear to be using it, but god knows how they figured out the API :)
06:54:18 <bennofs> merijn: I think you can use the "parsers" package and use trifecta as a backend
06:56:49 <haasn> kuribas: I did a quick test, apparently nub is faster than Set.toList . Set.fromList on "abcdefg", but the latter becomes faster if you increase the size or increase the number of duplicates
06:57:04 <merijn> bennofs: I'd still have no clue how to fit those two together
06:57:41 <kuribas> haasn: Did you mean increase the size from 6?
06:57:57 <merijn> Oh well, I'll bug edward tonight
06:57:58 <luite> haasn: but that doesn't work for infinite lists
06:58:40 <haasn> kuribas: eg. make it "abcdefgh" or something
06:58:58 <GregB> haasn: can you help please
06:59:00 <GregB> let (a,b) = ("programming","software") in nub $ filter (`notElem` b) a ++ filter (`notElem` a) b
06:59:01 <kuribas> haasn: Yes, interesting.
06:59:09 <GregB> this was your fucntion
06:59:21 <GregB> now I have this disjunction :: String -> String -> String
06:59:21 <GregB> disjunction xs ys = (xs,ys) in nub $ filter (`notElem` ys) xs ++ filter (`notElem` xs) ys
06:59:23 <haasn> the best case scenario for set obviously is (replicate n x)
06:59:35 <fizruk> GregB: missed let
06:59:49 <GregB> I want to be able write my woords
06:59:56 <GregB> now hardcode it
07:00:05 <GregB> but it doenst work
07:00:05 <kuribas> haasn: I am currently using hashSet for set operations on a list of strings.
07:00:12 <fizruk> GregB: disjunction xs ys = let (xs, ys) in ...
07:00:21 <kuribas> haasn: Since it's cheaper to do comparisons.
07:00:25 <haasn> > let (xs, ys) in () -- fizruk
07:00:26 <lambdabot>  <hint>:1:14: parse error on input `in'
07:00:41 <haasn> kuribas: good idea, let me bench it
07:00:48 <fizruk> haasn: ?
07:01:25 <haasn> fizruk: it's a syntax error
07:01:40 <haasn> let (xs, ys) in .. -- missing the definition; it's also not really what he wants
07:01:53 <fizruk> oh, right
07:01:56 <haasn> GregB: I used “let .. in” syntax to demonstrate the code
07:02:05 <haasn> GregB: do you understand how “let ... in ...” works?
07:02:23 <quchen> haasn: Ah, I was wondering about the "free vs Free" part. Thanks for clarifying. (Mathematically, are there cofree monads? Are there even cofree things?)
07:02:28 <GregB> yes It only works in the Prelude
07:02:49 <haasn> quchen: I don't think that makes sense, mathematically. I don't think “free” is mathematically defined, either
07:02:49 <GregB> But now i Want to write is out in a haskell file and load it
07:03:05 <haasn> the only notion of “free” I know is “adjoint to a forgetful functor”
07:03:10 <GregB> I have this
07:03:11 <GregB> disjunction :: String -> String -> String
07:03:11 <GregB> disjunction xs ys = (xs,ys) in nub $ filter (`notElem` ys) xs ++ filter (`notElem` xs) ys
07:03:12 <quchen> haasn: You mean "free" in a monad context?
07:03:14 <haasn> but forgetful functor is equally not-well-defined
07:03:22 <haasn> “free” as a general word
07:03:23 <quchen> Oh, I've heard that quite often
07:03:36 <haasn> eg. free monoid, free monad, free whatever
07:03:36 <quchen> I'll be careful then
07:04:51 <monochrom> GregB, why is the 2nd line not simply "disjunction xs ys = (xs, ys)"?
07:04:52 <haasn> fizruk: looks like hashset exceeds set for sets (not necessarily input strings) around size 40
07:05:00 <haasn> testing on "abcdefghijklmop" etc
07:05:18 <haasn> this is probably very highly dependant on the exact layout of the input string
07:05:41 <fizruk> haasn: did you mean kuribas?
07:05:56 <haasn> kuribas, yes; sorry, I'm tired
07:06:44 <fizbin> fizruk: Seriously, if you'd think anyone would get your irc name confused for someone else on the channel...
07:06:49 <haasn> quchen: although there certainly is a “free monad” and it certainly is mathematically well defined (we can write its definitions down in Haskell, after all)
07:07:05 <kuribas> haasn: Did you test with strings, or list of strings?  I think HashSet makes more of a difference when the values are strings or lists.
07:07:21 <fizruk> fizbin: :)
07:07:46 <haasn> kuribas: I literally just did “nf (Set.fromList . Set.toList) "abcdefg..."”
07:07:58 <haasn> a ballpark estimate is what I'm after
07:08:05 <monochrom> and look for both monochrom and monokrome in this channel! :)
07:08:16 <haasn> I wanted to know if nub and Set.toList are in the same order of magnitude, and how they grow relative to one another
07:08:29 <fizbin> Is monokrome ever active though?
07:08:45 <monochrom> yes, I saw him/her speaking once
07:09:25 <haasn> one of the two has got to go. fair coin toss says it's monochrom
07:09:39 <kuribas> For hashSet I would use something like "nf (Set.fromList . Set.toList) ["abcdefg", "hijklmn", "opqrstu", "abcdefg", "hijkfds"]"
07:10:04 <kuribas> haasn: Since hashing on chars is a loosing operation.
07:10:44 <kuribas> haasn: But anyway, thanks for the test.
07:11:12 <haasn> kuribas: interesting, on that exact test set gets 419ns, nub gets 518ns and hashset gets 957ns
07:11:21 <haasn> looks like hashing a small string is more expensive than just comparing it
07:11:30 <haasn> then again, that should be obvious
07:11:41 <haasn> the gain is in memory complexity, I guess
07:11:59 <bartavelle> for a large number of strings that might not be that obvious
07:12:39 <haasn> Is HashSet also tree-based or does it have O(1) comparison?
07:13:05 <haasn> ah, hash array mapped trie
07:13:16 <kuribas> The hashing is done only once, the comparing more than once.
07:13:29 <bartavelle> exactly
07:13:48 <haasn> fair point
07:13:54 <bartavelle> so if you have a lot of comparisons, you should eventually beat string comparison
07:14:07 <haasn> or larger sets
07:14:13 <kuribas> But that's only if log(sizeoftree) is significant.
07:14:16 <haasn> that you need to traverse vs. being able to just index them
07:15:04 <haasn> actually I think that one might be asymptotically equal
07:15:18 <bartavelle> (if the string fits in a register, you could be quite fast, but that would probably hard to write in haskell)
07:15:18 <haasn> log base 2 vs log base 16
07:15:41 <ciaranm> there's no such thing as O(1) you heretics!
07:16:21 <kuribas> ciaranm: Why not?
07:16:22 * hackagebot lgtk 0.6 - lens-based API for Gtk  http://hackage.haskell.org/package/lgtk-0.6 (PeterDivianszky)
07:16:37 <kuribas> ciaranm: A constant time operation?
07:16:49 <ciaranm> kuribas: there's a log n cost involved in being able to access n bytes of memory, and your hardware doesn't entirely hide that from you
07:16:59 <c_wraith> kuribas: well, register ops could be O(1), but memory ops aren't
07:17:56 <kuribas> Well, yes, if you take cache, etc into account.
07:18:08 <archblob> can seomeone lend a hand lend a hand with some type family  shenanigans ? it seems that I can work out the equivalence with pen and paper but maybe there's something I'm missing
07:18:29 <archblob> this is what ghc says http://pastebin.com/qqwAaCz5
07:18:55 <haasn> ciaranm: it all comes down to *what* you're claiming is O(1)
07:19:16 <archblob> here are the instances https://github.com/archblob/vector/blob/testtodo/tests/Utilities.hs
07:19:19 <c_wraith> Though demonstrating that hash tables have O(log n) insert/lookup doesn't even require that detail.  You have to actually do the hashing operation..  And if you want n elements to end up in O(n) different buckets, you'll find that your hashing operation needs to look at O(log n) bits of the data, making it an O(log n) operation.
07:19:38 <haasn> ciaranm: the number of pattern matches? the number of assembly instructions executed? the number of pipeline operations performed? the execution time in seconds?
07:20:03 <archblob> and here https://github.com/archblob/vector/blob/master/tests/Tests/Vector.hs the offending code in the prop_sequence
07:20:12 <artyomkazak> :t ClassyPrelude.headEx
07:20:13 <lambdabot> Couldn't find qualified module.
07:20:28 <kstt> I just type the signature of a function I was looking for in Hoogle ( (a -> Maybe b) -> [a] -> [b] : a map that can discard element ) and Hoogle just pointed me to Data.Maybe.mapMaybe . Smile !!
07:21:04 <quicksilver> customers who liked the function 'mapMaybe' also enjoyed the function 'catMaybes'.
07:21:18 <c_wraith> hoogle needs a recommendation engine
07:21:49 <haasn> catMaybes (5/5)
07:21:54 <haasn> filter isJust (1/5)
07:22:00 <haasn> ^- and a rating system
07:22:09 <c_wraith> catMaybes (4/5).  I don't like that the implementation uses fail
07:22:28 <haasn> @src catMaybes
07:22:28 <lambdabot> catMaybes ls = [x | Just x <- ls]
07:22:40 <dmj`> @typ catMaybes . filter isJust
07:22:41 <lambdabot> [Maybe a] -> [a]
07:22:56 <haasn> :type filter undefined
07:22:59 <haasn> :t filter undefined
07:23:00 <lambdabot> [a] -> [a]
07:23:05 <artyomkazak> could anybody with classy-prelude installed check how this works: http://lpaste.net/101400 ? For me, evaluating “test” results in (1, <infinite wait>)
07:23:24 <haasn> c_wraith: does it really?
07:23:28 <monochrom> "I bought catMaybes for Christmas and I'm very satisfied!"
07:23:42 <quicksilver> in the desugaring of list comprehension irrefutable pattern match failures, it does
07:23:43 <c_wraith> haasn: yes.  When the pattern match fails, it calls fail
07:24:02 <c_wraith> haasn: that is, in fact, the entire reason fail is in the class
07:24:13 <quicksilver> I think irrefutable pattern matches in comprehensions calling mzero is quite a nice feature
07:24:14 <haasn> c_wraith: I thought that only applied to do blocks, not list comprehensions
07:24:38 <quicksilver> and you shouldn't write it off just because 'fail' has baggage
07:24:48 <quicksilver> it would be perfectly reasonable if it generated a MonadZero constraint
07:24:51 <haasn> c_wraith: the translation in the haskell report doesn't mention fail
07:24:54 <haasn> c_wraith: it's hard coded as []
07:24:56 <c_wraith> quicksilver: if it just resulted in mzero, that'd be ok.  But it uses fail instead, which is way uglier
07:25:07 <quicksilver> no, it actually uses []
07:25:11 <quicksilver> as haasn points out :)
07:25:22 <haasn> quicksilver: unless you enable MonadComprehensions :)
07:25:24 <c_wraith> quicksilver: because fail takes a String argument.
07:26:06 <quicksilver> I know what is ugly about fail.
07:26:16 <quicksilver> I just don't think it's a valid objection to [x | Just x <- ls]
07:26:24 <quicksilver> which is quite a cute syntactic trick
07:26:40 <haasn> I've found myself embracing the idiom a lot
07:26:47 <haasn> list comprehensions make for concise code
07:26:58 <haasn> (I also use it heavily inside Maybe do blocks)
07:27:51 <pyon> What was the lambdabot command for introducing a definition?
07:27:51 <archblob> artyomkazak: what version of ClassyPrelude 0.8.0.1 does not export headEx, could you tell me which module exports it ?
07:28:13 <c_wraith> pyon: @let
07:28:38 <pyon> c_wraith: Thanks!
07:29:02 <quicksilver> it certainly looks nicer than "guard (isJust l) >> return l"
07:29:13 <quicksilver> it certainly looks nicer than "guard (isJust l) >> return (fromJust l)"
07:29:50 <haasn> quicksilver: s/".*"/"maybe mzero return"/
07:29:56 <pyon> What does guard do?
07:30:06 <haasn> pyon: guard False = mzero; guard True = return ()
07:30:32 <haasn> > guard False :: Maybe ()
07:30:33 <lambdabot>  Nothing
07:30:38 <kuribas> quicksilver:  catMaybes ls ?
07:30:46 <artyomkazak> archblob: I have 0.8.0.1 and it re-exports headEx from mono-traversable (module Data.MonoTraversable)
07:31:07 <pyon> haasn: Ah!
07:31:23 <c_wraith> :t mapM $ maybe mzero return
07:31:24 <lambdabot> MonadPlus m => [Maybe b] -> m [b]
07:31:39 <haasn> > mapM (maybe mzero return) [Just 3, Nothing, Just 4]
07:31:40 <c_wraith> oh, right
07:31:40 <lambdabot>  No instance for (Control.Monad.MonadPlus m0)
07:31:40 <lambdabot>    arising from a use of `e_134'
07:31:40 <lambdabot>  The type variable `m0' is ambiguous
07:31:40 <lambdabot>  Possible fix: add a type signature that fixes these type variable(s)
07:31:40 <lambdabot>  Note: there are several potential instances:
07:32:15 <c_wraith> throw a concat at the front
07:32:26 <c_wraith> ...  is there concatMapM?
07:32:47 <haasn> you mean a concatMap?
07:33:12 <archblob> artyomkazak: yeah, using Data.MonoTraversable (headEx) works, but it has the same behaviour as in your case
07:33:13 <monochrom> @type foldr1
07:33:13 <lambdabot> (a -> a -> a) -> [a] -> a
07:33:20 <c_wraith> huh.  I guess it is just concatMap
07:33:23 <haasn> > concat $ mapM (maybe zero return) [Just 3, Nothing, Just 4]) -- c_wraith
07:33:25 <lambdabot>  <hint>:1:60: parse error on input `)'
07:33:31 <haasn> > concat $ mapM (maybe zero return) [Just 3, Nothing, Just 4]
07:33:32 <lambdabot>  Not in scope: `zero'
07:33:32 <lambdabot>  Perhaps you meant `mzero' (imported from Control.Monad.Writer)
07:33:37 <haasn> > concat $ mapM (maybe mzero return) [Just 3, Nothing, Just 4]
07:33:38 <lambdabot>  []
07:33:42 <haasn> there we go!
07:33:52 <artyomkazak> archblob: in fact, even `headEx (1:filter odd [2,4..])` fails
07:33:57 <artyomkazak> archblob: I've filed a bug
07:34:02 <artyomkazak> thanks
07:35:10 <dmj`> concatMapM        :: (Monad m) => (a -> m [b]) -> [a] -> m [b]
07:35:11 <dmj`> concatMapM f xs   =  liftM concat (mapM f xs)
07:35:11 <dmj`>  
07:35:21 <kuribas> > catMaybes [Just 3, Nothing, Just 4]
07:35:22 <lambdabot>  [3,4]
07:35:35 <dmj`> concatMapM should be in Control.Monad imo
07:36:02 <c_wraith> > concatMap (maybe mzero return) [Nothing, Just 3, Nothing, Just 7]
07:36:03 <lambdabot>  [3,7]
07:36:25 * hackagebot parsers 0.11 - Parsing combinators  http://hackage.haskell.org/package/parsers-0.11 (EdwardKmett)
07:37:09 <haasn> > foldr [] (maybe id (:)) [Nothing, Just 3, Nothing, Just 7]
07:37:10 <lambdabot>  Couldn't match expected type `Data.Maybe.Maybe a2
07:37:11 <lambdabot>                                -> (Data.Maybe.Maybe a1 -> [a1] -> [a1])
07:37:11 <lambdabot>                                -> Data.Maybe.Maybe a1
07:37:11 <lambdabot>                                -> [a1]
07:37:11 <lambdabot>                                -> [a1]'
07:37:31 <haasn> > foldr (maybe id (:)) [] [Nothing, Just 3, Nothing, Just 7]
07:37:32 <lambdabot>  [3,7]
07:37:34 <haasn> I could have sworn that was the other way around
07:38:24 <shapr> :t foldr
07:38:24 <bennofs> > foldr (:) [1,2,3,4,5]
07:38:25 <lambdabot> (a -> b -> b) -> b -> [a] -> b
07:38:25 <lambdabot>  <[Integer] -> [Integer]>
07:38:33 <bennofs> > foldr (:) [] [1,2,3,4,5]
07:38:34 <lambdabot>  [1,2,3,4,5]
07:38:42 <haasn> oh cute, we have that Show instance again?
07:38:55 <haasn> > id
07:38:56 <lambdabot>  No instance for (Data.Typeable.Internal.Typeable a0)
07:38:56 <lambdabot>    arising from a use of `M35029838136756095669797.show_M35029838136756095669...
07:38:56 <lambdabot>  The type variable `a0' is ambiguous
07:38:56 <lambdabot>  Possible fix: add a type signature that fixes these type variable(s)
07:38:56 <lambdabot>  Note: there are several potential instances:
07:39:05 <bennofs> > id :: Int -> Int
07:39:06 <lambdabot>  <Int -> Int>
07:39:09 <c_wraith> > foldr (:) [1,2,3,4,5] [] -- look!  the argument order doesn't matter!
07:39:10 <lambdabot>  [1,2,3,4,5]
07:39:17 <bennofs> c_wraith: ha :p
07:39:26 <kuribas> > foldl (:) [] [1, 2, 3, 4, 5]
07:39:27 <lambdabot>  Occurs check: cannot construct the infinite type: a0 = [a0]
07:39:27 <lambdabot>  Expected type: [a0] -> [[a0]] -> [a0]
07:39:27 <lambdabot>    Actual type: [a0] -> [[a0]] -> [[a0]]
07:39:39 <kuribas> > foldl (flip (:)) [] [1, 2, 3, 4, 5]
07:39:40 <lambdabot>  [5,4,3,2,1]
07:40:02 <kuribas> > foldr (:) [1, 2, 3] [4, 5]
07:40:03 <lambdabot>  [4,5,1,2,3]
07:40:11 <archblob> artyomkazak: headEx is just 'foldr1 const'
07:40:28 <haasn> (++) = flip (foldr (:)) -- \o/
07:40:34 <kuribas> nice
07:40:59 <haasn> > foldl (flip (:)) [1,2,3] [4,5]
07:41:00 <lambdabot>  [5,4,1,2,3]
07:41:31 <kuribas> > foldr (:) [4, 5] [1, 2, 3]
07:41:32 <lambdabot>  [1,2,3,4,5]
07:42:12 <quicksilver> haasn: yes, but it's a common pattern and there isn't a funciton like 'maybe' in every case you might use it.
07:42:27 <haasn> (sadly)
07:46:01 <artyomkazak> archblob: ah, then it's clear why it hangs
07:48:56 <Kron> what on earth
07:49:04 <Kron> I think my structured haskell mode is magically working again
07:49:06 <Kron> o_o
07:49:09 <Kron> I didn't DO anything!
07:49:22 <archblob> so, can someone help me out with type family stuff ? I'll replay my messages :-P
07:49:40 <archblob> can seomeone lend a hand with some type family  shenanigans ? it seems that I can work out the equivalence with pen and paper but maybe there's something I'm missing
07:49:46 <archblob> here are the instances https://github.com/archblob/vector/blob/testtodo/tests/Utilities.hs
07:49:51 <Narvius> Hello, I have a somewhat philosophical question. I have a syntax tree for logical expressions, and I want to give it an Eq instance. Typically, I would consider the expressions (a ^ b) and (c ^d) to be equal, that is, upon comparison, to return true. On the other hand, I have functions that may have slightly different output for those two expressions, due to the different atom names in the propositions.
07:49:55 <archblob> this is what ghc says http://pastebin.com/qqwAaCz5
07:50:03 <archblob> and here https://github.com/archblob/vector/blob/master/tests/Tests/Vector.hs the offending code in the prop_sequence
07:50:11 <Narvius> Should (==) consider them to be equal, then?
07:50:58 <Kron> Narvius: I think the most important consideration when implementing Eq is that it should be transitive and commutative
07:51:04 <Kron> a == b and b== c implies a == c
07:51:07 <Kron> a == b implies b == a
07:51:16 <Kron> other than that you can formalize anything you want I think?
07:51:29 <johannesbodannes> ...and obviously, too, identical up to isomorphism verifies all of those properties
07:51:32 <Kron> I don't know of any code off the top of my head that makes any assumptions about Eq stuff other than those ones
07:51:52 <johannesbodannes> which i think is what you're getting at
07:51:56 <Kron> i'm not sure if (==)able things necesarily have to be exactly equal
07:52:02 <Kron> a == b implies fn a == fn b? not sure
07:52:14 <Kron> I haven't really thought about it
07:52:18 <Kron> it is kind of philosophical I suppose
07:52:23 <GregB> haasn: I'm not able to write   let (a,b) = ("programming","software") in nub $ filter (`notElem` b) a ++ filter (`notElem` a) b
07:52:23 <GregB> "pgminsftwe" out in a haskell file. can you please help
07:53:01 <johannesbodannes> you can arbitrarily define equality, even in math and outside of the context of programming, as long as the properties are verified
07:53:09 <Narvius> Alright.
07:53:17 <Narvius> That is enough for me, thanks.
07:53:19 <Kron> I guess we need to implement some Eq laws of sorts. I don't know.
07:53:46 <Kron> GregB: what's the problem exactly?
07:53:52 <haasn> GregB: if you want to parametrize over a and b, your function could look like: “disjunction a b = nub $ filter (`notElem` b) a ++ filter (`notElem` a) b”
07:54:13 <GregB> my problem is
07:54:22 <GregB> I want something like this disjunction :: String -> String -> String
07:54:22 <GregB> disjunction xs ys = (xs,ys) in nub $ filter (`notElem` ys) xs ++ filter (`notElem` xs) ys
07:54:33 <Kron> ah
07:54:38 <Kron> then... do that. Doesn't that work?
07:54:39 <GregB> with a signature
07:54:41 <haasn> the “(xs,ys) in” makes no sense there
07:54:49 <haasn> GregB: how are you learning haskell?
07:54:54 <Kron> oh I see
07:54:59 <Kron> missed that
07:55:14 <GregB> I have writing a long code
07:55:17 <Kron> GregB: you can just do this:
07:55:27 <jmcarthur> my preference is for (==) to return true whenever the values it's comparing are indistinguishable
07:55:35 <Kron> disjunction xs ys = nub $ filter (`notElem` ys) xs ++ filter (`notElem` xs) ys
07:55:46 <johannesbodannes> Here we go, Narvius: http://en.wikipedia.org/wiki/Equivalence_relation
07:55:56 <Kron> it'll define a function that takes in an xs and a ys and returns that construction
07:56:05 <Kron> jmcarthur: hmm, now that's a very nice definition
07:56:09 <Kron> I think I like that
07:56:24 <johannesbodannes> i've always found the pretty/intuitive diagrams dumb and naive so probably ignore those
07:56:24 <GregB> I Have this http://lpaste.net/101401
07:56:25 <jmcarthur> and of course to return False if that are distinguishable
07:56:30 <jmcarthur> *they
07:56:36 <GregB> and I'll like to write it in a shorter way
07:57:05 <haasn> that does not seem correct
07:57:11 <haasn> the logic, that is
07:57:26 <haasn> neither for exclusive nor inclusive disjunction
07:57:28 <Kron> GregB: gotcha
07:57:46 <haasn> disjunction xs [] = xs and disjunction [] ys = ys; for both types of disjunction
07:57:50 <GregB> I have figuret it out
07:57:53 <GregB> Thnz
07:57:59 <GregB> for the help
07:58:28 <johannesbodannes> i actually find the french material significantly better, like consistently for math stuff...
07:58:28 <johannesbodannes> -_-
07:58:29 <johannesbodannes> http://fr.wikipedia.org/wiki/Relation_d%27%C3%A9quivalence
07:58:36 <johannesbodannes> why are american mathematicians so embarrassing
07:58:48 <pyon> haasn: "both types of disjunction" --> multiplicative and additive? :-P
07:59:20 <haasn> pyon: from linear logic?
07:59:28 <pyon> haasn: yep
07:59:44 <haasn> I'm not sure if that's what GregB was asking about :)
07:59:51 <pyon> haasn: I know, I was just joking. :-)
07:59:57 <Narvius> johannesbodannes: I myself am not particularly used to reading mathematical texts, so it always takes me a solid while, so I can understand the drive towards pretty pictures. But thankfully I do not fall for them too often.
08:01:02 <Narvius> johannesbodannes: But yeah, thanks. That pretty much solves all my remaining doubts.
08:07:31 <archblob> can seomeone lend a hand with some type family shenanigans ? it seems that I can work out the equivalence with pen and paper but maybe there's something I'm missing
08:07:35 <archblob> this is what ghc says http://pastebin.com/qqwAaCz5
08:07:41 <archblob> here are the instances https://github.com/archblob/vector/blob/testtodo/tests/Utilities.hs
08:07:46 <archblob> and here https://github.com/archblob/vector/blob/master/tests/Tests/Vector.hs the offending code in the prop_sequence
08:08:26 <archblob> * https://github.com/archblob/vector/blob/testtodo/tests/Tests/Vector.hs the offending code in the prop_sequence
08:10:04 <byorgey> archblob: wow, exciting error message
08:10:44 <byorgey> archblob: how do you work out the equivalence with pen and paper?
08:11:21 <archblob> archblob: well, i'll just substitue the stuff i know from the defined instances
08:11:29 * hackagebot mono-traversable 0.4.0.3 - Type classes for mapping, folding, and traversing monomorphic containers  http://hackage.haskell.org/package/mono-traversable-0.4.0.3 (MichaelSnoyman)
08:13:08 <archblob> archblob: I just presumed that's what the typechecker does :-P
08:13:36 <archblob> byorgey: I just presumed that's what the typechecker does :-P
08:14:19 <byorgey> archblob: no, I mean, can you tell me explicitly what steps you take to work out the equivalence with pen and paper.  Then we can figure out what is going wrong.
08:19:24 <Walther> :t let zipper (x:y:ns) = (max x y) ++ (zipper (y:ns))
08:19:25 <lambdabot> <no location info>:
08:19:25 <lambdabot>     not an expression: `let zipper (x:y:ns) = (max x y) ++ (zipper (y:ns))'
08:19:30 <Walther> erm
08:19:37 <Walther> :t zipper (x:y:ns) = (max x y) ++ (zipper (y:ns))
08:19:38 <lambdabot> parse error on input `='
08:20:12 <archblob> byorgey: the type i need is P (v (Identity a) -> Identity (v a)), and i have and instance for TestData (a -> b) that is (Model a -> Model b)
08:21:02 <Walther> let zipper (x:y:ns) = (max x y) ++ (zipper (y:ns))
08:21:11 <Walther> @let zipper (x:y:ns) = (max x y) ++ (zipper (y:ns))
08:21:12 <lambdabot>  .L.hs:173:39:
08:21:12 <lambdabot>      Ambiguous occurrence `zipper'
08:21:12 <lambdabot>      It could refer to either `L.zipper', defined at .L.hs:173:1
08:21:12 <lambdabot>                            or `Lens.zipper',
08:21:12 <lambdabot>                               imported from `Control.Lens' at .L.hs:40:1-43
08:21:19 <Walther> Pfft.
08:21:27 <byorgey> archblob: ok, makes sense so far
08:21:37 <Walther> @let foo123 (x:y:ns) = (max x y) ++ (foo123 (y:ns))
08:21:39 <lambdabot>  Defined.
08:21:41 <Walther> :t foo123
08:21:42 <lambdabot> Ord a => [[a]] -> [a]
08:22:02 <archblob> byorgey: then I can see that Model (v (Identity a)) -> Model (Identity (v a)) ==> v (Model (Identity a)) -> Identity (Model  (v a))
08:22:19 <byorgey> archblob: why is that?
08:22:22 <bennofs> :t let zipper (x:y:ns) = (max x y) ++ (zipper (y:ns)) in zipper
08:22:24 <lambdabot> Ord a => [[a]] -> [a]
08:22:26 <Walther> ^why does that definition make it take list of lists as input, and not just a plain list
08:22:28 <bennofs> Walther: ^^
08:23:07 <Walther> Basically, i want a new list that is one less in length than the original list; so that the new list consists of numbers that are max of the each number pair next to each other
08:23:24 <byorgey> Walther: because ++ expects two list arguments, and you gave it (max x y) as its first argument
08:23:31 <byorgey> if (max x y) is a list then so are x and y
08:23:51 <Walther> Oh right, I should use :
08:23:57 <byorgey> yep
08:24:16 <byorgey> Walther: you can also do   zipWith max list (tail list)
08:24:38 <Walther> :t let zipper (x:y:ns) = (max x y):(zipper (y:ns)) in zipper
08:24:39 <lambdabot> Ord a => [a] -> [a]
08:24:47 <archblob> byorgey: hmm, maybe I made a leap right there with Model (v (Identity a)) ==> v (Model (Identity a))
08:24:49 <byorgey> > let zipper ls = zipWith max ls (tail ls)  in  zipper [1,2,4,5,2,6,7,8]
08:24:51 <lambdabot>  [2,4,5,5,6,7,8]
08:24:55 <Walther> Ooh.
08:25:08 <Walther> Thanks a bunch!
08:25:52 <bennofs> byorgey: maybe use drop 1 instead of tail to avoid partialness?
08:25:55 <bennofs> > tail []
08:25:57 <lambdabot>  *Exception: Prelude.tail: empty list
08:26:25 <byorgey> bennofs: there is no partialness.
08:26:37 <bennofs> byorgey: if ls = [] ?
08:26:44 <quicksilver> > zipWith max`ap`tail $ [1,2,4,5,2,6,7,8]
08:26:45 <byorgey> bennofs: think carefully =)
08:26:46 <lambdabot>  [2,4,5,5,6,7,8]
08:27:00 <bennofs> byorgey: ah, you rely on the laziness of zipWith? :O
08:27:06 <byorgey> right =)
08:27:06 <archblob> byorgey: well, now i don't think so, Model (v (Identity a)) ==> v (Model (Identity a)) follows from the vector instances for TestData and from the List instance
08:27:15 <byorgey> and the fact that it's strict in its first argument in particular.
08:27:36 <byorgey> a bit of a hack perhaps. using drop 1 is of course perfectly cromulent too.
08:27:46 <davidthomas> Is there a reasonable way to extract from cabal info a list of necessary native libraries?
08:28:18 <byorgey> archblob: where is that defined?  I couldn't find it in the files you linked to
08:29:04 <archblob> byorgey: https://github.com/archblob/vector/blob/testtodo/tests/Utilities.hs
08:30:44 <byorgey> archblob: I see nothing there that would cause it to conclude that  Model (v (Identity a)) = v (Model (Identity a))  *no matter what v is*.
08:31:42 <byorgey> maybe that's the problem, it's getting stuck on v.  Note the context has a requirement that  Model (v a) ~ [a], but that doesn't apply here since there's an 'Identity' in the way.
08:33:18 <archblob> byorgey: yes, it seems I overlooked the fact the for vectors models are defines to be just [a] not [Model a]
08:34:25 <archblob> byorgey: but if i'll try and define something for a general functor v i'll get a bunch of overlapping instances
08:34:58 <byorgey> indeed
08:35:02 <archblob> byorgey: and they don't relly consider the context
08:36:51 <narendraj9> What is the difference between where and let expressions?
08:37:10 <quicksilver> narendraj9: nothing. Except syntax.
08:37:20 <quicksilver> you can implement them in terms of each other
08:37:22 <byorgey> archblob: unfortunately I don't know what a good solution might be
08:37:26 <archblob> byorgey: when I first looked at that test suite I thought, whoa what a beauty, but I guess even though it is, it still needs some work
08:37:32 <quicksilver> but let attaches to expressions and where attaches to definitions
08:37:40 <quicksilver> and where scopes over guards
08:37:48 <narendraj9> quicksilver, I can use where bindings for simple expression as well?
08:38:04 <quicksilver> only if you rewrite your expression to be a definition
08:38:08 <narendraj9> > y = alpha where alpa = 10
08:38:10 <lambdabot>  <hint>:1:3: parse error on input `='
08:38:12 <quicksilver> no.
08:38:30 <int-index> lens are plain awesome
08:38:31 <quicksilver> > let y = alpha where alpha = 10 in y
08:38:32 <kuribas> Can I use fail in parsec to use my own error messages?
08:38:32 <lambdabot>  10
08:38:52 <kuribas> Say for showing type errors.
08:39:12 <archblob> byorgey: thank you for your help, I'll try and bang my had a little harder and maybe I can come up with something to fit that in
08:39:12 <narendraj9> quicksilver, okay. are the bindings that I introduce with where mutually recursive?
08:39:38 <bennofs> Is there already a name for \f -> maybe <*> f?
08:39:44 <bennofs> :t \f -> maybe <*> f
08:39:45 <lambdabot> (b -> a -> b) -> b -> Maybe a -> b
08:40:03 <bennofs> or maybe flip that
08:40:08 <quicksilver> narendraj9: they are.
08:40:14 <quicksilver> narendraj9: (and that is also true for let)
08:40:24 <supki> :t F.foldr
08:40:25 <lambdabot> Foldable t => (a -> b -> b) -> b -> t a -> b
08:40:29 <Walther> > [1..[2..10]]
08:40:31 <lambdabot>  No instance for (GHC.Show.Show t0)
08:40:31 <lambdabot>    arising from a use of `M353369268620103243310085.show_M3533692686201032433...
08:40:31 <lambdabot>  The type variable `t0' is ambiguous
08:40:31 <lambdabot>  Possible fix: add a type signature that fixes these type variable(s)
08:40:32 <bennofs> oh, right :D
08:40:32 <lambdabot>  Note: there are several potential instances:
08:40:36 <bennofs> thanks supki
08:40:46 <narendraj9> quicksilver, okay. So what are the guidelines I should follow when I have choice between the two. I mean what is good style?
08:40:58 <Walther> Hm, how to create a list of lists with truly ascending / descending lengths
08:41:20 <quicksilver> narendraj9: it is primarily a matter of taste. Do you like to define your subroutines before or after your code?
08:41:33 <byorgey> Walther: can you give an example?  What list of lists do you want to create?
08:41:37 <quicksilver> narendraj9: however, if you are using guards, then where's ability to scope over guards does make for elegant code.
08:41:41 <haasn> > map (`replicate` '.') [0..]
08:41:42 <lambdabot>  ["",".","..","...","....",".....","......",".......","........",".........",...
08:41:59 <quicksilver> narendraj9: I personally use 'let', all else being equal, and most experienced haskell programmers disagree with me.
08:42:01 <Iceland_jack> > map (join replicate) [1..]
08:42:02 <lambdabot>  [[1],[2,2],[3,3,3],[4,4,4,4],[5,5,5,5,5],[6,6,6,6,6,6],[7,7,7,7,7,7,7],[8,8,...
08:42:32 <kwantam> > map (flip take $ repeat 1) [1..]
08:42:33 <lambdabot>  [[1],[1,1],[1,1,1],[1,1,1,1],[1,1,1,1,1],[1,1,1,1,1,1],[1,1,1,1,1,1,1],[1,1,...
08:42:38 <narendraj9> quicksilver, so most people use where most of the time?
08:42:45 <Walther> Well, if I want [[1],[1,2],[1,2,3]] or the other way round
08:42:55 <Iceland_jack> quicksilver: I like using ‘let’ as such
08:42:55 <Iceland_jack>     function a b c d = let
08:42:55 <Iceland_jack>         e = ...
08:42:55 <Iceland_jack>         f = ...
08:42:57 <kwantam> > map (flip take $ [1,2..]) [1..]
08:42:58 <lambdabot>  [[1],[1,2],[1,2,3],[1,2,3,4],[1,2,3,4,5],[1,2,3,4,5,6],[1,2,3,4,5,6,7],[1,2,...
08:42:58 <Iceland_jack>         in e + f
08:43:14 <narendraj9> quicksilver, you don't like to use guard expressions? I didn't get you probably.
08:43:16 <Walther> kwantam: woo, thanks
08:43:35 <int-index> :t liftA maybe
08:43:37 <lambdabot> Applicative f => f a -> f ((a1 -> a) -> Maybe a1 -> a)
08:43:39 <Iceland_jack> > tail (inits [1..]) -- kwantam
08:43:40 <kwantam> also the [1,2...] is unnecessary but :)
08:43:40 <lambdabot>  [[1],[1,2],[1,2,3],[1,2,3,4],[1,2,3,4,5],[1,2,3,4,5,6],[1,2,3,4,5,6,7],[1,2,...
08:43:50 <quchen> let/where is either an obvious choice (e.g. where for guards), or one that you should make based on what's more readable.
08:43:50 <int-index> :t (maybe <*>)
08:43:51 <lambdabot> (b -> a -> b) -> b -> Maybe a -> b
08:43:52 <kwantam> Iceland_jack, indeed
08:44:30 <int-index> :t (<*>)
08:44:31 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
08:44:34 <int-index> :t liftA
08:44:35 <lambdabot> Applicative f => (a -> b) -> f a -> f b
08:44:54 <int-index> :t ap maybe
08:44:56 <lambdabot> (b -> a -> b) -> b -> Maybe a -> b
08:45:08 <quicksilver> Iceland_jack: so do I.
08:45:17 <quicksilver> narendraj9: yes, most people use where, given the choice.
08:45:28 <quicksilver> narendraj9: (I do like guards, and guards would be one of the reasons I would use where)
08:45:55 <narendraj9> quicksilver, okay. thanks quicksilver :-)
08:46:30 <Iceland_jack> I've never quite liked aligning the ‘let’ and ‘in’, it either feels too right-leaning or it makes you write it on a separate line which is rather ugly
08:46:30 <Iceland_jack>     function a b c d =
08:46:30 <Iceland_jack>         let ...
08:46:30 <Iceland_jack>         in ...
08:46:32 * hackagebot HaXml 1.24.1 - Utilities for manipulating XML documents  http://hackage.haskell.org/package/HaXml-1.24.1 (MalcolmWallace)
08:46:57 <Iceland_jack> Apart from ‘let’ being one character longer but that's an extreme thing to be picky about :)
08:47:25 <geekosaur> I tend to right-align them
08:47:36 <geekosaur> since it feels wrong for in to be at the same indentation level as let
08:47:40 <Iceland_jack>     let ...
08:47:40 <Iceland_jack>      in ...
08:47:40 <Iceland_jack> ?
08:47:43 <geekosaur> yes
08:47:49 <Iceland_jack> I can get behind that
08:48:15 <int-index> let ...
08:48:23 <int-index> in  ...
08:48:51 <int-index> A space after 'in' align it right too.
08:48:55 <int-index> aligns
08:48:56 <Iceland_jack> I'm not aware of other Haskellers who like their ‘where’s and ’let’s to be trailing like I do, it's perfectly fine for ‘module (...) where’, ‘instance ... where’ etc.
08:49:26 <Iceland_jack>     longFunctionBody a b c = d where
08:49:26 <Iceland_jack>         e = ...
08:49:26 <Iceland_jack>         f = ...
08:50:02 <int-index> I tend to do so if the first line doesn't get too long.
08:50:09 <thebnq> oh thats kind of neat, never seen the trailing where before
08:50:40 <Iceland_jack> I like the trailing ‘where’ when the expression before it is very short
08:50:44 <yitz> Iceland_jack: separating the in clause from the let bindings makes code much easier to read imho. so i like it on the next line, except in trivial cases. and i purposely do not want the in expression to align with the let bindings. so i don't add the space that int-index suggested.
08:51:31 <Iceland_jack> like for auxiliary functions
08:51:32 <Iceland_jack>     something = go 0 where
08:51:32 <Iceland_jack>       go n []     = ...
08:51:32 <Iceland_jack>       go n (x:xs) = ...
08:52:01 <thebnq> i might like the trailing where because i don't like it when all the where functions are indented so much
08:52:05 <thebnq> so i occassionally do
08:52:10 <thebnq> foo = x
08:52:11 <thebnq>   where
08:52:14 <thebnq>     bar
08:52:34 <thebnq> =s but i don't like it
08:52:35 <Iceland_jack> Yes I always find the indentation for regular ‘where’s very awkward
08:53:17 <yitz> Iceland_jack: i do like the idea of trailing where. but i hesitate to encourage it, because i'm sure some of our devs will end up abusing it and overall the effect could be negative.
08:53:24 <Iceland_jack> I've seen all of these and don't really like any
08:53:24 <Iceland_jack>     where a = ...
08:53:24 <Iceland_jack>     where
08:53:24 <Iceland_jack>     a = ...
08:53:24 <int-index> How about aligning the code like so?
08:53:25 <int-index> http://imgur.com/hUkim4u
08:53:27 <Iceland_jack>     where
08:53:30 <Iceland_jack>       a = ...
08:53:53 <Iceland_jack> int-index: Eh, it's okay but I wouldn't write it that way myself
08:54:26 <Iceland_jack> yitz: You should have a word with the Syntactic devs ;)
08:54:41 <yitz> they do it?
08:55:08 <davidthomas>  /lastlog cabal
08:55:13 <Iceland_jack> No they do
08:55:13 <Iceland_jack>     newtype Mon dom m a
08:55:13 <Iceland_jack>       where
08:55:13 <Iceland_jack>         Mon :: { ... } -> Mon dom m a
08:55:18 <Iceland_jack> http://hackage.haskell.org/package/syntactic-1.11/docs/src/Language-Syntactic-Frontend-Monad.html
08:55:25 <davidthomas> err, oops :-P
08:55:39 <Iceland_jack> same for ‘instance’s and ‘class’es
08:55:57 <Iceland_jack> (I'm not a fan of that at all for the record)
08:55:57 <yitz> newtype where?
08:56:26 <bennofs> yitz: GADT syntax I guess
08:56:42 <Iceland_jack> yitz: GADT
08:56:47 <yitz> for newtype?
08:56:52 <Iceland_jack> Yes
08:57:24 <yitz> weird. there can anyway only be one constructor
08:57:39 <yitz> and record syntax is now support for GADTs?
08:57:46 <yitz> *supported
08:58:00 <Iceland_jack> it has been for quite some time, the old version is now deprecated
08:58:36 <yitz> wow. i missed all that. it's already in 7.6?
08:59:29 <n-dolio> Yep.
08:59:37 <yitz> why in the world would you need a GADT for newtype? just for consistency with data?
08:59:52 <n-dolio> Think so.
09:00:03 <Iceland_jack> yitz: You get a lot of nice things with GADT syntax as well, like for existentials
09:00:15 <n-dolio> Yeah, but you can't use any of those in a newtype.
09:00:18 <Iceland_jack> but I'm guessing they just liked their where-syntax so much
09:00:50 <Iceland_jack> I personally find it very distracting, that's why I used it as a sneaky example to promote my way of writing it ;)
09:00:56 <yitz> heh
09:07:09 <quicksilver> well the way the GADT gives the type signature for the constructor is arguable clearer
09:18:26 <haasn> I've grown used to “where a = ...” and having the next line line up with the ‘a’
09:18:28 <haasn> but trailing where like that seems interesting
09:21:57 <dgpratt> int-e: thank you
09:26:36 * hackagebot th-printf 0.3.0.0 - Compile-time printf  http://hackage.haskell.org/package/th-printf-0.3.0.0 (JoelTaylor)
09:26:38 <joelteon> I like trailing where
09:26:48 <joelteon> I just recently discovered it was possible, and vim2hs indents it properly
09:27:06 <int-e> joelteon: fwiw, lambdabot is currently on 73 channels. /whois typically only shows the intersection of your own channels and the user's (though that depends on channel modes)
09:27:15 <joelteon> that's very odd
09:27:20 <joelteon> I've never seen an ircd that behaved like that
09:27:39 <peteretep> int-e: That's unusual for a whois
09:27:49 <peteretep> int-e: Mostly they will show non-secret channels
09:27:56 <peteretep> and mnany many channels tend to be set as secret
09:27:59 <peteretep> perhaps it's a freenode thing
09:28:07 <quicksilver> I suspect it's just that they're almost all secret
09:28:13 <geekosaur> secret seems to be the default
09:28:17 <quicksilver> and that causes the behaviour int-e remarks on
09:28:23 <thebnq> wow 73 =o
09:28:48 <johannesbodannes> wait, why is lambdabot on so many channels?
09:28:52 <haasn> yes, /whois on freenode certainly shows non-secret chanels as well
09:29:04 <haasn> johannesbodannes: because lots of channels need lambdabot!
09:29:07 <johannesbodannes> surely it's only applicable to a handful?
09:29:33 <johannesbodannes> <_<
09:29:36 <johannesbodannes> well, yes, haskell themed ones i'm guessing
09:29:41 <johannesbodannes> are there 73 haskell themed channels?
09:29:59 <thebnq> or haskell apps i suppose too
09:30:15 <geekosaur> it's not just haskell themed ones, I think. FP themed might be closer
09:30:15 <int-e> johannesbodannes: there are #haskell.cc channels for various country codes; then there's a couple of haskell projects like darcs or snap, and a collection of random social ones.
09:30:28 <haasn> #haskell-lens best subhaskell
09:30:43 <edwardk> it is for the haskell users who speak lens
09:30:49 * dwcook wonders if there's a #haskell-edwardk
09:30:50 <johannesbodannes> lol lens, i have been putting off learning lens so hard
09:30:53 <int-e> #unicycling is possibly the strangest (until you remember shapr)
09:30:58 <joelteon> dwcook: #haskell-lens and #haskell-edwardk are the same
09:31:07 <dwcook> Figures
09:31:21 <edwardk> #haskell-lens gets most of the build-bot updates from my projects
09:31:22 <joelteon> if you have a question about any of edwardk's libraries, just go in #haskell-lens
09:32:05 <johannesbodannes> augh i really SHOULD learn lens
09:32:12 <haroldcarr> I am having a problem with Aeson types.  Anybody available to help?
09:32:22 <johannesbodannes> it addresses a problem which i consistently experience when using haskell
09:32:31 <dwcook> haroldcarr, ask your question and a volunteer may present themself
09:32:34 <edwardk> johannesbodannes: i'll be doing another workshop, this year it should be at CUFP.
09:32:45 <haasn> edwardk: it is for the lens users who speak haskell*
09:32:45 <int-e> joelteon: ah it's a user mode, +i, "invisble" which hides channels you're on; freenode enables it by default.
09:33:33 <dwcook> int-e, with good reason, I'd say – I don't want spam bots hopping on the smaller channels I'm on :P
09:33:58 <int-e> dwcook: agreed.
09:34:39 <haroldcarr> Data.Aeson.Types.Internal defines: data Value = ... Number !Number ... , where Number is Data.Attoparsec.Number = I !Integer D !Double
09:34:40 <haroldcarr> but
09:34:55 <haroldcarr> in GHCi when I do :t Number
09:35:09 <haroldcarr> I get Number :: scientific-0.2.0.1:Data.Scientific.Scientific -> Value
09:35:20 <joelteon> yes, you are looking at out-of-
09:35:22 <joelteon> date documentation
09:35:25 <joelteon> damn enter key
09:35:50 <joelteon> haroldcarr: see http://hackage.haskell.org/package/aeson-0.7.0.2/docs/Data-Aeson.html#t:Value
09:35:53 <haroldcarr> I think this is causing integers to be written as 1.0 instead of 1 which mean I can read them back in after writing them out.
09:35:59 <edwardk> haroldcarr: 0.7 changed the type of Number
09:36:09 <joelteon> correct, javascript doesn't have integers, so aeson decided not to have them either
09:36:22 <edwardk> haroldcarr: it merged Int and Double into one case, and switched to Number.
09:36:30 <edwardk> er to Scientific
09:37:12 <haroldcarr> ah - I thought I was looking at the lastest (because I have the Chrome extension that tells me when I am not)
09:37:21 <haroldcarr> thanks! but I might be back with another question
09:38:57 <edwardk> It is rather needlessly precise as ECMA limits itself to IEEE 754 doubles.
09:39:19 <edwardk> "The Number type has exactly 18437736874454810627 (that is, 264−253+3) values, representing the double-precision 64-bit format IEEE 754 values as specified in the IEEE Standard for Binary Floating-Point Arithmetic, except that the 9007199254740990 (that is, 253−2) distinct “Not-a-Number” values of the IEEE Standard are represented in ECMAScript as a single special NaN value.
09:39:44 <edwardk> so using Scientific is a lot of pain for no real standard gain.
09:40:11 <joelteon> those crazy aeson maintainers.
09:40:22 <dwcook> Does this mean you could use this to generate JSON that an average JS implementation is incapable of reading correctly?
09:40:27 <johannesbodannes> ...wait what? 9007199254740990 NaN values?
09:40:39 <edwardk> dwcook: well, incapable of round-tripping correctly
09:40:46 <joelteon> well, you could produce number literals that
09:40:49 <joelteon> yeah
09:41:08 <yesthisisuser> that is the NaN value representation
09:41:15 <haroldcarr> I'm trying the aeson example from the Beginning Haskell book and can read back in what it writes out - I thought it might have something to do with the number format.  When did the Aeson Number change happen?
09:41:23 <haasn> dwcook: if JSON is defined in terms of JS, then surely the answer is no
09:41:26 <joelteon> haroldcarr: 0.7
09:41:28 <haroldcarr> I meant CANNOT read back in
09:41:32 <haasn> (I don't know how JSON is defined)
09:41:38 * hackagebot recaptcha 0.1.0.1 - Functions for using the reCAPTCHA service in web applications.  http://hackage.haskell.org/package/recaptcha-0.1.0.1 (JohnMacFarlane)
09:41:53 <dwcook> haasn, according to the spec at json.org, there are more representable number values in JSON than in JS
09:42:04 <shapr> int-e: Hopefully you still remember me :-)
09:42:05 <haasn> okay
09:42:21 <dwcook> haasn, well, it doesn't say that directly, but you can apply the number production ad infinitum
09:42:36 <edwardk> johannesbodannes: if you break up a NaN it has a sign, an exponent (all 1s for a NaN), and a signaling flag, then all the remaining bits are anything you want.
09:42:48 <int-e> shapr: Of course.
09:42:51 <kwantam> johannesbodannes, ieee 754 has one exponent value set aside for "special" things, and since it's an 11-bit exponent with a 53-bit mantissa, there are 2^53 possible values with the "special" exponent flag
09:42:54 <kwantam> viz, all ones
09:42:58 <dwcook> So really the problem is that the JSON interpreter in JS is deficient
09:43:04 <johannesbodannes> ...i see!
09:43:05 <kwantam> or well 10-bit exponent and sign
09:43:20 <kwantam> (wait, is that true...?)
09:43:22 <haasn> I never knew JSON had null. Why does JSON have null?
09:43:33 <dwcook> haasn, because JavaScript has null, presumably
09:43:43 <edwardk> johannesbodannes: this actually lets you cram x86-64 legal pointers into a legal IEEE754 double by starting them with 1s using the way pointers can start with leading 1s or 0s
09:43:55 <edwardk> > 0/0 -- haasn
09:43:56 <lambdabot>  NaN
09:44:25 <edwardk> kwantam: technically its 52 bits of mantissa with an implicit leading 1
09:44:46 <edwardk> and they switched to calling it significand these days
09:45:00 <dwcook> JSON.stringify(NaN) // -> 'null'
09:45:32 <kwantam> edwardk, right
09:45:55 <edwardk> one of these days i need to go back to work on compensated. =)
09:46:00 <kwantam> 52-bit + sign + 10-bit + exponent sign
09:46:00 <Hafydd> I'm more concerned about the ridiculous name "stringify" becoming standardised.
09:46:30 <kwantam> ieee 754 is kind of marvellous
09:46:31 <haasn> dwcook: seems like it
09:46:39 <kwantam> s/ll/l/
09:48:33 <joelteon> compensated depends on lens <4 D:
09:48:39 <edwardk> joelteon: good point
09:49:15 <haroldcarr> let tj = toJSON (Company    (2 :: Integer) "CompanyFoo" (Person "harold" "carr") "role")
09:49:23 <zomg> Hafydd: stringify is already standardized sadly :p
09:50:51 <edwardk> hrmm, messy. i can't just make Compensated Typeable1 the way i used to
09:51:39 <kuribas> Is there a reason to use liftM instead of fmap?
09:52:10 <kwantam> (also, edwardk, the implicit 1 isn't there for denormals, of course, but the NaN exponent and the denormal exponent are obviously distinct!)
09:52:22 <joelteon> Functor is not a superclass of Monad, so if you don't want to incur a "Functor m" constraint, use liftM
09:52:38 <edwardk> kwantam: yes =)
09:52:39 <joelteon> note that in the future Functor *will* be a superclass of Monad, in which case it won't be an issue anymore
09:52:56 <kuribas> ah, I see
09:53:45 <edwardk> kuribas: think of liftM as an admissable free definition for fmap if you have a Functor. until Functor is a superclass of Monad, it can occasionally avoid incurring a spurious Functor m constraint.
09:53:56 <edwardk> the latter scenario goes away with 7.10
09:54:15 <edwardk> the former scenario, well, it becomes the default definition via default signatures in 7.10 i think
09:54:27 <thebnq> will applicative be pulled into prelude too?
09:54:28 <edwardk> or the liftA version does i think
09:54:31 <edwardk> thebnq: yes
09:54:39 <edwardk> thebnq: that is the current plan
09:54:44 <johannesbodannes> why wasn't functor a superclass of monad to begin with?
09:54:53 <kuribas> <$> will be nice too.
09:54:56 <johannesbodannes> that seems fairly stupid
09:54:58 <joelteon> johannesbodannes: hysterical raisins
09:55:00 <thebnq> nice
09:55:30 <vozz> I made a session middleware for scotty (or I guess wai). Would anyone mind taking a look at it and how I might make it more concise to use? I feel like I have to repeat myself a lot when using it
09:56:28 <c_wraith> johannesbodannes: The current plan is to actually make Applicative the direct superclass of Monad..  And Applicative didn't exist when Haskell 98 was finalized.
09:56:33 <vozz> Here's the session middleware https://github.com/ollieh/scotty-sessions/blob/master/Web/Scotty/Sessions.hs and here's an example website with accounts and flash messages https://github.com/ollieh/scottyaccounts/blob/master/Main.hs
09:56:48 <c_wraith> johannesbodannes: so there's some minor accidental value in the old error.
09:57:09 <edwardk> johannesbodannes: we had to wait until all the objectors stopped caring
09:57:12 <Walther> Uhm. How do I getLines an input file, lines and words the input to a list of lists (file is a list of lines, line is a list of words) *but* ignore lines that start with # (a comment)
09:57:34 <edwardk> johannesbodannes: Applicative wasn't a superclass of Monad because it didn't exist. That one is more forgivable =)
09:58:14 <kwantam> Walther, so you have a list of lines, some of which begin with #
09:58:17 <edwardk> but in general the old argument was basically that you didn't need Functor and that it caused a couple of lines of boilerplate for all these Monads.
09:58:22 <kwantam> and you know that the ones that begin with # are the ones you want to ignore, right?
09:58:29 <edwardk> back in a time when more people wrote monads from scratch that cost was viewed as high
09:58:34 <kwantam> in other words, you want to filter the list of lines
09:58:40 <edwardk> now that we have more perspective that argument looks silly.
09:58:52 <edwardk> because it missing causes folks like me to have to write 2x as much code on top
09:59:15 <Walther> kwantam: hmmm... realLines = filter (head line != "#") lines -- or something like that?
09:59:23 <edwardk> since we have to deal with needless applicative/monad distinctions everywhere.
10:00:58 <allsystemsarego> hi all, haskeline's getInputChar does not capture arrow keys, are there any options if I want that?
10:01:11 <c_wraith> edwardk: are type signatures in base going to be made more permissive?  like, making liftM only require Functor?
10:02:14 <edwardk> c_wraith: liftM requiring functor actually creates cyclic definitions
10:02:31 <edwardk> c_wraith: consider all the users who wrote monads, then write functors using fmap = liftM
10:02:44 <edwardk> c_wraith: but in general, things like mapM will lower to requiring Applicative
10:02:54 <edwardk> and that will just be an alias for traverse.
10:03:22 <c_wraith> Ah.  So things that aren't matches to the class definitions.
10:05:03 <haasn> liftM should be DEPRECATED in favor of fmap and fmapDefault :: Monad m => (a -> b) -> m a -> m b -- should be added
10:05:29 <Athas> haasn: but isn't that just a longer name for the same thing?
10:06:18 <c_wraith> Athas: more importantly, it's a name that's not in use
10:06:35 <c_wraith> Athas: so existing code (probably) doesn't collide with it.
10:06:40 * hackagebot hyperloglog 0.2.3.1 - An approximate streaming (constant space) unique object counter  http://hackage.haskell.org/package/hyperloglog-0.2.3.1 (EdwardKmett)
10:06:46 <c_wraith> (though I have seen that name used for a function before)
10:07:19 <edwardk> haasn: that _is_ fmap. and fmapDefault would collide with the fmapDefault w're getting from Data.Traversable.
10:07:24 <edwardk> er that _is_ liftM
10:08:20 <haasn> Athas/edwardk: the idea is to weed out all current uses of ‘liftM’ in favor of the more general and perhaps more efficient ‘fmap’; and only reintroduce it where it is actually being used to default ‘fmap’, which I think is the less common use case
10:08:23 <edwardk> After the change, the only (not just for backwards compatibility) use of liftM will be for the default definition for fmap.
10:08:30 <haasn> edwardk: isn't Data.Traversable designed to be imported qualified anyway?
10:08:50 <edwardk> haasn: we're replacing the corresponding machinery in Prelude with it
10:08:53 <edwardk> so no
10:09:04 <haasn> okay
10:09:20 <an92> Hello :D, any mentors for GSOC online ?
10:09:32 <edwardk> an92: yes. there is also #haskell-gsoc
10:09:49 <an92> oh, I didn't know about haskell-gsoc :D
10:16:45 <vozz> If I have two similar lists of the same length and type, how can I filter one, leaving behind just the entries which are the same, or just the ones that are different?
10:17:38 <peteretep> sounds like you want the intersection and diff, respectively
10:17:51 <peteretep> http://hackage.haskell.org/package/base-4.2.0.1/docs/Data-List.html
10:18:13 <haasn> what an ancient documentation
10:18:23 <peteretep> interesection is called 'intersect', and diff is called (\\)
10:18:26 <jmcarthur> vozz: are you looking to treat the lists as sets or is the ordering important?
10:18:38 <verement> > [1..10] \\ [5..15]
10:18:40 <lambdabot>  [1,2,3,4]
10:18:53 <peteretep> jmcarthur has an excellent point though
10:18:55 <jmcarthur> > [1..10] \\ [5,2]
10:18:56 <lambdabot>  [1,3,4,6,7,8,9,10]
10:19:14 <peteretep> different answers depending on if you have sets or lists
10:20:07 <jmcarthur> http://hackage.haskell.org/package/Diff-0.3.0/docs/Data-Algorithm-Diff.html   -- if order is important, this may be more like what you want
10:21:41 * hackagebot hermit 0.4.0.0 - Haskell Equational Reasoning Model-to-Implementation Tunnel  http://hackage.haskell.org/package/hermit-0.4.0.0 (AndrewFarmer)
10:25:11 <kstt> Hi. I must map over a list of String to parse elements to Date. Parsing, by nature, is partial, so some elements might not be parsable. I want the result to be 'Either String [Date]', so either everything is fine (Right ...), or I want the first error (Left ...). What function should I use to "map but maybe fail" ?
10:26:04 <triliyn> kstt: mapM
10:26:05 <c_wraith> kstt: mapM should do that.
10:26:26 <c_wraith> :t mapM (undefined :: a -> Either b c)
10:26:27 <lambdabot> [a] -> Either b1 [b]
10:26:41 * hackagebot adblock2privoxy 1.0.0 - Convert adblock config files to privoxy format  http://hackage.haskell.org/package/adblock2privoxy-1.0.0 (zubr)
10:27:08 <Walther> I have a defined function "foo" that does stuff on lists of lists of integers, and outputs a single integer. Now I also have a parser in main do block that reads a file and parses it to a list of lists of integers. However, if I try to "answer <- foo parsedContent", I get weird type errors
10:27:37 <kstt> Ah, yes, indeed ! MapM + Either. Thank you very much triliyn and c_wraith.
10:29:04 <kstt> Beautiful Haskell ...
10:29:11 <k00mi> Walther: seeing the code would be helpful, but does foo return IO Integer or just Integer?
10:29:30 <Twey> int-e: Thanks a lot!  Haha, I never know what timezone people are in.
10:31:25 <Walther> k00mi: Well, I haven't defined the functions type manually, and the function itself is defined "purely".
10:31:40 <Walther> I should be able to call the function for some parsed input in main do block though?
10:32:31 <triliyn> Walther: show us the code and/or errors in more detail
10:33:11 <Walther> Couldn't match type `Int' with `IO a0' Expected type: [[IO a0]] Actual type: [[Int]]
10:34:08 <k00mi> @where lpaste
10:34:08 <lambdabot> http://lpaste.net/new/haskell
10:34:14 <k00mi> Walther: paste the code there ^
10:34:49 <Walther> http://lpaste.net/3017879991967809536
10:35:31 <haasn> Walther: why did you write “answer <- count tidy2” and not “let answer = count tidy2”?
10:35:57 <Walther> haasn: there we go, thanks a bunch!
10:36:10 <haasn> Walther: do you know what the “<-” signifies here?
10:36:14 <Walther> I need to learn where to use and where not to use = vs <- in main blocks
10:36:25 <haasn> Walther: <- binds the result of an IO action. = introduces a pure definition
10:36:39 <haasn> Walther: if “count tidy2” was an IO action, the <- would make sense
10:36:43 <haasn> Walther: but “count” is a pure function
10:36:47 <haasn> so there's no I/O to be performed
10:37:00 <Walther> haasn: mmh, and hence I thought i need to use <- there as it is "impure" data as it comes from IO (thinking "dirty" / IO being sticky)
10:37:09 <Walther> But yeah, thanks!
10:37:30 <haasn> that's essentially what the error is trying to tell you: the result of ‘count’ is an Int, but the <- expects it to be some IO action, eg. ‘IO a0’ for some a0
10:37:44 <haasn> Walther: the ‘count’ is already bound from the readFile action
10:38:00 <haasn> Walther: “count” is a pure value, representing the result of that action
10:38:30 <haasn> “IO” in Haskell isn't anything like a “dirty marker”, if that's what you were thinking
10:38:58 <haasn> it's an entirely conceptually different thing; an “IO String” is like a program that, when executed, would produce a String (or throw an exception)
10:39:43 <haasn> It has as little to do with an actual string (perhaps representing the result) as the contents of /bin/ls have to do with a list of files
10:40:58 <Walther> mmh, I know it's not really a "dirty marker" but ...i've faced similarities towards that kind of behavior :P Then again; I'm *really* just taking my first steps with haskell.
10:41:42 * hackagebot chatty 0.5.4.0 - Some monad transformers and typeclasses to simplify I/O on a transformer stack.  http://hackage.haskell.org/package/chatty-0.5.4.0 (implementation)
10:41:45 * hackagebot antisplice 0.12.3.0 - An engine for text-based dungeons.  http://hackage.haskell.org/package/antisplice-0.12.3.0 (implementation)
10:41:46 * hackagebot ironforge 0.1.0.15 - A technical demo for Antisplice.  http://hackage.haskell.org/package/ironforge-0.1.0.15 (implementation)
10:41:49 * hackagebot antagonist 0.1.0.7 - A web interface to Antisplice dungeons.  http://hackage.haskell.org/package/antagonist-0.1.0.7 (implementation)
10:42:02 <eacameron> noob question: I want to make a simple IO-like monad that gives me MVar protected versions of putStrLn (multithreaded app). I don't want to pass the mvar around everywhere, so I want to create a monad with it included. Should I use StateT with IO or something to achieve this?
10:42:50 <c_wraith> eacameron: what you describe could be done with ReaderT
10:43:08 <haasn> Walther: it's fine, I just wanted to clear it up as soon as possible because it's a really important realization to make before you're able to start really working with haskell IO
10:43:32 <eacameron> c_wraith: excellent..MVars requirire modification because of takeMVar, that's doable inside Reader?
10:43:34 <haasn> Walther: you may also be interested in http://www.haskell.org/haskellwiki/Introduction_to_IO
10:44:00 <c_wraith> eacameron: well, you'd need ReaderT WhateverEnvType IO
10:44:31 <c_wraith> eacameron: but the important part is that the MVar itself is always the same, so ReaderT suffices.
10:44:36 <k00mi> eacameron: you don't modify the MVar itself, you modify what it points at
10:44:39 <haasn> Walther: ps. you can have multiple definitions in a single “let” block; and due to the way haskell's block layout works that means you can drop the ‘let’ keyword from your subsequent lines
10:44:53 <haasn> (as long as you align them so the names match up)
10:44:56 <eacameron> c_wraith: k00mi: great! I'll give that a whirl
10:45:18 <thaicares> I'm very new and got stuck here http://en.wikibooks.org/wiki/Haskell/Truth_values#Guards
10:45:31 <thaicares> for some reason the abs function won't work for negative numbers...
10:45:46 <geekosaur> negative numbers are weird
10:46:00 <geekosaur> you need to parenthesize them, because they're a parser hack
10:46:02 <thaicares> should I be enclosing them (-x) ??
10:46:07 <geekosaur> yes
10:46:09 <thaicares> oh ok
10:46:23 <thaicares> should had thought about that on my own!
10:46:24 * haasn wonders how geekosaur figured that out from the information thaicares provided
10:46:36 <c_wraith> thaicares: otherwise the parser thinks you mean subtraction.  It's a silly corner case.
10:46:47 <jmcarthur> haasn: i don't know, but it was my first thought as well
10:46:53 <thaicares> understood, thank you :D
10:47:00 <c_wraith> and probably almost always the first silly corner case people run into in haskell.  Sigh.
10:47:05 <geekosaur> yes, was just a guess but given the mention of negative numbers it's an obvious guess
10:47:38 <thaicares> I'm new to programming in general, I've done very little python
10:47:53 <thaicares> my most work has probably been in internet tech php and javascript
10:47:59 <c_wraith> thaicares: well, have fun.  And feel free to ask us any more questions you have.
10:48:01 <thaicares> not sure if I should count html and css
10:48:22 <thaicares> c_wraith THANKS
10:48:24 <thaicares> will do
10:53:01 <Walther> Hmm, I'm having slight trouble filtering out the comment line - http://lpaste.net/3017879991967809536
10:53:48 <Rufflewind_> What's the most sane way to handle "indirect dependencies on multiple versions of a package"?
10:55:52 <haasn> Rufflewind_: patching one of the libraries that pulls in the older dependency.
10:56:32 <Rufflewind_> haasn: the issue is that all but one of the libraries uses a newer dependency
10:56:36 <Walther> Gah, filter is difficult ._.
10:57:27 <haasn> Rufflewind_: then patch the library that is incompatible with the newer dependency
10:57:47 <haasn> that is without a doubt the “most sane way” to resolve this issue, once and for all
10:58:01 <Walther> Help much appreciated, trying to filter out comments (the line with "filter") http://lpaste.net/3017879991967809536
10:58:18 <k00mi> Walther: either put backticks around notElem (so it's infix) or write it like normal function application: notElem '#'
10:59:07 <haasn> Walther: I'm not sure what ("#" not head) is supposed to mean
10:59:53 <Walther> fixed, just a sec :)
11:00:21 <haroldcarr> k
11:00:55 <haasn> Walther: that parses as standard function application, which means you're applying "#" to “not”, and the result of that to “head” - however "#" is not a function, so that does not make a lot of sense
11:01:10 <Walther> updated a bit
11:01:44 * hackagebot cabal-cargs 0.1.1 - A command line program for extracting compiler arguments from a cabal file.  http://hackage.haskell.org/package/cabal-cargs-0.1.1 (DanielTrstenjak)
11:02:32 <Walther> now having a bit of an issue with supplying the filename, but after fixing that I should be able to start refining / making the whole thing more readable
11:02:49 <haasn> Walther: how do you want to supply the filename?
11:02:58 <haasn> oh, I see it; via the STDIN
11:03:13 <haasn> Walther: readLn is probably not what you want
11:03:21 <samegame> hello I was wondering what would be the type signature of (:).f where f is opf ther type signature (a->b)
11:03:29 <Walther> haasn: ok, what then?
11:04:08 <k00mi> :t (:) . (undefined :: a -> b)
11:04:10 <lambdabot> a -> [b] -> [b]
11:04:11 <haasn> Walther: readLn :: Read a => IO a -- the Read type class is basically an ad-hoc parser; it describes values that can be parsed (or “read”) from a string, eg. read "5" = 5; read "('a',Just 3)" = ('a', Just 3)
11:04:13 <k00mi> samegame: ^
11:05:04 <haasn> Walther: notably, readLn is *not* an identity for strings, it parses them according to the rules of string literals, so eg. read "\"hello world\"" = "hello world", but read "hello world" :: String -- does not parse
11:05:25 <c_wraith> samegame: are you looking at someone's implementation of map in terms of foldr?  that's where I normally see that construction.
11:05:26 <haasn> Walther: you probably want getLine :: IO String -- which always just returns the line of input as supplied by the user, instead of trying to parse it according to some Read instance
11:05:26 <davidfetter_disq> beware /ad hoc/ parsers :/ http://langsec.org/ :: http://www.cs.dartmouth.edu/~sergey/langsec/
11:05:37 <haasn> davidfetter_disq: yes, beware Read. It fully applies
11:05:46 <davidfetter_disq> :)
11:06:00 <c_wraith> at least Read just crashes if you see something weird, instead of executing arbitrary code
11:06:03 <davidfetter_disq> glad to see langsec is starting to be part of people's decision making in the design phases :)
11:06:13 <haasn> davidfetter_disq: absolutely, I learned a lot from langsec
11:06:26 <samegame> k00mi: pretty much what I suspected I wonder how does composition work in this case usually composition type signature is defined as (c->a)->(b-c)->(b->a)
11:06:34 <samegame> c_wraith : yeah pretty much :)
11:07:12 <haasn> samegame: ‘a’ can be any type, including other functions
11:07:29 <c_wraith> I like all the dynamic languages' ad-hoc parsers that can be coerced into executing arbitrary code, then are embedded in their flagship web frameworks.  Err, I guess that's just ruby, but they do love to make that mistake in ruby. :)
11:07:47 <Walther> haasn: works, thanks!
11:08:00 <k00mi> samegame: keep currying in mind
11:08:15 <companion_cube> c_wraith: you mean like reading json in javascript by calling eval()? :)
11:08:32 <haasn> :t (.) `asTypeIn` \comp -> (:) `comp` undefined
11:08:33 <lambdabot> (b -> [b] -> [b]) -> (a -> b) -> a -> [b] -> [b]
11:08:58 <haasn> samegame: ^ read that as (b -> ([b] -> [b]) -> (a -> b) -> (a -> ([b] -> [b]))
11:09:02 <haasn> and you should see the connection to the type of (.)
11:09:23 <c_wraith> companion_cube: rails had two bugs announced at the same time one time, where its magic query string parsing of special formats could result in arbitrary code execution - for features most rails users didn't even know existed.
11:09:51 <samegame> haasn: you're right, how does on e go from (.) :: a->[a]->[a]  to (c->b) ? I mean do you choose a->[a] as  c or b to implement in composition formula (c->b)->(b->a)->(a->c) ?
11:09:53 <c_wraith> companion_cube: more or less, it would try parsing query args as yaml or xml in some circumstances, with a parser that could execute arbitrary code.
11:10:25 <c_wraith> companion_cube: and this was done automatically, unless the rails developer went to extra effort to disable those parsers
11:10:41 <companion_cube> well sure, convention over configuration
11:11:31 <haasn> samegame: you choose ‘a’ as ‘c’, and choose ‘[a] -> [a]’ as ‘b’
11:11:36 <haasn> samegame: -> is right associative
11:12:01 <haasn> so (a -> [a] -> [a]) is at the top level (a -> ..something..)
11:12:01 <c_wraith> companion_cube: conventially, we like insecurity! :)
11:12:38 <haasn> samegame: which means its first parameter, a, much match with the first parameter of ‘c -> b’, namely ‘c’. IT also means that the ..something.. must match with the ‘b’
11:12:46 <haasn> in this case [a] -> [a]
11:12:57 <samegame> haasn: I keep forgetting right associative means ..( a->b->c) means (a->(b->c)) right?
11:13:19 <haasn> samegame: so you can go ahead and rewrite all occurrences of “b” and “c” in the type of (.) by “[a] -> [a]” and “a”, respectively  (but be careful to rename the *other* a first)
11:13:24 <haasn> samegame: yes
11:13:38 <c_wraith> companion_cube: and at least Read doesn't do that!  the parser is chosen by the type, not the input. :)
11:13:51 <samegame> hasn : understood. Thanks for the help and info.
11:14:14 <Rufflewind_> haasn: thanks; passed --constraint and rebuilt the package so now it works
11:14:22 <companion_cube> I don't understand why read doesn't return Maybe, though
11:14:23 <companion_cube> :t read
11:14:24 <lambdabot> Read a => String -> a
11:14:30 <haasn> samegame: (the type signature you just gave for (.) is also slightly incorrect, I think you meant (b->c) -> (a->b)
11:14:36 <henk> Could this function http://lpaste.net/101408 with signature "diffTimeToHMSString :: NominalDiffTime -> T.Text" be made more generic in any way?
11:16:07 <henk> Any way to accept Ints as well? Any way to avoid printf?
11:17:16 <carter> printf is a code smell for haskell :)
11:18:41 <carter> haasn: fromIntegral?
11:20:07 <haasn> fromIntegral?
11:20:11 <haasn> oh
11:20:18 <haasn> that was for henk :)
11:20:29 <carter> yup
11:20:35 <henk> carter: Yeah, it’s not very elegant, but I don’t know how to avoid it ):
11:20:52 <carter> haasn: you want your own renderable dsl bascially :)
11:21:46 * hackagebot yesod-core 1.2.8 - Creation of type-safe, RESTful web applications.  http://hackage.haskell.org/package/yesod-core-1.2.8 (MichaelSnoyman)
11:21:48 * hackagebot yesod-form 1.3.8 - Form handling support for Yesod Web Framework  http://hackage.haskell.org/package/yesod-form-1.3.8 (MichaelSnoyman)
11:21:49 <henk> carter: NominalDiffTime is not an instance of Integral, which would be required for use of fromIntegral AFAIU. Correct?
11:21:50 * hackagebot yesod-static 1.2.2.2 - Static file serving subsite for Yesod Web Framework.  http://hackage.haskell.org/package/yesod-static-1.2.2.2 (MichaelSnoyman)
11:21:52 <haasn> carter: perhaps!
11:21:52 * hackagebot wai-app-static 2.0.0.4 - WAI application for static serving  http://hackage.haskell.org/package/wai-app-static-2.0.0.4 (MichaelSnoyman)
11:21:54 * hackagebot warp 2.1.1.2 - A fast, light-weight web server for WAI applications.  http://hackage.haskell.org/package/warp-2.1.1.2 (MichaelSnoyman)
11:22:10 <haasn> carter: but perhaps also something higher level than primitives
11:22:12 <carter> henk: yeah
11:22:17 <carter> both yeah
11:22:27 <carter> henk: is time a number
11:22:30 <carter> or a social construt
11:23:41 <haasn> henk: the easiest way to avoid printf is to make the structure explicit, eg. hours ++ ":" ++ minutes ++ ":" ++ seconds where ...
11:24:03 <haasn> more verbose, but safer and more rigid, insofar as you get to avoid printf
11:24:13 <haasn> (although you can use printf+TH to make it safer)
11:26:05 <henk> carter: uhm, not sure how you mean that question … In that case it’s a number.
11:26:20 <haasn> Hmm.. the Fractional constraint should perhaps be removed from RealFrac
11:26:33 <haasn> Then we could use “floor, ceiling, round” etc. on possibly Integral types, too
11:26:38 <haasn> which makes perfect sense
11:26:46 <henk> haasn: And then work with ifs and such to get the proper formatting? I need the resulting strings zero-padded …
11:26:48 <haasn> because they are well-defined operations (all of them being identity)
11:27:16 <haasn> henk: yes, ultimately; where hours | h < 10 = '0' : show h | otherwise = show h
11:27:32 <haasn> or:
11:28:12 <haasn> hours = pad 2 (show h) where pad l s = replicate (l - length s) ' ' ++ s
11:28:17 <haasn> for a more general approach to padding
11:29:12 <haasn> (note: won't work well for stuff involving non-single-width-character code points; not that I think %02 will fare any better :)
11:31:41 <henk> haasn: I see, thank you. I don’t think I like taking that approach though /-: It seems a little hackish and not as concise as printf IMHO.
11:32:13 <beaky> hello
11:35:15 <haasn> henk: if you're desperate to get rid of the printf but don't want to lose the simplicity of having a format descriptor, you could try one of the strongly typed alternatives such as http://hackage.haskell.org/package/xformat
11:36:43 <haasn> this is basically used like showf (Int % Char ':' % Align R 2 Int % Char ':' % Align R 2 Int)
11:36:47 * hackagebot Glob 0.7.4 - Globbing library  http://hackage.haskell.org/package/Glob-0.7.4 (MattiNiemenmaa)
11:37:23 <haasn> err, that Char should be an Id
11:38:41 <narendraj9> What are some applications written in Haskell that people use daily?
11:38:53 <bennofs> narendraj9: cabal, ghc :D
11:39:24 <narendraj9> bennofs, things that are not related to using haskell for the sake of using it only. :-D
11:39:38 <geekosaur> xmonad?
11:39:39 <narendraj9> I just want to have some applications.
11:39:46 <geekosaur> some people use pandoc a lot.
11:39:46 <narendraj9> that I can use.
11:39:52 <geekosaur> git-annex
11:39:58 <haasn> I use these (nearly) daily: ghc, cabal, haddock, xmonad, lambdabot, yeganesh, vimus and surely some more that don't immediately come to mind
11:40:06 <narendraj9> geekosaur, yes! applications like that. xmonad is a good example.
11:40:47 <narendraj9> haasn, lambdabot is written in haskell? I don't know how irc bots are written.
11:41:10 <geekosaur> yes
11:41:11 <Fuuzetsu> haasn: yeganesh?
11:41:12 <Zekka> Well, an IRC bot just uses sockets to communicate with an IRC server -- you can do this in most programming languages
11:41:20 <narendraj9> geekosaur, git-annex is..? git written in haskell?
11:41:20 <Fuuzetsu> first time I hear the name
11:41:21 <Zekka> Lambdabot works the same way, and it's written in Haskell
11:41:24 <geekosaur> yeganesh is a wrapper for dmenu that adds features
11:41:38 <haasn> narendraj9: IRC bots aren't very special, they're just anything that implements the IRC protocol and has some bot logic in it
11:41:38 <Fuuzetsu> so xmobar type of thing?
11:41:40 * bennofs uses xmonad and xmobar
11:41:53 <geekosaur> git-annex lets you store metadata in git without storing files; useful for large binary data sets or other things that git isn't really very good at
11:41:53 <haasn> Fuuzetsu: no, dmenu wrapper
11:42:01 <geekosaur> (or images etc.)
11:42:07 <haasn> I use xmobar and yeganesh
11:42:08 <Fuuzetsu> I wait for the day that xmobar uses Haskell for config instead of that ‘looks like Haskell but it sure as hell ain't one’
11:42:15 <narendraj9> geekosaur, yes. git isn't good for game development I have heard.
11:42:24 <Fuuzetsu> uhh
11:42:26 <geekosaur> so, for example, it makes more sense to back up one's homedir with git-annex than raw git
11:42:39 <geekosaur> ("=fsvo "back up")
11:42:52 <dmj`> * Missing C libraries: crypto, ssl, trying to install HsOpenSSL on ubuntu. openssl is installed, what C libraries are for crypto?
11:43:06 <haasn> narendraj9: well it's not efficient at storing very large files, especially ones that change frequently
11:43:18 <geekosaur> dmj` do you have the openssl devel package?
11:43:23 <narendraj9> Fuuzetsu, I haven't used xmobar. i use awesome window manager.
11:43:26 <haasn> that is what git-annex is developed for, although it is, of course, a trade-off
11:43:29 <geekosaur> the runtime is not sufficient
11:43:52 <dmj`> geekosaur: tried sudo apt-get install openssl-devel, doesn't exist
11:44:05 <geekosaur> I would expect something like libopenssl-dev
11:44:19 <narendraj9> haasn, true. git wasn't designed with large binary files in mind. text files were the center of concern.
11:44:22 <Zekka> dmj` -- apt-cache search openssl?
11:44:40 <dmj`> libssl-dev seems to be installing...
11:44:44 <geekosaur> in fact it is libssl-dev apparently
11:45:06 <geekosaur> "openssl-devel" is a red hat-ish name
11:45:11 <narendraj9> any music player written in Haskell?
11:45:55 <Zekka> Googling a little bit -- yes, actually, although you probably don't use any of them
11:46:00 <Zekka> http://www.haskell.org/haskellwiki/Applications_and_libraries/Music_and_sound
11:46:31 <grayling> https://github.com/ivitjuk/Haskell-Music-Player/wiki
11:46:44 <beaky> @pl \s -> print s >> getLine
11:46:45 <lambdabot> (>> getLine) . print
11:46:47 <ystael> Has anyone written a true textbook of "advanced functional programming"?
11:46:48 * hackagebot http-reverse-proxy 0.3.1.1 - Reverse proxy HTTP requests, either over raw sockets or with WAI  http://hackage.haskell.org/package/http-reverse-proxy-0.3.1.1 (MichaelSnoyman)
11:47:06 <Zekka> ystael - What do you think that would entail? Functional languages aren't all created equal.
11:47:09 <ystael> (The bibliography linked to from the haskellwiki, at http://www.catamorphism.net/, now appears to be a blog reviewing children's books?
11:47:11 <dmj`> ystael: nah, there's just a bunch of fake ones
11:47:16 <haasn> narendraj9: I don't know of any actual music player but if you're satisfied with an MPD front-end, I use vimus which I helped develop, in Haskell
11:48:13 <ystael> dmj`: What I mean by that is an expository survey of higher order techniques which are in papers or folklore in the community
11:48:40 <haasn> narendraj9: technically, xmonad and xmobar are both also MPD front-ends for me, since I import Network.MPD in xmonad.hs and bind some keys to it
11:49:08 <ystael> I can just start at the top of the haskellwiki papers bibliography and read until I run out of time, but I was wondering if there are books out there that systematize it more than that
11:50:02 <dmj`> ystael: there are many functional pearls you might find interesting. The typeclassopedia has many links to academic papers that explain in more detail
11:50:18 <dmj`> http://www.haskell.org/haskellwiki/Typeclassopedia
11:50:38 <Zekka> I was tempted to recommend the typeclassopedia but I thought that assuming typeclasses might make it too Haskell-specific
11:51:01 <Zekka> You can definitely read it as a manual on design patterns, I guess
11:52:26 <ystael> dmj`: Zekka: ok, thanks!
11:57:55 <klrr_> is "asynchronous I/O" analogous to "non-blocking I/O"?
11:58:46 <Fuuzetsu> only if it's web scale
11:59:00 <ystael> relatedly, does anyone know where the bibliography formerly at www.catamorphism.net is now?
11:59:07 <beaky> how do i do recursion with only lambdas
11:59:12 <beaky> is there some trick?
11:59:13 <klrr_> Fuuzetsu: eh?
11:59:19 <Fuuzetsu> It's a joke
11:59:22 <klrr_> okey
11:59:27 <davidthomas> I think all asynchronous IO is non-blocking, but not vice-versa
11:59:31 <bennofs> Could the haskell RTS theoretically be re-written in rust?
11:59:35 <Fuuzetsu> beaky: you can't without naming them
11:59:43 <klrr_> davidthomas: okey, so non-blocking is something else?
11:59:58 <Fuuzetsu> you could make ‘fix’ and work with that
12:00:10 <beaky> Fuuzetsu: what about the y combinator
12:00:13 <davidthomas> strictly, non-blocking just means "I am not synchronously *waiting* on a particular IO event"
12:00:16 <Fuuzetsu> that's fix
12:00:20 <beaky> oh ^^
12:00:28 <beaky> btw why is it called y
12:00:58 <davidthomas> (I think)
12:01:26 <klrr_> okey
12:01:30 <davidthomas> But something like "read from these file handles in non-blocking mode"
12:01:32 <davidthomas> is non-blocking
12:01:39 <davidthomas> because it returns right away
12:01:41 <pyon> Is there any way to say "export everything but this one definition"?
12:01:54 <dmj`> anyone have success using sandboxes between different vms (osx and ubuntu) via vagrant?
12:02:11 <davidthomas> but you can also have things that are genuinely asynchronous - that is, data appears in a buffer with no thought to where your program state is
12:02:36 <davidthomas> eg memory mapped device, zero copy apis, &c
12:03:06 <davidthomas> including some AIO facilities provided by the OS
12:03:26 <byorgey> pyon: sadly no
12:05:20 <Kron> how would you add two pairs together?
12:05:34 <Kron> (a,b) (c,d) --> (a + c, b + d)
12:05:50 <kuribas> \(a, b) (c, d) -> (a+c, c+d)
12:05:53 <conal> Kron: see the NumInstances package
12:06:04 <Kron> is there a simple lens for this?
12:06:07 <Kron> I assume there is
12:06:14 <jle`> (a,b) <> (c,d) = (a <> b, c <> d), i believe
12:06:31 <jle`> also there might be a biapplicative somewhere
12:06:33 <conal> Kron: with NumInstances, (a,b) + (c,d) --> (a+c,b+d)
12:06:43 <Kron> hmmm
12:06:46 <Kron> ok
12:06:59 <Kron> is there a haskell standard naming scheme for the reverse of a function?
12:07:05 <Kron> offset versus deoffset? unoffset?
12:07:07 <Kron> reverseoffset?
12:07:26 <jle`> there is a biapplicative
12:07:28 <fizruk> inverse?
12:07:47 <dmj`> Kron: can you give an example
12:08:07 <Kron> offset (x, y) = (x + 5, y + 5)
12:08:13 <Kron> deoffset (x,y) = (x - 5, y - 5)
12:08:14 <Kron> basically
12:08:20 <jle`> (+) <<$>> (a,b) <<*>> (c,d)
12:08:22 <jle`> should do what you want
12:08:28 <jle`> > (+) <<$>> (a,b) <<*>> (c,d)
12:08:29 <lambdabot>  Not in scope: `<<$>>'Not in scope: `<<*>>'
12:09:34 <fizruk> Kron: how about offsetBy n (x, y) = (x + n, y + n) and then offset 5 or offset (-5) ?
12:09:44 <fizruk> s/offset/offsetBy/
12:10:47 <Kron> what if the n is a pair?
12:10:54 <Kron> that's basically what i'm dealing with
12:11:00 <Kron> offsetting one pair by another, and reversing
12:11:37 <jowens> i'm trying to xor two ByteStrings together
12:11:40 <dmj`> @typ <**>
12:11:41 <lambdabot> parse error on input `<**>'
12:11:58 <jowens> I'm using Data.ByteString.Char8 (import Data.ByteString.Char8 as B8)
12:12:05 <jle`> bipure (+) (+) <<*>> (1,2) <<*>> (6,5)
12:12:09 <jowens> i'm trying to decipher the error code
12:12:14 <jowens> xor a b = B8.pack (B8.zipWith Data.Bits.xor a b)
12:12:17 <fizruk> what does a pair represent? perhaps data declarations with necessary Num instances would suit better your case?
12:12:20 <jowens> No instance for (Data.Bits.Bits Char)
12:12:20 <jowens>       arising from a use of `Data.Bits.xor'
12:12:23 <jowens> help?
12:12:55 <conal> jowens: what type do you want for your xor?
12:12:55 <fizruk> Kron: e.g. data Offset = Offset { offsetX :: Int, offsetY :: Int }
12:13:02 <jowens> ByteString
12:13:09 <jle`> biliftA2 (+) (+) (1,2) (3,4)
12:13:09 <jowens> hence the B8.pack
12:13:12 <conal> jowens: the full type
12:13:13 <geekosaur> you can't xor them directly like that with "Char8", use the regular interface
12:13:20 <jowens> xor :: ByteString -> ByteString -> ByteString
12:13:23 <bennofs> jowens: maybe don't import Data.ByteString.Char8, but instead Data.ByteString
12:13:24 <conal> jowens: ah.
12:13:30 <conal> good.
12:13:36 <geekosaur> (which gives you Word8 instead of Char, which should have a Bits instance)
12:13:45 <geekosaur> note that they are the same internally, just different interfaces
12:13:52 <conal> jowens: did you specify that type in your code?
12:13:56 <jowens> yes i did
12:13:59 <jowens> conal: yes i did
12:14:26 <fizruk> Kron: data Pos = Pos { posX :: Int, posY :: Int}
12:14:28 <jowens> bennofs: actually that works! (or at least it doesn't error when compiling)
12:14:34 <conal> jowens: okay. i guess there's an Bits instance kicking in.
12:14:44 <fizruk> Kron: and then (.+) :: Pos -> Offset -> Pos
12:14:52 <fizruk> Kron: or something like that
12:14:55 <conal> jowens: do you know which instance you're going for?
12:15:10 <jowens> conal: the Data.Bits (xor) instance   (is that what you're asking)
12:15:31 <conal> jowens: that's a class, i think, rather than an instance.
12:15:35 <jowens> can i get a little guidance on when I want to use Data.ByteString.Char8 vs. Data.ByteString?
12:15:38 <conal> jowens: also: hi!
12:15:50 <jowens> conal: :)
12:16:05 <bennofs> jowens: basically, never use Data.ByteString.Char8
12:16:18 <geekosaur> Char8 lets you pretend that the ByteString is made of Haskell Char-s (it's a very broken pretense and will likely bite you at some point)
12:16:26 <Fuuzetsu> except when working with Char8 ;)
12:16:41 <bennofs> Fuuzetsu: never work with Char8 :p
12:16:44 <jowens> ok. how do y'all feel about Data.ByteString.{Base64,Base16}?
12:17:22 <Fuuzetsu> bennofs: well, what do you suggest if we're reading some bytes and we happen to know they are characters?
12:17:34 <jle`> Text
12:17:35 <jowens> I had been using Data.ByteString.Char8 to convert String->ByteString
12:17:39 <jowens> with pack
12:18:07 <kuribas> What's a GHC extension which isn't much known, but everyone should know?
12:18:13 <bennofs> jowens: but String's Char represent unicode code points. ByteString will just truncate charcaters outside of Word8 (0 <= x < 256) range
12:18:30 <jmcarthur> i often find Data.ByteString.Char8 convenient when working with ascii protocols (as opposed to text intended for humans)
12:18:31 <bennofs> jowens: (if you use B8.pack)
12:18:33 <jowens> the Data.ByteString pack instead wants [GHC.Word.Word8]
12:18:35 <conal> jowens: given your type, consuming and producing bytestrings, it looks fishy to have a result pack and no argument unpacks
12:19:11 <jowens> conal: I am having trouble parsing the second part of that sentence
12:19:22 <Javran> @pl map return
12:19:22 <lambdabot> map return
12:19:39 <jowens> my use case is inputting strings, converting to ByteStrings, doing all my work in ByteStrings, and then eventually maybe outputting strings again
12:20:22 <Javran> @hoogle (Monad m, Functor f) => f a -> f m a
12:20:23 <lambdabot> Control.Applicative.Backwards Backwards :: f a -> Backwards f a
12:20:23 <lambdabot> Control.Applicative.Lift Other :: (f a) -> Lift f a
12:20:23 <lambdabot> Data.Functor.Reverse Reverse :: f a -> Reverse f a
12:20:32 <conal> jowens: i don't use bytestring, but i'd expect something like "xor a b = B8.pack (B8.zipWith Data.Bits.xor (B8.unpack a) (B8.unpack b))"
12:21:01 <conal> jowens: ie unpack the args, apply the operation, repack the result.
12:21:21 <jowens> ok. now i gotta figure out how to do that without B8 :)
12:21:21 <jmcarthur> conal: it could be that  B8.zipWith :: (Char8 -> Char8 -> a) -> ByteString -> ByteString -> [a]
12:21:28 <jowens> jmcarthur is correct
12:22:04 <conal> oh, wow.
12:22:21 <conal> oh, because bytestring is monomorphic
12:22:37 <jowens> the proximate question is "how do i go from String to ByteString?". Data.ByteString goes [GHC.Word.Word8] -> ByteString
12:25:57 <jowens> Data.ByteString zipWith is zipWith :: (Word8 -> Word8 -> a) -> ByteString -> ByteString -> [a]
12:28:13 <beaky> apart from the y combinator, how many combinators are there
12:28:18 <beaky> that are notable
12:28:29 <monochrom> s, k, i, b
12:28:36 <jmcarthur> there are a lot of interesting combinators
12:28:58 <jmcarthur> my favorites are s, k, i, b, c, w, y
12:29:08 <jmcarthur> in no particular order
12:30:00 <beaky> :t \f->(\x->x x)(\y->f(\x->y y x))
12:30:02 <lambdabot>     Occurs check: cannot construct the infinite type:
12:30:02 <lambdabot>       t1 = t1 -> t2 -> t0
12:30:02 <lambdabot>     Expected type: t1 -> t2 -> t0
12:30:12 <beaky> :(
12:30:17 <jle`> haskell can't really handle recursive types
12:30:20 <jle`> you have to wrap it in a data type
12:30:23 <jle`> i think
12:30:25 <jmcarthur> Y is not typable in plain haskell without some newtype
12:30:44 <jle`> *infinite recursive types
12:30:50 <jmcarthur> or you could be sneaky and use recursive let
12:31:01 <jle`> spoiler -- http://rosettacode.org/wiki/Y_combinator#Haskell
12:31:12 <jmcarthur> either way, you're using explicit recursion somewhere, whether at the type definition level or the value level
12:31:34 <beaky> :t \f -> let y = f in f y
12:31:35 <lambdabot>     Occurs check: cannot construct the infinite type: t1 = t1 -> t0
12:31:35 <lambdabot>     In the first argument of `f', namely `y'
12:31:35 <lambdabot>     In the expression: f y
12:31:40 <jmcarthur> @src fix
12:31:40 <lambdabot> fix f = let x = f x in x
12:31:44 <beaky> oh
12:32:34 <beaky> what makes the other combinators, like s and k, so great
12:32:42 <monochrom> using recursive let is not sneaky, it's plain sight. using a recursive type is more sneaky. but the sneakiest yet is using a mutable cell
12:32:43 <jmcarthur> their usefulness and generality
12:33:07 <jmcarthur> s and k alone are turing complete. b, c, k, and w are turing complete.
12:33:37 <jmcarthur> monochrom: recursive let uses mutation under the hood
12:34:10 <jmcarthur> except for some special cases
12:36:29 <beaky> http://en.wikipedia.org/wiki/SKI_combinator_calculus wow now i understand why haskellers are so fond of skiing
12:36:52 * hackagebot data-treify 0.3.4 - Reify a recursive data structure into an explicit graph.  http://hackage.haskell.org/package/data-treify-0.3.4 (ConalElliott)
12:37:01 <beaky> so with s and k, i can define the universe
12:37:43 <jmcarthur> beaky: another interesting fact... the ((->) a) instances of Functor, Applicative, and Monad are like this:   fmap = b; pure = return = k; (<*>) = s; join = w
12:38:12 <Malak> hai everyone
12:38:14 <beaky> wow
12:38:18 <beaky> hello Malak
12:38:22 <Malak> i need help
12:38:35 <beaky> so b is just function application?
12:38:42 <jmcarthur> beaky: b is function composition
12:39:04 <Malak> i have few doubts regarding eclipsefp for haskell
12:39:10 <osa1> oh wow... I'm trying to generate some C code but this module http://hackage.haskell.org/package/language-c-0.4.2/docs/Language-C-Syntax-AST.html is so complex I can't even generate "int f(int a) { return a; }" in 30 minutes.
12:39:21 <jmcarthur> :t fmap `asTypeOf` (.)  -- beaky
12:39:22 <lambdabot> (a -> b) -> (a1 -> a) -> a1 -> b
12:39:43 <Malak> i have installed eclipse fp but i am unable to see enything in hoogle
12:39:50 <Malak> i cant search anything in hoogle
12:39:54 <Malak> any help?
12:39:55 <jmcarthur> osa1: C is a very complicated language for such a simple language
12:40:15 <jmcarthur> Malak: i bet not many people use it
12:40:26 <osa1> jmcarthur: yeah and I only need very small subset of it. do we have any simplified syntax definition with pretty printer?
12:40:35 <jmcarthur> no idea
12:40:39 <Hodapp> jmcarthur: but it's a very effective language when your main aim is to insult the programmer when something goes wrong
12:41:22 <Hodapp> osa1: why do you require a formal syntax definition just for *generating* it?
12:41:33 <Malak> any one has idea on eclipsefp for haskell
12:41:49 <osa1> Hodapp: I don't need formal syntax definition. I just need a working pretty-printer because I'll need to debug generated code by reading it.
12:41:56 <Hodapp> ohhh...
12:42:24 <jmcarthur> osa1: i think it doesn't seem totally crazy to just write your own generator and use some command line tool to pretty print the results
12:42:26 <Hodapp> mleh, why not just indent well and use an editor that can pretty-print for you?
12:43:07 <osa1> hmm command line tool part makes sense actually. jmcarthur do you know such a tool?
12:43:12 <osa1> does clang do it?
12:43:15 <jmcarthur> i guess it sucks to not be able to as conveniently use ghci for it
12:43:23 <jmcarthur> maybe. i can't think of anything off the top of my head
12:43:42 <beaky> wow i didnt realize this whole time that <$>, <*>, and id were ski
12:44:00 <osa1> hmm -ast-print might do it
12:44:20 <beaky> maybe monads are w?
12:44:29 <jmcarthur> beaky: join is w
12:44:32 <beaky> oh
12:44:42 <Malak> can anyone tell me how to get hoogle working in eclipsefp?
12:44:45 <Hodapp> osa1: a2ps, Pygments
12:45:10 <Hodapp> I'm sure Emacs will gladly do it too
12:46:46 <Malak> jmcarthur: r u still there?
12:55:01 <ZettaBlade> Haven't used eclipsefp in a long time. I us fpcomplete.com for my haskell adventures
12:58:10 <greg`> in parsec how do i define a Double Parser?
12:58:55 <Lethalman> greg`, Parser Parser
12:58:57 * Lethalman :O
13:00:33 <posco> when I write, data List a = Nil | Cons a, there is no way to write a function that returns Cons, right? for instance: cons x l = x : l, we could say that cons :: a -> List a -> Cons a, but Cons is not a type.
13:01:26 <posco> err, data List a = Nil | Cons a (List a)
13:01:34 <geekosaur> posco: correct, Cons is not a type
13:01:53 <geekosaur> there are ways to build something that can do that, but think about why you want it
13:02:13 <posco> In this case, it is for a non-empty list.
13:02:24 <posco> head :: Cons a -> a
13:02:30 <posco> not, head:: List a -> a
13:03:21 <ChongLi> hi
13:03:23 <theguruofreason> hi
13:03:24 <geekosaur> there's already 3 such libraries on hackage :)
13:04:19 <posco> so, I write more in scala, and the analog in scala does keep all the constructors as types as well.
13:05:25 <posco> It can help constrain in some cases (and that was useful for a design I was making recently, but did not know how to describe the types without making a bunch of extra newtype/types).
13:06:10 <geekosaur> for nonempty lists it generally makes more sense to have a type witness for non-empty-ness rather than separate types for empty and non-empty components, I think.
13:06:33 <posco> ok. I'll checkout that approach.
13:06:58 <geekosaur> Java/Scala types work differently from Haskell types, you can't do the Scala thing directly in Haskell
13:08:51 <studmuf> [x ++ " " ++ y | x <- ["A".."C"], y <- ["D".."F"]]
13:09:59 <beaky> i wish i knew how to define recusion with only lambdas
13:10:09 <Iceland_jack> > [ [x,' ',y] | x <- ['A'..'C'], y <- ['D'..'F']] -- studmuf
13:10:10 <lambdabot>  ["A D","A E","A F","B D","B E","B F","C D","C E","C F"]
13:10:19 <studmuf> Iceland_jack: thanks
13:11:06 <studmuf> Iceland_jack: how would I only return the first and last element that shows up in the result?
13:11:26 <studmuf> I tried a combination of fst and last with no luck
13:11:35 <Iceland_jack> studmuf: Are you asking how to get the first and last element of a list?
13:11:45 <studmuf> of the resulting list
13:11:54 <Iceland_jack> > let list = [1..10] in [head list, last list]
13:11:55 <lambdabot>  [1,10]
13:12:18 <Iceland_jack> > let list = [ [x,' ',y] | x <- ['A'..'C'], y <- ['D'..'F']] in [head list, last list]
13:12:19 <lambdabot>  ["A D","C F"]
13:12:20 <geekosaur> haskell is not python, lists and tupes are completely different things
13:12:26 <geekosaur> fst won't work on a list
13:12:39 <studmuf> oh gottcha
13:12:48 <Iceland_jack> studmuf: Lists must have values of the same type (they're homogeneous)
13:12:56 <geekosaur> *tuples
13:13:12 <Iceland_jack> geekosaur: (I thought you were correctin me) :)
13:13:21 <geekosaur> heh
13:13:26 <Iceland_jack> studmuf: Tuples may have values of different types (heterogeneous)
13:13:31 <Iceland_jack> @ty fst
13:13:33 <lambdabot> (a, b) -> a
13:13:41 <geekosaur> note also that fst only works on 2-tuples
13:13:43 <Iceland_jack> studmuf: Does that type signature make sense?
13:13:50 <geekosaur> > fst (1,2,3)
13:13:51 <lambdabot>  Couldn't match expected type `(a0, b0)'
13:13:51 <lambdabot>              with actual type `(t0, t1, t2)'
13:14:31 <JoaoPortela> > ['A' .. 'C']
13:14:32 <lambdabot>  "ABC"
13:16:25 <JoaoPortela> >a where (a,_,_) = (1,2,3)
13:16:46 <Iceland_jack> > let (a_, _, _) = (1, 2, 3) in a
13:16:47 <lambdabot>  a
13:17:08 <Iceland_jack> oops
13:17:10 <Iceland_jack> > let (a, _, _) = (1, 2, 3) in a
13:17:11 <JoaoPortela> > let (a, _, _) = (1, 2, 3) in a
13:17:12 <lambdabot>  1
13:17:12 <lambdabot>  can't find file: L.hs
13:17:15 <JoaoPortela> :p
13:17:25 <Iceland_jack> Underscores
13:17:31 <JoaoPortela> thx
13:20:35 <studmuf> Iceland_jack: yes that type signature makes sense
13:20:39 <studmuf> thanks
13:20:56 <Iceland_jack> the ‘a’ and ‘b’ indicate that the tuple can contain two different types
13:21:04 <Iceland_jack> > (True, 'a') :: (Bool, Char)
13:21:06 <lambdabot>  (True,'a')
13:21:11 <Iceland_jack> > snd (True, 'a')
13:21:12 <lambdabot>  'a'
13:21:17 <Iceland_jack> :t fst
13:21:18 <lambdabot> (a, b) -> a
13:21:18 <Iceland_jack> :t snd
13:21:19 <lambdabot> (a, b) -> b
13:21:55 <gwz> hey, if I have two lists, [0,1] and [2,3], how would I append them together to get, [[0,1,],[2,3]]
13:22:25 <Iceland_jack> gwz: You can simply do
13:22:25 <Iceland_jack>     [xs, yy]
13:22:42 <Iceland_jack> *ys
13:22:43 <Iceland_jack> > let (xs, ys) = ([0,1], [2,3]) in [xs, ys]
13:22:45 <lambdabot>  [[0,1],[2,3]]
13:23:37 <mm_freak_> is there a package for semirings that is somewhat maintained?
13:23:44 <dmj`> I have a sandbox in OSX and a VM that's sharing the same folder running ubuntu. Is it possible to share a sandbox across OS's like this?
13:23:55 <dmj`> a cabal sandbox
13:24:56 <dmj`> so that when I rebuild it doesn't have to start from scratch
13:26:49 <dmj`> nevermind it seems to be working w/o rebuilding
13:27:05 <dmj`> rebuilding from scratch that is
13:27:55 <beaky> apart from the skibcwy combinators, what else should i learn about finctuonal programming
13:27:58 <beaky> functional*
13:28:08 <dmj`> beaky: what interests you
13:34:27 <vozz> How good are the various Haskell GUI libraries? Any favourites?
13:35:27 <awestroke> vozz: they're all bindings to existing toolkits afaik
13:35:48 <awestroke> vozz: the main ones being gtk+ and Qt I guess
13:36:00 <jeltsch> vozz: Gtk2Hs is quite good.
13:37:46 <vozz> If I was setting out to build GUI for a C application/library, would using Haskell be unwise?
13:38:19 <vozz> My other choice is Racket and I think that might be a whole lot easier.
13:38:28 <mm_freak> vozz: depends
13:38:44 <vozz> on?
13:39:05 <mm_freak> vozz: the bindings are pretty low level in haskell…  you create widgets and/or load GUIs (e.g. glade), then register your event handlers, etc.
13:39:14 <mm_freak> vozz: this is ugly and probably not much better than in C
13:39:30 <mm_freak> however, haskell gives you the opportunity to put a layer of abstraction over that, for example FRP
13:39:47 <mm_freak> reactive-banana makes this quite easy, and there is a ready-made such layer for wx
13:40:17 <mm_freak> so if you don't mind the learning curve, i would definitely go with haskell and FRP
13:40:40 <ChongLi> mm_freak: I thought you were a netwire guy? :)
13:40:57 <mm_freak> ChongLi: i am /the/ netwire guy, but reactive-banana solves this a lot better
13:41:06 <JoaoPortela> mm_freak: I'm also a bit curious about FRP and haskell GUI, which projects can I look at that use it?
13:41:23 <ChongLi> mm_freak: I'm still confused about FRP
13:41:35 <vozz> Yeah, that's what I was thinking. Nearly all of the toolkits are OOP and the Haskell bindings are just wrappers around them. Something FRP would be cool, but it feels like there's nothing very mature out there. I'll give reactive banana a look
13:41:39 <ChongLi> why not just shove all your events into a queue and then pull from that?
13:42:28 <vozz> It just feels like as much as I like Haskell, if I'm using one of these toolkits I'm effectively going to be writing OOP code in Haskell which can't be much fun
13:42:35 <mm_freak> we have mature FRP frameworks, but we don't have mature GUI frameworks
13:42:46 <mm_freak> in other words we have gtk2hs (mature) and we have reactive-banana (mature)
13:42:53 <mm_freak> but we don't have reactive-banana-gtk2hs
13:43:19 <ChongLi> but is gtk2 even what we want?
13:43:21 <vozz> I'm looking at the R-B site and it says it can be hooked up to Gtk2Hs?
13:43:28 <mm_freak> ChongLi: just an example
13:43:37 <ChongLi> why not a new, purely haskell GUI framework built on top of opengl?
13:43:42 <vozz> ChongLi: It's gtk3 afaiak, the 2 is like "to"
13:43:53 <mm_freak> ChongLi: and no, an event queue is not much different from event handlers, except that now you do the dispatching yourself
13:43:59 <vozz> ChongLi: That's a whole loooad of work, GUI toolkits are huuge things
13:44:29 <mm_freak> ChongLi: the benefit of FRP is that everything becomes declarative and events and time-varying values (like the current contents of an input field) become first class values
13:44:32 <vozz> Does reactive banana not work with gtk2hs?
13:44:40 <mm_freak> vozz: it does very well actually
13:45:12 <mm_freak> reactive-banana is an FRP framework specifically developed for event-handler-based GUI toolkits
13:45:32 <ChongLi> vozz: there's got to be some better way to do it, anyway
13:45:35 <vozz> I thought you said we don't have reactive-banana-gtk2hs
13:45:47 <mm_freak> you teach it how to register events in gtk2hs (a single LOC) and reactive-banana gives you first class FRP events
13:46:39 <vozz> So if I use it, I'll effectively be writing the "bindings" to Gtk2Hs as I go?
13:46:43 <ChongLi> mm_freak: when I looked at some netwire examples it seemed like ocharles was just using it as a queue anyway
13:46:48 <mm_freak> vozz: pretty much
13:46:58 * hackagebot yesod-bin 1.2.7.2 - The yesod helper executable.  http://hackage.haskell.org/package/yesod-bin-1.2.7.2 (MichaelSnoyman)
13:46:58 <vozz> Okay
13:47:00 * hackagebot yesod-platform 1.2.8 - Meta package for Yesod  http://hackage.haskell.org/package/yesod-platform-1.2.8 (MichaelSnoyman)
13:47:00 <guymann> h
13:47:39 <vozz> That seems pretty awesome, I'm not sure I'll end up using it on this next project but I'll have a play with it
13:48:23 <mm_freak> ChongLi: not quite a queue…  SDL events become inputs to the reactive system…  however, the reactive system itself is entirely declarative and does not understand this discreteness
13:48:30 <vozz> The whole racket -> gtk on linux, cocoa on mac, winapi on windows thing seems really appealing
13:49:24 <mm_freak> netwire is a good choice when your application runs in discrete time-steps and can be divided into frames
13:49:29 <mm_freak> like games and simulations
13:49:36 <mm_freak> or perhaps a highly animated OpenGL GUI
13:49:48 <ChongLi> I'm still a little confused
13:49:52 <mm_freak> for callback-based GUI toolkits reactive-banana is a better choice
13:51:25 <hseg> Hi. I'm trying to derive a function I have from fusion laws. However, I hear that "f . foldl g a" cannot be fused? Or at least cannot be elegantly fused?
13:51:42 <c_wraith> hseg: foldr/build fusion can't fuse foldl
13:52:03 <c_wraith> hseg: stream fusion can handle foldl just fine, but it's not so great at concatMap
13:52:27 <Benzi-Junior> can a package have more than one entry in ghc-pkg?
13:52:38 <c_wraith> hseg: recent work has shown how to do concatMap with stream fusion, but it requires a more complex system than GHC's rewrite rules to manage it.
13:53:22 <c_wraith> hseg: It's probable that in a few years, GHC will have adopted some way to get stream fusion that handles concatMap into the standard library.
13:54:41 <hseg> I don't know of foldr/build fusion. All I know is that f (foldr g a) can be fused into foldr h (f a), provided f (g x (foldr g a xs)) = h x (f (foldr g a xs)).
13:56:06 <mm_freak> edwardk: you certainly have semirings defined somewhere, don't you?
13:56:50 <edwardk> mm_freak: yes. though i confess i tend to just use Num, (-) be damned, in practice. =P
13:57:20 <edwardk> mm_freak: algebra has that and a bunch more. just too much more for me to enjoy working with it
13:58:11 <mm_freak> edwardk: Num does not work here…  it's far from numbers
13:58:17 <mm_freak> it's sets
13:58:30 <mm_freak> well, it does work, but i'd like to have a class with cleanly stated laws
13:59:03 <mm_freak> edwardk: to be precise it's these two:  http://lpaste.net/101411
13:59:45 <hseg> c_wraith: What I'm trying to prove here is http://lpaste.net/101412
14:00:04 <gamegoblin> Any idea on a speed different between "w == x || w == y || w == z" and "w `elem` [x,y,z]"
14:00:39 <mm_freak> gamegoblin: 'elem' does a list traversal, so it's slightly slower, but it may be optimized away
14:00:46 <edwardk> mm_freak: http://hackage.haskell.org/package/algebra-3.1/docs/Numeric-Algebra-Class.html#t:Semiring
14:01:57 <edwardk> gamegoblin: the former may be a tiny bit faster if it can't inline the elem or if optimization is off
14:02:06 <hseg> Given the foldl-like nature of my go function, it seems I should use foldl fusion.
14:05:09 <mm_freak> edwardk: am i right in assuming that you're not going to maintain that library much longer?
14:07:33 <Fuuzetsu> isn't there someone interested in doing stuff related to it for GSOC?
14:08:28 <hseg> Anyway, I'm not interested in the automatic fusion GHC does on my code. I'm asking regarding the laws allowing me to fuse stuff manually when doing equational reasoning. e.g. map f . map g = map (f . g)
14:13:56 <bennofs> When compiling code where perfomance matters, do I also need to compile all libraries with -O2?
14:14:13 <bennofs> s/perfomance/performance
14:15:39 <h_noob> what's wrong with this expression?
14:15:40 <h_noob> 14::CUChar .&. 57::CUChar
14:15:51 <h_noob> 14::CUChar is ok by itself
14:16:03 <h_noob> makeing two vars in ghci with let is ok
14:16:05 <bennofs> h_noob: you need parentheses, like (14::CUChar) .&. (57::CUChar)
14:16:11 <geekosaur> :: extends to the left as far as it can
14:16:43 <h_noob> ok cool, thx
14:22:52 <edwardk> mm_freak: i'll be maintaining algebra for a long time, though the API may radically shift and improve after rounded comes out
14:24:03 <mm_freak> hmm, ok
14:24:23 * hpc imagines edwardk literally maintaining algebra
14:24:27 <hpc> bug: 2+2=5
14:24:32 <hpc> status: WONTFIX
14:24:41 <davidfetter_disq> heh
14:24:51 <mm_freak> a dedicated semiring library would probably work better in my case
14:24:51 <hpc> reason: (+) is obsolete, use OneSemiGroup.append
14:24:52 <Heffalump> statusfailed: INVALID surely
14:24:55 <c_wraith> > let 2 + 2 = 5 in 2 + 2
14:24:57 <lambdabot>  5
14:24:58 <Heffalump> 2+2 = 4 is won't fix
14:25:01 <c_wraith> works for me
14:25:17 <aspidites>  /quit
14:26:31 <Cale> Feature request: Isomorphic groups should be equal
14:26:48 <hseg> So does there exist a foldl fusion law or not? Otherwise, I don't know how to show the equivalence of these two expressions: http://lpaste.net/101412
14:27:03 <Cale> @free foldl
14:27:04 <lambdabot> (forall x. f . h x = k (f x) . g) => f . foldl h y = foldl k (f y) . $map g
14:27:30 <Cale> @free foldr
14:27:30 <lambdabot> (forall x. g . h x = k (f x) . g) => g . foldr h y = foldr k (g y) . $map f
14:27:54 <beaky> why do we need the y combinator if fold can do the same thing
14:28:04 <hseg> Cale: I don't understand the output
14:28:30 <Cale> hseg: $map here is just map
14:29:02 <hseg> OK. But why is it there? At least the foldr law doesn't require it.
14:29:21 <Cale> Well, these laws are automatically generated from the type of the function
14:29:31 <Cale> So, they might be a little more general than you need
14:29:34 <hseg> Cale: Free theorems?
14:29:36 <Cale> You could always replace g with id
14:29:38 <Cale> yeah
14:29:59 <mm_freak> @free id
14:29:59 <lambdabot> f . id = id . f
14:30:07 <Cale> @free map
14:30:08 <lambdabot> g . h = k . f => $map g . map h = map k . $map f
14:30:39 <hseg> I suppose $map is a special map?
14:30:45 <hseg> Possibly fmap?
14:30:54 <mm_freak> hseg: it's probably just 'map' with the name changed
14:31:03 <Cale> If you set k = id there, then it simplifies to  g . h = f => map g . map h = map f
14:31:10 <mm_freak> so that you can formulate laws for map and tell the two apart
14:31:20 <mm_freak> @free const
14:31:20 <lambdabot> f . const x = const (f x) . g
14:31:22 <hpc> hseg: it gets a "$" to avoid it getting confused for a variable name
14:31:29 <Cale> yeah, $map is "let's pretend this thing is a functor, and here's its fmap"
14:31:41 <hpc> (by variable, bound variable, not free)
14:33:04 <hseg> Wait. A) Why is one map avoiding name-capture and the other not and B) Why does that g appear in the free theorem for const?
14:33:36 <monochrom> when you enter "@free map", you expect a law for "map", no?
14:33:43 <hpc> @free fmap
14:33:43 <lambdabot> Extra stuff at end of line in retrieved type "Functor f => (a -> b) -> f a -> f b"
14:34:02 <Cale> hseg: I asked for the free theorem for map, and as part of constructing that free theorem, it needed to assume that the list type constructor was a functor, and needed a name for its fmap, which it rendered as $map
14:35:06 <hseg> OK. And I assume that in the free theorems for fold(l/r) the forall x. is a quantifier quantifying the x only?
14:35:07 <Cale> So, we know that map = $map, but it doesn't assume this
14:35:08 <pjdelport> Does anyone here know offhand where Yi's core editor operations are defined? (That is, "move left", "delete word", and so on.)
14:35:20 <Cale> yeah
14:36:09 <hpc> pjdelport: a good follow-up question is to ask where it is ;)
14:36:43 <hseg> So $map is a function that is assumed to exist for the purposes of the theorem? i.e. List is assumed to be functorial for the purposes of the theorem?
14:36:48 <Cale> @free const
14:36:49 <lambdabot> f . const x = const (f x) . g
14:36:53 <Cale> hseg: yeah
14:37:30 <Cale> That g is helping express the idea that const ignores its second argument
14:38:00 <hseg> One odd thing regarding the free theorems for the folds. f and g are interchanged for no apparent reason.
14:38:19 <hseg> i.e. I'd expect the same names in the same places.
14:38:22 <monochrom> is "@free fff :: (a,b) -> a" a valid query?
14:38:26 <pjdelport> Context: I've been playing around with implementing a minimal text editor, just for self-instruction, and I'm taking the approach of defining a small editor state, and then defining everything else as actions on it, building up a small combinator library.
14:38:40 <Cale> Yeah, that's likely that it chooses variable names from a sequence, and ended up choosing the corresponding names in the opposite order
14:38:40 <Apocalisp> Can I make a data structure (C a b) that consists of alternating elements of types a and b?
14:38:53 <Cale> (i.e. it's just a coincidence of the algorithm used to generate the theorem)
14:39:01 <hpc> data C a b = Nil | C a b (C a b)
14:39:11 <Cale> @free fff :: (a,b) -> a
14:39:12 <lambdabot> f . fff = fff . $map_Pair f g
14:39:31 <hpc> (also, [(a, b)])
14:39:33 <Apocalisp> hpc: Might contain an odd number of as and even number of bs, or vice versa.
14:39:35 <monochrom> nice, thanks
14:39:52 <hpc> ah, for that we go to GADTs
14:40:44 <hpc> data C where Nil :: C a b; C :: a -> C b a -> C a b
14:41:11 <hpc> actually, do we even need GADTs for that?
14:41:15 <Cale> hseg: So, we can simplify the free theorems for foldl and foldr by choosing f = g = id
14:41:39 <hpc> Apocalisp: data C a b = Nil | C a (C b a) -- try that
14:41:39 <Cale> (forall x. h x = k (f x)) => foldl h y = foldl k (f y)
14:41:45 <jmcarthur> data C a b = Nil | C a (C b a)
14:41:51 <jmcarthur> i am beaten
14:41:58 <Cale> (h = k . f) => foldl h y = foldl k (f y)
14:42:14 <hpc> jmcarthur: they don't call me the head programming czar for nothing!
14:42:16 <Cale> foldl (k . f) y = foldl k (f y)
14:42:16 <hpc> (actually they do)
14:42:38 <monochrom> that's an interesting identity
14:42:50 <Cale> oh, oops
14:42:51 <Cale> hah
14:42:58 <Cale> yeah
14:43:13 <Cale> picking f = id trivialises it too much
14:43:29 <beaky> can lambdas be used to implement maps?
14:43:29 <hseg> Cale: you mean (forall x. f . h x = k . f x) =>  f . foldl h y = foldl k (f y)
14:43:31 <henk> haasn: I’ll take a look, thanks
14:43:40 <Cale> (forall x. f . h x = k (f x)) => f . foldl h y = foldl k (f y) -- let's just go with g = id
14:43:54 <hseg> beaky: In what sense?
14:43:55 <jmcarthur> beaky: that's kind of a vague question
14:44:09 <monochrom> ok, that is less magical :)
14:44:50 <hseg> beaky: Church proved that if you're masochistic/crazy enough to encode everything as functions, that you can express everything as lambdas.
14:44:55 <hpc> beaky: assuming lambda calculus, do it the perl way
14:45:04 <hseg> beaky: But that's probably not what you want.
14:45:09 <hpc> make a church-encoded list and make each even-odd pair a key-value pair
14:45:11 <jmcarthur> hseg: i don't even think it's such a masochistic thing to do
14:45:42 <monochrom> no, Turing is the really masochistic one
14:45:48 <jmcarthur> ^_^
14:45:53 <hseg> jmcarthur: *everything* as functions? Including all your data types? And not being allowed types?
14:45:57 <Fuuzetsu> sure is a pain in the ass though
14:46:00 <monochrom> but I guess L-systems trump them both
14:46:08 <hpc> monochrom: nothing compared to babbage
14:46:17 <Apocalisp> hpc, jmcarthur: Thanks! Makes sense
14:46:21 <hpc> he went into it with no formal model!
14:46:22 <monochrom> oh, gears, God, yeah
14:46:28 <jmcarthur> hseg: that's going a bit further. i like being able to define new types, and that's pretty orthogonal. the new types could still be encoded as functions.
14:47:05 <hseg> jmcarthur: I guess. Still, not what I'd like to be doing.
14:47:21 <monochrom> Babbage could totally write his autobiography as "from looming machines to dooming machines"
14:47:53 <jmcarthur> hseg: i'm also not saying i'd *prefer* to be stuck with this style, but there are advantages. you can deeper insights into your data structures. the compiler can sometimes do a lot with it. etc.
14:47:54 <hseg> Isn't SKI a type of L-system? Never got the hang of it.
14:48:14 <hseg> jmcarthur: Right. Plus all the computability proofs.
14:48:26 <jmcarthur> hseg: but church encodings are just folds. they aren't crazy.
14:48:45 <hseg> Come think of it, you're probably right.
14:49:02 <New2Haskell> Hello guys, I wrote a few Haskell functions for a school assignment http://lpaste.net/101415, I was wondering if I could do it cleaner/quicker using library functions
14:49:27 <jmcarthur> hseg: e.g....
14:49:29 <jmcarthur> :t foldr
14:49:30 <lambdabot> (a -> b -> b) -> b -> [a] -> b
14:49:31 <hseg> New2Haskell: count = mconcat . map Sum
14:49:36 <New2Haskell> The function basicly scans 2 strings and only gives the characters that occur in both strings exactly the same time
14:49:36 <hpc> New2Haskell: for starters, the first case of equalCount is redundant
14:49:50 <jmcarthur> newtype List a = List (forall r. (a -> r -> r) -> r -> r)
14:49:59 <Cale> hseg: To illustrate the encoding, consider a type of binary trees like  data Tree a = Tip | Branch a (Tree a) (Tree a). The idea behind Church encoding is to rewrite terms into lambdas which take the constructors as parameters...
14:50:02 <Cale> So  Branch 1 (Branch 2 Tip Tip) (Branch 3 Tip Tip)
14:50:06 <monochrom> the reason I prefer lambda calculus to Turing machine is this. various compositions are fundamental in building algorithms. compositions are easy in lambda calculus, tedious in Turing machine.
14:50:21 <Cale> would become (\tip branch -> branch 1 (branch 2 tip tip) (branch 3 tip tip))
14:50:47 <hseg> New2Haskell: Sorry. Meant mconcat . map Sum . filter . (.(==))
14:50:47 <Zekka> New2Haskell - Do you know about (filter)? I bet you could make count a lot shorter using that
14:51:01 <Zekka> Oh, wait, are you just telling him?
14:51:08 <Zekka> I was going to give hints
14:51:09 <hseg> Zekka: Oops.
14:51:17 <hseg> Zekka: I'm a bad man.
14:51:26 <hseg> Zekka: :)
14:51:30 <Cale> Well, that's a pretty fancy way to write it
14:51:37 <Zekka> What's wrong with count c = length . filter c
14:51:37 <kadoban> hseg: ...isn't that really complicated for little reason?
14:51:38 <Zekka> ?
14:51:44 <New2Haskell> yes I know about filter
14:51:47 <jmcarthur> mconcat . map Sum = sum
14:51:56 <Cale> Zekka: length . filter (== c) surely
14:52:02 <Zekka> Oh, you're right, c's not a predicate
14:52:10 <Zekka> teach me to be inattentive
14:52:21 <hseg> First thing that sprung to mind. As seen by my low quality of code, not quite correct.
14:52:31 <hseg> Even in my fixed form.
14:52:38 <Cale> New2Haskell: It might be more efficient to sort both strings
14:52:44 <Cale> and just check if they're equal
14:52:50 <Cale> errrr
14:52:51 <Zekka> hseg - I think your solution was accurate but I'm not sure, and haven't tested it
14:52:57 <New2Haskell> hmm
14:52:57 <Cale> No, that's not what you're doing here :)
14:53:08 <Zekka> I don't know if I'd ever write it that way, of course
14:53:16 <Cale> ah, you want the elements of one string which have the same number of occurrences in the other
14:53:17 <Cale> ?
14:53:19 <monochrom> what is the specification of equalCount? I'm too lazy to guess from the code
14:53:37 <Zekka> I'm in the same boat as monochrom although my gut is that you could make it much shorter with a fold just looking at the form of it
14:53:38 <kadoban> yeah, equalCount is a bit perplexing
14:53:46 <New2Haskell> Im not sure if it still satisfies the assignment then
14:53:50 <jmcarthur> `yeah, i see that many would be helpers here are still trying to figure out the question :)
14:53:52 <hseg> Zekka: I'm definitely wrong. Sum needs a Num instance in the value it wraps. I should have used map (const (Sum 1)). But that's just length.
14:53:57 <New2Haskell> yes so only one way
14:54:21 * monochrom does not believe in "code can be self-documenting"
14:54:35 <jmcarthur> i believe in it, but don't believe most people can write such code
14:54:48 <hpc> or that most code should be written that way
14:54:50 <Zekka> I think code can be self-documenting, but actually writing self-documenting code is probably more effort than commenting it
14:54:54 <hpc> or that most code even can be written that way
14:55:41 <monochrom> every time you write a loop or recursion, you very likely have to separately write a specification such as an assertion of invariant to explain the purpose
14:56:04 <hpc> either way, it's possible for sufficiently small pieces of code to be faster to comprehend from code than comments
14:56:07 <monochrom> because if not, the reader is basically looking at Rice's theorem
14:56:17 <Zekka> Back to the previous question, what is equalCount trying to do again?
14:56:23 <Walther> Hmm. filter(head/='#') doesn't work, filter(notElem '#') works. Any ideas on how to code golf this ._.
14:56:49 <New2Haskell> alright let me give you an example
14:56:56 <Zekka> Walther - filter ((/='#') . head) ?
14:57:17 <New2Haskell> equalCount programming software is supposed to give oa
14:57:23 <Walther> Zekka: not helpful in code golf, that's longer :/
14:57:54 <New2Haskell> So it only selects the characters that occur at the same frequency in both strings
14:58:09 <monochrom> sorry, what is "oa"?
14:58:17 <New2Haskell> equalCount proogramming software would give a
14:58:20 <New2Haskell> the return value
14:58:35 <New2Haskell> of this http://lpaste.net/101415 function
14:59:01 <New2Haskell> Its the last part of my schoolassignment series
14:59:12 <New2Haskell> Already have the solution but was just wondering if I could do it cleaner/quicker
14:59:17 <monochrom> alright, then it is wise to sort first. then there are more to do, but not too hard after sorting
14:59:23 <jmcarthur> i think some bit of that explanation got truncated or something. i still don't understand what the function is actually supposed to do
14:59:33 <jmcarthur> well, maybe i understand
14:59:48 <Zekka> I'm starting with applying group . sort to each, currently figuring out what comes next
15:00:11 <monochrom> yeah, group.sort definitely
15:00:21 <jmcarthur> New2Haskell: does the function have to return the characters in their original order?
15:00:27 <hseg> jmcarthur: It's to construct the list of all characters occuring an equal amount of times in both lists.
15:00:40 <Zekka> you could probably do it in a hacky way like this (one second, I'll pastebin)
15:00:50 <New2Haskell> no the order of the return value doesnt matter
15:00:59 <kadoban> group sort, filter by == lengths, then take head i guess?
15:01:01 <New2Haskell> aslong as the characters are correct
15:02:08 * hackagebot Grow 1.0 - A declarative make-like interpreter.  http://hackage.haskell.org/package/Grow-1.0 (MarcCoiffier)
15:02:19 <monochrom> in fact, define «info rs = (head rs, length rs)». then «map info . group . sort» gets you really close
15:02:30 <Twey> hpc: There's an easier way to do maps in λ-calculus: as functions.  empty = λ k d. d; insert = λ k v m k' d. equal k k' v (m k' d); delete = λ k m k' d. insert k d m k' d
15:02:39 <Zekka> Would this work? http://lpaste.net/101416
15:02:56 <New2Haskell> ill check it out
15:03:00 <Zekka> One sc, I'll try it
15:03:01 <hpc> Twey: what's the point of doing things in λcalc the easy way? ;)
15:03:08 <Twey> Heh
15:03:44 <Zekka> New2Haskell - For what it's worth, you need Data.List for this
15:03:57 <New2Haskell> yess thx
15:04:25 <New2Haskell> It does the same thing however im not really familair with groupsort
15:04:42 <New2Haskell> How does your function exactly work if you're not bothered to explain
15:04:42 <Zekka> I'm getting some weird results, let me do some testing
15:04:55 <Zekka> Basically, it sorts xs and sorts ys and then groups the
15:04:56 <Zekka> them
15:05:02 <New2Haskell> ok
15:05:03 <kadoban> Zekka: seems like you can do it faster, if not easier. `elem` isn't needed, right? they're in order, so you can step along both lists only once
15:05:12 <monochrom> an example may help
15:05:15 <Zekka> if xs is "test" it becomes "estt" and then ["e", "s", "tt"]
15:05:32 <Zekka> kadoban - You probably could if you wanted to although I'm not sure of a concise way to do it
15:05:33 <monochrom> > group "11110777"
15:05:34 <lambdabot>  ["1111","0","777"]
15:05:51 <monochrom> that's what group does. but I'm using a bad example. a better example is:
15:05:59 <monochrom> > group "00011777"
15:06:00 <lambdabot>  ["000","11","777"]
15:06:13 <New2Haskell> Ah I see
15:06:23 <New2Haskell> so it sticks duplicates together thats why you need the sort first
15:06:24 <monochrom> it is a better example because we are assuming sorted strings
15:06:29 <monochrom> yeah
15:06:55 <monochrom> I think you now see why it gets you really close
15:07:28 <jmcarthur> :t (fmap.fmap.fmap) head (intersectBy ((liftA2.liftA2) (&&) ((==) `on` head) ((==) `on` length)) `on` group . sort)
15:07:29 <lambdabot> Ord a => [a] -> [a] -> [a]
15:07:39 <jmcarthur> self documenting code indeed
15:07:49 <jle`> heh
15:08:00 <Zekka> I've got a shorter one, one second
15:08:05 <jmcarthur> let f = (fmap.fmap.fmap) head (intersectBy ((liftA2.liftA2) (&&) ((==) `on` head) ((==) `on` length)) `on` group . sort) in f "foobar" "boobarz"
15:08:08 <monochrom> I am just a bit worried about the time complexity of intersectBy
15:08:09 <jmcarthur> > let f = (fmap.fmap.fmap) head (intersectBy ((liftA2.liftA2) (&&) ((==) `on` head) ((==) `on` length)) `on` group . sort) in f "foobar" "boobarz"
15:08:10 <lambdabot>  "aor"
15:08:26 <Zekka> http://lpaste.net/101418
15:08:39 <jmcarthur> i was just not concerning myself with golfing or time complexity or anything, but with reusing tons of existing functions
15:08:43 <Zekka> using intersect this way feels a little messy but I can't think of any cases where it wouldn't work
15:09:14 <jmcarthur> oh, and being ridiculously point free, I suppose
15:09:18 <monochrom> you definitely try to make it both pointfreeer and longer :)
15:09:26 <Zekka> Yeah, his is by far the most pointless solution
15:09:27 <kadoban> Zekka: what about Data.List.Utils.merge on both lists, then a simple recursion that drops anything that's not doubled maybe? not as cute though :/
15:09:47 <Twey> New2Haskell: Do you care about the order of the characters in the resulting string?
15:09:53 <New2Haskell> no the order doesnt matter
15:09:57 <jmcarthur> oh, i could make it messier and avoid more duplication
15:09:59 <monochrom> it is hellish to eliminate doubles in a list
15:10:04 <Zekka> kadoban - Could work (not having tried it)
15:10:09 <New2Haskell> doesnt the nub function clear dubs??
15:10:10 <monochrom> or even, eliminate non-doubles
15:10:23 <kadoban> monochrom: it's sorted though, so it's easy isn't it?
15:11:06 <monochrom> let me put it this way. any algorithm that requires "look at two consecutive items in a list" is hellish
15:11:08 <jle`> New2Haskell: what's the problem again?  return only characters in the two strings that are in the same location and the same character?
15:11:23 <jmcarthur> jle`: just same number of occurrences in each list
15:11:28 <kadoban> monochrom: really? hmm...let me see if i can figure out why
15:11:33 <jmcarthur> jle`: position doesn't matter. interpret as multisets
15:11:41 <jle`> characters that are the same count
15:11:42 <Zekka> monochrom -- Can't you just zip a list with the tail of the list?
15:11:45 <jle`> one of each?
15:11:49 <New2Haskell> Compare 2 strings, return the characters that occur in both strings at the same ammount
15:11:49 <monochrom> because there are always several corner cases
15:11:51 <jle`> Zekka: the drop 1
15:12:12 <Zekka> jle1` - Well, yes, I'm assuming you can't meaningfully look at the item after the last item in the list
15:12:15 <kadoban> monochrom: ah, i see. yeah, that's true
15:12:24 <jle`> Zekka: just for totality :)
15:12:30 <Zekka> but you're right that a lot of algorithms that try to do this create corner cases
15:12:42 <jle`> replacing tail for drop 1 gives you totality and sacrifices little
15:12:43 <jmcarthur> fine, i got rid of some of my stupidity
15:12:44 <jmcarthur> :t (fmap.fmap.fmap) head (intersect `on` group . sort)
15:12:45 <lambdabot> Ord a => [a] -> [a] -> [a]
15:12:58 <Zekka> Is tail not defined as drop 1?
15:12:59 <jmcarthur> now it's just the pointless version of Zekka's
15:13:05 <jle`> @src tail
15:13:05 <lambdabot> tail (_:xs) = xs
15:13:05 <lambdabot> tail []     = undefined
15:13:09 <kadoban> Zekka: nope. tail is partial :/
15:13:11 <Zekka> Well, to be fair, it's also shorter
15:13:13 <hpc> @src drop
15:13:13 <lambdabot> drop n xs     | n <= 0 =  xs
15:13:13 <lambdabot> drop _ []              =  []
15:13:13 <lambdabot> drop n (_:xs)          =  drop (n-1) xs
15:13:21 <jle`> Zekka: tail is defined such that head xs : tail xs == xs, for nonempty xs
15:13:25 <jle`> head and tail predate haskell
15:13:47 <jmcarthur> :t (fmap head . intersect `on` group . sort)
15:13:47 <jle`> also it's defined to have no result on an empty list
15:13:48 <monochrom> I basically measure difficulty by "how many ways can you introduce a bug". I'm a correctness fiend. :)
15:13:48 <lambdabot> Ord a => [a] -> [a] -> [a]
15:14:35 <Zekka> By the way, is it a bad thing that I have difficulty reading pointless code like jmcarthur's solutions?
15:14:41 <jmcarthur> no
15:15:02 <monochrom> on the up side, mine is equivalent to what Hoare says about "so simple it obviously has no error, vs so complicated it has no obvious error" :)
15:15:34 <jmcarthur> why do i have duplicates? is that intersect's doing?
15:15:57 <monochrom> I think it's pointless's doing :)
15:18:01 <kadoban> Zekka: yeah, i can't find a way to make my solution very short or clean...doesn't help that Data.List.Utils apparently isn't in the platform
15:18:08 <monochrom> tail is intended to pair up with head as in "data List a = Nil | Cons { head::a, tail::List a }" i.e., as a field of the cons case just like head it
15:18:38 <jle`> monochrom: that's a much better answer than mine v.v
15:18:43 <monochrom> but of course you can protest against that. I am agnostic
15:19:03 <jle`> @pl \s1 s2 -> map head $ (intsersect `on` group . sort) s1 s2
15:19:03 <lambdabot> (line 1, column 47):
15:19:03 <lambdabot> unexpected "s"
15:19:03 <lambdabot> expecting space
15:19:03 <lambdabot> ambiguous use of a right associative operator
15:19:59 <Zekka> @pl tries to convert to pointlss form, right?
15:20:00 <lambdabot> (line 1, column 34):
15:20:00 <lambdabot> unexpected ','
15:20:02 <lambdabot> expecting variable, "(", operator or end of input
15:20:15 <jle`> @pl \s1 s2 -> map head $ (intsersect `on` (group . sort)) s1 s2
15:20:15 <lambdabot> (map head .) . (intsersect `on` (group . sort))
15:20:40 <jle`> could probably be less bad if we had one point
15:20:47 <jle`> @pl \s2 -> map head $ (intsersect `on` (group . sort)) s1 s2
15:20:48 <lambdabot> map head . (intsersect `on` (group . sort)) s1
15:21:03 <monochrom> interesting exercise
15:21:18 <Zekka> Is there a reason you keep spelling intersect with an extra s?
15:21:27 <jle`> > let f s1 = map head . (intersect `on` (group . sort)) s1 in f "hello" "worldl"
15:21:28 <lambdabot>  "lo"
15:21:42 <jle`> Zekka: haha. not really
15:22:36 <jle`> clutch spelled it right when it mattered though
15:22:39 <jle`> woo hoo
15:24:33 <Twey> New2Haskell: http://lpaste.net/101415 — you can do it by intersecting two maps
15:25:26 <Zekka> Twey - Some folks have alrady come up with shorter ways to do it, although your solution might still be correct
15:25:44 <jle`> Twey: you can use M.member
15:25:51 <Twey> Oh, yes
15:25:55 * Twey facepalms.
15:26:07 <New2Haskell> ok ill take a look
15:26:19 <jle`> don't worry, i still sometimes extract items out of the Maybe before comparing them
15:26:29 <Twey> jle`: Wait, no I can't
15:26:38 <Twey> The value is important too.
15:26:45 <Zekka> jle` - Is there a shorter way to do that than (==) <$> maybe1 <*> maybe2 ?
15:26:58 <jle`> Zekka: maybe1 == maybe2
15:27:00 <jle`> ?
15:27:03 <jle`> > Just 3 == Just 3
15:27:04 <Zekka> Oh. Right.
15:27:04 <lambdabot>  True
15:27:11 <jle`> > Just 3 < Just 8
15:27:11 <Twey> The Applicative will give you a Maybe Bool
15:27:12 <lambdabot>  True
15:27:20 <jle`> oh yeah
15:27:24 <Twey> Zekka: Ah, but mine has reasonable performance characteristics
15:27:31 <Zekka> I didn't know the other comparisons were defined on Maybe though
15:27:44 <jle`> Twey: ah, misread it, you're right
15:27:47 <jle`> my apologies
15:27:57 <jle`> Zekka: yeah, came up by surprise after a typo
15:28:03 <jle`> or maybe was it typing :info Maybe
15:28:06 <jle`> and seeing it had an Ord instance
15:28:07 <Zekka> Twey - Yeah -- intersect is probably pretty expensive
15:29:05 <Zekka> (I don't actually see its time-complexity listed but given that it doesn't assume Ord or anything I'm guessing it doesn't use any particular optimizations, so probably O(n^2))
15:29:45 <Zekka> Judging  by the implementation it's definitely O(n^2)
15:30:03 <Zekka> operative line: intersectBy eq xs ys =  [x | x <- xs, any (eq x) ys]
15:30:07 <zipper> Uh I am thinking of using haskell-chart for a few graphs. However I have an issue. I am wondering whether to use thr diagrams backend or the cairo backend. Note that I installed cairo when I installed  threadscope.
15:30:36 <jle`> do we have any containers-like libraries that use ffi c mutable data structures under a pure interfrace?
15:30:38 <hpc> i think diagrams can use cairo as its own backend, but also gives you other stuff
15:30:47 <hpc> it depends what your final output is going to be
15:30:57 <Apocalisp> jfischoff: When's BayHac?
15:30:57 <hpc> svg, png, an actual window?
15:31:07 <zipper> hpc: graphs png svg
15:31:21 <zipper> I am guessing png is best for graphs
15:31:27 <zipper> widely supported.
15:31:48 <jle`> so is svg, and it's vector
15:32:10 <zipper> jle`: I jus read about svg having support issues
15:32:12 <hpc> svg can get majorly unuseful if the graph is complex
15:32:20 <zipper> I want to use the graphs in my blog
15:32:25 <hpc> but support is solid across the board as long as you don't need ie6
15:32:27 <jle`> ah. blog makes more sense for png
15:32:36 <hpc> png is probably best regardless
15:32:38 <jle`> i was thinking something like pdf
15:32:39 <jle`> publishing
15:32:46 <hpc> cairo can output png with no trouble
15:33:04 <henk> »10,007,120 bytes allocated in the heap« that sounds much, is that much?
15:33:11 <jle`> if you're writing a paper i would probably recommend a vector format, and latex/pdfs take svgs well enough
15:33:17 <zipper> I read about svg having issues with support on some browsers plus on mobile.
15:33:17 <Zekka> henk - How much data are you operating on?
15:33:27 <jle`> i wouldn't use svg for web
15:33:50 <zipper> jle`: What is svg good for just pdf?
15:33:55 <zipper> and latex
15:34:02 <jle`> power point/slides?
15:34:03 <Rufflewind_> it's good for authoring :P
15:34:11 <jle`> presentations
15:34:14 <zipper> Thanks
15:34:14 <jle`> word docs
15:34:17 <jmcarthur> i had to leave and come back, so this is now an old topic, but i'm just an idiot and used too few fmaps. it was indeed related to the pointless style that screwed me up.
15:34:19 <jle`> yeah mostly in academic settings
15:34:22 <henk> Zekka: 2500 byte
15:34:42 <Zekka> I'd say that's a lot
15:34:46 <henk> Zekka: If you mean the input files to my program.
15:34:48 <Rufflewind_> pointless == pointfree ?
15:34:59 <jle`> i think it's a pun
15:35:05 <jmcarthur> Rufflewind_: yeah. sometimes we call it pointless because that is sometimes all it turns out to be
15:35:28 * zipper crosses fingers 
15:35:37 <Rufflewind_> hehe i figured; too many (.)'s can ruin my today :)
15:35:37 <zipper> cabal install chart-cairo
15:35:55 <jle`> i live for (.) man
15:35:56 <zipper> Hope no conflicts with cairo used in threadscope
15:36:14 <jle`> (.) all day err day
15:36:26 <jle`> never (>>>)
15:36:44 <Zekka> I should probably learn Arrow, it would make plumbing easier
15:36:49 <jle`> who even (>>>)s
15:36:50 <henk> Zekka: Thanks
15:37:09 <zipper> jle`: is that for function composition?
15:37:11 <jle`> Zekka: Arrow for the (->) category is not really much, it's only some utility compositions in that context
15:37:11 * hackagebot purescript 0.4.6 - PureScript Programming Language Compiler  http://hackage.haskell.org/package/purescript-0.4.6 (PhilFreeman)
15:37:16 <jle`> zipper: yes
15:37:19 <jle`> (>>>) is flip (.)
15:37:30 <jle`> for (.) in Control.Category
15:37:37 <jle`> which is (.) in Prelude for (->) category
15:37:42 <zipper> jle`: Why would I want to flip (.) ?
15:37:53 <zipper> No install issues yet.
15:37:54 <jle`> zipper: same reason you would want to use >>=
15:38:00 <Zekka> http://hackage.haskell.org/package/base-4.6.0.1/docs/Control-Arrow.html <- here's where >>> is defined and some details
15:38:03 <jmcarthur> jle`: I (<<<) sometimes...
15:38:05 <henk> Can anyone tell me where in http://lpaste.net/101349 »10,007,120 bytes allocated in the heap« this could be happening? Or what the best way is to debug that?
15:38:18 <jmcarthur> jle`: but I don't really (>>>)
15:38:35 <jle`> maybe (>>>) makes sense if you are in a bunch of (>>=)'s
15:38:37 <zipper> jle`: really? I don't figure but I am not an experienced haskeller
15:38:46 <jmcarthur> jle`: or in a bunch of (>=>)s
15:38:51 <jle`> yeah
15:39:05 <Rufflewind_> consider using a profiler?
15:39:17 <Zekka> Ooh, Arrows also have all kinds of other great operations
15:39:23 <zipper> Oh boy as far as I can tell I am not in cabal hell!!
15:39:26 <jle`> zipper: instead of, say, sortAndCompare = compare . sort
15:39:27 <zipper> :-D
15:39:33 <jle`> you can say sortAndCompare = sort >>> compare
15:39:35 <Zekka> like ^>>, >>^, ^<< and <<^
15:39:53 <jmcarthur> jle`: i prefer (=<<) over (>>=) and (<=<) over (>=>), except when the monad is especially "statey" like IO
15:40:01 <jle`> jmcarthur: me too
15:40:06 <jle`> hence "who even (>>>)s"
15:40:18 <hpc> bro, do you even liftM?
15:40:25 <Zekka> jmacarthur - Same feelings, because I like it when they're shaped like function application
15:40:40 <jle`> i don't think we would even have >>= if we didn't have do notation
15:40:46 <jle`> or we wouldn't use it as often
15:40:49 <zipper> jle`: for me f.g makes more sense and f(g x)
15:40:56 <zipper> So I prefer the (.)
15:41:00 <zipper> Familiarity
15:41:02 <jle`> zipper: and you should :)
15:41:17 <jle`> (>>>) might be familiar to people who use unix pipes though
15:41:21 <hpc> jle`: somebody would stumble upon it and it'd make a good enough substitute for imperative that someone would use it
15:41:23 <Zekka> If Haskell had suffix function application I'd probably be more of a >>> fan
15:41:28 <jle`> because unix pipes are basically (>>>)
15:41:50 <jle`> and id = cat
15:41:54 <anna> @pl \ ex -> "Error while parsing " ++ fp ++ ": " ++ show ex
15:41:55 <lambdabot> (("Error while parsing " ++ fp ++ ": ") ++) . show
15:42:51 <jle`> echo "hello" | cat | grep h, kinda like (grep h . cat . echo "hello") ()
15:42:58 <Peaker> FilePath = String   --> world of pain
15:42:59 <jle`> () because we ignore stdin
15:43:21 <jle`> but you can also say (echo "hello" >>> cat >>> grep 'h') ()
15:43:28 <jle`> to basically be a unix pipe
15:43:37 <Peaker> My performance is terrible due to all the FilePath strings everywhere :(
15:44:04 <Rufflewind_> blame Prelude :(
15:44:07 <Twey> Hm
15:44:15 <Twey> > M.differenceWith (\ x y → if x == y then Just x else Nothing) (M.fromList [('a', 1), ('b', 2)]) (M.fromList [('c', 2), ('b', 2)])
15:44:16 <lambdabot>  fromList [('a',1),('b',2)]
15:45:41 <Peaker> I don't even see alternatives for System.FilePath/Directory  that use a ByteString path.. only System.Posix.Directory/etc which are lower-level
15:47:42 <shachaf> Well, Windows file paths aren't bytestrings.
15:47:51 <shachaf> It's tricky to do it correctly in a cross-platform way.
15:50:45 <Twey> http://lpaste.net/101415
15:50:54 <Twey> (New2Haskell)
15:51:37 <Twey> It's annoying that there isn't a nice way to make general intersection-like operations without mergeWithKey
15:51:42 <vernon> Hello. Is any of the GSOC  mentors here by any chance?
15:51:57 <Twey> vernon: There's a dedicated #haskell-gsoc channel
15:51:58 <jle`> vernon: try #haskell-gsoc :)
15:52:08 <vernon> thanks a lot.
15:56:40 <jmcarthur> woah, darcs has first class support for importing and exporting with git now
15:56:53 <MP2E> nice o.O
15:57:13 * hackagebot tagged-binary 0.1.2.0 - Provides tools for serializing data tagged with type  information.  http://hackage.haskell.org/package/tagged-binary-0.1.2.0 (jle)
16:00:36 <Jitendra> hi everyone
16:00:39 <jle`> hi Jitendra
16:00:54 <Jitendra> i need urgent help
16:01:23 <Jitendra> can you guide me how to setup eclipsefp  for haskell
16:01:39 <jle`> not me, sorry
16:01:56 <Jitendra> jle : hi do you no anyone who can do this
16:03:18 <SrPx> is there an algorithm for determining function equality on the simply typed lambda calculus?
16:04:59 <Jitendra> hi all....please can anyone help me with setting up eclipsefp for haskell
16:06:03 <Jitendra> i heared that this is a great platform to start learning haskell
16:06:13 <ZettaBlade> Jitendra: whats wrong with http://eclipsefp.github.io/install.html
16:07:04 <kadoban> huh, i never knew that existed...i wolud have loved that back when i still used eclipse
16:07:17 <Jitendra> zettablade: I have installed using those instructions but i hoogle is not shwing any search results
16:07:19 <jmcarthur> SrPx: if you can generate all possible inputs then you can just exhaustively try every possible input
16:08:02 <jmcarthur> SrPx: oh, STLC, not Haskell... so maybe you could refine what you mean by equality
16:08:33 <jmcarthur> SrPx: if you mean "has the same canonical form" then you could just reduce both to canonical form and then compare the results
16:08:39 <Jitendra> zettablade: i mean no syntax highlight no method description using hoogle etc is working
16:09:49 <jmcarthur> SrPx: if you mean "always give the same results no matter the input" then i don't know
16:10:16 <Jitendra> zettablade: r u still there
16:10:42 <jmcarthur> SrPx: it may be that the former implies the latter, but i just don't know for sure. i had looked into exactly that question before and i think it came up positive, but i don't remember.
16:12:55 <ZettaBlade> Jitendra: if you set it up correctly and eclipse is in haskell mode, then it's probably a bug of some sort. Cant really help yah there :c
16:13:47 <Jitendra> zettablade: can u suggest me any other editor to work with haskell
16:14:17 <SrPx> jmcarthur: I was thinking as it is not turing complete then there should be an algorithm at least better than brute force
16:15:25 <Jitendra> zettablade: i just started learning haskell...and it would be nice if i have a editor which will have some intellisense
16:16:02 <ZettaBlade> I usually use vim on computer, and fpcomplete.com works for me. Fpcomplete costs $$$ though. $10 a month or something.
16:16:31 <jle`> vim has intelligence
16:16:36 <jle`> not sure about intellisense
16:16:55 <hpc> the i stands for intelligence
16:16:58 <hpc> the v stands for vim
16:17:29 <hpc> (the m also stands for vim)
16:18:04 <ZettaBlade> Yea i dont think either of those have intellisense, unless theres a vim plugin out there somewhere deep in the bowels of github
16:18:45 <jle`> if you got eclipsefp to work for the most part, i dont' think you really need hoogle integration to have an effective ide
16:18:50 <tmhedberg> You can get some completion using ghc-mod with vim or emacs
16:20:08 <MP2E> structured haskell mode + ghc-mod in emacs is awesome
16:20:34 <MP2E> fair bit of completion between the two, and autoformatting/syntax checking on the fly
16:20:48 <Jitendra> is emacs for windows
16:20:49 <MP2E> dunno how it compares to intellisense, I don't use vs
16:20:55 <Jitendra> or for MAC
16:21:42 <AncientPC> :source /home/ting/.local/share/byobu/profile
16:21:56 <AncientPC> oops, random copy / paste
16:22:59 <ZettaBlade> Fpcomplete has hoogle integration. It's convenient to not have to type haskell.org/hoogle to get a search hoogle
16:23:30 <ZettaBlade> Wish there was a browser search plugin for hoogle
16:23:44 <Rufflewind_> custom search with chrome works fine for me
16:24:09 <Rufflewind_> and it's not even an extension; just a builtin feature
16:24:48 <ZettaBlade> Nice
16:25:02 <archblob> I found this in hlint changelog " Don't suggest use of Data.Ord.comparing, using `on` is better " can someone explain the reasoning ?
16:28:48 <hpc> archblob: basically, the suggestion is to expand the definition of comparing
16:28:49 <hpc> @src comparing
16:28:50 <lambdabot> Source not found. It can only be attributed to human error.
16:29:02 <hpc> comparing f = compare `on` f -- or something like that
16:29:16 <hpc> archblob: there's honestly not much reason for it in that particular case
16:29:28 <Jitendra> so can someone tell me which is the best editor to start with haskell
16:29:40 <hpc> Jitendra: the one you already have
16:29:55 <Jitendra> but i am unable to get it working
16:30:04 <Jitendra> i wasted my time since morning fixing it
16:30:18 <Jitendra> but still unsuccessfull
16:31:01 <Jitendra> hpc: did u install eclipsefp plugin in ur machine
16:31:08 <Earnestly> Oh boy
16:34:36 <jfischoff> Apocalisp: BayHac is May 16-18, but I guess you know that now ;)
16:35:04 <bitemyapp> Given: data Foo a b c = Foo a b c deriving (Show) - how do I go from [(a, b, c)] -> [Foo] generically?
16:35:33 <bitemyapp> in some sense, I'm looking for a Clojure/Scala-esque "apply". Use of lens is kosher.
16:45:52 <bitemyapp> I got my answer, disregard my question :)
16:47:17 * hackagebot hyperloglog 0.2.3.2 - An approximate streaming (constant space) unique object counter  http://hackage.haskell.org/package/hyperloglog-0.2.3.2 (EdwardKmett)
16:52:20 <archblob> @src Data.Ord.comparing
16:52:20 <lambdabot> Source not found. Are you on drugs?
16:53:01 <MP2E> haha
16:53:12 <archblob> hpc: comparing f a  b = compare (f a) (f b)
16:54:04 <archblob> hpc: but to me comparing fst reads better than compare `on` fst in this particular case and is shorter, that's why I was puzzled about the decision
16:54:51 <hpc> archblob: indeed
16:55:59 <archblob> hpc: i just ran into that today and was looking to add a definition to hlint and when searching i cam upon that line in the changelok, just seemed odd
16:58:53 <jcarpenter2> Is there a way to capture up arrow presses or ctrl+p presses in Haskeline?
16:59:28 <jcarpenter2> I see how to handle ctrl+c
17:00:25 <jcarpenter2> although ctrl+c of course also quits the program
17:14:51 <Kron> comparing = compare `on`
17:17:54 <archblob> equivalent but not the way it is defined in the Prelude
17:22:59 <verement> :t comparing
17:26:07 <Zekka> Anyone know if I can use lenses to remove the head of a list? Something like list._head .~ Nothing, with a different operator, I'd imagine
17:27:06 <Zekka> Never mind, looks from the operator's page like it's not possible (which makes me sad)
17:27:22 * hackagebot floatshow 0.2.4 - Alternative faster String representations for Double and Float,  String representations for more general numeric types.  http://hackage.haskell.org/package/floatshow-0.2.4 (DanielFischer)
17:27:31 <edwardk> Zekka: not that way. there is an uncons/tail combinator obviously, and you can obviously just id %~ tail ;)
17:27:35 <Zekka> operators*
17:27:48 <edwardk> aka tail =)
17:28:07 <Zekka> edwardk - That probably should have been my first thought -- thanks
17:28:48 <edwardk> Zekka: there is a prism for _Cons you can use to match the cons cell an play games with it. that is used by head/tail/uncons/cons in Control.Lens.Cons as well
17:29:28 <Zekka> edwardk - I'm not sure I know the types well enough to trust myself to play with that -- should I be reading up on the derivations?
17:30:12 <edwardk> > Control.Lens.Cons.cons 1 [2,3]
17:30:13 <lambdabot>  Not in scope: `Control.Lens.Cons.cons'
17:30:13 <lambdabot>  Perhaps you meant one of these:
17:30:13 <lambdabot>    `Control.Lens.uncons' (imported from Control.Lens),
17:30:13 <lambdabot>    `Control.Lens.contains' (imported from Control.Lens),
17:30:13 <lambdabot>    `Control.Lens.cons' (imported from Control.Lens)
17:30:21 <edwardk> > cons 1 [2,3]
17:30:23 <lambdabot>  [1,2,3]
17:30:27 <edwardk> oh, it is in scope
17:30:52 <edwardk> :t _tail
17:30:53 <lambdabot> Cons (->) f s s a a => LensLike' f s s
17:31:15 <edwardk> you can of course use _tail to access the tail of a list if it has a head.
17:31:28 <edwardk> the real question is why you can't just %~ tail
17:31:58 <Zekka> That actually works, but uncons is closer to what I originally intended
17:32:35 <Zekka> suffice it to say I was mucking about and trying to find a sufficiently clever way to do what I wanted with builtins and missed a really obvious one
17:33:33 <edwardk> k
17:49:29 <Kron> Does anyone know any Haskell QuadTree libraries?
17:50:37 <pavonia> I think someone released one very recently
17:50:45 <Kron> because I can't find any at the moment. I've been working on one for ages mostly on an educational lark
17:51:07 <Kron> I'm wondering if I've kind of accidentally cornered the market here or something
17:51:46 <pavonia> http://hackage.haskell.org/package/QuadTree-0.10.0/candidate
17:51:49 <Kron> hah
17:51:50 <Kron> that's mine
17:51:55 <Kron> <-- Ashley Moni
17:52:00 <pavonia> Oh :D
17:52:07 <Kron> I made it a while ago for one of my friends
17:52:11 <Kron> she was working on a haskell roguelike
17:52:23 <Kron> and I wanted to give her something she could use that was better than a naive array
17:52:53 <Kron> but a few days ago I tried googling around for other quadtree things and all I find is some gloss library and some space partition thing that I don't understand
17:53:02 <pavonia> There's also http://hackage.haskell.org/package/spacepart-0.1.0.0
17:53:13 <Zekka> Don't most roguelikes just use a 2D grid for levels?
17:53:20 <Zekka> What does a quadtree do for them in this cases?
17:53:21 <Zekka> case*
17:53:57 <Kron> nothing, really. But it's a choice between the ST monad and some sort of structure that doesn't rewrite the whole thing on every unit movement
17:54:00 <MP2E> haskell roguelike, neat
17:54:24 <Kron> like she could've done it the normal way but she wanted to go for purity
17:54:40 <Zekka> Do Haskell's builtin arrays actually recopy/rewrite with every change? I thought laziness meant they didn't necessarily
17:54:56 <Kron> diff arrays are supposed to be the solution, but I hear they aren't quite up to snuff? I donno
17:55:10 <edwardk> Zekka: you can just store it s a Map (X,Y) valu
17:55:12 <edwardk> Zekka: arrays are big flat panels of memory
17:55:16 <edwardk> diff arrays pretty much are never a win
17:55:35 <Zekka> edwardk - I didn't know that Haskell arrays were actually represented as arrays.
17:55:42 <Kron> anyway, what I'd like to know is if there's some actual non-exercise merit to my work
17:55:47 <Kron> because if there is
17:55:52 <Kron> I'd like to do it right
17:55:55 <pavonia> Btw, what is the "candidate" in that hackage link supposed to mean?
17:55:56 <Kron> and publish something stable and useful
17:56:00 <Zekka> (For the record I'd probably be using a Map (X, Y) SomethingOrOther too)
17:56:03 <edwardk> Kron: what is your goal?
17:56:06 <Kron> it means it's not on the main listing and I can overwrite it
17:56:17 <Kron> my /initial/ goal was to just make a quadtree library that uses lenses
17:56:21 <Kron> now my goal is morphing slightly
17:56:38 <Kron> I want to make a good straightforward quadtree library, kind of like Data.List or Data.Map
17:56:57 <Kron> something simple and easy to use and easy to tack on and not terribly inefficient
17:57:05 <Kron> ... and I'd like to keep in lens support
17:57:18 <Kron> I'm exposing the direct setters and getters now in case people dont' want to use the lens
17:57:21 <edwardk> fair nuff. what algorithms do you want to be able to do on the quadtree? i confess it has been mostly replaced in my bag of tricks
17:57:25 <Kron> and I want to kind of rewrite my code to use prisms eventually
17:57:26 <Zekka> Oh, quick question by the way (not necessarily for you) -- is there a way I can check whether I'm running under an EitherT SomeType in a constraint?
17:57:47 <Zekka> A lot of monad transformers seem to provide their own typeclass but EitherT doesn't look like it does
17:57:48 <Kron> at the moment it basically has an index API that lets you poke it like it's an array
17:58:05 <Kron> but you can also process entire batches of nodes as leaves themselves
17:58:06 <Zekka> (using this definition of EitherT, which I think is edwardk's but I'm not sure: http://hackage.haskell.org/package/either-4.1.1/docs/Control-Monad-Trans-Either.html)
17:58:29 <edwardk> Zekka: instanceMonad m => MonadError e (EitherT e m)
17:58:33 <edwardk> use MonadError as that class
17:58:42 <edwardk> the issue was with the instance, not the class =)
17:58:56 <Zekka> Oh, it provides MonadError? I didn't see it in the list, I guess I was scanning for MonadEither
17:58:58 <Kron> http://hackage.haskell.org/package/QuadTree-0.10.0/candidate/docs/Data-QuadTree.html#g:5
17:59:12 <edwardk> yeah it does
17:59:12 <Kron> there's a tile system I've been working on
18:00:10 <Kron> basically just decomposing the quadtree into large chunks of similar elements so that they can be processed in batch, I guess
18:00:31 <Kron> lets you do things like sum all the elements a lot faster than an array, depending on distribution
18:01:15 <Kron> anyway I'd like to know what to do to make it... worth publishing I guess?
18:01:26 <Zekka> I think that sounds pretty cool
18:01:48 <Kron> hah, thanks
18:01:53 <meretrix> What are "i" and "p" in "newtype K1 i c p = K1 { unK1 :: c }"?
18:01:57 <edwardk> Kron: not sure. there are enough points in the design space that it is the kind of library i tend to void publishing
18:02:43 <Kron> hmmm
18:03:01 <edwardk> meretrix: the p is unused (unless using Generic1) but type Par0 = K1 P
18:03:18 <edwardk> and type Rec0 = K1 R
18:03:33 <edwardk> those indicate if its a parameter or recursion
18:04:12 <meretrix> Ah ok, thanks.
18:05:08 <edwardk> the whole point of 'p' is that newtype Par1 p = Par1 {unPar1 :: p}   gets 'p' plumbed to it as i recall
18:07:37 <edwardk> e.g. type Rep1 [] p = M1 D ... (C1 ... U1 :+: C1 ... (S1 NoSelector Par1 :*: S1 NoSelector (Rec1 [])))  -- is plumbing 'p' down to that Par1
18:07:43 <edwardk> er
18:07:50 <edwardk> type Rep1 [] p = M1 D ... (C1 ... U1 :+: C1 ... (S1 NoSelector Par1 :*: S1 NoSelector (Rec1 []))) p
18:10:12 <edwardk> whereas type Rep [Int] = M1 D ... (C1 ... U1 :+: C1 ... (S1 NoSelector (Rec0 Int) :*: S1 NoSelector (Rec0 [Int])))  -- uses Rec0 = K1 R   which just keeps ignoring p
18:12:26 * hackagebot diagrams-lib 1.1.0.2 - Embedded domain-specific language for declarative graphics  http://hackage.haskell.org/package/diagrams-lib-1.1.0.2 (BrentYorgey)
18:12:28 * hackagebot diagrams-cairo 1.1.0.1 - Cairo backend for diagrams drawing EDSL  http://hackage.haskell.org/package/diagrams-cairo-1.1.0.1 (BrentYorgey)
18:17:26 * hackagebot heist 0.13.1 - An Haskell template system supporting both HTML5 and XML.  http://hackage.haskell.org/package/heist-0.13.1 (DougBeardsley)
18:19:46 <Kron> not quite sure to do with my code
18:23:38 <ezrios> sacrifice it to the gods
18:32:27 * hackagebot diagrams-postscript 1.0.2.1 - Postscript backend for diagrams drawing EDSL  http://hackage.haskell.org/package/diagrams-postscript-1.0.2.1 (BrentYorgey)
18:47:08 <stolaruk> Can I use Monadic QuickCheck "monadicIO" to test functions in a monad transformer stack that ends in IO a?
18:52:23 <zipper> I chose to use haskell-chart for a simple bar graph but I am having issues with the colors of the bars.
18:52:57 <zipper> plot_bars_item_styles_ :: [(CairoFillStyle, Maybe CairoLineStyle)]
18:53:12 <zipper> Bloody hell
18:53:14 <ezrios> is there something like
18:53:17 <ezrios> uncurry for lists?
18:53:54 <jle`> ezrios: what if the list is too long, too short ...?
18:54:03 <ezrios> jle`: assume it is of a fixed size?
18:54:03 <Kron> uncurry as in?
18:54:07 <ion> ezrios: foldr
18:54:09 <Kron> what's the size?
18:54:09 <ezrios> I guess I could just convert it to a tuple
18:54:15 <ezrios> Kron: 3
18:54:18 <Kron> what's the operation you want to perform?
18:54:31 <ezrios> @hoogle fromGregorian
18:54:32 <lambdabot> Data.Time.Calendar fromGregorian :: Integer -> Int -> Int -> Day
18:54:32 <lambdabot> Data.Time.Calendar fromGregorianValid :: Integer -> Int -> Int -> Maybe Day
18:54:40 <ezrios> Parsec is giving me a list of results
18:54:47 <jle`> ezrios: well...lists really aren't meant to be used that kind of way
18:54:51 <Kron> yeahh
18:54:54 <ezrios> hum
18:54:58 <Kron> and in fact, I don't think it would even work
18:55:03 <jle`> can't you rewrite your parser?
18:55:04 <Kron> you can't have [Integer, Int, Int]
18:55:07 <Kron> you have to have a tuple
18:55:07 <ezrios> Kron: right
18:55:12 <ezrios> just noticed that ._.
18:55:15 <jle`> fromGregorian <$> parseInteger <*> parseInt <*> parseInt ?
18:55:28 <ezrios> ah right, applicatives
18:55:31 <ezrios> I always forget about those
18:55:34 <Kron> the second and third parseInt
18:55:40 <Kron> should get the same int? unless i'ts an IO action
18:55:46 <thebnq> also preferable so guarantee parsing 3
18:55:48 <ezrios> they're monadic
18:55:52 <Kron> ah, okay
18:55:53 <jle`> Kron: not in Parsec at least
18:55:55 <pavonia> zipper: What problem in particular?
18:56:00 <jle`> or any...useful monadic parser library
18:56:09 <jle`> that's sort of the whole point of monadic parsers heh
18:56:43 <dmj`> I'd say the fact you can combine them is wherein the power lies
18:57:54 <jle`> dmj`: yeah, their composability is their main power but
18:58:00 <jle`> a monadic parser that doesn't consume any input
18:58:04 <jle`> is kinda not so useful
18:58:26 <jle`> "whole point" might have been a bad choice of words
18:58:54 <zipper> pavonia: uh the one in the example is "plot_bars_item_styles .~ map mkstyle (cycle defaultColorSeq)" but what I want to do is compare the following four and the library doesn't seem to have foreseen this very simple use case.
18:59:09 <zipper> pavonia: Let me upload a pic
18:59:15 <zipper> pavonia: http://imgur.com/FFYNlSA
18:59:56 <pavonia> And you want each to have a different color?
19:00:08 <zipper> pavonia: Yes but I don't know how to get plot_bars_item_styles_ :: [(CairoFillStyle, Maybe CairoLineStyle)] to do this.
19:00:26 <pavonia> You'd need four elements, I think
19:00:41 <zipper> pavonia: What do you mean by four elements?
19:01:11 <pavonia> A list with four elements with color specifications in the order of the four bars
19:03:28 <zipper> pavonia: I don't really get how to specify the color in a list but this is the source file: https://gist.github.com/urbanslug/9634144
19:09:24 <pavonia> zipper: Hhm, as far as I understand your code should already color them correctly
19:09:50 <pavonia> Although the extra cycle doesn't seem to be necessary
19:10:09 <zipper> pavonia: Which extra cycle?
19:10:36 <pavonia> in your code, defaultColorSeq already has one
19:11:04 <pavonia> No wait, these colors are for each group of bars
19:11:22 <zipper> pavonia: I got that from the example. It doesn't correlate to the tuple used in documentation
19:11:25 <RaceCondition> what's the reason for `type T = Either String T` being illegal?
19:11:33 <zipper> pavonia: Yes that is what is up
19:12:03 <zipper> pavonia: It was made with this in mind https://github.com/timbod7/haskell-chart/wiki/example%2011
19:13:13 <croyd> RaceCondition: I'm kinda a noob but I think type variables need to be lower case, e.g. 'type t = Either String t'
19:13:22 <dmj`> RaceCondition: it forms a cycle
19:13:31 <dmj`> "Cycle in type synonym declarations:"
19:13:40 <croyd> o
19:13:50 <zipper> pavonia: The writer had a comparative bar graph in mind
19:14:23 <RaceCondition> dmj`: well that's obvious and what the errors says, but WHY aren't cycles allowed in this case?
19:14:32 <pavonia> zipper: Yeah, I see the problem but no solution atm
19:14:50 <RaceCondition> croyd: `type T = ...` is a definition of a type alias
19:14:54 <S11001001> RaceCondition: interestingly type T = Either String is a more useful way to write type T t = Either String t.  No scala nonsense here.
19:15:41 <zipper> pavonia: Uh have you looked at the docs for coloring bar graphs?
19:15:50 <RaceCondition> S11001001: could you elaborate?
19:15:52 <S11001001> RaceCondition: If you want to tie type knots, you can do this with 'newtype' instead of 'type'.  GHC 7.8 will have wonderful new facilities for dealing with this efficiently, something of a much more sophisticated and safe mechanism than scalaz's Tag.subst.
19:15:57 <pavonia> zipper: Yes
19:16:26 <S11001001> RaceCondition: you know how haskell functions only take one argument?
19:16:29 <RaceCondition> S11001001: newtype doesn't allow more than one constructor tho, so it's not very useful for emulating Either
19:16:36 <zipper> pavonia: Could you explain what that tuple means. Because it is not in the example.
19:16:39 <RaceCondition> yes, I know that
19:16:44 <S11001001> newtype E = E (Either String E)
19:16:59 <RaceCondition> aha, ok
19:17:01 <pavonia> zipper: Which tuple exactly?
19:17:19 <zipper> pavonia: (CairoFillStyle, Maybe CairoLineStyle)
19:17:45 <S11001001> @src Mu
19:17:45 <lambdabot> newtype Mu f = In { out :: f (Mu f) }
19:18:10 <zipper> :t map
19:18:10 <S11001001> E is isomorphic to Mu (Either String)
19:18:11 <lambdabot> (a -> b) -> [a] -> [b]
19:18:22 <pavonia> zipper: It's the sytle for each bar in a group in the order the values for these bars are given
19:18:34 <RaceCondition> S11001001: I didn't get what you said first tho... not seeing how that relates to what I asked
19:18:55 <S11001001> RaceCondition: It doesn't, just an interesting note about defining type synonyms.
19:19:04 <pavonia> zipper: the pair is built via "mkstyle c = (solidFillStyle c, bstyle)"
19:19:28 <RaceCondition> S11001001: yeah, type-level currying (probably not the right term)
19:19:46 <S11001001> RaceCondition: could be
19:20:20 <S11001001> RaceCondition: anyway, where it's just a syntactic difference (in the presence of NoMonomorphismRestriction) for functions, it actually means something different for synonyms.
19:20:59 <zipper> pavonia: Ok so mkstyle is the consumer of the tuple?
19:20:59 <RaceCondition> I have no idea what NoMonomorphismRestriction is, but I think I get your point
19:21:30 <zipper> pavonia: While `(cycle defaultColorSeq)` is a list of tuples?
19:21:43 <pavonia> zipper: Its just a simple function that maps a color to a pair
19:22:02 <pavonia> zipper: No, defaultColorSeq is a list of colors
19:22:28 <pavonia> defaultColorSeq :: [AlphaColour Double]
19:22:29 <zipper> pavonia: I also can't see how colors are defined. Whether in hex or strings.
19:22:48 <pavonia> defaultColorSeq = cycle $ map opaque [blue, red, green, yellow, cyan, magenta]
19:22:53 <zipper> pavonia: Oh man I must be in over my head
19:22:53 <asdgaf> how can i parse a string containing row and column indexes and a number into a 2d cumulative array?
19:22:58 <zipper> I am lost
19:23:01 <pavonia> that's the definition in Graphics.Rendering.Chart.Drawing
19:24:15 <pavonia> zipper you have that list defaultColorSeq and map mkstyle over it to build a list of pairs, it's really nothing magical here
19:24:37 <zipper> :t cycle
19:24:38 <lambdabot> [a] -> [a]
19:26:26 <pavonia> zipper: Re your problem, you could try the following: set "plot_bars_style .~ BarsStacked" and give the values like "[[3409], [0, 511.3], [0,0,559.6], [0,0,0,1071]]"
19:26:30 <zipper> pavonia: I am not sure but I think I can make cycle run once every time map is called.
19:26:43 <zipper> pavonia: I had tried that
19:26:50 <zipper> pavonia: It lacked symmetry.
19:27:02 <zipper> wait not that exactly
19:28:00 <zipper> pavonia: Worked like a charm.
19:28:10 <pavonia> Oh nice
19:28:11 <zipper> pavonia: Thanks a ton.
19:28:42 <pavonia> But that still seems like an ugly workaround to me :p
19:29:02 <zipper> pavonia: It is but I had no choice.
19:29:21 <zipper> pavonia: Have you used haskell-chart before?
19:29:49 <pavonia> Not really used it, but I had a look at it when I needed a plotting library
19:29:50 <zipper> I can't see how to manipulate size of output image in the docs
19:30:01 <stolaruk> omg I got Monadic QuickCheck to work
19:30:02 <zipper> pavonia: Which one did you use?
19:30:26 <pavonia> zipper: I#ve started to write my own :D
19:30:28 <asdgaf> how can i parse a string containing row and column indexes and a number into a 2d cumulative array?
19:31:05 <pavonia> zipper: I need it for financial charts plotting and I haven't found any library powerful enough for all my needs
19:31:16 <zipper> pavonia: Well I am looking for a GSoC project would looking for ways to fix haskell-chart have chances of going through?
19:31:45 <pavonia> Hhm, I don't know
19:32:02 <zipper> pavonia: I was also thinking of writing mine
19:32:30 <zipper> pavonia: One that can redraw every x times.
19:32:48 <pavonia> Do you need it for animations?
19:32:50 <dmj`> pavonia: you could use websockets and display them realtime in a browser
19:33:28 <pavonia> dmj`: Using what drawing engine?
19:34:22 <dmj`> javascript w/ html5 canvas, or webgl
19:35:20 <zipper> pavonia: Not really.
19:35:32 <zipper> dmj`: Oh could I?
19:35:51 <zipper> dmj`: That is one way to do it. Doesn't sound easy though.
19:36:28 <dmj`> use snap, websockets-snap, and yoru favorite javascript charting library
19:36:35 <dmj`> http://www.chartjs.org/
19:37:22 <dmj`> you could probably make the javascript type safe too
19:37:50 <pavonia> I've never really done anything more complex with HTML/JS, but I think it would be more complicated than the Cairo version I use for now
19:37:54 <dmj`> the benefit is you get the backend power of haskell to fetch and munge the data
19:38:38 <pavonia> Having different frontends would be a nice feature for later versions, though
19:40:10 <dmj`> do you receive the charting data via http?
19:42:00 <dmj`> guess it doesn't matte really
19:42:02 <dmj`> r
19:42:48 <joelteon> what's the policy on default-extensions in cabal file versus LANGUAGE pragmas?
19:43:35 <pavonia> dmj`: They can be loaded and updated in the program via csv files
19:44:32 <pavonia> zipper: Back to your question, your can change the "def" argument of "renderableToFile" to a FileOptions value
19:44:45 <pavonia> zipper: see http://hackage.haskell.org/package/Chart-cairo-1.2/docs/Graphics-Rendering-Chart-Backend-Cairo.html#t:FileOptions
19:44:53 <zipper> dmj`: I don't know JS I have no hurry to learn it.
19:45:09 <pavonia> zipper: the default is FileOptions (800,600) PNG
19:45:37 <zipper> pavonia: Ah def is short for deafult?
19:45:41 <zipper> *default?
19:45:59 <pavonia> yep
19:46:19 <zipper> I was confused. I thought it was some typedef language construct I wasn't familiar with.
19:46:33 <zipper> In my head def is typedef :<
19:46:37 <pavonia> It's the only function of the Default type class
19:47:04 <pavonia> And FileOptions is an instance
19:47:10 <djapo> does haskell have something equivalent to SciPy?
19:47:15 <dmj`> zipper: depending on your industry you might not need to know it, but if you can learn haskell you can learn js...
19:47:24 <haasn> djapo: what does SciPy do?
19:47:26 <zipper> pavonia: I am not good at haskell :(
19:47:46 <pavonia> You'll get better by time :)
19:47:48 <djapo> haasn is a scientific algorithm library
19:48:01 <zipper> pavonia: replace "good" with "expericed"
19:48:14 <haasn> djapo: there are a few scientific algorithms scattered throughout various packages; is there something specific you're interested in?
19:48:20 <dmj`> djapo: talk to carter, he's working on something like numpy for haskell I believe
19:48:24 <carter> ?
19:48:31 <zipper> pavonia: Yeah so I am not able to understand all that you are saying.
19:48:32 <carter> djapo: if you can wait a month it will
19:48:47 <carter> djapo: lurk on #numerical-haskell
19:49:06 <djapo> carter: ill add that to my channels list
19:49:29 <zipper> carter: lol how do you always show up when someone mentions something science or numerical related?
19:49:43 <zipper> carter: You check for keywords?
19:49:46 <carter> zipper: noh, textual makes a loud bing sound when people say my name
19:50:21 <pavonia> zipper: How long have you been learning Haskell?
19:50:25 <zipper> carter: Oh, I hadn't seen your name getting mentioned. My bad.
19:50:39 <zipper> pavonia: About a month. I just finished LYAH
19:50:55 <pavonia> ah okay
19:51:29 <zipper> pavonia: Why'd you ask?
19:52:08 <pavonia> just curious
20:03:43 <pyon> If I define an associated family "Foo s" inside a class "Bar s", why does GHC's type checker allow me to define type signatures containing "Foo s" without a "Bar s" constraint?
20:04:10 <Galactic> what do you guys think about this? http://honza.ca/2012/10/haskell-strings
20:04:22 <Galactic> should I believe his results?
20:04:58 <haasn> pyon: the same reason (SomeTF Int) is not a syntax error even if there is no type family instance for SomeTF Int
20:05:09 <haasn> pyon: I'm not sure what the technology is; but the compiler has no issue just leaving it as (Foo s)
20:05:13 <haasn> terminology*
20:05:33 <haasn> It's simply an uninhabited type until you know something more concrete about it
20:05:45 <haasn> (such as actual instance resolution would provide)
20:10:43 <Kron> Galactic: I think the Haskell community in general has moved away from String these days
20:10:46 <Kron> we use the Text package
20:11:02 <haasn> FSVO “Haskell community in general”, “moved away from”
20:11:08 <haasn> String is useful where String is useful
20:11:11 <Kron> ah, he's using Text down below
20:11:14 <haasn> and that is not an empty set
20:11:27 <Kron> noted
20:11:32 <Kron> FSVO?
20:11:37 <haasn> “for some value of”
20:11:53 <haasn> oh, I remember that post
20:12:32 <Kron> sorry for the badly qualified statements I guess
20:12:35 <Kron> didn't mean to speak for everyone
20:12:35 * hackagebot c-dsl 0.3 - A higher level DSL on top of language-c  http://hackage.haskell.org/package/c-dsl-0.3 (jozefg)
20:16:02 <heatsink> Huh.  It would have been nice if I had learned about this c-dsl thing a few years ago
20:16:30 <dmj`> Galactic: the article is myopic at best, compare haskell's concurrency to python. If all you write are single-threaded programs to manipulate strings then sure. There's something to be said for type-safety as well. He didn't even profile his code
20:17:21 <Galactic> I see
20:18:25 <Galactic> > scanl (+1) 0 [1,2,3,4]
20:18:27 <lambdabot>  Occurs check: cannot construct the infinite type: a0 = b0 -> a0
20:18:27 <lambdabot>  Expected type: a0 -> b0 -> a0
20:18:27 <lambdabot>    Actual type: a0 -> a0
20:18:35 <Galactic> ?
20:18:38 <Cale> > scanl (+) 0 [1,2,3,4]
20:18:39 <lambdabot>  [0,1,3,6,10]
20:20:19 <Galactic> > scanl (\a b -> a + b) 0 [1,2,3,4]
20:20:21 <lambdabot>  [0,1,3,6,10]
20:20:53 <Galactic> > scanl (\a b -> a + b + 1) 0 [1,2,3,4]
20:20:54 <lambdabot>  [0,2,5,9,14]
20:21:53 <Kron> dmj`: I'm not sure if it's all that myopic, he tried a large variety of programming languages
20:22:02 <Kron> he's just trying to keep the languages he learns honest, I guess
20:22:48 <Cale> > scanl (+) 0 [1,20,300,4000]
20:22:50 <lambdabot>  [0,1,21,321,4321]
20:23:14 <Cale> > scanl (flip (:)) [] [1,2,3,4]
20:23:15 <lambdabot>  [[],[1],[2,1],[3,2,1],[4,3,2,1]]
20:23:53 <thebnq> most of the benchmarking is of internal library calls too
20:25:28 <mvr_> I'm struggling with an overlapping instances problem trying to use the 'algebra' library
20:25:30 <Kingpatzer> anyone know how to get Leksah to install properly on Arch these days?
20:25:39 <mvr_> here's the error: http://lpaste.net/101432
20:26:06 <haasn> > scanl f x [a,b,c,d]
20:26:07 <lambdabot>  [x,f x a,f (f x a) b,f (f (f x a) b) c,f (f (f (f x a) b) c) d]
20:26:27 <mvr_> Why does it complain about the case that f is ()?
20:26:29 <haasn> > scanl (+) x [a,b,c,d]
20:26:31 <lambdabot>  [x,x + a,x + a + b,x + a + b + c,x + a + b + c + d]
20:27:06 <Galactic> this might be a dumb question but I am new to haskell :)  Can anything that can be done in languages such as Java,C++, and C be done in Haskell?
20:27:10 <dmj`> Kron: In the real world you have large code bases that interact w/ many api's and need to handle concurrency well. I know people who work at python-based companies that have 4 levels of testing before they release into prod and bugs *still* get in. Reassuring them that their string handling is faster than haskell doesn't help :)
20:27:18 <haasn> I love IncoherentInstances. It's my favorite language extension
20:27:21 <Cale> Galactic: Pretty much
20:27:33 <Cale> Galactic: Haskell doesn't run on the JVM of course
20:27:38 <haasn> Cale: (yet)
20:27:42 <Kingpatzer> Galactic not a dumb question at all -- the answer is that we think so because we think htat the Turing-Church hypothesis is true ... but no one can prove it
20:28:06 <Kron> dmj`: while that's true, I think it's important to just acknowledge it and not try to dismiss criticism
20:28:08 <luite> hm, the JVM isn't particularly well suited for running Haskell
20:28:13 <nisstyre> Cale: Frege kind of
20:28:17 <Kron> I used to primarily program in lisp, now I program in haskell
20:28:35 <Cale> mvr_: Maybe try not using overlapping instances?
20:28:38 <Kron> I understand my code is slow, I accept it, but it's worth it. It was worth it for the expressive power, it's worth it for the security, for the maintainability
20:28:48 <triliyn> Galactic: more seriously, haskell can bind to C libraries for things like OpenGL and is fairly powerful on its own
20:28:53 <haasn> I think it's important to distinguish between “can I theoretically implement the same algorithms in these turing complete languages X” and “can I accomplish the same things in these languages”
20:28:57 <dmj`> Kron: I'm not, I'm being realistic. I'm acknowledging haskell strings are slow, as does real world haskell if you read it, and there are better alternatives
20:29:05 <Galactic> I see
20:29:31 <Cale> String is slow, but often you don't care
20:29:58 <Kingpatzer> String might be slow - but it's still faster than I can read the IO, so who cares :)
20:29:59 <Cale> (and there are other sorts of things to use in the cases where performance is important)
20:30:00 <haasn> Galactic: this is not strictly related to language capabilities but rather to implementations; there exist C implementations for platforms to which no Haskell compiler exists (yet) - such as many flavors of embedded microchips
20:30:22 <Kingpatzer> haasn that's a very good point
20:30:26 <haasn> Galactic: so you would probably not be able to replace the entire set of C software by exclusively Haskell reimplementations
20:30:36 <Cale> Yeah, if you wanted to use Haskell for embedded stuff, you're more likely to use it as a metalanguage
20:30:45 <triliyn> Haskell is available on many more platforms than you might think though
20:30:49 <Cale> (and that approach has worked pretty well in some cases)
20:30:56 <triliyn> People have gotten ghc working on raspberry pi and android
20:30:58 <haasn> triliyn: via JavaScript, surely ;)
20:30:58 <Kingpatzer> So, Galactic, the point is that your target environment is also a consideration
20:31:14 <haasn> triliyn: ah, yeah; raspberry pi and android are still relatively common microarchitectures aren't they?
20:31:19 <haasn> I think both are ARM based?
20:31:21 <Cale> mvr_: What are you trying to do? Can we see your code?
20:31:24 <mvr_> Cale: I'm trying to convince to convince haskell that Chain is a Group and a LeftModule f, but Group requires Chain to also be a LeftModule Integer
20:31:27 <Kingpatzer> I just got my first Rasberry Pi today ... i might even get it booted up later if I'm not too fried trying to get Leksah to install
20:31:31 <triliyn> haasn: that's my impression, yeah
20:31:41 <mvr_> Cale: So I figure there's no way to avoid some sort of overlapping instances
20:31:43 <Kingpatzer> Pi is ARM
20:31:54 <mvr_> Cale: I'm just confused by why the first few overlaps are ok but the last isn't
20:31:55 <haasn> ARM is a tier-2 target platform for GHC
20:32:15 <Cale> mvr_: What's this LeftModule f (Chain f b) instance? That seems like it'll overlap pretty severely.
20:32:29 <haasn> which means it should generally work, but no guarantees are given; and things (like dynamic linking and interactive usage) may not be present
20:32:42 <Kingpatzer> why oh why is leksah unable to install on Arch . . . damn you AUR maintainers ....
20:32:43 <haasn> and it also won't delay a release if it doesn't work at launch
20:33:00 <mvr_> Cale: oh, sorry, I mean (Field f) =>
20:33:29 <Cale> mvr_: Those constraints don't matter when resolving which instance to select
20:33:53 <Cale> mvr_: (they're only checked after committing to a particular instance)
20:34:24 <mvr_> Cale: hmm ok
20:34:40 <Cale> There's a reason for that: you can always introduce new instances in future modules, so it could result in inconsistent behaviour if an instance was selected on the basis of some other instance not existing.
20:35:27 <Cale> mvr_: Can you get by without the LeftModule f (Chain f b) instance?
20:35:31 <mvr_> My goal here is to just be able to use f .* c and have it pick out the LeftModule instance that I want
20:35:35 <Cale> (and does it work without?)
20:36:00 <mvr_> I thought the 'algebra' package would be a sensible framework to build this stuff in, as it has all the algebraic structures all well laid out
20:36:15 <Cale> Can I see your code?
20:36:21 <dmj`> cabal install -j where have you been my whole life
20:36:29 <mvr_> which bits?
20:36:39 <Kingpatzer> ok - so I'm tired of fighting with Leksah -- what are people using for their environment on unixen? am I stuck with VI and Emacs?
20:36:41 <Cale> Enough to compile and get this error
20:37:02 <gamegoblin> Kingpatzer: yeah I pretty much just use vim :-/
20:37:04 <Zekka> Kingpatzer - I couldn't get it to build and run properly, but I think a lot of Haskellers are Yi fans.
20:37:20 <Zekka> that might be a little exotic for your taste, I'm not sure
20:37:30 <dmj`> Kingpatzer: emacs works really well
20:37:34 <mvr_> Cale: give me a sec
20:37:37 <dmj`> Kingpatzer: are you on osx?
20:37:40 * hackagebot purescript 0.4.7 - PureScript Programming Language Compiler  http://hackage.haskell.org/package/purescript-0.4.7 (PhilFreeman)
20:37:42 <mvr_> I'll try and boil it down
20:37:44 <Kingpatzer> Arch Linux...
20:37:55 <Kingpatzer> I'm just too old to learn any more damn keychords :)
20:38:02 <Cale> mvr_: Oh, also, {-# LANGUAGE NoMonomorphismRestriction #-}
20:38:06 <Cale> mvr_: Try that
20:38:31 <Cale> If reduced doesn't have a type signature, then the definition given there will have the MR apply to it
20:38:43 <dmj`> KingPatzer: if you use pacman to install emacs24 there is a package-manager in emacs that will allow you to install haskell-mode. I recommend installing the emacs-starter-kit too, default emacs is a little rough
20:39:23 <mvr_> didn't make a difference
20:39:57 <Kingpatzer> i'll give it a run I guess. I just find the emacs mode documentation generally lacking, and I don't speak lisp . . . I hate having to learn another language just to be able to turn on syntax highlighting
20:40:17 <haasn> Kingpatzer: I believe the majority uses emacs and the majority of the rest uses vim
20:40:28 <Kingpatzer> that's what I figured
20:40:44 <Cale> Kingpatzer: Any text editor which can convert tabs to spaces (and maybe do a little syntax highlighting) should do
20:40:46 <haasn> Kingpatzer: you can use the yi editor, which is written in Haskell
20:41:04 <Cale> Kingpatzer: You could even use gedit if it suits you
20:41:05 <haasn> Kingpatzer: it's also scriptable like xmonad (again, in Haskell); and it comes with vim and emacs emulation modes out of the box
20:41:15 <Kingpatzer> I'll take a look at it
20:41:26 <Cale> (just make sure to turn on the option which converts tabs to spaces)
20:41:34 <Kingpatzer> was hoping for a full blown IDE, but I'll take scriptable in a language I know :)
20:41:45 <haasn> Kingpatzer: what do you expect from a full-blown IDE?
20:41:54 <Cale> Generally, running GHCi alongside whatever texteditor you like is pretty decent
20:42:07 <Cale> You can tap :r in ghci whenever you save your file and have it loaded
20:42:15 <Cale> and then try out expressions interactively
20:42:28 <haasn> both vim and emacs come with a handful of great Haskell integration tools that can greatly assist your in-editor development
20:42:36 <haasn> it depends on what you want
20:42:55 <Kingpatzer> auto compleition, hoogle searching, live typechecking, hints, jumping to definitions, import cleanup, refactoring . ..
20:43:01 <Kingpatzer> auto formating
20:43:02 <haasn> I personally don't use any of them, though, opting for a traditional text editor+GHCi approach like Cale described; though I'm not convinced it's ideal. I just haven't gotten round to learning anything more powerful
20:43:04 <Kingpatzer> that sort fo thing
20:43:09 <Cale> I tend to use vim, but I don't really use many of its features
20:43:21 <dmj`> KingPatzer: you could try fpcomplete's offering it's actually really good. Don't think it has ghci support yet tho.
20:43:47 <Kingpatzer> it doesn't. that's why I'm trying to install Leksah. the difference between coding Java and Haskell on Eclipse is noticable
20:44:29 <Cale> I have half-joking/half-serious opinion that learning advanced text editor features wastes more time than it saves.
20:45:00 <Kingpatzer> honestly -- i probably should just suck it up and learn to use either vim or emacs properly .. but I kind of agree with Cale -- i just want it to not interrupt my workflow more than anything
20:45:07 <dmj`> Cale: could the same be said of learning an advanced programming language? :P
20:45:17 <Kingpatzer> dmj` ROFL!
20:45:18 <haasn> I used to be solely reliant on Visual Studio's C#.NET integration and debugging; but the more I used Haskell the more I realized I don't actually need it as much as I thought I did
20:45:19 <Cale> Especially in Haskell, where usually you end up spending a tiny fraction of your time actually entering program text
20:45:49 <mvr_> Cale: my only access to haskell at the moment is fpcomplete and it's taking a million years to build 'algebra', sorry
20:45:58 <Kingpatzer> Cale & haasn I get what you're saying -- but I still don't know the library types well enough to not find myself going and looking stuff up every 3 lines of code
20:46:00 <Cale> For languages with really verbose syntax, I can see it being more useful
20:46:01 <dmj`> haasn: I used to as well. Just keep hitting tab and VS writes all the code for you
20:46:15 <Kingpatzer> so an IDE that gives me type info would bereally useful to me
20:46:29 <dmj`> haskell is more about thinking than typing anyway
20:46:32 <Kingpatzer> * be really not bereally
20:46:51 <heatsink> dmj`: I hear that Idris does that too
20:47:10 <Cale> Kingpatzer: well, ghci can do that
20:47:17 <Cale> :t foo
20:47:18 <lambdabot>     Not in scope: `foo'
20:47:19 <lambdabot>     Perhaps you meant `T.for' (imported from Data.Traversable)
20:47:20 <Kingpatzer> while I think C# is kind of a crap language, VS is really nice :)
20:47:22 <dmj`> heatsink: writes code for you? now that's a programming language I want, one that has to learn me
20:47:27 <Cale> :t for -- :)
20:47:27 <lambdabot>     Not in scope: `for'
20:47:28 <lambdabot>     Perhaps you meant one of these:
20:47:28 <lambdabot>       `T.for' (imported from Data.Traversable),
20:47:34 <Cale> :t T.for
20:47:34 <lambdabot> (Applicative f, Traversable t) => t a -> (a -> f b) -> f (t b)
20:47:36 <Kingpatzer> Cale yeah - but that' not _IN_ the editor, which is what I find frustrating
20:47:37 <Cale> FINE
20:47:43 <bitemyapp> Kingpatzer: lots of refugees moving from C# to F#. Yet another half-step that doesn't really get anywhere all that desirable.
20:47:56 <Cale> Kingpatzer: You're not on a text-only terminal are you? :)
20:48:00 <heatsink> dmj`: All you have to do is give your function a type that admits only the correct implementation :)
20:48:06 <bitemyapp> Kingpatzer: but yeah, VS is nifty. I'm an Emacs user, so I just don't care that much.
20:48:08 <Cale> Kingpatzer: You can just have two windows side by side :)
20:48:19 <dolio> You can even do that in a text-only terminal.
20:48:35 <Cale> dolio: Indeed
20:48:48 <Kingpatzer> well, if I'm using VIM -- then yeah, I'm generally full screen in VI ...
20:49:01 <Kingpatzer> so having to come out to go look things up kind of sucks
20:49:03 <dolio> Full screen?
20:49:09 <haasn> Kingpatzer: I believe it's all a trade-off; giving up code completion teaches you the value of writing concise code; giving up type checking teaches you the value of understanding what is going on in the type level by yourself; giving up search-by-function teaches you the value of a good module layout, etc.
20:49:13 <Kingpatzer> xmonad and a small montior
20:49:13 <dolio> Do you have it split like three times or something?
20:49:20 <gamegoblin> Best way to match the regex [0-9]{0,3} in attoparsec?
20:49:32 <haasn> Kingpatzer: if there's one thing I can recommend every programmer does, it's pick up a second monitor :)
20:49:38 <S11001001> bitemyapp: evolutionary morality.  Like typed clojure :)
20:49:43 <Kingpatzer> haasn I get it, but I'm pushing 50 -- i am willing to admit I won't know everything before I die
20:49:50 <Cale> Kingpatzer: I generally always have at least two windows open: at least one for the code and one for ghci. Usually also a web browser for haddock documentation.
20:49:57 <dmj`> heatsink: awww I see webServer :: Request -> IO Response.. go!
20:50:02 <bitemyapp> S11001001: I hated core.typed
20:50:08 <bitemyapp> S11001001: so tedious.
20:50:18 <heatsink> dmj`: webServer _ = fail ""
20:50:26 <dmj`> haha :)
20:50:28 <bitemyapp> S11001001: unbelievable to me that people would put up with core.typed and not Haskell. Positively obscene.
20:50:36 <bitemyapp> heatsink: must be a Rails app.
20:50:43 <heatsink> heh
20:51:10 <dacali> bitemyapp: Isn't the benefits of Clojure+core.typed the availability of Java libraries though?
20:51:21 <Kingpatzer> Cale -- again -- that's why i'm trying to solve my IDE quest. With Eclipse I can get everything I want for Java, but Haskell it doesn't integrate with ghci.  but it sounds like iether I learn emacs or deal with it
20:51:38 <dolio> There's EclipseFP.
20:51:46 <Kingpatzer> basically the ide just takes the place of having 3 windows open :)
20:52:08 <S11001001> bitemyapp: haskell is less practilol
20:52:09 <Kingpatzer> dolio EclipseFP doesn't integrate into ghci -- or at least I don't know how to make it do so
20:52:19 <Cale> Kingpatzer: I say try just keeping ghci running so that you can ask it for types as you go
20:52:19 <dolio> I've never used it. I just know it exists.
20:52:25 <dolio> And some people like it.
20:52:27 <bitemyapp> S11001001: *eye roll*
20:52:44 <mvr_> Cale: http://lpaste.net/101435 give this a go
20:52:46 <bitemyapp> S11001001: the trajectory of Clojure tells me any differences can be closed, with an overall win for just using a freakin' typed ecosystem.
20:52:58 <dmj`> Kingpatzer: in emacs I have snippets for all imports and functions, so typing dbs writes import qualified Data.ByteString as B, etc. You can be pretty fast.
20:53:33 <Kingpatzer> dmj` gives another vote for "suck it up and learn to use a real editor :)
20:53:57 <haasn> FSVO “real”
20:54:24 <haasn> leksah is certainly a real editor, in a sense; and you are free to use it
20:54:35 <haasn> don't let the popular opinion dictate your desires
20:54:37 <dmj`> it's worth it, when you bust out emacs at starbucks people think you're a wizard, just sayin'
20:54:39 <Cale> mvr_: Which instance should it select when f = Integer?
20:55:08 <Kingpatzer> see -- impressing the average Starbucks patron never really made my "top 10" list of things to do before I die :)
20:55:29 <mvr_> Cale: so is my problem that () is more specific than my f instance, so haskell wants to pick that one?
20:55:44 <mvr_> Cale: do you see what I'd like to be able to do? is there a proper way of doing it?
20:55:47 <Cale> mvr_: The problem is that your f one overlaps with pretty much everything
20:55:54 <Kingpatzer> haasn the problem is that I can't get it to go on Arch. the distro is borked beyond my ability to fix it :)
20:56:11 <Cale> You might make a newtype to select the instance
20:56:15 <Kingpatzer> so time to brush up the emacs foo :)
20:56:22 <haasn> Kingpatzer: (warning: opinion ahead) then perhaps the solution is not to switch to a different text editor but to switch to a different distro? :)
20:56:28 <mvr_> Cale: Integer is not a field, so it would have to pick the Integer instance
20:57:04 <Kron> I love my emacs
20:57:28 <Kingpatzer> haasn all distros have their problems. all in all i happen to like more about arch than I dislike about it. ANd since I don't have any economic interest in my haskell programming, it's pure hobby, I'll keep struggling on
20:57:30 <Kron> there's a very "this is my rifle, there are many like it but this one's mine" feel to getting into emacs
20:57:31 <mvr_> Cale: is there something to the fact that my instance ONLY works when f is the same as the f in Chain f b?
20:57:42 <dmj`> Kingpatzer: haha, it's overrated anyways :P but sbux is where I learned emacs, using the built-in tutorial and this video: https://peepcode.com/products/meet-emacs
20:57:46 <Kron> it's sort of awkard to use at first but after a few years and a custom .emacs it becomes your dearest friend
20:58:43 <__pyon__> Does haddock support commenting instances?
20:59:01 <Kron> if you export them, then yes I think so?
20:59:24 <Cale> mvr_: No, remember, it doesn't see the constraints when selecting instances
20:59:24 <colDrMcBeardman> is there a way I can have cabal always pass arguments to my benchmark program?
20:59:32 <__pyon__> Kron: I mean, adding my own comments to instances, not just stating that an instance exist.
20:59:34 <__pyon__> exists*
20:59:46 <Cale> mvr_: It doesn't know that Integer isn't an instance of Field, and it can't know this because a future module might always come along and make it one
20:59:55 <Kron> I... I can't see why not, I suppose. Try it? -- | and all that
21:00:09 <colDrMcBeardman> I want to avoid passing --benchmark-options="-o report.html" on the command-line to cabal.
21:00:28 <Cale> mvr_: So it can't select one instance and not the other on the basis that there's no instance of Field for Integer
21:01:20 <mvr_> Cale: I see. so should I abandon this approach and just define my own .*?
21:01:26 <Cale> Possibly!
21:01:34 <mvr_> Cale: seems like a shame
21:01:36 <Cale> I don't have enough of your code to know
21:01:42 <Cale> You could also define a newtype
21:01:46 <Cale> Most likely
21:02:06 <mvr_> Cale: how do you mean?
21:02:28 <Cale> Let me try
21:04:36 <Cale> http://lpaste.net/101436
21:05:00 <Kingpatzer> thank dmj` I'll check out hte video
21:05:41 <Cale> mvr_: It's just a type-level tag to help select which instance you want.
21:05:56 <dmj`> Kingpatzer: no problem! happy emacsing
21:06:29 <dmj`> cabal sandbox hc-pkg unregister scotty --force ====> "cabal: unrecognized option `--force'"
21:06:38 <dmj`> why does this happen?
21:07:50 * hackagebot folds 0.5.0.1 - Beautiful Folding  http://hackage.haskell.org/package/folds-0.5.0.1 (EdwardKmett)
21:07:58 <Cale> mvr_: You'll see that trick also gets used in Data.Monoid with the Any/All/Sum/Product/First/Last types
21:08:32 <geekosaur> dmj`: because people expect broken by design gnu option semantics where the options can appear anywhere, so you need magic to force them through to the other command
21:08:42 <Cale> > getSum . mconcat . map Sum $ [1..10]
21:08:43 <lambdabot>  55
21:08:50 <Cale> > getProduct . mconcat . map Product $ [1..10]
21:08:51 <lambdabot>  3628800
21:09:19 <geekosaur> you may be able to stick a -- in there somewhere to make cabal not parse a following option but pass it through
21:09:42 <dmj`> geekosaur: I have need magic, I tried interspersing the "--force" throughout no luck
21:10:02 * geekosaur senses that what he said made no impact
21:10:15 <geekosaur> so I guess i leave it to someone who can say it better
21:11:13 <dmj`> geekosaur: stick a "--" in there somewhere, ok
21:11:41 <geekosaur> what I don't know is exactly where it needs to go to not break other parts of parameter parsing. I'd try before hc-pkg first
21:12:26 <dmj`> ghc-pkg can't be used though
21:12:52 <geekosaur> I suspect it could with an explicit package database parameter
21:16:04 <Cale> mvr_: Does that help?
21:19:23 <SrPx> "Why use OCAML and why now" (on Reddit) *clicks* *long article* *conclusion* "Because it compiles to JS better" ah cmon
21:20:48 <SrPx> You know something I'd pay a few hundred dollars without complaints? That! Do we have some kind of collaborating founding for development, by the way?
21:20:50 <__pyon__> Is there a class for stuff that always returns a single result, no matter what other effects it has? (Basically, Identity, IO and ST s.)
21:21:19 <jle`> __pyon__: a single result?
21:21:29 <jle`> what would be something that doesn't return a single result?
21:21:33 <haasn> __pyon__: Monad
21:22:05 <__pyon__> jle`: Maybe and Either e (possibly zero), [] (any number), etc.
21:22:08 <shachaf> What do you want to do with that fact?
21:22:19 <haasn> Maybe returns a single result, but may have the side effect of deleting the universe
21:22:24 <__pyon__> shachaf: Know that something is processed in a single-threaded manner.
21:22:38 <jle`> __pyon__: (Either e) and Maybe are sort of identical i think in this sense
21:22:51 * hackagebot scotty-tls 0.3.0.0 - TLS for Scotty  http://hackage.haskell.org/package/scotty-tls-0.3.0.0 (DavidJohnson)
21:22:59 <shachaf> Uh oh. Why do you want that?
21:23:05 <shachaf> (Or: what does that mean?)
21:24:45 <jle`> oh, so things that don't return nothing possibly
21:25:07 <__pyon__> shachaf: I am making a class for streams that can be rewinded to a previous position, but, when they are rewinded, they shall not forget the elements it backtracks. Furthermore, you can append new elements, always at the end of the stream (not necessarily after the current position).
21:25:27 <__pyon__> the elements they* backtrack*
21:26:21 <__pyon__> So, if I read elements e1,e2,e3,e4,e5, and then rewind to the position before element e3, the next element that shall be read is nevertheless e6, not e4.
21:27:09 <dmj`> __pyon__: are you using forkIO?
21:27:19 <__pyon__> dmj`: No.
21:27:38 <heatsink> Does backtracking to X forget what has been appended since X was processed?
21:28:20 <__pyon__> heatsink: No.
21:28:27 <__pyon__> heatsink: That is precisely the point.
21:29:35 <__pyon__> http://lpaste.net/101386 -- I hope this paste makes things less confusing
21:29:45 <jle`> sounds like...something that is not a MonadPlus
21:29:54 <jle`> for a generalized MonadPlus
21:30:02 <jle`> that includes Either somehow
21:30:06 <__pyon__> Definitely not a MonadPlus.
21:30:14 <jle`> it could be the antithesis
21:30:20 <jle`> there cannot exist an mzero such that
21:30:24 <jle`> mzero >>= f = mzero
21:30:34 <jle`> for all f
21:30:48 <__pyon__> There cannot exist mzero because mzero basically fails to produce a result.
21:30:57 <jle`> yeah, that is what i mean
21:31:23 <jle`> monads that do not have a value mzero s.t. forall f mzero >>= f = mzero
21:31:40 <jle`> is that a sufficient requirement?
21:31:51 <__pyon__> Mmm...
21:32:11 <jle`> i guess that means that (>>=) must be...bijective, in some sense?
21:32:32 <gamegoblin> oi mates. Best way to implement this regex in attoparsec: [0-9]{0,3}
21:32:34 <jle`> or at least an injection
21:32:50 <__pyon__> In what sense?
21:33:25 <Kron> ooooh cuts
21:33:32 <Kron> __pyon__: is this some sort of logic programming thing?
21:33:51 <__pyon__> Kron: "cut" is like in logic programming, yes.
21:34:11 <jle`> __pyon__: in that x >>= f must be different for every f
21:34:12 <__pyon__> Kron: Basically, "cut" forgets a stream's past, so you cannot backtrack before the current position.
21:34:29 <jle`> x >>= f must map each f to a unique x >>= f
21:34:33 <Kron> ok
21:34:49 <__pyon__> jle`: Ah.
21:35:03 <jle`> maybe that is stronger than what you want
21:35:17 <jle`> that depends on if f is injective
21:35:20 <__pyon__> Basically, if I pass a stream to a function that produces a new stream, the old stream must be considered not to exist anymore.
21:36:03 <__pyon__> Anyway, I guess I should make my life simple and just provide two methods, extract and extractIO. :-P
21:36:31 <__pyon__> But it looks somewhat clunky.
21:36:45 <__pyon__> @hoogle MonadIO
21:36:46 <lambdabot> Network.CGI class Monad m => MonadIO (m :: * -> *)
21:36:47 <lambdabot> Control.Monad.IO.Class class Monad m => MonadIO m
21:36:47 <lambdabot> package monadIO
21:52:14 <dmj`> geekosaur: https://github.com/haskell/cabal/issues/1200
21:52:23 <dmj`> don't think unregister exists for sandboxes
21:52:58 <gamegoblin> in attoparsec, I want to do takeWhile, but I want to say something like "takeWhile condition, but only up to n bytes"
21:53:00 <gamegoblin> how do?
21:53:56 <nisstyre> gamegoblin: not sure if you can easily do that, you might have to write something a bit lower level
21:54:02 <nisstyre> but it's been a while since I used attoparsec
21:54:57 <gamegoblin> something akin to the regex syntax {m,n} is what I'm looking for
21:55:08 <gamegoblin> really just {n}, but {m,n} would be nice
21:55:14 <nisstyre> attoparsec is meant to be simpler than regular parsec
21:55:20 <nisstyre> so it lacks some of the more convenient things
21:55:24 <gamegoblin> I don't even know how I'd do it in regular parsec
21:55:25 <nisstyre> in the name of efficiency
21:57:34 <pavonia> {n} should be "replicateM n" in parsec
21:58:13 <gamegoblin> ah sorry I meant {0,n}
21:58:26 <gamegoblin> {,n}
21:58:35 <gamegoblin> Or whichever regex flavor you prefer ;)
21:58:50 <nisstyre> gamegoblin: so between 0 and n repetitions
21:58:53 <nisstyre> right?
21:58:56 <gamegoblin> yes
21:59:03 <gamegoblin> or more generally between m and n
21:59:08 <nisstyre> yeah, not sure what the best way is
21:59:14 <gamegoblin> I'm rolling my own now, calling it satisfyMN
21:59:20 <gamegoblin> will update in 5 minutes or so
21:59:21 <nisstyre> fair enough
21:59:32 <pavonia> I think someone asked the same question a while ago and the answer was along the lines of "write your own function"
22:00:03 <gamegoblin> heh
22:02:04 <AaronFriel> I am implementing a library which makes FFI calls, but I want to make the library "exception free" to consumers. That is, they do not need to worry about async exceptions from my code (or should not need to worry). When I read the documentation on "catching all exceptions", the advice is that this is usually not what people want.
22:02:29 <AaronFriel> Is there a good argument in my use case for *not* catching exceptions inside my library?
22:02:34 <dmj`> geekosaur: no nevermind, it does exist
22:04:54 <AaronFriel> As an example, a "connect" call will either succeed in connecting to a database, fail to connect, *or*, because I don't know what exceptions FFI calls can throw, it could possibly do that. Either way, I want to return a connection in an open or a closed state. Because really, it'll either work... or it won't.
22:05:45 <AaronFriel> So, any reason I shouldn't to a `catch` (\(_ :: SomeException) -> return $ Left SomeFailureCode) or equivalent on it?
22:07:02 <gamegoblin> Here was my solution to the {m,n} thing, comments appreciated: http://lpaste.net/101443
22:07:32 <gamegoblin> so it will fail if m > 0 and the satisfy fails
22:09:20 <c_wraith> AaronFriel: among other things, by doing that you catch the exception the RTS uses to kill one thread from another.
22:09:36 <nisstyre> gamegoblin: seems okay, you might use the `maybe` function instead of an explicit case, or that might be less readable
22:09:38 <nisstyre> who knows
22:09:41 <c_wraith> AaronFriel: I don't think you mean that during those calls, the thread should be unkillable
22:09:43 <Javran> @pl f g x = (x, g x)
22:09:43 <lambdabot> f = ap (,)
22:10:07 <AaronFriel> Well, since they work with foreign function code, I don't think they can be interrupted anyway
22:10:20 <c_wraith> They do if you mark the functions safe.
22:10:25 <c_wraith> And you'd better be marking them safe
22:10:25 <Javran> @pl f g h x = (g x, h x)
22:10:26 <lambdabot> f = liftM2 (,)
22:10:37 <c_wraith> Unless you know *exactly* what marking them as unsafe does.
22:10:59 <jle`> Javran: bimap
22:11:04 <jle`> from bifunctor
22:11:14 <AaronFriel> I read the paper and a few articles on it, I think I've a pretty good idea of the unsafe part. Let's say for the sake of argument that I know that marking the majority (but not all) of the FFI calls unsafe is alright
22:11:28 <c_wraith> Well, you're probably wrong.
22:11:45 <c_wraith> A connect call, for instance, should never be marked unsafe.
22:11:48 <AaronFriel> I agree
22:12:00 <jle`> also (a -> b) -> (c, a) -> (c, b) is second from Control.Arrow and also Data.Bifunctor
22:12:15 <AaronFriel> But the majority of the calls will be of the form of "check if the foreign library has any data, if yes, return a value that it already has, if no, return immediately"
22:12:29 <AaronFriel> and it spends only microseconds in the FFI call
22:12:34 <Javran> jle`: thanks, I thought there's something I can use in arrow, but not sure which one
22:12:37 <jle`> :t second
22:12:38 <lambdabot> Arrow a => a b c -> a (d, b) (d, c)
22:12:54 <jle`> oh yeah you can also use (***)
22:12:57 <AaronFriel> So, let's move on from whether or not those calls should be unsafe - there are some that ought to be marked safe.
22:13:01 <AaronFriel> Including the connect call
22:13:04 <c_wraith> anyway..  Any safe FFI call, killthread *should* kill the haskell thread.  It won't interrupt native thread doing the API call, but that's a different matter
22:13:05 <Javran> :t (***)
22:13:06 <lambdabot> Arrow a => a b c -> a b' c' -> a (b, b') (c, c')
22:13:09 <jle`> > (*2) (***) (+2) $ (5,5)
22:13:10 <lambdabot>  Couldn't match expected type `(b0, c0)' with actual type `a0 -> a0'
22:13:15 <jle`> lol
22:13:15 <AaronFriel> What exceptions should I catch on that call?
22:13:18 <c_wraith> *the* native thread
22:13:20 <jle`> > (*2) *** (+2) $ (5,5)
22:13:21 <lambdabot>  (10,7)
22:13:44 <AaronFriel> Well, a native thread on -threaded
22:13:49 <Javran> jle`: but is there a "f x = (x,x)"?
22:14:03 <AaronFriel> But I understand the idea - the connect call in particular is something I want to program defensively around, but do so correctly
22:14:09 <jle`> > let f = join (,) in f 1
22:14:10 <lambdabot>  (1,1)
22:14:25 <AaronFriel> So - an interesting question is for example, what sort of Bad Things Can Happen in an FFI call?
22:14:37 <AaronFriel> if I make a safe call, are there any exceptions worth catching?
22:14:38 <Javran> jle`: cool, thanks!
22:14:49 <AaronFriel> Or should I assume all exceptions are fatal? Or do FFI calls never throw?
22:14:50 <c_wraith> AaronFriel: as far as I know, the *only* exception that can happen during an FFI call is an async exception.
22:15:12 <jle`> Javran: also join bipure in Data.Bifunctor
22:15:21 <jle`> to draw the analogy further
22:15:32 <jle`> er sory, Biapplicative
22:15:55 <jle`> Data.Bifunctor generalizes to all 2-tuple-like things
22:15:57 <jle`> (like Either)
22:16:07 <jle`> Control.Arrow generalizes to all (a -> b)-like things
22:16:17 <c_wraith> AaronFriel: Native code doesn't know about haskell's exception system.
22:16:38 <jle`> :t Data.Bifunctor.first
22:16:38 <lambdabot> Bifunctor p => (a -> b) -> p a c -> p b c
22:16:41 <AaronFriel> Okay.
22:16:44 <jle`> :t Control.Arrow.first
22:16:45 <lambdabot> Arrow a => a b c -> a (b, d) (c, d)
22:16:57 <AaronFriel> I know that, but I just don't know enough about the interface.
22:16:58 <jle`> put parentheses at the end of Bifunctor's first
22:17:14 <jle`> Bifunctor.first :: (a -> b) -> (p a c -> p b c)
22:17:19 <AaronFriel> Is there anywhere that this is documented? That FFI calls can only throw "Foo" and this or that can only throw "Bar"?
22:17:46 <Javran> jle`: not related, but I also heard of "Choice" when I came across free monad's document, is that something close?
22:17:47 <c_wraith> well, any exception can be delivered async, so there's no type limitations.
22:17:54 <jle`> Arrow.first :: (a `r` b) -> ((a, c) `r` (b, c))
22:18:10 <c_wraith> The important part is that the exception comes from other threads of haskell code, rather than from the FFI call
22:18:12 <AaronFriel> Okay, but I really shouldn't concern myself with catching things that are thrown *to* my thread, those are likely done by another Haskell user
22:18:31 <AaronFriel> And if the consuming library wants to throw exceptions to the thread while I'm doing stuff, that's they're responsibility
22:18:37 <AaronFriel> their'
22:19:02 <AaronFriel> I just wanted to make sure that there's no, uhm, obvious things I should do with an FFI call to cover my bases.
22:19:32 <c_wraith> There are a few "obvious" things.
22:20:12 <Javran> jle`: this one: http://hackage.haskell.org/package/free-4.5/docs/Control-Monad-Free.html#v:_Free I can only decipher the type signature by replacing "Choice" with "->"
22:20:22 <c_wraith> The most important is to make sure you that if you have to allocate a buffer to make the native call, the buffer is cleaned up regardless of whether there's an exception.
22:20:36 <c_wraith> Otherwise you will have written a memory leak!
22:20:59 <c_wraith> bracket is designed for exactly that purpose.
22:21:38 <AaronFriel> Yes, I am extensively using ResourceT and writing my allocations in terms of resources. (I've also fuzz tested it a bit to make sure it releases these resources under a variety of exceptional conditions)
22:21:55 <c_wraith> Javran: that's a lens-style Prism.  Don't worry about the exact type signature.
22:22:37 <c_wraith> Javran: the docs contain an alternate signature that's much easier to understand - just not how it's actually displayed by haddock.
22:23:47 <Javran> did you mean:  _Free :: Prism' (Free f a) (f (Free f a)) ?
22:24:08 <c_wraith> yeah, that's what you should think of the type as being.
22:24:15 <c_wraith> Prism' is just a type alias for that giant mess
22:24:31 <Javran> c_wraith: I see, thanks!
22:38:46 <jle`> Javran: i feel like choice seems to match, with Either a b instead of (a,b)
22:39:38 <jle`> choice has more powers though
22:39:54 <jle`> becuase it's a profunctor as well
22:42:29 <triliyn> The equations given for traverseOf in lens are kind of silly
22:42:53 <triliyn> traverseOf = id; traverse = traverseOf traverse
22:43:22 <jle`> kind incompatibility when matching types: a0 :: *, ByteArray :: *
22:43:27 <jle`> haskell is so silly
22:43:38 <triliyn> "We can define traverse in terms of itself by using the identity function"
22:43:51 <jle`> oh, it's ByteArray# :: #
22:44:01 <jle`> never seen # in a kind before
22:44:18 <jle`> i thought all kinds used * and (->) and Constraint
22:44:28 <triliyn> # is for unboxed types
22:44:41 <jle`> unboxed types are of a special kind?
22:44:53 <triliyn> Yeah
22:45:03 <jle`> that's neat
22:45:10 <triliyn> I guess they're treated differently because the RTS doesn't have pointers for them
22:45:19 <jle`> that makes sense
22:45:25 <jle`> but that feels more like an implementation detail
22:45:32 <jle`> then a statement about type theory
22:45:38 <pavonia> Is it possible to get a gtk2hs widget by its name?
22:45:43 <triliyn> Unboxed types are themselves an implementation detail, aren't they?
22:46:02 <jle`> triliyn: i would have expected them to be treated like any other type
22:46:16 <jle`> kind of like a typeclass
22:46:39 <triliyn> Well, you don't want to be able to have lists of unboxed things, for example
22:46:48 <triliyn> Because you'd need some kind of special case to handle it... I think
22:47:05 <jle`> you can't have a list of unboxed things?
22:47:07 <triliyn> Or maybe the # kind exists for a completely different reason
22:47:16 <triliyn> I don't think so
22:47:45 <jle`> what does * represent for kinds, anyway?
22:47:49 <triliyn> They're stored in registers and ghc implements constructor arguments with pointers
22:49:04 <triliyn> * is basically "any fully applied type constructor" or "any type that can be inhabited" (except there are exceptions)
22:53:21 <__pyon__> Is it possible to have kind-polymorphic type classes?
22:53:34 <theguruofreason> is anyone here familiar with the SDL bindings?
22:53:45 <kadoban> __pyon__: I don't think so?
22:53:50 <__pyon__> Aw. :-(
22:54:24 <kadoban> It's possible I'm wrong though, I'm barely beyond a beginner still
22:55:20 <triliyn> __pyon__: there is probably an extension for it and I think it will be included in a future (possibly the next?) version of ghc
22:55:52 <triliyn> Or maybe there isn't currently an extension
22:56:01 <triliyn> I'm pretty sure I heard something about a future version of ghc though
22:57:43 <mgsloan> Yeah, 7.4 and up have the PolyKinds extension:  https://www.haskell.org/ghc/docs/7.4.1/html/users_guide/kind-polymorphism-and-promotion.html#kind-polymorphism
22:57:52 <mgsloan> 7.8 will have polykinded Typeable, which is neat
23:43:02 * hackagebot eternal 0.0.2 - everything breaking the Fairbairn threshold  http://hackage.haskell.org/package/eternal-0.0.2 (Heather)
23:50:58 <NathanC> Hello! I'm trying to figure out how to render an OpenGL texture to a gtk3 drawing area
23:51:41 <NathanC> Does anyone know how I might go about doing this?
23:52:55 <pavonia> NathanC: Is there a special problem with gtk3 or is that a general question?
23:53:50 <pavonia> I mean gtk3 as opposed to gtk2
23:54:17 <NathanC> Well, I'm specifically trying to do it in gtk3
23:54:34 <NathanC> I believe the older gtk2 libary had Graphics.UI.Gtk.OpenGL.Drawable, but gtk3 doesn't
23:55:08 <NathanC> Ah, well, I just found the gtkglext library
23:55:12 <NathanC> would that be the way to approach it?
23:57:20 <pavonia> That's the package exporting that module
23:57:49 <pavonia> Uh, no, gtk3 is a different package
23:59:48 <NathanC> So how could I use it?
