00:00:22 <pavonia> You can't with gtk3
00:01:37 <NathanC> Hmm.
00:02:20 <NathanC> There's no way to render an OpenGL texture to a gtk3 window?
00:03:39 <pavonia> not with Haskell it seems
00:04:33 <jle`> so much of the Platform has yet to add Applicative instances to their Monads
00:05:15 <NathanC> Hmm, there's gotta be some way. I mean just basic rendering to a context shouldn't be too hard.
00:06:07 <NathanC> I mean, I'm sure it would be possible to use the gtk2 library to render a texture to a pixmap, and somehow serialize or convert the pixmap to a gtk3 one, but it'd be really slow
00:06:16 <pavonia> You could try to patch the gtkglext package to work with gtk3, but I guess it will fail if there were major API changes to Gtk+3
00:09:54 <pavonia> If a module doesn't export a type Foo but functions that use this type, it's still not in scope and I can't use it in my functions, is that correct?
00:10:49 * hackagebot scotty-tls 0.3.0.0 - TLS for Scotty  http://hackage.haskell.org/package/scotty-tls-0.3.0.0 (DavidJohnson)
00:10:49 * hackagebot eternal 0.0.2 - everything breaking the Fairbairn threshold  http://hackage.haskell.org/package/eternal-0.0.2 (Heather)
00:11:39 <kadoban> pavonia: is that even legal? usually the type is exported, but not the constructors
00:12:14 <pavonia> Apparently it is. I haven't seen this before, too
00:12:40 <triliyn> pavonia: I think you can use the functions as long as you have a way to produce the right arguments, but you can't mention the type in explicit signatures
00:13:39 <pavonia> Hhm
00:14:27 <kadoban> that's a pretty odd state of affairs...is there some actual reason to do that, or is it a mistake?
00:15:08 <NathanC> pavonia: just letting you know, after looking it up a bit, it looks like there's issues with using openGL and gtk3 in general, not just in haskell.
00:15:21 <pavonia> oh
00:15:42 <pavonia> kadoban: I can't tell, gtk is doing it
00:16:10 <Javran> is that a good practice to use lens? I find it handy but I haven't seen much libraries use that as a dependency
00:16:15 <triliyn> I can't think of a good reason to do it, but I haven't really tried
00:16:31 <triliyn> (the weird export thing, not lens)
00:16:35 <jle`> haha
00:16:56 <kadoban> hehe
00:17:02 <Eduard_Munteanu> Javran: lens has a lot of dependencies so it might be a bit scary
00:17:37 <pavonia> Strangely it's just a type synonym for another type that actually is exported :S
00:17:42 <pavonia> I'll use that instead ...
00:17:53 <enthropy> you might not export to stop people from using it in places
00:17:57 <Javran> Eduard_Munteanu: i see
00:17:57 <enthropy> say to write instances
00:18:09 <acomar> pavonia: maybe it's just a simple mistake then?
00:18:19 <pavonia> yeah
00:18:24 <kadoban> oooh, that sounds vaguely useful, enthropy
00:18:59 <Javran> I have lots of haskell libraries installed but to my surprise lens haven't been pulled in as a depenency
00:19:01 <enthropy> very vaguely
00:19:29 <jle`> lens seems to pop up randomly in my sandboxes somehow
00:30:46 * hackagebot definitive-base 1.0 - The base modules of the Definitive framework.  http://hackage.haskell.org/package/definitive-base-1.0 (MarcCoiffier)
00:40:31 <Javran> @hoogle [(a,b)] -> ([a],[b])
00:40:33 <lambdabot> Prelude unzip :: [(a, b)] -> ([a], [b])
00:40:33 <lambdabot> Data.List unzip :: [(a, b)] -> ([a], [b])
00:42:10 <siamsara> @src unzip
00:42:10 <lambdabot> unzip = foldr (\(a,b) ~(as,bs) -> (a:as,b:bs)) ([],[])
00:42:15 <siamsara> thought so
00:42:24 <jle`> wish there was a generic unzip for Traversable
00:42:46 <kadoban> what's that ~ in there?
00:42:52 <jle`> unzip :: Traversible t => t (a,b) -> (t a, t b)
00:42:56 <jle`> kadoban: it's a lazy pattern match
00:43:25 <jle`> it's sort of like using _ (it matches everything), and then splitting it later
00:43:35 <kadoban> huh, thanks, i didn't know that existed
00:43:41 <jle`> it doesn't have to check the contents to go down that path
00:43:45 <jle`> it goes down for everything
00:43:54 <jle`> insert crude joke
00:43:58 <kadoban> haha
01:15:48 <altschuler> If I have a State monad "wrapped" in an ErrorT (like "type TC a = ErrorT TypeError (State Environment) a"), I can use throwError in a function that returns TC (). But I can't use it in the same function if the throwError occurs in a "when" or "unless" and the type becomes TC TypeError instead of TC (). Can someone explain why?
01:20:14 <pavonia> altschuler: Do you have an example that fails?
01:20:53 <jle`> has anyone ever given thought to making a containers-like library that is implemented using mutable data structure but has a pure interface?
01:21:02 <jle`> so not in IO?
01:21:18 <jle`> either lots of unsafePerformIOs or ffi's to C implementations
01:21:22 <jle`> also randomized data structures too
01:22:41 <jle`> yeah that's the stuff
01:23:12 <altschuler> pavonia: Might be a little confusing code overall, but i pasted it here: http://lpaste.net/101448#line198
01:24:22 <Eduard_Munteanu> jle`: there's DiffArray that's like that
01:24:43 <pavonia> altschuler: And what is the error message?
01:24:44 <Eduard_Munteanu> But it's rather slow due to locking.
01:24:51 <jle`> Eduard_Munteanu: i see
01:25:02 <jle`> yeah i guess making things concurrency-aware would be tricky
01:25:09 <jle`> but
01:25:10 <altschuler> pavonia: Couldn't match type `TypeError' with `()'
01:25:10 <altschuler>     Expected type: ErrorT TypeError (State Environment) ()
01:25:10 <altschuler>       Actual type: TC TypeError
01:25:13 <altschuler>     In the second argument of `($)', namely
01:25:16 <altschuler>       `throwTE
01:25:18 <jle`> if they are treated as immutable data structures
01:25:31 <altschuler> pavonia: on line 198 that is :)
01:25:37 <jle`> hm
01:25:43 <jle`> maybe this is more useful for randomized data structures
01:25:44 <Eduard_Munteanu> jle`: also consider ST arrays and such
01:25:50 * hackagebot conduit-combinators 0.2.1 - Commonly used conduit functions, for both chunked and unchunked data  http://hackage.haskell.org/package/conduit-combinators-0.2.1 (MichaelSnoyman)
01:26:22 <pavonia> altschuler: So it's the other way around, "when" has m () as result type but you're returning m ErrorType instead
01:26:59 <pavonia> altschuler: Err, no
01:28:02 <pavonia> altschuler: Or actually yes :D
01:28:10 <pavonia> I'm tired
01:28:43 <pavonia> altschuler: try "void $ throwTE $ ..."
01:30:39 <altschuler> pavonia: That seems to rid the error, will try to do it all over immediately :)
01:32:03 <pavonia> :t when
01:32:04 <lambdabot> Monad m => Bool -> m () -> m ()
01:32:09 <altschuler> pavonia: hmm, except in the cases where the return type is TC Type and not TC ()
01:32:28 <pavonia> it's always TC ()
01:33:05 <pavonia> I'm wondering why when doesn't take "m a" as second parameter
01:33:05 <altschuler> pavonia: Meh. There's obviously something I don't fully get
01:33:48 <pavonia> look at the type of when, it's expecting an "TC ()" but you're giving it "TC Something"
01:34:40 <altschuler> pavonia: Ah, but this one isn't even in a when, it's just in an if. It's on line 238 in the hpaste
01:35:27 <pavonia> the result types of the then- and else-clauses probably don't match
01:38:06 <altschuler> pavonia: But how can I then either throw an error or return a Type for instance?
01:38:54 <altschuler> without returning some dummy instance of a type
01:39:16 <pavonia> you do that by sequencing: throwError "foo"; return someValue
01:39:40 <altschuler> but I have nothing to return if it fails
01:39:56 <pavonia> you don't need to
01:40:23 <altschuler> what then would be the value of someValue?
01:41:54 <pavonia> Ahh, I think the problem is in the return value of throwTE
01:42:33 <altschuler> I tried changing it to TC () which didn't really help either :)
01:43:37 <pavonia> Hhm, what do you want "typeOf (PIf cond conseq alt)" to return if there's no error?
01:43:52 <altschuler> a Type
01:44:03 <pavonia> Where from?
01:44:35 <altschuler> it would be either the conseq or alt
01:44:43 <altschuler> which are Types
01:44:50 <altschuler> or no, sorry, they are Expr
01:44:59 <pavonia> tyConseq and tyAlt?
01:45:03 <altschuler> yes
01:45:08 <altschuler> those are Types
01:45:21 <pavonia> so you return one of these
01:45:32 <altschuler> typeOf finds a Type of an Expr
01:45:37 <altschuler> yes
01:45:57 <pavonia> return $ if someCondition then tyCOnseq else tyAlt
01:47:37 <altschuler> Yes that would work, but what about something like: return $ if someCondition then tyCOnseq else throwTE "fail"
01:48:00 <pavonia> that won't work
01:48:24 <altschuler> my problem exactly :D
01:48:41 <pavonia> What is someCondition exactly?
01:49:27 <altschuler> a Bool
01:50:13 <pavonia> I guesses that, I mean in terms of semantics
01:51:07 <pavonia> I think you want something like "when (not $ someCondition) (void $ throwTE ...); return tyConseq"
01:51:50 <pavonia> so it someCondition is false, it fails prematurely; otherwise it returns the correct type
01:51:58 <pavonia> *so if
01:55:02 <pavonia> altschuler: Well, I have to go. Good luck!
01:57:27 <Javran> how can I get a value :: "RandT g (MaybeT IO) a" from "RandT g IO a" ?
02:00:38 <Javran> @hoogle (MonadTrans t1, MonadTrans t2, Monad m) => t1 m a -> t1 (t2 m) a
02:00:39 <lambdabot> No results found
02:04:26 <eatman> Hello.
02:18:18 * ski notes eatman
02:18:21 <no-n> > let f (_:_) = "hello" in f (repeat undefined) -- LYAH says doing something like this raises an exception for stuff defined with the data keyword but isn't [] one of them?
02:18:23 <lambdabot>  "hello"
02:20:00 <ski> presumably you've misunderstood what would raise an exception ?
02:20:14 <ski> > let f (_:_) = "hello" in f []
02:20:15 <lambdabot>  "*Exception: <interactive>:3:5-21: Non-exhaustive patterns in function f
02:20:22 <no-n> no
02:20:43 <no-n> http://learnyouahaskell.com/functors-applicative-functors-and-monoids#the-newtype-keyword
02:20:48 <no-n> ctrl+f "data CoolBool"
02:21:23 <jle`> newtypes are the strict ones
02:21:26 <jle`> not data
02:21:40 <no-n> isn't [] data thoug
02:21:46 <jle`> wait
02:21:51 <jle`> um
02:21:55 <ski> @src []
02:21:55 <lambdabot> data [] a = [] | a : [a]
02:22:08 <jle`> messed this up.  data has to be inspected, newtype does not
02:22:11 <no-n> also, id have thought it would just be looking at the value constructors
02:22:28 <jle`> > let f (_:_) = "hello" in f undefined
02:22:30 <lambdabot>  "*Exception: Prelude.undefined
02:22:38 <jle`> that's what LYAH is talking about
02:22:43 <ski> a `newtype' constructor is strict. a `data' constructor is not, unless it uses the `!' annotation in the declaration
02:22:45 <no-n> hmm, ok
02:22:52 <jle`> it has to check what is being passed to see if it is x:xs or []
02:23:05 <no-n> ahh, right
02:23:07 <jle`> repeat undefined is obviously x:xs
02:23:13 <ski> `repeat undefined' is `undefined : undefined : undefined : ...'
02:23:14 <jle`> it's undefined : repeat undefined
02:23:15 <no-n> i see
02:23:18 <no-n> ya
02:23:28 <no-n> my bad
02:23:53 <jle`> no prob at all.
02:24:03 <jle`> hm
02:24:07 <jle`> is there such thing as a Free Ord?
02:24:19 <jle`> i guess you could tag it into a tuple with Integer
02:24:36 <jle`> but i'm not sure how that would work
02:27:11 <akegalj_> i have "insert House" which returns (simplified) type YesodDB House. Now i want to implement to work for Maybe House too. So i tryed with "insert `fmap` Just House" and it's type is Maybe (YesodDB House), but i would like to get YesodDB (Maybe House). Is that somehow posible?
02:28:02 <ski> jle` : `Free Ord' ?
02:28:24 <jle`> ski: some structure that you can apply to something so that it satisfies the ord laws?
02:28:26 <no-n> hmm, so with data, the value constructors are strict and the fields are lazy?
02:28:48 <ski> @type Data.Traversable.mapM  -- akegalj_, perhaps you can use this one ?
02:28:49 <lambdabot> (Monad m, Traversable t) => (a -> m b) -> t a -> m (t b)
02:29:13 <jle`> no-n: deconstructing using pattern matching is strict
02:29:19 <ski> no-n : no, the value constructors are (usually) lazy
02:29:21 <jle`> unless you have an explicitly lazy pattern match
02:29:31 <akegalj_> ski: hm, will try now. thnx
02:31:22 <jle`> no-n: remember that constructors actually give you two things
02:31:28 <jle`> ways to create the data
02:31:30 <jle`> and ways to take it apart
02:31:36 <jle`> technically the latter is a deconstructor but yeah
02:31:46 <no-n> nod
02:31:57 <jle`> CoolBool is just an ordinary function
02:32:09 <jle`> (the constructor)
02:32:16 <jle`> you can have lazy pattern matching/deonstructing though
02:32:31 <jle`> > let f ~(_:_) = "hello" in f undefined
02:32:32 <lambdabot>  "hello"
02:32:34 <jle`> woo hoo
02:32:46 <no-n> heh, ahh :)
02:32:47 <jle`> you can also have strict fields in data
02:33:08 <jle`> data CoolBoolStrict = CoolBool' !Bool
02:33:27 <no-n> interesting
02:33:36 <jle`> mostly just more ways to control evaluation
02:33:47 <no-n> why would you want to though?
02:34:04 <ski> @src Complex
02:34:05 <lambdabot> data (RealFloat a) => Complex a = !a :+ !a
02:34:16 <jle`> no-n: for the lazy patern match, it helps performance
02:34:19 <jle`> @src unzip
02:34:19 <lambdabot> unzip = foldr (\(a,b) ~(as,bs) -> (a:as,b:bs)) ([],[])
02:34:21 <jle`> :t unzip
02:34:22 <lambdabot> [(a, b)] -> ([a], [b])
02:34:29 <ski> @src partition
02:34:30 <lambdabot> partition p xs = foldr (select p) ([],[]) xs
02:34:30 <lambdabot>     where select p x ~(ts,fs) | p x       = (x:ts,fs)
02:34:30 <lambdabot>                               | otherwise = (ts, x:fs)
02:34:34 <jle`> you know that all of the items will look like (as,bs) anyway
02:34:39 <jle`> why bother going through the step to check?
02:34:56 <jle`> for data fields, strict data fields avoid building up unecessary chains of thunks
02:34:58 <no-n> I was asking about !
02:35:07 <jle`> unnecessary
02:35:08 <ski> @let partitionStrict p xs = foldr (select p) ([],[]) xs where select p x (ts,fs) | p x       = (x:ts,fs) | otherwise = (ts, x:fs)
02:35:11 <lambdabot>  Defined.
02:35:11 <no-n> okay
02:35:29 <jle`> lazy data can be annoying
02:35:34 <jle`> because you really want to put in, say, a 5
02:35:42 <jle`> but you end up putting in 1+1+1+1+1
02:35:43 <ski> > (take 4 *** take 4) (partitionStrict even [0 ..])
02:35:44 <lambdabot>  (*Exception: stack overflow
02:35:45 <ski> > (take 4 *** take 4) (partition even [0 ..])
02:35:47 <lambdabot>  ([0,2,4,6],[1,3,5,7])
02:36:06 <jle`> which stays as 1+1+1+1 the entire time until you eventually force it
02:36:24 <no-n> ye
02:36:42 <ski> so omitting the `~' from `partition' makes it not work on infinite lists
02:36:44 <jle`> actually i think it is considered good-ish practice to just make all of your non-spine data fields strict
02:36:53 <ski> (also making it less efficient on finite lists)
02:37:24 <jle`> by spine, i mean, for data List a = Cons !a (List a)
02:37:45 <jle`> as opposed to data List a = Cons !a !(List a)
02:37:47 <no-n> hmm
02:37:48 <jle`> bcause why
02:37:51 <jle`> :/
02:39:33 <ski> in general, i'm not sure it's a good idea to make parametric fields strict
02:39:44 <jle`> oh yeah
02:39:48 <jle`> that was a bad example :|
02:40:24 <jle`> wanted to illustrate the difference between a leaf and a spine
02:40:53 <jle`> data IntList = IntCons !Int IntList
02:42:39 <akegalj_> ski: thanks, traversable works great. Also, side question... is this class of problems solved by monad transformers (as i don't realy use or now them yet)?
02:42:51 <jle`> lazy data fields are useful too and have their own uses.  so do strict ones.  they both have their specific use cases.  those are just rules of thumb of course.
02:43:00 <akegalj_> know*
02:43:27 <jle`> akegalj_: this doesn't have much to do with monad transformers
02:43:59 <jle`> monad transformers would be if you wanted to chain succesive IO (Maybe a)'s, but want the first IO that returns Nothing to stop for the rest of the IO action
02:44:37 <jle`> sort of like generalizing the normal Maybe behavior, but to IO (Maybe a)'s
02:44:46 <jle`> akegalj_: also, `fmap` is just <$> :)
02:45:28 <jle`> what mapM did was allow you to treat Maybe as if it was a list ([]), but with zero or one elements
02:45:44 <ski> akegalj_ : not sure what "this class of problems" is
02:45:46 <jle`> you can think of it as sort of implicitly doing mapM (from prelude) on maybeToList
02:46:32 * ski generally prefers using infix `fmap' to `<$>'
02:46:48 <jle`> ski: really?
02:46:56 <jle`> that's neat
02:47:00 <ski> yes
02:47:02 <ski> why ?
02:47:04 <jle`> any particular reason?
02:47:12 <ski> i don't like the name `<$>' ?
02:47:24 <jle`> that works
02:47:30 <ski> or rather, i think that name should have been chosen for what is now called `<*>'
02:47:45 <jle`> but <$> is like $ :/
02:47:54 <ski> `<*>' is more like `$'
02:47:57 <jle`> > (*2) $ 3
02:47:58 <lambdabot>  6
02:48:00 <ion> jle: So is (<*>). :-P
02:48:01 <jle`> > (*2) <$> Just 3
02:48:02 <lambdabot>  Just 6
02:48:08 <ion> > Just (*2) <*> Just 3
02:48:09 <lambdabot>  Just 6
02:48:25 <ski> `<*>' would be ok for `Applicative i => i a -> i b -> i (a,b)'
02:48:54 <ski> that is a much more symmetric operation, and so is more worthy of the symmetric-looking symbol
02:49:30 <ski> (also, `<**>' is just silly)
02:49:39 <jle`> so just throw in an extra pure? -- f <$> x <*> y ===> pure x <$> f <$> x <$> y ?
02:49:43 <jle`> er
02:49:48 <jle`> pure f <$> x <$> y
02:50:18 <ski> yes, or e.g. use `$>' for `fmap'
02:50:47 <ski> (or some other variant that highlights the lack of idiom on one side)
02:52:00 <jle`> that's interesting
02:52:05 <jle`> i like it
02:52:12 * ski smiles
02:52:54 <no-n> :t (<**>)
02:52:55 <lambdabot> Applicative f => f a -> f (a -> b) -> f b
02:55:08 <akegalj_> jle` ski : thanks for explaining things out :)
02:55:35 <ski> actually jle` did most of the explaining
02:59:26 <jle`> i kinda ramble
02:59:37 <jle`> so the signal:noise ratio is pretty low
03:05:28 <bahamas> can you type _|_ into ghci? I'm trying to, but I get a parse error?
03:05:34 <bahamas> s/error?/error/
03:06:06 <jle`> bahamas: _|_ is just the maths symbol
03:06:11 <jle`> it's not an actual computation
03:06:34 <jle`> you can use undefined or sum [1..] to simulate things if you want to run tests
03:06:56 <nkpart> I have a data type like, T a b c, and I can provide a functor for `T _ b c`, how can I express that? do I use a type synonym?
03:07:53 <merijn> bahamas: bottom (or ⊥) is a non-terminating (or crashing) computatipn
03:07:55 <jle`> nkpart: yes
03:08:10 <merijn> jle`, nkpart: No
03:08:16 <jle`> aw
03:08:20 <jle`> :(
03:08:21 <merijn> nkpart: You will have to use a newtype or reorder the arguments
03:08:27 <jle`> oh yeah
03:08:30 <jle`> it's late :|
03:08:44 <merijn> You can't write instances for partially applied type synonyms, sadly
03:08:56 <jle`> can't you do TFunctor b c a = T b c a ?
03:09:05 <jle`> er
03:09:19 <jle`> type TFunctor b c a = T a b c ?
03:09:25 <jle`> oh, you can't write an instance for it
03:09:33 <merijn> Exactly
03:09:39 <jle`> lame.
03:09:45 <nkpart> Ah yeah, thanks
03:10:07 <merijn> And the reason you can't is because partially applied type synonyms are identical to type level lambda's, which break inference in all sorts of horrible ways
03:11:54 <nkpart> oh really? I'm aware of that happening in scala, but I just never assume scala type inference works
03:12:45 <bahamas> jle`: ah, no. I just saw it written in the gentle introduction in examples of the form ('a', _|_), so I thought that it can be typed
03:13:34 <jle`> yeah, it is useful shorthand for 'anything that breaks stuff if you try to evaluate it'
03:13:45 <jle`> or doesn't terminate
03:15:02 <ski> anything that doesn't return a result value when forced
03:17:24 <jle`> is there a non-associative monoid/semigroup?
03:17:29 <jle`> typeclass
03:18:04 <jle`> magma?
03:20:54 <bahamas> anyone remember if/where LYAH talks about <*> and <$>? I have the feeling I read about them, but I'm not sure where
03:21:36 <ilmig> bahamas: http://learnyouahaskell.com/functors-applicative-functors-and-monoids#applicative-functors
03:22:12 <bahamas> ilmig: aha. then I skipped ahead in the past, because I just reached this chapter. thanks
03:23:10 <Dethkat> Hello would anyone mind answering a beginner question about type classes? I'm stuck
03:24:15 <tdammers> Dethkat: just ask
03:24:18 <Dethkat> sure
03:24:41 <Dethkat> e8 :: (?,[Float])
03:24:41 <Dethkat> e8 = (['a','b','c'],?)
03:25:25 <Dethkat> I'm not sure what to put for the question marks
03:25:35 <peteretep> Dethkat: Is this homework?
03:25:37 <Dethkat> tried a few things
03:25:39 <quicksilver> that doesn't appear to be about type classes at all
03:25:54 <tdammers> indeed... it's about types, if anything
03:25:55 <quicksilver> the first question mark should be the type of ['a','b','c'], is that clear?
03:26:04 <Dethkat> well its personal homework, im not in uni, I'm just doing the course by my self
03:26:30 <peteretep> Dethkat: The values of the two ?s will be different
03:27:11 <Dethkat> yes I thought the top one would be 'a' for anything
03:27:24 <bahamas> Dethkat: what is the type of 'a'?
03:27:33 <merijn> Dethkat: Why would it be anything?
03:27:33 <bahamas> Dethkat: mind the quotes
03:27:47 <peteretep> Dethkat: But you already know what it is, it's the type of ['a','b','c']
03:27:57 <bahamas> merijn: probably because type variables are designated by a, b, c :)
03:28:11 <peteretep> Dethkat: I'm not sure thinking of 'a' as 'anything' is helpful
03:28:48 <tdammers> technically speaking, e8 :: (a, [Float]) would be correct, but not really useful
03:29:18 <bahamas> Dethkat: what types do '4', 'a', '&' have?
03:29:31 <peteretep> Dethkat: The question is asking you to identify the type of ['a','b','c'], and then to give some example data of the type [Float]
03:29:57 <Dethkat> 'a' 'b' and 'c' are Char
03:30:00 <Dethkat> right?
03:30:06 <bahamas> Dethkat: correct
03:30:14 <bahamas> Dethkat: then, what type is ['a']?
03:30:28 <Dethkat> example data of the float is something like 1.0
03:30:32 <merijn> tdammers: No it wouldn't be correct
03:30:39 <peteretep> Dethkat: What do the square brackets mean?
03:30:47 <bahamas> that's correct as well
03:30:48 <merijn> tdammers: It'd unify with (a, [Float]), but that doesn't mean it *is* that
03:30:56 <Dethkat> thats a dictonary char
03:31:01 * hackagebot hopencl 0.2.1 - Haskell bindings for OpenCL  http://hackage.haskell.org/package/hopencl-0.2.1 (MerijnVerstraaten)
03:31:22 <bahamas> Dethkat: nope. haskell doesn't have dictionaries (AFAIK)
03:31:36 <peteretep> Isn't Data.Map a dictionary?
03:31:42 <Dethkat> sorry wrong word a list
03:31:49 <bahamas> Dethkat: correct
03:31:58 <bahamas> Dethkat: you can use ghci to check the type
03:32:01 <bahamas> :t ['a']
03:32:03 <lambdabot> [Char]
03:32:18 <peteretep> Dethkat: Can you think of another name for a list of characters?
03:32:31 <Dethkat> a string
03:32:47 <merijn> peteretep: Depending how you define dictionary, yes
03:33:01 <jle`> it's not built into the language, at least
03:33:01 <peteretep> merijn: What else could it mean? (genuine question)
03:33:30 <jle`> when you say a language 'has dictionaries', usually you mean that the language has dictionary baked into the syntax/spec
03:33:35 <jle`> i think
03:33:44 <tdammers> merijn: point taken
03:34:02 <jle`> bash, awk, ruby, python, perl
03:34:08 <Dethkat> seems like ive started another conversation off :)
03:34:29 <bahamas> Dethkat: yeah, let's return. do you know what type to put now?
03:34:33 <tdammers> jle`: I don't think it's possible to draw a hard line there
03:34:58 <Dethkat> sorry there are lots of people talking so ive got a little confused
03:35:01 <jle`> any language can implement a dictionary
03:35:18 <tdammers> jle`: for example, PHP has dictionary-like data structures baked into it, C++ has them as part of the standard libraries, Haskell provides them through a de-facto standard library...
03:35:25 <Dethkat> not that mind I appreciate the help
03:35:30 <peteretep> Dethkat: The question wants two answers
03:35:33 <Dethkat> yes
03:35:39 <peteretep> Dethkat: The first answer is identifying the type of ['a','b','c']
03:35:42 <ilmig> Dethkat: you actually already gave the correct answer.
03:35:51 <ilmig> at least for the first question
03:35:52 <bahamas> Dethkat: e8 :: (?, [Float]). what type do you put instead of "?"?
03:35:55 <peteretep> Dethkat: The second answer is giving an example of some data which would match the type [Float]
03:36:33 <Dethkat> Char?
03:36:42 <peteretep> Dethkat: You've said that [] means a list, the 'a' is a Char, and that float could be 1.0
03:36:49 <peteretep> Dethkat: You now just need to put those together
03:37:04 <Dethkat> right gota ya, sorry for being thick
03:37:10 <peteretep> Dethkat: Do you understand the different between the first line with the :: in it, and the second line with = in it?
03:37:46 <Dethkat> I'm not sure the bottom equals should be there
03:38:00 <bahamas> Dethkat: why not?
03:38:14 <bahamas> what should there be instead?
03:38:21 <Dethkat> no you right it should be
03:38:22 <peteretep> Dethkat: I think it should. What's the difference between the two lines? What does each line do?
03:38:53 <Dethkat> first line sets the type of the funcation
03:38:57 <Dethkat> function
03:39:12 <Dethkat> second line is the the function
03:39:32 <peteretep> excellent
03:39:38 <Dethkat> Thanks :)
03:39:56 <Dethkat> Your the man Peter
03:40:30 <ski> except it's not a function :)
03:40:54 <Dethkat> ?
03:41:04 <ski> `e8' is not a function
03:41:16 <ski> it doesn't take an argument. ergo, it's not a function
03:41:29 <Peaker> why does ParsecT have a ParseError in its OK results?
03:41:52 <Dethkat> ok :)
03:41:55 <Peaker> http://hackage.haskell.org/package/parsec-3.1.5/docs/Text-Parsec-Prim.html#t:Reply <-- this doesn't make much sense
03:43:31 <quicksilver> Peaker: the error when you backtrack is preserved even though the parser doesn't fail?
03:43:36 <quicksilver> Peaker: (that is only a guess)
03:43:52 <Peaker> quicksilver: but when you backtrack it's not Ok, is it?
03:44:03 <quicksilver> it's OK at the next level up
03:44:09 <quicksilver> when it starts going forward again
03:44:26 <Peaker> I'm wondering how to get my "u" state from Parsec when the parser fails (so I can give better error diagnostics)
03:44:37 <Peaker> quicksilver: perhaps, I guess I can ignore that
03:45:35 <Peaker> I guess I could use a StateT outside (above) ParsecT to get back-tracked state
03:45:43 <Peaker> but then I need to lift all the parsing operations :(
03:47:50 <Dethkat> e9 :: a -> (a, a)
03:47:51 <Dethkat> e9 ? = ?
03:48:18 <sjsunoob> What does the following signature mean?
03:48:38 <sjsunoob> [[a] -> [a]} -> [a] -> [a]
03:48:43 <sjsunoob> whoops
03:48:47 <sjsunoob> [[a] -> [a]] -> [a] -> [a]
03:49:25 <quicksilver> takes two parameters
03:49:30 <quicksilver> one a list of functions, the other a list
03:49:33 <quicksilver> and returns a list
03:49:35 <sjsunoob> I'm familiar with this ([a] -> [a]] -> [a] -> [a]
03:49:52 <sjsunoob> How did you deduce that the first one is a list of functions?
03:50:01 <quicksilver> the [] on the outside
03:50:01 <ski> @type foldr (.) id
03:50:03 <lambdabot> [b -> b] -> b -> b
03:50:11 <sjsunoob> why not [b -> b]
03:50:23 <peteretep> sjsunoob: Because b must also be a list, according to your type sig
03:50:23 <quicksilver> sjsunoob: well I was being unspecific for brevity
03:50:34 <quicksilver> it's actually a list of functions [a] -> [a]
03:50:40 <quicksilver> that is a list of functions which take lists and return lists
03:50:42 <ski> your list of functions is a list of functions that take a list of `a's to a list of `a's
03:51:10 <CARAM> so what does that function return then?
03:51:10 <peteretep> [filter,filter,filter]
03:51:19 <Dethkat> I'll wait till you help sjsunoob
03:51:20 <sjsunoob> so if I have [blablahblah -> blahblahablha]
03:51:35 <ski> CARAM : given a list of such functions, and then further a list of `a's, you get back a list of `a's
03:51:55 <ski> CARAM : given just a list of such functions, you get back a function from a list of `a's to a list of `a's
03:52:27 <sjsunoob> Man, this is frustrated me
03:52:30 <CARAM> got it... what's a possible implementation
03:52:30 <sjsunoob> can we take a step back?
03:52:34 <CARAM> ?
03:52:44 <sjsunoob> a -> a means it takes a element a and return element a
03:52:47 * ski steps back
03:52:49 <sjsunoob> corrent?
03:52:55 <ski> (aye)
03:52:56 <sjsunoob> correct* sorry, been at this for hours
03:53:19 <sjsunoob> [a] -> a takes a list of elements of a and returns a, correct?
03:53:25 <peteretep> :t cycle
03:53:27 <lambdabot> [a] -> [a]
03:53:37 <peteretep> :t [cycle,init,reverse]
03:53:38 <lambdabot> [[a] -> [a]]
03:53:38 <ski> sjsunoob : returns a value of type `a', yes
03:53:45 <sjsunoob> damn
03:53:47 <sjsunoob> I think i got it
03:53:59 <sjsunoob> [(a,a)] is a list of pairs
03:54:22 <sjsunoob> so [[a] -> [a]] is a list of functions that take in a list of a's and return a list of a's, correct?
03:54:34 <ski> it's the *type* of lists of pairs, both components being of type `a'
03:54:34 <exlevan> yep
03:54:42 <sjsunoob> horray
03:54:44 <sjsunoob> Thanks a lot!
03:54:47 <Dethkat> yay!!!
03:55:00 <sjsunoob> *throws money at the screen*
03:55:11 * ski boings up and down
03:55:59 <sjsunoob> Wow, this problem makes a ton more sense now
03:56:03 <Dethkat> e9 :: a -> (a, a)
03:56:04 <Dethkat> e9 ? = ?
03:56:04 <Dethkat> Does it mean 'takes anything and gives back a tuple of two anythings?
03:56:04 <sjsunoob> Could not wrap my head around it
03:56:29 <CARAM> yo but seriously, what would the implementation of a function like that be?
03:56:41 <quicksilver> CARAM: like which?
03:56:42 <sjsunoob> It's for a hw assignment
03:56:51 <sjsunoob> I'll past it but don't post the answer please, trying to figure this out on my own :)
03:57:06 <quicksilver> Dethkat: "takes anything and gives back a tuple of two of those things"
03:57:12 <CARAM>  [[a] -> [a]] -> [a] -> [a]
03:57:15 <sjsunoob> Define a function applyAll of type [[a] -> [a]] -> [a] -> [a] that successively applies the functions in the list of functions (from left to right) to the list of type [a]. So for example (applyAll [tail, tail, tail, tail] [1,2,3,4,5]) should return [5] and (applyAll [(map (* 2)), (map (+ 1))] [1,2,3,4,5]) should return [3,5,7,9,11].
03:57:45 <CARAM> oh
03:57:46 <CARAM> well
03:57:54 <ski> Dethkat : it means : takes a value of type `a', and gives back a pair of two values, both of type `a'
03:58:03 <ski> Dethkat : .. where the type `a' is arbitrary
03:58:11 <ski> Dethkat : in short, yes :)
03:58:25 <joneshf-laptop> somethings been bothering me
03:58:27 <Dethkat> I'm sorry if I'm using the wrong words, its my 3rd day, I've been reading quite a few books but I dont have anyone to ask
03:58:39 <sjsunoob> Man, I been learning so much haskell lately I think I could probably answer some question in this room!
03:58:46 <joneshf-laptop> in most introductions to fp you learn that foldr is this very important function
03:58:56 <sjsunoob> fp?
03:58:58 <joneshf-laptop> tht you can implement most of the things you would want to do with it
03:59:02 <bahamas> sjsunoob: functional programming
03:59:11 <ski> sjsunoob : sounds like recursion would do it
03:59:11 <sjsunoob> oh ok
03:59:15 <sjsunoob> yes, fp :)
03:59:16 <joneshf-laptop> but then when you start to delve deeper into haskell
03:59:19 <Dethkat> its also my first programming language so I think I'm doing bloody well considering
03:59:35 <joneshf-laptop> you see that the entire typeclass Foldable is useful, but not as much as it seems
03:59:56 <Dethkat> How would you say it properly if you dont mind me asking?
04:00:08 <ski> Dethkat : don't be sorry about using wrong words. i'm just trying to show the terminology we use (or sometimes are sloppy enough not to use ;)
04:00:39 <Dethkat> oh, I thought you were taking the piss
04:00:44 <joneshf-laptop> like, you can implement filter using foldr for lists pretty easily
04:00:45 <Dethkat> Sorry :)
04:00:55 <peteretep> Dethkat: Why have you chosen Haskell first?
04:01:00 <peteretep> Dethkat: Also, I have a book recommendation for you
04:01:07 <sjsunoob> I keep getting the following error
04:01:09 <sjsunoob>  Couldn't match type `a' with `[a]'       `a' is a rigid type variable bound by           the type signature for applyAll :: [[a] -> [a]] -> [a] -> [a]           at a3.hs:125:13
04:01:12 <joneshf-laptop> but try that with some other Foldable instance, and you suddenly need so much more in order to makes sense of it
04:01:19 <sjsunoob> to the following implementation: applyAll (f:fs) (xs) = map f xs
04:01:46 <ski> Dethkat : as long as you understand what you want to say, and the person you're talking with also understand it, you can often afford to be a bit sloppy. but imho, when you're new to it, it helps if you're being more careful with wording, so as not to develop any wrong understanding
04:01:56 <joneshf-laptop> is it just htat the list type is so powerful that simple functions like foldr seem powerful when used by it?
04:01:57 <CARAM> sjsunoob
04:02:02 <joneshf-laptop> or is there something else at play?
04:02:03 <CARAM> f is [a]->[a]
04:02:03 <ski> Dethkat : also, not quite sure what "taking the piss" means :)
04:02:09 <CARAM> not a->a
04:02:20 <sjsunoob> whelp, got it!
04:02:20 <Dethkat> making fun of me
04:02:27 <Dethkat> I'm british
04:02:27 <sjsunoob> wait...
04:02:31 <merijn> ski: "taking the piss" is british for making fun of
04:02:32 <sjsunoob> Let me look at this again
04:02:47 <Dethkat> I'm thinking about your question peter
04:02:59 <peteretep> Dethkat: excellent
04:03:06 <ski> sjsunoob : probably you shouldn't use `map'
04:03:22 <CARAM> fold is probably a better bet
04:03:33 <peteretep> Dethkat: If you are not wedded to Haskell, "The Little Schemer" is a great book on learning functional programming
04:03:36 <merijn> Any good intro's to Fix/Mu/Free/etc. ?
04:04:02 <ski> joneshf-laptop : `Foldable' is pretty boring
04:04:02 <peteretep> Dethkat: And if you are wedded to HAskell, "The Little MLer" will do
04:04:31 <joneshf-laptop> ski, right?
04:05:13 <joneshf-laptop> ski, it seems like for anything interesting you have to rely on applicative and/or monoid
04:05:30 <ski> joneshf-laptop : using the operations in that class is basically the same as flattening to a list and using the ordinary list operations
04:05:44 <ski> .. `Traversable' otoh, is more interesting
04:05:56 <Dethkat> I liked the people who wrote it,  Philip Wadler and simon Jones
04:05:59 <ski> iow, `Foldable' is basically just a convenience
04:06:26 <ski> @quote SPJ
04:06:27 <lambdabot> SPJ says: When the limestone of imperative programming is worn away, the granite of functional programming will be observed.
04:09:13 <sjsunoob> Could someone explain the foldl type signature?
04:09:14 <sjsunoob> (a -> b -> a) -> a -> [b] -> a
04:09:27 <sjsunoob> Takes a function that takes to parameters, followed by a type a, followed by a list?
04:10:05 <Dethkat> I guess also I wanted to learn something that wound make learning other programming language a little easier, I feel if I can get my head round Haskell I can get it round anything.
04:11:01 <joneshf-laptop> Dethkat, it will make some easier, and some harder
04:11:08 <joneshf-laptop> just the nature of perspective
04:11:33 <Dethkat> Thanks for the recommendation I'll check the book out
04:11:59 <joneshf-laptop> sjsunoob, yes that's pretty much it
04:12:09 <joneshf-laptop> sjsunoob, just remember that the a's and b's have to be the same type
04:12:17 <ski> sjsunoob : takes a function that combines an `a' with a `b' "element" into a new `a', and an "initial" `a', and a list of `b', producing a "final" `a'
04:12:39 <Dethkat> I think also because its kind of British I picked Haskell... thats a very silly reason but probably a little true
04:12:49 <joneshf-laptop> sjsunoob, you basically apply a function to every element in the list, accumulating the value along the way with the previously caclulated value
04:13:08 <spion> Haskell is an excellent choice, but I'm not sure if there is a lot of first-language learning material
04:13:19 <spion> is LYAH considered to be good at that?
04:13:34 <ski> > foldl (\string number -> "(" ++ string ++ " + " ++ show number ++ ")") "0" [2,3,5,7]  -- sjsunoob, can you follow this ?
04:13:35 <lambdabot>  "((((0 + 2) + 3) + 5) + 7)"
04:13:40 <spion> or does it also make assumptions
04:13:47 <joneshf-laptop> foldl (+) 0 [1,2,3] = ((1 + 2) + 3)
04:13:51 <sjsunoob> ski: let me see
04:13:56 <joneshf-laptop> sjsunoob, ^
04:14:05 <ski> > foldl (+) 0 [1,2,3]           :: Expr
04:14:05 <Dethkat> I've found quite a few books surprisingly, it has been about for 20 years
04:14:06 <sjsunoob> the string param starts at "0"
04:14:07 <lambdabot>  0 + 1 + 2 + 3
04:14:09 <joneshf-laptop> sjsunoob, better yet, just look at ski's output
04:14:25 <ski> > foldl (**) 0 [1,2,3]           :: Expr
04:14:26 <lambdabot>  ((0**1)**2)**3
04:14:36 <sjsunoob> I'm so tired
04:15:16 <kstt> Hi. My code is looping somewhere (100% CPU, but constant memory). With the very classy "putStrLn" method, I have narrowed that this is happening in "pure" codepath (no IO type). However, this codepath does parsing from a lazy bytestring, read from a file with lazy IO. How do you think I should takle that please ? How to narrow down the problem ?
04:15:43 <peteretep> I would always recommend someone learned HTML first. Then Javascript to do something with that. Then a "back end" programming language
04:15:44 <kstt> (I don't do explicit recursion)
04:15:53 <peteretep> But I think like most developers, I learned young enough that it's hard to generalize
04:16:36 * ski started out with BASIC
04:16:38 <CARAM> html is markup
04:16:43 <ski> yes
04:16:44 <CARAM> not a programming language
04:16:47 <spion> Dethkat, the question is whether they make assumptions about prior programming knowledge :/
04:16:54 <peteretep> CARAM: Yes....
04:16:56 <peteretep> CARAM: So?
04:17:19 <spion> i see now that LYAH does make some (not too big) assumptions
04:17:27 * peteretep started with QBasic, and then HTML, then Perl
04:17:32 <Dethkat> HTML would be teaching you to think of language in a different way
04:17:32 <zomg> spion: I think LYAH is generally recommended to beginners
04:17:33 <sjsunoob> I THINK I GOT IT!
04:17:46 <kstt> CARAM: a lot of the programming culture is already present in HTML. Find your editor, type text that a system can interpret ...
04:17:58 <peteretep> kstt: Exactly
04:18:21 <peteretep> Simple introduction to data structures
04:18:25 <Dethkat> Spion I agree yes I think most of them would expect you to have prior programming knowledge
04:18:29 <thrakcattack> HTML is turing-complete they say
04:18:43 <kstt> Who said that ?
04:19:01 <kstt> I'd be surprised ^^
04:19:08 <joneshf-laptop> peteretep, i think the only problem with that is the way html is taught. most don't take a very formal approach to it
04:19:31 <peteretep> joneshf-laptop: I don't know that that's important
04:19:43 <ski> sjsunoob : yes ?
04:19:45 <peteretep> joneshf-laptop: I think most people learning programming want to be productive as soon as possible
04:19:51 <zomg> Yeah formal and HTML seems a bit weird :) Especially when you consider typical audiences
04:19:53 <peteretep> joneshf-laptop: Where "productive" is "look what I made!!!"
04:19:57 <joneshf-laptop> peteretep, agreed
04:20:00 <zomg> Sure if you taught a HTML course to comp sci students.. =)
04:20:02 <sjsunoob> I think I solved the hw problem, double checking
04:20:11 <peteretep> And HTML is much much more productive than almost anything else
04:20:39 <peteretep> and it's very easy then to start embellishing it with cargo-cult Javascript
04:20:48 <Dethkat> There is a course on mitx that teaches HTML, CSS and C in the same course
04:20:49 <peteretep> and before you know it, you know about variables and simple branching
04:20:50 <joneshf-laptop> peteretep, i just mean it has always felt much more "quick hack this together in any way possible" than other introductions to languages
04:21:03 <peteretep> joneshf-laptop: I suspect that's a positive, rather than a negative
04:21:13 <zomg> Probably because web development is a quick hack this together thing in general...
04:21:17 <joneshf-laptop> peteretep, of course, it could be tha ijust don't know of any actual good html intro books
04:21:17 <narendraj9> peteretep, I second that.
04:21:29 <zomg> If you look at HTML, DOM APIs, CSS, JavaScript.. none of them were really designed from the ground up to work together
04:21:44 <sjsunoob> Thanks a lot for the help btw guys :) reading these function signature can be tough
04:21:44 <peteretep> joneshf-laptop: I dunno if you need them to be "good" in a "teaches formally" way
04:21:46 <flux> dethkat, makes perfects sense. "here's how you write web pages, here's how you render them"
04:21:56 <sjsunoob> Is anyone here from the Bay Area? Just curious, I won't stalk you :P
04:22:01 <peteretep> joneshf-laptop: "Good" just needs to be "achieve your outcome quickly"
04:22:19 <joneshf-laptop> peteretep, but i think that sets people down the wrong path
04:22:41 <ski> sjsunoob : i think so
04:22:44 <peteretep> joneshf-laptop: The bigger battle is stoking enthusiasm to overcome the learning curve
04:22:47 <peteretep> imho
04:23:25 <Dethkat> I think it great that its being taught like that flux, most non progammers just want to do useful, simple things
04:23:26 <sjsunoob> Anyone here every get tired of programming?
04:23:41 <peteretep> If you're the kind of kid who always knew that maths is beautiful and inherently interesting, something more formal might be great. I certainly wasn't, and I've enjoyed increasing my knowledge of computer science after becoming an effective developer with lots of practical experience
04:23:44 <sjsunoob> I thought I lost the spark for a while, but the functional programming thing is really sparking my interest again
04:24:11 <zomg> peteretep: agreed, pretty much what I've found as well
04:24:40 <peteretep> The small amount of discrete maths I've learned in the last few years has been fascinating, but only because I see how it applies to what I already know
04:25:23 <joneshf-laptop> peteretep, i mean, that's all well and good for getting new blood in the industry
04:25:48 <joneshf-laptop> peteretep, but it leads people to want to have this "hack it together" attitude with the rest of their stuff
04:26:00 <flux> dethkat, will they do those in C?
04:26:05 <joneshf-laptop> peteretep, do we really wantto live in a world where that is the norm?
04:26:16 <peteretep> joneshf-laptop: I think "hack it together" can mean two things
04:26:18 <kstt> zomg: web interfaces are hacky, but still a LOT more productive than GTK+ or WxWidget. And the difference is even greater if your language is Haskell.
04:26:28 <peteretep> It can mean a lack of attention to detail and being pleased with mediocre results
04:26:29 <Dethkat> what do you mean Flux?
04:26:31 <peteretep> OR
04:26:39 <peteretep> It can mean being willing to try new things and a focus on pragmatism
04:26:41 <joneshf-laptop> peteretep, i mean, we're lvigin in that now, and you can see by the loads of bugs that everything has just how not great that is
04:26:49 <kstt> And I have completed real, big, sold, projects with them.
04:27:01 <peteretep> joneshf-laptop: I'd say that's caused by people who have approached programming as a career, rather than as a joy
04:27:28 <Dethkat> Im enjoying it!
04:27:36 <zomg> kstt: yep
04:27:53 <kstt> I am in the middle of a GTK+ (on Haskell) project. I have formally taken the decision that this is my last attempt with GTK+.
04:27:54 <zomg> I do mainly web dev so quite familiar
04:27:55 <zomg> =)
04:27:59 <peteretep> Anyway, I mostly learned programming by hanging out on the world's most sociopathic IRC channel
04:28:10 <flux> dethkat, I mean HTML, and CSS are not going to support C or vice versa. for example, doing HTML parsing in C is going to be an onerous task.
04:28:13 <zomg> peteretep: #linux or #c ? ;)
04:28:14 <quicksilver> peteretep: did you also learn how to be a sociopath?
04:28:14 <hpc> #python?
04:28:29 <peteretep> hahah, I was thinking EfNet #perl about 15 years ago
04:28:31 <peteretep> but sure
04:28:59 <hpc> oh my
04:30:56 <Dethkat> its only a beginner course..Have a look for yourself :) https://www.edx.org/course/harvardx/harvardx-cs50x-introduction-computer-1022
04:31:14 <peteretep> quicksilver: I think it set back my professional interaction with coworkers back at least 5 years
04:31:31 <peteretep> Dethkat: Make sure to list "Harvard" under education on your LinkedIn profile now
04:31:37 <Dethkat> hahaha
04:31:50 <quicksilver> peteretep: if you didn't murder any of them yet then you are already in recovery!
04:33:11 <Dethkat> I tell everybody my father went to Cambridge tending to miss out art school at the end
04:34:43 <Dethkat> does anyone still use Hugs, would it be useful for me?
04:38:22 <sjsunoob> one more to go
04:38:47 <sjsunoob> I can so close to having my head rest against my comfy pilloW!
04:39:23 <quicksilver> Dethkat: it is not widely used any more. In some cases it produces (produced) better error messages.
04:39:41 <quicksilver> Dethkat: but ghci is still actively developed and gets much more use
04:40:48 <Dethkat> have you used it quicksilver? are the error messages much more helpful?
04:41:09 <peteretep> I think you're better off learning to read ghci's error messages
04:41:39 <Dethkat> will do :)
04:41:59 <Dethkat> I'm still stuck on this question
04:42:13 <Dethkat> e9 :: a -> (a, a)
04:42:14 <Dethkat> e9 x = (y, z)
04:42:48 <Dethkat> sorry bottom bit should be e9 ? = ?
04:43:28 <Dethkat> e9 :: a -> (a, a)
04:43:28 <Dethkat> e9 ? = (?, ?)
04:43:44 <peteretep> Dethkat: What does: e9 ? = (?, ?) mean?
04:43:50 <peteretep> Dethkat: What is it describing?
04:43:56 <peteretep> (in English)
04:44:16 <ilmig> Dethkat: maybe try to say in English what the type declaration (i.e. e9 :: a -> (a, a)) tells you
04:44:51 * ski is still waiting on Dethkat's question on this snippet
04:45:48 <Dethkat> I thought it meant 'takes a value of a and gives back a tuple of two a's?
04:46:01 <ilmig> Dethkat: correct!
04:46:48 <ilmig> Dethkat: so each ? in your definition (the one with the =) must have the same type
04:47:07 <Dethkat> see ive learnt to say it the right way from today :)
04:47:09 <peteretep> Dethkat: If you have one value passed in, how could you get two values out again?
04:47:26 <Dethkat> I'm not sure peter
04:47:38 <peteretep> So have a think :-)
04:47:40 <Dethkat> let me think about it
04:47:42 <Dethkat> haha
04:47:48 <peteretep> It's more of a logical question than a Haskell question
04:49:33 <spion> and it also shows the ambiguity of natural language :( "two values out" kind of implies more meaning than (?, ?)
04:51:30 <ski> anyway, `?' there isn't correct Haskell syntax
04:51:57 <ski> perhaps you meant to ask whether this is a good start, if you later fill in the `?'s with some appropriate code ?
04:52:00 <spion> ski, I think those are meant as blanks in an exercise
04:52:12 <ski> maybe
05:05:55 <Raydiation> hi, is map always done in parallel?
05:06:28 <quicksilver> no.
05:06:34 <quicksilver> in fact, map is never done in parallel
05:06:43 <Raydiation> why?
05:07:02 <quicksilver> it might be interesting to design a system which did
05:07:05 <Raydiation> i thought it was maybe optimized by the compiler
05:07:08 <quicksilver> many papers have been written about it
05:07:11 <quicksilver> but GHC is not such a system
05:07:18 <quicksilver> GHC does not do any implicit parallelisation.
05:07:45 <Raydiation> damn i thought i would have an easy solution for an exercise xD
05:07:55 <quicksilver> there is a conflict between impliciation parallelisation and lazy evaluation, insofar as lazy evaluation wants to do the "least possible work to get the answer demanded"
05:08:10 <quicksilver> while implicit parallelisation has to try to guess what might be wanted next
05:08:13 <quicksilver> (or prove it)
05:08:20 <Raydiation> right
05:08:26 <quicksilver> but, that soundsl ike a problem you can solve in principle
05:08:30 <quicksilver> and lots of smart people ahve thought about it.
05:08:39 <ghorn> the strict drawback never occured to me
05:09:18 <quicksilver> GHC's "sparking" mechanism is a flexible way of marking work to be done later
05:09:26 <quicksilver> see Control.Parallel.Strategies
05:09:33 <quicksilver> it's quite fiddly to actually make things run faster though
05:09:42 <quicksilver> turns out parallelisation is hard :-/
05:10:09 <quicksilver> see also JaffaCakes's book
05:10:29 <quicksilver> http://community.haskell.org/~simonmar/pcph/
05:10:50 <Raydiation> thanks
05:10:58 <quicksilver> you can read it online I think
05:11:18 <Raydiation> i prefer a local copy :P
05:12:43 <merijn> And of course lazily evaluating in parallel in practice comes down to parallel graph reduction, which many people have tried to tackle too, but is nowhere near solved
05:14:57 <tranma> I'm having some trouble understanding lens.plated. In particular, the binary tree example at http://hackage.haskell.org/package/lens-4.0.5/docs/Control-Lens-Plated.html. Here the docs gave 2 ways to implement a Plated instance for Tree and claimed "The former will only treat children directly in this tree as descendents, the latter will treat trees contained in the values under the tips also as descendants!".
05:15:20 <tranma> However I tried both implementations and they don't seem to be different in any way
05:15:36 <tranma> as in: children t and universe t yielded the same results
05:15:44 <tranma> t = Tip (Tip 0) for example
05:16:19 <tranma> children t = [Tip (Tip 0)] for both implementations
05:16:35 <tranma> where the doc suggests they should be different
05:17:25 <tranma> (sorry, I mean children t = [])
05:17:31 <Dementhor> Hi is there a function that checks if one list include the other one? something like [a]->[a]->Bool : f [1,2,3] [2,3] = True ; f [1,2,3] [2,4] = False; I'm looking for something differnent then elem cause its n^2 complexity and using hashes/maps is throublesome
05:18:43 <ski> tranma : i suspect because the two trees have different types
05:20:11 <Dementhor> f (x:xs) ys = x `elem` ys && f xs ys with base case: f [] _ = True is n^2 right?
05:21:02 <merijn> Dementhor: Cheapest way is probably convert both to Set and use Set functions to check
05:21:46 <Dethkat> anyone whos learning may find these lectures useful http://www.youtube.com/playlist?list=PL395B50FC04752DA8
05:22:17 <Dementhor> @merjin does set uses internally nub like function or it keeps duplicates like a multiset?
05:22:17 <lambdabot> Unknown command, try @list
05:24:16 <Hafydd> #yolo
05:24:17 <merijn> Dementhor: Set only stores one element
05:25:04 <ski> that `f' doesn't check multiplicity, either
05:26:40 <Dementhor> ok :) thx
05:28:11 <merijn> Does parsec already implicitly track SourcePos or do I manually need to update it?
05:28:50 <tdammers> it's automatic AFAIK
05:29:15 <tdammers> results are somewhat wonky at times, though, especially if you backtrack a lot
05:29:25 <merijn> How do I get it then?
05:29:35 <merijn> I can't seem to find a way to read it
05:29:45 <tdammers> there is a getter action somewhere
05:30:05 <tdammers> ah, yes
05:30:13 <tdammers> :hoogle getPosition
05:30:21 <tdammers> hmm
05:30:23 <tdammers> well
05:30:27 * ski blinks
05:30:31 <tdammers> http://hackage.haskell.org/package/parsec-3.1.5/docs/Text-Parsec-Prim.html#v:getPosition
05:30:36 <ski> @hoogle getPosition
05:30:37 <lambdabot> Text.Parsec.Prim getPosition :: Monad m => ParsecT s u m SourcePos
05:30:37 <lambdabot> Text.ParserCombinators.Parsec.Prim getPosition :: Monad m => ParsecT s u m SourcePos
05:31:19 * tdammers facepalms
05:31:27 <merijn> Ah, I was just blind. Thanks :)
05:31:31 <tdammers> np
05:31:49 <tdammers> SourcePosition would suggest getSourcePosition, but it's getPosition
05:31:52 <tdammers> bit sloppy
05:36:42 <tranma> hey, thanks ski, I understand that example now, it makes a difference for mutually recursive types, for example: newtype TieKnot = TieKnot (Tree [TieKnot])
05:38:01 <ski> tranma : right
05:38:19 * ski knows nothing about `lens.plated'
05:42:27 <beaky> hello
05:42:37 <beaky> why is ghc so big
05:43:39 <tdammers> beaky: because of all the features :x
05:43:42 <Dethkat> because its clever beaky :)
05:43:55 <tdammers> "so much room for activities"
05:45:08 <makalu> :D
05:50:23 <makalu> according to ohloh, gcc has 6,5 million lines, ghc has 350k
05:51:03 <tdammers> so about the same :D
05:51:15 <merijn> Why does the MonadState instance of ParsecT access an underlying MonadState if ParsecT has it's own state field?
05:51:35 <jmcarthur> beaky: GCC 2.95 was a 9MB .bz2 download when it came out. That was about 9.9 cents worth of hard drive space at the time. GHC's most recent .bz2 download is 121MB. That was about 0.6 cents worth of hard drive space at the time. And get this, GCC 4.8.2 (the most recent release) is still an 82MB .bz2 download, so it's not even much smaller.
05:51:53 <beaky> right
05:52:11 <beaky> gcc is awfully bloated :D
05:52:13 <jmcarthur> I only bring up an old GCC to highlight that hard drive space is getting *really* cheap.
05:52:28 <RichyB> jmcarthur, are you using rotating-rust or SSD pricing? ;)
05:52:54 <jmcarthur> Rotating rust. For now, that's still what most people are using anyway.
05:53:23 <tdammers> also, today's rotating rust is still a lot faster than gcc 2.95-era rotating rust
05:53:59 <jmcarthur> beaky: Given how cheap hard drive space is, I disagree that GCC or GHC are so bad.
05:55:28 <the_berserker> Why GHC limits tuple size to 62?
05:55:44 <quicksilver> it doesn't, the_berserker
05:55:52 <quicksilver> GHC supports unlimited size tuples
05:55:58 <merijn> quicksilver: Does it?
05:56:02 <quicksilver> but it limits the Show instance to 62
05:56:06 <quicksilver> so they're hard to use
05:56:07 <merijn> ah
05:56:09 <quicksilver> or whatever the limit is.
05:56:14 <merijn> 63, afaik
05:56:22 <merijn> The better question is
05:56:23 <quicksilver> better question is, why would you care?
05:56:31 <merijn> Why the hell would you ever need a tuple that big?
05:56:31 <the_berserker> How? Last time I checked, it gives an error message "A 63-tuple is too large for GHC"
05:56:54 <quicksilver> hmm maybe I'm wrong
05:56:57 <jmcarthur> yeah I thought there was actually a hard limit
05:57:02 <merijn> So did I
05:57:05 <the_berserker> The Haskell standard only guarantees 15-tuples.
05:57:05 <quicksilver> it might be something odd like the type checker permits it
05:57:13 <quicksilver> but the compiler won't actually compile it
05:57:18 <jmcarthur> the Show instances are much smaller though, I think, which might be where the confusion comes from
05:57:31 <merijn> the_berserker: What's the problem, though?
05:57:54 <jmcarthur> yeah, i think once you go over three (and even that's a pretty annoying tuple to use) you're doing something wrong
05:58:04 <vernon> Hello! Could you help a little bit with this parse error? http://pastebin.com/6vVQtkUj It's a Zippered list with constant time inserting. GHC throws : "error in pattern 28:9  const . Just". The other functions all work OK.
05:59:20 <the_berserker> jmcarthur: What to do instead of creating a tuple?
06:00:03 <merijn> vernon: Why do you think that line should work?
06:00:22 <merijn> vernon: You can only have pattern matches on the left-hand side of =
06:00:28 <merijn> vernon: const and . are functions
06:00:42 <vernon> oh ok.
06:00:45 <vernon> thanks.
06:00:47 <quicksilver> jmcarthur: I find 3,4,5-tuples occasionally useful for tabulating static data (which then gets processed before use). Things like (Command,HelpText,[KeyPress],Interactive,Undoable)
06:01:43 <the_berserker> What is the technical reason to limit tuple size?
06:01:55 <vernon> merijn: but wait, those are on the left side
06:02:08 <merijn> vernon: Right, but functions aren't pattern matches
06:02:12 <tdammers> the_berserker: finite machine size
06:02:35 <vernon> merijn: okay
06:03:44 <the_berserker> Why don't store tuples like lists?
06:03:56 <quicksilver> it's not a storage problem.
06:04:01 <quicksilver> there isn't really a strong reason, in fact
06:04:07 <quicksilver> it's just work to support them.
06:04:08 <the_berserker>  b
06:04:26 <quicksilver> it would be a straightforward thing for GHC to support arbitrarily large tuples, but it would require work in various areas
06:04:43 <quicksilver> and nobody wants to do the work, because it's a useless feature that nobody wants.
06:04:50 <the_berserker> The ability to dynamically generate data types?
06:05:53 <quicksilver> I'm not sure what you mean.
06:06:05 <quicksilver> Are you saying that's what GHC would need to do to implement the feature?
06:06:15 <quicksilver> or are you saying that's what you're doing and that's why you want large tuples?
06:06:16 <the_berserker> @type (1,)
06:06:17 <lambdabot> Num t => t1 -> (t, t1)
06:06:37 <the_berserker> @type (,,,,,,,,,,,,,,,,,,,,,,,)
06:06:38 <lambdabot> a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> s -> t -> u -> v -> w -> x -> (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x)
06:06:50 <the_berserker> @type (,)
06:06:51 <lambdabot> a -> b -> (a, b)
06:07:02 <merijn> I'm still not sure why you even want such big tuples?
06:07:04 <Walther> Hmm. getLine works for stdin one line, but how can I "getLines" until EOF?
06:07:36 <merijn> Walther: Probably you want "forever $ do { line <- getLine; doSomethingWithLine }"?
06:07:53 <merijn> Depending on what you're trying to do
06:08:44 <Walther> Nope. I want to pipe in a single file until EOF, and make a list of lists (list of lines, lines are lists of "words" (read::string->int)
06:09:00 <quicksilver> lines <$> getContents
06:09:02 <quicksilver> possibly
06:09:11 <quicksilver> although the Prelude getContents has its downsides
06:10:28 <quicksilver> merijn: (this bug is probably what lead me to believe that arbitrary tuples were permitted - https://ghc.haskell.org/trac/ghc/ticket/6148 )
06:12:58 <the_berserker> Is the Parser monad a kind of State monad?
06:13:31 <Walther> quicksilver: Hmmm. getContents returns a single string, which would be *very* problematic. I explicitly need a list(lines) of lists(words)
06:14:39 <ski> Walther : `map words . lines' ?
06:14:58 <merijn> Since we have closed type families, do we have closed data families too? Does such a thing even make sense?
06:15:33 <Walther> ski: Hm, does that work on getContents / does getContents return the \n characters etc to parse on?
06:16:19 <Walther> Oh, neat.
06:16:53 <ski> @type interact
06:16:54 <lambdabot> (String -> String) -> IO ()
06:17:00 <ski> might also be interesting
06:19:40 <quicksilver> Walther: that's why I said "lines"
06:19:50 <quicksilver> Walther: "lines <$> getContents" is what I said.
06:21:29 <the_berserker> One of the biggest difficulties I have when reading Haskell code is determining "which instance is this?". How to overcome this?
06:22:32 <Walther> My current do-block is "c<-getContents, let a=n$m(m r)$m words$filter(notElem '#')$lines c", where n is a function that works fine as is - but I wonder if there is a cleaner way to do the rest of it :/
06:22:49 <Walther> oh, r=read::String->Int
06:23:27 <Walther> s/oh/oh, and/
06:23:44 <c_wraith> the_berserker: usually that indicates a misuse of classes.  When using classes well, behavior is uniform.  You don't need to wonder what instance something is, because it doesn't matter - whatever it is, it'll behave the way you expect.
06:23:50 <ski> not abbreviating `map' as `m' might be cleaner ..
06:25:46 <Walther> ski: depends ;) This is for code-golfing, I have the human readable version in another fil
06:26:01 <Walther> file*
06:26:51 <ski> unless you know all the strings will read ok as `Int's, it's probably better to avoid using `read'
06:28:55 <Walther> ski: input file is spec'd, will only contain lines with Ints separated by spaces or comment lines beginning with #
06:31:05 <the_berserker> Why did they ban (n+k) patterns?
06:33:42 <Walther> Hmmm... I wonder if there is any way to golf "filter(notElem '#')" shorter, by knowing that the # has to be the first char of a line
06:33:52 <Walther> I'm not too familiar with filter syntax
06:34:16 <c_wraith> filter doesn't have syntax
06:34:23 <c_wraith> filter is just a function
06:35:08 <makalu> why is "f . g $ h" preferred over "f $ g h"?
06:35:08 <Walther> well yes, but for what kind of parameters it wants. E.g. filter(head/="#") doesn't seem to work
06:35:34 <merijn> :t filter
06:35:35 <lambdabot> (a -> Bool) -> [a] -> [a]
06:35:35 <c_wraith> it wants a function.  (head /= '#') doesn't typecheck.
06:35:38 <heatsink> filter(('#'/=).head)
06:36:02 <Walther> heatsink: aha. thanks
06:36:41 <Walther> (doesn't help in the golfing though :) )
06:37:20 <Walther> in case you're interested, https://github.com/Walther/euler problem0067.hs and the golfed version problem0067_golf.hs
06:37:36 <Walther> (golfed version has a slightly different algo though)
06:38:02 <c_wraith> makalu: two reasons.  First, it sometimes allows eta contraction.  bar x = f . g $ x -> bar = f . g       bar = f $ g   is a type error
06:39:10 <c_wraith> makalu: related to that, it means that more subexpressions are well-typed.  When you chain $ applications, you can't just pull a subexpression out of the middle and expect things to remain well-typed.  When you chain . applications, you can.
06:39:41 <quicksilver> more obvious if you have more than 2 functions. ( f . g . h . i $ x )
06:39:44 <c_wraith> makalu: where "pull a subexpression out" means pull a subexpression into its own named binding and use that name there.
06:39:56 <quicksilver> it's nice to notice that (f.g), (g.h), and (h.i) are all valid subexpressions
06:40:15 <quicksilver> they might be reusable or refactorable or independently testable or easy to reason about.
06:41:16 <makalu> so you worry about changing the code later. By that logic, shouldn't we always use "do" as well? Because you might want to expand it later?
06:42:00 <quicksilver> it's not just about changing it later
06:42:03 <c_wraith> That doesn't change how many subexpressions are well-typed
06:42:14 <quicksilver> it's about training yourself to think in a composable style
06:42:18 <quicksilver> because that will help you.
06:46:17 <augur_> quicksilver: for some definition of subexpression :)
06:46:37 <augur_> quicksilver: certainly in a normal sense they're not. the only subexpression mentioned is, afaik, (f.g)
06:47:11 <c_wraith> oh, don't be uselessly pedantic
06:47:16 <c_wraith> you know . is associative.
06:47:36 <augur_> yes, but thats an important fact that cant be ignored
06:48:00 <c_wraith> The fact that . is associative and $ isn't is a good point, I suppose.
06:48:28 <ski> @type (unlines . map unwords .) . (. map words . lines)
06:48:29 <lambdabot>     The operator `.' [infixr 9] of a section
06:48:29 <lambdabot>         must have lower precedence than that of the operand,
06:48:29 <lambdabot>           namely `.' [infixr 9]
06:48:50 <augur_> the associativity of (.) is an equational fact. if you define two levels of subexpression -- syntactic and semantic, where the semantic is defined in terms of syntactic + equations -- then you get all sorts of interesting consequences
06:49:18 <augur_> such as the claim that (\f y -> f x y) is a subexpression of g x w
06:49:22 <c_wraith> ski: does ghc 7.8 allow sections like that, or something?
06:49:28 <merijn> edwardk: ping?
06:49:35 <edwardk> pong
06:49:41 <augur_> because you can equationally rewrite this as  (\f y -> f x y) g w   and there its a syntactic subexp
06:49:55 <c_wraith> No, not 7.8
06:49:56 <merijn> edwardk: Is there any form of example for trifecta? :p
06:50:10 <edwardk> merijn: code that uses it mostly =)
06:50:31 <c_wraith> I could swear I saw something about an upcoming version of GHC allowing sections like those.
06:50:39 <augur_> c_wraith: so you see, its not pedantry, its an interesting and important distinction that ought to be discussed!
06:51:02 <merijn> edwardk: I'm a bit confused how things are supposed to fit together at the high level. I looked for reverse dependencies, but most of them seemed rather daunting as well (i.e. Idris >.>)
06:51:13 <ski> augur_ : perhaps inserting some quotes and unquotes in there could also make it more interesting
06:51:13 <edwardk> merijn: e.g. https://github.com/ermine-language/ermine/blob/master/src/Ermine/Parser/Kind.hs and https://github.com/ermine-language/ermine/blob/master/src/Ermine/Console/Command.hs#L121
06:51:37 <augur_> ski: hm?
06:52:04 <c_wraith> augur_: yet at the same time, it's meaningless from the standpoint of refactoring. Not using the formal definition doesn't change things at all there.
06:52:28 <augur_> c_wraith: is it? surely a great deal of refactoring involves recognizing these _semantic_ properties
06:52:39 <augur_> c_wraith: such as recognizing that some function you wrote is actually a map
06:52:57 <augur_> map is not a syntactic subexp, its a _semantic_ subexp, and you refactor precisely by recognizing this fact
06:53:07 <Galactic> does Data.List sort uses merge sort?  I am looking to sort 1 million integers. I think I should use Radix but I don't know if haskell has already that implemented.
06:53:10 <augur_> i would be that syntactic subexps are actually least relevant for refactoring
06:53:12 <c_wraith> augur_: now you're just ignoring the context.
06:53:18 <c_wraith> Galactic: it's a merge sort, yes
06:53:21 <augur_> c_wraith: maybe :)
06:53:37 <Galactic> c_wraith: k, thanks
06:54:12 <merijn> edwardk: There's a parseString but no parseText?
06:55:00 <quicksilver> augur_: it is undoubtedly an interesting interjection but I don't think it was relevant to my point (c_wraith's point)
06:55:08 <ski> augur_ :  ⌜g x w⌝  being equal to  (λ f ↦ λ y ↦ ⌜⌞f⌟ x ⌞y⌟⌝) ⌜g⌝ ⌜w⌝  and also to  (λ f ↦ λ y ↦ f ⌜x⌝ y) (λ x ↦ λ y ↦ ⌜g ⌞x⌟ ⌞y⌟⌝) ⌜w⌝  if you prefer
06:55:32 <quicksilver> augur_: haskell could perfectly well have been designed with (.) as a true associative connective.
06:55:48 <augur_> ski: you and your quine brackets
06:55:49 <quicksilver> and for reasoning about it, that is an appropriate view to take on it.
06:56:20 <augur_> quicksilver: i agree its the appropriate view for reasoning, but only because of the semantic aspects
06:57:30 <ski> augur_ : would you prefer the MetaML syntax ?
06:57:32 <augur_> quicksilver: its just as appropriate to imagine pulling out functions, turning   ... g x w ... g' x w' ...   into   let aux f y = f x y in ... aux g w ... aux g' w' ...
06:57:47 <c_wraith> Galactic: If you want to write your own radix sort, I bet you can do it really easily with http://hackage.haskell.org/package/array-0.5.0.0/docs/Data-Array-IArray.html#v:accumArray
06:57:58 <augur_> ski: i dont know what your QBs mean, let alone MetaML!
06:58:12 <ski> "QB" ?
06:58:17 <augur_> ski: quine bracket
06:58:20 <ski> oh
06:58:32 <augur_> but now you've made me type it, thus obviating the point of abbreviating!
06:58:35 <augur_> oh paradox
06:58:58 <quicksilver> augur_: it seems to me that you are saying "you're right, but only because you're right"
06:59:03 <quicksilver> thanks. I'm glad we agree.
06:59:07 <Fuuzetsu> augur_: but now you can use QB in future conversation, still saving keystrokes
06:59:10 <ski> ⌜⌞E⌟⌝  =  E  -- for any expression `E'
07:00:12 <ski> ⌞⌜E⌝⌟  =  E  -- for any expression `E' of the quoted language
07:00:12 <augur_> quicksilver: i agree you're right, for a very specific meaning of "subexpression" that deserves to be emphasized
07:00:40 <augur_> quicksilver: thats all i was saying -- that the usage here is somewhat non-standard (since subexps tend to be syntactically defined) and this warrants observation
07:00:58 <augur_> ski: maybe put that in a /msg?
07:01:15 <augur_> Fuuzetsu: let QB = quine bracket
07:11:22 * hackagebot optparse-applicative 0.8.0.1 - Utilities and combinators for parsing command line options  http://hackage.haskell.org/package/optparse-applicative-0.8.0.1 (PaoloCapriotti)
07:11:24 * hackagebot diagrams 1.1.0.1 - Embedded domain-specific language for declarative vector graphics  http://hackage.haskell.org/package/diagrams-1.1.0.1 (BrentYorgey)
07:31:23 * hackagebot snap 0.13.2.3 - Top-level package for the Snap Web Framework  http://hackage.haskell.org/package/snap-0.13.2.3 (DougBeardsley)
07:32:33 <Fuuzetsu> does anyone know if combinatorrent is a dead project? No updates for a year
07:36:30 <shapr> Hm, wasn't that a project by jlouis?
07:36:35 <c_wraith> yes
07:36:51 <shapr> and it's SUCH A GREAT NAME!
07:36:55 <shapr> I'm biased, I thought up that name.
07:37:49 <c_wraith> I think it's a great name, and I have no similar biases.
07:38:11 <Fuuzetsu> https://gist.github.com/samth/9641364 when is Haskell going to be runnable by node.js?
07:39:09 <c_wraith> "no download for haskell available"
07:39:14 <c_wraith> that's impressive failure to google
07:41:24 * hackagebot bitmap-opengl 0.0.1.5 - OpenGL support for Data.Bitmap.  http://hackage.haskell.org/package/bitmap-opengl-0.0.1.5 (BalazsKomuves)
07:41:47 <tdammers> Fuuzetsu: dafuq?
07:42:03 <tdammers> I mean, the Levenshtein distance is 1, but still
07:43:48 <Fuuzetsu> credit to edwardk for the link
07:44:11 <merijn> Fuuzetsu: wut
07:44:31 <merijn> Fuuzetsu: I feel I've been actively made dumber
07:45:14 <zomg> What on earth is that thing about? Why would you try to run .hs in node o_o
07:45:15 <Fuuzetsu> there are more in the gist linked inside of that gist
07:45:50 <zomg> oh, I think this is some weirdness where the idea is to reproduce things...
07:45:51 <zomg> :D
07:46:04 <RevJohnnyHealey> The relevant paper was "Formal specification of a JavaScript module system".
07:46:09 <zomg> reproduced that node doesn't run .hs, yeah... :D
07:46:19 <benj_> dependencies: nodejs (maybe)
07:46:26 <tdammers> Maybe NodeJS
07:46:29 <Fuuzetsu> zomg: the gist is about a study done about reproduciblity of research papers (click the link at the top). Someone then sat down and looked at the things they reported as not reproducible and found such pearls as the researcher marking as ‘can't reproduce’ because they didn't know how to get .hs files to run. They did best effort by trying to use node.js to run it
07:46:39 <benj_> you have to give the student credit for realising nodejs was only *maybe* necessary here.
07:47:04 <tdammers> maybe the student thought it was a typo
07:47:12 <tdammers> .hs, .js, same difference, right?
07:47:17 <Fuuzetsu> HyperScript
07:47:19 <Fuuzetsu> HaskellScript?
07:47:30 <tdammers> stupid computer, you'd think a machine this powerful should be able to figure out what you mean
07:47:32 <Fuuzetsu> original name, please don't steal
07:47:40 * heatsink wonders how the PLDI artifact evaluation process went
07:47:49 <zomg> Fuuzetsu: ahh... genius!
07:47:56 <Fuuzetsu> tdammers: ✓ misaki shana % file /tmp/Empty.hs
07:47:56 <Fuuzetsu> /tmp/Empty.hs: C++ source, ASCII text
07:47:57 <Fuuzetsu>  
07:47:58 <merijn> To get back to haskell...
07:48:00 <Fuuzetsu> ;(
07:48:24 <merijn> Suppose I have user state in ParsecT and a parser backtracks due to "try", will the user state reset to before it tried?
07:48:26 <tdammers> "it is forbiden please to steal towls. If you are not person to do such thing, please do not read this message."
07:48:38 <tdammers> (sign in a hotel room in tokio)
07:48:58 <tdammers> merijn: why don't you try?
07:49:02 <zomg> because hotels can't afford to hire a translator
07:49:02 <zomg> :D
07:49:04 <heatsink> Why do you steal towels, tdammers?
07:49:17 <merijn> tdammers: Because I'm lazy :(
07:49:19 <Fuuzetsu> tdammers: I must have read that years and years ago
07:49:36 <tdammers> heatsink: I don't. I disobey messages though.
07:49:51 <tdammers> also, I wasn't there myselfd
07:50:32 <quicksilver> merijn: I bet it doesn't.
07:50:43 <quicksilver> merijn: (I am also too lazy to try :P)
07:50:59 <heatsink> If you know about the message, it implies you're a thief.  Makes it hard to get it changed.
07:51:27 <heatsink> I guess hearsay gets around that
07:51:36 <quicksilver> merijn: looking at the types I guess the state backtracks
07:52:03 <tdammers> it's just a kind request
07:52:44 <tdammers> it just means that if you have read the message, you are either a person who (sometimes) steals towels, or a rude person who reads signs even when kindly requested not to, or both
07:53:31 <Fuuzetsu> or you are undefined
07:56:26 * hackagebot vect-opengl 0.4.6.1 - OpenGL support for the `vect' low-dimensional linear algebra library.  http://hackage.haskell.org/package/vect-opengl-0.4.6.1 (BalazsKomuves)
07:58:07 <tdammers> Fuuzetsu: that'd be too easy
08:06:27 * hackagebot http-conduit-downloader 1.0.14 - HTTP downloader tailored for web-crawler needs.  http://hackage.haskell.org/package/http-conduit-downloader-1.0.14 (VladimirShabanov)
08:06:29 * hackagebot definitive-graphics 1.0 - A definitive package allowing you to open windows, read image files and render text to be displayed or saved  http://hackage.haskell.org/package/definitive-graphics-1.0 (MarcCoiffier)
08:06:32 <augur_> does anyone know of a design discussion that tries to do a side-by-side comparison of OOP and FP approaches to actor-y systems?
08:08:03 <Peaker> Parsec not giving me the last user state[s] when it fails is really annoying :(
08:08:15 <Peaker> I want to be able to say where my parse error was #include'd from, and can't really do this properly
08:08:54 <MagneticDuck> any easy ways to get OpenGL to draw some scaled bitmaps on the screen?
08:08:56 <c_wraith> Galactic: if you're still around, and want a radix sort, http://lpaste.net/101452 is a reasonable starting point. It probably could be more efficient in a couple ways, but the benchmark results show what I'd expect.. Slower than merge sort on small lists, faster on large ones.
08:09:21 <Peaker> MagneticDuck: graphics-drawingcombinators
08:11:08 <c_wraith> Galactic: for instance, the radix sort could do fewer iterations if it knew the range of elements it was working on, instead of always assuming it's the full range.  tweaks like that.
08:16:28 * hackagebot lens 4.1 - Lenses, Folds and Traversals  http://hackage.haskell.org/package/lens-4.1 (EdwardKmett)
08:26:28 * hackagebot timezone-olson 0.1.4 - A pure Haskell parser and renderer for binary Olson timezone files  http://hackage.haskell.org/package/timezone-olson-0.1.4 (YitzGale)
08:31:29 * hackagebot definitive-parser 1.0 - A parser combinator library for the Definitive framework  http://hackage.haskell.org/package/definitive-parser-1.0 (MarcCoiffier)
08:33:48 <fizbin> Is there any way from a module to export everything in the module and also some collection of symbols from another module?
08:34:19 <fizbin> That is, I don't want to add an export list to this module because it creates a load of symbols I want to export through template haskell magic.
08:34:46 <fizbin> At the same time, I also wish to export these three symbols defined in a totally different module.
08:35:35 <fizbin> Can I do this, or am I going to have to create a third module to do nothing but import this module and export it along with some other symbols?
08:35:46 <geekosaur> you'll need a third module :(
08:36:18 <fizbin> Crud. Well, at least the third-module workaround isn't too bad.
08:36:29 * hackagebot definitive-sound 1.0 - A definitive package to handle sound and play it back  http://hackage.haskell.org/package/definitive-sound-1.0 (MarcCoiffier)
08:45:04 <Rembane> Good morning, I can't seem to make OpenGL+GLFW draw anything on screen, I've done a minimal example, could you take a look and give me directions? http://lpaste.net/101456
08:53:43 <skuggi> Is there any way to get type information into quasi-quotation in TH like this: http://lpaste.net/101457 ?
08:54:52 <skuggi> I'm assuming it's not possible, but I would like to be certain.
08:58:22 <joelteon> skuggi: you'd have to splice it
08:58:24 <joelteon> $(a)
08:58:39 <joelteon> which requires that 'a' be a TypeQ\
08:59:09 <joelteon> or I might be incorrect
09:06:11 <skuggi> I should make the example more clear
09:07:07 <skuggi> http://lpaste.net/101457
09:09:04 <skuggi> What I'm wondering is if there is some way get the code inside the quotation to use the "right". "Right" meaning the one that would be used outside the quotation.
09:09:42 <skuggi> s/"right"/"right" instance/
09:10:41 <haskell_newb> hi, are haskell macros hygienic?
09:11:05 <quchen> Haskell doesn't have macros.
09:11:06 <Kron> haskell macros meaning template haskell?
09:11:14 <Kron> because haskell itself has no such lispy macro support
09:11:26 <Kron> I think it does allow some C preprocessor style stuff, though I amn't sure
09:13:09 <haskell_newb> isn't template haskell a macro system?
09:13:17 <Kron> pretty much
09:13:27 <Kron> template haskell isn't haskell proper, though
09:13:35 <Kron> it's a kind of extended optional system on top
09:13:46 <haskell_newb> Kron: so is it hygienic?
09:13:58 <tdammers> haskell_newb: yes, sort of
09:14:43 <tdammers> think of it as an extra compilation step that compiles template haskell (which is just haskell coded against some library)
09:15:00 <haskell_newb> tdammers: when i'm hearing about "sort of" hygienic macro system i'm thinking about gensym workardound, is that what TH does?
09:15:07 <Kron> I'm not quite sure to be honest, never used it. But yeah I think it's hygienic? It itself has its own elaborate function system and type checking and things...
09:15:38 <tdammers> the compiled template haskell is then run and outputs data structures which are inserted into the actual compilation step
09:16:08 <Kron> it's true that template haskell can insert symbols into normal haskell though
09:16:15 <Kron> I'm not sure if there's a gensym system
09:16:25 <tdammers> it's hygienic in the sense that if the types for the TH compilation don't check out, you get an error, and if the output produces something that doesn't check out in the actual compilation, you also get an error
09:16:41 <merijn> Isn't the entire reason you want hygienic macro's from your macro's "leaking" names at runtime?
09:16:44 <tdammers> you can't bypass type checks with TH anymore than you can bypass them with regular haskell
09:17:18 <merijn> I don't think the question is entirely well-formed anyway
09:17:19 <haskell_newb> merijn: yep, it's pretty much it
09:17:29 <Kron> and yet, Safe Haskell disallows template haskell entirely
09:17:40 <merijn> haskell_newb: Right, but this doesn't apply to TH as there is no Template Haskell at runtime
09:17:41 <Kron> I'm pretty sure you can do /some/ squirrely shenanigans in it
09:17:46 <quchen> (Pedantic remark, Template Haskell is a GHC extension and not strictly Haskell.)
09:17:57 <haskell_newb> merijn: yeah, tdammers explained it
09:18:03 <haskell_newb> thank you for explanation!
09:18:16 <Kron> I'm surprised that you'd ask that question, to be honest
09:18:25 <Kron> is macro support one of the first considerations one makes with a new language?
09:18:30 <haskell_newb> Kron: why? do you know me?
09:18:33 <Kron> I guess if you're a lisper
09:18:37 <Kron> just wondering I guess
09:18:42 <haskell_newb> Kron: ha-ha, yeah
09:18:49 <Kron> common lisper myself
09:19:10 <augur_> hey, more people are talking
09:19:10 <Kron> in general I've found that the raw expressability of the composition system in haskell kind of invalidates the need for a lot of the macros i'm used to using
09:19:24 <Kron> that being said, the type systems can get a bit boilerplatey
09:19:25 <merijn> TH is less powerful than a true macro system, but many things you can do with macro's can also be achieved by laziness
09:19:27 <augur_> merijn, quicksilver, tdammers: how tdo you write actor-y code in haskell
09:19:39 <merijn> augur_: forkIO + Chan? :p
09:19:42 <Kron> I know there's some TH in the lens library to define lenses for your data fields in ADTs you define
09:19:47 <haskell_newb> there are still a lot boilerplate one might not want to write
09:19:50 <augur_> merijn: :P
09:19:53 <haskell_newb> for exaple lens boilerplate
09:19:57 <Kron> I've spent most of my life doing common lisp, I'm learning haskell now, and I haven't really missed macro functionality yet
09:20:00 <augur_> merijn: how do you do it without simulating objects!
09:20:06 <Kron> yeah, lens boilerplate is the only place I've run into it and been tempted to use it
09:20:15 <merijn> augur_: Why would actors need objects? Threads are the actors
09:20:24 <tdammers> I think Safe Haskell and TH don't go together because the kind of assertions Safe Haskell gives you would require compiling and running the TH
09:20:33 <davidthomas> TH is used to pretty good effect in Yesod (though I guess that's a bit controversial :-P)
09:21:03 <augur_> merijn: hm. i dont know much about haskell's threading
09:21:05 <haskell_newb> davidthomas: there are rewrite of yesod without TH going on currenlt AFAIK. :)
09:21:16 <MP2E> are most language extentions controversion? Or is it mainly TH
09:21:18 <haskell_newb> Kron: tempted? so you actually found a reason not to use it and resisited your temptation?
09:21:33 <MP2E> controversial*
09:21:34 <merijn> MP2E: I would say TH isn't controversial either
09:21:37 <Kron> yeah, learning, really
09:21:40 <augur_> merijn: i was just thinking in terms of like.. you conceptualize a problem in terms of multiple independent stateful agents. OO gives this concrete reality, but FP doesnt. so whats the FP idiom that does this instead
09:21:40 <MP2E> ah
09:21:51 <merijn> augur_: It's just lightweight threads being scheduled on a pool of OS threads
09:21:59 <Kron> I wanted to know how to define lenses
09:22:04 <Kron> what those lens definitions do
09:22:09 <Kron> so I did it myself
09:22:09 <merijn> augur_: You can easily have several thousand, if not several hundred thousands forkIO threads
09:22:10 <davidthomas> haskell_newb: Not rewrite, just support, for those who don't want the TH
09:22:19 <haskell_newb> Kron: ah, okay
09:22:21 <davidthomas> (at least, that's what I'm aware of)
09:22:22 <augur_> merijn: but is that necessarily the right approach? i mean, if we want to think of event handling responders in a UI framework like that, for instance
09:22:32 <merijn> MP2E: I would say that UndecidableInstances, OverlappingInstances and IncoherentInstances are controversial
09:22:42 <augur_> merijn: we want to think of these things talking to one another. do we want to have threads for that? that seems like overkill
09:22:46 <Kron> soometimes I can see some boilerplatey bits?
09:22:54 <haskell_newb> another question, i have some silly issues with type system...
09:22:57 <Kron> Tree a = Branch (Tree a) (Tree a) (Tree a) (Tree a) etc.
09:23:01 <merijn> MP2E: Most other extensions are not controversial (well, they're not portable beyond GHC, but if you accept that fact they're not controversial)
09:23:04 <haskell_newb> > let f x = (x,x)
09:23:08 <lambdabot>  not an expression: `let f x = (x,x)'
09:23:12 <haskell_newb> what the type of f?
09:23:21 <Kron> anything, really
09:23:25 <MP2E> That's fine with me, are there any other haskell compilers commonly used besides GHC?
09:23:25 <edwardk> Kron: you may want to look at Plated instances for that Tree as well.
09:23:31 <Kron> oh wait
09:23:32 <Kron> I see
09:23:34 <Kron> f is the function
09:23:35 <quchen> :t let f x = (x,x) in f -- haskell_newb
09:23:37 <merijn> augur_: Why does that seem overkill?
09:23:38 <Kron> then it's a -> (a,a)
09:23:39 <lambdabot> t -> (t, t)
09:23:41 <merijn> MP2E: Not really :p
09:23:42 <tdammers> haskell_newb: `let` on its own isn't allowed outside a `do` block
09:23:44 <augur_> merijn: UIs are a typical example where OO feels natural (as is game design), because we like to think of things-with-capacities-interacting
09:23:49 <Kron> it takes in x and returns (x,x)
09:23:50 <haskell_newb> > let f x = (x,x) in f
09:23:50 <heatsink> augur_: There's an OO pattern where you use an ADT to hold the public methods of an object.
09:23:53 <lambdabot>  No instance for (Data.Typeable.Internal.Typeable t0)
09:23:53 <lambdabot>    arising from a use of `M693835992089408118913529.show_M6938359920894081189...
09:23:53 <lambdabot>  The type variable `t0' is ambiguous
09:23:53 <lambdabot>  Possible fix: add a type signature that fixes these type variable(s)
09:23:53 <lambdabot>  Note: there are several potential instances:
09:24:00 <edwardk> e.g. instance Plated (Tree a) where plate f (Branch a b c d) = Branch <$> f a <*> f b <*> f c <*> f d
09:24:04 <merijn> MP2E: There's the Utrecht haskell compiler, there's a few other experimental ones, but GHC is pretty much the only production compiler
09:24:05 <haskell_newb> > let f x = (x,x) in f :: a -> (a,a)
09:24:06 <lambdabot>  No instance for (Data.Typeable.Internal.Typeable a0)
09:24:06 <lambdabot>    arising from a use of `M882555996605836308813538.show_M8825559966058363088...
09:24:06 <lambdabot>  The type variable `a0' is ambiguous
09:24:06 <lambdabot>  Possible fix: add a type signature that fixes these type variable(s)
09:24:06 <lambdabot>  Note: there are several potential instances:
09:24:07 <augur_> merijn: well i dont know, it just seems like its unnecessary to use fancy threading junk for this
09:24:14 <Kron> haskell_newb: ":t"
09:24:18 <merijn> augur_: Who says it's fancy?
09:24:20 <Kron> :t just declares the calculated type
09:24:21 <augur_> heatsink: yeah, but i want to avoid simulating OO. i want to know what the idiomatic way is
09:24:24 <lambdabot> parse error on input `type'
09:24:24 <augur_> merijn: i do!
09:24:26 <Kron> :t let f x = (x,x) in f
09:24:27 <lambdabot> t -> (t, t)
09:24:32 <Kron> it doesn't try to evaluate it
09:24:37 <Kron> functions themselves are unprintable
09:24:41 <edwardk> Kron: if you have lens questions and aren't getting answers, feel free to ask in #haskell-lens as well.
09:24:44 <Kron> which I honestly find a liiiitle bit annoying
09:24:44 * edwardk has to run.
09:24:54 <haskell_newb> Kron: thanks
09:24:56 <merijn> augur_: For a UI I wouldn't find it weird to spawn lots of threads for different widgets
09:25:10 <tdammers> > let f x = (x,x) in f "foobar"
09:25:12 <lambdabot>  ("foobar","foobar")
09:25:29 <merijn> MP2E: Most extensions either allow for more type safety or a more expressive type system, so in general they will not make your code less typesafe
09:25:42 <augur_> merijn: maybe. i mean, im not saying its a bad answer, it just seems less idiomatically FP and more like a simulation of objects using threads instead
09:25:52 <tdammers> :t (let f x = (x,x) in f)
09:25:55 <MP2E> Excellent :) I won't be phobic of extensions then
09:25:55 <lambdabot> t -> (t, t)
09:25:56 <augur_> merijn: also im not sure how statefulness is handled in that situation, but thats ok
09:26:28 <merijn> MP2E: Here's a decent list: https://stackoverflow.com/questions/10845179/which-haskell-ghc-extensions-should-users-use-avoid
09:26:40 <Kron> MP2E: if you're worried about typesafety, just activate the Safe language extension
09:26:42 <Kron> and go crazy
09:26:48 <Kron> I use scoped type variables and rank 2 types
09:27:13 <merijn> MP2E: The "good" list is mostly accurate, I would say "ExistentialQuantification" is often misused, so you should be suspicious if you think you want it
09:27:34 <merijn> MP2E: And GeneralisedNewtypeDeriving *can* break things, but should be safe for the most common usecase
09:27:50 <MagneticDuck> Say I have module A, and module B. Whenever I use module A, I end up using one particular definition from module B, and so I might find it handy to export that single definition from module A itself. However, if I then import module B in the code, I will get a conflicting definition error, right?
09:27:58 <merijn> MP2E: The others in the good list are fine
09:28:13 <MagneticDuck> not conflicting, duplicate
09:28:18 <merijn> MagneticDuck: Nope
09:28:19 <MP2E> Thanks for the info, wow, I had no idea there were so many o.O
09:28:22 <MagneticDuck> merijn: oh cool
09:28:25 <MagneticDuck> that's very nice
09:28:36 <merijn> MagneticDuck: Well, you mean you have module C importing A and B, and A exports something from B, right?
09:29:13 <MagneticDuck> module C is importing module B and module A. module A imports module B and exports a single definition from that module.
09:29:27 <merijn> MagneticDuck: I think that should just work, but I don't dare say
09:29:34 <MagneticDuck> okay well I'll try it
09:29:38 <merijn> MagneticDuck: FYI, you can do "import A hiding (foo)"
09:30:05 <quchen> MagneticDuck: Identically named definitions imported from different modules are not an issue, unless you actually use them in the importing module.
09:30:22 <MagneticDuck> merijn: yeah I can do that too
09:30:22 <ystael> Kron: i kind of wish functions had a default Show instance that printed their type ... is there some reason why that's not possible?
09:30:23 <quchen> In that case, it might help to import "as A" and "as B".
09:30:38 <quchen> i.e. a non-qualified import with name
09:30:41 <merijn> ystael: It is, lambdabot has it :)
09:30:43 <MagneticDuck> yeah I do that all the time
09:30:50 <merijn> ystael: Only works for non-polymorphic function, though
09:30:54 <MagneticDuck> I was just wondering how ghc / cabal deals with that by default
09:30:55 <Kron> ystael: as far as I can tell, no, it's possible
09:30:57 <merijn> > (+1) :: Int -> Int
09:30:59 <Kron> it'show ocaml does it
09:31:00 <lambdabot>  <Int -> Int>
09:31:21 <merijn> > isSpace
09:31:22 <lambdabot>  <Char -> Bool>
09:31:32 <Kron> > let f x = (x,x) in f
09:31:34 <lambdabot>  No instance for (Data.Typeable.Internal.Typeable t0)
09:31:34 <lambdabot>    arising from a use of `M399714669753433430913588.show_M3997146697534334309...
09:31:34 <lambdabot>  The type variable `t0' is ambiguous
09:31:34 <lambdabot>  Possible fix: add a type signature that fixes these type variable(s)
09:31:34 <lambdabot>  Note: there are several potential instances:
09:31:47 <merijn> Kron: That's polymorphic :)
09:31:50 <Kron> heh
09:31:59 <quchen> ystael: It would be possible to write such an instance, but you shouldn't do that because https://github.com/quchen/articles/blob/master/fbut.md#show-is-not-for-prettyprinting
09:33:07 <quchen> In 7.8 there will be the handy trick of using (`asTypeOf` _) to get a "function that prints its argument's type on compilation".
09:33:21 <bennofs> Hmm, is there something I can use to derive show instances that do not use the names of the fields? For example, I'd like show (Position x y) = "Position x y" instead of "Position { _xCoord = x, _yCoord = y }"
09:33:43 <Kron> I understand that show is not for prettyprinting
09:33:46 <merijn> bennofs: No, you'll have to write it yourself, I think
09:33:52 <Kron> but in this case it would make debugging way way easier
09:34:03 <bitonic> is there a way to run a finalizer when a thread gets garbage collected?
09:34:12 <Kron> I'd like to be able to kind of throw out half curried functions onto GHCi
09:34:12 <heatsink> > show (ErrorCall "fixme")
09:34:15 <Kron> and see what I need to fill in
09:34:16 <lambdabot>  "fi
09:34:18 <Taneb> > fmap `asTypeOf` Control.Category.(.)
09:34:19 <lambdabot>  Not in scope: data constructor `Control.Category'Precedence parsing error
09:34:19 <lambdabot>      cannot mix `GHC.Base.asTypeOf' [infixl 9] and `GHC.Base..' [infixr 9] in...
09:34:28 <Taneb> > fmap `asTypeOf` (Control.Category..)
09:34:30 <lambdabot>  Not in scope: `Control.Category..'
09:34:34 <Taneb> :(
09:34:38 <bitonic> will `addFinalizer' on the `ThreadId' work?
09:34:50 <heatsink> quchen: exceptions use show for pretty-printing though
09:35:10 <merijn> bitonic: Why not just add the finalizer to the forkIO call?
09:35:17 <merijn> @hoogle forkFinally
09:35:18 <lambdabot> No results found
09:35:21 <merijn> hmmm
09:35:28 <bennofs> @ty forkFinally
09:35:30 <bitonic> merijn: you mean add a finalizer on the `ThreadId'?
09:35:31 <lambdabot> Not in scope: `forkFinally'
09:35:39 <bitonic> I need to add the finalizer from the thread itself anyway
09:35:47 <merijn> bitonic: No: forkFinally :: IO a -> (Either SomeException a -> IO ()) -> IO ThreadId
09:36:17 <bitonic> merijn: that doesn't work, I need to do that from inside the thread
09:36:19 <merijn> bitonic: Wrap forkIO, have an MVar with a finalizer and then use something like forkFinally to read the finalizer from the MVar and call it?
09:36:37 * hackagebot folds 0.6 - Beautiful Folding  http://hackage.haskell.org/package/folds-0.6 (EdwardKmett)
09:36:49 <bitonic> merijn: I can't rely on threads being forked the way I want it
09:37:01 <merijn> Then you're boned, I think :)
09:37:03 <bitonic> for example I want to use it with threads forked by snap
09:38:09 <merijn> bitonic: "WARNING: weak pointers to ordinary non-primitive Haskell types are particularly fragile, because the compiler is free to optimise away or duplicate the underlying data structure. Therefore attempting to place a finalizer on an ordinary Haskell type may well result in the finalizer running earlier than you expected. This is not a problem for caches and memo tables where early finalization is benign."
09:38:42 <merijn> ThreadId is not primitive, so attaching a finalizer is ot safe
09:38:56 <bitonic> merijn: ThreadId is primitive as much as IORef/MVar or other things considered safe
09:38:59 <bitonic> *is as primitive
09:39:04 <merijn> No
09:39:19 <merijn> "data ThreadId = ThreadId ThreadId#" <- not a primitive type
09:39:42 <bitonic> merijn: so, what do you mean by primitive type?  is IORef primitive?
09:39:59 <merijn> bitonic: IORef is also not primitive
09:40:10 <merijn> bitonic: That's why "mkWeakIORef" exists
09:40:23 <merijn> bitonic: Primitive as-in, Cmm built-in in GHC
09:41:23 <Galactic> could someone give me an example of how can I create an array like  [0,0,0,0,0]  using Data.Arrays.IO?
09:41:57 <joneshf-laptop> whoa
09:42:05 <joneshf-laptop> does this mean what i think it means:
09:42:07 <joneshf-laptop> No instance for (Functor Foo)
09:42:07 <joneshf-laptop>   arising from the superclasses of an instance declaration
09:42:07 <joneshf-laptop> Possible fix: add an instance declaration for (Functor Foo)
09:42:07 <joneshf-laptop> In the instance declaration for `Applicative Foo'
09:42:12 <bitonic> merijn: right.  with IORef it is safe though, because we avoid the duplication
09:42:12 <bitonic> and also addFinalizer can't be used with primitive types as you define them anyway
09:42:12 <bitonic> in any case it definitely wouldn't work with ThreadId
09:42:32 <bitonic> even without the duplication issue
09:42:35 <merijn> If it doesn't have a # in it, it's probably not primitive
09:42:41 <joneshf-laptop> oh, apparently it doesn't
09:42:46 <joneshf-laptop> sorry for the spam
09:43:11 <bitonic> merijn: IORef/MVar for sure
09:43:11 <dv-> Galactic: newArray (0,4) 0?
09:43:16 <merijn> bitonic: Right, which is why IORef and MVar have their own explicit functions for attaching finalizers
09:43:35 <bitonic> merijn: yeah but you can stay safe with things like IORefs
09:43:48 <merijn> bitonic: The problem isn't just duplication, but also the fact that ThreadId may be prematurely GCed and then finalizer run too early
09:43:50 <c_wraith> Galactic: did you see my messages to you a couple hours back?
09:43:58 <bitonic> since the compiler won't be free to duplicate those
09:44:11 <merijn> (Yes, all of this sucks)
09:44:15 <bitonic> merijn: `addFinalizer' is fine for IORefs
09:44:27 <bitonic> merijn: oh I agree with the ThreadId bit
09:44:32 <merijn> bitonic: It can duplicate IORef's, but not the MutVar# inside, which is what mkWeakIORef uses
09:44:32 <merijn> bitonic: Not according to the docs
09:44:43 <quchen> Galactic: http://lpaste.net/101460
09:44:48 <merijn> The docs explicitly say to use mkWeakIORef to attach the finalizer to the internal MutVar#
09:45:23 <Galactic> c_wraith: yeap but I don't want a raix sort now :)  because I have to sort 1 million 32 bit numbers and there is a faster way to do that.
09:45:39 <bitonic> merijn: mhm... I don't see how it can duplicate an IORef
09:45:42 <schell> ReinH: did you make the original haskellive webcasts?
09:46:01 <Fuuzetsu> default associativity of the infix syntax is to the left, right?
09:46:05 <haroldcarr> I've been banging my head trying to use Aeson to parse Bitly responses.  Could someone give me a hint as to what Haskell types should be defined and how to use Aeson to then parse the following into those types?:
09:46:05 <haroldcarr>  
09:46:05 <haroldcarr> BITLY EXPAND RESPONSE
09:46:05 <haroldcarr> {
09:46:08 <haroldcarr>   "data": {
09:46:09 <Fuuzetsu> say, a `Cons` b `Cons` c
09:46:11 <haroldcarr>     "expand": [
09:46:13 <haroldcarr>       {
09:46:16 <merijn> Fuuzetsu: Default fixity is infixl 9
09:46:17 <haroldcarr>         "global_hash": "900913",
09:46:18 <Galactic> quchen: thant helped
09:46:20 <haroldcarr>         "long_url": "http://google.com/",
09:46:23 <haroldcarr>         "short_url": "http://bit.ly/ze6poY",
09:46:23 <Fuuzetsu> merijn: alright
09:46:26 <MagneticDuck> haroldcarr: use a pasting site.
09:46:26 <haroldcarr>         "user_hash": "ze6poY"
09:46:29 <haroldcarr>       }
09:46:31 <merijn> haroldcarr: Don't spam
09:46:32 <haroldcarr>     ]
09:46:33 <Fuuzetsu> it's too late, he can't stop it
09:46:33 <bitonic> merijn: OK, I don't think it can be duplicated but apparently the boxed version can be optimized away, thanks
09:46:36 <haroldcarr>   },
09:46:37 * hackagebot QuadTree 0.10.0 - QuadTree library for Haskell, with lens support.  http://hackage.haskell.org/package/QuadTree-0.10.0 (Kron)
09:46:39 <haroldcarr>   "status_code": 200,
09:46:40 <MagneticDuck> rofl haroldcarr
09:46:42 <haroldcarr>   "status_txt": "OK"
09:46:43 <haroldcarr> }
09:46:46 <haroldcarr>  
09:46:47 <quchen> kill -9 the client works, Fuuzetsu.
09:46:50 <haroldcarr> BITLY SHORTEN RESPONSE
09:46:53 <haroldcarr> {
09:46:56 <MagneticDuck> ROFL
09:46:56 <haroldcarr>   "data": {
09:46:57 <Fuuzetsu> quchen: so does a kick so I recommend that
09:46:58 <MagneticDuck> MORE?!?!
09:46:58 <merijn> @where ops
09:46:58 <lambdabot> arjanb bos byorgey Cale conal copumpkin dcoutts dibblego dmhouse dolio dons edwardk elliott geekosaur glguy Heffalump Igloo jmcarthur johnw kosmikus Lemmih monochrom nyc Philippa Pseudonym quicksilver roconnor Saizan shachaf shapr sjanssen ski sorear SyntaxPolice xerox
09:46:59 <haroldcarr>     "global_hash": "900913",
09:47:03 <haroldcarr>     "hash": "ze6poY",
09:47:06 <haroldcarr>     "long_url": "http://google.com/",
09:47:09 <haroldcarr>     "new_hash": 0,
09:47:10 --- mode: ChanServ set +o geekosaur
09:47:14 <haroldcarr>     "url": "http://bit.ly/ze6poY"
09:47:14 <haroldcarr>   },
09:47:16 <haroldcarr>   "status_code": 200,
09:47:19 --- kick: haroldcarr was kicked by geekosaur (haroldcarr)
09:47:19 --- mode: ChanServ set +o shapr
09:47:25 <shapr> geekosaur: beat me to it, thanks
09:47:34 <Galactic> lol
09:47:42 * geekosaur trying to do too many things at once
09:47:55 <Fuuzetsu> maybe you could use more ops *hint hint*
09:49:37 <shapr> geekosaur: I told haroldcarr in privmsg that using a pastebin means he won't get kicked
09:50:18 <shapr> Or at least, he won't get kicked for paste spam
09:50:28 <bergmark> ;)
09:50:36 <shapr> Man, that's a bunch of users here on #haskell
09:51:02 <bergmark> shapr: does it make you feel powerful? :)
09:51:21 <quchen> shapr: Little did you know about the consequence of your actions a decade ago
09:51:21 <shapr> bergmark: It makes me feel that the #haskell community is powerful :-)
09:51:42 <shapr> quchen: Truly, I did not think #haskell would continue to be this popular.
09:51:51 --- mode: geekosaur set -o geekosaur
09:52:00 <shapr> quchen: nearly 13 years ago now :-)
09:52:03 <bergmark> wow such a humble master
09:52:32 <shapr> bergmark: psh, I'm not the master of #haskell
09:52:54 <shapr> howdy haroldcarr, did you use a pastebin to show your problem?
09:53:06 <quicksilver> shapr: you are not master, you are the almighty creator.
09:53:31 <shapr> psh, I'm just the guy who bootstrapped #haskell into a community. Doesn't make me the master or creator.
09:53:48 <quchen> shapr: Only the true Messiah denies His divinity.
09:54:05 <shapr> quchen: or people who know themselves :-P
09:54:06 <haroldcarr> Apologies to all.  New to IRC.  Here is my question regarding parsing Bitly JSON responses with Aeson: http://lpaste.net/101461
09:54:49 <quicksilver> haroldcarr: Aeson supports three approaches.
09:55:10 <quicksilver> (1) you can use it's catch-all "Value" type, which is a big ADT which supports all of JSON
09:55:29 <quicksilver> (2) you can use the instances it provides for built-in types (lists, Maps, etc) which relate to JSON types
09:55:47 <quicksilver> (3) you can write your own custom data type which is an exact match, and write your own 'fromJSON' instance.
09:55:59 <quicksilver> actually you can mix parts of each.
09:56:38 * hackagebot QuickCheck 2.7 - Automatic testing of Haskell programs  http://hackage.haskell.org/package/QuickCheck-2.7 (NickSmallbone)
09:57:29 <quicksilver> haroldcarr: I'd recommend you use (3) for the top-level data type, at least.
09:57:47 <archblob> where would one report and send a patch for a function from base, Data.List ?
09:58:04 <quicksilver> and you could wimp out and use Map String String to represent the stuff inside the 'data' element.
09:58:19 <quicksilver> archblob: libraries@haskell.org I think.
09:58:37 <quicksilver> archblob: although you can report the bug on the GHC trac
09:58:39 <haroldcarr> @quicksilver: here is what I have tried so far: https://github.com/haroldcarr/learn-haskell-coq-ml-etc/blob/master/haskell/paper/haroldcarr/bitly-client/src/BitlyClientResponses.hs
09:58:40 <lambdabot> Unknown command, try @list
09:58:41 <quchen> archblob: What's the issue?
09:59:21 <quicksilver> haroldcarr: looks like the right kind of approach.
09:59:27 <haroldcarr> @list
09:59:27 <lambdabot> What module?  Try @listmodules for some ideas.
09:59:28 <archblob> quicksilver: oh god, so much paperwork :-P, maximumBy is incorredt, it should be LT in place of GT
09:59:40 <quicksilver> really?
09:59:44 <archblob> quicksilver: yes
10:00:02 <archblob> quicksilver: I'm just writing some tests for vector
10:00:23 * haroldcarr list
10:00:24 <archblob> quicksilver: at first i thought it was there, but no, it's base
10:00:32 <quicksilver> > maximumBy (comparing fst) [(1,'a'),(3,'b'),(2,'c')]
10:00:34 <quchen> Looks correct to me
10:00:35 <lambdabot>  (3,'b')
10:00:43 <quicksilver> archblob: ^^ is that wrong?
10:01:19 <quicksilver> haroldcarr: it's complaining because you used @ to address me and it though you were addressing hte bot.
10:01:25 <archblob> quicksilver: http://hackage.haskell.org/package/base-4.6.0.1/docs/src/Data-List.html#maximumBy
10:01:58 <archblob> quicksilver: it's implemented the same as minimumBy
10:02:07 <quchen> No, it's not
10:02:14 <quchen> x and y are switched in the case results
10:03:34 <archblob> quicksilver: you are right, i have to take a closer look
10:03:43 <quicksilver> :)
10:04:20 <Kron> k
10:04:31 <Kron> sorry, wrong channel
10:09:04 <eacameron> maybe I'm just complaining, but why can I not make operators that have alphanumeric letters somewhere in them, like (<t>) or something
10:09:57 <quchen> eacameron: It's not possible to do that.
10:10:13 <c_wraith> eacameron: because the lexer needed rules.  The rule they decided upon was that <t> would count as 3 tokens..  2 operators and one identifier.
10:10:15 <eacameron> quchen: I know...that's why I'm complaining :(
10:10:27 <Kron> I feel your pain :(
10:10:31 <eacameron> c_wraith: I suppose that makes sense
10:10:52 <Kron> I wish I could make lisp-symbol-names
10:10:58 <Kron> I prefer it to camelCase
10:11:03 <eacameron> I guess `t` is better than what I get in most languages anyway
10:11:08 <eacameron> Kron: yeah...that is nice
10:11:19 <c_wraith> eacameron: You could theoretically come up with an alternate set of lexer rules that uses whitespace more, such that <t> counted as a single token, but it would have the side effect of making something like (<foo) be a double-sided section of the operator <foo
10:11:24 <Kron> I know standardization of style is a great idea
10:11:26 <eacameron> Kron: but I suppose it's easier to do that with a syntax as simple as lisp's
10:11:30 <Kron> but camelCase brings back traumatic Java memories
10:12:08 <eacameron> c_wraith: fair point
10:12:13 <c_wraith> eacameron: Agda, for instance, has lexing rules more like that.  (I'm not sure if it goes that far, but whitespace is required between tokens in a lot more cases)
10:12:47 <Platz> would it be fair to say Vector is nice for reading (indexing), but not good for updates?  cons and snoc are O(n)
10:12:57 <eacameron> c_wraith: Interesting. with haskell's parsing power, it's a wonder there aren't more "flavors" of it out there...custom syntaxes that compile to haskell
10:13:53 <jbkcc> hi all, i have a slightly involved question about idiomatic haskell that's been bugging me for a while -- mind if i ask?
10:14:02 <c_wraith> Platz: it's a single allocation of contiguous memory.  That makes it good for indexing and for efficient use of memory.  It makes it bad for changing the size.
10:14:20 <eacameron> Platz: my impression is that Vector is best for mutable memory in IO or as frozen data in the pure world (don't change it)
10:14:43 <eacameron> Platz: fusion helps in that regard, but it's still not exactly what you want if you want lots of updates
10:14:52 <c_wraith> jbkcc: of course! we (usually) like to answer questions about idiomatic haskell.  Or maybe argue about potential answers to questions about idiomatic haskell. :)
10:15:14 <Kron> jbkcc: don't bother asking if you can ask, just ask! :)
10:15:20 <eacameron> Platz: there are other types (stricter than []) that have great update properties in the pure world
10:15:24 <quchen> Platz: It's O(n) because to change a single element, you have to copy the entire vector (due to immutability).
10:15:29 <jbkcc> in c, it's possible to keep two views of a single object by keeping two pointers to the same part of memory. when you change the underlying object by using the first pointer and view it with the second pointer, you can see the change in the second place
10:15:54 <jbkcc> how would you do something like this in haskell?
10:16:08 <Kron> You can't, be design. Or well, that's not quite true, you can fake it.
10:16:15 <jbkcc> by "this" i mean keeping multiple views of a single object
10:16:16 <eacameron> jbkcc: first question would be why do you want to
10:16:19 <Kron> Immutability means /everything/ is passed by reference / pointer
10:16:22 <Kron> it's called sharing
10:16:33 <Kron> you actually already have multiple views on the same object automatically, it's just immutable
10:16:43 <davidthomas> You have to have an explicit "handle to single mutable thing"
10:16:46 <jbkcc> ah! makes sense
10:16:49 <Kron> what you want is some kind of fake state that modifies and the pointers point to the new thing
10:16:51 <davidthomas> like an IORef
10:16:57 <Platz> good stuff.. thanks all
10:17:00 <Kron> right, or even a State monad
10:17:10 <jbkcc> hmm, ok
10:17:15 <davidthomas> or TVar or something
10:17:24 <Kron> jbkcc: when you do "x = y", x becomes a pointer to y
10:17:40 <davidthomas> but most of the time the answer is "you don't *actually* want sharing"
10:17:42 <Kron> > let xs = 1 : xs in (take 10 xs)
10:17:46 <lambdabot>  [1,1,1,1,1,1,1,1,1,1]
10:17:49 <Kron> infinite list ^
10:17:57 <Kron> everything you do is trivially like that, implicitly
10:18:14 <jbkcc> ok
10:18:16 <Kron> I say start with the State monad
10:18:21 <jbkcc> so well i guess i don't really want sharing
10:18:30 <jbkcc> what i want is when i change something here, it changes over there too
10:18:32 <Kron> the State monad is a way of basically passing around an invisible new parameter to sequences of functions
10:18:38 <jbkcc> i'm thinking mostly in the context of user interface programming
10:18:43 <Kron> and each function returns a new output thati s passed as that invisible input to the next function
10:18:46 <Kron> so you kind of 'fake' a state
10:18:53 <jbkcc> a gui affords both a view and a perturbation operation on an object
10:18:54 <Kron> by passing around a value that doesn't boilerplate up your code
10:19:13 <eacameron> jbkcc: davidthomas is right that if you actually want that behavior (shared mutable state), then you are no longer in the happy pure world
10:19:26 <Kron> you can use an IOref, yeah
10:19:33 <davidthomas> jbkcc: each GUI action takes some state and returns some state
10:19:53 <Kron> but he's asking for the idiomatic way to do it in haskell
10:19:56 <jbkcc> well, this part i get about the taking and returning state in gui
10:20:02 <davidthomas> Probably the easiest way to frame this is to put it in a State monad
10:20:08 <davidthomas> but it depends a tiny bit
10:20:08 <jbkcc> but how do i keep that state relevant to other parts of the program?
10:20:23 <Kron> and that means rephrase mutability as "the views take in an argument which is the current state of the UI" and you pass around modified state values
10:20:24 <eacameron> jbkcc: the other parts are in the same state monad
10:20:25 <jbkcc> since their references to the object will all be invalid after the mutation?
10:20:36 <davidthomas> jbkcc: Serialize events, and always operate on the "current state"
10:20:46 <Kron> what davidthomas said
10:20:56 <monochrom> if you plan to do MVC properly, I am not convinced that you must used a shared mutable cell. in fact it looks to me MVC's intention is to have C send a message to M, and M send a message to V
10:21:26 <Kron> jbkcc: http://learnyouahaskell.com/for-a-few-monads-more#state
10:21:40 * hackagebot twitter-conduit 0.0.1 - Twitter API package with conduit interface and Streaming API support.  http://hackage.haskell.org/package/twitter-conduit-0.0.1 (TakahiroHimura)
10:21:51 <monochrom> in other words M's only I/O is in receiving and sending messages, the rest of M is purely functional. simiarly C and V
10:21:57 <colDrMcBeardman> I have a type I want to put in a Data.Map but I don't think the key type [(String, Int)] makes Data.Map a good idea. Is there some other structure I could use?
10:21:59 <jbkcc> davidthomas: ah! serialize events
10:22:40 <davidthomas> jbkcc: right, not the only solution, but usually makes development easy
10:22:43 <colDrMcBeardman> Really the key type could be [String], but I still need to search through that list instead of matching equality for key lookup
10:22:46 <monochrom> hell, if you plan to do OOP properly, IMO it's the same story. send and receive messages, stay purely functional otherwise
10:22:56 <davidthomas> not a bad idea in C, either :-P
10:23:46 <Kron> doing it concurrenlty is possible
10:23:49 <Kron> MVars and stuff
10:24:03 <dwcook> colDrMcBeardman, so you want multiple keys to be tied to the same vale?
10:24:03 <dwcook> s/vale/value/
10:24:39 <colDrMcBeardman> dwcook, sort of.
10:25:06 <jbkcc_> sorry all, wifi dropped
10:25:50 <peteretep> (read "london") :: Data.ByteString.Internal.ByteString
10:25:58 <peteretep> that gives me a no parse error
10:25:59 <peteretep> any clues?
10:26:08 <Kron> you didn't miss much jbkcc_
10:26:22 <c_wraith> peteretep: "\"london\""
10:26:28 <c_wraith> peteretep: read probably isn't what you want
10:26:38 <Kron> you'd want a parser of some sort
10:26:46 <Kron> in general you never want to use show and read
10:26:53 <Kron> i... thiink/
10:27:02 <dwcook> colDrMcBeardman, perhaps you can clarify what you need?
10:27:02 <jbkcc_> thanks for the information! i'll read up about state monad now
10:27:03 <c_wraith> peteretep: you *probably want to go through Text and pack the string, then convert it to UTF 8
10:27:05 <colDrMcBeardman> I have a data type like T Double Double [(String, Int)] coming from a spaghetti-like structured file. The Strings are simple words, the Int is a label, and every entry may have several forms with the same value, hence the list
10:27:11 <dwcook> Ah
10:27:31 <colDrMcBeardman> now, if the file were sane, there would just be more entries for the other forms.
10:27:41 <colDrMcBeardman> but sanity is hard to come by these days.
10:28:07 <monochrom> "spaghetti-like structure" seems to be an oxymoron :)
10:28:18 <monochrom> what is T?
10:28:38 <Kron> spaghetti is a structure like black is a colour
10:28:46 <colDrMcBeardman> monochrom, just a label.
10:29:24 <colDrMcBeardman> the represent words with similar characteristics, so an example value might be:
10:29:49 <colDrMcBeardman> T 4.3 2.1 [("emerging", 1), ("emergent", 1)]
10:30:04 <colDrMcBeardman> so ideally, whether I look up "emerging" or "emergent", it's the same thing.
10:31:02 <colDrMcBeardman> I have to carry them around in pairs because you might have the same word with different meanings.
10:31:12 <monochrom> if you were thinking you wanted [(String,Int)] to be keys but it looks wrong, my next instinct is either Set (String,Int) or Map String Int as key. yes, a whole set or map is one key
10:31:58 <monochrom> that is, the outer map is like Map (Map String Int) value, or Map (Set (String,Int)) value. I don't know which one. depends on your problem.
10:32:29 <colDrMcBeardman> monochrom, that's what I was starting to think but the size complexity here is scaring me. I have a 13MB file, and having Maps of Maps (possibly of Maps of Maps of Maps) is scary.
10:33:14 <colDrMcBeardman> I also feel like separating things out like that will make me spend a lot of time peeling the data types apart only for the sake of wedging them into a different structure.
10:34:37 <colDrMcBeardman> I mean, it would be nice to have (log n) lookups, but after all that work, maybe O(n) would be an acceptable alternative, especially since the file's structure resembles a bucketed hash list.
10:35:26 <monochrom> nested things look huge, only because of careless counting. in both theory and practice, using [Char] is the only memory hog
10:39:04 <hseg> Is lambdabot available online - i.e. not in IRC?
10:39:20 <monochrom> at present, I am only worried about: are [("a", 10), ("b", 5")] and [("b", 5), ("a", 10)] considered the same? if so, what is the least amount of human work and least error-prone way to write a program that treats them the same? therefore Set (String, Int) comes to mind. you are welcome to stick to a list and write extra code yourself, at your own peril.
10:40:35 <Kron> I'm in favor of a Set myself
10:40:44 <Kron> you'll have to use a wrapper to make the tuples Ordable
10:40:52 <Kron> but otherwise it basically writes itself
10:43:36 <joelteon> hseg: no, but you can install it yourself
10:43:38 <Kron> hseg: you can just query lambdabot
10:43:41 <Kron> I do it all the time
10:43:50 <yati> Hi. I just installed the random package using `cabal install random`. However, trying to `import System.Random` doesn't work in ghci
10:43:55 <yati> Any insight?
10:44:02 <Kron> :m + System.Random
10:44:06 <Kron> special syntax in GHCi
10:44:11 <joelteon> no, import works too
10:44:13 <joelteon> what's the error, yati
10:44:30 <hseg> Kron: Not quite mobile-friendly. Still, better than nothing.
10:44:45 <Kron> I didn't realize import woks too! TIL
10:44:50 <colDrMcBeardman> monochrom, indeed a list with a custom ordering seems dangerous but almost the best option.
10:44:53 <yati> joelteon, <no location info>:   Could not find module `System.Random'   It is not a module in the current program, or in any known package.
10:44:58 <joelteon> interesting
10:45:07 <joelteon> where did you install random to?
10:45:28 <Kron> I think he just said 'cabal install random', so that would be in .cabal I think?
10:45:34 <yati> I don't know - I just did `cabal install random` as root.
10:45:34 <Kron> *just wrote
10:45:37 <Kron> right
10:45:43 <c_wraith> Kron: no, it defaults to ~/.ghc
10:45:47 <yati> But I did it as root
10:45:53 <c_wraith> ugh
10:45:56 <c_wraith> never run cabal as root
10:45:56 <yati> That could be a reason
10:45:58 <c_wraith> *never*
10:46:04 <Kron> c_wraith: gotcha
10:46:08 <MP2E> ^ I learned the hard wa
10:46:09 <MP2E> y*
10:46:11 <Kron> do it as a normal user, yati
10:46:18 <colDrMcBeardman> Kron, indeed the data is basically a multiset of unordered things
10:46:23 <Kron> cabal doesn't actually install software to your root file system and stuff
10:46:26 <Kron> it places them in your home folder
10:46:32 <Kron> you don't need elevated priveleges
10:46:37 <yati> Okay :P I thought this worked like Python's pip and uses some lib location.
10:46:38 <colDrMcBeardman> i can impose different orderings, each of which makes about as little sense as any other.
10:46:42 <yati> Shouldn't have assumed
10:46:51 <Kron> colDrMcBeardman: any ordering at all helps a lot
10:47:05 <Kron> data Tuplethingy = Wrapper string int
10:47:25 <Kron> instance Ord Tuplethingy where compare (Wrapper _ int) = compare int
10:47:27 <Kron> something like that
10:47:45 <Kron> that'll automatically compress a lot of extra tuple permutations
10:47:56 <colDrMcBeardman> Kron, I'm tempted to use simple lexicographical sorting on the strings in the key type, but there are cases where the list is something like:
10:48:22 <colDrMcBeardman> [("dorsal",2),("abaxial",1)
10:48:51 <colDrMcBeardman> I could essentially ignore all but the head of the list, but that's quite a bit of information to sacrifice for the sake of efficiency.
10:49:32 <Kron> I'm not sure I quite understand. what's the problem with that list?
10:50:03 <yati> Just curious, why was System.Random dropped from the stdlib? (I am following LYAH and I figured I didn't have System.Random)
10:50:21 <colDrMcBeardman> I need to  be able to lookup either "dorsal" or "abaxial" and get the same data type value for both those keys.
10:50:48 <Kron> so you want them both to map to 2, or both to map to 1?
10:51:02 <colDrMcBeardman> no, the [String, Int] is the key type.
10:51:06 <c_wraith> yati: base has been shrinking for a while.  The general policy has been to move specialized things that aren't depended on by other parts of base out to independent libraries.
10:51:07 <colDrMcBeardman> although I can ignore the Int
10:51:08 <Kron> ohh
10:51:15 <Kron> if you can ignore the int then do so
10:51:18 <Kron> index by strings
10:51:33 <c_wraith> yati: when they're independent projects, they can update on independent schedules.  base itself only updates when GHC is updated.
10:52:38 <colDrMcBeardman> I want a set where both keys "dorsal" and "abaxial" map to the same value T a b [("dorsal", 2), ("abxial", 1)]
10:52:47 <colDrMcBeardman> where a and b are numbers from the file.
10:52:54 <yati> c_wraith, hmm. makes sense. It is a bold move, though, in a world where most new languages have "batteries included"
10:53:41 <Kron> the same value being a and b?
10:53:50 <Kron> not the whole original T a b etc. etc. right?
10:53:58 <colDrMcBeardman> no, the original T a b blah blah
10:54:03 <Kron> ... a circular reference?
10:54:05 <Kron> why?
10:54:14 <colDrMcBeardman> the structure is the T (stuff) and I want to index it by its contents.
10:54:32 <Kron> but why? What in T are you indexing exactly? for access?
10:54:44 <Kron> what do you actually want to get out of the structure
10:54:57 <jle`> is there any way to get a module name wher ethe type is defined from a TypeRep?
10:54:58 <colDrMcBeardman> Kron, I have 13MB and I want to make searching better than O(n)
10:55:23 <c_wraith> yati: part of it is that haskell development has settled on a philosophy of having lots of small libraries instead of monolithic libraries. It's actually easy to work that way in haskell, compared to most languages, and things have developed as a result of that.
10:55:47 <Kron> what are you trying to get out of the 13 MB?
10:55:51 <colDrMcBeardman> I do need only the a, b, etc. but the problem is that it's a multiset, so I have to store as much of the data type as possible to prevent deduplication
10:56:02 <Kron> hmmm
10:56:14 <c_wraith> yati: you can find a fair number of packages on hackage that are under 100 lines, and yet do something useful and complete.
10:56:24 <colDrMcBeardman> Kron, they're just rows of text that I've mapped to a data type T (stuff...)
10:56:43 <colDrMcBeardman> it's actually T Int Float Float [(String, Int)]
10:56:59 <Kron> I'd personally nest it in a trie, but that is basically just Map-ing
10:57:07 <colDrMcBeardman> err.... T Label Int Float Float [(String, Int)]
10:57:07 <yati> c_wraith, Haha I don't doubt that with Haskell - I just wrote a one line program that does stuff using "interact" :D
10:57:49 <colDrMcBeardman> Kron, I'm confused because I know what I could do if it were just something like T blah blah String
10:58:13 <theorbtwo> BTW, haskell isn't alone in that.  Perl's also trying to remove modules that aren't needed to bootstrap our package manager.  (Slowly -- the depreciation cycle we decided on takes at least two years from decision to remove to actually not there anymore.)
10:58:26 <colDrMcBeardman> but because it can have multiple Strings that aren't necessarily similar or even lexicographically close... I'm lost.
10:59:15 <Kron> hash it? :(
10:59:40 <yati> theorbtwo, I think Rust also started separating libextra into independent units - not sure if they'll stop shipping those with the core, especially now when they have a new package manager
11:00:12 <c_wraith> I still need to really dig into rust at some point.  Not just watch from a distance.
11:00:59 <colDrMcBeardman> Kron, I actually was going to have a bloom filter in front of $MysteryStructure because, assuming I can even get this thing into a structure with O(log n) lookup, I will be pounding it with lots of garbage data.
11:01:15 <colDrMcBeardman> so a bloom would keep me from doing many needless lookups.
11:01:44 * hackagebot http-conduit-downloader 1.0.15 - HTTP downloader tailored for web-crawler needs.  http://hackage.haskell.org/package/http-conduit-downloader-1.0.15 (VladimirShabanov)
11:02:02 <yati> c_wraith, It was a fresh breath of air coming from C++, frankly - amazing compiler. I am learning haskell after Rust, and now I can see they were inspired in many ways :)
11:02:04 <Kron> I'm unfamiliar with bloom filters. Nonetheless, good luck with your endeavours, looks nontrivial
11:02:08 <colDrMcBeardman> I honestly feel better that no one has an easy answer, here... I feel less dumb :-)
11:02:33 <c_wraith> yati: yeah, I really appreciate what Rust is doing.  It's got a specific niche in mind, and it's not ignoring the last 50 years in programming language advancements.
11:02:59 <yati> right.
11:03:03 <Kron> I do love that even the C syntax style imperative languages are moving towards generics support and lots of safety
11:03:07 <c_wraith> I just haven't dug into it and used it for real.
11:03:18 <Kron> it's not quite a hindley milner type system but it's trying
11:04:06 <colDrMcBeardman> Kron, I remember giving a presentation on what was supposed to be C++0x and one of the people in the room almost hijacked the presentation with comments about haskell.
11:04:20 <yati> Kron, I so loved the pattern matching -> recurse pattern that I went on to ask on #rust why don't they have TCO as a language guarantee
11:04:27 <colDrMcBeardman> if only I had known, I would have dropped C++ in a heartbeat.
11:04:47 <Kron> is that where you learned about haskell, colDrMcBeardman?
11:05:03 <yati> But there are serious issues it seems in guaranteeing TCO, but LLVM should TCO out most stuff they say
11:05:33 <Kron> yati: the only languages I know with the "finite set of mutually exclusive constructors" thing are ocaml and haskell
11:05:36 <colDrMcBeardman> sadly, I largely forgot about it after that, because it was just audible comments. it was much latter watching another presentation that I saw some haskell code and my jaw hit the floor.
11:05:47 <Kron> even lisp doesn't quite let you do it in a neat compiler-checkable-safe way
11:05:49 <colDrMcBeardman> I think I switched overnight.
11:06:04 <Kron> what did the code do, col?
11:06:18 <Kron> for me it was me trying to learn my friend's favorite language
11:06:57 <yati> For me this is my 3rd attempt - and finally it's clicking now :)
11:07:11 <colDrMcBeardman> Kron, it was just basic stuff for an undergrad class called "programming language concepts", so it was your standard "meet language x" presentation
11:08:12 <colDrMcBeardman> but in those fifteen minutes I had this vague notion of how much of the bullshit you deal with in C/C++, Java, Python is completely eliminated.
11:08:43 <Kron> haha
11:10:05 <Kron> I never quite had a eureka-this-is-so-cool moment early on learning haskell
11:10:11 <Kron> just slowly grinding away and starting to like it
11:10:37 <MP2E> The second I looked at quicksort on haskell.org, I knew
11:10:40 <MP2E> heh
11:10:43 <colDrMcBeardman> I mean, I was primed, I suppose, from going through SICP while I was working for a company doing low-level C stuff, which I though I liked, but really didn't.
11:10:55 <MP2E> I keep having eureka moments all along to make it even more fun
11:11:02 <MP2E> all along the way*
11:11:15 <colDrMcBeardman> and Scheme/LISP is cool and all, but it always felt too low-level. I guess I just have a sweet tooth for syntactic sugar.
11:11:27 <Kron> for me one really interesting moment was realizing that there was no distinction between nullary functions and variables
11:11:32 <Kron> foo x y = two argument function
11:11:35 <Kron> foo x = one argument
11:11:38 <Kron> foo = ??? variable?
11:11:43 <Kron> answer: doesn't matter
11:11:50 <Kron> immutable and completely referentially transparent
11:12:00 <Kron> the distinction between function and variable dissolve away
11:12:02 <colDrMcBeardman> but at the same time, you have the C++ approach to syntactic sugar which is "bloat bloat bloat!" and then you have haskell... "we know we're doing something crazy if we add something and it would require a change in core"
11:12:33 <Kron> the operator insanity in haskell took me a while to get used to
11:12:48 <Kron> (++) <$> tail <*> drop 3
11:12:49 <Kron> etc.
11:13:05 <colDrMcBeardman> Kron, yes, first-class everything... I get the feeling that duck-typing is just an overreaction to not treating everything as first-class
11:13:26 <pyon> Kron: Heh, Applicative-style (as in Applicative-type-class-style) is nice for using parser combinators. :-)
11:13:28 <Kron> yeah it is nice how you can just write your own operators and prefix them like functions (and infix symbols)
11:14:49 <thebnq> i suddenly find control.category incredibly enlightening, why isn't it in prelude =)
11:14:53 <pyon> Dijkstra once said something like "abstraction is not about vagueness, it is about being precise at a new semantic level". Haskell almost perfectly fits that description. (If only there were something like that for systems programming...)
11:14:55 <ixmatus> I'm having a bit of difficulty with polymorphism in my library, could someone help me out a bit?
11:15:28 <c_wraith> pyon: hopefully, that's what Rust will become
11:15:56 <ixmatus> I put a polymorphic type class constraint on a data type and everything was hunky dorey until I got to my Aeson instances...
11:16:15 <ixmatus> I'm thinking I have to write Aeson instances for each type?
11:16:45 * hackagebot tempodb 0.2.2.3 - A small Haskell wrapper around the TempoDB api.  http://hackage.haskell.org/package/tempodb-0.2.2.3 (ParnellSpringmeyer)
11:17:02 <ixmatus> ^ that's the one I want help with, actually
11:18:04 <bergmark> ixmatus: what does this constraint look like?
11:18:12 <pyon> c_wraith: Overall, I like Rust, but it is clunky at places. For example, instead of being mutable, iterators should be consumed, and optionally return an element and a new iterator. If the iterator type implements Drop, no functionality is lost. If the iterator type does not implement Drop, new functionality is gained: the ability to revisit previously visited elements.
11:18:33 <lahwran> rust is still WIP
11:18:37 <ixmatus> bergmark, I'll get a quick example (from code) into a gist real quick, thanks
11:18:46 <lahwran> pyon: complain to the rust makey folks, maybe they'll improve it :D
11:18:52 <c_wraith> pyon: now's the time to bring that up with them!
11:18:57 <MP2E> indeed
11:19:03 <pyon> Yeah, sorry, wrong place to mention that.
11:19:06 <MP2E> 1.0 is too late :P
11:19:31 <MP2E> hopefully it gets a lot.. smoother around the edges before then
11:19:52 <Kron> linear types would be nice
11:19:53 <Kron> in general
11:20:30 <jophish> Yo yo yo
11:20:37 <jophish> why is Function named so?
11:20:40 <jophish> Functor*
11:20:49 <thebnq> from Category theory
11:20:51 <Kron> because we don't have enough concepts called Functor
11:20:54 <pyon> jophish: Because Functors are... functors.
11:20:55 <MP2E> hahha
11:20:57 <Kron> across a million programming languages
11:21:04 <Kron> and we wanted to throw in our entry to the party
11:21:08 <jophish> yes :)
11:21:14 <c_wraith> jophish: because the thing from math called a functor happens to map exactly to what haskell's Functor class does.  re-use the existing term!
11:21:15 <pyon> Kron: Only Haskell's functors are real functors. (But ML's come close.)
11:21:35 <ixmatus> bergmark, https://gist.github.com/ixmatus/9647916
11:21:38 <ixmatus> that's what the type looks like
11:21:47 <Kron> I don't care, I like how it makes my code look cool
11:21:47 <jophish> I meant the etymology of the word Functor
11:21:49 <jophish> in aths
11:21:51 <Kron> I just like saying the word functor
11:21:57 <pyon> lol
11:21:58 <Kron> Functor. Functooor.
11:22:06 <Kron> it sounds like a transformer
11:22:20 <MP2E> I HAVE THE FUNCTORRRRRRRRRRRRRRR! *read in He-man's voice*
11:22:51 <Kron> and I can tell my friends I'm writing a program that 'maps' an 'operation' over a 'functor' and they think i'm einstein
11:22:56 <Kron> what's not to love?
11:23:15 <c_wraith> jophish: If you look at category theory, you see that Functor can be seen as a generalization of the concept of functions.  Another choice could have been Functoid.  I think Functor is better!
11:23:32 <Kron> also, while we're at it, fmap fmap fmap sounds like a very lewd onomatopoeia
11:23:36 <bergmark> ixmatus: putting constraints directly on the data type like this gives barely any benefit
11:23:38 <thebnq> oh functoid would makes sense
11:23:45 <pyon> Kron: Please don't fmap too much. I mean, use <$> instead.
11:23:53 <bergmark> ixmatus: you will need to put the constraint on all functions working with it anyway
11:23:55 <Kron> i prefer .: and <$> yes
11:23:58 <ixmatus> bergmark, so I want that value field to be any Num type
11:23:59 <ixmatus> right
11:24:09 <ixmatus> is there a better way to do or think about what I want?
11:24:18 <bergmark> ixmatus: http://stackoverflow.com/questions/12770278/typeclass-constraints-on-data-declarations
11:26:30 <bergmark> ixmatus: see for instance Data.Map.singleton :: k -> a -> Map k a vs Data.Map.insert :: Ord k => k -> a -> M.Map k a -> M.Map k a
11:27:18 <bergmark> ixmatus: usually letting people construct an invalid type here isn't an issue, they won't be able to use it with anything else because there you'll have the constraint
11:27:44 <Apocalisp> I have two monoids x and y, f :: x -> y, g :: y -> x; (f . g) = id, but (g . f) != id. Both monoids admit a homomorphism to a third monoid z. Is there a name for this relationship?
11:29:13 <ixmatus> okay..so it would be considered okay for me to just keep it polymorphic with no constraint?
11:29:25 <ixmatus> (am I understanding you correctly?)
11:29:29 <ixmatus> I read the link, thanks
11:29:41 <bergmark> Apocalisp: a semigroup with a left identity, i think, but don't trust me too much on this stuff :-)
11:30:18 <Apocalisp> also hy . f . g = hx . g . f, for homomorphisms hy and hx
11:30:51 <fizbin> Anyone have somewhere some tests to check an Applicative instance? Maybe some quickcheck tests for the laws?
11:31:18 <bergmark> ixmatus: i'd say it's just better to omit it, no need to introduce a constraint that isn't needed
11:31:38 <bergmark> ixmatus: by removing the constraint you are simply abstracting
11:32:05 <ixmatus> okay, thanks bergmark
11:33:42 <dmj`> can I specify flags on packages in cabal files? Like snap-server -fopenssl in the cabal file
11:33:49 <ixmatus> bergmark, for Aeson instances of that type though, I will need to have an instance  for each "type" I want to support, it seems - is there a way to automatically derive those?
11:38:13 <bergmark> ixmatus: so you will end up with ToJSON a => ToJSON (Data a)
11:38:23 <bergmark> ixmatus: and yes, you can generically derive these, i think aeson can already do it
11:38:29 <ixmatus> doh
11:38:32 <ixmatus> thanks bergmark
11:40:59 <bergmark> oh they deprecated Data.Aeson.Generic
11:41:00 <bergmark> :(
11:41:06 <SrPx> Where I can see the implementation of the IO monad?
11:41:21 <bergmark> we have our own implementation though
11:41:33 <c_wraith> SrPx: GHC.Prim, probably
11:42:35 <c_wraith> SrPx: oh.  GHC.IO, it seems.  http://hackage.haskell.org/package/base-4.6.0.1/docs/src/GHC-IO.html
11:42:47 <c_wraith> SrPx: at least, those are the basics that aren't wired into the runtime
11:45:25 <SrPx> hmm I can't see the implementation just some uses
11:46:57 <c_wraith> SrPx: well, follow the imports.  It suggests that http://hackage.haskell.org/package/base-4.6.0.1/docs/src/GHC-ST.html is a good place to look
11:47:09 <SrPx> hmm I was there
11:47:42 <c_wraith> SrPx: ultimately, though, a lot of the code is going to be in the RTS
11:48:13 <quchen> SrPx: newtype IO is in libraries/ghc-prim/GHC/Types.hs
11:50:10 <quchen> Monad instance: libraries/base/GHC/Base.lhs
12:06:50 * hackagebot HGamer3D-Wire 0.3.1 - Wire Functionality for HGamer3D  http://hackage.haskell.org/package/HGamer3D-Wire-0.3.1 (PeterAlthainz)
12:07:32 <h_noob> Ok I'm using haskell to poll some hardware sensors.  there are 24 sensors.
12:07:49 <h_noob> after getting the first array of values, after that all the values stay the same
12:08:16 <h_noob> they should have some random jittering.  I guess haskell is caching the results somehow
12:08:32 <h_noob> what should I look for in my code to prevent the caching?
12:11:50 * hackagebot exceptions 0.3.3.1 - Extensible optionally-pure exceptions  http://hackage.haskell.org/package/exceptions-0.3.3.1 (EdwardKmett)
12:13:47 <geekosaur> are you actually getting new values? I think we'd have to see code to have any idea what to point you to look at
12:14:56 <h_noob> ok this is the loop:
12:14:57 <h_noob> pollall fd1 fd2 =
12:14:57 <h_noob>  do
12:14:57 <h_noob>   mapM printsensorval (map (\x -> poll fd1 x) sensors)
12:14:57 <h_noob>   mapM printsensorval (map (\x -> poll fd2 x) sensors)
12:14:57 <h_noob>   putStrLn ""
12:14:58 <h_noob>   pollall fd1 fd2
12:15:20 <h_noob> fd1 and fd2 are file descriptors for SPI devices.  I open those with c ftns.
12:15:51 <h_noob> "poll" gets the value from a sensor
12:15:51 <h_noob> poll fd (b1,b2) =
12:15:52 <h_noob>  do
12:15:52 <h_noob>   S.useAsCStringLen (S.pack [castCUCharToChar b1,castCUCharToChar b2])
12:15:52 <h_noob>    (\sendbytes -> do
12:15:52 <h_noob>     threadDelay 1000
12:15:56 <h_noob>     c_spiWriteRead fd (fst sendbytes) 2 bitsperword speed
12:15:58 <h_noob>     bs <- S.packCStringLen sendbytes
12:15:59 <h_noob>     return (decodedata (castCharToCUChar (S.index bs 0)) (castCharToCUChar (S.index bs 1)))
12:16:02 <h_noob>     )
12:16:33 <h_noob> I have a C program that works, so I think the basic concept is sound.  The numbers I get look reasonable, but they don't change
12:16:51 * hackagebot HaRe 0.7.1.6 - the Haskell Refactorer.  http://hackage.haskell.org/package/HaRe-0.7.1.6 (AlanZimmerman)
12:18:13 <h_noob> The C program uses similar code but not the exact same library.  might be work it to rewrite it to use the exact same sensor code
12:18:41 <rallyone> why am I getting this error message
12:18:45 <rallyone> every time I compile?
12:18:49 <rallyone> here is the screenshot with notes
12:18:50 <rallyone> http://i.imgur.com/kcQPbVA.jpg
12:19:35 <h_noob> output looks like this:
12:19:38 <h_noob> 592 624 656 688 720 752 784 816 848 880 912 944 592 624 656 688 720 752 784 816 848 880 912 944
12:19:38 <h_noob> 592 624 656 688 720 752 784 816 848 880 912 944 592 624 656 688 720 752 784 816 848 880 912 944
12:19:38 <h_noob> 592 624 656 688 720 752 784 816 848 880 912 944 592 624 656 688 720 752 784 816 848 880 912 944
12:19:38 <h_noob> 592 624 656 688 720 752 784 816 848 880 912 944 592 624 656 688 720 752 784 816 848 880 912 944
12:19:51 <Earnestly> h_noob: Use a paste site
12:19:56 <geekosaur> h_noob, please do not paste intot he channel
12:20:01 <h_noob> ok
12:20:02 <thebnq> nsfw warning
12:20:03 --- mode: ChanServ set +o geekosaur
12:20:09 --- mode: geekosaur set +b *!*rallyone@200.79.251.*
12:20:10 --- kick: rallyone was kicked by geekosaur (rallyone)
12:20:21 <benmachine> yeah, no-one click rallyone's link
12:20:40 <MP2E> thanks for the heads up
12:20:42 <MP2E> heh
12:20:53 --- mode: geekosaur set -o geekosaur
12:21:00 <raichoo> I've seen worse things but yeah, it's not for the faint of heart ^^
12:21:05 <thebnq> although quite literal in common game lingo
12:21:38 <benmachine> it is far from the worst thing on the internet, but it's definitely not a screenshot of a compile error
12:21:46 <zomg> benmachine: I wouldn't even have noticed it without all this commotion... so I clicked it.
12:21:49 <zomg> :D
12:21:51 * hackagebot haste-compiler 0.2.99 - Haskell To ECMAScript compiler  http://hackage.haskell.org/package/haste-compiler-0.2.99 (AntonEkblad)
12:22:03 <zomg> Gave me a chuckle, but yeah, definitely NSFW
12:22:03 <benmachine> zomg: well, good luck to you
12:31:36 <h_noob> here's the pastebin of the offending program and the output, etc.
12:31:40 <h_noob> http://pastebin.com/7RjqHaT2
12:32:50 <Sandra_> Hi guys ! anyone have a example to generarte HTML in a splice on heist/snap ?
12:34:51 <c_wraith> Sandra_: you might try the #snapframework channel if no one answers here.
12:35:07 <geekosaur> oh, suddenly I think I know what the problem is
12:35:20 <Sandra_> c_wraith : truth ! thanks !
12:35:25 <geekosaur> h_noob: how long do you expect `threadDelay 1000` to delay?
12:35:33 <h_noob> 1 millisecond
12:35:44 <geekosaur> hm, ok, so it's not the usual problem
12:36:00 <geekosaur> although I'd wonder if it actually has new data by then...
12:36:13 <h_noob> yeah it works better in C with a delay
12:36:56 <geekosaur> you might put the example C program up too for comparison, since I doubt anyone here has any idea how the APIs you're using work
12:37:16 <c_wraith> h_noob: well, geekosaur meant that people often assume threadDelay takes milliseconds, instead of microseconds.  Seems you didn't make that mistake, though.
12:38:59 <quchen> There should really be a Millisecond newtype.
12:39:06 <geekosaur> yes, it's extremely common (even among people familiar with Haskell) to make that mistake
12:39:24 <geekosaur> at one point even the bot here (lambdabot) had a bug becayse of that
12:39:28 <h_noob> I guess I was wondering if there's some kind of thing in haskell where it tends to cache values - say when it calls a pure ftn with the same values.
12:39:36 <geekosaur> nope
12:39:46 <h_noob> and maybe its confused because I'm calling C and changing the values there
12:39:49 <geekosaur> also anything FFI is automatically in IO
12:40:05 <c_wraith> ... assuming you put IO in the type signature
12:40:16 <geekosaur> oh, point, where is that
12:40:24 <c_wraith> If you leave the IO out of the type signature on a foreign import, it will automatically throw in an unsafePerformIO
12:40:30 <h_noob> ha yeah kind of letting haskell decide on the type sigs.  probably bad?
12:40:31 <geekosaur> ow
12:40:33 <quchen> Common subexpression elimination is like caching, in a way. So I wouldn't say "nope" in general.
12:40:34 <geekosaur> yes, that would be bad
12:40:56 <geekosaur> and I see no type signature so it is probable you are seeing that, because all bets are off if it thinks it's pure
12:41:10 <geekosaur> which it very much is not in this case
12:41:38 <h_noob> yes, not too pure.  I'll see if I can cabal repl and check the sigs.
12:42:02 <geekosaur> oh, I see IOs on the foreigns so it shouldn't be that
12:42:24 <geekosaur> would still like to see the C code for comparison
12:43:06 <h_noob> yeah I have C code but its organized differently, I'll paste it though
12:44:03 <skypers> hi
12:44:40 <skypers> hi
12:44:47 <skypers> found a bug
12:44:55 <skypers> @let data Foo = Foo deriving (show)
12:44:55 <lambdabot>  Parse failed: Illegal instance declaration
12:45:09 <skypers> in my ghci, it makes ghc to ghc panic
12:45:11 <pavonia> *Show
12:45:15 <skypers> yes pavonia
12:45:25 <skypers> ghc doesn’t say show is incorrect
12:45:27 <skypers> it just fails
12:45:28 <c_wraith> skypers: what version of ghc? I seem to recall something like that
12:45:29 <geekosaur> that's an old bug, I guess there's still a variant around unless your ghc is old
12:45:36 <c_wraith> Maybe around 7.6.1?
12:45:43 <geekosaur> (ghci does do things differently from ghc)
12:45:45 <skypers> 7.4.1
12:45:51 <c_wraith> Oh.  Yeah, that's plenty old
12:45:57 <geekosaur> 7.4.1 has that bug IIRC, yes
12:46:00 <skypers> #debian
12:46:02 <skypers> :D
12:46:24 <h_noob> ok geekosaur - here's the c++ code.
12:46:24 <h_noob> http://pastebin.com/tpHEpGa7
12:47:33 <akurilin> Hey. Do you guys know of any libraries out there that I could use to chop up mp3s into multiple files?
12:48:16 <h_noob> and fwiw here's the C code that is used by the haskell program:
12:48:16 <h_noob> http://pastebin.com/TvWcVbfa
13:03:13 <xico> i am trying to call dons' mersenne-twister library from a haskell code, loaded by the ghc library, and invoked from c++. anyway, the standard way (calling getStdGen) to do it seems buggy but the underlying code seems simple. could anyone help me understand it? basically, calling getStdGen seems the problem here, with some unsafe io and ioref under the hood:
13:03:33 <xico> http://lpaste.net/101466
13:03:53 <xico> (it fails on the "error" call at line 43)
13:08:17 <Apocalisp> Am I crazy or is (a,b) both a monoid product and a monoid coproduct for monoids a and b?
13:10:42 <bennofs> Is there a frequency monoid somewhere?
13:18:42 <Cale> Apocalisp: You're not crazy.
13:18:47 <Apocalisp> whew
13:19:02 <Apocalisp> Cale: So what is the point of a free product?
13:19:12 <nawal> hey guys
13:19:16 <Cale> Er, oh, silly me
13:19:27 <nawal> anyone played with haskell/bullet bindings?
13:19:29 <Cale> Yeah, it's a coproduct only if the monoids are commutative
13:19:43 <Cale> Rather, in the category of commutative monoids
13:19:50 <Apocalisp> Cale: why is that?
13:20:40 <Cale> Well, I guess let's check the definition?
13:21:19 <Apocalisp> Cale: As I understand it, a monoid coproduct of x and y admits homomorphisms from both x and y.
13:21:32 <DanielDiaz> I am reading files using the text library. However it keeps giving me errors like "hGetContents: invalid argument (invalid byte sequence)", only because it has Korean characters. What should I do? thank you
13:21:32 <Apocalisp> This is certainly true for (x,y)
13:21:45 <Cale> Apocalisp: Yes, but it's more than that :)
13:21:55 <Apocalisp> Cale: Oh! Well, that's good :)
13:22:12 <Apocalisp> I would like to know what that more is.
13:23:11 <Cale> You not only need that there are maps i_A: A -> A + B, and i_B: A -> A + B, but also that for any other monoid Z, and maps f : A -> Z and g : B -> Z, that there is a unique map [f,g] : A + B -> Z
13:23:32 <Cale> (which makes the diagram commute)
13:24:56 <Apocalisp> ahhh
13:25:08 <ReinH> schell: yes
13:25:19 <Apocalisp> Cale: Yes, that makes sense to me
13:25:24 <Cale> oops, i_B : B -> A + B of course
13:25:34 <schell> ReinH: cool - just checking - ever going to do another?
13:25:44 <ReinH> schell: maybe. Finding it hard to make time.
13:25:46 <ReinH> But I want to.
13:25:50 <Apocalisp> Cale: right, I totally looked through that typo
13:26:30 <schell> ReinH: i feel you on that one
13:26:53 <Apocalisp> Cale: Alright, so then I just need to make sure that there is not a map (a,b) -> z for all monoids z given a -> z and b -> z
13:27:29 <quchen> Is there a way to apply a function after a lens has been used? For example, `(traversed %@~ replicate) "Hello"` is `["","e","ll","lll","oooo"]`. Can I modify the lens ("traversed") so that the result is concatenated?
13:27:43 <quchen> … other than wrapping the entire thing in "concat", of course
13:27:59 <edwardk> not and be a lens, though in this case you can cheat
13:29:02 <quchen> edwardk: teach me how to cheat then :>
13:29:29 <edwardk> hrmm, for a second i thought (traversed %%@~ replicate)  would work, but that is a lie ;)
13:29:40 <edwardk> that gives you the monad, not the monoid
13:29:53 <quchen> Speaking of %%, what does that do? I couldn't make sense of it in my cheat sheet :-\
13:30:01 <edwardk> %%~ is id
13:30:37 <edwardk> look at something like %%~   that lets you pass it a function with an side-effect and get an answer with the same "side-effect".
13:30:55 <edwardk> lens requires just Functor, while a traversal requires Applicative
13:31:03 <bennofs> is there a function f :: Monoid a => Bool -> a -> a, that returns mempty on False and otherwise behaves like id?
13:31:10 <quchen> id can be one hell of a function though.
13:31:17 <edwardk> > (1,2) & both %%~ \x -> [x,x+1]
13:31:21 <lambdabot>  [(1,2),(1,3),(2,2),(2,3)]
13:32:02 <edwardk> quchen: think of it like traverseOf
13:32:17 <byorgey> bennofs: not pre-defined
13:32:18 <edwardk> > traverseOf both (\x -> [x,x+1]) (1,2)
13:32:21 <bennofs> :|
13:32:21 <lambdabot>  [(1,2),(1,3),(2,2),(2,3)]
13:32:26 <Cale> Apocalisp: So, let's think about what this means: If we're trying to construct a homomorphism h: A x B -> Z, and we have arbitrary homomorphisms f: A -> Z and g: B -> Z so we know that we want h(a,1) = f(a) and h(1,b) = g(b), are we certain to be able to extend h to a homomorphism?
13:32:49 <edwardk> > sequenceOf both ([1,2],[3,4])
13:32:52 <lambdabot>  [(1,3),(1,4),(2,3),(2,4)]
13:32:56 <Cale> Apocalisp: Well, if h is to be a homomorphism, then h((a,1) * (1,b)) = h(a,1) * h(1,b) = f(a) * g(b)
13:33:18 <Cale> Apocalisp: But also, we have that (a,1) * (1,b) = (a,b) = (1,b) * (a,1)
13:33:28 <quchen> edwardk: So it's like %~, but takes the applicative-icity into account somehow?
13:33:36 <edwardk> quchen: yep
13:33:42 <edwardk> quchen look at the type of a lens
13:34:23 <Cale> Apocalisp: So, while we know that h(a,b) = f(a) * g(b) from above, we'd better also have that h(a,b) = h((1,b) * (a,1)) = h(1,b) * h(a,1) = g(b) * f(a)
13:34:24 <edwardk> the lens _is_ the function that takes a function to modify part with an effect and gives you function that modifies the whole with the same effect.
13:34:32 <edwardk> (a -> f b) -> s -> f t
13:34:37 <edwardk> f is the 'effect'
13:34:53 <edwardk> hence why (%%~) is id
13:34:53 <Cale> Apocalisp: So for every a in A and b in B, we need f(a) * g(b) = g(b) * f(a) in Z
13:35:00 <edwardk> :t both
13:35:03 <lambdabot> Applicative f => (a -> f b) -> (a, a) -> f (b, b)
13:35:08 <edwardk> :t (both %%~)
13:35:09 <lambdabot> Applicative f => (a -> f b) -> (a, a) -> f (b, b)
13:35:11 <Cale> Apocalisp: Because we don't know that Z is commutative, this is a problem.
13:35:38 <Apocalisp> Cale: I see now why you said this would only hold for commutative monoids
13:35:51 <h_noob> geekosaur:  my problem is apparently in the C code... wrote a new C program to use the C library and produces same result as haskell.  old C++ code still works.  so should be a matter of C debugging from here.  thx for help!
13:36:44 <Cale> Apocalisp: Yeah, I should say, in the category of commutative monoids. The coproduct of monoids which happen to be commutative in the category of all monoids is still their free product, and in general won't be commutative.
13:36:55 <quchen> edwardk: Type-wise I understand what it does, but I can't intuitively make sense of it.
13:37:13 <quchen> As in "I'd never think of using it in the wild"
13:37:21 <Cale> Apocalisp: (because we need to know that this other arbitrary monoid Z is commutative in order to make this work)
13:37:40 <edwardk> quchen: hence my pointing it out now ;)
13:37:52 <Cale> Apocalisp: But if we did know that, then this indeed would work
13:38:00 <edwardk> quchen: now, there is a particular choice of functor that is most useful to motivate it
13:38:02 <edwardk> (,) e
13:38:26 <__sebastian___> I've deployed a very early version of the new hayoo at http://hayoo.spawnhost.de/ . (feel free to add issues to https://github.com/hunt-framework/hayoo/issues)
13:38:38 <Cale> Apocalisp: Because we get that h(a,b) = f(a) * g(b), and there is exactly one commutative monoid homomorphism which satisfies that equation.
13:38:38 <edwardk> then (a -> (e, b)) -> s -> (e, b)   lets you sneak out information
13:40:06 <Apocalisp> Cale: Thanks for clearing that up for me. It's always a problem to work with imprecise definitions
13:40:27 <edwardk> quchen: think of it as 'if you know how to do it with traverse, for a normal container then you can use %%~ on a lens/traversal.
13:43:08 <pavonia> After "casting" a gtk2hs "WidgetClass w => w" to a Widget, is there no way to to get the w back?
13:43:48 <pavonia> i.e. I want the opposite of "toWidget :: WidgetClass o => o -> Widget"
13:44:34 <geekosaur> that's kinda unsafe I think
13:45:33 <pavonia> Is it?
13:46:30 <pavonia> What I want to do is storing diffentent widget types as keys in a Map
13:47:02 <pavonia> but I need to convert to Widget to have an Ord instance
13:47:27 <c_wraith> pavonia: who says it's even possible? You're essentially asking for the same thing as fromInteger
13:48:13 <pavonia> yeah, I don't know if it's even possible
13:48:13 <c_wraith> pavonia: err, fromInteger is backwards.  But more to the point, you're asking to invert an arbitrary function.  Good luck with that.
13:48:43 <geekosaur> you can always turn an instance of WidgetClass into a Widget. what do you expect to happen if you convert a Widget that is a Button into a Window?
13:49:25 <c_wraith> I expect a very large button
13:49:37 <mm_freak_> where in the labyrinth of Foreign.* is the memset equivalent?
13:49:53 <pavonia> geekosaur: I want to get back the original WdigetClass w  => w. I don't care what exact type that is because I will only use functions that work with that type
13:50:42 <geekosaur> wat
13:50:49 <geekosaur> 1. Haskell cares
13:51:19 <geekosaur> 2. I fyou don't know what type it is, how do you know you're only calling functions that work with that type? More to the point, how does *the compiler* know that?
13:52:01 <pavonia> the functions I use all have the type "WidgetClass w => w -> Something"
13:52:57 <geekosaur> so I see an instance WidgetClass Widget
13:53:16 <geekosaur> if that is really all you care about then that should be sufficient
13:53:40 <pavonia> Oh, let me try that ...
13:53:43 <flebron> So I get that something like length :: [a] -> Int can be modeled as a natural transformation between the functors [] and Const Int. However, what if we have two type variables? What is something like fmap :: (a -> b) -> (f a -> f b)? It would seem that "for each object (a) there's a natural transformation (\b -> ...)". What is this sort of thing?
13:58:38 <pavonia> geekosaur: Seems to work fine, thanks
13:59:10 <Walther> :t interactr
13:59:11 <Walther> :t interact
13:59:13 <lambdabot> (String -> String) -> IO ()
13:59:13 <lambdabot>     Not in scope: `interactr'
13:59:13 <lambdabot>     Perhaps you meant one of these:
13:59:13 <lambdabot>       `interact' (imported from Prelude),
13:59:25 <Walther> :t interact
13:59:26 <lambdabot> (String -> String) -> IO ()
13:59:34 <Walther> Hmmm...
14:00:11 <Walther> Golfing around, I guess interact could shave off a couple chars here https://github.com/Walther/euler/blob/master/problem0067_golf.hs
14:01:12 <Walther> however, getting weird errors when trying to mod that to use interact (no instance for Num String arising from use of n)
14:02:03 * hackagebot chatty 0.5.4.1 - Some monad transformers and typeclasses to simplify I/O on a transformer stack.  http://hackage.haskell.org/package/chatty-0.5.4.1 (implementation)
14:02:05 * hackagebot antisplice 0.13.0.1 - An engine for text-based dungeons.  http://hackage.haskell.org/package/antisplice-0.13.0.1 (implementation)
14:02:07 * hackagebot ironforge 0.1.0.17 - A technical demo for Antisplice.  http://hackage.haskell.org/package/ironforge-0.1.0.17 (implementation)
14:02:09 * hackagebot antagonist 0.1.0.9 - A web interface to Antisplice dungeons.  http://hackage.haskell.org/package/antagonist-0.1.0.9 (implementation)
14:02:11 * hackagebot wai-middleware-static 0.4.0.3 - WAI middleware that intercepts requests to static files.  http://hackage.haskell.org/package/wai-middleware-static-0.4.0.3 (AndrewFarmer)
14:03:14 <geekosaur> that would be because you are feeding a String to something expecting a numeric type
14:04:48 <c_wraith> are block and unblock completely gone in GHC 7.8?
14:06:40 <Ptival> what's this syntax? "data Foo = | Foo :.. Bar"
14:07:03 <johannesbodannes> is there a shorthand way to refer to the tuple of n dimensions, of a single uniform type?
14:07:04 * hackagebot http-conduit-downloader 1.0.16 - HTTP downloader tailored for web-crawler needs.  http://hackage.haskell.org/package/http-conduit-downloader-1.0.16 (VladimirShabanov)
14:07:05 <c_wraith> Ptival: : is a "capital letter"
14:07:26 <quchen> The leading "|" is illegal syntax.
14:07:27 <c_wraith> Ptival: it's declaring an infix constructor named :..
14:07:37 <Ptival> c_wraith: huh... ok :)
14:07:45 <johannesbodannes> without having to write out, say... (Integer, Integer, Integer, ..., Integer)
14:07:55 <c_wraith> quchen: I assumed that was a copy/paste error
14:08:15 <mm_freak_> johannesbodannes: see the 'linear' library
14:08:24 <Ptival> yeah I meant to write = ... | Foo but I figured the ... might be misleading as to which part was confusing me :p
14:08:41 <johannesbodannes> oh, i guess it defines vectors? that's way more suitable
14:08:45 <mm_freak_> johannesbodannes: it has V2, V3, V4 as well as a length-polymorphic vector type
14:09:00 <johannesbodannes> ok thanks
14:09:01 <mm_freak_> johannesbodannes: however, 'linear' vectors are element-strict
14:09:29 <johannesbodannes> meaning that all of the elements of the vector are evaluated strictly?
14:09:53 <mm_freak_> johannesbodannes: meaning that when you're strict on the vector, you're also strict on all its elements
14:10:23 <johannesbodannes> i see! that might even be convenient, actually
14:10:35 <mm_freak_> johannesbodannes: usually it is, but it has some implications
14:10:41 <mm_freak_> map turns from O(1) to O(n)
14:19:58 <hseg> Question. Does anyone know of a better way to write (\(xs,p:ys) -> (xs ++ [p], ys)) . span (/=c) for some bound variable c?
14:23:12 <mm_freak_> hseg: explicit recursion
14:23:50 <hseg> I'd prefer to keep it high-level, if you please.
14:26:41 <hseg> Better question (this causes the above to be unnecessary). Given a subsequence of xs, how do I obtain the shortest prefix of xs of which that subsequence is also a subsequence? (In fact, I need the suffix corresponding to that prefix)
14:28:40 <tromp__> just write a recursive dropSubSeq :: [a] -> [a] -> [a]
14:28:57 <hseg> I thought I'd do it using snd . head . filter (subseqOf sxs . fst) . (zip <$> inits <*> tails)
14:29:08 <tromp__> don'
14:29:16 <tromp__> don't do that:(
14:29:20 <hseg> Why?
14:29:30 <hpc> that's right up there with acme-php's sort function
14:29:34 <tromp__> much less efficient
14:29:47 <tromp__> not to mention ugly:(
14:29:55 <tdammers> isn't acme-php's sort an implementation of bogosort?
14:30:08 <tromp__> dropSubSeq is *really* simple
14:30:20 <tromp__> btw, it needs Eq a =>
14:30:26 <hpc> it's bubblesort, written to doggedly avoid using points
14:30:35 <hpc> as well as to be psychologically crushing
14:30:43 <hseg> OK. So basically, for each element in my subsequence, drop elements from the original until I drop an element equal to that element?
14:31:12 <hseg> Sounds high-order-friendly.
14:31:20 <tromp__> yes. and it should actually produce a Maybe [a]
14:31:24 <mm_freak_> is there an easy way to make sure that a certain value is calculated at compile time?
14:31:29 <tromp__> since the subseq may not exisit
14:31:43 <hpc> mm_freak_: might not qualify as easy, but TH?
14:31:47 <mm_freak_> its value is static (it's related to the size of Word)
14:32:00 <hseg> Or it should produce the empty list if the subsequence is exhausted.
14:32:04 <mm_freak_> hpc: i'd like to do that as a last resort
14:32:06 * hackagebot scotty 0.7.1 - Haskell web framework inspired by Ruby's Sinatra, using WAI and Warp  http://hackage.haskell.org/package/scotty-0.7.1 (AndrewFarmer)
14:32:12 <monochrom> yes, hand-calculate it yourself and make it a magic constant
14:32:29 <hpc> or just leave it thunked
14:32:32 <mm_freak_> monochrom: Word doesn't have a fixed size
14:32:33 <hseg> mm_freak_: And document how you computed it.
14:32:38 <tdammers> head . filter isSorted . permutations -- that should stand against anything
14:32:40 <hpc> once evaluated for the first time it will be remembered
14:32:41 <monochrom> oh, then bugger
14:32:55 <hpc> is it an expensive value to compute?
14:34:52 <mm_freak_> hpc: the speed difference between writing '6' and 'popCount (8*sizeOf (undefined :: Word)) - 1)' is a factor of 2
14:35:40 <monochrom> use a lot of #ifdef and #define :)
14:35:47 <mm_freak_> ugh…
14:37:00 <hpc> mm_freak_: give it a name
14:37:01 <monochrom> oh, template haskell may be good enough
14:37:14 <hpc> fooSizeDependentValueThing = popCount (8*sizeOf (undefined :: Word)) - 1)
14:37:49 <hpc> (also yeah, TH would solve this quite handily)
14:38:43 <mm_freak_> hpc: it has a name
14:38:49 <hpc> ah, hmm
14:39:16 <mm_freak_> it's a CAF, it's shared and inlined
14:42:07 * hackagebot tempodb 0.2.2.4 - A small Haskell wrapper around the TempoDB api.  http://hackage.haskell.org/package/tempodb-0.2.2.4 (ParnellSpringmeyer)
14:49:41 <blablaa> is there something explaining relation between CPS and lazy evaluation?
14:50:08 <blablaa> as i understand it, CPS can be used to change order of execution of computations...
14:52:08 * hackagebot rope 0.6.3 - Tools for manipulating fingertrees of bytestrings with optional annotations  http://hackage.haskell.org/package/rope-0.6.3 (EdwardKmett)
14:52:29 <edwardk> that package is just for maintenance, not shiny and new
14:52:56 <hpc> blablaa: a simple example of CPS is something like withFile
14:53:18 <hpc> withFile filename go = do {h <- openFile filename; go h; closeFile h}
14:54:01 <hpc> blablaa: in this example, go is the continuation
14:54:40 <blablaa> hpc, i know what CPS is... i've written a little lib in CPS style before discovering it was called CPS style :D
14:55:05 <blablaa> hpc, i'm just wondering if it eliminates the inefficiencies of lazy eval or not
14:55:20 <n-dolio> What inefficiencies?
14:55:49 <blablaa> n-dolio, mainly the space leaks, but also the creation of thunks and so on
14:55:49 <hpc> certain uses of CPS can eliminate the efficiency of doing things like repeated calls to (++) in the "wrong order"
14:56:11 <n-dolio> Which space leaks? :)
14:59:08 <blablaa> n-dolio, so, you've some answers or only fake questions?
14:59:33 <n-dolio> There are two kinds of space leaks.
14:59:37 <n-dolio> At least.
15:00:26 <n-dolio> One is where thunks accumulate that would be reduced in a strict language.
15:01:06 <n-dolio> But I'm not sure that CPS would help that, except if your CPS were evaluating things like a strict language. But then the CPS is probably superfluous, you could just make your direct-style functions strict.
15:01:28 <quicksilver> CPS can avoid the use of tuples
15:01:34 <quicksilver> which is an efficiency saving in GHC
15:01:40 <quicksilver> but that's nothing to do with lazy eval.
15:02:13 <neversaynever> hi
15:02:41 <n-dolio> The other type of space leak happens when sharing causes certain things to be uncollectable, so you don't get an asymptotic win over a strict language.
15:02:53 <hseg> I don't like what http://lpaste.net/101469 looks like. Anyone have a better way of writing it?
15:03:03 <blablaa> n-dolio, i'm asking precisely if CPS can be used to implement something equivalent in performance to strict language. I know seq and i'm only asking if it is absolutely necessary or not.
15:03:42 <n-dolio> And the solution in that case is to not share certain things, and recompute them instead.
15:03:59 <n-dolio> But I'm not sure CPS would help you do that, either.
15:04:00 <blablaa> quicksilver, i'm asking about CPS and lazy eval. Not CPS and tuples.
15:04:10 <quicksilver> blablaa: I know you were.
15:04:22 <quicksilver> the answer to your question is No, as far as I know.
15:04:39 <blablaa> quicksilver, can you explain me why no? :)
15:04:48 <neversaynever> i want a function that receives the items as list  string representation and convert it to list type. toList :: (Read a, Show a) => String -> [a]    toList input = read ("[" ++ input ++ "]")
15:04:50 <blablaa> because with CPS one can bring to outermost what would be innermost.
15:05:05 <blablaa> but at the cost of passing continuations around...
15:05:05 <quicksilver> but that is just a formal transformation
15:05:11 <quicksilver> it doesn't change evaluation order
15:05:35 <quicksilver> AFAICR the CPS-transform is entirely semantics preserving
15:05:44 <byorgey> neversaynever: what's wrong with the function you just wrote?
15:05:58 <blablaa> quicksilver, we want to preserve semantics
15:06:05 <n-dolio> The only way CPS could help that I know if is by CPS encoding every data type that you use, because those are generally models of strict data types.
15:06:30 <quicksilver> blablaa: you generally can't eliminate space leaks without changing semantics.
15:06:31 <blablaa> quicksilver, the formal transformation can change execution order, no?
15:06:32 <neversaynever> byorgey, when i call it i get exception in Prelude saying Prelude.read. no parse
15:06:58 <quicksilver> eliminating a space leak will normally make something strict and preclude it from being _|_ (or infinite, e.g.) and that's a semantic change.
15:07:10 <byorgey> neversaynever: where are you calling this? at the ghci prompt or in a .hs file?
15:07:21 <blablaa> quicksilver, ok, that's good point
15:07:29 <neversaynever> byorgey: in ghci
15:07:36 <blablaa> quicksilver, i want to eliminate one kind of space leak caused by lazy eval...
15:07:38 <byorgey> > let toList input = read ("[" ++ input ++ "]") in  toList "3,4,5" :: [Int]
15:07:41 <lambdabot>  [3,4,5]
15:07:46 <blablaa> quicksilver, that kind where something is strict in reality but compiler doens't see it
15:07:48 <byorgey> neversaynever: you might need to add a type signature
15:08:12 <byorgey> neversaynever: the type might be defaulting to [()] or something silly like that
15:08:24 <geekosaur> shouldn't that be show input?
15:08:31 <blablaa> quicksilver, that should be possible, no?
15:08:38 <geekosaur> (judging by the type signature)
15:08:58 <byorgey> geekosaur: toList takes a String
15:09:11 <blablaa> quicksilver, because i would bring to outermost level what would cause evaluation later on...
15:09:13 <quicksilver> I think n-dolio is right; only if you CPS transform the data type (which is equivalent to making the data type string)
15:09:14 <neversaynever> byorgey: thanks a lot. i missed it.
15:09:31 <c_wraith> aaagh
15:10:00 <n-dolio> You have to be careful about how you use it, too.
15:10:04 <c_wraith> why was tyConModule not added until 7.8?
15:10:09 <c_wraith> Oh well.  At least it's in 7.8
15:10:21 <blablaa> n-dolio, i have to change data types? store continuations there too?
15:10:23 <blablaa> really?
15:10:25 <n-dolio> CPS encoding the natural numbers and then writing: 'foo n = ... fooo (cpsPlus n 1) ...' won't help.
15:10:34 <kuribas> In parsec, why isn't "expected" available, instead of <?> ?
15:10:48 <kuribas> I guess I could use "fail "" <?>" instead...
15:10:57 <n-dolio> You have to write all your functions as they would be evaluated in a strict language.
15:11:17 <blablaa> n-dolio, i don't need to change types, no?
15:11:27 <blablaa> n-dolio, just functions
15:11:32 <n-dolio> So 'foo n k = ... cpsPlus n 1 (<something with foo and k here>) ... '
15:11:57 <n-dolio> To make sure that the natural number is evaluated before the recursive call to foo.
15:12:25 <blablaa> n-dolio, yes, i need my own "+", this is what u're saying?
15:12:36 <n-dolio> And your own natural numbers.
15:13:13 <blablaa> why my own natural numbers?
15:13:41 <n-dolio> If you don't have seq, then switching from: 'foo n = foo (n+1)' to 'foo n k = foo (n+1) k' won't start evaluating n at each step.
15:13:47 <n-dolio> Even though that's now CPS.
15:13:53 <Walther> Is there a way to shorten/golf "map(map foo.bar)"?
15:14:25 <monochrom> that depends on bar
15:14:28 <Saizan> n-dolio: you can still have a CPS addition though
15:14:30 <n-dolio> You can implement seq for natural numbers, of course. So you don't need it as magic.
15:14:46 <Walther> monochrom: namely, map(map read.words)
15:14:56 <monochrom> if bar is a foldr, then «map foo . bar» can be rewritten
15:14:56 <Saizan> n-dolio: so you get foo n k = add n 1 (\m -> foo m k)
15:15:13 <n-dolio> Yeah, but you have to do some evaluating somehow. It can't just be: 'add m n k = k (m + n)'.
15:16:06 <monochrom> then I'll stick with «map read . words»
15:16:28 <Walther> not enough, as it is a list of lists -> need the second degree of ma
15:16:30 <Walther> map*
15:16:30 <monochrom> it could be rewritten but the benefit diminishes
15:16:53 <monochrom> the outer map has to stay.
15:17:01 <Walther> again, this is just for the sake of golfing, so any chars removed is a plus ;)
15:18:10 <blablaa> n-dolio, hmm i'm trying to understand.
15:18:36 <n-dolio> Got to go. Someone else will have to elaborate.
15:19:06 <blablaa> n-dolio, so i would need "add m n k = k $! (m + n)", that's your point?
15:19:15 <blablaa> n-dolio, or i need my own natural numbers?
15:35:59 <Dethkat> Hello again, is anybody about for a beginner question?
15:36:19 <Dethkat> I'm stuck on the type for this
15:36:44 <hpc> can you paste the code?
15:36:44 <geekosaur> @where justask
15:36:45 <lambdabot> Just ask your question. If somebody knows, they'll answer. If not, they won't, and you'll wait around; it will be no worse than having nobody who wants to claim expertise.
15:36:46 <hpc> @where hpaste
15:36:47 <lambdabot> http://lpaste.net/new/haskell
15:36:49 <Dethkat> toList (x,y) = [x,y]
15:37:07 <hpc> :t let toList (x,y) = [x,y] in toList
15:37:10 <lambdabot> (t, t) -> [t]
15:37:31 <Dethkat> thanks
15:38:10 <hpc> so what happens is, [x, y] is a list of some type [a]
15:38:16 <hpc> so the elements are both of type a
15:38:21 <hpc> so x :: a, y :: a
15:38:27 <hpc> so the tuple (x, y) :: (a, a)
15:38:44 <Dethkat> thats what i thought
15:39:18 <Dethkat> I was thinking something like this toList :: (a, a) = [a, a]
15:39:44 <Dethkat> or have I messed up?
15:40:17 <hpc> just a bit
15:40:40 <hpc> the type of functions is (arg -> result) with an arrow
15:40:42 <Dethkat> oh, well at least its only a bit
15:40:53 <Dethkat> yes of course
15:40:59 <hpc> and the list type takes only one type param
15:41:22 <Dethkat> toList (a, a) -> [a, a]
15:41:26 <hpc> (actual lists of types are much more "fun" and well down the line of learning)
15:41:43 <Dethkat> oh so [a]?
15:41:49 <hpc> yes
15:41:52 <ADexter> [a,a] is the same as a:[], so you can just write toList (a,a) -> [a]
15:42:07 <hpc> ADexter: no
15:42:08 <Dethkat> what is  that? sorry for the stupid questions?
15:42:18 <pavonia> I think you're mixing type signature and function defintion
15:42:21 <hpc> toList :: (a, a) -> [a]
15:42:27 <ADexter> ahh sry of course
15:42:27 <Dethkat> sure
15:42:28 <hpc> toList (x, y) = [x, y]
15:42:35 <ADexter> too late
15:43:10 <hpc> play around with the ":t" command in ghci and get a feel for how types get inferred and the general syntax
15:43:31 <Dethkat> I'vwe turned it on but had problems using it
15:44:10 <Dethkat> Your first comment I think has helped
15:44:19 <kuribas> Can ghc infer all the types when using GADTs?
15:44:53 <hpc> a very rough and high-level description is that ghc looks at everything and makes a huge system of "equations"
15:45:07 <Dethkat> Yes worked a treat, thanks very much for your help :)
15:45:11 <hpc> x :: a, y :: b, a = b (via list), etc
15:45:19 <hpc> and then it just solves for everything
15:45:36 <hpc> and the whole process is called unification
15:46:29 <kuribas> hpc: Like in prolog?
15:46:45 <pavonia> hpc: What do you mean by "via list"?
15:46:47 <hpc> kuribas: similar, yes
15:47:17 <kuribas> hpc: wait, did you refer to GADTs or normal types?
15:47:22 <hpc> pavonia: just eliding a few steps in the chain of "[x, y] implies type of x = type of y"
15:47:34 <pavonia> ah
15:47:43 <hpc> kuribas: i am just speaking in generality
15:48:59 <hpc> GADTs work by adding (~) constraints when you pattern match
15:49:22 <hpc> (a ~ b) meaning "a is the same as b", only it's different from just saying "a = b"
15:49:54 <kuribas> I see.
15:50:10 <hpc> i can't explain it very well today, i haven't thought about that in a while
15:50:24 <hpc> also i am multitasking a bit atm
15:50:55 <sm> help, what's the trick for getting rid of all these "Warning: haddock-html: /Users/simon/.cabal/share/doc/hfsevents-0.1.4/html doesn't exist or isn't a directory" type warnings from ghc-pkg check ?
15:52:47 <kuribas> GADTs made my code a lot cleaner, since I can test against types using (==) instead of using big case expressions.
15:57:45 <merijn> kuribas: Well, "a ~ b" is not so much "the same as" and more "unifies with"
15:58:03 <merijn> kuribas: So "a ~ [b]" is true (since 'a' can be '[b]')
15:58:30 <merijn> "(Int, b) ~ (a, Char)" is also true, since 'a' can be Int and 'b' can be Char
15:58:47 <hpc> in this context, "true" means "it typechecks"
15:59:07 <merijn> Indeed
15:59:35 <hpc> (as a side lesson, read up on curry-howard)
16:01:19 <kuribas> Does curry-howard apply to GADTs?
16:02:05 <hpc> yes
16:02:08 <quchen> Oh wow, `:k (~)` actually works
16:02:15 <quchen> I always wondered what enabled that operator
16:02:23 <hpc> it corresponds to a slightly more interesting logic system
16:02:36 <hpc> quchen: welcome to constraint kinds
16:02:40 <nooodl> quchen: is that * -> * -> Bool or something?
16:02:49 <quchen> :k (~)
16:02:51 <hpc> AnyK -> AnyK -> Constraint
16:02:51 <lambdabot> * -> * -> Constraint
16:03:01 <quchen> Not AnyK, actually.
16:03:06 <hpc> it was on mine
16:03:14 <mirror3000> hello
16:03:22 <quchen> hpc: "mine"?
16:03:23 <nooodl> what's Constraint?
16:03:27 <hpc> 7.4.1 or something
16:03:33 <Walther> hrmmm... Any smart ideas on how to golf `map(map read.words).filter(notElem '#')`
16:03:34 <quchen> Hmm. 7.6.3 here
16:03:48 <tnks> has anyone ever talked about a Haskell library (DSL) for drawing silly architectural diagrams, like for LaTeX.
16:03:54 <mirror3000> is there any mentor for gsoc here? i am a student and i have a question
16:04:05 <quchen> tnks: Check the `diagrams` package
16:04:10 <quchen> mirror3000: Check #haskell-gsoc
16:04:18 <mirror3000> thanks
16:04:33 <alpounet> nooodl: any restriction to a time: a ~ Int, Monad m, (Ord a, ToJSON a), etc
16:04:37 <alpounet> type*
16:04:43 <byorgey> tnks: what do you mean by "silly architectural diagrams"?
16:05:08 <tnks> byorgey: okay, serious architectural diagrams. . . Omnigraffle territory.
16:05:51 <tnks> shapes, arrows, text.
16:05:58 <quchen> TikZ style?
16:06:01 <byorgey> tnks: sorry, I don't even know what you mean by "architectural diagrams".  Do you mean blueprints? Or UML diagrams? Or circuit diagrams? or...
16:06:02 <zomg> I recall seeing some basic diagramming stuff where you could type stuff like "foo -> bar -> baz" and it'd generate a diagram like you'd expect
16:06:03 <quchen> Check the `diagrams` package
16:06:04 <byorgey> ok, I see
16:06:11 <tnks> yeah, kind of like TikZ only more high-level.
16:06:15 <zomg> but this was not Haskell, sounds like something it could do nicely with a DSL though
16:06:38 <byorgey> tnks: I don't know of any DSLs like that, but 'diagrams' would give you a nice starting point
16:06:42 <tnks> I'm thinking about something like what Elm does for web interaction.
16:06:51 <byorgey> it shouldn't be too much work to build such a DSL on top of what diagrams provides
16:07:03 <tnks> but less ambitious (just for pictures for my LaTeX docs)
16:07:16 <byorgey> tnks: what sort of pictures do you want to draw?
16:07:58 <tnks> byorgey: they tend to start with boxes and arrows. . . then with colors, then labels, and it seems to grow from there.
16:08:38 * tnks checking out diagrams
16:08:49 <byorgey> tnks: http://projects.haskell.org/diagrams/
16:08:55 <byorgey> tnks: also feel free to join #diagrams
16:08:57 <tnks> byorgey: thanks.
16:09:19 <tnks> byorgey: nice, I like what I'm seeing.
16:16:38 <Walther> hrmmm... Any smart ideas on how to golf `map(map read.words).filter(notElem '#')` shorter?
16:16:53 <hyuke> does haskell have any libraries for making 2d plots or surface plots?
16:17:43 <hyuke> I am coming form a C and Python backgrond. Python had nice libraries and with C you can always pipe to gnuplot. I guess I am asking if something exists for haskell that is not also piping to gnuplot (not that that's a big deal)
16:23:17 <kuribas> hyuke: Have you checked hackage?  http://hackage.haskell.org/packages/
16:24:04 <hyuke> kuribas: have not seen that. I am actually new to Haskell. I am just trying to convince myself it is worth a switch :)
16:24:10 <prinsen> What's the easiest way to stricly read an entire file into a ByteString, to avoid leaving the handle open
16:24:21 <kuribas> If have found: http://hackage.haskell.org/package/gnuplot and http://hackage.haskell.org/package/easyplot
16:24:46 <peddie> hyuke: chart is pretty good for making 2-d plots
16:25:18 <peddie> hyuke: they have plenty of examples at https://github.com/timbod7/haskell-chart/wiki to get you started
16:25:28 <hyuke> thanks guys :)
16:27:19 <artelius> Hi all, if Parsec hits a syntax error it will give you the line number and column, but I want to do some type checking etc. and if there are type errors I want to report the line number and column of the relevant declarations/usages. Presumably I need to store the line number and column of everything in the AST? What is a good way to do this?
16:29:47 <simon_> artelius, to give each constructor a position parameter
16:29:51 <sm> artelius: parsec tracks that as part of the parse state, you can access it while parsing and store it along with your parsed types
16:29:56 <simon_> artelius, perhaps not each constructor, but most.
16:34:58 <tnks> learning more about type families. . . can these be encoded with existential types?
16:35:16 <tnks> (or should I be asking #nothaskell. . . confused about this.
16:35:44 <Zekka> Hey, can I lift an (m a -> m b) to a (t m a -> t m b)?
16:35:51 <Zekka> Hoogle doesn't have any suggestions
16:36:08 <hpc> i don't think you can
16:36:20 <hpc> :t lift
16:36:22 <lambdabot> (Monad m, MonadTrans t) => m a -> t m a
16:36:28 <Zekka> Yeah, lift doesn't seem to be quite right
16:36:38 <Zekka> There's another way I can do it, don't worry
16:36:48 <Zekka> this was just a potentially easier way
16:36:53 <hpc> that's the only thing provided by MonadTrans, so you need something different at the type level
16:36:56 <hpc> to do it generically
16:37:32 <dsyang> Hey all, quick question about Test.QuickCheck
16:38:19 <dsyang> I defined my own Tree datatype and wrote a function find :: Tree a -> a -> Bool.  How can I test this function with quickcheck?
16:39:25 <artelius> well, thanks guys, I was hoping there was some monadic shortcut or something to save on repetition, I'm going to stare at it a bit longer...
16:44:20 <prinsen> What's the easiest way to stricly read an entire file into a ByteString, to avoid leaving the handle open? Right now I get To many open files
16:45:05 <hpc> getContents and then evaluate the length
16:45:09 <hpc> :t evaluate
16:45:11 <lambdabot> a -> IO a
16:47:25 * hackagebot diagrams-core 1.1.0.1 - Core libraries for diagrams EDSL  http://hackage.haskell.org/package/diagrams-core-1.1.0.1 (bergey)
16:50:22 <prinsen> schema <- Strict.readFile _file_; evaluate $ length schema
16:50:25 <prinsen> doesn't work
16:50:58 <hpc> hmm...
16:51:33 <quchen> evaluate (force schema)?
16:51:42 <quchen> Control.DeepSeq.force, that is
16:52:12 <MagneticDuck> anybody good at OpenGL in haskell here?
16:52:20 <prinsen> quchen: I tought evaluate did that
16:52:35 <MagneticDuck> question: what's the simplest way to draw a bitmap to the screen between two verticies?
16:52:44 <MagneticDuck> (scaled rectangly)
16:53:10 <Yaniel> he?
16:53:21 <Yaniel> draw a textured quad
16:54:02 <Yaniel> bu scaled rectangly I suppose you mean a nearest-neighbour-filter
16:54:06 <hpc> prinsen: strict BS might be using pascal-array kind of things, where it keeps the length separate
16:54:16 <Yaniel> (GL_NEAREST)
16:54:16 <hpc> in which case it doesn't evaluate the whole thing, or something
16:54:20 <quchen> prinsen: No, evaluate only evaluates stuff to WHNF. It's like an IO-based `seq`.
16:54:45 <hpc> quchen: not so much that, as that length doesn't force the whole thing
16:55:02 <quchen> Yeah, I was just speaking in general there.
16:55:09 <quchen> Not sure how the length of a BS is stored.
16:55:29 <quchen> Deepseq is usually the steam hammer to solve these kinds of problems though, but only if you're really sure you need a normal form.
16:55:34 <hpc> http://hackage.haskell.org/package/bytestring-0.10.4.0/docs/src/Data-ByteString-Internal.html#ByteString
16:55:41 <hpc> payload, offset, length
16:55:56 <hpc> not sure what the point of offset is
16:56:14 <prinsen> hpc: im using String atm
16:56:49 <prinsen> right now schema <- Strict.readFile _file_; evaluate $ (length schema) `seq` ()
16:57:18 <prinsen> doen't work
16:57:18 <hpc> that's the same thing as if it didn't have (`seq` ())
16:58:44 <prinsen> im trying deepseq atm
17:01:23 <prinsen> shouldn't Strict.readFile do this for me?
17:02:14 <pyon> Can a data instance be a newtype?
17:04:36 <ion> What’s a data instance?
17:05:03 <pyon> ion: An instance from a data family.
17:05:08 <pyon> http://www.haskell.org/haskellwiki/GHC/Type_families
17:05:23 <ion> Ah
17:05:40 <pyon> Apparently the answer was yes! (At least ghci did not complain.)
17:08:22 <MagneticDuck> Yaniel: "nearest-neightbour-filter"?
17:08:30 <MagneticDuck> hm
17:17:28 * hackagebot hspec-meta 1.9.0 - A version of Hspec which is used to test Hspec itself  http://hackage.haskell.org/package/hspec-meta-1.9.0 (SimonHengel)
17:21:38 <prinsen> Ok now I use
17:21:39 <prinsen>   jsonFile <- openFile json ReadMode
17:21:40 <prinsen>   schema <- hGetContents jsonFile
17:21:40 <prinsen>   rnf schema `seq` hClose jsonFile
17:21:47 <prinsen> and I still get to many open files
17:22:29 * hackagebot hspec 1.9.0 - Behavior-Driven Development for Haskell  http://hackage.haskell.org/package/hspec-1.9.0 (SimonHengel)
17:24:34 <quchen> Could be that the file is closed before you rnf it.
17:25:24 <prinsen> quchen: I don't thin so
17:27:08 <quchen> Well I do.
17:27:15 <quchen> It's probably unrelated to your leak though.
17:29:47 <prinsen> quchen: I followed System.IO.Strict
17:30:06 <prinsen> quchen: sry http://stackoverflow.com/questions/296792/haskell-io-and-closing-files
17:30:10 <Axman6> @hoogle withFile
17:30:10 <lambdabot> System.IO withFile :: FilePath -> IOMode -> (Handle -> IO r) -> IO r
17:30:10 <lambdabot> System.Posix.ByteString.FilePath withFilePath :: RawFilePath -> (CString -> IO a) -> IO a
17:30:11 <quchen> Try this one, withFile "foo.txt" ReadMode $ hGetContents >=> evaluate . force
17:30:35 <Axman6> needs moar bang patterns
17:32:02 <quchen> prinsen: When you run  "rnf schema `seq` hClose handle`, the hClose might be evaluated first, and you're rnf-ing a binding to a closed file.
17:32:31 <quchen> I think for standard IO the result is empty, and the ByteString API throws an exception.
17:33:15 <prinsen> quchen: I had a trailing readFile
17:33:27 <prinsen> quchen: Ill fix that first :)
17:34:41 <abbradar> Hello all! A question: if I define, for example, "let test :: Num a => a; test = 4 :: a", haskell gives me an error: I should explicitly write "let test :: Num a => a; test = 4 :: (Num a => a)". Is there a way to use "a" from type declaration inside function?
17:35:43 <quchen> abbradar: Assuming that's an artificial example, have a look at the ScopedTypeVariables extension.
17:36:13 <quchen> (The example is quite weird and I don't know where the question really comes from.)
17:36:16 <abbradar> quchen: Yes, that's artificial example and that looks just what I need. Thanks, I'll go check it out!
17:37:02 <jle`> has anyone tried building a data parallelism framework using arrows to build dependency graphs and stuff?
17:37:10 <jle`> is haxl some similar idea but using applicatives?
17:37:55 <abbradar> quchen: yes, that really hits the spot. thanks again!
17:38:05 <pavonia> > let test :: Num a => a; test = 4 :: a in test :: Int
17:38:08 <lambdabot>  Could not deduce (GHC.Num.Num a1) arising from the literal `4'
17:38:08 <lambdabot>  from the context (GHC.Num.Num a)
17:38:08 <lambdabot>    bound by the type signature for test :: GHC.Num.Num a => a
17:38:08 <lambdabot>    at <interactive>:1:13-22
17:38:08 <lambdabot>  Possible fix:
17:38:48 <pavonia> Can't you have normal type signatures in let-bindings?
17:39:01 <pavonia> Err, never mind
17:39:32 <quchen> What you wrote above can't possibly work. You first declare Test to be any Num, and in its definition assert that 4 should be a member of any type.
17:39:50 <quchen> "4 :: a" won't ever typecheck.
17:40:17 <pavonia> Yes, I missed the ":: a"
17:40:21 <hpc> :t let 4 :: a; 4 = 7 in "maybe?"
17:40:23 <lambdabot>     Invalid type signature: 4 :: a
17:40:23 <lambdabot>     Should be of form <variable> :: <type>
17:40:51 <hpc> oh, that's a new error
17:40:52 <quchen> Instance Num a where -- Okay let's stop here.
17:41:16 <jle`> can you do all useful things with Writer using its applicative interface?
17:41:27 <jle`> i guess you might want to branch on something you writer-calculated
17:41:28 <hpc> sometime i should play the ghc error game, and try and get as many unique messages out of it as possible
17:41:33 <andkore> Any recommendations on Web frameworks? I'm looking for something minimal (in scope) that doesn't use a bunch of GHC extension magic (e.g. Yesod with its Template Haskell and quasiquoting).
17:41:46 <hpc> andkore: snap, maybe?
17:41:48 <quchen> I think Scotty is the usual minimal recommendation.
17:41:49 <jle`> andkore: i always liked scotty
17:42:09 <hpc> it's definitely not happstack, which uses acid-state
17:42:16 <quchen> The "big" ones are Happstack, Yesod and Snap.
17:42:18 <hpc> (or recommends, rather)
17:42:41 <quchen> There's also Hakyll for static site generation.
17:42:56 <andkore> Definitely not lookign for a static site generator, but thanks
17:43:12 <andkore> I can't remember why I crossed of snap, lemme look. I was iffy on the "snaplets".
17:43:18 <quchen> You can run it on a per-request basis :>
17:43:27 <hpc> if you don't mind partying like it's 1999, you can get up and running with CGI without libraries very quickly
17:44:02 <biscarch> andkore You don't have to use snaplets.
17:44:06 <andkore> hpc: I basically want something that will be a step above that, and with routing.
17:44:19 <biscarch> They're useful IMO, but if you're not happy with them then don't use any
17:44:35 <andkore> biscarch: Right. I strongly prefer to use things that are more like "libraries" and throw in more libraries as needed. Not use giant frameworks and then not use half of them.
17:45:27 <andkore> Anyway, thanks for the input everyone. I'll do some more research and come back if I have some more specific questions.
17:45:29 <quchen> That reminds me of that I wanted to read up on Snap/Happstack. I remember one of the selling points of the latter being modularity (i.e. use whatever libs you want).
17:45:58 <quchen> Not having my own server makes the choice simpler though: no choice. :-þ
17:45:59 <biscarch> quchen it is.
17:46:15 <quchen> biscarch: Are you a developer?
17:46:27 <biscarch> yes
17:47:36 <quchen> biscarch: So in my (superficial) experience, Yesod seemed somewhat 'big'. I think Snap at the time was more similar to Happstack.
17:47:49 <quchen> Is that still somewhat correct?
17:47:54 <pikaren> hows haskell compared to scala
17:48:22 <biscarch> IMO, yes. Yesod is very opinionated in that way and Snap is more modular
17:48:51 <quchen> More modular compared to Yesod, or Happstack?
17:48:56 <biscarch> Yesod
17:49:28 <MagneticDuck> pikaren: haskell is cooler =P
17:49:36 <quchen> No language wars please :-/
17:49:50 <MagneticDuck> =P
17:49:57 <quchen> I feel like this "which web framework is right for me" question comes up a lot. A neutral summary would probably help a lot of people.
17:49:57 <pikaren> XP
17:50:16 <biscarch> quchen there's one on SO iirc
17:50:29 <quchen> Oh, is there? I missed that
17:50:33 <davidthomas> The Yesod scaffold is opinionated, but the intent with Yesod seems to be that it *can* be broken apart.  I don't have experience doing so, though.
17:50:52 <biscarch> quchen http://stackoverflow.com/questions/5645168/comparing-haskells-snap-and-yesod-web-frameworks
17:51:07 <simon_> anyone who asks the question should of course try at least Snap and Yesod. and anyone doing so will quickly (as in, within a couple of days) gather their own opinions. it shouldn't be difficult. :)
17:51:14 <Javran> is there a "(MonadTrans t1, MonadTrans t2, Monad m) => t1 m a -> t1 (t2 m) a" ?
17:51:23 <biscarch> not sure if happstack is there, but Snap + Yesod both have lead devs in the answer section
17:52:18 <sm> have to add spock to the web frameworks list, these days
17:52:57 <Javran> say I have a "RandT g IO a" and now I want a "RandT g (MaybeT IO) a"?
17:54:15 <c_wraith> Javran: that's the sort of thing the mmorph package was designed for.  it'd be "hoist lift", except I doubt there's an instance for RandT
17:54:39 <biscarch> simon_ of course. It's becomes mainly a personal preference afaik
17:54:40 <quchen> Javran: Have a look at the mmorph package to convert between transformers
17:55:11 <sm> Spock, I should say
17:55:39 <andkore> "Snap does have sessions and authentication, interfaces to several databases" <-- I might sound really crazy here, but I'm not sure I want my Web framework to do anything with databases
17:56:01 <c_wraith> andkore: in that case, strip that stuff out.  It's all optional.
17:56:28 <c_wraith> andkore: there's user sessions in the default app, but they're trivial to rip out.
17:56:41 <c_wraith> andkore: and if you build a minimal app, it won't have any of that
17:56:51 <andkore> c_wraith: The more I say, the whinier I'll sound... I'm not sure I want my web framework to even provide that option.
17:57:13 <c_wraith> andkore: You don't like when people like libraries to ease integration?
17:57:17 <biscarch> andkore the database stuff is libs, not strict "this is the one-true-way" sort of stuff
17:57:29 <c_wraith> *make* libraries
17:57:38 <andkore> to me they seem orthogonal. some applications need DB access but don't do HTTP. Some are the reverse.
17:57:51 <c_wraith> So..  Don't use the glue libraries.
17:58:08 <c_wraith> That's all they are.  "If you use these two things together, here are some convenience functions"
17:58:40 <andkore> Right
17:58:43 <c_wraith> It's not implementing the http server in the database drivers, or vice versa.  It's just convenience stuff for using them together.
17:58:49 <simon_> biscarch, well, I went through a couple of frameworks and ended up liking Snap in favour of Yesod for a number of reasons that transcend personal preference (it was simply easier to deal with).
17:59:22 <c_wraith> speaking of Snap, I've spent like 8 hours hacking on it today..  Getting it running on GHC 7.8, and now I'm speeding up the dynamic loader a bit.
17:59:24 <flebron> So I get that something like length :: [a] -> Int can be modeled as a natural transformation between the functors [] and Const Int. However, what if we have two type variables? What is something like fmap :: (a -> b) -> (f a -> f b)? It would seem that "for each object (a) there's a natural transformation (\b -> ...)". What is this sort of thing?
18:00:00 <c_wraith> "speeding up" isn't really accurate.  It'd be much more accurate to say "making it run concurrently so you don't notice as much how slow it is"
18:00:15 <biscarch> simon_ Snap was or Yesod was?
18:00:26 <simon_> biscarch, Snap was easier.
18:00:27 <biscarch> c_wraith I saw that. Very nice.
18:00:41 <copumpkin> flebron: just treat them independently
18:00:59 <simon_> biscarch, when it boils down to this kind of a statement, it surely sounds like nothing more than a personal preference.
18:02:14 <flebron> copumpkin: Hrm? That's what I thouht of when I wrote "a natural transformation for each object".
18:02:17 <quchen> Haha, I now understand the "stack" part of Happstack: http://hackage.haskell.org/package/happstack-server-7.3.4/docs/Happstack-Server-Monads.html#t:Happstack
18:02:43 <copumpkin> flebron: well, you can do it over the product of the two variables, for example
18:02:52 <copumpkin> and "uncurry" the two type variables
18:02:56 <c_wraith> quchen: Snap's MonadSnap is about the same.
18:02:58 <copumpkin> then your functors can pull out the parts
18:03:16 <copumpkin> flebron: in general, you probably want dinatural transformations or something to deal with the contravariant ones
18:03:50 <flebron> Man, the theory sure gets weird :p
18:05:01 <c_wraith> is Profunctor a dinatural transformation?
18:05:14 <c_wraith> I suppose it is.  It has dimap, after all.
18:06:40 <copumpkin> nah they're different sorts of things
18:06:50 <copumpkin> I'm sure you can express them in terms of one another if you get weird enough
18:11:38 <Javran> c_wraith: quchen: thanks you! I read that document and I think what I want is something like:  "hoist return v"?
18:11:38 <Javran>  
18:11:54 <c_wraith> Javran: hoist lift, I think
18:13:37 <Javran> c_wraith: ops, you are right, I wrongly thought the morphism was :: IO -> MaybeT IO
18:20:59 <flebron> So m is a monad if, when replacing f by return . f, what I get is a category? (The Kleisli category)
18:22:10 <c_wraith> well.  If what you get by doing that is a transformation from one category to another.
18:22:25 <flebron> Oh, nevermind, the idea is that what's being tested is the composition in this new category, which is comp f g = join . fmap f . g
18:23:57 <kadoban> I'm going to be parsing some binary data, is Parsec an okay tool for that, or should I be looking at something else?
18:25:35 <ezrios> kadoban: you can use ByteStrings in Parsec
18:25:48 <ezrios> kadoban: http://book.realworldhaskell.org/read/efficient-file-processing-regular-expressions-and-file-name-matching.html
18:26:05 <thebnq> kadoban: if you need speed, attoparsec will be faster
18:26:07 <ezrios> er, that is the wrong chapter
18:26:40 <ezrios> hm, actually I don't think RWH covers parsing binary data in Parsec. nevermind ._.
18:26:51 <kadoban> Ah, cool you can use ByteStrings though, I'm glad to hear that
18:27:02 <kadoban> I don't terribly care about speed I don't think, it should be quite small files
18:27:07 <kadoban> Thanks :)
18:42:35 * hackagebot force-layout 0.3.0.3 - Simple force-directed layout  http://hackage.haskell.org/package/force-layout-0.3.0.3 (BrentYorgey)
18:47:36 * hackagebot diagrams-lib 1.1.0.3 - Embedded domain-specific language for declarative graphics  http://hackage.haskell.org/package/diagrams-lib-1.1.0.3 (bergey)
18:50:50 <Nyyx> @pl \x -> x * 2 -1
18:50:50 <lambdabot> subtract 1 . (2 *)
18:52:36 * hackagebot diagrams-contrib 1.1.1.2 - Collection of user contributions to diagrams EDSL  http://hackage.haskell.org/package/diagrams-contrib-1.1.1.2 (bergey)
18:52:38 * hackagebot diagrams-cairo 1.1.0.2 - Cairo backend for diagrams drawing EDSL  http://hackage.haskell.org/package/diagrams-cairo-1.1.0.2 (bergey)
18:52:40 * hackagebot diagrams-postscript 1.0.2.2 - Postscript backend for diagrams drawing EDSL  http://hackage.haskell.org/package/diagrams-postscript-1.0.2.2 (bergey)
18:52:42 * hackagebot diagrams-svg 1.0.2.1 - SVG backend for diagrams drawing EDSL.  http://hackage.haskell.org/package/diagrams-svg-1.0.2.1 (bergey)
18:57:37 * hackagebot diagrams-builder 0.5.0.5 - hint-based build service for the diagrams graphics EDSL.  http://hackage.haskell.org/package/diagrams-builder-0.5.0.5 (bergey)
18:58:00 <asdf_> how do i build a 2d accumArray of sizes x and y?
19:01:24 <asdf_> how to make 2d accumulative array of size x and y?
19:03:03 <gaze> Hey folks! Does doing a datatype generic tree matching thing sound like a feasable thing to do?
19:03:30 <gaze> as in, specifying the rewrite rules along with a cost as a map from one tree datatype to another tree datatype
19:05:14 <gaze> I just don't know the best way to express the idea of two things matching a pattern in haskell
19:06:26 <roboguy_> asdf_: can you be more specific?
19:07:29 <asdf_> i want to create a 2d array of integer values in which i will add to later. col size is x, row size is y
19:07:50 <roboguy_> gaze: what kind of a mapping between trees?
19:08:17 <roboguy_> asdf_: what do you want to fill it with?
19:08:36 <asdf_> integer numbers from a tree that i'm supposed to traverse
19:08:59 <gaze> Say trivially I have a datatype ExprTriv a = Add a a; ExprCmplx = Add a a | AddAdd a a a, where AddAdd was a machine instruction that could be completed in the same number of cycles as an Add
19:09:17 <gaze> and the idea would be to try to reduce a tree of ExprTrivs to ExprComplxs
19:09:32 <colDrMcBeardman> any hspec users here? how do I express class constraints with prop?
19:09:45 <gaze> this is of course very easy for the case I've given, you greedily convert Adds to AddAdds but this is not necessarily optimal for a more complicated "instruction set"
19:10:04 <gaze> and is best solved by dynamic programming i.e. the HBURG library on hackage
19:10:15 <gaze> however, I am curious if this could be done in a datatype generic fashion
19:10:21 <roboguy_> gaze: you could do rewrite rules in the form of pattern matching
19:10:37 <gaze> yes but pattern matching is greedy
19:10:45 <gaze> that's exactly what I _don't_ want
19:11:01 <gaze> or rather, pattern matching as implemented in haskell is greedy
19:11:18 <gaze> this is a language restriction that makes sense obviously
19:11:44 <gaze> but I'm curious what the most sensible expression of a more complex datatype generic pattern matching system might be
19:12:46 <roboguy_> gaze: you could use the non-determinism monad/applicative, []
19:14:03 <gaze> I don't quite follow
19:15:12 <roboguy_> well, you could try every possibility and then find the one with the least cost
19:15:32 <roboguy_> I'm not sure if there can be a more efficient way, without knowing the specifics
19:15:50 <gaze> yes definitely. Optimal tree solving is a solved problem by dynamic programming. This isn't my question
19:16:21 <roboguy_> asdf_: you might want to try to convert it to an association list
19:16:24 <gaze> I want to understand how to best express multiple matching patterns in haskell
19:17:42 <asdf_> its for an assignment, and i'm supposed to make arrays
19:18:44 <roboguy_> asdf_: you can turn an association list into an array. in fact, that's what accumArray does
19:18:45 <gaze> the trivial case is "rw1 (Add x y) = Just (Add2 x y); rw1 _ = Nothing; rw2 (Add x (Add y z) = Just AddAdd2 x y z; rw2 _ = Nothing" and then you hammer all of them and drop all the nothings
19:18:49 <gaze> or rather
19:18:51 <gaze> the naive strategy
19:18:53 <gaze> hurr
19:19:30 <gaze> then you have a list of all valid rewrites
19:19:48 <gaze> but can you do better?
19:20:48 <gaze> I'd hope you could encode some intelligence about what the thing might be good on into it so you'd only select rewrites that are "good" on your current place on the tree
19:21:02 <gaze> does this make sense?
19:21:11 <roboguy_> hmm, yeah
19:21:57 <gaze> I haven't been consistent in my types, Add is the trivial tree, Add2/AddAdd2 in the above example are for the "optimized" instruction set
19:22:06 <gaze> but hopefully you get the gist
19:23:42 <asdf_> this is what my tree looks like. it contains row and col indexes, and the number im supposed to add to that intersection of rows and cols. I have to turn this tree into a 2d array. Group [Row [1,2] [Col [3] [Add 4]],Row [3] [Col [5] [Add 2],Col [6] [Add 2]],Row [4] [Col [7,8,9] [Add 1]]]
19:24:52 <gaze> ekmett : ping
19:25:36 <roboguy_> gaze: this sounds like something that plated would be used for, but I've never used it
19:27:21 <roboguy_> asdf_: well, I'd probably start by writing a function "Tree -> [(Index, Data)]" (with the appropriate types for Index and Data)
19:30:58 <roboguy_> Index would probably be something like (Int, Int)
19:32:40 * hackagebot warp 2.1.2 - A fast, light-weight web server for WAI applications.  http://hackage.haskell.org/package/warp-2.1.2 (MichaelSnoyman)
19:32:42 * hackagebot conduit 1.0.16 - Streaming data processing library.  http://hackage.haskell.org/package/conduit-1.0.16 (MichaelSnoyman)
19:37:40 * hackagebot http-client 0.2.2.3 - An HTTP client engine, intended as a base layer for more user-friendly packages.  http://hackage.haskell.org/package/http-client-0.2.2.3 (MichaelSnoyman)
19:43:08 <Javran> @hoogle b -> [(a,b)] -> Maybe a
19:43:09 <lambdabot> Data.Graph.Inductive.Graph lab :: Graph gr => gr a b -> Node -> Maybe a
19:43:09 <lambdabot> Prelude lookup :: Eq a => a -> [(a, b)] -> Maybe b
19:43:09 <lambdabot> Data.List lookup :: Eq a => a -> [(a, b)] -> Maybe b
19:43:25 <Javran> @hoogle (a,b) -> (b,a)
19:43:26 <lambdabot> Data.Tuple swap :: (a, b) -> (b, a)
19:43:26 <lambdabot> Data.Graph.Inductive.Query.Monad (><) :: (a -> b) -> (c -> d) -> (a, c) -> (b, d)
19:43:26 <lambdabot> Data.Graph.Inductive.Query.Monad mapSnd :: (a -> b) -> (c, a) -> (c, b)
19:44:36 <Javran> :t (,).uncurry flip
19:44:37 <lambdabot> (a -> b1 -> c, b1) -> b -> (a -> c, b)
19:45:54 <ezrios> woo, babby's first parser
19:46:08 <Javran> @pl \(x,y) -> (y,x)
19:46:08 <lambdabot> uncurry (flip (,))
19:46:09 <ezrios> even though it is a specialized CSV parser it works
19:50:23 <copumpkin> Javran: there's a swap function
19:50:25 <copumpkin> :t swap
19:50:27 <lambdabot> (a, b) -> (b, a)
19:52:40 <Javran> copumpkin: I see, I want to have a "b -> [(a,b)] -> Maybe a", wondering if there's a shorthand
19:53:07 <copumpkin> arrange for the (a, b) to be the other way around, then use lookup
19:53:08 <copumpkin> :t lookup
19:53:10 <lambdabot> Eq a => a -> [(a, b)] -> Maybe b
19:53:36 <copumpkin> :t \x -> lookup x . map swap
19:53:38 <lambdabot> Eq a => a -> [(b, a)] -> Maybe b
19:55:23 <Javran> copumpkin: I see, thanks.
19:55:33 <copumpkin> you can @pl that but I wouldn't recommend it
19:56:05 <copumpkin> much better would be to arrange to have the elements in swapped order to begin with
19:56:11 <copumpkin> or to use a Map
19:56:15 <copumpkin> which will be more efficient
19:57:15 <Galactic> has someone implemented a counting sort in haskell?  I am looking at one example but I don't understand it too much.
19:57:25 <Javran> @pl \x -> lookup x . map swap
19:57:25 <lambdabot> (. map swap) . lookup
19:57:36 <Javran> just out of curiosity
20:07:12 <Javran> :t ((.) . (flip (.)) ) (map swap) lookup
20:07:15 <lambdabot> Eq b => b -> [(a, b)] -> Maybe a
20:08:01 <copumpkin> ugh
20:08:49 <Javran> try that semantic editor combinators
20:10:14 <[swift]> does anyone know how to do different stuff in cabal depending on the OS *version*?
20:10:30 <[swift]> i need different behavior for OS X 10.9 vs earlier versions
20:11:25 <startling> [swift], you can probably do it in a Setup.hs
20:11:46 <[swift]> startling: do you know how?
20:11:52 <[swift]> startling: my google-fu is failing me on this one
20:12:07 <[swift]> i have quite an extensive Setup.hs already, so i don't mind doing it there if need be
20:12:36 <startling> [swift], do I know how to do what?
20:13:06 <[swift]> startling: how to check the OS version. System.Info doesn't have it, for example
20:13:28 <startling> [swift]: you're probably going to have to shell out to something
20:14:05 <startling> [swift]: quick google search indicates that sw_vers is a little os x utility that prints some information
20:14:53 <[swift]> startling: thanks, that's useful. shelling out made me think of uname, and i just noticed that Bindings.Uname exists... maybe that will work
20:15:11 <startling> [swift]: I don't think uname will tell you the os x version, just the kernel version
20:15:58 <[swift]> startling: ah, that's true. there's probably some mapping between the two but i don't really want to go there
20:16:08 <startling> yeah, agreed.
20:20:44 <joe9> I came across this article about type classes misuse in haskell and wanted to check if Idris has existential functionality?: http://codepad.org/DKzU0ZUc http://www.ninebynine.org/Software/Learning-Haskell-Notes.html#type-class-misuse
20:21:22 <dolio> I'm sure you can create existentials in Idris.
20:21:35 <joe9> dolio, ok, thanks.
20:22:20 <Galactic> can someone explain to me how this code works...I know what it does but there are just too many things going on for my brain to process :)
20:22:22 <Galactic> countingSort :: (Ix n) => [n] -> n -> n -> [n]
20:22:22 <Galactic> countingSort l lo hi = concatMap (uncurry $ flip replicate) count
20:22:22 <Galactic>   where count = assocs . accumArray (+) 0 (lo, hi) . map (\i -> (i, 1)) $ l
20:22:44 * hackagebot purescript 0.4.8 - PureScript Programming Language Compiler  http://hackage.haskell.org/package/purescript-0.4.8 (PhilFreeman)
20:23:52 <Galactic> for example what does this do: accumArray (+) 0 (lo, hi) . map (\i -> (i, 1)) $ l
20:24:18 <Galactic> where is the second parameter for map?
20:27:17 <c_wraith> Galactic: you need to learn what the . operator does
20:30:15 <asdf_> how can i turn this regular expression into a 2d array (([RC]k([,-]l)*)*+m;)* where k,l,m are integers and R,C denote row and column, and value of m is added to said index?
20:31:42 <Galactic> maybe an easier question (to explain at least). How does this work.:
20:31:49 <Galactic> > accumArray (+) 0 (0,8) (map (\i -> (i,1)) [3,1,2,4,5,6,6])
20:31:52 <lambdabot>  array (0,8) [(0,0),(1,1),(2,1),(3,1),(4,1),(5,1),(6,2),(7,0),(8,0)]
20:33:01 <Galactic> sorry, I am brain dead right now...I should reformat and start over. lol
20:35:14 <Kron> :t accumArray
20:35:18 <lambdabot> Ix i => (e -> a -> e) -> e -> (i, i) -> [(i, a)] -> Array i e
20:35:37 <Kron> it's some kind of fold?
20:36:41 <copumpkin> :t M.fromListWith
20:36:43 <lambdabot> Ord k => (a -> a -> a) -> [(k, a)] -> M.Map k a
20:36:51 <copumpkin> it's similar to that
20:37:13 <copumpkin> but yeah, you can think of it as a keyed fold
20:38:29 <Kron> > map (,1) [3,1,2,4,5,6,6]
20:38:32 <lambdabot>  [(3,1),(1,1),(2,1),(4,1),(5,1),(6,1),(6,1)]
20:40:36 <Galactic> > accumArray (+) 0 (0,7) (map (\i -> (i,1)) [3,1,2,4,5,6,6])
20:40:39 <lambdabot>  array (0,7) [(0,0),(1,1),(2,1),(3,1),(4,1),(5,1),(6,2),(7,0)]
20:40:44 <Galactic> how are the numbers sorted?
20:41:02 <Galactic> does accumArray sorts?
20:41:08 <c_wraith> Galactic: they're not.  They're just counted.
20:41:34 <c_wraith> Galactic: The resulting array contains a count of how many times each number appeared in the input.
20:42:00 <c_wraith> Galactic: the second half of count sort is taking the counts and generating a new list from them.
20:42:38 <Galactic> I see, ty
20:57:47 * hackagebot llvm-general-pure 3.3.11.2 - Pure Haskell LLVM functionality (no FFI).  http://hackage.haskell.org/package/llvm-general-pure-3.3.11.2 (BenjaminScarlet)
20:57:49 * hackagebot llvm-general 3.3.11.2 - General purpose LLVM bindings  http://hackage.haskell.org/package/llvm-general-3.3.11.2 (BenjaminScarlet)
20:57:51 * hackagebot llvm-general-pure 3.4.2.2 - Pure Haskell LLVM functionality (no FFI).  http://hackage.haskell.org/package/llvm-general-pure-3.4.2.2 (BenjaminScarlet)
20:57:53 * hackagebot llvm-general 3.4.2.2 - General purpose LLVM bindings  http://hackage.haskell.org/package/llvm-general-3.4.2.2 (BenjaminScarlet)
21:09:37 <Galactic> what is the extended form of this?:  map (uncurry $ flip replicate) [(0,0),(1,1)]
21:10:01 <Galactic> because I am trying to do this: uncurry $ flip replicate (0,0)
21:10:07 <Galactic> and I get an error
21:10:20 <ion> > (uncurry $ flip replicate) (0,0)
21:10:22 <Galactic> I know that replicate does not take a tupple
21:10:23 <lambdabot>  []
21:10:30 <Galactic> aaa ok
21:11:36 <Galactic> wow wtf, so could you write that in expanded form?
21:12:11 <startling> :t uncurry
21:12:13 <lambdabot> (a -> b -> c) -> (a, b) -> c
21:12:24 <startling> > uncurry (+) (1, 2)
21:12:26 <lambdabot>  3
21:12:37 <Galactic> yeap I got that
21:12:48 * hackagebot rados-haskell 3.0.0 - librados haskell bindings  http://hackage.haskell.org/package/rados-haskell-3.0.0 (ChristianMarie)
21:13:10 <startling> Galactic: "uncurry $ flip replicate (0,0)" is "uncurry (flip replicate (0, 0))".
21:13:10 <ion> uncurry (flip replicate) (a,b) = uncurry (\x n -> replicate n x) (a,b) = (\(x,n) -> replicate n x) (a,b) = replicate b a
21:14:32 <ion> Writing that as “uncurry $ flip replicate” instead of “\(x,n) -> replicate n x” is just obfuscation IMO.
21:15:43 <Galactic> This one: \(x,n) -> replicate n x    I understand  but the other one is brain fuck for me.
21:15:56 <kadoban> seems clear enough to me, once i remember what uncurry does. if it was any more complicated it seems like it'd be bad though
21:16:24 <Galactic> > flip replicate (0,0)
21:16:26 <lambdabot>  <Int -> [(Integer,Integer)]>
21:16:43 <Galactic> ????
21:16:55 <ion> You forgot the uncurry.
21:17:49 <ion> > uncurry (flip replicate) ('x',10)
21:17:51 <lambdabot>  "xxxxxxxxxx"
21:17:52 <ion> > flip replicate 'x' 10
21:17:53 <lambdabot>  "xxxxxxxxxx"
21:18:17 <Galactic> oooooooooooooooo I see the uncurry gets applied first to the (0,0)???
21:18:46 <Galactic> and then passed to the  flip replicate
21:18:47 <kadoban> Galactic: uncurry transforms the (flip replicate) function into something that takes a tuple
21:18:48 <ion> uncurry gets applied to the two values “(flip replicate)” and “('x',10)”
21:18:52 <ion> @src uncurry
21:18:53 <lambdabot> uncurry f p = f (fst p) (snd p)
21:19:24 <thebnq> wonder why the src doesn't pattern match
21:19:32 <ion> ditto
21:21:41 <dmj`> @typ concatMap $ uncurry replicate
21:21:43 <lambdabot> [(Int, b)] -> [b]
21:21:53 <Twey> The evaluation properties of a pattern-matching version aren't quite the same
21:22:17 <Twey> In this version, if f never looks at either of its arguments, p can be non-terminating but uncurry f will still be terminating
21:22:26 <dmj`> can ghc give me a list of all dependencies I'm not using?
21:22:49 <Twey> I.E. this version is as lazy as the function it's given, whereas otherwise it would add strictness
21:23:04 <thebnq> Twey: that makes sense, wouuld it be the same as matching ~(a,b) though?
21:23:14 <pyon> Is there any way to make a single Haddock comment for several functions?
21:23:38 <Twey> thebnq: Yeah, that's how we'd write it nowadays, but these @src definitions are from the H98 report I think
21:23:51 <Twey> pyon: Not AFAIK
21:23:55 <Twey> pyon: Bug Fuuzetsu to add it ;)
21:24:06 <pyon> Dang.
21:24:38 <dolio> You could write it that way in Haskell 98. They just didn't in the report.
21:24:41 <Twey> pyon: You can have sections in your documentation, though
21:24:47 <thebnq> aha. i only learnt of ~() today :)
21:24:58 <pyon> Twey: Ah, true that.
21:25:00 <Twey> dolio: We had irrefutable patterns in H98?  I can't remember
21:25:07 <dolio> Of course.
21:25:13 <Twey> Oh, okay.
21:26:32 <dolio> Haskell 1.0 had them. :)
21:27:34 <pyon> Is there any way to have ghci warn me about incomplete pattern matching?
21:27:57 <pyon> Sometimes I just... forget to make my functions total.
21:28:15 <Twey> pyon: -Wincomplete-patterns, I think?
21:28:23 <Twey> pyon: -Wall, at any rate
21:28:55 <Twey> I just got into the habit of writing the boring cases first :þ
21:30:10 * startling . o O ( case twey of _ -> ...; Just a -> ...; )
21:31:36 * Twey is thrown away ☹
21:31:50 * copumpkin rescues Twey
21:32:44 <dolio> If you write core, and use _DEFAULT_, it works. :)
21:32:48 <thebnq> don't throw him atwey :s
21:33:19 * Twey winces.
21:34:35 <dolio> Twey: In fact, going back and looking, ~ has always been used to give the operational semantics of let/where clauses.
21:36:29 <dolio> let p1 = e1 ; p2 = e2 ; ... ; pn = en in e ==> case fix (\~(~p1,~p2,...,~pn) -> (e1,e2,...,en)) of ~(~p1,~p2,...,~pn) -> e
21:41:18 <pavonia> Can you assure that with GADTs only a certain constructor is passed as an argument to a function? I think someone pasted an example of that yesterday
21:46:33 <pavonia> This seems to be where phantom types come into play
21:48:34 <Twey> dolio: Huh.  Interesting.
21:48:44 <Twey> pavonia: Yes
21:49:30 <Twey> pavonia: data ABool ∷ Bool → ★ where ATrue ∷ ABool True; AFalse ∷ ABool False
21:50:04 <Twey> pavonia: doSomethingWithATrue ∷ ABool True → B; doSomethingWithAnyABool ∷ ABool a → C
21:51:06 <pavonia> But that only works if there aren't any other functions that are able to return an ABool True value, no?
21:51:15 <Twey> (KindSignatures and DataKinds to restrict the kind to a Bool)
21:51:31 <Twey> pavonia: The only ABool True value there is is ATrue
21:51:38 <Twey> (and bottom)
21:51:53 <Twey> The only way a function could return an ABool True is if it returns ATrue (or bottom)
21:52:02 <Twey> That's what GADTs are for
21:54:10 <pavonia> Twey: Right. Let's say we also have AMagic :: ABool a, that would be accepted too
21:55:05 <pavonia> Hhm, would it?
21:56:05 <Twey> pavonia: Yes.  But in that case you've added the constructor yourself.
21:56:29 <Twey> @let data ABool :: Bool -> * where ATrue :: ABool True; AFalse :: ABool False; AMagic :: ABool a
21:56:29 <lambdabot>  Parse failed: Parse error: Bool
21:56:43 <Twey> No KindSignatures, I guess :-\
21:57:03 <Twey> @let data ABool a where ATrue :: ABool True; AFalse :: ABool False; AMagic :: ABool b
21:57:03 <lambdabot>  Parse failed: GADTs is not enabled
21:57:07 <Twey> Bah
21:58:29 <[swift]> argh, you don't seem to be able to use conditionals when setting the default value of a flag in a cabal file
22:17:53 * hackagebot cron 0.2.1 - Cron datatypes and Attoparsec parser  http://hackage.haskell.org/package/cron-0.2.1 (MichaelXavier)
22:22:39 <NemesisD> hey guys. i was looking to create a related typpeclass in my code to Serialize that only does one way or the other
22:23:40 <pyon> NemesisD: What exactly do you mean by "one way or the other"?
22:23:46 <NemesisD> i.e. i've got types that do not need to deserialize and vice versa. the problem is if i try to do something like class Serialize a => OnlyPut a where... i have to turn on undecidable and overlapping instances
22:24:36 <pyon> NemesisD: Why do you need a class for something that can *only* be serialized?
22:24:37 <NemesisD> pyon: i plan to in my code only to use the constraint OnlyPut rather than Serialize so that my program can be total and i can be assured i'm not calling the undefined deserialization funciton
22:25:02 <ion> pyon: “Show”
22:25:21 <pyon> NemesisD: If your type signature does not have a constraint "(... Deserialize s ...) =>", you cannot use the deserialize function on instances of s.
22:25:25 <NemesisD> pyon: under the hood i'm using cereal's Serialize class, but it forces you to implement the parse and encode functions. there is no necessary/sensible encode (or in other cases parse) impl
22:25:34 <pyon> Oh, whoa.
22:26:02 <NemesisD> its pretty inelegant. i don't understand why they forced both into the same class
22:26:26 <pyon> NemesisD: Me either. Obviously serialization and deserialization belong in different classes.
22:26:47 <SrPx> Honest question, do you guys think Haskell is completely capable of replace C++ for every single one of its uses, including systems programming, numerical computations and game engines?
22:27:16 <NemesisD> pyon: looks like binary does the same thing :( http://hackage.haskell.org/package/binary-0.7.1.0/docs/Data-Binary.html
22:27:17 <pyon> SrPx: Systems programming --> no. Numerical computing --> yes. Game engines --> no idea, not my area of interest.
22:27:36 <SrPx> pyon: I see, why not?
22:28:08 <kadoban> SrPx: because C++ (actually C) is really good at systems programming, and in Haskell it's relatively awkward
22:28:11 <pyon> SrPx: Not fine grained enough resource management. Haskell's type system is very powerful, but this is one thing it cannot do.
22:29:04 <NemesisD> kadoban: is C++/C actually good at systems progamming or is it the incumbant because the APIs were written for it
22:29:06 <pyon> SrPx: Actually, one could envision a safe functional language for systems programming, but this needs the ability to encode in types the kinds of thing systems programmers want to express.
22:29:17 <pyon> kind* of things*
22:29:53 <kadoban> NemesisD: Well, i haven't seen anything better. I don't know that I can argue either way on their objective goodness at the task.
22:30:14 <SrPx> pyon: makes total sense for me
22:30:16 <pyon> NemesisD: No, objectively speaking, C and C++ are really bad. It is just that we have few better things.
22:30:19 <SrPx> hmm
22:30:29 <pyon> (For that particular domain.)
22:30:34 <NemesisD> kadoban: from my outsider perspective, C/C++ main problems is that it is extrmely volatile and easy to blow your foot off
22:31:15 <kadoban> I tend to think that C is actually pretty good, if you use it for that kind of thing.  C++...maybe I've just used it too much, I agree with your apraisal there for sure.
22:31:24 <paulschellin> If C++ required an explicit "mutable" keyword instead of an explicit "const" keyword it would be a lot better, I think.
22:31:34 <pyon> paulschellin: Rust!
22:32:05 <kadoban> C does make it pretty easy to blow your foot off too, but you /can/ use it well if you try hard.  I would agree that I think it could be done better, but I'm just not sure how myself.
22:32:15 <paulschellin> pyon: I had read somewhere that a course on systems programming was actually taught in rust, I can't remember where I read that though.
22:32:37 <NemesisD> these days i have little interest in trying super hard to not harm myself with a language if there's a better alternative
22:32:49 <NemesisD> i've learned that as careful as I think I am, I am not
22:33:13 <SrPx> ok an unrelated question, considering we forget any kind of sequential operations, how do you think a parallel graph reducer would work on the GPU? I was thinking in implementing a toy one to benchmark, considering we have none afaik (why!??)
22:33:20 <paulschellin> My issue with systems code written in C is that most of the time people are writing boilerplate code which is effectively a poor man's RAII
22:33:31 <Twey> paulschellin: I find that unlikely, since Rust isn't even finalized yet :þ
22:33:57 <NemesisD> pyon: so is there a way to basically make this SerializeOnly subset of serialize without all the pragma witchcraft
22:34:00 <paulschellin> Twey: http://rust-class.org/pages/using-rust-for-an-undergraduate-os-course.html
22:35:14 <Twey> SrPx: You might find http://www0.cs.ucl.ac.uk/staff/C.Clack/research/ICLTechJournal.pdf‎ interesting
22:35:46 <Twey> paulschellin: Wow, that's… brave
22:35:54 <ecr> Twey: we're getting there
22:36:19 <paulschellin> Twey: I thought the same thing, but I've never played around with rust so I can't speak to it's (in)stability.
22:36:36 <SrPx> Twey: cool I've read that (: interesting that I've never found something similar on the GPU, for some reason
22:36:59 <NemesisD> havent you guys heard. go is gonna be the new systems language :/
22:37:21 <zjxv> paulschellin, http://www.cs.virginia.edu/~evans/cs4414-fall2013/author/david-evans.html
22:37:34 <Welkin> "the"?
22:37:39 <kadoban> every time i think of go, i wonder what marketing genius let them use that name.  it's impossible to search for :/
22:37:46 <Twey> paulschellin: My understanding is that core parts of the language have changed in the past few months :þ
22:37:47 <Welkin> golang
22:37:55 <Welkin> it is doubtful it will really catch on
22:38:00 <kadoban> it's bad enough with the game of that name, but you'd think a programming language would be more internet savy
22:38:00 <Welkin> we'll see
22:38:14 <Twey> kadoban: Speak for yourself.  It's my #2 Google result!
22:38:16 <NemesisD> people in the communities i'm in seem to be infatuated with go lately
22:38:47 <ecr> paulschellin, Twey: well, the rate of dramatic language changes has slowed down at least
22:38:51 <kadoban> Twey: haha, yeah...you can get to the like main pages, but finding things that reference it or are about go, is pretty freaking hard
22:39:18 <MP2E> NemesisD: this is all that needs to be said :P https://code.google.com/p/plan9front/wiki/golang
22:39:21 <Twey> kadoban: I think most people indeed just refer to it as ‘golang’ for grammatical/keyword unambiguity
22:39:52 <kadoban> Twey: seems possible, and a decent solution, but it just seems like somewhere along the way, someone should have just picked a better name
22:40:12 <MP2E> Go and Rust are pretty bad names
22:40:14 <MP2E> hehe
22:40:26 <Twey> Rust's fine, I think
22:40:27 <MP2E> most languages have pretty weird names, to be fair though
22:40:31 <Twey> Go is a bit short
22:40:38 <Twey> But yeah, you can't really get worse than ‘C++’
22:40:41 <paulschellin> "C" is a bit short
22:40:48 <Twey> Oh wait, ‘C#’
22:41:01 <MP2E> heh C#
22:42:01 <Welkin> brainfuck?
22:42:20 <NemesisD> one letter pl names are pretty bad too
22:42:32 <MP2E> D
22:42:38 <kadoban> brainfuck is actually a really good language name. it describes it well, and is pretty easy to search for :)
22:42:52 <Welkin> it isn't a brainfuck though
22:42:59 <Welkin> it's just an 8 opcode asm
22:43:45 <Twey> Malbolge, now…
22:49:53 <pyon> Why can't a newtype constructor have an existential context? :-O
22:50:34 <pyon> "newtype Parser s e a where { P :: Append s => (s -> Result s e a) -> Parser s e a }"
22:54:54 <Twey> pyon: Because the representation of a newtype is defined by the representation of the thing it wraps
22:55:13 <Twey> newtypes don't add a box
22:55:21 <MP2E> heh another mind blown moment, types are essentially functions
22:55:26 <MP2E> what *aren't* functions
22:55:37 <MP2E> I'm guessing everything is a function almost :P
22:55:39 <pyon> MP2E: ???
22:55:42 <Twey> pyon: So if you have an existential type in there, the compiler doesn't know how to represent your type
22:55:48 <pyon> Twey: Oh.
22:55:51 <mniip> How is 'Int' a function
22:56:03 <MP2E> user defined types, should have been more explicit
22:56:04 <MP2E> but yeah
22:56:21 <mniip> MP2E, Just and Nothing aren't types
22:56:21 <Twey> MP2E: data Foo = Bar -- where's the function?  ☺
22:56:29 <mniip> Theyre data constructors
22:57:16 <pyon> MP2E: You mean type constructors, like Maybe in "data Maybe a = Just a | Nothing"?
22:57:31 <MP2E> so lyah is wrong then? :P " Now when I say fields, I actually mean parameters. Value constructors are actually functions that ultimately return a value of a data type. Let's take a look at the type signatures for these two value constructors."
22:57:47 <MP2E> I don't understand, that seems fairly unambiguous to me
22:58:11 <Twey> MP2E: It's a little wrong, yeah
22:58:12 <mniip> Value constructors, not types
22:58:17 <MP2E> Ah okay
22:58:20 <MP2E> That makes sense.
22:58:25 <Twey> MP2E: Value constructors *that take arguments* are a special kind of function
22:58:46 <pyon> Is there any way to make a synonym for two or more type class constraints?
22:58:51 <Twey> MP2E: But you can also have nullary value constructors, like Nothing, that can't be considered a function by most useful definitions
22:59:08 <Twey> pyon: ConstraintKinds
22:59:36 <pyon> Oh.
22:59:58 <Twey> pyon: ConstraintKinds adds a new kind ‘Constraint’ of the things that can be used in constraints, and then you can make arbitrary type functions that return constraints
23:00:07 <Twey> pyon: E.G. type Foo a = (Read a, Show a)
23:00:15 <Twey> foo ∷ Foo a ⇒ …
23:00:24 <pyon> Twey: Whoa, sweet!
23:00:39 <Twey> ConstraintKinds is pretty great
23:00:52 <pyon> Sounds *exactly* like what I need.
23:01:01 <pyon> To reduce constraint boilerplate.
23:01:06 <Twey> Though the lack of partially-applied type functions is annoying sometimes
23:02:39 <Twey> pyon: If you look at vinyl, it makes use of ConstraintKinds pretty heavily to do stuff like ("foo" ::: Int ∈ f) ⇒ f → Int
23:02:59 <Twey> Giving you row typing, after a fashion
23:03:54 <pyon> Twey: "Int ∈ f" meaning...?
23:05:40 <scshunt> http://www.cs.utexas.edu/~wcook/Drafts/2009/essay.pdf
23:06:02 <Twey> pyon: Parse it ("foo" ::: Int) ∈ f
23:06:15 <Twey> pyon: ‘The record type f has a field "foo" holding a value of type Int’
23:06:32 <pyon> Twey: Whoa.
23:07:02 <pyon> Twey: Sounds much like what I would see in Ur/Web.
23:07:15 <Twey> Right
23:08:32 <Twey> It gets a little bit clunkier in Haskell sometimes, but we also get some cool stuff out of it (like Vinyl's default field types are parameterized over a monad, so you can make ‘validator’ types just by changing the functor, and validate things applicatively)
23:09:23 <pyon> :-O
23:10:32 <Twey> Er, s/over a monad/over a functor/ sorry
23:14:29 <pavonia> I'm building a gtk layout out of a layout specification ADT. When the layout is process, there may occur warnings in some situations that should be printed on stdout. However, I don't know how to refer to the problematic widgets in the warning, as they can be arbitrary widgets.
23:16:05 <Twey> pavonia: How about some sort of ‘path’ to the widget's location in the ADT?
23:16:37 <pavonia> Hhm, that would be possible
23:17:02 <Twey> pavonia: Or build names into your ADT
23:17:58 <pavonia> I also thought about using the gtk name field, but that would possibly mess up programs that rely on these
23:18:45 <Twey> I wouldn't stick arbitrary rubbish in there, but letting your user specify the GTK name through your ADT doesn't sound bad
23:21:17 <pavonia> Twey: Actually, I prefer the path idea because changing the ADT only for having debugging information doesn't feel right
23:21:26 <Twey> 'kay
23:21:49 <Twey> Well, I would imagine you wouldn't change it *just* for debugging information
23:22:10 <Twey> You can use the recursive-functor trick to let your user annotate the widgets with whatever data they like
23:22:33 <Twey> http://stackoverflow.com/questions/21394879/how-would-you-abstract-away-the-boilerplate-in-this-pair-of-similar-shaped-dat/21397322#21397322 — this one
23:22:48 <pavonia> There's no use for the names otherwise
23:23:05 <pavonia> Oh, GADTs again :)
23:23:15 <Twey> It *could* be debugging information, but perhaps the user would want to attach some kind of other information to the widgets?
23:23:37 <Twey> I don't know, maybe that makes sense in your case, in which case you can solve both problems neatly.
23:27:59 * hackagebot ghcjs-dom 0.0.6 - DOM library that supports both GHCJS and WebKitGTK  http://hackage.haskell.org/package/ghcjs-dom-0.0.6 (HamishMackenzie)
23:28:00 <pavonia> Twey: What is Type in that link?
23:30:24 <Twey> pavonia: It's just a code for a type in the embedded language; it's defined at the bottom of the question's code
23:31:14 <pavonia> But it's used as a kind too
23:31:45 <Twey> DataKinds
23:31:53 <amalloy> i was really surprised to see that `@pl \x -> f (g x) (h x)` yields `liftM2 f g h`. it seems like it's somehow related to the monad instance for ((->) a), but i can't quite put together the pieces to see what it "means". can anyone explain to me why these two are the same thing?
23:32:43 <Twey> :t liftM2
23:32:47 <lambdabot> Monad m => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
23:33:07 <Twey> That's horrible
23:33:35 <Twey> amalloy: liftM2 ∷ Monad m ⇒ (a → b → r) → m a → m b → m r
23:34:11 <Twey> amalloy: So for m = (r →), we get: liftM2 ∷ Monad m ⇒ (a → b → r) → (r → a) → (r → b) → (r → r)
23:34:16 <Twey> Oops
23:34:22 <pavonia> Kinds other than * are confusing me :S
23:34:28 <Twey> amalloy: So for m = (e →), we get: liftM2 ∷ Monad m ⇒ (a → b → r) → (e → a) → (e → b) → (e → r)
23:34:34 <Twey> Pardon me
23:35:05 <Twey> amalloy: Can you write a function with that type?  \ f ea eb → …
23:35:35 <Twey> amalloy: Or rather, \ f g h x → …
23:36:56 <amalloy> yeah, i see that there's only one such function
23:37:02 <Twey> pavonia: They're just the same as types on the value level
23:37:30 <Twey> amalloy: Intuitively, the (e →) monad is one that ‘feeds’ each action with an ‘environment’
23:37:34 <amalloy> it's still not...*obvious*, but i think it makes sense now that you've written out the types and substituted in actual type variables
23:37:49 <amalloy> yeah, i mean it's equivalent to Reader
23:37:51 <amalloy> that's a good point
23:37:52 <Twey> Right
23:38:16 <Twey> amalloy: So g and h are monadic actions (so, functions) that are fed an environment — in your case, x
23:38:33 <Twey> And then the results are combined with f, because that's what liftM2 is for
23:39:25 <Twey> You don't actually have to go all the way to Monad for this — the Applicative instance for functions (liftA2) has the same behaviour
23:39:39 <Twey> So we can also write it f <$> g <*> h, which I prefer
23:39:39 <jle`> can i call haskell users haskelleurs
23:39:53 <Twey> jle`: Only if you can do it with a straight face
23:40:07 <jle`> i'll give it my best effort
23:40:19 <amalloy> right, i'm not surprised to hear that applicative is enough here
23:40:20 <dagle> heskelleurs sound like people that would name variables herp and derp.
23:41:10 <jle`> i was half-serious about to write the sentence "the skilled haskelleur will immediately recognize..."
23:41:17 <Twey> amalloy: The Applicative is nice because you can think of it as normal function application that's ‘delayed’ until you get a value to feed to g and h
23:41:19 <jle`> s/skilled/experienced
23:41:32 <Twey> jle`: Carry on :þ
23:41:48 <pavonia> Twey: "data Term :: Type -> * where" means Term is a type constructor where the result type is arbitrary but the paramter type can only be of kind Type, so one of the defined constructors. Is that correct?
23:41:57 <Twey> pavonia: Right
23:42:06 <amalloy> Twey: you can think of the monad version that way too though, right? is that wrong in some way?
23:42:20 <jle`> it was used in #haskell in 2009
23:42:32 <Twey> amalloy: No, it's not wrong.  The Applicative syntax (with <$> and <*>, not the liftA2 version) just looks more like function application.
23:42:35 <jle`> by Warrigal
23:42:37 <amalloy> i see
23:42:50 <dagle> Back then, haskell was madness and haskelluers would have made sense.
23:43:00 * hackagebot jsaddle 0.1.1.4 - High level interface for webkit-javascriptcore  http://hackage.haskell.org/package/jsaddle-0.1.1.4 (HamishMackenzie)
23:43:02 * hackagebot tempodb 0.2.2.5 - A small Haskell wrapper around the TempoDB api.  http://hackage.haskell.org/package/tempodb-0.2.2.5 (ParnellSpringmeyer)
23:43:13 <pavonia> Twey: So I wouldn't be able to use a value of type, say "Type Int"?
23:45:22 <Twey> pavonia: That's not a kind-correct type in the first place
23:45:25 <pyon> "<dagle> heskelleurs sound like people that would name variables herp and derp." --> I do just that. But mostly in C++ snippets meant to illustrate a concept, in ##c++ .
23:45:57 <Twey> pavonia: Type doesn't take an argument
23:46:19 <pavonia> Err, I meant Term, sorry
23:46:25 <Twey> Ah
23:46:29 <Twey> Then yes, that's correct
23:46:41 <pavonia> Okay
23:49:42 <ion> “Putting Cloud Haskell to Work” by Gershom Bazerman was a nice talk.
23:52:42 <Welkin> wasn't that project abandoned?
23:54:59 <Twey> Not at all
23:55:25 <Twey> http://haskell-distributed.github.io/ — going strong
23:56:59 * ion notices #haskell-distributed exists
23:57:39 <Welkin> no updates for a year
23:58:16 <ion> welkin: https://github.com/haskell-distributed
