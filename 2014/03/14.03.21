00:00:13 <dmj`> anyone? ghc-pkg check gives me this: http://lpaste.net/101539
00:00:25 <dmj`> even after running this command: sudo cabal install --reinstall --force-reinstalls --enable-documentation
00:01:49 <Welkin> haskell.org is incredibly slow still... and the request never finishes, it just freezes
00:01:58 <Welkin> supposedly this is a known issue?
00:02:11 <Welkin> http://haskell.1045720.n5.nabble.com/www-haskell-org-is-currently-very-slow-in-responding-to-HTTP-requests-td3116250.html
00:09:19 * hackagebot foldl 1.0.3 - Composable, streaming, and efficient left folds  http://hackage.haskell.org/package/foldl-1.0.3 (GabrielGonzalez)
00:09:19 * hackagebot errors 1.4.6 - Simplified error-handling  http://hackage.haskell.org/package/errors-1.4.6 (GabrielGonzalez)
00:19:14 * hackagebot chunked-data 0.1.0.1 - Typeclasses for dealing with various chunked data representations  http://hackage.haskell.org/package/chunked-data-0.1.0.1 (MichaelSnoyman)
00:29:26 <jle`> I wonder where hackagebot disappeared off to all day
00:30:26 <jle`> also tekmo and snoyman appear to be hackage twins. I wonder if they coordinate their releases
00:31:18 <luite>  :)
00:34:15 * hackagebot imagesize-conduit 1.0.0.2 - Determine the size of some common image formats. (deprecated)  http://hackage.haskell.org/package/imagesize-conduit-1.0.0.2 (MichaelSnoyman)
00:39:12 <ThatOtherPerson> Does GHC have an option to expand the layout in a source file?
00:44:16 * hackagebot safe-failure 0.5.0.2 - Library for safe functions (deprecated)  http://hackage.haskell.org/package/safe-failure-0.5.0.2 (MichaelSnoyman)
00:54:17 * hackagebot persistent 1.3.0.4 - Type-safe, multi-backend data serialization.  http://hackage.haskell.org/package/persistent-1.3.0.4 (MichaelSnoyman)
00:54:19 * hackagebot yesod-persistent 1.2.2.2 - Some helpers for using Persistent from Yesod.  http://hackage.haskell.org/package/yesod-persistent-1.2.2.2 (MichaelSnoyman)
01:04:11 <tuk> ciao
01:04:14 <tuk> !list
01:04:14 <monochrom> tuk: http://hackage.haskell.org/packages/archive/pkg-list.html
01:11:09 <foobar_> I just read in a book(about general functional programming) that when an expression is evaluated, its result is memoized. does this happen in haskell too. if, say I evaluate some f(x) then whenever I use f(x), it'll serve memoized value?
01:11:28 <shachaf> No.
01:11:53 <shachaf> Figuring out when to do this and when not to do it is complicated.
01:12:09 <shachaf> Memoization is a time/space trade-off, not a thing you always want.
01:12:22 <foobar_> so its up to ghc to decide
01:12:35 <shachaf> It'll almost never happen. Certainly not in a global way.
01:12:45 <shachaf> However, it's true (in GHC) that if you say let y = f x in ...y...y..., f x will be evaluated only once.
01:13:54 <foobar_> this is coz we bind the result to a name right
01:17:19 <eatman> Morning!
01:25:03 <jle`> idk why when i started out in haskell, i assumed implicit memoization
01:25:08 <jle`> what was i even thinking
01:25:11 <jle`> eatman: good morning :)
01:25:47 <bartavelle> jle`, so did I, not sure how I got that into my head
01:26:17 <jle`> curious
01:31:44 <Twey> foobar_: In GHC you get memoization only for nullary values, not for functions.  So a common pattern is to encode a function you want to memoize as a list of results or some other data structure.
01:41:55 <foobar_> Twey, you mean like res =[f x, g x]
01:43:18 <jle`> foobar_: more like fs = map f [0..]; f' n = fs !! n
01:43:30 <jle`> but not really
01:44:26 <haasn> (perhaps something slightly more efficient than a list!)
01:44:35 <jle`> > let fs = map (+3) [0..]; f n = fs !! n in (f 1, f 5, f 1)
01:44:37 <lambdabot>  (4,8,4)
01:44:44 <jle`> 1 + 3 is only evaluated once
01:45:06 <haasn> jle`: I don't think that's correct, actually
01:45:13 <jle`> really?
01:45:15 <jle`> :(
01:45:29 <haasn> (well, apart from the obvious fact that it's implementation specific)
01:45:46 <haasn> > let fs = map (+3) [0..]; f n = fs !! n in (f 1 :: Int, f 1 :: Double)
01:45:48 <lambdabot>  (4,4.0)
01:45:53 <haasn> ‘fs’ and ‘f’ are polymorphic here
01:45:55 <jle`> ah yeah.
01:46:16 <jle`> > let fs = map (+3) ([0..] :: [Int]); f n = fs !! n in (f 1, f 5, f 1)
01:46:17 <lambdabot>  (4,8,4)
01:48:16 <jle`> in ghci it claims it only evaluates once, but i guess it is implementation dependent too
01:49:01 <haasn> that also goes for shachaf, ‘y’ can be polymorphic
01:49:14 <haasn> that can be a gotcha, especially when turning of the MonomorphismRestriction
01:50:37 <jle`> .^d jle` haasn's post
01:50:51 <jle`> er, jle` likes haasn's post
01:52:58 <haasn> then again, I'm not actually sure how smart GHC is about eliminating that these days
01:53:13 <haasn> can GHC detect and optimize multiple usages of the same polymorphic expression instantiated at the same type?
01:53:20 <haasn> even if that type is a rigid variable?
01:54:10 <jle`> i have always heard that ghc doesn't memoize even things like x = 4 with the dmr off
01:54:24 <jle`> but it could just be unverified things being passed around
01:57:16 <luite> jle`: can depend on other things, GADTs and TypeFamilies imply MonoLocalBinds
02:04:23 * hackagebot lio-simple 0.0.1.0 - LIO support for the Simple web framework  http://hackage.haskell.org/package/lio-simple-0.0.1.0 (DeianStefan)
02:04:51 <Javran> @pl \a1 b1 b2 a2 c d -> (a1 . b1) ((b2 . a2) c d)
02:04:51 <lambdabot> flip flip (.) . (((.) . (.) . (.) . (.)) .) . (.)
02:05:40 <Javran> @pl \a1 a2 c d -> (a1) ((a2) c d)
02:05:40 <lambdabot> (.) . (.)
02:06:46 <bartavelle> can someone explain to me what the notation "curry: C(A x P, B) =~ C(A, P -> B) :uncurry" mean in https://www.youtube.com/watch?v=9EGYSb9vov8 at 8:08 ?
02:07:00 <bartavelle> (just the notation, I don't think I will understand what it actually mean yet)
02:08:40 <`JRG> morn
02:08:53 <bartavelle> oh (A x P) probably mean a tuple of type (A, P)
02:09:03 <spacekitteh> foobar_: i just started using the MemoTrie package
02:09:10 <jle`> `JRG: mornin
02:09:13 <spacekitteh> foobar_: it's pretty simple to use
02:09:23 * hackagebot clifford 0.1.0.6 - A Clifford algebra library  http://hackage.haskell.org/package/clifford-0.1.0.6 (spacekitteh)
02:09:38 <spacekitteh> ^ in that
02:09:46 <Javran> @pl (a1 . b1) ((b2 . a2) c d)
02:09:46 <lambdabot> a1 (b1 (b2 (a2 c) d))
02:10:18 <Javran> @pl (a1 . b1 . c1 . d1) ((d2 . c2 . b2 . a2) c d)
02:10:19 <lambdabot> a1 (b1 (c1 (d1 (d2 (c2 (b2 (a2 c))) d))))
02:11:44 <Javran> @pl (fst . ($ 20) . snd . ($ 10)) (result . second . result . first) (*2) d2
02:11:44 <lambdabot> fst (snd (result (second (result (first 10)))) 20) (2 *) d2
02:12:43 <Javran> @pl (fst . ($ 20) . snd . ($ 10)) ((result . second . result . first) (*2) d2)
02:12:43 <lambdabot> fst (snd (result (second (result (first (2 *)))) d2 10) 20)
02:16:51 <Javran> @pl (fst . (h 20) . snd . (h 10)) ((result . second . result . first) (*2) d2)
02:16:51 <lambdabot> fst (h 20 (snd (h 10 (result (second (result (first (2 *)))) d2))))
02:18:57 <Javran> @pl a (b c d)
02:18:58 <lambdabot> a (b c d)
02:19:49 <`JRG> guys, what is the best way to do some haskell for one like me so used to common-lips+emacs+slime?
02:20:31 <merijn> `JRG: I know there some slime like extensions, but tbh personally I just have two terminals open (or split screened in tmux), one with a haskell file and one with ghci
02:20:50 <merijn> `JRG: Then I just ":r" my file when I wanna try something
02:21:19 <`JRG> merijn: thanks.  Haskell-mode anyone?
02:22:24 <spacekitteh> yeah, haskellmode is good.
02:24:53 <merijn> ghc-mod/hdevtools might be worth checking out too, they allow things like query the type of an expression in vim/emacs
02:25:17 <spacekitteh> oh cool merijn
02:26:07 <merijn> (at least, I'm blindly assuming someone wrote emacs extensions for them too :p)
02:26:20 <spacekitteh> yeah there is
02:40:53 <spacekitteh> weird. my trie performs better if it is a trie of (True,[Bool]) rather than [Bool]
02:43:01 <spacekitteh> must be cache alignment or something
02:43:13 <ghorn> I think I need -XRankNKinds  http://lpaste.net/101543
02:45:11 <ghorn> is there something like that?
02:46:11 <merijn> ghorn: Have you tried just adding explicit forall? (Note: I have no clue whether that works or is even supposed to work)
02:47:25 <ghorn> WOAH
02:49:01 <ghorn> that's crazy, but I don't think that solves my problem
02:50:22 <ghorn> I'm trying to do a sort of type-safe view into a vector-like structure
02:50:29 <merijn> ghorn: FYI, your use of Inner in outer looks like Fix?
02:50:43 <merijn> Or Free?
02:51:14 <jle`> with withMVar block other threads from accessing the MVar until the block has finished?
02:51:43 <merijn> jle`: Yes, IFF all threads use a "read, modify, write" access pattern
02:52:05 <jle`> merijn: ty
02:52:15 <skypers> hi
02:52:23 <skypers> monochrom: ah
02:52:31 <skypers> gonna try without the Show constraint
02:52:53 <jle`> sometimes \_ -> is more readable than const
02:53:00 <jle`> confirm or deny
02:53:38 <merijn> jle`: Yes
02:54:27 * hackagebot hjsmin 0.1.4.6 - Haskell implementation of a javascript minifier  http://hackage.haskell.org/package/hjsmin-0.1.4.6 (AlanZimmerman)
02:55:27 <skypers> monochrom: it works! thank you!
02:58:54 <jle`> um what is going on, ghc seems to think _variablename is a hole :/
02:59:29 <jle`> oh wait, it's because i never defined _variablename
03:01:22 <haasn> I'm still a bit confused about what “dynamic programming” actually refers to. As far as I can tell, it's just a buzz word for a recursive algorithm + memoization; does that sound right?
03:02:16 <ghorn> haasn: it means something specific in AI, where it's a recursive acronym
03:02:37 <ghorn> not acronyn, algorithm :)
03:02:44 <ghorn> in programming people use it to describe things which aren't recursive though
03:02:58 <haasn> such as?
03:02:59 <ghorn> or at least, recursive but converge after one iteration
03:03:42 <merijn> haasn: Yes and no
03:04:11 <allspark> How do you use -XFlexibleInstances in ghci? The pragma  {-# LANGUAGE FlexibleInstances #-} doesn't work. The code, http://pastebin.com/8z3nBmCM
03:04:16 <merijn> haasn: There's two ways to implement dynamic programming, recursive + memoization, which is obvious but tricky to do efficiently
03:04:22 <haasn> allspark: :seti -XFlexibleInstances
03:04:44 <merijn> haasn: The other is the imperative/in-place version, which is a bit more convoluted
03:05:02 <merijn> haasn: It's more of a "design pattern" then an algorithm, though
03:05:45 <merijn> haasn: I remember thinking "why would you ever implement it the imperative way", but CLRS had some points where the imperative one seemed more desirable, but I forgot the details
03:05:59 <haasn> merijn: in-place more like working your way upwards from f(0) basically and saving/memoizing the results until you get to f(n)?
03:06:20 <haasn> or am I completely misunderstanding what the “imperative/in-place” way to implement DP would look like
03:06:25 <ghorn> some people call this dynamic programming http://en.wikipedia.org/wiki/Levenshtein_distance
03:06:43 <ghorn> i mean, call it an example of dynamic programming
03:07:16 <ghorn> or the solution to this problem https://projecteuler.net/problem=18
03:08:52 <companion_cube> haasn: dynamic programming is a bit the dual of recursion+memoization, since you go bottom-up rather than top-down
03:09:35 <merijn> companion_cube: CLRS disagrees and calls both dynamic programming
03:09:49 <allspark> haasn: works without the 'i', thanks
03:10:25 <merijn> haasn: I just looked it up, the two approaches are identical, but they note that bottum-up dynamic programming is usually faster (by a constant factor) than top-down memoised dynamic programming
03:10:41 <b0bbi10> hi, this very basic contruct confuses me: "x == y = not (x /= y)" -> x is compared to y that in turn is the result of not (x /= y)?
03:10:41 <haasn> merijn: thanks, that clears things up a bit
03:10:48 <companion_cube> merijn: hmm, indeed.
03:11:07 <companion_cube> although I'm not sure all recursive memoization can be called "dynamic programming"
03:11:26 <merijn> b0bbi10: It's using the definition of /= (inequality) to define the equality function
03:11:38 <merijn> companion_cube: It can't
03:11:55 <b0bbi10> merijn: yeah, but why is x (whatever type x is) compared to a Bool?
03:11:59 <merijn> companion_cube: Only a subset of memoised recursion
03:12:05 <b0bbi10> (the result of not (x /= y))
03:12:09 <merijn> b0bbi10: It's not
03:12:11 <companion_cube> the subset for which a bottom-up algorithm also exists?
03:12:15 <merijn> b0bbi10: Where do you see that?
03:12:29 <b0bbi10>  merijn: "x =="
03:12:33 <merijn> b0bbi10: CLRS has a bunch of requirements for dynamic programming (I just closed it, so I forgot)
03:12:36 <haasn> merijn: I guess this would be an example of dynamic programming in Haskell? let fibs = scanl (+) 0 (1:fibs) in fibs !! n -- ?
03:13:00 <merijn> b0bbi10: You're parsing it wrong, it says "x == y" is defined as "not (x /= y)"
03:13:50 <b0bbi10> merijn: ah yeah, right, '=' has the lowest binding, I forgot
03:13:51 <b0bbi10> thanks
03:14:19 <merijn> companion_cube: They refer to dynamic programming as any recursively splittable problem, where each split shares a majority of it's subwork with other splits
03:14:29 <companion_cube> I see. Nice definition.
03:14:40 <companion_cube> so, Levenshtein distance is indeed dynamic programming.
03:14:59 <merijn> Yeah, Levenshtein is one of the classic examples of dynamic programming
03:14:59 <haasn> allspark: do note the difference between :set and :seti
03:15:09 <companion_cube> wonder whether some unification algorithms can be considered as dynamic programming
03:15:17 <companion_cube> the linear or quasi linear ones use sharing
03:15:29 <merijn> Well, I got taught DNA comparison for dynamic programming, but that's essentially just Levenshtein or extended Levenshtein :)
03:15:30 <ghorn> i think that definition of dynamic programming might be different than the AI one
03:15:42 <ghorn> i think of "value iteration" when i think DP
03:16:18 <merijn> ghorn: Not amongst AI people I know, but that might differ by location?
03:16:35 <allspark> haasn: what does 'interactive evaluation' mean? Isn't ghci interactive?
03:16:48 <ghorn> i am not an expert :)
03:16:59 <haasn> allspark: :seti means it's set *only* for statements you type inside GHCi; :set also applies to external files you load using :l
03:17:58 <haasn> allspark: so if you have a file containing a flexible instance (but without the {-# LANGUAGE #-} annotation), and you used :seti -XFlexibleInstances followed by :l File.hs, that file will fail to load (unless you add the annotation in the file itself)
03:18:12 <merijn> Man, obfuscated Haskell must be a nightmare. I keep finding new forms of "correct" syntax which are just horrendous
03:18:15 <haasn> allspark: if you, however, had :set -XFlexibleInstances enabled, that file will load just fine, as if you had written the annotation at the top
03:18:41 <kuribas> merijn: like?
03:18:45 <skypers> hm, I still have an issue to make my GADT an instance of Eq
03:18:49 <haasn> merijn: my favorite is still {-# LANGUAGE RebindableSyntax #-} do (>>=) <- foo; ...
03:19:17 <ghorn> merijn: here's an example of what I'm trying to do with these kinds
03:19:20 <skypers> it works for non-polymorphic type, like instance Eq (E Int) where, instance Eq (E Float)… but not for instance Eq (E (a,a)) where
03:19:22 <allspark> haasn: no wonder it didn't work at first. good to know
03:19:27 <skypers> this is pretty annoying
03:19:45 <ghorn> merijn: i want to do something like, split :: (View m, Viewable f) => m f -> f m
03:20:29 <ghorn> merijn: so I don't think i can throw away that type parameter with forall
03:20:37 <skypers> oh, nvm, I think I got it
03:23:43 <kuribas> does anyone know the metafont language?
03:25:05 <lieven_> I've read the metafont book once but that was decades ago
03:25:33 <merijn> kuribas: Well, witness this beauty: http://lpaste.net/101545
03:25:36 <lieven_> modern TeX uses metapost if I'm not mistaken
03:25:38 <kuribas> Metafont and TeX are probably one of the most unsafe languages.
03:26:08 <kuribas> lieven_: they are independend, but you can use metapost from TeX.
03:26:27 <merijn> That's correctly parsing haskell >.>
03:26:44 <lieven_> Guy Steele managed to convince Knuth that TeX needed a programmable substrate. unfortunately Knuth at the time was doing research in term rewrite grammars. otherwise we might have had a lispy substrate.
03:27:09 <kuribas> merijn: Ah, layout rule :)  I am not a big fan of indentation sensitive syntax.
03:27:27 <merijn> I am
03:27:34 <merijn> The problem is that haskell's isn't strict enough
03:27:58 <ghorn> haha
03:28:50 <jle`> wasn't that recent apple id security bug because of semanticless indentation?
03:28:52 <merijn> Anyone who thinks compilers shouldn't enforce layout has never graded undergraduate code
03:28:57 <merijn> jle`: Yes
03:29:03 <kuribas> lieven_: metafont looks structured, but it is actually a string of tokens which can be redifined completely.
03:29:14 <kuribas> lieven_: And so breaking every macro in the system.
03:29:47 <jle`> i wonder if haskell was intentionally designed to be compatible with cpp
03:30:10 <jle`> variable names can't start with #, for example
03:30:15 <jle`> but that part is probably incidental
03:32:08 <merijn> variable names can't start with symbols anyway :p
03:32:19 <lieven_> kuribas: I know. there's a reason not many of these macro systems are still around. m4 used to get some use for system admin stuff but it's dying too.
03:32:49 <jle`> actually, what kind of design decisions would have made haskell source non-cpp-compatible?
03:33:00 <jle`> cpp is designed pretty well to stay out of the way of real code
03:33:24 <merijn> Why is there a (<$) but not ($>)?
03:33:42 <no-n> because god does not exist
03:34:04 <NikolajK> side effects: can't you just remove side effects from any language by designing every functions so that it cleans the value of all term it has assigned a value during the computation?
03:34:05 <kuribas> lieven_: It's a very intricate and neat hack, but I feel it is unnecessary.
03:34:40 <lieven_> kuribas: as so lot of computing history side effects, it seemed like a good idea at the time
03:34:47 <skypers> hey folks
03:34:49 <companion_cube> NikolajK: how do you "clean the value" of an IO output?
03:34:50 <skypers> a + b == c + d
03:35:03 <skypers> how could I know whether that is true without evaluating a + b nor c + d?
03:35:06 <jle`> NikolajK: or a database write, for example
03:35:15 <skypers> a == c | a == d && …
03:35:17 <skypers> something like that?
03:35:28 <jle`> merijn: what would ($>) do?
03:35:33 <kuribas> lieven_: I am "redesigning" the metafont language, with similar syntax, but type safety and structured code.
03:35:56 <merijn> jle`: flip (<$)?
03:36:10 <lieven_> kuribas: that's an interesting project. Have you encountered any major problems so far?
03:36:26 <kuribas> lieven_: What I'd like is that a function or font program either succeeds on all possible inputs.
03:36:45 <kuribas> lieven_: No, but I haven't implemented user definable functions.
03:36:59 <kuribas> lieven_: They are currently hard coded into haskell.
03:37:04 <jle`> (<$) is like (<$>) but ignores the right side
03:37:09 <supki> merijn: it's in 7.8 I think
03:37:10 <NikolajK> companion_cube: I don't understand enough about how communication with the output hardware works to see how IO relies or does not rely on fixing terms
03:37:15 <jle`> it would make sense i think for ($>) to be like (<$>) but ignoring the left side
03:37:22 <supki> meanwhile you can use $> from comonad :)
03:37:23 <jle`> but that's just const
03:37:25 <merijn> jle`: "ignore the right hand side" is wrong
03:37:37 <lieven_> kuribas: I think such totality would be hard. there will always be inputs that would make curves not cross themselves in the right number of places or do other undesirable things. sort of like trying to type encode that you're not going to divide by 0
03:37:43 <jle`> hm, what is it supposed to mean?
03:37:50 <NikolajK> if Haskell computes 3+5 I see that it returns the value - I guess that must mean it stores that information
03:37:53 <NikolajK> 8
03:38:22 <merijn> jle`: "a <$ f" -> "const a <$> f"
03:38:22 <NikolajK> it's just not represented by some term which I can call again inside the language
03:38:32 <merijn> jle`: i.e. run a side-effect but replace the rsult with a fixed value
03:38:48 <merijn> jle`: flipping it just changes whether you write side-effect first or value first
03:38:54 <kuribas> lieven_: yes, so it should give a valid, if maybe strange result for crossing curves or division by zero.  But just not fail with an error message.
03:39:30 <merijn> jle`: If it ignored the right hand it'd just be 'const'
03:39:43 <jle`> merijn: if a <$ f = const a <$> f, i would expect a $> f to be a $> const f, but that doesn't relaly make sense
03:39:53 <jle`> merijn: yeah, i didn't mean ignore the value, i meant ignore the sideeffecty result
03:40:04 <kuribas> lieven_: metafont is a bit like a logic language, since it narrows the value of variables down.
03:40:17 <merijn> jle`: That's not flip ($>), though
03:41:12 <jle`> merijn: yeah, i'm saying that the nonsensical a $> const f makes more sense as a $> to me than flip (<$)
03:41:31 <jle`> flip (<$) would be more like... &> from lens
03:41:45 <merijn> Why does that make more sense?
03:42:04 <jle`> because f &> a would be f <&> const a
03:42:20 <jle`> :t (<&>)
03:42:22 <lambdabot> Functor f => f a -> (a -> b) -> f b
03:42:41 <jle`> :t (<$>)
03:42:42 <lambdabot> Functor f => (a -> b) -> f a -> f b
03:42:44 <merijn> I mean why does "a $> f" as "a <$> const f" make more sense
03:42:46 <jle`> (just checking for my own sanity)
03:42:53 <merijn> const f wouldn't even sanely typecheck
03:43:07 <jle`> merijn: because it flips which side the const is on. and yeah, i said that it is nonsensical/absurd
03:43:19 <kuribas> lieven_: So solving the equations for a metafont program may give either no result, fully defined variables, or some variables undefined.
03:43:23 <merijn> But why would/should it flip the side const is on?
03:43:37 <Welkin> it is absurd, like the man of faith?
03:43:44 <Welkin> oh, what a wonderful idea
03:43:50 <Welkin> a programming language built on faith
03:43:53 <Welkin> it is beyond logic
03:44:09 <kuribas> lieven_: What I want to know if it is possible to make that result consistent for a given program.
03:44:34 <Welkin> it shall be named kierkegaard, after the same philosopher
03:44:54 <jle`> yeah, it doesn't make sense to flip the const side
03:45:14 <jle`> maybe in my head a $> f would be just f, it'd be which side whose 'value' it is to keep
03:45:22 <jle`> but still it is profoundly useless
03:45:38 <jle`> the formulation in my head, that is
03:45:53 <jle`> still i feel more less unsettled with flip (<$) being (&>)
03:46:04 <jle`> going on the 'idea' of ($) vs the 'idea' of (&)
03:47:34 <jle`> hm. the more i think about it the more i feel like i should sleep
03:48:00 <snickle> nothing good ever came from that D:
03:49:12 <wferi> Hi! Is it possible to provide a type signature for an identifier bound in a do expression, to keep it polymorphic?
03:49:16 <nexx> from sleeping or thinking?
03:49:30 <snickle> take your pick :D
03:49:56 <Kinnison> wferi: I believe both let and where allow type signatures to be specified.  Not so sure about <-
03:50:14 <Kinnison> wferi: although thinking about it, I'd expect it to
03:50:16 <mniip> Kinnison, type signatures can be put anywhere
03:50:18 <nexx> I think there is an extension for this
03:50:39 <wferi> can you give me a syntax example?
03:50:48 <wferi> (let and where are fine)
03:50:57 <mniip> Oh, wait, you mean like... x <- g, but ensuring x is of some exact type?
03:50:58 <wferi> (I mean, I know the syntax for let and where)
03:51:26 <wferi> I want x to stay a polymorphic function (class member)
03:54:07 <mniip> hmmm, my idea with `x <- f (Monad m) => m Type` failed
03:54:23 <mniip> wferi, you can put `return (x :: String)` immediately after the bind, I guess
03:54:43 <mniip> well or any other type
03:55:27 <wferi> If I write this: p <- return (query :: Query a => String -> Maybe a)
03:55:41 <wferi> then p won't stay polymorphic, I can use it with a single type only
03:56:25 <mniip> wferi, ummmm can you give an example of your current code
03:56:28 <jle`> maybe you can try scpoed type variables and specify a at the top level?
03:56:33 <wferi> while let q :: Query a => String -> Maybe a; q = query works fine
03:57:40 <mniip> wferi, p <- return query :: Maybe a
03:58:02 <mniip> I mean, p <- return query :: String -> Maybe a
03:58:20 <mniip> wait I am confused
03:58:27 <mniip> :(
03:58:37 <wferi> http://lpaste.net/101546
03:59:14 <wferi> this errors out until I comment out the last (25th) line
03:59:45 <mniip> I see
04:00:41 <wferi> I have to leave the keyboard now, please just write your suggestions here, I'll be back
04:00:46 <wferi> thanks in advance
04:03:38 <ketil> Hi, people.  Any way to check if stdin is a pipe or a terminal?
04:06:35 <mniip> `hIsTerminalDevice stdin` it seems
04:08:12 <troydm> so i have an scheme implementational question, i'm storing closures as HashMap.Strict's and having a global lookup hierarchy as exists lookup [HashMap.Strict] thing
04:08:27 <troydm> is this an efficient way to handle enviroment variables?
04:10:21 <kuribas> You mean using unique IDs?
04:11:32 <kuribas> You could also use mutable variables, like STRef or IORef, that would be more efficient, but not pure...
04:11:33 <troydm> kuribas: no i mean having HashMap's for each call to a function
04:11:45 <troydm> kuribas: i use IORef btw
04:11:53 <kuribas> I see
04:12:42 <kuribas> I'd use an association list, because it can be easily extendend, and it shares the structure.
04:12:55 <kuribas> Though an hashmap is also fine probably.
04:15:39 <mniip> wferi, http://qp.mniip.com/p/b1
04:15:51 <mniip> my suggestion is to use let/where
04:18:26 <kuribas> troydm: lookup is slower for an association list, but list creation is faster, and extending the environment is simply prepending using cons.
04:20:15 <troydm> kuribas: ic
04:22:29 <bahamas> sometimes LYAH is so confusing. example: (<$>) :: (Functor f) => (a -> b) -> f a -> f b; f <$> x = fmap f x
04:23:09 <shiona> what's confusing about that?
04:23:33 <bahamas> shiona: the f
04:23:46 <shiona> ah
04:23:49 <bahamas> shiona: in the type definition it's a type variable and below it's a function
04:23:58 <shiona> true
04:24:13 <shiona> f is often used for both functor and function
04:24:25 <bahamas> yes, I noticed
04:24:33 <__sebastian__> that's indeed confusing
04:24:49 <bahamas> but until you remember that, it's confusing
04:24:55 <shiona> yes
04:24:58 <__sebastian__> yep
04:25:26 <shiona> an easy way to make the world a better place is to always use g as the first one letter function name in you own code/text
04:25:44 <shiona> maybe one day we won't have the confusion
04:29:52 <bahamas> another source of confusion is the fact that types and variable constructors have the same name. using slightly different names would make it easier
04:31:10 <jle`> one letter variables names in general can be a source of confusion
04:31:39 <jle`> i don't know any other language where it is idiomatic to name any variables other than counters with one letter
04:32:20 <__sebastian__> I've a problem with existing instances. I'd like to define my own instance for Falure E, but im in a monad transformer (with IO) and Falure already defines instances for that: http://hackage.haskell.org/package/failure-0.2.0.1/docs/Control-Failure.html#t:Failure
04:32:37 <__sebastian__> I'd really like to have my own instance instead
04:32:42 <__sebastian__> is it possible somehow?
04:33:35 <nicoo> jle`: I believe it has more to do with the scope of the variable : if the variable occurs only in a very small piece of code, terse (or even one letter) names are ok.
04:34:06 <nicoo> If your variable occurs in lots of places, it probably ought to have a descriptive name.
04:34:28 <ghorn> merijn: I have a workaround that seems to work http://lpaste.net/101543
04:34:36 <bartavelle> also variables for abstract stuff can't really have a meaningful name
04:34:37 * hackagebot BlogLiterately 0.7.1.6 - A tool for posting Haskelly articles to blogs  http://hackage.haskell.org/package/BlogLiterately-0.7.1.6 (BrentYorgey)
04:35:15 <ghorn> merijn: "Forall" isn't the right name though
04:35:23 <bartavelle> __sebastian__, I think the usual approach is to newtype IO, then derive all that you don't want to change, and redefine the rest
04:36:58 <__sebastian__> bartavelle: thanks.
04:37:40 <__sebastian__> bartavelle: I'll think about that. newtyping IO is a little bit arkward.
04:37:45 <bartavelle> yeah :/
04:39:12 <__sebastian__> another way would be to hack Failure to seperate the class from the instances
04:40:11 <bartavelle> yeah but this is evil if someone else reuses your code
04:42:08 <__sebastian__> mybe I'm not the only one with that problem. I could make a pull reqest
04:43:19 <bartavelle> I think others might just catch
04:55:39 <rfw> hi, so i'm just wondering about GADTs: data Foo a where Bar :: a -> Foo a
04:55:50 <rfw> is Bar actually :: forall a. a -> Foo a
04:55:55 <rfw> or does the a in Foo a actually come into play
04:56:50 <supki> those as are unrelated
04:56:52 <rfw> er, barring the use of datatype contexts
04:57:06 <supki> data Foo :: * -> * where Bar :: a -> Foo a  is the same thing
04:57:15 <rfw> aha
04:57:27 <rfw> so whatever names i give the parameters to the GADT don't actually matter?
04:57:33 <rfw> and they're not useful at all?
04:57:34 <supki> yeah, that's correct
04:57:38 <rfw> ah, thanks
05:04:37 <no-n> what's the diff between liftM and ap?
05:05:19 <kuribas> :t liftM
05:05:21 <lambdabot> Monad m => (a1 -> r) -> m a1 -> m r
05:05:23 <kuribas> :t ap
05:05:24 <lambdabot> Monad m => m (a -> b) -> m a -> m b
05:05:37 <no-n> they look the same
05:05:50 <kuribas> no-n: the first argument of ap is lifted in the monad.
05:06:02 <kuribas> m (a -> b) versus (a -> b)
05:06:06 <no-n> oh, oops
05:06:13 <no-n> indeed :4
05:06:14 <no-n> :3
05:06:55 <kuribas> ap is easier to combine with more than one param, for example : return f `ap` a `ap` b
05:07:46 <kuribas> That doesn't work with liftM because it would give a type error.
05:08:12 <kuribas> > (+) `liftM` return 1 `liftM` return 2
05:08:13 <lambdabot>  No instance for (GHC.Show.Show (m0 (a10 -> a10)))
05:08:13 <lambdabot>    arising from a use of `M574087125913140055319111.show_M5740871259131400553...
05:08:13 <lambdabot>  The type variables `m0', `a10' are ambiguous
05:08:13 <lambdabot>  Possible fix: add a type signature that fixes these type variable(s)
05:08:13 <lambdabot>  Note: there are several potential instances:
05:08:59 <kuribas> hm...
05:09:43 * hackagebot bytestring-class 0.0.0.1 - Classes for automatic conversion to and from strict and lazy bytestrings. (deprecated)  http://hackage.haskell.org/package/bytestring-class-0.0.0.1 (MichaelSnoyman)
05:09:59 <no-n> i was able to use "drop" as the first argument to ap.. is this because it's [a] -> [a] and the list monad? lol
05:10:05 <kuribas> > (+) `liftM` Just 1 `liftM` Just 2
05:10:07 <lambdabot>  Couldn't match expected type `a10 -> r0'
05:10:07 <lambdabot>              with actual type `Data.Maybe.Maybe (a1 -> a1)'
05:10:17 <kuribas> > return (+) `ap` Just 1 `ap` Just 2
05:10:18 <lambdabot>  Just 3
05:12:07 <no-n> uhh. ugh. lol.
05:12:37 <kuribas> strange...
05:12:39 <bahamas> kuribas: those two functions look like the equivalents of <$> and <*> for monads. am I correct?
05:12:52 <merijn> bahamas: Yes
05:12:54 <kuribas> :t <$>
05:12:54 <lambdabot> parse error on input `<$>'
05:12:59 <kuribas> :t (<$>)
05:13:00 <lambdabot> Functor f => (a -> b) -> f a -> f b
05:13:07 <merijn> bahamas: In fact, they only exist but right now applicative is not a superclass of monad
05:13:07 <kuribas> :t (<*>)
05:13:08 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
05:13:20 <merijn> bahamas: In 7.10 this should be fixed and they will be identical
05:13:36 <bahamas> merijn: did you mean "because" instead of "but"?
05:13:56 <bahamas> ah, cool. I'm glad I'm noticing these things
05:14:20 <kuribas> how is [a] -> [a] "m (a -> b)"?
05:14:40 <no-n> @pl \x -> drop x $ replicateM x "01"
05:14:41 <lambdabot> ap drop (flip replicateM "01")
05:14:45 <fizruk> kuribas: it is not
05:14:50 <hunt> google summer of code
05:14:52 <no-n> :t ap
05:14:53 <lambdabot> Monad m => m (a -> b) -> m a -> m b
05:14:56 <bahamas> kuribas: what do you mean?
05:15:06 <merijn> kuribas: Are you sure it was "[a] -> [a]"?
05:15:09 <no-n> what's confusing me is, drop is (a -> b) ; not m (a -> b)
05:15:13 <merijn> kuribas: i.e. which function did you use
05:15:31 <merijn> drop <*> foo?
05:15:31 <kuribas> drop is Int -> [a] -> [a]
05:15:36 <bahamas> :t drop
05:15:37 <lambdabot> Int -> [a] -> [a]
05:15:46 <no-n> yes
05:15:47 * merijn suspects reader monad
05:16:08 <merijn> no-n: Right, if you write "drop <*> foo" it's using the reader monad
05:16:19 <merijn> no-n: i.e. Monad ((->) r)
05:16:27 <no-n> ahh
05:16:30 <merijn> Or Applicative, whichever
05:17:39 * no-n would rather just use the lambda now
05:17:51 <merijn> "Applicative f => f (a -> b) -> f a -> f b" becomes "(->) Int ([a] -> [a]) -> (->) Int [a] -> (->) Int [a]" which is "(Int -> [a] -> [a]) -> (Int -> [a]) -> (Int -> [a]"
05:18:13 <bahamas> isn't drop <*> foo like drop . foo?
05:18:23 <khyperia> bahamas, no, that's fmap
05:18:48 <khyperia> <*> for functions is... I think \f g x -> (f x) (g x)
05:18:50 <no-n> fmap = (.)
05:18:52 <bahamas> oh, right
05:19:07 <no-n> <*> for functions :/
05:19:15 <khyperia> the function applicative instance
05:19:35 <khyperia> aka Reader
05:21:32 <bahamas> khyperia: from that definition I understand that (f x) needs to return a function, no?
05:21:50 <bahamas> so that it ca be applied to (g x)
05:22:23 <khyperia> yep, look at the signature of (<*>) - the first argument is a function, and then the Applicative f adds another argument in front of that
05:23:10 <khyperia> @pl \x -> f (g x) x -- for completeness, the instance Monad ((->) a)
05:23:10 <lambdabot> f =<< g
05:23:45 <merijn> :t (+) <$> (*3) <*> (+2)
05:23:46 <lambdabot> Num a => a -> a
05:23:57 <merijn> > (+) <$> (*3) <*> (+2) $ 5
05:23:58 <lambdabot>  22
05:24:17 <merijn> bahamas: It applies both (*3) and (+2) to 5 and then (+)'s the result
05:24:49 <khyperia> Heh, that blew my mind the first time I saw it... it looked like it was using functions as values, doing math operations on them :P
05:24:59 <Iceland_jack> > ((+) =<< pred) 10
05:25:00 <lambdabot>  19
05:25:14 <no-n> which part, khyperia?
05:25:23 * no-n probably needs to reread chapter 11 of LYAH
05:25:50 <khyperia> no-n, which part of what?
05:26:00 <no-n> that blew your mind when you saw it
05:26:09 <khyperia> oh, what merijn said to lambdabot
05:26:24 <bahamas> merijn: yeah, I'm trying to understand that
05:26:31 <no-n> oh yeah, heh
05:26:50 <no-n> I can't read the way it "happens" but I can read what it "does"
05:26:51 <bahamas> no-n: the one about functors and applicatives? I'm just reading that
05:26:54 <merijn> bahamas: It can be very educational to implement it yourself
05:26:55 <no-n> if that makes sense
05:27:06 <no-n> bahamas yea
05:27:14 <no-n> the one with frogtor
05:27:30 <no-n> i was happy that i'd finished it
05:27:40 <no-n> but i don't think i learned all its lessons well :p
05:27:58 <bahamas> I've been at it for the last two days, but I'm going slowly, because I want to understand stuff
05:27:59 <merijn> bahamas: Just open an editor, write: "instance Applicative ((->) r) where" and implement it by staring at the type :)
05:28:05 <khyperia> I agree with merijn, me implementing Reader and State Functor/Applicative/Monad for various things was *really* helpful
05:28:11 <bahamas> merijn: ah, that's what you meant
05:28:36 <no-n> merijn: I got "MULTIPLE INSTANCE DECLARATIONS" or some such
05:28:38 <merijn> bahamas: "pure :: Applicative f => a -> f a", "(<*>) :: Applicative f => f (a -> b) -> f a -> f b"
05:28:48 <merijn> no-n: Yeah, probably because it already exists :\
05:28:55 <no-n> right :p
05:29:02 <no-n> I implemented it for my Tree type
05:29:19 <merijn> no-n: You can get around it by defining a newtype "newtype Reader r a = Reader (r -> a)" and the implementing it for that
05:29:29 <no-n> ahh yes
05:29:43 <merijn> no-n: Just means you have to add some redundant wrapping using the Reader constructor
05:29:55 <no-n> yeah
05:29:59 <no-n> I remember all the new type stuff now
05:30:11 <no-n> like Any, All, First, Last, Product, Sum, etc...
05:30:25 <bahamas> :t (<$>)
05:30:26 <lambdabot> Functor f => (a -> b) -> f a -> f b
05:30:29 <no-n> actually, i have notes... maybe i just need to read those :P
05:30:45 <merijn> no-n: I think there's at most like a handful of ways to implement it in a way that typechecks and only one implementation makes sense, so just keep messing until it typechecks ;)
05:30:51 <merijn> bahamas: <$> is just infix fmap
05:31:11 <Iceland_jack> ghci> quickCheck (length >>= take >>= (==))
05:31:11 <Iceland_jack> +++ OK, passed 100 tests.
05:31:14 <bahamas> merijn: yup. I know. that's the part I'm trying to understand from your equation above
05:31:18 <merijn> > (+1) `fmap` Just 1
05:31:20 <lambdabot>  Just 2
05:31:42 <bahamas> I understand it when applied to other functors, but I'm still having difficulties with functions
05:31:44 <merijn> bahamas: Right, the trick to understanding my use of fmap is that "b" can be a function too
05:32:35 <merijn> "(a -> b) -> f a -> f b", now take 'b' as '[a] -> [a]' and you get: "(a -> ([a] -> [a])) -> f a -> f ([a] -> [a])}
05:32:53 <merijn> And of course "a -> ([a] -> [a])" is the same as "a -> [a] -> [a]"
05:33:04 <bahamas> ah, now I understand it. (+) <$> (*3) == (+) . (*3)
05:33:25 <bahamas> so this returns a functor, on which we can use <*>
05:33:31 <merijn> bahamas: Yeah
05:33:59 <bahamas> this is so brain twisting :)
05:34:01 <wferi> mniip: I found a description of my problem, it's "Let-bound polymorphism" at http://www.haskell.org/tutorial/pitfalls.html
05:34:24 <merijn> bahamas: Reader/State/Writer are all braintwisting until you slowly walkthrough them and go "ooooh, it's just X"
05:34:44 <merijn> bahamas: Hence why it's highly recommended to reimplement Functor/Applicative/Monad for them from scratch
05:34:45 * hackagebot wai-app-static 2.0.0.5 - WAI application for static serving  http://hackage.haskell.org/package/wai-app-static-2.0.0.5 (MichaelSnoyman)
05:34:47 * hackagebot warp-static 2.0.1.1 - Static file server based on Warp and wai-app-static (deprecated)  http://hackage.haskell.org/package/warp-static-2.0.1.1 (MichaelSnoyman)
05:34:48 <no-n> why is it called Reader?
05:35:02 <merijn> no-n: Because it gets a "read-only" environment
05:35:22 <bahamas> merijn: aha. I haven't reached them yet
05:35:25 <merijn> no-n: You're passing some value 'r' to every function as extra input, like a "global" context
05:35:35 <wferi> mniip: unfortunately, I can't simply use let or where, because I actually have to do I/O to prepare my query function (it's not hard-coded, but returns values from a file)
05:35:49 <no-n> i thought the r was the type of the functions parameter
05:35:56 <merijn> no-n: Right
05:36:07 <no-n> so how is that "extra input"?
05:36:10 <merijn> no-n: But with Reader it becomes easy to pass 'r' to lots of nested functions
05:36:47 <merijn> So you can kinda "hide" it away by writing "a -> b -> Reader r c" and then compose 'Reader r c' with other 'Reader r' operations
05:36:47 <mniip> wferi, you'll have to bind twice
05:36:55 <wferi> mniip: this "preparation", can be done in a separate let binding, but then I can't avoid also binding a name via do
05:37:14 <merijn> bahamas: If you mostly understood what I just said, you should already be able to do most of this (note: I say able to, I didn't say it's *easy* ;))
05:37:21 <wferi> mniip: which is an extra name in scope, which I'd like to avoid
05:37:37 <wferi> mniip: but can live with, if I must
05:37:51 <wferi> mniip: thanks for your assistance!
05:38:33 * no-n will drink another coffee then read the scrollback
05:38:39 <merijn> bahamas: Reader is fairly easy, with "newtype Reader r a = Reader (r -> a)", for a bit more challenge you can implement functor/applicative/monad for "newtype State s a = State (s -> (a, s))", for bonus points also write "get :: State s s" and "put :: s -> State s ()" :)
05:39:39 <no-n> i probably need to read this whole chapter again :/
05:39:45 * hackagebot wai-extra 2.1.1 - Provides some basic WAI handlers and middleware.  http://hackage.haskell.org/package/wai-extra-2.1.1 (MichaelSnoyman)
05:39:47 * hackagebot wai-handler-scgi 2.0.0.2 - Wai handler to SCGI (deprecated)  http://hackage.haskell.org/package/wai-handler-scgi-2.0.0.2 (MichaelSnoyman)
05:40:57 <merijn> bahamas: The expected experiences should be 1) what? 2) confusion 3) hmm, maybe? 4) I don't get this at all 5) oh...is that all it does?
05:41:36 <bahamas> :i Reader
05:42:44 <bahamas> how often are these things used?
05:42:51 <merijn> bahamas: It's defined in Control.Monad.Trans.Reader, but I recommend not peeking and instead grabbing a paper and working out the types by hand
05:43:28 <merijn> bahamas: The transformer versions of it are used fairly often and I would say that understanding them is critical for moving from "I just finished LYAH" to "writing real haskell programs"
05:43:50 <merijn> So spending a day or 2 trying to implement and understand them is time well spent
05:44:30 <bahamas> I'm not very familiar with "newtype" either. from what I know it's like "data". so Reader has the kind * -> * -> *
05:44:32 <bahamas> am I correct?
05:44:56 <no-n> it only wraps an existing type in a "new type"
05:45:09 <no-n> so you can only have one value constructor and one field
05:45:39 <no-n> basically so you can have different instances of a type class for the "same" type
05:45:47 <merijn> bahamas: The kind is right, yeah
05:46:28 <merijn> bahamas: The difference between data and newtype is that data constructors exist at runtime. Newtype constructors don't
05:46:55 <merijn> bahamas: So if I have "newtype Age = Age Int" then at runtime "1" and "Age 1" look identical
05:47:20 <merijn> bahamas: The constructor and type only exist during typechecking, to enforce not accidentally passing an Int to something expecting an Age
05:47:30 <no-n> ahh
05:47:39 <merijn> bahamas: Other bonuses are the ability to specify new typeclass instances for the newtype
05:49:08 <merijn> bahamas: This also has some subtle strictness implications
05:49:44 <bahamas> merijn: so you can't use the Age value constructor to build values at runtime?
05:49:46 * hackagebot conduit 1.0.17 - Streaming data processing library.  http://hackage.haskell.org/package/conduit-1.0.17 (MichaelSnoyman)
05:49:48 * hackagebot conduit-extra 0.1.7 - Experimental helper functions for conduit.  http://hackage.haskell.org/package/conduit-extra-0.1.7 (MichaelSnoyman)
05:49:58 <merijn> bahamas: For example "case Just undefined of Just x -> 1" <- this works fine, undefined is wrapped by Just at runtime, so pattern match works
05:50:10 <honza> would anyone be willing to offer a few thoughts on the relationship between haskell and ocaml?
05:50:38 <merijn> bahamas: "case Age undefined of Age x -> 1" <- this returns undefined, since the "Age" constructor doesn't exist at runtime, pattern matching against "Age undefined" is identical to matching "undefined"
05:50:55 <lllllllllllll> Hey, i have : mac1 and mac2 (mac addresses) and i want to prefix match on a string like "mac1mac2..." where my mac address can i either be the first or the second mac. Can i encode both mac address so that i can prefix match on it?
05:51:10 <merijn> bahamas: Well, it's more that during compilation all "Age 1" or "Age x" thing's just get replaced by "1" and "x"
05:51:38 <merijn> bahamas: And pattern matching "Age x" just becomes matching "x"
05:51:40 <lllllllllllll> like in packet with from and to i want to match where my address is either from or to but only with a prefix match
05:51:59 <Walther> Hi! I'm doing some code golfing, any idea on how to shorten "show.n.map(map read.words).filter(notElem '#').lines"
05:52:16 <bahamas> merijn: oh, right. since so many things happen at compilation time.
05:52:21 <merijn> honza: Haskell has nicer syntax, typeclasses, is lazy and pure. OCaml has structural subtyping, higher order modules, is strict and not pure.
05:53:03 <merijn> bahamas: Basically, newtype is a way to say "I just want to give this function an Int, but I want to statically check I never give it the "wrong" type of Int"
05:53:13 <honza> merijn: worth looking into ocaml?
05:53:36 <merijn> bahamas: So in the compiled code you're just passing/getting Int, but the typechecker has already ensured the type separation holds
05:53:51 <merijn> honza: Sure, if you already know haskell you should be able to pick it up in like half a day
05:53:51 <bahamas> I think I understand
05:54:28 <merijn> honza: See for example: http://blog.ezyang.com/2010/10/ocaml-for-haskellers/
05:54:47 <honza> merijn: awesome, will have a look
05:55:12 <merijn> honza: In terms of "should I learn haskell or ocaml", I would argue haskell is "more different" and thus a better investment. If you already know haskell (a bit), then it can't hurt to check out ocaml a bit
05:56:09 <honza> merijn: yeah, i'm getting deeper and deeper into haskell these days and the recent announcement out of facebook about their hacklang and its ocaml compiler peaked my interest in ocaml
05:56:38 <NikolajK> The type class Monad is related to functors. Is the same true for (all?) other type classes?
05:57:43 <merijn> NikolajK: All Applicatives are Functors and all Monads are Applicatives
05:57:48 <quicksilver> no, NikolajK, but it's true for most type classes of Kind * -> *
05:58:07 <quicksilver> most "interesting" things of kind * -> * are functors.
05:58:09 <merijn> NikolajK: It's not the same for every typeclass, though
05:58:25 <quicksilver> plenty of type classes have other kinds though
05:58:27 <NikolajK> okay, I'll look out for * -> *
05:58:34 <quicksilver> (Eq,Num,Ord, etc)
05:58:36 <fizruk> is `data Iter a = Iter (a -> a) a` interesting?
05:59:15 <NikolajK> does forall always only range over a fixed type class?
06:01:59 <bartavelle> lllllllllllll, what about isPrefixOf ?
06:03:03 <lllllllllllll> bartavelle, the proble is that i want to match my-mac|other-mac and other-mac|my-mac
06:03:19 <merijn> bleh, why doesn't Parsec have a built-in "anythingButX" parser >.>
06:03:19 <lllllllllllll> so i have to encode them somehow
06:03:43 <bartavelle> I am not sure I understand
06:03:52 <bartavelle> well I am sure I don't :)
06:03:59 <bahamas> merijn: if I understand correctly, newtype Coords = Coords Int Int doesn't make sense, because the value constructor takes two values here. am I right?
06:04:12 <merijn> bahamas: Right
06:04:29 <merijn> bahamas: Newtypes can only have one constructor and that constructor can have only one argument
06:04:34 <bahamas> so, newtype can be used as a sort of alias
06:04:39 <bahamas> aha
06:04:58 <bartavelle> lllllllllllll,  (mymac `isPrefixOf` src && othermac `isPrefixOf` dst) || (othermac `isPrefixOf` src && mymac `isPrefixOf` dst)   ?
06:05:07 <merijn> bahamas: Right, but unlike "type" newtype's name is treated as a new type (hence the name ;)) by the typechecker
06:06:02 <merijn> bahamas: For a well known example "type String = [Char]", giving ['a'] to a function that takes String is fine
06:06:17 <merijn> bahamas: If it had been "newtype String = String [Char]", then that'd be a type error
06:07:48 <bahamas> merijn: so what should we pass to the function, so that there's no type error? "a"?
06:08:44 <merijn> bahamas: "String ['a']"
06:08:59 <merijn> bahamas: "a" is just syntactic sugar for ['a']
06:09:05 <merijn> > "" == []
06:09:06 <lambdabot>  True
06:09:10 <merijn> > "a" == ['a']
06:09:11 <lambdabot>  True
06:09:57 <lllllllllllll> bartavelle,sorry, let me explain further: i send a string like "from|to|payload" over the network. On the other end i want to filter packets, that are either addressed to me or are send from me, so if my address is in from or to. But i can only prefix match (zeromq filter) the string, so i couldn't amtch if my address is in the to field, since i don't know the from field, so prefix amtching does not work. So my stupid idea was to somehow en
06:10:55 <bahamas> merijn: ah, so we use the name of the constructor, it's just that it's replaced at compile time
06:10:58 <lllllllllllll> so "mac1|mac2" and "mac2|mac1" should have the same prefix in their encoding
06:11:01 <merijn> bahamas: Yes
06:11:17 <lllllllllllll> i hoped the uniqueness gives rise to something like that
06:11:29 <bahamas> I see. these are so fine distinctions
06:11:35 <merijn> bahamas: newtype constructors are a way to tell the compiler "you can safely coerce to the newtype here"
06:11:57 <merijn> Essentially, they're a typechecked way of doing
06:12:01 <merijn> :t unsafeCoerce
06:12:02 <lambdabot> Not in scope: `unsafeCoerce'
06:12:05 <merijn> oh, duh
06:12:14 <merijn> It's unsafeCoerce :: a -> b
06:12:32 <bahamas> it does indeed feel like I'm almost relearning programming from scratch
06:14:56 <braintwist> Hey  I am trying to do some map over an IO list but I cant seem to get it right, some hints would be appreciated
06:16:02 <dv-> braintwist: pastebin your code
06:16:57 <braintwist> http://pastebin.com/TTAZbzRB
06:17:41 <fizruk> braintwist: please add type signatures for top-level definitions
06:18:43 <braintwist> the problem is my attemps at making findWord do a map...
06:19:00 <merijn> braintwist: FYI, you don't need "do" inside lines_w
06:19:18 <merijn> braintwist: Just "liftM lines w" should be sufficient
06:19:24 <braintwist> ah that is nice
06:19:42 <braintwist> yeah it works :D
06:20:17 <merijn> braintwist: You may wanna split findWords into smaller definitions and annotate the types so it's clearer for you (and us) what you're doing
06:20:56 <no-n> f <*> g = \x -> f x (g x) -- so why is it defined like this for ((->) r)? how does it work exactly?
06:21:13 <merijn> braintwist: For example "liftM (head . tail . tail) lines_w" <- this extracts the 3 line of "lines_w", that doesn't seem like what you want?
06:21:29 <braintwist> it gets one line
06:21:37 <braintwist> and finds a word
06:21:53 <merijn> no-n: Well "(<*>) :: (r -> (a -> b)) -> (r -> a) -> (r -> b)"
06:21:55 <braintwist> I just want it to do that across multiple lines
06:22:31 <merijn> no-n: So, it first gives an 'r' to the second function to get an 'a' and then gives both the 'r' and 'a' to the first function
06:23:47 <merijn> braintwist: What does searchStr return? A String?
06:23:53 <braintwist> Yeah
06:24:44 <braintwist> it uses the repat as regular expression to find a string of letters to return
06:24:53 <MagneticDuck> http://ix.io/bcC
06:25:06 <MagneticDuck> I'm using fold markers for folding in vim...
06:25:24 <MagneticDuck> but now I'm starting to document stuff with haddock and I'm running into problems like this one: how do I get haddock to ignore the last line (a fold marker)?
06:26:18 <MagneticDuck> I guess I could use {- for the haddock part?
06:26:23 <MagneticDuck> is there a cooler way of doing it?
06:27:10 <Methodius> Hello ; I have a probably stupid question about importing modules which I described here: http://lpaste.net/101552
06:27:36 <Methodius> Can someone help me answer it? It's probably very simple but some google foo didn't help me :(
06:28:31 <MagneticDuck> Methodius: maybe you mean to hide "main", not "test" x|
06:28:37 <braintwist> merijn: I think I have a good idea about my problem
06:28:51 <merijn> braintwist: For example: http://lpaste.net/101554
06:29:03 <MagneticDuck> Methodius: just because it's not being exported doesn't mean the module itself can't use it you know
06:29:10 <b0bbi10> hi, how come that 'take 24 [13, 26..]' is better than '[13, 26..24*13]'? isn't Haskell laze in both cases? and in the former Haskell would need resources for the function call
06:29:28 <braintwist> merijn: I want to map on a IO list but when I do want I think is the right thing I get the [m0 a10]
06:29:39 <merijn> braintwist: Right
06:29:46 <merijn> braintwist: Which is what we have this for:
06:29:49 <merijn> :t sequence
06:29:50 <lambdabot> Monad m => [m a] -> m [a]
06:29:50 * hackagebot flaccuraterip 0.2.1 - Verify FLAC files ripped form CD using AccurateRip"  http://hackage.haskell.org/package/flaccuraterip-0.2.1 (NicolaSquartini)
06:29:52 <merijn> :t sequence_
06:29:52 <lambdabot> Monad m => [m a] -> m ()
06:30:15 <pranz> Methodius: if A doesn't import B, you can't use any names from that module
06:30:19 <braintwist> yeah I am really green and this thing I am written is my learning haskell :D
06:30:21 <merijn> braintwist: Incidentally, like in my example "mapM f = sequence . map f" and "mapM_ f = sequence_ . map f"
06:30:51 <Methodius> MagneticDuck: Yes, I know it looks like I got it backwards, but this is a simplification of what I'm actually doing. I have a parser written in one file, and I'd like to alter only one function in it, while having a separate file
06:31:02 <MagneticDuck> Methodius: yeah, that doesn't work like that
06:31:25 <MagneticDuck> it really just... doesn't
06:31:39 <Methodius> Maybe the example was actually a bad one...
06:31:40 <MagneticDuck> if you want to generalise some part of a definition... use a function =P
06:32:04 <braintwist> merijn awesome that just worked...
06:32:48 <Methodius> Basically, I'm doing the exercises in Write Yourself A Scheme in 48 hours, and I'd like to keep one file with the main code they give, and then have one file for each exercise that reuse most of the definitions but alter just one function to solve the exercise
06:32:48 <bahamas> :t (<*>)
06:32:49 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
06:32:54 <braintwist> my problem was that my results all got [m0 a0] results and I needed m0 [a0] instead
06:32:55 <MagneticDuck> anybody here using fold makers and haddock simultaneously?
06:33:32 <merijn> braintwist: Yeah, are you aware of Hoogle?
06:33:42 <MagneticDuck> Methodius: it sounds like you want to generalise a part of a definition. That's what functions are for =P
06:33:48 <merijn> @hoogle [m a] -> m [a]
06:33:50 <lambdabot> Prelude sequence :: Monad m => [m a] -> m [a]
06:33:52 <lambdabot> Control.Monad sequence :: Monad m => [m a] -> m [a]
06:33:56 <lambdabot> Language.Haskell.TH.Syntax sequenceQ :: [Q a] -> Q [a]
06:34:10 <braintwist> merijn yes but it is a little difficult to find things when you dont know what you are looking for :D
06:34:11 <MagneticDuck> importing one module instead of another will never change the behaviour of functions imported from another module
06:34:29 <Methodius> MagneticDuck: That's why I mentioned my question was probably stupid :p
06:34:30 <no-n> hmm, i'm a bit more comfortable with applicative functors now going over my notes :3
06:34:32 <merijn> braintwist: It lets you search by type signature too, so if you know which type you want :)
06:34:37 <MagneticDuck> Methodius: alright :D
06:34:45 <bahamas> no-n: f <*> g = \x -> f x (g x) means that f should return a function while g should return a value
06:35:16 <braintwist> merijn yeah but since I am not so good at this haskell the type signatures can be a little difficult to get right
06:35:18 <pranz> Methodius: import your own module from the main code they gave you
06:35:21 <pranz> instead
06:35:24 <no-n> yes. you always get the same type of functor back.
06:35:28 <Methodius> MagneticDuck: See, I was wrongly interpreting an import as what a preprocessor #include would do, roughly, but that's obviously wrong
06:35:34 <no-n> oh, i get it
06:36:10 <bahamas> no-n: like (*) <*> (+4) $ 5 = (*5) returns a function and ((+4) 5) returns a value. so you have (*5) ((+4) 5)
06:36:25 <no-n> it's just (r -> (a -> b)) -> (r -> a) -> (r -> b) or something
06:36:39 <merijn> no-n: It's *exactly* that
06:36:43 <bahamas> heh
06:36:47 <no-n> B)
06:37:08 <Methodius> MagneticDuck: Now, I'm probably being very stupid, but I don't get how I could solve my "problem" with functions...
06:37:10 <MagneticDuck> Methodius: yeah, there might be something equilivant to that in haskell, but it's certainly not the behaviour of normal "imports"
06:37:10 <merijn> no-n: With the reminder that "r -> (a -> b)" and "r -> a -> b" are identical things
06:37:30 <no-n> so we're kind of thinking of the functions domain as a functor
06:37:39 <no-n> and its range as what's "inside" that functor"
06:38:07 <MagneticDuck> Methodius: well as I see it, you want to generalise a definition of something on the definition of some function that it's using right?
06:38:23 <no-n> merijn indeed
06:40:23 <Methodius> MagneticDuck: I have code given by book in one file. I have an exercise that says "modify function X to do so and so". I want to not duplicate the code I was given, have a separate file with my new definition of function X and use that file just like it was the original program, except function X has the new behaviour
06:41:25 <Methodius> MagneticDuck: Which I would never need to do really, except I want to clearly separate the exercise itself
06:42:19 <Methodius> MagneticDuck: and not duplicate code, or have logic to call one version of function X or another
06:42:19 <MagneticDuck> "To prevent code duplication and promote code reuse, generalise." once said a wise haskell monk
06:44:12 <MagneticDuck> ....
06:44:36 <MagneticDuck> hm
06:44:48 <MagneticDuck> uhm, let's make a simple example x|
06:45:22 <Methodius> MagneticDuck: I could even put it in my github and show you with the real code acutally
06:45:27 <MagneticDuck> so you have a function "bigFun" that uses "smallFun" as part of its definition; you want to substitute smallFun with another function with the same type and have bigFun work?
06:45:35 <MagneticDuck> generalise bigFun to accept another value of smallFun
06:45:47 <MagneticDuck> at least that's how I see it, hopefully not missing anything
06:48:30 <Methodius> MagneticDuck: Let me make a commit on my github with the actual (short) code I'm working with
06:48:57 <MagneticDuck> kk
06:51:28 <Methodius> MagneticDuck: https://github.com/ccressent/wyas48h/tree/master/2.parsing
06:51:47 <Methodius> MagneticDuck: if you open Wyas48h.hs and Ex2.hs side by side
06:52:21 <Methodius> MagneticDuck: I want to use all of Wyas48h.hs, but just modify parseString for the exercice
06:52:31 <MagneticDuck> nice names :D
06:52:59 <MagneticDuck> hm, URL doesn't seem to be valid
06:53:02 <MagneticDuck> oh
06:53:44 <MagneticDuck> I understand the names now ;D
06:54:52 * hackagebot clifford 0.1.0.7 - A Clifford algebra library  http://hackage.haskell.org/package/clifford-0.1.0.7 (spacekitteh)
06:55:08 <Methodius> MagneticDuck: So, ideally, if I compile Ex2.hs or load it in ghci, I'd be able to use the full parser, but with the modified version of parseString. All of this without duplication code. That's what I don't manage to do
06:56:18 <MagneticDuck> hm
06:57:12 <MagneticDuck> well I can't think of a better way of doing it besides just commenting out the definition of parseExpr and putting your own in
06:59:06 <Methodius> MagneticDuck: Yeah... I was trying to avoid commenting, moving or copying code, while still having a clear separation and the ability to run the examples... But yeah, I've been at it for almost 2 hours and I'm not sure it's possible at this stage
06:59:36 <fozworth> can someone help me get criterion and doctest installed at the same time? https://github.com/tfausak/haskeleton/issues/21
07:00:09 <MagneticDuck> Methodius: maybe a tool for automating generalisation of a parameter in a module?
07:00:10 <mniip> is there a quick way to check if an Integer is a power of 2?
07:00:38 <MagneticDuck> the neat solution would be ofc to parameterize usage of that definition, maybe if there was an automated way of doing it it would be cool =P
07:02:55 <MagneticDuck> mniip: how fast do you need?
07:03:12 <mniip> Well technically I need it short
07:03:22 <MagneticDuck> "short"?
07:03:23 <MagneticDuck> in code usage?
07:03:32 <mniip> as in code golf
07:03:36 <MagneticDuck> ahah
07:03:51 <Methodius> MagneticDuck: Well, thanks for trying to help me ; what's your problem with vim fold / haddock again? I can try to at least have a look at it
07:04:03 <fozworth> mniip: f x = x .&. (x - 1) == 0
07:04:07 <supki> fozworth: could you paste the output of  cabal install -v3 criterion doctest  on lpaste?
07:04:16 <fozworth> supki: sure, 1 sec
07:04:20 <MagneticDuck> fozworth: nifty
07:04:26 <MagneticDuck> @type (.&.)
07:04:27 <lambdabot>     Ambiguous occurrence `.&.'
07:04:27 <lambdabot>     It could refer to either `Data.Bits..&.',
07:04:27 <lambdabot>                              imported from `Data.Bits' at /home/lambda/.lambdabot/State/L.hs:56:1-16
07:04:36 <MagneticDuck> mm alright Data.Bits
07:04:42 <mniip> fozworth, I see, thanks
07:04:55 <MagneticDuck> Methodius: I think I got it solved
07:05:25 <monochrom> I just realized I made a silly mistake! I @tell'ed skypers but it's wrong target, it should be zipper
07:05:34 <MagneticDuck> Methodius: I think I've settled on http://ix.io/bcD
07:05:43 <monochrom> err wait nevermind, right target
07:05:43 <Methodius> MagneticDuck: Oh cool
07:06:00 <MagneticDuck> (using automation to generate that structure and stuff)
07:06:18 <MagneticDuck> my life as a programmer got a lot cooler when I started automating things and using / modifying plugins
07:06:57 <MagneticDuck> I'm still a bit primitive in my workflow though :<
07:06:58 <Methodius> MagneticDuck: Yeah. Let the computer work for *you*, not the other way around :)
07:07:39 <fozworth> supki: http://lpaste.net/101556
07:07:41 <Sonderblade> automate as much as possible you so get more time over to automate as much as possible
07:09:53 * hackagebot yi 0.7.2 - The Haskell-Scriptable Editor  http://hackage.haskell.org/package/yi-0.7.2 (DmitryIvanov)
07:09:56 * hackagebot yi-contrib 0.7.2 - Add-ons to Yi, the Haskell-Scriptable Editor  http://hackage.haskell.org/package/yi-contrib-0.7.2 (DmitryIvanov)
07:10:20 <Kron> My life got a lot cooler when I realized I could use version control for school assignments
07:10:40 <fozworth> mniip: a little golfier: f x = -x .&. x == x
07:11:10 <Kron> hmmm
07:11:10 <MagneticDuck> http://i.imgur.com/kaJ1Szj.png I be foldin'
07:11:16 <MagneticDuck> folds are nice
07:11:28 <Kron> fozworth: how does that work?
07:11:39 <MagneticDuck> unfortunately I found all of the automated foldexprs I found to be insufficent
07:11:53 <Kron> -x is... the negative version of x?
07:11:57 <Kron> or is it the curried version
07:12:00 <Kron> I can never remember
07:12:04 <fozworth> negative
07:12:05 <MagneticDuck> syntatic negation
07:12:10 <Kron> gotcha
07:12:13 <Kron> what does .&. do?
07:12:22 <MagneticDuck> "flip (-) 1"
07:12:22 <fozworth> it's been a while since i've twiddled twos complement bits, so i'm taking answers from http://stackoverflow.com/questions/600293/how-to-check-if-a-number-is-a-power-of-2
07:12:25 <MagneticDuck> :/
07:12:26 <MagneticDuck> not very golfy at all
07:12:36 <fozworth> .&. is binary AND
07:12:40 <fozworth> bitwise i mean
07:12:47 <Kron> gotcha
07:13:20 <spacekitteh> um silly question but if i compile haskell code with llvm, i can make it output any cpu architecture that llvm supports, right?
07:13:35 <spacekitteh> like, i can make it spit out arm code assuming i give it the right compiler options?
07:13:42 <supki> fozworth: ok, so the problem is that doctest depends on binary-0.5.1.1 but newer versions of criterion do not like it
07:13:45 <Kron> f = (==) <*> ((.&.) <*> negative)
07:13:47 <Kron> something like that
07:13:49 <Kron> would work, right?
07:13:53 <Kron> if it were right associative...
07:14:03 <supki> fozworth: I'm not sure you can do anything about that given that binary is a core package that comes with GHC
07:14:04 <Kron> f = (==) <*> (.&.) <*> (flip (-))
07:14:23 <supki> fozworth: probably your best bet is to compile doctest in a sandbox and copy the binary into PATH
07:14:36 <fozworth> supki: that's a bummer :(
07:14:36 <Kron> is there a simple way to say 'negative of'?
07:14:48 <Kron> like for curried forms
07:15:00 <fozworth> what about this issue/pr? https://github.com/bos/criterion/pull/38
07:15:30 <fozworth> Kron: negate ?
07:15:36 <Kron> ah, negate
07:16:08 <Kron> f = (==) <*> ((.&.) <*> negate)
07:16:12 <Walther> Any ideas on how to golf this shorter? show.n.map(map read.words).filter(notElem '#').lines;
07:16:21 <Walther> (n is a function)
07:16:52 <supki> fozworth: looks like it may fix the problem for you, but it has not been uploaded yet as far as I can see
07:17:05 <Kron> what's it trying to do, Walther?
07:17:12 <fozworth> yeah i couldn't tell if it was likely to be released as 0.8.0.2 or not
07:17:16 <fizbin> > let f=ap(==)$ap(.&.)negate in f 7
07:17:17 <lambdabot>  Ambiguous occurrence `.&.'
07:17:17 <lambdabot>  It could refer to either `Data.Bits..&.',
07:17:17 <lambdabot>                           imported from `Data.Bits' at L.hs:56:1-16
07:17:17 <lambdabot>                        or `Test.QuickCheck.Property..&.',
07:17:17 <lambdabot>                           imported from `Lambdabot.Plugin.Haskell.Eval.Truste...
07:17:28 <fizbin> lambdabot!
07:17:29 <mniip> :t \n -> show.n.map(map read.words).filter(notElem '#').lines
07:17:30 <lambdabot> (Read b1, Show b) => ([[b1]] -> b) -> String -> String
07:17:41 <mniip> hm
07:17:43 <Walther> Kron: this is a part of a code golfed program, and I'd like to make it even shorter :P
07:17:52 <Kron> I mean, still, what's it trying to do :P
07:17:55 <Walther> Kron: https://github.com/Walther/euler/blob/master/problem0067_golf.hs
07:17:55 <Kron> even in the golf
07:18:06 <Walther> Kron: Project Euler #67
07:18:08 <fizbin> > let (.&.)=Data.Bits..&.; f=ap(==)$ap(.&.)negate in f 7
07:18:09 <lambdabot>  <hint>:1:11: parse error on input `Data.Bits..&.'
07:18:17 <Kron> ok
07:18:23 <Walther> + parses out possible commented lines
07:18:24 <fizbin> Where do the parens go in Data.Bits..&. ?
07:18:27 <supki> fozworth: another option is to figure out the correct upper bound on statistics package for older criterion (< 0.7 or so) and install that alongside doctest
07:18:39 <Kron> I still don't know what interact does
07:18:41 <Kron> should look it up
07:18:52 <fizbin> > let (.&.)=Data.Bits.(.&.); f=ap(==)$ap(.&.)negate in f 7
07:18:54 <lambdabot>  Not in scope: data constructor `Data.Bits'
07:19:03 <fozworth> supki: alright i'll give that a shot. thanks for the help
07:19:54 * hackagebot base64-conduit 1.0.0.1 - Base64-encode and decode streams of bytes. (deprecated)  http://hackage.haskell.org/package/base64-conduit-1.0.0.1 (MichaelSnoyman)
07:19:56 * hackagebot conduit-combinators 0.2.3 - Commonly used conduit functions, for both chunked and unchunked data  http://hackage.haskell.org/package/conduit-combinators-0.2.3 (MichaelSnoyman)
07:20:18 <fizbin> > let (.&.)=(Data.Bits..&.); f=ap(==)$ap(.&.)negate in map (id&&&f) [1..10]
07:20:19 <lambdabot>  [(1,True),(2,True),(3,False),(4,True),(5,False),(6,False),(7,False),(8,True)...
07:21:21 <fizbin> > let (.&.)=(Data.Bits..&.); f=ap(==)$ap(.&.)(0-) in map (id&&&f) [1..10]
07:21:22 <lambdabot>  [(1,True),(2,True),(3,False),(4,True),(5,False),(6,False),(7,False),(8,True)...
07:22:02 <fizbin> Kron: "ap" is a shorter spelling of "<*>" and "(0-)" is a shorter spelling of "negate"
07:22:16 <Kron> true
07:22:42 <Kron> I mostly prefer to poke at symbol count golf than string length golf
07:22:58 <Kron> it's easier to talk about clever solutions without making things unreadable I guess
07:23:16 <Kron> geeze, sometimes haskell reminds me of spacechem in a really good way
07:23:56 <dmwit_> :t Data.Bits.popcount
07:23:56 <lambdabot>     Not in scope: `Data.Bits.popcount'
07:23:57 <lambdabot>     Perhaps you meant `Data.Bits.popCount' (imported from Data.Bits)
07:24:08 <fizbin> Thing is, "x .&. -x == x" is pretty short on symbols already.
07:24:19 <Kron> it is!
07:24:25 <Kron> I was just looking for a point free version
07:24:26 <dmwit_> :t Data.Bits.popCount
07:24:27 <lambdabot> Bits a => a -> Int
07:24:37 <fozworth> fizbin: my version is 6 characters shorter when fully golfed: let f x= -x.&.x==x
07:24:40 <dmwit_> > filter ((==1) . Data.Bits.popCount) [1..]
07:24:44 <lambdabot>  mueval-core: Time limit exceeded
07:24:59 <Kron> why can't you move -x to the left? will it fuse with = to form another operator?
07:25:04 <dmwit_> > map (((==1) . Data.Bits.popCount) &&& id) [1..]
07:25:05 <lambdabot>  [(True,1),(True,2),(False,3),(True,4),(False,5),(False,6),(False,7),(True,8)...
07:25:08 <fozworth> Kron: yeah
07:25:12 <Kron> gotcha
07:25:50 <fozworth> dmwit_: good find with popCount!
07:26:01 <dmwit_> > map (fromEnum . Data.Bits.popCount &&& id) [1..]
07:26:02 <lambdabot>  [(1,1),(1,2),(2,3),(1,4),(2,5),(2,6),(3,7),(1,8),(2,9),(2,10),(3,11),(2,12),...
07:26:10 <dmwit_> > map (fromEnum . Data.Bits.popCount &&& id) [1..] :: [(Bool, Int)]
07:26:11 <lambdabot>  Couldn't match type `GHC.Types.Bool' with `GHC.Types.Int'
07:26:11 <lambdabot>  Expected type: GHC.Types.Int -> GHC.Types.Bool
07:26:11 <lambdabot>    Actual type: GHC.Types.Int -> GHC.Types.Int
07:26:19 <dmwit_> > map (toEnum . Data.Bits.popCount &&& id) [1..] :: [(Bool, Int)]
07:26:20 <lambdabot>  [(True,1),(True,2),(*Exception: Prelude.Enum.Bool.toEnum: bad argument
07:26:27 <dmwit_> oh, right =P
07:27:10 <fozworth> it's 3 characters longer but much neater IMO: f=(1==).popCount
07:27:22 <fizbin> > let (.&.)=(Data.Bits..&.); f=((==0) .) . (ap (.&.) prev) in map (f &&& id) [1..10]
07:27:23 <lambdabot>  Not in scope: `prev'
07:27:23 <lambdabot>  Perhaps you meant one of these:
07:27:23 <lambdabot>    `pred' (imported from Prelude), `pre' (imported from Control.Lens)
07:27:35 <fizbin> > let (.&.)=(Data.Bits..&.); f=((==0) .) . (ap (.&.) pred) in map (f &&& id) [1..10]
07:27:36 <lambdabot>  No instance for (Data.Bits.Bits (a0 -> b0))
07:27:36 <lambdabot>    arising from a use of `e_10110'
07:27:36 <lambdabot>  Possible fix:
07:27:36 <lambdabot>    add an instance declaration for (Data.Bits.Bits (a0 -> b0))No instance for...
07:27:36 <lambdabot>    arising from a use of `M63569499241805993519774.show_M63569499241805993519...
07:28:06 <monochrom> I don't understand minimizing number of characters, as opposed to minimizing parse tree size
07:28:30 <fozworth> it's how code golf is played  ¯\_(ツ)_/¯
07:28:52 <merijn> Taste question, how would people layout multiple record constructors within the same datatype? http://lpaste.net/101557 any better suggestions?
07:28:56 <vivaldi> Hello, I have a function f1 x y. f1 adds some elements of y  to x. I need to create another function f2 a b which takes two lists and applies f1 to every element of a. How can I do that? "x" in f1 is tuple "y" is list. "a" in f2 is list of tuples and "b" is the same kind of list as "y"
07:29:18 <monochrom> but if you set out to minimizing number of characters, begin by renaming every multiple-letter name to a single code point, for example renaming popCount to 你
07:29:23 <dmwit> merijn: I would indent all the fields one more level.
07:29:36 <merijn> dmwit: Can you pastebin what you mean?
07:29:38 <dmwit> monochrom: renaming costs letters
07:30:08 <monochrom> use a customized Prelude
07:30:25 <merijn> monochrom: That's against codegolf rules/won't pass validation, probably
07:30:32 <fizbin> > let (.&.) = (Data.Bits..&.) ; f = (0==) . ap (.&.) pred in map (f &&& id) [1..]
07:30:33 <lambdabot>  [(True,1),(True,2),(False,3),(True,4),(False,5),(False,6),(False,7),(True,8)...
07:30:42 <dmwit> merijn: Three-space indentation is a violation of intergalactic law.
07:30:46 <dmwit> Also, annotated.
07:30:50 <monochrom> "codegulf rules" reminds me of "pirate rules"
07:31:00 <fizbin> Disadvantage: that formula false-positives on "0".
07:31:25 <fizbin> Is there a standard synonym for (0==) ?
07:31:32 <monochrom> no
07:31:41 <monochrom> apart from (==0) I guess
07:31:54 <dmwit> unsafeCoerce
07:32:42 <dmwit> monochrom: There's a code golf stack exchange, and every question is required to post their rules, because nobody can agree what a good set is.
07:32:54 <merijn> dmwit: Well, I was considering just 4 spaces, but then constructors don't line up with the type
07:33:08 <dmwit> Why should constructors line up with the type?
07:33:10 <monochrom> people really have too much spare time
07:33:18 <dmwit> Hell, why should anything on different indentation levels align?
07:33:38 <dmwit> If you have a convincing example, I want to see it and put it on dmwit.com/tabs
07:33:45 <merijn> dmwit: For prettiness
07:33:57 <merijn> dmwit: I had these examples as "acceptable" styles for non-records: http://lpaste.net/101557
07:34:13 <merijn> dmwit: I was turn between 4 space indent and lining up with the type in the last case
07:34:22 <monochrom> use a Euclidean plane and indent by sqrt pi + 2 spaces
07:34:25 <Walther> Hmm. I love using ghci as a terminal calculator, but how the heck can I essentially showHex $ 0xffbbffff + 0xffbbffff
07:34:35 <Walther> (It complains about no instance arising from a use of print)
07:34:49 <Walther> and just plain punching in the sum, i get out an integer instead of hex
07:34:59 <dmwit> showHex (0xf + 0xf) ""
07:35:42 <Walther> dmwit: thanks!
07:35:46 <supki> > hex # (0xffbbffff + 0xffbbffff)
07:35:48 <lambdabot>  "1ff77fffe"
07:35:54 <monochrom> the software crisis is due to programmers spending all their time playing on code golf websites instead of debugging
07:36:22 <fizbin> monochrom: Yeah, I somehow doubt that's a thing.
07:36:26 <dmwit> Yes, let's complain about how other people spend on IRC. That will get productive work done.
07:36:45 <dmwit> s/spend/spend their time/
07:36:54 <monochrom> I'm just joking!
07:36:59 <merijn> dmwit: I hope you can at least agree the last case is slightly more pleasing than moving everything 1 space to the right
07:37:06 <dmwit> Sorry, I'm just grumpy. =P
07:37:11 <Walther> supki: with that, i get "Not in scope: hex"
07:37:20 <merijn> dmwit: But I'm not convinced that's worth the bother, if I drop that I will change it for the record one too
07:37:25 <MagneticDuck> Walther: Hoogle ftw
07:37:27 <Welkin> code golf? haha
07:37:30 <fizbin> > map (ap (.&.) pred &&& id) [-5..]
07:37:31 <lambdabot>  Ambiguous occurrence `.&.'
07:37:32 <lambdabot>  It could refer to either `Data.Bits..&.',
07:37:32 <lambdabot>                           imported from `Data.Bits' at L.hs:56:1-16
07:37:32 <lambdabot>                        or `Test.QuickCheck.Property..&.',
07:37:32 <lambdabot>                           imported from `Lambdabot.Plugin.Haskell.Eval.Truste...
07:37:33 <Welkin> you mean coding challenge websites?
07:37:48 <fizbin> > map (ap (Data.Bits..&.) pred &&& id) [-5..]
07:37:49 <lambdabot>  [(-6,-5),(-8,-4),(-4,-3),(-4,-2),(-2,-1),(0,0),(0,1),(0,2),(2,3),(0,4),(4,5)...
07:37:56 <Walther> Welkin: Code golfing is solving a problem in as short piece of code as possible
07:38:05 <Walther> the less chars the better
07:38:13 <supki> Walther: oh, it's in Numeric.Lens
07:38:34 <Walther> supki: kk. Too bad this doesn't seem to be possible (trivially) in Prelude but requires import Numeric :/
07:38:36 <Welkin> so, perl programmers?
07:38:49 * dmwit nods at merijn
07:38:53 <Walther> Aaaanyway, i still stick with my opinion that ghci is the best terminal/CLI calculator :P
07:39:04 <ClarusCogitatio> reddit
07:39:06 <MagneticDuck> and that Haskell is by far the best language
07:39:06 <dmwit> merijn: I'm just messing with you, anyway. I've worked with people with weirder taste than 3-space indentation.
07:39:13 <Walther> MagneticDuck: it is!
07:39:15 <MagneticDuck> ofc
07:39:16 <Welkin> 3 spaces??
07:39:17 <monochrom> I too use ghci as calculator :)
07:39:22 <MagneticDuck> me three
07:39:27 <dmwit> ghci is a lousy terminal.
07:39:31 <Welkin> what is the standard haskell convention for code formatting anyway?
07:39:32 <edwardk> i had a 3 space phase once.
07:39:35 <dmwit> It's not a great shell, either.
07:39:36 <monochrom> in fact, http://www.vex.net/~trebla/haskell/calculator/Calculator.html
07:39:36 <merijn> dmwit: I'm trying to figure out what is optically pleasing and then make the autoindent follow it
07:39:39 <Welkin> is there an equivalent to Python's PEP 8?
07:39:40 <MagneticDuck> why in the world would I use another calculator when I already have an interactive terminal in a language I know well
07:39:43 <MagneticDuck> I mean, like, WHYY
07:39:54 <Taneb> I found myself in the habit of turning my computer of by writing :! sudo shutdown -h now
07:39:59 <monochrom> Welkin, the average Haskell programmer indents by 3.87 spaces
07:40:03 <merijn> Welkin: No one is suggesting 3 space indent as a general indent style
07:40:12 <Sornaensis> 4 space master race
07:40:27 <fozworth> Welkin: stylish-haskell and scan can enforce conventions
07:40:29 <Taneb> (I use 2 spaces)
07:40:31 <edwardk> i'm currently down to 2, eyeballing 1.
07:40:31 <merijn> Welkin: The question is whether using three spaces to line up constructors with type is pleasing here: http://lpaste.net/101557
07:40:32 <Welkin> I cringe when I read 2-space-indented code...
07:40:39 <Welkin> especially in C or Ruby...
07:40:41 <NikolajK> do the comma seperated conprehensions in a list comprehension commute? E.g. in concatMap f xs = [ y | x <- xs, y <- f x ]
07:40:43 <monochrom> and the average type class is associated with 4.77 laws
07:40:49 <dmwit> Are we really going to do an indentation argument?
07:40:53 <Welkin> haha
07:40:54 <merijn> Welkin: See the last case, there
07:40:56 <dmwit> I mean, I'm all for it.
07:40:58 <Walther> anyway, now that there's code golfing around, I could use some hints for https://github.com/Walther/euler/blob/master/problem0067_golf.hs
07:41:05 <Taneb> dmwit, clearly -6 is the best
07:41:10 <merijn> dmwit: I'm sorry, I was just wanting second opinions on aesthetics >.>
07:41:14 <edwardk> dmwit: hah. heading into #haskell-blah territory, definitely
07:41:29 <dmwit> NikolajK: no
07:41:34 <monochrom> I use 2 spaces. it is why the average Haskell programmer indents by 3.87 spaces instead of 3.89 spaces
07:41:42 <dmwit> NikolajK: The later bind varies faster.
07:42:04 <edwardk> monochrom: given your numbers we can extrapolate the number of haskellers. sweet
07:42:05 <merijn> edwardk: I saw you tweeting the unifying recursion schemes thing, but I'm still confused by this stuff and unclear what to study to get the required prerequisite knowledge. Any suggestions?
07:42:17 <NikolajK> dmwit: i.e. y <- f x is seen first?
07:42:23 <dmwit> NikolajK: (...and may refer to the variables bound in earlier bindings.)
07:42:29 <dmwit> NikolajK: I don't know. What does "seen" mean?
07:42:47 <NikolajK> what does "varies" mean? :)
07:43:00 <NikolajK> I mean is there an order of execution
07:43:02 <merijn> edwardk: I tried the bananas and lenses paper, but I might as well be reading it in Chinese :)
07:43:13 <dmwit> NikolajK: "varies" is about the result, not the order of execution.
07:43:20 <monochrom> tweets cannot possibly explain in detail :)
07:43:29 <merijn> monochrom: He tweeted a video from ICFP
07:43:32 <dmwit> NikolajK: It means that, when you look at the list in order, the variable bound second changes faster. For example:
07:43:38 <monochrom> ah, then nevermind
07:43:43 <edwardk> merijn: honestly? i don't find the stuff very useful. i did a bunch of work on them a few years back, but when i enapsulated them as distribution laws for (co)monad (transformers) I figured there was nothing left to say. Wu, Hinze & Gibbons's approach kind of puts the last nail in a coffin we thought was firmly shut. ;)
07:43:46 <dmwit> > [(x, y) | x <- [1..5], y <- "abcde"]
07:43:47 <lambdabot>  [(1,'a'),(1,'b'),(1,'c'),(1,'d'),(1,'e'),(2,'a'),(2,'b'),(2,'c'),(2,'d'),(2,...
07:43:48 <fizbin> Does the main module always need to begin with "module Main where ...", or is there some option you can use in cabal or ghc to rename which module is the main one?
07:44:18 <merijn> edwardk: Yes, but I don't understand the stuff you did either :D
07:44:22 <edwardk> well, they still hav some stuff to do on conjugate hylomorphisms, but from a practical standpoint i don't find non-trivial recursion schemes useful from a software engineering perspective
07:44:58 <dmwit> fizbin: -main-is ?
07:45:16 <merijn> edwardk: I just see these things and I'm trying to claw/find my way back into territory I understand so I can start reading from there. But I just get lost in a maze of cofree comonad coalgebra's all alike :)
07:45:23 <edwardk> they are an interesting way to play with the 'nature of recursion', but if you want to measure them by practicality or potential for practicality, they've been a rat-hole down which folks have thrown a lot of PhD students. ;)
07:45:52 <NikolajK> dimwit: okay, thx
07:46:03 <dmwit> NikolajK: Generally, asking about order of execution in Haskell means you haven't figured out the right question, yet.
07:46:12 <merijn> edwardk: tbh, I would be happy just to get to the point where I grok all the comonad/free/cofree/lenses stuff people keep throwing around
07:46:13 <dmwit> Not always. But often. It's a sign.
07:46:25 <fizbin> dmwit: No, main-is in my cabal file doesn't seem to work.
07:46:33 <merijn> edwardk: I just dunno where to start :)
07:46:47 <NikolajK> because of lazyness?
07:47:05 <edwardk> The material out there isn't terribly accessible. You can start with Erik Meijer's paper on bananas, lenses, etc. but you'll really need to go back to read a bunch of older stuff by Richard Bird to grok the formalism and style he uses. Maarten Fokkinga's dissertation is differently quirky, category theory through equational reasoning rather than diagrams, but also a decent entry point
07:47:06 <Welkin> I was using my python terminal thinking it was ghci...
07:47:11 <Sornaensis> lol
07:47:11 <Welkin> wondering why I was getting strange errors
07:47:18 <dmwit> fizbin: Define "doesn't work". Also, define "main-is in my cabal file".
07:47:28 <dmwit> fizbin: Have you read the Fine Manual?
07:47:31 <monochrom> I love equational reasoning
07:47:33 <Flonk> That feel when `read` yields an out of memory error.
07:47:45 <fizbin> dmwit: Which? The cabal user guide?
07:48:10 <edwardk> Both of those guys were students of Lambert Meertens. I believe Meertens is to blame for the sort of fetishization of greek/roman naming conventions in the recursion scheme world.
07:48:14 <dmwit> NikolajK: Well, roughly, yes. But "lazy" is just another execution order. The execution order of Haskell programs isn't really in the spec, so compilers are free to use other orders that aren't observably different.
07:48:15 <MagneticDuck> Flonk: out of memory?!?
07:48:30 <merijn> edwardk: Yeah, that was the impression I had too (material not being very accessible), I though after McBride I could tackle anything, but I was wrong :D
07:48:42 <edwardk> After those papers, the rabbit hole goes pretty deep. There is a bunch of stuff by Uustalu and Vene out there.
07:48:55 <fizbin> dmwit: I have a module which defines a symbol "main". This module is located at src/MyCompany/Whatever.hs. It is one of several modules-that-define-an-IO a-main-symbol in my project.
07:49:01 <edwardk> But they assume a lot of category theory background
07:49:07 <earthy> edwardk: that's a reasonably good guess ;)
07:49:13 <merijn> I'll check up on Fokkinga and Meertens first, then
07:49:21 <dmwit> fizbin: Seriously. Look at the Fine Manual. I'm staring at the sentence, and it was the first hit for "main-is". Yes, the cabal manual.
07:49:33 <Flonk> MagneticDuck: Haha yeah, it's kind of weird. I got a stack overflow before so I had to compile with -rtsopts, but I don't know what to do at this point
07:49:37 <earthy> (Lambert Meertens did a parser for latin back in the '60's, together with Koster)
07:49:42 <merijn> I start category theory too, but most of the material there is for mathematicians, not computer scientists :)
07:50:18 <dmwit> fizbin: I take it back. I shouldn't speak so roughly. There's a good chance I'm the one missing some subtlety.
07:50:25 <dmwit> fizbin: I apologize in advance, whether I'm right or not.
07:50:27 <edwardk> earthy: yeah and he has talks out there with titles like "Calculemus Igitur" http://www.kestrel.edu/home/people/meertens/diverse/calc.pdf
07:50:41 <dmwit> fizbin: But can you help me reproduce the problem, so I can verify for myself that the advice I'm giving is good or bad?
07:50:53 <earthy> edwardk: yeah. it's all a bit of good fun on his part though ;)
07:50:59 <edwardk> definitely
07:51:16 <edwardk> I do think though, that the net effect on the discipline is somewhat unfortunate
07:51:26 <fizbin> I think it's this: I'd like to not name my main module "Main". That is, I'd like to name it "module MyCompany.Whatever", as that matches its filename. I was asking if there were an option to make this doable.
07:52:02 <fizbin> Simply saying "main-is" and giving the filename without the contents of the file having "module Main where" near the top does not produce a working executable.
07:52:04 <edwardk> My only contribution to this space was noting that the distribution laws are the same as the way we build up monad transformers, so we can grow schemes accordingly by building composite disribution laws.
07:52:32 <earthy> edwardk: there is a good reason for it though. the terms he uses make it easier to distinguish that the term has a particular technical meaning
07:52:43 <edwardk> This bascally let me jus care about 'generalized catamorphisms' or 'generalized anamorphisms' parameterized by a comonad and monad respectively, and look for distribution laws.
07:52:57 * earthy nods
07:53:40 <monochrom> of recursion schemes I only care about 4 points: There is fold. There is unfold. Every program could be rewritten as a composition of a fold and an unfold (of theoretical interest only). Hinze's adding a left adjoint or right adjoint that solves the problem of "this ought to be a fold (or unfold) except for a technicality" i.e. adding a suitable functor to iron out that technicality
07:53:46 <edwardk> earthy: i understand the original motivation there, but once you get beyon the big 3 it jus becomes a memorization exercise, and the result is exclusionary, when the core results aren't that hard or exotic
07:54:06 <peteretep> Hinze has a rather fetching red lambda hoodie
07:54:13 <edwardk> monochrom++
07:54:15 <Flonk> MagneticDuck: Do you know how to throw more resources at a haskell program? +RTS -Hsize only seems to work up to 3 gigs
07:54:15 <fizbin> dmwit: So that's it. I'd like to have a haskell program whose entry point isn't the symbol "main" in the module Main, but rather the symbol "main" in some other module. The file you give to cabal's "main-is" option apparently must define the module Main and not some other module.
07:54:35 <earthy> edwardk: have you seen stuff in the social sciences?
07:55:08 <fizbin> I'd like this because the FP Complete IDE complains mightily about modules whose internal names don't match their filenames.
07:55:09 <earthy> edwardk: that is *all* memorization exercise, due to theories only being refered to by the name of the original author of a theory
07:55:16 <merijn> fizbin: Or you just define "module Main where; import Company.Whatever; main :: IO a; main = Company.Whatever.main"
07:55:32 <edwardk> earthy: well, i mention it here because the names cause people to assume all this stuff is some well known ancient lore from category theory they just somehow missed.
07:55:42 <MagneticDuck> Flonk: what are you making?
07:55:47 <MagneticDuck> O.o
07:55:56 <fizbin> merijn: I was under the impression that it wasn't possible to define more than one module per file.
07:55:58 <earthy> true enough. ;)
07:56:29 <dmwit> fizbin: Okay, I agree that cabal balks at this usage. I wonder: can you just leave the "module" line out of the file entirely? Will your IDE still balk at that?
07:56:32 <edwardk> an it is all rather unfortunate, because almost all haskellers already know all the monads and monad transformers that give rise to these schemes, but are scared off
07:56:41 <edwardk> er and
07:56:53 <MagneticDuck> ooh ancient category theory lore, sounds cool
07:56:57 <fizbin> merijn: Or are you saying I do that in a Main.hs and therefore ignore that there's more than one main in this project (what with tests and all)
07:57:12 <edwardk> for me the death knell of this whole area was when uustalu gave up on it ;)
07:57:56 <merijn> fizbin: It isn't possible, I was just saying add a redundant Main module that just reexports your existing main
07:58:08 <Flonk> MagneticDuck: I pulled a ton of porn titles from xnxx and want to procedurally generate new ones from this huge database
07:58:17 <MagneticDuck> ...
07:58:36 <MagneticDuck> interesting idewa
07:58:37 <dmwit> fizbin: I note that the following amusing clause WFM: "main-is: Test.hs; ghc-options: -main-is Test"
07:58:37 <Flonk> MagneticDuck: At the moment I want to read 17MB worth of [([T.Text],[(T.Text,Int)])], so I can see why theres a lot of recursion going on
07:58:39 <merijn> Flonk: Are you using String?
07:58:50 <merijn> ah, Text already
07:58:56 <Flonk> merijn: You talked me into Text a couple of days ago :P
07:59:00 <dmwit> fizbin: However you should probably try to think of something else; e.g. using lower-case names for your executables ;-)
07:59:25 <vivaldi> hello, I am asking again :) If I have a function that takes two lists and it adds some elements from second list to first one. This function works correctly. But I want to implement another function which takes a list of list as first element and second element is still a list. I want to implement this function using first function. How can I do that?
08:00:12 <dmwit> vivaldi: What have you tried? What went wrong? You can post snippets and explanations longer than one or two lines to a pastebin, such as
08:00:15 <dmwit> ?lpaste
08:00:15 <lambdabot> Haskell pastebin: http://lpaste.net/
08:00:24 <Welkin> Flonk, that would make a great interview question
08:01:20 <Flonk> Welkin: Yeah that's definitely going into my resume
08:02:48 <monochrom> new_function xx y = map (\x -> first_function x y) xx
08:04:16 <fizbin> Okay, my IDE totally craps out with multiple files without "module" lines.
08:04:30 <vivaldi> here is my problem, thanks http://lpaste.net/101560
08:04:37 <monochrom> poor IDE
08:04:58 * hackagebot twitter-conduit 0.0.2 - Twitter API package with conduit interface and Streaming API support.  http://hackage.haskell.org/package/twitter-conduit-0.0.2 (TakahiroHimura)
08:05:14 <MagneticDuck> fizbin: what are you using?"
08:05:21 <dmwit> vivaldi: Yes, see monochrom's suggestion.
08:05:37 <fizbin> MagneticDuck: The professional version of FP Complete's IDE.
08:05:47 <vivaldi> oh thank you!
08:06:01 <fizbin> MagneticDuck: Specifically, the self-hosted professional version.
08:06:06 <MagneticDuck> fizbin: FP complete... so, that thing exists.
08:06:11 <MagneticDuck> like, a web-based IDE and stuff
08:06:18 <MagneticDuck> sounded cool when I read about it
08:06:44 <MagneticDuck> still sounds cool, but I'm definitely not going to drop my current setup (vim :D)
08:07:08 <Welkin> I always wonder why anyone uses anything but emacs/vim
08:07:35 <Welkin> although I am still trying to get haskell-mode formatting to work nicely
08:07:38 <Welkin> with indentation, that is
08:08:11 <dmwit> I like vim. But I don't often wonder why people would choose something else. It doesn't surprise me that it would be possible for somebody to make something nice in the last thirty years.
08:08:40 <MagneticDuck> supposedly fp complete is nice because there's no way it can go wrong
08:08:44 <geekosaur> *shrug* it's all about what you're comfortable with
08:08:47 <MagneticDuck> just open your web browser, and code
08:09:00 <fizbin> MagneticDuck: hahahahaha
08:09:02 <MagneticDuck> supposedly fp complete sucks because you're coding in your web browser :D
08:09:32 <MagneticDuck> =P
08:10:09 <MagneticDuck> btw can anybody figure out why https://github.com/MagneticDuck/PixelGame this project isn't generating any haddock documentation when I cabal haddock it?
08:10:30 <fizbin> There's plenty that can go wrong with it. That said, they've made the best IDE-in-a-browser I think I've ever seen. The downside... well, I don't think I'm prepared to talk about that properly because I'm right now in the middle of a fight with it.
08:10:54 <MagneticDuck> sounds fun
08:11:24 <MagneticDuck> anyway, anybody have any ideas on my haddock mess?
08:11:34 <merijn> dmwit: I just wish someone would create a more easily hackable vim, it's insides are such a gory mess :(
08:11:54 <MagneticDuck> never go inside vim
08:12:05 <MagneticDuck> ouch
08:12:10 <geekosaur> the questions are (a) does it have reasonable support for coding (b) does it perform reasonably well (c) does it work the way you do
08:12:12 <monochrom> I sometimes type directly into lpaste. that should also count as coding in browser.
08:12:20 <geekosaur> I suspect (c) is what really trips most people
08:12:44 <MagneticDuck> guys can you stop discussing FP complete and figure out why I don't understand haddock >:0
08:13:02 <monochrom> yes, but you need to upload your brain for a full analysis
08:13:03 <geekosaur> dirty secret: nobody else understands it either :p
08:13:21 <monochrom> I understand haddock
08:13:41 <MagneticDuck> monochrom: my brain doesn't have any haddock documentation
08:13:44 <MagneticDuck> it's just a bunch of chemicals
08:13:45 <dmwit> MagneticDuck: Where is EuclideanThings package?
08:13:48 <monochrom> perhaps I am the one to upload my brain for your full analysis
08:13:49 <MagneticDuck> EXTREMELY poorly documented
08:13:58 <MagneticDuck> dmwit: silly geometry library I made a while ago
08:14:30 <MagneticDuck> not even the best scientists in the world can figure out what's going on in my brain
08:14:37 <MagneticDuck> god didn't document anyway
08:14:39 <MagneticDuck> anything*
08:14:42 * dmwit tries again
08:14:44 <dmwit> MagneticDuck: Where is EuclideanThings package?
08:14:55 <MagneticDuck> dmwit: on my github, but I think it's out of date or something
08:15:00 * hackagebot creatur 5.2.5 - Framework for artificial life experiments.  http://hackage.haskell.org/package/creatur-5.2.5 (AmyDeBuitleir)
08:15:01 <MagneticDuck> you don't need to know what EuclideanThings is
08:15:18 <MagneticDuck> (it doesn't have documentation)
08:15:24 <dmwit> MagneticDuck: If you want me to reproduce your problem, I do.
08:15:26 <monochrom> but I need your brain for experiments^W analysis
08:15:33 <dmwit> MagneticDuck: And I don't see a EuclideanThings repo on your account.
08:15:46 <MagneticDuck> dmwit: oh..
08:16:01 <MagneticDuck> dmwit: https://github.com/MagneticDuck/EuclieanThings
08:16:11 <MagneticDuck> I'll upload the newest version in case that doesn't compile / isn't compatible
08:16:27 <dmwit> That typo is egregious.
08:16:52 <MagneticDuck> yes I know :D
08:16:57 <merijn> Isn't it inefficient that Parsec doesn't have combinators of like "manyTill" that don't return anything? That would save building up a list of stuff in memory
08:17:04 <MagneticDuck> at first it was just a typo but then it because an identity
08:17:11 <MagneticDuck> dmwit: xDD
08:17:17 <MagneticDuck> okay, I updated it
08:17:41 <MagneticDuck> oh btw, it's a heaping mess.
08:17:46 <MagneticDuck> steaming*
08:18:07 <dmwit> I'm not really planning on looking at it or using it.
08:18:14 <MagneticDuck> good
08:18:43 <spacekitteh> so, i decided to run an experiment. this girl came to me asking me how to program. i pointed her towards LYAH. let's see how this goes :D
08:19:02 <merijn> oh, wait skipMany...I fail
08:19:18 <MagneticDuck> spacekitteh: you're trying to teach a random person haskell?
08:19:21 <MagneticDuck> have fun
08:19:23 <MagneticDuck> I've tried it a few times
08:19:28 <MagneticDuck> ... I didn't really get anywhere
08:19:30 <monochrom> also help her set up ghc.
08:19:35 <spacekitteh> MagneticDuck: she doesn't know *any* language
08:19:45 <MagneticDuck> spacekitteh: as I said, have fun.
08:19:49 <spacekitteh> my hypothesis is that if you learn haskell from the start, it's not as hard because you don't have to unlearn stuff
08:20:02 <spacekitteh> monochrom: yeah
08:20:23 <MagneticDuck> spacekitteh: that might be true, but if you have no idea what a programming language is, you're also going to have to teach her everything that you probably already accepted as obvious when you started learning haskell
08:20:38 <MagneticDuck> like what a compiler is, how to read syntax errors, how to code.
08:20:40 <spacekitteh> MagneticDuck: i dunno, she's responding well to LYAH
08:20:46 <MagneticDuck> well have fun :D
08:21:04 <spacekitteh> :D
08:21:16 <MagneticDuck> of course my arguments aren't really specific to haskell, they're really just in general why it can be hard to teach a first programming language
08:21:29 <spacekitteh> heh, yeah
08:21:49 <peteretep> Also, if you fail out of learning Ruby, you've learned enough basics of many other languages that it'll be easier the next time youdecide to learn a language
08:21:50 <monochrom> I disagree. when I first learned programming (it was BASIC), I did not know, and did not need to know, anything MagneticDuck says.
08:22:17 <monochrom> except for "how to read error messages". the error message was always "SYNTAX ERROR". I knew how to read it.
08:23:04 <MagneticDuck> monochrom: =P
08:23:40 * merijn gets off monochrom's lawn
08:23:51 <MagneticDuck> but like, how to think in like a coder. It takes a bit of learning, and learning a "hard" or "unintuitive" language doesn't help
08:24:07 <monochrom> I have no lawn. you need not get off anything.
08:24:12 <spacekitteh> i think it's only hard/unintuitive if you're coming from imperitive languages
08:24:17 <MagneticDuck> spacekitteh: hmm
08:24:30 <spacekitteh> MagneticDuck: that's my hypothesis
08:24:45 <MagneticDuck> well experimentation is the only way to solve this debate
08:24:59 <spacekitteh> yup
08:25:06 <merijn> MagneticDuck: The hypothesis of me is that you can't each people how to think like a coder
08:25:10 <spacekitteh> plus she totally has a crush on me so she's likely to take my advicwe
08:25:22 <merijn> MagneticDuck: Either they already can, or they can't
08:25:44 <merijn> MagneticDuck: If it can be taught I haven't found a reproducible way to do so
08:25:55 <MagneticDuck> hm.
08:26:04 <MagneticDuck> so you're saying that some people really just can't be coders?
08:26:07 <merijn> The only trick is to avoid confusing the present instincts by badly designed programming languages
08:26:20 <merijn> MagneticDuck: I'm pretty sure that there's people that can't be coders
08:26:23 <MagneticDuck> monochrom: any news on my problem? :<
08:26:40 <MagneticDuck> well I'm sure there's some desposition for everything
08:26:42 <monochrom> I don't know whether I qualify as "I can think like a coder without learning". I think my born ability was: "I can entertain any well-presented formal system"
08:26:59 <MagneticDuck> math, coding, rowing, artisan reed basket making
08:27:45 <merijn> I'm pretty sure the disposition for math and coding are mostly the same
08:28:06 <MagneticDuck> in my opinion, schools (math class here, for example) aren't very conductive to coder-like thinking
08:28:10 <MagneticDuck> (in 10th grade)
08:28:15 <merijn> monochrom: Right, I would argue that's what coders need, though. The ability to understand and creatively play with formal systems
08:28:22 <merijn> MagneticDuck: Agreed
08:28:53 <MagneticDuck> you'd think that we'd deal with rigour and the magic of formal systems...
08:29:10 <MagneticDuck> but all we end up learning is how to do a series of flat, trivial computations to get through the test
08:29:35 <fizbin> Huh. If I want to work only in my IDE, it works fine. My IDE is happy to run a non-Main module as an executable and show me the output. If I want to work just in cabal, I'm fine: I can remove the "module" line from files that define "main", and I'm good. It's my stupid insistence that I be able to do both that causes pain.
08:29:51 <MagneticDuck> it's the worst possible mix of "intuitive" thinking and trivial, boring "rigour"
08:29:52 <monochrom> I paid no respect to normal school homework, FWIW. I didn't care about marks. I didn't play their game.
08:30:03 <MagneticDuck> me neither
08:30:21 <fizbin> I played their game once I discovered how easy it was to win.
08:30:23 <MagneticDuck> I study for philosophy, portugese (learning the language here in portugal) and not much else
08:30:41 <MagneticDuck> monochrom: anyway any idea on my haddock mess?
08:30:53 <fizbin> That was fun. Useless in the long term, sure, but it gave me something to do at the time.
08:31:22 <monochrom> sorry, I don't
08:31:43 <MagneticDuck> hm :/
08:31:55 <MagneticDuck> well I'll check out well-formed haddock projects and see what I'm doing differently
08:32:30 <monochrom> the school homework scoring game was not easy for me. it was Hong Kong homework. crazy trig identities and crazy integrals. I saw no point playing, and I could not win anyway.
08:32:31 <czro_> I'm trying to run some code with "cabal test". How do I pass "+rts -N" so the code that is being tested can run in parallel?
08:33:43 <MagneticDuck> monochrom: here we're not even doing hard math
08:33:44 <monochrom> the computer study class, I won beautifully of course. it was good programming and good background history
08:33:56 <MagneticDuck> 10th grade, we're learning about... the absolute value function
08:34:03 <monochrom> yeah, in Canada or US, I would be able to win easily
08:34:10 <MagneticDuck> I'm in portugal
08:34:50 <narendraj9> How can I extract a number from a Haskell String?
08:34:58 <MagneticDuck> narendraj9: read
08:35:01 <MagneticDuck> @type read
08:35:01 * hackagebot creatur 5.2.6 - Framework for artificial life experiments.  http://hackage.haskell.org/package/creatur-5.2.6 (AmyDeBuitleir)
08:35:02 <lambdabot> Read a => String -> a
08:35:10 <dv-> > readMaybe "1" :: Maybe Int
08:35:10 <joelteon> > read "123" :: Int
08:35:11 <lambdabot>  Not in scope: `readMaybe'
08:35:11 <lambdabot>  can't find file: L.hs
08:35:18 <joelteon> ok
08:35:19 <joelteon> > read "123" :: Int
08:35:21 <lambdabot>  123
08:35:21 <dv-> > Text.Read.readMaybe "1" :: Maybe Int
08:35:22 <lambdabot>  Not in scope: `Text.Read.readMaybe'
08:35:25 <dv-> hm
08:35:50 <dmwit> head . fromEnum (not a serious suggestion)
08:36:07 <dv-> in any case you should use readMaybe from Text.Read if your ghc has it
08:36:15 <narendraj9> okay. I had found the answer on SO just now but asking here is always fun.
08:36:38 <monochrom> but don't get me wrong, I did care about the math class. whenever there were opportunities like "but why is log_b x = log x / log b true?" I jumped at them. in other words I liked to learn the ideas but hated to do yet another ugly identity with tricks.
08:37:17 <monochrom> I think, in fact, the class didn't show how to prove that one, and I proved it for myself
08:38:46 <MagneticDuck> monochrom: in class today everybody was graphing the super-interesting function abs(x) on their magical graphic calculators, so I had fun graphing a function of the form sqrt(x^2 + <small number>) + <signal noise made with sine waves at different frequencies> and complained to the teacher that my calculator was "funny"
08:38:55 <MagneticDuck> :D
08:39:15 <monochrom> you are naughty
08:39:32 <Kron> hahaha
08:39:57 <MagneticDuck> hehe
08:40:49 <Cale> monochrom: It seems to me that logarithms are taught in an especially circular fashion
08:41:52 <dmwit> MagneticDuck: Well, I finally got all your dependencies installed.
08:42:13 <MagneticDuck> here comes big wolfram alpha link with a recreation of my math class prank
08:42:14 <Cale> Or perhaps not always circular, but they tend to define log_b x as the y such that b^y = x, but then fail to define b^y in such a way that this makes any kind of sense.
08:42:16 <MagneticDuck> http://www.wolframalpha.com/input/?i=sqrt%28x^2+%2B+0.01%29+%2B+0.01*sin%284*pi*x%29+%2B+0.02*sin%288*pi*x%29+%2B+0.01*sin%289*pi*x%29+for+x+from+-1+to+1
08:42:18 <dmwit> MagneticDuck: And now I get a message saying G.UI.GLUT.Raw.Functions is a hidden module in the GLUT package.
08:42:27 <MagneticDuck> dmwit: thanks :D
08:42:31 <MagneticDuck> but, huh. That's funny.
08:42:49 <Cale> (and indeed, if you're doing things the right way around, it's usually defined in terms of the natural logarithm and exponential)
08:43:23 <monochrom> one could say, "there are holes in their definition" :)
08:43:26 <Cale> yeah
08:44:10 <kuribas> Nice, I managed to annotate a function with it's type by using GADTs and typeclasses.
08:44:18 <Walther> Hmmmm. Could someone help me with how to use folds? I wonder if this could be shortened (golfed) with a fold instead of using zipWith:s:  z=zipWith;z max(z(+)x y++[0])(z(+)(0:x)y)
08:44:25 <Cale> I really don't understand why they want to teach logarithms before any concepts from calculus.
08:44:57 <Cale> Walther: Rather than forcing everyone to figure out what that is, perhaps you could offer an un-golfed version?
08:45:50 <Walther> Cale: Sorry, not intending to "force" anything to anyone.
08:46:21 <Cale> Well, it's cool, it's just that it's really unclear what you're trying to compute :)
08:46:34 <Walther> Project Euler #67, https://github.com/Walther/euler/blob/master/problem0067_golf.hs
08:47:19 <fizbin> dmwit: Resolution. I used {-# LANGUAGE CPP #-} to make the "module" line in main-defining files appear to the IDE environment, but not the external cabal environment.
08:47:38 <kuribas> So I can do (addType ((+) :: Int -> Int -> Int)) ==> (TypedVal (FunType IntType (FunType IntType IntType)) (+))
08:48:43 <kuribas> Didn't expect it to work, but it does :)
08:48:44 <Walther> Cale: The other thing I suspect could possibly be shortened is the "show.n.map(map read.words).filter(notElem '#')" part
08:50:35 <MagneticDuck> MM MY WONDERFUL HADDOCK DOCUMENTATION IS WORKING
08:50:40 <MagneticDuck> haddock is nice
08:54:45 <Cale> Walther: Well, if you foldr1 this thing over the triangle, you get the solution: extendPaths xs (t:ts) = zipWith max (zipWith (+) xs ts) (zipWith (+) xs (t:ts))
08:55:03 * hackagebot creatur 5.2.7 - Framework for artificial life experiments.  http://hackage.haskell.org/package/creatur-5.2.7 (AmyDeBuitleir)
08:56:06 <Walther> Cale: Hmmm. Sadly, doesn't likely reduce chars then :/
08:56:25 <Walther> as with my current recursive call i use less chars than using a folrd1
08:56:50 <Walther> I was just thinking if one could use a fold in *place* of the zipWiths
08:56:56 * Walther shrugs
08:58:03 <kstt> Hi. I have a list of values of various types, but all types are instances of a common typeclass. I want to map over them to apply a function from this typeclass. What is the most direct way please ?
08:58:18 <kstt> Do I really have to hand-declare an existential type ?
08:58:51 <kstt> Note that the result will be homogeneous, single type
08:58:53 <merijn> kstt: How can you have a "list of values of various types" without already having wrapped them with an existential?
08:59:29 <czro_> Anyone know how to pass runtime options to "cabal test"?
08:59:32 <kstt> I have them at hand, literaly declared (a set of GTK widgets that I want to pack in a box container).
08:59:45 <MagneticDuck> what's a good name for the opposite of a constructor?
09:00:13 <kstt> merijn: the list literal, indeed, is illegal.
09:00:15 <quicksilver> not only do you have to wrap them, but the amount of work required to do so is essentially the same as just calling hte method directly, kstt
09:00:26 <quicksilver> this is an expressivity gap
09:00:27 <Fuuzetsu> MagneticDuck: destructor ;P
09:00:40 <quicksilver> [foo a, foo b, foo c] can be legal in contexts that map foo [a,b,c] is not
09:00:50 <quicksilver> and there is essentially not a solution to that as far as I know.
09:01:11 <merijn> quicksilver: Also known as: Dammit, when will someone make ImpredicativeTypes work for me?! :(
09:01:24 <quicksilver> you could write map foo [mkE a, mkE b, mkE c]
09:01:35 <kstt> quicksilver: merijn: I must say that I hate this existential pattern, and have never needed it so far. But here, the use case is quiet clear.
09:01:36 <MagneticDuck> no seriously what's the standard name for the opposite of a constructor xD
09:01:36 <MagneticDuck> I need to know
09:01:42 <quicksilver> but then that's "essentially" as much work as [foo a, foo b, foo c]
09:01:50 <quicksilver> MagneticDuck: accessor
09:01:53 <merijn> ImpredicativeTypes would be a solution, but currently it's broken and SPJ has put it on hold until someone volunteers to work on designing a good implementation
09:01:54 <MagneticDuck> wonderful
09:02:05 <quicksilver> MagneticDuck: or, catamorphism
09:02:10 <MagneticDuck> ooh that sounds cooler
09:02:12 <quicksilver> depending which kind of 'opposite' you meant
09:02:42 <quicksilver> runWriterT is an accessor and it's the 'opposite' to the constructor WriterT
09:02:45 <MagneticDuck> oh I see
09:02:49 <MagneticDuck> yeah I need accessor
09:02:55 <quicksilver> maybe is a catamorphism and it's the 'opposite' to Just and Nothin.
09:03:39 <MagneticDuck> is the composition of a constructor and a catamorphism always identity?
09:03:48 <MagneticDuck> I hadn't heard of the term, reading wikipedia
09:03:50 <MagneticDuck> it isn't, is it
09:04:14 <kstt> quicksilver, merijn: I have declared (literaly, in the code), 10 GTK+ widgets of various types. Now I want to pack them in a box. For that, I must run "boxPack theBox theWidget SomeOption1 SomeOption2". I can copy-and-past 10 lines of "boxPack ...", but franckly, that hurts. I'd like to list off widgets in a collections, and mapM_ over it to call "boxPack ..." on each element.
09:04:17 <MagneticDuck> alright it's "Accessor" for me
09:04:51 <merijn> kstt: Template Haskell ;)
09:04:57 <Cale> Walther: z = zipWith;x l a@(t:r)=let f=z(+)l in z max(f r)(f a);main=interact$show.foldr1 x.map(map read.words).lines
09:05:14 <kstt> merijn: ugly VS uglier ;)
09:05:23 <Cale> and actually, we don't need that let
09:05:30 <Cale> er, hmm
09:05:39 <Cale> well, maybe we do
09:06:01 <kstt> merijn: I will have a look at the impredicative extension, just out of curiosity.
09:06:25 <kstt> But I admit it is a required mostly because the GTK model maps poorly to haskell.
09:06:56 <merijn> kstt: Be warned, it's currently brokenish
09:07:17 <merijn> kstt: Essentially, it's supposed to allow types like [forall a . a]
09:07:18 <kstt> I will not use it, just read the rational and proposal.
09:07:26 <merijn> or "Maybe (forall a . a)"
09:07:31 <Cale> Walther: z=zipWith;s=z(+);x l a@(t:r)=z max(s l r)(s l a);main=interact$show.foldr1 x.map(map read.words).lines
09:07:51 <MagneticDuck> oh boy, I can't remember any words; what do you call an inversible function whos domain is equal to its range?
09:08:21 <emilguliyev> bijection?
09:08:29 <MagneticDuck> I'm asking questions like I'm doing some sort of really easy haskell crossword puzzle :D (I'm trying to find good names for various things in my current project)
09:08:46 <MagneticDuck> cool that's it
09:08:52 <Cale> MagneticDuck: Or permutation
09:09:06 <emilguliyev> unless the domain is infinite
09:09:13 <Cale> What?
09:09:23 <Cale> Bijections are exactly the invertible functions
09:09:28 <emilguliyev> you don't really call bijections on infinite sets permutations
09:09:35 <Cale> You don't?
09:09:46 <emilguliyev> you... do?
09:09:56 <joelteon> :t asAppliedTo
09:09:57 <lambdabot> (a -> b) -> a -> a -> b
09:10:27 <Cale> I would, anyway :)
09:10:40 <Cale> A permutation of S is a bijection S -> S
09:10:44 <MagneticDuck> now, a "transformer" isn't really just something that maps values in a set to other values in the same set... what exactly does it mean again?
09:10:46 <kstt> merijn: ImpredicativeTypes has a very large scope. I'm glad it is on hold :)
09:10:48 <MagneticDuck> does it really mean anything in particular?
09:11:08 <MagneticDuck> uhm, it has a few meanings doesn't it
09:11:34 <Cale> MagneticDuck: In what context?
09:11:39 <MagneticDuck> lol sometimes searching google for these terms is suprisingly difficult until you come up with the right search term
09:12:13 <MagneticDuck> Cale: I'm not sure :D
09:12:25 <Cale> Well, where are you reading the word "transformer"?
09:13:13 <MagneticDuck> in my code; it's a section of the exports of a module, methods that have (<data type> -> <data type>) as their type after being applied to sufficiently many values
09:13:22 <MagneticDuck> (the same data type)
09:15:10 <MagneticDuck> now, you wouldn't call a function of type a -> a -> a a "combinator" unless the result is truely more "complicated" or in some way of a different structure of its parameters right?
09:16:21 <Yuu_chan> Is it possible (with some extension) to write this typedef: "type M2 a = Maybe (Maybe 2)" in a "point-free" style, without explicit 'a'?
09:16:24 <Cale> Combinator has two meanings. There's a technical definition, and then there's the common usage which is not much different in sense than "function".
09:16:35 <Yuu_chan> *Maybe (Maybe a)
09:16:47 <MagneticDuck> I found http://www.haskell.org/haskellwiki/Combinator, but it doesn't really talk about the restriction of the second sense
09:16:48 <Cale> Yuu_chan: no
09:16:51 <geekosaur> Yuu_chan, not generally, no
09:16:58 <MagneticDuck> "more complicated"? So, (+) is not an example of a combinator I guess?
09:17:20 <Cale> MagneticDuck: Why not?
09:17:32 <MagneticDuck> okay!
09:17:43 <MagneticDuck> it's interesting how "why not?" can be an answer
09:17:53 <Cale> The point about the second sense is the manner in which you're thinking about the entire library
09:17:53 <geekosaur> type lambdas are not decidable, so Haskell places restrictions on how you declare types / type synonyms and on how you use them so that it doesn't have to deal with type lambdas in general
09:19:01 <Yuu_chan> geekosaur: I just wondered, because Haskell has such a large bunch of different extensions, some of them involving some kind of undecidability...
09:19:12 <Cale> It's not a local property of the individual functions involved, but that the library as a whole defines a bunch of primitives and means of combination to build up descriptions of complicated problems from descriptions of simple ones, and describe the solutions to those problems in terms of the solutions to the parts.
09:20:01 <MagneticDuck> I see
09:20:02 <Cale> Of course, you can look at the basic operations on numbers in that way as well.
09:20:04 <geekosaur> Yuu_chan, it does, but type lambdas are something that are specifically avoided
09:20:12 <Cale> (Though it's a little uncommon)
09:20:41 <Yuu_chan> geekosaur: will you tell about other languages?
09:20:44 <geekosaur> they actually exist at the level of GHC "core" and there has been some thought about finding a way to expose them at the level of Haskell code, but nothing has been done as yet as I understand it
09:20:51 <geekosaur> because it screws with type inference
09:21:46 <Yuu_chan> geekosaur: thanks for a definitive explanation
09:21:51 <geekosaur> and type unification in general
09:22:33 <pearson> hello, have a question regarding ghci. Hopefully someone may be able to answer.
09:22:47 <geekosaur> ask your question; if someone can answer, they will
09:22:48 <Yuu_chan> pearson: Likely!
09:22:55 <MagneticDuck> I always wondered why nobody felt the urge to make the type-world as "powerful" as the "value-world", and then generalise that up the line to all of the other worlds (what do you call the world higher than "kinds"?)
09:23:15 <MagneticDuck> but then I thought... is it even possible to generalise that chain, giving every level as much power as the level below it?
09:23:43 <pearson> How can I access hidden packages like "haskell 98-2.0.0.2"?  I am working through the yet another haskell tutorial and I never encountered this problem before
09:23:44 <Cale> Yuu_chan: You can generally look at most of the extensions to Haskell in recent years as moving the language in the direction of dependently typed systems while trying not to compromise on type inference for some core part of the language (i.e. pretty much the stuff which HM can infer types for)
09:23:44 <geekosaur> Tim Sheard's Omega is a poke at that
09:24:22 <geekosaur> as I understand it there are other approaches, and it's an area of active research
09:24:44 <MagneticDuck> sounds fun
09:24:45 <Cale> Generally the hope is that we can introduce fancier types while only requiring explicit signatures for the specific points in the program where we use them.
09:25:06 <Cale> MagneticDuck: See also Coq, Agda, Idris
09:25:12 <geekosaur> pearson: specifically for haskell98 you would need to tell the compiler to run in haskell 98 mode; it's not enough to just unhide the package
09:25:27 <Hodapp> mmmm, Coq.
09:25:39 <Hodapp> I'll learn Agda and Idris eventually.
09:25:44 <pearson> geekosair: how do I do that with ghci?
09:25:48 <geekosaur> pearson: later versions of the Haskell standard moved to using hierarchical modules, so the preferred solution is to change modules like List to Data.List.
09:26:03 <Yuu_chan> MagneticDuck: afair, they have those infinite line of higher-order "types", such as Values have Types, Types have Types2, Types2 have Types3 etc.
09:26:04 <MagneticDuck> Cale: yes, but what about taking it even further, my question is essentially "is it possible to generalise that kind of leap from values -> types to all of the higher levels of the ... well, whatever sequence starts with values, types, and kind"
09:26:17 <geekosaur> there is more to it than that though, since (for example) the old System module is now divided up into a bunch of submodules
09:26:25 <MagneticDuck> Yuu_chan: but do they all have equal "power"?
09:26:32 <geekosaur> ghci -XHaskell98
09:26:34 <Cale> MagneticDuck: Well, dependently typed languages subvert this, by blurring the distinction between types and terms.
09:26:43 <geekosaur> this will probably get you into other problems though
09:26:50 <MagneticDuck> hm..
09:27:08 <pearson> geekosaur: okay, so it might just be that yaht is a bit outdated, thanks, I'll try something.
09:27:12 <geekosaur> yes
09:27:43 <Yuu_chan> I started to scratch Idris recently, unfortunately I don't have enough time and motivation, but the language looks VERY intriguing
09:27:49 <geekosaur> unfortunately nobody's been updating the tutorials, and nobody can find the authors of some of them (notably LYAH :( )
09:28:32 <pearson> geekosaur: I just want to learn a programming language my university  teaches in the first semester. And I am still learning to understand haskell...
09:29:03 <Cale> I generally recommend looking at all three of those languages if you're going to look at one of them.
09:29:41 <geekosaur> LYAH is the tutorial we mostly recommend these days. It's still got some outdated stuff (notably it predates the reorganization of the MTL so some uses of "State" need to be changed to "state", likewise Writer and Reader)
09:29:44 <Yuu_chan> Cale: those three dependently-typed languages?
09:29:46 <Cale> yeah
09:29:54 <geekosaur> but it's closer and generally better than the older tutorials
09:29:59 <geekosaur> @where lyah
09:29:59 <lambdabot> http://www.learnyouahaskell.com/
09:30:08 <Cale> They share a lot of ideas, and there are few enough resources as of yet for learning about dependently typed programming that you'll be better off if you learn them all at the same time, to some extent. :)
09:30:15 <Yuu_chan> Indeed, that was very hard to choose one for the beginning
09:32:23 <pearson> welp, then lyah it is. Is there any  exercises I could try my luck with? I need to learn how to get along with it, before I can try something bigger..
09:32:52 <pearson> and with bigger I mean bigger than basic foundations
09:32:52 <geekosaur> lyah includes exercises
09:33:22 <pearson> geekosaur: really? didn't saw them.. meh, gonna take a look
09:33:26 <geekosaur> beyond that... many people try to use project euler, but it's something of a bad idea because it's more about mathematical thinking than programming language expertise
09:33:42 <Yuu_chan> @where 99 haskell
09:33:43 <lambdabot> http://www.haskell.org/haskellwiki/H-99:_Ninety-Nine_Haskell_Problems
09:34:18 <Cale> geekosaur: Though, most of the Euler problems are unsolvable without a computer
09:34:21 <Yuu_chan> ↑ a lot of exercises :)
09:34:31 <MagneticDuck> boy, all these darn singularities and strange behaviour of Doubles forces computational geometry libraries to have all kinds of catches
09:35:00 <pearson> thanks Yuu_chan and geekosaur. Last question though.
09:35:19 <pearson> How do I make my compiler as colorful as in lyah?
09:35:22 <geekosaur> Cale, yes, but the assumption is you know your language and are working out how to think math, not that you're trying to gain proficiency with your language
09:35:23 <MagneticDuck> Cale: I do remember reading a lot of solutions in the project being written by people who used some thinking, a calculator, and paper instead of a programming language =P
09:35:26 <jowens> geekosaur: I've found Project Euler to be really useful.
09:35:33 <jowens> in terms of learning Haskell
09:35:42 <MagneticDuck> geekosaur: uhm, I always thought it was more for learning programming and math
09:35:48 <Cale> MagneticDuck: Well, some of them are doable that way, but tedious
09:35:51 <geekosaur> you *can* use PE for that, but it's not directly helpful because it's more focused on learning math
09:35:57 <geekosaur> rather than learning programming
09:36:04 <Cale> But yeah, I guess so
09:36:08 <jowens> just because a new Haskell programmer can concentrate on some of the interesting parts of Haskell, specifically the functional programming subset
09:36:14 <Cale> It also kind of depends on what part you already know
09:36:19 <jowens> without having to worry about lots of other Haskell aspects
09:36:28 <MagneticDuck> if you already are fairly proficient you're probably not going to learn a lot more though
09:36:32 <MagneticDuck> (in programming)
09:36:40 <Cale> For me, PE problems seem mostly about how to coerce a computer into coming up with the solution for you.
09:36:55 <Yuu_chan> I agree, Euler problems are more like "two hours of brainstorming and five minutes of coding", the latter is especially valid for Hs
09:37:13 <tdammers> MagneticDuck: I've seen people who are officially "fairly proficient" in programming, but their brains still explode when they first try to understand Haskell
09:37:19 <tdammers> MagneticDuck: all pretty relative, I guess
09:37:25 <Cale> There is some mathematics involved of course, if you don't know basic number theory, you're going to be frustrated
09:38:30 <Cale> I also can't claim to have done most of them, since there's only so much time I can spend writing programs to generate a number nobody actually cares about before I get bored :)
09:39:07 <Cale> It actually really upsets me that the solution to every PE problem seems to be a number
09:40:19 <Yuu_chan> There were some interesting more "domain-specified" PE problems however, such as pathfinding, poker hands or Sudoku solving :)
09:40:53 <jowens> it's also very good for understanding the power of lazy evaluation
09:41:11 <jowens> lots of "generate an infinite sequence, take the nth one you find"
09:41:33 <Nafai> jowens: Haskell made beautiful solutions because of lazy evaluation.  MAde laziness click for me.
09:42:06 <jowens> nafai: ditto
09:43:30 <Yuu_chan> tdammers: brains of some programming-proficient friends of mine were exploded by the Maybe type definition :)
09:44:55 <Sonderblade> haskells builtin Text.Regex package is based on pure functions, right?
09:47:11 <Yuu_chan> Interestingly, I currently teach Haskell to 3rd grade students and they deal surprisingly well with all those HOFs and types, few of them already completed the course laboratory programs
09:47:38 <MagneticDuck> Yuu_chan: 3rd grade students?!
09:47:45 <MagneticDuck> wat.
09:48:28 <MagneticDuck> uhm, are we thinking about the same 3rd grade students?
09:49:29 <Yuu_chan> MagneticDuck: that would be an amazing coincidence
09:50:01 <pearson> Yuu_chan: Seriously though, if it's what I am thinking, what the hell?! That's amazing.
09:50:33 <edwardk> Yuu_chan: nice!
09:50:47 <MagneticDuck> Yuu_chan: 3rd year students maybe :D (3rd year in uni)
09:50:57 <MagneticDuck> sounds cool
09:51:17 <Yuu_chan> Okay, what are you guys thinking about? :)
09:51:31 <haasn> 3rd grade students might actually work
09:51:45 <haasn> Not sure if Haskell :)
09:51:57 <haasn> But it's definitely possible to learn programming in 3rd grade
09:52:02 <Yuu_chan> I probably mistranslated the word, English isn't my native, after all :(
09:52:05 <pearson> Yuu_chan: I thought, you teached 3rd class middle/grade school haskell
09:52:07 <MagneticDuck> I think I did around that time
09:52:16 <MagneticDuck> but I learned "logo" (from "MicroWorlds")
09:52:45 <MagneticDuck> btw, is that microworlds thing still a thing nowadays?
09:53:08 <kadoban> is logo the one with the turtle?
09:53:13 <MagneticDuck> yes
09:53:19 <MagneticDuck> one of the original turtle languages =P
09:53:20 <kadoban> yeah, i loved that one, that was cool
09:53:52 <zomg> MagneticDuck: every time someone speaks about turtle with regards to programming, I can't help but think of Minecraft :D
09:54:10 <joelteon> Minecraft doesn't have turtles
09:54:15 <haasn> MagneticDuck: 4th grade-ish here, with QBASIC :P
09:54:28 <zomg> There's this mod which adds Lua programmable computers to it... It also adds little robots called "turtles" :)
09:54:41 <MagneticDuck> minecraft...
09:54:43 <joelteon> oh
09:54:44 <MagneticDuck> that thing has gone too far
09:54:51 <MagneticDuck> :D
09:55:08 <Yuu_chan> ComputerCraft, it is :_
09:55:12 <zomg> Yep
09:55:19 <zomg> There's a bunch of folks using ComputerCraft to teach programming to kids
09:55:24 <zomg> apparently seems to be doing quite well
09:55:26 <Yuu_chan> There is also Forth-programmed RedPower
09:55:44 * hackagebot creatur 5.2.6 - Framework for artificial life experiments.  http://hackage.haskell.org/package/creatur-5.2.6 (AmyDeBuitleir)
09:55:44 * hackagebot creatur 5.2.7 - Framework for artificial life experiments.  http://hackage.haskell.org/package/creatur-5.2.7 (AmyDeBuitleir)
09:55:47 <zomg> Yeah never bothered even trying to learn it, too low level for my taste :D
09:56:53 <Yuu_chan> I can remember of some man teaching Haskell to kids...
10:00:53 <Cale> Yuu_chan: I can hardly stand to play Minecraft any more now that RP2 has stopped updating. Everything reminds me of how much I miss having it.
10:01:05 <Yuu_chan> pearson: in my mother Russian "student" only means "student in university", not school, and I always forget semantic difference of "class", "year", "grade" and so on >_>
10:02:47 <pearson> Yuu_chan: Ah, i see. Thank you.
10:03:01 <Cale> zomg: I went as far as writing a program to brew arbitrary potions, but didn't go much farther than that with RP2's Forth.
10:03:24 <dixtosa> Hello everyone
10:03:30 <Yuu_chan> Hi dixtosa
10:03:30 <Cale> hello!
10:03:48 <dixtosa> Ive got a quick question. :)
10:03:56 <dixtosa> Whats problem with this function definition?
10:04:00 <dixtosa> let myrev (a:b) = myrev(b)++[a]
10:04:24 <Yuu_chan> It doesn't know what to do when the list is empty.
10:04:58 <Yuu_chan> > let myrev [] = []; myrev (a:b) = myrev b ++ [a] in myrev "abracadabra"
10:04:59 <lambdabot>  "arbadacarba"
10:05:02 <dixtosa> No, even if add "let myrev [] = []"
10:05:22 <dixtosa> it raises the followig error : "Exception: <interactive>:28:5-17: Non-exhaustive patterns in function myrev"
10:05:26 <Yuu_chan> dixtosa: in GHCi all clauses of a function must be defined in a single block
10:06:03 <Cale> dixtosa: I strongly recommend creating a .hs file to put your definitions into and loading it in ghci
10:06:06 <Yuu_chan> dixtosa: if you do "let myrev [] = []", then "let myrev <...>", the second definition overrides the first
10:06:15 <Cale> Whenever you save your file, just use :r in ghci to reload it
10:06:31 <Cale> Keep a text editor window open alongside your GHCi window
10:06:43 <Yuu_chan> that's possible to define multiline function in ghci, but it's quite clumsy and fragile in my opinion
10:07:01 <scshunt> just use {
10:07:02 <Cale> You *can* define everything at the GHCi prompt now, but it's awkward, and there are various things which can happen to make you lose your work
10:07:47 <zomg> Cale: heh :) think there was a few things you could do with RP2 computers, like access RP2 managers or something, but all the rest you could do with CC computers but a lot more easily thanks to Lua :P
10:07:57 <Yuu_chan> By the way, I can vaguely remember that someone asked about reloading the file with keeping the local definition, is it possible?
10:08:02 <Cale> zomg: yeah
10:08:09 <dixtosa> Thanks and speaking of GHCi why is it neccessary to include the "let" keyword?
10:08:31 <Cale> dixtosa: Because GHCi is pretending to be the inside of a do-block
10:08:38 <joelteon> except for 'import'
10:08:49 <Cale> joelteon: and a bunch of other stuff :P
10:08:56 <joelteon> dixtosa: you may not know that you can use <- in ghci
10:08:56 <Cale> (data, class, etc.)
10:09:24 <fizbin> dixtosa: You can also use the ghci command ":{", then do your let statement over two lines (indent the second line so that it is under the let), then :} to close.
10:09:51 <geekosaur> which is the horror that Cale was advising against
10:09:58 <Cale> dixtosa: But I suppose the real reason is that it needs to distinguish expressions from declarations, and I suspect this is trickier in terms of parsing if the 'let' isn't there.
10:10:11 <dixtosa> Awesome!. It feels great when everything makes sense XD. Thank you guys : ))
10:11:42 <ski> dixtosa : if you really want to, you can separate the defining equations for `myrev' with `;'
10:11:43 * Yuu_chan wishes the option to turn off "let" in GHCi and to write code just as a plain source file
10:11:44 <quchen> haasn: Oh, so "mapped" is more like "fmapped"
10:12:21 * Yuu_chan has read "mapped" as "mappend"
10:12:27 <ski> Yuu_chan : what about (e.g. mutually) recursive definitions ?
10:13:05 <Yuu_chan> ski: I don't say if it is possible, I just wish! :)
10:13:39 <FireFly> it makes a bit more sense if you see the GHCi REPL as inside a big 'do'
10:13:46 <Yuu_chan> But yeah, I remember the F# interpreter with all those ugly "and"s.
10:14:18 <ski> more sensible to write non-throw-away code in a proper editor, imho
10:14:26 <Yuu_chan> FireFly: I know, but for example you can't define types inside the do-block.
10:14:45 <joelteon> or ~/.ghci
10:15:43 <Yuu_chan> So I imagined the option to switch from "do-mode" to "everything-mode"
10:18:31 <Yuu_chan> Are there any experts in gloss?
10:19:10 <skypers> 15:03 < monochrom> err wait nevermind, right target
10:19:32 <skypers> monochrom: :D yes I was the right target :) btw, I discovered that making my E a an instance of Eq is quite stupid
10:19:54 <skypers> then I can’t make it instance of Floating nor Integral
10:20:10 <skypers> oh it can be Floating
10:20:41 * hackagebot cabal-cargs 0.3 - A command line program for extracting compiler arguments from a cabal file.  http://hackage.haskell.org/package/cabal-cargs-0.3 (DanielTrstenjak)
10:20:48 <Cale> I've actually always been slightly opposed to GHCi allowing so many types of declarations. Obviously there are cases where it's convenient, but it also encourages beginners to do the wrong thing to some extent.
10:23:34 <Tehnix> has there been any news on GHC 7.8 since the October 2013 status report? :/
10:24:21 <Cale> Tehnix: yes
10:24:24 <mimi_vx> Tehnix: rc released :0
10:24:42 <Cale> Actually aren't we even on the second RC already? :)
10:24:43 <Tehnix> uh, nice :D
10:46:36 <nawal> hey guys
10:46:42 <Yuu_chan> Nya?
10:46:55 <nawal> I'm trying to compile a test code using the bullet library in haskel
10:47:04 <nawal> ghc src/Bullet1.hs -lBulletCollision -lBulletDynamics -lBulletSoftBody
10:47:09 <nawal> Undefined symbols for architecture x86_64:
10:47:18 <nawal> oh actually
10:47:28 <nawal> btGLDebugDrawer  "_glBegin", referenced from:
10:47:42 <nawal> I'm not sure how to include OpenGL in the linking? any advice please?
10:47:52 <nawal> this is on OS X
10:47:59 <nawal> 10.8.5
10:48:42 <Yuu_chan> Maybe GLUT is needed?
10:49:04 <ClaudiusMaximus> nawal: try using cabal-install, it collates all the external library dependencies and calls ghc with the right flags
10:49:50 <nawal> I tried  -lglut -L/opt/X11/lib but same error
10:50:15 <nawal> ClaudiusMaximus: I'll try that! Thanks!
10:50:17 <ClaudiusMaximus> -lGL might work, but if there is already a foo.cabal file then use it
10:51:07 <geekosaur> it's -lGL, yes
10:51:18 <geekosaur> and the -L probably needs to come before the -l...
10:52:09 <skypers> what is the english full word for the recip from Fractional function?
10:52:16 <Cale> reciprocal
10:52:19 <skypers> ok
10:52:29 <skypers> in french it’s “inverse”
10:52:36 <Cale> It's inverse in English too
10:52:48 <skypers> why isn’t it called inv then?
10:52:49 <Cale> (But inverse is more abstract)
10:53:27 <Cale> reciprocal is only used to refer to the multiplicative inverse and nothing else
10:53:29 <triliyn> "inverse" means lots of things; "reciprocal" is specifically the multiplicative inverse
10:55:44 * hackagebot colada 0.7.0.0 - Colada implements incremental word class class induction  using online LDA  http://hackage.haskell.org/package/colada-0.7.0.0 (GrzegorzChrupala)
11:05:25 <HugoDaniel> hi
11:06:07 <HugoDaniel> how can i create symbolic link between two files with haskell ?
11:08:21 <supki> @hoogle createSymbolicLink
11:08:21 <lambdabot> System.Posix.Files createSymbolicLink :: FilePath -> FilePath -> IO ()
11:08:21 <lambdabot> System.Posix.Files.ByteString createSymbolicLink :: RawFilePath -> RawFilePath -> IO ()
11:08:34 <geekosaur> http://lambda.haskell.org/platform/doc/current/ghc-doc/libraries/unix-2.6.0.1/System-Posix-Files.html#v:createSymbolicLink yes
11:09:52 <petrus> Hello!
11:10:02 <petrus> I am trying to install ihaskell. my "cabal install ihaskell" command failed. Log is at http://lpaste.net/101566
11:10:08 <petrus> Any advice?
11:13:05 <HugoDaniel> supki: thanks
11:24:44 <Rufflewind_> trying to install a package which depends on type-level-0.2.4, but i get this "Illegal type variable name: `'" error when I try to build that package; any ideas?
11:27:48 <schell> I'm looking for the docs on the module GHC.Int - (I'm patching a lib for ghc 7.8) - so far all I can find is https://www.haskell.org/ghc/docs/7.8.1-rc1/html/libraries/ghc-7.8.20140130/GHC.html which doesn't look like it provides GHC.Int - am I looking in the right place?
11:29:14 <geekosaur> base, I'd think
11:29:39 <geekosaur> but I am not sure what "GHC.Int" is
11:36:18 <skypers> is there a way to introduce constraint in a pattern matching?
11:36:23 <skypers> something like
11:36:25 <schell> geekosaur: right now i'm working on patching this file http://hackage.haskell.org/package/bytestring-show-0.3.5.5/src/Text/Show/ByteString/Int.hs
11:36:41 <skypers> case e of { I (x :: (Integral a) => a)) -> … }
11:36:42 <skypers> ?
11:37:25 <pearson> oh yeah, I am getting aware of this problem: Learn math, don't forget your math. Don't do the mistake I did.
11:38:05 <colDrMcBeardman> what would be a good reason to use the strict versions of Data.Map and Data.HashMap? Would huge structures that need to be queried a lot be one?
11:38:10 <geekosaur> schell: right, so that's a module that is normally not visible; the public interface is GHC.Exts
11:38:16 <fragamus> is ghc smart enough to store the result of a function call that is used duplicitavely
11:38:38 <geekosaur> (to the extent that it is public at all)
11:38:41 <colDrMcBeardman> fragamus, I asked something like this the other day and the answer is "possibly sometimes"
11:38:49 <fragamus> lol
11:39:04 <geekosaur> fragamus, ghc does not do CSE in general; you can hint that it should do so with a let binding, but even so it may not
11:39:38 <fragamus> did you know that lambdabot is in ##math
11:39:51 <chirpsalot> colDrMcBeardman: isn't that pretty much always the case with "does the compiler do this?"
11:39:57 <fragamus> i just got bitched at for using it in there
11:40:02 <johanneslippmann> Hi there. I want to do some GUI-Stuff, but I don't know which libary to use for it.
11:40:07 <johanneslippmann> I found this said wich recommends qtHaskell: https://en.wikibooks.org/wiki/Haskell/GUI
11:40:11 <johanneslippmann> But this One says it there is no support for qtHaskell anymore: http://www.haskell.org/haskellwiki/Applications_and_libraries/GUI_libraries
11:40:13 <colDrMcBeardman> chirpsalot, yes, forall x in the set of compilers.
11:40:16 <johanneslippmann> What should i do?
11:40:58 <colDrMcBeardman> fragamus, you can verify if ghc has done CSE or floated your function out by doing -ddump-simpl and reading the core.
11:41:08 <chirpsalot> fragamus: I keep mistaking haskell channels and math ones O_O.
11:41:27 <colDrMcBeardman> johanneslippmann, I believe GTK is more frequently used than qt for haskell
11:41:27 <fragamus> O.o
11:42:01 <colDrMcBeardman> chirpsalot, hopefully it's because the math people are all using Haskell now?
11:42:21 <chirpsalot> colDrMcBeardman: actually it's because the Haskell people all use math :).
11:42:24 <schell> geekosaur: hmmm, does that mean I'm going to have to look at the GHC source in order to figure out what Int#, (#>) etc. are?
11:42:33 <colDrMcBeardman> chirpsalot, my second guess.
11:42:45 <johanneslippmann> GcolDrMcBeardman: Yoz mean Gtk2Hs?
11:42:46 <geekosaur> schell: yes
11:43:00 <colDrMcBeardman> schell, those are unboxed machine types
11:43:02 <geekosaur> they are primitives
11:43:12 <geekosaur> GHC.Prim might be of a little help but probably not
11:43:39 <colDrMcBeardman> schell, the difference is that Int is a pointer to a closure on the heap, and Int# is an actual machine integer.
11:43:51 <colDrMcBeardman> johanneslippmann, yes?
11:44:14 <johanneslippmann> colDrMcBeardman: Ok, thanks. I will have a look to it :)
11:44:47 <colDrMcBeardman> I don't do gui programming, but that's what every button-using gui in haskell I've seen uses. I think there may be bindings to other ones like wxWidgets, but I'm not sure.
11:44:59 <schell> colDrMcBeardman: okay, so then i'm guessing the operators with # suffixes probably do what is expected, only on machine types, correct?
11:45:32 <colDrMcBeardman> schell, yes, + works on Ints and +# is a machine addition op working on the machine-type Int#s
11:47:31 <nawal> geekosaur, good call, that worked :-)ghc src/Bullet1.hs -lBulletCollision -lBulletDynamics -lBulletSoftBody -L/opt/X11/lib -lgl
11:48:12 <geekosaur> it should probably be -lGL if you intend this to be portable; it only works because OS X uses a case insensitive filesystem...
11:49:01 <chirpsalot> Oh cool, there is a bullet wrapper?
11:49:40 <schell> colDrMcBeardman: okay, thanks for the direction - are there any good texts (off the top of your head) i can use to investigate further?
11:49:55 <chirpsalot> geekosaur: is -lGL actually portable? I feel like I have had problems with that too...
11:50:07 <schell> or search terms that would yield good googling?
11:50:10 <geekosaur> that is the standard name, yes
11:50:11 <Yaniel> windows would want -lOpenGL32
11:50:22 <Yaniel> iirc
11:50:23 <geekosaur> -lgl will lose on other unixlikes *and* windows
11:51:00 <geekosaur> sadly library portability between unix and windows is a massive pain for which there are very few fixes; this is one reason why you were repeatedly advised to use Cabal mechanisms, which help to deal with it
11:52:28 <nawal> geekosaur: yeah I got the cabal to work now :-)
11:52:52 <nawal> But generally before I use automated things, I like to figure out where everything is first - that way I know why the automagic thing doesn't work :P
11:56:48 <colDrMcBeardman> schell, the performance page on the haskell wiki will help a little bit. there may be things on the GHC trac wiki. search around.
11:57:11 <schell> colDrMcBeardman: cool thanks again
11:57:14 <schell> geekosaur: thank you too
11:57:17 <colDrMcBeardman> terms would be "unboxed types"
11:57:29 <colDrMcBeardman> schell, sure np
11:59:31 <ClaudiusMaximus> http://lpaste.net/101570 having trouble installing accelerate-cuda, any ideas what might be going wrong?
12:08:57 <pyon> I have a pretty big module and I want to hide (not export) exactly *ONE* definition. Is the only way to do this to explicitly add all the other definitions to the module's export list?
12:09:45 <geekosaur> yes, sadly
12:09:54 <int-e> pyon: not really. you can import the module in another module (hiding the definition) and reexport the module from there.
12:09:55 <ClaudiusMaximus> pyon: export them all in a different module, add a module that imports hiding and re-export the module, hide the first module from the public api
12:10:02 <geekosaur> well, there is that
12:10:14 <geekosaur> but it'd be nice if module ... hiding (foo) worked
12:10:22 <pyon> Yeah.
12:10:38 <geekosaur> I half expect to see it proposed at some point, itgets asked about a lot and the intervening module is kinda a poor solution imo
12:11:03 <ClaudiusMaximus> true
12:11:31 <kazagistar1> is the main reason it does not exist that no one has done it yet?
12:14:35 <pyon> Another way I think it could work is by giving explicit type signatures to things we want to export. Inside a module, everything would be assigned its principal type (possibly more general than what the explicit type signature says), but, outside the module, things are only seen as having their explicitly assigned type signatures.
12:15:13 <pyon> At least that is how I tend to do stuff in ML.
12:15:54 * hackagebot vty 4.7.4 - A simple terminal UI library  http://hackage.haskell.org/package/vty-4.7.4 (CoreyOConnor)
12:19:15 <Redz> when i want to write a web application with server push (server sent events or websocket or similar) and dont want to handle fancy optimization structures (builders, pipes, conduit), just as plain as possible, which server and library should i use?
12:21:54 <geekosaur> Network works for simple stuff, Network.Socket is preferred but more low level
12:22:16 <geekosaur> HTTP for basic web stuff
12:22:23 <geekosaur> neither one has websockets that I know of
12:29:34 <codecodecode> hi
12:29:41 <jle`> Redz: there's the websockets library
12:29:49 <codecodecode> what's a monad, explained in simple Java terms? (haha)
12:29:52 <jle`> but also i wouldn't quite call pipes and conduit optimization structures
12:32:05 <croh> codecodecode: i like to say a programmable semicolon. gbacon.blogspot.com/2009/07/programmable-semicolon-explained.html
12:33:39 <Redz> jle`: its still easier to use things we all know instead of writing an extra abstraction with new words but similar meaning. ;)
12:34:07 <codecodecode> croh, read it, monads still elusive
12:34:10 <jle`> Redz: the abstraction changes the way you look at things
12:34:27 <jle`> codecodecode: monads aren't really conceptually anything
12:34:39 <codecodecode> i see
12:34:46 <codecodecode> now it's all clear
12:34:47 <jle`> if you try to understand what monads are
12:34:53 <jle`> you won't really learn anything practical
12:34:55 <jle`> immediately
12:35:02 <jle`> and you won't actually understand much
12:35:33 <Twey> codecodecode: What's an Iterable?  ☺
12:36:05 <codecodecode> Twey, are you in javaland now?
12:36:10 <jle`> and none of that math gobbledy gook
12:36:12 <jle`> with the next
12:36:15 <jle`> and prev
12:36:18 <jle`> and end
12:36:19 <jle`> and begin
12:36:45 <jle`> iterable tutorials are so elusive :/
12:36:45 <Twey> codecodecode: Sure
12:37:08 <Redz> jle` i tried to work with wai and it was a pain to write type conversions everywhere just because i'm happy with String for text.
12:37:18 <codecodecode> Twey, well, per definition a target for foreach
12:37:29 <jle`> Redz: Text is an optimization
12:37:36 <Twey> codecodecode: So an Iterable is something that can be iterated over?
12:37:42 <Redz> no. i mean text. not Text. ;)
12:38:05 <Twey> codecodecode: A monad is something that can be ‘chained together’
12:38:07 <Redz> or should i say String for string.
12:38:07 <jle`> what kind of type conversions do you mean? :/
12:38:09 <Redz> a list of characters.
12:38:10 <codecodecode> Twey, sure
12:38:23 <Twey> codecodecode: In the same sense
12:38:56 <codecodecode> Twey, iterable is a typing concept, so monads are the same?
12:39:00 <Redz> jle`: converting between blaze builder and string. and similar.
12:39:07 <jle`> ah
12:39:33 <codecodecode> Twey, so if i make something a monad, i can participate in chained application
12:39:45 <croh> codecodecode, I learned them by focusing on a single instance of them: the parser monad
12:39:47 <jle`> codecodecode: you know about Interfaces, right?
12:39:54 <codecodecode> jle`, yup
12:40:16 <jle`> monad can be said to be an interface of sorts
12:40:27 <codecodecode> jle`, that i don't believe
12:40:28 <Twey> codecodecode: Yes, something like that
12:40:28 <jle`> if a type is a monad, it has a contract to supply two operations
12:40:33 <codecodecode> Twey, okay
12:40:49 <ClaudiusMaximus> is there a better way to set up my ~/.cabal/config so that playing around with multiple ghc versions gives sane documentation without cabal: Haddock's internal GHC version must match the configured GHC version.
12:41:36 <jle`> Redz: well, i can't do anything to convince you.  but i wouldn't be discouraged from taking a look at pipes if you were turned off by blaze builder.  but websockets is a library that has a minimal interface over websockets
12:42:48 <Redz> yes. the websockets lib seems sufficient. i'll try it with websockets.
12:43:07 <NikolajK> can you have type classes with types of different kinds?
12:43:10 <jle`> codecodecode: you probably know about linked lists, so let's consider it as a concrete example.  if a linked list is a monad, it must supply a statc method LinkedList <a> unit(a);
12:43:14 <Twey> codecodecode: Monads let you ‘bind’ functions into them that produce the next version of the monad, like  x >>= \ valueGeneratedByX → y .  That's why people call them ‘programmable semicolons’ — because that looks kind of like  var valueGeneratedByX = x; y  in other languages
12:43:22 <NikolajK> e.g. can you put Int and [] in the same type class
12:43:29 <NikolajK> or any other example
12:43:43 <Twey> codecodecode: And indeed we have a ‘do-notation’ syntactic sugar for monads that lets you write:  do valueGeneratedByX ← x; y
12:44:18 <Twey> NikolajK: No
12:44:35 <Twey> NikolajK: You wouldn't be able to use the types in the typeclass, so it would be useless
12:44:41 <Twey> NikolajK: You can add an instance for [a], though
12:45:03 <jle`> it must also have a member method which is harder to define in java syntax, but if i have a LinkedList<a>, i can call LinkedList<b>.bind(  function-from-a-to-LinkedList<b>    );
12:45:07 <NikolajK> and polymorphic types are always of kind *?
12:45:11 <codecodecode> Twey, anyway, I should've found this before: http://logicaltypes.blogspot.no/2011/09/monads-in-java.html
12:45:18 <codecodecode> totally explains it to a java head
12:45:26 <Twey> codecodecode: Cool :-D
12:45:39 <Twey> Monads have a bad rep, but they're not really that intimidating
12:46:04 <Twey> NikolajK: Imagine: instance Foo a where foo ∷ a → a
12:46:06 <jle`> it's just unit and bind, whats the problem :|
12:46:08 <Twey> Er
12:46:12 <Twey> NikolajK: Imagine: class Foo a where foo ∷ a → a
12:46:34 <Twey> jle`: Applicative and join :<
12:46:45 <fizruk> NikolajK: types are of kind *, type constructors may be of kinds `* -> *`, `(* -> *) -> *`, etc.
12:47:01 <Twey> NikolajK: If you have an instance Foo Int, then foo ∷ Int → Int
12:47:23 <Twey> NikolajK: But what would an instance for [] look like?  instance Foo [] where foo ∷ [] → [] ?  That's obviously a kind error
12:47:48 <NikolajK> ic, makes sense, thx
12:48:39 <Twey> NikolajK: You *can* use the PolyKinds extension to have polymorphic kinds: class ∀ (a ∷ k). Foo a where …
12:48:45 <Twey> But it's just not useful
12:48:46 <NikolajK> and are polymorphic types always associated with some class?
12:48:51 <Twey> (in any way I can think of)
12:50:05 <fizruk> NikolajK: id :: a -> a
12:50:15 <fizruk> NikolajK: map :: (a -> b) -> [a] -> [b]
12:50:35 <fizruk> NikolajK: fst :: (a, b) -> a
12:50:40 <eacameron> I want to make this monad: newtype SafeTerm a = SafeTerm  { runSafeTerm :: ReaderT (MVar Terminal) IO a
12:50:48 <eacameron> but I can't derive MonadReader because of arity
12:50:52 <eacameron> ideas?
12:51:05 <fizruk> NikolajK: all those types are not bound to any type class
12:51:38 <roboguy_> NikolajK: classes and polymorphic types actually form two different kinds of polymorphism (and they can be combined): ad-hoc polymorphism and parametric polymorphism
12:52:42 <Twey> NikolajK: Hm, maybe if you used it as a parameter for an associated type, it could be useful
12:52:46 <NikolajK> why do classes form polymorphisms?
12:52:46 <NikolajK> you mean the functions associated with the classes happen to be polymorphic?
12:53:12 <roboguy_> NikolajK: no. type classes themselves are a kind of polymorphism
12:53:18 <fizruk> eacameron: deriving (MonadReader (MVar Terminal)) should work
12:54:02 <eacameron> fizruk: that it does! this is my first custom monad, thanks a ton
12:54:41 <roboguy_> NikolajK: the way that "f" is polymorphic in "class Point f where point :: a -> f a" is different than the way "a" and "b" are polymorphic in map :: (a -> b) -> [a] -> [b]
12:54:42 <NikolajK> roboguy_: as they collect types I see that they related to several types, but if you speak of polymorphism I'd want to speak about functions.
12:54:47 <Twey> class ∀ (a ∷ k). Foo a where Bar ∷ k → ★; baz ∷ Bar a → Int; … or something
12:55:04 <fizruk> NikolajK: type classes provide a possibility of overloaded functions/operators. Overloading here is what "ad hoc" means, I think (may be confused a bit myself)
12:55:31 * monochrom can't resist joining the explanation
12:56:15 <monochrom> look at "Maybe Int". or "Maybe<Int>" if you want that notation. you could generalize to "Maybe a". that's just one dimension. another dimension is to generalize to "m Int".
12:56:26 <monochrom> Haskell allows both. Java allows the first one only.
12:57:01 <monochrom> Therefore any effort to code up, say, Functor, in java is futile
12:57:06 <geekosaur> ad hoc is in contradistinction to parametric, and indicates that the polymorphism is dependent on the known instances instead of ranging over all possible values of the parameter
12:57:17 <benzrf> hey
12:57:22 <jle`> hi benzrf
12:57:31 <benzrf> i wanna complain to the creator of reactive-banana, if they are here...
12:57:40 <monochrom> you can code up a Java Maybe's fmap. you can code up a Java List's fmap. etc. etc. but you can't unify them under one roof.
12:58:07 <benzrf> WHY DIDNT YOU CALL IT 'CALLBACKREGISTRY' INSTEAD OF 'ADDHANDLER'
12:58:09 <benzrf> >:o
12:58:15 <NikolajK> I don't know too much about Java and I think I need more example to see how to introduce polymorphism in the two different ways
12:58:18 <monochrom> similar story for Monad. (Monad is just more stuff.)
12:58:27 <benzrf> monochrom: multimethods!
12:59:09 <NikolajK> data Tree a = Leaf a | Branch (Tree a) (Tree a)
12:59:10 <NikolajK> that's parametric polymorphism, right?
12:59:15 <benzrf> yea
12:59:19 <benzrf> same as generics
12:59:24 <benzrf> but more terrible
12:59:24 <ski> NikolajK : no
12:59:26 <benzrf> *less
12:59:30 <benzrf> oh
12:59:31 <benzrf> my bad
12:59:44 <ski> `Tree' is a parametric type
13:00:03 <ski> if you write `flatten :: Tree a -> [a]', then that's parametric polymorphism
13:00:12 <eacameron> I want to use mapM on a function that is within my MonadIO monad, how do I do that?
13:00:23 <ski> (also the data constructors `Leaf' and `Branch' are parametrically polymorphic)
13:00:46 <ski> (but `Tree' itself isn't polymorphic)
13:00:58 * hackagebot vty 4.7.5 - A simple terminal UI library  http://hackage.haskell.org/package/vty-4.7.5 (CoreyOConnor)
13:01:04 <eacameron> I guess I can't
13:01:11 <eacameron> that would be backwards
13:01:36 <beaky> hello
13:01:36 <NikolajK> okay, and when I define a class, and then a function for it, at which point do I enter ad hoc polymorphism?
13:01:52 <quchen> eacameron: lift (mapM f ...)
13:01:54 <beaky> I dont understand the proverbs "objects are a poor man's closures" and "closures are a poor man's objects". what do they mean?
13:02:02 <NikolajK> hi quchen
13:02:09 <roboguy_> beaky: you can represent closures with objects and objects with closures
13:02:12 <quchen> Oh hey
13:02:20 <NikolajK> me lerning Haskell
13:02:21 <beaky> roboguy_: what about adhoc polymorphism with objects
13:02:28 <roboguy_> beaky: ?
13:02:37 <eacameron> quchen: but f is not IO
13:02:46 <beaky> roboguy_: also objects can invoke mutliple methods... ooooh so you can do all that with closures?
13:02:49 <beaky> how
13:02:49 <eacameron> it's my own monad (that has IO underneath)
13:03:04 <roboguy_> beaky: yeah. you just need a way to encode the message.
13:03:06 <quchen> Do you have some example code?
13:03:09 <quchen> eacameron: ^
13:03:20 <NikolajK> quchen: me?
13:03:40 <roboguy_> beaky: in Lisp languages, they traditionally use unevaluated symbols for that. In Haskell, you would usually use a sum type
13:03:45 <quchen> NikolajK: No, eacameron. The "^" was an arrow.
13:04:04 <beaky> whats a sum type
13:04:21 <roboguy_> beaky: "data Bool = True | False" is a basic sum type
13:04:35 <eacameron> quchen: I lied
13:04:39 <ski> @src Bool
13:04:39 <lambdabot> data Bool = False | True deriving (Eq, Ord)
13:04:43 <benzrf> beaky: all an object is, is a bundle of state with functions
13:04:56 <benzrf> all a closure is, is a bundle of state with a function
13:05:05 <eacameron> quchen: I thought mapM would be an easier alternative example, I'm actually using mapConcurrently which is not parameterized on Monad
13:05:05 <benzrf> and multiple functions are the same as 1 function with more args
13:05:15 <beaky> how do closures work
13:05:19 <NikolajK> quchen: my degenerate approach to Haskell: http://physics.stackexchange.com/questions/104466/what-are-type-system-examples-of-local-gauge-transformation-and-field-strength
13:05:20 <beaky> sounds hard to implement
13:05:23 <ski> roboguy_ : .. or just use a record of methods implementing the messages
13:05:26 <eacameron> quchen: it takes IO straight up
13:05:43 <beaky> also why are cosures useful if we have objects
13:05:49 <beaky> or data in haskell
13:05:50 <ski> beaky : closures is one way to implement first-class functions
13:05:58 * hackagebot attoparsec-parsec 0.1.3 - An Attoparsec compatibility layer for Parsec  http://hackage.haskell.org/package/attoparsec-parsec-0.1.3 (SimonHengel)
13:06:01 <eacameron> quchen: can I "rewrap" my action in IO with "return" or something?
13:06:06 <roboguy_> beaky: haskell would basically be unusable without closures
13:06:52 <quchen> eacameron: You often 'lift' and 'return' things when working with transformers (and sometimes you even 'hoist' them). But without some minimal code example I'm not sure what exactly you're even asking.
13:06:53 <roboguy_> you wouldn't be able to have nice things like a (useful) map function
13:07:30 <beaky> so closures are just normal functions with free variables captured from its original context?
13:07:57 <roboguy_> beaky: pretty much. they are "closed over their lexical environment" (hence the name)
13:08:17 <NikolajK> [] is of kind *->*, but does it also relate to polymorphic types?
13:09:54 <ski> NikolajK : indirectly, yes
13:10:13 <Twey> NikolajK: Well, yes.  If some Foo is of kind ★ → ★, it means that you can form a type Foo a for any type a, so you can have functions that are polymorphic over that ‘a’ type
13:10:34 <Twey> (so long as a ∷ ★)
13:10:43 <ski> you can say stuff like `[] Int' and `[] (Either ([] Char) ((->) Int Int))', which is all completely monomorphic
13:11:17 <NikolajK> k
13:11:25 <roboguy_> NikolajK: [] is like a type level function, sort of
13:11:40 <roboguy_> you give it a type and it gives you a type
13:12:32 <roboguy_> more specifically, it is a type constructor
13:12:39 <ski> but it also means you can say stuff like `forall a. (a -> a) -> a -> [] a', which is a type of polymorphic things
13:12:41 <eacameron> quchen: https://github.com/CovenantEyes/libget-hs/blob/thread-safe-terminal/src/Main.hs#L108
13:13:02 <eacameron> quchen, like I said, this is my first custom monad ever
13:13:21 <NikolajK> above someone said Bool is basically a sum type. Now "data Bool = True | False", if I'm not mistaken. For a direct sum, I expect two types to begin with, while this is just the specification of the terms. Are there some t1, t2 with True : t1 and False : t2, such that Bool is t1+t2
13:13:26 <ski> NikolajK : a value is (parametrically) polymorphic when its type looks like `forall a. ..a..' (obviously `a' may be named something else)
13:13:40 <ski> NikolajK : no
13:14:09 <monochrom> you can do that in your own head. but not in Haskell.
13:14:17 <eacameron> quchen: I don't know how to get back to raw IO monad from my SafeTerm monad
13:14:28 <eacameron> main must be IO
13:14:34 <ski> NikolajK : however, `data Bool = False | True' is almost the same thing as `data Bool = False () | True ()', so in the latter we could schematically say `Bool = () + ()', or writing `1' for `()' : `Bool = 1 + 1'
13:14:40 <NikolajK> can you define a type in any way by summing over two or more other types (i.e. not by giving data ...)
13:14:50 <monochrom> no
13:15:40 <ski> NikolajK : also consider `data Tree a = Leaf a | Branch (Tree a) (Tree a)', this is almost the same as `data Tree a = Leaf a | Branch (Tree a,Tree a)', so now we can schematically say `Tree a = a + Tree a * Tree a'
13:15:54 <quchen> eacameron: Oh, well that should be easy. You have `newtype SafeTerm a = SafeTerm { runSafeTerm :: ReaderT (MVar Terminal) IO a`, and you need to convert it down to something of type `IO`. First unwrap your SafeTerm value to get a ReaderT value, then unwrap that (using runReaderT) and you'll end up with IO.
13:16:13 <ski> NikolajK : "can you define a type in any way by summing ..." -- no, because there is no subtyping in Haskell
13:16:25 <ski> (in O'Haskell, there was subtyping)
13:17:06 <eacameron> quchen: oh interesting, so runSafeTerm . runReaderT ?
13:17:22 <NikolajK> so there is no +, but there is -> and (,)
13:17:26 <NikolajK> something else?
13:17:47 <roboguy_> NikolajK: Either is like +
13:17:55 <NikolajK> I thought so
13:18:21 <roboguy_> so in that sense, yes, you can sum over types without giving a data definition
13:18:21 <quchen> eacameron: Yes, basically. (runSafeTerm . flip runReaderT env) will be what you end up with.
13:21:50 <roboguy_> NikolajK: one interesting thing is that both Either and (,) are covariant in both their arguments and (->) is contravariant in it's first argument and covariant in it's second argument (well, I think it's interesting anyway)
13:23:03 <NikolajK> not sure I grasp the implications
13:24:08 <NikolajK> to get the notation right, "Num" is the name of a type class and "Int" is a type in that class?
13:24:17 <ski> yes
13:24:32 <roboguy_> this means that you can define a "pairMap2 :: (a -> a') -> (b -> b') -> (a, b) -> (a', b')" and "eitherMap2 :: (a -> a') -> (b -> b') -> Either a b -> Either a' b'", but for (->) you instead have to define "fnMap2 :: (a' -> a) -> (b -> b) -> ((->) a b) -> ((->) a' b')"
13:24:52 <roboguy_> notice how the function being mapped over the first argument of (->) is "backwards" (going from a' -> a instead of a -> a')
13:25:03 <ski> `Num' is like "red", and `Int' is like "Mars". `Num Int' is like saying "Mars is red."
13:26:00 * hackagebot cookbook 2.2.0.0 - Tiered general-purpose libraries with domain-specific applications.  http://hackage.haskell.org/package/cookbook-2.2.0.0 (NatePisarski)
13:26:03 <roboguy_> oops, that should be fnMap2 :: (a' -> a) -> (b -> b') -> ((->) a b) -> ((->) a' b')
13:28:18 <NikolajK> I see that Bool is in Eq, but I don't see where == is defined for bools in particular
13:28:39 <NikolajK> instance or something
13:28:52 <benzrf> NikolajK: it is probably derived
13:29:12 <Iceland_jack> NikolajK: Are you looking for the Eq instance declaration for Bools?
13:29:13 <roboguy_> @src Bool
13:29:13 <lambdabot> data Bool = False | True deriving (Eq, Ord)
13:29:27 <MagneticDuck> hey guys, are there any cool... code refactoring tools that I could check out?
13:29:48 <Iceland_jack> MagneticDuck: there's HaRe but I haven't used it
13:30:34 <MagneticDuck> HaRe looks abandoned.
13:30:36 <MagneticDuck> :/
13:30:45 <roboguy_> NikolajK: yeah, it's automatically derived by the "deriving" clause
13:30:48 <MagneticDuck> http://www.haskell.org/haskellwiki/HaRe section "some problems to address"
13:30:58 <MagneticDuck> I'd.. rather not write haskell98
13:32:14 <MagneticDuck> refactorin'.... what a cool idea :D
13:32:16 <NikolajK> still can't find the initial definition though
13:32:25 <NikolajK> I checked Ord
13:32:30 <Krakarn> :t (\f -> traverse (pure . f))
13:32:34 <lambdabot> (Applicative f, Traversable t) => (a -> b) -> t a -> f (t b)
13:32:35 <MagneticDuck> there isn't really anything out there to use though :<
13:32:57 <roboguy_> NikolajK: you mean the definition of the Eq class itself, not specifically the Bool instance?
13:33:00 <xunplini> How can I make this work without a type error: "factor n = [x | x <- (takeWhile (<= (sqrt (n))) [1..]), mod n x == 0]" ?
13:33:03 <ski> NikolajK : `deriving' automatically "writes" the implementation of `(==)', from the `data ...' declaration
13:33:06 <Krakarn> :t (\f -> traverse (pure . f)) (+1) [1..5]
13:33:07 <lambdabot> (Enum b, Num b, Applicative f) => f [b]
13:33:13 <NikolajK> any definition, really
13:33:15 <Krakarn> > (\f -> traverse (pure . f)) (+1) [1..5]
13:33:18 <lambdabot>  No instance for (Control.Applicative.Applicative f0)
13:33:18 <lambdabot>    arising from a use of `e_1115'
13:33:18 <lambdabot>  The type variable `f0' is ambiguous
13:33:18 <lambdabot>  Possible fix: add a type signature that fixes these type variable(s)
13:33:18 <lambdabot>  Note: there are several potential instances:
13:33:18 <monochrom> Bool's Eq instance code is generated by compiler by request of "deriving Eq". see the Haskell 2010 Report for what kind of code "deriving Eq" gives you
13:33:21 <NikolajK> not just its type
13:33:47 <roboguy_> @src Eq Bool
13:33:47 <lambdabot> Source not found. :(
13:33:48 <Krakarn> that's weird, in my ghci, it works and gives me just a list
13:33:50 <monochrom> there is a lot to read and to learn if you want to learn so fast
13:33:50 <roboguy_> @src Bool Eq
13:33:51 <lambdabot> Source not found. Abort, Retry, Panic?
13:34:11 <roboguy_> NikolajK: well, the compiler automatically derives the Eq instance for Bool, but if you wrote it by hand it would look like "instance Eq Bool where True == True = True; False == False = True; _ == _ = False
13:34:21 <Krakarn> it seems the applicative thing goes away, any ideas?
13:34:49 <ski> xunplini : you probably need to intersperse some calls to `fromIntegral'
13:34:53 <monochrom> ghci has non-standard behaviour, such as picking a type for you
13:35:09 <roboguy_> Krakarn: you didn't specify what Applicative instance you want to use
13:35:46 <monochrom> whenever ghci differs from other things, ghci is wrong.
13:35:47 <NikolajK> k, thx
13:36:05 <Krakarn> roboguy_: yea i was dicking around in ghci and found the behaviour that accepted the error that lambdabot found here
13:36:06 <ski> xunplini : `mod' works on types in the type class `Integral', while `sqrt' works on types in the type class `Floating'
13:36:34 <roboguy_> Krakarn: it works because sometimes ghci does "defaulting": it picks a type for you if it's ambiguous
13:36:49 <roboguy_> this is not how haskell usually works though
13:36:49 <NikolajK> wait, can you create any types and add them to Eq just by making instances of their functions?
13:37:18 <roboguy_> NikolajK: what do you mean by instances of their functions?
13:37:22 <monochrom> I do not understand "making instances of their functions". but I guess the answer is "yes"
13:37:28 <ski> @let xunplini n = [x | x <- takeWhile ((<= sqrt (fromIntegral n)) . fromIntegral) [1 ..], n `mod` x == 0]
13:37:30 <lambdabot>  Defined.
13:37:34 <ski> @type xunplini
13:37:35 <lambdabot> Integral t => t -> [t]
13:37:51 <NikolajK> http://www.haskell.org/onlinereport/classes.gif
13:37:51 <NikolajK> you can vastly extend this, right?
13:37:53 <ski> > xunplini `map` [1 .. 16]
13:37:57 <lambdabot>  [[1],[1],[1],[1,2],[1],[1,2],[1],[1,2],[1,3],[1,2],[1],[1,2,3],[1],[1,2],[1,...
13:38:06 <roboguy_> NikolajK: you mean, can you make more instances? yes
13:38:09 <xunplini> ski: hah, that works! Thanks.
13:38:39 <roboguy_> you can make more instances and you can make more type classes
13:38:39 <ski> xunplini : instead of `(<= sqrt (fromIntegral n)) . fromIntegral' you can say `\x -> fromIntegral x <= sqrt (fromIntegral n)'
13:40:15 <alanz> MagneticDuck: See https://github.com/alanz/HaRe
13:41:52 <roboguy_> NikolajK: also, that image is a bit outdated. they've added some more type classes to the standard library since then
13:43:11 <beaky> why is functional programming better than object oriented programing if oop arguably models the real world and is arguably closer to the way humans think
13:43:42 <geekosaur> oop doesn't actually, people just like to think it does
13:43:58 <thebnq> arguably? what argument
13:44:02 <geekosaur> and in theory it could be, but in practice people can't actually use it when you do
13:44:03 <NikolajK> >better
13:44:05 <NikolajK> what is better
13:44:16 <roboguy_> beaky: you can actually do oop in haskell, just not in the way people expect
13:44:26 <NikolajK> I learn Haskell mostly because I'm interested in the type system, not in programs. What's better now :D
13:45:41 <thebnq> the problem is like 95% of people learn OO first so theres no fair comparison of whats obvious
13:45:49 <thebnq> that was a bs statistic
13:46:02 * hackagebot antisplice 0.13.2.0 - An engine for text-based dungeons.  http://hackage.haskell.org/package/antisplice-0.13.2.0 (implementation)
13:46:04 * hackagebot ironforge 0.1.0.22 - A technical demo for Antisplice.  http://hackage.haskell.org/package/ironforge-0.1.0.22 (implementation)
13:46:06 * hackagebot antagonist 0.1.0.12 - A web interface to Antisplice dungeons.  http://hackage.haskell.org/package/antagonist-0.1.0.12 (implementation)
13:46:16 <tac> only 95%?
13:46:31 <xunplini> I learned good old procedural programming in BASIC first.
13:46:36 <xunplini> Not Visual Basic mind, BASIC.
13:46:56 <xunplini> Admittedly that's even worse for understanding Haskell. ;)
13:47:23 <mangaba_leitosa> good old GOSUB
13:47:44 <thebnq> hehe ti-basic days :]
13:48:07 <Krakarn> I learned basic on an old casio calculator, had to look on a 1 row display
13:48:18 <Krakarn> lol
13:48:30 <thebnq> wow i've never seen that before
13:48:40 <ski> xunplini : hehe, i started with BASIC, and then 6502 next :)
13:48:45 <ski> Krakarn : PB-100F ?
13:49:20 <Krakarn> ski: yes, something like that
13:49:49 <Krakarn> tried to make a castlevania-type game on it, didn't succeed terribly well though ;)
13:49:54 <ski> Krakarn : <http://pocket.free.fr/html/casio/pb-100f_e.html>
13:49:58 <ski> that's the one i started with
13:50:42 <Krakarn> yea it was a long time ago but it looks exactly how i remember it
13:50:55 <thebnq> it says its a PC :D
13:51:12 <ski> of course it's a personal computer ;)
13:51:19 <Krakarn> especially remember the big exe button
13:51:29 <schell> i'm trying to do an operation using ghc primitives but am running into some problems
13:51:31 <schell> if (5# <# 6#) == 0# then "yes" else "no"
13:51:51 <schell> Kind incompatibility when matching types...
13:51:52 * ski idly wonders whether Krakarn should be in #haskell.se
13:51:54 <beaky> so why is fp better than oop
13:52:21 <Krakarn> ski: what's that, haskell for swedes?
13:52:29 <ski> something like that
13:52:34 <zomg> It's Special Edition
13:52:36 <zomg> like Java SE
13:52:38 <zomg> =)
13:52:50 <Krakarn> lol
13:52:58 <Krakarn> its *special*
13:53:15 <roboguy_> beaky: there are many issues at work here and it is hard to simplify things that much. for one, "functional programming" is often an ill-defined concept so it depends on what specifically you mean by functional programming
13:53:37 <ski> schell : try s/==/==#/
13:53:48 <roboguy_> also, as I said, you can do oop in haskell in a reasonable way, so it's not necessarily either-or
13:54:05 <ski> @where object-oriented
13:54:05 <lambdabot> http://community.schemewiki.org/?object-oriented-programming
13:54:15 <thebnq> and fp can be done in oo :]
13:54:35 <roboguy_> a record with function types is a lot like prototype-based oop
13:54:42 <schell> ski: thanks - i see my problem there
13:54:50 <schell> ski: but - now i'm getting Couldn't match expected type ‘Bool’ with actual type ‘Int#’
13:55:03 <NikolajK> == comes from the Eq class, so am I right in saying its polymorphism is ad hoc?
13:55:14 <Iceland_jack> NikolajK: Yes
13:55:24 <ski> schell : hm, i suppose `5# <# 6#' is actually a `Bool'
13:55:31 <xunplini> thebnq: lazy evaluation however can't.
13:55:31 <Iceland_jack> Type classes are a way of expressing ad-hoc polymorphism
13:55:32 <schell> which is the original problem i'm trying to solve - i'm guessing an if statement really requires a Bool and can't work on a Bool# or Int#
13:55:55 <ski> NikolajK : though type class polymorphism is less ad hoc
13:55:56 <schell> ski: it's an Int# I was told by ghci
13:55:56 <joelteon> pattern match?
13:55:59 <thebnq> xunplini: you just have to do it explicitly
13:56:09 <roboguy_> beaky: additionally, these sorts of discussions can get unnecessarily divisive, especially with that phrasing. we should focus on finding the best tools for each job regardless of what "style" they represent
13:56:12 <joelteon> case 5# <# 6# of 1# -> true case; 0# -> false case
13:56:19 <ski> @type (GHC.Prim.<#)
13:56:19 <xunplini> At that point you might as well write half of GHCI.
13:56:20 <lambdabot> GHC.Prim.Int# -> GHC.Prim.Int# -> Bool
13:56:23 <eacameron> quchen: I'm really close, but I'm still having an issue with mapConcurrently. It only takes IO actions but I want to pass it a SafeTerm action
13:56:27 <NikolajK> and parametric polymorphism always comes from "data …" declarations?
13:56:29 * Iceland_jack sits back and watches people respond to beaky
13:56:29 <fizruk> xunplini: I've seen explicit lazy evaluation many times
13:56:49 <ski> @google making ad hoc polymorphism less ad hoc
13:56:50 <lambdabot> http://homepages.inf.ed.ac.uk/wadler/papers/class/class.ps
13:56:55 <schell> ski: ah - maybe i need to use a different <#
13:56:57 <ski> NikolajK : see that ^ paper
13:56:57 <roboguy_> NikolajK: no. "forall a. a -> a" is parametric polymorphism
13:57:19 <schell> ski: (<#) :: Int# -> Int# -> Int# 	-- Defined in ‘GHC.Prim’
13:57:37 <schell> i'm using 7.8 - now i'm pretty certain there's been a change
13:57:41 <ski> ok, i see
13:57:46 <schell> and that is what is breaking this module i'm patching
13:57:48 <Iceland_jack> NikolajK: Parametric polymorphism just means that a function is acts the same way for a range of different types
13:58:05 <NikolajK> but that's the case for == also
13:58:14 <Iceland_jack> NikolajK: no
13:58:15 <ski> NikolajK : "and parametric polymorphism always comes from "data …" declarations?" -- no, it comes from `forall'
13:58:15 <roboguy_> schell: you are comparing a Bool to a Int#
13:58:31 <roboguy_> schell: with the == 0# part
13:59:00 <schell> roboguy_: right, i saw that as soon as ski pointed it out, i spaced =P
13:59:17 <Iceland_jack> NikolajK: The function ‘length’ is parametrically polymorphic since it acts exactly the same whether applied to a list of integers or a list of functions
13:59:22 <schell> so the next question is "how to print a Int#"
13:59:40 <Iceland_jack> NikolajK: 'a + b' does *not* behave the same when 'a' and 'b' are Ints or Doubles
14:00:19 <roboguy_> NikolajK: == works on specific types. something like "id :: a -> a" works for *all* types
14:00:40 <roboguy_> a type must have an instance of Eq for == to work on it
14:01:05 <NikolajK> oh, so it's like a natural transformation, not needing any specification
14:01:08 <ski> furthermore, `id', or any other parametrically polymorphic operation, works in the same uniform way, for every type `a'
14:01:21 <ski> NikolajK : you know any category theory ?
14:01:28 <NikolajK> yes
14:01:45 <ski> yes, parametric polymorphism is related to natural transformations
14:02:11 <ski> in haskell, an operation of type `forall a. F a -> G a' is always a natural transformation from `F' to `G'
14:02:14 <eacameron> I want to pass my own MonadIO monad to functions within Control.Async which only take IO actions. is this possible?
14:02:24 <joelteon> eacameron: use lifted-async
14:02:26 <joelteon> or async-lifteud
14:02:29 <joelteon> whichever it is
14:02:33 <joelteon> async-lifted*
14:02:41 <joelteon> http://hackage.haskell.org/package/lifted-async
14:02:55 <NikolajK> so ad hoc polymorphisms are significantly less pretty
14:02:58 <ski> yes
14:03:06 <eacameron> joelteon: whew! so glad this is out there
14:03:11 <eacameron> is it even possible without this?
14:03:22 <joelteon> you could write it yourself
14:03:24 <eacameron> and why doesn't async just do this anyway?
14:03:31 <joelteon> because it's out of scope for many people
14:03:41 <eacameron> not sure what you mean
14:03:57 <ski> still, if we think of `forall k v. Eq k => k -> [(k,v)] -> Maybe v' as really being `forall k v. EqDict k -> k -> [(k,v)] -> Maybe v', then we regain the parametricness
14:04:05 <joelteon> because many people just want to do async in the IO monad
14:04:12 <joelteon> and lifted-async pulls in some dependencies that async doesn't have
14:04:43 <ski> with `data EqDict a = MkEqDict {(==) :: a -> a -> Bool,(/=) :: a -> a -> Bool}ä
14:05:29 <NikolajK> gets a little messy for my eyes now
14:05:41 <NikolajK> not knowing too much of the syntax
14:06:13 <NikolajK> but where is "forall" with "[a]", which is parametric polymorphic
14:06:34 <merijn> ugh
14:06:38 <roboguy_> NikolajK: EqDict a is a pair of functions a -> a -> Bool
14:06:53 <merijn> Why does parsec export name clashes with Control.Applicative? :(
14:07:06 <joelteon> is it an Applicative instance?
14:07:09 <merijn> Yes
14:07:11 <joelteon> I don't think it is
14:07:13 <joelteon> oh
14:07:15 <joelteon> well then no idea
14:07:22 <roboguy_> merijn: what names?
14:08:20 <merijn> roboguy_: <|>, many, optional
14:08:45 <merijn> roboguy_: Parsec exports it's own <|> which does exactly the same as Control.Applicative, for some vile reason
14:08:57 <roboguy_> merijn: wow that's really weird
14:09:07 <roboguy_> I would imagine that many does the same thing too
14:09:17 <joelteon> many does the same thing
14:09:23 <joelteon> and attoparsec exports many1, which is the same as some
14:09:38 <ski> NikolajK : no `forall' in `[a]'
14:09:46 <merijn> I think parsec's <|> may predate Control.Applicative, but still why they didn't drop it when they moved from Text.ParserCombinator.Parsec to Text.Parsec (i.e. incompatible anyway) is a mystery
14:09:55 <merijn> It's a total pain
14:10:04 <merijn> I keep needing to explicitly hide stuff
14:10:25 <geekosaur> I think Text.Parsec predates wide use of Control.Applicative
14:10:32 <geekosaur> it took a long time for parsec3 to become usable
14:11:08 <ski> NikolajK : btw, note that (in most cases) if we write a type *signature* involving (free) type variables, like e.g. `lookup :: Eq k => k -> [(k,v)] -> Maybe v', then we *implicitly* universally quantify those as `lookup :: forall k v. Eq k => k -> [(k,v)] -> Maybe v', wrapping the *whole* type after `::' in the `forall'
14:11:46 <monochrom> yes, parsec-3 predates Applicative
14:11:51 <ski> NikolajK : the exceptions to this is in case some of those tyvars are already in scope -- in that case we don't add an implicit wrapping `forall' for those tyvars
14:12:05 <merijn> Still a newer version could've droped <|> and friends for Control.Applicative :\
14:12:27 <NikolajK> what is a simple type definition where I can see forall?
14:12:28 * monochrom was there in the days of both parsec-2 and the appearance of parsec-3
14:12:38 <NikolajK> I don't know lookup
14:12:54 <roboguy_> NikolajK: map :: forall a b. (a -> b) -> [a] -> [b]
14:12:56 <ski> NikolajK : a type *definition*, hm ..
14:13:00 <roboguy_> oh
14:13:09 <ski> what roboguy_ said was a type signature, not a type definition
14:14:52 <ski> @let newtype PureCont a = MkPureCont (forall o. (a -> o) -> o)
14:14:53 <lambdabot>  Parse failed: TypeOperators is not enabled
14:15:04 <ski> that would give you
14:15:11 <ski>   PureCont :: * -> *
14:15:26 <ski>   MkPureCont :: (forall o. (a -> o) -> o) -> PureCont a
14:15:33 <ski> where the latter is, per the above, short for
14:15:39 <ski>   MkPureCont :: forall a. (forall o. (a -> o) -> o) -> PureCont a
14:15:56 <ski> NikolajK : .. not sure whether this really helps much
14:17:22 <eacameron> joelteon: so there's no way to just wrap my action back in IO? like a stack with IO on both ends?
14:17:30 <ski> in this case we can't omit the `forall o.' by the "implicit universal quantification" elaboration rule, since `forall o.' doesn't occur at the "top level" of the type signature, iow not directly after the `::'
14:17:34 <joelteon> I'm not sure whaty ou mean
14:17:39 <NikolajK> so you can just declare types via *->*
14:17:40 <NikolajK> ?
14:18:03 <merijn> eacameron: What do you mean?
14:18:31 <eacameron> merijn: so I can pass my MonadIO action into something that only takes IO
14:18:31 <roboguy_> newtype Measure f = Measure (forall a. f a -> Int)
14:18:39 <ski> NikolajK : i'm not sure what you mean
14:18:58 <joelteon> eacameron: you'd have to tear down the monad transformer stack
14:19:24 <merijn> eacameron: That makes no sense, IO is not a monad transformer
14:19:40 <merijn> eacameron: Why can't you simply run your transformer?
14:19:46 <ski> NikolajK : in the above declaration `PureCont a' must have kind `*', since it's declared by `newtype'. and `a' must have kind `*' since it's passed as the left argument to `->'. so `PureCont' will have kind `* -> *'
14:19:50 <joelteon> also, what takes an IO action?
14:19:54 <joelteon> there might also be a lifted variant of that
14:20:06 <NikolajK> can I define
14:20:06 <NikolajK> doubletype :: * -> *
14:20:06 <NikolajK> doubletype a = (a,a)
14:20:25 <ski> @let DoubleType a = (a,a)
14:20:26 <lambdabot>  .L.hs:158:1: Not in scope: data constructor `DoubleType'
14:20:26 <lambdabot>  
14:20:26 <lambdabot>  .L.hs:158:12:
14:20:26 <lambdabot>      Multiple declarations of `a'
14:20:26 <lambdabot>      Declared at: .L.hs:156:1
14:20:30 <ski> er
14:20:32 <ski> @let type DoubleType a = (a,a)
14:20:35 <lambdabot>  Defined.
14:20:49 <roboguy_> NikolajK: if doubletype a = (a,a), then doubletype :: * -> *
14:21:00 <ski> `DoubleType' here has kind `* -> *'
14:21:00 <roboguy_> @kind DoubleType
14:21:01 <lambdabot>     Type synonym `DoubleType' should have 1 argument, but has been given none
14:21:02 <lambdabot>     In a type in a GHCi command: DoubleType
14:21:05 * hackagebot filepath 1.3.0.2 - Library for manipulating FilePaths in a cross platform way.  http://hackage.haskell.org/package/filepath-1.3.0.2 (HerbertValerioRiedel)
14:21:29 <ski> however, GHC doesn't like it if you attempt to use a type synonym without plugging all it's explicit parameters
14:21:42 <ski> which is why the above lambdabot `kind' command failed
14:22:02 <roboguy_> does lambdabot do newtypes?
14:22:05 <roboguy_> @let newtype NewDoubleType a = NewDoubleType (a, a)
14:22:06 <lambdabot>  Defined.
14:22:10 <roboguy_> @kind NewDoubleType
14:22:11 <lambdabot> * -> *
14:22:34 * ski doesn't really like naming a data constructor the same as a type constructor
14:22:38 <NikolajK> so I write "type DoubleType a = (a,a)" and then I can use "DoubleType Int" everywhere, which just gets substituted to (Int,Int)?
14:22:45 <ski> NikolajK : yep
14:22:53 <NikolajK> k, cool
14:23:07 <ski> `type' declares (possibly parametric) type synonyms
14:24:11 <NikolajK> I can't seem to infere the kind of DoubleType Int in the console
14:24:50 <NikolajK> no wait, it works
14:25:00 <NikolajK> cool
14:31:05 * hackagebot z3 0.3.2 - Bindings for the Z3 Theorem Prover  http://hackage.haskell.org/package/z3-0.3.2 (IagoAbal)
14:36:06 * hackagebot wx 0.90.1.0 - wxHaskell  http://hackage.haskell.org/package/wx-0.90.1.0 (HenkJanVanTuyl)
14:36:08 * hackagebot wxc 0.90.1.0 - wxHaskell C++ wrapper  http://hackage.haskell.org/package/wxc-0.90.1.0 (HenkJanVanTuyl)
14:36:10 * hackagebot wxcore 0.90.1.0 - wxHaskell core  http://hackage.haskell.org/package/wxcore-0.90.1.0 (HenkJanVanTuyl)
14:38:32 <eacameron> merijn: I I need to run mapConcurrently (which is not lifted) *within* my monad since my monad keeps some shared state that synchrozes the threads
14:38:53 <eacameron> *synchronizes
14:39:43 <eacameron> I can either use lifted-async I guess, or pass my synchronization around in the IO monad until I can use my monad without problems
14:41:06 * hackagebot wxdirect 0.90.1.0 - helper tool for building wxHaskell  http://hackage.haskell.org/package/wxdirect-0.90.1.0 (HenkJanVanTuyl)
14:41:09 <joelteon> lifted-async should be able to do that...
14:41:33 <eacameron> joelteon: I'm just so new to this stuff I'm scared to bring it in! ;) Can I just derive MonadBase?
14:41:47 <eacameron> I'm deriving MonadIO and such already
14:42:03 <xico> does anyone knows how to use something like -no-hs-main in ghc (the library)? i am trying Opt_NoHsMain without luck.
14:43:34 <joelteon> eacameron: you cannot derive MonadBase; there should be an instance for it already
14:43:37 <joelteon> what monad are you using?
14:44:42 <eacameron> joeltean: newtype SafeTerm = { doSafeTerm :: ReaderT (MVar MyData) IO a }
14:45:21 <joelteon> so it's just a wrapper around ReaderT
14:45:31 <eacameron> right
14:45:36 <joelteon> SafeTerm isn't a monad transformer
14:45:46 <eacameron> right...at least not yet
14:45:59 <joelteon> i'd like to see more of your code, it's hard to tell what the solution is
14:47:24 <dmj`> anyone using haskell-mode w/ cabal 1.18 sandboxes?
14:47:45 <eacameron> joelteon: https://github.com/CovenantEyes/libget-hs/blob/thread-safe-terminal/src/Main.hs#L121
14:50:06 <NikolajK> ski: you said "forall a. F a -> G a" corresponds to natural transformations. So, for all a, the F a are the objects of a category?
14:52:05 <NikolajK> ski: The type corresponds to natural transformations from the category objects of C_F to C_G?
14:53:24 <ski> NikolajK : no, operations of that type corresponds to natural transformations from the functor `F' to the functor `G' (assuming they are functors, i.e.)
14:59:14 <NikolajK> k
15:06:26 <MagneticDuck> say I define a transformation of a 2d plane as a composition of expansions and compressions in respect to lines; a "stretch" of magnitude -1 about a line is equilivant to a reflection, so I can define all of isometries, but I can also define some simple scaling transformations...
15:06:37 <MagneticDuck> is there any particular name for the set of transformations that I'm describing?
15:10:55 <MagneticDuck> guys?
15:11:33 <ski> perhaps you should try asking ##math
15:11:49 <zipper> Is typeclassopedia in any way out of date before I even bother reading it?
15:12:36 <dmj`> zipper: No
15:12:47 <dmj`> zipper: byorgey updates it
15:12:58 <zipper> dmj`: Yaaay thanks
15:13:03 <dmj`> indulge
15:13:19 <zipper> dmj`: What time is it in your land?
15:13:28 <dmj`> CST, 5pm
15:13:38 <ski> @localtime dmj`
15:13:39 <lambdabot> Local time for dmj` is Fri Mar 21 17:12:02 2014
15:14:06 <zipper> dmj`: Have a good evening then :)
15:14:13 <zipper> @localtime zipper
15:14:13 <dmj`> @localtime zipper
15:14:16 <lambdabot> Local time for zipper is Sat Mar 22 01:08:39 2014
15:14:17 <lambdabot> Local time for zipper is Sat Mar 22 01:08:39 2014
15:14:26 <dmj`> good morning
15:14:38 <zipper> dmj`: haha yeah
15:14:47 <zipper> dmj`: CST is which timezone?
15:14:54 <dmj`> Central Standard TimeZone
15:15:15 <zipper> I thought it was european for some reason. CEST is european
15:15:51 <dmj`> Chicago
15:16:08 <tristan_1> you in Chicago?
15:16:13 <dmj`> yea
15:16:30 <tristan_1> nice!
15:16:37 <dmj`> thanks.... you?
15:16:54 <tristan_1> I was till recently, now I'm in Champaign because my wife is in vet school here
15:16:58 <zipper> Who? me?
15:17:23 <pranz> Is there something like a reverse fold? I want to generate a list of type a with a starting value : a and a function f : a -> [a] -> a
15:17:25 <NikolajK> in "class  Functor f  where", is f a type constructor?
15:17:33 <dmj`> @typ unfoldr
15:17:34 <lambdabot> (b -> Maybe (a, b)) -> b -> [a]
15:17:39 <Heffalump> nik_89: yes
15:17:53 <Heffalump> sorry, NikolajK, not nik_89
15:18:12 <ski> pranz : the list is for ?
15:18:20 <ski> pranz : course-of-values-recursion ?
15:18:45 <tristan_1> got emailed recently because someone is trying to put on a Haskell day in Champaign
15:19:09 <dmj`> why wouldn't network-2.4.2.2 install on Windows?
15:19:10 <pranz> ski: hmm? I don't really get all that
15:19:52 <pranz> the type of what the function I'm searching for would be (a -> [a] -> a) -> a -> [a]
15:19:56 <dmj`> configure: error: invalid package name: 0 <=== is literally the error...
15:20:00 <dmj`> anyone every seen that?
15:20:20 <ski> pranz : yes, so i'm wondering what the first `[a]' would be for
15:20:29 <ski> @let loeb :: Functor f => f (f a -> a) -> f a; loeb ff = fa where fa = fmap ($ fa) ff
15:20:30 <lambdabot>  Defined.
15:21:16 <pranz> ski: well it would be empty initially since you haven't generated all the values
15:21:30 <NikolajK> so the closest interpretation is that types are objects of a category and the categories are the kinds?
15:22:13 <ski> @let cov f = loeb (map (\i as -> f (take i as)) [0 ..])
15:22:15 <lambdabot>  Defined.
15:22:29 <ski> > cov ((1 +) . sum)
15:22:31 <lambdabot>  [1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,2...
15:22:50 <pranz> :t loeb
15:22:51 <lambdabot> Functor f => f (f a -> a) -> f a
15:23:02 <pranz> hmm interesting
15:23:06 <ski> `loeb' isn't necessary to use here, it's just fun
15:23:34 <NikolajK> my wiki wants to correct ghci-environment to Gucci-environment
15:24:56 <Twey> pranz: (a → [a] → b → b) → b → [a] → b  is the list paramorphism; I'm not sure where you expect that a in the function to come from, but it's either the a argument or the b argument
15:25:12 <flebron> Is this a good example to showcase how Applicative differs from Monad? let comp b t f = if b then t else f in comp True <$> (Just "Yay") <*> Nothing
15:25:21 <ski> > loeb [sum . tail,length,(^ 3) . (!! 1)]
15:25:23 <lambdabot>  [30,3,27]
15:25:32 <Twey> pranz: para c n [] = n; para c n (x : xs) = c x xs (para c n xs)
15:26:09 <dwcook> flebron, well, that doesn't showcase Monad at all. To show the difference, you need to demonstrate what Monad is capable of that Applicative isn't
15:26:25 <flebron> Right, just showcasing one of Applicative's "difficulties".
15:26:33 <ski> @let leastPrimeFactor n = head [p | p <- [2 .. n],n `mod` p == 0]
15:26:34 <lambdabot>  Defined.
15:27:30 <Twey> flebron: Why's that a difficulty?
15:27:31 <ski> > take 7 (cov (leastPrimeFactor . (1 +) . product))
15:27:32 <lambdabot>  [2,3,7,43,13,53,5]
15:27:52 <ski> this is the first seven elements from an infinite list of distinct primes
15:27:59 <ski> pranz ^
15:28:10 <cdk_> I have a program I'm trying to parallelize, but GHC is GC'ing all my sparks. I can't see why, the result of the parallel computation is used immediately after so I don't see why GHC thinks the sparks aren't being evaluated. Code and comments here, the relevant function is `parFindNearest`: http://lpaste.net/101528 Can anyone help me get this working properly?
15:28:11 <flebron> Twey: That the effect of the else is run even though the branch wasn't taken.
15:28:18 <cdk_> i'm compiling with "ghc -O2 -fllvm -threaded" and running with "./RGB +RTS -N2 -s"
15:28:27 <flebron> i.e. I didn't need to return the branch or force it myself for <*> to run its computation.
15:28:27 <ski> pranz : each prime is computed as the least prime factor of : one added to the product of all the previous primes
15:28:28 <pranz> ski: thanks for all the examples
15:28:38 <Twey> flebron: Ah, I see
15:29:08 <flebron> Sorry, should've mentioned that returns Nothing :p
15:29:18 <ski> pranz : so `cov' gets a function that takes a list of all previous results generated, and is expected to generate the next result. `cov' then generates an infinite list of all the results generated
15:29:25 <pranz> but I think that wasn't what I was looking for after all now when I'm having the function
15:29:34 <pranz> gah, must learn to think like a haskeller
15:29:37 <ski> pranz : the initial result is generated by passing the empty list to the argument function
15:29:52 <Twey> flebron: I didn't realize that was supposed to be incorrect :þ
15:30:26 <ski> pranz : with `loeb', we can sortof define stuff like in a spreadsheet
15:30:31 <ski> > loeb [sum . tail,length,(^ 3) . (!! 1)]
15:30:33 <lambdabot>  [30,3,27]
15:30:56 <ski> pranz : each function will get applied to the final list, thereby they will compute the corresponding element of the final list
15:31:44 <ski> pranz : so `length' counts the number of final results (the same as the number of functions), so `3'. then `(^ 3) . (!! 1)' gets the number at index `1', which is the computed `3', and cubes it, getting `27'
15:31:53 <pranz> ski, wait, how can loeb generate a list of numbers when it only has a list of functions
15:31:57 <ski> pranz : finally `sum . tail' sums all the numbers except itself
15:32:01 <cribeiro> take 2 [1..10]
15:32:05 <NikolajK> is there any mechanism which prevents you from instantiating a member of the Functor class which doesn't fullfil, e.g. the identity law?
15:32:12 <ski> pranz : it maps over the list of functions, getting the list of results
15:32:19 <flebron> NikolajK: Nope.
15:32:25 <colDrMcBeardman> NikolajK, there is nothing to enforce class laws.
15:32:39 <ski> pranz : just replace `fmap' with `map' in the definition of `loeb', if you think it's easier to read that way
15:33:34 <colDrMcBeardman> NikolajK, however the ClassLaws package is like a QuickCheck for class laws. It doesn't provide proof but it does try to find counterexamples.
15:34:07 <pranz> ski: yeah but like, where does it get a value from? like you sum the tail of what?
15:34:09 <roboguy_> NikolajK: that sometimes wouldn't be possible in all possible cases in a Turing complete language
15:34:40 <ski> pranz : you sum the tail of the result list, which here is `[30,3,27]''
15:34:55 <pranz> aha
15:34:58 <pranz> right
15:35:00 <pranz> oh now I get it
15:35:14 <pranz> that's why you don't want it to sum itself
15:35:20 <ski> of course, it doesn't yet "know" that the first element of the result list is `30', since it's trying to compute it
15:35:25 <ski> yes
15:35:34 <ski> that'd be like saying `x = x + 1'
15:35:38 <pranz> yeah
15:35:41 <ski> > let x = x + 1 in x
15:35:44 <lambdabot>  mueval-core: Time limit exceeded
15:36:11 * hackagebot tianbar 0.3.5.0 - A desktop bar based on WebKit  http://hackage.haskell.org/package/tianbar-0.3.5.0 (AlexeyKotlyarov)
15:37:00 <ski> pranz : `loeb' is named after <http://en.wikipedia.org/wiki/Löb's_paradox>
15:41:12 * hackagebot antisplice 0.13.2.2 - An engine for text-based dungeons.  http://hackage.haskell.org/package/antisplice-0.13.2.2 (implementation)
15:41:13 * hackagebot ironforge 0.1.0.23 - A technical demo for Antisplice.  http://hackage.haskell.org/package/ironforge-0.1.0.23 (implementation)
15:41:16 * hackagebot antagonist 0.1.0.13 - A web interface to Antisplice dungeons.  http://hackage.haskell.org/package/antagonist-0.1.0.13 (implementation)
15:42:47 <Peaker> I hope FilePath becomes ByteString rather than String :(  gonna have to use "unix" APIs because all the base ones are String and slow as hell
15:44:07 <Peaker> how expensive are IO exceptions?  Would checking if files exist prior to operations be cheaper than catching IO exceptions about file missing? (this is racy, but can solve the race by also catching the exception in the rare race)
15:44:49 <dmj`> @typ doesFileExist
15:44:50 <lambdabot> Not in scope: `doesFileExist'
15:45:04 <hexagoxel> testing stuff with ConstaintKinds extension. question: is there an "empty" contraint?
15:45:10 <Cale> Peaker: I'd expect the difference in cost to be negligible, and if you find otherwise, let me know :)
15:45:45 <zomg> Cale: interesting, I would have expected it to be more expensive with exceptions, at least in OOP langs exceptions are often ridiculously expensive in comparison :P
15:45:55 <zomg> but tbh it's probably handled completely differently in haskell
15:46:16 <ReinH> Peaker: well, checking if the file exists prior is also a bug :)
15:46:33 <Peaker> ReinH: note the comment I added in parens
15:46:40 <ReinH> Peaker: :)
15:46:46 <Cale> It'd also be a whole other file operation
15:47:05 <Peaker> Cale: an extra system call, yeah
15:47:48 <Welkin> does haskell even have anything equivalent to exceptions?
15:47:52 <Cale> Welkin: yes
15:47:56 <hexagoxel> or asked differently: is there any x, so that "forall y . instance x y"
15:47:59 <Cale> See Control.Exception
15:48:50 <colDrMcBeardman> Welkin, you implement recovery with handle
15:48:56 <colDrMcBeardman> @type handle
15:48:56 <lambdabot> Exception e => (e -> IO a) -> IO a -> IO a
15:49:18 <Cale> @type try
15:49:19 <lambdabot> Exception e => IO a -> IO (Either e a)
15:50:00 <colDrMcBeardman> haskell is the first language I saw where exceptions weren't horribly broken.
15:50:41 <dmj`> Is anyone using haskell-mode w/ cabal sandboxes w/ success?
15:51:03 <Welkin> what is the best haskell learning resource after finishing learnyouahaskell?
15:51:12 * hackagebot rope 0.6.4 - Tools for manipulating fingertrees of bytestrings with optional annotations  http://hackage.haskell.org/package/rope-0.6.4 (EdwardKmett)
15:51:18 <dmj`> Welkin: typeclassopedia, real world haskell and parallel and concurrent programming
15:51:22 <Cale> Welkin: Maybe try Simon Marlow's book on concurrency
15:51:28 <NathanC> Does anyone know how I could have an IO() function that blocks until a key is depressed,and then returns that char?
15:51:29 <Peaker> Cale: "try" is a bit dangerous, because unlike "catch" and "finally" and friends, it doesn't have a way to mask async exceptions in your exception handler, so exposed to all kinds of concurrency bugs
15:51:29 <tristan_1> Welkin: maybe http://book.realworldhaskell.org/
15:51:32 <ski> colDrMcBeardman : ooc, which languages with exceptions had you seen before ?
15:51:49 <dmj`> NathanC: getChar?
15:51:55 <Cale> Peaker: Well, that's a decent point, though it's often sufficient.
15:51:56 <Peaker> colDrMcBeardman: Haskell exceptions seem pretty much the same as in other languages?
15:52:06 <Welkin> thanks
15:52:11 <NathanC> dmj`: I mean without waiting for the user to press enter
15:52:59 <hexagoxel> NathanC: iirc the enter thingy is a flushing problem
15:53:07 <heatsink> NathanC: It should work if you set the input to unbuffered mode
15:53:21 <colDrMcBeardman> I was thinking in particular Java.
15:53:27 <hexagoxel>      hSetBuffering stdin NoBuffering
15:53:37 <hexagoxel> NathanC: ^
15:53:59 <NathanC> I've heard that doesn't work well under windows?
15:54:44 <hexagoxel> dunno
15:55:19 <NathanC> Well, it works splendidly on linux, thank you. :)
15:55:34 <colDrMcBeardman> Peaker, the difference vis-a-vis many other implementations is in haskell it's more like registering handler functions with a wrapper than it is some ugly non-local return hack.
15:55:56 <Peaker> colDrMcBeardman: it's the same way in Python, except it has special syntax in Python
15:56:23 <colDrMcBeardman> Peaker, I've never touched python, but that's for other reasons.
15:56:25 <Peaker> Cale: in my case, btw, it's only an extra syscall if the file exists (most files don't, I think) -- and indeed, without exceptions (and with extra "access" check to speed up the non-existing case) it's actually slightly faster :(
15:56:52 <Peaker> colDrMcBeardman: Well, same as C++ too (if you ignore C++'s broken "throws" clauses)
15:57:24 <colDrMcBeardman> yes, I thought C++ went without mentioning, only because it doesn't seem to get anything right.
15:57:33 <colDrMcBeardman> poor Bjarne. I'm sure he tried as hard as he could.
15:58:01 <Welkin> or he is just a major troll
15:58:10 <Welkin> and the joke is on us
15:58:32 <colDrMcBeardman> Welkin, I'd feel a lot better about the human race if he were. actually, there was a joke fake interview the labs guys posted along those lines.
15:58:34 <colDrMcBeardman> they did not like him.
15:58:35 <Peaker> colDrMcBeardman: I mean C++ has special syntax for "try/catch" and silly semantics for the optional "throws" clauses, but otherwise is the same as Haskell exceptions?
15:58:36 <Twey> It's just that C++ has been developed incrementally
15:59:03 <Welkin> colDrMcBeardman, I read that interview -- it was great
15:59:06 <Twey> Most of the features make sense in themselves; they just haven't been thought out with respect to their interactions with the rest of the language
15:59:06 <benzrf> hej da
15:59:31 <colDrMcBeardman> Peaker, I don't think so. they're very much a non-local return in C++
15:59:55 <colDrMcBeardman> Welkin, haha glad you know what I'm talking about. comedic gold.
15:59:58 <Peaker> colDrMcBeardman: you "register handlers" by specifying "catch {}" clauses
16:00:04 <Twey> colDrMcBeardman: ‘Ugly non-local return hack’ — you mean implicit delimited continuation, right? :þ
16:00:07 <Peaker> colDrMcBeardman: much like in Haskell?
16:00:19 <Peaker> colDrMcBeardman: not sure I see the difference
16:00:43 <colDrMcBeardman> Peaker, catch clauses aren't functions.
16:01:40 <Peaker> colDrMcBeardman: it's a superficial difference..
16:02:06 <Peaker> Haskell has them as functions because they're implemented as libraries and not baked in (and probably because it's slightly more flexible)
16:02:26 <colDrMcBeardman> also IIRC you have the same problem as in Java where you have to eat a lot of copy-pasta if the same code handles different exceptions. Although maybe I remember a way to specify multiple exception types in one catch clause.
16:03:08 <Peaker> you can extract common code out to common functions, like you'd do in Haskell with separate `catch` clauses?
16:11:22 <Averell> there is "multi-catch" since java 7
16:17:04 <Averell> [1,1,2,2,3,3]
16:23:45 <jtcwang> Hi people, if I have a "function" which doesn't take any input, and gives me an output, does haskell cache it?
16:24:14 <jtcwang> basically, i'm generating a table/list through a formula, but i don't want it to be recalculated everytime
16:24:27 <Twey> jtcwang: If it doesn't take an input then it's not a function… and yes, it'll be ‘cached’ (multiple references to the value will only calculate it once)
16:24:36 <Twey> It's more often called ‘memoization’
16:25:48 <jtcwang> cool. yeah i saw that during my research but it involved some additional construct/types
16:25:58 <jtcwang> good to know, thank you
16:27:23 <conal> a subtlety: functions are also cached by default (as with all types), but their applications aren't.
16:28:12 <conal> i.e., if there's some work to be done in coming up with the function itself, that work won't be repeated.
16:28:56 <conal> hm. difficult to express such things unambiguously.
16:30:29 <zq> is there a way to equationally expand a given call to a function?
16:31:29 <zq> in ghci, that is. for instance :expand f 3 4 = g (h 3) (h 4) = ...
16:34:21 <Twey> zq: You can use benmachine's stepeval: https://github.com/bmillwood/stepeval
16:35:17 <Twey> It's quite incomplete, but might be good enough for learning purposes
16:38:10 <NathanC> can I make an Int touple (Int,Int) orderable?
16:38:18 <NathanC> I want to use it as a map key
16:38:25 <NathanC> for placement in a 2d matrix
16:38:46 <Iceland_jack> > (4, 10) > (4, 15)
16:38:47 <lambdabot>  False
16:38:54 <Iceland_jack> NathanC: ↑ is that what you're looking for?
16:38:59 <NathanC> Yeah, I just realized, thanks :)
16:39:04 <Iceland_jack> :)
16:39:06 <NathanC> I wasn't expecting it to already be orderable
16:39:09 <NathanC> That's highly useful
16:39:30 <Iceland_jack> Yes it is
16:39:40 <NathanC> Ah, haskell is so refreshing. I've build a multithreaded, platform-independed terminal app, with realtime user-input, in about an hour
16:39:43 <NathanC> it's so natural
16:40:01 <Taneb> :)
16:40:14 <NathanC> Especially Control.Concurrent. MVars are excellent
16:42:08 <NathanC> Any stylistic tips on parsing Maybes?
16:44:15 <colDrMcBeardman> Peaker, there are some similarities in the syntax, but the handlers aren't first-class. You don't and can't have things like "catches"  or "catchJust". Also exceptions in C++ can cause leaks. Yikes.
16:44:32 <colDrMcBeardman> oh... i guess he's not here anymore.
16:52:01 <MagneticDuck> is there a cool way to browse haddock documentation via a commandline program?
16:53:37 <MagneticDuck> well I could use lynx or something I suppose...
16:54:40 <colDrMcBeardman> MagneticDuck, I wish there were something in hoogle cli that would print out a link to the locally-installed docs :(
16:54:49 <colDrMcBeardman> and that cabal could update my hoogle db.
16:55:30 <colDrMcBeardman> as someone who doesn't use a heavyweight like vim or emacs and lives in a "dumb" terminal, those would be a godsend.
16:58:21 <Twey> colDrMcBeardman: Heavyweight… vim?  Do you edit your files with cat and sed?
16:58:32 <colDrMcBeardman> Twey, sam and/or ed
16:58:38 <Twey> Interesting
16:59:29 <hpc> i edit all my files with dd
17:00:53 <colDrMcBeardman> Twey, vim.basic on my machine is 2.2 megs statically linked. the two parts of sam are 1.5 statically linked ;-)
17:00:59 <thebnq> i edit files with printouts -> whiteout -> Ink -> scan/ocr :]
17:01:13 <Twey> colDrMcBeardman: Not even a whole (decimal) order of magnitude!
17:01:53 <colDrMcBeardman> Twey, the core is 484K
17:01:53 <Twey> MagneticDuck: haskell-mode for emacs has a C-c C-d binding to find haddock documentation for the symbol under point
17:02:19 <Twey> MagneticDuck: I don't know how well it works
17:02:43 <Twey> Pretty well, it seems
17:03:00 <colDrMcBeardman> Twey, plus there's always good ol' ed. 48k.
17:03:28 <Twey> … what
17:03:40 <Twey> My /bin/ed is smaller than my /bin/cat
17:03:47 <Twey> Oh, busybox, okay
17:03:48 <colDrMcBeardman> I'm guessing that's due to dynamic linking
17:03:53 <colDrMcBeardman> on mine.
17:04:01 <Twey> Wait, no it isn't
17:04:34 <Twey> 52K /bin/cat   48K /bin/ed   76K /bin/sed
17:04:36 <Twey> Weird.
17:04:43 <MagneticDuck> :D
17:04:49 <MagneticDuck> ed is fuckin' small
17:05:09 <Twey> 32K /bin/echo -- well, at least echo beats it
17:05:22 <MagneticDuck> xD
17:05:40 <colDrMcBeardman> cat and ed are the same size on my system. gnu bloat.
17:06:09 <colDrMcBeardman> MagneticDuck, statically compiled, it would be more like 288k
17:06:36 <colDrMcBeardman> (going off the plan 9 ed, which is about the same as unix ed)
17:08:26 <MagneticDuck> ops, I'm tired and not very good at the terminal.. why does grep {cat, echo, sed} not work in the way I think it should?
17:08:50 <zq> bash expansion
17:08:51 <MagneticDuck> isn't that.. isn't that how you make a regex that that matches either cat, echo or sed?
17:08:55 <MagneticDuck> quotes then?
17:09:02 <thebnq> hehe yi is 49MB here
17:09:21 <MagneticDuck> sasjdkf;lasdfjkl; <-- frusturation with bash
17:10:27 <zq> my posix regex is rusty, but i think it'd be (cat|echo|sed)
17:10:27 <Twey> MagneticDuck: grep {cat, echo, sed} expands to grep cat  echo sed
17:10:36 <Twey> Yeah, that's not regex anyway
17:10:36 <zq> MagneticDuck: ^
17:10:46 <MagneticDuck> Twey: ._.
17:10:54 <MagneticDuck> what am I thinking of...
17:11:01 <Twey> The regex use of {} is for repetition.  x{n,m} matches between n and m xs
17:11:06 <MagneticDuck> jahk
17:11:24 <MagneticDuck> reading the grep man pages xD
17:11:32 <MagneticDuck> I think I'm tired
17:11:41 <Twey> Sorry, I meant grep "cat" " echo" " sed"
17:12:56 <zq> egrep '(cat|echo|sed)'
17:14:35 <Iceland_jack> $ echo haskell{1,2,3,foo,bar}
17:14:35 <Iceland_jack> haskell1 haskell2 haskell3 haskellfoo haskellbar
17:16:03 <MagneticDuck> Iceland_jack: no...
17:16:10 <MagneticDuck> uh
17:16:15 <MagneticDuck> oh, globs
17:16:18 <MagneticDuck> or whatever they're called
17:16:24 <MagneticDuck> I should shut up and get some rest
17:16:29 <MagneticDuck> :D
17:17:22 <Iceland_jack> MagneticDuck: Brace expansion :) no globbing
17:17:43 <MagneticDuck> right.
17:17:45 <Iceland_jack> What was the ‘no...’?
17:17:46 <MagneticDuck> shell expansion.
17:18:06 <MagneticDuck> ...
17:18:38 <MagneticDuck> (at first didn't think that would work)
17:18:54 <Iceland_jack> ah okay, never mind
17:19:40 <Hafydd> $ echo haskell{curry,prime,platform,blah}
17:19:40 <Hafydd> haskellcurry haskellprime haskellplatform haskellblah
17:20:05 <Iceland_jack>     $ cp filewithlongname{,backup}
17:20:28 <Hafydd> cp filwithlongname{,nowwithevenlongername}
17:20:55 <zq> it's not globbing at all
17:21:22 <MagneticDuck> zq: yeah
17:21:28 <geekosaur> globbing = filename generation, pedantically
17:21:40 <zq> geekosaur: correct
17:22:15 <zq> echo {1..23}
17:22:15 <zq> 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23
17:24:16 <NathanC> I'm trying to decide how to implement something. I have a 2d array of entities, contained in a map. The key to the map is the Touple (x,y) that gives their location. I want to iterate through the map, giving each entity a turn. However, I want the entities to be able to *destroy other entities*. So the nth entity could delete any entities in the map, but I want to keep iterating through the undeleted entities. How could I do this?
17:25:10 <Hafydd> Sounds like a fold.
17:27:10 <NathanC> If I'm folding through a data structure, am I able to have early elements in the fold delete later elements, so they won't be included in the fold?
17:27:14 <NathanC> I'm rusty on folds
17:27:55 <MagneticDuck> "ignoring" some elements can be part of the accumulation value
17:28:51 <Hafydd> I rather thought that you'd iterate through the indices.
17:29:29 <Hafydd> It could also be done by having the elements lazily computed based on a list of destroyed entities, too, though.
17:30:45 <Hafydd> ...I suppose that would be hard to do properly, though.
17:31:32 <flebron> Are all free theorems the naturality conditions on some natural transformation, which is given by a function's polymorphism?
17:31:48 <Ralith> NathanC: Haskell is pure. You can't remove data from an Array.
17:32:03 <NathanC> I'm not using an array
17:32:08 <NathanC> I'm using a Map
17:32:14 <Ralith> "I have a 2d array of entities"
17:32:21 <NathanC> Abstractly
17:32:24 <Ralith> but you can't remove data from a Map either
17:32:33 <Ralith> because haskell is pure
17:32:43 <NathanC> Well, I can return an altered map
17:32:54 <gauthier> trying to play with https://github.com/ghorn/cplex-haskell/blob/master/cplex/cplex.cabal on windows, I tweaked the .cabal to point at lib folder and get it to compile install, but when running the Example.hs, the program just crashes with no output of any kind
17:32:57 <NathanC> even though the structure isn't per-say mutable
17:33:28 <hpc> gauthier: is there no terminal output either?
17:33:37 <Ralith> NathanC: yes, but that isn't typically going to affect your fold
17:33:40 <gauthier> hpc: no output at all
17:33:58 <NathanC> How do you think I should go about approaching this problem?
17:34:10 <gauthier> hpc: I'm running it with runhaskell and when I attach debugger, it's in ghc.exe
17:35:15 <hpc> yeah, runhaskell is a wrapper for ghc itself
17:35:45 <hpc> hmm
17:35:48 <gauthier> hpc: actually when I run ghc to compile it I get : http://lpaste.net/101578
17:36:20 <gauthier> which seems to indicate that linking somehow went wrong
17:37:16 <hpc> yes
17:37:20 <hpc> hmm
17:37:33 <gauthier> hpc: let me get another round at it
17:37:47 <hpc> everything it mentions is foreign import
17:37:54 <hpc> from cplex.h
17:38:31 <pavonia> Don't you need the --make flag?
17:39:52 <hpc> --make is implied now
17:40:47 <hpc> and it just means to do the things you would expect anyway
17:40:58 <hpc> compiling imports automatically, etc
17:41:14 <hpc> (afact, ghc man is not tremendously detailed on the flag)
17:41:49 <gauthier> I think I got some file versions mixed up in my first run, now it fails to compile http://lpaste.net/5472777861209260032 if that's familiar to anyone that would help
17:43:24 <hpc> that's getting too far into lower-level languages for me to be helpful
17:45:12 <colDrMcBeardman> gauthier, I don't touch windows, but this post may be helpful:
17:45:13 <colDrMcBeardman> http://mingw.5.n7.nabble.com/Linking-Error-with-MSVC-6-0-td18263.html
17:48:24 <gauthier> colDrMcBeardman: thanks, I'm going to check which runtime is linked by cplex and see how to get that linked in the binding too (I assume that what it should do)
17:50:01 <colDrMcBeardman> gauthier, if you ahve a newish msvc runtime, try linking in that. if not, I would just write a stub.c with that function and a return 0; and link that.
17:50:11 <colDrMcBeardman> or use unix :-P
17:58:35 <flebron> Where should I get an implementation of dynamorphisms from? It seems the package pointless-haskell isn't maintained much (in the past 5 years).
17:59:16 <zq> man
17:59:31 <zq> how does it make sense to have a typeclass decl over anything that isnt' kind *?
18:01:17 <Twey> zq: Easily, see Functor
18:01:56 <zq> Twey: that's my point
18:02:21 <Twey> There are lots of instances where you don't care about the type ‘inside’ the structure, just the structure itself
18:03:21 <uiop> newtype T a = T Int; instance Functor T where fmap f (T a) = T a
18:03:22 <zq> Twey: so i guess the full definition would be class Functor f a where
18:03:37 <Twey> zq: No, just class Functor f where…
18:03:41 <monochrom> no, the full definition is "class Functor f where"
18:04:07 <zq> how does the type checker not freak out?
18:04:11 <zq> it's * -> *
18:04:17 <zq> no, not even
18:04:27 <monochrom> it keeps calm and doesn't freak out
18:04:33 <zq> for an arbitrary type decl you have no way of knowing what kind the type variable is
18:04:39 <zq> typeclass decl*
18:04:40 <monochrom> more seriously, I don't understand your question.
18:04:41 <Twey> zq: The a doesn't enter into it — if you write an instance for (f a) instead, then you're restricted to only talking about (f a) inside the class
18:04:53 <Twey> zq: And in fact the definition of fmap requires that you also be able to talk about (f b)
18:04:54 <uiop> zq: what would be nice in the sense that you could give a Functor instance that needs another instance constraint on the "a"
18:05:31 <Twey> uiop: That's no longer a valid Functor instance
18:05:35 <uiop> oh yeah, you'd need "b" too
18:05:35 <monochrom> the type "(a -> b) -> f a -> f b" permits kind inference. f's kind is obviously *->* and obviously inferrable
18:05:39 <zq> i think my last sentence is the crux of my problem
18:06:06 <Twey> uiop: The functor laws effectively require that your instance is blind to the type inside
18:06:21 <Twey> zq: I don't understand why you think that would be a problem
18:06:53 <Twey> zq: In a function like id, you have no way of knowing what type the function variable is
18:07:07 <Twey> It's the same thing, just bumped up a level ☺
18:07:19 <monochrom> if I knew which paper has the theory, I would point you to it. a soundness proof is why it makes sense and the compiler doesn't freak out.
18:08:03 <uiop> Twey: yes this is all nice, but it is annoying having to use Set.map
18:08:27 <uiop> or insert your favorite case of this
18:12:11 <uiop> zq: the kind of each type variable in a class declaration is fixed when the class is defined (the compiler may make a cursory effort to infer the kind, but it's not required to be thorough)
18:12:13 <Twey> Hm
18:12:16 <NathanC> Are there non-binary semaphores that are like MVars?
18:12:20 <Twey> uiop: You can make Set a Monofunctor
18:12:23 <Twey> At least
18:14:09 <triliyn> What is a Monofunctor?
18:14:15 <monochrom> NathanC: there was Control.Concurrent.QSem, but it's deprecated, it says "Please use an alternative, e.g. the SafeSemaphore package, instead"
18:14:30 <Twey> triliyn: A functor that isn't polymorphic in its type parameter
18:16:53 <Hafydd> NathanC: this is something like what I meant: http://lpaste.net/101579
18:20:43 <NathanC> Hafydd: Thanks, that's really helpful!
18:23:27 <Twey> uiop: You can also write a RestrictedFunctor class, but it requires FlexibleInstances and MultiParamTypeClasses
18:24:47 <Twey> It's not and shouldn't be part of Functor, though, because it's not a functor (there are objects b such that you can't have fmap ∷ (a → b) → Set a → Set b)
18:25:08 <zq> how do you type those unicode glyphs?
18:25:12 <zq> such magic
18:25:41 <shergill> ,ping
18:26:03 <shergill> ,ping
18:26:11 <shergill> oops sorry
18:26:39 <Hafydd> He copies and pastes them from Wikipedia.
18:26:54 <zq> i was hoping that wasn't the case
18:27:46 <Twey> Hm
18:28:22 <Twey> uiop: Actually, I guess it *is* a functor, and even an endofunctor, but not over (all of) Hask
18:28:25 <geekosaur> usually there's some way to define keys to do it
18:28:55 <Twey> zq: I have a third-level layout, a compose key, and a TeX input method, for varying levels of convenience
18:29:51 <Twey> zq: I mostly type Haskell characters with my compose key (Compose : : produces ∷, Compose - > produces →, Compose * * produces ★, Compose A L produces ∀)
18:30:46 <Hafydd> What advantage does ★ even have over *?
18:31:12 <zomg> I would imagine that to be easier if there was an IME for custom characters =)
18:31:20 <zomg> in style of the japanese IME
18:31:36 <Twey> I wonder if it makes sense to have a kind of types that have a particular instance
18:31:45 <zomg> was actually looking into that at one point, ways to build a custom IME for some stuff but I really couldn't find anything on that
18:31:46 <Twey> I guess you'd need subkinding
18:32:12 <Twey> zomg: If you use UIM, it has a pretty simple Scheme-based IME definition
18:32:16 <Twey> You can easily customize it
18:32:26 <Twey> Hafydd: It doesn't look as silly :þ
18:32:32 <zomg> I'd imagine that's some kind of unix beard program which doesn't work on Windows
18:32:35 <zomg> =)
18:32:42 <Twey> And encourages people to hurry up and support Unicode properly already
18:32:51 <Twey> zomg: I'm told you can use AutoHotKey on Windows
18:33:05 <zomg> Yeah having it convert -> into the little arrow would certainly do the trick
18:33:09 <Twey> Which has an embedded custom configuration language from hell
18:33:30 <zomg> Don't really wanna do it since it seems like it would be a PITA to configure everything to show and input them properly
18:33:31 <Hafydd> Twey: presumably you're trying to make your IRC text look more like handwritten symbols, and nobody handwrites a five-pointed star unless they have to.
18:33:45 <zomg> like the example you gave for Compose : :, my IRC client doesn't even show that correctly even though it has unicode support :P
18:33:49 <zomg> Probably just a bad font or something
18:34:18 <Twey> Hafydd: Nonsense; any teenage schoolgirl can tell you five-pointed stars are easy to draw and make great tittles
18:35:10 <Hafydd> I always decorate my proofs with hearts and stars.
18:35:33 <Twey> Hafydd: But I care more about the distribution of colour than whether it looks like handwriting or not.  * bothers me because it's too high off the baseline, and -> bothers me because the head is far too big for the tail
18:35:47 <Hafydd> What is a tittle? That sounds vaguely sexual.
18:36:08 <zomg> tittle is the dot on top of an i
18:36:11 <Twey> Hafydd: A small, separate stroke that's part of a character, like the dot of an ‘i’
18:36:18 <Hafydd> I see...
18:36:21 <zq> til
18:36:25 <geekosaur> jots and tittles...
18:36:45 <zomg> yeah what a coincidence that I think I saw that on imgur just the other day
18:36:54 <zomg> and I swear nobody EVER used that word before at least when I was around!
18:36:56 <zomg> =)
18:37:01 <Twey> Hehe
18:37:10 <geekosaur> it's kinda fallen out of use, yeh
18:37:22 <Twey> Which is a shaem.  It's a brilliant word.
18:37:33 <zomg> haha yeah
18:39:03 <Twey> Hafydd: * also has the disadvantage that it's commonly used for multiplication and repetition in a similar context.  ★ is convolution, but that's not nearly as commonly found in conjunction with types.
18:40:01 <Hafydd> FYI, there is 2217 ∗ asterisk operator
18:40:12 <Hafydd> But that looks even worse in terminus, at least.
18:40:27 <Twey> That looks significantly better in my font than *
18:40:39 <Twey> But ★ has the advantage of being valid GHC
18:40:43 <Hafydd> 26B9 ⚹ sextile looks beautiful, however.
18:40:49 <zq> i see a box
18:40:59 <zq> such beauty
18:41:39 <Twey> ＊ would work too.
18:41:41 <colDrMcBeardman> Hafydd, the holes in letters like e and a are called counters. quite a bit less sexy than a tittle.
18:43:00 <flebron> What's an example of a Functor which isn't a "container", and isn't Const k or (->) r?
18:43:23 <Twey> flebron: Store?
18:43:56 <Hafydd> I suppose my complaint is with whoever approved those characters for GHC, then.
18:44:26 <Twey> Well, I suppose Store is kind of like (r →)
18:44:29 <Twey> Hafydd: Why?
18:44:58 <colDrMcBeardman> there's also , which depending on your typeface is not hard to confuse with x
18:45:20 <colDrMcBeardman> although you were talking about kind annotations?
18:45:22 <Hafydd> Twey: because ★ looks stupid.
18:45:44 <zomg> On my font that looks like 2/3rds of a filled 5 pointed star..
18:45:48 <Twey> flebron: Const, maybe
18:45:51 <zomg> not a full star, but 2/3rds...
18:45:52 <zomg> :D
18:46:00 <flebron> Twey: "That isn't Const" :p
18:46:08 <Twey> Oh, sorry, forgot about that bit
18:46:34 <flebron> Twey: I'm going to be giving a talk on typeclassopedia for a seminar in uni, and I wanted to be sure I had the right "notion" for all of the typeclasses.
18:46:47 <Twey> flebron: There are plenty of weird-ass monads with Functor instances
18:46:49 <flebron> Save for Const k which one could call pathological, (->) r is the only other one I know which isn't a container.
18:46:57 <Twey> Cont, for example
18:47:06 <Twey> Or the reverse state monad
18:47:12 <johnwalker> sorry, basic question - how can i call a function n times, collecting its results?
18:47:17 <Twey> Not sure if that counts as a ‘container’ or not
18:47:28 <Twey> > take 5 $ iterate (+ 2) 0
18:47:32 <lambdabot>  mueval-core: Time limit exceeded
18:47:34 * flebron checks out Cont's Functor instance
18:47:38 <Twey> Dammit lambdabot
18:47:59 <johnwalker> ahh, well i don't know if its iterate
18:48:01 <flebron> The issue is sometimes I've forgotten how to understand it without a bunch of arrows :p
18:48:12 <flebron> (And this seminar is supposed to be for semi-general, intra-uni public)
18:48:19 <johnwalker> will that yield 2, 4, 6, 8, or 2, 2, 2, 2?
18:48:22 <Twey> flebron: I have no idea how Cont works :-D
18:48:25 <johnwalker> sorry, i know its neither of those
18:48:31 <johnwalker> but basic idea-wise
18:48:40 <Twey> johnwalker: [0, 2, 4, 6, 8]
18:48:49 <flebron> instance Functor (Cont r) where
18:48:50 <flebron>     fmap f m = Cont $ \c -> runCont m (c . f)
18:48:52 <johnwalker> what if i wanted [0,0,0,0,0]?
18:49:07 <Twey> > replicate 5 0
18:49:08 <lambdabot>  [0,0,0,0,0]
18:49:18 <Twey> There's no point putting that in a function
18:49:19 <johnwalker> but i want to use the function (+ 2)
18:49:23 <Twey> Err
18:49:26 <Twey> Use it how?
18:49:34 <triliyn> > (replicate 5 . (+2)) 0
18:49:35 <lambdabot>  [2,2,2,2,2]
18:49:43 <johnwalker> i want to call (+ 2) 5 times
18:49:50 <Twey> > map (+ 2) $ replicate 5 (-2)
18:49:50 <flebron> Right, (Cont r) a "waits for" an a, and gives you an r, since it's just (a -> r) -> r.
18:49:51 <lambdabot>  [0,0,0,0,0]
18:49:58 <Twey> johnwalker: There's absolutely no point in doing that in Haskell
18:50:16 <johnwalker> i'm using random numbers
18:50:31 <johnwalker> actually, i'm generating random numbers from a function
18:50:40 <Hafydd> What function is it?
18:50:50 <Twey> johnwalker: If you have a list of numbers, you can map (+ 2) over it
18:51:01 <johnwalker> randomChar :: IO Char
18:51:07 <Twey> johnwalker: That's not a function
18:51:13 <johnwalker> oh :x
18:51:15 <triliyn> You want replicateM though
18:51:22 <johnwalker> is it a monad?
18:51:24 <johnwalker> lol
18:51:25 <Twey> johnwalker: It's an IO action (note the lack of an arrow in the type)
18:51:54 <flebron> IO is a monad, IO Char is just some type
18:52:04 <Twey> You can ‘replicateM $ fmap (+ 2) randomChar’
18:52:15 <Twey> Er
18:52:18 <Twey> You can ‘replicateM 5 $ fmap (+ 2) randomChar’
18:52:25 <Hafydd> Your question should therefore have been "How can I run an IO action n times, collecting its results?"
18:52:44 <johnwalker> yes
18:52:58 <johnwalker> ok, i will educate myself
18:53:01 <johnwalker> thanks for the help guys
18:54:04 <Twey> johnwalker: I generally prefer to use the ‘randoms’ function to get an infinite list of random values, then thread it through pure code
18:54:28 <Twey> johnwalker: Then you can just ‘map (+ 2) randomNumbers’ as normal
18:55:15 <johnwalker> thats a better way to handle it
18:55:38 <johnwalker> i actually just wanted a random element "function"
18:55:51 <johnwalker> umm, now i know more about what i actually wanted
18:56:03 <Twey> If you just want a small fixed number, carry on with replicateM, I guess
18:56:27 <Twey> But be aware that replicateM will store all the values in memory at once, so if you have a lot (or a variable number) it's often not a great idea
18:57:21 <Twey> http://hackage.haskell.org/package/MonadRandom-0.1.3/docs/Control-Monad-Random.html — the Random monad is a more convenient interface to randomness
18:57:34 <Twey> (but probably overkill if you just want five random characters)
18:58:46 <Twey> flebron: Oh hey, there's an easily-motivated non-container functor for you
18:59:06 <johnwalker> ahh, i'm not actually worried about memory so much
18:59:10 <Twey> flebron: Also: IO!  Duh!
18:59:17 <flebron> Ah yes, that's the weird monad-derivation thing
18:59:24 <flebron> Oh, right!
18:59:29 <flebron> And for similar reasons!
18:59:32 <Twey> Indeed
18:59:45 <Twey> How about Parsec
19:00:19 <Twey> Or FRP Events and Behaviours
19:01:07 <flebron> y'know, it's sort of embarassing but I just never had to do parsing in Haskell :p I suppose that's one of the reasons why I'm not comfortable with Applicative.
19:01:23 <Twey> Events are *just* Functors, unlike the other examples that are Monads
19:01:32 <Twey> Behaviours are Applicatives
19:03:43 <Twey> flebron: Applicative is just a kind of lifted function application.  So Parsec gives you f ∷ a → b → c, x ∷ Parser a, y ∷ Parser b ⊢ f <$> x <*> y ∷ Parser c
19:04:24 <flebron> Right, yeah, I know the typeclass, but I'm not comfortable in the sense that I have no good analogies, except "every effect gets carried out before application of the pure values".
19:04:37 <flebron> But that is a pretty crappy mental image, because "effects" isn't well-defined.
19:05:13 <Twey> Well, that's my intuition for it
19:06:00 <Twey> It's nice because you can do things like parsePair = (,) <$> parseTerm <*> parseTerm
19:09:18 <flebron> Twey: This is a dumb question perhaps but what's the "effect" in a Parser a?
19:10:18 <Twey> flebron: It's kind of like (r →) — the ‘effect’ is the parsing of the string to get the a
19:10:35 <Twey> So the function is applied to the result of that
19:10:37 <flebron> And what does it "do" to the string?
19:10:59 <Twey> flebron: Parses it :þ
19:11:07 <Twey> ‘Effects’ aren't really a good analogy, I think
19:11:16 <flebron> But does it return the string without a prefix, for instance?
19:11:21 <geekosaur> it's more like a state monad where the state is the parse position
19:11:23 <Twey> Oh, right
19:11:24 <Twey> Yes, it does too
19:11:32 <Twey> Yes, mea culpa
19:12:01 <flebron> So the parsing of the second parseTerm doesn't start until the first parsing is finished, then
19:12:22 <flebron> But it always happens, the (,) doesn't get a chance to not-parse one of the terms
19:12:40 <flebron> Or to parse it and do something else with it, or something like that.
19:12:55 <flebron> (Which it would if this were a monad, since it's receive the two actions parseTerm to run whenever and however it wanted)
19:12:59 <Twey> flebron: Right
19:12:59 <flebron> *it'd
19:14:18 <flebron> My "motivating" example is Simon Marlow's talk on how Facebook internally uses an Applicative as a data-gathering DSL, sine each source of data should be able to run in parallel, and not affect eachother
19:14:43 <Twey> flebron: Er, more precisely, if it were a monad it would be able to decide whether or not to parse the second term based on the value of the first term
19:14:43 <flebron> i.e. reading a log should not be affected by reading from a memcache or reading from some database, these should all statically be deduced to be runnable in parallel
19:14:49 <flebron> Right
19:14:58 <Twey> (it is a monad, but ignore that for now :þ)
19:15:08 <flebron> Oh, is that why it's context-dependent vs context-independent?
19:15:19 <Twey> Yes
19:15:36 <flebron> You branch out based not only on a nonterminal you just matched, but on some possible terminals which you also matched
19:15:40 <Twey> flebron: So, the core idea behind Simon M's Haxl project is that he provides a Haxl type with an Applicative instance and a Monad instance… but the instances are *different*
19:16:12 <Twey> flebron: For the Monad instance he runs the first action, and provides the result to the second action, as usual
19:16:44 <Twey> flebron: But for the Applicative instance, because he knows the second action will be run just so regardless of the result of the first action, he's free to run them both at the same time
19:16:45 <flebron> Hrm, so I suppose programmers will live in the Monadinstance (via do notation), but sometimes use its <*>?
19:17:31 <Twey> Or possibly the other way around
19:17:43 <colDrMcBeardman> I'm trying to get RTS profiling wedged into my .cabal file and I'm utterly stuck. I need to be able to run some driver code that calls all the functions I want to profile with RTS options, and then run hp2html and prof2pretty on the result
19:18:27 <colDrMcBeardman> cabal doesn't let me build two executables in a single benchmark section.
19:19:56 <Twey> flebron: That's the difference between Monad and Applicative — if you have an Applicative then you know *in advance* what actions will be executed later, whereas with a Monad the later actions are a function of the results of the earlier action, so they must be run in order
19:20:36 <flebron> Right, so the pure function you have in an applicative only gets provided the results of these computations, "all at once", after all their effects have run?
19:20:44 <Twey> Right
19:20:54 <flebron> Whereas in a monad each sequencing has the option of running some side effect, based only on the first computations given to it.
19:21:10 <flebron> i.e. a <- foo, {do something}, b <- bar, { do something }
19:21:33 <flebron> (Which may include not running bar entirely, or giving different parameters to bar)
19:21:41 <Twey> Or:  do b ← getABoolFromSomewhere; if b then runSomething else return ()
19:21:54 <Twey> Right
19:22:06 <flebron> Right, that's the "cond" example I had earlier to showcase one of the "shortcomings" of Applicative :)
19:22:40 * Twey nods.
19:22:55 <flebron> I'm still undecided whether to introduce the categorical notions or not. Many of the people will be first year students, so I guess I'll just have Functor defined semi-properly and that's it. Definitely no need for natural transformations or pointed functors
19:23:37 <flebron> But I will borrow from Kleisli and have monads be (join, return) instead of (bind, return), I find the former much cleaner, if less used in practice.
19:24:10 <flebron> That way I can handwave and say "See? It's a monoid! join . return = return . join = id, and join . join = join . fmap join!")
19:24:32 <foozbaz> i have a Foreign.Ptr to a block of mmap'd memory ... how can i put a bytestring into the memory?
19:25:13 <zq> man
19:25:18 <zq> you guys are having so much fun with haskell
19:25:20 <foozbaz> is it necessary to iterate over the bytestring, calling "pokeByteOff"
19:25:22 <foozbaz> ?
19:25:37 <zq> i'm all stuck reading quickcheck code gosh what a drag
19:25:57 <foozbaz> zq: quickcheck looms in my future
19:27:04 <Twey> flebron: If you're not afraid of explaining a hypothetical-Haskell, there's also a nicer formulation of Applicative as a monoidal functor: http://www.haskell.org/haskellwiki/Typeclassopedia#Alternative_formulation
19:27:37 * flebron reads
19:27:45 <Twey> flebron: The laws come out nicer that way
19:30:09 <fragamus> @pl (1.0/(6.0*a))*z
19:30:09 <lambdabot> 1 . 0 / (6 . 0 * a) * z
19:30:45 <flebron> So when they say   (**) :: f a -> f b -> f (a,b), they really mean (**) :: (f a, f b) -> f (a, b), it's just currying that makes it operationally less ugly
19:35:05 <flebron> That's pretty nice! It's still a monoid :)
19:36:06 <monochrom> it seems fashion to rewrite applicative as a monoid, and monad as a monoid
19:36:25 <monochrom> s/fashion/fashionable/
19:38:31 <flebron> I'm one of those simpletons who didn't understand what a natural transformation in Hask was until he realized it was just polymorphism :p
19:39:02 <flebron> So "tough concept" explained in terms of "simple concept" is a win in my book :)
19:39:08 <cads> is there any paper that actually formally defines hask?
19:39:36 <cads> to whatever degree..
19:40:20 <cads> I mean the category Hask.
20:01:55 <dagle> Anybody know how to create a color (not colour) from hex? Tried to go via colour but I seem to made a misstake (and it seem pretty ugly too).
20:03:05 <pavonia> What color do you mean?
20:03:17 <dagle> Oh, in the gtk package.
20:04:10 <pavonia> You mean from a String value?
20:04:15 <dagle> Yes.
20:04:20 <dagle> Like gtk_color_parse
20:10:40 <pavonia> Seems you have to write your own function
20:12:44 <Twey> flebron: Yes, indeed
20:13:12 <Twey> cads: Sure, the Haskell report :þ
20:14:07 <cads> :P
20:16:12 <iron_houzi> Does anybody know what line 69 in scripts/build.sh, from the Linux source files does?
20:16:35 <iron_houzi> GHC_PACKAGE_PATH="${ORIG_GHC_PACKAGE_PATH}" \
20:16:55 <Twey> iron_houzi: What's the next line?
20:17:21 <Twey> Trailing \ means ‘continued on the next line’
20:17:51 <iron_houzi>     tell ${GHC} --make Setup -o Setup -package "${CABAL_PKG_VER}" \
20:19:07 <iron_houzi> Twey: I know. .. but I just want to know what these variables are: GHC_PACKAGE_PATH and ORIG_GHC_PACKAGE_PATH
20:19:43 <heatsink> GHC looks for package databases in GHC_PACKAGE_PATH if it's set
20:20:28 <iron_houzi> Do you know why it would want to do thsi
20:20:31 <iron_houzi> *this
20:20:36 <iron_houzi> ?
20:22:51 <heatsink> GHC would want to look for packages in order to compile Haskell code that uses them.
20:24:43 <iron_houzi> This is part of what I need to know
20:24:51 <heatsink> Are you trying to fix a problem in the script?
20:26:43 <iron_houzi> heatsink: I need to install haskell platform to get cabal, but I already have a number of haskell packages installed for pandoc along with all the dependencies. Does installing haskell platform need to rebuild all the haskell code for these packages?
20:28:06 <heatsink> Installing the Haskell platform from source will build and install packages
20:28:37 <iron_houzi> When the build script tried to execute this line, it failed, but commenting it out allowed the script to run and build the haskell platform package. I just don't know if installing it will mess up pandoc and all its deps
20:33:15 <heatsink> It's unlikely that that variable will affect whether the install breaks preexisting packages.
20:33:40 <heatsink> It will probably just affect the new packages that are built and installed
20:34:12 <heatsink> if those clobber existing packages, they could mess up what you've installed
20:35:04 <napping> Is the difference between ForeignPtr and ByteArray# significant in comparing Text and ByteString?
20:35:08 <heatsink> You could install cabal and its prerequisites manually.
20:37:13 <heatsink> You would normally compare data types based on their performance or functionality
20:37:23 <heatsink> rather than on what data types they use internally
20:45:06 <iron_houzi> heatsink: thank you
20:45:12 <jmcarthur> napping: well, ForeignPtr is FFI compatible and won't be moved by the GC
20:45:54 <jmcarthur> that is, the pointer will be moved, of course, but the block it points to won't
20:53:57 <napping> jmcarthur: I think the only thing that might matter there is fragmentation
20:55:42 <julianb> uhm hi!, I'm trying to make a parser for lambda calculus in parsec, my code's in: http://lpaste.net/1210687491888119808 . The problem is that whenever I try to parse an expr, I run into a while loop when using applications or abstractions
20:56:48 <julianb> I meant to say that I run into an infinite loop when using applications or abstractions
20:57:05 <pavonia> Parsec can't automatically resolve link-recursion
20:57:11 <pavonia> *left-recursion
20:57:34 <pavonia> you can use the chainl combinator for that
20:58:26 <monochrom> yes, I use chainl too for my lambda parser
20:58:29 <julianb> uhm, I'll look into it, thanks
20:59:41 <monochrom> or perhaps chainl1
21:01:28 <dolio> chainl?
21:01:42 <dolio> With space or something?
21:02:47 <napping> speaking of parsec, I notice it doesn't remember error messages past things that succeeded on empty strings
21:03:20 <ezrios> how does one design types to express program invariants?
21:03:36 <napping> like many1 foo <*> optional bar <*> baz might say "expecting baz", even if a foo would also let it continue
21:04:01 <ezrios> for example, is it possible to design a system of types for a game of chess such that it is impossible to construct an invalid board position?
21:04:18 <napping> what's an invalid board position?
21:04:44 <ezrios> napping: say, a position with 9 queens on one side
21:04:52 <ezrios> greater than 9
21:05:11 <napping> Well, in Haskell you can't always express the entire invariant
21:05:39 <napping> but for example something like [[Maybe Piece]] doesn't let you have multiple pieces in a spot, compared to [(Int,Int,Piece)]
21:05:53 <monochrom> hmm, I eliminated spaces. there was nothing in between.
21:06:18 <monochrom> oh! so it's chainl with "return App" :)
21:06:19 <ezrios> napping: well, I was wondering if it was possible to enforce the legality of any given position through the type system
21:06:29 <dolio> Oh.
21:06:32 <ezrios> instead of relying on the correctness of the implementation of one's functions
21:06:41 <napping> Perhaps, but I'd say it's not worth the trouble without dependent types
21:06:54 <ezrios> I keep hearing about dependent types
21:06:58 <ezrios> maybe I will have to research those
21:07:16 <dolio> I'm not sure it's worth doing with dependent types, either.
21:07:33 <napping> for a chess board? Maybe
21:08:02 <napping> But you'd probably just use a predicate, like {x :: Board | goodBoard x}
21:08:13 <dolio> That would be easier, yeah.
21:08:27 <napping> which makes me think of some kind of debug or lint mode where you run the predicate after each step
21:08:59 <dolio> Well, except, you'd have to prove that all your operations preserve goodness.
21:09:30 <monochrom> it's a good idea to prove an important invariant anyway
21:09:52 <napping> Right, but if you use the same kind of predicate you'd use in a lint mode, you're getting something you've demonstrated you value. The questions is just whether the proof is too expensive
21:10:39 <napping> and if there's a way to bail out on error, you can always fall back to actually evaluating the predicate
21:11:05 <napping> (presumably if you have a proof you can put it in some kind irrelevant part of the term that doesn't cost anything at runtime)
21:11:48 <julianb> I'm not sure how chainl would work in the case of lambda calculus, would my separator be spaces?
21:12:23 <dolio> I just use many/some and foldl afterwards.
21:12:38 <dolio> But you could chainl with 'return App' as monochrom said.
21:13:20 <napping> is everyone doing a lambda calculus?
21:14:36 <heatsink> It's a good thing to practice on
21:15:01 <napping> Sure, but it sounds like julianb dolio and monochrom have all done it recently
21:15:28 <dolio> I work on a compiler at work sometimes.
21:15:46 <julianb> well, I went to an introductory talk about it in my uni, and it caught my eye
21:15:54 <kiras> hi...  is it possible to give names to value constructor parameters?  i think i saw something about using a map type to basically provide named argument functionality, but i'm not sure that's exactly what i want.
21:16:34 <julianb> kiras, you could use record syntax
21:16:41 <kiras> i also see that you can use type synonyms to give more descriptive names, but...
21:16:43 <kiras> ah
21:16:54 <kiras> i'll have to look at that
21:17:11 <julianb> data f = G { name :: String, age :: Int }
21:17:51 <kiras> oh, i think that's what i saw before, the map/named arguments style?
21:18:11 <julianb> although its probably akin to data f = G String Int \n name (G s _) = s \n age (G _ i) = i
21:18:46 <napping> kiras: If you want to call it that, but that syntax only works on records
21:19:37 <kiras> i see
21:21:02 <kiras> ok, that seems better.  thanks.
21:21:34 <napping> It does give you field updates, like val{name = "ted"}
21:22:12 <spacekitteh> how come hackage is no longer running haddock on my library? http://hackage.haskell.org/package/clifford
21:22:20 <kiras> that creates a new version of the record with a different value for name?
21:22:25 <napping> Yeah
21:22:43 <napping> It's not particularly nice as far as record systems go, but sometimes it's useful
21:23:26 <zzo38> I have received a message about the "dvi-processing" package. Are you using this program? Someone else updated it (I told them it is OK to do so), so maybe someone is using it and I would like to know who used it and what for.
21:24:09 <ski> one of the irritating things about it is that sometimes `name' has type `String', sometimes it has type `F -> String'
21:24:17 <kiras> cool.  so does this work similarly to data structures in clojure?  in other words, are records implemented as persistent data structures or something similar?
21:24:35 <napping> It's just a thin layer of sugar over an ordinary constructor with positional fields
21:24:50 <napping> So nothing to do with maps, no attempt to share other bindings in the constructor, etc.
21:24:50 <Javran> what's the most commonly used command line argument parser?
21:25:50 <julianb> Javran, I believe there's getopt
21:25:53 <kiras> so it basically allocates memory for each member of the new record?
21:26:26 <julianb> I don't know anything about its population within the haskell community, but it is pretty widely used
21:26:33 <napping> well, it's no different from writing (case val of Con field1 field2 _ field3 ... -> Con field1 field2 newName field3)
21:26:55 <Javran> julianb: thanks, I'll take a look at it.
21:27:38 <napping> So things can be said about performance, but nothing is because of record syntax in particular
21:27:38 <zzo38> It says uploaded by Jean Philippe Bernardy.
21:27:56 <kiras> that's a little past my current understanding of haskell at the moment...  is that pattern matching?
21:28:06 <zzo38> I would like to know if he used my program, as I am curious of knowing it. (If you don't want to tell me that's OK)
21:28:23 <napping> yeah
21:28:29 <ski> kiras : `case' does pattern-matching, yes
21:28:40 <kiras> i see
21:28:56 <kiras> in reference to what you said earlier, if name has type F -> string...  that's a function right?  what would F indicate?
21:29:20 <napping> well, if name is the field name then you get a function extracting that field from the record
21:29:27 <ski>   data F = G { name :: String, age :: Int }
21:29:39 <ski> `F' is the data type in question
21:29:48 <kiras> oh...
21:29:52 <napping> is more or less just like data F = G String Int; name (F n _) = n; age (F _ i) = i
21:30:20 <kiras> so you would have to explicitly pass in an instance of F to name?
21:30:37 <ski> in SML, the field projection functions would be written `#name' and `#age' instead -- avoiding the schizophrenia
21:30:38 <napping> If you want to use it as an accessor
21:31:03 <napping> like name someRecordVal (instead of someRecordVal.name in some other languages)
21:32:12 <ski> (thus `#name someRecordVal' in SML, but `{name = "Diaconescu",age = 76}' instead of `G {name = "Diaconescu",age = 76}')
21:32:40 <napping> functions and field names are not in separate namespaces?
21:32:47 <kiras> ok.  but sometimes name just has type String?  what causes the difference?  also...  how would that work?  how would the language determine what name to return?  would this be like static methods in some other languages?
21:33:34 <napping> name never just has type String (unless you've shadowed with with an argument name or something)
21:34:03 <napping> my expression with case might be the translation of val {name = newName}
21:34:30 <ski> napping : clearly if you say `G {name = "Diaconescu",age = 76}', then in `name = "Diaconescu"' you're equating `name' with a `String', so that instance of `name' must (conceptually) have type `String'
21:34:53 <ski> napping : even simpler, in `data F = G { name :: String, age :: Int }', `name' is directly claimed to have type `String'
21:35:29 <napping> and I suppose NamedFieldPun patterns let you write \G{name} -> ...
21:36:21 <mindleyhilner> @src asTypeOf
21:36:21 <lambdabot> asTypeOf = const
21:36:26 <mindleyhilner> const 4 ()
21:36:26 <ski> napping : yes, that's another problem with having the field projection look like an ordinary variable
21:36:30 <mindleyhilner> > const 4 ()
21:36:31 <lambdabot>  4
21:36:37 <mindleyhilner> > asTypeOf 4 ()
21:36:39 <lambdabot>  No instance for (GHC.Num.Num ()) arising from the literal `4'
21:36:39 <lambdabot>  Possible fix: add an instance declaration for (GHC.Num.Num ())
21:36:43 <mindleyhilner> liar
21:37:00 <ski> the source of it is really `asTypeOf :: a -> a -> a; asTypeOf = const'
21:37:12 <ski> (and maybe a ficity declaration, i don't recall)
21:37:22 <ski> (s/ficity/fixity/)
21:37:34 <julianb> I have do {char '\\'; dependent <- many1 letter; char '.'; braces expr `chainl` (return.LamT) dependent)}, but its complaining about needing Expr -> Expr rather than Expr. Is there any way to say I want only 1 occurence?
21:38:30 <ski> @hoogle chainl
21:38:30 <lambdabot> Text.ParserCombinators.ReadP chainl :: ReadP a -> ReadP (a -> a -> a) -> a -> ReadP a
21:38:31 <lambdabot> Text.Parsec.Combinator chainl :: Stream s m t => ParsecT s u m a -> ParsecT s u m (a -> a -> a) -> a -> ParsecT s u m a
21:38:31 <lambdabot> Text.ParserCombinators.Parsec.Combinator chainl :: Stream s m t => ParsecT s u m a -> ParsecT s u m (a -> a -> a) -> a -> ParsecT s u m a
21:39:27 <napping> kiras: in particular, the Haskell record system doesn't even try to allow different records to have fields with the same name (you can do it in different modules), or to write functions that work over multiple types by just caring that they have some field
21:40:22 <kiras> i read about the first issue before.  it sounds like some work is being done to resolve that?  would the second behavior typically be achieved via typeclasses?
21:40:29 <zzo38> You could make a class if you want to, although that isn't best either and cannot be used with { name = ... } syntax.
21:41:28 <ski> julianb : i don't quite recall how to use `chainl', but it seems it wants one more argument, at least ?
21:41:28 <zzo38> My opinion is that it ought to automatically make up a class and instances anonymously when you have multiple types with similar field names.
21:42:09 <ski> Trex in Hugs is interesting
21:42:20 <julianb> ski, it does, but there aren't any more. I want to receive \a.(expr) and parse it into LamT "a" (expr)
21:42:26 <ski> there are also some other, partly similar, proposals, iirc
21:42:45 <kiras> it'd be nice if that could be improved.  this is my first attempt at doing anything other than exercises in haskell and i already ran into this issue.
21:42:45 <ski> julianb : and `\a b. (expr)' ?
21:43:03 <julianb> ski, I'm thinking of \a.\b.(expr)
21:43:08 <zzo38> ski: I have read the documentation of Trex in Hugs.
21:43:22 <ski> zzo38 : ok
21:43:34 <julianb> so that should be: LamT "a" (LamT "b" (expr))
21:44:13 <Javran> I'm wondering is there a word in haskell like "pythonic" in python community?
21:44:57 <ski> julianb : i think `chainl' wants the "separator" parser as second argument. so if you want to use `chainl', you probably should use `many1' there -- and vice versa
21:45:12 <nisstyre> Javran: "wwekd"
21:45:21 <MP2E> o.O
21:45:24 <ski> julianb : perhaps you really want to use `foldl' or `foldl1' ..
21:45:25 <Javran> lol
21:45:29 <nisstyre> (what would edward kmett do)
21:45:48 <MP2E> ah
21:45:51 <julianb> ski, have you got some good resource to read about parsec? I'm kinda lost right now
21:46:10 <nisstyre> julianb: the parsec docs are about as good as it gets
21:46:13 <ezrios> julianb: book.realworldhaskell.org/read/using-parsec.html
21:46:25 <nisstyre> anything older is probably out of date
21:46:33 <nisstyre> RWH is frustrating in that aspect
21:46:36 <nisstyre> though it's gotten better
21:46:38 <ezrios> nisstyre: it is slightly dated, yes
21:47:01 <ski> @let data Exp var = Var var | LamT var (Exp var) deriving Show
21:47:03 <ezrios> not horribly so, at least for this chapter
21:47:03 <lambdabot>  Defined.
21:47:32 <julianb> ski, you're missing an application type
21:47:38 <ski> i know
21:47:50 <ski> > foldr LamT (var "(expr)") ["a","b","c"]
21:47:52 <lambdabot>  Couldn't match expected type `L.Exp [GHC.Types.Char]'
21:47:52 <lambdabot>              with actual type `Debug.SimpleReflect.Expr.Expr'
21:48:03 <ski> > foldr LamT (Var "(expr)") ["a","b","c"]
21:48:06 <lambdabot>  LamT "a" (LamT "b" (LamT "c" (Var "(expr)")))
21:48:33 <ski> julianb : seems to me you probably want to do that kind of thing there, instead of attempting to call `chainl' ?
21:49:50 <ski>   do char '\\'
21:49:56 <ski>      dependent <- many1 letter
21:49:58 <julianb> that seems about right, but I need to know all of the function's names before actually doing that (also, you might have a VarT or an Application rather than a LamT
21:50:01 <ski>      char '.'
21:50:22 <ski>      body <- braces expr
21:50:39 <ski>     return (foldr LamT body dependent)
21:50:45 <ski> something like that might work
21:52:32 <zzo38> You could also use Applicative format for that too, I think, it doesn't require monad operations
21:52:53 <zzo38> (Actually parsing normally doesn't need the monad operations; usually applicative is good enough, although not always.)
21:53:29 * ski nods
21:56:05 <julianb> ski, that should work for a \a b c d.(expr) syntax
21:56:13 <julianb> but how about a \a.(expr)?
21:56:32 <ski> what about it ?
21:56:53 <julianb> I mean, well, taking the same approach would hang
21:57:05 <ski> why ?
21:58:39 <julianb> well, someone said before that parsec is can't resolve left-recursion (that's the actual problem I was trying to solve with chainl)
21:59:24 <ski> there is no left-recursion in this example
22:00:03 <ski> (except maybe inside `many1' (and `chainl') -- but hopefully the implementers of those has done the right thing)
22:00:23 <julianb> then why does the parser hang when I try to parse "\a.a"
22:00:57 <ski> i don't know
22:01:13 <ski> perhaps there's left-recursion in some other part of your grammar
22:02:28 <julianb> this is the src http://lpaste.net/3277910557746790400
22:02:49 <julianb> there is indeed left recursion in expr
22:06:01 <ski> yes, via `application'
22:07:28 <ski> `variable' is overlapping `application'
22:08:38 <julianb> how so?
22:09:10 <ski> `chainl1' can succeed by performing the left parser once and the right parser not at all
22:09:26 <ski> meaning zero applications of `AppT'
22:09:38 <julianb> oh. That's not nice at all
22:09:44 <ski> probably you want to use `chainl' instead
22:10:52 <ski> e.g. starting off by parsing a `variable' -- or *maybe* a `variable' or an `abstraction', depending on how you want to parse `\a. (a b) c' and `\a. a b'
22:11:30 <julianb> wait, but isn't chainl1 supposed to have at least 1 match of the left parser? meaning it should call the separator at lesat once
22:11:31 <ski> and possibly using `braces' here as well ?
22:11:51 <ski> julianb : yes for the first part, no for the second part
22:11:54 <ski> it's like `foldl'
22:12:00 <ski> > foldl f z [a]
22:12:01 <lambdabot>  Ambiguous occurrence `a'
22:12:02 <lambdabot>  It could refer to either `L.a', defined at L.hs:156:1
22:12:02 <lambdabot>                        or `Debug.SimpleReflect.Vars.a',
22:12:02 <lambdabot>                           imported from `Debug.SimpleReflect' at L.hs:110:1-26
22:12:02 <lambdabot>                           (and originally defined in `simple-reflect-0.3.1:De...
22:12:16 <ski> @undefine
22:12:17 <lambdabot> Undefined.
22:12:18 <ski> > foldl f z [a]
22:12:19 <lambdabot>  f z a
22:12:23 <ski> > foldl f z [a,b]
22:12:24 <lambdabot>  f (f z a) b
22:12:28 <ski> > foldl1 f [a]
22:12:29 <lambdabot>  a
22:12:31 <ski> > foldl1 f [a,b]
22:12:32 <lambdabot>  f a b
22:12:44 <ski> note how with `foldl1' on a singleton list, `f' isn't called
22:13:08 <julianb> oh, right
22:13:11 <ski> similarly, with `chainl1', when parsing with the left parser only one time, the separator parser isn't used
22:14:13 <julianb> alright, but then I'd be missing one argument to AppT
22:14:18 <ski> julianb : so .. how would you like `\a. (a b) c' and `\a. a b' to be parsed ?
22:14:33 <ski> or should they (both ?) be parse errors ?
22:15:04 <ski> julianb : not sure what you're thinking about re "missing one argument to AppT" ..
22:16:05 <julianb> well, the signature for AppT is AppT Expr Expr
22:16:23 <ski> yes ?
22:16:38 <julianb> and there's no default value for the function
22:16:51 <julianb> "If there are zero occurrences of p, the value x is returned."
22:17:09 <ski> talking about `chainl' or `chainl1' ?
22:17:15 <julianb> chainl
22:17:22 <ski> ok
22:17:47 <ski> i think that (`x') corresponds to `z' in the `foldl' examples above
22:17:52 <ski> i.e. some initial vale
22:17:55 <ski> u
22:18:23 <ski> which you e.g. could get by initially doing `var <- variable'
22:18:32 <julianb> but there is no initial value!
22:18:58 <ski> and then `chainl (...) (return AppT) var'
22:19:26 <julianb> I mean, it doesn't make any sense to think of an initial value
22:19:41 <ski> julianb : the basic pattern you want to parse here is `e e_0 e_1 ... e_{n-1}', where `n' may be zero
22:20:34 <ski> and you don't want the initial `e' here to be an application, since in that case `n' would just be one more
22:20:43 <julianb> oh, right, but if its zero then it makes no sense to create an application at all
22:20:56 <ski> so, `e' must be a variable, or maybe (if that's allowed/sensible) an abstraction
22:21:01 <ski> yes
22:21:17 <ski> so `e' will not be parsed by the `chainl' call, you have to parse it separately
22:22:21 <ski> the `chainl' call will be responsible for parsing all the `e_i' (for `i < n'), and for combining the parse tree for `e' with the parse trees for `e_i' (for `i < n') into the whole parse tree for `e e_0 e_1 ... e_{n-1}'
22:22:26 <ski> julianb : all clear ?
22:22:54 <julianb> ok, all clear!. And if there's no such thing I should simply return a variable or something like that to indicate that nothing was parsed
22:23:02 <julianb> that's what the third argument is, right?
22:23:27 <ski> the third argument is the parse tree of `e', in this situation
22:23:39 <ski> i'm not sure what you mean by "if there's no such thing"
22:25:48 <julianb> The documentation says "chainl p op x parser zero or more occurrences of p, separated by op. Returns a value obtained by a left associative application of all functions returned by op to the values returned by p. If there are zero occurrences of p, the value x is returned."
22:26:31 <julianb> hence, if my p is an expression, and my op is (return AppT) as we said, the last value is a default value in case the string can't be parsed
22:26:33 <julianb> right?
22:26:34 <ski> "separated" should probably be "prefixed"
22:27:04 <ski> @hoogle chainl
22:27:04 <lambdabot> Text.ParserCombinators.ReadP chainl :: ReadP a -> ReadP (a -> a -> a) -> a -> ReadP a
22:27:04 <lambdabot> Text.Parsec.Combinator chainl :: Stream s m t => ParsecT s u m a -> ParsecT s u m (a -> a -> a) -> a -> ParsecT s u m a
22:27:04 <lambdabot> Text.ParserCombinators.Parsec.Combinator chainl :: Stream s m t => ParsecT s u m a -> ParsecT s u m (a -> a -> a) -> a -> ParsecT s u m a
22:27:09 <ski> hm
22:27:22 <julianb> the 3rd def is the one I'm using
22:27:35 <julianb> by that reasoning: application = chainl expr (return AppT) (VarT 'x')
22:27:53 <julianb> should simply return (VarT 'x') if there are 0 occurences of expr
22:28:43 <ski> hm, so perhaps i misremember the details of `chainl'
22:32:10 <ski> ok, i stand corrected
22:32:45 <ski> `chainl' is just a thin wrapper around `chainl1', that provides a default value in case the former parse fails
22:33:10 <julianb> oh, right
22:33:21 <julianb> so just using chainl1 is fine, then
22:34:50 <julianb> nevertheless, there is indeed some sort of problem with applications and variables (removing abstractions seems to make no difference to the fact that it just hangs)
22:35:25 <haasn> @@tell quchen @type const mapped "Yes, it's precisely like fmapped, as the Functor constraint shows"
22:35:33 <haasn> @@ @tell quchen @type const mapped "Yes, it's precisely like fmapped, as the Functor constraint shows"
22:35:35 <lambdabot>  Consider it noted.
22:35:40 <haasn> there we go :)
22:35:50 <haasn> I hope that wasn't too hacky
22:36:36 <haasn> Oh, no, the String bit is omitted from the tell :(
22:37:59 <Javran> Hi all, could you recommend me some good terminal UI libraries?
22:39:09 <Javran> I tried vty-ui, but almost all function in it returns IO, I'm not sure it's a good style in haskell..
22:39:32 <c_wraith> Javran: anything that actually alters what's displayed on screen will have IO in it.
22:39:33 <julianb> Javran, you won't have any other chance than using IO, I think
22:39:48 <shachaf> haasn: Does that actually get your message through somehow?
22:40:04 <haasn> shachaf: no, I sent it as an additional message upon realizing that already
22:40:19 <haasn> for a moment there I thought it displayed the expression like GHCI's :t
22:40:48 <haasn> c_wraith: that may be true, but it's certainly possible to abstract a great deal away from a single “runVty :: Vty a -> IO a” or something
22:41:09 <haasn> cf. gloss's approach
22:42:26 <Javran> c_wraith: they even have function called "addToFocusGroup".. I don't think manuipuating a list needs IO though
22:44:07 <Javran> anyway I think I can still go with it, I was just asking about more decent ways.
22:49:38 <ski> @type let chainl0 :: Text.Parsec.Stream s m t => Text.Parsec.ParsecT s u m a -> Text.Parsec.ParsecT s u m (r -> a -> r) -> r -> Text.Parsec.ParsecT s u m r; chainl0 p op z = do {f <- op; x <- p; chainl0 p op (f z x)} <|> return z in chainl0
22:49:39 <lambdabot> Text.Parsec.Prim.Stream s m t => Text.Parsec.Prim.ParsecT s u m a -> Text.Parsec.Prim.ParsecT s u m (r -> a -> r) -> r -> Text.Parsec.Prim.ParsecT s u m r
22:51:10 <ski> @tell julianb so i'm wondering why `chainl0 :: Stream s m t => ParsecT s u m a -> ParsecT s u m (r -> a -> r) -> r -> ParsecT s u m r; chainl0 p op z = do {f <- op; x <- p; chainl0 p op (f z x)} <|> return z' isn't defined (and perhaps called `chainl') .. cf. `foldl'
22:51:10 <lambdabot> Consider it noted.
22:52:14 <ski> (maybe that one is inefficient for some reason, i don't know)
23:03:55 <haasn> :t Proxy :: Proxy "test"
23:03:56 <lambdabot>     Illegal literal in type (use -XDataKinds to enable): "test"
23:04:01 <haasn> :(
23:06:04 <haasn> :t Proxy :: Proxy (t e s t)
23:06:05 <lambdabot> Not in scope: data constructor `Proxy'
23:06:05 <lambdabot> Not in scope: type constructor or class `Proxy'
23:22:49 <vozz> What is/are the most popular plotting library(s) for haskell?
23:23:01 <vozz> your favourite
23:23:08 <vozz> or *
23:23:23 <ezrios> Graphics.Rendering.Chart is not bad
23:26:54 * hackagebot clifford 0.1.0.8 - A Clifford algebra library  http://hackage.haskell.org/package/clifford-0.1.0.8 (spacekitteh)
