00:00:27 <jle`> filter p (x:xs) | p x = x : rest | otherwise = rest where rest = filter p xs
00:00:56 <chrisdotcode> jle`: do you think it's worth the trade off, or not having to re-write it again? I honestly think that that's kind of even clearer than the explicit recursion
00:01:33 <jle`> i feel like the first version is slightly more readable
00:01:34 <jle`> but
00:01:49 <jle`> not by any meaningful margin
00:02:49 <chrisdotcode> huh. well thanks for the help!
00:03:00 <jle`> if it's good enough for ghc though
00:03:27 <jle`> np
00:03:35 <chrisdotcode> yeah, that's exactly what I was thinking
00:03:43 <chrisdotcode> "if it's good enough for the source hackers, it's good enough for me"
00:03:53 <jle`> haha
00:04:07 <jle`> actually base is a pretty clean piece of work
00:04:18 <jle`> and usually works pretty well as a style reference
00:07:30 <hvr> if 'darcs pull -a' tells me, that I had conflicts (but I forgot where), how can darcs tell me what those conflicts where?
00:07:33 <hvr> -h
00:09:29 * hackagebot identifiers 0.3.0.0 - Numeric identifiers for values.  http://hackage.haskell.org/package/identifiers-0.3.0.0 (awagner83)
00:09:29 * hackagebot time 1.4.2 - A time library  http://hackage.haskell.org/package/time-1.4.2 (AshleyYakeley)
00:09:44 <jle`> hm
00:09:54 <pavonia> hvr: Doesn't "darcs whatsnew" tell you?
00:10:05 <hvr> it just shows me a large diff :-/
00:10:07 <jle`> if i have a pipe that "chunks" things up (awaits eight times and yields after all eight)...
00:10:31 <jle`> how do i rewrite it to handle the stream ending?
00:10:47 <pavonia> hvr: The conflicts are marked by "vvvvvv" and "^^^^^^", IIRC
00:10:54 <jle`> like if it stopson a non-multiple of 8, do something to clean up?
00:12:14 <hvr> pavonia: that's weird... it doesn't show any, even though darcs pull said there were
00:14:03 <pavonia> hvr: Hhm, or maybe the conflicts were marked in newly created files (for each conflicting source file)
00:14:37 <pavonia> hvr: I haven't used darcs for some time, sorry. Have you tried to ask in #darcs?
00:14:53 * hvr wonders why ppl say that 'darcs' is saner than 'git', even though I often don't have any clue what's happening with Darcs :-))
00:49:31 * hackagebot tasty-ant-xml 1.0.0.6 - Render tasty output to XML for Jenkins  http://hackage.haskell.org/package/tasty-ant-xml-1.0.0.6 (OliverCharles)
00:53:00 <czro_> Why is there no equivalent of liftIO for ST. Is it generally a bad idea to have ST instead of IO in a transformer stack?
00:54:47 <sipa> :t liftST
00:54:48 <lambdabot>     Not in scope: `liftST'
00:54:48 <lambdabot>     Perhaps you meant one of these:
00:54:48 <lambdabot>       `liftM' (imported from Control.Monad.Writer),
00:55:51 <czro_> :t liftIO
00:55:52 <lambdabot> MonadIO m => IO a -> m a
00:56:19 <czro_> but for Control.Monad.ST?
00:57:46 <aspidites> is there a way to get more detailed output from pandoc? I'm currently trying to migrate from sphinx to pandoc (which seems quicker) but find the output rather unhelpful
00:58:05 <jle`> czro_: perhaps the equivalent question is why is there no MonadST
00:58:19 <jle`> aspidites: output? like, the results?
00:58:29 <aspidites> for instance, in sphinx, i get a line number and column when a resource (such as an image is missing). in pandoc, I'm simply told that the image is missing
00:58:51 <jle`> oh the error messages
00:58:59 <aspidites> http://pastebin.com/uMvnVgN1
00:59:55 <osa1> two packages export same module, is there a way to specify which one to import in ghci?
01:01:24 <Saizan> czro_: it's not a bad idea, i think it's just not as common
01:01:28 <czro_> ekmkett has one on hackage. Is it better to keep IO in the transformer stack instead of ST. I have a ReaderT StateT IO/ST stack. Basically a computation that sometimes needs to generate random numbers, therefore the dependency on ST/IO.
01:02:13 <czro_> Saizan: Any reason for that not being common? Does it complicate things in some way with the threaded state parameter to ST?
01:02:35 <cwvh> osa1: :set -XPackageImports      then you can do:  import "mtl" Control.Monad.Reader
01:02:46 <Saizan> czro_: well IO does many things ST doesn't, so it's more applicable
01:03:03 <tikhon> of course, this means ST gives better guarantees
01:03:11 <osa1> cwvh: thanks, that worked. I was actually trying this but with version number of the package, so it was failing...
01:03:42 <Saizan> czro_: but yeah, i guess the 's' parameter of ST can make a MonadST class with liftST a bit trickier to write
01:05:56 <czro_> I thought ST would be the first choice for something like this, to get some more guarantees. Since ST is a monad I sould be able to manually lift if I need to run some ST action in a computation right?
01:06:30 <Saizan> yeah
01:06:48 <Saizan> you can just use as many "lift" as the depth of your stack
01:06:55 <jle`> i use ST at the bottom of a lot of my stacks
01:06:58 <jle`> but
01:07:06 <jle`> it is a little annoying that there is no MonadST
01:07:11 <osa1> cwvh: is there a way to do same thing inside the repl? something like :m + "mtl" Control.Monad.State ?
01:07:14 <jle`> it makes the stacks a little more fragile
01:07:28 <Saizan> jle`: put one on hackage!
01:08:06 <tikhon> just write the import directly?
01:08:14 <tikhon> that might reset your other imports though :/
01:08:20 <jle`> Saizan: :)
01:08:22 <czro_> could you do a paste of a "hello world" with ST at the bottom. I keep struggling with this. I would be very grateful.
01:08:52 <jle`> czro_: hm
01:09:14 <jle`> it shouldn't be any different than using any normal monad at the bottom
01:09:20 <jle`> i actually rarely use ST directly
01:09:33 <jle`> i often use it with MVectors and things like that
01:09:33 * hackagebot tasty-hunit 0.8.0.1 - HUnit support for the Tasty test framework.  http://hackage.haskell.org/package/tasty-hunit-0.8.0.1 (RomanCheplyaka)
01:09:44 <Saizan> czro_: maybe you can paste where you got stuck
01:10:43 <cwvh> osa1: you can use the import syntax in the repl ~ λ> import "containers" Data.Map
01:10:51 <czro_> Saizan: I'll do a small example of where I got stuck last time I tried this. Currently using IO. brb
01:12:57 <jle`> czro_: feel free to dig through literally my first ever haskell project https://github.com/mstksg/pi-monte-carlo
01:13:25 <jle`> it uses MVectors and a deep-ish stack with ST at the bottom
01:14:58 <czro_> jle`: I'll take a look. Seems to be something similar to what I'm doing. Thanks!
01:15:24 <jle`> oh yeah, remember to make sure your kinds match up
01:15:26 <jle`> :k ST
01:15:27 <lambdabot> * -> * -> *
01:15:47 <jle`> a monad transformer has to transform a monad
01:16:04 <jle`> :k Monad
01:16:05 <lambdabot> (* -> *) -> Constraint
01:16:23 <jle`> (ST s) is a Monad, ST is not
01:16:51 <jle`> :k MonadTrans
01:16:52 <lambdabot> ((* -> *) -> * -> *) -> Constraint
01:17:43 <jle`> probably more helpfully parenthesized as ((* -> *) -> (* -> *))
01:17:56 <jle`> kinda looks like ascii art heh
01:22:52 <merijn> jle`: ST is not a monad transformer
01:23:14 <jle`> merijn: yeah, he was trying to use ST at the base of a transformer
01:23:16 <jle`> and having problems
01:23:31 <merijn> ah, whoops
01:23:31 <jle`> so i was just reminding him that ST can't be a transformed monad, but ST s can
01:23:54 <jle`> not sure if that's his problem though because he has gone afk for a bit
01:23:57 <jle`> heh
01:25:10 <czro_> looking through your Monte Carlo thing.
01:29:36 * hackagebot cabal-rpm 0.8.10 - RPM packaging tool for Haskell Cabal-based packages  http://hackage.haskell.org/package/cabal-rpm-0.8.10 (JensPetersen)
01:30:50 <orzo_> ghc tells me i have a value of type: sample :: HList ((':) * Beta ((':) * EdgeFunction ((':) * Stroke ('[] *))))
01:31:45 <orzo_> but when i try to add the type signature, it says parse error on input ':'
01:31:46 <ketil> Any way to prevent cabal from pulling in a dependency?  It insists on installing text-1.1.0.0, but this doesn't compile with my current GHC
01:32:11 <orzo_> what are those ': and '[] things and how can i coax ghc into allowing me to write them in a type signature?
01:32:34 <jle`> czro_: remember that a lot of it is bad style ;)
01:32:49 <czro_> jle`: You haven't seen my code :)
01:33:02 <jle`> haha
01:33:12 <czro_> jle`: Yours reads like a dream...
01:33:36 <jle`> well regardless, just be aware of taking away any idioms that i use there
01:33:38 <jle`> heh
01:33:45 <jle`> been meaning to clean it up and turn it into a tutorial series though
01:39:37 * hackagebot jwt 0.1.0 - JSON Web Token (JWT) decoding and encoding  http://hackage.haskell.org/package/jwt-0.1.0 (StefanSaasen)
01:39:44 <pharaun> this may be a dumb question, but is there any good way to have "conditional" yield with pipes?
01:39:54 <pharaun> ie if X is true then yield y value otherwise carry on
01:40:03 <jle`> :t when
01:40:04 <lambdabot> Monad m => Bool -> m () -> m ()
01:40:19 <czro_> jle`: I'll keep that in mind. I'm just experimenting with how an algorithm I use in a project would turn out if written in haskell.
01:40:21 <pharaun> yeah i tried, seems to make the whole thing go bad, guess i'll play with it some more :\
01:40:43 <pharaun> jle`: i'm still a bit wombly but if i return () the pipe will then terminate
01:41:08 <jle`> ah
01:41:10 <supki_> ketil: you can add constraints to cabal install like  --constraint='text < 1.1'
01:41:17 <jle`> well i just learned pipes today :|
01:41:24 <pharaun> np :)
01:41:36 <pharaun> i've been enjoying them but having trouble with conditionals :)
01:41:46 <jle`> you can use bool maybe, but i'm not sure waht the idiomatic way is
01:41:49 <pharaun> one way i thought was to just build up pipes outside and do conditional outside but thats just awkward
01:42:21 <pharaun> yeah i have a "case x of just x -> yield x nothing -> return ()"
01:42:24 <pharaun> but that seems to make it die
01:43:03 <pharaun> so yeah i'm not sure yet
01:43:04 <jle`> even if you have a line after it?
01:43:49 <pharaun> i feel like i am missing something trivial here :)
01:44:16 <lieven_> look at the implementation of right in the Pipes.Csv example. perhaps you're forgetting to loop?
01:44:16 <jle`> it seems to work for me
01:44:24 <pharaun> jle`: http://lpaste.net/100647
01:44:42 <pharaun> that seems to cause it to terminate that pipe on the return ()
01:44:48 <jle`> well
01:44:56 <jle`> that's what's supposed to happen
01:44:57 <jle`> i think
01:45:06 <pharaun> i don't see how else i can conditionally yield then
01:45:09 <jle`> if you want a pipe that continually consumes and produces you either want to recurse
01:45:11 <jle`> or use forever
01:45:19 <pharaun> because if i don't have a password i'm not sure how to yield it when i have one
01:45:25 <pharaun> oh if i get rid of the passw part it works fine
01:45:33 <pharaun> i want it to terminate after it has spit out all of these values
01:45:40 <pharaun> but it seems to be prematurely terminating
01:46:43 <pharaun> i think i'm just smoking something, ok i'll dig into this some more then
01:47:10 <jle`> so you're saying it never yields nick, user, joinChain...?
01:47:27 <pharaun> jle`: never mind :)
01:47:36 <pharaun> jle`: i *am* smoking something
01:47:41 <jle`> haha
01:47:43 <pharaun> its yielding up the pass
01:47:49 <pharaun> sorry :)
01:47:54 <jle`> np
01:49:38 * hackagebot ghc-imported-from 0.1.0.3 - Find the Haddock documentation for a symbol.  http://hackage.haskell.org/package/ghc-imported-from-0.1.0.3 (CarloHamalainen)
01:56:58 <bahamas> why does let m = (`mod` 3829) work but let m = ((`mod` 3829) == 0) doesn't?
01:57:28 <shachaf> What do you expect the type of (==) to be here?
01:59:05 <mgomezch> Hi!  I have something like this: data X = A | B; data Foo (x :: X) where Bar :: Int → Foo A; Baz :: Char → Foo B; data Quux = forall x. Quux { ..., field :: Foo x, ...}
01:59:06 <lieven_>  :t ((== 0) . (`mod` 3829))
01:59:34 <mgomezch> My intention is for «field» to be either a Foo A or a Foo B.  I’m not sure whether this is the right way to do it.  Is it?
01:59:55 <mgomezch> If I do it this way, I can’t figure out how to instance Eq Quux
01:59:58 <tikhon> mgomezch: not quite
02:00:21 <tikhon> mgomezch: the data Foo ... part just declares the *type*, so it needs to be made up of types
02:00:30 <tikhon> so you'd have to write data Foo X = ...
02:00:39 <tikhon> then, right of the =, you define the *data* constructor
02:00:52 <bahamas> shachaf: yeah, I was confused. looks like lieven_'s solution is what I was thinking
02:00:52 <tikhon> erm, you'd just write data Foo
02:01:10 <bahamas> I need to get used to the fact that operators are functions
02:01:18 <bahamas> also with function composition
02:01:22 <tikhon> so data Foo = Bar X will create a type Foo that has a single constructor Bar
02:01:31 <tikhon> and Bar has a single argument of type X, which can be an A or a B
02:01:31 <mgomezch> tikhon: Oh, but I mean to use a GADT indexed on the (promoted) data kind X.
02:01:39 <tikhon> ah
02:01:49 <shachaf> data Foo :: X -> * where { ... } ?
02:02:03 <shachaf> Well, that's not the issue here anyway.
02:02:29 <bahamas> this is mind bending
02:03:20 <ketil> supki_, ah, thanks.  It seems cabal just wanted to upgrade a previously installed 'text' ...well, because.  It wasn't actually needed, apparently. :-)
02:03:27 <shachaf> mgomezch: What you wrote looks like it should do it but it's possible that "it" is less useful than you're expecting.
02:05:29 <mgomezch> shachaf: It compiles, but I can’t manage this: instance Eq Quux where l == r = ???
02:06:51 <mgomezch> Once I pattern match on l/r, they’ll come out with different instantiations for the type variable of course.  If they actually had the same type inside (I’m not sure that phrase even makes sense :] ), then it should be False — but how do I write that?
02:07:20 <mgomezch> oops, I meant «different types inside».  Or something like that.
02:07:36 <shachaf> Does something like this not work? instance Eq Quux where { Quux (Bar x) == Quux (Bar y) = x == y; Quux (Baz x) == Quux (Baz y) = x == y; _ == _ = False }
02:08:36 <mgomezch> I’ll give it a shot! (does type refinement work that way, though?  like, with nesting?)
02:10:02 <shachaf> I'm not entirely sure what you're getting at.
02:10:21 <shachaf> It seems like the type of the argument to Foo isn't affecting you at all here.
02:11:04 <shachaf> When you match on a Bar, you gain the information that x=A
02:11:15 <shachaf> But you don't really need that information for (==)
02:12:31 <mgomezch> Hm, indeed!  I don’t need to know about it.  That’s brilliant!
02:12:33 <pharaun> jle`: got it to work perfectly, yeah it was me being dumb :)
02:14:32 <mgomezch> Thanks!  It works perfectly. :)
02:19:41 * hackagebot tasty-rerun 1.1.1 - Run tests by filtering the test tree depending on the result of previous test  runs  http://hackage.haskell.org/package/tasty-rerun-1.1.1 (OliverCharles)
02:23:19 <danilo2> Hello! I'm very interested in writing webGL applications in haskell. I know, that ghc > 7.8 supports compilation to js (with ghcjs). Recently I came across Haskell Sodium 2d game engine and sodium FRP. Has somebody used it? I want to create pretty big webgl application and I'm looking for good library base :)
02:23:28 <danilo2> http://www.reddit.com/r/haskell/comments/1qy8sk/online_freecell_game_in_haskellfrpghcjs_with/
02:24:22 <jle`> danilo2: luite has some examples/tutorials on sodium and ghcjs on his blog
02:25:22 <danilo2> jle`: oh great! thank you :) I'll read it! You are talking about this: http://weblog.luite.com/wordpress/ ?
02:25:34 <jle`> danilo2: yes, specifically http://weblog.luite.com/wordpress/?p=127
02:25:45 <jle`> i'm working on a ghcjs webgl project myself
02:25:57 <jle`> but it's hardly in a state to be of any educational value
02:27:23 <danilo2> jle`: Cool, thank you very much :) I understand, that you are using sodium also ? Is it working with bigger projects without bigger problems? :)
02:27:25 <luite> they're probably a bit out of date
02:27:34 <luite> i really need to go over them again
02:27:41 <danilo2> jle`: I'm asking because I've never hear about it before
02:27:42 <jle`> i'm using netwire because i have a realtime game
02:27:47 <luite> but spent most of the weekend making ghcjs work on windows
02:28:12 <jle`> sodium is a solid frp library in the family of push/pull frp with reactive-banana
02:28:29 <jle`> i think it's mature enough for larger projects
02:28:31 <jle`> from what i've heard
02:28:40 <jle`> the sodium maintainer has a blog
02:28:45 <jle`> and also a nice talk if you want to get into it
02:28:48 <luite> danilo2: sodium does depend on weak reference handling to clean up its frp graph, there are a few open issues with those still with ghcjs
02:28:57 <luite> that i'll try to fix before releasing the stuff
02:29:06 <danilo2> luite: Hello! :) Nice to hear that :) So If you would recommend some library stack, you will go with sodium ? Or are there any other efforts worth looking in?
02:29:53 <luite> danilo2: i've only really tried sodium so far, but haven't built big things with it yet
02:30:02 <jle`> http://www.youtube.com/watch?v=gaG3tIb3Lbk -- for an overview of the semantics behind sodium and its family of frp
02:30:25 * ion downloads
02:30:42 <jle`> if you ask me by the end of next weekend i might be able to give you more concrete answers about netwire and ghcjs
02:30:45 <luite> danilo2: but stephen blackheath is coming over here in a week or so and we're going to see what we can do to support sodium better
02:31:46 <danilo2> luite: Hmm, ok - if you are working on these issues and it seems you know how to fix them its ok :) - Right now we will work on a custom webgl gui library - maybe we will opensource it when it will be ready - so during the development the issues will maybe not create big pains, but after releasing they could :)
02:31:49 <luite> i'd like to try to get incremental DOM updating work, where you get a Reactive value representing part of your DOM, and the browser only redraws updated parts
02:32:45 <danilo2> luite: Oh great! :) Right now I'm we are not very interested in DOM support (because we are creating webgl haskell gui library - which is completely run on canvas), but it is still nice to hear :)
02:34:28 <danilo2> luite, jle` : Thank you very much for all the links and info! :)
02:34:53 <luite> danilo2: cool. let me know if you have any problems. i haven't kept track of performance for a few months and there are probably many points where it can be improved
02:35:52 <danilo2> luite: Ok :) On the beginning let me introduce zgredzik to you - he is the guy, which will handle this stuff for a moment here and we will sometimes ask questions about ghcjs :)
02:36:24 <zgredzik> uhm, hi?
02:36:41 <luite> hello
02:43:52 <jle`> on a slightly related note, has anyone tried building a Windows 8 app in Haskell?
02:44:14 <jle`> Windows 8 apps can be programmed purely in HTML5/CSS/js
02:44:23 <jle`> so i presume it would be easy even with Fay and the like
02:44:31 <jle`> i would make one if i had any ideas
02:44:44 * hackagebot jwt 0.1.1 - JSON Web Token (JWT) decoding and encoding  http://hackage.haskell.org/package/jwt-0.1.1 (StefanSaasen)
02:45:03 <luite> hmm, haven't heard of anyone doing a windows 8 app
02:45:45 <jle`> http://msdn.microsoft.com/en-us/library/windows/apps/br211385.aspx
02:45:55 <jle`> sounds almost too simple
02:46:02 <jle`> but who uses windows 8 apps >.>
02:46:16 <luite> someone was making a chrome browser app with ghcjs (a z-machine implementation, text adventure) last week
02:46:34 <jle`> but at least we know that ghc can now target iphone and windows 8 platform
02:46:39 <jle`> if anyone cared.
02:46:55 <jle`> luite: oh really? do you have a link?
02:48:19 <luite> jle`: not sure if it's published/finished, it's shepheb, who's in this channel (also in #ghcjs)
02:48:22 <luite> :)
02:48:28 <jle`> luite: thanks :)
02:51:50 <merijn> Can someone explain why the left-side of the function arrow is the "negative position"? (i.e. A in A -> B)
02:52:15 <Tarrasch> Hi everyone, is there any consensus in the Haskell community weather if Exceptions for control-flow are good or not?
02:52:39 <Aetherspawn> Tarrasch: definately not.
02:52:42 <Tarrasch> I mean "acceptable" rather than "good"
02:52:45 <Aetherspawn> exceptions are in IO..
02:52:49 <merijn> Tarrasch: Define control flow
02:53:25 <merijn> Tarrasch: Most haskellers use haskell exception very similar to, say, Go's "fail"
02:53:29 <Aetherspawn> ContT best control flow 2014
02:53:30 <Aetherspawn> :P
02:53:42 <Tarrasch> merijn, See "Alternative return" in http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.50.1525&rep=rep1&type=pdf
02:53:49 <merijn> Tarrasch: i.e., normal expected errors should return Maybe, Either, or similar
02:54:23 <Aetherspawn> IO exceptions are really for actual IO bad-happenings
02:54:29 <merijn> Tarrasch: Exceptions should only be for unexpected breaks, say you have a server handling a socket, then using an exception to kill the entire thread handling that socket on disconnect, would make sense
02:54:39 <Aetherspawn> use Either or Maybe everywhere else
02:55:00 <merijn> Tarrasch: Actually, more concretely, I would argue the following: Exceptions should never cross API boundaries
02:55:14 <Aetherspawn> I had no idea but apparently thunks are executed in parallel?
02:55:41 <merijn> Tarrasch: Using exceptions for the kind of behaviour I just described *within* an application should be fine, but libraries should always return an explicit error instead of throwing an exception
02:55:52 <Tarrasch> merijn, But could you imagine using it if it didn't cross API boundraries?
02:56:20 <Aetherspawn> no.
02:56:23 <merijn> Tarrasch: I frequently use them for "terminal" error conditions, like I want to kill the entire thread upon an IO error
02:56:56 <merijn> Tarrasch: Basically, if you plan to "catch" within 1 or 2 levels of the place where the error is thrown, use Either/Maybe
02:57:14 <merijn> Tarrasch: If you plan to catch 10+ levels up in a server loop or whatever, use exceptions
02:58:00 <Aetherspawn> well, arguably
02:58:08 <Tarrasch> Aetherspawn, merijn thanks for your replies. I'm looking at "Stack traces for Haskell" and I want to get a better sense of how Exceptions are used in practice. Your thoughts give me a better idea :)
02:58:17 <Aetherspawn> catching 10+ levels up or somthing probably means you need a monad wrapping it that can help you do that
02:58:18 <jle`> exceptions also don't really make sense unless you're in IO as well, remember
02:58:25 <Aetherspawn> I wouldnt even use exceptions for that..
02:58:41 <jle`> don't throw an exception if, for example, a pure function receives a bad parameter
02:58:48 <jle`> i'm looking at you head
02:58:54 <Aetherspawn> ^
02:59:18 <jle`> exceptions are supposed to exclusively be for IO i think
02:59:49 <Aetherspawn> any reason why head [] shouldn't just return [] ?
02:59:55 <Aetherspawn> nvm
02:59:57 <jle`> Aetherspawn: wrong type?
02:59:57 <Aetherspawn> I'm stupid.
02:59:58 <Tarrasch> jle`, You prefer to take totality as far as you can?
03:00:00 <Aetherspawn> lol
03:00:13 <lieven_> jle`: what would you have head [] do then?
03:00:28 <Aetherspawn> it sounded a lot better in my head before I thought about the actual type of head
03:00:30 <jle`> lieven_: i meant, don't write functions like head
03:00:51 <Aetherspawn> well, head :: [a] -> Maybe a
03:00:57 <jle`> head has to be head
03:01:05 <jle`> because of that whole head/tail law thing
03:01:10 <jle`> head xs : tail xs === xs
03:01:22 <allsystemsarego> Aetherspawn, that's called headMay
03:01:26 <jle`> you can always use listToMaybe
03:01:39 <randomclown> jle`: clearlu that's in correct
03:01:45 <randomclown> head [] : tail [] !== []
03:01:58 <randomclown> > (head [] : tail []) == []
03:02:00 <lambdabot>  False
03:02:05 <randomclown> tada
03:02:12 <jle`> randomclown: well :| for non empty xs v.v
03:02:33 <jle`> it's something older than Haskell
03:02:36 <Tarrasch> randomclown, but there are infinitely many other cases where it is true! ;)
03:03:34 <jle`> Tarrasch: totality is nice because you have a compiler that can help you reason about types so well
03:03:38 <randomclown> it takes on counter example to show the whole ting to be false
03:04:19 <jle`> so if you have partial functions everywhere you are really telling the compiler that you don't want its help
03:04:19 <lieven_> dependent types in combination with a NonEmptyList a type might be feasible with a sufficiently smart compiler
03:05:36 <jle`> i mean with Haskell you have the ability to move so many of otherwise runtime errors to compile time
03:05:42 <jle`> why move them back into runtime?
03:06:51 <Tarrasch> jle`, could it be performance? I mean you maybe don't want to check for `Just x` between each function call
03:07:11 <jle`> (performance is the main reason yes)
03:07:12 <jle`> but
03:07:28 <jle`> you can usually structure yourself around it
03:08:24 <jle`> anyways the main idea is that once you start using partial functions you throw away a whole swath of compiler-enforced guaruntees
03:08:30 <jle`> and now you have to use human-enforced guaruntees
03:08:40 <jle`> so if you are a smart human...
03:22:53 <nicoo> jle`: What do you mean by “partial functions”? Non-terminating ones?
03:23:51 <randomclown> ones that fail with exceptions
03:24:02 <randomclown> > head []
03:24:03 <lambdabot>  *Exception: Prelude.head: empty list
03:27:50 <nicoo> randomclown: Failing with exception without using a monad for that is eviiiiiiiiiiiiil
03:29:12 <randomclown> eh, yolo
03:29:22 <allsystemsarego> > headMay []
03:29:24 <lambdabot>  Not in scope: `headMay'
03:29:34 <tikhon> :t listToMaybe
03:29:35 <lambdabot> [a] -> Maybe a
03:29:35 <allsystemsarego> > Safe.headMay []
03:29:37 <lambdabot>  Not in scope: `Safe.headMay'
03:29:42 <randomclown> pfff Safe.
03:29:54 <tikhon> also: http://hackage.haskell.org/package/spoon
03:29:56 <tikhon> spoon
03:30:08 <randomclown> More like JohnsonsBabyNoTears.head am i right?
03:30:18 <tikhon> what a wonderful name for a package: spoon
03:34:37 <tikhon> has anyone used HaRe?
03:34:42 <tikhon> the Haskell refactoring thing
03:35:54 <allsystemsarego> that thing is pretty much tied to emacs
03:36:08 <tikhon> I'm happy with that
03:36:10 <Maior> "Currently, HaRe is a full Haskell 98 refactoring tool for automated refactoring of Haskell 98 programs. It is integrated with Emacs and Vim"
03:36:14 <Maior> woo vim
03:36:19 <allsystemsarego> oh
03:36:24 <tikhon> euh, not as happy with Haskell 98 though :/
03:36:30 <allsystemsarego> I stand corrected
03:37:30 <tikhon> I'm mostly curious about how well it works and how easy it was to install
03:39:50 <Fuuzetsu> try and see ;)
03:40:32 <tikhon> I would have, except being tied to Haskell 98 isn't really an option right now
03:40:44 <tikhon> I use extensions pretty promiscuously in my current projects
03:40:46 <mrmonday> is there some way, given a [(a, b)] to get a [(a, b)] with values of a interspersed? eg (a,b), (a,c), (b,d) would become (a, b), (b, d), (a, c)
03:41:32 <Maior> I...don't understand
03:41:49 <tikhon> mrmonday: what exactly do you mean by "interspersed"?
03:42:09 <Fuuzetsu> I think he wants to re-order… Maybe?
03:43:14 <mrmonday> basically, I have the output from Data.Map.assoc (a list of key value pairs) and I want a list which doesn't have all the keys next to each other in it
03:43:53 <mrmonday> which I realise having typed that makes zero sense
03:44:12 <mrmonday> lemme go think about it, sorry :<
03:46:25 <pjdelport> mrmonday: What's the background of what you're doing?
03:46:28 <Fuuzetsu> common occurrence
03:53:07 <bahamas> that's why a rubbed duck is useful :P
03:54:55 * hackagebot cabal-db 0.1.4 - cabal-db  http://hackage.haskell.org/package/cabal-db-0.1.4 (VincentHanquez)
04:07:45 <ion> jle: That was a rather nice talk, thanks for linking.
04:25:26 <mrmonday> I'm looking for a function [(a,b)] -> [(a, [b])], does such a thing already exist? I can't seem to find anything with hoogle. How would I go about implementing it?
04:25:50 <tikhon> take a look at some of the existing Data.List functions
04:26:01 <tikhon> something like groupBy would probably help
04:26:10 <tdammers> mrmonday: what should that function do?
04:26:18 <Fuuzetsu> IIRC there's a function like that you can use with Data.Map
04:26:19 <pjdelport> mrmonday: What do you want it to do? Just wrap the second item of each tuple?
04:26:46 <Fuuzetsu> fromListWith
04:26:47 <tdammers> @djinn [(a,b)] -> [(a, [b])]
04:26:47 <lambdabot> Error: Undefined type []
04:27:05 <simon> mrmonday, it would group the bs under each a?
04:27:06 <tikhon> djinn isn't going to like lists in general
04:27:08 <mrmonday> for each a value, I want the b values to be concatenated
04:27:12 <tdammers> shame
04:27:26 <mrmonday> simon: that's the one, yeah :)
04:27:40 <tikhon> mrmonday: take a look at groupBy
04:27:45 <tikhon> :t groupBy
04:27:46 <lambdabot> (a -> a -> Bool) -> [a] -> [[a]]
04:28:57 <tikhon> it's probably the best starting point—I don't know of a single function to do all that for you
04:29:46 <mrmonday> I'm ultimately trying to construct a Map a [b], there only seems to be a function for Map a b though unfortunately
04:30:10 <pjdelport> mrmonday: b can be [t]
04:30:30 <simon> mrmonday, ah, that should be easier. fold over the list and Data.Map.insertWith each tuple
04:31:09 <mrmonday> simon: lovely solution, thank you :)
04:31:22 <simon> mrmonday, you need Ord a => ..., though.
04:31:51 <pjdelport> mrmonday: you could say: fromListWith (++) . map (\(a,b) -> (a,[b]))
04:32:51 <mrmonday> ooh
04:33:06 <mrmonday> awesome, thanks!
04:33:53 <pjdelport> or map (second (:[])) if you're feeling more pointless
04:33:54 <simon> given the right type signature, map (\(a,b) -> (a,[b]))  =  fmap return
04:35:36 <pjdelport> mrmonday: What are your keys and values? Are they related?
04:40:39 <mrmonday> pjdelport: they are related. I probably shouldn't be using a map but I made some bad decisions early on and it's easier to work around them than it is to change everything I've already written
04:41:19 <pjdelport> How are they related, and where do they come from?
04:41:21 <mrmonday> I'm not really happy with it but I'm on a deadline and I never have to look at the code again once it's done :3
04:41:51 <pjdelport> I'm just asking in case there are ways to simplify / skip work.
04:43:09 <mrmonday> I'm working on a classifier for politician's based on their votes, eg given a set of votes in a number of elections, can you identify their political party
04:43:58 <mrmonday> the map is from political party to [[Double]] (list of known votes for known mps in that party)
04:44:27 <mrmonday> the reason it's in the other format [(a,b)] is so I can do k-fold validation
04:44:44 <mrmonday> easiest to pull out chunks of the data that way
05:11:50 <seksifemale> hi
05:19:06 <theorbtwo> mrmonday: Surely, a vote is an enum-type-thingy -- aye,no,counting-the-no-lobby-but-not-voting-in-it,counting-the-aye-lobby-but-not-voting-in-it,did-not-vote,voted-in-both-lobbies, and a bill is an integer or similar... so why Doubles?
05:19:35 <theorbtwo> Er, s/bill/division/
05:20:17 <mrmonday> makes the maths easier
05:27:39 <c_wraith> mrmonday: in what way is Double easier than Integer?
05:29:20 <mrmonday> well if you combine the votes based on some likelihood you end up with a double anyway, since the likelihood will be between 0 and 1
05:29:23 <mrmonday> for example
05:30:04 <mrmonday> or if you're plotting the points in n-dimensional space and want to find the distance between them, you end up with a double
05:30:19 <mrmonday> s/double/floating point/g
05:30:20 <c_wraith> That's no excuse for storing the raw data in a lossy format
05:30:39 <bennofs> mrmonday: I wouldn't use Double if I didn't need to. Floating point math is so crazy.
05:30:42 <c_wraith> also, haskell has plenty of non-floating point representations for non-integer numbers
05:31:04 <c_wraith> And since it's haskell, they're not a pain to use.
05:32:39 <c_wraith> Double is only suitable for scientific calculations with known significant digits.  For just about every other use, you want something better.
05:32:42 * haasn waits for the day a floating point bug alters the outcome of an election
05:33:56 <mrmonday> what do you recommend?
05:34:20 <c_wraith> Integer for storage of integral data.  After that, it depends on your use case.
05:34:32 <c_wraith> Possibly Rational, possibly something from Data.Fixed
05:34:43 <haasn> Possible Double
05:35:50 <mrmonday> Rational's no use when your calculations potentially give irrational numbers
05:36:26 <bennofs> mrmonday: so you calculating roots? Or pi/e/... ?
05:36:28 <c_wraith> You do know that Double is a rational expression internally?
05:36:46 <mrmonday> bennofs: yup
05:36:51 <c_wraith> I don't mean Haskell's Double type specifically, either.  I mean IEEE754 floating point numbers.
05:37:08 <mrmonday> c_wraith: I know, it represents irrationals sufficiently well though
05:37:31 <c_wraith> That's the thing.  *everything* represents them sufficiently well.
05:37:32 <haasn> :t realToFrac :: Double -> Rational -- magic
05:37:33 <lambdabot> Double -> Rational
05:37:43 <mrmonday> so why not use Double then?
05:38:32 <c_wraith> because floating point is rarely appropriate outside of scientific calculations.  Why waste a ton of your representational space in a ton of precision around 0 that you probably don't want?
05:38:52 <c_wraith> In science, that makes some sense.
05:38:57 <c_wraith> In finance, it makes no sense at all
05:39:11 <c_wraith> In most other areas, it makes no sense at all.
05:39:20 <mrmonday> does machine learning not count as science then? :<
05:39:34 <haasn> also NaN and Infinity
05:39:44 <c_wraith> machine learning is not an optimal use for floating point, but they use it because CPUs make it fast
05:40:00 <mrmonday> and there you have it :3
05:40:03 <c_wraith> and machine learning is all about crunching *huge* matrices
05:40:09 <mrmonday> it already takes minutes to run
05:40:16 <c_wraith> machine learning would be much better off with fixed-point
05:40:16 <tdammers> it doesn't matter if it's scientific or not; it just so happens that science has a lot of use cases for the kind of precision characteristics that come with floats
05:41:19 <tdammers> stuff that behaves somewhat logarithmically with a well-defined zero, something like that
05:41:59 <Mikicacarica> BEST VIDEO EVER --- > http://interesting-animals.com/the-original-grumpy-cat
05:43:42 <c_wraith> My favorite story about floating point came from Quake 3, which used 32-bit floats for its map coordinate system.  The expansion had some maps that were so large that with the coordinate origin in the middle of the map, adjacent float values at the edges were feet apart, in the game scale.
05:45:24 <c_wraith> coordinate systems are not something floating-point numbers are suitable for.
05:45:32 <OODavo> With the list monad I can "pick" one element from several lists, and keep only the chosen collections of elements that pass a 'guard'. For a fixed number of lists this is straightforward, a <- firstList; b <- secondList; guard $ onBothLists; return [a, b] or whatever. How would I go about generalising this so that, given a list of lists, I can choose one element from each inner list and filter the results
05:45:34 <OODavo> with a guard? Should I just ignore the monad and work with maps/filters/whatever?
05:47:00 <Cale> OODavo: Pick a list from the list of lists, then pick an element from that list
05:47:24 <c_wraith> OODavo: at a broad level, sequence is "pick an element from each of the lists in the list passed in".  Adding filtering to that, though, makes things more complex.
05:47:42 <Cale> Or, is it sequence that you're looking for?
05:47:47 <c_wraith> > sequence [[1,2],[3,4],[5,6]]
05:47:48 <lambdabot>  [[1,3,5],[1,3,6],[1,4,5],[1,4,6],[2,3,5],[2,3,6],[2,4,5],[2,4,6]]
05:47:51 <OODavo> It very well might be sequence.
05:48:49 <c_wraith> But if you want to filter as that produces elements (bounding a search that's clearly going in the wrong direction, for instance), you're going to have to do something else.
05:49:15 <OODavo> Hmm. I'll poke around a bit with sequence and see if that fits. Thanks.
05:49:54 <knz> hoi
05:49:56 <greg`_> im suprised sequence works like that
05:50:29 <c_wraith> greg`_: it has no other choice, given what the [] monad instance does.  It just takes a bit to think through it. :)
05:50:31 <knz> question: is there some equivalent of show (:: a -> String) which prints its argument withut evaluating it? (ie serializes the unevaluated expression graph)
05:51:17 <c_wraith> knz: Not really.  the vacuum package has some stuff that's close, but it doesn't look into unevaluated expressions, just the evaluated ones
05:51:17 <Cale> knz: You're probably looking for vacuum
05:51:31 <triliyn> knz: there's a command in ghci for it
05:51:36 <triliyn> if it's just for debugging
05:51:41 <knz> good enough
05:51:45 <Cale> It can tell you the closure type of things without evaluating them
05:51:51 <Cale> and other data
05:52:03 <knz> oh
05:52:04 <c_wraith> knz: someone *did* mention working on a library that could introspect unevaluated thunks, but I don't remember who
05:52:07 <Cale> But yeah, the visualisation still needs to evaluate
05:52:09 <knz> but I dont want the type, I want the graph :)
05:52:25 <c_wraith> It was the...  main is usually a blog guy?
05:53:10 <c_wraith> oh, that's kmc.  Haven't seen him around in a while.  Not sure it was him.
05:53:53 <luite> i did a demo last year for ghcjs, keep hoping that someone will step up and write a proper introspector based on it :)
05:54:04 <Cale> knz: Reconstructing the graph in general is going to involve examining machine code for whatever platform things have been compiled for, because it's implicit in the code pointers which get jumped to
05:54:41 <Cale> (but if everything were compiled a bit differently, that would be easier)
05:54:46 <Cale> There's Hat
05:55:06 <Cale> http://hackage.haskell.org/package/hat
05:55:26 <Cale> http://projects.haskell.org/hat/
05:56:31 <Cale> If your program doesn't use too many extensions, it might work
05:58:04 <knz> Cale: thx will look into it
05:58:11 <knz> what about Vacuun.vacuunLazy?
05:58:13 <knz> -n+m
05:58:36 <c_wraith> knz: that's the one that will show you "I found an unevaluated thunk", but not its contents
05:58:43 * quicksilver wonders where mmorrow went, again
05:58:45 <knz> ah grumbl
06:00:10 * hackagebot electrum-mnemonic 0.1.2 - easy to remember mnemonic for a high-entropy value  http://hackage.haskell.org/package/electrum-mnemonic-0.1.2 (JoeyHess)
06:01:38 <knz> ok I like hat
06:01:50 <knz> it's not what I wanted today, but is what I wanted complementarily tomorrow
06:01:57 <knz> Cale: thx
06:04:01 <knz> Cale: felsin9.de/nnis/ghc-vis seems to fit the bill
06:11:59 <hcaulfield57> Quick question (hopefully), since the State moand is really just StateT s Identity, if I had a State monad like State String Int or something, and get is get :: m s, what is the 'm'? Identity Int
06:13:47 <randomclown> is there literally no way to do IO inside stm
06:14:14 <c_wraith> randomclown: there is very much no way to do IO inside STM.  You know that STM actions can retry arbitrarily many times, right?
06:14:27 <randomclown> c_wraith: yeah, it's just super annoying
06:14:48 <c_wraith> randomclown: you can return an IO action from an STM transaction - you just can't execute it there.
06:14:58 <randomclown> I know I know
06:15:04 <quicksilver> well there is unsafeIOtoSTM if you're trying to write your own custom transactional system
06:15:09 <randomclown> I just want to log out some internal state
06:15:18 <randomclown> but stm's just a brick wall
06:15:21 <quicksilver> and when you break it, you get to keep both pieces, as they say.
06:15:49 <c_wraith> randomclown: Why not WriterT?
06:15:52 <quicksilver> if only STM gave you a way to hook custom stuff into the rollback/retry as well.
06:16:22 <randomclown> c_wraith: beacuase I want to use the logging package
06:16:33 <randomclown> so it's consistent with all the other logging I do
06:16:59 <c_wraith> Psh.  A logging package that doesn't give you the option of working as WriterT doesn't deserve to be called such. :)
06:17:40 <c_wraith> ...  Nevermind me, I'm just thinking of my next article on fpcomplete.  It's going to be about designing a logging package with operational, so that it can do things like that.
06:18:00 <randomclown> I look foward to seeing the replacement to hslogger
06:18:04 <c_wraith> consistent interface, but you can run it in different ways as needed.
06:18:11 <quicksilver> randomclown: http://www.haskell.org/hoogle/?hoogle=unsafeIOToSTM then
06:18:11 <randomclown> but for now I'm between a brick wall and STM
06:18:19 <randomclown> quicksilver: this is for production btw
06:18:20 <quicksilver> randomclown: it's easy enough. Just be aware of the downsides
06:20:45 <hcaulfield57> Err, the 'm' would just be Identity in that example?
06:20:53 <quicksilver> hcaulfield57: yes.
06:21:13 <quicksilver> hcaulfield57: no.
06:21:16 <quicksilver> hcaulfield57: sorry :)
06:21:28 <quicksilver> hcaulfield57: in the signature of 'get' the 'm' is the whole monad stack.
06:22:53 <hcaulfield57> quicksilver, but for State String Int, what is the m? Unless that's what you meant haha
06:24:00 <randomclown> depeneds on what you stack StateT with
06:24:35 <quicksilver> hcaulfield57: m is (State Int) or (StateT Identity Int)
06:24:37 <c_wraith> hcaulfield57: there is no m in State String Int.  What m are you talking about?
06:24:42 <quicksilver> hcaulfield57: which are just two names for the same thing.
06:24:49 <quicksilver> c_wraith: the 'm' in the type signature of 'get'
06:24:54 <quicksilver> @type get
06:24:54 <lambdabot> MonadState s m => m s
06:27:40 <hcaulfield57> quicksilver: Okay thank you, I think I sort of understand
06:29:53 <fryguybob> randomclown: I'm curious what the particular internal state is that you would want to see from inside a transaction and what you hope to do with it?
06:32:46 <fryguybob> randomclown: I'm asking because I doubt you want to log an inconsistent view of memory, but that's what you get inside a transaction.  If you really want other information to escape, you can do that atomically several ways.  You have the result of the action and you can write to some channel that you read from another thread for instance.
06:33:20 <randomclown> just for debugging
06:34:24 <randomclown> it is useful to have internal state in your logfiles
06:34:30 <randomclown> so you can go back and see what's wrong after
06:35:22 <fryguybob> randomclown: But how useful is it to see an *inconsistent* view of your log files?
06:35:24 <quicksilver> yes, the problem with STM from a debugging perspective is you can't get *anything* out in the case of a retry
06:35:27 <quicksilver> it's as if it never happeend
06:35:39 <quicksilver> which can make it hard to debug "why does this keep retrying"
06:35:56 <fryguybob> quicksilver: Do you mean aborting due to conflict?
06:36:10 <randomclown> fryguybob: can't you not assume the last output to be the *correct* one?
06:36:21 <quicksilver> I mean retrying due to conflict yes
06:36:49 <fryguybob> randomclown: Last from which thread?
06:37:19 <fryguybob> randomclown: I'm trying to say,  If you really only care about the consistent one, then log to another channel.
06:37:33 <randomclown> fryguybob: which you can't do inside stm
06:37:39 <randomclown> I can pick a thread to be the canonical one
06:37:43 <fryguybob> randomclown: Yes you can, just write to a TChan
06:37:56 <randomclown> gross
06:37:59 <c_wraith> ..  Or use WriterT.  :P
06:38:16 <randomclown> I think unsafeIOToSTM is ok for now
06:40:08 <quicksilver> c_wraith: the writerT will not log from rolledback attempts
06:40:57 <bennofs> fryguybob: even if you write to a TChan, the logs will not include logs from rolledback attempts, because the TChan will also be rolledback
06:41:22 <c_wraith> quicksilver: hmm, well.  I suppose so.  If what you want to log is why you're retrying, instead of just steps along the calculation
06:43:16 <quicksilver> c_wraith: and you might indeed wish you could log that if you were trying to debug a complex situation with many STM threads apparently retrying all the time :)
06:57:26 <Zero0> !request
07:10:22 * hackagebot esqueleto 1.3.4.6 - Bare bones, type-safe EDSL for SQL queries on persistent backends.  http://hackage.haskell.org/package/esqueleto-1.3.4.6 (FelipeLessa)
07:15:58 <Sculptor> hi
07:16:08 <heatsink> hi sculptor
07:20:28 <makalu> let's say I have two functions, a and b. A takes a single element, b takes a list of elements and uses a to do something with them. Is there a naming convention for b? Like "somethingLookup" is a convention for functions returning Maybe.
07:21:04 <heatsink> It depends on what b does
07:21:37 <heatsink> Usually those functions use the name of the corresponding list function
07:21:55 <heatsink> For example, there are many functions with "map" in their name
07:22:13 <makalu> do you have a real life example (a library maybe)?
07:23:51 <heatsink> Compare Data.List, Control.Monad, Data.Array in the array package, and Data.Vector.Unboxed in hte vector package
07:26:13 <bennofs> Is there currently any logging library that does not use IO ?
07:26:14 <makalu> ok. Thank you.
07:26:16 <merijn> makalu: Arbitrary notational note: a and b are usually names reserved for non-function values (in both math and haskell), for functions it would be more common to use f/g/h
07:26:32 <makalu> merijn: that's actually good to know. Thanks.
07:26:34 <bennofs> (At least not for logging messages. It can of course use IO for printing them :) )
07:26:54 <makalu> (I have a bachelor's degree in CS so I should know this already :)
07:27:24 <heatsink> Does the function use side effects or return something, makalu?
07:27:26 <merijn> makalu: To be more precise, math would use a/b/c for constant but unknown values, f/g/h for functions, i/j/k for indices and x/y/z for variables
07:28:16 <heatsink> I didn't know about that use of a
07:28:45 <heatsink> I've always seen them used as type variables because α,β,γ are hard to type
07:30:18 <merijn> heatsink: In haskell, yes
07:30:37 <merijn> heatsink: Also because the notion of a "constant but unknown value" makes no sense in a programming language like haskell
07:30:54 <merijn> heatsink: That usage is more for solving equations like "ax^2 + bx + c = 0"
07:31:04 <heatsink> We call those global variables :)
07:31:09 <Maior> psh, alpha and beta are equivalence and reduction ;P
07:31:12 <makalu> heatsink: it's an IO wrapper to a C procedure. I basically insert things into a container and I wanted to make an interface where you build a list of values which are then inserted instead of calling insert for every single value. I can't just use map because the C wrapper is polymorphic and you can insert elements of different type.
07:32:33 <makalu> I guess "fromList" like Data.Map would be interesting. But it's no immutable so maybe supporting multiple calls of a fromList-like function would be useful.
07:32:33 <merijn> makalu: Oh
07:32:44 <merijn> makalu: I have an implementation for that, if you're not easily intimidated
07:33:09 <merijn> makalu: You'll have to rip it out of the surrounding code, but it should help you get started. It abuses some more advanced GHC stuff, though
07:33:47 <heatsink> makalu: There's a naming convention of always using a verb in side-effecting function names.  insertList sounds reasonable to me.
07:34:18 <makalu> merijn: well my thing is very simple. I just had to tackle one of the hardest problems in CS (naming things :). But if you give me a link I will be happy to read it.
07:34:43 <merijn> makalu: Oh, so you just need a name?
07:34:58 <makalu> yes
07:35:58 <bennofs> If I want to log from a pure computation, should I use Writer [LogMessage] or Producer LogMessage Identity  (Producer from pipes or conduit) ?
07:36:08 <bennofs> Or something else?
07:36:11 <merijn> makalu: I defined a polymorphic list datatype and then had a "foldWith :: (forall a . Entry a -> b -> b) -> PolyList x -> b"
07:36:28 <dwcook> bennofs, those do different things, but from your description, I would guess the first
07:36:37 <merijn> makalu: So it folds entries for the polymorphic list into a "b" (which could be, for example, inserting into a container)
07:37:06 <makalu> nice
07:37:10 <bennofs> dwcook: how are they different? They seem to be the same to me. I also heard that Writer may cause space-leaks?
07:37:14 <dwcook> bennofs, well, I can see how either would serve, actually. Depends what you want to do with the messages
07:37:48 <merijn> makalu: So I think a generic "foldWith" name would work, also compare what you want with the names found in Data.Foldable
07:38:38 <merijn> makalu: Because the operation you describe is just a fold over your polymorphic list/values
07:39:10 <kuribas> Is there a recommendation for toplevel module names?
07:39:19 <kuribas> Like Math, Data, Control, etc...
07:39:36 <dwcook> bennofs, yeah, Writer can build up thunks if the mappend it uses isn't strict, which I think it wouldn't be in this case
07:40:06 <makalu> thanks heatsink and merijn
07:41:24 <joneshf-laptop> hey
07:41:32 <joneshf-laptop> is there a good metric space library on hackage?
07:42:02 <joneshf-laptop> or maybe better, how do you decide wht a good package is on hackage?
07:42:12 <bennofs> Btw, I also wondered, is there a performance difference between data List a = List (forall m. Monad m => (a -> m ()) -> m ()) (passing the function for folding as an argument) and just using [a] and forM_
07:42:18 <bennofs> ?
07:43:05 <bennofs> I think I just know too many general purpose libraries. It seems like I can write everything with each of thewm
07:43:25 <dwcook> bennofs, I'm going to change my recommendation and say go with the Producer.
07:44:58 <dwcook> Because the main difference I can see is that in that case you'd avoid the potential Writer leaks and also be able to handle messages individually
07:49:01 <ZWJ> can anybody help me with ghc's cmm?
07:55:58 <eacameron> is there an infix operator for filter (like <$> for fmap)?
07:56:16 <dwcook> `filter` :)
07:56:28 <eacameron> dwcook: I was waiting for that... ;)
08:10:55 <dmj`> anyone using 7.8 w/ snap?
08:11:44 <bennofs> How can I do space profiling in multi-process haskell programs?
08:12:15 <heatsink> Multi-process, not mult-threaded?
08:12:31 <bennofs> yes, multi-process
08:13:41 <cschneid> at what point does low memory cause problems w/ ghc? is 512 ok for small/med sized projects?
08:14:07 <bennofs> cschneid: 512M/K/G ?
08:14:24 <cschneid> heh, thanks. 512M.
08:14:34 <heatsink> I don't know if there's a tool for that.  Maybe it is feasible to look at individual processes' profiles.
08:14:35 <cschneid> looking at enabling dev on low end vm boxes
08:14:38 <tromp_> i thought i'd never see this (in a blog mentioning Haskell): "I think it has way too much syntax"
08:15:06 <tromp_> from http://blog.fourthbit.com/2014/03/01/the-best-programming-language-or-how-to-stop-worrying-and-love-the-code#.UxRMIIfvkjI.hackernews
08:15:32 <bennofs> heatsink: how do I get the individual processes' profiles? I'm using +RTS -h, but I think if I use forkProcess, then both processes write to the same .hp file.
08:15:50 <bennofs> heatsink: which makes it unusable (hp2ps fails with an error)
08:16:47 <heatsink> Oh, I see
08:18:09 <heatsink> I'd suggest filing a GHC bug report for that
08:22:00 <heatsink> I've only used MPI for multi-process programs.
08:23:38 <t7> tromp_: i wonder if anyone can write a blog post detailing their opinion on most programming languages without starting a flame war ...
08:24:38 <tromp_> he's actually quite positive about Haskell. maybe he's just referring to type annotations
08:24:40 <monochrom> I think I did. http://www.vex.net/~trebla/haskell/prerequisite.xhtml#leibniz criticizes almost most programming languages at once :)
08:25:02 <monochrom> then again, I don't call it a "blog post" :)
08:25:20 <tromp_> but really, those are worth their  syntax weight in gold
08:32:12 <ZWJ> does anyone know if there is a way to fed ghc with manually written cmm code?
08:33:26 <heatsink> I presume so
08:33:46 <heatsink> since GHC's source code contains cmm files
08:34:42 <ZWJ> unfortunately you dont know how?
08:35:24 <heatsink> I've never tried it
08:35:32 * hackagebot plugins-multistage 0.3 - Dynamic linking for embedded DSLs with staged compilation  http://hackage.haskell.org/package/plugins-multistage-0.3 (AndersPersson)
08:35:36 <quicksilver> ZWJ: https://ghc.haskell.org/trac/ghc/wiki/Commentary/Compiler/CmmType#CompilingCmmwithGHC
08:35:48 <heatsink> but ghc seems to compile CMM if the filename ends with .cmm
08:37:44 <sellout-> So, since the axiom of choice can be proven via the rules of HoTT, does that give it a stronger basis for use in constructive proofs than its status as a axiom in ZFC?
08:38:01 <sellout-> (And is there a better place for me to direct my naïve HoTT question?)
08:39:13 <bartavelle> sellout-, /join ##hott, there is a dedicated channel
08:39:38 <sellout-> bartavelle: Ah, fantastic. Thanks.
08:40:43 <klrr_> http://www.haskellcast.com/episode/006-gabriel-gonzalez-and-michael-snoyman-on-pipes-and-conduit/
08:40:48 <klrr_> Episode 6 - Gabriel Gonzalez and Michael Snoyman on Pipes and Conduit
08:40:50 <klrr_> Haskell Cast
08:42:31 <ZWJ> ty quicksilver
08:44:12 <mkscrg> hey all, is there a convenient way to write a "context synonym"?
08:44:16 <mkscrg> e.g. rather than writing '(MonadReader Foo m, MonadLogger m, MonadIO m) =>' everywhere, i'd rather write '(MonadSite m) =>'
08:44:28 <ParahSailin> ZWJ: yes, i've done some cmm to feed ghc
08:45:02 <bartavelle> mkscrg, I think the extension is called something like ConstraintKind
08:45:17 <quicksilver> you don't even need an extension for that, mkscrg, bartavelle
08:45:21 <quicksilver> there is a longstanding hack
08:45:44 <bartavelle> ah !
08:45:45 <ZWJ> ParahSailin, how did you do this?
08:45:49 <heatsink> mkscrg: Use the ConstraintKinds extension, then define a type synonym for the context
08:45:50 <quicksilver> class (MonadReader Foo m, MonadLogger m, MonadIO m) => MonadSite m where
08:46:01 <bartavelle> ahhh
08:46:13 <ParahSailin> well, just ghc -c bla.cmm and it will spit out a .o file
08:46:13 <quicksilver> ^^ an empty class with a context is effectively a context synonym
08:46:14 <joelteon> ConstraintKinds has the benefit of not being a hack per se
08:46:23 <mkscrg> quicksilver: but then i have to define instances, no?
08:46:37 <quicksilver> mkscrg: you define one generic instance
08:46:44 <quicksilver> which covers everything
08:46:58 <quicksilver> s/generic/polymorphic/
08:47:05 <mkscrg> quicksilver: using UndecidableInstances?
08:47:08 <joelteon> it's basically s/class/instance
08:48:25 <quicksilver> it's not a terribile hack since it is quite in the spirit of the normal case of a new class which has a context and adds one method
08:48:31 <quicksilver> it's just a degenerate case of that
08:48:40 <quicksilver> but certainly the ConstraintKinds stuff feels more direct.
08:51:23 <ZWJ> ty ParahSailin it works
08:51:46 <ParahSailin> ZWJ: you managed to write some cmm that it compiles on the first try? im impressed
08:52:13 <bennofs> heatsink: If you want to try it out, here is a little example that seems to reproduce the bug: http://lpaste.net/100653
08:52:13 <ZWJ> yeah took a look at ghcs cmm parser
08:52:34 <ZWJ> but unfortunately its segfauling
08:54:01 <ZWJ> eL_Bart0, hey lieblingsadmin :)
08:54:07 <enthropy> quicksilver: I think ghc expands type synonyms sometimes, but doesn't never expand the class version... which makes the latter still useful IMHO
08:56:16 <cschneid> I never got an answer to my memory size question: what's the smallest reasonable memory for a ghc compile of a small/medium project? Is 512M too small? Doable, but maybe hiccups?
08:56:52 <heatsink> bennofs: I'll give it a try later
08:57:13 <bennofs> cschneid: I think that should be doable, provided that you don't use a lot of packages or TH
08:57:49 <cschneid> bennofs: ok. I'm setting up a package to get moving on haskell on nitrous.io (hosted dev environment) and their free tier is in the 512 range.
08:57:51 <cschneid> thanks
09:13:32 <zomg> cschneid: if you're doing web stuff 512 may prove to be too small... I always had a hard time trying to compile Yesod unless I added extra swap
09:14:13 <zomg> same with certain other common libraries like pandoc
09:14:14 <cschneid> zomg: good to know. Mostly I want to help the community with a super-lightweight way to spin up a working haskell env and run stuff. up to and including web sites
09:14:18 <cschneid> but 512 is pretty tight.
09:14:22 <kloplop321> Has anyone tried to use warp by sending a packet that looks like an HTTP request, and then all responses go into a null sink or so?
09:15:09 <kloplop321> The packet comes over UDP or so.
09:15:26 <zomg> cschneid: yeah something like snap might be more lightweight than yesod, not sure since I haven't used it... Plain warp itself is definitely pretty easy on the compilation.
09:16:17 <cschneid> zomg: cool. I'll have to experiment a bit honestly, it's really more up to the system they have (ie, do we have lots of swap when needed? Burst memory? I don't know... )
09:17:00 <zomg> Yeah, overall 512 has worked decent enough for me, just the few big packages which give you issues :)
09:18:59 <gamegoblin> Today where I live it is -16c and in a couple of days it will be 16c. Midwest USA weather... joy...
09:21:47 <mkscrg> cschneid zomg: i've been dealing w/ similar memory limits on ec2 micro instances. i've been deploying prebuilt code in docker containers to get around it
09:22:16 <mkscrg> might be more infrastructure than you could call "lightweight", though
09:22:25 <Maior> having your own package repo ftw
09:22:37 <cschneid> mkscrg: ideally I want to be able to tell anybody "hey, here's a nitrous invite, install the ghc pacakge and go to town
09:23:37 <mkscrg> cschneid: right, in which case separating the build and run environments is a no-go
09:24:15 <cschneid> mkscrg: yeah, it may just be "hey, it sucks for big packages, so here's some prebuilt binaries for common ones".
09:24:25 <cschneid> dunno. But I suppose compiling yesod is necessary to do anything with it
09:24:36 <cschneid> right? it's not just a package, it's your code that TH expands that's the hard part
09:26:51 <mkscrg> cschneid: in my experience the linker is what runs out of memory and gets killed
09:27:11 <cschneid> ok. I'll have to play with actual servers I imagine to get a feel for what works & doesn't
09:28:14 <mkscrg> cschneid: yeah, and you could always setup some swap for big builds. much slower but it gets the job done
09:28:35 <cschneid> mkscrg: well, in this case, it's a black box server so I don't have access to stuff like swap definitions.
09:31:19 <mkscrg> cschneid: i see, i'm not familiar with nitrous.io beyond their homepage
09:31:34 <cschneid> mkscrg: basically lightweight vms aimed at being IDEs
09:31:54 <cschneid> but they don't give root access for whatever reason
09:51:50 <gamegoblin> OK so I have an array of Maybe Strings. I'd like to concatenate them all together into one Maybe String (and fast-fail if anything is a Nothing)
09:51:55 <gamegoblin> I do this by...?
09:52:34 <joelteon> catMaybes
09:52:34 <enthropy> fmap concat . sequence
09:52:38 <joelteon> :t catMaybes
09:52:38 <lambdabot> [Maybe a] -> [a]
09:52:43 <gamegoblin> excellent
09:52:46 <joelteon> > catMaybes [Just 1, Just 2, Nothing, Just 3]
09:52:47 <gamegoblin> Didn't know about catMaybes
09:52:47 <lambdabot>  [1,2,3]
09:52:53 <gamegoblin> waaaait
09:52:54 <enthropy> catMaybes doesn't fail
09:52:57 <joelteon> whoops!
09:52:58 <Maior> none of those fail
09:52:59 <joelteon> i misread your question
09:53:00 <joelteon> sorry gamegoblin
09:53:02 <enthropy> > catMaybes [Nothing, Just 1]
09:53:03 <lambdabot>  [1]
09:53:07 <nimish_> mconcat ?
09:53:14 <Maior> :t mconcat
09:53:14 <lambdabot> Monoid a => [a] -> a
09:53:29 <Maior> nice
09:53:37 <joelteon> gamegoblin: catMaybes wouldn't do it, in this case I'd suggest writing your own function
09:53:43 <nimish_> > Just "a" <> Just "b"
09:53:44 <lambdabot>  Just "ab"
09:53:55 <nimish_> mconcat  [Just 1, Just 2, Nothing, Just 3]
09:54:02 <nimish_> >mconcat [Just 1, Just 2, Nothing, Just 3]
09:54:05 <joelteon> > mconcat [Just "a", Just "b", Nothing, Just "c"]
09:54:06 <lambdabot>  Just "abc"
09:54:09 <joelteon> huh.
09:54:11 <nimish_> :(
09:54:14 <Maior> yeah, DIY it
09:54:16 <enthropy> > let f = fmap concat . sequence in (f [Just 1, Just 2], f [Nothing, Just 1])
09:54:17 <joelteon> why do you want to fail?
09:54:17 <lambdabot>  No instance for (GHC.Show.Show a1)
09:54:17 <lambdabot>    arising from a use of `M31054074603845229881978.show_M31054074603845229881...
09:54:17 <lambdabot>  The type variable `a1' is ambiguous
09:54:17 <lambdabot>  Possible fix: add a type signature that fixes these type variable(s)
09:54:17 <lambdabot>  Note: there are several potential instances:
09:54:37 <gamegoblin> fmap concat . sequence seems to work
09:55:03 <enthropy> > let f x = fmap concat $ sequence x in (f [Just 1, Just 2], f [Nothing, Just 1])
09:55:05 <lambdabot>  No instance for (GHC.Show.Show a1)
09:55:05 <lambdabot>    arising from a use of `M79128417894946259841987.show_M79128417894946259841...
09:55:05 <lambdabot>  The type variable `a1' is ambiguous
09:55:05 <lambdabot>  Possible fix: add a type signature that fixes these type variable(s)
09:55:05 <lambdabot>  Note: there are several potential instances:
09:55:26 <Mon_Ouie> enthropy: concat concatenates lists, it can't add numbers ;)
09:55:34 <nimish_> > sequence [Just "a", Just "b"]
09:55:35 <lambdabot>  Just ["a","b"]
09:55:40 <nimish_> > sequence [Just "a", Just "b", Nothing]
09:55:41 <lambdabot>  Nothing
09:55:52 <enthropy> yeah too bad
09:56:04 <gamegoblin> I tried it in ghci and fmap concat . sequence worked
09:56:21 <gamegoblin> unless my tests weren't extensive enough
09:57:03 <gamegoblin> (fmap concat . sequence) [Just "hello, ", Just "world"]
09:57:15 <gamegoblin> > (fmap concat . sequence) [Just "hello, ", Just "world"]
09:57:17 <lambdabot>  Just "hello, world"
09:57:27 <gamegoblin> > (fmap concat . sequence) [Just "hello, ", Nothing, Just "world"]
09:57:28 <lambdabot>  Nothing
09:57:33 <gamegoblin> Seems to work?
10:05:42 * hackagebot mime-mail 0.4.4.1 - Compose MIME email messages.  http://hackage.haskell.org/package/mime-mail-0.4.4.1 (MichaelSnoyman)
10:06:52 <skypers>     Cannot use record selector `rendInterfaceExtract' as a function due to escaped type variables
10:06:54 <skypers> huh :(
10:07:30 <pavonia> What are escaped type variables?
10:07:46 <skypers> no idea :(
10:09:37 <supki_> skypers: paste the code?
10:10:06 <supki_> that's probably an existential qualification related problem, though
10:10:28 <johnw> pavonia: variables that just couldn't take it anymore
10:10:31 <skypers> supki_: yeah, alpounet just told me about that
10:10:37 <supki_> i.e. record selectors for an existentially qualified types are not functions
10:10:40 <supki_> oh, ok
10:11:46 <pavonia> johnw: Take what?
10:12:22 <johnw> living in a Haskell program? :)
10:12:34 <johnw> I am being facetious
10:24:40 <gamegoblin> so my haskell program exited and it says "killed"
10:24:48 <gamegoblin> what magic is this
10:24:54 <zomg> gamegoblin: it probably ran out of memory
10:25:01 <gamegoblin> mmmm gotcha
10:25:33 <gamegoblin> Aaaah I see where it could possibly infinitely recurse
10:25:47 <zomg> 'killed' usually means that the program was killed by something/someone, so unless another user killed it, it was killed by the system... system logs might contain more info
10:26:15 <zomg> but at least in my experienced things generally get killed only if they use so much memory the system can no longer handle it
10:28:00 <gamegoblin> helll yeeaaaaahhhh fixed it. My server now successfully defends against a slowloris attack.
10:28:00 <Hafydd> main = putStrLn "Killed"
10:28:06 <gamegoblin> Hafydd: Ha
10:32:35 <rusk101> lpaste.net/100654 Why does this crash for large N?
10:32:49 <rusk101> http://lpaste.net/100654 Why does this crash for large N?
10:35:54 <rusk101> Can anybody tell me why this crashes for large N? http://lpaste.net/100654
10:38:54 <orzo> I've seen a certain composition operator (.).(.) written as `oo` and as .: and .* ... I read .: had somewhat wide adoption among haskellers, but i dont think i believe that.  What are your preferences?
10:40:18 <fizruk> my preference is lambda or helper function
10:40:23 <geekosaur> most people don't bother with combinators like that
10:40:31 <bennofs> orzo: i like .:, but defined as (.:) = fmap . fmap
10:40:39 <johnw> orzo: other than (.:), I don't think anyone really uses that operator
10:41:01 <johnw> i've certainly never seen it used as ((.).(.)), that's pretty much just silly
10:41:20 <orzo> i mean defined that way, oo = (.).(.)
10:41:22 <orzo> they used `oo`
10:41:53 <chirpsalot> Does liftM f = return . f?
10:41:54 <rusk101> can anybody here take a look and see why this algorithm is crashing for large N? http://lpaste.net/100654
10:42:16 <johnw> :t return . (f :: a -> b)
10:42:17 <lambdabot>     Could not deduce (FromExpr b1) arising from a use of `f'
10:42:17 <lambdabot>     from the context (Monad m)
10:42:17 <lambdabot>       bound by the inferred type of it :: Monad m => a -> m b
10:42:25 <johnw> :t \f -> return . f
10:42:26 <lambdabot> Monad m => (a -> b) -> a -> m b
10:42:36 <orzo> why is (.).(.) silly
10:42:37 <Hafydd> rusk101: in what manner does it crash, and for what order of values of n?
10:42:38 <BMeph> orzo: That is an OCaML-ism, maybe, but it would be almost never used in Haskell.
10:42:39 <tomejaguar> orzo: 28 uses of .: here in the current 9k-line codebase I'm working on.
10:42:54 <Hafydd> I would guess it crashes by consuming too much memory.
10:42:56 <tomejaguar> I think .: is pretty popular
10:43:08 <BMeph> orzo: (That is, the oo thing, not the triple dots.)
10:43:10 <johnw> orzo: how is it not?  people here have issues with (f .) . g, and you think we should be using f (.).(.) g?
10:43:14 <Maior> :t (.).(.)
10:43:14 <lambdabot> (b -> c) -> (a -> a1 -> b) -> a -> a1 -> c
10:43:16 <Hafydd> (Sinces it keeps in memory all of primes')
10:43:38 <rusk101> primeFacts 1100001 and it returns [3,7,1069
10:44:18 <Hafydd> rusk101: that doesn't mean it's crashed; it's just taking a long time to compute.
10:44:26 <fizruk> any comonad experts here by chance?
10:44:44 <johnw> fizruk: I'm still waiting for a reason to use them :)
10:44:51 <chirpsalot> :t \f -> liftM f
10:44:51 <lambdabot> Monad m => (a1 -> r) -> m a1 -> m r
10:45:01 <BMeph> fizruk: No - all of our comonad experts are here on purpose! ;)
10:45:04 <chirpsalot> So, yes?
10:45:07 <Hafydd> rusk101: for me, that terminates with [3,7,1069].
10:45:21 <Maior> BMeph: lol
10:45:22 <johnw> liftM is not the same as return . f
10:45:31 <johnw> liftM f x is the same as x >>= return . f
10:45:37 <fizruk> johns, BMeph: i was trying to use them for particle simulation
10:46:33 <rusk101> Hafydd: I know that this is inefficient way of doing this. Plus im trying to get it to reutrnt he prime factorization of a number not just the primes deviding it.
10:46:48 <fizruk> BMeph: just haven't seen any last time I was here =P
10:46:50 <chirpsalot> johnw: hmmmm, okay.
10:47:21 <BMeph> chirpsalot: liftM (f :: a -> b) has type m a -> m b, for some Monad m. return . f has type a -> m b. Unless your 'm' is Identity, it seems "obviously" not true.
10:47:46 <Hafydd> rusk101: here are some words from Timothy Gowers on factorisation algorithms: http://i.imgur.com/UEnvR76.png
10:48:29 <chirpsalot> BMeph: oh, I don't know how I kept missing the 'm' >_<
10:48:30 <chirpsalot> Thanks.
10:48:31 <rusk101> Hafydd: LOL
10:48:39 <Hafydd> You'll note the similarity in aesthetic form to "[3,7,1069".
10:49:08 <rusk101> What you gave me didn't make sense but made me chuckle.
10:50:47 * hackagebot netpbm 1.0.1 - Loading PBM, PGM, PPM image files  http://hackage.haskell.org/package/netpbm-1.0.1 (NiklasHambuechen)
10:51:13 <rusk101> Hafydd: click on the link you sent me. There's nothing there
10:51:46 <fizruk> so, can some comonad expert check this out? https://gist.github.com/fizruk/dffd4454dd80c5641fa6
10:51:52 <Hafydd> rusk101: that's intentional. It was a joek.
10:52:01 <rusk101> lol ok
10:52:52 <tomejaguar> Hafydd: Was Tim's comment a joke?
10:53:09 <BMeph> fizruk: It is an abstraction, whose time has not yet come. Not that we don't understand them, just that, as johnw alluded, there isn't much of a compelling reason to use them as such, for now.
10:54:33 <Hafydd> tomejaguar: I believe it was.
10:54:40 <tomejaguar> fizruk: I don't understand why you would have 'gridpoint :: (i, a)' rather than 'gridpoint :: i'.
10:55:47 * hackagebot ntp-control 0.1 - Client library for NTP control messaging  http://hackage.haskell.org/package/ntp-control-0.1 (MagnusCarlsson)
10:56:07 <fizruk> tomejaguar: revision 2 has it that way, but (i, a) make implementation a bit simpler (i think)
10:57:46 <fizruk> anyway, my intention was to build a structure for moving points to compute each point's neighbours (and then forces and other quantities, apply them and so on)
10:58:26 <fizruk> this structure can be used without Comonad implementation but it seems to be cleaner that way (I may be wrong)
10:58:27 <tomejaguar> Looks like a fine comonad.  I guess you'd have to be sure that 'i' does not appear in the keys of 'gridMap' (unless there's some reason I don't understand that makes that OK).
10:59:36 <fizruk> tomejaguar: 'i' can appear in gridMap, but it should not contain 'snd . gridpoint' in a corresponding list
10:59:50 <rusk101> Ok. I got this to work, but is there a way to write the program better? http://lpaste.net/100654
10:59:57 <rusk101> More efficiently?
11:00:38 <fizruk> tomejaguar: I have a working SPH fluid simulation using 'Grid (Int, Int) Particle'
11:03:12 <tomejaguar> Oh I misunderstood what the Grid is.
11:03:18 <tomejaguar> What does it represent?
11:03:18 <fizruk> on problem is that I have to 'rearrange' Grid each time step (when 'a' objects move)
11:03:48 <fizruk> tomejaguar: essentially it's just a set of 'a' objects with 'i' positions
11:04:10 <fizruk> tomejaguar: Map is used for efficient access to object's neighbours
11:06:47 <fizruk> tomejaguar: suppose this: http://lpaste.net/100658
11:07:11 <fizruk> I have a set (list) of objects each with position :: Point
11:07:57 <fizruk> I divide continuous plane in cells of cellSize, thus obtaining Grid Cell a
11:08:36 <fizruk> now each object 'a' can be affected by its neighbours (e.g. objects that are closer that 'd')
11:09:21 <fizruk> so I make cell size = (d, d) and now I have to lookup for neighbours in current cell and adjacent ones
11:10:06 <fizruk> with Map I can make it efficient
11:10:17 <fizruk> tomejaguar: makes sense? =)
11:13:03 <clin88> Hi, does anyone know how to load `cabal repl` with language extensions?
11:13:09 <tomejaguar> fizruk: Well it makes enough sense for me to agree that it looks like a comonad.
11:13:27 <clin88> I'm trying to do the equivalent of `ghci -XOverloadedStrings` but with cabal repl
11:13:46 <dcoutts> clin88: --ghc-options
11:13:53 <clin88> thanks
11:14:07 <dcoutts> clin88: or once you've loaded, use :set -XOverloadedStrings
11:14:34 <fizruk> tomejaguar: my guess is this structure makes a lot of sense for simulations
11:14:35 <clin88> it worked! thanks :)
11:15:03 <fizruk> tomejaguar: so my first thought was "Have I reinvented something already existing?"
11:16:02 <cariveri> Hi. Im looking for a simply way to create a user interface. is there libraries for that?
11:16:04 <fizruk> the closest thing I've found so far is this old post by edwardk: http://comonad.com/reader/2008/the-pointed-set-comonad/
11:18:02 <Peaker> Is this a sane idiom for the async library?   wrap inner f = async (wait inner >>= f) ?
11:18:15 <Peaker> To approximate a Monad-like bind for Asyncs
11:18:18 <H1FuelCell> hey guys, what's the math symbol for 'where'?
11:18:30 <Peaker> Async a -> (a -> IO b) -> IO (Async b)
11:18:51 <H1FuelCell> like E is 'for every' and the euro symbol is 'belongs to'
11:18:51 <Peaker> I could try to build the async itself differently, but that's less composable
11:19:15 <tomejaguar> fizruk: There are some comonadic Game of Life simulations floating around, if you're interested.
11:19:52 <fizruk> H1FuelCell: in { x | x ∈ N } '|' can be read as 'where', i guess
11:21:03 <H1FuelCell> fizruk: nah... not quite what I'm looking for, but damn, math expressions look nice on the screen
11:21:43 <levi> cariveri: threepenny-gui might work for you
11:21:51 <fizruk> tomejaguar: yeah, I know, read them already. Grid is like that but with objects floating from cell to cell
11:22:15 <fizruk> tomejaguar: one thing that makes me uncomfortable is 'rearrange'
11:22:15 <Peaker> I have a little combinator to annotate IO exceptions with a wrapper that adds some information.. I wonder how many of the tiny utilities I wrote now make sense as additions to Hackage
11:23:21 <fizruk> tomejaguar: if you're interested I have a working SPH fluid simulation (using Gloss) for a concrete example
11:23:23 <pavonia> "like E is 'for every' and the euro symbol is 'belongs to'" -- What? :o
11:23:33 <Iceland_jack> pavonia: ∃ and ∈
11:23:44 <tomejaguar> fizruk: What is SPH?
11:23:55 <pavonia> Iceland_jack: Yeah, but "for every" is still wrong
11:24:08 <Iceland_jack> yeah, but those were the symbols they meant
11:24:12 <fizruk> tomejaguar: smoothed-particle hydrodynamics
11:24:15 <Cale> It's a rotated E, and something which is not very much like the Euro sign at all :P
11:24:30 <tomejaguar> Cool, good to see Haskell used for numerical stuff
11:24:32 <Rembane> And then there's the sigma. To make it all more awesome.
11:24:34 <Iceland_jack> ∀ for all, ∃ there exists, …
11:24:39 <Iceland_jack> Bread costs 2∈
11:24:48 <Cale> *twitch*
11:24:49 <Rembane> Or 2€
11:24:57 <Iceland_jack> 2∉
11:25:20 <Iceland_jack> ∉ would be for debt :)
11:25:46 <fizruk> tomejaguar: sent pm
11:27:49 <bitemyapp> Peaker: if you can group them into categories like "exception-utils" that could make for a neat library on Hackage.
11:28:07 <bitemyapp> Peaker: I know that at minimum, if that's too much hassle, I'd really appreciate a posting of the exception annotator to lpaste or github.
11:28:09 <Peaker> bitemyapp: I don't have more utils except that, yet :)
11:28:24 <bitemyapp> Peaker: well, lpaste/gh then? Please? :)
11:28:39 <Peaker> sec :)
11:28:58 <Peaker> bitemyapp: https://github.com/ElastiLotem/buildsome/blob/master/src/Lib/AnnotatedException.hs
11:29:42 <H1FuelCell> you can stop making fun of me now guys
11:29:58 <H1FuelCell> here's the math symbol for take it easy :P
11:30:04 <bitemyapp> Peaker: cool, thank you!
11:30:51 <Peaker> bitemyapp: various other utilities in Lib/ there
11:30:55 <Peaker> (but not exception-related)
11:31:33 <Peaker> some are redundant to lens, but this codebase needs to be accessible to complete newbies and ideally have a small footprint, dependency wise
11:36:28 <Peaker> why is IO not an instance of Monoid? :(
11:36:46 <Peaker> (standard Applicative-Monoid instance)
11:37:50 <cariveri> levi: thanks so far. looks great.
11:37:56 <dwcook> Peaker, what instance would that be?
11:38:07 <fizruk> Peaker: is has MonadPlus instal
11:38:12 <fizruk> instance
11:38:19 <jxv> :t mzero
11:38:19 <lambdabot> MonadPlus m => m a
11:38:22 <jxv> :t mplus
11:38:23 <lambdabot> MonadPlus m => m a -> m a -> m a
11:38:28 <dwcook> That's not a Monoid instance
11:38:31 <Peaker> instance (Applicative f, Monoid a) => Monoid (f a) where mempty = pure mempty ; mappend = liftA2 mappend
11:38:42 <jxv> dwcook, it's the same idea
11:38:42 <dwcook> Oh woop, didn't read the nick
11:39:04 <dwcook> Well you can't just choose a single empty is the problem
11:39:20 <Peaker> funnily, it's not even Alternative
11:39:34 <Peaker> fizruk: the MonadPlus instance isn't the recursive Monoid instance
11:40:14 <jfischoff> Peaker: Maybe because then IO would not be haskell 2010?
11:40:28 <jfischoff> I bet its just an oversight
11:40:54 <jfischoff> like the missing monad/applicative/foldable/traversable instances for First/Last etc
11:41:09 <dwcook> Peaker, let me put it this way: Monoid takes a *. Which * would you choose?
11:41:34 <Peaker> dwcook: instance Monoid a => Monoid (IO a) where ...
11:41:41 <dwcook> Ah, okay
11:42:33 <jfischoff> I think as a general rule, the types in Base should have all the instances that they can implement from the type classes in Base
11:42:59 <jfischoff> I am curious if there is a counter argument
11:43:21 <Iceland_jack> jfischoff: Would that include a Show instance for functions?
11:43:33 <Iceland_jack> or Num instance for functions
11:43:49 <jfischoff> Only show for if you can read it
11:44:05 <jfischoff> Num is out because of the overlap
11:44:16 <jfischoff> well
11:44:21 <jfischoff> no
11:44:22 <Iceland_jack> Just saying that the criteria isn't that obvious
11:44:35 <jfischoff> are there any laws for num?
11:44:47 <bitemyapp> Iceland_jack: lets not talk about num instances for functions.
11:44:58 <jfischoff> Show would diverge for many functions
11:45:31 <bitemyapp> jfischoff: only law for Num is (abs x * signum x == x)
11:45:41 <bitemyapp> that I'm aware of. I'd need to check the report to verify.
11:45:49 <jfischoff> I don't think num for functions make sense, how would you implement all of the methods?
11:45:56 <Iceland_jack> I wonder if you should be able to add the laws as pragmas...
11:46:09 <jfischoff> of annotations
11:46:10 <Iceland_jack> So that they could be displayed by ‘:info’
11:46:12 <jfischoff> s/of/or
11:46:15 <bitemyapp> Num apparently should be a ring, fromInteger a ring homomorphism, and abs/signum as above.
11:46:46 <jfischoff> so functions are out
11:47:09 <bitemyapp> Yeah.
11:47:26 <bitemyapp> but that was kind of a given wasn't it?
11:48:47 <bitemyapp> While reading up on the subject, I found: http://hackage.haskell.org/package/vector-space-0.8.6/docs/Data-VectorSpace.html
11:49:00 <bitemyapp> carter: ^^
11:49:00 <jfischoff> Sure, but the point is there something wrong with my claim that it you can implement a instance for a type in Base they can
11:49:07 <carter> bitemyapp: ?
11:49:08 <jfischoff> I guess a lawful instance
11:49:14 <bitemyapp> jfischoff: lawful, sure.
11:49:20 <carter> bitemyapp: jfischoff  i have plans to fix Num and friends
11:49:22 <jfischoff> Yeah I assumed that
11:49:28 <fizruk> so guys, no real world comonads?
11:49:30 <carter> and evade dealing with committee
11:49:41 <bitemyapp> i guess my point is that it was self-evident that the ruby DSL stack overflow was duuuuumb.
11:49:46 <carter> bitemyapp: jfischoff  step 1: get numerical haskell successful
11:49:46 <bitemyapp> fizruk: huh?
11:49:55 <carter> step 2: use my own numerical prelude
11:50:01 <bitemyapp> fizruk: people use comonads, depending on how Haskell-savvy they are.
11:50:21 <jfischoff> well there are other num instances of functions for different purposes, some less evil
11:50:23 <bitemyapp> fizruk: people use implicit, poorly specified and not-well-typed comonads in Java and C# all the time :)
11:50:35 <carter> naming abstractions gives them power!
11:50:44 <carter> so don't say YouKnowWhats name
11:50:47 <bitemyapp> carter: giving them laws makes them safe and composable!
11:50:53 * hackagebot LogicGrowsOnTrees 1.1 - a parallel implementation of logic programming using distributed tree exploration  http://hackage.haskell.org/package/LogicGrowsOnTrees-1.1 (GregoryCrosswhite)
11:50:55 * hackagebot LogicGrowsOnTrees-processes 1.0.0.1 - an adapter for LogicGrowsOnTrees that uses multiple processes for parallelism  http://hackage.haskell.org/package/LogicGrowsOnTrees-processes-1.0.0.1 (GregoryCrosswhite)
11:50:57 * hackagebot LogicGrowsOnTrees-network 1.0.0.1 - an adapter for LogicGrowsOnTrees that uses multiple processes running in a network  http://hackage.haskell.org/package/LogicGrowsOnTrees-network-1.0.0.1 (GregoryCrosswhite)
11:50:59 * hackagebot LogicGrowsOnTrees-MPI 1.0.0.1 - an adapter for LogicGrowsOnTrees that uses MPI  http://hackage.haskell.org/package/LogicGrowsOnTrees-MPI-1.0.0.1 (GregoryCrosswhite)
11:51:00 <carter> bitemyapp: i'm making a harry potter joke
11:51:07 <bitemyapp> carter: HPMOR?
11:51:13 <carter> "youknowhow"
11:51:16 <carter> vs "youknowwhat"
11:51:20 <bitemyapp> yeah
11:51:21 <carter> *who
11:51:27 <bitemyapp> carter: have you read HPMOR though?
11:51:27 <carter> hpmore is cool
11:51:29 <carter> yup
11:51:31 <bitemyapp> it's a ton of fun.
11:51:33 <carter> y
11:51:39 <bitemyapp> I can't wait for EY to finish the damn thing.
11:51:52 * bitemyapp goes back to debugging a crappy parser that can't round-trip its own output.
11:51:54 <carter> bitemyapp: i've given up on web design, i'm just doing to use the hakyll default theme for my shit until i have the time to yak shave
11:52:11 <bitemyapp> carter: I need to redo my site in terms of Hakyll, but the move has been disruptive.
11:52:22 <carter> bitemyapp: thats why i'm giving up on styling
11:52:32 <carter> after numerial haskell has been out for a month or so i can yak shave
11:53:01 <carter> bitemyapp: 'cause lts be honest, the hakyll defaults are hokey, but they're simple
11:53:07 <bitemyapp> yeah
11:53:20 <carter> bitemyapp: if i had the time... i'd figure out how to port the octopress theme and templates to hakyll
11:53:26 <carter> now *that* would be a nice hakyll init
11:53:32 <bitemyapp> I keep holding out on writing and publishing material because I know I'd need to fix up my site first, then I groan and just not bother.
11:53:34 <fizruk> bitemyapp: if something is a comonad, should I use it as a comonad then? e.g. in Conway's Game of Life extend is used once in a program, is it worth to define a Comonad?
11:53:40 <bitemyapp> carter: link the octopress theme you want
11:53:55 <carter> bitemyapp: yes, but the templating language is different
11:54:07 <carter> so that takes yake time
11:54:23 <carter> am i mkaing sense
11:54:28 <carter> or missing some trick
11:54:39 <bitemyapp> carter: link it.
11:54:48 <carter> link in the progrm
11:54:52 <carter> or give you a link?
11:55:02 <gamegoblin> Hi all. I have some code that ghc will compile, but hlint gives a parse error on
11:55:04 <carter> http://octopress.org/
11:55:07 <bitemyapp> carter: I want a link to an example or picture of the octopress theme you're talking about. I want to *see* it.
11:55:08 <gamegoblin> should I submit a bug report to hlint or what?
11:55:25 <bitemyapp> carter: you just want the default theme or a general way to port them?
11:55:36 <carter> theres other themes?
11:55:53 <bitemyapp> Presumably.
11:56:04 <alpounet> yes there are
11:56:05 <bitemyapp> maybe not baked in, but I'm sure others exist.
11:56:15 <carter> i guess so
11:56:15 <alpounet> i use a non-default theme for octopress atm
11:56:39 <augur> can anyone explain how generalized de bruijn indices work
11:56:40 <carter> bitemyapp: alpounet  either way, i don't have the time to figuring out fotran code and html in the same day
11:56:54 <carter> alpounet: no hakyll for you?
11:57:05 <bitemyapp> alpounet: link please?
11:57:49 <alpounet> carter: i used to run alpmestan.com on a hakyll instance, then switched to octopress, and now whenever i have some free time to hack on this, I'll get back to hakyll, with some custom stuffs because I have one more need compared to before.
11:57:56 <fizruk> bitemyapp: I guess you missed my question?
11:58:05 <alpounet> bitemyapp: http://alpmestan.com/
11:58:15 <bitemyapp> fizruk: it didn't make a ton of sense.
11:58:27 <bitemyapp> fizruk: cellular automata is one application of a very general concept (comonads)
11:58:49 <bitemyapp> fizruk: either your problem fits a comonad or it doesn't, but that `fitting` isn't limited to cellular automata.
11:59:44 <bitemyapp> fizruk: I actually prefer lenses as an example use of comonads, but it pulls in a bunch of other stuff too.
11:59:50 <carter> send help i'm writing fortran FFI stuff
12:00:05 <fizruk> bitemyapp: i meant what if some structure i use is comonadic, but I need to 'extend' only once
12:00:23 <augur> carter: surely you understand them!
12:00:25 <augur> no? :(
12:00:28 <carter> yes
12:00:45 <carter> its just  "omfg, how did science happen"
12:00:56 * hackagebot crypto-pubkey-openssh 0.2.5 - OpenSSH keys decoder/encoder  http://hackage.haskell.org/package/crypto-pubkey-openssh-0.2.5 (FedorGogolev)
12:01:20 <fizruk> bitemyapp: how lenses make an example use of comonads?
12:01:21 <levi> alpounet: That's a nice theme; it would be nice if there was a text justification mode that would not attempt to fully justify if it had to insert too much space between words, though.
12:01:26 <geekosaur> the way it usually does, which is less "eureka" than it is "oops"
12:01:30 <bitemyapp> alpounet: you might consider optimizing that background image for web, by the way.
12:01:45 <bitemyapp> fizruk: https://www.google.com/search?q=lenses+comonads&oq=lenses+comonads&aqs=chrome..69i57j0.2030j0j7&sourceid=chrome&espv=2&es_sm=91&ie=UTF-8
12:01:52 <alpounet> bitemyapp: it won't stay up there for long, don't worry
12:02:03 <bitemyapp> fizruk: there are some proof-oriented explanations as well as code-oriented ones.
12:02:12 <alpounet> levi: that's what I initially thought, but that doesn't fit what I want anymore
12:02:13 <bitemyapp> I can't really say which will make more sense to you.
12:03:39 <levi> I hacked some grid-based CSS layout calculation into a Clay-based stylesheet.
12:03:39 <enthropy> carter: fortran ffi is implementation defined, no?
12:03:53 <carter> enthropy: i think its C ABI compatible if your'e careful
12:03:53 <enthropy> you can f2c many things however
12:04:26 <carter> like, if you look at how hmatrix calls lapack, thejust call foo_
12:04:29 <carter> for the routine foo
12:04:45 <carter> *they just
12:04:54 <carter> at least for the f77 style apis
12:04:55 <enthropy> that's how gfortran mangles by default
12:05:24 * enthropy doubts you have guarantees about what another compiler does
12:05:27 <carter> yup
12:05:30 <dfarm> See http://www.fortran90.org/src/best-practices.html#interfacing-with-c
12:06:45 <carter> dfarm: enthropy  on linux, does lib lapack expose lapack_FOO functions?
12:07:02 <carter> on mac the clapack that apple provides doesn't
12:07:38 <enthropy> nm /usr/lib/liblapack.a   has no lapack_ symbols here
12:07:52 <carter> does it have stuff like dgesvx_ ?
12:08:04 <enthropy> of course
12:08:06 <carter> ok
12:08:08 <carter> cool
12:08:19 <carter> i'm going to be evil and hacky and assume FOO_ works
12:08:24 <carter> and fix it when someone gets a weird linker error
12:08:59 <enthropy> dfarm's suggestion is probably the way to go
12:09:10 <carter> writing bind c fortran wrappers?
12:09:36 <enthropy> or use somebody else's c bindings
12:09:51 <carter> i am i think
12:11:29 <carter> i'll add this as a ticket
12:11:48 <carter> for now i want to pretend its zero deps
12:11:50 <carter> :)
12:11:58 <carter> are there any c wrappers?
12:13:38 <enthropy> @google clapack
12:13:39 <lambdabot> http://www.netlib.org/clapack/
12:13:39 <lambdabot> Title: CLAPACK (f2c'ed version of LAPACK)
12:13:49 <carter> yes
12:13:55 <enthropy> @google lapacke
12:13:57 <lambdabot> http://www.netlib.org/lapack/lapacke.html
12:13:57 <lambdabot> Title: The LAPACKE C Interface to LAPACK
12:14:01 <carter> enthropy: problem
12:14:07 <enthropy> probably 50 others
12:14:11 <carter> i'm trying to make it sanely zero config
12:14:15 <dfarm> http://www.netlib.org/lapack/lapwrapc/
12:14:34 <enthropy> well you may be allowed to upload stuff like clapack to hackage
12:14:52 <enthropy> the haskell binding to zlib is a good example of such
12:15:04 <carter> oh
12:15:15 <carter> you mean just include clapack inline?
12:16:05 <enthropy> you can put it in separate files
12:16:19 <enthropy> I'll be back later this evening
12:16:26 <carter> yeah
12:16:36 <carter> i'm going to put some notes on this online
12:16:39 <carter> but for now i have to punt
12:16:49 <carter> though i agree doing this *right* is important
12:16:50 <dfarm> Something just occured to me. This is specifically for openblas right?
12:16:55 <carter> dfarm: yes/no
12:17:01 <carter> i'm kinda leaning towards not
12:17:10 <carter> but mebe I should still have that be the defualt
12:17:31 <carter> dfarm: why?
12:17:45 <carter> dfarm: the real goal is to have a zero config ffi layer that just works
12:17:50 <carter> and is easy to add stuff to
12:18:04 <dfarm> OpenBLAS already comes with C bindings
12:18:18 <carter> dfarm: one issue with lapacke is that it does off heap allocations
12:18:19 <carter> yeah
12:18:33 <carter> and the off heap allocations make space behavior opaque to ghc
12:18:50 <carter> hmatrix actually has this as an issue in its design
12:19:46 <dfarm> Yeah, being able to cross even the big ones like ATLAS, MKL and openblas could be pretty tricky.
12:20:02 <carter> cross == support?
12:20:19 <dfarm> Yeah
12:20:39 <carter> do you ahve atlas on you machine?
12:20:46 <dfarm> in other words the cartesian product of atlas, mkl, openblas * windows, mac, linux (I'm assuming)
12:21:04 <dfarm> versus just dealing with openblas which has good performance and a reasonable license across platforms will be tricky enough (but useful)
12:21:04 <carter> dfarm: if you look at how hmatrix does the ffi stuff
12:21:20 <carter> i think its actually simpler than you'd assume
12:21:26 <dfarm> I'm so new to Haskell it hurts (I'm actually a scipy guy, trying to cross over)
12:21:31 <carter> cool
12:21:42 <carter> i'm going ot assume for now FOO_ works
12:21:43 <dfarm> So anyway take with a grain of salt, but I am pretty familiar with the fortran/c science stuff
12:21:44 <carter> and fix it later
12:22:14 <carter> lets switch to #numerical-haskell, we're eating up this place
12:22:21 <dfarm> Sure
12:24:34 <Heffalump> how do I make Lens' s a -> Lens' s b -> Lens' s (a, b) ?
12:25:23 <tomejaguar> Heffalump: You have to be careful in general.  If the 'a' and 'b' overlap, it's not a valid lens.
12:25:51 <Heffalump> ah, good point
12:25:58 * hackagebot cabal-db 0.1.5 - query tools for the local cabal database (revdeps, graph, info, search-by)  http://hackage.haskell.org/package/cabal-db-0.1.5 (VincentHanquez)
12:26:09 <Heffalump> hmm, but how do I do that blatantly unsafe thing anyway? :-)
12:26:20 <Heffalump> or is there a safer alternative
12:26:48 <Heffalump> I actually just want to use the lens in a view pattern, so I could just write view lensA &&& view lensB or something
12:27:18 <tomejaguar> If you just want to use it as a getter that's much safer.
12:27:23 <Heffalump> ok
12:27:24 <tomejaguar> s/getter/Getter/
12:27:32 <tomejaguar> but I don't know if there's an existing combinator.
12:27:43 <Heffalump> I guess it's a general weakness of lens that they don't have a way to express disjointness and covering.
12:28:54 <tomejaguar> Yes, well a weakness of the Haskell type system, perhaps.
12:29:40 <supki_> :t runGetter ((,) <$> Getter _1 <*> Getter _2)
12:29:41 <lambdabot> Not in scope: `runGetter'
12:29:41 <lambdabot> Not in scope: data constructor `Getter'
12:29:41 <lambdabot> Not in scope: data constructor `Getter'
12:29:44 <supki_> aw
12:30:02 <supki_> anyway, this should work with lens >= 4
12:30:56 <supki_> also Fold/runFold for things that aren't Getters
12:31:21 <Heffalump> I think view lensA &&& view lensB is simpler :-) - is that somehow more general?
12:32:09 <bennofs> Heffalump: you can also do view $ runGetter $ (,) <$> Getter lensA <*> Getter lensB -- at least with lens 4.0
12:32:25 <bennofs> oh, supki already said that
12:32:32 <awestroke> trying to figure out foldl/foldr, why is it so much slower than iteration in this example?: https://gist.github.com/awestroke/cd6075bf94ac0cda2bbf
12:34:30 <milfjord> what, no intercalate?
12:35:30 <int-e> awestroke: join3 looks wrong. In any case, accumulating string by using ++ is bad, and makes the algorithms quadratic.
12:35:37 <milfjord> join2 should be quadratic
12:36:04 <int-e> awestroke: if in join3, you'd replace  ffn p acc = acc ++ ", " ++ p by ffn p acc = p ++ ", " ++ acc, things should look better
12:36:17 <tomejaguar> int-e: join is fine because it's associating to the right
12:37:09 <tomejaguar> supki_, bennofs: What is Getter in 4.0?
12:37:13 <awestroke> int-e: the recursive version uses ++ too but is somehow fine anyway
12:37:23 <milfjord> > let join3 (x:xs) = foldr ffn x xs where ffn p acc = acc ++ ", " ++ p in join3 ["foo", "bar", "baz", "quux"]
12:37:24 <lambdabot>  "foo, quux, baz, bar"
12:37:27 <milfjord> thought so
12:37:46 <milfjord> > let join3 (x:xs) = foldr ffn x xs where ffn p acc = acc ++ ", " ++ p in join3 (map show [1 .. 4])
12:37:47 <lambdabot>  "1, 4, 3, 2"
12:37:55 <int-e> awestroke: there's a huge difference between xs ++ (ys ++ zs) and (xs ++ ys) ++ zs ; the latter traverses the 'xs' portion twice.
12:38:19 <tomejaguar> int-e: Not in a lazy language
12:38:23 <milfjord> tomejaguar: wat
12:38:35 <int-e> tomejaguar: Uhm. Yes. I'm talking about Haskell.
12:38:43 <tomejaguar> int-e: http://h2.jaguarpaw.co.uk/posts/demystifying-dlist/
12:38:51 <milfjord> tomejaguar: WAT
12:38:56 <int-e> tomejaguar: those are plain lists, not dlists
12:39:03 <bennofs> tomejaguar: it's a newtype for Getter, which provides some useful instances
12:39:23 <milfjord> > let join3 xs = foldr (\x z -> x ++ ", " ++ z) "" xs in join3 (map show [1 .. 4])
12:39:24 <lambdabot>  "1, 2, 3, 4, "
12:39:24 <tomejaguar> bennofs: Ah interesting.
12:39:29 <milfjord> faster, but still incorrect
12:39:57 <milfjord> > intercalate ", " (map show [1 .. 4])
12:39:58 <lambdabot>  "1, 2, 3, 4"
12:40:01 <milfjord> laziest solution
12:40:06 <bennofs> tomejaguar: there's also Fold / runFold which provides a list-like monad instance too :)
12:40:42 <tomejaguar> int-e: Right, if you read the article you will see the first part is about lists and it demonstrates that left-associated appends do not cause parts of the list to be walked twice.
12:41:40 <tomejaguar> The quadratic behaviour is in the number of left-associated appends, not in the length of the operands.
12:41:44 <int-e> tomejaguar: Oh you want to get technical. What is traversed are the corresponding strings in the intermediate results. That's a mouthful.
12:43:19 <milfjord> I don't get it
12:43:33 <awestroke> alright, now it looks saner https://gist.github.com/awestroke/cd6075bf94ac0cda2bbf
12:43:40 <milfjord> (xs ++ ys) ++ zs has 2 left-associated appends, hence xs is walked twice
12:43:45 <milfjord> what's wrong with this?
12:43:55 <awestroke> are the result implying that the first join can be tail eliminated?
12:44:05 <int-e> milfjord: it traverses xs, then xs ++ ys.
12:44:14 <tomejaguar> Well, for strict lists I would say that '(xs ++ ys) ++ zs' traverses 'xs' twice.  I personally wouldn't use that terminology to describe what happens to lazy lists.
12:44:21 <int-e> milfjord: and the second one is a new string.
12:44:22 <milfjord> yes, and xs ++ ys incorporates a copy of xs
12:44:23 <tomejaguar> int-e: What do you mean by 'traverses' here?
12:44:25 <milfjord> meh
12:45:13 <int-e> tomejaguar: traverse. walk the list. it looks at every cons cell of the list, taking it apart.
12:45:27 <tomejaguar> What happens is a rebalancing of the tree of thunks from '(xs ++ ys) ++ zs' to 'xs ++ (ys ++ zs)' before any cons cell is forced at all.
12:45:42 <tomejaguar> int-e: OK, well I'm saying that's what is not happening.
12:45:45 <milfjord> tomejaguar: I don't even know what that means
12:46:00 <tomejaguar> Well the article I linked has a nice picture.
12:46:08 <milfjord> doesn't help
12:46:21 <int-e> it's wrong.
12:46:30 <milfjord> but I can clearly see that forcing (xs ++ ys) ++ zs needs to copy the head of xs twice
12:46:30 <tomejaguar> Actually I take that back, the rebalancing doesn't happen with lazy lists.
12:46:42 <tomejaguar> But it doesn't walk evaluate any cons cell of xs more than once.
12:46:44 <int-e> there is *no* pattern matching on ++ things.
12:47:09 <milfjord> tomejaguar: read "xs" as its elements
12:47:13 <milfjord> not the spine itself
12:47:31 <int-e> instead the ++, when forced, evaluates to a cons cell, with (usually) another unevaluated ++ as its tail.
12:47:49 <tomejaguar> When you pattern match '(x:xs ++ ys) ++ zs' you get 'x : ((xs ++ yz) ++ zs)'.  That first cons cell is never walked again.
12:47:58 <awestroke> why can't haskell lazily optimize '(xs ++ ys) ++ zs' to 'xs ++ (ys ++ zs)'?
12:48:08 <milfjord> tomejaguar: so?
12:48:28 <milfjord> tomejaguar: by that point it's too late: we've already processed x twice
12:48:42 <tomejaguar> So by 'xs' is traversed twice, I assumed int-e meant that cons cell would be matched twice.
12:48:46 <int-e> tomejaguar: In any case, "will cause xs to be traversed twice" is a lie to children that works quite well, because it does not require thinking about lazy evaluation too much.
12:49:28 <tomejaguar> If you like to lie to children, then fine.  Personally I think what's actually happening is not too difficult to understand either.
12:50:19 <milfjord> awestroke: what do you mean by "lazily optimize"?
12:50:40 <awestroke> milfjord: it's the same thing in the end, just semantically different
12:50:46 <milfjord> ?
12:50:56 <awestroke> it produces the same result...
12:51:41 <milfjord> please relate "lazily optimize", "produces the same result", and "semantically different"
12:52:04 <jfischoff> I would love to see a detailed explaination of what GHC actually does with ++ including all the rewrite rules in GHC.Base
12:53:58 <awestroke> milfjord: similar to how '(a + b) * (a + b)**2' could be optimized by the compiler to only evaluate '(a + b)' once, '(a ++ b) ++ c' could be automically made to evaluate as 'a ++ (b ++ c)', thanks to referential transparency or whatever
12:54:11 <int-e> > let join3 (x:xs) = x ++ foldr ffn [] xs where ffn p acc = ", " ++ p ++ acc in join3 (map show [1..10])
12:54:12 <lambdabot>  "1, 2, 3, 4, 5, 6, 7, 8, 9, 10"
12:54:22 <awestroke> bad first example I see now, the math makes no sense
12:54:59 <milfjord> ghc doesn't even to CSE
12:55:02 <milfjord> *do
12:55:22 <tomejaguar> awestroke: jfischoff was alluding to some rewrite rules that do the ++ association trick automatically
12:55:27 <tomejaguar> milfjord: Sure it does
12:55:36 <Yaniel> what is the recommended way to install haskell on arch linux?
12:55:46 <`^_^v> very carefully
12:56:05 <tomejaguar> '-fcse  Turn  on  common  sub-expression elimination. Implied by -O'
12:56:19 <tomejaguar> The origin of many a space leak.
12:56:52 <artyomkazak> Yaniel: there's a “ghc” package in extra. Or were you talking about actual haskell packages?
12:57:13 <Yaniel> what about cabal?
12:57:26 <awestroke> is CSE really that hard?
12:57:34 <Yaniel> ah, there is a cabal-install package
12:57:39 <artyomkazak> Yaniel: cabal-install, yep
12:57:40 <Yaniel> so I guess that and ghc?
12:57:50 <tomejaguar> awestroke: No I don't think so.
12:58:40 <artyomkazak> Yaniel: after that you can just use cabal-install to download everything you need, or you can get packages from some repository (which, I don't remember now)
12:58:52 <artyomkazak> just try not to mix the two approaches
12:59:04 <Yaniel> so no ghc package
12:59:11 <awestroke> artyomkazak: why is mixing bad?
12:59:15 <Yaniel> I was told cabal-install is preferred
12:59:20 <Yaniel> because sandboxing etc
12:59:45 <awestroke> Yaniel: only drawback is that cabal compiles the packages => longer install times
12:59:59 <Yaniel> but it does not work nicely with apps installed via the package manager since they depend on the packaged versions
13:00:06 <geekosaur> awestroke, because the package manager can and will install stuff without regard for your local installs
13:00:43 <geekosaur> this won't overwrite anything but *does* stand a good chance of confusing ghc because multiple versions of libraries suddenly exist
13:01:12 <milfjord> tomejaguar: I was remembering http://www.haskell.org/haskellwiki/GHC/FAQ#Subexpression_Elimination
13:01:23 <monochrom> awestroke, see my http://www.vex.net/~trebla/haskell/sicp.xhtml#unsafeInterleave . in fact, see the whole thing
13:01:44 <geekosaur> (also note that this is not specific to haskell, the same general rule "use the library manager or your package manager, don't mix them" also applies to perl, python, ruby, node.js, etc.
13:04:20 <awestroke> monochrom: great thanks
13:05:24 <jle`> i have a pipe that awaits 8 times and yields an aggregate/chunk for every ten inputs
13:05:40 <jle`> how can i define behavior so that if the stream 'stops', it'll clean up somehow?
13:05:52 <jle`> and process the leftoverinformation in a way so it's not lost?
13:10:57 <tomejaguar> milfjord: OK, but it does happen it at least some cases, for example: http://stackoverflow.com/questions/21891096/how-to-prevent-sharing-in-ghc/21891901#21891901
13:11:03 * hackagebot ironforge 0.1.0.7 - A technical demo for Antisplice.  http://hackage.haskell.org/package/ironforge-0.1.0.7 (implementation)
13:11:06 * hackagebot antisplice 0.8.0.1 - An engine for text-based dungeons.  http://hackage.haskell.org/package/antisplice-0.8.0.1 (implementation)
13:11:40 <gamegoblin> For a map with 10 elements, which sort of underlying datastructure do you think is the fastest?
13:11:52 <gamegoblin> hash, tree, or list?
13:12:04 <gamegoblin> 10 keys, that is
13:12:14 <milfjord> that looks like let floating
13:12:26 <dwcook> gamegoblin, speed hardly matters at that small a sample size
13:12:52 <dwcook> I'd say what matters more is a reasonable abstraction
13:13:05 <dwcook> for which I'd say go Data.Map
13:14:29 <Cale> gamegoblin: That's down in the scale where possibly a list is fastest, but as dwcook says, go with whatever makes the most sense in terms of the API. If the intent is to do lookups, use Data.Map.
13:15:04 <gamegoblin> Cale: That was why I asked, I thought the tree overhead might make list faster
13:15:07 <gamegoblin> but meh
13:15:12 <gamegoblin> will profile and optimize later
13:20:02 <augur> doubly-shameless self promotion: http://www.reddit.com/r/haskell/comments/1zgr2h/from_zipper_to_lens_school_of_haskell_shameless/
13:20:03 <augur> =x
13:20:23 <gamegoblin> blind upvote
13:21:55 <monochrom> programming with zippers, lenses, quantum tunneling microscopes, and large hadron colliders
13:22:14 <augur> monochrom: :)
13:26:59 <jle`> ion: no problem!
13:36:44 <kau> Hi guys!
13:37:06 <kau> How can I see the number of light threads my app is running?
13:45:26 <johnw> you can use threadscope
13:46:08 * hackagebot postgresql-libpq 0.9.0.0 - low-level binding to libpq  http://hackage.haskell.org/package/postgresql-libpq-0.9.0.0 (LeonSmith)
14:00:20 <haasn> augur: I eagerly await part 2: from Zipper to lens to ‘zippers’
14:00:35 <augur> haasn: `zippers'?
14:00:59 <haasn> augur: https://github.com/ekmett/zippers
14:01:05 <haasn> wait a minute, is this bitrotting?
14:01:08 <haasn> it was the best thing ever
14:03:13 <augur> haasn: im not even going to touch that one
14:05:23 <augur> hey haasn, was it you that i bugged about Bound the other day?
14:05:52 <haasn> Bound as in edwardk's “bound”?
14:05:52 <kau> <johnw>: thanks
14:05:55 <augur> yeah
14:06:01 <haasn> No, I hardly know anything about that library
14:06:44 <augur> kau: dont use <>s around names when talking to people. usually that's indicative of a log quote instead
14:06:48 <augur> haasn: hm
14:06:53 <kau> ok
14:07:40 <johnw> i feel enclosed
14:08:06 <augur> </johnw>
14:08:20 <johnw> that's how I felt when I took a nap just a bit ago
14:09:00 <augur> ah it was startling
14:09:09 * enemy runs naked after johnw with a screaming chainsaw and talks backwards backhus naur formatted spanish
14:09:39 <augur> what is "BNF formatted spanish"
14:09:42 <augur> this doesnt make any sense
14:10:49 <enemy> augur: i think you meant backwards backhus naur formatted (BBNF) spanish
14:11:03 <augur> yes but what is that supposed to even be
14:11:41 <haasn> (johnw<>)
14:11:50 <enemy> imagen spanish but without the special cases and grammatical oddities, like perfect spanish. but backwards.
14:11:53 <johnw> something which apparently lulls my defenses until I fall victim to his chainsaw
14:13:23 <gamegoblin> Is hackage being slow as hell for anyone else?
14:13:36 <johnw> that makes me wonder exactly how slow hell should be
14:13:46 <artyomkazak> gamegoblin: not for me
14:13:48 <gamegoblin> 5 seconds or so to load a page
14:14:01 <cmears> seems ok to me
14:14:11 <gamegoblin> alrighty, must just be me T_T
14:14:19 <jle`> augur: haha
14:15:09 <augur> enemy: and what makes that "backus naur formatted"
14:15:12 <augur> jle`: what?
14:15:39 <jle`> oh, closing the <johnw> ta
14:15:41 <jle`> g
14:15:47 <jle`> i guess my reaction was a little late
14:17:21 <gamegoblin> if I have a ` pack "some string literal ` in my code, at compile time does that get converted to the bytestring equivalent or whatever?
14:17:53 <shachaf> What is pack?
14:17:59 <gamegoblin> string -> bytestring
14:18:00 <alkabetz> :t ByteString.pack
14:18:00 <tomejaguar> ByteString.pack
14:18:01 <lambdabot> Couldn't find qualified module.
14:18:13 <shachaf> Data.ByteString.Char8? :-(
14:18:21 <alkabetz> Well, yes
14:18:53 <alkabetz> The docs say 'For applications with large numbers of string literals, pack can be a bottleneck.'
14:19:02 <alkabetz> This makes me think that string literals don't get ByteStringified at compile time.
14:19:07 <gamegoblin> mmmm gotcha
14:19:13 <shachaf> The answer is probably no, since the string generated by GHC will be UTF-8, and it'll need to process it.
14:19:29 <gamegoblin> does using overloaded strings avoid this?
14:19:30 <shachaf> But possibly if you don't have any codepoints above 127, or \0, it'll work.
14:19:40 <cpa> one can define fib = 0:1:zipWith (+) fib (tail fib) I want to compute g(n) s.t. g(i) = i if i < 2 and g(i) = g(0) + ... + g(i-1) otherwise. How can I do it with a nice lazy list like fib?
14:19:48 <shachaf> But you shouldn't use Data.ByteString.Char8 in the first place unless you know what you're doing.
14:19:49 <alkabetz> gamegoblin: Almost certainly not, since that's going to get desugared to a bunch of 'pack "foo"'s
14:19:58 <shachaf> Why are you using Data.ByteString.Char8?
14:20:07 <gamegoblin> schachaf: network coding
14:20:25 <gamegoblin> shachaf*
14:20:47 <wereHamster> I built my executable with 'cabal configure --enable-executable-profiling', but when I run it with +RTS -p, it complains that: the flag -p requires the program to be built with -prof
14:20:55 <wereHamster> what else do I need to do so I can profile my exe?
14:21:18 <alkabetz> wereHamster: cabal configure --enable-executable-profiling
14:21:29 <alkabetz> Er, --enable-library-profiling
14:21:42 <wereHamster> I don't want to profile the libraries. Just my executable
14:21:58 <alkabetz> wereHamster: Because of the way GHC inlines stuff, you need to have profiling versions of the libraries too
14:22:00 <awestroke> you need library profiling to do any profiling at all
14:22:23 <wereHamster> alright. But then how do I restrict th eprofile to only show my code?
14:22:55 <wereHamster> also, what is the point of  --enable-executable-profiling if it's not usable on its own?
14:25:44 <wereHamster> 'cabal configure --enable-executable-profiling' doesn't make the executable profileable. Cabal didn't say a word, not even a warning.
14:25:48 <geekosaur> wereHamster, you don't because it's never just your own code
14:26:34 <wereHamster> from what I read, I must also use --enable-library-profiling
14:26:40 <geekosaur> if this bothers you then laziness is not for you
14:27:42 <alkabetz> I dunno, '--enable-executable-profiling' not warning about --enable-library-profiling too seems like kind of a misfeature.
14:27:48 <alkabetz> I wonder if there's a Cabal bug filed about that.
14:36:04 <gamegoblin> What's wrong with this: return (liftM2 (:) (hGetChar h) (readN h (n-1)))
14:36:08 <gamegoblin> readN returns an IO String
14:37:14 <alkabetz> You have an extra 'return'
14:37:21 <alkabetz> :t liftM2
14:37:22 <lambdabot> Monad m => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
14:37:25 <gamegoblin> gotcha
14:37:26 <gamegoblin> thanks
14:37:30 <alkabetz> You're welcome.
14:37:34 <gamegoblin> works now
14:37:56 <aegis__> hey! could someone please tell me what's going on there? https://gist.github.com/a3gis/2080b22ad9dcec35ec33
14:38:17 <alkabetz> aegis__: I think you might be in the wrong channel
14:38:24 <gamegoblin> That's scala...
14:38:27 <gamegoblin> head over to #scala ;D
14:38:53 <aegis__> alkabetz: oops sorry :p too many channels open and not enough sleep
14:39:01 <alkabetz> aegis__: Haha, no worries
14:39:55 <gamegoblin> Any of you guys think of a more elegant way to do this: http://lpaste.net/100663
14:40:16 <gamegoblin> it reads a string of up to length n from a handle
14:40:59 <alkabetz> gamegoblin: Why not just do 'liftM (take n) (hGetContents h)'?
14:41:20 <alkabetz> 'hGetContents' is lazy, so it'll only actually read the amount you want
14:41:30 <gamegoblin> Good point. I am still getting used to thinking lazily
14:41:33 <alkabetz> (Although that might throw an exception if you try to read too much.  I'm not sure.)
14:41:40 <alkabetz> But yeah, I'd use laziness here.
14:42:01 <gamegoblin> if you do take n on something > length n it just takes everything it can
14:42:11 <gamegoblin> > take 3 [1,2,3,4,5,6,7]
14:42:13 <lambdabot>  [1,2,3]
14:42:21 <gamegoblin> > take 3 [1]
14:42:22 <lambdabot>  [1]
14:42:35 <gamegoblin> seems legit
14:42:38 <alkabetz> Whoa, TIL
14:42:43 <alkabetz> That ... is surprising behavior
14:43:58 <Iceland_jack> alkabetz: Why?
14:44:22 <alkabetz> Iceland_jack: It seems inconsistent with 'head'
14:44:30 <alkabetz> > head []
14:44:31 <lambdabot>  *Exception: Prelude.head: empty list
14:44:34 <alkabetz> > take 5 []
14:44:35 <lambdabot>  []
14:44:42 <jxv> maybe there should be a takeMay
14:44:53 <artyomkazak> and takeEx
14:44:58 <Iceland_jack> alkabetz: It's very consistent with drop, it's not really related to head
14:45:06 <Iceland_jack> it's more related to tail if anything
14:45:19 <alkabetz> Iceland_jack: Ah, that actually makes a lot of sense
14:45:39 <jxv> artyomkazak, where is that defined?
14:45:49 <jxv> the Ex suffix
14:46:05 <artyomkazak> Snoyman's classy-prelude
14:46:08 <Iceland_jack> alkabetz: If you use subtraction that is total on the natural numbers, it does make sense :)
14:46:14 <Iceland_jack> where 0 - n is 0
14:46:38 <artyomkazak> jxv: https://groups.google.com/forum/#!msg/haskell-cafe/SzrPAM-xUP0/JFrdifst9JsJ
14:47:13 <jxv> oh, I see. thanks
14:56:50 <haskellnoob> Hello
14:56:54 <Rembane> Good morning
14:56:56 <Iceland_jack> alkabetz: (an example)
14:56:56 <Iceland_jack>     take n xs ++ drop n xs == xs
14:56:56 <Iceland_jack>  
14:56:58 <Iceland_jack> hey haskellnoob
14:57:20 <Iceland_jack> Much nicer than having it fail at run-time :)
14:57:20 <wereHamster> how do I tell cabal to ignore packages in the global pakcage registry? I have a few packages there installed without profiling enabled and I want to ignore them. I have a local sandbox set up where packages should be installed to
14:58:01 <Iceland_jack> Also:
14:58:01 <Iceland_jack>     length (drop n xs) = length xs - n
14:58:01 <Iceland_jack> given my previous definition of -
14:58:14 <haskellnoob> I would like to implement a stale object exception using a version number or timestamp generically: every entity has a field version number and if the version number is less than the latest, the object is stale. What is the best approach to doing this?
15:01:16 * hackagebot foreign-store 0.0 - Store a stable pointer in a foreign context to be retrieved later. Persists through GHCi reloads.  http://hackage.haskell.org/package/foreign-store-0.0 (ChrisDone)
15:03:17 <haskellnoob> hey Iceland_Jack
15:04:12 <haskellnoob> So I am trying to use acid state for my server but I would like to manage disconnected network state throwing some form of StaleObjectException using timestamp or version number.
15:04:28 <haskellnoob> What is the best way to accomplish this in a generic manner?
15:06:53 <khyperia> Can I get a review of if I implemented State Functor/Applicative/Monad right? It typechecks, but I want to see if it's actually correct. https://dl.dropboxusercontent.com/u/18830644/StateThing.hs
15:10:59 <haskellnoob> Any suggestions or librariies that i can use
15:13:24 <cschneid> Is there a good approach to building up data structures as I annotate them with additional work? ie, brute forcing an xor input: readInput => <encrypted input>, decrypt with every key => <encrypted, decrypted, key>, score_attempt => <encrypted,decrypted,key,score> ....
15:13:36 <cschneid> I'd like to avoid having to boilerplate copy attributes from one datatype to another.
15:14:26 <benmachine> khyperia: looks correct
15:14:41 <khyperia> alright, cool, thanks
15:14:55 <benmachine> it IS possible to get wrong, even if it typechecks
15:15:37 <benmachine> e.g. threading the state the wrong way, or backwards
15:15:40 <cmears> cschneid, you could have the members of the structure as "Maybe t"
15:15:59 <cmears> start them all out as Nothing, and fill them in with "Just xyz" as you compute them
15:16:32 <cschneid> cmears: sure, but then I just have a Stuff datatype with a bunch of Maybes. I sorta like the idea of types enforcing that some computation happened (ie, can't score until I attempt to decrypt with a key)
15:17:06 <cschneid> huh, laziness may make that irrelevant. Build up "do this, then that, then this, then get me the top 10{"
15:17:10 <cschneid> nothing happens until that last step
15:18:33 <khyperia> why not just do something like "let a = foo; b = barPossiblyInvolvingA; c = soOnSoForth in Constructor a b c"
15:18:34 <simon> hi khyperia :)
15:18:39 <khyperia> heya simon!
15:20:40 <haskellnoob> Is stale object management in a state a common pattern that has already been solved? What is the best way to approach this?
15:21:13 <haskellnoob> In java world, we add a vernum attribute to each class instance and generate code to handle version management.
15:22:52 <krgn> ah its odd, probably something quite simple, but I'm loading a utf-8 encoded xml and print it (after some transformations) to stdout, and utf8 chars are all mangled
15:24:01 <krgn> apparently, localeEncoding says UTF-8, and there is normally no issue with this, but somehow I'm missing something regarding utf-8 support in ghc
15:24:44 <monochrom> depending on what xml lib you actually use, localeEncoding may or may not be relevant
15:26:10 <krgn> monochrom: its tagsoup
15:26:34 <krgn> and the xml is all utf-8 as well
15:29:16 <krgn> ah so I should be using soemthing like fast-tagsoup-utf8-only ?
15:39:25 <prooftechnique> Anyone know what haddock means by <no location info>: module ‘Cabal-1.19.2:Main’ is defined in multiple files:
15:39:38 <prooftechnique> ?
15:39:48 <prooftechnique> Just mucking about with RC2 and I keep seeing things like this
15:40:48 <geekosaur> I suspect there's a different Main for different platforms with some trickery to make the right one be used; haddock doesnt handle that kind of thing very well, IIRC
15:41:01 <prooftechnique> Hmm
15:42:19 <geekosaur> that, or you somehow have two different builds of the same version of Cabal, but then why does it have a Main module since it's a library. unless it's actually a test program and haddock probably shouldn't even be looking at it... that would be a bug to report, I think
15:42:28 <geekosaur> not really enough information to say
15:43:26 <prooftechnique> It's happened wih a couple of libraries, so I guess it must be a haddock bug. To trac I go!
15:46:16 <haskellnoob> is this the right forum to ask haskell design questions?
15:46:27 <haskellnoob> I am kinda stuck.
15:46:57 <geekosaur> you can ask here but the haskell-cafe list is often better for that kind of thing
15:47:04 <merijn> haskellnoob: Sure, although the r/haskell subreddit or -cafe mailing list may be better for in-depth long answers
15:47:29 <merijn> haskellnoob: So it depends on the size/complexity of the question whether IRC is a suitable format to answer, can't hurt to try, though
15:47:41 <haskellnoob> ok. I want to model stale object exception across my entities stored in either a database or acid state? What is the best abstraction for that.
15:48:56 <merijn> haskellnoob: What do you mean by "stale object"?
15:49:25 <haskellnoob> i have 2 network clients editing the same object or parent..
15:49:34 <haskellnoob> and one of them commits to the db first..which is fine.
15:49:45 <haskellnoob> but I want to send a stale object exception
15:49:52 <haskellnoob> to the other client..
15:50:05 <joelteon> some database engines have subscribe/notify services
15:50:08 <haskellnoob> Using acid helps me serialize the transactions in the server..
15:50:13 <joelteon> acid-state might do that, i'm not 100% sure
15:50:47 <copumpkin> haskellnoob: your drug habits are not relevant to this channel
15:50:54 <haskellnoob> Acid state manages state within the server..but not a version number..i did ask David about it..and his recommendation was to implement this at application level.
15:52:03 <merijn> copumpkin: Treading into Poe's Law territory without smileys there :p
15:52:08 <copumpkin> :)
15:52:13 <haskellnoob> so I am left with a task of implementing this abstraction that will work well and am bouncing betweeen transformers and monads..no luck.
15:52:43 <haskellnoob> copumpkin :)..i had to reread..the acid part to follow you..
15:53:00 <joelteon> how are the clients editing the object, haskellnoob
15:53:04 <joelteon> what is the interface?
15:53:04 <haskellnoob> with monads driving me nuts..the pressure is intense!
15:53:18 <haskellnoob> so I have a test case where 2 client sockets connect to a server socket.
15:53:38 <haskellnoob> client 1 has version number 2 and client has version number 1 and I have an artificial delay.
15:53:58 <Eduard_Munteanu> Suppose 'class Foo a b c | a b -> c', 'instance (c ~ (a + b)) Foo a b c', which requires UndecidableInstances for (+) a type family.
15:54:01 <haskellnoob> The real situation is a group of transactions for a journal.
15:54:31 <haskellnoob> so each update of a transaction updates the journal and updates the version number..so the other clients can be behind.
15:54:36 <haskellnoob> or stale.
15:54:38 <Eduard_Munteanu> Where a, b, c :: N, data N = Z | S Z.
15:55:12 <Eduard_Munteanu> Let data Np = Plus N N.
15:55:30 <haskellnoob> I have a function for each entity planned to do this..perhaps i can model a type but i still have to declare this instance in each entity that seems to be redundant to me.
15:56:14 <Eduard_Munteanu> I can rewrite the class and instance as class Foo' a b (c :: Np) | a b -> c; instance Foo' a b (Plus a b)
15:56:25 <dmj`> haskellnoob: when you are talking about versions are you talking about safecopy instances?
15:56:39 <haskellnoob> ah no..i checked that too..
15:56:47 <Eduard_Munteanu> Is this transformation avoidable, such that I can avoid UndecidableInstances?
15:56:47 <haskellnoob> those versions are for migrations..
15:56:59 <dmj`> haskellnoob: are you using the the acid-state remote module?
15:57:10 <Eduard_Munteanu> (the transformed version doesn't require UndecidableInstances)
15:57:12 <haskellnoob> this is very common in java: it is known as stale object exception in hibernate.
15:57:31 <haskellnoob> I am using an acid server as part of my server,so not using remote module.
15:57:50 <dmj`> haskellnoob: the acidServer function is only exposed in the remote module
15:57:50 <haskellnoob> Will that make a difference: i am not sure if a websocket client can connect to acid -remote.
15:58:36 <dmj`> haskellnoob: what data structure are you trying to modify concurrently?
15:58:53 <haskellnoob> I have about 40 entities..it is an erp application.
15:59:08 <Eduard_Munteanu> I could write it as a type family but in my actual use case the fundeps are more complex and involve constraints on the inputs.
15:59:11 <haskellnoob> I want to add this feature to all of them..
15:59:15 <dmj`> I'm unsure what you mean by entity
15:59:18 <haskellnoob> I started with the user entity
15:59:21 <haskellnoob> data constructor
15:59:39 <haskellnoob> data Login = Login {name : : String, verNum :: Int}
15:59:42 <haskellnoob> for example.
15:59:50 <haskellnoob> this is typeable, generic etc.
16:00:42 <haskellnoob> the model is managed by acid state.
16:02:14 <haskellnoob> dmj: Does it help...describe my usecase?
16:02:35 <dmj`> code might be better, I'm trying to understand what you mean by stale object
16:03:13 <haskellnoob> thats simple in the above example..the client with vernum = 2 is the latest one. If an object with vernum=1 is committed it should fail.
16:03:32 <haskellnoob> let me try to paste the test code..
16:03:40 <dmj`> use lpaste.net
16:04:49 <hexagoxel_> if (instance MonadTrans t) then (instance Monad m => Monad (t m)), correct?
16:05:03 <Eduard_Munteanu> haskellnoob: you could use a global sequence number or the time as version, you just need it monotonic, no?
16:05:50 <Eduard_Munteanu> haskellnoob: morally yes, but in Haskell no
16:05:52 <haskellnoob> but this should be specific to each entity no?
16:06:03 <Eduard_Munteanu> Er.
16:06:09 <Eduard_Munteanu> hexagoxel_: morally yes, but in Haskell no
16:06:20 <Eduard_Munteanu> haskellnoob: it needn't
16:06:44 <hexagoxel_> Eduard_Munteanu: i ask because the laws stated for MonadTrans seem to make that assumption, don't they??
16:06:59 <hexagoxel_> where else does that "return" come from?
16:06:59 <haskellnoob> hmmm....i am not sure I follow..
16:07:14 <dmj`> haskellnoob: Inside your doTransaction :: Int -> State Update Bool function you should do a check to see if the Int being added is already the largest one in the state. If it is add it and return True, else return False.
16:07:35 <dmj`> I think this is what Lemmih meant by doing it at the application level
16:07:44 <dmj`> the ACID nature of acid-state will ensure it's done in order
16:07:56 <Eduard_Munteanu> hexagoxel_: that's why I said "morally", I meant you don't automatically get a Monad instance from a MonadTrans
16:08:00 <haskellnoob> i see..but this will have to be done for each entity.and I guess there is no easy way to avoid it?
16:08:27 <haskellnoob> i meant abstract it..
16:08:52 <hexagoxel_> hmm ok then; shouldn't that be the first law?
16:09:12 <dmj`> It's hard to say w/o seeing your code, typeclasses could be used
16:09:28 <hexagoxel_> otherwise you got "loaded laws", eh?
16:09:29 <haskellnoob> let me paste it in lpaste.net..
16:09:33 <Eduard_Munteanu> hexagoxel_: lift . return = return  is stronger
16:09:43 <haskellnoob> http://lpaste.net/100665
16:10:08 <haskellnoob> this is a simple case..
16:10:13 <Eduard_Munteanu> hexagoxel_: well, assuming MonadTrans already implies Monad
16:11:36 <Eduard_Munteanu> hexagoxel_: IOW, you can construct 'Monad m', 'Monad (t m)' and 'MonadTrans t' such that the first law fails.
16:12:25 <haskellnoob> dmj: I pasted the relevant code here http://lpaste.net/100665
16:12:37 <hexagoxel_> yeah i did not say you should remove the other laws
16:13:24 <hexagoxel_> i only find it .. strange, that you write a law that makes implicit assumptions about instances
16:13:26 <haskellnoob> I see that I could use a bracket abstraction to handle this.?
16:13:44 <Eduard_Munteanu> haskellnoob: you could still keep the sequence number outside your Login and other structures
16:14:28 <haskellnoob> and any update with a sequence number less than the one expected is a stale object?
16:14:45 <Eduard_Munteanu> haskellnoob: yes
16:15:21 <haskellnoob> ok i will trythat..because that lets me develop the model without having to worry abt concurrency issues..etc.
16:15:59 <dmj`> haskellnoob: so if two of the same logins are inserted one of them is a "stale object" ?
16:16:10 <haskellnoob> yes..
16:16:31 <haskellnoob> that is the idea..login is an artificial example for test case.
16:17:15 <dmj`> are you making a website?
16:17:24 <haskellnoob> yes..
16:17:39 <dmj`> are you using a framework?
16:17:54 <haskellnoob> i have started to using websocket servers..and client to test..
16:18:06 <haskellnoob> i plan use either scala fx
16:18:06 <haskellnoob> f
16:18:07 <haskellnoob> or
16:18:30 <haskellnoob> my kid hit the enter..not me :)
16:18:37 <dmj`> :)
16:18:42 <haskellnoob> or seaside to keep the interaction dynamic..
16:19:10 <haskellnoob> seaside is a smalltalk framework that does look quite neat.
16:21:02 <dmj`> so you're using the websocket server from the example code?
16:22:45 <haskellnoob> I took the example code but have not yet modeled the connections. I am only using a barebones socket call to connect to the client and use json to parse.
16:22:53 <haskellnoob> Let me paste my server code real quick.
16:24:43 <haskellnoob> dmj: http://lpaste.net/100666
16:24:51 <Eduard_Munteanu> Hmm... I could use a constraint synonym.
16:25:46 <haskellnoob> I am using simple json parser to parse requests and process the db requests in the server. With the solution that Edward proposed, I can continue to test my model independent of the stale object issue and add the sequence number
16:25:55 <haskellnoob> at the root monad.
16:28:23 <haskellnoob> dmj: This is test code..the mvar is approximate..because runServer in WS doesnt return and I may need to update my code so I can put in the mvar after the server starts listening.
16:28:52 <artyomkazak> is there any commonly used operator for `isPrefixOf`?
16:29:09 <geekosaur> nope
16:29:29 <artyomkazak> not even in other languages?
16:30:33 <geekosaur> not commonly used, no
16:30:51 <geekosaur> if you dig you can probably find something somewhere, but you did ask about commonly used...
16:30:56 <dmj`> haskellnoob: yea, you'll have to initialize the mvar before you call runServer
16:31:26 <dmj`> haskellnoob: so are you going to write your own web server?
16:31:26 <artyomkazak> I'm okay with “commonly used” meaning anything except for “completely arbitrary”
16:31:30 <haskellnoob> dmj: I do that in the test runner...let me paste that..
16:31:40 <haskellnoob> dmj: eventually this should sit in snap or yesod..
16:31:52 <haskellnoob> cant take on that risk :)
16:33:26 <seksifemale> hi
16:33:28 <haskellnoob> updated the lpaste area..with the test driver.
16:33:55 <haskellnoob> dmj: http://lpaste.net/100666
16:34:27 <dmj`> haskellnoob: what I recommend you do is use snap, websockets-snap, snaplet-acid-state and snaplet-acid-auth when you do decide to use a framework. You don't want your acid-state and web server on the same box
16:34:47 <haskellnoob> hmmm..
16:35:21 <dmj`> use the remote module so you can manipulate your state locally
16:35:25 <Eduard_Munteanu> dmj`: why not?
16:35:25 <haskellnoob> that makes sense..
16:36:59 <dmj`> Eduard_Munteanu: if your acid-state has 4GB's worth of data, it will entirely be represented in RAM, unless you use mmap or have another way of loading data partially into memory. This means snap and your websockets connections (in your mvar) are competing for those resources. It's just not scalable imo.
16:37:17 <Eduard_Munteanu> Ah.
16:37:54 <dmj`> Eduard_Munteanu: plus, w/ acid-state remote you can create other apps that use your state. Unless you want all your communication to be done restfully
16:38:05 <haskellnoob> dmj: why not yesod (I have no affinity to any yet) and snap does seem to be a bit approachable.
16:38:52 <Eduard_Munteanu> Snap is the less complex, more approachable one.
16:39:28 <dmj`> haskellnoob: I can't comment on Yesod, all I know is that you shouldn't let the speed benchmarks lure you away from snap, esp w/ the new stuff coming. Also, load-balancers negate the entire speed argument anyway. The bottleneck is always the db, not the web server
16:39:30 <Eduard_Munteanu> Yesod instead uses type-safe routing, fancier templates and so on.
16:40:17 <haskellnoob> I got into haskell through Snoyman's excellent book..but I found that I could not wrap my head around the type system..
16:40:28 <haskellnoob> snap/websockets seem to be the way to go.
16:41:01 <haskellnoob> For my application: this is a sort of desktop application and not an open browser app.
16:41:19 <merijn> haskellnoob: Yesod can be pretty intimidating with all the Template Haskell magic, so don't worry too much about Yesod intimidating you
16:42:24 <haskellnoob> merijin: quite
16:42:41 <simon> haskellnoob, I think snap is a bit easier getting into than yesod.
16:42:46 <dmj`> merijn: acid-state question. The events file, it only contains the current serialized events correct? The checkpoint file is the only file that holds the data right
16:42:54 <haskellnoob> merijin: though I liked the locale messages features: compile time error checking for messages in the app : that was neat.
16:42:59 <merijn> dmj`: Mu
16:43:17 <Eduard_Munteanu> The TH bits on their own aren't that scary, but adding conduits and a bunch of other machinery to that can be. :)
16:43:17 <merijn> dmj`: The event log contains the value of said events, which influence the data
16:43:29 <merijn> dmj`: So, there is no clean split
16:44:07 <merijn> dmj`: Mind you, anything I say is speculation based on my understanding of acid-state's design, I'm not actually familiar with the *actual* implementation :p
16:44:14 <eacameron1> is there any benefit to moving Data.Graph to use Vector instead of Array
16:44:17 <eacameron1> ?
16:44:18 <dmj`> so when a checkpoint is made does the events file get cleaned out and inserted into the checkpoint file
16:45:04 <dmj`> merijn: it's some dense code, doesn't use iteratees either which concerns me..
16:45:24 <dmj`> but it seems to work great so
16:45:40 <merijn> dmj`: When you checkpoint at time X, the checkpoint file is updated (using the events preceding time X) to a new value. Once this is done, you mark "checkpointed at time X" in the log
16:46:14 <haskellnoob> i like the entire acid state interface..it is quite un-obstrusive..very elegant...so it helps me focus on the model.
16:46:17 <merijn> dmj`: The event log can still be concurrently updated while checkpointing, with new events happening after time X, thus not being part of the checkpoint
16:47:45 <merijn> dmj`: Basically, acid-state uses a very well known design for atomicity, similar to journaled filesystems
16:48:56 <merijn> dmj`: Updates are written sequentially to an event log, and the consistency rules are as follows: Everything that's been checkpointed is in "long-term storage", the event log is volatile and occasionally checkpointed, i.e. bulk move of events/updates to long-term storage and marking said events as "saved" in the event log
16:49:02 <haskellnoob> a question about scalability of acid state: will the application scale if we add more memory: 500 GB to the app?
16:49:29 <dmj`> haskellnoob: if you have 500GB+ of RAM yes
16:49:30 <merijn> dmj`: If your application crashes, first reload checkpoint, then replay any events in the log and your up to date
16:49:42 <merijn> dmj`: (only events after the last checkpoint, obviously)
16:49:57 <merijn> dmj`: Events that weren't yet written to the log "didn't happen"
16:50:02 <haskellnoob> dmj: I dont anticipate that requirement but it is always nice to know.
16:50:22 <Taneb> It's quite nice that pipes-parse relies on lens but doesn't depend on it
16:50:25 <merijn> dmj`: But acid-state API functions shouldn't return until the values have been written to the log, so once your update returns, it's safe
16:50:45 <haskellnoob> dmj, Edward and merijn: thank you all for all the pointers: much appreciated.
16:51:25 * monochrom has barely 12GB of RAM
16:51:45 <merijn> haskellnoob: As for your question about scaling. I dislike viewing acid-state as a database replacement, it is not very suited to the same tasks a database is (huge storage, significant parts of data on disk, efficient querying of said data)
16:52:03 <haskellnoob> hmmm.. i see.
16:52:12 <merijn> haskellnoob: You should think of acid-state more as a persistent program state with ACID guarantees
16:52:38 <merijn> haskellnoob: Like any program state, it is entirely in memory, but you won't have to worry about losing it when your code/machine crashes
16:53:08 <haskellnoob> I should also consider implementing a write-behind strategy for database updates?
16:53:08 <merijn> Now you can use this to fake a database (by essentially serialising a Map), but I don't think that's one of it's strong points
16:53:16 <Eduard_Munteanu> Besides, doesn't it serialize things rather inefficiently?
16:53:31 <merijn> Eduard_Munteanu: Well, define inefficiently?
16:53:39 <merijn> Eduard_Munteanu: It's not a densely packed table, no
16:53:40 <Eduard_Munteanu> merijn: read/show-like
16:53:52 <merijn> Eduard_Munteanu: It just use safecopy which uses binary, afaik
16:53:55 <dmj`> marijn: do you have any preference to using IxSet over Data.Map
16:53:57 <Eduard_Munteanu> Ah.
16:54:30 <merijn> Eduard_Munteanu: So it's as efficient as you can reasonably expect of a portable binary representation. Not comparable to say an SQL table, but that's mostly due to the structural difference
16:54:51 <merijn> Eduard_Munteanu: Because it's not really designed to serialise tables, but arbitrary values
16:55:11 <merijn> dmj`: I think IxSet is fine, as long as you have realistic expectations
16:56:01 <merijn> dmj`: Not sure how it's implemented, but I would expect similar to Data.Map, with nicer acid-state integration. So basically if the idea of using Map is ridiculoous, then so is using acid-state. If using a huge Map for your application is reasonable, then so is acid-state
16:56:02 <haskellnoob> merijn: so how do people use acid state and a database together?
16:56:50 <merijn> haskellnoob: The same way people use networking and pretty printing together? (i.e. those two are mostly orthogonal :))
16:57:43 <haskellnoob> merijn: so it implies i need to duplicate the data constructors and implement the table structures as well as the version numbers etc?
16:58:00 <merijn> haskellnoob: The two don't integrate because they're mostly unrelated. If you want to use a database you'd use one of the postgres/sqlite/whatever libraries
16:58:31 <merijn> haskellnoob: I don't understand that question?
16:58:59 <dmj`> haskellnoob: you don't have to redefefine the data constructors just make it an instance of FromRow
16:59:16 <dmj`> the beauty of typeclasses
16:59:25 <dmj`> merijn: I found this pkg
16:59:26 <dmj`> https://github.com/mightybyte/compact-ixset
16:59:37 <merijn> dmj`: That seems to assume a specific database library :p
17:00:22 <merijn> (the FromRow instance, I meant)
17:00:44 <dmj`> merijn: yea, the postgres one :)
17:01:08 <haskellnoob> dmj: great..that would work.
17:01:18 <merijn> See also: http://howfuckedismydatabase.com/
17:01:26 <dmj`> haskellnoob: I plan on doing that to save on space w/ acid-state
17:02:50 <haskellnoob> dmj: Nice. I will need to plan for that migration too. Initial prototype with acid is probably ok for my immediate needs.
17:03:08 <dmj`> MS Access hahaha
17:03:20 <haskellnoob> dmj`: this has been great: at least I have a good roadmap of what i need to do.
17:03:42 <dmj`> haskellnoob: if you plan for mass scalability, then go with postgres and use amazon RDS
17:03:47 <dmj`> they just added postgres support
17:03:49 <haskellnoob> merijn: the version number is an earlier discussion: about stale object exceptions.
17:04:37 <merijn> haskellnoob: Like I said, as long as "a huge Map" seems reasonable for your application (or prototype), you'll be fine
17:05:10 <haskellnoob> merijn: i dont expect a huge map for my version -1.0..
17:05:36 <haskellnoob> merijn: so i should be fine..and it is so nice to not have to look at the database :)
17:05:55 <merijn> haskellnoob: Realistically, I wouldn't worry until you hit things like 500k-1million entries
17:06:03 <haskellnoob> dmj`: do you plan to implement any write behind strategies for rdbms integration?
17:06:29 <merijn> (well, depending how much RAM you have, obviously)
17:07:05 <haskellnoob> merijn: that would be a mid-sized company...and i am looking at 2 - 10 users..so I dont expect to hit than number soon..:)
17:07:49 <dmj`> haskellnoob: just make a function, fromAcidToPostgres, pull out of one, dump into the other
17:08:24 <haskellnoob> dmj` this would work reliably because acid state guarantees state?
17:10:11 <dagano> noob question : i know that algebraic structures (for example) can be homomorphic (or other types of morphic) meaning roughly that you can set up some flavor of correspondence between the objects and the operation that combines the objects...what about functions? can i talk about functions having the same 'structure' if they behave the same way?
17:10:26 <dmj`> no, but just query the data, attempt to insert into postgres, if successful delete from acid-state, o/w keep it in acid-state, no data lost
17:10:59 <haskellnoob> dmj`: hmm..so that could be a function that would need a bit more care to manage..
17:11:15 <haskellnoob> dmj`: i meant fromACIDToProgres.
17:11:37 <heatsink> dagano: Many of the interesting cases involve data structures that contain functions
17:11:37 <gamegoblin> :t timeout
17:11:38 <lambdabot> Not in scope: `timeout'
17:11:43 <haskellnoob> dmj`: it is still manageable..for sure.
17:11:43 <gamegoblin> :t System.Timeout.timeout
17:11:44 <lambdabot> Int -> IO a -> IO (Maybe a)
17:13:10 <haskellnoob> thank you and good night. I will try to get a permanent handle the next time I sign up.
17:13:56 <dmj`> haskellnoob: night
17:14:47 <mirpa> Is threadscope package on Hackage dead?
17:16:33 <merijn> dagano: I'm about to go sleep, but if you are curious about things like "when are functions equal", you may want to look up the terms "intensional equality" and "extensional equality"
17:16:43 <merijn> dagano: It's a well-known hard problem in math/CS
17:17:09 <heatsink> It's also undecidable
17:17:26 <merijn> heatsink: Depends on your language :)
17:17:53 <merijn> In total language it's decidable, but most likely still computationallly intractable :p
17:18:17 <merijn> Actually
17:18:27 <gamegoblin> In homotopy type theory equality is equivalence
17:18:27 <merijn> I guess not if you have infinite datatypes
17:19:01 <gamegoblin> Univalence axiom and whatnot
17:19:08 <Eduard_Munteanu> dagano: a function homomorphism in that sense would be a map relating one function to another, but since any function can be described as a set of pairs it would just be another function
17:19:44 <merijn> dagano: At any rate, not it's not a silly question to wonder about "structure" or "equality", etc. of functions, but it's a complex area about which a lot has been written and I can't cover it in the 5 minutes before I should go sleep :)
17:20:32 <dagano> merijn: i'm aware of intensional vs extensional equality...thanks i'll look into it
17:21:00 <dagano> i actually have a specific example in mind .. and i'm trying to characterize it for myself
17:21:19 <pordan30> is that true? coq is total, but equivalence of functions isn't decidable; so forall (f : A -> B) (g : A -> B) . eq f g \/ neq f g isn't provable in general, if i recall correctly (my syntax may be off).
17:22:09 <Eduard_Munteanu> pordan30: yes
17:23:36 <Eduard_Munteanu> pordan30: it's not related to totality though
17:34:51 <gamegoblin> waaaa freaking hlint bugs
17:42:05 <Sgeo> GHC 7.4.1 is panicking on me :(
17:42:38 <jfischoff> when building or in ghci
17:42:55 <Sgeo> When trying to cabal install cabal
17:43:22 <jfischoff> what's the error?
17:44:03 <Sgeo> http://sprunge.us/EfeH
17:55:17 <vkbsh> Yet another monad question: why can't we just make our functions be of the form f :: (input_type, state_type) -> (output_type, state_type). Doesn't this keep track of state without the use of monads?
17:55:41 <echaozh> hi. when i install ghc 7.8.1 rc2, there're a lot of packages complaining that the array/binary/and other system libs are too new. can i install those packages without unpacking them and updating their cabal files?
17:55:51 <johnw> vkbsh: sure you can
17:56:01 <johnw> vkbsh: but that won't generalize to everything that can be a Monad
17:56:20 <vkbsh> Is it just more idiomatic Haskell to use monads to keep track of states?
17:56:23 <johnw> for example, with Maybe a, what is state_type?
17:56:43 <vkbsh> A boolean to keep track of whether it's Nothing or Just
17:56:50 <johnw> fwiw, State actually is: input_type -> state_type -> (output_type, state_type)
17:57:26 <geekosaur> echaozh, with a recent enough (not yet released, IIRC?) cabal-install there is an option to treat upper bounds as advisory
17:57:37 <jle`> vkbsh: that's actually (almost) literally what State is
17:57:41 <jle`> State is a newtype wrapper
17:58:00 <jle`> it's a thin containers over functions of type s -> (ao s)
17:58:20 <johnw> vkbsh: how you could implement a Monad is different from the abstraction which monads respresent.  If you abstracted the commonality for every "manual" monad definition that you might make, you'd notice a pattern, and that pattern would be Monad
17:58:30 <jle`> so yuor version would be i -> (s -> (o,s))
17:58:31 <ParahSailin> @src State
17:58:31 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
17:58:49 <jle`> vkbsh: however, consider how you would compose two such functions?
17:59:03 <monochrom> then "f(x, s0) = let { (y, s1) = g(x, s0); (z, s2) = h(x, s0) } in (z, s1)" is allowed, but see that it is nonsense: s0 is re-used, s2 is forgotten
17:59:04 <jle`> vkbsh: how would you 'combone' two s -> (o,s)'s ?  how would you 'sequence' them?
17:59:51 <jle`> vkbsh: you would probably implement some kind of "andThen" fucntion, andThen :: (s -> (o,s)) -> (s -> (o,s)) -> (s -> (o,s))
18:00:01 <jle`> a function that takes two stateful functions and sequence them and performs then one afte another
18:00:03 <monochrom> Clean uses uniqueness type on state_type to forbid this, therefore all is well again.
18:00:17 <jle`> using the output state of the first funtion as the input state of the first one
18:00:42 <jle`> how would you sequence two state functions with the 'resul't of the first one affecting teh next?
18:00:53 <vkbsh> Hmmm.
18:01:12 <jle`> you might have a function andThenWith :: (s -> (o,s)) -> (o -> (s -> (o2,s)) -> (s -> (o2,s))
18:01:30 <vkbsh> I was thinking basically having the state type being a list of previous states.
18:01:41 <jle`> where the second parameter is a function of the result of the first parameter, yielding a different s -> (o2, s) dependign on what the result of the first was
18:01:55 <monochrom> a list of all historial states is only worse
18:02:11 <jle`> this is probably the most meaningful way to sequence and compose s -> (o,s) 's
18:03:05 <jle`> and if you throw in a function like return :: i -> (s -> (i,s)), which yields an s -> (o,s) that does not affect the state but just returns that value you gave in
18:03:17 <jle`> then you have a pretty powerful toolset
18:03:26 <monochrom> just imagine what "f(x, list) = (x+1, take 2 list)" could possibly mean
18:03:27 <jle`> for combining, manipulating, sequencing, composing
18:03:34 <jle`> functions of the type s -> (o,s)
18:05:09 <jle`> but if you try implementing these sequencing/etc function combinators yourself
18:05:18 <jle`> you'll find that they follow certain laws
18:05:51 <vkbsh> So in practice, most of the heavy lifting will be done in the implementation of bind I'm guessing
18:06:00 <jle`> well, that's eaxctly what bind is
18:06:03 <jle`> bind is andThenWith
18:06:12 <jle`> you don't *have* to call it bind
18:06:15 <jle`> you can call it whatever you want
18:06:24 <jle`> you don't have to call `andThen` (>>)
18:06:28 <jle`> you don't have to call return return...
18:06:33 <jle`> but...
18:06:42 <jle`> these are exactly the tools you would want to use to work with s -> (o,s)'s
18:07:00 <jle`> and calling them, in your head, bind, return etc.
18:07:06 <jle`> well
18:07:11 <jle`> most practically, it lets you use do notation :P
18:07:33 <jle`> and all of our monad combinators
18:07:42 <jle`> but more powerfully it allows you to reason with them the same way you would reason about any other monad
18:08:15 <jle`> so you can go ahead and always manually use s -> (o,s)'s if it suits you
18:08:20 <jle`> but you're going to be writing a lot of boilerplate code
18:08:31 <jle`> that andThenWith/(>>=) will abstract away for you
18:09:24 <jle`> just like you can manually case x of Just x -> ...; Nothing -> ... a hundred lines deep :)  or you can juse use (>>=) for Maybe
18:12:11 <vkbsh> Ok. So suppose I want a function where if I apply it 100 times, it becomes Nothing.
18:12:31 <vkbsh> How do I use Monads to keep track how how many times the function has iterated?
18:13:13 <vkbsh> Do I need to construct a new type for this?
18:15:02 <Earnestly> Tentative… STMonad?
18:15:06 <Cale> vkbsh: I'm not sure what you mean by that
18:15:22 * Earnestly thinks "state", but knows nothing
18:15:26 <Cale> vkbsh: Functions are entirely determined by which result they produce for which input
18:15:26 <pordan30> a simple solution. you can track the number of times the function has been executed using something like the state monad; the function can guard against the state value, and when the state exceeds 100, return Nothing rather than another value.
18:16:00 <Cale> vkbsh: Could you give some examples at least of what you want your function to produce for some inputs?
18:17:09 <Cale> You could have something like f Nothing = Nothing; f (Just 0) = Nothing; f (Just n) = Just (n-1)
18:18:10 <Cale> and then applying f 100 times to Just 99 should get you Nothing
18:18:35 <vkbsh> f is any function: say f x = x + 1. If I compose f fewer than 100 times, I get a normal result: x + (num iterations). Else, I get nothing.
18:18:46 <jle`> I probably should not have mentioned Maybe
18:18:56 <Cale> > let f Nothing = Nothing; f (Just 0) = Nothing; f (Just n) = Just (n-1) in iterate f (Just 99)
18:18:57 <lambdabot>  [Just 99,Just 98,Just 97,Just 96,Just 95,Just 94,Just 93,Just 92,Just 91,Jus...
18:19:03 <xnull> jle`: maybe not
18:19:11 <jle`> the monad instance for Maybe has almost nothing to do with the monad instance for State
18:19:13 <jle`> heh
18:19:25 <Cale> vkbsh: That's untrue
18:19:33 <jle`> me?
18:20:03 <Cale> vkbsh: If f x = x + 1, then no matter how many times you apply f to an Integer value, you'll get another Integer. The type can't change.
18:20:24 <vkbsh> Ok, say change it to zero.
18:20:33 <vkbsh> If composed more than 100 times.
18:20:39 <jle`> also remember you have to keep in mind referential transparency
18:20:52 <Cale> vkbsh: Well, if you were to start with -100
18:21:00 <Cale> then you'd end up at 0 after 100 iterations
18:21:07 <Cale> but it would obviously continue from there
18:21:28 <Cale> Functions are honest mathematical functions in Haskell
18:21:54 <johnw> Cale: ssshh,, he'll find out about the functions that call unsafePerformIO...
18:22:04 <Cale> If a function gives a particular result when applied to a particular value, it will *always* produce that result
18:22:09 <jle`> referential transparency here would mean that if you replaced a function call of f with the return value, it should be indistinguishable
18:22:17 <vkbsh> What I mean is, what's the Haskell equivalent of an imperative function that executes normally if a global counter is < 100, else, it does nothing.
18:22:30 <Cale> If f 7 = 15, then every time you apply f to 7 you will get 15
18:22:35 <Clint> :t when
18:22:35 <lambdabot> Monad m => Bool -> m () -> m ()
18:22:41 <vkbsh> and at each function execution, it iterates the global counter.
18:22:50 <Cale> vkbsh: Ah, not a function
18:23:08 <Cale> vkbsh: You can have IO actions which keep track of a counter, using for instance an IORef.
18:23:22 <jle`> it would be an action
18:23:53 <jle`> you can not involve IO if you want it to only enforce a local limit
18:24:22 <Cale> hm?
18:25:10 <vkbsh> Hm, okay. Given me enough food for thought. Thanks to those who answered my questions.
18:26:02 <jle`> he could use State and have a limiter :: n -> (a -> b) -> (a -> State n (Maybe b))
18:26:59 <jle`> that increments the state when called and returns Just or Nothing if the state exceeds the limit parameter
18:27:14 <jle`> but the whole problem is kind of contrived in the first place
18:28:50 <Cale> vkbsh: I'm confused about what you want this for, so it's hard to suggest what you should do.
18:29:11 <Cale> vkbsh: If you have a particular program that you're trying to write, perhaps I can help suggest how you can structure it better.
18:29:31 <jle`> from the context it's probably just a gadenken experiment
18:29:51 <dolio> Yes. The correct answer to this question is that you never want a function that does something the first 99 times and does nothing the 100th time based on a global counter. :)
18:30:16 <jle`> gedanken
18:30:33 <jle`> I am not ein Berliner apparently
18:31:00 <vkbsh> Yeah, it's a contrived problem. Just trying to get intuition on how to do things.
18:31:42 * hackagebot adb 0.1.0.0 - Android Debug Bridge (ADB) protocol  http://hackage.haskell.org/package/adb-0.1.0.0 (StephenBlackheath)
18:33:19 <Cale> vkbsh: It might be worth noting that if you have some imperative program, you can convert it into an initially terrible functional program by turning each line (point at which the program counter can be) into a function, and each mutable variable in scope into a function parameter. You then have these functions apply each other according to the control flow, with appropriately updated parameters according to the effect
18:33:19 <Cale>  of the given line.
18:33:52 <gamegoblin> Not super haskelly, but I am coding Haskell right now and this is perfect coding music: https://www.youtube.com/watch?v=wU78FQl_HGg just thought I'd share
18:34:11 <Cale> This produces a terrible result, but usually once you have that, you can start doing algebraic simplification. I've done this on occasion in order to understand what some poorly-written C program would do.
18:34:15 <xnull> gamegoblin: let me know if you find some haskelly music
18:34:45 <gamegoblin> xnull: this channels Haskell to me: http://vimeo.com/5003279
18:35:06 <gamegoblin> Some nice tripglitch
18:36:04 <Cale> Usually after about a dozen or so refactorings, you get everything down to one function again, and it actually makes sense what's being computed at that point :)
18:37:40 <Algebr> All, I can't understand how `y = y + 1` can even compile. Its utter nonsense...right??
18:38:10 <geekosaur> it's not nonsense but it is bottom
18:38:24 <geekosaur> that is, if you demand the value of y it will recurse on itself
18:38:45 <Algebr> Then why isn't there a stackoverflow?
18:38:49 <dolio> It's not necessarily bottom, depending on the type.
18:39:00 <Algebr> What exactly is bottom?.
18:39:04 <geekosaur> I think it is because it can't produce a value
18:39:07 <verement> > let y = y + 1 in y
18:39:11 <lambdabot>  mueval-core: Time limit exceeded
18:39:13 <geekosaur> if it were 1 + y then a lazy type might have a chance
18:39:23 <geekosaur> but in any case, stacks dont work that way in Haskell
18:39:37 <Cale> Algebr: Recursive definitions give you the least-defined value which is consistent with the definition. In that case, _|_ + 1 is _|_, and so _|_ (nontermination) is what you get.
18:39:41 <geekosaur> there is a pattern match stack, but not the kind of call stack you're used to
18:39:45 <verement> > let y = y + 1 in length [y]
18:39:46 <lambdabot>  1
18:40:00 <geekosaur> verement: you never ask for the value of y there
18:40:05 <verement> nope
18:40:12 <geekosaur> only the structure of the list, which is well defined
18:40:15 <verement> yep
18:40:29 <Cale> Algebr: ah, bottom is a value in each type which represents a nonterminating computation of that type
18:40:34 <dolio> Whether 1 + y or y + 1 would work depends on the definition of +.
18:40:56 <geekosaur> mm, I guess that's so
18:41:10 <Cale> If we assume that the instance of Num being used is Integer, then (+) is strict in both arguments, and the result is bottom.
18:41:57 <geekosaur> if it's a lazy number of some kind and (+) examines its second parameter before its first, it could produce an infinite stream that something else could limit
18:42:20 <monochrom> you can certainly write a haskell compiler that statically catches certain bad programs
18:42:29 <Cale> Algebr: There's a partial ordering on the values of every type, where roughly speaking, the idea is that x <= y whenever some occurrences of _|_ in x can be replaced with other values to obtain y.
18:43:16 <Cale> Algebr: _|_ is then the least element of that partial order, which is usually pictured at the bottom of the page, with other elements lying above it
18:43:20 <Algebr> So why doesn't bottom throw an exception, doesn't seem to be a way to get out of bottom once you hit it?
18:43:45 <geekosaur> some forms of bottom can't be detected
18:43:57 <geekosaur> but, in some cases you will get a special exception called <<loop>>
18:44:09 <Cale> Algebr: Well, bottom is used to represent all forms of "not producing a value" including bombing out with an exception and just failing to ever finish
18:44:11 <geekosaur> indicating that a thunk was reentered while being evaluated
18:44:19 <rgrinberg> is there a way to tell runhaskell to use a cabal package?
18:45:04 <Cale> As an example of the partial ordering I was talking about, if we think about [Bool], then we have _|_ as the least element, and then just above that, we have [] and _|_ : _|_
18:45:32 <Cale> and then above _|_ : _|_ we have True : _|_ and False : _|_ and _|_ : [] as well as _|_ : (_|_ : _|_)
18:47:41 <Cale> Note that [] and _|_ : _|_ are incomparable in the ordering
18:47:51 <Cale> As are True : _|_ and False : _|_
18:48:50 <Cale> Now, not only is this a partial order, but it's "directed complete": if you have any sequence of elements which are becoming more defined  x1 <= x2 <= x3 <= ...
18:50:11 <Cale> Then there is a supremum for these elements, that is, there is some x such that each xn <= x, and whenever y is some other value for which each xn <= y, then we have x <= y.
18:50:27 <Cale> This is how we get infinite lists, we have:
18:50:55 <Cale> _|_ <= (1 : _|_) <= (1 : 2 : _|_) <= (1 : 2 : 3 : _|_) <= ...
18:51:58 <Cale> and this sequence (once we say what its elements are properly) will have a least upper bound, which in this case will be the list of positive integers
18:52:02 <Cale> > [1..]
18:52:03 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
18:53:24 <Cale> Sometimes it can be natural to think of an operational semantics for the language where each value starts out at _|_, and as it gets evaluated, the definitions in the program are used to move steadily upward in the partial order
18:54:35 <Cale> Some programs will fail to make progress and will leave the value _|_, but in any case, every computable function is order-preserving.
18:55:15 <Cale> (You need a Turing oracle to write a function which doesn't preserve this ordering)
18:56:24 <Cale> Algebr: I don't know how much of that makes sense, but feel free to ask questions :)
18:57:55 <Cale> Algebr: In any case, _|_ (which is ASCII art for an upside-down T symbol) is part of our mathematical understanding of Haskell programs, rather than a specific implementation detail (it actually corresponds to several things at the implementation level)
18:58:07 <zcd> is there a way to reuse the same let in two cases of a function?
18:58:28 <Cale> zcd: If those cases are guards, you can use a where clause
18:58:55 <Cale> (where scopes over multiple guards)
18:58:56 <verement> ⊥
18:59:04 <Cale> ^^ yes, that symbol :)
18:59:18 <zcd> okay thanks
19:00:25 <Cale> zcd: If you're matching against different patterns, then it's a little trickier. Options include using let with a case inside it instead, or just lifting the definitions out to the top level, or defining a helper function locally.
19:01:53 <Cale> (In general, the same code won't necessarily make sense, because it'll have access to different variables matched from the arguments)
19:02:42 <gamegoblin> can ghc compile case..of statements to multiway branches?
19:02:51 <gamegoblin> for certain types
19:03:13 <gamegoblin> or is it strictly linear
19:04:55 <Cale> It may, but I don't know whether it actually does.
19:05:38 <c_wraith> I'm pretty sure it uses a branch table when the number of constructors is large
19:05:41 <Cale> Note that the first thing that GHC will do with case expressions is to compile them into simpler case expressions which match against one constructor at a time
19:07:49 <Cale> Well, by that I mean, eliminating nested pattern matches -- there will still be in general as many branches as you have constructors in the given type
19:10:00 <Cale> Also, I know that for types with few constructors it does pointer tagging, so it can inspect the low-order bits of the pointer to the evaluated value it gets back rather than dereferencing it to look at which constructor it was.
19:10:56 <Cale> Your best bet is probably to -ddump-asm and see whether you can figure out what's going on :)
19:40:34 <Platz> is there any way to share a function between piece-wise function definitions, but also scoped to and only visible to those functions?  `where` clauses only apply to a single piece, and yet guards don't seem to allow one to deconstruct data
19:42:19 <Platz> i guess the most resonable option is to just create a helper function both definitions can use
19:42:41 <jle`> Platz: the way i've been doing it is to pull the entire branching into a case
19:43:15 <jle`> instead of f (Just x) True (y:ys) = ...; f Nothing True [] = ...
19:43:24 <jle`> f m t y = case (m, t, y) of ...
19:43:29 <jle`> where
19:43:34 <jle`> probably not the cleanest way though
19:44:04 <Platz> jle`: that's good though, didn't think of that.
19:44:33 <jle`> yeah, you can use guards for the cases too so you don't lose any power
19:44:43 <jle`> actually i wonder if ghc desguars functions like that into case statements
19:45:59 <Platz> LYAH seems to think so
19:46:44 <Earnestly> jle`: Yes
19:47:09 <jle`> Earnestly: thanks, was just about to check a core dump heh
19:47:16 <Earnestly> Do so anyway
19:47:25 <Earnestly> But afaik, core only has case
19:47:57 <c_wraith> Err.  I'm getting some special errors.
19:50:41 <c_wraith> http://lpaste.net/100670
19:51:08 <c_wraith> Oh, I think I see.  It doesn't realize type-level (+) is injective
19:51:28 <copumpkin> it's injective?
19:51:38 <c_wraith> well.  It isn't.  But type-level (+1) is injective.
19:51:42 <copumpkin> ah :)
19:52:31 <c_wraith> Is there no way at all to make that type-check?
19:52:52 <carter> c_wraith: the nats solver is dumber than you'd like
19:53:00 <carter> it cant do any abstract reasoning
19:53:10 <c_wraith> I can't see a way to annotate the types such that I can add the (n1 ~ n2) constraint
19:53:17 <carter> well
19:53:18 <carter> dont'
19:53:19 <carter> it wont work
19:53:23 <carter> use your own Nats type
19:53:33 <carter> the typelits one is useless aside from consuming pretty syntax
19:53:51 <carter> all it can do is check that 1+1=2
19:53:56 <carter> can't do anythign abstract
19:53:58 <carter> so don't bothr
19:54:11 <c_wraith> I don't need it to do anything other than believe me.
19:54:16 <c_wraith> I just can't tell it to believe me
19:54:21 <carter> unsafecoerce
19:54:48 <c_wraith> Well.  I suppose that's one way to tell it to believe me.
19:54:59 <c_wraith> I was hoping for something less forceful. :)
19:55:04 <carter> use your own nats type
19:55:09 <carter> and you can prove stuff
19:55:15 <carter> lemme paste an example
19:55:40 <c_wraith> I don't care about having my own type
19:55:43 <alpounet> It's like putting a gun in GHC's mouth, but here you don't have much of a choice for now if you just "need it to believe you" and that nothing at all can go wrong
19:55:54 <c_wraith> Without pretty syntax, it's kind of useless.
19:55:55 <carter> c_wraith: you either can prove stuff
19:55:59 <carter> or use unsafecoerce
19:56:06 <pavonia> So from (n1 + 1) ~ (n2 + 1) it can't deduce n1 ~ n2?
19:56:11 <c_wraith> pavonia: correct
19:56:19 <carter> it can donothingg
19:56:34 <c_wraith> pavonia: regular type constructors are injective.  Type families, which (+) is, are not
19:56:59 <carter> https://gist.github.com/cartazio/9340008
19:57:13 <carter> i can prove    go :: SNat n1 -> Shape n1  a-> Shape n2 a -> Shape (n1 + n2) a
19:57:19 <carter> with my own types
19:57:27 <carter> with some help from richard eisenberge
19:57:54 <pavonia> c_wraith: Ah, I didn't know it's a type familiy, I thought it would be some built-in magic
19:57:54 <pordan30> aren't injective type families coming to ghc soon? i recall a preliminary implementation posted on the mailing list some time ago...
19:58:07 <carter> pavonia: they exist
19:58:09 <carter> data families
19:58:11 <c_wraith> pordan30: technically, addition isn't injective either. :)
19:58:15 <carter> that too
19:59:17 <pavonia> Can you introduce a data family Succ for Nat kinds?
19:59:29 <jle`> whoa in this core dump all values used in main were computed at compile time
19:59:35 <c_wraith> pavonia: actually, I suspect GHC.TypeLits might have that already
19:59:39 <jle`> or maybe this is what inlining is
20:00:06 <carter> pavonia: look at mine
20:00:21 <c_wraith> Guess it doesn't have that already.
20:00:48 <carter> nope
20:01:04 <carter> it'd be usable if it could be mapped to Peano to induct on
20:01:06 <carter> bu tnooooo
20:01:37 <jle`> oh yeah, added a noinline and it no longer did it
20:01:40 <jle`> that's weird
20:01:53 <pavonia> carter: Where do Z and S come from?
20:02:39 <enthropy> pavonia: line 15 of the nat.hs
20:03:48 <pavonia> Oh, only read the upper part :S
20:06:54 * hackagebot LogicGrowsOnTrees 1.1.0.1 - a parallel implementation of logic programming using distributed tree exploration  http://hackage.haskell.org/package/LogicGrowsOnTrees-1.1.0.1 (GregoryCrosswhite)
20:07:26 <jle`> cute library name
20:07:45 <kloplop321> How can I dependably get the static share directory for a library? For example, I try to use `getAppUserDataDirectory "pandoc"`, but that just results in `~/.pandoc`, where as in the pandoc source, it seems to resolve to `~/Library/Haskell/ghc-7.6.3/lib/pandoc-1.12.0.2/share/data/templates`
20:08:03 <kloplop321> Well, without templates appended on it
20:11:54 * hackagebot LogicGrowsOnTrees-network 1.0.0.2 - an adapter for LogicGrowsOnTrees that uses multiple processes running in a network  http://hackage.haskell.org/package/LogicGrowsOnTrees-network-1.0.0.2 (GregoryCrosswhite)
20:14:58 <jrmithdobbs> haskell's formatting rules make me so angry with ruby
20:15:18 <jrmithdobbs> why can't i move the comma to the next line damn it
20:15:29 <jrmithdobbs> ;p
20:15:59 <jle`> foisted again by boolean blindness
20:27:30 <pordan30> a question about injectivity: if type families aren't injective, but data families are, is it possible to use data families to infer the correct type in this case? <http://lpaste.net/100671> this is from an old SO question
20:28:42 <pordan30> (i.e., to infer the correct instance)
20:32:26 <alpounet> pordan30: maybe with *closed* type families, which are (new) in 7.8
20:33:02 <alpounet> but not sure you'd be happy with closed type families
20:37:06 <pordan30> alpounet: thanks - i'm not running 7.8, so i'll give it a try
20:39:02 <alpounet> pordan30: the paper about it: http://www.cis.upenn.edu/~eir/papers/2014/axioms/axioms-extended.pdf - there also is a GHC commentary page about it IIRC
20:41:51 <zcd> is there a concise way of sayin map (==0) $ map (7 `mod`) [1..5]
20:42:05 <zcd> i think it has something to do with flip?
20:43:22 <alpounet> map ( (==0) . mod 7 ) [1..5] ?
20:43:41 <alpounet> also I'd write map (\x -> 7 `mod` x == 0) [1..5] i think
20:45:00 <zcd> thanks
20:45:28 <Hafydd> Shorter: map (==1) [1..5]
20:48:36 <m3ga> :t map
20:48:38 <lambdabot> (a -> b) -> [a] -> [b]
20:49:35 <shachaf> If you ever find yourself resorting to flip it might be better not to not to make your code point-free in the first place.
20:51:43 <maxiepoo> you're no fun shachaf
20:52:09 <zcd> what's point free?
20:52:13 <zcd> the period?
20:52:22 <maxiepoo> usually the only time I flip is when I'm using runReader or something else that takes its arguments "backwards" of what would compose nicer
20:52:47 <shachaf> "point-free" means avoiding using named arguments (e.g. (\x -> ...))
20:52:48 <nexx> iirc is a point an argument in math speak
20:53:14 <shachaf> maxiepoo: I prefer even (`runReader` x) to (flip runReader x).
20:53:22 <zcd> oh like an inner product <.,.> is a map etc etc.
20:53:36 <maxiepoo> interesting choice
20:54:22 <maxiepoo> but then you need the parens
20:54:40 <Clint> and it's uglier
20:58:13 <johnw> nexx: functions can be said to "map points in the domain to points in the range".  So the argument represents some "point" in the domain
21:03:04 <carter> pavonia: also that example code is part of some serious software i'm wrigng
21:03:55 <carter> alpounet: pordan30  you can do some clever stuff to get injectivity out of the constraint solver for the right type families
21:08:57 <mrmonday> is there a version of lines which gives indices as well as splitting up the line?
21:11:13 <pavonia> mrmonday: Indices of the line number?
21:12:37 <mrmonday> yeah
21:13:06 <pavonia> > zip [1..] . lines $ "foo\nbar\n\nbaz"
21:13:08 <lambdabot>  [(1,"foo"),(2,"bar"),(3,""),(4,"baz")]
21:13:16 <mrmonday> ah, of course!
21:13:18 <mrmonday> thank you
21:52:31 <akurilin2> Quick question: do you guys happen to know if there are docs for what can be passed into sqltype= when defining entities with Persistent? Trying to figure out what word it's expecting in there to understand I'm using a 4 byte postgres integer.
21:52:37 <akurilin2> since "integer" doesn't seem to work
21:53:59 <TallerGhostWalt> My Traversable instance of Either seems to have disappeared...
21:54:00 <akurilin2> There's this page, but it's all fixmes: https://github.com/yesodweb/yesod/wiki/Persistent-entity-syntax
21:55:15 <TallerGhostWalt> should I use the base-compat to bring it back?  Was there some reason it was taken away?
21:55:37 <TallerGhostWalt> Tried to google but didn't see much
22:14:57 <prooftechnique> Anyone else using RC2 on OSX having haddock issues? I'm trying to devise a minimal example for a bug report and your input could be helpful
22:16:24 <Fuuzetsu> Is there a way to have a project-local cabal config file? I'd like to use --disable-shared and --disable-documentation for few projects at some cases and I'm getting pretty sick from passing those in manually
22:17:35 <prooftechnique> Fuuzetsu: Well, I suppose a sandbox works. You can override the relevant flags in the cabal-sandbox-config
22:17:55 <Fuuzetsu> Ah, I'll look into that considering I pretty much always sandbox
22:18:42 <prooftechnique> Fuuzetsu: I mainly use it to null out symlink-bindir and the like to avoid weird PATH interactions :D
22:19:51 * Fuuzetsu is going to be trying out NixOS in few hours
22:19:55 <Fuuzetsu> maybe I can escape cabal
22:20:12 <Fuuzetsu> maybe I'll finally have sane environments!
22:20:46 <prooftechnique> Fuuzetsu: I've been doing the same. I'm building a NixOS VM so I can eventually move to it as my main OS. I really like the portability of nix files
22:24:02 <Fuuzetsu> Well, I tried asking a few questions in #nixos but they fell to death ears… I like Gentoo's USE flags so I'd like that kind of functionality and I don't want KDE, ALSA or any other cruft that the distro comes with.
22:26:52 <prooftechnique> Fuuzetsu: I started with the minimal ISO and built a quick little i3 based system. No KDE or anything. I'll get my stuff on github tomorrow if you'd like a look
22:27:12 <Fuuzetsu> I see, that's effectively the conclusion I came to as well.
22:27:32 <Fuuzetsu> although I'm surprised that you went for i3 instead of XMonad, seeing this is #haskell and all
22:27:44 <prooftechnique> Haha, that's fair.
22:28:21 <prooftechnique> I considered Xmonad, i3 just require less immediate effort. I should move to Xmonad, though, if only for the programming experience
22:28:44 <prooftechnique> I used XMonad on OS X for ages, so it shouldn't be too bad
22:29:43 <Platz> i3 is great, the hierarchical container model isn't in any other wm I'm aware of
22:31:07 <Platz> other tiling wm's were frustrating because you had to choose a predefined layout for windows
22:35:39 <gamegoblin> if I do ` str <- try (some parser that will fail) `
22:35:47 <gamegoblin> is str == "" or what?
22:36:44 <c_wraith> gamegoblin: the whole thing will fail.  str will never have a value if the parser failes
22:36:46 <c_wraith> *fails
22:37:36 <gamegoblin> gotcha
22:37:44 <prooftechnique> c_wraith: Not a Left (something) in a (atto)parsec parser?
22:38:33 <c_wraith> prooftechnique: nope.  No value is ever bound to the name str.  There might be a left involved, but it's behind the scenes if there is.
22:38:44 <prooftechnique> Ah, fair
22:50:38 <synonymous> Is there a way to have a data constructor which would only take something which has been fully applied? E.g. something like
22:50:39 <synonymous> > data T a = T a
22:50:39 <synonymous> such that you cannot construct
22:50:39 <synonymous> > foo = T id
22:50:39 <synonymous> but you can construct
22:50:39 <synonymous> > bar = T [1,2,3]
22:50:40 <lambdabot>  <hint>:1:5: parse error on input `='
22:50:40 <lambdabot>  <hint>:1:1: parse error on input `data'
22:50:41 <lambdabot>  can't find file: L.hs
22:53:13 <pavonia> Maybe you could restrict it to a type class that lacks a function instance
22:54:09 <roboguy_> synonymous: how do you know when something is fully applied?
22:54:27 <synonymous> pavonina, yes that's one way to go. I was wondering if there was another way to do it or the reason for why it can't be done
22:55:04 <levi> Platz: I haven't investigated deeply, but there are a *lot* of different ways you can configure xmonad to tile.
22:55:57 <levi> I have xmonad running on my xsessions for the thin clients I have running. Works really well.
22:56:01 <roboguy_> can something that conceptually gives you a function be "fully applied" even though the result is a function? It seems like a strange thing to distinguish between function types and non-function types
22:56:46 <Platz> levi: ah, thats encouraging.  xmonad would be very appealing for it's programmability
22:57:13 <ski> synonymous : usually, the fact that functions are values too is considered a feature :)
22:57:37 <synonymous> roboguy_ not sure, the fact that both (Int :: *) and (a -> a :: *) have the same kind makes me think you can't know. However, I can't come up with an example when you wouldn't know
22:57:58 <synonymous> ski, :D
22:57:59 <ski> synonymous : and, as roboguy_ says, should `id not' be considered "fully applied" ?
22:59:01 <pordan30> this might not be what you're looking for, but you can use strictness declarations to force evaluation (to weak-head normal form) when a data structure is created. also seq.
22:59:11 <synonymous> well, `id not` reduces to `not' which is a function
22:59:49 <roboguy_> synonymous: but id :: a -> a is applied to a value and it gave you a value, just like it's type signature says. does that not make it "fully applied"?
23:01:11 <Platz> levi: i3 containers http://www.youtube.com/watch?v=Wx0eNaGzAZU&feature=youtu.be&t=1m32s
23:02:50 <roboguy_> synonymous: what's the use case for this?
23:04:55 <synonymous> roboguy_: an EDSL for scalar expressions where functions and scalars are separate. I didn't want to restrict the types that could be used as scalars so long as they are scalars, and not functions
23:05:09 <roboguy_> synonymous: hmm, have you looked into gadts?
23:05:57 <synonymous> yes..so far I have:
23:05:57 <synonymous> data Exp a where
23:05:57 <synonymous>   ConstE :: a -> Exp a
23:05:57 <synonymous>   FunE   :: Impl a -> Exp a
23:05:57 <synonymous>   AppE   :: Exp (a -> b) -> Exp a -> Exp b
23:06:41 <levi> Platz: I have things set up somewhat like that, but with some switchable auto-layouts rather than h/v splitting. My keys for swapping and moving focus are similar.
23:09:51 <Platz> levi: Yeah, sounds productive enough.
23:12:57 <roboguy_> synonymous: You want to restrict ConstE so that it doesn't work on function types? I think you could do that with void and closed type families, if you're willing to install the ghc 7.8 release candidate
23:14:30 <roboguy_> well, maybe. hmm
23:16:43 <levi> Platz: Although xmonad is decent out of the box, it's really not so much a window manager as a window manager construction kit with a *lot* of bits you can swap in and out.
23:17:01 <levi> Platz: Check out all the modules in xmonad-contrib
23:18:54 <Platz> levi: there sure is a lot there
23:19:27 <synonymous> roboguy_: Yes, ConstE shouldn't be able to take functions. I have ghc head somewhere, what are these void type families you mentioned?
23:19:28 <Platz> Will have to investigate
23:19:48 <roboguy_> synonymous: there is a relatively stable release candidate for ghc 7.8, which is probably a bit safer than head
23:19:58 <roboguy_> also void and type families are two separate things
23:20:05 <synonymous> ah
23:20:07 <roboguy_> Void is an uninhabited data type: data Void
23:20:15 <roboguy_> (no data constructors)
23:20:29 <roboguy_> type families are essentially type level functions
23:20:57 <roboguy_> and closed type families pretty much let us pattern match on types in the type functions similarly to how normal functions can pattern match on values
23:21:08 <Fuuzetsu> regular reminder that ⊥ ruins it all
23:21:21 <roboguy_> Fuuzetsu: well, that's truee
23:21:30 <roboguy_> synonymous: here's the latest ghc 7.8 release candidate http://www.well-typed.com/blog/87
23:23:59 <roboguy_> synonymous: here's what I had in mind http://lpaste.net/100675
23:24:01 <synonymous> roboguy_: Thanks! Is void also called Empty Data Declarations?
23:24:27 <roboguy_> synonymous: well, you need empty data declarations to define the type. I'd just use the void package though. it comes with a couple useful functions
23:24:36 <roboguy_> (just in case you might need them at some point)
23:25:23 <roboguy_> that code has a type family that should map any type to Void (no values can have this type, so that should be okay) and every other type to itself
23:25:29 <roboguy_> *map any function type to Void
23:31:03 <synonymous> roboguy_: I think that's exactly what I need, thank you :)
23:31:42 <roboguy_> no problem! that might have actually been my first closed type family, so it was good practice for me too
23:32:19 <synonymous> :D
23:32:57 <roboguy_> well, I need to get to bed
23:32:59 <roboguy_> good night!
23:33:47 <synonymous> good night!
23:33:57 <synonymous> thanks again
23:40:31 <johtso> How would I write a type signature like this? prop_pathStatus :: NonEmptyList xs => (xs :: [Square]) -> Bool
23:40:45 <johtso> specifically a type constraint on a list
23:41:15 <johtso> do I need to make a type synonym?
23:41:21 <shachaf> Are you talking about a specific NonEmptyList class (or type), or are you just using this to express your intent?
23:42:14 <shachaf> You can use a particular type for NonEmptyList, like the one in http://hackage.haskell.org/package/semigroups-0.12.2/docs/Data-List-NonEmpty.html
23:42:27 <shachaf> Then you'd have foo :: NonEmpty Square -> Bool
23:43:06 <shachaf> Oh, I guess this is quickcheck. Quickcheck also lets you specify constraints dynamically, and inputs that don't match the constraint will be discarded, which is probably good enough for this case.
23:45:15 <johtso> I think I'm using quickcheck modifiers wrong..
23:52:25 <johtso> shachaf, how would I make the input list non empty? http://lpaste.net/9022662786274033664
23:54:00 <jrmithdobbs> johtso: um prop_pathStatus [] = False
23:54:18 <jrmithdobbs> johtso: must be before the other definition
23:54:33 <johtso> oh, just using patterns
23:54:53 <johtso> I thought I was supposed to use the NonEmptyList Modifier
23:55:15 <jrmithdobbs> oh prop_ ... quickcheck?
23:56:28 <jrmithdobbs> don't you do that in the constraint def or w/e quickcheck calls it?
23:57:19 * hackagebot yaml-config 0.2.2 - Configuration management  http://hackage.haskell.org/package/yaml-config-0.2.2 (FedorGogolev)
