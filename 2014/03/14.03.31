00:00:03 <fragamus> yes i fixed that
00:00:10 <fragamus> but still problems
00:02:03 <awestroke> is there a "seq" that evaluates to nf rather than whnf?
00:02:27 <Cale> awestroke: rnf / deepseq
00:02:53 <Cale> http://hackage.haskell.org/package/deepseq
00:08:23 <tfng> p
00:08:58 * hackagebot propellor 0.1.2 - property-based host configuration management in haskell  http://hackage.haskell.org/package/propellor-0.1.2 (JoeyHess)
00:08:58 * hackagebot HTTP 4000.2.12 - A library for client-side HTTP  http://hackage.haskell.org/package/HTTP-4000.2.12 (GaneshSittampalam)
00:13:38 <eatman> Hello
00:14:23 <cwvh> fragamus: your function works for me when I change e^2.0 to e**2.0 and '*' to the second atanh/tan calls.
00:14:49 <fragamus> thanks
00:18:53 * hackagebot mime-mail 0.4.4.2 - Compose MIME email messages.  http://hackage.haskell.org/package/mime-mail-0.4.4.2 (MichaelSnoyman)
00:18:55 * hackagebot hastache 0.6.0 - Haskell implementation of Mustache templates  http://hackage.haskell.org/package/hastache-0.6.0 (DaniilFrumin)
00:19:21 <athan> does deriving Typeable with the 7 or less type parameters corralate to the 7 Trees = 1 Tree dealio with Algebras of Algebraic Data Types?
00:20:57 <Cale> no
00:22:09 <Cale> athan: That's just where whoever wrote Typeable got bored
00:22:21 <athan> oh hahaha
00:22:26 <Cale> http://www.haskell.org/ghc/docs/latest/html/libraries/base/Data-Typeable.html#t:Typeable7
00:22:51 <Cale> This will be cleaned up in 7.8 from what I understand
00:23:03 <Cale> because Typeable is becoming poly-kinded
00:24:18 <hunt> fastest function to convert a float 4.0 to 4
00:24:19 <hunt> ?
00:25:20 <Cale> hunt: Well, depends on what you want 4.1 to be sent to
00:25:31 <Cale> (and 3.9)
00:25:46 <hunt> Cale: i dont follow?
00:26:01 <Cale> There are many different functions which send 4.0 to 4
00:26:10 <Cale> Which behave differently on other values
00:26:25 <hunt> i want an integral and can guarentee the number will have trailing 0s
00:26:33 <Cale> > round 4.0
00:26:34 <hunt> so whatever happens to 3.9 etc doesnt matter
00:26:35 <lambdabot>  4
00:26:37 <hunt> as long as its fast
00:26:39 <hunt> is that the fastest?
00:26:40 <Cale> > truncate 4.0
00:26:41 <lambdabot>  4
00:26:48 <Cale> > floor 4.0
00:26:50 <lambdabot>  4
00:26:56 <Cale> > ceiling 4.0
00:26:58 <lambdabot>  4
00:27:04 <Cale> They're all pretty fast
00:27:24 <Cale> I haven't ever bothered to compare them
00:27:29 <hunt> actually maybe i dont need to convert
00:29:56 <hunt> how is it that Integral is considered a member of Ord but Fractional is not?
00:30:07 <hunt> why isnt the typechecker asking me to call Integral Ord?
00:31:25 <Cale> What's the actual message you're getting?
00:32:14 <athan> what is "equational reasoning", and how can it be utilized with haskell in particular?
00:32:44 <athan> hmm
00:32:51 <Cale> athan: It's just the sort of reasoning you do in algebra class, making substitution of equals for equals in order to prove things
00:33:13 <Cale> (typically, more equations)
00:33:19 <athan> hmm, okay
00:33:56 <Cale> and the reason it works in Haskell is that the results of functions don't depend on anything other than their parameters, and generally, the same expression will always evaluate the same way
00:38:36 <athan> data T (m :: k -> *) a = MkT (m a)
00:39:06 <athan> MkT (Maybe (Maybe (Maybe Int)))
00:39:11 <athan> > data T (m :: k -> *) a = MkT (m a)
00:39:13 <lambdabot>  <hint>:1:1: parse error on input `data'
00:39:38 <athan> @help
00:39:38 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
00:39:46 <athan> @list
00:39:46 <lambdabot> What module?  Try @listmodules for some ideas.
00:39:51 <athan> @listmodules
00:39:51 <lambdabot> activity base bf check compose dice dict djinn dummy elite eval filter free fresh haddock help hoogle instances irc karma localtime more oeis offlineRC pl pointful poll pretty quote search slap source spell system tell ticker todo topic type undo unlambda unmtl version where
00:40:50 <Kaidelong> athan: strictly speaking you can do equational reasoning with any programming language, the thing about haskell that's special for it is the syntax and the fact that things that aren't actually functions are clearly marked
00:41:22 <athan> Kaidelong: Ahh, okay. Thanks!
00:43:07 <jle`> implicit state is so silly
00:43:39 <athan> @instances (->)
00:43:39 <lambdabot> Couldn't find class `(->)'. Try @instances-importing
00:43:44 <athan> ahh
00:43:51 <athan> @instances Profunctor
00:43:52 <lambdabot> Couldn't find class `Profunctor'. Try @instances-importing
00:44:06 <athan> @instances-importing Profunctor
00:44:06 <lambdabot> Couldn't find class `Profunctor'. Try @instances-importing
00:44:15 <athan> @instances-importing Control.Lens.Profunctor
00:44:16 <lambdabot> Couldn't find class `Control.Lens.Profunctor'. Try @instances-importing
00:44:22 <athan> i give
00:46:00 <awestroke> athan: try @let data [...]
00:46:15 <athan> @let data T (m :: k -> *) a = MkT (m a)
00:46:15 <lambdabot>  Parse failed: Parse error: k
00:46:15 <jle`> athan: you can :i in ghci
00:46:37 <athan> it uses kind polymorphism
00:46:45 <athan> can I load language extensions?
00:46:49 <awestroke> nope
00:46:54 <athan> > -XPolyKinds
00:46:55 <lambdabot>  Not in scope: data constructor `XPolyKinds'
00:46:58 <athan> :(
00:47:08 <athan> that's kindof a bummer
00:47:24 <athan> any reason why?
00:47:52 <bezirg> hi, can I have a local method defined in a where clause that is shared between the methods of an instance?
00:48:19 <shachaf> No.
00:48:43 <ion> bezirg: That would be convenient, but no such thing exists at the moment.
00:48:52 <bezirg> shachaf: so do u think i should copy the where clause over each instance method?
00:49:08 <ion> Or define it outside the instance definition.
00:49:27 <jle`> for now the best way is just to define it non-locally
00:49:31 <bezirg> ion: is it a grammar problem? bcs I thought the where clause was kind of powerful and could be put everywhere
00:50:02 <bezirg> jle`: the thing is that I am generating code from another language and I am worried that it will escape its scope
00:50:09 <bezirg> generating Haskell code*
00:50:12 <shachaf> They forget the power declaration in the grammar. "power where 8"
00:50:12 <jle`> there's already another where in instance declaration syntax so that might be awkward
00:50:44 <ion> bezirg: A where clause is always attached to a single definition, not multiple that happen to be nearby each other.
00:50:50 <jle`> but where in functions is declaration syntax, so you can only have a where per definition
00:50:53 <jle`> er
00:50:55 <jle`> per declaration
00:51:09 <bezirg> ion, shachaf, jle`: I understand
00:51:26 <bezirg> I will generate a where clause and copy it over for each instance method
00:51:41 <bezirg> the code will be bloated, but I don't think I will have a performance issue, right?
00:51:44 <jle`> if it is generated then that is probably on the border of ok
00:52:02 <jle`> it is definitely not a good idea for actual hand written source code
00:52:09 <bezirg> jle`: y
00:52:13 <bezirg> jle`: yes
00:52:21 <jle`> i suspected you were aware
00:52:56 <bezirg> thanks ppl
00:52:58 <jle`> i wouldn't think there would be a performance cost...if anything it might be like a manual inlining.  but i do not know enough to say for sure
00:53:17 <bezirg> jle`: y, think so too
00:54:39 <shachaf> "the code will be bloated" is a performance issue itself, of course.
00:55:16 <hunt> is it ok to use Data.IORef
00:55:25 <hunt> im using it for a dipslay callback in opengl
00:55:26 <bezirg> shachaf: :D
00:55:41 <hunt> and i store the vertices in the ioref
00:55:46 <hunt> anything about that sound bad to anyone?
00:56:06 <maroloccio> zerokarmaleft: i am not sure what you mean with "bridges nicely"..
00:56:39 <hunt> are IORefs set lazily?
00:57:59 <Cale> hunt: Executing  writeIORef r e  won't force the evaluation of e
00:58:23 <hunt> this is gonna sound crazy
00:58:29 <hunt> but doesnt writeIORef just sound really nice
00:58:31 <hunt> like the word
00:58:33 <hunt> it sounds crunchy
00:58:35 <hunt> and good
00:58:36 <jle`> hunt: i think for the OpenGL haskell library
00:58:39 <jle`> the only way to use it
00:58:41 <jle`> is with IORefs
00:58:47 <jle`> all of the examples use them i believe
00:59:08 <tdammers> they are set eagerly, but if the value you're setting them to isn't evaluated yet, setting the IORef won't evaluate it either
00:59:13 <hunt> jle` im talking about for my own stuff, not the opengl states
00:59:23 <Cale> woody word, not like that tinny runST
00:59:31 <hunt> tdammers Cale: exactly what i wanted to hear, thanks
00:59:45 <hunt> Cale: that is perfectly described, holy shit
00:59:54 <hunt> Cale: where did you discover the use of tinny and woody
00:59:55 <jle`> hunt: yeah, it's the only way to transfer any sort of state between frames, i think
00:59:57 <erisco> thank monty python
01:00:09 <hunt> jle` is it implemented in haskell or with IO magic
01:00:14 <Cale> https://www.youtube.com/watch?v=-gwXJsWHupg
01:00:20 <jle`> writeIORef?
01:00:23 <jle`> IORefs?
01:00:26 <hunt> IORefs
01:00:29 <edwardk> athan: Data.Profunctor not Control.Lens.Profunctor -- profunctors are more general
01:00:32 <jle`> IORefs are completely well-behaved
01:00:42 <jle`> in the context of what IO in haskell is
01:00:58 <jle`> they are under the same equational reasoning you can do with any other library IO action
01:01:09 <jle`> that was awkwardly phrased
01:01:55 <jle`> it isn't any more magic than getChar, it is a perfectly well-behaved IO action in haskell and it makes a lot of sense if you consider what IO is in haskell
01:02:25 <jle`> also, it is pure :)
01:02:36 <hunt> jle` yea sure im not questioning whether its out of scheme with other IO actions, but it is an IO action
01:02:37 <jle`> in the same sense that other standard library io actions are pure
01:02:55 <athan> edwardk: Thanks haha
01:03:00 <hunt> jle`:  how does it do what it does, also is it any different from State?
01:03:02 <tdammers> hunt: yes, it is an IO action - that is kind of the point
01:03:28 <tdammers> hunt: State is just some sugar, really, for implicitly passing some state around using a Monad
01:03:54 <athan> @instances Data.Profunctor
01:03:55 <lambdabot> Couldn't find class `Data.Profunctor'. Try @instances-importing
01:04:04 <athan> @instances-importing Data.Profunctor
01:04:04 <lambdabot> Couldn't find class `Data.Profunctor'. Try @instances-importing
01:04:08 <tdammers> hunt: under the hood, it carries state around as a function argument / return value
01:04:12 <athan> lol
01:04:12 <hunt> tdammers: so the bind of state just passes the state value accross functions?
01:04:20 <hunt> athan: why are you awake still
01:04:22 <tdammers> hunt: yes.
01:04:29 <athan> hunt: Why not?
01:04:45 <hunt> athan: idk i figured you dissapeared after you stopped talkinga  while ago
01:05:09 <athan> hunt: No, I'm just flushing the open tabs I've stocked up haha
01:05:26 <awestroke> how can contramap reverse a pure function?
01:05:34 <hunt> could you believe that there are some people who dont have > 10 tabs at a time
01:06:25 <athan> hahaha
01:07:25 <athan> holy crap
01:07:32 <athan> so haskell is a semiring?
01:07:34 <athan> er
01:07:42 <athan> seminearring?
01:07:50 <athan> jesus
01:08:18 <johnw> haskell types have the algebraic structure of a seminearring
01:08:23 <johnw> ADTs
01:08:29 <johnw> hence the "A" in ADT
01:10:03 <athan> holy petunias
01:10:06 <jle`> hunt: f :: s -> (a,s); g :: s -> (b, s)
01:10:09 <athan> that is incredible
01:10:16 <athan> where + and *
01:10:21 <athan> in
01:10:32 <athan> (S; +; *; 0)
01:10:42 <athan> are Sum and Product types
01:10:43 <athan> ?
01:10:56 <athan> and 0 being ()?
01:11:05 <athan> er
01:11:06 <jle`> hunt: f >> g :: s -> (b,s);   f >> g = \s -> let (_,s') = f s in g s'
01:11:07 <athan> Void
01:11:10 <hunt> jle` im sorry im way too tired to try and understand any of these letters
01:11:12 <athan> being the monoid
01:11:16 <jle`> hunt: no worries
01:11:16 <athan> er
01:11:30 <athan> (S; +; Void)
01:11:53 <hunt> how do you set an ioref
01:11:56 <hunt> does $= do that
01:12:10 <athan> i think that's from conduit
01:12:27 <athan> iorefs are for concurrency i think
01:12:29 <athan> like
01:12:36 <athan> @hoogle ioref
01:12:36 <lambdabot> Data.IORef module Data.IORef
01:12:37 <lambdabot> Data.IORef data IORef a
01:12:37 <lambdabot> package IORefCAS
01:12:42 <jle`> hunt: $= is an operator from OpenGL
01:12:51 <jle`> it's a typeclassy-magicky- kinda operator
01:12:57 <bartavelle> (it's also in conduits)
01:13:11 <hunt> jle` i used it on an ioref and it worked though
01:13:15 <athan> jle` must.... learn....
01:13:16 <jle`> yeah, it's also in conduits
01:13:19 <jle`> but he is using OpenGL
01:13:22 <bartavelle> ok !
01:13:27 <jle`> hunt: yeah, it works on a "settleable" typeclass
01:13:31 <jle`> which includes IORefs
01:13:34 <jle`> and also OpenGL configuration
01:13:36 <jle`> stuff
01:13:41 <hunt> jle` oh ok, how do i set iorefs without $=?
01:13:42 <jle`> yeah the library has a lot of weird design choices
01:13:47 <jle`> hunt: writeIORef
01:13:55 <hunt> kk thanks
01:13:55 <tdammers> hunt: have you read the IORef documentation?
01:14:04 <hunt> no but i guess i could
01:14:07 <athan> jle`: Have you toyed with GLFW?
01:14:09 <hunt> this is the only bit i was uncertain about
01:14:15 <tdammers> hunt: I guess you should :)
01:14:23 <hunt> ughhhhh fine
01:14:30 <athan> haaa
01:14:35 <tdammers> reading documentation is a good habit in general
01:14:37 <jle`> it's pretty succinct
01:14:41 <athan> I was like you about 3 months ago, hunt
01:14:50 <jle`> tdammers: http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-IORef.html
01:14:50 <hunt> whats that mean
01:14:53 <hunt> athan
01:15:00 <athan> nothing bad
01:15:07 <hunt> but likek what does it mean
01:15:09 <athan> if anything, you're getting on the cusp
01:15:12 <jle`> fight fight fight
01:15:17 <athan> hahaha
01:15:22 * jle` incites violence
01:15:23 <hunt> yea bitch i dont like the tone of this
01:15:31 * hunt gets out machete
01:15:31 <athan> hahaha
01:15:46 <jle`> hunt: yeah, the opengl lib is kinda weird in its design choices
01:15:51 <jle`> and also the documentation is pretty hard to follow
01:16:00 <jle`> it's good to have the index open to ctrl+f
01:16:08 <hunt> jle` for me thats alright because im pretty much writing my own graphics library
01:16:12 <bitemyapp> hunt: reading the docs is a particularly good idea with Haskell because unlike many communities there *is* documentation.
01:16:22 <jle`> hunt: http://hackage.haskell.org/package/OpenGL-2.9.1.0/docs/doc-index-All.html
01:16:36 <jle`> notice that a lot of the operators don't even have documentation or type signature annotations. gr!
01:16:40 <jle`> you have to dig through the source code
01:16:41 <hunt> jle` its rendering to an array of pixels, which are drawn as vertices with depth 0
01:16:43 <jle`> :)
01:16:58 <hunt> jle` is anyone improing that
01:17:18 <jle`> well at least the index tells you what source code file to look at :)
01:17:18 <otulp> Any ideas on how to create efficient Binary instances for large arrays of foreign data (e.g. Ptr CFloat), for network transport? I have been aliasing them to strict bytestrings with Data.ByteString.Internal.fromForeignPtr, but something somewhere goes wrong at sizes >= 2GiB, even though the platform is 64b. It seems that the problem does not lie with bytestring, so I'm guessing there is some 32b int indexing limitation somewhere in the ...
01:17:20 <jle`> i'm not sure.
01:17:24 <otulp> ... networking libs.
01:17:42 <jle`> hunt: there was a reddit post on rendering pixel arrays about a month or two ago, not sure if you caught it
01:18:02 <hunt> jle` no i didnt, thats really interesting. have a link?
01:18:32 <jle`> hunt: http://www.reddit.com/r/haskell/comments/1xjhcf/a_seriously_pixelated_game/
01:19:03 <athan> I heard of this one... juicy pixels?
01:19:06 <hunt> jle` damn ive already got it set up with opengl
01:19:20 <athan> nevermind
01:19:21 <jle`> hunt: here is $= btw, http://hackage.haskell.org/package/OpenGL-2.9.1.0/docs/Graphics-Rendering-OpenGL-GL-StateVar.html#v:-36--61- ; so IORefs, StateVars, and SettableStateVars (the latter two being internal OpenGL data types)
01:19:41 <bartavelle> otulp, that might not be too helpful, but have you tried writing it to a file, to rule out a networking library problem ?
01:20:03 <bartavelle> (also this is some serious data transfer)
01:20:31 <jle`> hunt: hm it looks like the article is asking about 'giant' pixels
01:20:36 <otulp> bartavelle: Nope. I have tried simply creating some large bytestrings, though, and prodding them a bit.
01:20:37 <jle`> so it might not be the best fit for yours
01:20:49 <hunt> oh alright
01:20:54 <hunt> jesus ive never been this tired
01:21:03 <hunt> im tired everywhere
01:21:04 <otulp> bartavelle: .. in ghci, that is
01:21:16 <bartavelle> ah
01:22:55 <jle`> hunt: actually it looks like the opengl docs aren't as bad as i remember for some reason
01:23:00 <jle`> i must have exagerated it in memory
01:23:28 <jle`> haskell is designed to be unwritable when tired. you normally can't even get the types to check :)
01:23:38 <jle`> it's like a 'go to sleep now' feature
01:24:16 <Cale> Haskell is much more writable when tired than untyped languages
01:24:27 <Cale> because the compiler tells you where all your stupid mistakes are
01:24:28 <tdammers> yeah
01:24:57 <tdammers> I found that programming in Haskell requires an exceptionally low amount of working memory (in the programmer's brain, that is)
01:25:58 <tdammers> I can usually get away with just making the bloody change, bluntly, right there and then, and then the compiler tells me what the impact is and where I need to fix stuff
01:26:13 <jle`> yeah, haskell is great for that and that's the best part about it
01:26:34 <jle`> but at a certain hour, it's like ghc enforces you to go to sleep if you can't even manage enough mental energy to get anything to typecheck
01:26:43 <jle`> it's like it spots sloppy code and shuts you down
01:26:48 <jle`> Cale: that is a good point. for me i usually just take it as a sign to sleep when i find out i have a high amount of stupid mistakes (This message has been postponed on 2014-03-31 01:24:12.)
01:27:59 <dv-> emacs' flymake is really nice for fixing things
01:29:46 <hunt> whats the difference for floor and truncate
01:30:34 <jle`> hunt: http://hackage.haskell.org/package/base-4.6.0.1/docs/Prelude.html :)
01:30:46 <gnomnain> hi
01:30:54 <jle`> the difference is in the behavior for negative numbers
01:31:12 <hunt> jle` do they ever have different results
01:31:14 <jle`> hi gnomnain
01:31:19 <jle`> hunt: yes
01:31:32 <jle`> > truncate (-1.2)
01:31:33 <lambdabot>  -1
01:31:36 <Cale> @check \x -> floor x == truncate x
01:31:37 <jle`> > floor (-1.2)
01:31:37 <lambdabot>  *** Failed! Falsifiable (after 3 tests):
01:31:37 <lambdabot>  -2.449533872688817
01:31:38 <lambdabot>  -2
01:31:43 <jle`> ^^
01:31:47 <hunt> oh my goodness
01:31:49 <gnomnain> i tried to install haskell-src-exts with cabal install but it failed because happy was not installed. i installed happy with cabal and it worked, but is it normal ? if not, how/where should i report that ?
01:31:49 <hunt> negative numbers
01:31:51 <hunt> of course
01:32:16 <jle`> quickcheck can give two failed results?
01:32:26 <Cale> no
01:32:33 <Cale> It only gave one
01:32:41 <jle`> oh the other one was the response to my query
01:32:41 <Cale> lambdabot responded to two requests at once
01:32:43 <jle`> heh
01:33:45 <jle`> @check \x y -> x `div` y == x `quot` y
01:33:47 <lambdabot>  *** Failed! Exception: 'divide by zero' (after 1 test):
01:33:47 <lambdabot>  0 0
01:34:03 * hackagebot ad 4.2 - Automatic Differentiation  http://hackage.haskell.org/package/ad-4.2 (EdwardKmett)
01:34:15 <jle`> @check \x y -> y /= 0 && x `div` y == x `quot` y
01:34:17 <lambdabot>  *** Failed! Falsifiable (after 1 test):
01:34:17 <lambdabot>  0 0
01:34:29 <jle`> @check \x y -> y == 0 && x `div` y == x `quot` y
01:34:30 <lambdabot>  *** Failed! Exception: 'divide by zero' (after 1 test):
01:34:30 <lambdabot>  0 0
01:34:37 <jle`> darn. okay i'll stop
01:38:05 <awestroke> how do I force haskell to fully evaluate a computation whose result I throw away? deepseq doesn't work
01:38:28 <startling> awestroke, why?
01:38:47 <Kaidelong> @check \x y -> y == 0 || x `div` y == x `quot` y
01:38:49 <lambdabot>  *** Failed! Falsifiable (after 7 tests and 3 shrinks):
01:38:49 <lambdabot>  1 -2
01:38:50 <awestroke> startling: benchmark, and criterion smudges the spark eventlog
01:38:56 <Kaidelong> that what you wanted?
01:39:03 * hackagebot process-conduit 1.0.0.2 - Conduits for processes  http://hackage.haskell.org/package/process-conduit-1.0.0.2 (HideyukiTanaka)
01:39:22 <startling> awestroke: hm, how do you know deepseq doesn't work?
01:39:24 <jle`> Kaidelong: yup
01:39:59 <jle`> awestroke: are you attaching deepseq to something that is actually being evaluated?
01:40:08 <awestroke> startling: oops, forgot criterion runs many samples
01:40:19 <startling> ?
01:41:10 <awestroke> it worked, I just have to feed it more data to have the same execution time as it had with the criterion benchmark, since criterion runs the function 100(?) times
01:44:04 <startling> ah
01:44:11 <startling> well. :)
01:45:08 <bitemyapp> awestroke: where'd the warm-up come from?
01:45:33 <awestroke> bitemyapp: ?
01:54:02 <hunt> how do i convert a float to a GLfloat
01:56:44 <startling> hunt: is it a Fractional type?
01:56:45 <startling> if so
01:57:07 <startling> :t fromRational (toRational (1.2 :: Float))
01:57:08 <lambdabot> Fractional a => a
01:57:39 <hunt> startling: thanks yea that should work
02:13:01 <supki> :t fromRational . toRational
02:13:01 <lambdabot> (Fractional c, Real a) => a -> c
02:13:03 <supki> :t realToFrac
02:13:04 <lambdabot> (Fractional b, Real a) => a -> b
02:13:25 <startling> ah, realToFrac
02:14:09 * hackagebot wai-static-cache 0.1.0.0 - A simple cache for serving static files in a WAI middleware  http://hackage.haskell.org/package/wai-static-cache-0.1.0.0 (HugoGomes)
02:19:10 * hackagebot dirfiles 0.1.0.8 -   http://hackage.haskell.org/package/dirfiles-0.1.0.8 (HugoGomes)
02:38:19 <makalu> what should I do if I need Data.List.find but my predicate is monadic?
02:38:35 <makalu> is there a predefined function for this?
02:39:24 <quicksil1er> not in the standard librayr I don't think, makalu
02:39:26 <quicksil1er> check out http://hackage.haskell.org/package/monad-loops-0.4.2/docs/Control-Monad-Loops.html
02:39:33 <quicksil1er> you might want 'firstM' from that package
02:39:55 <makalu> thanks
02:40:12 <erisco> makalu, sounds like an interesting case. why would the predicate need to be monadic?
02:40:33 <makalu> I don't want another dependency for such a small thing. I just have two places where I recurse manually instead of using a higher-order function.
02:40:44 <makalu> I'll leave it as it is then
02:40:50 <fizruk> erisco: check if entry is in DB, for example
02:41:09 <Iceland_jack> makalu: You can implement it in terms of filterM
02:41:11 <Iceland_jack> @src find
02:41:11 <lambdabot> find p          = listToMaybe . filter p
02:41:17 <erisco> fizruk, oh, why would that be monadic?
02:41:28 <fizruk> erisco: or get first which satisfies user (i.e. user enters yes or no)
02:42:08 <fizruk> Iceland_jack: wouldn't that traverse all the list?
02:42:09 <quicksilver> Iceland_jack: although that will run the action on all items rather than shortcutting at the first one unlike firstM, will it not?
02:42:22 <Iceland_jack> yes you're right
02:42:43 <erisco> fizruk, you could do the latter differently
02:42:43 <quicksilver> this is the generic problem with generalising a list combinator to monads
02:42:57 <quicksilver> lots of the standard list combinators rely on laziness not to do unnecessary work
02:43:06 <quicksilver> and that doesn't make sense (in most cases) with monadic actions
02:44:57 <fizruk> erisco: you always can do things differently, I guess. doesn't mean you should not use monads if they provide a nice solution
02:47:37 <hunt> how do i import one function from a module
02:48:02 <Iceland_jack> hunt: import Data.List (groupBy)
02:48:02 <fizruk> import Module (func)
03:00:21 <Darwin226> Hello. Is this a right place to ask questions about Haskell problems?
03:00:37 <Iceland_jack> Darwin226: sure
03:01:00 <hunt> guys i need help
03:01:11 <hunt> im taking getContents
03:01:14 <hunt> running it through lines
03:01:17 <hunt> and processing each line
03:01:28 <hunt> but when my program gets to the terminating line, which reads "end" it crashes
03:01:36 <hunt> because main: <stdin>: hGetLine: illegal operation (handle is closed)
03:01:47 <hunt> help?
03:03:54 <turbopape> guys, would you recommend haskell for Machine Learning, Will it be efficient to cluster huge amount of text into classes (after vectorization)? Any similar use case you've heard of ?
03:04:30 <Darwin226> Great. I'm implementing breadth-first search and I'm kind of stuck. I have discrete steps that consist of a map of currently visited nodes and a list of nodes to visit in the next step. Each step is derived from the last one by making a new map with the nodes in the queue marked as visited and making a new queue with the neighbors of the nodes in the current queue.
03:05:15 <Darwin226> The problem is that since the map doesn't get updated mid-step, different nodes push the same neighbor in the new queue and that drastically increases the complexity because those duplicates always spread in the same step, so they never really eliminate each other.
03:07:04 <Iceland_jack> hunt: paste code
03:07:06 <Iceland_jack> @where lpaste
03:07:06 <lambdabot> http://lpaste.net/new/haskell
03:07:29 <hunt> Iceland_jack: its part of a big system
03:07:59 <hunt> the gist is
03:08:08 <hunt> f . lines $ getContents
03:08:12 <hunt> returns at some point
03:08:22 <hunt> and then stdin neeeds to be used regularly
03:08:29 <hunt> but wheni  try and use stdin normally
03:08:31 <hunt> it fails horribly
03:08:52 <Iceland_jack> hunt: Have you tried just using getLine?
03:09:10 <hunt> Iceland_jack i need to get a lot of lines though
03:09:20 <hunt> the lines are recursively traversed
03:09:50 <Iceland_jack> Darwin226: Am I understanding it correctly that the issue is duplication?
03:10:31 <Iceland_jack> Been up all night so I'm not in top shape
03:10:34 <Darwin226> Yeah. I need a way to make sure that the same node doesn't get pushed in the new queue. But that information is only available after the step has executed.
03:10:44 <quicksilver> hunt: you can't.
03:10:50 <quicksilver> hunt: you can't use getContents and then use stdin again
03:11:01 <quicksilver> getContents is the end of your stdin.
03:11:06 <hunt> quicksilver: so i should recursively call getLine?
03:11:14 <quicksilver> that would be a reasonable approach, yes
03:11:29 <hunt> quicksilver: ok, thanks
03:11:46 <Darwin226> Iceland_jack: I think I might have wasted some of your time just now. I might have a solution
03:11:47 <Iceland_jack> hunt: if you use getContents you don't use anything else, you have to be careful since you're pretending you have the entire input in memory even though you don't
03:11:57 <Iceland_jack> Darwin226: would nub work?
03:12:13 <Iceland_jack> Darwin226: That's impossible because my time is worthless :)
03:12:44 <Darwin226> :D Nub would work but it adds too much complexity in the step. I think I need to restructure my code a bit
03:13:11 <Iceland_jack> Darwin226: ah, why not just use Set and have them insert into that?
03:14:22 <quicksilver> a set seems like the right way to me
03:14:34 <quicksilver> silly to keep a list with duplicates when you don't want duplicates.
03:14:37 <Darwin226> Because ideally, a BFS is O(n) where n is the number of nodes. If I use a set, then insertions start costing too much. All of those solutions would work but I was trying to see if I could do it efficiently
03:14:51 <Darwin226> without resorting to imperative style
03:15:06 <Iceland_jack> > S.size (S.fromList [magicThing, magicThing])
03:15:07 <lambdabot>  2
03:15:51 <quicksilver> I don't see how BFS of an arbitrary DAG can possibly be O(n) unless your data structure is built with a BFS-path hardcoded into it
03:16:05 <quicksilver> you have to remember your already-visited locations surely?
03:16:26 <Darwin226> Yes, but a map is constant time access
03:21:30 <bartavelle> I don't see why BFS of an arbitrary DAG can't be done in O(n), if you don't constrain memory usage
03:25:58 <quicksilver> bartavelle: yes, not what I meant. I meant with cycles.
03:26:07 <bartavelle> ah, yes
03:26:18 <quicksilver> without cycles you can just keep long lists of where to go next.
03:26:23 <bartavelle> yes
03:26:29 <bartavelle> they don't have to be long ;)
03:27:11 <Darwin226> What's preventing you from keeping a map of visited nodes even if the graph has cycles?
03:27:24 <bartavelle> Darwin226, you will have to query it
03:27:28 <bartavelle> which will not be O(n)
03:27:40 <Darwin226> querying a hashmap is O(1=
03:27:46 <Darwin226> O(1)
03:28:06 <tdammers> ...for an ideal hashing function
03:28:24 <bartavelle> with #buckets >= n
03:28:54 <Darwin226> I think it's safe to say that for any realistic circumstance it's O(1)
03:29:16 <tdammers> it's close enough, anyway... but then, it's dangerous to naively assume that
03:29:22 <tdammers> (see also HashDoS)
03:30:19 <quicksilver> Darwin226: it's quite wrong to assume that
03:30:23 <nicoo> Darwin226: O(1) amortized. If you need your function to have predictable execution time, a tree-based map might actually be better
03:30:26 <bartavelle> well, if there aren't too many elements in you list, but if you give a maximum to n, everything becomes O(1) anyway :)
03:30:29 <quicksilver> querying and inserting into hash maps is O(log n)
03:30:41 <quicksilver> this is a very commonly made mistake in complexity theory
03:30:49 <quicksilver> calculating a hash key is not constant time
03:30:56 <quicksilver> (how could it be? it has to inspect the data)
03:31:02 <Darwin226> Interesting point...
03:31:09 <Darwin226> I actually never thought about that
03:31:17 <bartavelle> quicksilver, it can be constant time, if you accept more collisions
03:31:19 <nicoo> quicksilver: It's not even log n then, but O(key_size)
03:31:21 <Iceland_jack> quicksilver: Could store the hash in the graph
03:31:33 <quicksilver> nicoo: yes, and key_size is at least log n
03:31:37 <quicksilver> nicoo: (but can be worse)
03:31:53 <nicoo> (so it should be Omega(log n), not O(log n))
03:31:54 <quicksilver> if you have n distinct keys they must be log n long...
03:31:58 <nicoo> </nitpick>
03:32:04 <Darwin226> Actually, what's stopping me from storing the informating about a node being visited with the node itself?
03:32:14 <quicksilver> nicoo: well you can possibly tweak the hash algorithm to recover O(log n)
03:32:24 <quicksilver> nicoo: if you know enough about your key distribution
03:32:47 <bartavelle> Darwin226, then you have to transport the "mutable map"
03:32:53 <bartavelle> in your algorithm
03:33:05 <bartavelle> (which might be a good tradeof)
03:33:20 <Darwin226> I don't know how I'd do it in haskell. This was just me thinking imperatively
03:34:27 <bartavelle> Darwin226, that's not really difficult, just boilerplate most of the case (maps become folds, etc.), or you might just use a State monad
03:34:46 <Darwin226> I was hoping I didn't need monads
03:35:03 <bartavelle> well it's just for convenience, you don't have to use it
03:35:14 <quicksilver> Iceland_jack: yes, you can sometimes cache the hash values. That helps with certain algorithms
03:35:28 <Darwin226> We'll see how what I'm writing currently works out. I have no idea how complex it will be. Maybe you'll be able to tell me when it's done.
03:35:29 <quicksilver> Iceland_jack: you generally need to calculate them at least once for every element, though, so you're still on O(n log n)
03:35:35 <Iceland_jack> quicksilver: indeed
03:36:00 <bartavelle> Darwin226, but you will notice that all your functions will become "HashMap x x -> ... -> (a, HashMap x x)", which is exactly what the state monad is for
03:36:24 <Iceland_jack> but when you think about it, doesn't every algorithm have the potential to run in O(1) if given the chance :)
03:38:11 <nicoo> quicksilver: It should probably be easier to use a terser representation for keys than to tweak the hash, but yes, O(log n) is the best we can aim for
03:38:41 <Darwin226> Is there a way to get the first two items in a tuple from a three item one?
03:38:52 <Iceland_jack> let (a, b, _) = tuple in ...
03:39:18 <nicoo> Darwin226: Pattern0matching
03:39:22 <nicoo> ... as Iceland_jack said
03:39:25 * nicoo is too slow
03:40:05 <Darwin226> Hmm, how can I fit this in nicely. I have a function like f x y = g x y, but g returns (a, b, c) and I want f to return (a, b)
03:40:30 <Iceland_jack>     f x y = (a, b) where
03:40:30 <Iceland_jack>       (a, b, _) = g x y
03:40:38 <Darwin226> Neat
03:46:02 <Iceland_jack> or
03:46:03 <Iceland_jack>     f x y = let
03:46:03 <Iceland_jack>       (a, b, _) = g x y
03:46:03 <Iceland_jack>       in (a, b)
03:46:08 <Iceland_jack>  
03:46:12 <Iceland_jack> what ever you prefer
03:46:20 <Iceland_jack> I guess this is a more traditional layout
03:46:21 <Iceland_jack>     f x y = let (a, b, _) = g x y
03:46:21 <Iceland_jack>              in (a, b)
03:46:24 <Iceland_jack>  
03:50:42 <nicoo> or foo (x, y, _) = (x, y)
03:51:11 <nicoo> And compose with g, if you have many such functions
03:51:25 <Iceland_jack> If you have many of those functions you may want to use something other than tuples :)
03:51:29 <Welkin> this seems interesting, https://helloworldopen.com/
03:54:56 <awestroke> what makes this possible? http://hackage.haskell.org/package/contravariant-0.4.4/docs/Data-Functor-Contravariant.html#v:-62--36--60-
03:55:41 <awestroke> (>$<)
03:56:47 <merijn> awestroke: I'm unsure what your question is?
03:56:54 <k00mi> awestroke: that's just a synonym for contramap
03:57:37 <merijn> awestroke: You mean "a -> b" changing something from f b to f a?
03:58:00 <awestroke> merijn: yes
03:58:04 <awestroke> "reversing" the function
03:58:14 <merijn> awestroke: It doesn't
03:58:30 <merijn> awestroke: I like to think of contravariant function as "sinks"
03:59:06 <merijn> awestroke: So "f b" is something that "consumes" bs, now with a function "a -> b" you can turn 'f b' into 'f a', i.e. something that "consumes" as
04:00:07 <awestroke> merijn: ooooh alright
04:03:55 <awestroke> merijn: what's an example of such a "something" that consumes things?
04:05:07 <merijn> awestroke: A Chan?
04:05:07 <quicksilver> most contravariants use functions or mappings or represent them
04:05:26 <quicksilver> if it wasn't for the Ord constraint, Map k v would be contravariant in the key type 'k'
04:08:37 <awestroke> quicksilver: instance (Ord k) => Contravariant Map k v where [...] ?
04:16:03 <srhb> Where does cabal put data-files after installation?
04:17:34 <awestroke> quicksilver: sorry, was disconnected, did you answer?
04:19:16 <merijn> srhb: Depends on where the library is installed
04:21:26 <shiona> if you guys have interest in AI, making haskell more known or competing, you may be interested in https://helloworldopen.com/
04:26:22 <awestroke> merijn: if Chan a can be a contravariant, why isn't it an instance of the Contravariant type class?
04:26:49 <t7> shiona: is it a real race car?
04:27:09 <quicksilver> awestroke: no, I didn't answer, but I don't think it works like that
04:27:23 <quicksilver> Chan isn't contravariant because it is indirect through IO, surely?
04:27:29 <t7> oh a game
04:27:30 <merijn> awestroke: Because it can't really be, right now, I think. Conceptually it could, though
04:27:59 <t7> json over tcp... for a realtime game...
04:28:19 <merijn> quicksilver: Yes
04:28:21 <awestroke> t7: running from the contestants' laptops over wifi during the finals, no less
04:29:24 * hackagebot ixset-typed 0.1.0.0 - Efficient relational queries on Haskell sets.  http://hackage.haskell.org/package/ixset-typed-0.1.0.0 (AndresLoeh)
04:29:32 <shiona> t7: most likely not :D
04:32:58 <Darwin226> Possibly a stupid question but how do I import Data.HashMap? It says that I can't be found and asks me if I meant Data.HashSet instead
04:33:18 <merijn> Darwin226: Do you have that package installed?
04:33:26 <Darwin226> I've never done that before
04:33:28 <Darwin226> How?
04:33:53 <supki> Darwin226: import Data.HashMap.Lazy or Data.HashMap.Strict
04:34:07 <Darwin226> Oh. Thanks
04:35:37 <smiller2> Hey guys, I'm trying to build a Pipes.Pipe pipe from a bytestring to a bytestring; I need to construct a "MonadIO m => Pipe ByteString ByteString m ()" value.  Is it possible to do this from an attoparsec Parser?
04:40:59 <awestroke> smiller2: why not IO (Pipe ByteString ByteString) ?
04:42:29 <merijn> awestroke: That makes no sense
04:42:39 <merijn> awestroke: That type is a type error
04:42:51 <merijn> smarter: Just use "Pipe ByteString ByteString IO ()"?
04:43:19 <merijn> eh
04:43:27 <merijn> Wrong autocomplete >.>
04:44:24 <smiller2> (;_; my browser became unresponsive; sorry guys!)
04:44:33 <skypers_> hello. I have a function :: E a -> E b ; I use pattern match to matche one ctor, and in other cases, I just want to leave the type unchanged
04:44:40 <skypers_> I failed to do that
04:44:40 <skypers_> like
04:44:47 <skypers_> a@(_) -> a
04:44:55 <skypers_> of cours a ~ b fails
04:44:56 <smiller2> < awestroke> smiller2: why not IO (Pipe ByteString ByteString) ? — The most recent version of Pipes defines it with four variables, essentially:
04:44:56 <skypers_> course*
04:45:02 <skypers_> I tried to cheat with const or id
04:45:04 <smiller2> awestroke: Pipe input output m r
04:45:06 <skypers_> but same thing
04:45:15 <smiller2> Pipes v4.1
04:47:04 <merijn> smiller2: I don't really understand what the problem is with constructing a pipe like that?
04:47:52 <smiller2> awestroke, merijn: In any case, I need to define a Pipe ByteString ByteString IO ()   value, from an attoparsec Parser.  IOW, pipe :: Pipe ByteString ByteString IO (); pipe = something with (parser :: Data.Attoparsec.ByteString.Parser)
04:48:23 <bartavelle> skypers, E a -> Either (E a) (E b) ?
04:48:23 <bartavelle> oh
04:48:23 <bartavelle> you mean you don't want to re-type all the pattern matches ?
04:48:34 <Aetherspawn> the best lenses are the ones that break all the rules
04:48:35 <Aetherspawn> :|
04:48:38 <skypers_> I think I fixed it
04:48:40 <skypers_> now
04:48:42 <skypers_> the type is
04:48:50 <skypers_> reduceE :: E a -> SomeE
04:48:59 <skypers_> SomeE is an existentially quantified type for E a
04:49:20 <smiller2> I checked out pipes-parse (http://hackage.haskell.org/package/pipes-parser), but it seems to require an existing Producer; I'm not sure how to define a Pipe instead.
04:49:21 <skypers_> it typechecks, gonna see what it does in runtime
04:49:27 * hackagebot array-memoize 0.5.0 - Memoization combinators for finite subsets of function domains using arrays  http://hackage.haskell.org/package/array-memoize-0.5.0 (DominicOrchard)
04:50:15 <skypers_> how can I unwrap that in ghci?
04:50:31 <skypers_> <interactive>:67:5:     My brain just exploded
04:50:41 <skypers_> pattern matching is not the solution :D
04:50:53 <bartavelle> would it make sense to change your E data type to something like
04:51:02 <skypers_> oh
04:51:04 <skypers_> it works
04:51:11 <skypers_> let f (SomeE a) = show a
04:51:14 <skypers_> tadaaa!
04:51:30 <bartavelle> data E a = EV (TypePart a) | EC ConstPart
04:51:33 <skypers_> I can show a function!
04:51:40 <bartavelle> hum :)
04:51:47 <skypers_> bartavelle: E is a more complex type
04:51:52 <skypers_> it has something like 30+ ctors
04:51:54 <skypers_> and is a GADT
04:52:07 <skypers_> the thing is
04:52:08 <bartavelle> yeah, I thought about splitting the 30 ctors in 2 groups
04:52:17 <skypers_> if I got E (a -> b)
04:52:19 <bartavelle> those that depend on the "a" type, and those that don't
04:52:19 <skypers_> I can show that
04:52:31 <skypers_> hm
04:52:36 <bartavelle> it probably isn't useful in your case
04:52:41 <skypers_> in a GADT a is not shared
04:52:47 <bartavelle> ah !
04:52:49 <skypers_> it’s existentially quantified
04:52:59 <skypers_> you can see a GADT as data E :: * -> * where…
04:53:03 <skypers_> there’s no a in there
04:53:56 <bartavelle> I don't understand what you wanted to do then, which doesn't surprise me
04:54:31 <Heather> :t ()
04:54:32 <lambdabot> ()
04:54:43 <Heather> :t (())
04:54:44 <lambdabot> ()
04:56:19 <smiller2> Is anybody here familiar with pipes parsers who can help me with that question?
05:09:14 <Darwin226> If I have a function f a b, and I have a tuple (a, b), is there a way to "unpack" the tuple into arguments?
05:09:43 <merijn> :t uncurry
05:09:43 <lambdabot> (a -> b -> c) -> (a, b) -> c
05:10:11 <Darwin226> Awesome. Is there a larger equivalent?
05:11:08 <skypers_> is there a way to turn a function a -> b -> c into a -> (b -> c)?
05:11:30 <ion> skypers: It already is in that form.
05:11:42 <ion> @hoogle (a -> b -> c -> d) -> (a, b, c) -> d
05:11:42 <skypers_> ion: the type system doesn’t agree
05:11:43 <lambdabot> No results found
05:11:49 <skypers_> yeah
05:11:51 <skypers_> :t curry
05:11:52 <lambdabot> ((a, b) -> c) -> a -> b -> c
05:11:55 <skypers_> I don’t want that
05:12:07 <skypers_> I have a ctor
05:12:17 <skypers_> Fun :: (E a -> E b) -> E (a -> b)
05:12:24 <ion> @type [undefined :: a -> b -> c, undefined :: a -> (b -> c) ]
05:12:25 <lambdabot> [a -> b -> c]
05:12:27 <skypers_> if I pass a function E Int -> E Float, it’s ok
05:12:36 <skypers_> if I pass E Int -> E Int -> E Float
05:12:37 <skypers_> it fails.
05:12:59 <merijn> skypers_: Because "E Int -> E Float" is not of the form "E b"
05:13:19 <skypers_> merijn: so I need to make it E (Int -> Float)?
05:13:29 <flebron> Has SPJ ever come here?
05:14:05 <skypers_> I think I’m gonna feel some pain with that issue
05:14:10 <skypers_> if I write that
05:14:18 <skypers_> foo :: E Float -> E Float -> E Float; foo = (+)
05:14:29 * hackagebot snap-server 0.9.4.2 - A fast, iteratee-based, epoll-enabled web server for the Snap Framework  http://hackage.haskell.org/package/snap-server-0.9.4.2 (GregoryCollins)
05:14:33 <skypers_> and I want to inject that with Fun :: (E a -> E b) -> E b
05:14:38 <skypers_> arf
05:14:57 <skypers_> (E a -> E b) -> E (a -> b)**
05:18:02 <awestroke> skypers_: what's E? is E a monad?
05:18:07 <skypers_> no
05:18:10 <skypers_> it’s a GADT
05:18:14 <skypers_> it represents an AST
05:18:21 <skypers_> currently
05:18:35 <skypers_> I can lift a computation (E a -> E b) into the AST using the Fun ctor
05:18:46 <skypers_> I’m looking for a way to lift a n-ary function
05:18:57 <skypers_> ahah
05:18:58 <skypers_> the Fun ctor
05:19:01 <skypers_> funny
05:19:09 <skypers_> not a Functor heh! :)
05:19:26 <awestroke> so what is a fun ctor?
05:19:37 <skypers_> the Fun constructor, awestroke
05:19:54 <skypers_> Fun :: (constraint) => Int -> (E a -> E b) -> E (a -> b)
05:19:58 <skypers_> don’t mind about the Int
05:20:41 <skypers_> maybe I just have to write a combinator that turns a function into a function that returns a Fun
05:21:11 <skypers_> like liftE :: (E a -> b) -> (E a -> E b)
05:21:31 <skypers_> the thing is, if b is already an expression (unary function), I end up with E (E b)
05:21:36 <skypers_> which sounds like a comonad…
05:24:06 <prophile> that looks a lot like a comonad
05:24:23 <skypers_> ok
05:24:26 <prophile> liftE is just extend
05:24:31 <skypers_> yeah
05:24:38 <skypers_> if I do
05:24:44 <skypers_> Fun 0 . foo
05:24:50 <skypers_> with foo :: E Float -> E Float -> E Float
05:24:57 <skypers_> I get E Float -> E (Float -> Float)
05:24:58 <prophile> what's the type of Fun?
05:25:05 <skypers_> [14:18] <skypers_> Fun :: (constraint) => Int -> (E a -> E b) -> E (a -> b)
05:25:09 <skypers_> prophile: ^
05:25:20 <prophile> oh, I see
05:25:44 <killy971> Hi. I have a question regarding the content of .cabal files, when creating a new cabal package:
05:26:06 <killy971> What are the best practices for defining the package dependencies constraints?
05:26:11 <skypers__> so
05:26:15 <skypers__> something like
05:26:17 <skypers__> E a -> a
05:26:22 <skypers__> which IS a comonad
05:26:25 <skypers__> (extract)
05:26:36 <skypers__> now I’m excited.
05:26:38 <skypers__> :)
05:29:07 <skypers__> aaaaw
05:29:10 <skypers__> it works!
05:29:45 <Darwin226> If I have a bunch of lists and I add the all together with ++, it shouldn't be any slower than putting them in a list of lists and then calling concat, right?
05:30:01 <dv-> @src concat
05:30:02 <lambdabot> concat = foldr (++) []
05:30:22 <makalu> if I have two expressions that have sub-expressions "f x" then that sub-expression is evaluated at most once?
05:31:34 <supki> makalu: I wouldn't count on that
05:31:46 <supki> makalu: if you want to share the result of  f x  use an explicit let
05:31:58 <eacameron> makalu: or "where"
05:32:10 <supki> binding, like  let y = f x in ... y ... y ...
05:33:14 <makalu> but in theory it should be possible to have this kind of optimization in the compiler? Because Haskell is referentially transparent.
05:33:32 <supki> sure, but it's not always an optimization
05:33:42 <skypers__> I use that for lisibility
05:33:57 <skypers__> and descending problem resolving
05:34:01 <awestroke> makalu: it's called CSE - Common subexpression elimination - and last I asked about it here in the channel somebody said GHC doesn't have it
05:34:06 <skypers__> you think and reason in high terms, general ones
05:34:12 <skypers__> and you “descen” into implementation
05:34:15 <skypers__> descend*
05:34:21 <skypers__> (with the where keyword)
05:34:27 <dwat3r_> hi guys, i've installed the binary-strict package via cabal,and I can't load the modules of the package into ghci
05:34:45 <dwat3r_> I don't know what's going on...
05:34:58 <skypers__> what error(s) do you get?
05:35:11 <awestroke> makalu: or rather, GHC has it but as a compile-time flag that currently has the risk of creating resource leaks iirc
05:35:27 <makalu> I found this www.haskell.org/haskellwiki/GHC/FAQ#Does_GHC_do_common_subexpression_elimination.3F thanks
05:35:54 <dwat3r_> skypers__: ghci can't find it.
05:39:09 <bartavelle> Darwin226, it might be different performance-wise, depending on how you use (++)
05:41:36 <Darwin226> I've finished my BFS implementation so if someone would be willing to look it over and see if there's anything obvious that's wrong with it, I'd appreciate it. It currently finds a path from 0,0 to 1000, 1000 in a square grid in about 6 seconds.
05:41:38 <Darwin226> http://lpaste.net/102059
05:42:33 <awestroke> dwat3r: what do you type into ghci?
05:42:50 <Welkin> those are long lines
05:44:20 <killy971> Is there any material available regarding how to define package dependencies constraints in a .cabal file when creating a new cabal package?
05:44:21 <awestroke> Welkin: those are big indents
05:44:27 <glguy> Darwin226: You're probably better off using a Data.Set.Set instead of a HashMap to store booleans
05:44:51 <glguy> unless you're actually using all three states (true, false, not found)
05:45:14 <Darwin226> Nope. Just storing true for visited.
05:45:27 <Darwin226> Am I really better off? Isn't that slower on the lookup and update?
05:47:20 <makalu> how do I know when to make record fields strict and when not to?
05:47:58 <aristid> makalu: some people recommend making them strict by default, and you would probably know when you can't have them strict.
05:50:32 <abbradar> Hello all, I need something like "restricted Data.Dynamic". I've written a working example of my idea: http://lpaste.net/edit/102061. It looks sloppy, though, and I don't want to type all instances by hand -- is there a better way to do this?
05:51:08 <quchen> Darwin226: Annotated with a couple of comments: http://lpaste.net/102059
05:52:34 <bartavelle> Darwin226, there is still HashSet, but I think it's just like HashMap k () ?
05:53:50 <Darwin226> quchen: Thanks for the comments. I know about the 80 char thing but I'm always scared to break the line because I don't know how the indentation will be interpreted
05:55:11 <macron> abbradar: as it happens I was trying to solve that problem myself just a few days ago.
05:55:24 <macron> abbradar: here's my attempt, http://lpaste.net/102067
05:56:01 <macron> abbradar: my Join class is similar to your Union class. A join is just a more abstract union.
05:56:25 <macron> abbradar: unfortunately, you still have to define some manual instances.
05:56:31 <Welkin> I believe you can break the line up with parens easily
05:56:53 <bartavelle> Darwin226, you might not want to use foldl on line 17 of the second file, as you do this in it : neighbors node ++ q
05:57:14 <glguy> In that case he's repeatedly appending a short list on the left
05:57:18 <glguy> so it's not too bad
05:57:32 <bartavelle> well then there is the case for foldl' ;)
05:57:40 <Darwin226> bartavelle: I'm looking at folds right now but I can't really say I get why one would be better than the other
05:58:20 <macron> abbradar: the trick used is the one from http://www.haskell.org/haskellwiki/GHC/AdvancedOverlap
05:59:06 <abbradar> macron: thanks, i'm tring to wrap my head though this right now
06:00:03 <bartavelle> in *my* experience (which isn't that extensive), foldl' is almost always a better choice than foldl
06:01:04 <killy971> Anyone can help regarding the best practices for defining dependencies constraints in .cabal files?
06:02:14 <Darwin226> It doesn't recognize foldl'. What do I have to import?
06:02:35 <Welkin> @hoogle foldl'
06:02:36 <lambdabot> Data.List foldl' :: (a -> b -> a) -> a -> [b] -> a
06:02:36 <lambdabot> Data.Foldable foldl' :: Foldable t => (a -> b -> a) -> a -> t b -> a
06:02:36 <lambdabot> Data.ByteString.Char8 foldl' :: (a -> Char -> a) -> a -> ByteString -> a
06:02:36 <bartavelle> Data.List
06:03:09 <kgadek> hi. quick survey: what IDE/editor/tools are you using (eg. vim+vim-haskell+hare+hoogle etc) ?
06:03:19 <osa1> can anyone help me? Aeson's eitherDecodeStrict' returns me error message "Failed reading: satisfyElem" and I have no idea what does that mean. I searched for that error string in Aeson source but couldn't find anything.
06:05:35 <supki> osa1: that looks like an attoparsec error
06:05:40 <supki> not that that helps you much
06:05:58 <osa1> ...
06:06:16 <glguy> It means that the parser was written using satisfyElem applied to some predicate and your file failed that predicate at some point
06:06:37 <glguy> It's an unhelpful "unexpected character in file in a particular context"
06:07:03 <osa1> okay so how do I know if this is a bug in aeson/attoparsec or in my program?
06:09:08 <supki> I'd try to parse to Aeson's Value first
06:09:46 <supki> if that fails I'd try to check JSON validity with some external validator
06:11:06 <abbradar> macron: quite a neat trick!
06:12:32 <Darwin226> So I tried my BFS with a regular map and it performed a lot worse. I tried it with a HashSet and the performance is the same. Also, foldl' didn't make a performance difference (but I get why it's better)
06:13:16 <Walther> Hmm. I need something like iterateWhile - i need to stop iterating when the result is 1
06:13:30 <Walther> (but i need the whole list until that point)
06:13:48 <glguy_> You can use takeWhile and iterate together
06:14:11 <glguy_> takeWhile (/= 1) (iterate f x)
06:14:33 <Walther> Ooh, neat
06:14:37 <Walther> didn't think of that, smart move
06:15:18 <Kron> when I was new I used to want a 'foldwhile' too; a fold function that stops at an aribtrary point.
06:15:18 <Walther> Although, that strips the 1 at the end :/
06:15:39 <Walther> toying around with Collatz chains :)
06:15:42 <Kron> but lazy evaluation + composition means you can just slap takeWhile in front of anything and you have a stopping version of that thing
06:16:12 <Kron> what're you trying to do exactly?
06:17:02 <quchen> Walther: Have a look at unfoldr to write collatz.
06:18:09 <Kron> (++ [1]) . takeWhile (\= 1) $ iterate f x
06:18:48 <Kron> not the most elegant solution in the world, hah
06:21:21 <tromp__> > 1-2*exp(-1)
06:21:22 <lambdabot>  0.26424111765711533
06:23:38 <tromp__> > (1-exp(-1))^2
06:23:39 <lambdabot>  0.39957640089372803
06:24:06 <Walther> > maximumBy length [1..1000] [1001..1002]
06:24:07 <lambdabot>  Couldn't match type `[a0]' with `[t1] -> t0'
06:24:07 <lambdabot>  Expected type: ([t1] -> t0) -> ([t1] -> t0) -> GHC.Types.Ordering
06:24:07 <lambdabot>    Actual type: [a0] -> GHC.Types.Int
06:24:53 <Walther> > maximumBy (max length) [1..1000] [1001..1002]
06:24:54 <lambdabot>  Couldn't match type `[a0]' with `[a0] -> GHC.Types.Ordering'
06:24:54 <lambdabot>  Expected type: ([a0] -> GHC.Types.Ordering)
06:24:54 <lambdabot>                 -> ([a0] -> GHC.Types.Ordering) -> GHC.Types.Ordering
06:24:54 <lambdabot>    Actual type: ([a0] -> GHC.Types.Ordering)
06:24:54 <lambdabot>                 -> [a0] -> GHC.Types.OrderingCouldn't match type `GHC.Types.I...
06:25:15 <Walther> > maximumBy (maximum length) [1..1000] [1001..1002]
06:25:16 <lambdabot>  Couldn't match expected type `[([t1] -> t0)
06:25:16 <lambdabot>                                 -> ([t1] -> t0) -> GHC.Types.Ordering]'
06:25:16 <lambdabot>              with actual type `[a0] -> GHC.Types.Int'
06:25:33 <killy971> isnt't it "maximumBy (comparing length)"?
06:26:34 <glguy_> > maximumBy (comparing length) [ [1..1000] , [1001..1002] ]
06:26:35 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
06:27:21 <Walther> ha, thanks
06:31:40 <aleator_> I have a monoid, which at some point 'fills up' and starts discarding the right argument of mappend. I need to feed it results of an IO action. Is it safe to rely on unsafeinterleaveIO to short circuit the calculation, if I end up immediatedly forcing the result?
06:37:49 <bennofs> aleator_: it's probably safe, but I wouldn't rely on unsafeInterleaveIO if there is another way (what you're doing seems a lot like an ugly hack to me). Maybe just write the function IO a -> IO a -> IO a (where a is your monoid type) manually? (You could even generalize it as Monad m => m a -> m a -> m a, not sure if there is a typeclass for this already)
06:38:11 <yitz> aleator_: why do you need unsafeInterleaveIO for this?
06:39:10 <aleator_> Yeah, it is bit hacky. I just don't want to encode the short-circuiting condition twice (ie. once for the monoid and once for the IO action that pulls stuff in the monoid)
06:40:17 <yitz> aleator_: can you test the monoid value to see if it is "full"?
06:40:38 <quchen> aleator_: Data that "fills up" does not sound like a monoid.
06:40:58 <aleator_> yitz: Yes. But I've got plenty of them and wanted to hack myself around doing that :)
06:41:00 <macron> abbradar_: I haven't gotten around to this yet, but could be worth hackaging that piece of code up.
06:41:05 <yitz> quchen: the First monoid is full right from the start.
06:41:08 <aleator_> quchen: Well, 'First'..
06:41:27 <quchen> ... are you sure about the laws? (Maybe I should have asked that in the first place)
06:43:02 <yitz> aleator_: it is common to do an IO action until some pure condition is fulfilled. one normally does not do that with unsafeInterleaveIO.
06:43:12 <aleator_> Well, mempty is clearly unit and I don't see a problem with associativity (This is essentially the `First` monoid with some extras)
06:43:55 <aleator_> yitz: I know :)
06:44:06 <quchen> Okay then. I was just asking because there have been a lot of "I have a monoid" questions here where the laws weren't verified (e.g. one that intersperses commas in mappend) etc.
06:45:51 <aleator_> The whole point of the exercise is that if i foldmap my monoid over a pure list, I think it short circuits nicely. Then I've got a gigabyte of stuff that I need to fold over, which I need to stream from the disk and preferrably short circuit as well.
06:46:53 <aleator_> I could and probably should just write somekind 'IsFull' class for my monoids and use that, but the unsafeinterleave seemed like a fun hack to try
06:47:00 <bennofs> aleator_: you could write your function once as Monad m => m YourMonoid -> m YourMonoid -> m YourMonoid and then write the Monoid instance for YourMonoid in terms of that function (using the identity monad)
06:48:08 <abbradar_> macron: Indeed. I'm playing with this piece of code now
06:48:46 <aleator_> bennofs: Yeah. Had I thought about that before writing dozens of these things that'd been the smarter idea :)
06:50:11 <hseg> Question: Is there a typeclass equivalent to Arrow in the same way Applicative is equivalent to a typeclass with functions `unit :: f ()` and `(><) :: f a -> f b -> f (a,b)` for some Applicative f?
06:51:03 <abbradar_> Also, second question to all: while thinking about "not writing instances by hand", I've tried to use TH (just for the sake of trying): http://lpaste.net/3230874803225231360. It's my first attempt to use it: can someone point me at plain bad parts?
06:51:50 <fizruk> hseg: i think it's usually called Monoidal, but I don't know if there is a definition for it in one of standard packages
06:52:05 <fizruk> hseg: ignore that, I misread your question
06:53:47 <hseg> http://homepages.inf.ed.ac.uk/wadler/papers/arrows/arrows.pdf looks promising, but I don't understand their notation.
06:54:13 <abbradar_> (For someone who has missed the first part of the code: http://lpaste.net/102061)
06:56:38 <aleator_> bennofs, yitz: here is the mockup I made of this http://lpaste.net/102070
06:57:24 <aleator_> The print is kinda essential there.
06:58:37 <aleator_> I think thats safe, but I've been wrong before
06:59:25 <jophish> Yo yo yo
06:59:49 <jophish> What is the problem with attoParsec's peekChar as noted here: http://hackage.haskell.org/package/subtitleParser-0.3/docs/Text-Subtitles-SRT.html
07:01:47 <abbradar_> Sorry, need to go now. I'll join later.
07:02:07 <Yuu_chan> What could be architecturally wrong with this code? http://lpaste.net/2875317254180831232
07:02:52 <Yuu_chan> (this is a refactoring task from a particular  C++ vacancy and I wondered how could it be rewritten in Haskell)
07:04:30 <tdammers> Yuu_chan: I might define data types for the various features and parse the input into those, rather than the ad-hoc list data structures you're using now
07:05:00 <tdammers> not sure whether that would actually be "better" though
07:05:12 <tdammers> at least not as long as this code exists in a vacuum
07:05:31 <Yuu_chan> tdammers: I thought about an ADT, but it wouldn't be easily extended
07:05:57 <tdammers> I was thinking separate types, actually, and then implementing a typeclass to pull them together
07:06:41 <Yuu_chan> tdammers: as for different types for different features, how to return a particular value from parsing? I probably wrongly understood, but this smells dynamic to me
07:07:01 <tdammers> well, you'd still wrap things in a Feature eventually
07:07:34 <tdammers> and actually, it might be overkill
07:07:34 <Yuu_chan> tdammers: existentials?..
07:08:23 <merijn> Yuu_chan: Actually, I would ignore what tdammers just said
07:08:31 <merijn> @where existential-antipattern
07:08:31 <lambdabot> "Haskell Antipattern: Existential Typeclass" by Luke Palmer at <http://lukepalmer.wordpress.com/2010/01/24/haskell-antipattern-existential-typeclass/>
07:08:51 <Yuu_chan> tdammers: being in vacuum is a significant problem of most test snippets :(
07:09:10 <merijn> Yuu_chan: Because most people *start* with the existential only to run into problems with it and moving back to your current approach
07:09:15 <Yuu_chan> merijn: I read that article, thank you :)
07:09:39 <tdammers> and no, I didn't mean existential types in any way
07:09:42 * hackagebot shuffle 0.1.1.0 - Shuffle tool for UHC  http://hackage.haskell.org/package/shuffle-0.1.1.0 (AtzeDijkstra)
07:09:49 <tdammers> http://lpaste.net/2875317254180831232
07:09:56 <tdammers> this kind of approach, reallyu
07:10:11 <tdammers> keep the Feature thing, just use a more structured representation for the individual shapes
07:10:38 <tdammers> maybe even Circle { circleCenter :: Point, circleRadius :: Double }
07:10:39 <merijn> tdammers: Ah, right
07:10:46 <tdammers> if only for self-documentation purposes
07:10:53 <merijn> tdammers: But that really depends on the operations used on them
07:11:02 <tdammers> merijn: of course. Hence, the vacuum argument.
07:11:05 <merijn> Yuu_chan: The original code looks ok to me, though
07:11:38 <Yuu_chan> tdammers: ah. So drawCircle would be Circle -> IO (), and so on?
07:11:48 <dmwit> ?unmtl StateT [Token] (Either [String])
07:11:49 <lambdabot> Plugin `unmtl' failed with: `StateT [Token] (Either [String])' is not applied to enough arguments, giving `/\A. [Token] -> (Either [String]) (A, [Token])'
07:12:00 <tdammers> Yuu_chan: yes
07:12:08 <Yuu_chan> So the changes are only to give meaning to abstract sets of points
07:12:20 <tdammers> pretty much, yes
07:12:29 <Yuu_chan> Thank you, now I get it
07:12:48 <tdammers> plus, depending on what you do, the compiler will have a bit more clue in case you do impossible things
07:13:39 <tdammers> you could add a ToFeature typeclass, and possible a FromInputData typeclass, but that'd probably be overkill at this point
07:14:58 <antris> Hey Haskellers. We're organizing a competition where you can win cash by coding a race car bot using Haskell: https://helloworldopen.com/
07:15:12 <antris> Opened signups today :)
07:15:31 <dmwit> No Alternative instance for Either?
07:15:33 <dmwit> That's inconvenient.
07:16:36 <Yuu_chan> By the way, the original piece of C++ code which was supposed to criticize and refactor: http://lpaste.net/1889268259954360320
07:17:04 <antris> Also let me know if you have any questions about the competition!
07:17:15 <Yuu_chan> dmwit: I thought of a most elegant way to fail where featureType is out of range, if-then seems ugly to me
07:18:03 <Yuu_chan> s/where/when
07:18:43 <tdammers> Yuu_chan: red flag
07:18:52 <dmwit> I'm not really sure why you're addressing me.
07:19:20 <dmwit> I don't mean like, "Why are you talking to me at all?", I mean, "Why was that question specific to me?".
07:19:53 <tdammers> looks like a programming task where you are strongly led towards applying a Factory pattern and code reuse by inheritance or some such
07:20:12 <dmwit> Haddock really needs a way to track down instance implementations. =/
07:20:22 <Adeon> antris: is says external dependencies must be included within the repository. does this mean anything if I want to use packages from hackage?
07:20:23 <Yuu_chan> dmwit: because you were speaking about Alternative instance of Either, and I thought if it is appliable to parsing error handle (decodeOrFail returns Either, after all)
07:20:24 <dmwit> Where the heck is the Alternative instance for StateT?
07:21:46 <tdammers> something like an abstract Feature base class, a FeatureParser base class, a FeatureParserFactory class, a FeatureFactory class, and then a layer of DI on top
07:22:22 <Yuu_chan> ...and I thought you saw my lpaste snippet >_> Sorry for misunderstandings.
07:22:31 <tromp__> > log(3)/log(2)
07:22:32 <lambdabot>  1.5849625007211563
07:22:45 <tromp__> > 16 / (log(3)/log(2))
07:22:46 <lambdabot>  10.094876057143319
07:23:00 <dmwit> Yuu_chan: I see. I haven't really been following your discussion, sorry.
07:23:15 <dmwit> > 16 / logBase 2 3
07:23:16 <lambdabot>  10.094876057143319
07:23:45 <quchen> dmwit: Control.Monad.Trans.State.{Lazy,Strict}
07:23:55 <dmwit> quchen: Thanks, looking.
07:24:02 <quchen> (transformers package)
07:25:01 <antris> Adeon: My Haskell knowledge is pretty shaky but as long as you have the license to use it and the size is reasonable then all libraries are allowed
07:25:17 <Yuu_chan> tdammers: you've passed the interview
07:25:23 <Adeon> okay
07:25:45 <dmwit> > Left 3 `mplus` Right 3
07:25:46 <lambdabot>  No instance for (Control.Monad.Trans.Error.Error a0)
07:25:47 <lambdabot>    arising from a use of `e_133'
07:25:47 <lambdabot>  The type variable `a0' is ambiguous
07:25:47 <lambdabot>  Possible fix: add a type signature that fixes these type variable(s)
07:25:47 <lambdabot>  Note: there are several potential instances:
07:25:57 <dmwit> bah
07:26:06 <dmwit> Why does everything have to be so fail.
07:26:30 <zq> antris: "
07:26:31 <zq> The AI must have have near real time performance on CI and qualifying round. Slow response time is grounds for disqualification."
07:26:40 <quchen> :set -XSuperExtendedDefaulting
07:26:43 <zq> not sure how you'll get realtime with a gc language
07:26:52 <Adeon> perhaps not *that* real-time
07:26:57 <Adeon> soft real-time, I would guess
07:26:59 <zq> then it ain't realtime
07:27:06 <zq> more like "fast enough"
07:27:14 <yesthisisuser> I am starting to like TH very much.
07:27:34 <antris> zq: Yeah our colleagues have written bots with Haskell successfully, so no worries :)
07:27:44 <antris> against the same servers
07:27:56 <yesthisisuser> It makes me think that "Any problem in computer science can be solved by adding another layer of boilerplate."
07:28:29 <tdammers> Yuu_chan: I flunked an interview on purpose once, because they gave me a task similar to this one
07:28:49 <tdammers> they gave me a list of "requirements", one of them being "you must use OOP"
07:29:17 <tdammers> I delivered a solution that was simple, elegant, and met all the other requirements
07:30:03 <quchen> yesthisisuser: You're joking, but there have been questions how to write TH to generate TH here in the past :-þ
07:30:32 <tdammers> quchen: what's wrong with that?
07:30:37 <Yuu_chan> tdammers: I think you did it the right way, it would be impossible to work in the company of prominent OOP fanatics <_<
07:30:56 <tdammers> yeah
07:31:10 <yesthisisuser> quchen: Hehe.. well i really do like TH.. i just haven't really "digged" into it before
07:32:01 <yesthisisuser> thinking in terms of ASTs is a bit different
07:32:03 <dmwit> Is there some package somewhere that offers an Either that doesn't bother getting a "fail" implementation?
07:32:08 <quchen> tdammers: I think TH is a really nice preprocessor. Generating TH using TH feels like using C++ templates to create templates, or CPP to generate CPP macros.
07:32:32 <Guest77325> http://www.marketglory.com/strategygame/galahad1st for online gamers, if you didn't already, use this link to register on MerkatGlory: a free2play financial strategy game where virtual currency can be converted into real money. It starts out slow but in time you can turn a good profit that is if you have the necessary patience to grow a little bit every day :P
07:32:44 <quchen> It's yet another layer of preprocessor, and I think at some point there should be no other preprocessor. TH_ω sounds wrong ;-)
07:33:16 <Yuu_chan> tdammers: and what did they say after all?
07:33:40 <antris> i've flunked an interview because i didn't use MVC. the difference was, though, that they didn't say it beforehand, just criticized my code that had "view and controller logic mixed up"
07:33:41 <tdammers> Yuu_chan: that my OOP skills were lacking. Then they gave me another task that involved refactoring an existing codebase
07:34:00 <tdammers> my answer to that one was that their architecture was fundamentally wrong, but they didn't agree
07:34:09 <antris> later on people started using angular.js, and it got really popular...
07:35:58 <quchen> tdammers: "Your entire codebase is wrong" is a daring thing to say in an interview haha
07:36:38 <bartavelle> well, better point it out during the interview than after you have resigned from the previous job
07:37:34 <tdammers> quchen: well, the ship had basically sailed for me anyway, I was just going to see how bad of a match exactly this would be
07:37:37 <antris> i would argue most good employers would welcome that kind of feedback, if it's done constructively
07:37:51 <antris> and you would show what you are basing your opinion on
07:38:16 <tdammers> quchen: also, I didn't say "your entire codebase is wrong", I said "this part of the codebase is fundamentally flawed at the architecture level; I would have done it like this and that, and here's how I'd refactor things to be that way"
07:38:18 <bartavelle> except employer /= guy that gives the interview :)
07:38:35 <tdammers> at which point they muttered something like refactoring dangerous mumble mumble
07:39:02 <antris> did you tell them about automated software testing? ;)
07:39:12 <hiptobecubic> tdammers, they sound like a reasonable oop shop to me
07:39:16 <tdammers> yeah
07:39:21 <Yuu_chan> When the vacancy isn't really what you need, and you can substantiate your words, it would be fun to say "Everything you have here is wrong" just to shatter their viewpoint :)
07:39:21 <hiptobecubic> tdammers, expecting oop and being scared to refactor
07:39:36 <quchen> Refactoring is more boring than dangerous mumble mumble
07:39:45 * hackagebot hpc-coveralls 0.1.0 - Coveralls.io support for Haskell.  http://hackage.haskell.org/package/hpc-coveralls-0.1.0 (killy971)
07:39:47 <quchen> "Did you consider porting everything to Haskell?" :-D
07:39:48 <tdammers> well, specifically, they had mixed up the concepts of a value and a front-end widget
07:40:06 <tdammers> I suggested separating them out and moving the value part out of the front-end part
07:40:17 <hiptobecubic> Yuu_chan, the problem is that it doesn't shatter their viewpoint. It makes you look like you're an inflexible jerk or worse, like you don't know what you're talking about because they don't know anything better
07:40:33 <tdammers> you know, make the proper abstractions and narrow interfaces at the right points
07:40:36 <hiptobecubic> I had an interview at a shop that asked me if i knew about polymorphism
07:40:52 <tdammers> but they didn't see how that would work
07:40:58 <tdammers> maybe I just failed the communication test
07:40:59 <hiptobecubic> I asked them what kind they wanted? And they said "the normal one. there's only one"
07:41:12 <bahamas> tdammers: you hurt their egos
07:41:29 <tdammers> bahamas: no, I honestly believe they thought I was the one who didn't understand and lacked experience
07:41:43 <hiptobecubic> So i explained that oop inheritance does not define all of programming but at that point i think they had decided that i was too inexperienced
07:41:59 <hiptobecubic> Granted, I had also decided that working there was probably not a great idea.
07:42:28 <hiptobecubic> but we certainly weren't on the same page about why i wasn't going to be working there
07:44:11 <tdammers> hiptobecubic: what do you mean? OOP *is* all of programming!
07:44:15 <norman_> @pl \x -> f <$> x
07:44:16 <lambdabot> (f <$>)
07:44:17 <bahamas> tdammers: I'm sure they were offended. if they thought you didn't know what you were talking about, then they were more offended
07:44:29 <tdammers> bahamas: yes, they were definitely offended
07:44:36 <tdammers> at least slightly
07:44:50 <Yuu_chan> hiptobecubic: yeah, some people consider "polymorphism" == "dynamic dispatch" :(
07:45:11 <tdammers> they were also offended when I didn't show the appropriate amount of amazement at their front-end stuff
07:45:13 <bahamas> tdammers: did you mean to do it or was it an accident?
07:45:40 <tdammers> let's say I was being honest, and offending people in the process seemed like acceptable collateral damage
07:45:41 <dmwit> I don't suppose I can make an Iso without depending on Lens, huh?
07:45:54 <dmwit> s/Lens/lens/ I mean
07:46:23 <quchen> dmwit: Iso is just a type synonym, type Iso s t a b = forall p f. (Profunctor p, Functor f) => p a (f b) -> p s (f t)
07:46:39 <dmwit> quchen: Right. Profunctor is my concern.
07:47:09 <prophile> Profunctor doesn't come from lens
07:47:11 <bahamas> tdammers: if you want to persuade people of something, you're more likely to be successful, if you don't offend them
07:47:17 <prophile> it comes from profunctors
07:47:27 <dmwit> ah, okay
07:47:30 <prophile> http://hackage.haskell.org/package/profunctors
07:47:36 <tdammers> bahamas: yeah, but I'm tired of persuading people when I'm plain out right and they're plain out wrong
07:47:52 <Yuu_chan> tdammers: I know that feel :)
07:48:01 <quchen> Is there a tool to print all dependencies (including transitive ones) of a package?
07:48:05 <Yuu_chan> (more like :( )
07:48:06 <tdammers> it's one thing to give solid arguments to support your point, and responding to counter-arguments
07:48:18 <dmwit> quchen: Right now I would also like such a tool. =P
07:48:21 <tdammers> but it's another thing to have people ignore arguments and demand persuasion regardless
07:48:22 <prophile> quchen: I think it got posted on the haskell subreddit very recently
07:48:37 <quchen> prophile: You mean the licence thing? That might work, actually
07:48:53 <tdammers> I simply don't see the point - either you listen to reason, in which case we can have a professional discussion, or you don't, in which case I'm done
07:49:05 <quchen> dmwit: I wish I had had that before casually installing hakyll in a sandbox.
07:49:09 <prophile> cabal-db isn't just restricted to licenses, from my reading of it
07:49:14 <prophile> although I haven't used it, I must confess
07:49:36 <bahamas> tdammers: I know. it's not easy. it's so hard for people to accept that they're wrong
07:49:44 <quchen> dmwit, prophile: http://hackage.haskell.org/package/cabal-db :-)
07:50:04 <quchen> It's for the local DB only, though.
07:50:19 <dmwit> thanks
07:50:26 <tdammers> bahamas: especially when they lack the mental capacity to understand where and why their thinking is wrong
07:50:41 <Yuu_chan> #cognitive-bias
07:51:27 <edwardk> dmwit: many packages make isos an prisms without a lens dep
07:51:31 <edwardk> er and
07:51:54 <tdammers> Yuu_chan: that, too
07:52:02 <prophile> quchen: yurs
07:52:06 <prophile> but it can output pretty graphs
07:52:22 <quchen> .dot files, anyway
07:52:49 <quchen> Oh nevermind, it actually does the GraphViz call itself
07:53:15 <dmwit> It doesn't do the call here. =(
07:53:20 <dmwit> Oh, maybe I don't have GraphViz installed.
07:54:27 <quchen> dmwit, the blog post suggests it does it. I haven't tried it myself. http://tab.snarc.org/posts/haskell/2013-03-13-cabal-db.html
07:54:47 * hackagebot exceptions 0.5 - Extensible optionally-pure exceptions  http://hackage.haskell.org/package/exceptions-0.5 (EdwardKmett)
07:55:24 <prophile> it vends an interesting rats nest for the idris package
07:55:30 <nicoo> ~/sb end
07:55:31 <Yuu_chan> Yay, the chat room is steadily growing
07:55:48 <bahamas> tdammers: sure, but even if they have it, they might have big egos. and a lot of programmers have big egos ("How dare you criticize my creation?")
07:56:33 <Yuu_chan> Here were less than thousand people in average about a year and a half ago
07:57:10 <tdammers> bahamas: yeah, definitely
07:57:10 <bahamas> I just realized that LYAH has funny/weird alts for each picture
07:57:40 <tdammers> especially when you hit some actual sore spots that their ego had carefully and unconsciously swept under the rug
07:57:50 <bahamas> Yuu_chan: there are more people here than in #python
07:57:55 <quchen> Oh, I think cabal-db uses the entire local "cabal update" DB. I assumed it only searched the DB of installed packages. Neat!
07:58:07 <tdammers> and then the first (and often only) reflex is to just reject the criticism just so you don't have to look under that rug
07:58:26 <Redz> why is Monoid in Data. and not in Control. ?
07:58:31 <Yuu_chan> bahamas: I can only hope programmers have to be more open-minded than many other professions
07:59:10 <bahamas> Yuu_chan: you would, but my experience is that programming makes you more sure of yourself. that can bring closed-mindedness
07:59:30 <dmwit> The Alternative instance for ErrorT does not follow the Alternative laws!
07:59:34 <Yuu_chan> bahamas: interesting point
07:59:42 <dmwit> Is this well-known?
07:59:48 * hackagebot tidal 0.3.2 - Pattern language for improvised music  http://hackage.haskell.org/package/tidal-0.3.2 (AlexMcLean)
07:59:56 <bahamas> Redz: because Monoid is out of control :)
08:00:05 <dmwit> (Specifically: Left "foo" <|> empty /= Left "foo".)
08:00:08 <tdammers> bahamas: my theory is that you can get quite far as a programmer despite being closed-minded
08:00:34 <Redz> :D
08:00:35 <tdammers> even though being open-minded makes you a better programmer, the economics of the real world don't reward open-mindedness enough for it to matter
08:01:51 <pavonia> > mempty :: Either a b
08:01:52 <lambdabot>  No instance for (Data.Monoid.Monoid (Data.Either.Either a1 b1))
08:01:53 <lambdabot>    arising from a use of `Data.Monoid.mempty'
08:01:53 <lambdabot>  Possible fix:
08:01:53 <lambdabot>    add an instance declaration for
08:01:53 <lambdabot>    (Data.Monoid.Monoid (Data.Either.Either a1 b1))
08:01:56 <Redz> it depends on the goal. sometimes i wish i wouldnt dream that much. because i get nothing done.
08:02:07 <makalu> "exceptions 0.5 - Extensible optionally-pure exceptions" ← it has no documentation?
08:02:30 <bahamas> tdammers: I agree. you can be closed-minded and still be good at something
08:03:36 <tdammers> bahamas: no, that's not possible! ;)
08:04:49 * hackagebot yesod-core 1.2.10 - Creation of type-safe, RESTful web applications.  http://hackage.haskell.org/package/yesod-core-1.2.10 (MichaelSnoyman)
08:05:40 <nicoo> tdammers: Was it a Java shop ?
08:06:09 <tdammers> nicoo: PHP
08:06:17 <tdammers> nicoo: no wait, PHP + Java
08:06:29 <tdammers> they actually ran PHP on top of Java. Really.
08:06:50 <nicoo> Ewwwwwww
08:06:58 <tdammers> right?
08:07:04 <tdammers> they assured me that "it was fine"
08:07:05 <tdammers> ugh
08:07:27 <nicoo> tdammers: Well, congratulations on flunking the interview
08:07:29 <bahamas> tdammers: and you actually wanted to get a job there?
08:07:38 <tdammers> not after the interviews
08:07:47 <quchen> makalu: I think 'exceptions' is an experimental package. It was announced a couple of months ago, not sure about its current status.
08:07:53 <zq> gaise
08:07:55 <zq> dis is offtopic
08:07:55 <tdammers> I also ditched the recruiter who sent me there shortly after
08:07:59 <zq> haskell-blah
08:08:04 <bahamas> tdammers: ah, so you don't have a problem working with PHP and Java per-se
08:08:12 <tdammers> bahamas: -blah?
08:08:26 <merijn> quchen: Exceptions should be fine
08:08:29 <bahamas> zq: ^
08:08:36 <merijn> quchen: Bunch of big libraries already use it
08:08:50 <merijn> quchen: i.e. pipes-safe and Snoyman is switching Yesod/conduit stuff to it too
08:09:00 <bahamas> there is no #haskell-offtopic
08:09:11 <merijn> bahamas: There is, it's haskell-blah
08:09:14 <zq> bahamas: /j #haskell-blah ; i'm just being a op pet
08:09:25 <makalu> can anyone tell me what's the point of it? It has some kind of monad transformer for throwing exceptions?
08:09:30 <bahamas> ah, really? I thought "blah" stood for something
08:09:38 <supki> makalu: it does have docs, you just have to wait for them to be generated
08:09:57 <merijn> makalu: mtl style transformer stacks
08:10:08 <quchen> merijn: I just looked at the source and recognized a couple of names. Is MonadCatch from that package the "usual" MonadCatch? I may have used that package without knowing it then.
08:10:10 <merijn> makalu: It does have docs, btw but the docs for the latest version haven't been generated yet
08:10:20 <makalu> ok
08:10:24 <merijn> quchen: No, it's a replacement for all the lifted stuff
08:10:34 <merijn> makalu: If you click the 0.4 version you should see the old docs
08:10:36 <quchen> Like lifted-base etc?
08:10:42 <makalu> but why should I use it instead of ErrorT for example?
08:11:21 <merijn> quchen: Not really for lifted-base as that turns all stuff into "MonadIO m => m a"
08:11:21 <quchen> MonadThrow instance: ~ * e SomeException => MonadThrow (Either e)
08:11:22 <quchen> Huh?
08:11:30 <quchen> Source: http://hackage.haskell.org/package/exceptions-0.4/docs/Control-Monad-Catch.html
08:12:04 <merijn> quchen: That's just haddock failing
08:12:11 <merijn> quchen: Source says "instance e ~ SomeException => MonadThrow (Either e) where"
08:12:12 <makalu> ok that page was useful. Thanks.
08:12:59 <quchen> merijn: That makes more sense. But why the constraint, instead of simply saying MonadThrow (Either SomeException)?
08:13:14 <merijn> quchen: No clue
08:13:16 <quchen> Would that be too polymorphic maybe?
08:13:20 <merijn> quchen: Ask Snoyman? he added it :p
08:13:23 <supki> quchen: (much) better inference
08:13:34 <merijn> quchen: oh, probably to avoid FlexibleInstances?
08:13:38 <supki> yes
08:13:41 <merijn> oh, no
08:13:50 <merijn> The file has flexible instances anyway
08:14:27 <quchen> Snoyman isn't on IRC, is he
08:14:39 <Clint> sometimes
08:14:49 * hackagebot ghc-mod 4.0.0 - Happy Haskell Programming  http://hackage.haskell.org/package/ghc-mod-4.0.0 (KazuYamamoto)
08:15:06 <merijn> quchen: Not often
08:16:29 <supki> quchen: equality constraint allows ghc to pick up the instance before knowing e is ectually SomeException
08:16:41 <supki> if it isn't, ghc will error later
08:17:29 <quchen> Could you explain that in a little more detail? Is it related to how (when) constraints kick in in the typechecker?
08:17:39 <quchen> supki: ^
08:19:50 * hackagebot tz 0.0.0.1 - Time zones database and library  http://hackage.haskell.org/package/tz-0.0.0.1 (MihalyBarasz)
08:24:41 <supki> quchen: well, it's related to instance lookup ignoring constraints when searching for instances
08:24:59 <supki> quchen: so what it actually sees is  instance MonadThrow (Either e) where
08:25:09 <supki> and you get the constraint by matching it
08:25:45 <supki> if it were  instance MonadThrow (Either SomeException)  you first need to prove (e ~ SomeException) before matching
08:26:53 <supki> so the result is you have some inference at the cost of some flexibility
08:27:13 <supki> you can have e.g.  MonadThrow (Either ArithException)  anymore
08:27:20 <supki> s/can/can't/
08:27:59 <quchen> supki: That makes sense, thanks.
08:28:18 <macron> supki: I believe GHC would still have to prove that e ~ SomeException.
08:28:30 <macron> supki: so no inference that I can see.
08:28:35 <supki> sure, after instance is matched
08:30:12 <macron> supki: above you said you get some inference. I'm not sure I get the point still. Perhaps an example use case?
08:32:28 <supki> macron: I think the simplest example is  IsString String  instance
08:32:56 <supki> macron: the problem with that is that things like  length "hello"  fail (e.g. in ghci) with -XOverloadedStrings
08:33:51 <supki> macron: if it were  (Char ~ c) => IsString [c]  length "hello"  would work by assuming c is Char
08:46:16 <Galactic> @version
08:46:16 <lambdabot> lambdabot 5.0-int-e
08:46:16 <lambdabot> git clone git://github.com/int-e/lambdabot.git
08:48:40 <bahamas> is there a way to pattern match for different types (list and integer) in the same function?
08:48:52 <quicksilver> how can the same function take lists and integers?
08:48:55 <quicksilver> what type would it have?
08:49:07 <DR6_> Either [Int] Int
08:49:12 <quicksilver> that's one option :)
08:49:24 <DR6_> or make an ADT for it
08:49:44 <DR6_> you can't just pattern match on different types, you have to use a sum type like that
08:49:48 <mwhitfie1d> which in either case would make pattern matching easy, so i don't think that's what he's asking
08:49:57 <bahamas> quicksilver: it can't have just type 'a'?
08:50:01 <bahamas> a -> a
08:50:02 <geekosaur> nope
08:50:03 <DR6_> no
08:50:06 <DR6_>  a
08:50:10 <bahamas> aha
08:50:14 <geekosaur> yu know nothing about what a is, you can't do anything with it
08:50:36 <Athas> It would be nice if Haskell had more convenient syntax for anonymous sum types.
08:50:55 <quicksilver> (Int|Bool) has been suggested, Athas
08:51:08 <geekosaur> if you are approaching haskell from a language where every type descends from some root type and you can just take that root type and discriminate on the real type... haskell doesn't work that way
08:51:27 <quicksilver> case p of (i|) -> "It was a number"; (|b) -> "it was a bool"
08:51:46 <monochrom> that is a nice syntax
08:51:57 <Athas> quicksilver: that is a neat syntax, although it scales badly for larger sums.
08:51:58 <peteretep> If it just had a type 'a', as geekosaur said, you can't do anything with it
08:52:01 <peteretep> Except ... id
08:52:06 <DR6_> how would that work for larger sums?
08:52:11 <peteretep> myID :: a -> a
08:52:12 <mwhitfie1d> more bars
08:52:14 <peteretep> myID = id
08:52:24 <DR6_> for sums of two either is nice enough IMO
08:52:24 <monochrom> case q of (||x|||) -> ... :)
08:52:26 <quicksilver> DR6_: (a||), (|b|), (||c)
08:52:30 <DR6_> I see
08:52:35 <DR6_> that would be nice
08:52:43 <aristid> :D (|||||a||)
08:52:46 <quicksilver> Athas: sure, but arguably you should use named cases for large sums
08:52:48 <bahamas> ok, I'm trying to make a function that will flatten a list with arbitrary depth. In an imperative language I would loop through the items and check the type
08:53:00 <mwhitfie1d> ((|9)a(|3))
08:53:09 <peteretep> bahamas: In Haskell, if it's a list, it's already got a consistent type
08:53:11 <quicksilver> bahamas: step 1: decide what the representation is for a list of arbitrary depth
08:53:23 <bahamas> quicksilver: [a]?
08:53:29 <quicksilver> bahamas: step 2: if you got the type right in step 1 the function pretty much wrote itself
08:53:29 <quchen> (|||||a||) is still nicer than Right (Right (Right (...
08:53:39 <quicksilver> bahamas: no, that's a list of depth 1.
08:53:43 <peteretep> bahamas: That won't work, because all of your 'a' need to be the same type
08:53:45 <monochrom> a list does not have arbitrary depth to begin with, bahamas. the type already nails its depth.
08:53:46 <peteretep> quicksilver: not quite
08:53:49 <quicksilver> a.k.a  a list.
08:54:01 <quicksilver> peteretep: it might be
08:54:09 <Athas> bahamas: so what you want is actually not a list, but a tree?
08:54:10 <quicksilver> which is is close enough to 'it is'.
08:54:28 <peteretep> bahamas: Are you confused?
08:54:29 <bahamas> monochrom: yeah, you made me realize that. in haskell, you can't have [[1,2], [[[3]]]]
08:54:33 <geekosaur> bahamas, that has the same problem as before: you know it is a list but the item type is completely unknown
08:54:34 <bahamas> peteretep: not anymore :)
08:54:36 <peteretep> There you go
08:54:41 <Athas> bahamas: you want the result of performing an in-order traversal of a tree, collecting the elements as you go.
08:54:42 <geekosaur> so all you can do is iterate over them, you can't do anything with them
08:54:43 <monochrom> [Int] has "depth" 1, [[Int]] has "depth" 2, etc. [[Int]] must be like [[1,2,3], [2,3,1]]. you can't even have [[1,2,3], 4].
08:54:49 <peteretep> bahamas: You can define your own list-like thing though
08:54:53 <peteretep> bahamas: which will allow it
08:55:13 <bahamas> Athas: no, I forgot that a list must contain the same type in haskell
08:55:47 <bahamas> tbh, I can't think of any case where you can have lists with arbitrary depth. it was just more of an exercise
08:56:04 <peteretep> bahamas: XML nodes
08:56:12 <quchen> Trees are like lists of arbitrary depth. Still homogeneous, though.
08:56:25 <Kaidelong> is haskell power enough to implement a function that returns the depth of a list?
08:56:28 <Kaidelong> powerful*
08:56:34 <peteretep> Kaidelong: no
08:56:34 <monochrom> no
08:56:35 <ski> bahamas : perhaps s/In an imperative language/In a dynamically typed language/ ?
08:56:41 <identity> I was rather bemused when I wrote some list flattening function in python using isinstanceof(or is it instanceof?) to know if I had to recurse further
08:56:46 <identity> it is madness
08:56:55 * ski nods
08:56:59 <bahamas> ski: you're probably right. I don't have enough experience with static languages to say
08:57:09 <DR6_> for that you need a type that supports lists with arbitrary depth
08:57:17 <peteretep> DR6_: So, a tree? :)
08:57:20 <Athas> identity: that is how you do it in the untyped lambda calculus, too.
08:57:21 <DR6_> yes
08:57:29 <DR6_> either that or [[[[a]]]]
08:57:32 <mwhitfie1d> yeah i was gonna say, you can get the height of a tree, isn't that the same thing?
08:57:33 <identity> Athas: such sorcery is still beyond me, unfortunately
08:57:38 <DR6_> at which point you don't need any function
08:57:39 <identity> but I shall conquer it
08:58:09 <ski> bahamas : the point is that in statically typed languages, types aren't really to be thought of as things you can *check*. you can check "tags", which in Haskell correspond to the data constructors of some given algebraic data type
08:58:12 <identity> i'm not sure we have a class that teaches it. I forgot to ask one of my professors
08:58:16 <Kaidelong> mwhitfie1d: it's not really the same thing, the tree data structure puts more information at the value level
08:58:16 <DR6_> mwhitfie1d: yes, only then you don't call it a list
08:58:24 <Kaidelong> if you were responding to me, anyway
08:58:34 <Athas> identity: it's not too bad.  I mean, there's nothing inherently crazy about dynamic typing when used carefully, it's just harder to get things right.
08:58:44 <peteretep> Kaidelong: Is there a single tree data structure?
08:58:52 <identity> Athas: yes. It's doesn't hold your hand as much, I know
08:58:53 <ski> bahamas : so, you can check whether a value of type `Maybe Foo' is of shape `Nothing' or of shape `Just x' (for some value `x' of type `Foo')
08:59:12 <Kaidelong> I'm assuming he means data Tree = Leaf | Tree [Tree a]
08:59:18 <Kaidelong> Leaf a *
08:59:22 <identity> Athas: but you won't get me to say dynamic typing >= static typing. I will always want the latter, and I have always wanted the latter, even when writing python
08:59:24 <DR6_> and Tree a *
08:59:32 <identity> I just feel like I'm using glue and duct tape when I'm writing python
08:59:52 * peteretep snarky comment about Python
08:59:53 <ski> bahamas : but you can't check whether something is of shape `Nothing' or `Right y', since the two types of those shapes are not consistent with each other -- it conceptually doesn't make sense to try to compare values from one type with values from another
08:59:59 <Athas> identity: sure, except that there are some rare cases where static typing is not helpful.  I prefer it as well for most tasks.
09:00:04 <mwhitfie1d> yeah i can only write python heavily TDD anymore, or I feel like I'm building a house of cards
09:00:05 <monochrom> harder to get right = closer to needing a mad scientist to get right = more madness
09:00:12 <nicoo> Athas: Well, it makes it harder to compile efficiently (esp. if you want to have dynamic dispatch)
09:00:22 <bahamas> ski: yeah, that's something I'm still getting used to, although I'm not checking types in Python either in general, because it's against duck-typing
09:00:24 <Athas> identity: and specifically, when you are writing the "glue and duct tape" between systems, that is when dynamic typing can be useful!  For example, it is a good fit for Erlang.
09:00:32 <ski> bahamas : in terms of implementation, this means that a compiler is *allowed* to represent e.g. `Just x' and `Right x' in the same way, because there conceptually isn't a way to compare them anyway
09:00:41 <indigo> identity: If Python is glue and duct tape, then what is PHP? ;)
09:00:52 <Kaidelong> a hammer with a nail remover on both ends
09:00:53 <identity> It seems like I can't help but mention how I dislike dynamic typing in specifically python every time I'm in here
09:01:00 <Athas> indigo: the spit and mud that swallows use for building their nests.
09:01:02 <pdpi> indigo: A perl script gone rogue?
09:01:06 <identity> Athas: I don't know any erlang to be honest
09:01:09 <dhrosa> http://blog.codinghorror.com/content/images/uploads/2012/06/6a0120a85dcdae970b017742d249d5970d-800wi.jpg
09:01:10 <bahamas> identity: at least python has strong typing
09:01:10 <pdpi> literally, even.
09:01:20 <indigo> Hehe.
09:01:25 <pdpi> bahamas: how is duck typing "strong"?
09:01:27 <Athas> identity: at least Python does not perform implicit type casts behind your back, like PHP.  *That* is where sanity breaks down.
09:01:32 <ski> bahamas : *nod* -- "duck-typing" here sortof corresponds to "structural typing" for objects/records in a statically typed language (e.g. as in OCaml)
09:01:59 <identity> indigo: I guess PHP must be like being locked in a dark room by a SAW-inspired maniac that instructs you to build something using your own feces as glue
09:02:02 <nicoo> ski: Yup. (OCaml only does it for objects)
09:02:09 <identity> Athas: yes, true
09:02:10 <ski> (yes)
09:02:11 <Fuuzetsu> I want to perform (a -> Maybe b) upon [a] and I want to get out (Just [b]) iff I get Just result for every element, what's a good way to do it?
09:02:20 <identity> like javascript, if I understand all the whole equivalence debacle
09:02:25 <Fuuzetsu> Well, consider a case with [Maybe b] and I want Maybe [b]
09:02:32 <dwcook> @type sequence
09:02:33 <lambdabot> Monad m => [m a] -> m [a]
09:02:42 <bartavelle> or mapM
09:03:01 <Fuuzetsu> oh, for some weird reason I imagined sequence had a different type… I knew the answer all along ;P
09:03:01 <indigo> identity: Sounds about right.
09:03:02 <dwcook> Or yeah, mapM is just map and sequence anyway
09:03:06 <dwcook> @type mapM
09:03:07 <lambdabot> Monad m => (a -> m b) -> [a] -> m [b]
09:03:11 <Fuuzetsu> awesome
09:03:22 <identity> @src mapM
09:03:22 <lambdabot> mapM f as = sequence (map f as)
09:03:24 <identity> yeah
09:03:32 <bahamas> pdpi: hm, I haven't considered the connection between duck typing and strong typing.
09:03:36 <ski> bahamas : what matters for a structural type system for records is what fields the record has, and what types the fields have
09:03:56 <identity> Athas: but you are right, actually. Hadn't thought about it like that. At least it *breaks*
09:04:11 <Athas> The terms "weak typing" and "strong typing" do not have a widely accepted definition, so they're not useful.
09:04:17 <identity> and doesn't just continue on marching until some ridiculous implicit type conversion breaks something farther down in the pipeline
09:04:33 <Athas> I recommend "static typing", "dynamic typing", (sometimes) "duck typing" and "stupid typing" for things like PHP.
09:04:51 <Athas> Stupid typing is any dynamically typed language that performs implicit type conversions.
09:04:55 * hackagebot tostring 0.2.0.1 - The ToString class  http://hackage.haskell.org/package/tostring-0.2.0.1 (ErikHesselink)
09:05:07 <ski> bahamas : what matters for a structural type system for objects is what methods the object has, and what argument and result types those objects have -- iow, how they "behave", generally speaking -- so as long as an object responds to the required messages, using the correct interface (at least accepts arguments of the specified types, and at least generates a result of the specified type), all is fine
09:05:15 <nicoo> (Also, “dynamic” typing is static with a single type :þ)
09:05:17 <identity> "stupid typing" is what lerdorf did when he wrote php
09:05:32 <bahamas> pdpi: at least duck typing requires explicit implementation, while weak typing doesn't
09:05:35 <identity> or maybe "typing stupid"
09:05:47 <ski> nicoo : yes, "typing" in the terms "static typing" and "dynamic typing" means different things ;)
09:06:06 <nicoo> ski: I know. Hence the smiley face and the parenthesis :>
09:06:42 <nicoo> identity: It turns out that even comparing hashes is tricky in PHP (as in `==` is tricky, even on strings)
09:07:07 <pdpi> bahamas: at least Python doesn't seem to have as much of a "pass random hashes around" culture as javascript does
09:07:20 <indigo> Which is why you always use === in PHP.
09:07:28 <indigo> Or, you should.
09:07:30 <Athas> nicoo: you just always have to use '==='.  It's not too bad.  Like having a self-destruct button in an airplane cockpit.  You just don't press it and it doesn't matter, see?
09:07:44 <pdpi> I've lost count of how many times I've been bitten in the arse by having JS codebases completely lose track of objects' structure.
09:07:54 <nicoo> Athas: Yeah, sure :>
09:07:55 <dmwit> > let notEmpty = ErrorT (Identity (Left "foo")) in (notEmpty <|> empty) == notEmpty
09:07:56 <lambdabot>  False
09:08:01 <dmwit> =(
09:08:10 * nicoo is happy not to have to touch PHP in any way, shape or form.
09:08:20 <indigo> nicoo: Sadly, I am a PHP dev by day. :(
09:08:45 <nicoo> indigo: Ouch :(
09:08:55 <pdpi> indigo: at least most people recognise that PHP is crap. I'm stuck with the node.js circle jerk.
09:08:55 <bahamas> pdpi: the anonymity is what annoyed me the most when working with js. all those backbone models and views didn't have a freaking name
09:08:59 <indigo> It's all right. The other developers don't understand my obsession with types. :P
09:09:09 <identity> nicoo: Hah, that's great.
09:09:31 <pdpi> bahamas: haha yeah.
09:09:54 <indigo> pdpi: The node.js circlejerk is strong here, as well.
09:09:56 * hackagebot bytestring-show 0.3.5.6 - Efficient conversion of values into readable byte strings.  http://hackage.haskell.org/package/bytestring-show-0.3.5.6 (DanDoel)
09:10:05 <identity> I have never had to touch PHP in any real sense so far and I will continue to actively avoid it
09:10:13 <pdpi> indigo: eh. Node.js is awesome. Because events.
09:10:30 <pdpi> >.<
09:10:32 <indigo> :P
09:11:46 <bahamas> I realized recently that async programming has some similarity to functional programming, i.e. you need to keep passing a value until you're done with it
09:12:33 <Fuuzetsu> didn't someone propose a function “foo f g xs = g . f . g $ xs” for standard lib few months ago? Anything happened with that?
09:12:55 <ski> bahamas : do you mean passing stuff as parameters (and sometimes returned as results as well), as opposed to using (more) global (scope) variables ?
09:12:59 <Fuuzetsu> I need to do reverse . bar . reverse ;(
09:13:14 <dmwit> "conjugate" is a better name than "foo". ;-)
09:13:30 <identity> I think we should just name it foo
09:13:33 <dmwit> well
09:13:38 <dmwit> It's not quite conjugation, I guess.
09:13:39 <monochrom> but conjugate is not g.f.g. conjugate is g_inverse.f.g or the other way
09:13:43 <dmwit> yeah
09:13:53 <monochrom> it so happens that reverse is self-inverse
09:13:56 <indigo> What do you guys use for writing REST APIs in Haskell? I've written one in Yesod and am going to try plain WAI + wai-routes next.
09:13:59 * dmwit nods agreeably
09:14:01 <identity> so 'conjugation' is a term in computer science?
09:14:05 <dmwit> group theory
09:14:07 <bahamas> ski: yup. when I used a scraping framework called scrapy, I was retrieving some info, passing it on with the next request until I was done with that item
09:14:09 <monochrom> therefore foo is bound to be of limited utility
09:14:10 <identity> or that
09:14:13 <bahamas> if that makes sense
09:14:36 <quicksilver> "ala" is related
09:14:40 <quicksilver> http://hackage.haskell.org/package/newtype-0.1/docs/Control-Newtype.html
09:14:50 <ski> @let infixr 1 ~>; (~>) :: (a1 -> a0) -> (b0 -> b1) -> ((a0 -> b0) -> (a1 -> b1)); (f ~> h) g = h . g . f
09:14:51 <lambdabot>  Defined.
09:14:59 <ski> @type reverse ~> reverse
09:14:59 <lambdabot> ([a] -> [a1]) -> [a] -> [a1]
09:15:10 <identity> I'm taking an abstract algebra class next year -- I hope to achieve kmett-ish nirvana
09:15:11 <monochrom> may as well just ask for "fooo f xs = (reverse . f . reverse) xs"
09:15:13 <ski> @type (~>) `join` reverse
09:15:14 <lambdabot> ([a] -> [a]) -> [a] -> [a]
09:15:56 <Fuuzetsu> any ideas how to improve this: http://lpaste.net/102074 ; I don't like how it looks
09:16:05 <bartavelle> Fuuzetsu, reversed %~ foo
09:16:12 <ski> bahamas : *nod*
09:16:13 <Fuuzetsu> with standard libs*
09:17:04 <bartavelle> heh :)
09:17:30 <ski> bahamas : perhaps in some such cases, one could use non-local variables (as with closures), instead ..
09:17:36 <Fuuzetsu> bartavelle: Well, if you can convince GHC guys to ship with lens then I'll consider it ;P
09:17:57 <bartavelle> Fuuzetsu, there are hardly any dependencies to lens, so that should be easy :p
09:18:09 <identity> Fuuzetsu: can't you just do something like "map (dropWhile (== ' '))" ?
09:18:17 <quchen> bartavelle: Correction, there are hardly any new dependencies after you install lens ;-)
09:18:23 <Fuuzetsu> not exactly what I call hardly any http://fuuzetsu.co.uk/images/1396282591.png
09:18:24 <identity> quchen: hah!
09:18:25 <bartavelle> hehe
09:19:06 <Fuuzetsu> identity: no because I only want to drop a single space iff there is one on every line (or if the line is empty then that's fine too)
09:19:24 <Fuuzetsu> I don't want to blindly strip whitespace from each line
09:19:29 <identity> ah.
09:19:50 <quchen> So you basically want an un-indent function?
09:20:15 <Fuuzetsu> eh, sure, for 1 space indent
09:20:24 <Fuuzetsu> (and drop a newline if it results in 2 trailing ones)
09:20:43 <Fuuzetsu> oh, I could intercalate with '\n' to spare myself that reverse
09:20:47 <Athas> Why does lens depend on a JSON parser?
09:20:52 <Fuuzetsu> :t intercalate
09:20:53 <lambdabot> [a] -> [[a]] -> [a]
09:21:02 <Fuuzetsu> :t intersperse
09:21:02 <lambdabot> a -> [a] -> [a]
09:21:04 <Fuuzetsu> ah
09:21:12 <bartavelle> Athas, http://hackage.haskell.org/package/lens-4.1.2/docs/Data-Aeson-Lens.html
09:21:17 <identity> Athas: I think the who.. yeah, what he said.
09:21:25 <identity> it comes with lenses for aeson
09:21:30 <bartavelle> (it's really handy)
09:22:13 <quchen> Hm, lens' dependency tree isn't actually that large: http://i.imgur.com/8UgVZ3l.png
09:22:37 <haasn> quchen: my irony detector is broken
09:22:47 <monochrom> heh
09:22:49 <quchen> haasn: No irony intended
09:22:57 <fizruk> quchen: how did you do that?
09:23:08 <quchen> It's big, but not nearly as enormous as I had expected.
09:23:15 <quchen> fizruk: cabal-db graph lens --hide base | dot -Tpng > ~/temp/lens-dep.png
09:23:22 <quchen> @hackage cabal-db
09:23:23 <lambdabot> http://hackage.haskell.org/package/cabal-db
09:23:24 <klugez> I'd like to see a similar graph for yesod.
09:23:30 <quchen> klugez: One minute
09:23:31 <fizruk> quchen: thanks!
09:23:41 <identity> wow.
09:24:02 <identity> What is cabal-db?
09:24:44 <quchen> identity: http://tab.snarc.org/posts/haskell/2013-03-13-cabal-db.html
09:24:49 <haasn> quchen: great, then it looks like there should be no problems shipping lens with GHC 7.10
09:24:59 <identity> I also had no idea about dot either.
09:25:02 <identity> that sounds really cool
09:25:09 <quchen> One moment, the PNG graph generated for Yesod is 9 megs. :-D
09:25:10 <zerokarmaleft> dot is from graphviz
09:25:21 <bartavelle> and graphviz is also very handy
09:25:24 <identity> quchen: wat.
09:25:44 <quchen> This is going to look as awful as my GEB-MIU-Puzzle graphs at https://github.com/quchen/geb-miu-puzzle/
09:26:02 <quchen> Imgur resizes my picture. Hold on, personal webspace time.
09:26:09 <zerokarmaleft> heh
09:26:57 <identity> okay, so cabal-db is really cool
09:27:51 <quchen> 22k*2k PNG, 9 meg, Yesod dependencies: http://stupidname.org/files/temp/temp_2014_03/yesod-dep.png
09:28:36 <indigo> quchen: Holy crap.
09:28:42 <k00mi> holy cow
09:29:06 <monochrom> I don't even dare to download it :)
09:29:07 <identity> mother of god
09:29:20 <identity> in the name of all that is holy
09:29:43 <dv-> finally a use for my 22k monitor
09:29:43 <indigo> Then again, Yesod does do a lot of stuff for you.
09:29:55 <identity> dv-: i'm jelly.
09:29:58 * hackagebot uri-encode 1.5.0.1 - Unicode aware uri-encoding.  http://hackage.haskell.org/package/uri-encode-1.5.0.1 (ErikHesselink)
09:30:06 <identity> indigo: yes. apparently everything.
09:30:18 <bartavelle> quchen, you should have exported it as svg: http://www.banquise.net/bin/lpuppet.svg
09:31:02 <ziman> I'd probably prune the edges, doing a BFS from the root and keeping only the forward ones or so
09:31:31 <indigo> identity: I think everyone is more for a libraries approach, but I think a framework that has everything is a more secure approach.
09:31:43 <quchen> bartavelle: Good idea.
09:32:29 <identity> indigo: Yeah, I don't mind really. but I am definitely surprised.
09:32:41 <klugez> http://koti.kapsi.fi/kluge/yesod-platform.png - The graph for yesod-platform doesn't seem to work in my Firefox. It's 32k x 2k PNG. 14 MB.
09:33:07 <quchen> bartavelle: On the other hand, SVG doesn't really show the magnitude of the graph. Nothing says "huge dep tree" like a 22k pixel wide PNG.
09:33:07 <identity> quchen: Is there a way to use cabal-db to find out which package has the most dependencies? that is, if it isn't just yesod
09:33:17 <bartavelle> quchen, true :)
09:33:18 <quchen> No idea.
09:33:47 <Kaidelong> klugez: I hope you are not planning to actually use that dependency graph for anything
09:34:00 <quchen> Hmm, apparently cabal-db breaks when using cabal-install 1.18.0.3.
09:34:15 <monochrom> use it to test 32k monitors :)
09:34:39 <klugez> http://koti.kapsi.fi/kluge/yesod-platform.svg - SVG is much better.
09:35:16 <klugez> Kaidelong: I was just curious how big it would be.
09:35:20 <Kaidelong> there has to be a better way to represent this information
09:35:46 <klugez> I can see how cabal might occasionally fail to find a good way to satisfy it. These images don't even have the version ranges.
09:35:49 <quchen> The information represented is "giant". I think it's a good representation.
09:35:50 <simukis_> klugez: firefox has a bug and cannot render images above 2¹⁵-1.
09:36:09 <simukis_> klugez: above that in pixels in any dimension.
09:36:46 <indigo> identity: I actually found Yesod to be surprisingly modular.
09:36:47 <Kaidelong> quchen: well simple thing, almost everything depends on base, it may be possible to factor that out somehow by making the big tree roots into something like a venn diagram
09:37:07 <quchen> Kaidelong: You can `--hide base` in cabal-db
09:37:08 <Hodapp> all I see is: 2^5 - 1
09:37:19 <Hodapp> what's the proper exponent on that 2?
09:37:21 <zerokarmaleft> http://ogirardot.wordpress.com/2013/01/05/state-of-the-pythonpypi-dependency-graph/ <= something like this would be cool for hackage
09:37:23 <identity> Hodapp: 2^15 - 1
09:37:32 <Hodapp> ahh, okay
09:38:58 <angerman> is there an introduction on how to split a haskell project into different files?
09:40:13 <klugez> indigo, identity: Doing a lot and being modular probably is the cause. I mean, they *could* just make one huge yesod package and then the dependency graph would be really clean.
09:40:38 <klugez> But then you'd be screwed if you only wanted to use one part of it.
09:40:55 <SwashBuckla> Elm (based on Haskell) question: https://groups.google.com/forum/#!topic/elm-discuss/aIUK_MiW3yo
09:42:10 <SwashBuckla> #elm is kinda inactive at the moment and I was wondering if anyone knew a solution
09:43:04 <bartavelle> can someone tell me what does that line do ? https://github.com/vincenthz/cabal-db/blob/master/Src/Main.hs#L207
09:43:10 <bartavelle> how does the pattern matching work ?
09:43:26 <quchen> bartavelle: ViewPatterns extension
09:43:29 <bartavelle> ViewPatterns
09:43:32 <bartavelle> ok
09:43:46 <bartavelle> how should I track the meaning of this pattern ?
09:43:58 <DR6_> basically it pattern matches on the result of the function on the left of the arrow
09:44:19 <peteretep> Perl has a set of Acme::MetaSyntactic modules, which contain long lists of useful names
09:44:30 <peteretep> Like Ben and Jerry icecream flavours
09:44:36 <peteretep> Anything similar for Haskell?
09:44:43 <bartavelle> DR6_, si "hidden" is equal to "map PackageName (the first argument to the CmdGraph constructor" ?
09:45:03 <DR6_> yes
09:45:07 <bartavelle> thanks
09:50:18 <aristid> is there an aeson package somewhere for GHC.Generics support? i guess the alternative right now is pretty much just TH
09:50:26 <tromp__> > 1-exp(-1)
09:50:27 <lambdabot>  0.6321205588285577
09:51:52 <aristid> oh it is in Data.Aeson directly
09:56:36 <rusk101> Hello every1
09:57:13 <ski> hello rusk101
09:57:14 <bartavelle> identity, yesod-platform is only #8
09:57:28 <identity> bartavelle: wow. who is at the top?
09:57:33 <identity> how did you come by that, btw?
09:57:51 <bartavelle> modified haskell-db a little bit
09:57:54 <Fuuzetsu> what's a good way to split a list on \n that actually splits on every \n… for example
09:57:55 <bartavelle> that might be wrong though :)
09:57:58 <Fuuzetsu> > lines "hello\n"
09:57:59 <lambdabot>  ["hello"]
09:58:00 <Fuuzetsu> > lines "hello"
09:58:01 <lambdabot>  ["hello"]
09:58:02 <Fuuzetsu> are the same
09:58:04 <bartavelle> lemme write a paste
09:58:12 <Fuuzetsu> I'd like the first one to be ["hello", ""]
09:58:22 <Fuuzetsu> I can't use the split package.
09:58:27 <tromp__> > 0.4^4
09:58:28 <lambdabot>  2.560000000000001e-2
09:58:50 <bartavelle> identity, http://lpaste.net/102075
09:59:00 <Fuuzetsu> > groupBy (/= '\n') "hello\n"
09:59:01 <lambdabot>  Couldn't match type `GHC.Types.Bool'
09:59:02 <lambdabot>                with `GHC.Types.Char -> GHC.Types.Bool'
09:59:02 <lambdabot>  Expected type: GHC.Types.Char -> GHC.Types.Char -> GHC.Types.Bool
09:59:02 <lambdabot>    Actual type: GHC.Types.Char -> GHC.Types.Bool
09:59:06 <Fuuzetsu> :t groupBy
09:59:06 <lambdabot> (a -> a -> Bool) -> [a] -> [[a]]
09:59:08 <bartavelle> I don't understand how git-annex could "win" this
09:59:20 <bartavelle> oh wow
09:59:33 <Fuuzetsu> :t partition
09:59:33 <lambdabot> (a -> Bool) -> [a] -> ([a], [a])
09:59:38 <bartavelle> it's probably doing something wrong with "or"
09:59:45 <klugez> bartavelle: git-annex uses yesod?
09:59:56 <identity> bartavelle: aaah, that is really neat
09:59:57 <rusk101> Can anybody take a look at my error I'm getting. This is for a composition of two functions. Write up is here: http://lpaste.net/102076
10:00:27 <bartavelle> klugez, http://hackage.haskell.org/package/git-annex  I think there might be a bug with my program ;)
10:01:08 <dhrosa> rusk101: pairs returns a list, but your function trries to do (blah):[pairs ... ]
10:01:27 <monochrom> rusk101, is it simply [h]:[t] vs h:t? I think you want h:t there.
10:01:39 <monochrom> and not even h:[t]
10:01:44 <bartavelle> (well, with my hack actually)
10:01:49 <dhrosa> you're trying to append a [[a]] to an [a]
10:02:23 <rusk101> ahhh. Thanks!
10:02:54 <ski> > (unfoldr (\s -> case s of "" -> Nothing; '\n':s -> Just (span ('\n' /=) s)) . ('\n' :)) "class Monad m where\nreturn and Kleisli compose\nmust form a monoid"  -- Fuuzetsu, one variant
10:02:55 <lambdabot>  ["class Monad m where","return and Kleisli compose","must form a monoid"]
10:03:32 <klugez> bartavelle: Yeah. It seems that it doesn't have yesod as a dependency, because I thought the web GUI part of it was written with yesod. Maybe it's in some other package.
10:03:49 <Fuuzetsu> You'd really think that basic splitting functions would be in base…
10:04:32 <aristid> Fuuzetsu: you would?
10:04:32 <quchen> Fuuzetsu: Base is what you need for GHC. The Platform has Data.List.Split though.
10:05:58 <Fuuzetsu> quchen: I'm stuck with only what's in GHC.
10:06:05 <rusk101> How is my function still non-exhaustive? http://lpaste.net/102076
10:06:12 <Fuuzetsu> I sure love re-implementing stuff.
10:06:28 <Fuuzetsu> rusk101: you're not showing the warning
10:06:43 <Fuuzetsu> GHC will warn you about non-exhaustive matches
10:06:45 <glguy> rusk101: lookup i []
10:07:03 <Fuuzetsu> heer lookup fails with []
10:07:05 <Fuuzetsu> here*
10:07:07 <kwantam> rusk101 imagine that bs and xs have different lengths
10:07:15 <kwantam> oops, beaten
10:09:28 <rusk101> so i should declare what lookup i [] is?
10:10:03 <rusk101> because right now lookup 4 [] = Nothing
10:10:14 <Fuuzetsu> ski: awesome, that works for me
10:13:16 <Fuuzetsu> ski: improved with LambdaCase (I didn't know it would work like that but it did!)
10:14:49 <quchen> Oh, the last critical RC2 bug seems to be gone
10:15:13 <quchen> I expect at least one release message on the mailing lists tomorrow then :-þ
10:16:29 <quchen> Oh, it was just demoted from highest to high priority. #8870 should be it.
10:17:03 <ski> Fuuzetsu : np
10:17:31 <Fuuzetsu> uh, I'm having a weird non-exhaustive match warning http://lpaste.net/102080 (ski, your function ;))
10:18:10 <glguy> Fuuzetsu: you only handle '\n':_ and "" but not any other x:xs
10:18:23 <Fuuzetsu> Ah!
10:18:35 * Fuuzetsu moves "" -> Nothing down to _ -> Nothing
10:18:49 <Fuuzetsu> bad warning message
10:19:48 <rusk101> Still dont get my bug http://lpaste.net/102076 I understand its in the lookup function but my output of lookup 4 [] = "Nothing"
10:20:27 <Fuuzetsu> it can't be considering you don't have a pattern for []
10:21:28 <rusk101> *Main> lookup 4 [] Nothing
10:21:44 <Fuuzetsu> what?
10:21:49 <rusk101> oh. its a built in function
10:21:54 <gnuvince> I have a question about the Fix datatype from Tekmo's free monad article (http://www.haskellforall.com/2012/06/you-could-have-invented-free-monads.html); why does Fix Done compile?  looking at kinds, Fix is of kind (* -> *) -> * and Toy is of kind * -> * -> *.
10:22:00 <rusk101> :t lookup
10:22:01 <lambdabot> Eq a => a -> [(a, b)] -> Maybe b
10:22:10 <Fuuzetsu> you can't even refer to your own lookup from GHCi because it's in the inner scope of apply
10:22:38 <rusk101> oh ok
10:22:46 <Fuuzetsu> the ‘lookup’ in ‘apply’ is what fails, not the ‘lookup’ you're playing with in GHCi
10:23:40 <rusk101> So what should I make my lookup i [] equal to? It needs to output type Int
10:24:50 <peteretep> I feel like conceptually I should be able to do this:
10:24:51 <peteretep> (next $ mkStdGen 5) >>= next
10:24:53 <peteretep> But I can't
10:25:11 <peteretep> Any pointers?
10:25:25 <dmwit> > Left "foo" <|> empty
10:25:26 <lambdabot>  Left ""
10:25:31 <dmwit> Oh, that's an easier example.
10:25:36 <dmwit> Thanks, haddock!
10:26:57 <dmwit> peteretep: MonadRandom
10:27:01 <glguy> peteretep: What might you expect that code to do?
10:27:06 <glguy> @type state next
10:27:07 <lambdabot> (MonadState s m, RandomGen s) => m Int
10:27:19 <peteretep> dmwit: ah ha
10:27:26 * peteretep defines himself a bind function first, to play
10:27:35 <dmwit> http://hackage.haskell.org/package/MonadRandom
10:27:40 <glguy> @type replicateM 2 (state next)
10:27:41 <lambdabot> (MonadState s m, RandomGen s) => m [Int]
10:27:53 <dmwit> And yes, implementing it yourself is a good way to become Enlightened.
10:28:41 <peteretep> hrm
10:28:48 <peteretep> >>= is wrong, I'd want >>
10:28:57 <dmwit> (>>) is definable in terms of (>>=)
10:29:08 <peteretep> Because I'm throwing away my initial non-gen value
10:29:11 <dmwit> But perhaps your problem is that you're trying to keep the Int.
10:29:12 <dmwit> Don't.
10:29:17 <peteretep> there we go :)
10:29:27 <dmwit> MyFancyType g a = g -> (a, g)
10:29:37 <dmwit> and then next :: RandomGen g => MyFancyType g Int
10:30:18 <peteretep> rbind (g, _) f = f g
10:30:49 <peteretep> doh, wrong way around
10:31:03 <dmwit> That looks funny to me. I would expect both arguments to bind to be "functions".
10:31:34 <dmwit> e.g. rbind :: (g -> (a, g)) -> (a -> g -> (b, g)) -> (g -> (b, g))
10:31:55 <dmwit> e.g. rbind :: (g -> (a, g))    ->    (a -> g -> (b, g))    ->    (g -> (b, g)) -- more space to aid your visual cortex's parser
10:31:55 <peteretep> rbind :: (Int, g) -> (g -> (Int, g)) -> (Int, g)
10:31:55 <peteretep> rbind (_, g) f = f g
10:32:08 <peteretep> hrm
10:32:19 <peteretep> :t (>>=)
10:32:20 <lambdabot> Monad m => m a -> (a -> m b) -> m b
10:32:37 <peteretep> = rbind :: (Int, g) -> (g -> (Int, g)) -> (Int, g)
10:32:58 <dmwit> Instead of (next foo >>= blah), consider what would happen if you were to think about (next >>= \v -> blah).
10:34:23 <dmwit> peteretep: You can try going forward with what you're suggesting. But I very much doubt that throwing away all your randomly-generated results is really what you wnat.
10:34:30 <dmwit> And that's what the rbind you proposed is doing.
10:34:37 <peteretep> sure
10:46:54 <peteretep> dmwit: ah ha, thing I've managed that
10:48:43 <Fuuzetsu> how can I turn off MINIMAL pragma warnings in a module?
10:49:25 <dmwit> I don't suppose there's a language pragma that implies Derive{DataTypeable,Foldable,Functor,Traversable}...?
10:49:35 <peteretep> (>>==) :: (g -> (a, g)) -> (a -> g -> (b, g)) -> (g -> (b, g))
10:49:36 <peteretep> (>>==) f c = uncurry c . f
10:50:05 <dmwit> cool implementation!
10:50:09 * hackagebot hint-server 1.3.1 - A server process that runs hint.  http://hackage.haskell.org/package/hint-server-1.3.1 (CorentinDupont)
10:50:28 <monochrom> there isn't
10:50:42 <dmwit> peteretep: Now can you write returnn :: a -> (g -> (a, g))? (should be easy)
10:51:02 <dmwit> monochrom: bummer, but thanks for confirmation
10:51:55 <peteretep> returnn = (,)
10:52:04 <dmwit> right!
10:52:14 <dmwit> Congratulations, you just invented the State monad.
10:52:15 <peteretep> Now I need to work out how to stick these together
10:52:19 <peteretep> hahaha, woo!
11:00:00 <kazu> Hello
11:00:08 <jle`> hello kazu
11:00:10 * hackagebot eprocess 1.6.1 - *Very* basic Erlang-like process support for Haskell  http://hackage.haskell.org/package/eprocess-1.6.1 (CorentinDupont)
11:00:33 <joseph07> I often find myself with a list [(a -> a)] that I want to compose and apply
11:00:54 <jle`> joseph07: you can foldr (.) id
11:00:55 <joseph07> to the effect of appEndo . mconcat . fmap Endo
11:01:00 <jle`> and use Endo too
11:01:02 <joseph07> jle`: or that
11:01:03 <jle`> spoke too sooon
11:01:16 <jle`> there's also that foldMap
11:01:34 <joseph07> :t foldMap
11:01:34 <lambdabot> (Foldable t, Monoid m) => (a -> m) -> t a -> m
11:01:43 <jle`> you still have to appEndo at the end tho
11:01:47 <jle`> ooh that rhymes
11:02:03 <supki> :t ala Endo foldMap
11:02:04 <lambdabot> Foldable t => t (a -> a) -> a -> a
11:02:22 <jle`> :o
11:04:59 <joseph07> :i ala
11:05:09 <skypers> hey, quick question: I have a function of the form w a -> w b -> w c -> … -> w r and a function (w a -> b) -> w (a -> b). I want to reduce the w a -> w b -> w c… chain into w (a -> b -> c -> … -> r) ; any idea?
11:05:12 <joseph07> :t ala
11:05:13 <lambdabot> Wrapped s s a a => (s -> a) -> ((s -> a) -> e -> a) -> e -> s
11:05:25 <skypers> I think it’s something like recursive composition using a typeclass
11:05:28 <skypers> but I don’t see how
11:05:49 <skypers> the function is (w a -> w b) -> w (a -> b), I mistaken
11:07:45 <dmwit> Is w a comonad?
11:07:45 <glguy> joseph07: http://hackage.haskell.org/package/lens-4.1.2/docs/Control-Lens-Wrapped.html#v:ala
11:07:59 <skypers> dmwit: I’d love it to be, but unfortunaly, no :(
11:08:09 <skypers> I tried to make it a comonad
11:08:10 <skypers> but I can’t
11:08:16 <skypers> since I can’t make it a Functor
11:08:21 <skypers> (it’s actually a GADT)
11:08:32 <joseph07> supki: thanks
11:08:34 <dmwit> It seems unlikely that you'll be able to achieve what you're asking, then.
11:08:47 <dmwit> Since after one step you get w (a -> w b -> w c -> ... -> w r)
11:08:56 <dmwit> At which point you're a bit stuck if you can't even fmap.
11:09:17 <joseph07> glguy: thanks
11:09:21 <skypers> dmwit: hm
11:09:21 <awestroke> skypers: if w is not a functor or even applicative, how would you apply the w (a -> b -> ...) function?
11:09:42 <skypers> awestroke: in the GADT, I have a ctor that embeds unary function
11:09:57 <skypers> Fun :: (E a -> E b) -> E (a -> b)
11:10:02 <skypers> (guess that w is E here)
11:10:24 <skypers> if I pass it a function like E a -> E b -> E b, it doesn’t typecheck
11:10:35 <skypers> then I have to compose the function with Fun
11:10:45 <skypers> which makes it E (a -> b -> b)
11:10:57 <skypers> now for a n-ary function, I have no idea.
11:12:26 <skypers> it’s quite logical, since composing Fun with f and f :: E a -> E b -> E b apply the Fun on (E b -> E b), which is okay, then I get E a -> E (b -> b), and if I reapply Fun on that, I get E (a -> (b -> b))
11:12:31 <skypers> which is E (a -> b ->_b)
11:12:32 <skypers> -_
11:13:06 <peteretep> addRandom (x, g) = uncurry ((,) . (:x)) $ next g
11:13:10 <peteretep> Fun with uncurry!!
11:14:32 <awestroke> :t (<<*>>)
11:14:33 <lambdabot> Not in scope: `<<*>>'
11:14:43 <awestroke> :(
11:14:58 <monochrom> looks like a spaceship!
11:15:13 <yogert> Is using recursion inside a "forever action" bad practice, or have any performance implications? For example http://lpaste.net/2428333646839545856
11:15:39 <monochrom> neither. do what you need.
11:16:14 <yogert> monochrom, was that to me?
11:16:17 <monochrom> yes
11:16:35 <yogert> so you saying that it is perfectly fine?
11:16:37 <awestroke> yogert: I think that's tail call eliminated
11:16:42 <tac> Is there a way to run ghci with all the cabal dependencies for your application in a single command?
11:16:58 <awestroke> wait no
11:17:13 <dcoutts> tac: perhaps you're looking for cabal repl
11:17:15 <monochrom> do what you need for the problem you solve
11:17:31 <tac> dcoutts: hm thnx
11:18:16 <yogert> ha, okay… well there are many ways to achieve the same thing, some better than others...
11:18:23 <awestroke> yogert: You should choose either forever or recursion, I think... I get the feeling you won't release the previous stack frame if it's running a "forever" loop
11:18:26 <cin> it's similar to, but not tail-call eliminated, it's that >> in the IO monad is lazy, so it can evaluate the left hand side and return immediately. the runtime will keep boinging like a TCO trampoline
11:19:36 <awestroke> yogert: http://lpaste.net/2428333646839545856 would this work?
11:20:05 <cin> awestroke, forever is fine performance-wise. it uses constant call stack space
11:20:12 * hackagebot thumbnail-plus 1.0 - Generate thumbnails easily and safely.  http://hackage.haskell.org/package/thumbnail-plus-1.0 (FelipeLessa)
11:20:19 <awestroke> cin: but it enters a new stack-frame with recursion
11:20:28 <awestroke> while keeping the old due to the forever
11:20:36 <cin> awestroke, it doesn't because it's not evaluated strictly.
11:20:47 <cin> forever x = x >> forever x   -- only evaluates x and then returns immediately
11:20:57 <cin> then the runtime forces the thunk again, which forces x and then repeat
11:21:04 <peteretep> I want to create a list of a certain length, whose values I'll throw away
11:21:08 <peteretep> any particular idiom for that?
11:21:25 <dmwit> replicate n ()
11:21:27 <monochrom> replicate 10 ()
11:21:46 <yogert> awestroke: sure, I was just curious what the implications of using forever were. but now im getting two different takes on it : o
11:21:48 <awestroke> cin: doesn't each recursion keep the parent in memory though? Since it isn't done (it's running the forever call)
11:21:55 <peteretep> thanks
11:22:06 <awestroke> yogert: don't listen to me, I'm probably not correct
11:22:43 <yogert> ha okay. so the fact that its lazily evaluated mitigates the problem then
11:22:58 <cin> awestroke, consider lists which are also lazy in the constructor. forever x = x : forever x   -- you can do head (forever 1) and get back 1. similarly, the IO monad runs the action and then *returns* what to do next
11:23:37 <awestroke> cin: I'm going to test it out, sec
11:26:17 <cin> yogert, yup
11:28:36 <awestroke> steadily increasing memory consumption, 5 -> 10 -> 20% and rising
11:28:38 <thaicares> I've been running gitit locally, If I am ready to launch it to a server I have ftp access to... how do I do that?
11:29:18 <awestroke> 40% memory, I think this is definitely leaking
11:29:24 <skypers> is there a way to write a function by specifying its return argument?
11:29:31 <skypers> is it a contravariant function?
11:29:37 <cin> awestroke, what are you testing? forever (return ())?
11:30:13 * hackagebot tidal 0.3.3 - Pattern language for improvised music  http://hackage.haskell.org/package/tidal-0.3.3 (AlexMcLean)
11:30:21 <awestroke> cin: http://lpaste.net/102084
11:30:32 <skypers> like ((->) a b) is a -> b and ((->b) a) is the same thing
11:30:34 <skypers> is it possible?
11:30:55 <cin> awestroke, that's lazy in the addition, and you're doing two infinite loops
11:31:21 <cin> awestroke, you're going to be building up thunks of (0 + 1 + 1 + 1 + 1 + …)
11:31:31 <cin> into a big-ass thunk stack that's never reduced
11:31:35 <awestroke> cin: no, it's evaluated to whnf each print
11:31:47 <ski> skypers : write a function, or write a function type ?
11:32:10 <awestroke> cin: also, the loop structure is very similar to the one presented by yogert
11:32:25 <cin> awestroke, ah, good point
11:32:36 <cin> i think the double loop is the problem
11:33:07 <cin> forever doesn't nest itself
11:33:17 <cin> whereas foo = forever foo is definitely nesting
11:33:17 <awestroke> cin: that's my point, the recursion away from the "forever" call keeps the previos stack frame
11:33:30 <cin> sure
11:33:50 <awestroke> yogert: resolved! use one or the other
11:33:52 <cin> but why's that interesting? forever by itself to do something forever is sufficient
11:34:12 <ski> @type fix forever
11:34:13 <lambdabot> Monad m => m a
11:34:39 <awestroke> cin: because that was the original question, if recursion inside a forever call was bad practice
11:34:46 <cin> oh, ok
11:34:58 <skypers> 20:30 < ski> skypers : write a function, or write a function type ?
11:35:02 <skypers> well
11:35:11 <yogert> awestroke, but i have to be careful in some cases, im trying to figure out what makes your case and mine different
11:35:14 * hackagebot hbro 1.1.2.2 - Minimal KISS compliant browser  http://hackage.haskell.org/package/hbro-1.1.2.2 (koral)
11:35:20 <monochrom> well, I hate to call it "bad practice" just because it is unfit for one example
11:35:24 <skypers> I’d like to make an instance of a typeclass any function whose result is something
11:36:09 <monochrom> in fact, "bad practice" is beside the point. I disbelieve in discussing these things away from the context of the problem being solved
11:36:16 <awestroke> monochrom: if it keeps filling up stack space, one should at least be aware of it... things like that kill long-running processes
11:36:49 <awestroke> you mean the difference between your lpaste and my version of it?
11:37:23 <yogert> well if I understand what was said, my case would result in an overflow, whereas yours would
11:37:38 <yogert> my case wouldn't result in an overflow
11:37:39 <yogert> typo
11:37:45 <tac> Is there an uncurry3-like operation?
11:37:54 <tac> that does
11:37:55 <tac>  (a->b->c->d) -> (a, b, c) -> d
11:38:37 <hiptobecubic> @hoogle (a -> b -> c ->d) -> (a, b, c) -> d
11:38:38 <lambdabot> No results found
11:38:41 <awestroke> hm, it seems to leak as much space when I run without the forever
11:39:08 <hiptobecubic> tac, guess you'll have to write one
11:39:32 <hiptobecubic> @let uncurry3 f x y z = f (x, y, z)
11:39:33 <lambdabot>  Defined.
11:41:20 <mr-> @pl f a (b, c, d) = a b c d
11:41:20 <lambdabot> (line 1, column 16):
11:41:22 <lambdabot> unexpected " "
11:41:24 <lambdabot> expecting operator
11:41:47 <latro`a> @pl \a (b,c,d) -> a b c d
11:41:48 <lambdabot> (line 1, column 9):
11:41:48 <lambdabot> unexpected "d"
11:41:48 <lambdabot> ambiguous use of a non associative operator
11:41:58 <latro`a> ew
11:42:00 <mr-> I guess that's not what I wanted ;-)
11:42:35 <mwhitfie1d> hiptobecubic isn't that curry3
11:42:51 <ski> skypers : sounds strange ..
11:42:53 <arbn> None of those make sense...
11:42:56 <peteretep> Is there a convention when writing functions that accept a StdGen
11:42:59 <peteretep> as to which argument it should be?
11:43:04 <peteretep> I feel like it should be the last one
11:43:04 <hiptobecubic> @type curry
11:43:04 <lambdabot> ((a, b) -> c) -> a -> b -> c
11:43:12 <yogert> Why would it build up a list of thunks? stackoverflow doesn't rely on the result of subsequent calls...
11:43:17 <yogert> awestroke
11:43:22 <mwhitfie1d> @type uncurry3
11:43:23 <lambdabot> ((t1, t2, t3) -> t) -> t1 -> t2 -> t3 -> t
11:43:51 <c_wraith|N10> Yes, it should be last, so that the functions reduce to g -> (a, g)
11:44:30 <awestroke> yogert: I'm very unsure about everything right now since plain recursion also bloated my memory, the only thing I've gotten working without space leaks now is using IORef with a "forever" call
11:45:45 <hiptobecubic> oopsie!
11:45:45 <hiptobecubic> @type uncurry
11:45:46 <lambdabot> (a -> b -> c) -> (a, b) -> c
11:46:16 <awestroke> yogert: this works fine: http://lpaste.net/102087
11:46:39 <monochrom> awestroke, memory doesn't grow here, after deleting "forever $"
11:47:08 <awestroke> monochrom: My laptop almost crashed from it even without forever, what might be the problem?
11:47:33 <monochrom> I don't know. I can't reproduce it. memory stays flat here.
11:47:47 <awestroke> monochrom: how long did you wait?
11:48:18 <monochrom> at least the time from my first sentence to your last sentence
11:49:33 <awestroke> monochrom: ghc version? using ghc --make or runhaskell?
11:49:44 <monochrom> 7.6.3, ghc --make
11:50:16 * hackagebot http-encodings 0.9.2 - A library for encoding and decoding bodies of HTTP messages  http://hackage.haskell.org/package/http-encodings-0.9.2 (AndreyChudnov)
11:51:15 <awestroke> monochrom: ah. no problem for me with the recursive version if i compile it...
11:52:38 <awestroke> yogert: so: use either forever or recursion, don't mix
11:52:55 <yogert> gotch
11:52:56 <yogert> a
11:53:02 <yogert> thanks
11:58:05 <danthedeckie> I've been thinking recently about the syntax order of 'function value' vs. 'object->method' - in some ways the latter makes for easier completion/automation (as you can see what methods are available for an object).  Is there an editor/mode which lets you type a variable, and then it tells you what functions there are which can take that as an input, which you can then select from and it shoves it in front of the var?
11:58:56 <geekosaur> sounds like the sort of thing that semantic haskell mode thing for emacs would do
11:59:03 <geekosaur> but I don't know if it does
11:59:46 <davidthomas> danthedeckie: https://ghc.haskell.org/trac/haskell-prime/wiki/TypeDirectedNameResolution
12:00:10 <davidthomas> (not an editor mode, but thinking in the space)
12:01:26 <awestroke> geekosaur: I find it more efficient to search for function signatures, then there's the & operator
12:01:29 <awestroke> :t (&)
12:01:29 <lambdabot> a -> (a -> b) -> b
12:01:32 <danthedeckie> "Type directed name resolution" - I knew there had to be people with that kind of thinking and some clever name for it! :-) Thanks davidthomas
12:01:39 <ski> danthedeckie : Alfa sortof does the opposite ..
12:01:45 <awestroke> danthedeckie: ^ I mean
12:02:56 <awestroke> >[1..5]&head
12:03:04 <awestroke> > [1..5]&head
12:03:05 <lambdabot>  1
12:03:47 <monochrom> danthedeckie: this is what you need to know about type-directed name resolution: http://article.gmane.org/gmane.comp.lang.haskell.cafe/83292/
12:04:56 <danthedeckie> thanks
12:07:34 <joar> Is http://www.haskell.org/haskellwiki/Implement_a_chat_server outdated? I get "Illegal tuple section in pattern: (sock,)" when trying to compile.
12:08:10 <cschneid> Can somebody explain the use of https://github.com/ekmett/machines/blob/master/src/Data/Machine/Is.hs ?
12:08:43 <joar> the problem is "runConn (sock, _) = do [...]"
12:08:48 <cschneid> like, what is Refl in this?
12:08:58 <ski> joar : either write `(,) sock' (possibly wrapped in outer brackets as well), or add `{-# LANGUAGE TupleSections #-}' to the top of the file
12:10:13 <ski> joar : hmm
12:10:50 <ski> joar : actually, i don't see `(sock,)' on that page (though i see `(sock, _)' in several places) -- perhaps you mistyped ?
12:11:18 <monochrom> joar: if you see "runConn (sock,  ) =", add _ to that space, "runConn (sock, _) ="
12:11:41 <monochrom> this is because the next line's syntax highlight shadows the _
12:11:56 <joar> ski: thank you, the _ was invisible to me
12:12:22 <awestroke> cschneid: I think the LANGUAGE GADTs pragma is a hint, https://en.wikibooks.org/wiki/Haskell/GADT
12:12:56 <joar> I had to zoom 200% to see the underscore
12:13:19 <monochrom> you can also copy-paste
12:14:30 <joar> monochrom: That's cheating. I'm just learning haskell, and svdvorak
12:15:23 <joar> Currently I see typing as training
12:16:23 * ski imagines joar training themselves in welltyping
12:17:01 <joar> ski: welltyping?
12:17:17 <ski> as in "well typed program"
12:17:25 <joar> od
12:17:27 <joar> oh
12:17:36 <monochrom> alright, copy-paste, then type. the point of copy-paste is to kill the bloody broken highlighting
12:17:49 <ski> .. after a while, you should be able to do simple type inference in your head
12:17:53 <awestroke> joar: I have enough problems typing on other peoples keyboards, if I learned dvorak I wouldn't be able to ever use others' computers at all
12:18:22 <monochrom> I can type on both qwerty keyboards and abcedf keyboards
12:18:46 <awestroke> monochrom: you never slip up and type a sentence in the wrong layout?
12:19:33 <joar> awestroke: I use the kinesis advantage as well as a regular laptop keyboard
12:20:02 <danthedeckie> I'm using a typematrix, with 'workman' layout, and then always use qwerty on standard layout keyboards. I can switch back and forth quite well.
12:20:03 <monochrom> I always make typos
12:20:10 <joar> Hello World => D.nnr ;rpne
12:20:22 * ski . o O ( Kinesis Advantage <http://i.4cdn.org/g/src/1396264574810.jpg> )
12:20:59 <joar> Mine is black though
12:25:57 <joar> monochrom: I get another error now: https://gist.github.com/joar/f637b966da7ac963318e
12:26:06 <yogert> With cabal sandbox, and cabal repl, how do I ignore files? I had them listed in "exposed-modules" but i have now commented them out
12:26:10 <dmead> ?yow
12:26:10 <lambdabot> ... I don't like FRANK SINATRA or his CHILDREN.
12:26:22 <yogert> yet it still tries to build them
12:26:30 <dmead> nancy was hot back in the day :/
12:26:41 <yogert> whats "yow"?
12:26:47 <ski> @help yow
12:26:47 <lambdabot> yow. The zippy man.
12:26:58 <yogert> very helpful
12:27:15 <yogert> ?yow
12:27:15 <lambdabot> Half a mind is a terrible thing to waste!
12:27:15 <dmead> @help karma
12:27:16 <lambdabot> karma <polynick>. Return a person's karma value
12:27:21 <dmead> @karma dmead
12:27:21 <lambdabot> You have a karma of 0
12:27:25 <dmead> what!
12:27:26 <jle`> :/
12:27:29 <dmead> i had lots back in the day
12:27:36 <dmead> this isn't the real lambdabot :/
12:27:56 <geekosaur> one of the handoffs went very poorly (we lost all the databases)
12:28:07 <dmead> :(
12:28:20 <Clint> backuprific
12:28:28 <dmead> dude, 1200 people
12:28:33 <dmead> last time i was here it was like 300
12:28:33 <jle`> that is a good qualification of the term 'poorly'
12:28:52 <monochrom> dmead: also, lpaste has exceeded 100000 pastes
12:30:17 <yitz> monochrom: is that with the help of spam pastes?
12:30:39 <monochrom> I have not counted
12:30:52 <yitz> dmead: you haven't been here for a long long time. 300. wow.
12:31:26 <yitz> dmead: so - welcome back!
12:31:37 <monochrom> and GHC has been at 7.6 or a while, going to be 7.8 soon (already RCing)
12:31:59 <monochrom> isn't Haskell exciting!
12:33:00 <yogert> Okay, so I've deleted the files in question, yet it is still trying to build them...
12:33:18 <yitz> and simon marlow doesn't work for MR anymore. nor ian lynagh for well-typed.
12:33:45 <mwhitfield> speaking of 7.8, i thought newtype deriving was supposed to be typesafe now? But i installed rc2 and it still wont compile with Safe. What happened with that?
12:33:50 <yitz> yogert: sounds like you may need to re-initialize your sandbox
12:34:23 <yogert> would that involve reinstalling all the dependencies?
12:34:37 <yitz> yogert: yes unfortunately
12:35:36 <yitz> yogert: you *were* in the mood for a break, weren't you?
12:35:47 <yogert> ha
12:36:08 <yogert> thats one way to look at ti
12:36:08 <yogert> it
12:36:09 <yogert>  : P
12:36:12 <ski> yogert : browsing <http://zippythepinhead.com/Merchant2/merchant.mv?Screen=PROD&Product_Code=30-Mar-14&Category_Code=sun2014&Product_Count=13> might help
12:36:55 <yogert> i feel better already
12:36:57 <yogert> thanks
12:38:06 <ski> yw
12:38:09 <ArneL> mwhitfield: They wanted to make it typesafe, but that has been delayed to at least 7.8.2 as a couple of bugs delayed the implementation to a point where it would have delayed the release far too much. For more information you can always read the corresponding ticket: https://ghc.haskell.org/trac/ghc/ticket/8827
12:39:26 <KatZilla> Hi there)
12:39:32 <KatZilla> Trying to run cabal-dev ghci
12:39:45 <KatZilla> and got an error like this: cabal-dev: user error (cabal: Can't parse --info output of GHC
12:39:45 <KatZilla> )
12:39:58 <KatZilla> any idea how to solve it ?
12:40:01 <KatZilla> using MAC
12:40:12 <mwhitfield> ArneL: ah, thanks. Didn't know about the ghc ticket site, that's really helpful
12:42:21 <KatZilla> http://lpaste.net/102091
12:42:30 <KatZilla> its my code
12:47:40 <schell> i’m having trouble deploying a server with ekg - i’m using `forkServer ipAddress 31338` - but visiting the server shows ‘No handler accepted “/“‘ - has anyone ran into this before?
12:49:51 <skypers> ok I think I got it how to turn a function w a -> w b -> w c -> w d into w (a -> b -> c -> d) with a function (w a -> w b) -> w (a -> b)
12:49:53 <KatZilla> trying to run cabal-dev ghci
12:49:55 <KatZilla> and got this
12:49:56 <KatZilla> and got an error like this: cabal-dev: user error (cabal: Can't parse --info output of GHC
12:49:56 <KatZilla> )
12:49:59 <skypers> if that last function is called Lamb
12:50:08 <skypers> and the former is f
12:50:19 <skypers> the reduced function is
12:50:42 <dsyang> Hi, I'm just getting started with haskell and installed the Haskell Platform for OSX (2013.2.0.0).  However, ghc/ghci doesn't seem to be able to find any of the haskell platform packages. Does anyone know what I need to get ghc/ghci to find the haskell platform packages?
12:50:42 <skypers> Lamb $ \x -> Lamb $ \y -> $ Lamb $ f x y
12:50:46 <skypers> hm
12:50:57 <skypers> I wonder how I can automate that
12:51:31 <mwhitfield> dsyang, i remember needing to add ~/.cabal to $PATH manually, you might try that
12:51:46 <geekosaur> the official platform package doesn't use that
12:51:51 <geekosaur> ~/Library/Haskell/bin
12:52:16 <mwhitfield> oh yeah, you're right, I'm misremembering
12:52:17 <jle`> skypers: it looks a lot like Applicative for Identity
12:53:01 <dsyang> geekosaur: I have ~/Library/Haskell/bin in my $PATH. There's nothing in the folder though
12:53:25 <geekosaur> right, that isn't going to be your problem; I was responding to mwhitfield there
12:53:36 <dsyang> oh ok
12:53:43 <geekosaur> the question is whether you have a ghc from some other source
12:54:07 <geekosaur> like if you installed it at some point from homebrew then that ghc won't see the stuff installed from the official platform package
12:54:12 <skypers> jle`: yeah but I can’t make it a Functor
12:54:15 <skypers> so an Applicative…
12:54:17 <geekosaur> (which includes its own ghc in /usr/bin)
12:55:44 <dsyang> geekosaur: I installed the platform through homebrew (brew install haskell-platform) and didn't have ghc installed before
12:56:06 <geekosaur> oh
12:56:20 <geekosaur> then I do not know.
12:56:58 <skypers> I guess there’s already something with a lowest constraint than Comonad to express (w a -> w b) -> w (a -> b)
12:57:13 <geekosaur> (also I do not know if the default homebrew ghc has the necessary bug fix for xcode 5 yet, there used to be a separate recipe somewhere on github --- see in the channel /topic I think there is a reference on that webpage)
12:57:37 <skypers> oh it’s not that
12:57:48 <skypers> it’s (w a -> b) -> w (a -> b)
12:58:16 <cwvh> geekosaur:  homebrew haskell-platform+ghc package with apple-gcc42 to fix the xcode 5 issue
12:58:44 <dsyang> yea I remember seeing something about gcc42 when homebrew was doing it's thing.
12:59:17 * geekosaur does not really know homebrew
12:59:30 <geekosaur> have seen enough of the code associated with it to not want to learn more
12:59:45 * cwvh shrugs
13:00:01 <eyenx> a
13:00:30 <dsyang> cwvh: geekosaur: would it be worth it to uninstall my homebrew version of the platform and try the instructions from /topic?
13:00:44 <aristid> it's ridiculous how easy it is to write parsers in haskell. i was first thinking about using json for something, but actually a hand-defined (concise) textual format parsed with json is not really much more code
13:00:55 <geekosaur> I don't know
13:01:13 <cwvh> I use homebrew's ghc with an updated gcc without any issues. I also keep a few GHC binaries in my $HOME.
13:01:14 <geekosaur> the xcode / clang thing is highly annoying but there won't be an official fix until may :/
13:01:30 <dsyang> :/
13:01:57 <aristid> homebrew's fix is good enough for me as well.
13:02:41 <skypers> @hoogle (w a -> b) -> w (a -> b)
13:02:41 <lambdabot> No results found
13:02:43 <skypers> :(
13:02:53 <dsyang> it's weird because ghc-pkg list finds the packages without any problems
13:03:18 <fizbin> Anyone who understands ConstraintKinds mind helping me walk through them?
13:03:19 <geekosaur> so what is the exact problem you are seeing?
13:03:28 <skypers> fizbin: yep?
13:03:36 <fizbin> Or rather, walk through a blog post that uses them without explanation?
13:03:39 <aristid> -json+attoparsec
13:03:46 <fizbin> I'm trying to read http://joyoftypes.blogspot.ru/2012/02/haskell-supports-first-class-instances.html
13:03:58 <skypers> fizbin: I used ConstraintKinds to create constraints alias
13:03:59 <skypers> like
13:04:06 <cwvh> dsyang: I would uninstall whatever Mac bundle you installed and get it all through homebrew:  brew install haskell-platform
13:04:18 <fizbin> And I can't get past the second quoted bit of code.
13:04:20 <dsyang> geekosaur: http://pastebin.com/pvNQzRqX
13:04:26 <skypers> type ErrorAndWriter m = (MonadError MyError m,MonadWriter MyOutput m)
13:04:29 <skypers> something like that
13:04:48 <fizbin> WTF does something like: data Dict c where
13:04:48 <fizbin>     Dict :: c => Dict c
13:04:55 <fizbin> even possibly mean?
13:04:56 <dsyang> cwvh: brew install haskell-platform is how I got all the things.
13:04:58 <skypers> it’s a GADT, fizbin
13:05:22 <skypers> but hm, c => Dict c sounds weird to me
13:05:31 <fizbin> Right, but how is Dict :: c a costraint?
13:05:37 <skypers> no idea
13:05:50 <geekosaur> dsyang, what is Concurrent.Parallel? I don't see that in the Platform
13:06:14 <cwvh> Control.Parallel?
13:06:14 <dsyang> it's provided by the parallel package
13:06:30 <dsyang> oh goddamnit
13:06:37 <cwvh> zing ~
13:06:51 <fizbin> Or, wait, is "c" by itself the constraint and then the constructor "Dict" is of type "given constraint 'c', (Dict c)"
13:06:52 <dsyang> geekosaur: you're right.
13:06:56 <geekosaur> did you install that package?
13:07:03 <fizbin> But WTF can that mean?
13:07:24 <skypers> fizbin: I think here
13:07:35 <dsyang> geekosaur: nah, I just misread hackage
13:07:43 <skypers> data Dict c where Dict :: c => Dict c is like
13:08:01 <skypers> data Dict :: Constraint -> * where Dict :: c => Dict c
13:08:05 <skypers> with PolyKinds
13:08:15 <dsyang> thanks for looking at it!
13:08:22 <skypers> but I’ve never used that kind of magical stuff
13:08:29 <fizbin> Okay, but what on earth does that mean?
13:08:35 <skypers> no clue
13:08:51 <skypers> I’m dealing with GADT and I’ whilling because I can’t make my GADT a Comonad :(
13:09:10 <triliyn> Maybe it's for reifying typeclass instances as records of functions?
13:09:24 <mwhitfield> c is a typeclass, the dict contains the instances of the typeclass explicitly
13:09:44 <athan> hahaha
13:10:04 <athan> mwhitfield: Holy crap
13:10:18 <fizbin> Okay, I'm going to go read the bit from ekmett's blog that that one points to, http://comonad.com/reader/2011/what-constraints-entail-part-1/ , and hope that if I follow it back far enough I'll figure out what it's saying.
13:10:30 <athan> Off-topic question: Is it possible to restrict the parameters of an ADT to only Sum types?
13:10:43 <athan> ie: Is there a sum typeclass? or something...?
13:11:59 <peteretep> What is a sum type?
13:12:33 <athan> peteretep: Data Sum a = One a | Two a | Three a ...
13:12:55 <athan> data Product a = (a, a, a, ...)
13:13:20 <athan> sums add the possible evaluations, products multiply
13:13:24 <ocharles> data Product a = Product a a a
13:13:37 <athan> check out the algebra of algebraic data types, peteretep
13:13:49 <dwcook> Either corresponds to sum, (,) corresponds to product
13:14:23 <athan> the type calculus he does is friggin insane
13:14:39 <athan> he uses taylor expansions to approximate the derivative of particular types
13:15:01 <athan> ie - the change in a type's # of possabilities as it becomes parameterized
13:15:04 <athan> it's crazy lol
13:16:02 <mwhitfield> wait what, that sounds amazing
13:16:23 <athan> mwhitfield: Algebra of Algebraic Datatypes!!
13:16:27 <mwhitfield> where is that? the ekmett link up there?
13:16:31 <athan> http://chris-taylor.github.io/blog/2013/02/13/the-algebra-of-algebraic-data-types-part-i/
13:16:36 <mwhitfield> ah
13:16:37 <mwhitfield> thanks
13:16:39 <athan> :)
13:17:18 <athan> it's truly incredible
13:17:22 <athan> that he was able to do that
13:18:02 <levi> For more on that topic, see the papers here: http://strictlypositive.org/calculus/
13:18:48 <mwhitfield> this is my problem with learning haskell past the total beginner stage, there's just so much interesting reading it keeps me from doing actual coding
13:19:01 <MagneticDuck> mwhitfield: welcome to the club
13:19:04 <MagneticDuck> >_>
13:19:11 <peteretep> I'm too stupid to understand what I read, so I have to code it to understand it
13:19:15 <MagneticDuck> there are so many interesting things
13:19:19 <MagneticDuck> peteretep: same =P
13:19:25 <athan> hahaha
13:19:27 <MagneticDuck> that's my favourite way of following tutorials
13:19:30 <peteretep> This is a definite benefit, as I have to spend all my time coding
13:19:31 <athan> I need to get into implementation design
13:19:37 <athan> profiling, testing, etc :/
13:19:38 <MagneticDuck> coding it out in a test module as you read
13:22:29 <athan> MagneticDuck: That's exactly what I lack
13:22:58 <athan> I just got leksah, hopefully that will encourage me lol
13:23:29 <athan> I just need to make a routine
13:25:57 <athan> but anyway, there's no way to restrict a data type definition to be a set of unique identifiers, huh
13:26:06 <athan> as only a set type, no product types
13:26:13 <athan> and no external data type usage
13:26:16 <athan> so like
13:26:49 <athan> all data constructors don't have any product types
13:26:50 <athan> so
13:27:00 <athan> data Foo = Bar Int | Baz
13:27:04 <athan> would be illegal
13:27:11 <athan> is there any way to restrict this?
13:27:22 <athan> I'd like the type checking, just not the extra stuff
13:31:10 <levi> I'm not really sure, but I doubt such a constraint exists.
13:31:31 <athan> hmmm
13:31:34 <athan> well
13:31:36 <athan> template haskell
13:32:01 <athan> is designed to convert constructors into sum types, product types, and unit
13:32:14 <athan> so I'm wondering if I could just make a dead-simple dsl
13:32:47 <levi> You could probably do it that way.
13:33:01 <skypers> seriously, I’m dying with my issue
13:33:03 <skypers> it’s killing me.
13:33:41 <skypers> I’m gonna write a lpaste about my attempts, you’ll tell me if where I do it wrong
13:35:20 <athan> skypers: Please do!
13:35:52 <awestroke> Isn't a comonad kind of like a functor? A "box" that holds a value
13:36:05 <apples> every comonad is a functor
13:36:07 <monochrom> please don't die today. please die another day :)
13:36:23 <skypers> yeah, maybe you’ll solve it in an ease
13:36:35 <skypers> I don’t see any other solutions…
13:36:36 <awestroke> apples: ah..
13:36:41 <awestroke> apples: oh
13:36:45 <mwhitfield> awestroke: pretty much all the algebraic typeclasses are subsets of Functor
13:37:23 <shachaf> What is an algebraic typeclass, and what is a subset?
13:37:25 <awestroke> so comonad just formalized the extraction of the held value?
13:37:46 <awestroke> and the "packing" of
13:37:57 <jle`> awestroke: meaningful duplication
13:38:07 <shachaf> "the held value" isn't a concept that makes sense for most Functor instances (and even for most Comonad instances).
13:38:31 <shachaf> And Comonad isn't just extract. extract on its own would not make a useful class.
13:38:45 <awestroke> jle`: the duplication is just wrapping another layer, isn't it?
13:39:19 <awestroke> shachaf: please give me a counterexample to the "held value" concept
13:39:44 <shachaf> data Stream a = Cons a (Stream a)
13:39:49 <jle`> depends on your extract, it could be a bit less trivial
13:40:23 <athan> awestroke: so like
13:40:32 <athan> awestroke: conways game of life
13:40:35 <jle`> have you looked at edwardk's command tutorial?
13:40:40 <athan> awestroke: each element is it's own comonad
13:40:51 <athan> awestroke: with the context being it's immediate neighbors
13:41:22 <shachaf> Functors are not cakes, and do not have layers.
13:41:29 <athan> hahaha
13:41:35 <awestroke> jle`: I tried to read it but it was above my level
13:41:44 <athan> I love how far haskell resolves... unknowns
13:41:56 <awestroke> shachaf: [[[a]]] <---- layers!
13:41:59 <athan> awestroke: I honestly have never used them
13:42:01 <skypers> monochrom: awestroke and others: http://lpaste.net/102092
13:42:07 <athan> awestroke: I need to learn how to use them practically
13:43:07 <athan> holy shit man
13:43:18 <athan> skypers: This is dope
13:43:23 <skypers> dope?
13:43:28 <skypers> what do you mean? :(
13:43:50 <athan> like
13:43:51 <athan> cool
13:43:53 <athan> hahaha
13:44:20 <jle`> it means you laced it with adequately strong drugs
13:44:51 <shachaf> f (f a) is "layers" of f at the type level, sure.
13:45:45 <monochrom> skypers: your goal is do-able IIRC, but it has been a while and I can't do it today
13:45:52 <athan> You need like... a LambN
13:46:08 <skypers> indeed athan
13:46:22 <skypers> I could also write 10 Lamb ctor
13:46:24 <monochrom> but normally I would not do it anyway
13:46:31 <skypers> Lamb, Lamb2, Lamb3…
13:46:35 <skypers> but it’s stupid
13:46:54 <athan> make f applicative, right?
13:47:04 <athan> if f is an instance of functor
13:47:09 <athan> and applicative
13:47:14 <athan> then I feel like it should work
13:47:19 <athan> this is very similar to lenses
13:47:20 <athan> I feel
13:48:01 <awestroke> jle`: I read the cellular automata example of comonads by edwardk, but it throws a lot of new stuff in there at the same time
13:48:20 <skypers> athan: hm?
13:48:22 <athan> Functor f => f ~ E where Lamb = <$>
13:48:22 <athan> ?
13:48:46 <skypers> E can’t be a Functor
13:48:54 <skypers> neither an Applicative
13:49:01 <athan> hmmm
13:49:24 <athan> skypers: I feel like analyzing how edwardk's lens library works will enlighten this adventure
13:49:35 <athan> he uses the existence of a functor as an isomorphism
13:49:37 <athan> or something
13:49:44 <athan> so use to convert
13:49:45 <athan> or something
13:49:46 <athan> lol
13:50:09 <skypers> sounds interesting
13:50:17 <skypers> a functor as an isomorphism
13:50:28 <apples> er..
13:50:31 <skypers> it’d be a contravariant functor wouldn’t it?
13:50:47 <athan> im not sure
13:50:50 <athan> what contravariance is
13:50:54 <athan> but i think you're right
13:50:57 <athan> it is an isomorphis
13:50:58 <athan> m
13:51:03 <skypers> if you have (a -> b) contravariance makes it (b -> a)
13:51:08 <athan> but what's interesting
13:51:09 <athan> ahhh
13:51:10 <athan> yeah
13:51:30 <athan> then yes, if you have a functor, you have both (a -> fb) and (fb -> a)
13:51:32 <athan> right?
13:51:52 <athan> hmm
13:51:54 <athan> idk
13:52:08 <athan> I think edwardk uses a unidirectional one
13:52:20 <athan> and then relates the two instances of a functor between two types
13:52:27 <athan> but in a polymorphic way
13:52:27 <skypers> well, a contravariant functor is something like (a -> b) -> f b -> f a
13:52:55 <athan> so all you need is the identity functor to instantiate a getter / setter between traversals
13:52:57 <athan> idk
13:52:59 <athan> shit is crazy
13:52:59 <athan> lol
13:53:05 <athan> ahhhhhh
13:53:06 <athan> okay
13:53:10 <athan> wow
13:53:14 <athan> that's actually really nuts
13:53:33 <athan> > flip const
13:53:33 <lambdabot>  No instance for (Data.Typeable.Internal.Typeable c0)
13:53:33 <lambdabot>    arising from a use of `M389258766265861455226881.show_M3892587662658614552...
13:53:33 <lambdabot>  The type variable `c0' is ambiguous
13:53:33 <lambdabot>  Possible fix: add a type signature that fixes these type variable(s)
13:53:33 <lambdabot>  Note: there are several potential instances:
13:53:44 <athan> lol
13:53:54 <athan> > flip const :: Int -> Int
13:53:55 <lambdabot>  Couldn't match type `c0 -> c0' with `GHC.Types.Int'
13:53:55 <lambdabot>  Expected type: GHC.Types.Int -> GHC.Types.Int
13:53:55 <lambdabot>    Actual type: GHC.Types.Int -> c0 -> c0
13:53:58 <skypers> athan: yeah
13:54:05 <skypers> :t contramap
13:54:06 <lambdabot> Contravariant f => (a -> b) -> f b -> f a
13:54:09 <skypers> <3
13:54:18 <skypers> :t flip const
13:54:19 <lambdabot> b -> c -> c
13:54:20 <skypers> :t const id
13:54:21 <lambdabot> b -> a -> a
13:54:38 <athan> :t curry const
13:54:39 <lambdabot> a -> b -> b1 -> (a, b)
13:54:44 <athan> :t uncurry const
13:54:45 <lambdabot> (c, b) -> c
13:54:58 <athan> i still have no idea :D
13:55:09 <skypers> I think I need to find my abstraction
13:55:12 <skypers> that makes
13:55:20 <skypers> w a -> w b -> w a -> …
13:55:21 <skypers> into
13:55:27 <skypers> w (a -> b -> c -> d…)
13:56:42 <athan> applicative, right?
13:56:53 <athan> wa <*> wb <*> wc ...
13:56:56 <athan> er
13:57:02 <skypers> :t (<*>)
13:57:03 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
13:57:06 <Benzi-Junior> is there a parsec combinator that works like "many" but retruns error if it fails any time
13:57:08 <skypers> I want…
13:57:10 <athan> ahhhhhhhhhhhhh
13:57:16 <skypers> a Coapplicative!
13:57:21 <athan> that's awesome
13:57:31 <athan> hmmm
13:57:43 <skypers> :t (<<=)
13:57:43 <lambdabot>     Not in scope: `<<='
13:57:43 <lambdabot>     Perhaps you meant one of these:
13:57:43 <lambdabot>       `<=' (imported from Data.Ord), `<<<' (imported from Control.Arrow),
13:57:47 <skypers> oh?
13:57:50 <dwcook> Benzi-Junior, so, a parser combinator that runs a parser infinite times?
13:57:53 <skypers> we don’t have Comonad in there?
13:58:07 <jle`> Benzi-Junior: forever :)
13:58:14 <jle`> (kidding)
13:58:32 <skypers> holy
13:58:34 <dwcook> Benzi-Junior, I'm not sure I'm understanding you correctly – What type should it have?
13:58:35 <skypers> lass (Functor f) => CoApplicative f where copure :: f a -> a coap :: (f a -> f b) -> f (a -> b)
13:58:52 <skypers> I need the SAME thing
13:58:58 <skypers> without the Functor constraint
13:59:06 <athan> hmmmm
13:59:16 <athan> unmap
13:59:36 <athan> cofunctor, right?
13:59:45 <skypers> Cofunctor?
13:59:47 <athan> :t unmap
13:59:47 <lambdabot> Not in scope: `unmap'
13:59:55 <skypers> @hoogle unmap
13:59:55 <lambdabot> Graphics.Rendering.OpenGL.GL.BufferObjects unmapBuffer :: BufferTarget -> IO Bool
13:59:55 <lambdabot> Graphics.UI.GLUT.Callbacks.Window Unmapped :: WindowState
13:59:55 <lambdabot> Graphics.Rendering.OpenGL.GL.BufferObjects UnmappingFailed :: MappingFailure
14:00:03 <skypers> yeah, doesn’t exist :D
14:00:20 <athan> i feel like you'd need a... prism
14:00:21 <athan> or something
14:00:32 <skypers> what’s a prism?
14:00:35 <athan> to deconstruct the types
14:00:39 <athan> it's like a type-level lens
14:01:03 <Lazarus> hello guys
14:01:06 <athan> I'm telling ya, research the lens library
14:01:12 <jle`> hi Lazarus
14:01:14 <athan> you'll probably like
14:01:17 <athan> double your power level
14:01:19 <athan> hello!
14:01:39 <Lazarus> i have a question concerning a project i would like to do in haskell
14:01:46 <athan> Lazarus: shoot!
14:01:47 <Lazarus> but im not shure about some stuff
14:01:57 <byorgey> athan: no, CoApplicative would have a Functor constraint, not Cofunctor.
14:01:57 <beaky> hello
14:02:05 <beaky> if haskell had no data, how would you represent data
14:02:06 <jle`> hello beaky
14:02:18 <Lazarus> at the moment i am doing my master thesis in chemistry
14:02:19 <athan> byorgey: I'm just guess+checking pathetically at this point lol
14:02:29 <dwcook> beaky, in another language
14:02:34 <beaky> lol
14:02:40 <apples> beaky: you mean via church encodings or something like that?
14:02:44 <beaky> yes!
14:02:46 <athan> beaky: through types!
14:02:47 <Lazarus> i am doing a lot of heavy numeric calculation on big files
14:02:49 <beaky> how do i do church encoding
14:02:49 <jle`> beaky: well...ADT's are all either sums or products
14:02:54 <skypers> when you say cofonctor
14:02:54 <jle`> which can both be church encoded
14:03:00 <skypers> you just mean… contravariant, right?
14:03:02 <beaky> how do you church encode sums
14:03:05 <athan> WOAH
14:03:16 <jle`> oh i was bluffing, i actually don't know how.
14:03:17 <athan> jle`: I can feel my third eye expanding...
14:03:18 <jle`> darn
14:03:19 <k4r1m> how do you use pure functions in an impure do block? lift??
14:03:28 <Lazarus> will i run into performance problems with haskell?
14:03:29 <jle`> k4r1m: can you give more context?
14:03:31 <Lazarus> compared to c
14:03:32 <Lazarus> ?
14:03:36 <skypers> k4r1m: let, or where
14:03:36 <beaky> k4r1m: fmap
14:03:38 <jle`> Lazarus: it depends on how you write your program
14:03:49 <jle`> Lazarus: the same thing can be said about C
14:04:02 <athan> Lazarus: It's a whole different ball game
14:04:07 <skypers> an « impure » do block is IO, pure code is not IO
14:04:08 <jle`> Lazarus: you can write performant and unperformant code in both haskell and C, and both have the potential to be faster or slower than the other
14:04:23 <beaky> > fmap (+1) $ Just 3
14:04:24 <lambdabot>  Just 4
14:04:25 <Lazarus> the thing is:
14:04:28 <skypers> then you can lift it, liftM, fmap, put it in a let expression, and so on
14:04:31 <athan> Lazarus: However, there have been findings that haskell is quicker to write and easier to reason about, while still being very performant (if designed properly)
14:04:45 <Lazarus> these are 10gb files that need to be fft'd and multiplied etc
14:05:10 <apples> beaky: (a -> c) -> (b -> c) -> c
14:05:12 <byorgey> Lazarus: it's possible to write fast numeric code in Haskell.  But it tends to require a good understanding of strictness, memory usage, etc.  It is easy to get terrible performance, and difficult to debug when you do.
14:05:39 <k4r1m> a couple of answers not sure which is the right one? Here is some contex http://lpaste.net/102093
14:05:41 <Lazarus> my code at the moment relies heavily on pointer ariticmetic
14:05:50 <Lazarus> lots of low level stuff
14:05:59 <byorgey> Lazarus: if I were you I would save yourself the trouble and stay away from Haskell for this project.
14:06:22 <athan> Lazarus: I agree with byorgey
14:06:23 <jle`> beaky: try looking through http://hbo-kennisbank.uvt.nl/cgi/nda/show.cgi?fid=2381
14:06:26 <apples> beaky: Left x is then \l r -> l x
14:06:34 <athan> Lazarus: pointer arithmetic is what haskell tries to stay away from
14:06:40 <beaky> oh
14:06:50 <apples> er, not quite, but you get the point
14:06:53 <beaky> how do you do pattern matchin on church encoded values
14:06:55 <Lazarus> just out of curiosity:
14:07:03 <jle`> Lazarus: pointer arithmetic?  is that the actual point of the project? or just an ends to a means
14:07:08 <Lazarus> can pointer arithmetic be done in haskell?
14:07:13 <athan> hmmmmmmmmm
14:07:20 <jle`> k4r1m: you'd use a let statement there
14:07:25 <Yaniel> Lazarus: you don't want to go that way
14:07:26 <Lazarus> well:-)
14:07:36 <jle`> k4r1m: do { let x = 10 + y; print x }
14:07:46 <Lazarus> the files are just huge and stuff needs to be calculated
14:07:46 <Benzi-Junior> dwcook: ok I'm using sepBy p s  which makes a parser that returns a list of values that the parser p would generate by parsing with p and s in sequence until either fails and then stops I want one that returns an error if p fails
14:07:49 <k4r1m> jle`: ok thanks
14:07:54 <jle`> k4r1m: i assume your actual application is a bit bigger than that
14:07:58 <Lazarus> there is not much high level stuff going on
14:08:02 <k4r1m> jle`: yeah of course haha
14:08:03 <jle`> k4r1m: because blah = print . (+ 10)
14:08:11 <apples> beaky: well, you just apply two functions that handle each case
14:08:12 <Lazarus> but i like haskell somehow
14:08:30 <jle`> Lazarus: you can do pointer arithmetic in Haskell, I believe
14:08:30 <k4r1m> was just a trivial demo to get an answer
14:08:31 <Lazarus> and i want shorter less verbose code
14:08:40 <jle`> Lazarus: but usually in most languages pointer arithmetic is a means to an end
14:08:46 <jle`> er wait
14:08:48 <apples> beaky: case x of (Left a) -> f a; (Right b) -> g b becomes x f g
14:08:58 <jle`> yeah
14:08:59 <beaky> wow
14:09:04 <beaky> so pattern marching is even easier
14:09:04 <k4r1m> is there a way to get to "x <- (+) y 4" to actually work with lifting the plus function?
14:09:19 <athan> if the sections of data are mutually exclusive, you could use haskell to orchestrate the arithmetic through ffi's
14:09:23 <jle`> k4r1m: the problem is that you can only put a monadic value on the right side of (<-)
14:09:24 <beaky> let x = y + 4
14:09:37 <jle`> k4r1m: so you could use return to turn y into a monadic value
14:09:54 <jle`> k4r1m: x <- (+ 4) <$> (return y)
14:09:56 <jle`> but that's kinda silly
14:10:05 <k4r1m> jle`: I was under the impression you "promote" functions to monads
14:10:12 <athan> beaky: I'm just as suprised
14:10:20 <jle`> k4r1m: you can make pure functions *work on monads*
14:10:27 <jle`> like, (a -> b) -> (m a -> m b)
14:10:29 <jle`> if that's what you mean
14:10:32 <k4r1m> oh but not the other way around?
14:10:44 <jle`> what do you mean by the other way around?
14:10:46 <Lazarus> ok, from an other perspective: is haskell any good in science, numberchrunching, etc?
14:10:46 <apples> beaky: church encoding can be inefficient though
14:10:56 <jle`> Lazarus: yeah, i use it for HPC in computational physics
14:11:08 <apples> if you church encode a recursive data type, that is
14:11:13 <beaky> yeah i wonder where church encoding is actually practically useful apart from 'look i can define data with only functions!'
14:11:22 <Lazarus> i am curious
14:11:23 <k4r1m> jle`: make a pure function return its normal value coupled with the current state
14:11:29 <Lazarus> what exactls are u doing?
14:11:33 <apples> well, it could simplify the implementation of a programming language, perhaps :)
14:11:33 <schell> does anyone know how to enable monitoring ekg on a server other than localhost?
14:11:35 <Lazarus> @jleÄ
14:11:35 <lambdabot> Unknown command, try @list
14:11:47 <jle`> beaky: i think it is mostly for mathematical rigor
14:11:50 <beaky> oh
14:12:00 <beaky> i thought it was a haskell design pattern or something
14:12:02 <jle`> like for proofs
14:12:09 <beaky> to write highly efficient parsers or reactive programming
14:12:18 <jle`> also you can do some church encoding at the type level too
14:12:21 <apples> i've heard that church encoding can speed things up, but i haven't seen any examples of that
14:12:46 <jle`> Lazarus: well at one lab i worked at i used it to simulate superconductor matrices and their reaction to magnetic flux
14:12:49 <apples> there are more efficient encodings for recursive types though, like the one detailed here: http://hbo-kennisbank.uvt.nl/cgi/nda/show.cgi?fid=2381
14:12:55 <jle`> k4r1m: can you say that in types?
14:13:23 <beaky> recursive types sound painful to church encode :D
14:13:35 <Lazarus> jle: would u describe this as computational intensive?
14:14:03 <jle`> Lazarus: it's numerical
14:14:15 <jle`> but it is not IO-ish
14:15:11 <Lazarus> jle: how far do u think u are away from c concerning performance?
14:15:14 <jle`> k4r1m: do you mean (a -> b) -> (a -> m b)
14:15:16 <jle`> ?
14:15:33 <k4r1m> jle`: yes sir.
14:15:36 * hackagebot cabal2nix 1.61 - Convert Cabal files into Nix build instructions  http://hackage.haskell.org/package/cabal2nix-1.61 (PeterSimons)
14:16:10 <jle`> k4r1m: that's sort of just fmap return
14:16:19 <jle`> :t fmap return (+ 10)
14:16:20 <lambdabot> (Monad m, Num a) => a -> m a
14:16:28 <athan> Lazarus: there's a recent paper from Simon Peyton Jones showing that Haskell is faster than C with sse calls (probably in some specific circumstance)
14:16:37 <athan> er SIMD calls
14:16:39 <jle`> but it comes up less often then you might imagine
14:16:47 <k4r1m> aw clever
14:16:50 <jle`> k4r1m: basically you call the function normally, and `return` the result
14:17:07 <k4r1m> I was only asking because the following kind of threw me off "liftM2 (+) [0,1] [0,2] = [0,2,1,3]"
14:17:55 <Lazarus> thx for the answers so far
14:17:57 <jle`> Lazarus: I'll admit I haven't dug too much into optimizing, i use a lot of unboxed types and strictness annotations, flirt with fusion, do some profiling
14:18:08 <jle`> but what i gain is nice parallelism/concurrency semantics
14:18:18 <jle`> i haven't attempted to do a direct comparison with c
14:18:27 <jle`> but mm_freak posted an article earlier
14:18:31 <Benzi-Junior> dwcook:oh no my bad it endBy works like that
14:18:38 <jle`> on his numerical code that worked faster in haskell than in c
14:19:35 <Lazarus> that would be my next question: given the same problem, are there any "benchmarks" that are real world like?
14:19:52 <beaky> > [x + y | x <- [0, 1], y <- [0, 2]]
14:19:53 <lambdabot>  [0,2,1,3]
14:19:56 <Lazarus> the language shootout puts haskell in a pretty bad light i think
14:20:03 <beaky> why arent list comprehensions as popular as in python
14:20:11 <Lazarus> for a compiles language i mean
14:20:13 <jle`> beaky: because they are usually just folds or maps or aps
14:20:19 <jle`> er
14:20:21 <jle`> filters or maps or aps
14:20:32 <beaky> but python has filters and maps too :(
14:20:43 <jle`> it's just a stylistic thing perhaps
14:20:47 <mwhitfield> it's just a cultural difference
14:20:52 <athan> Lazarus: Haskell distracts people from political issues :)
14:20:55 <jle`> oh also there is no partial application
14:20:59 <jle`> and operator sectioning
14:21:16 <mwhitfield> also awkward lambdas in python
14:21:17 <jle`> so you can't do things like (+) <$> [0,1] <*> [0,2]
14:21:20 <athan> Lazarus: I suggest you research more into haskell, then see whether or not you want to take the red pill ;)
14:21:32 <jle`> you'd have to do something like (\x y -> x + y) <$> [0,1] <*> [0,2]
14:21:38 <Lazarus> @athan
14:21:38 <lambdabot> Unknown command, try @list
14:21:50 <Lazarus> @athan: i dug into haskell already
14:21:50 <lambdabot> Unknown command, try @list
14:21:59 <jle`> and you can't easily do lessThan n = filter (< n)
14:22:01 <Lazarus> i think it is a great languang
14:22:05 <beaky> python has <*>?
14:22:19 <Yaniel> I wish people woudn't try to address people on irc the same way they do on twitter
14:22:19 <jle`> you'd ahve to do lessThan n xs = filter (\x -> x < n) xs
14:22:33 <Lazarus> i want to do more in it, but the performance question really stops me from commiting
14:22:47 <jle`> Lazarus: there are a few, but most performance articles are on people optimizing haskell to be better than C
14:22:51 <jle`> or on the same level
14:23:02 <athan> Lazarus: Well... what kind of properties does the computation satisfy?
14:23:07 <athan> associativity?
14:23:10 <athan> comutativity
14:23:13 <athan> is it a monoid?
14:23:20 <jle`> Lazarus: http://neilmitchell.blogspot.com/2014/01/optimising-haskell-for-tight-inner-loop.html
14:23:22 <beaky> monoids are the easiest typeclass
14:23:46 <athan> haskell gives you a sense of organization and capability, more than performance
14:23:55 <athan> ...but I'm probably wrong there, too ;)
14:23:57 <jle`> Lazarus: http://lpaste.net/101980
14:24:13 <beaky> haskell gives you unparalleled type safety and abstraction power
14:24:28 <beaky> no other language gives you the sense that "if it compiles, its correct"
14:24:40 <beaky> (then you spend days debugging stack overflow from laziness issues)
14:24:41 <quchen> And neither does Haskell.
14:24:47 <Lazarus> @athan: not much logic just a lot of the same calculation
14:24:48 <lambdabot> Unknown command, try @list
14:24:52 <athan> beaky: I agree with this as well, it eliminates a whole class of bugs
14:25:04 <quchen> Lazarus: @XY is a Lambdabot command :-)
14:25:21 <athan> Can you partition the data into independant elements?
14:25:36 <athan> can you describe the computation upon these elements, satisfying certain properties?
14:25:55 <athan> If you can turn the computation into a commutative monoid, you can massively parallelize the computation
14:26:56 <athan> Lazarus: Haskell is good (in my opinion) at massive data / parallel computation, but it requires the research and knowledge of orchestrating and designing it's implementation
14:27:11 <athan> I don't want to program in anything other than haskell right now, but I have a feeling that will change once I learn adga
14:27:13 <jle`> but so does C
14:27:45 <athan> jle`: But C is INHUMAN
14:27:49 <athan> jle`: :P
14:28:05 <athan> really, it's all about preference
14:28:24 <athan> I don't think I could imagine higher order polymorphism easilly in C
14:28:33 <athan> but that's just me :P
14:29:08 <dwcook> athan, supposedly Idris is more focused towards systems programming, much like Haskell, while Agda is more focused towards proof assistance
14:29:41 <Lazarus> @athan: it is like do fft on 100x100mb files
14:29:41 <lambdabot> Unknown command, try @list
14:29:43 <athan> dwcook: Sounds awesomely amazing and friggin needed in my life either way :D
14:29:56 <k00mi> I think most of the "haskell can be as fast as C" talk is a lie
14:30:09 <dwcook> athan, yeah, just letting you know in case you wanted to go that road
14:30:09 <k00mi> if you put the same effort into optimizing the C version it will likely be much faster
14:30:15 <Lazarus> @ athan: then sum all up
14:30:19 <Lazarus> stuff like that
14:30:19 <athan> dwcook: Thnak you :D
14:30:24 <athan> Lazarus: I think so
14:30:33 <beaky> haskell is pretty fast
14:30:39 <athan> Lazarus: fmap ffi files
14:30:40 <athan> lol
14:30:42 <k00mi> and highly optimized haskell is nothing like idiomatic haskell
14:30:55 <athan> or really
14:31:08 <athan> :t foldmap
14:31:09 <lambdabot>     Not in scope: `foldmap'
14:31:09 <lambdabot>     Perhaps you meant one of these:
14:31:09 <lambdabot>       `foldMap' (imported from Data.Foldable),
14:31:11 <athan> :t fold<ap
14:31:12 <lambdabot>     Occurs check: cannot construct the infinite type: a0 = t0 a0
14:31:12 <lambdabot>     Expected type: t0 (a0 -> b0) -> a0 -> b0
14:31:12 <lambdabot>       Actual type: t0 (a0 -> b0) -> t0 a0 -> t0 b0
14:31:15 <athan> :t foldMap
14:31:16 <lambdabot> (Foldable t, Monoid m) => (a -> m) -> t a -> m
14:31:24 <beaky> i wonder what highly optimized haskell looks like
14:31:35 <Lazarus> how well does the ffi integrate into haskell?
14:31:44 <athan> beaky: Check out warp
14:31:49 <Lazarus> meaning that calling low level stuff in c
14:31:53 <jle`> beaky: see the two articles i posted earlier
14:31:56 <athan> Lazarus: It can be difficult, I've heard
14:32:10 <Lazarus> but still having the high level abstractions in haskell upon this function, sortof
14:32:33 <jle`> Lazarus: haskell calling c through ffi is a very commonly taken route to build performant and pure libraries
14:32:36 <athan> Lazarus: What are the units of computation in the file? Lines?
14:32:45 <athan> Lazarus: Some kind of delimiter?
14:33:15 <athan> Lazarus: what jle` said
14:33:16 <yorick> OH GOD dependency management is a nightmare
14:33:27 <athan> yorick: Welcome!
14:33:36 <athan> I need to get nixOs
14:33:40 * yorick was used to the sane world of npm
14:33:49 <Lazarus> @ athan: no just one 4 byte word after another till the end
14:33:58 <beaky> https://github.com/yesodweb/wai/blob/master/warp/Network/Wai/Handler/Warp.hs looks like ordinary haskell
14:34:05 <athan> Lazarus: Check out Data.ByteString
14:34:23 <yorick> I wanted to use http://hackage.haskell.org/package/shpider but it depends on web-encoding which is deprecated and that depends on things that don't build anymore
14:34:24 <yorick> argh
14:34:26 <athan> beaky: It's one of the fastest http servers in production
14:34:51 <beaky> wow is it faster than that java one
14:35:06 <athan> beaky: crazy fast
14:35:13 <yorick> is it faster than nginx?
14:35:23 <athan> almost
14:35:29 <athan> the great thing about it
14:35:35 <athan> is that you can bind Yesod to Warp
14:35:44 <athan> so you basically get a nginx-speed MVC framework
14:35:59 <athan> I'm trying to design a scalable FRP framework
14:36:05 <athan> that binds design into the model
14:36:09 <beaky> for highly optimized haskell, warp seems like idiomatic haskell
14:36:26 <k00mi> beaky: that file doesn't even do anything
14:36:40 <indigo> It would be cool to use web-routes-boomerang with WAI/Warp. :)
14:36:43 <Lazarus> one question as a gamer: why are there no high end 3d engines implemented in haskell
14:36:44 <luvfp_> any one able to install haskell platform or build ghc7.6.3 from sources on RHEL 5.9 ?
14:36:45 <Lazarus> ?
14:36:48 <athan> boomerang?
14:36:54 <Lazarus> wouldnt that be sweet?
14:37:00 <athan> Lazarus: Frag, lambdacube
14:37:01 <indigo> athan: Yep. Happstack routing stuff.
14:37:09 <athan> ahhhhh
14:37:10 <athan> hmm
14:37:13 <athan> what does it do?
14:37:34 <athan> indigo: What new concept is it?
14:37:48 <indigo> athan: Just parsing combinators.
14:37:49 <athan> indigo: URL resolution for a cluster server?
14:37:54 <indigo> http://hackage.haskell.org/package/web-routes-boomerang-0.25.1/docs/Web-Routes-Boomerang.html
14:37:54 <athan> indigo: oh huh
14:37:58 <k00mi> @hoogle hgamer3d -- Lazarus
14:37:58 <lambdabot> Parse error:
14:37:58 <lambdabot>   hgamer3d -- Lazarus
14:37:58 <lambdabot>              ^
14:38:12 <k00mi> meh
14:38:18 <athan> oh hahaha
14:38:28 <geekosaur> did you mean @hackage
14:38:48 <k00mi> @hackage hgamer3d -- Lazarus
14:38:48 <lambdabot> http://hackage.haskell.org/package/hgamer3d -- Lazarus
14:38:53 <k00mi> aha!
14:38:54 <yitz> @google hgamer3d
14:38:54 <lambdabot> http://www.hgamer3d.org/
14:38:54 <lambdabot> Title: HGamer3D - Game Development with Haskell — HGamer3D - Game Development with...
14:39:10 <athan> indigo: I'm pretty sure warp/wai doesn't handle url handlers
14:39:12 <yorick> OH GOD nothing is documented
14:39:16 <athan> indigo: like...
14:39:23 <athan> indigo: I think that's passed into Yesod
14:39:30 <yorick> I could live with a readme to anything, you know
14:39:47 <indigo> athan: If you use wai-routes it does. That basically takes Yesod's routing and plugs it into WAI.
14:39:55 <k00mi> yorick: what are you looking at?
14:39:59 <athan> indigo: ahhhhhh, nice
14:40:08 <indigo> And then there's also web-routes-wai which takes Happstack's routing and plugs it into WAI.
14:40:08 <athan> indigo: yeah, I'm trying to do a different approach
14:40:13 <yorick> k00mi: I was looking at tagsoup, oh here it does have something. but it seems curl does not
14:40:37 <yitz> athan: yes wai is lower level - "middleware". it defines HTTP request and response. frameworks using wai define URL handlers.
14:41:10 <Lazarus> kk, thx for the answers guys, good night and hail haskell:-D
14:41:10 <indigo> It's nice to use plain WAI if you're doing REST APIs.
14:41:11 <k00mi> yorick: there are quite a few tutorials on tagsoup
14:41:48 <athan> yitz: I just forgot it parsed the request url into parts
14:41:54 <athan> yitz: hmm, interesting stuff
14:42:01 <k00mi> yorick: curl is just a thin wrapper around the C library I thkn
14:42:05 <k00mi> think
14:42:36 <athan> yorick: RIGHT?! I had that same frustration haha
14:42:40 <athan> yorick: with curl
14:42:57 <yorick> athan: haskell is great as long as you don't use anything by anyone else
14:43:05 <athan> yorick: hahaha
14:44:18 <athan> I really want to make network-scale frp
14:44:30 <athan> where the "signal" is replaced by atomic data operations
14:44:52 <athan> and the FRP is exposed to "actors", like the concurrency model
14:45:08 <athan> where each actor may have CRUD access to different scopes of data
14:45:12 <k4r1m> what's wrong with this? fmap (\x -> print x) [1..5]
14:45:20 <jle`> k4r1m: nothing is wrong with it
14:45:25 <athan> I think that this will compile down to a new style of web design
14:45:28 <jle`> > fmap print [1..5]
14:45:29 <lambdabot>  [<IO ()>,<IO ()>,<IO ()>,<IO ()>,<IO ()>]
14:45:35 <jle`> exactly what you wanted, right?
14:45:36 <athan> or really...
14:45:39 <jle`> :t fmap print [1..5]
14:45:40 <lambdabot> [IO ()]
14:45:41 <athan> information system design
14:45:53 <geekosaur> sequence_?
14:46:12 <k4r1m> oh a list of IO ()s
14:46:18 <luvfp_> is anyone's os RH 5.9?
14:46:40 <k4r1m> I want to print every element in some arbitrary list
14:47:15 <yorick> GHCi runtime linker: fatal error: I found a duplicate definition for symbol AAAAAAHGGHGHGI
14:47:24 <jle`> lambdabot:  check out http://www.skybluetrades.net/blog/tags/data-analysis.html
14:47:32 <yorick> I hate you forever, things.
14:47:48 * yorick rm -r ~/.cabal ~/.ghc
14:48:15 <athan> lol
14:48:16 <Fuuzetsu> sandbox next time
14:48:20 <Fuuzetsu> sandbox everything ever
14:48:21 <k4r1m> plus ghci actually complains when I use that fmap. What's the proper way to print every element?
14:48:22 <Fuuzetsu> it is the only way
14:48:26 <athan> I still have no idea how to do that, Fuuzetsu
14:48:33 <Fuuzetsu> cabal init sandbox
14:48:40 <Fuuzetsu> that's literally it, you're done
14:48:41 <geekosaur> k4r1m, you probably want mapM_
14:48:45 <athan> cabal doesn't understnad :(
14:48:51 <yorick> Fuuzetsu: does GHC know where to find things then?
14:48:51 <Fuuzetsu> update your cabal
14:49:07 <Fuuzetsu> yorick: I don't understand the question
14:49:26 <yorick> Fuuzetsu: when I run ghc in a sandbox dir, can it find the things installed in that sandbox?
14:49:29 <athan> WOAH
14:49:31 <athan> IT FINALLY WORKS
14:49:37 <athan> Thanks Fuuzetsu :D
14:49:39 <athan> lol
14:49:49 <k4r1m> [*** Exception: PrintfType (IO a): result should not be used ?
14:50:19 <geekosaur> you said print. printf is a harder thing
14:50:32 <geekosaur> (printf is in fact quite evil...)
14:50:35 <k4r1m> geekosaur: mapM_ :)
14:50:38 <athan> Is there like... a user's guide to cabal, that doesn't suck?
14:50:51 <athan> or a tutorial to productive haskell development?
14:50:57 <monochrom> "print [1..5]" already prints the list.
14:51:01 <geekosaur> right, but PrintfType tells me you are using printf
14:51:19 <geekosaur> and you will have trouble using that because it does very evil things with the type system
14:51:31 <k4r1m> monochrom: I need some custome formating
14:51:42 <k4r1m> what I actually want is to print a table from a list
14:51:48 <quchen> athan: Have you seen the Cabal user guide? Cabal isn't that complicated. I basically cross-read the user guide and a couple of random .cabal files I found on Hackage.
14:51:58 <k4r1m> with tabs and stuff. Don't see another way except printf?
14:52:09 <quchen> (I'm not sure whether you meant the official guide when you said "guide that doesn't suck")
14:52:18 <aristid> why does GHC.Generics have to use non-list-like encodings for big sum types :(
14:52:23 <athan> E:
14:52:24 <monochrom> ok, do not print, yet. build a string first, then putStrLn it.
14:52:46 <athan> quchen: I did... sorry haha. A lot of it was over my head last time I tried. I'll give it another go, tohugh :)
14:53:01 <Fuuzetsu> yorick: AFAIK you can tell it where to look (inside .cabal-sandbox) but if you have a cabal project then why are you running GHC by hand?
14:53:07 <monochrom> "show 5" gives you the string "5". surround it with tabs etc as per your formatting requirements
14:53:19 <yorick> Fuuzetsu: I don't have a cabal project yet
14:53:53 <quchen> athan: A .cabal file is really just a list of meta information (author, ...) and package dependencies. For building a simple project, the .cabal file can be quite small and understandable. See for example the pipes cabal file: http://hackage.haskell.org/package/pipes-4.1.0/pipes.cabal
14:54:02 <monochrom> also, it cannot be overemphasized that you will putStrLn that string. not print that string.
14:54:03 <quchen> (You can stop reading at "Benchmark")
14:54:32 <Fuuzetsu> yorick: make one!
14:55:20 <athan> quchen: I just found some roadblocks when it involved writing modules myself. But I've matured a lot as a haskeller, so I sohuld be fine now. Thank you!!!
14:55:21 <quchen> athan: `cabal init` will guide you through creating the meta information at the beginning of the file, after that you basically list all the dependencies, and what modules are part of the API.
14:56:09 <athan> quchen: Yeah, I still find it daughnting being the master of your own library haha
14:57:17 <athan> I'll get there eventually, I just have to make it a routine in my education to write modules and experiments as I go, but in a well structured, dev. friendly way
14:58:29 <athan> does the lambda calculus form any interesting mathematical objects?
14:58:38 <athan> I know algebraic data types form a near-semiring
15:01:01 <athan> like...
15:01:22 <athan> I've heard of some things that, when church encoded, they gain a performance increase
15:01:41 <yorick> Fuuzetsu: ah, cabal repl
15:02:58 <colDrMcBeardman> athan, there are some articles out there on applying algebra to lambda calculus.
15:03:11 <colDrMcBeardman> here's one: http://iml.univ-mrs.fr/~vaux/pub/alglam.pdf
15:03:45 <athan> colDrMcBeardman: Thank you, Colonel!
15:04:45 <athan> colDrMcBeardman: Do you have a lot of experience doing church encodings?
15:04:55 <athan> colDrMcBeardman: (if that's how you say it...) lol
15:05:55 <colDrMcBeardman> athan, none. I'm an abstract algebra and category theory noob. but I find it very interesting that so many things reduce to algebra.
15:06:27 <colDrMcBeardman> I actually would love to find an accessible book that reduces infinitessimal calculus to an algebra. I believe it's done by using hyper-real numbers.
15:06:40 <athan> colDrMcBeardman: Jesus
15:06:45 <athan> colDrMcBeardman: Me too hahaha
15:07:00 <athan> colDrMcBeardman: Have you read categories for the working mathematician?
15:07:18 <athan> colDrMcBeardman: I plan to soon
15:07:31 <colDrMcBeardman> athan, start by looking up hyper-real numbers. basically, all the controversy about Newton and Leibnitz's "ghosts of departed quantities" is actually not controversial.
15:07:50 <athan> wow
15:08:00 <athan> holy cheese burritos
15:08:01 <colDrMcBeardman> instead of all this limit theory, it could be taught the old-fashioned way if you just accept that inifinitessimals are first-class numbers.
15:08:17 <athan> hmm
15:08:18 <colDrMcBeardman> only category theory book i read was Pierce, and I don't remember much.
15:08:19 <athan> interesting
15:08:26 <colDrMcBeardman> I remember more of abstract algebra.
15:08:30 <colDrMcBeardman> and galois theory.
15:08:41 <athan> galios?
15:08:44 <athan> galois*
15:09:22 <colDrMcBeardman> athan, there was a french guy who proved before his death at the age of 21 why there's no general solution to fifth degree polynomials.
15:09:50 <colDrMcBeardman> his name was evariste galois, and his proof rested on the rotations (or lack of rotations) of this beautiful structure that was a special kind of group.
15:10:27 <athan> my god
15:10:47 <athan> hmm
15:11:04 <mwhitfield> apparently galois theory is the foundation for proving that no analytic solutions to Schrodinger's equation exist for atoms larger than He+. I was told that in grad school but never really looked into it
15:11:16 <mwhitfield> didn't know much abstract math at the time
15:12:10 <athan> interesting
15:12:16 <athan> I wonder what the operators were
15:12:24 <athan> some form of compositional manipulation?
15:13:04 <athan> and also tragic that such a powerful mind died so soon
15:13:34 <colDrMcBeardman> athan, the wiki article on galois groups is fairly approachable if you have a little AA background.
15:14:07 <athan> colDrMcBeardman: None at all, but I can add it on my shelf :) Thank you!
15:14:17 <kuribas> colDrMcBeardman: didn't Donald Knuth write a fiction noval about hyperreal numbers?
15:14:42 <colDrMcBeardman> kuribas, that sounds like something I have heard, yes.
15:15:05 <colDrMcBeardman> athan, I liked one titled A Book of Abstract Algebra
15:15:47 <kuribas> http://www.amazon.com/Surreal-Numbers-Donald-E-Knuth/dp/0201038129/ref=sr_1_13?s=books&ie=UTF8&qid=1396304023&sr=1-13&keywords=knuth
15:15:48 <colDrMcBeardman> and there's a real short one called Foundations of Galois Theory, but it's very formal... THM. DEF. PROOF. style, basically no pictures or diagrams :\
15:16:38 <colDrMcBeardman> kuribas, actually, those might not be the same.
15:16:53 <kuribas> oh, I see...
15:17:24 <colDrMcBeardman> hyperreals were described by hewitt and robinson
15:17:39 <colDrMcBeardman> and used first by archimedes, I guess.
15:17:46 <colDrMcBeardman> and of course, newton and leibnitz.
15:19:26 <yesthisisuser> has anyone here worked with Database.Persist.. I am trying to figure out what rawSql returns, or should return when doing an INSERT?
15:19:56 <athan> colDrMcBeardman: Oh woah! So hyper-real numbers just represent magnitudes beyond that of measurement?
15:20:20 <athan> :t Data.Persist.rawSql
15:20:21 <lambdabot> Couldn't find qualified module.
15:20:26 <athan> :t Data.Persistent.rawSql
15:20:27 <lambdabot> Couldn't find qualified module.
15:20:33 <athan> @hoogle rawSql
15:20:33 <lambdabot> No results found
15:20:54 <athan> :t Database.Persist.rawSql
15:20:55 <lambdabot> Couldn't find qualified module.
15:20:56 <colDrMcBeardman> athan, they're essentially the infinitessimal numbers we might call dx
15:21:16 <athan> colDrMcBeardman: Exactly
15:21:24 <athan> colDrMcBeardman: that's very interesting to me
15:21:45 <colDrMcBeardman> basically, the theory of hyper-reals just validates the use of infinitessimals as ordinary numbers, allowing the calculations and reasoning that Archimedes, Leibnitz, etc. did to be valid.
15:22:02 <athan> colDrMcBeardman: I had an idea the other day, that if you fold all elements of an equally distributed group, you get the identity
15:22:05 <colDrMcBeardman> without having to resort to the clunky things that Weierstrass used to formalize calculus.
15:22:24 <colDrMcBeardman> athan, that makes me think of division by zero and infinity.
15:22:28 <athan> ahhh yeah, that would make the arguments more valid huh
15:22:32 <athan> well
15:22:39 <athan> invertable, commutative monoids then
15:22:52 <colDrMcBeardman> I think that some of these "invalid" operations actually may have sensible semantics.
15:23:08 <athan> me too
15:23:15 <athan> so like
15:23:58 <athan> when you do the exhaustive computation
15:24:00 <athan> you basically get
15:24:01 <joelteon> Has anyone figured out a way to get packages in ~/.cabal indexed as a Dash docset?
15:24:08 <joelteon> that would be super helpful for me
15:24:20 <athan> (a <> !a) <> (b <> !b) <> (c <> !c) <> ... <> id
15:25:24 <colDrMcBeardman> athan, yeah, I think a lot of the effort people used to put into series calculations doesn't get thought about anymore.
15:25:44 * hackagebot groundhog 0.4.2.1 - Type-safe datatype-database mapping library.  http://hackage.haskell.org/package/groundhog-0.4.2.1 (BorisLykah)
15:25:49 <colDrMcBeardman> where it might be helpful to try to and use similar techniques on these structures we hadn't been paying attention to until comparatively recently.
15:26:03 <athan> it's because of the increse in data
15:26:10 <athan> people are forced to consider infinite structures
15:26:24 <athan> erm
15:26:25 <colDrMcBeardman> MacLaurin didn't have abstract algebra, but that doesn't mean the algebraists of the 21st century should forget about MacLaurin's thought process.
15:26:26 <athan> derp
15:26:30 <athan> i totally misheard you haha
15:26:34 <colDrMcBeardman> heh
15:26:36 <athan> you're right haha
15:26:52 <athan> have you read the algebra of algebraic data types?
15:27:15 <colDrMcBeardman> athan, no, I've been horrifically busy with "real life" and theory has taken a back burner to a lot of other things.
15:27:36 <colDrMcBeardman> my math and physics are still abyssmally high-school or barely above.
15:27:40 <athan> It's an hour long video
15:27:50 <athan> same! :D
15:27:53 <athan> but dude
15:27:54 <athan> this guy
15:28:15 <athan> takes the derivatives of types
15:28:23 <athan> by doing taylor expansion on their total possabilities
15:28:30 <colDrMcBeardman> athan, oh, I know about derivatives of data types.
15:28:31 <athan> basically representing how the space of a type grows
15:28:37 <athan> through it's parameterization
15:28:41 <athan> oh
15:28:44 <athan> never mind then lol
15:29:06 <colDrMcBeardman> which when I heard about it I was definitely thinking ... "no way."
15:29:17 <athan> same!!!
15:29:24 <athan> i still don't understand it
15:29:29 <athan> or church encodings
15:29:31 <colDrMcBeardman> but, it kinda makes sense. No idea how it's applicable. but it is nice theory.
15:29:31 <athan> or anything
15:29:32 <athan> now
15:29:32 <athan> lol
15:30:25 <athan> I think that it makes sense for understanding the possabilities of certain structures
15:44:46 <Eduard_Munteanu> I just realized we really need a structural editor to handle the presentational aspect of indentation.
15:45:55 <Eduard_Munteanu> Lining things up is all very tidy until you make one little change before the indented block, and it's rather difficult to write indentation-change-insensitive code.
15:46:24 <identity> athan: link for that video?
15:47:09 <johnw> Eduard_Munteanu: chrisdone has been working on that
15:47:42 <Eduard_Munteanu> johnw: you mean the fpcomplete stuff?
15:47:59 <johnw> no, I mean shm
15:48:07 <johnw> https://github.com/chrisdone/structured-haskell-mode
15:48:18 <Eduard_Munteanu> Wow, interesting.
15:49:03 <johnw> he's often in #haskell-emacs to discuss ideas about it
15:49:12 <Eduard_Munteanu> johnw: hm, but it still makes indentation part of the code
15:49:28 <johnw> you want it to use {;}?
15:50:03 <athan> identity: Just google "Algebra of Algebraic Data Types", it's linked in the blog post
15:50:43 <athan> hahaha
15:50:55 <athan> is there any way to have....
15:51:01 <athan> free pattern matching...?
15:51:08 <Eduard_Munteanu> johnw: no, I think tidy indentation has to be a presentational aspect, rather than something present in source code, because small changes propagate when you diff/patch and so on.
15:51:28 <athan> like, pattern match on the presence of an element in a tree, in a recusive, freewheel way?
15:51:30 <Eduard_Munteanu> johnw: the source code could contain purely semantic indentation.
15:51:43 <johnw> ah
15:53:13 <Eduard_Munteanu> athan: with ViewPatterns you can write stuff like   f (foo -> Bar) = ...   instead of   f x = case foo x of Bar -> ...
15:53:30 <athan> ahhhh right on!!
15:53:39 <athan> I'm trying to make a web ast
15:53:48 <athan> and detect browser bugs via pattern matching
15:53:51 <Eduard_Munteanu> athan: also with PatternGuards you can write   f x | Bar <- foo x = ...
15:53:53 <athan> some are absolute, others relative
15:54:16 <athan> aweosme! Thank you!!!
15:54:28 <Eduard_Munteanu> athan: note the "instead of" above means the two forms are equivalent, it's just notational sugar.
15:55:49 <athan> Eduard_Munteanu: Ahhhh, very interesting.
15:55:54 <tommd> Also, with assembly you can write         leaq -8(%r12),%rdx
15:55:55 <tommd>         subq $8,%rsp
15:55:55 <tommd>         movl $0,%eax
15:56:09 <Eduard_Munteanu> johnw: though I would settle for explicit presentational markup / styling, in-band or out-of-band, it doesn't have to happen automatically.
15:56:13 <tommd> Sorry, I just saw so many option it sounded funny.  Now it looks annoying.
15:56:19 <monochrom> heh
15:56:21 <Eduard_Munteanu> :)
15:57:48 <Eduard_Munteanu> I wonder if Literate Haskell makes sense for this stuff.
15:58:23 <athan> I wholeheartedly agree
15:58:37 <athan> it's due to the fact that we've encoded both into the langauge
15:58:46 <athan> and that we rely on the keyboard
15:59:11 <athan> I think it would be wonderful if we had a "character set" of lexical elements, then moved them in a gui
16:00:57 <Eduard_Munteanu> People use explicit markup to lay out math, so why not.
16:01:06 <jcarpenter2> Having two dimensions to lay things out in your source files would be great
16:01:11 <athan> hahaha
16:01:23 <athan> I'm doing that in my frp implementation
16:01:25 <athan> for websites
16:01:33 <athan> I'm completely decoupling design from semantics
16:01:38 <athan> because each can be their own ADT
16:01:55 <athan> then you fold them together if you want a single markup language
16:03:55 <athan> erm... syntax
16:03:56 <athan> lol
16:09:08 <akurilin> Say I have a repository with a .cabal file and a Main.hs which I just downloaded from Github. Do I need to explicitly run cabal init sandbox to have that project build in a sandbox?
16:09:17 <akurilin> As in, will the project not default to using a sandbox?
16:09:56 <athan> good question...
16:10:02 <athan> I think you're right
16:10:11 <athan> that it will default to using the system, not a sandbox
16:10:14 <quchen> Your project is sandboxed iff you sandbox it.
16:10:42 <athan> quchen: For an existing project, do you just run `cabal sandbox`?
16:10:49 <akurilin> quchen: I guess what I'm getting at is that the decision to sandbox it is never specified in the .cabal file, right?
16:10:51 <athan> quchen: or `cabal init sandbox`?
16:11:08 <athan> akurilin: Most likely
16:11:22 <athan> akurilin: That's an end-user opinion
16:11:22 <yesthisisuser> sorry.. isn't it cabal sandbox init?
16:11:27 <quchen> The usual pattern is  cabal sandbox init && cabal install --only-dependencies && cabal build
16:11:37 <athan> ahh okay
16:11:40 <quchen> See also here: http://www.haskell.org/cabal/users-guide/installing-packages.html#sandboxes-basic-usage
16:11:40 <athan> I have no idea honestly
16:12:02 <skypers> hm ok
16:12:06 <athan> quchen: Thank you!!!
16:12:54 <skypers> w a -> w b -> w c -> w d -> … -> w r ; make it w (a -> b -> c -> d -> … -> r) with only one function (w a -> w b) -> w (a -> b) sounds impossible with no Functor nor Applicative nor Comonad
16:12:58 <skypers> I’m stuck
16:13:07 <skypers> I might need to change the second function
16:13:13 <skypers> like (w a -> b) -> ?
16:13:15 <athan> hmmm
16:13:16 <skypers> or something like that
16:13:17 <athan> with only one?
16:13:22 <akurilin> Ok thanks for explaining everybody
16:13:24 <athan> You'd need to... create currying
16:13:36 <skypers> well
16:13:46 <Eduard_Munteanu> skypers: for a fixed number of a, b, c etc.?
16:13:50 <athan> or really
16:13:53 <athan> reverse currying
16:13:58 <skypers> I think the key is to compose the function at each « composable » points
16:14:09 <skypers> Eduard_Munteanu: nope, n-ary functions
16:14:12 <skypers> if I have
16:14:19 <skypers> w Float -> w Float -> w Float -> w Float
16:14:44 <skypers> I can turn that into w (Float -> Float -> Float -> Float) with my (w a -> w b) -> w (a -> b) function and (.)
16:14:48 <athan> you'd have to know how far the function could apply to at run-time
16:14:49 <athan> er
16:14:51 <athan> ahead of time
16:14:56 <skypers> yes
16:14:58 <athan> in a purely polymorphic argument
16:15:05 <skypers> that’s why I’m trying to do that with a typeclass
16:15:09 <athan> jesus man
16:15:13 <athan> hahaha
16:15:33 <skypers> jesus man?
16:15:50 <Eduard_Munteanu> skypers: hm, might be possible with tricks a-la printf
16:15:59 <skypers> if the “tool” function is called f :
16:16:07 <skypers> f $ f . theFunction
16:16:25 <skypers> or
16:16:38 <skypers> f $ \x -> f $ \y -> f $ \z -> f x y z
16:16:44 <skypers> this works.
16:16:51 <skypers> but I can’t figure out the general form of that
16:18:08 <Eduard_Munteanu> skypers: are you allowed UndecidableInstances and OverlappingInstances?
16:18:09 <athan> I really want to say that's undecideable
16:18:26 <skypers> yes, Eduard_Munteanu, but some folks say that UndecidableInstances is wrong
16:19:07 <Eduard_Munteanu> Hmm, right, you probably don't need it because you just need to match the argument type.
16:19:34 <skypers> I tried something earlier Eduard_Munteanu
16:19:35 <skypers> ait
16:19:39 <skypers> wait*
16:19:51 <athan> why can't you
16:19:52 <skypers> Eduard_Munteanu: http://lpaste.net/102092
16:19:54 <athan> er
16:19:56 <athan> wait nvm
16:20:08 <xpika> is there a shortcut to liftM f g g ?
16:20:43 <pavonia> @pl \f g -> liftM f g g
16:20:43 <lambdabot> join . fmap
16:21:32 <xpika> pavonia: thanks
16:23:32 <athan> skypers: I really want to say it's impossible because you have to list the arguments in it's definition, and haskell is right-curried
16:24:06 <athan> skypers: unless you could pattern match on the kind of the argument, then I think you're dead in the waters
16:24:20 <athan> but DON'T LET ME STOP YOU!!!!
16:24:22 <athan> !!!!!!!!!!!!!!!!!!!!
16:24:40 <skypers> I think it’s possible
16:24:45 <skypers> I think my typeclass is just wrong
16:25:08 <skypers> it’s just recursively applied composition
16:25:18 <athan> hmm
16:25:25 <skypers> if I got somethinge like E a -> aFunction
16:25:28 <Eduard_Munteanu> skypers: I think you want a  class LiftArg where f :: (w a -> w r) -> w (a -> r); instance LiftArg r => LiftArg (a -> r) where ...; instance LiftArg r where ...
16:25:41 <skypers> then I just compose the function with the Lamb and I reiterate
16:25:51 * hackagebot quantities 0.1.0 - Unit conversion and manipulation library.  http://hackage.haskell.org/package/quantities-0.1.0 (jdreaver)
16:25:51 <athan> Woah!!!!
16:25:54 <skypers> Eduard_Munteanu: yeah
16:25:56 <skypers> I tried that
16:26:04 <skypers> not sure it’s okay
16:26:12 <skypers> in the second case
16:26:20 <skypers> r ~ E b -> c
16:26:23 <skypers> resulting
16:26:30 <skypers> E (a -> E b -> …) -- dammit
16:26:52 <skypers> it’s quite simple on a fixed number of arguments
16:26:55 <skypers> let’s say
16:27:00 <skypers> w a -> w b -> w c -> w d
16:27:10 <skypers> if we compose that f function with another g function
16:27:19 <skypers> the g function will work on (w b -> w c -> w d)
16:27:25 <skypers> if we pass in g another composition
16:27:37 <skypers> the h function will work (w c -> w d)
16:27:44 <skypers> and I know how to lift that into w (c -> d)
16:27:54 <skypers> then I get back w b -> w (c -> d)
16:28:06 <skypers> I know how to lift that into : w (b -> (c -> d))
16:28:12 <skypers> which is… w (b -> c -> d)
16:28:24 <skypers> then I end up with w a -> w(b -> c -> d)
16:28:35 <skypers> applying the Lamb on that result in w (a -> b -> c -> d)
16:28:42 <skypers> I’m pretty sure I can write a typeclass that
16:28:44 <skypers> +for
16:29:23 <skypers> so the idea is to have a typeclass that stops when hitting (w a -> w b)
16:29:49 <skypers> and recurse by composing the function with the typeclass’ method itself in the case of…
16:29:52 <skypers> hm
16:30:03 <skypers> E a -> f with (LiftArg f) => f
16:30:05 <skypers> something like that
16:30:51 <athan> skypers: Do you have a way I could contact you on this idea? I really want to help with any research I can
16:30:58 <athan> like a github or something?
16:31:18 <skypers> sure, here, or through my email, dimitri.sabadie@gmail.com
16:31:33 <skypers> thank you :)
16:31:37 <athan> awesome, you'll be getting one from athan.clark@gmail.com
16:31:40 <athan> no problem!!!
16:31:44 <skypers> :)
16:31:46 <athan> I think you're doing something awesome
16:31:50 <athan> and really critical
16:31:52 <skypers> ?
16:31:54 <skypers> why?
16:32:26 <athan> cause it's a coapplicative
16:32:26 <athan> lol
16:32:34 <skypers> yeah :)
16:32:52 <skypers> well, I won’t call that CoApplicative
16:33:03 <skypers> since it’s definitely not a Functor
16:33:05 <Eduard_Munteanu> athan: there aren't any
16:33:16 <athan> CoApplication
16:33:16 <athan> lol
16:33:19 <Eduard_Munteanu> Not interesting at least.
16:33:27 <athan> Eduard_Munteanu: Why is that?
16:33:31 <athan> hm
16:33:39 <skypers> it’s just a way to wrap a bare function into “something”
16:33:40 <skypers> yeah
16:33:53 <athan> hmmmm
16:34:04 <Eduard_Munteanu> athan: the other edward said so. :P
16:34:04 <skypers> it’s an interesting pattern
16:34:08 <athan> would probably be really useful for CPS
16:34:13 <athan> hahaha
16:34:15 <skypers> what is CPS?
16:34:21 <athan> continuation passing stype
16:34:22 <athan> style
16:34:24 <athan> like
16:34:24 <skypers> oh
16:34:26 <skypers> yeah
16:34:27 <skypers> ok :)
16:34:28 <athan> promises, thunks
16:34:37 <athan> hmm
16:34:48 <Eduard_Munteanu> athan: I don't think Hask has any coexponentials for one thing.
16:35:00 <n4l> are take and drop lazy concepts? / do they make sense in an "eager" context?
16:35:08 <skypers> yes n4l
16:35:13 <skypers> they’re lazy
16:35:19 <skypers> > take 3 $ [1..]
16:35:20 <lambdabot>  [1,2,3]
16:35:24 <skypers> well
16:35:30 <skypers> take is lazy in its second argument
16:35:34 <skypers> and strict in its first
16:35:43 <skypers> I guess
16:35:45 <skypers> let’s try
16:35:49 <skypers> > take undefined []
16:35:50 <lambdabot>  *Exception: Prelude.undefined
16:35:52 * hackagebot th-instance-reification 0.1.0 - Fixed versions of instances reification functions  http://hackage.haskell.org/package/th-instance-reification-0.1.0 (NikitaVolkov)
16:35:53 <athan> aha!
16:35:55 <skypers> yeah, strict in the first :)
16:36:05 <athan> it would be hard not to be
16:36:15 <athan> you have to extract the magnitude of the number arg
16:36:17 <skypers> though drop is lazy in both I guess
16:36:21 <Eduard_Munteanu> athan: or any comonoids if you wish to take that route
16:36:22 <athan> (at least in my understanding)
16:36:28 <skypers> > drop undefined []
16:36:29 <lambdabot>  *Exception: Prelude.undefined
16:36:36 <n4l> skypers: was just asking bacause it looks like ruby's take is eager by default...
16:36:36 <skypers> that’s interesting
16:36:38 <athan> Eduard_Munteanu: CoMonoid...?
16:36:41 <athan> Eduard_Munteanu: Woah
16:36:54 <skypers> > take (-1) []
16:36:55 <lambdabot>  []
16:36:59 <skypers> this is really weird.
16:37:03 <athan> hahaha
16:37:17 <skypers> > drop (-379793) []
16:37:18 <lambdabot>  []
16:37:23 <dmj`> a cabal file can't contain multiple libraries?
16:37:28 <skypers> @src drop
16:37:28 <lambdabot> drop n xs     | n <= 0 =  xs
16:37:28 <lambdabot> drop _ []              =  []
16:37:28 <lambdabot> drop n (_:xs)          =  drop (n-1) xs
16:37:38 <skypers> hm
16:37:42 <skypers> drop _ [] = []
16:37:52 <skypers> to me, this is lazy in both args
16:38:03 <skypers> hm
16:38:08 <athan> drop (-345345) [1..]
16:38:11 <athan> > drop (-345345) [1..]
16:38:12 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
16:38:22 <skypers> I guess it’s not because one equation needs to evaluate it
16:38:25 <dcoutts> dmj`: no sorry. I've had a vague plan to allow multiple private ones, but multiple "public" ones don't make sense. (How would you depend on them?)
16:38:30 <skypers> pretty weird
16:38:42 <n4l> hmmm
16:38:43 <skypers> two equations*
16:40:20 <n4l> skypers: by chance do you know a "good" take in js?
16:40:32 <skypers> I don’t know much js, sorry
16:40:47 <skypers> and it’s 1:39 AM, I have work tomorrow
16:40:48 <skypers> :(
16:40:51 <skypers> see you folks
16:41:06 <skypers> athan: I’ll let you know if I resolve my typeclass and recursive composition issue :)
16:41:14 <skypers> bye
16:41:27 <skypers> (I’ll keep idleing in there though ;))
16:41:29 <n4l> bye.
16:42:09 <dwcook> n4l, join ##javascript and I can help.
16:42:18 <mwhitfield> it hits the first guard first, which has to evaluate n
16:42:25 <mwhitfield> i think?
16:43:27 <roboguy_> n4l: aren't all ruby functions eager?
16:43:40 <roboguy_> unless you explicitly give them a thunk?
16:50:51 <n4l> roboguy_: yes Im not exaclty sure... in the docs you can use take and drop is available to both the Enumerable and Enumerable::Lazy.
16:51:07 <athan> are there any instances of (Monad, Comonad)?
16:51:48 <edwardk> Identity, NonEmpty, Monoid e => (->) e, Monoid e => (,) e....
16:51:51 <edwardk> yes
16:52:01 <athan> ahhhhhh awesome, thank you
16:52:03 <n4l> roboguy: but if you do something equivalent to take 3 [1..] it works.
16:52:21 <athan> edwardk: You might be interested in skypers' venture
16:52:35 <edwardk> ?
16:52:41 <roboguy_> n4l: huh, I didn't know that
16:52:50 <n4l> dwcook: thanks heading overthere...
16:52:50 <athan> edwardk: He's trying to write an n-ary :: m a -> m b -> m c ... m ( a -> b -> c ...)
16:52:54 <athan> ie
16:53:00 <athan> coapplicative
16:53:01 <athan> or something
16:53:22 <edwardk> coapplicative doesn't exist for deep reasons
16:53:28 <athan> I feel a sense of disgust in my own lack of appreciation whenever I see co- anything now haha
16:53:35 <athan> that's what I'm thinking too
16:53:38 <athan> it undoes currying
16:53:40 <athan> right?
16:53:57 <athan> er
16:54:14 <edwardk> there are no interesting comonoids in Set.
16:54:15 <athan> contradicts the necessary right-direction of partial application
16:54:16 <jfischoff> my guess there is no curry for coproducts
16:54:50 <athan> coproduct?
16:54:56 <jfischoff> sums
16:54:58 <athan> derp
16:54:59 <shachaf> That's why "comonoid" means "comonoid in Chu"!
16:55:16 <edwardk> and you can't have arbitrary coexponentials and exponentials or you collapse to a poset. if you want more than one function between two types you can't have arbitrary coexponentials
16:55:29 <jfischoff> I mean you have a monoidially functor you flip the arrows, I'm just guessing
16:55:35 <athan> hmmm
16:55:40 <athan> very interesting
16:56:08 <oio> wherever i use get line i can't make mistakes tipping stuff because i end up writing weird symbols any workaround?
16:56:26 <athan> jfischoff: Does this mean that functions are product types?
16:56:54 <athan> oio: Punctionation. Please :(
16:57:17 <athan> oio: Could you explain your issue more?
16:57:25 <oio> athan: i can't edit my input when using getline
16:57:33 <athan> oio: edit?
16:57:40 <apples> athan: functions are exponentials
16:57:40 <athan> oio: You can transform
16:57:48 <athan> apples: D'Oh!!!!
16:57:56 <athan> apples: I totally spaced, sorry!
16:58:10 <oio> athan:*Main> getLine dasdasd^?^?^?^?^?a1^[[D^[[D
16:58:22 <oio> athan:"dasdasd\DEL\DEL\DEL\DEL\DELa1\ESC[D\ESC[D"
16:58:36 <geekosaur> what platform?
16:59:05 <geekosaur> (but I suspect that it's just that getLine doesn't use readline like you are apparently expecting)
16:59:26 <oio> geekosaur mac os x:
16:59:32 <geekosaur> although DEL not working is an stty issue.. which you can still encounter under some cases
16:59:33 <athan> geekosaur: NOW I know what readline does! Thank you! haha
16:59:47 <athan> geekosaur: Only after 5 years of gnu/linux...
16:59:56 <geekosaur> the tty driver is kinda dumb. readline provides line editing and optionally history
17:00:30 <geekosaur> arrow keys flat out will not work unless using either readline or a curses/other terminal manager interface
17:00:55 <geekosaur> (or a readline alternative like editline or haskeline; ghci uses the latter)
17:01:57 <oio> geekosaur: thanks
17:02:39 <geekosaur> so, the keys that should work are: if DEL doesn't work then control-h; control-w deletes the previous word; control-u clears the whole line and starts over
17:03:01 <athan> If I was to get good at category theory, how many babies would I have to sacrifice to satan?
17:03:29 <geekosaur> but if you want DEL to work then you probably want to run at a shell: stty erase '^?'
17:03:32 <geekosaur> (and find out why your terminal isn't doing that for you)
17:04:52 <geekosaur> that or you somehow got set into raw mode, which shouldn't happen (unless maybe you're running this in ghci, but even then I'd expect it to do "sane" line editing; if it's not, it's a bug)
17:05:51 <Eduard_Munteanu> Or perhaps a misconfigured terminal / inputrc?
17:06:12 <geekosaur> good question. too many possible variables
17:19:31 <athan> Can someone verify my understanding?
17:19:44 <athan> Rank-N types are for generic libraries, correct?
17:19:59 <athan> When the quantifier can't be.... expected... early in the function? Or sometihng?
17:20:41 <athan> Or really, when using quantifiers, is their placement in the type signature extremely important? What are cases when it doesn't propogate?
17:21:20 <tac> athan: The ordering of foralls don't matter if they are at the very front
17:21:35 <tac> However, when you nest them in parens or put them to the right of an arrow, it changes the meaning
17:22:20 <quchen> athan: One of the standard examples is runST. Are you familiar with ST?
17:22:44 <athan> only very shallowly
17:22:48 <quchen> (It's not really for generic libraries, and the placement of the foralls is very important.)
17:22:56 <quchen> :t runST
17:22:57 <lambdabot> (forall s. ST s a) -> a
17:23:02 <athan> quchen: There's a dependancy in the tuple that simulates the state, right?
17:23:07 <oio> i how i could use guards as case of i don't remember was somehitng like XXX x | x <-Just = "sss"
17:23:18 <athan> tac: That's what I'm wondering
17:23:36 <athan> why is it so important?
17:23:50 <quchen> athan: You can picture (ST s) as sort of a state-y monad for the time being. "s" is the state type, and "a" is whatever you compute in the ST environment.
17:24:00 <tac> athan: because it's logically different. it has a different meaning
17:24:10 <quchen> (It's not really State, but that's besides the point now.)
17:24:21 <tac> athan: Think of it this way: when you see "forall a. blah", the "forall" is actually an implicit type argument
17:24:38 <quchen> State allows you to encapsulate things that do mutable updates, and then later wrap it up so that the compiler can guarantee that the whole thing is referentially transparent.
17:24:41 <tac> Which you might write like this:
17:24:42 <athan> ahhhhh
17:24:42 <athan> hmm
17:24:46 <tac> id :: forall a. a -> a
17:24:51 <tac> id {Int} :: Int -> Int
17:24:55 <quchen> In other words, it creates a sandbox in which some of Haskell's rules (immutability) are relaxed in some way.
17:25:00 <tac> (that's not haskell syntax, but used in some other languages)
17:25:14 <athan> oh!!!
17:25:15 <athan> wait
17:25:21 <quchen> So a value of type "ST s a" can be seen as an ordinary value, but in the context of this relaxed environment.
17:25:25 <athan> hmm
17:25:43 <tac> athan: So if you have a type like quchen is using:
17:26:06 <tac> runST {a} f :: a
17:26:10 <quchen> To ensure that this mutable state part cannot leak out -- i.e. that you can pack up any "ST s a" in a function that makes it referentially transparent -- there has to be a way to guarantee that after you "runST" the ST action, no state can remain.
17:26:10 <athan> hmm
17:26:25 <athan> would the Int not propogate if it weren't quantified?
17:26:27 <athan> ie
17:26:35 <athan> id {Int} :: Int -> a
17:26:36 <athan> ?
17:26:38 <roboguy_> oio: do you want to use guards, or would just pattern matching work?
17:26:54 <tac> under the assumption:  f :: forall s. ST s a
17:26:58 <oio> roboguy_: guards
17:26:59 <quchen> If state *would* be able to get out of ST, you could pass it to another ST action. And then that would be a side-effect: the second ST computation could depend on the mutable state of the first one. You don't want that.
17:27:17 <tac> athan: with the runST, you have to ask, WHAT am I passing the 's' to?
17:27:25 <quchen> In other words: you want to guarantee that you cannot possibly get an "s" out of a "ST s a" when using "runST".
17:27:28 <dwcook> athan, if you supply the a then you cannot bind some a's while keeping others unbound
17:27:29 <tac> to runST? (nope) to whatever the function f is above? (yes)
17:27:43 <roboguy_> oio: are you sure? the example you gave could look like this with pattern matching: xxx (Just x) = ...
17:28:26 <athan> dwcook: That's what I was thinking. I'm still not sure what forall's do precicely
17:28:27 <oio> roboguy_: no i mean to use guards as case of
17:28:41 <athan> ohhhh
17:28:42 <athan> hm
17:29:00 <roboguy_> oio: you need pattern guards for that http://www.haskell.org/haskellwiki/Pattern_guard
17:29:12 <dwcook> athan, one thing to notice is that every type signature containing variables has an implicit forall
17:29:15 <dwcook> @type id
17:29:16 <lambdabot> a -> a
17:29:21 <athan> I've heard
17:29:22 <dwcook> ^ That really means forall a. a -> a
17:29:25 <dwcook> Okay
17:29:27 <athan> hmm
17:29:32 <quchen> This is getting too noisy, I'll be quiet.
17:29:44 <athan> sorry quchen :)
17:29:59 <quchen> Don't worry about it. It's simpler to only have one person tell you this at a time ;-)
17:30:10 * tac wishes you could explicitly pass type variables in Haskell... you already can in the Core anyhow
17:30:12 <oio> roboguy_: thanks
17:30:33 <Iceland_jack> quchen: #haskell is one of the few channels where too many answers is the problem :)
17:30:44 <athan> dwcook: Okay, so type variables normally encapsulate the entire type signature in a forall statement, right?
17:30:49 <dwcook> athan, yep
17:30:59 <dwcook> athan, did someone bring up the "type-level lambda" comparison to you yet?
17:31:09 * quchen drools
17:31:18 <athan> dwcook: No not yet, hmm
17:31:21 <dwcook> tac has been hinting at it
17:31:36 <athan> dwcook: I'm assuming the explicit quantification makes the two different?
17:31:47 <dwcook> Imagine that the type of id looked like this: \a.a -> a
17:31:48 <athan> because one's that don't include it could be implicitly forsome?
17:31:49 <athan> or like
17:32:02 <athan> a -> forall b. b /= a -> b
17:32:03 <dwcook> (I'm using not-quite-Haskell lambda syntax to avoid the arrow ambiguity)
17:32:03 <athan> right?
17:32:08 <quchen> Capital lambda for copy/paste: Λ  :-)
17:32:26 <dwcook> quchen, \o/
17:32:43 <tac> Λ is literally the same as forall, isn't it?
17:32:49 <athan> dwcook: Is that your forall?
17:32:57 <roboguy_> athan: well, both of those would be equivalent to forall a b. a -> b, I think
17:32:57 <dwcook> athan, well, the type of id practically *is* what I just mentioned, except that it's the compiler, not the programmer, that goes around supplying arguments to the "type lambdas"
17:32:59 <tac> Which is literally the same as Π for Type's
17:33:07 <dwcook> athan, yes, forall is a type-level lambda
17:33:23 <athan> oh woah
17:33:36 <athan> okay so
17:33:39 <tac> It's slightly more involved, though, because when you pass a type to it, the type gets substituted in everywhere else
17:33:41 <dwcook> athan, just as you would replace all free occurrences in the lambda body with the appropriate supplied value, you do that with types too
17:33:47 <quchen> Hmm. I would agree that they're connected, but not identical. But I'm not an expert on anything anyway.
17:33:54 <athan> the quantifiers are the lambda parameters for type signatures
17:34:01 <athan> they basically create the "hole"
17:34:14 <tac> anyway, I'mma shut up now too :)
17:34:33 <dwcook> tac, I feel like you're probably more qualified to explain this than I am :P
17:34:42 <athan> tac: I'm still very interested!
17:35:00 <athan> tac: would Π be used for kinds?
17:35:47 <athan> hmmm
17:35:54 <athan> OH SHIT
17:35:56 <athan> okay
17:35:59 <athan> hmm
17:36:55 <athan> so these lambdas come into play with higher order functions, right?
17:36:56 <athan> ie
17:37:22 <athan> \o/ a. b. a -> ( a -> b ) -> b
17:37:23 <athan> vs
17:37:46 <dwcook> athan, are you using "\o/" as an emoticon here or something else?
17:37:47 <athan> \o/ a. a -> ( \o/ b. a -> b ) -> b
17:37:47 <athan> ?
17:37:51 <athan> forall
17:37:52 <athan> lol
17:37:53 <athan> my bad
17:38:04 <athan> I thought that's what you were using it for haha
17:38:05 <dwcook> Hmm, where'd you see it used that way?
17:38:06 <dwcook> Oh
17:38:09 <hiptobecubic> \o/ is forall?
17:38:19 <athan> in this use, yes :P
17:38:20 <c_wraith|N10> I found a (dumb) sequence oeis doesn't know! http://lpaste.net/102097
17:38:21 <dwcook> No, athan got confused when I used \o/ as an emoticon
17:38:25 <quchen> I like ∀ as a symbolf for forall.
17:38:25 <hiptobecubic> I always thought it was more of a "woohooooo!"
17:38:32 <dwcook> hiptobecubic, exactly
17:38:34 <athan> me too
17:38:47 <dwcook> I said that to quchen who kindly provided the lambda character to paste
17:38:55 <athan> My type signature is so stoked
17:39:01 <dwcook> :D
17:39:07 <athan> but, anyway
17:39:10 <athan> is that right?
17:39:11 <quchen> I just wanted to do something good with that Lambda :-C
17:39:15 <roboguy_> consider a function like getLength :: (forall a. [a] -> [a]) -> [b] -> Int. This can only take a function that "shuffles" the list (or does nothing to it)
17:39:18 <athan> Do I have the use of quantifiers well understood?
17:39:49 <dwcook> athan, in "forall a. a -> (forall b. a -> b) -> b, you have a free occurrence of b
17:39:55 <dwcook> woops, missed the closing quote
17:39:57 <athan> roboguy_ So nothing in "all" is lost?
17:40:07 <dwcook> Anyway, you don't want free occurrences of type variables
17:40:09 <athan> ahhhhhh
17:40:13 <athan> makes sense
17:40:14 <athan> yeah
17:40:18 <athan> I believe it
17:40:31 <roboguy_> well, I should say, you can't do anything to the elements
17:40:39 <dwcook> If you meant those b's to be the same, you need b to be scoped to where a is, basically
17:41:03 <athan> roboguy_: That's my intuition. Very interesting! It doesn't affect the # of possabilities possible with the ADT associated with the type variable?
17:41:35 <roboguy_> contrast that with  getResultLength :: ([a] -> [a]) -> [a] -> Int. With getResultLength, you could pass in a function that is [Char] -> [Char], for example
17:41:45 <roboguy_> but getLength *must* take a function forall a. [a] -> [a]
17:42:14 <roboguy_> so the function getLength knows nothing about the type a
17:42:44 <roboguy_> well, the function that getLength *takes* knows nothing about type a, to be more to the point
17:42:54 <athan> hmmm
17:44:27 <athan> why would [Char] -> [Char] break getLength?
17:44:31 <roboguy_> another way to look at it is that with something like getLength, we can pick the type in the getLength function (but not the function that's passed in) and in getResultLength, we can pick the type based on what function we give to getResultLength
17:44:40 <roboguy_> athan: it's too specific
17:44:50 <roboguy_> it has to be forall a. [a] -> [a]
17:45:06 <Algebr> Why can't ghci run a program that has an import GHC statement in it?
17:45:09 <roboguy_> it wouldn't be *for all* a
17:45:41 <athan> hmmm
17:45:44 <quchen> Algebr: GHCi can run programs that have imports in them without problems. Maybe paste your code and your error?
17:45:48 <athan> why wouldn't it necessarilly be forall?
17:45:58 <roboguy_> athan: try giving it a [Int] -> [Int]
17:46:01 <roboguy_> err [Int]
17:46:02 <athan> because the list is undecidably infinite?
17:46:03 <roboguy_> it won't work
17:46:07 <roboguy_> no
17:46:11 <athan> shit
17:46:16 <athan> OH
17:46:17 <athan> DUH
17:46:20 <athan> sorry haha
17:46:26 <athan> the function _has_ to be polymorphic
17:46:27 <athan> basically
17:46:34 <roboguy_> yep!
17:46:39 <athan> ahhhhhhhhhhhhhhhh
17:46:42 <Algebr> quchen: `import GHC main = print "hello"`, that doesn't run for me.
17:46:45 <roboguy_> here's another example: applyToFour :: (forall a. [a] -> [a]) -> [Int]; applyToFour f xs = f [1,2,3,4]
17:47:08 <roboguy_> we get to pick the type that we give to f in applyToFour, rather than the other way around (which is how it would be without the forall)
17:47:16 <athan> where f = reverse :P
17:47:26 <Algebr> quchen: I get Could not find module `GHC'                                            |191
17:47:26 <dwcook> roboguy_, you accidentally threw on an extra parameter, xs
17:47:26 <athan> oh man
17:47:26 <athan> wow
17:47:27 <roboguy_> or any other function forall a. [a] -> [a]
17:47:29 <athan> that's incredible
17:47:34 <roboguy_> dwcook: oh, oops
17:47:36 <Algebr> 291    It is a member of the hidden package `ghc-7.6.3'.
17:47:43 <Algebr> sorry about that spam.
17:48:01 <quchen> Algebr: "import GHC main = ..." is not valid Haskell.
17:48:02 <athan> so haskell (at runtime) can either deduce which resulting types should be, or (if it's quantified), it can force a polymorphic arg
17:48:05 <athan> wow
17:48:11 <athan> that is so mind blowing
17:48:11 <roboguy_> athan: it's at compile time
17:48:15 <athan> I know
17:48:17 <Algebr> quchen: I realize that, its not all on the same line.
17:48:17 <quchen> Algebr: What are you trying to do?
17:48:17 <athan> er
17:48:18 <athan> wiat
17:48:23 <athan> oh
17:48:34 <quchen> Algebr: That's why you should paste your code.
17:48:36 <athan> it deduces the result at compile time?
17:48:38 <athan> wowowowow
17:48:43 <quchen> Algebr: You can use lpaste,
17:48:44 <quchen> @paste
17:48:44 <lambdabot> Haskell pastebin: http://lpaste.net/
17:49:20 <Algebr> quchen: http://lpaste.net/102098
17:49:23 <roboguy_> athan: wait until you see the yoneda lemma (although I don't trust myself to be able to explain it fully)!
17:49:32 <roboguy_> (the yoneda lemma is related)
17:49:52 <athan> right haha
17:49:57 <athan> I've been like
17:50:00 <athan> at a theme park
17:50:08 <quchen> Algebr: Well, there's no "GHC" module. You don't need to import "GHC" to do anything. Just delete that line and it'll work.
17:50:17 <athan> waiting to see the grand attractions
17:50:23 <athan> like indiana jones or something
17:50:23 <roboguy_> athan: in fact, yoneda is probably the next thing to look at when rank n types start making sense
17:50:39 <Algebr> quchen: I'm pretty sure there is a GHC because its from a working project, IHaskell.
17:51:19 <roboguy_> quchen: it looks like there is a GHC module, since it says it's hidden. this is the first I've heard of it though
17:51:38 <Algebr> http://www.haskell.org/haskellwiki/GHC/As_a_library
17:51:52 <dwcook> Algebr, add a dependency on the ghc package to your cabal file, if applicable
17:52:18 <quchen> Sure there is a GHC module (hierarchy), but that seemed unrelated to the question.
17:52:27 <Algebr> how can I pass the equivalent of `ghc -package ghc my_program.hs` to ghci?
17:52:35 <athan> roboguy_: Is it more of a tool, or a rule?
17:52:56 <dwcook> Algebr, ghci is just ghc in disguise, did you try using the same flag?
17:53:13 <Algebr> dwcook: No, I'm doing through in emacs.
17:53:24 <Algebr> aka c-c c-l
17:53:36 <dwcook> Sorry, not familiar with the emacs interface
17:53:54 <roboguy_> athan: hmm, I'd say more of a rule since it sort of tells you want a polymorphic function can and cannot do, basically by virtue of it being polymorphic
17:54:05 <roboguy_> well, sort of
17:54:26 <roboguy_> Algebr: :set -package ghc
17:54:42 <roboguy_> :set allows you to pass in command line args
17:56:05 <Algebr> roboguy_: Yay, that worked, thank you! Why do I have to explicity set packages? Isn't that what imports are for? Or is this like linking to a library?
17:56:37 <roboguy_> Algebr: it looks like that package is hidden by default. I'm not familiar with it though
17:56:45 <roboguy_> there's probably some reason though
17:56:56 <roboguy_> usually you don't need to do that
17:57:29 <athan> roboguy_: I think I'm starting to gain the sense... It's like effect-free code at the type level
17:57:50 <dmwit> Semigroup : Monoid :: ? : Applicative
17:57:59 <roboguy_> athan: yeah
17:58:04 <roboguy_> dmwit: Apply
17:58:23 <dmwit> Which package should I look in?
17:58:27 <quchen> Haha, I just stumbled upon GHC.Tuple. It includes a comment "Manuel says: Including one more declaration gives a segmentation fault."
17:58:39 <athan> ahhhhhhhhhh
17:58:59 <athan> Apply matches <> with $?
17:59:02 <dmwit> "Apply" is a tough search term for Hackage to deal with.
17:59:05 <athan> er
17:59:07 <roboguy_> dmwit: Semigroupoids
17:59:09 <athan> wait, that's not right
17:59:18 <dmwit> thanks!
17:59:37 <roboguy_> athan: it's like Applicative without pure
17:59:41 <athan> or does a semigroupoid just create another operator $?
17:59:48 <dmwit> Oh, wait, I asked the wrong question in the first place.
17:59:53 <dmwit> But maybe semigroupoids has the answer anyway.
17:59:54 <athan> hmmm
17:59:58 <roboguy_> athan: well, a semigroupoid is a category without identity arrows
18:00:05 <athan> ahhh
18:00:10 <athan> ahh wow, okay
18:00:13 <dmwit> Yep, Alt was what I was looking for.
18:00:15 <roboguy_> well, it doesn't *need* to have them. in the way that monoids don't need inverses
18:00:29 <athan> where
18:00:43 <athan> Category + associativity = Monoid?
18:00:53 <roboguy_> sometimes I like to mess around with edwardk's sort of abstract packages and try to figure them out, haha
18:01:11 <roboguy_> athan: a category's arrows are already associative
18:01:12 <athan> hahaha
18:01:12 <dmwit> athan: The composition in a category is already associative.
18:01:19 <roboguy_> athan: a monoid is a category with one element
18:01:28 <athan> whiggity what
18:01:56 <athan> one element?
18:01:56 <dmwit> The arrows of a one-object category form a monoid under the identity arrow and composition as the binary operation.
18:01:58 <athan> How?
18:02:00 <athan> er
18:02:01 <roboguy_> it took a while to make sense to me too. the arrows are the "objects" (like numbers, in the natural number addition monoid, for example) and arrow composition is the monoid operation
18:02:02 <davidthomas> athan: If you have a category of one element, then the arrows form a monoid over composition.
18:02:06 <athan> would that be basically the type
18:02:15 <roboguy_> objects was a bad word to use there
18:02:19 <roboguy_> "values" might be better
18:02:31 <hiptobecubic> dmwit, does it *have* to have one element? Or does it just usually have one element
18:02:34 <roboguy_> the identity arrow is the identity element
18:02:40 <athan> via endomorphisms?
18:02:46 <roboguy_> yeah
18:02:48 <dmwit> You can turn a monoid into a one-object category by making the arrows be the elements of the monoid; identity arrow the empty element; and composition the binary operation.
18:02:53 <Algebr> <$> is the same exact thing as fmap?
18:02:54 <athan> from Type to Type
18:02:57 <roboguy_> athan: since it has only one object, they're all endomorphisms
18:02:57 <athan> AH
18:02:58 <dmwit> hiptobecubic: Think about it, and then you tell me. =)
18:02:58 <davidthomas> hiptobecubic: A category with more than one element isn't a monoid anymore because there are some arrows you can't compose
18:02:58 <athan> nice
18:03:02 <roboguy_> Algebr: yep
18:03:19 <dmwit> hiptobecubic: Or read other people's spoilers. ;-)
18:03:24 <athan> how in the hell
18:03:26 <hiptobecubic> dmwit, lol yes.
18:03:29 <Algebr> roboguy_: Then why does it exist? saves one key stroke?
18:03:31 <roboguy_> Conceptual Mathematics is a pretty good intro to category theory
18:03:36 <roboguy_> Algebr: because it's infix
18:03:42 <roboguy_> Algebr: and it works really well with Applicative
18:03:52 <Algebr> roboguy_: but I can get the same thing with `fmap`, right?
18:04:02 <roboguy_> > (*) <$> [10, 100, 1000] <*> [2,3,4]
18:04:03 <lambdabot>  [20,30,40,200,300,400,2000,3000,4000]
18:04:08 <dmwit> Algebr: 50% fewer keystrokes!
18:04:09 <davidthomas> Algebr: Constructor <$> parseThing <*> parseOtherThing
18:04:09 <hiptobecubic> davidthomas, dmwit the idea that the category has a single element with no real purpose other than to be a target for arrows feels pretty strange
18:04:10 <roboguy_> is much clearer, I think, than:
18:04:17 <athan> dmwit: So just because the arrow resolves to the same element, it does not mean that you can forget about where it came from (to see if it's commutative, associative, etc)?
18:04:21 <roboguy_> > fmap (*) [10, 100, 1000] <*> [2,3,4]
18:04:21 <hiptobecubic> s/element/object
18:04:22 <lambdabot>  [20,30,40,200,300,400,2000,3000,4000]
18:04:32 <davidthomas> hiptobecubic: Arrows are usually more interesting than objects :-P
18:04:36 <dmwit> athan: I don't understand the question.
18:04:43 <athan> me neither
18:04:43 <athan> lol
18:04:44 <roboguy_> Algebr: you can think of <$> and <*> as "context sensitive whitespace", kind of
18:04:46 <athan> sorry
18:04:46 <dmwit> athan: What does "resolve to an element" mean?
18:04:58 <athan> an endofunctor
18:05:00 <athan> er
18:05:02 <athan> endomorphism
18:05:03 <athan> sorry
18:05:05 <dmwit> hiptobecubic: Mathematics. You get used to it.
18:05:07 <athan> im confusing myself now
18:05:18 <roboguy_> athan: you should start with the definition of a category (and remember that there is no extra stuff to the definition itself, it really is as simple as it is)
18:05:33 <athan> I have
18:05:36 <athan> I just like...
18:05:39 <athan> don't see how
18:05:51 <athan> a monoid isn't commutative under the categorical denfintion
18:05:58 <roboguy_> athan: I highly recommend "Conceptual Mathematics" if you're looking for an introductory category theory book by the way
18:06:10 <roboguy_> athan: where does commutivity come it?
18:06:13 <roboguy_> *in?
18:06:22 <eitan> wjat
18:06:31 <athan> well, swapping the composition of the arrows
18:06:32 <davidthomas> athan: Arrows mean more than just their src and dst
18:06:33 <eitan> what's the question at hand?
18:06:41 <roboguy_> athan: that's associativity
18:06:44 <athan> davidthomas: What else?
18:06:50 <roboguy_> if you mean f . (g . h) = (f . g) . h
18:06:58 <davidthomas> athan: Depends on the particular category
18:07:01 <mwhitfield> eitan: clarifying the idea that a monoid is a category with one object
18:07:05 <roboguy_> arrows are not necessarily commutative with composition
18:07:07 <athan> davidthomas: hmmmm. Very interesting
18:07:09 <eitan> ahh
18:07:12 <davidthomas> but you can have many arrows between the same two obects
18:07:15 <davidthomas> and they can be distinct
18:07:16 <athan> roboguy_ I'm definitely gonna get that book
18:07:24 <athan> see that's what I'm wondering
18:07:27 <athan> not just htat
18:07:32 <athan> but their compositions are distict
18:07:36 <athan> (if indeed they are so)
18:07:37 <davidthomas> take the monoid "strings over concatenation"
18:07:43 <eitan> a braided monoidal category is a 3-category with only one 0-morphism and only one 1-morphism :-)
18:07:55 <roboguy_> athan: I'm working through it right now. I like it because it doesn't assume any knowledge of abstract math, like a lot of other category theory resources. all it assumes is basic math knowledge
18:07:56 <davidthomas> Interpreted as a category, each arrow is a string
18:08:09 <athan> oh! Perfect!!!
18:08:23 <athan> WOAH
18:08:25 <athan> WOAH WOAH WOAH
18:08:33 <eitan> a commutative monoid is a 2-category with 1 0-morphism and 1 1-morphism :-P
18:08:35 <davidthomas> "composing two arrows" is "concatenating two strings" and gives you another arrow/string
18:08:39 <athan> the categorical P.O.V. is more abstract
18:08:42 <athan> than the actual routine
18:08:45 <athan> of the computation
18:08:58 <athan> erm
18:08:59 <athan> isn't it?
18:09:14 <eitan> yes, more abstract way of thinking about monoids
18:09:16 <roboguy_> I'm still internalizing the fact that arrows don't need to be "function-like", but it makes more sense than it did
18:09:20 <athan> so with "strings over concatenation"
18:09:26 <athan> the whole monoid composes
18:09:32 <davidthomas> athan: Category theory doesn't hold you to any particular reification of the structures you're working with
18:09:39 <athan> "s" to "t" to "r" ...
18:10:08 <athan> man
18:10:12 <athan> thank you!
18:10:17 <athan> This just gets better and better
18:10:51 <athan> Last question for the next half hour or so:
18:10:55 <athan> What is a Kan Extension?
18:11:00 <Algebr> Was just thinking...Is a Haskell program really just one big function evaluation?
18:11:15 <athan> pretty much lol
18:11:19 <athan> it's crazy man
18:11:19 <mwhitfield> yes, if you don't think too hard about what io actions are at the bottom
18:11:33 <c_wraith|N10> No. Main is executed, not just evaluated.
18:11:49 <eitan> yeah, i agree with c_wraith|N10
18:12:01 <eitan> all the pure stuff is a function
18:12:06 <eitan> but not main
18:12:15 <athan> Algebr: Read "The Haskell Road to Maths, Logic, and Programming" for a really good into to the evaluation mechanisms behind the language
18:12:27 <Algebr> athan: I'm working through that atm.
18:12:38 <roboguy_> athan: I wish I knew
18:12:51 <roboguy_> (I *almost* know, though] I think)
18:13:05 <athan> Algebr: Also check out the IO Inside paper
18:13:11 <athan> http://www.haskell.org/haskellwiki/IO_inside
18:13:13 <athan> er wiki
18:13:16 <athan> hahaha
18:13:24 <roboguy_> category theory people: is a left kan extension sort of like a retraction of some kind and a right kan extension sort of like a section?
18:13:31 <Algebr> athan: will do, thanks.
18:13:35 <athan> WOAH
18:13:37 <athan> NO WAY
18:13:39 <athan> for real?
18:13:57 <roboguy_> haha, I wish every programmer was this excited when I told them about haskell
18:14:02 <athan> hahahaha
18:14:06 <athan> I feel your pain
18:14:10 <Algebr> but once a haskell program is running, isn't it similar to say a dag?
18:14:14 <roboguy_> maybe someday
18:14:15 <athan> they just don't see the beauty
18:14:21 <dmwit> Okay, straw poll.
18:14:25 <c_wraith|N10> It can have cycles
18:14:26 <athan> well
18:14:30 <athan> i think that's their personality
18:14:30 <dmwit> I'm designing an alternative to Either.
18:14:37 <athan> to ignore other's interests
18:14:58 <c_wraith|N10> Knot-tying can introduce cycles into the reduction graph
18:15:01 <Algebr> c_wraith|N10: what would be an example cycle? Like a GUI?
18:15:13 <athan> Algebr: Equivilancy
18:15:15 <c_wraith|N10> @src cycle
18:15:15 <lambdabot> cycle [] = undefined
18:15:15 <lambdabot> cycle xs = xs' where xs' = xs ++ xs'
18:15:19 <athan> and cyclic definition
18:15:35 <dmwit> Should its Alt instance defer to an underlying Semigroup instance (e.g. instance Semigroup s => Alt (Either' s)) or hard-code the choice of First so that failures can fail faster?
18:15:43 <johnw> roboguy_: it certainly _looks_ like sections and retractions of natural transformations, but I'm not sure
18:15:56 <c_wraith|N10> That definition of cycle actually does create a circular linked list
18:16:02 <athan> > let a b = a:b:(let a b)
18:16:02 <roboguy_> johnw: that's what I thought of when I saw them, but I'm probably getting ahead of myself
18:16:03 <lambdabot>  <hint>:1:23: parse error on input `)'
18:16:12 <athan> > let derp a b = a:b:(derp a b)
18:16:13 <lambdabot>  not an expression: `let derp a b = a:b:(derp a b)'
18:16:17 <johnw> roboguy_: the diagram is awfully similar
18:16:19 <bitemyapp> augur_: ACID
18:16:20 <bitemyapp> augur_: BIRN
18:16:21 <athan> er
18:16:39 <dmwit> > let derp a b = a:b:derp a b in derp 3 5
18:16:40 <lambdabot>  [3,5,3,5,3,5,3,5,3,5,3,5,3,5,3,5,3,5,3,5,3,5,3,5,3,5,3,5,3,5,3,5,3,5,3,5,3,5...
18:16:47 <dmwit> > cycle [3, 5]
18:16:48 <lambdabot>  [3,5,3,5,3,5,3,5,3,5,3,5,3,5,3,5,3,5,3,5,3,5,3,5,3,5,3,5,3,5,3,5,3,5,3,5,3,5...
18:16:48 <augur_> bitemyapp: we really should do that in blah :P
18:16:52 <augur_> put that channel on autojoin man
18:18:02 <johnw> roboguy_: similarly I've wondered if you can have a sort of adjunctions among functions, so long as f . g . f  = f
18:18:44 <c_wraith|N10> Algebr: cycle [ trace "foo" 3, trace "bar" 5 ]
18:19:18 <c_wraith|N10> oh, nevermind, that's n0t
18:19:26 <c_wraith|N10> a good example
18:20:08 <c_wraith|N10> Do you really need vacuum to see the difference?
18:20:28 <Algebr> eh, I believe you.
18:20:53 <roboguy_> johnw: hmm. I should probably solidify my understanding of natural transformations first. the only thing that I don't like about Conceptual Mathematics is that it doesn't seem to go over things like natural transformations and adjunctions
18:21:18 <c_wraith|N10> You should check out vacuum, though. It's pretty great.
18:23:24 <HowToPrin> Hi all
18:23:31 <johnw> hello!
18:23:32 <HowToPrin> I have printing troubles
18:23:33 <roboguy_> dmwit: hmm, what's the difference from the normal Either?
18:23:35 <HowToPrin> :(
18:23:42 <HowToPrin> Wndering if anyone could give a quick hand
18:24:14 <HowToPrin> Here's my code: http://lpaste.net/3513568309402402816
18:24:18 <HowToPrin> handleDescriptions is the problem
18:24:25 <HowToPrin> which is called by main
18:24:50 <roboguy_> HowToPrin: the first thing I see is that you *definitely* shouldn't be doing !! 0
18:25:01 <roboguy_> also, what do you mean by worK?
18:25:11 <Dashkal> I feel like a function of this type should exist, but hoogle comes up empty: groupByN :: Int -> [a] -> [[a]]  Am I missing something obvious?
18:25:26 <HowToPrin> roboguy_: Really? How come? I'm just indexing a list.
18:25:29 <roboguy_> Dashkal: what should it do?
18:25:31 <S11001001> HowToPrin: Infinite type?
18:25:33 <roboguy_> HowToPrin: you should use pattern matching
18:25:38 <dmwit> roboguy_: I intend the new type to satisfy the Alternative laws.
18:25:38 <HowToPrin> roboguy_: Here's my error: Could not deduce (PrintfType (m a0))       arising from the ambiguity check for `handleDescriptions'
18:25:42 <dmwit> roboguy_: Check this out:
18:25:46 <roboguy_> HowToPrin: also, you definitely, *definitely* should have type signatures
18:25:46 <dmwit> > Left "foo" <|> empty
18:25:48 <lambdabot>  Left ""
18:25:53 <Dashkal> Groups the input lists into sections of n, with the tailing one allowed to have fewer entries.
18:26:29 <Dashkal> I could whip something up with recursion and splitAt quickly enough I suppose./
18:26:31 <roboguy_> HowToPrin: errors get much easier if you add type signatures to all top level definitions, so I'd start with that
18:26:33 <S11001001> @ty printf "%s"
18:26:33 <lambdabot> PrintfType r => r
18:27:07 <roboguy_> dmwit: your's would do result in Left "foo" (effectively)?
18:27:12 <dmwit> right
18:27:17 <HowToPrin> roboguy_: I'm not sure how to give those functions a signature
18:27:26 <HowToPrin> roboguy_: When all they do is printf
18:27:40 <HowToPrin> S11001001: What did you mean by infinite type?
18:27:45 <dmwit> But in the absence of empty, the laws say much less...
18:27:51 <S11001001> HowToPrin: just talking to myself...
18:27:59 <dmwit> So there's a free choice about how to craft the Alt instance.
18:28:00 <Algebr> I'm confused why type constructors can take arguments...anyone?
18:28:03 <roboguy_> HowToPrin: well, I assume you want them to take a 2D list of Ints and print them, or something like that? printTitles :: [[Int]] -> IO ()
18:28:17 <roboguy_> Algebr: why are you confused?
18:28:20 <HowToPrin> Ah.. so the key is
18:28:23 <HowToPrin> -> IO
18:28:32 <Algebr> roboguy_: Why would they need to?
18:28:37 <roboguy_> HowToPrin: essentially, yeah
18:28:39 <geekosaur> an example would be Maybe
18:28:41 <roboguy_> Algebr: [] is a type constructor
18:28:46 <roboguy_> [Int] is a type constructed by it
18:28:46 <S11001001> @hoogle PrintfType
18:28:47 <lambdabot> Text.Printf class PrintfType t
18:28:47 <lambdabot> Text.Printf class HPrintfType t
18:28:48 <dmwit> Algebr: So that you can have polymorphic containers.
18:28:52 <roboguy_> [Int] can also be written [] Int
18:28:53 <Dashkal> Well, this does it: let groupByN n as = let (sec, rest) = splitAt n as in sec : groupByN n rest
18:28:58 <geekosaur> it's not really menaingful by itself, but you can use it to make (for example) Maybe Int
18:29:15 <novochar> ("foo", "bar") is a Map right? How would you get the ghci interpreter to tell you this?
18:29:29 <dmwit> ("foo", "bar") is not a Map.
18:29:38 <Algebr> dmwit: Ah, that's nails it. Thank you.
18:29:38 <roboguy_> Algebr: another example is (,) which is a type constructor that takes two arguments
18:29:39 <dmwit> You can ask ghci for the type of an expression with :t <expr>
18:30:06 <Algebr> roboguy_: So is it instead of having to do stuff like ArrayList<T>, etc?
18:30:11 <roboguy_> HowToPrin: do you know what I mean by using pattern matching?
18:30:13 <novochar> dmwit: isn't [Char] derive Eq?
18:30:27 <novochar> Sorry for the incorrect wording there, not sure how to phrase it.
18:30:27 <dmwit> novochar: [Char] is an instance of Eq.
18:30:33 <HowToPrin> roboguy_: No actually. Care to elaborate?
18:30:38 <novochar> and "foo" is an instance of [Char]
18:30:45 <dmwit> "foo" has type [Char].
18:30:46 <roboguy_> Algebr: well, it depends on what you mean. sometimes type constructors don't actually contain any values of the type they are given (although that's a more advanced topic)
18:30:48 <novochar> (Eq k, Eq a) is an instance of Map
18:31:06 <dmwit> (Eq k, Eq a) is a constraint, and is completely unrelated to Map.
18:31:19 <dmwit> It is also unrelated to tuples.
18:31:36 <dmwit> (Eq k, Eq a) is not the type of a pair of things, each of which are instances of Eq.
18:31:47 <novochar> dmwit: (Eq k, Eq a) is listed as an instance of Map on https://www.haskell.org/ghc/docs/6.12.2/html/libraries/containers-0.3.0.0/Data-Map.html
18:31:50 <dmwit> It is not the type of any expression, in fact.
18:32:20 <roboguy_> HowToPrin: something like 'printTitle ((s:ss):rest) = printf "%s" s' prints the first element of the first element of the given String list of lists
18:32:22 <roboguy_> for example
18:32:23 <dmwit> novochar: That says that Maps are comparable for equality when their key and value types are.
18:32:43 <dmwit> novochar: Map is not a class, so it can't have instances.
18:32:54 <HowToPrin> roboguy_: You recommend that as opposed to indexing?
18:32:55 <roboguy_> Algebr: a type constructor is sort of like a function at the type level
18:33:02 <roboguy_> HowToPrin: definitely
18:33:12 <novochar> What are some things I should read up on (maybe again) to create an instance of Map?
18:33:28 <dmwit> novochar: You might like the "fromList" function.
18:33:34 <dmwit> novochar: It turns a list of key/value pairs into a Map.
18:33:39 <dmwit> :t fromList
18:33:40 <lambdabot>     Not in scope: `fromList'
18:33:40 <lambdabot>     Perhaps you meant one of these:
18:33:40 <lambdabot>       `IM.fromList' (imported from Data.IntMap),
18:33:41 <roboguy_> HowToPrin: pattern match errors are much easier to read and it's more obvious from the code if you've covered every possibility
18:33:42 <dmwit> :t M.fromList
18:33:43 <lambdabot> Ord k => [(k, a)] -> M.Map k a
18:33:49 <roboguy_> (which you didn't, in this case)
18:34:30 <roboguy_> HowToPrin: also, you can avoid using snd and fst there with pattern matching
18:34:36 <roboguy_> it makes things much easier to read
18:34:52 <novochar> let b = Data.Map.fromList [(1,2), (3,4)] --?
18:35:13 <dmwit> That looks good to me, modulo that not actually being a comment. =)
18:35:14 <HowToPrin> roboguy_: OK. Can I show you the type of data I'm handling? Maybe you can help with type signatures.
18:35:21 <roboguy_> HowToPrin: yeah
18:35:33 <dmwit> > let (--?) = const in "why?" --? "to confuse beginners"
18:35:34 <lambdabot>  "why?"
18:36:01 <petrie> could anyone recommend a fairly simple image processing library? or know of one for that matter?
18:36:09 <novochar> > (--?)
18:36:11 <lambdabot>  Not in scope: `--?'
18:36:15 <novochar> > --?
18:36:16 <lambdabot>  <hint>:1:1: parse error on input `--?'
18:36:17 <roboguy_> dmwit: haha, I've actually run into that before
18:36:24 <Ralith> petrie: juicypixels is nice
18:36:38 <dmwit> > let a --? b = 2 * a + logBase 10 b in 32 --? 1000
18:36:38 <johnw> and juicy
18:36:40 <lambdabot>  67.0
18:36:51 <novochar> Oh wow :)
18:36:55 <petrie> Ralith: Thanks I'll have a look into it!
18:37:50 <HowToPrin> roboguy_: Great thanks.
18:37:56 <HowToPrin> roboguy_: Have a look at the comments added: http://lpaste.net/3513568309402402816
18:38:29 <HowToPrin> roboguy_: Not sure how to signify that kind of data in a type sig...
18:39:14 <roboguy_> HowToPrin: looks like the types are "printTitles :: [[(String, String)]] -> IO ()", "printDescriptions :: [(String, String)] -> IO ()" and "handleDescriptions :: [[(String, String)]] -> IO ()"
18:39:28 <guesting> Silly question: How do you run a ghc compiled file on Windows?
18:40:01 <HowToPrin> roboguy_: Cool. For some reason I used (a, b) instead of (String, String)
18:40:21 <hiptobecubic> guesting, assuming you compiled it on windows, you run it the same way you run anything else
18:40:41 <roboguy_> HowToPrin: (a, b) must match all types "a" and "b", so it was too specific when you tried to use them as Strings. but that's something to learn about later, don't worry about it now
18:41:00 <ezrios> Can you overwrite let bindings in ghci?
18:41:06 <roboguy_> ezrios: yeah
18:41:09 <guesting> hiptobecubic: Double clicking? It doesn't know what application to open it with...
18:41:09 <ezrios> hm
18:41:12 <HowToPrin> roboguy_: Wow. My initial error is gone. Is there a reason type signature changes the way the functions behave?
18:41:37 <roboguy_> HowToPrin: well... sort of. printf is actually a pretty complex and advanced thing in haskell because it takes multiple arguments
18:41:39 <ezrios> roboguy_: ah, so you can
18:41:48 <hiptobecubic> guesting, ah ok, Try opening it with cmd.exe
18:41:56 <ezrios> weird, I thought that my new functions were not being used for some reason...
18:41:57 <roboguy_> HowToPrin: it would probably be better to use print and putStrLn for now
18:42:02 <hiptobecubic> guesting, which is the terminal prompt in windows.
18:42:12 <guesting> hiptobecubic: It says that it's not a recognized command
18:42:21 <hiptobecubic> guesting, did you browse and find it?
18:42:26 <hiptobecubic> guesting, what version of windows are you on?
18:42:28 <guesting> yes
18:42:30 <guesting> windows 7
18:42:32 <roboguy_> guesting: what is the file extension?
18:42:33 <guesting> im in the directory
18:42:38 <guesting> no file extension
18:42:59 <hiptobecubic> Surely someone else in here is using windows?
18:43:02 <roboguy_> guesting: if you right click and go to properties, the file name has no extension?
18:43:29 <guesting> The compilation I did was ghc --make Main.hs -o output -O2
18:43:34 <hiptobecubic> roboguy_, oh good point. probably should be .exe
18:43:35 <HowToPrin> roboguy_: OK one more thing that's tricky. I want handleDescriptions to do recursion on "rest" of s, until s is empty. How do I write a base case for that given the signature that we have?
18:43:36 <Algebr> In the haskell wiki All About Monads, it says that "return is a type constructor that creates monad instances", but if return is a type constructor, then why doesn't it start with a capital letter?
18:43:40 <roboguy_> guesting: oh. try using -o output.exe
18:43:43 <hiptobecubic> guesting, try output.exe
18:43:49 <guesting> I should note that I'm fine on linux, just this is my first time doing this on windows
18:43:54 <guesting> oh
18:43:55 <guesting> hahaha
18:44:06 <HowToPrin> roboguy_: So... handleDescriptions [] = *do stuff to handle empty list*
18:44:08 <hiptobecubic> guesting, windows uses extensions instead of magic numbers to determine what files are
18:44:10 <roboguy_> HowToPrin: yep
18:44:30 <HowToPrin> roboguy_: Is there a way to... do nothing?
18:44:35 <guesting> ah
18:44:36 <guesting> great
18:44:38 <guesting> thank you!!
18:44:39 <HowToPrin> roboguy_: Same way other languages have "return"
18:44:42 <roboguy_> HowToPrin: make sure to put that before the other case. patterns are matched in order, and if the other pattern is "handleDescriptions xs = ...",  xs matches everything
18:44:43 <djahandarie> Algebr, your reasoning is correct. It's not a type constructor.
18:44:45 <roboguy_> HowToPrin: return ()
18:45:00 <HowToPrin> roboguy_: Yes I'll make sure of that
18:45:08 <HowToPrin> roboguy_: Thanks so much for your help
18:45:13 <roboguy_> HowToPrin: by the way, return in haskell is actually a lot different than in other languages. unfortunately, it can be superficially similar. that's something to keep in mind
18:45:15 <roboguy_> HowToPrin: no problem!
18:45:23 <hiptobecubic> guesting, what did it do, actually? Launch a terminal?
18:45:28 <HowToPrin> roboguy_: Roger that.
18:45:57 <guesting> hiptobecubic: I actually for some reason have a bug, even though I'm using the example from threepenny-gui
18:46:09 <guesting> hiptobecubic: Let me figure this out first
18:46:20 <roboguy_> Algebr: it isn't a type constructor.
18:46:26 <hiptobecubic> guesting, sure. i was just curious... although you remind me now that i wanted to try out threepenny :0
18:46:32 <roboguy_> if that's what is in the wiki, it is a mistake
18:46:35 <hiptobecubic> guesting, :)
18:46:48 <hiptobecubic> brb
18:46:58 <guesting> hiptobecubic: It seems like the best gui option by FAR
18:46:59 <Algebr> hmm, guess its a typo in the docs.
18:47:20 <dmwit> I'm confused. I can (Left "foo" <|> Right 3) in ghci, but :i Alternative does not list an instance for Either.
18:47:23 <dmwit> What gives?
18:47:24 <guesting> hiptobecubic: Let me know if you can compile the example
18:47:29 <roboguy_> Algebr: it could be defined in terms of a *data* constructor, but it doesn't *have* to be
18:47:54 <roboguy_> and return itself wouldn't technically be a data constructor regardless
18:48:37 <roboguy_> dmwit: that doesn't work for me at all
18:48:55 <dmwit> err
18:49:03 <dmwit> I have a bunch of imports. Let me track down the minimal set.
18:50:01 <djahandarie> dmwit, and perhaps some other stuff in a .ghci file (I've been confused by things I've forgotten in there in the past)
18:50:22 <dmwit> roboguy_: Control.Applicative and Control.Monad.State are enough
18:50:53 <dmwit> Hm, I just have a :def k! and a :set -v0 in there.
18:51:25 <ezrios> woo
18:51:45 <dmwit> djahandarie: still seems to happen with no .ghci file
18:51:48 <sinelaw> anyone with NLP experience here?
18:52:09 <roboguy_> dmwit: hmm, I see the instance in ghci-7.8 but not ghci-7.6.3
18:52:15 <djahandarie> instance Alternative Maybe -- Defined in `Control.Applicative'
18:52:27 <roboguy_> djahandarie: Left and Right are for Either
18:52:39 <djahandarie> Arg, lol
18:52:45 <dmwit> roboguy_: huh!
18:52:48 <guesting> hiptobecubic: In the docs it should be "Just 10000", not "10000", fyi
18:52:51 <dmwit> okay, probably a known bug, then
18:53:09 <djahandarie> I confirm I don't see it either in 7.4.1
18:53:32 <djahandarie> (Also confirming that I'm apparently blind in the process)
18:53:41 <roboguy_> I *think* I ran into something else like that with 7.6.3, but I don't remember if it was a bug or if it was my mistake
18:54:53 <roboguy_> dmwit: the (conceptual) problem with the Alternative Either instance, though, is that you need some kind of constraint on the first type argument
18:55:29 <dmwit> roboguy_: Right; like I said, instance Monoid m => Alternative (Either' m)
18:55:29 <djahandarie> Is there some notion of "simplest definition which doesn't ignore arguments?"
18:55:36 <roboguy_> dmwit: ahh, right
18:55:56 <roboguy_> djahandarie: I'm not totally sure what you mean, but probably no
18:56:13 <djahandarie> Hmm, to be more specific, "simplest definition which doesn't ignore information"
18:56:22 <mwhitfield> simplest definition of what?
18:56:27 <roboguy_> dmwit: isn't that what edwardk's either package does, actually
18:56:30 <dmwit> djahandarie: Should \a b -> a or \a b -> b be the simpler definition for a -> a -> a?
18:56:42 <dmwit> roboguy_: Hm. Which package?
18:56:47 <roboguy_> dmwit: either
18:56:48 <djahandarie> dmwit, I would say those are equally simple.
18:56:59 <roboguy_> djahandarie: what is the rigorous definition of "simplest"?
18:57:44 <dmwit> either looks nice, thanks.
18:57:53 <dmwit> roboguy_: I think that's djahandarie's question, too. =)
18:58:28 <djahandarie> For example, (a -> b) -> [a] -> [b] can be implemented by a lot of things. Some of those things ignore arguments (like just returning []), some of those things don't ignore arguments entirely but still ignore information (like returning [f x]), and some of those things don't ignore information but do more computation than others (say, reversing the list after mapping).
18:58:56 <S11001001> heh, -fwarn-dodgy-imports
18:58:57 <S11001001> great name
18:59:08 <roboguy_> djahandarie: well, you can see which it is with the yoneda lemma
19:00:24 <roboguy_> hmm, kind of anyway
19:01:26 <dmwit> djahandarie: I suspect the argument about order is going to get you in trouble.
19:01:50 <dmwit> djahandarie: But dropping that, probably "mentions each bound variable exactly once" probably isn't a bad definition.
19:02:10 <roboguy_> djahandarie: if you pass in id, you can see which definition it is
19:02:18 <roboguy_> even if you don't see the source code
19:03:42 <haasn> how about this for “simplest definition which doesn't ignore arguments”:
19:03:57 <haasn> f a b c .. z = a `seq` b `seq` c `seq` .. z `seq` undefined
19:04:25 <haasn> or f !a !b !c .. !z = undefined
19:05:15 <mwhitfield> welp, today I learned "f !a = .." is a thing
19:05:49 <roboguy_> haasn, dmwit, djahandarie: how about if someFunction id x = x, it is the simplest (when it's type cannot allow for the trivial definition someFunction _ x = x)?
19:06:07 <roboguy_> the type djahandarie gave, for example, would not allow for someFunction _ x = x
19:07:03 <haasn> (actually it would. what you mean is something else)
19:07:17 <roboguy_> haasn: what do you mean?
19:07:35 <roboguy_> someFunction _ x = x cannot be of type "(a -> b) -> [a] -> [b]"
19:07:39 <carter> dmwit: no hac phi?
19:07:50 <haasn> roboguy_: oops, I was looking at :: a -> a -> a
19:08:19 <roboguy_> this seems sort of related to the fact that "forall r. ((a -> r) -> f r)" is isomorphic to "f a"
19:08:50 <haasn> given a Functor constraint on f
19:09:05 <roboguy_> yeah
19:10:31 <roboguy_> actually, hmm do you need the Functor constraint?
19:10:52 <roboguy_> I suspect that you don't
19:11:13 * hackagebot type-structure 0.1.0 - Type structure analysis  http://hackage.haskell.org/package/type-structure-0.1.0 (NikitaVolkov)
19:11:56 <roboguy_> haasn: yeah, you don't need any constraints
19:12:13 <c_wraith|N10> Isn't that yoneda?
19:12:18 <roboguy_> c_wraith|N10: yep!
19:12:39 <roboguy_> fromYoneda :: forall r. ((a -> r) -> f r) -> f a; fromYoneda f = f id
19:12:55 <haasn> roboguy_: toYonega?
19:12:57 <haasn> Yoneda, even
19:13:39 <roboguy_> ah, right. you need it for that
19:14:15 <roboguy_> maybe
19:14:43 <roboguy_> yeah, you would have to have Functor
19:16:41 <roboguy_> anyway, equality might cause some problems sometimes, but it seems like the natural definition of "simplest" definition in this context would be when f id x = x (with a sufficiently polymorphic type for f)
19:20:08 <dmwit> carter: Hm, dunno! Haven't started up the discussion yet. But I'm graduating (fingers crossed) and I think the other two guys who help organize it are trying to schedule their end dates, too.
19:20:17 <carter> yeah I heard
19:20:18 <carter> congrats!
19:20:25 <carter> dmwit: whats your projects been again?
19:20:26 <dmwit> thanks!
19:20:46 <dmwit> I've been working on bidirectional programming -- my dissertation will be about edit lenses.
19:20:55 <carter> dmwit: its kinda crazy, i've kinda got some potential papers popping out of my project
19:21:01 <carter> dmwit: cool!
19:21:05 <carter> what sorts?
19:21:18 <carter> (link)
19:21:19 <carter> ?
19:21:33 <roboguy_> dmwit: that sounds really cool
19:21:44 <dmwit> http://dmwit.com/papers/201107EL.pdf
19:21:58 <dmwit> Or there's slides and video of the talk I gave about that stuff on my website.
19:22:43 <dmwit> The promise of edit lenses is basically three-fold: no alignment problems, symmetry, and they offer incremental operation.
19:23:06 <dmwit> Alignment isn't really an issue with the kind of lenses people typically use in Haskell-land anyway.
19:23:12 <carter> dmwit: what sort of alignment?
19:23:22 <dmwit> But it can matter when you start moving away from pure record-selection scenarios.
19:23:24 <carter> dmwit: could edit lenses be used for sparse matrices?
19:23:37 <carter> or amortized merging things?
19:23:37 <dmwit> Hm, I'm not sure!
19:23:43 <dmwit> It sounds plausible, though.
19:24:11 <carter> ok
19:24:23 <dmwit> The idea for our list-y edit language goes roughly:
19:24:33 <carter> http://dmwit.com/papers/201107EL_slides.pdf ?
19:24:34 <dmwit> you can resize, modify a given position, or reorder.
19:24:52 <dmwit> right
19:25:21 <dmwit> So if the modifications you can make to matrices fit in that collection of changes, you can probably use edit lenses.
19:25:52 <dmwit> What would you want to do with matrices and lenses?
19:26:01 <dmwit> (What transformation do you want?)
19:26:52 <carter> dmwit: i've a pretty pretty rich api for slicing (for N dim array, pickng out an N dim sub array) and projections (rank shrinking)
19:27:09 <carter> (still iterating on it)
19:27:22 <dmwit> Oh, cool.
19:27:40 <dmwit> That's actually one of the areas that we haven't covered very well yet: transformations that can change the number of "holes" in your data.
19:27:45 <carter> oh
19:27:47 <carter> heheheh
19:27:47 <dmwit> I think there's some work from the asymmetric delta lens folks.
19:27:50 <carter> sparse is even worse
19:27:54 <dmwit> Which may be adaptable.
19:28:08 <carter> in sparse you don't know where the nonzero entries are!
19:28:16 <dmwit> (Or directly usable, even, though they're less careful about incremental operations -- so sparse matrices might be more of a challenge for them.)
19:28:39 <carter> numerical linear algebra (dense and sparse both)
19:28:53 <carter> has a HUGE
19:29:02 <carter> rich space of structure
19:29:10 <dmwit> carter: I don't think sparse should be a problem for edit lenses. We don't track the actual data anyway -- that's your responsibility.
19:29:14 <dmwit> Any representation you want to use is fine.
19:29:16 <carter> well
19:29:34 <carter> dmwit: "should be"
19:29:38 <carter> is a a weasel word
19:29:39 <carter> here
19:29:40 <carter> :)
19:29:43 * dmwit nods appreciatively
19:29:45 <carter> sparse linear algebra engineering is HARD
19:30:10 <dmwit> I'm just saying we have paid more attention to this issue than most other lens frameworks.
19:30:13 <dmwit> Not that we've solved it.
19:30:19 <dmwit> necessarily
19:30:31 <carter> i want to build tools that actually compete with 30 year old gnarly fortran code
19:30:31 <dmwit> Since we haven't studied your particular problem, I can't say for sure.
19:30:33 <carter> both on perf
19:30:41 <carter> and being lightyears easier to understand and patch
19:31:42 <taktoa> ∀x, "x engineering" ∈ Hard, IMO
19:32:02 <carter> taktoa: nope, numerical computing is one of thee hardest that doesn't involve browsers
19:32:21 <taktoa> I didn't preclude that statement
19:32:24 <carter> :P
19:32:25 <carter> :)
19:32:28 <carter> i tease
19:32:51 <taktoa> also I was really tempted to make another cartesian product joke given the subject at hand
19:33:04 <taktoa> but I couldn't come up with anything
19:33:17 <carter> be glad
19:33:17 <carter> :P
19:34:04 <dmwit> I'll say another thing, which is that the hard stuff when changing the number of holes is in dealing with inductive types which you expect to change shape over time.
19:34:31 <dmwit> If the shape of the data on either side of the transformation isn't changing shape over time -- e.g. with a matrix and a slice from that matrix -- a lot of hard problems disappear.
19:35:17 <dmwit> So we still haven't studied that, but you pose an interesting (and potentially easier) subproblem that I hadn't considered before.
19:35:32 <carter> glad I can snipe :)
19:35:50 <taktoa> so I just registered for Hac NYC
19:35:54 <carter> taktoa: yay!
19:35:55 <carter> :)
19:35:56 <taktoa> since I live 20 minutes north
19:35:59 <carter> i'll be there
19:36:00 <taktoa> of the city
19:36:17 <dmwit> I'm sad I won't be there. I have friends visiting.
19:36:18 <dmwit> ah well
19:36:45 <carter> dmwit: in recompense, start reading up on the crazy rich phylogenies of problems structures in sparse linear algebra
19:37:03 <dmwit> hm =)
19:37:55 <carter> dmwit: crazily enough, sparse linear algebra kinda looks like undirected edge weighted sparse graphs in the symmetric matrix case, and directed edge weighted graphs in the general case
19:38:02 <carter> at least in the 2D case
19:38:43 <carter> and we all know graph theory is pretty deep right? :)
19:39:17 <carter> dmwit: i've actually had to force myself to *not* work on the sparse lin alg tooling
19:39:25 <carter> because i know its going to be such a deep rabbit hole
19:41:49 <mindleyhilner> hac nyc what
19:42:00 <taktoa> I am going
19:42:40 <carter> www.haskell.org/haskellwiki/Hac_NYC
19:42:42 <carter> yay
19:42:58 <taktoa> I am mostly going for the talks
19:43:08 <saml_> which talks?
19:43:10 <taktoa> I don't know what to work on
19:43:20 <taktoa> I heard there are talks on the wiki page
19:43:26 <carter> taktoa: i can help you come up wiht projects!
19:43:34 <carter> its my secret power
19:43:40 <saml_> i can help you with projects too
19:43:44 <carter> saml_: youlll be there?
19:43:50 <saml_> where?
19:43:56 <taktoa> well I have a little project right now, but it's progressing slowly, and the code I've written is garbage so far
19:43:57 <carter> nyc haskell hackathon next weekend
19:44:05 <carter> taktoa: well, you can ask for a code review
19:44:07 <saml_> oh i can come
19:44:09 <taktoa> teamspeak 3 log analyzer
19:44:15 <saml_> weekend? do you have link?
19:44:16 <carter> and get amazing feedback
19:44:19 <carter> www.haskell.org/haskellwiki/Hac_NYC
19:44:21 <carter> www.haskell.org/haskellwiki/Hac_NYC
19:45:06 <taktoa> I figure that I would strongly regret not going since, you know, I live so close
19:45:33 <mindleyhilner> oh wow
19:45:37 <mindleyhilner> a haskell in my town
19:46:23 <carter> mindleyhilner: theres also a monthly meetup
19:46:42 <mindleyhilner> carter: the haskell for kitties thing? went to one, wasn't really my thing
19:46:46 <carter> nope
19:46:47 <saml_> is it for young people?
19:46:47 <carter> the real one
19:46:51 <saml_> can old people come?
19:46:52 <carter> mindleyhilner: thats for noobs
19:46:57 <saml_> to hac_nyc
19:47:03 <carter> http://www.meetup.com/NY-Haskell/
19:47:15 <carter> is the fun one
19:47:30 <saml_> can i only attend saturday?
19:47:36 <mindleyhilner> man
19:47:42 <mindleyhilner> i always miss the good stuff
19:47:45 <carter> saml_: whenever you want
19:47:48 <carter> mindleyhilner: its every month
19:47:54 <carter> hac nyc is the one for marchish
19:47:57 <saml_> wait it's in brooklyn
19:47:58 <carter> er april
19:48:00 <saml_> who goes to brooklyn..
19:48:08 <carter> its in manhattan on friday
19:48:09 <carter> too
19:48:11 <carter> idk
19:48:12 <carter> you rcall
19:48:15 <dalaing> NY-Haskell has some amazing content
19:48:23 <carter> dalaing: my talk is the worst one
19:48:24 <mindleyhilner> oh, it's this week
19:48:30 <carter> literally
19:48:32 <carter> april 4-6 :)
19:48:39 <carter> register so we have an accurate head count
19:48:41 <dalaing> and I'm half a world away
19:49:32 <taktoa> when is haskell-ny?
19:49:34 <taktoa> generally
19:49:40 <saml_> oh that sounds fun
19:49:46 <carter> 3rd  wednesday each month?
19:49:47 <carter> i forget
19:49:50 <saml_> hackathon is like presentations?
19:49:55 <mindleyhilner> i >>= ny
19:50:12 <taktoa> hackathon is a) hacking b) talks c) chatting d) food
19:50:16 <taktoa> afaik
19:50:26 <saml_> so you need a laptop?
19:50:27 <mindleyhilner> carter: seems i can only make it to the waitlist
19:50:36 <taktoa> yea pretty much
19:50:38 <carter> mindleyhilner: nah, for the hackathon there a different registration
19:50:45 <carter> its hanging out and doing whatever
19:50:53 <carter> mindleyhilner: taktoa  www.haskell.org/haskellwiki/Hac_NYC
19:50:55 <taktoa> I mean you could attend without a laptop but it's probably not optimal
19:51:04 <carter> https://docs.google.com/forms/d/1taZtjgYozFNebLt1TR2VnKv-ovD2Yv5sOdSZzmi_xFo/viewform
19:51:10 <carter> taktoa: nope
19:51:12 <carter> its optimial
19:51:19 <carter> i usually just spend my time talkin with folks :)
19:51:23 <carter> at least at hacphi
19:51:25 <mindleyhilner> saturday's full :<
19:51:26 <taktoa> oh really
19:51:33 <carter> mindleyhilner: nope
19:51:34 <copumpkin> full?
19:51:44 <carter> mindleyhilner: register throught http://www.haskell.org/haskellwiki/Hac_NYC
19:51:55 <carter> copumpkin: he's confused by sclv 's meetup page
19:52:01 <mindleyhilner> carter: ah, i was going through meetup
19:52:03 <carter> yes
19:52:04 <carter> i know
19:52:05 <davidthomas> Anyone interested in overlaying types on C?
19:52:07 <carter> http://www.haskell.org/haskellwiki/Hac_NYC
19:52:08 <carter> http://www.haskell.org/haskellwiki/Hac_NYC
19:52:13 <carter> davidthomas: done
19:52:38 <davidthomas> carter: where?
19:52:46 <carter> davidthomas: sooooo many projects
19:52:47 <c_wraith|N10> Huh. I want to introspective laziness. Or something.
19:52:56 <carter> c_wraith|N10: ghci can do that1
19:53:06 <carter> c_wraith|N10: though ghcjs has better hooks for it I think
19:53:23 <carter> theres actually going to possible be 1-2 GSOC projects related ot that I think
19:53:24 <taktoa> davidthomas: cyclone, I think, does it
19:53:24 <c_wraith|N10> I don't mean for debugging. I mean as part of the algorithm.
19:53:27 <saml_> i have no haskell coding ability
19:53:38 <saml_> can i find mentor at hac_nyc?
19:53:49 <carter> saml_: heck, yes
19:53:54 <saml_> http://www.haskell.org/haskellwiki/Hac_NYC/Projects  this thing doesn't even load
19:54:03 <saml_> now it loads
19:54:04 <carter> wait longer
19:54:06 <davidthomas> taktoa: link?
19:54:12 <carter> davidthomas: google  it :)
19:54:14 <c_wraith|N10> I have a function that results in <<loop>> when it's complete, but is productive before that.
19:54:15 <carter> cyclone project
19:54:16 <taktoa> http://en.wikipedia.org/wiki/Cyclone_(programming_language)
19:54:28 <carter> saml_: not all projects are listed there
19:54:30 <carter> saml_: just come
19:54:32 <carter> and learn
19:54:35 <carter> and stuff
19:54:36 <saml_> okay
19:54:48 <saml_> free pizza, right?
19:54:54 <carter> saml_: idk
19:54:59 <carter> does it say that?
19:55:07 <carter> i'm not the organizer, just a voluntary marketing monkey
19:55:13 <carter> who helps out on haskell hacking
19:55:51 <c_wraith|N10> I just want to detect that it's about to loop, and output [] instead. Obviously, I'm doing something wrong.
19:55:54 <davidthomas> carter: I did, but there are too many things called cyclone :-P
19:56:09 <davidthomas> taktoa: thanks :)
19:56:18 * hackagebot th-instance-reification 0.1.1 - Fixed versions of instances reification functions  http://hackage.haskell.org/package/th-instance-reification-0.1.1 (NikitaVolkov)
19:56:24 <copumpkin> saml_: if all you want is the free pizza, that seems a bit exploitative. You've been around here for a while :P
19:56:34 <taktoa> honestly
19:56:38 <taktoa> that is one fucking long con
19:56:45 <taktoa> if you joined a haskell irc channel
19:56:52 <taktoa> to get free pizza, months in advance
19:57:12 <saml_> yay free pizza
19:57:14 <carter> yeah
19:57:17 <saml_> what project should i work on?
19:57:24 <carter> i think javascript or ruby has more freepizza
19:57:36 <davidthomas> Cyclone doesn't look like quite what I want - was hoping for static checks and zero runtime overhead
19:57:40 <mindleyhilner> carter: what exactly is "food restrictions" asking me on the sign-up form?
19:57:42 <carter> heck java has pizza  http://en.wikipedia.org/wiki/Pizza_(programming_language)
19:57:50 <carter> mindleyhilner: if you ahve allergies or dietary idk
19:57:59 <carter> mindleyhilner: i'm not an organizer
19:58:00 <carter> i know nutting
19:58:06 <saml_> i think there will be a lot of people
19:58:13 <saml_> and electricity problem
19:58:17 <carter> ask sclv  or mightybyte or ryantrinkle or kat
19:58:28 <carter> saml_: i think yer trolling
19:58:28 <carter> :)
19:58:39 <saml_> no a bit serious.. are you really prepared?
19:58:49 <carter> the spaces are quite big
19:58:56 <carter> and regularly host large tech events
19:58:57 <sclv> just show up and hang out
19:59:03 <sclv> there will be plenty to hack on
19:59:05 <saml_> ah i see
19:59:14 <sclv> a project can be “write a simple program"
19:59:15 <carter> sclv: how many people have signed up?
19:59:17 <sclv> if thats what you want to do
19:59:21 <sclv> about 90 signed up
19:59:31 <carter> sweet
20:00:05 <saml_> i don't have to register for meetup.com, right?
20:00:06 <haasn> c_wraith|N10: whatever you do, do *not* use trying_ _NonTermination (return $! x)
20:00:14 <copumpkin> saml_ is the longest troll ever
20:00:37 <saml_> you get to meet the longest troll in real life
20:00:38 <copumpkin> you were around before I started :)
20:00:48 <carter> i've been around a while, just not on irc
20:00:54 <copumpkin> and I started in late 2008
20:01:04 <carter> copumpkin: irc or haskell?
20:01:13 <copumpkin> I've been on IRC a lot longer than I've been doing Haskell
20:01:15 <dmwit> How come ghci loads this file fine, but cabal build demands that I turn on DoAndIfThenElse? Isn't that extension part of the standard now?
20:01:17 <copumpkin> that was Haskell
20:01:25 <carter> i think 2004/2005 for me
20:01:37 <roboguy_> davidthomas: I've wondered how far you could get doing something like that
20:01:37 <c_wraith|N10> haasn: why not?
20:01:47 <haasn> I've been on IRC since age 8 or something
20:01:50 <saml_> i learned haskell in school and stop using it :P
20:02:03 <haasn> c_wraith|N10: will not work in GHCi or the threaded RTS or possible implementations other than GHC
20:02:08 <carter> dmwit: i think cabal defaults to h98 and ghc  defaults to h2010
20:02:35 <carter> unless the cabal file says otherwise
20:02:37 <c_wraith|N10> dmwit: cabal sets haskell98 by default
20:02:50 <dmwit> whyyyy
20:03:11 <c_wraith|N10> ask dcoutts
20:03:12 <carter> dmwit: legacy
20:03:30 <sclv> saml_: meetup.com listings are just there to avoid confusion
20:03:35 <sclv> you can avoid it entirely
20:03:46 <saml_> great sclv
20:04:31 <taktoa> I started haskelling in 2010, IIRC
20:04:46 <taktoa> started getting into IRC around the same time, actually
20:05:01 <taktoa> I knew of IRC before that but didn't use it much
20:06:52 <carter> i  blame copumpkin  for starting my habittual irc habbit
20:06:57 <carter> *habit
20:12:01 <mindleyhilner> carter: regged, thanks
20:12:07 <carter> woot
20:13:05 <dmwit> I conclude that there are roughly 10x as many Haskell hackers in NYC as there are in Philadelphia.
20:13:08 <dmwit> shocking
20:13:20 <dmwit> [ed. note: not actually shocking]
20:13:27 <taktoa> why is that not shocking
20:13:38 <taktoa> CMU is in philadelphia
20:13:46 <dmwit> I... what
20:14:02 <dmwit> Well. CMU is in Pittsburgh.
20:14:18 <dmwit> Anyway, I think it's not shocking because I believe there's much more software development in general in NYC than in Philadelphia.
20:14:53 <dmwit> Additionally, there are about 6x as many people in NYC as there are in Philadelphia.
20:14:56 <mindleyhilner> yeah except a huge portion of that is ruby nodejs webdev sludgefest
20:15:34 <dmwit> I don't think the language of the dev jobs is relevant to the language interests of the devs, really.
20:16:20 * hackagebot cabal2ebuild 0.0.15.6 - make gentoo's .ebuild file from .cabal file  http://hackage.haskell.org/package/cabal2ebuild-0.0.15.6 (YoshikuniJujo)
20:19:29 <taktoa> oh, derp
20:19:31 <taktoa> sorry dmwit
20:19:46 <taktoa> pennsylvania is a blur to me
20:19:52 <taktoa> also sleep deprivation
20:20:13 <taktoa> two large p-starting cities in the same state
20:20:47 <Rufflewind> that also starts with p
20:21:15 <taktoa> pennsylvania, you mean?
20:21:31 <Rufflewind> yea the state
20:21:48 <dmwit> Well, you're doing better than me. I didn't even know CMU was in Pennsylvania.
20:22:11 <tikhon> dmwit: I've been really liking fgl, coincidentally
20:22:30 <dmwit> tikhon: That's great!
20:22:46 <dmwit> What have you been doing with it?
20:23:00 <tikhon> generating mazes
20:23:36 <tikhon> I'm using that to finally start the blog I've been thinking about for far too long :)
20:23:43 <dmwit> haha, fun!
20:23:49 <taktoa> dmwit: I recently visited CMU on college visits
20:23:55 <taktoa> got rejected but whatever
20:24:04 <dmwit> taktoa: Oh, bummer!
20:24:10 <taktoa> my interviewer for the school was a haskeller which was pretty cool
20:24:18 <tikhon> it's an interesting problem for functional programming because it requires both graph algorithms and randomness
20:24:21 <taktoa> we talked for like 1.5 horus
20:24:23 <taktoa> *hours
20:24:44 <tikhon> almost everyone I know from CMU is very pro-ML rather than Haskell :(
20:24:44 <taktoa> I'm almost certainly going to UIUC
20:24:57 <taktoa> yeah that's what he said about the CS department there
20:25:12 <taktoa> they hate haskell because laziness and monads are hard to teach
20:25:14 <tikhon> they believe Harper too much about laziness
20:25:26 <taktoa> and hard to reason about, according to them
20:25:38 <dmwit> Well, I think CMU has an ML bias in part because they have their own ML compiler that they use for language experiments.
20:25:45 <tikhon> still, at least they do functional programming at all
20:26:06 <dmwit> Language implementations aren't that hard, but building up all the infrastructure you need to have a compiler that doesn't suck yet is still small enough to modify is kind of hard.
20:26:21 <taktoa> oh, I am pretty excited
20:26:30 <taktoa> because I got a scholarship to study abroad at UIUC
20:26:39 <taktoa> and one of the options is university of bristol
20:26:39 <dmwit> Cool. Where do you think they'll go?
20:26:48 <dmwit> s/they'll/you'll/ of course
20:26:51 <taktoa> which has a haskell research group
20:27:10 <taktoa> I'm going to major in aerospace engineering, probably
20:27:20 <taktoa> but I want to get a masters in CS
20:27:48 <tikhon> I've found planning ahead that far rather ineffective
20:28:00 <taktoa> oh I figure my plans will change
20:28:11 <taktoa> but you know, I make plans anyway
20:28:21 <taktoa> because at least then I'm not groping in the dark
20:39:54 <taktoa> bad math joke incoming
20:39:55 <taktoa> "I like my women like I like my topological manifolds...
20:40:03 <taktoa> ... homeomorphic to a 2-torus and not subject to the hairy ball theorem"
20:43:37 <athan> hahahahaha
20:44:33 <roboguy_> that's the dirtiest math joke I've ever seen
20:44:54 <taktoa> :)
20:44:59 <taktoa> it's a taktoa original
20:48:58 <copumpkin> heh
20:51:48 <Algebr> Is it not possible to make your own typeclasses that are derivable?
20:53:13 <tikhon> I think you can use generics for that
20:53:24 <tikhon> I've never used it, but there's a package you can look at: http://hackage.haskell.org/package/generic-deriving
20:55:34 <Algebr> Do Haskell people generally shrug off the notion that classes and methods are misnamed? At least somewhat confusing for OO programmers?
20:55:45 <tikhon> basically, yeah
20:55:50 <copumpkin> misnamed?
20:55:52 <tikhon> I mean, OO programmers aren't a big deal
20:55:52 <roboguy_> Algebr: it is unfortunate that they share the names
20:56:17 <Algebr> roboguy_: Share that view on return?
20:56:19 <roboguy_> tikhon: I don't know about *that*, since they are probably the majority (at the very least, at the moment)
20:56:24 * hackagebot cabal2ebuild 0.0.15.7 - make gentoo's .ebuild file from .cabal file  http://hackage.haskell.org/package/cabal2ebuild-0.0.15.7 (YoshikuniJujo)
20:56:25 <tikhon> meh
20:56:29 <roboguy_> Algebr: return could definitely be named something better
20:56:39 <roboguy_> "pure" is better
20:57:11 <tikhon> that said, I usually call typeclasses "typeclasses" and not "classes"
21:01:25 * hackagebot http-client 0.2.3 - An HTTP client engine, intended as a base layer for more user-friendly packages.  http://hackage.haskell.org/package/http-client-0.2.3 (MichaelSnoyman)
21:04:23 <mgsloan> j
21:16:01 <athan> roboguy_: Why even have terms?
21:16:07 <athan> roboguy_: Why not colors? :)
21:17:41 <athan> ...or audio haha
21:17:42 <roboguy_> athan: reminds me of colorForth
21:17:46 <athan> colorForth?
21:18:12 <tikhon> athan: it's exactly what it sounds like: a variant of Forth where color is part of the syntax
21:18:20 <tikhon> http://www.colorforth.com/cf.htm
21:18:38 <tikhon> for example, you normally define forth words (ie functions) using a :
21:18:42 <tikhon> : foo do some stuff
21:18:49 <roboguy_> red and green seem like strange choices though
21:18:51 <tikhon> in colorForth, you would do it by making foo red instead
21:19:03 <apples> has anyone read beginning haskell? is it worth recommending to a beginner over LYAH?
21:19:11 <athan> ehhhhhhh
21:19:33 <tikhon> apples: I haven't read it, but it looks like a somewhat suspicious publisher
21:20:04 <athan> tikhon: I really want to create a shape that abides by all the structures used in haskell
21:20:10 <tikhon> I'd stick to LYAH, especially since it's free
21:20:17 <athan> tikhon: For instance, like a near-semi ring for ADTs
21:20:25 <roboguy_> athan: a shape?
21:20:37 <athan> roboguy_: Yep, not sure how to represent it yet
21:20:43 <athan> roboguy_: Something visual
21:20:54 <apples> the ToC doesn't seem all that bad, but you're right about the weird publisher
21:21:02 <athan> roboguy_: It feels like a manifold, plays like a...
21:21:10 <athan> *stroke*
21:21:24 <tikhon> the Haskell commmunity has been very good about making books available online, so I figure we may as well take advantage of that
21:22:46 <tikhon> apples: if they speak Russian, you could recommend О Haskell which looks very good: http://ohaskell.ru/
21:22:51 <roboguy_> yeah. LYAH, RWH, that book on concurrent haskell, all those papers...
21:23:16 <athan> roboguy_: Flushing my downloads folder right now
21:23:22 <tikhon> Yesod and Snap books as well
21:23:23 <athan> Literally 3 reams
21:23:27 <apples> they don't speak russian, i believe :) -- i've told them to read LYAH, but they can't seem to keep much interest in it
21:23:38 <tikhon> yeah, LYAH is admittedly a bit dry
21:23:42 <roboguy_> tikhon: is that related to the OO variant?
21:23:46 <tikhon> no
21:23:52 <tikhon> it's a Russian О :)
21:24:00 <tikhon> it means "about"
21:24:08 <apples> i had actually not heard of o haskell before
21:24:20 <roboguy_> I skipped ahead pretty far in LYAH, when I read it and picked up the rest as I went along
21:24:21 <tikhon> it popped up on Reddit recently
21:24:28 <athan> apples: The yesod book did it for me. After I realized the potential, then I forced myself, now I'm hear, addicted and craving ever more
21:24:38 <tikhon> a few people were keen on translating it
21:24:49 <Tekmo> athan: Just out of curiosity, what part of the yesod book convinced you the most
21:25:17 <athan> Tekmo: "...as fast as nginx..."
21:25:33 <athan> the benchmarks also when I looked it up
21:25:38 <athan> like
21:25:40 <athan> when it talked about
21:26:07 <athan> massive concurrency + lightweight threads, that really sparked my interest
21:26:21 <athan> because I was learning node at the time I googled "wtf is haskell"
21:26:45 <athan> and then I googled warp
21:26:49 <athan> and looking at the code
21:27:01 <roboguy_> Tekmo: would that Codensity encoding of Free be an example of making things more efficient with a church encoding?
21:27:20 <Tekmo> roboguy_: Yes, that is one example
21:27:30 <Tekmo> roboguy_: Although, not in the way you think
21:27:41 <athan> it was like it was written by a total badass, annihilating the world of pathetic computational speed issues
21:27:51 <athan> and then I was like "...man, I really want that..."
21:27:54 <Tekmo> roboguy_: I'm still writing up a post on this exact topic, but I will summarize it the best I can
21:28:04 <apples> ooh, sounds interesting :)
21:28:07 <Tekmo> roboguy_: The basic idea is that `ghc` is not good at optimizing recursive code
21:28:10 <athan> what's density?
21:28:24 <roboguy_> Tekmo: really? that's very unfortunate, considering
21:28:25 <Tekmo> roboguy_: So church encoding is a way to encode a type non-recursively
21:28:29 <Tekmo> roboguy_: Yes, it is
21:28:49 <athan> Tekmo: Woah! That's really interesting!
21:28:51 <apples> why can't GHC apply the codensity transformation automatically?
21:28:58 <Tekmo> roboguy_: More importantly, all transformations on that type are implemented non-recursively
21:29:00 <athan> Tekmo: I've been seeing this... dual... to how you express types
21:29:17 <Tekmo> roboguy_: So what happens is that you get really efficient code produced by `ghc`
21:29:23 <Tekmo> roboguy_: As a bonus, you get things like shortcut fusion for free
21:29:28 <roboguy_> huh
21:29:28 <Tekmo> roboguy_: You don't need to implement rewrite rules for it
21:29:49 <Tekmo> roboguy_: There are actually two dual ways to encode data types non-recursively
21:30:00 <Tekmo> roboguy_: They are called inductive and coinductive types
21:30:17 <Tekmo> roboguy_: Church encoding is isomorphic to the inductive encoding of a data type
21:30:29 <Tekmo> roboguy_: For example, the inductive encoding of a list is:
21:30:47 <Tekmo> roboguy_: forall x . (Maybe (a, x) -> x) -> x
21:30:59 <Tekmo> You can then show that's isomorphic to the church encoding, which is:
21:31:07 <Tekmo> roboguy_: forall x . (a -> x -> x) -> x -> x
21:31:22 <Tekmo> roboguy_: The dual encoding is coinductive, expressed like this:
21:31:29 <shachaf> I,I "Boehm-Berarducci encoding is often confused with Church encoding."
21:31:36 <Tekmo> roboguy_: exists x . (x, x -> Maybe (a, x))
21:31:52 <Tekmo> roboguy_: Notice how much that resembles `Data.List.unfoldr`
21:31:58 <roboguy_> yeah
21:32:19 <Tekmo> The basic idea is that given any recursive type like:
21:32:29 <Tekmo> data List a  = Cons a (List a) | Nil
21:32:51 <shachaf> A good exercise for this sort of thing is to show the isomorphism between these three types: newtype Fix f = Fix (f (Fix f); newtype Mu f = Mu (forall r. (f r -> r) -> r); data Nu f = forall x. Nu x (x -> f x)
21:33:01 <Tekmo> You first define a non-recursive functor that is the "base functor" for the encoding, just by adding another type parameter, `x` to the type and replacing all recursive instances of that type with `x`
21:33:06 <Tekmo> roboguy_: Like this:
21:33:12 <shachaf> (They are isomorphic in Haskell, not in a language like Agda that makes careful distinctions.)
21:33:13 <Tekmo> data ListF a x = Cons a x | Nil
21:33:20 <augur_> Tekmo: for any type A ~ Fix f, A ~ forall r. (f r -> r) -> r
21:33:29 <Tekmo> Notice how `ListF a x` is isomorphic to `Maybe (a, x)`
21:33:36 <roboguy_> Tekmo: that makes sense
21:34:07 <Tekmo> The reason those two encodings are dual is that you can think of an inductive list as one that has a function of the form:
21:34:14 <Tekmo> (ListF a x -> x) -> List a -> x
21:34:21 <Tekmo> And an inductive list has a function of the form
21:34:28 <Tekmo> (x -> ListF a x) -> x -> List a
21:34:41 <Tekmo> *coinductive list, for the last one
21:35:10 <augur_> forall s. (s -> f s) -> s -> Cofix f
21:35:16 <Tekmo> Exactly
21:35:37 <Tekmo> So both inductive types and coinductive types have nice properties other than optimization
21:35:39 <roboguy_> Cofix?
21:35:41 <augur_> i should point out that these are the types for generic fold and unfold
21:36:01 <augur_> roboguy_: greatest fixed point
21:36:06 <Tekmo> For example, you can use inductive and coinductive encodings of types to implement recursion in languages where recursion is not first-class
21:36:43 <Tekmo> ... which is pretty much all non-functional languages
21:37:03 <roboguy_> you mean recursion in types?
21:37:14 <Tekmo> Both (I think)
21:37:15 <augur_> you should also use it to implement recursion in functional languages :)
21:37:23 <Tekmo> Yeah, I agree with augur
21:37:32 <Tekmo> I think this is the principled way to implement recursion
21:37:38 <augur_> Let Conor Show the Way
21:37:38 <Tekmo> Haskell's solution is not the best, in my opinion
21:37:59 <augur_> this way also guarantees termination
21:38:08 <Tekmo> The reason why it's easier to optimize these types is that you don't have to put arbitrary limits on optimization
21:38:34 <roboguy_> haha, this is going to take a lot more thought than I thought it would
21:38:34 <Tekmo> These encodings are guaranteed to be finite and non-recursive, so you can just have the optimizer go as long as necessary with the guarantee that optimization eventually will terminate
21:38:57 <augur_> roboguy_: what are you doing?
21:39:00 <Tekmo> Contrast this with a language with unrestricted and unprincipled recursion, where you have to use weird heuristics to detect cycles and choose which part of the cycle to tighten
21:39:12 <augur_> programming with structural recursion isnt trivial fwiw
21:39:15 <roboguy_> augur_: trying to figure out the church encoding stuff
21:39:19 <augur_> roboguy_: oh
21:39:22 <Tekmo> Yeah, augur is right
21:39:29 <augur_> roboguy_: church encodings are easy
21:39:37 <Tekmo> THis makes recursive programs harder to write, but you're basically paying the cost up front
21:39:38 <roboguy_> well, I think I understand the encoding itself
21:39:48 <augur_> roboguy_: they're just the fold for the type
21:39:51 <Tekmo> Once you pay that cost, everything past that point becomes trivial
21:39:56 <roboguy_> yeah
21:40:15 <Tekmo> Like, writing a compiler to optimize a program written using inductive/coinductive types is super-trivial
21:40:23 <augur_> i mean, folding over structures is straightforward roboguy_
21:40:27 <Tekmo> You just inline everything and you're done
21:40:34 <augur_> you have some type with constructs c0, c1, c2, ...
21:40:58 <augur_> and you fold by replacing c0, c1, c2, ... with functions f0, f1, f2, ...
21:41:09 <roboguy_> Tekmo: how does the haskell optimizer know it can go as long as necessary and what sort of optimization does it do?
21:41:18 <augur_> the key is to understand what this is actually doing in terms of correspondence to programs you write
21:41:19 <roboguy_> augur_: right. it's the optimization stuff I'm not sure about, mainly
21:41:32 <augur_> oh, who knows about optimization
21:41:37 <augur_> what sort of optimization are you looking for?
21:41:39 <roboguy_> Tekmo does, haha
21:42:04 <roboguy_> augur_: Tekmo wrote a post recently that said that church encodings can improve efficiency sometimes and I was wondering about that
21:42:27 <augur_> oh, well there's no data
21:42:29 <augur_> its just code
21:42:30 <roboguy_> Tekmo: so it just inlines as much as possible which is fine since it's guaranteed to terminate?
21:42:34 <augur_> procedure
21:42:37 <Tekmo> roboguy_: Exactly
21:42:40 <roboguy_> hmm
21:42:52 <Tekmo> roboguy_: The Haskell optimizer can't do that for Haskell code because inlining is not safe for unrestricted recursion
21:43:10 <Tekmo> roboguy_: For example, if you define `ones = 1:ones`, you can't inline that or you get: `1:1:1:1:...`
21:43:14 <roboguy_> Tekmo: it can do it for church encoded stuff though?
21:43:20 <Tekmo> roboguy_: But the coinductive coding just becomes:
21:43:28 <Tekmo> ((), () -> Just (1, ()))
21:43:36 <Tekmo> ... and that's safe to inline because it's not recursive
21:44:10 <roboguy_> I don't think I've ever seen anything about this aspect of church encodings before, huh
21:44:12 <Tekmo> Notice that you can't implement `ones` using an inductive encoding
21:44:21 <Tekmo> It only works with the coinductive encoding
21:44:41 <Tekmo> The way I like to think about it is that an inductive encoding is something finite that you can evaluate completely at compile time
21:44:57 <Tekmo> A coinductive coding is like a loop where each step is finite and can be evaluated at compile time
21:45:12 <augur_> data Colist a = forall s. Colist s (s -> (a,s))
21:45:13 <augur_> iinm
21:45:33 <roboguy_> this sounds it could be surprisingly important for something I haven't seen any articles on yet. interesting
21:45:35 <augur_> ones = Colist () (\() -> (1,()))
21:45:42 <Tekmo> roboguy_: I agree
21:45:49 <Tekmo> roboguy_: That's why I'm writing up a post on it, to get it some more attention
21:46:01 <Tekmo> roboguy_: It's know in the literature, but not well known outside of that
21:46:25 <roboguy_> yeah, it stood out to me quite a bit when I read that bit in your post since the only thing I knew about church encoding was the definition of it
21:46:38 <roboguy_> and it seemed a bit unintuitive that it could speed things up
21:46:47 <Tekmo> roboguy_: For example, coinductive encodings is how `vector` is internally implemented
21:47:11 <Tekmo> roboguy_: The stream fusion optimization is basically a coinductive encoding of effectful vector generation
21:48:07 <roboguy_> I think I'm going to have to spend some time considering these things. I've heard induction vs coinduction talked about before, but I don't know much about it yet
21:48:20 <roboguy_> I'll definitely be interested in that post you're writing
21:48:36 <Tekmo> Here's a good post to read that first got me interested in this subject: http://blog.sigfpe.com/2007/07/data-and-codata.html
21:48:52 <roboguy_> Tekmo: I'll take a look at it, thanks!
21:48:59 <Tekmo> roboguy_: You're welcome!
21:50:11 <joelteon> why can't you splice patterns in expression quotes?
21:52:09 <Zerker> Is there a general functional programming channel?
21:53:33 <roboguy_> Zerker: I don't think there is. this channel's probably the closest for general fp questions
21:54:17 <Zerker> Well basically I was playing around with Nock
21:54:29 <Zerker> And found myself "inventing" a combinator
21:54:54 <Zerker> Which is essentially Y but instead of having a function explicitly recurse
21:55:11 <Zerker> It just loops it until it stops changing its argument
21:55:21 <Zerker> Any idea what the official name might be?
21:55:29 <Tekmo> until
21:55:39 <Tekmo> :t until
21:55:40 <lambdabot> (a -> Bool) -> (a -> a) -> a -> a
21:56:07 <joelteon> until doesn't do that
21:56:21 <Tekmo> Oh wait, you're right
21:56:36 <Zerker> a -> (a->a) -> a?
21:56:47 <joelteon> you need Eq a
21:56:50 <Tekmo> Eq a => a -> (a -> a) -> a
21:58:23 <copumpkin> :t iterate
21:58:24 <lambdabot> (a -> a) -> a -> [a]
21:58:24 <joelteon> it's something like dropWhile id . ap (zipWith (==)) tail
21:59:01 <Zerker> Like, fib: 0 a b -> 0 a b | n a b -> n-- a+b a
21:59:02 <copumpkin> :t find (not . null . drop 1) . group . flip iterate
21:59:03 <lambdabot>     Couldn't match type `(a0 -> a0) -> [a0]' with `[a1]'
21:59:03 <lambdabot>     Expected type: a0 -> [a1]
21:59:03 <lambdabot>       Actual type: a0 -> (a0 -> a0) -> [a0]
22:00:03 <copumpkin> :t head . fromJust . ((find (not . null . drop 1) . group) .) . flip iterate
22:00:04 <lambdabot>     Couldn't match type `(a0 -> a0) -> Maybe [a0]' with `Maybe [c0]'
22:00:04 <lambdabot>     Expected type: ((a0 -> a0) -> [a0]) -> Maybe [c0]
22:00:04 <lambdabot>       Actual type: ((a0 -> a0) -> [a0]) -> (a0 -> a0) -> Maybe [a0]
22:00:06 <copumpkin> :(
22:00:15 <copumpkin> :t ((head . fromJust . find (not . null . drop 1) . group) .) . flip iterate
22:00:16 <lambdabot> Eq a => a -> (a -> a) -> a
22:00:20 <copumpkin> >_>
22:00:43 <Tekmo> Or maybe something like: \as -> snd $ until fst $ zipWith (\a b -> (a == b, a)) as (tail as)
22:01:18 <Tekmo> I think I'm overthinking this
22:01:21 * copumpkin likes shitty golfing
22:01:26 <Zerker> combinator fib 5 1 0 =  0 8 5
22:01:30 <joelteon> @pl \a b -> (a == b, a)
22:01:30 <lambdabot> flip =<< ((,) .) . (==)
22:01:43 <copumpkin> I like that I use both head and fromJust
22:01:46 <copumpkin> next to each other!
22:02:14 <Zerker> I'm not asking how to /implement/ it(I already have, though not haskell), I'm asking if it has a name ^-^
22:02:25 <copumpkin> I wasn't answering you :P
22:02:26 <Tekmo> > let untilEq f x = let x' = f x in if (x == x') then x else untilEq f x'
22:02:27 <lambdabot>  not an expression: let untilEq f x = let x' = f x in if (x == x') then x els...
22:02:28 <copumpkin> stupid golfing is fun
22:02:46 <Zerker> I'd call it "fixpoint" but that's taken :P
22:02:51 <Zerker> Aye, that it is
22:02:54 <Tekmo> > let untilEq f x = let x' = f x in if (x == x') then x else untilEq f x' in untilEq (* 0) 1
22:02:55 <lambdabot>  0
22:02:58 <copumpkin> fixEq?
22:02:59 <copumpkin> :)
22:05:17 <Zerker> \me is kinda disbelieving of the concept that he's come up with new math nobody's ever thought of before
22:05:30 <joelteon> good
22:06:12 <Zerker> Especially since it feels less awkward(more declarative?) than explicit recursion, and is equally general
22:06:54 <Zerker> So it would be nice if upon coming across a person that's come across it, I could communicate effectively :3
22:10:24 <kakos> I have a getter of type "Foo -> Maybe String" and a setter of type "Foo -> String -> Foo". When I try to create a lens with those two, it doesn't work as a getter. "f^.myLens" throws the error "Couldn't match type ‛[Char]’ with ‛Maybe String’" Is there something I need to do to get this to work?
22:34:16 <Kneiva_> kakos: your getter returns Maybe String and you are trying to put into something that takes [Char] or plain String which won't work. You need to get that String out of the Maybe and take into account the case where it is Nothing.
22:36:37 * hackagebot mime-mail 0.4.5 - Compose MIME email messages.  http://hackage.haskell.org/package/mime-mail-0.4.5 (MichaelSnoyman)
22:36:39 * hackagebot mime-mail-ses 0.2.2.2 - Send mime-mail messages via Amazon SES  http://hackage.haskell.org/package/mime-mail-ses-0.2.2.2 (MichaelSnoyman)
23:15:35 <dmj`> I'm trying to share cabal sandboxes amongst OS's. At times I get "Warning: The package list for the local repo", which then keeps my haskell-mode from loading cabal properly, '/Users/dmj/SolidTranslate/.cabal-sandbox/packages' is missing. The repo is
23:16:23 <dmj`> the message is: "Warning: The package list for the local repo, /Users/dmj/SolidTranslate/.cabal-sandbox/packages' is missing, the repo is invalid"
23:17:04 <athan> dmj`: is that folder in your .gitignore?
23:17:15 <athan> because cabal install should populate it, right?
23:17:28 <dmj`> athan: what would this have to do with git?
23:17:54 <athan> dmj`: Having cabal packages installed that were designed for other OS's
23:18:07 <athan> or other platforms
23:18:18 <athan> git could be your middle-man
23:18:37 <dmj`> athan: I'm using virtualization to share the sandbox, not git
23:18:49 <athan> see, I think there's your hiccup
23:19:06 <dmj`> how so
23:19:30 <athan> I don't believe that multiple OS's, ghc versions, underlying shared objects, etc. could all share the same.... bones
23:19:57 <athan> the target platform should have it's own model of dependancies
23:20:42 <athan> developing with the same dependancies as other targets might require different dependancies seems contradictary
23:20:54 <athan> erm
23:21:00 <athan> hmm
23:21:02 <dmj`> correct, and it does, when you cabal install across os's the .cabal-sandbox folder creates a platform specific folder for the deps
23:21:03 <athan> how do I say this
23:21:15 <athan> correct!
23:21:27 <athan> but if you share that folder, your sandboxing is no longer a sandbox
23:21:35 <dmj`> why?
23:21:50 <athan> because other people can play in it :)
23:22:03 <athan> I'll be on in about an hour, though, so we can both walk through this
23:22:09 <dmj`> No they can't
23:22:18 <dmj`> My VM's are local
23:22:28 <athan> but they share the same sandbox folder
23:22:32 <athan> correct?
23:22:38 <dmj`> yes
23:22:40 <athan> through a shared drive
23:22:43 <athan> there's your flaw
23:22:48 <dmj`> how is that a flaw
23:22:50 <athan> they need to be isolated in their platforms
23:22:53 <dmj`> they are
23:23:06 <athan> they need their own sandboxes
23:23:14 <athan> the sandbox isn't just for development
23:23:17 <athan> it's for installation
23:23:19 <dmj`> when you cabal install across os's the .cabal-sandbox folder creates platform specific folder for the deps
23:23:26 <gal_bolle> for any french speakers: j'ai commenc une dpche sur ghc 7.8 sur linuxfr.org (http://linuxfr.org/redaction/news/sortie-de-ghc-7-8), tout coup de main apprci
23:23:29 <athan> oh!
23:23:32 <athan> I didn't know that
23:23:48 <athan> hm
23:23:53 <athan> you got me there
23:24:00 <athan> TO THE DOCS!
23:24:34 <dmj`> I've read the cabal user guide in its entirety
23:24:47 <dmj`> this will require more creative thinking
23:46:45 * hackagebot tagstream-conduit 0.5.5.1 - streamlined html tag parser  http://hackage.haskell.org/package/tagstream-conduit-0.5.5.1 (YiHuang)
23:58:23 <athan> could someone explain exestentially quantified types, and how they contrast with universal declarations?
23:58:51 <athan> I understand that universally quantified type signatures must have corrosponding inputs be purely polymorphic
23:59:39 <athan> but, would that mean that the function (if indeed the parameter is a function) that's existentially quantified would have a typeclass constraint instead?
