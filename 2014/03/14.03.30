00:09:30 <bitemyapp> takeoutweight: you want to get yelled at?
00:10:01 <bitemyapp> takeoutweight: the real point is explicit vs. implicit, IMO.
00:10:03 <takeoutweight> Yep always
00:10:17 <takeoutweight> If it brings out a definition I can lean on it's worth it
00:10:29 <bitemyapp> takeoutweight: lifting side affects, state change/transition, mutation, etc. into the type system or otherwise as an explicit construct
00:10:32 <athan> bitemyapp: You're gonna hate me...
00:10:37 <bitemyapp> rather than something that is merely "everywhere, all the time"
00:10:51 <athan> Could you relate a functor and the distributive property?
00:10:51 <bitemyapp> takeoutweight: ditching "universal ether" for proper building blocks.
00:11:21 <bitemyapp> takeoutweight: making everything known as explicit and static as possible, to aid human and machine reasoning.
00:11:31 <bitemyapp> I *like* seeing where `IO a` pops up.
00:11:56 <bitemyapp> I don't give a damn how the effects system works, as long as it's nice and composable. But it has to be explicit! No hiding! No pretending!
00:12:09 <bitemyapp> no side channel crap.
00:12:19 <bitemyapp> functions take arguments, return values. That's it. Forever and ever.
00:12:36 <bitemyapp> compiler wants to turn that into something more amenable to the machine? what. ever. I don't care.
00:13:28 <takeoutweight> Yeah, I agree with the benefits of precision in the effect system. In ML you can't type syomething as "nobody is referencing a global reference anywhere in any potential call graph of this function"
00:13:29 <athan> yeah im tired as hell actually
00:14:30 <bitemyapp> takeoutweight: so fine, you don't like pure/impure nomenclature even that though design decision is what gave rise to explicit effect typing?
00:14:36 <bitemyapp> then call it explicit effect typing.
00:14:45 <bitemyapp> similarly in Haskell, I call them sum types and product types, not ADTs.
00:15:05 <bitemyapp> but it's just nomenclature and much like syntax, not worth describing if it gets the point across mostly accurately.
00:15:21 <bitemyapp> not worth bickering over*
00:16:36 * hackagebot warp 2.1.3.3 - A fast, light-weight web server for WAI applications.  http://hackage.haskell.org/package/warp-2.1.3.3 (MichaelSnoyman)
00:16:38 <bitemyapp> takeoutweight: anything you'd like to contend there?
00:16:46 <bitemyapp> athan: how...did you fall into that?
00:17:14 <augur> takeoutweight: that is precisely what makes haskell pure
00:17:18 <takeoutweight> No. I'm trying to see if I can think of a way to articulate a distinction
00:18:09 <bitemyapp> augur: hullo again.
00:18:22 <augur> takeoutweight: and what makes ML impure -- that haskell's effects are reified as values, rather than implicitly there in the backfround
00:18:25 <augur> .. background
00:18:40 <takeoutweight> To me, haskell higher-order polymorphism buys you this nice way of stating in the types that you are using a particular abstraction that gives a particular meaning to terms of that type. So a -> (b,s) gets a very precise meaning when you call it a state monad.
00:18:43 <augur> thats also why we dont need to talk about get's denotation, vs. a references denotation
00:20:28 <bitemyapp> oh, there's the cotraverse.
00:20:40 <bitemyapp> athan: dammit man, you have me looking at cotraverse in kmett's libraries
00:20:41 <takeoutweight> But for statements of that type, they can only be meaningfully manipulated via the exact same laws that would apply to random ref-using ML code. I agree having expressive types is good, but I just want to recognize that when you're in State your living in the same equational world as ML-with-refs practically.
00:20:58 <bitemyapp> takeoutweight: no you're not
00:21:01 <augur> takeoutweight: except thats not true
00:21:37 * hackagebot shakespeare 2.0.0.1 - A toolkit for making compile-time interpolated templates  http://hackage.haskell.org/package/shakespeare-2.0.0.1 (MichaelSnoyman)
00:21:39 <augur> takeoutweight: in haskell i can write perfectly adequate functions that produce and manipulate State s a's just as i can write any other function
00:21:47 <augur> the same is not true of ML references afaik
00:21:50 <takeoutweight> like to me, replacing "get" with \(a,s) -> (s,a) isn't doing any meaningful equational reasoning. It's just inlining the definition of a function.
00:22:04 <augur> takeoutweight: except it is, because bind is just the same
00:22:25 <takeoutweight> Let me rephrase
00:22:55 <edwardk> takeoutweight: there is a BIG difference though. I can compose State with non-determinism. i can't compose reference manipulating code. you can 'snapshot the entire heap' in O(1) if you insist on viewing 'State' as being like having mutable references
00:23:02 <edwardk> that is a lot of additional power.
00:23:04 <takeoutweight> not meaningless in that its unsound, but just "no better than any kind of inlining you could get away with while being sound in ML"
00:23:45 <edwardk> so it _is_ better than just having references in ML, since a.) i don't have to worry about any other threads going in and mutating refs behind my back, and b. i can snapshot and go bck
00:23:51 <takeoutweight> Yeah I agree with that as well. That's why I ventured a defn. for pure as "working over immutable data" as the essence. Not the "equational reasoning" thought.
00:24:07 <bitemyapp> that's not what purity is
00:24:08 <augur> takeoutweight: and State s a _does_ work over immutable data
00:24:23 <edwardk> State s a is still working with immutable data
00:24:27 <bitemyapp> it's a fairly well defined and well understood concept that is not limited to just working over immutable data.
00:24:33 <augur> takeoutweight: the fact that you use `State s a` to pretend like you have mutability is irrelevant
00:24:37 <bitemyapp> it *is* working over immutable data, but it forces other things too.
00:25:08 <takeoutweight> Yeah, no I get that. So I'd buy an explanation of "purity" that says persistent data structures is the key aspect.
00:25:37 <augur> i would say purity = no implicit effects
00:26:19 <augur> which is probably an entailment of equational reasoning
00:26:34 <bitemyapp> takeoutweight: you keep fixating on mutability/immutability but that's not enough.
00:26:52 <bitemyapp> You can't have any implicit side effects of any sort.
00:27:16 <bitemyapp> takeoutweight: I've written code in Clojure that was buggy *because of* implicit side effects despite only working with immutable, persistent data structures.
00:27:29 <augur> haskell in that regard, btw, isnt actually pure, due to implicit failure
00:27:38 * bitemyapp facepalms
00:27:43 <takeoutweight> Yeah no, I don't want to lean on nontermination
00:27:48 <bitemyapp> augur: can we put that aside?
00:27:50 <augur> not non-termination
00:27:50 <takeoutweight> I'm happy to live in the "morally correct" aspect of the argument
00:27:57 <augur> haskell has implicit Either
00:27:57 <bitemyapp> bottom/exceptions are blah.
00:28:24 <augur> they sort of arent tho. i mean, in ML you can use them to do all sorts of whacky stuff
00:29:06 <augur> throwing exceptions and catching them as some sort of wonky way to do continuations or something, crazy jumps. implicit errors is another important kind of impurity
00:29:20 <augur> tho its not too bad. non-determinism is another fun one
00:31:21 <takeoutweight> I agree that code is more complicated with state, and that it makes local reasoning more difficult
00:31:48 <takeoutweight> But I think purity is not the opposite of state, as you can implement state just by pure functions
00:31:57 <takeoutweight> So there must be some other word to describe why state is hard.
00:32:09 <augur> takeoutweight: its not the opposite of state
00:32:13 <augur> it just precludes _implicit_ state
00:32:23 <bitemyapp> implicit side effects/real world fuckery
00:32:31 <augur> thats the point. implicit effects are impure. reified effects are pure.
00:32:34 <bitemyapp> not just mutation/state in itself.
00:32:39 <bitemyapp> augur: precisely!
00:32:46 <bitemyapp> takeoutweight: why do you keep fixating on state/mutation?
00:32:59 <bitemyapp> takeoutweight: you realize all implicit use of side effects breaks purity right?
00:33:08 <augur> bitemyapp: i've been saying that on twitter since before you managed to rouse takeoutweight here :p
00:33:42 <bitemyapp> takeoutweight: If I'm implicitly logging results to a file, then implicitly reading results from a file, then using that to influence the results of my function...that breaks equational reasoning.
00:34:08 <bitemyapp> takeoutweight: I didn't "mutate" any data structures, but I wasn't honest with my compiler/fellow readers about what the type signature meant if I'm not reifying effects.
00:34:44 <bitemyapp> takeoutweight: what if the file handle disappears and my function throws an exception? still no "mutation" or "state" insofar as you seem to be envisioning it...still breaks purity and equational reasoning.
00:34:53 <takeoutweight> Maybe I'm going too meta. I'm complaining about the "obvious" usage of the term pure to be the right word to describe the difficulty in nonlocal reasoning with state-like abstractions. I'm not talking about implicit side effects and "reading in the phase of the moon" to determine output, we all agree that's confusing.
00:36:08 <takeoutweight> I'm saying that you lose local reasoning with the State monad in very similar ways to when you us ML refs (in an honest way, not using any filesystem real world IO stuff)
00:36:26 <bitemyapp> takeoutweight: that's not purity
00:36:41 <techtangents> Hi, all. Wondering if someone could help me understand an Illegal instance declaration error.
00:36:43 <bitemyapp> takeoutweight: you're making a value judgment about what does and doesn't make sense, you're not talking about purity or equational reasoning.
00:37:04 <bitemyapp> takeoutweight: you're changing pure from meaning "pure" into meaning, "good, makes me feel fluffy and warm inside, doesn't challenge me at all"
00:37:04 <techtangents> type Row = V4 Integer
00:37:04 <techtangents> newtype Board = Board (V4 Row) deriving (Eq, Ord)
00:37:04 <techtangents> instance Newtype Board (V4 Row) where
00:37:05 <techtangents>   pack = Board
00:37:05 <techtangents>   unpack (Board b) = b
00:37:18 <techtangents> 2048.hs:96:10:
00:37:19 <techtangents>     Illegal instance declaration for `Newtype Board (V4 Row)'
00:37:19 <techtangents>       (All instance types must be of the form (T a1 ... an)
00:37:19 <techtangents>        where a1 ... an are *distinct type variables*,
00:37:19 <techtangents>        and each type variable appears at most once in the instance head.
00:37:19 <techtangents>        Use -XFlexibleInstances if you want to disable this.)
00:37:19 <techtangents>     In the instance declaration for `Newtype Board (V4 Row)'
00:37:20 <techtangents> Failed, modules loaded: none.
00:37:29 <bitemyapp> techtangents: don't paste code into a channel like that, hella rude.
00:37:40 <bitemyapp> takeoutweight: and then saying everybody got the definition of purity wrong when it should mean however you feel about the code on a case by case basis
00:37:46 <augur> whoa there techtangents
00:37:51 <augur> consider using hpaste
00:37:53 <takeoutweight> No I don't have an opinion on what pure should mean, I'm trying to pin down a precise meaning
00:38:00 <Welkin> @paste
00:38:00 <lambdabot> Haskell pastebin: http://lpaste.net/
00:38:17 <techtangents> Sorry, I didn't know that was bad form.
00:38:21 <bitemyapp> takeoutweight: we told you repeatedly
00:38:33 <bitemyapp> State s a doesn't break purity. We explained why.
00:38:33 <augur> takeoutweight: we gave you one
00:38:39 <augur> why is that so hard?
00:38:43 <augur> no. implicit. effects.
00:39:07 <takeoutweight> Sure, I'll accept that 100%.
00:39:11 <augur> ok good
00:39:16 <takeoutweight> I'm really not trying to obtuse, sorry if I'm coming across that way.
00:39:16 <bitemyapp> arguments always decide results.
00:39:16 <augur> so thats sorted
00:39:22 <bitemyapp> nothing outside arguments influences results.
00:39:27 <bitemyapp> takeoutweight: s'okay.
00:39:49 <bitemyapp> hell, I bet dibblego would get cranky if I was even using the plural "arguments" to describe it :)
00:39:59 <techtangents> Ok peeps. http://lpaste.net/101999
00:40:34 <augur> bitemyapp: dibblego is mighty cranky
00:40:39 <bitemyapp> augur: that's why I love him.
00:40:42 <augur> and ideological.
00:40:56 <bitemyapp> augur: he's like, the only person I've met that will make a point more forcefully than I will. I dearly love it.
00:41:03 <jedws> augur I would prefer "consistent"
00:41:17 <bitemyapp> I would prefer "consistently rational"
00:41:34 <bitemyapp> I'm sure if the facts change, so will he.
00:41:38 <augur> i would prefer consistently religious
00:41:43 <takeoutweight> So the problem I have with that definition of purity is that when you look at anything with the State monad, you get to count the state of the world at the time of, say, the "get" statement as an argument to the state function. I'm fine if you call this pure. But the exact same reasoning was used in the 60s to give semantics to references and mutation.
00:41:44 <augur> bitemyapp: the problem isnt with facts
00:41:44 <bitemyapp> bahahaha. :)
00:41:56 <apples> techtangents, what typeclass are you trying to implement?
00:42:04 <techtangents> Newtype
00:42:14 <bitemyapp> takeoutweight: you're talking about a couple of different things
00:42:23 <apples> you want instance Newtype Board where ...
00:42:43 <augur> bitemyapp: his attitude towards grammticality vs meaningfulness is ridiculous
00:42:44 <apples> Board has kind *, so you can't supply it a type like that in the instance definition
00:43:18 <techtangents> Newtype has 2 type arguments
00:43:21 <bitemyapp> augur: good cop, bad cop.
00:43:24 <apples> ah
00:43:34 <jedws> takeoutweight perhaps your objection is one of a philosophical nature, you're aware of the quote "no person can cross the same river twice"?
00:43:34 <techtangents> Is it that I'm using type aliases?
00:43:59 <jedws> "get" can!
00:44:11 <apples> techtangents, http://hackage.haskell.org/package/newtype-generics-0.4/docs/Control-Newtype.html -- this Newtype, or another?
00:44:16 <bitemyapp> takeoutweight: there's actually a technical argument to be made here, but fully laying it out would be laborious.
00:44:35 <bitemyapp> takeoutweight: suffice to say, there is a huge, huge difference between the vague bullshit "proofs" of the 1960s and what we're reifying to the type system today.
00:45:20 <takeoutweight> Well ok, let's stay in the 90's and use Moggi's monads as an example then
00:45:36 <bitemyapp> hum, that might be something else
00:45:41 <bitemyapp> I thought monads were introduced to force eval order?
00:45:54 <augur> jedws: heraclitus!
00:45:58 <augur> or was it parmenides
00:46:00 <bitemyapp> takeoutweight: at what point did we say monads were the source of purity?
00:46:00 <jedws> \o/
00:46:09 <techtangents> apples: This one actually: http://hackage.haskell.org/package/newtype-0.2
00:46:14 <jedws> augur right first time
00:46:19 <apples> aha
00:46:20 <bitemyapp> takeoutweight: we didn't. The point we've been making is "purity comes from explicit reification of effects"
00:46:32 <bitemyapp> techtangents: I wondered what in the fuck that was
00:46:34 <augur> jedws: i just recently listened to Roochnik's Great Courses course on ancient greek philosophy :)
00:46:40 * hackagebot cabal-db 0.1.7 - query tools for the local cabal database (revdeps, graph, info, search-by)  http://hackage.haskell.org/package/cabal-db-0.1.7 (VincentHanquez)
00:46:42 <bitemyapp> takeoutweight: monads aren't the only option. Cf. Idris and Eff
00:46:53 <jedws> bitemyapp which coincidentally reifies time!
00:47:01 <takeoutweight> Yeah no I understand effect typing. How about this:
00:47:23 <augur> Eff is too complicated. i dont know how they work. :(
00:47:42 <apples> techtangents, you'll have to wrap V4 Row in a newtype too then, i think
00:48:22 <takeoutweight> If ML code had to be honest of any functions that mentioned := or ! for reference setting/getting, would that be pure? Because that would (this is why I bring up moggi) admit nearly the same reasoning as anything with a -> State b. (modulo some efficiency on backtracking which you wouldn't have if you wanted to do that sort of thing)
00:48:31 <techtangents> bitemyapp: I thought this was supposed to be a friendly community - why are you swearing at me?
00:48:53 <augur> takeoutweight: honest in what sense?
00:49:02 <bitemyapp> techtangents: I wasn't swearing *at* you
00:49:10 <takeoutweight> So it's either a question of "honesty of the types" or "honest of the types plus persistent datastructures which makes backtracking cheap"
00:49:10 <bitemyapp> I was baffled by seeing a capitalized "Newtype"
00:49:17 <techtangents> ah
00:49:17 <augur> takeoutweight: honest in that i have first-class effectful values, or honest in that it marks effectfulness on types?
00:49:42 <augur> im not sure you can be honest without having first class effectful values
00:49:56 <bitemyapp> first-class effectful values exist in impure languages. You still have to reify to the type system or no bargain.
00:50:07 <augur> bitemyapp: yes of course, thats a given :)
00:50:11 <bitemyapp> JUST SAYING
00:50:20 <augur> bitemyapp: now you're yelling at me too!
00:50:21 <augur> T_T
00:50:25 <bitemyapp> 15 minutes ago I had a longer list of "givens" than I do now.
00:50:45 <bitemyapp> augur: pretty soon we'll be defending symmetry of equality as being true equality.
00:51:01 <bitemyapp> actually...I bet I can find a way to break symmetry in Scala.
00:51:02 <bitemyapp> h/o
00:51:02 <augur> <Socrates> but what _is_ equality?
00:51:17 <augur> jedws gets my joke
00:51:18 <jedws> but, equality is key to the whole thing
00:51:24 <jedws> snap
00:51:31 <bitemyapp> bahahaha, Proxy.
00:51:43 <bitemyapp> augur: if you use Proxy you can get asymmetric Equality in Scala.
00:51:44 <augur> man now i have to go through my feed to find jedws and follow him
00:51:48 <bitemyapp> augur: that's worse than JS!
00:51:50 <bitemyapp> Brill.
00:51:53 <augur> man i wont touch scala
00:51:58 * bitemyapp golf clap
00:52:04 <flippant> oh snap
00:52:07 <flippant> haha
00:52:10 <augur> its type system is interesting in some respects, but its just.. i dont know
00:52:13 <bitemyapp> Scala: do anything, include bad things.
00:52:15 <augur> i hear too many horror stories
00:52:19 <bitemyapp> including*
00:52:35 <bitemyapp> good to see my nose for, "what evil can I accomplish with Scala?" is still accurate.
00:52:39 <thebnq> But its on the jvm :]
00:52:42 <bitemyapp> and that they still haven't fixed anything from 5 years ago.
00:52:47 <bitemyapp> thebnq: dun dun dunnnnn
00:52:51 <thebnq> xD
00:52:52 <techtangents> General comment: Hackage is big. I come across lots of libraries that do basically the same thing in similar ways. Are there people sifting through it to try and de-dupe and remove redundant ones? I get the feeling it's far too eas to add things to Hackage than remove them.
00:53:12 <techtangents> s/eas/easy
00:53:35 <bitemyapp> techtangents: nah, even derelict libraries make knowledge available.
00:53:39 <bitemyapp> deletionism is a hateful thing.
00:53:44 <Welkin> techtangents, there are little gnome working day and night
00:53:47 <bitemyapp> techtangents: if you want curation, check with fpcomplete.
00:53:48 <Welkin> gnomes*
00:54:21 <jedws> augur you may enjoy "Functional Programming is Terrible" by Apocalisp then for a good overview on FP in Scala https://www.youtube.com/watch?v=hzf3hTUKk8U&feature=youtu.be
00:54:45 <bitemyapp> jedws: I never see him called that.
00:54:58 <copumpkin> runar?
00:55:00 <bitemyapp> yeah.
00:55:07 <augur> two runars in FP?
00:55:11 <augur> impossible
00:55:15 <copumpkin> only one runar
00:55:23 <augur> runai bjarnason = runar oli?
00:55:24 <jedws> bitemyapp it may be an old handle  but it is still his irc nick IIRC
00:55:26 <techtangents> I think it's an awesome nick. He should use it more often :)
00:55:33 <copumpkin> augur: yeah, oli is his middle name
00:55:33 <bitemyapp> fat chance, there's only like 300k icelanders in the whole world.
00:55:37 <augur> copumpkin: o
00:56:04 <augur> thank goodness, otherwise we may have had to conclude that this conversational context wasnt referentially transparent :)
00:56:21 <copumpkin> :)
00:56:42 * hackagebot ad 4.0 - Automatic Differentiation  http://hackage.haskell.org/package/ad-4.0 (EdwardKmett)
00:56:46 <bitemyapp> augur: this introduction to this talk is Brave. He keeps saying "referentially transparent"
00:56:49 <copumpkin> edwardk: w00t
00:56:59 <bitemyapp> I'm suprised Bob Harper hasn't body-checked him and taken over the talk.
00:57:01 <edwardk> copumpkin: took long enough, but the new version is sexy
00:57:12 <copumpkin> bitemyapp: bob wasn't there :P
00:57:13 <bitemyapp> edwardk: what is sexier?
00:57:14 <vermeille> Does anyone know if Packrat parsers and TAG parsers are the same?
00:57:25 <bitemyapp> copumpkin: that's why Runar still lives and breathes.
00:57:37 <copumpkin> edwardk: what's new?
00:57:45 <copumpkin> oh there's a fancy changelog
00:57:52 <bitemyapp> oh, derp.
00:57:52 <edwardk> bitemyapp: types got a lot cleaner, internals are simpler, you can write monomorphic AD modes, end users can write new primitives with know partials, etc.
00:58:11 <copumpkin> monomorphic modes as in they work only over Double?
00:58:13 <edwardk> oh, i should have finished updating the CHANGELOG
00:58:18 <edwardk> yeah
00:58:19 <copumpkin> for performance, I assume?
00:58:25 <augur> bitemyapp: oh god
00:58:30 <edwardk> Numeric.AD.Mode.Forward.Double is one
00:58:37 <augur> bitemyapp: noone knows what that phrase means
00:58:41 <edwardk> it can also be put in vectors, etc.
00:58:57 <augur> its so frustrating, because its such a simple concept, yet people just keep getting it wrong
00:58:59 <copumpkin> ah
00:59:01 <edwardk> so it gives you a path to work with nice unboxed vectors of forward mode
00:59:45 <bitemyapp> augur: what if we just gave them calculators with algebra modules that keep giving different answers to the same questions with the same inputs?
00:59:53 <Welkin> that reminds me of the video "Haskell is a useless language"
01:00:19 <Welkin> https://www.youtube.com/watch?v=iSmkqocn0oQ
01:00:37 <augur> bitemyapp: i dont know if there are interesting connections between effects and RefTrans actually
01:00:40 <Welkin> bitemyapp, that would be fun
01:00:40 <bitemyapp> edwardk: I noticed a wave of monomorphic stuff in Haskell libraries lately. How did this start? I first noticed it with Snoyman's library.
01:00:42 <augur> there probably are
01:00:53 <ion> edwardk: cool
01:01:05 <edwardk> bitemyapp: unrelated to this
01:01:06 <bitemyapp> Welkin: in the Dwarf Fortress sense of the world... !FUN!
01:01:18 <bitemyapp> edwardk: oh I figured, it's just been on my mind.
01:01:23 <edwardk> here it arises because you want to be able to work over stuff in a particular ad mode
01:01:40 <edwardk> in many ways lens is also about such things. e.g. the text traversal
01:01:50 <edwardk> :t over Data.Text.Lens.text
01:01:51 <lambdabot> (Indexable Int p, Data.Text.Lens.IsText t) => p Char Char -> t -> t
01:01:56 <edwardk> :t over Data.Text.Lens.Strict.text
01:01:56 <lambdabot> Couldn't find qualified module.
01:02:05 <edwardk> :t over Data.Text.Strict.Text.text
01:02:05 <lambdabot> Couldn't find qualified module.
01:02:12 <edwardk> :t over Data.Text.Strict.Lens.text
01:02:13 <lambdabot> Indexable Int p => p Char Char -> Data.Text.Internal.Text -> Data.Text.Internal.Text
01:02:20 <bitemyapp> oh cool
01:02:20 <edwardk> heh, i can remember the name eventually
01:02:32 <bitemyapp> edwardk: 'tis your namespaces and nomenclature :)
01:02:46 <Welkin> has anyone watched "Monads and Gonads"?
01:02:55 <bitemyapp> with that title, I'm not sure I want to.
01:02:59 <edwardk> Welkin: unfortunately. i want that time back
01:03:10 <Welkin> haha
01:03:19 <Welkin> there are so few haskell videos on youtube
01:04:16 <bitemyapp> sigh, Crockford.
01:04:21 * bitemyapp closes tab immediately
01:04:26 <bitemyapp> Welkin: No.
01:09:21 <thebnq> Welkin: i actually have, i didn't find it too helpful
01:13:33 <techtangents> BTW. I'm attempting a solver for the 2048 game in Haskell. Wish me luck :)
01:13:41 <bitemyapp> jedws: unapply is terrifying. I haven't seen this before.
01:19:52 <bitemyapp> not that apply was great to begin with.
01:23:39 <augur> bitemyapp: what's unapply?
01:23:56 <augur> and whats apply in this context?
02:21:53 * hackagebot yackage 0.7.0.3 - Personal Hackage replacement for testing new packages. (deprecated)  http://hackage.haskell.org/package/yackage-0.7.0.3 (MichaelSnoyman)
02:36:55 * hackagebot yesod-fay 0.5.0 - Utilities for using the Fay Haskell-to-JS compiler with Yesod.  http://hackage.haskell.org/package/yesod-fay-0.5.0 (MichaelSnoyman)
03:05:30 <no-n> > Left 1 `mplus` Right 2
03:05:31 <lambdabot>  No instance for (Control.Monad.Trans.Error.Error a0)
03:05:31 <lambdabot>    arising from a use of `e_112'
03:05:31 <lambdabot>  The type variable `a0' is ambiguous
03:05:31 <lambdabot>  Possible fix: add a type signature that fixes these type variable(s)
03:05:31 <lambdabot>  Note: there are several potential instances:
03:37:01 * hackagebot servius 1.1.1.2 - Serve Shakespearean templates via Warp (deprecated)  http://hackage.haskell.org/package/servius-1.1.1.2 (MichaelSnoyman)
03:43:10 <darthdeu> guys i've just tried to reinstall haskell-platform, and now that i tried to install yesod it gave me an error https://gist.github.com/darthdeus/d1808a7553c9ae99f789 ... and when I run ghc-pkg check I get a bunch of missing errors
03:43:13 <darthdeu> what should I do?
03:43:40 <darthdeu> after the uninstall I did rm -rf ~/.cabal
03:44:56 <darthdeu> this is what ghc-pkg check returns https://gist.github.com/darthdeus/e601650bdc4b588aa3c3
03:45:27 <darthdeu> i guess i'll just do ghc-pkg check --simple-output | xargs -n 1 ghc-pkg unregister --force
03:46:51 <Philonous> darthdeu, In my experience you also have to rm -rf ~/.ghc
03:47:17 <darthdeu> Philonous: should I reinstall haskell-platform after doing that?
03:47:41 <Philonous> You don't have to. If you don't the packages will just be pulled in from hackage
03:47:57 <darthdeu> I thought packages are in ~/.cabal though?
03:48:43 <Philonous> The package registration database is in .ghc
03:48:49 <Philonous> And that's what ghc-pkg is working with
04:13:27 <angerman> how do you handle parameter creep in haskell?
04:13:37 <angerman> Am I just not composing right?
04:14:51 <angerman> I guess the core of the issue I'm having is this: let x :: String -> String -> String -> String -> String -> Something, the ordering of the parameter is a little tricky.
04:15:54 <angerman> Could this be something I brought from objc, where the parameters are explicitly named? xWithFirstname:lastname:address:andPhoneNumber:...
04:17:08 <iota_> angerman: use a record with named fields ?
04:17:39 <angerman> iota_: is that the idomatic way to do it?
04:17:53 <angerman> so I basically define data { ... } and then use that?
04:18:30 <benmachine> angerman: you can also then provide a defaultArgs and override specific fields
04:18:50 <iota_> angerman: I guess so
04:19:05 <angerman> iota_: are there performance implications I should be aware of? Not that I would try to optimize prematurely just curious.
04:19:14 <benmachine> (the exact syntax for the data declaration is data ArgsType = MkArgs { arg1 :: Type1, arg2 :: Type2, ... }
04:19:17 <angerman> benmachine: huh?
04:19:17 <benmachine> )
04:19:42 <benmachine> angerman: ok so one example is xmonad
04:19:50 <angerman> about that data thing, I'm probably goging to have another question later on.
04:20:02 <angerman> benmachine: so I should study xmonad? Alright :)
04:20:03 <nooodl> "when (isJust x) $ m (fromJust x)" <- what's a clean way to write this?
04:20:23 <benmachine> angerman: there is a function xmonad :: Config -> IO (), and a defaultConfig :: Config
04:20:41 <benmachine> angerman: and you write things like main = xmonad defaultConfig { startupHook = blah }
04:21:12 <benmachine> angerman: which gets the default config, replaces the startupHook with blah, then uses that as the configuration
04:21:15 <angerman> ok. so the config is prepopulated. and just updated.
04:21:18 <pranz> :t when
04:21:18 <lambdabot> Monad m => Bool -> m () -> m ()
04:21:19 <benmachine> yep
04:21:33 <benmachine> nooodl: using case
04:21:42 <pranz> nooodl: I don't think that's what you want
04:21:50 <angerman> ok. gotta think about that a little.
04:21:52 <benmachine> case x of Nothing -> return (); Just y -> m y
04:21:54 <angerman> bbl.
04:22:13 <benmachine> or, if you're feeling fancy, maybe (return ()) m
04:22:23 <benmachine> :t maybe (return ()) m
04:22:24 <lambdabot>     Couldn't match expected type `a0 -> m0 ()' with actual type `Expr'
04:22:24 <lambdabot>     In the second argument of `maybe', namely `m'
04:22:24 <lambdabot>     In the expression: maybe (return ()) m
04:22:28 <benmachine> oh, right
04:22:35 <benmachine> :t let m x = print x in maybe (return ()) m
04:22:36 <lambdabot> Show a => Maybe a -> IO ()
04:22:58 <pranz> nooodl: what is the type of x and m?
04:23:06 <Hafydd> nooodl: is that not fmap m x?
04:23:50 <pranz> x >>= m works
04:23:51 <Hafydd> Er, or rather... x >>= m.
04:23:57 <pranz> but I still don't think that's what he wants
04:24:01 <benmachine> that depends on what the monad is
04:24:10 <pranz> because returning a Maybe () is pretty pointless
04:24:17 <pranz> it's just another name for Bool
04:24:19 <benmachine> who said anything about that?
04:24:28 <pranz> benmachine: the use of when
04:24:35 <benmachine> pranz: but it need not be Maybe-when
04:24:38 <benmachine> it could be anything
04:24:41 <nooodl> pranz: x :: Maybe t, m :: t -> IO ()
04:24:48 <pranz> ah, right
04:25:04 <pranz> alright
04:25:19 <benmachine> the answer is pattern-matching, using case
04:25:37 <pranz> :t maybe
04:25:38 <lambdabot> b -> (a -> b) -> Maybe a -> b
04:25:49 <nooodl> it's not just x >>= m though:
04:25:50 <nooodl> :t Nothing >>= print
04:25:51 <lambdabot>     Couldn't match type `IO' with `Maybe'
04:25:51 <lambdabot>     Expected type: a0 -> Maybe ()
04:25:51 <lambdabot>       Actual type: a0 -> IO ()
04:26:00 <benmachine> nooodl: no, it isn't
04:26:08 <nooodl> case sounds good
04:26:11 <pranz> nooodl: yeah, use pattern matching or the maybe function
04:26:14 <benmachine> case is great
04:27:07 * hackagebot language-lua 0.3.0 - Lua parser and pretty-printer  http://hackage.haskell.org/package/language-lua-0.3.0 (OmerAgacan)
04:27:44 <moofy> hmm
04:31:06 <supki> nooodl: Data.Foldable.for_
04:32:07 * hackagebot language-c 0.4.3 - Analysis and generation of C code  http://hackage.haskell.org/package/language-c-0.4.3 (BenediktHuber)
04:34:07 <moofy> ahoy, I'm having a problem with runhaskell and I wondered if anyone could give me a pointer
04:34:45 <moofy> trying to play with gloss a bit, but running even the simplest script with runhaskell just gives me an unresponsive white rectangle :/
04:53:38 <Saizan> moofy: tried compiling?
04:54:21 <xpika> does anyone know why (  read .  (:[]) <$> getChar  ) :: IO Int gives the number twice?
04:54:36 <Saizan> moofy: i only know some graphic libs don't like the interpreter, i remember there are some workarounds though, they'd be the same as for ghci
04:55:09 <Philonous> xpika, What do you mean by "giving the number twice"?
04:55:44 <xpika> Philonous: sorry my bad i think its just im confusing my own input for the number
04:56:00 <Philonous> xpika, If you enter this into ghci you'll see the digit twice: Once because you enter it, once because the result is printed on the screen
05:02:11 * hackagebot xlsx 0.1.0 - Simple and incomplete Excel file parser/writer  http://hackage.haskell.org/package/xlsx-0.1.0 (KirillZaborsky)
05:02:25 <moofy> it works compiled Saizan, I think it must just be balking at running interpreted
05:06:52 <kuribas> Is their a way to get from Just (IO a) to IO a?
05:07:13 <kuribas> :hoogle Maybe (IO a) -> (IO a)
05:08:06 <ion> kuribas: case foo of { }  -- What’s the first step?
05:09:35 <kuribas> hm, I see...
05:10:08 <ion> (The answer: no, but if you restrict the “a” appropriately, yes.)
05:10:29 <kuribas> Maybe (IO ()) -> IO () better
05:10:39 <ion> That would work.
05:12:17 <ion> I recommend figuring out how to do it manually first – please ask if anything is unclear – and then looking at Data.Foldable.sequence_
05:12:31 <Philonous> It's IO so you could throw an exception (if that's appropriate for you application)
05:12:41 <kuribas> Wait, I can just nest do notation...
05:13:15 <ion> philonous: Good point
05:13:38 <kuribas> like do {something; do {a <- fromAMaybe; sideEffectWith a}; theRest}
05:14:34 <browndawg> Any vim users in here who could point me to a great haskell config? The out of box hs support really sucks.
05:14:58 <vermeille> browndawg: vin2hs
05:15:08 <vermeille> vim*
05:15:13 <vermeille> Just google it. Amazing.
05:15:40 <ion> Assuming theRest doesn’t access an “a”, that looks like it’s the same as do { something; a <- fromAMaybe; sideEffectWith a; theRest }. (A side note: IO effects are just “effects”, not side effects. IO would have *side* effects if just evaluation resulted in IO.)
05:15:43 <nadirs> browndawg: I use "dag/vim2hs", "eagletmt/ghcmod-vim" and syntastic
05:16:14 <browndawg> Yes, thank you vermeille & nadirs. Already have syntastic set up. Looks like vim2hs is what I need.
05:17:05 <kuribas> ion: Well, the type of something is "IO ()", and of fromAMaybe is "Maybe smtng", so they are two different monads.
05:17:28 <ion> Then that’s a type error.
05:17:29 <Philonous> kuribas, Then you can't have them in the same do block
05:17:42 <angerman> Ok. I must be doing it wrong :( I think I'm missing something. So I tried to condense what I'm doing and what I intend to do here: http://lpaste.net/6340123678885281792
05:17:44 <kuribas> Philonous: yes
05:18:20 <nadirs> browntag: also, I don't know about you but I don't like "conceal" so I set "let g:haskell_conceal = 0" and "let g:haskell_conceal_enumerations = 0"
05:18:21 <Philonous> kuribas, Nesting do blocks doesn't help, either, because the do-block itself is an action in the other monad.
05:20:04 <kuribas> Ah, yes.
05:20:24 <kuribas> So can only use monad transformer stack?
05:20:30 <ion> kuribas: case (foo :: Maybe something) of { }  -- What’s the first step?
05:20:40 <ion> What are the possible cases?
05:20:46 <Philonous> @type \maybeAction -> case maybeAction of Just a -> a; Nothing -> return ()
05:20:47 <lambdabot> Monad m => Maybe (m ()) -> m ()
05:21:14 <kuribas> case parseName n of {Just name -> update name; Nothing -> return ()}
05:21:50 <ion> name :: IO something?
05:22:07 <kuribas> No, just string for example.
05:22:09 <Philonous> ion, (update name) is the IO action
05:22:22 <Philonous> I reckon
05:22:25 <ion> philonous: I gathered as much, that just didn’t match the original question.
05:25:47 <Philonous> kuribas, It all really depends on what you want to do if that value turns out to be Nothing. You could just do nothing (that's what we are discussing) or you could have some non-local control transfer, like exceptions.
05:26:15 <kuribas> case lookup 1 [(1, "one"), (2, "two")] of {Just s -> putStrLn s; Nothing -> return ()}
05:26:30 <kuribas> Philonous: Just do nothing in my case.
05:27:20 <ion> @type Data.Foldable.traverse_ putStrLn
05:27:21 <lambdabot> Foldable t => t String -> IO ()
05:27:49 <kuribas> @type Data.Foldable.traverse_
05:27:50 <lambdabot> (Applicative f, Foldable t) => (a -> f b) -> t a -> f ()
05:28:34 <kuribas> That will do!
05:28:46 <kuribas> @type Data.Foldable.for_
05:28:47 <lambdabot> (Applicative f, Foldable t) => t a -> (a -> f b) -> f ()
05:29:02 <kuribas> traverse_ is (flip for_) ?
05:39:09 <Philonous> kuribas, Yes (FSVO "is")
05:40:21 <kuribas> Philonous: Well, it seems completely equivalent.
05:40:42 <Philonous> Extensionally, yes.
05:40:51 <kuribas> What do you mean?
05:41:09 <kuribas> Looking in the source: "for_ = flip traverse_"
05:41:28 <Philonous> traverse_ and (flip for_) give the same answers to the same arguments. They are the same functions. but traverse_ isn't defined as (flip for_)
05:41:53 <kuribas> Philonous: True, for_ is defined as flip traverse_.
05:42:46 <pranz> in Data.Foldable yes
05:42:52 <pranz> there is a Traversable class too
05:43:49 <ion> which doesn’t contain a traverse_
05:46:12 <donri> nor for ;)
05:46:58 <ion> It contains a flipped for. :-) But no for_
05:47:33 <no-n> did John Carmack release any of his HS Wolf 3D code/
05:48:03 <donri> `for` is not part of the class ;)
05:48:26 <donri> the art of nitpicking
05:48:36 <benmachine> kuribas: I suppose the key question is whether flip (flip f) = f
05:49:16 <kuribas> yes
05:49:33 <Philonous> @type id
05:49:34 <lambdabot> a -> a
05:49:39 <Philonous> @type flip (flip id)
05:49:40 <lambdabot> (a -> c) -> a -> c
05:49:41 <kuribas> when f = a -> b
05:49:58 <benmachine> the answer is "extensionally yes" and extensionally is usually what you're worried about
05:50:21 <Philonous> benmachine, Except when you're not, because performance is usually an issue.
05:50:29 <kuribas> So what exactly is not-extensionally equal?
05:50:47 <kuribas> The same definition?
05:50:53 <Philonous> Yes
05:50:56 <benmachine> that would be one kind of non-extensional equality
05:50:58 <Philonous> the same internal structure
05:51:22 <kuribas> So is (+) equal to \x y -> x+y ?
05:51:55 <Philonous> kuribas, It's eta-equivalent. So it's also extensionally equivalent.
06:14:46 <darthdeu> how can I make a Functor instance for a type that doesn't have the (* -> *) kind but only * ?
06:15:14 <Philonous> darthdeu, You can't
06:15:34 <darthdeu> Philonous: so if I have   data Foo = Foo Int, I can't have a Functor instance for that?
06:15:47 <Philonous> Yes, you can't make that a functor.
06:15:51 <darthdeu> hmm
06:16:02 <darthdeu> interesting
06:21:06 <Philonous> darthdeu, If may want to have a look at lenses, however.
06:21:33 <darthdeu> I've been trying to understand those for the past week or something, but I still don't get it
06:21:50 <yoeight> Philonous: I think it's to soon
06:22:27 <darthdeu> i've listened to the haskellcast about lenses, read a bunch of stuff about them, but I don't still see it
06:22:30 <ion> There was a package with a Functor-like class for things of kind *, but i don’t remember its name.
06:22:54 <yoeight> darthdeu: Why do you want to derive a Functor instance for a kind * ?
06:25:03 <Philonous> darthdeu, a lens is conceptually the combination of a "getter" and a "setter". So in you case you can extract the Int from Foo via getFoo (Foo i) =i and you can set a new value with setFoo (Foo _) j = Foo j.
06:25:45 <notdan> darthdeu: what would be the type of `fmap` if `Foo` was a functor?
06:25:58 <Philonous> darthdeu, Now, the lens package encodes them cleverly and you build a lens with the "lens" function like thus: "fooLens = lens getFoo setFoo"
06:25:59 <yoeight> ion: mono-traversable package ?
06:26:41 <darthdeu> yoeight: I have this monoid and thought it would be nice to use fmap on it
06:27:01 <_ikke_> darthdeu: A functor is basically an iterator for a 'container' type
06:27:05 <darthdeu> Philonous: hmm, that's probably what i need
06:27:31 <Philonous> darthdeu, Now you can use this lens to access the value inside foo. You get the getter back with view: "view fooLens (Foo 3) ==> 3"
06:27:37 <yoeight> darthdeu: I still don't get why you need fmap
06:27:45 <darthdeu> _ikke_: i thought the metaphor of "container" is not to be used :P
06:28:00 <_ikke_> darthdeu: learnyouahaskel describes it like that
06:28:03 <darthdeu> yoeight: I don't really need it, i was just curious if it's possible
06:28:22 <darthdeu> _ikke_: yeah, i've read LYAH and RWH and now i'm reading typeclassopedia
06:28:28 <Philonous> darthdeu, And the setter with set: "set fooLens 5 (Foo 3)  ==> Foo 5"
06:28:29 <lrocksmashtime> why are there periods after many of the logical operators in some haskell code? like in the case of this Persist example (selectList [PersonAge >. 25, PersonAge <=. 30] [])
06:28:56 <darthdeu> Philonous: which lens package should I use? there's this http://hackage.haskell.org/package/lens  and also the lens-family package
06:29:03 <darthdeu> and i've read each does things differently
06:29:28 <lrocksmashtime> actually i think i know why. They are operators defined by the Persist libraries specifically for generating queries.
06:29:55 <Philonous> darthdeu, And there are lots of helper functions, for example you can combine getting, applying a function and setting with over: "over fooLens (+1) (Foo 3) ==> Foo 4"
06:30:14 <notdan> lens-family is more beginner friendly
06:30:20 <notdan> and it is also compatible with lens
06:30:21 <Philonous> darthdeu, so over acts like a (generalized) fmap
06:32:32 <Philonous> darthdeu, The examples I gave where from the "lens" package. But any package that implements van-Laarhoven lenses should be compatible
06:33:50 <darthdeu> awesome :)
06:33:51 <darthdeu> thanks guys
06:40:19 <skypers> hey
06:40:29 <skypers> I’d like to introduce function binding in my AST through GADTs
06:40:32 <skypers> but I don’t see how
06:40:54 <skypers> the idea would be to add a ctor like Fun :: (E a -> E b) -> E (a -> b)
06:41:31 <skypers> I’m not even sure it’s possible
06:41:52 <c_wraith|N10> It's possible. I'm just not sure it's useful.
06:42:12 <skypers> c_wraith|N10: well, it is
06:42:22 <yoeight> skypers: any code available somewhere ?
06:42:31 <skypers> not yet
06:42:44 <skypers> c_wraith|N10: my AST is for GLSL code
06:42:52 <c_wraith|N10> I mean I'm not sure that representation is useful.
06:42:53 <skypers> I’d like to be able to create GLSL functions through it
06:43:11 <yoeight> skypers: hard to help with no types
06:43:21 <nooodl> Map.fromList [(1,"world")] ^.at 1  gives me  "No instance for (At (Map k0 [Char])) ..." am i forgetting to import something here?
06:43:44 <notdan> skypers: I think it is possible
06:43:47 <skypers> yoeight: I may have some code
06:43:47 <skypers> wait
06:43:56 <nooodl> that should be in Control.Lens, shouldn't it...
06:44:01 <ion> yoeight: Yeah, that’s it.
06:44:10 <skypers> yoeight: https://github.com/skypers/ion/blob/master/Graphics/Rendering/Ion/Core/Expr.hs#L17
06:44:18 <skypers> ahah
06:44:35 <angerman> if you are defining data with fields do you do data A = A { a :: String }  or data A = A { getA :: String } ?
06:44:45 <angerman> or is there something more ideomatic?
06:45:00 <ion> skypers: I see i’m not only a window manager, i’m also a raytracer.
06:45:03 <geekosaur> depends on how it's being used
06:45:12 <skypers> yeah ahah :)
06:46:23 <angerman> I just think A { getA = "foo" } looks kind weird, while getA x looks right.
06:47:14 <geekosaur> the getA form is generally used when it's acting as a collector or evaluator  in some fashion; see for example the Sum monoid or runState
06:47:39 <geekosaur> what we *don't* generally do is treat it as an OOP-style accessor
06:47:48 <yoeight> skypers: Do you mean Lambda abstraction or function application ?
06:48:03 <skypers> function application
06:48:21 <skypers> I want to be able to show a function, actually
06:48:35 <skypers> otherwise I’d need some tricky work around
06:48:45 <geekosaur> because that breaks down as soon as you start using pattern matching e.g. foo (Bar {getA = a}) = ...something using a...
06:49:09 <yoeight> skypers: what about that then -> App :: E a -> E a -> E a
06:49:11 <angerman> geekosaur: so it's basically a decision about aiding readability, right?
06:49:14 <nooodl> http://lpaste.net/194710499823190016 here's the full error. just reinstalled lens, too. no idea what's going on
06:49:34 <skypers> yoeight: it’s not the type of a function
06:49:36 <geekosaur> largely, yes, but also conveys its conceptual meaning
06:49:40 <skypers> a function would be a -> b
06:49:46 <angerman> geekosaur: so maybe you also have some advice on this:  http://lpaste.net/6340123678885281792 ?
06:49:48 <skypers> not an endomorphism
06:50:56 <geekosaur> the answer to line 22-27 is you need parentheses, like I showed in my pattern match example
06:51:04 <yoeight> skypers: do you mean to be able to store a function and using it at interpretation time ?
06:51:26 <geekosaur> `writeElement A1 e` takes two parameters, a bare constructor (which is a function) and a non-pattern-matched value
06:51:36 <skypers> yoeight: yes
06:51:38 <qwebirc> how do I get value out of a Maybe? e.g. how do I convert Just 8 to 8?
06:51:48 <geekosaur> `writeElement (A1 e)` takes a single parameter whose constructor must be A1
06:52:03 <angerman> geekosaur: ohh thanks!
06:52:04 <_ikke_> qwebirc: fromJust
06:52:08 <_ikke_> http://www.haskell.org/hoogle/?hoogle=fromJust
06:52:14 <skypers> :t fromJust
06:52:15 <lambdabot> Maybe a -> a
06:52:27 <geekosaur> fromJust is a bad idea; consider
06:52:29 <geekosaur> :t maybe
06:52:29 <yoeight> skypers: considering you're using GADTs, you need to use Operational Monad
06:52:30 <lambdabot> b -> (a -> b) -> Maybe a -> b
06:52:32 <geekosaur> :t fromMaybe
06:52:33 <lambdabot> a -> Maybe a -> a
06:52:37 <nooodl> qwebirc: you can also pattern match on it. case x of Just a -> ...; Nothing -> ...
06:52:42 <ion> ikke: Please
06:52:43 <skypers> Operational ?
06:52:47 <nooodl> or f (Just a) = ...; f Nothing = ...
06:53:02 <angerman> geekosaur: Am I doing it conceptually right? or should I be using different tools from the haskell toolchain?
06:53:02 <geekosaur> (the former lets you specify a transformation to do on the value or a default if it's Nothing; the latter just substitutes a default for the Nothing case)
06:53:10 <yoeight> skypers: http://hackage.haskell.org/package/operational
06:53:27 <_ikke_> ion: ?
06:53:29 <geekosaur> angerman: it's hard to say
06:53:51 <geekosaur> would have to see more about what you're doing to be able to tell if you're using the most appropriate approach
06:53:55 <ion> ikke: There is no situation where fromJust would be good advice.
06:54:07 <_ikke_> ion: ok
06:54:17 <geekosaur> (also I won't be around for much longer, have something of a busy day ahead)
06:54:21 <_ikke_> Because it throws exceptions on Nothing, right?
06:54:30 <angerman> geekosaur: thanks for the input anyway!
06:54:45 <ion> ikke: Even when you are sure a value is a Just, the exception fromJust throws hides where it happened. One should use a pattern match in that case.
06:55:12 <_ikke_> ok
06:55:20 <ion> That is, when you’re sure it’s a Just but happen to be wrong.
06:55:21 <geekosaur> I will note that, if they're all strings and you want a traversal that flattens them somehow, you may want a generics approach such as lens
06:55:50 <geekosaur> however, you may instead want to just store them flattened, depending on what exactly you're doing with it (again, not enough information in your paste)
06:56:57 <Philonous> skypers, I think you should start by replicating the GLSL type system. Then you can implement lambda abstraction with explicit type annotation as (Lambda :: SType a -> E b -> E (Fun a b)) where (STybe a) is a singleon and Fun is the (promoted) constructor for Function types
06:57:11 <Philonous> singleton*
06:57:25 <angerman> geekosaur: they can be of differnt types [String], String, and Int for now. But I think maybe I could setup a type class, that would turn [String] -> [String], String -> [String] and Int -> [String]
06:57:51 <geekosaur> that's something of a bad idea, because typeclasses often turn out to be bigger hammers than you intend
06:57:58 <angerman> geekosaur: then, they'd all be [String], I'd just need to get them in order out of the record. would lenses do that?
06:58:05 <skypers> Philonous: I already replicated it
06:58:29 <aristid> geekosaur: i try to avoid using typeclasses, but they still often end up being the most convenient solution
06:58:38 <geekosaur> lenses, or generics in general, let you traverse a structure and operate on everything that is a String wherever it is (including [String] --- but not including the Int)
06:59:25 <angerman> geekosaur: ok, something to look up then.
06:59:50 <Philonous> skypers, I meant, you should have data GLSLType = GLSLVoid | GLSLBool | GLSLInt ...
06:59:51 <geekosaur> I will also note that, if all of them start with the same thing, you may want to refactor to have a common section and then the variants
07:00:24 <skypers> Philonous: ah
07:00:37 <skypers> well, I want the AST to be the more abstract as possible
07:00:39 <geekosaur> `data Element = Elem { name :: String, version :: Int, value :: ElemInfo }` and then define an ElemInfo type which discriminates the different values
07:00:48 <skypers> my framework is designed to support several backends
07:00:55 <skypers> OpenGL, CUDA, and so on
07:01:13 <yoeight> skypers: Operational is what you need then
07:01:15 <geekosaur> once again,t here is not enough information in the paste about how this is being used for me to be able to tell what the best approach is
07:01:19 <skypers> yoeight: sounds scary
07:01:35 <yoeight> skypers: no, you just need practice
07:02:16 <yoeight> skypers: Using Operational, you could have different interpreters depending on targeted backend
07:02:32 <ghost355> hi, is it possible using more then one "case...of" in one expression?
07:02:45 <skypers> I see
07:02:53 <skypers> I’ll take a look the
07:02:54 <skypers> n
07:03:01 <ion> > (case 42 of 42 -> (++)) (case 43 of 43 -> "hello ") (case 44 of 44 -> "world")
07:03:03 <lambdabot>  "hello world"
07:03:09 <yoeight> skypers: relative cousin is Free monad
07:03:58 <yoeight> skypers: Both are isomorphic considering Yoneda lemma but that an another story :)
07:03:58 <skypers> ah!
07:04:02 <skypers> the Free monad
07:04:14 <skypers> isomorphic?
07:04:19 <ghost355> and what about if need each "case of" with other choose
07:04:29 <yoeight> skypers: equivalent
07:04:42 <ion> ghost355: What are you actually trying to achieve?
07:04:44 <skypers> why don’t you say “equivalent” in the first place? :D
07:05:03 <yoeight> skypers: because isomorphic is more precise
07:05:21 <skypers> ok
07:06:12 <ghost355> ion, i try to understand phrase from "Learn You a Haskell for Great Good!"
07:06:29 <yoeight> skypers: Here's Yoneda at work it you wanna know -> https://gist.github.com/YoEight/9455226
07:06:32 <ion> I can vouch for Operational being nice.
07:07:15 <skypers> what do you mean “at work”?
07:07:27 <ion> “being used”
07:07:29 <ghost355> "They are useful for pattern matching against something in the middle of an expression." Its for one  or for same
07:07:48 <ghost355> its about "case of"
07:08:00 <skypers> ok
07:08:06 <yoeight> skypers: I meant here a proof of Yoneda lemma
07:08:15 <hiptobecubic> There's an interesting discussion in ##c++ about Haskell's type erasure of closures. What does that mean? Aren't all types erased during compilation anyway?
07:08:28 <ghost355> not samу - some:)
07:08:40 <skypers> hiptobecubic: C++, lol.
07:09:24 <ion> ghost355: Sorry, i’m not quite getting what you are asking. Is there a piece of code you’d like to learn to understand?
07:09:51 * geekosaur wonders if they're comparing this to the unfortunate nature of java's type erasure semantics
07:10:04 <ghost355> ion, describeList :: [a] -> String
07:10:04 <ghost355> describeList xs = "The list is " ++ case xs of [] -> "empty."
07:10:04 <ghost355>                                                [x] -> "a singleton list."
07:10:04 <ghost355>                                                xs -> "a longer list."
07:10:37 <shiona> akylhän ere on vieläkin ihan kelvotonta js-kuraa
07:10:58 <geekosaur> (note also that type erasuure is more of an issue in general in OO languages where you *need* to use introspection to do a lot of things; Haskell not only has other mechanisms, it also has ways to maintain type info at runtime if it's needed)
07:11:07 <ghost355> what about if  i need add one more case matching? is it possible in one expression, ion
07:11:15 <MagneticDuck> yes..
07:11:20 <geekosaur> ghost355, don't paste into the channel, use a paste site
07:11:21 <MagneticDuck> a case expression can be an expression
07:11:26 <MagneticDuck> ...
07:11:29 <MagneticDuck> s/can be/is an
07:11:34 <MagneticDuck> s/can be an/is an
07:11:37 <ion> ghost355: Yeah. Did you see my code example earlier?
07:12:11 <ghost355> yes, ion :)
07:12:17 <no-n> :t noMsg
07:12:18 <lambdabot> Error a => a
07:12:40 <no-n> :t strMsg
07:12:41 <lambdabot> Error a => String -> a
07:12:48 <angerman> geekosaur: thanks yea. that grouping thing is probably a good idea. I probably head it wrong in my head, as I was considering Element = A1 { head :: Header, value1 :: Type1, value2 :: Type2, ... }
07:16:23 <ghost355> but I try to understand is it possible if has more then one matching for each case. in your example what if case 42 -> ++ and 40 -> -- and other has 2 or more way for chosing too :)
07:17:45 <ghost355> ion or its not use?
07:19:22 <ghost355> geekosaur what do you mean - use a paste site? :) what is it?
07:19:34 <ion> > (case 42 of 0 -> id; _ -> reverse) (case 43 of 0 -> "hi"; _ -> "ho")
07:19:34 <geekosaur> @paste
07:19:34 <lambdabot> Haskell pastebin: http://lpaste.net/
07:19:35 <lambdabot>  "oh"
07:20:05 <geekosaur> if you paste too much stuff into the channel, either the IRC server will kick you off for flooding or your client will lock up and the channel will be unusable for anyone else
07:20:49 <geekosaur> also getting your code with IRC stuff around it can make it harder to read and certainly harder to paste into an editor etc.
07:21:02 <geekosaur> so there are web sites where you paste stuff and then get a URL you can point other people to
07:21:03 <ion> let f n = (case n of 0 -> "hello"; _ -> "bye") ++ " " ++ (case n of 1 -> "world"; _ -> "universe") in [f 0, f 1]
07:21:10 <ion> > let f n = (case n of 0 -> "hello"; _ -> "bye") ++ " " ++ (case n of 1 -> "world"; _ -> "universe") in [f 0, f 1]
07:21:11 <lambdabot>  ["hello universe","bye world"]
07:25:26 <ghost355> ion thanks I understand, I needing  braces and semicolons syntax. And I was tried to use write it in one column in each case of using
07:29:06 <no-n> :t throwError
07:29:07 <lambdabot> MonadError e m => e -> m a
07:32:28 * hackagebot inspection-proxy 0.1.0.3 - A simple proxy for debugging plaintext protocols communication  http://hackage.haskell.org/package/inspection-proxy-0.1.0.3 (MariusGhita)
07:34:48 <athan> is >>= associative?
07:34:54 <athan> i feel like it should be
07:35:16 <athan> so that a monad becomes a monoid on the endofunctors of X
07:35:28 <jmcarthur> athan: well, there is an associativity law
07:35:30 <athan> of which are it's natural transformations
07:35:39 <athan> jmcarthur:?
07:36:09 <jmcarthur> athan: which can be rephrased as   (a <=< b) <=< c  =  a <=< (b <=< c)   where (f <=< g) x = g x >>= f
07:36:24 <athan> ahh! Perfect!!!
07:36:33 <jmcarthur> athan: by "the associativity law" i mean one of the monad laws
07:36:40 <athan> so the association still obeys the distributive laws
07:36:49 <athan> ahhh okay
07:36:52 <athan> great!
07:36:55 <jmcarthur> hm? what would it distribute over?
07:36:57 <athan> thank you!!!
07:37:08 <pranz> a monad is just that; a monoid in the category of endofunctors
07:37:11 <athan> I'm just calling `fmap` distributive haha
07:37:24 <pranz> join is the monoid combining operation
07:37:28 * hackagebot minimal-configuration 0.1.1 - Minimal ini like configuration library with a few extras  http://hackage.haskell.org/package/minimal-configuration-0.1.1 (MariusGhita)
07:37:29 <athan> NICE!!!!!
07:37:36 <pranz> :t join
07:37:37 <lambdabot> Monad m => m (m a) -> m a
07:37:37 <athan> pranz: Mind = bloooowwwwwwn
07:37:42 <ion> @quote monad.*just
07:37:43 <lambdabot> chrisdone says: it's neat how you learn haskell because you are drawn in by the purely functional paradigm, and then you find loads more things like algebraic data types, monad abstractions, arrows and applicative, lack of objects... so that when people say "well, it's not haskell, but at least X is functional", it's just not the same at all
07:37:50 <athan> pranz: and cause it has an id
07:38:02 <pranz> athan: yes, return
07:42:19 <athan> imagine if you had an invertable "state"
07:42:23 <athan> or other useful monad
07:42:40 <athan> two elements anywhere in the monoid that are dual, could then be eliminated
07:50:46 <jmcarthur> athan: actually, i showed you the "wrong" associative property if you are interested in the whole monads as monoids on the category of endofunctors. you want this property of join:    join = fmap join
07:50:53 <jmcarthur> :t join `asTypeOf` liftM join
07:50:54 <lambdabot> Monad m => m (m (m a)) -> m (m a)
07:52:05 <jmcarthur> athan: think of composition of m as being the associative thing, really
07:53:48 <athan> jmcarthur: aaaaaah, now that's interesting
07:55:01 <athan> yeah, see exactly
07:55:08 <athan> the composition of m being the associative part
07:55:10 <athan> so then
07:55:38 <athan> ( m a >>= m b ) >>= m c = m a >>= ( m b >>= m c )
07:55:50 <athan> correct?
07:56:38 <athan> hmm
07:56:51 <haskell_newb> hello
07:56:58 <athan> the composition of m as the datatype as associative?
07:57:05 <athan> hello!
07:57:32 <athan> I couldn't imagine using a type constructor like "(Maybe Maybe) Foo"
07:57:56 <athan> ...partially applied type constructors? Now that's voodoo
07:58:14 <haskell_newb> how come that haskell is slower than nodejs? http://lpaste.net/1552136451322281984
07:58:17 <irene-knapp> hm
07:58:20 <haskell_newb> am i doing something wrong?
07:58:30 <irene-knapp> isn’t that the same as Maybe (Maybe Foo)?
07:58:40 <irene-knapp> because if so, I would always write it in the latter form for clarity
07:59:45 <irene-knapp> haskell-newb: it looks as though that benchmark is a tie to three significant figures
07:59:55 <irene-knapp> how many iterations was it?  do you even have three significant figures?
08:00:04 <ion> type O a b c = a (b c); (Just . Just) 42 :: (Maybe `O` Maybe) Integer
08:00:13 <irene-knapp> I wouldn’t assume that the Haskell websockets library you’re using is necessarily faster than Node's,
08:00:31 <athan> irene-knapp: just doing associativity experiments
08:00:50 <irene-knapp> but what it makes me think is that the network is being measured, and is dominating over the CPU costs
08:00:59 <irene-knapp> try to get the network costs out of it
08:01:05 <athan> ion: HAHAHAHA
08:01:09 <athan> ion: holy shit.
08:01:19 <irene-knapp> whoa, haha
08:01:21 <irene-knapp> cute
08:01:26 <irene-knapp> but WHY
08:01:41 <athan> because space
08:01:44 <athan> hahaha
08:02:03 <Hodapp> ...
08:03:30 <haskell_newb> anyone?
08:03:47 <irene-knapp> haskell_newb: did you see my response?
08:04:48 <irene-knapp> I’d additionally like to note that when you bench libraries which aren’t heavily optimized, you’re benching them, not their implementation languages
08:05:03 <irene-knapp> but the figures are seriously so close that it almost has to be that your network is where most of the time is going
08:05:30 <haskell_newb> irene-knapp: ah, you haven't spelled my nick properly but i see it no. I did couple of iteration and there is constant 1sec deifference between node and haskell.
08:05:45 <irene-knapp> ah okay, sorry
08:05:51 <haskell_newb> actually i was expecting something like haskell being 10x faster than node
08:06:14 <haskell_newb> but it's slower or equal to node :(
08:06:25 <irene-knapp> it’s a simple enough task that I am not surprised at node having similar performance
08:06:41 <irene-knapp> your figures don’t show a 1sec difference
08:07:04 <irene-knapp> node has a slower “minimum”, and an 0.1-second-faster “average”
08:07:15 <irene-knapp> also an 0.2-second-faster “maximum"
08:07:47 <haskell_newb> irene-knapp: okay, still something you won't expect from compiled vs interpreted language...
08:07:54 <irene-knapp> but how many iterations was each test run?  how did you invoke the testing tool?  what was your testing methodology?
08:08:42 <irene-knapp> I agree; as such, I suspect your benchmark is not measuring language performance but rather network performance, perhaps because of how you set up the testing scenario
08:08:47 <haskell_newb> irene-knapp: i used https://www.npmjs.org/package/websocket-benchmark with -c 10000 and -n 50000
08:09:25 <irene-knapp> that’s a fair number of iterations.  is it running both the server and client on the same machine?
08:09:43 <irene-knapp> (it probably shouldn’t be, but they should be on the same LAN)
08:10:06 <haskell_newb> irene-knapp: i'm running my servers and that benchmark on same machine, yeah
08:10:09 <athan> @src Traversable
08:10:09 <lambdabot> class (Functor t, Foldable t) => Traversable t where
08:10:09 <lambdabot>     traverse    :: Applicative f => (a -> f b) -> t a -> f (t b)
08:10:09 <lambdabot>     sequenceA   :: Applicative f => t (f a) -> f (t a)
08:10:09 <lambdabot>     mapM        :: Monad m => (a -> m b) -> t a -> m (t b)
08:10:09 <lambdabot>     sequence    :: Monad m => t (m a) -> m (t a)
08:10:24 <irene-knapp> the reason not to do that is that they are sharing cpu and memory resources with each other
08:10:41 <irene-knapp> which means that the benching tool and the server software can interfere
08:11:29 <irene-knapp> anyway, if you’re looking for someone to hold accountable for the results you’re seeing, that’s not me :)
08:11:51 <irene-knapp> that response time is rather large for BOTH of them, although
08:11:56 <irene-knapp> perhaps not so large for that many threads
08:12:19 <irene-knapp> oh - you know what it probably is
08:12:38 <irene-knapp> your operating system probably performs poorly with vast quantities of connections all trying to open at once
08:12:45 <Kron> is there any way to make GHCi apply -Wall to compilations and C-c C-l loads, but not apply -Wall to just using the repl?
08:13:02 <Kron> I can't even do basic math without it screaming at me about defaulting the Num typeclass
08:13:13 <irene-knapp> no clue
08:13:18 <haskell_newb> irene-knapp: heh, using linux. anyways thanks for response!
08:13:21 <ion> .ghci: :set -Wall -fno-warn-type-defaults
08:13:35 <irene-knapp> haskell_newb: the TCP port space is only sixteen bits, so you’re exhausting them, I suspect
08:13:39 <Kron> well I /do/ want it to warn me about type defaults
08:13:46 <irene-knapp> anyway, yes, good luck :)
08:13:47 <Kron> ... in actual source code files. Not repl poking.
08:14:00 <Fuuzetsu> Kron: alias ghci to not use -Wall when you just want to use it as a REPL to play with
08:14:18 <Kron> I use GHCi inside emacs and constantly compile my code against it
08:14:37 <Kron> I guess... I should rework C-c C-l to send it to GHCi with the wall command? is that doable?
08:15:19 <Philonous> Kron, You can just :set -Wall inside ghci
08:15:38 <Philonous> Oh
08:15:41 <Philonous> Not when using repl
08:16:23 <nadirs> Hey, a quick question about cabal: can it generate a license file? Like, for example I ask for MIT and it creates a MIT license file?
08:16:37 <haskell_newb> heh, mean for libwebsockets echo server is 11045.65304ms
08:16:39 <haskell_newb> C
08:17:05 <irene-knapp> that should be a tipoff that you’re not testing what you think you are
08:17:06 <Philonous> Kron, you could defadvice haskell-process-load-file to send "-Wall" before reloading the file and "-w" afterwards
08:17:20 <irene-knapp> only with CPU-bound tasks does it make sense to think that you are in any sense testing language efficiency
08:17:27 <Kron> yeah I'm probably gonna have to do that
08:18:17 <rioch> How do I call a pure function (e.g: myLast :: [a] -> a) from main? I want to compile and run it.
08:18:44 <Philonous> rioch, What do you mean by "call"? A function doesn't _do_ anything.
08:19:10 <nadirs> rioch: if you're inside a do block I think you can use the let syntax
08:19:37 <ion> rioch: print (myLast [])
08:19:58 <Kron> is there a way to name wildcards, prolog style?
08:19:59 <Philonous> ion, You're evil ;)
08:20:29 <Fuuzetsu> Philonous: maybe he found a way to produce any ‘a’ from ‘[a]’!
08:20:46 <Philonous> Fuuzetsu, Computer scientists hate him!
08:21:01 <hpc> one weird trick for proving termination!
08:21:06 <irene-knapp> lol
08:21:30 <Fuuzetsu> Single mother discovered one weird trick to extract ⊥ from [⊥], find out how!
08:21:49 <rioch> I have: 'main do last <- mylast [1,2,3,4] putStrLn last' and get an error "No instance for (Num (IO String)) arising from the literal `1'"
08:22:13 <irene-knapp> yes, I see how that error would be confusing
08:22:43 <Philonous> rioch, Try main = do {let last = myLast [1..4]; putStrLn (show last)}
08:22:45 <ion> rioch: mylast [1,2,3,4] is not :: IO Something, “last <- ” isn’t appropriate. do { let { last = mylast [1,2,3,4] }; putStrLn last }
08:23:04 <Philonous> ion, No instance for Num String
08:23:20 <Fuuzetsu> s/putStrLn/print/
08:23:22 <ion> Whoops, missed that part. print.
08:23:43 <rioch> I need to call show explicitly then, or use this print thingy. Ok, let me see.
08:23:47 <ion> “Surely there is no more than one error. *turns brain off*”
08:24:38 <Philonous> rioch, print is just putStrLn and show combined into one: print x = putStrln (show x)
08:24:53 <Fuuzetsu> :t last $ map (return . show) [1 .. 4]
08:24:54 <lambdabot> Monad m => m String
08:25:23 <rioch> Philonous: thank you. It works now.
08:25:41 <Fuuzetsu> > do { x <- last $ map (return . show) [1 .. 4]; putStrLn x }
08:25:42 <lambdabot>  <IO ()>
08:27:51 <SwashBuckla> anyone know Elm but is for some reason not in #elm? I am struggling to update this code to use the new FFI: https://github.com/thSoft/elm-lib/blob/master/Chat/Chat.elm
08:29:33 <SwashBuckla> that code uses `foreign import jsevent' which is very outdated. Elm now uses ports to communicate to and from JavaScript
08:29:49 <SwashBuckla> example: https://github.com/evancz/elm-html-and-js/blob/master/Stamps.elm
08:30:29 <SwashBuckla> I can almost see how to do it myself, but I'm attempting to save effort here :)
08:31:36 <angerman> so if I want to map over all fields in a Record, say data D = D String String String, magicMap f $ D "a" "b" "c" === [f "a", f "b", f"c"]
08:32:35 * hackagebot xss-sanitize 0.3.5.1 - sanitize untrusted HTML to prevent XSS attacks  http://hackage.haskell.org/package/xss-sanitize-0.3.5.1 (GregWeber)
08:33:12 <douglarek> ?src ($)
08:33:13 <lambdabot> f $ x = f x
08:33:20 <ion> angerman: You might write a traversal for that and use combinators from lens.
08:33:22 <douglarek> ?src cycle
08:33:22 <lambdabot> cycle [] = undefined
08:33:22 <lambdabot> cycle xs = xs' where xs' = xs ++ xs'
08:33:35 <no-n> what's ?src - @src
08:34:09 <rioch> myLast xs = head $ reverse xs; work but myLast = head . reverse; doesn't; however myLast = head . reverse; does. Why does the $ variant require the parameter?
08:34:11 <no-n> aka diff ?src @src
08:34:29 <SwashBuckla> @src cycle
08:34:29 <lambdabot> cycle [] = undefined
08:34:29 <lambdabot> cycle xs = xs' where xs' = xs ++ xs'
08:34:38 <angerman> ion: ok, but generally one could traverse the items in a record, right?
08:34:40 <Fuuzetsu> I'd probably make D into ‘D a = D a a a’ and then use the standard typeclasses like Traversable and friends
08:34:44 <douglarek> I install hoogle , and execute hoogle data, failed with `gzip: downloads/hoogle.tar.gz: uncompress failed`
08:34:51 <douglarek> anyone knows?
08:35:23 <nadirs> when I run `cabal init` I choose MIT but when cabal tries to generate the package it says "Warning: unknown license type, you must put a copy in LICENSE yourself.". Any idea?
08:35:49 <Fuuzetsu> rioch: You just said head . reverse doesn't work and it does work
08:35:49 <irene-knapp> that isn’t a failure
08:35:59 <irene-knapp> it’s telling you that if you want your license to be clear to people
08:36:04 <irene-knapp> you should create a file called LICENSE
08:36:08 <irene-knapp> which has it (as text)
08:36:19 <douglarek> nadirs: you can choose 7
08:36:22 <irene-knapp> but it should have succeeded with creating the .cabal file, regardless
08:36:36 <nadirs> douglarek: I choose 8 which is MIT
08:36:46 <nadirs> irene-knapp: in fact it succeds in creating the .cabal file
08:36:47 <Philonous> rioch, Because f $ x = f x and f . g = \x -> f (g x). so head . reverse = \x -> head (reverse x) but head $ reverse = head reverse (which doesn't type check)
08:36:59 <irene-knapp> nadirs: good.
08:37:10 <nadirs> irene-knapp: though, I thought it could generate a generic LICENSE template file
08:37:19 <Fuuzetsu> nadirs: it should be able to
08:37:21 <nadirs> which I could then customise with my data
08:37:24 <Fuuzetsu> for the stock choices that is
08:37:26 <irene-knapp> generic to what text the text file actually contains?
08:37:33 <irene-knapp> the LICENSE is never in any particular format
08:37:36 <irene-knapp> it’s just text
08:37:37 <rioch> Philonous: so it has nothing to do with being partially applied?
08:37:43 <irene-knapp> google up your preferred license and copy-paste it
08:37:55 <nadirs> irene-knapp: like this (http://mit-license.org/) for instance
08:38:02 <irene-knapp> yes
08:38:06 <irene-knapp> much like that :)
08:38:21 <Fuuzetsu> oh https://github.com/haskell/cabal/blob/master/cabal-install/Distribution/Client/Init/Licenses.hs doesn't actually have MIT
08:38:26 <irene-knapp> just copy-paste it.  most Haskell projects use BSD3, so it’s not astonishing to me that it doesn’t...
08:38:27 <irene-knapp> right
08:38:28 <Fuuzetsu> maybe it'd be worthwhile to ask the to add it
08:38:41 <angerman> ion: on a similar note, say I have data T = T { x :: String, y :: String, z :: String }, i could write a function test r@(T _ "foo" _) = "bar" ; test (T _ _ _) = "baz"
08:38:56 <identity> My god
08:39:01 <identity> tikz is awesome.
08:39:03 <nadirs> irene-knapp: indeed I can just do that, but I could do it with the other files as well (Setup.hs, package.cabal). I was just wondering if cabal should do that with the license file too. Anyway, good to know. Thanks
08:39:06 <angerman> ion, but can I check directly for a given item? say that y == "foo" ?
08:39:07 <identity> okay, oops, this was the wrong channel
08:39:10 <angerman> identity: it is!
08:39:14 <identity> but yes, it is haha.
08:39:32 <Philonous> rioch, Well, not directly. The problem is that ($) doesn't compose functions but applies them.
08:39:39 <irene-knapp> nadirs: well, I mean, the .cabal is heavily customized based on your answers, and cabal init exists as a shortcut.  personally I never use cabal init.
08:40:25 <nadirs> irene-knapp: why not? "cabal init" + cabal sandbox is quite handy
08:40:42 <nadirs> irene-knapp: what's your work-flow if I may ask?
08:40:50 <rioch> Philonous: so head $ reverse tries to apply reverse (without a parameter) to head, which fails because head requires a list and not a function?
08:40:55 <irene-knapp> the only thing that init does is create the files you need the first time
08:41:11 <irene-knapp> I actually install everything globally, because I am slightly insane
08:41:19 <colDrMcBeardman> is there a foldl that can be used over [Maybe a]?
08:41:20 * Fuuzetsu shudders
08:41:26 <irene-knapp> now that sandboxes are rolled out and I’ve learned them (kicking and screaming), I’ll probably switch
08:41:31 <irene-knapp> but not until the next GHC upgrade
08:41:34 <irene-knapp> because I already have stuff installed
08:41:42 <Fuuzetsu> colDrMcBeardman: doing what?
08:41:44 <_jacco> rioch: exactly
08:41:48 <nadirs> irene-knapp: I always fall in cabal hell whenever I try to install something globally
08:41:56 <irene-knapp> yes, I’m rather good at resolving that
08:41:59 <irene-knapp> but it’s annoying :)
08:42:05 <SwashBuckla> I wonder if let cycle' x = concat xs' where xs' = (x : xs') is faster than
08:42:05 <nadirs> so I just sandbox everything nowadays :P
08:42:09 <SwashBuckla> @src cycle
08:42:09 <lambdabot> cycle [] = undefined
08:42:09 <lambdabot> cycle xs = xs' where xs' = xs ++ xs'
08:42:13 <colDrMcBeardman> Fuuzetsu, anything, really. Say I want to add all the a's in a [Maybe a] and just ignore the Nothings
08:42:28 <Fuuzetsu> :t sum . maybes
08:42:29 <lambdabot>     Not in scope: `maybes'
08:42:29 <lambdabot>     Perhaps you meant `maybe' (imported from Data.Maybe)
08:42:31 <SwashBuckla> probably not
08:42:41 <Fuuzetsu> :t justs
08:42:42 <lambdabot> Not in scope: `justs'
08:42:42 <colDrMcBeardman> Fuuzetsu, oh, right maybes. I always forget that.
08:42:47 <irene-knapp> anyway, I wouldn’t really call installing dependencies “workflow” either…  I mean, it’s a preparation step
08:42:48 <Fuuzetsu> what is that bloody function called
08:42:52 <nadirs> irene-knapp: yeah, I've lost the count of "rm -r .cabal/{lib,bin}" :P
08:42:54 <irene-knapp> when I’m working on code I, you know, “cabal build” a lot :)
08:42:55 <Fuuzetsu> :t sum . catMaybes
08:42:55 <lambdabot> Num c => [Maybe c] -> c
08:43:26 * colDrMcBeardman goes and reads Data.Maybe again.
08:43:59 <nadirs> irene-knapp: about "workflow", I tend to use words quite randomly (I haven't exactly mastered Albion's language :P)
08:44:04 <irene-knapp> fair lol
08:44:15 <irene-knapp> but I’m not sure what you were trying to ask in that case :)
08:44:53 <rioch> _jacco: thx
08:44:55 <nadirs> irene-knapp: well, I meant what are the usual (often repetitive) steps you take when you set up a project
08:45:36 <irene-knapp> oh
08:46:04 <irene-knapp> I copy a .cabal from another project that’s similar with regard to deployment (ie, shares the property of being open-source, personal and private, or for my employer), and edit it
08:46:18 <irene-knapp> then I grudgingly copy the Setup.hs and LICENSE files as well, look in them once to make sure they’re right, but don’t change anything
08:46:31 <irene-knapp> then I do cabal install —only-dependencies —dry-run
08:46:42 <irene-knapp> if it wants to reinstall anything I tell it NO
08:46:55 <irene-knapp> and figure out why until it no longer wants to
08:47:23 <Fuuzetsu> what do you do when you have two projects that clash regarding library dependencies?
08:47:44 <nadirs> irene-knapp: I see. thanks for sharing!
08:47:49 <irene-knapp> if the one I’m currently working on requires a newer version
08:47:52 <irene-knapp> anytime :)
08:47:59 <Fuuzetsu> changing versions is not an option, might be dependency requirements etc
08:48:05 <irene-knapp> then I upgrade it, and the next time I work on the other one, I upgdate the minimum on that one too
08:48:14 <irene-knapp> *update
08:48:26 <irene-knapp> this means that not all my projects build at any given time, yes
08:48:34 <irene-knapp> sandboxes are much nicer than this
08:48:37 <Fuuzetsu> terrifying
08:48:38 <irene-knapp> but I wish that sandboxes nested
08:48:46 <Fuuzetsu> nested?
08:48:49 <irene-knapp> you know, if Docker would run on an OS X kernel
08:48:56 <irene-knapp> I would probably use it instead of sandboxes
08:48:56 <Fuuzetsu> You can refer to other sandboxes from a sandbox
08:49:02 <irene-knapp> can you?
08:49:08 <irene-knapp> and it imports all the packages from the parent?
08:49:13 <irene-knapp> I didn’t see that feature.  how is it done?
08:49:16 <Fuuzetsu> don't know
08:49:20 <Fuuzetsu> (if it imports)
08:49:28 <irene-knapp> well, I mean, makes them available
08:49:30 <irene-knapp> to things in the child sandbox
08:49:35 <irene-knapp> because
08:49:40 <irene-knapp> there are a handful of important and complicated packages
08:49:43 <Fuuzetsu> but AFAIK you can have a sandbox with Text and you can refer to that from projects that need Text
08:49:43 <irene-knapp> which never build cleanly on OS
08:49:45 <irene-knapp> OS X
08:49:56 <irene-knapp> because of the clang/cpp issue
08:50:10 <irene-knapp> so I edit them by hand every time I install them (my text editor has a macro for it, at this point)
08:50:17 <irene-knapp> it’s a giant pain in the a**
08:50:21 <irene-knapp> and I hate doing it
08:50:24 <irene-knapp> so I want to only have to do it once
08:50:30 <Fuuzetsu> I think that's getting fixed now, I think the patch is pretty much ready
08:50:39 <irene-knapp> that’d be nice.  what cpp impl are we using?
08:50:45 <Fuuzetsu> impl?
08:50:52 <irene-knapp> implementation
08:50:52 <Fuuzetsu> oh, implementation
08:51:07 <nadirs> very off-topic but I wonder: why is everyone using Mac (and its OS) these days?
08:51:08 <Fuuzetsu> I don't know the details, there's a massive ticket on Trac somewhere
08:51:21 <Fuuzetsu> nadirs: because shiny, right?
08:51:21 <StoneCypher> nadirs: it's less than six percent
08:51:26 <irene-knapp> nadirs: because it’s good
08:51:36 <irene-knapp> Fuuzetsu: okay - I’ll try to find it
08:51:38 <nadirs> I mean "everyone" as "every developer"
08:51:47 <Fuuzetsu> nadirs: but they aren't
08:51:49 <StoneCypher> very few developers i know outside the bay area use macs
08:51:50 <irene-knapp> because it’s a Unix GUI that works
08:51:56 <irene-knapp> unlike X11 :)
08:52:03 <Fuuzetsu> X11 works just fine, tyvm
08:52:08 <irene-knapp> also I dislike the Linux kernel’s general approach
08:52:26 <irene-knapp> well, I mean, I was asked, but I don’t want to debate what constitutes a working GUI :)
08:52:30 <StoneCypher> sounds like you're trying to sell people on macs.
08:52:31 <nadirs> Fuuzetsu: +1 :)
08:52:34 <irene-knapp> I was just stating my position
08:52:56 <nadirs> irene-knapp: I don't know about the kernel, but the whole system is quite nice
08:53:11 <irene-knapp> listen, you’re entitled to your opinion
08:53:23 <irene-knapp> I would never tell anyone else to switch OS
08:53:43 <StoneCypher> nadirs: consider getting actual data on what developers use, instead of trying to explain what you've seen in your local social circles.
08:53:53 <irene-knapp> and I don’t get why Linux zealots very often act like it’s a personal affront that I don’t agree with their choice
08:53:57 <StoneCypher> nadirs: all of our visibility is heavily biassed
08:54:03 <nadirs> StoneCypher: actually where I live everyone uses windows so, meh
08:54:05 <StoneCypher> irene-knapp: i'm not a linux zealot, thanks
08:54:13 <notdan> irene-knapp: because GNU/Linux is a lifestyle, heh
08:54:13 <irene-knapp> okay.  then that statement was not about you.
08:54:17 <StoneCypher> irene-knapp: i bet
08:54:22 <StoneCypher> irene-knapp: the reason people get offended that you don't agree with their choices is nobody asked you
08:54:34 <irene-knapp> I was, in fact, asked.  by nadirs.
08:54:44 <nadirs> I'm just seeing videos companies make (GitHub, 8th light, Google, etc.)
08:54:45 <StoneCypher> you were speaking in the genera,l
08:54:46 <irene-knapp> I’m not going to lie or hide the fact that I use a Mac
08:55:01 <StoneCypher> nobody here is offended, and i think maybe you might be somewhat confused by the difference between offended and bored/annoyed
08:55:04 <nadirs> and they all use OS X
08:55:14 <irene-knapp> I didn’t say “offended”.  you did.
08:55:21 <StoneCypher> irene-knapp: lol, no
08:55:23 <nadirs> (by the way, I'm sorry I started these :/ )
08:55:26 <nadirs> *this
08:55:31 <StoneCypher> nadirs: that's okay
08:55:36 <StoneCypher> nadirs: you didn't know there was one of those here
08:55:46 <notdan> btw, there is #haskell-blah for such discussions :P
08:56:01 * StoneCypher has a faster solution
08:56:17 * StoneCypher just drops it
09:04:21 <StoneCypher> nadirs: for the record, i can't find anyone having looked into it more recently than 2011, but 2011 was mac's peak (it's been going downwards since), and the studies done in 2008, 2009, 2010, and 2011 show windows gaining among devs while it was (no longer is) slipping in the primary world
09:04:58 <StoneCypher> in end-2011 windows had >80% developer market share according to Evans Data, which is impartial to stay alive in the way that neilsen is
09:05:19 <StoneCypher> apparently mac has surpassed linux, which i find very surprising, but that's what the data says
09:05:24 <StoneCypher> 7.9% to 5.1%
09:06:13 <Fuuzetsu> and how was this data gathered?
09:06:15 <StoneCypher> scuse, 5.6%, my mistake
09:06:19 <Fuuzetsu> I don't remember anyone asking me.
09:06:32 * SwashBuckla nods
09:06:52 <StoneCypher> oh, they're quite transparent about that, if you're interested
09:06:58 <StoneCypher> looks like the 2013 one is underway right now
09:06:59 <StoneCypher> http://www.evansdata.com/reports/viewRelease_download.php?reportID=19
09:07:16 <StoneCypher> looks like it's a 1300 person survey, geodistributed
09:08:00 <Fuuzetsu> StoneCypher: I don't see a link to the report
09:08:08 <Fuuzetsu> >Online purchasing coming soon for this report.
09:09:03 <StoneCypher> yeah, that's because 1) it's not done yet and 2) you get to pay money for that answer, like the journalists did
09:09:28 * Fuuzetsu loses all interest
09:09:52 <StoneCypher> i mean there's probably a way to measure it for free, but i've no idea what that would be without introducing severe bias
09:12:03 <angerman> say I have a typeclass X a where x :: a -> String; and now I'd like to create an instance for everything that can "show", such that x y = show y is. But I somehow fail to understand how to define an instance for a typeclass on a class of types.
09:14:07 <t4nk555> Hi. How is the support for GHCI on ARM going, esspecially for GHC 7.8
09:14:27 <triliyn> angerman: if you just do "instance Show a => X a", that instance overlaps with everything, because any type could be given a Show instance (even if it doesn't have one now)
09:15:07 <Fuuzetsu> x' = show
09:15:41 <triliyn> One way to deal with this is to use a newtype, like: newtype UseShowForX a = USFX a
09:16:11 <triliyn> Then you can use the USFX wrapper to use Show but you can also implement your own X instances if you need to
09:16:50 <triliyn> If you really want to have it as an overridable default you might be able to use the OverlappingInstances extension, but I think that's generally considered a bad idea
09:17:09 <angerman> I guess I need wrap my head around this first.
09:18:56 <yitz> angerman: the problem is that "an instance for everything that can 'show'" is a statement about your entire program, now and in the future, not just about this type or this module.
09:19:38 <t4nk555> if anyone is looking here is something interesting
09:19:39 <t4nk555> http://bgamari.github.io/posts/2014-03-06-compiling-ghc-7.8-on-arm.html
09:38:27 <carter> t4nk555: it should work on arm
09:38:37 <carter> t4nk555: if it doesnt, ask bgamari  and thoughtpolice  for help when they have time
09:38:39 <carter> well
09:38:49 <carter> first email ghc-users list or cafe
09:38:54 <carter> then escalate to emailing ghc-devs
09:38:58 <t4nk555> Thanks carter
09:39:03 <carter> then escalate to asking them on irc on #ghc
09:39:08 <carter> then escalate to a ticket on trac
09:39:23 <carter> t4nk555: i *think* theres an ARM RC2 build
09:39:42 <t4nk555> ou nice
09:40:07 <carter> nb, idk if its arm >= V7 or V6
09:40:17 <carter> rpis are v6 which is old and ghetto i'm told :)
09:40:37 <carter> t4nk555: so normal arm should be a tier 1 platform for 7.8
09:40:44 <carter> and ios should be a tier 2
09:40:49 <carter> thats A LOT of new platform
09:41:08 <t4nk555> gonna check it out test and report bugs
09:42:06 <carter> there shoulnd't be any....
09:42:11 <carter> or at least no show stoping ones
09:42:29 <Zekka> http://lpaste.net/102017 <- shorter question: violating the lens laws would make my program much neater -- is it reasonable and is there an alternative I've missed?
09:42:31 <carter> aside from 1-2 hard crashes on windows, every new bug fix is going to be in 7.8.2
09:43:23 <Zekka> also I just realized there's no word wrap on lpaste: sorry about that
09:47:08 <artyomkazak> Zekka: word-wrapped: http://lpaste.net/102017
09:47:39 <Zekka> artyomkazak - That was kind of you, thanks.
09:47:45 * hackagebot ad 4.0.0.1 - Automatic Differentiation  http://hackage.haskell.org/package/ad-4.0.0.1 (EdwardKmett)
09:47:56 <artyomkazak> (wow, I didn't know that public pastes are edited inplace – sorry 'bout that)
09:48:16 <Zekka> I didn't either, but it doesn't look like you edited it in a way that breaks anything
09:50:46 <artyomkazak> Zekka: what if you make `state` a custom Lens instead of letting it be derived automatically? Then you can have it clear _heuristics without having to do it manually every time
09:51:04 <Zekka> artyomkazak - That's option 1.
09:51:21 <Zekka> I'm concerned that it would violate the lens laws
09:51:21 <artyomkazak> Ouch, r-right
09:51:33 <Zekka> namely, state %= id would also clear heuristics
09:52:06 <Zekka> I'm mostly trying to work out what it would break if anything
09:52:36 <Zekka> The structure's very rarely mutated (although the heuristic table gets added to a lot)
09:52:47 <artyomkazak> then you might define state and justState – the first one would be intelligent, the second − dumb
09:53:12 <Zekka> That sounds like it could work, sure
09:53:38 <Zekka> My feelings are that the code other than the part which analyzes the structure don't really care about the heuristics table at all
09:54:03 <joelteon> Someone wrote a blog post about writing a pgsql API in Haskell using dependent types, iirc
09:54:07 <joelteon> anybody remember what I'm talking about?
09:54:20 <Zekka> there's basically a specific portion of the code that iteratively performs different kinds of analysis (each in Stateful [ResultType]) and all of them do a few things in common which are hard to predict in advance
09:54:27 <Zekka> so for that, caching seems useful
09:57:26 <artyomkazak> you might be breaking the letter of lens laws here, but I don't think you'd be breaking the spirit of them, especially if you guarantee that _heuristics don't accidentally pop up in Eq, Show instances and so on
09:58:38 <Zekka> Yeah, even though I doubt that anyone will actually use the Eq instance in this specific case
09:58:51 <Zekka> Well, actually, I take that back
09:59:01 <Zekka> there was a specific case where I figured the Eq instance would come in handy
09:59:18 <Zekka> so in general it's really uncommon but might still happen
09:59:53 <ge0Shira> hi, is it possible to find all nodes by label in fgl?
10:00:20 <edwardk> alternately you could split the heuristcs from the value you are modifying, gather all of them up in some combinator that can recompute them and apply it after al your modifications to the state.    or you could treat heuristics strictly as a cache and only access it through a combinator that takes what to do when the heuristic isn't there, and treat the lens as holding up to the correctness of the use of that operation
10:01:12 <Eduard_Munteanu> ge0Shira: I'm not familiar with it, but if you can convert to a list, a traversal really, you can filter on that.
10:01:27 <Eduard_Munteanu> :t nodes
10:01:28 <lambdabot> Not in scope: `nodes'
10:01:30 <Eduard_Munteanu> @hoogle nodes
10:01:31 <lambdabot> Data.Graph.Inductive.Graph nodes :: Graph gr => gr a b -> [Node]
10:01:31 <lambdabot> Data.Graph.Inductive.Monad nodesM :: GraphM m gr => m (gr a b) -> m [Node]
10:01:31 <lambdabot> Data.Graph.Inductive.NodeMap delMapNodes :: (Ord a, DynGraph g) => NodeMap a -> [a] -> g a b -> g a b
10:01:41 <Zekka> edwardk - I think I considered the first of those, and I was planning to do the second but I'm not sure exactly how it solves my problem
10:03:22 <Zekka> For get-access to heuristics I was planning to use alternatives to builtins along the lines of whenHeuristic, guardHeuristic, etc.
10:03:23 <ge0Shira> Eduard_Munteanu: thanks, i was thinking there should be graph optimizaed function for that in fgl but it's seems to be not the case
10:03:53 <Zekka> but I don't see how that helps when heuristics need to be cleared in the case of ordinary set operations to state
10:04:41 <Eduard_Munteanu> ge0Shira: the traversal is likely good, so I don't think it matters.
10:04:43 <edwardk> if you have a closed set of heuristics you could instead switch to a representable cache of the answers.
10:04:53 <bezirg> question: How can I turn the compiler flag -fwarn-missing-methods to be an error , while keeping the other warning as simple warnings and not errors?
10:05:05 <Zekka> There's not really any way to know how many or what heuristics there are in advanced
10:05:07 <bezirg> warnings*
10:05:21 <Zekka> advance*
10:05:32 <bezirg> what I do now is -Werror -fwarn-missing-methods, and this turns all warnings into errors
10:05:43 <Eduard_Munteanu> bezirg: have you tried something like -Werror=warn-missing-methods? I remember something very similar to that in gcc.
10:05:57 <Zekka> I was tempted to try calculating all of them before each round of analysis and clearing them all immediately after, but the vast majority would never actually be used
10:06:08 <Zekka> (Although laziness might make that matter a little less)
10:06:13 <edwardk> well, what i mean is if you change from String -> Bool which givs you no information to something like f Bool  where f is a functor full of boolean results that could have lazy leaves
10:06:32 <edwardk> then you compute by forcing
10:06:55 <Eduard_Munteanu> Any chance trifecta has attribute grammars, or anything that could get me an unparser from a parser, for free?
10:06:56 <Zekka> I'm not sure I quite follow, could you be a little more specific?
10:07:02 <edwardk> Eduard_Munteanu: nope
10:07:28 <Eduard_Munteanu> Thanks.
10:07:41 <Zekka> I have a feeling what you're suggesting is pretty straightforward but I'm not immediately getting it
10:07:54 <edwardk> Zekka: a representable functor f has an natural isomorphism between f a  and (x -> a) for some x.  so we'll call x' the representation of the representable functor.
10:08:14 <edwardk> an example, data Complex a = a :+ a   is representable by Bool.      t can be seen as a function Bool -> a
10:08:45 <bezirg> Eduard_Munteanu: -Werror=warn-missing-methods does not work
10:08:48 <edwardk> tabulate f = f False :+ f True         index (a :+ _) False = a; index (_ :+ b) True = b
10:08:53 <Zekka> I'm not quite sure how it's representable by bool but I'm understanding the concept
10:09:14 <edwardk> tabulate shows (Bool -> a) -> Complex a    and index goes back
10:09:25 <Eduard_Munteanu> bezirg: what are the symptoms? Perhaps there's a different thing to put after the equals sign.
10:09:25 <edwardk> Complex a -> (Bool -> a)
10:10:05 <edwardk> you can view Complex a as a tabulation of some function (Bool -> a) where every answer has been memoized in a separate field
10:10:12 <Zekka> Right, so because it's a one-to-one mapping, any function written using f a can also be written sing (Bool -> a)?
10:10:25 <Zekka> and the other way around?
10:10:30 <edwardk> yes
10:10:45 <edwardk> the package 'adjunctions' provides Data.Functor.Rep for these kinds of functors
10:10:46 <bezirg> Eduard_Munteanu: it complains it is not a valid OPTIONS_GHC pragma
10:10:59 <edwardk> and you get dozens of instances for free, as that is a lot of structure
10:11:01 <edwardk> now
10:11:03 <vermeille> In which case would you need to define your own monad instances? it looks to me that reader/writer/state almost always do the job
10:11:06 <Eduard_Munteanu> bezirg: you should try it on the command line first
10:11:31 <edwardk> if you make the 'heuristic set being used' visible in the type as a parameter 'f' for some functor
10:11:34 <Eduard_Munteanu> vermeille: mostly never, really :)
10:11:40 <bezirg> Eduard_Munteanu: : y that's what I did
10:12:19 <vermeille> Eduard_Munteanu: so why the do all the books spends a lot of time on that topic oO?
10:12:31 <edwardk> and make a class or some such that provides class Representable f => Heuristics f where heuristics :: YourState -> f Bool
10:12:33 <hpc> vermeille: there are more interesting monads than just reader/writer/state
10:12:37 <Eduard_Munteanu> vermeille: unless you're saying Reader et al. are all you ever need; of course, there are many more useful monads.
10:12:40 <hpc> such as Cont
10:12:52 <hpc> or Parsec
10:13:03 <hpc> or that one i forget the name of that does version control
10:13:07 <Eduard_Munteanu> I initially interpreted the question as being about redefining instances of State etc.
10:13:11 <edwardk> then you could have your updates 'refresh the cache' by calling that on the first argument and storing it as the second nyour Complicated data type.
10:13:26 <edwardk> then you can index in by heuristic, the heuristic would be the representation of f.
10:13:30 <hpc> you will very occasionally want to write your own monads that do new things
10:13:32 <ge0Shira> how can i sepcify multiple typeclass constraints in function? for eaxmple i want to contraint a to Eq in "foo :: Graph gr => gr a b -> Bool"?
10:13:35 <haasn> IO is not reader, writer or state
10:13:41 <haasn> and it's certainly very useful
10:13:51 <haasn> because without it, we could not write very many useful applications
10:13:51 <Eduard_Munteanu> ge0Shira: (Constraint1 x, Constraint2 y) => ...
10:13:52 <edwardk> it is a lazily constructed cache of all heuristics so you only pay for the ones you use
10:13:52 <Zekka> edwardk -  Hold up, let e write some sample code to make sure I understand your idea
10:13:53 <vermeille> hpc, sure, but it's still another already defined monad. When do you have, as a "simple" user to define a monad from scratch? (which can't be based on any standard)
10:13:58 <ge0Shira> Eduard_Munteanu: thanks
10:14:03 <monochrom> (Graph gr, Eq a) => gr a b -> Bool
10:14:27 <ge0Shira> was trying without parens
10:14:57 <Eduard_Munteanu> It can't work without them.
10:15:07 <hpc> vermeille: parsing or version control
10:15:20 <Eduard_Munteanu> Though you can still use parens for only one constraint (or even a null constraint '()')
10:15:25 <hpc> vermeille: of course, the nature of programming is that once one person writes the code everyone else can use it ;)
10:15:26 <edwardk> data Complicated f = Complicated YourState (f Bool)
10:16:03 <vermeille> hpc: for parsing, what's wrong with a State ParseState a?
10:16:18 <hpc> you can't easily do backtracking
10:16:42 <hpc> (or multiple matches, or however you deal with parse failures)
10:16:53 <monochrom> I am doubtful of the value of arguing how much a book should tell you about monads. write your own book.
10:16:54 <vermeille> oh, right
10:17:06 <edwardk> state f (Complicated xs _) = f xs <&> \xs' -> Complicated xs' (calculateHeuristics xs')
10:17:29 <hpc> actually, here's the source for Parsec: http://hackage.haskell.org/package/parsec-3.1.5/docs/src/Text-Parsec-Prim.html#ParsecT
10:17:38 <edwardk> you don't need complex represntable machinery, just the fact that f is lazy really.
10:17:41 <Zekka> Oh, hold up, I see you're writing your own example. I'll draw a line and copy yours down under mine to see if we ended up writing the same thing
10:17:47 <vermeille> monochrom: that's not the point. I just spent a lot of time understanding how to define your owns, and now that I understood... I very rarely do it
10:18:03 <monochrom> ok, do you want your money back?
10:18:19 <vermeille> Haha
10:18:40 <Eduard_Munteanu> Don't put your money in monads, you can never get it back. :P
10:18:45 <hpc> there's also attoparsec which has a different monad for parsing with some advantages and disadvantages
10:18:47 <monochrom> hahaha
10:18:52 <athan> is there a language extension that could test for properties, then instantiate a type / function set into a typeclass? I was thinking, why not have associativiy and identity tested over a datatype / function combo, then automatically create the Monoid instance if it passes?
10:19:10 <monochrom> @remember Eduard_Munteanu Don't put your money in monads, you can never get it back. :P
10:19:10 <lambdabot> It is stored.
10:19:22 <athan> it would be like the morphism view of typeclasses/types
10:19:32 <hpc> athan: there isn't; it runs into the halting problem
10:19:39 <athan> hpc: Interesting!
10:19:51 <hpc> you should check out something like agda or idris
10:20:01 <hpc> which can encode those things into the type system
10:20:01 <athan> hpc: We have ways to test properties, though, so I'm just wondering
10:20:09 <athan> yeah I thought I'd head down that road soon haha
10:20:49 <angerman> what's the difference between () and []?
10:20:51 <hpc> we have ways to test properties, but we don't have a way to prove them
10:20:57 <monochrom> () and [] are unrelated
10:21:13 <athan> hpc: aaaaaahhhhhh
10:21:15 <athan> hpc: wow
10:21:15 <Twey> angerman: One is round, one is square
10:21:20 <athan> hpc: that's interesting.
10:21:32 <angerman> Twey: ah! hadn't noticed that.
10:21:49 <Eduard_Munteanu> :t (1, 2)
10:21:50 <lambdabot> (Num t, Num t1) => (t, t1)
10:21:54 <Eduard_Munteanu> :t [, 2]
10:21:55 <lambdabot> parse error on input `,'
10:21:57 <Eduard_Munteanu> :t [1, 2]
10:21:57 <lambdabot> Num t => [t]
10:21:57 <dwcook> angerman, as values, () is the value of type unit (besides bottom) and [] is the empty list. As types, () is the unit type and [] is the list constructor.
10:21:59 <athan> hpc: is that similar to how `head []` fails becuase of the Sum / Product datatype being "short circuited"?
10:22:11 <joelteon> can anyone help me with this? I've been beating my head against a wall since yesterday http://lpaste.net/102019
10:22:23 <angerman> so I cannot abuse (a,b,c,d) as [a,b,c,d] for an inhomogenous list.
10:22:33 <Eduard_Munteanu> angerman: exactly
10:22:33 <dwcook> Nope, they are different types
10:22:41 <dwcook> That first thing's a tuple, by the way, not unit
10:22:48 <hpc> athan: those two things are unrelated
10:22:49 * hackagebot csv-conduit 0.6.2.1 - A flexible, fast, conduit-based CSV parser library for Haskell.  http://hackage.haskell.org/package/csv-conduit-0.6.2.1 (OzgunAtaman)
10:22:54 <hpc> head [] fails because it is defined to fail
10:22:56 <angerman> thanks guys!
10:23:24 <edwardk> Zekka: even simpler, i suppose: class Heuristics k where heuristics :: YourState -> k -> Bool   can be made to work if you're careful about setting up the function
10:23:29 <athan> hpc: Hmm. So why wouldn't a comprehensive test of all possabilities be technically a proof, with invariant functions?
10:23:41 <angerman> So, I have a set of fns with signatures A -> X, A -> Y, A -> Z
10:23:44 <edwardk> if the function internally is lazy enough that can be made to do the right thing
10:23:59 <Eduard_Munteanu> athan: how do you test Int? Go through all 2^64 combinations for a 64-bit wide Int?
10:24:01 <hpc> yes, an exhaustive test can be a proof
10:24:05 <angerman> I cannot put them in a list, right?
10:24:12 <hpc> but you have to have a finite domain in order to finish testing ;)
10:24:20 <dwcook> angerman, right, you cannot.
10:24:20 <athan> Eduard_Munteanu: Ahhh, so it starts to hit the fan when infinite types are considered
10:24:41 <edwardk> data Complicated k = Complicated YourState (k -> Bool) -- where the latter is just the resut of partialy applying heuristics to YourState.
10:24:41 <hpc> not infinite types, but types with an unbounded number of values
10:24:45 <Eduard_Munteanu> athan: it hits the fan before infinity, unless the set is very small
10:24:54 <dwcook> angerman, you can however turn those into A -> (X, Y, Z) if you so desired for some reason
10:24:55 <athan> hpc: What if it's recursive? :P
10:24:56 <Zekka> edwardk - I'm still staring at exactly the machinery I've got here: I've got types that look vaguely like mine, and a 'state' function which looks like a lens -- minding that if it's meant to be one I don't think I can use the properties of the Heuristics typeclass.
10:24:59 <hpc> (infinite types are a different thing)
10:25:16 <Eduard_Munteanu> angerman: what do those functions do?
10:25:35 <athan> hpc: waaaaaah there goes my brain
10:25:37 <Zekka> http://lpaste.net/102020 <- this is what I've got from your previous suggestion
10:25:41 <angerman> dwcook: I have a typeclass that would turn X -> B, Y ->B, Z -> B, say f. I wanted to do map f [f1, f2, f3]
10:26:12 <dwcook> angerman, you could use a heterogeneous list
10:26:25 <angerman> dwcook: haskell has those?
10:26:25 <Eduard_Munteanu> angerman: why not store [f f1, f f2, f f3] directly, instead?
10:26:27 <ktosiek> is there something like that in Haskell?
10:26:29 <dwcook> angerman, sort of
10:26:36 <Zekka> One of my first points of confusion is why state seems generalized to any functor (like a lens) instead of using only Heuristics and using the heuristics method instead of taking the (InnerState -> f Bool) as a parameter
10:27:13 <edwardk> Zekka: http://lpaste.net/102020
10:27:15 <edwardk> simpler
10:27:23 <angerman> Eduard_Munteanu: map f [...] seems less cluttered, and has better readablity?
10:27:35 <angerman> Eduard_Munteanu: that's kindof the motiviation I have.
10:27:49 <Zekka> Alright, and your argument is that f just generalizes ((->) a)?
10:28:11 <edwardk> Zekka: well, lets drop thinking about f for a minute, and just think about how to write such a functon
10:28:12 <edwardk> =)
10:28:15 <dwcook> angerman, a list of these would do the trick: data Bable = (ToB a) => Bable a
10:28:19 <Eduard_Munteanu> angerman: where do you get the fN's from in the first place?
10:28:42 <Eduard_Munteanu> Is it a tuple?
10:28:46 <edwardk> the first Heuristics instance we can come up with is one where 'a' is a function from InnerState.
10:28:57 <Zekka> edwardk - Right. a is probably some algebraic data type along the lines of `data Heuristics = AllExist | NoneExist`
10:29:03 <angerman> Eduard_Munteanu: the `accesors`/fields from a data constructor.
10:29:04 <dwcook> angerman, I wrote that wrong actually, I don't remember the correct syntax
10:29:36 <edwardk> instance (a ~ InnerState, b ~ Bool) => Heuristics (a -> b) where heuristics i k = k i
10:29:39 <Eduard_Munteanu> angerman: oh, then just pass the record type... are there issues with that?
10:29:46 <angerman> dwcook: so I basically setup a data type to capture the fns and then put the functions in the data and put the datas in the list.
10:29:59 <dwcook> angerman, data Bable = forall a. (ToB a) => Bable a
10:30:06 <dwcook> (You'll need ExistentialQuantification enabled)
10:30:08 <edwardk> Zekka: yeah, then you can work with things like your simpler Heuristic type, or test with a larger slower function type like the one i just gave that'd recompute each time
10:30:09 <angerman> Eduard_Munteanu: I'm trying to "serialize" the record type.
10:30:15 <dwcook> angerman, yes, or what Eduard_Munteanu said
10:30:23 <edwardk> but the instances for 'a' would give you the caching behavior
10:30:42 <Zekka> I'm going to play with yours a little bit
10:31:07 <Eduard_Munteanu> angerman: you can't really do it nicely other way than serializing all fields at once.
10:31:22 <Eduard_Munteanu> angerman: unless you use something like Generics
10:31:41 <Eduard_Munteanu> angerman: have you tried simply deriving Show?
10:31:58 <edwardk> instance Heuristics YourHeuristics where heuristics (MyState ...) = let ... build up all the intermediate results you need for all heuristics ... in \ xs -> case xs of AllExist -> result1; NoneExist -> result2
10:32:09 <angerman> Eduard_Munteanu, so I had the idea of taking a list of all the `accessors`, and mappning my typeclass function over it.
10:32:22 <angerman> Eduard_Munteanu: well show does not "serialize" in the form I need.
10:32:29 <edwardk> the let binding captured all the parts in closures, now result1, and result2 just force the parts they need
10:32:42 <Eduard_Munteanu> angerman: what do you need?
10:32:46 <edwardk> if you need more heuristics, build a new 'a' and have it use some of the old YourHeuristics
10:32:54 <Zekka> edwardk - Yeah, that's what I figured, possibly specialcasing some cases like 'the heuristic has a function inside of it'
10:33:10 <Zekka> assuming there's not some unintentional drawbacks that happen if you do that
10:33:44 <edwardk> my usual tricks there are do to things like reflection to grab the function and make it show in the type
10:33:53 <edwardk> but i like types to show my invarants
10:33:58 <edwardk> YMMV
10:34:31 <angerman> Extended example: data D = D { x :: Int, y :: String, z :: [String] }, (I have a typeclass, that turns Int -> B, String -> B, [String] -> B), say toB, map (\x -> toB . x $ D { x = 1, y = "foo", z = ["bar","baz"] }) [x,y,z]
10:34:58 <edwardk> gotta run
10:35:01 <edwardk> good luck!
10:35:26 <angerman> Eduard_Munteanu: the record basically encodes the information in a readable fashing. For the serilization, I need a list of [B], which then in turn is encoded.
10:35:33 <Zekka> See you
10:35:59 <angerman> Eduard_Munteanu: And I'm going to have a lot of data types of D, thus i try to atomate the process of turning the record into a list.
10:36:28 <Eduard_Munteanu> angerman: I was going to suggest using a library that can serialize any Generic/Data, if you need some known format like JSON.
10:36:53 <angerman> Eduard_Munteanu: it's not a well known format. More of the very obscure kind.
10:37:47 <angerman> Eduard_Munteanu: my first sketch at what I wanted to get was http://lpaste.net/6340123678885281792
10:37:51 * hackagebot ltk 0.13.2.0 - Leksah tool kit  http://hackage.haskell.org/package/ltk-0.13.2.0 (HamishMackenzie)
10:37:53 * hackagebot leksah 0.13.4.0 - Haskell IDE written in Haskell  http://hackage.haskell.org/package/leksah-0.13.4.0 (HamishMackenzie)
10:38:25 <aranea> (Monad m =>) When there are a function f :: a -> b -> c and values x :: m a, y :: m b, one can write f <$> a <*> b :: m c. However, This isn't possible with f :: a -> b -> m c. Sure, one could use a do block, first do x' <- x and y' <- y and then simply f x' y', but that seems kinda tedious. Isn't there a shorter way to write that?
10:39:02 <angerman> Eduard_Munteanu: writeElement with implicit destructuring, I already have know how to optimize. writeElement e@(A1 "A" 1 _ _) = ...
10:39:02 <aranea> So, I'm searching for a version of (=<<) with (a -> b -> m c) instead of (a -> m b)
10:40:07 <Eduard_Munteanu> angerman: there isn't a safe way to construct / destruct records step by step, other than Data / Generics / TH magic
10:40:58 <Eduard_Munteanu> angerman: I mean stuff like  http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Data.html
10:41:15 <Eduard_Munteanu> (don't worry about instances, they can be derived)
10:42:02 <Eduard_Munteanu> But I have a feeling you're focusing on a particular record type.
10:43:31 <angerman> Eduard_Munteanu: no, my records are plain. with values of types in (Int, String, [String]), for now.
10:44:06 <angerman> Eduard_Munteanu, but I could do it explicitly, which is why I tried to stuff the accessors in a list.
10:44:22 <angerman> Eduard_Munteanu: that way I could potentially also control, which accessors are fetched.
10:44:58 <Eduard_Munteanu> angerman: you should just call the serializing function manually on each field
10:46:18 <angerman> Eduard_Munteanu: :)
10:47:26 <mwhitfield> \quit
10:47:35 <Eduard_Munteanu> angerman: consider doing it the other way around, parsing it. You would extract all fields in the same function and build the record all at once.
10:47:56 <Eduard_Munteanu> Otherwise you would not be able to know you got a full definition.
10:48:56 <angerman> Eduard_Munteanu: yes parsting is done that way. But for ~300 record types, with potentail 3 versions, any automatism would have been nice.
10:49:41 <Eduard_Munteanu> angerman: hm, in that case TH / generics would be nice, yeah.
10:49:56 <angerman> TH is non portable, right?
10:50:05 <Eduard_Munteanu> angerman: and you could also use it to automate record declarations
10:50:15 <Eduard_Munteanu> FSVO portable.
10:50:20 <Eduard_Munteanu> angerman: what do you mean portable?
10:50:35 <geekosaur> TH doesn't work with non-GHC, but there aren't many Haskell compilers other than GHC
10:50:45 <geekosaur> and the ones that do exist are limited in many other ways as well
10:50:51 <angerman> Eduard_Munteanu: I'd like to keep the option to cross compile it to a library I could ue on the iPhone.
10:52:10 <Eduard_Munteanu> angerman: I don't see how TH affects that
10:52:47 <Eduard_Munteanu> angerman: you could also write a code generator
10:53:17 <Eduard_Munteanu> And run it only once.
10:54:54 <angerman> Eduard_Munteanu: yea. I don't recall where I read that TH and iPhone incompartibility.
10:56:20 <Eduard_Munteanu> Perhaps if it's an unregistered port.
10:56:24 <angerman> Eduard_Munteanu: on that heterogenous list thing. Could I create a type that would capture from Type A to typeclass ToB?
10:56:53 <angerman> Eduard_Munteanu: I just read that somewhere and made a mental note, be cautious about TH.
10:56:59 <Eduard_Munteanu> angerman: I'm unsure what you mean, can you rephrase it?
10:58:09 <angerman> Eduard_Munteanu: I think I may have that backwards, I cannot define a type as a map, right? I cannot cerate a type that would repreent String -> Int, right?
10:58:23 <Twey> type Foo = String -> Int
10:59:09 <angerman> ok. so I can.
10:59:34 <angerman> can I also define a type that would represent String -> (Show a)?
10:59:58 <Eduard_Munteanu> angerman: you can make an existential type
11:00:31 <Twey> angerman: With an extension (ExistentialQuantification) you can define a type that represents Show a => String -> a
11:00:38 <Eduard_Munteanu> data Field = forall a. Serializable a => Field a
11:00:39 <Twey> angerman: But you'll need to wrap it in a newtype
11:00:48 <Twey> Or a data, right
11:01:05 <Eduard_Munteanu> Then you can have a [Field].
11:01:18 <Twey> That's often an antipattern, though.
11:01:19 <Eduard_Munteanu> And you can only call methods of Serializable on its contents.
11:01:54 <angerman> Eduard_Munteanu: but in that case I would need to wrap it in a data, right? e.g. Field f1
11:02:09 <Eduard_Munteanu> angerman: yes
11:03:09 <angerman> so, I cannot create common type and have the compiler accept it, without wrapping it in a data record, right?
11:03:10 <Eduard_Munteanu> On the other hand, a heterogenous list would really only be a tuple you can cons to / uncons from, much like (a, (b, (c, d))).
11:03:20 <flebron> data Showable = forall a. Show a => ShowIt a. let xs = [ShowIt 1, ShowIt "a"]
11:04:01 <Eduard_Munteanu> angerman: that's not the issue, rather that lists are homogenous.
11:04:09 <Eduard_Munteanu> For good reasons.
11:04:55 <shachaf> Keep in mind that this Showable type is useless.
11:04:56 <Eduard_Munteanu> You could make an existential list as well... e.g.  data FList = FNil | forall a. (Serializable) => FCons a FList
11:05:07 <shachaf> let xs = [show 1, show "a"]
11:05:11 <angerman> Eduard_Munteanu, so the type is not sufficient for a homogenous list?
11:05:30 <Eduard_Munteanu> angerman: what's the type of [x, y] if x :: a and y :: b
11:05:50 <Eduard_Munteanu> Also as shachaf notes, it's rather useless because you could just call show or the serializing function yourself.
11:06:00 <shachaf> All lists are homogeneous.
11:06:12 <shachaf> Even with existentials, they are homogeneous.
11:07:06 <aristid> angerman: i think your nick is supposed to be parsed anger-man, but i can't help reading it as an-german and then be pained by the "typo"
11:08:02 <Eduard_Munteanu> I read it as a germanic name, sort of.
11:08:10 <angerman> aristid, lastname truncated to 8 char :)
11:09:39 <angerman> so, i though, if i created a new type, say (Show a) => String -> a, then I could have a homogenous list of [(Show a) => String -> a]
11:10:13 <shachaf> It seems that a lot of things are being mixed up here...
11:10:40 <angerman> it's day three into haskell for me :)
11:10:45 <Eduard_Munteanu> angerman: that type is somewhat legal, but it means "a list of functions from String to any a which is Show-able"
11:10:57 <angerman> Eduard_Munteanu, yea, exatlcy :)
11:11:15 <Eduard_Munteanu> angerman: whoever builds that list has to provide a polymorphic 'a'
11:11:22 <flebron> Perhaps you should start with something more reasonable, such as LYAH.
11:11:36 <flebron> Getting into extensions is likely just going to muddle the waters.
11:11:45 <Eduard_Munteanu> Because it means  [forall a. (Show a) => String -> a]  unless you had some other quantification in mind.
11:12:28 <Eduard_Munteanu> angerman: and whoever gets such a list would be able to instantiate 'a' to any type Show-able
11:12:30 <angerman> Eduard_Munteanu: no that would be good. I know that for all the functions I put in the list, I can provide an instance for the typeclass.
11:13:13 <Eduard_Munteanu> angerman: you won't be able to build the list
11:14:11 <angerman> flebron,:)
11:14:17 <angerman> Eduard_Munteanu, hm....
11:14:35 <Eduard_Munteanu> :t let x :: Integer; x = 5 in [x]
11:14:36 <lambdabot> [Integer]
11:14:57 <Eduard_Munteanu> :t let x :: Num a => a; x = 5 in [x]
11:14:58 <lambdabot> Num t => [t]
11:15:14 <Eduard_Munteanu> :t let x :: Num a => a; x = 5 in [x] :: [Num t => t]
11:15:15 <lambdabot>     Illegal polymorphic or qualified type: Num t => t
11:15:15 <lambdabot>     Perhaps you intended to use -XImpredicativeTypes
11:15:15 <lambdabot>     In an expression type signature: [Num t => t]
11:15:26 <Eduard_Munteanu> All the above are different things.
11:16:20 <Eduard_Munteanu> The second one for example won't work in your case, since it's still the same 'a' even if polymorphic in the outer scope.
11:19:07 <angerman> hm.so it's not possible :-| at least we explored it.
11:20:11 <Eduard_Munteanu> Not just not possible, but illogical really. :)
11:20:46 <Sculptor> 7 perpedicular lines
11:21:13 <Sculptor> n
11:21:36 <Eduard_Munteanu> Is that a "7 perpendicular lines walk into a bar"-starting joke? :P
11:22:00 <angerman> Sculptor: mutually perpendicular?
11:22:15 <Sculptor> angerman, yeah. seen that sketch?
11:22:37 <Sculptor> here https://www.youtube.com/watch?v=BKorP55Aqvg
11:25:10 <angerman> can I pattern match on named fields of records? Something like fn r@(Record {name == "foo"}) =
11:25:55 <shachaf> Yes, with the same syntax you use to make them.
11:25:57 <Eduard_Munteanu> angerman: yes, it should be a normal '='
11:26:03 <shachaf> (So one =, not two.)
11:26:19 * haasn .oO( Record{..} )
11:26:24 <redtricycle> How can I ignore tags?  Trying to modify this example: http://hackage.haskell.org/package/xml-conduit-1.1.0.9/docs/Text-XML-Stream-Parse.html
11:26:30 <Eduard_Munteanu> angerman: also if you've defined a datatype as a record you can still use the constructor to match
11:26:33 <haasn> angerman: also I'm quite sure those parens are redundant
11:26:42 <redtricycle> my actual xml has <population xmlns="somethingsomething">
11:26:42 <haasn> {} parses very tightly
11:26:46 <shachaf> haasn: .oO( RecordWildCards :☹( )
11:26:46 <redtricycle> as the root
11:27:31 * haasn .oO( Record {name} )
11:27:43 * shachaf .oO( shadowing :-( )
11:28:00 <Eduard_Munteanu> NamedFieldPuns + RecordWildCards is rather awesome at times.
11:28:00 <Twey> shachaf: Not you too (☹⌢☹)
11:28:11 <redtricycle> I've tried: tagName="population" (requireAttr "xmlns" <* ignoreAttr) $ many parsePersons
11:28:26 <haasn> aaw, I expected “NamedFieldPuns :☹(” :(
11:28:56 <osa1> what should I add to my cabal file to compile lib + execs + deps with profiling enabled(I'm using sandbox)
11:29:00 <angerman> Eduard_Munteanu: so I'm confused.  through Records where synonymous to data.
11:29:26 <haasn> Eduard_Munteanu: I have to say, I prefer it to (r^.field1), (r^.field2) etc.
11:29:27 <Eduard_Munteanu> angerman: records as in data with names for fields
11:29:38 <haasn> Eduard_Munteanu: I use it together with lensy records, this makes _field1, _field2 etc. be the values you matched
11:29:48 <angerman> Eduard_Munteanu: thanks, for the clarification.
11:31:38 <joelteon> can anyone help me with this? I've been beating my head against a wall since yesterday http://lpaste.net/102019
11:32:38 <osa1> so on a fresh cabal sandbox does cabal install --enable-library-profiling --enable-executable-profiling install everything with profiling enabled?
11:32:52 <osa1> oh p_o files are generated
11:33:06 <Eduard_Munteanu> joelteon: should your arrayElem be a [Field]?
11:36:03 <donri> Sculptor: Geometry.  Just ignore it!
11:36:12 <Sculptor> ;)
11:36:25 <joelteon> Eduard_Munteanu: no, that's the element type
11:36:27 <joelteon> homogeneous array
11:39:59 <benzrf> yo
11:40:12 <benzrf> is there something that takes a list and gives back a map or assoclist of occurrences of each element
11:41:04 <benzrf> i.e. "abcabd" => [('a', 2), ('b', 2), ('c', 1), ('d', 1)]
11:41:38 <aristid> benzrf: no ready-made function but it's quite easy to build
11:41:53 <aristid> > map (group . sort
11:41:55 <lambdabot>  <hint>:1:18:
11:41:55 <lambdabot>      parse error (possibly incorrect indentation or mismatched brackets)
11:41:56 <aristid> argh
11:42:04 <aristid> > map (head &&& length) . group . sort
11:42:05 <lambdabot>  <[()] -> [((),Int)]>
11:42:21 <aristid> > map (head &&& length) . group . sort $ "abcabd"
11:42:22 <lambdabot>  [('a',2),('b',2),('c',1),('d',1)]
11:42:42 <aristid> sorry shachaf, i planned on doing that with only one line :P
11:42:48 <shachaf> help
11:42:50 <aristid> benzrf: does this help?
11:42:59 * hackagebot cake3 0.4.0.0 - Third cake the Makefile EDSL  http://hackage.haskell.org/package/cake3-0.4.0.0 (SergeyMironov)
11:43:01 * hackagebot type-level-natural-number 2.0 - Simple type level natural numbers  http://hackage.haskell.org/package/type-level-natural-number-2.0 (GregoryCrosswhite)
11:43:44 <aristid> it's quite easy to accidentally hit the ent
11:43:52 <aristid> er key
11:47:14 <benzrf> aristid: is that efficient o.O
11:47:27 <benzrf> aha i see
11:48:31 <aristid> benzrf: it probably won't win performance benchmarks, but it might be good enough:)
11:49:21 <skypers> @hoogle (:>)
11:49:21 <lambdabot> Data.Sequence (:>) :: Seq a -> a -> ViewR a
11:57:35 <benzrf> :t second
11:57:36 <lambdabot> Arrow a => a b c -> a (d, b) (d, c)
12:03:11 <dsyang> Hey all, if I'm on OSX, what's the best way to install haskell? I heard it was the haskell plafrom but that seems outdated
12:05:43 <asQuirreL> dsyang: not sure how old this information is, but I use homebrew
12:06:11 <dsyang> asQuirreL: brew install ghc? or brew install haskell-platform?
12:06:41 <asQuirreL> dsyang: I installed the haskell-platform
12:07:51 <Redz> haskell-platform isnt that old.
12:09:02 <dsyang> asQuirreL: that installs haskell-platform 2013.2.0.0 though, with GHC 7.6 and not the new cabal w/ sandboxes
12:09:31 <dsyang> I've heard cabal w/ sandboxes is the recommended way to do haskell dev?
12:09:49 <asQuirreL> dsyang: if you have need for sandboxes now, or feel you will do in the future, then feel free to install cabal on top of the haskell platform
12:09:51 <Redz> i'm sure you will survive without sandboxes. ;)
12:10:41 <hiptobecubic> i use the platform with updated cabal
12:10:58 <benzrf> @hoogle (a' -> b' -> c) -> (a -> a') -> (b -> b') -> (a -> b -> c)
12:10:59 <dsyang> Ok, I'll start with the platform then. Thanks all!
12:10:59 <lambdabot> No results found
12:11:03 <benzrf> :|
12:11:17 <asQuirreL> dsyang: I'm pretty sure cabal can be updated indpendently of even brew
12:11:19 <arrdem> so in Clojure we have -> and ->> as notation for rewriting nested expressions. Mod a comonad, how can I achieve a similar expression notation in Haskell?
12:12:57 <benzrf> arrdem: you mean like foo -> bar -> baz
12:13:07 <benzrf> instead of baz (bar foo)
12:13:24 <arrdem> benzrf: essentially
12:13:39 <hiptobecubic> (baz . bar $ foo) achieves that
12:13:45 <benzrf> hiptobecubic: shh
12:13:54 <benzrf> (|>) = flip ($)
12:14:01 <benzrf> > (|>)
12:14:02 <lambdabot>  No instance for (Control.Lens.Cons.Snoc
12:14:03 <lambdabot>                     Control.Lens.Internal.Review.Reviewed
12:14:03 <lambdabot>                     Data.Functor.Identity.Identity
12:14:03 <lambdabot>                     s0
12:14:03 <lambdabot>                     s0
12:14:05 <benzrf> oops
12:14:09 <benzrf> @let (|>) = flip ($)
12:14:10 <lambdabot>  Defined.
12:14:21 <benzrf> > 3 |> (+4) |> (+5)
12:14:22 <lambdabot>  Ambiguous occurrence `|>'
12:14:23 <lambdabot>  It could refer to either `L.|>', defined at L.hs:142:1
12:14:23 <lambdabot>                        or `Control.Lens.Cons.|>',
12:14:23 <lambdabot>                           imported from `Control.Lens' at L.hs:40:1-43
12:14:23 <lambdabot>                           (and originally defined in `lens-3.10:Control.Lens....
12:14:26 <benzrf> pfft
12:14:45 <hiptobecubic> :D
12:14:59 <hiptobecubic> > 3 L.|> (+4) L.|> (+5)
12:15:01 <lambdabot>  12
12:15:08 <benzrf> :t L.|>
12:15:09 <lambdabot> parse error on input `L.|>'
12:15:12 <benzrf> :t L.(|>)
12:15:13 <lambdabot> Not in scope: data constructor `L'
12:15:14 <lambdabot>     Ambiguous occurrence `|>'
12:15:14 <lambdabot>     It could refer to either `L.|>',
12:15:18 <benzrf> :t (L.|>)
12:15:19 <lambdabot> b -> (b -> c) -> c
12:15:22 <benzrf> kk
12:15:35 <benzrf> @hoogle a -> (a -> b) -> b
12:15:36 <lambdabot> Prelude ($) :: (a -> b) -> a -> b
12:15:37 <lambdabot> Data.Function ($) :: (a -> b) -> a -> b
12:15:37 <lambdabot> Prelude ($!) :: (a -> b) -> a -> b
12:15:38 <ezrios> so
12:15:40 <benzrf> kk
12:15:43 <ezrios> function application?'
12:17:42 <benzrf> :t liftM2 compare snd snd
12:17:43 <lambdabot> Ord b => (a, b) -> Ordering
12:17:48 <benzrf> >.<
12:17:52 <benzrf> derp
12:20:07 <rusk101> What does this actually do? [1,2,3,4,5]--[1,2,3]
12:20:18 <Redz> :t (--)
12:20:19 <lambdabot>     parse error (possibly incorrect indentation or mismatched brackets)
12:20:24 <ezrios> @hoogle (--)
12:20:24 <lambdabot> No results found
12:20:29 <alpounet> -- introduces a comment
12:20:29 <alpounet> :]
12:20:30 <benzrf> rusk101: -- is a comment
12:20:30 <ezrios> looks like a comment
12:20:34 <rusk101> lol
12:20:37 <Redz> lol.
12:20:41 <rusk101> --lol
12:21:05 <rusk101> Whats the function for set subtraction?
12:21:09 <Redz> shouldnt there a space or something behind a comment start?
12:21:13 <ezrios> > [1,2,3,4,5] \\ [1,2,3]
12:21:14 <lambdabot>  [4,5]
12:21:19 <rusk101>  ty
12:21:38 <intrados> I feel as though I generally understand the choice between sum types and typeclasses on a pragmatic level (e.g. the expression problem), but is there a "more principled" basis for choosing between the two? Like what each expresses and can express about your data?
12:21:57 <Redz> because i get a parser error on --~ . and my editor is stupid enough to write an ~ when autogenerating a comment.
12:22:09 <rusk101> hmmm. \\ is not in my scope
12:22:15 <ezrios> import Data.List
12:22:25 <ezrios> @hoogle (\\)
12:22:25 <lambdabot> Data.List (\\) :: Eq a => [a] -> [a] -> [a]
12:22:25 <lambdabot> Data.IntMap.Strict (\\) :: IntMap a -> IntMap b -> IntMap a
12:22:25 <lambdabot> Data.IntMap.Lazy (\\) :: IntMap a -> IntMap b -> IntMap a
12:22:44 <Twey> intrados: Well, typeclasses are open where sum types are closed
12:23:33 <intrados> Twey: Right. That's what I was trying to get at via the expression problem. Is that the biggest difference?
12:23:54 <rusk101> still not in scope even after I import.. hmm
12:24:09 <shachaf> Algebraic data types give you both sides of the expression problem.
12:24:48 <Twey> Yeah, that's not quite the expression problem
12:24:54 <shachaf> data Shape = Rectangle Double Double | Circle Double Double, or data Shape = Shape { area :: Double, perimeter :: Double }
12:25:22 <intrados> Twey: I know it's not quite the same but they seem at least related to me. No?
12:26:12 <kttm> hi, i can't get ghc-check-syntax working with ghc-mod
12:26:32 <kttm> ghc-show-type works so i think my install is almost correct
12:26:33 <Twey> In that they're both about the expression of things from open/closed pieces, yes
12:26:58 <kttm> does somebody have pointers or links to configure it properly?
12:27:13 <Twey> There's nothing really principled about typeclasses.  They don't have a nice place in the theory; they're just conveniences
12:27:17 <kttm> (i'm using it with emacs)
12:29:05 <intrados> Twey: Alright, thanks for the confirmation.
12:34:28 <gdoteof> http://lpaste.net/102027  I have a fucntion of type IO Value and want to call that function from a function of type HandlerT App IO t0  but can't seem to figure out what i am doing wrong
12:34:47 <gdoteof> line 10 there is telling me     Couldn't match expected type `HandlerT App IO t0'
12:34:50 <gdoteof>                 with actual type `IO Value'
12:34:52 <Eduard_Munteanu> gdoteof: liftIO
12:35:14 <gdoteof> >.<
12:35:16 <gdoteof> thanks
12:36:15 <Eduard_Munteanu> gdoteof: it's sometimes nicer / more convenient to define functions with a (MonadIO m) => ... -> m ...  type so you don't need to lift outside the function.
12:36:42 <Eduard_Munteanu> e.g. list_sessions = liftIO $ return $ object []
12:37:14 <Eduard_Munteanu> I just got spammed privately by anantaa
12:37:36 <quchen> Eduard_Munteanu: #haskell-ops?
12:38:06 <Eduard_Munteanu> I could just @where ops
12:38:10 <benzrf> what forms an arrow besides functions and newtypes around em?
12:38:12 <Eduard_Munteanu> @where ops
12:38:12 <lambdabot> arjanb bos byorgey Cale conal copumpkin dcoutts dibblego dmhouse dolio dons edwardk elliott geekosaur glguy Heffalump Igloo jmcarthur johnw kosmikus Lemmih monochrom nyc Philippa Pseudonym quicksilver roconnor Saizan shachaf shapr sjanssen ski sorear SyntaxPolice xerox
12:38:17 --- mode: ChanServ set +o copumpkin
12:38:32 <copumpkin> Eduard_Munteanu: what'd they say?
12:38:51 <Eduard_Munteanu> copumpkin: something about a private show and posted a link
12:39:06 <benzrf> ive been getting em as well
12:39:06 --- mode: copumpkin set +b *!~ircap@90.174.0.162
12:39:07 --- kick: anantaa was kicked by copumpkin (no PM (or otherwise) spam please :))
12:39:07 <intrados> I also got the same spam message from the same user
12:39:10 <benzrf> @where
12:39:10 <lambdabot>  @where <key>, return element associated with key
12:39:17 --- mode: copumpkin set -o copumpkin
12:39:18 <benzrf> @there
12:39:19 <lambdabot>  @where <key>, return element associated with key
12:39:54 <Eduard_Munteanu> benzrf: does 'Kleisli m' count as a wrapper around a function?
12:41:20 <Twey> benzrf: Every arrow has to in some sense be a ‘wrapper around a function’ because of arr
12:41:30 <Twey> :t arr
12:41:30 <lambdabot> Arrow a => (b -> c) -> a b c
12:42:25 <Twey> So in the application of ‘arr f’, at some point f has to be called; the only thing you can do is do things before/after doing so
12:43:19 <benzrf> Twey: oh right
12:43:23 <benzrf> derp
12:43:29 <angerman> is ther ea map like function that takes the arguments in reverse? E.g. map f [a b c] === [f a, f b, f c], but I want [a f, b f, c f], Is there something other than map' o fs = map (\f -> f o) fs ?
12:43:50 <benzrf> angerman: how about map ($v)
12:43:54 <Eduard_Munteanu> > map ($ f) [a, b, c]
12:43:56 <lambdabot>  Couldn't match expected type `a0 -> b0'
12:43:56 <lambdabot>              with actual type `Debug.SimpleReflect.Expr.Expr'Couldn't match e...
12:43:56 <lambdabot>              with actual type `Debug.SimpleReflect.Expr.Expr'Couldn't match e...
12:43:56 <lambdabot>              with actual type `Debug.SimpleReflect.Expr.Expr'
12:43:59 <Eduard_Munteanu> :(
12:44:19 <fizruk> > map ($ x) [f, g, h]
12:44:20 <lambdabot>  No instance for (Debug.SimpleReflect.Expr.FromExpr b0)
12:44:20 <lambdabot>    arising from a use of `e_1'
12:44:20 <lambdabot>  The type variable `b0' is ambiguous
12:44:20 <lambdabot>  Possible fix: add a type signature that fixes these type variable(s)
12:44:20 <lambdabot>  Note: there are several potential instances:
12:44:32 <Eduard_Munteanu> > map ($ (f :: Expr)) [a, b, c]
12:44:33 <lambdabot>  Couldn't match expected type `Debug.SimpleReflect.Expr.Expr -> b0'
12:44:33 <lambdabot>              with actual type `Debug.SimpleReflect.Expr.Expr'Couldn't match e...
12:44:33 <lambdabot>              with actual type `Debug.SimpleReflect.Expr.Expr'Couldn't match e...
12:44:33 <lambdabot>              with actual type `Debug.SimpleReflect.Expr.Expr'
12:44:45 <Eduard_Munteanu> > flip table
12:44:52 <lambdabot>  Not in scope: `table'
12:45:01 <Twey> > map ($ a) [f, g, h]
12:45:04 <lambdabot>  No instance for (Debug.SimpleReflect.Expr.FromExpr b0)
12:45:06 <lambdabot>    arising from a use of `e_1'
12:45:07 <quchen> > map ($ x) [f, g, h] :: [Expr]
12:45:08 <lambdabot>  The type variable `b0' is ambiguous
12:45:10 <lambdabot>  [f x,g x,h x]
12:45:11 <Twey> All variables are not  created equal
12:45:12 <quchen> :-)
12:45:12 <lambdabot>  Possible fix: add a type signature that fixes these type variable(s)
12:45:16 <lambdabot>  Note: there are several potential instances:
12:45:22 <tapuu> How do i put a literal backslash in a string?
12:45:23 <Rufflewind> has anyone encountered an issue where the configure script for GHC gets stuck on "checking for a BSD-compatible install..." (on Windows)
12:45:27 <Eduard_Munteanu> tapuu: \\
12:45:29 <geekosaur> \\
12:45:51 <tapuu> I've tried that, its giving me "parse error on input '\'"
12:46:04 <Twey> > "\\"
12:46:04 <quchen> > "\\"
12:46:05 <lambdabot>  "\\"
12:46:05 <lambdabot>  can't find file: L.hs
12:46:07 <angerman> thanks. ... what did I just start? ....
12:46:08 <Twey> Haha
12:46:20 <Eduard_Munteanu> tapuu: do you have more than 2 backslashes in the string?
12:46:26 <Twey> quchen: Race condition ⁵
12:46:35 <tapuu> Oh wait I'm looking at the wrong line
12:46:39 <tapuu> sorry
12:46:44 <kuribas> To get a cursor from a TextCtrl in wxHaskell I have to use : "textCtrlPositionToXY :: TextCtrl a -> Int -> Ptr CInt -> Ptr CInt -> IO Int".  Not very nice!
12:46:56 <tapuu> I messed up lambda syntax on the line below
12:47:03 <kuribas> How do I create a Ptr CInt?
12:48:29 <geekosaur> look in Foreign.Marshall.Array?
12:48:50 <Twey> kuribas: With a malloc, Foreign.ForeignPtr.mallocForeignPtr
12:49:00 <Twey> But I suspect there's a better way to do this
12:49:15 <kuribas> ok, thanks
12:50:07 <kuribas> Twey: there isn't :(
12:50:30 <kuribas> Twey: I mean another API for this...
12:50:35 <geekosaur> depending on what you are doing, mallocArray alllocaArray (or the 0 variants with a terminating element)
12:50:45 <Eduard_Munteanu> You might want gtk2hs if you're not into it too deep already.
12:51:20 <kuribas> very deep
12:51:26 <geekosaur> the alloca ones let you pass code to run with the temporary array in scope, the malloc ones are for longer term use
12:51:30 <kuribas> And wxhaskell is quite portable.
12:51:53 <kuribas> alloca allocates on the stack?
12:52:10 <aristid> yes
12:52:11 <geekosaur> in C it does, but that's not really a mechanism in Haskell
12:52:39 <aristid> oh i didn't know there's an allocaArray
12:53:05 <geekosaur> it has the same general behavior of going out of allocation/scope once the code block you pass completes
12:53:14 <aristid> geekosaur: how does it work? if it used alloca(2), it would use the stack
12:53:19 <kuribas> Ok, I see.
12:53:26 <geekosaur> aristid, what is the stack in ghc?
12:53:39 <kuribas> alloca is nice because there is no memory allocation overhead.
12:53:40 <geekosaur> ghc's execution model doesn't really work that way
12:53:43 <aristid> geekosaur: my knowledge of ghc code generation is sadly limited
12:53:50 <aristid> geekosaur: but alloca is a C function
12:53:55 <geekosaur> yes, I know
12:53:57 <aristid> so when you call it, it uses the C stack
12:54:00 <geekosaur> the name doesn't indicate the mechanism
12:54:12 <Eduard_Munteanu> There would still be a stack in the executable.
12:54:13 <geekosaur> because there isn't really a call stack like there is in C
12:54:14 <aristid> geekosaur: so it's a misleading name! :P
12:54:33 <aristid> so what _does_ allocaArray do, exactly?
12:54:34 <geekosaur> since evaluation is lazy and "outside in"
12:54:44 <Eduard_Munteanu> As in stack frame, stack segment and all that.
12:55:05 <geekosaur> there is, but it doesn't behave like it does in C
12:55:50 <Eduard_Munteanu> There probably is code like the libc wrappers which still require a standard notion of stack.
12:56:01 <geekosaur> ...
12:56:09 <geekosaur> yes, there is, when executing foreign code
12:56:20 <geekosaur> if haskell code executes that way then it is in IO and strict
12:56:37 <geekosaur> that is, it's not haskell code
12:56:57 <kuribas> Alloca works in IO and is strict right?
12:57:12 <kuribas> allocaArray
12:57:17 <Eduard_Munteanu> Ok, I know the Haskell and C stack are completely different things, I thought they're both present though.
12:57:19 <geekosaur> somehow I feel like I am digging myself a hole of incomprehensibility
12:57:45 <geekosaur> they are both present. the C stack has essentially no relevance to evaluation of Haskell code and is not safe to use for allocations
12:57:56 <Eduard_Munteanu> Ah, I see.
12:58:14 <kuribas> geekosaur: Do you mean that allocaArray might not use the C stack, or are you sure?
12:58:16 <geekosaur> C's alloca only works with the way C uses the stack, and its scoping is completely out of sync with Haskell scoping
12:59:14 <kuribas> That's true...
12:59:44 <geekosaur> and having just traced through the source, it's allocating a pinned byte array in the heap
13:00:47 <geekosaur> I can't see it actually using the C stack because, seen from the standpoint of the C stack, stuff creates closures and returns the closure immediately --- so if it were alloca-d, it would go out of scope immediately
13:01:02 <geekosaur> (using the C version of alloca which extends the stack frame)
13:01:37 <arrdem> bitemyapp: RFC, the Clojure map/reduce imp'l is obvious, the haskell one less so. https://github.com/arrdem/freki/blob/master/Model/Game/Freki.hs#L172
13:05:30 <aristid> geekosaur: does it do some GC stuff differently?
13:05:49 <geekosaur> anyway it's a lie if you insist on the C version isnce it's in the heap, but it's proper "alloca" from the viewpoint of the relevant Haskell stack which is closures waiting to be forced by pattern matching --- the storage is automatically freed when the relevant closure goes out of scope either by being fully evaluated or by an outer (pattern match) stack frame going out of scope
13:07:23 <Eduard_Munteanu> Hm, right, I wasn't taking Haskell scoping into consideration.
13:07:31 <geekosaur> aristid: not really except insar as it's pinned so GC can't move it
13:07:37 <geekosaur> *insofar
13:08:20 <geekosaur> which would be expected since it's a foreign array so you have to assume that the code relying on it cannot be notified of it being moved by GC
13:08:33 <geekosaur> (generally C or other foreign language code)
13:09:07 <geekosaur> otherwise, the pointer has a finalizer that releases the allocated heap memory when the pointer goes out of scope
13:12:52 <Eduard_Munteanu> Hm, lately, I've been using an indentation style comprised of 8 space units ("tabs") with separators stealing space on the left, like data Foo = Foo {\n____fieldA :: TypeA\n__, fieldB :: TypeB\n}.
13:13:41 <geekosaur> I think that only works inside braces?
13:13:52 <Eduard_Munteanu> And generally I try to avoid variable indentation on the left, e.g. prefer line breaks on definitions just after the '=' sign, rather than indenting everything according to the LHS's length.
13:14:29 <Eduard_Munteanu> geekosaur: also things like   foo =  bar\n____<|> baz
13:14:38 <Eduard_Munteanu> Or such stuff.
13:15:07 <Eduard_Munteanu> Or even lists, except you also get the '[' on its own line.
13:15:14 <geekosaur> I think there are some limitations on how much you can "bend" the indentation there, thugh
13:15:53 <cdk> I think one of the nicest things about Haskell (that isn't talked about enough) is having a post-optimization IR at a higher level than ASM or LLVM's IR. Being able to look at the generated Core is so useful for debugging performance or laziness problems I find I miss it when I write in anything but Haskell. Does any other language have something similar? I can't think of any myself.
13:16:02 <Eduard_Munteanu> I personally dislike things like 'verylongline = do' with everything lined up after the '='.
13:16:35 <aristid> Eduard_Munteanu: especially if you then change the contents of 'verylongline"
13:16:42 <aristid> like add a parameter
13:16:49 <Eduard_Munteanu> Right.
13:18:42 <Eduard_Munteanu> I tend to stick to 80 columns as well, but I wonder if there's some research on all this.
13:31:01 <joeyh> is there any way to catch when I forget to list a new source file in my .caball file?
13:31:38 <Eduard_Munteanu> joeyh: I think haskell-mode picks them up automatically if you're using Emacs
13:32:13 <zenkeku> Is there a value (type?) constructor named Cons?
13:32:30 <zenkeku> Not :, I mean the literal word "Cons"
13:32:34 <Eduard_Munteanu> zenkeku: no
13:33:00 <aristid> data Foo = Cons -- now there is
13:33:06 <Eduard_Munteanu> zenkeku: neither, but since you're ambivalent I suspect you might be confused about something.
13:34:12 <zenkeku> Eduard_Munteanu: That's very likely. I'm currently reading the book Real World Haskell by O'reilly Publishing. In Chapter 3 there is a specific function that uses both "Cons" and "Nil". Would it be useful to profile a screen shot?
13:34:27 <zenkeku> to provide*
13:34:44 <Eduard_Munteanu> zenkeku: or a link, but I guess they're defining it themselves.
13:35:44 <zenkeku> @paste
13:35:44 <lambdabot> Haskell pastebin: http://lpaste.net/
13:36:31 <zenkeku> http://lpaste.net/102029 The first group of functions are the ones defined in the book, the second are how I think they should look.
13:37:18 <zenkeku> I am aware that this function seems to do nothing.
13:37:49 <Eduard_Munteanu> zenkeku: the book might try to convert a normal Haskell list to an otherwise identical variety.
13:38:45 <_jacco> the book tries to show that you can convert an ordinary haskell list into your custom list datatype, since they have the same shape
13:38:46 <Eduard_Munteanu> @let data List a = Nil | Cons a (List a)
13:38:47 <lambdabot>  Defined.
13:39:27 <Eduard_Munteanu> @let data List a = Nil | Cons a (List a) deriving Show
13:39:27 <lambdabot>  .L.hs:147:6:
13:39:28 <lambdabot>      Multiple declarations of `List'
13:39:28 <lambdabot>      Declared at: .L.hs:144:6
13:39:28 <lambdabot>                   .L.hs:147:6
13:39:28 <lambdabot>  
13:39:28 <monochrom> what are lines 4-5 doing? I mean, they look out of place.
13:39:42 <Eduard_Munteanu> @undefine
13:39:42 <lambdabot> Undefined.
13:39:44 <Eduard_Munteanu> @let data List a = Nil | Cons a (List a) deriving Show
13:39:45 <lambdabot>  Defined.
13:39:49 <Eduard_Munteanu> > let fromList (x:xs) = Cons x (fromList xs); fromList [] = Nil in fromList [1,2,3]
13:39:50 <lambdabot>  Ambiguous occurrence `Cons'
13:39:50 <lambdabot>  It could refer to either `L.Cons', defined at L.hs:144:15
13:39:50 <lambdabot>                        or `Math.OEIS.Types.Cons',
13:39:50 <lambdabot>                           imported from `Lambdabot.Plugin.Haskell.Eval.Truste...
13:39:50 <lambdabot>                           (and originally defined in `oeis-0.3.5:Math.OEIS.Ty...
13:39:59 <Eduard_Munteanu> Oh lawd.
13:40:14 <monochrom> perhaps @undefine first :)
13:40:19 <Eduard_Munteanu> > let fromList (x:xs) = L.Cons x (fromList xs); fromList [] = L.Nil in fromList [1,2,3]
13:40:21 <lambdabot>  Cons 1 (Cons 2 (Cons 3 Nil))
13:40:40 <zenkeku> Eduard_Munteanu: Ah.. I looked previously in the book (one page before) and it seems I missed where they defined that.
13:40:47 <Eduard_Munteanu> monochrom: that looks like an import
13:40:58 <monochrom> I see
13:41:19 <monochrom> oh! yeah, "Math.OEIS.Types.Cons", can't be helped
13:41:53 <monochrom> isn't Haskell exciting!
13:42:49 <scb> Is there any library to colorize the output of haskell I/O ?
13:43:21 <merijn> zenkeku: Basically, the point LYAH is trying to make that aside from the unusual syntax, lists are just a datatype you could define yourself in haskell
13:43:31 <Eduard_Munteanu> RWH.
13:43:48 <bitemyapp> arrdem: map and reduce in Haskell isn't obvious?
13:43:49 <merijn> Oh, RWH, whatever :p
13:43:51 <merijn> Same diff :p
13:43:52 <zenkeku> merijn: Alright. This whole thing is difficult to wrap my head around.
13:44:05 <zenkeku> Sorry for the silly questions.
13:44:21 <Eduard_Munteanu> zenkeku: it's only another list-like thing with different names
13:44:23 <arrdem> bitemyapp: it's still obvious...
13:44:31 <arrdem> bitemyapp: it's just that my gut is to drag data.map in
13:44:44 <monochrom> don't worry, they are not silly questions
13:44:52 <arrdem> bitemyapp: since the reduce value is {String -> FA}
13:44:57 <merijn> zenkeku: If RWH is difficult, you may also want to look at Learn You a Haskell, it's a bit slower paced (imo), mixing them also works, since LYAH doesn't really mention any exercises
13:45:13 <bitemyapp> arrdem: which line are you using to go from String -> FA?
13:45:53 <zenkeku> merijn: I am mixing them, as of right now.
13:46:02 <merijn> :)
13:48:12 <arrdem> bitemyapp: the idea was (reduce (fn [a m] (update-in a [(modelName m)] decFA)) (into {} (map (juxt modelName fieldAllowance) models)) models)
13:49:07 <arrdem> bitemyapp: there isn't a specific line I wrote that out on, cause I'm unsure on the translation.
13:49:37 <bitemyapp> arrdem: the upper level, the reduce, is just foldr.
13:50:22 <bitemyapp> arrdem: if you actually need a non-deterministic bag of models referenced by name, that can make sense, but it seems like you wouldn't have a way to disambiguate two models of the same name.
13:50:50 <arrdem> bitemyapp: that's the intended behavior. There is no case when two models of the same name do not share a single FA
13:51:08 <arrdem> bitemyapp: so if I have [Charger, Charger, Charger] those all count against the same FA U of Charger.
13:51:26 <bitemyapp> arrdem: but it *is* scoped to a particular player
13:51:31 <bitemyapp> arrdem: so it's instanced for each player.
13:51:51 <arrdem> bitemyapp: sure. I'm ignoring that by validating one list at a time in isolation.
13:51:57 <bitemyapp> arrdem: Data.Map just requires Ord on the keys, so you could just implement or derive Ord on the models, then have a map that goes from Model -> FA
13:52:18 <bitemyapp> arrdem: if you don't even want to implement Ord, use unordered-containers.
13:52:39 <bitemyapp> OTOH, that could be annoying if you have multiple instances...hrrm...yeah just do String -> FA
13:52:58 <arrdem> <3
13:52:59 <bitemyapp> arrdem: I endorse String -> FA Data.Map, I don't have anything superior off-hand :)
13:53:14 * hackagebot digestive-functors 0.7.1.0 - A practical formlet library  http://hackage.haskell.org/package/digestive-functors-0.7.1.0 (JasperVanDerJeugt)
13:54:07 <arrdem> bitemyapp: cheers. I'll play with this some more later...
13:54:48 <bitemyapp> arrdem: have fun :)
14:00:06 <Algebr> What the heck is a hidden package?
14:00:49 <merijn> Algebr: A package installed/registered with GHC, but not explicitly listed in cabal dependencies (usually)
14:01:24 <geekosaur> ghc will not attempt to use modules from a hidden package
14:01:50 <geekosaur> you can hide things explicitly, or cabal will temporarily hide any package not listed as a dependency in the whatever.cabal file
14:02:04 <Galactic> If I want to use Data.Text how can I use getContents like in regular strings...  I wan to do something like  T.lines getContents
14:02:21 <Galactic> but they are not the same type
14:02:26 <Algebr> What would be the purpose of doing that
14:02:32 <Eduard_Munteanu> Galactic: use Data.Text.IO
14:02:58 <Eduard_Munteanu> It gives you a getContents for Text.
14:03:05 <Galactic> aaa ok ty, i will take a look at that.
14:03:10 <merijn> Galactic: Use what Eduard_Munteanu says, or, the more proper way is to use the hGetContents functions in Data.ByteString and then use Text.Encoding to decode ByteString to Text
14:03:15 * hackagebot ad 4.1 - Automatic Differentiation  http://hackage.haskell.org/package/ad-4.1 (EdwardKmett)
14:03:39 <Eduard_Munteanu> You might also like Data.Text.Lazy{,.IO}
14:05:56 <Galactic> is there any difference in performance between Data.Text.IO and Data.Text.Lazy.IO?
14:06:10 <Galactic> the documentation seems the same.
14:06:16 <bitemyapp> Galactic: performance for what?
14:06:29 <bitemyapp> Galactic: need a specific test-case/behavior to speak to anything
14:07:10 <Galactic> well, I guess my question is where do I want to use Data.Text.IO vs Data.Text.Lazy.IO  or vise versa.
14:08:24 <Eduard_Munteanu> Galactic: if you're just getting input lines they should be almost equivalent performance-wise (however behavior is different)
14:08:37 <lispy> lazy IO is rarely correct IO
14:08:46 <lispy> But, do these do strict IO and return lazy text?
14:09:15 <lispy> What I mean to say is, do they stream out lazy text?
14:09:37 <merijn> Galactic: For just learning, either will be fine
14:09:51 <merijn> Galactic: The first will read everything into memory, the second will use lazy IO
14:09:52 <Galactic> alright
14:10:11 <merijn> Galactic: Lazy IO has some issues if you want reliable/long running software, but for prototyping/learning it's fine
14:10:33 <merijn> Galactic: Just make a mental note of asking "How/why do I avoid lazy IO?" when you want to write "production" software
14:10:46 <lispy> there are two main things to watchout for when using the lazy IO stuff. a) Do you close the file before you're done with it? b) Do you hold the whole 'stream' in memory instead of processing some bounded bit of it at a time?
14:11:07 <Galactic> I see
14:12:03 <lispy> (there is also, do you close the files as your process them? but that is less common as it only tends to matter when you lazily load lots of files)
14:13:12 <lispy> Galactic: if you're new to haskell then I recommend staying way from lazy IO. There are better techniques and as merijn says, you probably don't need it for now.
14:13:19 <geekosaur> well, there's also whether you need to deal with things like read errors that will be invisible with lazy IO
14:13:37 <lispy> geekosaur: true. So many worms in that can.
14:14:56 <lispy> I really wish the prelude IO functions were strict.
14:15:05 <merijn> lispy: I would say "do use IO, just be aware it has problems for "real" code, so you can learn something like pipes/conduits when you need to"
14:15:32 <lispy> At this point, probably the best we can do until a language revision is to make sure there are easy to use strict variants (easy in the sense of, maybe they can live in base?)
14:16:24 <merijn> lispy: I don't think a revision that gratuitously backwards incompatible is likely to happen
14:17:02 <lispy> merijn: sure. and I wouldn't mind having to say import Prelude.Strict.IO ( hGetContents )
14:18:32 <lispy> Fortunately for me, most of the Haskell code I write isn't 'production' code. It's usually either a prototype of something for 'research' or some hackish toy project.
14:19:56 <vermeille> I'm writing a tiny compiler for maths expressions (with functions and variables), so, when compiling, I need to carry something that I call an AsmEnv which is just a description of the stack frame and of the registers ; I use a State monad for that. BUT, I would also need some kind of writer monad to write my generated assembly in. How would you represent such a type?
14:21:20 <edwardk> vermeille: note you can carry 'output' in state as well. just cons or append it onto the value of one of the fields in you state
14:21:26 <lispy> vermeille: The two main approaches are to use a library like mtl or monadLib to apply WriterT to your State monad; or you could add that to your state.
14:21:28 <edwardk> the benefit there is you can do fixups, etc.
14:22:11 <bitemyapp> augur: laughed at Khuong's avatar, didn't notice it until you said something.
14:22:35 <vermeille> edwardk: true. I'll go that way.
14:22:50 <augur> bitemyapp: :)
14:23:06 <edwardk> bitemyapp: re the lz77 post?
14:23:09 <bitemyapp> da
14:23:40 <edwardk> i still prefer lz78 for those applications, but ymmv
14:24:12 <lispy> vermeille: If you need labels to jump to and whatnot there is a cute trick you can do with monadfix. See the third article here for an example: http://www.haskell.org/wikiupload/1/14/TMR-Issue6.pdf
14:24:19 <edwardk> has the benefit of a simpler algorithm, handling infinite starting dictonaries better, etc.
14:24:19 <Yaniel> Galactic: are you the Galactic I know?
14:24:49 <Galactic> I don't know, probably not...do you go to UCF?
14:24:49 <lispy> vermeille: I think the syntax for recursive do has changed since that was published, but otherwise the examples should work
14:25:14 <Galactic> my name is Luis.
14:25:33 <vermeille> thx lispy , I'll check that!
14:25:55 <Yaniel> Apparently not then
14:26:12 <bitemyapp> Galactic: but we still love you
14:26:35 <Galactic>  lol thanks.
14:27:21 <edwardk> bitemyapp: https://github.com/ekmett/compressed/blob/master/src/Data/Compressed/Internal/LZ78.hs gives a nice monad for working with lz78 compressed data, and lets you decompress in an arbitrary monoid. i've been meaning to find more applications for it.
14:27:57 <Galactic> I know that Data.Text isInfixOf is faster than the Data.List one but for some reason when I use Data.Text my code is slower...could some take a look at my code (very short) and see if I am doing something wrong? http://pastebin.com/cyvxEwje
14:28:18 <lispy> edwardk: does it give you a virtual file system (a la zip) or is it for encoding a stream of data?
14:28:39 <vermeille> Actually, I'm just wondering, do I need two passes? The first to count how many variables are allocated on my stack frame, and the other to actually generate the code?
14:29:37 <edwardk> lispy: take a container in memory, like a list. and give me something like Eq a or Ord a or Hashable a and Eq a so i can use that to compile a LZ78 stream of tokens from it.   then when you want to get some summary of the data i can decompress directly in your chosen monoid, reusing intermediate results
14:29:38 <lispy> Galactic: looking. Just a stylistic comment. I prefer: str2 `T.isInfixOf` str1, as it reads like english :)
14:30:25 <Galactic> ty lispy I will change it and keep that in mind for the future.
14:30:34 <edwardk> lispy: LZ78 tokens are basically (existing slot, value to to snoc onto it) producing a new slot, and a dictonary that starts wth 1 slot, the empty slot.
14:31:25 <lispy> Galactic: I can't think of why your program would be slower with Text. How much of a slow down are you talking about?
14:32:37 <lispy> edwardk: Hmm..this sounds lower level than what I was tihnking. I asked because I once wrote a program that parsed files and stored their ASTs in a .zip archive (to reduce overhead during processing, the AST were verbose but compressed very well, so the reduction in IO was a huge performance win)
14:32:37 <Galactic> I forgot to mention that str1 and str2 can be 100000 in size
14:32:50 <edwardk> aabaa...  becomes [(0,a),(1,b),(1,a)...    yielding slots [(0,""),(1,"a"),(2,"ab"),(3,"aa")...
14:32:57 <lispy> edwardk: and I basically used the zip archive as a file system. Which was also nice because all the filesystem operations became pure.
14:33:24 <edwardk> lispy: think compression as data structure to exploit regularities in your data, not the usual compression on disk story
14:33:52 <Galactic> lispy: in one case Data.List took 0.25 sec and Data.Text took more than 5 sec.
14:33:58 <lispy> edwardk: okay. Actually, both would help in the case I was working in. Much of the structure could be shared and 'compressed'
14:34:04 <edwardk> take a sequence of numbers, LZ78 them, now you can decompress in the 'sum' monoid without every really fully expanding
14:34:28 <edwardk> you just compute the sums for the slots by adding the new value onto the sum for the previous slot.
14:34:39 <edwardk> and as you go carry your running total
14:34:43 <lispy> Galactic: My hunch is that it has to do with laziness. You might take this as a change to learn how profiling works in ghc. It's a useful skill to have under your belt for anytime you need to performance tune a haskell program.
14:34:51 <edwardk> this works for min, max, any monoid in general
14:35:35 <lispy> Galactic: IIRC, chapter 23 of real-world Haskell (free on line) can get you started
14:35:41 <edwardk> i treat it as a tool for making big data "less big" by exploiting redundancies in the shape of data
14:36:05 <Galactic> lispy: thanks, I will take a look at that.
14:36:07 <lispy> edwardk++ I wish more folks would realize that most big data can be substantialy less big.
14:36:25 <lispy> Galactic: as a quick test you might change your imports to use the lazy IO of Text.
14:37:46 <startling> I wonder if anyone has written nice knockout js things for blaze-html
14:38:05 <edwardk> i also with people would figure out if you only have a few hundred gigs you don't have "big data"
14:38:31 <edwardk> er wish
14:41:17 <c_wraith|N10> Huh. I just ran into a performance issue I didn't expect, and can't explain on first glance. That's rare. (lots of tools I haven't used yet, so I'm sure I can figure it out.)
14:41:46 <startling> hmm, knockout + blaze-html + purescript would be nice
14:42:21 <Galactic> lispy: I used Lazy and it did not time out...but now I get some wrong answers, that is interesting.
14:43:18 <startling> with a quasi-quoted, maybe?
14:43:21 <startling> quasi-quoter, too
14:44:22 <athan> what would be a good example of a type of kind * -> * that can't be made an instance of Functor?
14:45:02 <startling> athan, data Example a where x :: Example String
14:45:04 <athan> something like data Foo a = Nil?
14:45:12 <athan> ahhhh
14:45:13 <startling> athan: that's called Const, and is a Functor. :)
14:45:15 <athan> awesome
14:45:23 <startling> fmap f Nil = Nil
14:45:32 <benmachine> well, Const () more precisely
14:45:40 <athan> hmm
14:45:41 <startling> Sorry, that's right
14:45:56 <athan> so when you demand an instance of an un-included type, then you're dead in the waters?
14:45:57 <startling> what's that? I swear it has a name
14:46:07 <startling> athan, something like that
14:46:10 <benmachine> startling: Proxy, maybe?
14:46:15 <startling> ah, right
14:46:16 <c_wraith|N10> Oh. Caused by good old-fashioned combinatorial explosion. What do you know.. Deferring the combinatorial with laziness is a win
14:46:27 <benmachine> athan: newtype Sink a = MkSink (a -> Bool)
14:46:40 <athan> er, and unexpectable one?
14:46:50 <startling> athan: Functor f is "for every type f there's a corresponding f a and for every function a  -> b there's a corresponding f a -> f b"
14:47:02 <int-e> A contravariant functor?
14:47:04 <benmachine> athan: I don't understand either of your last two remarks
14:47:06 <startling> benmachine's example fails to satisfy the latter, mine fails to satisfy the former
14:47:28 <startling> ah, I misspoke
14:47:30 <int-e> If you want to be evil, use Fun a = MkFun (a -> a).
14:47:30 <athan> ahh okay
14:47:37 <athan> so you're just relying on distributive laws
14:47:39 <augur> whoever linked me to runar's scala talk, 0_0
14:47:40 <athan> basically
14:47:40 <benmachine> startling: I disagree, Example Int exists but is an empty type
14:47:59 <startling> benmachine: ah, true
14:48:12 <startling> so mine does fail to satisfy the latter as well.
14:48:16 <benmachine> athan: it's not really a distributive law, because the (a -> b) and the (f a -> f b) need not be the same
14:48:21 * hackagebot keystore 0.1.0.0 - Managing stores of secret things  http://hackage.haskell.org/package/keystore-0.1.0.0 (ChrisDornan)
14:48:31 <benmachine> wait
14:48:36 <athan> benmachine: how do you mean?
14:48:38 <benmachine> actually it's not a distributive law at all
14:48:53 <benmachine> never mind, I am not following :P
14:50:54 * startling needs to start spending more time with haskell again
14:50:56 <athan> benmachine: multiplication itself is a functor
14:51:03 <athan> er
14:51:06 <athan> no, wait
14:51:08 <athan> nevermind
14:51:13 <athan> hold on, let me ponder :P
14:57:31 <enthropy> what do people do for mass ghc-pkg unregister --force?
14:57:55 <startling> Does cabal provide a way to define subcommands like e.g. git does?
14:58:02 <enthropy> it is straightforward to do a loop or whatever in bash to get rid of packages currently broken
14:58:04 <startling> I'd like to have "cabal sandbox ghci" or something
14:58:37 <startling> enthropy, rm -rf .cabal-sandbox
14:58:39 <cwvh> enthropy: when I get to that point, I opt for rm -areyousure ~/.{cabal,ghc}
14:58:42 <Philonous> startling, cabal repl ?
14:58:51 <startling> Philonous: that's slightly different.
14:59:18 <startling> I want ghci using the packages in the sandbox, rather than ghci using the packages in the .cabal file.
14:59:51 <enthropy> cwvh: yeah that's an option... but this upgrade is only breaking about 10 packages, not everything I've ever installed
15:00:04 <Philonous> startling, Indeed. I wanted to do that a few times myself.
15:00:23 <startling> It's some ghci flag I can never remember
15:00:42 <startling> ah, ghci -package-db .cabal-sandbox/x86_64-osx-ghc-7.8.20140130-packages.conf.d/
15:01:42 <Michaelo> Hello! is willing someone to help me a bit with a network thing concerning sharing 3g connection from a guest os on virtual box to the host os that havent any internet?
15:02:36 <shachaf> Michaelo: Does it have to do with Haskell?
15:04:48 <Michaelo> i dont know about what is haskell i just red somewhere on the web that is a good chanel for networking help! if i am wrong could you please prompt me to a right one chanel?!
15:05:50 <athan> does an instance of functor need to implement id?
15:06:17 <startling> athan, huh?
15:06:33 <augur> bitemyapp: woo, two more twitter points!
15:06:36 <athan> startling: Yeah, kinda what I was thinking lol
15:06:46 <athan> startling: I'm just looking at the functor laws
15:06:48 <startling> athan, well, fmap id = id for functors
15:06:50 <Philonous> athan, No, but fmap id_a = id_(f a)
15:06:53 <athan> startling: yeah
15:06:58 <bitemyapp> athan: yesterday distributive, today you want to implement...id?
15:06:59 <startling> :t fmap id
15:07:00 <lambdabot> Functor f => f b -> f b
15:07:17 <Michaelo> j #security
15:07:29 <athan> bitemyapp: multiplication's a functor, isn't it?
15:07:32 <bitemyapp> > fmap id "blah" == id "blah" == "blah"
15:07:32 <lambdabot>  Precedence parsing error
15:07:33 <lambdabot>      cannot mix `GHC.Classes.==' [infix 4] and `GHC.Classes.==' [infix 4] in ...
15:07:36 <bitemyapp> ...
15:07:48 <bitemyapp> > fmap id "blah" == "blah"
15:07:49 <lambdabot>  True
15:07:55 <benmachine> athan: between what categories?
15:08:08 <benmachine> athan: or do you mean in Haskell, in which case, um, how?
15:08:12 <athan> ._.
15:08:23 <startling> athan: are you perhaps thinking of Product?
15:08:34 <bitemyapp> athan: you could possibly relate multiplication to a different concept.
15:08:39 <athan> I was just thinking in the context of numbers
15:08:52 <startling> athan, I don't follow.
15:08:57 <bitemyapp> athan: nah, but there's a different concept you could use to relate multiplication to numbers.
15:09:01 <bitemyapp> athan: what do you think that might be?
15:09:02 <athan> 2 * ( 5 + 3 ) = (2 * 5) + (2 * 3)
15:09:20 <benmachine> athan: what do you think a functor is?
15:09:34 <bitemyapp> athan: functors have laws attached btw.
15:09:35 <athan> the same concept, but with wrappers
15:09:47 <athan> in these terms, simply the parens are the wrappers
15:09:53 <athan> like a container
15:10:09 <athan> it's kinda coupled with the multiplication operator
15:10:20 <athan> but it has the same result, which interests me
15:10:34 <benmachine> athan: I have basically no idea what you are talking about
15:10:50 <benmachine> excuse my bluntness
15:10:59 <athan> fmap ((*) 5) (2 + 4)
15:11:03 <athan> > fmap ((*) 5) (2 + 4)
15:11:04 <lambdabot>  No instance for (GHC.Show.Show (f0 b0))
15:11:04 <lambdabot>    arising from a use of `M448818041252234996423109.show_M4488180412522349964...
15:11:04 <lambdabot>  The type variables `f0', `b0' are ambiguous
15:11:04 <lambdabot>  Possible fix: add a type signature that fixes these type variable(s)
15:11:04 <lambdabot>  Note: there are several potential instances:
15:11:12 <athan> woah hahaha
15:11:17 <bitemyapp> athan: you're using the Functor instance for ((->) r)
15:11:22 <bitemyapp> athan: not for numbers
15:11:27 <benmachine> look hold on
15:11:30 <bitemyapp> athan: do you know what parentheses do in Haskell?
15:11:31 <athan> ahhhhh
15:11:35 <benmachine> I'm pretty sure there's some basic misunderstandings here
15:11:36 <athan> they...
15:11:38 <athan> uhhh
15:11:41 <Egbert9e9> !help
15:11:42 <athan> connect morphisms
15:11:43 <bitemyapp> athan: parentheses are not a type or a "container"
15:12:05 <athan> hmm
15:12:07 <bitemyapp> athan: in Haskell, types implement a functor interface, which contains just fmap.
15:12:25 <bitemyapp> athan: functors in Haskell are principally about reusing functions for application to data inside a type, without caring about the specifics of the type.
15:12:31 <startling> athan, data Multiply a = Multiply a a is a functor (as well as a Monad)
15:12:36 <Egbert9e9> @help
15:12:36 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
15:13:01 <bitemyapp> startling: I don't think entertaining the crazy is the way to go here.
15:13:13 <athan> bitemyapp: hmm, I'm gonna need to refresh my ideas more
15:13:14 <bitemyapp> startling: there are more important misunderstandings, you could end up leading them down a garden path.
15:13:27 <athan> bitemyapp: I feel like I'm trying to use it at the thunk level
15:13:36 <bitemyapp> athan: I gave you exercises.
15:13:36 <startling> athan: ah. Don't think about that. :)
15:13:44 <bitemyapp> athan: don't think about thunks.
15:13:51 <bitemyapp> athan: https://gist.github.com/bitemyapp/8739525 do the exercises.
15:13:54 <Egbert9e9> what're `<~` and `~~`?
15:13:59 <athan> applicative
15:14:03 <bitemyapp> Egbert9e9: you can use symbolhound or Hoogle to find out.
15:14:04 <athan> fmap and <*>
15:14:14 <athan> also liftM
15:14:19 <athan> er
15:14:23 <athan> liftMN
15:14:32 <athan> for however many <*>s there are
15:14:50 <Egbert9e9> bitemyapp: thanks! hoogle didn't yield any results. i hope symbolhound will.
15:15:21 <darthdeu> guys is there a more noob-friendly lens tutorial than the main documentation pages for lens-family and lens packages? i feel that everything explains them in terms of more theoretical things, but i dont see how to use them practically
15:15:23 <benmachine> Egbert9e9: I don't recognise either of them, they are valid infix function names that presumably come from a library
15:15:27 <quchen> Egbert9e9: Or Hayoo. (<~): http://holumbus.fh-wedel.de/hayoo/hayoo.html?query=%28%3C~%29
15:15:38 <benmachine> darthdeu: there have been many blog posts
15:15:49 <bitemyapp> athan: do the exercises.
15:15:55 <edwardk> darthdeu: https://github.com/ekmett/lens/wiki/Examples perhaps?
15:16:06 <darthdeu> edwardk: thanks!
15:16:20 <Egbert9e9> oh wow. that makes very little sense
15:16:40 <startling> darthdeu, for a long time this channel was the best way to learn lenses. It still might be. If you have a question, asking it here might be productive. :)
15:17:08 <edwardk> another good place is #haskell-lens for when #haskell isn't answering =)
15:17:23 <darthdeu> startling: the problem is that i dont have any questions :\ i feel like i understand what they do and what they're for, but not when i want to use them myself
15:17:28 <bitemyapp> or when #haskell gets tired of hearing about co-co-co-co
15:17:38 <darthdeu> because for example right now I started a new app and when I wrote a first record type i thought "hey i should probably use lenses"
15:17:42 <Egbert9e9> reading this https://github.com/switchface/helm/blob/master/demos/platformer/Main.hs
15:17:44 <Peaker> can optparse-applicative do <|> ?  i.e:  --version as one parser <|> the real options?
15:17:50 <startling> darthdeu: ah.
15:17:52 <darthdeu> also just found this https://skillsmatter.com/skillscasts/4251-lenses-compositional-data-access-and-manipulation
15:18:07 <startling> darthdeu: lenses are good for updating deeply-nested records. That's probably the best place to start.
15:18:10 <bitemyapp> Egbert9e9: oh, FRP stuff.
15:18:14 <edwardk> darthdeu: simon's talk is a good nuts and bolts explanation of why the basic lens type works
15:18:32 <bitemyapp> Egbert9e9: yeah they're probably going to make up their own operators.
15:18:43 <bitemyapp> Egbert9e9: you'll have to read the code/documentation provided.
15:20:10 <darthdeu> edwardk: I guess with lenses the argument that "records are hard to work with" is no longer valid?
15:20:33 <edwardk> darthdeu: pretty much
15:20:52 <darthdeu> awesome
15:21:21 <bitemyapp> darthdeu: well, for a somewhat iffy definition of "hard". More like, "nested records are no longer tedious to manipulate" imo
15:23:06 <Egbert9e9> <~ = lift -- ~_~
15:23:24 <mornfall> bitemyapp: but you mustn't make any typos lest you die of type error overdosage ;P
15:23:45 <Egbert9e9> (~~) = (<*>) . fmap (<*>)
15:24:22 <bitemyapp> mornfall: meh.
15:25:34 <darthdeu> btw this is probably a dumb question, but I've installed the lens package via cabal, and now when I try to :m +Control.Lens or import Control.Lens in ghci it doesn't find it ... but if i add it in a project with cabal sandbox to the dependencies and run cabal repl, it is available in there
15:26:46 <darthdeu> hm if i do cabal install inside a sandbox, it only installs in the sandbox?
15:26:53 <tromp> > ln(2)
15:26:54 <lambdabot>  Not in scope: `ln'
15:26:54 <lambdabot>  Perhaps you meant one of these:
15:26:54 <lambdabot>    `n' (imported from Debug.SimpleReflect),
15:26:54 <lambdabot>    `l' (imported from Debug.SimpleReflect),
15:26:54 <lambdabot>    `on' (imported from Data.Function)
15:27:02 <tromp> > exp(1)
15:27:03 <lambdabot>  2.718281828459045
15:27:22 <tromp> > exp(-1/16.0)
15:27:23 <lambdabot>  0.9394130628134758
15:27:40 <tromp> > exp(-1/16.0)* 17/16.0
15:27:41 <lambdabot>  0.998126379239318
15:27:45 <tromp> > 1 - exp(-1/16.0)* 17/16.0
15:27:46 <lambdabot>  1.8736207606819821e-3
15:29:29 <tromp> > 1/(1 - exp(-1/16.0)* 17/16.0)
15:29:30 <lambdabot>  533.7259390934634
16:23:03 * haasn .oO( ComonadCobaseNtrol )
16:24:49 * haasn .oO( lowerCobaseWith :: ComonadCobaseNtrol c w => w a -> c a -> RunInCobase w c )
16:25:31 * augur .oO( why is hasn't turning into ski )
16:25:38 <augur> .. haasn :|
16:25:40 <augur> i cant type :(
16:26:14 <haasn> haasn't
16:27:00 <zenkeku> Is it bad (or good?) practice to indent ='s to a specific column so that they line up? Example: http://lpaste.net/102031
16:27:22 <Cale> I'd say good
16:28:02 <indigo> Yay, I just wrote my first Haskell web service. :D
16:28:02 <Cale> Generally lining things up when they're logically siblings in the syntax tree makes sense.
16:28:04 <haasn> Indent all the things
16:28:06 <haasn> All of them
16:28:11 <haasn> Align*
16:29:06 <zenkeku> Hm.. Does any of your editors do this automatically?
16:29:24 <johnw> zenkeku: Emacs can do it with a key press
16:30:01 <zenkeku> johnw: I'm using emacs, actually. How does one go about doing that?
16:30:21 <ion> @quote haiku
16:30:21 <lambdabot> lilac says: class Monad m where / return and Kleisli compose / must form a monoid  <lilac> that's my new monad tutorial haiku  <jmcarthur> i think that is the best monad tutorial i have ever read
16:30:37 <johnw> zenkeku: https://gist.github.com/9881702
16:30:38 <mm_freak> hi there
16:30:43 <johnw> then set `align-code' to a key, I use M-[
16:31:01 <mm_freak> does anyone know how i can get a multi-column layout with ansi-wl-pprint?
16:31:20 <mm_freak> abc    xxx
16:31:23 <mm_freak> defgh  yyy
16:31:26 <mm_freak> something like that
16:33:34 * hackagebot bytestring-lexing 0.4.3.2 - Parse and produce literals efficiently from strict or lazy bytestrings.  http://hackage.haskell.org/package/bytestring-lexing-0.4.3.2 (WrenThornton)
16:33:36 * hackagebot data-fin 0.1.1.2 - Finite totally ordered sets  http://hackage.haskell.org/package/data-fin-0.1.1.2 (WrenThornton)
16:33:38 * hackagebot data-or 1.0.0.4 - A data type for non-exclusive disjunction.  http://hackage.haskell.org/package/data-or-1.0.0.4 (WrenThornton)
16:33:40 * hackagebot exact-combinatorics 0.2.0.7 - Efficient exact computation of combinatoric functions.  http://hackage.haskell.org/package/exact-combinatorics-0.2.0.7 (WrenThornton)
16:33:42 * hackagebot list-extras 0.4.1.3 - Common not-so-common functions for lists  http://hackage.haskell.org/package/list-extras-0.4.1.3 (WrenThornton)
16:34:04 <zenkeku> johnw: Thanks for the code snippet, but what is literate-haskell-mode?
16:34:30 <StoneCypher> zenkeku: i don't actually know, but it seems almost certain to be about knuth's literate programming
16:34:44 <johnw> for editing .lhs files
16:35:00 <hae> Did you know that TeX Live is a literate program? Supposedly.
16:35:23 <mm_freak> ah, i'll just use fillBreak
16:35:25 <mcurran> are there any program files i probably use w/ a debian testing install that was written in haskell?  just wondering if I've even seen it.
16:36:05 <mm_freak> mcurran: unlikely, but look for stuff like xmonad, darcs and pandoc
16:37:44 <PudgePacket> How can I make floating point maths more correct, i'm doing some float - float and i'm getting rounding errors even though i'm subtracting amounts like 0.01, 0.05, 0.1
16:38:01 <mm_freak> PudgePacket: 0.1 is not exact in any base-2 float format
16:38:16 <mm_freak> 0.1 = 1/10, where 10 = 2*5
16:38:25 <zenkeku> johnw: Did you mean `align-regexp' not `align-code'?
16:38:26 <mm_freak> the number is only exact, if the denominator is a power of 2
16:38:32 <johnw> I mean align-code
16:38:44 <mm_freak> PudgePacket: however, you can Rational
16:38:44 * hackagebot pointless-fun 1.1.0.5 - Some common point-free combinators.  http://hackage.haskell.org/package/pointless-fun-1.1.0.5 (WrenThornton)
16:38:46 * hackagebot prelude-safeenum 0.1.1.1 - A redefinition of the Prelude's Enum class in order to render it safe.  http://hackage.haskell.org/package/prelude-safeenum-0.1.1.1 (WrenThornton)
16:38:48 * hackagebot stm-chans 3.0.0.2 - Additional types of channels for STM.  http://hackage.haskell.org/package/stm-chans-3.0.0.2 (WrenThornton)
16:38:48 <johnw> ah,
16:38:50 * hackagebot intervals 0.6 - Interval Arithmetic  http://hackage.haskell.org/package/intervals-0.6 (EdwardKmett)
16:38:52 * hackagebot unix-bytestring 0.3.7.2 - Unix/Posix-specific functions for ByteStrings.  http://hackage.haskell.org/package/unix-bytestring-0.3.7.2 (WrenThornton)
16:39:01 <johnw> zenkeku: https://gist.github.com/9881840
16:39:13 <johnw> bind-key is from my 'use-package' library, replace with something smiilar
16:39:43 <Fuuzetsu> How can I check which package a module is coming from?
16:40:08 <mm_freak> Fuuzetsu: the easiest way is to open your local haddock documentation for it, if you have it
16:40:11 <zenkeku> johnw: There we go. Thank you.
16:40:13 <mm_freak> otherwise there is probably some ghc-pkg way to do it
16:40:39 <Fuuzetsu> mm_freak: ironically I need to know so I can find the Haddock documentation for it…
16:40:44 <mm_freak> Fuuzetsu: this file lists all modules that you have installed: ~/.cabal/share/doc/index.html
16:40:53 <Fuuzetsu> I found it now anyway by sly Google work
16:40:55 <shachaf> ghc -hide-all-packages -package base -e 'import Mod.Ule'
16:40:55 <mm_freak> and to the right you will see the package it belongs to
16:41:03 <Fuuzetsu> shachaf: clever
16:41:19 <ezrios> type Eval4 α = ReaderT Env (ErrorT String (StateT Integer Identity)) α
16:41:48 <ezrios> why is this not type Eval4 a = ReaderT Env (ErrorT String (StateT Integer Identity a) a) a
16:41:50 <ezrios> ?
16:42:05 <ezrios> given that
16:42:08 <ezrios> newtype ErrorT e m a
16:42:13 <mm_freak> ezrios: because that would be a kind error
16:42:14 <ezrios> newtype StateT s m a
16:42:45 <ezrios> mm_freak: so the "inner monad" being transformed needs to be of kind * -> *?
16:42:53 <mm_freak> ezrios: a monad transformer is something of kind (* -> *) -> (* -> *), i.e. it takes a monad and results in a monad
16:42:57 <mm_freak> ReaderT X IO a
16:43:04 <mm_freak> not ReaderT X (IO a) a
16:43:24 <mm_freak> ReaderT X :: (* -> *) -> (* -> *)
16:43:33 <mm_freak> and the rest is just regular currying
16:44:14 <ezrios> ah I see
16:44:16 <ezrios> thanks
16:45:27 <colDrMcBeardman> is there an elegant way to have a case statement match intervals? I assume case x of (>5) -> something; doesn't work
16:45:35 <mwhitfield> is there a general community consensus around any particular testing framework (HUnit/testframework/something else)? Or is there no real "standard"?
16:45:48 <colDrMcBeardman> or something other than case that can do that?
16:45:55 <mm_freak> colDrMcBeardman: if you don't mind an extension, you can use MultiWayIf
16:45:55 <ezrios> colDrMcBeardman: use boolean guards
16:46:05 <mm_freak> colDrMcBeardman: if | x > 5 -> …
16:46:14 <mm_freak> with as many such guards as you like
16:46:47 <mm_freak> mwhitfield: the current de facto standard is test-framework, but we're probably moving to tasty bit by bit
16:46:58 <mm_freak> personally i'm still using test-framework
16:47:02 <Cale> Or if you want to avoid the extension,  case () of _ | x > 5 -> ... | ...
16:47:27 <mwhitfield> mm_freak: Gotcha, thanks. I'll use test-framework for now, but have a look at tasty
16:47:38 <mm_freak> mwhitfield: i'd suggest to use tasty instead =)
16:48:01 <mm_freak> mwhitfield: i'm only using test-framework because i know it very well and want to spend my learning resources for other things right now
16:48:21 <mwhitfield> mm_freak: Thanks, I'll have a look
16:49:19 <lavorno> hi guys ! talking of tests (and installing/confit) - i've tried to use the sandbox approach recently and it seems to have deleted (or made disappear) my previously installed packages .. anybody has any thoughts / suggestions on where to check for them ? (ghc-pkg list shows a clean base)
16:50:09 <geekosaur> lavorno, that's what a sandbox does
16:50:32 <Cale> lavorno: Even from outside the sandbox?
16:50:35 <lavorno> really ? it means it deletes all my previously installed packages ?
16:50:41 <geekosaur> it creates a completely independent user package database. if for some reason all your packages were in the user package database then you'll need to install them all again inside the sandbox
16:51:03 <lavorno> how about the packages that i had installed before ?
16:51:06 <geekosaur> anything installed in the global package database remains visible
16:51:08 <lavorno> are they gonna be removed ?
16:51:18 <geekosaur> they afre not removed, only invisible from the sandboix
16:51:20 <ion> I can do add, subtract, multiply and divide any quadratic irrational with any integer or rational, but i can only do those operations against two QIs if their square root term matches or is zero. Is there a type class with operators for that somewhere?
16:51:22 <lavorno> that's the problem i am asking - i can not see the global ones
16:51:36 <mm_freak> lavorno: it doesn't delete anything outside the sandbox, but it makes everything outside invisible
16:51:36 <geekosaur> are you sure they were global?
16:51:42 <lavorno> y
16:51:49 <geekosaur> run this outside the sandbox: ghc-pkg list --global
16:51:53 <lavorno> before i could run ghc-pkg
16:51:57 <lavorno> ok
16:52:37 <mm_freak> ion: sounds like an extension ring/field to me
16:52:42 <mm_freak> ion: like number fields
16:52:57 <lavorno> geekosaur: did it and it shows a clean base, none of my prev packakages
16:53:33 <lavorno> mm_freak: (that's what ithought)
16:54:07 <lavorno> Cale: yes, i was running the ghk-pkg geeko said outside right now
16:54:11 <geekosaur> right, that's the packages that would be visible inside the sandbox
16:54:36 <lavorno> geekosaur : and how about my previously installed packages ? :)
16:54:41 <geekosaur> if you installed other packages, they are in your user database and will not be visible in the sandbox
16:54:56 <geekosaur> they have not been removed; the sandbox is using a different local package database
16:55:19 <ion> mm_freak: Ok, thanks for the pointers. I suppose there is no package with such a type class.
16:55:30 <lavorno> ghc-pkg --user shows nothing
16:56:30 <mwhitfield> ion: sounds like a parameterized type: data QI root coef :: * -> * -> *, with QI root deriving Num (I'm not sure if that's possible, or possible without generalized newtype deriving though. I'm just learning this stuff)
16:58:01 <ion> mwhitfield: I’d need it to be parameterized on the value of the square root term, not the type. I’m not sure how nicely that can be done without a dependently typed language, so for now i’m happy with qiAdd :: QI -> QI -> Maybe QI.
16:58:20 <mm_freak> ion: there is the algebra package, but i'm not sure what its future is going to be
16:58:31 <ion> mm_freak: Thanks, i’ll take a look at it.
16:58:35 <mm_freak> edwardk stated that he doesn't want to maintain it in its current form
16:58:42 <ion> ok
16:58:49 <mm_freak> so it will be changed or replaced some time in the future
16:59:17 <mm_freak> ion: oh, alternatively you can think of your type as a vector space
16:59:24 <mm_freak> in which case you might be able to use the 'linear' package
16:59:33 <edwardk> i'll be working on it eventually, but other things are more pressing =)
16:59:44 <ion> mm_freak: Hmm, thanks, i’ll give that a thought.
16:59:49 <mwhitfield> ion: Right, so you'd need type-level numbers (from e.g. datakinds)
16:59:49 <edwardk> we may have a gsoc student working on something off of it for grobner bases
17:00:18 <Sgeo_> Aww, I think plugins wants a UNIX system or compatibilty to work :(
17:00:52 <lavorno> geekosaur: not really a huge deal, i may have deleted the ~/.ghc by accident (to give it the benefit of doubt) - will keep an eye open and share if happens again
17:01:09 <geekosaur> if you did that then you lost them all, yes
17:01:24 <geekosaur> generally I don't blindly delete, I rename stuff so I can put it back if I screwed up
17:01:45 <lavorno> usually do that too, but today i did too many things too fast :)
17:02:04 <lavorno> was just trying to make emacs work seamlessly with both the sandbox and the regular packages
17:02:34 <lavorno> it seems like it can load in the eval window through ghci but not through the repo sandbox command
17:03:23 <lavorno> so i can't use the same shortut keys when running something in sandbox (as before when i was running them in the wild)
17:03:28 <geekosaur> I think there are still issues being worked out in that area
17:03:37 * hackagebot no-role-annots 1.0 - Role annotations without -XRoleAnnotations  http://hackage.haskell.org/package/no-role-annots-1.0 (RichardEisenberg)
17:06:25 <lavorno> thanks
17:10:02 <dagle> Is there a class for creating empty objects, like mempty in Monoid without the mappend? Most likely I will find that it actually is a monoid but the question remains.
17:10:22 <Iceland_jack> Default
17:10:40 <Iceland_jack> from data-default
17:11:31 <dagle> Ty.
17:17:30 <gdoteof> i'm using data.aeson.. i have some *.json files that need to read and encoded into the substructure of a json object.. but my naive attempts are ending up with the .json files being escaped as strings
17:18:09 <gdoteof> http://lpaste.net/102033
17:19:02 <johnw> dagle: however, do note: http://www.haskellforall.com/2013/04/defaults.html
17:19:57 <gdoteof> instead of getting {data: [{foo: "baz"}, {foo: "bar"}]  i am getting {data: ["\"foo\": \"baz\"", ""\foo\": \"bar\""]}
17:28:26 <SwashBuckla> Hi there. I get the following error from running `configure --prefix=/usr/local/ghc': checking for path to top of build tree... ./configure: line 2121: utils/ghc-pwd/dist-install/build/tmp/ghc-pwd: No such file or directory
17:28:40 * hackagebot intervals 0.7 - Interval Arithmetic  http://hackage.haskell.org/package/intervals-0.7 (EdwardKmett)
17:28:48 <SwashBuckla> on ghc 7.6.3
17:32:06 <augur> bitemyapp: goodness, are you and takeoutweight at it again?
17:34:18 <mm_freak> hi again…  do i need to define 'many' and 'some' explicitly, when they have the obvious definitions like 'many p = liftA2 (:) p (many p) <|> pure []'?
17:35:38 <shachaf> They have default mutually-recursive definitions.
17:36:17 <shachaf> See http://hackage.haskell.org/package/base-4.6.0.1/docs/Control-Applicative.html#t:Alternative
17:36:54 <shachaf> (And in particular the source link -- the default definition is the same as what you wrote.)
17:37:47 <mm_freak> alright, thanks
17:45:39 <bitemyapp> augur: it's wrapped up. and now I'm leaving for BBQ
17:46:21 <SwashBuckla> any help with this bizarre error when I try and ./configure GHC 7.6.3?  checking for path to top of build tree... ./configure: line 2121:utils/ghc-pwd/dist-install/build/tmp/ghc-pwd: No such file or directory
17:48:01 <geekosaur> if the file is there then it's the loader that is missing, meaning you have an incompatible system
17:48:42 * hackagebot xss-sanitize 0.3.5.2 - sanitize untrusted HTML to prevent XSS attacks  http://hackage.haskell.org/package/xss-sanitize-0.3.5.2 (GregWeber)
17:49:42 <geekosaur> (the loader in this case is an ELF program loader, commonly called ld.so although the path may vary depending on your linux distribution. ldd may help with diagnosing this)
17:51:35 <SwashBuckla> geekosaur: hmm ok. I am using a fresh Ubuntu 12.04.3 LTS install
17:51:47 <SwashBuckla> geekosaur: I will diagnose with ldd
18:03:07 <zipper> Which is the best lenses tutorial for a newbie-ish person without solid math background. Having read learn you a haskell and typeclassopedia.
18:04:01 <edwardk> zipper: typically? watch SPJs talk. wander around the wiki. ask questions on #haskell-lens
18:04:34 <hiptobecubic> you forgot "Use lenses"
18:04:37 <joelteon> @pl \i -> f i >> g
18:04:37 <lambdabot> (>> g) . f
18:04:53 <haasn> SPJs talk has awkward timing though since he adjusts his speed quadratically to ensure it fits inside the time allowed
18:05:12 <edwardk> haasn: heh
18:05:22 <zipper> edwardk: Wow getting a reply from you is totally unexpected.
18:05:27 <zipper> *was
18:05:35 <edwardk> well, the nice thing about SPJ's talk is his enthusiasm is infectious
18:05:48 <edwardk> by the end you are jazzed about learning more about lenses. hell i was.
18:06:04 <hiptobecubic> :D
18:06:15 <haasn> He should have counted the number of unsafeCoerces
18:06:35 <haasn> 126, apparently
18:06:38 <zipper> Ok I entered "SPJ's talk on lenses" into youtube
18:06:40 <haasn> Is that number still accurate?
18:06:58 <zipper> I did not get obvious results
18:07:03 <edwardk> haasn: should be. there are stats run by travis after every build
18:07:08 <haasn> Excellent
18:07:09 <edwardk> https://skillsmatter.com/skillscasts/4251-lenses-compositional-data-access-and-manipulation
18:07:15 <edwardk> you need to register to get access to it though. sadly
18:07:16 <haasn> travis integration for number of unsafeCoerces. I need this
18:07:21 <johnw> SPJ's lens talk: http://ftp.newartisans.com/pub/Lenses.mp4
18:07:22 <haasn> edwardk: hang on, there's a direct link somewhere
18:07:24 <haasn> .. there
18:07:36 <Iceland_jack> <Iceland_jack> <johnw> Iceland_jack: http://ftp.newartisans.com/pub/Lenses.mp4
18:07:36 <Iceland_jack> <Iceland_jack> <johnw> ^-- SPJ's presentation on Lenses
18:07:36 <Iceland_jack>  
18:08:32 <edwardk> johnw: you sir are a gentleman and a scholar
18:08:38 <johnw> :)
18:08:47 <zenkeku> What type would a list be if it can be Ints and Doubles? i.e. 1 and 1.1.
18:08:57 <edwardk> off to watch cosmos, be back in an hour or so =)
18:09:15 <johnw> it could be Num a => [a], but you wouldn't know which were Ints and which Doubles originally
18:09:28 <johnw> usually you would build a type wrapper
18:09:38 <johnw> data NumWrapper = IntNum Int | DoubleNum Double
18:09:43 <johnw> now you can have [NumWrapper] and know
18:09:59 <zenkeku> I don't necessarily need to know their types, simply that they can be added together.
18:10:11 <zipper> Thank you all.
18:10:12 <zenkeku> So Num a? Would that be [Num a] for a list?
18:10:18 <johnw> Num a => [a]
18:10:23 <johnw> how are you going to use the final number though?
18:10:25 <haasn> zenkeku: I don't understand what you need this list for
18:10:27 <johnw> just "show" it?
18:10:38 <zipper> I had looked at Gozales' lens tutorial and the type signatures didn't seem to make sense.
18:10:58 <zipper> So I had to get a very different source of info.
18:11:15 <zenkeku> My function takes a list of numbers and computes the mean (sum(list) / length(list)).
18:11:16 <johnw> zipper: you can also ask questions here or in #haskell-lens
18:11:17 <zipper> I was in bed a week ago when that happened though.
18:11:44 <haasn> zenkeku: (/) does not work on Ints
18:11:48 <zipper> johnw: Yeah, I'm downloading the video from the link you gave me http://ftp.newartisans.com/pub/Lenses.mp4
18:11:54 <haasn> and sum xs / length xs -- should be avoided
18:12:50 <zenkeku> I was writing that in pseudo code because I couldn't immediately think of a way to do that in haskell.
18:13:13 <haasn> > let list = [1..10] in sum(list) / length(list)
18:13:26 <haasn> ...err?
18:13:35 <haasn> @botsnack
18:13:54 <johnw> zenkeku: check out http://hackage.haskell.org/package/foldl-1.0.3/docs/Control-Foldl.html
18:14:03 <johnw> that gives you a safe and efifcient way of doing sum/length
18:14:50 <kaz007> Hi, is there any efficient bit vector implementations? I have a huge collection of binary data, and want to operate them at bit level
18:15:02 <zenkeku> johnw: Oh, thank you.
18:15:21 <johnw> zenkeku: further, rather than using Num a => [a], I'd use [Double], and then use "fromIntegral" to cast the Ints up to Doubles
18:15:41 <haasn> I would use Fractional a => [a] -> a
18:15:48 <johnw> ah, or that
18:16:00 <johnw> the fold should work nicely on a list of fractionals
18:16:03 <haasn> If you want an exact fraction, you can use Rational. If you want an integer approximation, you can ‘floor’ that.
18:17:56 <tromp_> > exp(-1/16.0)
18:18:04 <lambdabot>  0.9394130628134758
18:18:14 <haasn> > let list = [1..10] in sum(list) / length(list) -- \o/
18:18:22 <lambdabot>  No instance for (GHC.Real.Fractional GHC.Types.Int)
18:18:23 <tromp_> > 1/(1-exp(-1/16.0))
18:18:27 <haasn> Oh no :(
18:18:28 <lambdabot>    arising from a use of `GHC.Real./'
18:18:30 <lambdabot>  16.50520799428067
18:18:34 <haasn> Why doesn't that default to D-- oh, length
18:18:40 <haasn> > let list = [1..10] in sum(list) / genericLength(list)
18:18:48 <lambdabot>  5.5
18:18:49 <haasn> how ugly
18:18:50 <shachaf> D++
18:18:57 <shachaf> genericLength-- :-(
18:19:03 <shachaf> The scow of functions.
18:19:23 <johnw> haasn: sum/length has memory references problems too, as Tekmo describes in http://www.haskellforall.com/2013/08/composable-streaming-folds.html
18:19:30 <quchen> Careful with genericLength. Most of the time you want `fromIntegral . length` instead.
18:20:09 <quchen> Well, most of the time you don't want `length` at all.
18:20:15 <shachaf> Or sometimes (mostly on 32-bit GHC) you want another function with an implementation identical to length and a more general type.
18:20:29 <shachaf> genericLength is not that function.
18:21:06 <copumpkin> genericLength is literally the worst function out there
18:22:05 <shachaf> literally
18:22:08 <haasn> @src length
18:22:09 <pavonia> Why is it so bad?
18:22:12 <copumpkin> I have seen no worse
18:22:14 <lambdabot> Source not found. Listen, broccoli brains, I don't have time to listen to this trash.
18:22:19 <copumpkin> and I've spent a lot of times looking at shitty functions
18:22:23 <haasn> Aaw, lambdabot doesn't show the true source of length :(
18:22:40 <shachaf> I have nightmares involving genericLength.
18:23:15 * haasn is tempted to say something about nightmares involving shachaf
18:23:22 <quchen> pavonia: genericLength is overly lazy. It's the naive "length (_:xs) = 1 + length xs" algorithm, builds up a huge thunk and it gives shachaf nightmares.
18:23:32 <haasn> does it really build up a huge thunk?
18:23:43 <shachaf> I was just going along with copumpkin's thing.
18:24:06 <copumpkin> I was just going along with yours!
18:24:21 * haasn is tempted to say something about the blind leading the blind
18:24:31 <copumpkin> :)
18:25:18 <quchen> shachaf: There is a rewrite rule to get a "length"-like "genericLength" for Int and Integer results though.
18:25:26 <quchen> http://hackage.haskell.org/package/base-4.6.0.1/docs/src/Data-List.html#genericLength
18:25:47 <shachaf> Yay, so the problem is even harder to spot.
18:25:54 <shachaf> I think "builds up a huge thunk" is how people usually describe problems with foldl-style sum.
18:26:08 <haasn> Does evaluating “1 + x” to WHNF entail evaluating ‘x’ to WHNF?
18:26:18 <haasn> specialized, say, to Int
18:26:22 <shachaf> haasn: Depends on your Num instance.
18:26:29 <Cale> haasn: With Int, yes
18:26:31 <shachaf> Yes, Int (+) is strict in both arguments.
18:26:35 <shachaf> The legitimate use for genericLength is lazy naturals.
18:26:43 <haasn> Okay
18:26:58 <johnw> shachaf: I was thinking about the fact that in sum/length, length maintains a reference to the whole list until the end, even though sum (using foldl') is able to release each member as it passes
18:27:19 <haasn> It just looks to me like using genericLength on, say, Int, would cause a stack overflow - rather than a gigantic thunk (like foldl would). Disclaimer: in GHC
18:27:28 <shachaf> ?
18:27:31 <haasn> (Disclaimer 2: on a large enough list)
18:27:36 <shachaf> Oh, in sum xs/"length" xs
18:27:40 <johnw> right
18:28:04 <shachaf> haasn: Yes.
18:28:42 <quchen> foldl would first create a thunk and then a stack overflow. genericLength skips that first part.
18:29:04 <zipper> Is there a book that teaches haskell from a types and type systems perspective?
18:29:17 <zipper> I have seen some on DSL
18:29:25 <zipper> and some general ones
18:29:33 <zipper> maybe even algorithms
18:30:12 <haasn> quchen: oh, good point; foldl would still cause a stack overflow (assuming you give it enough time and memory to build up its gigantic thunk, first)
18:30:25 <zipper> but types and type sigantures in haskell are really becoming a bother and a bottleneck everytime I look at something in hackage.
18:30:54 <haasn> You do not necessarily need a book on types and type systems to understand Haskell type signatures; you just need a good book on Haskell
18:31:07 <zipper> haasn: hmmm
18:31:18 <haasn> What kinds of type signatures are confusing you?
18:31:22 <zipper> haasn: This http://www.haskellcraft.com/craft3e/Home.html
18:31:37 <haasn> If ‘lens’ is the first package you're looking at after reading LYAH, some confusion is to be expected
18:32:02 <geekosaur> eheheh
18:32:15 <shachaf> If LYAH is the book you read to learn Haskell, some confusion is to be expected.
18:32:26 <haasn> johnw: subject, of course, to implementation; ‘length’ does not maintain a reference and a valid implementation strategy would be to build and discard the list twice
18:32:28 <zipper> haasn: Let me see monads, Lenses
18:32:29 <haasn> GHC is just not smart enough to do that
18:32:32 <haasn> (or dumb enough)
18:33:25 <zipper> shachaf: What do you recommend I read?
18:33:36 <johnw> haasn: length doesn't?
18:33:47 <haasn> shachaf: I'm wondering if there's a book you'd recommend, say, to somebody reasonably experienced with C, Java and Python who is interested in Haskell and functional programming.
18:33:55 <zipper> Good thing about LYAH is that it doesn't treat me like a person who has never programmed before
18:34:01 <zipper> shachaf: ^
18:34:05 <haasn> zipper: that might be a drawback
18:34:09 <shachaf> I liked Hutton's _Programming in Haskell_.
18:34:43 <shachaf> I haven't read LYAH. Most of my exposure to it is people in here being confused by it, and linking to confusing/wrong excerpts. So my view of it is probably biased.
18:34:59 <zipper> haasn: A drawback? It saves time
18:35:04 <sjy_> do many/most of the people in this channel use haskell in their day job?
18:35:11 <hiptobecubic> lol
18:35:22 <johnw> sjy_: some do, but I'm be surprised if it were most
18:35:22 <hiptobecubic> there are 1177 people in here
18:35:23 <haasn> johnw: not necessarily; Haskell doesn't say how implementations have to keep track of and/or garbage collect memory - it's very possible for a sufficiently smart compiler to automatically transform f (foldl' .. xs) (foldl' .. xs) into equivalent code to what modules like Foldl could produce
18:35:24 <shachaf> I don't know of a really good introductory Haskell book right now.
18:35:38 <zenkeku> I'm sorry for asking this question again but I am unable to scroll up. In a type signature how would I specify that my function can either take a list of Ints or a list of Integers?
18:35:57 <shachaf> zenkeku: You can't, exactly.
18:36:07 <haasn> zipper: But it is often the case that intuitions gained in other programming languages are not easily transferable to Haskell
18:36:24 <hiptobecubic> zenkeku, you can take an (Either Int [Int]) if you must. But usually it's not used that way.
18:36:24 <zipper> shachaf: I am not looking for an introductory programming book but maybe for a person who is coming from dynamicaly typed langs like ruby.
18:36:32 <startling> shachaf, I think there's some selection bias involved
18:36:33 <haasn> zipper: Motivating example: Suppose you know what the ‘return’ keyword does in C
18:36:43 <quchen> zenkeku: You can use IRCBrowse to scroll up all the way to the first post in 2001 in the channel, there's a link in the topic. :-)
18:36:45 <haasn> zipper: Haskell's ‘return’ will utterly confuse you the first time you don't see it at the end of a ‘do’ block
18:36:45 <shachaf> startling: That's why I said that.
18:36:48 <hiptobecubic> zipper, i think it's a sufficiently different mindset such that you're better off pretending like you don't know anything
18:36:58 <zipper> haasn: I hate do syantax
18:37:01 <Fuuzetsu> regular reminder that a kitten dies every time you use unchecked ‘head’ in your source
18:37:01 <startling> shachaf: ah, well
18:37:06 <haasn> zipper: Why do you have do syntax?
18:37:13 <hiptobecubic> zipper, well you'll see without do syntax as well
18:37:14 <shachaf> zenkeku: The question should be not just about the type but about the function.
18:37:19 <shachaf> But I'll let other people answer.
18:37:23 <sjy> because the bind operator is ugly?
18:37:26 <zenkeku> shachaf: I'll post the function, I suppose.
18:37:27 <sjy> :P
18:37:27 <zipper> The do syntax kills my context/wrapper view of monads.
18:37:31 <zipper> haasn: ^
18:37:42 <startling> zipper, that's an inaccurate view.
18:37:54 <hiptobecubic> > [1,2,3] ++ return 4 ++ [5]
18:37:55 <lambdabot>  [1,2,3,4,5]
18:38:04 <haasn> zipper: If ‘do’ syntax kills your view of monads then your view of monads needs adjusting.
18:38:15 <zipper> startling: Well I don't know plus enough people hate it so I shall blame it for my problems too.
18:38:32 <startling> zipper: sigh.
18:38:37 <zipper> haasn: hmmm well not kills it but ruins perfection
18:39:16 <hiptobecubic> i don't know anyone that hates do notation
18:39:19 <sjy> zipper: hmm, so you find the context/wrapper view easier to make sense of using >>= ?
18:39:20 <hiptobecubic> except zipper, i guess.
18:39:33 <zipper> sjy: Yes
18:39:57 <zenkeku> the aforementioned function http://lpaste.net/102038
18:40:08 <zipper> hiptobecubic: Chain your (>>=) and <*> lol
18:40:44 <hiptobecubic> zipper, it sounds like you just don't understand do syntax
18:40:56 <sjy> do syntax is basically just letting you write "\n" for >>= right?
18:41:01 <hiptobecubic> zipper, you know that it's just sugar over >>=, yes?
18:41:05 <startling> sjy: no.
18:41:22 <shachaf> zenkeku: In your case you can just write :: Num a => [a] -> Double
18:41:27 <hiptobecubic> and >>, of course
18:41:51 <zenkeku> shachaf: Oh, alright.
18:42:01 <hiptobecubic> zipper, there are several places on the web that show the conversion from do syntax to >>= and back
18:42:03 <zenkeku> Thanks for the help!
18:42:23 <haasn> sjy: do syntax is basically just letting you write “do x” for x, “do x; y” for “x >> do y” and “do p <- x; y” for “x >>= \a -> case a of p -> y; _ -> fail ""”
18:43:10 <hiptobecubic> haasn, bonus points for monadfail :)
18:43:31 <haasn> (those are incidentally the desugaring rules as present in the Haskell report)
18:43:52 <haasn> sorry, I meant “do y” in my third desugaring
18:48:20 <haasn> zenkeku: You would probably be better off using foldl' instead of foldl here, for reasons discussed about in various forms. The short summary is that foldl (+) 0 [1,2,3,4] will first build up a big expression (((1+2)+3)+4) before reducing it from the outside in; whereas foldl' (+) 0 [1,2,3,4] will compute the sub-expressions “as it goes along”, ie. immediately reducing (1+2)+... to 3+..., then (3+3)+...
18:48:22 <Algebr> Why can't ghci load code that includes `import GHC`?
18:48:23 <haasn> to 6+..., and finally (6+4) to 10.
18:49:03 <haasn> s/about/above/
18:50:41 <sjy> haasn: thanks for the explanation :)
19:05:58 <vermeille> what's the common pattern when you need to append an element *in the end* of a container?
19:06:17 <vermeille> prepending to a list then reversing it?
19:07:10 <davidthomas> vermeille: You mean you need to do a bunch of appends, and then later do something with the list?
19:07:19 <vermeille> Yup
19:07:35 <enthropy> Data.Sequence probably gets used for that purpose too
19:07:41 <davidthomas> prepend, then later reverse, certainly works
19:08:09 <davidthomas> as enthropy says, Data.Sequence works as well
19:08:21 <vermeille> but it may no work when you can't separate that clearly accumulation / usage
19:08:33 <davidthomas> yes
19:08:42 <pavonia> It heavily depends on the type of container
19:08:59 <vermeille> Is Sequence implemented like a std::deque?
19:09:10 <davidthomas> You also see builders
19:09:19 <davidthomas> Sequence is a finger tree, I think
19:09:30 <davidthomas> not sure how std::deque is implemented
19:11:09 <vermeille> davidthomas: std::deque is a kind of vector of static circular buffers, if I'm not wrong
19:11:37 <davidthomas> vermeille: 'k, then no, under the hood Data.Sequence is nothing like that
19:12:13 <davidthomas> http://www.soi.city.ac.uk/~ross/papers/FingerTree.html
19:13:08 <davidthomas> O(1) appends, though
19:13:25 <davidthomas> well, O(1) append of a single element
19:13:49 <davidthomas> O(log(min(n1,n2))) concatenation of two sequences
19:14:29 <davidthomas> http://hackage.haskell.org/package/containers-0.5.5.1/docs/Data-Sequence.html
19:15:22 <vermeille> Great! Thanks!
19:22:24 <hunt> ivebeen reading arguments the haskell, if it couldve been invented now, would not be lazy-first
19:22:41 <hunt> and i cant get my mind around how that wouldn't severely slow certain things down
19:22:48 <hunt> like the way we operate over lists
19:23:18 <Welkin> python lists are not lazy
19:23:22 <Welkin> they work fine
19:23:55 <hunt> yea but is not the lazyness thta allows haskell list operations not to be redundant
19:23:59 <hunt> and only traverse the list once
19:24:22 <Welkin> ?
19:24:51 <hunt> if i write foldr (+) 0 . map (+1) [1..100]
19:24:55 <hunt> if i write foldr (+) 0 . map (+1) $ [1..100]
19:24:57 <hunt> sorry
19:25:05 <hunt> then typically
19:25:12 <hunt> i would map +1 all the way across the list
19:25:16 <hunt> traversing the list once
19:25:18 <Welkin> okay I see
19:25:30 <hunt> right? so how can we just ditch lazyness
19:25:42 <edwardk> hunt: personally i am very much in the opposite camp. if someone made haskell strict tomorrow i'd go out and write another language that was lazy to have one.
19:26:12 <Welkin> what is the argument against lazy evaluation? memory leaks?
19:26:46 <hunt> Welkin: i was reading from this thread on HN, https://news.ycombinator.com/item?id=7498305
19:27:10 <edwardk> i'm not going to argue the wrong side of the debate. ;)
19:27:21 <hiptobecubic> edwardk, :D
19:27:48 <hunt> edwardk: me too, but I don't really understand the other camp well enough to be certain
19:27:50 <edwardk> for me it comes down to the fact that laziness composes in ways strict languages just don't. period.
19:28:05 <Welkin> there are strict versions of functions
19:28:12 <Welkin> like foldl' for foldl
19:28:29 <edwardk> i've written a lot of code in scala in a 'strict-by-default with explicitly lazy values' setting, and well, it is awful reasoning about code.
19:29:06 <edwardk> the thing with 'you could make your structures be lazy by being explicit' is that because it is so painful to work that way... nobody does.
19:29:31 <dhrosa> is there a variant of (&&&) that can create a 3-tuplet?
19:29:32 <edwardk> Welkin: i have no problem with the existence of strict functions
19:30:15 <edwardk> but if i look out on a 10 year horizon rather than what i can bang out next quarter? i want the non-strict solution.
19:30:29 <hunt> :t &&&
19:30:30 <lambdabot> parse error on input `&&&'
19:30:35 <hunt> :t (&&&)
19:30:36 <lambdabot> Arrow a => a b c -> a b c' -> a b (c, c')
19:30:41 <vermeille> is sometimes lazyness a good thing for performance?
19:30:58 <edwardk> vermeille: yes, provably changes asymptotics in some cases if you rule out mutation otherwise
19:31:03 <dhrosa> hmm actually I realized I can just deal with a ((a,b),c) for this hack
19:31:57 <edwardk> vermeille: finger trees fundamentally use the laziness of the spine. skew binary random access lists do so as well
19:32:35 <zipper> edwardk: PM
19:33:13 <hunt> anyone here who believes haskell should be strict first, to give some perspective
19:33:15 <hunt> ?
19:34:17 <vermeille> what do you mean?
19:34:43 <Platz> I had though SPJ had mused a few times in various videos about haskell not being lazy (the points made by thirsteh)
19:34:44 <hiptobecubic> hunt, there is that Discipline(?) language
19:35:07 <Welkin> BDSM language?
19:35:18 <edwardk> hunt: tibbe is probably the strongest advocate for a strict haskell
19:35:24 <edwardk> hiptobecubic: DDC
19:35:33 <hunt> edwardk: do you know what his argument is?
19:35:56 <edwardk> yes. i just don't want to work in that language =P
19:36:05 <edwardk> it is easy to write a compiler for that language
19:36:13 <hunt> edwardk: what does he say?
19:36:24 <edwardk> it is easy to reason about the performance of code in that language
19:36:24 <hiptobecubic> disciple, that was it.
19:36:29 <edwardk> these are all stock arguments
19:37:11 <hunt> edwardk: ok i guess we would need him the flesh to actually hash this out
19:37:30 <hunt> edwardk: whts i really want to see is for a bunch of people to get own and dirty and settle this for me
19:37:40 <Cale> hunt: hm?
19:37:58 <hunt> Cale: strict-first v. lazy-first haskell
19:38:12 <edwardk> hunt: well, we fundamentally disagree about the core issue, so we're not going to settle it one way or the other.
19:38:19 <Cale> Strict-first might as well be strict-only
19:38:22 <Welkin> if you want to see PhDs throwing punches (literally) go to an Anthropology or Physics conference
19:38:30 <Welkin> they get violent
19:38:37 <Platz> I recall Meijer noting around 2007 that "haskell is probably getting dependent types in the future".  Has the community decided dependent types aren't as easy as thought to implement, or rather aren't a good idea?
19:38:43 <hunt> edwardk: just about the economy, and both of the arguments are rooted in programmer experience arent they?
19:38:47 <edwardk> there are thousands of languages out there that are all strict by default. we basically have one useful lazy language. hands off =P
19:39:02 <Welkin> use Brainfuck or Whitespace
19:39:06 <johnw> Platz: dependent types comes with costs; probably the best answer is that we're not yet ready to pay them
19:39:07 <Welkin> it solves all your porblems
19:39:08 <Platz> I know you can do some basic simulation i.e peano numbers
19:39:18 <Cale> Platz: Since that time, almost all the work on extensions has been in that particular direction.
19:39:22 <hunt> Welkin: im coming over to haskell from 15 years of brainfuck
19:40:07 <hunt> johnw: anywhere i can read up on the costs/benefits, i don't really graspe what dependant types are after a googling or two
19:40:08 <Platz> johnw: I imagine it must make the compilers much more complex
19:40:21 <johnw> hunt: a dependent type is able to depend on a value
19:40:43 <johnw> hunt: it makes type inference harder, compilation more expensive, and some programs much more difficult to write
19:40:44 <hunt> johnw: so you calculate a value first, and then the type?
19:40:57 <Cale> hunt: So for instance, you can have a type for lists of length n
19:41:03 <johnw> hunt: check out Idris if you're interested in a good modern approach to dependent typing in a practically-oriented language
19:41:06 <Cale> hunt: where n is some natural number
19:41:28 <Cale> and then you can write an append function which takes a list of length n and a list of length m and produces a list of length n + m
19:41:36 <Cale> as a sort of standard first example
19:42:20 <edwardk> It pretty much comes down to even if the cadre of folks who want a strict-by-default language are right in terms of short term gains, it is wrong in terms of the long term health of the ecosystem of all languages to cut off the only serious exploration of the other side of the debate. Haskell's laziness carries fundamental benefits. Strictly more programs terminate. You can sensibly write 'where', you don't wind up with null's
19:42:20 <edwardk>  showing up in values that shouldn't have them because of strict knot tying in circulate let bindings like you get in letrecs in scheme
19:42:47 <Platz> there was an excellent video where someone encoded the length of a heap in the type to guide implementation
19:43:10 <Platz> or height, rather
19:43:37 <edwardk> there are just so many nonsensical consequences to making a language like haskell strict that it isn't really a debate. you can add a pragma to randomly strictify all the case/let statements in a module, that is what tibbe is doing. _that much_ makes perfect sense to me. the language it describes isn't very full featured, but it could be convenient for writing a certain kind of library in.
19:43:37 <hunt> Cale: n is not specified correct?
19:44:16 <geekosaur> n is known at runtime, not necessarily at compile time
19:44:26 <edwardk> so in that sense, i fully support making a pragma, but there aren't many serious users of haskell who i think would take the other side of the debate fully and say it should flip over entirely.
19:44:33 <johnw> lazy-by-default is wonderful for composition; I would hate to give that up.  I have too much experience hacking limits into my C++ algorithms, resulting in excessively fused algorithms, because everything had to be determined before that one call could complete
19:45:35 <johnw> when a function only needs to compute what the caller needs "right now", you have lots of expressive freedom
19:45:38 <edwardk> i wrote c/c++ for 20 years and have very little reusable code to show for it. i've written haskell now for 8 and can pretty much use everything i've ever written, much of it i couldn't say that about if it was written in a strict language as i'd always be hand fusing crap to get better performance.
19:46:12 <Welkin> edwardk, you have been writing software for 28 years?
19:46:27 <edwardk> Welkin: yes
19:46:28 <johnw> he started young :)
19:46:31 <geekosaur> he's not the only one here who can claim that, even
19:46:35 <hiptobecubic> that's only back to the 80's
19:46:49 <hiptobecubic> it's not like people weren't programming then
19:46:55 <johnw> i've been writing software for exactly 28 years too
19:47:13 <hiptobecubic> The java/OO boom was already the 90's wasn't it?
19:47:15 <edwardk> johnw and i have amazingly similar backgrounds
19:47:43 <johnw> I've been working on sync'ing up with edwardk's 8 years of Haskell :)
19:47:47 <vermeille> edwardk: not kidding, do you write enough templates?
19:48:24 <edwardk> vermeille: yes. the easy with which i could write "generic" programs in haskell was one of the first things that won me over. =)
19:48:26 <hunt> johnw: how manny haskell years do you ahve
19:48:27 <hunt> ?
19:49:11 <johnw> hunt: I'm at 1.6 real years now, with 2 years before that where nothing made sense and I gave up several times
19:49:13 <hunt> edwardk: do you have a github?
19:49:20 <edwardk> hunt: github.com/ekmett
19:49:23 <hiptobecubic> hunt, lol
19:49:36 <hiptobecubic> hunt, do youself a favor and *don't* follow him
19:49:38 <edwardk> there are a few packages on there
19:49:53 <hunt> hiptobecubic: whys that?
19:50:07 <hiptobecubic> hunt, unless you *really* just don't care what anyone else on earth is working on :)
19:50:13 <hiptobecubic> hunt, because edwardk is... prolific
19:50:17 <edwardk> hiptobecubic: well, my traffic is way down this year. i went from 5th most active user to something like 72nd ;)
19:50:59 <johnw> edwardk: did 7-Eleven stop carrying Diet Coke?
19:51:00 <hiptobecubic> edwardk, hah. not surprised at all. Where do you get the stats? Can we see the distribution?
19:51:15 <Welkin> I've only been serious about writing software for 1 year
19:51:23 <edwardk> johnw: =P nah. got sucked into actually committees for things, work, giving talks, etc.
19:51:27 <hiptobecubic> johnw, he probably ran out of good ideas for operators
19:51:28 <Welkin> before that I only wrote small IRC scripts
19:51:45 <hunt> edwardk: do you use haskell at work
19:51:49 <hiptobecubic> there's only so many two and three character combinations that are valid
19:51:53 <edwardk> hunt: yes
19:52:08 <hunt> edwardk: is it research?
19:52:09 <edwardk> https://gist.github.com/paulmillr/2657075
19:52:32 <edwardk> hunt: i work in finance, we make tools used by quants/traders mostly.
19:53:26 <edwardk> i also mostly gave up sleep for a few years, surprisingly, that helped my producitivity
19:53:31 <zipper> You work in finance? I thought I heard different on the haskell cast.
19:53:52 <johnw> edwardk: oh, and the working out was a big time hit
19:54:01 <zipper> edwardk: Sleeping less helps productivity? How many hours?
19:54:08 <edwardk> johnw: that hurt a lot last year, yeah
19:54:35 <edwardk> zipper: i'm back up around 4-5 hours now, was down around 2-3 for the last few years
19:54:57 <zipper> edwardk: 2-3 hours every night?
19:55:01 <zipper> Christ
19:55:14 <zipper> but lots of coffee I assume, right?
19:55:17 <johnw> wow, I sleep 4-6 edwardk nights for each one of mine
19:55:27 <hunt> edwardk: no way 2-3 per night? no way you can survive on that
19:55:28 <zipper> 2-3 hhours for a few years OMG
19:55:31 <edwardk> mostly diet coke and occasionally tea
19:55:40 <hunt> edwardk: thats gotta just fuck someting up
19:55:52 <johnw> I've heard there are rare people who can actually function on that little sleep
19:55:59 <zipper> edwardk: Won't it hurt your brain when you're older?
19:56:02 <edwardk> i'll let others in here testify to the fact that it somehow works, and it definitely does hurt things.
19:56:14 <edwardk> zipper: so people insist on telling me
19:56:16 <Welkin> sleep deprivation is not a good thing
19:56:55 <zipper> Yeah I think it's bad for your brain, luckily you are our test subject. We eagerly await your old age to see the effects.
19:57:03 <edwardk> i can generally keep going as long as i let myself switch topics regularly and as long as i'm learning something or doing something new. if i'm just surfing reddit or something, i'll just turn it off and go to sleep.
19:57:07 <hunt> edwardk: you felt rested when you woke up?
19:57:58 <augur> man i wish i could sleep that little
19:58:06 <augur> noam chomsky sleeps like 4 hours
19:58:34 <tsou> my 2-3 hours phase luckily lasted 3-4 months only, i'm back to 4-5 too now :P
19:58:36 <edwardk> hunt: not terribly good/bad either way. i used to do polyphasic sleeping, but eventually stopped because i couldn't fit the perfectly timed sleep into my day. the main thing i got out of it though was the ability to fall asleep pretty much instantly and get up as long as i sleep in multiples of ~1.5 hours.
19:58:42 <zipper> I've heard of people doing drugs to raise productivity. I don't know those people personally.
19:58:54 <zipper> Like prescription drugs for ADD
19:59:13 <hunt> edwardk: and no depression or communicative failures?
19:59:27 <edwardk> i pretty much live in terror of doing anything to disrupt my current level of productivity, so i do nothing to my brain chemistry ;)
19:59:32 <zipper> edwardk: Write about that. I sure want to try that for a few months
19:59:33 <hunt> zipper: adderall, its a popular study drug
19:59:56 <zipper> hunt: Do you do drugs to make yourself "cleverer"?
20:00:02 <hunt> not me
20:00:16 <hunt> but there are people at my school who do
20:00:22 <hunt> i think
20:00:40 <hunt> no actual confirmation, but its really likely
20:00:53 <zipper> hunt: I'm too afraid of getting some brain disease when I am old for such drugs.
20:01:09 <prsteele> zipper: hunt http://en.wikipedia.org/wiki/Paul_Erd%C5%91s#Personality
20:01:18 <hunt> zipper: probably best not to, and im sure there are plenty of articles about this stuff
20:01:21 <edwardk> i figure as long as i spend the extra time learning stuff i should be okay
20:01:31 <zipper> I mean mental illness.
20:02:04 <hunt> edwardk: I've had glimpses of that treror, and i really don't want to go down that path, besides theres more to life than productivity, isnt there?
20:02:24 <Welkin> most of the contributors on that list are writting javascript, ruby, or php
20:02:29 <Welkin> writing
20:02:36 <edwardk> hunt: well, i rather like what it is i do.
20:02:55 <zipper> hunt: Easy to say that when you can at least get by,
20:02:59 <edwardk> and i have an amazingly patient wife who puts up with me =)
20:03:04 <zipper> I don't want to be poor
20:03:06 <hunt> edwardk: ok, better phrased: do you think the year or two or three of 2-3 hours of sleep was worht it?
20:03:06 <Welkin> no kids?
20:03:17 <dmj`> edwardk: do you drink coffee?
20:03:19 <hunt> yea all that stuff, it must be so hard to manage
20:03:25 <edwardk> absolutely
20:03:31 <Welkin> some days I sleep 12 hours
20:03:34 <edwardk> dmj`: diet coke mostly
20:03:46 <Welkin> mostly 8
20:03:46 <hunt> edwardk: was that absolutely for me
20:03:50 <Welkin> rarely 6
20:03:51 <zipper> Welkin: lol me too. I feel guilty for being lazy
20:03:52 <edwardk> Welkin: i pretty much can't sleep 8 hours if i want to =)
20:03:56 <edwardk> hunt: yes
20:03:58 <hunt> Welkin: same here
20:04:00 <Welkin> zipper, do not feel guilty
20:04:02 <Welkin> you are not lazy
20:04:06 <hunt> ^
20:04:08 <lispy> does anyone know if 7.8 will have better 64bit windows support? In 7.6 it exists but is quite flaky.
20:04:10 <zipper> Welkin: What am I?
20:04:12 <Welkin> you need down time to be creative
20:04:17 <hunt> zipper: a real human bean
20:04:29 <edwardk> when i look back at all the things i didn't know ~4 years ago, i'm shocked at what an idiot i was.
20:04:49 <athan> physical health is important man
20:04:49 <geekosaur> sounds normal to me :p
20:04:51 <edwardk> when i look at all the things i don't know how to do now, i'm aware i have a lot more to learn =)
20:04:51 <hunt> i guess theres something to be said for spending a huge amount of time just absorbing
20:04:52 <Welkin> on your death bed, you will not wish that you worked longer hours
20:04:54 <haasn> edwardk: I hope that feeling never disappers for me
20:04:57 <athan> it makes things way easier, too
20:05:01 <haasn> disappears*
20:05:13 <zipper> "be productive or die trying"
20:05:19 <hunt> thats silly
20:05:22 <hunt> whered you hear that zipper
20:05:32 <edwardk> Welkin: i've heard that line my entire life, and it always struck me as the sort of thing people were trying to convince themselves of, rather than convince others of =P
20:05:38 <Welkin> productivity is a capitalistic idea
20:05:50 <haasn> am I being productive right now by contributing to software I use and love?
20:05:52 <hunt> ^
20:06:00 <haasn> and is this capitalistic?
20:06:05 <hunt> Welkin, are these uncommon thoughts because youre pretty much speaking my mind right now
20:06:12 <Welkin> you don't need to "be productive"
20:06:17 <mornfall> productivity is moot, true
20:06:20 <Welkin> you create your own purpose for living
20:06:26 <athan> Welkin: This
20:06:26 <Welkin> do not judge yourself on the standards of others
20:06:31 <hunt> athan: this
20:06:44 <zipper> If I will die having achieved what I wanted to achieve I won't care whether or not I didn't sleep for a whole year
20:06:47 <athan> erm
20:06:52 <mornfall> but it's possibly a good indirect measure
20:06:53 <haasn> I don't need other people to tell me to be productive, but what I need less is for other people to tell me to not be productive
20:06:54 <athan> flip Welkin: this
20:06:55 <zipper> The end justifies the means
20:06:58 <edwardk> Welkin: i'm not trying to maximize some naive notion of lines of code. what i do want is for functional programming to succeed, for good ideas to succeed over horrible hacks, and to find nice ways to build code in a way that in 8 years i'm not solving the same problems using variants on the same crappy tools i was 8 years before.
20:07:13 <mornfall> also, it's 5 am, here come my 2.5 hours of sleep :D zzz
20:07:26 <athan> We need to look at interacting with an environment differently
20:07:31 <athan> to make something easily adaptable
20:07:33 <athan> I believe
20:07:37 <haasn> If anything, I think it's capitalistic to tell people to do nothing
20:07:41 <hunt> edwardk: ideas arent neccesarrily linked toproductivity though, are they?
20:07:43 <zipper> !grab edwardk
20:07:53 <nisstyre> Welkin: some people genuinely enjoy doing their work
20:07:56 <athan> I think they are, hunt
20:07:56 <zipper> This bot :(
20:08:00 <nisstyre> and are willing to spend a lot of time on it
20:08:12 <athan> natural actions are just more things to not have to worry about
20:08:16 <Welkin> yes nisstyre, I also enjoy working on things that I enjoy working on
20:08:20 <hunt> athan: i don't know, I think its more about freeing yourself of worry
20:08:26 <hunt> athan: yea sure,
20:08:29 <Welkin> but not at the expense of everything else in life
20:08:29 <edwardk> hunt: a lot of the code i write is the way it is because i like to reach out and touch a lot of disciplines. if i didn't spread myself so strangely i couldn't write a lot of the stuff i write.
20:08:40 <hunt> athan: but if productivity is not the pinnacle of your existence then you wont really be worrying about it so much
20:08:41 <nisstyre> Welkin: that is highly contingent on your personality
20:08:53 <nisstyre> some people do not enjoy other 'things' as much
20:09:08 <zipper> nisstyre: Not the people in this channel.
20:09:30 <hunt> edwardk: so you have diverse abilities and knowledge, but aren't we talking about creativity right now? or just ability?
20:09:30 <Welkin> for example, thinking about human activity and trying to understand the world
20:09:35 <nisstyre> some people would legitimately be bored if they went out drinking or whatever all the time
20:09:53 <zipper> I remember last semester I had jock roommates at campus. I stayed up all night programming. They thought I was crazy.
20:09:53 <Welkin> this may not be "productive" by society's standards, but it is personally fulfilling
20:09:57 <athan> hunt: I feel like I agree with you, but I still believe that we should have capability as well
20:10:13 <zipper> They go for nights partying continuously but think that is normal
20:10:13 <hunt> athan: i agree, you need some capability for your ideas to be practical and relevant
20:10:16 <athan> so expanding potential through expansion, rather than ability to expand
20:10:18 <haasn> zipper: thanks for reminding me the sun is about to rise, and I'm still programming :(
20:10:24 <johnw> I already look back at my past several decades, and wish I'd worked harder at more productive things
20:10:35 <zipper> Studying for over 2 hours is crazy to some but partying all weekend is just...
20:10:39 <athan> derp
20:10:40 <athan> wow
20:10:49 <athan> I didn't even realize I made a circular definition hahaha
20:11:03 <prsteele> anyone use literate haskell?
20:11:13 <nisstyre> prsteele: very likely
20:11:21 <Welkin> no, illiterate haskell
20:11:23 <nisstyre> do you have a question about it?
20:11:25 <johnw> prsteele: I use it when I write blog posts
20:11:27 <hunt> theres a good chance, and i think we can all agree with this, that a lot of people in computer science are potentially depriving themselves of real life because they also enjoy programming
20:11:34 <athan> increase of potential through the increase actual content, that can be used ad-hoc, vs. ability to create things
20:11:34 <zipper> prsteele: Interesting guy Paul Erdos.
20:11:41 <athan> I think both are needed, and need to coexist
20:11:42 <nisstyre> hunt: I disagree
20:11:44 <vermeille> study is party \o/
20:11:52 <zipper> hunt: What is real life?
20:11:53 <hunt> nisstyre: why
20:11:54 <johnw> hunt: real life cannot be separated from programming to me
20:12:00 <zipper> hunt: Is CS not real life?
20:12:01 <athan> that's all up to you
20:12:02 <hunt> ok sorry, i mean the rest of ilfe
20:12:04 <athan> and how you spend it
20:12:08 <athan> and what you view as a waste
20:12:09 <edwardk> hunt: well, i pretty much follow feynman's problem solving algorithm, to apply it petty much requires spending a lot of time learning new techniques.
20:12:13 <edwardk> re pretty much
20:12:18 <nisstyre> hunt: because programming is just as 'real' as going out every night and killing brain cells or sitting in front of a screen and watching explosions
20:12:22 <vermeille> Oh, things like girls, alcohol and stuff?
20:12:35 <Welkin> no
20:12:41 <Welkin> I don't find those thing very interesting
20:12:42 <zipper> When athletes and artists spend all their time pracicing it is normal?
20:12:46 <nisstyre> how many people actually spend most of their time doing things like hiking, or visting other countries?
20:12:55 <hunt> no no no hold on, it was a mistake to use "real", i mean all the other parts of your humanity
20:12:55 <Welkin> I enjoy existential philosophy and anthropology
20:12:56 <nisstyre> not very many, because those things require free time and money
20:13:02 <Welkin> artwork
20:13:07 <akurilin> quick question: when I make a request in http-conduit and then pass records to it for customization, how exactly is that request acting like a function? What kind of magic is that?
20:13:07 * johnw wonders if #haskell has gone meta so as to prove the necessity of programming before it proves the necessity of functional programming
20:13:18 <nisstyre> hunt: lots of programmers also like things like reading, are into music, and other things
20:13:25 <lispy> vermeille: probably adults of other genders (as contrasted with 'girls', that means children, right?)
20:13:30 <johnw> akurilin: do you mean partial application?
20:13:37 <johnw> akurilin: can you show me the code in question?
20:13:38 <athan> Yeah, like I do drugs and stuff
20:13:41 <athan> er, wait...
20:13:42 <hunt> nisstyre: im not saying they dont, i do those things, but im saying there may be an epidemic in which programmers avoid all of that
20:13:46 <nisstyre> personally I can also play the drums, enjoy a huge range of music, read lots of non-technical books, and enjoy art history
20:13:51 <akurilin> johnw: http://www.yesodweb.com/book/http-conduit
20:13:58 <nisstyre> hunt: I disagree with that
20:14:00 <johnw> akurilin: which part?
20:14:03 <akurilin> johnw: check out the first example where he makes req2
20:14:08 <nisstyre> is that just based on anecdotes?
20:14:17 <johnw> ok
20:14:25 <johnw> req2 is modifying fields from req
20:14:29 <johnw> to make a new request from an old one
20:14:33 <athan> hunt: I do find people like that
20:14:34 <hunt> nisstyre: its a reaction to edwardk's description of his two years of dedicated study
20:14:37 <vermeille> lispy: is "women" better?
20:14:42 <edwardk> i personally derive much of the same joy other people do from going off and playing with a guitar riff or appreciating art from going off and playing in a different field
20:14:56 <johnw> edwardk++
20:15:00 <nisstyre> hunt: well there's nothing wrong with focusing for a while
20:15:01 <athan> hunt: I've seen lots of people that vicariously live through life
20:15:02 <hunt> yea i believe your fine edwardk, it was reasonable and i guess an effective decision for the time
20:15:06 <johnw> yes, to some, engineering is both art and science
20:15:37 <zipper> Hiking isn't for everyone you know.
20:15:43 <hunt> nisstyre: but i believe it might be a practivce that is more common than just edwardk, and easy to get away with in the programming world, especially when the reasons might not be rational
20:16:04 <edwardk> hunt: well, my schedule switched when i went back and started collecting degrees post-dot-com-crash. i pretty much paced myself based on what the opportunity cost of beng in academia meant. to me.
20:16:08 <lispy> vermeille: definitely! :)
20:16:09 <hunt> johnw: thats what ive always said, and thats what ive always said is attractive about it
20:16:13 <vermeille> Hmmmmmmmmm, a not-so-unrelated question: how many of you do you work in the Silicon Valley?
20:16:22 <athan> hunt: But, I mean, sometimes those kind of people haven't confrontend themselves over their... lazyness about what they want in life. Eventually, everyone should get to the point where they decide whether they should twist it up or not
20:16:22 <Platz> try lots of things.  keep doing the ones you find that you enjoy
20:16:31 <nisstyre> hunt: I notice parallels in the work ethic of people like Hayao Miyazaki (animator), John Carmack, and directors like Werner Herzog, which is that they're all _dedicated_ to their craft
20:16:33 <akurilin> johnw: so to clarify we have a m Request that takes a record and return a modified Request?
20:16:38 <zipper> edwardk: How many hours and how many times did you sleep per 24 hours during the polyphasic sleep time of your life?
20:16:40 <nisstyre> and they spend almost all of their waking life refining it
20:16:42 <athan> This is dumb, but...
20:16:45 <nisstyre> because they love it
20:16:51 <edwardk> so a year later i graduated, a semester later i graduated again, and again, and again, then i realized i was hiding in academia and left back for the real world
20:17:01 <johnw> akurilin: yes, the syntax there is called "record mutation", in that we generate a new record from an existing record by replacing the values in certain fields
20:17:02 <athan> I write open source software to try and improve the planet
20:17:06 <athan> like literally that's my goal
20:17:08 <athan> that's what drives me
20:17:10 <athan> so i mean
20:17:14 <athan> we all have our reasons
20:17:17 <nisstyre> athan: yes, me too
20:17:22 <zipper> athan: :)
20:17:29 <zipper> athan: That is noble
20:17:31 <athan> I just feel like everyone needs to define it themselves
20:17:36 <nisstyre> I have the utmost respect for people like Richard Stallman and Gerald Sussman (founders of the FSF)
20:17:38 <athan> hahaha thanks
20:17:38 <hunt> nisstyre: those are very particular examples, and i'm not sure if i understand your point
20:17:42 <edwardk> zipper: 6 30 minute naps, on ever 4 hours.
20:17:43 <athan> I couldn't live any other way
20:17:46 <nisstyre> hunt: my point is that it
20:17:50 <edwardk> er one every
20:17:52 <nisstyre> it's fine to be insanely dedicated
20:17:55 <johnw> I code, because if I stopped coding, I'd just find another way to code. :)
20:17:58 <athan> edwardk: I must try this
20:18:07 <nisstyre> there's nothing unnatural about it, people just act like it is to make themselves feel better or something
20:18:11 <athan> nisstyre: hahaha
20:18:14 <edwardk> athan: i couldn't do it. 4 months in i burned out.
20:18:35 <edwardk> too hard fixing your schedule like that when you have to interact with other human beings.
20:18:43 <nisstyre> the cold hard truth is that most people are unproductive and wish they could find something they can be more productive at and enjoy
20:18:46 <athan> edwardk: I might... I don't know. I've been able to do it in one lump-sum
20:18:46 <Welkin> I don't particularly care about programming or computers, I just enjoy creating things
20:18:57 <athan> edwardk: hahaha
20:19:00 <akurilin> johnw: so any type that has the accessors / uses record syntax to define its components will support this individual field updating syntax?
20:19:01 <nisstyre> look at something like Maslow's hierarchy
20:19:02 <Welkin> whether it is food, artwork, games, utilities, etc
20:19:13 <athan> i feel like
20:19:14 <johnw> akurilin: "uses record syntax", yep
20:19:16 <zipper> I overinduldge in everything I do.
20:19:16 <prsteele> johnw: any chance you use Emacs when writing literate Haskell?
20:19:20 <athan> people overlook the requirement of energy
20:19:21 <johnw> prsteele: Indeed I do :)
20:19:26 <athan> not just sleep
20:19:42 <hunt> nisstyre: ok maybe my argument is too particular as well, but what I'm trying to get accross is that a lot of people might be dedicated to programming for bad reasons, such as avoiding real life. I know a lot of people who are genuinely passionate about programming and insanely dedicated and thats just how they are, it may have some consequences, but its who tey are, . And I know others who are dedicated for silly reasons, like status 
20:19:43 <nisstyre> in the top of the pyramid is "problem solving"
20:19:43 <athan> but actually measuring their proficiency from diseparate facotrs
20:19:49 <athan> focus, energy, charisma
20:19:50 <akurilin> johnw: cool thank you!
20:19:53 <athan> curiosity
20:19:56 <athan> things liek these
20:20:08 <athan> they need to be taken into consideration when measuring your own performance
20:20:12 <nisstyre> hunt: so you're saying that they do it because they're misanthropes?
20:20:12 <hunt> nisstyre: other life is too hard
20:20:24 <prsteele> johnw: any tips / warnings? It seems to work well as-is, but this is hardly a normal mode...
20:20:25 <johnw> akurilin: you do it to any record value, even a return value from functions: (foo x) { field = blah }
20:20:36 <nisstyre> it's hard to tell if that's true without knowing the people in question
20:20:39 <vermeille> hunt: the same is applicable to a looooooot of nerds playing video games, or reading heroic fantasy, or porn addicts, or... or... or.. [plenty of things]
20:20:43 <johnw> prsteele: you'll need to ask me something more specific; or ask in #haskell-emacs
20:20:48 <hunt> nisstyre: I'm saying they do it for a variety of unhealthy resons
20:21:05 <prsteele> johnw: so that exists; perfect, thanks
20:21:06 <edwardk> More or less when I went back to collect degrees I was binging through initially to see how quickly I could graduate because of opportunity cost of going back so late in life, and then after a while it was more trying to see if I'd burn out, and kept cranking up the pressure. I ran out of money before i burned out.
20:21:06 <hunt> vermeille: yea i figured earlier on that tat may be what my argument boils down to, which is unfortunate
20:21:08 <athan> hunt: They need to confront that on their own
20:21:11 <johnw> a syntax that still blows my mind sometimes is: let x = Record {..}
20:21:19 <athan> hunt: the best thing we can do is be compassionate
20:21:27 <hunt> athan: I know, but i think there are missing components in the programming community that could help avoid that
20:21:30 <akurilin> johnw: ah good to know
20:21:42 <athan> hunt: I agree
20:21:48 <nisstyre> hunt: what, specifically, do you propose people do to encourage healthy attitudes?
20:21:54 <athan> hunt: I'm working on a large physical interface
20:21:58 <hunt> A social component to programming
20:22:06 <athan> hunt: for music
20:22:06 <zipper> haha I would be neck deep in academia if I could find a good college
20:22:06 <nisstyre> that exists
20:22:07 <hunt> but im not sure how that could possibly exist
20:22:17 <athan> hmm
20:22:18 <athan> well
20:22:24 <hunt> nisstyre: where
20:22:25 <nisstyre> it just isn't present in most organizations
20:22:29 <hunt> nisstyre: or what or w.e.
20:22:33 <zipper> edwardk: How did you pay for all the degrees?
20:22:41 <athan> I think that it's a side effect of compounding the fact that it's mentally difficult to program
20:22:50 <Welkin> the worst part of programming is being stuck at a desk in front of a screen
20:22:56 <athan> thinking hard, itself, leans itself to isolation
20:23:03 <akurilin> ok another question: I'm running some http-conduit code in a runResourceT $ do block. I can't seem have let foo = runResourceT $ do ... syntax parse correctly.
20:23:09 <athan> Welkin: I try to go to coffee shops
20:23:16 <akurilin> Doing something silly I'm sure.
20:23:18 <johnw> akurilin: foo <- runResourceT ...
20:23:19 <Welkin> I would prefer to program in nature without a screen
20:23:29 <Welkin> possibly by voice
20:23:31 <athan> Welkin: Or like, at parties, I'll just be the crazy guy, pondering in his mind
20:23:36 <hunt> you know what is also possibly a problem, that the type of introverted thinking we do while programming also overlaps with a lot of what we do to process the real world
20:23:41 <nisstyre> hunt: there are lots of initiatives to get people together (physically) and learn/teach/program
20:23:44 <johnw> akurilin: otherwise, you're naming the action, not executing it
20:23:44 <hunt> and maybe distracts
20:23:45 <athan> Welkin: But explaining it all to people
20:23:53 <athan> It's actually pretty fun
20:23:58 <hunt> nisstyre: good, i think it should be more integral to programming
20:24:04 <athan> peopel can be interested in what it means to program
20:24:22 <_|x|_> cant have it both ways unfortunately
20:24:23 <athan> you just have to show the interesting parts
20:24:31 <edwardk> zipper: left over money from my telecom CTO days before the crash and some random royalties
20:24:41 <athan> I'm trying to start a studio
20:24:47 <_|x|_> oh this is haskell
20:24:47 <athan> for games, music, art, etc.
20:24:48 <_|x|_> lol
20:24:52 <nisstyre> hunt: personally I dislike trying to program right there with someone else...it just doesn't work
20:24:52 <athan> (via programming)_
20:25:04 <athan> hmm
20:25:06 <nisstyre> and inevitably the other person will slow me down with unhelpful suggestions
20:25:06 <athan> yeah
20:25:11 <bitemyapp> nisstyre: you get used to it.
20:25:25 <bitemyapp> nisstyre: but pair-programming *can* be intensely frustrating sometimes.
20:25:25 <athan> I mean, problem solving itself takes someone to find the answer
20:25:29 <sjy> sounds like you need to find someone better to pair with
20:25:34 <athan> like, normally one person hits the target
20:25:35 <bitemyapp> Especially when you're already following up on a thread of thought that will work.
20:25:37 <athan> then gets the team to move on
20:25:39 <bitemyapp> sjy: that too.
20:25:39 <hunt> nisstyre: thats not a very realistic attitude, i think the conversation maybe should be more about larger systems then programmic minutia
20:25:48 <nisstyre> hunt: yeah maybe
20:25:48 <sjy> i have had positive experiences pair programming with people who are more skilled than me
20:25:59 <nisstyre> but if the other person is not on the same page then it will be you explaining fundamental concepts
20:25:59 <sjy> i'm not sure if they found the experience to be positive :P
20:26:00 <athan> that's why I believe in sharing things of interest
20:26:10 <hunt> nisstyre: not if youre in a group from the get go
20:26:12 <edwardk> zipper: Basically i'd been a CTO for several years by then but who wants to hire a CTO without a formal education, especially post dot-com crash when the market is flooded? so i went back and fixed the imbalance. Overshot a bit.
20:26:15 <nisstyre> or if you have different philosophies then maybe that could be productive
20:26:35 <nisstyre> hunt: I have nothing wrong with teaching though
20:26:39 <zipper> edwardk: Nothing like overdoing education IMO
20:26:42 <nisstyre> as long as it's clear that's what's happening
20:26:56 <akurilin> johnw: ah thanks, that seems to have done it!
20:26:59 <zipper> I want to do a math degree after I am done with my informatics degree.
20:27:06 <nisstyre> edwardk: Oculus
20:27:07 <bitemyapp> edwardk: "overshot a bit" to the Haskell community's benefit though :)
20:27:14 <zipper> but I want to do it in a different school.
20:27:21 <bitemyapp> akurilin: lpaste the result for me please?
20:27:22 <edwardk> zipper: somewhere after the second masters while meeting the requirements for a third and auditing a fourth I realized I should stop =)
20:27:24 <zipper> Maybe a school in USA or Europe
20:27:28 <hunt> Welkin: do you do programming work
20:27:31 <bitemyapp> akurilin: I want to see what set you to rights after all.
20:27:38 <zipper> edwardk: Stop why?
20:27:43 <Welkin> hunt, I am still in uni, so no
20:27:47 <edwardk> zipper: well, mostly because i ran out of money
20:27:53 <hunt> Welkin: but you plan to after
20:27:54 <hunt> ?
20:27:56 <zipper> edwardk: lol that makes sense
20:27:57 <Welkin> but my degree program in computer engineering (hardware + software)
20:28:05 <nisstyre> I think Elon Musk has the right idea about academia
20:28:19 <nisstyre> churning out papers can be cool, but actually making use of academic ideas is lacking
20:28:35 <zipper> I feel that software engineering should be a masters section in mathematics and not an undergrad thing.
20:28:38 <nisstyre> that seems to be where Haskell shines?
20:28:45 <edwardk> now that that is fixed, i'm not sure i want to trade in the flexibility of what i do now for less money and less flexibility and less time to learn in academia.
20:28:50 <zipper> Then maybe there would be better software.
20:28:57 <sjy> zipper: there aren't enough mathematicians to write all the world's software though
20:29:13 <akurilin> bitemyapp: http://lpaste.net/3435932467675004928
20:29:13 <nisstyre> let mathematicians sit and think about whatever
20:29:16 <zipper> sjy: That is why we must make them.
20:29:22 <nisstyre> they shouldn't be writing software if they don't want or need to
20:29:28 <Welkin> hunt, I just want to build interesting things, so possibly
20:29:31 <hunt> nisstyre: thats probably one of the shiniest features of haskell, that it makes you feel like less of a grunt
20:29:33 <zipper> nisstyre: Those who want to.
20:29:43 <edwardk> well, i think there is merit to both 'computer science' and 'software engineering' both are actually important skillsets that are sadly largely disjoint and uncorrelated amng practitioners.
20:29:50 <hunt> Welkin: I do too, but im worried that the real industry just boils down to pointless grunt work and im not into that
20:30:09 <edwardk> burying CS under math ignores the SE side, which can be productively engaged in largely math-free
20:30:12 <Welkin> hunt, that is why I am also heavily into entrepreneurship
20:30:30 <hunt> Welkin: I'm following that exact path, but 'm only jsut about to enter uni
20:30:36 <zipper> Never met a programming community as intellectually curious as the haskell one.
20:30:40 <bitemyapp> akurilin: thanks. I was suspicious of the dangling record getter with no retunr.
20:30:44 <bitemyapp> return*
20:31:01 <hunt> zipper: is this your first timein the channel
20:31:02 <edwardk> zipper: that and the sheer niceness of everyone here was what lured me in.
20:31:22 <zipper> hunt: No not at all.
20:31:23 <nisstyre> edwardk: or when you give examples of some idea making them about things nobody would ever need on a frequent basis (I've noticed the delimited continuation literature is bad for this)
20:31:27 <hunt> I agree though people are so much more interesting and distilled in haskell then elsewhere
20:31:33 <akurilin> bitemyapp: whatever I had before was making the app stall :(
20:31:47 <akurilin> bitemyapp: works now
20:32:04 <zipper> hunt: Distilled? lol people are distilled? lol are you saying that some people are impurities?
20:32:20 <hunt> zipper: i meant distilled as in theres less bullshit surrounding the core
20:32:21 <edwardk> nisstyre: hah
20:32:30 <bitemyapp> hunt: who has time? :)
20:32:49 <nisstyre> edwardk: if you could show me a killer app for them I'd be very happy
20:32:49 <hunt> bitemyapp: time for what?
20:33:01 <nisstyre> the closest I got was a thing about tree traversal
20:33:13 <athan> wait... can you have datatype references to polymorphic functions
20:33:13 <zipper> hunt: lol I know, but what a word, distilled. This is the first time I heard it describing people's way of thought.
20:33:14 <athan> ?
20:33:16 <athan> like
20:33:29 <edwardk> well, to finish my revisions package i basically need to go back and work it up delcont style. ;)
20:33:39 <athan> type Lens' s a = forall f. Functor f => (a -> fa) -> s -> f s
20:33:41 <hunt> ziper: i thought it  was an interesting choice too, i think its the right one
20:33:43 <athan> that's a function, isn't it?
20:33:50 <nisstyre> edwardk: I'm assuming you've looked at Oleg's papers on them
20:33:54 <edwardk> nisstyre: yes
20:33:58 <zipper> edwardk: When you started doing polyphasic sleep, did you just go cold turkey or what did you do in preparation?
20:33:59 <athan> er, the type of a particular function?
20:34:28 <edwardk> zipper: i pretty much gave it a shot cold turkey, was miserable for ~2 weeks and then started being able to function
20:34:30 <athan> > type Lens' s a = forall f. Functor f => (a -> fa) -> s -> f s
20:34:31 <lambdabot>  <hint>:1:1: parse error on input `type'
20:34:53 <edwardk> zipper: by around 2 months into it i was at maybe 80% of my usual energy level, but with more hours in the day.
20:35:25 <Welkin> you may find this interesting: https://www.youtube.com/watch?v=QfMvqkrQkYQ
20:35:27 <zipper> hmmm Would my parents be ok with me sleeping 2 hours a day?
20:36:00 <athan> psh
20:36:00 <athan> sleep
20:36:00 <athan> lol
20:36:00 <zipper> They might think I have gone mad.
20:36:00 <hunt> ok i have a real haskell question now, not a human one (lol): I'm writing a graphics program that takes input from a command file (stuff like "line 0 0 0 1 1 1" and "render-parralel"), how would you approach this problem? currently I have a parse function that runs through a list of the lines of the file and calculates all the lines that need to be drawn, but as I'm expanding functionality (as in, I want to draw more than just lines, a
20:36:02 <Welkin> sleep is necessary for cognitive function
20:36:05 <hunt> this is proving ineffective
20:36:09 <hunt> what would you do?
20:36:17 * hackagebot xss-sanitize 0.3.5.2 - sanitize untrusted HTML to prevent XSS attacks  http://hackage.haskell.org/package/xss-sanitize-0.3.5.2 (GregWeber)
20:36:17 * hackagebot leksah 0.13.4.1 - Haskell IDE written in Haskell  http://hackage.haskell.org/package/leksah-0.13.4.1 (HamishMackenzie)
20:36:17 <edwardk> zipper: in many ways i've found i do a lot of my best work when i'm slightly tired. why? because i stop trying to pick the perfect solution and am willing to take a good one. then the next day i'm usually back in perfectionist mode, so it alternates between styles, often the best answer lies in the middle and it makes me my own devil's advocate
20:36:30 <Welkin> those who believe "sleep is for the weak" are naive and will pay dearly in the near future when their health deteriorates
20:36:46 <athan> Health is so important
20:36:48 <athan> diet
20:37:04 <nisstyre> " If you aren't sure which way to do something, do it both ways and see which works better."
20:37:06 <zipper> Welkin: Do you have proof of this?
20:37:11 <sjy> hunt: your message was truncated after "more than just lines,"
20:37:12 <athan> i really believe that our idea of having an instant suppliment for energy is wrong
20:37:18 <athan> all these "pick me ups"
20:37:24 <edwardk> Welkin: i don't believe sleep is for the weak. i know my health deteriorates. i also know that when i started working out it was too much for me to maintain that sleep pattern. my body started physically breaking down.
20:37:28 <athan> it really shouldn't be that way, imo
20:37:34 <Welkin> zipper, of course, about any neuroscience literature out there
20:37:37 <Welkin> it is common knowledge
20:37:42 <akurilin> So the OverloadedString pragma tells the compiler to figure out which type of string the literal should be interepreted as based on the context, rather than always defaulting to Prelude's String?
20:37:57 <zipper> Welkin: How many hours of sleep are ok?
20:38:03 <bitemyapp> akurilin: or an explicit type.
20:38:03 <Welkin> it depends on the person
20:38:04 <edwardk> tinnitis, rotator cuff injuries, knee pain, etc. all those ligaments need time to heal.
20:38:06 <nisstyre> akurilin: it turns it into a type class constraint much like Num
20:38:09 <Welkin> however many you need to feel fully rested
20:38:18 <Welkin> 6-12 a day
20:38:21 <hunt> sjy: i want to do stuff mid parse, and my current system is ineeffective, alternatives? I was thinking about writing a monad for parsing but im not clear on whether or not  i should
20:38:25 <Welkin> most people are around 8
20:38:32 <edwardk> Welkin: if i had to lie in bed for 6 hours i'd go nuts =P
20:38:37 <Welkin> and do not wake up to an alarm clock
20:38:45 <Welkin> it disrupts your sleep cycle
20:38:48 <akurilin> bitemyapp: nisstyre kk thx
20:38:55 <Welkin> you will wake up feeling anxious and angry
20:39:10 <nisstyre> akurilin: I put it in my .ghci
20:39:13 <edwardk> Welkin: sadly using an alarm clock and being able to hold a job are relatively correlated ;)
20:39:25 <Welkin> I've looked into polyphasic sleep and found it interesting
20:39:29 <Welkin> it is just a hack though
20:39:44 <edwardk> absolutely. you'll note i don't do it any more
20:39:46 <sjy> hunt: i still don't really understand your question, does each line of the file represent a discrete task that can be completed independent of the others?
20:39:47 <Welkin> it would drive me nuts to fall unconscious and then wake up so many times in a day
20:40:37 <hunt> sjy: yes, but i need to keep track of the results as well as the results of previous lines some lines rely on data accumulated from other lines
20:40:38 <Welkin> edwardk, did you ever experience sleep paralysis while engaging in polyphasic sleep?
20:40:49 <dmj`> edwardk: do you use emacs?
20:41:01 <edwardk> Welkin: nope
20:41:06 <edwardk> dmj`: vim
20:41:36 <edwardk> dmj`: and as folks can attest, i use very strange corners of it, often poorly. ;)
20:42:10 <edwardk> dolio pretty much hangs his head watching me move code around at all the inefficiencies in my workflow
20:42:31 <akurilin> Do I HAVE to create a data type every time I want to encode/decode something with aeson?
20:42:39 <akurilin> or can I one-off it?
20:42:51 <bitemyapp> akurilin: what would one-offing mean?
20:43:08 <bitemyapp> akurilin: you can skip implementing the FromJSON/ToJSON instances if you want, via the use of generics/TH/SYB
20:43:09 <edwardk> akurilin: you can "one-off it" using the combinators to get into the data type to get out the pats you need
20:43:15 <sjy> hunt: to me a logical way to break up the problem is to divide the problem into a list of discrete (and ideally parallelizable) tasks first
20:43:16 <edwardk> er parts
20:43:26 <bitemyapp> edwardk: lens aeson combinators?
20:43:33 <edwardk> bitemyapp: those too
20:43:48 <akurilin> e.g. I just want to make a {foo = "bar"} object
20:44:04 <hunt> sjy: well the truth is, actually, every line relies on a state affected by the orevious  line to be fully completed. The file describes the steps to composing the final state
20:44:07 <akurilin> Do I need to make a data type for it?
20:44:29 <hunt> sjy: as far as i can tell
20:46:31 <sjy> hunt: mind if i ask what kind of problem you're solving? i don't know a lot about graphics, but got the impression most graphics problems are usually easily parallelisable :)
20:46:39 <hunt> interesting, this is the first time ive seen haskell break away from haskell
20:47:07 <sjy> what kind of state gets updated between lines?
20:47:20 <edwardk> akurilin: _Object # (mempty & at "key" ?~ (_String # "value")) :: String        ===>   "{\"key\":\"value\"}"
20:47:37 <edwardk> not the most elegant abuse of lens, but meh
20:47:42 <Welkin> does anyone in here use haskell for graphics programming?
20:47:50 <edwardk> Welkin: yes
20:47:56 <Welkin> in place of c++?
20:48:01 <akurilin> edwardk: oh wow, good gosh
20:48:17 <sjy> hunt: what kind of state is it that gets changed between lines?
20:48:28 <hunt> sjy: yea sorry i was trying to think how to phrase this
20:48:51 <sjy> hunt: that's ok! i don't actually know if i'm being helpful at all :)
20:48:52 <hunt> sjy: currently, i am tracking a transformation matrix, a line matrix (composed of vertices) and potentially a triangle matrix
20:49:07 <edwardk> akurilin:  _Object # HM.fromList [("key",_String # "value")] :: String   -- is probably a bit cleaner
20:49:13 <hunt> sjy: as well as a little auxiallary data about the output
20:49:18 <hunt> Welkin: I'm trying to right now
20:49:34 <hunt> Welkin: but I'm at the beginning, not doing anything super serioius
20:49:40 <edwardk> that is using OverloadedStrings and Data.Aeson.Lens and Control.Lens
20:50:56 <edwardk> >>> _Object._Wrapped # [("key",_String # "value")]
20:50:58 <edwardk> "{\"key\":\"value\"}"
20:51:12 * hackagebot leksah 0.13.4.2 - Haskell IDE written in Haskell  http://hackage.haskell.org/package/leksah-0.13.4.2 (HamishMackenzie)
20:51:25 <edwardk> that is nicer
20:51:29 <edwardk> that is about as short as i can golf it with lens without getting silly
20:51:40 <hunt> sjy: I've contemplated just using straight up state, but i feel like the best solution is probably monadic somehow
20:52:09 <hunt> im not really familiar enough with monads (I've just raed through their purpose and usage) to actually think of it though
20:52:52 <sjy> hunt: yeah, my intuition is probably not much better than yours :)
20:53:03 <hunt> sjy: damint!
20:53:21 <Welkin> dat mint
20:54:17 <sjy> hunt: what do you get out at the end of that computation? is that state part of what you're trying to compute, or is it just needed to define each successive step of the computation?
20:54:32 <Welkin> this mint dark chocolate is great
20:56:11 <hunt> sjy: intermittently, you need to know the line matrix and the triangle matrix (whenever youre asked to render to the screen or to a file), my current solution is that the parse function returns that data and trashes everything else when render is called, and then i can render it with opengl
20:56:43 <hunt> sjy: but i guess the problem is i dont want to trash everything
20:57:14 <hunt> do you guys ever get anxious without much clue why
20:58:16 <sjy> hunt: right, i think i'm now at the point where i agree that the best solution probably involves some monadic stuff i'm not clever enough to think of :P
20:58:35 <hunt> sjy:nooooooooooooo
20:59:39 <hunt> i think the rerason im anxious is because most of what i said back when we were talking about philosophy was probably more about my own problems then anything else
20:59:41 <hunt> i always do that
21:00:29 <hunt> does anyone want to help me figure out this monad i want
21:01:11 <dmj`> hunt: what monad do you want
21:01:36 <hunt> dmj' i want a monad tht can track 6 pieces of data, and perform IO functions on the occasion
21:01:57 <dmj`> hunt: do you need the ability to update these 6 pieces of data during the computation
21:01:58 <hunt> dmj' and actually, Im not sure if its a monad
21:02:11 <Zekka> hunt - StateT (Data1, Data2, Data3, Data4, Data5, Data6) IO?
21:02:28 <hunt> dmj' yea, what I'm doing is traversing through a command file which alters the 6 pieces of data, and outputting them every time it asks me to
21:02:38 <hunt> Zekka: maybe, im not convinced it has to be a monad either
21:03:31 <hunt> what do you guys think?
21:03:32 <dmj`> hunt: what data structure do you think could be used to best represent the 6 pieces of data
21:04:34 <hunt> each uses a different type, 3 are matrices, the other three are a area ((Int,Int),(Int,Int))
21:05:01 <hunt> one is actually a list of matrices, my bad
21:05:26 <hunt> dmj` any ideas?
21:06:28 <hunt> anyone else have any ideas?
21:06:56 <dmj`> hunt: as Zekka suggested I think StateT ADT IO () is a reasonable choice
21:07:12 <hunt> dmj` what is ADT?
21:07:17 <dmj`> algebraic data type
21:07:51 <dmj`> hunt: it's easier than dealing w/ tuples, at least from a software engineering perspective, IMO.
21:08:01 <Zekka> I suggested a tuple for brevity but an ADT is probably more appropriate
21:08:18 <Zekka> (I didn't want to list a data declaration on a separate line)
21:08:38 <dmj`> hunt: then inside your StateT s m a you can use a lens library to update your six pieces of data.
21:09:09 <dmj`> you can use lenses on tuples too, but ADT's are more descriptive
21:09:19 <hunt> thats scary, because I dont know anything about lenses or StateT. Also I'm hesitant that I should need a library for this
21:09:35 <Zekka> You don't strictly need lenses -- they're just neater
21:09:40 <hunt> also, will it maintain the data through a recursive call
21:09:53 <hunt> because my function parses one line and then calls itself on the rest of the list
21:09:59 <Zekka> StateT SomeType just transforms a monad that doesn't help you thread state of SomeType into one that does
21:10:16 <Zekka> hunt - That should still work as far as I know
21:10:47 <hunt> Zekka: ok, its strange to ask but the state of the data is maintained outside of the function?
21:10:55 <hunt> in a different skcope, perhaps?
21:11:15 * hackagebot propellor 0.1 - property-based host configuration management in haskell  http://hackage.haskell.org/package/propellor-0.1 (JoeyHess)
21:11:28 <Zekka> hunt - Not really: the state monad basically acts like an extra parameter where Haskell pipes that extra parameter through each operation in the monad, although the plumbing is a little hard to explain
21:12:36 <Zekka> https://en.wikibooks.org/wiki/Haskell/Understanding_monads/State <- this article goes through the plumbing a bit
21:13:26 <maroloccio> hello world :) so i found this book in the library.. is it a good place to start from scratch (2008-12-01 | Real World Haskell | O'Reilly Media | 714p | by Bryan O'Sullivan | ISBN-0596514980) or am i better off using http://learnyouahaskell.com/ or somethink like that since the book is from 2008?
21:13:35 <Zekka> Basically, an a in StateT b is internally a b -> (a, b) (in the StateT wrapper)
21:14:14 <Zekka> because StateT is a monad, functor, etc., it's good at hiding the plumbing that makes it feasible for you to compose those, but it proides some functions like put and get that help you move the state information into or out of the 'value' slot
21:14:56 <Zekka> er, State x is a monad, functor, etc., I should be more rigorous
21:15:01 <hunt> Zekka: so i call my recursive function from a StateT monad, and use puts/gets in the recursive function to have an effect?
21:15:29 <Zekka> hunt - You use those to get or modify your state value
21:15:48 <Zekka> You'd use lift to perform IO if that's what you mean
21:16:23 <hunt> Zekka: i guess it is, you mean when i need o io, id lift a do block and use my state as i please?
21:16:35 <hunt> Zekka: could i access the state from within the do block?
21:16:35 <Zekka> You don't have to lift a do  block
21:16:47 <Zekka> you just have to lift an IO action, which might be represented by a do block
21:17:06 <dmj`> hunt: do you want an example?
21:17:07 <Zekka> Basically, lift will turn your IO a into a StateT ADT IO a, so you can use it in your StateT ADT IO a
21:17:14 <hunt> dmj` yes that wouldbe nice
21:17:27 <Zekka> You'd write most of your block under StateT ADT IO a, but you'd lift your specific IO actions
21:17:40 <Zekka> but I should stop talking because I have homework to finish and dmj will write a good example
21:17:48 <hunt> Zekka: ok, thanks!
21:18:49 <zerokarmaleft> maroloccio: depending on your familiarity with functional programming, LYAH more or less bridges nicely to RWH
21:20:23 <athan> can you have a datatype of kind * -> (* -> *) -> *
21:20:25 <athan> ?
21:20:56 <dwcook> athan, you can certainly have a type constructor of that kind
21:20:56 <dmj`> hunt: http://lpaste.net/102041
21:20:56 <Cale> yes
21:21:36 <athan> dwcook: A type constructor? I thought that was the same thing as a value...
21:21:43 <athan> dwcook: but a partially applied one
21:22:04 <athan> dwcook: So, it would be a function, not a type, wouldn't it?
21:22:08 <dwcook> athan, not at all. A type constructor is a type of a kind with an arrow in it, like the one you mentioned
21:22:21 <athan> like Maybe?
21:22:25 <athan> derp
21:22:33 <dwcook> Yes
21:22:44 <athan> I'm thinking of like "Nil" in Foo a = Nil | Cons (Foo a)
21:22:54 <athan> what would that be called?
21:22:54 <dwcook> That's a data constructor
21:22:58 <athan> A value constructor?
21:22:59 <athan> ahhhhhh
21:23:00 <athan> okay
21:23:01 <dwcook> Or, well
21:23:11 <dwcook> Let me make sure I'm not confusing the terminology
21:23:29 <athan> where cons is... a partially applied data constructor
21:24:25 <athan> could you have something like
21:24:39 <athan> Of :: * -> ( * -> *) -> *
21:24:46 <dwcook> Um, the Report might use "type constructor" to mean a type of any kind, but I'm not sure
21:24:47 <athan> Of a b = b a
21:24:56 <athan> hmm
21:25:01 <athan> so then you could do
21:25:05 <dwcook> Anyway Cons is also a data constructor, it just happens to be a function
21:25:08 <scb> How do i tell cabal to install my dependencies defined on my .cabal?
21:25:09 <athan> Of Int Maybe = Maybe Int
21:25:23 <athan> cabal install
21:25:24 <dmj`> scb: cabal isntall
21:25:30 <dmj`> what athan said
21:25:31 <athan> while in the same directory as the .cabal
21:25:48 <dwcook> athan, yes, what you just mentioned is perfectly valid
21:25:54 <athan> dwcook: SERIOUSLY?
21:26:01 <dwcook> athan, wait no
21:26:04 <dwcook> type Of a b = b a
21:26:04 <athan> dwcook: Holy toleto, that brings a whole new level
21:26:12 <athan> dwcook: waaaaaaaaa
21:26:20 <athan> dwcook: Okay, my brain is fried
21:26:42 <hunt> what are lenses
21:26:42 <Zekka> athan - If it makes you feel any better, you can't partially apply it
21:26:43 <athan> dwcook: So you can do type arithmetic that is kind-safe?
21:26:57 <athan> hunt
21:26:58 <dwcook> athan, what do you mean?
21:27:37 <athan> hunt: jquery but with a bi-directional datatype (lens)
21:27:41 <dwcook> athan, by the way, type declarations are kind of odd in that GHC insists on you fully applying them before getting anything out of them, so doing "type Of a b = b a" and then ":k Of" in ghci might not be helpful
21:27:42 <Zekka> hunt - They're composable accessors.
21:27:42 <athan> so you have getters and setters
21:27:57 <athan> but you can do actually, anything that can become a functor to them
21:28:08 <athan> so you can do IO actions upon jquery selected subsets
21:28:09 <dwcook> athan, however you could do: data Of a b = Of (b a)
21:28:27 <dwcook> And then Of :: * -> (* -> *) -> *
21:28:28 <Zekka> Or newtype Of a b = Of (b a), which says about the same thing
21:28:41 <athan> hmm
21:28:48 <athan> so what is the difference with type?
21:28:56 <athan> it resolves back to b a in the type system?
21:28:57 <edwardk> hunt: lenses provide a way to make a sort of composable reference into parts of a structure so you can compose together the lenses to describe parts of a structure, and then use them with various combinators we provide to separate 'what to do' from 'what to do it to'. they just make the kind of code you already know how to write more composable.
21:28:57 <dwcook> athan, it's a limited type function, basically
21:29:00 <Zekka> (newtype basically meaning 'there's a constructor function that exists at compiletime)
21:29:01 <athan> it's just an alias, right?
21:29:20 <dwcook> athan, both of those intuitions are basically correct, yeah
21:29:20 <edwardk> hunt: jquery for haskell data types is probably the pithiest summary
21:29:55 <athan> hmm
21:30:13 <athan> Zekka: Aaaaah okay
21:31:15 <Zekka> athan - newtypes work basically the same way as data declarations with one constructor/one field, except after compilation they act like synonyms
21:31:20 <Zekka> they're static-only IIRC
21:31:42 <athan> ahhh okay
21:31:47 <dwcook> Among other things, newtypes let you hide or add typeclass instances
21:33:24 <athan> So any datatype that has an argument of kind * must have a concrete type, correct?
21:33:34 <athan> so eventually, the type has to resolve
21:33:35 <dwcook> e.g., say I wrote some strange monad transformer stack based on IO but didn't want the user to embed arbitrary IO. I could export just a newtype that didn't have an MonadIO instance
21:33:50 <athan> ahhh, hmm
21:33:51 <dwcook> athan, concrete types *are* exactly those types of kind *
21:34:16 <Zekka> (Not exporting MonadIO meaning "even if somewhere in my stack I use IO, if you ask me to do some IO for you I will stare at you blankly instead of helping")
21:34:18 <athan> dwcook: So that requirement exists?
21:34:31 <dwcook> athan, what requirement?
21:34:33 <athan> dwcook: ie, you couldn't supply a type constructor?
21:34:44 <dwcook> athan, to what?
21:34:52 <athan> dwcook: to complete the expression
21:34:54 <Zekka> I'm pretty sure it's not possible to define infinitely recursive type synonyms, if that's what you're asking
21:34:57 <dwcook> athan, which?
21:35:08 <hunt> how do i force ghc to rebuild everything?
21:35:09 <athan> your nested calls eventually have to come to a concrete type before )))))'ing
21:35:12 <Zekka> If you could partially apply them you'd probably be able to define the Y combinator, but you can't
21:35:20 <athan> so, here's my theory
21:35:34 <athan> Zekka: exactly my point
21:36:00 <joseph07> newtypes are also more explicit than type synonyms, because if functions expecting the newtype won't accept the wrapped type
21:36:01 <athan> you couldn't leave scope of an argument from a partially applied type
21:36:02 <vermeille> Parsec or Happy?
21:36:36 <athan> you can't do anything with (Maybe (Maybe))
21:36:47 <athan> because * /= * -> *
21:36:48 <dwcook> That's because Maybe's kind forbids that
21:36:51 <dwcook> Yes
21:37:00 <dwcook> That doesn't relate to type synonyms
21:37:20 <dwcook> You could easily write something of kind (* -> *) -> *
21:37:22 <Zekka> I've got to go, I may be back later
21:37:36 <athan> Zekka: See ya
21:37:43 <dwcook> e.g., data Foo f = Foo (f ())
21:37:46 <athan> hmm
21:37:55 <dwcook> Then Foo Maybe is perfectly valid
21:38:10 <athan> but, at compile time, all kinds must resolve to *
21:38:11 <athan> er
21:38:12 <athan> types
21:38:21 <athan> right?
21:38:23 <athan> er
21:38:26 <athan> evaluation time...?
21:38:45 <athan> hmm
21:38:46 <hunt> why does mapM_ have to be seperate from map? wouldn't map work for the same purposes?
21:38:50 <dwcook> You might be thinking of how all values belong to a type :: *
21:39:00 <athan> hunt: Yes!!
21:39:05 <athan> Have you read the typeclassopedia
21:39:05 <athan> ?
21:39:18 <athan> dwcook: Probably haha
21:39:21 <hunt> not yet
21:39:26 <hunt> so why does it exist then?
21:39:28 <athan> dwcook: I don't even know how to measure anymore lol
21:39:37 <athan> it's getting resolved
21:39:39 <athan> so like
21:39:43 <athan> fmap = <$>
21:39:55 <athan> should be resolved by ghc 7.8 or 7.10
21:40:13 <dwcook> athan, hunt, that's related to fmap versus map, not mapM_ versus map
21:40:21 <hunt> oh wait, so theyre dropping regular map entirely? its just fmap now?
21:40:22 <dwcook> @type mapM_
21:40:23 <lambdabot> Monad m => (a -> m b) -> [a] -> m ()
21:40:26 <dwcook> @type map
21:40:27 <lambdabot> (a -> b) -> [a] -> [b]
21:40:38 <hunt> dwcook: why do both have to exist
21:40:42 <dwcook> Well let's look at mapM for instance
21:40:44 <dwcook> @type mapM
21:40:44 <lambdabot> Monad m => (a -> m b) -> [a] -> m [b]
21:40:46 <athan> hunt: No, I'm trying to explain that the action is one and the same
21:40:54 <athan> hunt: because monads are functors
21:41:02 <dwcook> If you set m ~ Identity, then mapM is, essentially, map
21:41:06 <athan> er
21:41:08 <athan> oh
21:41:09 <athan> whoops
21:41:11 <athan> my bad
21:41:15 <dwcook> But map exists for convenience since you don't want to have to runIdentity everywhere
21:41:25 <dwcook> and mapM exists for generality, since it applies to non-Identity monads
21:41:26 <athan> hmm
21:42:27 <dwcook> mapM_ and map don't really compare well. It'd be silly to use m ~ Identity with mapM_
21:42:33 <athan> hmm
21:42:34 <athan> man
21:42:36 <zerokarmaleft> hunt: the underscore variants throw away the results, as you can see by comparing the result type of mapM and mapM_
21:42:49 <dwcook> > runIdentity $ (+1) (Identity [1, 2, 3])
21:42:50 <lambdabot>  No instance for (GHC.Show.Show t0)
21:42:51 <lambdabot>    arising from a use of `M679040038326939117623969.show_M6790400383269391176...
21:42:51 <lambdabot>  The type variable `t0' is ambiguous
21:42:51 <lambdabot>  Possible fix: add a type signature that fixes these type variable(s)
21:42:51 <lambdabot>  Note: there are several potential instances:
21:42:56 <dwcook> > runIdentity $ (+1) (Identity [1, 2, 3 :: Integer])
21:42:58 <lambdabot>  No instance for (GHC.Num.Num
21:42:58 <lambdabot>                     (Data.Functor.Identity.Identity [GHC.Integer.Type.Integer]))
21:42:58 <lambdabot>    arising from a use of `GHC.Num.+'
21:42:58 <lambdabot>  Possible fix:
21:43:00 <lambdabot>    add an instance declaration for
21:43:06 <dwcook> Erm, I'm tired :P
21:43:17 <dwcook> Oh woops
21:43:22 <dwcook> > runIdentity $ mapM_ (+1) (Identity [1, 2, 3 :: Integer])
21:43:23 <lambdabot>  Couldn't match expected type `[Data.Functor.Identity.Identity b0]'
21:43:23 <lambdabot>              with actual type `Data.Functor.Identity.Identity
21:43:23 <lambdabot>                                  [GHC.Integer.Type.Integer]'
21:43:32 <shachaf> Possible fix: Try your demonstrations in /msg before trying them in-channel.
21:43:40 <dwcook> shachaf, sorry
21:44:13 <hunt> lol dwcook
21:44:43 <hunt> :info runIdentity
21:44:48 <hunt> :t runIdentity
21:44:49 <lambdabot> Identity a -> a
21:44:59 <hunt> :k Identity
21:45:00 <lambdabot> * -> *
21:45:09 <hunt> > runIdentity 2
21:45:10 <lambdabot>  No instance for (GHC.Show.Show a0)
21:45:10 <lambdabot>    arising from a use of `M681185080982814522424074.show_M6811850809828145224...
21:45:10 <lambdabot>  The type variable `a0' is ambiguous
21:45:10 <lambdabot>  Possible fix: add a type signature that fixes these type variable(s)
21:45:11 <lambdabot>  Note: there are several potential instances:
21:45:17 <hunt> > runIdentity 'a'
21:45:18 <lambdabot>  Couldn't match expected type `Data.Functor.Identity.Identity a0'
21:45:19 <lambdabot>              with actual type `GHC.Types.Char'
21:45:23 <shachaf> This possible fix goes for everybody.
21:45:32 <dwcook> > runIdentity $ mapM_ (return . (+1)) [1, 2, 3]
21:45:33 <lambdabot>  ()
21:45:42 <dwcook> ^ That is what I meant to demonstrate. mapM_ for Identity is silly
21:46:11 <ion> Seems like a perfectly fine way to generate a () to me.
21:46:35 <Fuuzetsu> yep
21:51:22 * hackagebot propellor 0.1.1 - property-based host configuration management in haskell  http://hackage.haskell.org/package/propellor-0.1.1 (JoeyHess)
21:51:58 <athan> you can't partially apply types, huh
21:52:00 <athan> so like
21:52:16 <athan> if you had a type constructor expecting (*-> *) -> *
21:52:28 <dwcook> athan, sure you can. Just "aliases" made with the "type" declaration must have all their parameters applied.
21:52:29 <athan> you couldn't fudge the first arg
21:52:36 <athan> like
21:53:14 <athan> Either a
21:53:16 <athan> er
21:53:19 <athan> Ether Int
21:53:21 <athan> could you?
21:53:23 <athan> crap
21:53:24 <athan> haha
21:53:40 <athan> I was trying to nest Maybe's, but that didn't work
21:53:49 <athan> at least, I don't think it would.. would it?
21:54:24 <athan> Could you supply (Maybe List) as an arg for a type of kind (* -> *) -> *?
21:54:39 <dwcook> You just have to make sure the kinds come out correct
21:54:43 <athan> er like
21:54:51 <dwcook> No, since Maybe List, for the standard definition of Maybe, is not well-kinded.
21:54:52 <athan> (\x Maybe List x)
21:55:03 <athan> well-kinded?
21:55:12 <dwcook> @kind Maybe
21:55:13 <lambdabot> * -> *
21:55:15 <dwcook> @kind []
21:55:16 <lambdabot> * -> *
21:55:17 <athan> oh!!!
21:55:23 <athan> holy toleto
21:55:29 <dwcook> * does not unify with * -> *
21:55:31 <athan> wow
21:55:32 <athan> okay
21:55:38 <athan> so those aren't polymorphic
21:55:45 <athan> (has no idea what the word means now)
21:56:07 <Welkin> poly = many
21:56:10 <Welkin> morph = form
21:56:13 <dwcook> * refers specifically to concrete types. You can have kind variables (k is often written) that stand for "any kind".
21:56:28 <athan> ahhhhhh
21:56:32 <athan> see that's what I was wondering
21:56:36 <athan> so * is like
21:56:41 <athan> a common, universal metric
21:57:33 <dwcook> athan, I don't know what you mean by that.
21:57:46 <athan> dwcook: Me neither
21:57:46 <athan> lol
21:58:01 <Sgeo_> Is there anything like Scotty but... more Haskelly?
21:58:10 <Sgeo_> Scotty just seems so... in love with runtime errors
21:58:21 <hunt> is there a way to return an ADT with one field changed to a value
21:58:43 <dwcook> hunt, yourValue { yourField = newFieldValue }
21:59:00 <hunt> and all the other fields will stay the same
21:59:03 <dwcook> Correct.
21:59:07 <hunt> cool thanks
21:59:56 <athan> hmm
22:00:16 <athan> so kind checking makes sure that data types are well structured, while type checking makes sure that data is well structured
22:00:27 <hunt> if i export an object notation ADT to i have to export the functions for ech of the fields as well?
22:00:46 <dwcook> athan, something like that.
22:01:03 <dwcook> hunt, you can export as many or as few fields as you like.
22:01:18 <dwcook> hunt, I'm not sure what you mean by "object notation" though.
22:01:25 <hunt> { adsa : asd }
22:01:31 <hunt> or whatever the notation is
22:01:42 <hunt> lyah calls its record notation i think
22:02:05 <dwcook> So you're asking whether you can constructor a value using record notation regardless of whether all its fields are exported?
22:02:09 <dwcook> construct*
22:02:32 <dwcook> I don't know off the top of my head, but why not try it and see?
22:02:35 <vermeille> what is the cost of function composition?
22:02:37 <hunt> alrihgt
22:02:46 <vermeille> what does the compiler/runtime under the hood?
22:02:56 <vermeille> +do
22:03:00 <hunt> vermeille: i dont think composition itself has a cost
22:03:29 <shachaf> Compilers and runtimes are not cars, and do not typically have hoods.
22:03:42 <hunt> burn
22:03:43 <vermeille> Hum? how can that work so?
22:03:43 <shachaf> What sort of answer are you hoping for for that question?
22:04:21 <hunt> vermeille: the price is in actual computations done by the cuntions, compositions is just a style of programming, which is reduced to raw instructions eventually
22:04:31 <hunt> functions*
22:04:39 <vermeille> "The compiler constructs at runtime a kind of object grouping a function pointer and thunk to argument that have already been partially applied etc etc"
22:05:15 <hunt> vermeille: i dont know much about that, besides what thunks are. only very basic knowledge though fmor me
22:05:17 <dwcook> hunt, it looks like the answer to the question I believed you were asking is no.
22:05:19 <shachaf> OK. The answer is "it depends on a lot of things; look at the generated code in your particular case".
22:05:36 <shachaf> (.) will usually be inlined.
22:05:45 <hunt> dwcook: alright, it was more of a do i actually need to export the fields or will haskell do it for me type o thig, but that was interesting as well
22:06:04 <shachaf> But the thing you're talking about can exist.
22:06:12 <hunt> shachaf: how do you look at the generated code
22:06:30 <dwcook> hunt, yes, you must explicitly say that you are exporting the fields, however, you can use the .. shorthand to mean to export all fields. e.g., module Foo (MyData(..)) where …
22:06:31 <shachaf> But unless you've already gotten an idea of how Haskell code is compiled, it's probably pretty different from what you expect.
22:07:21 <hunt> dwcook: brilliatn, thanks!
22:07:56 <dwcook> hunt, .. will also export all constructors, by the way
22:08:25 <vermeille> shachaf: okay, I'll just assume there is some black magic inside until I'll need to look at the generated assembly code
22:08:43 <hunt> what should i name a package of data that i can render
22:08:50 <hunt> its a datatype
22:09:14 <shachaf> There are many layers of generated code between the original Haskell and the assembly.
22:09:47 <shachaf> If you want a general idea of how GHC compiles Haskell code, you could read the STG paper:
22:09:51 <shachaf> @where stg
22:09:51 <lambdabot> http://citeseer.ist.psu.edu/viewdoc/summary?doi=10.1.1.53.3729
22:11:24 * hackagebot propellor 0.1.2 - property-based host configuration management in haskell  http://hackage.haskell.org/package/propellor-0.1.2 (JoeyHess)
22:11:57 <Cale> It's easier to think in terms of expressions or at worst expression graphs than it is to worry about the really low-level details about thunks.
22:12:04 <Cale> (I think(
22:12:06 <Cale> )
22:12:22 <shachaf> I agree.
22:12:24 <hunt> what is record notation
22:12:31 <hunt> {field: type} ?
22:12:46 <shachaf> It's sufficient for talking about "cost", up to constant factors.
22:13:14 <vermeille> What are the typical use cases of Parsec VS Happy? How can they compete? Parsec is LL while Happy is LR so happy looks more powerful
22:13:34 <Cale> hunt: data Employee = Empl { name :: String, salary :: Integer }
22:13:53 <hunt> ahhhh im so silly
22:13:59 <Cale> hunt: Empl { name = "Bob", salary = 100000 }
22:14:08 <Iceland_jack> Cale: ‘Integer’ I wish! :)
22:14:16 <Iceland_jack> Word8 for me thanks
22:14:19 <zenkeku> http://lpaste.net/102038 -- Could I get a bit of help with this? I don't really understand the issue.
22:14:24 <vermeille> shachaf: thanks for the link!
22:14:45 <Cale> and you can do things like:  raise n empl = empl { salary = salary empl + n }
22:14:59 <Cale> (and if that seems ugly, then look into using lenses instead)
22:15:48 <Cale> (that produces a new record with the same fields as empl had, but with salary replaced)
22:17:53 <Iceland_jack> This also works with -XNamedFieldPuns
22:17:53 <Iceland_jack>     raise n employee@Empl{salary} = employee { salary = salary + 1 }
22:18:06 <zipper> Cale: FEAR THE LENS!
22:18:22 <zipper> I kid, don't fear the lens.
22:18:49 <athan> If Maybe was a comonad, wouldn't extract be a possibly-failing function, much like `head []`?
22:19:00 <johnw> and that's why it's not
22:19:04 <athan> they're so awesome
22:19:57 <athan> johnw: so the types have to be product types?
22:20:02 <athan> not sum types?
22:20:32 <johnw> well, that would be one restriction
22:20:36 <athan> i mean, unless the sum type always has an instance of the type variable
22:20:39 <athan> like
22:21:08 <athan> Double a = One a | Two a
22:21:12 <athan> or something
22:21:15 <athan> so like
22:21:16 <xpika> what is the flag --extra-lib-dirs seperated by?
22:21:16 <johnw> that's a sum of products, which can be algebraically factored into (a, One | Two)
22:21:32 <athan> if you had a comonad instance for (Foo a)
22:21:34 <athan> where Foo
22:21:35 <athan> is
22:21:46 <athan> data Foo a b = One a b | Two b
22:21:49 <athan> that would work
22:21:50 <athan> right?
22:22:02 <johnw> again, that's the same thing as (b, One a | Two)
22:22:06 <athan> algebraically factored?
22:22:11 <athan> that's aewsome
22:22:13 <johnw> there is an algebra of types
22:22:16 <athan> I knew it
22:22:22 <athan> i knew there was sense to this!\
22:22:24 <athan> hahaha
22:22:25 <johnw> types in Haskell form the algebraic structure of a seminearring
22:22:27 <athan> that's awesome
22:22:36 <athan> o.O
22:22:41 <athan> seminearring?
22:22:59 <athan> duplicates of sum types can be factored into a tuple
22:23:12 <athan> so, depending on the context
22:23:23 <athan> and you can refactor it
22:23:25 <athan> holy crap
22:23:27 <athan> that's amazing
22:23:28 <kazagistar> I can find on wikipedia a near-semiring...
22:23:37 <johnw> in short, seminearning means that we have products and sums, and a monoid unit for the sum
22:23:40 <johnw> http://en.wikipedia.org/wiki/Near-semiring
22:23:57 <athan> makes sense
22:24:10 <athan> hmm
22:24:12 <vermeille> athan: you can represent your types with algebraic formulas, then derive them like a mathematical function... and tadaaa, you have the zipper
22:24:24 <johnw> so, you can rewrite One a | Two a as: a * 1 + a * 1, which equals a * (1 + )
22:24:28 <johnw> a * (1 + 1)
22:24:43 <shachaf> Well. You have a definition of a type isomorphic to a zipper, roughly.
22:24:44 <athan> hmm
22:24:53 <athan> so the constructors
22:24:56 <shachaf> A big part of the point of zippers is to be efficient, and there's no guarantee of that, of course.
22:25:05 <athan> or polymorphic terms
22:25:18 <athan> man
22:25:18 <athan> wow
22:25:27 <johnw> oh, it get trippier
22:25:35 <athan> hahaha
22:25:43 <johnw> you can take the first deritative of a Haskell type :)  and it means something very cool!
22:25:53 <johnw> it links to the idea of zippers, mentioned above
22:25:54 <athan> what does it mean?
22:25:59 <athan> o.O
22:26:08 <athan> yeah...
22:26:10 <athan> what's a zipper?
22:26:15 <athan> exactly?
22:26:29 <vermeille> LYAH, ctrl+f zipper :)
22:26:36 <vermeille> that's a notion hard to explain on IRC
22:26:38 <athan> er
22:26:39 <athan> okay
22:26:40 <athan> yeah
22:26:42 <athan> I get tha
22:26:43 <athan> t
22:26:47 <zerokarmaleft> athan: http://chris-taylor.github.io/blog/2013/02/10/the-algebra-of-algebraic-data-types/
22:27:12 <athan> Thank you!
22:28:07 <athan> this is wizardry I swear haha
22:29:46 <johnw> the derivative of a*a (aka, (a,a)) is 2*a, which is to say, (Bool, a), where the Bool is stating "which half" of the original tuple it preserves.  You make a zipper out of it by creating a type which provides what's now missing: TupleZipper = TupleZipper a (Bool, a).  Given that, I can reconstitute the original tuple
22:31:06 <johnw> so the zipper reduces the original structure into a value, and the "rest of the structure except for that value".  This allows you to mutate that value, and then reconstitute another structure of the same shape around it, so to speak.  I'm not sure if that makes much sense, though; the Internet has much to say abuot it, and there are some great papers on it
22:32:34 <vermeille> zippers seems to be a little old fashion now that lenses exist, am I wrong?
22:32:52 <johnw> there is a strong connection between zippers and lenses, by way of comonads
22:32:55 <shachaf> They are mostly orthogonal concepts.
22:34:32 <johnw> I can't help but reference Uustalu here: http://cs.ioc.ee/~tarmo/tsem05/uustalu0812-slides.pdf
22:36:25 <kazagistar> that link is pretty cool, zerokarmaleft, lurking pays off for me once again
22:36:44 <vermeille> yep, amazing link!
22:37:01 <johnw> there's a video presentation that goes along with that link tooa
22:37:34 <johnw> see also http://stackoverflow.com/questions/9190352/abusing-the-algebra-of-algebraic-data-types-why-does-this-work
22:37:43 <edwardk> vermeille: we have a zippers package built on top of lenses
22:38:03 <johnw> here's the video link: https://www.youtube.com/watch?v=YScIPA8RbVE
22:38:18 <zerokarmaleft> kazagistar: np...it's an engaging talk as well
22:40:48 <kazagistar> hmm... from the zipper slides: "Ever had to represent trees with a focus of attention and refocussing operations?"... from my very brief understanding, lens does that?
22:41:13 <johnw> kazagistar: a zipper will keep the tree torn apart across operations
22:41:13 <dolio> No, it does not.
22:41:35 <johnw> and it lets you shift around the focus
22:45:43 <johnw> kazagistar: see http://tangledw3b.wordpress.com/2013/01/18/zipper-comonad/
22:48:18 <vermeille> It's so reassuring when you write in Haskell to know that you are protected by maths :D
22:49:45 <Sgeo_> How does GHC.Generics encode function types?
22:49:46 <Iceland_jack> vermeille: Protected by maths?
22:50:10 <Welkin> you are not protected from anything unless your hardware is radiation hardened and properly engineered
22:50:28 <Sgeo_> Does it?
22:50:30 <vermeille> True, but that's not your code's fault :D
22:50:34 <Welkin> nothing can stop a solar flare from corrupting your data
22:50:35 <johnw> Iceland_jack: I think he means that there's some sound theory behind many of Haskell's decisions
22:50:55 <Enigmagic> Sgeo_: it doesn't
22:51:21 <vermeille> johnw: if not all.
22:52:12 <johnw> I wonder if ImpredicativeTypes has a theory somewhere I could read...
22:53:17 <Iceland_jack> johnw: I'm vary of that kind of attitude though
22:53:52 <Iceland_jack> It's not like your program gets correct only by virtue of using ADTs or what ever the topic may be :)
22:54:07 <vermeille> I don't understand what comonads are for
22:54:29 <johnw> vermeille: a good practical example is pixel dithering
22:54:34 <hunt> how can i derive Eq for data Test m a = Test {f1 :: m a}
22:54:40 <dmj`> johnw!
22:54:53 <hunt> i know what i plan on using m a as is Eq
22:55:04 <Iceland_jack> Sgeo_: https://en.wikipedia.org/wiki/Generic_programming#Generic_Haskell it seems like this has something relevant
22:55:09 <Iceland_jack>    type Eq {[ k -> l ]} t1 t2 = forall u1 u2. Eq {[ k ]} u1 u2 -> Eq {[ l ]} (t1 u1) (t2 u2)
22:55:11 <Sgeo_> ty
22:55:15 <ion> hunt: Add “deriving (Eq)”
22:55:17 <Iceland_jack> hm, then again maybe not
22:55:31 <hunt> ion: but theres no instance for Eq m a
22:55:56 <johnw> a comonad is perfect when computing the next value of a structure requires mutating each element of that structure with knowledge of the whole at each point
22:56:08 <mgsloan> johnw: I believe this is the paper that's associated with
22:56:08 <mgsloan> ImpredicativeTypes: http://research.microsoft.com/en-us/um/people/simonpj/papers/boxy/
22:56:17 <johnw> mgsloan: thanks!
22:56:25 <johnw> dmj`!
22:56:36 <hunt> oh sorry
22:56:37 <hunt> wait
22:56:42 <ion> hunt: For any m a for which Eq (m a) exists, you can have Eq (Test m a). That’s what deriving (Eq) will do.
22:56:49 <mgsloan> johnw: welcome!
22:56:49 <hunt> its m Float
22:56:52 <hunt> ion:
22:57:05 <johnw> ah, i've got that in my reading queue; it's just way at the back :)
22:57:09 <shachaf> The first question with ImpredicativeTypes is "why is it hard?", since it seems like a thing that should obviously exist and doesn't even need its own name.
22:57:19 <zenkeku> Is there any type of member that can be made into a list that in themselves cannot be compared using ==?
22:57:32 <hunt> i want this:  data Test m a = Test {f1 :: m Float, f2 :: a} deriving (Show,Eq)
22:57:39 <hunt> but it errors
22:57:47 <vermeille> johnw: I don't get it. Anyway, it's 8 AM, I should go to sleep, the sun is rising
22:57:50 <shachaf> zenkeku: Functions, for instance.
22:57:52 <shachaf> mgsloan: Coming to BayHac this year?
22:58:14 <zenkeku> shachaf: Functions can be made up in a list? TIL
22:58:36 <Iceland_jack> zenkeku: You can also easily define your own datatype and not derive Eq
22:58:46 <johnw> vermeille: in the pixel dithering example, you make a new picture by taking each pixel from the original image, and blending it with the pixels around it.  I think there's a more in-depth description of how that's a Comonad on the Web
22:58:57 <zenkeku> I was just wondering why GHCi was yelling at me for not having Eq a => [a] in the type signature of a function that compared elements of that list.
22:59:12 <johnw> or perhaps I should say, how such an operation is comonadic in nature
22:59:19 <hunt> is there a reason i cant derive Eq for m Float
22:59:24 <shachaf> zenkeku: Any value can. Functions are values.
22:59:26 <hunt> in  data Test m a = Test {f1 :: m Float, f2 :: a} deriving (Show,Eq)
22:59:48 <zenkeku> shachaf: Then do you have an idea why GHCi would require Eq a => [a]?
23:00:06 <hunt> ?
23:00:07 <Iceland_jack> hunt: It's the ‘m’ part
23:00:33 <hunt> Iceland_jack how do i get around this, m is kind * -> * and i need to include it in the ADt
23:01:31 <dmj`> hunt: what types that you know have the kind (* -> *) ?
23:01:46 <mgsloan> shachaf: Hmm, possibly, I'll keep the possibility in mind!
23:01:53 <hunt> dmj` well its a class actually my mistake
23:03:08 <hunt> dmj` the class has kind (*-> *) -> Constraint
23:03:23 <zenkeku> shachaf: http://lpaste.net/102038 The function in question, in case you are curious.
23:03:37 <hunt> and m is an instance of the class
23:04:18 <shachaf> zenkeku: And what's the question?
23:04:48 <zenkeku> 23:58 < zenkeku> shachaf: Then do you have an idea why GHCi would require Eq a => [a]?
23:04:54 <hunt> dmj` it doesnt make sense to me that i shouldnt be able to derive Eq for m Float
23:05:07 <shachaf> (Your function has several distasteful parts and at least one bug.)
23:05:18 <shachaf> I don't know what that question means.
23:05:21 <zenkeku> Please elaborate.
23:05:26 <shachaf> (The bug is that it doesn't work for odd-length lists.)
23:05:45 <zenkeku> In this case it would never take an odd length list.
23:05:48 <shachaf> (Some odd-length lists.)
23:06:16 <zenkeku> The function I am using to produce a palindrome produces a list that always has an even length.
23:06:48 <shachaf> But I still don't understand your question.
23:07:50 <zenkeku> When the type signature was isPalindrome :: [a] -> Bool it produced an error relating to Eq. With the Eq => a it no longer produced an error. My question was is there any type that can form a list that cannot be compared? Excluding user-made types.
23:07:53 <hunt> so no one knows what to do with this data type?  data Test m a = Test {f1 :: m Float, f2 :: a} deriving (Show,Eq) :'(
23:08:07 <Tijuanense> can somebody explain this compile error to me?
23:08:08 <Tijuanense> http://i.imgur.com/eizzhMx.jpg
23:08:18 <shachaf> Please write complete signatures. :-(
23:08:23 --- mode: ChanServ set +o Cale
23:08:29 --- mode: Cale set +b *!*@knows.you.stole-my.pw
23:08:29 --- kick: Tijuanense was kicked by Cale (Tijuanense)
23:08:33 <zenkeku> Note: Tijuanense Just posted pornography.
23:08:38 <shachaf> "Eq a => [a]" and "Eq => a" both don't make sense.
23:08:53 <Cale> He's been here before doing the same thing
23:09:07 <zenkeku> shachaf: My apologies. I'll post a paste with the different type signatures.
23:09:08 <shachaf> zenkeku: You need an "Eq a =>" constraint because you're using (==) on elements of the list.
23:09:15 <shachaf> I understand the question now.
23:09:19 <dmj`> zenkeku: thanks for the heads up
23:09:21 <shachaf> No need to paste.
23:09:25 <zenkeku> dmj`: No problem.
23:09:28 <zenkeku> shachaf: Okay.
23:09:34 --- mode: Cale set -o Cale
23:10:27 <zenkeku> shachaf: Do I always need "Eq a =>" whenever I use (==)?
23:10:29 <hunt> guys i mreally dying out here, is it impossible to get that data type?
23:11:06 <shachaf> Sometimes it's "Eq b =>"
23:11:15 <shachaf> Or sometimes it's a concrete type, like Int.
23:11:23 <shachaf> But you need Eq to use (==). That's how (==) works.
23:11:25 <shachaf> :t (==)
23:11:26 <lambdabot> Eq a => a -> a -> Bool
23:11:27 <shachaf> No magic.
23:11:27 <dmj`> hunt: Show and Eq have the kinds of * -> Constraint
23:11:43 <zenkeku> Ah, okay. Thanks for the info.
23:12:04 <shachaf> dmj`: ?
23:12:21 <hunt> dmj` ok, but its fully applied as m Float, just like it would be as m a
23:12:24 <hunt> right?
23:12:32 <zenkeku> Signing off for now, thanks for the help, everyone.
23:12:33 <dmj`> data Test a = Test { f1 :: Float, f2 :: a } deriving (Show, Eq) can derive since Float and a fully apply them
23:13:14 <hunt> dmj` isnt m Floar also applied?
23:14:34 <dmj`> hunt: No
23:14:34 <shachaf> Oh, I see now.
23:15:04 <dmj`> hunt: m isn't specified, it needs to be concrete
23:15:37 <hunt> dmj` well i want m to be a member of the Matrix class and Eq
23:15:50 <hunt> dmj` but i dont want to specify which instances
23:19:35 <fragamus> look at this line of code:           v11 = 2 * x c2 - 2 * x c1
23:19:58 <fragamus> it seems like there are some missing operators
23:20:03 <fragamus> WTF
23:20:12 <copumpkin> unless x is a function?
23:20:20 <supki> hunt: use standalone deriving if you want to derive something nontrivial
23:20:35 <Zekka> Looks to me like x is a function alright
23:20:37 <hunt> supki: how is that done
23:20:59 <supki> hunt:  deriving instance (Eq (m Float), Eq a) => Eq (Test m a)
23:21:00 <Zekka> it's a little clearer as 2 * (x c2 - x c1) if * distributes over - here.
23:21:11 <supki> hunt: you'll need -XStandaloneDeriving
23:21:22 <supki> and -XFlexibleInstances, I think
23:21:32 * hackagebot HTTP 4000.2.12 - A library for client-side HTTP  http://hackage.haskell.org/package/HTTP-4000.2.12 (GaneshSittampalam)
23:21:45 <supki> hunt: that deriving thing should be on separate line
23:21:46 <hunt> supki: i dont get this can be impossible in vanilla haskell
23:22:10 <hunt> supki: it seems like a big part of being implementation transparent
23:22:28 <hunt> should this data type maybe be a class?
23:23:03 <fragamus> oh yeah x is an accessor method
23:23:25 <fragamus> this is where that code came from:
23:23:26 <fragamus> -- https://github.com/acmeism/RosettaCodeData/blob/master/Task/Problem-of-Apollonius/Haskell/problem-of-apollonius.hs
23:24:02 <awestroke> can I do something like ((+1),(+2)) <*> (3, 4)? Are there biapplicatives?
23:25:02 <supki> hunt: well, the instance you try to derive isn't vanilla haskell, so it makes sense you can't do it
23:25:03 <dmj`> > ((+1) *** (+2)) $ (3, 4)
23:25:04 <lambdabot>  (4,6)
23:25:18 <awestroke> :t (***)
23:25:19 <lambdabot> Arrow a => a b c -> a b' c' -> a (b, b') (c, c')
23:25:23 <Zekka> dmj` - Beat me to it (I was trying to remember if it was *** or &&&)
23:25:26 <athan> hmm
23:25:27 <dmj`> > over both (+1) (1,2)
23:25:29 <lambdabot>  (2,3)
23:25:37 <athan> is the derivative of () Void?
23:25:44 <awestroke> :t over
23:25:56 <athan> and the derivative of a ()?
23:26:18 <athan> :t Data.Lens.over
23:26:24 <athan> > :t Data.Lens.over
23:26:28 <supki> hunt: and in general, I think, inferring constraints you have in mind is hard
23:26:29 <athan> o.O
23:26:34 <awestroke> you killed it
23:26:40 <athan> hahaha
23:26:44 <athan> :t 1
23:26:55 <awestroke> @type over
23:27:01 <solirc> Should stringification of CPP macros work in Haskell source files
23:27:05 <athan> cashed
23:27:05 <Zekka> That's over from Control.Lens, not Data.Lens, right?
23:27:15 <dmj`> yes
23:27:21 <athan> derp
23:27:23 <athan> you're right
23:27:26 <Zekka> Because my installation of Control.Lens says over :: Profunctor p => Setting p s t a b -> p a b -> s -> t
23:27:26 <athan> I thought I was off
23:27:35 <athan> yep
23:27:36 <Zekka> but I think there's a neater type signature in the documentation
23:27:43 <solirc> say I try: foo = #BAR
23:27:43 <athan> good ol' pabst
23:27:46 <Zekka> (er, neater in the sense that 'I'm not a category theorist what is that')
23:27:47 <edwardk> p = (->) typically
23:27:53 <solirc> but it does not work
23:27:57 <awestroke> time to learn arrows
23:28:10 <Zekka> edwardk - Does Setting (->) s t a b look like Lens s t a b?
23:28:14 <johnw> why does everyone want to learn arrows?
23:28:20 <johnw> there must be some corner of the Web I'm not stepping into
23:28:23 <lambdabot> Num a => a
23:28:23 <lambdabot> Couldn't find qualified module.
23:28:23 <lambdabot> Profunctor p => Setting p s t a b -> p a b -> s -> t
23:28:23 <lambdabot> Profunctor p => Setting p s t a b -> p a b -> s -> t
23:28:23 <lambdabot>  <hint>:1:1: parse error on input `:'
23:28:26 <edwardk> Zekka: well you can pass a lens in as that.
23:28:48 <edwardk> Setting (->) s t a b = (a -> Identity b) -> s -> Identity t
23:29:32 <Zekka> hold up, looking up the Lens docs
23:29:47 <awestroke> johnw: because it seems people use them, so the probability of being worse off learning about them seems small
23:30:08 <johnw> awestroke: I've never used them, and don't know anyone who uses them, if that helps
23:30:13 <edwardk> awestroke: except few of us use them any more
23:30:30 <Cale> Arrow is very close to something which is actually a good idea
23:30:56 <Cale> But in its current state sort of doesn't fit the niche it's supposed to serve very well
23:31:54 <dmj`> only arrows I find useful are first, second, (&&&) and (***), but now lens can do all that stuff...
23:32:26 <edwardk> i personally prefer to use bifunctors for most of that
23:32:38 <Cale> dmj`: You probably mean that the only Arrow you find useful is (->)
23:33:06 <awestroke> is there a list of things to avoid and things to learn? if there is such a consensus
23:33:07 <Cale> (because of the way those things specialise)
23:34:22 <Cale> awestroke: Eh, it'll always depend on what sort of programming you're interested in doing. That said, I recommend Simon Marlow's new book whether you're actually all that interested in concurrency and parallelism or not. :)
23:34:48 <Cale> http://chimera.labs.oreilly.com/books/1230000000929
23:35:13 <hyuke> I am just learning Haskell (from a background in C and Python). Can someone clear something up for me real quick? http://pastebin.com/A6rjVy5H  <-- in the condition (x:xs), there is an expression that follows: min x (mnmInt xs). In this context, is 'x' the first element of the list and 'xs' is the second element in the list?
23:35:36 <Cale> xs is the rest of the list
23:35:49 <dmj`> Cale: I liked your reddit comment about visualizing thunks w/ HOPS (i think that was you), you say HOPS isn't open source though?
23:35:52 <Zekka> x:xs corresponds to uses of the : operator outside of pattern matching
23:36:03 <Zekka> You know how x:xs conses x to xs? In a pattern, it unconses
23:36:24 <hyuke> Cale: min cannot take a list though can it? I was thinking the list was handled in the recursion process
23:36:33 <Cale> dmj`: Well, I don't think Dr. Kahl is opposed to releasing it, but iirc he was working on a new version since the old one was hard to build, and I don't know what happened.
23:36:49 <hyuke> Zekka: I don't quite follow.
23:37:00 <Cale> dmj`: He's kind of bad at releasing the cool stuff that he does. He also has a really cool library for relational algebra.
23:37:05 <hyuke> Zekka: what do you mean be conses?
23:37:19 <Zekka> hyuke - 1:[2, 3, 4] == [1, 2, 3, 4]
23:37:25 <hyuke> oh!
23:37:25 <hyuke> yes
23:37:31 <Zekka> uncons [1, 2, 3, 4] = Just (1, [2, 3, 4])
23:37:36 <Cale> > 1 : [2,3,4]
23:37:37 <lambdabot>  [1,2,3,4]
23:37:58 <Cale> > let (x:xs) = [1,2,3,4] in (x,xs)
23:38:00 <lambdabot>  (1,[2,3,4])
23:38:22 <hyuke> oh, I see, so the recursion is sending the remainder of the list
23:39:13 <hyuke> thanks guys :D
23:44:31 <dmj`> Cale: Was HOPS written in Haskell? Hard to tell by reading: http://www.cas.mcmaster.ca/~kahl/HOPS/#intro
23:44:57 <fragamus> wtf:
23:45:02 <fragamus> polarAreaUnderHyperbolicSection :: Double -> Double -> Double -> Double -> Double
23:45:02 <fragamus> polarAreaUnderHyperbolicSection lowerBound upperBound p e = (p*(atanh((sqrt((-1.0) + (e^2.0))*tan(lowerBound/2.0))/((-1.0) + e)) - atanh((sqrt((-1.0) + e^2.0) tan(upperBound/2.0))/((-1.0) + e))))/sqrt((-1.0) + e^2.0)
23:45:03 <Cale> dmj`: OCaml
23:45:14 <fragamus> I am getting weird errors
23:45:29 <Cale> dmj`: and the UI uses some Tk binding
23:45:30 <fragamus> compile errors
23:45:35 <awestroke> fragamus: split it over more lines
23:45:43 <fragamus> ill paste
23:49:34 <kazagistar> fragamus: that code reads like a formula copied straight out of a paper or something to me
23:49:44 <fragamus> lol
23:49:53 <fragamus> I derived it in Mathematica
23:54:09 <kazagistar> fragamus: I actually don't know how that is going to work since you are using i, but not using complex numbers?
23:55:33 <fragamus> e>0
23:56:05 <kazagistar> it does not matter, all the operations are a -> a or a -> a -> a, so they will all be over numbers
23:56:16 <kazagistar> right?
23:56:24 <kazagistar> *I mean doubles
23:57:36 <kazagistar> it uses type inference to figure out which implementation of sqrt you want, finds that since it's output is Double then clearly you must want that one, and gives you NaN for each (sqrt -1)
23:57:58 <enthropy> > sqrt((-1.0) + e^2.0)
23:57:59 <lambdabot>  No instance for (GHC.Real.Integral b0)
23:57:59 <lambdabot>    arising from a use of `GHC.Real.^'
23:57:59 <lambdabot>  The type variable `b0' is ambiguous
23:57:59 <lambdabot>  Possible fix: add a type signature that fixes these type variable(s)
23:57:59 <lambdabot>  Note: there are several potential instances:
23:58:40 <enthropy> could be positive depending on 'e'
23:59:41 <fragamus> e>0
23:59:41 <enthropy> the compile error is probably a missing *,+,- before the tan(upperBound/2.0))
23:59:57 <kazagistar> oh derp, I misread the parens... carry on <_<
