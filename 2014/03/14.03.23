00:01:00 <jle`> > let k = return 6 in k 7
00:01:02 <lambdabot>  6
00:01:32 <jle`> is it just me or does that totally make sense
00:01:39 <flebron> dmwit: What would you suggest?
00:02:39 <flebron> jle`: Where m = (->) r, return = const.
00:03:48 <dmwit> flebron: What does the grammar, which you definitely wrote down on a piece of paper before-hand, say to do?
00:04:19 <flebron> My grammar (which I wrote on a .txt :p) uses expr -> expr expr.
00:04:22 <johannesbodannes> does anyone know of an HTML rendering library that uses haskell string over say... Text or ByteString out of the box? i'm using a compiler with bad support for those types
00:04:39 <flebron> But I'm not sure how Parsec will handle the associativity in that case, that's why I was doing the many1 and foldring myself.
00:06:02 <dmwit> Your grammar is probably ambiguous.
00:06:52 <dmwit> e.g. \x.x\x.x can probably parse as (\x.x)(\x.x) or \x.(x\x.x), if the code you posted is an accurate reflection of the written grammar up to parseTerm being not-quite-right.
00:07:34 <flebron> Right. I'd like to have a way to say \x.{be greedy here}.
00:07:59 <flebron> But I think that's a separate matter, and perhaps I can use "eof" in Parsec for that.
00:08:05 * hackagebot tls 1.2.4 - TLS/SSL protocol native implementation (Server and Client)  http://hackage.haskell.org/package/tls-1.2.4 (VincentHanquez)
00:08:05 * hackagebot tls-debug 0.3.2 - Set of programs for TLS testing and debugging  http://hackage.haskell.org/package/tls-debug-0.3.2 (VincentHanquez)
00:09:05 <dmwit> Anyway, since you only have one other alternative in parseExpr, why not parseExpr = many1 (variables <*> parseExpr)?
00:09:11 <dmwit> Plus the appropriate fmapping, of course.
00:11:27 <jle`> flebron: yeah, exactly
00:11:35 <jle`> it makes perfect sense
00:11:47 <jle`> and is kinda neat
00:11:54 <jle`> why don't we just use return instead of const?
00:12:04 <dmwit> I suspect I'm misunderstanding something, though. What are the other productions for expr? Obviously expr -> expr expr isn't the only noe.
00:12:37 <dmwit> jle`: All the usual arguments about map vs. fmap, (++) vs mappend, and (>>>) vs (.) apply.
00:12:42 <spacekitteh> If I have a function of (Vector p q f) -> (Vector p q g) does that make sense as an arrow?
00:12:58 <jle`> dmwit: ah yeah.
00:13:01 * hackagebot tls 1.2.5 - TLS/SSL protocol native implementation (Server and Client)  http://hackage.haskell.org/package/tls-1.2.5 (VincentHanquez)
00:13:01 <flebron> The original grammar I wrote was expr -> \lambda x. expr, expr -> (expr), expr -> expr expr
00:13:12 <jle`> spacekitteh: er, the function?
00:13:29 <spacekitteh> jle`: in this case it's an arbitrary linear operator
00:13:29 <dmwit> flebron: Then parseExpr = many1 (parseLambda <|> parseParentheses)
00:13:36 <dmwit> flebron: Plus appropriate fmappery.
00:14:05 <flebron> And then I foldr App that?
00:14:19 <jle`> i'm sorry, what sense of arrow do you mean?
00:15:00 <dmwit> Well, foldr, or foldl1, or whatever.
00:15:14 <spacekitteh> jle`: i'm trying to create a type, LinearOperator p q f g with {operator :: (Vector p q f -> Vector p q g)} and implement an instance of arrow for it
00:16:00 <jle`> ah
00:16:13 <jle`> yes, i think it does
00:16:20 <dmwit> linear operators are probably not arrows
00:16:36 <dmwit> remember, arrows have to encompass all Haskell functions, thanks to "arr"
00:16:53 <dmwit> Well. Linear operators are probably not Arrows, anyway.
00:17:12 <spacekitteh> dmwit: yeah that's what i think i'm discovering.
00:18:12 <spacekitteh> is there something equivalent where i can use notation similiar to the whole signal flow diagram thing Arrow has going on?
00:18:41 <dmwit> You can probably get a long way by writing 'arr = error "Nuh-uh, sister!"'.
00:19:00 <spacekitteh> yeah, atm i have arr=undefined
00:22:41 <spacekitteh> on a related topic
00:23:28 <spacekitteh> can i just have LinearOperator p q f with {operator :: Vector p q f -> Vector p q f} and make it a category where composition is only valid going to and from the same f?
00:23:44 <spacekitteh> or is that... is that like saying "a category without the catgory"
00:24:44 <dmwit> Perhaps you are looking for Monoid.
00:24:51 <dmwit> Which is a category with only one object.
00:25:37 <spacekitteh> yeah, thought so. i already was implementing both category and monoid with monoid as Monoid (LinearOperator p q f f)
00:26:13 <edwardk> spacekitteh: pull the 'f' to the front, then yes.
00:26:37 <spacekitteh> what do you mean?
00:26:46 <edwardk> LinearOperator f p q = .. has the right shape for Category (LinearOperator f)
00:27:02 <spacekitteh> p and q are Nats
00:27:06 <edwardk> yes
00:27:16 <edwardk> and Category is PolyKinded now. You're welcome ;)
00:27:52 <spacekitteh> but won't that allow composition of linear operators with different p's and q's?
00:28:52 <dmwit> It would require you to combine a LO f p q and a LO f q r to create an LO f p r, yes.
00:29:05 <edwardk> well, i didn't read your example correctly. I'd assumed you meant something like Linear n m = Vector n -> Vector m  so that the composition made sense.
00:29:16 <spacekitteh> yeah that won't make sense because (p,q) is the metric signature of the space
00:29:20 <edwardk> I don't know what those indices in your type mean
00:29:28 <dmwit> Whether it makes sense for your definitions or not is probably impossible to say without more information.
00:29:34 <edwardk> oh
00:29:44 <edwardk> that doesn't make sense then
00:30:02 <edwardk> then that isn't a category. =)
00:30:26 <edwardk> carry on then
00:30:34 * spacekitteh carries on thusly
00:31:02 <spacekitteh> oooh i know... i'll just make LinearOperator' p q f g; LinearOperator p q f = LinearOperator' p q f f
00:31:22 * ion strokes the beard thusly
00:31:31 <edwardk>  Monoid (LinearOperator p q f f)  may be better written as f ~ g => Monoid (LinearOperator p q f g)
00:31:38 <edwardk> that'll get better type inference
00:32:15 <spacekitteh> does ~ mean same kind or something?
00:32:25 <Iceland_jack> just means equality
00:32:26 <edwardk> 'is the same type as'
00:32:28 <spacekitteh> ah
00:32:32 <spacekitteh> hi Iceland_jack
00:32:40 <Iceland_jack> hey spacekitteh
00:32:40 <Cale> I don't understand why it's ~ and not = but probably some parsing reason
00:32:42 <edwardk> your instance requires the type checker to figure out f = g before it can match
00:33:03 <Iceland_jack> Cale: I believe it was because '=' is already used to mean so many things
00:33:11 <edwardk> the one above requires only that you figure out tht you need LinearOperator on the outside and if you need a Monoid it _tells_ you that f and g are the same.
00:33:24 <Cale> Iceland_jack: But not so much to the right of ::
00:33:27 <edwardk> that helps out a lot when the typechecker doesn't fully know the type
00:33:45 <Iceland_jack> Cale: That's right, if that really was the reason I'm not sure I agree
00:33:55 <edwardk> rather if you need a Monoid it tells you that f and g must be the same to get it
00:34:26 <spacekitteh> edwardk: ah, cool
00:36:52 <spacekitteh> GADTs to the rescue! :3
00:39:52 <spacekitteh> is there a way to make an object masquarade as a function? e.g. is it possible to implement some sort of apply function so you can do thus: flip = LinearOperator {fgsfds}; flip thisVector
00:41:46 <spacekitteh> or should i make LinearOperator some sort of newtype based on (->)
00:42:00 <tikhon> What's the preferred way to work with graphs in Haskell?
00:42:26 <tikhon> ideally, I'd like something nice to work with more than something particularly fast
00:42:34 <enthropy> a newtype won't help you drop the constructor
00:43:01 <tikhon> the fgl library looks neat, but I'm not sure if it's supported or actually a good option
00:43:16 <spacekitteh> enthropy: i don't mind about the constructor so much as being able to get nice notation for application/composition
00:43:27 <enthropy> and if you have   type LinearOperator a b c d e f = a -> b, you probably can't write all the instances you want
00:43:56 <dmwit> tikhon: I think fgl is pretty much the best thing we've got going for graphs.
00:44:10 <tikhon> dmwit: have you used it at all?
00:44:14 <dmwit> I have.
00:44:22 <tikhon> did you like it?
00:44:22 <dmwit> It's got a very complete API.
00:44:34 <dmwit> And it wasn't that cumbersome.
00:44:46 <tikhon> that sounds good
00:45:03 <tikhon> it sounds much better than manually managing an adjacency matrix or something
00:45:19 <dmwit> Yeah, I've hobbled together half a dozen data types that really wanted to be a graph.
00:45:27 <dmwit> And eventually regretted it for one reason or another. =P
00:46:07 <tikhon> trees cover like 99% of graph stuff I've ever done, so I haven't had to deal with this in Haskell before
00:46:21 <dmwit> Well, I think you'll like the philosophy that led to fgl.
00:46:23 <tikhon> and Haskell is obviously good with trees :)
00:46:39 <tikhon> I think I have their paper in my "to read" directory
00:46:40 <dmwit> Because the core idea he went with is: trees are neat because you do the pattern matching thing. How can we do that with graphs?
00:47:07 <tikhon> hah, that was actually pretty much exactly what I was hoping for when I asked the question
00:47:10 <dmwit> Answer: the patterns you can match on are a node, together with all its edges, together with the remainder of the graph.
00:47:18 <dmwit> It's just like an inductive type. Except not canonical.
00:47:29 <tikhon> hmm, that also sounds pretty similar to a zipper
00:48:03 <dmwit> Then you need a bloody lot of tricks to make that efficient. =)
00:49:09 <dmwit> I encourage you to do a quick read of the paper. It's got some beautiful ideas in it, and I think it will make it much easier to understand the types in fgl.
00:49:23 <dmwit> ...and to know where to look in the frankly enormous module hierarchy.
00:50:26 <tikhon> "Inductive Graphs and Functional Graph Algorithms"?
00:50:52 <tikhon> hmm, looking at their website, that seems to be the one alright
00:51:27 <tikhon> and, of course, my first thought is "journal formatting is weird" :)
00:51:52 <dmwit> yes
00:53:08 <edwardk> spacekitteh: yes, there is a way to get overloading as a function, sometimes anyways, don't think it works for your case easily though.
00:53:54 <spacekitteh> edwardk: hmm, how would one do that?
00:55:42 <edwardk> spacekitteh: class Foo f where foo :: whatever you want to use to construct it -> f a b; instance Foo (->) where foo = .. make me a function; data Foo a b = Foo (whatever you want to use to construct it) instance Foo MyFoo where foo = MyFoo; now you can   use 'foo x y z' assuming it took 3 parameters either as a function or as Foo.
00:56:16 <spacekitteh> oooh
00:56:28 <edwardk> spacekitteh: you need to be aware constantly about how type inference works though
00:57:03 <edwardk> :t indexed
00:57:04 <lambdabot> Indexable i p => p a b -> i -> a -> b
00:57:12 <edwardk> ^- that is the same idea as used by lens
00:58:18 <edwardk> well, at least in reverse,   class Indexable i p where indexed :: p a b -> i -> a -> b; instance Indexable i (->) where indexed = const; instance i ~ j => Indexable i (Indexed j) where indexed = Indexed
00:58:32 * spacekitteh nods
00:58:34 <spacekitteh> i think i get it
00:59:08 <edwardk> that is how lens lets you work with indexed lenses and traversals as normal ons
00:59:11 <edwardk> er normal ones
00:59:17 <bitemyapp> why doesn't this print anything: simpleHTTP (getRequest "http://localhost:9200/events/event/_search?q=port:3000&size=1") >>= liftM putStrLn . getResponseBody
00:59:19 <edwardk> :t traversed
00:59:20 <lambdabot> (Applicative f1, Traversable f, Indexable Int p) => p a (f1 b) -> f a -> f1 (f b)
00:59:35 <bitemyapp> if I elide (liftM putStrLn) and just getResponseBody I'll see the IO String
00:59:51 <edwardk> when p = (->) you get a normal traversal. when it is Indexed you get access to the index in the function you feed it
00:59:56 <edwardk> :t traversed . Indexed
00:59:57 <lambdabot> (Applicative f1, Traversable f) => (Int -> a -> f1 b) -> f a -> f1 (f b)
00:59:58 <bitemyapp> hrm, it works if I bind the putStrLn
01:00:08 <bitemyapp> derferk.
01:00:18 <edwardk> :t itraverseOf traversed
01:00:19 <lambdabot> (Applicative f, Traversable f1) => (Int -> a -> f b) -> f1 a -> f (f1 b)
01:00:44 <spacekitteh> edwardk: ok, thanks, i'll try it out
01:03:11 <spacekitteh> edwardk: come to think of it i think LinearOperator makes way more sense as a class anyway
01:14:05 <solidus-river> is there a valid reason to learn darcs if your already familiar with git?
01:15:56 <bitemyapp> solidus-river: do you have a burning need to be on the bleeding edge of what's possible for intelligent merging behavior?
01:16:17 <bitemyapp> solidus-river: git (intentionally) gives up and pukes on a merge more quickly than darcs will (intentionally)
01:16:43 <bitemyapp> I favor the, "come save me human" design, but I don't doubt VCS will incorporate whatever darcs does eventually.
01:17:53 <solidus-river> cool, didn't know it was the tool for the job for intelligent merges, i favor the come save me design too
01:18:04 <solidus-river> but now i have a reason to look at darcs sometime :)
01:18:36 <spacekitteh> :t (***)
01:18:37 <lambdabot> Arrow a => a b c -> a b' c' -> a (b, b') (c, c')
01:20:18 <dmwit> solidus-river: Wanting to collaborate on some project that already uses darcs is also a good reason to learn darcs.
01:20:23 <tikhon> ooh, I was working on a project to do more intelligent merges a while back
01:20:36 <tikhon> but then I ran into some algorithmic issues, got stuck and it's been on hiatus ever since :(
01:20:47 <tikhon> I should really sort that out
01:21:32 <tikhon> doesn't Darcs also have its own algorithmic issues?
01:21:40 <dmwit> solidus-river: Also, darcs still has the best user interface of any VCS, as far as I'm concerned.
01:21:51 <dmwit> tikhon: yes, definitely
01:22:04 <dmwit> tikhon: Though supposedly that has cleared up some since the advent of darcs 2
01:22:10 <tikhon> that's good to hear
01:22:21 <tikhon> the scary stories about exponential runtime have kept me away from it
01:22:39 <tikhon> not because they scare *me* but because I think they will scare away people I would be working with
01:22:49 <bitemyapp> to be fair, if you have one of those companies where every project (inadvisedly) is in a single repo, you can choke git too.
01:23:09 <tikhon> which is enough to make some of them (ie FB) move away from Git
01:23:33 <bitemyapp> tikhon: I'm still grumpy about that.
01:23:39 <tikhon> heh
01:23:54 <bitemyapp> they put little/no effort into improving any of git's pain points, then did a fairly serious project around fronting mercurial.
01:23:59 <tikhon> I've used Hg on a few projects, and it's caused nothing but pain
01:24:08 <bitemyapp> Ditto.
01:24:18 <tikhon> a good part of that is my fault, of course, but still
01:24:26 <bitemyapp> Fortunately, while most of my company is Hg, my last 3-4 repos that I've worked on have been git from the beginning.
01:24:38 <tikhon> from the outside, Darcs seems like a strict imrpovement over Hg or even Git
01:24:52 <tikhon> but less popular and with relatively less support
01:25:00 <tikhon> hmm, sounds like certain programming languages :P
01:25:17 <bitemyapp> anything I do has a decent chance of getting pushed to github, so starting with git makes the most sense for me.
01:25:33 <tikhon> oh yeah, that's another big thing that has kept me from trying Darcs
01:25:34 <bitemyapp> whether at work or independently. I've had decent luck open sourcing my 9-5 work recently.
01:25:45 <tikhon> ooh, that's always good to hear
01:25:46 <k_bx> Is C-u C-x C-t still working for everyone in fresh haskell-mode? Just wanted to check before I will start debugging why it just selects definition and prints it's type for me. Thanks!
01:25:58 <bitemyapp> tikhon: just...need more Haskell at work and the circle will be complete...
01:26:01 <k_bx> Sorry, C-u C-c C-t
01:26:07 <bitemyapp> tikhon: I'm enjoying Texas btw.
01:26:29 <tikhon> Texas?
01:26:48 <bitemyapp> tikhon: I'm Chris, I was at a few of the type theory and Tecate nights :)
01:26:58 <bitemyapp> tikhon: guy that worked at the genetics company.
01:27:11 <tikhon> ah, right
01:27:17 <tikhon> didn't connect the username
01:27:19 <bitemyapp> np
01:29:04 <bitemyapp> okay, enough poking at Conduit. Goodnight all :)
01:29:23 <tikhon> night
01:37:22 <tikhon> hmm, after reading a bit about fgl, it seems legitimately exciting
01:55:22 <jle`> how does type inference for recursive functions work?
01:55:50 <jle`> from an algorithmic/hindley-milner perspective
01:56:01 <jle`> i'm not totally sure how to start with an implementation
01:56:11 <jle`> i already have non-recursive bindings worked out
02:05:40 <skypers> hey
02:05:52 <skypers> I have a little situation with my EDSL representing an AST
02:06:12 <skypers> I can for example write F 3, it yields a E Float
02:06:30 <skypers> now, if I want to express a shared computation in the EDSL, I have no idea how to do that
02:06:33 <skypers> for instance
02:06:56 <skypers> (F 1, F 2, F 3) :: E (Float,Float,Float) -- this is ok to me, but the folling is not
02:07:19 <skypers> let sin3 = sin (F 3) in (sin3,sin3,F 3)
02:07:31 <skypers> the generated AST will duplicate sin (F 3)
02:07:46 <skypers> I think I need some kind of state monad to handle that
02:07:58 <skypers> but hm, since the type of an expression can vary, what’s my state?
02:08:10 <skypers> I could introduce something like
02:08:25 <skypers> do { sin3 <- var . sin $ F 3; return (sin3,sin3,F 3) }
02:08:33 <skypers> any idea folks?
02:08:40 <irene-knapp> without looking at this too deeply
02:08:47 <irene-knapp> can you use an existential?
02:08:52 <skypers> hm
02:09:09 <skypers> I don’t know
02:09:16 <skypers> I’d like to traverse the AST
02:09:23 <irene-knapp> ie. data PleasantState = forall foo . PleasantState (Expression foo)
02:09:26 <skypers> with an existential I guess it’s not possible anymore
02:09:49 <irene-knapp> you can, you just need to create a typeclass and put that in the appropriate contexts
02:09:59 <skypers> what do you mean?
02:10:13 <irene-knapp> data PleasantState = forall foo . (PleasantValue foo) => PleasantState (Expression foo)
02:10:23 <irene-knapp> where PleasantValue exports the methods you need for traversal
02:10:29 <skypers> what would do such a typeclass?
02:10:30 <skypers> ah
02:10:45 <skypers> might work indeed
02:10:48 <skypers> I’ll try that, thank you
02:10:49 <irene-knapp> (you can use the scrap-your-boilerplate approach if you make Data a superclass of it, or even just use Data)
02:10:51 <irene-knapp> sure thing!
02:11:07 <skypers> Data?
02:11:09 <skypers> Data.Data?
02:11:13 <irene-knapp> yes that
02:11:18 <irene-knapp> you know why it exists, yes?
02:11:21 <skypers> I looked at it
02:11:28 <skypers> it frightened me.
02:11:29 <irene-knapp> if not, google “scrap your boilerplate syb” and read the paper
02:11:31 <irene-knapp> yes, haha
02:11:42 <irene-knapp> it basically provides reflection on the constructors and parameters of a type
02:12:00 <irene-knapp> which is needed to write what syb-style libraries (there are several choices on hackage)
02:12:06 <irene-knapp> refer to as “generic functions"
02:12:09 <irene-knapp> the paper explains it
02:12:37 <skypers> ah
02:12:38 <skypers> yes
02:12:38 <irene-knapp> I mention it because large ASTs are exactly where it’s useful
02:12:43 <skypers> I read something about reification
02:12:51 <skypers> I almost passed out that day
02:12:51 <skypers> :D
02:12:55 <irene-knapp> it essentially makes the visitor pattern into a library so you don’t actually have to implement your visitor
02:13:01 <irene-knapp> if that helps
02:13:04 <irene-knapp> haha k :D
02:25:42 <jtcwang> hey guys
02:26:05 <jtcwang> my folder structure is as follows:
02:26:18 <jtcwang> proj/
02:26:21 <jtcwang> test/    src/
02:26:40 <jtcwang> how would i let files in test folder access files in src folder?
02:27:44 <jle`> jtcwang: well all module names are relative to hs-source-dirs
02:28:17 <jtcwang> does ghci take that into account tho?
02:28:26 <jtcwang> since i'm currently just using ghci to run tests
02:29:19 <jle`> what do you mean by 'files in test'?  are you :l test/file.hs ?
02:29:39 <jtcwang> yeah
02:29:50 <jtcwang> but then it can't find the modules in src/ folder
02:29:55 <dalaing> jtcwang: for the tests section in the cabal file, you can list both the src and test directories in hs-source-dirs
02:31:00 <jtcwang> do you have a link for a documentation that explains that?
02:31:04 <jtcwang> i'm still searching atm
02:33:01 <jtcwang> ok i found this line in a haskell project
02:33:01 <jtcwang> so haskoin
02:33:14 <jtcwang> hs-source-dirs: . tests
02:34:17 <jtcwang> so in my case, i'll have.... src tests?
02:34:57 <supki> jtcwang: with cabal you can either add src to hs-source-dirs: field or depends on library in test-suites
02:35:28 <supki> jtcwang: with ghci you can pass -isrc for it to look up the source files correctly
02:35:55 <jtcwang> righty
02:35:58 <jtcwang> that works
02:36:19 <jtcwang> supki, when you say "depends on library in test-suites"
02:36:24 <supki> oh
02:36:36 <supki> I mean add the library to build-depends: field, sorry
02:36:39 <jtcwang> you mean depends on library settings?
02:36:50 <jtcwang> oh ok
02:37:13 <jtcwang> thx guys for your help
02:37:21 <jtcwang> i'm still new to cabal stuff
02:37:23 <jtcwang> :)
02:37:44 <supki> if you add the library to build-depends: cabal won't recompile the source twice
02:38:17 <supki> that can be handy or inconvenient depending on your workflow
02:39:06 <jtcwang> do you have a good example of cabal file I can use for future reference?
02:40:14 <jle`> well there's the one generated by cabal init ?
02:40:42 <jtcwang> yeap i have that
02:40:52 <jtcwang> but stuff like hs-source-dirs are not in there by default
02:41:48 <tanmaig> Hi! I just upgraded a library (cabal install template-haskell) from 2.7 to 2.8
02:41:54 <tanmaig> The install was successful
02:42:07 <tanmaig> But my program doesn't compile.
02:42:40 <tanmaig> And gives my a linker error that says duplicate symbol found while processsing .../template-haskell-2.8.0.0/ghc-7.4.2/HStemplate-haskell-2.8.0.0.o
02:43:08 <tanmaig> Do I need to delete the object files and compile things afresh?
02:44:43 <jtcwang> i recall someone mentioned in the past
02:44:52 <jtcwang> that ghc is lazy
02:44:59 <jtcwang> and uses the existing .o file
02:45:02 <jtcwang> when compiling
02:45:09 <jtcwang> so yeah try that
02:45:18 <tanmaig> Well I deleted my programs' object files ofcourse.
02:45:21 <tanmaig> But to no avail
02:45:35 <tanmaig> But I was wondering if I needed to compile other TH dependents again.
02:45:41 <tanmaig> Like Persistent (Yesod)
02:45:49 <tanmaig> Because TH works fine in ghci
02:47:32 <supki> tanmaig: updating template-haskell is a really bad idea, it's tightly coupled to ghc version
02:47:48 <tanmaig> Oh bugger!
02:48:13 <tanmaig> Aaaah. I'd almost got everything working, and then I needed guards which seemed to be only in 2.8
02:48:16 <tanmaig> So I upgraded.
02:49:37 <tanmaig> Is there an uninstall with cabal?
02:54:44 <ulfdoz> gone
02:58:49 <supki> tanmaig: yeah, you can update the template-haskell _library_ but it's only going to confuse ghc
02:59:16 <b0bbi10> hi, can you imagine when a
02:59:18 <supki> tanmaig: cabal does not have uninstall command, but you can unregister the package with ghc-pkg unregister
02:59:25 <b0bbi10> 'Num' is not an 'Ord'?
02:59:44 <tanmaig> supki: Yeah. Just did that. Unregistered TH 2.8
02:59:51 <supki> b0bbi10: sure, complex numbers
02:59:51 <tanmaig> supki: Phew. That was close.
03:00:08 <b0bbi10> supki: ah yeah, thanks
03:06:32 <b0bbi10> how come that this construct "repeat' x = x:repeat' x" evaluates to a list? is it because of the ':' operator?
03:06:45 <Kneiva_> yes
03:07:02 <Kneiva_> :t (:)
03:07:04 <lambdabot> a -> [a] -> [a]
03:08:27 <b0bbi10> so 'x' is translated/ 'cast'/ inferred into '[x]'?
03:08:48 <skypers> @index Array
03:08:48 <lambdabot> Data.Array, Data.Array.IArray, Data.Array.Unboxed, Data.Array.Diff
03:08:53 <skypers> @hoogle Array
03:08:53 <lambdabot> Foreign.Marshal.Array module Foreign.Marshal.Array
03:08:54 <lambdabot> Data.Text.Array data Array
03:08:54 <lambdabot> Data.Array data Array i e :: * -> * -> *
03:09:03 <skypers> oh it’s in base?
03:09:22 <skypers> oh no, array
03:18:23 * hackagebot postie 0.3.0.0 - A library to receive emails from within Haskell programs.  http://hackage.haskell.org/package/postie-0.3.0.0 (alexbiehl)
03:18:34 <ghost_355> Hi! I have a question - has there is a function for check  that elements in list are uniqe  in Haskell
03:19:39 <ghost_355> I need to khow (a/=b/=c/=.../=n) in Haskell
03:19:45 <jle`> @hoogle Eq a => [a] -> Bool
03:19:45 <lambdabot> Prelude elem :: Eq a => a -> [a] -> Bool
03:19:46 <lambdabot> Data.List elem :: Eq a => a -> [a] -> Bool
03:19:46 <lambdabot> Prelude notElem :: Eq a => a -> [a] -> Bool
03:21:24 <circ-user-uPA98> ghost_355: You could use "nub" http://www.haskell.org/hoogle/?hoogle=nub, then compare lengths
03:24:08 <ghost_355> circ-user-uPA98: thx i try it
03:24:40 <ski> @type \as -> and [a `notElem` as | a:as <- as]  -- ghost_355
03:24:41 <lambdabot> Eq a => [[a]] -> Bool
03:24:49 <ski> er, actually
03:24:54 <ski> @type \as -> and [a `notElem` as | a:as <- tails as]
03:24:55 <lambdabot> Eq a => [a] -> Bool
03:25:20 <ski> > (\as -> and [a `notElem` as | a:as <- tails as]) [2,8,5,7,1,4]
03:25:22 <lambdabot>  True
03:25:28 <ski> > (\as -> and [a `notElem` as | a:as <- tails as]) [2,8,5,7,1,5,4]
03:25:29 <lambdabot>  False
03:27:11 <no-n> @hoogle sequenceA
03:27:11 <lambdabot> Data.Traversable sequenceA :: (Traversable t, Applicative f) => t (f a) -> f (t a)
03:27:11 <lambdabot> Data.Foldable sequenceA_ :: (Foldable t, Applicative f) => t (f a) -> f ()
03:27:40 <jle`> > let f xs x | elem x xs = Nothing | otherwise = Just (x:xs) in isJust $ foldM f [] [1,2,3,4,5]
03:27:42 <lambdabot>  True
03:27:45 <jle`> > let f xs x | elem x xs = Nothing | otherwise = Just (x:xs) in isJust $ foldM f [] [1,2,3,4,5,4]
03:27:46 <lambdabot>  False
03:28:09 <ghost_355> thx sky:
03:28:16 <ghost_355> thx ski
03:28:45 <circ-user-uPA98> ghost_355: "import Data.List; allUniq xs = (length $ nub xs) == length xs"
03:28:47 <jle`> @pl f xs x | elem x xs = Nothing | otherwise = Just (x:xs)
03:28:47 <lambdabot> (line 1, column 21):
03:28:48 <lambdabot> unexpected " "
03:29:17 <jle`> @pl \xs x -> if elem x xs then Nothing else Just (x:xs)
03:29:17 <lambdabot> ap (ap . flip flip Nothing . (if' .) . flip elem) ((Just .) . flip (:))
03:29:22 <jle`> aw
03:29:30 <ghost_355> ski, its worked but i don't know how yet :)
03:29:46 <ski> ghost_355 : you don't know how what yet ?
03:30:01 <ski> jle` : what did you expect ?
03:30:05 <ghost_355> ski, its worked but i don't understand how yet :)
03:30:16 <jle`> ski: some clean way to write it so my foldM solution would be cute :/
03:31:04 <ski> ghost_355 : `tails as' gives a list of all tails of `as', then the `a:as <-' matches each such tail list with head in `a' and tail in `as', and we collect a list of booleans  a `notElem` as  for each such tail
03:31:31 <ski> ghost_355 : `and' checks all the booleans are `True', so we're checking for each element that it doesn't occur in the list of elements following it
03:31:47 <ski> jle` : i was pondering a variant of your idea
03:33:02 <jle`> @let bool x y True = x; bool x y False = y
03:33:03 <lambdabot>  Defined.
03:33:07 <ghost_355> ski I mean that I need start learn your exeption step by step , thx 4 explanation
03:34:24 <ski> > (`fix` \_ -> True) (\loop p as -> case as of [] -> True; a0:as -> p a0 && loop (\a1 -> p a1 && a0 /= a1) as) [2,8,5,7,1,4]
03:34:25 <lambdabot>  True
03:34:28 <ski> > (`fix` \_ -> True) (\loop p as -> case as of [] -> True; a0:as -> p a0 && loop (\a1 -> p a1 && a0 /= a1) as) [2,8,5,7,1,5,4]
03:34:29 <lambdabot>  False
03:34:40 <Kneiva_> b0bbi10: no (:) or cons takes a value and a list of that value and prepends the value to the list returning a new list
03:34:55 <ski> (not using `elem' nor `notElem' directly, instead using `(/=)', so it's a but clunky)
03:36:11 <b0bbi10> Kneiva_: so in "repeat' x = x:repeat' x" "repeat' x" is infered as being a list?
03:36:29 <ski> b0bbi10 : yes
03:36:56 <b0bbi10> ok, thanks
03:37:22 <ski> @let repeat' x = xs where xs = x : xs
03:37:23 <lambdabot>  Defined.
03:37:38 <ski> is another variant of the same thing, which might execute slightly more efficiently
03:37:55 <jle`> @pl \xs x = bool Nothing (Just (x:xs)) (elem x xs)
03:37:56 <lambdabot> (line 1, column 7):
03:37:56 <lambdabot> unexpected "="
03:37:56 <lambdabot> expecting pattern or "->"
03:38:01 <jle`> @pl \xs x -> bool Nothing (Just (x:xs)) (elem x xs)
03:38:01 <lambdabot> ap (ap . ((bool Nothing . Just) .) . flip (:)) (flip elem)
03:38:23 <jle`> ap is just (<*>) right?
03:38:44 <ski> jle` : i suggest not using `pointless' except for trivial things. it's better to hand-pointless stuff, if you feel the need to
03:38:47 <ski> jle` : yes
03:39:09 <jle`> just trying to pl to perhaps spark some inspiration for a different approach
03:40:10 <jle`> @hoogle (a -> Bool) -> a -> Maybe a
03:40:10 <lambdabot> Data.List find :: (a -> Bool) -> [a] -> Maybe a
03:40:11 <lambdabot> Data.Foldable find :: Foldable t => (a -> Bool) -> t a -> Maybe a
03:40:11 <lambdabot> Control.Monad mfilter :: MonadPlus m => (a -> Bool) -> m a -> m a
03:41:32 <ski> @type liftM2 (`bool` Nothing) Just
03:41:33 <lambdabot> (a -> Bool) -> a -> Maybe a
03:42:44 <ski> > foldr (\a0 check_as p -> p a0 && check_as (\a1 -> p a1 && a0 /= a1)) (\p -> True) [2,8,5,7,1,4] (\_ -> True)
03:42:45 <lambdabot>  True
03:42:47 <ski> > foldr (\a0 check_as p -> p a0 && check_as (\a1 -> p a1 && a0 /= a1)) (\p -> True) [2,8,5,7,1,5,4] (\_ -> True)
03:42:49 <lambdabot>  False
03:44:06 <ski> jle` : those two (the `fix' and the `foldr' one) are more along the lines of your one than my original one
03:45:08 <ski> > (\as -> and [a `notElem` as | a:as <- tails as]) (repeat 0)
03:45:09 <lambdabot>  False
03:45:11 <ski> > (`fix` \_ -> True) (\loop p as -> case as of [] -> True; a0:as -> p a0 && loop (\a1 -> p a1 && a0 /= a1) as) (repeat 0)
03:45:12 <lambdabot>  False
03:45:19 <ski> > foldr (\a0 check_as p -> p a0 && check_as (\a1 -> p a1 && a0 /= a1)) (\p -> True) (repeat 0) (\_ -> True)
03:45:20 <lambdabot>  False
03:45:51 <ski> > let f xs x | elem x xs = Nothing | otherwise = Just (x:xs) in isJust $ foldM f [] (repeat 0)
03:45:52 <lambdabot>  False
03:45:53 <jle`> :t check_as
03:45:54 <lambdabot> Not in scope: `check_as'
03:46:21 <whald> what's the preferred way to concurrently read Binary instances from a file? I assume just doing a hSeek to the offset and then using hGet :: ByteString needs synchronization. is there a way to do it atomically?
03:46:23 <ski> > (\as -> length (nub as) == length as) [2,8,5,7,1,4]
03:46:24 <lambdabot>  True
03:46:25 <ski> > (\as -> length (nub as) == length as) [2,8,5,7,1,5,4]
03:46:26 <lambdabot>  False
03:46:32 <ski> > (\as -> length (nub as) == length as) (repeat 0)
03:46:37 <lambdabot>  mueval: mueval: Prelude.undefinedExitFailure 1
03:46:52 <ski> jle` : `check_as' is a local function, an argument of the lambda
03:47:01 <jle`> ah i see it now
03:47:18 <ghost_355> circ-user-uPA98 thx your expression so clean and short :) I just disassembled it
03:47:46 <ski> so the original `nub'&`length'-based solution can't cope with an infinite list with duplicates (and therefore probably doesn't cope well with long lists with duplicates either)
03:48:05 <ski> obviously none of the solutions can cope with an infinite list without duplicates ..
03:48:41 <ski> jle` : that `foldr' trick is the typical "leaned so far right they came back as left" thing
03:49:04 <jle`> yours, or mine?
03:49:10 <ghost_355> ski: I have an ending list
03:49:24 <ski> (i hope you can see why they can't possibly cope with an infinite list without duplicates ..)
03:49:31 <ski> ghost_355 : short ?
03:49:50 <ski> jle` : mine. you used `foldM', not `foldr'
03:49:55 <ClaudiusMaximus> whald: maybe open the file multiple times to get more handles, or mmap the file for reading as a bytestring and use binary for reading from (virtual) memory with different offsets, or find some way to duplicate a handle
03:49:58 <jle`> ah
03:50:14 <ghost_355> ski: short :) about 8-10
03:50:15 <jle`> ghost_355: how about a long list, but where the first two elements are duplicates?
03:50:26 <jle`> the nub solution will require going through the whole list
03:50:55 <jle`> i think nub just has a bad reputation overall :/
03:50:57 <jle`> @src nub
03:50:58 <lambdabot> nub = nubBy (==)
03:51:03 <jle`> thank you lambdabot
03:51:07 <jle`> @src nubBy
03:51:07 <lambdabot> nubBy eq []             =  []
03:51:07 <lambdabot> nubBy eq (x:xs)         =  x : nubBy eq (filter (\ y -> not (eq x y)) xs)
03:51:09 <ghost_355> jle`: oops , I dont think about it
03:51:46 <no-n> @hoolge foldMap
03:51:46 <lambdabot> Data.Foldable foldMap :: (Foldable t, Monoid m) => (a -> m) -> t a -> m
03:51:46 <lambdabot> Data.Traversable foldMapDefault :: (Traversable t, Monoid m) => (a -> m) -> t a -> m
03:51:46 <lambdabot> Data.IntMap.Strict foldMapWithKey :: Monoid m => (Key -> a -> m) -> IntMap a -> m
03:52:04 <no-n> how did it know that hoolge means hoogle :>
03:52:18 <whald> ClaudiusMaximus, ok, those are the options I already thought about. just wanted to confirm I'll have to go that route. thanks!
03:52:26 <jle`> lambdabot has that best-guess spellchecking thing
03:52:27 <ski> jle` : my `tails'-based one will walk through the whole list already on the first element, unless it finds a duplicate on it
03:52:41 <ski> jle` : your solution, and my two later solutions, won't do that
03:53:10 <ski> instead they'll keep around all the already-seen elements of the list, while progressing through the list
03:53:13 <whald> @hoogle Handle -> IO Handle
03:53:13 <lambdabot> GHC.IO.Handle hDuplicate :: Handle -> IO Handle
03:53:13 <lambdabot> Control.Exception.Base evaluate :: a -> IO a
03:53:13 <lambdabot> Control.Exception evaluate :: a -> IO a
03:53:48 <whald> hm, ghc specific... I think I can live with that. :-)
03:54:01 <ski> (that's what i meant by saying i pondered a variant of your idea)
03:54:14 <ski> @hoogle+
03:54:14 <lambdabot> Control.OldException evaluate :: a -> IO a
03:54:14 <lambdabot> Network.BufferType buf_hGetContents :: BufferOp a -> Handle -> IO a
03:54:14 <lambdabot> Network.BufferType buf_hGetLine :: BufferOp a -> Handle -> IO a
03:55:20 <jle`> yeah, i started out with a foldr that keeps already-seens, but kept a tuple (Bool,[x])...but realized that i could represent the same thing with Maybe [x]
03:55:29 <whald> "The two Handles will share a file pointer, however.". dang. :-/
03:56:28 <whald> I wonder how Java's FileChannel does this: http://docs.oracle.com/javase/7/docs/api/java/nio/channels/FileChannel.html#read(java.nio.ByteBuffer, long) under the hood.
03:56:29 <jle`> ski: oh i see what you were trying to do now with repeat 0
03:58:19 * ski smiles
03:58:25 <seanparsons> whald: You could just look at the source. :)
03:58:29 <hooplahoops> Hi, why is 'data Foo = X Int | Y Float' a valid type declaration, but 'data Foo = X { x :: Int } | Y { x :: Float }' is not?
03:58:51 <ski> jle` : yeah, instead of `Maybe [a]', i used `a -> Bool' directly, otherwise it's basically the same thing
03:58:54 <hooplahoops> I get: Constructors X and Y give different types for field `x' . Why do they need to be the same?
03:58:54 <DR6> because what type could c have?
03:59:00 <whald> seanparsons, I'm already at it. ;-)
03:59:10 <DR6> c :: Foo -> Int?
03:59:16 <DR6> or c :: Foo -> Float?
03:59:26 <ski> DR6 : perhaps you mean s/c/x/
03:59:36 <DR6> yes
04:00:14 <hooplahoops> DR6: Isn't it a variant I must discriminate against, just like the first declaration?
04:00:15 <ski> hooplahoops : because `x' will be an ordinary function (and also a little more), and it can't have both type `Foo -> Int' and type `Foo -> Float'
04:00:26 <jle`> a little more?
04:00:53 <ski> yes
04:00:54 <hooplahoops> ski: I suppose I don't understand the difference between the first and second variant, why is the latter not equal to the former + some added names?
04:01:04 <DR6> it is
04:01:16 <DR6> only it can't give the added names
04:01:22 <DR6> and it fails because of that
04:01:26 <ski> @let data Foo = X Int | Y Float
04:01:28 <lambdabot>  Defined.
04:01:37 <jle`> hooplahoops: when you do something like data Hello = Hello { getHello :: Int }
04:01:41 <hooplahoops> Oh, you're saying that each name introduces a function
04:01:45 <jle`> you are creating a couple of new functions
04:01:47 <hooplahoops> Oh I see
04:01:53 <hooplahoops> jle`: right, yeah, thanks
04:01:54 <jle`> the first is Hello :: Int -> Hello
04:02:02 <jle`> the second is getHello :: Hello -> Int
04:02:29 <hooplahoops> Hm, so that means I also have restrictions on the names I use in different variants
04:02:38 <ski> @let x :: Foo -> Int; x (X i) = i; x (Y _) = error "sorry, no `Y'"; x :: Foo -> Float; x (X _) = error "sorry, no `X'"; x (Y f) = f
04:02:39 <lambdabot>  .L.hs:148:1:
04:02:39 <lambdabot>      Duplicate type signatures for `x'
04:02:39 <lambdabot>      at .L.hs:146:1
04:02:39 <lambdabot>         .L.hs:148:1
04:02:52 <hooplahoops> e.g. data Foo = X { x :: Int } and data Bar = Y { x :: Float }
04:02:57 <ski> hooplahoops : the problem with your definitionis basically the same as the problem with ^
04:03:10 <jle`> hooplahoops: yes, this whole deal about record syntax is quite a mess
04:03:17 <ski> jle` : yes
04:03:25 <jle`> there is a language extension coming out soon that attemps to remedy some of the problems
04:03:31 <hooplahoops> Wouldn't it be better if no such functions were introduced?
04:03:37 <ski> @undefine
04:03:37 <lambdabot> Undefined.
04:03:39 <hooplahoops> I can always write those myself if I needed them
04:03:40 <jle`> hooplahoops: then what would the use even be...?
04:03:47 <ski> @let data Foo = X { x :: Int }; data Bar = Y { x :: Float }
04:03:48 <lambdabot>  .L.hs:145:14:
04:03:48 <lambdabot>      Multiple declarations of `x'
04:03:48 <lambdabot>      Declared at: .L.hs:143:14
04:03:48 <lambdabot>                   .L.hs:145:14
04:03:55 <jle`> i guess for assignments? Hello { getHello = 1 }
04:04:00 <seanparsons> jle`: What's the name of the language extension? Just so that I can keep an eye out for it.
04:04:01 <hooplahoops> jle`: yes
04:04:11 <ski> jle` : which language extension are you thinking about ?
04:05:44 <jle`> it's the one that would turn x into a sort of typeclass-like function?
04:06:06 <jle`> where if you use getHello on something, you can make it generic to all data types that have a getHello record
04:06:17 <jle`> by using some special syntax in the type constraints
04:06:44 <ski> something like Trex ?
04:07:11 <hooplahoops> This is even more restrictive given that Haskell doesn't do overloading
04:07:27 <hooplahoops> I basically have a bunch of different terms in my grammar that I want to give a "pos" field
04:07:45 <hooplahoops> but to do that I'd have to collapse everything into a single variant
04:08:07 <jle`> hooplahoops: the typical solution at this moment is to prefix the record with the name of the type
04:08:08 <ski> or factor
04:08:35 <ski> jle` : Trex <http://cvs.haskell.org/Hugs/pages/hugsman/exts.html#trex> is an extension in Hugs
04:08:37 <jle`> but it is not a very desirable solution
04:09:02 <hooplahoops> jle`: like X { Xpos :: Pos } you mean?
04:09:03 <jle`> data Foo = Foo { fooX :: Int, fooY :: Int }
04:09:11 <jle`> yeah, like that
04:09:41 <hooplahoops> I will lose my polymorphic "pos" access though :) Or at least I'd have to write it
04:09:50 <jle`> ski: yeah, that sounds like it. there was a reddit post a couple of months back on extensible records
04:10:14 <jle`> in ghc
04:10:27 <jle`> hooplahoops: yeah, you can write a HasPosition typeclass
04:10:36 <jle`> but lack of ad-hoc polymorphism can be considered a feature
04:10:45 <ski> hooplahoops : did you consider factoring yet ?
04:11:40 <hooplahoops> ski: Thanks, no I haven't. I don't really know what that is, where can I read about that?
04:12:22 <jle`> ah here it is
04:12:24 <jle`> http://www.well-typed.com/blog/84/
04:12:46 <ski> in SML, `{ x :: Int , s :: String }' (adapted slightly to Haskell-like syntax) would be a type by itself, and so one could use `{ x :: Float , t :: Towel }' as well in the same module
04:12:49 <jle`> seanparsons: OverloadedRecordFields
04:12:51 <ski> jle` : ty
04:13:29 * hackagebot tls 1.2.6 - TLS/SSL protocol native implementation (Server and Client)  http://hackage.haskell.org/package/tls-1.2.6 (VincentHanquez)
04:14:14 <jle`> genericPos :: (r { pos :: Int }) => r -> Int; genericPos = pos
04:14:33 <ski> hooplahoops : let's say you have types `A',`B',`C', and you have defined `data ABC = FromAB A B | FromAC A C' -- now, you could reformulate this as `data ABC = MakeABC A BC; data BC = FromB B | FromC C' -- algebraically, this corresponds to `(a * b) + (a * c)  =  a * (b + c)'
04:15:02 <jle`> but you can't do things like x { pos = 1 } anymore without specifying the type isngature of x somewhere else, sadly
04:15:12 <seanparsons> jle`: Cheers for that, I can see that being _really_ useful, shame it's not making it into 7.8. :(
04:15:23 <ski> hooplahoops : however, i would only consider this as an option when the two `A's in the original definition of `ABC' "represent the same thing" -- if those two data constructors just *happened* to use the same type `A', i would not consider this factoring
04:15:29 <ski> hooplahoops : all clear ?
04:16:36 <ski> hooplahoops : and of course you can only apply this if `A' occurs in *all* the alternatives (but you could use associativity and group the alternatives where it *does* occur together, ..)
04:17:16 <hooplahoops> ski: ah yeah, cool, thanks
04:17:25 <hooplahoops> ski: I think that somewhat fits my case
04:17:33 <ski> jle` : clarification. a field name *is* a field projection function, but it's also more, since we can use it in construction, update, and matching
04:18:12 <ski> hooplahoops : note that i'm not saying you *should* do this factoring, if the precondition applies. i'm only saying that this refactoring is *possible* to make
04:18:55 <hooplahoops> ski: yeah I understand, thanks for the clarification. It certainly feels a lot like a workaround and a bit of an intrusion into what I actually want
04:19:03 <ghost_355> i need to solve this : TETA + BETA = GAMMA where same letter is same digits other letters is other digits
04:19:04 <ski> jle` : by "is a field projection function", i e.g. mean that you can use it in other ways than in direct projection
04:19:16 <ghost_355> thats my solve import Data.List;
04:19:16 <ghost_355> nm = [0..9];
04:19:16 <ghost_355> allUniq xs = (length $ nub xs) == length xs;
04:19:16 <ghost_355> rebus nm = [ [a,b,c,d,e,f,g]| a <- nm, b <- nm, c <- nm, d <- nm, e <- nm, f <- nm, g <- nm, allUniq [a,b,c,d,e,f,g], (a*1000+b*100+a*10+d) + (e*1000+b*100+a*10+d)  == f*10000+d*1000+g*100+g*10+d];
04:19:16 <ghost_355> main::IO();
04:19:16 <ghost_355> main = print $ rebus nm
04:19:52 <hooplahoops> jle`: so in SML, can I take a "structurual" record, like f :: { x :: Pos } -> ... ?
04:20:02 <jle`> ski: ah i see
04:20:41 <hooplahoops> jle`: I'm guessing it doesn't have permutation subtyping :)
04:20:42 <ski> jle` : e.g. if `getHello :: Hello -> Int' is a field projection for `Hello', then if `aHello,anotherHello :: Hello', you can say `getHello aHello', but you can *also* say `map getHello [aHello,anotherHello]', rather than the more verbose `map (\h -> getHello h) [aHello,anotherHello]'
04:20:51 <ski> hooplahoops : yes
04:21:13 <hooplahoops> ski: for my guess or for the structural record question? :)
04:22:02 <ski> hooplahoops : also in SML, the field projection function for that record would be `#x' (of type `{ x :: Pos } -> Pos' in this case). avoiding the unfortunate confusion in Haskell between the projection function for the field, and the field itself (which here has type `Pos', not some function type)
04:22:15 <ski> hooplahoops : for the structural record thing :)
04:23:49 <jle`> ski: can't you say map getHello [..] for a normal function?
04:23:55 <hooplahoops> ski: oh cool, there's quite some power in that, I suppose it's another dimension of polymorphism?
04:24:33 <ski> jle` : it's not clear how `pos' is in scope there
04:25:09 <ski> jle` : yes, of course
04:25:22 <ski> jle` : but you e.g. can't for data constructor functions in OCaml
04:25:28 <jle`> the ah
04:25:31 <jle`> ah
04:25:37 <jle`> oh yeah i remember being pretty frustrated by that
04:25:42 <jle`> how data constructors weren't actual functions
04:25:43 <ski> just must say `Some x', you can't just say `Some', you'd have to say `fun x -> Some x'
04:25:55 <jle`> and i kept on asking the world why.
04:26:33 <jle`> i would say then that the projection functions are literally no more than just functions Hello -> Int?
04:26:42 <ski> hooplahoops : not sure what the "it" you're using refers to
04:27:12 <hooplahoops> ski: the record polymorphism, a bit of a philosophical question perhaps, feel free to ignore it :)
04:27:14 <ski> jle` : except that you can say `blah {getHello = 2}'
04:27:34 <ski> so obviously in some contexts, `getHello' is not *just* an ordinary function
04:27:58 <jle`> well, in that context, getHello is not a projection function
04:28:07 <ski> hooplahoops : well, it's related to what's called "row polymorphism" and (indirectly) subtyping (iow inclusion polymorphism)
04:28:49 <hooplahoops> ski: how efficiently is that typically compiled? Does it have another array of field offsets?
04:29:28 <ski> jle` : notice i originally said "`x' will be an ordinary function (and also a little more)", referring to `x' itself, not to the projection function that is sometimes denoted by it, in some contexts ;)
04:29:40 <ski> hooplahoops : which ?
04:29:58 <hooplahoops> ski: functions that are row-polymorphic
04:30:17 <ski> hooplahoops : i think one approach to row polymorphism will at run-time pass offsets for all the fields used
04:30:18 <hooplahoops> ski: or perhaps, since mutation isn't allowed, it can just reassemble the fields
04:30:57 <hooplahoops> ski: right, cool
04:31:05 <hooplahoops> Another question, does haskell have any python bindings? I couldn't really find any
04:33:12 <bergey> hooplahoops: I haven't tried this, but have you seen: https://john-millikin.com/articles/ride-the-snake/
04:34:24 <hooplahoops> bergey: cool, thanks! Haven't seen that, but it looks good
04:38:50 * hackagebot postie 0.3.1.0 - SMTP server library to receive emails from within Haskell programs.  http://hackage.haskell.org/package/postie-0.3.1.0 (alexbiehl)
04:38:50 * hackagebot lord 2.20140324 - A command line interface to online radios.  http://hackage.haskell.org/package/lord-2.20140324 (rnons)
04:53:45 * hackagebot hoogle 4.2.30 - Haskell API Search  http://hackage.haskell.org/package/hoogle-4.2.30 (NeilMitchell)
04:57:59 <tpsinnem> http://www.haskell.org/haskellwiki/Web/Comparison_of_Happstack,_Snap_and_Yesod <-- this page says happstack is 'being rewritten with pipes'. is that rewrite done by now?
05:03:16 <iNode001>  /join #jsoftware
05:05:54 <daimonos> :t ($)
05:05:55 <lambdabot> (a -> b) -> a -> b
05:06:12 <daimonos> :t fmap
05:06:12 <lambdabot> Functor f => (a -> b) -> f a -> f b
05:07:18 <ski> @type (<*>)
05:07:19 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
05:07:21 <ski> @type ap
05:07:22 <lambdabot> Monad m => m (a -> b) -> m a -> m b
05:07:30 <ski> @type (=<<)
05:07:31 <lambdabot> Monad m => (a -> m b) -> m a -> m b
05:13:30 <daimonos> ski: You trying to make me life hard?
05:15:02 <ski> daimonos : more like trying to make it more interesting
05:18:49 * hackagebot clifford 0.1.0.13 - A Clifford algebra library  http://hackage.haskell.org/package/clifford-0.1.0.13 (spacekitteh)
05:24:18 <fizruk> :t Control.Comonad.extend
05:24:18 <lambdabot> Control.Comonad.Comonad w => (w a -> b) -> w a -> w b
05:25:16 <fizruk> :t traverse
05:25:17 <lambdabot> (Applicative f, Traversable t) => (a -> f b) -> t a -> f (t b)
05:25:26 <Dethkat> Hello again.. I have another noob question. I'm looking for a way of taking three numbers, something like this convert3 = [3, 4, 5] and getting back 543 so like a reverse sort I guess
05:25:57 <daimonos> ski: lol
05:26:18 <daimonos> I know $ to be just a way to put brackets around something
05:26:33 <daimonos> ski: but now it's a whole function with a signature
05:26:41 <daimonos> ski: I feel cheated
05:26:46 <ski> Dethkat : what if the input is `[3,5,4]' ?
05:26:54 <daimonos> I should've figured it but..
05:27:31 <ski> daimonos : please don't try to remove most pairs of brackets using `$'
05:27:34 <daimonos> ski: Thanks for (=<<)
05:27:36 <fizruk> > sum . zipWith (*) (map (10^) [0..]) $ [3, 4, 5]
05:27:36 <lambdabot>  543
05:28:00 <daimonos> ski: I have wondered why it sometimes fails :)
05:28:21 <Dethkat> Hi ski this is the question I'm answering Exercise 2.2.4. Define the program convert3 . It consumes three digits, starting with the least
05:28:21 <Dethkat> significant digit, followed by the next most significant one, and so on. The program produces the
05:28:21 <Dethkat> corresponding number. For example, the expected value of
05:28:22 <ski> @src $
05:28:22 <lambdabot> f $ x = f x
05:28:57 <daimonos> @type ($)
05:28:58 <lambdabot> (a -> b) -> a -> b
05:29:25 <daimonos> @type (<$>)
05:29:25 <lambdabot> Functor f => (a -> b) -> f a -> f b
05:29:32 <daimonos> ski: Ok I'm lost
05:29:48 <ski> > foldr (\d i_n i -> d * 10^i + i_n (i + 1)) (\i -> 0) [3,5,4] 0
05:29:49 <lambdabot>  453
05:30:07 <daimonos> ski: In the first case I see no use for `$'
05:30:28 <ski> daimonos : in which first case ?
05:31:05 <daimonos> f $ x
05:31:31 <ski> Dethkat : suspected cut off after "For example, the expected value of"
05:31:49 <ski> daimonos : that is the definition of `$'
05:32:25 <Dethkat> ski, the expected value was 543... I found quicksort on google but I though maybe there is something a little simpler as I think the question is looking for something very simple.. btw its not homework
05:32:44 <ski> Dethkat : i don't think you want to sort at all
05:33:08 <ski> Dethkat : you just want to piece together an integer from digits
05:33:27 <daimonos> :t foldr
05:33:27 <lambdabot> (a -> b -> b) -> b -> [a] -> b
05:33:33 <fizruk> daimonos: $ is an infix operator defined to be just function application. it has very low precedence (contrasting with usual application (f x)), so that you can write something like `div x $ y + z` instead of `div x (y + z)`
05:33:51 <ski> Dethkat : so if you get digits `[d0,d1,d2]' as input, you want to compute `d0 + d1 * 10 + d2 * 100' as output, do you agree ?
05:34:20 <ski> daimonos : .. or instead of `(div x) (y + z)' ..
05:34:43 <ski> > foldr f z [a,b,c,d]   :: Expr
05:34:44 <lambdabot>  f a (f b (f c (f d z)))
05:34:51 <ski> > foldr (+) 0 [a,b,c,d]   :: Expr
05:34:52 <lambdabot>  a + (b + (c + (d + 0)))
05:34:56 <ski> > foldr (*) 1 [a,b,c,d]   :: Expr
05:34:57 <lambdabot>  a * (b * (c * (d * 1)))
05:34:57 <Dethkat> I thought is was going to be something to do with using 'max'
05:35:01 <fizruk> daimonos: it is mostly used when last argument is too large, or when you use a composition of functions before
05:35:36 <ski> > foldr (\number string -> "(" ++ show number ++ " + " ++ string ++ ")") "0" [2,3,5,7]
05:35:37 <lambdabot>  "(2 + (3 + (5 + (7 + 0))))"
05:35:41 <fizruk> daimonos: e.g. sum . filter (< 10) . map (^2) $ [1..]
05:35:52 <daimonos> I thought that `$' and ($) were different for some reason
05:36:04 <ski> daimonos : can you follwo how that last `foldr' example works ?
05:36:22 <ski> daimonos : they are different, just like `+' and `(+)' are different
05:36:26 <fizruk> daimonos: ($) is just a section of $ operator, just like (+) is a section for +
05:36:31 <ski> the formers are operators, the latters are expressions
05:37:54 <daimonos> I see
05:37:55 <kuribas> > foldr (+) 0 a b c d e
05:37:56 <lambdabot>  Couldn't match expected type `[Debug.SimpleReflect.Expr.Expr
05:37:56 <lambdabot>                                 -> Debug.SimpleReflect.Expr.Expr
05:37:56 <lambdabot>                                 -> Debug.SimpleReflect.Expr.Expr
05:37:56 <lambdabot>                                 -> Debug.SimpleReflect.Expr.Expr
05:37:56 <lambdabot>                                 -> t0]'
05:38:06 <kuribas> > foldr (+) 0 [a, b, c, d, e]
05:38:07 <lambdabot>  a + (b + (c + (d + (e + 0))))
05:39:23 <kuribas> > foldl (+) 0 [a, b, c, d, e]
05:39:24 <lambdabot>  0 + a + b + c + d + e
05:40:27 <daimonos> ski: most pairs of what?
05:40:34 <daimonos> ski: Sorry
05:40:46 <daimonos> was replying to something in my scrollback
05:41:55 <Dethkat> ski, it seems like a simple question in having a list [3, 4, 5] and then returning the highest digit and then the next highest and so on. so getting back [5, 4, 3]
05:42:39 <dv-> > reverse $ sort [3,4,5]
05:42:40 <lambdabot>  [5,4,3]
05:42:54 <ski> > foldr (+) 0 [] a b c d e   :: Expr
05:42:56 <lambdabot>  0
05:44:34 <Dethkat> dv-,  sort doesnt work in ghci. I tried it before I came to ask
05:45:09 <ski> daimonos : most pairs of brackets
05:46:48 <ski> Dethkat : but "It consumes three digits, starting with the least significant digit, followed by the next most significant one, and so on. The program produces the corresponding number." doesn't talk about highest digit, it talks about least *significant* digit, next to least *significant* digit, up to highest (/most) *significant* digit, which is something completely different
05:48:26 <ski> Dethkat : you can use `sort' in GHCi, if you first bring it into scope by `:module + Data.List' -- still, `sort' is a red herring here
05:48:41 <Dethkat> ski, your probably right but its the way I understood it from the input and the output on the example
05:48:51 <Dethkat> ski, thanks :)
05:49:10 <no-n> @src T.sequenceA
05:49:10 <lambdabot> Source not found. You untyped fool!
05:49:18 <no-n> lies
05:49:25 <ski> Dethkat : iiuc, `convert3 [5,2,7]' should evaluate to `725'. as opposed to e.g. `[7,5,2]' or `752'
05:55:31 <Dethkat> ski, this is the answer written in Scheme, it looks as if your first idea was correct.. sorry :) (define (convert3 x y z)
05:55:32 <Dethkat>   (+ x (* 10 y) (* 100 z)))
05:58:47 <Raydiation> are monads mostly used to deal with state?
05:58:56 <ski> no
05:59:26 <ski> state is certainly one of the common uses of monads
05:59:51 <ski> backtracking is another common one (see parsing)
06:00:45 <narendraj9__> What are some applications in active development that one can contribute to?
06:01:00 <narendraj9__> written in Haskell.
06:01:01 <ski> there's also exceptions, environment, output/logging, continuations
06:01:25 <ski> (.. and more)
06:01:36 <Raydiation> exceptions as in maybe?
06:01:52 <Raydiation> btw is there null?
06:02:15 <Raydiation> or do people use maybes everywhere
06:03:15 <whald> Raydiation, Either is quite popular for communicating failure
06:03:18 <hpc> Maybe, Either, and more specialized things
06:05:32 <pearson> hello, I have a question regarding the bf calculator I made, i think the formula isn't right. Do I need to type anything when using the logarithmus?
06:05:46 <pearson> wait, I'll type it into lpaste
06:06:16 <no-n> @src liftM2
06:06:16 <lambdabot> liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
06:07:00 <no-n> @src liftA2
06:07:00 <lambdabot> liftA2 f a b = f <$> a <*> b
06:08:45 <pearson> http://lpaste.net/101625
06:10:12 <pearson> %Fat = 86.010*LOG(abdomen - neck) - 70.041*LOG(height) + 30.30 is the  formula, i pasted and changed it, but I think I oversaw some precedence?
06:12:03 <khyperia> looks correct to me, pearson
06:14:12 <khyperia> and you want base-e logarithm, not base-10, right?
06:16:15 <pearson> khyperia: I don't know much math yet, forgot it over the summer. Maybe it's another logarithm.
06:16:27 <pearson> khyperia: http://www.wikihow.com/Measure-Body-Fat-Using-the-US-Navy-Method is the source
06:16:54 <khyperia> yep, it means base 10, look under "Tips"
06:17:01 <khyperia> you're using base e
06:17:17 <pearson> khyperia: thanks
06:17:24 <ski> Raydiation : as in `Maybe' and as in `Either exn'
06:17:45 <ski> Raydiation : there is no `null'. `null' is a bad idea
06:18:01 <khyperia> so it should be `logBase 10 (abdomen - neck)`, etc.
06:18:37 <ski> @google billion-dollar mistake infoq
06:18:38 <lambdabot> http://www.infoq.com/presentations/Null-References-The-Billion-Dollar-Mistake-Tony-Hoare
06:18:38 <lambdabot> Title: Null References: The Billion Dollar Mistake
06:18:42 <ski> Raydiation ^
06:21:31 <Raydiation> ski: yeah, thought about that too
06:25:03 <rindolf> Hi all.
06:25:44 <rindolf> http://pastie.org/8961158 - how can I fix this code so f will output the stuff to the IO () monad recursively? It's for this Golf challenge - http://pastie.org/8961158 ?
06:26:42 <ski> @type null
06:26:43 <lambdabot> [a] -> Bool
06:28:03 <no-n> :t void
06:28:04 <lambdabot> Functor f => f a -> f ()
06:31:27 <ski> rindolf : is that supposed to compute combinations ?
06:31:45 <rindolf> ski: to print them.
06:31:52 <ski> yes
06:32:12 <rindolf> ski: http://golf.shinh.org/p.rb?combination - it's for this challenge.
06:38:17 <ski> rindolf : hm, i remember implementing that in C (without recursion) slightly more than a year ago, for fun
06:38:43 <rindolf> ski: ah.
06:38:52 <rindolf> ski: did you use a stack of stuff?
06:39:05 <ski> (someone mentioned it on a channel, and i implemented it in C, and in Prolog, for comparision. i hadn't seen any website for it before now)
06:39:36 <rindolf> ski: ah.
06:40:00 <ski> rindolf : i used an array, plus two hard-to-grok placements of `goto'
06:40:08 <ski> (that was part of the fun)
06:41:19 <ski> i first wrote down the algorithm as a flowchart, and later translated most of it into `if's and `for's
06:41:51 <ski> leaving one `goto' jumping out of the body of the `for' and another jumping in to the body of the `for'
06:42:08 <rindolf> ski: heh, interesting.
06:42:34 <ski> rindolf : anyway, i suspect using something like <http://hackage.haskell.org/package/List> would be simplest in your case
06:43:13 <ski> @wiki ListT done right
06:43:13 <lambdabot> http://www.haskell.org/haskellwiki/ListT_done_right
06:43:26 <rindolf> ski: you can implement recursion without procedural recursion by using a stack of items with a pointer that you increment and decrement .
06:43:34 <rindolf> ski: it's still recursion in essence.
06:43:56 <daimonos> ski: Hey could we talk on ##haskell-overflow?
06:45:33 <daimonos> ski: Holla when you get there.
06:47:04 <rindolf> ski: is this List module in the core ghc?
06:47:25 <daimonos> rindolf: Oh man even you are here :)
06:47:33 <daimonos> rindolf: hi 5 o/
06:47:42 <prooftechnique> Am I right in thinking that you can hide nonexistent things in an import declaration without the compiler caring?
06:47:56 <rindolf> daimonos: hi.
06:48:03 <daimonos> prooftechnique: How do you hide the non existent?
06:48:10 <prooftechnique> e.g., import Data.List hiding (thingThatDoesn'tExist)
06:48:11 <rindolf> daimonos: I'm not always here - I just joined to ask a question.
06:48:42 <daimonos> rindolf: Stick around. Don't leave.
06:49:30 <rindolf> daimonos: heh, I will stick around for the while.
06:49:45 <rindolf> daimonos: but I have a meetup soon, and I need to shave and bathe first.
06:49:53 <rindolf> daimonos: it's a Khronos meetup.
06:49:58 <rindolf> The first one.
06:50:43 <daimonos> Khronos? Like the titan?
06:50:50 <daimonos> Cronos
06:51:49 <daimonos> Ok ski I can't wait no  more.
06:52:06 <rindolf> daimonos: http://www.meetup.com/Khronos-Tel-Aviv-Chapter/events/169536192/ - here.
06:54:01 * hackagebot antisplice 0.14.0.0 - An engine for text-based dungeons.  http://hackage.haskell.org/package/antisplice-0.14.0.0 (implementation)
06:54:03 * hackagebot ironforge 0.1.0.25 - A technical demo for Antisplice.  http://hackage.haskell.org/package/ironforge-0.1.0.25 (implementation)
06:54:05 * hackagebot antagonist 0.1.0.14 - A web interface to Antisplice dungeons.  http://hackage.haskell.org/package/antagonist-0.1.0.14 (implementation)
06:54:30 <nadirs> Hey there! Has anyone ever had the error `hoogle: Wrong hoogle database version: found 4.2.23.0, expected 4.2.30.0` (versions may vary, obviously) when running `hoogle <something>`? I've uninstalled/removed everything haskell-related on my system and reinstalled.
06:54:56 <nadirs> I've also run `hoogle data` for generating (I guess) databases
06:55:29 <rindolf> daimonos: bye, I'm off to prepare for the meetup.
06:55:36 <rindolf> daimonos: I should have some time later on.
06:56:28 <Reite> How can I derive a instance for a newtype using GeneralizedNewtypeDeriving somewhere else than where its defined?
06:56:42 <prooftechnique> nadirs: Hmm. It seems like that's related to that latest update
06:57:08 <Reite> I tried just doing "instance MyType", but I get an error that it doesnt have a default method
06:57:30 <nadirs> prooftechnique: which update are you referring to? `hoogle data`? I've tried using it before and after running that command
06:58:02 <prooftechnique> No, I mean hoogle just got an update this morning, so I wonder if that's the cause
06:58:35 <prooftechnique> Reite: You can't, and really you oughtn't
06:58:49 <nadirs> prooftechnique: I've been having this problem since 4.2.28, though
06:58:51 <prooftechnique> Actually, you might be able to
06:59:17 <prooftechnique> Reite: Look into StandaloneDeriving
07:00:27 <Reite> prooftechnique: Thanks, that seems to solve my problem. Why shouldnt I though? Any other reason than that I should avoid orphan instances?
07:00:44 <prooftechnique> nadirs: That's unusual. Maybe related to this? https://github.com/ndmitchell/hoogle/issues/55
07:01:17 <prooftechnique> Reite: That's pretty much it. Orphan instances are evil, but as long as it's just application code it's probably fine
07:02:31 <ski> daimonos : mhm
07:02:47 <nadirs> prooftechnique: probably not. `hoogle data` doesn't throw errors. I haven't tried `hoogle data all`. I'll try it
07:02:50 <ski> rindolf : yes
07:03:07 <ski> rindolf : i don't think it is
07:03:33 <prooftechnique> nadirs: Oh, okay. Hmm
07:11:52 <jxport> Hi guys.  Haven't touched haskell in a while - I think I just need a little reminder on a couple things.  Could someone help me decode this, please?
07:11:57 <jxport> foldMap :: Monoid m => (a -> m) -> t a -> m
07:13:49 <nadirs> jxport: it seems you're missing a piece → foldMap :: (Foldable t, Monoid m) => (a -> m) -> t a -> m
07:13:53 <prooftechnique> ^
07:14:03 * hackagebot yesod-platform 1.2.8.1 - Meta package for Yesod  http://hackage.haskell.org/package/yesod-platform-1.2.8.1 (MichaelSnoyman)
07:14:50 <nadirs> jxport: http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Foldable.html#v:foldMap
07:14:59 <nadirs> "Map each element of the structure to a monoid, and combine the results."
07:15:36 <prooftechnique> jxport: The bit before => is just saying "m must be an instance of Monoid"
07:15:52 <jxport> Yes I'm asking more on a syntactic level, here
07:17:07 <nadirs> jxport: what do you mean?
07:17:31 <jxport> (a -> m) -> t a -> m     -- focusing more on this bit now.  So ultimately, a Monoid m is returned;
07:18:03 <jxport> Want to make sure I understand the part beforehand
07:18:41 <nadirs> jxport: you have a function that turnsa Foldable instance's content into a monoid, I guess?
07:18:46 <nadirs> *turns a
07:18:55 <spacekitteh> ... i just realised i've written like 1000 lines of haskell in the last two months and haven't once touched a debugger. is there even a haskell debugger? o.O
07:19:16 <Yaniel> it is called "compiler"
07:19:33 <nadirs> spacekitteh: strange coincidence → http://chrisdone.com/posts/ghci-debugger
07:19:36 <DR6> there's a profiler
07:19:41 <spacekitteh> nadirs: yeah that's what made me realise
07:19:46 <spacekitteh> Yaniel: :P
07:20:07 <nadirs> spacekitteh: haha, I should have consider it :P
07:20:14 <nadirs> *considered
07:20:20 <spacekitteh> :3
07:20:59 <nadirs> oh my, `hoogle data all` takes forever
07:21:04 * spacekitteh just learned of magit too
07:21:29 <flebron> What's a pretty solution to getting a "fresh" variable, given a Data.Set of used variables, and my target codomain being a..z, a'..z', a''..z'', ... ? (i.e. those are the variables I would like to get, in that order). I'm currently using a simple filter (`notMember` s) ['a'..'z'], but that doesn't work for the a'..z', a''..z'' and so on.
07:21:50 <prooftechnique> nadirs: Yeah, so it does. I just went to do it myself to check if I got an error
07:21:53 <prooftechnique> Still going :D
07:22:04 <nadirs> prooftechnique: :D
07:22:47 <flebron> Oh, perhaps something like concat $ iterate (map (++ "'")) ['a'..'z']...
07:22:52 <nadirs> prooftechnique: I find amusing that it runs seemingly backwards (from Z to A). Does it use foldr? :P
07:23:49 <flebron> Yeah OK, concat . iterate (map (++ "'")) $ map return ['a'..'z'] works.
07:24:26 <ski> jxport : "a Monoid m is returned" -- no. `m' (the type) is the monoid. an *element* of that monoid is returned
07:24:40 <prooftechnique> flebron: I'm sure we're all glad to have been so helpful :D
07:24:50 <flebron> Hahaha
07:24:51 <jxport> ski: thanks
07:25:29 <nadirs> rubber-ducking for the win
07:26:09 <ski> jxport : e.g. `m' might be the type `Sum Integer', and then elements of that type are (basically) integers, and the monoid here consists of that type, together with info that we're interested in *summing* such integers (rather than taking product, e.g.)
07:27:56 <prooftechnique> > mconcat $ map Sum [1..10]
07:27:57 <lambdabot>  Sum {getSum = 55}
07:28:25 <ski> > [c : replicate n '\'' | n <- [0 ..],c <- "abc"]  -- flebron ?
07:28:26 <lambdabot>  ["a","b","c","a'","b'","c'","a''","b''","c''","a'''","b'''","c'''","a''''","...
07:28:51 <flebron> Yeah that works too :)
07:29:44 <ski> > iterate ('\'' :) [] >>= \primes -> map (:primes) "abc"  -- shares some more tails
07:29:45 <lambdabot>  ["a","b","c","a'","b'","c'","a''","b''","c''","a'''","b'''","c'''","a''''","...
07:30:28 <no-n> @hoogle readMay
07:30:29 <lambdabot> Data.Graph.Inductive.Internal.Thread threadMaybe :: (i -> r -> a) -> Split t i r -> SplitM t j i -> SplitM t j a
07:30:29 <lambdabot> Data.Graph.Inductive.Internal.Thread threadMaybe' :: (r -> a) -> Split t i r -> Split t j (Maybe i) -> Split t j (Maybe a)
07:31:02 <ski> @hoogle readJune
07:31:02 <lambdabot> No results found
07:31:11 <no-n> =)
07:31:19 <ski> @hoogle readMust
07:31:19 <lambdabot> No results found
07:32:04 <no-n> @hoogle Safe
07:32:04 <lambdabot> Data.Array.IO.Safe module Data.Array.IO.Safe
07:32:05 <lambdabot> Data.Array.MArray.Safe module Data.Array.MArray.Safe
07:32:05 <lambdabot> Data.Array.ST.Safe module Data.Array.ST.Safe
07:32:11 <no-n> hmm
07:33:30 <flebron> So an even worse question: How can I read an a..z, followed by 0 or more single quotes, in Parsec? I'm trying (return <$> letter') <*> many (char '\''), but it seems it's only reading the letter. Is <*> the right combinator to use here?
07:34:17 <flebron> (letter' = spaces *> letter <* spaces)
07:34:47 <no-n> @hoogle Read a => String -> Maybe a
07:34:48 <lambdabot> Network.CGI.Protocol maybeRead :: Read a => String -> Maybe a
07:34:48 <lambdabot> Network.CGI readCookie :: (Read a, MonadCGI m) => String -> m (Maybe a)
07:34:48 <lambdabot> Network.CGI readInput :: (Read a, MonadCGI m) => String -> m (Maybe a)
07:35:46 <aristid> why do the GHC.Generics type all have an extra type variable at the end that seems to be never used?
07:37:33 <prooftechnique> flebron: Do you get different results with many1?
07:37:41 <flebron> Nope.
07:37:55 <flebron> (I don't want to require a ', zero or more is fine.)
07:37:55 <ski>   liftA2 (:) letter' many (char '\'')  -- how about this ?
07:38:26 <ski> also, are you sure you want to accept "a '" ?
07:40:01 <flebron> Yeah thought about that when writing out what letters' was ;)
07:40:12 <flebron> Your solution seems to work! :)
07:44:08 <ski> flebron :)
07:44:38 <joebobjoe> Will there ever be a day where programming languages as we know them become obsolete and we can design programs with complete generality? I always see compromises where library designers have to decide what features should be implemented statically and which should be implemented dynamically... either at the cost of performance overhead or runtime flexibility.
07:45:49 <joebobjoe> the same logic that is so convenient in higher level languages must be reimplemented in C for embedded systems for example
07:48:46 <exicer> What is the big advantage of using pureMT when drawing random numbers ?
07:49:47 <jmcarthur> joebobjoe: i don't actually know what functionality you are saying we are missing
07:50:07 <jmcarthur> joebobjoe: what do you mean by "implemented dynamically"?
07:53:51 * ski figures it could mean that parts of the program are written after the program has started to execute
07:54:50 <joebobjoe> jmcarthur: idk
07:55:09 <tristan__> does cabal have pre-compile hooks? or what is the best wya if I have a dir of markup that I want converted with pandoc into tpl files before the app is built
07:56:07 <joebobjoe> In C++, allocators are given to a container class via a static type parameter. There is no way to decide the allocator at runtime.
07:56:45 <joebobjoe> Writing code that would give you the option of runtime vs compile time input is difficult
07:57:01 <ski> joebobjoe : could you elaborate on what an allocator is and does, in C++ ?
07:57:30 <ski> i assume it's distinct from the storage class of a declaration
07:58:03 <briennetheblue> does anyone else think this is a bit strange? http://lpaste.net/101627  it was confusing me for a while...
07:58:22 <joebobjoe> ski: It is the class to be instantiated to determine how the container manages memory at a very low level
07:58:41 <joebobjoe> I don't know if it is actually a class but it is the code required
07:59:15 <joebobjoe> Why aren't compilers written with automated proof assistants :(
07:59:32 <rindolf> Hi all. How can I print a list of strings using putStrLn in Haskell?
08:00:05 <DR6> mapM putStrLn
08:00:12 <ski> joebobjoe : mhm, ok
08:00:25 <DR6> sorry
08:00:29 <DR6> mapM_ putStrLn
08:00:45 <rindolf> DR6: thanks.
08:00:48 <DR6> otherwise you get a list of ()s
08:01:28 <hpc> you can also use print, if you want to see the actual list
08:02:03 <jmcarthur> briennetheblue: it does seem strange to me
08:02:29 <jmcarthur> briennetheblue: i thought sprint shouldn't evaluate anything, but it seems to be here
08:03:06 <jmcarthur> briennetheblue: actually, i don't know the difference between :print and :sprint
08:03:14 <jmcarthur> briennetheblue: maybe :sprint does something special?
08:03:34 <jmcarthur> hmm, no
08:03:35 <briennetheblue> jmcarthur: :print behaves the same way
08:04:01 * geekosaur wonders if what's different is the number one is potentially polymorphic
08:04:21 <jmcarthur> perhaps :print is doing something weird due to the fact that it has a special case for rendering strings
08:04:38 <jmcarthur> i would consider this a bug
08:04:45 <geekosaur> could try the string one with -XOverloadedStrings to see if it changes behavior
08:05:06 <hpc> sprint gives simpler output than print
08:05:27 <jmcarthur> i see. underscores instead of named things with types
08:06:10 <briennetheblue> it confused me when I was doing some debugging and what :sprint was telling me was "blah" was actually [_,_,_,_] (well at least before :sprint forced it itself)
08:07:06 <jmcarthur> i am getting more and more confusing results from this
08:07:22 <jmcarthur> let me paste
08:07:30 <hpc> i tried with x = map id ["yes"]
08:07:40 <hpc> length x, :sprint x -- [_]
08:07:57 <hpc> head . head $ x, :sprint x -- [('y' : _)]
08:08:28 <jmcarthur> i added an annotation
08:08:54 <hpc> oooooooh
08:09:03 <rindolf> Hi all. How can I write the do here - http://pastie.org/8961328 - on one line? This is for golfing - not for production code.
08:09:17 <hpc> when the spine is fully evaluated and it's a stringy thing
08:09:31 <hpc> yeah, i would consider that a bug too
08:09:36 <jmcarthur> both of the behaviors in that annotation confuse me
08:09:44 <jmcarthur> why does the last thing give _?
08:09:47 <briennetheblue> jmcarthur: i can't reproduce your b example
08:10:11 <jmcarthur> briennetheblue: if you do  :t b   what do you get?
08:10:12 <DR6> > liftM words getLine >>= \[a,b] -> mapM_ putStrln (f (read a) (read b) [])
08:10:13 <lambdabot>  Not in scope: `putStrln'
08:10:13 <lambdabot>  Perhaps you meant one of these:
08:10:13 <lambdabot>    `putStrLn' (imported from Prelude),
08:10:13 <lambdabot>    `BSC.putStrLn' (imported from Data.ByteString.Char8),
08:10:13 <lambdabot>    `BSLC.putStrLn' (imported from Data.ByteString.Lazy.Char8)
08:10:16 <jmcarthur> briennetheblue: mine is polymorphic
08:11:05 <jmcarthur> briennetheblue: if i monomorphise it then sprint shows the entire list before i even do any work with it
08:11:23 <geekosaur> @. pl undo do { n <- getLine; let { [a,b] = words n}; mapM_ putStrLn $ f (read a) (read b) [] }
08:11:23 <lambdabot> (line 1, column 24):
08:11:23 <lambdabot> unexpected "{"
08:11:23 <lambdabot> expecting "()", natural, identifier or "in"
08:11:28 <geekosaur> whoops
08:11:40 <briennetheblue> jmcarthur: oh, right.  nm.
08:11:46 <hpc> jmcarthur: yeah, i can reproduce your second example if i explicitly give b a type of Num a => [a]
08:11:53 <rindolf> geekosaur: thanks for your help.
08:12:03 <jmcarthur> briennetheblue, hpc: yeah, i just edited my annotation to force it to be polymorphic
08:12:09 <hpc> and that's just going to be the weird un-sharing behavior of it being class-polymorphic
08:12:13 * geekosaur is just fuddling around; @pl almost never qualifies as helping :p
08:12:20 <jmcarthur> oh!
08:12:23 <jmcarthur> makes sense
08:12:40 <jmcarthur> so sprint is correct there
08:12:42 <hpc> the string one is 100% bug
08:12:45 <jmcarthur> but it's buggy with the string
08:12:53 <hpc> i have a weird one, actually
08:13:17 <hpc> hmm, nvm
08:13:25 <briennetheblue> it made debugging even more confusing and that is a cruel thing to do :(
08:13:51 <jmcarthur> i think this just goes to show how often people really use this feature
08:14:00 <jmcarthur> that is to say, not very
08:14:07 <hpc> it'd be neat to have a unit testing library for strictness
08:14:23 <hpc> that automatically generated nice output of how far each test case is evaluated, input and output
08:14:36 <jmcarthur> that would be nice
08:14:47 <hpc> (output after trying to whnf)
08:14:55 <briennetheblue> i really like that idea
08:15:00 <jmcarthur> you could have a test define an evaluation order for the result and prescribe evaluation patterns on the inputs
08:15:07 <hpc> edwardk: add it to criterion!
08:15:15 <jmcarthur> of course, this would be highly ghc specific
08:15:20 <hpc> oh, certainly
08:15:32 <jmcarthur> both in semantics and in implementation
08:16:04 <hpc> you could probably come up with a way to define the semantics in terms of plain haskell
08:16:11 <hpc> but the implementation would be totally compiler-specific
08:16:49 <hpc> it'd be a very gross specification and probably involve lots of "if this could be bottom then ...."
08:16:54 <jmcarthur> well the thing is that a compiler is technically free to evaluate whatever it wants if it can prove that it doesn't lead to non-termination
08:17:02 <hpc> indeed
08:17:11 <hpc> oh, i see
08:17:18 <hpc> yeah, that does change the semantics...
08:17:55 <jmcarthur> also, i have no idea how to test stuff like par
08:18:56 <hpc> isn't the semantics of par something like "whnf both arguments concurrently and return the second one"?
08:19:42 <hpc> you couldn't observe the concurrency, but you could at least see both arguments being evaluated
08:19:43 <jmcarthur> the semantics is just  par a b is _|_ if b is _|_ otherwise it's b
08:20:09 <hpc> i meant the ghc implementation
08:20:16 <jmcarthur> you would have to somehow want for a to be evaluated before testing
08:20:17 <hpc> with its extra sparkiness
08:20:18 <jmcarthur> *wait
08:20:32 <jmcarthur> but then you might wait forever
08:20:43 <jmcarthur> it's not actually driven by evaluating b
08:20:52 <jmcarthur> it's nondeterministic, if you just sample it after evaluating b
08:21:11 <hpc> that doesn't make sense, how would pseq work then?
08:21:22 <jmcarthur> pseq actually evaluates the first argument and then the second argument
08:21:30 <ski> (unlike `seq')
08:21:39 <hpc> so, in (a `par` b `pseq` f a b)
08:21:41 <jmcarthur> pseq _|_ _ = _|_; pseq _ _|_ = _|_; pseq a b = b
08:21:49 <hpc> at least, in order for it to be useful
08:22:16 <hpc> you have to have a and b both evaluated before starting (f a b)
08:22:23 <jmcarthur> so you evaluate f a b and then test if a and b are evaluated. only b is guaranteed to be evaluated by then.
08:23:11 <hpc> so how is that useful?
08:23:12 <jmcarthur> maybe you mean     (a `par` b `pseq` a `pseq` f a b)
08:23:28 <hpc> does evaluating a in (f a b) get blackholed or something?
08:23:50 <jmcarthur> it might if evaluation of a had already begun by then
08:24:12 <hpc> i don't see how the par/pseq idiom is useful, then
08:24:12 <jmcarthur> (but i think it wouldn't be a blackhole but one of the other holes...)
08:24:27 <hpc> yeah, not blackhole but just blocked on the other spark
08:24:27 <nadirs> prooftechnique: I don't know if you're still there, but I ended up solving the hoogle issue. "hoogle data all" didn't help; though I'm not sure, it was probably some "*.hoo" file floating around, I did a `find / -name "*.hoo*", found one in my home dir (don't know if hoogle reads from there :P). Reinstalled and now it works :D
08:25:04 <jmcarthur> hpc: the usefulness is that a is evaluated in parallel with the other stuff, not that a is forced before the other stuff.
08:25:24 <jmcarthur> hpc: e.g. maybe f doesn't need a until it has already done some other work
08:25:43 <jmcarthur> hpc: or maybe b takes long enough that a is likely to be evaluated by the time you get to f ab
08:25:46 <jmcarthur> *f a b
08:25:55 <hpc> but if f doesn't need b until later, for instance
08:26:02 <jmcarthur> hpc: but there's not a *guarantee* that a is evaluated before f a b
08:26:06 <hpc> then you would rather have (b `par` a `pseq` f a b)
08:26:18 <hpc> that seems tremendously quirky
08:26:38 <jmcarthur> i don't really see the quirkiness you see
08:26:54 <hpc> that the order of the par matters
08:27:00 <jmcarthur> huh?
08:27:15 <jmcarthur> the order of par's arguments?
08:27:22 <hpc> (b `par` a `pseq` f a b) is different from (a `par` b `pseq` f a b)
08:27:32 <hpc> if f wants one argument immediately and the other later
08:27:37 <jmcarthur> how would you propose it work?
08:27:40 <hpc> you will see a marked difference in evaluation time
08:27:50 <jmcarthur> par is not intended to be commutative at all
08:28:13 <hpc> perhaps it should be
08:28:25 <jmcarthur> maybe this is what you are modelling par as:    par :: a -> b -> ()
08:28:35 <jmcarthur> where evaluating the resulting () sparks both arguments
08:28:36 <prooftechnique> nadirs: Oh, good!
08:28:42 <hpc> jmcarthur: yeah, pretty much that
08:28:52 <jmcarthur> that should be expressible with the existing machinery if you prefer that
08:29:24 <hpc> and the benefit of such would be that if you did, say
08:29:51 <jmcarthur> par2 a b = a `par` b `par` ()
08:29:59 <hpc> (a `par` b `par` c `pseq` f a b c), all three of a, b, c are in whnf at the time of evaluating the full expression
08:30:06 <hpc> having been done concurrently
08:30:18 <jmcarthur> no
08:30:21 <jmcarthur> that is still not true
08:30:53 <hpc> par2 a b = a `par` b `pseq` a `pseq` b `pseq` ()
08:31:07 <hpc> or something like that
08:32:25 <jmcarthur> this gives a lot less control to the runtime over how to manage sparks. what if i only want to evaluat a and b speculatively, *in case* i need them later?
08:32:29 <jmcarthur> *evaluate
08:32:55 <jmcarthur> with just par i can express stuff like that. "Evaluate these on the side, maybe, if you have time, because I might need it later."
08:33:50 <hpc> maybe what i want is just (a `par` b `par` f a b) then?
08:34:13 * hackagebot data-lens-template 2.1.8 - Utilities for Data.Lens  http://hackage.haskell.org/package/data-lens-template-2.1.8 (RussellOConnor)
08:34:17 <jmcarthur> i really like sparks. my only complaint about sparks, really, is that we have a spark queue instead of a spark priority queue.
08:34:32 <hpc> how would you prioritize sparks?
08:35:05 <jmcarthur> yeah, that says to start evaluating f a b immediately and evaluate a and/or b in parallel if the chance arises
08:35:33 <hpc> and eliminates what was bugging me, which was that b was getting treated differently from a
08:35:45 <hpc> in that it would always be whnf before f a b, but a might or might not
08:35:52 <hpc> now they are equally un-promised
08:36:23 <jmcarthur> well, for example, i might want sparks generated from deeper recursive calls in some function to get a different priority from sparks generated closer to the beginning
08:36:41 <jmcarthur> depends on how evaluation normally would proceed for this function, i guess
08:36:54 <jmcarthur> ah, so it was actually pseq that you didn't like ;)
08:37:01 <hpc> perhaps ;)
08:37:59 <jmcarthur> anyway... the point is i don't know how to reasonably test this kind of thing
08:38:31 <hpc> i can imagine pseq making a nice "here's how far these sparks can go" kind of thing, though
08:38:39 <joneshf-laptop> is there a flag to print out how a line is parsed?
08:38:40 <joneshf-laptop> with ghc
08:38:51 <joneshf-laptop> or ideally in ghci
08:39:11 <hpc> joneshf-laptop: you mean like printing a full AST or just parenthesization?
08:39:41 <joneshf-laptop> the latter for now, but both would be great
08:39:51 <m09> I have a data structure defining trees as Tree a = Leaf (Int, Int) a | Node (Int, Int) a (Tree a) (Tree a) where the (Int, Int) couples are coordiantes in the tree. I'd like to memoize a function that takes a tree as input thanks to data-memocombinators. I'm not sure how to declare a memoizer for my tree tough. Any idea?
08:40:25 <m09> s/tough/though/
08:40:35 <hpc> joneshf-laptop: i don't know of anything for either off the top of my head
08:40:48 <hpc> for the former you can try printing intermediate output but that's just gross
08:41:01 <hpc> and there probably isn't a stage close enough to source to be useful
08:41:46 <hpc> for the latter i have no idea if such a thing exists
08:43:08 <DR6_> m09: why are the coordinates baked into the tree?
08:43:35 <DR6_> anyway
08:43:56 <DR6_> your Tree type can be written using pairs and eithers recursively
08:44:11 <joneshf-laptop> hpc, hmm okay
08:44:11 <DR6_> and memocombinators provides memoizers for those
08:44:34 <DR6_> with that and the wrap function you should be served
08:44:43 <m09> hum, ok. Thanks for the insight
08:44:44 <hpc> DR6_: that's like solving a pretty-printing problem by saying "turn it into a bytestring"
08:45:08 <DR6_> but what else can you do?
08:46:25 <hpc> write an instance of MemoTable
08:46:51 <DR6_> but for that you need a `Memo a`
08:47:09 <DR6_> the other option would be to write the memoizer directly
08:47:23 <DR6_> but then memocombinators doesn't buy you anything
08:47:43 <jmcarthur> i think the pairs and eithers encoding is just fine
08:48:07 <jmcarthur> it's not like turning it into a bytestring. it still preserves all the properties of the original type.
08:48:31 <jmcarthur> you only do the transformation on the way in to the memo trie. it doesn't have to be your primary representation
08:48:48 <jmcarthur> this is, for what it's worth, the way many of the built in instances work
08:49:40 <jmcarthur> it would be nice to have a memo package that uses generics. maybe there is one already?
08:49:50 <DR6_> Data.Function.Memoize
08:50:33 <DR6_> it has DeriveMemoizable
08:51:11 <prooftechnique> If I hide something during an import that doesn't exist, will the compiler care?
08:51:40 <prooftechnique> e.g., import Data.List hiding (someNonsense)
08:51:56 <jmcarthur> it will probably complain, yes
08:52:02 <hc> didn't know Data.List contained nonsense ;)
08:52:04 <jmcarthur> you could just try it
08:52:07 <DR6_> it doesn't
08:52:13 <jmcarthur> whaaat?
08:52:20 <prooftechnique> I did try it, but I didn't know if there was something I was missing
08:52:24 <prooftechnique> It didn't complain at me
08:52:34 <jmcarthur> wow
08:52:35 <ClaudiusMaximus> prooftechnique: it might give a warning, but otherwise works fine (eg: import Prelude hiding (catch) is quite common)
08:52:35 <DR6_> > import Data.List hiding (sadfqdsfasdfasd)
08:52:37 <lambdabot>  <hint>:1:1: parse error on input `import'
08:52:42 <DR6_> oh well
08:52:48 <DR6_> in ghci it works
08:53:03 <prooftechnique> It throws a warning, but it doesn't actually cause a problem
08:53:18 <jmcarthur> sadness. it may be that i meant to hide a different value from what i actually typed so that i wouldn't accidentally use it (say i don't trust it or intend to use something else instead)'
08:53:23 <jmcarthur> oh a warning
08:53:31 <jmcarthur> okay, then i'm happy enough i guess
08:55:15 <briennetheblue> jmcarthur, hpc: should i make a bug report for that :print thing?
08:55:34 <jmcarthur> briennetheblue: yes!
08:55:38 <briennetheblue> ok
08:55:43 <m09> what I don't get is whyis there a need for the second function in the wrap method of memocombinators? If I can turn my tree into a pair for the memoization that should be enough shouldn't it? The type signature seems to require a function to turn the pair back into a tree
08:56:16 <jmcarthur> joneshf-laptop: btw, i think that you are memoizing a function whose domain is a tree structure suspicious. what are you doing?
08:56:28 <jmcarthur> *is suspicious
08:57:27 <m09> jmcarthur: I need to calculate a value in a dynamic programming fashion
08:57:32 <joneshf-laptop> jmcarthur, you mean m09
08:57:41 <jmcarthur> ah, my bad
08:57:54 <m09> and memoization seemed to me as the simplest way to keep it "functionnal"
08:58:11 <jmcarthur> m09: is this going to be some recursive function that takes a tree as input?
08:58:19 <m09> yup
08:58:29 <jmcarthur> m09: and you'll be calling the memoized recursive function on subtrees?
08:58:46 <m09> well, it's not really a tree, it's more of a DAG
08:58:50 <jmcarthur> right
08:58:59 <jmcarthur> m09: so i'm totally right in being suspicious :)
08:59:04 <m09> why is that?
08:59:13 <monochrom> m09, consider http://www.haskell.org/haskellwiki/Dynamic_programming_example
08:59:33 <jmcarthur> m09: you are going to increase the complexity of your algorithm by a factor proportional to the size of the tree
08:59:49 <jmcarthur> or at least you will not save anything
09:00:07 <b0bbi10> hi, when doing
09:00:08 <jmcarthur> m09: consider that in order to do the lookup in the memo table you will have to traverse the entire argument you pass in
09:00:11 <b0bbi10>     multThree :: (Num a) => a -> a -> a -> a
09:00:11 <b0bbi10>     multThree x y z = x * y * z
09:00:23 <b0bbi10> does x * y * z have to be in the order they were defined?
09:00:34 <m09> jmcarthur: that's not what I want to do, I want to lookup only based on the coords
09:00:40 <jmcarthur> coords?
09:00:41 <b0bbi10> e. g. can I write multThree x y z = z * y * x ?
09:00:55 <jmcarthur> m09: you mean based on which node in memory it is?
09:00:57 <m09> the (x, y) position of the node in the tree
09:01:10 <m09> nah I have even hardcoded the position of the node in my type
09:01:26 <m09> precisely to make memoization easy
09:01:34 <jmcarthur> m09: ah, but there is an easier way!
09:01:35 <monochrom> b0bbi10: both are valid programs. make sure you choose one that satisfies your specification.
09:02:02 <monochrom> I should say s/valid/legal/
09:02:04 <jmcarthur> m09: if it's a DAG in the memory representation then you can use my stable-memo package. you don't even have to store extra data in the nodes.
09:02:04 <m09> I also wanted to avoid State thingies, is that it?
09:02:17 <m09> oh, I'll look into that
09:02:29 <jmcarthur> m09: also, you don't have to write any instances or anything
09:02:46 <b0bbi10> monochrom: ah ok, thanks
09:02:53 <m09> oh, it seems extremely promising
09:06:19 <monochrom> "the garbage collector is chasing you" is a gruesome scene. (see also: movie Robots) :)
09:06:54 <qwebirc66329> is this the right place to ask a comonad question?
09:07:02 <monochrom> a right place
09:07:27 <qwebirc66329> cool: is there a way to express fmap in terms of cojoin and copure?
09:07:44 <jmcarthur> i doubt it
09:07:57 <jmcarthur> maybe in terms of cobind and copure, though?
09:08:48 <qwebirc66329> (<<=) ::  (f a -> b) -> f a -> f b   -- is this cobind?
09:09:03 <jmcarthur> yes
09:09:10 <daimonos> How come --> (($ 4) (+5)) = 9
09:09:13 <qwebirc66329> cool
09:09:21 <qwebirc66329> so how would you do it?
09:09:40 <daimonos> Considering $ takes a functions as it's first arg
09:09:48 <monochrom> let's calculate. ($ 4) (+ 5) = (+ 5) $ 4 = (+ 5) 4 = 4 + 5
09:09:51 <nadirs> daimonos: ($ 4) is a section
09:09:52 <Eduard_Munteanu> qwebirc66329: that's usually called 'extend'
09:10:05 <monochrom> (+ 5) is a function
09:10:10 <daimonos> monochrom: So which is the first arg it took?
09:10:17 <monochrom> (+ 5)
09:10:25 <nadirs> daimonos: (+5) is a section
09:10:26 <daimonos> To me it seemed to take 4 as it's first arg
09:10:30 <monochrom> you can also see it in "(+ 5) $ 4"
09:10:33 <jmcarthur> daimonos:    ($ 4) (+5)  ==>  flip ($) 4 (flip (+) 5)  ==>  ($) (flip (+) 5) 4  ==>  flip (+) 5 4  ==>  (+) 4 5  ==>  9
09:10:38 <daimonos> I don't know ehat a section is
09:10:43 <monochrom> ok, have you read the equations I wrote?
09:10:54 <Eduard_Munteanu> qwebirc66329: whereas cobind = (=>>) = flip (<<=)
09:11:12 <daimonos> monochrom: I have
09:11:26 <nadirs> daimonos: since ($) is an infix function the right-hand argument is the "second" argument
09:11:40 <daimonos> nadirs: Ok nice
09:11:49 <qwebirc66329> do i run copure against f a or against (a -> b)?
09:12:10 <daimonos> > $ 5 (+4)
09:12:11 <lambdabot>  <hint>:1:1: parse error on input `$'
09:12:19 <daimonos> > ($) 5 (+4)
09:12:22 <lambdabot>  5
09:12:23 <Eduard_Munteanu> qwebirc66329: are you asking about comonads or coapplicatives?
09:12:29 <daimonos> nadirs: Ok nice
09:12:29 <nadirs> daimonos: you need parentheses around the whole section
09:12:39 <m09> jmcarthur: I'm not sure why but stablememo doesn't seem to memoize much.
09:12:39 <nadirs> ($ 5)
09:12:52 <daimonos> Infix functions first arg is actully the second arg
09:12:56 <daimonos> Nice
09:13:03 <m09> how would I go about making sure my DAG is indeed a DAG in memory?
09:13:07 <Eduard_Munteanu> qwebirc66329: coapplicatives don't really exist or make sense in Haskell
09:13:25 <jmcarthur> qwebirc66329: how about something like this (correctness no guaranteed)   fmap f a = a =>> \x -> f (copure x)
09:13:27 <jmcarthur> *not
09:13:34 <jmcarthur> m09: you could try something like ghc-vis
09:13:44 <m09> thanks :)
09:13:51 <jmcarthur> m09: if you just mean debugging and not programming techniques
09:14:28 <jmcarthur> m09: the trick would be to use use stable-memo in more places :)  e.g. if you even generate a new DAG from an existing one, you must use memo to preserve the sharing
09:14:37 <jmcarthur> s/even/ever/
09:15:11 <Eduard_Munteanu> Is there something better than '\c -> option () (satisfy c)' or 'void (optional (satisfy c))' somewhere in Attoparsec / Control.Applicative?
09:15:45 <Fuuzetsu> option () . satisfy
09:15:46 <Eduard_Munteanu> That is, skipping zero or exactly one char matching a predicae.
09:15:57 <jmcarthur> m09: if you find that you're getting really confused about what is and isn't being shared, though, maybe it would be worth trying a non-recursive representation. e.g. simulating references with ids and a map. then instead of using stable-memo at all, you would just transform the map lazily
09:16:05 <Eduard_Munteanu> Well, sure, I was asking if there was a combinator for this already.
09:16:31 <Fuuzetsu> I don't recall seeing one.
09:16:32 <m09> jmcarthur: true, I wanted to modify the naive approach the least but that might be the best starting point
09:17:11 <jmcarthur> m09: i personally like using memoization for this kind of thing, but it does have the effect of tying your reasoning to the implementation
09:18:27 <ski> > map ($ 5) [succ,min 2,max 2,(2 +),(2 *),(2 ^),(^ 2)]  -- daimonos
09:18:28 <lambdabot>  [6,2,5,7,10,32,25]
09:19:18 <jmcarthur> daimonos:    (f $)  ==>  ($) f    but    ($ x)  ==>  flip ($) x
09:19:39 <ski> jmcarthur : that comonadic `fmap' looks right
09:20:12 * ski would probably write `=' instead of `==>'
09:20:38 <jmcarthur> ski: meant to represent "desugars to something equivalent to"
09:21:11 <jmcarthur> ski: that is, i'm talking about syntax transformations, not values
09:21:12 <qwebirc66329> i dont know what coapplicative is?
09:21:19 <jmcarthur> qwebirc66329: nothing useful
09:21:26 <qwebirc66329> good
09:21:29 <jmcarthur> qwebirc66329: and not related to comonads, really
09:21:59 <Eduard_Munteanu> (Arguably applicatives aren't related to monads either. :P)
09:22:09 <b0bbi10> how should I read this:
09:22:11 <b0bbi10> flip' f = g
09:22:11 <b0bbi10>     where g x y = f y x
09:22:11 <ski> (though monads are related to applicative functors)
09:22:24 <qwebirc66329> for some reason i cant get this to compile : f <$> a = a =>> \x -> f (copure x)
09:22:36 <ski> b0bbi10 : given a function `f' define a new function `g' depending on it, and then return `g'
09:22:51 <qwebirc66329> also defined  (=>>) = flip (<<=)
09:22:52 <b0bbi10> "flip' takes a parameter f and returns g, which is a function that takes x and y and then?
09:23:04 <jmcarthur> b0bbi10: flip' of f equals g, where g of x and y is equal to f of y and x
09:23:08 <Eduard_Munteanu> ski: sort of a coincidence in the bigger picture of CT
09:23:41 <b0bbi10> ski, jmcarthur: thanks :)
09:23:51 <Eduard_Munteanu> qwebirc66329: f needs to be a   w a -> b
09:23:56 <ski> b0bbi10 : which is a function that takes two arguments, call them `x' and `y', and returns `f' applied to `y' and `x' (in that order)
09:24:06 <Eduard_Munteanu> Err, your lambda, not f.
09:24:38 <jmcarthur> Eduard_Munteanu: is it not already?
09:24:47 <flebron> I'm still not too comfortable with the categorical notion of an applicative functor. Functors themselves, and monads, I understand reasonably well via their diagrams. Applicatives I still understand as "more restrictive monads", but only in their Haskell usage via the monadic definition of ap, not via their categorical notion.
09:24:48 <Eduard_Munteanu> Er, it is, don't mind me.
09:25:23 <ski> qwebirc66329 : fwiw, i'd write it as `f <$> wa = wa =>> \wa -> f (extract wa)' or `f <$> wa = f . extract <<= wa'
09:25:36 <jmcarthur> flebron: here's a more categorical style (but still in haskell):    unit :: f (); prod :: (f a, f b) -> f (a, b)
09:25:36 <ski> (where i prefer the name `extract' to `copure')
09:25:55 <flebron> Yeah, I was shown that link on haskell.org, I should do the homework of proving those two are equivalent :)
09:26:17 <Eduard_Munteanu> flebron: a reasonable simplification would be that applicatives are exponential-preserving functors, IMO.
09:26:21 <flebron> jmcarthur: Is that the way you understand them formally?
09:27:23 <flebron> Eduard_Munteanu: That would seem to be what f (a -> b) -> (f a -> f b) does, yes, but then return comes out of nowhere :p
09:27:43 <jmcarthur> flebron: well of course that presentation is not formal. i am not good at formal presentations of category theory.
09:28:15 <qwebirc66329> awesome thanks ski
09:29:19 <Eduard_Munteanu> flebron: pure is required because you need to be able to translate 'eval' through the functor.
09:29:34 <Eduard_Munteanu> :t liftA2 ($)
09:29:35 <lambdabot> Applicative f => f (b -> c) -> f b -> f c
09:30:03 <ski> qwebirc66329 : anyway, i think of the `wa =>> \wa -> ..wa..' combination as "lifting" the `..wa..' expression into the comonad, while making a "copy" of `wa' (really not quite a copy, more like a "contextual copy")
09:30:05 <qwebirc66329> is there a real world case for using list comonad or a pair comonad
09:30:05 <Eduard_Munteanu> :t \f x -> ($) <$> pure f <*> pure x
09:30:06 <lambdabot> Applicative f => (a -> b) -> a -> f b
09:30:07 <Saizan> :t liftA (uncurry ($))
09:30:07 <lambdabot> Applicative f => f (b1 -> b, b1) -> f b
09:30:30 <troydm> :t (<$>)
09:30:31 <lambdabot> Functor f => (a -> b) -> f a -> f b
09:30:36 <troydm> :t (<*>)
09:30:37 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
09:30:41 <jmcarthur> qwebirc66329: there is no list comonad
09:30:55 <Eduard_Munteanu> qwebirc66329: if you want examples of useful comonads, I think Store / Costate should come first.
09:31:11 <Eduard_Munteanu> There's a stream comonad, though.
09:31:17 <jmcarthur> qwebirc66329: the pair comonad is equivalent in power to the reader monad
09:32:04 <ski> qwebirc66329 : i've been pondering a syntactic extension where `(=>>) @\wa -> ..wa..' would expand to `(=>>) wa (\wa -> ..wa..)' -- which would make this idiom a bit nicer
09:32:19 <jmcarthur> qwebirc66329:    (r, a) -> b   ~   r -> a -> b   ~   a -> r -> b  ~  a -> Reader r b
09:32:28 <ski> (or maybe `\@' would be better than `@\')
09:32:32 <thaicares> I need to add /.cabal/bin so that I can run programs from it through terminal
09:32:43 <Eduard_Munteanu> ski: is that a snail operator? :)
09:32:50 <thaicares> I'm on Debian if that helps (testing)
09:32:52 <ski> Eduard_Munteanu : if you'd like :)
09:34:13 <qwebirc66329> here is an example : id <<= (1 :. 2 :. 3 :. 4 :. Nil)   yields [[1,2,3,4],[2,3,4],[3,4],[4]]
09:34:18 <monochrom> yes, add $HOME/.cabal/bin to PATH
09:34:29 <jmcarthur> qwebirc66329: what does this yield?   id <<= []
09:34:42 <monochrom> choice of doing that addition in .profile or .bashrc
09:34:46 <jmcarthur> qwebirc66329: err, ignore that
09:34:55 <jmcarthur> qwebirc66329: what does this yield?   extract []
09:35:19 <b0bbi10> if I got "flip' f y x = f x y" and call "flip' f <value>" does something "happen" already or do I just a partially applied function back with the 'y' "bound" to '<value>'?
09:35:40 <jmcarthur> b0bbi10: you will have to define what you mean by "happen" there
09:35:42 <monochrom> nothing happens already
09:35:58 <thaicares> monochrom .bashrc ?
09:36:08 <monochrom> yes, one choice is .bashrc
09:36:15 <thaicares> I've never had to do this before...
09:36:28 <monochrom> what have you done before?
09:36:30 <qwebirc66329> you are right: not a Comonad but an Extend ie Comonad missing copure
09:36:39 <b0bbi10> jmcarthur: I guess what monochrom just said, will something be done/ applied to the 'y' when an argument is given for that?
09:37:09 <thaicares> so just add a new line in the txt file "$HOME/.cabal/bin" ?
09:37:18 <jmcarthur> b0bbi10: in ghc, you will just get a closure. in other implementations (none that i know of, but theoretically possible) you could get back a function that has been specialized somewhat. either way, nothing *observable* has happened.
09:37:59 <b0bbi10> that's probably what I mean, thanks guys :)
09:38:22 <monochrom> no, not that simple. unfortunately I am too lazy to detail what to do in small steps
09:38:43 <jmcarthur> b0bbi10: also, note that ghc will very often inline flip, so it may be that there is no runtime step involved at all :)
09:38:51 <jmcarthur> b0bbi10: almost always, in fact
09:40:22 <thaicares> Don't worry... http://www.troubleshooters.com/linux/prepostpath.htm
09:40:23 <b0bbi10> do you know that feeling when you learn something weird (like Haskell) and then it just does 'click' and you know how that works?
09:40:27 <b0bbi10> that moment's awesome!
09:40:35 <thaicares> the internet PROBABLY can fix me :)
09:40:41 <briennetheblue> yup
09:41:15 <monochrom> yeah, that is a much better tutorial than I would ever write
09:44:01 <fizruk> is there a flipped version of <|>?
09:44:13 <monochrom> I had few clicks in Haskell. I had more clicks in math. Haskell was too easy.
09:45:01 <monochrom> instead, when learning Haskell, my most frequent flashes of thought was: "why doesn't every language do this?"
09:45:05 <fizruk> i would like to write something like this: def <|> {- some big expression here -}
09:46:30 <fizruk> placing def after big expression is not nice, and making a separate function can be overkill (big expression might be 2-lines do-block)
09:46:47 <monochrom> example: you can generalize from "Maybe Int" to "m Int", not just "Maybe a". why doesn't every language support this?
09:46:58 <fizruk> so I though there might be a flipped version of <|> for this case
09:47:16 <dwcook> fizruk, put the big expression on a binding in a where block
09:47:17 <monochrom> example: you have static types. why doesn't every language support this?
09:47:39 <fizruk> dwcook: nice idea, thanks!
09:48:32 <monochrom> example: you can define your own "control" structures like "myif True y z =y; myif False y z = z" and "forever t = t >> forever t". why doesn't every language support this?
09:48:56 <monochrom> that last point is pretty deep. it requires non-strictness. why isn't every language non-strict?
09:49:23 <b0bbi10> I checked google already: how cna I join several predicates with the && operator? filter ((>3) (&&) (>4)) [1, 2, 4] doesn't work
09:50:01 <dwcook> @pl \x -> x > 3 && x > 4
09:50:01 <lambdabot> liftM2 (&&) (> 3) (> 4)
09:50:03 <monochrom> and need I mention lambda? (I learned Haskell around 2000. most languages had not jumped on the lambda bandwagon yet.)
09:50:08 <companion_cube> monochrom: because otherwise every language would be haskell?
09:50:40 <monochrom> ok, so why doesn't every language meet or exceed Haskell?
09:51:09 <b0bbi10> dwcook: haven't learnt about liftM2 yet, is there any other way with just the && operation?
09:51:33 <dwcook> b0bbi10, no, you'd need at least some sort of combinator because (&&) doesn't do that
09:51:57 <companion_cube> monochrom: why doesn't Haskell have dependent types? ;)
09:53:00 <dmj`> anyone use haskell-mode w/ cabal sandboxes?
09:54:18 <dwcook> b0bbi10, though if you're not comfortable using a combinator, you can of course write it the way I wrote what I fed to the pointless plugin.
09:54:48 <monochrom> I know how to answer that, companion_cube. http://www.vex.net/~trebla/humour/tautologies.html #2
09:55:12 <jmcarthur> b0bbi10: well, let's think about this... we have predicates   type P a = a -> Bool  and we want a way to combine them  (&) :: P a -> P a -> P a,  so it probably looks something like this:  (f & g) x = f x && g x   and from experience you will recognize this pattern, so it can become   (f & g) x = liftA2 (&&) f g x    or even   (&) = liftA2 (&&)
09:55:13 <monochrom> actually I should generalize it. it is not just software.
09:55:19 <b0bbi10> dwcook: well, I am not sure I understand your piece of code, I was just asking because LYAH says "The filter equivalent of applying several predicates in a list comprehension is either filtering something several times or joining the predicates with the logical && function. " and I didn't know how to do that
09:55:42 <monochrom> tautologies are most general when worded most generally :)
09:55:48 <dwcook> b0bbi10, I think it was referring essentially to what I did. Are you familiar with lambdas?
09:56:21 <b0bbi10> dwcook: I know lambdas from Python (anonymous functions)
09:56:22 <jmcarthur> b0bbi10: if you just want to use (&&) in a single filter without using liftA2/liftM2 or anything else...   filter (\x -> pred1 x && pred2 x)
09:56:38 <b0bbi10> but not sure if lambdas are the same in Haskell
09:56:43 <jmcarthur> b0bbi10: since (&&) expects booleans, not functions
09:57:01 <dwcook> b0bbi10, yeah, that's the basic idea. \x -> y is a function with a parameter x that results in y.
09:57:28 <companion_cube> monochrom: your answer applies equally well to your previous questions :
09:57:29 <companion_cube> :)
09:57:40 <dwcook> b0bbi10, so \x -> x > 3 && x > 4 takes some x, an element from your list let's say, and tells you whether it's greater than 3 and greater than 4 (which is redundant, but meh :P)
09:57:52 <monochrom> dang it
09:57:53 <dmj`> > (&&) <$> (>4) <*> (<3) $ 4
09:57:53 <b0bbi10> jmcarthur, dwcook: ah ok, think I get that now, thank you
09:57:55 <lambdabot>  False
09:58:18 <monochrom> fortunately, I wrote those tautologies long after I had learned haskell
09:58:51 <prooftechnique> Oh, god, hoogle data all just finished
09:59:50 <dwcook> monochrom, at least one of your tautologies is… *gasp* tautological!
09:59:50 <monochrom> "if you're 20 and don't want every language to exceed haskell, you have no heart. if you're 40 and don't accept that most languages are inferior to haskell, you have no brain" :)
10:01:53 <gauthier_> http://lpaste.net/101633 I don't get where this a1 is coming from
10:02:50 <dwcook> gauthier_, the a in delimit and remaining are named the same but are not necessarily equal
10:03:11 <dwcook> gauthier_, take off the type signature from remaining and it will be inferred correctly
10:03:52 <dwcook> I think there's also an extension you can enable if you really want to give it a signature, but I forget which one
10:04:07 <gauthier_> dwcook: got it thanks :)
10:04:17 <monochrom> dwcook: are you, by chance, referring to #6? it arose when shachaf and I were pondering on some math. he had some very minimal premise and asked how much could be concluded. we discussed some variations and concluded: the more [premises] you know, the more [conclusions] you know.
10:06:12 <dwcook> monochrom, oh I wasn't thinking of one in particular, it just seemed like a safe statement to make :P
10:06:23 <monochrom> haha yes absolutely!
10:07:07 <nadirs> prooftechnique: are you enjoying your 2GB of new data? ;P
10:08:05 <monochrom> hmm, how many GBs are there on hackage?
10:08:43 <monochrom> last time I heard was about 2GB or 4GB or something. something definitely below 10GB, even 5GB.
10:09:23 <monochrom> I'm thinking flash memories and hard disks could advertise themselves as, e.g., "64GB: it can fit 16 hackages!"
10:10:34 <nadirs> haha
10:10:51 <monochrom> or ISPs and phone data plans could advertise: "16GB per month: you can download hackage 4 times!"
10:11:05 <nadirs> new meme coming: "hackage for scale"
10:16:30 <prooftechnique> nadirs: I am :D
10:23:41 <joneshf-laptop> how can i write this with the correct kind: deriving instance (Show s, Show u, Show m, Show a) => Show (Operator s u m a)
10:23:47 <joneshf-laptop> where Operator isL http://hackage.haskell.org/package/parsec-3.1.5/docs/Text-Parsec-Expr.html#t:Operat
10:23:54 <joneshf-laptop> err
10:23:56 <joneshf-laptop> http://hackage.haskell.org/package/parsec-3.1.5/docs/Text-Parsec-Expr.html#t:Operator
10:24:29 <joneshf-laptop> or is there a better way to do this?
10:25:21 <joneshf-laptop> since apparenrly `m` needs kind `* -> *`
10:25:33 <byorgey> joneshf-laptop: what are you trying to do?  There's no way you can derive a Show instance for Operator, since it contains ParsecT which contains functions
10:25:46 <byorgey> even aside from the kind problems
10:26:29 <joneshf-laptop> ohh
10:27:19 <Fuuzetsu> how would one solve the kind problem in case where everything actually was Showable
10:27:38 <joneshf-laptop> ^
10:27:45 <daimonos> is: ZipList [x] == ZipList (repeat x)
10:28:18 <joneshf-laptop> >  ZipList [x] == ZipList (repeat x)
10:28:19 <lambdabot>  No instance for (GHC.Classes.Eq
10:28:20 <lambdabot>                     (Control.Applicative.ZipList Debug.SimpleReflect.Expr.Expr))
10:28:20 <lambdabot>    arising from a use of `GHC.Classes.=='
10:28:20 <lambdabot>  Possible fix:
10:28:20 <lambdabot>    add an instance declaration for
10:28:27 <joneshf-laptop> oh well theres one problem
10:28:30 <joneshf-laptop> but it shouldn't be
10:29:45 <daimonos> > Control.Applicative.ZipList [x] == Control.Applicative.Ziplist (repeat x)
10:29:47 <lambdabot>  Not in scope: data constructor `Control.Applicative.Ziplist'
10:29:47 <lambdabot>  Perhaps you meant one of these:
10:29:47 <lambdabot>    `Control.Applicative.ZipList' (imported from Control.Applicative),
10:29:47 <lambdabot>    `Control.Applicative.Const' (imported from Control.Applicative)
10:29:49 <joneshf-laptop> because if that were the case then `ZipList [] == Ziplist (repeat x)`  would be true
10:30:00 <joneshf-laptop> right?
10:30:22 <joneshf-laptop> or `ZipList [x,x] == ZipList (repeat x)`
10:31:09 <joneshf-laptop> and then using transitivity you get `ZipList [] == ZipList [x]`
10:31:11 <joneshf-laptop> or some such
10:31:38 <joneshf-laptop> and reflexivity
10:31:43 <joneshf-laptop> erm
10:32:15 <daimonos> joneshf-laptop: I don't get what you mean. you can pass ZipList an empty list [] but I am not sure how I'd pass repeat an empty value.
10:32:18 <joneshf-laptop> symmetry
10:32:41 <joneshf-laptop> unless of course you'renot required to obey those laws for Eq
10:32:45 <joneshf-laptop> then all bets are off
10:33:19 <daimonos> joneshf-laptop: I want to obey the laws of Eq
10:33:34 <joneshf-laptop> daimonos, then subtitute `ZipList []` for `ZipList [x,x]`
10:34:39 <monochrom> laws of Eq:
10:34:45 <monochrom> 1. reflexive
10:34:50 <monochrom> 2. symmetric
10:34:52 <daimonos> joneshf-laptop: I can't even picture ZipList [x,x]
10:34:54 <monochrom> 3. transitive
10:35:13 <monochrom> 4. Leibniz: if x==y, then for all f, f x == f y
10:36:16 <daimonos> > ZipList [1,2]
10:36:18 <lambdabot>  No instance for (GHC.Show.Show (Control.Applicative.ZipList a0))
10:36:18 <lambdabot>    arising from a use of `M839357956082468786926676.show_M8393579560824687869...
10:36:18 <lambdabot>  Possible fix:
10:36:18 <lambdabot>    add an instance declaration for
10:36:18 <lambdabot>    (GHC.Show.Show (Control.Applicative.ZipList a0))No instance for (GHC.Num.N...
10:37:28 <joneshf-laptop> daimonos, what do you mean?
10:38:32 <daimonos> Ok I think I have it
10:39:02 <daimonos> repeat creates an infinite list. I thought it added "[]" around a stuff.
10:39:14 <joneshf-laptop> daimonos, oh
10:39:22 <daimonos> Which makes `pure x = ZipList (repeat x)` really weird
10:39:24 <joneshf-laptop> daimonos, well that's how pure is defined for it
10:39:29 * hackagebot kan-extensions 4.0.2 - Kan extensions, Kan lifts, various forms of the Yoneda lemma, and (co)density (co)monads  http://hackage.haskell.org/package/kan-extensions-4.0.2 (EdwardKmett)
10:39:35 <joneshf-laptop> daimonos, it makes sense because of laziness
10:40:03 <daimonos> Well it does but if you don't use a take or foldr stuff can blow up in your face
10:40:22 <joneshf-laptop> or if you use vectors
10:43:51 <daimonos> That is too dangerous. I think pure x ZipList [x] would be better but I haven't tried checking if it follows functor laws
10:44:13 <daimonos>  `pure x == ZipList [x]'
10:44:29 * hackagebot adjunctions 4.0.3 - Adjunctions and representable functors  http://hackage.haskell.org/package/adjunctions-4.0.3 (EdwardKmett)
10:44:42 <exicer> I want to create an infinite list of tuples, where each successive tuple is the result of a function that takes one of the previous tuples as an argument. Is there some function that can help me here ?
10:45:26 <DR6_> but the repeat one is the one that follows the applicative laws
10:45:59 <DR6_> like pure f <*> l = f <$> l
10:46:33 <jmcarthur> daimonos: it does indeed violate some laws
10:46:39 <DR6_> if it was pure x = ZipList [x] the first would return the first element
10:47:23 <monochrom> exicer: does "iterate" help? iterate f x = [x, f x, f (f x), ...
10:48:10 <exicer> monochrom: It might.. I am not sure how I can reference the previous tuple, however!
10:49:11 <DR6_> does "one of the previous tuple" mean an arbitrary previous tuple?
10:49:19 <DR6_> rather than the previous one?
10:49:37 <exicer> DR6_: I mean the previous one
10:49:39 <exicer> :
10:49:46 <exicer> Should have made that clear!
10:49:48 <DR6_> then iterate does what you want
10:50:03 <DR6_> you don't need to "reference" the previous one
10:50:12 <exicer> DR6_: Ah, true!
10:50:16 <exicer> Cool, thanks :)
10:50:59 <monochrom> in f (f x), f x is already the previous item
10:51:10 <monochrom> how about this?
10:51:12 <monochrom> @src iterate
10:51:12 <lambdabot> iterate f x =  x : iterate f (f x)
10:51:32 <monochrom> err, maybe not enlightening. nevermind.
10:51:41 <monochrom> just believe everything we say :)
10:51:55 <daimonos> Products of human egestion seem to have hit the rotating ventilation device.
10:53:33 <Fuuzetsu> > iterate (+1) 0
10:53:34 <lambdabot>  [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,2...
11:00:39 <joneshf-laptop> > iterate (second (+1)) (0,0)
11:00:40 <lambdabot>  [(0,0),(0,1),(0,2),(0,3),(0,4),(0,5),(0,6),(0,7),(0,8),(0,9),(0,10),(0,11),(...
11:01:09 <creswick> does anyone know how to use custom token types with parsec? I'm running into type errors I don't understand (small example here: http://lpaste.net/101635)
11:01:35 <Peaker> Why is the data constructor SomeAsyncException not exported?
11:02:32 <Peaker> how can I mark an exception I'm throwTo'ing as asynchronous, so it isn't caught as a synchronous one?
11:03:05 <startling> creswick, I think it needs to be "Steam s Identity [(Text, Tag)]"
11:03:28 <startling> er, sorry, misreading the classes / types
11:04:18 <creswick> startling: np
11:04:43 <exicer> joneshf-laptop: Is second different from snd some how ?
11:04:59 <yitz> @type snd
11:05:00 <lambdabot> (a, b) -> b
11:05:02 <yitz> @type second
11:05:03 <lambdabot> Arrow a => a b c -> a (d, b) (d, c)
11:05:17 <Eduard_Munteanu> > second (+1) (2, 5)
11:05:18 <lambdabot>  (2,6)
11:05:31 <yitz> um - here, think of "a b c" as "(b -> c)"
11:05:42 <startling> creswick: what type does posTok get inferred as?
11:05:47 <exicer> I don't know anything about arrows.. should possibly have a read
11:05:49 <creswick> I've been wondering if it's related to why the stream type that ghc expects doesn't seem to make the connection between the token type and the stream type
11:05:57 <Eduard_Munteanu> > (subtract 1 *** (+1)) (2, 5)
11:05:58 <lambdabot>  (1,6)
11:06:02 <yitz> so second :: (b -> c) -> (d, b) -> (d, c)
11:06:49 <creswick> startling:  just a sec… I pulled this out of my project to use ghci, and I'm not sure how to get type suggestions
11:06:52 <exicer> yitz: Okay, perhaps I will just think of it like that for now..
11:07:14 <yitz> exicer: it's an interesting topic, but unnecessary for understanding "second".
11:07:17 <startling> creswick: comment out things that fail to type-check, say :t posTok in ghci
11:07:21 <exicer> Eduard_Munteanu: What does *** mean ?
11:07:28 <startling> :t (***)
11:07:29 <lambdabot> Arrow a => a b c -> a b' c' -> a (b, b') (c, c')
11:07:47 <exicer> yitz: From what I have read, they seem to have been popular a while ago, but no longer.
11:07:53 <startling> :t (***) `asAppliedTo` (undefined :: a-> b)
11:07:54 <lambdabot> (a -> b) -> (b' -> c') -> (a, b') -> (b, c')
11:08:05 <Eduard_Munteanu> exicer: it makes an arrow that processes inputs in a parallel fashion
11:08:12 <creswick> startling:  edited to add type http://lpaste.net/101635
11:08:27 <exicer> Eduard_Munteanu: Okay, hmm
11:08:36 <Eduard_Munteanu> > (f *** g) (a, b)
11:08:37 <lambdabot>  No instance for (Debug.SimpleReflect.Expr.FromExpr c'0)
11:08:37 <lambdabot>    arising from a use of `e_1'
11:08:37 <lambdabot>  The type variable `c'0' is ambiguous
11:08:37 <lambdabot>  Possible fix: add a type signature that fixes these type variable(s)
11:08:37 <lambdabot>  Note: there are several potential instances:
11:08:50 <yitz> exicer: cdsmith wrote an interesting series of blog posts in which he showed that Applicative is pretty much equivalent to Arrow in practice.
11:09:06 <Eduard_Munteanu> > (f *** g) (a, b) :: (a, b)
11:09:07 <lambdabot>  No instance for (Debug.SimpleReflect.Expr.FromExpr b1)
11:09:08 <lambdabot>    arising from a use of `Debug.SimpleReflect.Vars.g'
11:09:08 <lambdabot>  Possible fix:
11:09:08 <lambdabot>    add (Debug.SimpleReflect.Expr.FromExpr b1) to the context of
11:09:08 <lambdabot>      an expression type signature: (a1, b1)
11:09:30 <Iceland_jack> > ((-1 +) *** (+ 1)) (2, 5)
11:09:31 <lambdabot>  (1,6)
11:09:32 * hackagebot unfoldable 0.7.2 - Class of data structures that can be unfolded.  http://hackage.haskell.org/package/unfoldable-0.7.2 (SjoerdVisscher)
11:09:45 <yitz> exicer: well, Applicative + Category
11:09:53 <yitz> @google cdsmith applicative arrow
11:09:55 <lambdabot> http://cdsmith.wordpress.com/2011/08/13/arrow-category-applicative-part-iia/
11:09:56 <lambdabot> Title: Arrow = Category + Applicative? (Part IIa) | Sententia cdsmithus
11:10:09 <startling> creswick: aha. I think you want that to be "Stream s Identity [(a, a1)]" instead.
11:10:11 <exicer> yitz: Cool. I shall add it to my ever growing list :p
11:10:50 <startling> oh, no.
11:11:09 <yitz> exicer: but the functions first, second, ***, &&&, and >>> from Control.Arrow remain ever popular. :)
11:11:10 <startling> it needs to be "Stream [(a, a1)] Identity (a, 1)".
11:11:34 <creswick> startling: yeah.. I'm trying with a more concrete version of that inferred type sig…
11:11:34 <startling> creswick: I think specifying that type signature will work.
11:14:43 <creswick> startling:  this works, but note that the actual parser example at the bottom is commented out: http://lpaste.net/101635
11:16:20 <creswick> startling:  putting that back in results in another variation on the stream instance missing error: No instance for (Stream [(Text, Tag)] Identity (Text, Tag))
11:17:45 <Tekmo> Assume I have a computation of type `example :: IO Void`.  How can I prove from the type alone that `example >>= f = example`?  Intuitively, I understand why this is true but I don't know how to prove it
11:19:51 <joneshf-laptop> question about this: https://ghc.haskell.org/trac/ghc/wiki/DefaultSuperclassInstances#Designgoal2:writeimplementationsofsub-classesthatimplytheirsuperclassimplementations
11:19:58 <startling> creswick: hm, odd. There's an instance Monad m => Steam [s] m s right here: http://hackage.haskell.org/package/parsec-3.1.5/docs/Text-Parsec-Prim.html#t:Stream
11:20:07 <joneshf-laptop> so the Functor instances between Traversable and Applicative don't have to match?
11:20:36 <creswick> startling:  *nods* that's what has me confused!
11:20:54 <lucch> Hello, is anyone using the package 'couchdb-conduit' ? I need some help regarding 'cabal hell' and this package..
11:21:07 <bennofs> Tekmo: f is of type Void -> IO Something. To extract the IO, you'd need to pass it a Void, which is impossible, which means that the result of f can never be used (or is this waht you mean by "intutive"?)
11:21:16 <startling> creswick: can you add the actual error?
11:21:18 <Tekmo> bennofs: Yeah, that's the intuitive explanation
11:21:20 <Eduard_Munteanu> Tekmo: assuming extensionality you can reason that f = return . id
11:21:27 <benmachine> Tekmo: is it even true in the presence of bottoms?
11:21:44 <creswick> startling:  it's up: http://lpaste.net/101637
11:21:56 <creswick> startling:  (at the very bottom)
11:21:57 <Tekmo> Eduard_Munteanu: What does it mean to assume extensionality?
11:22:01 <Tekmo> benmachine: I'm fine with disregarding bottom
11:22:17 <Eduard_Munteanu> Tekmo: that is, forall x, f x = return x trivially, since Void is empty
11:22:27 <monochrom> Tekmo: cannot. a counterexample is counterexample = f >> counterexample
11:23:04 <Eduard_Munteanu> Tekmo: and extensionality means f = g if f x = g x, forall x
11:23:07 <benmachine> monochrom: how do you distinguish between counterexample >>= f and counterexample?
11:23:12 <creswick> startling:  updated again, putting a type sig on parseNoun
11:23:50 <monochrom> that is not what I wrote
11:24:01 <monochrom> I wrote counterexample = f >> counterexample
11:24:16 <monochrom> in counterexample = f >> counterexample, the effect of f happens infinitely often.
11:24:36 <monochrom> in example = example >>= f, the effect of f happens infinitely never.
11:25:26 <Peaker> Is there any library with a simple Time data-type (like NominalDiffTime) but with functions like: seconds :: Double -> Time ; microseconds :: Integer -> Time ; etc?    (P.S: threadDelay really ought to use such a type)
11:25:33 <Eduard_Munteanu> I read it as an equality rather than a definition.
11:25:40 <Tekmo> Eduard_Munteanu: Just give me a second to understand that
11:25:45 <Peaker> and not have some implicit/implied unit of time?
11:26:18 <Eduard_Munteanu> Peaker: don't you get that with Data.Time + Data.Fixed?
11:26:59 <monochrom> I read that as equality too
11:27:24 <Eduard_Munteanu> Nevermind, Peaker is looking for a nicer API, not that.
11:27:27 <Peaker> Eduard_Munteanu: The problem with vanilla Fixed is that the type doesn't carry around what units it has
11:27:31 <Tekmo> Eduard_Munteanu: So what are the `f` and `g` that you are proving extensionally equal?
11:28:13 <Eduard_Munteanu> Tekmo: you're proving that all fs are equal to return.
11:28:59 <Eduard_Munteanu> Tekmo: so you can apply the   example >>= return = example   law.
11:29:04 <Peaker> hmm.. "DiffTime" actually seems close to what I want
11:29:14 <Tekmo> Eduard_Munteanu: The part I have trouble with is proving all `f`s are equal to `return`
11:29:31 <creswick> startling:  aha! that instance is not defined in the parsec modules i'm importing — it's defined in Text.Parsec.String
11:29:44 <creswick> startling:  adding that import fixed it.
11:29:51 <startling> creswick: ugh, what a pain
11:30:00 <lucch> i'm using the feature of cabal sandboxes in a personal project.. now i need to persist the application data in CouchDB and, for that, i'm trying to cabal install the package 'couchdb-conduit'... It happens that this package has conflicting dependencies with the ones i'm already using and upgrading the package's dependencies is difficult (there are many deps and the versions are much older)..  Could someone please tell what's the prop
11:30:12 <creswick> startling:  yeah! had to grep the unpacked source to find it.
11:30:16 <creswick> startling:  thanks for the help!
11:30:23 <Eduard_Munteanu> Tekmo: let f :: Void -> IO Void. Pick an 'x' :: Void, compute 'f x' and compare to 'return x'. It's vacuously true.
11:30:37 <Tekmo> Eduard_Munteanu: Yes, but what if the return value of `f` is not `Void`?
11:30:53 <Tekmo> Eduard_Munteanu: (>>=) :: IO Void -> (Void -> IO Int) -> IO Int
11:31:12 <startling> lucch, you can probably add it to your dependencies, rm -rf .cabal-sandbox, and cabal install --dependencies-only
11:31:13 <Eduard_Munteanu> Tekmo: then you can apply the principle of explosion, namely forall a. Void -> a, usually called bot-elim
11:31:21 <startling> lucch: if that doesn't work you need to loosen some of your bounds
11:32:20 <Eduard_Munteanu> Tekmo: wait, what equality would you want for that one?
11:32:39 <Tekmo> Eduard_Munteanu: The same equality: example >>= f = example
11:32:53 <Eduard_Munteanu> Tekmo: that'd be a type error, no?
11:32:55 <lucch> startling: thank you for your reply.. i've already tried that and didn't work.. :// isn't there any way to install two versions of the same package at the same sandbox?
11:32:59 <Tekmo> Eduard_Munteanu: Oh yeah.  Hmm
11:33:05 <startling> lucch: no.
11:33:10 <startling> lucch: this isn't sandbox-related, btw
11:33:23 <startling> lucch, (you'd get the same issues outside of a sandbox)
11:33:37 <Tekmo> Eduard_Munteanu: Okay, what about:
11:33:52 <startling> lucch, this is affectionately known as "cabal hell". You need to loosen your dependency versions more. :)
11:33:58 <Tekmo> Eduard_Munteanu: example >>= f = fmap absurd example
11:34:35 * hackagebot tables 0.4.1 - In-memory storage with multiple keys using lenses and traversals  http://hackage.haskell.org/package/tables-0.4.1 (EdwardKmett)
11:34:43 <Eduard_Munteanu> Tekmo: then it's what I said above, absurd being bot-elim.
11:35:06 <lucch> startling: so.. conclusion is: either i change all my code to use the older versions (as the package i'm trying to install) or don't use the package, right?
11:35:16 <startling> lucch: correct
11:35:31 <startling> lucch: (or patch the existing library to use modern versions)
11:35:47 <Tekmo> Eduard_Munteanu: I get that `absurd` is the proof that anything is reachable from `Void`, but I don't get how that completes the proof
11:35:52 <lucch> startling: nice.. thank you.. i'm new to haskell and this is the first time a came here.. :) i'm glad i can find quick and useful help..
11:36:09 <startling> lucch: no problem! sorry there's not a better answer.
11:37:18 <Tekmo> Eduard_Munteanu: So if I understand correctly, I can reduce the problem to proving `f = return . absurd`
11:37:37 <Eduard_Munteanu> Tekmo: yeah
11:37:39 <lucch> startling: yeah.. i think i can make myself a simle package to interface couchdb.. after all, it seems to be just aeson + http-conduit..
11:37:40 <Tekmo> Eduard_Munteanu: I think the missing piece of the puzzle is proving that `absurd` is unique
11:37:56 <startling> lucch: that's another option, yeah
11:38:41 <Eduard_Munteanu> Tekmo: it needn't, forall x, f x = return (absurd x) is vacuously true.
11:39:06 <Peaker> funny to have DiffTime in picoseconds.. I doubt any timer available is even close to that resolution -- DiffTime is missing a bunch of extra convenience functions
11:39:10 <Peaker> (for micros, millis, etc)
11:39:27 <Tekmo> Eduard_Munteanu: Why?
11:39:36 <Fuuzetsu> just because _you_ don't have a picosecond-capable timer, Peaker
11:40:02 <Eduard_Munteanu> Tekmo: there are no xs, so the proposition is true forall x. :)
11:40:16 <Tekmo> Eduard_Munteanu: OOOOOOOH
11:40:20 <Tekmo> Eduard_Munteanu: Okay, now I get it
11:40:23 <Peaker> Fuuzetsu: perhaps it should use some sort of planck time interval?
11:40:32 <Tekmo> Eduard_Munteanu: Thanks for explaining that!
11:40:41 <Eduard_Munteanu> Sure, alright.
11:42:04 <Fuuzetsu> Peaker: gotta be future proof
11:42:45 <nadirs> has anyone managed to `cabal install hakyll` lately?
11:44:44 <Peaker> Fuuzetsu: at the expense of the present :)
11:49:33 <Tekmo> nadirs: Are you getting errors?
11:49:46 <nadirs> Tekmo: failing dependencies
11:49:58 <Tekmo> nadirs: Did you install the Haskell Platform first?
11:50:35 <avaritia> any datatype suggestions for writing a raytracer in haskell? i'm running with lists wrapped in newtype but that doesnt have too good performance
11:50:49 <nadirs> yes, I have ghc 7.6.3 and cabal 1.18
11:50:55 <nadirs> Tekmo: ^
11:51:40 <Tekmo> nadirs: Can you use `lpaste.net` to paste the error so I can study it more closely?
11:52:08 <Tekmo> nadirs: One trick, if the error is lost in a bunch of successful computations, is to repeat the `cabal install hakyll` command
11:52:14 <SwashBuckla> what does the ((!)) do on the line:  import Text.Blaze.Html5 ((!))   ?
11:52:15 <Tekmo> nadirs: That will then output just the errors
11:52:27 <Eduard_Munteanu> SwashBuckla: it imports only (!)
11:52:54 <nadirs> Tekmo: ok, let me run it again (I've cleaned so I have to re-run the whole thing)
11:52:55 <Tekmo> SwashBuckla: The outer parentheses is for the import list.  The inner parentheses is because stand-alone operators require a parentheses around them
11:53:02 <Tekmo> nadirs: That's fine.  I can wait
11:53:12 <Tekmo> SwashBuckla: Sort of how in Haskell you can define: add = (+)
11:54:41 <SwashBuckla> Eduard_Munteanu: Where in the Text.Blaze.Html5 documentation is the function (!)?
11:54:45 <SwashBuckla> I can't seem to find it
11:56:06 <Fuuzetsu> SwashBuckla: why don't use the Index that Haddock generates for you to find it?
11:56:29 <Tekmo> SwashBuckla: In the top-right corner of the documentation is the link to the Index
11:56:37 <Fuuzetsu> http://hackage.haskell.org/package/blaze-html-0.7.0.1/docs/doc-index-33.html
11:57:46 <Fuuzetsu> perhaps it isn't exported
11:58:10 <nadirs> Tekmo: this is the second run → http://lpaste.net/101640
11:58:30 <jmcarthur> Tekmo: i like to define Void like this, so that absurd is trivial:    newtype Void = Void (forall a. a)
11:58:56 <nadirs> I tried installing the failing packages on their own but it seems a "turtles all the way down"-kind-of situation
11:59:34 <nadirs> I also tried to install hakyll in a cabal sandbox (which is my main interest, by the way)
11:59:40 <nadirs> but I get the same troubles
12:03:37 <nadirs> if I try installing `alex` it fails on `happy` which in turn fails on `happy` (?)
12:05:53 <byorgey> nadirs: do you have ~/.cabal/bin on your PATH ?
12:06:25 <nadirs> byorgey: Ido :)
12:06:28 <nadirs> *I do
12:07:22 <nadirs> in fact I have it on top of PATH so I can override my system's cabal (which is version 1.16)
12:10:08 <Tekmo> nadirs: So the `happy` command is not anywhere on your PATH?
12:10:24 <nadirs> Tekmo: exactly
12:10:38 * geekosaur hopes that $PATH does not literally have ~/.cabal/bin in it (~ only works in the shell)
12:11:30 <nadirs> geekosaur: PATH contains the absolute path ;)
12:12:04 <nadirs> Tekmo: I'll try installing happy from pacman
12:12:33 <Tekmo> Yeah, that's a good idea
12:12:48 <NikolajK> IO monad: Should I think of appliactions of it as: "I write the whole long function and with the IO monad I can break up that computation is several parts and interact with the world"?
12:13:27 <Tekmo> NikolajK: Think of the IO monad as a first-class subroutine
12:13:45 <Tekmo> NikolajK: You can pass subroutines around as ordinary values
12:13:58 <Tekmo> NikolajK: (>>=) and (>>) are just ways to connect subroutines together
12:16:27 <nadirs> Tekmo: ok, I've installed happy as a system package → `cabal install hakyll` still failed → `cabal install alex`: succeded → hakyll succeded. Thank you!
12:18:12 <nadirs> looking at hakyll's package description on hackage it seems it's missing alex as build-depends probably
12:19:40 * hackagebot intervals 0.4.2 - Interval Arithmetic  http://hackage.haskell.org/package/intervals-0.4.2 (EdwardKmett)
12:22:23 <absence> what is the alternative to using Arrow for frp? Applicative? is reactive banana the primary example of this, or are there others? can netwire be used without the Arrow instances?
12:23:18 <NikolajK> Tekmo: Okay, but how to understand >>=. It takes values of 'm a' and 'a -> m b'
12:23:18 <NikolajK> passing subroutines around isn't enough
12:23:24 <NikolajK> for me to understand it
12:25:13 <Quashie> so let's say you were trying to do something IO
12:25:20 <dwcook> NikolajK, under one understanding, it lets you choose the next thing to "do" based on the result of the last thing. This applies for IO, for example
12:26:05 <Quashie> and you just had some naive thing where each subroutine was just a -> IO b
12:26:23 <Quashie> then at the end you'd have IO IO IO IO IO IO IO h
12:26:29 <Quashie> for each subroutine
12:27:01 <monochrom> um, what does that mean?
12:27:32 <Quashie> >>= prevents that, so for example in the example of IO it takes 'IO a' and 'a -> IO b' and gives you back an 'IO b'
12:27:55 <startling> Quashie: yep. The "naive thing" is fmap.
12:28:05 <startling> :t fmap putStrLn getLine
12:28:06 <lambdabot> IO (IO ())
12:28:21 <startling> :T (=<<) putStrLn getLine
12:28:25 <startling> :t (=<<) putStrLn getLine
12:28:26 <lambdabot> IO ()
12:28:38 <klrr_> :t fmap . fmap . fmap . fmap
12:28:39 <lambdabot> (Functor f, Functor f1, Functor f2, Functor f3) => (a -> b) -> f (f1 (f2 (f3 a))) -> f (f1 (f2 (f3 b)))
12:28:58 <startling> :t (=<<) . (=<<) . (=<<) . (=<<)
12:28:59 <lambdabot> Monad m => (a -> m b) -> m (m (m (m a))) -> m b
12:29:11 <Quashie> the fact that there is a mapping (m (m a) -> m a) is one of the ways you can define what a monad is
12:29:37 <Quashie> in particular it's an operation that a monad has that an applicative doesn't necessarily have
12:29:48 <startling> oh, sorry, I confused you with NikolajK
12:29:59 <monochrom> Is there any reason why you think everything you have said answers the question?
12:30:46 <startling> haha
12:31:06 <tavoe> I'm using Scotty. It's html function takes a Data.Text.Lazy.IO. I can read a file as IO ...Lazy.IO, but I can't extract the ...Lazy.IO from it to pump into the html function. It seems like a core concept I'm missing. Hoogle recomends a function unsafePerformIO, but that sounds... unsafe??
12:32:02 <startling> tavoe: I think you're confused
12:32:08 <tavoe> I do too
12:32:27 <startling> tavoe: "Data.Text.Lazy.IO" is a module, not a type
12:32:43 <tavoe> I'm using Scotty as a web server. I'm trying to load a html file, then send it over the network.
12:32:55 <tavoe> OH! You're right. I'm using the getFile function from the module
12:32:58 <tavoe> Sorry
12:33:06 <startling> tavoe: "Data.Text.Lazy.IO" provides some functions with the return type "IO Text"
12:33:29 <startling> tavoe: there's probably some way to use IO in whatever scotty's type is
12:33:35 <startling> probably liftIO
12:34:00 <NikolajK> should I think of the uppercase names, e.g Tree in "Tree Char" or Maybe in "Maybe Int" as telling me in which type class the Char resp. Int has wandered?
12:34:36 <meiji11> I'm writing a language interpreter in haskell, that uses this large-ish, monolithic eval function. periodically, this language uses IO. I'm wondering how to elegantly handle those cases that require IO without wrapping the eval function in the IO monad.
12:34:37 <startling> tavoe: yeah. something like liftIO (getFile myPath) >>= html should work
12:34:47 <meiji11> or, if simply wrapping it in IO would be a kosher thing to do.
12:34:48 <monochrom> no. you should think of the uppercase names as "not a variable"
12:35:00 <tavoe> ok. Looking at that now. Thank you
12:35:36 <meiji11> by 'wrapping in IO' I mean pushing IO down in the monad transformer stack that the eval function now operates in.
12:35:38 <jmcarthur> meiji11: if you want your interpreter to do IO it will have to at least return some IO A
12:35:41 <monochrom> also, Tree and Maybe are not type classes
12:36:00 <meiji11> jmcarthur: right, exactly. but IO actions are funny. they can contain things that aren't run until you open the box, in some sense.
12:36:12 <jmcarthur> meiji11: they are just values
12:36:43 <startling> meiji11: one way to do it is to parametrize eval by the monad which its result is computed in
12:36:46 <meiji11> jmcarthur: yes, but isn't that what necessitates IO? IO orders effects so that they occur in the specified order, I thought.
12:36:59 <Apocalisp> What is the dual of a distributive law?
12:37:01 <meiji11> startling: yeah, I had attempted something like that, but bungled it.
12:37:08 <jmcarthur> meiji11: a lot of people analogize (>>=) as "opening the box and applying a function to it, then closing the box again", but that is a lie. the "box" is not opened at all. there is no box.
12:37:20 <jmcarthur> meiji11: in fact, an IO String doesn't contain a String at all
12:37:24 <meiji11> startling: I'm not sure how to get the pieces parameterized on IO, and those parameterized on some other monad, usually Identity, to play nicely together.
12:37:30 <startling> @quote shachaf ls
12:37:30 <lambdabot> shachaf says: <dmwit> CReal is the computable reals. <shachaf> Just like CInt is the computable integers!
12:37:38 <startling> @quote /bin/ls
12:37:38 <lambdabot> shachaf says: getLine :: IO String contains a String in the same way that /bin/ls contains a list of files
12:37:42 <Apocalisp> f (a * b) -> f a * f b
12:37:42 <jmcarthur> ^^
12:37:44 <meiji11> jmcarthur: I've been scarred by those analogies, I guess. :P
12:37:58 <orbital_> hi
12:38:08 <startling> meiji11, you can pass in e.g. a "Map variable (Function m Value)"
12:38:14 <Apocalisp> f a + f b -> f (a + b) -- what is this called?
12:38:16 <jmcarthur> meiji11: IO is not for controlling order of execution, but for describing imperative programs.
12:38:35 <orbital_> (/ x) <- does this imply out-of-order currying? How does it know?
12:38:40 <startling> meiji11, then eval :: Map variable (Function m Value) -> Expression variable -> m Value somehow
12:38:41 <jmcarthur> meiji11: or, a bit more than that, for describing imperative programs that can call pure functions
12:38:54 <startling> orbital_, (/ x) = \a -> a / x
12:38:55 <monochrom> meiji11: it looks to me eval's type can be legitimately "String -> IO Answer" or "String -> Either EvalError (IO Answer)" or "String -> IO (Either EvalError Answer)". replace String by whatever you use.
12:39:12 <benmachine> jmcarthur: "there is no box" ← then you'll see that it is not the box that opens, it is only your mind?
12:39:27 <monochrom> in other words, I don't see why you should avoid IO, if the semantics of your language is about I/O.
12:39:37 <startling> ^ this too
12:39:49 <startling> but sometimes it's nice to be able to say "this expression can run without IO"
12:39:58 <jmcarthur> meiji11: my point is, it totally makes sense that the resulting *value* returned by your evaluator is an IO action of some sort
12:40:02 <startling> (at the type level)
12:40:04 <orbital_> startling: right, i'm just trying to understand how that works. Is it something special that () knows how to do with ifnix functions?
12:40:08 <jmcarthur> meiji11: and I don't think that should be considered dirty.
12:40:19 <startling> orbital_: it's special syntax, yeah
12:40:23 <Apocalisp> orbital_: Yeah, that's magic built-in syntax
12:40:26 <startling> orbital_, they're called "sections"
12:40:28 <monochrom> alright, then generalize from IO to some type class. but I prefer doing it concretely, specifically IO first. specific before general.
12:40:39 <orbital_> aha, sections
12:40:47 <orbital_> startling Apocalisp : thanks
12:41:11 <monochrom> also, generalizing from IO to some type class still does not avoid IO
12:41:39 <startling> right, but it provides a way to avoid IO
12:41:50 <startling> (if some members of that type class are not IO)
12:42:00 <jmcarthur> I think this tendency to "avoid IO" missed the point of IO.
12:42:30 <startling> Maybe. I think running a subset of a language in a pure way is a worthy goal, though.
12:42:34 <quchen> "Avoid unnecessary IO."
12:42:37 <jmcarthur> IO is pure!
12:43:05 <meiji11> jmcarthur: eval doesn't need IO most of the time, so to center all the action in IO, via a monad transformer, seems inappropriate.
12:43:05 <jmcarthur> In the pedantic sense and in the practical sense.
12:43:18 <meiji11> jmcarthur: but I have no idea, really. I'm a beginner.
12:43:20 <monochrom> my main point is: what is the semantics of your language? then code up exactly that semantics.
12:43:39 <monochrom> you can say, "the semantics is I/O". then it's IO.
12:43:44 <jmcarthur> meiji11: I would argue that the problem is not that IO is involved but that you are constraining your whole interpreter to a single context (this big monad you're constructing).
12:43:46 <meiji11> its an impure language, so.. ok. :P
12:44:15 <monochrom> you can also say, "the semantics is a general abstract thing. a specialization is I/O." then it's a general abstract thing. a specialization is IO.
12:44:16 <jmcarthur> meiji11: you should drop the parts you don't use in contexts that you don't need them
12:44:30 <meiji11> jmcarthur: it's exactly StateT (Either ErrorMsg) m a.
12:44:34 <jmcarthur> meiji11: and then lift them in the more powerful monad as you get closer to the top level of your interpreter
12:44:36 <monochrom> it's completely tautological. but humans tend to try very hard to violate obvious tautologies.
12:44:37 <meiji11> m ~ Identity, currently.
12:45:05 <jmcarthur> meiji11: That is not a valid type. What is the last argument to Either?
12:45:14 <meiji11> meiji11: sorry, left that out. It's a.
12:45:27 <thaicares> anyone familiar with gitit?
12:45:28 <monochrom> it's why my tautologies are such deep wisdom to those humans.
12:45:33 <meiji11> It really should be StateT s (Either ErrorMsg) m a.
12:45:34 <jmcarthur> meiji11: That does not form a monad. :)
12:45:45 <jmcarthur> now i'm more confused
12:45:46 <meiji11> something to that effect, I know the type signature is a little off.
12:45:51 <monochrom> it's relative. it tells you the level of humans.
12:46:06 <meiji11> ok, it's StateT s (EitherT ErrorMsg (m a)). I think that should be right.
12:46:07 <jmcarthur> meiji11: if you unwrap all those goofy transformers, what do you end up with?
12:46:23 <meiji11> a state transformer on an either that wraps m a.
12:46:23 <jmcarthur> meiji11: do you mean   StateT s (EitherT ErrorMsg m) a?
12:46:33 <meiji11> jmcarthur: yes, seems correct.
12:46:37 <Algebr> How can I get something like `print :t show` ?
12:46:51 <monochrom> cannot. not easily.
12:48:09 <meiji11> jmcarthur: that's exactly it.
12:48:10 <jmcarthur> meiji11: okay, so, let's say you have some function you call from your eval function that needs most of that transformer stack, but doesn't care whether m ~ Identity or m ~ IO
12:48:39 <meiji11> jmcarthur: sure.
12:48:41 <jmcarthur> meiji11: all you have to do is *not* specialize it for IO. leave it polymorphic in m.
12:49:18 <jmcarthur> meiji11: sure, it will end up being IO when you use it in eval, but the type guarantees you aren't using IO where you don't need it.
12:49:27 <monochrom> I suspect that "(MonadIO m)" is eventually a necessary constraint on m
12:49:49 <meiji11> jmcarthur: ah, ok. I realize that I have some difficulty understanding exactly how polymorphic types are specialized, if that's the word I want.
12:50:44 <meiji11> jmcarthur: I didn't think this approach would work, previously.
12:50:53 <jmcarthur> meiji11: if you have a function that returns a   StateT s (EitherT ErrorMsg m) a  then it *can't* use m as though it is IO. If it did, it would have to return a  StateT s (EitherT ErrorMsg IO) a
12:51:33 <jmcarthur> meiji11: (or at least constrain m further somehow)
12:52:18 <meiji11> jmcarthur: it can't use m as anything other than a monad, I thought.
12:52:27 <meiji11> jmcarthur: ie. only bind and return apply.
12:52:48 <jmcarthur> meiji11: that's right. if m is totally unconstrained except for (Monad m), you can only use Monad stuff
12:53:16 <meiji11> jmcarthur: right, but doesn't that effectively forbid eval from interacting with functions that aren't polymorphic on m?
12:53:24 <meiji11> or values, I should say.
12:53:28 <jmcarthur> meiji11: eval would still have IO in place of m
12:53:38 <jmcarthur> meiji11: but eval would use functions that leave m polymorphic
12:54:00 <jmcarthur> meiji11: those functions would be the ones that don't need that extra IO power
12:55:09 <jmcarthur> yes, s/functions/values/ for more generality
12:55:59 <tommd> @bots
12:55:59 <lambdabot> :)
12:56:00 <jmcarthur> meiji11: eval can *also* use values that specialize m to IO, since eval itself specializes it to IO
12:56:14 <jmcarthur> meiji11: but that doesn't mean all values eval uses must specialize it to IO
12:56:37 <meiji11> jmcarthur: ok, that makes sense. eval should specialize to IO, other stuff.. as needed.
12:56:40 <jmcarthur> meiji11: so long as they don't specialize m to something else
12:57:09 <meiji11> jmcarthur: right.
12:57:14 <meiji11> thank you for your help.
12:57:17 <jmcarthur> np
12:57:36 <jmcarthur> i hope it was actually helpful and not just a bunch of information with apparent application
12:57:39 <jmcarthur> *without apparent
12:59:10 <meiji11> jmcarthur: no, I see it fits together. I was mainly confused over the appropriate use of IO.
12:59:15 <meiji11> s/it/how it
13:00:33 <jmcarthur> meiji11: note that this is not the only way to do it, but given that you are using transformers and (apparently) not all those mtl type classes, this is probably the best way to fit IO into it without it creeping into places it isn't needed.
13:00:57 <meiji11> how would you write an interpreter without monad transformers?
13:01:04 <jmcarthur> depends on the interpreter
13:01:09 <meiji11> since you're constantly passing all this state around and want to be able to catch errors on the fly..
13:01:15 <meiji11> it's a simple lisp interpreter.
13:01:28 <jmcarthur> are you following some sort of tutorial or something?
13:01:48 <meiji11> I looked write yourself a scheme .. a while ago, but I'm doing this on my own for fine.
13:01:50 <meiji11> fun.
13:01:54 <meiji11> not sure why that came out as fine.
13:02:34 <jmcarthur> transformers are only conveniences, of course, they always can be inlined.
13:03:07 <jmcarthur> sometimes transformers hide nice properties about your code. sometimes transformers *explain* nice properties about your code. whether they are good to use is just situation dependent.
13:03:50 <jmcarthur> maybe if you have a simple subset of your interpreter done i could show you an alternative way to write it
13:03:51 <meiji11> they're hiding lots of boilerplate. which is nice.
13:04:19 <jmcarthur> i think the point of view that transformers are for "plumping" and "boilerplate" is not quite in line with what I think they are for.
13:04:23 <jmcarthur> *plumbing
13:04:30 <jmcarthur> plumping is a weird typo
13:04:36 <meiji11> heh.
13:05:05 <jmcarthur> In most cases, I find that transformers actually add *more* boilerplate. :(
13:05:13 <meiji11> it's pretty similar to write you a scheme.
13:05:23 <jmcarthur> except when using the type classes of mtl, i suppose
13:05:25 <meiji11> how's that? with the lifting, etc?
13:05:33 <NikolajK> how can I ask ghci which classes exist atm?
13:06:05 <meiji11> oh wow, I have to go.
13:06:17 <jmcarthur> but worse... transformers don't really explain the purpose of designing your type the way you do. for example, if I'm using reader, I get this nice "ask" function, but what am I asking for exactly?
13:06:21 <jmcarthur> not explained by the name
13:06:36 <jmcarthur> okay. take luck!
13:06:54 <meiji11> yes, you too. thanks again for the help.
13:09:46 * hackagebot stm-conduit 2.3.0 - Introduces conduits to channels, and promotes using  conduits concurrently.  http://hackage.haskell.org/package/stm-conduit-2.3.0 (ClarkGaebel)
13:15:11 <NikolajK> whwhen I've installed a package (semigroups in my case) by going to the folder and calling "cabal install", should I consequently be able to use the functions defined there after I call ghci?
13:15:56 <jmcarthur> NikolajK: as long as you import the relevant modules, yes
13:16:02 <edwardk> NikolajK: yes, you'll need to import Data.Semigroup or what have you first, but the modules are available to you then
13:16:02 <lucch> NikolajK: yes, but inside ghci you should type: ":m + <module name>"
13:17:14 <NikolajK> what is :m?
13:20:17 <lucch> NikolajK: type ":help" inside ghci.. it allows you to load a module..
13:20:57 <lucch> NikolajK: it's the same of typing: "import Your.Module.Name"
13:21:15 <hooplahoops> Hey, I have 'hs-source-dirs' set in my cabal file, but when I do 'cabal build' it says 'cabal: can't find source for Foo/Bar in ., dist/build/autogen', how come?
13:23:37 <hooplahoops> Ooh nevermind, I have to put that under 'library', otherwise it is ignored
13:23:41 <hooplahoops> Thanks :)
13:23:53 <hooplahoops> You guys are the best teddy bears
13:25:13 <dagle> Well, :m allows you to do things import wont? Like unloading etc?
13:27:02 <lucch> dagle: I think you are right..  ":m - Your.Module.Name" unloads the module.. I think you can't do that using "import"...
13:29:38 <td123> any tips on debugging "thread blocked indefinitely in an MVar operation" errors?
13:29:46 <td123> it's in another library
13:29:57 <td123> but I know which one
13:31:03 <Student200> hi
13:31:09 <Student200> what is the most compact way to say this:
13:31:12 <Student200> foo xs = if (length xs) == 0 then "" else ","
13:31:29 <hpc> case xs of [] -> ""; _ => ","
13:31:34 <td123> if null xs then "" else ","
13:32:00 <Iceland_jack> > [ "," | null "hi" ]
13:32:01 <Eduard_Munteanu> foo [] = ""; foo _ = ","
13:32:01 <lambdabot>  []
13:32:02 <Iceland_jack> > [ "," | null "" ]
13:32:03 <lambdabot>  [","]
13:32:09 <Iceland_jack> hm..
13:32:12 <Iceland_jack> never mind :)
13:32:16 <arpunk> haha :D
13:32:26 <Iceland_jack> Needs a join
13:32:26 <Iceland_jack> > join [ "," | null "hi" ]
13:32:27 <lambdabot>  ""
13:32:28 <Iceland_jack> > join [ "," | null "" ]
13:32:29 <lambdabot>  ","
13:32:53 <td123> Student200: are you trying to join strings with a "," ?
13:33:05 <Student200> yes sir
13:33:16 <Student200> list elements to be precise
13:33:37 <ezrios> > intercalate "," ["foo", "bar", "baz", "quux"]
13:33:38 <lambdabot>  "foo,bar,baz,quux"
13:33:52 <td123> was gonna mention intercalate then :)
13:34:01 <Student200> thanks!
13:34:02 <Iceland_jack> Student200: Not everyone here is male for future reference :)
13:34:14 <Student200> :)
13:34:17 <ezrios> > intercalate "," . map show $ [1,2,3,4]
13:34:18 <lambdabot>  "1,2,3,4"
13:34:40 <c_wraith> Odds suggest that out of nearly 1250 people, there are probably more women than bots present.
13:35:15 <theorbtwo> But are there more women then steves?
13:35:22 <ezrios> but more idlers than women
13:35:39 <path[l]> I wish there were more gender neutral pronouns and words in english
13:36:12 <Iceland_jack> path[l]: 'they' and 'their' are decent
13:36:20 <Iceland_jack> “I was answering their question”
13:36:21 <path[l]> yeah but its also plural
13:36:25 <path[l]> it sucks having to use it
13:36:28 <Iceland_jack> not neccesarily
13:36:33 <path[l]> the rules of grammar change deliberately around it
13:36:47 <theorbtwo> path[l]: English is actually very good about that compared to many languages.  In German, for example, nouns refering to things that are in no way people are still gendered.
13:37:00 <path[l]> like “he is” “they are”
13:37:02 <Iceland_jack> path[l]: You can use 'their' to refer to someone of unspecified gender
13:37:04 <path[l]> you cant say “they is”
13:37:07 <ezrios> theorbtwo: same with French
13:37:18 <path[l]> theorbtwo: yeah, hindi too
13:37:46 <Iceland_jack> http://dictionary.reference.com/browse/their
13:37:46 <Iceland_jack>     (used after an indefinite singular antecedent in place of the definite masculine form his  or the definite feminine form her  ): Someone left their book on the table. Did everyone bring their lunch?
13:38:16 <path[l]> I know, I use it all the time. But it would be nice if we evolved a new pronoun that was singular and gender neutral
13:38:21 <Student200> intercalate doesnt work in my case cos separator and list elements must have same type
13:38:35 <path[l]> I heard that some people have started using “yo” as a gender neutral pronoun
13:38:40 <path[l]> but that hasnt become mainstream yet
13:38:41 <Iceland_jack> People have attempted to in many languages, languages are just very tricky
13:38:46 <Eduard_Munteanu> :t intersperse
13:38:46 <Iceland_jack> Swedish has ‘hon’
13:38:47 <lambdabot> a -> [a] -> [a]
13:38:49 <monochrom> I support getting rid of both gender and singular-plural.
13:39:01 <theorbtwo> There have been many attempts, none have caught on.
13:39:02 <Eduard_Munteanu> > intersperse ',' "Hello"
13:39:03 <lambdabot>  "H,e,l,l,o"
13:39:18 <Eduard_Munteanu> Student200: like that? ^^
13:39:42 <zomg> path[l]: yo mama?
13:39:54 <theorbtwo> Gendered pronouns are also somewhat handy; they allow at least limited reference to two different people via pronoun.
13:39:56 <zomg> gives a new meaning to those jokes!
13:39:56 <Student200> let's say im trying to do something like intercalate "," [1,2,3]
13:40:12 <ion> That’s a type error.
13:40:14 <Cale> > intercalate "," ["1","2","3"]
13:40:15 <lambdabot>  "1,2,3"
13:40:19 <raek> Iceland_jack: in swedish, "han" and "hon" mean "he" and "she". the new debated pronoun is "hen"
13:40:24 <Cale> > intercalate "," . map show $ [1,2,3]
13:40:25 <lambdabot>  "1,2,3"
13:40:25 <theorbtwo> One of the reasons that crypto examples use Alice and Bob.
13:40:28 <Iceland_jack> raek: ah right, that's what I meant
13:40:36 <Iceland_jack> Student200: First you need to turn the list into a list of strings
13:40:38 <Student200> i know, my list actually has custom data type..t.hats why i was using if ..then..earlier
13:40:45 <raek> which sounds the same as Finnish "hän" which is gender neutral
13:40:48 <path[l]> theorbtwo: that’s pretty cool, I never thought about that
13:40:53 <tdammers> "shklee"
13:41:11 <zomg> Should be worth pointing out that all person pronouns in finnish are gender neutral
13:41:22 <Student200> i already have Show implemented
13:41:22 <ion> tdammers++
13:41:37 <Iceland_jack> Student200: Then you can map show over the list and use intercalate
13:41:42 <Student200> thanks Iceland
13:41:47 <DR6_> but that's when you just happen to have a male person and a female person
13:42:08 <theorbtwo> DR6_: Yeah.  "At least limited".
13:42:27 <DR6_> I really don't think it's worth it
13:42:35 <tdammers> DR6_: "It's not that simple. Gender is a multi-faceted continuum!"
13:42:47 <DR6_> yeah exactly
13:42:51 <theorbtwo> Of course, in informal language, you can get away with just calling multiple people "he" and hoping the listener can work out which one you meant.
13:43:00 * Iceland_jack says something about gender being a leaky abstraction
13:43:06 <theorbtwo> ...or you can just repeat people's names.
13:43:32 <theorbtwo> Iceland_jack: No, sex is an abstraction over how people take a leak, gender's the social one.
13:43:32 <DR6_> if you shorten the names they shouldn't take more than two or three syllables
13:43:35 * theorbtwo ducks.
13:43:42 <monochrom> we need variable bindings
13:43:58 <DR6_> both are continuums
13:44:19 <theorbtwo> monochrom: The party of the first person thinks that would get unwealdy.
13:44:23 <monochrom> let {x = John McCarthy; y = x's father} in x is a nice guy, y raised x very well
13:45:00 <ezrios> let's all speak in predicate logic
13:46:04 <colDrMcBeardman> grammatical gender has more to do with getting things to sound right when inflected than it does with the physical/sexual gender of the noun.
13:52:59 <Student200> how to apply map to custom data types?
13:53:22 <monochrom> what does that mean?
13:53:26 <Student200> i have data Set a = Set [a]
13:53:34 <Student200> and want to apply map to it
13:53:53 <Student200> e,g, map foo (Set [1,2,3])
13:54:19 <monochrom> f (Set x) = Set (f x)
13:54:22 <monochrom> err
13:54:23 <Fuuzetsu> perhaps Functor class is what you're after
13:54:25 <monochrom> f (Set x) = Set (map f x)
13:54:30 <monochrom> err, that's still wrong
13:54:36 <monochrom> f g (Set x) = Set (map g x)
13:54:54 <Fuuzetsu> :t let f :: a -> b; f = undefined in fmap (map f)
13:54:55 <lambdabot> Functor f => f [a] -> f [b]
13:56:47 <DR6_> Just use DeriveFunctor
13:59:23 <xil> Hi everyone. I'm having some problems I can't figure out building Hoogle. I wanted to get the command line Hoogle working so I could search through the gtk package. I'm on Debian and the repos don't have a package for Hoogle so I was using cabal to build it. Here is what happens http://lpaste.net/101645 and I can't figure out what to do about it. I unpacked the tar and looked at General.hs and it seems to define its own (===) method. I 
14:07:37 <ADexter_>         rev   = toEnum $ fromEnum 'z' - fromEnum small + fromEnum 'a'
14:07:56 <ADexter_> sry, that was a mistake
14:08:24 <Student200> how to use :t foo in expressions? e.g. main = print $ :t foo
14:08:31 <monochrom> cannot
14:08:32 <quchen> xil: You might have an incompatible version of QuickCheck installed already. It started exporting (===) with version 2.7.
14:08:51 <Student200> is there any way to display variable type, non-interactively?
14:09:05 <xil> the constraints on the hoogle package include "QuickCheck -any" though
14:09:31 <xil> I can forcibly install a pre 2.7 version though? I guess that might be worth a shot?
14:09:35 <geekosaur> Student200, why would you want to? types do not exist at runtime
14:09:48 <dmj`> typeOf in Data.Typeable
14:09:54 <quchen> xil: You can try this in a sandbox so you don't destroy your original package DB
14:10:07 <meretrix> Student200: In ghc-7.8 there's a feature called "holes" that might help.
14:10:10 <geekosaur> (unless you do something liek that but that brings in constraints that represent types; they're niot actual types though)
14:10:14 <dmj`> Student200: but you shouldn't need to unless you're doing something advanced
14:11:09 <xil> quchen: is there an established way to sandbox this kind of stuff, or would I just do something like configuring cabal to install to a new user directory and doing it all there?
14:11:17 <Student200> here's a different question....i create same string in 2 different ways
14:11:43 <monochrom> get rid of QuickCheck 2.7. then cabal install --constraint="QuickCheck==2.6.*" hoogle
14:11:43 <Student200> when i put both into a tuple and print the tuple, one string has quotes around it, the other doesnt
14:12:08 <monochrom> show actual code.
14:12:20 <Iceland_jack> Student200: If the two strings behave differently they're not the same string
14:12:32 <Student200> main = print $ (s,rez2)     produces    ({1,2,3},"{1,2,3}")
14:12:53 <Iceland_jack> rez2 is probably something like 'show s'
14:12:53 <Student200> monochrome, the code is > 10 lines long
14:13:01 <monochrom> do you need to keep s and rez2 secret?
14:13:03 <Iceland_jack> Student200: Use lpaste
14:13:04 <Student200> yes thats right, monochrome
14:13:05 <Iceland_jack> @lpaste
14:13:05 <lambdabot> Haskell pastebin: http://lpaste.net/
14:13:51 <Iceland_jack> > let (s, rez2) = ([1,2,3], show s) in (s, rez2) -- I'm guessing it's something like this
14:13:52 <lambdabot>  ([1,2,3],"[1,2,3]")
14:14:05 <monochrom> but then s is no longer a string
14:14:24 <neversaynever> hi
14:14:50 <Iceland_jack> monochrom: If Student200 did 'print (s, rez2)' and s does not have quotes it wasn't a string in the first place?
14:14:55 * hackagebot HaRe 0.7.2.0 - the Haskell Refactorer.  http://hackage.haskell.org/package/HaRe-0.7.2.0 (AlanZimmerman)
14:15:19 <ADexter> hey never
14:15:35 <neversaynever> in ghci, when i load my .hs file, i get an error saying :"114:54: parse error on input `::' ". but in my .hs file, there's not a file on column 54
14:15:38 <monochrom> I'm referring to: [1,2,3]
14:15:59 <neversaynever> sorry not "file", i mean there's not a character on column 54
14:16:02 <monochrom> please tell me you know that [1,2,3] is not a string. please.
14:16:04 <quchen> xil: The simple-and-stupid solution to compiling executables without dependency issues is doing it entirely in a sandbox, similar to this: http://www.haskell.org/cabal/users-guide/installing-packages.html#sandboxes-basic-usage
14:16:09 <Iceland_jack> monochrom: Sure?
14:16:12 <Student200> monochrome, i show u in pvt?
14:16:19 <Student200> is homework
14:16:24 <monochrom> I do not accept pvt.
14:16:28 <ADexter> @neversaynever could you lpaste your code? maybe its an indent error or something from a line above
14:16:28 <lambdabot> Unknown command, try @list
14:16:46 <Student200> ADexter is homework solution , icant share it with everyone
14:16:47 <xil> quchen: awesome! Thank you!
14:17:58 <quchen> xil: I'm not entirely sure how `cabal install`ing an executable from a sandbox works, but I don't think I've had many issues with it in the past. But I also haven't done it terribly often or recent.
14:17:59 <ADexter> neversaynever: is there a line in 114? have you tried removing it? have you tried removing all type signatures, to check if the error changes?
14:19:10 <ADexter> neversaynever: have you copied some lines from the interwebs maybe? Sometimes utf8 is a bitch
14:19:19 <xil> quchen: the problem happens when I `cabal build` too, so I should be able to test it without running into that problem. I figure it if builds then I can just downgrade my main QuickCheck and install outside
14:19:57 <quchen> xil: Oh you mean in the sandbox? Yeah you'll have to specify that you want an old QuickCheck, like monochrom suggested above.
14:20:28 <quchen> Otherwise you'll just do the same (broken) thing in the sandbox as before without it.
14:20:46 <xil> quchen: yeah, that's the plan
14:20:47 <tavoe> so. I'm sure this is a standard thing. I've got a setup like this: readFromFile >>= \fileContent -> print fileContent. What if I want to read from the file, then call print and emailToMyself on the content? Can I feed from a bind into two functions? Or do I need a special version of print that both prints and passes on the value?
14:21:30 <monochrom> readFromFile >>= \fileContent -> print fileContent >> email fileContent
14:21:39 <monochrom> there is also a do-notation version
14:22:02 <neversaynever> ADexter: i put a blank line and it gives the error at that line.	let trade = Trade account (read order)::Int (read side)::Side symbol (read volume)::Volume
14:22:12 <monochrom> memory cost: this will cause memory to be spent to hold all of fileContent for a while
14:22:13 <neversaynever> the problem is at the 'volume'
14:23:49 <monochrom> also, great news! the memory spent is at least 2*64*(length fileContent) bits
14:23:54 <Student200> main = print $ (s,rez2)     in this , s is not a string indeed, rez2 is a string,  I have implemented the show method for type of s, so that's why it prints
14:24:00 <Student200> ({1,2,3},"{1,2,3}")
14:24:08 <Student200> so in a way, that strips off the quotes
14:24:10 <tavoe> very good news!
14:24:19 <monochrom> a string gets quotes, a non-string does not.
14:24:23 <tavoe> any idea what the do noation way would be?
14:24:46 <monochrom> or rather: a string gets quotes when printed, a non-string gets no quotes when printed.
14:24:50 <Student200> monochrome, but in my Show implementation , i build a string manuall, with ++ and eveyrthing
14:24:57 * hackagebot free 4.6 - Monads for free  http://hackage.haskell.org/package/free-4.6 (EdwardKmett)
14:25:02 <geekosaur> but you do not call show on that string
14:25:12 <geekosaur> do you understand the difference?
14:25:28 <edwardk> ^- now with real free Alternatives
14:25:31 <Student200> yes, for my custom type, my custom SHow is called
14:25:38 <NikolajK> is Hask Carterian closed?
14:25:38 <monochrom> you can add more quotes to your Show implementation if you like
14:25:48 <NikolajK> cartesian*
14:25:53 <edwardk> NikolajK: 'more or less'
14:25:56 <Student200> hahaha no monochrome, im trying to exterminate them
14:25:57 <monochrom> indeed, Show implementation of [Char] adds more quotes
14:26:06 <NikolajK> what's missing
14:26:11 <NikolajK> (,) and -> is there
14:26:15 <ADexter> neversaynever: I'm just a beginner, but that amount of type casting doesn't seem right
14:26:16 <edwardk> NikolajK: it is more about how (,) is lifted.
14:26:18 <geekosaur> then don't call show on a String
14:26:31 <edwardk> NikolajK: so 'yes if you ignore pedantry about bottoms'
14:26:59 <edwardk> NikolajK: http://hackage.haskell.org/package/categories-1.0.6/docs/Control-Category-Cartesian-Closed.html
14:27:21 <NikolajK> ah, is this releted to how (bottom,bottom) is bottom or not?
14:27:26 <edwardk> NikolajK: yes
14:27:43 <NikolajK> only read keywards in the Haskell history paper
14:29:02 <edwardk> anyways, ignoring that yes, it is very productive to view Hask as a cartesian closed category
14:30:18 <NikolajK> does bottom relate to non-termination of lambda terms?
14:30:37 <b0bbi10> how does right folds work on infinite lists? Oo
14:30:53 <b0bbi10> LYAH: One big difference is that right folds work on infinite lists, whereas left ones don't!
14:31:02 <monochrom> some right folds do not work on infinite lists.
14:31:46 <quchen> monochrom: How does the 2 in the above "2*64" come about? I would expect the file to be read into memory, but that only takes its size (for printing). The emailing can then lazily deconstruct it, leading only to "a little more than 1*64*length" memory usage.
14:31:56 <quchen> ^ that's what I would have guessed anyway.
14:32:03 <quchen> Well, depending on the email function.
14:32:07 <monochrom> "x:xs" consists of two fields. instantly 2 machine words
14:32:30 <quchen> Oh, I thought the 64 was cons+pointers+character
14:33:25 <monochrom> ":" itself may yet occupy one more machine word
14:34:31 <monochrom> do you agree that there exists a moment such that the whole string is in memory?
14:34:45 <quchen> Yes.
14:34:52 <monochrom> then that is enough to kill
14:35:27 <monochrom> every often, even a short moment pushes the computer over the edge
14:35:39 <monochrom> even 1 nanosecond is enough
14:36:19 <monochrom> memory is not like electricity when you could mitigate short high spikes by capacitors
14:36:29 <monochrom> s/when/where/
14:37:11 <quchen> I still don't understand the 2*64. Here's my count.  cons: 1 word. First field of cons: 1 word (a pointer), second field: 1 word (another pointer), character: 1 word (or more, UTF-8 etc).
14:37:38 <monochrom> I said "at least". so I counted 2. if you see 4, all the better
14:38:09 <monochrom> many characters are shared. GHC does some flyweight. Bless that design pattern :)
14:38:28 <quchen> Ah, I thought the "at least" was just to be accurate in case of "large" UTF-8 characters.
14:39:24 <monochrom> GHC stores UTF-32
14:40:11 <quchen> Oh! Well that's new to me.
14:40:29 <monochrom> most of HXT memory hogging is due to keeping [Char]
14:41:21 <b0bbi10> is that pattern matching, too? "head' = foldr1 (\x _ -> x)" looks rather like a function that takes two arguments. I would implement the patterns as (x:xs)
14:41:22 <geekosaur> also ghc does not generally work in less than a machine word size
14:41:35 <monochrom> "<hello/>" literally becomes Elem ('h':'e':'l':'l':'o':[]) []
14:42:06 <monochrom> so imagine a 1GB XML file of full of "<hello/>"
14:42:33 * quchen has quit (heap overflow)
14:42:39 <monochrom> haha
14:43:20 <dwcook> b0bbi10, there is pattern matching in the lambda
14:43:39 <xil> quchen: thanks so much again for the help! Turns out my distro only have cabal 1.14, which doesn't have the sandbox, but I just took the risk and downgraded my QuickCheck and that let me build it =D
14:43:44 <dwcook> x and _ are both patterns matching any value. (The difference is that _ doesn't bind anything)
14:43:45 <monochrom> foldr1 contains its own pattern-matching
14:44:28 <monochrom> but yes the variable "x" is already a pattern. boring pattern, sure, but still pattern.
14:45:16 <b0bbi10> dwcook: two questions: if they are mathing any value (two parameters), they can't match one list (and extract the head), right? 2) is _ defined as binding nothing or can I still access it via '_'?
14:45:44 <dwcook> b0bbi10, right, extracting the head would involve the (:) constructor. And that's correct, _ doesn't even bind _ on the right side.
14:46:11 <b0bbi10> got it
14:46:14 <b0bbi10> thanks :)
14:46:26 <dwcook> b0bbi10, _ can be read as "don't care", meaning it can be anything but won't affect the result
14:46:45 <dwcook> e.g., const x _ = x
14:47:43 <eyebloom> Why are bound variables from a lambda allowed in a let expression that is enclosed in it's body?
14:47:48 <b0bbi10> ah ok, didn't know that _ is special
14:48:03 <DR6_> why wouldn't they be allowed?
14:48:27 <eyebloom> Such as \x -> let y = x + 1 in y
14:48:54 <eyebloom> It's seems like they make the language unnecessarily complicated.
14:49:06 <DR6_> even when this is not quite right
14:49:34 <eyebloom> Since you could always write: \x -> let y z = z + 1 in y x
14:49:41 <DR6_> you can think about let {x = something in (y x) as (\x -> y x) (something)
14:50:17 <DR6_> I don't understand the problem
14:50:35 <DR6_> when a lambda bounds a variable it's accessible in all its body
14:50:46 <DR6_> the let binding is part of the body
14:50:57 <dwcook> eyebloom, you'd need a special rule if you wanted to *disallow* it, since any parameter is bound inside the entire body of the function
14:50:59 <DR6_> it would be more complicated if they weren't accessible
14:52:35 <monochrom> eyebloom: it is uniformly allowed to re-use variable names and get shadowing. for example let {x=1} in let {x='y'} in x
14:53:02 <prinsen> Im using TemlateHaskell in Hint. If i do something like evaluate $( [| "test" |] ) it compiles and I can print the result
14:53:18 <DR6_> or let {2 + 2 = 5} in 2 + 2 :>
14:53:20 <monochrom> in fact, try: let {x=1} in ((let x='y' in x), x)
14:53:55 <monochrom> for sanity, of course we don't use that freedom too much
14:53:57 <prinsen> but if I use a user-defined data type like MyType String String and interprets $( [| MyType "test" "test" |]) it segfaults when I try to print the object
14:54:53 <monochrom> in fact, when I'm teaching, I'm so paranoid that after I define "f x = x+1", I don't define "g x = x+2", I write "g y = y+2".
14:55:01 * hackagebot data-category 0.6.0 - Category theory  http://hackage.haskell.org/package/data-category-0.6.0 (SjoerdVisscher)
14:56:10 <quchen> That's not just a "silly student" issue though. It's often hard to keep scopes in mind when reading larger bodies.
14:58:45 <b0bbi10> "map ($ 3) [(4+), (10*), (^2), sqrt]" -> would that evaluate to [$ 3 (4+),...] or [(4+) $ 3,..] ? I always thought map would do [func val1, func val2...]
14:59:16 <Iceland_jack> b0bbi10: Yes
14:59:17 <Iceland_jack> > ($ 3) sqrt
14:59:17 <monochrom> (4 +) $ 3
14:59:18 <lambdabot>  1.7320508075688772
14:59:43 <monochrom> "($ 3)" is not "$ 3"
14:59:43 <Iceland_jack>       ($ x) f
14:59:44 <Iceland_jack>     = f $ x
14:59:44 <Iceland_jack>     = f x
14:59:55 <awestroke> > [] : []
14:59:56 <lambdabot>  [[]]
15:00:05 <awestroke> > [] : [] : []
15:00:06 <lambdabot>  [[],[]]
15:00:15 <Iceland_jack> > ([] : []) : []
15:00:16 <lambdabot>  [[[]]]
15:00:27 <monochrom> (^ 2) = (\x -> x ^ 2).  (5 ^) = (\y -> 5 ^ y). similarly for other operators.
15:02:21 <monochrom> ($ 3) (4 +) = (\x -> x $ 3) (\y -> 4 + y) = (\y -> 4 + y) $ 3 = (\y -> 4 + y) 3 = 4 + 3
15:02:25 <b0bbi10> that seems like magic again. $ is supposed to have the lowest priority, that I understand but it even changes the order of the expressions Oo
15:02:27 <monochrom> keep calm and plug in.
15:02:49 <dmwit_> Priority only matters during parsing, not during evaluation.
15:02:58 <monochrom> the parentheses completely overshadow precedences
15:03:27 <monochrom> keep calm and plug in. suppress intuition.
15:03:43 <monochrom> suppress, repress, oppress your intuition
15:03:50 <monochrom> keep calm and plug in.
15:03:51 <Iceland_jack> b0bbi10: No magic, you are aware that:?
15:03:51 <Iceland_jack>       (• y)
15:03:51 <Iceland_jack>     = (\x -> x • y)
15:03:51 <b0bbi10> hehe
15:04:07 <b0bbi10> Iceland_jack: yeah
15:04:13 <b0bbi10> currying
15:04:23 <Iceland_jack> no just operator sections :)
15:04:31 <Iceland_jack> let's replace (•) by ($)
15:04:33 <monochrom> that is not currying
15:04:48 <ski> partial application is not currying
15:04:55 <Iceland_jack> b0bbi10: Do you agree with this?
15:04:56 <Iceland_jack>       map ($ 3)
15:04:56 <Iceland_jack>     = map (\f -> f $ 3)
15:05:33 <b0bbi10> Iceland_jack: yes
15:05:37 <prinsen> my haskell programs segfaults with Segmentation fault (core dumped), but no core dumps are generated :(
15:05:57 <monochrom> you need to play with "ulimit" to enable core dumping
15:06:01 <prinsen> other programs that dumps core ends up in systemd-coredumpctl
15:06:01 <haasn> in my books, “currying” = “applying curry”
15:06:05 <haasn> (in Haskell)
15:06:07 <prinsen> monochrom: i have
15:06:12 <monochrom> then I don't know
15:06:41 <ski> "currying" is turning a function from "tupled style" to "curried style", either manually, or by applying functions like `curry'
15:06:57 <prinsen> monochrom: Any experience with TH and Hint?
15:06:57 <Iceland_jack> Then do you agree with the following?
15:06:57 <Iceland_jack>       map ($ 3) [(4+), (10*), (^2), sqrt]
15:06:57 <Iceland_jack>     = [($3) (4+), ($3) (10*), ($3) (^2), ($3) sqrt)
15:06:57 <Iceland_jack>     = [(\f -> f$3) (4+), (\f -> f$3) (10*), (\f -> f$3) (^2), (\f -> f$3) sqrt)
15:07:00 <Iceland_jack>  
15:07:04 <Iceland_jack>  
15:07:10 <monochrom> I have only played with TH a little bit.
15:07:15 <Iceland_jack> (last ')' should be ']')
15:07:15 <ski> .. it also turns out that `curry' can in Haskell be used to partially apply a function -- but that's because `curry' in Haskell is itself written in curried style !
15:07:57 <b0bbi10> Iceland_jack: yup, that's clear now
15:08:04 <Iceland_jack> b0bbi10: okay :)
15:08:06 <b0bbi10> thanks everyone
15:08:33 <Javran> > ($ 3) . ($ 2) $ (+)
15:08:34 <quchen> ski: curry f x y = f (x,y) -- what's curried about this?
15:08:35 <lambdabot>  5
15:08:47 <Iceland_jack> A way of writing that is possibly clearer is just writing it as
15:08:47 <Iceland_jack>     map (\f -> f 3)
15:08:56 <Javran> > ($ 3) . ($ 2) $ (-)
15:08:58 <lambdabot>  -1
15:09:00 <nisstyre_> @src curry
15:09:00 <lambdabot> curry f x y = f (x, y)
15:09:15 <dmj`> @src uncurry
15:09:15 <lambdabot> uncurry f p = f (fst p) (snd p)
15:09:26 <Iceland_jack> > map ($ 3) [(4+), (10*), (^2), sqrt]
15:09:27 <lambdabot>  [7.0,30.0,9.0,1.7320508075688772]
15:09:31 <Iceland_jack> > map (\f -> f 3) [(4+), (10*), (^2), sqrt]
15:09:32 <lambdabot>  [7.0,30.0,9.0,1.7320508075688772]
15:09:35 <ski> quchen : .. i suppose i should say that `curry' is identical to a hypothetical `partiallyApply' function, written in curried style
15:10:09 <ski> @let tupledPartialApply (f,x) = \y -> f (x,y)
15:10:10 <lambdabot>  Defined.
15:10:18 <ski> @let curriedPartialApply f x = \y -> f (x,y)
15:10:19 <lambdabot>  Defined.
15:10:19 <Javran> can uncurry also be written as "uncurry f ~(x,y) = f x y" ?
15:10:25 <ski> `curriedPartialApply' is `curry'
15:10:37 <monochrom> yes
15:11:17 <haasn> :t uncurry curry
15:11:18 <lambdabot> ((b, b1) -> c, b) -> b1 -> c
15:11:30 <nisstyre_> wouldn't it be correct to say the result of `uncurry f` is also a curried function?
15:11:39 <haasn> :t uncurry ?f
15:11:40 <lambdabot> (?f::a -> b -> c) => (a, b) -> c
15:11:54 <monochrom> yes if c is a function
15:11:55 <haasn> if ‘c’ is a function, yes
15:12:26 <monochrom> it is good to have independent confirmation
15:12:32 <haasn> as it turns out, it's not a very simple or useful thing to distinguish between “curried” and “uncurried” functions
15:12:55 <ski> .. if `c' is a function *type* :)
15:12:59 <nisstyre_> haasn: maybe a better name for uncurry would be "toProduct" or something
15:13:03 <nisstyre_> and fromProduct for curry
15:13:09 <haasn> Understanding the term “curry” and “currying” is also in no way a prerequisite for understanding haskell, haskell's functions and function application
15:13:13 <nisstyre_> (there are probably better names)
15:13:17 <haasn> nisstyre_: I'll go with schön and hässlich
15:13:26 <nisstyre_> okay :P
15:13:27 <quchen> haasn is an expert on …   nevermind
15:13:27 <haasn> @hackage acme-schoenfinkel
15:13:27 <lambdabot> http://hackage.haskell.org/package/acme-schoenfinkel
15:13:52 <ski> haasn : it's all relative to some *view* of the function as taking some multiple arguments, yes
15:14:21 <haasn> ski: which in Haskell is not very useful as all haskell functions take precisely one argument
15:14:31 <ski> in real Haskell, functions are neither tupled or curried, just like functions in real Haskell always takes exactly one argument
15:15:04 <quchen> ski: CAFs are special then?
15:15:17 <ski> haasn : it can some times be useful as a POV. but it's still a viewpoint
15:15:24 <quchen> I'm never sure whether they're functions or not. The rule of thumb seems to be "perhaps".
15:15:51 <ski> quchen : functions are those values which have types of shape `.. -> ..'
15:16:09 <haasn> ski: when programming, I certainly think of “a -> b -> c” as as a function that takes two parameters; and I think of applying it to only one parameter as “partial application”
15:16:33 <ski> haasn : *nod*
15:16:46 <quchen> ski: So `Num a => a` is not a function?
15:16:55 <haasn> I think currying may be a red herring; the key could be to understand high order functions
15:17:08 <quchen> Depends on how you think of typeclasses I guess. Hmm.
15:17:18 <ski> quchen : strictly speaking, no. more loosely speaking, it depends on what type `a' is bound to
15:17:18 <haasn> *not* to understand some specific interpretation of multiple-parameter functions (as higher order functions)
15:17:36 <haasn> If you try to understand the latter without understanding its prerequisite it might be easy to be caught up in confusion
15:18:07 <jle`> but being caught up in confusion is half the fun of haskell
15:18:10 <jle`> why would you rob someone of that joy
15:18:17 <haasn> jle`: are you a lens user, I see?
15:18:27 <haasn> you are*
15:18:48 <ski> (just like strictly speaking, a value of type e.g. `forall a. [a] -> Int' isn't a function. it's a polymorphic value that when instantiated will yield a function. however, since this instantiation is implicit in the syntax, it's usually useful to think of it as a function of type `[tau] -> Int', for any appropriate type `tau')
15:19:28 <ski> haasn : certainly to understand currying fully, you need to understand higher-order functions
15:19:51 <ski> and if you understand the latter, you may or may not have any use of the term "currying" and "curried"
15:20:00 * haasn vaguely remembers the first time he read a paragraph about currying on wikipedia
15:20:02 <quchen> ski: Wait, there are no polymorphic functions (in the strict sense)?
15:20:32 <haasn> I think it was reading up on the lambda calculus that made it click into place. When I saw currying explained after introducing the basics of lambda calculus (in the article on the LC), I knew what it was
15:20:38 <ski> you could view "polymorphic X" as shorthand for "polymorphic value which when instantiated yields X"
15:20:40 <haasn> When I read the definition of “currying” before, I could not understand it
15:21:40 <ski> quchen : note that in a type-passing system, a polymorphic value would (possibly) not be represented in the same was as a monomorphic one
15:21:49 <ski> s/was/way/
15:21:50 <xil> quchen: I contacted the package maintainer and it looks like they coincidentally fixed that very bug just today, so now the package works with any QuickCheck, haha. Thanks again!
15:22:19 <haasn> perhaps “forall a. Num a => a is a function” is neither true nor not true? :)
15:22:56 <haasn> (but you can force it one way or the other by assuming its truth or negation as an additional axiom which constraints the type of a)
15:23:31 <ski> haasn : well, `forall a. Num a => a' is a type, not a value. perhaps that's your point : that it's meaningless (a meta type error) to try to apply the predicatate "is a function" to something that's not a value ?
15:24:00 <ski> (s/predicatate/predicate/)
15:24:10 <haasn> ski: I meant “function type” :)
15:24:17 <haasn> or “type of a function”
15:24:42 <ski> ok, strictly speaking, it's clearly not a function type, it's a universal type
15:25:17 <ski> but since universal instantiation is implicit on values, we could decide to "look inside" the outer `forall'
15:25:28 <ski> and similarly for the `Num a =>' part
15:25:40 <ski> and so the question is whether `a' is a function type
15:25:49 <jle`> i'm not sure if i am qualified to weigh in, but wouldn't Num a => a be a function at the implementaiton level because of how typeclasses are implemented in ghc?  it is a function that takes a typeclass dictionary and returns an `a`?
15:25:53 <ski> and .. it depends on whether `a' is a function type (duh !)
15:25:53 <haasn> that seems logical, yes
15:25:58 <haasn> :)
15:26:10 <quchen> ski: Why is it always the simple questions that have difficult answers ;-)
15:26:16 <haasn> jle`: implementation details are precisely that
15:26:18 <ski> so, in some instantiations, it (a bit loosely speaking) is a function type, and in some, it isn't
15:26:49 <haasn> jle`: dictionary passing is not the only way to implement type classes; and in fact GHC will not always do this
15:27:15 <jle`> i see
15:27:18 <ski> jle` : no, `Num a => a' is a type. and it's certainly not a type function (like `Maybe' or `ReadS', e.g.)
15:27:34 * ski is being pedantic here, on purpose
15:27:58 <jle`> heh
15:28:00 <jle`> i see
15:28:21 <jle`> oh yeah
15:28:24 <jle`> >.>
15:28:33 <haasn> jle`: if GHC decides to inline this “Num a => a” inside a context in which ‘a’ is constrained to some monomorphic type, for example, it is capable of using the monomorphic, type-dependent versions of *, + etc. without going through a “dictionary” parameter
15:29:14 <ski> jle` : in e.g. MetaML, a value of type  ['a#]. 'a list -> 'a  is *not* represented as a function (an example of such a function could be `sum'. the `#' is a constraint on the type variable that it supports "numeric" operations)
15:29:35 <ski> (or rather, an example of such a non-function ;)
15:30:03 <haasn> ski: what about the ->? :P
15:30:19 <avaritia> if i care about performance is it better to make thing instance of Num or to implement my custom multiplication/addition functions?
15:31:06 <ski> in Haskell terms, this type would be `forall a. Num a => [a] -> a' .. and we've already concluded that, strictly speaking, values of that type aren't functions. they are polymorphic values
15:31:14 <monochrom> make an instance of Num. add a lot of INLINE pragmas
15:31:27 <haasn> avaritia: I think I'd make it an instance of Num, add INLINE pragmas and make sure my use cases are monomorphic where they need to be
15:31:31 <jle`> ski: that makes sense
15:31:40 <haasn> (add lots of type signatures!)
15:31:47 <avaritia> haasn: monomorphic?
15:32:15 <ski> haasn : in MetaML, a function gets printed in the interactor as `fn'. a polymorphic value gets printed as `Fn' (since it can be thought of as a different kind of function, one that takes a *type* (implicitly), and returns a value)
15:32:49 <ski> avaritia : not polymorphic
15:32:49 <avaritia> thank you :)
15:32:59 <avaritia> ski: ok,  thank you :)
15:33:42 <haasn> avaritia: the opposite of polymorphic; for a simple demonstration of what I mean: “phi :: Floating a => a; phi = (1 + sqrt 5) / 2” vs “phi :: Double; phi = (1 + sqrt 5) / 2”
15:34:16 <ski> (this also means that the empty list, not instantiated to any particular type, is a polymorphic value in MetaML, and so will get printed as `Fn', unless you constrain it to some particular element type)
15:34:19 <haasn> depending on the location and the setting of the MonomorphimRestriction, GHC will infer either the former or the latter if you leave off the type signature
15:34:36 <haasn> which can have differing effects on performance
15:35:19 <haasn> ski: ah, okay
15:36:00 <avaritia> also a thing which i'm curious about, are algebraic datatypes similar in implementation to the typeclasses?
15:36:01 <ski> haasn : are you familiar with System F ?
15:36:12 <haasn> ski: no
15:36:14 <ski> avaritia : not at all
15:37:16 <ski> avaritia : algebraic datatypes have a statically fixed set of alternatives (data constructors) (each having zero or more arguments of particular types -- possibly using record notation)
15:38:24 <ski> avaritia : a type class only specifies a set of methods that instances must implement. it has an open set of instances : more instances can be added in other parts of the program later
15:39:53 <avaritia> ski: so typeclasses are implement similar to virtual functions?
15:40:15 <avaritia> ski: but when i match a function against algebraic datatype i'm doing something similar to a switch?
15:40:53 <Eduard_Munteanu> avaritia: there's no adhoc polymorphism so there's no vtable, you only have a dictionary
15:41:13 <haasn> I don't know what “virtual functions” and “switch” mean it sounds like you're trying to assign intuition for haskell concepts by comparing them to other programming languages. You should be aware of the dangers of this, although I don't know how justified it is here
15:41:22 <haasn> mean but it*
15:41:29 <ski> avaritia : somewhat similar, but still different
15:41:41 <Eduard_Munteanu> avaritia: unless you map typeclasses to overloaded functions 1 to 1
15:42:19 <ski> avaritia : with vtables, you have both some instance state (instance/member variables), and a vtable
15:42:35 <ski> avaritia : with typeclasses, you only have the vtable, so to speak. no instance state
15:42:45 <avaritia> ok
15:42:52 <ski> avaritia : also, the types work a bit different
15:43:08 <Eduard_Munteanu> avaritia: it isn't like a switch at all, unless you're only referring to matching the constructor
15:43:19 <avaritia> last question, when i have a list e.g of Ints and i'm doing something like map (2*) over it is ghc smart enough to remove the vtable?
15:43:39 <avaritia> Eduard_Munteanu: yes i'm referring to matching
15:44:01 <Eduard_Munteanu> Constructors are usually represented in a bitfield attached to the enclosed value.
15:44:41 <ski> avaritia : with inlining, probably yes
15:44:51 <Eduard_Munteanu> So strictly in that sense, matching the constructor tag, it is like a switch of sorts.
15:45:33 <ski> haasn : in System F, we have two new kinds of expression terms, let's write them `/\alpha. ..alpha..' and `e [tau]', where `alpha' is a tyvar, `..alpha..' and `e' are (value) expressions, and `tau' is a type expression (a type term)
15:45:34 <Eduard_Munteanu> IIRC GHC makes matching O(log n), n = number of constructors.
15:45:38 <avaritia> thank you for the answers :)
15:45:43 <tnks> reading http://projects.haskell.org/diagrams/doc/vector.html and found a broken link to http://projects.haskell.org/diagrams/haddock/Data-AffineSpace.html.  I looked in Hoogle and couldn't find a reference to the AffineSpace type class.
15:46:23 <tnks> so a few questions.  1) Am I looking in the wrong place  2) does Hoogle not capture everything in Hackage  3) Do people actually remove packages from Hackage when they're abandoned?
15:46:39 <haasn> ski: I'm vaguely familiar with the basics of Agda and Core, both of which have (partially) explicit type application
15:46:47 <k00mi> tnks: yes, hoogle does not search all of hackage
15:46:51 <k00mi> hayoo does though
15:47:02 <k00mi> and usually packages are just left to rot
15:47:05 <ski> haasn : if an expression `expr' (possibly involving `alpha' freely) has type `tau' (possibly involving `alpha' freely), then `/\alpha. expr' has type `forall alpha. tau'
15:47:34 <tnks> k00mi: cool, I'll look at hayoo.
15:48:10 <tnks> k00mi: does hayoo subsume hoogle?
15:48:36 <Fuuzetsu> no, they just search different packages
15:48:49 <ski> haasn : if `expr' has type `forall alpha0. tau1', then `expr [tau0]' has type `[alpha0 |-> tau0] tau1', where this denotes substition of `tau0' for `alpha0' in `tau1'
15:49:17 <k00mi> tnks: hoogle is better at search for types
15:49:32 <tnks> Fuuzetsu: okay, a little confused resolving "hayoo does though [search all of hackage]" but Hoogle searches something not searched by Hayoo.
15:49:33 <Fuuzetsu> I think hayoo searches all the packages that hoogle does but I think hoogle gets updated more often and it's sometimes nice to get less noise by searching fewer packages
15:50:08 <tnks> Fuuzetsu: okay, I'm understanding, maybe.
15:50:08 <ski> haasn : in Agda, these would just be ordinary abstraction `\alpha -> expr' and application `expr tau0'
15:50:32 <Fuuzetsu> ski: that's really hard to read, use τ and α ;P
15:50:47 <haasn> ski: oh, good point about Agda; I forgot about dependent typing
15:50:48 <ski> Fuuzetsu : i actually considered doing just that
15:50:48 <k00mi> hayoo is also pretty unstable, it's sometimes broken for days
15:50:54 <haasn> ski: Core would be closer, though, I think?
15:50:59 <robshack21> wikileaks.org
15:51:07 <ski> haasn : yes (i don't recall the Core syntax)
15:54:04 <robshack21> wikileaks.org
15:54:37 <Eduard_Munteanu> robshack21: are you spamming?
15:54:46 <robshack21> no
15:54:55 <Fuuzetsu> maybe he just loves wikileaks.org
15:54:58 <jmcarthur> then what are you doing?
15:54:59 <Eduard_Munteanu> robshack21: then what is that?
15:57:20 <Fuuzetsu> is wikileaks a burrito
15:57:36 <ZettaBlade> Is wikileaks a monad?
15:57:57 <ezrios> wikileaks is web scale
15:57:59 <haasn> ski: (\ (@ alpha) -> expr) and (expr @ tau) it seems
15:58:05 <Eduard_Munteanu> It is. You can always leak something, and if you leak it twice it's the same thing.
15:58:20 <Fuuzetsu> haasn: what's the @
15:58:43 <Eduard_Munteanu> (and of course, it's hard to unleak it)
15:59:04 <Fuuzetsu> I'm reminded to update my Agda, they have some new exciting features
15:59:23 <Eduard_Munteanu> Fuuzetsu: oh... like what? (I haven't been playing with it recently.)
15:59:49 <Fuuzetsu> well, you can now have functions one the LHS which take different number of arguments
16:00:00 <Fuuzetsu> so you can have something like
16:00:03 <Fuuzetsu> f [] = 5
16:00:05 <Fuuzetsu> f = head
16:00:08 <Fuuzetsu> (I think)
16:00:14 <Eduard_Munteanu> Hm, I see.
16:00:31 <Eduard_Munteanu> Even GHC refuses that these days.
16:00:31 <Fuuzetsu> also seems it's able to match up implicit params better
16:00:39 <Fuuzetsu> yeah, it does which annoys me
16:00:42 <haasn> Fuuzetsu: type quantification and type instantiation, it seems
16:01:08 <Eduard_Munteanu> I remember it used to accept that, not sure though.
16:01:29 <Eduard_Munteanu> It might complicate coverage checking.
16:02:53 <romildo> What is called a library in Haskell? I thought a library is a collection of modules. But it seems that a library is just a single module. At least this is the impression I have when reading http://www.haskell.org/haskellwiki/Applications_and_libraries
16:03:16 <Fuuzetsu> I wish they moved their repo to GitHub already
16:03:17 <Eduard_Munteanu> romildo: nah, library and package are almost synonymous
16:03:21 <Fuuzetsu> they moved their STDLIB which is nice
16:04:19 <romildo> Eduard_Munteanu, then generally a library is a collection of modules.
16:04:41 <Eduard_Munteanu> romildo: yeah
16:05:02 <haasn> Eduard_Munteanu: what about libraries which are split into multiple packages?
16:05:09 * hackagebot MFlow 0.4.4 - stateful, RESTful web framework  http://hackage.haskell.org/package/MFlow-0.4.4 (AlbertoCorona)
16:05:16 <dwcook> haasn, in what sense are those still "a" library?
16:05:20 <Eduard_Munteanu> Well, I suppose it depends on context.
16:05:29 <haasn> in the sense that it's arbitrary, perhaps :)
16:08:39 <Fuuzetsu> what a scary module http://hackage.haskell.org/package/Agda-2.3.2.2/docs/src/Agda-ImpossibleTest.html#impossibleTest
16:09:38 <haasn> clearly, it's testing to make sure whatever its testing is impossible to test
16:09:50 <Eduard_Munteanu> 'data Tree b l = Branch b [Tree b l] | Leaf l' looks an awful lot like 'data Free f a = Pure a | Wrap (f (Free f a))'. Is there more to this similarity? The latter seems a generalization.
16:10:45 <ski> haasn : hm, i'd call the first "type abstraction (over terms)"
16:11:02 <jmcarthur> Eduard_Munteanu: Free (Compose ((,) b) [])
16:11:09 <Eduard_Munteanu> Yeah.
16:11:21 <Eduard_Munteanu> But is it something deeper or just a coincidence?
16:11:53 <dmj```> I'm trying to cabal install network-2.4.2.2 on windows and getting the following strange linker errors.
16:11:54 <dmj```> http://lpaste.net/101648
16:11:56 <haasn> Eduard_Munteanu: it's certainly no coincidence that free monads show up often
16:11:59 <Eduard_Munteanu> It also seems to generalize nicely to other tree-like structures and lists.
16:12:02 <jmcarthur> Eduard_Munteanu: that depends on where Tree comes from
16:12:10 <haasn> Eduard_Munteanu: does it really generalize nicely to lists?
16:12:21 <jmcarthur> Eduard_Munteanu: yes, Free (and CoFree) generates trees
16:12:37 <jmcarthur> Eduard_Munteanu: Free generates trees with values in leaves. CoFree generates them with values in inner nodes
16:13:06 <jmcarthur> CoFree works for non-empty lists, at least
16:13:12 <Eduard_Munteanu> haasn: Free Identity a ~ [a], seems to me
16:13:17 <jmcarthur> neither is a very convenient way to define lists
16:13:19 <ski> @where DecoratingStructures
16:13:19 <lambdabot> <http://web.archive.org/web/20051126143527/http://haskell.org/hawiki/DecoratingStructures>
16:13:20 <ski> @where IndirectComposite
16:13:20 <lambdabot> <http://web.archive.org/web/20051126141834/http://haskell.org/hawiki/IndirectComposite>
16:13:25 <Eduard_Munteanu> Er, not really...
16:13:36 <jmcarthur> no, Free Identity ~  data Foo a = Step (Foo a) | Return a
16:13:39 <dmj```> Does anyone know why network would have linking errors on windows?
16:13:44 <Eduard_Munteanu> Free ((,) a) a
16:13:53 <haasn> Eduard_Munteanu: what does [] correspond to?
16:14:01 <jmcarthur> Eduard_Munteanu: that won't give you the free monad though
16:14:02 <Eduard_Munteanu> Grr...
16:14:05 <Eduard_Munteanu> Free ((,) a) (). :)
16:14:12 <jmcarthur> neither will that
16:14:13 <Fuuzetsu> dmj```: I think you'll have more luck asking on the mailing lists
16:14:14 <haasn> Eduard_Munteanu: what is the type of return?
16:14:22 <ski> haasn : `Pure ()' ?
16:14:24 <dmj```> Fuuzetsu: thanks, will do
16:14:43 <ski> @type return  -- haasn, there you go
16:14:44 <lambdabot> Monad m => a -> m a
16:15:20 <ski> oh, jmcarthur had a `Return' .. of type `a -> Foo a'
16:15:48 <Eduard_Munteanu> I'm merely wondering if there's a deeper connection beyond trees. I noticed it while trying to make up a trie, as Free (Map k) a ~ TrieMap k a.
16:15:59 <tnks> I see in http://hackage.haskell.org/package/vector-space-0.8.6/docs/src/Data-AffineSpace.html#.-%5E an interesting use of the CPP extension to remove boilerplate.
16:16:04 <tnks> how "safe" is this?
16:16:42 <jmcarthur> tnks: well, it doesn't bypass the type system or anything
16:16:43 <ski> trees come in many variants and shapes
16:17:02 <tnks> jmcarthur: okay, that's good. . . seems kind of useful then.
16:17:38 <haasn> Eduard_Munteanu: Free ((,) a) is sort of like a list of ‘a’s with some other value attached at the tail. The Monad instance is radically different, though. The parameter of [] is the type of the list elements; the parameter of Free ((,) a) is the type of the value attached to the tail!
16:17:41 <jmcarthur> Eduard_Munteanu: the thing to pay attention to is "trees where the last type parameter has kind * and there are only values of that type in the leaves"
16:17:41 <Fuuzetsu> I think normally TH is preferred for boilerplate removal but each to their own
16:18:14 <haasn> (and that's the parameter that determines the type of the “bound value” passed to (>>=)'s right hand side!)
16:18:14 <Eduard_Munteanu> Oh, right.
16:18:19 <tnks> jmcarthur: without going too crazy with human-comprehensibility issues, is there any reason to avoid it?
16:18:29 <haasn> Eduard_Munteanu: (>>) for Free-style “lists” corresponds to list concatenation
16:18:57 <jmcarthur> tnks: none other than the obvious
16:19:15 <tnks> jmcarthur: k.
16:31:28 <xnoise> hello guys.
16:31:36 <Eduard_Munteanu> xnoise: hi
16:31:36 <Iceland_jack> hey xnoise
16:31:59 <__monty__> Could someone take a lot at these errors, I don't fully understand IORef and monads.
16:32:20 <xnoise> have maybe a stupid question: i am starting into haskell coming from imperative programming. All good and nice, but there are things i do not understand (mathematics related)
16:33:15 <xnoise> initially i think this will not be a issue, but since my math skills are quite bad (10+ years since i did equations in school), would like to know where i can get started
16:33:32 <Iceland_jack> xnoise: What are you having trouble with?
16:34:08 <xnoise> reading some explanations on forums, monads and related stuff
16:34:18 <Eduard_Munteanu> Good thing Haskell-related math isn't much about numerical stuff, rather more fundamental stuff :)
16:34:30 <Eduard_Munteanu> (foundational, even)
16:35:19 <xnoise> i guess so, that's why i don't have any issues. but still would like in parralel to brush off the math skills. lambda calculus, category theory, set theory, they look a little advanced and i get lost really fast in the language
16:35:26 <ski> __monty__ : maybe you should paste the errors
16:35:28 <ski> @paste
16:35:28 <lambdabot> Haskell pastebin: http://lpaste.net/
16:36:15 <Iceland_jack> xnoise: If you want to understand how to use monads then that's exactly what you should do (i.e. use them) and not worry about some kind of “bigger picture”
16:36:29 <Eduard_Munteanu> xnoise: have you ever studied abstract algebra (monoids, groups and so forth)?
16:36:31 <ski> xnoise : basic algebra and equation solving could help. also understanding the math notion of a function
16:36:46 <xnoise> @Eduard: some long time ago :) most knowledge is lost by now
16:36:47 <lambdabot> Unknown command, try @list
16:37:05 <__monty__> ski: Oops, here you go: http://lpaste.net/101649
16:37:42 <Eduard_Munteanu> I see... conveniently, it's rather straightforward and it doesn't have many prerequisites.
16:38:08 <ski> __monty__ : start by changing `IORef Solution' to `IO (IORef Solution)'
16:38:11 <xnoise> so abstract algebra is the branch i want to look into first right?
16:38:39 <ski> __monty__> :t best_solution_found
16:38:53 <ski> __monty__> :t abc_
16:38:58 <Iceland_jack> xnoise: Depends on what your goals are frankly, learning abstract algebra just to program in Haskell is overkill
16:39:00 <ski> __monty__> :t timeout
16:39:16 <Eduard_Munteanu> xnoise: just basic notions, it isn't scary at all... e.g. monoids are structures which have an operation with an identity element.
16:39:18 <ski> __monty__> :t init_solutions
16:39:47 <xnoise> well, i generally like to understand the core principles behind a technology i am using. And i like to go pretty deep (proves quite useful later on)
16:40:02 <ski> xnoise : basic algebra would be better to start with, unless you feel confident about that
16:40:37 <__monty__> ski: best_so.. :: Distances (Map.Map) -> [Solution] -> Solution, abc_ :: really long, I'll add it to the paste
16:40:42 <ski> xnoise : abstract algebra *might* be useful later on, if you like that kind of thing. but it's not a prerequisite
16:40:45 <xnoise> ski: at the moment, my algebra probably is really rusty. can't say i am sure about anything. :)
16:40:53 <Iceland_jack> xnoise: To make an analogy with numbers, you learn how to use numbers (to count, etc.) and operations on them (addition, ...) before learning about rings or groups or monoids
16:41:35 <xnoise> Iceland_jack: i am already doing alot of exercises (simple ones)
16:41:51 <xnoise> trying to build some small stuff, small algorithms with the knowledge i have so far
16:42:03 <Eduard_Munteanu> I suspect "algebra" here means something more than they actually need. Also "abstract" isn't necessarily "advanced".
16:42:11 <xnoise> so far so good, all looks ok, although sometimes "slow"
16:42:13 <Iceland_jack> xnoise: You should definitely learn about Functors before learning about Monads, LYAH introduces these concepts in a very logical order
16:42:30 <Iceland_jack> so read through LYAH and you will learn
16:42:30 <ski> xnoise : you should know about "replacing equals for equals" in equations, and how to make "equation chains", and how to connect equations with implications and equivalences
16:43:00 <__monty__> ski: http://lpaste.net/101649
16:43:02 <ski> xnoise : .. or rather, perhaps you don't *have* to know that beforehand. but it will certainly *help*
16:43:05 <Eduard_Munteanu> That seems right on spot. :)
16:43:19 <Iceland_jack> xnoise: (every Monad is a Functor, and Functors are a much simpler concept)
16:43:41 <xnoise> Iceland_jack: that's exactly the language that throws me off
16:43:51 <Iceland_jack> xnoise: Then read LYAH :)
16:44:08 <xnoise> at LYAH i am at partial application/currying, and i was really happy when it started to make sense
16:44:37 <xnoise> had to read that chapter and practice quite some times to catch it, and i am sure i am missing some parts
16:44:44 <Iceland_jack> xnoise: Do you know what Maybe is?
16:44:50 <Iceland_jack>     data Maybe a = Nothing | Just a
16:44:55 <Eduard_Munteanu> If it hasn't been said earlier, you can take the LYAH way and avoid focusing too much on the mathy aspects.
16:44:58 <xnoise> keep hearing about it. Maybe monad?
16:45:16 <Iceland_jack> xnoise: Yes, but you can ignore that it's a monad for now
16:45:23 <Eduard_Munteanu> Before being a monad, it's a data type.
16:45:27 <xnoise> yep
16:45:33 <xnoise> that i know :)
16:45:46 <Iceland_jack> xnoise: Let's say that you want to apply a function 'a -> b' to a 'Maybe a'
16:45:53 <Iceland_jack> what would the type of that function be?
16:47:13 <xnoise> thinking. never met this one before
16:47:32 <Iceland_jack> so something like
16:47:32 <Iceland_jack>       magic show (Just 5)
16:47:33 <Iceland_jack>     ⇒ Just "5"
16:47:33 <Iceland_jack> and
16:47:35 <Iceland_jack>       magic show Nothing
16:47:39 <Iceland_jack>     ⇒ Nothing
16:49:42 <ski> __monty__ : instead of `take (length initial_sols) [0..]', you could say `zipWith const [0 ..] initial_sols'
16:50:21 <ski> __monty__ : and you're missing an argument to `abc_', inbetween `pls' and `iterations'
16:50:41 <ski> __monty__ : the one having type `[Distances -> Solution -> Integer -> StdGen -> (Solution, StdGen)]'
16:51:10 <__monty__> ski: yep added that argument, thank you for the zipwith
16:51:36 <Iceland_jack> xnoise: (I'm basically walking you through what Functors are, but you can find all this information in LYAH)
16:51:39 <Iceland_jack> @lyah
16:51:39 <lambdabot> Unknown command, try @list
16:51:41 <Iceland_jack> @where lyah
16:51:41 <lambdabot> http://www.learnyouahaskell.com/
16:52:05 <ski> __monty__ : also, instead of using `mkStdGen 123', you should probably use `newStdGen' or take a `StdGen' as argument
16:52:59 <__monty__> ski: Does the return type of abc really have to be IO (IORef Solution)?
16:53:15 <xnoise> Iceland_jack: (Maybe a, b) => a -> b ?
16:53:26 * ski preferred it when Iceland_jack used `=' for reduction chains :)
16:53:30 <__monty__> ski: I know it's in a funny place but this algorithm is not for actual use, it's for benchmarking purposes.
16:53:31 <xnoise> sorry if it is wrong :)
16:53:36 <Iceland_jack> xnoise: no, you're misunderstanding => :)
16:53:38 <ski> __monty__ : yes, it has to
16:53:54 <Iceland_jack> ski: I'll let #haskell vote on what to use
16:53:59 <Iceland_jack> maybe ↝?
16:53:59 <ski> __monty__ : it invokes I/O operations, hence its return type must involve `IO'
16:54:07 <Iceland_jack>       5 + 2
16:54:07 <Iceland_jack>     ↝ 7
16:54:13 <xnoise> this is so weird compared to imperative programming :)
16:54:42 <Iceland_jack> xnoise: Actually this isn't that very different
16:54:55 <ski> Iceland_jack : well, i think it's better than ⌜⇒⌝, but i still prefer the simple and declarative looking ⌜=⌝ :)
16:54:59 <xnoise> then i am lacking the basic understanding for that as well :)
16:55:01 <Iceland_jack> You have something that contains a value or not (tagged union in C)
16:55:06 <xnoise> which is even worse :)
16:55:26 <Iceland_jack> xnoise: Here's the definition
16:55:26 <Iceland_jack>     magic function Nothing  = Nothing
16:55:26 <Iceland_jack>     magic function (Just x) = Just (function x)
16:55:27 <xnoise> yes. that i understood from the data definition
16:55:52 <__monty__> ski: Thanks for the help I finally got rid of all the errors.
16:55:58 <ski> (of course for some purposes the more specific ⌜↝⌝ is better. but when talking to newbies, i think ⌜=⌝ is good)
16:56:15 <Iceland_jack> ski: Maybe I should just choose them arbitrary
16:56:16 <Iceland_jack>       5 + 2 * 10
16:56:16 <Iceland_jack>     = 5 + 20
16:56:16 <Iceland_jack>     ↝ 25
16:56:29 <xnoise> mhm
16:56:33 <ski> __monty__ : yw
16:56:39 <Iceland_jack> xnoise: Does the definition make sense?
16:56:47 <ski> __monty__ : any comment on getting rid of `mkStdGen' ?
16:56:54 <monochrom> I think you can safely stick to = for quite a while
16:57:02 <ski> Iceland_jack : haha, even worse ;)
16:57:06 <xnoise> yes, it makes sense
16:57:24 <Iceland_jack> xnoise: Okay, so let's figure out the type real quick
16:57:26 <haasn> Iceland_jack: that makes it look like ↝ implies “RHS is in normal form” ;)
16:57:30 <dwcook> Iceland_jack, that character is too small for my font, is that a spider? :P
16:57:34 <thebnq> maybe ≅ =)
16:57:39 <Iceland_jack> dwcook: The reduction spider!
16:57:39 <merijn> haasn: Not really
16:57:49 <merijn> haasn: Using that arrow for a single reduction step is common
16:57:49 <Iceland_jack> The first argument is some function (a → b)
16:57:56 <ski> thebnq : noo :)
16:58:00 <xnoise> yep
16:58:00 <haasn> dwcook: does ⌜↝⌝ looks like a spider with wings?
16:58:12 <dwcook> haasn, kinda
16:58:13 <__monty__> ski: I'm not sure why you think it should be removed. This code is an experiment testing a heuristic that requires 'random' choices. I need these 'random' choices to be the same every time I run it.
16:58:13 <Iceland_jack> xnoise: and since we want to apply it to the value of 'Just x', the second argument must have type 'Maybe a'
16:58:14 <merijn> haasn: Frequently you'd use arrow plus * to indicate 0 or more reduction steps to normal form
16:58:20 <Iceland_jack> xnoise: and the result must have type 'Maybe b'
16:58:31 <haasn> merijn: okay. perhaps picking them randomly is not the best idea, to avoid confusion :)
16:58:36 <Iceland_jack> so the final type is
16:58:36 <Iceland_jack>     magic :: (a -> b) -> Maybe a -> Maybe b
16:58:45 <xnoise> Iceland_jack: now it looks understandable
16:58:55 <Iceland_jack> xnoise: okay good, here's the million dollar question
16:58:58 <Iceland_jack> Does it look familiar?
16:59:07 <ski> __monty__ : ok, i see. that's different then
16:59:31 <ski> __monty__ : it might still be nice to pass in an `StdGen' as an argument, though
16:59:35 <xnoise> well, used it (kinda) before. So it looks familiar after starting with Haskell.
16:59:48 <Iceland_jack> xnoise: Does it look similar to
16:59:48 <Iceland_jack> @ty map
16:59:48 <__monty__> Do most people write haskell bottom-up (start defining small functions and then compose) or top-down (start with a skeleton of the bigger functions?)
16:59:49 <lambdabot> (a -> b) -> [a] -> [b]
16:59:59 <xnoise> and it actually makes alot of sense
17:00:13 <ski> __monty__ : often a mixture. and it depends on the person and the program, i think
17:00:23 <xnoise> sure it looks familiar with that
17:00:37 <Iceland_jack> xnoise: basically, this is what Functors are
17:00:54 <__monty__> ski: I have to create the StdGen at some point right? abc is the start of the heuristic that's why I put it there. (In this experiment I do not need to vary the seed.)
17:01:04 <Iceland_jack> if you have something '??? a' and a function (a -> b), then you can get '??? b'
17:01:08 <haasn> xnoise: you mentioned something about understanding the implementation of “magic” from just the data definition; there's something deeper here that I thought I'd mention - there is in fact at most one valid (law-abiding) Functor instance for any data type, and it's reasonably straightforward to automatically figure it out from just the data type definition. GHC can do this!
17:01:16 <Iceland_jack> In the case of 'magic', ??? was Maybe
17:01:24 <Iceland_jack> in the case of 'map', ??? is []
17:01:31 <ski> __monty__ : ok, then it's fine
17:01:47 <Iceland_jack>     (NOTA BENE: '[a]' is the same as '[] a')
17:02:04 <xnoise> hmmm.... that looks understandable. But most tutorials do not present it like this :)
17:02:30 <ski> > [] a  -- silly remark
17:02:32 <lambdabot>  Couldn't match expected type `Debug.SimpleReflect.Expr.Expr -> t0'
17:02:32 <lambdabot>              with actual type `[a0]'
17:02:59 <Iceland_jack> xnoise: so there is a generalization of both those functions, and it's called 'fmap'
17:03:01 <Iceland_jack> @ty fmap
17:03:02 <lambdabot> Functor f => (a -> b) -> f a -> f b
17:03:08 <Iceland_jack> See the similarities?
17:03:15 <Iceland_jack> Let's try it out
17:03:16 <Iceland_jack> > fmap show [1..10]
17:03:17 <lambdabot>  ["1","2","3","4","5","6","7","8","9","10"]
17:03:21 <Iceland_jack> > fmap show (Just 5)
17:03:22 <lambdabot>  Just "5"
17:03:23 <xnoise> i mean exactly this was the purpose of my initial question: once someone puts things for me in a "real" example, i will eventually get it. is not that hard. The problem is the abstract language that surrounds every single advanced explanation
17:03:24 <Iceland_jack> > fmap show Nothing
17:03:25 <lambdabot>  Nothing
17:03:47 <xnoise> is like everyone assumes i am familiar with the technical language (which i am not), and then they go forward
17:03:47 <Iceland_jack> xnoise: Yes that was exactly my suggestion! Get used to concrete examples, then learn the abstract concepts :)
17:04:18 <ski> xnoise : in the long run, the abstract language helps with understanding and use. in the short run, perhaps not very much
17:04:20 <__monty__> Also, how do you avoid writing lots of code (400 is a lot to me) and then having to solve lots and lots of bugs? Do you manually test every function in ghci?
17:04:45 <monochrom> I do. I test 5-line chunks.
17:04:59 <Javran> @pl (a . b . c) (d . e . f) x
17:04:59 <lambdabot> a (b (c (d . e . f))) x
17:05:08 <xnoise> yeah. i am already trying to do as much "real" work as possible, and trying to understand this via working examples
17:05:11 <Javran> @pl (a . b . c . d) (e . f) x
17:05:12 <lambdabot> a (b (c (d (e . f)))) x
17:05:16 * hackagebot Elm 0.12 - The Elm language module.  http://hackage.haskell.org/package/Elm-0.12 (EvanCzaplicki)
17:05:25 <ski> xnoise : good
17:05:27 <xnoise> thank you very much guys, i will probably come back tomorrow with other questions :)
17:05:33 <ski> you're welcome :)
17:05:36 <monochrom> I cannot, in fact, understand the mentality of spewing out a 400-line monolith in one go, and only then preliminary tests begin
17:05:44 <Iceland_jack> xnoise: So this is the definition of a Functor
17:05:44 <Iceland_jack>     class Functor f where
17:05:44 <Iceland_jack>       fmap :: (a -> b) -> f a -> f b
17:06:18 * ski doesn't mention `@src Functor'
17:06:20 <xnoise> that looks reasonably understandable :)
17:06:35 <xnoise> gotta run now (2 am here). thank you all very much.
17:06:45 <Iceland_jack> xnoise: No problem :) good luck
17:06:56 <Javran> @pl (a . b . c . d) ((e . f) g)
17:06:56 <lambdabot> a (b (c (d (e (f g)))))
17:07:01 <codygman> Are there any PHP interpreters implemented in Haskell? Seeing hack made me wonder about incrementally turning a PHP codebase to Haskell... which then made me wonder about having X to Haskell importing libraries.
17:07:10 <Javran> @pl (a . b . c . d . e) (f g)
17:07:10 <lambdabot> a (b (c (d (e (f g)))))
17:07:32 <ski> @unpl (a . b . c . d) ((e . f) g)
17:07:33 <lambdabot> (a (b (c (d (e (f g))))))
17:08:12 <ski> apparently the equalizer of `pl' and `unpl' isn't completely trivial
17:08:26 <Javran> ski: I guess those a b c d .. can be moved around and the function doesn't change?
17:08:39 <ski> moved around how ?
17:09:15 <Javran> like: (f1 . f2 . f3) ((g1 . g2 . g3) x) and (f1 . f2 . f3 . g1 . g2 ) (g3 x)
17:09:40 <__monty__> monchrom: I know it's a ridiculous amount of code to write in one go without testing. The problem was that the input for most functions was pretty complicated to generate by hand, so to easily test one function required another and another... You get the idea. I was hoping to get some pointers on how to write a haskell program in such a way that you can test it easily while writing.
17:09:44 <ski>      (a . b . c . d . e) . f
17:09:52 <ski>   =  a . b . c . d . e . f
17:10:01 <ski>   =  (a . b . c . d) . (e . f)
17:10:09 <ski> and so
17:10:21 <ski>      (a . b . c . d . e) (f g)
17:10:32 <ski>   =  ((a . b . c . d . e) . f) g
17:10:36 <ski>   =  (a . b . c . d . e . f) g
17:10:43 <ski>   =  ((a . b . c . d) . (e . f)) g
17:10:52 <ski>   =  (a . b . c . d) ((e . f) g)
17:11:03 <ski> the extra step here is because
17:11:06 <monochrom> ok, then it is not testing every 5-line chunk. instead, it is performing a test after every 5-line addition
17:11:06 <ski> @src (.)
17:11:06 <lambdabot> (f . g) x = f (g x)
17:11:06 <lambdabot> NB: In lambdabot,  (.) = fmap
17:11:15 <ski> Javran : does that help ?
17:11:24 <Javran> ski: I see, that helps!
17:12:04 <quchen> Even if you can't test your code for whatever reason it's a good idea to load it in GHCi every couple of lines, and fix static errors right away.
17:12:49 <Javran> ski: is this called "associativity"?
17:13:01 <ski> Javran : it's a generalized associativity, yes
17:13:09 <__monty__> Thanks for the help and good night everyone.
17:13:19 <monochrom> I mean, clearly, your code is organized as a 5-line definition called A which is independent of anything else, followed by a 5-line definition called B that depends on just A, followed by a 5-line definition called C that depends on just A and B, etc etc
17:13:25 <ski> Javran : the two steps in the first equality chain, i.e.
17:14:13 <Javran> ski: got it, thanks!
17:14:29 <monochrom> then I am saying that I cannot understand the mentality of starting to write B before even the most trivial sanity check on A, or write C before even the most trivial sanity check on A and B.
17:14:47 <monochrom> like, what is the author thinking? does he think he's Knuth?!
17:15:56 <ski> Javran : in general, if we know `forall a b c. a # (b # c) = (a # b) # c', for some operator `#', then we can prove that for any sequence `a # b # ... # y # z', with zero or more `#'s (and so at least one "operand"), it doesn't matter how we fully insert brackets to disambiguate, the expression will still denote the same value
17:16:26 <ski> iow, all those expressions can be shown to be pairwise equal
17:17:50 <edwardk_> monochrom: i'm pretty content to bang out a few thousand lines of haskell before i even try to compile it these days. the typechecker is remarkably good at telling me when i'm being an idiot when i go to finally compile it, and fixing my preconceptions usually fixes any structural bugs along the way
17:17:57 <edwardk_> and i'm definitely no knuth =P
17:18:26 <monochrom> ok, next time it will be "does he think he's edwardk?!".
17:18:53 <ski> Javran : .. if we also have an element `neutral' such that `forall b. neutral # b = b' and `forall a. a = neutral # a', then we can extend this to an `n'-ary combination of `n' operands with `#', even for the case when `n' is `0'
17:19:01 <ski> Javran : this is called a "monoid"
17:19:27 <edwardk_> monochrom: by contrast though, i feel the need to test every 10 lines of javascript =P
17:19:59 <ski> Javran : er, the second condition should be `forall a. a = a # neutral' ;)
17:20:08 <Javran> ski: neutral ~ mempty and # ~ mappend ?
17:20:18 * hackagebot epub-tools 2.4 - Command line utilities for working with epub files  http://hackage.haskell.org/package/epub-tools-2.4 (DinoMorelli)
17:20:33 <ski> if you want to use the terminology of the `Monoid' type class, sure
17:21:26 <ski> Javran : so then `a # b # ... # y # z' corresponds to `mconcat [a,b,...,y,z]'
17:21:27 <Javran> ski: and I guess there are also some connections to Control.Category?
17:21:37 <monochrom> Knuth is a newbie in terms of Haskell anyway!
17:21:54 <dagle> "Signal might not be sent" Gtk programming <3
17:22:04 <Javran> say (#) ~ (.) and neutral ~ id ?
17:22:28 <quchen> A few thousand lines!?
17:22:53 <monochrom> that's edwardk for you! :)
17:23:15 <ski> Javran : and then the generalized associative law above amounts to `forall a0 ... h0 j0 ... z0 a1 ... z1. mconcat [a0,b0,...,h0,mconcat [a1,...,z1],j0,...,z0] = mconcat [a0,b0,...,h0,a1,...,z1,j0,...,z0]'
17:24:07 <SwashBuckla> is it possible to get GHC to only check for syntax/type sanity as opposed to actually compiling and building an object file?
17:24:46 <Javran> ski: sounds like a "flatten"
17:24:48 <ski> Javran : or, less parabolic written : `forall as0 as1 as2. mconcat (as0 ++ [mconcat as1] ++ as2) = mconcat (as0 ++ as1 + as2)'
17:25:49 <ski> Javran : another generalized associative law says `forall ass. mconcat (map mconcat ass) = mconcat (concat ass)'
17:26:19 <k00mi> SwashBuckla: -fno-code I think
17:27:01 <ski> (there's probably some deep connection to lists being the free monoid, for the latter law, but alas i don't know it)
17:28:19 <Javran> ski: another missing piece for me is that: given (-> a) is a reader monad, I'm trying to establish some connection between (.) and (>=>), would that work?
17:28:45 <shachaf> ski: That law just says that mconcat is a [] monad algebra, right?
17:29:10 <ski> hm .. this law claims `mconcat . map mconcat = mconcat . concat', or with more CT notation, `mconcat . List mconcat = mconcat . concat', hmm
17:29:14 <SwashBuckla> k00mi: yes that had the desired result, thanks :)
17:29:31 <shachaf> Monoids are just free monoid monad monad algebras, and all that.
17:30:05 <Javran> that is "free monoid"?
17:30:05 <ski> shachaf : it probably says just that, yes
17:30:05 <dmj`> when someone says ADT, they mean algebraic datatype ...right?
17:30:17 <ski> dmj` : sometimes people mean "Abstract Data Type"
17:30:31 <shachaf> Except when they mean -- yes, that. Which often means roughly the opposite.
17:31:08 <ski> shachaf : i didn't follow the "monad monad algebras" part
17:31:39 <shachaf> ski: T-algebras of the free monoid monad.
17:31:54 <dmj`> when will GHC let me use the same record field names? data D = D { name :: Text }, data C = C { name :: Text } ?
17:32:03 <dmj`> across different ADT's, in the same module
17:32:04 <shachaf> That phrasing is deliberately obscure, probably best to ignore it.
17:32:23 <ski> Javran : probably connecting `(>=>)' with `(.)' won't have much to do with environment monads
17:32:41 <quchen> dmj`: Soon, https://ghc.haskell.org/trac/ghc/wiki/Records/OverloadedRecordFields
17:32:42 <dwcook> dmj`, don't count on it. Renaming or separating into different modules is a better bet
17:32:47 <dwcook> Oh, never mind then
17:32:55 <ski> shachaf : `T' being which endofunctor ?
17:33:13 <ski> i suppose the `List' one
17:33:36 <ski> (being the free monoid monad)
17:33:38 <shachaf> Yes.
17:34:18 <ski> hm, right every adjunction gives rise to a monad
17:34:19 <Javran> ski: I see..so what is "free monoid" ..didn't get it through wiki
17:34:35 <dwcook> Lists are the free monoid
17:35:13 <ski> Javran : "free" here is a (somewhat) obscure technical Category Theoretic term
17:36:02 <ski> shachaf : so i suppose "Monoids are just free monoid monad monad algebras" generalizes to any adjoint situation ?
17:36:05 <dwcook> I don't think it's obscure so much as not rigorous
17:36:18 <shachaf> ski: Xs are just free X monad monad algebras
17:36:30 <shachaf> ski: The original was "monads are just free monad monad monad algebras"
17:36:30 <Javran> ski: If I understand it correctly, "free monad" is a monad with the definition of "join" delayed?
17:36:42 <ski> shachaf : cute :)
17:36:53 <dwcook> Javran, no, it's a monad formed from an underlying structure, in this case any functor will do
17:37:06 <shachaf> I feel like this is more on the confusing and less on the helpful side so maybe it belongs in #-blah.
17:37:15 <dwcook> @google understanding free monads
17:37:16 <lambdabot> http://stackoverflow.com/questions/13352205/what-are-free-monads
17:37:16 <lambdabot> Title: haskell - What are free monads? - Stack Overflow
17:37:24 <dwcook> That works.
17:37:35 <ski> shachaf : well, helpful for me. perhaps not so much for Javran
17:38:11 <shachaf> ski: Similarly comonads are just cofree comonad comonad comonad coalgebras.
17:38:26 <Javran> dwcook: since they are all called "free", so I guess those two "free"s are of the same meaning?
17:38:48 <ski> Javran : "free" is always relative to some underlying "base" category. depending on what one takes as the base, it will mean different things
17:38:49 <dwcook> Javran, "free" has this general "feel" to it but is not rigorously defined.
17:39:05 <shachaf> "free" is certainly rigorously defined.
17:39:19 <Javran> I see
17:39:28 <dwcook> shachaf, in what sense?
17:39:32 <ski> shachaf : generally, i don't very well understand Eilenberg-Moore
17:39:33 <shachaf> Many senses.
17:39:42 <shachaf> https://en.wikipedia.org/wiki/Free_object
17:39:43 <dmj`> has anyone ever shared a cabal sandbox across linux and windows
17:39:45 <ski> (though i think it has improved lately)
17:40:28 <flebron> So, small lambda calculus parser + evaluator (30 lines each). Style/idiom comments? http://lpaste.net/1425340993745453056 . Thanks in advance :)
17:41:31 <dwcook> shachaf, I suppose I was expressing myself poorly. Thanks for the link.
17:41:59 <ski> flebron : "Warning: Redundant bracket"
17:42:23 <flebron> Yeah, saw that. :) I'm still afraid of going wild with operators and parentheses.
17:43:51 <quchen> Parse error: No documentation
17:44:09 <pavonia> Having (-->) as unary operator is confusing to me
17:44:10 <flebron> Heh, fair enough :) Thanks!
17:44:22 * ski would rename `Const' to `Var'
17:44:58 <quchen> wrap = join Parsec.between, by the way.
17:45:49 <Javran> @pl let g f x = f x x
17:45:49 <lambdabot> (line 1, column 18):
17:45:49 <lambdabot> unexpected end of input
17:45:49 <lambdabot> expecting variable, "(", operator, ";" or "in"
17:45:52 <flebron> Ah cool, didn't know that :) Figured someone would've ran into that by now.
17:46:01 <ski> i would write  (`filter` allVariables)  -- but maybe i'm strange
17:46:03 <Javran> @pl \f x -> f x x
17:46:03 <lambdabot> join
17:47:08 <ski> @type Data.Set.member
17:47:09 <lambdabot> Ord a => a -> S.Set a -> Bool
17:47:14 <ski> @type Data.Set.characteristic
17:47:15 <flebron> pavonia: Yeah it's kind of unfortunate, I wanted to use the notation of p -->> q for q derived by multiply beta-reductions from p, but then q would be a function of p, so "q = p -->>" in some weird way :p
17:47:15 <lambdabot> Not in scope: `Data.Set.characteristic'
17:49:02 <ski> `alpha' looks like substitution
17:49:20 <ski> i'd move the first argument so that it's the last
17:49:31 <flebron> I kind of conflated the two, yes. One is the renaming, and the other is [y <- x].
17:50:01 <flebron> ski: Question, how did you know to do that? Just because you saw pain somewhere in the use of flip?
17:50:05 <ski> the latter is (capture-avoiding) substitution
17:50:09 <orbital_> as
17:50:26 <flebron> (I know the genreal principle is "most varying thing for last", but I didn't know when writing the function what the most varying parameter would be!)
17:50:44 <ski> flebron : `alpha' just looked like it would benefit from that argument reordering. i haven't looked at uses yet
17:51:30 <ski> flebron : well, you can see that in the "structural" recursive calls, `x' and `e' are unchanged
17:51:34 <ski> that's what cued me
17:52:29 <ski> (for the remaining recursive call, i would probably fold it out into a separate function -- maybe calling it `alpha' :)
17:52:36 <flebron> So I should try to pattern match on the latter parameters of a function?
17:52:50 <ski> that can often be a good idea
17:52:55 <ski> sometimes it doesn't matter much
17:53:23 <ski> however, if you do, you can use the pattern
17:53:32 <ski>  subst x e = loop
17:53:33 <ski>     where
17:53:43 <Cale> Sometimes it's possible to optimise things by doing something like   f x = let <stuff> in \y -> case y ...
17:53:46 <ski>     loop (Lambda v t) = ..loop..
17:54:00 <Cale> Indeed, or like that :)
17:54:07 <ski> whether you like doing that or not is a separate question
17:55:33 <ski> also, i'd rename  e'  to  t'  there
17:55:47 <flebron> Yeah I've seen it in a lot of internal code, "foo bar = go where go = ...".
17:56:02 <ski> and  tau  to  v'  ?
17:57:40 <ski> `multibeta' is a fixpoint iteration (possibly you already know that)
17:58:32 <flebron> Is there a better way than what I'm doing? (Which is ugly since I needed Eq)
18:00:24 * hackagebot elm-server 0.11 - Server for developing Elm projects  http://hackage.haskell.org/package/elm-server-0.11 (EvanCzaplicki)
18:01:23 <ski> flebron : use `Maybe' for `beta' ?
18:01:32 <ski> and then possibly use `unfoldr'
18:01:59 <ski> @type unfoldr . (fmap (join (,)) .)
18:02:00 <lambdabot> (b -> Maybe b) -> b -> [b]
18:03:04 <ski> of course you'll need to idiomize or monadize `beta' then
18:03:08 <flebron> Is that something that people usually do? iterate (I assume that's how you were hinting at fixpoints, or did you mean straight up fix :: (a -> a) -> a?)
18:03:17 <flebron> * and then unfoldr?
18:03:38 <ski> `iterate' does infinite iteration, not fixpoint iteration
18:04:02 <ski> (and no, i didn't mean `fix')
18:05:24 * hackagebot rainbox 0.2.0.0 - Two-dimensional box pretty printing, with colors  http://hackage.haskell.org/package/rainbox-0.2.0.0 (OmariNorman)
18:05:25 <ski> .. perhaps i should say *finite* fixed-point iteration
18:06:21 <ski> (but that's often (not always) what is meant, in computing sciency applications. like e.g. deductive databases)
18:15:23 <Javran> @pl \x y z -> x + y - z
18:15:23 <lambdabot> ((-) .) . (+)
18:17:26 <Iceland_jack> :t let (.:) = (.).(.) in (-) .: (+)
18:17:27 <lambdabot> Num b => b -> b -> b -> b
18:22:22 <dagle> A leftover ghc process was running, using 6GB memory.
18:23:47 <Mars> hello
18:24:04 <startling> dagle: haha
18:24:20 <Guest74498> May I ask question about installing leksah?
18:24:38 <shachaf> You've already asked one.
18:24:44 <Guest74498> hehe
18:25:01 <shachaf> (Really, just ask your questions. Don't ask to ask.)
18:25:43 <Guest74498> I got a problem when building the program: src/Text/PrinterParser.hs:230:42: Not in scope: `catch'
18:25:54 <Guest74498> Failed to install ltk-0.8.0.6
18:26:55 <enthropy> they got rid of Prelude.catch when ghc-7.6 came out
18:27:10 <Guest74498> I googled and found somebody on stackoverflow suggested installing ltk-0.8.0.6 directly
18:27:20 <enthropy> Guest74498: maybe there is an ltk that has been updated?
18:27:44 <Guest74498> I'm not sure about that
18:28:00 <Guest74498> I used cabal install leksah to install it
18:31:56 <startling> Guest74498: leksah is weird and old, if you just want to write Haskell you probably shouldn't use it.
18:32:19 <enthropy> Guest74498: I think the problem is that you have not done a `cabal update' in a while?
18:32:43 <Guest74498> I think I just did it
18:32:47 <enthropy> http://hackage.haskell.org/package/ltk-0.8.0.6 is from 2010, but the newest one has been updated recently
18:33:21 <pharaun> so we're not encouraging usage of leksah?
18:34:03 <pharaun> never used, seemed cool
18:34:10 <enthropy> "weird and old" probably needs some backing up
18:34:37 <enthropy> hamishmack: is around to agree/disagree?
18:34:45 <pharaun> latest news is 2012 on the website
18:34:57 <pharaun> but i see a 0.13 up on hackage now
18:34:58 <Guest74498> I found it from haskellWiki
18:35:22 <enthropy> Guest74498: ok well you can cabal install leksah --constraint 'ltk >= 0.13'
18:35:29 <startling> I've tried to help multiple new-to-haskell people get it installed here, it always ends up being a huge hassle and they usually decide not to use it.
18:35:30 <Guest74498> and it sounds petty decent one
18:35:31 <pharaun> there's a 2014 update so should work
18:35:33 <enthropy> and there may be a hint as to why that one isn't possible
18:37:00 <Guest74498> I just tried cabal install ltk
18:37:05 <Guest74498> and got The pkg-config package gtk+-3.0 is required but it could not be found
18:37:41 <pharaun> any general recommendation for logs? i've been manually logging to files - would hslogger be recommended?
18:37:58 <Guest74498> I just installed gtk2.0 as the old version required...
18:40:54 <Guest74498> enthropy: I got "Failed to install regex-posix-0.72.0.3" when cabal install leksah --constraint 'ltk >= 0.13'
18:42:35 <SrPx> Is there any library to write graphical applications such as games and 3D viewers in a functional style? I'm aware of the OpenGL API, but it is pretty much a wrapper around the C api, so very imperative style. I was thinking something more on the line of writing code functionally with folds etc and that being translated to OpenGL/CUDA/whateverGPU under the hoods.
18:43:20 <enthropy> Guest74498: based on that I can't say why regex-posix-0.72.0.3 didn't work
18:44:32 <Guest74498> Text/Regex/Posix/Wrap.hsc:312:1:     Unacceptable argument type in foreign declaration: CInt     When checking declaration:       foreign import ccall unsafe "static regcomp" c_regcomp         :: Ptr CRegex -> CString -> CompOption -> IO ReturnCode  Text/Regex/Posix/Wrap.hsc:312:1:     Unacceptable result type in foreign declaration: IO CInt     When checking declaration:       foreign import ccall unsafe "static regcomp" c_regco
18:53:37 <Guest74498> I was trying to build the old version ltk-0.8.0.6 as somebody suggested on stackoverflow but got this msg: Setup.lhs: At least the following dependencies are missing: glib >=0.10.0, gtk >=0.10.0
18:53:53 <Guest74498> the problem is I just installed these 2 pkgs
18:54:14 <Guest74498> $ ghc-pkg latest --user gtk gtk-0.12.5.6
18:54:30 <Guest74498> ghc-pkg latest --user glib glib-0.12.5.3
18:55:01 <Guest74498> should I do something to let Setup.lhs find these pkgs?
18:59:03 <Guest74498> anybody can give me some hints?
18:59:20 <m09> I don't get why this program prints false: https://gist.github.com/m09/9732920 shouldn't c and d point to the a object in the heap?
19:03:34 <ski> @type GHC.Prim.reallyUnsafePtrEquality#  -- m09, perhaps you meant to use this ?
19:03:35 <lambdabot> a -> a -> GHC.Prim.Int#
19:03:57 <hamishmack> Guest74498: Can you try cabal install leksah --constraint='leksah>=0.13'
19:04:56 <Guest74498> hamishmack: I got "Failed to install regex-posix-0.72.0.3" when cabal install leksah --constraint 'ltk >= 0.13'
19:05:10 <Fuuzetsu> what names do we have to give things if reallyUnsafe* no longer cuts it?
19:05:26 <Fuuzetsu> setYourHouseOnFire*
19:05:51 <hamishmack> what if you just do cabal install regex-posix ?
19:06:27 <m09> ski: sorry to ask but I'm not sure how to use that, it produces a parse error on #
19:07:06 <Guest74498> hamishmack: All the requested packages are already installed: regex-posix-0.95.2
19:07:47 <startling> m09, {-# Language MagicHash #-}
19:07:54 <m09> thanks :)
19:08:07 <hamishmack> Cool so there might be an upper bound somewhere that needs updating
19:08:12 <ski> m09 : anyway, iiuc, `newStablePtr' makes a new `StablePtr' for each execution
19:08:12 <hamishmack> I’ll have a look now
19:08:52 <ski> m09 : perhaps there's a slightly less unsafe variant of `reallyUnsafePtrEquality#' around somewhere
19:09:00 * ski can't recall
19:09:28 <m09> so you think the === operator I use doesn't decide correctly whether or not the object is the same in the heap?
19:09:48 <hamishmack> Guest74498: What happens if you try cabal install leksah --constraint 'ltk >= 0.13' again now that regex-posix is installed?
19:10:28 <hamishmack> Guest74498: Also what GHC version and OS are you using?
19:12:18 <hamishmack> Guest74498: This error “The pkg-config package gtk+-3.0 is required but it could not be found” that you reported earlier, indicates that the C dev packages for gtk, gtksourceview and webkitgtk may not be installed
19:13:00 <Guest74498> hamishmack: I'm using ghc7.6.3 and Mac os x 10.8
19:13:19 <hamishmack> How did you install gtk?
19:13:33 <Guest74498> port install gtk
19:14:30 <hamishmack> ok that might work, but if you want gtk3 you might need to “port install gtk3” too
19:14:59 <Guest74498> I think only the new version of ltk requires gtk3.0. When I used cabal install leksah, it didn't complain about the gtk
19:15:42 <hamishmack> You can install the new version of leksah with gtk 2 too if you want
19:15:55 <hamishmack> use cabal install leksah -f-gtk3
19:15:56 <Guest74498> how should I do that?
19:16:08 <Guest74498> thanks, I'm trying
19:16:17 <Fuuzetsu> where's the list of GHC error codes again? Lost that thing again
19:17:05 <Guest74498> hamishmack: I think this cannot bypass the ltk-0.8.0.6 problem
19:17:10 <hamishmack> port install webkitgtk gtksourceview2
19:17:48 <Guest74498> I was trying to build the old version ltk-0.8.0.6 as somebody suggested on stackoverflow but got this msg: Setup.lhs: At least the following dependencies are missing: glib >=0.10.0, gtk >=0.10.0
19:18:04 <hamishmack> That is a really bad idea
19:18:29 <hamishmack> 0.8.0.6 predates GHC 7.6.3 by so much it will never work
19:18:47 <hamishmack> I don’t think 0.12 works with 7.6.3
19:19:20 <Guest74498> ok, I will try to install gtk3 first
19:20:31 <tavoevoe> I'm having a lot of trouble getting test values for my code, and outputting values mid-way through my code. Any advise?
19:21:08 <ski> m09 : yes
19:22:36 <hamishmack> Guest74498: You need to install ghc with macports too BTW (the haskell platform package uses the wrong libiconv and libgmp)
19:23:17 <hamishmack> Guest74498: This might help… http://sourceforge.net/p/gtk2hs/mailman/message/32117872/
19:24:12 <Guest74498> hamishmack: can I just update libiconv and libgmp?
19:24:48 <tavoevoe> An example. How do I convert this: main = return "a string" >>= \message -> print message >> print message
19:24:51 <tavoevoe> to do notation?
19:25:17 <ion> do { message <- return "a string"; print message; print message }
19:25:48 <Fuuzetsu> @do return "a string" >>= \message -> print message >> print message
19:25:48 <lambdabot> do { message <- return "a string"; print message; print message}
19:25:54 <hamishmack> Guest74498: Not as far as I know
19:25:59 <tavoevoe> thank you
19:26:42 <Fuuzetsu> hm, I should hook up a function to convert between do and undo notation in to my text editor
19:26:59 <Guest74498> hamishmack: will the ghc installed by "port install ghc" produce any conflict with the current ghc on my computer?
19:27:09 <tavoevoe> I think that would be kind of nifty
19:28:16 <hamishmack> Guest74498: Only place it might is in ~/.ghc
19:28:43 <hamishmack> and perhaps ~/.cabal
19:29:36 <hamishmack> You can have multiple ghc’s installed easily enough
19:29:46 <hamishmack> but if they are both 7.6.3
19:30:12 <MrElendig> Guest74498: cabal sandbox can be really handy
19:30:14 <hamishmack> then I think they might try to put files in the same place
19:30:19 <MrElendig> Guest74498: fix your nick btw
19:30:57 <ion> MrElendig: fix your nick btw
19:31:07 <Guest74498> hamishmack: this is strange: I just installed gtk3 and tried "cabal install leksah --constraint 'ltk >= 0.13'" again but I still got the msg: Failed to install regex-posix-0.72.0.3
19:31:40 <MrElendig> ion: I'm not the one who tried to use a nick that is already registered and got kicked off it
19:32:16 <tavoevoe> Ok. I figured out my confusion. For the record, the ";" is manditory syntax if you want the value to continue on
19:34:00 <mars0000> MrElendig: I'm using this now. First time to use irc, sorry about that
19:34:18 <MrElendig> no worry
19:34:19 <ski> tavoevoe : not if you break it, with one command on each line, indented properly
19:34:29 <ski>   do message <- return "a string"
19:34:32 <ski>      print message
19:34:33 <ski>      print message
19:34:44 <MrElendig> mars0000: you probably want to register it btw
19:34:50 <ski> or possibly
19:34:58 <ski>   foo x y z = do
19:35:01 <MrElendig> http://freenode.net/faq.shtml#nicksetup
19:35:02 <ski>     message <- return "a string"
19:35:07 <ski>     print message
19:35:07 <ski>     print message
19:35:14 <ski> tavoevoe ^
19:36:39 <ski> mars0000 : welcome to IRC
19:36:47 <jle`> return "a string" >>= replicateM_ 2  . print
19:37:34 <hamishmack> Guest74498: Can you try cabal install leksah --constraint 'ltk >= 0.13' --constraint 'regex-posix == 0.95.2'
19:38:36 <hamishmack> Guest74498: Actually this might be better… cabal install leksah --constraint ‘leksah >= 0.13' --constraint 'regex-posix == 0.95.2'
19:38:44 <ski> mars0000 : while #haskell is usually a pretty busy channel, note that in general, it's considered polite to ask one's real question without questions like "is anyone here ?" or "does anyone know about ... ?", and then wait at *least* a few hours before leaving the channel
19:39:24 <jle`> who has time for that
19:39:32 <jle`> :)
19:39:38 <ski> of course you can do other things in the meantime
19:40:19 <mars0000> hamishmack: this is what I got:cabal: Could not resolve dependencies:
19:40:19 <mars0000> trying: leksah-0.13.3.0
19:40:21 <mars0000> trying: leksah-0.13.3.0:+webkit
19:40:22 <mars0000> trying: jsaddle-0.1.1.4
19:40:22 <ski> the important part is that you don't leave the channel too quickly, and that you check back at least once before leaving, to see whether anyone tried to respond
19:40:23 <mars0000> trying: jsaddle-0.1.1.4:+jsffi
19:40:24 <mars0000> trying: jsaddle-0.1.1.4:+ghcjs
19:41:06 * ski idly wonders whether Guest74498 is the same as mars0000
19:41:29 <m09> ski: I used ghc-vis to inspect the sharing and it seems fine. Thanks for invalidating my first tool for inspecting :]
19:42:17 <ski> np
19:43:17 <gyeh> hey, does anyone know a way to do set theory in haskell? like, for example, existential and universial quantification?
19:43:36 <mars0000> hamishmack: I got the same msg when using "cabal install leksah --constraint 'leksah >= 0.13' --constraint 'regex-posix == 0.95.2'" and "cabal install leksah --constraint 'ltk >= 0.13' --constraint 'regex-posix == 0.95.2'"
19:43:56 <Fuuzetsu> gyeh: ‘do set theory’ is not a very precise term
19:44:55 <hamishmack> mars0000: Can you use this http://lpaste.net/ to send the output of “ghc-pkg list”
19:46:03 <mars0000> hamishmack: sorry, i didn't get it. what is this webpage for?
19:46:07 <hamishmack> mars0000: Also the full output of cabal install leksah --constraint 'leksah >= 0.13' --constraint 'regex-posix == 0.95.2’ -j1
19:49:28 <gyeh> Fuuzetsu: I guess specifically something like propositional logic with quantifiers
19:49:54 <gyeh> Fuuzetsu: Also supporting set operations like a U b U c...
19:51:50 <ski> it's not clear what you want to do with it
19:52:00 <ski> just represent the formulae ?
19:52:41 <gyeh> well, check if statements are true/false
19:52:50 <gyeh> like logical programming
19:53:00 <gyeh> query a set of statements, etc... like prolog
19:53:45 <Fuuzetsu> if you want proofs, something like Agda might be a better pick
19:54:32 <no-n> > map (join (*)) [1..7]
19:54:34 <lambdabot>  [1,4,9,16,25,36,49]
19:54:45 <Fuuzetsu> if you just want to play with sets then Haskell is fine ;)
19:54:56 <jle`> or maybe you can use haskell sets + quickcheck :P
19:55:12 <jle`> quickcheck is a theorem prover, right...?
19:55:26 <Fuuzetsu> someone might think you're serious
19:55:40 <Fuuzetsu> > quickcheck (\x y -> x == y)
19:55:41 <lambdabot>  Not in scope: `quickcheck'
19:55:41 <lambdabot>  Perhaps you meant one of these:
19:55:41 <lambdabot>    `quickCheck' (imported from Lambdabot.Plugin.Haskell.Eval.Trusted),
19:55:41 <lambdabot>    `myquickcheck' (imported from Lambdabot.Plugin.Haskell.Eval.Trusted)
19:55:44 <Iceland_jack> hehe
19:55:46 <Fuuzetsu> > quickCheck (\x y -> x == y)
19:55:48 <lambdabot>  <IO ()>
19:56:11 <jle`> @check \x y -> x == y
19:56:12 <lambdabot>  +++ OK, passed 100 tests.
19:56:17 <Fuuzetsu> ah there we are
19:56:17 <jle`> sweet
19:56:25 <Iceland_jack> jle`: You should write a paper
19:57:07 <jle`> @check \x y -> (x :: Int) == y
19:57:08 <lambdabot>  *** Failed! Falsifiable (after 1 test and 1 shrink):
19:57:09 <lambdabot>  1 0
19:57:23 <Fuuzetsu> would the paper be on horrible misconceptions caused by #haskell jokes?
19:57:44 <jle`> @check \xs -> length xs == length (sort xs)
19:57:46 <lambdabot>  +++ OK, passed 100 tests.
19:57:46 <Iceland_jack> I was under the impression that jokes were off topic on #haskell
19:57:52 <c_wraith> @faq can haskell solve the halting problem?
19:57:53 <lambdabot> The answer is: Yes! Haskell can do that.
19:58:18 <MP2E> haha
19:58:18 <MP2E> haha
19:58:21 <AshyIsMe> :t quickCheck
19:58:22 <lambdabot> Testable prop => prop -> IO ()
19:58:25 <dmwit> gyeh: If you want prolog, look at LogicT.
19:58:26 <Iceland_jack> @check (length >>= take >>= (==))
19:58:27 <lambdabot>  +++ OK, passed 100 tests.
19:58:42 <dmwit> ?hackage logict
19:58:43 <lambdabot> http://hackage.haskell.org/package/logict
19:58:53 <tnks> do you guys use iwatch from a Makefile for looping the compiler when in Vim?
19:59:00 <tnks> or is there a fancier way?
19:59:20 <dmwit> tnks: I do something even less fancy: I just keep ghci open and :r.
19:59:34 <Fuuzetsu> :t unsafePerformIO
19:59:34 <lambdabot> Not in scope: `unsafePerformIO'
19:59:35 <tnks> dmwit: yeah, I'll take fast feedback if I can get it.
20:01:11 <jle`> @check \xs ys -> let s1 = S.fromList xs; s2 = S.fromList ys; in S.size s1 ++ S.size s2 == S.size ( s1 `S.union` s2 ) - S.size ( s1 `S.intersection` s2 )
20:01:12 <lambdabot>  Couldn't match expected type `[a0]'
20:01:12 <lambdabot>  with actual type `GHC.Types.Int'Couldn't match expected type `[a0]' with act...
20:01:26 <jle`> @check \xs ys -> let s1 = S.fromList xs; s2 = S.fromList ys; in S.size s1 + S.size s2 == S.size ( s1 `S.union` s2 ) - S.size ( s1 `S.intersection` s2 )
20:01:28 <lambdabot>  *** Failed! Falsifiable (after 3 tests and 1 shrink):
20:01:28 <lambdabot>  [()] [()]
20:01:41 <jle`> oh yeah
20:01:46 <jle`> @check \xs ys -> let s1 = S.fromList xs; s2 = S.fromList ys; in S.size s1 + S.size s2 == S.size ( s1 `S.union` s2 ) + S.size ( s1 `S.intersection` s2 )
20:01:48 <lambdabot>  +++ OK, passed 100 tests.
20:01:51 <jle`> sweet
20:01:55 <jle`> free set theory theorem prover
20:02:12 <Fuuzetsu> 100 test cases = proof
20:02:46 <Iceland_jack> Fuuzetsu: Come on, you need at least 300
20:03:04 <jle`> but what if 301 fails?
20:03:05 <jle`> i suggest 302.
20:03:16 <Iceland_jack> jle`: Didn't think of 301
20:03:23 <jle`> nobody ever does!
20:03:27 <jle`> no shame in that
20:03:28 <Fuuzetsu> I run 100000 in Haddock if I'm feeling like generous and have a lot of time to kill
20:03:34 <Fuuzetsu> s/like//
20:03:54 <Iceland_jack> Actually reminds me of a Futurama quote
20:03:55 <Iceland_jack>     Zoidberg> All six thousand hulls have been breached.
20:03:55 <Iceland_jack>     Fry> Oh, the fools! Why didn't they build it with six thousand and one hulls? When will they learn?
20:04:10 <unfoobar> Hello, I have a Question About Concurrent Haskell: http://lpaste.net/101653
20:04:21 <jle`> oh, the fools.
20:04:50 <Iceland_jack> so yeah, throw in 303 for good measure and you've got a proof
20:05:05 <jle`> idk how to do that on lambdabot
20:05:16 <jle`> so for now we're going to have to live with being 33% sure that the theorem is true
20:05:30 <jle`> at least our ignorance is quantifiable!
20:05:42 <Fuuzetsu> unfoobar: isn't it because chan is empty and you try to read from it first thing in foo?
20:05:51 <Fuuzetsu> if that's not it then it's high time for me to go to bed
20:05:58 <Iceland_jack> I prefer 100% certainty of being wrong than slightly unsure about being right!
20:06:12 <jle`> unfoobar: what happens? does it terminate?
20:06:15 <dmwit> unfoobar: You are asking `bar` to atomically create an empty TMVar and then read from it.
20:06:19 <dmwit> unfoobar: *atomically*
20:06:34 <dmwit> unfoobar: Meaning nothing else can (observably) write to that TMVar.
20:07:09 <Fuuzetsu> So I was wrong. Good night.
20:07:17 <dibblego> what is something that is Eq but not Ord?
20:07:25 <dmwit> dibblego: IORef
20:07:37 <dmwit> dibblego: or Complex
20:07:50 <jle`> or anything that doesn't make sense to order
20:07:54 <Fuuzetsu> Bool
20:08:01 <Iceland_jack> jle`: Float/Double…?
20:08:05 <dmwit> Fuuzetsu: eh?
20:08:06 * Iceland_jack ducks
20:08:06 <Fuuzetsu> actually Bool seems to have Ord for whatever reason
20:08:07 <jle`> Bool is ord in Haskell i think?
20:08:08 <dmwit> > True < False
20:08:09 <lambdabot>  False
20:08:10 <dibblego> awesome thanks
20:08:10 <Fuuzetsu> but why
20:08:13 <Iceland_jack> Bool shouldn't erally be ord
20:08:16 <Iceland_jack> *really
20:08:16 <dmwit> FUZxxl: why not?
20:08:18 <jle`> i think it's for hax
20:08:19 <dmwit> uh
20:08:23 <dmwit> Fuuzetsu: why not?
20:08:26 <jle`> it's for being clever
20:08:28 <Fuuzetsu> ^
20:08:49 <startling> Ord is a subclass of Enum, isn't it?
20:08:56 <startling> sorry, superclass
20:08:59 <Fuuzetsu> it makes me think back to all those terrible languages with Bool being an int or something
20:08:59 <jle`> i think...it's not
20:09:05 <jle`> wait
20:09:08 <dmwit> startling: no, I don't think so
20:09:09 <no-n> @src join
20:09:09 <lambdabot> join x =  x >>= id
20:09:14 <startling> > [False..True] -- would be a shame not to be able to do this ;)
20:09:15 <lambdabot>  A section must be enclosed in parentheses thus: (False.. True)Not in scope: ...
20:09:26 <startling> > [False.. True] -- would be a shame not to be able to do this ;)
20:09:27 <lambdabot>  A section must be enclosed in parentheses thus: (False.. True)Not in scope: ...
20:09:29 <Fuuzetsu> no-n: I wish that it was id >=> id on regular basis
20:09:32 <startling> well
20:09:32 <jle`> startling: yeah, enum and ord are independent
20:09:33 <dmwit> > [False ..True]
20:09:34 <lambdabot>  [False,True]
20:09:43 <startling> ah
20:09:55 <jle`> and so is bounded i think
20:10:02 * Fuuzetsu zzz
20:10:02 <Iceland_jack> > [minBound..maxBound] :: [Bool]
20:10:04 <lambdabot>  [False,True]
20:10:11 <Iceland_jack> Imagine if we had to write [False,True] by hand
20:10:12 <Iceland_jack> yuck
20:10:38 <Fuuzetsu> > [minBound ..] :: [Bool]
20:10:39 <lambdabot>  [False,True]
20:10:45 <Fuuzetsu> save the keystrokes
20:10:59 <unfoobar> Thanks Fuuzetsu, jle`, and dmwit. dmwit was right. it terminates with the correction: http://lpaste.net/101653
20:11:03 <sipa> > [..] :: [Bool]
20:11:04 <dmwit> universe :: [Bool] -- =)
20:11:04 <startling> Iceland_jack: yeah, exactly
20:11:04 <lambdabot>  <hint>:1:2: parse error on input `..'
20:11:06 <Iceland_jack> Fuuzetsu: Or propose a patch for GHC where [..] is shorthand for [minBound..]
20:11:20 <Fuuzetsu> Iceland_jack: I might tomorrow if I remember
20:11:41 <Iceland_jack> Writing silly shorthands for [False, True] is what separates us from other animals
20:11:42 <dibblego> why might I find the instance Eq for IORef?
20:11:57 <dibblego> er that was a great sentence, well done
20:12:20 <ski> dibblego : in the run-time system, probably ?
20:12:45 <dmwit> instance Eq (IORef a) where IORef x == IORef y = x == y
20:12:50 <dmwit> http://hackage.haskell.org/package/base-4.6.0.1/docs/src/GHC-IORef.html#IORef
20:12:51 <dmwit> =)
20:12:58 <dibblego> yeah I found it in GHC.IORef
20:13:09 <dmwit> Of course, that just means you probably want to know about the source for STRef's Eq instance.
20:13:18 <Iceland_jack> dibblego: You can probably find it by searching for 'instance Eq IORef' on your favourite search engine
20:13:25 <dibblego> instance Eq (STRef s a) where
20:13:25 <dibblego>     STRef v1# == STRef v2# = sameMutVar# v1# v2#
20:13:52 <dibblego> ok, so it's pointer equality
20:14:26 <ski> yes
20:14:36 <dmwit> Oh, yes, I could have told you that straight from the beginning.
20:14:45 <dmwit> In fact, you should know it just from the instance line without even seeing the method.
20:14:57 <dmwit> instance Eq (IORef a) -- note, no (Eq a) context
20:15:15 <dibblego> I am always cautious about applying reasoning on things like that, but yeah :)
20:15:42 <dmwit> Well, that's fair. s/know/guess/, and then you probably did that after all
20:16:04 <dibblego> yeah I guessed it, cheers for the help
20:30:41 * hackagebot aws-sdk 0.12.3 - AWS SDK for Haskell  http://hackage.haskell.org/package/aws-sdk-0.12.3 (YusukeNomura)
20:31:35 <no-n> ((+) >>= id) 5 -- How does it "know" what it's partially applied argument "was"?
20:31:48 <no-n> > ((+) >>= id) 5 -- oops
20:31:49 <lambdabot>  10
20:31:59 <no-n> also its
20:33:06 <ski> @src (->) (>>=)
20:33:07 <lambdabot> f >>= k = \ r -> k (f r) r
20:33:30 <dibblego> no-n: all haskell functions take one argument, including (+) and the monad for ((->) e) is on that argument (the input)
20:33:55 <no-n> I know but
20:35:49 <pavonia> no-n: Look at the definition of (>>=), it passes the argument to both functions
20:36:24 <no-n> oh, okay
20:36:30 <no-n> so it's a cheat, rather than a consequence :P
20:37:34 <gyeh> :dmwit thanks
20:37:40 <gyeh> dmwit: thanks
20:37:44 <gyeh> lambdabot: ty
20:38:01 <tavoevoe> lamba expressions + point free. do I dare, and how?
20:38:02 <SrPx> Woa I just actually made someone learn Haskell for real. And by that I mean the person starts looking for things by himself after we stop, and adopting it as his main programming language. I feel so accomplished.
20:38:40 <MP2E> SrPx : wow :O
20:38:40 <MP2E> I've told everyone about it and no one carse :(
20:38:41 <MP2E> cares*
20:38:52 <SrPx> BTW I asked this earlier but nobody replied, may I ask again: Is there any library to write graphical applications such as games and 3D viewers in a functional style? I'm aware of the OpenGL API, but it is pretty much a wrapper around the C api, so very imperative style. I was thinking something more on the line of writing code functionally with folds etc and that being translated to OpenGL/CUDA/whateverGPU under the hoods.
20:39:16 <SrPx> MP2E: I told a lot of people and nobody cared too
20:39:24 <no-n> it's sort of my main language atm too
20:39:27 <no-n> i'm pretty noob tho
20:39:41 <no-n> i did a bit of python, c, asm before this
20:39:46 <MP2E> same actually
20:39:49 <MP2E> that's kinda funny
20:40:06 <MP2E> every little thing I find in haskell I just think "YES, why hasn't it always been like this?"
20:40:09 <MP2E> heh
20:40:09 <MP2E> so far at least
20:40:10 <MP2E> :)
20:40:25 <no-n> yeah, all those other langs are nasty in comparison
20:40:47 <SrPx> Haskell has everything to be one of the #5 languages. It is not, not because it is hard or anything like that. It is not because we don't want to. I, for example, have ideas that could get a lot of people to actively use it, but then I don't want to do a disfavour to the community
20:41:11 <SrPx> MP2E: yes!
20:42:08 <tavoevoe> I, on the other hand feel like I'm 80% why won't this compile? I'm going back to x
20:42:30 <tavoevoe> But I love it so much conceptually, I'm pushing through until it becauses natural(ish)
20:42:42 <no-n> > \r -> id ((+) r) r $ 5
20:42:43 <lambdabot>  No instance for (Data.Typeable.Internal.Typeable t0)
20:42:43 <lambdabot>    arising from a use of `M536649706963207058729106.show_M5366497069632070587...
20:42:43 <lambdabot>  The type variable `t0' is ambiguous
20:42:43 <lambdabot>  Possible fix: add a type signature that fixes these type variable(s)
20:42:43 <lambdabot>  Note: there are several potential instances:
20:42:52 <no-n> > (\r -> id ((+) r) r)  5
20:42:53 <lambdabot>  10
20:43:08 <Iceland_jack> > join (+) 5
20:43:09 <lambdabot>  10
20:43:20 <no-n> that's what I was trying to decode, Iceland_jack :P
20:43:33 <Iceland_jack> no-n: Or a more advanced version!
20:43:33 <Iceland_jack> > 5 + 5
20:43:34 <lambdabot>  10
20:43:41 <no-n> !
20:43:42 <ski> no-n : you should probably avoid reaching for `$' more
20:43:53 <pyon> Is it possible to do anything similar to -XDeriveFunctor for bifunctor?
20:43:55 <no-n> ya
20:44:17 <edwardk> pyon: sadly no
20:44:26 <silasm> I just joined recently, but if you're evangelizing haskell based on it having good design to your fellow coders, you're probably fighting a losing battle. Even if your friends do learn it, they'll probably only use it for personal projects, and I think Haskell being fun and forcing me to think in different ways is the real killer for me there ;).
20:45:18 <edwardk> pyon: i'd take a patch to the bifunctors package that added lens-like template haskell to make Bifunctor, Bifoldable, and Bitraversable instances though
20:45:31 <silasm> if you're trying to evangelize it to clients or whatever that's another story, but not one I can help with.
20:45:59 <andkore> Is there any concern in the Haskell community that Haskell is moving towards being an implementation defined language? What with the dominance of GHC, and the existence of libraries that depend on GHC extensions...
20:47:01 <no-n> glasgow haskell
20:47:10 <andkore> no-n: pardon?
20:47:24 <no-n> idk... it's sort of becoming a dialect, right?
20:47:37 <silasm> oh no, you used the d-word
20:47:42 <silasm> maybe it should be a concern.
20:47:49 <no-n> :P
20:48:21 <silasm> personally I've vaguely started worrying about it, but I don't know enough about the real standard to know if my worries are legitimate or not.
20:48:26 <Iceland_jack> andkore: I think most people would welcome a real competitor to GHC but the situation with Haskell is quite different from other languages'
20:49:03 <andkore> Iceland_jack: care to elaborate?
20:50:32 <Iceland_jack> I think the emphasis on research changes the situation
21:11:00 <chrisdotcode> can anyone help me out quickly? I modified the source of a module on haddock, and I want to use that version of the library when compiling another program. how do I do that with ghc?
21:11:13 <chrisdotcode> (as opposed to using the version installed in ~/.cabal)
21:13:08 <pavonia> I think you can do that with cabal sandbox
21:13:13 <chrisdotcode> I was thinking that
21:13:23 <chrisdotcode> cabal sandbox init; cabal sandbox add-source $lib right?
21:13:46 <pavonia> Uh, I don't know how to use it, sorry
21:14:04 <chrisdotcode> okay, cool. I was going to try cabal sandbox, but I thought there was an easier way first
21:14:08 <chrisdotcode> I'll try it now, though.
21:15:46 * hackagebot hybrid-vectors 0.1.2 - Hybrid vectors e.g. Mixed Boxed/Unboxed vectors  http://hackage.haskell.org/package/hybrid-vectors-0.1.2 (EdwardKmett)
21:20:47 * hackagebot free 4.6.1 - Monads for free  http://hackage.haskell.org/package/free-4.6.1 (EdwardKmett)
21:25:47 * hackagebot push-notify 0.1.0.1 - A server-side library for sending push notifications.  http://hackage.haskell.org/package/push-notify-0.1.0.1 (MarcosPividori)
21:25:49 * hackagebot push-notify-ccs 0.1.0.1 - A server-side library for sending/receiving push notifications through CCS (Google Cloud Messaging).  http://hackage.haskell.org/package/push-notify-ccs-0.1.0.1 (MarcosPividori)
21:25:51 * hackagebot push-notify-general 0.1.0.1 - A general library for sending/receiving push notif. through dif. services.  http://hackage.haskell.org/package/push-notify-general-0.1.0.1 (MarcosPividori)
21:35:38 <mzero> is there some common pitfall with using the derived instance of Read with a data type that has a member that has a type with a custom instance of Read?
21:39:10 <carter> huh
21:39:11 <carter> no clue
21:40:29 <carter> Iceland_jack: 'cause we have a type system so we're ok with moving the langauge slightly :)
21:47:32 <no-n> @src (->) (<*>)
21:47:32 <lambdabot> (<*>) f g x = f x (g x)
21:49:21 <no-n> @pl (<*>) f g x = f x (g x)
21:49:21 <lambdabot> (line 1, column 14):
21:49:21 <lambdabot> unexpected " "
21:49:21 <lambdabot> expecting operator
21:50:30 <pyon> > let { foo = Left 1 :: Either Int Int } in (unsafeCoerce foo :: Either Int String)
21:50:32 <lambdabot>  Not in scope: `unsafeCoerce'
21:50:44 <jle`> @pl \f g x -> f x (g x)
21:50:44 <lambdabot> ap
21:51:09 <tac> pyon: are you a madman?
21:51:16 <pyon> tac: I am not.
21:51:18 <tac> trying to unsafeCoerce in a room full of people like that
21:51:35 <tac> You could accidentally turn someone into a PHP programmer!
21:51:52 <pyon> tac: Hehe. :-)
21:55:18 <SrPx> Okaay guys, NOBODY here is writing graphical applications with Haskell to asnwer my question? t_t
21:55:29 <jle`> :'(
21:56:03 <MrRacoon_> SrPx: what's your question?
21:57:30 <SrPx> MrRacoon_: I was asking if there was a way to make graphical applications (3d viewers, games, etc) in pure Haskell. I'm aware of the OpenGL bindings, but it is mostly a wrapper around the original API, so follows a very stateful/imperative style. I wonder if there is a lib that allows you to follow a functional style - then it converts it to opengl/cuda/whateverGPU under the hoods?
21:57:58 <no-n> @src Maybe (<*>)
21:57:58 <lambdabot> (<*>) = ap
21:58:04 <no-n> :t ap
21:58:05 <lambdabot> Monad m => m (a -> b) -> m a -> m b
21:58:12 <no-n> @src ap
21:58:12 <lambdabot> ap = liftM2 id
21:58:15 <jle`> SrPx: well there is threepenny-gui
21:58:36 <enthropy> "gloss" may be closer
21:58:58 <jle`> that too
21:59:04 <jle`> hm
21:59:06 <edwardk> SrPx: threepenny or just talking via websockets to the browser works well
21:59:18 <SrPx> jle`: hm I'll check this out, but I'm not interested in guids but general graphical apis (I want to port a shader I made in webgl - I'm wondering if I can do it in a more functional way)
21:59:26 <jle`> gloss might be nice then
21:59:45 <SrPx> edwardk: hm pardon? Talking via websockets to the browser?
22:00:09 <tavoe> what is this error: http://lpaste.net/101656 and what should I learn from it?
22:00:50 <edwardk> SrPx: i've mostly given up on portable guis in haskell, they always have some horrid build problem. but i can build web stuff anywhere, and canvas works on 85% of the browser market these days, webgl something like 45%
22:01:00 <jle`> SrPx: use the browser as your front-end for rendering, and sending messages to it from your backend to tell it what to render
22:01:17 <edwardk> SrPx: github.com/ekmett/arcade is starting to take that path
22:01:51 <SrPx> So I still have to code the shader in webgl? So no point in redoing it in Haskell, I guess, it is already done then. :(
22:02:23 <dmj`> tavoe: strange that a redundant do gives an error message
22:02:24 <jle`> tavoe: what are you trying to do?
22:02:24 <edwardk> if you are on chrome you can play around at http://ekmett.github.io/arcade/static/ wasd+space moves, 1-7 spawns, 0 clears, mouse grabs, q/e lifts lowers what you grab.
22:02:44 <edwardk> need to finish that thing one of these days
22:02:50 <dmj`> tavoe: L.filter (=='.') <$> param "postid"
22:03:32 <dmj`> tavor: maybe... html =<< L.filter (=='.') <$> param "postid"
22:03:55 <tavoe> what is <$>?
22:03:58 <dmj`> fmap
22:04:02 <tavoe> ghc claims not in scope
22:04:06 <dmj`> @src fmap
22:04:06 <lambdabot> Source not found. I feel much better now.
22:04:10 <edwardk> SrPx: but yeah that doesn't help you with functionally reimplementing the shader
22:04:17 <jle`> import Control.Applicative ((<$>))
22:04:21 <dmj`> import Control.Applicative
22:04:25 <SrPx> edwardk: hmm minified code, no idea how that works :C
22:04:30 <edwardk> SrPx: there is a 'shady' language that conal has lying around.
22:04:42 <SrPx> conal?
22:04:47 <edwardk> srpx: the code that is minimizd is just for require.js the rest of the site is normal
22:04:58 <jle`> you can think of it like applying a pure function to a monadic value
22:05:00 <edwardk> https://github.com/ekmett/arcade/tree/master/static
22:05:03 <jle`> which...it is
22:05:04 <jle`> heh
22:05:08 <MP2E> hey guys, I have a 2 Sets, one of Int and the other is a bunch of curried functions of type (Int -> Int). How do I just "combine" these? The curried functions in the second list need only be applied to the first list
22:05:16 <tavoe> That worked. W
22:05:19 <tavoe> hy did that work?
22:05:28 <MP2E> I tried Set.map ($) set1 set2 but that didn't work
22:05:36 <tavoe> is =<< a backwards >>=?
22:05:39 <jle`> MP2E: how do you want to combine them?
22:05:50 <startling> tavoe: yes
22:05:54 <startling> :t (>>=)
22:05:54 <jle`> like zipping them up?
22:05:54 <lambdabot> Monad m => m a -> (a -> m b) -> m b
22:05:58 <startling> :t (=<<)
22:05:59 <lambdabot> Monad m => (a -> m b) -> m a -> m b
22:06:09 <tavoe> :t (<$>)
22:06:10 <lambdabot> Functor f => (a -> b) -> f a -> f b
22:06:20 <edwardk> srpx: https://github.com/ekmett/arcade/blob/master/src/Arcade/Server.hs sets up the server, but it currently just stubs out what to do with the connection in this branch
22:06:20 <jle`> tavoe: you can imagine your tools of function composition as (.), (<$>), and (=<<)
22:06:33 <jle`> . composes pure and pure
22:06:40 <jle`> <$> composes pure and impure
22:06:43 <startling> tavoe: yeah, (=<<) looks a lot like fmap with a secondary "flattening" step
22:06:45 <jle`> =<< composes pure and pure
22:06:49 <jle`> er
22:06:51 <jle`> impure and impure
22:07:08 <edwardk> of course (.) = (<$>)
22:07:13 <edwardk> so that gets muddled ;)
22:07:13 <startling> ish.
22:07:17 <tavoe> and having a monad (like IO) attached == "impure"?
22:07:23 <jle`> html =<< filter (== '.') <$> param postid
22:07:34 <jle`> tavoe: yeah, it's a loose word for impure, it's used in the standard library a lot like that
22:07:34 <ski> jle` : perhaps you mean `($)' instead of `(.)' ?
22:07:39 <SrPx> edwardk: woa dats awesome
22:07:53 <fragamus> edwardk is there a fmap for V3
22:07:58 <jle`> ski: yeah, ($) would be better
22:08:01 <edwardk> fragamus: yes, fmap =)
22:08:02 <jle`> and more analogous
22:08:07 <jle`> :)
22:08:10 <fragamus> lol
22:08:14 <fragamus> sorry
22:08:21 <fragamus> ill try it
22:08:21 <MP2E> ah I see, I just misunderstood what I wrote :P
22:08:32 <MP2E> heh
22:08:52 <tavoe> how did (\c -> c = '.') become =='.'. Oh.
22:08:55 <tavoe> wait, I get it
22:08:57 <SrPx> edwardk: I still have no idea what I'm supposed to do but it is really cool
22:09:01 <MP2E> hmm it's great how ghc can point out huge holes in your logic before the program ever runs.
22:09:17 <jle`> :t (== '.')
22:09:18 <SrPx> edwardk: seems like you wrote a lot of javascript, though. I see it is in canvas
22:09:18 <lambdabot> Char -> Bool
22:09:34 <jle`> i'm working on my own websockets/js rendering library
22:09:39 <jle`> but i'm being held back by some issues with ghcjs :/
22:09:47 <edwardk> SrPx: yeah the server doesn't really do anything the client cares about yet
22:09:49 <dmj`> MP2E: your sets are of different types
22:10:07 <edwardk> SrPx: and canvas was to avoid webgl availability headaches
22:10:18 <mzero> so, here's a minimal (!) case: http://lpaste.net/101658
22:10:31 <mzero> I've got a type with Read defined via a ReadP parser
22:10:32 <SrPx> jle`: you're using ghcjs? I've managed to install (finally!) haste and fay and benchmark them. Got kinda good results, but almost 20x slower than my hand written js... wont do it for my needs for now :C how is ghcjs performing for you?
22:10:40 <edwardk> wanted to see if i could get a usable framerate out of canvas and mutation-heavy javascript
22:10:46 <SrPx> edwardk: yea you dont really need webgl there
22:10:56 <mzero> and then a simple type that uses it and has a derived Read.... which fails
22:11:07 <edwardk> it'd help a lot with the drop shadows, avoiding the z-sort, etc.
22:11:24 <jle`> SrPx: have not been working too much worht performance, been concentrating on developing abtractions :)
22:11:31 <jle`> if they end up being non-performant then oops :/
22:11:39 <edwardk> but the technology limitations give it a weird old-school meets new school charm ;)
22:11:54 <SrPx> :/
22:12:40 <jle`> tavoe: i revise my statement, you have a couple of tools for 'function application', ($) pure function pure value, (<$>) for pure function impure value, (=<<) for impure function impure value
22:13:15 <SrPx> Well OK so conclusion, no realtime games/graphics intensive apps for haskell yet, then?
22:13:36 <MP2E> in terms of graphics intensive games no
22:13:41 <MP2E> but there are realtime games written
22:13:45 <SrPx> (Other than using the OpenGL api but then I could just use C...)
22:13:48 <jle`> SrPx: have you looked at Frag?
22:13:51 <MP2E> ^
22:14:04 <dmj`> jle`: does Frag build?
22:14:06 <jle`> it's opengl though
22:14:10 <MP2E> how could write a graphics intensive game *without* opengl?
22:14:16 <MP2E> that doesn't make sense, then it would be CPU bound
22:14:49 <jle`> i don't see why you would want to discount a C library if you want to build a native app
22:15:07 <SrPx> I'll look at its source
22:15:17 <jle`> haskell is about abstractions
22:15:38 <jle`> hide the ugly implementation behind a beautiful abstraction and pretend the implementation doesn't exist
22:15:47 <jle`> expose a mathematical abstraction/interface
22:15:53 <jle`> use equational reasoning to deal with it
22:16:17 <ski> MP2E : to make any interesting `Set (Int -> Int)', you must have `Ord (Int -> Int)' ..
22:16:35 <ski> @type \sab sa -> S.unions [S.map ab sa | ab <- S.toList sab]  -- that said, ..
22:16:36 <lambdabot> (Ord a, Ord a1) => S.Set (a1 -> a) -> S.Set a1 -> S.Set a
22:18:03 <dmj`> has anyone encountered linker issues when building the network lib on haskell?
22:18:06 <dmj`> http://lpaste.net/101660
22:18:19 <dmj`> I would gittip anyone who knows the solution :P
22:19:08 <dmj`> on windows*** not on haskell
22:19:25 <kadoban> anyone have a good example i can look at on how to put in automated tests for a package/module? i'd like to put in both quickcheck and manualy unit tests, have it all run nicely and checkable by exit code (so i can have git automatically run it and refuse my commits if the tests fail)
22:19:48 <dmj`> kadoban: https://github.com/tfausak/haskeleton
22:20:50 <SrPx> jle`: exactly, that's why I thought we'd have something abstracting away shaders, opengl and gpu programming in general.
22:21:08 <SrPx> I guess the world needs something like that
22:21:09 <mzero> kadoban: use test-framework
22:21:22 <SrPx> jle`: ah and I just read the paper on Frag, thanks
22:21:47 <kadoban> mzero: dmj`: thanks!
22:22:46 <kadoban> jle`: thanks again for your monad-handholding the other day, that code i was working on is about a thousand times better than it was now :)
22:22:48 <dmj`> SrPx: like three.js?
22:23:00 <mzero> is there a way to dump the code for derived instances
22:23:01 <mzero> ?
22:23:29 <dmj`> try -ddump-deriv
22:23:36 <mzero> woot
22:23:44 <jle`> kadoban: congrats  :)
22:24:08 <SrPx> dmj`: nah. It is just a 3D rendering application. You can actually write your own shaders for it but if you want multiple pass rendering you'll have to hack the source
22:24:23 <SrPx> dmj`: <why are you guys suggesting js stuff when I'm here to run away from js? :C >
22:24:32 <jle`> we can't escape js
22:24:36 <dmj`> SrPx: there is no running
22:24:36 <SrPx> nooooo
22:24:41 <jle`> it's called "The javascript problem"
22:25:03 * ski idly wonders which class mzero wanted to dump derived instances for
22:25:11 <jle`> http://www.haskell.org/haskellwiki/The_JavaScript_Problem#The_problem
22:25:35 * mzero casually points at type Use in http://lpaste.net/101658
22:26:44 <jle`> you might be able to figure out the implementation from the Report spec
22:26:53 <jle`> but that is slightly more involved than a dump
22:27:04 <jle`> only slightly
22:27:19 <SrPx> I still fail to understand this, I have myself written a compiler for a fp language that is pretty much scheme except it becomes ridiculously fast javascript. How could compiling Haskell, which is pretty much what I got except typed, be so hard?
22:27:20 <mzero> you can't ... I tried - it isn't defined in a way that makes it clear how it uses classes with hand defined Read/Show instances
22:27:28 <jle`> http://www.haskell.org/onlinereport/derived.html
22:27:42 <jle`> SrPx: it's the runtime system
22:27:50 <jle`> especially GHC's
22:28:08 <SrPx> why is the runtime system necessary?
22:29:05 <jle`> think about doing anything
22:29:06 <jle`> :)
22:29:12 <jle`> thunks?
22:29:16 <jle`> concurrency?
22:29:17 <SrPx> For example, `foo a b = a + b` ... why can't we just compile this to (function(a,b){return a+b}) ?
22:29:24 <jle`> because that's not how it works in haskell
22:29:57 <jle`> (not even talking about currying and partial application)
22:30:03 <SrPx> when would this even fail?
22:30:05 <jle`> what about laziness?
22:30:52 <jle`> garbage collection semantics?
22:31:01 <SrPx> ah that's something else, I honestly still don't understand why laziness should be part of our way to think... I see it as an implementation detail
22:31:05 <SrPx> same for GC semantics
22:31:20 <jle`> how would you store an infinite list without laziness?
22:31:23 <SrPx> mayme I'm an idealist though, I understand how that is necessary for being practical
22:31:41 <MP2E> it isn't *necessary* but it is elegant
22:31:47 <MP2E> the ability to store infinite lists and such is very useful
22:31:52 <jle`> also it is heavily tied into the way haskell evaluation works
22:32:00 <jle`> for example, say take 5 $ [1..]
22:32:04 <jle`> @src take
22:32:04 <lambdabot> take n _      | n <= 0 =  []
22:32:04 <lambdabot> take _ []              =  []
22:32:04 <lambdabot> take n (x:xs)          =  x : take (n-1) xs
22:32:10 <jle`> it evalutes to
22:32:14 <jle`> 1 : take 4 [2..]
22:32:22 <SrPx> jle`: I don't know, maybe I'm for Idris approach to the subject...
22:32:23 <jle`> 1 : 2 : take 3 [3..]
22:32:51 <jle`> 1:2:3:4: take 2 [4..], etc
22:33:15 <jle`> you can't have haskell without it
22:33:21 <SrPx> yes yes I know, just...
22:33:40 <SrPx> what do you think about the way idris deal with it?
22:33:42 <dmj`> jle`: so we'd have to mimic the haskell RTS in order to have a valid Haskell to JS translation?
22:34:12 <jle`> dmj`: well...you'd have to follow the Report spec somehow
22:34:35 <SrPx> I hope you guys know that is never going to work, honestly...
22:34:37 <jle`> you need to have some sort of runtime system to be a practical implementation
22:34:48 <dmj`> jle`: which implies a ton of generated JS
22:35:13 <jle`> well, yeah...what would you expect?  compare a haskell hello world binary to a c hello world binary
22:35:22 <SrPx> Also no way that is going to be fast, JS is particularly really, really poor performant for fp style of programmin
22:35:25 <SrPx> programming*
22:35:42 <jle`> well, one solution is to only compile a subset of haskell
22:35:50 <jle`> and not actually compile haskell
22:36:02 <dmj`> jle`: like elm
22:36:04 <jle`> another solution is to make a new language inspired by haskell
22:36:05 <SrPx> yea, but then you lost a huge amount of existing code
22:36:07 <jle`> like elm, purescript
22:36:13 <dmj`> jle`: doesn't fay actually mimic lazy eval in js?
22:36:16 <jle`> SrPx: well, the existing code relies on haskell's runtime semantics
22:36:28 <jle`> so you can't have it and drop the runtime no matter what
22:36:58 <jle`> dmj`: fay has lazy semantics yeah
22:37:16 <jle`> but it's considerably more lightweight than a full haskell comipler, like ghcjs and haste etc.
22:37:17 <SrPx> I think we should honestly just make a language that is simple enough so we can translate it to anything else in the future - be it a new target language, a new computer architecture... that is, we should settle with a language that specs only semantics, not evaluation strategies and so
22:37:44 <jle`> haskell's laziness is semantic
22:37:45 <SrPx> I guess nobody cares about making future proof stuff nowadays, but things change but legacy code dont
22:38:12 <Iceland_jack> SrPx: You're basically talking about intermediate languages, like LLVM's bitcode?
22:38:24 <dmj`> jle`: If we can closue compile generated Fay code to where it's tolerable and allow sane debugging I might consider using it. I just dislike large code-gen in general, anywhere
22:38:55 <dmj`> SrPx: binary is pretty portable
22:39:22 <dmj`> :P
22:39:46 <SrPx> Iceland_jack: I just wish we had a solid language spec that was likely not to need to change regardless of drastic changes in computer architectures or so. IMO it is something like Idris, not even numbers are on the language definition, it is all libs. But I know too few of it to understand it.
22:39:49 <jle`> binary probably isn't portable
22:40:25 <SrPx> dmj`: then lisp machines become the future... or graph reducers... and now your assembly binary becomes garbage
22:40:51 <SrPx> and with that all code made is useless now
22:41:18 <Iceland_jack> Sure, wake me up when lisp machines take over :)
22:42:07 <MP2E> hahaha
22:44:32 <m09> jmcarthur: thanks again for the stable memo link, it worked fine after some strictness tweaking (-O).
22:46:01 <SrPx> Iceland_jack: can I wake you up when parallel machines take over? Because you might have not noticed but GPU are pretty much outperforming CPUs in almost anything. The current bottleneck for the majority of the applications is the software side of the thing
22:46:24 <mzero> AHA!
22:46:29 <mzero> Figured it out!
22:46:45 <mzero> readsPrec is assumed to consume leading whitespace!
22:46:52 <mzero> how friggin' bogus!
22:47:16 <SrPx> mzero: good catch (:
22:47:33 <mzero> This only set me back three hours!
22:47:43 <jle`> SrPx: there's that balance between abstraction and getting low-level access, of course
22:47:48 <mzero> :-/
22:48:30 <jle`> some things that are easy to compile to in some architectures will be difficult in others
22:49:23 <Iceland_jack> SrPx: GPUs outperform CPUs in things GPUs are good at :)
22:51:04 <SrPx> jle`: I don't believe that :/ I think that when you are high level enough to express what your program do the compiler should be able to find any representation that fits best its target architecture. And I do think the "sufficiently smart compiler myth" is a myth itself
22:51:37 <SrPx> but how we went at this again, I was asking about graphics stuff on haskell lol
22:51:59 <SrPx> oh god I hate webgl
22:52:14 <Iceland_jack> SrPx: Look at the massive flora of operating systems, programming languages, programs etc., a “universal X” is generally a pipe dream
22:52:34 <jle`> idealism is idealism though
22:52:48 <jle`> but if you have any good leads then feel free to pursue them, or join people who are
22:52:50 <SrPx> Iceland_jack: I can't see a thing that couldn't be easily coded in a simple language
22:53:06 <Iceland_jack> SrPx: That statement has no meaning to me
22:53:21 <SrPx> jle`: I don't know anyone, do you?
22:53:27 <ion> I added one more program. http://codegolf.stackexchange.com/a/24289/1621
22:53:50 <jle`> SrPx: i know one now :)
22:54:01 <SrPx> ):
22:56:05 <SrPx> people dream with a world full of peace. people want good economics, money, success, status. I dream with a world where I can write games in a pure functional style. because that would be sick
22:56:20 <jle`> i'm writing an rts in frp :/
22:56:25 <jle`> we'll see how the performance works out
22:56:44 <SrPx> jle`: what libs you are using?
22:56:49 <jle`> for graphics?
22:56:54 <jle`> unknown so far
22:56:57 <jle`> that's an implementation detail :P
22:57:04 <jle`> i'm using netwire for the game logic
22:57:25 <SrPx> jle`: but thats the most important thing to think in advance lol
22:57:31 <jle`> really?
22:57:41 <jle`> it always feels like the least significant thing to me :/
22:57:53 <jle`> i just build abstractions
22:57:55 <SrPx> well it is the only thing that could have a huge performance problem I guess...?
22:57:56 <jle`> and worry about optimizing later
22:58:29 <jle`> yeah, but game logic in haskell is more of what i am p-o-c'ing
22:58:36 <jle`> it is of more interest to me
22:59:25 <SrPx> but how do you create your meshes etc? if you just code everything, ie, a physics engine and the renderer in pure haskell using lists you'll have to redo almost all of it
23:00:01 <SrPx> jle`: game logic in haskell is really fit though
23:00:26 <jle`> you'd be surprised about popular opinion!
23:00:30 <jle`> or maybe you wouldn't
23:01:32 <SrPx> jle`: pardon?
23:01:36 <jle`> but until we have a lot of concrete examples of beautiful game logic in haskell, public opinion will probably see imperative oop as the only reasonable choice for game coding
23:01:47 <SrPx> jle`: ahh I see
23:03:10 <SrPx> jle`: I agree with that, IMO everything is awesome in pure Haskell. The only possible source of ugliness in Haskell code is having to give up to an imperative style in so many important cases
23:04:06 <jle`> some problems are best approached imperatively
23:04:12 <jle`> but i haven't run into such cases yet
23:04:19 <dmj`> didn't John Carmack write some haskell
23:04:23 <jle`> (i'm being facetious)
23:04:30 <dmj`> where's his code at
23:04:38 <jle`> he's too busy working on oculus rift
23:04:41 <dmj`> http://functionaltalks.org/2013/08/26/john-carmack-thoughts-on-haskell/
23:05:31 <SrPx> jle`: imo nothing is best approached imperatively
23:06:01 <jle`> how could something like that even be meaningfully justified?
23:06:36 <jle`> what about baking a cake?
23:07:11 <jle`> you can't say that there is not a single problem that is best approached from an imperative mindset
23:07:42 <dmj`> you can't bake a cake outside of the cake monad
23:07:46 <SrPx> jle`: a list of instructions that you foldl with f, where f is how to perform a cooking step? that is how I see it. I don't consider sequential=imperative
23:07:50 <Iceland_jack> jle`: Pure bakers crack their eggs and create new ones
23:08:43 <jle`> SrPx: imperative programming is approaching computation as a graph of statements that change a program state
23:09:29 <jle`> although there are varying definitions, yea
23:09:32 <SrPx> jle`: so (foldl (+) 0 [1,2,3,4,5]) is imperative programming...?
23:10:55 <AaronFriel> Question for library implementation: I have a remote stream (FFI) that will asynchronously emit values - there are many, many "Stream" data types in Hackage. What should I implement and why?
23:11:46 <jle`> SrPx: you could interpret it as imperative, but it's far enough from the line that i wouldn't call it too ambiguous
23:12:21 <AaronFriel> "Chan" is messy (consumer should only read, producer should only write), "TQueue" suffers the same problem. A custom "Stream" type doesn't interoperate with anything. Pipes and conduits are high level, and restrictive for consumers. "io-streams" looks nice, except it means I add a boat-load of dependencies to my project that I don't want.
23:12:21 <jle`> but i wouldn't call it an imperative approach to summing
23:13:02 <AaronFriel> Data.Vector.Stream.Fusion has a stream data type that only requires the vector package, *and* it is set up for fusion, but do any libraries actually consume that?
23:19:14 <SrPx> jle`: ;/
23:20:30 <jle`> ;\
23:20:42 <AaronFriel> Thoughts? Anyone?
23:20:55 <AaronFriel> I'll leave my PC on - message me if you have an idea of what streaming library makes the most sense.
23:23:22 <gentleben> AaronFriel I feel your pain
23:23:56 <gentleben> Internally we us conduit
23:24:02 <gentleben> *use
23:24:18 <gentleben> I have never used pipes
23:24:35 <AaronFriel> Mmh. I would like to write a library that can be consumed by conduit and pipes users relatively painlessly, at least.
23:24:40 <gentleben> I also don't think there is a good way to quantify which is used more
23:24:43 <AaronFriel> It looks like io-streams might be the best candidate for that
23:25:09 <gentleben> I wouldn't jump to that conclusion
23:25:17 <AaronFriel> I really don't understand why there are so many stream types - it looks like IOStreams is okay, but Vector's Stream has list fusion :/
23:25:24 <AaronFriel> stream fusion, rather
23:25:36 <gentleben> I might suggest (and this is subprime) making a base version of your library
23:25:41 <jle`> if you do some sort of io-stream-like/handle-based interface, it is easy to wrap it in both pipes and conduits as an interface
23:25:56 <gentleben> and then making seperate conduit/pipes/io-steam packages for it
23:26:00 <AaronFriel> I mean, I should clarify - I understand why there are so many high level libraries. There are a lot of local maxima to optimize for
23:26:57 <AaronFriel> But I don't understand why there is no standard super-basic "Stream m a = m (Maybe (a, Stream m a))"
23:27:06 <AaronFriel> with a dash of some fusion and other stuff
23:27:15 <gentleben> its the same problem people face with binary vs cereal
23:28:01 <gentleben> and there isn't a good
23:28:06 <gentleben> way to do it today
23:32:10 <jle`> AaronFriel: hm
23:32:19 <jle`> interesting observation
23:32:32 <jle`> and then that library would write the pipes/conduit interfaces for you?
23:32:38 <jle`> just give it a Stream m a?
23:33:11 <tavoe> Very similar question to last time. I clearly don't understand something. http://lpaste.net/101661
23:33:18 <AaronFriel> I suppose so, I mean, I just want something that says "Hey take values from me in some monad, so I can know that you're not cheating"
23:33:42 <dmj`> html =<< curly <$> param "postids"
23:33:44 <AaronFriel> Oleg writes about streams over lazy IO all the time, so it surprises me to see very little widespread adoption of types that protect from it
23:33:46 <dmj`> tavoe: ^
23:34:01 <dmj`> tavoe: what is the type of ($) compare to the type of fmap?
23:34:06 <dmj`> compared*
23:34:31 <jle`> AaronFriel: although you might want to expand it to Auto m a b = a -> m (Maybe b, Auto m a b)
23:34:36 <jle`> in case your stream takes input
23:34:47 <AaronFriel> It doesn't! Ever!
23:34:53 <AaronFriel> So I want to keep it simple
23:34:56 <jle`> AaronFriel: i mean, for a generalized library
23:34:59 <AaronFriel> Ah
23:35:06 <jle`> that way Stream m a b = Auto m () b
23:35:09 <AaronFriel> Well I just want to make my library have streaming data that people can use
23:35:28 <AaronFriel> It's a database library - an interface to HyperDex
23:35:44 <AaronFriel> and when you send the database a query, you get an asynchronous stream of results back
23:36:01 <AaronFriel> and I'm just having no luck finding a definitive answer for representing that to an end user
23:36:10 <jle`> just giving tips in case you want to one day design such a general library :)
23:37:06 <AaronFriel> Then I would have to get into arguments on reddit with gabriel and snoyman
23:37:07 <jle`> i think a safe road would be to just provide handle-like interface ( get :: handle -> IO a ), and then provide wrappers for pipes and conduit etc.
23:37:13 <AaronFriel> and that just seems like it would make me sad
23:37:23 <jle`> that is the approach i have taken with my js websockets library
23:37:29 <AaronFriel> hmm
23:37:37 <jle`> writing the pipes/conduits wrappers would be simple
23:37:41 <jle`> if you had the handle interface
23:38:59 <jle`> hm, you might also want to look at the haskell websockets library too
23:39:03 <tavoe> Should it be intuitive that map and $ have something in common?
23:39:07 <jle`> they might have had a similar problem with you
23:39:37 <jle`> tavoe: $ aplies a pure function to a pure value; <$> applies a pure function to an impure value (fsov of impure, value)
23:39:37 <AaronFriel> looks like they used io-streams
23:39:43 <jle`> fsvo
23:40:12 <shachaf> tavoe: (.) "maps over" the result of a function
23:41:16 <shachaf> length :: [a] -> Int; ((.) show) length :: [a] -> String
23:41:48 <shachaf> Or I guess you could write length :: ([a] ->) Int; ((.) show) length :: ([a] ->) String
23:42:12 <shachaf> And for xs :: [Int], (map show) xs :: [String]
23:43:34 <dmj`> tavoe: It might not be intuitive now, but will become intuitive, have you gone through LYAH?
23:43:53 <tavoe> I've read it 3 1/2 times over the last year or so
23:44:36 <tavoe> I never wrote enough code to go along with it, so now I'm trying to use haskell for a project I actualyl want to get done
23:44:36 <AaronFriel> jle`: looks like I will be using io-streams
23:44:47 <jle`> ($) :: (a -> b) -> a -> b
23:44:58 <jle`> (<$>) :: (a -> b) -> m a -> m b
23:45:08 <AaronFriel> jle`: I wish there were fewer package dependencies - I don't like that iostreams places a dependency on zlib-bindings, time, process, blaze-builder, and so on, but I don't know if there is a better option
23:45:17 <jle`> (=<<) :: (a -> m b) -> m a -> m b
23:45:25 <AaronFriel> jle`: I will sleep on it though and consider in the morn
23:45:43 <jle`> AaronFriel: you can just write your interface from scratch without any dependencies
23:46:05 <tavoe> I think what I need to remember in the short term is that when I have monad-y errors, I don't need a new version of my functions, just new connectors between my functions
23:46:10 <AaronFriel> jle`: Maybe, but then I don't get any of the benefit of having it work other people's libraries
23:46:33 <AaronFriel> jle`: maybe that isn't actually a use case I should optimize for though, I don't know
23:46:35 <dmj`> tavoe: can you translate from do syntax to bind syntax and write reader, writer, state out
23:46:36 <jle`> tavoe: bingo :)
23:46:39 <jle`> tavoe: http://www.haskellforall.com/2012/09/the-functor-design-pattern.html
23:46:57 <jle`> or its prereq http://www.haskellforall.com/2012/08/the-category-design-pattern.html
23:47:35 <shiona> somehow I read that "the category of design patterns"
23:47:47 <jle`> the key is to pick a 'common denominator' of where you live
23:47:56 <jle`> and then find ways to promote everything else to that common denominator
23:48:03 <jle`> shiona: :P
23:48:41 <jle`> shiona: in this case your common denominator is the Action monad, so find ways to promote your pure stuff, your other monadic stuff, etc into the Action
23:48:47 <jle`> er sorry, tavoe
23:49:01 <jle`> and haskell is especially good at those sorts of promitions
23:49:01 <gentleben> AaronFriel your best bet is to make bindings to other libraries a seperate library
23:49:03 <jle`> promotions
23:49:23 <gentleben> otherwise you end up with the union of dependencies
