00:10:24 * hackagebot scientific 0.2.0.2 - Arbitrary-precision floating-point numbers represented using scientific notation  http://hackage.haskell.org/package/scientific-0.2.0.2 (BryanOSullivan)
00:10:24 * hackagebot Win32 2.3.0.2 - A binding to part of the Win32 library  http://hackage.haskell.org/package/Win32-2.3.0.2 (BryanOSullivan)
00:46:25 <ski> Ayadew : unfortunately, mostly yes
02:30:36 * hackagebot llvm-pkg-config 0.0 - Generate Pkg-Config configuration file for LLVM  http://hackage.haskell.org/package/llvm-pkg-config-0.0 (HenningThielemann)
02:56:04 <zlatan> hi, I'm trying to learn haskell as my first language (okay, I did some basic coding in python, c and some intermediate in html but nothing special)
02:56:22 <zlatan> so I was wondering what suggestions do you have - how to learn, what to read/watch etc
02:57:21 <zlatan> I was thinking on reading Learn You Haskell for Great Good by Lipovaca and listening to some spooky music while reading/coding :D
02:57:35 <zlatan> any feedback would be great
02:58:08 <mniip> chiptune makes great background for writing code
02:58:11 <johnw> enjoy
02:58:15 <mniip> For me at least
03:01:09 <mniip> zlatan, learn you a haskell is a great book
03:02:08 <zlatan> mniip, I read first 30 or so pages and is very enjoyable for now (the pics are great and the code is easy to understand/well explained)
03:02:10 <mniip> But some chapters need to be read twice to understand
03:02:27 <zlatan> mniip, okay - but it is a good for start?
03:03:03 <mniip> Though that's a side effect of haskell natively operating with complex things from category teories and stuff
03:03:09 <zlatan> mniip, and chiptune you were referring to this http://haskelllive.com/?
03:04:02 <zlatan> mniip, oh, yes, I hear a lot about category theories when trying to find resources for haskell - do you have some suggestions for it?
03:04:03 <audax333> Can someone recommend a library like "readability.js" which extracts the main content from an html page?
03:04:27 <merijn> audax333: You just want to scrape HTML pages?
03:04:45 <mr-> zlatan: if you don't know category theory already, ignore it
03:04:54 <audax333> Yup, it should just work most of the time. For example extracting the content of a blog post and ignoring the menu
03:04:57 <merijn> audax333: I found the combination of http-conduit (for downloading pages) and html-conduit (for parsing/processing them) to work fairly well
03:05:22 <zlatan> mr-, to ignore and read on or?
03:05:41 * hackagebot hruby 0.2.6 - Embed Ruby in your Haskell program.  http://hackage.haskell.org/package/hruby-0.2.6 (SimonMarechal)
03:05:59 <mniip> zlatan, no, by chiptune I mean chiptune
03:06:47 <audax333> merijn: I am looking for a heuristic approach, not a manual one. I am building/porting a bookmark aggreagator with a full text search and I'd like to extract the "meaningfull" text from a website
03:06:56 <mniip> zlatan, if you learn haskell, you will understand some aspects of category theory
03:07:21 <mniip> If you know category theory, you will understand some aspects of haskell
03:07:48 <mniip> But generally it isn't a requirement for learning haskell
03:07:53 <zlatan> mniip, I am looking at wikipedia article and I think we learned that in mathematics on faculty but I don't think we call it same in our native language
03:07:59 <zlatan> mniip, good
03:08:11 <merijn> audax333: Ah, then I dunno what exists
03:08:40 <audax333> Maybe porting readability.js to haskell would be a good excercise for me...
03:08:44 <zlatan> mniip, so book by Lipovaca is great...is there any special way to take (to supplement reading with videos and/or some special coding sites)?
03:12:03 <mniip> zlatan, install ghc
03:12:25 <zlatan> mniip, I use debian and already have all that installed :)
03:13:26 <zlatan> mniip, for the matter of fact I use xmonad on regular basis but didn't ever bother to change anything in it (it works great!) :)
03:14:32 <zlatan> mniip, I also see people praise Real World Haskell book - is that also a must read one?
03:16:59 <zlatan> mniip, I also downloaded videos Functional Programming Fundamentals by Erik Meijer
03:17:12 <zlatan> and Advanced Functional Programming by Ralf Lammel
03:17:23 <zlatan> hope they are good to watch
03:21:10 <lizzin> http://lpaste.net/3107284855835066368
03:21:19 <lizzin> What am I doing wrong here?
03:21:53 <lizzin> Why doesn't the insert example show the tree containing 7 as its value?
03:22:09 <quicksilver> lizzin: when you insert in the left tree or the right tree (recursing calls in your 'insert Node' case)
03:22:16 <quicksilver> lizzin: you are throwing away the top-node
03:22:24 <lizzin> hrmm
03:22:45 <quicksilver> lizzin: you probably meant | v < v' = Node v' (insert v lf) rt
03:22:45 <lizzin> oh!
03:22:47 <quicksilver> for example
03:23:12 <audax333> Apparently yesod with postgres-fay is broken atm. Welp. I probably won't need it anyway >.<
03:23:21 <lizzin> quicksilver: Thanks, I can't believe I missed that
03:25:11 <lizzin> quicksilver: Also, why does this throw an error: data (Ord a) => BinTree a = Empty | Node a (BinTree a) (BinTree a)?
03:25:49 <lizzin> Illegal datatype context (use -XDatatypeContexts): Ord a =>
03:26:32 <quicksilver> you can't put contexts on data types
03:26:43 <quicksilver> it used to be permitted but utterly useless
03:26:48 <quicksilver> so they made it illegal instead
03:27:03 <lizzin> oh, i must be reading an old book
03:27:50 <lizzin> so instead the constraints are placed on the functinos that operate on the type?
03:28:45 <quicksilver> yes
03:29:58 <lizzin> ok
03:30:06 <spacekitteh> has anyone got numeric-prelude working with ghc 7.8 yet?
03:31:16 <merijn> lizzin: When DatatypeContexts was still allowed you *still* had to put constraints on the functions
03:31:27 <merijn> lizzin: Hence why it's considered useless and not allowed
03:33:43 <lizzin> that seems funky
03:34:07 <lizzin> seems like you should be able to set it on the data line and then the compiler checks the functions
03:36:47 <johnw> well, putting it on the data declaration constrains the constructor
03:36:53 <johnw> but that doesn't provide the constraint to the function
03:37:22 <johnw> otherwise, you'd somehow have to end up passing around invisible constraint dictionaries everywhere that the type was involved
03:38:25 <quicksilver> which is how GADTs work
03:39:18 <b0bbi10> hi, why don't these separate functions work for different patterns? http://ideone.com/PGeIXu
03:39:31 <b0bbi10> do I have to specify the signature/ type first?
03:40:11 <johnw> the latter "let" overwrote the former
03:40:21 <mniip> b0bbi10, second let statement overwrites first
03:40:22 <johnw> try this: let lucky 7 = ...; lucky x = ...
03:41:15 <b0bbi10> ah ok, thanks
03:41:37 <lizzin> i guess it works that way in scala because the method is already tied to the object/class
03:42:49 <cariveri> hi haskellers.
03:42:58 <mniip> b0bbi10, ghci is more like a do-statement than a file input
03:43:34 <mniip> you can't say 'x=5' but you can 'let x=5'. do-semantics are implied
03:43:38 <johnw> cariveri: hello!
03:43:42 <cariveri> can I have ghc compile with all dependencies, so that the target machine doesnt have to install packaged to make it run?
03:43:51 <b0bbi10> mniip: good to know :)
03:43:59 <johnw> cariveri: you mean, static linking?
03:44:00 <mniip> cariveri, like static compilation?
03:44:10 <mniip> Er, linking, yes
03:44:55 <cariveri> Im not sure. but one target machine was missing libgtk11 something. does static mean shipped with all necessary parts?
03:45:44 <mniip> Static means all library code is copied into the executable
03:46:01 <cariveri> then yes. thats what I want.
03:46:01 <mniip> And you don't need any libraries whrn running
03:48:48 <audax333> Can someone give me a hint how to configure yesod to connect to my postgres DB with a unix socket instead of a port?
03:50:26 <merijn> lizzin: Well, it makes sense when you realise how typeclasses are usually implemented
03:51:14 <cariveri> johnw: so how do I link statically ?
03:51:37 <Flonk> Is there a package around for working with the windows active directory?
03:52:13 <merijn> lizzin: i.e. in GHC the class "Ord a" gets translated into a record containing the functions of Ord for 'a' so the "foo :: Ord a => a -> Bool" compiles to take an explicit dictionary like "Ord a -> a -> Bool", if the "Ord a" is implicit, this means it has to be stored in the datatype (bloating the size and making it more complex)
03:53:45 <cariveri> mniip: and how about pictures that are called from a relative path and such stuff. can those also be put into the binary?
03:55:02 <mniip> Idk, ask someone else
03:55:59 <danilo2> Hello! :) I've got probably very simple question, but could somebody tell me why I'm getting error "Type synonym `X' should have 2 arguments, but has been given none" when trying to create instance of  Category?
03:56:00 <danilo2> http://lpaste.net/101012
03:56:02 <johnw> cariveri: i don't remember
03:58:21 <cariveri> ok thanks guys. johnw mniip
03:58:49 <johnw> you can't do partial application with type synonyms
03:59:16 <johnw> it works with newtype and data, but not "type"
04:00:05 <danilo2> johnw: hmm, so this shoul be newtype? I was looking into (http://www.haskellforall.com/2012/01/haskell-for-mainstream-programmers_28.html) and there it is declared as type and the author is claiming, he is making instance of category for it
04:01:21 <Hafydd> I believe you can if you use -XLiberalTypeSynonyms.
04:01:35 <johnw> if not, it may be that his type synonym there is just demonstrative
04:02:10 <merijn> Hafydd: No, because that'd mean type synonyms become type level lambdas, which grossly breaks the type system, hence why you can declare instances for partially applied synonyms
04:02:27 <johnw> since none of the real lens library use that type anymore :)
04:03:23 <danilo2> johnw, merijn, Hafydd: Ok, thank you very much :)
04:06:13 <Hafydd> Oh, that's right. You can partially apply type synonyms, but only as arguments to other type synonyms, and if the result has no remaining partial applications.
04:26:59 <suppi> Hi
04:27:06 <suppi> I've got a small problem...
04:27:26 <suppi> When I compile this small snippet:
04:27:30 <suppi> import System.IO
04:27:30 <suppi> main = getChar >>= return . (:[]) >>= putStrLn
04:28:02 <suppi> using The Glorious Glasgow Haskell Compilation System, version 7.4.1
04:28:31 <suppi> and run the program, I have to press enter after entering a char
04:28:46 <suppi> but when i :load it with ghci I don't have to wait
04:29:00 <suppi> *to press enter
04:29:14 <Kneiva> which operating system do you have?
04:29:25 <Iceland_jack> :t getChar >>= putStrLn . (:[])
04:29:26 <lambdabot> IO ()
04:29:30 <Iceland_jack> You can use that instead suppi
04:29:31 <suppi> I'm using Elementry OS (ubuntu LTS)
04:29:42 <suppi> thanks Iceland_jack
04:29:50 <Iceland_jack> or
04:29:50 <Iceland_jack> :t getChar >>= putStrLn . return
04:29:51 <lambdabot> IO ()
04:30:03 <Iceland_jack> Since
04:30:03 <Iceland_jack> > return 5 :: [Int]
04:30:03 <Iceland_jack> for the list monad
04:30:04 <lambdabot>  [5]
04:30:54 <suppi> very nice :)
04:30:57 <Iceland_jack> suppi: Are you familiar with buffering?
04:31:12 <suppi> not really
04:31:31 <Iceland_jack> Okay so you may want to read up on line buffering which is the default for stdin
04:32:02 <suppi> is this a bug, the difference between ghc and ghci?
04:32:25 <suppi> which behavior is the current one?
04:33:00 <Yuu-chan_> suppi: try to set 'hSetBuffering stdin NoBuffering' to guarantee a single-char input
04:33:58 <Iceland_jack> suppi: So you compiled it, ran the executable and you had to press enter after entering the character for the output to be displayed but when you ran the same code in GHCi it displayed immediately?
04:34:14 <suppi> yes.
04:34:27 <Yuu-chan_> suppi: that's not a bug, but an implementation difference. Probably the ghci console disables buffering by itself.
04:34:34 <Iceland_jack> Not a bug
04:34:48 <suppi> alright, I'll try your suggestion Yuu-chan_
04:35:00 <Iceland_jack> suppi: It can also be a matter of your terminal settings
04:35:05 <Iceland_jack> check stty
04:35:30 <suppi> this works now
04:35:32 <suppi> many thanks!
04:35:43 <Iceland_jack> :)
04:35:46 <suppi> :)
04:35:54 <Yuu-chan_> When I developed tiny console games, I had to disable both stdin and stdout buffering (in Windows)
04:36:55 <suppi> another question while I'm here, i want to reprint the console screen as they do it programs like vi, less and so on
04:37:03 <suppi> in*
04:37:13 <suppi> without clearing the screen
04:37:37 <suppi> how can I achieve that in haskell?
04:37:44 <b0bbi10> hi, can you recommend some other beginner book for Haskell than LYAH? I don't get along with it somehow....
04:38:31 <Iceland_jack> b0bbi10: LYAH is the best really.. you can look at http://www.cse.chalmers.se/edu/year/2013/course/TDA452/FPLectures/Vid/ if you don't mind recordings (introduction to functional programming at Chalmers)
04:38:47 <abdulsattar> Beginning Haskell: A project based approach, released recently, got a lot of good reviews
04:38:57 <mariomystic_> I have my test data in a file say foo.txt and I wrote some unit tests using that. Now how to package foo.txt in cabal. Also what is the ideal way of referring to it in the tests.
04:39:07 <Yuu-chan_> suppi: you can use libraries like ansi-terminal
04:39:07 <b0bbi10> abdulsattar: can you recommend it, too?
04:39:24 <abdulsattar> I didn't get to read it.
04:39:25 <b0bbi10> Iceland_jack: thanks
04:39:26 <suppi> Yuu-chan_, alright, I'll check it out. thanks again :)
04:39:46 <abdulsattar> There was a thread on /r/haskell when that book released, a lot of people liked it
04:39:49 <Yuu-chan_> suppi: people here proposed another one, but I can't remember its name :)
04:40:31 <Yuu-chan_> suppi: vty
04:40:39 <suppi> one solution is enough, thanks :)
04:41:03 <suppi> two is even better
04:41:05 <suppi> thanks :)
04:41:06 <suppi> are
04:50:55 <grohne> are leksah questions on topic here?
04:52:35 <ski> you could try in here
04:52:45 <ski> apparently there's also a #leksah channel
04:52:50 <ski> i dunno how active it is
04:55:52 <grohne> I am pretty new to leksah, trying it in a cabalized project with a cabal sandbox. When I try to start ghci (inside leksah), I am greeted with "cabal: Can't parse --info output of GHC" but that's hardly an actionable issue.
04:56:06 <grohne> much less reproducible outside leksah
04:57:19 <grohne> I hope that this is a bit more informative than "it doesn't work", but I'm likely missing important aspects.
04:57:24 <merijn> grohne: tbh, I think the community of leksah users is quite small, so I'm not sure how well it keeps with other developments
04:58:11 <grohne> the package I am working on was developed against ghc6
04:58:33 <merijn> ah
04:58:34 <grohne> so advancements of the ecosystem shouldn't be a problem.
04:58:43 <merijn> ghc6 is really, REALLY ancient
04:58:58 <Yuu-chan_> Btw, today is exactly two years from the last Leksah release. Sadly it seems to have died :(
04:59:02 <grohne> yes, it took me considerable amount of time to make it work with ghc7 at all
04:59:21 <merijn> grohne: Which cabal are you using?
04:59:32 <merijn> grohne: Oh, I guess 1.18 for sandboxes?
04:59:45 <grohne> 1.18.1.3
04:59:52 <grohne> installed via cabal. ;-)
05:00:10 <merijn> grohne: And which ghc are you using?
05:00:23 <grohne> 7.4.2 (as shipped by some OpenSuSE release)
05:00:31 <merijn> hmmm
05:00:38 <grohne> ok. let me step back:
05:00:53 <grohne> the reason why I was trying leksah was that maybe it would help me understand the codebase at hand
05:01:11 <grohne> as in, maybe I could ask for the type of an expression or use quick cross references
05:01:23 <grohne> what other options are there to facilitate this task?
05:01:25 <merijn> grohne: What editor do you normally use?
05:01:29 <grohne> vim
05:01:32 <grohne> and emacs for agda
05:01:47 <merijn> grohne: Then you may want to look into ghc-mod and hdevtools + associated vim/emacs plugins
05:01:53 <grohne> but my emacs knowlegde is basically knowledge in agda2-mode. ;-)
05:02:33 <merijn> grohne: I use vim + syntastic and vim hdevtools to get automatic syntax checking and things like querying types/definitions from within vim
05:03:00 <grohne> I shall have a look at that. Installing ghc-mod and hdevtools was the easy part.
05:03:04 <merijn> grohne: See for example git+ssh://git@github.com/bitc/vim-hdevtools.git
05:03:18 <merijn> and git+ssh://git@github.com/scrooloose/syntastic.git
05:04:30 <merijn> grohne: There's a ":HdevtoolsInfo" command in vim-hdevtools that will use hdevtools to query the definition of the symbol under your cursor, showing things like types and source
05:07:00 <jkarni> anyone know how to link GLUT (the haskell library) against freeglut on os x?
05:07:27 <jkarni> there don't seem to be any flags for that in the cabal file
05:09:26 <benjamin_> hi guys
05:09:57 <benjamin_> i'm an intermediate haskeller and i need some advice, can anyone help me?
05:10:05 <benjamin_> i'm trying to test a monadic action
05:10:32 <benjamin_> but HUnit assertions are IO
05:11:09 <benjamin_> so i need to put the IO action inside the monad i'm testing right? or vice versa
05:11:48 <benjamin_> is there a 'standard' solution for this? i've read something about monad transformers
05:13:14 <Yuu-chan_> benjamin_: IO is a monadic action too
05:13:18 <jkarni> that is the standard solution
05:13:43 <benjamin_> Yes, I understand that IO is a monad
05:13:52 <benjamin_> I'm trying to compose IO code with pure code
05:14:37 <benjamin_> I'm basically trying to write unit tests for a 'fake database', which conforms to the same interface as the real database, but sits in a State monad instead of IO
05:14:55 <Yuu-chan_> benjamin_: if you have a function that computes IO Smth, you can bind it with an assertion (which is IO too) with >>=.
05:14:56 <jkarni> benjamin_: Use StateT instead of State
05:15:28 <jkarni> benjamin_: Most common monads come with a monad transformer version
05:15:53 <benjamin_> @jkarni so I should use a StateT s IO instead of a State s?
05:15:53 <lambdabot> Unknown command, try @list
05:16:01 <benjamin_> jkarni: so I should use a StateT s IO instead of a State s?
05:16:01 <ion> benjamin: You can do pure tests in HUnit, too. Your State stuff doesn’t need to use IO at all.
05:16:19 <benjamin_> ion: I need to run the same tests against the real db and the fake db
05:16:45 <benjamin_> jkarni: what would the type signature of my test look like then?
05:16:53 <benjamin_> i guess it'd feature MonadIO somewhere?
05:17:29 <jkarni> benjamin_: Do you have the current code?
05:17:33 <jkarni> @paste
05:17:33 <lambdabot> Haskell pastebin: http://lpaste.net/
05:17:43 <benjamin_> Sure
05:22:44 <benjamin_> http://lpaste.net/101013
05:23:28 <benjamin_> Hope that code makes sense
05:26:28 <jkarni> yeah, so it should be as simple as changing the State to StateT s IO
05:26:38 <jkarni> and then using liftIO for the actions that should be in IO
05:27:17 <jkarni> e.g., loaded <- liftIO $ loadEvents fakeEventStore info, I think
05:27:43 <jkarni> though I don't know the signature of most of these things, so I can't be too sure
05:30:43 <grohne> Is it a bug if Graphics.Gloss.display kills ghci with "<interactive>: interrupted"?
05:31:19 <jkarni> benjamin_: btw, you don't have to use StateT s IO, but could leave it at Monad m => StateT s m in the pure side of things, and just instantiate it to IO when you need to (so the separation is clearer)
05:32:34 <jkarni> grohne: is this with -fno-ghci-sandbox? I remember some mention of using that flag when using gloss with ghci
05:32:48 <jkarni> grohne: Though it might have been relevant to a different problem
05:33:10 <grohne> jkarni: the faq says that workaround is not needed for ghc >= 7.4
05:33:32 <grohne> jkarni: but with -fno-ghci-sandbox the ghci is also killed. this time without any message
05:34:07 <jkarni> grohne: hmm
05:35:20 <jkarni> grohne: My bad then; not sure that I have any other ideas
05:36:07 <Fuuzetsu> what's the latest one has to confirm their attendance at ZuriHack? I'd like to go but I have no idea whether I'll be able to until much closer to the date.
05:36:49 <grohne> jkarni: well, I'll probably have to resort to a compile&test cycle then
05:58:32 <bernalex> what's the difference between "Eq a => a -> b" and "forall a. Eq a => a -> b"?
05:59:23 <merijn> bernalex: Nothing
05:59:26 <quchen> bernalex: forall is implicit in Haskell types
05:59:33 <quchen> (Where applicable)
05:59:47 <merijn> bernalex: In standard haskell there is an implicit leftmost forall for all type variables
06:00:04 <bernalex> right, I saw some old slides that used it.
06:00:06 <merijn> bernalex: Actually, the letter is always wrong
06:00:07 <quchen> bernalex: You can enable explicit foralls with -XExplicitForAll
06:00:21 <merijn> bernalex: It should be "forall a b. Eq a => a -> b"
06:00:26 <bernalex> is this haskell 98?
06:00:36 <quchen> merijn: The ∀b. was implicit ;-)
06:00:57 <merijn> bernalex: In haskell 98 they are implicitly there, but you can't specify them. So it depends what you mean by "is this haskell 98?"
06:01:05 <benjamin_> Thanks for the advice guys, that's very helpful
06:01:11 <benjamin_> (sorry, i was away from my desk)
06:01:40 <adimit> quick question: if I want to quickCheck-test some invariants of a function f in some module M, but don't want to export f from M, what are my options? As far as I know, cabal test wants a separate test suite. I'm using hspec currently, to set up specs for all my modules.
06:01:49 <bernalex> merijn: I meant if they were implicitly  in haskell 98 :-)
06:02:02 <merijn> bernalex: FWIW, "State s" is literally "StateT s Identity" so you can use "Monad m => StateT s m" identical to "State s" by just adding a type signature :)
06:02:12 <merijn> bernalex: Then yes, it is haskell 98
06:02:29 <benjamin_> merijn: thanks, should help with refactoring incrementally ;)
06:02:53 <benjamin_> adimit: why are you trying to test internal functions?
06:03:25 <adimit> benjamin_: because there's easy invariants I can define on them, and I want to make sure they hold.
06:03:51 <benjamin_> don't test implementation details
06:04:10 <adimit> basically, I like to test the little stuff first, because if only the topmost function fails in the end, I'm gonna have a harder time debugging it.
06:04:21 <benjamin_> the invariants might be useful when you're first writing your function, but when you've finished you should throw your tests away and make it internal
06:04:36 <adimit> hm.
06:04:44 <benjamin_> you should avoid coupling your tests to your implementation details
06:04:51 <benjamin_> because it makes it harder to change them later
06:04:51 <merijn> benjamin_: I disagree, why wouldn't you test internal functions?
06:05:10 <merijn> benjamin_: That's only relevant if you're likely to change it often
06:05:15 <benjamin_> merijn: if it's internal, then by definition its existence does not affect the externally observable behaviour of the module
06:05:15 <adimit> benjamin_: I can always throw away the tests later, can't I? I mean if I change the implementation details.
06:05:36 <merijn> benjamin_: Testing isn't (necessarily) about external observable behaviour
06:05:40 <merijn> benjamin_: It's about correctness
06:06:08 <benjamin_> adimit: You can, but imagine coming back in a year's time and not being sure what the tests do
06:06:20 <merijn> Then you have a bigger problem
06:06:36 <merijn> i.e. that you didn't sufficiently document what you are doing
06:06:40 <benjamin_> how do you decide which tests you should throw away and which tests are definitions of valuable behaviour?
06:07:05 <benjamin_> Trust me, i've worked on code-bases with too much testing and it is not fun
06:07:06 <adimit> benjamin_: That's why I like hspec. Documentation is pretty cool with it; you always have these little blurbs that say what the test does exactly, and they are even printed to stdout when the test fails.
06:07:38 <benjamin_> adimit: yes. I'm totally on board with BDD ;) but the point of BDD is that you should *only* test what the code does, not how it does it
06:07:40 <adimit> benjamin_: I'm learning the whole testing-game right now. This is the first project I've been using lots of tests on.
06:07:50 <benjamin_> ie, if it's not part of the public API it shouldn't be tested
06:08:06 <benjamin_> it's a massive topic and we're all still learning about it! ;)
06:08:29 <benjamin_> But testing public behaviours and not private implementation details is a good habit to get into early
06:09:04 <benjamin_> http://signalvnoise.com/posts/3159-testing-like-the-tsa is a good introductory blog post
06:09:28 <adimit> I guess. I wanted to preempt a bad occasion where a particular quickCheck test ran 20 times or so, and failed on the 21st… If I had had tests for the smaller parts of that part of the API, I might've caught the bug sooner.
06:09:46 <benjamin_> merijn: what is correctness about, if not externally observable behaviour?
06:09:55 <adimit> (problem with quickCheck is that it may not generate the one thing that'll fail.)
06:10:18 <benjamin_> adimit: i agree, that sort of test is very useful *while you're writing the function*
06:10:44 <benjamin_> if you're unsure of the correct implementation, write tests for it. But then throw them away
06:10:48 <adimit> benjamin_: so you're saying: export it while testing, then de-export it, and scrap the tests? (I think i'd rather just comment them out.)
06:11:24 <benjamin_> adimit: exactly. i wouldn't comment the tests - they'll still be in the Git history, they're not gone forever
06:11:35 <benjamin_> and generally it's pretty easy to re-write tests of this sort when you need them
06:12:02 <benjamin_> the tests you should keep, ie for regression purposes, are the ones that test the externally observable behaviour of the code, ie the public API
06:12:12 <audax333> The #yesod channel is not very helpful, it is rather quiet. :/
06:12:15 <adimit> benjamin_: drilling down a git-history can be obnoxious.
06:12:24 <benjamin_> the whole point of making something private is that you're saying "I want to be free to change this at any time"
06:12:31 <adimit> audax333: my experience is that they may answer within a couple of days…
06:12:47 <audax333> This makes for a rather frustrating learning experience
06:13:05 <audax333> Yesod is the web framework of choice, isn't it?
06:13:26 <benjamin_> if your tests know too much about your internals, that makes it harder to change. for small code bases perhaps it's not such an issue but it's a good habit to get into
06:13:48 <audax333> The great yesod-book doesn't even mention testing
06:13:51 <jkarni> audax333: Snap and happstack are also pretty popular
06:14:21 <bxc> if you don't have clearly defined interfaces between different bits of your internals, then you can get into a mess
06:14:36 <benjamin_> bxc: that is not a concern of the tests
06:14:52 <benjamin_> testing doesn't absolve you from the need to write good code
06:14:55 <bxc> benjamin_: right
06:14:56 <adimit> bxc: if you don't pay attention to the design of your API, you're gonna have a bad time.
06:15:15 <bxc> benjamin_: but i you have designed a clear interface between two pieces of your internals, you then should be testing that interface
06:15:20 <benjamin_> i disagree
06:15:34 <benjamin_> well, actually it depends
06:15:37 <bxc> ha
06:15:40 * bxc WINS!
06:15:53 <adimit> An alternative could be like what ByteString and Text do: have some Bla.Foo.Internal module.
06:15:54 <benjamin_> how clearly drawn is your architectural boundary?
06:15:55 <audax333> jkarni: I'll look into them, thanks. Yesods seems to have quite a bit of magic init and I am a haskell novice who doesn't understand magic yet. ;)
06:16:15 <bxc> benjamin_: right. at some point "internals" becomes fuzzy
06:16:27 <adimit> audax333: yesod will be *hard* to get into without a good grasp of Haskell's type system.
06:16:33 <adimit> I suggest you ask questions on SO, also.
06:16:45 <jkarni> audax333: Agreed - I tend to prefer Happstack from that perspective
06:16:52 <benjamin_> bxc: if it's something you want *users of your software* to be able to swap out like a plugin system, then i think you should probably test that interface
06:17:03 <benjamin_> bxc: but then it's not really an internal interface after all
06:17:13 <bxc> right, efinitely not in that case
06:17:20 <audax333> I finally managed to get at least some tests running with yesod, but now I can't use the hspec function for asserting because they expect a different type, etc...
06:17:32 <bxc> but say i've build an big integer module and am then only using it within my own code elsewhere
06:17:40 <bxc> but relying on the fact that the integers module works
06:17:43 <audax333> I'll look into happstack :)
06:17:55 <bxc> as part of my certainty that the product as a whole works
06:18:02 <bxc> even though its not exposed
06:18:09 <bxc> i'd want to test it.
06:18:12 <benjamin_> that's a good question
06:18:20 <adimit> bxc: that's basically the situation I'm in. It's not a big integer module, but a graph representation of my internal data structures.
06:19:01 <benjamin_> i'm not going to pretend i know the answers!
06:19:05 <adimit> I could implement it as something that's not exactly a graph. Or is implicitly a graph (A graph is not an algebraic data structure, which makes things more complicated.) But right now it's a graph, and I'd like to know all the little lookup-functions work.
06:19:39 <benjamin_> adimit: "i could implement it as something that's not exactly a graph" - ie you want to be free to refactor your implementation
06:19:47 <benjamin_> So you shouldn't have tests for it
06:19:59 <bxc> but would you then have to change the "all the lookup functions" to different signatures?
06:20:19 <adimit> benjamin_: I am highly unlikely to refactor it, but I'm also ready to refactor the tests, too.
06:20:23 <benjamin_> you'd have to change all the tests as well
06:20:24 <adimit> bxc: some yes, some no.
06:20:35 <bxc> but i disagree with the general principle of only testing publicly exposed behviour
06:20:51 <benjamin_> bxc: we'll have to agree to differ then
06:20:54 * bxc nods
06:21:05 <merijn> adimit: If you stumbled on any interesting things about functional graph processing, I'd be interested to hear it :)
06:21:22 <bxc> i've caught sufficient bugs from fiddlign with my own code that way that I like my way
06:21:25 <merijn> adimit: I found some interesting things, but I wanna avoid missing something important :)
06:21:34 <benjamin_> my rule of thumb is to test as little as I can, which is still a lot of testing ;) This view is echoed in the blog post i linked above
06:21:36 <adimit> merijn: not yet, though I've read a couple of papers. I'm using fgl (and being a bit disappointed, I thought that fgl seemed rather crude.)
06:21:44 <benjamin_> and Kent Beck seems to agree in this stack overflow answer http://stackoverflow.com/questions/153234/how-deep-are-your-unit-tests
06:21:53 <jkarni> adimit: Crude in what way?
06:22:16 <benjamin_> bxc: Practicing TDD on a small personal project is very different from using it on a big business project
06:22:23 <adimit> jkarni: edges are triples, nodes are tuples… just not so good. I'd like for ledge to be an ADT with a functor instance, for example.
06:22:30 <adimit> *LEdge
06:22:56 <bxc> benjamin_: yes. I've saved much more money having tests on big projects than small projects.
06:23:02 <adimit> It could use a little more polish. Also, you're directly exposed to the implementation details (i.e. you know all the node indices.)
06:23:05 <jkarni> adimit: Can't you just keep a separate map with additional structure?
06:23:10 <merijn> benjamin_: I think TDD is a waste of time, you should test what's reasonable given your cost-benefit intuition as a programmer, don't care whether that's internal or external
06:23:39 <bxc> merijn: as long as you have the right intuition there, i agree with that.
06:23:45 <jkarni> adimit: Data.Graph doesn't even have node and edge labels, I think
06:24:13 <jkarni> adimit: the assumption being, I assume, that you'll have IntMaps for those
06:24:32 <DMcGill> Steelball when can you play?
06:25:00 <adimit> jkarni: I'm afraid a map won't cut it. In fact, it's two interconnected graphs, one describing a type structure, and another run-time representations of data structures with said types. The functions that make sure that the run-time representation is sound (in terms of types) are *internal*, but I'd like to test them still :-)
06:25:05 <bxc> merijn: but I don't believe many (most?) programmers that I've worked with have the intuitions about where things will break
06:25:12 <DMcGill> oops wrong channel sorry
06:25:26 <merijn> bxc: That's because most programmers suck, sure. But that doesn't mean rigid dogma is any better
06:25:53 <bxc> oh god no rigid dogma
06:26:01 <benjamin_> i'm getting back to work. Thanks for the discussion, it's been interesting ;)
06:26:19 * bxc gets enough of that watching agile programmers
06:26:29 <adimit> bxc: to be fair, it's difficult. When you're having the feeling that it'll break somewhere, you're going to scrutinize the code so it doesn't break. And then it'll break elsewhere, while you weren't paying attention.
06:27:08 <jkarni> adimit: I'm a little unclear on what you have in mind instead - surely the labels themselves can be functors in fgl?
06:27:49 <LnL> I have a question about foldl', I don't understand in which case foldl is preferred, or when it would behave differently
06:27:51 <adimit> jkarni: nope. they can't. They're of type (,,). Which, if you treat it as (,) (,) *has* a functor instance, but it's awkward.
06:29:04 <jkarni> adimit: ah, so you want LEdge a to be a functor, rather than Functor a => LEdge a?
06:29:06 <vanila> LnL, it's about strictness, basically if foldl is giving a stack overflow try foldl'
06:29:16 <adimit> jkarni: yes :-)
06:29:26 <adimit> and, arguably, it makes sense for it to be a functor.
06:29:38 <LnL> vanilla: I understand that, my question is why does foldl even exist?
06:29:56 <adimit> LnL: in cases you need laziness.
06:29:56 <jkarni> adimit: Why? I'm curious, since it sounds like you have cool plans for your graphs
06:30:36 <vanila> the are equal as functions
06:30:42 <adimit> jkarni: oh, no fancy reason. Basically I have a ledge and want to apply a function to its label. So from NotYetLookedUpLabelString to LookedUpLabelWithDataInIt.
06:30:56 <vanila> they just operate differently
06:31:00 <adimit> LnL: you need laziness if you fold over infinite or very large lists.
06:31:00 <skypers_> hi
06:31:13 <skypers_> I’m looking for a way to traverse a Vector in a Monad
06:31:16 <skypers_> or Applicative
06:31:22 <skypers_> I don’t really know Traversable
06:31:32 <skypers_> but the idea is that I’d like to do something like fmap
06:31:34 <skypers_> but in a monad
06:31:44 <skypers_> huh
06:31:48 <skypers_> nevermind
06:31:50 <jkarni> adimit: Have you looked at the Monadic fgl graphs? I haven't so I don't know if they're relevant, but from the sound of it they should be
06:31:51 <skypers_> it’s just mapM_
06:32:15 <adimit> jkarni: I could do it with decomposition: let (n,n',l) = bla in (n,n',f l), but that's just. You know. Not *elegant* enough.
06:32:18 <skypers_> Foldable.mapM_ might make it through
06:32:33 <adimit> jkarni: no, I haven't yet. Though I might, thanks for the pointer.
06:33:00 <LnL> admit: Hmm, I was thinking you could only foldr over an infinite list
06:33:11 <adimit> skypers_: if you're in a monad anyway, just use monadic mapM, or mapM_.
06:33:25 <skypers_> adimit: I don’t care about the result
06:33:29 <skypers_> so mapM_
06:33:43 <adimit> skypers_: effects it is then. :-)
06:33:53 <skypers_> :)
06:34:11 <skypers_> hm
06:34:14 <adimit> okies, gotta get back to work myself.
06:34:18 <skypers_> why isn’t mapM in Foldable?
06:35:18 <skypers_> oh
06:35:21 <skypers_> Data.Vector.mapM
06:35:29 <skypers_> it’s there for Vector as well
06:35:30 <skypers_> curious
06:35:40 <skypers_> I wonder why it’s not in Foldable
06:35:56 <skypers_> foldable admits that you fold with an accumulator
06:36:28 <skypers_> and Traversable has mapM
06:36:30 <skypers_> but no mapM_
06:36:34 <skypers_> I’m confused
06:38:03 <LnL> admit: Could you give an example?
06:40:17 <fizbin> Anyone here who understands the use of the MonadError and MonadState classes when combined?
06:40:53 <skypers_> yes?
06:41:06 <skypers_> I do that
06:41:29 <skypers_> I often have signatures like
06:41:48 <skypers_> foo :: (MonadIO m, MyMonadState m, MyMonadError m) => a -> m ()
06:41:53 <skypers_> it’s not uncommon to me
06:44:45 <staffehn> Hello, could someone help me out what data structure to use to represent something like 3D-Arrays that could be possibly efficiently concatenated (stacked in different dimensions) and efficiently modified?
06:45:10 <fizbin> skypers: Okay. I'm working up a paste.
06:45:33 <fizbin> This is confusing enough that I'm willing to leak some proprietary stuff at this point, because w.t.f.
06:49:54 <fizbin> Okay, take a look at http://lpaste.net/3218181791886082048
06:51:07 * hackagebot full-text-search 0.2.1.0 - In-memory full text search engine  http://hackage.haskell.org/package/full-text-search-0.2.1.0 (DuncanCoutts)
06:51:09 * hackagebot csound-expression-dynamic 0.0.2 - dynamic core for csound-expression library  http://hackage.haskell.org/package/csound-expression-dynamic-0.0.2 (AntonKholomiov)
06:51:11 * hackagebot csound-expression-typed 0.0.2 - typed core for the library csound-expression  http://hackage.haskell.org/package/csound-expression-typed-0.0.2 (AntonKholomiov)
06:51:34 <fizbin> I'm mixing up how to stack MonadState on top of MonadError - I want MonadError for the return value, and the MonadState usage is purely internal to that function.
06:51:56 <audax333> I think I'll try Scotty instead of yesod/happstack/snap. Scotty looks easy :D
06:52:26 <fizbin> The error messages the compiler throws at me aren't at all helpful - it says that I need all sorts of additional instance declarations, which tells me I've gotten something confused.
06:55:46 <jkarni> audax333: Yeah, forgot to mention that one
06:55:57 <zomg> audax333: Scotty is pretty simple in comparison to those yeah :)
06:56:08 * hackagebot csound-expression 3.1.1 - library to make electronic music  http://hackage.haskell.org/package/csound-expression-3.1.1 (AntonKholomiov)
06:56:10 * hackagebot csound-catalog 0.1.1 - a gallery of Csound instruments.  http://hackage.haskell.org/package/csound-catalog-0.1.1 (AntonKholomiov)
07:06:07 <kuribas> @hoogle Num a => Int -> a
07:06:08 <lambdabot> Data.Set elemAt :: Int -> Set a -> a
07:06:08 <lambdabot> Prelude (!!) :: [a] -> Int -> a
07:06:08 <lambdabot> Data.List (!!) :: [a] -> Int -> a
07:06:10 * hackagebot pipes-errors 0.2 - Integration between pipes and errors  http://hackage.haskell.org/package/pipes-errors-0.2 (jdnavarro)
07:06:28 <kuribas> Is there a fromIntegral for Int?
07:06:48 <kuribas> fromIntegral gives me a lot of warnings "defaulting to Integer..."
07:07:11 <kuribas> Because I use (fromIntegral . round) to round doubles.
07:07:57 <`^_^v> fromIntegral is the fromIntegral for Ints
07:08:14 <fikusz> does someone have experience with netwire?
07:09:18 <fikusz> I'm looking for a way to build complex wires by composing a number of simpler ones
07:09:49 <fikusz> and I would like to have access to intermediate values
07:10:22 <fikusz> i.e. the results of the simpler wires
07:10:31 <fikusz> and also the result of the large / complex one
07:11:12 <fikusz> the problem is: I don't know how to do this without doing the calculations multiple times
07:11:36 <fikusz> if I just step the large wire, I don't have access to the values of the small ones
07:11:37 <jkarni> fikusz: I haven't used net wire, but I believe it has as arrow interface, no?
07:12:01 <fikusz> jkarni: yes
07:12:51 <jkarni> fikusz: So can't you do intermediate <- s -< source, and then use intermediate in multiple places?
07:13:02 <kuribas> Is it possible to convert a float to Num?
07:13:09 <jkarni> fikusz: (Using the Arrows extension)
07:13:52 <fikusz> jkarni: give me a sec
07:14:38 <prophile> (>>> (id &&& f)) will give you (intermediate, intermediate after f) I think
07:14:46 <`^_^v> float already has a num instance
07:14:48 <prophile> :t (>>> (id &&& f))
07:14:49 <lambdabot> (Show a1, FromExpr c') => (a -> a1) -> a -> (a1, c')
07:14:57 <fizbin> skypers: http://lpaste.net/101017 is the error handling pattern I'
07:15:00 <prophile> :t \f -> (>>> (id &&& f))
07:15:01 <lambdabot> (a1 -> c') -> (a -> a1) -> a -> (a1, c')
07:15:12 <prophile> I think that's the prelude id, but you get the picture ^^
07:15:17 <fizbin> The error handling pattern I'm trying to get a handle on.
07:15:54 <fizbin> I can't figure out what to do with the error message, and I don't know whether I have all the types right, or if the error shown is getting in the way.
07:16:15 <fikusz> prophile: I'm not that familiar with arrow syntax, I'll check on this. thanks
07:17:28 <jkarni> fikusz: Also look into the Arrow extension - for Arrowized FRP, it's usually a lot clearer
07:19:34 <fikusz> jkarni: thanks, will do
07:20:05 <b0bbi10> hi, why can I make a type declaration for a function before declaring a function in a script but not in interactive mode?
07:21:17 <kuribas> b0bbi10: Because it's not in scope, while in a script haskell reads all declarations and types.
07:22:24 <b0bbi10> kuribas: ah ok, scope issue :/
07:23:25 <kuribas> b0bbi10: you can do (let f :: Int -> Int; f a = a+2)
07:24:37 <kuribas> b0bbi10: ghci works somewhat like inside a do block.
07:25:14 <b0bbi10> kuribas: <interactive>:7:32: parse error on input `)'
07:25:42 <kuribas> Without the parens...
07:27:14 <b0bbi10> kuribas: ok, thanks
07:28:57 <fizbin> Seriously, anyone understand how to layer MonadState on MonadError? I can't figure out what http://lpaste.net/101017 is trying to tell me.
07:29:59 <b0bbi10> it seems I can't declare a type for a function after the function has benn declared. is it similar to the fact that I can't change a variable after defining it?
07:30:22 <supki> :t gets
07:30:23 <lambdabot> MonadState s m => (s -> a) -> m a
07:30:45 <supki> :t get
07:30:46 <lambdabot> MonadState s m => m s
07:30:48 <fizbin> Oh! that is an easy fix. Just a sec...
07:31:15 <fizbin> Okay, let me go update the error message...
07:31:57 <mm_freak> hi there
07:32:10 <haasn> > let f x = x+1; f :: Int -> Int in f 3 -- b0bbi10
07:32:11 <lambdabot>  4
07:32:19 <supki> fizbin: next problem is that you use x as a number
07:32:31 <supki> fizbin: while it's actually a tuple
07:32:37 <haasn> mm_freak: oh hey. this your first visit?
07:32:44 <mm_freak> haasn: totally ;)
07:32:52 <haasn> back from the realm of the IRC-dead, that is
07:33:13 <mm_freak> haasn: oh, no, i just have a question about emacs' haskell-mode
07:33:35 <fizbin> Huh. Okay, so both errors were actually simple ones.
07:33:50 <mm_freak> after my last git pull haskell-mode fails to turn on indent-mode for new buffers…  does anyone know why that might be?
07:33:54 <fizbin> But the error message seemed to be about something else entirely.
07:34:43 <mm_freak> haasn: i'm making a lot of progress with my FRP research by not hanging out here…  in fact i believe i have solved savegames for free =)
07:35:20 <fizbin> Also, it took entirely too long to realize I wanted "execStateT", not "execState"
07:36:29 <haasn> mm_freak: intriguing :)
07:40:10 <New2Haskell> Hello guys im playing with haskell variables to learn the language however there is one thing im breaking my head about
07:40:42 <New2Haskell> Its a school assigntment the objective is to analyse a string, filter decimal numbers en give the length of the longest number
07:40:47 <New2Haskell> i now havethis:
07:41:05 <New2Haskell> longestDecimal xs = length(maximum (filter (all isDigit) (groupBy (\x y -> isDigit x == isDigit y) xs)))
07:41:30 <New2Haskell> which gives the correct values on strings: hoi123doei1234dag12345
07:41:44 <ij> Why don't you use $ instead of those parens?
07:41:44 <New2Haskell> however it breaks on hoi123doei233455sds22222222222222222
07:41:47 <b0bbi10> :S I am New2Haskell too and that looks weird
07:42:05 <New2Haskell> saying longest var is 5 big which clearly isnt
07:42:06 <ion> ij: Excess use of $ isn’t much better.
07:42:17 <ion> new2haskell: You’re computing the maximum of strings, not lengths.
07:42:23 <haasn> New2Haskell: “maximum” on lists uses lexicographic ordering
07:42:24 <New2Haskell> ohh
07:42:28 <ij> ion, For length i's totally appropriate.
07:42:34 <New2Haskell> but it worked on other strings though
07:42:52 <haasn> New2Haskell: coincidence
07:42:57 <New2Haskell> hold on im going to turn off join messages for a bit
07:43:08 <haasn> > "12345" > "1234"
07:43:09 <lambdabot>  True
07:43:13 <haasn> > "12345" > "1321"
07:43:15 <lambdabot>  False
07:43:16 * ij freezes.
07:45:18 <haasn> New2Haskell: have a look at maximumBy
07:46:14 <New2Haskell> kk thx
07:48:49 <b0bbi10> do Types and Typeclasses have some kind of a 'circular' relation? Typeclasses have Types as Members. Types belong to Typeclasses. is it correct to say that Types come first since they can exist on their own? the existence of Typeclasses make no sense without Types, right?
07:49:21 <haasn> b0bbi10: types don't belong to type classes
07:49:22 <sipa> b0bbi10: looks right to me
07:49:42 <haasn> the existence of typeclasses makes no sense without types
07:49:54 <haasn> the existence of types without typeclasses makes perfect sense. See: every language in existence other than haskell
07:50:05 <sipa> well, "belong" is a big word, but there is an m-to-n relationnbetween types and type classes
07:50:31 <b0bbi10> ok, thanks
07:50:49 <prophile> typeclasses are in some ways just sugar for passing their "methods" around with values of their types
07:50:59 <prophile> and in fact I think they're even implemented that way in GHC
07:51:02 <haasn> prophile: quite magical sugar, then
07:51:09 <haasn> prophile: insofar desugaring rules are highly context sensitive
07:51:13 <quicksilver> a typeclass is a set of types
07:51:16 * hackagebot gang-of-threads 2.0.0 - Non-deterministic parallelism with bags  http://hackage.haskell.org/package/gang-of-threads-2.0.0 (bholst)
07:51:16 <prophile> veritable high fructose corn syrup
07:51:17 <quicksilver> that's what "class" means
07:51:27 <prophile> semantic sugar rather than syntactic sugar
07:51:36 <quicksilver> class is just a synonym for set or kind (or type, indeed)
07:51:42 <New2Haskell> okay I do maximum on this list in particular: ["123","5555","2222222222"] and it gives 5555
07:51:47 <New2Haskell> how is that logical??
07:51:59 <quicksilver> New2Haskell: dictionary order, New2Haskell, those are strings.
07:51:59 <haasn> New2Haskell: '5' is greater than '1' and '2'
07:52:17 <quicksilver> > maximum [123,5555,22222222]
07:52:18 <lambdabot>  22222222
07:52:25 <quicksilver> different for numbers
07:52:25 <New2Haskell> ohh
07:52:39 <New2Haskell> So if I want to get the length of the longest number
07:52:44 <New2Haskell> I have to convert them first to ints??
07:52:59 <quicksilver> there are many ways but converting them first to Integers might be the simplest
07:53:06 <haasn> disagree
07:53:12 <haasn> maximumBy (comparing length) -- simplest
07:53:14 <prophile> :t maximumBy (compare `on` length)
07:53:15 <lambdabot> [[a]] -> [a]
07:53:36 <New2Haskell> maximumBy ["123","5555","2222222222"]
07:53:49 <New2Haskell> would give 10??
07:54:01 <haasn> no, that's a type error
07:54:47 <haasn> (oh, you actually want the length of the longest number, not the longest number itself. then yes, maximum . map length should be even simpler, as quicksilver suggested)
07:55:25 <New2Haskell> Alright ill try and look into that
07:56:30 <adimit> merijn: you said earlier you were interested in functional graphy stuff — I unfortunately have only questions: I want to write a monadic EDSL-interface to constructing graphs. Something like do { n <- newLNode label; n' <- newLNode label'; newLEdge n n' edgelabel } simple enough. Do you know of any research into something like that?
07:57:10 <adimit> It seems a little cumbersome, yet reasonably effective. Better than exposing the user to LEdges and LNodes.
07:58:43 <haasn> adimit: should be relatively simple to do with something like a State monad
07:59:37 <adimit> haasn: yes, of course. I was wondering if the interface itself isn't just a little too… dunno. unwieldy. How much sense does it make to do it that way? Are there better alternatives to constructing, basically, static compile-time graphs?
08:00:06 <adimit> ideally, I would like there to be a possibility to do this stuff in a repl. But I'm taking it step by step.
08:00:21 <haasn> adimit: a smart constructor that works off lists and ensures the invariants (that edges only connect nodes) should pretty much result in the same thing
08:00:23 <haasn> ah
08:02:32 <haasn> adimit: beware monad then, as it isn't really static nor is it compile-time
08:02:55 <haasn> maybe you'd be interested in Arrow? I wonder how well that could work out
08:03:02 <haasn> time to sleep
08:03:19 <adimit> I was wondering something along the lines of Arrow, too. But I don't think it'd be better suited for what I need.
08:08:28 <Twey> adimit: If you want to do it at compile-time, you could use Template Haskell to compile your the action into a list literal or something, maybe?
08:09:12 <adimit> Twey: maybe. But then I'd have to learn Template Haskell :-P
08:09:16 <adimit> I've avoided that so far.
08:09:21 <Twey> adimit: Another bonus!
08:09:54 <adimit> Also, it feels weird to make an EDSL that relys on TH. The compile time error messages for the users will be *even* worse.
08:10:14 <jkarni> adimit: Arrows are pretty well-suited for graphs (unsurprisingly)
08:10:43 <Twey> adimit: Well, the EDSL would just be a normal EDSL.  The errors would be the same, I'd imagine.  You'd just use TH to force evaluation at compile-time.
08:10:51 <jkarni> adimit: I was just playing around with a visual Arrow notation editor - pretty easy to parse the graph into arrow notation, and probably pretty easy to go the other way
08:11:52 <adimit> jkarni: yes, going down the Arrow route seems an interesting proposition. I'm just not very firm with Arrows. I only used them for HXT — once upon a time.
08:12:19 <binroot> What's a good out of the box map reduce implementation in Haskell?
08:12:38 <adimit> binroot: map and foldr?
08:12:40 <prophile> :t foldMap
08:12:40 <lambdabot> (Foldable t, Monoid m) => (a -> m) -> t a -> m
08:12:43 <prophile> ^
08:12:48 <jkarni> adimit: I'd go as far as saying Arrows *are* a graph DSL
08:12:50 <binroot> no, I mean Google's mapreduce
08:13:22 <binroot> with threads in parallel
08:13:40 <prophile> my understanding of google's mapreduce is that it's for scaling across many many machines
08:13:44 <adimit> jkarni: interesting thought! … do you have examples, or just, you know. Pointers I could start with. Else I'm just going to go read Control.Arrow's docs and go from there.
08:13:55 <prophile> so perhaps you could look at cloud haskell
08:14:07 <jkarni> http://www.haskell.org/arrows/
08:14:07 <Eduard_Munteanu> Is there any support in Cabal for installing possibly unsafe packages, using Safe Haskell to infer safety?
08:14:09 <prophile> http://www.well-typed.com/blog/73
08:14:14 <binroot> thanks! I'll take a look. You can also scale across one computer's cores
08:16:02 <Twey> prophile: It's just what it sounds like — you do parallel map on parts of your problem, then fold them together into your final answer
08:16:09 <dcoutts> Eduard_Munteanu: cabal doesn't really do anything special with safe haskell
08:16:16 <prophile> Twey: yes, it is
08:16:22 <prophile> hence my initial answer
08:16:32 <prophile> but I suspect that a cloud haskell link is closer to want binroot was actually asking about :)
08:16:37 <Twey> In theory you can do it between  machines, CPU cores, GPU cores, &c.
08:16:43 <Twey> Possibly
08:17:01 <fizbin> If I'm in a MonadError world, is there a simple way to say "if this condition is false, throw an error, otherwise continue" without nesting all the statements after that inside the "if" ?
08:17:45 <fizbin> I guess something like this might work: if (badCond) then throwError (strMsg "whatever") else (return ())
08:18:06 <prophile> fizbin: unless condition $ throwError blah
08:18:08 <fizbin> And then statements after that in the do block wouldn't need nesting.
08:18:10 <adimit> fizbin: MonadError m => Bool -> m () ?
08:18:21 <Eduard_Munteanu> dcoutts: I see... are there other ways to ensure building and installing a package is "safe"? (perhaps not automatically as a cabal option, but another way)
08:18:29 <fizbin> @src unless
08:18:29 <lambdabot> unless p s = if p then return () else s
08:18:51 <lieven_> @src when
08:18:52 <lambdabot> when p s = if p then s else return ()
08:18:53 <fizbin> prophile: And indeed, it is almost as I suspected.
08:19:01 <Eduard_Munteanu> dcoutts: I'm asking because I see Hackage displaying a Safe Haskell status, how do they do it?
08:19:24 <dcoutts> Eduard_Munteanu: you mean in the haddock docs? Haddock does that
08:19:58 <Eduard_Munteanu> Yeah... hm.
08:20:53 <dcoutts> Eduard_Munteanu: but I think you can just use the normal ghc safe haskell flags & the ghc-pkg trust stuff
08:23:14 <Eduard_Munteanu> dcoutts: hm, I'm unsure how to use it to that effect... can ghc-pkg be configured to apply such a policy globally, such that 'cabal install' invocations are "safe"?
08:23:35 <fizbin> Though since my error conditions are better expressed as a case match, I'll manually do the "return ()" bit.
08:23:50 <dcoutts> Eduard_Munteanu: ghc-pkg has trust & distrust. I'd read the ghc user guide section on the topic.
08:24:03 <Eduard_Munteanu> Thanks, I will.
08:24:59 <danilo2> Hello! I've got an abstract question :) Lets consider following situation: I'm processing sequences of images and I've got some TimeMonad (whihch has methods like currentFrame). I want to create a dataflow computations, like read image -> blur -> ... etc. But I want to
08:25:03 <danilo2> implement also function "timeShift", which basically should change the "currentFrame" state but **only** for the data, the function i used on. So basically I would like to change the monad for some data and for some other not - is it clear? What design should I choose?
08:27:02 <Eduard_Munteanu> danilo2: do you want to track multiple state separately?
08:33:51 <danilo2> Eduard_Munteanu: something like that. Think about such situation, that you've got a dataflow: readImageFromCurrentFrame -> blur -> ... . This defines a dataflow graph, which will be executed for each frame. Now I can split the flow into 2 separate operations, like C and D
08:34:43 <danilo2> Eduard_Munteanu: C will be a "timeShift", which means, that the result from this operation should use a flow with different time! So even readImageFromCurrentFrame should be computed twice - once for current state and second for that value
08:34:53 <danilo2> Eduard_Munteanu: is that clear?
08:35:31 <a3gis> hey! is it possible to work on random data in haskell? Basically I would like to generate a list of random first order logic expressions, filter it based on some predicate (tautologies) and display the result
08:36:29 <Twey> @faq Is it possible to work on random data in Haskell?
08:36:29 <lambdabot> The answer is: Yes! Haskell can do that.
08:37:00 <a3gis> ok! how? ^^'
08:37:12 <Iceland_jack> @hoogle random
08:37:12 <lambdabot> System.Random random :: (Random a, RandomGen g) => g -> (a, g)
08:37:12 <lambdabot> package random
08:37:12 <lambdabot> package random-access-list
08:37:13 <a3gis> I tried to fiddle with Gen but didn't get very far
08:37:21 <Twey> a3gis: It sounds like you want to write an instance of Random for your type
08:37:29 <Iceland_jack> a3gis: Gen for Test.QuickCheck?
08:37:38 <Iceland_jack> You don't use that to generate random values outside of testing
08:37:48 <a3gis> yep I tried to work with an instance of Arbitrary but I guess that was the wrong approach
08:37:52 <a3gis> ok
08:37:58 <New2Haskell> Alright I just finnished the first assignment giving the length of the longest number
08:38:09 <Twey> a3gis: Then your ‘list of random first-order logic expressions’ is just randoms g
08:38:14 <Iceland_jack> a3gis: http://learnyouahaskell.com/input-and-output under the section "Randomness"
08:38:22 <New2Haskell> Thanks for that but now I am stuck at retrieving the value of the biggest number in a string list
08:38:27 <Twey> I don't know how you'll test for tautologies, but I assume you've got that bit figured out
08:38:29 <New2Haskell> How could that be acomplished?
08:38:30 <knz> hi guys
08:38:47 <knz> wrote this yesterday http://staff.science.uva.nl/~poss/haskell-for-ocaml-programmers.html <- comments welcome!
08:38:56 <a3gis> thanks !
08:40:02 <danilo2> Eduard_Munteanu: I think image is worth more than 10000 wrods :) Look: http://snag.gy/gq90K.jpg In this situation we load image from image sequence (so we load based on current frame), we blur and we split the flow - the right tree is from current time and the left is for example from 10 times before. and then we are adding these images
08:40:21 <dmj`> New2Haskell: what have you tried
08:40:23 <danilo2> Eduard_Munteanu: I want to get such behaviour using monads / arrows or something simmilar if its possible
08:40:26 <suppi> knz, saw this one on reddit earlier today, I always appreciate people writing new tutorials but since I don't know O'Caml (yet) and hardly even know any haskell I'll just save this one and read it later in life :)
08:41:09 <dmj`> New2Haskell: I'd recommend reading Learn you a haskell first
08:41:13 <Iceland_jack> New2Haskell: What is your level of Haskell knowledge? Can you write functions? Recursive functions?
08:41:15 <Iceland_jack> @where lyah
08:41:16 <lambdabot> http://www.learnyouahaskell.com/
08:41:19 <Iceland_jack> New2Haskell: ↑ read that
08:41:41 <suppi> lol, "@where lyah" looks really useful
08:42:33 <prinsen> Is it possible to write a Typeable3 or Typeable4 instance for Pipes? Im having trouble with the monad parameter as its of kind (* -> *)
08:42:49 <prinsen> That is, Pipes.Pipe
08:43:27 <prophile> :k Typeable4
08:43:28 <lambdabot> (* -> * -> * -> * -> *) -> Constraint
08:43:30 <suppi>  Iceland_jack, what do you recommend I should do next, after reading lyah? I just finished it a couple of days ago
08:43:43 <Iceland_jack> suppi: Program and read papers
08:43:50 <New2Haskell> I have tried taking the maximum value
08:44:03 <suppi> papers? which papers?
08:44:04 <klrr_> suppi: write yourself a scheme is alos good
08:44:14 <Iceland_jack> you can check out Real-World Haskell or Simon Marlow's book on parallelism and concurrency in Haskell
08:44:15 <New2Haskell> by just adding maximum in front of the function
08:44:15 <Twey> suppi: ‘Real World Haskell’ has some practical projects in it you might want to give a go
08:44:26 <dmj`> New2Haskell: and what happened?
08:44:35 <Twey> suppi: If you don't have any project ideas of your own
08:44:39 <New2Haskell> it didnt give errors but it didnt give the right results either
08:44:53 <Iceland_jack> New2Haskell: Are you the same user who asked yesterday?
08:44:55 <prinsen> prophile: any idéa how to fit a (* -> *)?
08:44:55 <dmj`> New2Haskell: what is the type of the list you are calling maximum on
08:45:07 <New2Haskell> string list
08:45:07 <suppi> kirr_, I had my eye on that, maybe I'll give it another go
08:45:23 <prophile> prinsen: not into a Typeable3 or a Typeable4, unfortunately
08:45:26 <New2Haskell> I already searched on converting it to ints first
08:45:41 <suppi> Twey, Yes, maybe I'll should catch up with real world haskell
08:45:41 <prophile> you could go for (Typeable1 m) => Typeable2 (Pipe m) or something along those lines I suppose
08:45:43 <New2Haskell> But it didnt really work out that well
08:45:56 <Twey> suppi: Your own projects are always best, though ☺
08:45:57 <klrr_> suppi: it might be a bit outdated, if you want to get your hands dirty you can look into GADTs and write the evaulator more type-safe
08:46:01 <dmj`> > maximum "123456789"
08:46:02 <lambdabot>  '9'
08:46:10 <New2Haskell> let me see
08:46:11 <dmj`> New2Haskell: why not
08:46:13 <suppi> alright, thanks for the advice
08:46:21 <ski> prinsen : you'd prefer a kind-polymorphic type class for that
08:46:32 <suppi> I started writing a 'less' clone, with zippers
08:46:32 <prinsen> prophile: The monad is always IO, just a bit bothered that the type parameters arent Pipe IO await yield return
08:46:36 <Twey> klrr_: Write Yourself a Scheme has been made into a wikibook
08:46:49 <klrr_> Twey: oh, cool
08:46:51 <klrr_> link?
08:47:05 <Shammah> eh, http://hastebin.com/suhululoku.cmake is this supposed to happen; that it always recommend updating? :P
08:47:08 <Shammah> This never ends :<
08:47:19 <klrr_> Twey: oh find it
08:47:21 <klrr_> cool.
08:47:22 <suppi> klrr_, http://en.wikibooks.org/wiki/Write_Yourself_a_Scheme_in_48_Hours
08:47:26 <Twey> klrr_: http://en.wikibooks.org/wiki/Write_Yourself_a_Scheme_in_48_Hours
08:47:29 <Twey> Yeah
08:47:32 <Twey> My Internet is a bit slow, sorry
08:47:42 <klrr_> np! i should google before asking ;)
08:48:11 <prinsen> ski: sounds scary. Right now I let the user write code that compiles to a function OutputType -> InputType, but it would be nicer if they can write a pipe
08:48:17 <New2Haskell> for example if I do maximum "abc8000ddd40000"
08:48:21 <New2Haskell> it would give 8000
08:48:26 <suppi> so, real world and then scheme or scheme and then real world?
08:48:33 <New2Haskell> The function itself extract decimals from the string
08:48:47 <Iceland_jack> > "8000" > "40000"
08:48:48 <lambdabot>  True
08:48:49 <prinsen> but then I need a Typeable1 for Pipe
08:48:49 <suppi> or GADTs? what ever that is
08:48:50 <New2Haskell> as a string list
08:49:00 <Iceland_jack> New2Haskell: Turn it into a number first
08:49:07 <New2Haskell> I tried using this:
08:49:19 <dmj`> > maximum "abc8000ddd40000"
08:49:19 <Iceland_jack> > read "8000" > (read "40000" :: Int)
08:49:20 <lambdabot>  'd'
08:49:20 <lambdabot>  can't find file: L.hs
08:49:21 <New2Haskell> ehh combination of map read
08:49:32 <Iceland_jack> > read "8000" > (read "40000" :: Int)
08:49:33 <prinsen> prophile: Can i flip the type parameters?
08:49:33 <lambdabot>  False
08:49:48 <dmj`> New2Haskell: It gives you 'd' not 8000, are you running your code?
08:49:55 <New2Haskell> yes
08:50:02 <klrr_> suppi: just mentioned GADTs if you wanna "extend" the Writer Yourself a Scheme implementation, implementing macros can also be a good exercise (that one i had hard time with though, but back then i was very new to programming in general so might not be that difficult as it seemed then)
08:50:03 <dmj`> then how did you get "8000"
08:50:14 <New2Haskell> but thanks to Iceland_jack i have a function that takes out the decimals only
08:50:34 <New2Haskell> so I would get ["8000","40000"]
08:50:37 <suppi> klrr_, thanks, any recommendation on where to start?
08:50:49 <New2Haskell> > maximum ["8000","40000"]
08:50:49 <lambdabot>  "8000"
08:51:00 <Iceland_jack> New2Haskell: You need to turn them into numbers first
08:51:01 <klrr_> http://en.wikibooks.org/wiki/Write_Yourself_a_Scheme_in_48_Hours
08:51:03 <Iceland_jack> Using 'read'
08:51:12 <New2Haskell> just read?
08:51:14 <suppi> alright :)
08:51:23 <Iceland_jack> > maximum [read "8000", read "40000" :: Int]
08:51:24 <lambdabot>  40000
08:51:28 <Iceland_jack> New2Haskell: No but it's a start
08:51:37 <Iceland_jack> I don't like spoonfeeding people
08:51:43 <New2Haskell> oh
08:51:57 <klrr_> suppi: it will almost directly show you some practical and nice use of monads so it's good way to get the weird stuff :)
08:52:49 <suppi> I'll do it. It was my plan all along but when I trying to start I got a little disheartened. I'll gather my courage and try again :)
08:53:22 <Twey> knz: The ‘list of statements’ explanations for monads makes me feel a little dirty
08:53:25 <a3gis> Iceland_jack: I am a bit stuck on my generator. Here's the ADT I want to generate random expressions with: https://gist.github.com/a3gis/15761d9c4b7884b2b4dc
08:53:29 <klrr_> suppi: yes, it's maybe not super trivial at first site, but when you got some basics it is a good introduction (was for me at least)
08:53:40 <Twey> knz: And this paragraph is outright wrong: « By convention, programmers also name the file containing "module Blah where ..." with filename Blah.hs. However, it is possible to split a Haskell module definition in multiple source files with different names, or define multiple Haskell modules in the same source file. »
08:53:53 <a3gis> Iceland_jack: as extra complexity I also want to increase the probability of generating a Var as the depth increases
08:54:01 <klrr_> you actually learn to write a fairly "real world" program which is kinda left out in many tutorials
08:54:10 <Iceland_jack> a3gis: Yes :) this is standard
08:54:48 <Twey> knz: The module name must match the filename in general (if you intend to import the module from another module).  The only time it's okay to have a module name that doesn't match the filename is when you are loading the file directly, as an entry point or into GHCi
08:54:51 <klrr_> suppi: also, hoogle is your friend: http://www.haskell.org/hoogle/
08:54:54 <Iceland_jack> a3gis: You use the ‘sized’ function
08:54:54 <suppi> klrr_, yes, and I get to write an interpreter as a bonus, something I have never done before but always wanted to
08:54:57 <Iceland_jack> @hoogle sized
08:54:57 <lambdabot> Test.QuickCheck.Gen sized :: (Int -> Gen a) -> Gen a
08:54:58 <lambdabot> Test.QuickCheck sized :: (Int -> Gen a) -> Gen a
08:54:58 <lambdabot> package sized-types
08:55:07 <suppi> yes I know of hoogle, it's great :) thanks.
08:55:10 <Iceland_jack> And during each recursive call you divide it by two
08:55:16 <klrr_> gl hf!
08:55:24 <Twey> knz: You can only have one module in each file (alas) and you can't define one module across multiple files, although a common organizational technique is to make several ‘sub-modules’ and re-export their definitions in the main module
08:55:33 <knz> Twey: thanks for the clarification. Although I believe technically this is implementation-dependent
08:55:34 <Iceland_jack> a3gis: http://www.cse.chalmers.se/~rjmh/QuickCheck/manual.html this should be very helpful!
08:55:43 <knz> the report clearly mentions more flexibility
08:55:46 <Iceland_jack> the "Generating Recursive Data Types" section
08:55:51 <suppi> thanks :)
08:56:50 <Iceland_jack> a3gis: So it's a common problem to want to generate arbitrary recursive datatypes which could possibly terminate but more likely (past a certain thresh hold) continue forever
08:57:57 <a3gis> Iceland_jack: mmh right but I am not working with quickCheck; I am trying to gen a list of expression I can work on (what randoms does)
08:58:08 <Twey> knz: The report just doesn't talk about the relation to the filesystem at all
08:58:13 <a3gis> thanks for the links though, I will take a look
08:58:20 <Iceland_jack> a3gis: You can use the same approach
08:58:44 <Twey> knz: But I think it's important to talk about what actually works, or your readers might get confused when they try to put multiple modules in one file :þ
08:59:00 <prinsen> Iceland_jack: instance Typeable3 (Pipe a b IO c) doesn't work as Haskell says it is of kind *, any way to do what I want? Ie. having kind * -> * -> * -> *
08:59:15 <Twey> Maybe a footnote could mention that this behaviour isn't required by the standard
09:00:08 <knz> Twey: thanks
09:00:59 <knz> Twey: about you feeling "dirty"; well, sorry for that but you probably understand why it was a necessary evil :)
09:01:07 <a3gis> Iceland_jack: an can I use helpers such as oneof etc?
09:02:08 <Twey> knz: The dirtiness stems from the fact that a ‘list’ is a predefined data structure, that doesn't capture what the IO monad does.  We like the analogy of a ‘recipe’ around here lately.
09:02:23 <knz> aha
09:03:02 <knz> well for one I was very careful to place "list" between quotes consistently, to make it clear it was shorthand for something else entirely.
09:03:03 <knz> but I like "recipe" too!
09:03:21 <Twey> I know, I figured that out… but better to avoid the term altogether, no?
09:03:50 <Twey> knz: putStr.show v1 -- this doesn't type-check in the context in which you've used it (you probably meant  putStr $ show v1  or  putStr . show $ v1 )
09:04:14 <gal_bolle> is there a library for using an 'STRef s (RandomGen)' to get random numbers from within an 'ST s a' computation?
09:04:26 <Twey> putStr.show v1 = putStr . show v1 = putStr . (show v1); show v1 isn't a function, so it can't be composed with putStr
09:05:25 <Twey> knz: Also, it's conventional to space operators in most cases, with the exception of some of edwardk's lens stuff and sometimes for grouping of mathematical expressions like a + b*c
09:07:44 <Twey> knz: Might be nice to go into some of GHCi's debugging features, rather than talking about unsafePerformIO and Debug.Trace.trace
09:08:43 <Twey> knz: Mentioning unsafePerformIO instead has the two disadvantages that a) it doesn't work so well when things are evaluated in an order different to what you expect due to lazy evaluation, and b) you have to teach newbies about unsafePerformIO :þ
09:08:58 <a3gis> Iceland_jack: I found a good blog-post; thanks a lot for the help
09:09:50 <Twey> knz: When talking about mutability, I think ST bears some mention
09:10:29 <knz> Twey: it is mentioned later
09:10:38 <Twey> Ah, okay — haven't got there yet
09:11:09 <Twey> Eq actually has default implementations for *both* functions — the empty instance is an infinite loop >.<
09:11:25 * hackagebot engineering-units 0.0.1 - A numeric type for managing and automating engineering units.  http://hackage.haskell.org/package/engineering-units-0.0.1 (TomHawkins)
09:13:03 <Twey> knz: Pedantry, but <- is actually built-in syntax, not an operator
09:13:58 <Twey> knz: You introduce =<< and >>= rather abruptly in ‘Rolling your own “statement lists”’ — you've been carefully avoiding them up to that point :þ
09:14:18 <knz> nope, they are mentioned earlier
09:14:32 <knz> "piping of effects"
09:16:27 <Twey> Oh yeah — missed that somehow
09:17:16 <Twey> knz: Re. named/optional arguments, you might want to mention records and the ‘default record argument’ pattern
09:17:55 <knz> Twey: oh? I don't know it\
09:18:01 <Twey> What's a polymorphic variant?  Google seems to think it's just a sum type, which Haskell certainly has
09:18:52 <Twey> knz: Like Pandoc — you have a record type that represents all the possible parameters to the function, and a record of default settings ‘def’ (often using the Default typeclass).
09:19:08 <Twey> knz: Then you can write: foo def { parameterIWantToOverride = bar }
09:20:10 <knz> Twey: polymorphic variants are "open union types" where you can use the same constructor in multiple types
09:20:10 <knz> or redefine later
09:20:22 <knz> polymorphic variants have a rich algebra for subtyping
09:20:52 <knz> and I still do not understand the default record argument thing
09:20:57 <Twey> Oh, I see
09:21:15 <Twey> We have type families these days; not sure if that's the same kind of thing
09:21:39 <Sculptor> hi
09:21:39 <knz> http://neilmitchell.blogspot.nl/2008/04/optional-parameters-in-haskell.html
09:21:40 <Twey> knz: Record update syntax is: someRecord { someNewParameter = someNewValue }
09:22:14 <Twey> knz: Yep, that's the trick
09:22:49 <Twey> knz: Except the ‘Default’ typeclass lets you avoid naming your default parameters after your type
09:22:56 <Twey> Sculptor: Hi
09:24:44 <levi> Twey: Diagrams makes heavy use of the default record argument pattern too; they've even provided a 'with' alias for 'def'.
09:25:38 <Twey> Indeed
09:26:03 <knz> Twey: ok, I'll mention it. I also looked at type families and yes, you can abuse them to do things similar to what people do with ocaml's polymorphic variants.
09:26:19 <knz> it's not stricty the same however.
09:26:31 <Twey> Not sure it's an abuse; that's part of what open type families are for
09:27:08 <watermind> so updating cabal-install gives me this warning
09:27:10 <watermind> http://pastebin.com/i55AxUZm
09:27:31 <knz> Twey: ok...but anything that involves a compiler-specific extension qualifies as "abuse" in my eyes :)
09:28:00 <watermind> In order, the following would be installed:  directory-1.2.0.1 network-2.4.2.2 HTTP-4000.2.11 process-1.2.0.0 Cabal-1.18.1.3 cabal-install-1.18.0.3
09:28:06 <levi> Hmm; Cabal relies on file names and directory structure for the build process, doesn't it?
09:28:15 <watermind> cabal: The following packages are likely to be broken by the reinstalls: ... ghc-7.6.3 ...
09:28:34 <watermind> suppose so
09:28:37 <levi> knz: It's part of the expansion of the language, not necessarily abuse.
09:28:50 <byorgey> watermind: yikes
09:28:56 <watermind> byorgey: yes
09:29:09 <byorgey> watermind: can you paste the output of cabal install --dry-run -v3 cabal-install ?
09:29:16 <watermind> byorgey: sure
09:30:08 <watermind> byorgey: http://pastebin.com/VkcA5Lii
09:30:09 <knz> levi: find me a formal definition of "abuse" and then we can argue :)
09:33:25 <byorgey> watermind: ah, it looks like your package database is already in a strange/inconsistent state.  e.g. you have two versions of the 'unix' package and two versions of the 'process' package installed...
09:33:42 <byorgey> watermind: try  cabal install --constraint='unix < 2.7' --dry-run cabal-install
09:34:08 <byorgey> since it looks to me like the solver is picking unix-2.7 early on and it is causing a lot of problems
09:34:34 <byorgey> but unix-2.6 should work just as well
09:34:40 <watermind> byorgey: no idea how that happened :/
09:35:54 <watermind> byorgey: http://pastebin.com/a8A6Tq9B
09:35:58 <watermind> doesn't seem to fix it
09:36:34 <byorgey> watermind: the link you gave doesn't have a --constraint argument
09:36:50 <fly2web> infinite loof how can escape it?
09:36:54 <watermind> byorgey: wait
09:36:55 <fly2web> busy.
09:37:07 <byorgey> fly2web: Ctrl-C ?
09:37:08 <watermind> byorgey: opss sorry!
09:37:08 <fly2web> infinite loop.
09:37:19 <fly2web> thanks
09:37:32 <byorgey> fly2web: is this in ghci? or a compiled program? or...?
09:37:38 <watermind> byorgey: yeah that seems to work
09:37:46 <byorgey> great
09:37:52 <fly2web> ghci.
09:38:02 <watermind> byorgey: should i remove unix 2.7 then?
09:38:08 <fly2web> thanks byorgey
09:38:44 <byorgey> watermind: yes.  at the very least you will find out what depends on it, if ghc-pkg complains that some things will break
09:38:49 <byorgey> ghc-pkg unregister unix-2.7
09:38:55 <watermind> ok
09:38:58 <levi> knz: Well, it seems a bit ironic for someone talking about new extensions to the OCaml language to talk about new extensions to Haskell as abuse. The fact that OCaml doesn't have an 'OCaml Report' to be compatible with is the only difference.
09:39:22 <knz> levi: what extension are you thinking about?
09:39:58 <watermind> byorgey: nothing depended on it ... weird
09:40:14 <watermind> byorgey: thanks!
09:40:30 <levi> Well, I'm not sure how long polymorphic variants have been around, but they're definitely not a core ML feature.
09:41:13 <levi> OCaml's recently got GADTs and first-class modules as well; are those 'abuse'?
09:42:35 <knz> levi: I was specific to write an article for *ocaml* progamers. the OCaml language, in contrast to Haskell, is *defined by its implementation* -- it is nothing more or less than what the official ocaml distribution supports. As of 4.xx, it supports both polymorphic variants and GADTs, so I have to mention them somehow.
09:42:36 <knz> Extending my writing to also talk to SML programmers would be a different task...
09:44:09 <sykik> hi people
09:44:09 <companion_cube> levi: OCaml isn't "just" sugar-coated ML any more
09:44:21 <Twey> abuse /əˈbjus/ n. Improper treatment or usage; application to a wrong or bad purpose.
09:44:40 <sykik> I've just started reading about functional programming
09:44:43 <Twey> Arguably type families are an abuse of Haskell, but open sum types aren't an abuse of type families no matter how you look at it.
09:44:44 <levi> My point is that it evolves; calling Haskell's method of evolution 'abuse' seems a bit harsh.
09:44:56 <watermind> companion_cube: what do you mean by that?
09:45:09 <sykik> One question that's bothering me is about immutability
09:45:16 <sykik> Anybody free to explain that to me?
09:45:20 <companion_cube> watermind: that features such as objects or GADTs make it quite different from SML
09:45:46 <Twey> sykik: Immutability means that once value are defined in Haskell, they aren't modified.
09:46:12 <Twey> values**
09:46:14 <sykik> I know the definition of it....I'm still to pose the question
09:46:29 * hackagebot yesod-bin 1.2.7.1 - The yesod helper executable.  http://hackage.haskell.org/package/yesod-bin-1.2.7.1 (MichaelSnoyman)
09:46:31 <Twey> sykik: Oh.  Well, pose your question, then :þ
09:46:34 <knz> sykik: you can't get an answer before you actually state your question!
09:46:56 <watermind> companion_cube: right, yes I agree
09:47:00 <sykik> I didn't want to interrrupt the conversation in mainchat
09:47:32 <sykik> anyways...let me compose it and post it here.. 1 min
09:47:32 <Twey> sykik: It's not against IRC etiquette to have more than one thread of discussion going on at once.
09:47:34 <watermind> companion_cube: but objects were always part of OCaml no? so by that reasoning it was never just sugar-coated ML
09:47:56 <companion_cube> right
09:48:08 <companion_cube> but I mean that Ocaml now has many more features
09:48:19 <watermind> yes, indeed
09:48:59 <levi> Well, GHCHaskell has many more features than Haskell. If we call it GHCHaskell, it's defined by its implementation and no longer abusing things. :)
09:49:05 <watermind> the one thing I really miss at this point is some way to somehow replicate some of the ad-hoc polymorphism given by typeclasses
09:50:18 <watermind> on haskell I miss modules
09:50:21 <k00mi> knz: one of the goals of haskell is to experiment with new features without having to build an entire new language
09:50:24 <sykik> Twey: Suppose we're iteratively building a new list starting from one existing list.....So by definition, everytime
09:50:25 <sykik> we add an element to the list, we'll have to copy the old list and then append the latest element.
09:50:25 <sykik> How can this be efficient?
09:50:33 <k00mi> implementation specific extensions were intended from the beginning
09:50:51 <watermind> sykik: you don't copy
09:51:03 <watermind> sykik: you share
09:51:09 <eacameron> I'm ashamed to say that I just realized that the IO monad is basically strict (not lazy): does that mean that unused IO computations in my do blocks will always be executed anyway?
09:51:20 <sykik> that means we overrite?
09:51:24 <watermind> sykik: no
09:51:41 <watermind> sykik: it means both the new list and the old list share data
09:51:48 <watermind> sykik: and coexist
09:51:57 <k00mi> sykik: as long as you don't modify the old list, you don't have to copy it, you just point to it in your new cons cell
09:52:18 <watermind> sykik: the new list's tail shares the elements of the old list
09:52:34 <watermind> sykik: plus it has a new element on the head
09:52:54 <kuribas> For interactive programs, isn't using mutable variables more efficient than updating state globally?
09:53:39 <sykik> similar to a linkedlist right? but in that case, we'd lose the old list
09:53:42 <k00mi> but sharing works only for prepending, if you append, you have to traverse the list to modify the nil (and thus the entire list), so you have to copy
09:54:17 <Twey> sykik: Haskell uses boxed data (almost) everywhere.  Wherever you refer back to an existing structure, the structure is not copied over, only its pointer.
09:54:21 <sykik> I mean we won't have distinction between the old and new list. All we'd have is the new list
09:55:02 <Twey> sykik: So, for example, if as = [1, 2, 3, 4] and bs = 5 : tail as, that's the same as saying xs = [2, 3, 4], as = 1 : xs, bs = 5 : xs
09:55:05 <k00mi> sykik: you can still point to the head of the old list, it isn't modified
09:55:06 <levi> sykik: Think about what a reference to the 'old' list is pointing to.
09:55:11 <watermind> k00mi: kinda... you still don't copy the info on the nodes do you?
09:55:22 <Twey> sykik: I.E. [2, 3, 4] is only stored in memory once.
09:55:22 <k00mi> watermind: yes
09:55:41 <watermind> k00mi: yes you have or yes I'm right that you don't have?
09:55:55 <k00mi> yes you're right ;)
09:55:58 <watermind> ok :(
09:56:00 <watermind> ok :)
09:56:02 <watermind> opss
09:56:12 <sykik> ya that makes sense
09:56:46 <zerokarmaleft> sykik: the same principle applies to trees
09:57:43 <sykik> so what kind of data structure is used to achieve this?.
09:58:22 <zerokarmaleft> I recommend reading up on Chris Okasaki's for an in-depth coverage of functional data structures
10:00:02 <simon> kuribas, those don't exclude each other. it is more efficient to modify memory in-place, but you can achieve this with immutable data structures so long as you can prove at compile-time that something won't be re-used. I reckon uniqueness types / linear typesystems will be popular for this reason because you can achieve the efficiency of mutability with the strictness of declarative languages.
10:00:53 <simon> sykik, achieve what exactly?
10:02:06 <sykik> the sharing facility of lists
10:02:17 <simon> sykik, linked lists will do.
10:03:35 <simon> sykik, do you mean if you were prepending rather than appending, as k00mi talked about?
10:03:36 <kuribas> simon: For example, I have a drawing program where the handles can change appearance when the mouse hovers over it.  I can do this easily with a mutable variable, or I can just copy the whole handle datastructure to reflect the change.  Or I can give each handle a unique ID, but it all seems more complicated than a mutable variable.
10:04:12 <Twey> sykik: Pointers ;)
10:04:16 <sykik> not anything specific. any kind of modification
10:04:36 <sykik> right Twey
10:04:50 <Twey> sykik: That's really all you need
10:04:53 <sykik> have better understanding now
10:05:19 <Twey> sykik: The trick is just to make everything accessible via a pointer, and then copy the pointer over instead of its contents
10:05:21 <sykik> thanks Twey wantermind  zerokarmaleft  simon
10:05:35 <Twey> Everything else is transparent (until you start thinking about lazy evaluation)
10:05:55 <zerokarmaleft> immutability guarantees that the shared structure doesn't change out from underneath any of the references
10:06:01 <simon> kuribas, the way you do that functionally is to have a function that passes as argument a structure containing the state. if you have to create a whole new structure upon every recursive call, that does become inefficient.
10:06:02 <Twey> This only works because of immutability, of course — if the structure were mutable you couldn't do that, because a change to one thing would appear in the other
10:08:51 <hutn> hey #haskell
10:09:04 <hutn> im working on really basics graphics stuff
10:09:12 <hutn> and im trying to use matrices so i can do cool transformations and stuff
10:09:23 <hutn> but im not sure how to go about implementing matrices
10:09:33 <shiona> 2d or 3d?
10:09:34 <kuribas> 3D or 2D?
10:09:36 <hutn> whether i should just use [[]] or make a data Matrix or a class
10:09:38 <hutn> 2d then 3d
10:09:45 <hutn> 3d later
10:10:17 <kuribas> hutn: here is a library I wrote for 2D: http://hackage.haskell.org/package/cubicbezier-0.2.0/docs/Geom2D.html
10:10:25 <hutn> 3d in the sense that im also tracking z in a transformation matrix, never going deeper than [[]]
10:10:36 <hutn> oh cool kuribas! thanks ill take a look
10:10:50 <kuribas> hutn: It is actually for bezier curves, but it has basic 2D transformations.
10:11:49 <pavonia> hutn: What library do you use for drawing? Most of them already have some matrices support
10:12:07 <hutn> kuribas: this is pretty much what i want to write lol! this is a bit of a learning project so im looking mostly for advice on what i should use fundamentally to track matrices
10:12:48 <spruett3> 023.
10:12:49 <hutn> pavonia: im writing to an image file directly, currently just a learning project so im hand rolling most of this
10:13:00 <sykik> right zerokarmaleft twey
10:13:14 <hutn> pavonia: i want to write my own matrices because im also doing this to learn haskell and for my computer graphics class
10:13:34 <hutn> oh shit i spelled my name wrogn
10:13:45 <bergey> hutn: I like http://hackage.haskell.org/package/linear when I want vectors and matrices, but not a pre-selected representation of any higher-level geometry.
10:14:14 <sykik> Twey : what is boxed data?
10:14:44 <hutn> bergey: thanks! this looks about what im looking for exactly
10:16:06 <hutn> pavonia: im writing to an image file directly, currently just a learning project so im hand rolling most of this
10:16:36 <pavonia> I see
10:16:54 <k00mi> hutn: a list of lists is usually a bad idea performance-wise
10:18:12 <kuribas> I don't even use matrices, the coded the transformation directly as a datatype.
10:18:16 <hutn> k00mi: whats the alternative? a flat list?
10:19:12 <hutn> k00mi: im worried about using a flat list because i dont want haskell to retreverse the matrix unnecceesarrily to pack up rows for dot products
10:19:17 <hutn> or columns
10:19:51 <geekosaur> you do realize that a list is a singly linked list, not an array?
10:20:15 <hutn> geekosaur: yea thats why im worried about retreversal!
10:20:52 <k00mi> hutn: some sort of array type, like Data.Vector
10:21:02 <k00mi> but the linear package is really great for this kind of thing
10:24:42 <Twey> Fuuzetsu: proposed-project 2012: ‘Solve cabal dependency hell’
10:25:02 <Twey> sykik: Boxed data is data that is represented not directly but by a pointer
10:25:26 <sykik> got it
10:25:39 <Twey> (and possibly some extra information)
10:26:04 <geekosaur> solution to cabal dependency hell: make ghc not so persnickety. sadly this seems impossible :/
10:26:24 <geekosaur> (well, it's possible but only by switching to whole-program compilation or taking a massive performance hit)
10:26:33 * hackagebot yesod-form 1.3.7 - Form handling support for Yesod Web Framework  http://hackage.haskell.org/package/yesod-form-1.3.7 (MichaelSnoyman)
10:26:36 <Twey> Indeed
10:26:38 <dcoutts> I don't think that's the solution
10:26:47 <dcoutts> even if you did it, it's only solve part of the problem
10:26:52 <dcoutts> its/it'd
10:27:00 <dcoutts> what nix does is the solution
10:27:02 <thebnq> isn't backpack supposed to be the (type of) solution we need
10:27:43 <Twey> Is there any work on *implementing* Backpack?  I've seen the paper around for ages, but there doesn't seem to be any drive to actually do it
10:27:58 <dcoutts> thebnq: no, it's solving a different problem
10:28:26 <dcoutts> Twey: we had a conference call about implementing it not so long ago, it is a lot of work though and it's not clear the resources are there, but we'll see
10:29:33 <thebnq> does it relate in anyway or is my understanding just bad, i haven't read the paper yet..
10:29:53 <Twey> dcoutts: Ah, cool
10:30:10 <Twey> What is the ‘local naming policy’ for GHC Trac?
10:30:19 <thebnq> or would it juts "help"
10:30:34 <Twey> I'm trying to sign up but it just keeps telling me my username doesn't match the local naming policy, with no indication of what that might be
10:32:33 <dcoutts> thebnq: backpack is great for doing things like mocking, swapping out concrete implementations for others with the same interface
10:33:09 <dcoutts> thebnq: the impl would rely on some of the same underlying mechanisms as we need to solve cabal hell generally, like being able to install multiple instances of the same version of the same package at once
10:33:09 <helekfek> hi
10:33:24 <helekfek> i have to say something.
10:33:36 <AGD> hi guys, I'm struggling with a design issue and was hoping someone cleverer than me could help me out :)
10:33:43 <AGD> I'm trying to implement behaviour trees using pure functions. (Behaviour trees are trees where nodes specify which children to update and the leaves are functions which implement the behaviours).
10:33:47 <helekfek> http://book.naver.com/bookdb/book_detail.nhn?bid=7436299   <-- this book is licensend?
10:33:57 <AGD> It works fine but all my actions accept the same input parameters.
10:34:07 <AGD> This is not great for coupling and I don't really like passing in the whole world to each behaviour function!
10:34:21 <AGD> Are there any nice functional patterns to disaggregate the global state as required for each function?
10:34:23 <thebnq> dcoutts: i see, thanks
10:34:51 <helekfek> http://book.naver.com/bookdb/book_detail.nhn?bid=7436299   <----- legal book?
10:36:06 <dcoutts> helekfek: I've no idea if naver are reselling it legally, but it is certainly for sale legally from the publisher and some other retailers
10:36:16 <dcoutts> http://www.nostarch.com/lyah.htm
10:36:46 <helekfek> i think so
10:37:02 <helekfek> plz capture it.
10:38:10 <helekfek> royalty is paied?
10:38:14 <helekfek> to that book?
10:38:56 <helekfek> royalty is paid to that book?
10:39:14 <dcoutts> helekfek: I'm not sure what you're asking exactly. If you're worried that it's not a legal resale then contact the original publisher.
10:44:10 <pavonia> How bad is it to create a Monad instance for a data type that actually isn't a monad, just to be able to use do-notation?
10:46:20 <k00mi> pavonia: you could use RebindableSyntax instead
10:47:02 <pavonia> What is that?
10:47:35 <k00mi> http://www.haskell.org/ghc/docs/6.8.1/html/users_guide/syntax-extns.html
10:47:36 <k00mi> 8.3.5
10:47:52 <k00mi> it desugars do to >>= and >>, using whatever is in scope
10:48:28 <ryantrinkle> is there a good way to wait for *either* read or write, a la GHC.Conc.threadWaitRead and threadWaitWrite?
10:48:36 <ryantrinkle> (better than spawning two threads and racing them)
10:49:27 <pavonia> k00mi: Does that allow you to mix "real" monads and my in one module?
10:49:40 <pavonia> in do-notation, that is
10:50:06 <k00mi> pavonia: I don't know, I never actually used that extension
10:51:26 <pavonia> I guess the user of my module has to use it too, which is probably even worse than a faked monad :p
10:52:03 <Twey> pavonia: It's pretty bad.
10:52:26 <Twey> pavonia: Though if you can define a sensible meaning for do-notation, it probably is a monad
10:53:13 <dcoutts> ryantrinkle: not conveniently, you'd have to go down to the event layer of the IO manager
10:53:15 <shachaf> (Catch: "sensible" means "it's a monad".)
10:53:31 <ryantrinkle> dcoutts: ok, np; good thing spawning threads is relatively cheap :)
10:53:33 <k00mi> pavonia: if it's for a library, a fake Monad is pretty horrible
10:53:55 <dcoutts> ryantrinkle: aye
10:55:05 <Twey> shachaf: Not necessarily.  It could be an indexed monad.
10:55:21 <Twey> Hence ‘probably’
10:55:30 <pavonia> Well, I don't need the type parameter for that type, so the only sensible thing (in my eyes) would be to create "instance Monad FooM" and export "type Foo = FooM ()"
10:55:49 <Twey> Ah, it's monomorphic
10:55:57 <Twey> pavonia: That doesn't sound like a terrible idea
10:56:12 <pavonia> Oh, good
10:56:19 <Twey> pavonia: What's the type, exactly?  Maybe you *can* generalize it to make use of the type parameter
10:57:00 <pavonia> It's a type for describing layouts, I don't have a real type yet
10:58:20 <Twey> pavonia: Why does it make sense to use do-notation?  What does the ← operation bind?
10:59:01 <pavonia> Yeah, that part doesn't make sense, it would be () in that case
10:59:16 <Twey> pavonia: Well, that's the point of do-notation :þ
10:59:33 <Twey> Why else would you want to use it?
10:59:44 <pavonia> But it would be nice to use syntactic layout for nested levels of the layout specification
11:01:37 * hackagebot network-conduit 1.0.4 - Stream socket data using conduits.  http://hackage.haskell.org/package/network-conduit-1.0.4 (MichaelSnoyman)
11:01:39 * hackagebot persistent 1.3.0.3 - Type-safe, multi-backend data serialization.  http://hackage.haskell.org/package/persistent-1.3.0.3 (MichaelSnoyman)
11:01:41 * hackagebot persistent-mongoDB 1.3.0.3 - Backend for the persistent library using mongoDB.  http://hackage.haskell.org/package/persistent-mongoDB-1.3.0.3 (MichaelSnoyman)
11:01:43 * hackagebot persistent-mysql 1.3.0.1 - Backend for the persistent library using MySQL database server.  http://hackage.haskell.org/package/persistent-mysql-1.3.0.1 (MichaelSnoyman)
11:01:45 * hackagebot persistent-postgresql 1.3.0.3 - Backend for the persistent library using postgresql.  http://hackage.haskell.org/package/persistent-postgresql-1.3.0.3 (MichaelSnoyman)
11:02:00 <Twey> pavonia: It sounds like you might want some variant of the Reader monad
11:03:02 <Twey> pavonia: What sort of layouts are you talking about, here?  Like GUI widget layouts, or XMonad layouts (functions from a set of widgets with layout hints to a set of widget with some kind of positioning information)?
11:04:09 <pavonia> Twey: GUI layouts
11:06:47 * hackagebot persistent-sqlite 1.3.0.3 - Backend for the persistent library using sqlite3.  http://hackage.haskell.org/package/persistent-sqlite-1.3.0.3 (MichaelSnoyman)
11:06:49 * hackagebot persistent-template 1.3.1.2 - Type-safe, non-relational, multi-backend persistence.  http://hackage.haskell.org/package/persistent-template-1.3.1.2 (MichaelSnoyman)
11:06:51 * hackagebot pool-conduit 0.1.2.1 - Resource pool allocations via ResourceT.  http://hackage.haskell.org/package/pool-conduit-0.1.2.1 (MichaelSnoyman)
11:06:53 * hackagebot warp 2.1.1 - A fast, light-weight web server for WAI applications.  http://hackage.haskell.org/package/warp-2.1.1 (MichaelSnoyman)
11:13:06 <kwstas> i created my version of the length :: [a] -> Int function: `length' = foldr' (\_ acc -> acc+1) 0`. Shouldn't this function run in constant space?
11:13:26 <Cale> kwstas: Well, let's evaluate
11:13:43 <Cale> foldr (\_ acc -> acc + 1) 0 [1,2,3]
11:14:09 <Cale> --> (\_ acc -> acc + 1) 1 (foldr (\_ acc -> acc + 1) 0 [2,3])
11:14:37 <Cale> --> (\acc -> acc + 1) (foldr (\_ acc -> acc + 1) 0 [2,3])
11:14:47 <Cale> --> (foldr (\_ acc -> acc + 1) 0 [2,3]) + 1
11:15:22 <Cale> --> ((\_ acc -> acc + 1) 2 (foldr (\_ acc -> acc + 1) 0 [3])) + 1
11:15:34 <Cale> --> ((\acc -> acc + 1) (foldr (\_ acc -> acc + 1) 0 [3])) + 1
11:15:46 <Cale> --> ((foldr (\_ acc -> acc + 1) 0 [3]) + 1) + 1
11:16:54 <Cale> --> ((\_ acc -> acc + 1) 3 (foldr (\_ acc -> acc + 1) 0 [])) + 1) + 1
11:17:03 <Cale> --> ((\acc -> acc + 1) (foldr (\_ acc -> acc + 1) 0 [])) + 1) + 1
11:17:13 <Cale> --> ((foldr (\_ acc -> acc + 1) 0 []) + 1) + 1) + 1
11:17:23 <Cale> --> ((0 + 1) + 1) + 1
11:17:46 <Cale> (I think I missed a '(' at one point there, but you get the picture)
11:18:03 <Cale> and now we can finally begin to reduce this arithmetic expression
11:18:08 <dawik> haskell users are so ocd
11:18:18 <dawik> i feel right at home
11:18:40 <Cale> But in the meantime, this expression has been growing, and you can see that if we'd started with a list of length 1000000, it would actually be quite large
11:19:14 <joehillen> Cale: there should be a tool to generate that. I would call it "The Stupid Computer" after Philip Walder's explanation of Haskell evaluation
11:19:15 <adimit> … and that's why we use foldl'.
11:19:20 <kwstas> Cale: yes i got it. I thought  foldr' (strict version) solves this issue, but it just evaluates the (acc+1), eh?
11:19:34 <Cale> Where are you getting foldr' from?
11:19:47 <kwstas> Data.Foldable
11:19:51 <Cale> ah, okay
11:20:09 <Cale> Well, the Data.Foldable version can't possibly do anything better in the case of lists
11:20:19 <Cale> which is why there's no such thing in Data.List
11:20:24 <ReinH> Cale: er, that's parenthesizes as a right fold?
11:20:45 <Cale> ReinH: hm?
11:20:59 <ReinH> wouldn't it be 0 + (1 + (1 + 1))
11:21:01 <joehillen> kwstas: foldr' keeps the accumulator strict so that you don't end up with a big list of thunks
11:21:06 <christianpbrink> Suppose I've got a web app and I'm publishing jobs to a message queue, to be processed later by a worker.  'Job' is a type class, and there are several different datatypes that are instances of it, representing different types of jobs the worker can perform.  Now, the jobs are serialized to JSON, which of course is typeless.  I'm wondering: when I decode that JSON (using Aeson, for instance), is it possible to make my program infer which of
11:21:06 <christianpbrink>  my job types it is?  I know I could *tell* my program which of the types it is, but what I want, if it's possible, is for the program to infer the type.  I am of course happy to tell the program that the type must be an instance of my Job typeclass... but not constrain it any further than that.
11:21:08 <Cale> ReinH: Apparently not!
11:21:11 <ReinH> *parenthesized
11:21:14 <ReinH> Cale: huh! :)
11:21:26 <Cale> ReinH: You can follow my reduction steps there and see if I messed up anywhere, but I don't think I did.
11:21:40 <Cale> ReinH: Remember that we've reduced all the 'f's here
11:22:05 <kwstas> Cale: Is there some other foldr' that solves the problem, or shoul;d i use a foldl' as adimit said?
11:22:11 <Cale> You should use foldl'
11:22:27 <Cale> You can also get away with just using foldl if you're compiling with at least -O
11:22:29 <kwstas> Cale: Ok, thanks a lot :)
11:22:43 <ReinH> @src foldr
11:22:44 <lambdabot> foldr f z []     = z
11:22:44 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
11:22:46 <Cale> (The compiler is smart enough to compile foldl to efficient code)
11:22:57 <Cale> (but only with optimisations on)
11:23:32 <adimit> be wary of using it to fold really large lists in complex code, esp. if you're reading them in from file. Lazy IO could bite there.
11:23:49 <Cale> adimit: Wary of using what?
11:24:17 <ReinH> hmm... foldr (+) 0 [1,2,3] --> 1 + (foldr (+) 0 [2,3]) --> 1 + (2 + (foldr (+) 0 [3])) --> 1 + (2 + (3 + (foldr (+) 0 []))) --> 1 + (2 + (3 + 0))
11:24:25 <ReinH> Cale: what's the difference?
11:24:35 <Cale> ReinH: The operation we used wasn't (+)
11:24:47 <Cale> It was (\_ acc -> acc + 1)
11:25:04 <ReinH> ah right
11:25:13 <ReinH> it's the Sum (Const 1) monoid
11:25:16 <Cale> You might be happier with (\_ acc -> 1 + acc)
11:25:20 <ReinH> ahhh
11:25:22 <ReinH> doh
11:25:51 <ReinH> (aka the count monoid)
11:26:07 <ReinH> gotcha
11:26:32 <ReinH> Cale: well yes acc is on the left hand side, that's obvious now :p
11:26:39 <ReinH> so ofc it parenthesizes from the left
11:26:54 <Twey> pavonia: So, you can do a Reader Environment (Widget, Position)
11:27:38 <Twey> pavonia: When you nest things, you have a new layout, so you runReader with the new layout information and a separate do-block for the nested layout
11:27:59 <Twey> pavonia: The return value from your monad is the positioned widgets
11:28:20 <Twey> pavonia: Sorry, I meant Reader Environment (Set (Widget, Position))
11:28:43 <Twey> You probably want to lay out more than one widget :þ
11:29:01 <Twey> Or Reader Environment (Map Widget Position) if your Widget is Ord
11:30:21 <ReinH> Twey: you probably want a nice way to have access to previous widget position calculations?
11:32:22 <Twey> ReinH: Do you?
11:32:49 <ReinH> Twey: Maybe?
11:33:13 <Twey> ReinH: I'd see that as a bit fishy.  You'd have to impose some sort of arbitrary order of dependencies on them.
11:33:51 <ReinH> Twey: widgets sometimes have non-arbitrary order dependencies, a la "contains"?
11:33:58 <hseg> Hi. I've been attempting to understand SPJ
11:34:04 <ReinH> i.e. widgets often form a tree?
11:34:44 <hseg> 's State in Haskell, and I still don't understand how the type of runST prevents cross-thread communication.
11:34:46 <pavonia> Twey: Hhm, I may need a more complex data type because there are two ways to do the actual widget positioning: 1) Do it myself and use fixed coordinates, 2) let the GUI library do the calculations by using existing layout management
11:34:56 <ReinH> Twey: maybe you just want a widget monoid
11:35:18 <Twey> ReinH: ‘Contains’ here is going to be handled by nesting layouts, no?  To lay out a container, you first decide where to position the container itself, then lay out its children in an environment that includes the constraints imposed by being inside that space
11:35:23 <merijn> hseg: Did you read the ST paper?
11:35:28 <ReinH> Twey: right, was just thinking that
11:36:19 <merijn> hseg: Do you understand that the only way to leak state from one runST to another is by leaking actions that read STRefs or the STRef themselves?
11:36:43 * hackagebot email-header 0.2.0 - Parsing and rendering of email and MIME headers  http://hackage.haskell.org/package/email-header-0.2.0 (KyleRaftogianis)
11:36:44 <hseg> merijn: That's what I'm asking. I'm on page 8 of State in Haskell, and while I understand the idea of how rank-2 types prevent leaking, I don't understand the practice of how it works.
11:36:57 <Twey> pavonia: Sure, you can embed that in an Either or whatever.  That's just the type for when you want to do it yourself; if your library requires some kind of special type to do its own layouts, you'll want to sum the two types together in order to handle both cases.
11:37:04 <hseg> merijn: No, I'm not sure I understand that.
11:37:13 <merijn> hseg: Well, the only mutable state is in STRefs, right?
11:37:21 <hseg> merijn: Yes.
11:37:34 <hseg> merijn: Well, as far as the given API goes.
11:37:51 <merijn> hseg: So the only way to encounter mutable state is to read an STRef or get an STRef that you can read yourself, right?
11:38:53 <hseg> merijn: Right. This is mutation as seen in the State monad, as far as I can tell.
11:39:55 <merijn> hseg: Right, now the trick is this: "runST :: (forall s . ST s a) -> a", so the entire ST must be polymorphic in 's', right? Because if it was one specific 's', then it wouldn't match the forall
11:40:04 <kuribas> It there a function IO a -> IO () that just throws away the result?
11:40:09 <hseg> merijn: Right.
11:40:16 <hseg> :t void
11:40:16 <lambdabot> Functor f => f a -> f ()
11:40:28 <pavonia> Twey: Okay, thanks for the input. I see I have to think more about the specification to make clear what I actually want before just start coding :)
11:40:29 <hseg> kuribas: IO is a Functor
11:40:36 <kuribas> oh, nice.
11:40:38 <kuribas> Thanks
11:40:56 <hseg> kuribas: Pleasure. BTW, you do know how to implement void, I assume?
11:41:06 <merijn> hseg: But the way the ST monad is defined, any STRef that is returned from an ST "transcation" will have a monomorphic 's'
11:41:24 <kuribas> hseg: yeah, that would be no problem.
11:41:42 <kuribas> fmap () I guess?
11:41:43 <merijn> hseg: As such, trying to read this STRef (or use an action that reads one) won't be completely polymorphic in 's', so any ST action that does so won't be polymorphic in 's'
11:41:51 <hseg> kuribas: Yep
11:41:59 <merijn> kuribas: no, () is not a function
11:42:10 <merijn> kuribas: "fmap (\_ -> ())"
11:42:11 <kuribas> > :t fmap $ const ()
11:42:12 <lambdabot>  <hint>:1:1: parse error on input `:'
11:42:17 <kuribas> > :t fmap . const ()
11:42:18 <lambdabot>  <hint>:1:1: parse error on input `:'
11:42:21 <geekosaur> it's just :t
11:42:33 <geekosaur> "> " runs code, ":t" queries type
11:42:36 <kuribas> :t fmap . const ()
11:42:37 <lambdabot>     Couldn't match expected type `a0 -> b0' with actual type `()'
11:42:37 <lambdabot>     In the first argument of `const', namely `()'
11:42:37 <lambdabot>     In the second argument of `(.)', namely `const ()'
11:42:40 <geekosaur> don't combine them, because :t is not valid code
11:42:40 <hseg> kuribas: Sorry for my too-quick acceptance.
11:42:59 <merijn> hseg: So when you try to run an ST action that uses an STRef from an older ST action, it will result in a type error! (monomorphic 's' can never match the polymorphic "forall s . ST s a")
11:43:05 <kuribas> hseg: lol
11:43:38 <merijn> hseg: Well, that's not entirely true, you can still pass an STRef to an ST action and have it work, but only if you never read the inside of that STRef
11:43:39 <kuribas> :t fmap $ const ()
11:43:40 <lambdabot> Functor f => f a -> f ()
11:43:49 <kuribas> hseg: my mistake :)
11:44:22 <hseg> merijn: So let me get this straight. Basically, the only way to obtain an STRef is by combining the given functions. This means that the STRef's s parameter is some concrete, monomorphic type.
11:44:32 <merijn> hseg: "readSTRef :: STRef s a -> ST s a" <- if the 's' of the STRef isn't polymorphic, then the 's' of the resulting ST action won't be polymorphic, so passing it to runST is a type error
11:45:18 <merijn> hseg: You can think of it as "runST" passing a "unique" key to an ST action and any STRef/mutable ST action that is returned from running an ST action uses *that* specific key
11:45:30 <merijn> hseg: However, "runST" only accepts actions that work with *any* key
11:45:47 <merijn> hseg: Except that all this happens at the type level, so there's no runtime overhead
11:46:57 <hseg> merijn: Basically, the only way to obtain a bare STRef is using some expression that uses runST. Except that would make the s parameter of the STRef monomorphic, which means that any expression using it would also be monomorphic in s, meaning one can't pass *that* expression to runST.
11:47:13 <merijn> hseg: Yes
11:47:29 <merijn> hseg: Well, you can, but any read's on it will return the wrong "ST s" type :)
11:47:57 <merijn> hseg: So while you can pass STRef/ST action to another, you just can't actually *read* them
11:48:13 <merijn> or run them, for that matter
11:48:48 <merijn> And if you can't read/run them, you know for sure you can't perceive any "leaked" mutable state
11:49:07 <hseg> merijn: So while let r = runST newSTRef in r typechecks and is valid Haskell, you can't do anything with r because it's monomorphic now, and there are no functions that work on bare STRefs with a monomorphic s.
11:49:26 <merijn> hseg: Yeah
11:50:16 <aristid> :t runST
11:50:17 <lambdabot> (forall s. ST s a) -> a
11:50:23 <merijn> hseg: Well, "readSTRef :: STRef s a -> ST s a", so that works, but it returns an ST action with a monomorphic 's', which (due to the monad being "ST s") makes the entire resulting ST action monomorphic
11:50:24 <aristid> magic
11:50:33 <merijn> hseg: And monomorphic ST actions can't be run by runST :)
11:50:47 <uiop> :t unsafeCoerce runST :: ST s a -> a
11:50:48 <lambdabot> Not in scope: `unsafeCoerce'
11:51:41 <hseg> merijn: Thus far, I understand. However, in State in Haskell, SPJ says: "Now in order to apply runST we have to be able to generalise the type of readVar v with respect to s, but we cannot as s is free in the type environment: readVar v simply does not have type forall s. ST s Bool"
11:51:45 * hackagebot happstack-authenticate 0.10.11 - Happstack Authentication Library  http://hackage.haskell.org/package/happstack-authenticate-0.10.11 (JeremyShaw)
11:51:46 <merijn> hseg: Same way you can have "foo >> bar" if "foo :: State Int ()" and "bar :: State Char ()"
11:51:59 <hseg> merijn: And this is the point that I don't understand.
11:52:07 <merijn> hseg: Right, that's just what I was just explaining :)
11:52:45 <hseg> merijn: Again, I understand the idea. I'd like to understand the magic jargon.
11:53:19 <hseg> merijn: Also, WTF? (foo :: State Int ()) >> (bar :: State Char ()) typechecks?!
11:53:21 <merijn> hseg: "generalise the type of readVar with respect to s" <- we want the type to work for *any* 's', not just 1 specific one
11:53:28 <merijn> hseg: No, it doesn't
11:53:34 <merijn> hseg: I meant "can't" xD
11:53:41 <merijn> But I can't type
11:53:46 <uiop> :t (undefined :: ST s a -> a) :: (forall s. ST s a) -> a
11:53:46 <lambdabot>     Couldn't match type `ST s0 a' with `forall s. ST s a'
11:53:47 <lambdabot>     Expected type: (forall s. ST s a) -> a
11:53:47 <lambdabot>       Actual type: ST s0 a -> a
11:53:52 <hseg> merijn: xD. We all can't.
11:54:09 <merijn> hseg: "but we cannot as 's' is free in the type environment" <- 's' is coming from somewhere else
11:54:28 <merijn> hseg: "readVar v simply does not have typ forall s. ST s Bool" <- should be obvious now
11:55:20 <hseg> merijn: So when he says "generalise the type of foo w.r.t. s" he basically means "try to unify foo's type with a type that's polymorphic in s"?
11:55:31 <merijn> hseg: Yes
11:55:34 <hseg> merijn: Why is that called generalisation?
11:55:54 <_sebastian_> hi all, are there any limitations to autmatically deriving functor? it looks like it's not decending into the tree
11:56:10 <shachaf> Yes, there are limitations.
11:56:42 <_sebastian_> shachaf: is there a documentation?
11:57:03 <merijn> hseg: tbh, I'm not really sure about etymology
11:57:40 <shachaf> I don't know.
11:57:58 <merijn> I'm not even sure my explanation is technically correct, I understand what is happening and think you got what I meant. But I'm not convinced all the terminology I used to get the point across is right :)
11:58:35 <shachaf> (If you describe your problem maybe someone here will know.)
11:58:57 <merijn> hseg: I wouldn't worry too much and keep reading
11:59:16 <merijn> hseg: If I insisted understanding every nuance of papers I read I'd never get anything done >.>
11:59:37 <hseg> merijn: OK. So basically, you explained the intuitive meaning of ST, but you don't know the technical machinery. I guess I should go search for some type theory.
12:00:05 <merijn> I know the technical machinery, just not sufficiently to be sure I can explain it correctly :)
12:00:21 <hseg> merijn: And I'd agree with you in general, except here, where this nuance is the main reason I'm reading the paper.
12:00:23 <c_wraith> I can explain ST's type machinery
12:00:26 <c_wraith> Usually. :)
12:00:27 <hseg> merijn: OK.
12:00:36 <hseg> c_wraith: Hit me, please?
12:00:42 <uiop> :t let {runST :: (forall s. ST s a) -> a; runST x = (undefined::ST s a -> a) x} in runST
12:00:43 <lambdabot> (forall s. ST s a) -> a
12:01:20 <c_wraith> hseg: So, there are two important parts.  One, there's a phantom type parameter s in the definition of ST, and in the definition of everything mutable in ST
12:01:35 <hseg> c_wraith: OK.
12:01:43 <c_wraith> hseg: all the type signatures ensure that the s in ST and the ST in STRef/STArray/Whatever are all the same s
12:01:46 * hackagebot rollbar 0.2.2 - error tracking through rollbar.com  http://hackage.haskell.org/package/rollbar-0.2.2 (GregWeber)
12:02:32 <hseg> c_wraith: So basically, the combinators enforce the equality of the s's in all the components of an expression in ST?
12:02:38 <c_wraith> hseg: yes
12:02:45 <uiop> :t runST $ return ()
12:02:45 <lambdabot> ()
12:02:50 <uiop> :t runST `id` return ()
12:02:51 <lambdabot>     Couldn't match expected type `forall s. ST s a0'
12:02:51 <lambdabot>                 with actual type `m0 ()'
12:02:51 <lambdabot>     In the return type of a call of `return'
12:03:01 * uiop mumbles hack :)
12:03:30 <c_wraith> hseg: so then comes the second part, the type of runST.  It demands that the expression it's operating on be polymorphic in s
12:03:39 <c_wraith> hseg: that is, no part of it can depend on the type of s
12:03:52 <c_wraith> hseg: but the result type doesn't mention s
12:04:33 <c_wraith> hseg: So if you tried to leak an STRef, the expression would have a type like ST s (STRef s Int)
12:04:49 <c_wraith> hseg: and there's no way to unify that type with (forall s. ST s a)
12:05:05 <knz> levi: re your earlier answer, yes I have written other pieces where I was specifically using the word "GHC's Haskell" to clarify "with extensions" and "a particular run-time system". And I am frustrated that many articles on line use simply "Haskell" when they really mean GHC's.
12:05:07 <knz> k00mi: thanks for the clarification.
12:05:18 <hseg> c_wraith: No. runST newSTRef typechecks.
12:05:49 <cschneid> what coersion happens with:   x = 1 % 2; x < 1 --> true.  How does 1 turn into a ratio
12:06:05 <carter>  % is the ratio builder
12:06:08 <cdk> cschneid: fromIntegral, from the Num typeclass
12:06:15 <carter> right?
12:06:18 <carter> :t (%)
12:06:19 <lambdabot> Integral a => a -> a -> Ratio a
12:06:19 <hseg> c_wraith: You *can* leak an STRef. It's just that you can't use it, because any expression you construct with the leaked STRef is coerced to only work with the s from the leaked STRef.
12:06:24 <cdk> :i Num
12:06:26 <geekosaur> carter, he's asking about the 1 in < 1
12:06:29 <carter> oh
12:06:30 <c_wraith> :t runST (newSTRef ())
12:06:30 <carter> ok
12:06:31 <lambdabot>     Couldn't match type `a' with `STRef s ()'
12:06:31 <lambdabot>       `a' is a rigid type variable bound by
12:06:31 <lambdabot>           the inferred type of it :: a at Top level
12:06:38 <c_wraith> hseg: doesn't look like it typechecks to me
12:06:47 <cschneid> cdk: it automatically does fromIntegral for me there? is that how the literal 1 is coerced into "something that works" in the expression
12:06:48 <cdk> cschneid: fromInteger, rather
12:06:56 <cschneid> sure
12:06:57 <cdk> yes
12:07:04 <hseg> c_wraith: OK. Then my understanding of runST is still broken.
12:07:04 <cschneid> a literal 1 is :: Num, yes?
12:07:29 <cdk> if the type is not constrained in any way, yes
12:07:30 <_sebastian_> shachaf: thanks, it was my fault
12:07:37 <geekosaur> cschneid, http://www.haskell.org/onlinereport/haskell2010/haskellch6.html#x13-1360006.4.1
12:07:44 <c_wraith> hseg: the important part is that the s is required to be polymoprhic, but the a is required be specified by caller.
12:07:46 <cdk> i think you can specify what you'd like numeric literals to default to
12:07:56 <c_wraith> hseg: how familiar are you with Rank 2 types, in general?
12:08:02 <geekosaur> not exactly
12:08:02 <uiop> > 1 :: Rational
12:08:03 <lambdabot>  1 % 1
12:08:24 <cschneid> ohh! I see, I tried:
12:08:27 <cschneid> > 1 :: Ratio
12:08:28 <lambdabot>  Expecting one more argument to `GHC.Real.Ratio'
12:08:32 <cschneid> which it sure didn't like
12:08:37 <geekosaur> Ratio is not a type
12:08:39 <uiop> > fromInteger (1 :: Integer) :: Rational
12:08:40 <lambdabot>  1 % 1
12:08:43 <geekosaur> Rational is a type
12:08:46 <aristid> > 1 :: Ratio Int
12:08:47 <lambdabot>  1 % 1
12:08:53 <hseg> c_wraith: I understand the general idea of Rank N types. You basically are allowed to specify the precise scope of all the quantifiers of the type variables in your expression.
12:08:56 <geekosaur> Ratio is a type constructor; Rational is a type alias for Ratio Integer
12:09:11 <cschneid> ohh, I see.
12:09:13 <aristid> so what's the generic name for something of kind * -> *?
12:09:27 <cdk> aristid: higher-kinded type
12:09:29 <c_wraith> hseg: there's kind of a game-theory interpretation as well.
12:09:36 <uiop> :t [0::Rational, 0::Ratio Integer
12:09:36 <lambdabot>     parse error (possibly incorrect indentation or mismatched brackets)
12:09:38 <cschneid> it's like the diff between Maybe a and Maybe Int. Thanks.
12:09:39 <uiop> :t [0::Rational, 0::Ratio Integer]
12:09:40 <lambdabot> [Rational]
12:09:43 <simon> c_wraith, what's that?
12:09:50 <shachaf> Understanding rank-n types means understanding what it means to have a non-outermost quantifier.
12:10:09 <shachaf> Anyway, the thing that c_wraith is about to say is one of the reasonable ways to think about it. So listen to c_wraith.
12:10:37 <c_wraith> hseg: one way of interpreting it is "who gets to choose what concrete type the type variable has?"
12:10:38 <hseg> Yes, shachaf. (meekly)
12:11:04 <c_wraith> hseg: With normal rank-1 types, the caller gets to choose what all the type variables refer to.
12:11:27 <hseg> c_wraith: OK. So if the quantifier is outermost, then the caller gets to choose, whereas if it's not, the callee gets to choose - and more than once, on top of that?
12:12:09 <c_wraith> hseg: it's trickier than that, when you start nesting foralls deeper, but that's the right intuition to start with.
12:12:41 <cschneid> can fromInteger ever crash? Is there  something to give it that causes an undefined? (for any of the common impls)
12:13:06 <c_wraith> hseg: so, in the type (forall s. ST s a) -> a, the type a is chosen by the caller of runST.  The type s, however, is up to runST to pick.
12:13:12 <hseg> c_wraith: Basically, functions with type parameters can be seen as receiving an additional parameter that determines the type of that parameter.
12:13:50 <cdk> hseg: thats actually exactly what happens in GHC Core (System FC), it uses explicit type application
12:13:54 <c_wraith> hseg: so the caller doesn't know enough to pick a type a that will contain whatever type s runST chooses.  (nevermind that runST never actually chooses anything - the type says it *can*, so the restriction is respected)
12:14:25 <fizbin> Hey, anyone using MonadError: do you find the need to make hierarchical custom Error types? If so, how do you tend to manage them?
12:15:21 <hseg> c_wraith: Basically, what you're saying is that runST :: forall. a (forall s. ST s a) -> a, and therefore: 1) since the a is on the caller side, it must be computible with the caller's data 2) since the s is on the callee's side, the parameter must be polymorphic in s?
12:15:32 <fizbin> My instinct is to attempt to model an Error hierarchy similar to the one I might build in java or in python, but I don't know if that's a good idea with MonadError
12:15:36 <c_wraith> hseg: yes.  Does that make sense to you?
12:16:21 <hseg> c_wraith: Yes. Now all that remains to be understood is the jargon SPJ uses, but that is less important.
12:16:51 <hseg> c_wraith: At least with this knowledge I can understand, more or less, how the reflection package works.
12:17:20 <uiop> hseg: it's similar to subtyping and function types: (A->B)<=(C->D)<==>(C<=A)&&(B<=D). so, if A:=Int, B:={n::Int|odd n}, then b<=a and (a->())<=(b->())
12:17:31 <uiop> err, hit enter by accident
12:17:46 <uiop> ... then B<=A and (A->())<=(B->())
12:18:08 <uiop> so s/subtyping/subsumption/
12:18:30 <c_wraith> hseg: there is one additional thing.  There are tricks that allow leaking STRefs out of ST.
12:18:42 <shachaf> runST always chooses the same s.
12:18:44 <uiop> ()->() <= (forall a.a)->()
12:18:44 <c_wraith> hseg: You can use an existential to quantify over the type variable s, so it never shows up in the type a, for instance.
12:18:45 <hseg> uiop: That makes sense... I'm unsure what you mean precisely by subtyping/subsumption, so all I can say is that it makes intuitive sense.
12:18:46 <shachaf> But you don't know that.
12:19:35 <c_wraith> hseg: fortunately, that doesn't break ST either.  Because if you try to *use* the STRef, you'll find that you can't make it work with any of the combinators
12:19:44 <uiop> hseg: (a <=_subsumption b) <==> (_::a)::b
12:20:10 <c_wraith> hseg: since they all enforce that ST s and STRef s have the same s..  It can't prove than an STRef that just came out of an existential has the same s as ST does
12:20:22 <nstdloop> I just noticed there's an update for the CLI on mavericks (5.1.0.0) - before I update, do we know if that breaks anything?
12:20:22 <c_wraith> hseg: and so you still get a type error.
12:20:29 <uiop> hseg: (a <=_subtype b) <==> (f_ab(_)::a)::b
12:20:55 <uiop> or something-ish
12:21:34 <hseg> uiop: so a subsumes b if all x :: a is also :: b, and a subtypes b if there is a map a -> b?
12:22:39 <uiop> id <= take 1
12:22:39 <uiop> :t [id,take 1]
12:22:39 <lambdabot> [[a] -> [a]]
12:23:01 <hseg> c_wraith: Wait. Given a value of type (forall s. STRef s Int), why can't I apply it to readSTRef :: STRef s a -> ST s a?
12:23:49 <c_wraith> hseg: It's not actually (forall s. STRef s Int)
12:24:06 <uiop> hseg: something like that. for instance in C++ (multiple-inheritance), to cast go from a subtype to a supertype you need to in the general case add an offset to the (ptr to the) subtype to get the base ptr of the supertype
12:24:10 <hseg> c_wraith: Why not?
12:24:10 <c_wraith> hseg: it's actually (exists s. STRef s Int), if it's come out of unpacking an existential.
12:24:30 <c_wraith> hseg: that is, the type of s was lost when it was put in the existential wrapper.
12:24:43 <uiop> hseg: so abstracting that, you in the general case need to apply some function to pass from subtype to super type
12:24:50 <c_wraith> hseg: so all the type systems knows is that there's *some* type s.  But it doesn't know what type it is, so it doesn't let you unify it with anything.
12:25:23 <hseg> c_wraith: Right. All you know is that s was somehow used to construct the STRef. With no other constraints on s, you can't apply it to anything.
12:25:30 <uiop> hseg: whereas with polymorphism, "it's all in the type"
12:25:50 <hseg> uiop: I'm not sure I follow.
12:26:49 <uiop> :t (id::a->a, id::[a]->[a], id::[[a]]->[[a]])
12:26:50 <lambdabot> (a -> a, [a1] -> [a1], [[a2]] -> [[a2]])
12:27:20 <uiop> each one of those is the exact same value (the value of the function id)
12:28:08 <hseg> uiop: Right. And you ordered the from most general to least general. Or from supertype to subtype
12:28:20 <MrRacoon> a/win 17
12:28:25 <uiop> hseg: right
12:29:49 <hseg> uiop: So basically, a subtype of some polymorphic type is a type constructed by assigning some type to each of its type parameters?
12:30:01 <uiop> hseg: err, the subtyping <= goes the opposite way as the subsumption <= (in a sense)
12:30:17 <hseg> uiop: Right.
12:30:29 <uiop> but that's just the convention directions of those definition of each (<=)
12:31:12 <uiop> (which is the more confusing way for them to be from our conversation's point of view)
12:32:09 <uiop> (at least imo)
12:32:46 <Shammah> hmm... Data.Map is actually mostly O(log n), interesting ...
12:33:12 <c_wraith> Shammah: it's a balanced binary tree.  Isn't that what it should be?
12:33:22 <c_wraith> well.  near-balanced binary tree.
12:33:25 <Shammah> I was expecting a hashmap really
12:33:26 <[swift]_> so is there a runtime cost to passing a constructorless datatype (say "Proxy t") to a function?
12:33:47 <c_wraith> Shammah: then use the unordered-containers package.
12:33:48 <Shammah> Oh, there's Data.HashMap in unordered-containers
12:33:49 <adimit> [swift]_: no. Erasure.
12:33:53 <uiop> err, strike that. the confusing part is that we say "*more* general than" but we use "<=" (sometimes people pull a fast one and "flip (<=)")
12:34:12 <c_wraith> Shammah: Data.HashMap uses a HAMT, though.  Still not an array. :)
12:34:26 <[swift]_> adimit: nice. that makes me feel better about using that pattern
12:34:55 <adimit> [swift]_: it's a purely type-level construct. I don't know if phantom types count as a pattern, though. I guess.
12:35:02 <elricl> Is there anyway to dervive generic typeclass for types described using persistent ?
12:35:29 <c_wraith> Shammah: the HAMT has a history of performing really well for persistent hashed structures in Clojure, so Data.HashMap decided to use it.
12:35:34 <Shammah> c_wraith, so there is not a HashMap which has (nearly) insertion and lookup time of O(1)?
12:35:49 <[swift]_> adimit: well, i use phantom types a lot, but generally in situations where i actually do have values and i just want to add a type-level tag to them
12:36:02 <[swift]_> adimit: this case, where there's no value at all and only the type-level tag, is new for me
12:36:13 <adimit> c_wraith: Data.HashMap in the form of tibbe.
12:36:43 <Shammah> because even inserting in Data.HashMap takes O(log n)
12:36:49 <c_wraith> Shammah: O(1) is mathematically impossible for a couple of reasons that people never actually talk about.  But yes, there are array-backed mutable hash maps in a couple packages.  They require working in IO or ST, though.
12:36:50 * hackagebot hsini 0.3 - Package for user configuration files (INI)  http://hackage.haskell.org/package/hsini-0.3 (MagnusTherning)
12:36:52 * hackagebot shelly 1.5 - shell-like (systems) programming in Haskell  http://hackage.haskell.org/package/shelly-1.5 (GregWeber)
12:37:00 <Shammah> ah
12:37:24 <Shammah> well, that's true, that's why I said 'nearly' O(1)
12:37:26 <adimit> [swift]_: you might wanna look at DataKinds (specifically, type-level strings, i.e. Prolog atoms) or GADTs.
12:37:37 <c_wraith> Shammah: http://hackage.haskell.org/package/hashtables for instance
12:38:14 <[swift]_> adimit: i do use GADTs some but i've never experimented with DataKinds. i'll look into them
12:38:18 <Shammah> ah I see
12:38:43 <Shammah> This is way more complex than I initially thought ...
12:39:53 <adimit> [swift]_: Type-level strings basically makes EmptyDataDecl obsolete. I prefer using them over constructorless data decls, because it's clear from a look at the signature that the type isn't inhabited.
12:40:13 <c_wraith> Shammah: about 95% of the time, the performance difference doesn't matter enough to make it worth using the more complicated interfaces.
12:40:25 <[swift]_> adimit: that sounds pretty good!
12:40:42 <c_wraith> Shammah: and just using a persistent tree-based structure is fast enough that it's not the slow part.
12:41:14 <Shammah> Well I'm not running into any performance problems, just theorizing here a bit
12:41:19 <adimit> THen again, so few people know about it that they might be confused by the sudden appearance of strings in signatures. I know most Haskell "parsers" and "code highlighters" still are.
12:42:23 <Exabina> test
12:48:02 <uiop> Shammah: Data.Map has huge fanout since everything's boxed, as well as needs to call (<=),etc via function pointer (Ord instance). O(lg n) but the constant looms large
12:51:13 <adimit> Yeah, Data.Map is really only for stuff where you're too lazy to write a Hashable instance for the key, and you're sure it won't matter performance-wise. (Hint: it *will* matter later on.)
12:51:52 * hackagebot hsini 0.3.1 - Package for user configuration files (INI)  http://hackage.haskell.org/package/hsini-0.3.1 (MagnusTherning)
12:52:29 <zhasha> Suppose I have some blaze Html and I want to locate certain elements and replace them. How would I best go about this?
12:56:02 <levi> Blaze HTML isn't really designed for transformation. Do you have the option of using another high-level representation for your document?
12:58:18 <zhasha> levi: I have some Text that I currently turn into Blaze Html, so all doors are basically open (I think)
12:58:30 <zhasha> It just has to end up as Blaze Html
13:01:05 <nadirs> zhasha: if the Text contains HTML you might use something from xml-conduit
13:01:31 <nadirs> (I never used it, I've just found it on hackage)
13:01:53 * hackagebot shelly 1.5.0.1 - shell-like (systems) programming in Haskell  http://hackage.haskell.org/package/shelly-1.5.0.1 (GregWeber)
13:05:17 <levi> Snap's xmlhtml library has some document manipulation tools; it renders to Text.Blaze directly rather than to Text.Blaze.HTML, though.
13:08:21 <zoooobap> can you add strictness decorations to a record-syntax data type?
13:08:48 <bennofs> zoooobap: yes, but sometimes you need parentheses
13:08:51 <zoooobap> it works in this case "data Foo = Foo { goop :: !Int }"
13:09:03 <zoooobap> bennofs: ah, okay... ill try with parens .. my case had a maybe
13:09:11 <bennofs> zoooobap: data Foo = Foo { goop :: !(Maybe Int) }
13:09:30 <zhasha> levi: I'm writing something with Yesod
13:09:43 <acowley> Isn't there a package somewhere with some TH to generate instances based on an isomorphism between your type and another type that has the required instance?
13:09:44 <zhasha> Also I'm new at this
13:09:53 <bitemyapp> bennofs: how many bytes extra are tagged unions?
13:10:02 <bitemyapp> just happened to wonder because of the bang pattern.
13:10:03 <bennofs> bitemyapp: ?
13:10:23 <bennofs> I don't know :)
13:10:36 <fizbin> What's the relationship between the hackage packages test-framework and HTF?
13:11:28 <bitemyapp> fizbin: I don't think you want to use test-framework.
13:11:42 <bitemyapp> fizbin: https://hackage.haskell.org/package/tasty
13:11:47 <bitemyapp> jfischoff: hello from Austin!
13:11:59 <bitemyapp> jfischoff: already got a couple coworkers tinkering with Haskell in their free time :)
13:12:03 <fizbin> Well I certainly don't want to use HTF, since I can't run htfpp in this IDE...
13:12:31 <bitemyapp> fizbin: take a look at Tasty. I don't know anything about IDEs, but it seems to be the preferred way to slap tests together lately.
13:12:39 <fizbin> Why would I use tasty over HUnit?
13:12:54 <bitemyapp> fizbin: you use HUnit *in* Tasty.
13:12:55 <bennofs> fizbin: you use tasty with HUnit
13:13:01 <bitemyapp> fizbin: Tasty replaces test-framework, not HUnit.
13:13:07 <fizbin> Huh.
13:13:20 <bitemyapp> I said, "you probably don't want to use test-framework" :)
13:14:26 <fizbin> Right, okay then. Why would I want to use tasty instead of test-framework?
13:14:52 <sm> tasty has a more recently active maintainer than test-framework
13:14:52 <bitemyapp> fizbin: nicer, better maintained.
13:14:54 <bennofs> fizbin: test-framework is not as actively maintained (is it even maintained?)
13:15:39 <fizbin> What's the lag time on updates to declare something "unmaintained"?
13:15:50 <fizbin> test-framework was updated six months ago.
13:16:14 <bitemyapp> fizbin: use both, make a judgment call.
13:16:20 <sm> yes, some would say tasty was hasty
13:16:22 <bennofs> fizbin: I'd rather define unmaintained based on PRs / number of open issues
13:16:36 <bitemyapp> fizbin: I don't think any of us are especially invested in you using anything in particular, I was just trying to toss you a friendly pointer. I'm not going to crusade on behalf of it.
13:17:10 <fizbin> Okay. But no one seems to think HTF is a particularly good idea.
13:17:13 <bitemyapp> I, personally, use Tasty. I didn't like test-framework as much. That's the best endorsement I can offer for something as boring as a test harness library.
13:17:14 <jfischoff> bitemyapp: oh hey, glad the trip worked out
13:17:36 <acowley> What was wrong with test-framework vs tasty? I thought they were pretty similar at this point.
13:17:36 <bitemyapp> jfischoff: yeah, having fun down here. I didn't realize when I moved that SXSW was coming up.
13:17:39 <fizbin> Which is totally something I can get behind. HTF looks like a neat idea that could easily totally fail to work.
13:17:51 <jfischoff> oh yeah that's cool
13:17:52 <bitemyapp> acowley: Tasty was a bit easier for my noob-butt to get rolling.
13:18:08 <acowley> bitemyapp: I've read about tasty but not seen anything that would improve my day to day
13:18:33 <jfischoff> acowley: better console output IMO
13:18:38 <acowley> But I'm not a fancy user of test-framework
13:18:40 <bitemyapp> ^^ yeah that was one of the things I liked.
13:18:59 <acowley> I think my uses are too boring to expose the differences
13:19:05 <jfischoff> test-framework would interleave the output
13:19:07 <bitemyapp> since my work-flow with Haskell is hybrid batch and interactive, and I don't like running tests in my REPL, having nice console output is important.
13:19:43 <acowley> When I run tests, I get colorized success/failure reports and identification of failed tests.
13:19:48 <acowley> I don't know enough to want more than that
13:20:33 <jfischoff> test-framework would just screw on me in ghci
13:20:42 <jfischoff> screw up
13:20:53 <acowley> oh!
13:20:55 <jfischoff> they are basically the same
13:20:59 <acowley> Yes
13:21:03 <acowley> I did see that
13:21:27 <acowley> I run my test suite from the command line, but do ad hoc testing in the repl
13:21:39 <jfischoff> cmd line works
13:22:12 <acowley> Well, good to know that that issue works better with tasty
13:22:38 <jfischoff> at work we have 1000's of tests that are run with runhaskell (I'm not exactly sure why) and it was quite a nuisance
13:23:06 <bitemyapp> wat @ runhaskell
13:23:35 <jfischoff> bitemyapp: non interactive version of ghci
13:23:53 <zoooobap> bennofs: thanks! the strictness annotations helped me to identify and remove the leak!
13:24:35 <troydm> so i want to have hash table in my code
13:24:46 <troydm> Data.Hashtable says it's depricated
13:24:52 <troydm> what should i use?
13:24:57 <bitemyapp> jfischoff: I know. Just surprised that works for your tests.
13:25:04 <bitemyapp> 'tis a good thing though.
13:25:07 <jfischoff> ah
13:25:08 <geekosaur> troydm, look at the unordered-containers package
13:25:22 <bitemyapp> troydm: do you want Ord or not?
13:25:31 <acowley> writing out instances by hand is ridiculous
13:25:38 <troydm> bitemyapp: no i don't need Ord
13:25:47 <troydm> geekosaur: ic, thx
13:25:49 <bitemyapp> troydm: yeah, unordered-containers is the way to go then.
13:30:28 <troydm> why isn't Text Hashable?
13:31:10 <troydm> ohh wait it is
13:31:19 <troydm> sorry
13:32:44 <Kron> > (f . g) x
13:32:46 <lambdabot>  Could not deduce (Debug.SimpleReflect.Expr.FromExpr b0)
13:32:46 <lambdabot>    arising from a use of `Debug.SimpleReflect.Vars.g'
13:32:46 <lambdabot>  from the context (Debug.SimpleReflect.Expr.FromExpr c)
13:32:46 <lambdabot>    bound by the inferred type of
13:32:46 <lambdabot>             it :: Debug.SimpleReflect.Expr.FromExpr c => c
13:32:57 <Kron> hmmm, how far can lambdabot compute?
13:33:06 <troydm> :i Text
13:33:08 <Kron> I know she was doing pretty complex foldr expansions earlier
13:33:45 <tdammers> lambdabot is a fembot?
13:34:06 <narendraj9__> print [1..10]
13:34:17 <Kron> > print [1..10]
13:34:18 <lambdabot>  <IO ()>
13:34:28 <narendraj9__> lambdabot, print [1..10]
13:34:29 <manja> @pl (\ k _ -> length k > limit)
13:34:29 <lambdabot> const . (> limit) . length
13:34:45 <narendraj9__> > print [1..10]
13:34:46 <lambdabot>  <IO ()>
13:34:54 <narendraj9__> > print [1..]
13:34:55 <lambdabot>  <IO ()>
13:37:53 <Kneiva> > [1..]
13:37:54 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
13:40:08 <Soft> hmm I would like to express something like type RandomState = RandomGen g => State g; How should I approach this?
13:40:43 <Soft> or is that even something that would make any sense
13:42:21 <statusfailed> Does Control.Concurrent.Chan have CSP's choice operator?
13:42:27 <statusfailed> what I think is 'select' in unix sockets?
13:42:51 <statusfailed> or at least... the general 'wait for a message on n channels and respond to the first'
13:42:58 <pranz> Soft: ConstraintKinds extension allows such types
13:44:26 <bitemyapp> statusfailed: bub, go up a level.
13:44:29 <bitemyapp> statusfailed: https://hackage.haskell.org/package/async-2.0.1.5/docs/Control-Concurrent-Async.html
13:44:52 <bitemyapp> statusfailed: c.c.c is probably lower level than you want. Use Async. Has the ability to select from a list.
13:44:56 <k00mi> Soft: what do you want to do?
13:44:59 <bitemyapp> statusfailed: have you seen marlow's book? it's really good.
13:45:14 <bitemyapp> statusfailed: http://chimera.labs.oreilly.com/books/1230000000929 read the book. It's great.
13:47:21 <Soft> k00mi: I used state monad to keep track of the random number generator so I dont have to do it manually. This works with stricter definition like type RandomState = State StdGen
13:49:36 <statusfailed> bitemyapp: Ha, looks good
13:49:48 <statusfailed> bitemyapp: no I haven't! thank you :)
13:50:25 <bitemyapp> statusfailed: marlow will get you sorted out, but yeah, as a general run, Chan/TChan is lower level than what you want.
13:50:28 <bitemyapp> general rule*
13:53:21 <acowley> So, anyone feel like writing some more example/test programs for concurrent-machines? I think it's full of bugs that need to be teased out.
13:53:59 <k00mi> Soft: you can do that with the RankNTypes extension
13:54:48 <k00mi> Soft: then you need an explicit forall, like this:
13:54:50 <k00mi> type RandState a = forall g. RandomGen g => State g a
13:55:25 <bennofs> acowley: what is concurrent-machines?
13:55:51 <uniquenick> is there a way to override cabal dependency constraints from the command line?  like I want to install something that insists it needs base==4.6.* even though it actually works with base 4.5 just fine
13:55:51 <acowley> bennofs: Small thing that runs compositions of machines concurrently
13:56:01 <acowley> bennofs: https://github.com/acowley/concurrent-machines
13:56:07 <acowley> bennofs: There's an example in the README there
13:56:31 <shepheb> is there a standard solution when I'm getting ambiguous instances and there's a clear choice of instance, that GHC even suggests? I'm not sure how to point it at that instance.
13:56:43 <acowley> My problem is that I'm not exercising much of the library in my own code, but I wanted to split it off from a larger code base
13:56:59 <Soft> k00mi: that's really cool, thanks
13:57:07 <acowley> shepheb: Why do you think the choice is clear?
13:57:25 <shepheb> acowley: for one thing, there's only one instance of this class anywhere.
13:57:26 <acowley> shepheb: There aren't many options here, unfortunately. The answer is almost always a newtype.
13:57:43 <acowley> They why are you using a typeclass?
13:57:55 <shepheb> there will be more, later.
13:58:02 <k00mi> shepheb: you should read up on how typeclass resolution works
13:58:23 <shepheb> the idea here is a general backend class, that can have multiple implementations.
13:58:38 <acowley> shepheb: Can you lpaste some code?
13:58:46 <raphie____> is there some sort of takeWhile that also passes in the previous element?
13:59:01 <shepheb> I suppose. it's heavily experimental, but I'll paste it.
13:59:49 <acowley> raphie____: You probably want to zip your list with its tail, then takeWhile that
14:00:55 <shepheb> http://lpaste.net/101036
14:01:24 <shepheb> it's possible I'm rediscovering some sort of library here - persistent jumps to mind, though it's seems a bit more bound to SQL-style backends.
14:03:07 <fizbin> This feels like it should be a stupid easy thing, but I can't figure it out: I had to add "undefined" bits in code that I know will never execute to get it to typecheck: http://lpaste.net/101037
14:03:24 <mindleyhilner> doesn't RankNTypes violate the H-M requirement that variable bindings in an abstraction be monotype?
14:03:29 <acowley> shepheb: What's the error message you're getting?
14:03:43 <shachaf> RankNTypes isn't Hindley-Milner-compatible.
14:04:06 <geekosaur> that sounds liek assertError has an unfortunate type
14:04:10 <geekosaur> :t error
14:04:11 <lambdabot> [Char] -> a
14:04:19 <mindleyhilner> shachaf: so that's a yes?
14:04:25 <fizbin> :t assertError
14:04:25 <lambdabot>     Not in scope: `assertError'
14:04:26 <lambdabot>     Perhaps you meant `userError' (imported from Prelude)
14:04:27 <acowley> Oh
14:04:34 <fizbin> :t assertFailure
14:04:35 <lambdabot> Not in scope: `assertFailure'
14:04:41 <shepheb> acowley: http://lpaste.net/101036
14:05:09 <acowley> Right
14:05:12 <fizbin> geekosaur: assertFailure comes from HUnit, and has type Assertion, which is a type alias to IO ()
14:05:15 <acowley> repeated type variables don't usually do what people want
14:05:49 <acowley> You might be able to give them distinct names in the instance, then add equality constraints
14:05:54 <fizbin> Rather, it has type String -> Assertion
14:08:32 <fizbin> It seems like assertFailure should have type (IO _|_), or possibly (forall a. IO a)
14:09:30 <bennofs> fizbin: do you mean IO Void?
14:09:53 <fizbin> bennofs: No.
14:10:02 <shachaf> You don't mean IO Void?
14:10:18 <shachaf> Then what is _|_-the-type?
14:13:19 <fizbin> If we view Haskell types as having a poset relation where (typeA) <= (typeB) whenever any expression of typeA can be used wherever an expression of typeB is required, then the type _|_ is the type that is <= every other type.
14:13:29 <fizbin> Rather, is <= every type.
14:13:55 <fizbin> I guess that type is probably better written as "a"
14:14:07 <shachaf> So when you say _|_ you mean (forall a. a)?
14:14:31 <fizbin> As a type, yeah. Well, maybe.
14:14:54 <verement> :t undefined
14:14:55 <lambdabot> a
14:15:11 <fizbin> By "IO _|_" I meant "A type that could be used wherever I needed a type of type (IO b), for all b"
14:15:42 <fizbin> I think (IO (forall a. a)) is different from (forall a. IO a)
14:16:10 <byorgey> yes, they are different
14:16:49 <byorgey> your description sounds exactly like  forall a. IO a
14:16:50 <shachaf> Well, they're isomorphic, arne't they?
14:16:57 <isaacbw> I just had a possible realization. Could someone tell me if it's correct? The usefulness of a monad is in providing an interface via a set of rules to enable do notation?
14:17:01 <fizbin> So anyway, geekosaur, I think you were right: assertFailure has an unfortunate type. It should have type (IO a)
14:17:55 <pantsman> isaacbw, monads would be useful even if there was no do-notation.
14:18:15 <byorgey> shachaf: I suppose you're right.  Though actually implementing the isomorphism would require ImpredicativeTypes or something like that.
14:18:23 <fizbin> isaacbw: In general, the usefulness of a class instance is in providing an interface. Instances of Monad also provide the convenience of do notation.
14:18:39 <shachaf> byorgey: Well, sure, IO (forall a. a) isn't even a thing in GHC.
14:18:46 <byorgey> ah, right.
14:19:17 <shachaf> But we can make a newtype Void = Void (forall a. a) and then say (forall a. IO a) ~~ IO Void
14:20:10 <byorgey> yes.
14:22:42 <fizbin> @type let f = undefined :: (IO Int) -> (IO Int), g = return undefined :: (IO a) in f g
14:22:43 <lambdabot> parse error on input `,'
14:22:57 <fizbin> @type let f = undefined :: (IO Int) -> (IO Int); g = return undefined :: (IO a) in f g
14:22:57 <lambdabot> IO Int
14:23:10 <fizbin> @type let f = undefined :: (IO Int) -> (IO Int); g = return undefined :: (IO Void) in f g
14:23:11 <lambdabot> Not in scope: type constructor or class `Void'
14:23:25 <Cale> isaacbw: The usefulness of the Monad class is not having to write all the stuff in Control.Monad and Data.Traversable and elsewhere which is parameterised over a choice of monad m, for each instance of Monad.
14:23:39 <fizbin> Huh. I thought lambdabot knew about Void.
14:24:03 <Cale> isaacbw: You could of course implement all that stuff (or more likely fragments of it) for each library which happened to be a monad, but the abstraction saves us that trouble.
14:24:10 <Cale> That's about all there is to it :)
14:24:39 <zdg> @pl \f a g -> f a + g a
14:24:39 <lambdabot> (`ap` flip id) . (((.) . (+)) .)
14:24:53 <zdg> @pl \f g a -> f a + g a
14:24:53 <lambdabot> liftM2 (+)
14:25:07 <shachaf> @let newtype Void = Void { absurd :: forall a. a }
14:25:08 <lambdabot>  Parse failed: TypeOperators is not enabled
14:25:23 <shachaf> Hmph.
14:29:24 <bennofs> oh, that's the same. Sorry
14:29:30 <shepheb> acowley: well, adding -XTypeFamilies, renaming one pair of k and a, and adding equality constraints on them got it to compile and work.
14:29:31 <shepheb> thanks for the help. it's a little frutrating that repeating the type variables didn't work, but this isn't a painful workaround.
14:29:33 <bennofs> fizbin: it is. fmap absurd and id can be used to convert between IO Void and forall a. IO a
14:29:49 <fizbin> :t absurd
14:29:50 <lambdabot> Not in scope: `absurd'
14:30:08 <Eduard_Munteanu> I just came in, but... _|_ for subtyping is different from the one that means undefined (which is usually what Haskellers mean).
14:31:25 <k00mi> IO a would be the type you want
14:31:26 <k00mi> so you don't have the hassle with returning undefined
14:31:26 <tibbe> Am I being completely dense, if I have "sumManyArrays :: [MArray] -> IO Int" and call it like so "print `fmap` sumManyArrays marrs" how could absolutely nothing get printed?
14:31:26 <tibbe> Changing it it:
14:31:26 <tibbe> total <- sumManyArrays marrs
14:31:26 <tibbe> print total
14:31:26 <tibbe> makes it work
14:31:26 <tibbe> :t fmap
14:31:26 <tibbe> @type fmap
14:31:26 <tibbe> lambdabot: why have you forsaken me?
14:31:27 <tibbe> I'm being stupid
14:31:27 <k00mi> tibbe: sumManyArrays marrs >>= print
14:31:27 <tibbe> yes
14:31:27 <tibbe> the fmap thing typechecks but doesn't mean something sensible
14:31:27 <lambdabot> Functor f => (a -> b) -> f a -> f b
14:31:27 <lambdabot> Functor f => (a -> b) -> f a -> f b
14:31:33 <tibbe> but I'm surprised IO () has a Show instance
14:31:37 <k00mi> it doesn't
14:31:37 <tibbe> k00mi: perhaps because I imported GHC.IO ?
14:31:38 <tibbe> k00mi: I didn't get a type error
14:31:45 <k00mi> are you using ghci?
14:32:03 * hackagebot hlint 1.8.58 - Source code suggestions  http://hackage.haskell.org/package/hlint-1.8.58 (NeilMitchell)
14:32:28 <fizbin> k00mi: But I can't exactly change HUnit. So I guess I need undefineds...
14:34:57 <zdg> @pl \f g h a -> f (h a) + g (h a)
14:34:57 <lambdabot> (. (.)) . ap . (liftM2 (+) .) . (.)
14:35:17 <zdg> @pl \h f g a -> f (h a) + g (h a)
14:35:17 <lambdabot> ap (flip . (((.) . liftM2 (+)) .) . flip (.)) (flip (.))
14:36:31 <mindleyhilner> what's the meaning of (forall a. a) -> b?
14:37:10 <quchen_> It's the type of a function that maps ⊥ to a value of some other type (which does not exist).
14:37:19 <fizruk> :t (+) `on` ($ ?h ?a)
14:37:20 <lambdabot> (Num c, ?h::t -> a, ?a::t) => (a -> c) -> (a -> c) -> c
14:37:59 <mindleyhilner> quchen_: what about \x -> undefined?
14:38:02 <quchen_> mindleyhilner: Well, the function exists in Haskell, it's called `absurd` (from Data.Void). But in theory, it's equivalent to "False implies everything"
14:38:10 <shachaf> I wish people only used _|_ to mean the (least-defined) value.
14:38:36 <shachaf> Yes, you can make a preorder of types if you want to. But it's just ambiguous and usually confusing.
14:39:04 <mindleyhilner> \x -> undefined is a -> b, which is somehow different from (forall a. a) -> b, but i can't feel what the second one means
14:39:29 <quchen_> "quchen, you should better call it the uninhabited type because …" -- "thanks shachaf for your constructive answer"
14:41:17 <jesyspa> mindleyhilner: I think it has to do with where the instantiation happens.  When you have forall a. (a -> X), the caller gets to decide what a is.  When you have (forall a. a) -> X, the caller must provide something that can be instantiated to anything within the function.
14:44:08 <mindleyhilner> jesyspa: that's a handy way to think of it, thanks
14:44:16 <mindleyhilner> of rank N poly, actually
14:45:16 <mindleyhilner> :t (\x -> undefined)
14:45:17 <lambdabot> t -> a
14:45:26 <mindleyhilner> :t (\x -> undefined) :: (forall a. a) -> b
14:45:27 <lambdabot> (forall a. a) -> b
14:45:33 <mindleyhilner> :t ((\x -> undefined) :: (forall a. a) -> b) undefined
14:45:33 <lambdabot> b
14:46:03 <Guest24988> Is there a way to provide default options to GHC, say in a configuration file?
14:46:23 <milfjord> wrapper script
14:46:38 <Guest24988> :(
14:46:42 <mindleyhilner> quchen_: so in calling (forall a. a) -> b absurd, we're ignoring the trivial case where undefined inhabits everything?
14:47:22 <Guest24988> I'm trying to come up with a way to enforce a Safe Haskell policy.
14:51:23 <Guest24988> mindleyhilner: (forall a. a) -> b  ~  (forall a. a) -> (forall a. a)  and it's not absurd in itself
14:51:24 <quchen_> mindleyhilner: Well, you can create a value of any type in Haskell. Absurd is called absurd because there can't possibly be a meaningful implementation, and using absurd on a value in actual code signals that this piece of code should never be evaluated (and the type checker can verify this claim, given a non-evil implementor).
14:52:14 <quchen_> mindleyhilner: For example there are values involving the empty type in the Pipes library. It guarantees that certain pipes can only send, and never receive, data.
14:57:18 <quchen_> Or an easier example, suppose you have a function that for some reason generates only Right values of type "Either X Y". How can you guarantee that there won't be a Left case, ever? Well, set X=Void, so your function maps to "Either Void Y". Whenever you pattern match the result of this function, handle the never-happening case with "absurd" to close off the "Void"-typed end: "case foobar of { Right r -> doStuff r; Left l -> absurd l }". T
14:57:19 <quchen_> he thing will be well-typed, there won't be a non-exhaustive pattern warning.
14:59:48 <Eduard_Munteanu> As a sidenote, IIRC GHC 7.8 will have absurd patterns.
15:02:22 <quchen_> Eduard_Munteanu: Got a reference? The only ticket I can find is #3483 and it's abandoned.
15:03:34 <joelteon> Anybody experienced with the machines package? I don't know how to connect two machines together.
15:03:50 <c_wraith> joelteon: machines or plans?
15:04:07 <joelteon> which ones can you connect?
15:04:30 <ion> eduard_munteanu: Cool. What syntax does it use?
15:04:53 <Eduard_Munteanu> I'm looking it up, I hope it wasn't a false "alarm".
15:06:30 <quchen_> Eduard_Munteanu: Maybe it's somehow contained in pattern synonyms?
15:07:13 <Eduard_Munteanu> It might have been this one ... https://ghc.haskell.org/trac/ghc/ticket/2431   (EmptyCase)
15:09:27 <quchen_> Eduard_Munteanu: Indeed, it's in the 7.8 changelog
15:09:30 <quchen_> http://www.haskell.org/ghc/docs/7.8.1-rc2/html/users_guide/release-7-8-1.html
15:09:35 <quchen_> Search for "EmptyCase"
15:09:52 <Eduard_Munteanu> Ah.
15:09:55 <Eduard_Munteanu> ion: ^^
15:10:15 <ion> Thanks. I suppose an empty case expression is *required* and a type signature without a binding is not okay?
15:10:54 <Eduard_Munteanu> I would expect that, yes, as in Agda.
15:11:39 <quchen_> How is EmptyCase better than `absurd` though?
15:12:03 <Eduard_Munteanu> Generally absurd patterns are checked on a per-parameter basis.
15:13:09 <Eduard_Munteanu> quchen_: what type would 'absurd' have? I can't think of any definition that makes a compiler check arbitrary types are indeed empty.
15:13:52 <quchen_> Eduard_Munteanu: Ah right, EmptyCase is polymorphic over the "sort of Void".
15:14:44 <quchen_> Polymorphic probably isn't the right word. I meant that EmptyCase works on any empty type, not just Void (and absurd is only for that).
15:15:07 <uiop> Eduard_Munteanu: if you mediate upon the zen of gcc's __builtin_unreachable(), the answer may be reached
15:15:15 <Eduard_Munteanu> quchen_: yeah... it should also be checked it is indeed empty
15:15:25 <Eduard_Munteanu> Hehe.
15:15:39 <Eduard_Munteanu> __attribute__((pure)) FTW :P
15:16:04 <quchen_> Eduard_Munteanu: Hmm?
15:16:05 <Eduard_Munteanu> (that's not checked at all, btw)
15:16:24 <uiop> a student of the buddha
15:16:33 <quchen_> Oh, I missed uiop's comment above, nevermind.
15:17:30 <Eduard_Munteanu> quchen_: consider  data (==) :: k -> k -> * where Refl :: a == a   and   theorem :: 3 == 4 -> 7 == 8
15:18:33 <Eduard_Munteanu> The compiler should validate the proof of 'theorem', not just trust you 3 == 4 is empty.
15:21:03 <quchen_> I like that example.
15:26:21 <Eduard_Munteanu> "In GHC 7.10, Applicative will become a superclass of Monad" -- this one is a tad bit dubious from a purely theoretically POV
15:26:36 <johnw> how so?
15:26:48 <uiop> zen is thus:
15:26:51 <uiop> <uiop> ,cc __builtin_unreachable();
15:26:52 <uiop> <candide> uiop: Program received signal SIGSEGV, Segmentation fault in ?? () called by __libc_start_main () called by _start ()
15:26:55 <uiop> :)
15:27:05 <Eduard_Munteanu> johnw: applicative functors and monads are unrelated at large
15:28:41 <Eduard_Munteanu> johnw: at least I can't find any relationship between them as closed / lax monoidal functors vs monads
15:29:20 <uiop> just sounds like the Applicative zealots trying to get in on the instance action
15:29:27 <uiop> :)
15:29:32 <johnw> i guess since in Haskell all functors are strong endofunctors, there's nothing about the functionality of Applicative which would disallow it from being a Monad
15:29:47 * Eduard_Munteanu . o O (instance action suit)
15:29:51 <johnw> so really we're just taking advantage of the overlap to avoid having to always introduce a second constraint
15:30:06 <quchen_> (Functor f, Monad f) => …
15:30:08 <quchen_> :-s
15:30:20 <Eduard_Munteanu> Well, for starters Functor should be a superclass of Monad.
15:30:32 <johnw> Applicative being a superclass is just mighty handy
15:30:41 <Eduard_Munteanu> Yeah, I agree.
15:31:29 <yogurt_truck> "A partial function f from A to B (abbreviated as f : A → B) is a subset of A×B such that if (x,y) ∈ f and (x,z) ∈ f, then y = z. In other words, a partial function from A to B associates to each element of A at most one element of B."
15:31:40 <yogurt_truck> ^ is that accurate?
15:32:12 <johnw> Eduard_Munteanu: they do both relate monoidal structures to functors, just maybe in an orthogonal way?
15:32:14 <Eduard_Munteanu> johnw: actually, are all Haskell functors strong, as opposed to just all monads being strong?
15:32:33 <Eduard_Munteanu> I suppose so.
15:33:11 <johnw> hmm
15:33:14 <johnw> now you have me not so sure
15:33:47 <Eduard_Munteanu> Actually strongness is Traversable, pretty much.
15:33:48 <uiop> where is (<$>) located nowadays?
15:34:04 <Eduard_Munteanu> uiop: Control.Applicative, but with a Functor constraint
15:34:04 <ij> Data.Functor?
15:34:12 <johnw> Eduard_Munteanu: right
15:34:14 <uiop> ah
15:34:33 <Eduard_Munteanu> (simply as 'flip fmap')
15:34:40 <Eduard_Munteanu> Er.
15:34:47 <Eduard_Munteanu> Infix 'fmap'.
15:34:57 <johnw> well, if I have any v ⊗ F(w), in Haskell I can always fmap (v ⊗) (F(w)), and get F (v ⊗ w)
15:35:37 <Eduard_Munteanu> johnw: would that be costrong?
15:35:44 <johnw> not according to http://ncatlab.org/nlab/show/tensorial+strength
15:36:10 <Twey> http://comonad.com/reader/2008/deriving-strength-from-laziness/
15:36:12 <dolio> Strength means you can internalize the mapping action of the functor.
15:36:25 <dolio> Which is obviously the case for Functors.
15:36:34 <johnw> meanwhile Applicative is F (v ⊗ w) → F v ⊕ F w
15:36:47 <johnw> yay, dolio
15:36:52 <johnw> a person with real knowledge :)
15:37:21 <Eduard_Munteanu> Isn't strength 'F (v x w) -> v x F w' rather? I'm confused.
15:37:30 <dolio> No, it is not that.
15:38:23 <Eduard_Munteanu> Oh, duh, I was thinking of (,) e and got confused.
15:38:45 <Eduard_Munteanu> :t Data.Traversable.sequence
15:38:46 <lambdabot> (Monad m, Traversable t) => t (m a) -> m (t a)
15:38:46 <acowley> Just realized I had been net split to a version of #haskell with like 10 people in it :/
15:39:01 <johnw> was it the right 10 people though?
15:39:04 <Eduard_Munteanu> F would be the 'm' there.
15:39:12 <dolio> Anyhow, the statement of strength with a tensor product is some sort of weakest way of stating it.
15:39:24 <acowley> No, no it was not.
15:40:00 <dolio> But I've seen it noted that the meat is that you fmap has an internal hom analogue.
15:40:04 <acowley> I kept making bad jokes, and G&S meets type theory references, but nobody laughed. It was awful.
15:40:35 <dolio> Which is trivial in the case of Haskell, because you're usually considering everything to be enriched in Haskell-definable things.
15:41:07 <dolio> Presumably it's also trivial for Sets.
15:42:11 * hackagebot MFlow 0.4.0 - stateful, RESTful web framework  http://hackage.haskell.org/package/MFlow-0.4.0 (AlbertoCorona)
15:42:32 <dolio> But presumably it's not always trivial for a functor over a category that isn't enriched in itself to contain the mapping action of the functor internally.
15:43:56 <Eduard_Munteanu> dolio: would it be equivalent / similar to state your functor commutes with all limits and exponentials?
15:44:44 <dolio> I don't know about equivalent. That sounds stronger.
15:45:06 <Eduard_Munteanu> Er, commutes one way.
15:45:38 <dolio> No, I mean 'all limits' sounds stronger.
15:46:13 <dolio> Considering that just commuting with (A ×) is sufficient.
15:47:32 <Eduard_Munteanu> I'm sometimes a bit confused regarding the monoidal category machinery vs just going with products and so on, e.g. applicatives as closed functors vs functors preserving exponentials.
15:48:42 <Eduard_Munteanu> The latter was pretty much my own concocted idea of Applicative.
15:49:35 <Eduard_Munteanu> Confused as in I'm not sure what it buys you.
15:49:53 <dolio> It's more general.
15:52:25 <allspark> why must tuples inside lists be homogeneous?
15:52:35 <milfjord> what?
15:52:52 <ij> allspark, You mean why can't you have [(a), (a,a), ...something]?
15:52:54 <Eduard_Munteanu> allspark: all elements of a list must have the same type, regardless if they're tuples
15:53:01 <uiop> allspark: for the same reason that both branches of an if must unify
15:54:05 <uiop> allspark: actually, that's probably just plain not true .. :) (not the *same* reasons)
15:54:16 <ij> well
15:54:37 <ij> If an if returns something, the function must know, likewise, if you map a list, the function must know too.
15:54:49 <Eduard_Munteanu> dolio: how much more general / weaker is a tensor product for a monoidal category as opposed to the actual product? Does it lack an UMP and so you can construct tensor products that aren't isomorphic to the actual product?
15:55:09 <uiop> ij: similar enough for the me to knee-jerk it, yes
15:55:09 <dolio> Yeah. Tensor product could be anything.
15:55:24 <dolio> (+, 0) form a monoidal category structure.
15:55:32 <Eduard_Munteanu> Ah, anything as long as it makes some sort of monoid.
15:55:41 <Eduard_Munteanu> I see, thanks.
15:55:42 <uiop> ij: at least, it *sounds* good ;)
15:56:34 <allspark> How come this is wrong [("first",1),(12,13)]? aren't the elements all of type tuple(at least from the top)?
15:57:06 <Eduard_Munteanu> allspark: the entire type matters, not just the outer bit
15:57:17 <triliyn> allspark: (String, Integer) is different from (Integer, Integer)
15:57:42 <Eduard_Munteanu> allspark: what do you say if I ask you what type that list has?
15:57:45 <milfjord> allspark: "tuple" is not a type
15:58:36 <Eduard_Munteanu> :t [("first", 1)]
15:58:36 <lambdabot> Num t => [([Char], t)]
15:58:42 <Eduard_Munteanu> :t [(12, 13)]
15:58:42 <lambdabot> (Num t, Num t1) => [(t, t1)]
15:59:05 <acowley> Is anybody working on type family injectivity with DataKinds?
15:59:33 <c_wraith> acowley: what do you mean by that?
15:59:33 <Eduard_Munteanu> acowley: what do you mean by "working on [...] injectivity"?
16:00:12 <c_wraith> acowley: do you mean "making GHC infer that this type family is injective because it's defined over a finite data kind"?
16:00:19 * ion notices GHC.Fingerprint
16:00:21 <acowley> c_wraith: Yes, that
16:01:01 <Eduard_Munteanu> Er, why would it be injective in that case?
16:01:04 <acowley> Actually, I guess closed type families is a lot of information
16:01:10 <c_wraith> acowley: I haven't heard of anyone working on that..  But #ghc would be a better place to ask about it.
16:01:17 <allspark> what 'type' does a tuple belong in. I don't understand signatures too well at this stage
16:01:19 <acowley> Eduard_Munteanu: It doesn't have to be injective, but if it is, then it is
16:01:26 <c_wraith> Eduard_Munteanu: it wouldn't necessarily be, but you could at least know.
16:01:26 <Eduard_Munteanu> Oh.
16:01:43 <tmhedberg> allspark: It depends on the type of the components of the tuple
16:02:00 <acowley> I seem to run into this sort of thing a lot
16:02:07 <Eduard_Munteanu> allspark: there isn't a standalone thing called 'tuple'... there are tuples of Integers and Strings and tuples of this, that and that other thing.
16:02:11 <acowley> like defining instance for GADTs indexed by a DataKinds
16:02:37 <acowley> You can provide instances for all possible types, but you still need to mention the constraint.
16:02:38 <c_wraith> acowley: yeah, closed type families can probably do what you want, in one way or another.
16:03:04 <Eduard_Munteanu> Ah, yes, I ran into a similar thing a few days ago, haven't reported it yet.
16:03:05 <c_wraith> acowley: *that* specific issue is deeper.
16:03:20 <acowley> Yes, now I'm lumping things in
16:03:30 <acowley> But these are common pain points when using DataKinds
16:03:41 <acowley> it's so close to being amazingly wonderful
16:03:47 <allspark> so I can just generalize it as a data structure?
16:03:55 <c_wraith> acowley: for instance, in GHC.TypeLits, you know that there are SingI instances for all types of kind Nat.  But you still have to specify that the instance is present.
16:04:26 <acowley> I just want to write some equations about types and have the compiler do more work for me
16:04:39 <acowley> c_wraith: Yeah, that's a good example
16:04:44 <Eduard_Munteanu> allspark: ("first", 3) :: (String, Integer), there's no way you can simplify that.
16:05:07 <c_wraith> acowley: edwardk_ explained the reason for that a while ago.  It has to do with how GHC implements dictionary-passing internally.
16:05:13 <Eduard_Munteanu> Aside from defining a synonym for it.
16:05:28 <tmhedberg> allspark: You can't just have "a list of tuples"; you need to know what type of values are in the tuples
16:05:30 <acowley> c_wraith: Yeah
16:05:37 <acowley> c_wraith: I can still ask for sweeter syntax
16:05:42 <acowley> (aka no syntax at all)
16:05:47 <c_wraith> acowley: He said that yes, it's theoretically possible to come up with a different design for determining those things, but it's a lot of work, and no one's doing it.
16:05:52 <tmhedberg> allspark: A pair of Strings is a different type than a pair of Integers, or a pair of one String and one Integer
16:06:05 <tmhedberg> Or a triple of Strings
16:07:06 <Eduard_Munteanu> allspark: it might also help to know (concrete) types never share elements
16:07:21 <uiop> allspark: do you know C? an anology would be to a struct{union{char*;int};int}, and you get to russian-roulette the first member wrt dereferencing it
16:07:23 <milfjord> Eduard_Munteanu: eh?
16:07:23 <Eduard_Munteanu> There is no value that belongs to different types.
16:07:33 <heatsink> > unsafeCoerce# () :: Bool
16:07:34 <lambdabot>  Not in scope: `unsafeCoerce#'
16:07:41 <heatsink> should be False
16:07:54 <c_wraith> Eduard_Munteanu: that's not true.  Nothing belongs to an infinite number of types.
16:08:38 <uiop> c_wraith: id::a->a, id::[a]->[a], id::[[a]]->[[a]], ...
16:08:44 <c_wraith> Eduard_Munteanu: you'll need to phrase that more carefully.
16:08:46 <Eduard_Munteanu> Er, I was thinking about something else and got out wrong.
16:08:57 <milfjord> there's no subtyping
16:09:03 <c_wraith> Yeah, I think I know what you meant.
16:09:09 <c_wraith> But it certainly came out wrong. :)
16:09:46 <Eduard_Munteanu> Subtyping, but also the lack of non-disjoint union types.
16:10:32 <Eduard_Munteanu> And if you determine that x :: A, clearly there's no B such that x :: B.
16:10:51 <Eduard_Munteanu> (where 'x' is a name)
16:11:18 <milfjord> type B = A
16:11:28 <milfjord> x = undefined
16:11:55 <Eduard_Munteanu> milfjord: undefined doesn't have a monomorphic type
16:12:03 <Eduard_Munteanu> In that context.
16:13:11 <Eduard_Munteanu> > let x = undefined :: String in x :: Integer
16:13:11 <lambdabot>  Couldn't match type `[GHC.Types.Char]'
16:13:12 <lambdabot>                with `GHC.Integer.Type.Integer'
16:13:12 <lambdabot>  Expected type: GHC.Integer.Type.Integer
16:13:12 <lambdabot>    Actual type: GHC.Base.String
16:13:31 <milfjord> > let x = x in (x :: String, x :: Integer)
16:13:35 <lambdabot>  mueval-core: Time limit exceeded
16:14:04 <allspark> uiop: I 'know' C but don't get the analogy, how does it relate to lists?
16:14:09 <Eduard_Munteanu> milfjord: that's still polymorphic
16:14:20 <Eduard_Munteanu> :t let x = x in x
16:14:21 <lambdabot> t
16:14:30 <Eduard_Munteanu> You just instantiate it twice.
16:14:42 <uiop> allspark: in your case you would need to use the type [(Either String Int, ..)]
16:15:13 <Eduard_Munteanu> Unless you were nitpicking on my informal description earlier, in which case I take the point. :)
16:16:10 <uiop> allspark: that type turns struct{union{char*,int},..} into struct{enum{its_a_char_ptr,its_an_int},union{char*,int},..}
16:16:29 <allspark> Ahh, I see. what about 'concrete types don't share elements'?
16:17:09 <uiop> i missed that comment, so defer to its author
16:17:51 <allspark> Eduard_Munteanu: what'd you mean by 'concrete types don't share elements'?
16:18:28 <Eduard_Munteanu> allspark: I was trying to tell you tuples of different types and sizes are completely different types, but it came out wrong
16:19:05 <allspark> you had me googling like crazy
16:19:13 <Eduard_Munteanu> Sorry. :)
16:19:58 <acowley> I type {-# GHC_OPTIONS ... #-} every. single. time.
16:20:11 <Eduard_Munteanu> acowley: to what end?
16:20:24 <acowley> An unknown pragma warning
16:22:38 <c_wraith> acowley: someone told me that it's kind of like haskell type signatures.  you put the part that's most likely to change at the back.  And there are already OPTIONS_* pragmas other than GHC.  I've even used OPTIONS_HADDOCK!
16:23:25 <acowley> c_wraith: Makes sense.
16:24:02 <acowley> I probably try too hard to read things as English
16:25:33 <ion> “Template Haskell declarations, types, patterns, and untyped expressions are no longer typechecked at all.” What does that make better?
16:25:34 <cyber> HASKELL Kills
16:25:37 <cyber> Whatever anyone else might say, Linux IS about choice.
16:25:39 <cyber> Debian is the anti-redhat. Fuck systemd, please second this proposal: https://lists.debian.org/debian-vote/2014/03/msg00000.html
16:25:45 <cyber> HASKELL Kills
16:25:50 <cyber> Whatever anyone else might say, Linux IS about choice.
16:25:53 <cyber> Debian is the anti-redhat. Fuck systemd, please second this proposal: https://lists.debian.org/debian-vote/2014/03/msg00000.html
16:25:57 --- mode: ChanServ set +o milfjord
16:26:03 <ion> thanks
16:26:16 <cyber> haskell kills
16:26:17 --- mode: milfjord set +b *!*@ool-457cb565.dyn.optonline.net
16:26:59 <allspark> haha, i love trolls
16:27:08 <SwashBuckla> oh dear
16:27:15 --- kick: cyber was kicked by milfjord (cyber)
16:29:15 --- mode: milfjord set -o milfjord
16:30:26 <zomg> I wonder what did Haskell killing have to do with that proposal
16:30:44 <zomg> was it some ridiculous attempt at making it look like it was relevant to the channel?
16:30:47 <zomg> who knows =)
16:30:57 <milfjord> I do
16:30:59 <thebnq> @faq can haskell kill?
16:30:59 <lambdabot> The answer is: Yes! Haskell can do that.
16:31:01 <thebnq> :(
16:31:05 <Yaniel> :D
16:31:15 <Yaniel> well, so can carrots
16:31:16 <dawik> @faq are you skynet?
16:31:16 <lambdabot> The answer is: Yes! Haskell can do that.
16:31:40 <dawik> boo. alicebot can do better than that
16:32:07 <ion> No, the fault lies in the question. Humans can do better than that.
16:45:33 <heatsink> Interesting.  Two algebraic data values with different types can have the same _address_ in GHC.
16:45:44 <qwebirc58811> i have been reading http://joyoftypes.blogspot.com/2012/02/haskell-supports-first-class-instances.html and got flummoxed with "data Dict a where Dict :: a => Dict a"
16:45:53 <qwebirc58811> what does it mean?
16:46:28 <heatsink> The 'a' stands for a constraint, which is anything that can normally be on the left of an =>
16:46:48 <heatsink> and a Dict a holds the run-time data of the constraint
16:47:01 <heatsink> For example, Dict (Eq Int) holds the equality-comparison methods for Int
16:47:26 <dmwit> heatsink: Yes, e.g. [] is shared across all lists -- even lists of different types.
16:47:43 <dmwit> heatsink: Or does it go even deeper than that? Will, e.g., () and [] have the same address?
16:48:34 <heatsink> Not that I've seen, dmwit
16:48:51 <dmwit> right
16:50:02 <qwebirc58811> normally i am used to seeing constraints as eg Ord a => a
16:50:05 <geekosaur> I wonder if it's smart enough to optimize based on representation. that is, the representation of Word8 and Word16 are the same (since constructor # 0 and the value is always a machine word)
16:51:14 <dmwit> I don't think so. That's what I was getting at with ()/[].
16:51:49 <dmwit> I vaguely remember that it only shares nullary constructors across types with the same head type constructor.
16:52:15 <dmwit> Though my memory and progress since I heard that are both likely reasons for that to be wrong.
16:53:33 <5EXAAR3UB> how do I set a dynamic ghci prompt, i.e the namespace changing with every import?
16:54:04 <thetallguy> 5EXAAR3UB: it's not happening automatically?
16:54:40 <skypers> is there a binding to OpenCL ?
16:54:47 <5EXAAR3UB> It never changes once i set it with :set prompt ">>> "
16:55:02 <geekosaur> right, there is currently no way to combine those
16:55:06 <thetallguy> http://hackage.haskell.org/package/OpenCL
16:55:19 <geekosaur> the default is modules in scope, if you set an explicit one then it's that literal string
16:55:25 <pavonia> 5EXAAR3UB: you can use "%s" for the list of loaded modules
16:57:29 <5EXAAR3UB> pavonia: nifty little trick that. got one that just includes the most recent one?
16:57:51 <pavonia> nope
17:00:36 <5EXAAR3UB> why does this not work, main=add 25 36?
17:00:56 <5EXAAR3UB> yet this works, main=putStr "Hello world\n"
17:01:07 <ion> main :: IO a
17:01:10 <milfjord> "doesn't work" is not a problem description
17:01:53 <SJSUNOOB> Hi all, I'm having trouble understanding the following:
17:01:55 <SJSUNOOB> head' :: [a] -> a   head' [] = error "Can't call head on an empty list, dummy!"   head' (x:_) = x
17:02:01 <5EXAAR3UB> "doesn't work" usually means "gives an error"
17:02:14 <milfjord> sometimes it does, sometimes it doesn't
17:02:15 <SJSUNOOB> Let me print that otu a bit better
17:02:20 <SJSUNOOB> head' :: [a] -> a
17:02:24 <ion> “gives an error” usually means “provide your code and the exact error message when asking a question about this”
17:02:25 <SJSUNOOB> head' [] = error "Can't call head on an empty list, dummy!"
17:02:29 <SJSUNOOB> head' (x:_) = x
17:02:51 <SJSUNOOB> I understand the first line "head' :: [a] -> a  " Create a function called head' that takes in a list of type a and produce an item of type a
17:02:57 * geekosaur suggests use of lpaste instead of pasting into the channel
17:03:00 <geekosaur> @paste
17:03:01 <lambdabot> Haskell pastebin: http://lpaste.net/
17:03:01 <tmhedberg> SJSUNOOB: What about it is confusing you, specifically?
17:03:12 <SJSUNOOB> second line "head' [] = error "Can't call head on an empty list, dummy!"  " spit out the error if there is an empty list
17:03:16 <SJSUNOOB> I don't understand the third line
17:03:22 <SJSUNOOB> head' (x:_) = x
17:03:33 <tmhedberg> Do you know what : is?
17:03:37 <SJSUNOOB> I'm running through the following tutorial in pattern matching: http://learnyouahaskell.com/syntax-in-functions
17:03:43 <milfjord> SJSUNOOB: a list is either the special value [] (representing an empty list) or a pair of an element and another list
17:03:48 <SJSUNOOB> It concatnates items
17:03:50 <geekosaur> 5EXAAR3UB, the exact error message is usually important
17:03:58 <ion> [0,1,2] is syntactic sugar for 0:1:2:[]
17:04:00 <milfjord> SJSUNOOB: the latter is written as element : otherlist
17:04:01 <SJSUNOOB> for example 5 : [3,4,5] = [5,3,4,5]
17:04:10 <ion> > case 0:1:2:[] of (x:xs) -> (x, xs)
17:04:11 <lambdabot>  (0,[1,2])
17:04:29 <ion> > case 0:1:2:[] of (x:_) -> x
17:04:30 <lambdabot>  0
17:04:39 <SJSUNOOB> I'm getting confused
17:04:40 <5EXAAR3UB> It didn't seem appropriate to paste 4 lines here
17:04:42 <tmhedberg> SJSUNOOB: Not exactly, it constructs a new list from a single element (on the left) and another list (on the right)
17:04:54 <SJSUNOOB> ok, single element on the left and a list on the right
17:05:02 <ion> @src []
17:05:03 <lambdabot> data [] a = [] | a : [a]
17:05:07 <tmhedberg> Since it is a constructor, it can also be used to deconstruct the same via pattern matching
17:05:15 <milfjord> data List a = Nil | Cons a (List a)
17:05:29 <tmhedberg> So (x:_) matches any non-empty list, and binds the name "x" to the first element of that list
17:05:31 <ion> head' (Cons x _) = x
17:05:36 <SJSUNOOB> So for (x:_) it's saying ignore the actual list part
17:05:59 <tmhedberg> It says "ignore the tail of the list", i.e. all except the first element
17:06:04 <milfjord> there is no actual list, really
17:06:19 <SJSUNOOB> I know it ignores the tail of the list, I'm just trying to wrap my head around the syntax
17:06:33 <milfjord> > "p" : ("a" : ("t" : []))
17:06:34 <lambdabot>  ["p","a","t"]
17:07:25 <tmhedberg> Instead of writing [1, 2, 3], you could write 1:2:3:[], they are equivalent. The pattern (x:_) applied to 1:2:3:[] binds x to the 1, and ignores the rest
17:08:14 <SJSUNOOB> so head' [] =  error "some error" is saying spit an error if the list is empty
17:08:15 <tmhedberg> The : operator is right-associative, so you match the leftmost : first
17:08:34 <tmhedberg> Yes
17:08:37 <SJSUNOOB> so the : operator has to function
17:08:50 <SJSUNOOB> it can add an item and a list, and it can be used as a pattern match?
17:08:59 <SJSUNOOB> two*
17:09:05 <tmhedberg> Correct, and the same is true of any constructor, not just :
17:09:08 <ion> There are list constructors ([] and a : [a]), head' needs to cover both.
17:09:33 <ion> (Unfortunately it doesn’t cover [] very well because head' is evil, but that’s beside the point. :-P)
17:09:52 <ion> (or perhaps the other way around)
17:10:04 <SJSUNOOB> hmm, honestly not quite wrapping my head around it
17:10:09 <SJSUNOOB> It was all good up until this point
17:10:15 <tb01110100> So, I'm learning haskell and screwing arount with the ghci thingy. Why can't I do this: "let string = [12,37,17,48]" and "let mean = (sum string) / (length string)" and "mean"
17:10:19 <tb01110100> Why won't that work?
17:10:29 <tb01110100> The error is rather cryptic.
17:10:52 <milfjord> tb01110100: because you can't use / on Ints
17:11:03 <heatsink> Integers
17:11:10 <milfjord> heatsink: true but irrelevant
17:11:13 <tb01110100> so what do I do then?
17:11:15 <skypers> 00:51 < thetallguy> http://hackage.haskell.org/package/OpenCL
17:11:16 <tmhedberg> Try `div` instead
17:11:20 <skypers> thank you thetallguy
17:11:22 <milfjord> tb01110100: fromIntegral (length string)
17:11:24 <tb01110100> tmhedberg: ty, I'll try that
17:11:58 <ion> If string defaulted to :: [Integer], that’s not enough.
17:12:14 <SJSUNOOB> Hmm, so x is the parameter being passed in
17:12:16 <SJSUNOOB> why won't you just do head' x = x
17:12:20 <5EXAAR3UB> and also sum is sum :: Num a => [a] -> a
17:12:22 <SJSUNOOB> wouldn't that give you the same answer?
17:12:28 <milfjord> SJSUNOOB: x would be a list there
17:13:17 <ion> tb01110100: You might want to do “:set -XNoMonomorphismRestriction” in ghci (and perhaps even set it in ~/.ghci), that way string will end up being polymorphic instead of defaulting to :: [Integer]
17:13:36 <tb01110100> tmhedberg: same kind of error
17:13:36 <milfjord> SJSUNOOB: so that's a type error (because you said head' :: [a] -> a)
17:13:36 <5EXAAR3UB> my bad
17:13:47 <tmhedberg> tb01110100: You will need to use fromIntegral to generalize the type one side of the operation, or use the -XNoMonomorphismRestriction option to increase polymorphism
17:13:58 <ion> GHC 7.8 will use NoMonomorphismRestriction in ghci by default.
17:14:36 <tb01110100> sorry, but I didn't understand most of what you said. I'm still very new to haskell, but I think it's beautiful :P
17:15:10 <milfjord> tb01110100: the simplified version is that / works on floating point numbers and length returns an Int
17:15:20 <milfjord> so you need to convert both sides to Double with fromIntegral
17:15:45 <tmhedberg> tb01110100: try this: let mean = fromIntegral (sum string) / fromIntegral (length string)
17:16:24 <SJSUNOOB> milfjord: Ok, I think I'm getting it
17:16:24 <SJSUNOOB> So if x is a list
17:16:24 <SJSUNOOB> we want to do x:_
17:16:24 <SJSUNOOB> which would combine x with an empty list?
17:16:24 <SJSUNOOB> milfjord: It's a type error because I need to return a single element?
17:16:32 <ion> sjsunoob: Let’s ignore lists for a second. Are you familiar with Maybe?
17:16:47 <SJSUNOOB> no...
17:16:51 <milfjord> SJSUNOOB: yes to the type error
17:16:54 <tb01110100> tmhedberg: alright, that works. Still don't understand why my original one didn't, though.
17:17:16 <SJSUNOOB> milfjord: I fully understand this haskell code though, if it helps: http://lpaste.net/101041
17:17:20 <milfjord> SJSUNOOB: ok, I think you need to learn some basic type stuff before jumping into lists
17:17:23 * hackagebot vinyl-json 0.1.0.0 - Provide json instances automagically to vinyl types  http://hackage.haskell.org/package/vinyl-json-0.1.0.0 (tbelaire)
17:17:28 <tmhedberg> tb01110100: The original one didn't work because / wants operaands of type Double, but you were giving it integers
17:17:43 <milfjord> SJSUNOOB: I doubt that
17:17:43 <SJSUNOOB> Well, I'm literally going through this book
17:17:44 <SJSUNOOB> http://learnyouahaskell.com/
17:17:57 <tb01110100> tmhedberg: alright...
17:18:08 <tb01110100> so basically it didn't like decimals in the answer?
17:18:37 <milfjord> > length "a" / length "b"
17:18:38 <lambdabot>  No instance for (GHC.Real.Fractional GHC.Types.Int)
17:18:38 <lambdabot>    arising from a use of `GHC.Real./'
17:18:38 <lambdabot>  Possible fix:
17:18:38 <lambdabot>    add an instance declaration for (GHC.Real.Fractional GHC.Types.Int)
17:18:39 <tmhedberg> No, it didn't like the fact that you were providing operands of an incompatible type
17:20:02 <tmhedberg> fromIntegral takes its argument from an Integral type to any numeric type, so that made the arguments compatible with what / expects
17:46:40 <tb01110100> man, really quiet here all of a sudden.
17:47:03 <caseof> Any better way to write map (\(c,_,_,_,_) -> c) l ?
17:47:37 <quchen_> Nope
17:47:44 <milfjord> _1
17:47:45 <ParahSailin> probably a lens for that
17:48:02 <pavonia> :t _1
17:48:03 <lambdabot> (Functor f, Field1 s t a b, Indexable Int p) => p a (f b) -> s -> f t
17:48:35 <milfjord> :t view _1
17:48:36 <lambdabot> (MonadReader s m, Field1 s s b b) => m b
17:48:57 <quchen_> You probably shouldn't be using 5-tuples in the first place anyway. 3-tuples are usually smelly already.
17:49:05 <quchen_> Use a custom type instead.
17:49:38 <quchen_> data InternetAddress = Addr Host Port Protocol -- instead of (Host, Port, Protocol)
17:50:16 <pavonia> How do you get the simple projection function from _1?
17:50:38 <heatsink> I really should refactor some of the tuples in Haddock
17:50:55 <quchen_> :t (^. _1) -- pavonia
17:50:56 <lambdabot> Field1 s s b b => s -> b
17:51:26 <pavonia> >  (^. _1) (10, 20, 30, 40, 50)
17:51:28 <lambdabot>  10
17:51:39 <quchen_> :t \x@(a,b,c,d,e,f,g) -> (x ^. _1)
17:51:39 <lambdabot> (t, t1, t2, t3, t4, t5, t6) -> t
17:51:47 <heatsink> I think lens has TH code to generate a class instance that contains the projection function.
17:52:39 <heatsink> Ah, I misread the question.
17:54:24 <thebnq> i don't think it does O.O http://hackage.haskell.org/package/lens-4.0.5/docs/src/Control-Lens-Tuple.html
17:54:34 <thebnq> wonder if anyone seriously uses 9-tuples
17:54:55 <quchen_> My guess is that 10 is the first number that doesn't align well in the source.
17:55:08 <haasn> Great news!
17:55:11 <quchen_> I think the Report requires tuple functions to scale up to 7.
17:55:12 <haasn> I finally found a use case for TardisT!!
17:55:20 <hpc> 9-tuples believe in themselves and don't need the validation of internet strangers ;)
17:55:22 <quchen_> haasn: Other than the Twitter waterflow problem?
17:55:28 <haasn> quchen_: Haven't seen it :(
17:55:45 <haasn> quchen_: traversing over a structure (using a traversal or just plain old ‘traverse’) with access to the values before and after your current
17:55:47 <quchen_> Nevermind then! Share your use, you'll double the use cases
17:55:53 <haasn> λ evalTardis ?? (10,0) $ traverse (\a -> tardis $ \(next,prev) -> (unwords [if a>prev then ">prev" else "<=prev", if a>next then ">next" else "<=next"], (a,a))) [1,2,3,2,1]
17:55:55 <haasn> [">prev <=next",">prev <=next",">prev >next","<=prev >next","<=prev <=next"]
17:56:03 <quchen_> Waitamoment
17:56:24 <quchen_> Yeah no not going to try to understand that
17:56:36 <haasn> if you look at the list like 0 [1,2,3,2,1] 10 you'll see in each position a description of how that value compares to the previous/next values
17:57:19 <haasn> I wonder if it could be generalized using a TardisT [a] [a] to gain access to an entire history..
17:57:20 <quchen_> How about using the list comonad?
17:57:40 <quchen_> Or list zipper
17:57:44 <haasn> quchen_: there's no list comonad!
17:57:50 <haasn> or did you mean nonempty?
17:57:57 <quchen_> list with lower-case "l" :-þ
17:58:00 <haasn> that would certainly work, yes
17:58:01 <c_wraith> there's a list semicomonad
17:58:30 <c_wraith> it has extend, but not extract
17:58:45 <quchen_> I know.
17:59:06 <quchen_> I meant the "Foobar [a] a [a]" comonad, whatever you want to call it. The listy zippy comonad that allows you to do the thing the tardis did above.
17:59:43 <c_wraith> at least one blog post called that the automata comonad
18:03:01 <haasn> quchen_: what does <*> look like on that?
18:03:31 <quchen_> <@> you mean?
18:03:39 <c_wraith> haasn: it's a comonad.  It doesn't have <*>
18:03:42 <haasn> No, I mean, is it an Applicative?
18:03:44 <haasn> Okay
18:03:59 <haasn> Then I still need the TardisT to feed the state through forwards and backwards (applicatively)
18:04:59 <quchen_> NonEmpty has a ComonadApply instance though, c_wraith.
18:05:12 <haasn> getPast >>= extract -- elegant enough ;)
18:05:19 <quchen_> I assume the automaty zippy listy comonad has a similar instance.
18:05:47 <haasn> oh, not >>=
18:06:02 <quchen_> Eh,  instance ComonadApply NonEmpty where (<@>) = ap
18:26:21 --- mode: ChanServ set +o milfjord
18:26:22 --- mode: milfjord set -b *!*@ool-457cb565.dyn.optonline.net
18:28:21 --- mode: milfjord set -o milfjord
18:29:27 <haasn> quchen_: http://lpaste.net/101042
18:29:54 <haasn> context (:) gives you access to the entire history
18:30:00 <haasn> and context const gives you access to the values immediately adjacent
18:30:25 <quchen_> uuuh
18:30:48 <quchen_> MonadFix is because of Tardis?
18:30:51 <haasn> yeah
18:31:06 <haasn> you need access to the values flowing backwards from the future if you want to use it as a transformer
18:31:13 <haasn> shouldn't be a huge deal since I'm mainly using it with Identity
18:31:33 <quchen_> What's "u"?
18:31:38 <haasn> update function
18:31:42 <quchen_> (Documentation: F)
18:32:16 <quchen_> n/p = next/previous?
18:32:19 <haasn> yeah
18:32:29 <haasn> (see? single letter variable names are sufficient documentation!)
18:33:00 <haasn> now I wonder if it works on infinite traversals..
18:33:48 <haasn> doesn't, unfortunately :(
18:34:22 <quchen_> Why do you flip (n,p), for example in line 14?
18:34:32 <quchen_> Is that a Tardis API smell or is it significant?
18:34:57 <haasn> quchen_: “tardis” has the values flowing backwards before the values flowing forwards; but in my API I wanted the values to the left of the current to be to the left, and the values to the right of the current to be to the right
18:37:40 <haasn> I'm suddenly unsure why it doesn't work on infinite lists.. hmm
18:38:51 <haasn> oh, because of sequence_ on an infinite structure
18:39:14 <haasn> and a sufficiently strict TardisT monad implementation..
18:39:21 <quchen_> Tardis doesn't work that well on infinite data anyway, does it?
18:41:29 <haasn> apparently not
18:44:00 <tb01110100> so, is "|" in haskell comparable to "for" in bash?
18:44:37 <haasn> tb01110100: are you talking about list comprehension syntax?
18:45:13 <tb01110100> haasn: I guess so
18:45:14 <tb01110100> as in
18:45:37 <tb01110100>  sum [1 | _ <- xs[
18:45:49 <tb01110100> s/xs[/xs]
18:45:54 <tb01110100>  sum [1 | _ <- xs]
18:46:21 <tb01110100> ^^ that one
18:47:48 <haasn> it's not really like ‘for’ in bash in that you don't have access to side effects
18:51:37 <Cale> tb01110100: lists behave much like loops though
18:51:54 <tb01110100> Cale: ah, ok. ty
18:52:04 <Cale> tb01110100: Just like how a loop either never happens (because its precondition isn't met), or consists of an iteration followed by another loop
18:52:18 <Cale> Lists are either empty, or consist of a single element followed by another list
18:54:32 <Cale> (and just like loops can be infinite, so can lists)
18:55:21 <dpwright> I'm trying to write a simple typechecker using ekmett's Bound library at the moment, and struggling somewhat
18:56:16 <dpwright> I have three main datatypes: Exp, Type, and TypeScheme, which are parameterised on things like the identifiers used for type variables, type constructors, and expression variables, as well as the set of literal types and literal expressions which are allowed
18:56:24 <isaacbw> is there a way to generate minimal complete definitions
18:56:48 <isaacbw> I mean, generate sets of functions to define
18:57:47 <dpwright> the Exp type is fine; basically copied from the samples.  The TypeScheme type is defined as "data TypeScheme χ t α = TS (Scope () (TypeScheme χ t) α) | T  (Type χ t α)", where χ is the identifier for type constructors and α is the identifier for type variables (excuse the greek)
18:59:06 <dpwright> I'm struggling to write a monad instance for TypeScheme
18:59:30 <dpwright> is there anyone who might be able to lend a hand if I put the code up somewhere?
19:11:19 <dpwright> http://lpaste.net/101044 the problem is with the definition of (>>=) for T in the TypeScheme instance
19:12:38 <dpwright> the underlying Type is parameterised on the same Type Variable identifier, so if the function I'm binding to returns a different type the types don't match
19:13:32 <dpwright> It makes sense -- I could imagine a function which just converts the identifier from Text to String, for example -- you would have to run an equivalent function for Type to get the types to line up
19:14:00 <dpwright> but I don't know what to do... I'm inclined to think that this problem is a sign that I'm approaching it wrong
19:15:29 <NemesisD> anyone use structured-haskell-mode?
19:24:09 <byorgey> NemesisD: I've been trying it for a few days, haven't really gotten the hang of it yet
19:25:25 <NemesisD> byorgey: for some reason when i hit tab it brings up that annoying-ass haskell-mode menu telling about indentation modes
19:25:36 <NemesisD> but shm isn't supposed to be used with those indentation modes
19:26:00 <Welkin> in emacs?
19:26:14 <NemesisD> Welkin: yes
19:28:07 <byorgey> NemesisD: oh, yeah, I've seen that too.  did you turn off other indentation modes when enabling shm?
19:28:26 <byorgey> but I think I was seeing that before enabling shm.
19:35:48 <NemesisD> byorgey: yeah. i think thats the problem. i hit tab and haskell-mode is like hey you don't have an indentation mode
19:43:20 <isaacbw> hold on, so fmap over Either only touches the right? Isn't that limiting? (even if necessary)
19:44:46 <pavonia> Limiting in what way?
19:45:10 <isaacbw> well, what if you wanted to map left
19:45:51 <pavonia> Either is a Bimap, so you can use its functions
19:47:12 <pavonia> Erm, *Bifunctor
19:55:46 <haasn> Can somebody help me with cabal sandboxes? I'm following the steps at http://coldwa.st/e/blog/2013-08-20-Cabal-sandbox.html and I have “cabal sandbox add-source”'d my patched dependencies
19:55:58 <haasn> but now if I modify those and run “cabal build” again, it doesn't actually rebuild them
19:56:07 <haasn> cabal sandbox list-sources mentions them
19:56:22 <dcoutts> haasn: iirc, you need to build them once manually, then they'll be picked up from then on
19:56:32 <haasn> dcoutts: what does that mean?
19:56:48 <dcoutts> haasn: as in cabal install ./the/local/pkg
19:57:12 <haasn> oh, wait, if I use “cabal install” it reinstalls the package along with its dependencies
19:57:24 <haasn> looks like it works for “cabal install” but not for “cabal configure && cabal build”, weird
19:57:58 <dcoutts> haasn: as I said, once you've built the add-src deps once, then they're tracked, including for build (iirc)
19:59:45 <megajosh2> I haven't done much with Haskell in a long time
19:59:54 <megajosh2> Does cabal sandbox do the same type of things cabal-env was?
20:00:00 <megajosh2> err
20:00:02 <megajosh2> cabal-dev
20:00:27 <dcoutts> megajosh2: yes, but better in various ways (because it's integrated rather than a wrapper)
20:00:29 <gaze> hey folks, what a kind of [*] ?
20:02:44 <dmj`> gaze: where do you see that?
20:04:11 <gaze> from the vinyl library
20:04:50 <gaze> see "http://www.jonmsterling.com/posts/2013-04-06-vinyl-modern-records-for-haskell.html", type LifeForm = ["name" ::: String, "age" ::: Int, ...
20:04:59 <gaze> trying to unravel how this works
20:07:21 <enthropy> gaze: it is like [a] but one level higher
20:07:44 * hackagebot fix-imports 1.0.3 - Program to manage the imports of a haskell module  http://hackage.haskell.org/package/fix-imports-1.0.3 (EvanLaforge)
20:08:04 <enthropy> there aren't any values with that type
20:08:31 <enthropy> but LifeForm is still useful
20:09:26 <gaze> what should I call it?
20:09:34 <gaze> if I'm googling for it
20:10:00 <enthropy> @google giving haskell a promotion
20:10:03 <lambdabot> http://research.microsoft.com/en-us/people/dimitris/fc-kind-poly.pdf
20:10:03 <lambdabot> Title: Giving Haskell a Promotion
20:10:43 <enthropy> also the extension is called -XDataKinds
20:10:56 <enthropy> which you should have had to enable
20:11:02 <gaze> ahh thanks!
20:15:50 <isaacbw> does anyone know why this is popping up when I hit tab in haskell mode in emacs? https://gist.github.com/isaacbw/9500093
20:17:45 * hackagebot beamable 0.1.0.2 - Generic serializer/deserializer with compact representation  http://hackage.haskell.org/package/beamable-0.1.0.2 (JohnLato)
20:20:56 <Welkin> something to do with structured-haskell-mode?
20:22:03 <triliyn> isaacbw: there are two extant haskell indentation modes for emacs, and rather than make one of them the default, the author of haskell-mode decided to prompt the user
20:22:21 <triliyn> (Because opinions differ as to whether one of them is better)
20:22:23 <Welkin> oh
20:22:35 <isaacbw> triliyn: well, I did pick one I thought
20:22:43 <Welkin> I never encountered that since I set it in my .emacs before ever starting haskell-mode
20:22:44 <isaacbw> (add-hook 'haskell-mode-hook 'turn-on-haskell-indent)
20:22:55 <triliyn> hmm
20:23:09 <triliyn> Have you reloaded your .emacs since adding that line?
20:23:17 <isaacbw> yea, it's been there for ages
20:23:28 <triliyn> I have no idea then, sorry
20:23:51 <Welkin> do you have this line? (load "/usr/share/emacs24/site-lisp/haskell-mode/haskell-site-file")
20:24:05 <isaacbw> oh weird
20:24:10 <isaacbw> it's because I had auto-complete-mode on
20:24:23 <isaacbw> seems like a bug in haskell-mode
20:24:38 <Welkin> haskell-mode seems buggy anyway
20:24:39 <Welkin> haha
20:26:31 <isaacbw> structured-haskell-mode looks awesome
20:31:06 <gaze> what's with all the primes in the datakinds paper?
20:31:25 <gaze> like, what's ': all about, or '[]
20:31:45 <gaze> is that to disambiguate it from : and [], since [*] is nonambiguous
20:31:53 <Cale> gaze: It should explain them, and yes
20:32:15 <gaze> ohhhoho. Cool. This is really wild.
20:32:30 <gaze> I heard 7.8 has better support for type level nats... what changed?
20:34:06 <levi> isaacbw: structured-haskell-mode is awesome, but I've decided it's not quite for me. :(
20:34:14 <levi> But don't let that stop you from trying it.
20:47:35 <codygman> This function is hanging (but not throwing an exception): https://github.com/yi-editor/yi/blob/master/yi/src/library/Yi/Boot.hs#L73 How would I debug it? I verified it wasn't throwing an exception by running it with ghci after doing :set -fbreak-on-exception and invoking main.
21:05:18 <mebaran151> hey all, I'm using Data.Csv to encode some data, and I was wondering how I could make it handle a dynamic column layout (i.e. all my maps may not have all the headers, so I want a sparse CSV)
21:06:35 <dmj`> [[ Maybe a ]] ?
21:07:02 <mebaran151> it would nice if it found all my columns automagicaly but I might unfies have to roll something like that
21:07:09 <codygman> mebaran151: Semi-related, you might want to use csv-conduit if you are going to be parsing very large files. At leat I couldn't parse large files well with Data.CSV with deterministic resource handling otherwise.
21:07:51 <mebaran151> my files aren't currently too big (less than 100k records atm), though I'll definitely keep that in mind
21:08:08 <mebaran151> related: is their a csv-conduit like for HDBC / ODBC in Haskell land?
21:08:19 <mebaran151> my queries are what really need the streaming love
21:09:23 <codygman> mebaran151: I don't see any that use streaming, but I do see a few packages for HDBC/ODBC.
21:09:34 <mebaran151> yep I'm on HDBC ODBC
21:09:41 <mebaran151> it works and works fine, but it's painfully slow
21:09:46 <mebaran151> compared to my database export directly
21:09:54 <codygman> mebaran151: Well that is a shame :(
21:10:03 <codygman> about the slowness that is
21:10:09 <mebaran151> I might end up having to put together some CLI program to output a csv this little Haskell program eats
21:25:04 <hamburger11> chomp chomp
21:25:21 <hamburger11> @where ops
21:25:21 <lambdabot> arjanb bos byorgey Cale conal copumpkin dcoutts dibblego dmhouse dolio dons edwardk elliott geekosaur glguy Heffalump Igloo jmcarthur johnw kosmikus Lemmih monochrom nyc Philippa Pseudonym quicksilver roconnor Saizan shachaf shapr sjanssen ski sorear SyntaxPolice xerox
21:25:41 <Welkin> ?
21:25:42 <johnw> do you need an op?
21:25:48 <hamburger11> yes please ? can I pm ?
21:25:51 <johnw> sure
21:25:54 <hamburger11> thanks
21:31:16 <erisco_> I am trying to grok the definition of leftApp http://hackage.haskell.org/package/base-4.6.0.1/docs/src/Control-Arrow.html#leftApp
21:31:25 <erisco_> is ||| the same precedence as >>> ?
21:32:39 <geekosaur> infixr 2 |||
21:32:44 <geekosaur> infixr 1 >>>
21:32:48 <geekosaur> (er ghci)
21:32:51 <geekosaur> *per
21:42:58 --- mode: ChanServ set +o johnw
21:43:00 --- mode: johnw set -b $a:spetrea-home
21:44:49 <hunt> wen it says "    Could not deduce (a ~ Int)" what does that actually mean
21:45:12 <hunt> wen it says "    Could not deduce (a ~ Int)" what does that actually mean
21:45:36 <therealhunt> wen it says "    Could not deduce (a ~ Int)" what does that actually mean
21:45:44 <therealhunt> im not sure how to understand the ~
21:45:46 <haasn> therealhunt: asking your question once is enough
21:45:47 <levi> That means that you told it that it was polymorphic, but it inferred that it was monomorphic to Int.
21:45:58 <therealhunt> haasn: oh sorry it was telling me the name was in use loll
21:46:06 <therealhunt> haasn: figured that meant it wasnt sending
21:46:10 <levi> The ~ is a type equality operator.
21:46:11 <haasn> therealhunt: a ~ b essentially means “a and b is the same type”
21:46:26 <erisco_> > let x = 5 :: a in x
21:46:27 <lambdabot>  No instance for (GHC.Num.Num a2) arising from the literal `5'
21:46:27 <lambdabot>  Possible fix:
21:46:27 <lambdabot>    add (GHC.Num.Num a2) to the context of
21:46:27 <lambdabot>      an expression type signature: a2
21:46:27 <lambdabot>      or the inferred type of x :: a1
21:46:32 <jle`> what does "portable" mean on Hackage?  that it runs on most haskell compilers?  or that it compiles with GHC-family on all systems?
21:46:34 <erisco_> -.- well I tried
21:46:48 <haasn> therealhunt: for example, that error could arise if you are trying to write a function which is polymorphic over some ‘a’ but you are using the value as if it was an Int
21:46:56 --- mode: johnw set -b *!*@188.26.210.134
21:46:59 --- mode: johnw set -b *!*@188.26.210.56
21:47:09 <therealhunt> ah ok, i understand why thats happening, but i cant think of a solution
21:47:20 <haasn> therealhunt: that, unfortunately, depends on the problem
21:47:42 <haasn> it's not a typo or a simple fix; it's a logic error
21:47:49 <haasn> somewhere you are trying to do something that's impossible, and rightly so
21:47:51 <geekosaur> jle`: typically means works on all supported operating systems vs. being (say) posix only or windows only
21:47:59 <erisco_> levi, what case does that happen in? "Couldn't match expected type 'a' with actual type '[Char]'" happens too
21:48:06 <therealhunt> im trying to write a function to generate an identity matrix (http://pastebin.com/RyXGQFTy) but how do i do the list comprehension without needing the definite ranges
21:48:11 <therealhunt> which i think are the problem
21:48:12 <haasn> (unless of course it's a typo or a simple fix ;))
21:48:34 <therealhunt> haasn, lol unfortunately not
21:49:04 <haasn> therealhunt: how is ListMatrix defined?
21:49:11 <therealhunt> data ListMatrix d = MatrixV Int Int [[d]] | MatrixH Int Int [[d]] deriving (Eq)
21:49:26 <haasn> therealhunt: there's your problem; you are trying to pass ‘r’ and ‘c’ as parameters to the MatrixH constructor
21:49:27 <levi> erisco_: I'm not sure when exactly you get a ~ in the error and when you get 'expected type'.
21:49:56 <haasn> therealhunt: but in your type signature you specified that they should be polymorphic in all values of a!
21:50:06 <haasn> therealhunt: have you tried changing your first two ‘a’s to Int in the type signature of identity?
21:50:08 <therealhunt> oh my god im literally so stupid
21:50:18 <therealhunt> thanks haasn, i think thatll fix it
21:50:23 <haasn> I think so too :)
21:50:27 <therealhunt> hahha
21:50:32 <therealhunt> oh about fixing
21:51:11 <haasn> also you can use [[if x==y then 1 else 0 | x <- [1..c]] | y <- [1..r]] -- instead of introducing it as a local definition
21:51:16 <haasn> that might be a bit cleaner
21:53:43 --- mode: ChanServ set +o copumpkin
21:53:57 --- mode: copumpkin set -b *!~un_golan@*
21:55:58 <therealhunt> haasn, ah ofc! my mind must be running slow today
21:56:52 <copumpkin> o/ average
21:56:54 --- mode: copumpkin set -o copumpkin
21:57:14 <average> \o copumpkin , johnw
21:59:19 <haasn> erisco_: looks like the (|||) is just ‘either’, ie. it uses (->); so you can parse the global structure as something like:
21:59:52 <haasn> erisco_: from the Either b d we get, we retrieve our (a x d, x) from either the first lambda or the second lambda, depending on whether it's Left or Right
22:00:01 <haasn> (the result of that is fed into app which gives us the ‘d’)
22:00:08 <erisco_> haasn, ||| is either only for (->)
22:00:21 <haasn> yes, that's the instance used here
22:00:33 <erisco_> it isn't
22:00:50 <erisco_> it uses the instance of 'a'
22:01:18 <haasn> it is! try replacing the ||| by `either` in that code, type checks
22:01:28 <erisco_> I checked the type in ghci and it is not
22:01:59 <erisco_> if you replace with 'either', then of course the parametric 'a' reduces to just (->)
22:02:14 <haasn> erisco_: http://lpaste.net/101048
22:02:15 <haasn> load this in GHCi
22:02:18 <haasn> see for yourself
22:03:33 <erisco_> well I am confused
22:03:53 <haasn> erisco_: the structure is arr (l1 ||| l2) >>> app
22:03:56 <haasn> erisco_: where l1 and l2 are two lambdas
22:04:00 <haasn> (hence they are in -> already)
22:04:13 <erisco_> no l1 and l2 are arrows
22:04:15 <haasn> l1 is used to construct the correct arrow for the ‘left’ case, parametrized by ()
22:04:24 <haasn> erisco_: they are lambdas that *produce* arrows
22:04:30 <haasn> look at the (\b ->
22:04:32 <haasn> and the (\d ->
22:04:44 <haasn> the produced arrows are what ‘app’ ends up applying
22:04:48 <haasn> once with the >>> f >>> mixed in
22:04:50 <haasn> and once without
22:05:00 <erisco_> oh damn I misread the parens
22:05:52 <nh2> @faq Can Haskell read your mind?
22:05:52 <lambdabot> The answer is: Yes! Haskell can do that.
22:06:05 <erisco_> sorry haasn I see you're correct now
22:06:23 <haasn> erisco_: blame the writer of the function for using ||| instead of either
22:06:27 <haasn> and having such a confusing structure.
22:09:24 <Galactic> what is a good online judge system for haskell?
22:09:41 <erisco_> I'm glad you pointed that out because I won't be stuck for the next half hour wondering what is wrong
22:13:26 <haasn> Galactic: #haskell
22:13:54 <erisco_> haasn, it is certainly an interesting way to do branching
22:14:05 <Galactic> haasn: ?
22:16:27 <haasn> erisco_: I would probably rewrite the function as leftApp f = arr (\e -> (g e, () )) >>> app where g (Left b) = arr (const b) >>> f >>>> arr Left; g (Right d) = arr (const d) >>> arr Right
22:16:51 <haasn> oh, shouldn't that be um
22:17:02 <haasn> g (Right d) = arr $ const (Right d) -- the same as this?
22:17:18 <haasn> yeah, that line can be simplified
22:17:32 <haasn> I wonder if I should submit a patch :)
22:26:43 <therealhunt> anyone here use sublimetext?
22:26:57 <therealhunt> the lack of highlighting for guarded functions is so annoying
22:27:59 <nh2> therealhunt: please put it into https://github.com/SublimeHaskell/SublimeHaskell/issues/63
22:29:09 <therealhunt> nh2, oh cool ii didnt know i could do that
22:30:09 <therealhunt> so i need some advice, im parsing a command file with different lines, where each line has a command at the front and then arguments following, and i need to track a few different variables as i progress through the file, what should i do?
22:31:18 <johnw> you could use ParsecT over State
22:31:28 <erisco_> for the definition of bind, is this reasonable?  x >>= f = x >>> arr(\v -> (f v, ())) >>> app
22:31:52 <erisco_> :t \x f -> x >>> arr(\v -> (f v, ())) >>> app
22:31:53 <lambdabot> ArrowApply cat => cat a b -> (b -> cat () c) -> cat a c
22:33:53 <Kron> can anyone explain this oddness of the GHCi for me:
22:33:55 <Kron> ghci> let debug = ((flip trace) <*> show) :: Show a => a -> a
22:33:55 <Kron> ghci> :t debug
22:33:55 <Kron> debug :: () -> ()
22:34:13 <Kron> why won't it let me define debug?
22:36:07 <joelteon> monomorphism restriction
22:36:11 <joelteon> another victim ;(
22:36:24 <johnw> try: :set -XNoMonomorphismRestriction
22:36:37 <johnw> in 7.6 I think it's off by default in ghci
22:38:00 * hackagebot generic-church 0.1.0.0 - Automatically convert Generic instances to and from church representations  http://hackage.haskell.org/package/generic-church-0.1.0.0 (jozefg)
22:38:16 <therealhunt> @johnw im trying to avoid using libs (this is a learning project)
22:38:16 <lambdabot> Not enough privileges
22:38:24 <therealhunt> @johnw any other suggestions?
22:38:24 <lambdabot> Not enough privileges
22:39:24 <Welkin> you keep trigger the lambdabot
22:39:27 <Welkin> @
22:39:33 <Welkin> @lambda
22:39:33 <lambdabot>   unlambda: Parse error at end of file
22:39:48 <Welkin> @commands
22:39:48 <lambdabot> Unknown command, try @list
22:39:53 <Welkin> @list
22:39:53 <lambdabot> What module?  Try @listmodules for some ideas.
22:41:28 --- mode: johnw set -o johnw
22:41:42 <johnw> therealhunt: ah, then I don't have any
22:41:58 <gamegoblin> I want to concatenate two IO (Maybe String)'s (and return IO Nothing if either is nothing). Best way?
22:42:22 <johnw> liftM2 (++)
22:42:30 <gamegoblin> I tried that but the compiler seemed to yell at me...
22:42:37 <johnw> fmap (liftM2 (++))
22:42:44 <johnw> err
22:43:01 * hackagebot generic-church 0.1.0.1 - Automatically convert Generic instances to and from church representations  http://hackage.haskell.org/package/generic-church-0.1.0.1 (jozefg)
22:43:03 <johnw> one sec
22:43:09 <gamegoblin> would it be liftM2 (liftM2 (++)) ??
22:43:19 <johnw> perhaps
22:43:24 <gamegoblin> mmm yeah that compiles
22:43:26 <johnw> :t liftM2 (liftM2 (++))
22:43:26 <lambdabot> (Monad m, Monad m1) => m (m1 [a]) -> m (m1 [a]) -> m (m1 [a])
22:43:29 <johnw> yep
22:43:30 <gamegoblin> this is why I should use MaybeT
22:43:49 <gamegoblin> but I haven't quite wrapped my head around the details of monad transformers yet
22:44:01 <gamegoblin> So I'm left doing embarassing things like this in the mean time
22:49:12 <supki> :t (Control.Monad.Trans.Maybe.runMaybeT .) . (liftA2 (++) `on` Control.Monad.Trans.Maybe.MaybeT)
22:49:13 <lambdabot> (Monad m, Functor m) => m (Maybe [a]) -> m (Maybe [a]) -> m (Maybe [a])
22:49:34 <johnw> MaybeT is a decent transformer to start learning with
22:50:28 <therealhunt> can i use guards in a do block?
22:52:06 <Iceland_jack> @ty guard
22:52:07 <lambdabot> MonadPlus m => Bool -> m ()
22:52:26 <Iceland_jack> oh, you might want if guards
22:52:43 <augur> therealhunt: what kind of guards?
22:52:46 <Iceland_jack> using the multi-way if extension
22:53:08 <Iceland_jack> therealhunt: http://www.haskell.org/ghc/docs/7.6.3/html/users_guide/syntax-extns.html under section 7.3.16. Multi-way if-expressions
22:53:33 <augur> therealhunt: in a do block, you do this usually:   do { x <- mx ; guard (something involving x) errorValue ; more stuff }
22:54:03 <augur> oh no sorry
22:54:12 <augur> do { x <- mx ; guard (something involving x) ; more stuff }
22:54:37 <augur> guard p   is kind of like saying   if (!p) { return; }
22:55:20 <augur> some monads let you guard with an error using things like unless:    unless p err   is like   if (!p) { return err; }   sort of but not quite
23:04:53 <gamegoblin> So I'm trying to make my type TimeoutStream an insance of the Stream typeclass with
23:04:55 <gamegoblin> instance Stream TimeoutStream IO Char where
23:05:00 <gamegoblin> but ghc gives me the error
23:05:08 <gamegoblin> Illegal instance declaration for `Stream TimeoutStream IO Char'
23:05:09 <gamegoblin>       (Only one type can be given in an instance head.
23:05:34 <gamegoblin> Any way around it (without language extensions)?
23:05:55 <joelteon> no
23:08:18 <gamegoblin> so there is no way to fullfill
23:08:19 <gamegoblin> class Monad m => Stream s m t | s -> t
23:08:24 <gamegoblin> without language extensions?
23:08:42 <gamegoblin> also, what does the " | s -> t " mean at the end of that?
23:08:43 <apples`> there are already two language extensions in use there, you know :)
23:08:53 <gamegoblin> I didn't know
23:08:54 <apples`> it's a functional dependency
23:09:14 <gamegoblin> damn parsec folks and their use of language extensions
23:09:23 <gamegoblin> I feel weird using language extensions
23:10:03 <pavonia> You'll get used to it
23:10:19 <johnw> i use about 20 extensions regularly
23:10:28 <johnw> Haskell would seem different to me without them now :)
23:11:11 <gamegoblin> Even using overloaded strings feels weird to me :P
23:11:24 <johnw> that's usually the first one I enable :)
23:11:30 <gamegoblin> But I can justify that one as syntactic sugar
23:11:49 <johnw> justify to whom?
23:11:52 <gamegoblin> myself ;D
23:12:01 <johnw> are you wanting to write code that will run in HUGS or something?
23:12:07 <gamegoblin> Not really
23:12:23 <johnw> until things change, GHC *is* Haskell for me; so all I care about is how far back I want to be compatible with
23:12:55 <gamegoblin> It's just strange having things that aren't in the haskell spec, but since GHC has a virtual monopoly, they might as well be
23:13:04 * hackagebot hstradeking 0.1.0 - Tradeking API bindings for Haskell  http://hackage.haskell.org/package/hstradeking-0.1.0 (TravisAthougies)
23:14:53 <therealhunt> do you guys see any problems with http://pastebin.com/jRAYhz6m ?
23:14:53 <dmj`> johnw!
23:14:58 <johnw> dmj`!
23:15:01 <johnw> am I going to see you on Saturday?
23:15:13 <dmj`> of course, I'll be there
23:15:16 <johnw> nice
23:15:27 <gamegoblin> therealhunt: apt topic as I was just talking about a similar topic ;D
23:15:47 <apples`> therealhunt, you can wrap the [[a]] in a newtype and implement a Matrix instance for that instead
23:15:48 <johnw> so anytime I look at you and say, "Isn't that awesome?"  You can say, "Yes, yes it is!"
23:15:54 <gamegoblin> I think you might be able to newtype [[a]]
23:16:04 <gamegoblin> apples` beat me to it
23:16:09 <apples`> :)
23:16:20 <dmj`> johnw: haha, just hold up the applause sign :)
23:16:58 <therealhunt> that seems strange
23:17:06 <therealhunt> why is this not possible without new types in haskell
23:17:09 <dmj`> johnw: will def. be a lot of fun, should come to NYC too
23:17:16 <gamegoblin> therealhunt: deep voodoo in the haskell spec
23:17:33 <gamegoblin> theealhunt: and as I learned 5 minutes ago, language extensions probably are clearer and easier than newtypes
23:17:51 <augur> you should use newtypes for conceptual reasons
23:18:08 <augur> namely, sure, you think [[a]] is a good representation of matrices with a-type elements
23:18:12 <gamegoblin> therealhunt: just stick in a {-# LANGUAGE FlexibleInstances #-} in your code and you're good
23:18:14 <augur> but what if you decide theres a better way?
23:18:23 <augur> so you implement a new library?
23:18:39 <bitemyapp> oh my lord do not do matrix manipulation with [[a]]
23:18:49 <augur> if you use newtype, and you force people to go through your library's interfaces (smart constructors, etc.) then you have a common interface
23:18:52 <bitemyapp> there are vector and matrix libraries ;_;
23:19:02 <augur> a nice abstract barrier that prevents people from caring about your implementation choices
23:19:35 <augur> so instead you define newtype Matrix a = Matrix [[a]] and you have your interface functions
23:19:40 <johnw> plus, newtypes can better define the semantics of your intended use of the wrapped type
23:19:47 <augur> and you only export the type constructor and your interface functions
23:19:54 <johnw> for example, Text is always a Monoid, but not every use of Text is really a Moniod
23:19:56 <augur> and thats it. noone can care about your implementation details
23:20:13 <augur> johnw: yeah, that relates to abstract barriers really
23:20:23 <johnw> yep, newtypes++
23:20:24 <augur> abstract barriers are essentially your semantics
23:20:30 <augur> abstraction*
23:20:51 <augur> they say what its supposed to be, not how it achieves that
23:24:02 <therealhunt> augur, not sure i understand: If i define a newtype Matrix a = Matrix [[a]] wouldnt that break my typeclass?
23:24:20 <augur> therealhunt: no, why would it?
23:24:46 <therealhunt> well im not sure how i would go about implementing this new type in the class
23:24:49 <augur> therealhunt: oh i see, you're defining a matrix class, not a matrix type
23:25:48 <augur> i see. well, so type classes are ways of unifying different implementations of the same functionality
23:26:06 <therealhunt> augur, doesnt instance Matrix a imply that matrix is a class? sorry about my ignorance this is a learning project
23:26:21 <augur> yes, im not sure if there's a namespacing issue here
23:26:31 <augur> but ill pretend there isnt
23:26:55 <augur> but what i was responding to was really apples`'s suggestion for why you should use a newtype
23:27:02 <augur> you seem to have different goals
23:27:06 <therealhunt> also augur, i have my own data implementation of matrix but i figured i should implement [[a]] in the class just because it would work and might make testing easy
23:27:20 <gamegoblin> :t System.Timeout.timeout (return (Just ""))
23:27:21 <lambdabot>     Couldn't match expected type `Int'
23:27:21 <lambdabot>                 with actual type `m0 (Maybe [Char])'
23:27:21 <lambdabot>     In the return type of a call of `return'
23:27:26 <therealhunt> ah ok, lol then is it possible to use [[a]]?
23:27:34 <gamegoblin> :t System.Timeout.timeout 1 (return (Just ""))
23:27:35 <augur> therealhunt: i think thats probably the wrong way to go about it but
23:27:35 <lambdabot> IO (Maybe (Maybe [Char]))
23:27:54 <therealhunt> bitemyapp, im trying not to use libs and so far no ones mentioned any alternatives to [[a]] :/ (learning proj)
23:27:58 <augur> therealhunt: the specific problem you're having is that haskell type classes, at the basic level, can only be defined for certain kinds of things
23:28:36 <augur> therealhunt: as the error says: the basic haskell setup requires that when you do   instance C (...)
23:28:45 <augur> the ... has the form   TypeConstructor var1 var2 ...
23:28:55 <augur> with distinct var1 var2 ...
23:29:11 <augur> what you have is two layers of type constructors, not just one
23:29:28 <augur> as the error says, if you want this, you need the flexible instances flag
23:29:38 <augur> {-# LANGUAGE FlexibleInstances #-}   will make the error go away
23:29:51 <augur> as gamegoblin said :x
23:30:17 <augur> tho you should think hard about your reasons for wanting to have [[a]] as an instance of the Matrix class
23:30:33 <augur> sure, [[a]] is convenient as a way to make matrices, for instance
23:31:03 <augur> but should you say [[a]] IS a matrix, or do you want to instead say that there's a conventional way of building a matrix from a [[a]]?
23:31:53 <augur> eg, should you instead have:   class Matrix f a where fromList :: [[a]] -> f a
23:31:58 <therealhunt> so if im saying its a conventional way of building, which i think i am, im probably also saying that i want a function to
23:31:59 <therealhunt> yea
23:32:27 <augur> now, if you're only dealing with one implementation, you probably dont need a typeclass either
23:32:29 <therealhunt> augur, i guess theres no real need for a Matrix typeclass, because matrices arent really a class of data
23:32:35 <therealhunt> augur, !
23:32:52 <augur> typeclasses are useful only when you want to abstract further away from implementation and say "ill work with ANY implementation choice"
23:33:07 * hackagebot HLearn-classification 1.0.1.2 -   http://hackage.haskell.org/package/HLearn-classification-1.0.1.2 (MikeIzbicki)
23:33:12 <augur> well no matrices are a class of data, but the question is does that matter
23:33:18 <augur> for some tasks it might, right
23:33:38 <augur> the classic example from SICP is 2D coordinates
23:34:11 <therealhunt> augur, should i read sicp
23:34:15 <augur> one library might use cartesian representations with x and y, the other might use radial representations with theta and r
23:34:28 <augur> but you just care about having points
23:34:48 <augur> so you have a Point class, and you only use its class methods
23:35:05 <augur> therealhunt: yes, you should always read SICP
23:35:16 <therealhunt> augur, haha always?
23:35:18 <augur> always
23:35:23 <augur> every moment
23:35:26 <augur> even when you're asleep
23:35:26 <therealhunt> conveniently i have been
23:35:32 <therealhunt> since feoutus
23:35:39 <therealhunt> fetus
23:35:41 <therealhunt> *
23:36:29 <augur> there are at least two kinds of abstraction barriers, basically
23:36:31 <therealhunt> so then, why shouldnt [[a]] be a matrix
23:36:43 <therealhunt> or an implementation of one
23:36:44 <augur> type-level barriers, where you dont care about how the type does its thing, but you do know precisely the type
23:36:57 <augur> and class-y barriers, where you dont even care about the type
23:37:40 <therealhunt> ok
23:37:46 <therealhunt> i think i have a much better grip of this
23:37:46 <augur> the latter is only necessary when there is a need to have multiple representations at once
23:38:08 <therealhunt> in other news, ive just wasted 50 minutes on something that actually has nothing to do with this project thats due in the morning
23:38:46 <augur> if you're designing a tight little library and you dont need to have 10 different kinds of 2D point types, for instance, then you dont need a typeclass
23:39:19 <augur> but when you're combining multiple libraries, with their own internal representational demands that might be different from yours, type classes are the way to go
23:40:23 <therealhunt> augur, im always overambitious about the scope of my libraries
23:40:48 <augur> therealhunt: its sometimes good to write out your goals and sketch a birds eye view of things
23:41:19 <augur> what is the library for, what parts to users of the library need to know about to use it, etc.
23:41:32 <augur> also, who is it for
23:42:32 <therealhunt> augur, i think ive just stumbled upon a similar error,
23:42:44 <therealhunt> nevermind
23:42:46 <therealhunt> actually
23:43:06 <augur> who is important for the interfacing issue. "do we need a common way of using disparate representations?" only comes up if youre interfacing between things
23:44:34 <therealhunt> augur, im interfacing with myself at different points in time here, and in general i try to program as abstractly as is useful
23:44:53 <augur> right but i mean
23:45:16 <augur> the different points in time arent communicating back and forth with different notions of what a 2d point is, for instance
23:45:23 <augur> or what a matrix is
23:45:40 <augur> at any given moment, you have one notion of a matrix (whatever that notion is)
23:46:41 <augur> whereas if you were building a program that talks to, say, mathematic and also to a parallel processing manager thing, each of those might have different models of what a matrix is
23:46:49 <augur> because they might have different optimizations at work
23:47:04 <augur> so you would want an interface between those implementations
23:47:24 <augur> whereas you just need one implementation, and you need a way of ignoring the details
23:47:41 <augur> so for you, all you need is a single abstracted type, together with its interface functionality
23:48:07 <augur> you dont need to have different representations talking to one another
23:49:02 <therealhunt> augur, thats true
23:50:24 <therealhunt> is it possible to extend Functor without KindSignatures?
23:50:38 <augur> what do you mean?
23:51:18 <therealhunt> im playing around with having Functor a=> Matrix a (even though i agree this isnt neccessarry for my proj) and cant figure a way to get it buildable
23:51:45 <therealhunt> because i think having fmap in matrices is important
23:52:20 <augur> class Functor f => Matrix f a
23:52:50 <jle`> i'm putting a package on hackage and i noticed that my documentation links for the various modules aren't links...they are black
23:52:59 <jle`> anyone know how to make them links?
23:53:02 <jle`> http://hackage.haskell.org/package/tagged-binary-0.1.0.0/candidate
23:53:17 <augur> or if you have a different version of the matrix class, you could do   class Functor f => Matrix (f a)
23:53:28 <augur> but that requires language extensions
23:53:33 <augur> (i think?)
23:53:40 <augur> both do
23:54:44 <therealhunt> augur, so i need language extensions to extend functor at all?
23:54:58 <augur> no, but to have Matrix f a or Matrix (f a) you do
23:55:17 <haasn> augur: how is that even a valid class definition with any amount of extensions?
23:55:20 <therealhunt> how else could you extend functor but in that style
23:55:28 <augur> haasn: how isnt it?
23:55:29 <therealhunt> besides*
23:55:57 <haasn> augur: can you show me an example of a program in which “class Functor f => Matrix (f a)” is accepted?
23:56:14 <augur> accepted, or useful?
23:56:19 <haasn> accepted
23:56:43 <augur> ok:   `class Functor f => Matrix (f a) where`   with the appropriate extensions :)
23:56:53 <haasn> augur: which extensions?
23:56:54 <augur> its useless, it has no methods, but its accepted!
23:57:02 <augur> lemme poke at ghc, gimme a sec
23:57:04 <therealhunt> MultiParamTypeClass
23:57:11 <tbelaire> does cabal sandbox create a folder called —list-options when I'm using multiple projects in one sandbox?
23:57:12 <therealhunt> es
23:57:41 <therealhunt> im confused how Functor can exist at all without language extensions
23:57:52 <haasn> therealhunt: Functor is completely haskell98
23:57:55 <haasn> (it's even in haskell98)
23:58:09 <haasn> therealhunt: class Functor f where fmap :: (a -> b) -> f a -> f b
23:58:11 <haasn> is valid Haskell98
23:58:17 <anon_555> hi
23:59:54 <therealhunt> haasn, sure but it doesnt make sense to me that it requires extensions to have the typeclass require functorability
