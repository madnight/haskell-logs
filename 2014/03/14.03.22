00:02:04 <no-n> @pl \n -> replicate n n
00:02:04 <lambdabot> join replicate
00:02:11 <no-n> :t join
00:02:13 <lambdabot> Monad m => m (m a) -> m a
00:06:28 <aspidites> i must be insane
00:07:34 <aspidites> i know for a fact lenses, and monads (reader, writer, and state in particular) would make my life easier, but i'm doing without them for learning purposes
00:07:49 <aspidites> that and refactoring is ridiculously easy in haskell
00:11:44 <tanmaig> Hi! Can I create ad-hoc packages in a Haskell project? Something similar to __init__.py inside a folder in Python.
00:12:28 <tanmaig> So I can then use imports and qualified imports as I need.
00:14:42 <Twey> tanmaig: To produce the module Foo.Bar, create a file Foo/Bar.hs
00:15:13 <Twey> tanmaig: You can re-export existing modules with the syntax: module Foo.Bar (module Foo.Baz) where import Foo.Bar …
00:15:22 <tanmaig> Twey: Thanks, trying it out.
00:15:44 <Twey> tanmaig: Beware: that's relative to the current directory in GHCi
00:16:05 <Twey> If you're using Cabal, Cabal will set things up so that modules are found relative to the project root
00:16:14 <Twey> (with ‘cabal repl’)
00:17:05 <tanmaig> Twey: Ah. Exactly. I have foo/ foo2/ and I want to be able to import modules from foo for code in foo2.
00:33:47 <Twey> tanmaig: Module names should start with a capital letter, usually
00:34:29 <tanmaig> Twey: Oh sorry. Yep, so that would be Foo/ and Foo2/
00:35:13 <tanmaig> But short of using cabal there's no way to specify relative paths, or compile with ghc and ask it to include relative dirs during compiling?
00:41:27 <pordan30> If i wanted to install GHC 7.8 RC2 on a 64-bit system running a Debian derivative, I should compile from ghc-7.8.0.20140028-x86.64-unknown-linux-deb7 at haskell.org/ghc/dist/7.8.1-rc2 - correct?
00:43:43 <Twey> tanmaig: You shouldn't need to.  If it's under your package then you can reference it with ‘import Foo2’; if it isn't, then it should be in a separate package, and you can list it as a dependency for Cabal
00:43:56 <Twey> tanmaig: But you *can* use the -i flag to add a directory to the import path
00:52:04 * hackagebot tls 1.2.3 - TLS/SSL protocol native implementation (Server and Client)  http://hackage.haskell.org/package/tls-1.2.3 (VincentHanquez)
00:52:06 * hackagebot tls-debug 0.3.1 - Set of programs for TLS testing and debugging  http://hackage.haskell.org/package/tls-debug-0.3.1 (VincentHanquez)
01:16:46 <johannesbodannes> Are developers of hackage packages generally receptive to volunteer contributors? Is there an etiquette?
01:17:27 <alpounet> johannesbodannes: this depends pretty much on authors, but the huge majority is VERY receptive to contributions
01:19:10 <ZettaBlade> it is open source, after all. You get the corner cases, but I imagine most authors would be glad to see some contributions.
01:19:21 <johannesbodannes> Cool, awesome.
01:20:12 <Welkin> that is the point of open source, after all
01:20:53 <Welkin> a bazaar rather than a cathedral
01:27:07 * hackagebot HaRe 0.7.1.7 - the Haskell Refactorer.  http://hackage.haskell.org/package/HaRe-0.7.1.7 (AlanZimmerman)
01:31:43 <allspark> if i create a small console app, can i post it on hackage?
01:33:23 <pavonia> If you think it might be useful to others too, sure
01:34:42 <allspark> i thought hackage was a place to host haskell libraries, not apps
01:34:52 <alpounet> it's for both
01:34:59 <alpounet> xmonad is hosted there, for example
01:35:30 <alpounet> the point is to be able to install a package, library or executable, with 'cabal install <foo>'
01:41:32 <allspark> how do you create a variable that needs an annotation for it to work, like maxBound?
01:43:35 <pordan30> like: 'let x = maxBound :: Int'?
01:44:19 <allspark> yeah
01:46:09 <pordan30> what's wrong with either an explicit type annotation or inference (where applicable)?
01:48:35 <allspark> I'm not trying to use it anywhere. Just curious as to how it was created?
01:51:25 <pordan30> maxBounded is a member of the type class Bounded; there are instance of Bounded for many bounded types, including the integral types. you can see the definition here: http://hackage.haskell.org/package/base-4.6.0.1/docs/src/GHC-Enum.html#Bounded
01:56:19 <pordan30> allspark: for instance, the implementation of maxBound for Int can be found here: http://hackage.haskell.org/package/base-4.6.0.1/docs/src/GHC-Int.html. if you search through the GHC-x files in /docs/src at that link, you can find other implementations.
01:57:09 * hackagebot old-locale 1.0.0.6 - locale library  http://hackage.haskell.org/package/old-locale-1.0.0.6 (HerbertValerioRiedel)
01:57:56 <pordan30> "Int" -> "integer types", sorry
02:00:33 <allspark> does the 'a' affect both in  minBound, maxBound :: a
02:03:14 <ski> that type signature applies to both `minBound' and `maxBound', yes
02:07:41 <allspark> I get it now. It's a class member not a variable
02:14:16 <Zolomon> What is the difference between performing an IO action and evaluating an IO action?
02:14:44 <jle`> Zolomon: similar to the difference between compiling a program and running it, perhaps?
02:15:09 <jle`> more accurately, it would be evaluating and expanding all the function calls, etc.
02:15:26 <jle`> you know, sequence [putStrLn "hello",putStrLn "world"]
02:15:30 <jle`> @src sequence
02:15:30 <lambdabot> sequence []     = return []
02:15:30 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
02:15:30 <lambdabot> -- OR: sequence = foldr (liftM2 (:)) (return [])
02:15:49 <Zolomon> jle`: The latter you mean?
02:16:03 <SrPx> Hey, does anyone know what could be causing this? http://lpaste.net/101583
02:16:19 <jle`> when you do something like f x = x * 3, would you say is the act of evaluating f 8?
02:16:30 <Zolomon> no
02:16:51 <jle`> *what would you say
02:17:07 <jle`> basically, to evaluate f 8, you would look at the definition f x = x * 3
02:17:12 <jle`> then you would replace all x's with 8
02:17:14 <jle`> 8 * 3
02:17:20 <jle`> then evaluate 8 * 3 to get 24
02:17:32 <jle`> that is the evaluation of let f x = x * 3 in f 8
02:17:45 <Zolomon> Ah, so the performing part is the step before evaluation?
02:17:55 <jle`> no, we aren't performing anything here
02:18:10 <Zolomon> Ok. *ponders*
02:18:11 <jle`> well, kinda not
02:18:20 <jle`> everything in haskell is an expression, right
02:18:22 <jle`> ?
02:18:25 * Zolomon nodnods.
02:18:30 <jle`> how would you simplfy something like foldr (+) 0 [1,2,3] ?
02:18:34 <jle`> @src foldr
02:18:34 <lambdabot> foldr f z []     = z
02:18:34 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
02:18:53 <Zolomon> 6 ?
02:18:56 <pordan30> 'f = \x -> x + 3' is a definition of the function 'f'. evaluation of 'f' at an argument, say 'n', means applying 'n' to 'f' and reducing the resultant expression in accord with a set of rules.
02:19:19 <jle`> foldr (+) 0 [1,2,3] = (+) 1 (foldr r 0 [2,3])
02:19:36 <jle`> = (+) 1 ((+) 2 foldr (+) 0 [2])
02:19:38 <jle`> etc. etc.
02:19:46 <jle`> that's evaluating a function call
02:20:08 <Zolomon> Right
02:20:16 <jle`> you can evaluate out foldr (+) 0 [1,2,3] by hand actually
02:20:16 <SrPx> nobody has an idea? ):
02:20:19 <jle`> and in the end you get a number
02:20:38 <jle`> SrPx: is [Float] an instance of Marshal?
02:20:49 <SrPx> jle`: what is a Marshal?
02:21:12 <jle`> SrPx: presumably some typeclass used by wherever you got the 'export' functino from
02:21:19 <SrPx> ):
02:21:20 <jle`> Zolomon: so, the same deal is for evaluating IO
02:21:43 <jle`> let's look at the simple IO action operator (>>)
02:21:49 <jle`> (>>) :: IO a -> IO b -> IO b
02:21:51 * Zolomon nodnods
02:22:00 <jle`> it takes two IO actions, and returns a new IO action
02:22:36 <jle`> so evaluating x >> y would involve 'creating' that new IO action
02:22:41 <jle`> that does x and then y
02:22:53 <jle`> so if you do x >> y, you get a new IO action
02:23:00 <jle`> say xy = x >> y
02:23:04 <jle`> and if you have an IO action z
02:23:07 <jle`> you ca do xy >> z
02:23:13 <jle`> which returns a new IO action
02:23:30 <jle`> that encodes the idea of doing xy first, then z
02:23:37 <Zolomon> Yes
02:23:43 <jle`> evaluating it would be *creating* that IO action
02:23:51 <jle`> that synthesized IO action/command blob
02:24:03 <jle`> if you imagine (IO a) as a little packet of C code, perhaps, it might be clearer
02:24:07 <jle`> if x and y are little packets of C code
02:24:12 <jle`> x >> y would return a new packet of C code
02:24:17 <jle`> that does what x does, then what y does
02:24:21 <Zolomon> Yes
02:24:30 <jle`> the evaluation part would be the act of generating that new merged C code packet
02:24:37 * Zolomon lays it out in front of his inner eye.
02:24:45 <jle`> and that's cool and fun
02:24:51 <jle`> now, when you compile a haskell program
02:25:09 <jle`> the compiler looks at a specific "c code packet", a specific IO blob
02:25:15 <jle`> that has been assigned the name 'main', by you
02:25:35 <jle`> and it basically compiles whatever IO blob has been named main
02:25:38 <jle`> into an executable
02:25:59 <jle`> so if you say main = x, then it compiles that IO blob/c code packet/instruction packet x into an executable
02:26:38 <jle`> if you say main = x >> y, it will first create a 'combined' IO blob/c code packet (from x and y), and then it'll compile that into an executable
02:26:59 <jle`> and that creation part is the evaluation
02:27:06 <jle`> now, you have an executable
02:27:39 <jle`> and your computer, being some sort of von neumann architecture with an instruction set known to ghc, will be able to understand that executable and run it on its hardware
02:27:47 <jle`> that part is the execution
02:28:33 <Zolomon> Aah
02:28:59 <jle`> haskell's job is to combine, merge, synthesize, compose io actions and represent them in some way; the compiler's job is to look at that io action representation and translate it into machine language; your computer's job is to run that machine code
02:29:02 <Zolomon> So any side effects only happen when performing IO actions, not when being evaluated for example?
02:29:20 <jle`> yes, the evaluation and the execution/performing are completely separate acts
02:29:29 <jle`> evaluation is pure
02:29:39 <jle`> just like evaluating foldr (+) 0 [1,2,3] is pure
02:29:43 <jle`> evaluating x >> y will always be pure
02:29:48 <jle`> it'll always return the same c packet
02:29:53 <jle`> the same combined io data structure
02:30:01 <jle`> without any side-effects
02:30:27 <jle`> the combined IO action that it creates is pure, and the process of combining x >> y does not have any side-effects (at the language level, at least)
02:30:47 <jle`> er, it creates the combined IO action in a pure way is what i meant
02:31:03 <jle`> putStrLn "hello" >> putStrLn "world" will always create the exact same IO action
02:31:14 <Zolomon> Thank you so much! I feel like I comprehend this much better now. Am reading about IO in RWH at the moment.
02:31:30 <jle`> getLine >>= putStrLn will always create the same IO action
02:31:38 <jle`> even though when you *execute* it, it'll behave differently
02:31:40 * Zolomon nodsnods.
02:31:42 <jle`> the IO action that it creates will always be the same
02:31:44 <jle`> no problem :)
02:32:00 <Zolomon> jle`: By the way, do you work as a teacher?
02:32:06 <jle`> i do not
02:32:24 <Zolomon> jle`: Your examples are very pedagogical and enlightening. :)
02:32:46 <jle`> haha. thanks. it is only the result of having explained it many times
02:32:56 <jle`> and also from hearing the explanation of others on this channel
02:35:16 <yesthisisuser> i find it a bit confusing with all these different I/O libraries.. streams, pipes, conduit, iteratee I/O..
02:35:45 <jle`> yesthisisuser: too much choice ... ?
02:36:48 <yesthisisuser> yes maybe.. but i need to learn more and i don't know really where to start
02:37:05 <jle`> why the sudden impetus to learn all of them?
02:37:35 <jle`> there are good pipes and conduit introductions
02:37:45 <jle`> http://hackage.haskell.org/package/pipes-4.1.0/docs/Pipes-Tutorial.html
02:38:01 <jle`> https://www.fpcomplete.com/school/to-infinity-and-beyond/pick-of-the-week/conduit-overview
02:38:14 <pordan30> if i recall correctly, there was a good tutorial article in 'the monad reader' on iteratee i/o several years ago
02:39:11 <yesthisisuser> but all of these have in common that they aim to separate producer/consumer.. that's the basic idea or
02:39:31 <jle`> hm. that's not necessarily their aim
02:40:18 <pordan30> "This document aims to provide an in-troduction to enumeration-based I/O by constructing an iteratee library from first principles": http://themonadreader.files.wordpress.com/2010/05/issue16.pdf
02:40:58 <yesthisisuser> oh. great. thanks..
02:47:13 * hackagebot old-time 1.1.0.2 - Time library  http://hackage.haskell.org/package/old-time-1.1.0.2 (HerbertValerioRiedel)
03:42:48 <skypers> http://lpaste.net/2212455787245076480 lines 43 to 45, anyone knows how I could put the Show constraint for those?
03:46:21 <ClaudiusMaximus> skypers: instance Show a => Show (E a) where  -- just guessing...
03:46:45 <skypers> ClaudiusMaximus: no it doesn’t work
03:46:52 <skypers> it breaks at Vec2 if I do that
03:47:03 <skypers> I don’t fully understand why
03:49:32 <ClaudiusMaximus> skypers: ah,  maybe (Show a, Show (a,a), Show (a,a,a), Show (a,a,a,a)) =>   but that's just another guess..
03:49:35 <klrr_> when dealing with IRC is it just ASCII? is it fine to simply use Data.ByteString.Char8 or is it better or more idomatic to use Data.Text for this?
03:50:30 * zipper will now use containers. Just missed cabal hell by a whisker.
03:50:37 <Saizan> klrr_: it really isn't just ascii, though tbf you have no guarantee about the encoding
03:51:01 <Saizan> klrr_: defaulting to utf8 will probably be ok on networks like freenode though
03:51:30 <skypers> ClaudiusMaximus: huh
03:51:45 <Saizan> (and you want to use Text for that, Char8's hack corresponds to latin1)
03:53:03 <ClaudiusMaximus> klrr_: the irc protocol is ascii mixed with unspecified character encodings for message content, so bytestring might be more appropriate than text here (with judicious guessing at utf-8 with fallback that doesn;t crash your code with unexpected encodings)
03:56:31 <ClaudiusMaximus> skypers: my reasoning for that is that instance resolution works "backwards", so using  Foo a => Bar a  means "i want a Bar a, so now I need a Foo a to make it work"
03:57:18 * hackagebot hoopl 3.10.0.0 - A library to support dataflow analysis and optimization  http://hackage.haskell.org/package/hoopl-3.10.0.0 (HerbertValerioRiedel)
03:58:32 <ClaudiusMaximus> skypers: but i'm not familiar with GADTs, so i'm probably missing something
04:01:38 <klrr_> Saizan, ClaudiusMaximus: thanks
04:02:02 <klrr_> another questoin, what is the appropriate exception to throw if a connection is lost?
04:02:19 * hackagebot webkitgtk3 0.12.6.0 - Binding to the Webkit library.  http://hackage.haskell.org/package/webkitgtk3-0.12.6.0 (HamishMackenzie)
04:02:21 * hackagebot cpphs 1.18.4 - A liberalised re-implementation of cpp, the C pre-processor.  http://hackage.haskell.org/package/cpphs-1.18.4 (MalcolmWallace)
04:02:23 * hackagebot webkit 0.12.6.0 - Binding to the Webkit library.  http://hackage.haskell.org/package/webkit-0.12.6.0 (HamishMackenzie)
04:03:52 <skypers> ClaudiusMaximus: thank you anyway
04:11:48 <zipper> skypers: Down with skype
04:12:19 * hackagebot ghcjs-dom 0.0.7 - DOM library that supports both GHCJS and WebKitGTK  http://hackage.haskell.org/package/ghcjs-dom-0.0.7 (HamishMackenzie)
04:26:31 <testeree> hi, is there a way to find which libraries provides a given namespace?
04:28:05 <joachifm> testeree: have you tried ghc-pkg find-module ?
04:28:38 <joachifm> testeree: hoogle/hayoo can be of help, too
04:28:58 <testeree> joachifm, thanks . that works.
04:31:11 <testeree> i am on archlinux and the default ghc the distro provides doesn't install the docs and is there a way to install the docs manually for all installed modules?
04:32:43 <testeree> is reinstalling the only option?
04:34:57 <joachifm> testeree: for me, cabal's docindex contains haddocks for all Haskell packages, both those I've installed via cabal-install and those provided by the arch repo. this includes base, ghc-prim, etc.
04:35:56 <joachifm> i.e., ~/.cabal/share/doc/index.html serves all my documentation needs ...
04:36:38 <Guest85928> Hey! Is it possible to apply a function like uncurry n-times? For example: uncurry^3 :: (a->b->c->d->e) -> (a,(b,(c,d)))->e
04:37:22 * hackagebot hpc 0.6.0.1 - Code Coverage Library for Haskell  http://hackage.haskell.org/package/hpc-0.6.0.1 (HerbertValerioRiedel)
04:39:22 <int-e> @type (!! ?n) . iterate ?f -- but this restricted to functions of type c -> c
04:39:23 <lambdabot> (?n::Int, ?f::c -> c) => c -> c
04:39:36 <Krakarn> :t uncurry . uncurry . uncurry
04:39:37 <lambdabot> (a -> b2 -> b1 -> b -> c) -> (((a, b2), b1), b) -> c
04:41:33 <Guest85928> int-e: thx for the code...
04:43:26 <Guest85928> @pl (a,(b,(c,d))) -> f a b c d
04:43:26 <lambdabot> (line 1, column 17):
04:43:26 <lambdabot> unexpected '>'
04:43:26 <lambdabot> expecting operator
04:43:34 <Guest85928> @pl \ (a,(b,(c,d))) -> f a b c d
04:43:35 <lambdabot> uncurry ((`ap` snd) . (. fst) . flip flip snd . (ap .) . flip flip fst . ((.) .) . f)
04:45:25 <skypers> @hoogle Data.Vector
04:45:26 <lambdabot> package vector
04:45:26 <lambdabot> package vector-algorithms
04:45:26 <lambdabot> package vector-binary
04:45:32 <skypers> ah, I thought it was containers
04:45:37 <skypers> :)
04:47:22 * hackagebot clifford 0.1.0.9 - A Clifford algebra library  http://hackage.haskell.org/package/clifford-0.1.0.9 (spacekitteh)
05:02:23 * hackagebot clifford 0.1.0.10 - A Clifford algebra library  http://hackage.haskell.org/package/clifford-0.1.0.10 (spacekitteh)
05:02:25 * hackagebot hsimport 0.2.11 - A command line program for extending the import list of a Haskell source file.  http://hackage.haskell.org/package/hsimport-0.2.11 (DanielTrstenjak)
05:16:07 <Guest85928> @pl \ (a,(b,(c,d))) -> (a, b, c, d,)
05:16:08 <lambdabot> (line 1, column 22):
05:16:08 <lambdabot> unexpected ","
05:16:08 <lambdabot> expecting letter or digit, variable, "(", operator or ")"
05:16:13 <Guest85928> @pl \ (a,(b,(c,d))) -> (a, b, c, d)
05:16:13 <lambdabot> uncurry ((`ap` snd) . (. fst) . flip flip snd . (ap .) . flip flip fst . ((.) .) . (,,,))
05:22:25 * hackagebot haskell98 2.0.0.3 - Compatibility with Haskell 98  http://hackage.haskell.org/package/haskell98-2.0.0.3 (HerbertValerioRiedel)
05:29:11 <haskell_newb> hello
05:29:11 <Athas> g.
05:29:26 <Krakarn> hi
05:29:45 <haskell_newb> i installed https://github.com/valderman/haste-compiler from cabal and trying to build https://github.com/valderman/haste-compiler/tree/master/examples/chatbox
05:29:59 <haskell_newb> but getting Could not find module `Haste.App.Concurrent'
05:30:05 <haskell_newb> how can i fix it?
05:38:32 <haskell_newb> ah, having outdated haste
05:42:13 <ski> Guest85928 : `pl' on tuples rarely gives nice solutions. you're better off hand-pointlessing it, if you insist
05:42:26 * hackagebot cabal-bounds 0.3 - A command line program for managing the bounds/versions of the dependencies in a cabal file.  http://hackage.haskell.org/package/cabal-bounds-0.3 (DanielTrstenjak)
05:47:27 * hackagebot haskell2010 1.1.2.0 - Compatibility with Haskell 2010  http://hackage.haskell.org/package/haskell2010-1.1.2.0 (HerbertValerioRiedel)
05:50:24 <int-index> I came up with a combinator like this: (f >>|= g) x = f x >>= g x
05:50:37 <int-index> Looks like something I could find in a combinator library
05:51:03 <int-index> Is it in some package?
05:51:18 <bennofs> int-index: that's (f >=>) . g
05:51:19 <hpc> :t \f g x -> f x >>= g x
05:51:21 <lambdabot> Monad m => (t -> m a) -> (t -> a -> m b) -> t -> m b
05:51:38 <bennofs> :t \f g -> (f >=>) . g
05:51:39 <lambdabot> Monad m => (a1 -> m b) -> (a -> b -> m c) -> a -> a1 -> m c
05:51:52 <bennofs> or maybe not
05:52:09 <hpc> x is the same in both places
05:52:18 <bennofs> :t liftA2 (>>=)
05:52:19 <lambdabot> (Monad m, Applicative f) => f (m a) -> f (a -> m b) -> f (m b)
05:52:34 <bennofs> :t liftA2 (>>=) `asTypeOf` (\f g x -> f x >>= g x)
05:52:34 <lambdabot> (Monad m, Applicative ((->) t)) => (t -> m a) -> (t -> a -> m b) -> t -> m b
05:52:37 <hpc> ah, that's the one
05:52:52 <int-index> Excellent! Thank you.
05:59:29 <joneshf-laptop> that looks like a monadic version of on
06:01:06 <joneshf-laptop> :t \f g x -> ((>>=) <$> f <*> g) x
06:01:06 <lambdabot> (Monad m, Applicative ((->) t)) => (t -> m a) -> (t -> a -> m b) -> t -> m b
06:34:28 <no-n> is it better to use fst . unzip or map fst?
06:37:01 <ainieco> hi, trying out cabal sandboxes, i made my sandbox with "cabal sandbox init" and then "cabal install" but everything was installed into ~/.cabal how can i tell it to install everything in sandbox?
06:37:25 <ainieco> since it doesn't make much sense to have sundob and still install deps and stuff into ~/.cabal
06:41:04 <ainieco> hm, i was wrong, everything works fine
06:48:41 <hc> i have "[...] ++ (unpack iLineName) sclass ++ [...]". hlint complains about the brackets, but the compiler needs them
06:48:52 <hc> (HLint v1.8.53)
06:49:04 <bennofs> hc: you don't need brackets around (unpack iLineName)
06:49:38 <daimonos> Slow internet will kill me.
06:49:49 <hc> hmm, right, i guess i messed up the code while fixing hlint errors
06:50:29 <hc> yeah, the original line was \"" ++ (unpack $ iLineName sclass) ++ "\";\n" ++; first hlint suggested to remove the $
06:50:42 <hc> but that doesn't work,because unpack needs only one argument...
06:50:46 <daimonos> :k Either e
06:50:48 <lambdabot> Not in scope: type variable `e'
06:51:08 <daimonos> :k Either
06:51:09 <lambdabot> * -> * -> *
06:51:16 <daimonos> :k (Either e)
06:51:16 <bennofs> hc: write unpack (iLineName sclass) instead of (unpack $ iLineName sclass)
06:51:17 <lambdabot> Not in scope: type variable `e'
06:51:25 <hc> ah, ok
06:51:33 <daimonos> :k Either -> e
06:51:34 <lambdabot> Not in scope: type variable `e'
06:51:45 <hc> yeah, that does work, thanks!
06:51:47 <bennofs> hc: so: .. ++ unpack (iLineName sclass) ++ ...
06:52:25 <bonnechance> Why do I get an error on: let a = [2,4,8..200]
06:52:27 <khyperia> Does anyone know System F and/or System IF typechecking that I could discuss with? I'm trying to implement a compiler for my own language, and I'm pretty lost - the papers are very hard to read for me.
06:52:34 <daimonos> :k Either Int
06:52:35 <lambdabot> * -> *
06:52:44 <daimonos> ;)
06:56:18 <khyperia> :k forall e. Either e
06:56:18 <lambdabot> * -> *
06:56:53 <khyperia> Huh. That's not `* -> * -> *`? I thought forall was sort of like a type lambda, as in System-F style type lambda
07:08:31 <NikolajK> What is the most true-to-the-maths comprehensive Haskell package? For groups and graphs say. I mean implementations where, if I know the math already, e.g. they type declarations tell me what's going on.
07:09:00 <ski> khyperia : `forall' is not like a type lambda
07:09:14 <byorgey> khyperia: it is, but forall is a bit strange in Haskell because it's implicit
07:09:16 <ski> still, it's surprising that that kindchecks, i think
07:09:19 <NikolajK> "HaskellForMaths package"? That what comes up in Hackage under google
07:09:34 <ainieco> http://hackage.haskell.org/package/fgl-5.4.2.4/docs/src/Data-Graph-Inductive.html is it a good practive to export modules like that?
07:09:39 <ainieco> practice*
07:09:41 <khyperia> wait, ski, byorgey, I'm confused - which one of you is right?
07:09:51 <ski> khyperia : both ?
07:10:11 <khyperia> Hrm. So it is a type lambda, but it isn't, but it's something strange...
07:10:13 <ski> hm
07:10:47 <ainieco> i'm concerned about shadowing
07:10:53 <ski> khyperia : oh. well, *terms* having a universal type (one of shape `forall a. ..a..') could perhaps be said to have an (implicit) type lambda -- i assume this is what byorgey meant
07:11:24 <ski> otoh, a lambda at the type level would be another thing, distinct from `forall', if it existed in Haskell
07:11:40 <khyperia> Right. Is there a difference between when the user writes "forall" and when the compiler automatically injects foralls for free type variables?
07:11:44 <byorgey> ah, yes, that's what I meant.  ski is right.
07:12:17 <byorgey> khyperia: no, except that with extensions like RankNTypes you can write forall in places the compiler wouldn't automatically inject them.
07:12:17 <ski> khyperia : both mean the same thing
07:12:26 <khyperia> Ah.
07:12:40 <khyperia> So then why is "forall a. Either a" different from "Either"?
07:13:36 <khyperia> since it seems like it's just an eta-reduction/expansion
07:13:45 <byorgey> because ski is right and forall isn't a type lambda.
07:14:03 <khyperia> Right...
07:14:07 <byorgey> lambda a. Either a  (if Haskell had such a thing) would be the same as Either.
07:15:03 <ski> khyperia : also, i'm not sure why `forall a. Either a' is kind correct at all
07:15:18 <byorgey> instead, forall is the *type* of a type lambda at the term level.  For example,  /\ (a :: *) -> \(x :: a) -> x  has type  forall (a :: *). a -> a
07:15:19 <khyperia> so... forall is a magical thing that eliminates a free variable and says sort of like "this can be anything"?
07:15:57 <khyperia> Right... lemme try and comprehend that, byorgey
07:16:01 <ainieco> for example i have Data.MyData.Stuff, what should i put in Data/MyData.hs ?
07:16:08 <ainieco> what are conventions are?
07:16:18 <ski> khyperia : in the basic view. if `..a..' has kind `*', with the tyvar `a' having some kind `k', then `forall (a :: k). ..a..' has kind `*', and doesn't have `a' a free type variable
07:16:57 <ski> khyperia : note that both `..a..' and the whole `forall (a :: k). ..a..' here must have kind `*'
07:17:10 <ski> (because only values can be polymorphic, so to speak)
07:17:50 <khyperia> "must have kind `*'" as in "not `* -> *'" or "not something else"?
07:17:53 <ski> for some reason it appears GHC has generalized this to allow `..a..' and `forall (a :: k). ..a..' to have some common kind `k1', which need not be `*'
07:17:55 <byorgey> ainieco: you don't have to.  This kind of re-exporting modules is usually done just so that users of a library can import a single module and get a bunch of stuff which is defined in separate modules.
07:18:00 <ski> khyperia : yes
07:18:10 <byorgey> ainieco: but other than that it's not required or standard to re-export lower-level modules from higher ones.
07:18:14 <ski> khyperia : as is : not anything else than `*'
07:18:22 <khyperia> Right.
07:18:40 * byorgey agrees with ski that it's strange that  forall a. Either a  kind-checks at all
07:18:41 <ainieco> byorgey: thanks
07:19:35 <ski> presumably, if you have `forall (a :: k). ..a..' of kind `k0 -> k1', and `tau' with kind `k0', then `(forall (a :: k). ..a..) tau' of kind `k1' is seen as an abbreviation for `forall (a :: k). (..a..) tau' (iow "lifting the `forall' outside the application)
07:20:39 <ski> i suspect that `..a..' and `forall (a :: k). ..a..' here is allowed to have some other kind than `*' is experimental, and related to the `PolyKinds' extension
07:21:10 <ski> either that, or it's simply a bug
07:21:56 <ainieco> are there any "stylish-haskell"-likes for cabal file?
07:22:08 <ski> khyperia : you're probably best off to think of the body and the whole of a universal type as being required to have kind `*'
07:22:14 <ainieco> i want to automatically align everything there like stylish-haskell does for "hs" files
07:22:57 <khyperia> Righto. Thanks for the help, ski, theory stuff like this is what I love about haskell/programming languages!
07:25:28 <ski> khyperia : you can basically think of `forall (a :: k). ..a..' as if it said `Pi (\(a :: k) -> ..a..)', where `Pi' has kind `(k -> *) -> *' (or really `Pi :: forall k. (k -> *) -> *' -- `Pi' is polymorphic !)
07:26:10 <ski> where `\(a :: k) -> ..a..' is a lambda expression on the type level, taking a type `a' as input (which incidentally must have kind `k') and returns the type `..a..', depending on `a'
07:27:42 <ski> khyperia : also note that e.g. the type of `length', `forall (a :: *). [a] -> Int', is *not* polymorphic. `length' is polymorphic, its type isn't (one might say it's "universal", perhaps)
07:31:05 <ski> @undefineotoh, if you define e.g. `newtype Dup f a = MkDup (f a a)', one could conceivably assign not just the kind `(* -> * -> *) -> (* -> *)' to `Dup' but also e.g. the kind `((* -> *) -> (* -> *) -> *) -> ((* -> *) -> *)'
07:31:05 <lambdabot> Unknown command, try @list
07:31:16 <ski> s/@undefine//
07:31:51 <ski> because the definition of `Dup' doesn't constraint the kind of `a' in any way, except that it must be the same as the two argument kinds for `f'
07:32:21 <ski> iow, we could imagine `Dup :: (k -> k -> *) -> (k -> *)', for any kind `k'
07:33:00 <ski> or more explicitly, `Dup :: forall k. (k -> k -> *) -> (k -> *)', so here `Dup' *is* a polymorphic type (which naturally then has a universal kind)
07:33:20 <ski> khyperia : does that help ?
07:33:31 <khyperia> Yeah, a bunch... going to take a bit to comprehend it, but yeah
07:37:53 <ainieco> i'm trying to generate haddock documentation for my sandboxed cabal project but i'm gettig "could not find link destinations for: Data.UUID.Internal.UUID" warnings constantly
07:37:56 <ainieco> how can i fix it?
07:38:17 <khyperia> ski, okay, I'm a bit confused by the `length' example - does "universal" just mean something like "*"?
07:38:41 <khyperia> or... hrm... I have a thought in my head of what it means, but it's hard to express in words.
07:39:04 <ski> i use `universal' as an adjective to mean that it starts with `forall', it has `forall' on the "outside"
07:39:33 <ski> like "function type", means a type of the shape `... -> ...', so with `(->)' "on the top"
07:39:57 <ski> (not to be confused with a type function, like `Maybe' and `Either Int')
07:43:44 <khyperia> I'm still kinda confused, could you give me an example of a polymorphic type and a not-polymorphic-type? So `length' is not polymorphic type, and... `Either Int' is polymorphic? Because it takes another type variable or something?
07:43:47 <huljovm> Why do I get an error on: let a = [2,4,8..200]
07:43:57 <hpc> length is polymorphic
07:43:59 <hpc> :t length
07:44:01 <lambdabot> [a] -> Int
07:44:12 <khyperia> hpc, polymorphic in the type
07:44:23 <hpc> length is a value with polymorphic type
07:44:24 <geekosaur> huljovm, that syntax is not general like that
07:44:26 <khyperia> hpc, look at ski's comment a bit ago
07:44:58 <khyperia> right before the @undefineotoh typo :P
07:45:49 <hpc> oh, i see
07:46:06 <hpc> he's just gone up a level to kind polymorphism
07:46:11 <khyperia> yeah
07:46:28 <geekosaur> there are certain specific cases that translate to calls in the Enum typeclass: enumFrom, enumFromThen, enumFromTo, enumFromThenTo. [2,4,8..200] doesn't match any of them
07:46:58 <huljovm> geekosaur: ??
07:47:12 <geekosaur> what confuses you about this?
07:47:34 <ski> khyperia : `length' is not a type, so obviously can't be a polymorphic type
07:47:37 * hackagebot clifford 0.1.0.11 - A Clifford algebra library  http://hackage.haskell.org/package/clifford-0.1.0.11 (spacekitteh)
07:48:15 <ski> khyperia : the type `Int -> Bool' is not a polymorphic type. the type `forall (a :: *). [a] -> Int' (which just so happens to be the type of `length') is also not a polymorphic type
07:48:33 <huljovm> geekosaur: Your explanation confuses me.
07:49:05 <ski> hpc : i'd say `length' is a polymorphic value
07:49:06 <geekosaur> the exact forms allowed are: [x..], [x, i..], [x..y], [x, i..y] corresponding to enumFrom x, enumFromThen x i, enumFromTo x y, enumFromThenTo x i y
07:49:37 <huljovm> geekosaur: Do you know of a good online source which could better explain what you're saying? (It's okay if you don't, I'm already googling.)
07:50:19 <geekosaur> I don't see what is difficult about [x, y, z ... w] is not a valid enumeration
07:50:23 <geekosaur> er
07:50:27 <geekosaur> [x, y, z .. w]
07:50:28 <hpc> huljovm: it should be covered in the LYAH chapter that covers lists
07:50:34 <khyperia> ski, so what'd be an example of a polymorphic type?
07:50:34 <ski> .. just as the empty list `[]', and `Nothing' as well, are polymorphic values
07:50:50 <monochrom> I simply say that [2, 4, 8 .. 200] is a syntax error.
07:51:01 <ski> khyperia : `Dup' as defined above, assuming enough recent extensions to GHC
07:51:03 <monochrom> read the Haskell 2010 Report for valid syntax
07:51:04 <geekosaur> note that .. is not just something you can drop anywhere, [ .. ] is a specific syntax
07:51:35 <geekosaur> [x..], [x, i..], [x..y], [x, i..y] are the only forms allowed
07:52:36 <khyperia> ski, so is `* -> *' a polymorphic type, or is `k -> *' a polymorphic type?
07:52:37 * hackagebot clifford 0.1.0.12 - A Clifford algebra library  http://hackage.haskell.org/package/clifford-0.1.0.12 (spacekitteh)
07:53:09 <khyperia> or both, since the first one is true and therefore the second as well?
07:53:40 <klrr_> is there a way to check if a thread has died or not?
07:53:48 <huljovm> geekosaur: Found it. Thanks for the search terms.
07:55:51 <jmcarthur> klrr_: well, you could have the thread fill some MVar or something right before i dies.
07:55:55 <ski> khyperia : `* -> *' is not a type, it's a kind. hence it's not a polymorphic type
07:56:03 <ski> khyperia : similarly for `k -> *'
07:56:12 <jmcarthur> *it
07:56:13 <khyperia> Right.
07:56:28 <ski> khyperia : would you like to revist your question ?
07:56:36 <ski> s/revist/revise/
07:56:45 <khyperia> I have a feeling I messed up long ago, but... alright, sure, let's try again
07:57:29 <ski> `* -> *' is not a universal kind. `k -> *' is not a universal kind. `forall k. k -> *' would be a universal kind
07:57:40 <daimonos> Typeclassopedia w00t
07:57:43 <daimonos> clap for it
07:57:57 <ski> `Maybe' has kind `* -> *'. `Maybe' is not a polymorphic type
07:57:59 <monochrom> if you killThread the thread. then you know that it is dead. :)
07:58:07 <Cubic_> Hi, is anyone here familiar with OpenGL and really bored right now? I made a simple test program that's just supposed to draw a rectangle and for the love of me I can't figure out where it's going wrong (I just get a screen filled with the clear color instead)
07:58:08 <Cubic_> https://gist.github.com/hanst99/9708435
07:58:18 <jmcarthur> arguable, Maybe is not even a type
07:58:31 <jmcarthur> *arguably
07:58:47 <khyperia> so Dup is a polymorphic type, but the type of Dup (the kind) is what you mean by "is not a type, it's a kind"?
07:58:56 <ski> if we know `Foo :: k -> *', then we don't know that `Foo' is a polymorphic type -- *unless* the former is really short for `Foo :: forall k. k -> *', since then would `Foo' be a polymorphic type
07:59:54 <ski> khyperia : yes, since `Dup :: forall k. (k -> k -> *) -> (k -> *)', its kind "starts" with `forall', and so is a universal kind. and so `Dup' is a polymorphic type
08:00:02 <khyperia> ohhhhhhhh
08:00:58 <ski> btw, one possible way to get such a `Foo' is `data Foo a = MkFoo', which simply doesn't use `a' at all, and therefore `a' could have any kind we like, such as `*',`* -> *',`* -> * -> *',`(* -> *) -> *',`(* -> *) -> * -> *',&c.
08:01:46 <khyperia> okay that sentence connecting kind starting with forall, universal kinds, and polymorphic types is what I needed to know... things are starting to make sense now
08:01:47 <ski> khyperia : similarly, since `lengthh :: forall (a :: *). [a] -> Int', its type "starts" with `forall', and so is a universal type. and so `length' is a polymorphic value
08:02:46 <ski> (s/lengthh/length/)
08:04:21 <ski> > [] : "" : []
08:04:23 <lambdabot>  ["",""]
08:04:55 <ski> here the first `[]' has type `[] Char', and the second `[]' has type `[] ([] Char)'
08:05:02 <khyperia> and then... a kind that starts with a forall is a universal *kind*, and so is a polymorphic *type* (like a value who's type starts with a forall is a universal *type* and so a polymorphic *value*)
08:05:12 <ski> `[]' is a polymorphic value, it has many shapes, it fits into multiple types
08:05:42 <_vlatkoB> I'm trying to benchmark a very simple pure and monadic function with Criterion, but results do not look correct. Can someone take a look to see if benchmark is set up correctly?
08:06:01 <ski> > length (map length ["this","is","a","dream"])
08:06:03 <lambdabot>  4
08:06:10 <_vlatkoB> http://lpaste.net/101584
08:06:36 <ski> here the first `length' has type `[Int] -> Int', and the second `length' has type `[[Char]] -> Int'
08:06:49 <ski> `length' is a polymorphic value, it has many shapes, it fits into multiple types
08:06:55 <jmcarthur> _vlatkoB: i don't think nf const does what you hope it does
08:07:17 <jmcarthur> _vlatkoB: const applied to only one argument will just create a function, and ghc can't evaluate under lambdas
08:07:37 <_vlatkoB> I do not need that extra parameter. How can I write it?
08:07:39 * hackagebot JuicyPixels 3.1.5 - Picture loading/serialization (in png, jpeg, bitmap, gif, tiff and radiance)  http://hackage.haskell.org/package/JuicyPixels-3.1.5 (VincentBerthoux)
08:07:41 <ski> khyperia : almost
08:07:48 <khyperia> almost?
08:08:02 <bennofs> _vlatkoB: maybe try using nf (\img -> diffPure img img) img1 ?
08:08:05 <jmcarthur> _vlatkoB: you must write your benchmark such that it depends on some argument, or else all the work might just happen once up front
08:08:14 <ski> khyperia : a *type* having a kind starting with `forall' is a polymorphic type
08:08:42 <khyperia> Oh, right
08:08:46 <ski> khyperia : "a kind that starts with a forall is a universal *kind*, and so is a polymorphic *type*" looks like it's saying that the kind is a polymorphic type, which isn't right
08:08:56 <ski> a value *having* such a kind is a polymorphic value
08:09:18 <ski> er, a *type* having such a kind is a polymorphic *type*, i mean :)
08:09:52 <ski> (and if you have a type starting with `forall', a universal type. then a value *having* that type is a polymorphic value)
08:10:12 <ski> khyperia : so you probably had the right idea, just didn't phrase it careful enough ;)
08:10:18 <khyperia> yeah, heh
08:17:04 <ainieco> how to adapt emacs haskell-mode to cabal sandboxes?
08:17:54 <ainieco> i just want to C-c C-l inside sandbox
08:18:55 <hexagoxel> (repeating question from yesterday:) how can i express an "empty" constraint? (i am using XConstraintKinds)
08:19:59 <hexagoxel> or is there an empty typeclass somewhere "Any" somewhere, where "instance Any a"? this stuff is hard to google/hoogle
08:21:54 <_vlatkoB> bennofs: Now I'm getting "index out of bounds". Like the img1 is not an image, but maybe an Int.
08:23:51 <ainieco> https://github.com/haskell/haskell-mode/issues/253 heh, someone alredy created issue for that
08:27:16 <_vlatkoB> jmcarthur: Do you mean something like "tst f x = if x == 0 then f else f"
08:28:06 <Krakarn> :(
08:28:27 <ski> (vafalls ?)
08:28:41 <Krakarn> people leaving haskell
08:28:55 <awestroke> ?
08:29:06 <Krakarn> ah nvm :)
08:36:56 <__monty__> Hi, I'm new to haskell and I'm trying to implement an algorithm that has no stop condition, instead you pass an argument that bounds the execution time. In imperative languages this is trivial: pass in the start time and compare it to the current time. How would I do something like this in haskell? (I'm currently trying the getTime function from criterion and loopwhile from control.monad.loopwhile but I don't see how I can pass the output of t
08:37:54 <Tehnix> If I have `data ContentKind = Article | Page`, can I then get the `Article` and `Page` bit somehow from code?
08:38:14 <awestroke> Tehnix: you can pattern match it
08:38:25 <Tehnix> I'm thinking more of extracting it
08:38:31 <awestroke> Tehnix: wat?
08:38:45 <awestroke> Tehnix: like "show k" ?
08:38:46 <Tehnix> like `extractTypes ContentKind` would return Article and Page
08:38:58 <Tehnix> I need to use it for some TH stuff
08:39:16 <Tehnix> I want to generate some code for each, eh, type(?) in ContentKind
08:39:37 <geekosaur> Data.Typeable foo?
08:39:59 <Tehnix> uhhh, Data.Typeable :p imma look into that, ty :)
08:43:21 <MagneticDuck> __monty__: uhm.
08:45:47 <__monty__> MagneticDuck: Not sure what you mean?
08:49:00 <MagneticDuck> __monty__: if you want to abort an algorithm when it goes over a certain execution time, you'd break it down into a pure function that, repeatedly applied to an initial position, returns the result
08:49:25 <MagneticDuck> then you could just make an IO loop that repeatedly applies until... there's no time left
08:49:35 <MagneticDuck> (or the process finishes)
08:50:01 <MagneticDuck> make sure to put the bulk of the process in a pure form if it's possible though
08:51:23 <__monty__> MagneticDuck: That's what I'm trying to do actually, the key part I'm missing is how do "pipe" the "result" from one iteration into the next? (It's an optimisation problem so I pass a list of lists and I return an improved list of lists.)
08:53:27 <MagneticDuck> I'll write a simple example
08:53:29 <MagneticDuck> give me a moment
08:53:35 <jmcarthur> __monty__: you could just do   System.Timeout.timeout microseconds (Control.Exception.evaluate computation)
08:53:57 <jmcarthur> __monty__: unless there is some partial result you still want access to if you must terminate early
08:54:15 <doofernickname> @pf input x  input = map (split " ") (split "\n" input)
08:54:16 <lambdabot> Maybe you meant: pl bf
08:54:25 <doofernickname> @pl input x  input = map (split " ") (split "\n" input)
08:54:25 <lambdabot> input = const (map (split " ") . split "\n")
08:54:26 <MagneticDuck> yeah, or that
08:54:42 <doofernickname> @pl input x  = map (split " ") (split "\n" input)
08:54:43 <lambdabot> input = fix (const . map (split " ") . split "\n")
08:54:44 <__monty__> jmcarthur: What would that return if the iteration is stopped halfway through?
08:54:55 <doofernickname> @pl x input  = map (split " ") (split "\n" input)
08:54:55 <lambdabot> x = map (split " ") . split "\n"
08:54:56 <jmcarthur> __monty__: Nothing
08:55:24 <darthdeu> how can i uninstall a globally installed package? tehre's no cabal uninstall/remove/delete
08:55:40 <__monty__> jmcarthur: The problem with that is that the algorithm is never meant to terminate, so it would always timeout and return Nothing making it pointless.
08:55:42 <jmcarthur> __monty__: note that it accepts an IO action though. if you want, you could keep updating some IORef with partial results and then read that out at the end, whether it times out or not
08:55:54 <jmcarthur> __monty__: so you do want partial results
08:56:00 <jmcarthur> __monty__: so the IORef trick would work
08:57:46 <__monty__> jmcarthur: Alright I'll read up on IORef, thank you.
09:01:15 <colDrMcBeardman> can anyone suggest how I might tie RTS profiling, hp2html and prof2pretty into a cabal file with test-suite or benchmark?
09:01:31 <MagneticDuck> darthdeu: use ghc-pkg unregister
09:07:37 <johannesbodannes> i've been thinking a lot about the excellent work here done on Haste.App, which basically joins the client and server sides of web development into a single body of Haskell code: http://ekblad.cc/icfp14.pdf
09:08:03 <johannesbodannes> Of course it's really just a websocket server with corresponding JS at this point but
09:08:50 <johannesbodannes> clearly someone can come along and substitute the websockets code with web server + AJAX
09:09:24 <johannesbodannes> the obstacle, though, is that since your program compiles to only one javascript file you have to make that work for your entire website, which is honestly kind of unacceptable
09:10:00 <johannesbodannes> but with clever preprocessing
09:10:28 <johannesbodannes> conceivably from the GCC perspective a piece of web application code looks like one application
09:10:45 <johannesbodannes> but then from the Haste perspective it looks like one application for every web route?
09:11:06 <johannesbodannes> with proper separation of concerns this would be feasible, right?
09:14:25 <johannesbodannes> uniting frontend and backend web development into a single type-checked application is such a lofty goal. so much redundancy goes on between javascript and backend implementations where frontend data manipulation and javascript-assisted presentation is concerned.
09:15:13 <mbuf> is there an alternative for Prelude.catch for GHC 7.6.3?
09:15:18 <darthdeu> MagneticDuck: thanks
09:16:40 <awestroke> johannesbodannes: is HTML generated by haste, too? what about stylesheets?
09:17:27 <supki> mbuf: catchIOError from System.IO.Error
09:17:45 * hackagebot ieee-utils-tempfix 0.4.0.1 - ieee-utils  http://hackage.haskell.org/package/ieee-utils-tempfix-0.4.0.1 (MichalKonecny)
09:17:59 <johannesbodannes> nah, it's not. and that implementation in the paper is just a websockets server/client. but it proves that it's possibe to approach web development this way. nothing prevents us from sticking a full-featured web server behind it.
09:18:06 <johannesbodannes> @ awestroke
09:18:21 <johannesbodannes> it's literally just
09:18:25 <johannesbodannes> #ifdef __HASTE__
09:18:38 <johannesbodannes> -- some haste-specific stuff
09:18:47 <johannesbodannes> #endif
09:19:01 <johannesbodannes> in the library at least
09:19:15 <awestroke> johannesbodannes: but the DOM is typed, it'd be great if haste generated HTML and typechecked the interaction with the DOM
09:19:17 <johannesbodannes> but these shenanigans are completely abstracted from the end-user
09:21:14 <johannesbodannes> that's true, yes. giving the haste compiler knowledge of the DOM would be incredible, but yeah you wouln't just have a javascript compiler anymore
09:21:23 <johannesbodannes> you'd have a web language compiler
09:22:21 <johannesbodannes> i don't feel as comfortable about what's required to achieve that <_<
09:23:28 <johannesbodannes> ....no. that's not necessary
09:23:38 <johannesbodannes> you can perform those type checks from the GCC/server side
09:23:43 <johannesbodannes> yes, i'm pretty sure
09:23:54 <johannesbodannes> you don't even need to touch Haste
09:24:04 <ZNW> Hi Guys, is there anyway to simplify this function? hasTwoVowels :: String -> Bool
09:24:04 <ZNW> hasTwoVowels x =  elem 'a' x && elem 'e' x || elem 'a' x && elem 'o' x || elem 'e' x  && elem 'o' x
09:25:10 <MagneticDuck> "elem 'a' x && elem 'e' x" could be simplified into "all (flip elem x) "ax"
09:25:19 <MagneticDuck> and so on...
09:25:33 <MagneticDuck> oh lols
09:25:42 <ZNW> so I have x at both sides, is there a way to remove it?
09:26:00 <MagneticDuck> the entire thing can be simplified into (any (flip elem x) ["ax", "ao", "eo"])
09:26:10 <MagneticDuck> well if you wanted to make it completely pointfree...
09:26:20 <MagneticDuck> @pl any (flip elem x) ["ax", "ao", "eo"]
09:26:20 <lambdabot> any (flip elem x) ["ax", "ao", "eo"]
09:26:27 <dwcook> MagneticDuck, s/"ax"/"ae"/ ?
09:26:31 <johannesbodannes> or well not with those letters ofc <_<
09:26:31 <MagneticDuck> @pl (\x -> any (flip elem x) ["ax", "ao", "eo"])
09:26:32 <lambdabot> flip any ["ax", "ao", "eo"] . flip elem
09:26:42 <MagneticDuck> yeah lol :D
09:27:02 <Hafydd> Flippant.
09:27:17 <MagneticDuck> ZNW: haskell is nice isn't it :D
09:27:22 <ZNW> ya
09:27:25 <ZNW> interesting
09:27:33 <ZNW> thank you guys
09:27:37 <MagneticDuck> <3
09:27:42 <james-sh> Hi guys, I am trying to find a haskell module which can help me to model and Markov Chain and help me with solving them with respect to the stationary distribution
09:28:04 <james-sh> does anyone have any idea where should I look for?
09:28:21 <johannesbodannes> well i'm sure there must be something on hackage that's useable
09:28:48 <johannesbodannes> http://hackage.haskell.org/packages/
09:28:52 <johannesbodannes> in there or something, or
09:29:39 <johannesbodannes> http://hackage.haskell.org/packages/#cat:Natural%20Language%20Processing
09:29:40 <alanz> Should this be valid haskell? GHC complains of line 13 http://lpaste.net/101585
09:29:45 <johannesbodannes> yeah here we go, does that help?
09:30:06 <johannesbodannes> i can imagine GHC getting confused about that whitespace
09:30:29 <james-sh> so the second you mentioned is for language processing
09:30:43 <james-sh> it is really for training markov chains
09:30:58 <james-sh> and not solving them using linear algebra methods
09:31:18 <alanz> johannesbodannes: I am not sure if this is an error in my code (produced as output of HaRe) or a bug in GHC
09:31:29 <johannesbodannes> i really don't know, it's not a domain that i've treated personally before. but chances are excellent that if you search through that page that the groundwork for something is available
09:31:41 <johannesbodannes> alanz: it's your whitespace
09:31:57 <james-sh> johannesbodannes: thanks
09:32:39 <johannesbodannes> remember that whitespace is important in haskell, and if you're filling that whitespace with comments then you're creating problems for the haskell compiler
09:32:52 <geekosaur> I would expect that the newline is part of the comment so syntactically it's `sq z=z^pow pow=2`
09:33:28 <johannesbodannes> that's an interesting way of looking at it
09:33:51 <johannesbodannes> it's pretty shitty to read too <_<
09:33:52 <monochrom> interesting, I forgot the fine print in the Haskell 2010 Report about how comments become spaces
09:34:41 <int-e> alanz: eww, I hope that's illegal.
09:34:43 <alanz> johannesbodannes: I am testing pathological cases for HaRe.
09:35:07 <alanz> Well, GHC doesn't like it, so I guess it is de facto illegal
09:37:24 <awestroke> alanz: perhap GHC finds it aesthetically objectionable
09:37:34 <monochrom> hmm, the basic notion is column number. so a comment of length n should become spaces of length n
09:37:35 <alanz> :)
09:37:47 * hackagebot unix 2.7.0.1 - POSIX functionality  http://hackage.haskell.org/package/unix-2.7.0.1 (HerbertValerioRiedel)
09:37:55 <alanz> monochrom: that's what I would expect
09:38:29 <alanz> I think because it is a block comment continuing on a second line confuses the issue
09:39:12 <monochrom> yes that will hurt.
09:39:34 <Fuuzetsu> it seems that the record syntax binds tighter than function application…
09:39:46 <monochrom> when I said "comment of length n should become spaces of length n" I was ignoring "what if the comment has tabs and newlines"
09:40:03 <hpc> ghc has no problem with it
09:40:06 <hpc> test case:
09:40:06 <hpc> thisFunctionHasALongName x | x > 3 = "three" {- comment -}            | otherwise = "not three"
09:40:24 <hpc> looks like it takes comments into account in layout
09:40:47 <monochrom> since the basic notion is column numbers and line numbers, the bottom line is precisely that. the column number and line number of the token before the comment. and the column number and line number of the token after the comment.
09:40:53 <alanz> Well, GHC has a problem in my example
09:42:09 <int-e> alanz: reading the report, however, leads me to believe that it is legal. It hinges on the question whether newlines in nested comments start new lines ...
09:42:23 <monochrom> so if your comment has newlines and tabs and vertical tabs, that's too bad, they affect the column number and line number of the token after. can't just pretend they are U+0020.
09:42:24 <hpc> oh, your exampe was offscreen and i missed it
09:42:38 <hpc> yeah, i would have expected that to work
09:42:41 <alanz> I would expect the 'pow' token to have a line and col, and that is all that should count
09:43:07 <hooplahoops> Hello, what library would you recommend for term rewriting in Haskell?
09:43:11 <hpc> it would keep counting layout through the comment to the end of line, see the newline and start a new line, then continue
09:44:02 <monochrom> interesting example
09:44:23 <int-e> do people actually put commments in leading whitespace that is relevant for layout?
09:44:28 <augur> hooplahoops: what are you goals? can you give a small example?
09:44:41 * int-e didn't even know that this was legal.
09:44:58 <hooplahoops> augur: want to write a little CPS (continuation-passing style) compiler for educational purposes
09:45:13 <alanz> yes. But in reality I need to push it onto the next line for my example, because whether or not it should be legal GHC thinks it is not
09:45:46 <augur> hooplahoops: and what were you hoping to get out of a library? i dont know if there are any, but it might help to know what you want
09:45:47 <hooplahoops> augur: and see how many transformations are expressible using term rewriting, learning a bit of both I suppose :)
09:46:16 <hooplahoops> augur: basically I want to compose rewrite rules and apply them to a term in a single go
09:46:31 <colDrMcBeardman> the Data.HashMap docs say that lookup is order log n time complexity, but shouldn't it be constant?
09:46:49 <monochrom> nothing is ever constant
09:46:55 <colDrMcBeardman> or do they mean log n in the bit size of the hash?
09:47:12 <hooplahoops> augur: the thing I'd otherwise come up with is probably to put a fix-point around an fmap that composes a number of single transformation functions
09:47:29 <augur> hm.
09:47:40 <hooplahoops> augur: e.g. "f (Foo x) = Bar x ;; f x = x"
09:47:51 <colDrMcBeardman> monochrom, in the "average case" a hash table lookup is O(1)
09:47:59 <hooplahoops> augur: and then compose them using dot, e.g. fmap (f . g) term
09:48:00 <augur> i would be interested in seeing if something like this exists.
09:48:29 <hooplahoops> augur: google pointed me to some libraries, so now I have arrived at the Great Indecision
09:48:36 <augur> hahaha
09:48:37 <monochrom> thank you for telling me the lie that everyone already tells.
09:49:08 <augur> The Great Indecision :)
09:49:16 <colDrMcBeardman> monochrom, how is it not constant time? Unless the hash is stored in a tree, which I guess is the case with Data.HashMap.
09:49:53 <int-e> colDrMcBeardman: Also, in practice, log(n) is generally bounded by 64 ;-)
09:50:59 <colDrMcBeardman> int-e, I'm just trying to figure out what the n is in this case... is the 0.5M elements I'm storing, or is it the size of the hash?
09:51:24 <colDrMcBeardman> (fairly sure they mean the latter, but I don't want to assume having not read the sources)
09:51:38 <int-e> The real lie here are asymptotics. When comparing hash tables and (binary?) search trees, what matters is the total number of random memory accesses, and in the average case that characteristic is better for hash tables.
09:52:06 <int-e> For practical sizes.
09:52:14 <monochrom> I have an array. its size is not fixed, or not small. let's say the size is K. you are to read one entry of this array, at my mercy. do you really believe that this reading is constant time, no matter how huge K is?
09:52:45 <Cubic_> colDrMcBeardman: n is always the size of the entire input. technically it would be the entire hash table + the element you're looking for. Since elements tend to have a constant size, it's just the hash table itself thats relevant
09:53:00 <monochrom> here is a question to consider: how many bits of information must you transmit to me, and I must spend time reading, before I know which entry you like?
09:53:04 <colDrMcBeardman> monochrom, if it's too large that something has to get paged in, it will take longer, but that time isn't related to the value of K
09:53:49 <monochrom> ok I see that you have bought the lie wholesale and cannot see the truth.
09:54:04 <colDrMcBeardman> Cubic_, that's why I'm confused by the Data.HashMap docs. A hash table lookup should not be log n in the number of stored elements in the "average case"
09:54:21 <monochrom> but HashMap is not a table.
09:54:47 <Cubic_> colDrMcBeardman: I'm pretty sure that HashMap isn't a array based hash table
09:55:04 <colDrMcBeardman> afaict it stores the hashes in a tree.
09:55:14 <Cubic_> colDrMcBeardman: Probably some kinda BTree with hashes as keys
09:55:25 <Cubic_> colDrMcBeardman: In which cases log n perf is what you get
09:55:47 <monochrom> yes, it is IntMap with hash as Int
09:56:03 <monochrom> or equivalent
09:56:33 <colDrMcBeardman> so the log n would be in the size of the Int, not the number of values.
09:57:22 <monochrom> why? I would think that tree depth is just log (number of things in the tree)
09:58:17 <monochrom> and so far, absolutely 0 time is spent on asking how much time to compute the hash. which is also clearly non-constant, unless you also buy another lie.
09:58:59 <Cubic_> colDrMcBeardman: n is the number of elements in the tree here - it requires on average log(2)(n) comparisons to find an element in a BTree (or to find out it isn't there)
09:59:03 <berdario> Hi, Why does runghc/runhaskell exits when I do ^C, but not when I run "pkill -SIGINT runghc"?
09:59:08 <colDrMcBeardman> monochrom, the hash time is not related to the number of items stored, but in the average case to the average length of the items
09:59:32 <monochrom> yes. and the average length is usually 2000.
09:59:32 <berdario> and why, if I run "pkill runghc" runghc doesn't also terminate ghc?
09:59:34 <Cubic_> monochrom: It depends on what elements you're looking for - constant size elements tend to have constant time hashes
10:00:04 <berdario> uh, maybe it has been fixed in ghc 7.8?
10:00:19 <monochrom> Cubic_, I am not disputing that.
10:00:30 <colDrMcBeardman> monochrom, in some cases, I suppose. In the case I am dealing with, the average length will be much shorter than 15 (plus overhead for ByteString)
10:00:42 <Cubic_> monochrom: And of course lookup in a realistic BTree is "effectively constant" - not in the sense of its asymptotic behavior, but more because of the size a collection will probably have you don't really get much over 20-40 comparisons at worst
10:01:10 <monochrom> I agree with "effectively constant", too.
10:01:51 <monochrom> nothing makes me happier than getting people to agree "tree lookup is effectively constant"
10:03:23 <colDrMcBeardman> Cubic_, Ok, I foolishly got the wrong impression about how Data.HashMap is implemented.
10:04:48 <Cubic_> monochrom: although if you make a _lot_ of lookups then an actual HashTable is still better - of course Data.HashMap isn't really one.
10:05:51 <Cubic_> Data.HashMap seems be mostly good for things with expensive comparisons, like relatively long strings or such
10:05:59 <colDrMcBeardman> monochrom, I still don't get why you're saying that complexities are a lie. Would you assert that if you're looking for a number in a hugely long list of unsorted integers it will be more than O(n)?
10:06:39 <monochrom> I did not say that complexities are a lie. read carefully how much I call lies.
10:07:01 <monochrom> hell, just read carefully.
10:08:27 <colDrMcBeardman> monochrom, said "thank you for telling me the lie ..." in response to "hash table lookups are O(1)"
10:08:45 <knz> hi all
10:08:48 <monochrom> yes. what can you correct deduce from what I said there?
10:08:52 <knz> I just uploaded the following library: https://github.com/knz/hs-tracer
10:08:59 <knz> I welcome comments
10:09:07 <colDrMcBeardman> that you don't believe a memory access is constant time.
10:09:16 <monochrom> that's correct.
10:09:58 <colDrMcBeardman> I wouldn't dispute that, but complexity notation relates the order of the data to the time only, ceteris paribus.
10:10:18 <monochrom> sorry, what is ceteris paribus?
10:11:00 <colDrMcBeardman> all other things being equal, so, in this specific instance, ignoring the particular machine's operations complexities since they cannot be known for all cases
10:11:19 <colDrMcBeardman> now, that obviously can be a pretty big ignoration, in the case of a page fault.
10:11:49 <colDrMcBeardman> but still, the time it takes the implementation to fault in a page when you ask for it has nothing to do with the size of the structure (other than that it's big, or else the system is under memory pressure)
10:12:01 <colDrMcBeardman> which is why that isn't factored in.
10:12:47 <monochrom> everything you have just said is right. and there is an honest way to say it.
10:13:43 <monochrom> a memory access takes O(1) memory access. instead of "O(1) time", it's "O(1) memory access". use the correct unit.
10:14:57 <colDrMcBeardman> monochrom, or perhaps O( k * O (avg time random mem access) )
10:15:10 <colDrMcBeardman> but again, whether there's a page fault or not is non-deterministic.
10:15:20 <colDrMcBeardman> and therefore, since it is complexity "theory" is ignorable.
10:15:52 <monochrom> here is another example. "my sorting algorithm takes O(n log n) comparisons". it does not say "O(n log n) time". it says "O(n log n) comparisons". it spells out what I am counting, and also acknowledges that I have not counted something else.
10:16:05 <colDrMcBeardman> you're expected to know when you're applying "theory" to "real world" that there are more factors. In that light, I don't think it's a "lie"
10:16:27 <colDrMcBeardman> monochrom, good point.
10:16:56 <darthdeu> guys if I have this https://gist.github.com/darthdeus/fa75cc4a8de472f363b6 how can I use :type in GHCi to inspect the type of (>>=) for that particular instance? I'd like to see how the actual types look when used with that instance
10:17:30 <colDrMcBeardman> better for Data.HashMap would be to claim O(log n) comparisons + a memory access
10:17:56 <NikolajK> I could need some assistance with a simple thing: I went there and downloaded the file  http://hackage.haskell.org/package/graphs  and now I want to load it. it seems I can't just go to the folder and do ":l xxx", so how to load this
10:17:57 <monochrom> it is possible to stay theoretical, and still be honest, and still be practice-ready although not practical yet.
10:20:05 <NikolajK> which is the file I must load anyway: http://i.imgur.com/Uk604nN.png
10:20:39 <jmcarthur> i like Õ notation. it avoids this communication problem
10:21:14 <monochrom> cache locality kills both tree lookups and table lookups
10:21:19 <jmcarthur> since people like to forget logarithmic factors, whether accidentally or intentionally
10:21:44 <aristid> jmcarthur: Ö notation is much better than Õ notation
10:21:44 <monochrom> what is the definition of Õ?
10:22:00 <jmcarthur> aristid: shoot, i'm having trouble seeing what character that is
10:22:09 <aristid> jmcarthur: umlaut
10:22:18 <monochrom> that's O with two dots instead of a ~
10:22:43 <monochrom> it's Gödel's ö capitalized
10:23:01 <thebnq> its a suprised face
10:23:15 <hpc> it's a poorly constructed bowling ball
10:23:40 <colDrMcBeardman> jmcarthur, wouldn't that notation ignore larger factors than things like page faults in the case of a large hashtable lookup that claims O(1)
10:24:05 <dwcook> NikolajK, `cabal repl` perhaps
10:24:56 <bennofs> NikolajK: why do you want to "load" it?
10:25:45 <jmcarthur> monochrom: Õ(f(n)) means O(f(n) log^k f(n)) for some k
10:25:56 <NikolajK> bennofs: ah, I've only started Haskell recently and have been working in ghci
10:26:07 <NikolajK> the text I read was loading modules via :l
10:26:12 <bennofs> NikolajK: so you just want to use the library?
10:26:18 <NikolajK> I guess
10:26:34 <NikolajK> I just wanted to use non-in-build code and get into the swing of things
10:26:35 <mzero> NikolajK: you are in the graphs-0.5.0.1 dir?
10:26:38 <jmcarthur> aristid: what is Ö notation?
10:26:39 <mzero> if so, then    cabal -isrc
10:26:47 <bennofs> then the best thing to do is: cabal install <name of library>. You can then load modules from the library using "import Module.Name" at GHCi
10:26:53 <mzero> when once in there, you can :l files
10:26:57 <they> cabal is the best way of installing libraries.
10:27:13 <johannesbodannes> hmmm
10:27:21 <johannesbodannes> does snap use much template haskell? does anyone know?
10:27:24 <mzero> if you want to use the directory in a project, then yes, go ahead an install it
10:27:34 <mzero> if you just want to explore it, you can do the    -isrc thing
10:27:39 <monochrom> thanks jmcarthur
10:27:41 <jmcarthur> colDrMcBeardman: in what sense is that a larger factor?
10:27:42 <mzero> (assuming all it's dependencies are installed)
10:27:53 <stepkut> johannesbodannes: pretty much only the call to makeLens if you are use snaplets
10:28:01 <bennofs> johannesbodannes: it uses lenses, which can be generated with template haskell (but you can also write them manually)
10:28:02 <stepkut> johannesbodannes: why?
10:28:12 <aristid> jmcarthur: i don't think it exists, but i like umlauts.
10:28:15 <mzero> which.. having tried it, it won't be as it uses things like Data.Void
10:28:33 <jmcarthur> ah. i didn't take it as a joke :)
10:28:50 <mzero> oy - that is the only thing it needs
10:28:51 <mzero> sigh
10:28:55 <colDrMcBeardman> jmcarthur, I guess what I really mean to ask is what guarantee is there that the added log^k f(n) factor corresponds to the actual implementation's performance?
10:29:06 <stepkut> johannesbodannes: it also uses 'deriving'
10:29:11 <NikolajK> okay, yeah now I'm in the graphs dir
10:29:12 <jmcarthur> colDrMcBeardman: there is never a guarantee that big-O corresponds to real performance
10:29:12 <johannesbodannes> i'm trying to think of a good way of combining a web framework with the approach described in this publication, keeping in mind that Haste struggles with template haskell: http://ekblad.cc/icfp14.pdf
10:29:44 <stepkut> johannesbodannes: use ghcjs instead?
10:29:48 <NikolajK> unrecognised command: -isrc (try --help)
10:29:48 <johannesbodannes> this is a websockets server, but i'm trying to devise a way to make it work with a web server/ajax instead!
10:29:54 <colDrMcBeardman> jmcarthur, ok, so knowing nothing about soft-O notation, what exactly is the reason for the implicit  log^k f(n) factor?
10:30:00 <monochrom> I can furnish a joke definition of Ö. inspired by Gödel
10:30:03 <johannesbodannes> GHCJS generates such massive and inefficient output code ._.
10:30:15 <aristid> monochrom: please do:)
10:30:20 <they> There's always fay, and that other one.
10:30:27 <johannesbodannes> yesod?
10:30:28 <micrypt> aristid: Hullo there. Still peddling umlauts, I see. :)
10:30:35 <they> No, yesod is a web server.
10:30:42 <bennofs> johannesbodannes: yesod use lots of TH
10:30:42 <aristid> micrypt: can't have too many of those
10:30:44 <johannesbodannes> oh you mean ->js compilers
10:30:48 <johannesbodannes> it does yeah
10:30:48 <monochrom> Ö(f(n)) means O(g(f(n))) for some function g that cannot be decided :)
10:30:54 <hamishmack> johannesbodannes: Have you tried ghcjs lately?
10:30:54 <jmcarthur> colDrMcBeardman: it addresses the fact that information retrieval always requires some logarithmic factor. it says "I know. I'm explicitly ignoring all these pedantic details."
10:31:07 <johannesbodannes> i mean, a bit of TH is fine i think because you can wrap them and then hide them from the compiler using preprocessor directives
10:31:10 <aristid> monochrom: Öööh..
10:31:14 <johannesbodannes> last time was like 6 months ago
10:31:18 <exicer> Is there a lens tutorial anyone could suggest ?
10:31:23 <johannesbodannes> has it changed a lot since?
10:31:30 <hamishmack> Yes
10:31:33 <colDrMcBeardman> jmcarthur, hm. to be totally realistic, though, shouldn't that factor depend on something different from n?
10:31:42 <jmcarthur> colDrMcBeardman: there is usually some constant that people bound the log factors by. this is a more honest way of doing that
10:32:01 <edwardk> exicer: depends on how deep you need to go. SPJ's covers the basics, I have video out there covering more. There are aso a few good ones on fpcomplete.com
10:32:02 <johannesbodannes> hmmmmmmm ghcjs...
10:32:10 <colDrMcBeardman> interesting.
10:32:14 <jmcarthur> s/doing that/achieving the same kind of simplification/
10:32:20 <johannesbodannes> does it still try to implement its own garbage collection over javascript?
10:32:41 <exicer> edwardk: I'm looking for a sort of, practical "why this is good" type introduction, without too much mention of category theory :p
10:32:43 <hamishmack> Only needs that if you want week refs
10:32:51 <hamishmack> you can turn it off
10:32:59 <johannesbodannes> oh that's good
10:33:00 <jmcarthur> colDrMcBeardman: you always choose the n you are going to express big-O with. there is usually a log factor you're not talking about anyway.
10:33:19 <edwardk> exicer: SPJs intro is sort of CT allergic, so perhaps that is a nice starting point. he doesn't get to the neat stuff that warrants the complexity though
10:33:21 <jmcarthur> colDrMcBeardman: people usually just don't think about it, don't realize it's there, or don't want to get into such pedantry
10:33:43 <johannesbodannes> maybe GHCJS is even feasible then
10:33:47 <edwardk> https://skillsmatter.com/skillscasts/4251-lenses-compositional-data-access-and-manipulation i think you need to register to watch it these days though
10:33:49 <hamishmack> The code size is still large, but we are working on that next.  Code is much, much faster than it was though.
10:34:02 <exicer> edwardk: Hm, okay. Well I think a few days of just using them as an updated record notation, then maybe look at the more complex cases.
10:34:31 <hamishmack> There is this too…http://hackage.haskell.org/package/ghcjs-dom
10:34:32 <bennofs> exicer: there is also https://www.fpcomplete.com/school/to-infinity-and-beyond/pick-of-the-week/a-little-lens-starter-tutorial
10:34:52 <colDrMcBeardman> jmcarthur, on the theme of pedantry, in the case of a page fault, and assuming the OS doesn't page itself, and uses a hashtable for page lookups, wouldn't that logarithmic factor be too big?
10:35:06 <jmcarthur> colDrMcBeardman: and really, for most practical purposes, i don't care about O(1) vs. O(log n) anyway. O(log n) doesn't really grow "fast enough" to care vs. O(1).
10:35:12 <hamishmack> If you use ghcjs-dom you can make your app work stand alon with webkitgtk or in the browser
10:35:15 <colDrMcBeardman> jmcarthur, that is true.
10:35:25 <exicer> edwardk, bennofs: Thanks. I will come back when I inevitably get stuck.
10:35:38 <stepkut> johannesbodannes: my impression from talking to luite is that he has spent a significant amount of time ensuring that GHCJS has good runtime optimizations -- but not so much focus on code size. Hard to get both. And, really, a few images on the page outweights the code size in many cases.
10:35:41 <NikolajK> it seems I must install "cabal" first, right?
10:35:59 <bennofs> NikolajK: how have you got GHC? cabal comes with haskell platform
10:36:20 <bennofs> NikolajK: if you don't have the haskell platform, then yes, you need cabal
10:36:26 <jmcarthur> colDrMcBeardman: if we're really going to be pedantic about it, if you care about "how big" a log factor is in real-world terms then you don't want big-O
10:36:26 <NikolajK> I'm using ghci
10:36:37 <jmcarthur> colDrMcBeardman: neither big-O nor soft-O, that is
10:36:39 <mzero> how did you get ghci? by installing?
10:36:46 <NikolajK> can't remember
10:36:46 <Jei> NikolajK: just don't mistake it for Cobol
10:37:00 <they> I'm just learning how to do Monads and what-not, and came across some syntax that I can't find out what it does. What does the "|" here do? "class (Monoid w, Monad m) => MonadWriter w m | m -> w where". Also, in the implementation, what about the "~" in "writer ~(a, w) = do"?
10:37:13 <mzero> ENVIRONMENT SECTION....
10:37:34 <johannesbodannes> that's a good point, stepkut
10:37:52 * hackagebot conduit 1.0.17.1 - Streaming data processing library.  http://hackage.haskell.org/package/conduit-1.0.17.1 (MichaelSnoyman)
10:37:58 <NikolajK> is "cabal -isrc" to be called from the ghci inviroment?
10:37:58 <monochrom> they: for "|", see "multiple parameter type class" and "functional dependency"
10:38:11 <monochrom> for "~", see "irrefutable pattern"
10:38:15 <mzero> er... no      ghci -isrc    is what I meant, actually
10:38:18 <edwardk> exicer: #haskell-lens is good for answering lens questions as well.
10:38:23 <mzero> (I'm sleepy, need more coffy)
10:38:26 <they> Huh. I've made multi-parameter typeclasses without '|'. I'll read the docs on those things, thanks.
10:38:28 <colDrMcBeardman> jmcarthur, yes, to be perfectly honest, you are always ignoring the fact that memory access times in paged systems are completely nondeterministic, which was a point I raised before
10:38:37 <mzero> but, that won't work fo ryou because package graph needs package Void
10:38:39 <monochrom> ok, see "functional dependency"
10:38:55 <NikolajK> how do I get out of the ghci enviroment btw.?
10:39:01 <they> NikolajK: :q
10:39:01 <NikolajK> q, quit, exist, doesn't work
10:39:05 <NikolajK> k
10:39:08 <johannesbodannes> some extremely mainstream websites have atrocious load times too and they still manage to get away with it <_<
10:39:29 <mzero> but yes, NikolajK - you need cabal , and you should have gotten it when you installed Haskell Platform --- if you installed just GHC itself... that will be somewhat more difficult road
10:39:30 <edwardk> they: the | m -> w   in that class sys that the parameter m determines w. so for say MonadWriter (WriterT w f) w      loking at WriterT w f tells you the other parameter is w
10:39:39 <mzero> control-D
10:39:44 <mzero> is how you get out of ghci
10:39:55 <edwardk> er says
10:40:13 <mzero> what OS are you on NikolajK ?
10:40:15 <they> Thanks. That's actually really helpful, and exactly what I needed for my project.
10:41:00 <jmcarthur> colDrMcBeardman: yup!
10:41:15 <NikolajK> I'm on a Mac
10:41:29 <mzero> okay- and how did you install GHC?
10:42:25 <NikolajK> don't know, too long ago, maybe someone else did it
10:42:48 <mzero> hmmm... and you don't have cabal? then they probably didn't use Haskell Platform
10:42:56 <mzero> if you are comfortable re-installing: http://www.haskell.org/platform/mac.html
10:43:05 <mzero> it is one DMG download, one double-click installer
10:43:22 <mzero> (if you are on Mavericks w/Xcode 5... we have, alas, one more step for you)
10:43:26 <colDrMcBeardman> NikolajK, I would recommend not using a distribution's package manager to install GHC/Haskell
10:43:46 <haasn> colDrMcBeardman: why not?
10:43:59 <NikolajK> ghci -irsc loaded, it gave me
10:43:59 <NikolajK> GHCi, version 6.12.3: http://www.haskell.org/ghc/  :? for help
10:43:59 <NikolajK> Loading package ghc-prim ... linking ... done.
10:43:59 <NikolajK> Loading package integer-gmp ... linking ... done.
10:43:59 <NikolajK> Loading package base ... linking ... done.
10:44:00 <NikolajK> Loading package ffi-1.0 ... linking ... done
10:44:02 <colDrMcBeardman> the target moves too fast for distros to keep up, and having a weird mix of apt/yum/rpm installed packages and cabal-installed things will eventually invite much pain.
10:44:16 <mzero> AHA - you have a rather old version of GHC (as in years old)
10:44:18 <haasn> that's why I don't use cabal-install
10:44:27 <jmcarthur> i usually use the distro package manager for just ghc, and use cabal-install for everything else
10:44:43 <colDrMcBeardman> especially, if like me, you use a stable debian variant because you don't want to upgrade 50000 packages every six months.
10:44:44 <mzero> it will be fine for exploring haskell... like running through the code in Learn You A Haskell....
10:44:53 <MP2E> thankfully, the gentoo haskell ebuilds are pretty up-to-date with cabal, so I just handle my haskell packages through portage
10:44:54 <NikolajK> okay, so I just go to http://www.haskell.org/platform/mac.html
10:44:56 <mzero> but it will be a bit difficult to work with most libraries up on hackage, as they ahve all moved on
10:44:58 <haasn> so you mean “don't install GHc/Haskell using debian's package manager”?
10:45:01 <colDrMcBeardman> jmcarthur, that works if the package manager doesn't bundle too much with ghc.
10:45:08 <NikolajK> I can reinstall it, I guess
10:45:14 <colDrMcBeardman> haasn, no, others as well, I have heard of people having problems.
10:45:18 <mzero> NikolajK: are you on Mavricks?
10:45:23 <mzero> (10.9)
10:45:28 <colDrMcBeardman> portage and apm probably have fewer problems.
10:45:40 <colDrMcBeardman> but apt and rpm cause pain.
10:45:42 <haasn> Portage here, works fine
10:45:53 <NikolajK> 10.9.1
10:45:53 <NikolajK> I think it's the newest downloadable version
10:45:55 <thebnq> portage is great :]
10:45:57 <colDrMcBeardman> haasn, due to the from-source nature
10:46:08 <mzero> okay - on that page - there is a second step -- you'll need to follow it
10:46:19 <colDrMcBeardman> I love gentoo and portage, but i abused my system too much and just couldn't deal with the constant compiling after a while :/
10:46:23 <mzero> (assuming you have Xcode 5 installed, that is)
10:46:33 <colDrMcBeardman> not that that's portage's fault, but more that linux userland is just too big.
10:47:24 <NikolajK> so I must check if I have Xcode 5? I updated to Mavricks a month ago or so, should it be there?
10:47:33 <mzero> NikolajK: gcc --version will tell you
10:47:46 <mzero> if it is "Free Software Foundation" code, then you have Xcode 4 (which will work)
10:47:51 <colDrMcBeardman> NikolajK, the developer tools are not installed by default on OS X, if you installed them from the web or from your CD, then they are there.
10:48:42 <mzero> if not, you have Xcode 5 (it is clang), which will also work, but you need the patch file ont he page I gave you
10:48:58 <NikolajK> *installing developers tool for gcc*
10:49:01 <mzero> and, if gcc doesn't run, you don't have any Xcode.. you need to get some
10:49:04 <mzero> heh
10:49:37 <NikolajK> I remember having Xcode though, years ago
10:50:24 <NikolajK> does "type level programming" anything more than putting lots of into about the program into the types by declaring them?
10:52:05 <thebnq> NikolajK: the type system is turing complete, if thats what you are wondering
10:52:31 <NikolajK> how is reduction preformed on static types
10:52:39 <NikolajK> as in beta reduction
10:52:53 <mzero> Yes, most code puts lots of info about the program into types without doing any serious computation there
10:53:13 <haasn> thebnq: not in haskell98 or haskell2010
10:53:45 <thebnq> ok fair enough, you need pragmas to be complete
10:54:00 <mzero> Some techniques involve doing compuation at the type level: Ex:   fixedVectorConcat :: FixedVector a -> FixedVector b -> FixedVector (a :+: b)
10:54:22 <thebnq> NikolajK: type reduction is similar to term reduction
10:54:36 <jmcarthur> NikolajK: types are checked with unification, not so much beta reduction (although i guess some extensions do something like beta reduction...)
10:54:38 <mzero> here one has encoded the fixed length into a type parameter, and the used computation on that type parameter to make a type declaration about the function
10:54:45 <NikolajK> the type checker is total, everything terminates. can this system express all computations?
10:55:00 <haasn> jmcarthur: I guess type synonyms get reduced when “applied”?
10:55:08 <thebnq> NikolajK: http://www.haskell.org/haskellwiki/Type_arithmetic
10:55:20 <mzero> There is a subset of the Type system that always terminates ... and that is the one we use!
10:55:22 <jmcarthur> haasn: i guess type synonyms are kind of like combinators
10:55:36 <haasn> jmcarthur: and non-combinators
10:55:57 <jmcarthur> haasn: what is an example of a type synonym that isn't a type combinator?
10:55:58 <thebnq> NikolajK: in the sort example, the result of the sort is specified by the type :)
10:56:15 <haasn> jmcarthur: type Foo a = Bar a -- not a combinator because ‘Bar’ is free
10:56:29 <haasn> at least, following the proper definition of “combinator”
10:56:58 <jmcarthur> haasn: it's a combinator if you inline Bar into the definition of Foo, which is what i think i interpret most combinator definitions as
10:57:16 <jmcarthur> haasn: e.g. the definition of I in terms of S and K is still a combinator even though S and K are "free"
10:57:48 <haasn> if Bar is a data type, how can it be inlined?
10:58:41 <jmcarthur> ah, maybe inlining isn't the right way to describe my interpretation
10:59:19 <jmcarthur> Bar is a constant. it doesn't really vary with environment. it's just defined in some metalanguage.
10:59:32 <NikolajK> thebnq: in the type artihmetic link, writing just "data Zero" does what?
10:59:55 <NikolajK> that looks like a type constrcutor without content
11:00:51 <jmcarthur> haasn: would you say that   \f x -> Bar (f x)   is not a combinator? would ghc not happily compile that into a "supercombinator"?
11:00:53 <haasn> jmcarthur: I guess you could say “I = SKK” is a combinator in the environment in which S and K are defined (since they are not free)
11:01:19 <jmcarthur> haasn: hmm... that seems agreeable to me
11:01:23 <haasn> similarly, for type Foo a = Bar a -- in the environment in which “Bar” is defined
11:01:33 <NikolajK> gcc --version
11:01:33 <NikolajK> Configured with: --prefix=/Library/Developer/CommandLineTools/usr --with-gxx-include-dir=/usr/include/c++/4.2.1
11:01:33 <NikolajK> Apple LLVM version 5.1 (clang-503.0.38) (based on LLVM 3.4svn)
11:01:33 <NikolajK> Target: x86_64-apple-darwin13.0.0
11:01:33 <NikolajK> Thread model: posix
11:01:44 <dwcook> NikolajK, data Zero creates a type, Zero, with no constructors, so it's inhabited only by bottom.
11:01:49 <haasn> then again, everything would be a combinator at some point
11:01:55 <NikolajK> ic
11:02:44 <thebnq> NikolajK: adding a constructor won't change the meaning of the example
11:02:54 * hackagebot ShellCheck 0.3.2 - Shell script analysis tool  http://hackage.haskell.org/package/ShellCheck-0.3.2 (vidarhol)
11:03:00 <dwcook> In this case Zero is only necessary at the type level
11:03:10 <NikolajK> mzero: above, did gcc tell me if I need to install Xcode?
11:03:40 <jmcarthur> haasn: indeed. that is kind of what lambda lifting is trying to achieve. if you can lift a definition to the top level, it only depends on other top level definitions, and it's effectively a combinator (as far as the compiler is concerned)
11:04:53 <jmcarthur> at least if the compiler is happy to inline aggressively, i guess
11:05:27 <jmcarthur> (this is where i thought to bring up inlining, but i realize it wasn't really applicable)
11:07:55 * hackagebot aosd 0.2.1 - Bindings to libaosd, a library for Cairo-based on-screen displays  http://hackage.haskell.org/package/aosd-0.2.1 (DanielSchuessler)
11:19:57 <colDrMcBeardman> hmm... any reason why haddock would ignore markup like = and __ ?
11:24:26 <lyxia> colDrMcBeardman: Do you happen to have haddock 2.10? bold and header markup were added in 2.14.
11:26:25 <joneshf-laptop> why is the default list applicative one of combinations rather than one of iterations? meaning why was this instance chosen over zipList?
11:26:42 <joneshf-laptop> is it an artifact of the list monad already existing the way it was?
11:27:04 <joneshf-laptop> so this instance of applicative was put so it would work in the hierarchy?
11:27:17 <joneshf-laptop> or do zipLists not have a monad?
11:27:21 <haasn> joneshf-laptop: because otherwise [] could not be made a Monad
11:27:25 <haasn> joneshf-laptop: ZipLists do not have a Monad instance
11:27:36 <colDrMcBeardman> lyxia, ah, actually I have 2.13.2. I got it with haskell platform; is it safe to cabal install to upgrade?
11:28:22 <Fuuzetsu> colDrMcBeardman: those changes are not in any stable release yet, although if you use RC2 then you should be able to use them
11:28:46 <enthropy> joneshf-laptop: I think it would be fine if liftA2 = zipWith is different from the liftM2 for lists
11:29:03 <colDrMcBeardman> Fuuzetsu, no, I have 7.6.3
11:29:14 <Fuuzetsu> colDrMcBeardman: you can't cabal install it, 2.14.x is not officially out
11:29:28 <Fuuzetsu> it will be officially out when GHC 7.8 is
11:29:34 <colDrMcBeardman> Fuuzetsu, ok, thanks.
11:30:05 <Fuuzetsu> if you're in a hurry, you can use 7.8 rc or even GHC HEAD to get new features
11:30:22 <AlainODea> big thanks to getting the TLS certs on haskell.org.  Good work folks :)
11:31:44 <colDrMcBeardman> Fuuzetsu, I will wait. It will be fun enough to upgrade ghc and platform when the time comes.
11:47:55 <joneshf-laptop> haasn, interesting, is it a bind?
11:48:06 <joneshf-laptop> it seems to satisfy the associativity
11:52:16 <allsystemsarego> hi all, I expected this would work, it doesn't and I don't understand why: flip runStateT 0 $ runInputT defaultSettings $ do { Just c <- getInputChar "> "; put 1; return c }
11:52:51 <dmj`> what is runInputT? Can you paste more code
11:53:10 <allsystemsarego> it's from Haskeline
11:53:26 <allsystemsarego> import System.Console.Haskeline
11:53:32 <allsystemsarego> that's it
11:55:01 <pavonia> allsystemsarego: What error do you get?
11:55:14 <allsystemsarego> a wall of text
11:55:23 <allsystemsarego> let me paste it
11:55:31 <allsystemsarego> on lpaste
11:55:35 <allsystemsarego> of course
11:55:55 <haasn> joneshf-laptop: well, what would join [[1,2],[3,]] be?
11:56:01 <haasn> [[1,2],[3]]
11:56:18 <joneshf-laptop> [1,2,3] i would assume
11:57:24 <haasn> ie. join = concat?
11:58:14 <allsystemsarego> pavonia, http://lpaste.net/101590
11:58:25 <joneshf-laptop> haasn, yeah, is that the wrong idea for it?
11:59:56 <pavonia> allsystemsarego: How are you using this expression?
12:00:48 <allsystemsarego> pavonia, just experimenting in GHCi
12:01:26 <haasn> joneshf-laptop: liftM2 should be equal to liftA2 as a result of the Applicative/Monad interaction laws; liftM2 f x y = x >>= \a -> fmap (f a) y = join (fmap (\a -> fmap (f a) y) x); if we assume join = concat then this is basically liftM2 f x y = concatMap (\a -> fmap (f a) y) x; so liftM2 f [a,b] [c] expands to concat [fmap (f a) [c], fmap (f b) [c]] = concat [[f a c], [f b c]] = [f a c, f b c] which is
12:01:28 <haasn> clearly different from liftA2 f [a, b] [c] = zipWith f [a, b] [c] = [f a c]
12:01:33 <haasn> joneshf-laptop: so we know that join = concat is not a valid implementation
12:01:35 <haasn> we need something else
12:01:44 <haasn> something that “zips”
12:01:50 <pavonia> allsystemsarego: Try giving an excplicit type annotation :: IO Int
12:02:12 <allsystemsarego> ok, let me try
12:03:00 * hackagebot yesod-auth-bcrypt 0.1.0 - BCrypt salted and hashed passwords in a database as auth for yesod  http://hackage.haskell.org/package/yesod-auth-bcrypt-0.1.0 (olihunt)
12:03:17 <pavonia> allsystemsarego: But it looks like you can't use MonadState not with Int as state type
12:03:41 <dmj`> haskell on windows is a nightmare
12:03:55 <haasn> windows is a nightmare
12:04:02 <dmj`> true
12:04:11 <joneshf-laptop> haasn, hm, i'll have to look at this later
12:04:47 <dmj`> haasn: trying to share sandboxes across vm's. Some packages have to be installed in the cygwin prompt vs. dos prompt for C-libs to load
12:04:52 <pavonia> allsystemsarego: Err, I was looking at an old version's docs, you can't use MonadState at all :)
12:05:52 <allsystemsarego> pavonia, so how how can I compose Input and State?
12:07:22 <pavonia> You probably can use the StateT transformer but have to lift the read/write methods manually
12:07:53 <allsystemsarego> ok, let me try that
12:14:41 <dwcook> How might I combine several pipes producers into one?
12:16:27 <SrPx> Hey, I can't have 2 different data types with the same name for a field? data Quaternion = Quaternion {x::Double, y::Double, z::Double, w::Double}; data Vector3 = Vector3 {x::Double, y::Double, z::Double}
12:16:38 <hpc> dwcook: liftM2 (,)?
12:16:40 * hpc doesn't pipes
12:17:14 <dwcook> Actually I'm not convinced I'm on the right track, and pipes-concurrency looks promising for what I want
12:18:30 <dmj`> SrPx: Not yet, there's a GSOC project to allow this though. I think currently you'd have to put them in different files and use the DisambiguteFields pragrma
12:19:11 <SrPx> dmj`: what is the linguistic way to define those types in the same file
12:19:42 <dwcook> SrPx, technically just putting them in different modules will suffice, but GHC tends to associate files with modules
12:26:16 <pavonia> dmj`: Is there any more information about this project yet? How to infer types and such?
12:36:51 <haasn> SrPx: you can also get something close to this using lenses' HasX approach for now; anyway there's a language extension in development that resolves this one and for all
12:37:06 <haasn> SrPx: https://ghc.haskell.org/trac/ghc/wiki/Records/OverloadedRecordFields/Design
12:37:13 <edwardk> haasn: wel, not sure abut resolving it forever, but it at least reduces the pain somewha
12:37:16 <edwardk> er somewhat
12:37:21 <haasn> fair enough
12:37:32 <SrPx> I am trying to define a typeclasse but I guess I don't know enough of haskell yet :C
12:38:32 <SrPx> http://lpaste.net/101592
12:40:19 <haasn> SrPx: the syntax is “class”, not “typeclass”
12:40:36 <haasn> and you probably want line 14 to be inside an instance declaration, eg. “instance Dim V3 where”
12:40:51 <haasn> X is also not a valid Double
12:42:57 <nielsbusch> How can I get Haskell working on OS X Mavericks? I followed this guide, but it didn't work: http://justtesting.org/post/64947952690/the-glasgow-haskell-compiler-ghc-on-os-x-10-9
12:44:42 <Cale> nielsbusch: Not that I'm the best person to help you (I'm on linux), but what do you mean by "it didn't work"?
12:44:50 <Cale> (What's actually happening in your case?)
12:45:03 <geekosaur> probabaly the usual clang cpp thing
12:45:18 <geekosaur> cf. the topic "Xcode 5 issues?"
12:45:22 <nielsbusch> I try to install various packages, but get compile errors like this: error: invalid preprocessing directive
12:45:40 <nielsbusch> I'm a complete noob, so probably doing everything wrong.
12:45:41 <Cale> Yeah, that sounds like you need the ghc-clang-wrapper script
12:46:01 <nielsbusch> Cale Yep, I installed it already, and updated my gcc settings to point to it.
12:46:18 <nielsbusch> Maybe my cabal is using another path / gcc install or something?
12:46:30 <geekosaur> also there's a homebrew recipe going around that apparently has problems
12:46:59 <nielsbusch> I added the persistent package to my cabal dependencies. Then I do cabal install and it fails during compilation.
12:48:19 <nielsbusch> Hmm... I'll try to work in a virtualbox instead if I dont' manage to fix it. What is the recommended way to install Haskell Platform on ubuntu?
12:49:14 <nisstyre_> nielsbusch: just download ghc and cabal with apt-get
12:49:25 <nielsbusch> nisstyre_ k, thx.
12:49:29 <c_wraith> nielsbusch: On linux, I universally recommend not installing the platform.  Just install the generic linux binaries and cabal.
12:49:30 <nisstyre_> use cabal sandboxes for individual projects if you can
12:49:41 <nielsbusch> c_wraith why not?
12:50:07 <nielsbusch> nisstyre yep, is cabal sandbox available out of the box or do I have to install something extra?
12:50:15 <nisstyre_> nielsbusch: it should be available
12:50:23 <nisstyre_> `cabal sandbox init`
12:50:31 <c_wraith> nielsbusch: because it installs a bunch of packages I don't need, and the ones I do want need to be reinstalled in sandboxes anyway.
12:50:44 <nielsbusch> c_wraith makes sense.
12:51:13 <nielsbusch> I would really like to get Haskell working on OS X because I would like to use EclipseFP.
12:51:23 <c_wraith> nielsbusch: on the other hand, the windows build of the platform is magical, since it gives you msys and everything else you need on windows. That's a much bigger pain to install on windows than gcc is on linux.
12:51:42 <nielsbusch> c_wraith luckily that won't be relevant for me.
12:51:50 * StoneCypher finds msys fairly straightforward
12:52:20 <c_wraith> StoneCypher: it probably is. I just haven't ever bothered because it's more steps than using my package manager on linux. :)
12:52:43 <StoneCypher> it actually isn't, particularly
12:52:46 <StoneCypher> it's a one-click installer
12:52:59 <Eduard_Munteanu> Argh, why is there no Text interface to Alex?
12:53:02 <StoneCypher> so i guess going to the webpage and getting it might be more hassle than sudo apt-get
12:53:06 <StoneCypher> but not by much imo
12:53:09 <Kneiva_> nielsbusch: I have Haskell platform on my mac. I remember installing xcode with command line tools and the platform itself, but don't recall if I had to do some other things
12:53:10 <c_wraith> StoneCypher: you
12:53:17 <c_wraith> StoneCypher: you're right, that's not much more work.
12:53:20 <Eduard_Munteanu> I can write my own, I know.
12:53:33 <StoneCypher> also
12:53:37 <nielsbusch> Kneiva_ do you have OS X Mavericks?
12:53:45 <StoneCypher> if someone wants this stuff on windows they almost certainly already have msys installed from git
12:53:52 <c_wraith> Eduard_Munteanu: alex is older than Text.  Probably hasn't been much done with alex in a long time.
12:53:56 <nielsbusch> Kneiva_ I think the problem is that Apple changed the gcc compiler.
12:53:57 <Kneiva_> nielsbusch: yeah
12:54:07 <Eduard_Munteanu> Are there other lexers like Alex?
12:54:18 <c_wraith> Eduard_Munteanu: not that I know of.
12:54:25 <StoneCypher> if someone starts a successor and calls it trebek i will mail them a dollar
12:54:32 <NikolajK> mzero: okay, it tool my 3 hours but now I have Xcode 5
12:54:49 <nielsbusch> Kneiva_ Hmm... weird. Well I can also compile simple packages, but as soon as I try to install persistent or some bigger package I run into problems with the preprocessor.
12:55:37 <nisstyre_> StoneCypher: make it $2.56
12:56:31 <nisstyre_> I just realized you won't be able to have that much in cash in Canada once pennies are completely gone
12:57:08 <Eduard_Munteanu> c_wraith: actually is there anything else besides Parsec and the likes? It seems to me lexer generators can theoretically be better than parsing combinators, because, e.g., they can optimize regexps.
12:57:22 <nisstyre_> Eduard_Munteanu: PEGs
12:57:39 <Eduard_Munteanu> nisstyre_: what does that stand for?
12:57:49 <nisstyre_> Parsing Expression Grammars
12:57:50 <nisstyre_> http://tinlizzie.org/ometa/
12:58:04 <nisstyre_> looks like there is no Haskell variant though
12:58:12 <nisstyre_> it would have to be encoded in a different way I guess
12:58:34 <c_wraith> nisstyre: there are
12:58:49 <nisstyre_> c_wraith: fair enough
12:59:02 <nisstyre_> oh Peggy
12:59:22 <c_wraith> nisstyre: and several others, if you search for packrat
12:59:25 <StoneCypher> frisby and peggy
12:59:25 <nielsbusch> Kneiva_ Is your ghc version 7.6.3 and located in /usr/local/bin/ghc ?
12:59:48 <StoneCypher> nisstyre: i think you want http://repetae.net/computer/frisby/
12:59:59 <c_wraith> nisstyre: since packrat parsing is one of the main algorithms for handing PEGs
13:00:13 <Kneiva_> nielsbusch: /usr/bin/ghc and 7.6.3
13:03:28 <Javran> @pl \x -> gM (fM x) >> hM
13:03:28 <lambdabot> (>> hM) . gM . fM
13:03:49 <nisstyre_> StoneCypher: frisby looks nice
13:04:29 <NikolajK> Can someone tell me how to work with a package like
13:04:29 <NikolajK> http://hackage.haskell.org/package/semigroups
13:04:41 <NikolajK> how do I "load" it?
13:05:05 <kau> hi guys
13:05:25 <Javran> @pl \x -> gM (f x) >> hM
13:05:25 <lambdabot> (>> hM) . gM . f
13:05:30 <geekosaur> you import modules from it. it doesnt have executables or etc.
13:05:49 <Javran> @pl f >>> gM >>> (>> hM)
13:05:49 <lambdabot> f >>> gM >>> (>> hM)
13:06:21 <kau> I'm looking for a function like this: (a -> b) -> (a, a) -> (b,b)
13:06:27 <kau> do you know it?
13:06:37 <pavonia> :t join (***)
13:06:38 <lambdabot> Arrow a => a b c -> a (b, b) (c, c)
13:06:56 <kau> great, thanks!!
13:07:07 <Iceland_jack> > join (***) succ (10, 3)
13:07:08 <lambdabot>  (11,4)
13:07:19 <NikolajK> If I install Haskell Platform, must I uninstall something first?
13:07:43 <they> Not usually, no.
13:08:05 <tristan__> anyoen know if heist has syntax highlighting support for markdown somewhere?
13:08:13 <pearson> hey guys, I work with lyah right now, but I didn't like the BMI calculator, so I changed it for the more body relevant formula for bodyfat composition, why does it not function? Do I have to declare it? Ithought Haskell can do it already? http://lpaste.net/101595
13:08:18 <Kneiva_> nielsbusch: I don't know if this helps, but anyway: http://lpaste.net/101599
13:09:00 <nielsbusch> Kneiva_ thx I have exactly the same.
13:09:01 <Javran> :t (|||)
13:09:03 <lambdabot> ArrowChoice a => a b d -> a c d -> a (Either b c) d
13:09:55 <NikolajK> http://www.haskell.org/platform/mac.html
13:09:55 <NikolajK> in the section "Xcode 5 & OS X 10.9 (Mavericks)", what does that mean?
13:09:59 <NikolajK> "this script"
13:10:16 <NikolajK> which scipt is that and how to run it, ahh, they should work on their presentation
13:10:38 <Javran> > (show ||| const undefined) (Left "foo")
13:10:40 <lambdabot>  "\"foo\""
13:11:04 <nielsbusch> NikolajK better explanation here http://justtesting.org/post/64947952690/the-glasgow-haskell-compiler-ghc-on-os-x-10-9
13:11:27 <pavonia> pearson: You can't do "123x" in Haskell, you have to use the multiplication operator explicitly: "123*x"
13:12:00 <nielsbusch> NikolajK about "loading" packages I think you should add them to your cabal file as dependencies and then cabal install. Then you can import them in your code after. Someone correct me if I am wrong...
13:13:06 * hackagebot simple-form 0.4.1 - Forms that configure themselves based on type  http://hackage.haskell.org/package/simple-form-0.4.1 (StephenWeber)
13:14:52 <pearson> pavonia: thank you.
13:25:12 <Fuuzetsu> is there a lib anywhere which uses TFs+singletons or something to work with length indexed vectors? I think I've had one Prelude.head exception too many
13:26:44 <Fuuzetsu> something like VecN but with some actual functions
13:31:55 <enthropy> Fuuzetsu: that package does have actual functions if you look at the instances
13:32:35 <enthropy> anyways, there are many packages to choose from
13:32:43 <Fuuzetsu> ah, I see what you mean
13:32:54 <Fuuzetsu> I certainly don't see the ‘many’ packages though
13:33:06 <enthropy> stuff like HList doesn't count?
13:33:07 * hackagebot wxdirect 0.90.1.1 - helper tool for building wxHaskell  http://hackage.haskell.org/package/wxdirect-0.90.1.1 (HenkJanVanTuyl)
13:33:28 <Fuuzetsu> HList is a bit too heavy I think ;P
13:33:52 <enthropy> you're using ghc, that's already heavy
13:33:55 <enthropy> http://www.haskell.org/haskellwiki/Extensible_record#Libraries_on_hackage
13:34:35 <daimonos> nurupo: The weird nicks haskellers have haha
13:35:00 <Fuuzetsu> maybe it's unclear what I'm after. I'm effectively looking for something presenting similar interface to Agda's Vec module
13:35:28 <nurupo> daimonos: :)
13:36:03 <johannesbodannes> web developers get so touchy in their defense of javascript : (
13:36:13 <johannesbodannes> completely not recommended to bring it up
13:37:13 <Fuuzetsu> at least we don't get nurupos in Haskell
13:37:38 <dmj`> SrPx: ping?
13:38:37 <daimonos> nurupo: What does this mean? "< Fuuzetsu> at least we don't get nurupos in Haskell"
13:38:48 <benbangert> hmm, I get an exception about no match in a record selector when I compile my code and run it, but when it doesn't have the object files and I just run it with cabal repl, it works... the exception unfortunately doesn't seem to provide much of a hint about what I did wrong. any ideas?
13:39:13 <dmj`> I'm getting linking issues w/ network-2.4.2.2 on windows...
13:39:35 <nurupo> Fuuzetsu: Haskell might not get nurupos, but nurupo gets Haskell :)
13:41:12 <Fuuzetsu> daimonos: nurupo = NullPointerException (because Japan)
13:45:46 <Javran> @hoogle Monoid m => (a -> m) -> [a] -> m
13:45:47 <lambdabot> Data.Traversable foldMapDefault :: (Traversable t, Monoid m) => (a -> m) -> t a -> m
13:45:47 <lambdabot> Data.Foldable foldMap :: (Foldable t, Monoid m) => (a -> m) -> t a -> m
13:45:47 <lambdabot> Prelude map :: (a -> b) -> [a] -> [b]
13:46:29 <skypers> is there a way to write descending infinite list?
13:46:31 <skypers> like
13:46:35 <skypers> [10..0] ?
13:46:44 <bennofs> > [10,9..0]
13:46:46 <Javran> > [10,9..0]
13:46:47 <lambdabot>  [10,9,8,7,6,5,4,3,2,1,0]
13:46:48 <lambdabot>  [10,9,8,7,6,5,4,3,2,1,0]
13:46:55 <c_wraith> those are finite. :P
13:47:06 <bennofs> skypers: what would the first element of that list be?
13:47:17 <c_wraith> > [0, -1 ..]
13:47:17 <skypers> > take 10 [0,9..]
13:47:18 <lambdabot>  can't find file: L.hs
13:47:18 <lambdabot>  [0,-1,-2,-3,-4,-5,-6,-7,-8,-9,-10,-11,-12,-13,-14,-15,-16,-17,-18,-19,-20,-2...
13:48:21 <c_wraith> skypers: that error message from lambdabot means that it tried to process our requests at the same time and got a race condition
13:49:15 <skypers> hm
13:49:24 <skypers> > take 10 [0,9..]
13:49:25 <lambdabot>  [0,9,18,27,36,45,54,63,72,81]
13:49:33 <skypers> huh… what? :D
13:49:42 <skypers> uh
13:49:43 <skypers> ah
13:49:52 <skypers> the first argument is the first element, the second the step
13:50:17 <nurupo> skypers: race condition, "race" as in human classification
13:50:26 <Javran> > take 5 [10,(10-8)]
13:50:27 <lambdabot>  [10,2]
13:50:34 <Javran> > take 5 [10,(10-8)..]
13:50:36 <lambdabot>  [10,2,-6,-14,-22]
13:51:02 <skypers> > [0,(-1)..]
13:51:03 <lambdabot>  [0,-1,-2,-3,-4,-5,-6,-7,-8,-9,-10,-11,-12,-13,-14,-15,-16,-17,-18,-19,-20,-2...
13:51:08 <skypers> that’s great
13:51:11 <skypers> thank you guys
13:51:38 <benbangert> how do you make an exception give you more data about where/why it occured?
13:52:34 <johannesbodannes> actually, what's very interesting is that a quick search reveals that javascript has a lot of apologists... and the greatest number of detractors i can find are actually from the haskell camp
13:53:02 <Iceland_jack> > [0,-1..] -- You don't need the parentheses
13:53:03 <lambdabot>  [0,-1,-2,-3,-4,-5,-6,-7,-8,-9,-10,-11,-12,-13,-14,-15,-16,-17,-18,-19,-20,-2...
13:53:15 <johannesbodannes> javascript is offensive to haskellers, but on the whole it seems that people are very content with the language
13:53:21 <kadoban> Javascript seems like one of those languages that's pretty nice as long as you don't use 3/4 of it.
13:53:51 <monochrom> javascript does not offend me
13:54:12 <monochrom> mere programming languages have long ceased to offend me. I have long grown out of it.
13:54:14 <johannesbodannes> i'm kind of offendned that i'm forced to use it : /
13:54:23 <kadoban> The only parts of Javascript that I really hate are the parts that aren't really Javascript at all (dealing with the DOM)
13:54:23 <johannesbodannes> offended*
13:54:34 <benbangert> ah ha
13:54:38 <johannesbodannes> yeah that sucks
13:54:49 <_1_ibose> what
13:54:54 <johannesbodannes> dealing with the DOM
13:54:58 <Anquietas> Hey. Is FunctorSalad around?
13:55:19 <kadoban> Otherwise it pretty much seems like C++-ish, except less verbose and better first-class-function support and etc.
13:55:38 <bennofs> i find java's prototype inheritance pretty interresting
13:55:44 <bennofs> s/java/javascript
13:56:44 <johannesbodannes> and sort of just does its best to keep running, even when there are awful problems with your code. and everything looks fine but the javascript interpreter is seamlessly concealing a time bomb <_<
13:57:00 <benbangert> it'd be nice if the "No match in record selector" error told you what line of code was trying to do it
13:57:40 <johannesbodannes> it's one of those disgusting sprawling multi-paradigm languages too
13:57:48 <johannesbodannes> that forces no coherent development strategy
13:57:55 <johannesbodannes> and everyone is sort of invited to do their own thing
13:58:45 <kadoban> johannesbodannes: I've noticed that JSlint fixes a lot of that.  It makes it at least a little bit harder to go completely off the rails if you follow its advice
13:59:02 <johannesbodannes> i've never used JSlint before
13:59:06 <johannesbodannes> i should look that up
13:59:54 <kadoban> It's pretty nice.  I saw a tech talk by the guy that wrote it and it convinced me
14:08:12 <Zekka> Hey -- I'd like to use a type behaving very similarly to a two-tuple, but with a named constructor so it'll be more readable when I pattern-match over it
14:08:31 <Zekka> Is there a way I can still get the Functor/Applicative/etc. instances from tuples without explicitly rewriting tem?
14:09:14 <jmcarthur> i don't really mind having to use newtypes to make different instances of the same type class for the same type, but i really hate having to use newtypes just to rearrange type parameters to make it compatible with some type class
14:09:32 <pavonia> You can derive at least Functor, not sure about Applicative
14:09:39 <monochrom> there is "deriving Functor" under an extension. I don't know about Applicative
14:09:52 <Zekka> I might just rewrite the instances for ease, even though it's boilerplate
14:10:10 <Zekka> I've got two types that take this form and I'm worried if I used tuples I'd confuse the two in pattern-matching
14:10:37 <jmcarthur> Zekka: if you use a newtype around a tuple instead of a new data type with separate fields, you can use GeneralizedNewtypeDeriving
14:11:04 <Zekka> jmcarthur - That sounds like the right kind of thing, let me do a little research
14:11:06 <c_wraith> Applicative instances aren't unique, so they can't be automagically derived
14:15:13 <Zekka> Looks like my type isn't a valid applicative, although I haven't proven it
14:16:06 <Zekka> Or rather, at least one of my types isn't a valid applicatie
14:16:09 <Zekka> applicative*
14:17:20 <jmcarthur> Zekka: tuples can be applicatives, for sure
14:17:48 <jmcarthur> Zekka: monads, in fact
14:18:05 <jmcarthur> Zekka: but the standard library doesn't have the monad instance included
14:18:14 <jmcarthur> not sure about applicative
14:18:16 <Zekka> jmcarthur - Hold up, let me find the applicative instance for tuples
14:18:25 <jmcarthur> okay, i won't give it to you
14:18:35 <jmcarthur> i am spoiler free!
14:18:40 <Zekka> Oh, I meant 'google for it', but I can try to derive one too
14:18:46 <jmcarthur> bah :)
14:18:52 <Zekka> I'll derive it, one sec
14:20:07 <bennofs> Can anyone explain this? http://lpaste.net/101602
14:20:18 <bennofs> It seems that using a separate lookup is faster than using alter/update
14:21:10 <Zekka> jmcarthur - The applicative formulation I came up with only works for (Monoid a) => Applicative ((,) a) -- I'll post it in a second
14:21:11 <bennofs> I thought that alter would be faster, because it would only need to traverse the map once
14:22:09 <jmcarthur> Zekka: that sounds about right to me
14:22:30 <jmcarthur> Zekka: now try the Monad :)
14:22:44 <Zekka> http://pastebin.com/ci0xyQ4s <- the applicative instance, for posterity
14:23:11 * hackagebot wxc 0.90.1.1 - wxHaskell C++ wrapper  http://hackage.haskell.org/package/wxc-0.90.1.1 (HenkJanVanTuyl)
14:23:20 <jmcarthur> Zekka: there are also Applicative and Monad instances for   data Pair a = Pair a a   for the record
14:23:30 <benbangert> Is there something that can be turned on so that a no match in record selector error indicates *where in the code* the record lookup that failed actually occured?
14:23:34 <Zekka> jmcarthur - I believe it, and I bet they're easier to find as well
14:23:47 <Zekka> mostly because I bet they look a lot like the instances for data Identity a = Identity a
14:23:54 <jmcarthur> Zekka: well, they may not be the *most* obvious things. the Applicative is easy, but the Monad might be tougher
14:24:09 <Zekka> I might find them in a sec just because math is fun
14:24:14 <Zekka> let me finish Monad first though
14:25:01 <bennofs> Hmm, using -O2, the difference disappears
14:25:36 <Zekka> jmcarthur -- How does this definition for Monad ((,) a) look? http://pastebin.com/Q4BYFcCB
14:27:15 <Zekka> (I have a feeling it'd be neater formulated in terms of fmap and join, but I'm not sure)
14:27:18 <bennofs> Hmm, with -s1000, the difference still shows with -O2
14:33:12 * hackagebot cblrepo 0.11.1 - Tool to maintain a database of CABAL packages and their dependencies  http://hackage.haskell.org/package/cblrepo-0.11.1 (MagnusTherning)
14:34:29 <jmcarthur> Zekka: it looks about right to me
14:34:50 <jmcarthur> bennofs: perhaps it's due to that closure allocation? just guessing
14:35:38 <jmcarthur> i'd be surprised if that outweighed the cost of a whole other traversal though
14:36:24 <NikolajK> what if you
14:36:24 <NikolajK> cabal uninstall cabal-uninstall
14:36:24 <NikolajK> ?
14:36:26 <bennofs> jmcarthur: ok, with -O2 and -s10000 there is no difference
14:36:56 <jmcarthur> bennofs: sounds like the difference at -s1000 is probably noise then
14:37:02 <bennofs> jmcarthur: yeah
14:37:18 <NikolajK> and if I installed something, like say semigroups, then an update is simple down by installing it again, right?
14:42:42 <laar> @pl \x y -> 1 < gcd x y
14:42:42 <lambdabot> ((1 <) .) . gcd
14:43:13 * hackagebot postgresql-simple 0.4.1.0 - Mid-Level PostgreSQL client library  http://hackage.haskell.org/package/postgresql-simple-0.4.1.0 (LeonSmith)
14:43:15 * hackagebot wxcore 0.90.1.1 - wxHaskell core  http://hackage.haskell.org/package/wxcore-0.90.1.1 (HenkJanVanTuyl)
14:49:43 <dwcook> I have a binding startServer :: IO (Producer … IO ()), which starts a server and gives a stream of events coming from it. (This won't be the final type but it will do for now.) In the …, I want to have a type Event clientId but where clientId is existential; specifically, the user knows it is Ord and nothing else. How can I do this?
14:51:21 <dwcook> I've tried creating a synoynm type Event = (Ord clientId) => Event' clientId for an appropriate type Event' but I get asked to enable some extensions but they don't "make it work". (e.g., liberal type synonyms, impredicative types)
14:52:46 <bennofs> dwcook: you need to create a new data type, like data Event' = forall clientId. Ord clientId => Event' (event clientId)
14:53:00 <dwcook> All right. Why is that?
14:53:24 <dwcook> I'm curious where what I'm attempting fails in the type system.
15:08:15 * hackagebot QuickCheck 2.7.2 - Automatic testing of Haskell programs  http://hackage.haskell.org/package/QuickCheck-2.7.2 (NickSmallbone)
15:09:03 <dwcook> I've decided to just have one Event type and leave clientId out of the type entirely. Thanks, bennofs.
15:10:39 <lpsmith> hmm,  there isn't a hashable instace for text :-/
15:13:29 <monochrom> dwcook: an existential type requires a "data" declaration. in GHC anyway.
15:15:13 <benjumanji> anyone got any ideas as to why I would be able to cabal install zlib, but not zlin-bindings? zlib-bindings claims it can't find my zlib header
15:15:17 <benjumanji> but zlib can
15:15:27 <benjumanji> and it is clearly in /usr/includes
15:15:38 <benjumanji> I know nothing about how configure works with cabal :(
15:19:47 <dwcook> monochrom, is there a theoretical reason why type synonyms don't also permit that?
15:32:51 <kuribas> How do I get double from floor?
15:33:18 * hackagebot postie 0.2.0.0 -   http://hackage.haskell.org/package/postie-0.2.0.0 (alexbiehl)
15:33:30 <dwcook> @type floor
15:33:31 <lambdabot> (Integral b, RealFrac a) => a -> b
15:33:34 <dwcook> @type fromIntegral
15:33:35 <lambdabot> (Integral a, Num b) => a -> b
15:33:39 <dwcook> @type fromIntegral . floor
15:33:40 <lambdabot> (Num c, RealFrac a) => a -> c
15:33:42 <jmcarthur> :instances Integral
15:33:46 <jmcarthur> @instances Integral
15:33:47 <lambdabot> Int, Integer
15:34:06 <dwcook> > let myFloor = fromIntegral . floor in myFloor 3.2 :: Double
15:34:08 <lambdabot>  3.0
15:34:17 <benjumanji> and the crowd goes wild!
15:34:20 <kuribas> Ah, of course...
15:34:43 <jmcarthur> note that if you do it that way, ghc will have to use defaulting, and it will decide that the intermediate type should be Integer
15:34:57 <jmcarthur> if you would rather it use an Int as the intermediate, you should say so explicitly
15:35:29 <jmcarthur> or if you don't want to use defaulting but at okay with Integer then you could use fromInteger instead of fromIntegral
15:35:38 <jmcarthur> s/at/are/
15:39:20 <b0bbi10> evening, how would I match the last (three) elements of a list in a pattern? LYAH says '(xs ++ [x,y,z])' and
15:39:31 <b0bbi10> '(xs ++ [x])' would be invalid
15:39:46 <geekosaur> you can't do it in a pattern
15:40:09 <geekosaur> because in a pattern you match constructors, and you can't do that from the inside out, only the outside in
15:40:53 <nisstyre_> geekosaur: what about a view pattern?
15:41:02 <geekosaur> remember that [a,b,c,d] is sugar for (a : (b : (c : (d : []))))
15:41:17 <geekosaur> possibly; I haven't used them much
15:41:18 <b0bbi10> ok, so '(xs ++ [x])' wouldn't work because of that constructor thing, right?
15:41:30 <b0bbi10> or is the syntax just wrong here
15:41:35 <nisstyre_> geekosaur: it would probably be inefficient though because you'd have to reverse the list
15:41:51 <geekosaur> ++ is not a constructor, and you still have the problem that you're truing to match the inside without matching the outside
15:41:52 <jmcarthur> you could do this with a view pattern       (reverse -> z:y:x:xsRev)
15:41:57 <nisstyre_> geekosaur: view patterns are basically just a way to match the result of applying a function easily
15:42:07 <dwcook> > let { lastThree [a, b, c] = Just (a, b, c) ; lastThree (x:xs) = lastThree xs ; lastThree _ = Nothing } in (lastThree [], lastThree [1..3], lastThree [1..10])
15:42:09 <lambdabot>  (Nothing,Just (1,2,3),Just (8,9,10))
15:42:29 <dwcook> (Just felt like it :P)
15:42:45 <jmcarthur> > let lastThree (reverse -> z:y:x:_) = Just (x,y,z); lastThree _ = Nothing in lastThree [1..10]
15:42:46 <lambdabot>  Just (8,9,10)
15:43:01 <geekosaur> in any case you need some kind of trickery (a recursive solution like dwcook showed, or a view pattern involving reverse; not a simple pattern) to do it
15:43:03 <dwcook> Very concise
15:43:19 * hackagebot postie 0.2.0.1 - A library to receive emails from within Haskell programs.  http://hackage.haskell.org/package/postie-0.2.0.1 (alexbiehl)
15:43:20 * hackagebot postie 0.2.0.2 - A library to receive emails from within Haskell programs.  http://hackage.haskell.org/package/postie-0.2.0.2 (alexbiehl)
15:43:22 <b0bbi10> alright, thanks
15:43:35 <b0bbi10> you provided me with much more info than I needed ;D
15:45:37 <Zekka> I've got a module full of type definitions and I'd like to define show instances for those types -- can I somehow define those show instances in a separate file or should I just define them in one module, the types in another, and define a third module that exports both?
15:45:45 <Rufflewind> Is there a way to manage an object (say a file descriptor) with a finalizer using Haskell's GC in a way similar to ForeignPtr (but not necessarily a pointer)?
15:45:54 <Zekka> Show*, to be clear
15:52:12 <fragamus> need to know if convex polygon intersects with square
15:53:20 * hackagebot data-fin 0.1.1.1 - Finite totally ordered sets  http://hackage.haskell.org/package/data-fin-0.1.1.1 (WrenThornton)
15:53:31 <tristan__> haha
15:53:40 <tristan__> so he shows up here too
15:55:18 <andkore> Does anyone know the copyright status of "The Haskell Road to Logic, Maths, and Programming
15:55:18 <andkore> "? There's a link to a PDF version of the book in a recent reddit post (http://www.reddit.com/r/programming/comments/20zk5q/online_programming_books_a_list_of_haskell_books/), but I'm not sure it's actually supposed to be free
15:58:44 <mcc> Hi... I am working through the Learn You A Haskell tutorial. I got to the point of type specification. I try running `x :: Integer; x = 3`; it works fine...
15:59:04 <mcc> But then just to see what would happen, I run `x :: Char; x = 3` and I get the error: No instance for (Num Char) arising from the literal `3'". Possible fix: add an instance declaration for (Num Char)
15:59:19 <verement> :t 3
15:59:21 <lambdabot> Num a => a
15:59:25 <nisstyre_> mcc: you will have to understand type classes before you understand why that is
15:59:37 <hpc> mcc: that error message is GHC deciding that the best way to solve that type error is to make Char a type of number
15:59:39 <nisstyre_> that's explain in LYAH
15:59:42 <nisstyre_> *explained
15:59:57 <mcc> ok i will keep reading
16:00:09 <mcc> i understand it is wrong i was just trying to figure out why that particular error :)
16:00:12 <hpc> mcc: for a slightly more straightforward message, try
16:00:16 <hpc> x :: Char; x = False
16:00:31 <nisstyre_> mcc: in simple terms, the literal 3 can take on various number types
16:00:42 <Iceland_jack> mcc: Intuitively because '5' is a number and Char is not the type of a number
16:01:07 <nisstyre_> mcc: so ghc is trying to figure out if x (which is a Char) is one of these
16:01:11 <nisstyre_> and it's saying "nope!"
16:01:14 <mcc> hpc: Oh! because 3 is a member of a type class and False is not.
16:01:17 <lpsmith> ok,  there used to be a hashable text instance
16:01:56 <mcc> Okay. Uh, one more question which I'm sure HLAH will explain, but I'm curious now. Aren't Capitalized variables required to be types? But True and False are capitalized? Are they types?
16:02:12 <Zekka> They're constructors for the Bool type
16:02:14 <hpc> mcc: capitalized identifiers are constructors
16:02:19 <mcc> ok
16:02:28 <Zekka> @s Bool
16:02:28 <lambdabot> Maybe you meant: sequence set-topic shift-topic shootout show slap smack spell spell-all src v @ ? .
16:02:37 <Zekka> @src Bool
16:02:37 <lambdabot> data Bool = False | True deriving (Eq, Ord)
16:02:43 <mcc> ok thanks
16:02:50 <hpc> so at the value level, a constructor is just one of the primitive things you define a type with
16:03:05 <hpc> data Color = Red | Blue | Green -- out of order to annoy the graphics people
16:03:20 <hpc> (in that example, Red/Blue/Green)
16:03:49 <hpc> it's necessary to distinguish between constructors and variables in pattern matching
16:04:02 <hpc> foo red = red -- this is the same as foo = id
16:04:13 <hpc> bar Red = Red -- this is probably what you would have meant
16:04:37 <hpc> a similar justification exists for type constructors
16:05:25 <hpc> and to fully cap things off, the character ':' is a capital symbol, which sounds weird but basically just means it can be used as cons for lists
16:11:37 <nisstyre_> hpc: to be more pedantic, at the value level, capitalized identifiers are constructors
16:11:48 <lpsmith> err wait, there still is a hashable text instance, it's just some cabal black magic that hides that fact on hackage
16:11:50 <nisstyre_> things like Bool are still identifiers
16:12:04 <mcc> hpc: that is confusing to me-- surely in a type expression : is just like an operator...?
16:12:48 <lpsmith> actually, not really even black magic
16:13:05 <lpsmith> it appears to be a hackage bug that isn't showing the dependency
16:13:06 <hpc> nisstyre_: they are type constructors and data constructors; two different levels
16:13:16 <nisstyre_> hpc: that's what I meant
16:13:25 <nisstyre_> I was responding to your first statement
16:13:39 <nisstyre_> both identifiers, but different meanings
16:14:14 <hpc> ah
16:14:22 <Zekka> I've got two modules completing totally separate tasks but each depends on the other -- it doesn't seem feasible to refactor part of the functionality into a third module. Is harassing GHC into compiling them mutually recursively worth it or should I merge them and export the functionality of each into a separate front-facing module?
16:14:46 <dwcook> Zekka, if applicable, try moving concrete types into type parameters
16:15:27 <Zekka> dwcook - I don't think so. Basically, each contributes to the same task, but each occasionally requires an instance of the other's task to be performed
16:15:56 <Zekka> (more specifically, one describes calling conventions and one describes opcodes, and performing a call involves interpreting some opcodes, while some opcodes result in making a call)
16:15:58 <hpc> mcc: yeah; operators are identifiers as well, and you can define your own
16:16:12 <hpc> mcc: and ones beginning with ':' are constructors as well
16:16:18 <Zekka> I'll clarify -- by 'I don't think so' I mean 'I don't think that's applicable'
16:16:51 <dwcook> Zekka, are you sure they don't belong in the same module?
16:17:02 <Zekka> dwcook - They were originally in the same module but as part of a refactor I separated them
16:17:41 <awestroke> mcc: another example of an operator type constructor: http://hackage.haskell.org/package/base-4.6.0.1/docs/src/Data-Complex.html#Complex
16:17:45 <Zekka> I'd still like to expose the interface to each separately -- namely because outside code does have a reason to make function calls but it almost never has a reason to interpret opcodes -- so I'm still thinking about merging them, then defining two separate modules that export part of the common module's functionality
16:18:10 <b0bbi10> how can I use where-clauses with one function pattern/ definition?
16:18:14 <b0bbi10> like
16:18:14 <b0bbi10> let a b = b + c
16:18:15 <b0bbi10>     where c = 1
16:18:22 * hackagebot tracer 0.1 - Tracing utilities for Functor/Applicative/Monad types  http://hackage.haskell.org/package/tracer-0.1 (knz)
16:18:50 <b0bbi10> :r
16:19:06 <b0bbi10> ah ok, got it working :/
16:19:10 <Zekka> b0bbi - That looks correct, except I don't think GHCi will accept a multiline definition and you shouldn't use let with top-level definitions in a source file
16:19:40 <b0bbi10> Zekka: I noticed ;)
16:19:48 <Zekka> You know, come to think of it, there's a really obvious solution here that I didn't get
16:20:11 <dwcook> Zekka, do you have knowledge that GHC is capable of handling recursive modules? I was under the impression it wasn't
16:20:13 <Zekka> I'll just merge them and only export part of the functionality like dwcook already suggested
16:20:14 <b0bbi10> GHCi is quite nice, but sometimes it gives me the impression Haskell is like a scripting language since I can play around in that
16:20:33 <Zekka> dwcook - From what I hear it's not automatic but you can use some kind of ugly  trickery to force it to
16:20:57 <Zekka> In practice real use cases for mutually recursive modules are pretty rare and generally I try to avoid them
16:21:53 <dwcook> b0bbi10, depends on how you define "scripting language". You can use hashbangs with Haskell, after all ;)
16:22:06 <Zekka> I find myself using runhaskell pretty often
16:22:50 <geekosaur> ghci can do multiline in a couple of different ways, all annoying
16:24:56 <hpc> the least annoying by far is :{ and :}
16:25:38 <DR6> but that one is still annoying
16:25:43 <hpc> yeah
16:25:49 <DR6> just having to use let makes c&p useless
16:25:56 <DR6> so all of them are harmed by that
16:26:24 <DR6> besides, :{ and :} ignore custom prompts and use the module list
16:26:31 <DR6> I think that should be a bug
16:26:46 <bennofs> DR6: I think there is prompt2 for that
16:26:51 <bennofs> DR6: secondary prompt
16:27:01 <DR6> is there?
16:27:05 <DR6> gonna try it
16:27:51 <bennofs> doesn't work
16:27:53 <DR6> nope
16:28:08 <DR6> "Some flags have not been recognized: prompt2, ~>"
16:28:53 <bennofs> DR6: oh, but I think ghc7.8 does have it
16:29:16 <bennofs>   "   :set prompt <prompt>        set the prompt used in GHCi\n" ++
16:29:18 <DR6> oh, that can be
16:29:18 <bennofs>   "   :set prompt2 <prompt>       set the continuation prompt used in GHCi\n" ++
16:29:47 <bennofs> DR6: you can get it now by using ghci-ng
16:29:52 <bennofs> DR6: cabal install ghci-ng :)
16:30:06 <MP2E> huh, neat
16:30:16 <MP2E> Didn't know you could have a newer ghci without ghc
16:30:37 <DR6> but that's something different right?
16:30:38 <geekosaur> it's just an application using ghc-as-a-library
16:30:43 <MP2E> AH I see.
16:30:51 <bennofs> DR6: it's just like ghci, but with some added features
16:31:11 <bennofs> DR6: many of those features are in GHCi 7.8 though, I think
16:31:33 <DR6> but why are there two different prompts anyway?
16:31:42 <DR6> and why was one not settable until now?
16:31:44 <bennofs> DR6: so you can tell them apart
16:31:57 <bennofs> DR6: you might want to know if you're inside a multiline command or not
16:32:12 <DR6> that would make sense if you could set prompt2
16:32:12 <bennofs> DR6: probably because nobody needed it/complained
16:32:22 <DR6> yeah probably that
16:32:32 <bennofs> I don't think many people are even using multiline
16:33:23 * hackagebot yesod-session-redis 0.1.0 - Redis-Powered Sessions for Haskell  http://hackage.haskell.org/package/yesod-session-redis-0.1.0 (olihunt)
16:40:50 <cin_> you can just write multiple lines in haskell-mode's repl
16:44:21 <monochrom> "ghci-ng" is dangerously close to "ghc-ing" :)
16:44:34 <MP2E> I'
16:44:39 <MP2E> whoops*
16:44:42 <MP2E> brb
16:47:00 <dwcook> monochrom, do you like ghci-ng-ing?
16:47:09 <monochrom> haha
16:47:44 <ion> :-)
16:54:19 <mcc> Can I cause a type to be "deriving" another type after the fact?
16:54:24 <mcc> like let's say I design a typeclass Arbitrary. And it *happens* to be the case that some built-in type that has already been defined conforms to Arbitrary.
16:54:30 <mcc> Can I put the type into Arbitrary even though it is already defined? Is this a sensible question?
16:55:21 <DR6> eh
16:55:31 <DR6> I think you are confusing thigs
16:55:33 <opqdonut> mcc: there's an extension for that. standalone deriving.
16:55:48 <DR6> first, typeclasses and types are completely different things
16:55:51 <opqdonut> see http://www.haskell.org/haskellwiki/GHC/Stand-alone_deriving_declarations
16:55:53 <geekosaur> http://www.haskell.org/ghc/docs/latest/html/users_guide/deriving.html#stand-alone-deriving ?
16:56:02 <DR6> you make types instances of typeclasses
16:56:22 <DR6> deriving is making the instances automatically
16:56:23 <mcc> thank you very much
17:15:24 <seanparsons> Any users of SublimeHaskell? I'm struggling with settings not being applied, which is possibly due to me not knowing where they should go.
17:29:27 <Algebr> Why does the syntax of case use -> instead of just = like straight up pattern matching does
17:31:30 <Boney> win 10
17:32:23 <dwcook> Algebr, I take it you're referring to definitions of bindings. In that case, the = looks rather like the mathematical sense of = in that the thing on one side can be replaced with the thing on the other. That intuition doesn't work so well with case
17:32:36 <enthropy> it looks more like a lambda
17:32:58 <cin_> Boney: welcome to #lambdalove
17:33:28 * hackagebot postgresql-simple 0.4.2.0 - Mid-Level PostgreSQL client library  http://hackage.haskell.org/package/postgresql-simple-0.4.2.0 (LeonSmith)
17:33:36 <Boney> cin_: I've been here a while :-)  I just forgot the '/' on front of my command.
17:34:39 <Algebr> dwcook: Thank you, is that because in the binding you assigning based on a boolean rather when in the case you're "returning" based off the values of the parameters?
17:34:46 <dwcook> I won 10 once. But it turned out I, and everyone else, for that matter, already had 10
17:35:18 <dwcook> Algebr, in case expressions, you're not saying the thing on the left *is* the thing on the right, it's more of a mapping.
17:35:29 <ahdai> new haskell platform user here. "cabal install cabal-install" works, saves executable, but cabal --version still shows the old cabal is in use. Known bug? Or is it really expected that I have to update the path to use the new cabal?
17:36:55 <seanparsons> ahdai: Yup, but it goes in a standard location that all cabal installed binaries go, so it's a one time only thing.
17:37:06 <dwcook> Algebr, in case someList of [] -> foo ; (x:xs) -> bar, it makes no sense to say that the empty list *is* foo. However, when you define f [] = foo ; f (x:xs) = bar, it definitely makes sense to say that f [] is foo
17:37:59 <cin_> dwcook, my point system goes up to 11
17:38:08 <cin_> it's like 10 but winnier
17:39:51 <Algebr> dwcook: ah, got it, thanks!
17:45:29 <ahdai> seanparsons - thanks, so are you saying I should just read the manual? ;) I know where the new cabal.exe is, was able to use it by calling its direct path, but I think its a bit ... "scary" ... that if I generate cabal packages using cabal install that I have to know to put them somewhere else manually in order to use them. If I was making my own standalone app, sure, but when upgrading the cabal platform itself, that seems a bit frag
17:46:41 <seanparsons> You wouldn't put them somewhere else you'd just add (in the case of Linux) ~/.cabal/bin/ to your PATH environment variable.
17:46:45 <the_berserker> Numbers are an abstract data type, why can we pattern match on them?
17:48:07 <seanparsons> When I say I mean prepend more specifically so that it got in before the system one.
17:50:01 <dwcook> the_berserker, basically, because the report says so
17:50:12 <dwcook> It's its own case of pattern matching
17:50:20 <ahdai> seanparsons - thanks.
17:51:13 <dwcook> the_berserker, the report actually says to carry out an equality check (with (==)) in that case
17:51:26 <dwcook> So theoretically I guess that means it adds an Eq constraint? I'm not sure, let's find out
17:51:33 <the_berserker> dwcook: Is it magic?
17:51:40 <dwcook> :t let f 0 = () in f
17:51:41 <lambdabot> (Eq a, Num a) => a -> ()
17:51:46 <geekosaur> yes, it adds an Eq and Num constraint
17:51:47 <dwcook> As expected
17:51:50 <geekosaur> it's ... annoying
17:52:06 <dwcook> the_berserker, yes, as much as anything is magic because the spec says it is so
17:52:20 <Iceland_jack> It's not magic, it converts them to Integers
17:52:42 <dwcook> Well "magic" is ill defined :)
17:52:55 * geekosaur sometimes thinks all the Num special casing in the Report / Prelude should be set to "The Thing That Should Not Be"
17:53:13 <Iceland_jack> When you pattern match on '5' you're really pattern matching on (5 :: Integer) which then gets converted to your Num instance of choice via
17:53:13 <Iceland_jack>     fromInteger (5 :: Integer) :: ...
17:54:01 <dwcook> geekosaur, well at least n+k patterns have gone away
17:54:10 <geekosaur> true
17:54:39 <dwcook> I get the feeling these features were added because they are "nice" for the programmer but then maybe they turned out not to be so nice
17:55:04 <geekosaur> s/programmer/beginner/
17:55:14 <dwcook> I mean it sure does make sense to me to be able to use 0 like I'd use the constructor of some type whose constructors I know
17:55:30 <geekosaur> overreaction to ML's float handling, maybe
17:57:26 <khyperia> what's ML's float handling?
17:57:37 <khyperia> I've never used it
17:59:14 <geekosaur> Haskell tries to handle integers and floating point similarly, via typeclasses and defaulting etc. ML doesn't; there are completely different operators for floating point types, etc.
17:59:28 <khyperia> ah
17:59:59 <khyperia> hey, at least it's better than all this implicit confusion present in other languages
18:00:16 <geekosaur> except we kinda reintroduced that :/
18:00:39 <khyperia> The worst parts of it, not really...
18:00:40 <geekosaur> cf. all the folks popping in trying to figure out why division doesn't work
18:00:45 <khyperia> ah
18:01:03 <Iceland_jack> geekosaur: But do you see any straight-forward way of fixing that?
18:01:12 <geekosaur> nope
18:01:30 <khyperia> Yeah... even in a perfect world where we could do anything, there's not really a good solution.
18:01:42 <geekosaur> I don't think there is one, and sometimes I wish Haskell didn't bother with what amount to half measures
18:01:43 <Iceland_jack> One large source of confusion is that functions like 'length' are not as generic as they could be
18:02:02 <Iceland_jack> > length [1,2,3,4] / 4
18:02:03 <lambdabot>  No instance for (GHC.Real.Fractional GHC.Types.Int)
18:02:03 <lambdabot>    arising from a use of `GHC.Real./'
18:02:04 <lambdabot>  Possible fix:
18:02:04 <lambdabot>    add an instance declaration for (GHC.Real.Fractional GHC.Types.Int)
18:02:04 <Iceland_jack> > genericLength [1,2,3,4] / 4
18:02:05 <lambdabot>  1.0
18:02:23 <khyperia> :t genericLength
18:02:24 <lambdabot> Num i => [b] -> i
18:02:34 <khyperia> Ah.
18:02:34 <Iceland_jack> But then again, numbers are notoriously difficult to get right
18:02:50 <Iceland_jack> as fundamental as they are, almost no programming language gets natural numbers right
18:03:18 <ahdai> seanparsons - hi again, I found this apparently unresolved bug report for Windows users (I'm trying the platform on win7 atm) http://trac.haskell.org/haskell-platform/ticket/146 . I'll delete the main cabal.exe, which is the only suggested workaround on this _4_year_old_ticket.
18:04:29 <hpc> isn't the solution to that going to be cabal install cabal-install --global?
18:04:42 <khyperia> Well, me being silly (and testing my own knowledge of haskell), wouldn't the "most generic type" actually be something like `(Traversable t, Enum e) => t a -> e'? Or am I forgetting what Traversable's definition is...
18:05:27 <Iceland_jack> khyperia: Enum would be a stretch, but yes Traversable would be more generic (possibly overly generic) :)
18:05:56 <Iceland_jack> At that point it's really a design choice, overloading too many things leads to life being uncool
18:06:14 <khyperia> Right, thanks
18:07:22 <shachaf> Wouldn't the "most generic type" be GenericLength a b => a -> b?
18:07:37 <Iceland_jack> I mean the naive way would be to just mindlessly create one type class per operation
18:07:46 <shachaf> "most generic" isn't really a concept that makes sense here.
18:07:57 <Iceland_jack> Yes you're right
18:08:20 <shachaf> With that said, you should never use genericLength except when your number type is lazy naturals.
18:08:26 <shachaf> It's unreasonably inefficient.
18:09:44 <khyperia> Isn't there something in GHC that does a thing?... Specialize or something, where it optimizes a function for a specific type? (so genericLength :: [a] -> Int and related would optimize)
18:09:55 <shachaf> That's not very generic.
18:09:56 <khyperia> or do I have no clue what Specialize does
18:10:10 <shachaf> SPECIALIZE does something else.
18:10:17 <khyperia> ah
18:10:25 <shachaf> But the thing you said would defeat the purpose of genericLength a bit.
18:10:53 <shachaf> For almost all actual lists and actual number types, (fromIntegral . length) is much better than genericLength.
18:11:03 <khyperia> no, I mean "genericLength :: [a] -> Int" as in the special case where the result is specialized to Int
18:11:14 <shachaf> What?
18:11:39 <khyperia> "Num i => [b] -> i" where "i" ~ "Int"
18:12:18 <carter> khyperia: wanna help me? :)
18:12:19 <shachaf> I don't think I understand what you're saying.
18:12:30 <khyperia> sure, carter
18:12:41 <carter> khyperia: validate fails on my cpp_settings branch
18:12:42 <khyperia> shachaf, the case at where the call site you use the result as an Int
18:12:43 <carter> and I don't know why
18:12:45 <shachaf> If your list is longer than 2^64 (or 2^32 on 32-bit GHC is more likely) elements, then you should write your own "genericLength" which behaves sanely for non-lazy-natural types.
18:12:50 <shachaf> khyperia: What do you want to happen in that case?
18:13:43 <khyperia> it optimizes to not use the generic version of genericLength with typeclass argument, but rather uses Int's Num functions directly
18:13:56 <Iceland_jack> shachaf: Use shorter lists :)
18:14:09 <shachaf> OK, but that's just a constant factor improvement from not passing dictionaries around.
18:14:17 <shachaf> genericLength is asymptotically bad.
18:14:21 <khyperia> because iirc `(Constraint a) => ..a..` gets translated to `(Constraint a) -> ..a..` somwhere in the compilation process
18:14:24 <khyperia> ah, right
18:14:59 <khyperia> why?
18:15:11 <Iceland_jack> Not defending the performance of ‘genericLength’, just that it adds to the confusion of Haskell's already daunting type system
18:15:31 <khyperia> carter, I think validate failed on some tests on a vanilla build for me a bit back, so...
18:15:42 <carter> yes
18:15:45 <shachaf> Why what?
18:15:47 <Iceland_jack> I believe Rust splits its type classes (traits) more generously up so they have an Add, Mul, etc. traits
18:15:50 <carter> khyperia: i need to get it to validate
18:16:23 <bjz> Iceland_jack: it's because we don't have arbritrary operator overloading
18:16:33 <khyperia> shachaf, why is genericLength a different big-O constant than length? (it seems like you were implying that)
18:16:52 <shachaf> Because it is implemented differently.
18:16:56 <shachaf> @src genericLength
18:16:56 <lambdabot> genericLength []    = 0
18:16:56 <lambdabot> genericLength (_:l) = 1 + genericLength l
18:17:03 <bjz> Iceland_jack: a sad fact about going with a curly-bracket syntax
18:17:12 <Iceland_jack> bjz: ah, I actually don't think it's sad at all
18:17:29 <bjz> Iceland_jack: yeah, different ways of looking at it
18:17:31 <shachaf> Or maybe you're asking why it's implemented differently.
18:17:40 <Iceland_jack> If anything, Rust is incredibly promising in so many ways
18:17:59 <gamegoblin> So do all attoparsec parsers automatically rewind upon failure, or just the string parser?
18:18:06 <nisstyre_> shachaf: nitpick, don't you mean 2^32-1 ? >.>
18:18:21 <bjz> Iceland_jack: I'm not a fan of the operator traits because they convey no semantic meaning
18:18:27 <shachaf> nisstyre_: I mean 2^31-1, because it's a signed Int.
18:18:41 <bjz> Iceland_jack: but I can cope with it because I value other things about Rust more
18:18:44 <nisstyre_> oh right
18:18:47 <Iceland_jack> bjz: Yes but they're at least easy to understand to all programmers?
18:18:47 <nisstyre_> one bit is for the sign
18:19:07 <khyperia> shachaf, how is that different from normal-length?
18:19:18 <Iceland_jack> Unlike the names Ring, AbelianGroup, … that many Haskellers would have replace Num if they could
18:19:35 <Iceland_jack> Actually I'm envious of Rusts's default parsing, I believe it returns None on {over,under}flow
18:19:39 <khyperia> @src length
18:19:40 <lambdabot> Source not found. Are you typing with your feet?
18:20:01 <NikolajK> does someone have a reference for a presentation of the IO monad without do-notation?
18:20:15 <shachaf> In GHC, length looks something like foldl' (+) 0
18:20:15 <bjz> Iceland_jack: unfortunately abstract algebra doesn't map very well to the realities of numerics on the computer :(
18:20:22 <shachaf> Er.
18:20:25 <bjz> Iceland_jack: believe me, I wish it would
18:20:25 <hpc> ppsh, clearly they should be HasPlus, HasMult, HasAssociativePlus, HasZeroPlusIdentity, HasAssociativeMult, ...
18:20:32 <bjz> Iceland_jack: <3 abstract algebra
18:20:41 <Iceland_jack> bjz: No disagreement there :)
18:20:49 <shachaf> In GHC, length looks something like foldl' (\x _ -> x + 1) 0
18:21:12 <Iceland_jack> I actually designed a very nice numeric tower which was way too polymorphic, but quite nice conceptually
18:21:19 <bjz> Iceland_jack: I've definitely tried
18:21:30 <nisstyre_> @src sum
18:21:30 <lambdabot> sum = foldl (+) 0
18:21:34 <nisstyre_> >.>
18:21:48 <shachaf> Yes, that's why I wrote a different thing.
18:21:49 <bjz> Iceland_jack: in the end I think floats should be entirely separate things
18:21:50 <ahdai> anyone know of an "abstract algebra" study of floating point?
18:21:57 <khyperia> Right, shachaf, so something about stream fusion and foldl' being insanely optimized?
18:22:06 <bjz> ahdai: ask carter
18:22:07 <Iceland_jack> bjz: Don't even get me started on floating-point numbers
18:22:08 <shachaf> No stream fusion and no foldl'.
18:22:24 <carter> bjz: :)
18:22:31 <nisstyre_> ahdai: no, but this is a good source on fp in general http://docs.oracle.com/cd/E19957-01/806-3568/ncg_goldberg.html
18:22:40 <bjz> Iceland_jack: floating point is an amazing acheivement
18:22:53 <carter> ahdai: if you add a (1±epsilon) to all the normal rules, tis an approx algebra usually
18:22:56 <nisstyre_> it's quite hard reading though, at least for me
18:22:58 <bjz> Iceland_jack: that is, IEEE
18:23:00 <shachaf> length = go 0 where { go !n [] = n; go !n (_:xs) = go (n+1) xs }
18:23:06 <shachaf> Something like that works just as well.
18:24:04 <khyperia> So why isn't genericLength implemented like that?
18:24:16 <Iceland_jack> bjz: IEEE 754 gets way too much undeserved hate
18:24:30 <shachaf> Because it works for lazy naturals.
18:24:32 <Iceland_jack>       sqrt (-1) :: Complex Float
18:24:32 <Iceland_jack>     ⇒ -0.0 :+ 1.0
18:24:32 <Iceland_jack>       sqrt (-1) :: Float
18:24:32 <Iceland_jack>     ⇒ error
18:24:35 <Iceland_jack>       sqrt (-1) :: Maybe Float
18:24:38 <Iceland_jack>     ⇒ Nothing
18:24:41 <bjz> Iceland_jack: it's a super tough problem they had to solve
18:24:49 <khyperia> Explain "lazy natural", I've never heard of it before
18:25:19 <Iceland_jack> bjz: yes and basically all the short-comings of IEEE weren't 'accidental' but rather carefully thought out compromises
18:25:19 <nisstyre_> Iceland_jack: mostly from people who don't understand it and got bugs because of that
18:25:25 <Iceland_jack> nisstyre_: right
18:25:31 <carter> agreed
18:25:32 <hpc> khyperia: basically, data Nat = Zero | Succ Nat
18:25:44 <carter> the more i understand floating point, the more I appreciate it being the way itis
18:25:47 <Iceland_jack> > read (show (fromIntegral (maxBound :: Word8) + 1)) :: Word8 -- This should be a parse error
18:25:47 <hpc> khyperia: it's lazy in the sense that all haskell data structures are lazy
18:25:48 <lambdabot>  0
18:26:03 <hpc> and in this case the laziness shows up quite conveniently, kind of like how list-as-stream does
18:26:15 <khyperia> ah
18:26:18 <hpc> the part of a number that is evaluated is "the number is at least this big"
18:26:38 <hpc> and you can do stuff like infinity = fix Succ
18:26:49 <ahdai> nisstyre_ thanks, I've read that, as well as the online practical papers by Kahan. I was wondering whether any abstract mathnuts had written anything about it. While integer math on a computer is not closed, so it fails to be a group under addition and mult by that, at least it is simple within that limited domain. Float is not even commutative under addition.
18:26:49 <Iceland_jack> hpc: There is a nice paper discussing natural numbers in a lazy language which touches briefly on a hybrid representation of nats
18:27:12 <ahdai> sorry, commutative, but not associative
18:28:36 <Iceland_jack> ahdai: The Haskell abs also isn't IEEE 754 compliant!
18:28:46 <Iceland_jack> > abs (-0.0) -- should be 0.0
18:28:47 <lambdabot>  -0.0
18:29:02 <nisstyre_> Iceland_jack: what's the reason for that?
18:29:05 <nisstyre_> just arbitrary?
18:29:08 <Iceland_jack> nisstyre_: arbitrary
18:29:15 <Iceland_jack> It doesn't claim to adhere to the standard but I think that's just an oversight
18:29:22 <Iceland_jack> not very serious I must say
18:29:51 <Iceland_jack> But yes, NaN and Inf/-Inf and 0/-0 make a huge mess of things
18:29:56 <nisstyre_> Haskell conforms better than most languages though
18:29:57 <nisstyre_> e.g. Python
18:30:06 <ahdai> iceland_jack - abs(-0.0) == -0.0 in Haskell? Well, most people turn their head sideways when I even mention -0.0 in float ....
18:30:16 <carter> Iceland_jack: nisstyre_  i hope to help fix it up a teeny bit in 7.10 :0
18:30:17 <carter> mebe
18:30:17 <Iceland_jack> NaN in particular when people try to put floating point numbers in containers..
18:30:54 <ahdai> And many "tools" don't handle -0.0 properly, ie they treat -0.0 as 0.0
18:31:12 <carter> wat
18:31:13 <carter> really?
18:31:15 <carter> what do they do?
18:31:32 <carter> (==) (-0.0) 0.0
18:31:37 <carter> > (==) (-0.0) 0.0
18:31:38 <lambdabot>  True
18:31:44 <scshunt> that is correct
18:31:48 <ahdai> for example, if you test "x < 0.0", if x is -0.0 it would return false
18:31:48 <nisstyre_> e.g. 1/0 in Python raises an exception
18:32:19 <scshunt> ahdai: that's also correct
18:32:35 <carter> nisstyre_: Iceland_jack  i want ghc to eventually have a precise model of floating point sematnics :)
18:32:47 <Iceland_jack> carter: I know you do and I would like that too!
18:32:48 <carter> not intel / amd grade mind oyu
18:32:52 <carter> yay!
18:32:58 <nisstyre_> carter: that's awesome
18:33:11 <nisstyre_> that would make writing precisely defined interpreters easier in Haskell too
18:33:22 <Iceland_jack> carter: Let's make our own floating-point standard where everything is associative!
18:33:36 <Iceland_jack> (even subtraction..)
18:33:36 <carter> Iceland_jack: nope
18:33:39 <ahdai> scshunt, how is "-0.0 == 0.0 => true" correct?
18:33:56 <scshunt> ahdai: because == is numerical comparison
18:34:05 <hpc> ahdai: the spec says those two are equal when compared
18:34:06 <scshunt> and signed zeros are still numerically zero
18:34:18 <scshunt> see http://en.wikipedia.org/wiki/Signed_zero
18:34:26 <hpc> but they are observably different in other ways
18:35:28 <scshunt> for instance, 1 / +0 = +inf, 1 / -0 = -inf
18:36:22 <Iceland_jack> > let nan = 0/0 in S.fromList [nan, nan]
18:36:23 <lambdabot>  fromList [NaN,NaN]
18:37:16 <Iceland_jack> > S.fromList [0.0, -0.0]
18:37:17 <lambdabot>  fromList [-0.0]
18:38:09 <ahdai> scshunt, if IEE754 says -0.0 == 0.0 should return, then what I've seen correctly follows that rule, but I don't agree with it. For one, it makes handling -0.0 overly complicated. For example, to write a two argument arctan function, you have to distinguish them
18:38:13 <geekosaur> well, we already knew the floating point types confuse Set/Map pretty badly
18:39:32 <Iceland_jack> geekosaur: Yes but people who don't know that are too often the ones using floats
18:41:26 <Iceland_jack> Also I believe Python has the additional complexity of object identity
18:41:27 <Iceland_jack>     >>> x, y = float('nan'), float('nan')
18:41:27 <Iceland_jack>     >>> s = {x}
18:41:27 <Iceland_jack>     >>> x in s # true
18:41:29 <Iceland_jack>     >>> y in s # false
18:41:53 <Iceland_jack> where 'x is x', 'y is not x' and 'x ≠ x' and 'y ≠ y'
18:42:46 <carter> ahdai:  limits are a thing
18:43:28 <Iceland_jack> nisstyre_: Here's the ticket for the abs btw https://ghc.haskell.org/trac/ghc/ticket/7858
18:44:39 <carter> ahdai: the ±0 stuff comes from having limits be a thing
18:45:01 <Iceland_jack> carter: Ping me if you started working on that, I can't promise much during my thesis but after that.. :)
18:45:10 <carter> whens your thesis?
18:45:15 <Iceland_jack> carter: Also I applied for volunteering at ICFP
18:45:15 <vozz> If I install something with cabal while ghci is open, and then try and import it, it complains it doesn't exist. Is there a way to refresh the package list from inside ghci?
18:45:21 <carter> Iceland_jack: cool!
18:45:28 <carter> vozz: no clue
18:45:50 <Iceland_jack> carter: Well I started working on it about a month or so ago, it will probably take 2 or 3 months more
18:45:58 <carter> ok
18:45:59 <carter> well
18:46:11 <carter> theres a very very good chance i won't have startd by then :)
18:46:25 <Iceland_jack> Excellent!
18:46:48 <Iceland_jack> Feel free to bounce ideas off me though
18:46:56 <carter> will do
18:51:43 <Tekmo> Iceland_jack: Good luck on your thesis!
18:51:54 <carter> i think we almost need merry focus
18:51:56 <csnate> Hello all I had a couple of questions.
18:52:06 <carter> someone might have answers!
18:52:11 <Iceland_jack> Thanks Tekmo! I'll be sure to bug #haskell questions :)
18:52:13 <Iceland_jack> *with
18:52:17 <derdon> Iceland_jack: float('nan') != float('nan')
18:52:18 <Tekmo> Iceland_jack: Great! :)
18:52:25 <csnate> I'm working on an Extendible Hash table in Haskell, its for a database project.
18:52:46 <ahdai> carter, I'm not sure what you're getting at about limits. If it wanted to treat -0.0 as identical to 0.0 (rather than their being more literally positive and negative infinitesimals), it should always return 0.0 where it currently returns -0.0, and the -0.0 bitpattern should be a NaN pattern.
18:52:46 <Iceland_jack> derdon: Oh, was that not what I said?
18:52:57 <Platz>  /j fsharp
18:52:58 <csnate> I've opted to implement the project in Haskell as I'm learning the language (I had the choice of language :) )
18:52:59 <derdon> Iceland_jack: it is, just in a more complicated way in my opinion ;)
18:53:24 <Iceland_jack> derdon: hah, yes but NaN is already not equal to NaN
18:53:45 <Iceland_jack> so that's nothing new, the important part is that you can have the same NaN's which is sometimes what the containers check
18:53:46 <csnate> Basically, is there any way you can have a pointer or reference in Haskell?
18:53:57 <Tekmo> csnate: Yes, sort of
18:54:30 <Tekmo> csnate: First off, before we continue, have you seen the `unordered-containers` library?
18:54:31 <carter> csnate: by value and by reference are the same for pure values
18:54:38 <carter> and pointers are a thing
18:54:41 <csnate> No I have not.
18:55:03 <Tekmo> csnate: It provides a very efficient implementation of hash tables
18:55:18 <carter> hashtables does too :)
18:55:22 <carter> @hackage hashtables
18:55:22 <lambdabot> http://hackage.haskell.org/package/hashtables
18:55:31 <ahdai> carter, (continued) but I think it's good that it has -0.0, for functions like arctan, in order to recognize that one zero is "the limit approaching zero from the positive", and the other is from the negative
18:55:32 <csnate> I actually have to implement the hash table myself, its for a school project.
18:55:54 <csnate> Well, to an extent anyway.
18:56:07 <Tekmo> csnate: So to answer your question about references, it depends on how you want to use it
18:56:32 <csnate> If you look at the Extendible Hash, you have a Map of keys to buckets.
18:57:23 <csnate> During insertion its possible to have to have two keys that point to the same Bucket.
18:57:39 <csnate> See: http://en.wikipedia.org/wiki/Extendible_hashing
18:58:38 * hackagebot bytestring-arbitrary 0.0.3 - Arbitrary instances for ByteStrings  http://hackage.haskell.org/package/bytestring-arbitrary-0.0.3 (tsuraan)
18:59:23 <Tekmo> csnate: So the brute force solution to references in Haskell is to simulate them within the language
18:59:43 <csnate> Would you say thats the best\only approach though?
19:00:25 <luite> hmm, those orphan instances packages are getting a bit of a pain, it's worse for data-default though
19:00:32 <dwcook> Tekmo, thanks for writing your free monad article. It helped me write a simple DSL. I especially had trouble working out how to write something :: Program Foo for some Foo when I didn't have a Foo to provide, and the article helped with that.
19:00:32 <Tekmo> csnate: The idea is that the Haskell language does not expose a notation of reference or pointer
19:00:43 <Tekmo> dwcook: You're welcome! :) I'm glad it helped
19:01:22 <Tekmo> csnate: The reason why is that providing arbitrary references to things breaks a lot of core principles of the language like optimizations or equational reasoning
19:01:32 <Tekmo> csnate: This is why you have to explicitly opt into them by simulating them
19:01:46 <csnate> Right, so how would one go about simulating them?
19:02:07 <Tekmo> csnate: The common way to do this is to have a data structure of the values you want to refer to, and then represent references as indices into that data structure
19:02:10 <carter> Tekmo: you don't have to simulate them
19:02:16 <carter> but lets pretend that for now :)
19:02:26 <Tekmo> csnate: For example, you can have a vector of values that you want to refer to
19:02:29 <Tekmo> csnate: And then you represent references as indices of that vector
19:02:34 * carter goes back to trying to get my compiler patch working
19:02:39 <Tekmo> csnate: Then mutating a reference is as simple as updating the index
19:02:44 <csnate> I see.
19:02:47 <carter> and its thread safe!
19:03:00 <Tekmo> csnate: So you're basically simulating memory within Haskell
19:03:05 <carter> and distributed thread safe!
19:03:11 <Tekmo> csnate: The data structure of values you refer to is like your "memory"
19:03:21 <Tekmo> csnate: ... and indices into that structure are "pointers"
19:03:59 <csnate> That makes sense.  So does the absense of references imply that Haskell is always pass-by-value?
19:04:07 <Tekmo> csnate: Note that if your data structure is an unboxed vector, then it will actually represent a contiguous block of memory, so the performance impact of this simulation is pretty minimal
19:04:24 <startling> csnate: not really.
19:04:27 <Tekmo> csnate: Yes.  Haskell always passes by value, but thanks to the fact that it is purely functional it never needs to copy values
19:04:45 <Tekmo> csnate: Values are immutable, so Haskell just shares them between all functions that need them
19:04:59 <startling> csnate: it's more like "everything's immutable, so there's no difference between a value and a pointer anyhow."
19:05:05 <Tekmo> ^
19:05:15 <Tekmo> startling is probably more accurate
19:05:18 <csnate> Ohh that makes sense.
19:05:53 <startling> in other words, pass-by-value and pass-by-reference are implementation details we don't need to care about.
19:05:54 <Tekmo> csnate: However, note that if you do need to mutate things there are ways to do that
19:06:08 <Tekmo> csnate: There are mutable vectors and mutable data cells, if you really need them
19:06:10 <carter> pass by reference === by value in a prue language
19:06:41 <sipa> talking implementation-wise, i'd say everything is pass by reference
19:06:45 <Tekmo> csnate: However, generally we try to minimize the use of mutable tricks because purely functional data structures have lots of advantages
19:07:04 <Tekmo> csnate: Like carter mentioned, they are always thread safe and you can reason about them equationally
19:07:15 <carter> and distributed systems like functional data
19:07:15 <carter> !
19:07:17 <Tekmo> csnate: Also, expressing algorithms in a purely functional way opens up opportunities for parallelism
19:07:21 <carter> you get transactionality for free!
19:07:26 <startling> haha
19:07:35 <carter> ish
19:07:56 <startling> > all (== "transactional
19:07:57 <lambdabot>  <hint>:1:23:
19:07:57 <lambdabot>      lexical error in string/character literal at end of input
19:07:58 <Tekmo> csnate: Also, you should check out the ST monad
19:08:00 <startling> > all (== "transactional) []
19:08:01 <lambdabot>  <hint>:1:27:
19:08:01 <lambdabot>      lexical error in string/character literal at end of input
19:08:08 <startling> > all (== "transactional") [] -- I can't type
19:08:09 <lambdabot>  True
19:08:12 <Tekmo> csnate: It's a way tha tyou can open up a mutable window, but then purify it by proving that no references leak
19:08:30 <Tekmo> csnate: The type system will enforce that no references escape the ST monad
19:09:52 <Iceland_jack> Tekmo: Side question, is the ST monad actually used much? It's a great idea and and excellent use of rank-2 polymorphism but I haven't seen it used much in the wild
19:10:03 <csnate> That's actually seems like it would be really useful.
19:10:07 <Tekmo> Iceland_jack: It's abstracted over by many libraries
19:10:14 <csnate> Still trying to wrap my head around monads.
19:10:24 <carter> ST monadic is amazing
19:10:27 <Tekmo> Iceland_jack: For example, the `vector` library uses it heavily
19:10:37 <Tekmo> Iceland_jack: However, you wouldn't realize it because the common user-facing API is already purified
19:10:39 <carter> Iceland_jack: in Vector you'll see PrimMOnad
19:10:49 <Iceland_jack> ah okay
19:10:49 <carter> which is code that can run in either ST or IO
19:11:17 <carter> Iceland_jack: in some of the code i'm writing these days you'll see the sam idea
19:11:25 <carter> PrimMonad all the things
19:11:27 <carter> granted
19:11:31 <Iceland_jack> carter: How does it actually perform?
19:11:31 <carter> you should be careful when you do that
19:11:34 <carter> umm
19:11:37 <carter> ST == IO
19:11:42 <carter> ish
19:11:53 <carter> how does what perform?
19:12:10 <carter> ST monad == ops that have IO siblings but don't leak mutation
19:12:12 <Tekmo> Iceland_jack: ST is the same speed as using IORefs (which is fast)
19:12:28 <Iceland_jack> Tekmo: okay thanks :)
19:12:32 <n^izzo> arch explicitly installed packages in chronological order
19:12:36 <Tekmo> Iceland_jack: Think of STRefs as being identical to IORefs
19:12:39 <n^izzo> Is there any way to list the explicitly installed pacages in chronological order
19:12:49 <carter> basically when ST things ar slower than there IO things, report it as a bug :)
19:13:04 <Tekmo> Iceland_jack: And IORefs are basically as fast as raw assignment statements in an imperative language
19:13:17 <carter> yeah
19:13:33 <Iceland_jack> I was actually always under the impression that IORefs were a bit slow.. did they used to be at one point or was I fed incorrect information? :)
19:13:41 <Tekmo> Iceland_jack: I used to think that, too
19:13:48 <carter> slow in what sense?
19:13:52 <Tekmo> Iceland_jack: I think it's just the fact that their usage is so verbose that makes people think they are slow
19:14:07 <Iceland_jack> Tekmo: haha that may actually be it
19:14:12 <carter> "it requires words  to write the code, it must be slow"
19:14:16 <Tekmo> Haha
19:14:17 <Iceland_jack> carter: slower than equivalent operations in other langauges
19:14:22 <carter> Iceland_jack: nah
19:14:30 <Iceland_jack> That's why pointfree code is faster
19:14:35 <carter> Iceland_jack: lies
19:14:37 <shachaf> Certainly in many cases using an IORefs is slower than writing the equivalent code in C (or even in Haskell in convoluted recursive non-IORef style, in some cases).
19:14:38 <Iceland_jack> carter: :)
19:14:39 <carter> pointfree code is actually slower
19:14:42 <carter> like
19:14:43 <carter> actually
19:14:52 <carter> yeah
19:14:55 <carter> 'cause of the boxing right?
19:14:59 <shachaf> IORefs are boxed pointers to boxed values stored on the heap.
19:15:08 <shachaf> As opposed to values stored in registers, say.
19:15:13 <carter> jah
19:15:32 <shachaf> If you write a function that counts to N recursively or using an IORef, in GHC, the first version will be way faster.
19:15:43 <carter> moar registers
19:15:43 <carter> yeah
19:15:45 <dolio> That's why you should have functions calling themselves with changing arguments, instead of using mutation. :)
19:15:55 <shachaf> Naturally.
19:15:59 <carter> ive some fun functional code that generates nice bit fiddling
19:16:46 <Iceland_jack> I'm wondering if there is a function similar to QC's 'suchThat :: Gen a -> (a -> Bool) -> Gen a' for System.Random...
19:18:01 <dolio> I don't think System.Random has a structure like Gen.
19:18:03 <Iceland_jack> I need to generate a even n-bit random number and
19:18:03 <Iceland_jack>     suchThat (choose (withBits n)) even
19:18:03 <Iceland_jack> is just excellent
19:18:33 <dolio> You could write something on top that worked similarly, I imagine.
19:18:41 <Iceland_jack> dolio: yeah, it could be written but from what I see you'd need a special function for suchThatR, suchThat, suchThatRIO, suchThatIO, ...
19:18:47 <shachaf> Generate an (n-1)-bit random number and double it.
19:19:37 <Iceland_jack> shachaf: clever, but it would be nice to have a more general way of doing it
19:20:21 <dwcook> Iceland_jack, what would suchThat do? Discard non-matching values?
19:20:47 <Iceland_jack> yeah, for System.Random it would probably return the last generator used as well
19:21:33 <Iceland_jack> *last generator returned
19:22:45 <Iceland_jack> I mean I implemented it at one point, didn't feel quite as elegant as QuickCheck's version
19:24:01 <startling> Iceland_jack: a more natural way to do it is just mapping the generated values to the wanted values somehow
19:24:01 * dwcook wonders why System.Random doesn't use a stream type
19:24:31 <Iceland_jack> startling: Can you give an example of what you mean?
19:24:41 <Tekmo> dwcook: That's because you only need an effect to get the generator.  Once you have that you can generate all values purely as an infinite list
19:24:52 <shachaf> You wouldn't believe how slow STRef/IORef is.
19:24:55 <startling> Iceland_jack: suchThat (< 5) is fmap (`mod` 5)
19:25:01 <shachaf> In fact, I don't trust my own benchmark.
19:25:10 <shachaf> So someone else here should try it and see if they get the same result.
19:25:18 <dolio> Iceland_jack: Even in quickcheck it's better to directly generate things you want than filtering out of a much larger set.
19:25:24 <carter> jah
19:25:36 <dwcook> Tekmo, it could be a trivial effect (e.g., Identity)
19:25:43 <dwcook> That would be pure
19:25:55 <Iceland_jack> dolio: That's right, but sometimes generating one or two more values is not too bad
19:26:02 <dolio> Iceland_jack: Anyhow, can you just use Gen from quickcheck? You can feed it with a StdGen, right?
19:26:08 <dolio> Just pretend it isn't a testing library.
19:26:09 <shachaf> I wonder what sort of class of predicate lets you efficiently generate things that match the predicate.
19:26:12 <Iceland_jack> I suppose I could yes
19:26:19 <shachaf> Is there a thing for that?
19:26:22 <startling> I'm wondering the same thing.
19:26:41 <Tekmo> dwcook: Yeah, but lists will be more efficient because of lower constant factors and a large system of fusible functions
19:26:47 <shachaf> And in what cases those predicates are composable.
19:26:52 <dolio> You could probably peel all the Gen stuff into a separate library and it'd be useful to have.
19:26:58 <Iceland_jack> shachaf: Test.QuickCheck.Function can do that ;)
19:27:02 <startling> predicates like (a \in B), where there's a surjection from A to B, I guess?
19:27:04 <Iceland_jack> In a very limited way of course..
19:27:05 <dolio> But that won't happen.
19:27:12 <shachaf> dolio: But that doesn't let you get a predicate easily, does it?
19:27:46 <dolio> I'm talking about what Iceland_jack wants.
19:27:51 <dolio> Which is Gen. :)
19:27:51 <Iceland_jack> ghci> quickCheck (\(Fun _ p) -> p "testing" ==> p "TESTING")
19:27:51 <Iceland_jack> *** Failed! Falsifiable (after 2 tests and 74 shrinks):
19:27:51 <Iceland_jack> {"testing"->True, _->False}
19:28:04 <shachaf> Oh. Sure.
19:28:06 <Iceland_jack> ;P
19:28:21 <dolio> Dunno about the predicates thing.
19:28:34 <Iceland_jack> The predicate question is interesting, I don't have the answer to that
19:28:49 <dolio> If you represented them syntactically, you might be able to compute inverses for sufficiently easy examples.
19:29:16 <Iceland_jack> dolio: Yes, it would be difficult to do that while preserving the distribution though?
19:30:07 <dolio> Yeah, that's a hard part, I guess.
19:30:22 <dolio> Depends what operations you allow.
19:30:25 <Iceland_jack> Yes
19:31:01 <dwcook> Tekmo, I think the interface could be nicer though. Instead of g -> (a, g) we could have Stream a where data Stream a = Cons a (Stream a), which seems to me like it'd be nicer to define operations over. Am I missing something?
19:31:08 <yogert> Hey all, I have a process spawned with "createProcess $ shell foo" that I'm trying to kill, but I'm not having any luck when using "terminateProcess". Any suggestiongs?
19:31:32 <Iceland_jack> If you have a type of A, B, C, D and the predicate only matches C and D then it would be trivial to make a single random value respect the predicate
19:31:41 <Iceland_jack> but for more ambitious data types or predicates..
19:31:56 <Tekmo> dwcook: There is a library with that type: http://hackage.haskell.org/package/Stream
19:32:02 <Tekmo> dwcook: Probably the simplest API would be:
19:32:02 <Iceland_jack> Reminds me of http://stackoverflow.com/questions/137783/expand-a-random-range-from-15-to-17 a bit
19:32:13 <Tekmo> dwcook: randoms :: Random a => IO (Stream a)
19:32:57 <yogert> Note, I'm on a *nix machine, so it should kill it...
19:33:09 <Iceland_jack> Tekmo: Isn't the generator an issue when dealing with random streams (unless it would be a stream of (a, g)'s)?
19:33:27 <dwcook> Iceland_jack, Stream a decomposes to an a and another Stream a, so Stream is the g
19:33:36 <dwcook> Stream a is the g*
19:33:53 <Iceland_jack> dwcook: ah of course..
19:34:32 <dwcook> g -> (a, g) is a function that in some sense also decomposes a stream
19:34:45 <Iceland_jack> wouldn't the simplest API then be something like
19:34:45 <Iceland_jack>     randoms :: (RandomGen g, Random a) => g -> Stream a
19:35:05 <Iceland_jack> since you can create 'randomIO' from that but not the other way around
19:35:33 <dwcook> That looks like a way to convert a generator into a stream, so that'd work fine once you had a generator
19:36:26 <yogert> Oh, and this process is a daemon btw
19:36:46 <gamegoblin> best way to express this regex in attoparsec? [A-z0-9][-A-z0-9]*[A-z0-9]?
19:37:01 <gamegoblin> That is, an alphanum, followed by any number of alphanum OR hyphen, followed by alphanum
19:37:54 <pavonia> that should be very straight-forward
19:38:19 <gamegoblin> it's the middle part that's messing with me
19:38:21 <gamegoblin> takeWhile (\w -> isAlphaNum w || w == 45) won't work
19:38:31 <gamegoblin> since it'll be greedy
19:38:35 <gamegoblin> and grab the last alphanum, too
19:38:47 <gamegoblin> So I need some sort of lookahead?
19:39:07 <gamegoblin> help appreciated
19:39:19 <dolio> Are you sure that's the regex you want anyway?
19:39:23 <gamegoblin> positive
19:39:27 <dolio> 2 alphanumbs if there are no hyphens?
19:39:32 <dolio> Er, alphanums.
19:39:33 <gamegoblin> yup
19:39:42 <gamegoblin> Right there in the URI spec
19:39:46 <Iceland_jack> What are people's thoughts on the System.Random's design by the way? Packages like crypto-random use a completely different interface for both the random values and the generator and packages like tf-random also use implements an alternative version of RandomGen to fix the brokenness of ‘split’
19:39:47 <Iceland_jack> Even though System.Random is not aiming to be cryptographically secure I feel like the design could be improved
19:39:50 <dolio> Ah.
19:40:09 <Iceland_jack> -use
19:40:33 <dolio> Iceland_jack: I think most people have moved beyond System.Random for anything remotely serious.
19:41:07 <pavonia> gamegoblin: let an = alphaNum in (\x xs y -> x : xs ++ [y]) <$> try an <*> many (try (char '-' <|> an)) <*> an
19:41:17 <gamegoblin> o_o
19:41:22 <pavonia> as a frist approximation
19:41:29 <pavonia> *first
19:41:38 <Iceland_jack> dolio: Yes but if Haskell were to start over, would the interface be redesigned so it could be used for non-serious as well as serious packages providing randomness? :)
19:42:41 <Iceland_jack> If there are any threads discussing this I'd be interested in them
19:43:05 <gamegoblin> You should read SPJ's papers on Backpack
19:43:11 <gamegoblin> it's an interesting idea
19:43:20 <Iceland_jack> I have :) it would be interesting if it ever gets added
19:43:44 * hackagebot lord 2.20140323 - A command line interface to online radios.  http://hackage.haskell.org/package/lord-2.20140323 (rnons)
19:43:44 <gamegoblin> It would seem to alleviate a lot of design issues since then all of your Random packages should move to having a spec'd API
19:44:27 <Iceland_jack> gamegoblin: even with Backpack you'd still like a well designed interface that can be used by many different libraries no?
19:44:51 <gamegoblin> Yes, but ideally all of your random libraries would implement the same specified interface
19:44:58 <gamegoblin> and hopefully that one would be good ;)
19:45:14 <Iceland_jack> Shifting the problem :)
19:45:23 <gamegoblin> Consolidating it, I guess
19:45:51 <Iceland_jack> But yes in that situation a type class wouldn't really be necessary (not that many libraries actually make use of System.Random's classes)
19:45:53 <gamegoblin> pavonia: Could you write that in non-applicative form? Not an applicative guru yet except for <|>
19:46:39 <gamegoblin> Or just walk me through it
19:46:57 <pavonia> Do you mean in do-notation?
19:47:07 <gamegoblin> that would work
19:47:14 <gamegoblin> just without the <$> and <*>
19:48:10 <pavonia> do { let an = alphaNum; x <- try an;  xs <- many (try (char '-' <|> an)); x' <- an; return (x : xs ++ [x']) }
19:48:15 <dolio> The docs say try doesn't do anything in attoparsec.
19:48:30 <pavonia> Ah, attoparsec, right
19:48:30 <dolio> It always backtracks.
19:48:55 <gamegoblin> on the attoparsec main page it says it does do something
19:49:01 <gamegoblin> but on the attoparsec.combinators page it says not
19:49:14 <gamegoblin> If you look at the source, there seem to be two different try's...
19:49:58 <dolio> I don't pay much attention to attoparsec.
19:50:06 <dolio> I seem to recall that it didn't have try way back.
19:50:15 <pavonia> I think someone here pointed out that the backtracking behavior is different depending on the stream type
19:50:17 <dolio> And then it was implemented in a weird way.
19:50:22 <dolio> But I'm not sure what the current state is.
19:50:35 <gamegoblin> pavonia: But it only supports ByteString?
19:51:09 <fread2282> how can I do "class (Biplate (t a) a) => Foo t"?
19:51:15 <pavonia> gamegoblin: No
19:51:18 <Platz> I thought you were supposed to implement "backtracking" in attoparsec with Alternatives from applicative
19:51:36 <Platz> parse  a <|> b
19:51:39 <dolio> fread2282: Can't, I believe.
19:51:52 <dolio> You have to add a to Foo's parameters.
19:51:52 <fread2282> dolio: :(
19:53:02 <dolio> What is that supposed to mean, for instance?
19:53:09 <dolio> forall a? exists a?
19:53:35 <dolio> The constraint language doesn't include those quantifiers.
19:55:10 <dolio> fread2282: What's the body of the class you want look like?
20:01:07 <gamegoblin> pavonia: I don't see how what you have is different from what I had
20:02:22 <pavonia> I didn't check the first and last charcter for being different
20:03:08 <pavonia> Err, *you didn't
20:03:25 <gamegoblin> I have
20:03:25 <gamegoblin>         a <- alphanum
20:03:26 <gamegoblin>         b <- takeWhile (\w -> isAlphaNum w || w == 45) -- 45 == '-'
20:03:26 <gamegoblin>         c <- alphanum
20:03:26 <gamegoblin>         return (snoc (cons a b) c)
20:03:39 <gamegoblin> (I just pasted the middle, as that was the problem)
20:04:21 <gamegoblin> and that doesn't work
20:04:28 <gamegoblin> the takeWhile is too greedy, I think
20:04:42 <gamegoblin> will the try's make a difference?
20:05:00 <pavonia> Oh wait
20:05:32 <pavonia> If the last charcter is a char, c fails to parse
20:05:46 <gamegoblin> exactly
20:05:59 <gamegoblin> Because b consumed it
20:06:03 <gamegoblin> but I'd like that not to happen
20:06:28 <pavonia> So even if try would work in attoparsec, it wouldn't help here
20:06:37 <gamegoblin> any ideas?
20:07:19 <pavonia> You could use lookAhead, but I guess there's a btter way
20:08:09 <dolio> What should happen if you have 'a-b-c-'?
20:08:44 <gamegoblin> it should fail
20:09:11 <dolio> Well, how, overall? That's just a parse failure?
20:09:29 <pavonia> Isn't there a combinator separatedBy, you could use that and join all results with '-' interspersed
20:09:36 <dolio> If so, you can parse alphanum(alphanum|-)* and then check that the last character is alphanum.
20:10:18 <dolio> Or something like that.
20:10:33 <td123> is push-notify the only haskell library available to send to APNs (apple's push notification server)?
20:10:44 <gamegoblin> mmmm I can do alphanum+(-alphanum+)*
20:11:11 <td123> asking because push-notify's example is returning thread blocked indefinitely in an MVar operation
20:18:08 <ezrios> @hoogle sepBy
20:18:09 <lambdabot> Text.ParserCombinators.ReadP sepBy :: ReadP a -> ReadP sep -> ReadP [a]
20:18:09 <lambdabot> Text.Parsec.Combinator sepBy :: Stream s m t => ParsecT s u m a -> ParsecT s u m sep -> ParsecT s u m [a]
20:18:09 <lambdabot> Text.ParserCombinators.Parsec.Combinator sepBy :: Stream s m t => ParsecT s u m a -> ParsecT s u m sep -> ParsecT s u m [a]
20:19:10 <Iceland_jack> http://www21.in.tum.de/~bulwahn/lpar18.pdf ← related to the conversations about generating random data satisfying a predicate (in Isabelle)
20:19:50 <ezrios> > parse (many alphaNum `sepBy` char '-') "" "a-asdfh82g-b"
20:19:52 <lambdabot>  Not in scope: `parse'Not in scope: `alphaNum'
20:19:55 <ezrios> damnit
20:20:43 <fread2282> dolio: it's really just to save me nasty refactoring all at once
20:20:44 <pavonia> :t sepBy
20:20:45 <lambdabot> Eq a => [a] -> [a] -> [[a]]
20:20:52 <pavonia> :t P.sepBy
20:20:53 <lambdabot> Couldn't find qualified module.
20:20:56 <fread2282> so I can just get rid of that class now
20:21:02 <ezrios> actually that parser doesn't even match the regex
20:21:07 <pavonia> :t Parsec.sepBy
20:21:07 <lambdabot> Couldn't find qualified module.
20:21:10 <ezrios> it would also succeed on "abc-def-ghi" :/
20:21:12 <pavonia> :(
20:21:17 <Iceland_jack> :t Text.ParserCombinators.ReadP.sepBy
20:21:18 <lambdabot> Text.ParserCombinators.ReadP.ReadP a -> Text.ParserCombinators.ReadP.ReadP sep -> Text.ParserCombinators.ReadP.ReadP [a]
20:21:31 <Iceland_jack> also
20:21:32 <Iceland_jack> :t Text.Parsec.Combinator.sepBy
20:21:32 <lambdabot> Text.Parsec.Prim.Stream s m t => Text.Parsec.Prim.ParsecT s u m a -> Text.Parsec.Prim.ParsecT s u m sep -> Text.Parsec.Prim.ParsecT s u m [a]
20:27:57 <thebnq> is there a standard or preferable IPC library
20:28:00 <cwvh> ((:) <$> ident <*> many1 (char '-' *> ident)) where ident = letter <|> digit
20:28:07 <thebnq> other than files or localhost sockets
20:30:42 <nisstyre_> thebnq: you can use things like Redis for that I guess
20:33:23 <thebnq> it suggests Hedis
20:34:20 <nisstyre_> "things like"
20:34:43 <nisstyre_> oh Hedis is a Redis library
20:35:20 <thebnq> it sounds neat, might try it, thanks
20:40:02 <startling> Does "the monomorphism restriction" allude to the categorical notion of monomorphisms somehow, or is it just "not polymorphism"?
20:42:14 <Iceland_jack> startling: not-polymorphism
20:42:54 <startling> ah. I guess sometimes there's no deep relationship between two things with the same name. :)
20:46:27 <shachaf> No relation.
20:57:25 <flebron> Is RWH still up-to-date w.r.t applicative parsing with Parsec?
20:59:21 <pavonia> Is the GADT version of "data Bar = forall a . Foo a => Bar a" this "data Bar where { Bar :: Foo a => a -> Bar }"?
21:00:49 <zq> yesh
21:02:04 <pavonia> And explicitly using "forall a. " in the GADT version wouldn't make a difference?
21:02:09 <zq> flebron: i depends if you want the parsec 2 or 3 api
21:02:18 <zq> flebron: from memory, rwh does 2
21:02:26 <flebron> I'd prefer using whatever's most up to date (I've never done parsing :p)
21:02:31 <zq> use 3
21:02:48 <zq> it's basically just using text.parsec.* instead of text.parsercombinators.parsec.*
21:03:12 <flebron> Yeah, Parsec's documentation seemed to just say "import Parsec".
21:03:18 <jmcarthur> no, those are not equivalent
21:03:30 <jmcarthur> oh wait
21:03:33 <jmcarthur> sorry, i misread
21:03:37 <jmcarthur> yes, they are
21:03:40 <flebron> (At http://legacy.cs.uu.nl/daan/download/parsec/parsec.html )
21:06:34 <flebron> If I am not in dire need of performance, is attoparsec still preferred over parsec? (Parsing a toy language here)
21:06:51 <yogert> Anyone know how to go about killing a daemon? I have it's PID, but despite sending sigQuit and sigKill signals it won't die
21:06:59 <startling> flebron: you should use trifecta instead of either. :)
21:07:34 <startling> yogert, is its parent restarting it>?
21:07:34 <yogert> and this daemon has been spawned using System.Process
21:07:41 <startling> haha
21:08:01 <flebron> startling: Is there some documentation on how to use it, other than Haddock?
21:08:21 <startling> flebron: not afaik but it's pretty straightforward
21:08:35 <flebron> (Considering I've never parsed anything with Haskell before)
21:08:44 <yogert> hah. I'm not sure, I have the process handle that "spawned the daemon", and i've tried terminating it with "terminateProcess" and then sending the signals to the daemon
21:08:59 <yogert> with no lucj
21:09:02 <startling> flebron: oh, useful to note that most of the meat of trifecta is in a separate library, 'parsers'
21:09:29 * flebron thinks he'll leave learning trifecta for at least tomorrow, when he's done parsing this toy language with parsec
21:09:44 <startling> flebron: you probably want to start with Text.Parser.Token and Text.Parser.Char
21:09:59 <startling> it's definitely easier to learn trifecta after using parsec.
21:10:06 <startling> (you can even use parsec with trifecta!)
21:10:15 <startling> the main benefit of trifecta is clang-like diagnostics
21:11:08 <MP2E> clang-like diagnostics sounds pretty great
21:11:16 <MP2E> clang's diagnostics are quite helpful :>
21:12:06 <zq> trifecta is a thing now?
21:12:07 <prooftechnique> @hackage trifecta
21:12:07 <lambdabot> http://hackage.haskell.org/package/trifecta
21:12:14 <prooftechnique> Neat
21:12:21 <MP2E> neat, thanks
21:12:24 * MP2E booksmarks
21:12:26 <zq> das ist neu
21:12:53 <startling> fsvo "new"
21:13:37 <zq> "kitchen sink"
21:14:04 <prooftechnique> Is there a high-level "This is how trifecta differs from parsec" sort of document?
21:14:11 <fragamus> is there a better way to convert my V2 to a pair: (\e->(e^._x,e^._y))
21:14:13 <startling> the other nice thing about trifecta is that it's implementation-independent. you can write a parser with parsers'/trifecta's combinators and use it with parsec or attoparsec
21:14:25 <startling> prooftechnique: it's mostly "most things are in typeclasses"
21:15:12 <yogert> Does anyone know why a daemon won't die despite sending sigKill and sigQuit signals, and terminating its parent process?
21:15:38 <zq> yogert: perms
21:15:39 <Javran> :t (.) . (.)
21:15:40 <lambdabot> (b -> c) -> (a -> a1 -> b) -> a -> a1 -> c
21:15:45 <zq> yogert: try an external kill -9
21:15:55 <dwcook> You probably broke the circle you summoned it with
21:16:10 <prooftechnique> fragamus: liftM2 (,) (^._x) (^._y)
21:16:16 <prooftechnique> Not really "better", though
21:16:31 <fragamus> no it really is
21:16:35 <fragamus> i like it
21:16:48 <browndawg> what do you guys use for building? Make? Or something else?
21:16:53 <MP2E> cabal
21:17:15 <MP2E> I tried to get cmake to work with haskell, trust me when I say: Don't try to shoehorn an existing build system into cabal
21:17:17 <prooftechnique> Shake is also fun for non-cabal-y things
21:17:17 <dwcook> browndawg, cabal
21:17:18 <MP2E> just use cabal
21:17:19 <MP2E> it'll make your life easier heh
21:17:24 <yogert> zq: so something like "createProcess $ shell 'kill −9'" ?
21:17:38 <zq> yogert: no, from a shell somewhere else
21:17:47 <browndawg> anything wrong with using make?
21:17:54 <browndawg> will be difficult to setup or something?
21:18:04 <prooftechnique> It's mostly just counterproductive
21:18:09 <MP2E> ^
21:18:09 <dwcook> browndawg, cabal setup is dead simple. make requires writing a makefile
21:18:13 <browndawg> I mean I just want to build project euler solutions
21:18:24 <browndawg> I've got like problem[1..].hs
21:18:27 <MP2E> well that doesn't really matter then :P
21:18:31 <prooftechnique> ghc --make
21:18:33 <browndawg> yeah that's what I said
21:18:33 <MP2E> yeah
21:18:42 <browndawg> not trying ot build something huge here
21:18:47 <browndawg> just individual euler solns
21:18:48 <MP2E> I'm actualyl doing project euler and I didn't even bother making a makefile
21:18:53 <MP2E> I just type out the ghc command
21:18:58 <yogert> zq: oh, well i can kill it, just not from within haskell
21:19:00 <dwcook> For that I wouldn't even bother compiling. runhaskell ftw
21:19:02 <browndawg> MP2E: For C solutions having a makefile helps.
21:19:09 <MP2E> C solutions, ah I see
21:19:11 <prooftechnique> Oh, sure, make is fine for that. You could also try out Shake
21:19:13 <MP2E> I'm doing it in haskell
21:19:18 <browndawg> to tell it to link stuff like gmp etc
21:19:30 <browndawg> MP2E: Me too.
21:19:39 <browndawg> which is why I asked if I should just use a similar makefile
21:19:43 <browndawg> or something else
21:19:55 <zq> yogert: maybe paste some proof of concept code
21:20:00 <yogert> ok
21:20:18 <MP2E> yeah makefile, shake, cabal, doesn't really matter with something that size.
21:20:20 <browndawg> prooftechnique: ah just read the man entry on ghc --make. Should do hte trick. TY
21:20:24 <MP2E> ghc --make yeah
21:20:31 <browndawg> otherwise cabal?
21:20:33 <MP2E> so many options!
21:20:34 <browndawg> thanks
21:20:36 <browndawg> yeah!
21:22:26 <yogert> zq: oo, i got it to work : ) I seems that there was a conditional that was always True which prevented the signals from being sent. silly me…
21:22:30 <yogert> thanks!
21:26:55 <prooftechnique> Is there some kind of cabal sandbox remove-source?
21:27:05 <prooftechnique> Or do I just delete the directory?
21:31:53 <prooftechnique> Side note, I'm really digging typed holes
21:32:45 <Quashie_> I'm highly amused by the fact that the final boss in the latest FFXIII game spawns "Monads"
21:33:19 <Quashie_> clearly, they are monsters
21:35:54 <Cale> Quashie_: Probably really a reference to the philosophical sense of the word (which has a different etymology) rather than the category theoretical one though :)
21:35:55 <prooftechnique> Do they split into dyads?
21:37:28 <Quashie_> Cale: True. There are plenty of references to Gnosticism in such games
21:38:03 <prooftechnique> Quashie_: The important question is "were they burritos or spacesuits?"
21:38:25 <Cale> It's curious that the Wikipedia page for monad seems to claim that the category theoretical one is somehow related to the philosophical usage, while I'm fairly certain it was just a portmanteau of monoid and triad (monads were originally often referred to as triples or triads).
21:40:58 <Quashie_> Map, fold, and join, I suppose
21:41:15 <Quashie_> Anyway, later
21:51:44 <jtcwang>  Hi people, I'm trying to construct a multiplication table for finite field multiplication
21:52:11 <jtcwang> I'm thinking of using data.vector
21:52:46 <jtcwang> since i need to do stuff like table[i] = x during the table construction
21:53:11 <jtcwang> i can see the ! operator for accessing
21:53:30 <jtcwang> but how would i 'modify' entry i of the table?
21:53:44 <prooftechnique> Sounds like a job for lens
21:53:47 <jtcwang> (i.e. create a new table with a new value at index i)
21:54:35 <jtcwang> i've read about it b4, but is there a way to avoid it for now?
21:55:00 <jtcwang> since i'm still relatively new to haskell, and i'd like to keep the source simple
21:56:56 <prooftechnique> jtcwang: This help? http://hackage.haskell.org/package/vector-0.10.9.1/docs/Data-Vector.html#g:14
21:57:46 <jtcwang> prooftechnique, just what i'm looking for
21:57:47 <jtcwang> cheers
21:58:00 <prooftechnique> No problemo
22:03:54 <vozz> Is there a guide somewhere for writing your own lenses? Finding it a bit confusing
22:04:02 * hackagebot zlib-bindings 0.1.1.4 - Low-level bindings to the zlib package.  http://hackage.haskell.org/package/zlib-bindings-0.1.1.4 (MichaelSnoyman)
22:08:20 <c_wraith> vozz: I'd start with SPJ's presentation on lens.  He makes it all seem simple and obvious.
22:11:23 <vozz> Ha, I just watched that
22:12:01 <vozz> but what's the function that takes a getter and a setter and makes a lens out of it?
22:12:08 <vozz> or I think maybe I want a traversal
22:21:50 <solidus-river> hey all, wheres the best place to start looking if i'm trying to set up a good development environment for building a haskell executable with cabal
22:21:58 <solidus-river> its dependent on two libraries
22:22:03 <ion> @type lens
22:22:04 <lambdabot> Functor f => (s -> a) -> (s -> b -> t) -> (a -> f b) -> s -> f t
22:22:48 <ion> solidus-river: “cabal sandbox init”, “cabal init”, modify blah.cabal, “cabal install”
22:24:38 <fragamus> ugh can someone tell me how to convert a number to string without scientific notation
22:25:13 <fragamus> 0.000007 not 0.7e-5
22:25:14 <dmwit> solidus-river: There's a page on the wiki about how to make a Haskell package. That's a very good place to start.
22:25:25 <dmwit> fragamus: Check the Numeric module.
22:25:33 <fragamus> i did
22:25:40 <fragamus> i dont get ShowS
22:26:02 <dmwit> ShowS is just the type of functions of the form (s++) for some string s.
22:26:14 <dmwit> If you've got a ShowS, and you want a String, pass it "".
22:26:40 <solidus-river> dmwit: ion i guess the first barrier i'm running into is that i'm using ubuntu 13.10 as my main platform and it seems to have an old version of cabal
22:26:48 <solidus-river> before cabal knew about sandbox's
22:26:55 <zq> sandboxes
22:27:02 <fragamus> > showFFloat Nothing (1.7e-8)
22:27:03 <lambdabot>  <[Char] -> [Char]>
22:27:13 <dmwit> > showFFloat Nothing 1.7e-8 ""
22:27:14 <lambdabot>  "0.000000017"
22:27:21 <fragamus> thanks
22:30:54 <ezrios> solidus-river: yeah you might as well build cabal from source
22:31:27 <ezrios> I ran into the same problem on an Ubuntu machine and it was more work figuring out how the hell to install cabal via package manager than to just build the damn thing
22:33:51 <jle`> i wouldn't touch anything haskell from ubuntu's package manager
22:34:34 <ezrios> more to the point, I wouldn't touch Ubuntu if I had a choice
22:35:00 <Welkin> ubuntu, or unity?
22:35:05 <ezrios> Welkin: both
22:35:40 <Welkin> I don't see anything wrong with ubuntu, as long as you use a different DE
22:36:07 <ezrios> after having used Gentoo portage I see Synaptic as a downgrade
22:37:59 <dwcook> jle`, I use Mint's Haskell packages, based probably entirely on Ubuntu's. What's the problem?
22:38:14 <mbuf> how do I fix this error? http://lpaste.net/101612
22:39:01 <dwcook> mbuf, it might be instructive if you looked at the types of xor2 and and2
22:39:07 <ion> solidus-river: I’m not using the distro packages at all. https://gist.github.com/ion1/2815423
22:39:51 <dwcook> jle`, oh never mind, I didn't read enough of the scrollback. I got just the compiler and cabal from it, none of the source packages.
22:40:08 <mbuf> dwcook, xor2 :: ( sig ~ Signal i) => sig Bool -> sig Bool -> sig Bool
22:40:21 <jle`> mbuf: so why are you trying to use xor on a tuple?
22:40:23 <flebron> Hi. Control.Applicative seems to export "Const". I have "Const" too. I want to import (<$>), (<*>), (<*), and (*>) from Control.Applicative, without importing Const. Is this doable? (I tried appending " hiding Const" after my import list, this fails with a parse error.)
22:40:46 <jle`> try import Control.Applicative hiding (Const)
22:41:02 <flebron> But I don't want to import everything from Control.Applicative, only those 4 things.
22:41:05 <dwcook> mbuf, I don't understand why that constrained is used, but it looks like you need to give it a Signal i Bool, not a tuple.
22:41:11 <dwcook> constraint*
22:41:29 <startling> flebron, import ((<$>), ...) hiding (Const) should do it
22:41:56 <startling> you might want "hiding (Const(..))", actually
22:42:04 <jle`> ^^
22:42:06 <flebron> Unfortunately doesn't. This is a parse error. "import Control.Applicative ((<$>), (<*>), (<*), (*>)) hiding (Const)"
22:42:35 <flebron> Same thing, the error is parsing, not semantics as Const(..) would be.
22:42:55 <solidus-river> ion: thanks for the link!
22:42:56 <flebron> The error message is "parse error on input `hiding'".
22:42:56 <ion> “hiding” would be redundant if you specify a list of names to import.
22:43:11 <flebron> ion: Yet "Const" is being imported without being in that list.
22:43:29 <solidus-river> aye, not a big fan of ubuntu either, unfortunately for anything cloud / web related, they rule supreme as a base image
22:44:01 <flebron> Oh, nevermind, that must be GHCi who's importing that.
22:44:03 <ion> flebron: http://lpaste.net/101614
22:44:18 <flebron> I'm running this in GHCi and imported Control.Applicative in GHCi.
22:44:45 <mbuf> dwcook, jle` I can give a type declaration for halfAdd
22:44:46 <flebron> Yeah, thanks :)
22:46:37 <dwcook> mbuf, doesn't matter since it's (a, b) that has the wrong type for how you're using it
22:46:48 <dwcook> mbuf, though that's generally a good idea anyway, yeah
22:46:55 <mbuf> dwcook, okay
22:47:08 <jle`> mbuf: if a function is, say, Int -> Bool, you can't give it a String; you can only give it an Int
22:47:51 <mbuf> jle`, right; didn't understand the definition of sig Bool
22:48:10 <mbuf> and (sig ~ Signal i)
22:48:22 <dwcook> mbuf, (sig ~ Signal i) means that sig is Signal i in what follows
22:48:37 <mbuf> dwcook, I see
22:48:42 <dwcook> Though I'm still unclear on why it's used there so it's possible I've misunderstood something
22:48:52 <jle`> is that really valid syntax? that sounds useful
22:49:10 <dwcook> My best guess is that it's just used to abbreviate
22:49:16 <dwcook> save some repetition
22:49:23 <dwcook> At least there
22:49:24 <jle`> yeah, i have always looked for local type aliases
22:49:43 <jle`> oh wow it works
22:49:53 <dwcook> Someone once tried to demonstrate to me an instance of something being functionally different if you replaced the variable for what it was equated with, but I didn't understand
22:50:03 <jle`> hm. darn
22:50:17 <jle`> well it does involve enabling type families, so it might be more complex than just a simple type alias
22:50:23 <jle`> or gadt's
22:50:31 <dwcook> Agreed, it may depend on how Signal is defined
22:50:36 <dwcook> mbuf, so what is this Signal type?
22:51:58 <jle`> it looks like it might be based on http://www.cis.upenn.edu/~bcpierce/courses/552-2008/resources/circuits.hs ?
22:57:45 <mbuf> BRB
23:15:15 <stevejb> hello, I am trying to apply a list of functions as seen in this  code snippet https://gist.github.com/99e2324bc18aa22e4779
23:15:53 <stevejb> however, I am clearly missing something
23:16:15 <jle`> stevejb: not exactly as clear as you seem to believe
23:16:21 <pavonia> You want "\fn wt -> ..." I guess
23:16:22 <jle`> can you put up what error you are getting?
23:16:47 <stevejb>     Parse error in pattern: fn
23:17:04 <jle`> also yeah, \(fn wt) doesn't make too much sense
23:17:10 <jle`> you can't apply functions inside patterns
23:17:21 <jle`> you can only pattern match on type constructors and things like that
23:17:21 <stevejb> jle`: ah, that is what I needed to know
23:17:27 <jle`> you probably want \fn wt ->
23:17:32 <jle`> which is a function that takes two parameters, fn and wt
23:18:04 <Iceland_jack> stevejb: You can *sort* of apply functions within patterns using an extension called ViewPatterns
23:18:05 <Iceland_jack> > let (length -> n) = "testing" in n
23:18:06 <lambdabot>  7
23:18:14 <stevejb> jle` yeah that was it.
23:18:14 <jle`> :O
23:18:38 <stevejb> Iceland_jack: Ah that is useful. I think that I wasn't intending to apply the function there, just a syntax thing
23:18:55 <Iceland_jack> stevejb: Yeah I gathered as much, it's a very nifty extension though :)
23:19:19 <stevejb> Iceland_jack: yeah it seems cool! Thanks for the reference.
23:19:22 <Iceland_jack> for example if you're feeling silly you can define the function ‘minimum’ as
23:19:23 <Iceland_jack>     minimum (sort -> x:_) = x
23:19:40 <stevejb> :)
23:19:57 <stevejb> I see, so the work is done in the pattern match, and all that is left is to return what the pattern match found? Am I reading that right
23:20:27 <Iceland_jack> Yes pretty much, it's the same as doing
23:20:27 <Iceland_jack>     minimum xs = case sort xs of
23:20:27 <Iceland_jack>         x:_ -> x
23:20:39 <Iceland_jack> > let (sort -> x:_) = [5,3,4,2,6,5,7,4,-434343,45,4] in x
23:20:40 <lambdabot>  -434343
23:20:56 <dmwit> The work isn't done in the pattern match. The work is done in sort.
23:21:04 <Iceland_jack> you can also compose functions and what not
23:21:04 <Iceland_jack> > let (head . sort -> x) = [5,3,4,2,6,5,7,4,-434343,45,4] in x
23:21:05 <lambdabot>  -434343
23:21:42 <Iceland_jack> stevejb: The only thing done in the pattern matching in the former example is matching on 'x:_'
23:21:56 <stevejb> Iceland_jack: ok.
23:22:29 <stevejb> thanks! That is good to know about
23:24:12 * hackagebot tls 1.2.4 - TLS/SSL protocol native implementation (Server and Client)  http://hackage.haskell.org/package/tls-1.2.4 (VincentHanquez)
23:24:14 * hackagebot tls-debug 0.3.2 - Set of programs for TLS testing and debugging  http://hackage.haskell.org/package/tls-debug-0.3.2 (VincentHanquez)
23:27:46 <flebron> Is this usually taken as syntactically valid lambda calculus? "(\x.x)\x.x" (as opposed to adding parenthesis to the second identity)
23:35:31 <flebron> For some reason, I can parse each of those things (i.e. identity with and without wrapping parens) fine with parseExpr, but "many1 parseExpr" hangs on that string.
23:41:22 <dmwit> You can set up perfectly good lambda calculus grammars for either answer to your first question.
23:41:42 <dmwit> If you want a good answer to your second question, I suspect you'll need to Show Us The Code.
23:42:43 <flebron> Parser code: http://lpaste.net/8277340373911601152
23:43:17 <flebron> The issue is that a Term cannot be just a \lambda... , and this is what I'm many1'ing.
23:43:38 <flebron> But when I change that many1 parseTerm on line 23 to many1 parseExpr, parseExpr hangs.
23:55:11 <dmwit> um
23:55:21 <dmwit> in case multiVarSugar doesn't match, that makes it
23:55:28 <dmwit> parseExpr = many1 parseExpr
23:55:35 <dmwit> You can't really expect that not to hang, can you?
23:57:08 <dmwit> s/multiVarSugar/variables/
