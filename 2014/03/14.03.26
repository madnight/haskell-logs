00:00:13 <johnw> it's magical :)
00:00:20 <no-n> very nice
00:00:37 <johnw> yeah, it's one of the best parallel/concurrent programming platforms I've ever used
00:01:21 <no-n> so how would I use forkIO to give this a CLI? http://www.haskell.org/haskellwiki/Roll_your_own_IRC_bot#Roll_your_own_monad
00:01:40 <no-n> you have to scroll down a little for the actual code
00:01:59 <no-n> http://www.haskell.org/haskellwiki/Roll_your_own_IRC_bot/Source or just see it here
00:02:41 <Aetherspawn> well
00:02:47 <Aetherspawn> there are rare cases where OS threads can be faster
00:02:55 <Aetherspawn> usually when related to cache coherency
00:03:03 <Aetherspawn> the OS is aware of things like that, whereas the haskell runtime doesn't care.
00:14:57 <no-n> are there any kinds of clean-up actions that the programmer has to invoke with lightweight-threads or is it all handled by haskell itself?
00:17:31 <dmj`> no-n: http://chimera.labs.oreilly.com/books/1230000000929/ch07.html
00:17:51 <redtricycle> I have ghc 7.6.2 installed to run xmonad (and various dependencies)
00:17:56 <no-n> ty
00:17:58 <redtricycle> and want to use haskell-platform, which requires ghc 7.6.3
00:18:08 <redtricycle> Is this going to break my xmonad if I upgrade?
00:18:14 <redtricycle> and install haskell-platform?
00:18:50 <johnw> no-n: the beauty of Haskell's lightweight threads is that the garbage collector does most of the work for you.  If you have resources that require effects to cleanup (some action in IO, for example), then you'll need to handle exception, for which the async library is one of the best approaches
00:19:09 <johnw> and is covered quite nicely in that book mentioned above
00:19:19 <no-n> awesome, thanks
00:19:26 <bitemyapp> Marlow's book is excellent. Async is a nice library.
00:19:32 <johnw> the beauty of it all should astonish you
00:19:42 <no-n> hehe
00:19:47 <bitemyapp> no-n: for bonus points, rewrite the CSP paper in terms of Async.
00:19:50 <bitemyapp> let us know how it goes.
00:20:01 <no-n> I don't even know what that is :P
00:20:17 <bitemyapp> no-n: http://en.wikipedia.org/wiki/Communicating_sequential_processes
00:26:05 <wirrbel> hi, I am using cabal with hsenv
00:26:24 <wirrbel> can I somehow prevent myself from installing packages when not using a haskell environment?
00:27:18 <wirrbel> I.e. I would like to have a safeguard so that I do not accidentally pull in a lot of packages in the userspace cabal "namespace" that would impose a dependency nightmare
00:30:37 <erisco> is there a shorter version of const (return ()) ?
00:31:22 <Kaidelong> that seems pretty short
00:32:39 <pavonia> :t (()<$)
00:32:40 <lambdabot> Functor f => f b -> f ()
00:33:20 <erisco> ah interesting but a bit cryptic I suppose. I'll define discardM = (()<$)
00:33:41 <pavonia> note that this will only work if you use it with monads
00:33:42 <jle`> void?
00:33:43 <erisco> well that works on functors so
00:33:44 <jle`> :t void
00:33:45 <lambdabot> Functor f => f a -> f ()
00:33:54 <pavonia> ha
00:34:04 <jle`> void requires a Functor constraint though so it can be annoying
00:34:08 <johnw> void and (()<$) both expect an argument
00:34:11 <johnw> const (return ()) does not
00:34:22 <johnw> oh, duh
00:34:23 <johnw> n/m
00:34:25 <johnw> too late at night fro me
00:35:01 <erisco> ah yes the annoying Monad does not require Applicative
00:35:17 <erisco> well const (return ()) it is then
00:35:17 <jle`> so i usually just do >> return ()
00:35:41 <jle`> :t const (return ())
00:35:41 <lambdabot> Monad m => b -> m ()
00:36:00 <sa1> beginner question: I have "type Value = String" defined in one module, which I import in another file. For a string "Adams" in the other file, which should be read as Value, I get "Couldn't match expected type `Value' with actual type `[Char]'"
00:36:03 <erisco> well I am using >=> so I cannot use >>
00:36:17 <jle`> you can use... pure?
00:36:32 <sa1> more specifically, I am trying to run http://weblogs.asp.net/brianbec/articles/246392.aspx this with sample database moved to another file
00:36:35 <jle`> but i guess you need Applicative too
00:36:36 <johnw> >=> void?
00:36:51 <jle`> i don't think void is a kleisli arrow
00:37:19 <jle`> but you are johnw
00:37:20 <erisco> discardM = const (return ()) and that'll be fine for now
00:37:23 <Kaidelong> sa1: that should work, unless String for some reason is defined differently from how it is in the prelude, but likely you should try {#- LANGUAGE OverloadedStrings -#}
00:37:55 <pavonia> Also, "which should be read as Value" sounds suspicious
00:38:07 <johnw> jle`: you are quite right
00:38:32 <jle`> :t pure ()
00:38:33 <lambdabot> Applicative f => f ()
00:38:47 <jle`> :t return () >=> pure ()
00:38:48 <lambdabot>     Couldn't match type `()' with `m0 b0'
00:38:48 <lambdabot>     Expected type: a0 -> m0 b0
00:38:48 <lambdabot>       Actual type: a0 -> ()
00:38:50 <jle`> darn
00:39:02 <smiller2> Hey guys, I'm confused by IORef.  If multiple threads have the same IORef value, where does the IORef reside?  Does each thread get their own copy?
00:39:03 <jle`> return () >=> pure (pure ())
00:39:07 <jle`> :t return () >=> pure (pure ())
00:39:07 <lambdabot>     Couldn't match type `()' with `f0 b0'
00:39:07 <lambdabot>     Expected type: a0 -> f0 b0
00:39:07 <lambdabot>       Actual type: a0 -> ()
00:39:30 <jle`> smiller2: you can think of an IORef like a pointer in the global memory
00:39:37 <erisco> return () does not unify with a -> m b
00:39:49 <jle`> oh yeah
00:39:54 <jle`> :t return >=> pure (pure ())
00:39:55 <lambdabot> (Monad f, Applicative f) => b -> f ()
00:40:00 <jle`> :t return >=> pure ()
00:40:01 <lambdabot>     Couldn't match type `()' with `m0 c0'
00:40:01 <lambdabot>     Expected type: b0 -> m0 c0
00:40:01 <lambdabot>       Actual type: b0 -> ()
00:40:14 * jle` sighs
00:40:32 <Kaidelong> @ty void . return
00:40:32 <lambdabot> (Monad f, Functor f) => a -> f ()
00:40:39 <erisco> your name ended up as a compile error in my code
00:40:39 <Kaidelong> that's a kleisli arrow
00:40:42 <erisco> window focus!
00:40:48 <bitemyapp> Kaidelong: 'tis a fish.
00:40:57 <jle`> Kaidelong: good job :)
00:41:00 <sa1> Kaidelong: thanks. I get "No instance for (Data.String.IsString Value) arising from the literal `"Adams"' add an instance declaration for (Data.String.IsString Value)"
00:41:04 <sa1> investigating
00:41:12 <bitemyapp> sa1: Overloaded Strings?
00:41:21 <sa1> yes, after Overloaded Strings
00:41:26 <erisco> Kaidelong, ah that is pleasant enough thanks
00:41:29 <bitemyapp> sa1: is that supposed to be getting coerced to Text or Bytestring or what?
00:41:41 <bitemyapp> sa1: are you expecting a library import to be doing the job for you?
00:41:58 <bitemyapp> sa1: if you haven't imported the instance (check your references), you need to write one.
00:42:04 <bitemyapp> sa1: or pack it explicitly.
00:42:09 <pavonia> sa1: Where in that file do you get the error?
00:42:13 <Kaidelong> well I was just firing a shot in the dark
00:42:18 <Kaidelong> his actual issue is much more mysterious
00:42:31 <Kaidelong> he has a type alias to String that doesn't match with [Char]
00:42:47 <sa1> pavonia: wherever strings are
00:42:48 <Kaidelong> I figured he was maybe using a library that overrides the Prelude String
00:42:59 <sa1> I didn't override anything.
00:42:59 <Kaidelong> and that thing likely had an IsString instance
00:43:10 <jle`> how insidious
00:43:26 <Peaker> 16% of my runtime is in https://github.com/ElastiLotem/buildsome/blob/master/src/Lib/Sock.hs#L17-L22  <-- this sounds weird.. this should be a trivial loop?
00:43:45 <jle`> Peaker: did you look at the core?
00:43:54 <Peaker> not yet
00:44:03 <sa1> How do I detect if it is overloaded? The only library I am importing is simple-sql-parser
00:44:49 <Kaidelong> sa1: try ":info String" in GHCi maybe?
00:45:16 <Kaidelong> prelude string is just "type String = [Char]"
00:45:55 <bitemyapp> Peaker: burn or wait?
00:46:27 <Peaker> bitemyapp: 16.2% time and 24.0% alloc according to +RTS -p
00:47:31 <sa1> Kaidelong: thanks, detected my error. In an earlier version of code, I had used data Value = String | Num instead of type Value = String. somehow that version was loaded
00:47:51 <Peaker> ghc-core-html is nice!
00:48:12 * bitemyapp jots down new tool to try
00:48:55 <jle`> oh that sounds neat
00:49:51 <Peaker> I don't see anything I could improve there :(
00:57:42 <eatman> Hello
00:58:11 <supki> Peaker: you can try to share maxFrameSize, f, and sock between the iterations
00:58:28 <supki> I wonder if ghc figures that out by itself
00:59:35 <[swift]_> there's no way to specify a class constraint on a type family, right?
00:59:58 <pavonia> supki: What does that mean, having the inner loop in a local function?
01:00:29 <supki> pavonia: yeah, or using fix
01:02:35 <DarkFox> How would one find the minimum value of [(a,b), (c,d)] comparing b and d, then output with a or c respectivly.
01:04:19 <pavonia> > map fst $ compareBy snd [(1,2), (3,4)]
01:04:20 <lambdabot>  Not in scope: `compareBy'
01:04:20 <lambdabot>  Perhaps you meant `compare' (imported from Data.Ord)
01:04:37 <DarkFox> @hoogle compareBy
01:04:37 <lambdabot> No results found
01:05:07 <DarkFox> pavonia: Try again? :P
01:05:26 <pavonia> I'm wondering what functions I was thinking of
01:05:34 * DarkFox too \o/
01:05:35 <pavonia> *function
01:06:45 <erisco> gorgeous... just wired up my first html template to reactive-banana all compiled by ghcjs and served over the webs
01:06:47 <dario> > map fst $ compare `on` snd $ [(1,2), (3,4)]
01:06:48 <lambdabot>  Precedence parsing error
01:06:48 <lambdabot>      cannot mix `GHC.Base.$' [infixr 0] and `Data.Function.on' [infixl 0] in ...
01:06:48 <lambdabot>      cannot mix `Data.Function.on' [infixl 0] and `GHC.Base.$' [infixr 0] in ...
01:07:05 <pavonia> > fst $ minimumBy (compare `on` snd) [(1,2), (3,4)]
01:07:06 <erisco> the text box says "waiting..." then when the ajax request fails it says "error!". fascinating
01:07:06 <lambdabot>  1
01:07:11 <pavonia> DarkFox: ^
01:07:29 <pavonia> > fst $ minimumBy (compare `on` snd) [(1,10), (3,4)]
01:07:30 <lambdabot>  3
01:07:37 <DarkFox> :D
01:07:38 <DarkFox> Yay
01:07:39 <DarkFox> Thanks
01:07:40 <apples> :t comparing
01:07:40 <lambdabot> Ord a => (b -> a) -> b -> b -> Ordering
01:11:11 <DarkFox> pavonia: I don't see any on nor minimumBy ?
01:11:24 <DarkFox> Well; on I see but no idea why lambdabot would...?
01:11:57 <pavonia> Data.List and Data.Function, I think
01:12:06 <pavonia> @hoogle on
01:12:06 <lambdabot> Data.Function on :: (b -> b -> c) -> (a -> b) -> a -> a -> c
01:12:07 <lambdabot> Control.Exception.Base onException :: IO a -> IO b -> IO a
01:12:07 <lambdabot> Control.Exception onException :: IO a -> IO b -> IO a
01:12:10 <pavonia> yup
01:12:57 <DarkFox> Yay
01:13:10 * DarkFox wonders if any better functions could be used?
01:14:40 <pavonia> comparing was mentioned
01:14:55 <pavonia> > fst $ minimumBy (comparing snd) [(1,10), (3,4)]
01:14:57 <lambdabot>  3
01:15:00 <DarkFox> Indeed
01:15:01 <DarkFox> Oh
01:15:05 <DarkFox> That's how you use comparing :D
01:15:19 <DarkFox> Cool
01:16:12 <DarkFox> > let f a = minimumBy (comparing snd) [(x, a `xor` 2^x) | x <- [0..256] ] in map f [2^5, 2^255-19]
01:16:13 <lambdabot>  [(5,0),(254,2894802230932904885589274625217197696331749616641014100986439600...
01:16:30 <pavonia> You could also use sortBy, if you consider that a better function :)
01:16:36 <jle`> woo hoo got my parallel arrows thing to work, merging reforks
01:16:57 <DarkFox> pavonia: I'm thinking about making a program to take numbers and compress them into mathamatical functions instead.
01:17:15 <DarkFox> Because factorzation is awesome :)
01:17:55 <DarkFox> There would probally be a lot of better ways that what I'm trying to do... but it's a concept / start for fun at least.
01:18:16 <DarkFox> s/that/for/
01:21:21 <no-n> (from Parallel and Concurrent Programming in Haskell) is there a reason why main itself doesn't recurse here? http://lpaste.net/5109470361506807808
01:21:34 <no-n> s/reason/good reason/
01:22:33 <Kaidelong> that seems suspicious, does the beahvior change if you actually just remove the where?
01:23:06 <no-n> didn't try it. i'm wondering if something get's "lost" if main itself is recursed
01:23:14 <no-n> gets*
01:24:33 <Axman6> no-n: I think it's convention more than anything
01:25:10 <no-n> there's something quite ninja about having a recursive main
01:25:35 <Axman6> main = do ... forkIO main ...
01:25:43 <no-n> not that :P
01:25:46 <Rembane> Haskell forkbomb?
01:25:53 <Axman6> I know, but that's also fun :P
01:25:57 <no-n> hehe
01:26:10 <no-n> does that just crash the whole system
01:26:30 * hackagebot tasty-html 0.1 - Render tasty output to HTML  http://hackage.haskell.org/package/tasty-html-0.1 (jdnavarro)
01:26:30 <Axman6> give it a try...
01:26:36 <no-n> no thanks
01:26:58 <Axman6> :(){:|:()};: # have I remembered that right?
01:27:11 <no-n> ?
01:27:14 <Axman6> oh, there needs to be a & in there too
01:27:15 <Kaidelong> I've actually written quite a few recursive mains
01:27:23 <Kaidelong> they're very handy for command line utilities
01:28:05 <Kaidelong> also most programs probably have some recursive IO somewhere
01:28:22 <Rembane> The recursive main makes it look like Erlang
01:28:40 <no-n> :t when
01:28:41 <lambdabot> Monad m => Bool -> m () -> m ()
01:28:52 <DarkFox> Axman6: No that is a zsh bom
01:28:57 <DarkFox> Similar not even right...
01:29:25 <DarkFox> :(){:|:&};:
01:29:31 <jle`> is there any way to automatically desguar a proc/do block?
01:29:33 <DarkFox> Don't run it ... please
01:29:33 <Axman6> that's the one
01:29:35 <jle`> an @unproc
01:30:03 <Axman6> that reminds me, I should read about arrow notation
01:30:28 <jle`> my code seems to work fine with manual arrow combinators but crashes with proc/do and i'm wondering what it's doing that is causing it to crash
01:31:31 * hackagebot attempt 0.4.0.1 - Concrete data type for handling extensible exceptions as failures. (deprecated)  http://hackage.haskell.org/package/attempt-0.4.0.1 (MichaelSnoyman)
01:31:33 * hackagebot wai-cors 0.1.0 - CORS for WAI  http://hackage.haskell.org/package/wai-cors-0.1.0 (larsk)
01:34:43 <jle`> oh
01:34:59 <jle`> it uses arr (\x -> (x,x)) instead of (id &&& id)
01:35:01 <jle`> :/
01:35:05 <jle`> which makes sense
01:36:13 <jle`> wait even if i use arr (\x -> (x,x)) with my normal combinators it still works
01:37:01 <jle`> i wonder if these are still up to date --- http://www.haskell.org/arrows/sugar.html
01:38:34 <mariomystic_> Is there a function available to multiply 2 Word64 to get both the result as Word64 and Carry as Word64?
01:41:06 <dmwit> mariomystic_: Dunno for sure. Can you get by with Integer instead?
01:41:37 <dmwit> jle`: You can ask GHC to print the desugared version.
01:41:44 <jle`> dmwit: really?
01:41:49 <dmwit> jle`: With -ddump-simpl or something like that.
01:41:56 <dmwit> Can't remember the exact flag, but stare at the Fine Manual.
01:42:08 <jle`> sure, will do
01:42:10 <jle`> thanks
01:43:56 <jle`> oh you can dump deriving output?
01:44:58 <bitemyapp> ddump-deriv
01:45:13 <bitemyapp> jle`: ^^
01:45:32 <jle`> yeah, i just saw that
01:45:38 <jle`> i think someone asked about that earlier and nobody answered them :
01:45:40 <jle`> :/
01:46:00 <bitemyapp> clearly I should stop eating, sleeping, and working and just answer questions >:)
01:46:05 <bitemyapp> blog post queued.
01:46:23 <luite_> mariomystic_: on 64 bit platforms it's the timesWord2# primop
01:46:32 * hackagebot nlp-scores 0.6.0 - Scoring functions commonly used for evaluation in NLP and IR  http://hackage.haskell.org/package/nlp-scores-0.6.0 (GrzegorzChrupala)
01:46:40 <luite_> otherwise the functions that the 64 bit multiply calls :)
01:51:33 * hackagebot swift-lda 0.7.0.0 - Online sampler for Latent Dirichlet Allocation  http://hackage.haskell.org/package/swift-lda-0.7.0.0 (GrzegorzChrupala)
01:52:44 <dmwit> bitemyapp: If people can't find it in the manual, what makes you think they'll find your blog post?
01:52:52 <dmwit> (...no offense to your awesome blog intended)
01:53:55 <dmwit> Ugh, now I feel like a jerk. That wasn't as fun of a joke as I thought it would be. Sorry.
01:54:48 <jle`> ah, i found the problem
01:54:57 <jle`> it looks like arrow desguaring doesn't use first and second
01:55:00 <jle`> it always uses first
01:55:11 <jle`> and it swaps the tuple and firsts, to use second
01:55:15 <dmwit> hah
01:55:24 <dmwit> nothing quite like generated code, eh?
01:55:52 <exicer> Anyone know if there is a way to generate higher dimensional distributions using random-fu ?
01:56:14 <jle`> well...
01:56:20 <jle`> is that actually one of the Arrow laws?
01:56:34 * hackagebot colada 0.8.0.0 - Colada implements incremental word class class induction  using online LDA  http://hackage.haskell.org/package/colada-0.8.0.0 (GrzegorzChrupala)
01:56:39 <jle`> that second f whould behave like arr swap . first f . arr swap
01:56:41 <jle`> ?
01:56:48 <dmwit> I would be shocked if it wasn't a law.
01:57:00 <jle`> arrow laws are actually surprisingly lax
01:57:13 <jle`> but i will check
01:57:30 <jle`> http://hackage.haskell.org/package/base-4.6.0.1/docs/Control-Arrow.html#t:Arrow
01:57:51 <jle`> nope
01:58:29 <jle`> no such arrow law
01:58:33 <jle`> that i can gleam
01:58:51 <dmwit> The original paper *defines* second in that way.
01:59:04 <jle`> yes but isn't that just a default implementation?
01:59:15 <jle`> ah
01:59:17 <jle`> oh it's a definition?
01:59:19 <jle`> i see.
01:59:21 <jle`> well then.
02:00:34 <dmwit> The laws listed in "base" don't even mention "second". Which should be a tip-off that they aren't complete.
02:01:24 <jle`> i've been using them as complete for a while, oops.  is there a definitive set of laws somewhere?
02:02:44 <dmwit> I don't know for sure, but I suspect that the laws listed there + the laws implied by the default definitions are it.
02:03:50 <dmwit> Oh, the original paper has a section named "Arrow Laws".
02:03:52 <dmwit> So that sounds promising.
02:05:31 <dmwit> Oh, and there's that rephrasing of arrows as a lambda calculus.
02:06:08 <dmwit> http://homepages.inf.ed.ac.uk/wadler/papers/arrows-jfp/arrows-jfp.pdf
02:06:11 <dmwit> highly recommended
02:06:25 <dmwit> Page 4 gives the classic arrrow laws.
02:11:55 <pavonia> It's somewhat scary that Google almost always chooses the version installed on my system when I search for a hackage package O.o
02:14:12 <DarkFox> pavonia: Would it be easily possible to get two minimal values ? (I.e. to compare against another function)
02:14:26 <DarkFox> Actually never mind
02:15:01 <dmwit> take 2 . sortBy (flip compare)
02:16:36 * hackagebot xml-catalog 1.1.0.2 - Parse XML catalog files (deprecated)  http://hackage.haskell.org/package/xml-catalog-1.1.0.2 (MichaelSnoyman)
02:16:38 * hackagebot uri-conduit 1.1.1.2 - Read and write URIs (deprecated)  http://hackage.haskell.org/package/uri-conduit-1.1.1.2 (MichaelSnoyman)
02:16:39 <pavonia> Why flip compare?
02:16:40 * hackagebot dtd 1.1.0.2 - Parse and render DTD files (deprecated)  http://hackage.haskell.org/package/dtd-1.1.0.2 (MichaelSnoyman)
02:16:47 * DarkFox confused
02:16:51 <pavonia> > sortBy (flip compare) [3,5,2,4,1]
02:16:52 <lambdabot>  [5,4,3,2,1]
02:16:56 <jle`> flip compare is reverse compare
02:17:02 <dmwit> Because I'm wrong.
02:17:26 * dmwit can never remember which way sort goes
02:18:14 <haskell_newb> hello, reading http://homepages.inf.ed.ac.uk/wadler/papers/arrows-jfp/arrows-jfp.pdf currently, what Ð“ means? E.g in types section on page 3
02:19:05 <opqdonut> haskell_newb: type context / type environment
02:19:05 <prophile> as I understand it, it's essentially "the set of known types"
02:19:09 <dmwit> Gammas are environments that tell the types of the variables currently in scope.
02:19:47 <haskell_newb> is it correct transcription of first one: if (x of type A) belongs to Ð“ then it's true that Ð“ entails (x of type A) ?
02:20:01 <dmwit> yes
02:20:03 <haskell_newb> dmwit, opqdonut got it
02:20:06 <haskell_newb> thanks
02:20:13 <haskell_newb> s/is/if/
02:20:20 <opqdonut> there was a nice introduction to type theory notation somewhere
02:20:22 * DarkFox can't see how to get this to link into the list of turples.
02:20:24 <opqdonut> but I can't seem to find it
02:20:35 <dmwit> TAPL? ;-)
02:20:41 <Krikey_Sanchez> I'd like read an int, and return a Maybe Int with Nothing if the read fails
02:20:43 <opqdonut> yeah TAPL is nice
02:20:45 <DarkFox> dmwit: Apparently not sortBy (compare . snd)...?
02:20:51 <Krikey_Sanchez> but it seems like read throws a runtime error if it can't parse something
02:20:53 <opqdonut> but I mean an online "cheat sheet"
02:20:53 <dmwit> Krikey_Sanchez: There's readMaybe. But you could also just use reads.
02:20:55 <dmwit> That's what I do.
02:21:05 <dmwit> (I have strong, unpopular opinions on this.)
02:21:16 <haskell_newb> yeah, cheat sheet sort of thing will be cool to have at hand
02:21:17 <dmwit> DarkFox: You might like "comparing".
02:21:30 <dmwit> > sortBy (comparing snd) [(1, "b"), (2, "a")]
02:21:31 <lambdabot>  [(2,"a"),(1,"b")]
02:21:35 <DarkFox> :)
02:21:37 * hackagebot failure 0.2.0.2 - A simple type class for success/failure computations. (deprecated)  http://hackage.haskell.org/package/failure-0.2.0.2 (MichaelSnoyman)
02:21:39 <DarkFox> Thanks
02:21:55 <DarkFox> I tried comparing . snd by mistake... :P
02:24:23 <haskell_newb> what Ð“, x : A entails N : B means?
02:24:40 <jle`> dmwit: ty
02:24:51 <haskell_newb> current scope have x of type A entails N of type B?
02:25:16 <dmwit> haskell_newb: It means if we extend the current scope by recording that x has type A, then N has type B in that extended context.
02:25:17 <opqdonut> current scope, _and_ x having type A entails N having type B
02:25:55 <haskell_newb> dmwit: hm, from where N comes from if extend context only by x of type A?
02:26:30 <opqdonut> concrete example: x:A, y:B :- (x,y) : (A,B)
02:26:37 * hackagebot yesod-core 1.2.9.1 - Creation of type-safe, RESTful web applications.  http://hackage.haskell.org/package/yesod-core-1.2.9.1 (MichaelSnoyman)
02:26:39 * hackagebot yesod 1.2.5.1 - Creation of type-safe, RESTful web applications.  http://hackage.haskell.org/package/yesod-1.2.5.1 (MichaelSnoyman)
02:26:50 <dmwit> haskell_newb: Where does it come from? I dunno, a programmer, Mars. What does that matter?
02:27:12 <haskell_newb> dmwit: ah, okay
02:29:36 <haskell_newb> uh, still can get that example with Ð“, x : A |- N : B...
02:30:43 <haskell_newb> upper part means that if current env and x variable in it having A type and that entails that N : B then what?
02:35:15 <haskell_newb> dmwit, opqdonut: coul you please translate it to me?
02:36:38 * hackagebot zlib-bindings 0.1.1.5 - Low-level bindings to the zlib package. (deprecated)  http://hackage.haskell.org/package/zlib-bindings-0.1.1.5 (MichaelSnoyman)
02:36:40 * hackagebot streaming-commons 0.1.0.0 - Common lower-level functions needed by various streaming data libraries  http://hackage.haskell.org/package/streaming-commons-0.1.0.0 (MichaelSnoyman)
02:41:39 * hackagebot text-stream-decode 0.1.0.5 - Streaming decoding functions for UTF encodings. (deprecated)  http://hackage.haskell.org/package/text-stream-decode-0.1.0.5 (MichaelSnoyman)
02:41:41 * hackagebot yesod-auth 1.3.0.0 - Authentication for Yesod.  http://hackage.haskell.org/package/yesod-auth-1.3.0.0 (MichaelSnoyman)
02:43:58 <mariomystic> I want to say Foo a = Foo {-# UNPACK #-} !a {-# UNPACK #-} !a , but I suppose this unpack pragma will be useless? Is there a way to say that `a` can always be unpacked ?
02:44:01 <no-n> does takeMVar empty an MVar?
02:44:18 <luite_> no-n: yes
02:44:42 <no-n> cool
02:44:55 <luite_> in fact there is nothing that reads an MVar without emptying it (readMVar empties it and then quickly puts back the result)
02:44:57 <no-n> kind of like leaving a secret package in a locker at an airport :o
02:46:40 * hackagebot html-conduit 1.1.0.3 - Parse HTML documents using xml-conduit datatypes.  http://hackage.haskell.org/package/html-conduit-1.1.0.3 (MichaelSnoyman)
02:46:42 * hackagebot xml-conduit 1.2.0 - Pure-Haskell utilities for dealing with XML with the conduit package.  http://hackage.haskell.org/package/xml-conduit-1.2.0 (MichaelSnoyman)
02:46:44 * hackagebot xml-hamlet 0.4.0.7 - Hamlet-style quasiquoter for XML content  http://hackage.haskell.org/package/xml-hamlet-0.4.0.7 (MichaelSnoyman)
02:49:19 <dmwit> haskell_newb: What example is that?
02:49:21 <no-n> :}
02:49:59 <dmwit> haskell_newb: There's a three place relation which relates typing contexts, language terms, and types.
02:50:00 <cwvh> mariomystic: the unpack will be useless and I know of no way you can hint the compiler that a can be unpacked (ghc won't know the size, and can't be told). If you throw on -Wall, you should get a warning about it.
02:50:25 <dmwit> haskell_newb: Gamma, x : A |- N : B says the triple with typing context Gamma, x : A, term N, and type B is in the relation.
02:50:33 <dmwit> There's not really much more to it than that.
02:51:06 <mariomystic> cwvh: Thats what I suspected thanks.
02:51:40 * hackagebot keter 1.2.1 - Web application deployment manager, focusing on Haskell web frameworks  http://hackage.haskell.org/package/keter-1.2.1 (MichaelSnoyman)
02:51:41 <dmwit> haskell_newb: Perhaps you are asking about the typing rule for lambda on page 3?
02:51:42 * hackagebot fdo-notify 0.3.1 - Desktop Notifications client  http://hackage.haskell.org/package/fdo-notify-0.3.1 (MaxRabkin)
02:52:55 <dmwit> haskell_newb: If so, it says: if we have some variables in scope, and we want to check that a lambda has an arrow type A -> B, then here's what we do: we put the lambda's variable in scope (with type A), and then check that the body of the lambda has type B.
02:55:48 <dmwit> haskell_newb: I've got to run. There are other smart people around who can help, but they won't know the context we have; so you might want to make your next question fairly self-contained.
02:56:48 <haskell_newb> dmwit: okay, thanks, sorry was afk
02:56:49 <no-n> omg, wow, like omg, cool (- my reaction to Control.Concurrent)
02:57:49 <DarkFox> Anyone here see any way to effeciently take a 256-bit number and factorize it into a series of smaller numbers (all below 1024) to create a mathamatical equation for that number...
02:59:24 <haskell_newb> can someone please translate that to english? http://lpaste.net/101779
03:02:40 <lyxia> haskell_newb: That looks like what dmwit addressed at 10:51. To show that \x.N : A -> B, in some context gamma, you show that N:B in the same context plus x:A.
03:05:04 <luite_> DarkFox: do the smaller numbers have to be something other than primes?
03:05:36 <luite_> DarkFox: or what does your 'mathematical equation' allow?
03:06:03 <DarkFox> luite_: The only goal is to take public 256-bit identity ephermal keys and output with a relativly easy to type equation to get the original number.
03:06:37 <DarkFox> luite_: Basic example I have (through brute force) reversed 2^255-19 -> (255,19)
03:07:32 <DarkFox> Ineffecient code...
03:07:53 <luite_> DarkFox: convert it to binary, only need 2 keys to type, what can be easier?
03:07:55 <luite_> :p
03:07:55 <DarkFox> > let g (x,y) = sortBy (comparing snd) [ (e, 2^(e-1) - y) | e <- [x, x+1] ]; f a = minimumBy (comparing snd) [ (x, a `xor` 2^x) | x <- [0..256] ] in drop 1 . g $ f (2^256-19)
03:07:57 <lambdabot>  [(256,19)]
03:08:16 <DarkFox> luite_: It won't compress onto a small card easily :(
03:08:57 <luite_> your result won't be shorter than the original anyway, in general
03:09:33 <luite_> (some shortness may come from extending the alphabet with operators, but it wouldn't be that much)
03:10:39 <haskell_newb> lyxia: gotcha, thank you
03:10:39 <DarkFox> luite_: compare "53^31+2^254" with 28948022309329048855893029751450258221975221692090709519171368715126845012381
03:10:57 <DarkFox> luite_: This is the goal :D
03:11:16 <luite_> DarkFox: that only works for a very tiny percentage of the numbers...
03:11:18 <lyxia> haskell_newb: You're welcome!
03:11:28 <DarkFox> Brute force is a quick thing to do with these 256-bit numbers ... luckly. :)
03:12:04 <luite_> DarkFox: if you generate the 256 bit number yourself, or there's a particular pattern in how they're generated, then you'd be able to do this
03:12:17 <DarkFox> luite_: The idea is to generate a set of possible keys until you find one where the public part returns a small enough equation.
03:13:35 <DarkFox> Shouldn't affect the security in any way unless there was a mapped relationship between the ability for a small equation and the possible numbers that could result.
03:13:41 <DarkFox> Which...
03:13:44 <luite_> DarkFox: hmm, i don't think that'd be a feasible approach
03:13:46 <luite_> well
03:13:49 <DarkFox> Even then; this is only the public part so not secret.
03:14:14 <luite_> for RSA keys a nice equation would contain the factors :)
03:14:26 <DarkFox> Those factors are too large
03:14:30 <DarkFox> And it's cheating :P
03:15:49 <luite_> DarkFox: but the problem is more information theoretical, you have 256 'random' bits, there is no general way to encode them more efficiently. if you want something that encodes to 100 bits shorter than 256 bits, you'd need to throw away around 2^99 before you find one on average
03:16:16 <DarkFox> The basic goal is to have a small program that generates a set of keys and attempts to generate a public where the equation is smaller than half the hex representation. So for a 256-bit number that would be 16bytes.
03:17:51 <luite_> DarkFox: so operators add a bit do your alphabet (but less than allowing operator chars for every digit), and thre are only about 8? you'd need to add 90 symbols (assuming decimal) to halve your encoded length in general
03:18:25 <DarkFox> It's not encoding; but rather factorizing.
03:18:51 <DarkFox> Which in a way; I guess is a form of encoding
03:19:30 <luite_> there are more ways you can look at the same problem, but if one way tells you it's impossible, it's not going to be more possible by just looking at it differently ;)
03:20:29 * DarkFox knows what you mean; but eventually (through brute force) there will be a reasonable result.
03:20:46 <luite_> DarkFox: not in reasonable time
03:21:00 <DarkFox> What do you define as resonable?
03:21:28 <bartavelle> ok, what's the relationship between church encoding and performance ?
03:21:44 * hackagebot bff-mono 0.2.0 - "Bidirectionalization for Free" for Monomorphic Transformations  http://hackage.haskell.org/package/bff-mono-0.2.0 (kztk)
03:22:04 <DarkFox> bartavelle: Hard to crunch, FAST for "decoding"
03:22:32 <bartavelle> why is it faster than pattern matching ?
03:22:42 <bartavelle> oh perhaps when you combine functions ?
03:22:50 <DarkFox> Or did I read your message incorrectly...?
03:22:54 <luite_> well, you said halve the encoed size (assuming hex original, decimal+operators result), i'd say reasonable would be a bit better than throwing out 2^128 rsults to get a usable one :)
03:23:20 <bartavelle> DarkFox, I read this (http://www.haskellforall.com/2014/03/introductions-to-advanced-haskell-topics.html) , and it says " .. use Church encoding for efficiency reasons .. "
03:23:34 <DarkFox> bartavelle: Then I read wrong
03:23:35 <bartavelle> so I read a bit about it, think I kind of have an idea of what it's about, but it seems I am wrong
03:23:46 <bartavelle> because I don't see how it helps performance
03:23:57 <bartavelle> I hoped that an answer would give me an insight
03:24:40 <bartavelle> it looks like a typical haskell problem : there are things that everyone seems to find useful, there are papers/blog posts explaining how they work, but it's hard to understand why you would want to use it at first glance
03:26:44 * hackagebot bff-mono 0.2.1 - "Bidirectionalization for Free" for Monomorphic Transformations  http://hackage.haskell.org/package/bff-mono-0.2.1 (kztk)
03:27:27 <DarkFox> luite_: What suggestions do you have for this problem?
03:28:16 <DarkFox> Pesudowords?
03:28:33 <DarkFox> Pseudowords *
03:29:34 <DarkFox> There was one for that; but I couldn't find it again. (It was very effective)
03:30:38 <luite_> DarkFox: dunno what there is exactly, but since you can't really win on actually making it shorter, it'd have to be in that kind of direction
03:32:46 <tero-> is there a better way to convert Int to Double than fromRational . toRational?
03:33:07 <Kaidelong> fromInteger
03:33:22 <Kaidelong> or fromIntegral
03:33:49 <tero-> ah, thanks
03:34:03 <Kaidelong> @hoogle (Num r) => Int -> r
03:34:04 <lambdabot> Data.Set elemAt :: Int -> Set a -> a
03:34:04 <lambdabot> Prelude (!!) :: [a] -> Int -> a
03:34:04 <lambdabot> Data.List (!!) :: [a] -> Int -> a
03:34:11 <Kaidelong> that was useless
03:34:27 <darthdeus> hey guys, what's the difference between these two? https://gist.github.com/darthdeus/26bf6eafba141c554aee
03:34:56 <darthdeus> is it that it can be two different functors instead of the same one?
03:35:28 <darthdeus> as in forall f. Functor f => (b -> f b) -> (a -> f a) means something like Functor f1, f2 => (b -> f1 b) -> (a -> f2 a)
03:35:30 <Kaidelong> is that legal haskell?
03:35:34 <DarkFox> Even if the equation is as long as the hex representation; it would be easier to confirm any segment in the case of a typo.
03:36:00 <darthdeus> Kaidelong: it's Rank2Types extension
03:36:11 * DarkFox asks W|A
03:37:07 <DarkFox> (For an example)
03:37:37 <DarkFox> 2^3Ã—19Ã—61Ã—5431Ã—6286849Ã—6490643Ã—12074639Ã—945409485184144216217986279321350587
03:37:43 <DarkFox> Well; thanks giant calculator -_-
03:38:41 <quicksilver> darthdeus: no.
03:38:55 <quicksilver> darthdeus: there is no difference between those two.
03:39:12 <quicksilver> the initial forall is logically there in both cases, but it's not part of standard haskell to write it.
03:40:04 <darthdeus> quicksilver:  why is it there in this case though? http://twanvl.nl/blog/haskell/cps-functional-references
03:40:39 <quicksilver> darthdeus: the author chose to write it because he thought it was clearer.
03:41:21 <Kaidelong> data .. = forall x. .. can have special meaning with some extensions though I think
03:41:23 <darthdeus> I don't understand why if it's the default behavior here and he doesn't use it any further
03:41:46 * DarkFox offline
03:47:03 <Cale> This reminds me of that old comp.compression $5000 challenge
03:48:56 <Cale> http://www.faqs.org/faqs/compression-faq/part1/section-8.html
03:49:48 <b_jonas> Cale: if you want an ongoing compression challenge, see http://www.mailcom.com/challenge/
03:52:10 <Cale> That sounds like a more sincere sort of challenge.
03:57:00 <dirtyObject> But does it blend?
04:01:54 <quicksilver> Cale: I find it very depressing to read evidence of smart people wasting their debunking fraudulent claims. What a waste of energy.
04:04:26 <Cale> quicksilver: For a $100 processing fee :)
04:10:18 <quicksilver> Cale: yes, but the effort in writing that FAQ entry, and the effort evidently put in to various of the newsgroup threads referenced.
04:26:53 * hackagebot hakyll 4.5.0.0 - A static website compiler library  http://hackage.haskell.org/package/hakyll-4.5.0.0 (JasperVanDerJeugt)
04:37:52 <haasn> Anybody familiar with repa? I have an Array F DIM3 Word8 and I want to map over the inner Array F DIM1 Word8
04:38:02 <haasn> all of the mapping functions I can find only let me map over individual Word8s..
04:42:53 <beaky> hello
04:43:02 <beaky> how do i write a basic webserver in haskell
04:47:10 <vlatkoB> In Repa for DIM3 (x,y,z), is it possible to fold over only two dimensions (x,y) and get whole z dimension at once (unlike foldP)?
04:50:48 <mniip> vlatkoB, not familiar with what you're using, but it seems logical to just map 2d-folding over z dimension
04:54:49 <vlatkoB> z are color channels and I'd like them in a tuple, so I need all zs at once. Just started experimenting with repa.
04:56:44 <beaky> how do i get cabal to automagically install the dependencies that my haskell app depends on
04:56:52 <beaky> like gem install
04:58:45 <r444> beaky: cabal install --dependencies-only
05:00:02 <r444> beaky: also i think you mean "bundle", not "gem install"
05:01:43 <beaky> oh right :D
05:02:03 <beaky> wow tons of libraries just to use scotty
05:02:19 <beaky> I wonder how i will manage dependency hell
05:02:58 <beaky> haskell compiles quite fast compared to c++
05:03:19 <r444> google "cabal dev"/"cabal sandbox"
05:03:37 <r444> s/cabal\sdev/cabal-dev/
05:04:39 <beaky> what does cabal-dev and cabal sandbox do
05:04:46 <beaky> i thought cabal-dev was a development version of cabal
05:05:36 <r444> beaky: basic sandboxing functionality
05:06:21 <beaky> how do i run haskell in the raspberry pi
05:06:23 <r444> beaky: think of bundler
05:07:14 <shiona> beaky: like on any other linux box? except that arm doesn't (or at least didn't) handle TH at all, so you're quite limited
05:08:11 <beaky> aww :(
05:08:24 <beaky> i wonder why arm doesnt like TH  i thought it was cross platform
05:11:20 <macanudoman> beaky: there is ghc and cabal and all, the only thing it doesnt come with the haskell platform its ghci
05:11:31 <dibblego> http://lpaste.net/101781 does this exist anywhere?
05:11:58 * hackagebot wai-handler-devel 2.0.0.2 - WAI server that automatically reloads code after modification. (deprecated)  http://hackage.haskell.org/package/wai-handler-devel-2.0.0.2 (MichaelSnoyman)
05:12:00 * hackagebot sequor 0.7.0 - A sequence labeler based on Collins's sequence perceptron.  http://hackage.haskell.org/package/sequor-0.7.0 (GrzegorzChrupala)
05:23:13 <beaky> should i prefer join, mconcat, or concat to turn a [[a]] to an [a]
05:24:42 <fragamus> hey edwardk how come when i use a V2 as a key to a hashmap i get _|_ on invoking insertWithKey
05:34:36 <beaky> why do i get this mesage: "Thread killed by Warp's timeout reaper"
05:35:28 <tdammers> beaky: not 100% sure, but my theory is that Warp kills waiting worker threads after a timeout
05:35:38 <tdammers> from what I've gathered, it's harmless
05:36:01 <spacekitteh> You know how the Category class expects kind * -> * -> *? How can I specify constraints on the first two types? E.g. how can I specify "instance (Algebra.Field.C a, Ord a, Algebra.Field.C b, Ord b) => Category (AffineOperator a b)"?
05:37:29 <merijn> spacekitteh: You can't
05:37:43 <merijn> spacekitteh: Same reason you can put constraints on the arguments to a functor instance
05:37:50 <merijn> spacekitteh: (hence why Set isn't a functor)
05:37:56 <spacekitteh> fuck, ok
05:38:06 <yogurt_truck> when was `>>=` first called "bind"?
05:38:13 <yogurt_truck> in the wadler paper?
05:38:23 <merijn> yogurt_truck: I think the term "bind" predates >>=
05:40:10 <spacekitteh> merijn: that's really annoying. i can make LinearOperator a category but not AffineOperator because i can't access Algebra.Additive.zero :<
05:40:31 <yogurt_truck> merijn: I see
05:42:01 * hackagebot sequor 0.7.1 - A sequence labeler based on Collins's sequence perceptron.  http://hackage.haskell.org/package/sequor-0.7.1 (GrzegorzChrupala)
05:55:45 <no-n> let (head:tail) = [1..10] in head
05:55:53 <no-n> > let (head:tail) = [1..10] in head
05:55:55 <lambdabot>  1
05:57:03 * hackagebot wai-app-static 2.0.1 - WAI application for static serving  http://hackage.haskell.org/package/wai-app-static-2.0.1 (MichaelSnoyman)
06:29:45 <regtools> .j #python
06:35:39 <hemanth> Define Haskell in a line: "It's a Purely functional programming language which is Statically typed and lazily evaluated" sounds good?
06:37:02 <tdammers> purely? pure?
06:37:23 <tdammers> also, Haskell can do strict evaluation
06:37:31 <tdammers> it just defaults to lazy
06:37:41 <Averell> If you understand the description you already knew anyway.
06:37:49 <hemanth> purely a pure functional ;)
06:38:01 <no-n> #define SOMETHING 42 // can you do this in Haskell
06:38:30 <Hodapp> hemanth: why capitalize Purely and Statically?
06:38:43 <tdammers> no-n: yes... if you enable CPP...
06:38:50 <hemanth> Hodapp, will fix that, thanks.
06:39:01 <no-n> all right. might be something i will look into but not right now.
06:39:09 <tdammers> no-n: but if all you want is a constant, I'd just define it as a top-level binding
06:39:14 <tdammers> something = 42
06:39:38 <no-n> yeah. makes sense.
06:40:06 <hemanth> let something = 42
06:40:28 <tdammers> hemanth: depends on context... if you want it to be global, don't use let, but put it at the top level
06:40:37 <tdammers> (module-global, that is)
06:41:27 <beaky> http://lpaste.net/101783 how do i improve my website
06:41:34 <beaky> i wrote a purely functional website with scotty
06:41:52 <no-n> (slightly off-topic): do IRC server codes differ across networks?
06:42:13 <hemanth> tdammers, hmm, but in the REPL, it won't work without let, right?
06:42:19 <tdammers> hemanth: no
06:42:22 <no-n> the 3-digit number you get in a server message, that is
06:42:36 <tdammers> hemanth: the repl wraps everything in some sort of implicit do {} block
06:43:04 <tdammers> hemanth: that's why you can suffice with let foo = bar
06:43:09 <tdammers> hemanth: without "in"
06:44:24 <tdammers> beaky: add more features!
06:44:25 <beaky> @pl f g = a . b . c . d . g
06:44:25 <lambdabot> f = ((a . b . c . d) .)
06:44:49 <hemanth> tdammers, interesting, I'm working on http://github.com/hemanth/haskell-rascal I would be very happy to get your suggestion there, it's WIP; algoriddle I also keeping an eye on it :)
06:47:44 <tdammers> hemanth: have you checked the "canonical" learning resources?
06:47:50 <tdammers> Gentle Introduction, LYAH, RWH?
06:49:06 <peteretep> hemanth: I have been writing a series of exercises to teach people monads
06:49:21 <peteretep> They seem to still be a little too difficult
06:49:34 <peteretep> I think I will swap from Writer Monad to Maybe as the first one to introduce
06:50:20 <hemanth> tdammers, Yes I have checked them :)
06:50:45 <hemanth> peteretep, über kool, any link? Was trying to apply them in javascript :)
06:50:58 <tdammers> javascript *is* a monad :P
06:51:06 <hemanth> heh heh
06:51:31 * tdammers catches himself writing `var foo <- bar();` in JS all the time
06:52:07 <makalu> which of the numerous error reporting mechanisms should be used in haskell?
06:52:10 <peteretep> So I tried to write Monad tutorials in Perl too
06:52:11 <peteretep> but
06:52:13 <peteretep> Like in JS
06:52:18 <peteretep> Because there's no real need for it
06:52:21 <peteretep> Because it doesn't solve any problem
06:52:24 <peteretep> Hard to make it stick
06:52:27 <grohne> makalu: depends on the error. ;-)
06:52:27 <hemanth> tdammers, you can soon write them as var foo = () -> "hello"
06:52:42 <hemanth> correction : var foo = () => "hello"
06:52:47 <grohne> makalu: so if something really is a programming error, use error
06:52:49 <peteretep> You end up having to say "Hey, so imagine 20 constraints that JS doesn't have, and then..."
06:53:14 <peteretep> Need a Maybe monad? nah, just throw an exception and catch it
06:53:30 <peteretep> Need the IO Monad? You're already in it
06:53:30 <grohne> makalu: otherwise MonadError might help
06:53:31 <peteretep> etc. etc.
06:54:03 <tdammers> hemanth: coffeescript? nah. not worth the hassle.
06:54:08 <grohne> makalu: specifically try to avoid "fail"
06:54:14 <hemanth> tdammers, no pure javascript!
06:54:19 <tdammers> oh, hey
06:54:21 <tdammers> well
06:54:27 <tdammers> still, just syntax, really
06:54:28 <makalu> grohne: why should I avoid fail?
06:54:38 <hemanth> tdammers, http://h3manth.com/content/arrow-functions-javascript
06:54:53 <hemanth> few new things, you might like https://speakerdeck.com/gnumanth/harmony-with-es6
06:55:36 <grohne> makalu: for one thing because it changed behavior from ghc6 to ghc7, and then it is conceptually not well defined what it means and has no provisions to give structured errors
06:56:17 <makalu> what are structured errors?
06:56:23 <grohne> strings
06:56:37 <grohne> err that are unstructured erros
06:56:54 <tdammers> I'm not going to click through a slideshow with bite-sized chunks of microinformation
06:56:56 <grohne> you are looking for instances of the Error class
06:56:58 <tdammers> other than that, I approve
07:01:41 <prooftechnique> Is it me, or is Vector.concat better than V.++ basically all the time?
07:04:06 <edwardk> @tell fragramus good question. what is the key you're using?
07:04:06 <lambdabot> Consider it noted.
07:06:02 <quicksilver> prooftechnique: no.
07:06:42 <quicksilver> well I don't see how it can be
07:06:48 <quicksilver> I think the complexity annotation is confusing and/or wrong
07:07:12 * hackagebot project-template 0.1.4 - Specify Haskell project templates and generate files  http://hackage.haskell.org/package/project-template-0.1.4 (MichaelSnoyman)
07:08:25 <prooftechnique> I only ask because I got a 2x speedup switching from V.++ to V.concat with a 2-element list, which seemed really weird
07:08:36 <quicksilver> prooftechnique: oh, well maybe it is then :)
07:08:47 <quicksilver> prooftechnique: probably an optimisation bug, you should report it.
07:09:32 <prooftechnique> I'm also on 7.8, so maybe there's some new fancy thing under the hood :D
07:10:05 <prooftechnique> I was just expecting V.concat to be written in terms of V.++, but it turned out they were completely separate
07:10:51 <beaky> hello
07:10:55 <beaky> why is church encoding useful
07:11:02 <beaky> it seems to do what data already does
07:11:39 <haskell_newb> hi
07:11:44 <beaky> hello haskell_newb
07:11:50 <edwardk> @tell fragramus we appear to be missing Hashable instances for one. adding
07:11:50 <lambdabot> Consider it noted.
07:11:52 <haskell_newb> is it possible it implement clos on top of haskell as linrary?
07:13:44 <prooftechnique> @faq Can I implement CLOS?
07:13:44 <lambdabot> The answer is: Yes! Haskell can do that.
07:13:46 <haskell_newb> clos - https://en.wikipedia.org/wiki/Common_Lisp_Object_System
07:14:22 <haskell_newb> prooftechnique: how?
07:14:28 <troydm> prooftechnique: if u are wondering about clos, i think the closest thing to clos in haskell world is lenses
07:14:48 <prooftechnique> troydm: It was a joke for the benefit of haskell_newb
07:14:56 <beaky> haskell is already an ad-hoc, informally-specified, bug-ridden, slow implementation of half of common lisp
07:15:01 <quchen> You can do things that are arguably OOP in Haskell, but I don't think I've seen a place where this is a good idea. (It also depends a lot on what you mean with "OOP" of course.)
07:15:14 <haskell_newb> beaky: he-he
07:15:29 <haskell_newb> quchen: by oop i mean clos :)
07:15:43 <troydm> ic
07:16:29 <haskell_newb> beaky: actually ghc should be faster than most of cl implementations :)
07:16:29 <peteretep> Once you have polymorphism, what more do you need?
07:17:06 <prooftechnique> Parentheses, obviously
07:17:17 <haskell_newb> peteretep: inheritance
07:20:07 <edwardk> @tell danharah what was the definition of Data.Profunctor.Lift we worked out? wasn't it just the profunctor like Rift on the othr argument?
07:20:07 <lambdabot> Consider it noted.
07:20:15 <edwardk> @tell danharaj what was the definition of Data.Profunctor.Lift we worked out? wasn't it just the profunctor like Rift on the othr argument?
07:20:15 <lambdabot> Consider it noted.
07:21:45 <beaky> Flat is better than nested.
07:21:52 <beaky> oops wrong channel
07:26:27 <prooftechnique> Some user called danharah is gonna come in someday and be so confused
07:26:32 <kqr> hah
07:27:14 * hackagebot http-reverse-proxy 0.3.1.2 - Reverse proxy HTTP requests, either over raw sockets or with WAI  http://hackage.haskell.org/package/http-reverse-proxy-0.3.1.2 (MichaelSnoyman)
07:37:37 <makalu> what does "reify" mean?
07:39:34 <edwardk> makalu: http://stackoverflow.com/a/5316014/34707
07:39:47 <makalu> thank you
07:41:28 <kgadek> hi. I've got a strange behaviour of cabal sandboxes on OS X. When in ~/tmp2, cabal sandbox init, cabal install <things>, I get some binaries in global location, ie. /Users/konrad/Library/Haskell/bin
07:41:45 <kgadek> actually there are symlinks: /Users/konrad/Library/Haskell/bin//ghc-pkg -> ../../../tmp2/.cabal-sandbox/bin/ghc-pkg
07:41:57 <kgadek> what's happening?
07:42:16 * hackagebot profunctors 4.0.3 - Profunctors  http://hackage.haskell.org/package/profunctors-4.0.3 (EdwardKmett)
07:57:20 <dagle> http://lpaste.net/101788 , Idk if this is possible with haskells typesystem but it would make my code a bit "cuter".
07:58:05 <quicksilver> dagle: class Test a where unbox :: a b -> IO b
07:58:13 <quicksilver> dagle: ..would be perfectly legal.
07:58:35 <quicksilver> and you could make IORef an instance of it, which would then work for everything not just Int.
08:00:59 <edwardk> dagle: inference for the type you've given will be terible. you really want a to determine b or vice versa if you can
08:03:17 <quicksilver> edwardk: well as it happens he doesnt' need b at all, for now. But it's not clear what other instances he might have in mind.
08:03:32 <edwardk> quicksilver: exactly
08:12:19 * hackagebot gang-of-threads 3.0.0 - Non-deterministic parallelism with bags  http://hackage.haskell.org/package/gang-of-threads-3.0.0 (bholst)
08:13:42 <Galactic> is there a quick way of merging two list and returning a list only with the similar elements on both, for example: [1,5,25] and [1,2,4,5,10,25] should return [1,5,25]
08:14:19 <Fuuzetsu> @hoogle intersect
08:14:20 <lambdabot> Data.List intersect :: Eq a => [a] -> [a] -> [a]
08:14:20 <lambdabot> Data.List intersectBy :: (a -> a -> Bool) -> [a] -> [a] -> [a]
08:14:20 <lambdabot> System.Posix.Files.ByteString intersectFileModes :: FileMode -> FileMode -> FileMode
08:14:38 <Fuuzetsu> > intersect [1, 5, 25] [1,2,4,5,10,25]
08:14:39 <lambdabot>  [1,5,25]
08:14:47 <Galactic> wow thanks.
08:15:07 <yitz> Galactic: depends what you mean by "quick". intersect is O(n^2).
08:15:16 <Galactic> o dam that sucks
08:15:29 <Fuuzetsu> you're not going to do much better with a linked list, if you want speed pick a different data atype
08:15:32 <Fuuzetsu> data type*
08:16:04 <Fuuzetsu> you can uses view patterns and stuff to keep more or less the same interface
08:16:17 <yitz> Galactic: intersect is probably fine if you won't have more than a few hundred elements.
08:16:42 <Galactic> I am trying to find number of common divisors two number have
08:16:54 <artyomkazak> This code stackoverflows when a list is left unevaluated â€“ but I don't understand, why? http://lpaste.net/7121957659770617856
08:17:07 <quicksilver> > (S.intersection`on`S.fromList) [1, 5, 25] [1,2,4,5,10,25]
08:17:08 <lambdabot>  fromList [1,5,25]
08:17:09 <yitz> Galactic: if you don't need to keep the original order, you can make them both sets (cf. Set.fromList) and intersect the sets.
08:17:18 <quicksilver> ^^ Galactic, Fuuzetsu
08:17:27 <quicksilver> but honestly, for lists of length 5, who cares about asymptotics
08:17:32 <quicksilver> lists will be much faster than sets for length 5.
08:17:40 <yitz> Galactic: if you do, you can make just one of them into a set and then filter the other against the set.
08:18:32 <Galactic> humm, k
08:18:53 <prooftechnique> @let sort' = Data.Set.toList . Data.Set.fromList
08:18:53 <lambdabot>  .L.hs:146:9: Not in scope: `Data.Set.toList'
08:18:53 <lambdabot>  
08:18:53 <lambdabot>  .L.hs:146:27: Not in scope: `Data.Set.fromList'
08:19:28 <prooftechnique> @let sort' = S.toList . S.fromList
08:19:28 <lambdabot>  .L.hs:146:20:
08:19:29 <lambdabot>      No instance for (Ord a0) arising from a use of `S.fromList'
08:19:29 <lambdabot>      The type variable `a0' is ambiguous
08:19:29 <lambdabot>      Possible cause: the monomorphism restriction applied to the following:
08:19:29 <lambdabot>        sort' :: [a0] -> [a0] (bound at .L.hs:146:1)
08:19:51 <prooftechnique> @let sortsort' = S.toList . S.fromList
08:19:52 <lambdabot>  .L.hs:146:24:
08:19:52 <lambdabot>      No instance for (Ord a0) arising from a use of `S.fromList'
08:19:52 <lambdabot>      The type variable `a0' is ambiguous
08:19:52 <lambdabot>      Possible cause: the monomorphism restriction applied to the following:
08:19:52 <lambdabot>        sortsort' :: [a0] -> [a0] (bound at .L.hs:146:1)
08:20:07 <prooftechnique> @let sort' :: [Int] -> [Int]; sort' = S.toList . S.fromList
08:20:08 <lambdabot>  Defined.
08:20:10 <prooftechnique> There
08:20:20 <yitz> @set -XNoMonomorphismRestriction -- i know, this doesn't work in lambdabot
08:20:33 <prooftechnique> > sort' [3,2,4,3,2,5,9,10,17,6]
08:20:35 <lambdabot>  [2,3,4,5,6,9,10,17]
08:20:52 <prooftechnique> I wonder how horifically inefficient that is
08:21:05 <quicksilver> it's fine. it's a tree sort
08:21:37 <prooftechnique> *horrifically
08:21:42 <prooftechnique> Oh, good, though
08:21:51 <quicksilver> effectively
08:22:25 <prooftechnique> artyomkazak: Try doing what hlint says at the bottom
08:22:38 <prooftechnique> artyomkazak: Increasing laziness will probably help you
08:23:57 <artyomkazak> prooftechnique: it hasn't changed anything
08:24:05 <prooftechnique> Hmm
08:24:38 <prooftechnique> artyomkazak: Can you explain what the program is meant to do?
08:27:10 <merijn> prooftechnique: Just specifying "Ord a => [a] -> [a]"as type for sort' would've worked too :)
08:28:00 <peteretep> compare = LT -- very fast sort
08:28:15 <prooftechnique> merijn: That's true, I was just being shiftless :D
08:28:57 <prooftechnique> artyomkazak: I don't get a stack overflow
08:29:10 <dagle> Fastest sort: Define the ordering to be the current order.
08:29:24 <artyomkazak> prooftechnique: is your machine x86 or x64?
08:29:24 <Fuuzetsu> clever
08:29:25 <StoneToad> lol!
08:29:31 <prooftechnique> artyomkazak: x64
08:30:06 <exicer> Anyone managed to cabal install gtk on mavericks ?
08:30:30 <prooftechnique> exicer: I got cairo to build. I'll see if I can make gtk happen
08:30:59 <exicer> Cool cool - let me know how it goes :)
08:32:39 <prooftechnique> exicer: Are you getting any particular errors I should look out for?
08:33:06 <exicer> prooftechnique: gtk2hsC2hs: Error in C header file.
08:33:35 <prooftechnique> Ah, I think I remember that one, too
08:33:37 <exicer> seems to be coming from glib, specifically
08:33:57 <exicer> I guess this is something to do with mavericks c compiler or something..
08:33:57 <prooftechnique> exicer: Have you tried passing --with-gcc=gcc-4.8?
08:34:09 <exicer> prooftechnique: Will do now
08:34:11 <prooftechnique> (After installing such a gcc, of course)
08:35:30 <yitz> > let isSorted = and . (zipWith (<=) <*> tail); sort = head . filter isSorted . permutations in sort  [3,2,4,3,2,5,9,10,17,6]
08:35:31 <lambdabot>  [2,2,3,3,4,5,6,9,10,17]
08:36:18 <exicer> Tried with gcc4.2 (which I have installed), no joy. Is it worth installing 4.8 ?
08:36:32 <exicer> prooftechnique: ^
08:36:55 <prooftechnique> That's what I see all the cool kids using lately, but I don't know if it'll actually help
08:37:17 <prooftechnique> I'm currently building on ghc 7.8 with clang, so I'll let you know how that goes
08:37:47 <nooodl> @pl \f g x -> f x (g x)
08:37:47 <lambdabot> ap
08:38:20 <nooodl> ((->) r) monad is scary
08:39:00 <yitz> nooodl: is it less scary when it's called Reader?
08:39:33 <prooftechnique> Oh, my god, undo-tree is the best thing ever
08:40:13 <yitz> prooftechnique: in the containers library, undo-tree is called "flatten"
08:40:26 <prooftechnique> heh
08:42:57 <prooftechnique> artyomkazak: Have you figured out where your stack overflow is coming from?
08:43:20 <artyomkazak> prooftechnique: I've added a commentary: http://lpaste.net/7793361361391583232 ; my machine is x64 too and I get stackoverflow with default stack size (8mb). If this is relevant, I'm using GHC 7.6.
08:44:53 <prooftechnique> artyomkazak: Hmm. I wonder if 7.8 has some changes that make it work.
08:45:23 <prooftechnique> I just can't imagine why you'd get an overflow there, though
08:45:36 <prooftechnique> > [1..300000] ++ [1]
08:45:37 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
08:46:01 <cschneid> does cabal have a similar idea to ruby bundler's "Gemfile.lock" -> which is the actual versions of all libraries that got resolved from the allowed ranges in your dependency definition: ("anything 3.0 or up" => "actualy found 3.1.2, and am using that")
08:46:04 <prooftechnique> > let g = [1..300000] ++ [1] in print (g == g)
08:46:06 <lambdabot>  <IO ()>
08:46:11 <prooftechnique> > let g = [1..300000] ++ [1] in g == g
08:46:13 <lambdabot>  True
08:46:30 <prooftechnique> cschneid: That's the cabal file
08:47:05 <cschneid> prooftechnique: well, cabal file says: "3.1.x is ok", cabal install resolves that to "3.1.4 was found, using it" - but I want to have a coworker build exactly the same thing I have.
08:47:16 <cschneid> I'd rather the dep resolving step doesn't go find 3.1.5 on his system
08:47:27 <prooftechnique> cschneid: Then you want ==3.1.4
08:47:40 <Galactic> can someone point me to a implementation of quadratic sieve in Haskell, I am trying to do prime factorization in Haskell but I can't find actuall code for an implementation just the basic algorithm.
08:47:48 <prooftechnique> Oh, or do you mean once it finds something, it should lock that as the one to use?
08:47:49 <merijn> cschneid: I think Snoyman was working on a way to "freeze" dependency sets
08:48:02 <prooftechnique> I totally misunderstood if that's what you're after
08:48:10 <cschneid> prooftechnique: right. "freeze" until I manually tell it to try and upgrade a dep.  This turns out to be pretty handy when working with a team
08:48:36 <artyomkazak> prooftechnique: I've just checked with GHC 7.8 (from git) and there's indeed no stack overflow
08:48:40 <prooftechnique> Ah. Hmm. Let me poke around for a minute. I'm not sure there's anything existing right now, though
08:48:44 <cschneid> merijn: so not yet, but maybe soon/later?
08:49:00 <prooftechnique> artyomkazak: Weird. I wonder what changed
08:49:02 <cschneid> (question came up from combo of our ruby workflow at work, and http://engineering.imvu.com/2014/03/24/what-its-like-to-use-haskell/ mentioning something similar as an issue)
08:49:28 <krgn> hey, so i  have written this little program and want to upload it to hackage, but kind of don't understand the process
08:50:00 <prooftechnique> cschneid: How about this? https://github.com/benarmston/cabal-constraints
08:50:04 <krgn> I did upload it, and its in the 'review' queue, but maybe I need to do soemthing else?
08:50:05 <merijn> cschneid: See discussion here: http://www.reddit.com/r/haskell/comments/1m2bkp/cabal_version_lockdown_reliable_builds_for/
08:50:35 <merijn> krgn: What's the package name?
08:50:40 <krgn> merijn: leo
08:50:49 <cschneid> merijn: cool thanks
08:51:01 <krgn> its a little utility to query a popular german translation site
08:51:33 <merijn> krgn: Depending on when you uploaded it can take a while, the database is populated using a cron job
08:52:01 <krgn> merijn: oh yes, its a few weeks ago I thinkj
08:52:09 <prooftechnique> cschneid: I think cabal-constraints does what you want, but it's not quite as magical as Gemfile.lock
08:52:23 <cschneid> prooftechnique: yeah, that's what I'm gathering. Easily fixed by a few team shell scripts though :)
08:52:24 * hackagebot hinquire 0.1.0.0 - Generate armet style query strings.  http://hackage.haskell.org/package/hinquire-0.1.0.0 (joneshf)
08:52:43 <cschneid> prooftechnique, merijn: thanks for the help. I'm doing my best to sneak haskell services into our environment :)
08:52:52 <prooftechnique> Hehe, great
08:53:02 <merijn> krgn: Oh, that's odd then
08:53:03 <cschneid> but lots of workflow questions to answer when you start doing real team-based work
08:53:22 <merijn> krgn: What's your hackage username?
08:53:32 <merijn> cschneid: I believe Snoyman is running a curated hackage for this type of thing
08:53:54 <krgn> merijn: krgn
08:54:07 <prooftechnique> Yeah, Stackage
08:54:31 <cschneid> merijn / prooftechnique: that's a slice of hackage meant to play nice together? Sorta like an extended haskellplatform kind of idea?
08:54:48 <prooftechnique> Yeah, kinda
08:54:59 <merijn> krgn: Have you tried reuploading?
08:55:01 <prooftechnique> I think it's short for "stable hackage"
08:55:07 <merijn> krgn: It should take a day or so tops to update
08:55:40 <krgn> merijn: okay, I'll try that, but do I need to delete the previous one? its still in the queue
08:55:43 <prooftechnique> cschneid: http://daniel-diaz.github.io/stackagelist/
08:55:47 <prooftechnique> That's the package list
08:55:51 <cschneid> thanks
08:55:54 <merijn> krgn: I don't think so?
08:56:11 <krgn> merijn:  ok, thanks :)
08:57:32 <yitz> artyomkazak: did you try modifySTRef' ?
08:58:32 <artyomkazak> yitz: in `root`? Yes, but it has no effect
08:58:43 <bennofs> Is there a haskell library that allows me to detect the file type (in this case, I want to load an xml file, but that file may be compressed by gzip), similar to the unix `file` command?
09:01:37 <yitz> bennofs: i don't know of one. but that particular case is easy enough to check in a few different ways.
09:04:06 <quicksilver> bennofs: http://hackage.haskell.org/package/magic
09:04:23 <quicksilver> but it is probably overkill and I have no idea if it works
09:04:35 <quicksilver> CosmicRay wrote a large number of obviously missing haskell libraries
09:05:23 <CosmicRay> wow.  I looked at that description, thought "glad that's there", then looked at the maintainer... heh.
09:05:25 <bennofs> Hmm right, in my special case, I can just check for the gzip magic number
09:05:25 <CosmicRay> forgot I wrote that.
09:05:46 <tdammers> some "maintainer" you are
09:05:50 <CosmicRay> hah
09:06:15 <mviera> hi, any HList expert around?
09:06:26 <prooftechnique> CosmicRay maintains distance from the library
09:06:56 <CosmicRay> I never hear from people about it.  either nobody uses it or it has no bugs.  perhaps both ;-)
09:07:25 <CosmicRay> I honestly can't remember what I needed it for, now.
09:08:53 <tdammers> if a package has bugs, but there are no users to run into them, is the package still buggy?
09:08:54 <mviera> I don't know why I can't define: myf r1 r2  =   hRearrange (recordLabels r1) r2
09:09:07 <prooftechnique> tdammers: I think there's an xkcd about that
09:09:08 <bennofs> What's the easiest way to read a single Word16 from a file in haskell?
09:09:35 <tdammers> prooftechnique: there has got to be some sort of law about xkcd
09:09:57 <tdammers> something like, if it's nontrivial, then there's an xkcd about it
09:09:58 <tdammers> idk
09:10:04 <prooftechnique> bennofs: takeWord16?
09:10:30 <prooftechnique> tdammers: Seems likely
09:10:32 <bennofs> prooftechnique: Hmm, I think I'll use hGet from bytestring
09:11:05 <prooftechnique> Oh, you want a bytestring. Yeah, I guess takeWord16 is for Text
09:14:47 <kstt> Hi. Haskell/GTK+ question : does anyone know how to populate a generic combobox with a model please ?
09:15:18 <prooftechnique> exicer: Using --with-gcc=gcc-4.8 seems to be working for me
09:16:03 <kstt> I want to map a model in the combobox, and have the model "name" displayed in the box.
09:16:19 <kstt> Very standard business, very basic.
09:19:52 <ski> flebron : i'd say `Maybe' is a type (and also a type constructor, and also a type function), similarly for `Either'. but `Either Int' is a (type and a) type function, but not a type constructor (compare how `Node 2' isn't a data constructor) -- also i'd say `Int' is a type constructor (compare with `False',`True',`Nothing' being data constructors) -- all type functions are of course types
09:19:56 <yitz> kstt: haven't used gtk+ in haskell for a while. but it used to be that you would look up questions like that in the regular C GTK+ docs, then transcribe the answer to haskell in a straightforward way.
09:21:06 <ski> flebron : and then the types which are capable of having values (including the `Void' type) are the concrete types. concrete types are those with kind `*' (probably those with kind `#' should be included as well, and maybe also the ones with kind `(#)')
09:21:21 <Galactic> if I have an list like [1,1,1,1,2,2,2,2,3,3,3,3,6,6,6,6] how can I count the number that each number repeats?
09:21:46 <yitz> Galactic: map length . group
09:21:50 <hasenov> 0/quit
09:22:06 <Galactic> yitz: ty
09:22:11 <yitz> > map length . group $ [1,1,1,1,2,2,2,2,3,3,3,3,6,6,6,6]
09:22:12 <lambdabot>  [4,4,4,4]
09:22:12 <cdk_> > map (head &&& length) (group [1,1,1,1,2,2,2,3,3,3,4,4,5,5]
09:22:13 <lambdabot>  <hint>:1:59:
09:22:13 <lambdabot>      parse error (possibly incorrect indentation or mismatched brackets)
09:22:19 <cdk_> > map (head &&& length) (group [1,1,1,1,2,2,2,3,3,3,4,4,5,5])
09:22:20 <lambdabot>  [(1,4),(2,3),(3,3),(4,2),(5,2)]
09:22:22 <flebron> ski: I'd never heard of Int being called a type ctor.. it seems awfully close to the "but values are 0-ary functions" mixup, but perhaps it's a better way of calling it.
09:23:05 <byorgey> flebron: is  'Nothing'  a data constructor?
09:23:28 <flebron> Sure.
09:23:33 <Galactic> @unpl length . group $ [1,2,3,4]
09:23:33 <lambdabot> (length (group ([1, 2, 3, 4])))
09:23:41 <byorgey> then 'Int' should be a type constructor.
09:23:49 <byorgey> the word "constructor" here has nothing to do with functions.
09:24:43 * byorgey has a half-finished blog post lying around on the history of this particular terminological confusion.  I should finish it.
09:24:58 <merijn> byorgey: Yes, it annoys me when people argue about that! :>
09:25:37 <bennofs> How do I turn EitherT a (ConduitM ....) into ConduitM ... (EitherT a ...) ... ?
09:26:37 <quicksilver> ski: I agree with you, but just to be contrary, I point out that 'Functor' is a constructor class and 'Either Int' is a member of it so surely Either Int is a type constructor ;)
09:26:54 <yitz> bennofs: either (return . Left) Right
09:27:12 <yitz> umm
09:27:41 <yitz> bennofs: either (return . Left) (fmap Right)
09:27:50 <ski> @tell erisco i think it's reasonable to assume that if you say "higher-order function" for some specific example, you usually mean "proper", in the sense of the order being greater than `1'. similarly for higher-order types like `Mu' (having kind `(* -> *) -> *'. the MLs unfortunately don't support higher-order types, only concrete types (~ zeroth-order type "functions") and first-order type functions)
09:27:50 <lambdabot> Consider it noted.
09:28:39 <quicksilver> yitz: don't you need 'hoistEither' for what you're trying to do?
09:28:52 <yitz> @type either (return . Left) (fmap Right)
09:28:53 <lambdabot> (Monad m, Functor m) => Either a (m b) -> m (Either a b)
09:28:54 <quicksilver> yitz: you can't use "either" on an "EitherT" because the top constructor of an "EitherT" is not Left or Right.
09:29:05 <yitz> ah, EitherT....
09:29:22 <quicksilver> http://hackage.haskell.org/package/either-3.4/docs/Control-Monad-Trans-Either.html
09:29:43 <quicksilver> I think it might be hoistEither combined with "liftM join"
09:29:46 <quicksilver> but I'm not sure.
09:30:13 <bennofs> lift . fmap hoistEither . eitherT (return . Left) (return . Right) -- seems to work right, but I thought maybe there is already a function for it?
09:30:37 <ski> quicksilver : yes, "constructor classes" uses the older convention of : things with kind `*' are types, things with kind `K0 -> K1' (for some kinds `K0',`K1') are type constructors
09:30:52 <ski> (at least i assume it's older)
09:31:08 <bennofs> well, that's still not exactly right ...
09:31:33 <byorgey> ski, quicksilver: no, see, this is where the confusion came from.  In Mark Jones' paper "A System of Constructor Classes", he used the term "constructor" as a technical term for a class of things that included types of ALL kinds.
09:32:03 <byorgey> he had to make up a new name because at that time in Haskell there were no kinds, and "types" referred to things we would now call "types of kind *"
09:32:31 <ski> byorgey : so a polymorphic type class ?
09:32:38 <byorgey> so "constructor classes" in that paper is a generalization of "type classes"
09:32:48 <quicksilver> ski: just a higher-kinded type class I think
09:32:57 <ski> or maybe "class" in "class of things ..." were not in the "type class" sense ?
09:33:46 <byorgey> but when Gofer's implementation was picked up by Haskell, people started using the term "constructor class" to refer to the *extra* things that got added to the language (i.e. classes abstracting over things with any kind other than *)
09:34:11 <ski> byorgey : yes, if `Either Int' counts as a type constructor, then both `Either' and `Int' themselves should also count, by trivial inclusion
09:34:15 <quicksilver> byorgey: ah well that is interesting
09:34:29 <quicksilver> byorgey: perhaps a bad choice of word in retrospect :)
09:34:32 <ski> byorgey : ah, i see. ty
09:34:34 <byorgey> quicksilver: right =)
09:34:58 <byorgey> note, this is mostly well-informed speculation on my part.  As I said, I need to finish my blog post, which will include actually running it by Mark Jones and maybe some others to get more historical perspective
09:35:15 <danlamanna> is there a general functional programming language room on freenode?
09:35:25 <byorgey> but I've spent a lot of time reading various versions of the Haskell Report and Jones' paper while researching my blog post.
09:36:03 <bennofs> yitz: I think it's 'lift . eitherT left right . mapEitherT lift'
09:36:10 <byorgey> danlamanna: not that I know of.
09:36:14 <merijn> ski: I don't consider "Either Int" a type constructor in the same way that I don't consider (1:) a list constructor
09:36:30 <ski> merijn : *nod*, i don't do either
09:36:42 <ski> (note the "if" :)
09:37:01 <danlamanna> alright, so here goes nothing. obviously this will be biased, but anyone have an opinion on a good first language to learn functional programming? most of my experience is in C, python, and some emacs lisp.
09:37:07 <byorgey> "Either Int" is a 'constructor' in the technical sense of Mark Jones' paper.  It is not a 'type constructor' according to the Haskell report.
09:37:08 <quicksilver> merijn: yes, we all agree.
09:37:48 <ski> danlamanna : Scheme (e.g. with SICP), or SML or OCaml, or Haskell
09:37:54 <quitobro> danlamanna: Haskell
09:38:03 <ski> danlamanna : or Clean
09:38:06 <quicksilver> danlamanna: haskell pretty much forces you to program functionally, so that makes the learning process more abrupt
09:38:16 <Hodapp> Clean?
09:38:17 <ski> yes
09:38:19 <quicksilver> danlamanna: scheme with SICP is another good choice for learning.
09:38:37 <ski> Clean is "the other" lazy functional programming language
09:39:07 <ski> <http://en.wikipedia.org/wiki/Clean_(programming_language)>
09:39:52 <ski> Clean is interesting in that it has uniqueness types (Mercury (a hybrid logic / functional programming language) has uniqueness modes, which is pretty similar, but developed independently)
09:40:05 <ski> Clean programs starts by executing
09:40:13 <ski>   Start :: *World -> *World
09:40:41 <ski> by passing in the initial state of the world, and the program returns the final state of the world
09:40:44 <no-n> the world is not clean
09:41:13 <danlamanna> thanks guys :)
09:41:20 <ski> the `*' means that we have the a unique reference to the value of the respective type, in the program
09:41:37 <merijn> ski: How many other languages use uniqueness types? I only know like 2
09:41:39 <no-n> looks rather a lot like haskell from the code examples
09:41:42 <danlamanna> close friend also recommended scheme, with "the little schemer" as a reference. so i may try that.
09:41:58 <ski> danlamanna : TLS is nice, if you like that style (not all do)
09:43:25 <no-n> (a -> b) [a] -> [b] :(
09:43:43 <Galactic> if I have something like [["10","4"],["1","100"],["288","240"]]  how could I convert each number to an int?
09:44:05 <ski> danlamanna : in the end, i suggest learning Scheme (for continuations and hygienic macros), SML or OCaml (not F#) (for the module system with "module functors"), Haskell for many cool advanced type things (SML and OCaml has the basic types, and also the pattern-matching. OCaml also has a few of the more advanced type stuff (like GADTs))
09:46:06 <kstt> yitz: thank you. Frankly I am getting mad. GTK2HS has been the most miserable experience in my whole programmer life.
09:46:26 <thebnq> Galactic: you want to map read
09:46:54 <kstt> I have literaly lost half of my project time on getting stupid basic stuff working.
09:47:09 <Galactic> thebnq: yea but i am trying this:  map (read :: String -> Int) [["10","4"],["1","100"],["288","240"]]   but it does not work
09:47:32 <thebnq> Galactic: well since you have a list of lists, you actually want to map (map read)
09:47:34 <kstt> Admitedly, this is largely due to GTK being poorly designed and terribly documented.
09:47:47 <Galactic> aa ok
09:47:52 <exicer> prooftechnique: After compiling and installing gcc4.8, everything works.
09:48:11 <prooftechnique> exicer: Awesome
09:50:20 <Galactic> > map (map (read :: String -> Int) [["1","2"],["288","240"]])
09:50:21 <lambdabot>  Couldn't match expected type `a0 -> b0'
09:50:22 <lambdabot>              with actual type `[GHC.Types.Int]'Couldn't match expected type `...
09:50:22 <lambdabot>              with actual type `[GHC.Types.Char]'Couldn't match expected type ...
09:50:22 <lambdabot>              with actual type `[GHC.Types.Char]'Couldn't match expected type ...
09:50:22 <lambdabot>              with actual type `[GHC.Types.Char]'Couldn't match expected type ...
09:51:06 <beaky> are there purely functional databases
09:51:51 <thebnq> Galactic: parenthesis a bit off
09:52:18 <Galactic> where?
09:52:50 <thebnq> you want map (map (read :: String -> Int))
09:53:40 <thebnq> > map (map read) [["1","2"],["288","240"]] :: [[Int]]
09:53:41 <lambdabot>  [[1,2],[288,240]]
09:53:46 <Galactic> > map (map (read :: String -> Int)) [["1","2"],["288","240"]]
09:53:47 <lambdabot>  [[1,2],[288,240]]
09:53:51 <thebnq> and then putting the type there is a bit easier to read =)
09:53:51 <Galactic> ty
09:57:10 <quchen> Don't use read, it crashes when the input is malformed.
09:57:21 <quchen> readMaybe is your friend.
10:04:19 <Galactic> why I can't do something like:  [a + b | (a:b) <- [1,2]]
10:05:36 <thebnq> gala	you don
10:05:40 <thebnq> oops
10:05:54 <Jaak> Galactic: you can do [... | let (x : xs) = [1,2]]
10:06:07 <thebnq> b is the tail
10:06:09 <Jaak> but in that case xs would bind to [2]
10:06:29 <Jaak> > [a + b | let (a:b:_) = [1,2]]
10:06:32 <lambdabot>  [3]
10:08:22 <Galactic> humm, well what I want to do is:   [[solve a b | (a:b) <- xs] | xs <- [[1,2],[288,240]]]
10:08:33 <Galactic> how can I achieve something like that.
10:08:38 <quchen> Galactic: Read the "<-" as "draws from", not "matched against".
10:09:34 <Jaak> Galactic: in that case you can do [[solve a b | (a, b) <- xs] | xs <- [(1,2),(288,240)]]
10:10:02 <Jaak> or also [[solve a b | [a,b] <- xs] | xs <- [[1,2],[288,240]]]
10:10:48 <Jaak> > [(x,y) | [x, y] <- [[1,2],[1,2,3,4],[3,4]]]
10:10:49 <lambdabot>  [(1,2),(3,4)]
10:11:13 <quchen> What you want is probably  [solve a b | (a,b) <- [(1,2),(288,240)]].
10:12:04 <peteretep> couldn't you just use uncurry?
10:12:35 <Galactic> > [[gcd a b | [a,b] <- xs] | xs <-  [[1,2],[288,240]]]
10:12:36 <lambdabot>  No instance for (GHC.Show.Show t0)
10:12:36 <lambdabot>    arising from a use of `M5837523321733720026047.show_M5837523321733720026047'
10:12:36 <lambdabot>  The type variable `t0' is ambiguous
10:12:36 <lambdabot>  Possible fix: add a type signature that fixes these type variable(s)
10:12:36 <lambdabot>  Note: there are several potential instances:
10:15:54 <Galactic> I want something like this: [[gcd a b | [a,b] <- xs] | xs <-  [[1,2],[288,240]]]
10:17:39 <quchen> Maybe describe the problem to us?
10:17:42 <aib> all the examples given above were _like_ that.
10:18:05 <thebnq> making the inner lists be tuples seems like what you want for sure
10:18:23 <aib> maybe they want a cartesian product?
10:19:55 <Galactic> quchen: making the inner lists tuples would be an extra step, since the inner list is already the way it is.
10:19:59 <artyomkazak> prooftechnique: â€œI wonder what changedâ€Â â€“ turned out that GHC 7.8 sets default stack size to 80% of memory available at runtime, that's what has changed. [With â€œ-K8Mâ€ it crashes at 337000, which is slightly better than on 7.6 but still weird, since with unevaluated list it manages to do 500000 before crashing.]
10:20:21 <quchen> Galactic: Don't use Haskell, use words. What do you want to do?
10:20:48 <quchen> "I have a list of pairs of numbers and would like to calculate the GCD of each of these pairs", for example.
10:21:07 <Galactic> I want to calculate the gcd of two numbers given a list of list, where the inner list contains two elements.
10:22:10 <quchen> That would be the code I wrote after "What you want" above.
10:22:43 <Jaak> > [[gcd a b | let [a,b] = xs] | xs <-  [[1,2],[288,240]]]
10:22:44 <lambdabot>  [[1],[48]]
10:22:46 <quchen> Except that the input data is a list of tuples and not a list of lists, because the latter makes far less sense.
10:22:56 <Jaak> the type error you go was a bit scary
10:23:22 <Jaak> but it was because elements of xs were not lists
10:23:37 <Galactic> wow, Thanks guys.
10:24:02 <Jaak> foo <- bar "draws foo's from bar"
10:24:16 <Jaak> let foo = bar "binds foo to bar"
10:24:37 <Galactic> nice that helps.
10:24:39 <Jaak> (and does the pattern matching you need)
10:25:22 <thebnq> You COULD do  [a+b | [a,b] <- [[1,2],[288,240]]] , but if the source could switch to tuples, it should be clearer and faster
10:25:25 <Jaak> you can simplify the code to [gcd a b | [a,b] <- [[1,2],[288,240]]] btw
10:25:34 <thebnq> yea :b
10:25:35 <ReinH> ofc this only works if you can guarantee that the inner lists all have exactly 2 elements
10:25:41 <ReinH> and if you can do that you should just use a tuple
10:25:50 <Jaak> it works otherwise too
10:26:01 <quchen> For some value of "works".
10:26:01 <Jaak> > [() | [a,b] <- [[1,2,3]]]
10:26:02 <lambdabot>  []
10:26:04 <Jaak> yeah
10:26:14 <ReinH> Right, as in "doesn't throw a runtime error"
10:26:23 <ReinH> But you probably want works as in "correctly returns the gcd"
10:26:39 <ReinH> a tuple gives you a type-level guarantee about the number of inner elements
10:26:41 <ReinH> seems good
10:26:43 <quchen> sort = id -- This is a working sorting algorithm
10:26:55 <quchen> It's wrong for unsorted inputs though ;-)
10:27:15 <kwantam> it relies on nondeterministic advice from the user. in the form of sorted input.
10:27:41 <quchen> It's also a very fast algorithm.
10:27:54 <ReinH> it's what we call a heuristic-based algorithm
10:28:02 <ReinH> (not really)
10:28:04 <kwantam> swapsort
10:28:16 <kwantam> genetic swapsort
10:28:16 <quchen> ReinH: Probabilistic sorting!
10:28:24 <ReinH> quchen: for data science!
10:28:25 <kwantam> hill-climbing swapsort
10:28:26 <thebnq> its likelyhood of success is inversely proportional to the input size :D
10:28:38 <ReinH> thebnq: worse than that :p
10:28:59 <thebnq> inverse factorial .. not sure how to describe it accurately in words :b
10:29:05 <ReinH> it has inverse factorial probability of success. Which notation is that? Not O. Not theta...
10:29:25 <quchen> Î©? Bounded below etc
10:29:29 <ReinH> :p
10:29:37 <quchen> Î©(1) for sure! :-)
10:29:41 <ReinH> a
10:29:43 <ReinH> ha
10:29:45 <thebnq> its 100% success rate for n <= 1 =D
10:30:06 <quchen> Similarly, Quicksort is a popular sorting algorithm with O(n!) time complexity.
10:30:09 <ReinH> in fact many adaptive sorting algorithms switch to it for small enough n
10:30:14 <ReinH> true story
10:30:26 <thebnq> haha thats an interesting thought
10:37:43 * hackagebot conduit-combinators 0.2.3.1 - Commonly used conduit functions, for both chunked and unchunked data  http://hackage.haskell.org/package/conduit-combinators-0.2.3.1 (MichaelSnoyman)
10:39:00 <aib> In Â§2.1 of http://www.cs.virginia.edu/~wh5a/personal/Transformers.pdf , I'm getting error "Couldn't match type `Maybe Value' with `Identity Value'" for the code. It's because eval1 returns an identity monad whereas the Var case returns Map.lookup
10:39:52 <aib> yet in the text right after the code, Map.lookup is defined to work with any monad, making use of its fail function. What's wrong here?
10:40:33 <aib> :t Data.Map.lookup
10:40:34 <lambdabot> Ord k => k -> M.Map k a -> Maybe a
10:40:46 <aib> hmm
10:42:33 <Rufflewind_> is there a way to get runhaskell to import a different version of a libary?
10:43:34 <joseph07> aib: That used to be the case
10:43:37 <joseph07> http://hackage.haskell.org/package/containers-0.1.0.0/docs/Data-Map.html
10:43:58 <klrr_> okey, this obivously doesnt type-check: http://lpaste.net/101798 but does anyone know how to achieve this? e.i have a Reader monad generalised over two different "reader values"
10:43:59 <joseph07> lookup had type (Monad m, Ord k) => k -> Map k a -> m a
10:44:19 <klrr_> wait, i can have a intermidiate type
10:44:45 <aib> ah. So I fixed it with: fixLookup Nothing  = error "Nothing" ; fixLookup (Just x) = return x
10:45:02 <aib> pending a better name
10:45:10 <glguy_> klrr_: You could have a "Reader (Either Foo Bar)"
10:45:12 <klrr_> i can just use Either
10:45:13 <klrr_> ye
10:47:22 <joseph07> aib: I think you can use fail "nothing" instead of error
10:48:33 <aib> joseph07: good idea. and name it "maybeToMonad" pending a better name :)
10:51:30 <kadoban> Anyone know how to actually use the 'token' function in Parsec?  I want to override the default one, but the thing is...it doesn't appear to actually be used anywhere?  Totally don't understand, grepping through the whole package, it seems that 'token' is only ever defined, never used.
10:51:34 <bennofs> :t F.msum
10:51:35 <lambdabot> (MonadPlus m, Foldable t) => t (m a) -> m a
10:57:45 * hackagebot authenticate 1.3.2.7 - Authentication methods for Haskell web applications.  http://hackage.haskell.org/package/authenticate-1.3.2.7 (MichaelSnoyman)
10:58:26 <glguy_> kadoban: http://lpaste.net/101799
10:59:00 <stolaruk> I just started reading the Parsec chapter of RWH
10:59:14 <kadoban> glguy_: wow, thanks!
11:07:47 * hackagebot linear 1.10 - Linear Algebra  http://hackage.haskell.org/package/linear-1.10 (EdwardKmett)
11:10:07 <yogert> how could i make this typeclass more generic? http://lpaste.net/1569857280227147776
11:14:50 <joseph07> yogert: If you only have one type of Doc and one type of DocTypes, why does Document need to be parametrized on them?
11:16:47 <yogert> joseph07, well I'd like to make this as modular as possible I thinkâ€¦ Maybe the "Doc" datatype wouldn't vary between usage, but the classification certainly would
11:17:50 <jrmithdobbs> does anyone happen to know if the "weirdness" (lacking* type inference, let's say, *as in not great) in F# is mostly due to CLR limitations? that seems to be the case in every example i've looked at
11:18:22 <jrmithdobbs> is that why the clr haskell was never seen by the public?
11:20:27 <koala_man> jrmithdobbs: I haven't used F#, but I know part of it use due to overloaded methods. it's harder to do type inference when you have multiple choices for the type of each function
11:21:31 <jrmithdobbs> koala_man: ya that's kind of what I was getting at, and that all comes from the CLR and is further forced by wanting abi interop with other clr langs
11:22:11 <jrmithdobbs> because if you want the latter you have to have the overloaded method stuff handled or things explode at runtime, heh
11:22:23 <jrmithdobbs> (to use the technical term)
11:22:59 <jrmithdobbs> it's a surprisingly interesting language though
11:23:44 <koala_man> jrmithdobbs: the overloaded method to use is determined at compile time, not runtime. if, like in Haskell, you uniquely specified the function you wanted to call, there wouldn't be a problem
11:30:55 <joseph07> yogert: Could you describe what the system is supposed to do?
11:33:08 <athan> guys, what's a natural transformation?
11:33:42 <jle`> a function from f a to g a
11:33:58 <dmj`> http://www.haskell.org/haskellwiki/Category_theory/Natural_transformation
11:34:26 <athan> thank you!
11:35:00 <athan> jle`: that only affects the wrapper, and not compromising it's contents, right?
11:36:19 <yogert> joseph07, heh well as a personal project I'm trying to parse a bunch of documents of varying formats and content. At this point I'm playing around with ways to structure the program so that the parsing can be done in parallel, and the code is as declarative as possible. The idea behind this approach is to simply define a set of rules to classify the documents, and extract the information based on the classification
11:37:45 <yogert> joseph07: also, I'm still learning as you can probably tellâ€¦ : )
11:38:41 <beaky> how do i write a haskell program
11:39:07 <athan> beaky: with your mind
11:39:24 <athan> beaky: what OS do you run?
11:39:32 <beaky> im usig arclinux
11:39:35 <beaky> archlinux*
11:39:42 <athan> beaky: get the haskell-platform!
11:39:50 <athan> beaky: learn to use ghc/ghci
11:40:00 <beaky> i got ghc and cabal installed
11:40:11 <beaky> from official repo
11:40:12 <athan> beaky: ahhhh, you're gonna have to learn the cabal spec then
11:40:21 <athan> beaky: if you want to write packages
11:40:34 <athan> beaky: you're familiar with git + programming in other langs?
11:40:39 <beaky> yes
11:40:43 <nadirs> beaky: have you read/done anything about/with haskell yet?
11:40:43 <yogert> this is a good resource http://book.realworldhaskell.org/
11:40:52 <nadirs> @where LYAH
11:40:52 <lambdabot> http://www.learnyouahaskell.com/
11:40:54 <beaky> nadirs: i made only a basic game
11:41:00 <beaky> and a website
11:41:10 <athan> beaky: do you want to learn more of the theory?
11:41:23 <athan> beaky: and why haskell is designed the way it is?
11:41:29 <beaky> yes i want to think in the haskelll wayu
11:41:31 <nadirs> beaky: that's more than I've done then :P
11:41:33 <beaky> way*
11:41:35 <johnw> beaky: haven't you been using Haskell for like a year now?
11:41:42 <johnw> you're famous for talking about how easy monoids are
11:41:54 <Iceland_jack> what johnw said
11:42:17 <athan> lol
11:42:26 <beaky> yet i still dont know haskel
11:42:32 <athan> oh quick question - wouldn't arrow merging be a monoid?
11:42:46 <nadirs> beaky: I don't think that feeling ever goes away
11:42:46 <johnw> you mean composition?
11:42:49 <athan> like (***)
11:42:51 * hackagebot language-c-quote 0.7.7 - C/CUDA/OpenCL/Objective-C quasiquoting library.  http://hackage.haskell.org/package/language-c-quote-0.7.7 (GeoffreyMainland)
11:43:04 <johnw> :t (***)
11:43:04 <lambdabot> Arrow a => a b c -> a b' c' -> a (b, b') (c, c')
11:43:06 <athan> hmm maybe
11:43:12 <johnw> the type of a monoid is always a -> a -> a
11:43:17 <johnw> (the append operation)
11:43:18 <athan> is composition a monoid? It shouldn't be...
11:43:23 <nadirs> beaky: haskell is so deep that the more you learn the more ignorant you feel, I believe
11:43:37 <athan> well, yes, but what if the underlying structure was unsorted?
11:43:42 <johnw> arrow composition among endomorphisms is a monoid
11:43:45 <athan> like a true set
11:43:51 <beaky> haha thats exactly how i feel about everything
11:43:52 <athan> hmmm
11:44:04 <DR6> it's simple
11:44:14 <athan> OH
11:44:15 <athan> WAIT
11:44:16 <DR6> the only conditions for a monoid are associativity
11:44:21 <DR6> which obviously holds
11:44:24 <DR6> and identity
11:44:25 <DR6> which is id
11:44:35 <DR6> the structure is not important
11:44:53 <athan> johnw: so composing endomorphisms is a monoid?
11:44:59 <johnw> yes, we call it Endo
11:45:14 <athan> johnw: and they can be technically re-arranged in any order?
11:45:18 <athan> That's friggin nuts
11:45:21 <beaky> haskell language itself and the abstractions seem simple (monoids are easy)
11:45:22 <DR6> no
11:45:24 <johnw> well, they can associate in any order
11:45:36 <DR6> if you already composed them, you can't rearrange
11:45:37 <nadirs> I currently only understand Arrows as functions, are there other instances apart from (-> r)?
11:45:49 <DR6> rearranging is a property of the free monoid
11:45:51 <athan> hmm
11:45:55 <DR6> aka lists
11:45:56 <quchen> Rearranging = commutativity. Moving parentheses = associativity.
11:45:57 <athan> wouldn't it have to be endofunctors?
11:46:07 <athan> er
11:46:08 <athan> shit
11:46:33 <athan> what if the underlying morphisms aren't monoids themselves? Like (+), it is actually (%) underneath
11:46:48 <quchen> Huh?
11:46:52 <nadirs> beaky: have you played with applicative parsers? Haskellers seem to like them a lot
11:46:58 <DR6> the morphisms are the functions
11:46:58 <athan> even though it's an endomorphism on the same type, the morphism isn't monoidal
11:47:06 <DR6> no
11:47:09 <DR6> wait
11:47:13 <athan> and thus, the composition of them wouldn't be monoidal
11:47:15 <DR6> in that monoid
11:47:19 <DR6> the functions are the objects
11:47:30 <athan> not their implementation?
11:47:40 <DR6> look
11:47:41 <athan> merely their existence on the types?
11:47:45 <athan> hmm
11:47:46 <DR6> it'0s simpler than that
11:47:49 <athan> I could see that
11:48:03 <quchen> nadirs: Kleisli (i.e. "monadic functions", type a -> m b) are the other default arrow instance.
11:48:13 <quchen> (.) = (>=>), id = return
11:48:14 <DR6> (f . g) x = f (g x)
11:48:17 <DR6> that is the operation
11:48:34 <DR6> so f . (g . h) x = f (g (h x))
11:48:49 <DR6> and (f  . g) . h x = f (g (h x))
11:48:50 <DR6> they are the same
11:48:56 <DR6> so composition is associative
11:49:07 <DR6> f . id = id . f = f
11:49:10 <DR6> so you have an identity
11:49:11 <athan> correct, but the results aren't the same if you flip the ordering
11:49:17 <athan> much like a list
11:49:19 <DR6> yes
11:49:22 <athan> hmm
11:49:24 <DR6> monoids don't need to be commutative
11:49:26 <athan> that's still a monoid?
11:49:28 <athan> OH
11:49:30 <athan> damn!
11:49:32 <DR6> lists are a monoid too
11:49:33 <athan> There's my mistake
11:49:38 <johnw> there *are* commutative monoids, but not all are
11:49:44 <DR6> exactly
11:49:48 <nadirs> quchen: I'm afraid I need to understand category theory for Kleisli?
11:50:00 <athan> so even then, arrow merging is still a monoid itsef too, even though it's results are tuples
11:50:11 <DR6> eh
11:50:19 <quchen> nadirs: Not really, no.
11:50:26 <athan> is there a class of commutative monoids? That's data-location scalable
11:50:31 <DR6> no
11:50:31 <DR6> (f *** g) ** h =/= f *** (g *** h)
11:50:38 <DR6> they are different types
11:50:41 <athan> hmm
11:50:46 <Drezil> nadirs: you don't have to ... but its difficult :p
11:51:06 <athan> i'll make one with unsorted containers, then come back lol
11:51:07 <nadirs> quchen, Drezil: so, they're functions that lift stuff into monads, right?
11:51:28 <jle`> kleisli composition is not complicated, wtf?
11:51:39 <quchen> They're your usual functions that you put on the RHS of (>>=) all the time.
11:51:43 <quchen> :t (>>=)
11:51:43 <lambdabot> Monad m => m a -> (a -> m b) -> m b
11:51:52 <quchen> There's a "Kleisli" function right in the middle
11:51:56 <dmwit> athan: You might look in the numeric-prelude package.
11:52:01 <DR6> :t putStrLn
11:52:02 <lambdabot> String -> IO ()
11:52:02 <athan> I see a monoid as an expression that's... freely orientable
11:52:10 <nadirs> quchen: a-ha! That's clear, nice.
11:52:14 <athan> but not directable (that's where the commutative ones come into play)
11:52:23 <quchen> :t Kleisli putStrLn -- putStrLn is Kleisli.
11:52:24 <lambdabot> Kleisli IO String ()
11:52:33 <DR6> here you got a kleisly arrow
11:52:40 <DR6> more like freely nestable
11:53:06 <athan> dmwit: Will do!
11:53:06 <DR6> monoids are things that are kinda like lists
11:53:08 <dmwit> (>=>) is Kleisli composition
11:53:24 <DR6> in the sense that there is an "empty" element and you can "concatenate" elements
11:53:49 <athan> DR6: I agree
11:54:11 <athan> dmwit: but there's still a common direction
11:54:11 <DR6> that is the good intuition
11:54:18 <Drezil> DR6: and you should be able to "backreference" some of the prior elements in the list, if im not mistaken ..
11:54:24 <dwcook> Lists are in some sense a general monoid. They include the monoid structure and nothing else.
11:54:33 <dmj`> DR6: Sum and Product are monoids, but they don't look like lists
11:54:35 <DR6> how backreference?
11:54:38 <dmwit> athan: Even if there's no standard class for it, it's not exactly hard to make. "class Monoid m => CommutativeMonoid m" is the complete source. =P
11:54:45 <DR6> yes they do
11:54:47 <DR6> in the way I said
11:55:02 <dmwit> dmj`: Sum looks like a list modulo the equation [a, b] = [a+b]
11:55:19 <nadirs> dmwit: how would CommutativeMonoid work?
11:55:26 <quchen> dwcook: where commute a b = if unsafePerformIO randomIO then a <> b else b <> a
11:55:27 <athan> everywhere!
11:55:32 <athan> nadiris:
11:55:33 <dmwit> nadirs: You'd only provide an instance for commutative monoids.
11:55:36 <Drezil> DR6: like i can access the already concatenated elements in the list, but not the ones defined/added after that..
11:55:47 <dmwit> nadirs: It's not like there's many extra operations you get by assuming a monoid is commutative. Just extra guarantees.
11:55:49 <athan> nadiris: It gives you the freedom of RAM
11:55:49 <DR6> only they are commutative
11:55:50 <DR6> you could say that a monoid instance is equivalent to a function [m] -> m
11:55:50 <dwcook> quchen, did you mis-highlight?
11:56:03 <dmj`> dmwit: I see
11:56:08 <quchen> dwcook: Oh, yes. I meant dmwit. Well it was a bad joke anyway :-)
11:56:15 <DR6> no
11:56:18 <DR6> not necessarily
11:56:53 <athan> i mean, you don't have to keep the organization of the elements in mind
11:56:58 <dmwit> A monoid instance is equivalent to a monoid homomorphism [m] -> m. But that's an awful definition for obvious reasons. =)
11:57:03 <athan> you can freely associate and operate on any subsets
11:57:09 <athan> in any order to get the result
11:57:13 <DR6> the organization as in the nesting
11:57:13 <DR6> yes, you don't have to do it
11:57:31 <DR6> it also means that foldl and foldr do the same, modulo laziness
11:57:32 <athan> perfect for distributed calculations!
11:57:35 <nadirs> dmwit: I don't understand yet. Do you have an example instance for CommutativeMonoid
11:57:37 <nadirs> ?
11:57:42 <athan> but, probably everythign here is lol
11:57:42 <Drezil> DR6: or is the monad-property of binding derived from properties of the endofunctor instead of the monoid?
11:57:43 <DR6> and yes, distributed calculations
11:57:48 <dmwit> nadirs: instance CommutativeMonoid (Sum Integer)
11:57:52 <athan> DR6: HOLY CRAP
11:58:23 <athan> DR6: mind = blown
11:58:26 <nadirs> dmwit: oh, in that way, ok. So you just give a name to something that is already commutative
11:58:32 <joseph07> yogert: This might help you get started http://lpaste.net/101800
11:58:36 <DR6> the problem with CommutativeMonoid is that it doesn't add any new functions
11:58:48 <DR6> so you are promising that it's commutative without doing anythinh
11:58:54 <dwcook> DR6, it would add commute
11:58:56 <dmwit> nadirs: Well. No new names. Just a new constraint.
11:59:03 <dmwit> dwcook: And what would "commute" do?
11:59:04 <nadirs> DR6: I was guessing something like "flip"ping the monoid instance
11:59:13 <DR6> it wouldn't add anything
11:59:19 <DR6> if the monoid is commutative
11:59:34 <DR6> <> is already commutative
11:59:36 <dwcook> Hmm, yeah, I can't think of how to phrase that in terms of the existing Monoid
11:59:47 <nadirs> DR6: you're right. Flipping would just verify it's correct...
12:00:12 <DR6> maybe you could not make it a superclass of monoid
12:00:24 <DR6> but make it with a function Set m -> m instead
12:00:32 <athan> they have a common domain
12:00:35 <DR6> technically it doesn't guarantee that it will be commutative
12:00:38 <dmwit> Set m -> m is not the same as commutative
12:00:45 <athan> but the commumutivity actually is less restrictive
12:00:48 <dmwit> Set m -> m also assumes idempotency or something like that, I would bet.
12:00:49 <athan> not an added feature
12:01:11 <nadirs> athan: how is it *less* restrictive?
12:01:16 <DR6> yeah that would be a problem
12:01:27 <nadirs> It adds the constraint that a monoid works on any order, no?
12:01:35 <DR6> yes
12:01:38 <DR6> it adds a constraint
12:01:41 <athan> nadirs: because the elements can be <>'d in any order, in any subsets, and still return the same result
12:01:43 <DR6> so it's more restrictive
12:03:02 <nadirs> the set of monoids that works the same way in any order is smaller than the set of monoids that give different results in different orders
12:03:07 <athan> nadirs: opposed to monoids that must execute within proximity and direction to eachother - f <> (g <> h) vs (f <> g) <> h
12:03:38 <athan> nadirs: more solutions available! More freedom!
12:04:15 <nadirs> athan: indeed. So, aren't we saying the same thing? I can't tell :P
12:04:41 <athan> nadirs: I think so lol. My view: Commutative monoids are less restrictive than standard monoids
12:05:04 <DR6> maybe you could say that they are restrictive
12:05:08 <nadirs> athan: a-ha. Ok, I think I understand the misunderstanding
12:05:16 <DR6> as in they let you do more transformations without changing the result
12:05:27 <athan> correct!
12:05:28 <DR6> but normally it's done backwards
12:05:30 <skypers> itâ€™s curious how I can understand expressions I was impressed by a year ago
12:05:36 <skypers> I wrote this one:
12:05:37 <skypers> liftIO $ Shader <$> (flip newForeignPtr p =<< wrap (peek >=> glDeleteShader))
12:05:41 <nadirs> I'm saying they're more restrictive in their domain, you're saying they're less restrictive in their usage. Maybe?
12:05:43 <skypers> itâ€™s straight-forward now
12:05:49 <athan> we should have network-scale commutative monoid simulators
12:05:54 <skypers> I remember a year ago I was like â€œWHATâ€
12:05:54 <skypers> :D
12:05:56 <athan> for mmo's
12:06:08 <DR6> there is a neural network library
12:06:08 <athan> or anything else that requires a common understanding
12:06:15 <DR6> that uses monoids for exactly that
12:06:18 <skypers> DR6: alpounetâ€™s, yes
12:06:24 <DR6> i don't remember the name
12:06:35 <alpounet> nah
12:06:40 <alpounet> mine doesn't use monoids
12:06:44 <skypers> oh
12:06:44 <alpounet> DR6: it's hlearn
12:06:46 <DR6> *machine learning
12:06:46 <athan> nidirs: Yes!! Sorry hahaha
12:06:47 <skypers> I thought so
12:06:48 <alpounet> and it's not just neural networks
12:06:55 <athan> No way
12:07:00 <athan> what is a neural network??
12:07:10 <beaky> is haskell a well-designed langauge
12:07:12 <alpounet> hlearn-classification is the one doing the machine learning per se
12:07:27 <skypers> a layer of several neurons I gues
12:07:35 <skypers> beaky: whatâ€™s the question?
12:07:38 <dmwit> beaky: Sounds troll-y. Be careful.
12:07:45 <athan> hmm
12:07:51 <skypers> guess*
12:07:58 <athan> that's interesting
12:08:04 <athan> right lol
12:08:07 <alpounet> athan: an AI technique, see the wikipedia page.
12:08:15 <skypers> hm
12:08:16 <athan> i have
12:08:19 <athan> but in what context?
12:08:20 <alpounet> there is a coursera course about that, too, check it out
12:08:28 <athan> a standard type across the... inferers?
12:08:37 <skypers> a NN as monoid, sounds fun, how does it work, you can accumulate the activation function with mappend?
12:08:41 <athan> And each node just does statistical analysis of the connections within the type, right?
12:08:51 <athan> or is it way crazier, like with signaling patterns?
12:08:57 <DR6> I meant machine learning
12:08:58 <DR6> a neural network is a specific way of doing machine learning
12:08:58 <DR6> but I don't think it benefits from monoids
12:08:58 <DR6> I mean I don't know
12:09:07 <alpounet> it can
12:09:08 <TallerGhostWalt> if you use ! in data definitions do you not need BangPatterns?
12:09:16 <athan> meh
12:09:17 <athan> anyway
12:09:19 <skypers> TallerGhostWalt: yes
12:09:21 <nadirs> beaky: hey, just curious, have you open-sourced the website written in haskell you mentioned early?
12:09:26 <alpounet> training a neural net on samples is a monoid homomorphism, if you want the technical terms for reference
12:09:28 <beaky> yes
12:09:28 <TallerGhostWalt> skypers: thx
12:09:33 <athan> I'm also trying to make a realtime front-end/yesod engine for websites
12:09:39 <athan> to have immediate communications
12:09:47 <alpounet> TallerGhostWalt: no you don't
12:09:48 <athan> I think that's a prime example of the comm. monoid
12:09:59 <skypers> monoids rule
12:10:09 <alpounet> you need them when you want a value to be evaluated strictly, somewhere in a function
12:10:10 <beaky> http://lpaste.net/101801
12:10:12 <beaky> my website
12:10:26 <nadirs> have you people read that article about discovering monoids in PHP?
12:10:34 <threestrikes> I'm new to haskell and have been reading "Learn you a Haskell for Great Good"  I don't have any other programming experience.  Can a few of you share your experiences with how you came to truly understand Haskell.  What can I do to assist me with actually being able to write a working program of moderate complexity?
12:10:39 <TallerGhostWalt> In the haskell cast w/ Don Stewart, the suggestion was strict all record primatives.
12:10:42 <dmwit> alpounet: Do you need a dependent type to make that a monoid? e.g. you may only combine neural nets with the same network layout or something?
12:10:43 <TallerGhostWalt> What about like [Int]
12:10:48 <TallerGhostWalt> any general guideline?
12:10:53 <dmwit> alpounet: If yes, I think I understand your sentence; if no, I definitely don't.
12:11:15 <Yaniel> threestrikes: write programs with close to no complexity
12:11:20 <beaky> threestrikes: I tried writing a simple game (tictactoe, hangman, rougelike) in haskell
12:11:57 <beaky> having an end goal with haskell in mind helps motivate learning
12:12:13 <threestrikes> I see
12:12:15 <Yaniel> I use it as a programmable calculator every now and then
12:12:22 <beaky> who knows maybe you invent a chess monad!
12:12:24 <Yaniel> just to do something
12:12:28 <nadirs> threestrikes: if you figure it out let me know. I'm still stuck at the "Fibonacci gap" ( term invented here â†’ http://mainisusuallyafunction.blogspot.it/2010/10/tour-of-real-toy-haskell-program-part-1.html)
12:13:04 <dmwit> threestrikes: Hang it in-channel and try to understand the show-off one-liners people post as snarky answers to beginner questions.
12:13:20 <dmwit> threestrikes: Then hang out in-channel and try to concoct show-off one-lines to post as a snarky answer to beginner questions.
12:13:21 <nadirs> beaky: ha, thanks for the link :)
12:13:23 <TallerGhostWalt> dmwit: lol
12:14:11 <dmwit> threestrikes: (Which is to say, just another variation of other people's advice: write a lot of code.)
12:14:38 <nadirs> dmwit: I love the intro to Typeclassopedia â†’ http://www.haskell.org/haskellwiki/Typeclassopedia#Introduction
12:14:42 <alpounet> dmwit: it represents labels with centrois and does a union, when 'mappend'ing
12:14:46 <nadirs> Â«Someone in the #haskell IRC channel used (***), and when I asked lambdabot to tell me its type, it printed out scary gobbledygook that didnâ€™t even fit on one line! Then someone used fmap fmap fmap and my brain exploded.Â»
12:14:49 <alpounet> dmwit: http://hackage.haskell.org/package/HLearn-classification-1.0.1.1/docs/src/HLearn-Models-Classifiers-Perceptron.html#Perceptron check the Monoid instance there
12:14:57 <dmwit> alpounet: thanks
12:15:10 <threestrikes> I just want to say thank you all.  I was beginning to doubt myself and was worried I bit off more than I could chew.
12:15:19 <alpounet> dmwit: train someData generates a Perceptron. train data1 <> train data2 == train (data1 <> data2)
12:16:32 <dmwit> oh
12:17:00 <beaky> to me it seems on a surface level, programming in haskell seems like programing in any other programing language; just sit down, think really hard about your problem, then open up vim and start punching keys
12:17:08 <zerokarmaleft> threestrikes: if you're starting off with haskell with no other prior programming experience, some might say that they envy your situation
12:17:27 <alpounet> beaky: that will change over time. i've been using it for 6 years and i'm still understand things day after day
12:17:44 <zerokarmaleft> threestrikes: you get to start off programming with solid first principles, whereas a bunch of people have to unlearn years of terrible habits from other languages
12:18:06 <alpounet> you just get to understand more complicated things as you go, things you didn't know existed when you began learning. and those things that were hard at the beginning become trivial after a couple of years
12:18:28 <alpounet> dmwit: yeah this is a pretty fun idea to toy around with :-)
12:18:35 * dmwit . o O ( 10,000 hours of practice )
12:18:39 <TallerGhostWalt> beaky:  I don't think I program like that, that sounds like super genius programming
12:18:40 <bahamas> zerokarmaleft: on the other hand, knowing the *bad* stuff makes you appreciate the elegance of haskell more
12:18:41 <Drezil> 20:09 < nadirs> have you people read that article about discovering monoids in PHP? << no... do you have a link?
12:18:51 <nadirs> Drezil: let me find it :)
12:19:16 <zerokarmaleft> bahamas: ignorance is truly bliss
12:19:46 <alpounet> monoids in php?
12:19:49 <alpounet> erk.
12:19:53 <mornfall> alpounet: monoids are everywhere
12:20:00 <mornfall> yes, even in php! :-)
12:20:09 <alpounet> i know, the values are the same in the absolute
12:20:31 <nadirs> Drezil: http://videlalvaro.github.io/2014/03/the-power-algorithm.html
12:20:33 <alpounet> it's just that actually using them as such certainly shouldn't improve readability
12:20:48 <bahamas> zerokarmaleft: why are you here then?
12:21:29 <zerokarmaleft> bahamas: that's tongue-in-cheek...coming from Java -> Ruby -> Scheme/Clojure -> Haskell I can say that I've never had more fun programming than I do now :)
12:21:36 <nadirs> I like the fact that even in a terrible thing like PHP you can bend your mind and discover this kind of things
12:22:01 <kakos> How do you make a TH function that performs multiple declarations?
12:22:28 <Drezil> nadirs: thx
12:23:10 <aib> :t (***)
12:23:11 <lambdabot> Arrow a => a b c -> a b' c' -> a (b, b') (c, c')
12:23:22 <aib> err that reminds me, I gotta read up on arrows
12:24:30 <nadirs> Â«gobbledygookÂ»
12:24:40 <Drezil> :t beside
12:24:41 <lambdabot> (Applicative (Data.Profunctor.Rep.Rep q), Applicative f, Data.Profunctor.Rep.Representable q) => Overloading p q f s t a b -> Overloading p q f s' t' a b -> Overloading p q f (s, s') (t, t') a b
12:24:43 <Drezil> :p
12:24:57 <Drezil> thats my favorite atm :D
12:24:57 <bahamas> zerokarmaleft: exactly
12:24:58 <nadirs> Drezil: haha I see. It only gets worse
12:25:30 <bahamas> zerokarmaleft: I'm actually interested in Lisp. I'm curious to see how much I will miss the static typing
12:25:41 <nadirs> Drezil: there's some troll on FPComplete who wrote an article which title is "I love Profunctors. They're so easy"
12:25:42 <dwcook> I tried searching "php monoid" and managed to find this instead
12:25:48 <dwcook> @google monad-php
12:25:48 <lambdabot> Plugin `search' failed with: user error (https not supported)
12:25:50 <aib> all I got from that was "fstab". As in /etc/fstab :)
12:25:57 <dwcook> https://github.com/ircmaxell/monad-php
12:26:16 <bahamas> now that I've gotten used to them, I miss it in python
12:26:16 <dwcook> Note the "extract" method on Maybe :P
12:26:19 <kadoban> is there some way to get lpaste to execute code and show the output, or not so much?
12:26:20 <Drezil> nadirs: http://hackage.haskell.org/package/lens-3.10/docs/src/Control-Lens-Traversal.html#beside - all the other headers are equivalent "specialisations" of that general function-signature
12:26:22 <bahamas> s/it/them/
12:26:30 <dwcook> And even on List
12:26:41 <aib> eugh, I still can't get over the fact that PHP uses \ for namespace resolution
12:26:43 <bahamas> kadoban: codepad executed code, but I don't remember if it supported haskell. you can check
12:26:44 <prooftechnique> dwcook: I was also looking at that library the other day
12:26:55 <Drezil> but ... if the signature is longer than the function it gets scary ...
12:27:10 <geekosaur> last I checked, codepad used hugs or something like that
12:27:56 * hackagebot hinquire 0.1.1 - Generate armet style query strings.  http://hackage.haskell.org/package/hinquire-0.1.1 (joneshf)
12:28:07 <kadoban> bahamas: hmm, alrighty, thanks
12:28:13 <nadirs> Drezil: I'm still in the "wat" stage :P
12:28:38 <bennofs> http://ideone.com does have GHC 7.6.3
12:29:06 <kadoban> Hmm, I guess ideone and codepad both execute haskell, but they don't have the module I need, sigh...oh well
12:29:20 <bennofs> kadoban: ^^ or you try fpcomplete
12:29:27 <nadirs> kadoban: what bennofs said.
12:29:52 <nadirs> fpcomplete is doing an impressive work
12:30:03 <Drezil> nadirs: well.. im still there ... after 1 year
12:30:30 <Drezil> https://www.youtube.com/watch?v=9EGYSb9vov8 is still WTF-Land for me ...
12:30:31 <bennofs> kadoban: http://fpcomplete.com -- The community edition allows you to play around with it, although there is no way to "download" the code from the ide (other than copy-pasting)
12:30:59 <kadoban> Parsec question http://lpaste.net/101804  I'd expect the output to be "unexpected Byte: 5\n expecting valid opcode or end of input", but the "valid opcode" part isn't there when I run it.  Any ideas why?
12:31:30 <nadirs> Drezil: http://1.bp.blogspot.com/-OF-0Go_epzs/USZlmg4vTkI/AAAAAAAABXM/xxjX-uQe0Vs/s1600/tower.gif
12:32:51 <nadirs> Drezil: have you read the top comment: "The friendliest presentation on category theory I've ever seen.ï»¿"
12:38:08 <bennofs> Is there some tool that automatically tests a cabal library for the upper and lower bound of each dependency? (It shouldn't test all possible combinations, just one dependency at one time)
12:39:02 <bennofs> Another question: Is it fine for a library to have ghc-options: -Wall in the cabal file?
12:39:30 <dcoutts> bennofs: on Q #2: yes
12:40:18 <aib> "The composition of two Functors is also a Functor." - what's the composition of two type classes? Maybe Maybe Int? (a,(b,c))?
12:40:38 <dwcook> aib, Maybe isn't a type class
12:41:07 <dwcook> aib, you can compose type constructors though. For example, Compose Maybe Maybe just gives you a double-nested Maybe
12:41:40 <aib> dwcook: sorry, I meant "stuff of kind (* -> *)" instead of "type class"
12:41:47 <bennofs> aib: it means that if you've got two data types that are an instance of Functor (data types that are an instance of Functor are sometimes abbreviated to just "Functors"), then the composition is also an instance of Functor
12:41:55 <aib> "type constructors of kind * -> *"
12:42:13 <dwcook> aib, Compose :: (* -> *) -> (* -> *) -> (* -> *)
12:42:22 <bennofs> aib: data Compose f g a = Compose (f (g a))
12:42:35 <dwcook> So yes, types of kind * -> * are closed under composition
12:42:52 <yitz> Drezil: i don't use lenses (yet), but that signature for beside actually makes some sense. i don't know about the representability stuff, but other than that, it's quite clear what beside is doing.
12:44:04 <aib> I see it now. thanks
12:51:06 <SrPx> Is there a way to use a lazy foldr to divide the first 10 elements of an infinite list?
12:51:29 <dwcook> SrPx, sure, but take might serve you better
12:51:29 <SrPx> `foldr1 (/) [1..]` obviously won't work
12:51:48 <dwcook> Anyway, what do you mean when you say you want to divide more than two elements?
12:52:59 * hackagebot unbounded-delays 0.1.0.7 - Unbounded thread delays and timeouts  http://hackage.haskell.org/package/unbounded-delays-0.1.0.7 (BasVanDijk)
12:53:10 <SrPx> dwcook: I want to make a point that foldr always begin reduction of `f` at the last element... his example was that `take 10 $ foldr (:) (repeat 1)` returns a finite list, thus (:) begins being applied to the first element, then the second, etc, til the 10th
12:53:23 <SrPx> but that is false, the first (:) application is (: 8 9) in that case!
12:53:41 <dwcook> SrPx, there is no "first" application, only innermost and outermost
12:55:57 <dwcook> SrPx, you might not be able to do it *just* in terms of foldr. e.g., you might have to do something to the output
12:56:22 <dennda> 3
12:56:25 <dennda> Well, sorry.
12:56:36 <dwcook> Though I'm still curious why take is insufficient
12:57:42 <SrPx> dwcook: what I mean is that (take 4 $ foldr1 (:) [1..]) is (0 : (1 : (2 : (3 : [])))) ... the innermost expression is (3 : []). If (:) was reducible, then the other expressions would depend on (3:[]). thats the point
12:58:00 * hackagebot case-insensitive 1.2.0.0 - Case insensitive string comparison  http://hackage.haskell.org/package/case-insensitive-1.2.0.0 (BasVanDijk)
12:58:16 <ziman> > take 10 $ foldr ((:) . (+1)) [] [1..]
12:58:17 <lambdabot>  [2,3,4,5,6,7,8,9,10,11]
12:58:28 <dwcook> SrPx, I don't get what you mean. But are you aware that foldr1 (:) is the identity on non-empty lists?
12:58:39 <awestroke> How do I change my bnfc grammar to make alex/happy include line numbers?
12:59:11 <SrPx> dwcook: yep (:
12:59:22 <SrPx> ziman: oh good (:
12:59:35 <SrPx> ziman: oh actually thiis wouldn't work for (/) I guess
13:00:11 <dwcook> SrPx, what are some example inputs and outputs? It's unclear what you want to divide by what
13:00:53 <SrPx> dwcook: I was just going to make a point that foldr (/) generally is not the same as foldl (/) but nvm that by now ^^
13:01:14 <dwcook> SrPx, sure, (/) isn't commutative
13:01:21 <ziman> SrPx, yes because (/) is strict in its second argument
13:01:55 <SrPx> dwcook: associativity is the problem actually
13:02:29 <dwcook> > foldr1 (/) [a, b, c, d, e]
13:02:30 <lambdabot>  a / (b / (c / (d / e)))
13:02:34 <dwcook> > foldl1 (/) [a, b, c, d, e]
13:02:35 <lambdabot>  a / b / c / d / e
13:02:43 <dwcook> Yeah, you're right
13:03:20 <SrPx> did you just use undefined variables
13:03:26 <dwcook> They're not undefined
13:03:57 <dwcook> lambdabot is prepopulated with bindings for special values intended to make introspection easy
13:04:04 <dwcook> :t a
13:04:05 <lambdabot> Expr
13:04:17 <dwcook> :t f
13:04:18 <lambdabot> FromExpr a => a
13:04:24 <SrPx> Expr? How is that actually defined?
13:04:29 <dwcook> No idea
13:04:34 <dwcook> @src Expr
13:04:34 <lambdabot> Source not found. There are some things that I just don't know.
13:04:40 <SrPx> interesting
13:04:51 <SrPx> lol
13:05:01 <dwcook> Well they're not "special". They just have interesting Show instances
13:05:10 <dwcook> and instances in general
13:05:10 <SrPx> @src sdlmfalsm
13:05:10 <lambdabot> Source not found. You untyped fool!
13:05:25 <quchen> @define mapFirst = let mapFirst' :: Int -> (a -> a) -> [a] -> [a]; mapFirst' n f xs = foldr go (const []) xs n where go y ys 0 =   y : ys 0; go y ys n = f y : ys (n-1) in mapFirst'
13:05:26 <lambdabot>  Defined.
13:05:32 <quchen> > mapFirst 3 (*100) [1..]
13:05:33 <lambdabot>  [100,200,300,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,...
13:05:35 <quchen> :-)
13:05:45 <quchen> http://lpaste.net/101807
13:06:46 <SrPx> > take 5 $ mapFirst 5 (/10) [1..]
13:06:48 <lambdabot>  [0.1,0.2,0.3,0.4,0.5]
13:06:51 <SrPx> neat
13:07:30 <quchen> I think a splitAt-based version is clearer though.
13:07:51 <kadoban> Hmm, nevermind on my parsec question above, in the unlikely event anyone is still looking at it.  Found an easier way I think.
13:08:58 <bennofs> Is the underlying data type for IntMap/Map the same, for both the strict and the lazy variant?
13:09:00 <quchen> That one: mapFirst' n f xs = let (before, after) = splitAt n xs in  map f before ++ after
13:09:31 <quchen> bennofs: They're both binary self-balancing trees, yes
13:09:40 <bennofs> quchen: I mean, is the type actually the same?
13:10:56 <quchen> Depends on what you mean with "the same". They both have separate types defined in separate locations.
13:11:05 <bennofs> > (undefined :: IntMap.Lazy.IntMap Int) == (undefined :: IntMap.Strict.IntMap Int)
13:11:06 <lambdabot>  *Exception: Prelude.undefined
13:11:11 <bennofs> how do you explain that this typechecks then?
13:11:29 <bennofs> (I did import qualified Data.IntMap.Strict as IntMap.Strict etc)
13:11:42 <quchen> Oh, I was just commenting on the Map/IntMap part.
13:11:57 <bennofs> ah, probably misphrased my question then :D
13:11:58 <quchen> Strict/lazy I'm not sure, hold on.
13:12:06 <TallerGhostWalt> it's always so weird when I feel like I need a stack trace
13:12:35 <zerokarmaleft> in a cabal sandbox, if I have some build-depends defined solely under test-suite (e.g. tasty, tasty-*), shouldn't `cabal install --enable-tests` grab those deps?
13:12:52 <karshan> hey I though that it wasn't possible to define a non-pure function in haskell. So why do I think "\ a b = getStdRandom (randomR (a, b))" is non-pure
13:12:52 <quchen> bennofs: They both seem to be the same type indeed.
13:12:59 <quchen> Strict/lazy IntMap, that is.
13:13:08 <bennofs> quchen: ok thanks, then I only need/can write instances for one of them :)
13:13:43 <thebnq> karshan: it returns IO
13:13:54 <quchen> karshan: What "pure" means isn't well-defined. The function you posted is the same every time you run it: it takes two parameters (a and b) and gives you back "a program that calculates a random number".
13:14:17 <karshan> quchen: thanks that makes perfect sense
13:14:30 <quchen> karshan: Performing that IO requires the runtime system to actually make a computer execute these instructions.
13:14:49 <quchen> But on Haskell's inside, it's all "pure" in a sense.
13:14:58 <quchen> Also see the famous
13:15:02 <quchen> @quote shachaf /bin/ls
13:15:02 <lambdabot> shachaf says: getLine :: IO String contains a String in the same way that /bin/ls contains a list of files
13:15:25 <zerokarmaleft> nvm, it does precisely that after blasting my sandbox
13:15:34 <quchen> /bin/ls is "pure" because it doesn't change.
13:15:37 <quchen> It's always the same program.
13:15:59 <quchen> Running the program isn't part of /bin/ls, that's whatever the OS decides to do with that executable.
13:16:37 <SrPx> Hey a question, is it possible to make sure Haskell is computing everything, without using `print` to force evaluation of the whole structure?
13:17:03 <SrPx> Something like "print" that doesn't actually print, just forces complete normalization
13:17:05 <bitemyapp> SrPx: use the evalue?
13:17:08 <bitemyapp> SrPx: seq?
13:17:09 <karshan> SrPx: there's seq
13:17:10 <WraithM> seq?
13:17:18 <SrPx> let me see
13:17:19 <quchen> deepSeq?
13:17:25 <bitemyapp> lets all say seq at once.
13:17:28 <Iceland_jack> seq is not what SrPx is asking for, deepSeq is
13:17:44 <bitemyapp> oh, complete normalization.
13:17:45 <Iceland_jack> Control.DeepSeq
13:17:47 <bitemyapp> roight.
13:18:02 * hackagebot yesod-auth 1.3.0.1 - Authentication for Yesod.  http://hackage.haskell.org/package/yesod-auth-1.3.0.1 (MichaelSnoyman)
13:18:04 * hackagebot yesod-static 1.2.2.3 - Static file serving subsite for Yesod Web Framework.  http://hackage.haskell.org/package/yesod-static-1.2.2.3 (MichaelSnoyman)
13:18:33 <SrPx> yep it is deepseq, neat thanks
13:21:44 <awestroke> > fail "haskell" :: [haskell]
13:21:45 <lambdabot>  []
13:22:18 <SrPx> > foldlr1 (flip (/)) [a,b,c,d]
13:22:18 <lambdabot>  Not in scope: `foldlr1'
13:22:19 <lambdabot>  Perhaps you meant one of these:
13:22:19 <lambdabot>    `foldl1' (imported from Data.List),
13:22:19 <lambdabot>    `BSC.foldl1' (imported from Data.ByteString.Char8),
13:22:19 <lambdabot>    `BSLC.foldl1' (imported from Data.ByteString.Lazy.Char8)
13:22:27 <SrPx> > foldr1 (flip (/)) [a,b,c,d]
13:22:28 <lambdabot>  d / c / b / a
13:22:37 <SrPx> > foldl1 (/) [a,b,c,d]
13:22:38 <lambdabot>  a / b / c / d
13:22:43 <bitemyapp> :t a
13:22:44 <lambdabot> Expr
13:23:33 <SrPx> > foldr1 (/) [a,b,c,d]
13:23:34 <lambdabot>  a / (b / (c / d))
13:23:41 <SrPx> > foldl1 (flip (/)) [a,b,c,d]
13:23:42 <lambdabot>  d / (c / (b / a))
13:26:29 <_ikke_> Trying to create a toUpper function and getting this error: http://lpaste.net/101808
13:27:58 <ion> ikke: â€œtoUpper' :: [a] -> [a]â€ means that i (the user of it) get to pick the â€œaâ€. So youâ€™re promising i can do â€œtoUpper' [5,6,7]â€.
13:28:19 <_ikke_> ok
13:28:24 <ion> ikke: GHC sees that your code canâ€™t fulfill that promise. The code restricts â€œaâ€ to â€œCharâ€.
13:29:18 <_ikke_> Ok, I fixed it to String -> String, and it works
13:29:26 <_ikke_> ion: thanks
13:30:39 <kazagistar1> I was just wondering if something vaugely like this exists... (Regex -> Test.QuickCheck.Gen String) ?
13:31:19 <ion> ikke: This is a fine learning exercise, but itâ€™s worth pointing out that for real-world things, toUpper :: Char -> Char can not work correctly due to how Unicode works. Data.Text.toUpper does the right thing. http://hackage.haskell.org/package/text-1.1.0.1/docs/Data-Text.html#g:8
13:31:49 <_ikke_> ion: Yes, I was aware of this.
13:32:09 <_ikke_> Thanks for the tip
13:32:55 <kazagistar1> it would be nice to specify "create arbitrary strings matching this regex", basically
13:33:02 <quchen> ion: Why can't toUpper be Char -> Char? Composite characters?
13:33:41 <ion> quchen: The linked Data.Text documentation has examples.
13:33:55 <_ikke_> quchen: one character could map to multiple other characters
13:34:02 <_ikke_> quchen: Or multiple to one
13:34:13 <quchen>  For instance, the German "ÃŸ" (eszett, U+00DF) maps to the two-letter sequence "SS".  à² _à²   The fight for the capital ÃŸ continues!
13:34:28 <quchen> Thanks ion, _ikke_
13:34:42 <_ikke_> quchen: Are you german?
13:34:45 <ystael> quchen: áºž áºž áºž
13:34:58 <ion> kazagistar1: Iâ€™m pretty sure thereâ€™s a library for that somewhere.
13:35:26 <kazagistar1> ion: I was looking, but I couldn't find one...
13:35:39 <ion> http://hackage.haskell.org/package/regex-genex
13:37:05 <beaky> @hoogle (a -> Maybe b) -> [a] -> Maybe [b]
13:37:05 <lambdabot> Prelude mapM :: Monad m => (a -> m b) -> [a] -> m [b]
13:37:05 <lambdabot> Control.Monad mapM :: Monad m => (a -> m b) -> [a] -> m [b]
13:37:05 <lambdabot> Control.Monad forM :: Monad m => [a] -> (a -> m b) -> m [b]
13:37:36 <handuel> Can anyone recommend a resource to learn haskell with exersizes? I am trying to follow learn you a haskell, but I keep forgetting things because I don't actually use much haskell to actually program while following it. (I just mess around with the examples). Does anyone know of a tutorial with actual problems to solve?
13:37:41 <beaky> @hoogle [a] -> (a -> Maybe b) -> Maybe [b]
13:37:41 <lambdabot> Control.Monad forM :: Monad m => [a] -> (a -> m b) -> m [b]
13:37:41 <lambdabot> Prelude mapM :: Monad m => (a -> m b) -> [a] -> m [b]
13:37:41 <lambdabot> Control.Monad mapM :: Monad m => (a -> m b) -> [a] -> m [b]
13:37:45 <beaky> oops
13:38:18 <quchen> handuel: RWH has exercises. When I learned Haskell, I read LYAH and did the RWH exercises that I understood.
13:38:41 <quchen> handuel: You can also try implementing Prelude functions yourself, such as map, take, dropWhile, span, splitAt, â€¦
13:39:46 <handuel> quchen: I'll take a look at real world haskell then. I have heard of it but not actually given it a look. Thank you for the advice.
13:41:12 <handuel> "The server at realworldhaskell.com is taking too long to respond." Or maybe I'll do that another day :(
13:44:19 <quchen> handuel: Works for me!
13:44:29 <quchen> Direct link to the book: http://book.realworldhaskell.org/read/
14:03:07 * hackagebot Nomyx-Web 0.5.0 - Web gui for Nomyx  http://hackage.haskell.org/package/Nomyx-Web-0.5.0 (CorentinDupont)
14:03:09 * hackagebot Nomyx-Language 0.5.0 - Language to express rules for Nomic  http://hackage.haskell.org/package/Nomyx-Language-0.5.0 (CorentinDupont)
14:03:11 * hackagebot Nomyx-Core 0.5.0 - A Nomic game in haskell  http://hackage.haskell.org/package/Nomyx-Core-0.5.0 (CorentinDupont)
14:03:13 * hackagebot Nomyx 0.5.0 - A Nomic game in haskell  http://hackage.haskell.org/package/Nomyx-0.5.0 (CorentinDupont)
14:03:18 <Dugar> I solved euler problem #4, but stylistically, it just feels wrong. Is there a better way to structure my code? https://dpaste.de/Wbx7
14:03:35 <handuel> quchen: Sorry, I found that link by myself and was reading so didn't see the message. Thanks for the help. book.realworldhaskell.org seems to work just not realworldhaskell.org
14:04:44 <hpc> i would give (*) <$> [100..999] <*> [100..999] a name, probably "products"
14:06:01 <hpc> also you might be able to get more performance from map show . reverse . sort rather than reverse . map show . sort
14:06:14 <hpc> maaaybe
14:06:30 <hpc> other than that it's pretty solid
14:07:12 <Dugar> It's ok to just chain 20 functions together like that?
14:07:17 <hpc> sure
14:07:25 <solarus> I guess you could remove the `map show' and `read' all together if you just did `filter (is_palindrome . show)'
14:07:25 <Dugar> were I doing this in javascript, I'd split it up into 20 steps
14:07:33 <hpc> oh, you should probably use (.) instead of ($) btw
14:07:45 <hpc> f $ g $ x = f . g $ x
14:08:00 <hpc> but the latter is preferred because it has nicer syntactic properties
14:08:12 <droo> any ETA on when crystal weed will be amortized?
14:08:12 <hpc> f $ g $ x parses as f $ (g $ x)
14:08:24 <hpc> f . g $ x parses as (f . g) $ x
14:08:39 <hpc> which becomes convenient for pointlessness
14:09:15 <Dugar> It seems like a lot of the time, I could use either, and I don't know which to choose then
14:09:29 <Dugar> but you're saying to always favor . if there's a choice?
14:09:53 <hpc> not always, there's a very fuzzy sort of logic to it
14:10:09 <hpc> but it sort of ends up being "look like what it is"
14:10:17 <hpc> and (.) is function composition, where ($) is function application
14:11:21 <hpc> you'll get a better handle over time for which one is appropriate
14:12:43 <hpc> anyway it's not what i would consider a real problem, because anyone who looks at your code is going to know what it does in 3 seconds
14:13:13 <hpc> which is ultimately what coding style is supposed to do ;)
14:13:19 <shoerain> 1. is `cabal sandbox init` supposed to take ~5 minutes? 2. is it building ghc every time? 3. am I missing something? I'm using this as a reference: coldwa.st/e/blog/2013-08-20-Cabal-sandbox.html
14:14:58 <bitemyapp> bos: sorry to bug you, but the realworldhaskell site is down. Who admins it?
14:15:26 <hpc> shoerain: i haven't used sandboxes but i doubt it's supposed to take that long
14:15:33 <quchen> 1. No, cabal sandbox init just creates some empty database files, if even that. 2. No, GHC isn't compiled by Cabal at all
14:15:35 <lovefp> has any one successfully cabal installed directory on win7 ?
14:16:02 <shoerain> I could show you the output of it; it's fairly long
14:16:23 <quchen> Of cabal sandbox init? Sure, paste it online
14:16:23 <merijn> "cabal sandbox init" takes like 1-2 seconds here
14:16:26 <quchen> @where paste
14:16:26 <lambdabot> Haskell pastebin: http://lpaste.net/
14:16:34 <hpc> lovefp: considering it's part of the platform, quite likely yes ;)
14:16:46 <shoerain> yeah i got it; well there's a lot of "Compiling" going on
14:16:54 <hpc> lovefp: can you paste your issue? someone who uses windows might know how to fix your issue
14:17:07 <quchen> There shouldn't be any compilation when initializing the sandbox.
14:17:59 <luvfp> hpc, unfortunately i can't follow this because if I do cabal install directory it fails
14:18:08 <luvfp> saying it needs MingW or Cygwin
14:19:25 <glguy_> Dugar: Don't forget about list comprehensions. They can be nice for stuff like this: last [ n | x <- [100..999], y <- [x..999], let n = x*y, isPalendrome (show n) ]
14:19:35 <luvfp> I do have cygwin.  and if i try it in a cygwin shell window, it says configure: WARNING: unrecognized options: --with-compiler, --with-gcc and it cannot find the sources
14:19:53 <luvfp> configure: error: cannot find sources (include/HsDirectory.h) in /cygdrive/c/Program Files (x86)/pythonxy/swig or ..
14:20:30 <Dugar> I like that way glguy
14:21:27 <shoerain> okay clearly I didn't mean 'cabal sandbox init', but rather further commands, like 'cabal install snap'
14:21:41 <quchen> Oh. Well that installs snap.
14:21:58 <quchen> And all dependencies. From source. So yes, that step can take long.
14:22:23 <quchen> You can build in parallel with the -jN flag using N threads, which speeds things up significantly.
14:22:28 <shoerain> I guess it does it everytime? if i wipe away the sandbox and re-create it, same amount of compilations?
14:22:38 <quchen> Sure, that's the point of a sandbox.
14:22:39 <shoerain> quchen: like `cabal install snap -j4`?
14:22:58 <quchen> Yes. I'm not sure whether the -j has to be before the snap, but other than that that's the command.
14:23:05 <shoerain> quchen: well not being familiar with haskell, i figured certain things can be cached
14:23:09 * hackagebot recaptcha 0.1.0.2 - Functions for using the reCAPTCHA service in web applications.  http://hackage.haskell.org/package/recaptcha-0.1.0.2 (JohnMacFarlane)
14:23:30 <quchen> You can also not use sandboxes of course, and use the global package DB. But then you might get version issues.
14:23:42 <quchen> You can also share one sandbox between multiple different projects. I think your link talks about that as well.
14:23:50 <quchen> (that one, http://coldwa.st/e/blog/2013-08-20-Cabal-sandbox.html)
14:25:34 <bahamas> what web framework do people prefer, yesod or snap?
14:27:04 <quchen> or Happstack. There's also the very lightweight Scotty.
14:27:48 <hpc> happstack is good for doing complex stuff
14:30:31 <bahamas> so the answer to my question is "yes" :)
14:30:59 <Dugar> I like my code much better now guys. Thanks for the help
14:34:50 <migimunz> I just spent 15 minutes figuring out a syntax error that turned out to be a function name indented less (though still indented) then the end of 'let'. Is it a common practice to insert a newline after a multi-line let expression for this reason?
14:36:53 <kadoban> migimunz: I don't think so.
14:38:11 * hackagebot zeromq4-haskell 0.3.2 - Bindings to ZeroMQ 4.x  http://hackage.haskell.org/package/zeromq4-haskell-0.3.2 (ToralfWittner)
14:38:13 * hackagebot zeromq4-haskell 0.4 - Bindings to ZeroMQ 4.x  http://hackage.haskell.org/package/zeromq4-haskell-0.4 (ToralfWittner)
14:41:09 <cdk_> I'm trying to implement a k-d tree using GADTs and TypeFamilies to provide type-safe guarantees about which axis is used to divide the space. I end up with a redundant function in my Functor instance (and others). Is there a better way to implement this so that the Functor instance doesn't have 2 redundant (identical) versions of go? http://lpaste.net/101810
14:42:17 <cdk_> I'm using closed type families from GHC 7.8, so 7.6.* users wont be able to compile the snippet
14:43:12 * hackagebot postie 0.3.2.0 - SMTP server library to receive emails from within Haskell programs.  http://hackage.haskell.org/package/postie-0.3.2.0 (alexbiehl)
14:43:49 <glguy_> cdk_: You can use instance signatures to get access to the type variables for 'f' so you can write a type signature for "go" and use it once
14:44:24 <glguy_> cdk_: or you'll have to pass in 'f' to go or some other function so that you can give it a type signature
14:44:58 <Iceland_jack> cdk_: that may be the reason you commented out the types, but they're wrong
14:45:29 <cdk_> Iceland_jack: yes, those types don't type-check, but they give the right idea don't they?
14:45:37 <cdk_> glguy_: instance signatures?
14:46:45 <glguy_> cdk_: http://lpaste.net/101810
14:47:29 <glguy_> or instead you could have fmap = fmap' where fmap' :: ....
14:47:38 <glguy_> and not use the InstanceSigs extension
14:48:53 <glguy_> cdk_: Do you understand why you had to have two versions of go in our original code and why you couldn't uncomment the go or go' type-signatures?
14:48:55 <cdk_> glguy_: ah I see, I thought ScopedTypeVariables might be able to help here, but I wasn't sure how to work it out.
14:48:58 <cdk_> thanks!
14:49:44 <cdk_> yes, I needed two go's because they have different types, the same go couldn't recurse on a subtree because the type of the subtree has a different dimension
14:50:18 <cdk_> I have a fuzzy idea of why I couldn't uncomment the types
14:50:36 <glguy_> You couldn't uncomment type types because your functions didn't work for ALL 'a' and 'b'
14:50:39 <cdk_> basically the forall in the instance signature of fmap doesn't match with the foralls in go
14:50:46 <cdk_> yes
14:50:51 <glguy_> they only worked for the particular a and b of the provided 'f'
14:51:20 <glguy_> but you had to write the type signature because you were matching on a GADT and those can't be inferred to the general type on their own
14:52:13 <cdk_> i see
14:54:33 <glguy_> Well, it's not a GADT, but type families have similar restrictions
14:56:22 <glguy_> I'm not doing well, the problem is polymorphic recursion :)
14:58:24 <cdk_> glguy_: well you've been very helpful, could you explain the polymorphic recursion a bit more?
15:09:28 <lukasz__> hi, i was wondering...does anyone use haskell at work professionally? There does not seem to be many jobs in haskell...
15:10:40 <quchen> There are many people here that do, lukasz__. Probably not as many as you'd find coding C++ in a C++ channel though.
15:12:02 <quchen> Facebook hired one of the head developers of GHC. We all hope he osmotically makes people learn Haskell there.
15:12:06 <lukasz__> i am just curious. Haskell seems to be very interesting alternative for java, c++ etc... however, like i said i havent seen any job offerings in haskell yet
15:12:49 <thebnq> its useful to learn even if you don't use it =)
15:13:35 <quchen> They definitely exist. But public postings explicitly for Haskell programmers are somewhat rare, that's true.
15:13:46 <lukasz__> i am sure it is useful:) i already see mental progress instead of doing code in java which sometimes seems to be killing my brain cells;)
15:14:51 <lukasz__> ok, so there are some lucky people who do code in haskell and get money for it:) i am glad to hear that :)
15:15:12 <quchen> Some of the FPComplete staff is here, for example.
15:15:50 <quchen> They're doing a lot of commercial Haskell work, but I haven't seen them disclosing their clients. That would be quite interesting actually.
15:16:26 <geekosaur> not at all uncommon that they don't want to be disclosed so they can't be used as advertising
15:16:44 <geekosaur> I think only one of my employer's customers has given permission for their name to be used
15:17:02 <quchen> geekosaur: Are you FPComplete too?
15:17:04 <geekosaur> (not haskell related)
15:17:17 <geekosaur> nope
15:17:50 <quchen> Well you don't need to disclose the names, you could provide a generic description of the company.
15:18:01 <geekosaur> just mentioning because fpcomplete might not be allowed by their customers to name them
15:18:11 <quchen> Like "financial sector, more than 10 employees, > 100k sloc Haskell codebase"
15:18:17 <geekosaur> or to give enough information that someone else might be able to identify them (this can be tricky)
15:18:33 <quchen> That's why I picked the numbers that small above :-)
15:18:46 <quchen> Well, 100k sloc isn't *that* small. But you get the idea.
15:18:55 <geekosaur> sure biut there comes a point where you might as well not have said anything
15:19:06 <schell> in the docs of Web.Scotty.Trans it states "The functions in this module allow an arbitrary monad to be embedded in Scotty's monad transformer stack in order that Scotty be combined with other DSLs"
15:19:08 <schell> - does anyone have an example of that?
15:19:11 <geekosaur> or where saying it makes you sound stupid
15:19:50 <quchen> geekosaur: I see your point, but I wanna know anyway :>
15:20:26 <quchen> Oh yeah by the way we have this project running with RMS to port GNU to Haskell, sorry we couldn't disclose it earlier
15:20:48 <quchen> (RMS and non-disclosure in the same sentence, eeh, nevermind that one)
15:20:57 <geekosaur> :p
15:23:40 <hpc> wait, what?
15:23:57 <lukasz__> so in summary, there are some secret companies doing haskell...so... and you are not working in any if them....so... what are you using haskell for? Some scripting? Or just for fun in the meantime?
15:24:25 <merijn> Not even just some secret companies
15:24:37 <merijn> http://www.haskell.org/haskellwiki/Haskell_in_industry
15:24:53 <lukasz__> oh...i forgot about this site:)
15:25:20 <bernalex> lukasz__: we use haskell at work
15:25:20 <merijn> @quote Jafet research
15:25:20 <lambdabot> Jafet says: Haskell is an abstract research language used only in academia, education, banking, stock trading, circuit design, embedded systems, cryptography, operating systems research, bioinformatics, phone apps, and web services.
15:27:12 <lukasz__> ok, i agree with that. But i assume that most of the people here are not doing any of that....except for the academic reaserch (probably we have a lot of students on board ;-)...
15:28:03 <merijn> Why would you assume most people aren't doing that?
15:28:37 <merijn> Also, define most people. Are we talking channel regulars here or the hundreds inactive idlers?
15:29:16 <sipa> active channel regulars probably don't have time to do coding in between the irc chatting!
15:29:35 <hpc> except for edwardk
15:29:39 <hpc> he was born with nine hands
15:29:56 <lukasz__> ok, maybe "most people" are not a good expression...however if there are not so many job offerings in haskell...then i assume that a lot of people are not doing much of haskell at work
15:29:57 <sipa> some people are just natural born multithreaders
15:31:30 <merijn> lukasz__: Depends where you look for jobs, I agree that I almost never see haskell jobs on a job board. But I run into people hiring haskellers all the time
15:31:37 <merijn> For some value of all the time :p
15:32:28 <geekosaur> the situation with haskell is also complicated by the fact that many companies will hire people with haskell experience even if they have no intention of using haskell, because haskell programmers tend to be better at programming in general
15:32:54 <lukasz__> sounds reasonable
15:33:02 <quchen> I am also a non-professional gardener, non-professional mountain biker, and non-professional climber
15:33:15 <geekosaur> because understanding how to program in haskell teaches you good programming discipline that stands you in good stead in any language
15:33:44 <lukasz__> sounds like you are non-professional Leonardo DaVinci :)
15:33:48 <lukasz__> good for you:)
15:34:01 <quchen> Some people also code Haskell and give their executable .py names, and nobody notices. (This used to be an urban legend; it's not anymore)
15:34:36 <bernalex> the only company in my country I know about that want to hire haskell guys is my company... problem is we can't find anyone using haskell...
15:34:59 <heatsink> But does being a Haskell programmer indicate that you'll be unwilling to put up with Java?
15:35:48 <quchen> Personally not wanting to put up with Java indicates that you'll be unwilling to put up with Java.
15:36:21 <hpc> i could probably tolerate it if i got paid
15:36:24 <bernalex> who wouldn't want to use java? I hear it's getting unsigned ints now even.
15:36:39 <quchen> bernalex: No unsigned Integer jokes in #haskell please ;-P
15:36:40 <sipa> bernalex: which country?
15:36:50 <bernalex> sipa: Norway.
15:36:54 <Yaniel>  and java 8 adoption is going to be soooo great
15:37:08 <bahamas> merijn: where are the people that you meet hiring?
15:37:19 <Yaniel> well, I don't know about EE
15:37:30 <merijn> bahamas: Switzerland, US, UK
15:37:33 <merijn> Norway ;p
15:37:42 <merijn> Netherlands, Singapore
15:37:47 <bahamas> merijn: do they accept remote workers?
15:37:57 <merijn> bahamas: The US ones I've seen do
15:38:07 <bernalex> quchen: what if I do it on twitter and link it here: https://twitter.com/skramlife/status/448951671864180736
15:38:09 <bahamas> merijn: ah, yes. I've seen the job postings of the company in singapore
15:38:52 <bernalex> bahamas: we don't here. we're a startup. we kind of want to minimise all risk we have control over. =/
15:39:50 <bahamas> bernalex: it's too bad, but I can understand the need for more control
15:40:03 <bahamas> handling remote work is not easy
15:50:17 <yepyep> what is the haskell equivalent for uniqueness types for something such as IO on a file?
15:51:21 <merijn> yepyep: The IO monas *is* haskell's alternative to uniqueness types
15:52:02 <merijn> yepyep: The IO monad guarantees ordering of operations already, uniqueness types are just an alternative solution to that same problem
15:52:19 <merijn> (although I admit my understanding of uniqueness types is limited)
15:52:31 <yepyep> say i want to acquire an exclusive lock on a file i'm doing IO on
15:52:46 <yepyep> so that I have a guarantee of purity
15:53:27 <yepyep> i.e. couldn't two or more IO monads lead to side effects if they all were reading/writing to a file?
15:54:22 <merijn> yepyep: You'd have to lock the file using (for example) posix file locks
15:54:42 <merijn> yepyep: Uniqueness types can't really help you, because another process can write to that file just as easily
16:08:29 <joelteon> what do I use for a list with a type-level enforced size?
16:09:06 <hpc> tuple?
16:09:15 <joelteon> fair enough
16:10:03 <peddie> joelteon: do you want to enforce a particular size or have a safe 'head' function, or . . . ?  there's the HList library, for example
16:10:19 <joelteon> well it'll be a 16-tuple
16:10:22 <joelteon> maybe that's bad, maybe not
16:11:41 <kadoban> Sounds like it could get pretty clunky...guess it depends what operations you need to do on it
16:13:41 <DanielDiaz> joelteon: if you have a recent version of GHC, you can use type-level naturals to enforce numerical properties (like length of a list in your case)
16:33:00 <heatsink> joelteon: There's a storable-static-array package for static-length storable arrays and a tagged-list package for static-length lists
16:33:58 <heatsink> TaggedList doesn't use TypeNats though
16:37:48 <dibblego> http://lpaste.net/101781 does this exist anywhere?
16:41:39 * heatsink checks the associativity of <>
16:42:23 <johnw> heatsink: infixr 6
16:43:04 <heatsink> I meant dibblego's <> operator
16:43:23 <heatsink> it doesn't look associative to me so I'm expanding a <> b <> c on paper
16:43:32 <johnw> ah
16:46:01 <dibblego> I just added tests for associativity, which pass
16:46:41 <dibblego> oh wait, no I didn't
16:47:27 <monochrom> associativity is a beast to test
16:47:53 <heatsink> I get different expressions
16:48:49 <heatsink> (T f <> T g) <> T h = T $ \xs -> h $ g (f xs : xs) : xs
16:49:09 <heatsink> T f <> (T g <> T h) = T $ \xs -> h $ g (f xs : xs) : f xs : xs
16:49:17 <heatsink> Note the extra (f xs)
16:49:28 <dibblego> yes the associativity test fails
16:53:07 <ZettaBlade> is the pronounciation "ha-skull" or "ha-skell"?
16:53:36 <johnw> I say it like I would say "rascal"
16:53:50 <thebnq> for me, closer to the former
16:53:59 <thebnq> but still in the middle
16:54:44 <haasn> @tell roconnor Also, it seems like colour's performance is downright abyssmal; it was nearly unusable when I tried using it to convert an image file to a different color space; I had much, much better results calculating my own conversion matrix with hand-rolled code using hmatrix and using that everywhere. A few orders of magnitude at least. Maybe it would be possible to compute a â€œre-usableâ€
16:54:44 <lambdabot> Consider it noted.
16:54:46 <haasn> transformation in colour and use that to speed things up?
16:54:54 <watermind> a couple of pretty basic questions
16:56:28 <watermind> if you want to work with an array for read only purposes, consuming slices of info at a time, what do you use? good old Array?
16:56:47 <johnw> watermind: I'd build up a mutable vector and then "freeze" it
16:57:14 <johnw> in fact, conduit now has sinkVector for doing just that
16:57:37 <haasn> watermind: repa perhaps
16:57:47 <heatsink> You can use Data.Array, watermind
16:57:48 <haasn> I think it's good at slicing
16:57:49 <watermind> johnw: I'm completely out of the loop with regards to the whole conduit, pipes, lens thing
16:57:58 <johnw> well, they are _extremely_ useful
16:58:04 <heatsink> If you want arrays of numbers, use unboxed arrays
16:58:05 <watermind> haasn: repa?
16:58:18 <heatsink> repa is good for writing array traversals concisely
16:58:21 <johnw> are you familiar with how handy lazily evaluated lists can be for composition and partial processing?
16:58:25 <watermind> heatsink: that was what I had in mind... I know it's the basic solution
16:58:32 <watermind> johnw: yeap
16:58:40 <johnw> so, add in effects, and you have pipes/conduit
16:58:45 <watermind> johnw: right
16:58:58 <johnw> in a more principled way (i.e., in the type system) compared to lazy I/O
16:59:04 <heatsink> watermind: repa has good facilities for expressing lops in terms of transformations on array indices
16:59:09 <johnw> as for lens, watch SPJ's presentation on lens, it's brillian
16:59:11 <johnw> t
16:59:30 <watermind> heatsink: got to search for it
16:59:51 <Iceland_jack> johnw: That video seems to require you to log in now
16:59:52 <watermind> johnw: oh I only started watching edward's didn't know about SPJ's
17:00:10 <johnw> Iceland_jack: I have a copy, if you want
17:00:11 <heatsink> watermind: http://www.cse.unsw.edu.au/~keller/Papers/repa.pdf
17:00:21 <watermind> thanks!
17:00:22 <johnw> watermind: whatever you do, don't watch edwardk's first :)
17:00:41 <watermind> heatsink: oh!
17:00:52 <johnw> edwardk is like a bullion cube; dissolve him in the water of a thousand other tutorials for best flavor
17:00:56 <Iceland_jack> johnw: Yes please :)
17:01:13 <edwardk> =P
17:01:17 <greg`> lo
17:01:26 <watermind> johnw: what happened was that he started talking about comonads... my background is actually math, so then I started going deeper into comonads and ended up never watching the whole thing
17:01:30 <greg`> no data constructor for Writer?
17:01:34 <watermind> edwardk: hey :)
17:01:35 <edwardk> ^- tongue out to taste the cube
17:01:37 <greg`> solutions anyone?
17:01:42 <johnw> edwardk is how I improve at Haskell: by always reminding me of what I don't know yet
17:01:58 <edwardk> greg`: use 'writer' not Writer
17:02:07 <greg`> thanks
17:02:23 <edwardk> greg`: Writer w is just a type alias for WriterT w Identity
17:02:30 <edwardk> that was part of the big change in mtl 2
17:02:43 <greg`> ah ok
17:02:45 <johnw> Iceland_jack: getting it
17:02:50 <watermind> just one more question, and this is super basic but... I rarely do any kind of parsing... at all
17:02:54 <edwardk> on the plus side, we maintain half as many types, on the minus side you occasionally get these questons
17:03:02 <greg`> watermind: what was the talk you were watching?
17:03:17 <watermind> if you just want to parse a file with  2 ints per line, what's the easiest route? do you go full Parsec?
17:03:58 <watermind> greg`: I watched part o edwardk's talk on lens, but I got distracted with comonads and adjunctions ... need to finish watching it
17:04:01 <greg`> watermind: you could go regex
17:04:10 <heatsink> watermind: map (map read . words) . unlines
17:04:11 <acowley> watermind: I'd probably start with lines and words
17:04:28 <watermind> oh right I totally forgot about words!
17:04:30 <greg`> ah can someone put a link up to edwards talk
17:04:31 <watermind> and lines
17:05:00 <greg`> i think one of the best sites to learn lens is adit.io
17:05:07 <greg`> + parsec
17:05:14 <greg`> + Arrows
17:05:19 <greg`> + hxt
17:05:32 <watermind> so I was wondering why there wasn't something like  read_some :: Read a => String -> (Maybe a, String)
17:06:07 <watermind> greg`: https://www.youtube.com/watch?annotation_id=annotation_158204&feature=iv&hd=1&src_vid=Q7l56Ryy8H8&v=cefnmjtAolY
17:06:14 <greg`> thanks
17:07:40 <monochrom> watermind: see my http://www.vex.net/~trebla/haskell/reads.xhtml
17:08:13 <watermind> monochrom: thank!
17:08:15 <watermind> monochrom: thanks!
17:09:57 <watermind> monochrom: oh right
17:10:09 <watermind> totally forgot about that
17:17:29 <colDrMcBeardman> I'm not familiar with Reader but I'm using it because I have to pass around a data structure but I'm confused. I have a function that builds it from a file, so I'm stuck in IO monad.
17:17:29 <johnw> Iceland_jack: http://ftp.newartisans.com/pub/Lenses.mp4
17:17:37 <johnw> ^-- SPJ's presentation on Lenses
17:18:17 <Iceland_jack> Great! Thanks johnw :)
17:19:02 <johnw> I'll keep the link up, in case others want it in future
17:19:19 <johnw> (I say this to you, reading this IRC log 5 years from now)
17:19:38 <Iceland_jack> ((enjoy your hoverboard))
17:20:39 <colDrMcBeardman> Iceland_jack, relevant: http://www.youtube.com/watch?v=A4vE_vpkr90
17:23:25 <glguy> colDrMcBeardman: this might help http://lpaste.net/101818
17:23:43 <Luke> is it possible to run cabal as a function instead of a CLI?
17:23:45 <glguy> using Reader from "inside" IO
17:25:01 <colDrMcBeardman> glguy, I could use it from inside IO, but the "environment" I want to store into the Reader when I first create it has to call readFile
17:26:02 <colDrMcBeardman> I more or less know the functions I want to run in the reader, but I don't know what I have to do here... Reader IO Env? Reader SomethingElse (IO Env)
17:26:21 <colDrMcBeardman> I'm totally lost there, not that being unfamiliar with Reader is a good thing, either.
17:26:33 <glguy> colDrMcBeardman: Why don't you show us what you thought you wanted
17:26:33 <blipped> how long does it usually take to really be effectively coding in Haskell? I feel like everything else I do I can be making cool things in a week or two (Python, Ruby, Java, Php, C/C++ etc...) but I'm a week into Haskell and I probably couldn't code a bubble sort without looking things up.
17:27:07 <colDrMcBeardman> glguy, I'll try and do a minimal case as I can't share the code.
17:27:13 <glguy> great
17:30:29 <colDrMcBeardman> So, this is drastically simplified, but basically where I'm at now is this: buildDB = do ls <- lines <$> readFile "someFile"; let myMap = fromList (myParser ls); return Database {myMap}
17:30:43 <koala_man> blipped: Python, Ruby, Java, PHP, C/C++ are all more or less the same language. how long did it take you to manage bubblesort when you first started coding?
17:30:44 <colDrMcBeardman> so I get an IO Database, and I want to get that Database into a Reader.
17:31:28 <blipped> koala, I suppose quite awhile thinking back. Or at least to get to that conceptual point.
17:32:28 <colDrMcBeardman> glguy, in reality, Database contains three inner structures, but that is the jist of my problem. I have buildDB :: IO Database and want a Reader Something Something where one of those somethings is the Database.
17:33:13 <colDrMcBeardman> I will probably also be querying the reader from IO, in case that's relevant.
17:33:33 <glguy> What does it mean to be querying the reader from IO?
17:35:17 <glguy> colDrMcBeardman: http://lpaste.net/101818
17:35:30 <glguy> colDrMcBeardman: Is that similar to what you're doing?
17:37:14 <colDrMcBeardman> glguy, :\ my inability to understand Reader is a hindrance here. It
17:37:19 <colDrMcBeardman> 's not really like that paste
17:37:54 <glguy> colDrMcBeardman: In that case why are you trying to use Reader?
17:39:27 <koala_man> blipped: try an algorithm more suited to immutable lists, like heapsort or quicksort
17:42:38 <colDrMcBeardman> glguy, I'm making a more full-fledged paste that will probably help, just a moment.
17:43:39 <blipped> it's not the algorithm that's the problem, just the understanding of how I'd implement it. Going through LYAH at the moment and it was going well until I got to currying, folding, etc... If I look at it long enough it makes sense, but feels so unintuitive at first. Just feeling like I'm coming up against a wall at the moment. Perhaps I'm not used to that when it comes to coding :/
17:47:36 <colDrMcBeardman> glguy, http://lpaste.net/101820
17:47:41 <greg`> haskell is a long road to travel
17:48:02 <colDrMcBeardman> greg`, indeed, but the journey seems worth it.
17:48:08 <Sculptor> but is it worth it
17:48:16 <Sculptor> ah, it seems?
17:48:21 <nisstyre> colDrMcBeardman: your paste confuses me
17:48:26 <zRecursive> Of course
17:48:30 <colDrMcBeardman> nisstyre, I'm confused, too.
17:48:55 <nisstyre> colDrMcBeardman: for starters it looks like you meant return $ someComputation row
17:49:04 <nisstyre> that might aid in deconfusing the code
17:49:09 <colDrMcBeardman> yes.
17:49:17 <glguy> colDrMcBeardman: http://lpaste.net/101820
17:49:25 <glguy> colDrMcBeardman: is that the kind of function you need?
17:49:26 <colDrMcBeardman> although.. I'm not even sure that function is what I want.
17:49:32 <nisstyre> not sure what someComputation signifies though
17:49:56 <nisstyre> your main function is wrong because it doesn't return IO a
17:50:12 <colDrMcBeardman> nisstyre, you did see the comment about all hope being lost.
17:50:24 <zRecursive> sure
17:50:41 <glguy> colDrMcBeardman: return isn't a keyword like in C, it's just another function
17:50:56 <glguy> so you'd need: return (someComputation row)
17:50:57 <nisstyre> yes, that should be made abundandtly clear
17:50:57 <zRecursive> :t return
17:50:58 <lambdabot> Monad m => a -> m a
17:50:59 <glguy> and of course other fixes
17:51:04 <colDrMcBeardman> glguy, perhaps that's what I need; I'm still confused how I get the Database into a Reader.
17:51:19 <colDrMcBeardman> glguy, I am aware, I just typed that vaguely into the paste.
17:51:23 <glguy> colDrMcBeardman: you "get it in" with the runReader function
17:51:28 <glguy> :t runReader
17:51:29 <lambdabot> Reader r a -> r -> a
17:51:46 <zRecursive> @unmtl ReaderT r a
17:51:46 <lambdabot> Plugin `unmtl' failed with: `ReaderT r a' is not applied to enough arguments, giving `/\A. r -> a A'
17:51:48 <colDrMcBeardman> the datatype, buildDB and lookup are all I have at the moment.
17:52:35 <colDrMcBeardman> glguy, so what I'm looking for is probably a ReaderT Database (IO a)?
17:52:57 <zRecursive> @unmtl ReaderT r m a
17:52:58 <lambdabot> r -> m a
17:53:08 <colDrMcBeardman> and then buildDB should use runReader?
17:53:14 <glguy> colDrMcBeardman: http://lpaste.net/101820
17:53:22 <glguy> colDrMcBeardman: getting warmer?
17:54:10 <colDrMcBeardman> yes.
17:54:59 <colDrMcBeardman> although I fail to see how this is supposed to reduce the code in my particular case as opposed to, say, passing around the Database...
17:55:34 <glguy> colDrMcBeardman: In this very simple case it doesn't help
17:56:06 <glguy> It just encapsulates the pattern of passing an unchanging argument to a set of functions
17:56:23 <glguy> You could just as well manually pass around the 'db' value yourself and get the same effect
17:56:41 <colDrMcBeardman> glguy, I can always refactor it later, I suppose.
17:57:01 <nisstyre> glguy: maybe a better name for the Reader monad would be the Environment monad
17:57:11 <nisstyre> or maybe that would be even more confusing
17:57:39 <colDrMcBeardman> nisstyre, that's what I have been conceptualizing it as. because there is a chance I may need the Database elsewhere and it is quite expensive to create.
17:58:08 <glguy> nisstyre: This isn't going to help, but Control.Comonad.Trans.Env has data EnvT e w a = EnvT e (w a)
17:58:25 <steamboat> hey folks, I'm trying to compile a program for profiling, but ghc complains about not having a profiling package for lens...
17:58:25 <steamboat> >> Perhaps you haven't installed the profiling libraries for package `lens-4.1.2'?
17:58:25 <steamboat> any advice on how I could go about acquiring the right packages?
17:58:48 <colDrMcBeardman> steamboat, you need to configure cabal to do library profiling and rebuild.
17:59:06 <glguy> that's it for me, good luck, colDrMcBeardman  :)
17:59:22 <colDrMcBeardman> maybe just cabal install lens --enable-library-profiling is all you need.
17:59:35 <colDrMcBeardman> thanks glguy
18:00:08 <colDrMcBeardman> steamboat, you may find, however, that you need more than just lens's profiling libraries
18:00:43 <stolaruk> I started to read the RWH chapter on Parsec. I'm curious how relevant this chapter is now. If I want to learn about parsing libraries in Haskell, is this a good place to start? Is there some other library I should learn about instead?
18:01:06 <colDrMcBeardman> stolaruk, I think it's still quite relevant.
18:01:24 <steamboat> colDrMcBeardman: I'll try that now, and hope it goes well. Thanks
18:01:46 <colDrMcBeardman> you can also learn some things from the attoparsec tutorials, but those libraries are not the same in usage.
18:01:59 <stolaruk> how are they different?
18:02:17 <edwardk> steamboat: the easiest way i know is to change your ~/.cabal/config to turn on profiling for everything, nuke ~/.ghc/x86_whatever and reinstall from scratch. you need profiling all the way down
18:03:09 <colDrMcBeardman> stolaruk, attoparsec generally doesn't keep track of as much as parsec does so it can be faster. the architecture is therefore different, meaning that the user API is not compatible with Parsec and isn't used exactly the same way.
18:03:18 <Luke> how do you guys handle dependencies / cabal for Shake files?
18:03:50 <colDrMcBeardman> edwardk, that confirms my suspicion, sadly.
18:03:50 <stolaruk> Can I use Parsec with Text?
18:05:31 <pyon> Is there IO action that prints an empty line?
18:05:34 <pyon> there any*
18:05:55 <pyon> I mean, basically, putStrLn "", but shorter (for golfing).
18:06:16 <stolaruk> pyon: Why not write your own
18:06:31 <Iceland_jack> :t putChar '\n'
18:06:31 <lambdabot> IO ()
18:06:36 <stolaruk> That ^^
18:06:58 <pyon> Thanks!
18:07:17 <chrisdotcode> hey gues, does `(|>) = flip (.)` do what I think it will do (and I think it'll change the order of function composition)?
18:07:18 <Fuuzetsu> > :t let nl = putStrLn "" in nl
18:07:19 <colDrMcBeardman> stolaruk, try using the OverloadedStrings extension
18:07:19 <lambdabot>  <hint>:1:1: parse error on input `:'
18:07:22 <Fuuzetsu> :t let nl = putStrLn "" in nl
18:07:23 <lambdabot> IO ()
18:07:23 <pyon> stolaruk: Well, writing my own would probably be long... which is counterproductive when golfing.
18:07:35 <colDrMcBeardman> that will save you from lots of pack/unpack boilerplate.
18:07:38 <stolaruk> Iceland_jack: I figured out how to use MonadicQuickCheck to write property tests to test code in my monad transformer stack
18:07:40 <Fuuzetsu> (I think putChar '\n' isn't portable for the \r\n world)
18:07:51 <Iceland_jack> stolaruk: Great!
18:07:54 <chrisdotcode> hey *guys, does `(|>) = flip (.)` do what I think it will do (and I think it'll change the order of function composition)?
18:08:08 <Iceland_jack> stolaruk: Do you find it okay to work with?
18:08:11 <stolaruk> pyon: What do you mean by golfing
18:08:19 <colDrMcBeardman> although again, that's why Parsec is slower than attoparsec. However, I've been using Parsec to do up a text file of several megabytes and it hasn't been an issue for me.
18:08:29 <stolaruk> Iceland_jack: So far yeah very easy, after I figured out how to get it to typecheck. That was the biggest hurdle
18:08:29 <Fuuzetsu> chrisdotcode: why not think about it a bit?
18:08:32 <Fuuzetsu> :t flip (.)
18:08:33 <lambdabot> (a -> b) -> (b -> c) -> a -> c
18:08:48 <chrisdotcode> Fuuzetsu: I thought about it, but I want to run a brain exercise without doing any code :)
18:09:04 <colDrMcBeardman> stolaruk, golfing is trying to get your code pared down to be minimal as possible; from the fact that in golf you try to get the lowest score at each hole you can (i.e., fewest swings)
18:09:19 <stolaruk> even at the cost of readability?
18:09:19 <Iceland_jack> stolaruk: Of course preferrably you'd like to write your transformer bits in a pure way (even though you intend to use them with an impure stack)
18:09:21 <pyon> stolaruk: Trying to write the shortest program (in terms of number of bytes) that solves a given, usually trivial, task.
18:09:26 <colDrMcBeardman> stolaruk, depends, but yes, usually
18:09:28 <chrisdotcode> Fuuzetsu: I'm trying to (theoretically) do something like: `f |> g` instead of `g . f`
18:09:38 <chrisdotcode> and flip (.) seems right to me
18:09:39 <Iceland_jack> *preferably
18:09:52 <thebnq> chrisdotcode: are you an f# programmer :b
18:09:55 <stolaruk> Iceland_jack: I try to write code outside the stack and lift it in, but find this can only be done so much
18:10:17 <Fuuzetsu> chrisdotcode: sure, but I'm not clear on what you're expecting from us. Do you want us to tell you if it will do what you want? Isn't that just the same as trying it out?
18:10:25 <Iceland_jack> stolaruk: You shouldn't have to lift it in if you write your constraints correctly
18:10:43 <zRecursive> :t lift
18:10:44 <lambdabot> (Monad m, MonadTrans t) => m a -> t m a
18:10:46 <chrisdotcode> thebnq: heh, well no, but I stole it from f# and livescript :)
18:10:59 <chrisdotcode> Fuuzetsu: when you put it that way, it makes it seem a bit silly to ask >_>
18:11:00 <Fuuzetsu> chrisdotcode: I think you could use >>> from Arrow to compose functions that way
18:11:19 <stolaruk> Iceland_jack: Maybe I misunderstood, what do you mean by writing transformer bits in a pure way
18:11:27 <chrisdotcode> Fuuzetsu: oh, that looks pretty, too. maybe even prettier
18:11:33 <chrisdotcode> :t (>>>)
18:11:34 <lambdabot> Category cat => cat a b -> cat b c -> cat a c
18:11:39 <Fuuzetsu> > (+5) >>> (*2) $ 7
18:11:40 <lambdabot>  24
18:12:01 <chrisdotcode> oh, that's awesome!
18:12:16 <pyon> "print = putStrLn . show", right?
18:12:19 <Fuuzetsu> just replace â€˜catâ€™ by â€˜->â€™ and make it infix and you get the same signature
18:12:57 <stolaruk> > (+) <$> (+5) <*> (*2) $ 7
18:12:57 <blipped> I can't load any modules from the ghci or by compiling with ghc <filename>
18:12:58 <lambdabot>  26
18:13:03 <zRecursive> :k (->)
18:13:04 <lambdabot> * -> * -> *
18:13:08 <chrisdotcode> Fuuzetsu: well thanks for making me feel a bit silly, but helping nontheless :)
18:13:13 <Fuuzetsu> np
18:13:19 <Nightson> hey guys
18:13:23 <Nightson> i'm working with happy
18:13:36 <Nightson> when I do happy.y it works fine
18:13:45 <Nightson> file.y*
18:13:55 <Nightson> then I try ghc file.hs and it gives the following errors:
18:14:28 <colDrMcBeardman> woah
18:14:31 <Nightson> Not in scope: data constructor `Int'
18:14:40 <Nightson> someone has an idea why this happens?
18:14:42 <Iceland_jack> stolaruk: aah, I don't have the mtl but it looks something like
18:14:42 <Iceland_jack>     foo :: MonadState m a => m a
18:14:42 <Iceland_jack>     foo = ...
18:14:42 <Iceland_jack> which is a pure function that works well with any MonadState, whether it uses IO or not
18:15:12 <geekosaur> Nightson, you used a type as a data constructor somewhere. we'd have to see the code
18:15:15 <colDrMcBeardman> Nightson, example of what you're doing to make that happen?
18:15:59 <blipped> Nightson, just a net split. Common for IRC really.
18:16:05 <stolaruk> :t execState
18:16:05 <lambdabot> State s a -> s -> s
18:16:12 <stolaruk> :t execStateT
18:16:12 <lambdabot> Monad m => StateT s m a -> s -> m s
18:16:25 <stolaruk> :t runStateT
18:16:26 <lambdabot> StateT s m a -> s -> m (a, s)
18:16:49 <geekosaur> @paste
18:16:49 <lambdabot> Haskell pastebin: http://lpaste.net/
18:16:59 <geekosaur> Nightson, use the pastebin ^^
18:19:34 <haasn> johnw: where can I find SPJ's presentation on lens?
18:19:56 <Iceland_jack> <johnw> Iceland_jack: http://ftp.newartisans.com/pub/Lenses.mp4
18:19:56 <Iceland_jack> <johnw> ^-- SPJ's presentation on Lenses
18:19:56 <Iceland_jack>  
18:20:05 <stolaruk> colDrMcBeardman: (FYI) From SO: "Since Parsec 3.1.2 support of Data.Text is built-in!" http://stackoverflow.com/questions/4064532/using-parsec-with-data-text
18:20:05 <haasn> Iceland_jack: thanks
18:21:22 <colDrMcBeardman> stolaruk, ok, groovus.
18:22:06 <stolaruk> When will the next great Haskell bk be out? :)
18:22:50 <prooftechnique> stolaruk: What language?
18:23:04 <prooftechnique> We're translating a Russian book right no
18:23:06 <prooftechnique> *now
18:23:07 <stolaruk> In my case either English or Japanese
18:23:19 <stolaruk> into English?
18:23:22 <prooftechnique> Yeah
18:23:31 <stolaruk> oh nice, what's the bk like?
18:23:54 <prooftechnique> The title is roughly "Haskell for Regular Programmers"
18:24:05 <prooftechnique> It's from the perspective of C++ programmers, mostly
18:24:33 <stolaruk> Is it an introductory type thing then?
18:25:43 <prooftechnique> A chunk of it, yeah
18:26:03 <stolaruk> Sounds interesting, Haskell and C++ are worlds apart
18:26:33 <prooftechnique> It also covers a lot of practical stuff. Dealing with cabal, using tools like hlint, all that
18:26:44 <stolaruk> nice
18:30:47 <colDrMcBeardman> stolaruk, but... but... C++ has type classes! I mean... concepts! I mean... was going to have....
18:31:55 <stolaruk> I haven't written a line of C++ (or read one) in 20 years
18:32:45 <colDrMcBeardman> stolaruk, I recently kicked C to the curb in favor of haskell.
18:33:10 <colDrMcBeardman> I flirted with C++ for a time, but... ugh. so much bullshit to remember. like more rope to shoot yourself in the foot with than plain C.
18:33:31 <stolaruk> you can always FFI to interface w/ your C code
18:33:36 <stolaruk> not that I know much about it at all
18:33:56 <StoneCypher> lol switching to haskell to escape remembering things :)
18:34:23 <stolaruk> there is a lot to remember with Haskell indeed
18:35:32 <heatsink> But it's actually meaningful.
18:35:45 <StoneCypher> so is c++
18:36:32 <heatsink> In C++, existential quantification and universal quantification look totally different
18:36:43 <heatsink> In Haskell, they're just differences in where the types are bound
18:37:14 <stolaruk> C++ = very low lvl, Haskell = very high lvl
18:37:25 <heatsink> Function pointers and virtual functions look totally different, but they do almost the same thing
18:37:29 <heatsink> Haskell just has functions
18:37:38 <colDrMcBeardman> StoneCypher, Haskell is a big language, but most of it is sugar.
18:38:13 <StoneCypher> colDrMcBeardman: c++ is a far smaller language than haskell.
18:38:23 <heatsink> There's lots of irritating junk like that in C++
18:38:30 <colDrMcBeardman> you can get by only working with small subset. also, the things you pick up learning more of haskell aren't things like rvalue references
18:38:33 <StoneCypher> there's a lot of irritating junk in haskell too
18:38:33 <heatsink> Also, no one really knows how overloading works in C++
18:38:39 <StoneCypher> yes they do
18:38:41 <StoneCypher> you might not
18:38:50 <stolaruk> Which one has the bigger spec? C++, no?
18:38:59 <StoneCypher> stolaruk: i don't know.  i've never read the haskell spec.
18:39:12 <colDrMcBeardman> StoneCypher, but core is smaller than C++. and that's fundamentally what the big haskell boils down to.
18:39:13 <stolaruk> The C++ spec is notorious for being very long
18:39:34 <StoneCypher> stolaruk: that's because it's specific, not because the language is large.  if you're arguing against a language because of rumors you've heard, you'll get taken about as seriously as that has earned.
18:39:55 <StoneCypher> colDrMcBeardman: if that's true i will be shocket
18:39:57 <StoneCypher> shocked*
18:40:08 <StoneCypher> colDrMcBeardman: i speak north of 50 languages and c++ is almost the smallest language i know.
18:40:11 <stolaruk> Actually I'm not arguing for or against anything, just throwing out some observations
18:40:19 <StoneCypher> stolaruk: rumors aren't observations, though
18:40:34 <stolaruk> what have I said thats rumor?
18:40:36 <prooftechnique> StoneCypher: 50? Yeesh.
18:40:47 <prooftechnique> I thought 10 or 12 was a lot.
18:41:06 <blipped> I enjoyed coding in C++ 10 years ago. It was a nice language then, but times change.
18:42:22 <haasn> â€œOr, as Edward would write it:â€ <- needs more unsafeCoerce and .#
18:42:56 <thebnq> C++ being small out of 50 languages ... i'm not sure about this in any possible way
18:43:47 <blipped> North of 50 languges? proficiently?
18:43:47 <StoneCypher> thebnq: ok
18:43:56 <StoneCypher> blipped: people argue over proficiency.
18:44:10 <StoneCypher> blipped: i would call myself proficient in around 15-20 of them depending on where the line is, and adequate in the rest.
18:44:40 <blipped> Huh
18:45:02 * StoneCypher quite enjoys c++, but it doesn't really apply very well to the stuff he's doing lately
18:45:08 <thebnq> StoneCypher: in reference to "the core being small", have you seen ghc's core data type
18:45:14 <prooftechnique> I tutor people in Python despite not really knowing Python. I know how to solve problems they want to solve and the rest is just looking up "how do I do that here?"
18:45:15 <thebnq> https://ghc.haskell.org/trac/ghc/wiki/Commentary/Compiler/CoreSynType
18:45:15 <blipped> Not sure I could name 50 languages off the top of my head.
18:45:21 <StoneCypher> thebnq: no.  note that i have carefully not taken any position on haskell.
18:45:26 <colDrMcBeardman> StoneCypher, Core's syntax has about 20 productions. A yacc file I found describing C++ has nearly 200.
18:45:30 <prooftechnique> I wrote an expert system in Python, but that's the only nontrivial thing
18:45:37 <StoneCypher> colDrMcBeardman: well, some yacc author isn't very good at what they do.
18:45:39 <blipped> prooftechnique, that's how I learned Python.
18:45:58 <chrisdotcode> hey guys, does (.) have the same precedence as actual function application? or does function application have precedence 10?
18:46:00 <blipped> helping friends figure things out as well as one-off progrs.
18:46:00 <colDrMcBeardman> StoneCypher, ok, do you have one available that's less than that?
18:46:00 <StoneCypher> prooftechnique: in the sense of cyc?
18:46:19 <StoneCypher> colDrMcBeardman: nope, i don't really focus on yacc grammars as a way to evaluate languages.  i don't believe that that's a valid metric.
18:46:20 <prooftechnique> StoneCypher: Specifically, I implemented EMYCIN
18:46:31 <StoneCypher> prooftechnique: sorry, i don't know what that is
18:46:43 <thebnq> do you have a better metric to offer
18:46:44 <prooftechnique> StoneCypher: https://en.wikipedia.org/wiki/Mycin
18:46:59 <prooftechnique> It's a medical expert system
18:47:06 <StoneCypher> thebnq: not that i can apply to haskell.  i'm quite ignorant of haskell.  i've written now three entire functions.
18:47:07 <prooftechnique> But I guess you could repurpose it for whatever
18:47:22 <StoneCypher> prooftechnique: well it's a good name for a system like that :)
18:47:38 <prooftechnique> chrisdotcode: Function application has the highest precedence
18:48:10 <thebnq> StoneCypher: why not, what is it? i'm just curious how you say C++ is small
18:48:14 <stolaruk> chrisdotcode: Try :info (.) in ghci
18:48:30 <heatsink> StoneCypher: How do you judge the language size?  My copy of the C++11 draft spec is 1334 pages.  The language and semantics (without the library) takes about 400 pages.
18:48:32 <colDrMcBeardman> StoneCypher, if a grammar has fewer productions, it has fewer constructs built in. hence it is smaller.
18:48:52 <StoneCypher> thebnq: by observing that the language was carefully kept small by design, and observing how many things are in it.  you could read Moo if you wanted insight, but i'm not able to reduce this to a glib soundbite.  you have to actually know c++ to understand its simplicity.
18:49:02 <StoneCypher> colDrMcBeardman: yes, that's the metric i don't believe in.
18:49:27 <thebnq> well i can't argue with observation
18:49:27 <stolaruk> chrisdotcode: I don't know how to fully answer your question tho
18:49:29 <StoneCypher> heatsink: so, one language might write one line to explain an array, and another two pages to make complexity guarantees and requirements
18:49:46 <StoneCypher> heatsink: i don't find those two to be meaningfully different in complexity as a language; just that one is vague bullshit and the other is well defined
18:49:53 <StoneCypher> heatsink: obviously haskell isn't vague bullshit
18:49:56 <prooftechnique> colDrMcBeardman: I'm beginning to think you're not a colonel, a doctor, *nor* a son of a bear! :D
18:49:56 <colDrMcBeardman> StoneCypher, would you agree lambda calculus is smaller than C++?
18:50:01 <prooftechnique> *beardman
18:50:25 <StoneCypher> colDrMcBeardman: by the time you argue that haskell is nothing but the lambda calculus, i make an apology to alonzo church and stop paying attention
18:50:41 <StoneCypher> colDrMcBeardman: but yes, of course c++ is larger than something it contains.
18:50:46 <prooftechnique> colDrMcBeardman: Plain lambda calculus is also much less expressive than C++, though, no?
18:51:15 <chrisdotcode> prooftechnique, stolaruk: well I know that (.) has precedence 9, from ghc, but does function application have precedence 9, or a higher precedence than composition?
18:51:36 <heatsink> I don't see what point you are making about precision of the spec, StoneCypher
18:51:47 <stolaruk> chrisdotcode: That's what I don't know. :(
18:51:50 <prooftechnique> chrisdotcode: It has higher precedence than any infix operator
18:51:58 <prooftechnique> Always
18:52:07 <chrisdotcode> prooftechnique: okay, great. that was the answer I was looking for :)
18:52:12 <prooftechnique> :)
18:52:12 <thebnq> stolaruk: i just think your priorties and view point on what a "language" is, is just vastly different
18:52:20 <thebnq> StoneCypher: ^ oops
18:52:24 <stolaruk> np
18:52:54 <colDrMcBeardman> I don't think StoneCypher knows about Core, honestly.
18:53:11 <prooftechnique> thebnq, colDrMcBeardman, StoneCypher: This might be a better discussion for #haskell-blah, at this stage
18:53:23 <StoneCypher> heatsink: That's why i don't consider the length of the spec a useful measurement
18:53:24 <colDrMcBeardman> prooftechnique, I didn't know that was a thing.
18:53:24 <prooftechnique> You may also get more active participants
18:53:26 <StoneCypher> prooftechnique: okay
18:53:42 <StoneCypher> colDrMcBeardman: hooray, you discovered what i've been saying outright.
18:53:58 <StoneCypher> prooftechnique: i'm not going to go join another channel to get blubbed at though :)
18:53:59 <athan> is a monoid a semigroup (or vise versa?)
18:54:01 <athan> ?
18:54:22 <ion> A monoid is a semigroup with an identity element.
18:54:30 <athan> Ahhhhhhhhhh
18:54:43 <athan> so a semigroup is only an associative binary operator?
18:54:50 <haasn> â€œAnd I think even, Edward in his library put an INLINE pragma on it, so it willâ€ <- amazing how I can just take this out of context without mentioning what function he's talking about and it'll remain as true as before
18:54:50 <athan> That may or may not have an identity?
18:54:50 <prooftechnique> StoneCypher: Just mentioning it to keep things on point :D No worries.
18:54:53 <athan> hmmm
18:55:20 <prooftechnique> athan: Specifically, a semigroup is a magma where the operator is associative, yes
18:55:35 <athan> magma?
18:55:54 <prooftechnique> A set together with a binary operato
18:55:57 <prooftechnique> *operator
18:55:58 <ion> http://upload.wikimedia.org/wikipedia/commons/d/d0/Magma_to_group2.svg
18:56:00 <athan> AWESOME
18:56:04 <athan> wow
18:56:11 <athan> many math
18:56:11 <prooftechnique> ion: One of my favorite diagrams
18:56:13 <athan> such awesome
18:56:42 <athan> hmm
18:56:44 <thebnq> wow haven't heard of the left side, makes sense
18:56:52 <prooftechnique> I don't actually know any useful properties about magmas, but I assume there are some :D
18:56:55 <athan> what does it mean for something to be invertable?
18:57:03 <athan> Like you could recreate it's inputs?
18:57:07 <thebnq> a*b = identity
18:57:12 <prooftechnique> ^
18:57:15 <thebnq> b is a's inverse
18:57:16 <prooftechnique> Inverse element
18:57:35 <triliyn> prooftechnique: free magmas are trees, which is kind of interesting
18:57:37 <athan> OH
18:57:43 <prooftechnique> triliyn: Oh, that's neat
18:57:46 <prooftechnique> Good to know
18:57:47 <athan> so then there's a pivot point for the elements
18:57:52 <athan> they all have their dopplegangar
18:57:58 <prooftechnique> triliyn: Any reference for that? I'd enjoy the read
18:58:01 <athan> hmm
18:58:22 <athan> what about divisability?
18:58:23 <triliyn> I didn't read it anywhere, just saw it in this channel and it seemed true
18:58:33 <athan> you could recreate an element out of others?
18:58:41 <athan> er...
18:58:43 <prooftechnique> triliyn: Fair enough :D
18:59:06 <prooftechnique> athan: Divisibility means there's some meaningful notion of division
18:59:24 <athan> prooftechnique: can you give an example?
18:59:34 <prooftechnique> So given a = b * c, you have that a / b = c
18:59:36 <triliyn> Divisibility without identity is hard for me to imagine
18:59:46 <athan> ahhhhhhhh
18:59:56 <heatsink> StoneCypher: It is relevant because C++ has lots of little parts that need to be defined.  The spec lists the implicit conversions that occur in various situations.  It lists the various things that + can do depending on its operand types.  It lists the various ways that overloaded functions are resolved to a definition.  It lists the implicitly defined member functions and what they do.
18:59:58 <prooftechnique> triliyn: Yeah, it's pretty weird
19:00:32 <heatsink> StoneCypher:   Haskell has a smaller and more orthogonal set of language features, so there isn't the need for the spec to enumerate so many cases.
19:00:44 <athan> so for something more obfuscating, like addition, one would have to make record of every expression or something within the data elements in question
19:00:49 <athan> this is good stuff...
19:01:03 <colDrMcBeardman> StoneCypher, Haskell gets boiled down to Core, which has only variables, literals, let, case statements, application and types. all of the high-level stuff in haskell proper is just shorthand.
19:01:17 <prooftechnique> Hey, -blah with that :P
19:01:33 <athan> how would you make a quasigroup out of a single operator and a set, though?
19:01:37 <prooftechnique> Though I guess it is more germane to Haskell at this exact second :D
19:01:42 <athan> hmmm
19:01:49 <colDrMcBeardman> prooftechnique, just explaining what core is.
19:01:54 <colDrMcBeardman> not trying to troll.
19:02:00 <prooftechnique> No worries :)
19:02:12 <athan> it was mentioned earlier that a free magma is a tree
19:02:23 <athan> is that just a parametric magma?
19:02:27 <triliyn> Isn't core just GHC's particular implementation of the haskell standard?
19:02:45 <prooftechnique> athan: It just means that you imbue your operator with a notion of division that maintains closure
19:02:52 <prooftechnique> I'm trying to think of a good example
19:03:04 <colDrMcBeardman> triliyn, it's sort of like an intermediate language. it is a stripped-down haskell
19:03:04 <athan> addition that keeps a record of every addition lol
19:03:18 <heatsink> triliyn, Core is GHC's internal language
19:03:19 <athan> so you could backtrace the result to it's inputs
19:03:29 <athan> that would be a good notion of divisability, right?
19:03:35 <prooftechnique> Oh, I guess Latin squares are the multiplication tables of quasigroups
19:03:41 <heatsink> triliyn, the standard actually defines the meaning of some syntax in terms of translation to other syntax though
19:03:43 <haasn> aaw
19:03:53 <triliyn> colDrMcBeardman: right, but I mean, the language standard itself doesn't say anything about core, I thought
19:03:54 <athan> o.O
19:03:56 <colDrMcBeardman> IOW, everything gets pared down to that simple "core" of haskell and then compiled.
19:03:58 <triliyn> heatsink: hmmm, okay
19:04:02 <heatsink> so the phrasing sort of suggests a core language
19:04:21 <colDrMcBeardman> take if ... then ... else, for example.
19:04:22 <prooftechnique> heatsink: Throw in a dash of Z-encoding for good measure :D
19:04:43 <colDrMcBeardman> that's defined to be just case ... of True -> ...; False -> ... (abusing notation here)
19:05:31 <colDrMcBeardman> so if you have case, you don't need if to be in the core. IIRC pattern matching is also done in terms of case.
19:06:49 <athan> is there a special term for a commutative magma?
19:07:10 <AshyIsMe> "liquid mag-mah"
19:07:14 <athan> ha
19:07:36 <thebnq> probably so obscure that "commutative magma" is fine
19:07:46 <athan> yeah I agree
19:07:47 <prooftechnique> I don't know if you can actually do that at the magma level. I think you need at least a semigroup
19:07:57 <athan> hmm
19:08:04 <athan> you're right
19:08:12 <athan> commutativity is a superset of associativity
19:08:29 <athan> well
19:08:30 <athan> actually idk
19:08:45 <athan> associativity gives you the freedom of nesting the parameters however you want
19:08:59 <athan> while commutativity gives you the freedom of swapping them around
19:09:10 <triliyn> It's possible to have commutativity without associativity, but it's not as powerful as it is with associativity
19:09:22 <athan> so would the swap constitute a re-nest?
19:09:35 <prooftechnique> Oh, actually
19:09:38 <prooftechnique> Look at this
19:09:39 <triliyn> The swap is not a re-nest
19:09:41 <prooftechnique> https://en.wikipedia.org/wiki/Example_of_a_commutative_non-associative_magma
19:09:45 <thebnq> i don't see why not though, you have MxM->M, just means the table is == its transpose
19:09:47 <prooftechnique> How oddly specific
19:09:51 <triliyn> Floating point operations are commutative but not associative
19:10:04 <thebnq> woah thats a cool example
19:10:05 <prooftechnique> Oh, right, RPS
19:10:09 <prooftechnique> I forgot about that
19:10:50 <triliyn> huh, RPS is a nice example too
19:10:51 <prooftechnique> The link was purple for me, so I guess I was wondering the same thing at some point
19:10:53 <triliyn> I didn't think of that
19:10:55 <athan> triliyn: which ones specifically?
19:11:20 <athan> triliyn: I could see addition and mult, but those are also associative
19:11:44 <triliyn> athan: addition and multiplication are normally associative, but with floating point numbers they are not
19:11:47 <prooftechnique> ^
19:11:56 <prooftechnique> Floating points are messy
19:12:00 <athan> ?
19:12:04 <athan> hmm
19:12:25 <athan> i could see the associativity with decimal. I'm guessing there's a gap for floats?
19:12:39 <athan> or some kind of non-consistent results
19:12:49 <triliyn> Floating point addition accumulates errors if you add things with wildly differing magnitudes
19:12:50 <athan> okay, so here's my trip
19:13:02 <triliyn> By re-nesting, you can change the magnitude gap, and this changes the result
19:13:08 <athan> commutativity feels like it need associativity
19:13:26 <prooftechnique> Decimal is usually defined in a more restricted fashion than float, so it behaves better
19:13:26 <athan> because if you swap inputs, it also swaps the nesting
19:13:36 <athan> Ah!
19:13:52 <athan> because the precision is arbitrary
19:13:59 <athan> and there's room for incompleteness
19:14:00 <athan> wow
19:14:04 <athan> that's awesome, thank you!
19:14:19 <triliyn> athan: if you have (a*b)*c, you can swap it as long as you don't change the nesting
19:14:23 <prooftechnique> Right. That's why normally you use a decimal type for important stuff like financial calculations, but for graphical stuff it's more important to be memory efficient
19:14:28 <triliyn> c*(a*b), (b*a)*c
19:14:45 <triliyn> But not a*(c*b)
19:14:45 <athan> ahhhhhhhhhhhhhhhhhh
19:14:56 <athan> triliyn: now that makes perfect sense, thank you!
19:15:17 <athan> interesting
19:15:23 <athan> i have this idea
19:15:29 <prooftechnique> athan: If you know rock-paper-scissors, that wiki page may give you a good intuition, as well
19:15:33 <athan> that's probably lofty and putrid in the eyes of the great
19:15:37 <athan> but here it is lol
19:15:57 <athan> commutative semigroups have O(1) time and space complexity
19:16:12 <athan> ahhhhhhh
19:16:13 <athan> hmm
19:17:43 <prooftechnique> athan: I don't know what you mean by that
19:18:07 <athan> actually let me rephrase
19:18:34 <athan> a commutative semigroup is n-ary
19:18:41 <athan> where the arguments are independant
19:18:44 <prooftechnique> This whole discussion has led me to discover a fun new book to read, The Algebraic Theory of Semigroups
19:18:49 <athan> it lifts the binary operation into a scalable one
19:19:06 <athan> Heck yeah! I'll check it out!
19:19:40 <sjy> what does it mean to "lift a binop into a scalable one"?
19:19:55 <athan> well...
19:20:11 <athan> (a -> a -> a) -> ([a] -> a)
19:20:21 <roboguy_> you mean it can take advantage of some kind of parallelism, potentially?
19:20:25 <athan> yes
19:20:29 <thebnq> semigroup reduction .. forms a monoid ? :]
19:20:34 <athan> yes!
19:20:54 <prooftechnique> Hmm
19:21:02 <athan> see what I mean?
19:21:05 <athan> it's delicious
19:21:08 <triliyn> athan: without an identity element, it needs to be (a -> a -> a) -> ([a] -> a -> a)
19:21:16 <athan> how come?
19:21:21 <cdk_> I have a type family F x where F (F (F x)) ~ x, how can I convince GHC of this? It complains that it cannot construct the recursive type t ~ F (F (F t)))
19:21:41 <athan> i don't think the identity is pivotal for the parallelism
19:21:46 <triliyn> if you get an empty list, you need something to return in that case
19:21:50 <athan> as the bin op is both associative and commutative
19:22:05 <athan> ahhhhhhhh
19:22:08 <triliyn> So if there's no predefined element you can return, you need an extra argument for the base case
19:22:10 <triliyn> Like foldr
19:22:11 <prooftechnique> athan: Keep in mind that a binop has to be closed over the set
19:22:18 <athan> hmm
19:22:20 <athan> interesting
19:22:36 <athan> by closed, you mean covers all possabilities, correct?
19:22:53 <sjy> if a, b \in X, then a*b \in X
19:23:00 <prooftechnique> ^
19:23:07 <athan> i see how the monoid is necessary now, triliyn
19:23:17 <athan> nothing + nothing = 0
19:23:20 <roboguy_> there's a surprising amount of haskell discussion in the stackoverflow c++ lounge
19:23:35 <prooftechnique> roboguy_: Link?
19:23:36 <monochrom> haha
19:23:51 <roboguy_> prooftechnique: if you scroll up, http://chat.stackoverflow.com/rooms/10/loungec
19:24:49 <prooftechnique> Thanks
19:25:33 <prooftechnique> Oh, god, that's a really good pun
19:25:36 <sjy> athan: "covering all possibilities" is not sufficient, eg. subtraction can be applied to any two positive numbers, but the result is not necessarily a positive number
19:25:55 <prooftechnique> "Everyone is glaring at each other. The hot tub is full of suspicion. Why did I get in the J'accuzzi?"
19:26:07 <roboguy_> prooftechnique: haha, yeah I liked that too
19:26:08 <athan> sjy: endomorphism?
19:26:38 <athan> sjy: but, fully comprehensive of the inputs, and that the morphism returns the same set?
19:26:42 <StoneCypher> prooftechnique: very nice.
19:27:11 <orzo> I'm trying to use package binary-0.5.1.1 and I need to write something like this:  getWhile :: (Word8 -> Bool) -> Get ByteString
19:27:36 <orzo> I'm also interested if its possible with latest binary package 0.7.1.0
19:27:38 <sjy> athan: kind of, except a closed binary operation is (X, X) -> X so not technically an endomorphism i think
19:27:51 <athan> ahhh
19:27:52 <athan> hmm
19:27:57 <athan> interesting
19:28:08 <athan> would morphisms be sensative to arity?
19:28:10 <dibblego> endo is a ~> a
19:28:12 <athan> or could you fake it?
19:28:22 <athan> hmm
19:28:25 <orzo> anybody good with Data.Binary and can help me with that question?
19:28:36 <athan> interesting
19:29:21 <prooftechnique> @hoogle (Word8 -> Bool) -> Get ByteString
19:29:21 <lambdabot> Did you mean: (Word8 -> Bool) -> RequestMethod
19:29:21 <lambdabot> Data.ByteString dropWhile :: (Word8 -> Bool) -> ByteString -> ByteString
19:29:21 <lambdabot> Data.ByteString.Lazy dropWhile :: (Word8 -> Bool) -> ByteString -> ByteString
19:29:37 <orzo> I dont want to force all of the input into memory
19:29:44 <prooftechnique> Hmm
19:31:49 <orzo> I cant use dropWhile because i'm trying ot create an instance of Data.Binary and i need to write the get method
19:33:21 <orzo> getLazyByteStringNul seems close to what i need, but it frustratingly only works with (==0) as the predicate
19:34:13 <zq> what's the idiomatic way to cabal update a package?
19:34:25 <zq> i gotta have my new qc
19:35:41 <prooftechnique> zq: ghc-pkg unregister, cabal intall
19:35:44 <prooftechnique> *install
19:35:49 <zq> oh ok
19:35:55 <prooftechnique> And also hope nothing breaks
19:35:59 <zq> seriously?
19:36:06 <athan> haha
19:36:11 <athan> nixos
19:36:14 <zq> no, serious
19:36:15 <zq> ly
19:36:27 <prooftechnique> It'll warn you if something would break
19:36:38 <zq> i used cabal0uninstall
19:36:46 <athan> hmm
19:36:59 <zq> which presumably ghc-unreges and deletes the modules themselves too
19:38:14 <prooftechnique> I would expect so
19:38:18 <glguy_> I use a tool I wrote that detects outdated packages, recursively unregisters packages, and detects if you have more than one version of a package installed
19:38:26 <glguy_> for doing my cabal updates
19:38:31 <prooftechnique> glguy_: Got a link?
19:38:42 <glguy_> https://github.com/glguy/GhcPkgUtils
19:38:50 <prooftechnique> Oh, I have that starred :)
19:38:57 <prooftechnique> I thought it sounded familiar
19:39:30 <glguy_> My work flow is basically: cabal update; GhcPkgUtils outdated; GhcPkgUtils unregister that-one-package; cabal install -j that-one-package
19:43:34 <orzo> I see runGetIncremental could be useful if i was using the latest bytestring package
19:43:47 <prooftechnique> orzo: Are you restricted to an older one?
19:43:51 <orzo> yea
19:44:07 <orzo> targeting ghc as packaged for debian stable
19:44:12 <orzo> ancient i guess
19:44:44 <prooftechnique> Ah, I see
20:04:17 <Redz> is there a shortcut function for if-then-else in the standard lib?
20:05:10 <Iceland_jack> bool is recent
20:05:10 <dmj`> Redz: there's when and unless, but I wouldn't call those shortcut functions
20:06:33 <thebnq> what do you mean by shortcut, if-then-else- is pretty short
20:07:42 <dibblego> there is if'
20:08:09 <dibblego> and {-# LANGUAGE RebindableSyntax #-}
20:08:34 <dmj`> there is multi-way-if lang pragma
20:08:35 <Iceland_jack> Redz: â€˜boolâ€™ recently got added to Data.Bool in base
20:08:37 <Redz> where is if' defined?
20:08:48 <Iceland_jack> if' is not a standard function
20:09:05 <Iceland_jack>     bool :: a -> a -> Bool -> a
20:09:05 <Iceland_jack>     bool f _ False = f
20:09:05 <Iceland_jack>     bool _ t True  = t
20:09:11 <dmj`> Redz: are you mean looking for a ternary operator?
20:09:26 <dmj`> are you looking*
20:09:44 <ion> iceland_jack: Ooh, nice.
20:10:14 <Redz> dmj`: more or less. just  Bool -> a -> a -> a so that i can curry it.
20:10:29 <Redz> or apply partial.
20:10:46 <roboguy_> is it true that Church encodings can sometimes be particularly efficient implementations of certain data structures?
20:19:09 <athan> roboguy_ you mean like peano numerals?
20:19:21 <athan> roboguy_ oh hell, haven't checked that wiki in a while haha
20:19:23 <roboguy_> athan: that would be one example
20:19:33 <prooftechnique> Iceland_jack: I hadn't seen that
20:19:35 <prooftechnique> Neat
20:20:11 <erisco> are there any extensions to scope record label names? that is, so two records can share the same label name
20:20:15 <athan> roboguy_: I could see it as an abstract binary
20:20:55 <athan> roboguy_: you're working directly with the thunks, so if you can shortcut the objects or make the translations take up the least amount of space/time, I could see that
20:21:00 <prooftechnique> erisco: OverloadedRecordFields
20:21:14 <joelteon> :t readMaybe
20:21:16 <lambdabot> Not in scope: `readMaybe'
20:21:17 <roboguy_> athan: Tekmo's article mentions that attoparsec uses them for efficiency
20:21:27 <athan> roboguy_: I feel like it's more of a design perspective than a direct problem solving one
20:21:47 <athan> roboguy_: Hmm, I'll need to read that then!
20:21:56 <prooftechnique> erisco: Though I think it's only in HEAD right now
20:22:07 <roboguy_> athan: well, he doesn't go into much more detail about that particular topic (which is why I was wondering) http://www.haskellforall.com/2014/03/introductions-to-advanced-haskell-topics.html
20:22:52 <prooftechnique> erisco: Actually, now that I look, it's only in one particular branch of a particular fork. Apparently it's supposed to be merged in after 7.8 is released, though
20:23:00 <roboguy_> I also seem to remember that Church encoding is a special case of some other more general kind of encoding (either that, or they are identical for things like naturals but they differ for more complex stuff), but I can't remember what it's called
20:24:23 <erisco> prooftechnique, shame
20:30:19 <erisco> I like the row type idea
20:31:03 <prooftechnique> erisco: You could play with Ur. I think it does row types
20:31:13 <prooftechnique> Maybe Ermine, too
20:31:19 <erisco> I am using Haskell but thanks
20:32:28 <sjy> roboguy_: the church encoding of the natural numbers is reminiscent of the definition under the peano axioms, is that what you were thinking of?
20:35:41 <orzo> if i define the same algebraic data type in two different modules, can I unsafeCoerce them to each other?
20:36:05 <prooftechnique> orzo: Are they the same type?
20:36:27 <prooftechnique> You could just export it from one of them and import it into the other.
20:36:34 <shachaf> There are many things to worry about, such as whether the modules are compiled with the same optimization level (and other flags like -funpack-strict-fields).
20:36:39 <orzo> well, i want to konw if it works
20:37:04 <orzo> i was using it as a way to get access to internals of a module that does not export them
20:37:14 <orzo> probably bad, but i dont want a lecture heh
20:37:23 <orzo> i just want to know if it in fact works
20:38:18 <prooftechnique> I mean, it'll typecheck. I'm not really sure if it'll do what you want, though
20:38:22 <shachaf> There aren't particularly strong guarantees.
20:38:46 <shachaf> If you compile with the same flags I think it'll probably work in practice.
20:38:48 <roboguy_> sjy: no. church encoding is basically a representation of the peano axioms
20:38:55 <shachaf> You can try it out.
20:38:57 <roboguy_> well, church encoding natural numbers
20:39:00 <orzo> hm
20:39:05 <prooftechnique> orzo: Give it a shot, write a blog post about it :)
20:39:21 <orzo> i can put conditional compilation to restrict the compiler too
20:39:51 <roboguy_> I wish google had some kind of inequality thing that let me search: "church encoding" "(* != church) encoding"
20:41:10 <pavonia> What would that do?
20:41:11 <roboguy_> scott encoding, I think that's it
20:41:32 <chrisdotcode> I'm writing a handler using Yesod. Can anybody tell me if the non-do notation form is sufficiently harder to understand than the do-notation one? I'm trying to write the one that's the most clear. http://lpaste.net/101825
20:41:42 <roboguy_> pavonia: match a page that has the phrase "church encoding" and a two word phrase that begins with a word that isn't "church" and ends with the word "encoding"
20:41:42 <chrisdotcode> (it's only 4 lines)
20:42:28 <Galactic> if I have something like ["something","very","another","ok"]  how can I patter match it so that I get the first two elements... I am thinking something like:  myFuc [[a],[b]]   but I don't know how to put the rest of the list.
20:42:43 <prooftechnique> chrisdotcode: I think the one liner is totally readable
20:43:08 <prooftechnique> You could even get away with returnJSON <$>, probably :D
20:43:08 <erisco> > let x:y:rest = ["a","b","c","d"] in (x,y) -- Galactic
20:43:10 <lambdabot>  ("a","b")
20:43:14 <chrisdotcode> prooftechnique: I'm only a haskell intermediate, and I want to make sure that 1. I'm using good style and 2. I'll be able to read it two weeks from now
20:43:26 <indigo> Is there no difference between yesod init and yesod init --bare? :<
20:43:32 <chrisdotcode> prooftechnique: (and I tried that, but <$> has higher precedence than >>=, so it would happen first)
20:43:33 <prooftechnique> chrisdotcode: Is the pipeline clear to you? That's pretty much key
20:43:41 <prooftechnique> Oh, right
20:43:51 <chrisdotcode> prooftechnique: yeah, it's clear to me. my primary issue is whether or not it's good style
20:43:54 <dwcook> Galactic, for future reference, [x] in a pattern refers to a list with exactly one element, which will be bound to x
20:44:25 <prooftechnique> chrisdotcode: Not knowing Yesod very well, I think it's fairly clear what it does
20:44:29 <chrisdotcode> indigo:  I have no idea; I was under the impression that --bare doesn't include the full scaffold?
20:44:37 <prooftechnique> It's certainly no *less* clear than the do notation
20:44:42 <Galactic> o wow ty erisco I thought that  (x:y:xs) or something symilar was only for list that looked like [1,2,3,4,5]  and not list of lists
20:44:57 <indigo> chrisdotcode: I was under that impression as well; however, it seems that there's no difference in running yesod init with or without --bare.
20:44:58 <dwcook> Galactic, x and y can be any type at all, lists or no
20:45:06 <Galactic> I see
20:45:09 <chrisdotcode> prooftechnique: okay, cool. just being paranoid about style. thanks then :)
20:45:12 <dwcook> It's completely transparent to the pattern whether the elements are lists
20:45:25 <chrisdotcode> indigo: really? I think that's really odd
20:45:38 <indigo> Same here. :|
20:46:16 <prooftechnique> chrisdotcode: It'd probably be worthwhile to write it with do-notation for consistency reasons (your other handlers all use it, or something), but for plain readability it's AOK
20:46:33 <dx25> prooftechnique, in case you care, i finally got that copy/paste thing to work right.  http://pastebin.com/R6ZSXhNp
20:46:45 <prooftechnique> dx25: Oh, awesome!
20:47:16 <chrisdotcode> prooftechnique: heh, I'm actually trying to use a little do-notation as possible.
20:47:20 <erisco> chrisdotcode, I do not think either is better than the other
20:47:38 <dx25> prooftechnique, but the foldl' confuses me.  i'm ignoring the first parameter in that lambda.  there must be a better way to write it.
20:47:56 <chrisdotcode> erisco: I'm more concerned about good style. because I don't mind the one-liner, but I want to make sure that another haskeller would be comfortable reading it
20:48:46 <prooftechnique> :t const
20:48:47 <lambdabot> a -> b -> a
20:48:51 <prooftechnique> ^ dx25
20:49:01 <prooftechnique> > const 4 25
20:49:02 <lambdabot>  4
20:49:09 <prooftechnique> > const [1..10] undefind
20:49:10 <lambdabot>  Not in scope: `undefind'
20:49:10 <lambdabot>  Perhaps you meant `undefined' (imported from Prelude)
20:49:11 <prooftechnique> > const [1..10] undefined
20:49:12 <lambdabot>  [1,2,3,4,5,6,7,8,9,10]
20:49:34 <erisco> :t curry fst
20:49:35 <lambdabot> c -> b -> c
20:49:57 <indigo> chrisdotcode: Never mind; it seems that --bare did not do what I think it does. It just creates the project in the current directory instead of creating a new directory for it.
20:50:14 <chrisdotcode> indigo: oh, so --bare doesn't ask you the questions?
20:50:21 <chrisdotcode> or it just drops all the files in the current dir?
20:50:25 <indigo> Nono, --bare still asks you the questions.
20:50:28 <dx25> hmm... ok
20:50:30 <indigo> And then drops all the files in the current dir.
20:50:47 <indigo> Otherwise it drops the files in the project name dir.
20:51:19 <chrisdotcode> well, I guess that's another correct usage of the word bare, but maybe --currentdir would be better?
20:52:09 <indigo> Either that, or some documentation.
20:52:50 <indigo> I might look into making some...
20:54:29 <prooftechnique> dx25: Specifically, you can remove nn and just put const before the lambda
20:54:57 <prooftechnique> :t f n = foldl' (const (\d -> min n (f d + div n d))) n $ divisors n
20:54:58 <lambdabot> parse error on input `='
20:55:09 <prooftechnique> :t \f n -> foldl' (const (\d -> min n (f d + div n d))) n $ divisors n
20:55:09 <lambdabot> Not in scope: `divisors'
20:55:10 <orzo> is there a smiple way to see what ghc set __GLASGOW_HASKELL__ to?
20:55:22 <prooftechnique> :t \f n -> foldl' (const (\d -> min n (f d + div n d))) n
20:55:23 <lambdabot> Integral a => (a -> a) -> a -> [a] -> a
20:55:25 <prooftechnique> There
20:55:49 <dx25> :t \f n -> foldl' (const (\d -> min n (f d + div n d))) n $ divisors n
20:55:50 <lambdabot> Not in scope: `divisors'
20:56:04 <Javran> wow, I just realise "uncurry fst" and "uncurry snd" are true and false in church encoding O_O
20:56:10 <Tekmo> Yep
20:56:23 <dx25> divisors x = [n | n <- [1..x-1], mod x n == 0]
20:56:31 <ion> @tell acowley I really enjoyed your Haskell robotics talk. Thanks.
20:56:31 <lambdabot> Consider it noted.
20:56:39 <Tekmo> In fact, that's exactly how you would translate true and false to a cartesian closed category
20:56:41 <dx25> :t \f divisors x = [n | n <- [1..x-1], mod x n == 0]
20:56:42 <lambdabot> parse error on input `='
20:56:51 <dx25> :(
20:56:55 <prooftechnique> dx25: Better to try it in your file
20:57:11 <prooftechnique> For now, try it, see that it works, then we can talk about why
20:57:15 <dx25> k
20:57:57 <Tekmo> dx25: You want to use `->` instead of `=`
20:58:35 <Javran> Tekmo: I thought previously `flip` as negation and `const` as true, then false should be `flip const`
20:58:46 <Tekmo> :t \x -> [n | n <- [1..x-1], mod x n == 0]
20:58:46 <lambdabot> Integral t => t -> [t]
20:59:13 <Tekmo> Javran: I have a simpler rule for deducing the shape of the church encoding
20:59:22 <Javran> "uncurry fst" and "uncurry snd" look cool
20:59:26 <Tekmo> Javran: Just pretend that you are writing a function that substitutes for all constructors
20:59:35 <dx25> Tekmo, why?
20:59:47 <prooftechnique> dx25: He means for dealing with lambdabot
20:59:51 <dx25> oh ok
21:00:01 <Tekmo> dx25: You could also do:
21:00:21 <Tekmo> dx25: let divisors x = [n | n <- [1..x-1], mod x n == 0] in divisors 6
21:00:55 <Tekmo> Javran: For example, `foldr cons nil` just replaces all `(:)` constructors in a list with `cons` and replaces the `[]` constructor with `nil`
21:01:25 <Tekmo> Javran: You can think of `foldr` as just converting a list to its church encoding
21:01:44 <prooftechnique> That's a neat way to think of it
21:02:14 <Tekmo> Javran: Similarly, `maybe just nothing` replaces the `Just` constructor with `just` and replaces `Nothing` with `Nothing`
21:02:24 <Tekmo> Javran: *replaces `Nothing` with `nothing`
21:02:37 <Tekmo> Javran: So `maybe` just converts a `Maybe` to its church encoding
21:02:45 <Tekmo> Same thing for `either`
21:02:58 <Tekmo> Javran: The two arguments to `either` are how to substitute `Left` and `Right`
21:03:08 <Javran> Tekmo: I see
21:03:10 <Tekmo> Javran: And `either` Church encodes `Either`s
21:03:17 <prooftechnique> dx25: Whenever you're ready, I'll describe why you need to do it this way to get rid of that extra term
21:03:32 <Tekmo> Javran: In fact, I will use this often as a naming convention when implementing church encoding
21:03:36 <Tekmo> Javran: For example
21:03:47 <Tekmo> Javran: false = \true_ false_ -> false_
21:03:55 <Tekmo> Javran: true = \true_ false_ -> true_
21:04:06 <Tekmo> Javran: nil = \cons_ nil_ -> nil_
21:04:07 <dx25> prooftechnique, yeah that seems to work.  i'm confused about what it was passing for nn -- the value sometimes equals n but sometimes didn't.
21:04:20 <Tekmo> Javran: cons a as = \cons_ nil_ -> cons_ a as
21:04:40 <Tekmo> Javran: three = \succ zero -> succ (succ (succ zero))
21:04:54 <prooftechnique> dx25: Okay, so let's look at the types
21:04:59 <Galactic> I am trying to take the first two strings in a list of strings and see if one string is a substring of the other: This is what I have tried [isInfixOf str2 str1 | let (str1:str2) = x  <- ["something","very","another","ok"]]
21:05:04 <prooftechnique> :t \n f -> (\nn d -> min n (f d + div n d))
21:05:05 <lambdabot> Integral a => a -> (a -> a) -> t -> a -> a
21:05:07 <Tekmo> Javran: In other words, I name each continuation after the constructor they are replacing
21:05:12 <prooftechnique> Note that t
21:05:29 <Galactic> all in one line: [isInfixOf str2 str1 | let (str1:str2) = x  <- ["something","very","another","ok"]]
21:05:32 <prooftechnique> :t \n f -> (\d -> min n (f d + div n d))
21:05:33 <lambdabot> Integral a => a -> (a -> a) -> a -> a
21:05:39 <prooftechnique> Here, the t is gone
21:05:42 <Tekmo> Javran: Actually, my cons example was wrong
21:05:53 <prooftechnique> :t foldl (\n f -> (\d -> min n (f d + div n d)))
21:05:54 <lambdabot>     Occurs check: cannot construct the infinite type: a0 = a0 -> a0
21:05:54 <lambdabot>     In the first argument of `min', namely `n'
21:05:54 <lambdabot>     In the expression: min n (f d + div n d)
21:06:04 <Tekmo> Javran: cons as = \cons _ nil_ -> cons a (as cons_ nil_)
21:06:21 <prooftechnique> Uh-oh, we can't do that, so we're stuck with the other one, but then we have this other term to come up with
21:06:56 <dx25> right
21:06:56 <prooftechnique> But by using const, we can say "I don't care what that second argument is, just get rid of it"
21:07:06 <Javran> Tekmo: what about \fst_ snd_ p_ -> fst_  and \fst_ snd_ p_ -> snd_ for pairs?
21:07:23 <prooftechnique> :t \n f -> const (\d -> min n (f d + div n d))
21:07:24 <lambdabot> Integral a => a -> (a -> a) -> b -> a -> a
21:07:47 <Tekmo> Javran: It would be: pair a b = \tuple -> tuple a b
21:07:48 <Javran> Tekmo: since lists are pairs
21:07:51 <prooftechnique> So now it has the same shape as the type with the extra term, but we're clear that we don't care about it
21:08:03 <prooftechnique> b has replaced t, in this case
21:08:03 <dx25> yeah that part makes sense.  but where is the extra term coming from?
21:08:18 <Javran> Tekmo: yep, "p_" as a "selector"
21:08:25 <Tekmo> Javran: Yeah, that's right
21:08:31 <dx25> i guess i need to read the definition of foldl'
21:09:26 <Tekmo> Javran: Note that there is a dual technique to church encoding
21:09:42 <Tekmo> Javran: Church encoding is one of two dual ways to encode recursion
21:10:15 <Javran> Tekmo: so what's the other way?
21:10:33 <Tekmo> Javran: To explain the other way, I just need to explain one other thing about Church encoding
21:10:59 <Javran> Tekmo: and what's the "dual"?
21:11:25 <Javran> for now, I find myself struggle to understand any co- stuffs ..
21:11:43 <Javran> except for contravariants :)
21:12:05 <roboguy_> Tekmo: is it scott encoding?
21:12:05 <Tekmo> So the idea is that you can encode recursive types as "fixed points" of a functors
21:12:09 <Tekmo> roboguy_: No
21:12:22 <Tekmo> So there are two ways to encode a fixed point of a functor
21:12:28 <Tekmo> One is known as the "least fixed point"
21:12:36 <orzo> prooftechnique, shachaf: the unsafeCoerce experiment is triggering segfaults.  I have the same LANGUAGE pragmas, but its hard to knw if the flags are the same.
21:12:41 <Tekmo> It basically means that you have a function of type:
21:12:50 <Javran> y combinator / or that Data.Function.fix ?
21:13:15 <Tekmo> (forall a . F a -> a) -> (forall b . LFix F b -> b)
21:13:36 <Tekmo> Oops, that type is wrong
21:13:39 <Tekmo> One second
21:14:00 <Tekmo> forall a . (F a -> a) -> (LFix F -> a)
21:14:08 <Tekmo> So think of `LFix F` as:
21:14:22 <Tekmo> F (F (F (...)))
21:14:28 <Tekmo> It's a finite chain of `F`s
21:15:01 <Tekmo> I think there is still a mistake in my type
21:15:04 <Javran> Tekmo: could you give me an example?
21:15:06 <Tekmo> But anyway, let me use a concrete example
21:15:11 <Tekmo> I'll find the mistake if I give the example
21:15:23 <Tekmo> So let's start from the type of `foldr`, with the arguments rearranged
21:15:48 <Javran> :t foldr
21:15:49 <lambdabot> (a -> b -> b) -> b -> [a] -> b
21:15:50 <Tekmo> Actually, keep the argument order the same
21:16:08 <Tekmo> So we can show that the type of `foldr` is "isomorphic" to:
21:16:43 <prooftechnique> orzo: Hmm. That sounds gross
21:17:01 <Tekmo> Here, let me use a simpler type for just a second
21:17:04 <prooftechnique> orzo: Any flag information in the cabal file? Or maybe a build log?
21:17:08 <Tekmo> Let's use the church encoding of `Either`
21:17:25 <Tekmo> type ChurchEither a b = forall r . (a -> r) -> (b -> r) -> r
21:17:38 <Tekmo> This type is "isomorphic" to:
21:17:56 <Tekmo> type ChurchEither a b = forall r . (Either a b -> r) -> r
21:18:17 <Tekmo> An easy way to prove the isomorphism is to use the correspondence between types and ordinary algebra
21:18:58 <Tekmo> The idea is that `a -> b` corresponds to `b^a`, `Either a b` corresponds to `a + b` and `(a, b)` corresponds to `(a * b)`
21:19:17 <Tekmo> So you can think of the first version of `ChurchEither` as being:
21:19:33 <Tekmo> (r^(r^b))^(r^a)
21:19:39 <Tekmo> You can then simplify that to:
21:19:48 <Tekmo> r^((r^b) * (r^a))
21:19:56 <Tekmo> And furhter simplify that to:
21:20:02 <Javran> umm...somehow mind blowing for me..
21:20:07 <Tekmo> r^(r^(a + b))
21:20:12 <Tekmo> Then convert that back to:
21:20:18 <Tekmo> (Either a b -> r) -> r
21:20:34 <roboguy_> I like to think about that algebraic representation as corresponding to the "number" of values that inhabit the type
21:20:44 <Tekmo> roboguy_: That's the correct intuition
21:21:03 <roboguy_> if there are |a| values in type a and |b| values in type b, then there are |b|^|a| possible functions a -> b
21:21:12 <orzo> prooftechnique: i sought out the cabal file and got ghc_options from that and passed them exactly (as much as i could...) and now it does not segfault.  Something is going wrong though, but maybe its just my own proramming mistake...
21:21:40 <Javran> why a -> b is corresponding to b^a .. I mean a and b get flipped?
21:21:45 <prooftechnique> Well, that's an improvement, anyway
21:21:57 <aji> we doing topology now?
21:22:05 <roboguy_> Javran: think about the number of possible functions {1,2} -> {a,b,c}
21:22:06 <aji> this is FP, stick to category theory, people
21:22:19 <Tekmo> Javran: Think of `a -> b` as a tuple of `b`s, one for each possible value of `a`
21:22:29 <Tekmo> Javran: For example:
21:22:38 <Tekmo> Javran: Bool -> a ~ (a, a) ~ a^2
21:22:59 <Tekmo> Note that `Bool ~ 2`
21:23:07 <Tekmo> Javran: Bool ~ Either () () ~ 1 + 1
21:23:15 <prooftechnique> aji: Homotopy Type Theory, yo
21:23:38 <aji> well i mean, like, R^N being the set of all functions from N->R
21:23:46 <aji> i learned about that in my topology class
21:24:13 <Tekmo> Javran: This post does a much better job of explaining it than me: http://chris-taylor.github.io/blog/2013/02/10/the-algebra-of-algebraic-data-types/
21:24:27 <roboguy_> aji: category theory generalizes that I think
21:24:28 <Javran> wait .. what does "Bool -> a ~ (a, a) ~ a^2" mean?
21:24:31 <roboguy_> (naturally)
21:24:32 <aji> probably
21:24:38 <aji> idk. i'm a tad drunk.
21:24:43 <aji> don't feel like googling about math atm
21:24:48 <roboguy_> Javran: ~ is type equivalence
21:24:57 <Tekmo> Javran: I'm being loose with notation
21:25:02 <Tekmo> Javran: Let me be ore precise
21:25:06 <ion> roboguy: Or equality?
21:25:09 <Javran> now I get it
21:25:11 <Tekmo> Javran: Let's define a function that computes the number of inhabitants of a type
21:25:16 <Tekmo> inhabitants :: Type -> Int
21:25:19 <roboguy_> ion: yeah
21:25:23 <Tekmo> inhabitants Bool = 2
21:25:35 <Tekmo> inhabitants (Either a b) = inhabitants a + inhabitants b
21:25:45 <Tekmo> inhabitants (a, b) = inhabitants a * inhabitants b
21:25:49 <Tekmo> inhabitants () = 1
21:25:53 <Tekmo> inhabitants Void = 0
21:26:02 <Javran> void??
21:26:06 <Tekmo> inhabitants (a -> b) = inhabitants b ^ inhabitants a
21:26:12 <Tekmo> Javran: data Void -- The empty type
21:26:15 <ion> javran: The definition: â€œdata Voidâ€.
21:26:18 <Tekmo> Javran: See the `void` package, which has this type
21:26:26 <Javran> ok
21:26:29 <Tekmo> Javran: It's a type with no valid constructors, so it's uninhabited
21:26:47 <Tekmo> Javran: So now I can be more precise
21:26:50 <Javran> just recall I saw that before somewhere..
21:27:16 <Tekmo> inhabitants (Bool -> a) = inhabitants a ^ inhabitants Bool = inhabitants a ^ 2
21:27:28 <Tekmo> inhabitants (a, a) = inhabitants a * inhabitants a = inhabitants a ^ 2
21:27:33 <Tekmo> So:
21:27:40 <Tekmo> inhabitants (Bool -> a) = inhabitants (a, a)
21:27:55 <Javran> could you give me some concrete example of this part: "inhabitants (a -> b) = inhabitants b ^ inhabitants a"?
21:28:23 <Javran> is (^) power function?
21:28:24 <roboguy_> Tekmo: is that at all related to the adjunction between (-> a) and (, a)?
21:28:28 <Tekmo> inhabitants (Bool -> ()) = inhabitants () ^ inhabitants Bool = 1 ^ 2 = 1
21:28:39 <Tekmo> roboguy_: No, it's unrelated
21:28:53 <Tekmo> Javran: Yes, `(^)` is the power function
21:28:58 * hackagebot HLearn-distributions 1.1.0.2 - Distributions for use with the HLearn library  http://hackage.haskell.org/package/HLearn-distributions-1.1.0.2 (MikeIzbicki)
21:29:37 <Tekmo> Javran: `inhabitants (Bool -> ()) = 1` tells us that there is only one function of type `Bool -> ()` that we can write
21:29:38 <shachaf> orzo: Are you compiling with the same optimization level?
21:29:47 <Tekmo> Javran: ... and that function is `\_ -> ()`
21:31:21 <Tekmo> Javran: In fact, we can replace `Bool` with any type and it's still true
21:31:25 <Javran> Tekmo: I see why a -> b is b^a now, it's just all possible relations from codomain to domain?
21:31:34 <Tekmo> Javran: That's correct
21:31:59 <orzo> shachaf: yes, and i found a my mistake, just a bug in my code, the coerce seems to be working.
21:31:59 <Tekmo> Javran: Let's do a non-trivial example
21:32:18 <Tekmo> Javran: inhabitants (Bool -> Bool) = inhabitants Bool ^ inhabitants Bool = 2 ^ 2 = 4
21:32:26 <prooftechnique> dx25: Anyway, to answer your question, this is way easier to see with typed holes, but essentially it comes down to the fact that foldl requires a function of two arguments
21:32:29 <Tekmo> Javran: That means that there are four unique functions we can write of type `Bool -> Bool`
21:32:33 <Tekmo> Javran: I'll enumerate them all
21:32:57 <Tekmo> Javran: f0 b = if b then True else True
21:33:04 <Tekmo> Javran: f1 b = if b then True else False
21:33:12 <Tekmo> Javran: f2 b = if b then False else True
21:33:18 <Tekmo> f3 b = if b then False else False
21:33:39 <prooftechnique> So :t \x y -> _ => a -> a -> a, but :t \x -> _ => a -> a, so foldl chokes. But :t \x -> const (_) => a -> t -> a
21:33:41 <Tekmo> Javran: Notice how I can represent all four functions by the values of each branch
21:33:46 <hunt> when do you guys use list comprehensions and when do you use mixtures of maps and other functions
21:33:49 <Tekmo> Javran: I could just represent each function as a 2-tuple of bools
21:33:53 <Tekmo> Javran: f0 = (True, True)
21:33:57 <Tekmo> Javran: f1 = (True, False)
21:34:02 <Tekmo> Javran: f2 = (False, True)
21:34:10 <Tekmo> Javran: f3 = (False, False)
21:34:14 <Javran> but 'b' is gone?
21:34:31 <orzo> prooftechnique, shachaf: fixed my bug, i have verified success with this coerce technique, but it does require the same optimization level
21:34:35 <Tekmo> Javran: They are not equal, but rather isomorphic
21:34:43 <prooftechnique> orzo: Neat. Good to know
21:35:00 <shachaf> orzo: In the context of this same thing in the past I discovered that GHC doesn't respect {-# UNPACK #-} when optimizations aren't turned on.
21:35:01 <prooftechnique> If it's not already, you should document your process and use case on the wiki or in a blog post
21:35:01 <Tekmo> Javran: Meaning that I can take this 2-tuple and convert it to a function or (vice versa) I can take the function and convert it to the equivalen 2-tuple
21:35:05 <shachaf> Not even if you specify it explicitly.
21:35:10 <Javran> I see
21:35:19 <Tekmo> Javran: I should ahve given the latter set of f's different names
21:35:26 <shachaf> orzo: (This was in the context of duplicating Data.Map's data type.)
21:35:28 <prooftechnique> *not there already
21:35:48 <roboguy_> orzo: so data structures that should be equivalent internally actually are?
21:36:04 <orzo> shachaf: perhaps ghc should provide an extension for this sort of thing, a way to get at internals
21:36:05 <Tekmo> Javran: The point though is that we can represent a function as some equivalent tuple that just enumerates what the codomain would be for each value in the domain
21:37:03 <sjy> in fact, that is the usual mathematical definition of a function, isn't it
21:37:39 <shachaf> orzo: Oh, you can get the information about what's actually exported in a data type from the .hi file.
21:37:43 <orzo> roboguy_: well, probably.  But my experiment used the same exact text, a code paste.  So theres a chance that it required constructors to be named the same and so on
21:37:44 <shachaf> ghc has an option to dump it.
21:37:50 <Javran> I think pure functions are just set of relations
21:37:55 <Tekmo> Javran: So if the codomain has `inhabitants b` inhabitants and our domain has `inhabitants a` inhabitants, then we have `inhabitants b ^ inhabitants a` possible functions
21:38:01 <prooftechnique> Javran: Which is just a set of tuples
21:38:11 <Javran> yep
21:38:13 <sjy> f: X -> Y is a set of tuples in (X, Y) (a relation) with the condition that there is only one Y for each X
21:38:49 <orzo> shachaf: no, i mean a way to access symbols that were not exported.  To extend a library without replacing it
21:39:01 <shachaf> I know.
21:39:15 <Tekmo> I like to think of `X -> Y` as a really big case statement with `X` branches (one for each inhabitant of `X`) and each branch returns a `Y`
21:39:17 <orzo> shachaf: and hi files will enable that?
21:39:20 <shachaf> No.
21:39:40 <Javran> that makes sense
21:39:44 <shachaf> I am only pointing out that they exist and have the relevant information.
21:40:04 <Tekmo> Javran: Now, there's one additional twist that's not as obvious as everything so far
21:40:08 <shachaf> Hmm, or maybe they don't, if the type isn't exported... I don't know.
21:40:12 <prooftechnique> Tekmo: Ow, my brain
21:40:13 <orzo> is there a way to detect the optization level in code?
21:40:14 <Tekmo> Javran: You can even count the number of inhabitants in polymorphic functions
21:40:24 <Tekmo> Javran: For example, functions like `forall r . r -> r`
21:40:34 <Tekmo> Javran: There is a neat way to prove that function only has one inhabitant
21:40:42 <hunt> what is forall
21:40:47 <no-n> how do I construct a ByteString (Lazy)?
21:40:53 <prooftechnique> orzo: Some authors put a header in their source or the cabal file.
21:40:57 <Tekmo> hunt: It basically means the type is true for any type `r`
21:41:06 <Tekmo> hunt: In other words, we can specialize `r` to any specific type
21:41:08 <prooftechnique> But detect? I'm not really sure
21:41:09 <ion> @hoogle [Word8] -> Data.ByteString.Lazy.ByteString
21:41:09 <lambdabot> Parse error:
21:41:09 <lambdabot>   [Word8] -> Data.ByteString.Lazy.ByteString
21:41:09 <lambdabot>                   ^
21:41:13 <Javran> that's universal quantification
21:41:17 <ion> @hoogle [Word8] -> ByteString
21:41:17 <lambdabot> Data.ByteString.Lazy pack :: [Word8] -> ByteString
21:41:18 <lambdabot> Data.ByteString pack :: [Word8] -> ByteString
21:41:18 <lambdabot> Data.ByteString.Lazy repeat :: Word8 -> ByteString
21:41:26 <Tekmo> hunt: i.e. we could use it as `Int -> Int` or `Double -> Double` or `String -> String`.  It will type-check as any of those
21:41:31 <hunt> Tekmo: why do you need forall, cant you just use an unclassed a
21:41:37 <Tekmo> hunt: Yes you can
21:41:38 <Javran> Tekmo: prove by contradiction?
21:41:42 <Tekmo> hunt: I was just making the forall explicit
21:42:01 <hunt> Tekmo: ah ok, i love this language
21:42:05 <Tekmo> Javran: So there is a neat theorem which says that:
21:42:14 <no-n> ion: do I have to use pack to make something like "hello, world"?
21:42:18 <hunt> Tekmo: is it special syntax, or is it defined somewhere?
21:42:22 <ion> no-n: In what encoding?
21:42:27 <no-n> ASCII
21:42:34 <orzo> i changed the options except for -O, it looks like -O is the most important for this
21:42:35 <Tekmo> Javran: forall r . (a -> r) -> f r ~ f a
21:43:13 <Tekmo> hunt: You can use it if you use the `ExplicitForall` extension
21:43:13 <Tekmo> hunt: Or the `RankNTypes` extension
21:43:13 <Tekmo> hunt: `ExplicitForall` is the minimum you need to have an outer-level `forall`
21:43:16 <hunt> Tekmo: are those popular extensions? are extensions popular at al
21:43:19 <ion> no-n: What do you want to happen if the String contains code points â‰¥ U+0080?
21:43:27 <Tekmo> hunt: RankNTypes is popular.  `ExplicitForall` is not
21:43:40 <roboguy_> forall a. a can be thought of as equivalent to Void, in some sense, right?
21:43:43 <no-n> ion: i don't know :/
21:43:43 <Tekmo> hunt: RankNTypes enables more advanced types that are otherwise not possible using Haskell98
21:43:51 <no-n> ion: this will be for ir
21:43:54 <Tekmo> Javran: So here's how this works
21:43:54 <no-n> ion: irc *
21:44:06 <Javran> "forall r . (a -> r) -> f r ~ f a" what is "f" here?
21:44:09 <hunt> roboguy_ void *
21:44:11 <Tekmo> Javran: You start from the type: forall r . r -> r
21:44:15 <Tekmo> Javran: I will explain that
21:44:18 <roboguy_> hunt: ?
21:44:23 <ion> no-n: IRC messages? You should output UTF-8 on IRC.
21:44:32 <hunt> roboguy_ its a void * isnt it, not just void
21:44:35 <no-n> hmm, so Text?
21:44:36 <roboguy_> hunt: oh. I mean "data Void"
21:44:43 <ion> no-n: Data.Text.Encoding.encodeUtf8
21:44:46 <hunt> roboguy_ oh sorry i see
21:44:48 <roboguy_> in the sense that it is (treated) as uninhabited
21:44:58 <Tekmo> Actually, let me just explain one last thing
21:45:08 <Tekmo> Javran: So now I will skip talking in terms of number of inhabitants
21:45:09 <roboguy_> if you have some function "forall a. a -> a", you can't actually do anything to the inhabitants of a
21:45:18 <no-n> ion: okay. so how would I construct "hello, world" as Text?
21:45:18 <Tekmo> Javran: I will just say that two types are "isomorphic"
21:45:29 <Tekmo> Javran: Isomorphic means that you can convert reversibly between the
21:45:42 <Javran> let me guess..
21:45:44 <Tekmo> Javran: For example `Bool -> a` and `(a, a)` are "isomorphic"
21:45:48 <hunt> wait do functions work on typeconstructors? i see that you use (.) to tie forall together with the type constructors (->)
21:45:52 <Javran> forall a . a -> a ~ 1 ?
21:45:56 <ion> no-n: With OverloadedStrings, just "hello, world". Without OverloadedStrings, @hoogle String -> Text
21:46:03 <Tekmo> Javran: That's right
21:46:08 <Tekmo> Javran: That's what we will prove
21:46:21 <Tekmo> Javran: So the first step is that `r ~ (() -> r)`
21:46:25 <Tekmo> Javran: So you get:
21:46:33 <Tekmo> Javran: forall . (() -> r) -> r
21:46:34 <dwcook> hunt, that . is just to separate the forall from the rest
21:46:36 <ion> hunt: In types, the . is not an operator.
21:46:47 <Tekmo> Javran: The second step is that `r ~ Identity r`
21:46:50 <Tekmo> Javran: So you get:
21:46:56 <Tekmo> Javran: forall r . (() -> r) -> Identity r
21:47:03 <roboguy_> hunt: what do you mean work on type constructors?
21:47:08 <Tekmo> Javran: Then you apply the theory I told you about, where `Identity` is the `f`
21:47:15 <Tekmo> Javran: That gives you:
21:47:26 <Tekmo> Javran: Identity ()
21:47:27 <prooftechnique> :t pack
21:47:28 <lambdabot>     Not in scope: `pack'
21:47:28 <lambdabot>     Perhaps you meant one of these:
21:47:28 <lambdabot>       `BS.pack' (imported from Data.ByteString),
21:47:32 <Tekmo> Javran: ... which is isomorphic to `()`
21:47:34 <prooftechnique> :t Text.pack
21:47:35 <lambdabot> Couldn't find qualified module.
21:47:36 <hunt> so the (.) is special syntax, and not the same (.) we use for composition?
21:47:39 <prooftechnique> :t T.pack
21:47:40 <lambdabot> Couldn't find qualified module.
21:47:41 <dwcook> hunt, correct.
21:47:42 <hunt> dwcook
21:47:47 <hunt> aw thats dissapointing
21:47:50 <Tekmo> Javran: So since `()` has only one inhabitant, there can only be one valid implementation of `forall r . r -> r`
21:48:00 <no-n> with overloaded does that mean it's already stored as Text in the executable? (no pack at runtime)?
21:48:02 <roboguy_> hunt: you mean when you see something like Foldable.toList?
21:48:05 <dwcook> hunt, you can still write type-level compose if you want
21:48:23 <prooftechnique> no-n: It's actually an instance of IsString, not Text explicitly
21:48:26 <dwcook> data Compose f g x = Compose (f (g x))
21:48:53 <ion> hunt: (.) the operator is a thing in the world of values, (->) is a thing in the world of types. â€œforall a.â€ including the dot is syntax.
21:48:59 <hunt> dwcook is it assumed here that f is a type constructor and g is a type constructor
21:49:00 <Javran> "So the first step is that `r ~ (() -> r)`" I'm wondering how it that possible to have "() -> r", looks like making things from nothing?
21:49:12 <no-n> uhh
21:49:16 <prooftechnique> no-n: But in practice, yeah
21:49:18 <no-n> so confuse :3
21:49:19 <Tekmo> Javran: This is easy to show by starting from the definition of an isomorphism
21:49:36 <no-n> so type inference would make it Text/whatever?
21:49:37 <prooftechnique> no-n: As long as you write your type signatures as Text, ghc'll figure it out
21:49:40 <hunt> ion, yea thats what dissapointing to me because it seems as though the . is being used in a similar fashion but a way that doesnt work. it seems like it might not have to be special syntax
21:49:42 <dwcook> hunt, yes. Haskell assigns them both the kind * -> * based on how I used them on the right hand side.
21:49:53 <prooftechnique> no-n: Yeah, type inference can figure it out
21:49:56 <Javran> Tekmo: oh, that's const function?
21:49:57 <no-n> ccool
21:50:01 <no-n> very thanks
21:50:08 <Tekmo> Javran: When we say two types `A` and `B` are isomorphic, we mean that there are two functions `fw` and `bw` that convert between them:
21:50:15 <Tekmo> Javran: fw :: A -> B
21:50:20 <Tekmo> Javran: bw :: B -> A
21:50:26 <Tekmo> Javran: ... and those functions must obey these laws:
21:50:26 <roboguy_> in this case, (() -> r) doesn't mean (forall r. () -> r)
21:50:28 <Tekmo> Javran: fw . bw = id
21:50:31 <Tekmo> Javran: bw . fw = id
21:50:36 <Tekmo> Javran: So in this case:
21:50:43 <Tekmo> Javran: fw :: r -> (() -> r)
21:50:49 <Tekmo> Javran: fw r = \() -> r
21:50:56 <Tekmo> Javran: bw :: (() -> r) -> r
21:51:00 <no-n> what does the "overloaded" mean?
21:51:00 <Tekmo> Javran: bw f = f ()
21:51:48 <Javran> looks good
21:52:03 <prooftechnique> Am I right in thinking that fw must be injective and bw must be surjective?
21:52:27 <prooftechnique> no-n: It just means that it can specialize to a number of string-like types
21:52:50 <no-n> okay
21:52:51 <roboguy_> prooftechnique: don't they both have to be bijective?
21:52:56 <Tekmo> Javran: So since we show that `forall r . r -> r` is isomorphic to `()` then they must have the same number of inhabitants
21:53:11 <Tekmo> Javran: Since `()` has one inhabitant, then `forall r . r -> r` must also only have one inhabitant
21:53:23 <Tekmo> Javran: In this case, that inhabitant is the `id` function
21:53:52 <prooftechnique> roboguy_: Oh, you're right, I was thinking of something else
21:54:09 <prooftechnique> That's obvious :|
21:55:52 <Javran> "forall r . (a -> r) -> f r ~ f a" so where does this theory come from?
21:56:06 <Tekmo> Javran: This theory is known as the Yoneda lemma
21:56:34 <Tekmo> Javran: It's actually more general than that.  What I showed you is a special case of that theorem
21:56:59 <Tekmo> Javran: You'll want to read this: http://blog.sigfpe.com/2006/11/yoneda-lemma.html
21:58:06 <Tekmo> Anyway, where I was going is that then there is an additional trick when you want to prove this kind of thing for recursive types
21:58:27 <Javran> .ok, let me wrap up the proof:
21:58:43 <roboguy_> Javran: I'd start by making the function "(forall r. (a -> r) -> f r) -> f a"
21:58:50 <prooftechnique> Oh, god, everything is Yoneda
21:58:54 <Javran> r ~ (() -> r) and r ~ Id r  , so we have (() -> r) -> Id r
21:58:59 <Tekmo> Javran: Righg
21:59:01 <Tekmo> *Right
21:59:14 <Javran> and then apply that special form of Yoneda lemma?
21:59:28 <Tekmo> That's right
21:59:41 <Javran>  (() -> r) ~ Id r actually
21:59:42 <roboguy_> Javran: that function would be half of the isomorphism that forms the Yoneda lemma
22:00:05 <Javran> which function?
22:00:20 <Tekmo> fw :: (forall r . (a -> r) -> f r) -> f a
22:00:25 <Tekmo> fw k = k id
22:00:30 <Tekmo> THe reverse function is:
22:00:32 <roboguy_> Javran: oh, sorry I thought you were talking to me. that one ^
22:00:39 <Tekmo> bw :: f a -> (forall r . (a -> r) -> f r)
22:00:50 <Tekmo> bw f = \k -> fmap k f
22:01:01 <roboguy_> that's what I get for turning on alerts for the word "yoneda"
22:01:22 <Tekmo> Notice that it's really easy to prove that `fw . bw = id`
22:01:30 <Tekmo> It's really hard to prove that `bw . fw = id`
22:01:37 <Tekmo> That's where the meat of the Yoneda lemma is
22:03:25 <no-n> how would I read *everything* from a chan? (Control.Concurrent.Chan)
22:04:17 <no-n> hmm. STM.TChan, I suppose, lol
22:04:29 <no-n> instead of isEmptyChan (deprecated)
22:04:29 <Tekmo> Alright, I have to get some sleep
22:04:43 <Tekmo> If you have more questions and I'm not on IRC, my e-mail address is Gabriel439 at google's email
22:05:03 <Javran> I tried "fw (bw f)" but it goes to "fmap id f"?
22:05:04 <prsteele> I love this channel. It is so friendly
22:05:13 <Javran> oh I see, never mind
22:05:14 <no-n> me too :}
22:05:15 <Tekmo> Javran: The functor laws say that `fmap id = id`
22:05:58 <Javran> functions are functions :)
22:06:03 <Javran> I meant functors
22:06:14 <no-n> why would a function that simply checks if a chan is empty be deprecated - seems weird
22:06:34 <prooftechnique> no-n: Link to docs?
22:06:52 <no-n> prooftechnique http://hackage.haskell.org/package/base-4.6.0.1/docs/Control-Concurrent-Chan.html vs. http://hackage.haskell.org/package/stm-2.4.3/docs/Control-Concurrent-STM-TChan.html
22:06:57 <bitemyapp> no-n: I can't speak to the rationale behind the deprecation, but I often see such functions used in pathological ways.
22:07:04 <Dugar> there's probably a length function for how many people are currently in a channel
22:07:08 <ion> tautologies are tautologies
22:07:12 <bitemyapp> such as forever loops in place of proper dataflow-oriented logic.
22:07:23 <no-n> bitemyapp: mmm.
22:07:36 <no-n> well I just want to keep reading from a chan until it's empty
22:07:44 <Tekmo> no-n: There's a race condition
22:07:54 <no-n> ahh
22:07:59 <Tekmo> no-n: In the `IO` version the channel state could change in between checking for empty and reading from it
22:08:04 <no-n> wouldn't MVar-locking prevent that?
22:08:21 <Tekmo> no-n: Yes, but STM is generally the recommended way of doing this
22:08:23 <dwcook> no-n, here is the url that it mentions, properly formatted, unlike in those docs: https://ghc.haskell.org/trac/ghc/ticket/4154
22:08:26 <Tekmo> no-n: It's much simpler to work with
22:08:41 <no-n> okay, I'll use STM.Tchan in that case.
22:08:44 <Tekmo> no-n: Using MVars to keep track of this sort of thing has the same disadvantage as using locks
22:09:13 <no-n> Tekmo: I wasn't talking about using them directly
22:09:26 <Tekmo> no-n: If you haven't already, do these tutorials: https://www.fpcomplete.com/school/advanced-haskell/beautiful-concurrency
22:09:40 <Tekmo> no-n: They not only explain how to use STM, but they also explain why what you are proposing doesn't work in general
22:09:49 <no-n> i've been reading http://chimera.labs.oreilly.com/books/1230000000929
22:10:02 <no-n> ok
22:10:22 <Tekmo> ALright, I have to head out, but please feel free to e-mail me: Gabriel439 at google mail
22:10:28 <no-n> see you
22:10:29 <Tekmo> I love to mentor people by e-mail
22:10:36 <Tekmo> Alright, see you all later
22:10:37 <no-n> thanks for the advice
22:10:42 <Tekmo> You're welcome!
22:10:45 <no-n> :)
22:11:11 <xpika> is there a data structure that represents a non-empty list?
22:11:21 <bitemyapp> Tekmo: may I bug you too? :)
22:11:37 <prooftechnique> xpika: There's one called NonEmptyList
22:12:15 <dibblego> xpika: it's in semigroups package
22:12:25 <dibblego> http://hackage.haskell.org/package/semigroups-0.12.2/docs/Data-List-NonEmpty.html
22:13:04 <xpika> dibblego: excellent
22:13:07 <xpika> prooftechnique: thanks
22:15:38 <xpika> ive been getting too many empty list exceptions
22:16:21 <dibblego> try to imagine those functions don't exist
22:16:30 <roboguy_> xpika: are you using head and tail?
22:16:40 <xpika> roboguy_: maximum and minimum
22:16:56 <no-n> @hoogle Text -> IO ()
22:16:56 <lambdabot> Data.Text.IO putStr :: Text -> IO ()
22:16:56 <lambdabot> Data.Text.Lazy.IO putStr :: Text -> IO ()
22:16:56 <lambdabot> Data.Text.IO putStrLn :: Text -> IO ()
22:17:34 <dibblego> xpika: then you probably also want this http://hackage.haskell.org/package/semigroupoids-4.0.1/docs/Data-Semigroup-Foldable.html
22:18:33 <roboguy_> xpika: if you have a function noEmpty :: [a] -> Maybe [a], that would probably help
22:18:42 <dibblego> listToMaybe does that
22:19:04 <roboguy_> dibblego: are you sure?
22:19:06 <dibblego> actually, what you want is foldl1 for which there is no [] instance, but there is NonEmpty instance
22:19:17 <dibblego> roboguy_: no, I just reread your signature
22:19:44 <roboguy_> if you had noEmpty, you could do something like maximum <$> noEmpty xs
22:20:05 <dibblego> why not just not use unsafe functions to begin with?
22:20:06 <roboguy_> that might be a little nicer than converting to and from NonEmpty
22:20:23 <dibblego> I don't agree that taking an unsafe function, then trying to make it more useful is nicer
22:20:24 <roboguy_> dibblego: I don't think there's a safe version of minimum and maximum in base
22:20:44 <dibblego> why would anyone write a haskell project without the Prelude hidden?
22:20:47 <roboguy_> dibblego: it just takes an unsafe function and turns it into a safe one... that seems like a good thing
22:20:54 <bitemyapp> is pattern-matching for an empty list just not a thing anymore?
22:20:56 <dibblego> it seems like a nasty thing to me
22:21:10 <roboguy_> bitemyapp: that's probably the best solution
22:21:12 <bitemyapp> This seems like an eminently solvable problem.
22:21:16 <roboguy_> in most circumstances anyway
22:21:49 <dibblego> you could use a better function :: [a] -> Maybe (NonEmpty a) now it's safe but unnecessarily clumsy
22:21:51 <roboguy_> noEmpty is just like half of "non []" from lens without a full lens dependency
22:21:56 <bitemyapp> if you have a chain of operations to perform, pattern-match at the beginning to get the base/pathological case and then when you've accounted for the possibility of a non-empty list, chuck your functions in.
22:22:14 <bitemyapp> ...I like Lens but come on.
22:22:42 <dibblego> Max is a Semigroup, but not a Monoid
22:22:45 <roboguy_> bitemyapp: haha, well that's why I suggested just writing it instead of incurring a dependency just for that
22:23:03 <roboguy_> dibblego: right, but Maybe lifts a Semigroup to a Monoid
22:23:13 <dibblego> right, but ick
22:23:20 <bitemyapp> roboguy_: mempty = Nothing? lol.
22:23:24 <roboguy_> yep
22:23:26 <bitemyapp> across type boundaries? double lol.
22:23:33 <dibblego> the cost of a dependency is negligible to hacking about with unsafe functions just because: history
22:24:01 <bitemyapp> I love safer ways of doing things, but I don't see how the problem wasn't dismissed with, "pattern match the empty list case" to begin with.
22:24:23 <dibblego> it usually ends up even clumsier
22:24:23 <tnks_> has anyone thought of a way to have the Haskell compiler warn or error out if you call an unsafe function?
22:24:37 <tnks_> like one that it knows calls "error"?
22:24:40 <bitemyapp> tnks_: there's a flag for incomplete pattern matches, but I don't know if that's only sum types or not.
22:25:03 <bitemyapp> tnks_: -fwarn-incomplete-patterns I think?
22:25:12 <prooftechnique> tnks_: There's Safe Haskell
22:25:13 <tnks_> yeah, exhaustive pattern matching is just one piece of the problem.
22:25:19 <tnks_> prooftechnique: oh yeah.
22:25:21 <prooftechnique> I dunno if it really handles that case, though
22:25:24 <copumpkin> tnks_: Safe Haskell?
22:25:37 <tnks_> copumpkin: yeah, I forgot about Safe Haskell.
22:25:43 <copumpkin> don't think error counts though
22:25:43 <shachaf> Safe Haskell doesn't do much about partial functions.
22:25:51 <tnks_> is that just a ghc extension?
22:25:53 <copumpkin> it's more about actual unsafe things
22:26:01 <copumpkin> -XTotal
22:26:02 <tnks_> or something different altogether?
22:26:04 * copumpkin runs
22:26:17 <shachaf> Safe Haskell is about things like unsafeCoerce and unsafePerformIO
22:26:25 <shachaf> Nothing for partiality.
22:26:31 <tnks_> oh, I see.
22:27:22 <bitemyapp> copumpkin: I like this rename.
22:28:10 <tnks_> I'm just thinking that people call head on list all the time. . . then have bugs, which dulls their perception of the value of types.
22:28:23 <schell> when using monad transformers like ReaderT, is it necessary to make the resulting 'transformed' monad an instance of MonadReader in order to use functions like ask and asks?
22:28:35 <bitemyapp> tnks_: yawn.
22:28:39 <roboguy_> bitemyapp: across type bounadries?
22:29:27 <roboguy_> tnks_: I could have sworn I saw some kind of haskell static analysis thing that checked for things like that, but I don't remember what it's called
22:29:35 <shachaf> ReaderT already has a MonadReader instance.
22:29:48 <bitemyapp> roboguy_: maybe I misunderstood but it seemed like the Monoid and semigroup were for different types.
22:29:57 <bitemyapp> max is from Ord.
22:30:00 <copumpkin> tnks: you see I put my java bytecode decoder/encoder online?
22:30:06 <bitemyapp> mempty would've been from Maybe
22:30:06 <schell> shachaf: that's what i thought, i think i just don't understand the concept yet then
22:30:11 <schell> thought i did :(
22:30:19 <copumpkin> tnks: still nowhere near complete, but already stresses GHC
22:30:27 <copumpkin> (stressing GHC is always a goal of mine)
22:30:31 <tnks> copumpkin: I saw the gist a week ago.
22:30:35 <roboguy_> bitemyapp: I'm still not sure what you mean... I just mean that if you have some type T that is an instance of Semigroup but not Monoid, Maybe T is a Monoid
22:30:42 <copumpkin> ah
22:30:49 <roboguy_> so Maybe lifts a Semigroup to a Monoid
22:30:58 <bitemyapp> roboguy_: okay, I read a different conception, you were being more generic.
22:31:07 <tnks> when you say "stressing GHC" I may not be following exactly what you mean?
22:31:26 <bitemyapp> roboguy_: that sound right. Thanks.
22:31:36 <tnks> bitemyapp: curious what you meant by your yawn.
22:31:37 <roboguy_> tnks: I think this is what I was thinking of, but I'm not sure how much it's still maintained http://community.haskell.org/~ndm/catch/
22:31:39 <bitemyapp> tnks: sometimes it breaks out into hives when you -Wall bad code.
22:31:45 <bitemyapp> that's what stressing out GHC means.
22:32:28 <copumpkin> tnks: I had to bump up the default typechecker limits for it to even typecheck
22:32:37 <copumpkin> which is kind of amusing for a binary format parser
22:32:40 <Aetherspawn> how does church encoding increase effeciency?
22:32:45 <bitemyapp> tnks: the yawn is because incomplete pattern matches are...relative to most programming languages...one of the few places you'll get errors/exceptions. a failure to realize it's a non-deterministic collection/container imperfectly expressed in the base library doesn't mean the type system is totally useless.
22:32:47 <Aetherspawn> gabriel says that in his blog, but I can't imagine how
22:32:51 <Aetherspawn> or even find implementations
22:33:38 <roboguy_> Aetherspawn: haha, I just asked that earlier and I think someone asked it before me too
22:33:39 <tnks> bitemyapp: oh, you don't need to convince me. . . just thinking it's an unfortunate conclusion for other people.
22:33:53 <Aetherspawn> roboguy_: lol!
22:33:53 <bitemyapp> tnks: that's where education comes in I guess.
22:33:54 <roboguy_> Aetherspawn: seems unintuitive, but you never know
22:33:55 <Aetherspawn> did you get an answer
22:34:01 <roboguy_> not really
22:34:14 <roboguy_> I should have asked again while he was here...
22:34:15 <bitemyapp> none may know the mind of Tekmo. Except for Oleg.
22:34:26 <copumpkin> eh
22:34:30 <tnks> copumpkin: what kind of limits can you bump in GHC?
22:34:33 <Aetherspawn> brb sending him an email
22:34:40 <copumpkin> I have {-# OPTIONS_GHC -fcontext-stack=250 #-}
22:34:44 <bitemyapp> Aetherspawn: a fine choice.
22:34:48 <copumpkin> (https://github.com/copumpkin/java/blob/master/src/Java/Bytecode/Encoding.hs)
22:35:02 <roboguy_> Aetherspawn: tell him he should expand that section. or at least write a footnote or something
22:36:34 <schell> shachaf: aha! my ReaderT was one level deeper in my monad stack - i just needed one `lift`
22:36:52 <schell> i think i understand now
22:37:19 <shachaf> schell: It's probably worth your while to understand how mtl transformer classes do the "implicit lifts" thing.
22:37:26 <Aetherspawn> email sent
22:37:28 <Aetherspawn> huzzah
22:37:30 <shachaf> (For example, to understand why it didn't work in your case, and when it does work, and how.)
22:38:04 <schell> shachaf: yeah, i thought i was getting an implicit lift since i'm using the ReaderT from mtl, but maybe i'm using ask from transformers?
22:38:30 <shachaf> It's not about ReaderT but about the thing at the top level.
22:38:47 <shachaf> But you should figure out which version of the function you're using, sure.
22:39:10 <schell> ahh - then maybe it's outside of my control, ultimately - i'm embedding a monad in Scotty's monad stack
22:39:41 <roboguy_> Aetherspawn: I know there is a way to make the traditional Free monad definition more efficient in most cases, but I'm not totally clear how it works.  Codensity does look a little like a Church encoding though. maybe it's that sort of thing
22:40:18 <shachaf> Well, it's probably worth your while to figure out how it works and why it doesn't.
22:41:02 <schell> shachaf: i'd like to, i've been reading monad transformer articles for a good part of the day
22:41:18 <Aetherspawn> I've been thinking about trying to church encode register indices
22:41:53 <schell> i tend to learn quicker from doing rather than by reading though, which is hard without someone to bounce ideas off of
22:42:21 <prooftechnique> Get a rubber duck :)
22:43:31 <McGreevy> l
22:43:46 <McGreevy> Albaquerque?
22:43:49 <McGreevy> is that you?
22:44:35 <McGreevy> hello
22:45:29 <bitemyapp> McGreevy: aren't you the troll from the Clojure mailing list?
22:45:45 <McGreevy> no this is my first time on irc
22:45:54 <bitemyapp> I don't think a mailing list is IRC.
22:46:08 <McGreevy> an emailing list
22:46:25 <McGreevy> which for me is but a list of good deeds
22:48:21 <McGreevy> like when old murphy shot the long lamma
22:48:31 <tnks> copumpkin: I couldn't tell. . . where is :> coming from in your code?
22:50:56 <copumpkin> tnks: https://github.com/copumpkin/java/blob/master/src/Data/Prickler.hs
22:51:37 <copumpkin> tnks: I'll probably end up changing that stuff a lot though
22:51:42 <tnks> oh, I see.
22:51:48 <copumpkin> I like the final spec but not so much how it works :)
22:51:51 <tnks> and Prickler's not on Hackage yet?
22:51:57 <tnks> I was looking for it on Hayoo.
22:52:04 <copumpkin> nah, still super rough
22:52:16 <copumpkin> wanted to tinker with it on a realistic use case
22:52:38 <tnks> oh, never mind. . . same project.
22:52:43 <copumpkin> yup
22:52:44 <tnks> just didn't go back enough.
22:52:50 <tnks> folder-wise.
22:52:54 <copumpkin> eventually will split it out if I like it enough
22:55:17 <Aetherspawn> free monads are confusing
22:55:25 <Aetherspawn> whats the point of having church encoding in a monad
22:55:38 <Aetherspawn> wouldn't it be much nicer to just have it as a value so you can have some tangible ones
22:55:39 <Aetherspawn> confused..
22:55:55 <jle`> Aetherspawn: do you understand free monoids
22:56:10 <jle`> what's the point of free monoids?
22:56:34 <Aetherspawn> I do not.
22:56:35 <jle`> only that they are literally the first data structure introduced to anyone
22:57:05 <prsteele> how do I suggest a type in-line? E.g. let `read` know I want an Int without adding a type annotation to the function?
22:57:22 <jle`> prsteele: it's usually not as hard as you think...if you use the value later, it'll be inferred
22:57:34 <jle`> prsteele: but usually if it can't be infereed you add a type annotation to the entire value, not the function
22:57:36 <ion> read :: String -> Int
22:57:45 <jle`> oh you're asking about how to do it
22:57:49 <ion> reads :: ReadS Int
22:58:00 <jle`> i like read "4" :: Int
22:58:13 <prsteele> jle`: ah perfect
22:58:26 <jle`> Aetherspawn: so i have a channel that receives Message data type, but i want to be able to merge messages and combine them
22:58:30 <jle`> to create mega-messages containing both
22:58:32 <ion> (reads :: ReadS Int) "4"
22:58:48 <jle`> and with semantics of a monoid
22:58:58 <jle`> associativity and with an identity
22:59:09 <jle`> but...i don't want to write a Monoid instance for Message
22:59:24 <jle`> and it's tricky to make Message into a monoid by hand and account for all the combing abilities
22:59:36 <jle`> so i use a free monoid
22:59:44 <Aetherspawn> what's "free" about it?
22:59:46 <jle`> something that turns Message into a monoid...with all the laws...for free.
22:59:53 <Aetherspawn> oh
22:59:54 <shachaf> ion: Pft, errors? In my code? Like that'll ever happen.
23:00:05 <jle`> and then later, when i want to 'combine' Messages by hand, with how messages should be processed
23:00:08 <jle`> i can handle that later
23:00:18 <jle`> for now, i can make it a monoid without doing any work at all
23:00:24 <jle`> and defer the actual merging logic for later.
23:00:33 <ion> shachaf: Of course not in your code, but there are errors in your users.
23:00:45 <jle`> (do you see what the free monoid is? you've probably used it)
23:01:02 <Aetherspawn> so the free stuff is for building up computations of stuff without deciding what function to use later
23:01:11 <jle`> no, the free is that you get a Monoid instance
23:01:20 <jle`> er well
23:01:21 <prooftechnique> Man, I love sandboxes
23:01:23 <jle`> that's not what the free means
23:01:33 <jle`> but you get a monoid instance 'for free' without doing any work
23:01:46 <jle`> (that's a different 'free' definition, but yeah)
23:02:01 <jle`> the free monoid is []
23:02:13 <jle`> in case i was being too vague
23:02:19 <jle`> i can use [Message]
23:02:23 <jle`> to turn message into a monoid
23:02:27 <jle`> without doing any work
23:02:38 <jle`> and then defer the actual 'how to merge messages' later, to whatever function handles multiple messages.
23:02:51 <Aetherspawn> how does it become easier with a monad
23:03:03 <jle`> also, in the Netwire library, Events can be merged if their argument is a monoid
23:03:12 <jle`> so i can merge events with Message by just using [Message]
23:05:51 <jle`> similarly if you have something that you want to be able to treat like a monad
23:05:57 <jle`> something you want to sequence, per se
23:06:00 <jle`> or use do notation for somehow
23:06:10 <jle`> you can do it by just wrapping it in Free
23:09:12 <prooftechnique> cabal install visual-prof --dry-run
23:09:17 <prooftechnique> Whoops :|
23:14:21 <prsteele> thanks everyone, have a good night
23:19:11 * hackagebot cryptohash 0.11.3 - collection of crypto hashes, fast, pure and practical  http://hackage.haskell.org/package/cryptohash-0.11.3 (VincentHanquez)
23:24:11 * hackagebot cryptohash 0.11.4 - collection of crypto hashes, fast, pure and practical  http://hackage.haskell.org/package/cryptohash-0.11.4 (VincentHanquez)
23:46:39 <no-n> hmm
23:46:55 <no-n> so TVars should be used instead of MVars or are MVars still right for some situations?
23:48:04 <enthropy> stm might be slower if you never actually need transactions that get rolled back
23:49:23 <no-n> what is meant by rolled back?
23:56:17 <johnw> MVar has one very tasty use case
23:56:25 <johnw> and some efficiency/fairness benefits in some cases
23:56:34 <johnw> you can do IO within a modifyMVar
