00:09:03 <jle`> i wonder why there isn't (b -> c) -> (a -> m b) -> (a -> m c)
00:09:53 <jle`> @pl \f g x -> f <$> g x
00:09:53 <lambdabot> (.) . (<$>)
00:10:42 <jle`> @pl \f g x -> liftM f (g x)
00:10:42 <lambdabot> (.) . fmap
00:10:48 * jle` shrugs
00:11:28 <jle`> @pl \f g x -> liftM g (f x)
00:11:29 <lambdabot> flip ((.) . fmap)
00:15:46 <awestroke> are there any lens functions for State/StateT, and if so how do I find them?
00:16:08 <fragamus> looking for more elegant:    (addVertexTo (triangle !! 0)) . (addVertexTo (triangle !! 1)) . (addVertexTo (triangle !! 2))
00:17:57 <fragamus> maybe map and then a function to compose the list of functions
00:19:29 <jle`> awestroke: can you give an examlple of what you are looking for?
00:20:54 <jle`> fragamus: why don't you map and then use foldr to compose?
00:21:51 <fragamus> i'll give it a shot and get back to you
00:22:03 <pordan30> that looks like a fold to me, fragamus: addVertexTo (t !! 0) (addVertexTo (t !! 1) (addVertexTo (t !! 2) p)) where p is a polygon (or whatever).
00:24:37 <nisstyre> Is there anything that corresponds to XPath's /foo/bar[n] in xml-conduit?
00:24:51 <nisstyre> it doesn't look like there is, which is a shame
00:25:45 <fragamus> foldr (\f z-> f . (addVertexTo z)) id triangle
00:25:51 <fragamus> how about that
00:26:08 * hackagebot dlist 0.7.0.1 - Difference lists  http://hackage.haskell.org/package/dlist-0.7.0.1 (SeanLeather)
00:32:13 <pordan30> perhaps i'm not understanding your code, but if a triangle is a list of vertices, why not fold addVertexTo over the vertex list, with the case for the empty list being the shape you are adding vertices to?
00:32:46 <pordan30> something like foldr addVertexTo p triangle where p is a shape and triangle is a list of vertices defining a triangle?
00:36:09 * hackagebot quadratic-irrational 0.0.1 - An implementation of quadratic irrationals  http://hackage.haskell.org/package/quadratic-irrational-0.0.1 (ion)
00:50:41 <fragamus> Does anybody have a hashable instance for V2 Double
00:51:11 * hackagebot Decimal 0.4.1 - Decimal numbers with variable precision  http://hackage.haskell.org/package/Decimal-0.4.1 (PaulJohnson)
00:54:55 <awestroke> fragamus: for what?
00:55:16 <fragamus> Linear    V2 Double
00:55:27 <pordan30> i don't know whether there are hashable instances for v2, but the hashable page on hackage contains good instructions for constructing hashable instances
00:55:34 <fragamus>    No instance for (Data.Hashable.Hashable (V2 Double))
00:55:37 <startlin1> fragamus, I don't, but you can derive it automatically (and I'm sure edwardk would like a PR with one)
00:55:58 <startlin1> (considering 'linear' already depends on hashable and V2 already has a Generic instance)
00:56:26 <fragamus> so use deriving clause?
00:57:10 <startlin1> fragamus, you should be able to just say "instance Hashable a => Hashable (V2 a)"
00:59:47 <fragamus> yep: "instance Hashable a => Hashable (V2 a)"
01:01:12 * hackagebot doctest 0.9.11 - Test interactive Haskell examples  http://hackage.haskell.org/package/doctest-0.9.11 (SimonHengel)
01:01:14 * hackagebot simple-genetic-algorithm 0.1.0.0 - Simple parallel genetic algorithm implementation  http://hackage.haskell.org/package/simple-genetic-algorithm-0.1.0.0 (eax)
01:06:13 * hackagebot simple-genetic-algorithm 0.1.0.1 - Simple parallel genetic algorithm implementation  http://hackage.haskell.org/package/simple-genetic-algorithm-0.1.0.1 (eax)
01:06:39 <b0bbi10> morning, is "to calate" in Data.List.intercalate a neologism? (I tend to learn functionnames better if I know what they mean) I wouldn't find a translation for that verb
01:07:30 <b0bbi10> couldn't*
01:07:51 <tdammers> https://en.wiktionary.org/wiki/intercalare
01:09:16 <tdammers> so no, 'calate' is not a verb in its own right
01:09:43 <tdammers> the '-cal-' part is etymologically related to 'calendar' I think
01:17:48 <pordan30> b0bbil0: intercalate is from 'inter' + 'calare'. 'calate' is from 'calare' (to announce, proclaim, call forth, call together); so the meaning is something like: "to proclaim/announce/bring together/etc (as) between." this probably doesn't help, and my latin is a little rusty
01:20:20 <tdammers> it actually does
01:20:37 <tdammers> because if you verb it, you have an appointment
01:20:56 <tdammers> ;)
01:21:15 * hackagebot tianbar 0.3.6.0 - A desktop bar based on WebKit  http://hackage.haskell.org/package/tianbar-0.3.6.0 (AlexeyKotlyarov)
01:38:27 <zMole> W
01:51:18 * hackagebot QuickCheck 2.7.3 - Automatic testing of Haskell programs  http://hackage.haskell.org/package/QuickCheck-2.7.3 (NickSmallbone)
01:52:01 <adimit> Correct me if I'm wrong, but basically everything of kind * -> *, or * -> * -> *, and so on, is a _type function_, right? I don't really have a conceptual problem here, I'm just not sure if the nomenclature applies generally.
01:52:43 <merijn> adimit: Yes and no, depending on context :)
01:53:37 <adimit> merijn: I don't have a Haskell context in mind, but a general type-theoretic one.
01:53:40 <merijn> adimit: In general, I don't think it'd be considered wrong, but in some contexts, "type function" might refer more specifically to TypeFamilies style type functions
01:53:48 <adimit> (i.e. System F-sub.)
01:54:36 <adimit> I'm basically trying to explain system-f-sub to a bunch of linguists who have only ever seen Montagovian-style type systems (simply typed lambda-calculus with 2 atomic types.)
01:54:48 <merijn> adimit: IFF you consider data constructors functions, then all those kinds are type functions (because those kinds can only be 1) type constructors or 2) type functions)
01:55:30 <merijn> And if data constructors are functions, then type constructors should be considered the same at the type level, imo
01:56:01 <adimit> merijn: So, basically (,) is a type function, and a type constructor, because it's a product type.
01:57:47 <adimit> (and, of course, (,) is a data constructor, at the term level.)
01:58:43 <adimit> btw, is there a special name for types of kind *? Like "simplex types" or "atomic types"?
01:59:06 <merijn> adimit: * is the name, usually :p
01:59:32 <adimit> merijn: it's a bit of a chicken and egg problem, because I haven't yet explained kinds.
02:00:14 <adimit> You kind of have to explain kinds and polymorphic types at the same time‚Ä¶
02:01:37 <m09> is there something close to set comprehension in Haskell?
02:02:11 <ion> Set.fromList [ ‚Ä¶ | x <- Set.toList x ]? :-P
02:02:19 <jle`> m09: heh
02:02:20 <ion> err, s/toList x/toList xs/
02:02:32 <m09> ion: not efficient I guess
02:02:33 <m09> :(
02:02:36 <adimit> m09: there's even Monad comprehension, now.
02:02:40 <jle`> can we do anything with the new overloaded list literals in ghc?
02:03:05 <jle`> m09: actually with fusion there might not even be an intermediate list
02:03:09 <jle`> (maybe)
02:03:37 <m09> doesn't the list comprehension kinda force the intermediate list?
02:03:48 <m09> I thought it had a bad producer behavior
02:03:49 <ion> m09: How about Set.filter composed with Set.map?
02:04:14 <m09> I'll check that =)
02:06:50 <m09> hum, the problem is that I'd like some comprehension that combines multiple sources ie, {x + y | x <- xs, y <- ys}
02:11:50 <peteretep> m09: List comprehensions can do that
02:12:11 <m09> oh?
02:12:13 <peteretep> m09: Is the issue that you want to then create a set from the result?
02:12:19 <m09> yup
02:12:22 <m09> efficiently if possible
02:12:45 <merijn> m09: You can't really do set comprehensions more easily than the suggested list one
02:12:58 <peteretep> > [ x + y | x <- [1..3], y <- [1..3] ]
02:12:59 <lambdabot>  [2,3,4,3,4,5,4,5,6]
02:13:00 <merijn> Because if you manipulate the elements you need to reconstruct it anyway
02:13:14 <merijn> Because set's structure depends on the value of each element
02:13:20 <ski> m09 : did you see my version of `(<*>)' for `Set' ?
02:13:53 <peteretep> > nub [ x + y | x <- [1..3], y <- [1..3] ]
02:13:54 <lambdabot>  [2,3,4,5,6]
02:14:01 <m09> ski: I'm not too used to applicatives so I'm not sure what that'd be
02:14:08 <awestroke> is there a duplicates function for lists? like:    duplicates (x:xs) = filter (`elem` xs) [x] ++ duplicates xs
02:14:17 <merijn> nub
02:14:20 <m09> just above
02:14:22 <m09> : d
02:14:27 <merijn> > nub [1,2,3,4,1,2,3,4]
02:14:28 <jle`> awestroke: you can use sort and groupBy
02:14:28 <lambdabot>  [1,2,3,4]
02:14:33 <jle`> er, group
02:14:35 <jle`> by
02:14:45 <peteretep> m09: Why do you need a set as the result?
02:14:49 <merijn> Note that nub isn't particularly efficient :)
02:15:10 <jle`> if only Set was an Applicative :/
02:15:12 <peteretep> m09: Are you simply looking for membership in the result?
02:15:20 <m09> peteretep: for fast membership checking and no duplicate
02:15:28 <merijn> awestroke: If your elements are Ord it may be faster to go through Set using fromList and toList
02:15:36 <jle`> then that would be (+) <$> xs <*> ys
02:15:58 <jle`> also try doing the from/to list and checking out the core, you might find that the list has been eliminated
02:16:03 <jle`> *intermediate
02:16:21 <ski> m09 : oh, actually it was MP2E asking about it, now you .. no wonder you didn't see it
02:16:37 <ski> <MP2E> hey guys, I have a 2 Sets, one of Int and the other is a bunch of curried functions of type (Int -> Int). How do I just "combine" these? The curried functions in the second list need only be applied to the first list
02:16:39 <pavonia> merijn: I think he wants the opposite of what nub does, i.e. return all duplicate elements
02:16:41 <ski> <MP2E> I tried Set.map ($) set1 set2 but that didn't work
02:16:46 <ski> <ski> MP2E : to make any interesting `Set (Int -> Int)', you must have `Ord (Int -> Int)' ..
02:16:53 <ski> <ski> @type \sab sa -> S.unions [S.map ab sa | ab <- S.toList sab]  -- that said, ..
02:16:56 <ski> <lambdabot> (Ord a, Ord a1) => S.Set (a1 -> a) -> S.Set a1 -> S.Set a
02:17:02 <jle`> i'm so confused, who is who?
02:17:21 * ski is ski, please to meet you
02:18:10 <ski> m09 : anyway, consider now instead a cartesian product
02:18:49 <ski> @type \sa sb -> S.unions [S.map ((,) a) sb | a <- S.toList sa]
02:18:50 <lambdabot> (Ord a1, Ord a) => S.Set a1 -> S.Set a -> S.Set (a1, a)
02:19:03 <ski> or a `zipWith'-like function
02:19:12 <ski> @type \f sa sb -> S.unions [S.map (f a) sb | a <- S.toList sa]
02:19:12 <lambdabot> (Ord a, Ord a1) => (t -> a1 -> a) -> S.Set t -> S.Set a1 -> S.Set a
02:19:23 <m09> yup it might be a fit
02:19:28 <m09> thanks for the input :)
02:19:45 <jle`> is there a possible way to implement 'constrained' monads?
02:20:01 <ski> jle` : yes
02:20:04 <jle`> monads with arbitrary constraints on (>>=)
02:20:10 <jle`> like Set requiring Ord
02:20:13 <jle`> for its (>>=)
02:20:19 <jle`> oh, really?
02:21:13 <fizruk> i think there's a package restricted-monads or something
02:21:22 * hackagebot dynamic-mvector 0.1.0.0 - A wrapper around MVector that enables pushing, popping and extending.  http://hackage.haskell.org/package/dynamic-mvector-0.1.0.0 (AndrasKovacs)
02:21:35 <fizruk> http://hackage.haskell.org/package/rmonad
02:21:42 <fizruk> jle`: ^
02:21:44 <jle`> ty
02:22:56 <jle`> that's interesting
02:23:39 <merijn> This is lovely: https://twitter.com/EvilHaskellTips/status/447877761760120832 :)
02:24:08 <ski> @hackage set-monad
02:24:08 <lambdabot> http://hackage.haskell.org/package/set-monad
02:24:15 <ski> is a more direct attack on `Monad Set'
02:24:36 <ski> (but i was thinking about `rmonad', i just couldn't recall what it was named ;)
02:25:00 <fizruk> ski: me too, I googled
02:25:35 <jle`> can't set just also provide its own setBind?  or setJoin?  you wouldn't be able to use all the nice combinators but it might be useful for things like this
02:28:23 <jle`> setJoin :: Ord a => Set (Set a) => Set a
02:28:55 <jle`> setBind :: (Ord a, Ord b) => Set a -> (a -> Set b) -> Set b
02:29:08 <jle`> there is already a setMap
02:29:10 <jle`> (map)
02:29:22 <jle`> for a functor-like interface without actually being a functor
02:29:37 <fizruk> jle`: setJoin could be concat and setBind - concatMap, I guess
02:30:20 <jle`> ah yeah, those are better names
02:30:34 <jle`> that sounds like something minimal that could be done
02:30:45 <jle`> they didn't try to make Set a functor, but they gave a specific Data.Set.map
02:31:51 <merijn> jle`: "Set (Set a)" would require that "Set a" is Ord
02:32:02 <merijn> jle`: How would you make 'Set a' an Ord instance?
02:32:16 <jle`> merijn: Set a is already an Ord
02:32:21 <merijn> It is?
02:32:25 <merijn> What's it ordered on?
02:32:33 <jle`> http://hackage.haskell.org/package/containers-0.5.5.1/docs/Data-Set.html
02:32:43 <jle`> i checked before suggesting it
02:32:46 <jle`> i'm actually not sure.
02:32:57 <fizruk> instance Ord a => Ord (Set a) where
02:32:57 <fizruk>     compare s1 s2 = compare (toAscList s1) (toAscList s2)
02:33:11 <ski> merijn : there's several possible partial orderings, Egli-Milner, Hoare, Smyth .. total orders is harder, i think
02:33:40 <merijn> That's not a very efficient ordering >.>
02:33:46 <jle`> <.<
02:34:07 <jle`> @src [] compare
02:34:07 <lambdabot> Source not found. I don't think I can be your friend on Facebook anymore.
02:34:22 <jle`> isn't []'s compare lazy?
02:34:29 <jle`> so it might not be that inefficient
02:34:49 <shiona> > [1,undefined] < [2,3]
02:34:51 <lambdabot>  True
02:34:54 <fizruk> toAscList should be lazy too, I think
02:34:58 <shiona> yes, it's lazy
02:35:08 <jle`> i would think toAscList is
02:35:12 <jle`> woohoo for lazy semantics
02:39:00 <fizruk> hm... I guess concat/setJoin is simply fold (from Data.Foldable)
02:39:13 <fizruk> since Set a is a monoid
02:40:36 <fizruk> > F.fold . S.fromList . map S.fromList $ [[1, 2, 3], [1, 3, 5], [1, 4, 7]]
02:40:37 <lambdabot>  fromList [1,2,3,4,5,7]
02:41:01 <fizruk> jle`: concatMap would be just foldMap then
02:41:24 * hackagebot boundingboxes 0.1 - The type for 2D bounding box  http://hackage.haskell.org/package/boundingboxes-0.1 (FumiakiKinoshita)
02:41:56 <jle`> ah i missed the line saying Set was Foldable
02:42:05 <jle`> that makes sense
02:42:15 <jle`> hm. so what would `ap` be?
02:42:16 <fizruk> > F.foldMap (\n -> S.fromList [1..n]) $ S.fromList [1..10]
02:42:17 <lambdabot>  fromList [1,2,3,4,5,6,7,8,9,10]
02:42:18 <jle`> @src ap
02:42:18 <lambdabot> ap = liftM2 id
02:42:32 <jle`> @src liftM2
02:42:32 <lambdabot> liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
02:42:55 <jle`> hm. well ap might be impossible seeing that you can't have Set (a -> b)
02:43:07 <fizruk> jle`: there can be no `ap` since functions can't be Ord
02:43:28 <jle`> but there might be a liftM2
02:43:37 <jle`> ?
02:43:54 <fizruk> sure, you just wrote it
02:44:59 <jle`> oh yeah :)
02:45:22 <fizruk> liftM2 f s1 s2 = foldMap (\x -> foldMap (\y -> singleton $ f x y)) s2
02:45:26 <fizruk> something like that
02:46:11 <awestroke> what's the easiest way to get started unit testing haskell?
02:46:17 <fizruk> ah that's syntactically wrong, but you get the idea
02:46:23 <jle`> mhm
02:46:44 <ski> hm, iirc we can have `instance (Compact a,Overt a,Eq b) => Eq (a -> b)'
02:47:00 <ski> one could ponder what could be a reasonable case for `Ord'
02:47:05 <fizruk> what's Compact and Overt?
02:47:11 <ski> @where impossible
02:47:12 <lambdabot> <http://math.andrej.com/2007/09/28/seemingly-impossible-functional-programs/>,<http://math.andrej.com/2008/11/21/a-haskell-monad-for-infinite-search-in-finite-time/>
02:47:21 <ski> @where topology
02:47:22 <lambdabot> "topology in Haskell" <http://www.haskell.org/pipermail/haskell/2004-June/014134.html> and "Synthetic topology of data types and classical spaces" <http://www.cs.bham.ac.uk/~mhe/papers/entcs87.(pdf|dvi|ps)> by MartÌn EscardÛ
02:48:14 <merijn> awestroke: QuickCheck and hunit?
02:48:16 <jle`> if `a` is enumerable, there could be a presumable Eq instance?  And if it was finite, a terminating one?
02:48:25 <ski> fizruk : `Compact a' means that we can semi-decide a univeral on `a' over a semi-decidable property on individuals
02:48:31 <merijn> awestroke: The former isn't really unit testing, but property testing is better anyway
02:48:34 <ski> `Overt' is the same, but for existentials
02:48:39 <jle`> Eq a => Bool -> a
02:48:44 <jle`> can definitely have an Eq instance
02:48:50 <awestroke> merijn: I know of quickcheck, but I'm not smart enough to apply it here
02:49:03 <jle`> heck even Eq a => Int -> a
02:49:06 <merijn> awestroke: What are you trying to test?
02:49:43 <ski> jle` : also `Eq ([Bool] -> Bool)' (for total functions of that type)
02:49:57 <jle`> maybe instance (Enum a, Bounded a, Eq b) => instance Eq (a -> b)
02:50:04 <jle`> except Enum doesn't work that way
02:50:15 <merijn> jle`: I suggested that before as a joke :)
02:50:32 <merijn> jle`: Enum doesn't work which way?
02:50:54 <jle`> f == g = map f [minBound..maxBound] = map g [minBound..maxBound]
02:50:59 <merijn> :t enumFromTo minBound maxBound
02:51:00 <lambdabot> (Bounded a, Enum a) => [a]
02:51:01 <jle`> merijn: an Enum instance might not enumerate over the entire space
02:51:06 <jle`> ie, Double
02:51:19 <merijn> jle`: Double's Enum instance is a lie anyway
02:51:31 <jle`> yeah, so we couldn't rely on the Enum instance
02:51:47 <ski> `Enum' should possibly be split
02:51:50 <merijn> We can, you can't rely on equality for double anyway
02:51:52 <jle`> i think i heard somewhere that Enum actually did not have to do with enumerable but instead range/steppable
02:52:15 <jle`> by somewhere i mean #haskell
02:52:35 <merijn> > (read "NaN" :: Double) == read "NaN"
02:52:36 <lambdabot>  False
02:52:38 <jle`> *did not have to do with enumeration
02:53:01 <jle`> merijn: we wouldn't be relying on equality for the double
02:53:18 <merijn> jle`: I know, I'm just saying Double's instances are awful anyway :)
02:53:22 <jle`> ah
02:53:38 <jle`> if only there was some sort of typeclass that says that you can create a list covering the entire type
02:53:44 <jle`> Coverable? but that's already a math term i think
02:53:52 <ski> hm, in SML, `real' isn't an `eqtype', you can't use `op =' on pairs of values from it
02:54:11 <ski> "cover" is a term, at least
02:54:24 <ski> "compact" means "every cover has a finite subcover"
02:54:50 <ski> (or at least, that's the traditional, point-set definition of it)
02:54:55 <jle`> what does cover mean?
02:55:38 <lukky513> hi Haskellers
02:55:48 <ski> a cover of a topological space is a family of open sets in the space, whose unions is the whole space
02:55:50 <jle`> hi lukky513
02:55:50 <lukky513> how do I escape minus sign in regexp?
02:55:56 <ski> s/unions/union/
02:56:57 <ski> so a space being compact means that any family of open sets whose union is the whole space has a subfamily of open sets whose union is still the whole space
02:57:25 <jle`> lukky513: minus sign isn't a control character in normal regexps?  so you can use them unescaped.  unless you are specifying ranges, you can use \- like expected
02:57:49 <lukky513> I need to do that within character class, regular \\- doesn't seem to work
02:58:00 <jle`> can you give an example?
02:58:04 <merijn> In character classes - has to go first, I think
02:59:07 <ski> however, if you want a computational intuition, it might be better to think of `A' as being compact to mean that one can implement a `forall_A :: (A -> Sierpinski) -> Sierpinski' function, which returns `Terminated' iff the argument function returns `Terminated' for all elements of `A'
02:59:31 <lukky513> [^\\.\\<\\>\\-\\ ]+
02:59:38 <lukky513> I know most can be omitted
02:59:44 <ski> where `data Sierpinski = Terminated' is thought of as a type of semi-decidable truth-values, with `Terminated' meaning "true", and `_|_' meaning "false"
02:59:57 <ski> jle` : ok ?
03:00:08 <merijn> lukky513: Any reason why you're not just using parsec to write a parser instead of regex?
03:00:18 <lukky513> is there :alnum: class that would work with unicode?
03:00:30 <lukky513> merijn: parser would be overkill, I just need to split and count words
03:00:57 <lukky513> unless I can specify grammar no longer than regexp
03:01:05 <fizruk> lukky513: then regex might be overkill too?
03:01:06 <merijn> Considering that a parsec parser would take like a 5 mins tops to implement and will still be readable a year from now
03:01:22 <quchen> Regex is write only. Also https://github.com/quchen/articles/blob/master/fbut.md#im-looking-for-a-good-regex-library
03:01:22 <merijn> lukky513: Also, what's wrong with "words"?
03:01:32 <merijn> > words "How about that, huh?"
03:01:33 <lambdabot>  ["How","about","that,","huh?"]
03:01:39 <lukky513> merijn: I don't know idioms
03:01:40 <merijn> > length $ words "How about that, huh?"
03:01:41 <lambdabot>  4
03:01:57 <lukky513> I need to strip it of punctuation
03:02:17 <jle`> filter elem blah blah
03:02:18 <fizruk> lukky513: can you filter punctuation?
03:02:41 <jle`> ski: am processing
03:03:20 <lukky513> fizruk: I need to cover case like "some-words" -> ["some", "words"]
03:03:36 <jle`> map punctuations to spaces
03:03:40 <fizruk> lukky513: replace punctuation with spaces
03:03:52 <lukky513> seems reasonable
03:04:26 <ski> jle` : e.g. given `andS Terminated Terminated = Terminated', we can define `forall_Bool p = andS (p False) (p True)'
03:04:34 <lukky513> although one-pass FSM which regexp is supposed to be should be faster
03:04:34 * quchen is thrilled to see the homebrewn chain of special case handling that is not an overkill like an easy parser would be
03:04:46 <lukky513> but given the built time overhead...
03:04:54 <jle`> lukky513: you can also use replicateM (many1 alphaNum)
03:04:55 <lukky513> s/built/build/
03:05:17 <jle`> er
03:05:23 <jle`> um
03:05:42 <int-index> I'm writing a lazy lexer and I need a type like a list, but with Nil holding a value. Something like List a b = Cons a (List a b) | Nil b
03:05:44 <fizruk> lukky513: you might be wrong about the speed of (words . map f) solution
03:05:46 <jle`> many1 (many1 alphaNum <* punctuation)
03:05:49 <int-index> Is there something like this?
03:06:16 <lesur> I'm trying to learn arrows and am slightly confused about proc. It doesn't seem to be a function and Hoogle says it is a "keyword." What exactly does proc do?
03:06:21 <fizruk> int-index: there are some packages for non-empty lists, I guess
03:06:24 <lukky513> fizruk: I suppose I am, I'm just saying what I think things should be
03:06:27 * hackagebot directory 1.2.1.0 - library for directory handling  http://hackage.haskell.org/package/directory-1.2.1.0 (HerbertValerioRiedel)
03:06:31 <jle`> lesur: it is syntactic sugar, like do notation
03:06:37 <ski> jle` : now, implementing `orS' is trickier (requires some internal concurrency), but you could take it as a primitive to define `exists_Nat p = orS (p Zero) (exists_Nat $ \n -> p (Succ n))' e.g., so `data Nat = Zero | Succ Nat' (considering only the finite elements) is `Overt'
03:06:38 <int-index> fizruk, a /= b
03:06:44 <quchen> int-index: Isn't that just ([a],b)?
03:06:45 <merijn> lesur: proc is is special notation, but arrow notation is a bit...complex
03:06:57 <lukky513> quchen: it would require me some prior Haskell knowledge, I suppose; anyway, I don't have time for that *right now*
03:07:19 <int-index> quchen, no, as you cannot construct such a tuple lazily
03:07:19 <ski> jle` : but of course `Nat' is not `Compact' (it is infinite, how can you check an infinity number of conditions in finite time ?)
03:07:47 <merijn> lesur: See http://www.haskell.org/ghc/docs/latest/html/users_guide/arrow-notation.html
03:07:50 <lesur> jle`: so its like do; just to let the compiler know that I am using a special notation?
03:08:03 <ski> jle` : still, Escard√≥'s surprising discovery is that it *is* possible to implement `forall_A' for some type `A' with an infinite number of elements !
03:08:09 <int-index> a type like this would be ok too: List a = Cons a (List a) | Nil | Interrupt
03:08:17 <merijn> lesur: Which also has links to several papers on the notation
03:08:18 <jle`> ski: :o
03:08:28 <supki> int-index: Free (a,) b ?
03:08:44 <fizruk> int-index: Either [a] () ?
03:09:02 <merijn> fizruk: It's customary to have the exceptional type as first argument
03:09:11 <merijn> fizruk: i.e. "Either () [a]"
03:09:17 <ski> jle` : see the "impossible" articles linked above, and also Escard√≥'s paper "Synthetic topology of data types and classical spaces" (at least the introductory parts (featuring some Haskell code) should be readable)
03:10:01 <int-index> fizruk, that's just Maybe a, and the problem is constructing the list lazily. Either an interrupt or a nil occurs, and the calling code might not even reach in, whereas in the Either solution you NEED to pattern match Left/Right
03:10:02 <fizruk> merijn: yeah, didn't put any thought into that..
03:10:47 <jle`> ski: this playing around almost feels cheating
03:10:55 <jle`> but i will look at the paper
03:11:12 <fizruk> int-index: true, seems like I don't get your problem
03:11:36 <jle`> can you give an example
03:12:10 <ski> jle` : in the case of the universal quantifier of type `(([Bool] -> Bool) -> Sierpinski) -> Sierpinski' for the infinite type `[Bool] -> Bool' (where in this case we allow the list in `[Bool]' to be infinite, but not partial. also the functions taking these potentially-finite streams must be total, so `and' is out of the question), the trick is that any such function, when it terminates, will only have looked at a *finite* part of the input stream
03:12:12 <quchen> supki: That's true, but just a different way of writing his suggestion.
03:12:31 <ski> (er, possible cut off near ".., the trick is that any such function, when it terminates, will only have looked at a *finite* part of the input stream")
03:13:02 <ski> jle` : first read the blog posts, at least the first one, before the paper
03:13:17 <lukky513> about mapping: how can I easily remap ".,?!" to spaces? like Unix tr?
03:13:48 <jle`> how can a cover not have a finite subcover?
03:14:07 <int-index> fizruk, ok, I'll try to explain. Say I have a function tokenize :: String -> [Token]. In case of bad input I what do I do? Raise an exception? Not a good idea. But if I wrap it in a maybe like String->Maybe[Token], then I can't just do something like (take 10 (tokenize str))
03:14:36 <jle`> lukky513: puncToSpaces x | x `elem` ".,?!" = ' ' | otherwise = x
03:14:51 <jle`> map puncToSpaces "hello.world?"
03:15:39 <lukky513> jle`: thanks! though I supposed there'd be a built-in :D
03:16:08 <merijn> int-index: That's what fmap is for
03:16:19 <merijn> take 10 <$> tokenize str
03:16:22 <fizruk> merijn: that's not his question I think
03:16:28 * hackagebot yesod-platform 1.2.8.2 - Meta package for Yesod  http://hackage.haskell.org/package/yesod-platform-1.2.8.2 (MichaelSnoyman)
03:16:37 <fizruk> merijn: I think he wants first tokens that did not fail to parse
03:16:59 <merijn> Then just do "String -> Either [Token] [Token]"?
03:17:19 <merijn> You either return a full succesfull tokenize or just "whatever you have so far"
03:17:28 <merijn> Or possibly better
03:17:40 <merijn> String -> Either (ErrorMsg, [Token]), [Token]
03:17:57 <int-index> I later pass those tokens to a parser, and it might consume not all the tokens, but only the ones it needs.
03:18:22 <bahamas> I realized one thing that makes haskell a bit harder to read. there is a lot of mental substitution that needs to be done, since the arguments passed to a function aren't always spelled out
03:18:27 <int-index> And it would be handy to work with them like with a simple list, but which ends whether with an interrupt or a succesfull termination.
03:18:47 <peteretep> int-index: This look a lot like an assignment I did for a course called FPR
03:20:07 <osa1> I know I asked this before but in case it's added in RC2/latest cabal, is there a way to run cabal for only type checking?
03:20:10 <int-index> merijn, the problem is that in order for tokenize to determine if it is completely successful or has 'something so far', it needs to tokenize the string completely
03:20:16 <int-index> It's not optimal
03:20:23 <int-index> I want to make use of lazy evaluation.
03:20:53 <fizruk> int-index: I would use ([a], b) thing
03:21:49 <fizruk> int-index: when the list is empty, check whether b contains any errors
03:22:01 <fizruk> int-index: if not - all is ok
03:22:28 <int-index> Fair enough, I'll give it a try.
03:22:37 <fizruk> int-index: is the list is not empty - you didn't go far enough to encounter lexical error
03:22:48 <peteretep> int-index: couldn't you use a Monad to short-circuit further evaluation
03:23:00 <exlevan> is it juct me or free-4.6.1 broke lens?
03:23:01 <int-index> Which monad?
03:23:21 <jle`> why not Maybe?
03:23:38 <int-index> Because I lose lazy evaluation.
03:23:56 <int-index> In order to determine if it's a Just or Nothing, the complete string needs to get tokenized.
03:24:14 <fizruk> int-index: you loose partial results
03:24:46 <int-index> Exactly.
03:25:06 <peteretep> So ... use Either
03:25:11 <peteretep> or something Either like
03:25:16 <int-index> Nope, I will use ([a],b)
03:25:24 <int-index> as fizruk suggested
03:25:40 <int-index> I just figured out that it is equivalent to the type I asked for by laws of algebraic data types.
03:28:42 <fizruk> int-index: note that if ([a],) is a writer monad
03:29:41 <ski> jle` : "how can a cover not have a finite subcover?" -- consider the space ‚åú‚Ñù‚åù, the real line, and the cover specified by : for every integer ‚åún‚åù, the interval ‚åú(n-1,n+1)‚åù
03:30:15 <int-index> fizruk, that's just neat! so I do some Writer stuff, and return if a error was encountered.
03:30:17 <ski> jle` : do you agree that the union of these intervals, over any integer ‚åún‚åù, is the whole of ‚åú‚Ñù‚åù ?
03:30:37 <fizruk> int-index: there's more
03:31:13 <fizruk> int-index: ([a], Maybe b) is actually MaybeT (Writer [a]) b
03:31:51 <ski> why is `unmtl' broken :( ?
03:31:53 <fizruk> int-index: similarly ([a], Either e b) is ErrorT e (Writer [a]) b
03:32:08 <int-index> It might come in handy, but for now I think that b=Bool is enough.
03:32:26 <peteretep> fizruk: ah ha, the big reveal ;-)
03:32:43 <fizruk> int-index: Maybe/Either gives you much more than Bool
03:33:32 <int-index> Well yes, I might return a position of a lexical error.
03:33:41 <fizruk> int-index: with Bool you need to short-circuit manually
03:35:49 <jle`> ski: my terminal does not like the unicode :/
03:36:45 <fizruk> int-index: actually if you use Maybe b or Either e b, you should not use b for error information
03:37:50 <int-index> why not?
03:38:52 <fizruk> int-index: because error would be Nothing or `Left err` correspondingly
03:40:07 <ski> <ski> jle` : "how can a cover not have a finite subcover?" -- consider the space `|R', the real line, and the cover specified by : for every integer `n', the interval `(n-1,n+1)'
03:40:14 <ski> (note that that interval is open)
03:40:21 <int-index> fizruk, why is that necessary? I mean, if it's not idiomatic, I might note it in documentation
03:40:26 <ski> <ski> jle` : do you agree that the union of these intervals, over any integer `n', is the whole of `|R' ?
03:42:25 <ski> fizruk : i think it can make sense to use the dexter part for error information, in case you're trying several alternate things, if one fails, you may want to try another thing depending on the way the first failed in
03:42:57 <ski> (besides, it's fun to turn convention on its head like that)
03:43:39 <ski> (i agree about possibly taking a note of it in the documentation, though)
03:47:11 <fizruk> int-index: if you have the situation like ski described above, you can use b for error info
03:47:48 <fizruk> int-index: or if you want to collect a list of errors, I guess
03:48:30 <fizruk> int-index: but I believe in your case you have a single thing to try (parse token) and stop after first error
03:49:08 <ski> however, imo it would possibly be nicer then to choose names that signal that you expect the "error case" as "main/normal answer"
03:51:48 <fizruk> int-index: so to return a position where error occurred, I'd use `e` of `Either e a`
03:55:22 <jle`> ser
03:55:46 <jle`> ski: i do
03:56:13 <jle`> oh, and no subcovers of those intervals are covers of |R?
03:56:21 <kwertie> what does =>  mean in a function signature?
03:56:41 <merijn> kwertie: A (typeclass) constraint
03:56:55 <julia_> is there a way to implement http://hackage.haskell.org/package/hxt-9.3.1.3/docs/Control-Arrow-ArrowList.html#v:arr4 for more than 4 arguments (without using a long tuple definition)?
03:57:27 <merijn> kwertie: You can read "foo :: Eq a => a -> a -> Bool" as "IF 'a' is an instance of the Eq typeclass, THEN foo has type 'a -> a -> Bool'"
03:57:35 <julia_> definition of arr4:        arr4 f              = arr (\ ~(x1, ~(x2, ~(x3, x4))) -> f x1 x2 x3 x4)
03:58:15 <julia_> I need something like arr5 and arr13...
03:58:32 <ski> jle` : now a finite subfamily of that must have a lower bound and an upper bound, and so can't cover the whole of `|R'
03:59:26 <ski> jle` : in this case, actually no proper subfamily of that cover is a cover, yes
03:59:35 <julia_> and what does "~" mean in the definition?
03:59:53 <jle`> what are the cases of the opposite?
04:00:05 <jle`> julia_: it's a lazy pattern match
04:00:14 <ski> julia_ : delay the pattern-matching inside the `~(...)' until a variable bound by `...' is forced
04:00:24 <kwertie> merijn: thanks
04:00:48 <ski> julia_ : it is called "irrefutable pattern match" (though, strictly speaking, it's just one form of "irrefutable")
04:01:14 <julia_> thx, http://www.haskell.org/haskellwiki/Lazy_pattern_match , right?
04:01:15 <ski> > let f ~(Just x) (2,x) in fst (f Nothing)
04:01:16 <lambdabot>  <hint>:1:23: parse error on input `in'
04:01:19 <merijn> What are some well-known graph algorithms that require mutation? Graph reduction and Delaunay mesh refinement, any other important ones?
04:01:23 <ski> > let f ~(Just x) = (2,x) in fst (f Nothing)
04:01:24 <lambdabot>  2
04:01:28 <ski> > let f ~(Just x) = (2,x) in f Nothing
04:01:29 <lambdabot>  (2,*Exception: <interactive>:3:5-23: Irrefutable pattern failed for pattern ...
04:01:40 <ski> > let f ~(Just x) = 2 in f Nothing
04:01:41 <lambdabot>  2
04:01:51 <ski> julia_ : consider those cases ^
04:02:14 <ski> @src partition
04:02:14 <lambdabot> partition p xs = foldr (select p) ([],[]) xs
04:02:14 <lambdabot>     where select p x ~(ts,fs) | p x       = (x:ts,fs)
04:02:14 <lambdabot>                               | otherwise = (ts, x:fs)
04:02:31 <ski> @let strictPartition p xs = foldr (select p) ([],[]) xs where select p x (ts,fs) | p x       = (x:ts,fs) | otherwise = (ts, x:fs)
04:02:33 <lambdabot>  Defined.
04:02:52 <ski> > (take 8 *** take 8) (partition even [0 ..])
04:02:54 <lambdabot>  ([0,2,4,6,8,10,12,14],[1,3,5,7,9,11,13,15])
04:02:59 <ski> > (take 8 *** take 8) (strictPartition even [0 ..])
04:03:02 <lambdabot>  (*Exception: stack overflow
04:03:27 <ski> julia_ : note how `strictPartition' can't cope with infinite lists, without `~'
04:04:02 <ski> this also means that `strictPartition' will insist on walking to the end of a long list before yielding any initial elements in the two lists it returns
04:04:20 <ski> (which is inefficient, compared to what `partition', using `~', can do)
04:05:26 <ski> (the `(take 8 *** take 8)' just crops both output lists to at most eight elements. otherwise both would be infinite, and we wouldn't get to see the second because it would attempt to print the whole first one first)
04:05:33 <yitz> > (take 8 *** take 8) (strictPartition even [0 .. 100]) -- just to keep ski honest
04:05:35 <lambdabot>  ([0,2,4,6,8,10,12,14],[1,3,5,7,9,11,13,15])
04:05:53 <ski> good point
04:06:08 <ski> > (take 8 *** take 8) (strictPartition even [0 .. 1000000])
04:06:10 <lambdabot>  (*Exception: stack overflow
04:06:11 <ski> > (take 8 *** take 8) (partition even [0 .. 1000000])
04:06:12 <lambdabot>  ([0,2,4,6,8,10,12,14],[1,3,5,7,9,11,13,15])
04:06:53 <julia_> thx for your explanation... I guess I got the point... ;-)
04:07:06 <ski> (thus suggesting that `strictPartition' tries to do much more work before yielding the initial first eight elements of both lists to the caller)
04:07:52 <ski> julia_ : `~' can also be useful for tying "recursive knots", where you're chasing your own tail, and can't look at it yet, before you omit some output
04:10:07 <julia_> > let f (Just x) = 2 in f Nothing
04:10:08 <lambdabot>  *Exception: <interactive>:3:5-18: Non-exhaustive patterns in function f
04:10:38 <ski> > fix (\fibs -> 0 : 1 : zipWith (+) fibs (tail fibs))  -- this computes the fibonacci sequence
04:10:40 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
04:11:06 <ski> > fix (\fibs @ (_:tailFibs) -> 0 : 1 : zipWith (+) fibs tailFibs)  -- this attempts to use matching instead of `tail', but "looks to early at the tail", so doesn't work
04:11:10 <lambdabot>  mueval-core: Time limit exceeded
04:12:00 <ski> > fix (\fibs @ ~(_:tailFibs) -> 0 : 1 : zipWith (+) fibs tailFibs)  -- this works, because we delay the matching of the list `fibs' with the pattern `_:tailFibs' until after we have produced the `0' output
04:12:01 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
04:12:38 <no-n> what's ~
04:12:46 <ski> > fix (\fibs -> 0 : case fibs of _:tailFibs -> 1 : zipWith (+) fibs tailFibs)  -- this explicit way also works, but littering code with `case' like this can be ugly
04:12:47 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
04:13:31 <ski> > fix (\fibs -> case fibs of _:tailFibs -> 0 : 1 : zipWith (+) fibs tailFibs)  -- but moving the output `0 :' inside the `case', so that we attempt to look at the tail before producing the output (so, being too eager in chasing our tail), fails
04:13:35 <lambdabot>  mueval-core: Time limit exceeded
04:13:39 <ski> julia_ : does that help ?
04:13:53 <no-n> > (\xxs @ (x:xs) -> x) [1..10]
04:13:54 <lambdabot>  1
04:14:00 <no-n> aha
04:14:13 <ski> julia_ : if you haven't seen that first formulation of fibonacci earlier, you may first want to take some time understanding how it works
04:15:16 <ski> @src fix
04:15:16 <lambdabot> fix f = let x = f x in x
04:15:29 <ski> which might more nicely (imho) be written as
04:15:33 <ski>   fix f = x
04:15:34 <ski>     where
04:15:37 <ski>     x = f x
04:15:44 <ski> may help in decoding the above
04:15:50 <tdammers> fix x = undefined -- TODO
04:16:08 <ski>   fix (\foo -> ..foo..)
04:16:15 <ski> is basically the same as
04:16:22 <ski>   let foo = ..foo.. in foo
04:16:46 <ski> *except* that with `let', there's an implicit `~' around the whole `foo' pattern to the left of the `='
04:16:48 <julia_> :ski: your previous example with let f ~(Just x) = ... helped already a lot!
04:16:57 <no-n> how do you make fix "stop"?
04:17:04 <no-n> what's a trivial example
04:17:11 <ski> (which is why i couldn't do the above example with a recursive `let', rather than with `fix')
04:17:13 <no-n> factorial maybe =)
04:17:21 <ski> > fix (1:)
04:17:22 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
04:17:35 <ski> > fix ("hi" ++)
04:17:35 <julia_> I guess I understand the meaning of "~" now... ;-)
04:17:37 <lambdabot>  "hihihihihihihihihihihihihihihihihihihihihihihihihihihihihihihihihihihihihih...
04:17:37 <no-n> that doesn't stop :P
04:18:05 <ski> > fix (\fact n -> if n == 0 then 1 else n * fact (n - 1)) 5
04:18:07 <lambdabot>  120
04:18:20 <no-n> ok cool
04:18:26 <ski> > (let fact = \n -> if n == 0 then 1 else n * fact (n - 1) in fact) 5
04:18:27 <lambdabot>  120
04:18:35 <ski> > let fact n = if n == 0 then 1 else n * fact (n - 1) in fact 5
04:18:36 <lambdabot>  120
04:19:07 <no-n> hrm
04:19:14 <no-n> using fix isn't so different from... not using fix it seems
04:20:08 <julia_> Is there way to implement http://hackage.haskell.org/package/hxt-9.3.1.3/docs/Control-Arrow-ArrowList.html#v:arr4 with more arguments than 4 (like 13 arguments) and not using a huge tuple-definition?
04:20:16 <ski> no-n : yes, it's mostly useful as a nice shorthand, in some cases
04:20:21 <ski> btw, here's a quick sketch (in some sense) explaining `fix (\fibs -> 0 : 1 : zipWith (+) fibs (tail fibs))'
04:20:32 <lyxia> > let fibs = 0 : 1 : zipWith (+) fibs (tail fibs) in fibs
04:20:33 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
04:20:50 <ski>      fix (\fibs -> 0 : 1 : zipWith (+) fibs (tail fibs))
04:21:01 <ski>   =  fibs0
04:21:07 <ski>        where
04:21:24 <ski>        fibs0 = (\fibs -> 0 : 1 : zipWith (+) fibs (tail fibs)) fibs0
04:21:27 <ski>   =  fibs0
04:21:30 <ski>        where
04:21:42 <ski>        fibs0 = 0 : 1 : zipWith (+) fibs0 (tail fibs0)
04:22:01 <ski>   =  fibs0
04:22:05 <ski>        where
04:22:14 <yitz> > fix show -- and the famous fun example
04:22:14 <ski>        fibs0 = 0 : fibs1
04:22:15 <lambdabot>  "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\...
04:22:30 <ski>        fibs1 = 1 : zipWith (+) fibs0 (tail fibs0)
04:22:45 <ski>   =  0 : fibs1
04:22:53 <ski>        where
04:23:04 <lyxia> yitz: Very fun indeed!
04:23:05 <ski>        fibs1 = 1 : zipWith (+) (0 : fibs1) fibs1
04:23:05 <no-n> wat
04:23:35 <ski>   =  0 : 1 : fibs2
04:23:36 <ski>        where
04:23:45 <ski>        fibs1 = 1 : fibs2
04:23:54 <ski>        fibs2 = zipWith (+) (0 : fibs1) fibs1
04:23:55 <julia_> @type arr4
04:23:56 <lambdabot>     Not in scope: `arr4'
04:23:56 <lambdabot>     Perhaps you meant `arr' (imported from Control.Arrow)
04:23:58 <ski>   =  0 : 1 : fibs2
04:24:00 <ski>        where
04:24:00 <zomg> I suspect paste fail
04:24:01 <zomg> :P
04:24:12 <ski>        fibs2 = zipWith (+) (0 : 1 : fibs2) (1 : fibs2)
04:24:19 * ski isn't pasting
04:24:20 <julia_> @type Control.Arrow.ArrowList.arr4
04:24:21 <lambdabot> Couldn't find qualified module.
04:24:35 <ski>   =  0 : 1 : fibs2
04:24:38 <ski>        where
04:24:49 <zomg> oh so you're just filling the channel with noise for fun then
04:24:50 <zomg> :p
04:24:58 <ski>        fibs2 = 0 + 1 : zipWith (+) (1 : fibs2) (fibs2)
04:25:01 <haasn> fibs = scanl (+) 0 (1:fibs) -- \o/
04:25:01 <julia_> @type Control.Arrow.arr4
04:25:02 <lambdabot>     Not in scope: `Control.Arrow.arr4'
04:25:02 <lambdabot>     Perhaps you meant one of these:
04:25:02 <lambdabot>       `Control.Arrow.arr' (imported from Control.Arrow),
04:25:06 <ski>   =  0 : 1 : 1 : fibs3
04:25:08 <ski>        where
04:25:22 <ski>        fibs3 = 0 + 1 : zipWith (+) (1 : 1 : fibs3) (1 : fibs3)
04:25:44 <ski> (strike the `0 + 1 : ' there)
04:25:55 <kuribas> Wouldn't it be possible to automatically derive Functor, Traversable, Foldable, etc, by looking where the type variables is?
04:26:01 <ski>   =  0 : 1 : 1 : fibs3
04:26:03 <ski>        where
04:26:10 <haasn> kuribas: it is in fact possible, with extensions
04:26:16 <ski>        fibs3 = 1 + 1 : zipWith (+) (1 : fibs3) fibs3
04:26:23 <ski>   =  0 : 1 : 1 : 2 : fibs4
04:26:25 <ski>        where
04:26:29 <hpc> stahp
04:26:38 <haasn> kuribas: DeriveFunctor, DeriveFoldable and Derivetraversable
04:26:47 <kuribas> Ah, nice!
04:26:50 <ski>        fibs4 = zipWith (+) (1 : 2 : fibs4) (2 : fibs4)
04:26:57 <ski>   =  0 : 1 : 1 : 2 : 3 : fibs5
04:26:58 <ski>        where
04:27:12 <haasn> kuribas: there's also DeriveGeneric, DeriveDataTypeable!
04:27:13 <ski>        fibs5 = zipWith (+) (2 : 3 : fibs5) (3 : fibs5)
04:27:17 <ski> (and i'll stop now)
04:27:19 <pyon> ski: ?
04:27:46 <ion> ski: Aww, i was looking forward to the rest of the sequence.
04:28:07 <kuribas> haasn: there are still so many haskell niceties I don't know...
04:28:11 <ski> ion : if you want to, i could provide more in private ;)
04:28:23 <haasn> (isn't this what #haskell-overflow is meant for?)
04:28:38 <ski> hm, possibly
04:34:49 <awestroke> how are State monads injected and combined?
04:35:42 <Iceland_jack> awestroke: Do you know how regular monads are combined?
04:37:22 <awestroke> Iceland_jack: I know some. like Nothing >>= _ = Nothing
04:37:54 <Iceland_jack> awestroke: Here's a quick example; ‚Äòmodify‚Äô takes a function that modifies the state value, so
04:37:55 <Iceland_jack>     modify (+1)
04:37:55 <Iceland_jack> adds one to the current state, does that make sense?
04:37:56 <Fuuzetsu> how is State not a regular monad in your book, Iceland_jack?
04:38:06 <Iceland_jack> Fuuzetsu: I didn't say that it wasn't
04:39:04 <awestroke> Iceland_jack: sure. and it's implemented as :   modify s = do s <- get; put f s;
04:39:42 <Iceland_jack> awestroke: yes, so we can execute it twice to get ‚ÄòaddTwo‚Äô, agreed?
04:39:42 <Iceland_jack>     addTwo = do modify (+ 1)
04:39:42 <Iceland_jack>                 modify (+ 1)
04:39:42 <Iceland_jack>  
04:40:02 <awestroke> yes
04:40:16 <Iceland_jack> Now we can run it
04:40:16 <Iceland_jack> > let plus2 = do modify (+1); modify (+1) in runState plus2 0
04:40:17 <lambdabot>  ((),2)
04:40:40 <Iceland_jack> s/plus2/addTwo/
04:40:57 <awestroke> how does modify (+1) read from the state if the state is not passed in, only out
04:41:22 <Iceland_jack> awestroke: The state is passed in, in the implementation of (>>=)
04:41:56 <Iceland_jack> But those plumbing-details are hidden from the user, doesn't mean that they don't take place :)
04:42:35 <haasn> awestroke: modify (+1) is like \s -> ((), s+1)
04:42:45 <awestroke> Iceland_jack: yes, here: http://hackage.haskell.org/package/transformers-0.3.0.0/docs/src/Control-Monad-Trans-State-Lazy.html#line-182
04:42:54 <awestroke> and I can't understand that >>= definition
04:43:21 <Iceland_jack> awestroke: The (>>=) definition is a bit trickier since it's not defining State but StateT
04:43:47 <awestroke> Iceland_jack: State is just alias for StateT id or something
04:43:54 <Iceland_jack> awestroke: Yes
04:43:54 <awestroke> so I have to understand the StateT >>=
04:44:03 <Iceland_jack> But you can also define State without StateT
04:44:10 <haasn> @src State >>=
04:44:10 <lambdabot> Source not found. Just try something else.
04:44:27 <Iceland_jack> First we should make sure you understand the definition
04:44:27 <Iceland_jack>     newtype StateT s m a = StateT { runStateT :: s -> m (a,s) }
04:44:32 <haasn> newtype State s a = State { runState :: s -> (a, s) }
04:44:33 <Iceland_jack> awestroke: anything unclear about that?
04:44:35 <awestroke> ~(a, s') <-    what does this mean?
04:44:39 <Iceland_jack> awestroke: lazy pattern match
04:44:53 <Iceland_jack> It's not very important to understanding State
04:45:13 <ski>   runState (ma >>= amb) s0 = let
04:45:17 <awestroke> What makes (a, s') <- strict ?
04:45:17 <ski>     (a,s1) = runState   ma    s0
04:45:19 <ski>           in runState (amb a) s0
04:45:42 <ski> is a simplified (and not-quite-Haskell) explanation of `(>>=)' for basic `State'
04:45:49 <haasn> State x >>= f = State (\s -> let (a,s') = x s in runState (f a) s')
04:46:09 <Iceland_jack> awestroke: (I recommend checking out ski's code!)
04:46:59 <Iceland_jack> > let f ~(x, y) = "hi" in f undefined -- If you really want to understand lazy pattern matching
04:47:00 <lambdabot>  "hi"
04:47:05 <ski> (sorry, the last `runState' should be fed the new state `s1', not the old one -- this is exactly why the state monad was invented in the first place ! to avoid having such silly errors, instead relying on a single (hopefully correct !) `(>>=)' plumbing the state under the covers)
04:47:08 <Iceland_jack> > let f (x, y) = "hi" in f undefined
04:47:09 <lambdabot>  "*Exception: Prelude.undefined
04:47:21 <bahamas> awestroke: pattern matching is strict by default
04:48:09 <ski> adek : if you want, you could name the result of the last state `(b,s2)' .. but then you'd just return `(b,s2)' anyway, so why not simplify it a bit ?
04:48:41 <awestroke> how does runStateT inject the initial state into the computation
04:48:57 <Iceland_jack> awestroke: You pass it as an argument
04:48:59 <Iceland_jack> @ty runState
04:49:00 <lambdabot> State s a -> s -> (a, s)
04:49:09 <Iceland_jack> 's' is the initial state
04:49:20 <ski> awestroke : iow, it would be possible to also say
04:49:24 <ski>   runState (ma >>= amb) s0 = let
04:49:30 <Iceland_jack> > runState get "initial state"
04:49:30 <ski>        (a,s1) = runState   ma    s0
04:49:31 <lambdabot>  ("initial state","initial state")
04:49:38 <ski>        (b,s2) = runState (amb a) s1
04:49:41 <ski>     in (b,s2)
04:49:43 <haasn> > do Left x <- Just (Right 3); return (x :: Int)
04:49:44 <lambdabot>  Nothing
04:49:48 <haasn> > do ~(Left x) <- Just (Right 3); return (x :: Int)
04:49:49 <lambdabot>  Just *Exception: <interactive>:3:4-30: Irrefutable pattern failed for patter...
04:50:54 <Iceland_jack> Don't get too hung up on ~
04:51:04 <ski> awestroke : the point is that *when* `ma >>= amb' later gets "executed", i.e. in this case, *when* `runState' gets applied to it, with some input state `s0'. *then* will `ma >>= amb' pass on the state `s0' to `ma' (using `runState', of course !), and get a result `a' and a new state `s1' in return
04:51:05 <awestroke> Iceland_jack: I know s is the initial state. how does it suddenly slip into the called function
04:51:39 * hackagebot haddock 2.14.1 - A documentation-generation tool for Haskell libraries  http://hackage.haskell.org/package/haddock-2.14.1 (MateuszKowalczyk)
04:52:07 <Iceland_jack> awestroke: The state is just a function
04:52:07 <Iceland_jack>     s -> (a, s)
04:52:16 <Iceland_jack> (wrapped in a newtype)
04:52:24 <Iceland_jack> When you call ‚ÄòrunState‚Äô, you unwrap it
04:52:30 <ski> awestroke : and *then*, we pass `a' to `amb' to determine which the next `State'-action is to be, and we execute that, by feeding it the current state `s1', getting a result `b' and yet another state `s2' in return. and now the execution of `ma >>= amb' on the initial state `s0' just returns a pair of the result `b' and the currently most recent state `s2'
04:52:37 <ski> awestroke : does that make any sense ?
04:52:38 <haasn> awestroke: in (x >>= f), what is the type of ‚Äòf‚Äô? (Assuming we are talking about the State monad)
04:52:52 <awestroke> ski: I understand that
04:53:15 <ski> awestroke : in my examples, `ma :: State s a', `amb :: a -> State s b', `s0,s1,s2 :: s', `a :: a' and `b :: b'
04:53:17 <awestroke> oh wait
04:53:33 <Iceland_jack> awestroke: Are you clear how newtypes work?
04:53:45 <Iceland_jack> otherwise it won't make much sense
04:53:47 <awestroke> "fn :: Int -> State Bool" does this really return a function that accepts a state and returns a new state and a boolean?
04:54:06 <haasn> awestroke: try expanding the definition of ‚ÄòState‚Äô there
04:54:13 <ski> awestroke : well, yes, except for the "return" part. it *is* such a function
04:54:20 <ion> State takes two parameters.
04:54:26 <haasn> ski: he meant, it returns such a function when applied to an Int
04:54:26 <awestroke> ski: not until I pass an int to it, no
04:54:33 <ski> awestroke : er, sorry, i misparsed what you said, ignore
04:54:43 <haasn> also what ion said is pretty important
04:54:43 <ski> awestroke : you're right
04:55:20 <awestroke> ion: two parameters?
04:55:37 <Iceland_jack> awestroke: type of the state, type of the return value
04:55:37 <haasn> awestroke: newtype State s a = State { runState :: s -> (a, s) }
04:55:39 <bahamas> :k State
04:55:40 <lambdabot>     Type synonym `State' should have 1 argument, but has been given none
04:55:40 <lambdabot>     In a type in a GHCi command: State
04:55:52 <ion> awestroke: State s a
04:55:59 <haasn> State :: * -> * -> *
04:56:04 <ski> awestroke : so, given `fn :: Int -> State s Bool', knowing that a `State s Bool' just contains a `s -> (Bool,s)', this `fn :: Int -> State s Bool' is almost the same as `fn :: Int -> (s -> (Bool,s))', except that we need to explicitly unwrap the `State s Bool' with `runState'
04:56:22 <haasn> or fn :: Int -> s -> (Bool, s)
04:56:22 <Iceland_jack> awestroke: Here's is an example of a state value which returns a boolean
04:56:22 <Iceland_jack>     blocked :: State RobotState Bool
04:56:32 <ski> awestroke : so, it basically amounts to what haasn said
04:56:59 <awestroke> thanks everyone
04:57:01 <awestroke> much appreciated
04:57:24 <ski> @google what the hell are monads
04:57:26 <lambdabot> http://web.cecs.pdx.edu/~antoy/Courses/TPFLP/lectures/MONADS/Noel/research/monads.html
04:57:26 <lambdabot> Title: Online Tutorial: What the hell are Monads?
04:57:50 <ski> awestroke : you might try that ^ monad tutorial -- it's somewhat old, but i think still good
04:58:15 <Iceland_jack> awestroke: Could you make a value with an Int state that returns 'True' if the state is even?
04:58:34 <ski> (afaik, it's the first monads-in-programming tutorial, at least if you don't count papers)
05:05:19 <fizruk> i think, learning applicatives/traversables first reveals much more "functional things" in FP and it is easy to learn monads after
05:05:48 <fizruk> there's so much confusion when going directly from pure functions to monads
05:05:58 <fizruk> at least I had a lot
05:09:34 <ski> fizruk : could be
05:10:34 <Iceland_jack> One of the biggest problem is that monads are so notorious in Haskell that some people go into Haskell just to learn them, without learning about functors or type classes first
05:10:40 <quicksilver> applicatives have the same core message as monads
05:10:54 <quicksilver> which is that "something else" goes alongside the "computation"
05:10:58 <merijn> Iceland_jack: Or types, for that matter
05:11:05 <quicksilver> I would have thought they were equally potentially confusing.
05:11:39 <merijn> fizruk: I think it's more people thinking "oh, there's type inference! I can just forget about types!", instead of properly learning types ad typeclasses
05:11:55 <Brody> Hello. Im wondering what do you guys think about using Haskell to make programs with lots of input and output, ie games. I know people do, and Ive seen some amazing examples. Im just unsure if these people are 200 IQ savants and if a nooby such as myself would be kidding himself.
05:11:58 <ski> (`Functor' should certainly be grokked before `Monad')
05:12:20 <Iceland_jack> merijn: indeed
05:12:46 <merijn> Brody: I don't think these people are 200 IQ savants, but I do think writing such programs has a bigger learning curve in Haskell than in more traditional languages
05:13:14 <merijn> Brody: Mostly because Haskell has very few "beginner" game examples, and the game examples that do exist are mostly written for more intermediate/advanced haskell programmers
05:13:39 <haasn> I certainly think gloss is very easy to work with, for example
05:13:41 <Brody> merijn thanks
05:13:43 <haasn> And it can certainly be used to write games
05:14:09 <merijn> Brody: So you would probably have to familiarise yourself with those before diving head-first into game development
05:14:57 <Brody> merijn yes, ive been working my way through 'learn you a haskell for great good' so far.
05:15:39 <jle`> Brody: i am no savant but i don't think games are much more of a challenge in haskell than in other languages
05:15:59 <jle`> haskell is really not the genius language you might perceive it to be
05:16:03 <jle`> haskell users are normal programmers
05:16:16 <jle`> in fact if you're new to programming you might actually find haskell easier than imperative languages
05:16:37 <haasn> I cannot understand how people write games in C++, though; from my perspective those must be 200 IQ savants
05:16:47 <jle`> most of the difficulty is in the adjustment period where old habits and vertigo make you think that haskell is hard, but what is really hard is applying your old intuition to an unrelated domain
05:16:55 <merijn> haasn: That's why you throw hundreds of programmers against the problem :)
05:16:57 <tdammers> haasn: I'd say games are one of those things where C++ actually has a place
05:16:59 <jle`> much respect for those C++ game developers
05:17:11 <bahamas> jle`: why do you think haskell would be easier for beginners?
05:17:21 <merijn> bahamas: Depends what your compare it too
05:17:36 <haasn> bahamas: the core semantics are very simple and the language has little ‚Äúbuilt-in‚Äù
05:17:57 <NathanC> I'm using the Control.Concurrent.Chan library, and am having an issue with getChanContents
05:18:05 <jle`> bahamas: what i meant from that was that i don't think haskell is inherently any more difficult to learn than impreative languages.
05:18:07 <haasn> most of the complicatedness of haskell arises from syntactic sugar for conceptually simpler forms
05:18:08 <jle`> at least, that
05:18:39 <haasn> but at its ‚ÄúCore‚Äù, Haskell expressions only have one of very few forms that mainly rely around function abstraction, function application and pattern matching
05:19:08 <merijn> NathanC: And that issue is?
05:19:17 <bahamas> merijn: with imperative languages which jle` mentioned
05:19:23 <NathanC> Ah, actually nevermind, just overlooked a silly mistake.
05:19:39 <NathanC> It's a really nice library, very easy to use and powerful
05:19:58 <merijn> bahamas: Compared with C, no memory management, pointer mistakes or worrying about object vs pointer distinction
05:20:34 <merijn> bahamas: Compared to Java, no distinction between objects and references, no confusion about the difference between primitive types and objects, doesn't conflate namespacing, implementation hiding and data structures
05:20:44 <bahamas> merijn: actually, you have a point. the imperative family contains a lot of languages. I was thinking of Python
05:21:07 <fizruk> bahamas: python was my first language
05:21:17 <bahamas> fizruk: mine too
05:21:28 <adimit> oh god, I'm old. Mine was Turbo-Pascal.
05:21:29 <merijn> bahamas: Compared to python, again no object/reference distinction, no confusion about types of thing, function signatures easier to understand, can't accidentally modify functions of a class instance, etc.
05:21:30 <AmroPlay> bahamas: python also has many functional features...
05:21:31 <bahamas> merijn: I'm curious if objects make more sense to people than functors do
05:21:33 <tdammers> adimit: same here
05:21:47 <bahamas> AmroPlay: I know. but there's no monad/applicative/functor
05:21:51 <haasn> merijn: also no subtyping in haskell (re: java)
05:21:54 <jle`> bahamas: there is that one article about a guy teaching his high school kids programming languages
05:21:56 <lieven_> lol. I'm older still. Fortran 66 and then 360 Assembler.
05:21:57 <merijn> haasn: Word
05:21:59 <adimit> ah, the good old days of one-pass compilers. And then Borland Delphi. Hihi.
05:22:06 <haasn> no implicit coercion
05:22:08 <bahamas> adimit: I studied a bit of pascal in school, but was never proficient in it
05:22:23 <adimit> bahamas: and you don't need to be. It's obsolete now, pretty much.
05:22:32 <tdammers> adimit: I switched to C a while later, because that's what all the cool books used for examples
05:23:00 <haasn> my first language was QBASIC, followed by GML, PHP and C#. Not a combination I'd recommend, but I eventually discovered Haskell and have loved its liberation ever since :)
05:23:00 <bahamas> jle`: what's his conclusion?
05:23:09 <tdammers> AmroPlay: and it doesn't really have the balls to really put their money in them
05:23:11 <jle`> i'm trying to find it
05:23:18 <jle`> students struggled a lot with imperative concepts
05:23:23 <jle`> but
05:23:31 <jle`> map was very easy for them to understand right away
05:23:36 <jle`> and surprisingly so was fold
05:24:05 <jle`> of course it is his own anecdotal experience
05:24:09 <AmroPlay> tdammers: its main focus is object orientation... now java has as many functional features as python
05:25:35 <haasn> (except with 10x as much boilerplate!)
05:25:39 <NathanC> If the thread that called a forkIO is killed, is the thread it created killed?
05:25:42 <bahamas> a study about this would be interesting
05:25:49 <haasn> also list comprehensions are immensely useful; I wonder if JAva is ever going to get those
05:26:40 <AmroPlay> haasn: maybe in twenty years or seo
05:26:45 <Brody> Does anyone know of someone using Haskell to make prgrams that are compatible with android operating system?
05:26:54 <quchen> NathanC: No, forkIO just creates something and then stops caring. Have a look at the `async` package for what you want to do.
05:27:06 <NathanC> quchen: Okay, thank you.
05:27:56 <bahamas> I'm glad python adopted quite a few function features. it meant I didn't have so many unknowns when I started with haskell
05:28:15 <tdammers> AmroPlay: I know Python. I don't think it's very good at OOP either.
05:28:42 <quchen> I don't think merely having lambdas makes your language very functional.
05:29:31 <AmroPlay> quchen: Java also has the Streams API (which let you "map", "filter" and so on)
05:29:33 <quchen> There should be at least some focus on them, and easy syntax to support them.
05:29:40 <jle`> Brody: well, you can make HTML5 apps :)
05:29:45 <haasn> AmroPlay: and it will probably work by first defining a ComprehensionFactory class and instantiating that ;)
05:30:04 <no-n> @src T.sequenceA
05:30:04 <lambdabot> Source not found. stty: unknown mode: doofus
05:30:15 <no-n> wow rude
05:30:34 <Brody> jle' html5, thats perfect.
05:30:50 <no-n> @src [] sequenceA
05:30:50 <lambdabot> Source not found.
05:30:57 <haasn> Brody: I'd try asking in #haskell-mobile
05:31:12 <haasn> though I think that's mainly based on iOS
05:31:15 <quchen> T.sequenceA = T.mapM id
05:31:21 <quchen> Eh, T.traverse
05:31:31 <Brody> ok
05:31:43 <AmroPlay> haasn: Something like "new ComprehensionFactory<ArrayList>().setGenerator(new ArrayList<Integer>.asList(1, 2, 3))"
05:31:44 * hackagebot shakespeare-css 1.0.7.2 - Stick your haskell variables into css at compile time.  http://hackage.haskell.org/package/shakespeare-css-1.0.7.2 (MichaelSnoyman)
05:32:06 <no-n> http://hackage.haskell.org/package/base-4.6.0.1/docs/src/Data-Traversable.html eh
05:33:03 <blipped> Hi, trying to figure out why I keep getting parse errors when compiling
05:33:23 <blipped> using ":l filename.hs" with ghci on Win7 using Sublime text editor.
05:33:38 <blipped> It's infrequent, and when I copy the code to a new file it works.
05:33:40 <AmroPlay> blipped: tried to convert all tabs to spaces in the file?
05:33:59 <merijn> blipped: Well, it'd help to pastebin your file and your parse errors?
05:34:05 <jle`> bahamas: found the article
05:34:09 <jle`> http://sawafaso.blogspot.com.ar/2013/07/why-haskell-at-school-matters.html?m=1
05:35:40 <jle`> 'When the last class finished, one boy come to me and complained: "professor, when will we start learning challenging things in Haskell?".'
05:36:44 * hackagebot shakespeare-css 1.0.7.3 - Stick your haskell variables into css at compile time.  http://hackage.haskell.org/package/shakespeare-css-1.0.7.3 (MichaelSnoyman)
05:38:14 <bahamas> jle`: thanks. I'll have a look
05:40:43 <NathanC> I'm looking for a function that allows me to perform a monadic action n times, where n is the length of a list, and I need to pass the data in the list sequentially to a monad
05:41:01 <NathanC> so something like ReplicateM, but with different arguments each time
05:41:44 <b0bbi10> how come the first value is at the last position when using Data.Map.fromListWith?
05:42:09 <jle`> NathanC: you mean the result of one action is the input of the next?
05:42:19 <b0bbi10> is it because of Map is implemented as a tree?
05:42:21 <jle`> b0bbi10: what last position?
05:42:31 <mornfall> NathanC: do you mean sequence?
05:42:45 <b0bbi10> jle`: sorry, forgot to provide the paste http://ideone.com/rppymX
05:42:47 <jle`> NathanC: try giving us a type signature
05:42:58 <mornfall> NathanC: or mapM?
05:43:00 <NathanC> jle`: Ah, no, simply independent calls to the monadic action using different data
05:43:19 <jle`> sounds like mapM
05:43:24 <NathanC> mapM looks like what I'm looking for, thanks
05:43:35 <jle`> hoogle would help you greatly :)
05:43:50 <jle`> also consider that mapM f is sequence . map f
05:43:55 <NathanC> I checked it a bit. I'm rather sleep deprived at the moment, working on a fun genetics algorithm program
05:43:57 <blipped> amroplay, didn't seem to work. It's just LYAH code: http://snipt.org/Qggij7  - But sublime gives me parse errors on input = '='
05:44:17 <quchen> Paste your code.
05:44:35 <quchen> Or is that a paste of your source file, and not just LYAH copy+paste?
05:44:50 <blipped> both.
05:44:55 <blipped> I pasted it directly in.
05:45:12 <blipped> Though it formatted oddly on snipt with that extra indent..
05:45:13 <jle`> b0bbi10: it does not have to do with map's internal implementation, i would think
05:45:16 <quchen> The paste won't load for me. We like lpaste in this channel.
05:45:18 <quchen> @where paste
05:45:18 <lambdabot> http://hpaste.org/new/haskell
05:45:21 <blipped> I can't use pastebin here in China without a vpn.
05:45:27 <quchen> Ewww, still HPaste in that command.
05:45:29 <quchen> @paste
05:45:29 <lambdabot> Haskell pastebin: http://lpaste.net/
05:45:31 <quchen> That one.
05:45:35 <jle`> b0bbi10: perhaps the fromListWith function takes the new item as the first argument and the original value as the second
05:45:40 <gnoynat> Hi, all, when I read the tutorial 'learn you a haskell', i have a question about the Foldable typeclass, how the author figure out he just need to implenemt foldMap function when to add the Tree type as a instance of foldMap?
05:45:59 <ion> @@ @where+ paste @paste
05:46:00 <lambdabot>  Okay.
05:46:07 <b0bbi10> jle`: well, could be
05:46:08 <b0bbi10> thanks
05:46:30 <blipped> Huh, ok, pasted it into a new file and changed the encoding again and it works.
05:46:33 <quicksilver> blipped: your problem is that your indentation is wrong
05:46:43 <quicksilver> perhaps it was a tab/spaces thing or a copy/paste error
05:46:53 <jle`> gnoynat: have not looked at lyah for that, but according to http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Foldable.html
05:46:54 <blipped> Must have been.
05:46:57 <quchen> It's tab/spaces. Do not use tabs.
05:46:57 <fizruk> jle`: the article is interesting, thanks for sharing!
05:47:00 <jle`> the minimal definition is either foldMap or foldr
05:47:06 <quicksilver> but the (l:_) needs to be on the same column as (f:_)
05:47:06 <jle`> fizruk: np!
05:47:11 <blipped> I have changed sublime now to replace tabs with spaces.
05:47:29 <quchen> blipped: See here, https://github.com/quchen/articles/blob/master/fbut.md#tabs-vs-spaces
05:47:31 <jle`> gnoynat: i assume you are familiar with 'default implementations' for typeclasses?
05:47:48 <blipped> thank you much everyone.
05:48:09 <fizruk> gnoynat: try implementing foldMap via folder and vice versa
05:48:11 <blipped> seriously one of the most helpful coding channels.
05:48:29 <gnoynat> jle`: when i type :i F.Foldable, i saw 6 functions: fold, foldMap, foldr, foldl, foldr1 and foldl1
05:48:47 <jle`> gnoynat: there are 6 functions, but there are 'default implemtnations' for them
05:48:52 <jle`> just like if you look at Eq
05:49:02 <jle`> there are two functions, (==) and (/=)
05:49:10 <jle`> but if you define (==), then the compiler will know how to (/=)
05:49:23 <jle`> because there is a default implementation for (/=) based on what you define as (==)
05:49:34 <jle`> alternatively, if you define (/=), the compiler will know how to (==)
05:49:34 <haasn> http://www.nand.wakku.to/base/Data-Foldable.html
05:49:42 <haasn> Minimal complete definition: foldMap | foldr
05:49:44 <jle`> because there is a default implementation for (==) based on what you define as (/=)
05:50:05 <quchen> GHC 7.8 will also support warnings if your definition doesn't meet the minimum.
05:50:11 <gnoynat> yes, i know the typeclass have default implement, but i just can not to see in ghci
05:50:12 <jle`> so if you define foldMap, there are default implementations for fold, foldr, foldl, foldr1, and foldl1
05:50:29 <jle`> gnoynat: yeah, ghci won't help you too much there for now :/
05:50:40 <jle`> but 7.8 has better warnings if you do not implement all of the defaults
05:50:47 <jle`> for now the best bet is to just look at the documentation
05:50:59 <jle`> (which you should still do in 7.8, but...)
05:51:42 <jle`> so i gues s"how did the author know" would be he read the documentation
05:51:46 * hackagebot h2048 0.1.0.1 - a haskell implementation of Game 2048  http://hackage.haskell.org/package/h2048-0.1.0.1 (javran)
05:52:27 <gnoynat> jle`: thanks!
05:53:03 <b0bbi10> jle`: after thinking about it, it actually makes sense to put the new value as the first parameter. many functions take some new value as the first parameter and something to be modified as the second one
05:53:16 <greg> in hackage i see the following definition
05:53:27 <greg> fromUrl :: String -> IOSArrow XmlTree (NTree XNode)
05:53:29 <jle`> b0bbi10: :)
05:53:51 <greg> then i find out that you can just as easily write
05:54:07 <greg>  fromUrl :: String -> IOSArrow XmlTree XmlTree
05:54:12 <yesthisisuser> I don't understand in the context of server applications, why network sockets are referred to as "scarce" resources
05:54:38 <greg> is there some convention in documentation whereby the last argument is expanded to include a constructor
05:54:41 <merijn> yesthisisuser: Because there's a kernel limit on how many file descriptors/sockets you can have
05:55:29 <merijn> yesthisisuser: If you have hundreds of thousands of clients your kernel may run out and you can't accept new connections
05:55:59 <yesthisisuser> merijn: ok.. hmm.. thanks
05:56:14 <quchen> merijn: Is the kernel limit arbitrary/historical, or is there a deeper reason for it?
05:56:36 <merijn> quchen: You need to reserve buffers, etc. for it
05:56:41 <quchen> A couple of thousand connections at a time don't seem so absurd nowadays
05:56:59 <merijn> quchen: I said hundreds of thousands, i.e. several 100k
05:57:04 <yesthisisuser> so the problem with lazy I/O is that it relies on garbage collection to free these or
05:57:10 <merijn> yesthisisuser: Yes
05:57:14 <greg> also ghc when suggesting a type for my untyped function, gave the most deconstructed definition via traversing type definition, but i dont want the detail
05:57:30 <merijn> yesthisisuser: Well, not just relying on GC to free them, but also that it might be very unpredictable when GC happens
05:57:53 <merijn> yesthisisuser: Imagine I do "getContents :: IO String", the Handle won't be GCed until I either GC the string or read until the end of it
05:58:01 <merijn> yesthisisuser: All the time in between it's kept
05:58:16 <merijn> quchen: FreeBSD lets you configure the limit, but that's a boot time parameter
05:58:39 <quchen> There are other problems, e.g. that side effects are triggered from pure code. `x <- getContents` will evaluate `getContents` as you force x.
05:58:44 <merijn> quchen: Presumably linux will let you tune it too, but not necessarily at runtime.
05:59:32 <quchen> merijn: Oh, I was thinking about sockets all the time, and wondered about the "several 100k".
06:01:47 * hackagebot h2048 0.1.0.2 - a haskell implementation of Game 2048  http://hackage.haskell.org/package/h2048-0.1.0.2 (javran)
06:03:14 <bahamas> I've found an actual error in LYAH. import qualified Foldable as F instead of import qualified Data.Foldable as F
06:06:24 <yesthisisuser> that is outrageous
06:12:09 <haasn> bahamas: it's just outdated
06:18:03 <bahamas> haasn: ah. so it used to be available as Foldable
06:18:37 <haasn> bahamas: yes
06:19:02 <haasn> bahamas: at some point in time, they moved from top level modules to second-level modules (behind Data. or Control., usually)
06:19:15 <bahamas> haasn: smart move
06:19:34 <haasn> (Except for the Data./Control. stuff)
06:24:49 <yorg> http://www.marketglory.com/strategygame/galahad1st for all you online gamers out there, if you didn't already, use this link to register on MerkatGlory a free2play financial strategy game where virtual currency can be converted into real money. It starts out slow but in time you can turn a good profit
06:37:51 <AaronFriel> Last night I asked a question of #haskell - what is the best way to expose an asynchronous stream API in a library *meant to be consumed by other libraries and applications*
06:38:13 <merijn> AaronFriel: Pipes and/or conduits?
06:38:23 <AaronFriel> I don't want to limit it to one or the other if possible :/
06:38:34 <AaronFriel> Nor do I want the boat-load of dependencies both bring in
06:38:38 <AaronFriel> Well, not so much pipes
06:38:43 <AaronFriel> But Conduit has a fair share
06:39:27 <AaronFriel> Some people have suggested simply exposing a handle-like API, with a function that will produce values
06:39:52 <AaronFriel> io-streams works really well with that too, and there seem to be a lot of connectors - but io-streams strangely has even more dependencies than pipes or conduit
06:47:41 <skypers_> hi
06:48:25 <merijn> AaronFriel: Right, one possible approach is to implement a low level API that's ugly and then wrap that using pipes/conduits/whatever, which would allow others to produce their own wrapper for their flavour of the month iteratee library
06:49:08 <AaronFriel> merijn: some people proposed last night exposing just a handle-like API and having another cabal package provide conduit/pipes?
06:51:53 * hackagebot monad-journal 0.2.1.1 - On-the-fly logging typeclass and monad transformer  http://hackage.haskell.org/package/monad-journal-0.2.1.1 (DimitriSabadie)
06:53:48 <merijn> AaronFriel: Right, that's what I meant
06:54:46 <merijn> AaronFriel: Basically implement "mypackage-internal" and then implement "mypackage-pipes" (or whichever has your personal preference to use) and if someone else wants to use something different, like conduit, they can just write it themselves
06:55:24 <merijn> AaronFriel: Alternately, provide a single package that exposes your preferred interface, but also exports an .Internal module that others can use to implement their own wrapping
06:55:31 <b0bbi10> is Haskell implemented in C?
06:56:04 <AaronFriel> b0bbi10: the GHC compiler is mostly self-hosting (written in Haskell)
06:56:29 <k00mi> the runtime system is written in C
06:56:44 <geekosaur> core parts of the runtime / compiler primitives are in C and/or Cmm
06:56:45 <merijn> k00mi: Cmm and not even entirely
06:56:45 <AaronFriel> b0bbi10: but there are large parts of compiling the compiler that require other languages, namely C and Perl, if I recall correctly.
06:56:54 <b0bbi10> ah ok
06:57:10 <merijn> AaronFriel: Perl was for the evil mangler, which is deprecated (or doesn't even exist anymore?)
06:57:10 <geekosaur> perl is only used to set up the build environment these days
06:57:22 <AaronFriel> merijn: I don't know, I think the evil mangler lives on in the hearts of many.
07:00:28 <NathanC> Is there a way for me to handle the threadKilled function so I can perform some action? I have some cleanup to do when a thread is killed
07:01:00 <merijn> NathanC: Look into forkFinally
07:02:14 <NathanC> I have, it doesn't quite work. The thread I'm needing to kill has internal refrences to other threadIDs
07:02:47 <NathanC> forkFinally allows for a value returned by the thread when it exits normally, but gives an exception otherwise
07:03:32 <NathanC> Which, I guess, makes perfect sense in a declarative setting. Still, I'm trying to find a graceful way to do this.
07:03:54 <merijn> NathanC: What does it matter that it has internal references to other threadIDs?
07:04:07 <NathanC> I need them to be killed when this thread is killed
07:04:17 <merijn> NathanC: Just use bracket?
07:04:21 <NathanC> ?
07:04:48 <merijn> NathanC: Control.Exception has a bunch of functions like bracket which let you run finalizers when an exception happens
07:05:10 <geekosaur> so your thread should catch ThreadKilled, kill the other threads, and re-throw ThreadKilled. I think. bracket is useful for this
07:05:16 <merijn> NathanC: They're the equivalent of "try { } except e { cleanup(); rethrow e; }"
07:05:32 <merijn> There's even a finally function
07:05:47 <NathanC> That looks perfect.
07:06:09 <NathanC> How would I use it? I have to admit, I've never really delved into haskell exceptions
07:06:19 <merijn> @hoogle finally
07:06:20 <lambdabot> Control.Exception.Base finally :: IO a -> IO b -> IO a
07:06:20 <lambdabot> Control.Exception finally :: IO a -> IO b -> IO a
07:06:20 <lambdabot> Control.OldException finally :: IO a -> IO b -> IO a
07:06:58 <merijn> NathanC: "finally x y" says, "run x, when x returns or an exception occurs, run y"
07:06:58 <quchen> or onException, which is `finally` but only run in case of an exception.
07:07:19 <skypers_> is there a way to explicitely instantiate Typeable?
07:07:21 <geekosaur> http://lambda.haskell.org/platform/doc/current/ghc-doc/libraries/base-4.6.0.1/Control-Concurrent.html#v:killThread
07:07:33 <geekosaur> you mean, specify your own? no
07:07:36 <merijn> skypers_: Not anymore, it disappeared in 7.8
07:07:37 <skypers_> arf
07:07:44 <merijn> skypers_: You need to derive Typeable now
07:07:44 <skypers_> I have a wrapper over Int
07:07:50 <geekosaur> there is StandaloneDeriving though
07:08:05 <skypers_> and I‚Äôd like it to show as ‚Äúint‚Äù, not ‚ÄúInt‚Äù
07:08:17 <skypers_> I guess I‚Äôll write my own typeclass for that
07:08:24 <NathanC> It looks like I'd actually like to use bracket, since I'm aquiring and releasing a recourse.
07:08:29 <NathanC> resource*
07:08:37 <skypers_> ok, thank you
07:08:39 <merijn> NathanC: Hence my initial suggestion :)
07:08:49 <b0bbi10> why is the syntax to function pattern with record syntax like value = param instead of param = value? http://ideone.com/jh1lzw
07:08:55 <b0bbi10> s/to/of
07:09:08 <pilu> hi, i want to deduce the semantic of the following expression
07:09:13 <pilu> (/:/) f g x = (f x) (g x)
07:09:13 <pilu> xnull f [] = []
07:09:13 <pilu> xnull f xs = f xs
07:09:13 <pilu> pp1 = zip /:/ xnull tail				
07:09:40 <pilu> i don't know what the function pp1 does
07:09:59 <NathanC> merijn: Well, this looks splendid, thank you kindly.
07:10:15 <merijn> pilu: It parses as "((zip) /:/ (xnull tail))"
07:10:28 <NathanC> I'm having a lot of fun with a massively multi-threaded program
07:10:35 <b0bbi10> ^ that looks like assignment in the opposite direction
07:10:48 <merijn> NathanC: tbh, haskell exceptions are pretty easy and similar to exceptions in other languages, if you accept that you can only reliably throw/catch them in IO
07:11:22 <NathanC> They seem very easy to work with so far.
07:12:31 <NathanC> I really like using threads as primitive entities, there's an overhead but it allows for a really semantically nice system
07:12:34 <merijn> NathanC: One minor catch is that "throw" is nasty and should (almost) never be used, instead use throwIO (or is it called throwM)
07:12:56 <monochrom> it is called throwIO
07:13:13 <NathanC> :t throw
07:13:14 <lambdabot> Exception e => e -> a
07:13:30 <merijn> NathanC: This because "throw :: Exception e => e -> a", this means it can be used in pure code, but due to laziness it may end up being evaluated "outside" your bracket
07:13:49 <NathanC> Makes sense
07:13:55 <pilu> merijn: yes, but the type of pp1 is [b] -> [(b, b)]
07:14:10 <merijn> "throwIO :: Exception e => e -> IO a", here the IO enforces the "throwIO" gets forced, making sure it can't escape your bracket/etc.
07:14:30 <NathanC> Couldn't you use a seq to force strictness?
07:14:40 <merijn> NathanC: Mayhaps, but it'd be tricky :)
07:14:59 <merijn> NathanC: Better make your live easy as bracket and friends already want IO actions anyway :)
07:15:39 <NathanC> The IO monad is certainty a useful beast
07:16:00 <NathanC> I've been dabbling in haskell for awhile, but now I'm at the point where I actually want to sit down and Systematically learn it.
07:16:55 * hackagebot lens 4.1.1 - Lenses, Folds and Traversals  http://hackage.haskell.org/package/lens-4.1.1 (EdwardKmett)
07:16:56 <NathanC> The declarative mindset is definitely starting to be more natural to me than imperative in a lot of ways, I find myself wanting to express it when tutoring other students in CS, but sadly my university is very imperative.
07:17:35 <ski> NathanC : `seq', or `pseq' or `evaluate'
07:19:01 <zzzzzzzz> pilu, pp1 is written pointfree, u can write it as pp1 xs = ((zip) /:/ (xnull tail)) xs
07:19:07 <ski> hm.. i wonder whether we'd like a variant of `evaluate' which used `pseq' instead of `seq' ?
07:21:42 <pilu> zzzzzzzz: why the type of (/:/) is (t2 -> t1 -> t) -> (t2 -> t1) -> t2 -> t ???
07:22:51 <zzzzzzzz> f must be a function that takes two parameters and g takes one and both get the x
07:23:32 <zzzzzzzz> f gets the x and the result of the (g x), right?
07:23:42 <zzzzzzzz> g just gets the x
07:25:26 <exicer> Why are there so rarely examples in packages on hackage? It makes it so much harder to work out what is going on!
07:26:15 <merijn> exicer: Because people aren't getting paid to write them and thus can't be arsed?
07:26:25 <tdammers> exicer: unlike untyped languages, haskell gives you a lot of information in type signatures.
07:26:40 <tdammers> exicer: lots of package authors feel that this is enough and call it a day
07:27:11 <exicer> Its not like they have an obligation to do so, of course!
07:27:40 <merijn> I mean, everytime I have to document things I wrote for my personal use it's quite a painful battle
07:27:52 <merijn> If I don't have any users other than me yet, why bother?
07:28:01 <exicer> That is just it though - the documentation is usually awesome. Why not just have some simple use cases
07:28:04 <exicer> ?
07:28:15 <exicer> I suspect it is just because I'm not so good at haskell
07:28:29 * ski notes pilu and zzzzzzzz playing with starlings
07:29:18 <tdammers> exicer: there's probably a certain elitism playing as well
07:29:44 <zzzzzzzz> ski, starlings?
07:29:47 <ski> exicer : perhaps it's sortof a backlash from types being relatively useful. so that people other don't bother with other forms of documentation
07:30:04 <ski> zzzzzzzz : the `S' combinator
07:30:42 <zzzzzzzz> oh i did not even recognize it, thanks :)
07:30:46 <ski> @where mockingbird
07:30:46 <lambdabot> "To mock a mockingbird : and other logic puzzles including an amazing adventure in combinatory logic" by R. M. Smullyan, "To Dissect a Mockingbird: A Graphical Notation for the Lambda Calculus with Animated Reduction" at <http://dkeenan.com/Lambda/> by David C. Keenan. Also see `smullyan'
07:31:00 <joneshf-laptop> exicer, i dont believe that to bethe case
07:31:00 <ski> see the latter one ^
07:31:12 <exicer> I can understand that the type system helps.. I don't know. I can eventually work out what I need to do, but in the end I am just replicating what is probably the most simple use case anyway
07:31:21 <joneshf-laptop> exicer, some people are just lazy
07:31:31 <exicer> Yeah, well I don't have anything against lazyness :p
07:31:49 <exicer> I am obviously very grateful that they have even made these packages
07:31:52 <tdammers> you may also see a difference because a lot of hackage is really just personal-use stuff that people throw on hackage for convenience
07:31:55 <joneshf-laptop> exicer, you can make it better for thenext person though, and submit a patch with that suggestion
07:32:04 <tdammers> I know I do
07:32:18 <zzzzzzzz> ski, oh nice, thank you never saw that one
07:32:32 <ski> yw
07:32:33 <zzzzzzzz> i mean the paper, link
07:32:51 <tdammers> it's just easier to upload a package to hackage than to pull it in from some repository and then install it into the "real" project manually, and then remember that you've done it, etc.
07:33:16 <exicer> I've never uploaded anything to hackage, so I don't realy know how that works
07:33:39 <tdammers> cabal sdist; cabal upload /dist/whatever/path/cabal-sdist/gave/you
07:33:45 <tdammers> that's basically it
07:34:09 <tdammers> and then in the other project, you just add your package to the .cabal file, and cabal takes care of it
07:34:34 <exicer> hmm, that does seem nice
07:36:55 <hemanth> I would be very happy if anyone could help to make a good syllabus for https://github.com/hemanth/haskell-rascal/ ;)
07:46:21 <hemanth> meow?
07:54:35 * ski meows back
07:56:22 <fizbin> It's quiet, so I'll ask: anyone see any issues with how I implemented Applicative and Functor in https://github.com/fizbin/hxt/commit/7de29a6f0af2ffb338622bdeb13225d3465b617a ?
07:58:16 <fizruk> fizbin: why not use monad transformers?
07:58:28 <fizbin> How?
07:58:44 <monochrom> why is monad transformer relevant?
07:58:53 <fizruk> i see
07:58:56 <fizbin> That is, I don't understand the question because I ... what monochrom said.
08:01:31 <Krakarn> fizbin what is the type of Unpickler?
08:01:33 <fizruk> hm... if error occurred, don't you have (Left (msg, st), st) ?
08:02:33 <fizruk> fizbin: I mean, why store St in UnpickleErr if is is already stored (in runUP result type)
08:02:35 <fizbin> fizruk: Not necessarily the same St value.
08:03:18 <fizbin> Krakarn: click on the expansion symbol between the line numbers. Unpickler is defined in that file, above where I made my changes.
08:03:20 <fizruk> fizbin: then why not ErrorT (String, St) (StateT St) ?
08:03:20 <Krakarn> nvm :)
08:03:49 <fizruk> fizbin: I thought the state in error is last successful state
08:04:44 <fizruk> @unmtl ErrorT (String, s) (StateT s) a
08:04:44 <lambdabot> (StateT s) (Either (String, s) a)
08:05:05 <fizruk> seems pretty much like Unpickler to me
08:07:37 <joneshf-laptop> unmtl?
08:07:40 <joneshf-laptop> that's a thing?
08:07:44 <fizbin> fizruk: Except that that thing's MonadError instance is different.
08:08:00 <monochrom> unmtil takes away the newtypes for you
08:08:31 <monochrom> but it only knows how to do it for mtl stuff
08:08:48 <fizruk> fizbin: new type, derive needed instances, define your own MonadError instance (not sure that's good)
08:09:12 <fizbin> At that point, why use monad transformers?
08:09:58 <fizruk> to write one deviated instance only, I guess
08:10:11 <ski> @check fizruk == fizbin
08:10:13 <lambdabot>  *** Failed! Falsifiable (after 1 test):
08:10:24 <joneshf-laptop> right?
08:10:44 <joneshf-laptop> it's like two people but one people
08:11:23 <alcabrera> hemanth: hey there! re: haskell-rascal - I'd be happy to help. Where would you like to start with teaching haskell?
08:12:27 <fizbin> joneshf-laptop: No, it's like two totally distinct people with the same first name and different last name.
08:12:37 <fizbin> It's only confusing if you let it be.
08:12:50 <ski> fizruk : unfortunately `unmtl' seems broken atm
08:13:06 <ski> (it doesn't recursively unwrap, like it used to)
08:13:34 <fizruk> :(
08:13:42 <hemanth> alcabrera, planning to go in a seq, string, list, tuples, functions, arrows, monads so on....
08:14:02 <hemanth> what say?
08:14:17 <fizbin> Anyway, I wasn't sure about implementing (<*>) on top of one stage of execution and then fmap like that, but the types worked out, so...
08:15:01 <fizruk> fizbin: the instances seem ok to me
08:15:06 <alcabrera> hemanth: that sounds reasonable. How deep will you go into each topic? Once you wander into arrows/monads, there's a lot that can be said. Do you think the style of teaching will be more "learn by doing" or "intermix with theory"?
08:15:32 <fizbin> I also got lost trying to prove all the applicative laws.
08:16:06 <fizbin> Though I'm pretty sure that (<*>) === ap in those instances.
08:16:14 <hemanth> alcabrera, I would vote for intermix with bit of theory and a lot of learn by doing.
08:16:15 <fizruk> fizbin: there's a nice post I recently encountered: http://blog.ezyang.com/2012/08/applicative-functors/
08:16:44 <fizbin> And once (<*>) === ap and return === pure, I think the applicative laws follow from the Monad laws.
08:16:48 <ski> preflex: xseen ezyang
08:17:33 <fizruk> fizbin: Monoidal laws might be easier to prove/understand/memorize, I guess
08:17:46 <hemanth> alcabrera, We could create levels maybe, like intro, intermediate, advance ?
08:25:32 <alcabrera> hemanth: re: levels - I like the idea. In part, I'm especially curious about the intro level atm.
08:26:15 <alcabrera> hemanth: in the sense that - there can be intro level for someone who has never programmed before, and there can also be intro-level for someone who has never done typed, FP before, and so forth.
08:26:31 <alcabrera> extremely valuable way to lower barriers to entry for many different entry points
08:27:33 <ski> sounds slightly related to the language levels in DrRacket
08:28:22 <merijn> ski: We need that for Prelude, so the "expert level" Prelude gets Foldable, Traversable, etc. and map :: Functor f => (a -> b) -> f a -> f b :p
08:28:35 <alcabrera> ski: oh? I should take a look at that. I've only dabbled in Racket-land so far.
08:28:42 <hemanth> alcabrera, haskell as a first language seems very rare, we can stick to never done typed, FP before...?
08:28:48 <hemanth> ski, link handy ?
08:29:02 <fizruk> merijn: fantastic idea
08:29:28 <joneshf-laptop> alcabrera, the one who's never done fp sounds more like intermediate if you spin it right
08:30:23 <ski> hemanth : <http://racket-lang.org/>
08:30:36 <alcabrera> joneshf-laptop: that's true. it could well be someone who's written servers and clients for years but hasn't worked in FP. :)
08:31:10 <hemanth> ski, yeah, was looking into http://docs.racket-lang.org/drracket/
08:31:23 <joneshf-laptop> hemanth, that picture has been my desktop background for years :D  though it's the one with the red lambda
08:32:23 <hemanth> joneshf-laptop, kool! You can send a PR for red lambda ;) heh heh
08:33:07 <joneshf-laptop> sure, if you'd like
08:33:20 <ski> joneshf-laptop : talking about any of the pics at <http://www.barzilay.org/random/CS212.html> ?
08:35:30 <hemanth> :)
08:35:33 <magicman> lambdabot:
08:35:46 <magicman> ... oops.
08:36:47 <joneshf-laptop> hemanth, there you go
08:37:32 <joneshf-laptop> ski, https://raw.githubusercontent.com/joneshf/haskell-rascal/eb8c8f405d8cf7ed4b37d4608fb51888a69052dc/imgs/swahili.png
08:38:19 <hemanth> joneshf-laptop, waiting for the PR :)
08:38:28 <tero-> interactive Haskell lectures on browser with exercises would ensure ultimate learning experience
08:38:35 <ski> joneshf-laptop : ok
08:39:57 <joneshf-laptop> hemanth, it didn't show up?
08:40:56 <joneshf-laptop> hemanth, https://github.com/hemanth/haskell-rascal/pull/1
08:41:12 <monochrom> what is "interactive lecture"? how expensive is it to produce one? how much money are you ready to pay?
08:42:08 <monochrom> hell, same question on "ultimate learning experience"
08:42:10 <hemanth> joneshf-laptop, merged, thanks :) I was on the wrong repo, my bad.
08:42:39 <monochrom> even "ultimative movie experience" that is blu-ray movies cost a few dollars
08:44:49 <tero-> monochrom: I'll try to be a bit more concrete :)
08:45:14 <monochrom> actually I just need you to be concrete on how much money you will pay
08:45:25 <tero-> monochrom: can't I dream?
08:45:33 <monochrom> ok, you can dream
08:46:40 <tero-> interactivity by offering programming exercises of suitable difficulty level and automatically grading them
08:46:48 <hemanth> joneshf-laptop, updated the readme with the red logo, thanks :)
08:47:32 <tero-> IDE in the browser, so you don't have to install Haskell platform
08:47:35 <monochrom> tryhaskell.org does not have lecture but has exercises and immediate automatic something
08:47:58 <tero-> oh, that's cool
08:47:58 <monochrom> FP Complete has an IDE in the browser. it makes you pay, too.
08:48:53 <tromp> a very reasonable $75 / year
08:48:53 <hemanth> :)
08:51:00 <Averell> 99
08:51:30 <tdammers> Averell: maybe that's the exchange rate for very-reasonable-dollars to US dollars
08:51:38 <bartavelle> :)
08:52:52 <Averell> i rather hope reasonable years are shorter.
08:53:23 * hemanth needs some rest, cya soon Haskell gurus and thank you for the support! :)
08:58:17 <alcabrera> hemanth: take care. :)
09:02:08 * hackagebot creatur 5.2.8 - Framework for artificial life experiments.  http://hackage.haskell.org/package/creatur-5.2.8 (AmyDeBuitleir)
09:02:17 <cariveri> hi
09:03:18 <cariveri> gchi complains about data Card 2 | 3 | 4 ..  | Ace  by "Illegal literal in type (use -XDataKinds to enable): 2"
09:03:29 <cariveri> why cant I use 2 as constructor ?
09:03:49 <tdammers> because 2 is already a number literal
09:05:29 <cariveri> ok. what would be a good way to circumvent this problem. I could use words like ONE , TWO ... but then I would need to define a show function to map back.
09:06:11 <quchen> data Card = Card2 | Card3 | ‚Ä¶
09:06:52 <quchen> Also note that Show is not for prettyprinting, https://github.com/quchen/articles/blob/master/fbut.md#show-is-not-for-prettyprinting
09:06:58 <cariveri> quchen: ok. and the ordering? is deriving ORd enough for that?
09:07:08 <cariveri> *Ord
09:07:13 <peteretep> data Card = Card Suite Face
09:07:30 <peteretep> data Face = King | Queen | Jack | N Int
09:07:48 <quchen> cariveri: Deriving Ord (and Eq and Show) is fine.
09:08:04 <tdammers> peteretep: that does allow things like N (-10933425) though
09:08:28 <quchen> tdammers: Implicit mod 8? :-)
09:08:36 <quchen> Eh, 9
09:08:37 <cariveri> peteretep: yes. so I cannot cosntruct a subset of numbers?
09:13:20 <t7> yeah but it has to be mod 256, or 2^16, 2^32 etc
09:13:24 <t7> :)
09:16:00 <geekosaur> haskell does compile time typing, and subsets tend to require some part of typing to be done at runtime. there *is* work being done on this, but it's not straightforward
09:16:23 <peteretep> cariveri: You could have a constructor that perofrms that
09:22:11 * hackagebot creatur 5.2.9 - Framework for artificial life experiments.  http://hackage.haskell.org/package/creatur-5.2.9 (AmyDeBuitleir)
09:23:51 <hemanth> alcabrera, you too! :)
09:23:59 * hemanth zzz,,,
09:24:29 <cariveri> ok. then I go with the other solution. ONE | TWO ...its alright.
09:32:40 <cariveri> does haskell allow infix data constructors?  lie data Card = Face OF Suit  where OF is the constructor?
09:33:32 <Kinnison> cariveri: constructors are just functions
09:34:02 <Kinnison> cariveri: So `OF` would work at least
09:34:39 <geekosaur> carivery: infix has to be a symbol (or a function wrapped in ``), and symbols have an additional constraint that pattern matching needs to bew able to identify constructors syntactically so infix constructors must start with :
09:34:53 <geekosaur> (or, for ``, start with uppercase as usual for "word" constructors)
09:35:02 <Fuuzetsu> chrisdone made something cool again
09:36:20 <cariveri> ok cool. did not see those backticks before in data contructors
09:38:09 <geekosaur> backticks always enable a prefix function-like thing to be an operator (type permitting), parentheses always enable an operator to be used as a function (hence things like (+); this is also where sections like (1+) come from)
09:39:04 <sclv_> ?tell mzero ping
09:39:04 <lambdabot> Consider it noted.
09:39:48 <cariveri> ok thanks guys.
09:40:30 <dmj`> can anyone explain why cabal sandboxes can't force an uninstall?
09:40:32 <dmj`> cs hc-pkg unregister text-1.1.0.1 --force
09:40:37 <dmj`> cs == cabal sandbox
09:40:45 <dmj`> cabal: unrecognized option `--force'
09:45:19 <byorgey> dmj`: maybe try   cs hc-pkg unregister text-1.1.0.1 -- --force
09:45:58 <byorgey> I think the problem is that cabal thinks --force is a flag for it, rather than something to be passed along to hc-pkg
09:47:13 * hackagebot shelly 1.5.1 - shell-like (systems) programming in Haskell  http://hackage.haskell.org/package/shelly-1.5.1 (GregWeber)
09:49:11 <dmj`> byorgey: thanks, I will try it once cabal stops installing things, trying to reinstall snap-server w/ with a -fopenssl flag, causes breakages that I'm just going to force
09:49:21 <tnks> oh yeah, this question came up. . . for companies with some internal-sensitive code, what tools do people use for making internal "Hackage"-style repos?
09:50:55 <byorgey> I think you can literally set up your own Hackage instance
09:52:34 <tnks> byorgey: is that done commonly?
09:53:12 <tnks> I know Haskell is probably less in proprietary industrial settings, but I'm thinking there's enough that this has probably been done.
09:53:27 <byorgey> I don't know how common it is.  I just know that I have heard of it being done.
09:53:29 <quicksilver> I doubt people bother
09:53:33 <quicksilver> in general
09:53:45 <quicksilver> it's not that hard to manually install a couple of packages
09:53:53 <tnks> quicksilver: I know. . . perhaps this is what happens when people have too much experience with Java and other ecosystems.
09:54:19 <quicksilver> I don't think many companies have actual cooperating sets of 10+ proprietary haskell packages
09:54:26 <tnks> also, I guess cabal allows you to easily enough link sources that have been checked out into different directories.
09:54:30 <quicksilver> in fact I'd be surprised if more than, say, 3 companies did.
09:54:44 <tnks> quicksilver: yeah, I know.
09:54:54 <tnks> okay, well, I thought I'd ask.
09:55:22 <dmj`> tnks: standard charter has 1M lines of haskell code and they have their own internal hackage
09:55:24 <quicksilver> I believe you can do it with hacakge2 if you want to, though
09:55:37 <tnks> dmj`: good to know.
09:56:09 <dmj`> byorgey: you're a life saver thanks. "-- --force" worked great
09:56:34 <tnks> dmj`: is there any public docs on how to set up a public Hackage in a least-hacky way?
09:57:33 <byorgey> dmj`: great!
09:59:04 <dmj`> tnks: maybe try cloning, building, and reading through the source: https://github.com/haskell/hackage-server
09:59:53 <tnks> dmj`: k.
10:19:37 <DistantStar> Hello Haskellers
10:22:36 <Fuuzetsu> greetings
10:22:48 * ski notes a distant star
10:24:33 <int-e> ski: that message will take many years to get there.
10:24:53 <mzero> yp
10:24:55 <ski> well yes
10:24:55 <mzero> yo
10:25:25 * ski didn't think of it as a message to reach there, though
10:27:17 <Fuuzetsu> anyone with OSX and some time to spare? We're hitting a nasty problem with Haddock and would like to confirm if it's OSX specific problem
10:27:31 <mzero> I might be able to help
10:27:32 <Fuuzetsu> basically it's grab 7.8 rc2 and try to build docs for the ‚Äòfree‚Äô package
10:27:42 <mzero> ah - I can try that tonight
10:27:48 <Fuuzetsu> awesome
10:27:52 <mzero> are you using the haddock that is in the 7.8 package?
10:27:59 <mzero> or are you using some haddock you have installed?
10:28:35 <Fuuzetsu> I tried with the Haddock that will ship later in the day (that we just released) but please try with the one that comes with the rc2
10:29:07 <mzero> what‚Äôs the problem?
10:29:15 <carlosgaldino> how can I know which package's version is installed?
10:29:20 <Fuuzetsu> http://trac.haskell.org/haddock/ticket/284
10:29:33 <Fuuzetsu> pretty big deal if it cripples everyone on OSX
10:29:47 <Fuuzetsu> carlosgaldino: you can use ghc-pkg list
10:29:53 <Fuuzetsu> or use cabal list
10:30:11 <carlosgaldino> Fuuzetsu: thanks
10:31:37 <Fuuzetsu> I don't know anyone with an OSX machine so this is going to be unfun to try and fix
10:33:05 <fizbin> Fuuzetsu: I have one here. What do you need me to try?
10:33:28 <mzero> so - I have to get HP building docs next‚Ä¶ and it will need to build docs for Cabal, parsec, network, and zlib ‚Äî all which are listed as failing ‚Äî is the problem now isolated to package free, or are those packages also still affected?
10:33:30 <ArneL> already got ghc 7.8 rc2 and OS X 10.9.2, what do I have to do? Just grap the package from github, then 'cabal configure && cabal haddock'?
10:34:34 <Fuuzetsu> fizbin: ArneL: yep, git clone git@github.com:ekmett/free.git then cabal configure && cabal haddock
10:34:47 <Fuuzetsu> maybe even do it all in a sandbox
10:35:16 * armlesshobo gets his shovel and pail
10:35:18 <fizbin> Okay. Need to go get ghc 7.8 rc2 for this box first...
10:35:51 <Fuuzetsu> (of course install deps first, so sandbox is probably the best idea)
10:36:06 <Fuuzetsu> cabal sandbox init && cabal install --only-dependencies && cabal configure && cabal haddock
10:36:07 <Fuuzetsu> or something
10:36:25 <Fuuzetsu> cabal install --only-dependencies --enable-documentation
10:36:26 <hasenov> hello, how can I import a module only if the file exists?
10:36:45 <Fuuzetsu> hasenov: you can't, it has to exist
10:36:46 <hasenov> and if the file doesnt exist, execute another action
10:37:06 <hasenov> ie, check to see if it exists before importing
10:37:11 <Fuuzetsu> there is no conditional module loading
10:37:20 <mzero> hasenov: are you trying to make your code compile in several differnent dependency environments?
10:37:33 <ArneL> dependencies are installing.
10:37:43 <thetallguy> hasenov: you would probably have to fiddle with something in the cabal file
10:37:48 <mzero> or to put it another way, how will your code handle the module being absent?
10:38:09 <thetallguy> hasenov: and then use CPP conditional to include the import or not
10:38:28 <ArneL> When were at it, is 'cabal install -j' supposed do work? Regularly segfaults for me
10:38:42 <hasenov> mzero: i am writing xmonad config file, and have a generic one I use for several desktops I own
10:38:48 <thetallguy> hasenov: but it seems like your supposition that you need to do so is flawed.
10:38:56 <thetallguy> s/like/likely/
10:39:09 <mzero> ah - then yes, -XCPP is the way to go - and then use #if style conditionals
10:39:21 <hasenov> but have one machine which has slightly different keybindings and workspaces, so I'd like in the parent config file, to check if the file exists before loading it
10:39:36 <hasenov> and if not, to just use the default config
10:39:49 <mzero> can‚Äôt really do it that way -
10:40:12 <mzero> and I‚Äôm not sure the environment that Xmonad uses to load code‚Ä¶ anyone? Is it compiled, or loaded using one of the dynamic loaders for GHC?
10:41:33 <hasenov> mzero: it is compiled
10:42:23 <hasenov> is it possible to use System.Directory to check if file exists?
10:42:24 <ArneL> haddock generation does not work for me: http://lpaste.net/101667
10:42:41 <ArneL> Fuuzetsu: haddock generation does not work for me: http://lpaste.net/101667
10:42:55 <mzero> no - you can‚Äôt call any code while it is compiling - unless you use template haskell‚Ä¶
10:43:24 <hasenov> oh, gotcha
10:43:50 <Fuuzetsu> ArneL: Noted. Did you try in a sandbox or not?
10:44:12 <mzero> if you can arrange for a -D define at compile time‚Ä¶ you can always have the module there, but have it‚Äôs contents conditional via #ifdef
10:44:58 <ArneL> Fuuzetsu: Sandbox
10:45:02 <Fuuzetsu> right
10:45:05 <edwardk> Fuuzetsu: looks like it isn't just me =)
10:45:11 <hasenov> mzero: but then ud have to rewrite the xmonad binary right?
10:45:12 <Fuuzetsu> I think I have to go and cry on cabal-devel again
10:45:43 <Fuuzetsu> this is a big problem but I can't exactly fix what I can't replicate and I'm pretty sure it's a cabal issue‚Ä¶
10:45:44 <edwardk> i have a coworker trying it as well, but he's still downoading stuff
10:45:53 <mzero> hasenov: no idea - depends on what arrangements Xmonad made for passing environment into the config compilation
10:46:41 <ArneL> Fuuzetsu: anything else I can do?
10:48:09 <Fuuzetsu> ArneL: I think trying with older cabal(-install) would be great but I have no idea about downgrading that and it seems like it might break everything ever
10:48:55 <mzero> ArneL:  can you run that with whatever verbose logging level gets cabal to spit out the command lines? I think looking at the haddock invocation will be a big help
10:49:19 <edwardk> mzero: i have that here.
10:49:45 <edwardk> @hpaste
10:49:46 <lambdabot> Haskell pastebin: http://lpaste.net/
10:50:17 <edwardk> http://lpaste.net/101668
10:51:11 <mzero> I‚Äôm wondering if Data.Functor.Apply or Data.Typeable has in 7.8, under conditional compilation, something called Main
10:52:17 <ArneL> Fuuzetsu : I'll try. Maybe I can even downgrade cabal later that day, though that could really get problematic.
10:52:21 * hackagebot distributive 0.4.1 - Haskell 98 Distributive functors -- Dual to Traversable  http://hackage.haskell.org/package/distributive-0.4.1 (EdwardKmett)
10:52:57 <mzero> edwardk / ArneL  ‚Äî can you look at the preprocessed free source (in dist/build/temp‚Ä¶) to see if there IS a Main defined in those files?
10:53:09 <mzero> then perhaps you can tease out how it got there
10:53:52 <mzero> (again, may need some cabal flags to keep the temp files around)
10:54:16 <edwardk> i don't see a temp dir
10:54:49 <mzero> the preprocessing step (in your trace you pasted) has things like ‚Äú-o dist/build/tmp-11354/src/Control/Monad/Free/Class.hs"
10:55:04 <mzero> I think those or rm‚Äôd on completion‚Ä¶ but there is a ghc or cabal flag to keep ‚Äòem
10:55:11 <ArneL> mzero: there no such path. Only entries in dist/build is 'autogen'
10:55:26 <edwardk> dolio remembered such a ghc option existing
10:55:33 <edwardk> but i don't have it handy
10:55:56 <ArneL> mzero: and the single hs file in there ('Paths_free/hs') has no main of course
10:56:07 <mzero> GHC‚Äôs -keep-tmp-files
10:56:13 <edwardk> -keep-tmp-files
10:56:15 <edwardk> yeah thats it
10:56:41 <Fuuzetsu> http://www.haskell.org/ghc/docs/7.0.3/html/users_guide/separate-compilation.html section 4.7.5
10:56:57 <mzero> cabal configure ‚Äîghc-option=-keep-tmp-files
10:57:12 <mzero> remember, we‚Äôre looking for Main, not main
10:57:17 <Fuuzetsu> I've posted to cabal-devel CC'ing ghc-devs, maybe someone has some guesses
10:57:21 * hackagebot wai-middleware-static 0.5.0.0 - WAI middleware that serves requests to static files.  http://hackage.haskell.org/package/wai-middleware-static-0.5.0.0 (AndrewFarmer)
11:02:18 <edwardk> mzero: that didn't get me the directory
11:03:57 <mzero> :-(
11:04:05 <edwardk> i hand compiled it with ghc and there is no Main
11:04:21 <mzero> harrumph
11:04:34 <edwardk> besides, ghc compiles the packag just file
11:04:39 <edwardk> its just haddock that craps out
11:05:04 <mzero> did you just hand copy the execution line for the preprocess step - say line 13 in your lpaste
11:05:51 <edwardk> i did ghc -keep-tmp-files src/Control/Monad/Free.hs -hide-package="monads-tf" -DGHC_TYPEABLE -v2
11:05:54 <mzero> so, another idea - it is possible that the .haddock files in the Mac distro. are bad? Did anyone see if this is so both from the distro, and from the 7.8rc2 built from source (I know that is a tall order...)
11:06:02 <edwardk> and looked at the file in /var/folders/...
11:06:36 <edwardk> mzero: note: 90% of my packages haddock just fine, its just this one and another one.
11:07:10 <edwardk> both give the same style of error
11:07:36 <edwardk> and neither gets very creative about abusing haddock
11:09:03 <mzero> so, edwardk is there any pattern to perhaps modules the breaking packages include, that are no perhaps included in the others?
11:09:24 <edwardk> mzero: i have no pattern to it yet
11:09:27 <Fuuzetsu> mzero: Haddock itself has no platform specific options that could affect it I think (the interface files that is) so if it's a problem of that nature, it's somewhere higher up
11:09:44 <edwardk> the package itself is actually pretty tame
11:10:26 <mzero> I‚Äôm still thinking that there is a references .haddock file that is busted
11:10:33 <edwardk> i have vastly more complicated packages that even depend on te package in question and all of its dependencies that build
11:10:47 <edwardk> and which haddock correctly
11:11:05 <Fuuzetsu> interesting
11:11:06 <mzero> and‚Ä¶ Main is wierd symbol ‚Äî anyone have any idea where that is from?
11:11:39 <tnks> I'm reading more about Cabal sandboxes, and it seems like sandboxes can still break if you fiddle with your dependencies as you develop.
11:11:56 <tnks> (mostly from the top section http://coldwa.st/e/blog/2013-08-20-Cabal-sandbox.html)
11:11:58 <mzero> yes - but only in the sandbox‚Ä¶. which is easy to wipe away and rebuild
11:12:03 <edwardk> i was just figuring that it was something where haddock was asking for a module name somehow via ghc-api, and taking Main if it didn't find one
11:12:09 <tnks> mzero: okay, that's what I thought.
11:12:25 <tnks> mzero: is there a clean way to detect that the sandbox is broken?
11:12:34 <mzero> hmmmm‚Ä¶ I suppose
11:12:36 <tnks> is it possible to have a broken sandbox and not really now?
11:12:37 <mzero> on the Main thing
11:12:37 <tnks> know?
11:12:46 <mzero> tnks: no
11:13:11 <tnks> okay, so shit just won't build and it will be tedious to fix, and you can just punt, delete the sandbox and try again?
11:13:15 <mzero> you‚Äôd know ‚Äòcuase when installing something into it you‚Äôd get a cabal warning about having to reinstalling something‚Ä¶
11:13:18 <mzero> which you should never do
11:13:31 <tnks> mzero: okay, soudns good.
11:13:42 <tnks> well, not "good" but let's say "good enough for now"
11:13:45 <Fuuzetsu> Haddock doesn't have the word ‚ÄòMain‚Äô occur in the source so something else must be coming up with it
11:13:50 <mzero> yes, you can kill and    cabal sandbox init ;  cabal install ‚Äîonly-dependencies
11:14:09 <haskell_newb> hello
11:14:38 <tnks> mzero: oh, I see, if you do a --only-dependencies, it will overlay the dependencies with other stuff already installed system-wide?
11:14:40 <haskell_newb> are there more modern libraries for graphs than fgl?
11:15:06 <tnks> not sure what else would be installed without --only-dependencies.
11:16:05 <Fuuzetsu> tnks: yes
11:16:10 <mzero> tnks - that was after blowing away the sandbox and recreating    only-dependnecies is what you do to get the sandbox filled up with the packages your .cabal file needs‚Ä¶ prior to configuring and building your pakcage
11:16:11 <ArneL> haskell_newb: You could try diagrams: http://projects.haskell.org/diagrams/  They even have a cool new site.
11:16:21 <Fuuzetsu> if you don't have the dep installed (or add-source'd) then it will use what's installed in the system if the version is fine
11:16:38 <EvilMachine> Hi guys. I just tried to parametrize a type variable. GHC tells me ‚Äúunexpected type‚Äù. My intention was to force the type variable of type C to only accept types of class E that themselves have one type variable that only accepts types of class C. How do I do that properly?
11:16:57 <ArneL> haskell_newb: or maybe charts: http://hackage.haskell.org/package/Chart (can use diagrams as a backend)
11:17:10 <Fuuzetsu> EvilMachine: posting what you have on lpaste is probably a good ideaa
11:17:26 * hackagebot shelly 1.5.1.1 - shell-like (systems) programming in Haskell  http://hackage.haskell.org/package/shelly-1.5.1.1 (GregWeber)
11:17:50 <EvilMachine> Fuuzetsu: I could post someting /like/ it there. Not the code itself. One minute‚Ä¶
11:18:02 <ArneL> haskell_newb: upon further consideration... I think you are looking for something else, sorry
11:18:16 <haskell_newb> ArneL: right, no problem :)
11:19:11 <haskell_newb> looking at http://hackage.haskell.org/packages/#cat:Graphs i can't find anything to match flg :(
11:19:41 <haskell_newb> too bad fgl is dead
11:20:08 <haskell_newb> i don't really belief that software can reach "nothing to add, nothing to take" point
11:22:36 <EvilMachine> Fuuzetsu: http://lpaste.net/101671
11:23:11 <byorgey> haskell_newb: in what sense is fgl dead?
11:24:09 <EvilMachine> http://lpaste.net/101671 ‚Üê Does anyone know what‚Äôs wrong with that? (I only know that it looks‚Ä¶ funky. :) But I don‚Äôt know how to express what I want otherwise.
11:24:39 <haskell_newb> byorgey: it was last updated 3 years ago
11:28:01 <byorgey> haskell_newb: no one says it has reached a point where there is nothing to add.  It's just that no one has the time or motivation to work on it.
11:28:06 <Fuuzetsu> EvilMachine: seems like you might be a little confused about type classes or something
11:28:13 <byorgey> it still works, and there are still many packages that use it.
11:28:37 <EvilMachine> Fuuzetsu: very likely probably, I would say. :)
11:28:57 <byorgey> Though I agree that for many packages, not being updated for 3 years is a bad sign.
11:29:09 <EvilMachine> Fuuzetsu: I have no idea how to express it properly.
11:29:21 <Fuuzetsu> EvilMachine: for example, you can't have Container on the right hand side of ->
11:29:47 <Fuuzetsu> EvilMachine: tell us what types you want to end up with and with what restriction
11:29:53 <EvilMachine> Fuuzetsu: Oops, that was a typo
11:30:02 <EvilMachine> Fuuzetsu: assume a lowercase container there
11:30:06 <fizbin> haskell_newb: I'm using fgl happily right now, in something that will hopefully be a piece of production software.
11:32:27 * hackagebot comonad 4.0.1 - Comonads  http://hackage.haskell.org/package/comonad-4.0.1 (EdwardKmett)
11:32:48 <EvilMachine> Fuuzetsu:  My intention was to force the second paramener of the type that implements Container to to only accept types that implement the class Element and themselves have one parameter that only accepts types that implement class Container.
11:32:51 <haskell_newb> fizbin byorgey: yeah, i've used it previously and it was good, just wondering if there is something newer come up
11:33:07 <byorgey> EvilMachine: you also can't have something like  class Container (a b (c d))
11:33:51 <EvilMachine> byorgey: Fuuzetsu: btw: fixed version (without the typo) http://lpaste.net/101672
11:33:55 <byorgey> EvilMachine: you can't express that.  Instead just put Element and Container constraints on whatever functions need them.
11:34:01 <Fuuzetsu> ^
11:34:27 <Fuuzetsu> maybe something like
11:34:28 <Fuuzetsu> class E e where
11:34:28 <Fuuzetsu>  
11:34:30 <Fuuzetsu> class (Eq i, Enum i, E e) => C c e i where
11:34:32 <Fuuzetsu>   takeOut :: c -> i -> e
11:34:55 <EvilMachine> Hmm, I dislike being forced to do boilerplate stuff like that. I didn‚Äôt use Haskell to be back in boilerplate world. :(
11:34:57 <Fuuzetsu> no idea if that works for you (or at all)
11:35:05 <byorgey> you could also have Element and Index be associated types
11:35:31 <EvilMachine> byorgey: No idea what that means in this context.
11:35:37 <byorgey> that's a pretty standard example for the use of associated types, in fact
11:36:25 <byorgey> EvilMachine: http://www.haskell.org/haskellwiki/GHC/Type_families#An_associated_type_synonym_example
11:37:00 <EvilMachine> byorgey: There are so many of these ‚Äúadvanced techniques‚Äù, (e.g. GADT being one of them) that I often feel like I‚Äôm drowning and will never get actually a full Haskell coder. :/
11:37:28 * hackagebot semigroupoids 4.0.1 - Semigroupoids: Category sans id  http://hackage.haskell.org/package/semigroupoids-4.0.1 (EdwardKmett)
11:38:00 <byorgey> EvilMachine: just keep treading water, eventually your legs grow long enough and you can touch the bottom
11:38:14 <Zolomon> http://hastebin.com/bufodaguse.hs -- I'm trying to compile the code from http://book.realworldhaskell.org/read/writing-a-library-working-with-json-data.html, but I get this error when running the command at the top of the hastebin, and I don't fully understand the errors. I have no multiple definitions?
11:38:45 <Zolomon> (Ignore the first warning, I fixed that)
11:40:09 <EvilMachine> byorgey: I‚Äôm not exactly good in grinding games. I have a trauma wrt motivation. I easily get nightmares about anything that frustrates me that much.
11:40:13 <geekosaur> does it really tell you to link SimpleJSON.o?
11:40:41 <Zolomon> "ghc -o simple Main.hs SimpleJSON.o" copied from the website.
11:40:42 <geekosaur> because that looks like a compiled Haskell module, and ghc should be importing it itself and then explicitly linking SimpleJSON.o as well would cause multiple definition errors
11:41:19 <monochrom> please don't measure yourself against "all advanced techniques". there are infinitely many. you will never measure up. no one will.
11:41:25 <Zolomon> geekosaur: Yeah, it worked if I removed the SimpleJSON.o part.
11:41:51 <EvilMachine> byorgey: I‚Äôll have to look into that wiki page. Thanks for the help. Fuuzetsu: Thank you too. :)
11:42:12 <geekosaur> oh, I bet I know what this is
11:42:29 <geekosaur> it used to be that automatic linking was only done with ghc --make
11:42:44 * Zolomon nods
11:42:45 <geekosaur> which it should have used there, since --make would be silently ignored by current ghc as it's the default
11:44:21 <trolling> arrow laws are tedious to prove
11:45:34 <monochrom> Phil Wadler has reduced them down to about 4 laws. that is less tedious.
11:45:40 <EvilMachine> trolling: are you‚Ä¶ trolling? XD (sorry, I could *not* resist. :))
11:45:58 <trolling> EvilMachine: assuming nick comparison is reflexive
11:46:21 <trolling> monochrom: yeah, reading that paper now
11:46:36 <monochrom> ok good!
11:46:40 <mizu_no_oto> I just installed XCode 5.1, and ran ./configue for the GHC 7.8 RC 2.  It failed with the message "configure: error: C compiler cannot create executables".  Trying to run xcode-select --install failed with the message "Can't install the software because it is not currently available from the Software Update server."  Is anyone familiar with my problem or know of a better channel to ask?
11:46:45 <trolling> it does involve converting from one form to the other first though so net tediousness may be unchanged
11:46:56 <monochrom> haha ok
11:47:11 <trolling> I will report back with a blood pressure graph later
11:47:43 <monochrom> blood pressure may reflect joy rather than frustration :)
11:47:56 <Zolomon> I found a post by Ekmett today on Quora recommending http://www.amazon.com/Category-Computer-Scientists-Foundations-Computing/dp/0262660717/, made me buy it ! *feels excited while waiting for it to arrive (not from Amazon...)*
11:48:39 <geekosaur> mizu_no_oto, can you pastebin the config.log from the ghc build attempt?
11:48:41 <geekosaur> @paste
11:48:41 <lambdabot> Haskell pastebin: http://lpaste.net/
11:48:41 <raichoo> Zolomon: That's a good read! Congrats :)
11:49:42 <Zolomon> raichoo: I'm a bit curious what kind of mathematical background is needed to comprehend its contents, so far I've only read calculus and linear algebra at my university.
11:50:09 <trolling> some set theory will probably help
11:50:43 <Zolomon> trolling: Thanks
11:50:51 <raichoo> Zolomon: You might feel lost when you start reading it. It's quite thin but very dense.
11:51:22 <Zolomon> raichoo: That's ok, because I love exploring jungles. :)
11:51:40 <ski> Zolomon : is that the think or the thick book ?
11:51:58 <Zolomon> ski: Looks like the thin book, were you thinking of http://www.math.mcgill.ca/triples/Barr-Wells-ctcs.pdf ?
11:52:07 <ski> ok, i assume it's the think one, by raichoo's comment
11:52:08 <shachaf> I would say it's moderately thin and moderately dense.
11:52:09 <raichoo> Zolomon: After that you might want to read "Category Theory" by Steve Awodey.
11:52:30 * hackagebot heroku 0.1.1.1 - helpers for deploying to Heroku  http://hackage.haskell.org/package/heroku-0.1.1.1 (GregWeber)
11:52:32 * hackagebot mtl 2.1.3.1 - Monad classes, using functional dependencies  http://hackage.haskell.org/package/mtl-2.1.3.1 (EdwardKmett)
11:55:54 <raichoo> Zolomon: Also "Algebra of Programming" by Richard Bird and Oege De Moor is pretty good but it's quite hard to get an affordable copy.
11:55:56 <Zolomon> Also, a question on style, which is better: values = intercalate ", " $ map renderJValue, values vs = intercalate ", " $ map renderJValue vs, or values vs = intercalate ", " (map renderJValue vs) ?
11:57:43 <Zolomon> raichoo: According to the amazon comments the book is in print in India.
11:58:08 <raichoo> yep
11:58:13 <raichoo> Heard of that as well.
11:59:12 <raichoo> Zolomon: How about point-free? values = intercalate ", " . map renderJValue
12:00:48 <Zolomon> raichoo: Ah, yeah, I missed that one -- thank you.
12:01:47 <ski> Zolomon,raichoo : i think i may have been thinking of "Categories, Types, and Structures : An Introduction to Category Theory for the Working Computer Scientist" by Andrea Asperti,Giuseppe Longo in 1991
12:02:46 <ski> (iirc, it looks somewhat similar on the outside as the "thin" book above, which was why i was asking)
12:03:50 <ski> Zolomon : of course `values = intercalate ", " $ map renderJValue' is type incorrect
12:04:08 <ski> Zolomon : if not the pointless one, i'd prefer the one with brackets
12:04:38 <Zolomon> ski: Because it adds some kind of visual scope?
12:04:57 <ski> because `$' is ugly, and brackets aren't scary
12:05:15 <SwashBuckla> I happen to prefer `$'
12:05:19 <Zolomon> ski: I have been playing around with LISPs lately, brackets are second nature to me. :)
12:05:40 <Zolomon> SwashBuckla: Me too to be honest..
12:06:07 * ski mostly tries to minimize their use of `$'
12:07:48 <ski> (with a few other exceptions, which i think are reasonable), most of my remaining uses of `$' would disappear if one could write `foo \x -> ...', `foo do ...', `foo case ...', `foo if ... then ... else ...', `foo let ... in ...'
12:09:24 <braintwist> Somehow I cant do json with haskell I was just thinking I got it cight, but then it returns a Nothing and not the Just i hoped for.
12:09:52 <ski> (when closing brackets starts to pile up on each other, at least if they enclose a large expression (several lines), then i think `$' is ok, if one can't write it as nicely in some other way)
12:11:17 <braintwist> http://pastebin.com/XCrYEq2G this is the code I cant get to work
12:11:50 <braintwist> https://btc-e.com/api/2/btc_usd/ticker that is the json (although it updates but the structure stays the same
12:17:10 <supki> braintwist: it's "server_time" in JSON but "servertime" in your code
12:17:45 <exlevan> is there a way to tell cabal-install to install two different versions of the same package in one go? When I try cabal install pkg-x.y.1 pkg-x.y.2, it just thinks that I provide conflicting requirements
12:18:21 <geekosaur> there is not, and that's a lovely way to get yourself into trouble
12:18:54 <geekosaur> because multiple versions of a package installed confuses the **** out of ghc
12:19:45 <braintwist> supki is that really all I did wrong :D
12:20:32 <supki> I've no idea
12:20:56 <supki> I wouldn't repeat (v .: "ticker") 10 times but otherwise the parser looks okish
12:21:06 <braintwist> supki well that wont work either but I appreciate the help
12:21:21 <braintwist> how could I avoid that repetition ?
12:23:41 <supki> parseJSON (Object v) = (v .: "ticker") >>= \v' -> Ticker <$> (v' .: "high") <*> (v' .: "low") <*> ...
12:23:50 <jle`> i wish we could do foo \x -> :/
12:23:57 <monochrom> yes
12:23:59 <jle`> are there any meaningful proposals?
12:24:06 <monochrom> no
12:24:09 <jle`> that suggest the state of things might change?
12:24:11 <jle`> aw
12:24:13 <jle`> why not?
12:24:16 <jle`> would it be lack of compatibility with the report?
12:24:31 <monochrom> too lazy
12:24:43 <jle`> :'(
12:24:51 <braintwist> supki that seems good, I am a bit new to haskell so that is not something that jumps immediately at me
12:25:33 <daimonos> Adam West!
12:25:33 <jle`> > (+) <$> Just 1 <*> Just 3
12:25:34 <lambdabot>  Just 4
12:25:43 <grache28> hi I'm just learning about haskell and functional programming.  in fibonacci seq. code           fibs = 0 : 1 : zipWith (+) fibs (tail fibs)
12:25:45 <jle`> braintwist: <$> and <*> allow you to apply functions inside monads/applicatives
12:25:50 <daimonos> > Adam West
12:25:51 <lambdabot>  Not in scope: data constructor `Adam'Not in scope: data constructor `West'
12:25:53 <quchen> Is there a nice way to define `zip` for `Data.Set`, i.e. `zipSets :: (Ord a, Ord b) => Set a -> Set b -> Set (a,b)`?
12:26:08 <jle`> quchen: what would be paired with what?
12:26:11 <grache28> I'm trying to understand the : operator and lazy evaluation - so that code produces an infinetely long fibonacci sequence?
12:26:17 <jle`> grache28: it does
12:26:28 <jle`> or well, a representation of it
12:26:34 <monochrom> yes grache28
12:26:49 <jle`> you can use take, etc, to take pieces of that infinitely long sequence in a useful way
12:26:51 <braintwist> jle' yeah I didn't know that
12:26:51 <grache28> jle`: so in the real world if I wanted to just see the first N elements of the sequence how would I see them?
12:26:58 <jle`> grache28: take
12:27:03 <jle`> > take 3 [1..]
12:27:04 <lambdabot>  [1,2,3]
12:27:09 <jle`> take is not magic
12:27:10 <jle`> @src take
12:27:11 <lambdabot> take n _      | n <= 0 =  []
12:27:11 <lambdabot> take _ []              =  []
12:27:11 <lambdabot> take n (x:xs)          =  x : take (n-1) xs
12:27:14 <quchen> jle`: It's equivalent to `fromList (zip (toList set1) (toList set2)`
12:27:19 <quchen> )
12:27:58 <quchen> It should be well-defined by that, no?
12:28:05 <jle`> grache28: if you try to 'apply' take 2 to [1..], you will see that take 2 (1:[2..]) = 1 : take 1 [2..] = 1:2:take 0 [3..] = 1:2:3:[]
12:28:11 <jle`> = [1,2,3]
12:28:17 <grache28> ok - tks (I'm not actually learning Haskell atm, just reading a book that talks about different programming paradigms)
12:28:17 <mornfall> quchen: it would give counterintuitive results though
12:28:36 <quchen> Why?
12:28:52 <jle`> grache28: laziness is only an implementation detail in the sense that what is 'really' important is that haskell's evaluation is evaluation *by substitution*
12:29:01 <mornfall> quchen: adding a single element to one of the sets could change many pairings
12:29:21 <quchen> That's the same for lists
12:29:23 <jle`> grache28: what's important here is that to evalute take 3 [1..], you just expand out the definition of take with your list, and the fact that infinite lists don't explode is built into that
12:29:24 <supki> braintwist: yeah, it takes practice and aeson is not an exceptionally friendly library
12:29:33 <jle`> quchen: yeah, but that's okay because lists are ordered data
12:29:37 <mornfall> quchen: not really
12:29:44 <supki> braintwist: anyway, with s/servertime/server_time/ your code seems to work for me
12:29:57 <jle`> sets are supposed to be technically unordered, right?
12:30:01 <mornfall> quchen: depends on how you interpret "adding" but with lists, the natural interpretation seems to be append, not insert randomly in the middle
12:30:07 <braintwist> supki but are there any friedly libraries for json ?
12:30:20 <jle`> or at least for lists, the ordering of your elements is under your control, and it matters
12:30:29 <grache28> jle`: ok, tks for that, back to my book for now
12:30:30 <braintwist> supki does it give you an ADT  ?
12:30:33 <quchen> Append is pretty unnatural for lists. Prepend is natural, but modifies all pairings in the zip.
12:30:35 <mornfall> quchen: so "adding" an element to a list and zipping commutes fairly well, but with sets, it doesn't
12:31:29 <mornfall> quchen: well, for prepending, it still works out well for lists -- prepending a single element to both commutes, and it still doesn't for sets
12:31:46 <supki> braintwist: yeah: http://lpaste.net/8142376004501897216
12:32:03 <quchen> jle`: You mean that Set is a unordered data structure, and only uses Ord for performance? I don't think so, since Foldable etc. rely on the ordering of the elements.
12:32:07 <mornfall> quchen: also, appending to a list is only "unnatural" because it's inefficient in haskell :P
12:32:23 <jle`> prepending things would affect things in a predictable way; you could prepend to both lists.  but if you're adding two things to two sets of different types, it's not exactly predictable?
12:32:57 <monochrom> jle`, mathematical sets are unordered, but Set is not exactly mathematical sets.
12:33:06 <quchen> (I'm not sure how this is related to my initial question anyway.)
12:33:38 <monochrom> also, mathematical sets require only Eq, if I'm allowed to mix up the two worlds
12:33:54 <braintwist> supki Hmm I find it confusing that liftM decode didnt work ? Or am I doing that wrong ?
12:34:00 <quchen> Set is a sequential container of ordered values, so zipping should be well-defined. That changing input changes the result of the zip isn't surprising.
12:34:02 <mornfall> quchen: it's related because it's not clear what should zipping sets mean
12:34:25 <Javran> is there a safe version of "last"?
12:34:39 <jle`> Javran: as in a Maybe version?
12:34:39 <quchen> "It's equivalent to `fromList (zip (toList set1) (toList set2)`", mornfall
12:34:44 <supki> braintwist: yeah it may need help to figure out the right type to decode to
12:34:50 <quchen> ‚Ä¶ which is not the pinnacle of performance or beauty
12:34:52 <quchen> :-C
12:35:13 <mornfall> quchen: I'd still find that to be at least odd, if not surprising (were it part of the library)
12:35:16 <Javran> > (listToMaybe . reverse) []
12:35:18 <lambdabot>  Nothing
12:35:29 <Javran> > listToMaybe [1,2,3]
12:35:30 <lambdabot>  Just 1
12:35:34 <braintwist> supki so if I wanted to take the ticker out of this Either  ? I would like to display a little nicer
12:35:37 <jle`> it just doesn't seem to mesh with the semantics of sets in my head. but. no reason it can't be implemented
12:35:50 <quchen> :t let safeLast [] = Nothing; safeLast xs = last xs in safeLast
12:35:51 <lambdabot> [Maybe a] -> Maybe a
12:35:59 <quchen> Ergh. Well you get the idea.
12:36:06 <jle`> @src reverse
12:36:06 <lambdabot> reverse = foldl (flip (:)) []
12:36:19 <monochrom> you are right jle`, Set has a different semantics from your set
12:36:20 <jle`> is there a way to make a lazy reverse
12:36:21 <mornfall> quchen: also, I don't think you can do much better than that anyway
12:36:27 <mornfall> quchen: in terms of performance
12:36:37 <jle`> you might be able to work with the internal representation of Set
12:37:02 <mornfall> quchen: if you are a little lucky, the intermediate lists can be fused away
12:37:15 <monochrom> after 20 years of programming, one learns that "meaningful" names are meant to be figurative, not actual.
12:37:44 <quchen> mornfall: Well, the order of elements in the zipped set is defined by the first argument of zipSet. I wonder whether that can be used for good.
12:37:47 <monochrom> most trivial example is "function".
12:38:08 <mornfall> monochrom: I have always regarded std::set & friends as approximations of mathematical set -- the order requirements mostly exist for efficiency only
12:38:31 <mornfall> quchen: you could use fromAscList or such
12:38:36 <mornfall> quchen: that saves you a logarithm
12:38:37 <supki> braintwist: oh well you'd need to decide what to do in the Left case and then pattern match or use `either' etc
12:39:13 <monochrom> unfortunately, Data.Set API provides minView and maxView. that is going to far exceed both "mathematical set" and "like mathematical set but efficient"
12:39:31 <braintwist> left would be a failed match, so that is probably good with an error
12:39:33 <quchen> mornfall: fromAscList is almost identical in performance to fromList nowadays, I think
12:39:34 <mornfall> quchen: but that's most likely peanuts compared to the cost of all the memory crawling
12:40:47 <supki> braintwist: http://lpaste.net/2366165309489938432
12:41:04 <mornfall> monochrom: well, yes, that happens with most standard libraries
12:41:25 <mornfall> monochrom: C++ has grown unordered_set eventually :-)
12:41:48 <braintwist> supki thanks it really helps to see things in action
12:42:20 <jle`> monochrom: i don't know, minView and maxView make sense in the case of a set that happens to be ordered.  so does traverse; you can consider the order to be arbitrary.  but zip..hm actually i guess zip does make sense in an ordered set. what was i trying to say again?
12:42:56 <mornfall> jle`: ordered sets as such are fairly unnatural ;-)
12:42:57 <Fuuzetsu> > iterate (\x -> 2 * x + 1) 0
12:42:58 <lambdabot>  [0,1,3,7,15,31,63,127,255,511,1023,2047,4095,8191,16383,32767,65535,131071,2...
12:43:18 <jle`> mornfall: sets of objects that happen to have a total ordering
12:43:22 <mornfall> jle`: possibly because they are very paper-unfriendly
12:43:23 <monochrom> programmers are control freaks. you cannot preserve a pure, abstract interface for long. someone will change it to expose more internals. control freaks want the internals.
12:44:26 <jle`> how uncouth
12:45:35 <peteretep> oDesk has 338 Haskell developers
12:45:46 <mornfall> peteretep: good for them
12:45:47 <monochrom> jle`, I think you're trying to say, minView and traverse are so convenient, you want to keep them. and yet, the mathematical ideal is so ideal, you want to keep that slogan too.
12:46:19 <mornfall> monochrom: good thing that we invented newspeak, so we can!
12:46:44 <peteretep> mornfall: I wsas surprised at thevolume
12:47:16 <monochrom> yeah, Ord is unordered, Free is slavery...
12:47:33 <jle`> mornfall: i guess i was saying that i can reconcile minView and traverse with set abstractions that happen to be over ordered items, and then to believe that their behavior for things without meaningful orders is simply unspecified
12:47:39 <monochrom> we need a slavery monad package!
12:48:06 <DR6_> it's called IO
12:48:06 <jle`> which is convenient because all Sets are of Ord!
12:48:07 <quchen> monochrom: IO! Unescapable!
12:48:12 <quchen> Awww DR6_ stole my joke
12:48:17 <monochrom> haha great
12:48:20 <DR6_> you delivered it better
12:48:28 <DR6_> let's call it a tie
12:48:38 <quchen> And *if* you escape it's an adventure.
12:49:01 <mornfall> quchen: That'd be room 101 for you.
12:49:22 <pyon> Room 101? Gilad Bracha's blog?
12:49:24 <monochrom> use a solitary cell and a sextant to help escape IO
12:49:37 <tommd> Is there an '@seen' functionallity on any bot here anymore?  It seems all the person-tracking plugins/bots are gone.
12:50:16 <quchen> tommd: You can search the logs yourself
12:50:28 <quchen> IRCBrowse has a pretty handy search function
12:50:50 <quchen> (Works only for #haskell though)
12:50:56 <mornfall> pyon: that's another reference to the same book :)
12:51:37 <tommd> quchen: Yes I know, but it is nice to do it within the irc window.
12:52:15 <tommd> @quote preflex
12:52:16 <lambdabot> preflex says: god was last seen on ##c++ 96 days, 6 hours, 19 minutes and 16 seconds ago, saying: I don't really know either actually
12:53:15 <Fuuzetsu> heh
12:53:35 <quchen> I just discovered `Data.Set.splitRoot`. Awkward function.
12:53:43 <monochrom> haha
12:53:46 <schell> what is the standard way to send a patch to a darcs repo? attach the *.dpatch in an email to the maintainer?
12:54:59 <Fuuzetsu> I believe it's 1. Convince them to switch to git 2. Do the usual
12:55:06 <mornfall> quchen: did you *have* to tell us?
12:55:07 <monochrom> haha
12:55:11 <schell> haha
12:55:12 <schell> nice
12:55:13 <monochrom> but sending email is good
12:55:29 <monochrom> in fact I think darcs has a command for sending that email, no?
12:55:34 <mornfall> darcs send
12:55:35 <mornfall> yes
12:55:42 <mornfall> but you need a system that can send mail
12:55:46 <mornfall> most people apparently don't anymore
12:55:51 <Javran> is there a shorthand for (\s -> (isX s && isXX s) || (isY s && isYY s) || .... | const True) ?
12:56:17 <Fuuzetsu> :t (&&&)
12:56:18 <lambdabot> Arrow a => a b c -> a b c' -> a b (c, c')
12:56:21 <Fuuzetsu> hm
12:56:23 <Fuuzetsu> :t (***)
12:56:24 <lambdabot> Arrow a => a b c -> a b' c' -> a (b, b') (c, c')
12:56:25 <Javran> ops, forget about const True part
12:56:39 <jle`> Javran: what should it be?
12:56:49 <Javran> Fuuzetsu: you have to (curry &&) after that
12:56:57 <Fuuzetsu> yeah which is why I'm hmming
12:57:06 <mornfall> Javran: something like or . map and? :)
12:57:22 <Fuuzetsu> :t liftM2 (undefined :: a -> Bool)
12:57:23 <lambdabot>     Couldn't match type `Bool' with `a20 -> r0'
12:57:23 <lambdabot>     Expected type: a10 -> a20 -> r0
12:57:23 <lambdabot>       Actual type: a10 -> Bool
12:57:23 <jle`> you can (&&) <$> isX <*> isXX
12:57:39 <jle`> :t (&&) <$> f <*> g
12:57:40 <lambdabot> (Applicative f, FromExpr (f Bool)) => f Bool
12:57:48 <jle`> hm what
12:57:55 <jle`> :t (&&) <$> (f :: a -> Bool) <*> g
12:57:56 <lambdabot>     Could not deduce (FromExpr Bool) arising from a use of `f'
12:57:56 <lambdabot>     from the context (Show a)
12:57:56 <lambdabot>       bound by the inferred type of it :: Show a => a -> Bool
12:58:08 <jle`> :t (&&) <$> (f :: Int -> Bool) <*> g
12:58:09 <Javran> I haven't seen FromExpr before ...
12:58:09 <lambdabot>     No instance for (FromExpr Bool) arising from a use of `f'
12:58:09 <lambdabot>     Possible fix: add an instance declaration for (FromExpr Bool)
12:58:09 <lambdabot>     In the second argument of `(<$>)', namely `(f :: Int -> Bool)'
12:58:10 <mornfall> jle`: that only serves to make it completely unreadable
12:58:29 <daimonos> :t (***)
12:58:30 <lambdabot> Arrow a => a b c -> a b' c' -> a (b, b') (c, c')
12:58:52 <jle`> really?  applicative function instances don't feel too unreadable to me. but i might be living in a cave
12:59:03 <Javran> I think I should use the most readable and concise one.
13:01:12 <jle`> all ($ s) [(&&) <$> isX <*> isXX,  (&&) <$> isY <*> isYY ..]
13:01:15 <jle`> *any
13:01:19 <tibbe> edwardk: around?
13:01:23 <jle`> hm that is kinda not too pretty
13:01:57 <Javran> hmm, I think I've found some other way
13:02:06 <nadirs> hello
13:02:15 <Javran> I should apply a filter before doing this
13:02:32 <nadirs> hey Javran, I've been reading your blog, it's really nice how you put down your discoveries :)
13:02:37 * hackagebot unfoldable 0.8 - Class of data structures that can be unfolded.  http://hackage.haskell.org/package/unfoldable-0.8 (SjoerdVisscher)
13:02:55 <jle`> any ($ s) (zipWith (\f g x -> f x && g x) [isX,isY..] [isXX, isYY..])
13:02:57 <nadirs> s/put down/write down/
13:03:00 <jrmithdobbs> something like [[isX,isXX],[isY,isYY]] & each any
13:03:06 <tibbe> edwardk: I think people are missing Mark's point. The point is not that HP authors can't ignore roles because is as unsafe as the pre-7.8 state, rather it is that HP authors can't ignore roles as the HP is expected to, by its users, to play nicely with whatever GHC release it ships with.
13:03:52 <tibbe> edwardk: In other words, we don't want to ship a HP with this release note: "Hey, we're including this new GHC feature but you shouldn't really use it, because the HP libraries won't work well with it."
13:04:21 <tibbe> edwardk: The default is really a red herring as far as HP is concerned.
13:04:25 <Javran> nadirs: that's great, thanks for you support!
13:04:51 <tibbe> edwardk: Same thing when everyone wanted to but Safe pragmas everywhere. Doing the role thing correctly across HP is lots of work.
13:06:46 <skypers> hey pals!
13:07:01 <skypers> I have a foreign function that allocates something
13:07:08 <skypers> and a ‚Äúfree‚Äù version of that function
13:07:13 <tibbe> edwardk: The perceived benefit isn't there for most users. While plugging a type system hole feels nice with my language implementor hat on, we had this whole for years and years and I think very few people actually had issues due to it.
13:07:20 <skypers> how could I wrap that in order to call the free function when the GHC says so?
13:08:17 <Javran> finally this is how I implement it:  http://lpaste.net/101676
13:08:22 <Fuuzetsu> withFFIFunction = allocateStuff >> doStuff >> freestuff
13:08:31 <Fuuzetsu> withFFIFunction doStuff = allocateStuff >> doStuff >> freestuff
13:08:53 <Javran> any comments?
13:09:07 <jrmithdobbs> allocate >>= do >>= free
13:09:08 <jrmithdobbs> surely
13:09:27 <Fuuzetsu> whatever works
13:09:52 <jrmithdobbs> well the first bind needs to not be forgetful at least if that action needs what's allocated ;p
13:11:12 <alpounet> well
13:11:28 <alpounet> depending on if there are exceptions that could be raised, you'd throw a bracket in there instead
13:12:10 <quchen> Javran: Is that supposed to check whether a String contains at least one letter, and all letters are upper case?
13:12:33 <skypers> yeah
13:12:36 <skypers> I could use bracket
13:12:37 <skypers> indeed
13:12:53 <skypers> but it‚Äôs a C function
13:13:07 <skypers> how can I foresee an exception to be thrown from C code?
13:13:13 <skypers> does Haskell do that?
13:13:16 <Javran> quchen: yes
13:13:32 <Javran> quchen: I made it wrong, shouldn't have that "not"
13:13:38 <skypers> I guess if the C function tries to do something with memory and the GC dislikes, he may throw something
13:14:24 <edwardk> tibbe: given my druthers i'd throw the whole role thing back until we could find a nicer solution, but if it is happening, i have a hard time looking at nominal as a viable default.
13:14:52 <tibbe> edwardk: sure, it's not
13:15:00 <quchen> Javran: Looks fairly complicated to me. You could solve this with foldr as well.
13:15:00 <tibbe> edwardk: people will just not use 7.8 if it's the default
13:15:40 <Javran> quchen: fine, I'll have a try
13:16:02 <edwardk> i'm honestly just plugging the holes so coerce is a ever so slightly safer unsafeCoerce that at least ensures representational soundness, and looking for a better class based solution.
13:16:35 <alpounet> skypers: not unless you write the exception type yourself and make your functions raise them, but that's not the cleanest way i'd say. exceptions tend to appear when you're managing resources, quite often, from what I've seen
13:16:58 <edwardk> https://github.com/ekmett/roles/blob/master/src/Data/Roles.hs is a sketch of my last stab in that direction, but even that has problems
13:17:42 <skypers> alpounet: sure, I guess I don‚Äôt care then since I won‚Äôt raise anything and it‚Äôs a C function
13:18:33 <skypers> hey, it‚Äôs not actually what I need
13:18:45 <skypers> you‚Äôre using the with* convention (which is nice btw)
13:18:52 <skypers> I‚Äôd like something automatic through the GC
13:19:15 <alpounet> want to attach a finalizer?
13:19:29 <skypers> yeah!
13:19:36 <skypers> I remember know
13:19:39 <skypers> it‚Äôs a special pointer
13:20:30 <skypers> ForeignPtr
13:20:31 <skypers> that‚Äôs it
13:20:47 <skypers> and FinalizerPtr
13:21:41 <Javran> @pl  (\i -> (isValid i &&)
13:21:41 <lambdabot> (line 1, column 22):
13:21:41 <lambdabot> unexpected end of input
13:21:41 <lambdabot> expecting variable, "(", operator or ")"
13:21:47 <Javran> @pl  (\i -> (isValid i &&))
13:21:47 <lambdabot> (&&) . isValid
13:22:17 <skypers> thank you for make me remember, alpounet :)
13:22:41 * hackagebot warp 2.1.2.1 - A fast, light-weight web server for WAI applications.  http://hackage.haskell.org/package/warp-2.1.2.1 (MichaelSnoyman)
13:23:17 <quchen> Javran: Think of this step by step. You should walk the input from left to right. Along the way, you want to abort with False if you see a lowercase letter. If you see an uppercase letter, remember that there is at least one uppercase letter. When you reach the end of your string, check whether there has been an uppercase letter, that's your result.
13:24:32 <Javran> quchen: this is what I have for now: http://lpaste.net/101676 see version 2.
13:26:35 <yorg> http://www.marketglory.com/strategygame/galahad1st for all you online gamers out there, if you didn't already, use this link to register on MerkatGlory a free2play financial strategy game where virtual currency can be converted into real money. It starts out slow but in time you can turn a good profit
13:26:42 <quchen> Javran: isYell "!" is True there
13:26:54 <fragamus> hmm I'm having a weird problem. If I use a pair of numbers as my key when inserting into Data.Hashable all is well but‚Ä¶.. if I use a V2 I get   _|_
13:27:23 <Javran> quchen: ops..
13:27:25 <fragamus> tuples good, Linear V2 bad
13:27:29 <fragamus> why
13:27:50 <quchen> Javran: The problem is that you need to keep track of whether there has been an uppercase letter already.
13:28:46 <quchen> The solution isn't a "simple" foldr, it's a bit special. Related to "foldl in terms of foldr".
13:29:42 <quchen> Javran: Maybe this helps to understand how to use "foldr with 4 arguments": https://github.com/quchen/articles/blob/master/useful_techniques.md#bouncy-folds
13:31:07 <Javran> quchen: the only way when I'm thinking about keeping track of "whether there has been an uppercase letter already" is to use pair, but this is what I'm trying to avoid ...
13:33:56 <quchen> Javran: I can post you my solution if you want, but I think you should give my link above a quick read.
13:34:25 <quchen> I find the technique fairly useful sometimes, and it was very enlightening for my practical understanding of foldr when I got it.
13:34:34 <awestroke> When doing: mapM_ statefulComputation list    , the state is reset. why?
13:34:48 <nadirs> quchen: may it be that you can use Maybe with (||) so you can track both truthiness (one (Just True) result makes the whole fold return (Just True)) or failure (Nothing if you find a lower)?
13:35:50 <raphie> is there a way to map a list of functions over a list of values?
13:36:06 <nadirs> (and, probably, (Just False) for other chars)
13:36:13 <mzero> do you want them matched 1 by 1, or cartesian product?
13:36:18 <raphie> as in, fn [succ, pred] [1,2] -> [[2, 3], [0, 1]]
13:36:22 <byorgey> awestroke: can you be more specific?  you haven't given nearly enough information to answer your question.
13:36:29 <mzero> sure
13:36:43 <awestroke> byorgey: one sec let me write an example
13:37:02 <DR6_> raphie: <*> does that
13:37:11 <byorgey> awestroke: ideally, paste some code on e.g. lpaste.net, show what it does and what you expect it to do instead, or something along those lines
13:37:44 <raphie> DR6_: what is that?
13:37:49 <mzero> > let fs = [succ, pred]; vs = [1, 2] in map (\v -> map ($ v) fs) vs
13:37:50 <lambdabot>  [[2,0],[3,1]]
13:37:58 <DR6_> an operator in Control.Applicative
13:38:05 <mzero> or
13:38:08 <DR6_> the ap function in Control.Monad also would work
13:38:24 <mzero> > let fs = [succ, pred]; vs = [1, 2] in map (\f -> map f vs) fs
13:38:25 <lambdabot>  [[2,3],[0,1]]
13:38:31 <mzero> depending on which way you want it nested
13:38:33 <DR6_> > [succ, pred] <*> [1,2,3]
13:38:34 <lambdabot>  [2,3,4,0,1,2]
13:38:40 <DR6_> oh
13:38:41 <mzero> > let fs = [succ, pred]; vs = [1, 2] in fs <*> vs
13:38:42 <lambdabot>  [2,3,0,1]
13:38:44 <DR6_> you wanted them nested
13:38:47 <mzero> which is somewhat different
13:39:17 <mzero> > let fs = [succ, pred]; vs = [1, 2] in (map ($) vs) <*> fs
13:39:19 <lambdabot>  Could not deduce (GHC.Num.Num ((a0 -> a0) -> b))
13:39:19 <lambdabot>    arising from the ambiguity check for `e_112'
13:39:19 <lambdabot>  from the context (GHC.Enum.Enum a, GHC.Num.Num ((a -> a) -> b))
13:39:19 <lambdabot>    bound by the inferred type for `e_112':
13:39:19 <lambdabot>               (GHC.Enum.Enum a, GHC.Num.Num ((a -> a) -> b)) => [b]
13:39:37 <mzero> > let fs = [succ, pred]; vs = [1, 2] in (map (\v -> ($ v)) vs) <*> fs
13:39:38 <lambdabot>  [2,0,3,1]
13:39:42 <mzero> for completeness
13:41:21 <Javran> quchen: this is the pair version http://lpaste.net/101676
13:42:08 <Redz> oh man i was so stupid. i simply forgot :i in ghci. i pulled the docs every time ...
13:44:27 <edwardk> mizu_no_oto: can you join #haddock ?
13:45:08 <nadirs> Javran: I find the first version was the most readable
13:45:36 <nadirs> except maybe I'd rather use (.) instead of (>>>)
13:45:42 <b0bbi10> hi, I don't understand why the record syntax matching has to be value = parameter (line 2) instead of parameter = value (line 5). why does that assign from left to right? Oo http://ideone.com/IYFJOd
13:45:50 <b0bbi10> can you help me please?
13:46:05 <nadirs> (but this last bit is a matter of taste, I guess)
13:47:10 <Javran> nadirs: well, whenever I import Control.Arrow, I tend to use that .. since you don't have to read function compostion from right to left
13:47:30 <dgpratt> experimenting with accessing a SQL Server 2012 db with hdbc and I have stumbled on to what appears to be a bug in hdbc-odbc
13:48:02 <nadirs> Javran: yeah, it's probably just what one gets more used to :)
13:48:03 <dgpratt> and I surprised myself by (apparently) fixing said bug
13:48:07 <dgpratt> but
13:48:24 <dgpratt> I don't think my solution is generic enough
13:48:38 <dgpratt> and there are aspects of the current code that don't make sense to me
13:49:04 <dgpratt> don't suppose there are any hdbc-odbc experts around I could discuss this with?
13:50:41 <dgpratt> it doesn't help me that information on the correct use of the ODBC API is hard to come by
13:51:41 <geekosaur> dgpratt, might try haskell-cafe
13:51:55 <dgpratt> thanks for the suggestion, geekosaur
13:52:07 <dgpratt> I never think oif the mailing lists for some reason
13:52:10 <dgpratt> *of
13:52:34 <geekosaur> there's a lot of disjoint usage between irc, lists, and reddit
13:52:40 <geekosaur> apparently
13:52:44 * hackagebot animalcase 0.1.0.1 - Convert camelCase to snake_case and vice versa  http://hackage.haskell.org/package/animalcase-0.1.0.1 (ibotty)
13:53:14 * geekosaur does not use reddit however so can only report that via hearsay
13:54:18 <tdammers> wait, someone made camelcase/underscores conversion into a library?
13:54:36 * tdammers just types that out every time
13:55:10 * geekosaur waits for spiky'case
13:55:33 <Twey> @hoogle (a -> d -> e) -> (c -> d) -> a -> c -> e
13:55:34 <lambdabot> Data.Function on :: (b -> b -> c) -> (a -> b) -> a -> a -> c
13:55:34 <lambdabot> Data.Data gmapQl :: Data a => (r -> r' -> r) -> r -> (forall d. Data d => d -> r') -> a -> r
13:55:34 <lambdabot> Data.Data gmapQr :: Data a => (r' -> r -> r) -> r -> (forall d. Data d => d -> r') -> a -> r
13:55:44 <Twey> Hrmph
14:02:09 <quchen> Javran: That's not as lazy as it could be though: isYell3 (repeat 'a') should be False, but doesn't terminate
14:02:36 <quchen> I'm afraid I have to leave, but here's my solution: http://lpaste.net/101680
14:02:46 * hackagebot vinyl 0.3 - Extensible Records  http://hackage.haskell.org/package/vinyl-0.3 (JonSterling)
14:02:59 <quchen> Eh, delete the "Quchen" to get proper comment alignment, I'm in a hurry
14:03:17 * Fuuzetsu deletes Quchen
14:03:25 <Javran> quchen: I'm still trying to understand your article, but thanks for help!
14:03:35 <jonsterling> (BTW, since I haven't figured out how to do a change log, I'll note here that the vinyl release heralded above by hackagebot adds spine-strictness and removes the dependency on transformers)
14:04:04 <Fuuzetsu> jonsterling: I think you just literally write things in CHANGELOG file
14:04:06 <Fuuzetsu> or something
14:04:16 <jonsterling> Fuuzetsu: Oh man, is that all? I'm the worst...
14:04:47 <quchen> Javran: Comments and improvement suggestions are always welcome :-)
14:05:20 <Fuuzetsu> jonsterling: just checked and the changelog button on Hackage just takes me to the CHANGELOG file in the package
14:05:24 <Fuuzetsu> uh
14:05:26 <Fuuzetsu> CHANGES file
14:05:42 <jonsterling> Fuuzetsu: Cool, thanks... I'll have to do that.
14:06:14 <Redz> is there an package for simplification of accelerate on hackage?
14:06:17 <tdammers> sheesh... I just spent 5 whole minutes trying to figure out how to implement `local` from MonadReader for my stack
14:06:29 <tdammers> turns out, it's `local = local`.
14:06:45 <tdammers> beer and coding do not go together well.
14:06:57 <Javran> quchen: I see, thanks for the help and also for that article!
14:07:28 <Fuuzetsu> I'm always queasy about such definitions, I never know if the RHS local is what I want or is it just going to infinitely loop on me
14:07:47 * hackagebot snaplet-mysql-simple 0.2.0.0 - mysql-simple snaplet for the Snap Framework  http://hackage.haskell.org/package/snaplet-mysql-simple-0.2.0.0 (ibotty)
14:08:40 <bitemyapp> tdammers: huh.
14:08:49 <tdammers> Fuuzetsu: this is actually pretty straightforward... the stack in question is just ScottyT on top of an arbitrary MonadReader
14:09:58 <Fuuzetsu> sure but I just don't like the fact that
14:10:03 <Fuuzetsu> > let f = f in f
14:10:06 <Fuuzetsu> is fine
14:10:07 <lambdabot>  mueval-core: Time limit exceeded
14:10:16 <monochrom> it is not fine :)
14:10:22 <Fuuzetsu> typechecks*
14:10:25 <tdammers> monochrom: it compiles...
14:10:52 <monochrom> "show (MyCtor x) = show x" is unproblematic because the MyCtor there tells you there is a difference
14:11:25 <tdammers> actually, I'm not sure whether one-step loops in an instance declaration are actually possible
14:11:27 <monochrom> for this reason, I also don't believe that "local = local" works. I believe you're doing more like "local = MyWrapper local"
14:11:59 <b0bbi10> I don't understand why the record syntax matching has to be value = parameter (line 2) instead of parameter = value (line 5). why does that assign from left to right? Oo http://ideone.com/IYFJOd can you help me?
14:12:50 <rusk101> could somebody help me write a function for checking if a relation is antisymmertric? http://lpaste.net/101681
14:13:05 <monochrom> that is a very ugly colouring. I'm telling my browser to turn off CSS for that paste
14:13:09 <tdammers> http://lpaste.net/101682
14:13:14 <tdammers> this is the instance
14:14:31 <tdammers> or maybe it does loop and I just don't hit the loop
14:14:32 <tdammers> hmm
14:14:37 <monochrom> b0bbi10, you could argue either way, some people are bound to like one and hate the other. there is no pleasing everyone. a coin has to be tossed, and a decision has to be made.
14:14:48 <erisco> is there some lib that perhaps uses template Haskell to read a configuration file into an ADT with minimal plumbing?
14:15:26 <Fuuzetsu> I like to use dyre for those actually-Haskell config files but it might be overkill for you
14:15:35 <monochrom> actually, I do have an argument in favour of the status quo
14:15:46 <b0bbi10> monochrom: so that _is_ really an assignment from left to right?
14:16:00 <b0bbi10> LYAH introduces that piece of code without further explanation
14:16:17 <Fuuzetsu> no assignment, binding
14:16:29 <b0bbi10> and it looks strange because assignments were right to left all the time
14:16:51 <geekosaur> b0bbi10, patterns look like definitions but work backwards. when you create a record, it's Constructor { field = value, ... }
14:16:53 <monochrom> if an example value is written like "Car{field=(1,2)}", then I expect a pattern to parallel that, like "Car{field=(x,y)}".
14:16:54 <b0bbi10> Fuuzetsu: it binds from left to right then
14:17:00 <Fuuzetsu> b0bbi10: you could read it the field of ‚Ä¶ has value
14:17:13 <geekosaur> so when you pattern match it, it's Constructor { field = bindvar, ... }
14:17:22 <monochrom> I don't care about "bind from left to right" or "bind from right to left". wrong dichotomy.
14:18:16 <monochrom> look, if an example list is 1:(2:[]), then I expect a pattern to parallel that, like x:xs, no? you don't re-order things just because of some petty philosophy.
14:18:33 <geekosaur> ^
14:18:38 <monochrom> so why suddenly re-order things when the value happens to be a record?
14:18:43 <b0bbi10> ok, see the point
14:18:53 <erisco> Fuuzetsu, dyre takes a different approach than I would like
14:19:33 <bitemyapp> erisco: I prefer to use *.env files which get sourced by the shell to inject environment variables which the application then reads/accesses to configure itself.
14:19:43 <bitemyapp> erisco: http://12factor.net
14:20:21 <bitemyapp> carter: I can unsafeDupable environment variable reads right?
14:20:28 <carter> yup
14:20:30 <bitemyapp> carter: they're commutative, totally interchangeable operations.
14:20:35 <bitemyapp> yeah I figured, okay.
14:20:41 <carter> unsafedupable === "its ok to run more than once"
14:20:44 <bitemyapp> I just wanted to remove the IO taint, lol :)
14:21:00 <bitemyapp> carter: essentially means, "this is re-entrant" right?
14:21:08 <carter> idempotentant
14:21:12 <bitemyapp> that too.
14:21:18 <carter> reetrant is more like "transactional"
14:21:29 <bitemyapp> read from an env var is definitely idempotent.
14:21:40 <bitemyapp> well unsafeDupable, so far as I knew, allowed concurrent execution
14:21:45 <monochrom> b0bbi10: have you seen my http://www.vex.net/~trebla/haskell/prerequisite.xhtml#unification ?
14:21:46 <bitemyapp> that's why I'm querying about re-entrancy.
14:21:53 <carter> yeah
14:21:54 <carter> well
14:21:58 <carter> they're related
14:22:04 <b0bbi10> monochrom: not yet, will have a look at it
14:22:04 * bitemyapp shrugs
14:22:11 <daimonos> bitemyapp: Hey?
14:22:26 <daimonos> bitemyapp: urbanslug on twitter says hey.
14:22:29 <carter> a good example of something where unsafedupable would be ok is calling a pure hash function on fixed data
14:22:36 <carter> that calls out to c code
14:23:33 <bitemyapp> daimonos: hi
14:25:09 <erisco> bitemyapp, I do not have a problem with the config file format. It is the reading of the configuration into an ADT that is problematic (it requires much repetition)
14:26:22 <rusk101> could somebody help me write a function that checks if a relation is antisymmetric? this is what I have so far http://lpaste.net/101681
14:27:12 <monochrom> what is antisymmetry again?
14:27:19 <bitemyapp> erisco: a sum type?
14:27:25 <companion_cube> x R y & y R x => x=y?
14:27:30 <rusk101> yes
14:27:44 <erisco> bitemyapp, I do not know what a sum type is
14:27:49 <rusk101> Its the last one I need
14:27:51 <bitemyapp> erisco: Maybe is a sum type.
14:27:58 <bitemyapp> erisco: do you mean that when you say ADT?
14:28:05 <bitemyapp> erisco: a record is a product type, as well.
14:28:25 <erisco> okay, well, I am not sure what you are saying, but I mean something declared by "data"
14:28:44 <bitemyapp> erisco: a data decl can generally be a product type or a sum type
14:28:54 <bitemyapp> erisco: is it a record? does it use the glyph "|" ?
14:29:00 <erisco> no
14:29:15 <bitemyapp> erisco: I have a library I could recommend but you sound like you might need to get a little more comfortable with Haskell itself.
14:29:18 <monochrom> ok, then it looks like [x==y | (y,x) <- r, elem (x,y) r]
14:29:34 <bitemyapp> erisco: is the data decl a one-liner? can you paste it?
14:29:58 <erisco> bitemyapp, I am fairly comfortable with Haskell. I just do not know what "sum type" or "product type" means
14:30:07 <bitemyapp> erisco: well, you know what Maybe is right?
14:30:16 <erisco> I know its definition
14:30:21 <bitemyapp> erisco: what does ADT stand for when you use it?
14:30:33 <bitemyapp> because it can mean "algebraic data type" or "abstract data type"
14:30:58 <erisco> I mean the former
14:31:22 <erisco> Haskell docs say "we have ADTs and they are declared by 'data'" so I call them ADTs
14:31:32 <rusk101> Thanks mono
14:31:59 <erisco> bitemyapp, but I read on the wikipedia article just now for ADT what product type and sum type means
14:32:42 <erisco> I am familiar with "tagged union" and "variant type", and so it seems "sum" is another name
14:32:43 <monochrom> "data P = Hello Int Bool" is a product type. Int times Bool.
14:33:08 <monochrom> "data S = Gee Int | Whee Char" is a sum type. Int plus Char
14:33:09 <bitemyapp> erisco: a tagged union is a sum type.
14:33:14 <bitemyapp> monochrom: bless you. Thank you.
14:33:36 <tdammers> it makes sense if you think about types as sets of possible values
14:33:42 <monochrom> "data M = Hello Int Bool | Aloha Char" has a sum and a product. Int*Bool + Char.
14:33:47 <erisco> monochrom, this agrees with what I understand from the article, but what does one ...
14:33:49 <hc> "data Nice = Nice; data World = World; data Haskell = Haskell; data P = Hello Nice Haskell World" ;p
14:33:52 <erisco> oh okay you answered that there
14:34:32 <pavonia> Also a good read on that topic: http://chris-taylor.github.io/blog/2013/02/10/the-algebra-of-algebraic-data-types/
14:34:41 <erisco> alright, well in that case the ADT is a product type of all the configuration fields
14:47:56 <hcaulfield57> I'm trying to debug this snake game that I wrote, it works, but the snake will never grow, the problem seems to be in the addSnake function, if anyone could help, it would be much appreciated!
14:48:02 <hcaulfield57> http://lpaste.net/101684
14:49:18 <Fuuzetsu> hcaulfield57: did you try to take out the growing logic and testing it?
14:49:34 <hcaulfield57> Fuuzetsu: What do you mean?
14:49:49 <monochrom> test addSnake independently
14:50:01 <Fuuzetsu> have a Snake -> Direction -> Snake function which lets you test the logic without the IO gunk
14:50:18 <hcaulfield57> Oh, I'll give it a shot, I'll let you know
14:50:24 <monochrom> that's even better
14:50:44 <Fuuzetsu> an alternative is to add prints although it's much less testable that way
14:50:58 <Fuuzetsu> (you can do both I suppose)
14:52:41 <triliyn> hcaulfield57: (maxx,maxy) = getPt . minPt $ head snake -- this sounds like a mistake
14:53:06 <hcaulfield57> triliyn: How come?
14:53:57 <triliyn> They're the same as minx and miny; I would assume they're supposed to be from maxPt instead
14:54:21 <hcaulfield57> I didn't even notice that!
14:54:24 <hcaulfield57> Lemme try
14:54:41 <Fuuzetsu> nominolo: what does wiki admining encompass? Do you need more admins?
14:56:05 <hcaulfield57> triliyn: Well that was definitely a mistake, but it doesn't seem to make a difference
14:56:17 <triliyn> hmm, okay
14:57:52 <b0bbi10> monochrom: tried to read your thoughts on Unification, but I don't think I understand 95 % of it. but never mind, I'll go on and try to learn Haskell ;)
14:59:54 <mars0000> what could be a cause for failing to install gtk-0.12.5.6?
15:00:16 <hcaulfield57> mars0000: OS X?
15:00:20 <mars0000> http://lpaste.net/101686
15:00:28 <mars0000> ubuntu
15:00:43 <hcaulfield57> Nevermind then, I know it's currently broken on OS X
15:02:10 <b0bbi10> monochrom: is math skill really needed for Haskell?
15:02:36 <Kam_> b0bbi10: To just use it normally, not really
15:02:37 <monochrom> depends on what math you mean. very basic school math, yes of course.
15:02:40 <bitemyapp> b0bbi10: nope, I'm awful at math.
15:02:49 <bitemyapp> b0bbi10: arithmetic and basic algebra are useful.
15:02:57 <hcaulfield57> I can't do math at all, although I do also suck at Haskell :)
15:03:03 <Kam_> But to understand what's going on in there you will need some more advanced math lol
15:03:10 <monochrom> bitemyapp, we're referring to my http://www.vex.net/~trebla/haskell/prerequisite.xhtml
15:03:39 <b0bbi10> monochrom: I am checking your list of prerequisites for learning Haskell
15:03:39 <mars0000> hcaulfield57: could you help me look at http://lpaste.net/101686 ?
15:03:44 <b0bbi10> yep
15:03:50 <mars0000> This is the information I got
15:04:44 <monochrom> mars0000: I think maybe adding "-v" to your "cabal install ..." command may generate more information
15:04:50 <hcaulfield57> mars0000: Yea I dunno what the problem is, I just know it doesn't work on OS X, although I can tell you it does build on Linux fine
15:04:54 <monochrom> at present I'm betting on "out of memory"
15:05:23 <monochrom> I'm also ready to bet on "solar activities"
15:05:33 <bitemyapp> monochrom: oh, sorry.
15:05:34 <sipa> phase of the moon
15:07:31 <jle`> b0bbi10: nope :D
15:07:47 <jle`> b0bbi10: but there are certain math skills needed for real life in the real world
15:08:21 <monochrom> I think whenever "math" appears, people knee-jerk think that it must refer to celestrially advanced math
15:08:43 <monochrom> not basic things like "= is reflexive symmetric transitive"
15:08:59 <monochrom> not basic things like "(\x -> x+x) 5 = 5+5"
15:08:59 <Fuuzetsu> you made me check whether there's actually an ‚Äòr‚Äô in ‚Äòcelestially‚Äô ;(
15:09:08 <hcaulfield57> I think the problem must be in some other function.
15:09:20 <zerokarmaleft> bitemyapp: maybe late to the party, but http://cokmett.github.io/cokmett/
15:09:23 <monochrom> I did not check spelling
15:09:24 <hcaulfield57> Although some concepts in Haskell do come from celestially advanced math
15:10:41 <monochrom> although, unification is pretty advanced. not conceptually advanced. computationally advanced. it is exponential time for computers already. so nevermind humans.
15:11:14 <companion_cube> unification is actually linear, afaik
15:11:25 <bitemyapp> zerokarmaleft: seen it before, amuses me :)
15:11:37 <bitemyapp> zerokarmaleft: I think some people get grumpy at the hero worship kmett gets (deservedly or not) though.
15:11:50 <bitemyapp> zerokarmaleft: you see the slide at clojure west me and ddellacosta got mentioned in?
15:11:53 <Fuuzetsu> I'm going to need to study cabal-install (and possibly Cabal), is there recommended reading before I dive right into it?
15:12:07 <mars0000> http://lpaste.net/101687
15:12:11 <hcaulfield57> I think Haskell is probably harder if you already know some programming language, that is likely not functional.
15:12:21 <zerokarmaleft> bitemyapp: I have not...something regarding instaparse?
15:12:21 <monochrom> yes Fuuzetsu, my http://www.vex.net/~trebla/haskell/cabal-cabal.xhtml
15:12:21 <jle`> definitely
15:12:51 <mars0000> monochrom: almost the same information after adding -v
15:13:12 <mars0000> will "-v" tell if this was caused by "out of memory"?
15:13:27 <monochrom> I see. that's pretty bad. I don't know what's going on.
15:13:35 <tel> Anyone have any information on doing type level sets?
15:13:36 <Fuuzetsu> monochrom: not quite what I'm after, not at all even ;P
15:13:43 <Fuuzetsu> I'm looking for something like GHC commentary for Cabal I guess
15:15:02 <tel> I'd like to be able to write `join :: Rel as -> Rel bs -> Rel (union as bs)`
15:15:11 <tel> But I fear it's time to move to DTs
15:15:56 <pyon> Is there any way to do something like "ghc-pkg list" for the current sandbox?
15:15:58 <Fuuzetsu> first result on Google http://stackoverflow.com/questions/18444942/type-level-sets-in-haskell-agda
15:16:06 <Fuuzetsu> pyon: cabal sandbox hc-pkg list
15:16:19 <pyon> Fuuzetsu: Thanks.
15:16:24 <Fuuzetsu> (note the missing ‚Äòg‚Äô)
15:16:41 <pyon> Yeah. :-)
15:17:21 <tel> Fuuzetsu ... Ha, sorry 'bout that. I could have sworn all the things out there were just old dead haskell-cafe posts
15:17:27 <pyon> In order to do "cabal repl", I need to init a cabal package, right? A sandbox is not enough, right?
15:17:35 <pavonia> mars0000: Does it proceed compiling if you run cabal again?
15:17:42 <Fuuzetsu> tel: I lied, it was a second result
15:18:05 <mars0000> pavonia: No, I tried several times
15:18:51 <haasn> tel: you can hack pretty much anything you want into the type system using TFs+DataKinds+UndecidableInstances but it gets very ugly very fast
15:19:15 <haasn> tel: my approach would probably be to just use sorted lists as ‚Äúsets‚Äù
15:19:31 <haasn> but you could implement a BST on the type system without too much hassle
15:19:39 <nominolo> Fuuzetsu: mostly just creating accounts and occasionally looking over the recent edits and see that there's no spammy stuff
15:19:50 <pavonia> mars0000: Not even if you run cabal configure and cabal build?
15:20:41 <mars0000> pavonia: I didn't get it. what should I do?
15:21:14 <Fuuzetsu> haasn: except you can't reasonably hack in DTs
15:21:21 <tel_> haasn Yeah, I'm foraging to understand how ugly how fast
15:21:25 <quchen> Javran: So I'm back for a bit. Did you figure the algorithm out?
15:21:29 <pavonia> mars0000: "cabal configure", "cabal build" and if it fails "cabal build" again
15:21:35 <jle`> has anyone worked with using free arrows to build graphs in haskell?
15:22:12 <quchen> Javran: If it helps, here's the same code again, but with a version of "isYell" that uses explicit recursion instead of foldr. http://lpaste.net/101688
15:22:30 <mars0000> pavonia: I'm trying to see if it was a memory issue
15:24:47 <haasn> tel_: the LHS of a TF instance declaration can only be a basic pattern match, eg. Foo X Y a b = ... -- ie. no view patterns, no guards, no conditions, no submatches; although you can use the same variable twice (which actually constrains that those two parameters must be the same)
15:25:25 <haasn> tel_: the RHS of a TF instance must contain a type expression, which basically restricts you to type application (among other things such as ‚Äòforall.‚Äô and constraints ‚Äò=>‚Äô)
15:25:59 <haasn> tel_: this means, we have no: let/in; no case/of; no if/then/else, no where, no lambdas, etc.
15:26:22 <haasn> tel_: it's equal in power, but any possible subdefinition or sub-pattern-match you'd want has to go through a new top level name
15:26:57 <Fuuzetsu> nominolo: I could help out if you're short on people I suppose
15:27:29 <haasn> tel_: it's also problematic w.r.t strictness/performance in GHC's implementation; a type-level IfThenElse will compute both the ‚ÄòThen‚Äô and the ‚ÄòElse‚Äô cases
15:27:42 <Javran> quchen: I've got some early idea about giving control to "go", but not quite get it. I'm busy doing some other works now :(
15:28:00 <haasn> tel_: that's the short summary, at any rate
15:28:20 <tel_> haasn Thanks! Thanks definitely a lot of mess...
15:29:01 <stephenmac7> Would this be the "right" way to use the Reader Monad? http://lpaste.net/101690
15:29:34 <Fuuzetsu> unwrap = getName
15:29:57 <jle`> stephenmac7: what are you trying to do?
15:30:10 <tel_> haasn I've been making due so far essentially using Vinyl's method, but they depend a lot on the simple structure of a type level list. I also suppose I could write a a type-level append-uniquely
15:30:42 <jle`> if you are trying to access a Test in the 'environment', you would do 'ask' to get the Test, and then getName what you asked for.
15:30:46 <haasn> tel_: I did some work related to this for https://github.com/haasn/units/blob/master/src/Units/Internal/Types.hs
15:30:51 <jle`> stephenmac7: what type signature do you expect unwrap to have?
15:31:03 <jle`> getName isn't a monad, so you can't really use it like that in do notation
15:31:12 <stephenmac7> jle`: Actually, I want to use the Reader monad for a blaze template
15:31:16 <bitemyapp> Can I get critiques of my post? http://bitemyapp.com/posts/2014-03-24-monads-bind-join-actions.html
15:31:23 <stephenmac7> The above was just a test.
15:31:27 <jle`> oh getName can be a monad.
15:31:29 <byorgey> jle`: sure you can, getName is a function, and (->) e  is a monad
15:31:30 <mars0000> pavonia: I think it was a memory issue. It's installed now. Thanks!
15:31:36 <jonsterling> bitemyapp: Adding it to my reading list
15:31:41 <jle`> stephenmac7: can you give an example of what you want to do?
15:31:45 <haasn> tel_: see the definition of ‚Äúdata Unit‚Äù in line 135, it's basically a Map [TChar] Int
15:31:51 <haasn> tel_: which is similar to a Set
15:31:55 <jle`> byorgey: yeah haha. realized that.  but it's not an instance of Reader, which is what stephenmac7 is trying to do I think.
15:32:17 <jle`> it is an instance of a monad that is identical to reader for the most part though >.>
15:32:21 <haasn> tel_: the interesting instances are at https://github.com/haasn/units/blob/master/src/Units.hs#L26
15:32:22 <jle`> without the newtype wrapper
15:32:29 <bitemyapp> jonsterling: I can almost guarantee you won't like it.
15:32:37 <stephenmac7> A page with <p>SomeString SomeNumber</p> (and boilerplate html) generated with Blaze
15:32:38 <jonsterling> bitemyapp: Uh-oh!
15:32:47 <bitemyapp> jonsterling: it's a hacky specific example lesson. Not very elegant :(
15:32:56 <tel_> haasn Oh, that's perfect
15:32:59 <bitemyapp> jonsterling: but I'm hoping it lends intuition to how nested thunks in monads works.
15:33:02 <bitemyapp> work*
15:33:08 <jle`> bitemyapp: what's wring it IO (IO ()) ?
15:33:11 <stephenmac7> The blaze tutorial recommends using the reader monad... but doesn't provide an example.
15:33:18 <bitemyapp> jle`: it's a smell. Read the post.
15:33:18 <jle`> stephenmac7: ah
15:33:33 <stephenmac7> "In the previous example, the user would probably be pulled out of a reader monad instead of given as an argument in a realistic application." on http://jaspervdj.be/blaze/tutorial.html
15:33:35 <tel_> haasn I'd been eyeballing this as well https://github.com/haasn/units/blob/master/src/Units/Internal/TypeOrd.hs
15:33:50 <jonsterling> bitemyapp: Those can be useful!
15:33:51 <haasn> tel_: I think there are better versions of that in GHC HEAD now, it's quite dated
15:34:02 <haasn> tel_: there's <=? in base but I'm not sure what instances it has
15:34:32 <Fuuzetsu> bitemyapp: I'm confused as to its purpose. Does it try to show off join?
15:34:43 <stephenmac7> I should have given a more thorough code sample
15:34:50 <haasn> tel_: oh, never mind; base's <=? is constrained to work on Nat only
15:34:55 <jle`> i think i use blaze with reader in my blog source
15:34:56 <jle`> let me see
15:34:58 <stephenmac7> I realize unwrap = getName would be a lot better
15:35:04 <stephenmac7> :D
15:35:05 <haasn> tel_: in other news, the code I have could be rewritten to use GHC Nats instead of my own peano construction, most likely
15:35:27 <bitemyapp> Fuuzetsu: it's designed to make monads less magical/mysterious, and demonstrate the unrolling of structure. Particularly as it relates to how it can change when/where side effects happen. Or if they happen at all.
15:35:43 <bitemyapp> Fuuzetsu: that IO (IO ()) could never get flattened, and therefore, my damn putStrLn would never happen.
15:35:46 <tel_> haasn Ah, just found it myself. And yeah, I have no problem using newer base, but I'm still not on HEAD or 7.8 yet so I'll try to aim for 7.6.3
15:35:50 <bitemyapp> that's...not kosher :)
15:36:03 <haasn> tel_: none of my code works in 7.6; none of this works in 7.6 at all, in fact
15:36:24 <tel_> haasn Well, that answers that question : )
15:36:31 <haasn> tel_: 7.6 doesn't have closed TFs yet so all your instances must be consistent
15:36:58 <haasn> which means that you can't have, say, ‚ÄúCmpList' EQ a b = CmpList a b‚Äù and ‚ÄúCmpList' c a b = c‚Äù
15:37:07 <Fuuzetsu> bitemyapp: it would not be a problem if only you had a type signature of what you were expecting it to be
15:37:22 <haasn> because CmpList' c a b = c -- matches CmpList' EQ a b as well
15:37:44 <haasn> there's no ‚Äúorder of pattern matching‚Äù with classical TF instances, similar to class instances; this is something exclusive to closed TFs, which operate more like functions
15:38:04 <jle`> stephenmac7: are you familiar with the reader monad in general?
15:38:13 <bitemyapp> Fuuzetsu: I didn't know what to expect for behavior WRT IO () vs. IO (IO ()), that's why this post is needed.
15:38:21 <b0bbi10> hello, in "read "Just 't'" :: Maybe a" does 't' have to adhere to
15:38:25 <stephenmac7> I only know what was in LYAH.
15:38:29 <b0bbi10> 'a' or the other way around?
15:38:36 <tel_> haasn Hm.. You can get some form of that with type class bingo though, right?
15:38:53 <bitemyapp> Fuuzetsu: the type expectations aren't enough if you don't know explicitly what types will produce what results you want.
15:38:53 <haasn> tel_: with OverlappingInstances, maybe
15:39:01 <bitemyapp> Fuuzetsu: this post hopefully will help teach people to know what to want.
15:39:17 <haasn> tel_: the alternative is to specify all your instances manually; eg. having two lines for ‚ÄúCmpList' LT a b = LT‚Äù and ‚ÄúCmpList' GT a b = GT‚Äù in addition
15:39:19 <Fuuzetsu> bitemyapp: I see
15:39:23 <b0bbi10> I would say that 't' has to adhere to 'a' because 'Just a' is of type 'Maybe a'
15:39:33 <tel_> haasn As this increasingly turns into an exercise in how to make Haskell accept my typing Agda looks nicer and nicer, sigh
15:39:40 <Fuuzetsu> by the way, easy example, return (return "hello") :: IO (IO String)
15:39:47 <haasn> tel_: but that won't work, for, say: ‚Äútype family (a :: k) == (b :: k) :: Bool where a == a = True; a == b = False‚Äù
15:39:57 <haasn> because ‚Äòk‚Äô is polymorphic, we can't possibly list constructors
15:40:05 <bitemyapp> Fuuzetsu: sometimes the curse of knowledge can make it difficult to empathize with or predict certain pedagogical problems. I got tripped up by this one recently and was alarmed because I saw virtually zero literature that explicitly laid it out.
15:40:16 <tel_> haasn I see
15:40:21 <bitemyapp> It was entirely implicit in the nature of the de-nesting of the monad.
15:40:36 <bitemyapp> Fuuzetsu: which might be enough for smart people like you, but it isn't for me.
15:40:42 <haasn> tel_: yes, hacking in the haskell type system has often made me wish it had DTs :(
15:40:46 <bitemyapp> I need my nose shoved in things.
15:41:06 <tel_> haasn At the very least I could flesh out the design there
15:41:09 <Fuuzetsu> bitemyapp: Sure, I don't mean to discourage you.
15:41:09 <bitemyapp> haasn: I don't find I crave DTs that much, although Idris is super-cool, but a kind system that was typed would be nice.
15:41:33 <iota_> [A[B/w 1
15:41:34 <haasn> bitemyapp: I'm not sure what you mean
15:41:39 <haasn> kind system that was typed?
15:42:15 <tel_> bitemyapp universes?
15:42:28 <jonsterling> tel_: As Bob Harper will point out, not quite universes...
15:43:00 <haasn> tel_: do note that there is some work done in the direction of auto-lifting haskell functions to the type level via TH, in the singletons library
15:43:03 <haasn> @hackage singletons
15:43:03 <lambdabot> http://hackage.haskell.org/package/singletons
15:43:05 <bitemyapp> haasn: *
15:43:11 <tel_> jonsterling I don't understand that reference... excepting that Bob Harper is prone to pointing out things : )
15:43:16 <haasn> http://www.cis.upenn.edu/~eir/packages/singletons/README.html
15:43:27 <bitemyapp> tel_: there was an exchange on twitter between harper and ezyang you may want to check out.
15:43:38 <bitemyapp> tel_: even better would be if jonsterling had a literary reference.
15:43:59 <jonsterling> And the kind system in modern Haskell is sort of typed... It's just really hard to work with. Something tells me Haskell folk might like something like Omega---All the phase separation you could possibly want, in spite of the fact that we know from Brady & McBride & friends that phase separation need not be in the same place as the small-large type
15:44:00 <jonsterling> distinction.
15:44:14 <bitemyapp> jonsterling: oh, I've seen Omega. I just don't have time to play with it.
15:44:20 <bitemyapp> jonsterling: I'd rather learn Vinyl! :P
15:44:41 <jonsterling> bitemyapp: Learn it, and then help me implement it! Somebody need to add extensible sums.
15:45:28 <stephenmac7> jle`: I'm having issues with it. I have this currently, though: http://lpaste.net/101690
15:45:43 <bitemyapp> jonsterling: extensible meaning the extension produces a new type, we don't mean open unions here right?
15:45:45 <haasn> ‚Äúthe following constructs will be coming soon:‚Äù ‚Äú.. case, let, lambda expression ...‚Äù  :(
15:45:48 <stephenmac7> test.hs:24:12:
15:45:48 <stephenmac7>     Couldn't match type `Int' with `String'
15:46:02 <haasn> I forgot how useless ‚Äúsingletons‚Äù is
15:46:04 <nominolo> Fuuzetsu: thanks, once a better sign-up system is in place we'll evaluate how many admins we'll need
15:46:13 <tel_> Twitter conversations are tough to piece back together
15:46:23 <jle`> stephenmac7: you use read pts on line 26
15:46:28 <jle`> you can only read a string
15:46:29 <jle`> :t read
15:46:30 <lambdabot> Read a => String -> a
15:46:45 <tel_> I want a graph view
15:46:57 <haasn> stephenmac7: I think you meant ‚Äòshow‚Äô, not ‚Äòread‚Äô
15:46:59 <jonsterling> bitemyapp: Well, not "extensible" in the sense of ML-style exn, etc.; that would be cool, but something like that needs to include a runtime-effect component, which isn't safe in Haskell. Rather, extensible in the sense that you can compositionally create sum datatypes... The dual to vinyl.
15:47:00 <bitemyapp> Fuuzetsu: any other feedback?
15:47:16 <bitemyapp> jonsterling: that's what I figured you mean, the dual to Vinyl.
15:47:25 <jonsterling> Linyv
15:47:38 <bitemyapp> jonsterling: I wouldn't be willing to emulate anything from ML that cannot be statically safe in Haskell.
15:47:48 <bitemyapp> runtime reflection is not why I'm porting my code to Haskell -_-
15:48:16 <tel_> Oh, it was a response to Haskell for Coq Programmers
15:48:20 <jonsterling> bitemyapp: Please. The reason it can't be safe in Haskell is that Haskell does not support data abstraction.
15:48:32 <bitemyapp> jonsterling: I know, that's me point.
15:48:41 <bitemyapp> jonsterling: I'm not going to do anything that extends beyond its faculties.
15:49:00 <jonsterling> bitemyapp: Oh, I see! I thought the worst, but what you were saying is quite reasonable. :)
15:49:30 <stephenmac7> jle`: haasn: My stupid mistake :P
15:49:41 <bitemyapp> jonsterling: tl;dr "I'm not going to lose static safety so I can pimp my ride"
15:49:54 <bitemyapp> even if other schoolyards have nicer jungle gyms.
15:49:56 <jonsterling> bitemyapp: Totally agree. Definitely don't want to do that.
15:50:12 <greg`> hi haskellers
15:50:18 <bitemyapp> greg`: ahoy
15:50:29 <greg`> whats a good library for http client
15:50:34 <jonsterling> bitemyapp: There's a nice page on the SML/NJ wiki I think which demonstrates how exn murders type safety if it can't be generative...
15:50:54 <bitemyapp> greg`: do you want something that's pretty serious and allows constant-space streaming or a library that'll spit out an `IO String`?
15:51:22 <greg`> oooooh choices.....can i have both alternatives
15:51:37 <bitemyapp> greg`: well anyway, there's http-conduit if you want the former (tutorial on the Yesod Book website), and then there's HTTP
15:51:38 <greg`> probaly want to spit io string to start
15:51:45 <bitemyapp> greg`: there's an io-streams based one called http-streams too!
15:51:46 <greg`> aha
15:52:01 <bitemyapp> greg`: I actually just wrote a post that incorporates HTTP incidentally. See here: http://bitemyapp.com/posts/2014-03-24-monads-bind-join-actions.html
15:52:14 <greg`> nice thanks
15:52:36 <haasn> there's also pipes-http
15:52:36 <bitemyapp> greg`: String is kinda ick though, so I'd try to flip over to something that returns bytestrings if possible.
15:52:51 <kuribas> Is it better to use a list function on lists, rather than it's traversable counterpart?
15:52:53 <bitemyapp> haasn: I'm lazy and rather like http-conduit's httpLbs :)
15:54:17 <greg`> ah yes , i have no issue chewing bytestrings
15:54:18 <haasn> bitemyapp: you can still get a LBS out of a Producer using fmap fromChunks . toListM
15:54:25 <haasn> but that's not idiomatic
15:54:31 <greg`> do these libraries support https?
15:54:39 <bitemyapp> haasn: right, I want something that won't punish me :P
15:54:41 <jle`> i wonder who __class__  and __main__ are
15:55:16 <jle`> ah they hang around #python, that makes sense
15:55:18 <jle`> *more sense
15:55:28 <stephenmac7> jle`: python programmers, I guess
15:55:38 <jle`> interesting names.
15:55:56 <haasn> bitemyapp: I guess conduit has the market share advantage for http stuff thanks to warp
15:56:09 <haasn> I don't know my way around conduit as much as around pipes, though :(
15:57:25 <tel_> greg` the libraries based on http-client (http-conduit, pipes-http) both support TLS via http-client-tls
15:57:53 <tel_> greg` not sure about the others
16:00:09 <kuribas> Does anyone know how to get emacs to show types in the minibuffer?
16:00:28 <kuribas> Also types from the buffer it's visiting?
16:01:13 <bitemyapp> haasn: I wouldn't attribute Conduit's popularity to that alone.
16:04:24 <greg`> kuribas: usually you have to hover over the type to see it
16:04:50 <kuribas> yes, but I can only see standard names such a foldl, etc, not types from my project.
16:04:56 <kuribas> Or from cabal.
16:05:34 <levi> kuribas: Do you have hdevtools or ghc-mod installed?
16:05:50 <kuribas> Seeing type and documentation for a function from cabal would be extremely useful!
16:05:52 <kuribas> levi: no
16:07:01 <pyon> "<jonsterling> bitemyapp: Please. The reason it can't be safe in Haskell is that Haskell does not support data abstraction." --> Do you mean, like, how Haskell does not have anything like ML's opaque ascription?
16:07:16 <levi> ghc-mod has an emacs mode, ghc-mode, that provides C-c C-t to show the type of the expression at point
16:07:30 <levi> ghc-mode is an extension to haskell-mode
16:07:45 <jonsterling> pyon: That, and the fact that there are no generative constructions.
16:08:26 <levi> hdevtools integrates into flymake-mode to give you on-the-fly error checking.
16:08:55 <levi> You can theoretically make either of the two do most of the same things, but those are the things that seem to work best out-of-the-box.
16:08:56 <pyon> jonsterling: Like ML's generative exceptions? To be frank, exceptions and refcells are precisely what I dislike the most about ML. If it were not for them, modules could safely be applicative.
16:09:18 <pyon> s/modules/functors/
16:09:43 <kuribas> levi: looks very nice!
16:09:55 <levi> kuribas: You may run into issues with cabal sandboxes, though, especially with hdevtools.
16:10:03 <jonsterling> pyon: The exceptions, yeah. I happen to think the exceptions are pretty cool, but yeah, refs are a wart which arises from it being really difficult to program in granular effect modalities in ML
16:11:44 <jonsterling> pyon: But I think it is likely that generative constructions are useful even when you aren't stuck in the "IO + Exceptions + References" tarpit modality. I'm sort of imagining a world in which you can make it so that definitional equality does not apply to certain things‚Äîit would be not provable in the system that F(X).t == F(X).t, but perhaps it wouldn't
16:11:44 <jonsterling> be possible to disprove it either.
16:12:09 <dpwright> hey, I've been doing most of my haskell stuff on linux until recently, but I'm just switching my work computer to a mac -- what is the best way to get set up in OS X?  I use homebrew for most things, which is nice because it's all one system, but in general the haskell platform installer seems to be what people recommend
16:12:58 <jonsterling> Or, to be more precise, you could create cases where Œ≤-Œ∑ equality would not suffice to give a proof of equality. Abstraction & generativitiy are necessary to achieve safety with side effects, but they are probably useful without side effects too...
16:13:02 <dpwright> (as an aside, do we know yet when a haskell platform release for the latest GHC is likely to come out?)
16:15:10 <pyon> jonsterling: Regarding exceptions, I think there are two kinds of errors: 1. fatal errors, which can only be dealt with by aborting the whole program (basically, "exit(EXIT_FAILURE);"), and 2. non-fatal ones, which are more profitably dealt with by making the return type of the operation a sum type like "Either e a". Nonlocal control of flow is evil and gets in the way of resource management, which any nontrivial program that does
16:15:10 <pyon> anything besides theorem proving has to do.
16:20:41 <pyon> jonsterling: And I have no idea what you gain by making things not provably equal to themselves.
16:21:12 <jonsterling> Well, the idea would be that (let module M = F(X) in M.t == M.t) would be provable.
16:22:49 <stephenmac7> jle`: Got it. http://lpaste.net/101690
16:24:06 <mniip> is there a way to launch GHC without threads?
16:24:15 <jle`> stephenmac7:  congrats :)
16:24:23 <pyon> jonsterling: But "let module M = F(X) in let module N = F(X) in M.t == N.t" would not, right?
16:24:43 <stephenmac7> :)
16:27:07 <jonsterling> pyon: Exactly!
16:27:27 <merijn> dpwright: Which OSX version?
16:27:35 <dpwright> mavericks
16:27:52 <dpwright> :-/
16:28:18 <merijn> dpwright: I personally use the platform, which works great for me. But the latest platform wasn't updated to support Apple dropping gcc, there's a workaround in the topic, though
16:29:22 <dpwright> merijn: in the topic on what? the wiki? ghc trac?  or does the platform have its own trac?
16:29:26 <geekosaur> mniip, if you mean ghci, no, it always uses the threaded runtime
16:29:28 <geekosaur> mniip, if you mean ghci, no, it always uses the threaded runtime
16:29:32 <geekosaur> the channel
16:29:39 <mniip> no, GHC
16:29:47 <dpwright> ohhhh, sorry!
16:30:06 <geekosaur> ghc defaults to the non-threaded runtime, you need to build with -threaded and use an RTS option to get threads
16:30:11 <dolio> jonsterling: But why do you want that, apart from hidden effects?
16:30:16 <geekosaur> (you will still have "green threads")
16:30:23 <pyon> jonsterling: The lack of equational reasoning is what makes me always come back to Haskell, despite the warts (type classes and newtype being decidedly inferior to signatures and opaque ascription). :-|
16:30:26 <mniip> geekosaur, for some reason it calls clone()
16:30:41 <geekosaur> oh. IO is always a separate thread
16:30:45 <geekosaur> no way to disable that
16:31:13 <dpwright> ok, thanks, will take a look at that
16:31:34 <geekosaur> that is, the runtime has an I/O manager, and it has a bound thread.
16:32:07 <geekosaur> because there has to be somewhere to run any system call that blocks
16:32:41 <merijn> dpwright: I meant the channel topic :)
16:35:45 <pyon> jonsterling: That being said, I do not think it should be impossible to have both data abstraction and equational reasoning. Every time you make a definition, you are making two judgements: a type judgement (x has type T) and a definitional equality judgement (x is definitionally equal to "foo bar baz"). Modularity is simply about carefully controlling access to the second judgement to the rest of the program.
16:49:33 <jonsterling> pyon: Exactly right!
16:56:14 <erisco> ghc-pkg seems to be using an incorrect database path and thus is thinking every package is broken
16:56:25 <erisco> how can I see what path it is using currently and how can I change that path?
16:57:09 <monochrom> "ghc-pkg describe containers" is an example
16:57:20 <monochrom> I think it's pretty tedious to change by hand
16:57:25 <erisco> ah actually 'cabal list' gives the package.conf file being used
16:57:40 <monochrom> do not trust cabal list. it lies.
16:57:49 <erisco> turns out it is picking up on the mingw install... whoops
17:01:27 <ski> jonsterling : "There's a nice page on the SML/NJ wiki I think which demonstrates how exn murders type safety if it can't be generative..." -- which are you thinking about ?
17:01:35 <ski> jonsterling,pyon : hm, could one say that opening existentials is generative in Haskell (with existebntials extension) ?
17:01:48 <gentleben> what comments out multiple lines in a cabal file?
17:02:06 <monochrom> --
17:02:19 <monochrom> oh, multiple lines, nevermind. use a lot of -- :)
17:02:19 <geekosaur> afaik there's only the to-end-of-line comment style
17:02:24 <geekosaur> no {- -}
17:02:35 <jonsterling> ski: Ah, it wasn't SML/NJ but rather mlton: http://mlton.org/GenerativeException
17:02:50 <erisco> I just have to figure out how to point back to the Haskell platform install and not the mingw one
17:02:57 <erisco> where is the global variable? gah!
17:03:02 <monochrom> I think some editors can do many -- for you
17:03:20 <ski> jonsterling : ty
17:04:04 <monochrom> erisco, I don't understand. what does "the mingw one" mean? in fact, does it even exist?
17:04:35 <kadoban> quickcheck sure is the coolest thing ever
17:05:34 <erisco> monochrom, well I was trying to compile ghcjs on windows, which required newer versions of ghc and cabal, and I was probably using the mingw environment for the install, so things are under some mingw directory
17:06:03 <ski> jonsterling : e.g. long ago, there was a thread on c.l.f where Adrian Hey (iirc) showed how to use existentials to simulate functors
17:06:06 <erisco> but this evidently mucked up the version that comes with the Haskell platform
17:07:04 <monochrom> ok, you are saying you put on a second copy of ghc. the second copy is not going to honour the libraries known to the first copy.
17:08:00 <monochrom> if you have not overwritten any old files, then you can use the first copy's libraries... by using the first copy of ghc
17:08:07 <erisco> I do not expect it to. however, when I try to use ghc-pkg from the Haskell platform, it is now using the wrong database
17:08:41 <monochrom> ok, then some files were overwritten. lost data is lost.
17:09:11 <erisco> yes but clearly it is the variable that determines the global package database which was altered
17:09:55 <jle`> what is yalls favorite functors
17:10:32 <ski> jle` : `CoYoneda f'
17:11:04 <monochrom> how should I put it? there is no such variable in the normal sense.
17:11:17 <erisco> it has to locate it somehow
17:11:25 <erisco> it used to look in one place, then another
17:11:55 <erisco> which indicates a configuration file, or environment variable was modified
17:12:19 <erisco> "If the environment variable GHC_PACKAGE_PATH is set, and its value does not end in a separator (: on Unix, ; on Windows), then the last database is considered to be the global database"
17:12:46 <monochrom> there are a few shell scripts. they have directory names hardcoded. you could say, so you go in modify those shell scripts. that is all very well, the consequences of doing so are complicated.
17:13:06 <monochrom> GHC_PACKAGE_PATH is normally not set at all
17:14:17 <ski> jonsterling : anyway, i'm not sure we want generativity to fix the problem mentioned on that page
17:14:44 <colDrMcBeardman> > logBase 10 1000
17:14:45 <lambdabot>  2.9999999999999996
17:14:53 <monochrom> actually I'm only telling the linux story. the windows story is even darker. probably hardcoded in exe's directly
17:14:53 <colDrMcBeardman> @lambdabot why?
17:14:54 <lambdabot> Unknown command, try @list
17:15:09 <macanudoman> logBase 10 1000 :: Int
17:15:25 <monochrom> or not. ok I don't know windows.
17:15:27 <ski> > logBase 2 16384
17:15:28 <lambdabot>  14.0
17:15:35 <macanudoman> > logBase 10 1000 :: Int
17:15:36 <lambdabot>  No instance for (GHC.Float.Floating GHC.Types.Int)
17:15:36 <lambdabot>    arising from a use of `GHC.Float.logBase'
17:15:36 <lambdabot>  Possible fix:
17:15:36 <lambdabot>    add an instance declaration for (GHC.Float.Floating GHC.Types.Int)
17:15:40 <ski> colDrMcBeardman : floating-point arithmetic
17:15:46 <dwcook> Is there a way to bring the bindings of all a pattern matched value's fields into scope, without writing each one individually?
17:15:55 <ski> @where floating-point
17:15:56 <lambdabot> "What Every Programmer Should Know About Floating-Point Arithmetic" at <http://floating-point-gui.de/> and "What Every Computer Scientist Should Know About Floating-Point Arithmetic" by David Goldberg in 1991 at <http://docs.sun.com/source/806-3568/ncg_goldberg.html> and <http://citeseer.ist.psu.edu/viewdoc/summary?doi=10.1.1.102.244>
17:15:58 <ski> colDrMcBeardman ^
17:16:00 <monochrom> if you can find in in an environment variable, then good for you. if not, then I'm likely right, all is lost.
17:16:08 <colDrMcBeardman> ski, yeah, this is why I use a slide rule.
17:16:22 <flebron> Say I have an f :: B -> Maybe B. Is there a function which will apply f over and over until it's nothing, and stop just short of that? i.e. give me the last value which wasn't Nothing, given f, and a starting value. i.e. g :: (a -> Maybe a) -> a -> a.
17:17:06 <geekosaur> dwcook, if it's not a record, no. if it's a record, there's an extension I think
17:17:07 <flebron> I can do it with iterate and >>=, but if there's something already made, even better :)
17:17:07 <ski> dwcook : record syntax pattern ?
17:17:32 <dwcook> geekosaur, ski, yes, it's a record.
17:17:49 <dwcook> I wasn't aware there was a sense of "fields" for non-records.
17:18:10 <geekosaur> Foo {..} with the RecordWildCards extension
17:18:14 <jle`> flebron: i have always asked for this
17:18:20 <dwcook> geekosaur, thanks
17:18:27 <monochrom> or you could say, it's in windows registry
17:18:27 <jle`> but there is nohting like this in the standard libraries so far
17:18:30 <ski> dwcook : <http://www.haskell.org/ghc/docs/latest/html/users_guide/syntax-extns.html#record-puns> and <http://www.haskell.org/ghc/docs/latest/html/users_guide/syntax-extns.html#record-wildcards> may be interesting
17:18:35 <jle`> it actually acts a lot like an iterateM
17:18:36 <geekosaur> Moo a b c d has 4 fields, they're just "named" by position
17:18:46 <jle`> the best thing you can do for now is iterate and (>>=)
17:19:10 <geekosaur> and if you have a record type you can use the positional field syntax with it, but not vice versa
17:19:13 <dwcook> ski, thanks
17:19:50 <macanudoman> > help
17:19:51 <lambdabot>  Not in scope: `help'
17:20:22 <jle`> flebron: alternatively maybe submit a patch to monad-loops, where such a function might belong
17:20:34 <mniip> How do I create an instance for a nested type?
17:20:37 * ski looks at macanudoman
17:20:52 <dwcook> It turns out the reason GHC didn't tell me about this was I accidentally wrote the constructor name lowercase XD
17:21:08 <mniip> like [Maybe a] or (IO (IO a))
17:21:11 <macanudoman> o/
17:21:31 <apples> mniip: create a newtype for it
17:21:37 <mniip> but I did
17:21:45 <mniip> the outer type /is/ a newtype
17:22:03 <jle`> waht's the problem?
17:22:27 <mniip> newtype X a = X a; instance MyClass (X (IO a)) where -- doesn't work
17:22:49 <apples> newtype X a = X (IO a)
17:22:51 <jle`> newtype MyNew a = MyNew (X (IO a))
17:23:14 <mniip> yeah but X isn't supposed to carry only IO's
17:23:34 <flebron> jle`: Thanks :)
17:24:08 <jle`> mniip: X can carry other things than IO a's
17:24:26 <jle`> but your MyNew won't be able to
17:24:31 <jle`> but what are you trying to do, exactly?
17:24:59 <monochrom> I don't understand the question. "newtype N a = N [Maybe a]" then write instance for N or N a. If you ask "is there a more general way?", then no.
17:25:01 <mniip> hacking the type system :D
17:25:09 <mniip> well it seems that it worked
17:25:22 <mniip> though 2 newtypes for nothing really bother me
17:25:36 <monochrom> so don't use 2 newtypes. use just 1.
17:25:55 <mniip> but I need the second
17:25:59 <mniip> for the other instance
17:26:09 <monochrom> ok then you have to do it
17:26:24 <monochrom> if you need N, then you need N. greatest tautology ever.
17:27:09 <mniip> ugh it is not working
17:27:36 <monochrom> PEBKAC
17:27:44 <MP2E> haha
17:27:45 <mniip> figured
17:28:49 <dwcook> monochrom, that tautology was so wise it oughta be called a taught-ology
17:29:28 <kadoban> *groan*
17:29:46 <jle`> it was so profound and elegant that even a child could understand it
17:29:52 <jle`> so it oughta be called a tot-ology
17:30:07 <monochrom> I like puns
17:30:25 <mniip> http://lpaste.net/5778112953207226368
17:30:41 <AfC> Is there a way to make GHC stop on the first error it reports?
17:30:44 <monochrom> ok, pasting actual code is good
17:31:18 <jle`> mniip: so what's the problem? :)
17:31:41 <mniip> it's not really what I intended
17:31:50 <pavonia> jle`: note that "tot" means "dead" in German :p
17:32:04 <jle`> pavonia: perhaps it was intentional!
17:32:18 <monochrom> both children and dead people understand it
17:32:20 <jle`> mniip: can you perhaps be a little more clear?
17:32:32 <jle`> even the intellectually dead!
17:32:59 <mniip> jle`, I'm trying to craft a function, that when given an IO a, executes the IO, and when given a Show
17:33:03 <mniip> 'able value, prints it
17:33:04 <monochrom> you do not need RI.
17:34:03 <monochrom> however, using RI is still not wrong
17:34:39 <mniip> I'm quite lost here
17:34:59 <jle`> we call it a koan
17:35:01 <monochrom> you have achieved your stated goal. call it a day and go watch a movie.
17:35:11 <mniip> monochrom, have I
17:35:26 <monochrom> yes.
17:35:38 <mniip> I'm pretty convinced I have not
17:35:41 <monochrom> well I haven't tested it, but... I have tested it in my brain
17:35:44 <mniip>     No instance for (Show (IO ())) arising from a use of `run'
17:36:12 <monochrom> ok, is that an error arising from the provided code?
17:36:15 <mniip> yes
17:36:16 <jle`> what line number?
17:36:40 <mniip> oh
17:36:50 <mniip> no, it's not from the code
17:36:51 <monochrom> I can't reproduce the error
17:36:57 <jle`> i'm trying hard to reproduce
17:37:01 <jle`> ghc will not comply
17:37:02 <jle`> :'(
17:37:06 <jle`> why do you fail me ghc
17:37:12 <mniip> run $ R $ putStrLn "hi"
17:37:24 <monochrom> why R? why not RI?
17:37:43 <mniip> because RI doesn't work with the other half of types
17:37:56 <mniip> run $ RI $ "hi"  ->    Couldn't match expected type `IO a0' with actual type `[Char]'
17:38:20 <monochrom> run (RI (putStrLn "hi"))  works here
17:38:25 <mniip> yes
17:38:35 <mniip> but what aboout run (RI "hi")
17:38:40 <dwcook> mniip, your constructor for RI says it should only take an IO action
17:38:45 <monochrom> and run (R "hi") works here
17:38:48 <mniip> yes
17:38:54 <mniip> monochrom, they both do
17:38:59 <jle`> are you trying to make a generic wrapper that handles both (IO a) and Show a => a ?
17:39:00 <mniip> but that is not what I intended
17:39:04 <dwcook> mniip, so why are you trying to give it a String?
17:39:05 <mniip> jle`, yes!
17:39:15 <monochrom> cannot be done
17:39:18 <mniip> jle`, I beleive I said that
17:39:19 <jle`> hm.
17:39:29 <jle`> you might be able to play around with undecidable/flexible instances
17:39:37 <jle`> can you?
17:39:38 <dwcook> Yeah, some silly person could come along and define instance Show (IO a), and then you're out of luck
17:39:50 <mniip> dwcook, god have a mercy on their soul, then
17:40:05 <jle`> well, on if they do it, the one who needs mercy would be you ;)
17:40:14 <mniip> :(
17:40:22 <mniip> but ok, ...
17:40:27 <mniip> what do I need to know
17:40:28 <jle`> try
17:40:45 <jle`> data R a = RIO (IO a) | RR a
17:41:01 <jle`> it's a little less flexible than you want
17:41:20 <yogert> Hey all, I
17:41:21 <mniip> and then what
17:41:33 <jle`> mniip: then you can define run using pattern matching
17:41:50 <mniip> I don't quite see how will it work
17:41:55 <yogert> I'm doing some web scraping, and I want persistence, what database interface would you recommend I use?
17:41:56 <jle`> actually wait that probably won't work because you need that show constraint on your RIO
17:42:22 <mniip> jle`, there are 2 data constructors, RIO and RR
17:42:25 <mniip> problem persists
17:42:37 <jle`> yes but now one type
17:42:39 <monochrom> no, nothing to print in the "IO a" case. (unless the IO a itself prints, but you need do nothing)
17:42:44 <jle`> then make some sort of wrapper
17:42:57 <monochrom> but the RR case needs Show. but you worry about it elsewhere
17:43:02 <Eduard_Munteanu> yogert: I was working on a similar thing the other day, 'persistent' should be alright.
17:43:10 <mniip> jle`, the whole point was to make a single function
17:43:20 <mniip> that can take either an IO a, or a Show a => a
17:43:49 <jle`> you might be looking for the right solution to the wrong problem
17:43:51 <yogert> Eduard_Munteanu: The yesod one?
17:44:00 <mniip> jle`, X->Y problem?
17:44:11 <Eduard_Munteanu> yogert: yes, you can use it without Yesod too
17:44:18 <jle`> you could do that by making a WrapRunnable typeclass, perhaps, but...
17:44:22 <jle`> what are you trying to do at the high-level
17:44:24 <jle`> that requires you to do this?
17:44:39 <mniip> some kind of... ghci behavior emulation
17:44:41 <macanudoman> Hello, has someone here done haskell with CORBA?
17:44:42 <monochrom> "g (RIO a) = a;  g (RR a) = print a" is one single function.
17:44:56 <mniip> monochrom, yeah but how do I run g?
17:45:16 <mniip> g $ RIO $ putStrLn "hi"    vs     g $ RR 1
17:45:19 <monochrom> g (RIO getLine). g (RR 'x')
17:45:19 <Eduard_Munteanu> Is there an efficient data structure that supports updates and can lookup keys for values and values for keys?
17:45:29 <jle`> mniip: you can easily define a run g
17:45:34 <mniip> monochrom, see, still 2 different function
17:45:34 <mniip> s
17:45:49 <mniip> ?
17:45:53 <yogert> Eduard_Munteanu: Okay, thanks for the suggestion. I'll check it out
17:46:07 <monochrom> ghci is an interpreter. it has introspection power. of course it can do what you said.
17:46:37 <mniip> well too bad I can't get ghci to run without threading
17:46:41 <monochrom> haskell itself doesn't have all that much introspection power to help you do this
17:46:43 <macanudoman> Eduard_Munteanu: doesn't Data.Map do the job?
17:46:43 <jle`> mniip: i think you could straight up define a Runnable typeclass and define instances for IO a and Show a => a
17:46:45 <jle`> using undecidable instances
17:46:49 <jle`> and flexible instances
17:46:53 <mniip> okee
17:47:59 <Eduard_Munteanu> macanudoman: except for the part where you can "invert" the map to look up keys by values efficiently.
17:48:44 <dwcook> Eduard_Munteanu, I wanted something similar and ended up with a pair of maps. Probably not ideal
17:48:48 <jle`> mniip: be aware that your instances will be undecidable ^.^
17:48:53 <jle`> potentially
17:49:40 <mniip>     Overlapping instances for Runnable (IO ())
17:49:52 <jle`> did you enable the extensions
17:50:02 <mniip> Yes, otherwise it'd not compile
17:50:13 <jle`> post some code
17:51:10 <Eduard_Munteanu> mniip: you can't really have conflicting instances, if that's the case... the most OverlappingInstances can do is match instances in order.
17:51:27 <mniip> jle`, http://lpaste.net/7744760945989124096
17:51:43 <pavonia> Eduard_Munteanu: Have you looked at Data.Bimap?
17:51:44 <Eduard_Munteanu> When a later one involves a type variable.
17:51:57 <Eduard_Munteanu> No, *looks*
17:52:10 <macanudoman> certainly Bimap looks like the option dwcook said
17:52:24 <dwcook> That's great. It doesn't quite fit my case but it looks fine for Eduard_Munteanu's
17:52:34 <dwcook> My case involves a *possibly nonexistent* key the other way
17:52:48 <macanudoman> Maybe?
17:52:54 <Eduard_Munteanu> Hm... mine too. I don't quite need a bijection.
17:53:00 <dwcook> Yes, but then I could have a definitive entry for Nothing
17:53:31 <Eduard_Munteanu> Ah, but lookup is parametrized by a Monad 'm'.
17:53:39 <jle`> mniip: try OverlappingInstances
17:53:43 <S3thc0n> Hello #haskell people, I've recently been diving into functional programming; and coming from an imperative background (but loving functionality), I was wondering how the seeming collision between the (for me) imperative nature of definition of data structures and the declarative rest is resolved, if at all? Might be that I am heavily misunderstanding, but if you define your own boolean type
17:53:43 <S3thc0n> (not that that'd be neccessary), a single bit can hold that information; although a whole word might be more efficient. I thought about using some magic behind the scenes to devise a structure automatically by means of compiler / interpreter, but that seems nearly impossible (and maybe not even smart). Another problem I see is a XOR linked list (not that it would really be required, but the
17:53:43 <S3thc0n> principle is what interests me here). Can anyone help me out?
17:53:46 <Eduard_Munteanu> lookup :: (Ord a, Ord b, Monad m) => a -> Bimap a b -> m b
17:54:19 <S3thc0n> >.> Looking at that length I should maybe have used some board, sorry.
17:54:54 <copumpkin> Eduard_Munteanu: ewww
17:55:13 <jle`> S3thc0n: declarative rest?
17:55:17 <zRecursive> :t fmap
17:55:18 <lambdabot> Functor f => (a -> b) -> f a -> f b
17:55:58 <jle`> S3thc0n: also, remember that data structures are a means to an end
17:56:00 <Eduard_Munteanu> S3thc0n: inductive types are quite different, yes. But on the upside, they're often safer than pointer manipulation that's usually involved in certain imperative data structures.
17:56:04 <jle`> not an end in and of themselves
17:56:13 <Eduard_Munteanu> copumpkin: what is the eww about?
17:56:18 <jle`> different dadta structures might work in different situations and contexts
17:56:21 <jle`> but that should be nothing new
17:56:23 <copumpkin> Eduard_Munteanu: being parametrized by a monad
17:57:42 <Eduard_Munteanu> copumpkin: I guess a Monoid is better?
17:58:39 <copumpkin> Eduard_Munteanu: nope
17:59:23 <copumpkin> Eduard_Munteanu: neither monoid nor monad are really related to what that function needs
17:59:30 <copumpkin> which is basically Maybe :P
18:00:06 <Eduard_Munteanu> Hm, fair, I suppose. I was going to ask about Alternative next. :)
18:00:10 <copumpkin> I don't really think generalization by composing with nothingToFail :: Monad m => Maybe a -> m a
18:00:24 <S3thc0n> jle`: Indeed, else that question would not be asked by me; if I could always use linked lists ;) -- By declarative rest you mean that rest already is functional. But it is an abstraction, isn't it? I came to all that because low-level / systems programming is not often done in functional languages, despite them offering great advantages. It seems to me like there should be a way to combine
18:00:24 <S3thc0n> both worlds. But maybe the is delusional
18:00:24 <copumpkin> is very useful generalization
18:00:56 <cdk_> I have a program I'm trying to parallelize, but GHC is GC'ing all my sparks. I don't understand why, the result of the parallel computation is used immediately after so I don't see why GHC thinks the sparks aren't being evaluated. Code and comments here, the relevant function is `parFindNearest`: http://lpaste.net/101528 Can anyone help me get this working properly?
18:01:00 <geekosaur> House, and someone recently wrote a *BSD sound driver in ajhc
18:01:01 <cdk_> i'm compiling with "ghc -O2 -fllvm -threaded" and running with "./RGB +RTS -N2 -s"
18:01:15 <Eduard_Munteanu> S3thc0n: you can implement imperative data structures either by FFI-ing to C or using IORefs / STRefs.
18:02:31 <Eduard_Munteanu> S3thc0n: but often there are good analogues to them... e.g. zippers instead of imperative doubly-linked lists.
18:02:43 <zRecursive> When will ghc-7.8 be released ?
18:03:04 <macanudoman> cdk_: what do you mean with GC'ing?
18:03:44 <ricky_clarkson> colleccionando la basura
18:03:53 <macanudoman> aah ok
18:04:15 <cdk_> macanudoman: take a look at the paste. I've included the output of +RTS -s at the bottom. You can see that out of 215623 sparks, 1318 are usefully converted, 198111 are GC'd and 16194 fizzle
18:05:49 <S3thc0n> Eduard_Munteanu: That seems a bit like a dirty workaround to me. I know it is possible, but it just feels like their should be a more natural way, except some data structures are inherently imperative.
18:07:46 <Eduard_Munteanu> S3thc0n: I suspect you can greatly increase the scope of the inductive structures if you include tying-the-knot methods, e.g. representing doubly-linked lists using inductive types alone, but that's often inefficient for updates.
18:08:31 <Eduard_Munteanu> S3thc0n: however you should really look into zippers first
18:08:38 <Eduard_Munteanu> They're quite elegant.
18:09:19 <S3thc0n> Doing that right now. I was commenting on interfacing with C or using a monad to just extract the data structure.
18:09:27 <Eduard_Munteanu> Ah.
18:10:27 <Eduard_Munteanu> S3thc0n: it's the only practical way for things like arrays and whatever else is based on them, e.g. Data.Map
18:10:56 <Eduard_Munteanu> @src Map
18:10:57 <lambdabot> Source not found.
18:11:06 <Eduard_Munteanu> @src M.Map
18:11:06 <lambdabot> Source not found. My brain just exploded
18:11:12 <Eduard_Munteanu> @src Data.Map.Map
18:11:12 <lambdabot> Source not found. Abort, Retry, Panic?
18:11:13 <Eduard_Munteanu> :(
18:11:29 <S3thc0n> I'll google it ;)
18:11:44 <zRecursive> @hoogle Data.Map
18:11:45 <lambdabot> Data.Map module Data.Map
18:11:45 <lambdabot> Data.Map.Lazy data Map k a
18:11:45 <lambdabot> Data.Map.Strict data Map k a
18:12:52 <Eduard_Munteanu> Nevermind, it's rather irrelevant for Map.
18:13:48 <Eduard_Munteanu> Er, and wrong, I don't know why I was thinking of Map.
18:17:26 <macanudoman> cdk_: sorry, haven't found a why for that, without explicit mallocs and free this is very tricky
18:23:20 <S3thc0n> Eduard_Munteanu: Thank you very much for the help, definitely advanced my view. I'll continue tomorrow, but I think I now have somewhat of an idea.
18:23:41 <dario> @hoogle (a -> b) -> (a -> c) -> a -> (b, c)
18:23:41 <lambdabot> No results found
18:24:55 <copumpkin> dario: (&&&)
18:24:56 <pyon> dario: Looks like something that could be built using arrow combinators.
18:25:26 <dario> hm, thanks guys :)
18:28:19 * hackagebot haskelm 0.1.12.0 - Elm to Haskell translation  http://hackage.haskell.org/package/haskelm-0.1.12.0 (jeremondi)
18:28:30 <fragamus> hey I have this pattern and I want a slicker way: bs = map f1 as;cs = map f2 bs;ds = map f3 cs
18:28:45 <fragamus> ds = ((map f3) . (map f2) . (map f1)) as
18:28:49 <fragamus> but I'm guessing someone here can do better
18:29:35 <apples> ds = map (f3 . f2 . f1) as
18:29:49 <fragamus> of course!
18:29:59 <fragamus> i am sorry to have bothered you
18:30:07 <apples> cheers for map fusion :)
18:31:09 <jle`> fragamus: no worries :)
18:31:14 <jle`> note that it's one of the functor laws, i believe
18:31:31 <apples> yep, specialized to lists
18:31:46 <jle`> the other is map id = id
18:31:53 <jle`> one of them is actually a free result of the other
18:31:55 <jle`> i forgot which though
18:32:07 <fragamus> i have a new one:  id = id
18:32:10 <apples> the latter
18:32:41 <tavoe> is there any way to reference the previous/next element in the filter function? Like, remove element if it is even, or if the previous element was 3
18:33:01 <jle`> tavoe: consider zipWith with the list and the drop 1 list
18:33:17 <tavoe> heh
18:33:18 <tavoe> ok
18:46:26 <gaze__|net> https://github.com/tomahawkins/atom/blob/master/Language/Atom/Expressions.hs Hey, does anyone know why Data/Typeable are derived here?
18:46:37 <gaze__|net> for Type and Const
18:48:07 <Eduard_Munteanu> gaze__|net: likely for generics / Data.Data code that might need one and standalone deriving wouldn't be very nice as a default.
18:48:19 <c_wraith> Usually, that pair is derived to enable writing generic traversals over data structures
18:49:11 <Daejo> :unpl trueIndexes = intercalate [True] . (++ [repeat False]) . (zipWith ((flip replicate False .) . subtract . (+1)) <*> tail) . (-1:)
18:49:35 <Daejo> @unpl trueIndexes = intercalate [True] . (++ [repeat False]) . (zipWith ((flip replicate False .) . subtract . (+1)) <*> tail) . (-1:)
18:49:35 <lambdabot> trueIndexes j = intercalate [True] ((((zipWith (\ s y -> replicate (subtract (s + 1) y) False)) <*> tail) ((-1) : j)) ++ ([repeat False]));
18:53:58 <gaze__|net> mmm okay.
18:54:33 <gaze__|net> oh also! What would you guys suggest as a reference for a well designed EDSL that's designed to represent C-Like code
18:54:42 <gaze__|net> I'm looking at Atom but it was designed several years ago
18:54:57 <gaze__|net> I'm wondering if there are some more modern techniques I should be paying attention to
18:55:19 <Eduard_Munteanu> Hm, this is starting to look lensy... data Treeish p f i a = Treeish { rootLabel :: a, subForest :: p i (f (Treeish p f i a)) }
18:56:01 <copumpkin> why do you separate the i out from the p?
18:57:23 <Eduard_Munteanu> copumpkin: one particular use would be defining a  data Trie k a = Trie (Map k (a, Trie k a))
18:57:44 <copumpkin> yeah, just not sure why you'd separate the p i
18:58:18 <copumpkin> nowhere do you use them separately
18:59:22 <Eduard_Munteanu> copumpkin: it seemed like a lensy way to do it... if p is a Profunctor, you can write a generic contrafmap to rekey.
18:59:40 <copumpkin> yeah, but I don't know why you'd build it into the datatype
19:00:11 <copumpkin> ultimately it just looks like Cofree
19:00:20 <Eduard_Munteanu> Er.
19:00:50 <Eduard_Munteanu> Yeah, I guess it is cofree-ish. Also my Trie is free-ish.
19:00:51 <copumpkin> I can understand separating the (p i) from the f, since our Compose notation sucks
19:01:12 <copumpkin> but I don't understand splitting p and i :)
19:01:29 <copumpkin> since you can just instantiate it with p i at use sites if you really want that
19:01:43 <jle`> is there a version of haskell that is haskell but perfect?
19:01:49 <copumpkin> no
19:02:05 <jle`> aw.
19:02:28 <jle`> what if we rewrote the haskell spec and base libraries, would we be able to use what we have learned in the past two decades to build a much better language?
19:02:35 <jle`> or would it be not much of an imporvement in the grand scheme of things
19:02:35 <Eduard_Munteanu> copumpkin: theoretically you want to be able to name edges too, which a plain g = p i doesn't let you do nicely.
19:02:55 <copumpkin> I guess I don't see why it doesn't :/
19:03:36 <jle`> gaze__|net: have you looked at http://hackage.haskell.org/package/language-c ?
19:03:49 <jle`> not a clean EDSL admittedly
19:04:01 <jle`> but i think you can generate AST's for C code
19:04:03 <Eduard_Munteanu> Well, you can for Trie with g = Map k, but I feel that's a coincidence and it doesn't quite capture the notion of a map.
19:04:06 <jle`> and then output them
19:04:39 <gaze__|net> not really that close to what I'm trying to do
19:05:11 <copumpkin> Eduard_Munteanu: hmm, so what if I wanted to use IntMap?
19:05:33 <copumpkin> Eduard_Munteanu: how is it a coincidence?
19:05:54 <copumpkin> I could use a Vector which is indexed by an Int/Fin
19:06:00 <copumpkin> it would be just as Trie-like
19:06:05 <copumpkin> and would not have its index represented in its type
19:06:22 <copumpkin> furthermore, I sort of doubt Map actually forms a profunctor
19:06:39 <copumpkin> given that it needs to be covariant in its first parameter
19:06:40 <Eduard_Munteanu> copumpkin: for IntMap you could index with a singleton kind, e.g. i :: (), i = '()
19:06:46 <copumpkin> ew :P
19:06:57 <copumpkin> good luck making a profunctor out of that
19:09:36 <Eduard_Munteanu> copumpkin: your p-less treeish sort of has the 'i' existential, one could argue.
19:09:50 <copumpkin> ?
19:10:37 <copumpkin> it's existential in the same way a closure is existential
19:11:23 <Eduard_Munteanu> Treeish (Map k) a  ~   data Treeish' Map '() a = forall k. Treeish' ... Map k a ...
19:11:51 <Eduard_Munteanu> (well, disregard the '())
19:12:32 <Eduard_Munteanu> copumpkin: is there something in particular you find problematic regarding 'p' itself? I'm just trying out stuff, really. :)
19:12:49 <copumpkin> no, it just seems more complicated/restrictive than it needs to be, for no benefit that I can see
19:13:10 <Eduard_Munteanu> Oh, ok. I suspect I am cargo-culting lens a bit, yes. :)
19:13:18 <copumpkin> as I said, it's Cofree, except with two functors separated out
19:14:43 <Eduard_Munteanu> I guess IndexedTree would be a better name (and perhaps better usage scenario).
19:29:16 <zzo38> Why does the documentation for MonadPlus still mention "mzero >>= f  =  mzero
19:29:25 <zzo38> and "v >> mzero   =  mzero"?
19:29:36 <zzo38> The first one is implied by the monad laws, and the second one isn't necessarily true.
19:30:58 <Eduard_Munteanu> zzo38: how's the first one implied?
19:32:25 <Eduard_Munteanu> MonadPlus has an additional monoidal structure on top on Monad's.
19:32:32 <Eduard_Munteanu> *on top of
19:32:48 <zzo38> Eduard_Munteanu: I know that.
19:33:01 <zzo38> That isn't what I am talking about, though.
19:33:50 <Eduard_Munteanu> zzo38: Monad laws don't talk about mzero at all, then
19:34:12 <zzo38> Eduard_Munteanu: It implies that law despite that.
19:34:19 <Eduard_Munteanu> And Monoid laws don't talk about (>>=).
19:35:00 <zzo38> It has nothing to do with monoid laws; the monad laws imply (mzero >>= f = mzero).
19:35:19 <Eduard_Munteanu> zzo38: why?
19:35:35 <dolio> Why don't you submit a patch with a proof of that to replace the current comment?
19:37:00 <zzo38> The type of mzero is (m a) where a is universally quanitified, so it can be any type. Also, (mzero >>= f = join (fmap f mzero)), and due to functor laws and the universal quantification, if "f" is anything it must be the same, therefore even if f is id, or if f is return, and monad laws imply (join (fmap return x) = x) therefore f = return it implies it.
19:37:07 <zzo38> I didn't write it perfectly, but it is like that.
19:37:53 <zzo38> Hopefully you know that, now?
19:39:54 <Eduard_Munteanu> zzo38: you're arguing that 'a' is phantom, but 'm a' needn't be the same under binding.
19:42:25 <zzo38> Eduard_Munteanu: OK, but can you describe what you mean "needn't be the same under binding"? Bind is just the same as using join and fmap, though.
19:42:27 <Eduard_Munteanu> zzo38: just like f >> g can have effects despite f :: m (), g :: m A
19:43:17 <Eduard_Munteanu> I mean by a similar reasoning one could argue f >> g = g.
19:43:21 <zzo38> Eduard_Munteanu: Yes, although, if you do (f >>= \() -> g) it is same if f :: m().
19:43:53 <Eduard_Munteanu> Just () >> Just 3
19:43:54 <zzo38> My reasoning may be presented in a somewhat wrong way.
19:43:56 <Eduard_Munteanu> > Just () >> Just 3
19:43:57 <lambdabot>  Just 3
19:44:02 <Eduard_Munteanu> > Nothing >> Just 3
19:44:03 <lambdabot>  Nothing
19:44:42 <zzo38> I know that f >> g can differ based on that, but it has nothing to do with what I said.
19:45:09 <zzo38> In terms of "effects", you could say that something of type (forall a. m a) cannot possibly "return", therefore it cannot "continue".
19:45:25 <zzo38> But that isn't the best way to describe it mathematically.
19:46:16 <zzo38> Eduard_Munteanu: In fact, in the case of (Nothing >> Just 3), Nothing itself is (forall a. Maybe a), and no matter what you put after >> or >>= it is Nothing; so, it satisfies the law too.
19:46:17 <Eduard_Munteanu> zzo38: take Maybe for example and try proving Nothing >>= f = Nothing just from monad laws alone.
19:46:42 <dolio> It doesn't matter if 'mzero >>= f = mzero' is implied by the monad laws; it's still worth that being in the documentation so that people don't have to intuit it from knowing about parametricity theorems.
19:46:43 <copumpkin> well, he's trying to use monad laws + parametricity, I think
19:46:55 <zzo38> Eduard_Munteanu: I did that already.
19:47:29 <zzo38> dolio: Yes, OK, although perhaps it might still help to not only mention the law but also mention that it is implied.
19:48:28 <Eduard_Munteanu> Even with parametricity, what if you have   data Perhaps a = Something a | Nay | Nowai   where   mzero = Nay  specifically?
19:48:28 <copumpkin> Eduard_Munteanu: I think the point is more along the lines of "try writing an mzero with that type, that doesn't satisfy that law"
19:48:46 <copumpkin> hm
19:48:52 <dolio> Eduard_Munteanu: The free theorem for mzero is 'fmap f mzero = mzero'
19:49:11 <copumpkin> I don't think that'd be a monad
19:49:14 <Eduard_Munteanu> That sounds sensible, yes.
19:49:32 <dolio> So fmap f mzero = mzero = fmap return mzero, and so join (fmap f mzero) = join (fmap return mzero) = mzero.
19:49:32 <copumpkin> oh, perhaps it would be, never mind
19:49:39 <zzo38> dolio: Yes, that is what I meant, and furthermore, if f = return and then join (fmap return mzero) = mzero is implied by monad laws
19:50:40 <zzo38> Now, it is what I meant.
19:51:27 <monochrom> If you have v :: forall a. Maybe a, then you can prove why v :: Nothing. you have to use the specifics of Maybe, and reduce "suppose it's Just x" to "x :: forall a. a" or "f :: forall a. () -> a"
19:52:06 <monochrom> if you have w :: forall a. IO a, then you can prove a similar statement, but that statement has to be customized for IO, and the proof has to be customized for IO
19:54:00 <zzo38> monochrom: Yes, although because of the monad laws, it works for any monad.
19:54:08 <monochrom> if you have u :: forall m. (Monad m) => forall a. m a, then whatever you state and prove is not a generalization of the above. because you don't even know that m must be IO, or Maybe. for all I know, m could be Identity
19:54:27 <monochrom> no, that's exactly what I'm saying. does not work that way.
19:54:37 <Eduard_Munteanu> I'm not sure I grok that join ... = join ... there, it seems you need to know the arguments equal mzero a priori.
19:55:39 <dolio> Eduard_Munteanu: The first equation is just x = y -> join x = join y using the previous equation.
19:55:48 <zzo38> monochrom: For monads such as Identity, you can't make something of type (forall a. Identity a)
19:55:55 <monochrom> if you say, "change (Monad m) to (MonadZero m)", then I believe that IO does not even fit
19:55:58 <dolio> The second equation is join (fmap return x) = x from the monad axioms.
19:56:43 <zzo38> monochrom: So, when I said "any monad" I mean, only of something of type (forall a. m a) is possible.
19:57:19 <Galactic> could someone write this without using the dot please... main=interact $ unlines.takeWhile (/="42").lines
19:57:38 <dwcook> @unpl unlines.takeWhile (/="42").lines
19:57:38 <lambdabot> (\ d -> unlines (takeWhile (\ a -> a /= "42") (lines d)))
19:57:43 <dwcook> Galactic, ^
19:57:52 <Eduard_Munteanu> dolio: I know, I'm saying you only have x --> mzero  and  y --> mzero  as reductions rather than full equalities, no?
19:58:12 <dolio> What?
19:58:15 <Galactic> dwcook: o wow lambdabot can do that haha ty
19:58:36 <monochrom> then I have a tautological solution for you.
19:59:20 <monochrom> define: class Monad m => MonadForAll m where { action_for_all :: m a }
20:00:06 <monochrom> (p :: forall a. m a) exists iff m can be made an instance of MonadForAll
20:01:06 <c_wraith> that would imply that the monad has *some* sort of termination condition build in, I suppose.
20:01:25 <dwcook> c_wraith, why would it imply that?
20:02:00 <c_wraith> well, assuming bottoms are disallowed, it would mean that action_for_all >>= foo wouldn't execute foo
20:02:01 <zzo38> monochrom: Yes, although then it still apply (action_for_all >>= f = action_for_all), assuming that the functions are defined.
20:02:02 <Eduard_Munteanu> :t fmap return
20:02:03 <lambdabot> (Monad m, Functor f) => f a -> f (m a)
20:02:13 <monochrom> IMO you should not wander beyond the boring "forall a. m a makes sense". because what "makes sense" means depends really on the specific of m.
20:02:18 <zzo38> (For example, (Just undefined) is not defined.)
20:02:29 <Eduard_Munteanu> I'm a bit confused.
20:03:13 <monochrom> for example how Maybe supports it is totally different from how IO supports it. there is no fine-grain statement you can make to cover both.
20:03:38 <dwcook> c_wraith, you're saying that the ability to pick out an action :: m a for a given m implies that? I don't follow.
20:03:39 <c_wraith> Indeed. I was going for the opposite for fine-grained with "some sort"
20:03:45 <zzo38> monochrom: Yes, it does depend on the specific of m, but as long as it works, it holds, so it covers all of them, mathematically. So, due to mathematical laws you *can* make the statement to cover all of them
20:04:32 <Eduard_Munteanu> Ah,  fmap f mzero :: m a,  fmap return mzero :: m (m a)  but the inner 'm a' is phantom. Oh well, I guess it is an argument by parametricity.
20:04:44 <monochrom> I don't think action_for_all >>= f = action_for_all is obvious
20:05:02 <dwcook> Yeah, that's basically what I'm trying to figure out
20:05:02 <zzo38> For a list monad, it is an empty list, for a Maybe monad, it is Nothing, for a IO monad, it may terminate the entire program or cause an exception or something.
20:05:04 <dolio> No. fmap f mzero :: m (m a)
20:05:12 <andkore> Does anyone know if a video of http://www.reddit.com/r/haskell/comments/1th3hx/haskell_haskell_and_ghc_too_big_to_fail_panel/ exists online or will exist online at some point?
20:05:13 <dolio> f :: b -> m a
20:05:17 <dwcook> zzo38, hey, you look familiar. :)
20:05:22 <monochrom> I think, in fact, IO is a counterexample
20:05:44 <zzo38> monochrom: action_for_all >>= f = action_for_all is mathematically "obvious" to me, at least!
20:05:50 <Eduard_Munteanu> Oh, duh.
20:05:52 <dolio> monochrom: It's not obvious, but it's provable without knowing anything about m other than that it's a monad.
20:06:05 <monochrom> ok, then I accept it
20:06:15 <zzo38> dolio: Yes, that is what I meant exactly.
20:06:49 <c_wraith> IO is a bit of a weird case.  forever (getLine >>= putStrLn) has type forall a. IO a
20:06:54 <dolio> (And that you're not using undefineds.)
20:06:59 <c_wraith> But zzo38's law still holds
20:07:07 <dwcook> Does that mean we're neglecting recursion or something?
20:07:24 <dwcook> The weird case isn't IO so much as forever
20:07:43 <zzo38> c_wraith: Yes, it still holds in that case
20:07:52 <dwcook> @type forever $ return ()
20:07:53 <lambdabot> Monad m => m b
20:08:02 <dwcook> ^ There's your MonadForAll instance right there :P
20:08:09 <c_wraith> dwcook: that's a bottom for many types
20:08:12 <monochrom> I am cool with ruling out bottom. I have been. note that forever xxx is usually *not* bottom, i.e., for most xxx's
20:08:26 <dwcook> c_wraith, ah yeah, I suppose that is bottom
20:08:47 <zzo38> (It means, I forgot to enumerate all of the cases, in the case of IO, but that's the only thing.)
20:08:47 <dolio> monochrom: You don't need to rule out undefined :: m a, just 'return undefined' I think.
20:09:00 <monochrom> that's even better
20:10:30 <zzo38> Something like forever (getLine >>= putStrLn) is defined; it is just IO action of an infinite loop. Things like [undefined,undefined,undefined+1,42] and other non-halting pure codes are not defined, though.
20:10:52 <zzo38> But, IO actions do not interact with pure code except by the monad interface.
20:10:58 <Eduard_Munteanu> I'm not very sure what you do with  data Perhaps a = Some a | A | B   though.
20:11:05 <dolio> It might be tricky to prove that undefined >>= f = undefined, though.
20:11:20 <dwcook> Eduard_Munteanu, privilege either A or B?
20:11:34 <dwcook> Much as Either privileges Left over Right
20:11:47 <dolio> A >>= f = A and B >>= f = B, or else you're not a monad.
20:12:22 <dwcook> Maybe I was unclear what the problem with Perhaps was
20:12:55 <Eduard_Munteanu> dolio: suppose you do that, which is mzero? Either of them?
20:13:04 <dolio> You could pick either.
20:13:16 <zRecursive> @where cabal-install
20:13:17 <lambdabot> http://hackage.haskell.org/trac/hackage/wiki/CabalInstall
20:13:17 <zzo38> Just as much as   f :: forall x. x; f = undefined;   does not halt (halting with an error message is not "halting") and therefore does not prove that (forall x. x) is a true statement of intuitionistic logic, which of course, it isn't.
20:13:21 <dwcook> What is A >> B? B >> A?
20:13:22 <monochrom> one semantics of IO is by some free monad. a data structure that holds your recipe of effects. then forever xxx is an infinite data structure. it is as sane as an infinite list.
20:13:38 <zzo38> dwcook: A >> B = B and B >> A = A
20:13:43 <zzo38> I mean, vice versa
20:13:52 <zzo38> A >> B = A and B >> A = B
20:13:54 <zzo38> Sorry
20:13:55 <monochrom> that is, IO does not have to be weird, certainly no weirder than infinite lists.
20:14:02 <dwcook> Then you lack an identity element
20:14:19 <dwcook> Or wait, no
20:14:33 <dolio> zzo38: I guess that example shows that m >> mzero = mzero doesn't work, too.
20:14:56 <zzo38> dolio: It is true that m >> mzero = mzero isn't always true. That is a mistake in the documentation.
20:15:03 <dolio> Since if you pick mzero = B, then A >> B = A violates that.
20:15:04 <zzo38> But, mzero >> m = mzero is always true.
20:15:08 <dwcook> Wait, I'm confused, I thought mzero was supposed to be the identity of a monoid?
20:15:09 <augur_> zzo38: whats this now
20:15:15 <augur_> halting with an error message is not halting?
20:15:16 <augur_> sure it is.
20:15:24 <zzo38> dwcook: It is the identity of a monoid, but the monoid made by mplus, not by >>
20:15:27 <monochrom> I thought mzero was a member of #haskell  XD
20:15:31 <dwcook> Oh, okay.
20:15:39 <Eduard_Munteanu> Heh.
20:15:39 <augur_> zzo38: f = undefined (or f = f or anything like that) is naughty, from a type theoretic perspective
20:15:43 <c_wraith> what happened to the right semi-nearring formalization of MonadPlus?
20:16:00 <zzo38> augur_: Yes, I know; it isn't defined.
20:16:04 <augur_> zzo38: its precisely why haskell's type theory is inconsistent, because it _is_ a proof of Void, but it shouldnt be one
20:16:06 <dwcook> augur_, yeah, we should just eliminate bottom. Problem solved!</facetious>
20:16:14 <augur_> dwcook: ofcourse we should
20:16:19 <zzo38> (I suppose, things like (Just undefined) are "partially defined", but that doesn't make them defined.)
20:16:51 <augur_> dwcook: we can reify partiality with Maybe, and we can handle non-termination with codata!
20:16:52 <dwcook> augur_, well, I don't have an opinion on eliminating bottom, because I don't know practically how it would be done; it was mostly the "just" that I was joking about
20:16:53 <monochrom> I like bottom. it adds spice to denotational semantics. XD
20:16:55 <zzo38> (Clearly partially defined things can be useful, though.)
20:16:56 <fookite_> i have a general question, about a very practical problem
20:16:58 <augur_> i mean, haskell cant, but
20:17:10 <augur_> dwcook: just just just :)
20:17:20 <augur_> dwcook: "bottom" in haskell is actually two bottoms
20:17:23 <augur_> we pretend its one but its two
20:17:31 <fookite_> two bottoms are better than one
20:17:35 <dwcook> You're talking about let f = undefined versus let f = f?
20:17:36 <monochrom> I don't think two is enough
20:17:36 <augur_> theres the bottom of undefined, and the bottom of looping
20:17:48 <Eduard_Munteanu> What happens if I make A >> B = B, and B >> A = A, and set mzero = A?
20:17:50 <augur_> and they have different solutions when you remove them
20:18:14 <zzo38> Eduard_Munteanu: Then, it is not a real monad.
20:18:22 <zzo38> (Regardless of what you set mzero to.)
20:18:23 <augur_> dwcook: bottom-of-undefined becomes Nothing (or more typically, Error "undefined" :: Error a (== Either String a))
20:18:38 <augur_> dwcook: the bottom of looping becomes enforced totality + codata
20:18:40 <dolio> Eduard_Munteanu: If you do that then m >> n = m >> \_ -> n is violated.
20:18:44 <monochrom> throwing exceptions kills the cat. exception handler brings it back!
20:19:01 <dolio> Er, m >>= \_ -> n
20:19:36 <augur_> monochrom: what? lol
20:19:58 <fookite_> i built this thing a while back
20:20:01 <dwcook> augur_, what's one language that distinguishes data and codata?
20:20:06 <augur_> dwcook: agda :)
20:20:06 <dwcook> I've been meaning to learn the difference
20:20:14 <dolio> Charity.
20:20:18 <fookite_> and i decided to start working on it again
20:20:27 <fookite_> but now it won't compile anymore
20:20:28 <augur_> i wonder if idris does as well
20:20:30 <augur_> lets ask!
20:21:05 <dwcook> http://www.idris-lang.org/idris-0-9-5-released/ says Idris has codata declarations
20:21:16 <Eduard_Munteanu> Hm, I see.
20:21:26 <fookite_> so i spent the day getting this thing to compile, setting my version bounds in the .cabal file appropriately
20:21:39 <fookite_> (to old versions, of course)
20:21:46 <augur_> it seems idris does, yeah
20:21:52 <fookite_> and i finished, it compiles.
20:22:10 <dwcook> So now I just need to figure out what the heck that means. Excitement!
20:22:19 <fookite_> what is the best course of action to get it to compile against the world as it exists now?
20:22:43 <monochrom> update your code to be compatible with current libraries
20:22:48 <fookite_> yes
20:22:59 <Eduard_Munteanu> dwcook: Agda doesn't have "codata declarations" per se, it's actually more flexible, you can define types which are partly inductive and partly coinductive.
20:23:03 <monochrom> pay me to do it for you. $100 per hour
20:23:19 <monochrom> eh, make it 1 bitcoin per hour
20:23:35 <fookite_> how about tulips?
20:23:44 * copumpkin sighs
20:24:00 <augur_> dwcook: in agda, you have a flag for lazy positions or something like that
20:24:02 <augur_> copumpkin: sup
20:24:07 <fookite_> i was thinking i change my version bounds one library at a time to current versions
20:24:21 <fookite_> and cabal install and fix the problems as they come up
20:24:21 <monochrom> yes, one change at a time is good
20:24:27 <fookite_> is that a bad way to do it?
20:24:37 <monochrom> it is a good way.
20:24:41 <fookite_> thanks!
20:24:50 <dwcook> augur_, lazy = codata?
20:24:58 <fookite_> sorry i can't pay you your rate
20:25:08 <monochrom> my sympathy
20:25:19 <augur_> dwcook: yes
20:25:24 <c_wraith> dwcook: codata implies non-strict evaluation.
20:25:28 <augur_> well, more or less
20:25:31 <Hafydd> How much does a lazy position pay?
20:25:34 <dwcook> Got it.
20:25:48 <augur_> dwcook, c_wraith: for proper codata types, you dont need non-strict evaluation per se
20:25:56 <monochrom> a lazy position co-pays :)
20:26:01 <Eduard_Munteanu> dwcook: it's better to state data is finite, while codata is possibly infinite but it's made of finite bits.
20:26:05 <augur_> i mean, you can have strict streams, for instance
20:26:11 <c_wraith> monochrom: so you give me money to work for me?  Sounds percted!
20:26:15 <c_wraith> ...  er, perfect
20:26:22 <Hafydd> percolated!
20:26:24 <dwcook> Eduard_Munteanu, what is a formalization of that?
20:26:58 <augur_> they're just defined in such a way that evaluation doesnt quite do anything problematic
20:26:58 <Eduard_Munteanu> dwcook: or that induction must terminate, while coinduction can go on forever as long as it produces parts of the result as it goes
20:27:12 <monochrom> "my co-worker is so lazy"
20:27:25 <dwcook> I see
20:27:46 <Eduard_Munteanu> dwcook: it is rather formal already
20:27:58 <dwcook> The "finite bits" part is mostly what felt hand-wavey to me
20:28:11 <Eduard_Munteanu> dwcook: ah, those bits would be constructors
20:28:31 <augur_> dwcook: http://wiki.portal.chalmers.se/agda/pmwiki.php?n=ReferenceManual.Codatatypes
20:28:34 <augur_> thats how agda does it
20:28:35 * hackagebot warp 2.1.3 - A fast, light-weight web server for WAI applications.  http://hackage.haskell.org/package/warp-2.1.3 (MichaelSnoyman)
20:28:36 <monochrom> I think "every finite prefix takes finite time" works
20:28:43 <dwcook> ".php" :(
20:28:53 <augur_> yeah, its pmwiki
20:29:15 <Eduard_Munteanu> dwcook: e.g. data Stream a = Cons a (Stream a), mapStream f (Cons a as) = Cons (f a) (mapStream f as) leaves a trail of conses as it goes
20:29:42 <dwcook> So, essentially, Agda doesn't allow general recursion, but it lets you produce infinite data structures (codata)?
20:29:45 <Eduard_Munteanu> dwcook: and each step provably produces a result in finite time
20:29:49 <augur_> i think, iinm, that agda's coinduction is a type-level enforcement of thunks
20:30:36 <augur_> dwcook: no it does allow general recursion (assuming i know what that means!) but you have to be productive if you're non-terminating
20:30:45 <Eduard_Munteanu> dwcook: restricted recursion is one thing, and restricted corecursion is another
20:31:16 <dwcook> I'm afraid I don't know the difference between recursion and corecursion either
20:31:31 <jle`> corecursion is recursion but the dual, dontcha kno
20:31:33 <monochrom> "productive" probably means "produce another constructor infinitely often"
20:31:49 <augur_> i think type-enforced thunking is nice, because it has the benefits of being sorta kinda not really lazy while getting all the benefits
20:31:55 <dwcook> jle`, I'm not sure how to view recursion category theoretically
20:32:14 <augur_> dwcook: corecursion is a fancy way of saying unfolding
20:32:36 <augur_> dwcook: for lists, recursion = foldr, corecursion = unfold
20:32:39 <augur_> :t foldr
20:32:39 <lambdabot> (a -> b -> b) -> b -> [a] -> b
20:32:42 <augur_> :t unfold
20:32:43 <lambdabot>     Not in scope: `unfold'
20:32:43 <lambdabot>     Perhaps you meant one of these:
20:32:43 <lambdabot>       `BS.unfoldr' (imported from Data.ByteString),
20:32:48 <dwcook> So, anamorphisms?
20:32:49 <augur_> noooooo
20:32:54 <augur_> damn you :t!
20:32:55 <Eduard_Munteanu> dwcook: you could also visualize foldl vs foldr as an analogy of the kind of the duality you have
20:33:00 <augur_> dwcook: yeah, anamorphisms are another word for it
20:33:11 <augur_> Eduard_Munteanu: : no no naughty
20:33:20 <augur_> foldl vs foldr is not an analogy of it at all
20:33:31 <augur_> foldl is a recursion scheme
20:33:42 <jle`> naughty eduard
20:33:47 <augur_> its just the recursion scheme for snoc lists (pretending that cons lists are snoc lists)
20:33:57 <Eduard_Munteanu> You can only foldl finite lists, but you can foldr lazy infinite lists.
20:34:20 <augur_> Eduard_Munteanu: yes, but thats because haskell is lazy, not because foldl is corecursion
20:34:28 <c_wraith> I like to scanl infinite lists
20:34:35 <Eduard_Munteanu> I mean foldl is not corecursion, rather.
20:34:49 <dolio> Recursion is when you define a function by self-reference on smaller arguments. Corecursion is when you define a function by self-reference for smaller parts of the result.
20:35:36 <augur_> Eduard_Munteanu: its all sorta corecursion in haskell anyway cause its lazy. we cant talk about true (co)recursion in this setting
20:36:30 <dwcook> Should I just unlearn the definition of "recursion" that says "When a function calls itself"?
20:36:41 <augur_> dwcook: no, thats more or less correct
20:37:07 <dwcook> But corecursion also falls under that
20:37:22 <augur_> dwcook: only when you have laziness
20:37:22 <Eduard_Munteanu> dwcook: you might want to look at (co)induction first
20:37:38 <augur_> dwcook: the more-or-less part is where you have to be careful
20:37:54 <colDrMcBeardman> I'm using the twitter-conduit library (a newer version than what's on hackage), and I'm wondering if there's a way to have a library using conduit like that sort of cache or memoize a value I've asked for.
20:37:55 <augur_> dwcook: how you implement (and think about) recursion is very important
20:38:03 <augur_> one way you can do it is by reference
20:38:10 <augur_> a function can call itself because you have variables
20:38:13 <augur_> the function is stored in a var
20:38:22 <augur_> and when you go to use the function in its body, it looks up that far
20:38:24 <augur_> var*
20:38:32 <augur_> and there you go, you get recursion. its simple!
20:38:36 * hackagebot shelly 1.5.2 - shell-like (systems) programming in Haskell  http://hackage.haskell.org/package/shelly-1.5.2 (GregWeber)
20:38:38 <Eduard_Munteanu> Structural induction is restricted to strictly decreasing arguments, while structural coinduction is restricted to strictly increasing results.
20:38:43 <augur_> thats the typical route people like to go because its easy. like really easy
20:39:01 <augur_> but its also hard to think about. what you really want is recursion-over-a-type
20:39:08 <augur_> ie catamorphisms/structural recursion
20:39:29 <augur_> but then you get a dual notion -- anamorphisms/structural corecursion
20:39:37 <Eduard_Munteanu> The mapStream earlier does just that... it increases the result size in finite time.
20:40:20 <augur_> corecursion is a convenient way to simulate stateful objects
20:41:39 <augur_> dwcook: another way of looking at corecursion is that codata is defined by destructors, not constructors
20:41:49 <augur_> which gives rise to agda's copatterns
20:42:08 <augur_> tho im not sure how you think about potentially-finite codata in that perspective
20:44:01 * dwcook remembers, at the mention of stateful objects, the term "costate comonad coalgebra"
20:45:47 <augur_> something like that
20:46:41 <augur_> the core idea of stateful objects (ignoring message passing) is that you have some sort of internal state, and methods to access it
20:46:55 <augur_> which is sort of like saying you have some unknown-to-the-outside type S for the state
20:47:08 <augur_> and a bunch of methods over that
20:47:53 <dwcook> Sounds related to existentials
20:48:00 <augur_> yep it is
20:49:23 <augur_> the canonical counter type would be something like   exists a :: *. (Int, a -> a)
20:49:47 <augur_> where the Int is the current count, and the a -> a is the increment
20:50:38 <augur_> so you get something like   makeCounter = (0, (1+)) :: that_type
20:50:52 <augur_> no thats not right, sorry
20:50:57 <augur_> exists a :: *. a -> (Int, a)
20:50:59 <augur_> there we go :p
20:51:13 <dwcook> Aha, much better
20:51:30 <augur_> i think thats about right
20:51:33 <dwcook> It's basically a stream of Int
20:51:55 <augur_> i forget how this junk works, honestly
20:52:34 <augur_> actually i think you also need another a in there
20:52:45 <dwcook> The other day I was pondering how to implement a pure unique value generator, and I realized it bore a striking similarity to what random does. That was when I realized both were streams
20:52:48 <augur_> exists a :: *. (a, a -> Int, a -> a)
20:53:37 * hackagebot range-set-list 0.0.3 - Memory efficient sets with continuous ranges of elements.  http://hackage.haskell.org/package/range-set-list-0.0.3 (phadej)
20:53:55 <dwcook> Okay, so you give me a thingy, a way to turn the thingy into an Int, and a way to get a new thingy from a previous one
20:54:03 <dwcook> So it could as well just be Int
20:54:09 <augur_> something like that, yeah
20:54:31 <dwcook> (n, id, (+1))
20:54:37 <dwcook> for some n :: Int
20:54:53 <augur_> the type of unfoldr is the right type for the constructor
20:56:09 <augur_> so yeah:   data CoList a = forall b. CoList b (b -> a) (b -> b)
20:56:19 <augur_> well, thats a stream actually
20:56:26 <augur_> not a colist
20:56:31 <augur_> colists might end
20:57:12 <augur_> the general scheme is soemthing like   data CoAlg f a = forall b. CoAlg b (b -> f b)
20:57:31 <augur_> eh. CoAlg is a bad name too. :)
20:58:12 <augur_> it wraps a f coalgebra into an object-y thing. also i shouldnt have that a there. im a dope
20:58:19 <augur_> i should just shut up
20:59:38 <dwcook> I'm a bit lost but I appreciate the effort
20:59:55 <dwcook> I learn best by applying
20:59:59 <augur_> thats ok, im lost too! :P
21:00:06 <augur_> let me point you to the right thing to read
21:00:56 <augur_> Algebraic and Coalgebraic Methods in the Mathematics of Program Construction - Backhouse, Crole, and Gibbons
21:01:23 <augur_> especially Ch 3 and 5
21:02:53 <augur_> A Tutorial on (Co)Algebras and (Co)Induction - Jacobs and Rutten
21:02:54 <augur_> and also
21:02:54 <augur_> Introduction to Coalgebra - Jacobs
21:03:04 <augur_> dwcook: i can send them to you if you need them
21:03:11 <dwcook> That would be good
21:03:12 <gaze__|net> Hey, anyone know why you'd write a type signature like data X a where X :: X a
21:03:30 <augur_> gaze__|net: GADTs!
21:03:38 <c_wraith> gaze__|net: that's GADT syntax, though that specific example is not a GADT
21:04:06 <gaze__|net> yeah yeah I get that it's GADT syntax... just usually the idea is to store a bit of data
21:04:13 <gaze__|net> I can't figure out what's being represented
21:04:18 <augur_> data TRUE = TRUE   ;   data So a where Oh :: So TRUE
21:04:30 <c_wraith> gaze__|net: so you're really asking why you'd use a phantom type?
21:04:33 <augur_> actually i guess data TRUE can be empty, but who cares
21:04:49 <augur_> gaze__|net: pls give me a value of type So Int
21:04:55 <gaze__|net> I've never heard of a phantom type
21:05:14 <c_wraith> gaze__|net: phantom types are ones that appear in a type signature, but no value of that type is represented
21:07:22 <c_wraith> gaze__|net: in that case, a is a phantom type.
21:08:26 <pavonia> Why is it a phantom type?
21:08:47 <augur_> phantom because no values of that type are ever used
21:08:57 <augur_> like
21:09:00 <augur_> its there in spirit only
21:09:20 <pavonia> I thought phantom type are types that don't have any data constructors
21:09:24 <augur_> no
21:09:33 <augur_> those are empty types
21:09:37 <dwcook> "empty"
21:09:41 <pavonia> oh
21:09:43 <augur_> empty modulo bottom!
21:09:55 <augur_> yet another reason why we should get rid of implicit effects!
21:10:03 <augur_> cmon haskell, you're all about reifying effects into monads
21:10:12 <augur_> lets reify partiality and laziness!
21:10:18 <augur_> why stop at IO!
21:10:20 <dwcook> augur_, it's too lazy
21:10:27 <augur_> :(
21:10:40 <augur_> i think thunking is a monad, iinm
21:10:48 <augur_> in agda, i mean
21:10:52 <gaze__|net> well, my example is from Accelerate... I'm trying to understand why you'd define data IntegralDict a where   IntegralDict :: ( Bounded a, Enum a, Eq a, Ord a, ...) => IntegralDict a in Type.hs
21:12:22 <c_wraith> gaze__|net: ah, in that case, it's not exactly phantom.  You're declaring that the GADT is carrying instance dictionaries for all those instances.
21:12:40 <c_wraith> gaze__|net: So there actually are values involved, though it's a bit implicit
21:13:23 <gaze__|net> https://github.com/tmcdonell/decelerate/blob/master/Type.hs is a watered down version I think
21:13:46 <gaze__|net> what do you mean instance dictionary?
21:14:02 <c_wraith> Eh.  Forget dictionaries, that's an implementation detail
21:14:12 <c_wraith> Think of it as proofs.
21:14:35 <c_wraith> n order to construct an IntegralDict, you need to prove those instances exist for the type a
21:14:40 <c_wraith> *In order to...
21:14:55 <gaze__|net> OH
21:14:57 <c_wraith> And then the IntegralDict value carries those proofs around.
21:15:14 <gaze__|net> so it's just a way of imposing that it's an eq, an ord, a boundad, etc.
21:15:21 <Iceland_jack> gaze__|net: https://www.haskell.org/ghc/docs/7.6.2/html/users_guide/data-type-extensions.html read the '7.4.6. Declaring data types with explicit constructor signatures' section
21:16:06 <c_wraith> gaze__|net: Yeah.  I kinda don't like it.  I'd rather have the instances be on the functions, not passed around in hiding like that.
21:16:08 <Iceland_jack> The GADTs extension really enables several different things
21:16:30 <gaze__|net> honestly I'm trying to find a good EDSL to take inspiration from
21:16:40 <gaze__|net> what do you guys recommend?
21:16:47 <gaze__|net> I was following Atom but it's a few years old
21:18:40 * hackagebot boundingboxes 0.1.1 - The type for 2D bounding box  http://hackage.haskell.org/package/boundingboxes-0.1.1 (FumiakiKinoshita)
21:18:42 * hackagebot free-game 1.0.4 - Create games for free  http://hackage.haskell.org/package/free-game-1.0.4 (FumiakiKinoshita)
21:32:10 <pygoscelis_> #NickServer
21:32:21 <pygoscelis_> quit
21:33:34 <augur_> lol
21:34:50 <bitemyapp> Fuuzetsu: the update that never ends. Wtf! Impressive :)
21:48:44 * hackagebot search 0.1 - Infinite search in finite time with Hilbert's epsilon  http://hackage.haskell.org/package/search-0.1 (EdwardKmett)
21:49:27 <augur_> ive never understood hilberts epsilon
21:50:24 <augur_> ive seen that one tutorial on it, but i dont understand it :(
21:53:51 <edwardk> the key is that the predicate has to terminate in finite time regardless of what it is given
21:54:11 <edwardk> so such a predicate can't inspect more than a finite portion of its input
21:54:31 <augur_> edwardk: hmm
21:54:47 <edwardk> so enumerate all the possibilities, working your way out and you'll eventually cross that modulus of continuity
21:55:13 <augur_> "modulus of continuity"?
21:55:53 <edwardk> consider a predicate on, say a natural number peano style, but it has to terminate in finite time.
21:56:00 <copumpkin> augur_: this is a simplified version of it in Agda: https://gist.github.com/copumpkin/4647315#file-weird-agda-L81-L84
21:56:20 <augur_> edwardk: finite but unbounded?
21:56:32 <augur_> edwardk: probably bounded, no?
21:56:39 <edwardk> basically it has to give the same answer to every number beyond a certain point, otherwise it'd take an infinite amount of time to calculate
21:56:53 <edwardk> here think of the number as codata
21:56:55 <augur_> ie, pred is O(1)
21:57:01 <copumpkin> no
21:57:20 <augur_> then what is meant?
21:57:36 <copumpkin> this : {P : Co‚Ñï ‚Üí Set p} (P? : Decidable P) ‚Üí Dec (‚àÉ P)
21:57:41 <copumpkin> :P
21:58:14 <augur_> i mean, what is meant by "terminate in finite time"
21:58:29 <augur_> if not constant time, then it seems like it means just "terminates"
21:58:39 <copumpkin> yeah, it terminates
21:58:41 <augur_> ok
21:59:03 <edwardk> i want you to give me a predicate that returns True or False for any input, but you can't take "too long". your question has to terminate no matter what Conat i give you.
21:59:22 <edwardk> therefore it can only inspect a finite portion of the input.
21:59:39 <augur_> ok
21:59:41 <edwardk> that means that anything beyond what it looks at can be whatever it wants, and the answer won't change
21:59:56 <edwardk> that 'event horizon' is the modulus of continuity i'm talking about.
22:00:13 <augur_> but "a finite portion" could mean of arbitrary length
22:00:18 <edwardk> you don't know what number it is, but you know there is one
22:00:30 <edwardk> sure
22:00:30 <augur_> ie there is no length n such that it inspects at most n constructors on the input
22:00:55 <edwardk> but if you start small and work out, eventually you'll pass whatever theshold there is
22:01:46 <augur_> im not sure how thats true if theres no upper bound on the size it looks at
22:02:07 <edwardk> so lets work with a query about a conats. you give me a predicate, i'll answer. i'll do so by checking zero, if not zero, then my response will start wth a succ, and i'll succ the argument i feed the predicate.
22:02:21 <edwardk> each time i'm using your predicate to do a bounded amount of work
22:02:21 <augur_> i mean, sure it can only look at finitely much of the input, but maybe for the n+1-th input it looks at a little bit more of that input
22:02:32 <edwardk> so my succ's are coming out as productiv corecursion
22:02:47 <edwardk> you can't do that.
22:03:10 <augur_> productive corecursion doesnt have to terminate tho
22:03:12 <Javran> @pl [f x | f <-[g,h,i,j,k] ]
22:03:12 <lambdabot> [f x | f <- [g, h, i, j, k]]
22:03:13 <edwardk> if i hand you the infinite conat you have to give me an answer in finite time
22:03:17 <edwardk> that is the contract
22:03:24 <augur_> ok
22:03:31 <augur_> so there IS a maximum bound
22:03:35 <edwardk> yes
22:03:37 <augur_> and its O(1)
22:03:41 <copumpkin> you just don't know it ahead of time
22:03:43 <augur_> for some sufficiently large constant
22:03:46 * hackagebot simple-genetic-algorithm 0.1.0.2 - Simple parallel genetic algorithm implementation  http://hackage.haskell.org/package/simple-genetic-algorithm-0.1.0.2 (eax)
22:03:49 <edwardk> your predicate is giving me the bound implicitly
22:03:55 <copumpkin> so you can't use it for your recursion
22:03:56 <augur_> right
22:03:58 <Javran> @pl [f x | f <- fs]
22:03:59 <lambdabot> [f x | f <- fs]
22:04:08 <Javran> @pl fs >>= \f -> f x
22:04:08 <lambdabot> ($ x) =<< fs
22:04:13 <edwardk> that bound is the modulus of continuity. i don't know what it is, but everything beyond some horizon doesn't matter.
22:04:34 <augur_> but the predicate is an O(1) algorithm -- thats the requirement, that there has to be an upper bound that bounds all uses of the predicate
22:04:37 <edwardk> this is a topological trick just reified into programming terms
22:04:50 <Javran> @pl fs >>=\f -> return . f $ x
22:04:50 <lambdabot> flip (return .) x =<< fs
22:04:51 <fragamus> hmm I'm having a weird problem. If I use a pair of numbers as my key when inserting into Data.Hashable all is well but‚Ä¶.. if I use a V2 I get   _|_
22:05:01 <fragamus> tuples good, Linear V2 bad
22:05:08 <augur_> edwardk: why is it called the modulus of continuity?
22:05:21 <copumpkin> augur_: keep in mind that I can define that weird thing with it
22:05:26 <copumpkin> in my file
22:06:09 <copumpkin> basically deciding if two "costreams" are equal in finite time
22:06:30 <augur_> copumpkin: costreams??
22:06:36 <copumpkin> Stream a = Nat -> a
22:06:40 <Javran> @hoogle (a -> b -> c) -> (a1 -> a) -> (b1 -> b) -> (a1 -> b1 -> c)
22:06:40 <edwardk> augur: http://math.andrej.com/2006/03/27/sometimes-all-functions-are-continuous/
22:06:41 <lambdabot> No results found
22:06:44 <copumpkin> Costream is what I'm calling CoNat -> a
22:06:49 <augur_> copumpkin: ah
22:07:11 <copumpkin> in some sense it's less streamy than Nat -> a
22:07:13 <copumpkin> but meh
22:07:30 <augur_> why less?
22:08:17 <copumpkin> because if a is not coinductive, I can only inspect a finite portion of the index at any point
22:08:36 <augur_> hm
22:08:49 <copumpkin> it's kind of weird
22:08:54 <copumpkin> same thing we had with our decision procedure before
22:10:29 <edwardk> basically that package proceeds by taking these ideas and building a generic construction for product types, sum types, (), etc. then turns that into a suitable epsilon
22:10:38 <NemesisD> hey guys. in ghci i'm reading a file that has 38 bytes in it like so: f <- withBinaryFile "test/golden/metadata_request" ReadMode hGetContents yet f shows up as "". whats up with that
22:11:07 <dolio> copumpkin: Finally did it, eh?
22:11:13 <copumpkin> dolio?
22:11:19 <dolio> impossible
22:11:19 <copumpkin> oh, that thing in agda
22:11:20 <edwardk> epsilon :: (a -> Bool) -> a   gives you an a that satisfies the predicate if any a does, or an arbitrary a otherwise.
22:11:24 <augur_> i feel like i'd understand this better if the examples involved were less number-y and more type-y
22:11:27 <copumpkin> dolio: yeah, a while ago :)
22:11:39 <copumpkin> never did andrej's original formulation though
22:11:49 <copumpkin> not convinced that's possible without a lot more weirdness
22:11:56 <copumpkin> or escardo
22:12:00 <edwardk> epsilon :: (() -> Bool) -> ()  -- is easy
22:12:17 <kazagistar> lets say I am writing a game, and the game has players that take turns reacting to the game state. Some players might require IO action to make their choice, ie human players, and some players might not, ie computer players. What would be a good way to write this... should I just thread IO through all of the players, or keep the stateless and stateful players separate and treated separately, or what?
22:12:27 <NemesisD> ah nm i see. shouldn't read it as a string. using bytestring instead
22:12:36 <edwardk> for sums? check one, if the answer fails the predicate check the other.
22:12:41 <copumpkin> dolio: unless you were just remarking on the naming, and not the fact that I'd been trying to do that for a while :P
22:12:41 <edwardk> products are actually quite tricky
22:12:54 <dolio> No, the latter.
22:12:54 <edwardk> but that is the only hard case
22:12:58 <copumpkin> ah okay
22:13:35 <augur_> edwardk: this really ought to apply to functions too, no?
22:14:09 <augur_> edwardk: that is to say, function spaces should be searchable as well? or do function spaces not have this upper bound
22:14:40 <augur_> certainly you can enumerate constructive functions
22:14:48 <Welkin> copumpkin, where do people come up with these names?
22:14:57 <edwardk> well, note copumpkin's example was (Conat -> a)  is searchable, if a is searchable, not just Conat
22:15:10 <Welkin> I read it at first as "compumpkin"
22:15:32 <edwardk> so you can search Cantor, not just Conat
22:15:39 <gaze__|net> What are peoples' opinions on using a GADT to represent the syntax tree of an embedded language vs just an ADT? I noticed Copilot uses GADTs, and Ivory uses just a simple ADT
22:15:55 <augur_> gaze__|net: depends on what you want to use the GADT-ness for
22:16:03 <edwardk> of course naive search gets expensive
22:17:23 <gaze__|net> well, I suppose I don't see why you wouldn't use a GADT. It would seem to assure that the AST is well typed, which seems like exclusively a good thing
22:17:58 <Iceland_jack> gaze__|net: GADTs complicate things, there is always a trade off
22:18:32 <edwardk> augur_: http://comonad.com/reader/2011/searching-infinity/ shows a vastly faster way to extract the modulus if you let some intensional information get out from the function.
22:22:30 <augur_> @tell dwcook http://www.purelytheoretical.com/transfers/corecursion.zip
22:22:30 <lambdabot> Consider it noted.
22:22:49 <augur_> that has a few good PDFs btw incase anyone wants some reads
22:28:13 <augur_> edwardk: the peano search is closely related somehow to an enumerator coalgebra for peanos
22:28:26 <augur_> this is nice. hmm hmm
22:29:35 <augur_> edwardk: it seems like searching ultimately comes down to: you have an enumerator, and you have a test that runs it constant time
22:30:11 <edwardk> augur_: yep
22:30:12 <augur_> and then its just findFirst p enums
22:31:40 <jle`> kazagistar: how are you structuring your game?  Imperatively or FRP...?
22:32:15 <MedDev> I'm trying to install the accelerate-examples package but upon trying to install I get a weird error: http://lpaste.net/101701 . It says it found ghc before that so I don't know why not finding uhc would cause it to fail? or is it some other dependency failure?
22:33:19 <MedDev> oh nvm maybe it's because the flags i'm setting aren't properly set
22:33:21 <kazagistar> jle`: So far, imperatively I think, though I am not entirely sure what the difference would be for this
22:34:00 <jle`> kazagistar: just trying to frame the situation in my head
22:34:32 <jle`> i would recommend not tying in player input IO
22:34:45 <jle`> and having it be an input/state to your system that is added during the game loop
22:35:27 <jle`> if it gets too complicated then don't discount having the entire game state an IO for input, but...no need to throw it all out the window for now
22:36:16 <jle`> alternatively you can make everything StateT IO and everything non-io a StateT Identity, and promote the StateT Identity monads to StateT IO inside your state loop
22:36:43 <jle`> so you get the guaruntees of purity, with the conveniences of ad-hoc io where you want it
22:38:21 <kazagistar> jle`: What I was thinking about was something that would look like move :: GameState -> StateT IO Action, which sounds like what you are suggesting
22:38:52 <jle`> yeah, but make sure that you write computerMove :: GameState -> StateT Identity Action
22:39:02 <jle`> and then when you wrap it all together, promote it to StateT IO
22:39:22 <jle`> actually what
22:39:28 <jle`> that should be StateT GameState IO Action
22:39:41 <jle`> vs computerMove :: StateT GameState Identity Action
22:40:48 <jle`> @unmtl StateT s m a
22:40:48 <lambdabot> s -> m (a, s)
22:41:27 <bitemyapp> @help unmtl
22:41:27 <lambdabot> unroll mtl monads
22:41:32 <bitemyapp> @help mtl
22:41:32 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
22:41:47 <jle`> just demonstrating that StateT already has the implicit GameState -> ... part inside it
22:42:31 <jle`> kazagistar: so basically, write as much as your code in StateT GS Identity, and only a minimal subset in StateT GS IO
22:42:37 <kazagistar> jle`: hmm, I was thinking that it might be good to separate AI state from game state, so what I should have is more like move :: StateT a IO Action... ill have to look up promoting Identity, that is a bit outside my current (limited) haskell knowlege
22:42:40 <jle`> actually, you can take this even another level
22:42:49 <jle`> and have another 'safe' level
22:42:57 <kazagistar> I mean  move :: GameState -> StateT a IO Action
22:42:58 <jle`> ReaderT GameState Identity Action
22:43:13 <jle`> which is like the StateT version only you can't modify the state
22:43:36 <jle`> kazagistar: why would your move take a GameState as a parameter?
22:43:41 <jle`> is your StateT's state not GameState?
22:44:39 <kazagistar> jle`: no, I was going to make that my AI state, since that is a separate concern and I don't want game code to care about how the AI's state is handled
22:44:46 <jle`> ah
22:44:55 <no-n> @src replicateM
22:44:56 <lambdabot> replicateM n x = sequence (replicate n x)
22:45:52 <jle`> then why wouldn't it be GameState -> Identity Action ?
22:46:31 <jle`> or moveAI :: GameState -> Action
22:47:55 <kazagistar> jle`: how would moveAI :: GameState -> Action modify the AI state?
22:48:38 <jle`> kazagistar: ah the AI state is persistent across moves
22:48:48 <jle`> forgot about that.
22:48:51 <jle`> but that's going to be weird
22:48:51 <kazagistar> jle`: think of a state machine based AI, or something similar, yes
22:49:09 <jle`> how are you going to store the AI state from frame to frame?
22:49:30 <jle`> you can store the state of the state machine, but State isn't a state machine
22:50:01 <jle`> state doesn't have any memory if you don't store and re-feed back in the state
22:51:24 <jle`> if you're doing that you might as well do moveAI :: GameState -> AIState -> (Move, AIState), so you don't have to do the superfluous unwrapping step
22:51:53 <kazagistar> jle
22:51:57 <jle`> you can use State AIState to compose your AI actions
22:52:18 <jle`> but if you do that, your moveAI should handle the wrapping and unwrapping/running for you?
22:52:34 <jle`> sorry, i talk a bit too much v.v
22:52:38 <kazagistar> jle`:  that makes sense, but I also was hoping to have players use the same interface... maybe that is just the wrong way to do things?
22:53:20 <kazagistar> A player's natural interface looks more like movePlayer :: GameState -> IO Move
22:54:36 <jle`> how do you want to store your AI's state from frame to frame?
22:55:03 <kazagistar> and honestly, I could just use the same interface for AIs, and just have the state stored as an IORefs, like the bad imperative programmer in me whispers to do
22:55:58 <jle`> if you want to store it as a part of the GameState, you can do movePlayer :: StateT GameState IO Move, moveAI :: StateT GameState Identity Move would work.
22:56:08 <jle`> or you could use zoom etc. from lense
22:56:16 <jle`> and make moveAI :: StateT AIState Identity Move
22:56:21 <jle`> did i say lense haha
22:56:42 <jle`> basically, zoom etc. lets you use a StateT action that acts on a small sub-set of the GameState
22:56:45 <Iceland_jack> lens√©
22:57:30 <jle`> hm wait but then you do'nt have the whole GameState
22:57:33 <jle`> er.
22:57:39 <jle`> either way you have to store the AI state somehow
22:59:00 <jle`> why chose an IORef instead of keeping it in GameState?
22:59:28 <jle`> you are just trading explicit state for implicit state
22:59:58 <jle`> alternatively you can have a GameAIState = GameAIState GameState AIState, if you want to separate it out
23:00:11 <kazagistar> I mean moveAI :: GameState -> AIState -> (Move, AIState) looks fine, bit it could be something like move :: Monad a => GameState -> AIState -> a (Move, AIState)
23:00:13 <jle`> this is just one of the trickier problems you have to deal with when using a giant monolithic state global state monad
23:01:10 <jle`> kazagistar: and a could possibly be IO ?
23:02:00 <kazagistar> jle`: yes, and in the Human implementations it would be explicitly IO, and the computer ones it would be left undefined? is that possible?
23:02:07 <jle`> undefined = Identity
23:02:09 <jle`> but
23:02:15 <jle`> for Human implemenations, what is AIState?
23:03:26 <kazagistar> no idea, probably also useless... maybe I really do need to handle them separately
23:03:41 <augur_> edwardk: i wonder if its possible to define what it means to be a testable predicate
23:04:44 <augur_> edwardk: i think for certain polynomial functors, you could define testable predicts on them by defining a depth type
23:04:49 <jle`> if you do movePlayer :: GameState -> () -> IO (MoveState, ()), then you can sort of have the same interface
23:04:50 <zRecursive> @src threadDelay
23:04:50 <lambdabot> Source not found. Sorry.
23:05:15 <jle`> it'll also be a little more symmetric if you swap the first two arguments
23:05:40 <zRecursive> :t threadDelay
23:05:41 <lambdabot> Not in scope: `threadDelay'
23:05:53 <augur_> edwardk: like... data Depth f n where   Stop :: Depth f 0   ;   Go :: f (Depth f (n-1)) -> Depth f n
23:06:05 <zRecursive> :t Control.Concurrent.threadDelay
23:06:06 <lambdabot> Int -> IO ()
23:06:15 <jle`> movePlayer :: () -> GameState -> IO (Move, ()), moveAI :: AIState -> GameState -> IO (Move, AIState).... then you could do movePlayer () :: GameState -> IO (Move, ()) and moveAI AIState :: GameState -> IO (Move, AIState)
23:06:23 <augur_> edwardk: then you can say  Searchable f = exists n. Depth f n -> Bool
23:06:44 <augur_> edwardk: no actually
23:06:46 <mzero> grr... why is there no nice way to write       (f =<< a) =<< b
23:06:49 <augur_> Stop :: Depth f n
23:07:00 <augur_> edwardk: and then   Searchable f = exists n. [Depth f n]
23:07:14 <augur_> edwardk: since that would be a list of f's at most n deep
23:07:31 <augur_> edwardk: then you could just pattern match on those to test
23:08:35 <mzero> grrr... that isn't even what I want
23:08:56 <augur_> search :: Searchable f -> Mu f
23:08:56 <jle`> kazagistar: the plumbing might be a bit ugly in that case though.
23:09:17 <kazagistar> jle`: that seems reasonable though
23:09:25 <jle`> *either case
23:09:48 <jle`> beucas eyou're just yanking the AIState out of the state, and then putting it back in later
23:09:50 <jle`> :/
23:10:03 <jle`> that's sort of the whole point of the state monad + lens's in the first place
23:10:51 <kazagistar> jle`: now for something a little harder: lets say the game were now realtime, and each move is a frame: it might be nice to have the players calculate their moves in parallel. IO forces linearization though, so now you would have to treat pure and impure players differently, or just go to FRP proper, right?
23:13:24 <kazagistar> ... I really should just learn lenses, I just don't have a really good project for it yet
23:13:49 <jle`> how about this one? :P
23:13:54 * hackagebot simple-genetic-algorithm 0.1.0.3 - Simple parallel genetic algorithm implementation  http://hackage.haskell.org/package/simple-genetic-algorithm-0.1.0.3 (eax)
23:14:46 <jle`> if each move is a frame then you could do the same thing, and launch all of the AI thread at once.  because they are all pure, it shouldn't matter
23:15:08 <jle`> if each move spans over multiple frames nondeterministically then you have to rethink things
23:19:53 <jle`> by the way i might talk with confidence but full disclaimer, i actually don't know anything about anything :)
23:20:05 <kazagistar> I mean, a real game engine has all KINDS of sillyness built around physics frames vs rendering frames and whatnot
23:20:12 <Welkin> the only thing you know is that you know nothing
23:20:44 <jle`> kazagistar: yup
23:21:39 <jle`> kazagistar: FRP proper doesn't have too many real solutions for realtime games that launch and re-collect parallel threads
23:21:45 <jle`> even.
23:21:48 <jle`> not for now at least :)
23:22:15 <jle`> i think sodium and family can do that, those might not be the ones you want to make realtime games with
23:22:55 <jle`> real semantic solutions, at least
23:23:17 <jle`> actually
23:23:19 <jle`> hm.
23:23:23 <jle`> time to hit vim
23:23:27 <jle`> or a notepad
23:23:34 <Welkin> windows notepad?
23:23:56 <jle`> (a physical one :)  or windows, depending on which one i find first)
23:24:20 <Welkin> don't use windows...
23:24:39 <Welkin> programming on paper is actually a good exercise
23:24:49 <zRecursive> BTW, What's the best way for a notepad to visit Internet ?
23:25:08 <jle`> i actually did mean my physical notebook i carry around...having it around has actually provlem very useful :)
23:25:50 * startling . o O ( 'provlem' = 'proven' + 'problem' ? )
23:25:54 <Welkin> just as long as you write in psuedo-code or at least avoid algol-based languages...
23:26:01 <zRecursive> wifi oe 3G ...
23:26:13 <Welkin> the braces and semi-colons become annoying very quickly
23:26:13 <startling> Welkin: you just need to perfect your curly braces
23:26:35 <Welkin> I have; they look quite nice now
23:26:41 <Welkin> but I don't like writing them
23:26:50 <jle`> startling: yeah, perhaps :)
23:26:55 <jle`> i mostly draw graphs
23:27:33 <Welkin> data structures are nice and simple to play with in haskell
23:27:45 <Welkin> I haven't even written anything yet in haskell, just played around
23:27:55 <kazagistar> I have a teacher who writes pseudocode in Pascal, and uses value parameters to pass function outputs, it blows my mind
23:28:24 <startling> > let (+) = curry ((++) <$> take 4 . fst <*> drop 4 . snd) in "proven" + "problem"
23:28:26 <lambdabot>  "provlem"
23:28:51 <startling> (this is a monoid!)
23:28:52 <kazagistar> way to scare the new haskeller :P
23:29:03 <Welkin> I'm still on functors
23:29:42 <startling> Welkin: monoids aren't hard, for what it's worth
23:29:49 <startling> I mostly mean in the algebraic sense though
23:30:35 <Welkin> It has taken me some time to get used to the syntax, but I must say that Haskell is the coolest language
23:31:03 <Welkin> also, nice to look at (one reason I like python)
23:31:09 <jle`> :)
23:31:11 <jle`> :|
23:31:14 <zRecursive> Welkin: cool is enough not coolest :)
23:31:17 <jle`> (that is the progression of my reaction)
23:31:37 <startling> Welkin: it definitely is nice to look at
23:31:55 <Welkin> (let's all wrap our messages in parens to simulate lisp)
23:32:03 <Welkin> one reason I don't care for lisp
23:32:53 <startling> You get over the syntax, fwiw.
23:32:56 <kazagistar> I can't judge, all I know is I am still much faster at understanding Java or Python code then Haskell, but I am still training my brain
23:33:06 <startling> And the simplicity of it lets you do structural editing pretty easily.
23:33:19 <kazagistar> I mostly have trouble working through stuff like what you just wrote, startling :P
23:34:11 <jle`> kazagistar: try breaking it up
23:34:11 <kazagistar> but hoogle is the most amazing tool ever, so there is that
23:34:14 <jle`> but
23:34:18 <startling> kazagistar: the main thing is the Applicative ((->) r) instance
23:34:26 <jle`> you probably shouldn't be discouraged if you don't understand it right away
23:34:31 <jle`> it's not something you would see in real code, hopefully
23:34:33 <ricky_clarkson> kazagistar: Write id in Java and see how easy to understand it is. :)
23:34:35 <startling> it's intentionally opaque
23:34:55 <Welkin> you were overloading the "+" operator startling ?
23:34:59 <startling> or, well, not intentionally transparent.
23:35:04 <jle`> not overloading, but redefining
23:35:04 <kazagistar> ricky_clarkson: id = rather not?
23:35:05 <startling> Welkin: no, defining a new one
23:35:19 <jle`> you can define arbitrary operators in haskell
23:35:31 <Welkin> that part still confuses me
23:35:43 <ricky_clarkson> > let x . y = y x in "Haskell is OO too".length
23:35:44 <lambdabot>  17
23:35:46 <startling> Welkin: which part, the shadowing or the defining?
23:35:49 <Welkin> how in learnyouahaskell ":=:" was redefined to mean the same thing as ":"
23:35:51 <jle`> and if you do something like let hello = 5 in hello, "hello" refers to the hello in the "let ... in"
23:36:05 <jle`> Welkin: it's not being redefined :)
23:36:09 <jle`> it's just like a normal definition
23:36:13 <Welkin> well, defined
23:36:23 <Welkin> I didn't see a straightforward definition
23:36:46 <startling> most people kind o.O at seeing an operator on a left-hand-side of =.
23:36:57 <jle`> > let tupleUp x y = (x,y) in tupleUp x y
23:36:58 <lambdabot>  (x,y)
23:37:09 <jle`> > let x <+> y = (x,y) in x <+> y
23:37:10 <lambdabot>  (x,y)
23:37:27 <startling> > let (<+>) = (,) in x <+> y
23:37:28 <lambdabot>  (x,y)
23:38:10 <Welkin> how would you define :=: to be list appending?
23:38:17 <kazagistar> > let x -|- y = y - x in 3 -|- 4
23:38:18 <lambdabot>  1
23:38:27 <jle`> Welkin: do you mean appending, or consing?
23:38:33 <jle`> appending is list ++ list
23:38:38 <jle`> consing is item : list of items
23:38:39 <startling> Welkin: I think (:=:) is a syntax error.
23:38:43 <Welkin> yes
23:38:45 <Welkin> consing
23:38:46 <startling> or, defining it as a function is
23:39:04 <no-n> i want some fun haskell problems
23:39:04 <jle`> hm. wait, did LYAH define the data constructor as :=:?
23:39:09 <Iceland_jack> Welkin: (:=:) is a constructor, you can't define a function that starts with :
23:39:14 <no-n> i found the 99 but they're ehhh
23:39:16 <startling> :t let (:=:) = (:) in (:=:)
23:39:17 <lambdabot> Not in scope: data constructor `:=:'
23:39:17 <lambdabot> Not in scope: data constructor `:=:'
23:39:31 <jle`> Welkin: do you know about algebraic data types?
23:39:38 <kazagistar> oh god, I forgot I need to disable smilies on my chat client before I come to #haskell
23:39:53 <jle`> data List a = Cons a (List a) | Nil
23:40:04 <Welkin> Iyes
23:40:07 <Welkin> I remember that
23:40:09 <startling> kazagistar: haha
23:40:18 <jle`> so
23:40:29 <jle`> remember you can define let plus x y = x + y
23:40:39 <Welkin> and Lipovaca redfined Cons as :=:
23:40:44 <jle`> you can also define let x <<>> y = x + y
23:40:53 <jle`> <<>> is just like a normal function...it just goes in between things
23:41:00 <jle`> you can do the same thing with data constructors...although most people don't do it normally
23:41:08 <jle`> data List a = a :=: List a | Nil
23:41:13 <jle`> :=: is the same as Cons
23:41:22 <jle`> except in the middle, infix, instead of prefix
23:41:38 <kazagistar> note, you can use any normal function in-between things as well using backticks, or use any infix function in front using parens
23:42:05 <Iceland_jack> > take 3 [1..]
23:42:06 <lambdabot>  [1,2,3]
23:42:10 <Iceland_jack> > 3 `take` [1..]
23:42:12 <lambdabot>  [1,2,3]
23:42:36 <kazagistar> > (+) 3 4
23:42:38 <lambdabot>  7
23:42:56 <jle`> no-n: try those daily haskell problems?
23:42:59 <jle`> they are neat
23:43:45 <kazagistar> I tried the 99 haskell problems, but they are not well tunes for haskell, and betray their lisp heritage a lot
23:44:17 <kazagistar> *tuned
23:45:11 <no-n> jle`: link?
23:45:50 <kazagistar> is it this one maybe? http://dailyhaskellexercise.tumblr.com/
23:46:09 <jle`> no-n: https://twitter.com/1HaskellADay
23:46:50 <kazagistar> I see a bunch of twitter chatter and no problems :/
23:47:32 <jle`> https://github.com/1HaskellADay/1HAD/tree/master/exercises/HAD
23:47:34 <jle`> but
23:47:39 <jle`> the twitter chatter is a part of the charm i think :)
23:47:58 <jle`> the latest problem is only a couple of messages down from the top
23:51:29 <kazagistar> yeah, I prefer something that I can point a rss feed at and get a high signal to noise ratio, twitter just isn't for me
23:52:47 <jle`> you can also clone the repo and re-pull every day :)
23:52:55 <jle`> or every time you wanta  new problem
23:54:30 <kazagistar> rss/email has the advantage of unified push notifications
23:55:07 <kazagistar> but yeah, I am just being silly and offtopic now :D
23:59:02 <MP2E> huh, I can't get darcs to clone xmonad
23:59:11 <MP2E> granted I've never used darcs so this could be user error
23:59:18 <MP2E> But it's saying something about a hash mismatch.
23:59:23 <MP2E> Same with xmonad-contrib
