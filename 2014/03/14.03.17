00:01:56 <jle`> is it common for Show instances of Exceptions to be pretty-printy shows?
00:02:09 <jle`> instead of the typical "it should be the inverse of read rawr" instances?
00:06:01 <rex1> I have this function that takes in a list of functions over lenses:
00:06:04 <rex1> makeForm :: [(TVar a, Lens' a b) -> UI Element] -> TVar a -> Lens' a b -> UI Element
00:06:16 <rex1> and I try to map  like this:
00:06:19 <rex1> map ($(st,l)) elts
00:06:30 <rex1> but I'm getting a type error that I don't understand
00:06:45 <rex1>  Couldn't match type `forall (f :: * -> *).
00:06:48 <rex1>                          Functor f =>
00:06:50 <rex1>                          (b -> f b) -> a -> f a'
00:06:52 <rex1>                   with `(b -> f0 b) -> a -> f0 a'
00:06:54 <rex1>     Expected type: [(TVar a, (b -> f0 b) -> a -> f0 a) -> UI Element]
00:06:56 <rex1>       Actual type: [(TVar a, Lens' a b) -> UI Element]
00:07:01 <zenkeku> Anyone familiar with XMonad? #xmonad seems to be pretty dead at the moment.
00:07:08 <zenkeku> @paste
00:07:09 <lambdabot> Haskell pastebin: http://lpaste.net/
00:07:12 <zenkeku> rex1: ^
00:08:04 <rex1> oh sorry
00:09:40 * hackagebot warp 2.0.3.4 - A fast, light-weight web server for WAI applications.  http://hackage.haskell.org/package/warp-2.0.3.4 (MichaelSnoyman)
00:09:42 * hackagebot warp 2.1.1.1 - A fast, light-weight web server for WAI applications.  http://hackage.haskell.org/package/warp-2.1.1.1 (MichaelSnoyman)
00:09:43 <rex1> I copied it to that:
00:09:45 <rex1> http://lpaste.net/101318
00:10:52 <rex1> I guess I don't know what f is, or why i has a quantifier in one type but not the other
00:11:08 * hackagebot warp 2.0.3.4 - A fast, light-weight web server for WAI applications.  http://hackage.haskell.org/package/warp-2.0.3.4 (MichaelSnoyman)
00:11:08 * hackagebot warp 2.1.1.1 - A fast, light-weight web server for WAI applications.  http://hackage.haskell.org/package/warp-2.1.1.1 (MichaelSnoyman)
00:12:12 <zoku> zenkeku: yep
00:12:18 <zoku> zenkeku: I used it for a while, what's up?
00:12:59 <zenkeku> zoku: http://lpaste.net/101317 -- Calling this gives me absolutely nothing. I know the syntax of the command (scrot ... ) is correct.
00:14:08 <zoku> hmm, yea, that's odd
00:14:31 <zoku> maybe check your console output for the X session?
00:14:57 <zenkeku> zoku: Do you mean by running the command in the terminal?
00:15:46 <zoku> your x11 session will have a console output somewhere, it could be ~/.xsession.errors
00:16:02 <zoku> or if you run `startx` from a tty
00:16:12 <zoku> the console will be in that tty
00:16:37 <YellowOnion> jle`: was that a question in relation to what I was talking about?
00:17:09 <zenkeku> zoku: I am using startx. How would I view the output to the tty?
00:17:16 <jle`> YellowOnion: no, actually
00:17:19 <zoku> ctrl+alt+f1
00:17:31 <zoku> or f2, f3..whatever tty you spawned it from
00:17:53 <zoku> then f7 will get you back to the x session
00:18:17 <YellowOnion> spacekitteh: minimal reproduction in ghci: http://lpaste.net/raw/101319
00:18:56 <zenkeku> zoku: Unfortunately I am running on TTY1. Note: I am using arch linux.
00:21:50 <zoku> soo, you can't get back to tty1?
00:22:36 <lpsmith> Does anybody here upgrade Cabal (the library, not cabal-install) from what GHC shipped with on a regular basis?
00:23:23 <YellowOnion> zoku: I think startx uses the same tty as it was launched it (atleast I remember this happening last time on archlinux)
00:24:32 <zenkeku> YellowOnion: The only way I would be able to view errors (If they were output to the TTY) is to killx.
00:25:11 <spacekitteh> YellowOnion: what package is that?
00:25:37 <YellowOnion> zenkeku: yeah I would probably killx and restart with output piped to a file.
00:26:00 <zenkeku> YellowOnion: Yea.. I'll probably just do that.
00:26:01 <YellowOnion> spacekitteh: Graphics.Implicit as shown on the prompt.
00:26:04 <zenkeku> Or just start X on another tty
00:26:37 <spacekitteh> YellowOnion: what cabal package i mean
00:27:08 <YellowOnion> oh cabal install implicit
00:27:39 <YellowOnion> zenkeku: a file will be easier to pastebin
00:28:13 <zoku> YellowOnion: weirdd, it always found a new one for me
00:28:23 <zoku> usually getty was tty1-6
00:28:27 <zoku> X was like tty7
00:28:59 <zenkeku> YellowOnion: No errors what so ever.
00:30:49 <spacekitteh> i get an error
00:30:59 <spacekitteh> win8.1 x64
00:32:04 <YellowOnion> zenkeku: empty output or do you get some output, but nothing hinting at your issue?
00:32:34 <zenkeku> YellowOnion: Some output but no errors.
00:34:26 <YellowOnion> I'm not familiar with Xmonad or scrot so I wouldn't know where to proceed
00:35:01 <zenkeku> Mm, that's unfortunate. Thanks for the help, regardless.
00:38:06 <no-n> why doesn't vim use cyan for hs files? :p
01:16:13 * hackagebot clash-ghc 0.2.2.1 - CAES Language for Synchronous Hardware  http://hackage.haskell.org/package/clash-ghc-0.2.2.1 (ChristiaanBaaij)
01:26:14 * hackagebot lio-simple 0.0.0.2 - LIO support for the Simple web framework  http://hackage.haskell.org/package/lio-simple-0.0.0.2 (DeianStefan)
01:28:33 <spacekitteh> oh damn
01:28:38 <spacekitteh> i just tried compiling my library on windows
01:28:56 <spacekitteh> it won't compile because a function with unicode in it doesn't have a top level binding
01:29:02 <spacekitteh> and so ghc warns about it
01:29:05 <spacekitteh> and so ghc crashes
01:30:21 <spacekitteh> er
01:30:28 <spacekitteh> it's a top level binding with no type sig
01:40:00 <tdammers> a function with a unicode identifier?
01:40:07 <tdammers> or a function that does something unicode-related?
01:43:56 <fly2web> (\l@(x:xs) -> (x,length l))   <------ i don't know about @?
01:44:50 <shiona> fly2web: if that was a question: l gets assigned to the whole list, x is first element of the list and xs is rest of the list
01:45:47 <fly2web> thanks shiona
01:50:39 <PudgePacket> If you ignore the qualifications in front of the functions, is there a better way to do this same piece of code without packing each argument?Data.Text.IO.putStrLn $ Data.Text.replace (Data.Text.pack "a") (Data.Text.pack "b") (Data.Text.pack "abc")
01:52:45 <PudgePacket> Perhaps wrapping Data.Text.replace to take and output strings and do the packing and unpacking inside the function but that seems so much clutter, isn't there a replace function that operates on strings?
01:54:27 <merijn> PudgePacket: You can use 'as' to rename imports, like "import qualified Data.Text as T" and then use T.pack
01:55:45 <merijn> Common aliases are BS for ByteString, LBS for lazy ByteString, M for Map, S for Set, T for Text or Traversable and F for Foldable
01:56:32 <zomg> I always find it odd for it to be LBS and not BSL, because the package is ByteString.Lazy, not Lazy.ByteString =)
01:56:32 <PudgePacket> Thanks merijn. I wrote a wrapped function to take and return strings around the Data.Text.replace, is there no equivalent function that operates on strings?
01:57:35 <merijn> PudgePacket: I don't know of one, but I understand why it wouldn't exist, String is pretty damn slow and is really best avoided for text processing
01:59:42 <PudgePacket> How can I use text then in my code, t"text" ?
01:59:44 <eatman> Morning!
02:00:03 <PudgePacket> Do I have to pack every string literal?
02:00:18 <Geraldus_RU> Morning!)
02:01:06 <merijn> PudgePacket: You may be interested in -XOverloadedStrings :)
02:01:19 <Geraldus_RU> merijn: Hi!
02:01:31 <merijn> PudgePacket: That extension changes every string literal into "fromString "string literal""
02:01:53 <peteretep> ah
02:02:00 <merijn> PudgePacket: Where "fromString :: IsString a => String -> a" and of course Text has an IsString instance :)
02:02:18 <peteretep> that's how all the examples for Happstack and Aeson get around explicitly recasting as Data.Text
02:02:30 <merijn> So you can just write string literals and use them as Text :)
02:02:43 <peteretep> now I know
02:02:46 <peteretep> Confused me a bit
02:03:09 <peteretep> I am slowly trying to increase my "real world" usage at the moment, and that strikes me as exactly one of those things
02:03:12 <merijn> PudgePacket: See also the "{-# LANGUAGE OverloadedString #-}" pragma, so you don't have to explicitly give the flag to GHC every time you compile
02:03:27 <merijn> peteretep: Even better, 7.8 will have OverloadedLists :)
02:03:57 <peteretep> about 80% of my time writing a simple REST API recently was:
02:04:14 <peteretep> a) Fighting the shitty Happstack.Lite docs until I gave up and just used Happstack.Server
02:04:25 <peteretep> b) Fighting Text.JSON, until I gave up and used Aeson
02:04:35 <PudgePacket> Thanks merijn!
02:05:27 <peteretep> is merijn a masculine form of the dutch name marijn?
02:05:53 <Geraldus_RU> Hello friends! I have GHC-7.8.1-RC2, and trying install Yesod. There is a problem with cryptohash-cryptoapi package. Compiler outputs a lot of "Not in scope" errors. There are only one file in that package, can someone take a look and help with solution? All errors points to names created with CPP directives
02:05:59 <merijn> peteretep: marijn is unisex, but yes merijn is the masculine version
02:06:21 <startling> is that like "marian"?
02:07:59 <merijn> startling: No, Marian comes from Mary, which comes from the biblical name. Marijn/Merijn come from Mare which is Latin for sea
02:08:13 <startling> oh, neat.
02:08:53 <peteretep> like "Marine", which is a French name
02:08:57 <peteretep> (I'm guessing)
02:09:16 <merijn> Apparently Mary originates from Aramaic/Hebrew from the original meaning of "rebellion" according to the interwebs
02:09:40 <peteretep> I am going to go by the name "RIOT" from now on
02:09:47 <t7> rebelling against classical insemination
02:10:22 <peteretep> o_O
02:37:10 <fly2web> It takes a list and weeds out the duplicate elements  <------ i don't know the mean of 'weed out'?
02:37:31 <luite> fly2web: removes
02:37:40 <fly2web> remove ok thanks
02:37:42 <fly2web> luite:
03:08:48 <int_index> How do I fold a tuple using template haskell? Say I have a function f and a tuple (a,b,c), I'd like to replace a call like TemplateFold f (a,b,c,d) to f a (f b (f c d)). Types of a,b,c,d do not matter, function f is overloaded using typeclasses
03:11:13 <gal_bolle> int_index: what is the class that f uses and what function of that class? (just to make the discussion more concrete)
03:15:01 <int_index> gal_bolle: Well let it be a typeclass F g, with a method f :: g a -> g b -> g (a,b)
03:15:50 <merijn> ezyang: After "Haskell for Coqers" and "OCaml for Haskellers", when will we get an "Agda for Haskellers"? :p
03:16:23 <Cale> int_index: You could generate a lambda which matches against a TupP
03:17:44 <Cale> Well, hmm...
03:17:51 <int_index> Cale: I thought it could be in some library already, since it's a very simple application of TH and I feel it could be common
03:18:06 <Cale> Nobody uses tuples bigger than pairs very much
03:18:32 <int_index> Doesn't matter, even if it were (a, (b, (c,d)) -- i'd like to fold it
03:18:44 <int_index> s/were/was/g
03:18:49 <int_index> not my native language, sorry
03:18:58 <Cale> were is fine
03:21:34 <quicksilver> you actually don't need TH for that; you can write a typeclass for tuple-folding
03:22:00 <quicksilver> I have a feeling that using TH for it won't actually be convenient in practice
03:22:09 <Cale> Yeah, you could write a bunch of instances
03:22:18 <quicksilver> but without the context of what you're actually doing, it's hard to be sure.
03:22:47 <bahamas> for foldl, doesn't the folding function take the accumulator as the first argument? I have this code http://lpaste.net/101323 and the compiler complains about an argument passed to a the "push" function. see the error at the end
03:22:52 <int_index> In the context of what I am doing I found a better solution. Now I'm just curious how to make a tuple foldable.
03:23:26 <merijn> :t foldl
03:23:27 <lambdabot> (a -> b -> a) -> a -> [b] -> a
03:23:59 <Cale> bahamas: Look at the type signature for process
03:24:03 <merijn> bahamas: Square brackets in rpn
03:24:08 <merijn> bahamas: On line 29
03:24:29 <merijn> bahamas: You're matching a list of one String, where that one String is "ex:_"
03:24:35 <merijn> so "ex :: Char"
03:24:42 <bahamas> Cale: ah, I forgot to update that
03:24:48 <Cale> the type signature for process says acc :: a and x :: [a]
03:25:15 <czro_> Im a bit confused about the different time types in the time package. I wish to add a measured amount of time to a point in time and return a new point in time, but cant figure out how. Do I understand it correctly if DiffTime is used for measured amounts of time and UTCTime for points in time? How do I add them?
03:25:15 <bahamas> yeah, I had it the other way around and I forgot to update the type signature. now I get a different error
03:25:38 <bahamas> merijn: doesn't getArgs return a list of strings?
03:25:54 <merijn> bahamas: Yes, but you're pattern on line 29 is wrong
03:26:06 <merijn> bahamas: I'm assuming you intend ex to be a String?
03:26:29 <Taneb> :t addUTCTime
03:26:30 <lambdabot> Not in scope: `addUTCTime'
03:26:35 <Taneb> @let import Data.Time
03:26:36 <bahamas> merijn: let me check
03:26:36 <lambdabot>  .L.hs:103:1:
03:26:36 <lambdabot>      Data.Time: Can't be safely imported! The module itself isn't safe.
03:26:38 <merijn> czro_: UTCTime is a "point in time" i.e. like march 29th 2014, 13:00 UTC
03:26:40 <Taneb> :(
03:26:49 <merijn> czro_: DiffTime is the span in between two points in time
03:27:24 <Taneb> czro_, and NominalDiffTime is like Difftime but doesn't know about leap seconds
03:27:54 <czro_> merijn: Ok. Probably easier to use NominalDiffTime then. Thanks.
03:28:39 <bahamas> merijn: oh, right
03:28:54 <merijn> bahamas: Basically, "rpn [ex:_]" matches as follow: [x] matches a one element list and that one element list 'x' is matched with (ex:_), so 'ex' is the first char of the list inside the outer list
03:29:11 <merijn> bahamas: If you intended to match the first String in getArgs you wanted "(ex:_)"
03:29:28 <Cale> int_index: http://lpaste.net/101326
03:31:01 <int_index> Cale: thanks, that's exactly what I was thinking of. I'm just curiuos if it's implemented somewhere already.
03:31:16 <Cale> It's not, as far as I know
03:31:42 <Cale> int_index: What are you using it for?
03:31:51 <bahamas> merijn: yup. I meant the second
03:32:48 <int_index> Cale, I was using it before I found out there's a hidden monad in my code.
03:34:31 <Cale> int_index: I mean, why are you trying to fold over tuples?
03:36:01 <int_index> I have a complex data structure which needs to be traversed in different ways, combining the results. I first found out that what I am doing is similar to heterogeneous fold, with my data instead of lists, and I could represent my data as tuples in order to achieve the effect.
03:36:58 <bahamas> damn, haskell really makes me think about the types I'm working with
03:37:36 <Axman6> oh no D:
03:37:45 <benj_> I know right!
03:38:01 <bahamas> :)
03:38:13 <bahamas> I'm not complaining
03:38:19 <int_index> Cale: if you ask about the overall problem, I need to apply certain transformations to a heterogeneous tree, which is an intermediate representation of a program in my translator
03:39:18 <Cale> Are you aware of stuff like http://hackage.haskell.org/package/syb ?
03:39:40 <Cale> and http://hackage.haskell.org/package/uniplate
03:41:40 <int_index> Cale, I was not aware. It's something to study, thank you.
03:42:01 <kuribas> If I want to make a typed language in haskell, I could use GADTs: http://lpaste.net/101327
03:42:12 <kuribas> How could I make this support multiple arguments?
03:42:25 <kuribas> Say (Int, String) -> Int
03:43:33 <kuribas> I cannot use a list, because it can have just one type?
03:46:18 <Yuu_chan> @pl \p f g x -> p (f x) (g x)
03:46:18 <lambdabot> liftM2
03:47:47 <Cale> kuribas: Every function has type a -> b for some types a and b
03:47:56 <Cale> kuribas: Include a function type in your type of types?
03:48:13 <int_index> kuribas: or a tuple in your type of types
03:48:31 <kuribas> int_index: I'd like tuples of arbitrary length...
03:49:57 <kuribas> Cale: ok, I am trying to figure out how...
03:50:53 <Cale> kuribas: FunType :: Type a -> Type b -> Type (a -> b)
03:51:39 <int_index> kuribas, in haskell a tuple of every size is a different type
03:51:49 <int_index> so (,) and (,,) and (,,,) are not connected in _any_ way
03:52:10 <kuribas> int_index: Yes, so I don't want to make a declaration for each tuple type.
03:52:48 <int_index> So I'd change the way you work with types.
03:53:49 <int_index> You could make a use of existential qualification
03:54:11 <int_index> Then every of your type could be parametrized by different amount of type variables.
03:54:31 <quicksilver> I think returning functions and using currying is in many ways preferable to the tuple tarpit
03:54:36 <int_index> *quantification
03:54:51 <quicksilver> I would try just having a single tuple type (the pair) perhaps
03:55:07 <int_index> quicksilver: it actually leads to the same problem
03:55:21 <int_index> he needs different amount of type variables in Type for every instance of the type
03:55:34 <int_index> I mean, a function is parametrized by a and b
03:55:35 <Cale> hm?
03:55:43 <int_index> and Integer is not parametrized at all
03:55:46 <kuribas> int_index: Ok, I'll look into existential qualification.
03:55:51 <int_index> quantification
03:55:52 <int_index> my bad
03:55:56 <kuribas> int_index: But I think Cales proposal will do.
03:56:16 <Cale> I don't really understand why you'd need multiple parameters to the Type type constructor
03:56:27 <Cale> in fact, it's unusual that there's one in the first place
03:56:40 <quicksilver> int_index: why? what's wrong with Type a -> Type b -> Type (a->b) and Type a -> Type b -> Type (a,b)
03:57:24 <PudgePacket> How would I define a list that can hold text, lists of text, lists of lists of text etc ?
03:57:38 <Cale> PudgePacket: As something which isn't a list
03:57:48 <Cale> PudgePacket: You're thinking of trees
03:58:03 <Cale> (I think)
03:58:21 <int_index> Cale, exactly, the purpose of GADTs here is to eliminate this type variable in Type type
03:58:51 <int_index> quicksilver, how'd you write the data constructors for those?
03:59:02 <int_index> so far I see only IntType and StringType
03:59:05 <Cale> int_index: Like I showed
03:59:19 <int_index> Oh, I see now.
03:59:53 <kuribas> Is this better? http://lpaste.net/101327
04:00:19 <Cale> kuribas: Possibly!
04:00:33 <Cale> It looks nicer to me, but I don't know what you're doing with it :)
04:01:37 <kuribas> I need a collection of typed functions which I use for evaluating a language.  They are currently builtin, but later it should be possible to define new ones.
04:02:26 <kuribas> The parser needs to know the type because it will parse differently based on the type of the function.
04:02:48 <kuribas> It's a typed version of metafont.
04:04:52 <kuribas> So the parser takes a map from String to Value, and it typechecks the expression.  When it typechecks, it evaluates the function.
04:05:11 <bahamas> what wrong with this function http://lpaste.net/101329? the compiler complains that it can't deduce instances of Show and Read for x and y. do I need to use Int in the type signature of the function?
04:05:34 <kuribas> It seemed easier than constructing a syntax tree, and evaluating it.
04:05:56 <Fuuzetsu> bahamas: you're using show without saying that your input is Showable
04:06:24 <Fuuzetsu> your constraint should have ‘Show a, Read a, Integral a’
04:06:33 <bahamas> Fuuzetsu: oh
04:06:41 <Fuuzetsu> using Int would work but only because it happens to be an instance of all of those
04:07:35 <bahamas> I forgot all about that
04:07:38 <bahamas> Fuuzetsu: thanks
04:22:32 <bahamas> how do people debug in haskell? is there any equivalent to tracing with "print" from other languages?
04:22:49 <kuribas> bahamas: look at Debug.Trace
04:22:51 <Fuuzetsu> Debug.Trace
04:23:19 <kuribas> bahamas: I always test my functions in ghci.
04:23:48 <kuribas> Although arguably unit tests are better...
04:23:58 <kuribas> quickcheck is useful too.
04:24:01 <Cale> kuribas: Or quickcheck tests, yes
04:24:14 <bahamas> I've heard of quickcheck
04:24:39 <bahamas> kuribas: yeah, for this case, testing in ghci could help me. I didn't see how I could do that at first, but I see a way now
04:25:09 <Cale> But yeah, interactively evaluating things in ghci can be quite helpful for figuring out where stuff is going wrong. GHCi also has a debugger in it, but I haven't really gotten much use out of that.
04:25:41 <Reite> runtime debugging is a real pain in the ass! Luckily I almost never have to do it
04:26:08 <kuribas> bahamas: I normal have my program broken down in small functions, so first I do is trying out the small functions, to see if they work correctly.
04:26:53 <skypers_> hi
04:27:18 <Cale> Yeah, if you have a big complicated function somewhere which isn't working correctly, breaking it up into smaller parts often can get rid of the bug on its own, and even if it doesn't, it makes the problem easier to figure out.
04:27:41 <skypers_> @hoogle (Bifunctor p a b, Bifunctor p c d) => (a -> c -> x) -> (b -> d -> y) -> p a b -> p c d -> p x y
04:27:42 <lambdabot> Warning: Unknown class Bifunctor
04:27:42 <lambdabot> No results found
04:27:45 <skypers_> dammit…
04:28:03 <skypers_> I’m looking for a zip for bifunctor
04:28:08 <skypers_> zipWith*
04:28:32 <skypers_> oh btw I forgot Bifunctor p x y in the constraint
04:28:48 <bahamas> kuribas: that makes sense, but I haven't gotten used to doing it like that, especially when I try to get the big picture. that's why I build stuff and test at the end
04:28:53 <quicksilver> Bifunctor only has one paramter not three, skypers_ ?
04:29:08 <quicksilver> and isn't your function just first f . second g ?
04:29:18 <bahamas> in any case, I just realized I made an assumption that breaks a lot of things
04:29:20 <quicksilver> oh, no, it's not
04:29:44 <skypers_> huh, what?
04:29:50 <skypers_> a bifunctor is p a b
04:29:54 <skypers_> (two parameters)
04:30:04 <quicksilver> the class only has one parameter
04:30:11 <quicksilver> "class Bifunctor p where"
04:30:20 <quicksilver> sure, 'p' has two parameters
04:30:23 <skypers_> hm, yeah
04:30:30 <quicksilver> but that doesn't goe in the constraint
04:30:42 <skypers_> so yeah
04:30:46 <quicksilver> what you asked for can't be done with bifunctor, anyway
04:30:51 <quicksilver> it's like 'biapplicative' or something
04:31:02 <skypers_> (Bifunctor p) => (a -> c -> x) -> (b -> d -> y) -> p a b -> p c d -> p x y
04:31:10 <kuribas> bahamas: Making small functions and typechecking and testing early is a good thing, IMO.
04:31:24 <skypers_> I want that in order to write Num instances for (Int,Int), (Float,Float) and so on
04:31:24 <quicksilver> skypers_: biliftA2 :: Biapplicative w => (a -> b -> c) -> (d -> e -> f) -> w a d -> w b e -> w c f
04:31:33 <bahamas> kuribas: I don't disagree. I was just saying how I'm used to doing things :)
04:31:38 <skypers_> whaaaaaaaaaat :D
04:31:46 <skypers_> I’ll have a look into that after lunch :P
04:31:48 <skypers_> thank you :)
04:31:59 <skypers_> I think it’s not really the solution
04:32:09 <skypers_> since I’ll write instances for Num for (Int,Int,Int)
04:32:15 <kuribas> bahamas: I used to do that too, and still do sometimes.  But I find that the other way gives a better workflow.
04:32:16 <skypers_> and also (Word32,Word32,Word32,Word32)
04:32:17 <skypers_> and so on
04:32:44 <Cale> bahamas: btw, when we say "test" here, it doesn't necessarily have to be anything extensive
04:32:44 <kuribas> bahamas: But everyone is different, maybe for you another workflow works better.
04:33:08 <Cale> bahamas: You can just load the thing into ghci and apply it to a few parameters and make sure it behaves like you expect
04:33:53 <Cale> (and the nice thing is that whatever values you get from evaluating pure expressions like this, you'll always get)
04:34:14 <Cale> That's sort of why Haskell programmers get by without interactive debugging most of the time
04:34:32 <kuribas> bahamas: undefined is useful for typechecking :)
04:35:05 <Cale> Because interactive debugging mostly exists in order to allow the program to get into some complicated state and inspect the state of the world before and after some event
04:36:22 <quicksilver> skypers_: you can use the Traversable instance then
04:36:40 <quicksilver> I think
04:36:51 * quicksilver isn't sure
04:36:52 <Cale> But for pure Haskell functions, the only state which matters is the arguments to the function, and the only state affected is the result.
04:37:56 <bahamas> Cale: yup, that's how I understood it as well
04:40:14 <bahamas> Cale: kuribas anyway, it seems that Haskell is forcing me to take the approach that you mentioned (test things one at a time)
04:41:45 <kuribas> bahamas: It's a good approach for other languages too :)
04:42:35 <bahamas> kuribas: sure. it's just not easy changing habits :)
04:58:29 <instantepiphany> I am having trouble setting a colour of a widget using gtk2hs. I added a textview to a scrolled window and now there is a black border, thicker on top than on sides, around my text view. It _isn't_ the shadow, that is set to ShadowNone.
04:59:25 <instantepiphany> Never mind, my bad.
05:31:03 <bahamas> why does "subtract" have the arguments reversed compared to "div"?
05:31:33 <merijn> bahamas: Because it exists as replacement for operator section of (-)
05:31:53 <merijn> bahamas: The problem is that (-9) is minus 9, instead of "\x -> x - 9"
05:32:23 <quchen> bahamas: https://github.com/quchen/articles/blob/master/fbut.md#--4-is-not-x---x---4
05:32:24 <merijn> bahamas: Whereas div is just the implementation of integer division
05:34:25 <bahamas> merijn: I understand everything you said, but I still don't understand the reason. 10 - 14 == -4 but 10 `subtract` 14 == 4
05:34:43 <quchen> > (subtract 4) 10
05:34:44 <lambdabot>  6
05:35:02 <quchen> subtract = flip (-)
05:35:32 <quchen> `subtract` is a hack to create sections for (-), nothing else. Don't use it as `infix`.
05:36:44 <bahamas> quchen: you mean without "subtract", (-) wouldn't be possible?
05:36:56 <merijn> bahamas:
05:37:03 <merijn> bahamas: No, he means that you can do
05:37:16 <merijn> > let f = (+10) = f 5
05:37:17 <lambdabot>  <hint>:1:15: parse error on input `='
05:37:20 <merijn> eh
05:37:23 <merijn> > let f = (+10) in f 5
05:37:24 <lambdabot>  15
05:37:27 <merijn> But not
05:37:30 <merijn> > let f = (-10) in f 5
05:37:31 <lambdabot>  Could not deduce (GHC.Num.Num (GHC.Integer.Type.Integer -> t))
05:37:31 <lambdabot>    arising from the ambiguity check for `e_1105'
05:37:31 <lambdabot>  from the context (GHC.Num.Num (a -> t), GHC.Num.Num a)
05:37:31 <lambdabot>    bound by the inferred type for `e_1105':
05:37:31 <lambdabot>               (GHC.Num.Num (a -> t), GHC.Num.Num a) => t
05:37:42 <merijn> Because (-10) is parsed as negative 10
05:37:47 <merijn> Not partial application of (-)
05:37:56 <merijn> subtract's only goal is partal application of (-)
05:38:26 <merijn> > let f = subtract 10 in f 5
05:38:27 <lambdabot>  -5
05:38:49 <LnL> > let f = (- 10) in f 5
05:38:49 <lambdabot>  Could not deduce (GHC.Num.Num (GHC.Integer.Type.Integer -> t))
05:38:50 <lambdabot>    arising from the ambiguity check for `e_1105'
05:38:50 <lambdabot>  from the context (GHC.Num.Num (a -> t), GHC.Num.Num a)
05:38:50 <lambdabot>    bound by the inferred type for `e_1105':
05:38:50 <lambdabot>               (GHC.Num.Num (a -> t), GHC.Num.Num a) => t
05:39:19 <bahamas> merijn: yup, I understood that you can't do (-10), but I was still confused by something
05:39:37 <merijn> bahamas: subtract is to implement "(-10)"
05:39:42 <merijn> that's the only reason
05:39:47 <bahamas> merijn: quchen's article finally loaded and I think I understand
05:41:26 <quchen> O:-)
05:42:34 <merijn> quchen: Might wanna modify the "Char8 only for stuff like HTTP" note to mention that even then it's only useful for writing ByteString literals in your code
05:45:11 <quchen> merijn: Oh, good point
05:46:41 <merijn> quchen: Also: "It is worth noting that evaluating seq (error "x") (error "y") allows inspection of which argument is actually evaluated first." <- not true :p
05:47:08 <merijn> quchen: In case of an expression returning multiple potential bottoms, haskell is allowed to return an arbitrary one of the possible ones
05:47:12 <hpc> > seq (error "x") (error "y")
05:47:13 <lambdabot>  *Exception: x
05:47:15 <hpc> > seq (error "x") (error "y")
05:47:16 <lambdabot>  *Exception: x
05:47:17 <merijn> quchen: Regardless of which "it should have been"
05:47:19 <hpc> :(
05:47:50 <hpc> quchen: you might be thinking pseq, which /does/ have an ordering for reasons
05:48:04 <hpc> (that ordering is the only difference between it and pseq)
05:48:10 <merijn> So "case 4 of 4 -> error "Whoo!"; _ -> error "Boo!"" is allowed to return 'error "Boo!"'
05:49:02 <hpc> ghc might have seq = pseq but that's more of a "who cares" kind of thing than anything deliberate on their part
05:49:19 <hpc> and could change at any time
05:49:50 <merijn> hpc: That's exactly what his document says
05:51:33 <hpc> and yeah, the disconnect between what ghc happens to do consistently and what haskell specifies is vast
05:52:23 <__sebastian__> hi all, cabal has a problem with a package:  "rejecting: hunt-client-0.1/installed-798... (package is broken)". "cabal sandbox hc-pkg list" doesn't say, that this package is broken
05:52:49 <quchen> hpc: Sure, isn't that what I'm saying?
05:52:59 <__sebastian__> anyone has an idea, why this package might be broken?
05:53:02 <quchen> (Not sure where you're coming from, is this a response to my comments here yesterday?)
05:53:08 <dcoutts_> __sebastian__: it doesn't get listed with {}'s?
05:53:34 <quchen> GHC's implementation of seq = pseq is correct
05:53:52 <__sebastian__> dcoutts_: no
05:55:00 <quchen> merijn: Updated the Char8 paragraph, better?
05:56:49 <quchen> ReinH: I'm disappointed how little blood there is in the new Haskell Cast
06:07:39 <dcoutts_> quchen: no ghc's impl of seq is not the same as pseq
06:07:57 <dcoutts_> __sebastian__: and when you're doing the install, that's also within the sandbox?
06:08:18 <__sebastian__> yep. everything is in the sandbox
06:09:28 <__sebastian__> dcoutts_: I've unregistered and installed it again. this wotks, until I want to install a completley unrelated package
06:09:55 <quchen> dcoutts_: Well, in the sense that seq evaluates its first argument first
06:10:16 <dcoutts_> quchen: but that's exactly the point, there is no such guarantee with seq
06:10:37 <dcoutts_> quchen: and because of that lack of guarantee, they added pseq
06:10:54 <quchen> dcoutts_: Sure, but current seq works like pseq anyway. It's just wrong to rely on it.
06:11:03 <dcoutts_> quchen: no! it's really not
06:11:08 <quchen> Oh?
06:11:27 <dcoutts_> quchen: compile-time transforms can change it
06:11:43 <dcoutts_> e.g. strictness analysis + function strictness
06:12:06 <dcoutts_> it's not just a theoretical issue
06:12:09 <quchen> Oh, like "x `seq` y" is "y `seq` x `seq` y" for example
06:12:14 <skypers_> hey
06:12:27 <skypers_> if I have a type in Num
06:12:35 <skypers_> and a binary function between those types
06:12:40 <skypers_> Foo -> Foo -> foo
06:12:46 <skypers_> I can use Num litteral
06:12:50 <skypers_> like 9, 2, 3
06:13:07 <skypers_> now, if I have an instance in Num, why can’t I use it for Foo?
06:13:20 <skypers_> like 1 .+ 3 :: Foo
06:13:21 <skypers_> but
06:13:27 <quchen> Stop using Return.
06:13:30 <skypers_> (1,3) .+ (-1,4) -> fail
06:13:43 <quchen> :-s
06:13:52 <skypers_> (though (Int,Int) is in Num, I provided the instance)
06:14:00 <skypers_> any idea?
06:15:32 <quchen> No, paste some code.
06:16:41 <quchen> dcoutts_: Good thing I don't actually assert anything about GHC in the article. I'll be careful not to add it later :-)
06:17:07 <skypers_> erm, too long code. The issue is that I have a Foo type with an operator .+ :: Foo -> Foo -> Foo; now I made Foo in Num like (+) = (.+); I can right 3 + 1 :: Fo instead of Foo 3 + Foo 1; but if I have another way to build a Foo, with tuples for instance, I can’t write (2,3) + (-1,4)
06:18:52 <quchen> My oracle is broken, can't help you
06:19:38 <skypers_> well quchen, let’s ask another way: how does GHC to convert the litteral 7 into the Num type?
06:19:54 <skypers_> if I pass 3 to a function that expects a Foo
06:20:04 <skypers_> and if Foo is in Num, it works; why?
06:20:26 <skypers_> I think it’s thank to fromInteger
06:20:35 <yitz> skypers_: 3 is polymorphic.
06:20:36 <skypers_> that would explain why it fails with (1,3)
06:20:46 <skypers_> yitz: so is (1,3)
06:20:53 <quchen> literal 7 == fromIntegral 7
06:21:07 <yitz> skypers_: well yes but a different polymorphic type
06:21:30 <skypers_> that’s I can’t construct a Foo from (Int,Int) but I can from Int
06:21:49 <skypers_> even if  (Int,Int) is in Num
06:21:51 <skypers_> quite weird
06:22:14 <spacekitteh> is the wolfram language just mathematica
06:29:37 <isaacbw> sort of
06:29:42 <isaacbw> not the full language, but it's similar
06:29:45 <isaacbw> not sure if it's a proper subset
06:30:24 <PudgePacket> I'm trying to define a tree that can either hold text or a list of text, what's wrong with this? data TreeNode = Text | [TreeNode]
06:30:30 <spacekitteh> ah ok
06:30:55 <merijn> PudgePacket: You don't have any constructors
06:30:58 <mmmm> You need some constructors
06:31:04 <PudgePacket> oh derp
06:34:09 <PudgePacket> what would a constructor look like?
06:34:47 <tdammers> data TreeNode = Leaf Text | Branch [TreeNode]
06:34:54 <merijn> "data TreeNode = Node Text | Branches [TreeNode]" or something
06:35:02 <PudgePacket> ahhhhh
06:35:23 <quicksilver> data TreeNode = JustOne Text | LotsAndLots [TreedNode]
06:36:18 <quchen> From a logical perspective, can I treat constraint "=>" just as function arrows?
06:36:57 <quicksilver> if you are prepared to take the limiting and naive dictionary translation implementation as some kind of cosmic truth, quchen, then you can
06:37:37 <quchen> So that means yes, but you also shatter my world view with it?
06:38:11 <hpc> "yes, but you lose a lot of other things that way"
06:38:20 <quchen> Such as?
06:39:02 <hpc> polymorphic recursion
06:39:21 <quchen> Ah.
06:41:11 <Kron> Does anyone know any good quadtree libraries on hackage?
06:41:44 <Kron> something that abstracts a big 2D space and pretends to be an array but uses trees instead
06:42:44 <PudgePacket> I'm trying to make a datatype that is similar to a list but contains either text or a list of itself, it seems "data Tree = Leaf Text | Branch [Tree]" doesn't quite fit
06:43:06 <Kron> that is pretty much exactly the data type
06:43:13 <Kron> it's what I'd have done
06:43:17 <Kron> what's missing?
06:43:27 <prinsen> What's the difference between loadModules and setImports in Hint?
06:45:02 <PudgePacket> does "[Leaf "a", Leaf "b"]" not conform to that Tree type?
06:45:38 <Kron> no, it's (Brach [Leaf "a", Leaf "b"])
06:45:42 <benzrf> PudgePacket: ^
06:45:43 <Kron> the list itself is not a Tree
06:45:45 <benzrf> *Branch
06:45:49 <Kron> the Branch constructor is needed
06:45:52 <Kron> right
06:46:00 <dmwit> ?hoogle (Traversable t, Alternative f) => t a -> (a -> f b) -> f b
06:46:01 <lambdabot> Data.Foldable concatMap :: Foldable t => (a -> [b]) -> t a -> [b]
06:46:01 <lambdabot> Control.Concurrent.MVar withMVar :: MVar a -> (a -> IO b) -> IO b
06:46:01 <lambdabot> GHC.Conc.Sync withMVar :: MVar a -> (a -> IO b) -> IO b
06:46:02 <benzrf> PudgePacket: sum types require wrapping data constructors
06:46:03 <Kron> like, when you see this: [1,2,3]
06:46:10 <Kron> it's actually this: 1:[2,3]
06:46:13 <benzrf> PudgePacket: you cannot make a sum type of direct values of other types
06:46:15 <Kron> the cons constructor is the type list
06:47:11 <dmwit> prinsen: My guess would be it's something similar to :l vs. :m in ghci.
06:47:39 <dmwit> prinsen: i.e. loadModules puts all identifiers in scope, whether they're exported or not; and setImports uses an already-compiled chunk of code.
06:47:43 <dmwit> prinsen: or similar
06:48:13 <dmwit> :t \l f -> asum (fmap f l)
06:48:14 <lambdabot>     Not in scope: `asum'
06:48:14 <lambdabot>     Perhaps you meant one of these:
06:48:14 <lambdabot>       `F.asum' (imported from Data.Foldable),
06:48:19 <dmwit> :t \l f -> F.asum (fmap f l)
06:48:20 <lambdabot> (Functor t, Foldable t, Alternative f) => t a1 -> (a1 -> f a) -> f a
06:48:47 <dmwit> Any better way to write that? (e.g. does it already have a name?)
06:49:13 <benzrf> @pl \l f -> asum (fmap f l)
06:49:13 <lambdabot> (asum .) . flip fmap
06:49:17 <benzrf> probably not
06:49:22 <benzrf> :t F.asum
06:49:23 <lambdabot> (Foldable t, Alternative f) => t (f a) -> f a
06:49:40 <byorgey> dmwit: I doubt it
06:49:44 <benzrf> oh, is asum just foldr1 (<|>)
06:49:47 <Kron> @pl asum .: (flip fmap)
06:49:47 <lambdabot> asum .: flip fmap
06:49:47 <prinsen> dmwit: If i try to use loadModules on say Control.Concurrent I get module `Control.Concurrent' is a package module
06:49:51 <Kron> that should work
06:49:54 <benzrf> :T (.:)
06:49:55 <benzrf> :t (.:)
06:49:56 <lambdabot>     Not in scope: `.:'
06:49:56 <lambdabot>     Perhaps you meant one of these:
06:49:56 <lambdabot>       `.' (imported from Data.Function),
06:49:58 <Kron> use .: from Data.Composition
06:49:59 <benzrf> ??
06:50:06 <dmwit> benzrf: I think basically yes; though probably it uses foldr empty instead of foldr1.
06:50:07 <Kron> http://hackage.haskell.org/package/composition-1.0.1.0/docs/Data-Composition.html
06:50:08 <benzrf> wots .:
06:50:12 <Kron> it's basically just more complex compositors
06:50:17 <benzrf> that sounds awesome
06:50:17 <Kron> f .: g x y = f (g x y)
06:50:22 <Kron> I use it all the time
06:50:28 <Kron> imagine . but with two inputs
06:50:29 <prinsen> dmwit: my problem is that XSafe with Hint only has affect on loadModules, not setImports
06:50:30 <Kron> that's .:
06:50:47 <Kron> so we flip fmap and then just double composite it
06:50:48 <byorgey> for a counterpoint, /me never uses it =)
06:50:50 <Kron> asum .: flip fmap
06:50:54 <byorgey> not that I have anything against it
06:51:07 <bennofs> generalized: (.:) = fmap . fmap
06:51:11 <Kron> I find myself reimplementing it in half my haskell files
06:51:19 <Kron> so I just gave up and import it from Data.Composition
06:51:20 <dmwit> prinsen: Yes, I suspect Control.Concurrent is already compiled (hence can't be interpreted). You'd get the same error if you tried to :l Control.Concurrent in ghci.
06:51:31 <dmwit> prinsen: As for XSafe, I don't really understand that well enough to give advice.
06:51:45 <dmwit> prinsen: Presumably Control.Concurrent is already as Safe or Trusted as it can be.
06:52:12 <prinsen> dmwit: Sure, but I can import System.IO.Unsafe too :(
06:52:51 <byorgey> prinsen: what do you mean 'XSafe with Hint'?  where/how exactly did you set  XSafe?
06:52:57 <Kron> how will I know that hackage has processed my package candidate? Will it inform me, show error messages, etc.?
06:53:10 <bennofs> prinsen: maybe you're interrested in http://hackage.haskell.org/package/mueval ?
06:53:31 <hpc> Kron: how do you mean? afaik packages that are uploaded appear immediately
06:53:42 <Kron> the documentation hasn't appeared for mine
06:53:43 <bennofs> hpc: I think he is asking about docs
06:53:47 <Kron> *she
06:53:48 <hpc> oh
06:53:51 <prinsen> byorgey: unsafeRunInterpreterWIthArgs [ "-XSafe" ]. It seems to work with the modules loaded with loadModules, ie. I get an error if they import unsafe modules
06:53:57 <hpc> yeah, give that a day or so
06:54:01 <Kron> gotcha
06:54:03 <hpc> there's a cronjob that runs periodically
06:54:50 <byorgey> Kron: how long has it been since you uploaded your package?
06:54:53 <merijn> Kron: You won't really get a notification, there's a build log you can look into
06:55:01 <Kron> I uploaded it yesterday
06:55:05 <zgredzik> when I try to run `cabal install cuda` it fails at: Foreign/CUDA/Driver/Utils.chs:35:23: Illegal type signature: `IO (Status, Int) cuDriverGetVersion' - any ideas what can I do to fix this?
06:55:07 <Kron> about 14 hours ago
06:55:07 <prinsen> bennofs: I have already moved from plugins to hint, but Ill keep it in mind
06:55:25 <merijn> Kron: Which package?
06:55:30 <Kron> http://hackage.haskell.org/package/QuadTree-0.10.0/candidate
06:55:31 <byorgey> Kron: hmm, then the docs should have built by now.  as merijn says there is a build log but it can be difficult to find
06:55:48 <byorgey> prinsen: hmm, sorry, I don't know then, that sounds right
06:56:17 <Kron> I mostly want to just test out that my documentation properly links with the rest of the package ecosystem
06:56:28 <Kron> a 1+ day testing cycle is a bit annoying
06:56:55 <merijn> Kron: Weird
06:57:00 <merijn> Kron: That shouldn't take that long
06:57:02 <hpc> oh, there's /candidate now, TIL
06:57:11 <byorgey> prinsen: if you're interested in "safe" evaluation of untrusted Haskell code, though, you should really look at existing solutions instead of rolling your own, e.g. mueval for something simple, and/or http://hackage.haskell.org/package/restricted%2Dworkers for a more industrial-strength solution
06:57:23 <dmwit> You should be able to test documentation generation locally. So if all you want to know is if it links correctly, do that.
06:57:26 <Kron> well yesterday people told me to wait several days
06:57:27 <merijn> Kron: Oh, did you pick "package candidate"?
06:57:30 <Kron> yes i did
06:57:33 <merijn> Kron: Not sure it generates docs for that?
06:57:35 <bennofs> byorgey: it's not yet build: http://hackage.haskell.org/package/QuadTree-0.10.0/candidate/reports/
06:57:35 <Kron> ...
06:57:37 <dmwit> Of course that won't help with checking that Hackage managed to build your documentation, and that can be frustrating.
06:57:38 <merijn> Kron: But, despair not!
06:57:47 <merijn> Kron: http://fuuzetsu.co.uk/blog/posts/2014-01-06-Fix-your-Hackage-documentation.html
06:57:48 <Kron> there's no way to test your package without permanently publishing it?
06:57:49 <dmwit> But if Hackage succeeds, and you succeed, the documentation should be essentially the same.
06:57:51 <PudgePacket> I'm trying to make a prettyPrint func for my datatype but i'm not understanding how to use it like a list yet http://lpaste.net/101336
06:57:57 <Kron> I don't like this system very much
06:58:04 <dmwit> Kron: Yes, just ask for local documentation...
06:58:07 <merijn> Kron: That lets you generate local docs that link to hackage docs external
06:58:15 <Kron> I already generated local docs
06:58:16 <bennofs> Kron: I think the "safest" way is to upload your own docs to hackage ...
06:58:21 <merijn> dmwit: She wants to check whether they properly link to external docs
06:58:22 <Kron> but i make a lot of links to Prelude and Foldable
06:58:25 <Kron> and Data.List
06:58:30 <Kron> how do I upload my own docs?
06:58:59 <danilo2> Hello! I'm also very interested in the zgredzik's question : yesterday I cleaned up all the haskell packages from my system and when trying to install cuda package I'm getting error "Foreign/CUDA/Driver/Utils.chs:35:23: Illegal type signature: `IO (Status, Int) cuDriverGetVersion'" Does anybody knows what the error is connected to? :)
06:59:06 <bennofs> I don't know. I only know that it's possible :=
06:59:06 <merijn> Kron: That blog post shows has links to scripts for uploading your own docs and making sure they link to the proper external hackage docs :)
06:59:10 <byorgey> Kron: see http://hackage.haskell.org/api, look at the  documentation-core section
06:59:12 <Kron> awesome
06:59:14 <Kron> thanks
06:59:21 <Kron> I'll try that
06:59:25 <Kron> anyway, have to run
06:59:42 <merijn> I've been thinking of building that script on Fuuzetsu's blog into cabal, but I'm still to intimidated by the cabal source
07:01:19 <byorgey> danilo2: sounds like some bogus code being generated by hsc2hs, maybe you need a newer version?   I'm not really sure
07:01:43 <byorgey> danilo2: did you recently upgrade GHC?
07:01:48 <bennofs> Does hackagebot also show candidate uploads?
07:02:49 <danilo2> byorgey: hmmm, I did not. its ghc-7.6.3. As far as I know hsc2hs is shipped with ghc, so it should not be the case, am I correct? Or maybe are you talking about c2hs?
07:06:30 <danilo2> byorgey: Thank you VERY much! you solved the problem! (not directly, but you did) - so 2 days ago c2hs was upgraded - after downgrading it, it works - I'll file a bug there :) thank you!
07:06:37 <byorgey> =D
07:07:55 * byorgey feels like Super Grover, who bumbles around trying to be helpful until whoever he is trying to help solves their own problem
07:09:28 <danilo2> byorgey: I filled a bug here: https://github.com/haskell/c2hs/issues/69 . Than kyou once again Super Grover! :D
07:10:20 <SuperGrover> all in a day's work for your favorite neighborhood fuzzy blue superhero!
07:10:32 * SuperGrover flies off dramatically, and crashes into a lamp post
07:10:44 <hpc> oh no! president supergrover are you alright?
07:10:57 <danilo2> SuperGrover: you made my day :D
07:11:07 <merijn> SuperGrover: Isn't grover green?
07:11:15 <zgredzik> lol
07:11:30 <merijn> Oh, wait, no
07:11:36 <merijn> I'm confused with the wrong one
07:11:37 <PudgePacket> If i have a type "data Tree = Leaf Text | Branch [Tree] deriving (Eq, Ord, Show, Read)" why can't i call "head" on a Branch ?
07:12:03 <Eduard_Munteanu> PudgePacket: head works on lists, so you'll have to unpack it from Branch first
07:12:36 <merijn> PudgePacket: Why would you expect head to work on Tree?
07:12:42 <merijn> :t head
07:12:43 <lambdabot> [a] -> a
07:12:49 <merijn> Tree is not a list
07:12:54 <PudgePacket> Branch is just a list
07:12:58 <merijn> No
07:13:06 <merijn> Branch is constructor for Tree
07:13:10 <hpc> PudgePacket: in (Branch ls), ls is a list
07:13:58 <michaelt> dcoutts_: I managed a pipe from Builder to ByteString following the model of one of the functions in Data.ByteString.Builder.Internal https://github.com/michaelt/pipes-builder-shabby/blob/master/Pipes/Builder/Shabby.hs
07:14:12 <benzrf> PudgePacket: you could make lenses and then use over
07:14:18 <benzrf> *prisms actually
07:14:30 <benzrf> :t over
07:14:31 <lambdabot> Profunctor p => Setting p s t a b -> p a b -> s -> t
07:14:44 <benzrf> oh hmm no
07:14:49 <benzrf> i want view, derp
07:14:54 <benzrf> no wait
07:14:56 <benzrf> bluh w/e
07:15:24 <benzrf> :t Prism' a s -> (s -> b) -> a -> Maybe b
07:15:25 <lambdabot> parse error on input `->'
07:15:28 <benzrf> @hoogle Prism' a s -> (s -> b) -> a -> Maybe b
07:15:28 <PudgePacket> So i'm unpacking it, now prettyTree won't work on the last line on the rest of the list
07:15:28 <lambdabot> Warning: Unknown type Prism'
07:15:29 <lambdabot> No results found
07:15:29 <PudgePacket> http://lpaste.net/101337
07:15:32 <benzrf> bah
07:17:24 <thebnq> PudgePacket: because its a list of Tree, the function only accepts Tree
07:18:29 <merijn> PudgePacket: Which book are you reading? You seem to be pretty fundamentally confused about what you're doing
07:19:10 <PudgePacket> :) none in particular, perhaps that's why
07:19:34 <merijn> PudgePacket: You may want to have a look at Learn You a Haskell or Real World Haskell
07:19:37 <merijn> @where lyah
07:19:37 <lambdabot> http://www.learnyouahaskell.com/
07:19:38 <benzrf> is there a way to get an unordered pair in haskell
07:19:40 <merijn> @where rwh
07:19:40 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
07:19:42 <benzrf> besides using sets
07:19:55 <benzrf> im doing a thing with undirected graphs
07:19:55 <benzrf> :u
07:19:57 <PudgePacket> would this fix it thebnq? prettyTree (Branch (x:xs)) = prettyTree x ++ (map prettyTree xs)
07:20:59 <thebnq> PudgePacket: closer to something, but you're trying to combine a string to a list of strings, you need to combine them too
07:21:38 <benzrf> halp :I
07:22:55 <merijn> benzrf: So you want to represent edges as unordered pairs?
07:23:39 <benzrf> yeshuah__:
07:23:40 <benzrf> *yes
07:24:10 <jmcarthur> benzrf: why besides using sets?
07:24:14 <benzrf> well
07:24:17 <benzrf> it seems like overkill -.-
07:24:24 <benzrf> besides i want to indicate in the type that it's 2-element
07:24:26 <merijn> benzrf: Well, why not just have two entries per edge?
07:24:31 <benzrf> merijn: hmm?
07:24:38 <merijn> (1,2) and (2,1)
07:24:38 <benzrf> oh i guess i could do that
07:24:40 <jmcarthur> you could represent unordered pairs as ordered pairs and just hide their representation
07:24:47 <benzrf> that feels icky thorkilnaur
07:24:49 <benzrf> *tho
07:24:51 <benzrf> >_>
07:24:54 <merijn> Or just go with an adjacency list
07:25:13 <benzrf> erm
07:25:13 <thebnq> or matrix if its not sparse :]
07:25:15 <benzrf> ok
07:25:21 <benzrf> i dont know matrices -.-
07:26:03 <merijn> benzrf: What's your graph size and what do you need compute on them?
07:26:04 <benzrf> ok ill just do an adjacency list :I
07:26:08 <benzrf> it seems fine
07:26:13 <benzrf> even appropriate for what i have o.o
07:27:48 <benzrf> ugh
07:27:59 <benzrf> im gonna have to arbitrarily number nodes for id purposes arent i
07:28:10 <benzrf> well
07:28:17 <benzrf> i guess i could try to do some kind of recursive ds
07:28:36 <benzrf> but no, id still need to give them ids to make em identifiable
07:28:43 <benzrf> i shouldve done this in ruby or something
07:28:50 <benzrf> where objects inherently have identity
07:28:51 <benzrf> o.o
07:30:36 <merijn> benzrf: I don't know of graph representation that don't require arbitrary unique ids for nodes
07:30:51 <Eduard_Munteanu> benzrf: you could use a Map and/or only store the lower/upper triangle of the matrix
07:30:55 <merijn> benzrf: Sure, but then your performance would suck :p
07:32:02 <Eduard_Munteanu> benzrf: that is, only lookup (m, n) for m <= n
07:32:34 <ZWJ> how to hide typeclass instances from an imported module?
07:33:11 <hpc> you don't
07:33:30 <mniip> How can I say that if type 'a' is an instance of 'SomeClass', then it's an instance of 'MyClass' too?
07:33:35 <mniip> instance (SomeClass a) => MyClass a where -- does not work
07:33:58 <merijn> mniip: Well, that does work, but probably doesn't do what you want/expect :)
07:34:07 <hpc> mniip: you need to turn on overlapping instances for that to work
07:34:08 <Eduard_Munteanu> mniip: that's generally not a good idea because it overlaps more specific instances
07:34:14 <hpc> and what merijn says
07:34:16 <mniip> merijn, compilation error is totally not what I expect
07:34:31 <Eduard_Munteanu> mniip: you should generally use a newtype for these cases
07:34:48 <hpc> mniip: you should also look at how Functor and Applicative do it
07:34:52 <Eduard_Munteanu> Unless your typeclass is merely for typelevel trickery.
07:35:12 <ZWJ> is there any way to hide class instances from an imported module?
07:35:15 <mniip> Eduard_Munteanu, I guess that is the case
07:35:32 <Eduard_Munteanu> newtype FromFoo a = FromFoo a    instance Foo a => Bar (FromFoo a)
07:35:54 <Eduard_Munteanu> mniip: what exactly is it?
07:36:04 <supki> ZWJ: no
07:36:19 <ZWJ> oh so i have to wrap it into a newtype?
07:36:34 <supki> "it"?
07:36:53 <ZWJ> the type i want my own class instance for
07:36:58 * hackagebot wai-handler-webkit 2.0.0.1 - Turn WAI applications into standalone GUIs using QtWebkit.  http://hackage.haskell.org/package/wai-handler-webkit-2.0.0.1 (MichaelSnoyman)
07:36:59 <supki> yes
07:37:00 * hackagebot servius 1.1.1.1 - Serve Shakespearean templates via Warp  http://hackage.haskell.org/package/servius-1.1.1.1 (MichaelSnoyman)
07:37:08 <Eduard_Munteanu> ZWJ: different instances in different contexts aren't quite sound
07:37:37 <benzrf> hmm
07:38:02 <ZWJ> in my case they are: i want to pretty print on in my own way
07:38:11 <benzrf> @hoogle (a1 -> b -> c) -> (a0 -> a1) -> (a0 -> b -> c)
07:38:12 <lambdabot> Data.Function on :: (b -> b -> c) -> (a -> b) -> a -> a -> c
07:38:12 <lambdabot> Data.Data gmapQr :: Data a => (r' -> r -> r) -> r -> (forall d. Data d => d -> r') -> a -> r
07:38:12 <lambdabot> Data.Data gmapQl :: Data a => (r -> r' -> r) -> r -> (forall d. Data d => d -> r') -> a -> r
07:38:42 <benzrf> :t (<*>) `asAppliedTo` (undefined :: a -> b -> c)
07:38:43 <lambdabot> (a -> b -> c) -> (a -> b) -> a -> c
07:38:52 <benzrf> :I
07:39:25 <Kron> what're you looking for?
07:39:27 <Eduard_Munteanu> benzrf: is there something confusing in there?
07:39:29 <benzrf> @pl \s v -> insert (f s) v
07:39:29 <lambdabot> insert . f
07:39:37 * benzrf headdesks
07:39:42 <benzrf> derp derp derp
07:41:04 <ZWJ> Eduard_Munteanu, is there any trick i could use to avoid the newtype wrapping? language extensions...?
07:41:30 <merijn> ZWJ: No, as doing so would break tons of code in subtle way
07:41:59 * hackagebot wai-handler-devel 2.0.0.1 - WAI server that automatically reloads code after modification.  http://hackage.haskell.org/package/wai-handler-devel-2.0.0.1 (MichaelSnoyman)
07:42:17 <PudgePacket> I got my prettyTree working, it took a second function but it works haha
07:42:57 <PudgePacket> Could this be done better? http://lpaste.net/101338
07:43:56 <ZWJ> ty merijn
07:44:21 <Kron> you can replace x:[] with [x]
07:44:30 <peteretep> PudgePacket: Maybe I'm being slow, but I don't see why you need prettyTrees
07:45:06 <PudgePacket> How would you replace it ?
07:45:09 <merijn> ZWJ: For example, suppose you could replace the Ord instance for Char
07:45:12 <quicksilver> I think he's trying to avoid "pointlessly" repacking into a Branch to recurse.
07:45:20 <Kron> prettyTrees [x] = prettyTree x
07:45:21 <Kron> etc.
07:45:26 <merijn> ZWJ: Now a library returns a "Map Char Int" to you
07:45:45 <merijn> ZWJ: However, the library used the NORMAL Ord instance of Char, while your code uses a different one
07:45:47 <quicksilver> PudgePacket: there is duplication between prettyTrees and prettyTree
07:45:50 <ZWJ> merijn, i would be very happy if could replace it in the context of my module
07:45:59 <merijn> ZWJ: Now the ordering of your the Map is completely wrong
07:46:08 <quicksilver> PudgePacket: you can just say "prettyTree (Branch xs) = prettyTrees xs"
07:46:24 <Twey> PudgePacket: http://lpaste.net/101338
07:46:29 <merijn> ZWJ: That's not possible, because you can't guarantee anything sensible about values you get from/return to other modules code if you could do that
07:47:11 <Kron> Twey: ... does that work?
07:47:12 <Twey> PudgePacket: In fact, http://lpaste.net/7329898492816523264
07:47:18 <Kron> you're calling prettyTree on a list
07:47:25 <Kron> prettyTree is defined on Trees
07:47:29 <Twey> Kron: No I'm not
07:47:30 <peteretep> http://lpaste.net/101338
07:47:42 <peteretep> PudgePacket: ^^ something like that?
07:48:01 <Kron> oh wait
07:48:01 <Kron> list of trees
07:48:01 <Kron> right
07:48:13 <Twey> Kron: I did use msum instead of mconcat, though.  Fixed in the edit ☺
07:49:10 <benj_> do you really need the case for (Branch []), or is the monoid identity used by mconcat something other than (pack "") ?
07:49:27 <Twey> benj_: Fixed that in the edit, too
07:49:37 <Twey> But lpaste decided to put it in a different paste for some reason
07:50:43 <PudgePacket> Thanks for your help guys, mconcat looks cool by reducing the code by a ton but I don't understand it. peteretep's response looks ok and makes sense to me
07:51:05 <Twey> PudgePacket: mconcat just joins a bunch of things together
07:51:16 <peteretep> "just"
07:51:18 <Twey> Nothing fancy
07:51:36 <peteretep> PudgePacket: I am willing to explain mconcat to you. It is, as Twey says, actually pretty simple
07:52:10 <PudgePacket> If you're willing :) i'll listen and try to understand
07:52:13 <Twey> PudgePacket: The Right Way to do this, though, is to define Foldable and Traversable instances for your data-type
07:52:46 <peteretep> PudgePacket: If you think of the set of integers, the + operation, and the number 0
07:53:03 <Twey> Actually, that basically is foldMap
07:53:05 <peteretep> PudgePacket: Any two integers you perform the operation on return another integer
07:53:14 <peteretep> PudgePacket: And any integer you add 0 to stays as the same integer
07:53:16 <peteretep> PudgePacket: right?
07:53:41 <PudgePacket> yup
07:54:11 <peteretep> Those three things: a set, an operation on two items of that set that reutrn another member of the set, and an 'identity' element, are called a monoid
07:54:27 <PudgePacket> it sounds really similar to a fold
07:54:29 <peteretep> Examples: Int, 1, *
07:54:33 <peteretep> Int, 0, +
07:54:51 <peteretep> PudgePacket: right
07:55:07 <peteretep> PudgePacket: What's the identity element for appending strings?
07:55:14 <PudgePacket> ""
07:56:05 <peteretep> PudgePacket: So if your data type is declared as a monoid, that means it has defined the identity element, and the way to join those things
07:56:36 <peteretep> PudgePacket: Which means you know what a base element and the folding function would look like already
07:56:52 <peteretep> So rather than: foldr ++ ""
07:57:03 <peteretep> You can just say: mconcat
07:57:35 <PudgePacket> wow, so mconcat infers the identity element and concat operation based on type?
07:57:56 <tdammers> PudgePacket: yes. That's how typeclasses work in general.
07:58:35 <PudgePacket> damn, that's cool
07:58:39 <peteretep> PudgePacket: In order to say that it's a type that mconcat works on, the instance of the type for that typeclass needs to specify what those are
07:59:08 <PudgePacket> right, so string implements the monoid typeclass?
07:59:12 * peteretep loves explaining things he only half understands
07:59:15 <benj_> :t mconcat
07:59:16 <lambdabot> Monoid a => [a] -> a
07:59:25 <benzrf> monoids r fun
07:59:28 <benzrf> PudgePacket: no, list does
07:59:31 <benzrf> PudgePacket: strings are just lists
07:59:34 <benzrf> :t "foo"
07:59:35 <lambdabot> [Char]
08:01:06 <benj_> this is not the case for Text, though. Text is not just a List, so there is a Monoid instance for Text
08:01:18 <peteretep> benj_: I am trying to find that definition, and cannot
08:01:24 <peteretep> benj_: Where's it definted?
08:01:40 <tdammers> Data.Text.Internal, maybe?
08:01:42 <benj_> peteretep, in Data.Text
08:01:44 <tdammers> or just Data.Text
08:01:45 <peteretep> of course
08:01:47 <peteretep> thanks
08:02:02 <PudgePacket> man, all of the types and typeclasses fit so nicely, it's a bit crazy
08:02:15 <tdammers> also, haddock documentation on hackage tends to link to the source code
08:02:20 <Twey> PudgePacket: We actually have a typeclass for exactly the operation you're implementing
08:02:27 <Twey> PudgePacket: It's called ‘Foldable’
08:02:35 <Twey> PudgePacket: Here's an instance: http://lpaste.net/101342
08:02:50 <Eduard_Munteanu> ZWJ: if your data structure is a Functor you could use fmap to wrap the values into a newtype
08:02:54 <Twey> PudgePacket: (note that I've had to abstract the type of the value in the leaves out)
08:03:40 <peteretep> instance Show Tree where show = prettyTree
08:03:45 <Twey> PudgePacket: Then your prettyTree just becomes foldMap id
08:04:19 <Twey> (‘the data inside the tree is already a monoid [Text] so you don't have to do anything to transform it into a monoid’)
08:04:36 <benj_> peteretep, usually show and "pretty print" are different things
08:04:48 <quicksilver> Twey: "foldMap id" is spelt "fold" isn't it?
08:04:48 <Twey> peteretep: Yeah, this is not a good Show instance
08:04:53 <PudgePacket> in this line "prettyTree = foldMap id" what is id and where did it come from?
08:04:53 <benj_> I don't think this prettyTree would be a suitable show, since it is lossy
08:05:18 <Twey> quicksilver: Yep
08:05:21 <peteretep> benj_: probably right, but I thougt it played on the typeclass theme nicely
08:05:34 <Twey> quicksilver: I thought it would be more obvious without it, though
08:05:36 <peteretep> PudgePacket: id stands for idiot, because it's a function that just repeats whatever you say to it
08:06:01 <benj_> oh here we go into the forest of combinatory birds ;)
08:06:02 <PudgePacket> I can't tell if you're serious or not...
08:06:07 * Twey annotates more
08:06:14 <peteretep> PudgePacket: I am serious, but other people call it 'identity'
08:06:23 <PudgePacket> is it defined in prelude?
08:06:24 <peteretep> PudgePacket: consider: map id [1..5]
08:06:26 <Twey> > id 3
08:06:27 <lambdabot>  3
08:06:30 <Twey> > id "hello"
08:06:31 <lambdabot>  "hello"
08:06:34 <peteretep> > map id [1..5]
08:06:35 <lambdabot>  [1,2,3,4,5]
08:06:44 <peteretep> benj_: :-)
08:06:50 <Twey> PudgePacket: id x = x
08:07:04 <PudgePacket> well... that's handy i guess
08:07:29 <peteretep> PudgePacket: it comes in useful later
08:08:30 <peteretep> PudgePacket: `id` in Twey's example is Text->Text; you could try using (++"!") instead and see what it did
08:09:27 <Twey> PudgePacket: It's useful when you have to apply a function, but don't actually want to change anything.
08:10:08 <Twey> PudgePacket: As quicksilver pointed out, I could instead have just said ‘prettyTree = fold’, which is the same thing (fold = foldMap id)
08:10:08 <merijn> PudgePacket: id exists exactly for scenarios like "foldMap id"
08:10:42 <ZWJ> Eduard_Munteanu, unfortunately its theres no functor for it, can you explain me how to derive one? because im not capable to so atm
08:11:02 <Eduard_Munteanu> ZWJ: what is the datatype?
08:12:02 * hackagebot resourcet 0.4.10.1 - Deterministic allocation and freeing of scarce resources.  http://hackage.haskell.org/package/resourcet-0.4.10.1 (MichaelSnoyman)
08:12:39 <ZWJ> http://co-dan.github.io/ghc-docs/StgSyn.htm
08:12:54 <ZWJ> the StgExpr type
08:13:03 <peteretep> that needs an l on the end
08:13:31 <Eduard_Munteanu> ZWJ: that link seems broken
08:14:30 <Twey> ZWJ: StgExpr isn't a valid functor… StgExpr bndr could be, maybe
08:14:53 <Twey> Oh, beg your pardon
08:15:06 <Twey> type StgExpr = GenStgExpr Id Id, which definitely can't be
08:15:21 <ZWJ> how peteretep said theres an l on the end missing
08:17:14 <ZWJ> Twey, i would have to write  a function from hand to map over the Ids in StgExpr?
08:18:36 <Twey> ZWJ: There are two different kinds of ‘Id’ in StgExpr
08:19:41 <Twey> ZWJ: And StgExpr itself is a type synonym for GenStgExpr Id Id
08:19:58 <Twey> StgExpr has no type parameters, so you can write a Monofunctor instance but I don't advise it
08:20:07 <ZWJ> whats a monofunctor?
08:20:19 <Twey> ZWJ: Alternatively, you can work with GenStgExpr, and write a functor over one of them (instance GenStgExpr bndr where …), or you could write a bifunctor over both (instance Bifunctor GenStgExpr where …)
08:20:30 <Twey> ZWJ: A monofunctor is like a functor, but has no type parameter
08:20:41 <Twey> E.G. Text is a monofunctor (over Char)
08:20:42 <Kron> cabal's giving me an error: "File name does not match module name, saw Quadtree and expected Data.Quadtree"
08:20:51 <Kron> so do I need to rename it Data.QuadTree.hs?
08:20:59 <Kron> in Data? Data/Data.QuadTree.hs
08:21:16 <Twey> Kron: No, you put it in Data/Quadtree.hs but called it Quadtree
08:21:24 <Kron> I already did
08:21:32 <Twey> Kron: Cabal expected the module there to be called Data.Quadtree, not Quadtree
08:21:42 <Kron> ah
08:21:48 <Kron> module Data.QuadTree where, etc?
08:21:51 <Twey> Right
08:21:57 <Kron> thanks!
08:21:58 <PudgePacket> I DCed a bit ago but I saved the code you guys sent me and the log of our convo, I have to go now but thanks for your time and help explaining monoids etc :)
08:22:11 <Twey> That ‘put’ was supposed to be past tense.  Sorry about English.
08:22:22 <Twey> PudgePacket: o/
08:24:42 <favetelinguis> cabal fails to install tasty, how can i find the error (newbie)
08:24:46 <Kron> merijn: when I cabal haddock is it supposed to generate many "cannot find link destinations" errors?
08:25:14 <merijn> Kron: No
08:25:25 <Kron> hrngh
08:25:27 <Kron> okay
08:25:28 <geekosaur> it will do that if you do not have haddocks for dependencies
08:25:44 <merijn> Kron: Did you look at the bash script linked from that blogpost?
08:26:04 <Kron> no I haven't
08:26:07 <Kron> trying to do it manually
08:26:08 <merijn> Kron: Also, you may want to enable "Documentation: True" in ~/.cabal/config
08:26:25 <merijn> Kron: It's like 10 lines, you can just look at it too see what to do
08:26:50 <merijn> (and while you're at it, add "library-profiling: True")
08:26:59 <Kron> what does that do?
08:27:17 <Kron> library profiling doesn't exist
08:27:26 <merijn> Kron: The first enables always building docs, the latter always builds profiling versions
08:27:43 <merijn> Otherwise 2 months from now you'll want to profile something and need to reinstall *all* libraries
08:27:46 <merijn> Kron: https://gist.github.com/Fuuzetsu/8276421
08:28:16 <merijn> The curl stuff attempts to upload the docs to hackage too
08:28:29 <Kron> is there a way to just upload a package candidate?
08:28:32 <Kron> with documentation?
08:29:01 <merijn> I dunno
08:29:11 <merijn> I recommend trying at #hackage :)
08:29:23 <merijn> Kron: Hackage 2.0 is still kinda new and work in progress
08:29:26 <Kron> bleh, I have to go now
08:29:33 <Kron> thanks for your help merijn
08:29:39 <merijn> np
08:30:46 <ZWJ> Twey, merijn Eduard_Munteanu , thank you for helping me
08:31:40 <Twey> ZWJ: No problem
08:32:06 <ZWJ> ill manually write a bifuntor now
08:36:21 <gspr> Suppose v is either the storable or the unboxed vector type. Is there a function  f :: v CDouble -> v Double  that is O(1) on implementations where the Double and CDouble coincide? (Correct me if I'm wrong, but this is at least the case for GHC and GCC on Linux x86, right?)
08:36:45 <gspr> (Obviously, I'm asking for a conversion function f, not just "a function" :P )
08:40:19 <ion> gspr: See if coerce :: v CDouble -> v Double in GHC 7.8
08:41:50 <joelteon> so there's no builtin cabal conditional for whether tests are enabled
08:41:55 <gspr> ion: Interesting! Can't seem to find the docs though...
08:42:05 <ion> gspr: https://www.fpcomplete.com/hoogle?q=coerce&env=ghc-7.8-unstable
08:42:12 <gspr> ion: Thanks
08:44:00 <gspr> ion: Wow, this seems really neat. I think it'll simplify a lot of FFI stuff..
08:44:12 <gspr> It'll be in 7.8?
08:44:27 <ion> Yeah, you can download and install the release candidate.
08:45:04 <gspr> ion: Would one normally use rule pragmas to support platforms where v CDouble and v Double are not identical?
08:45:47 <gspr> (I don't even know if such platforms exists, but I guess it's pretty clearly allowed by the report...)
08:45:51 <gspr> *exist
08:46:14 <ion> I don’t know what the best way is in the absence of coerce.
08:46:54 <gspr> ion: No, I mean in the presence of coerce. To still handle cases where there is no  Instance Coercible (v CDouble) (v Double)
08:47:07 * hackagebot cron 0.2.0 - Cron datatypes and Attoparsec parser  http://hackage.haskell.org/package/cron-0.2.0 (MichaelXavier)
08:47:40 <ion> gspr: Oh, CPP and #ifdefs along with a cabal flag probably.
08:47:53 <gspr> ion: Barf. But ok, that makes sense :)
08:48:05 <gspr> ion: Thanks a bunch :)
08:48:50 <gspr> This is really great :)
08:48:50 <ion> np
08:49:11 <Peaker> Does anyone know why a custom Setup.hs in a .cabal package would cause --enable-*-profiling to be ignored?
08:49:26 <Peaker> the custom setup just does: main = defaultMainWithHooks simpleUserHooks { preBuild = \_ _ -> do ... }
08:50:01 <rpglover64> I'm having trouble getting Emacs set up (following this tutorial: http://tim.dysinger.net/posts/2014-02-18-haskell-with-emacs.html); in particular, I'm getting "haskell-process-start: cl-ecase failed: cabal-repl, (ghci quote cabal-ghci quote cabal-dev quote)" as an error when I try to load the interpreter via "C-c C-l".
08:50:02 <Fuuzetsu> Kron: yes, you can upload a candidate with docs
08:50:22 <gspr> ion: Do you, by the way, know if there is a document anywhere that specified when GHC's haskell types are identical to their C counterparts?
08:50:28 <gspr> *specifies
08:50:38 <Kron> Fuuzetsu: alright, thanks
08:50:39 <Fuuzetsu> Kron: there's also a script at https://gist.github.com/stbuehler/7068764 which does a better job at making the docs although you might need to fight with it a bit to get it running
08:50:55 <Kron> fighting is something I'm used to at this point :P
08:50:56 <Fuuzetsu> (my gist makes some pages broken IIRC)
08:51:08 <Kron> thank you very much for your blog post
08:51:21 <Fuuzetsu> np
08:51:36 <Fuuzetsu> by the way, I closed your Haddock bug as invalid, if anything it's a documentation bug on our end
08:51:55 <Fuuzetsu> parse failures are bugs iff it's a failure on the documentation string rather than the comment location
08:52:05 <ion> gspr: Sorry, i don’t know.
08:53:17 <Kron> Fuuzetsu: speaking of haddock issues
08:53:25 <Kron> is show-extension not a valid option for HADDOCK_OPTIONS?
08:53:34 <Kron> it was listed in the haddock documentation but my haddock can't recognize it
08:53:39 <Kron> *show-extensions
08:53:53 <Peaker> oh, I see even a Setup.hs that only does "main = defaultMain" with "Custom" setup type in .cabal prevents profiling from working (Cabal 1.16.0)
08:54:52 <stbuehler> Fuuzetsu: my script is perfect, why would you need to fight with it? :) (improvements are welcome ofc)
08:55:49 <Peaker> wow, ghc is at 200% cpu for quite a while when building Distribution.PackageDescription
08:56:15 <hpc> documentation is webscale
08:56:55 <Peaker> some of the "deriving" clauses drive GHC to take insane amounts of compute time
08:57:02 <Peaker> (e.g: deriving Read/Show on large records)
08:58:05 <Fuuzetsu> stbuehler: it didn't work for me for some reason IIRC
08:58:15 <Fuuzetsu> also it requires some weird configuration or something
08:58:42 <Peaker> ok, seems like "cabal-install" was the culprit. If I build and call the custom Setup.hs manually, it does build with profiling
08:58:44 <Fuuzetsu> Kron: It is a valid option but perhaps your Haddock is too old?
08:58:50 <Kron> ah
08:58:52 <Peaker> checking the newest cabal-install
08:58:53 <Kron> how would I update?
08:59:17 <Kron> I have 2.13.2.1
08:59:42 <Fuuzetsu> no idea, I think the standard is to get the version that comes with GHCs; we're releasing 2.14.x with GHC 7.8 which will have the change
08:59:48 <Fuuzetsu> I'm pretty sure the RCs have it
09:00:18 <Fuuzetsu> (new Haddock versions require new GHC versions)
09:01:37 <c_wraith> is haddock distributed with GHC?  I guess I've never installed it manually.  Huh.  I never even thought of that.
09:04:15 <haasn> c_wraith: yes, under “utils”
09:05:08 <yesthisisuser> I have been looking at Erlang a bit and I am wondering how difficult it would be to implement something similar in Haskell. I was looking at the Haskell Cloud project but it looks like it goes even beyond what Erlang does
09:05:36 <yesthisisuser> I am, of course, talking about the capabilities of the Erlang/OTP runtime.. and not about the language itself
09:06:32 <ion> Distributed-process has Erlang-like primitives and you probably could implement the equivalent of OTP on top of it as it is now.
09:06:58 <yesthisisuser> And wouldn't it be equivalent to use something like AMQP for message passing
09:08:11 <Shammah_> quchen, I figured the foldMap out for monoids yesterday: http://lpaste.net/101347 :)
09:08:26 <Shammah_> I forgot I had to convert to a monoid using Data.Monoid.Sum
09:11:15 <merijn> Peaker: are you building profiled versions too?
09:11:22 <yesthisisuser> ion: yes it looks like it. but i still wonder what would be the disadvantage of using something like AMQP and RabbitMQ for message passing
09:11:32 <merijn> Peaker: I've had trouble with GHC dying on profiled code due to OOM
09:12:54 <yesthisisuser> since RabbitMQ is used a lot by Erlangers - that would suggest there is something missing in their own message passing framework.. hehe
09:13:11 <gwz> hey, how would I add two integers to a list in haskell?
09:13:37 <jmcarthur> > 4 : 5 : [6,7,8,9]
09:13:38 <lambdabot>  [4,5,6,7,8,9]
09:13:41 <isaacbw> does anyone know of good reference material for implementing proper tail calls in a language? I don't need anything as powerful as what haskell's got, just something like scheme
09:13:45 <ion> gwz: You can insert to the front with (:). If you want to append to the end you probably shouldn’t be using a list.
09:13:48 <gwz> 4 : 5 : [] would work too I guess?
09:14:05 <jmcarthur> > 4 : 5 : []
09:14:06 <lambdabot>  [4,5]
09:14:15 <gwz> thank you
09:15:06 <isaacbw> I'm thinking of creating a js->js compiler (for fun) that implements tco
09:15:27 <jmcarthur> isaacbw: i'm not sure i understand in what way you believe tail calls in haskell are more powerful than in scheme
09:15:46 <Platz> saw a tweet about purescript last night; it looks pretty awesome; you can actually read the js it generates
09:16:10 <isaacbw> jmcarthur: I was under the impression that haskell did transformations to turn all recursive forms into tail call forms, and then did tco
09:16:30 <jmcarthur> no, it does not
09:16:40 <isaacbw> I have an academic PL friend who told me that kind of tranformation is possible
09:16:45 <jmcarthur> > let f x = 1 + f (x-1) in f 1000000
09:16:46 <lambdabot>  *Exception: stack overflow
09:17:17 <Platz> isaacbw: I suppose you could turn everything into a continuation-passing mess
09:17:21 <jmcarthur> isaacbw: there are many cases in haskell where a non tail recursive function is preferable to a tail recursive one
09:17:27 <jmcarthur> isaacbw: that may be what you are thinking
09:17:33 <jmcarthur> isaacbw: but it's still non tail recursive
09:18:10 <jmcarthur> > let f n = if n <= 0 then [] else True : f (n-1) in f 1000000    -- for example
09:18:12 <lambdabot>  [True,True,True,True,True,True,True,True,True,True,True,True,True,True,True,...
09:18:34 <jmcarthur> isaacbw: ^^ the list can be generated lazily in part due to the non tail recursion
09:18:49 <isaacbw> jmcarthur: I see
09:18:58 <c_wraith> GHC *does* do TCO, though.  It converts any tail call into just executing the function, rather than using a stack.
09:19:04 <isaacbw> in that case, is there any good reference material that you can recommend on scheme and/*or* haskell tco?
09:19:05 <jmcarthur> isaacbw: if it was tail recursive, you would have to build the list from the bottom up
09:19:13 <c_wraith> It just doesn't try to convert things into tail calls
09:19:39 <ElectroStatik> hello
09:19:52 <jmcarthur> right. we have tail recursion. it's just not special in any way. (in fact, i would say that tail recursion in haskell has some bad subtlety sometimes)
09:20:10 <ElectroStatik> can someone refer me to the haskell documentation? I only have the link to the language report
09:20:22 <AndChat-522641> M
09:20:31 <kwantam> isaacbw, what level of reference are you talking about? Doesn't Lisp In Small Pieces have a section on TCO in one of the early implementations?
09:20:36 <c_wraith> ElectroStatik: what kind of documentation?
09:21:02 <isaacbw> kwantam: could do, I could probably also check sicp. I bet it has some material. Hmm...
09:21:07 <jmcarthur> when you write tail recursive functions you often will have accumulating parameters. if you forget to force them as you go, they will grow a lot, and if you evaluate it later you might even fill up the stack, which is exactly what you may have been trying to avoid by writing a tail recursive function in the first place!
09:21:31 <c_wraith> ElectroStatik: haskell has like 25 years of documentation in thousands of tutorials and academic papers.  What sort of thing are you looking for?
09:21:41 <AndChat-522641> bnb
09:21:45 <kwantam> surely sicp should, but it's not clear the level of detail. Even in the metacircular evaluator implementations I don't recall a ton of discussion on explicitly performing TCO. But it's been a long time...
09:21:55 <c_wraith> jmcarthur: not having TCO wouldn't make that better, though.
09:22:00 <merijn> ElectroStatik: You mean like books to learn?
09:22:13 <AndChat-522641> My
09:22:39 <jmcarthur> c_wraith: no. i just mean when you compare haskell's TCO to scheme's, haskell's is basically the same thing, except for its interaction with other features of haskell
09:24:07 <ElectroStatik> I don't understand this : can someone help?
09:24:11 <ElectroStatik> let notNull x = not (null x) in filter notNull [[1,2,3],[],[3,4,5],[2,2],[],[],[]]
09:24:28 <ElectroStatik> not ... in  ; I dont get
09:24:46 <t7> which part dont you understand ?
09:24:59 <tdammers> ElectroStatik: it's not `not ... in`, it's `let ... in`
09:25:24 <tdammers> let (notNull x = not (null x)) in (filter notNull)
09:25:27 <tdammers> that's how it groups
09:25:33 <tdammers> rather than:
09:25:47 <c_wraith> tdammers: might as well use valid syntax if you're goin to show that.  :P
09:25:49 <tdammers> let notNull x = (not (null x) in (filter notNull))
09:25:54 <tdammers> c_wraith: how?
09:25:57 <tdammers> oh wait
09:25:59 <tdammers> yeah
09:26:26 <ElectroStatik> ok
09:26:27 <t7> > let notNull x = not (null x) in filter notNull [[1,2,3],[],[3,4,5],[2,2],[],[],[]]
09:26:42 <ElectroStatik> so the let ... in does what?
09:26:48 <ElectroStatik> let defines a funciton
09:26:51 <t7> yeah
09:27:11 <c_wraith> let defines any bindings..  Function or simple value.
09:27:28 <c_wraith> let x = 5 in x + 7  evaluates to 12, for instance
09:27:34 <ElectroStatik> ok got that
09:27:36 <ElectroStatik> in ?
09:27:46 <jmcarthur> ElectroStatik: "let" defines a function to be used "in" the scope of the expression that follows
09:27:54 <kwantam> let x in y means first define an environment in which x, then evaluate y
09:28:03 <jmcarthur> ElectroStatik: (not just functions, by the way. any value)
09:28:05 <gspr> ElectroStatik: You might feel more comfortable writing your function definitions in a file and loading it in GHC. This way you can avoid let bindings at first
09:28:12 <gspr> *GHCi
09:28:45 <ElectroStatik> ah ok
09:29:12 <ElectroStatik> I think I got it now. We are binding a function to the first expression, then using it in the context of the next after in
09:29:31 <c_wraith> @where lyah
09:29:37 <lambdabot> http://www.learnyouahaskell.com/
09:29:43 <bbloom> does anybody know of any good "cheat sheets" for the notation of operational/denontational semantics and/or typing rules?
09:29:58 <c_wraith> ElectroStatik: Check out learn you a haskell as introductory material
09:30:02 <yesthisisuser__> let x = 5 in x + 1
09:30:29 <c_wraith> ElectroStatik: it covers the basic language constructs pretty well
09:31:33 <zerokarmaleft> bbloom: TAPL as a basis maybe? there doesn't seem to be overarching consistency in notation in my limited reading experience
09:34:08 <ElectroStatik> thanks to everyone who helped me out there. You guys are the best FP community on the net
09:37:13 * hackagebot plugins-multistage 0.4 - Dynamic linking for embedded DSLs with staged compilation  http://hackage.haskell.org/package/plugins-multistage-0.4 (AndersPersson)
09:38:45 <julianb>  /quit
09:39:40 <gwz_> hey how would I create a array of x by x which is initialized to 0
09:40:14 <monochrom> there is a notational consistency among operational semantics and type rules. the stuff above the horizontal line is a premise, the stuff below is a conclusion. :)
09:40:39 <dagle> Haskell documentation and color vs colours...
09:41:03 <dagle> I have seen the use of color and colour being used in the same sentence.
09:41:03 <bbloom> zerokarmaleft: thanks. kinda a bummer. i wish there was some kind of notation one-pager to give folks who are new to academic articles
09:41:30 <dagle> (and no, it was not speaking of different datastructures)
09:42:13 * hackagebot scottish 0.1.0.0 - scotty with batteries included  http://hackage.haskell.org/package/scottish-0.1.0.0 (echaozh)
09:42:45 <nicoo> bbloom: I wish there was consistent notation (which kinda is a prerequisite for such a one-pager)
09:43:32 <bbloom> nicoo: seems like modern stuff is much more consistent than it used to be
09:43:44 <bbloom> nicoo: reading older works always requires extra context
09:43:51 <pavonia> gwz_: Have you looked at Data.Array? I think newArray initializes all elements with a given value
09:45:09 <bitemyapp> bbloom: https://www.google.com/url?sa=t&rct=j&q=&esrc=s&source=web&cd=4&ved=0CEEQFjAD&url=http%3A%2F%2Fwww.cse.iitd.ernet.in%2F~sanjiva%2Fopsem.ps&ei=fSUnU8SVGZS42gX4qID4Cw&usg=AFQjCNHUqOYw4hJXvGubYxTsjJhV8Ko_qg&bvm=bv.62922401,d.b2I&cad=rja
09:46:15 <bbloom> bitemyapp: thanks. that's a useful N pager for which some cheat sheet would serve as a visual index
09:47:02 <zerokarmaleft> bitemyapp: nice find
09:47:24 <bbloom> the fundamental issue is one of "i don't know what to google for" when you see some notation
09:47:40 <bbloom> i don't need explainations, i just need a pictures => words to google for mapping to give to folks
09:48:01 <bbloom> although they will then surely need explainations after that :-)
09:48:49 <gwz_> so would something like this work, arrayVal <- newArray (1,15) 0
09:49:59 <pavonia> for a 1-dimensional array yes
09:50:47 <pavonia> gwz_: What is your use case?
09:51:12 <gwz_> need to build a 2d array and intialize it to some value
09:52:11 <pavonia> Sure, but why do you need an array? What are you programming?
09:52:40 <pavonia> Also, do you need a mutable or immutabel array?
09:52:58 <Peaker> merijn: I was trying to build a profiled version of my code with cabal 1.16.0, but I had a custom Setup.hs
09:53:02 <gwz_> well in the end, I was hoping to do some stuff to array using accumArray
09:53:07 <gwz_> not sure if it needs to immutable or muttable
09:53:15 <Peaker> merijn: apparently there was a bug in cabal-install that it didn't pass on the profiling options properly to the Setup.hs
09:53:19 <Peaker> merijn: trying newer cabal-install now
09:53:31 <gwz_> mutable arrays
09:54:13 <Peaker> hmm.. newest cabal-install still seems buggy
09:54:22 <pavonia> gwz_: What do you need it for?
09:54:36 <gwz_> iterating through it and getting some values
09:54:50 <merijn> gwz_: Why not a list?
09:54:57 <pavonia> Okay, I give up
09:55:01 <Peaker> I'll just use Setup.hs directly without "cabal" :(
09:55:40 <gwz_> its a requirement to use an array , If I had known it would be impossible to achieve this in haskell
09:55:52 <gwz_> I wouldnt have tried this
09:57:48 <c_wraith> gwz_: who said anything about impossible?  We said "what do you need to actually do?"
09:58:15 <gwz_> all I need is to initialize a 2d array and then changing it later and iterate through it after
09:58:55 <Peaker> does Ctrl-c send an asynchronous exception to the main thread?
09:59:04 <Zekka> Greetings. I've got a question long enough that I pastebinned it instead: http://pastebin.mozilla.org/4612217
09:59:06 <jmcarthur> gwz_: i think you need to give use more information
09:59:09 <jmcarthur> *us
09:59:10 <Peaker> will "mask" hold Ctrl-c for a bit?
09:59:29 <c_wraith> Peaker: indirectly, that's what it does.  And yes, it will.
09:59:38 <Peaker> c_wraith: cool, thanks :)
09:59:39 <jmcarthur> gwz_: you can do anything you want with arrays in haskell, but with more context we can tell you better ways of doing it
09:59:47 <gwz_> how would you define a 2d array in haskell with value of 0,  thats alll I need to know
10:00:11 <jmcarthur> it depends on how i want to use it
10:00:19 <jmcarthur> that's what i'm trying to get at
10:00:32 <c_wraith> gwz_: if that's all you want to know, you'd just look at the documentation.
10:00:53 <merijn> Zekka: Not currently possible, but 7.8 will have ViewPatterns, which may get you close
10:00:58 <Kron> alright, back
10:01:17 <Kron> Fuuzetsu: you said that package candidates have their documentation generated?
10:01:20 <merijn> oh, wait
10:01:22 <Zekka> merijn - Thanks. Can you think of any approaches that can approximate this? Otherwise I can just write it out for each constructor -- there's only like three or four.
10:01:25 <merijn> viewpatterns is the wrong name
10:01:38 <Saizan> gwz_: newArray works for 2d arrays too, you just need a different range for the indexes
10:01:44 <merijn> Zekka: I would just write them out in that case, it'll be easier and faster
10:01:58 <Zekka> merijn - Sounds like a plan, especially since there's one case where I can specialize one to perform an automatic conversion
10:02:06 <Fuuzetsu> Kron: I said you can upload docs for candidates
10:02:11 <Saizan> gwz_: like newArray ((0,0),(15,15)) 0
10:02:15 <Fuuzetsu> but I believe they get docs generated anyway
10:02:30 <Fuuzetsu> but it takes until the doc bot runs, just like with any other package
10:02:34 <Kron> it's been nearly 24 hours now, i'll try uploading myself
10:02:39 <c_wraith> gwz_: it sounds a lot more like you're asking "how do I implement this algorithm I won't tell you anything about efficiently", though, which is why we keep asking what it is you're trying to do..  So we can answer it.
10:02:45 <Fuuzetsu> Kron: check the log if there is one
10:02:53 <Kron> I couldn't find a log sadly
10:03:05 <Fuuzetsu> can you give me the link to the candidate?
10:03:16 <Kron> http://hackage.haskell.org/package/QuadTree-0.10.0/candidate
10:03:24 <gwz_> `newArray ((0,0),(15,15)) 0
10:03:31 <Kron> well I guess 24 hours is an exaggeration
10:03:34 <Kron> it's more like 17
10:03:57 <gwz_> > newArray ((0,0),(15,15)) 0
10:04:00 <lambdabot>  Not in scope: `newArray'
10:04:01 <Fuuzetsu> http://hackage.haskell.org/package/QuadTree-0.10.0/candidate/reports/ out of luck ;)
10:04:07 <Kron> yeah
10:04:11 <Fuuzetsu> you can try asking in #hackage
10:04:12 <Kron> not got much of that stuff
10:04:15 <jmcarthur> gwz_: we have a pattern where i work. whenever somebody comes up to a programmer and asks "How do I ...?" the programmer always answers "What do you *really* want to do?". the answer to that question almost always affects the answer to the original question.
10:04:25 <gwz_> > import Data.Array.IO
10:04:25 <Fuuzetsu> there's a GitHub issue about fixing these reports
10:04:26 <lambdabot>  <hint>:1:1: parse error on input `import'
10:04:50 <gwz_> thank you Saizan
10:04:51 <Fuuzetsu> https://github.com/haskell/hackage-server/issues/142
10:05:20 <Fuuzetsu> IIRC there was a comment on some issue on why this happens
10:06:01 <Fuuzetsu> https://github.com/haskell/hackage-server/issues/74 seems relevant
10:06:11 <Fuuzetsu> tl;dr someone needs to find time and help out the Hackage guys
10:06:12 <Saizan> jmcarthur: i'd say that doesn't work so well on irc, and i'd amend it by giving the obvious answer first, you show you know the stuff that way and the asker might be more willing to stay around for the more refined answer
10:06:44 <Kron> how do I download package documentation?
10:07:02 <Kron> or do I even need to? will it automatically link the documents when I upload them or should I download all the docs and link it locally before uploading?
10:09:17 <Zekka> merijn - Thanks: it works fine now, although an unrelated portion of my code seems to have driven the typechecker mad
10:09:35 <c_wraith> Saizan: overall, both approaches are a waste with this particular person.  He's shown a tendency to be abusive until people give him the partial answer he's looking for, then abusive when it doesn't work because he refused to listen to the full answer.
10:09:42 <Zekka> (I wish the names of type aliases were reliably preserved)
10:09:44 <jmcarthur> Saizan: i find often that approach leads to somebody becoming more frustrated because they keep hitting roadblocks they didn't foresee but which somebody more experienced could have at least warned them about.
10:09:48 <c_wraith> Saizan: to be honest, I don't know why I was trying.
10:09:52 <Zekka> er, synonyms
10:11:25 <Fuuzetsu> Kron: it will automagically link stuff, or rather insert it as-is which means that just calling ‘cabal haddock’ and uploading the result won't do because you get local links that will break once you upload
10:11:34 <jowens> hey, three beginner questions, happy to get some advice!
10:11:35 <Kron> gotcha
10:11:40 <jowens> 1) I've never built a project from scratch before. So I used "hi" to create a cabal skeleton for a new project. It has "HS-Source-Dirs: src"; src is a subdirectory of the directory where the cabal file lives. Inside src is 3 .hs files. One of those three is marked in the cabal file as "main-is". When I compile ("cabal build --ghc-option=-ferror-spans"), it does not find the module in one of the other files. It does not seem to recognize 
10:11:41 <jowens> other files at all. How do I get it to recognize the other .hs source files in the src directory?
10:11:46 <troydm> is it possible to reference modules from one another
10:11:47 <jowens> 2) "hi" set up a "test-suite" for me, "spec". Is this the test suite that the cool kids are using? It appears to include QuickCheck, which seems good. I have not written tests for Haskell before, and there seems to be lots of documentation on QuickCheck. Other suggestions?
10:11:52 <jowens> 3) Data structure question, and surely a simple one. I would like to make two string-ish classes, let's call them encodedString and decodedString. They're both just plain strings internally. If I coded in an OO style, I'd give them both member functions that applied specifically to that kind of string. Do I just use a type synonym (type encodedString = String)?
10:11:53 <troydm> like i have module A and module B
10:12:01 <Fuuzetsu> sometimes I get tempted to just upload my own custom pages for that unique package look ;)
10:12:03 <troydm> and i want them to mutually import each other
10:12:24 <Fuuzetsu> troydm: you can use boot files but in general, no, you can't
10:12:35 <jmcarthur> jowens: 3) if you want encapsulation you can use modules and control what they export
10:12:57 <jmcarthur> jowens: 3 cont.) and i would at least use a newtype, if going for that approach, and possibly even if not
10:13:09 <jowens> jmcarthur: I'm more concerned with how I declare the datatypes (not worrying about the modules and exports now). newtype, OK.
10:13:23 <jowens> newtype meaning "data encodedString = ..." ?
10:13:40 <jeltsch> jowens: wrt 3: You probably want a type instead of a class. A class in Haskell is something very different from a class in OO.
10:13:56 <ankov> was you or b) rewrite xinit to our applicants be
10:14:17 <jmcarthur> jowens: type aliases don't actually allow you to hide the representation, but newtypes do. newtypes also give you types that are actually distinct from the type you are wrapping (you can't accidentally use a String as an EncodedString this way)
10:14:37 <yitz> troydm: there is a mechanism to do it, but it's tricky and not recommended
10:14:37 <jmcarthur> jowens: "newtype EncodedString = EncodedStringConstructor String"
10:14:46 <troydm> yitz: ic, thx
10:14:47 <jowens> jmcarthur: awesome! i'm on it.
10:14:57 <jowens> jeltsch: thanks!
10:15:12 <jmcarthur> jowens: for now you can think of newtype as like data but optimized for one constructor and one field. there are some subtle differences in semantics, but nothing you really need to worry about right now
10:15:14 <yitz> troydm: usually what you want to do is create a third module with just the common types. that usually fixes the problem.
10:15:22 <henk> I wrote a program to learn haskell and want to clean up the code a little but have lost the overview a little. Would anyone please take a look at http://lpaste.net/101349 (main program file and module "Diddo") and point out what (functions, names, constructs, …) is in most need of improvement?
10:15:46 <SrPx> Hello guys, could anyone help me identifying the problem with `haste-boot` here? http://lpaste.net/101350
10:16:19 <jowens> jmcarthur: yes, newtype clearly what i want here. it'll typecheck that way, which is good for me. thx.
10:18:16 <Peaker> src/Lib/FilePath.hs
10:18:18 <Peaker> oops :)
10:18:22 <mmmm> Are there any tools to help you find where function definitions are in libraries?
10:18:36 <hpc> hoogle
10:18:53 <Peaker> the clipboard on this machine is behaving very oddly (if I cut&paste very quickly, it often "loses" the paste)
10:19:37 <pavonia> mmmm: hoogle for search by type, hayoo for search by name
10:19:37 <Peaker> Just confused ghc --make into thinking it need not recompile an .hs file when it should, further validating the need for the Haskell build system I'm working on which tries much harder to guarantee correctness than "make" or "ghc --make"
10:20:50 <Ainieco> Hello, are there any functions for a -> (a -> b) -> (a -> c) -> (b,c) ?
10:21:44 <jmcarthur> :t (&&&)
10:21:45 <lambdabot> Arrow a => a b c -> a b c' -> a b (c, c')
10:22:03 <pavonia> :t \x f g -> (,) <$> f <*> g $ x
10:22:03 <lambdabot> Applicative ((->) t) => t -> (t -> a1) -> (t -> a) -> (a1, a)
10:22:06 <jmcarthur> :t (&&&) `asTypeOf` (undefined :: (a -> b) -> (a -> c) -> a -> (b, c)
10:22:06 <lambdabot>     parse error (possibly incorrect indentation or mismatched brackets)
10:22:09 <jmcarthur> :t (&&&) `asTypeOf` (undefined :: (a -> b) -> (a -> c) -> a -> (b, c))
10:22:10 <lambdabot> (a -> b) -> (a -> c) -> a -> (b, c)
10:22:28 <pavonia> @pl \x f g -> (,) <$> f <*> g $ x
10:22:29 <lambdabot> flip (flip . (((,) <$>) .) . (<*>))
10:22:32 <Ainieco> jmcarthur: Any non-arrow versions of &&&?
10:22:54 <jmcarthur> Ainieco: why does it need to be non-arrow?
10:22:56 <geekosaur> I was thinking (liftM2 (,) f g) on ((->) e)
10:23:17 <geekosaur> but I suspect I'm missing something
10:23:36 <jmcarthur> :t liftA2 (,)
10:23:37 <yitz> Peaker: ghc --make seems to be pretty good usually, but cabal sure gets it wrong often enough. or is that really coming from GHC?
10:23:37 <lambdabot> Applicative f => f a -> f b -> f (a, b)
10:23:52 <jmcarthur> :t liftA2 (,) `asTypeOf` (&&&)
10:23:53 <lambdabot> (Applicative (a1 b1), Arrow a1) => a1 b1 a -> a1 b1 b -> a1 b1 (a, b)
10:23:57 <jmcarthur> heh
10:24:04 <Ainieco> I don't really see any point other than "beauty" of non [a-zA-Z] function names.
10:24:15 <Ainieco> any point in arrows*
10:24:23 <yitz> SrPx: 1. did you install the latest version of Haskell Platform? 2. are you on mavericks?
10:24:32 <SrPx> yes
10:24:36 <jmcarthur> the point of arrows is to capture a pattern, that's all
10:24:49 <Peaker> yitz: it's from cabal build, but cabal build is just a wrapper around ghc's --make afaik
10:24:56 <jmcarthur> the naming of the function is just what it is, not the point
10:25:05 <Peaker> yitz: if you edit sources files while compiling you can confuse most build systems (but no mine, muhaha :-) )
10:25:12 <yitz> Peaker: i see. well, that would be great then!
10:25:20 <Ainieco> jmcarthur: So arrow just abstracts function application "."?
10:25:28 <jmcarthur> Ainieco: anyway, if you don't want to use (&&&) there's also liftA2 (,)
10:25:50 <jmcarthur> Ainieco: arrow is some funky monoidal category -ish abstraction.
10:25:56 <Peaker> yitz: https://github.com/ElastiLotem/buildsome/blob/master/README.md
10:26:02 <Ainieco> Both of them cool, thank  you!
10:27:29 <jmcarthur> :t liftA2 (,) `asTypeOf` (&&&) `asTypeOf` (undefined :: (a -> b) -> (a -> c) -> a -> (b, c))
10:27:29 <lambdabot> (a -> b) -> (a -> c) -> a -> (b, c)
10:27:46 <joshcough> anyone: if i dont expose a module (but list it in other-modules), is it possible to write tests (unit tests, properties) for it?
10:28:05 * jmcarthur just realized that `asTypeOf` (undefined :: ...) might as well just be :: ...
10:28:22 <Peaker> jmcarthur: or let lambdabot give the type?
10:28:32 <jmcarthur> Peaker: lambdabot gives a more general type
10:28:49 <Peaker> oh, right, Arrow+Applicative constraints
10:28:58 <yitz> SrPx: see the parts about mavericks here: http://is.gd/H4sEub
10:29:06 <Kron> heh, finally managed to upload documentation and all the links are broken
10:29:42 <Kron> http://hackage.haskell.org/package/QuadTree-0.10.0/candidate/docs/Data-QuadTree.html
10:29:47 <yitz> SrPx: i'm a bit worried that the GHC source code that haste is trying to compile will run in to the CPP issues with clang vs. gcc.
10:29:51 <Kron> can anyone point me in the right direction to fixing it?
10:31:32 <Rc43> Isn't list applicative in fact already monad? I am about "non-deterministic" variant.
10:31:36 <quchen> henk: http://lpaste.net/diff/101349/101351
10:32:01 <Rc43> Because we need "concat" for definition of that, hence we already have "join".
10:32:39 <Peaker> Rc43: List is both Applicative and a Monad
10:32:46 <ion> rc43: No, you can not implement Monad [] in terms of Applicative [].
10:32:48 <Peaker> Rc43: but not every applicative is necessarily a monad
10:33:10 <Peaker> and what ion said
10:33:15 <henk> quchen: Thanks a lot (:
10:33:32 <quchen> henk: Thank you for making me discover the diff feature of lpaste with this link :-D
10:33:43 <Rc43> Peaker, I am about other; I mean that Monad is vacuous
10:33:58 <Rc43> ion, why we don't?
10:34:11 <Rc43> ion, oh, yes, we don't of course
10:34:37 <Rc43> ion, but applicative definition becomes very trivial
10:34:46 <Peaker> Rc43: it's not vacuous for the same reason Monad > Applicative in general:  We can choose which non-determinism to have based on previous non-deterministic results with Monad[] but not with Applicative[]
10:35:30 <Rc43> Peaker, don't Monad and Applicative versions of list have the same non-determinism model?
10:35:37 <ion> rc43: If you’re referring to implementing Functor and Applicative in terms of a Monad instance, that is always possible.
10:35:43 <Rc43> Peaker, they boh use concat as join
10:36:37 <Peaker> Rc43: there's no join in Applicative
10:37:02 <Rc43> ion, ye, I am not sure how to formulate my thought. I am just about that we must define join for non-determinism, but if we do that we already have monad. I am not sure if there is similar situation for other functors (I think no).
10:37:11 <Rc43> Peaker, it is used internally
10:37:30 <Peaker> Rc43: but it's full power is not exposed through the Applicative interface
10:37:33 <Peaker> its*
10:37:58 <Rc43> Peaker, in fact we define Applicative via Monad in case of ND list applicative
10:38:10 <Rc43> Peaker, but we can do that without monad (ziplist)
10:38:18 <Peaker> Rc43: often it is easiest to define the most powerful instance (e.g: Monad) and derive the weaker ones from it
10:38:21 <Rc43> Peaker, why we need to duplicate code?
10:38:36 <Peaker> Rc43: if (<*>) is defined to be "ap" there's no duplication
10:38:50 <henk> quchen: hehe, my pleasure (:
10:38:56 <Rc43> Peaker, hmm, ok, so it is just question of interfaces
10:39:33 <Peaker> Rc43: It's nice to have both Applicative and Monad because some code is general to all Applicatives and you want it to work with lists too
10:40:05 <narendraj9> > y = y + 1
10:40:05 <lambdabot>  <hint>:1:3: parse error on input `='
10:40:12 <Peaker> Rc43: also you could use the list applicative to do things like "Applicative.Backwards" to reverse the order of non-determinism, which you cannot do with the list monad
10:40:12 <narendraj9> > let y = y + 1
10:40:13 <lambdabot>  not an expression: `let y = y + 1'
10:40:36 <yitz> > let y = y + 1 in y
10:40:40 <lambdabot>  mueval-core: Time limit exceeded
10:41:40 <yitz> > let increment y = y + 1 in increment 20
10:41:41 <lambdabot>  21
10:41:54 <yitz> narendraj9: is this what you are looking for?
10:42:22 <jle`> Rc43: monad instance of list is more powerful. consider the problem of deciding how many ways to 'split' something nondeterministically, depending on its value
10:42:28 <narendraj9> yitz, no I wanted to know what exactly is happening when the time exceeded.
10:43:00 <Peaker> Rc43: in some types you can instantiate Applicative but not Monad. When you can instantiate both: You might have more efficient code for the Applicative special case, or you might just specify the Applicative instance as "return" and "ap", and "fmap" as "liftM"
10:43:02 <jle`> > let f x | even x = [x,x/2] | odd x = [x] in f =<< [1..10]
10:43:04 <lambdabot>  No instance for (GHC.Show.Show b0)
10:43:04 <lambdabot>    arising from a use of `M82850383751214341806172.show_M82850383751214341806...
10:43:04 <lambdabot>  The type variable `b0' is ambiguous
10:43:04 <lambdabot>  Possible fix: add a type signature that fixes these type variable(s)
10:43:04 <lambdabot>  Note: there are several potential instances:
10:43:09 <narendraj9> yitz, on my computer it is constantly evaluating something.
10:43:15 <jle`> > let f x | even x = [x,x/2] | odd x = [x] in f =<< [1..10] :: Int
10:43:16 <lambdabot>  Couldn't match expected type `GHC.Types.Int'
10:43:16 <lambdabot>              with actual type `[b0]'
10:43:23 <jle`> > let f x | even x = [x,x/2] | odd x = [x] in f =<< [1..10] :: [Int]
10:43:24 <lambdabot>  No instance for (GHC.Real.Fractional GHC.Types.Int)
10:43:24 <lambdabot>    arising from a use of `f'
10:43:24 <lambdabot>  Possible fix:
10:43:24 <lambdabot>    add an instance declaration for (GHC.Real.Fractional GHC.Types.Int)
10:43:30 <jle`> oh yeah, i'm dumb.
10:43:37 <jle`> > let f x | even x = [x,x `div` 2] | odd x = [x] in f =<< [1..10] :: [Int]
10:43:38 <lambdabot>  [1,2,1,3,4,2,5,6,3,7,8,4,9,10,5]
10:43:43 <Peaker> Rc43: by the way, [] could probably have more efficient code for (<*>) than "ap"
10:43:45 <yitz> narendraj9: ok. that version says: in order to compute y, compute y + 1. so for that, compute (y + 1) + 1. etc. so it is an infinite loop.
10:43:52 <Peaker> Rc43: I hope the stdlib does better than "ap"
10:43:54 <haskk> Hi, can anyone please help me with the error I get on using Parsec ? Here is the three line code and the error I get
10:43:55 <haskk> http://www.heypasteit.com/clip/186P
10:44:58 <Peaker> Rc43: for example, if the right-list is empty, "ap" might need to re-discover this every time for each of the left elements (given the right side is hidden behind a const lambda), whereas (<*>) could see the right list is empty without evaluating each element on the left side
10:45:01 <haskk> I am defining the "simple" function as a parser equal to the "letter" parser
10:45:03 <narendraj9> yitz, okay. I had guessed it must be this but wanted to confirm. I am learning Haskell.
10:45:09 <narendraj9> yitz, thanks. :-)
10:45:40 <haskk> but I dont understand why ghci cannot load the module
10:46:51 <jle`> haskk: try loading with -XNoMonomorphismRestriction
10:47:01 <jle`> or :set -XNoMonomorphismRestriction
10:47:34 <haskk> when I add the type expression like this :       simple :: Parser Char , then the error disappears
10:47:42 <jle`> ghc by default attempts to make declarations like that monomorphic (applying to one type), unless explicitly told otherwise
10:47:59 <jle`> so without an explicit type signature, it looks for clues to see what the monomorphic type should be
10:48:05 <jle`> it can't find any, so it has no idea
10:48:05 <haskk> why does this function necessarily need me to put the type explicitly. Can ghci not automatically infer the type?
10:48:16 <jle`> haskk: it can't infer the monomorphic type
10:48:26 <jle`> oh wait
10:48:31 <yitz> narendraj9: you're welcome. good luck, and have fun!
10:48:39 <Peaker> the dreaded MR does not prevent inferring a mono-type, only poly-types
10:48:53 <haskk> whats a mono type in simple words?
10:48:55 <Peaker> (and only poly-types that have type-class constraints)
10:49:01 <jle`> yeah
10:49:04 <narendraj9> yitz, :-) will be around here from now on. :-)
10:49:08 <Peaker> haskk: a type without type-variables
10:49:17 <jle`> haskk: consider Int -> Bool
10:49:20 <jle`> instead of a -> Bool
10:49:37 <yitz> narendraj9: ok great. we'll be looking for you.
10:49:37 <jle`> Text.Parsec.Prim.Stream s0 m0 Char has two type variables
10:49:50 <Peaker> haskk: Can you paste the code that does not work without "Parser Char"?  Is it parsec's "Parser" synonym?
10:49:58 <danr> anyone seen donri recently?
10:50:04 <Peaker> haskk: what's the "Parser" type?
10:50:05 <jle`> Peaker: he put it up earlier, http://www.heypasteit.com/clip/186P
10:50:42 <Peaker> ah, the problem isn't the MR -- it's an ambiguous type
10:51:00 <Zekka> Anyone here who can figure out why this fails to compile? http://pastebin.mozilla.org/4612623 <- error included here
10:51:01 <jle`> but with the MR off
10:51:05 <jle`> why would it care?
10:51:11 <haskk> I am using this Parsec library...and Parser type is defined there.
10:51:12 <jle`> until you try to use it, right?
10:51:24 <Zekka> Scroll down to lines 36-39 if you don't feel like reading it all, and compare those to the form of lines 31-34
10:51:28 <jle`> but i suspect you are right
10:51:29 <Peaker> hmm.. perhaps it is the MR -- it has no specific mono-type to choose
10:51:38 <Peaker> and the poly-type needs TC constraints which the MR forbids
10:52:09 <jle`> it's not directly because of the dmr but i feel like it is indirectly, and would not error if it was off
10:52:14 <haskk> peaker, I dont know how I can produce the error without using the Parsec
10:52:23 <jle`> that being said i don't have parsec installed right now so i can't directly test it
10:52:48 <jle`> haskk: don't worry, it's hard-ish because most types have a 'default' mono value somewhere
10:53:06 <Kron> how would I fix a broken hashable package?
10:53:11 <jle`> most...typeclasses
10:53:52 <Kron> or... I'm not sure if the package is broken, it just consistently fails to install in a build script
10:53:56 <haskk> jle`, can you elaborate more on functions with types with no type variable?
10:54:01 <haskk> what is a type variable?
10:54:06 <Peaker> jle`: Yeah, I was wrong -- it is the MR.. if the MR is invoked but fails to choose a mono-type it errors out like this
10:54:19 <jle`> haskk: it's Int vs a
10:54:28 <jle`> @src map
10:54:28 <lambdabot> map _ []     = []
10:54:28 <lambdabot> map f (x:xs) = f x : map f xs
10:54:31 <jle`> er
10:54:33 <jle`> :t map
10:54:34 <lambdabot> (a -> b) -> [a] -> [b]
10:54:36 <jle`> has two type variables, a and b
10:54:39 <jle`> :t chr
10:54:40 <lambdabot> Int -> Char
10:54:42 <jle`> has no type variables
10:54:45 <haskk> i see
10:55:15 <Peaker> haskk: for now, it will work to just use NoMonomorphismRestriction -- it's a really annoying "feature" of Haskell that needs to be disabled with a pragma :(
10:55:18 <jle`> ghc by default tries to get rid of type variables to make it monomorphic unless you specifically ask otherwise
10:55:37 <jle`> don't use NoMonomorphismRestriction on real source code though, just explicitly give a type siganture
10:55:43 <Peaker> jle`: It's enough that I add: foo :: Parser Char ; foo = simple    and "simple" is no longer a type error
10:55:47 <jle`> i'm in the enabled-by-default-is-better camp
10:55:55 <jle`> :)
10:56:30 <Peaker> ghc by default tries to get rid of type variables: A) only if they have type-class constraints   B) if the definition uses the *syntax*:  <name> = ...        if it uses the syntax:  <name> <params> =    then it no longer does so!
10:56:34 <Peaker> this is a terrible terrible special case
10:56:35 <haskk> peaker, yes, if you add that type signature, there is no error then
10:56:49 <jle`> if you typed mymap = map in ghci
10:56:55 <Peaker> it makes:  foo x y = ...       different from:   foo = \x y -> ...         <-- different only due to the MR (and inlining rules/hints)
10:57:04 <jle`> you might get something like map :: (() -> ()) -> [()] -> [()]
10:57:10 <Peaker> haskk: yes, because an explicit type signature also disables the annoying "feature"
10:57:19 <jle`> because it tries to fix the type of 'a' and 'b', and the simplest replacements are () and ()
10:57:26 <Peaker> jle`: ghci does this silliness -- but it's a ghci-specific thing, not a ghc thing
10:57:40 <Peaker> (and it was also fixed in recent versions, I think, by disabling the MR by default in ghci)
10:57:56 <haskk> thanks guys, it is sort of clearer now
10:58:02 <monochrom> actually "mymap = map" is ineligible for the restriction. you will get it polymorphic
10:58:08 <jle`> oh yeah
10:58:11 <jle`> just tried it
10:58:22 <MP2E> oh thank god, so ghc 7.8.1-rc2 is probably fine?
10:58:24 <monochrom> test before speak up!
10:58:32 <jle`> was going to correct myself v.v.
10:58:32 <Peaker> monochrom: yeah because of A) above
10:58:39 <jle`> typeclass constraints
10:59:05 <quchen> Yes, 7.8 has no monomorphism restriction in GHCi. http://www.haskell.org/ghc/docs/7.8.1-rc2/html/users_guide/release-7-8-1.html
10:59:14 <quchen> Section 1.5.2.3.
10:59:20 <Peaker> yay. Hopefully Haskell 2014 can have NoMR enabled by default
10:59:36 <quchen> I wonder what the benefits of the DMR are.
10:59:38 <jle`> honestly mr disabled by default only makes sense in ghci
10:59:45 <c_wraith> I want TupleSections enabled by default.
10:59:49 <quchen> I've only heard that "some argue it's a necessary evil".
10:59:56 <quchen> c_wraith: And MultiWayIf and LambdaCase.
11:00:01 <Peaker> quchen: things like:   x = 5    being a non-memoized function rather than a simple Int
11:00:17 <jle`> x = 5 would have to be reevaluated every time
11:00:20 <jle`> you use x
11:00:27 <Peaker> quchen: or worse:  x = <big computation polymorphic to any Num>
11:00:28 <quchen> Because of the Num dictionary being applied?
11:00:32 <monochrom> there will be Haskell 2014?!
11:00:37 <Peaker> monochrom: I hope :)
11:00:48 <jle`> yea
11:01:03 <Peaker> quchen: because GHC doesn't memoize functions and treats type-class-polymorphic values as functions
11:01:14 <quchen> monochrom: There is "Haskell 2014", but we're not sure whether it has anything to do with Haskell. Maybe we should update this pipe dream to 2015 now that it's a new year
11:01:20 <Zekka> Oh, I've got to go. I'll post my confusing code later
11:01:22 <Peaker> actually GHC does memoize *some* functions (by floating stuff, e.g: from behind a ()->... function)
11:01:27 <monochrom> I have long given up hope. Haskell revisions take longer time than me finishing my PhD!
11:01:47 <quchen> monochrom: Like there's been a Haskell revision
11:01:50 <MP2E> hah :P
11:02:12 <colDrMcBeardman> I have a silly line of performance/ref transparency questions.
11:02:19 <quchen> Let's bring Haskell up to date! 12 years of development, and let's see … n+k-patterns should be deprecated, end
11:02:21 <jle`> i assume monomorphism much more than i assume non-reevaluation
11:02:27 <Peaker> quchen: :)
11:02:34 <colDrMcBeardman> if I have a function, with something like let len = length reallyLongList
11:03:05 <jle`> colDrMcBeardman: that would be an unevaluated thunk, and when it is evaluated, it's replaced with its result
11:03:07 <jle`> globally
11:03:14 <colDrMcBeardman> then I use it several times in the function, it will be replaced at the first call site, assuming it is forced, and then will not need to be recalculated later in that function
11:03:47 <quchen> Peaker: Coming back to the DMR, are there other reasons for having it?
11:03:55 <monochrom> it actually depends on several factors. one is where you place it. another is the mood of the compiler.
11:03:55 <colDrMcBeardman> jle`, so right, once it's evaluated, it's replaced with its value.
11:04:39 <monochrom> but you can empirically test. «len = trace "hello" (length reallyLongList)». trace comes from Debug.Trace
11:05:05 <colDrMcBeardman> monochrom, let's assume it becomes evaluated. So now, I'm correctly assuming that nowhere else in the caller does that need to be reevaluated.
11:05:20 <monochrom> I prefer to never assume.
11:05:46 <quchen> "Need not be reevaluated" doesn't mean it never is.
11:05:57 <MP2E> http://xkcd.com/1339/
11:06:01 <MP2E> relevant
11:06:33 <monochrom> not to mention that a world's most counterproductive thing to do is to hinge an hour of discussion and two hours of coding on a flawed assumption that could have been refuted by a 1-minute test.
11:07:01 <quchen> I'm pretty sure counterproductiveness is unbounded.
11:07:05 <colDrMcBeardman> quchen, fair enough, but if things are really behaving with referential transparency, theoretically, at the first evaluation, the call to length reallyLongList will be replaced with the value.
11:07:21 <colDrMcBeardman> monochrom, don't think I won't test it ;-)
11:08:04 <colDrMcBeardman> but I'm interested in the theory, which my next question hinges on what we've discussed heretofor
11:08:31 <monochrom> in theory the compiler is free to do what it pleases
11:08:39 <k00mi> colDrMcBeardman: it's not specified
11:09:03 <colDrMcBeardman> so now the caller returns. assuming len doesn't get garbage collected at some point, if I call that function again, will it possibly not need to reevaluate length reallyLongList?
11:09:11 <quchen> Yes.
11:09:24 <quchen> Possibly no.
11:09:33 <colDrMcBeardman> quchen, is that something GHC would be likely to catch?
11:09:44 <colDrMcBeardman> assuming the next call is pretty close in time?
11:09:56 <quchen> The compiler may also float out the `length reallyLongList` to the top level and it'll be memoized forever.
11:10:26 <colDrMcBeardman> interesting, what would make it want to do that? lots of callers?
11:10:44 <quchen> The mood of the implementors, mostly :-þ
11:10:48 <colDrMcBeardman> heheh
11:11:16 <colDrMcBeardman> yeah, I was thinking also if you use a map on your caller, you might want it to get floated out since that's technically "lots of callers"
11:11:20 <quchen> It's often an optimizations to float out definitions, and optimizations are tricky to get right, lots of heuristics are necessary
11:11:22 <colDrMcBeardman> for a long enough list.
11:11:29 <colDrMcBeardman> indeed.
11:12:18 <quchen> But in general, if you have a definition like "let x = f y in (x,x)", GHC will evaluate `f y` only once and insert the result twice in the tuples.
11:12:22 <mmmm> How much of a drop in replacement are cabal sandboxes for cabal-dev?
11:12:36 <quchen> It's not wrong to compute it twice though, and maaaybe there are cases in which this might be a good idea.
11:13:01 <colDrMcBeardman> quchen, I was thinking in a case where the computed value is strictly referentially-transparent.
11:13:15 <jle`> mmmm: i switched without problems
11:13:24 <jle`> cabal-dev does things by playing around with your PATH
11:13:31 <jle`> cabal sandboxes just passes flags to ghc
11:13:34 <quchen> Referential transparency guarantees that the result of `f y` is the same every time you calculate it. It doesn't forbit unnecessary reevaluation.
11:13:40 <quchen> forbid*
11:13:42 <jle`> so some things you have to do a bit differently
11:13:59 <colDrMcBeardman> quchen, of course, but it's a clue that a memoizing optimization can be done.
11:14:13 <dcoutts> jle`: did it really? I though cabal-devl worked by passing flags to cabal
11:14:20 <colDrMcBeardman> I'm sort of wondering under what circumstances GHC will pick up that clue.
11:15:13 <quchen> I don't think there is a simple answer to this. I would say GHC seems to be pretty smart most of the time, and profiling will help you find the other cases.
11:15:21 <ReinH> quchen: yeah, it was downright neighborly :)
11:15:42 <jle`> dcoutts: am i thinking of hsenv?
11:15:43 <byorgey> dcoutts, jle`: cabal-dev passes flags.  hsenv messes with your PATH.
11:15:53 <jle`> darn
11:15:58 <jle`> well back to studying for finals
11:16:10 <colDrMcBeardman> quchen, that's as I suspected. thanks!
11:16:31 <quchen> ReinH: Any other upcoming guests, or ones you think would be good for the series? Most of the famous Haskellers have been there
11:16:31 <byorgey> mmmm: cabal sandboxes are indeed a drop-in replacement for cabal-dev
11:17:12 <quchen> colDrMcBeardman: I think if you make something a CAF and it's reduced to a value at some point, it is *very* likely that it's shared the maximum amount possible.
11:17:16 <Younder> I'd say Category theory is not enought embedded at the core. If it was you cound prove assoumptions without lemma's because the compiler would know the math
11:17:37 <byorgey> quchen: you seem to think  isFamous :: Haskeller -> Bool,  but it's more like  howFamous :: Haskeller -> Double
11:17:45 <colDrMcBeardman> quchen, though isn't there a possibility it could be GC'd?
11:18:09 <jle`> also, howFamous :: Haskeller -> IO Double
11:18:38 <quchen> colDrMcBeardman: Yes. There's also a possibility I'm entirely wrong :>
11:18:49 <colDrMcBeardman> heh. thanks again!
11:18:51 <byorgey> or maybe just  howFamous :: Haskeller -> Time -> Double.  Surely asking how famous someone is can't cause things to be printed to the screen.
11:18:55 * monochrom adds complexity by convert_continuum_to_predicate :: (a -> Double) -> Double -> (a -> Bool)
11:19:17 <jle`> it might depend on more than time, like where you ask
11:19:24 * quchen removes complexity by telling people that Haskell types suck for general communication
11:19:29 <Rc43> Peaker, I understood what annoyed me about monads definition. Now it is cycle: Monad ----join--> Applicative ----pure--> Monad. We can linearise it: SemiMonad (join | bind) ----join--> Applicative ----pure--> Monad.
11:19:31 <jle`> and asking sometimes prints stuff on screen
11:19:34 <jle`> (like it does right now)
11:19:46 * byorgey notes monochrom has not been interviewed
11:20:10 <Younder> The secret to garbage collection is to eliminate quickly. To not have a lot of dependenciies hanging around that don't need to be there.
11:20:43 <Younder> That is part language and part discipline.
11:20:50 <Rc43> Peaker, or just throw away return from Monad and type function signatures as "Monad a, Applicative a => ..."
11:21:22 <jle`> Rc43: Peaker is gone
11:21:24 <colDrMcBeardman> Younder, I was asking about memoization and referential transparency in the context of computing lengths of huge lists.
11:21:50 <jle`> although i'm not totally sure what you are trying to say
11:21:54 <jle`> with your diagrams
11:22:07 <ReinH> quchen: yes, we have a list :)
11:22:29 <colDrMcBeardman> I was thinking that since GC's generally behave as you described, if there were multiple uses of that memoized value between calls, there is a chance it will get collected and have to be re-eval'd
11:22:42 <quchen> I realize that I shouldn't ask yes/no questions in a channel partially about logic, ReinH :>
11:22:56 <ReinH> quchen: :p
11:23:14 <quchen> ReinH: Say "A" iff there is a person with the last name starting with "A" on your list in position 1; otherwise say "NO"
11:23:22 <ReinH> heh
11:23:29 <quchen> This is going to be tedious
11:23:29 <Younder> colDrMcBeardman, SVM then
11:23:36 <ReinH> lol
11:23:36 <colDrMcBeardman> SVM?
11:23:38 <quchen> BRB, coding an IRC bot to spam ReinH with correct questions :>
11:23:39 <n-dolio> GC doesn't do that.
11:24:03 <xRamses> Hey folks, is there any black voodoo magic involved when appending to files with appendFile? Like laziness or something. I'm trying to do just that but it ALWAYS writes it in the wrong order.
11:24:23 <quchen> xRamses: What do you want to do? What have you tried? What did your attempts amount to? What do you think was wrong? What is the source code?
11:24:48 <colDrMcBeardman> xRamses, if you suspect laziness is the problem, have you tried seq?
11:25:06 <napping> there's nothing strange with appendFile
11:25:34 <xRamses> colDrMcBeardman: well where would I put seq? its just appendFile file str after all
11:25:50 <colDrMcBeardman> oh, no, I was thinking if maybe you were calling it multiple times.
11:26:25 <napping> Is there anything (especially in filepath) that normalizes a path in a way that drops "dir/../", short of canonicalizePath?
11:27:13 <xRamses> colDrMcBeardman: Well I do call it twice, in two different functions, and despite printing to stdout gives me the right order in the file the order is wrong.
11:27:43 <napping> are you using threads or unsafePerformIO or anything that would mess up order like that?
11:27:51 <byorgey> napping: I don't think so
11:28:01 <ElectroStatik> hey all. Is there a tool to view reduction steps in Haskell?
11:28:07 <dwcook> xRamses, at this point showing a test case in the form of source code is probably the most helpful
11:28:18 <napping> byorgey: I guess I'll do canonicalizePath then
11:28:33 <xRamses> dwcook: I guess so, hang on.
11:30:45 <ReinH> So I haven't seen chrisdone in a couple months and he hasn't tweeted either. Anyone know what's up?
11:31:08 <ReinH> Well he's blogging at least
11:31:11 <Nafai> I saw him on #emacs last week or something
11:31:20 <ReinH> Maybe he hates haskell now
11:31:51 <quchen> ReinH: I've also seen him on Reddit. I asked him the same, but didn't get an answer.
11:31:53 <byorgey> haha, I don't think so.  Didn't he just write a blog post about hot-reloading code in ghci or something like that?
11:32:05 <ReinH> byorgey: yes :)
11:33:17 <Platz> http://chrisdone.com/posts/blackout
11:33:47 <ReinH> Platz: AH. Thanks.
11:34:08 <bitemyapp> Platz: nuts. He's awesome :(
11:34:15 <ReinH> Confirm.
11:35:26 <byorgey> oh, interesting
11:35:27 <bitemyapp> ReinH: I was kind of hoping for a Haskellcast with Done about Fay or something.
11:35:35 <levi> Bummer, though I imagine it's actually a good thing for him.
11:35:45 <bitemyapp> levi: yeah, probably.
11:35:49 <bitemyapp> byorgey: I liked your HC btw!
11:35:55 <byorgey> bitemyapp: thanks!
11:36:01 <assia_t> byorgey: Fay (JavaScript/Haskell) on Code Deconstructed - Episode 7 ... ?
11:36:24 <ReinH> bitemyapp: (so was I)
11:36:34 <byorgey> assia_t: ?
11:36:39 <assia_t> byorgey: ops
11:36:45 <assia_t> mean for bitemyapp
11:36:48 <byorgey> ah
11:37:27 <bitemyapp> assia_t: got it, thanks!
11:38:11 <ReinH> bitemyapp: that might have been why I was looking for him :)
11:38:29 <assia_t> bitemyapp: you're welcome... :) (the nickname autocomplete in limechat always makes me do these mistakes haha)
11:39:17 <xRamses> Ok, the code is on http://github.com/xRamses/redo , the two functions that call appendFile are 1: writeDependencyHash in Build.hs and 2: writeDepTargets in redo-ifchange.hs
11:40:17 <xRamses> The result of the hole thing is that the hash is written _after_ the other stuff instead of before
11:41:47 <gspr> Could someone point me in the direction of how one goes about cleaning up after a destroyed Pipe (releasing resource, etc.)?
11:42:32 * hackagebot dlist 0.7 - Difference lists  http://hackage.haskell.org/package/dlist-0.7 (SeanLeather)
11:43:12 <Peaker> napping: I just wrote one for my own purposes (to remove "..") cause I couldn't find it. And now discovered it was my performance problem so rewriting it in C
11:43:14 <fizruk> hi! is anyone aware of a library of general distributed algorithms (for such problems as leader election, consensus problem, distributed search, termination detection, etc.)?
11:44:24 <napping> Peaker: were you doing a lot with paths? I'm just chasing imports, I expect most of the work will be actual parsing
11:44:29 <fizruk> (i'm working on one and want to check if there's been any work on that)
11:44:45 <Peaker> napping: I'm doing it a whole lot, yeah
11:44:50 <gspr> (In my case it's  Pipe a b IO ()  I'm talking about, with cleanup to happen in IO)
11:45:12 <levi> fizruk: I haven't heard of one, though I've seen a couple of standalone implementations of things like Raft.
11:45:15 <Peaker> napping: https://github.com/ElastiLotem/buildsome/blob/master/src/Lib/FilePath.hs#L37 <-- I use this
11:45:41 <fizruk> levi: what's Raft?
11:45:57 <ReinH> fizruk: Library? Not for Haskell, but I have a textbook that might interest you.
11:45:58 <JagaJaga> Hello! Is there any way to redife show for types? I mean smth like type Matrix = [[Double]], instance Show Matrix. No?
11:46:44 <ReinH> fizruk: this covers algorithms for all of those things and also other things http://www.amazon.com/Introduction-Reliable-Secure-Distributed-Programming/dp/3642152597
11:46:47 <levi> fizruk: It's a relatively new distributed consensus protocol
11:46:51 <ReinH> fizruk: just fyi
11:47:01 <gspr> JagaJaga: You can wrap your type in a newtype...
11:47:23 <JagaJaga> gspr, stupid am I. thx!
11:47:35 <gspr> newtype Matrix = Matrix [[Double]] (a horrible matrix type if you want to do linear algebra, btw)
11:47:44 <levi> fizruk: Was created to be an "understandable" alternative to Paxos, and now there about a billion partially finished implementations in various languages.
11:47:48 <JagaJaga> gspr, what is better?
11:47:49 <fizruk> ReinH: oh, thanks! did "not for haskell" meant for library or textbook? are you aware of non-haskell library of distributed algorithms?
11:47:59 <ReinH> fizruk: well, there's Erlang ;)
11:48:07 <ReinH> fizruk: also Twitter has published some stuff iirc
11:48:10 <gspr> JagaJaga: Anything with O(1) indexing...
11:48:14 <ReinH> fizruk: then there's special purpose stuff like Raft, Zookeeper, etc
11:48:29 <ReinH> fizruk: I don't know of a general purpose distributed algorithms library in Haskell
11:48:29 <levi> I think distributed algorithms tend to be implemented one or two at a time rather than all together as a library.
11:48:51 <gspr> JagaJaga: You don't want to have to traverse n-1+m elements to simply read the (m,n) entry of an m-by-n matrix.
11:48:56 <ReinH> The problem with a general purpose library is that the algorithms need to be tuned or even changed based on the specifics of the systems they're being used for
11:49:00 <gspr> JagaJaga: Sorry, m-1+n
11:49:02 <napping> Peaker: looks interesting. Shake has worked pretty well for me, adding automatic dependency tracking might be nice
11:49:14 <ReinH> a fair lossy failure detection algorithm is different from one that needs to handle byzantine systems, for instance
11:49:20 <gspr> JagaJaga: You could use a Vector, for example.
11:49:29 <JagaJaga> gspr, well. You are right. Thx. Gonna change
11:49:35 <levi> Yeah, distributed systems are hard and have to make lots of trade-offs, and the ones you want to make depend a lot on the application.
11:49:42 <ReinH> failure detection over tcp is very different from failure detection over udp, etc
11:49:46 <Peaker> napping: dependency scanning is annoying to implement everywhere.. e.g: when using Python to do code generation
11:49:47 <ReinH> levi: pretty much
11:49:51 <solrize> edwardk?
11:49:53 <gspr> JagaJaga: A Vector (storing the matrix row- or column-major) will be fine
11:49:56 <levi> It's not just a 'use Quicksort and win!' kind of field.
11:50:01 <Peaker> napping: and the #include problem I mentioned is actually a problem with Shake too, I think
11:50:08 <ReinH> levi: heh, even sorting isn't "use Quicksort and win!" ;)
11:50:31 <ReinH> Although it might be "use Quicksort and be guaranteed not to lose by very much"
11:50:31 <Peaker> napping: And I'm not sure if "shake" does directory listing dependencies correctly, nor does it do the stdout/stderr preservation
11:50:39 <napping> what #include problem?
11:50:50 <napping> It does handle directory contents
11:50:53 <fizruk> ReinH: still you can use `sort` until you have performance problems?
11:51:05 <napping> or at least it provides its own function for listing directory contents
11:51:16 <levi> ReinH: Well, sure, but you know what I mean.
11:51:17 <solrize> "Heck, Stephanie Weirich has been talking about just throwing open the kind system to get a universe tower in GHC for a couple of years now."
11:51:30 <solrize> is that what tim sheard's omega is?
11:51:48 <fizruk> ReinH, levi: point being, there may exist "a general solution" which can be used until you need something better, I think
11:51:49 <Peaker> napping: the repo readme, find "#include"
11:52:14 <ReinH> fizruk: Well, in fact there are a large number of general solutions and picking the right one is part of the problem :)
11:52:38 <Peaker> napping: if #include scans are cached -- then it is always forgotten to also consider all the include paths prior to the found one as dependencies -- non-existing file dependencies.. which I'm not sure if Shake can represent
11:52:41 <napping> Peaker: ah, that's a good point
11:52:43 <ReinH> fizruk: what people generally do is pick a big hammer like Raft or Zookeeper and then design their problem around it. ;)
11:53:27 <Peaker> napping: I wonder if shake tries to detect third party meddling with sources *during* a build, which I also do
11:53:29 <ReinH> fizruk: and it's not quite like picking a sorting algorithm. All sorting algorithms sort. Some distributed algos just won't work in some situations.
11:53:29 <levi> There's also the point that 'distributed algorithms' is sort of a cross-cutting concern rather than a focused area.
11:53:52 <Peaker> napping: i.e:  "gcc" gets fed a source, and before it manages to generate the .o file, I save a new version of that source -- which mtime is recorded as the one it built from?
11:54:04 <bitemyapp> fizruk: distributed systems are hard. You can have totally useless, broken systems that lose or data or have poor availability.
11:54:39 <ReinH> The main utility of such a library for me might actually be as a teaching tool tbh.
11:54:44 <bitemyapp> fizruk: not at all the same thing as a merely sub-optimal implementation. The reason people will leap straight to Raft/Zookeeper is to avoid data loss and only concern themselves with "loosening" constraints after they've at least got something plausibly working.
11:54:47 <Peaker> napping: my train is arriving soon...
11:54:53 <ReinH> "Here's what a clean room leader promotion algorithm looks like in Haskell"
11:54:54 <Peaker> napping: I really wanted to use Shake or tup
11:55:05 <bitemyapp> ReinH: there are Raft libraries in Haskell
11:55:05 <ReinH> (vs the shit you actually have to do to make it work in the real world)
11:55:07 <Peaker> napping: but I thought I could do better with a bit of time
11:55:13 <ReinH> bitemyapp: yep, but Raft is complex
11:55:18 <ReinH> less complex than Paxos, but still
11:55:21 <levi> And there are some general *techniques* that you can use to do something in a distributed manner, but you can't just blindly apply them to a local algorithm and get a distributed algorithm out of it in general.
11:55:28 <ReinH> the *idea* of leader promotion can be expressed with a much simpler algorithm
11:55:31 <bitemyapp> fizruk: incidentally, the main way you escape the relative restrictiveness of things like Raft, Zookeeper is to constrain your domain model/operations to things like, "commutative operations only", "append-only", etc.
11:55:34 <ReinH> it just won't handle real world use cases
11:56:01 <ReinH> but as a pedagogic tool I think it would have value
11:56:09 <ReinH> "here's how we need to change it to handle partition failure" etc
11:56:42 <levi> The world of distributed algorithms is also chock full of impossibility results as well as actual algorithms.
11:56:46 <fizruk> too bad I'm not familiar with Raft, Paxos, Zookeeper :(
11:56:52 <bitemyapp> ReinH: I really like this idea.
11:56:54 <ReinH> also the best general purpose distributed systems library is one that provides timeouts :)
11:57:03 <ReinH> because timeouts make everything better
11:57:45 <ReinH> bitemyapp: that's basically the structure of the textbook I recommended, except in an erlang-ish message passing pseudo-langauge
11:57:56 <levi> fizruk: You should read some early Leslie Lamport papers and start implementing things like distributed clocks.
11:58:08 <ReinH> levi: oh god :)
11:58:10 <bitemyapp> ReinH: "uh, it was breaking so I increased the timeout by 5 ms and now it's no longer breaking" <--- 80% of what people in production distributed systems do :P
11:58:23 <levi> Apparently Paxos actually fell out of an attempt at an impossibility proof.
11:58:43 <xRamses> Does appendFile call flush at any point?
11:58:46 <ReinH> bitemyapp: so here's the thing: systems with a known upper bound on message delivery and process termination time have happens-before guarantees
11:58:50 <ReinH> bitemyapp: which is REALLY important
11:59:04 <ReinH> which is why timeouts are really important
11:59:16 <ReinH> which is why Raft leans on them so heavily
11:59:30 <ReinH> it replaces a bunch of failure modes handled separately by Paxos with "did it timeout"?
12:00:04 <ReinH> levi: lol
12:00:26 <levi> The real-world distributed algorithms I've come across have been highly timeout-dependent.
12:00:26 <ReinH> (collapsing failure modes is another big win for timeouts b/c Requisite Variety)
12:00:33 <edwardk> solrize: yes?
12:00:43 <ReinH> levi: yep :)
12:00:43 <fizruk> perhaps I'm dealing with a bit different matter, though. I'm interested in general implementation of multi-agent coordination algorithms/patterns. I'm not sure, but seems they are a level of abstraction higher than distributed algorithms you're talking about.
12:00:48 <ReinH> levi: and there's good math for why too
12:00:52 <ReinH> levi: which is what I like
12:01:05 <solrize> edwardk -->  "Heck, Stephanie Weirich has been talking about just throwing open the kind system to get a universe tower in GHC for a couple of years now."
12:01:06 <levi> I've become very familiar lately with layer-2 bridging protocols like MRP.
12:01:15 <solrize> i was wondering if that was what Omega was
12:01:58 <edwardk> solrize: basically the last sketch of the idea I heard was to treat System F_c as having * in * or type-in-type, then use the fact that the source language has a tower to make it coherent. it is harder than with omega though in the presence of equality coercions
12:02:15 <edwardk> solrize: so it isn't just a matter of 'take tim's stuff and make it work'
12:02:47 <levi> It's basically built on repeating idempotent declarations on a fixed timer, but there are some crazy subtleties to the state machines.
12:02:52 <solrize> hmm ok
12:03:12 <solrize> thanks
12:04:44 <edwardk> solrize: the issue arises when you consider the type of equality checks that result in the system, its fairly subtle and wen i have it paged in I can follow the discussions. dolio has these sorts of issues mlocked in his brain, though. ;)
12:04:48 <edwardk> er when
12:05:09 <ReinH> levi: good times :)
12:05:24 <ReinH> levi: I'm particularly interested in approximate failure detection over lossy links atm.
12:05:44 <ReinH> levi: for instance statsd is fundamentally broken b/c it doesn't compensate for packet loss, which makes me sad
12:05:48 <fizruk> ReinH, levi: have I missed your point, or are we actually talking about different things?
12:05:54 <ReinH> fizruk: maybe :)
12:07:13 <solrize> edwardk heh.   hmm does that mean omega has fewer equality checks than haskell (ghc flavor) currently does?
12:08:19 <fizruk> ReinH: I was talking about algorithms for agents in multi-agent setting. Such as asynchronous backtracking, iterative breakout, ant colony, etc.
12:08:36 <fizruk> ReinH: I just though they might as well be called distributed algorithms
12:08:45 <edwardk> solrize: well, it means it can't write the kinds of code you can with type equality coercions
12:09:05 <an92> Hello guys, I want to apply to Google Summer of Code @ Haskell :D Sorry if I'm late to the party
12:10:14 <edwardk> an92: you still have tim =)
12:10:18 <edwardk> er time
12:10:30 <an92> I hope so :))
12:10:33 <MP2E> thermal interface material!
12:10:38 <MP2E> heh
12:10:38 <MP2E> :P
12:10:55 <xRamses> look at little tim tim, trying to write haskell code ... errr
12:11:02 <MP2E> haha
12:11:27 <fizruk> ReinH, levi: anyway thanks for your answers! I should see what those Raft/Zookeeper things are :)
12:12:42 <edwardk> fizruk: i've also been working on raft / paxos over time.
12:13:59 <fizruk> edwardk: i've been asking if there's been any work on general distributed algorithms library
12:14:19 <fizruk> edwardk: by which I apparently meant multi-agent coordination algorithms
12:14:46 <edwardk> fizruk: sort of. davean has been building a bunch of code for working with gossip, distributed count-min sketches, etc.
12:15:01 <an92> @ GSOC I was thinking about working at the Faster Cabal/GHC parallel builds
12:15:24 <edwardk> i have a fair bit of interest in the distributed algorithms space, but haven't had much bandwidth to work on it lately
12:15:36 <an92> like, compiling with ghc -j to take more advantage of multple cores
12:15:50 <bitemyapp> is there a Haste channel?
12:16:07 <levi> fizruk: I kind of got sidetracked, though it was all under the general umbrella of "distributed algorithms"
12:16:21 <davean> fizruk: I am working on one
12:17:31 <davean> fizruk: I ran into a problem with the zeromq bindings in Haskell having some issues, what I currently have for gossip works well as far as I can tell, but in theory sohuld have an issue when there is more then one capability due to the spec (I found this looking at the zeromq implimentation in haskell after the initial write)
12:17:46 <davean> I'm working on fixing that before I claim it is usable, though in testing it has no problems
12:18:36 <davean> I also intend to impliment an anti-entropy system, and RAFT most likely
12:18:44 <davean> is that the sort of thing you're looking for?
12:18:46 <fizruk> davean: is your work available?
12:19:05 <fizruk> davean: might be close
12:20:00 <davean> ReinH: are you considering something like Phi accrual?
12:20:08 <ReinH> davean: yes exactly
12:20:26 <ReinH> davean: unfortunately adding a unique sequence number to the statsd payload would be a breaking change
12:20:46 <davean> That is something I felt had to be allowed to hook into gossip, but replacing my zeromq took higher priority
12:20:53 <ReinH> protip for schema designers: allow arbitrary metadata
12:21:01 <bitemyapp> davean: replacing zeromq with what?
12:21:13 <bitemyapp> ReinH: no kidding. Also, favor the use of universally unique identifiers.
12:21:27 <bitemyapp> If I can't idempotently replicate events/messages I get hella cranky.
12:21:32 <skypers> hey
12:21:32 <davean> bitemyapp: not sure, nanomq doesn't have the thread-affinity that makes programming reliably in Haskell hard
12:21:42 <davean> bitemyapp: maybe just BSD sockets
12:21:48 <skypers> https://github.com/skypers/skyoralis/blob/new_design/Graphics/Rendering/Sky/GPU/Shader.hs#L40 << do you know a better way to write that Ord instance?
12:21:59 <skypers> like avoiding LT -> LT and GT -> GT
12:22:02 <skypers> which is quite stupid
12:22:21 <fizruk> skypers: EQ -> ...; x -> x
12:22:36 <davean> bitemyapp: the problem is that a lot of ZeroMQ stuff is thread local
12:23:01 <fizruk> skypers: also looks like a monoid usage for Ordering
12:23:13 <bitemyapp> davean: terrifying.
12:23:25 <skypers> hm
12:23:26 <skypers> you mean
12:23:28 <fizruk> skypers: (x `compare` y) <> (z `compare` w) ...
12:23:34 <skypers> oh
12:23:39 <skypers> or
12:23:50 <skypers> hm yes
12:23:52 <skypers> thank you :)
12:23:56 <skypers> much better I guess
12:23:58 <davean> bitemyapp: not that it isn't doable, but it sure complicates it and causes the code to be unnatural in Haskell
12:24:01 <fizruk> skypers: or mconcat [x `compare` y, ... ]
12:24:22 <skypers> yeah
12:25:15 <xRamses> If appendFile is lazy (at least its in Data.Text.Lazy.IO) when is str actually written to the disk then?
12:25:18 <skypers> fizruk: hm.
12:25:27 <skypers> if x `compare` y is LT
12:25:34 <skypers> what does <> do then?
12:25:41 <skypers> it compares the rest?
12:25:49 <fizruk> > LT <> GT
12:25:50 <lambdabot>  LT
12:26:10 <fizruk> skypers: it compares the rest only on EQ
12:26:20 <fizruk> > EQ <> LT
12:26:21 <lambdabot>  LT
12:26:28 <fizruk> > GT <> EQ
12:26:29 <lambdabot>  GT
12:26:32 <c_wraith> Huh.  The Monoid instance for Ordering is really nice
12:26:42 <davean> fizruk: And yah, my code is floating about with a BSD license
12:26:46 <skypers> fizruk: ok, sounds great
12:26:54 <skypers> > fromEnum LT
12:26:54 <lambdabot>  0
12:27:08 <skypers> > mconcat [LT..]
12:27:09 <lambdabot>  <hint>:1:14: parse error on input `]'
12:27:23 <fizruk> davean: can you provide a link please (if it's on github or anywhere on the internet)?
12:27:33 <c_wraith> skypers: you need a space between LT and ..
12:27:44 <skypers> > mconcat [LT ..]
12:27:45 <lambdabot>  LT
12:27:48 <skypers> oh
12:27:54 <skypers> I don’t put any space with integrals
12:28:08 <skypers> > mconcat [EQ ..]
12:28:09 <lambdabot>  GT
12:28:10 <fizruk> skypers: LT starts with captital, like module names
12:28:12 <davean> fizruk: I'd be interested in what particular things you're interested in though
12:28:16 <skypers> oh
12:28:17 <skypers> ok :)
12:28:22 <c_wraith> :t Prelude..
12:28:23 <lambdabot> parse error on input `Prelude..'
12:28:26 <davean> ReinH: well, if you impliment it as a library, I'd love to plug it into mine :)
12:28:32 <c_wraith> :t (Prelude..)
12:28:33 <lambdabot> (b -> c) -> (a -> b) -> a -> c
12:28:34 <fizruk> davean: multi-agent coordination algorithms
12:28:51 <skypers> > mconcat $ LT : fix ((:) LT)
12:28:52 <lambdabot>  LT
12:29:06 <davean> fizruk: this is where specific names or papers would be great :)
12:29:11 <c_wraith> skypers: that's how it was parsing it.  the operator named . from the module LT..  And it's syntactically invalid to do [.]
12:29:12 <skypers> > mconcat $ fix ((:) LT)
12:29:13 <lambdabot>  LT
12:29:15 <skypers> > mconcat $ fix ((:) EQ)
12:29:18 <skypers> ok
12:29:20 <lambdabot>  mueval: Prelude.undefined
12:29:20 <skypers> great :)
12:30:06 <davean> fizruk: "multi-agent coordination algorithms" doesn't mean anything precise to me
12:30:08 <fizruk> skypers: why not just look at the code?
12:30:14 <colDrMcBeardman> does anyone know of any haskell bindings to the linkedin api? there don't appear to be any on hackage or github
12:30:24 <skypers> fizruk: because it’s funnier testing!
12:30:33 <skypers> but you’re right
12:31:06 <skypers> I guess without laziness, it’s impossible to achieve
12:31:28 <skypers> (the infinity list monoid mappending, which can be actually finite)
12:31:32 <skypers> I love working that way
12:31:41 <yitz> colDrMcBeardman: you're right, that one looks wide open. go for it!
12:31:45 <skypers> like zipping finite list with [0..]
12:32:01 <c_wraith> skypers: be careful.  Soon you'll get used to it, and wonder why strict languages are *so* clumsy. :)
12:32:01 <bitemyapp> colDrMcBeardman: have fun :)
12:32:12 <skypers> clumsy? what do you mean?
12:32:45 <fizruk> davean: actually, there isn't any precise thing about it. But what I'm talking about is a family of distributed search algorithms (http://en.wikipedia.org/wiki/Distributed_constraint_optimization) and adjustable autonomy patterns (http://dspace.library.uu.nl/handle/1874/34210)
12:32:49 <c_wraith> skypers: you have to actually think about what happens if the values you define get fully evaluated - because they will be.
12:33:01 <skypers> yes
12:33:29 <colDrMcBeardman> yitz, bitemyapp, I'll definitely get the profile API working at some point, just hope the boss(es) let me release some of this stuff I'm working on under BSD.
12:33:37 <colDrMcBeardman> (or at all)
12:33:40 <c_wraith> skypers: It means you can't just depend on laziness to allow you to express the smallest part of the idea - you have to also express all the upper bounds manually.  It's annoying when you're used to not bothering.
12:33:41 <davean> fizruk: that is immensely more precise then where you were before though
12:34:11 <skypers> c_wraith: before learning Haskell, I studied C, C++, D, and a lot of other languages
12:34:13 <fizruk> davean: I guess that's most of it (there are tons of papers on multi-agent-systems and I don't have them sorted well enough)
12:34:16 <skypers> so I’m kinda used to it :)
12:35:15 <skypers> Monoid is a wonderful abstraction
12:35:16 <c_wraith> skypers: my point is that if you use haskell enough, you'll become much more hyper-aware of it when you have to do it. It's not just "well, yeah, that's what you have to do" anymore, because you have evidence it's *not* what you have to do.
12:35:38 <davean> fizruk: those are fairly divergent from the area I'm working in ATM
12:35:41 <skypers> yeah, I can imagine, c_wraith
12:35:45 <skypers> I’ll take care then :)
12:35:48 <davean> and I have no current reason to work on that sort of thing
12:35:58 <davean> though some of the stuff I'm working on might assist you some
12:36:09 <Platz> data abstraction: how would I choose between Modules(without exposing dataCtors)+Typeclasses, vs using records of functions?
12:36:58 <Platz> are they the same thing but just using different machinery to accomplish the same goal?
12:38:13 <Platz> or am I missing something that clearly shows those two things are more different that I'm leading on
12:38:46 <ReinH> davean: which library is yours?
12:40:37 <davean> ReinH: see PM
12:40:50 <xRamses> I'm getting insane, appendFile works in any example I can think of but NOT in my code.
12:42:04 <c_wraith> Platz: in general, you use a class when you want a different type for each different behavior, and there's only one sane behavior choice for each type.
12:42:25 <whald> i'd like to play around with a routing algorithm and have attempted to define some typeclasses it sould operate on. yet I fail to come up with anything that typechecks. could someone give me a hint how it could be done? I'v created a paste with hopefully enough comments to illustrate my intent: http://lpaste.net/101355
12:43:37 <c_wraith> whald: do you have a specific reason to want to use classes, or is it just what you think you should do based on other languages?
12:43:52 <Platz> c_wraith: makes sense, so the records way is more flexible but more obfuscated?
12:43:55 <artyomkazak1> @pl dup f x = f x x
12:43:55 <lambdabot> dup = join
12:44:23 <c_wraith> Platz: in practice, they aren't more obfuscated. Just a bit more verbose.
12:44:44 <Platz> c_wraith: ah, ok, thanks'
12:44:58 <whald> c_wraith, I'd like to have an simple implementation for simulations and maybe some day the "real stuff" where the message needs Binary instances, and real networking and so on
12:46:41 <whald> c_wraith, and this way I can turn a simple Int into an instance of Location, and the Message does not need a payload at all (but real messages obviously will), and the Node is considerably simpler for simulations as well. does that make sense?
12:48:17 <c_wraith> whald: you're describing why you want abstraction. You're not describing why you want to use classes
12:49:44 <c_wraith> whald: I suppose that's a discussion for another time, though.  The specific issue you're having is with MPTCs.
12:49:52 <whald> c_wraith, I think I see what you mean. the only thing that should really be an class here is Location, right?
12:50:15 <c_wraith> whald: the type signature of success doesn't mention one of the type variables in the class.
12:50:26 <c_wraith> whald: that means the type of success can *never* be inferred
12:50:57 <c_wraith> whald: because the behavior could change depending on what the third type variable is.
12:51:48 <c_wraith> whald: in fact all three functions in your Node class will have that issue.  This really does suggest you don't want a class.  Or at least, you don't want *that* class.
12:52:14 <whald> c_wraith, so should Node be ADTs parametrized on the Location to use?
12:52:51 <c_wraith> whald: that's one approach that often will work.
12:53:06 <xRamses> Ok I'm sorry but I have to repost my issue, I'm unable to solve it myself. The problem is that the order of my 2 appends to a file are getting messed up, the hash, which is supposed to be written first by https://github.com/xRamses/redo/blob/master/Build.hs#L72 , is written AFTER the stuff written by https://github.com/xRamses/redo/blob/master/redo-ifchange.hs#L20.  Both functions are called...
12:53:08 <xRamses> ...at https://github.com/xRamses/redo/blob/master/redo-ifchange.hs#L14
12:54:35 <tkon> Can someone help me optimize this repa code? http://lpaste.net/101356 Its a simple function to do a number of weighted jacobi iterations.
13:02:24 <whald> c_wraith, ok, turning Node into an ADT gave me something that typechecks, I'll see how far it takes me. thanks!
13:02:44 <c_wraith> whald: good luck :)
13:05:02 <bitemyapp> What's a good data structure in Haskell for when I want to be able to efficiently insert items into the middle of a sequence?
13:05:48 <jmcarthur> bitemyapp: well, there's Data.Sequence
13:06:03 <jmcarthur> bitemyapp: O(log n) insert to arbitrary locations. O(1) to the ends.
13:06:04 <bitemyapp> jmcarthur: I had the impression it didn't have efficient access/insert to the middle.
13:06:14 <bitemyapp> log n insert to arbitrary locations...
13:06:16 <bitemyapp> that might be fine.
13:06:37 <jmcarthur> bitemyapp: i doubt you will do better than O(log n) if you are restricting yourself to a purely functional data structure
13:07:00 <jmcarthur> bitemyapp: heck, even if you allow mutation, it might be tough...
13:07:10 <c_wraith> I doubt you'll do better than O(log n) even with mutation
13:07:18 <jmcarthur> bitemyapp: if you will tend to insert into the same area, you could use a zipper
13:07:33 <jmcarthur> yeah i think O(log n) is basically optimal
13:08:11 <bitemyapp> I don't see a good way to insert in the middle of a Sequence from the API
13:08:18 <bitemyapp> I see insert left, insert right, and insert index
13:08:23 <jmcarthur> bitemyapp: split, cons/snoc, concat
13:08:23 <bitemyapp> but insert index would require cascading.
13:08:24 <c_wraith> bitemyapp: split
13:09:05 <bitemyapp> split, cons/snoc, and concat altogether are going to be log n?
13:09:11 <jmcarthur> yes
13:09:21 <bitemyapp> color me impressed.
13:09:29 <jmcarthur> split is logarithmic, cons/snoc is constant time, concat is logarithmic
13:10:46 <jmcarthur> there even exist purely functional deques with constant time concat, but split wouldn't improve any (maybe would even become linear...)
13:11:43 <eacameron> how can I make an IO-like monad without reqiring liftIO everwhere
13:12:00 <jmcarthur> eacameron: define a set of blessed IO operations that do the lifting internally
13:12:23 <eacameron> jmcarthur: :( I was afraid of that
13:12:23 <Younder> slaves
13:13:20 <eacameron> can I somehow *not* make my own monad, but just piggy-back on IO with some additional data that comes along for the ride?
13:13:44 <ReinH> eacameron: it's pretty damn easy to make your own monad
13:13:56 <jmcarthur> eacameron: you could use some trick like http://hackage.haskell.org/package/reflection
13:14:16 <eacameron> ReinH: I know...but one that doesn't require liftIO for real IO actions
13:14:24 <jmcarthur> eacameron: allows you to hijack type classes to pass a value around implicitly ^^
13:14:36 <ReinH> eacameron: it's really not that hard to use liftIO
13:14:41 <Peaker> eacameron: there's the lifted-base package that gives all the IO stuff already lifted-IO?
13:14:43 <eacameron> jmcarthur: sounds scary
13:14:50 <jmcarthur> eacameron: however, reflection really only works for Reader-like stuff
13:15:00 <Younder> cs.ioc.ee/mpc-amast06/msfp/filinski-slides.pdf‎ on monadic reflection
13:15:04 <Peaker> also, "liftIO" is not really noisy, though sometimes aliased to "io"
13:15:20 <eacameron> Peaker: I like that pretty well
13:15:32 <eacameron> Peaker: tell me more about this
13:15:40 <eacameron> Peaker: lifted-IO package
13:16:00 <c_wraith> and if you're writing liftIO every line, remember that you can coalesce successive liftIOs into a single liftIO
13:16:17 <Younder> reflection leads to weak inference. It is a copout
13:16:20 <ReinH> c_wraith: yep
13:16:43 <Peaker> eacameron: http://hackage.haskell.org/package/lifted-base
13:16:46 <pavonia> Is there a way to make GHCi load all packages that the currently loaded file imports modules from?
13:16:47 <ReinH> This might also be a case for a free (or operational) monad
13:16:58 <ReinH> if you want to be more restrictive of when and what kind of IO you can perform
13:17:13 <allsystemsarego> hi all, what does the "(..)" mean in "import Control.Exception (AsyncException(..))" ?
13:17:30 <dwcook> allsystemsarego, import all data constructors of that type
13:17:41 <allsystemsarego> dwcook, thanks
13:18:04 <dwcook> As well as the fields, I believe
13:18:50 <dwcook> Yeah, the report confirms it. All constructors and fields
13:19:12 <dwcook> (That are exported)
13:20:41 <bitemyapp> > (\(x, y) -> x >< y) $ over _1 (\x -> (Data.Sequence.|>) x 'd') (Data.Sequence.splitAt 3 $ Data.Sequence.fromList ['a', 'b', 'c', 'e'])
13:20:42 <lambdabot>  Not in scope: `Data.Sequence.|>'Not in scope: `Data.Sequence.splitAt'Not in ...
13:20:56 <bitemyapp> sigh. Point being, it returns "abcde" as a sequence.
13:21:05 <bitemyapp> c_wraith: jmcarthur ^^ thank you both.
13:22:25 <jmcarthur> > (\(x, y) -> x >< y) $ over _1 (\x -> (Seq.|>) x 'd') (Seq.splitAt 3 $ Seq.fromList ['a', 'b', 'c', 'e'])
13:22:26 <lambdabot>  Couldn't match type `Test.QuickCheck.Gen.Gen a0
13:22:26 <lambdabot>                       -> Test.QuickCheck.Gen.Gen a0'
13:22:26 <lambdabot>                with `Data.Sequence.Seq GHC.Types.Char'
13:22:36 <jmcarthur> > (\(x, y) -> x Seq.>< y) $ over _1 (\x -> (Seq.|>) x 'd') (Seq.splitAt 3 $ Seq.fromList ['a', 'b', 'c', 'e'])
13:22:38 <lambdabot>  fromList "abcde"
13:23:26 <bitemyapp> yeah, right, that.
13:23:27 <xRamses> Is there any real debugger for haskell? And no ghci doesn't count.
13:23:53 <lllllllllllll> gdb?
13:24:10 <bitemyapp> xRamses: are you trying to use the debugger to reason about code?
13:24:55 <xRamses> bitemyapp: I'm trying to use the debugger to simple debug my program.
13:25:31 <ReinH> One does not simply debug a Haskell program. Or something.
13:25:38 <bitemyapp> xRamses: the answer to my question was yes. You want to get away from using debuggers to understand sundry code. It's more manual than the alternatives.
13:25:39 <yitz> xRamses: what do you need that you didn't find in ghci?
13:25:41 <xRamses> I thought about gdb already, would be quite difficult to understand whats going on though without deeper knowledge about haskell.
13:25:53 <ReinH> xRamses: reasoning about the ordering of lazy IO is really hard and one of the main reasons libraries like conduit exist.
13:26:08 <ReinH> xRamses: so maybe you should try using a strict IO library like pipes or conduit
13:26:09 <bitemyapp> xRamses: I think your problem is knowing Haskell rather than acquiring toys. If your problem is lazy IO related such as ReinH suggests then you want to use strict or streaming IO
13:26:25 <bitemyapp> Conduit is quite nice :)
13:26:29 <ReinH> they both are :D
13:26:40 <bitemyapp> indeed. pipes-parse is impressive.
13:27:24 <xRamses> bitemyapp: It surely is my problem, however using strict IO while I want to understand haskell and its lazy IO is counter productive.
13:27:45 * hackagebot uuagd 0.1.0.0 - A debugger for the UUAG system.  http://hackage.haskell.org/package/uuagd-0.1.0.0 (MatthijsSteen)
13:27:50 <ReinH> xRamses: If you think that lazy IO doesn't make any guarantees about when IO actions are performed then you understand it pretty well :)
13:27:59 <ReinH> xRamses: and the solution when you want such guarantees is to not use lazy iO.
13:28:01 <ReinH> *IO
13:28:06 <bitemyapp> ^^ yep.
13:28:24 <MP2E> so lazy IO == bad for emulators or other time sensitive stuff. got it
13:28:34 <bitemyapp> MP2E: depends on what you're emulating.
13:28:53 <jle`> MP2E: lazy IO is bad when you want to understand when io happens
13:28:54 <bitemyapp> and how, for that matter.
13:28:54 <ReinH> It's bad when you want guarantees about timing, resource management, ordering, etc
13:28:58 <jle`> and you rely on it
13:29:03 <jle`> resource management
13:29:05 <xRamses> ReinH: but how can it forget in which order it was supposed to write stuff? That makes no sense to me.
13:29:06 <jle`> yeah ReinH
13:29:16 <jle`> i'm just here to procastinate from finals anyway
13:29:25 <bitemyapp> xRamses: it doesn't work like that. lazy eval means nothing gets forced until it's needed.
13:29:32 <yitz> MP2E: it's bad for when you several IO channels at the same time and need to specify how events are ordered back and forth between them, for example.
13:29:40 <bitemyapp> xRamses: if you have a lambda with an IO action in it, but you don't force the lambda until next week, when do you suppose the side effect fires off?
13:29:46 <MP2E> Ah I see
13:29:50 <bitemyapp> xRamses: so, don't use lazy IO if you care *when* things happen.
13:30:01 <bitemyapp> or at all, for that matter.
13:30:25 <bitemyapp> if you have a path (in lazy, this is a graph, not a tree) in your program where certain IO actions never get forced, then they'll never happen. Period.
13:30:30 <ReinH> xRamses: I was referring to ordering of things like resource acquisition and release
13:30:37 <ReinH> Sorry for being confusing
13:30:45 <bitemyapp> having something be available for evaluation is not the same thing as evaluation in a lazy language.
13:30:47 <ReinH> xRamses: http://stackoverflow.com/questions/5892653/whats-so-bad-about-lazy-i-o
13:30:49 <xRamses> bitemyapp: Isn't writting to a file a side effect? Otherwise it would never be written to the file?
13:30:52 <yitz> bitemyapp: it's fine for read a file, process it, write out a file, good bye.
13:30:54 <eacameron> speaking of lazy IO; does do { x <- readFile file; return 5 } read the file anyway?
13:30:56 <bitemyapp> This is, generally, a good thing. In pure code. In impure code, just use a library.
13:31:02 <bitemyapp> yitz: until it isn't, sure.
13:31:18 <yitz> until it isn't?
13:31:41 <bitemyapp> yitz: what if you start exhausting the file handlers on your servers because they don't get closed after reading quickly enough?
13:31:41 <ReinH> eacameron: Does do { let x = [1..]; return () } create an infinite list?
13:31:44 <Younder> pietistic pascell
13:32:01 <eacameron> ReinH: well those are both pure
13:32:02 <yitz> bitemyapp: in the scenario i described that won't happen
13:32:08 <Younder> evereting has to be pure
13:32:10 <bitemyapp> yitz: can you prove that?
13:32:14 <ReinH> eacameron: so is x <- readFile file
13:32:32 <jle`> eacameron: do { x <- readFile file; return 5 } is pure in its evaluation
13:32:47 <ReinH> There is nothing impure about *defining* IO actions. What's impure is *performing* IO actions.
13:32:53 <yitz> bitemyapp: i can prove it empirically. i have been doing it all day long in endless combinations for years, processing many terabytes of data, and never had a single problem.
13:33:01 <eacameron> ReinH: but IO is strict isn't it?
13:33:03 <bitemyapp> ReinH: very good point.
13:33:10 <ReinH> eacameron: No.
13:33:25 <bitemyapp> yitz: you're probably doing this in batch, with non-persistent services.
13:33:35 <ReinH> In fact the laziness is the reason solutions like the iteratee (foldl) pattern exist.
13:33:36 <eacameron> ReinH: I thought it was...not I'm confused
13:33:38 <bitemyapp> yitz: if you have a long running server/service you have to be a lot more anal about deterministic resource management.
13:33:43 <xRamses> So if I understand this correctly, main = appendFile "t.txt" "Something" >> appendFile "t.txt" "More something" is undefined behavior
13:33:55 <bitemyapp> it's not undefined behavior at all.
13:34:07 <jle`> it's very well defined
13:34:09 <bitemyapp> undefined behavior means, "it's allowed to shoot your dog and burn your house down"
13:34:20 <bitemyapp> xRamses: you just don't understand laziness yet.
13:35:01 <xRamses> bitemyapp: Well that's why I'm trying to learn it ;)
13:35:07 <yitz> bitemyapp: exactly. in that scenario, lazy io is fine. and also if you add maybe two more layers of complexity, if you understand some advanced tricks and understand the operational semantics going on behind the scenese. beyond that, it's no longer worth it.
13:35:17 <bitemyapp> yitz: right.
13:35:33 <yitz> *scenes
13:35:58 <xRamses> So when its very well defined than in which order are the 2 strings in the file?
13:36:08 <ReinH> xRamses: so you're saying that in your example above, the file sometimes looks like "More something\nSomething"?
13:36:35 <xRamses> ReinH: actually everytime, which is the weird thing.
13:36:58 <klrr_> in pipes library is there a way to do different things depending what values come in in a convinient way? i.e pass them to a consumer if Left or yielded downstream if Right
13:37:08 <yitz> bitemyapp: but don't worry. if you don't open too many files, it will only shoot your dog.
13:37:15 <bitemyapp> lmao.
13:37:34 <YoSoySpock> Good night
13:37:36 <xRamses> ReinH: but not in this particular example, sorry
13:37:46 <bitemyapp> YoSoySpock: good night
13:37:56 <bitemyapp> YoSoySpock: sure you shouldn't be using Universal Greeting Time?
13:38:03 <ReinH> xRamses: if you can make a reproducible example and put it on lpaste that might help.
13:38:04 <MP2E> haha
13:38:06 <bitemyapp> YoSoySpock: http://thinkmoult.com/ugt.html
13:38:11 <ReinH> Try to make it as minimal as possible
13:38:13 <bitemyapp> YoSoySpock: ITYM, "Good morning everybody!"
13:38:49 <xRamses> ReinH: if I would be able to make a reproducible example I would probably fixed the problem 3.5 hours ago. But I fail at doing so.
13:38:55 <ReinH> klrr_: use `either'?
13:38:58 <ReinH> xRamses: :p
13:39:22 <ReinH> xRamses: well, you know some things can't possibly be affecting it (because they're pure) so start removing them :)
13:39:34 <YoSoySpock> bitemyapp: thanks, I didn't know it
13:40:43 <klrr_> ReinH: hmm
13:40:56 <ReinH> \x -> either (goLeft x) (goRight x) x ?
13:41:10 <klrr_> that's not the issue
13:41:16 <klrr_> i got such a function working already
13:41:23 <TiberiusKirk> good morning
13:41:23 <klrr_> i need the other end
13:41:28 <ReinH> which is join (either <$> goLeft <*> goRight), but that's probably not actually better than the version with points.
13:41:30 <klrr_> the one that either pass it or consume it
13:41:34 <xRamses> ReinH: to bad thats every second function, but you're right.
13:42:04 <ReinH> xRamses: maybe this is a good time to point out that separating your pure code from your impure code usually leads to a better design
13:42:23 <ReinH> better, for instance, by being easier to reason about and change :)
13:42:40 <klrr_> i got a producer that yields (Either a a), now i want a fuinction kinda like this "Consumer a -> Pipe (Either a a)" that consumes on Left and yields on Right
13:42:59 <ReinH> xRamses: I suspect that if you refactor towards putting pure code with pure code and impure code with impure code the problem will be much easier to see
13:43:30 <ReinH> klrr_: I'm not sure
13:43:36 <jle`> klrr_: try writing out the full type
13:43:42 <jle`> do you want Pipe (Either a a) a a ?
13:43:56 <klrr_> unit will be returned
13:44:05 <xRamses> ReinH: Yeah I know, but as my application depends heavily on both the cli environment and the filesystem thats hard to do.
13:44:20 <klrr_> i dont care about the "result" i just want it to consume some values and push some values downstream (eventually to another thread)
13:44:27 <fizbin> Is there an IRC channel specifically about the FP Complete IDE?
13:44:30 <jle`> klrr_: what about the values that you don't push...?
13:44:33 <jle`> are they lost?
13:44:36 <jle`> what do you mean by consumed
13:44:37 <klrr_> no
13:44:42 <ReinH> xRamses: Sometimes we should do things even though they're hard :)
13:44:44 <klrr_> they are consumed by a Consumer a IO ()
13:44:49 <klrr_> that sends them to a server
13:44:58 <jle`> so you want to fork your pipe
13:45:04 <klrr_> yes
13:45:09 <jle`> into two different consumers
13:45:17 <klrr_> yes
13:45:27 <jle`> ah, ok.
13:46:20 <ReinH> klrr_: look at leftD and rightD
13:46:40 <klrr_> ok
13:47:39 <xRamses> ReinH: I'm trying :)
13:47:51 <klrr_> i tyhink tee in Pipes.Prelude is exactly what i find, thanks for all help though!
13:49:14 <ReinH> wait what happened to leftD and rightD in 4.x?
13:49:15 <ReinH> oh well
13:49:38 <jle`> i think tekmo wanted to move away from arrow-like interfaces
13:49:51 <jle`> you could presumably solve the same problem with tee
13:49:53 <ReinH> jle`: ahh
13:50:01 <ReinH> seems good
13:50:12 <jle`> sort of a right-answer-to-the-wrong-question kinda thing
13:50:18 <jle`> i cannot pretend to know his mind though
13:50:30 <ReinH> Well I guess I should have asked him
13:51:52 <jle`> my up and coming pipes/conduit replacement library with a strong arrow interface and idioms will restore it ^.^
13:52:17 <klrr_> dont forget machines :)
13:53:18 <jle`> klrr_: that too
13:53:20 <jle`> :)
13:53:28 <klrr_> okey :)
13:53:33 <klrr_> looking forward to see it
13:54:23 <jle`> don't hold your breath, ran into some issues with the semantics with the diamond topology :/
13:54:41 <monochrom> heh
13:54:53 <yesthisisuser> cabal sandbox deserves an award
13:55:03 <monochrom> diamond is the best thing since sliced hierarchies
13:58:30 <ReinH> diamond is best rhombus
13:59:06 <pxqr> suppose we have a lot of actions we need to run after some specific interval of time. each action have a different interval before it can fire. each action may do network io. the most naive solution is to have a bunch of (fork $ threadDelay n >> action) threads. hovewer, timeout queue should scale better. what is the better way to do that?
14:00:36 <yesthisisuser> almost sounds like something for http://haskell-distributed.github.io/ . I am mainly saying because I was looking at it just now
14:01:29 <yesthisisuser> thread supervision etc.
14:01:31 <yesthisisuser> Erlang-type of stuff
14:05:08 <monochrom> I do use a priority queue, keyed on UTC time to fire. plus a thread that wakes up every minute and look for jobs on the priority queue
14:05:54 <gwz> hey, how do I create a 2d accumulative array in haskell?
14:05:56 <monochrom> I decided against forkIO simply because I want to save pending jobs on disk
14:06:34 <pxqr> yesthisisuser: well, that is too overkill
14:07:10 <pxqr> monochrom: does we have timeout queues implemented somewhere?
14:07:13 <yesthisisuser> pxqr: probably :)
14:07:24 <monochrom> I don't know
14:07:44 <gwz> anyone?
14:07:49 * hackagebot scotty 0.7.0 - Haskell web framework inspired by Ruby's Sinatra, using WAI and Warp  http://hackage.haskell.org/package/scotty-0.7.0 (AndrewFarmer)
14:07:51 * hackagebot chatty 0.5.3.1 - Some monad transformers and typeclasses to simplify I/O on a transformer stack.  http://hackage.haskell.org/package/chatty-0.5.3.1 (implementation)
14:07:53 * hackagebot Spock 0.4.3.2 - Another Haskell web toolkit based on scotty  http://hackage.haskell.org/package/Spock-0.4.3.2 (AlexanderThiemann)
14:08:59 <monochrom> but I use PSQueue for my priority queue
14:09:13 <pxqr> monochrom: does GHC.Event fit for this problem?
14:09:24 <monochrom> I don't know. haven't used it
14:10:24 <monochrom> ok, scotty and Spock. soon we will have Kirk, Chekov, Sulu, Uhura too
14:10:36 <monochrom> not to mention the real mccoy :)
14:18:55 <hiptobecubic> monochrom, let's not forget Redshirt :)
14:22:23 <eyem> I have this data X = X { x :: BS.ByteString } and added a instance FromJSON X where .... But I can't get it to work since BS is ByteString.Char8
14:22:51 * hackagebot uuagd 0.1.0.1 - A debugger for the UUAG system.  http://hackage.haskell.org/package/uuagd-0.1.0.1 (MatthijsSteen)
14:23:43 <pxqr> eyem: aeson dropped instance FromJSON ByteString recently
14:23:53 <dmj`> cabal: The following packages are likely to be broken by the reinstalls:
14:23:54 <dmj`> haskell-platform-2013.2.0.0
14:24:01 <dmj`> where is the haskell platform package?
14:24:06 <dmj`> it's not on hackage
14:24:24 <geekosaur> nope. but, you should treat that as "warning do not proceed"
14:24:26 <eyem> pxqr: Oh didn't know..
14:24:49 <geekosaur> I can point you to the package but it won't solve your problem since it pulls in fixed versions of packages
14:24:55 <dmj`> geekosaur: how can I diagnose why it's breaking? This is a brand new install of 7.6.3 on OSX
14:25:06 <dmj`> only pkg installed was cabal
14:25:10 <dmj`> 1.18
14:25:11 <dmj`> .03
14:25:22 <pxqr> eyem: https://github.com/bos/aeson/issues/179
14:26:10 <geekosaur> oh. I think you can ignore that since cabal-install is one of the packages that is fixed by a haskell platform install but won't affect anything else. (and haskell-platform is a metapackage, so nothing will *actually* be broken)
14:26:11 <eyem> pxqr: Thanks!
14:27:26 <fikusz> is there a nice way of building lists incrementally? I've tried assembling all components in a where block and then just concat them, but I think a sequential approach would be more readable in this case
14:28:58 <dmj`> geekosaur: so you're saying that if I have version 1.16 of cabal I won't get that message?
14:29:02 <fikusz> maybe something like the writer monad I guess
14:29:04 <dwcook> fikusz, what do you mean by "incrementally"? And what's the list you want to build?
14:29:26 <geekosaur> wait, where are you getting this message from? (what did you do to get it?)
14:30:38 <rivet> is there a function: nbrLines :: String -> Int ?
14:31:00 <monochrom> what should it do?
14:31:04 <erisco> is that counting the number of lines?
14:31:22 <erisco> :t length . lines
14:31:23 <lambdabot> String -> Int
14:31:23 <dwcook> length . lines -- ?
14:32:09 <fikusz> dwcook: it's a string built from numeric parameters and by incrementally I mean that the code should follow the structure of how the string is assembled (from beginning to end)
14:33:03 <dwcook> fikusz, I still don't quite understand your notion of "incrementally", but it sounds like Writer might be what you want
14:33:51 <monochrom> x 5 ++ y 4 ++ z 10 is incremental and follows the structure of the string
14:34:07 <jle`> you can use concat [one, two, three]
14:34:39 <dmj`> geekosaur
14:34:48 <fikusz> maybe incremental is the wrong word, currently I use a concat with a large where block, but it's very hard to read
14:34:57 <dmj`> geekosaur: I init'd a new cabal sandbox on an existing project and called 'cabal install'
14:34:59 <monochrom> if you want it to look like imperative code, write "x 5 ++" on one line, "y 4 ++" on the next line, "z 10" on the last line
14:35:02 <alanz> so hackage goes down seconds before I publish the next version of HaRe :(
14:35:08 <geekosaur> that seems odd
14:35:14 <jle`> writer might be nice too
14:35:24 <geekosaur> I think you'll have to ask dcoutts_ or someone :/
14:35:25 <dmj`> geekosaur: I have 60 pks
14:35:49 <jle`> > execWriter $ do { tell [1]; let x = 3; tell [x]; tell [x+1] }
14:35:50 <lambdabot>  <hint>:1:48: parse error on input `;'
14:35:58 <dmj`> geekosaur: I agree it is odd
14:37:02 <rivet> how can I get a list of all files in a dir
14:37:03 <rivet> ?
14:37:05 <fikusz> jle`: yes, I was looking for a monadic approach
14:37:21 <jle`> fikusz: not sure why the lambdabot isn't working but that should work on multiple lines
14:37:31 <dmj`> @typ getDirectoryContents
14:37:32 <lambdabot> Not in scope: `getDirectoryContents'
14:37:33 <jle`> the main advantage for using Writer is that you can 'compose' builders
14:37:46 <monochrom> you need let {x = 3}
14:37:50 <sarfraz_0> Hello, hackage seems to be down
14:37:52 <jle`> so you can define putter1, putter2, and do putter 1 >> putter 2
14:37:56 <quchen> sarfraz_0: See topic
14:38:02 <jle`> putter1 >> putter2
14:38:09 <sarfraz_0> oh yes, thx
14:38:14 <jle`> and also letting you bind things for the rest of the do block
14:38:43 <jle`> > execWriter $ do { tell [1]; let {x = 3}; tell [x]; tell [x+1] }
14:38:45 <lambdabot>  [1,3,4]
14:39:19 <jle`> > let putter x = tell [x,x+1] in execWriter $ do { tell [1]; putter 2; putter 3 }
14:39:20 <lambdabot>  [1,2,3,3,4]
14:39:31 <fikusz> jle`: yes, the binding for the rest of the do block is nice too
14:39:36 <jle`> but...you can always just do where and concat too
14:39:39 <jle`> idk
14:39:40 <dart> hi
14:39:51 <jle`> hi dart
14:39:53 <dart> why haskell.org is down ? :S
14:40:10 <fikusz> jle`: one particular problem was that with the large were block my definitions where not near the places where they were used
14:40:19 <jle`> ah
14:40:23 <jle`> yeah then that makes sense :)
14:40:32 <fikusz> jle`: and I did not want to bother with let ... in blocks
14:40:45 <jle`> then this might be nice
14:41:00 <fikusz> jle`: indeed, thanks again!
14:41:18 <jle`> using writer on [] is generally discouraged for performance reasons though
14:41:34 <jle`> i'm not sure if it's worse than the concat way though
14:41:38 <jle`> hm
14:41:41 <jle`> it's probably not, right?
14:41:50 <jle`> because it's just building up a chain of mappends?
14:42:12 <ReinH> jle`: (<>) = (++) for lists, yes
14:42:19 <quchen> Writer associates to the left, which has terrible performance for lists
14:42:25 <ReinH> you could use a diff list
14:42:34 <quchen> tell a >> tell b >> tell c  ⇒  (a ++ b) ++ c
14:42:37 <ReinH> and get amortized constant time appends
14:42:38 <Cale> quchen: wait, what?
14:42:54 <jle`> @src concat
14:42:54 <lambdabot> concat = foldr (++) []
14:42:57 <rivet> where is getDirectoryContents?
14:43:05 <monochrom> System.Directory
14:43:07 <jle`> @src foldr
14:43:07 <lambdabot> foldr f z []     = z
14:43:07 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
14:43:07 <fizbin> jle`: Actually, what I've seen says that mappend on a StateT with a monoid state type is much faster than Writer.
14:43:14 <quchen> Cale: My second line is what I meant with the first one.
14:43:25 <fizbin> Is hackage down?
14:43:27 <quchen> Yes.
14:43:30 <tac> In cabal, what is the purpose of --only-dependencies? Why would cabal install something that wasn't a dependency anyway?
14:43:55 <jle`> i see, writer is (a ++ b) ++ c, whereas mconcat is a ++ (b ++ c)
14:43:56 <fikusz> tac: the package you're working with itself?
14:43:59 <quchen> tac: With the flag, the actual lib/exe won't be installed, just the dependencies.
14:44:11 <tac> ah, gotcha
14:44:17 <jle`> and a ++ (b ++ c) is not bad at all, but (a ++ b) ++ c is awful -- fikusz
14:44:17 <monochrom> "cabal install fay --only-dependcies" does not install fay
14:44:25 <tac> hmmm
14:44:52 <tac> tyty
14:44:58 <Cale> I'm pretty sure Writer ends up associating the other way...
14:45:03 <quchen> ReinH: Why "amortized" constant time appends?
14:45:11 <rivet> whats the best way to check if a file is a java file?
14:45:22 <rivet> somethung like endsWith ".java" ?
14:45:28 <quchen> Run it and see whether it throws a NullPointerException
14:45:47 <fikusz> jle`: hm, any way I could work around this? it's pure code, so proper sequencing doesn't really matter in the end
14:45:48 <ReinH> quchen: because you have to pay O(n) eventually
14:45:57 <yesthisisuser> it's funny that Java has so many NullPointer errors and it doesn't even have pointers
14:46:04 <ReinH> maybe I'm using "amortized" wrong
14:46:06 <quchen> ReinH: You mean for the list conversion? That's not DList anymore though
14:46:08 <monochrom> I don't know about the best way. but I would send the file to stackoverflow and ask
14:46:09 <Cale> execWriter $ mapM_ (\x -> tell [x]) [1..1000000] <-- this seems to go much faster than it could if it were left associating the (++)
14:46:17 <ReinH> quchen: right, ok
14:46:26 <Cale> > execWriter $ mapM_ (\x -> tell [x]) [1..1000000]
14:46:28 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
14:46:46 <Cale> In fact, it's even lazy:
14:46:48 <Cale> > execWriter $ mapM_ (\x -> tell [x]) [1..]
14:46:48 <jle`> fikusz: the result is the same (due to the monoid laws), but the performance is different
14:46:49 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
14:46:52 <quchen> ReinH: "Amortized" O(1) for DLists would mean that every once in a while you need to convert the intermediate result to a list
14:46:58 <shachaf> @let data N a = L a | B (N a) (N a) | E deriving Show
14:46:58 <Cale> So, it *must* be right associating
14:46:59 <lambdabot>  Defined.
14:47:04 <jle`> fikusz: but Cale is doing science
14:47:05 <fikusz> jle`: yes, I understand
14:47:07 <ReinH> quchen: right, and you do. Once. When you want to use it. :p
14:47:12 <shachaf> @let instance Monoid (N a) where mempty = E; mappend = B
14:47:13 <lambdabot>  Defined.
14:47:33 <shachaf> execWriter $ mapM_ (\x _> tell (L x)) [1,2,3]
14:47:35 <shachaf> > execWriter $ mapM_ (\x _> tell (L x)) [1,2,3]
14:47:37 <lambdabot>  <hint>:1:25: parse error on input `>'
14:47:42 <shachaf> > execWriter $ mapM_ (\x -> tell (L x)) [1,2,3]
14:47:44 <lambdabot>  B (L 1) (B (L 2) (B (L 3) E))
14:47:47 <uhsheen716> It seems like Hoogle is down for me - I would appreciate if soemone could let me know if there's a function with the following definition: Int -> a -> (a -> M a) -> a? It repeatedly applies a function to a monad.
14:47:49 <mm_freak> hi there
14:47:50 <shachaf> There you go.
14:47:51 <mm_freak> hackage down?
14:47:52 <Cale> shachaf: :)
14:47:54 <jle`> uhsheen716: there is @hoogle
14:48:15 <uhsheen716> jle`: I don't understand the @?
14:48:15 <jle`> uhsheen716: and that function...is...something i wish every other week was in some library
14:48:16 <rivet> whats the best way to check if a file is a java file?
14:48:24 <jle`> (and you probably mean -> (m a) at the end)
14:48:26 <shachaf> rivet: Maybe ask in #java?
14:48:33 <jle`> rivet: check the suffix?
14:48:36 <uhsheen716> jle`: Oh, I do - sorry.
14:48:41 <Cale> rivet: Run the java compiler on it?
14:48:53 <rivet> ha
14:49:20 <rivet> I want to write a haskell program that counts the total LOC in a dir with java files
14:49:30 <shachaf> I have a slightly fancier version of that N type somewhere with nicer pretty-printing and so on.
14:49:35 <shachaf> Maybe I should put it on Hackage.
14:49:43 <rivet> is there no split function?
14:49:46 <uhsheen716> jle`: Do you mean there is a bot with the nick @hoogle that I can message? Or... the Twitter account?
14:49:56 <jle`> @hoogle a -> a
14:49:57 <lambdabot> Prelude id :: a -> a
14:49:57 <lambdabot> Data.Function id :: a -> a
14:49:57 <lambdabot> GHC.Exts breakpoint :: a -> a
14:49:58 <rivet> @hoogle String -> [String]
14:49:58 <lambdabot> Prelude lines :: String -> [String]
14:49:58 <lambdabot> Data.List lines :: String -> [String]
14:49:59 <lambdabot> Data.String lines :: String -> [String]
14:50:00 <Cale> rivet: What kind of split do you mean?
14:50:07 <Cale> Oh, lines?
14:50:21 <dmj`> why is hackage down
14:50:22 <uhsheen716> @hoogle Int -> a -> (a -> M a) -> (M a)
14:50:23 <lambdabot> Warning: Unknown type M
14:50:23 <lambdabot> No results found
14:50:25 <rivet> split '.' "hello.java" -> ["hello","java"]
14:50:30 <uhsheen716> @hoogle Int -> a -> (a -> m a) -> (m a)
14:50:30 <lambdabot> No results found
14:50:34 <uhsheen716> jle`:  Thanks!
14:50:35 <Cale> rivet: There's a package called split on Hackage that has lots of splitting functions and ways of making more of them
14:51:12 <jle`> uhsheen716: you want iterateM n x f = iterate (>>= f) (return x) !! n
14:51:20 <mm_freak> you can count lines with 'wc'-like speed by using pipes…  and it still looks like list functions =)
14:51:51 <mm_freak> in fact it looks slightly nicer
14:51:56 <jle`> :t iterate
14:51:57 <lambdabot> (a -> a) -> a -> [a]
14:51:59 <monochrom> rivet, takeExtension exists in System.FilePath
14:51:59 <Cale> > splitOn "." "hello.java"
14:52:00 <lambdabot>  ["hello","java"]
14:52:00 <mm_freak> count (lines (readFile "blah.java"))
14:52:07 <Cale> But yeah, use takeExtension :)
14:53:21 <dmj`> I got around the hackage outage by changing remote-repo in my cabal config to point to a mirror
14:53:25 <dmj`> http://comonad.com/reader/2012/hackage-mirror/
14:53:52 <uhsheen716> jle`: Awesome, thanks - that's very helpful!
14:54:15 <jle`> uhsheen716: no problem.  i have needed this so many times :/  wish it was in monad-loops or something at least
14:55:03 <mm_freak> which one?  iterateM?
14:56:57 <mm_freak> i've never needed iterateM…  whenever i thought i needed it, some combination of foldr and foldM turned out to be nicer
14:59:20 <quchen> Cale: (Still working on understanding Writer again.)
14:59:43 <uhsheen716> mm_freak: I'm writing an algorithm that runs for 'n' steps and takes the previous result to build upon. 'iterateM' seemed the most... obvious? to me.
15:00:12 <erisco> :t iterate ($) -- now here is a useless one
15:00:13 <lambdabot> (a -> b) -> [a -> b]
15:00:15 <Cale> quchen: It will be associated the same way that the (>>)'s are, and usually (>>) gets associated to the right.
15:00:33 <Cale> quchen: of course, if you're using >>= then there's no choice, it has to be associated to the right
15:00:48 <mm_freak> uhsheen716: in a case like this i'd probably go with replicateM_ over StateT
15:01:25 <dmj`> why does 'cabal sandbox hc-pkg unregister text --force'
15:01:35 <uhsheen716> :t replicateM_
15:01:36 <lambdabot> Monad m => Int -> m a -> m ()
15:01:41 <dmj`> give "unrecognized option --force"  ?
15:01:48 <mm_freak> uhsheen716: reason is that iterateM is "unnatural" in a sense…  i have trouble formulating any laws about it
15:02:02 <uhsheen716> :t replicateM
15:02:03 <lambdabot> Monad m => Int -> m a -> m [a]
15:02:14 <uhsheen716> mm_freak: I don't understand? I still need the resulting a.
15:02:26 <yitz> dmj`: try moving --force 2 places to the left
15:02:34 <mm_freak> uhsheen716: execStateT (replicateM_ c) s0
15:02:36 <yitz> or one place
15:02:44 <mm_freak> uhsheen716: execStateT (replicateM_ n c) s0
15:03:03 <dmj`> yitz: same for "cabal sandbox hc-pkg unregister --force text"
15:03:15 <mm_freak> uhsheen716: where c = StateT (\x -> …)
15:03:29 <mm_freak> uhsheen716: but in many cases there are even better solutions
15:03:37 <Kron> is hoogle down?
15:03:42 <archblob> hackage is down, does anyone have a handy mirror to trow this way ?
15:03:47 <WraithM> Kron: hackage is down
15:03:48 <uhsheen716> mm_freak: Oh ok, thanks - I'll take a look at that, too. That's a bit less obvious to me, based on my experience.
15:03:53 <Kron> ... Ah.
15:03:57 <JagaJaga> guys, i have to end my work soon. i'm writing solvers of linear system of equations. I've done with gauss, conjugate gradient, jacobi. May be smone can help me with gauss-seidel or successive over-relaxation method? May be smone don't know what do do this evening and I will be very happy :)
15:03:58 <Kron> Hope it's not my fault
15:04:05 <dmj`> archblob: http://comonad.com/reader/2012/hackage-mirror/
15:04:21 <mm_freak> uhsheen716: example:  what's the nature of your combining function?  is it monoidal?
15:04:21 <archblob> thank you dmj`
15:04:33 <mm_freak> uhsheen716: if yes, then WriterT is a far better choice than iterateM and StateT
15:04:45 <ReinH> JagaJaga: well shit I could have used those for ICFP 2010, why didn't you write them 5 years ago :p
15:04:54 <dmj`> why does osx suck so bad for cabal sandboxes?
15:05:01 <quchen> Cale: Hm, looks like all I knew was wrong :-C
15:05:05 <yitz> luite's mirror isn't in style anymore?
15:05:09 <uhsheen716> mm_freak: I don't know..? I'm working in the IO monad (for random) for this algorithm: http://www.stuffwithstuff.com/robot-frog/3d/hills/hill.html
15:05:11 <JagaJaga> ReinH, haha :D
15:05:23 <Zekka> Hey, I asked a question earlier and nobody replied -- after that, I had to go. The question was 'why do stPush and stPop compile while stSwap fails with the given error'?
15:05:26 <Zekka> http://pastebin.mozilla.org/4612623
15:05:57 <yitz> dmj`: it does? i haven't noticed any particular issue.
15:06:09 <Zekka> Sorry to bother folks
15:06:31 <mm_freak> uhsheen716: you're using IO only for randomness?
15:06:40 <sarfraz_0> yitz: it does work for me
15:06:52 <uhsheen716> mm_freak: Yes (if I get kicked off IRC it's because I'm on a spotty connection, so apologies).
15:07:08 <erisco> > let add = (iterate ((+1).) !!) in add 5 7 -- ^_^
15:07:09 <lambdabot>  Couldn't match expected type `[a0]'
15:07:09 <lambdabot>              with actual type `(a1 -> b0) -> [a1 -> b0]'
15:07:34 <mm_freak> uhsheen716: no worries…  if you get rid of IO, you get a nice pure function for this, in which case you can use plain old 'iterate'
15:08:05 <mm_freak> uhsheen716: but yes, the combination function here is indeed monoidal!
15:08:12 <erisco> whoops
15:08:15 <erisco> > let add = (iterate ((+1).) id !!) in add 5 7 -- ^_^
15:08:16 <lambdabot>  12
15:08:29 <dmj`> yitz: I can't uninstall packages and installing anything w/ cabal 1.18 apparently causes haskell-platform to break. Also, hs-cryptohash-cryptoapi broke so I clone it, add the fix but sandboxing sure won't persist changes made on cabal install
15:08:39 <mm_freak> uhsheen716: the essence of the algorithm is that you're generating a number of independent terrains and then calculating their sum
15:09:03 <dmj`> with hsenv everything just works, but it's not cross-platform since it uses unix and not unix-compat
15:09:06 <mm_freak> uhsheen716: given two terrains x and y, the summing function (<>) is associative and has an identity (the flat terrain)
15:09:22 <dmj`> sorry to complain so much :)
15:09:37 <ReinH> uhsheen716: I'd generally suggest using IO to create a random generator and passing that rather than using IO inside your iterate
15:09:41 <fizbin> Zekka: What is the type of theStack ?
15:09:45 <ReinH> you only need to do IO once to use randomness
15:09:45 <yitz> dmj`: i haven't had any of those problems.
15:09:57 <ReinH> (pseudorandomness at least)
15:10:00 <mm_freak> uhsheen716: so your first step is to create a type for your terrains, for example:  newtype Terrain = Terrain { terrain :: UArray (Int, Int) Double }
15:10:07 <mm_freak> uhsheen716: then write a Monoid instance for that type
15:10:10 <Zekka> fizbin - It's a lens for a stack defined as a [Variant]
15:10:19 <Zekka> Want me to pastebin my types module?
15:10:36 <uhsheen716> mm_freak: Ah, that's cool, I think I understand. The benefits of making something monoidal are?
15:10:37 <yitz> dmj`: anything you do in a sandbox won't break HP, except possibly inside that sandbox. what generally break HP is installing a different version of a package that is part of HP.
15:10:57 <mm_freak> uhsheen716: the benefit is that you build complexity from simple parts
15:10:59 <Zekka> Sorry for not pastebinning the whole program -- it's defined in seven or eight files
15:11:03 <tac> Is there an alternative to hackage when haskell.org is down?
15:11:12 <tac> (And if so, how do you connect to it?)
15:11:46 <mm_freak> uhsheen716: currently you are summing continuously, which creates the impression that your algorithm is stateful
15:12:00 <sarfraz_0> tac: http://comonad.com/reader/2012/hackage-mirror/
15:12:04 <Zekka> fizbin - The interesting bit to me is that as far as I can tell, (swap) has the same type as (push v)
15:12:05 <mm_freak> uhsheen716: with a terrain monoid it's not much different from summing a bunch of independent numbers
15:12:09 <yitz> dmj`: are you sure you are in a sandbox? that's one of the problems of 1.18 - you have to check actively to see if you are really in a sandbox. now there's a new --require-sandbox option, that can also be used in local or global cabal.config.
15:12:09 <tac> ty
15:12:48 <ReinH> mm_freak: how do you get mempty without knowing the array bounds at the type level?
15:13:04 <ReinH> mm_freak: I think you actually have a semigroup
15:13:06 <mm_freak> ReinH: good point
15:13:23 <ReinH> mm_freak: you can make it a monoid with Maybe (Option really)
15:13:26 <dmj`> yitz: Using 1.18.1.3, my understanding is that if I'm in the directory I have called 'cabal sandbox init' on, I am in the sandbox
15:13:34 <mm_freak> ReinH: there is a better way =)
15:13:38 <ReinH> mm_freak: orly
15:13:51 <mm_freak> newtype Terrain = Terrain { terrain :: (Int, Int) -> Double }
15:13:57 <ReinH> mm_freak: boom :)
15:13:58 <tac> and you can only have one remote-repo at a time, sarfraz_0 ? (You have to comment the other out?)
15:14:01 <Zekka> fizbin -- For an example of my confusion, this code compiles: stPush' (v: vs) = theStack %= push v
15:14:04 <yitz> ReinH: but don't. if it's a semigroup - use semigroup. trust me, i've learned the hard way.
15:14:13 <ReinH> yitz: yep :)
15:14:20 * johnw hugs semigroups
15:14:25 <ReinH> jowens: confirm
15:14:34 <mm_freak> that one is a monoid, and you need it to be a monoid for writer monads
15:14:45 <ReinH> mm_freak: right
15:14:57 <mm_freak> i like semigroups, but i love monoids =)
15:15:02 <ReinH> mm_freak: me too :)
15:15:03 <jowens> ReinH: confirm ... what ?
15:15:15 <ReinH> jowens: sorry not you, tab complete fail
15:15:22 <johnw> Last is such a convenient semigroup, and an annoying monoid
15:15:26 <jowens> ReinH: :) np
15:15:26 <ReinH> heh
15:15:35 <mm_freak> jowens: confirm
15:15:36 <mm_freak> oops
15:15:38 <ReinH> heh
15:15:44 <ReinH> SEE WHAT I MEAN
15:15:46 <mm_freak> johnw: confirm =P
15:15:53 <uhsheen716> I think this has gone over my head - but I think I can understand up to this point. Thanks for the help! I'm going to stop taking advantage of this coffee shop now :)
15:16:30 <mm_freak> while we're at it…
15:16:30 <fizbin> Zekka: Oddly, when I have theState being a lens for a [String], this also fails to compile: stSwap = theStack %= push "d"
15:16:51 <yitz> johnw: if you need an infix operator for the mappend of Last, here's a suggestion for a nice mnemonic one: !@$+
15:16:55 <mm_freak> data Terrain = Terrain (Int, Int) ((Int, Int) -> Double)
15:17:00 <mm_freak> what would that be?  a comonoid?
15:17:04 <Zekka> fizbin - I ran another test and got a stranger outcome
15:17:12 <Zekka> when stSwap takes an argument, it compiles, and when it doesn't, it doesn't compile
15:17:23 <ReinH> mm_freak: well it's a store comonad
15:17:28 <mm_freak> ReinH: nope
15:17:30 <ReinH> maybe with the params flipped
15:17:32 <ReinH> mm_freak: no?
15:17:38 <mm_freak> data Terrain a = Terrain (Int, Int) ((Int, Int) -> a)
15:17:41 <mm_freak> that one is a store comonad =)
15:17:43 <Zekka> (My test was (stPush' (v: vs) = theStack %= push v) vs (stPush' = theStack %= push undefined))
15:17:45 <ReinH> mm_freak: fine :p
15:17:58 <ReinH> probably a comonoid then who knows :p
15:18:01 <ReinH> wait
15:18:03 <ReinH> what would that even mean
15:18:07 <ReinH> arrows pointing the other direction...
15:18:13 <ReinH> it's still just a monoid?
15:18:16 <mm_freak> yeah
15:18:21 <Zekka> This just seems like such a dead trivial case.
15:18:24 <ReinH> they're all automorphisms
15:18:33 <ReinH> so all the same arrows still exist
15:18:37 <mm_freak> ReinH: isomorphisms
15:18:44 <mm_freak> no
15:18:47 <mm_freak> endomorphisms
15:18:49 <ReinH> mm_freak: er, the arrows in a monoid category are automorphisms?
15:18:50 <fizbin> Zekka: It compiles if you add a type signature to stSwap.
15:18:57 <mm_freak> ReinH: not necessarily
15:19:05 <Zekka> fizbin - I have no idea why I didn't try that. Thanks
15:19:06 <mm_freak> ReinH: you're thinking of groups
15:19:16 <ReinH> mm_freak: oh right, they're just loops
15:19:18 <ReinH> they don't have the structure
15:19:26 <fizbin> Zekka: Therefore, I'm guessing that the error has to do with ghc's known occasionally less-than-omniscient type inference.
15:19:33 <mm_freak> if all endomorphisms are automorphisms, you have a group
15:19:41 <ReinH> yep endomorphism
15:19:44 <ReinH> mm_freak: yep indeed thanks
15:19:59 <ReinH> mm_freak: b/c you get invertibility?
15:20:02 <fizbin> Zekka: The signature I added was stSwap :: (MonadState VMState m) => m ()
15:20:08 <mm_freak> ReinH: yeah
15:20:14 <ReinH> mm_freak: cool
15:20:16 <mm_freak> isomorphisms denote inversion
15:20:17 <ReinH> mm_freak: I remember some of the things :D
15:20:18 <fizbin> Zekka: Requires {-# LANGUAGE FlexibleContexts #-}
15:20:20 <Zekka> fizbin - That seems right -- I'm going to check the sig for stPush and work from there
15:20:26 <mm_freak> and endo+iso = auto
15:20:33 <ReinH> mm_freak: yep yep yep I remembe rnow
15:20:41 <fikusz> I've rewritten my function with Writer, I think it's much clearer to read than a concat version: http://lpaste.net/6349363996079947776
15:20:49 <Zekka> What does FlexibleContexts do? I can google it if you don't want to explain it
15:21:01 <mm_freak> ReinH: one of the beauties of category theory is that you can explain monoids in a single sentence =)
15:21:09 <mm_freak> "category with a single object."
15:21:10 <ReinH> mm_freak: yep :)
15:21:15 <ReinH> mm_freak: and monads too :p
15:21:29 <fikusz> but I'd love to be proven wrong by a better one
15:21:33 <ReinH> "monoid in the category of endofunctors"
15:21:38 <mm_freak> ReinH: well…  the single-sentence explanation of monads is not nearly as elegant =)
15:21:38 <ReinH> easy
15:21:44 <ReinH> mm_freak: yep :)
15:22:02 <ReinH> mm_freak: but I like that it's sufficient
15:22:05 <colDrMcBeardman> so... hackage/haskell.org are down?
15:22:25 <ReinH> mm_freak: I also like going the other way, from monoids to categories
15:22:28 <fizbin> Zekka: Unfortunately, the best explanations for haskell language pragmas are usually on hackage, and it's down.
15:22:29 <ReinH> when explaining categories
15:22:32 <mm_freak> ReinH: with enough auxiliary definitions you can define everything in a single sentence =)
15:22:37 <ReinH> mm_freak: touche
15:22:55 <thebnq> or just really long sentences :D
15:23:15 <Zekka> fizbin - Here's another question I probably need hackage to answer. Why can't I import Control.Monad.State.Class?
15:23:20 <Zekka> Am I importing the wrong thing?
15:23:24 <mm_freak> ReinH: well, i've done that experiment actually in a workshop i gave
15:23:36 <fizbin> Zekka: Yes. import Control.Monad.State
15:23:52 <Zekka> actually, hold up, it looks like my .cabal file is incorrect, I'll fix that
15:23:53 <mm_freak> ReinH: when i explained monoids, i drew a circle on the whiteboard with arrows looping back to it
15:24:09 <ReinH> mm_freak: oh I think we talked about that
15:24:09 <mm_freak> people were confused at first, but the transition to categories was a lot easier =)
15:24:28 <johnw> is there an easy and accurate way to find out how much memory was allocated while executing a particular IO action?
15:24:31 <ReinH> mm_freak: oh, you can use the kleene star as a nice bridge for programmers
15:25:16 <ReinH> mm_freak: the fsm for a is a single state; a* is a single state with a transition to itself. Now squint really hard and wave your hands.
15:25:20 <mm_freak> ReinH: sure, although i tend to start with sets and unions
15:25:40 <ReinH> mm_freak: right
15:26:19 <mm_freak> it's sufficiently uncommon to get people's brain started, and sufficiently easy to go from that to the general pattern
15:26:23 <haskk> Hi, I am considering this simple program http://www.heypasteit.com/clip/1870 and it produces an error related to the type inference. can anyone please help me understand what the error is?
15:26:42 <mm_freak> i strongly believe that people learn best when i don't explain everything
15:26:49 <ReinH> mm_freak: when you talk about, e.g., the sum monoid as a categorical monoid, do you just arbitrarily pick an object?
15:27:10 <ReinH> I guess the object is whichever set of numbers you are summing?
15:27:11 <mm_freak> ReinH: it was just an experiment…  i don't do it that way anymore
15:27:19 <mm_freak> no, because that would be wrong
15:27:21 <ReinH> right
15:27:34 <ReinH> right, what would be right?
15:27:45 <mm_freak> an unnamed object
15:28:01 <ReinH> Ok I'm right then
15:28:03 <mm_freak> or an object with an insignificant name
15:28:10 <ReinH> an arbitrary object
15:28:10 <mm_freak> like M
15:28:12 <fizbin> haskk: Uncomment that type declaration.
15:28:38 <haskk> fizbin : yes, why do I necessarily need to uncomment  that line?
15:28:52 <haskk> because i am assuming that haskell can infer the type, no?
15:28:55 <mm_freak> ReinH: but nowadays i do it the other way around:  explain monoids, then explain categories, then reexplain monoids as a special case
15:28:59 <ReinH> mm_freak: cool
15:29:27 <mm_freak> ReinH: that's more fascinating, because it makes some people acknowledge the elegance of category theory =)
15:29:34 <haskk> fizbin: for all functions I have seen so far, i did not need to specify the type myself explicitly
15:29:38 <ReinH> mm_freak: awesome
15:29:46 <haskk> fizbin: for all functions I have seen so far, i did not need to specify the type explicitly
15:29:51 <ReinH> "APPRECIATE IT!"
15:30:18 <mm_freak> ReinH: until i admit that we're doing it wrong anyway =)
15:30:43 <ReinH> mm_freak: how so?
15:30:58 <mm_freak> ReinH: for starters haskell is what conor mcbride would call "bullshit-complete" =)
15:31:17 <dacali> mm_freak: What's the category for monoids? (Er... what are the objects and what are the morphisms?)
15:31:33 <ReinH> mm_freak: ah right
15:31:37 <mm_freak> ReinH: but more to the point:  i'm pretty sure that not all of your categories have a universe argument =)
15:31:45 <ReinH> mm_freak: A glass-is-half-full way to phrase that might be "morally correct" ;)
15:31:53 <mm_freak> dacali: a monoid is any single-object category
15:31:55 <yitz> fikusz: as a writer monad: 1. follow lpaste's suggestion. 2. your use of put is a little confusing; it sounds like a state monad.
15:32:18 <ReinH> or equivalently, any single category object is a monoid
15:32:35 <haskk> guys, anyone interested to answer my waiting question
15:32:37 <yitz> fikusz: take a look at Data.Text.Builder for a different approach, using a monoid instead of a writer monad.
15:32:53 <fizbin> haskk: Haskell occasionally has difficulty inferring type signatures that require typeclass constraints (the stuff followed by =>) as part of the signature.
15:32:54 <mm_freak> ReinH: a single category object may have non-endo morphisms
15:33:13 <dacali> mm_freak, ReinH: Have a blog post written about it by chance? :) I'm going to need to think about this one for a bit.
15:33:36 <fizbin> haskk: If you really care to delve into the state of the art research on type inference, that's beyond here.
15:33:41 <mm_freak> dacali: tons probably, but just look at the definition of categories
15:33:43 <haskk> fizbin i see
15:33:55 <yitz> fikusz: oh, and usualy you want to use a dlist rather than a list for a writer monad. otherwise you end up with quadratic complexity.
15:33:55 <ReinH> dacali: are you familiar with the Endo monoidin Haskell?
15:34:02 <ReinH> *monoid in
15:34:08 <dacali> mm_freak: Thanks. I'll start Googling. :)
15:34:16 <fizbin> haskk: But in this case, the type of "letter" is (Stream s m Char) => (ParsecT s u m Char)
15:34:32 <mm_freak> dacali: pick a category with a single object M, then draw arrows from that object to itself (endomorphisms)…  draw at least one, name it 0
15:34:36 <haskk> fizbin: is this failure to infer the type somehow related to the fact that Parser is a monad? ( I dont know what monad is)
15:34:41 <ReinH> mm_freak: name it 1 please :p
15:34:50 <mm_freak> name the others 1 : M → M, 2 : M → M, 3 : M → M, …
15:34:58 <dacali> ReinH: Not very familiar with Haskell at all. :( Just starting out.
15:35:01 <ReinH> mm_freak: a zero semigroup is something else :p
15:35:18 <ReinH> oh ok you're just describing the sum monoid
15:35:20 <fizbin> haskk: No. It's related to the fact that the people behind Parsec use some crazy types.
15:35:24 <mm_freak> ReinH: ;)
15:35:31 <haskk> i see
15:35:36 <haskk> fizbin i see
15:35:37 <mm_freak> ReinH: and in my view of reality, 0 is a natural number =P
15:35:52 <ReinH> mm_freak: I choose to agree with you on alternate days
15:36:00 <ReinH> mm_freak: just like I choose to accept the axiom of choice on alternate days
15:36:02 <haskk> so anytime I write my Parsec functions, I should specify the type, just to be on the safe side
15:36:11 <haskk> fizbin, am I correct ?
15:36:23 <ReinH> mm_freak: That was a math joke. It was hilarious.
15:36:29 <fizbin> Or specify them when necessary. It's not as though a compile error is the end of the world.
15:37:23 <haskk> fizbin, can I ask another question about Parser monad?
15:37:32 <ReinH> :t Endo
15:37:33 <lambdabot> (a -> a) -> Endo a
15:37:51 <fizbin> Okay, though you may need someone else to finish answering, as I'm about to need to vanish.
15:37:59 <ReinH> dacali: Endo is a newtype for functions from some type to the same type
15:38:05 <dacali> mm_freak: So there is one object that represents all monoids, and there are multiple morphisms to itself?
15:38:54 <tac> ghc-pkg doesn't know anything about cabal sandboxes does it?
15:39:31 <ReinH> dacali: never mind, it doesn't generally help to have two people explain something at the same time. Listen to mm_freak :)
15:39:45 <dacali> ReinH: I appreciate the feedback anyways. :)
15:40:01 <mm_freak> ReinH: sorry, i didn't get your joke =)
15:40:09 <mm_freak> dacali: no, every single-object category is /one/ monoid
15:40:39 <dacali> mm_freak: Ah, gotcha.
15:40:43 <ReinH> mm_freak: so you don't need the axiom of choice to select elements from an infinite list if you have a rule for doing so.
15:40:52 <ReinH> mm_freak: that's it. That's the joke.
15:41:13 <mm_freak> ReinH: i can't wrap my head around set theory =/
15:41:21 <ReinH> mm_freak: it isn't a very good joke :)
15:41:22 <haskk> fizbin, I am considering this code now
15:41:25 <haskk> fizbin http://justpaste.it/erz3
15:41:27 <dacali> mm_freak: Does that mean addition over integers be a single category then?
15:41:38 <mm_freak> dacali: yeah
15:41:43 <tac> ok so hmmm
15:41:46 <tac> I have a package
15:41:52 <haskk> fizbin, the function parens check things like this (( ))
15:41:53 <mm_freak> dacali: it's one unnamed object and each arrow corresponds to an integer
15:41:57 <tac> and when I try to cabal install, I get some bogus error about a conflict
15:42:03 <tac> But it doesn't explicitly say what is conflicted
15:42:04 <haskk> fizbin, equal number of open and close parenthesis.
15:42:20 <tac> http://lpaste.net/1845640162550218752
15:42:29 <tac> what is that error telling me?
15:42:32 <mm_freak> dacali: keep in mind that the object is entirely insignificant…  it's the arrows you want to examine =)
15:42:33 <haskk> fizbin, the type of the function says that it does some parsing and then returns nothing.
15:42:44 <mm_freak> dacali: and arrow composition = addition (for example)
15:42:48 <mm_freak> 1 ∘ 2 = 3
15:43:22 <dacali> mm_freak: Ooo... okay. That makes sense now! Thanks.
15:43:44 <haskk> but we know that functions such as char parse a character and then return the character parsed
15:44:11 <haskk> so I see this as a conflict
15:44:12 <geekosaur> tac: it is telling you that it wants to install a yesod-websockets that requires a newer yesod-core than you have installed in your sandbox
15:44:26 <ReinH> mm_freak: which helps reenforce the idea that the objects are often boring. The arrows are where it's at. :)
15:44:37 <mm_freak> =)
15:44:39 <tac> geekosaur: hmm
15:45:11 <ReinH> mm_freak: the category of matrices with multiplication is my other favorite example of a category with boring objects. :)
15:45:19 <tac> How do I force a reinstall?
15:45:34 <yitz> tac: just limit the version of yesod-websockets
15:46:02 <tac> I'm not sure what that entails :(
15:46:05 <yitz> tac: we like to do that in a local cabal.config file
15:46:15 <dacali> ReinH: What are the arrows for matrices with multiplication?
15:46:18 <mm_freak> ReinH: you mean the matrix multiplication monoid?
15:46:23 <ReinH> mm_freak: no, category
15:46:33 <mm_freak> oh, i see
15:46:36 <ReinH> objects are counting numbers, arrows are matrices, composition is multiplication
15:46:42 <mm_freak> where objects correspond to dimensions
15:46:45 <ReinH> right
15:46:55 <mm_freak> nice, i haven't thought of that
15:46:58 <yitz> tac: create a file in the root of your sandbox called cabal.config with the line: build-depends: yesod-websockets <= 9.9
15:47:00 <haskk> fizbin so the question is if I have a parser which parses a char and then follow that by return () , then what would be the type of the whole parser?        Parser ()?
15:47:00 <ReinH> shachaf showed it to me :)
15:47:03 <fikusz> yitz: thanks for your suggestions, I'll try those
15:47:12 <yitz> tac: not 9.9 though, whatever number you need
15:47:17 <tac> Like the pre-existing cabal.sandbox.config?
15:47:33 <mm_freak> IIRC starting with GHC 7.8 Category will be kind-polymorphic
15:47:40 <mm_freak> so you can have this category in haskell! =)
15:47:47 <ReinH> mm_freak: id_n is an n x n identity matrix ofc
15:48:05 <ReinH> I_n
15:48:18 <tac> ah I misread
15:48:26 <ReinH> I want an IRC client that understands TeX math notation :(
15:48:36 <mm_freak> no, you don't
15:48:37 <yitz> tac: sort of. cabal.config overrides that.
15:48:42 <ReinH> mm_freak: lmao
15:48:58 <mm_freak> you want an IRC client that supports a unicode input method
15:49:05 <tac> So I added .cabal-sandbox/cabal.config
15:49:06 <tac>  with that one line and same error
15:49:38 <yitz> tac: no not inside .cabal-sandbox. in the root of the sandbox directory itself. next to your cabal file.
15:49:46 <tac> ah ok
15:50:37 <tac> Warning: /home/tac-tics/TacTicsNet/cabal.config: Unrecognized field
15:51:30 <tac> Do I need to put that in a tabbed section, like Executable or library
15:51:45 <yitz> no
15:52:09 <yitz> tac: oh i'm sorry
15:52:20 <yitz> tac: not build-depends. constraints:
15:52:58 <tac> no error on the cabal this time, but same conflict :(
15:53:43 <tac> constraints: yesod-websockets <= 9.9
15:53:43 <tac>  
15:53:52 <tac> is what I have in the cabal.config
15:53:58 <JagaJaga> tac, btw, arn't you using NixOS?
15:53:58 <dacali> ReinH: RE: matrix multiplication. It's multiplication because the dimension of the result matrix is the first and last object?
15:54:11 <tac> JagaJaga: Ubuntu
15:54:29 <JagaJaga> tac, sorry, saw same nick in nixos irc
15:54:49 <JagaJaga> tac, go to my side and you will never get conflicts ;0
15:54:51 <ReinH> dacali: what are the composition laws for a category?
15:55:22 <dacali> ReinH: Given A => B, B => C, there exists a A => C?
15:55:37 <ReinH> dacali: and over what matrices is matrix multiplication defined
15:56:26 <ReinH> usually something like: if A is an m × n matrix and B is an n × p matrix, AB is an m × p matrix such that...
15:56:40 <ReinH> mm_freak: unicode input :D
15:56:58 <lahwran> matrix multiplication makes me mad
15:57:13 <lahwran> why does it include an implicit transpose? why not do it in the same direction...
15:57:53 <ReinH> lahwran: how would it work without the transpose?
15:58:32 <tac> I'm not seeing where this constraint is coming from where it needs yesod-core equal to EXACTLY 1.2.6.7
15:58:58 <yitz> tac: sigh. hackage down. harder to hunt down dependency solutions.
15:59:06 <tac> yeah :[
15:59:15 <ReinH> mm_freak: Oh look what I found! http://vikhyat.net/projects/latex_to_unicode/
15:59:24 <ReinH> mm_freak: this is amazing
15:59:25 <tac> I have cabal set up to pull from hdiff.luite.com
15:59:32 <tac> but all the docs online are down, of course
15:59:36 <lahwran> I don't know how to write matrices on a single line in any language besides octave, but using that; what is now [x y; a b] * [q u; w i] would be, if it worked the way I think it should, [x y; a b] * [q w; u i]
16:00:06 <yitz> tac: right
16:00:16 <ReinH> lahwran: oh, but now do it for non-square matrices
16:00:51 <lahwran> ReinH: I'm just saying, what is now A * B, I think should be A * transpose(B)
16:01:06 <ReinH> lahwran: but then they don't form a category :)
16:01:06 <lahwran> it should go across on both sides
16:01:13 <lahwran> ?
16:01:25 <yitz> tac: i think it's because you already had that version of yesod installed in your sandbox, then you installed Sundlowbotcom and it compiled against that version of yesod, and now cabal doesn't want to undo all that.
16:01:46 <xico> im trying to understand ghc-pkg. if i do "ghc-pkg field base depends" it lists "builtin_rts" as a dependency. how can i get info on this package from ghc-pkg? i mean builtin_rts is its package id, not its name (which is rts). is there a way to get that without issuing a dump, or looking into the directories?
16:01:54 <lahwran> I'm also not really clear as to why matrix multiplication includes the weird distribute and sum thing that it does - seems like those should be separate operations
16:02:08 <ReinH> lahwran: your version requires A to be m × n and B to be p × n
16:02:18 <lahwran> yep
16:02:24 <tac> I'm taking drastic measures. Deleting the sandbox entirely and trying again.
16:02:24 <ReinH> which means they can't form a category
16:02:48 <lahwran> a category? perhaps there's a reason beyond historical that I didn't know about
16:02:50 <yitz> tac: yeah. time for a cup of coffee.
16:02:53 <tac> By the time this is done installing, hackage will be up again
16:03:18 <tac> Coffee? hah. I could go get a masters degree faster than Yesod installs :X
16:03:30 <tac> maybe I will continue my nap :3
16:03:51 <dacali> ReinH: Do you recommend any resources as an introduction to category theory?
16:03:56 <ReinH> lahwran: I'll take the cost of the implicit transpose if the benefit is forming a category because I think you get a lot of mileage out of categories.
16:04:08 <tac> dacali: note the existence of ##math and ##categorytheory
16:04:14 <ReinH> dacali: Awodey has a good textbook and some youtube lectures, there's a nother youtube channel called TheCatsters
16:04:17 <yitz> tac: good idea. i'm going to sleep. seeya, good luck. i think you'll work this out.
16:04:22 <dacali> tac: Thanks!
16:04:34 <tac> dacali: Awodey is a standard text for logicians and computer scientists.
16:04:38 <ReinH> MacLane is, ime as a non-mathematician, hard to get through as your first CT book but very good as your second.
16:04:42 <tac> thanks for your help, yitz :D
16:04:43 <tac> night
16:04:56 <lahwran> ReinH: interesting. I'm still not convinced that has to be native to matrix multiplication, considering that you'd get that just by doing X * transpose(Y)
16:05:16 <lahwran> it makes it harder to reason with
16:05:19 <dacali> ReinH: Thanks, again. I'll check them out.
16:05:21 <ReinH> lahwran: there's probably another good reason that I don't know as someone who doesn't do a lot of linear algebra
16:05:25 <lahwran> since there's more bundled up into one operation
16:05:35 <ReinH> but the fact that it doesn't form a category hints to me that it is somehow less elegant
16:05:40 <ReinH> lahwran: maybe edwardk knows
16:05:51 <edwardk> ?
16:05:52 <roboguy_> dacali: I'm finding "Conceptual Mathematics" pretty accessible as an introduction to category theory
16:06:04 <yitz> ReinH: mac lane is two words. i knew saunders - he was always insistent on that.
16:06:07 <ReinH> lahwran: why is matrix multiplication defined the way it is?
16:06:09 <ReinH> yitz: woops
16:06:17 <ReinH> er
16:06:21 <shachaf> Categories are relevant because they're good at describing things that we care about, such as matrix multiplication.
16:06:23 <yitz> ReinH: np :)
16:06:26 <lahwran> ReinH: are you asking if I'm asking that, or asking me that
16:06:27 <ReinH> edwardk: why is matrix multiplication defined the way it is?
16:06:31 <lahwran> oh.
16:06:39 <edwardk> ReinH: because it works? =)
16:06:44 <lahwran> for what
16:07:03 <ReinH> multiplying them? :p
16:07:04 <lahwran> that is, what does it work better for the way it is, than if it were defined a different, simpler way?
16:07:10 <lahwran> such as being elementwise
16:07:17 <lahwran> what is it more useful for
16:07:35 <edwardk> lahwran: elementwise multiplication is useful for different things
16:07:36 <roboguy_> lahwran: lots of linear algebra type stuff
16:07:41 <dacali> roboguy_: I'll check it out. That may already be on my wish list.
16:07:55 <lahwran> roboguy_: that's a pretty useless answer :|
16:08:04 <edwardk> surprisingly few things though.
16:08:17 <roboguy_> lahwran: like change of basis (which is pretty important) and 3d rotations
16:08:41 <lahwran> k, cool!
16:08:50 <roboguy_> I think it's sometimes used in solving differential equations, but it's been a while since I've done that
16:09:19 <edwardk> a matrix can be viewed as representation of a linear transformation, describing how to take the vectors of one basis of one space and describe them in terms of a basis of vectors in another space.
16:10:27 <edwardk> composing that notion of a transformation requires you to 'trace out' the intermediate basis. that is why you go through x_i_j * y_j_k = z_i_k  -- you're making 'j' disappear
16:11:23 <ReinH> edwardk: ahh, which is why forming a category is nice. f . g makes the codom of g "disappear" too.
16:11:24 <edwardk> its a mapping from one space to another
16:11:32 <edwardk> ReinH: exactly
16:11:44 <edwardk> though they like to make the arrows read backwards from common linear algebra usage
16:11:55 <edwardk> ReinH: just to mess with you ;)
16:11:56 <ReinH> ah
16:12:07 <ReinH> seems like a thing linear algebrists like to do
16:12:15 <Zekka> Oh, is that why (*) acts like composition when you deal with matrices that represent transformations?
16:12:22 <ReinH> I once had one get an appendicitis on the weekend of the ICFP competition about linear algebra
16:12:27 <ReinH> Pretty sure that was just to mess with me too
16:13:09 <ReinH> Zekka: it *is* composition in the category for matrices and matrix multiplication :)
16:14:04 <yitz> ReinH: if you can win icfp while under general anesthesia, you have proven that you are really the best
16:15:22 <dagle> Hmm. Is haskell.org down?
16:15:48 <edwardk> dagle: yes
16:16:18 <ReinH> yitz: we came in 8th or something?
16:16:36 <ReinH> yitz: he was literally following along from his hospital bed and giving us suggestions
16:17:04 <roboguy_> ReinH: dedication
16:17:09 <ReinH> I know.
16:17:33 <ReinH> It was really funny. As soon as we figured out that the underlying problem was a linear algebra problem, BOOM our PhD'd linear algebrist bites the dust.
16:17:40 <ReinH> Timing.
16:17:42 <Zekka> Hey, is there a typeclass or something that can help me map values of m a to values of mTrans m a for some monad transformer?
16:18:10 <Zekka> This may be a simpler problem than I think it is
16:18:18 <ReinH> Zekka: for a given monad transformer, often yes. MonadState, etc.
16:18:47 <ReinH> also these can be derived for newtype monad stack wrappers with GeneralizedNewtypeDeriving
16:19:49 <Zekka> ReinH - I'm under something like StateT SomeType IO trying to get into EitherT SomeOtherType (StateT SomeType IO), is there any hope for me?. I assumed there wasn't a general solution
16:20:06 <Zekka> (I may check those typesigs, I'm a little new to monad transformers and it's possible they're a bit garbled)
16:20:27 <ReinH> so your newtype Foo a = Foo EitherT StateT SomeState IO a can derive MonadError, MonadState SomeState, MonadIO. I also forgot some parens in my definition of Foo but whatever.
16:20:32 <ReinH> At least I think MonadError is derivable there
16:20:54 <Zekka> I'm using a type synonym, not a newtype -- is this bad and should I rewrite my code to use a newtype?
16:21:19 <ReinH> Zekka: if you're using a type synonym then it already has those instances?
16:21:32 <pfurla> is http://www.haskell.org/ really down?
16:21:38 <pfurla> http://www.downforeveryoneorjustme.com/http://www.haskell.org/
16:21:39 <ReinH> Zekka: I like using a newtype so I can have nice type signatures, like foo :: MyMonad ()
16:21:42 <ReinH> pfurla: yep
16:22:00 <ReinH> and generalized newtype deriving is your friend there
16:22:37 <quchen> I think the mmorph package might be relevant here.
16:22:47 <ReinH> quchen: I don't know it :D
16:22:49 <Zekka> Maybe I'm confused -- I'm trying to bind an operation resulting in an EitherT SomeOtherType (StateT SomeType IO) when what I have is a StateT SomeType IO . I'm a little bit confused about what the typeclasses you've listed have to do with my problem (I thought they were mostly used to make it easy to lift operations to work with them)
16:23:02 <quchen> ReinH: "hoist etc"
16:23:17 <ReinH> Zekka: yep, and lifting is what you want to do :)
16:23:26 <ReinH> you have a StateT action and you want to lift it to an EitherT action
16:23:51 <yitz> @type lift
16:23:53 <lambdabot> (Monad m, MonadTrans t) => m a -> t m a
16:23:58 <Zekka> Oh, thanks
16:24:09 <Zekka> if I'm reading that right then that's exactly what I wanted
16:24:16 <ReinH> Zekka: I think the EitherT monad morphism you want is just called left?
16:24:35 <Zekka> ReinH - I was experimenting with right, let me see what the typechecker said
16:24:40 <ReinH> oh right
16:24:43 <ReinH> right, ofc
16:24:49 <ReinH> I'm wrong. It's right.
16:24:56 <ReinH> I suddenly forgot how Either worked.
16:25:22 <Zekka> I hate when Hackage is down
16:26:05 <ReinH> Zekka: you can use your local haddocks
16:26:22 <Zekka> Really? How do I pull them up?
16:26:35 <ReinH> Zekka: look for the location of the index file in ~/.cabal/config
16:26:41 <Zekka> Also my code compiled
16:26:47 <ReinH> Then it must be correct.
16:26:49 <archblob> ?src replicateM
16:26:49 <lambdabot> replicateM n x = sequence (replicate n x)
16:26:56 <Zekka> Obviously. I'll run my test program in a second
16:27:14 <archblob> ?src replicate
16:27:15 <lambdabot> replicate n x = take n (repeat x)
16:28:01 <Zekka> When I go to what seems to be the location o the docs, I get 'file not found'
16:28:09 <Zekka> one second, though
16:28:25 <Zekka> Do I have to generate them?
16:28:44 <Zekka> Oh, for better or for worse it worked perfectly
16:28:55 <Zekka> which is generally what happens when you satisfy the typechecker, I guess
16:29:22 <roboguy_> Zekka: the fpcomplete "mirror" of hackage is up
16:29:31 <roboguy_> https://www.fpcomplete.com/hoogle
16:29:45 <Zekka> Thanks, that would have saved me some time
16:30:00 <gamegoblin> Just came in here to ask about hackage
16:30:08 <gamegoblin> and here it is in the first line I read ;D
16:30:10 <Zekka> assuming this has the same featureset/is the reskinned normal Hoogle softwar
16:30:12 <Zekka> software*
16:30:20 <roboguy_> fpcomplete's hoogle is more comprehensive than regular hoogle anyway
16:30:27 <Zekka> gamegoblin - Yeah, I was griping about it
16:30:33 <gamegoblin> It's a shame hoogle.com is an unused wordpress site
16:30:55 <jcarpenter2_> I type that in all the time
16:31:44 <jcarpenter2_> How do types address russel's paradox?
16:31:47 <roboguy_> I would think that it would be a relatively high-value domain name, since h is so close to g
16:31:59 <Zekka> Thanks, folks: try/catch now work in the tiny VM I've been writing
16:32:07 <ReinH> The letters are right next to each other in both senses!
16:32:14 <roboguy_> jcarpenter2_: in what sense do you mean?
16:32:48 <ReinH> jcarpenter2_: How does Russel's Paradox address types? :p
16:33:06 <jcarpenter2_> either way
16:33:39 <jcarpenter2_> I understand that types are like propositions, but I'm not sure how you would apply that to "the set of all sets that don't contain themselves"
16:34:31 <roboguy_> jcarpenter2_: it would probably be like encoding this kind of thing in the form of dependent types: http://en.wikibooks.org/wiki/Haskell/Denotational_semantics#What_to_choose_as_Semantic_Domain.3F
16:34:33 <jcarpenter2_> Let x = the above set.  I'm guessing "x in x" or "x not in x" would be your proposition / type
16:35:19 <shelf> cabal should maintain a local haddock site
16:35:57 <roboguy_> jcarpenter2_: what does x translate to?
16:36:00 <shelf> it's crazy to be hitting up the innernets for doc lookup
16:36:10 <jcarpenter2_> x = the set of all sets that do not contain themselves
16:36:18 <roboguy_> I mean type-wise
16:36:28 <jcarpenter2_> That's a great question
16:36:47 <yesthisisuser> i want offline documentation
16:37:09 <ReinH> yesthisisuser: cabal builds haddocks for software you install so you probably already have it
16:37:17 <jcarpenter2_> I suppose that's what that other link starts to answer
16:37:37 <ReinH> yesthisisuser: look in ~/.cabal/config for the location of the index.html
16:38:00 <ReinH> s/software/packages
16:38:07 <yesthisisuser> ReinH: thanks. that was good news
16:38:54 <quchen> ReinH: Don't you have to enable the `documentation` flag in cabal.conf manually?
16:39:39 <yesthisisuser> so it should be under /usr/share/doc i think
16:40:01 <ReinH> quchen: oh maybe? I have it for most packages I care about.
16:40:14 <ReinH> oh you mean mine had that enabled
16:40:23 <ReinH> Maybe that's the default for the haskell platform
16:41:47 <gamegoblin> Does attoparsec have a way to get all of the remaining input?
16:41:53 <gamegoblin> besides I guess takeWhile True
16:41:57 <yesthisisuser> i am going to enable it anyway.. it's good to know
16:42:15 <yitz> gamegoblin: yes. but i can't look it up because hackage is down. :(
16:42:24 <johnw> gamegoblin: takeByteString
16:42:44 <TheGreekBrit> rip site
16:42:52 <gamegoblin> Thanks
16:42:57 <yitz> johnw: that sounds specific to bytestring
16:43:01 <gamegoblin> So do we know what happened to hackage?
16:43:17 <yesthisisuser> it would be great to create some offline Haddock browser like devhelp for GTK+/GNOME
16:43:23 <johnw> yitz: it's attoparsec
16:43:34 <yitz> johnw: right - used for Text.
16:43:39 <quchen> ReinH: I'm just mentioning it because I traditionally found out about the missing flag when Hackage went down.
16:43:50 <johnw> I think takeText, if you are using Attoparsec.Text
16:43:57 <gamegoblin> I'm using bytestring
16:44:08 <gamegoblin> takeByteString worked
16:44:10 <yitz> johnw: a few years ago it was only bytestring, and attoparsec-text was a separate library, but those days are long gone.
16:44:32 <johnw> well, when people ask unqualified questions about attoparsec, I speak in ByteString :)
16:44:38 <ReinH> quchen: yep, now's a great time to fix that and not be able to use it!
16:46:59 <roboguy_> jcarpenter2_: how about this? http://lpaste.net/101358
16:47:30 <roboguy_> that uses the barber paradox
16:47:38 <yitz> johnw: bytestring is really for binary bytes, not text, so the default use of attoparsec is text.
16:47:53 <johnw> when did that change?
16:48:25 <johnw> as far as I know, import Data.Attoparsec brings in the ByteString parsing code
16:49:06 <yitz> johnw: for backwards-compatibility. attoparsec was written before text existed.
16:49:33 <jcarpenter2_> roboguy_: that last line of Russel looks like it causes a paradox on its own
16:49:54 <roboguy_> jcarpenter2_: why?
16:49:57 <jcarpenter2_> Russell Ze Ze = Negate (Russell Ze Ze)
16:49:59 <jcarpenter2_> Russell*
16:50:03 <roboguy_> exactly!
16:50:21 <jcarpenter2_> so why do you need Russell One One = True and Russell Two Two = False?
16:50:37 <roboguy_> oh, well, just to make it more like the barber problem. those probably aren't needed actually
16:50:51 <jcarpenter2_> I see
16:52:17 <roboguy_> they are if you want any hope of matching certain patterns and terminating under certain conditions
16:52:17 <Zekka> Existential types aren't considered rude or anything, are they?
16:52:22 <Zekka> I just ask bcause I'm using a lot of pragmas
16:52:38 <roboguy_> Zekka: depends
16:52:46 <roboguy_> well, what do you mean by rude
16:52:55 <Zekka> Actually I may be using the wrong language extension, hold up
16:53:20 <ezrios> wawaweewa
16:53:25 <Zekka> Well, I'm worried that it means that it won't work on a lot of Haskell implementations, or it's considered bad practic
16:53:31 <Zekka> practice* -- my e key is unreliable
16:53:53 <ezrios> hackage down?
16:53:53 <roboguy_> Zekka: people use extensions all the time. that's a common one
16:53:56 <ReinH> ezrios: yep
16:54:00 <ezrios> ReinH: arg
16:54:13 <ReinH> Zekka: GHC is the de facto implementation unless you're doing something very specific
16:54:21 <roboguy_> Zekka: also at the moment, ghc is definitely the haskell implementation to use unless you have a really really good reason to do otherwise
16:54:35 <adit> ezrios: Use http://hdiff.luite.com, hackage mirror
16:54:41 <roboguy_> Zekka: most of the others are pretty unmaintained
16:54:51 <ezrios> @hoogle Either a b -> b
16:54:52 <lambdabot> Data.Either rights :: [Either a b] -> [b]
16:54:52 <lambdabot> Data.Typeable typeOf2 :: Typeable2 t => t a b -> TypeRep
16:54:52 <lambdabot> Prelude either :: (a -> c) -> (b -> c) -> Either a b -> c
16:55:21 <ezrios> adit: thanks
16:57:45 <ReinH> ezrios: such a function would be partial. You probably want to pattern match instead.
16:57:52 <Zekka> Hm. I'm trying to define a function whose type is (forall a. Num a => (a -> a -> a) -> VM (), meaning that it takes functions which can operate on two objects of any numeric type to result in a third object of that numeric type
16:58:02 <Zekka> What am I doing wrong here?
16:58:03 <ezrios> ReinH: yeah, I was looking at it and figured out it didn't really make sense
16:58:19 <roboguy_> jcarpenter2_: I was missing a case for it to be a proper barber paradox. I updated it and it should be now
16:59:19 <jcarpenter2_> roboguy_: I'm trying to compile it, but I'm getting a parse error on input 'where' on line 8
16:59:28 <roboguy_> jcarpenter2_: oh, you need ghc 7.8
16:59:37 <roboguy_> for closed type families
16:59:37 <jcarpenter2_> oh, what does that have?
16:59:39 <jcarpenter2_> oh cool
16:59:50 <roboguy_> you might be able to do it with an open type family too
17:01:12 <derek_c> is the Haskell website down?
17:01:17 <TheGreekBrit> Yes
17:01:29 <jcarpenter2_> I've been trying to look up type families there
17:01:39 <jcarpenter2_> not even the google cache will load
17:01:51 <roboguy_> jcarpenter2_: there I edited the paste with some code that will probably compile under 7.6.3
17:01:53 <jcarpenter2_> no wait, yes it did
17:02:16 <derek_c> I surely hope the backend is not written in Haskell :)
17:03:53 <ezrios> @hoogle initialPos
17:03:53 <lambdabot> Text.Parsec.Pos initialPos :: SourceName -> SourcePos
17:03:54 <lambdabot> Text.ParserCombinators.Parsec.Pos initialPos :: SourceName -> SourcePos
17:04:24 <jcarpenter2_> Now it's just conflicting family instance declarations for the Russell type family
17:04:46 <roboguy_> oh wait, you wouldn't be able to define the last case of Russell without closed type families. the rest you should be able to as type instances though
17:04:49 <jcarpenter2_> I guess you do need closed type families
17:05:48 <jcarpenter2_> you could change the last line to (Su (Su (Su x)))
17:06:46 <jcarpenter2_> Actually you apparently only need two Su's....  the False definitions don't collide
17:07:49 <roboguy_> jcarpenter2_: ok, I updated it so it should be able to work on ghc-7.6.3 and you should still see the paradox
17:08:39 <jcarpenter2_> You can also do this: http://lpaste.net/101358
17:08:58 <jcarpenter2_> right?
17:09:40 <roboguy_> jcarpenter2_: what do you mean?
17:09:45 <jcarpenter2_> yeah, that works
17:10:44 <roboguy_> I've never used full dependent types before. I wonder what it is haskell is lacking that prevents it from having them. Haskell's type system is pretty powerful...
17:11:01 <jcarpenter2_> (Su (Su x)) corresponds to all x >= 2
17:11:06 <jcarpenter2_> I've wondered the same thing
17:11:27 <gamegoblin> for parsing, are ` choice [try star, try absoluteURI, try absolutePath] ` and ` (try star) <|> (try absoluteURI) <|> (try absolutePath) ` the same thing? If so, which is faster?
17:11:40 <roboguy_> closed type families essentially give us something analogous to functions with multiple equations, but on a type level
17:11:52 <roboguy_> pattern matching on types, etc
17:13:09 <roboguy_> gamegoblin: probably about the same: choice = foldr (<|>) empty
17:13:25 <roboguy_> I'd use whichever looks better
17:13:36 <gamegoblin> mmm personally I prefer choice [...] I think
17:13:42 <roboguy_> that's what I'd go with too
17:13:58 <gamegoblin> weird infix operators look funny to my oldschool C brain
17:14:21 <gamegoblin> weird meaning not C ;)
17:14:24 <jcarpenter2_> I think weird infix operators are just unpronouncable
17:14:46 <jcarpenter2_> That's why I don't like them
17:14:57 <gamegoblin> I think it's funny in haskell libraries when they define some infix operator like "&^>" (pronounced "expect")
17:15:09 <gamegoblin> always have to include a pronunciation
17:16:27 <jcarpenter2_> I also think foo' and foo'' should be given more descriptive names
17:16:49 <thebnq> foo_prime foo_double_prime?
17:16:52 <roboguy_> some of the lens operators are named to have mnemonics that help. they can still be confusing though
17:17:03 <gamegoblin> I use prime/double prime etc
17:18:26 <roboguy_> > (map (:[]) [1..5]) & indexing traverse <<%@~ (\i x -> (i,x))
17:18:28 <lambdabot>  ([1,2,3,4,5],[(0,[1]),(1,[2]),(2,[3]),(3,[4]),(4,[5])])
17:18:47 <gamegoblin> the hell
17:19:14 <gamegoblin> Brain just melted
17:19:20 <quchen> Good old smaller smaller percent at tilde operator.
17:19:22 <thebnq> put(,) on the end :]
17:19:45 <thebnq> yay monkey operator
17:19:58 <roboguy_> > (:[]) 2
17:19:59 <lambdabot>  [2]
17:20:06 <roboguy_> ^ monkey operator?
17:20:09 <thebnq> yea
17:20:19 <ezrios> :t (<<%@~)
17:20:20 <roboguy_> % means modify (because the word sort of sounds like "modulo", which some languages use % for), @ is for index, I don't fully remember the rest
17:20:20 <lambdabot> Overloading (Indexed i) q ((,) a) s t a b -> (i -> a -> b) -> q s (a, t)
17:20:27 <ezrios> lenses?
17:20:31 <roboguy_> ezrios: yeah
17:20:40 <ezrios> o.o
17:20:50 <quchen> ~ is set because = is for State stuff
17:20:59 <roboguy_> my goal with that line of code was to figure out the <<%@~ operator, haha
17:21:16 <roboguy_> (not that it's used much anyway)
17:21:58 <ezrios> the lens library has the most obtuse infix operators I've seen
17:22:00 <ezrios> by far
17:22:08 <roboguy_> ezrios: luckily, they all have actual names too
17:22:20 <ezrios> roboguy_: yeah, there's a convention behind them
17:22:26 <ezrios> but if you don't know what it is
17:22:26 <quchen> <<%@~ doesn't :-\
17:22:29 <ezrios> you're screwed
17:22:37 <roboguy_> quchen: well, except for a couple strange ones
17:22:43 <quchen> "Adjust the target of an IndexedLens returning the old value, or adjust all of the targets of an IndexedTraversal and return a monoidal summary of the old values along with the answer."
17:22:52 <thebnq> rolls off the tongue
17:23:27 <ezrios> ah yes, the AdjustTargetAndReturnOrSum operator
17:31:31 <taktoa> what's going on with haskell.org, it seems to have been down for the last hour
17:32:31 <quchen> taktoa: http://www.reddit.com/r/haskell/comments/20o04g/unscheduled_haskellorg_and_hackage_downtime/
17:32:56 <taktoa> thanks
17:33:52 <vozz> Trying to cabal install in the directory of a module I just made, and get this https://gist.github.com/ollieh/3c14387b97897edd0bde Could not resolve dependencies, with no helpful output as to what went wrong. What should I do?
17:38:01 <tac> oh yay, haskell.org is back from the dead
17:38:02 <yesthisisuser> it is back!! :)
17:53:47 <ezrios> @pl (\x -> f x (sum x))
17:53:48 <lambdabot> ap f sum
17:53:57 <ezrios> neato
18:00:44 <Duta> Does anyone know of a crossplatform way to read a char from stdin without echoing?
18:01:19 <Algebr> Is there a less hideous way than this? digitToInt $ last $ take 3 "I 4"
18:01:54 <roboguy_> Duta: I don't think there's a crossplatform way
18:01:55 <no-n> the take 3 isn't needed
18:01:59 <Duta> Algebr, take 3 isn't needed
18:02:11 <Duta> So just digitToInt $ last "I 4"
18:02:18 <Duta> And roboguy, damn
18:02:38 <roboguy_> Algebr: how about read . (:[]) $ last "I 4"?
18:02:41 <Algebr> Duta, sorry, It isn't needed in this example, but it could in other, imagine the string is longer, my bad about the example not being fully correct.
18:03:08 <Duta> Well it doesn't look that hideous to me
18:03:12 <Duta> If you want hideous:
18:03:13 <Algebr> roboguy_: That lookes amazing, but I need a second to understand it
18:03:20 <no-n> map digitToInt $ filter isDigit "I 4"
18:03:37 <Duta> pl digitToInt $ last $ take 3 "I 4"
18:03:39 <Duta> :pl digitToInt $ last $ take 3 "I 4"
18:03:45 <Duta> @pl digitToInt $ last $ take 3 "I 4"
18:03:46 <lambdabot> digitToInt (last (take 3 "I 4"))
18:03:48 <Algebr> So having $'s everywhere is normal course of haskell programming?
18:03:51 <roboguy_> Algebr: some people don't like (:[]) and you could replace it with (\x -> [x])
18:04:17 <Duta> I personally prefer \x -> [x]
18:04:22 <Duta> But it's taste
18:04:23 <roboguy_> Algebr: I like to use a lot of .s and then $ once, like f . g . h $ someFunction x
18:04:36 <roboguy_> instead of f $ g $ h $ someFunction x
18:04:49 <k00mi> Algebr: what exactly do you want to do? what does your input look like?
18:04:59 <Duta> Although in that case you don't need the $s
18:05:01 <Zekka> I tend to do the same thing Roboguy does, partially because I write a lot of point-free code
18:05:33 <Algebr> k00mi: I'm trying to parse a pseduo log message, the message could be like "I 21 4 blah blah"
18:05:53 <Duta> What would you want output from that string?
18:06:01 <Duta> 21? 4? [21, 4]?
18:06:21 <Algebr> Duta: I want to get the first integer instance in that string, so in that previous case, I want the 21.
18:06:38 <Algebr> I was going to handle the case of single digits first, then arbitrary digits
18:06:43 <Algebr> aka, the 21.
18:07:00 <Duta> Well the obvious way is to dropWhile it isn't a digit, and then takeWhile it's a digit
18:07:10 <Duta> But there's probably a better way.
18:07:20 <no-n> what about find (all isDigit) . words
18:07:42 <Algebr> Duta: I was gonna try takeWhile not getting an empty space or char
18:07:46 <Duta> no-n, I think that'll be different to what's required
18:07:48 <roboguy_> > fmap read . find (all isDigit) $ words "I 21 4 blah blah" :: Maybe Int
18:07:49 <lambdabot>  Just 21
18:07:50 <Duta> I may be wrong
18:08:01 <Duta> Oh, I am wrong
18:10:13 <Duta> What I'd have gone for is something like
18:11:37 <Duta> trim = takeWhile isDigit . dropWhile (not . isDigit)
18:11:56 <Duta> Which turns "I 21 4 blah blah" into "21" for easy conversion
18:12:12 <k00mi> > fmap fst . listToMaybe . reads . dropWhile (not . isDigit) $ "I 21 4 blah blah" :: Maybe Int
18:12:13 <lambdabot>  Just 21
18:12:22 <Algebr> Duta: Ah! That's awesome, I'll go with that. Thank you!
18:13:48 <stolaruk> Are there any good tutorials out there that explain how to use QuickCheck test case generation tricks and test data modifiers?
18:16:51 <roboguy_> Algebr: how do you want something like "abc123def 56" to read?
18:17:34 <Duta> Algebr, two things
18:17:40 <Duta> 1) roboguy has a good question
18:17:46 <Duta> 2) read . takeWhile isDigit . dropWhile (not . isDigit)
18:18:18 <vozz> If I have a [(ByteString, ByteString)], say there may or may not be a ("test", somethingelse) in there, what would be the cleanest way of replacing it with ("test, "something") if it exists, or adding it if it doesn't?
18:18:27 <Algebr> roboguy_: It won't be an issue because I always know the strings will be in the format of "<someChar>' ' <someInt>..."
18:20:44 <Twey> vozz: The cleanest way would be using a Map instead, like you seem to want
18:21:13 <vozz> Twey: Okay, thanks.
18:22:00 <Twey> vozz: Then there's a function ‘insert’ that does what you want
18:23:26 <Duta> insert doesn't do what he wants
18:23:42 <Duta> It inserts rather than replaces
18:24:17 <vozz> Is there a way to convert from a list of tuples to a map?
18:24:25 <vozz> and convert back?
18:25:24 <pavonia> @hoogle Map k v -> [(k, v)]
18:25:25 <lambdabot> Data.Map.Lazy assocs :: Map k a -> [(k, a)]
18:25:25 <lambdabot> Data.Map.Strict assocs :: Map k a -> [(k, a)]
18:25:25 <lambdabot> Data.Map.Lazy toAscList :: Map k a -> [(k, a)]
18:25:56 <roboguy_> Duta: doesn't insert replace something if it is already in the map?
18:26:04 <orbital> is there a library function to invert an Ordering?
18:26:27 <Duta> vozz, Map.fromList?
18:26:49 <roboguy_> vozz: you need to convert it back?
18:27:06 <roboguy_> orbital: Down
18:27:33 <Duta> assocs :: Map k v -> [(k, v)]
18:27:43 <roboguy_> orbital: "Ord a => Down a" has the reverse Ord as type a
18:27:46 <vozz> roboguy_: Yes
18:27:46 <Duta> fromList :: [(k, v)] -> Map k v
18:27:57 <roboguy_> vozz: hmm. that makes me think that this isn't the most efficient way
18:28:10 <roboguy_> vozz: why do you need to convert it back?
18:29:14 <vozz> The redis library gives me a list of ByteString tuples, and I need to give it back the list modified to set it to a different value
18:29:22 <orbital> roboguy_: thanks
18:29:47 * hackagebot arithmoi 0.4.0.4 - Efficient basic number-theoretic functions.  Primes, powers, integer logarithms.  http://hackage.haskell.org/package/arithmoi-0.4.0.4 (DanielFischer)
18:30:42 <vozz> I think I might just filter the list and then append the thing i want in there
18:32:24 <stolaruk> Is there a good way to tell QuickCheck to generate a long list?
18:32:32 <stolaruk> Like 80+ elements
18:33:54 <johnw> replicate 80 arbitrary?
18:34:24 <stolaruk> johnw: I'm doing something a bit like that
18:34:58 <stolaruk> I guess I'm wondering if there is a neat trick to do this built into the QC API
18:35:06 <stolaruk> perhaps not
18:47:30 <ezrios> :t (.) . (.)
18:47:31 <lambdabot> (b -> c) -> (a -> a1 -> b) -> a -> a1 -> c
18:47:36 <ezrios> Why a and a1?
18:48:11 <ezrios> why not something like (c -> d) -> (a -> b -> c) -> a -> b -> d
18:48:27 <BMeph> :t (.)
18:48:28 <lambdabot> (b -> c) -> (a -> b) -> a -> c
18:48:45 <BMeph> ezrios: Because that. ;)
18:49:04 <ezrios> BMeph: I don't follow
18:49:28 <ezrios> When does GHC decide to subscript a type variable
18:49:32 <enthropy> ghc tries to give you the type variables you tell it back
18:49:35 <ezrios> as opposed to just making a new one
18:49:44 <ezrios> ah hm
18:49:53 <ezrios> enthropy: aaah okay
18:50:34 <enthropy> the 'a1' used to be an 'a', but that was already taken
18:50:55 <ezrios> gotcha
18:51:23 <BMeph> ((b -> c) -> ((a -> b) -> a -> c)) . ((b1 -> c1) -> (a1 -> b1) -> a1 -> c1)
18:52:17 <fredM> hi everyone
18:52:32 <ezrios> is the boobs combinator bad style?
18:52:38 <Duta> Is there a nice way to do this without the explicit xs?
18:52:41 <ezrios> or is this a common haskell idiom
18:52:42 <Duta> replace kv xs = kv:filter (((/=) `on` fst) kv) xs
18:52:43 <joelteon> I thought it was called the monkey combinator
18:52:51 <ezrios> joelteon: I thought that was (:[])
18:52:56 <joelteon> oh, that is (:[])
18:52:57 <joelteon> never mind
18:53:01 <joelteon> (.).(.) doesn't even look like a monkey
18:53:04 <ezrios> the boobs combinator is (.) . (.)
18:53:31 * BMeph sends Greetings From Eroticon 6! ;þ
18:54:08 <Duta> vozz, you still here?
18:54:32 <fredM> Can someone help me
18:54:52 <fredM> I wrote a program that do this
18:54:57 <fredM> disjunction “programming” “software” =>“pgminsftwe”
18:54:57 <fredM> disjunction “programming” “software” =>“pgminsftwe”
18:54:57 <BMeph> Duta: That would be: " replace kv = (kv:) . filter (((/=) `on` fst) kv)
18:55:10 <fredM> my code is this
18:55:11 <fredM> disjunction :: Eq(a) => [a] -> [a] -> [a]
18:55:11 <fredM> disjunction [] _  = []
18:55:11 <fredM> disjunction _ []  = []
18:55:11 <fredM> disjunction xs ys = (disjunct xs ys) ++ (disjunct ys xs)
18:55:27 <BMeph> > “programming” // “software”
18:55:28 <lambdabot>  <hint>:1:1: lexical error at character '\8220'
18:55:34 <fredM> is there a shorter and a nicer way ?
18:55:38 <BMeph> ...
18:55:42 <ezrios> > "programming" \\ "software"
18:55:44 <lambdabot>  "pgrmming"
18:55:46 <Algebr> Where does cabal actually save the downloads of packages?
18:55:47 <Iceland_jack> fredM: Please use lpaste for pasting code
18:55:48 <mjrosenb> > "programming" \\ "software
18:55:49 <ezrios> BMeph: I made the same mistake
18:55:50 <lambdabot>  <hint>:1:27:
18:55:50 <lambdabot>      lexical error in string/character literal at end of input
18:55:50 <Iceland_jack> @lpaste
18:55:50 <mjrosenb> efb
18:55:50 <lambdabot> Haskell pastebin: http://lpaste.net/
18:56:30 <fredM> http://lpaste.net/101369
18:56:32 <fredM> here
18:56:50 <fredM> what the code is
18:56:53 <fredM> take two list
18:57:33 <fredM> and show show the letters that is in both list
18:57:36 <fredM> but
18:57:41 <fredM> show is only 1 time
18:57:46 <fredM> my code is to long
18:58:03 <Iceland_jack> fredM: The recursive calls call the wrong function, also the logic is wrong
18:58:09 <fredM> i wonder if it can be written in a shorter way
18:58:44 <Iceland_jack> At no point to you use your Eq constraint (using (==) or (/=))
19:02:44 <Duta> map (\x -> [x]) [1, 2, 3, 4, 5] :: [[Int]]
19:02:57 <Iceland_jack> > map (\x -> [x]) [1, 2, 3, 4, 5] :: [[Int]]
19:02:58 <lambdabot>  [[1],[2],[3],[4],[5]]
19:03:12 <Duta> > map (:[]) [1, 2, 3, 4, 5] :: [[Int]]
19:03:13 <lambdabot>  [[1],[2],[3],[4],[5]]
19:03:23 <Duta> > map return [1, 2, 3, 4, 5] :: [[Int]]
19:03:24 <lambdabot>  [[1],[2],[3],[4],[5]]
19:05:47 <roboguy_> > let (x, y) = ("programming", "software") in ((y `union` x) \\ y) ++ ((x `union` y) \\ x)
19:05:48 <lambdabot>  "pgminsftwe"
19:06:28 <gwz> hey how can I insert something to a specific index in a list
19:06:46 <roboguy_> gwz: if you need to do that a lot, you should consider using something other than a list
19:07:26 <enthropy> @type \x n xs -> let (a,b) = splitAt n xs in a ++ x : b
19:07:27 <lambdabot> a -> Int -> [a] -> [a]
19:07:29 <gwz> what other ds would suit that need?
19:07:33 <enthropy> @pl \x n xs -> let (a,b) = splitAt n xs in a ++ x : b
19:07:34 <lambdabot> (line 1, column 16):
19:07:34 <lambdabot> unexpected "("
19:07:34 <lambdabot> expecting "()", natural, identifier or "in"
19:07:38 <roboguy_> gwz: Vector and Arrau
19:07:39 <roboguy_> *Array
19:07:51 <roboguy_> and maybe IntMap, depending on what you need
19:07:53 <mvr_> I'm trying to implement an algorithm where objects can be added one by one. I'll need to track the 'time' an object was added, i.e. that this object is the 12th to be added. What is a good way to do this? Is there a way to do that without cluttering the object with an Int field?
19:08:34 <Duta> Store it as a tuple of the object and an int?
19:09:21 <mvr_> I'd like to be able to quickly find the object given an index and vice versa, is there some data structure that will let me do that?
19:09:49 <Duta> Are you going to want to do a lot of removing?
19:09:58 <enthropy> gwz: I would use Data.Sequence for such a thing
19:10:11 <Duta> So basically you want a bidirectional map
19:10:32 <enthropy> updates to Array and Vector involve lots of copying too
19:13:46 <gwz> enthropy: thanks
19:19:30 <gwz> how do you add stuff to a sequence, (<|) doesnt work
19:20:23 <roboguy_> gwz: what do you mean doesn't work
19:24:03 <Algebr> How do you guys think about when solving a problem, like I mean for example when solving a problem, do you start with thinking from building up from what you start with, say a string, and up and up until you get your desired result or do you start from desired result and figure out how to get down to what you start with. Sorry if that's unclear.
19:25:09 <ezrios> look at your starting types and your end types
19:25:12 <ezrios> try to bridge the gap
19:27:05 <roboguy_> Algebr: I'll second what ezrios said. type holes can help with that style too
19:27:42 <Algebr> What's a type hole? Is that like a placeholder?
19:28:12 <ezrios> is old-locale deprecated or something?
19:28:30 <tikhon> pretty much: you just leave a _ in your code, and the compiler will tell you what type it expects there
19:28:31 <ezrios> it is the only package I can find that has constructors for TimeLocale
19:28:34 <Iceland_jack> Algebr: It's like a placeholder that you can get the type of
19:28:52 <geekosaur> it's... confusing. (old-locale)
19:28:53 <tikhon> they're going to be part of the next GHC release
19:29:06 <ezrios> geekosaur: should I just add this to build-depends or something
19:29:18 <geekosaur> yes
19:29:43 <roboguy_> lambdabot doesn't have type holes yet, does it?
19:29:52 <Algebr> Iceland_jack: Neat, reading up on that now. Never heard of it before.
19:29:52 <roboguy_> > 1 + _
19:29:53 <lambdabot>  Pattern syntax in expression context: _
19:30:20 <Iceland_jack> Algebr: You should check out Agda if only for the excellent editor integration it has
19:30:54 <Algebr> Iceland_jack: Whoa, never heard of that either, reading up.
19:31:07 <Iceland_jack> where you can take a function
19:31:07 <Iceland_jack>     foo :: Ordering -> ...
19:31:07 <Iceland_jack>     foo a = ?
19:31:07 <Iceland_jack> and expand it to
19:31:10 <Iceland_jack>     foo :: Ordering -> ...
19:31:13 <Iceland_jack>     foo LT = ...
19:31:17 <Iceland_jack>     foo EQ = ...
19:31:20 <Iceland_jack>     foo GT = ...
19:33:23 <geekosaur> ezrios: I've heard an official explanation but can't find it right now. but, more or less, someone back in the day thought that the locale package was tightly associated with the time package; that time package was deprectaed to old-time and is now gone. old-locale hangs on, nobody willing to make it a proper locale package instead of just a thing used by time
19:33:50 <irene-knapp> essentially, yes (although I missed the question)
19:33:54 <ezrios> geekosaur: ._.
19:34:08 <irene-knapp> locale is related to time in this way: what timezone the user wants to see things in is probably part of the locale
19:34:21 <geekosaur> but it's wrong, isn't it? hardcoded to US
19:34:31 <irene-knapp> is it really?
19:34:40 <irene-knapp> maybe in the "C" locale, haha
19:34:41 <geekosaur> my recollection is it's %m/%d/%Y
19:34:47 <irene-knapp> oh, the time zone, not the time format
19:34:53 <irene-knapp> although time format is part of it too in principle
19:36:50 <geekosaur> it has nothing but time formats and it hardcodes US time formats for the default (but also provides ISO8601 and RFC822)
19:37:02 <geekosaur> note that it is pure, so it *can't* actually look at your locale
19:37:17 <escondida> Hey, folks, trying to work with Network.MPD; any time I try to get at the contents of `withMPD currentSong' (say, by using either or by matching with case), I get "Couldn't match expected type `Either a0 (Maybe a1)' with actual type `IO (Response (Maybe Song))'", despite the fact that "type Response = Either MPDError" and Response is exported in Network.MPD.Core. Thoughts?
19:38:26 <tikhon> escondida: maybe it's a problem with the IO part of the type?
19:38:27 <Iceland_jack> escondida: Because one of the type is 'IO a' and the other is 'a'
19:38:27 <geekosaur> (also I have no idea why it hardcodes US defaults when GHC HQ is MSR Cambridge...)
19:41:33 <escondida> ah
19:42:41 <Iceland_jack> Just like you can't do
19:42:41 <Iceland_jack> @ty "hello" ++ getLine
19:42:42 <lambdabot>     Couldn't match expected type `[Char]' with actual type `IO String'
19:42:42 <lambdabot>     In the second argument of `(++)', namely `getLine'
19:42:42 <lambdabot>     In the expression: "hello" ++ getLine
19:43:11 <Iceland_jack> Since (getLine :: IO String) and (("hello" ++) :: String -> String)
19:43:32 <Iceland_jack> @ty fmap ("hello" ++) getLine
19:43:33 <lambdabot> IO [Char]
19:43:48 <Iceland_jack> @ty fmap length getLine
19:43:49 <lambdabot> IO Int
19:45:23 <escondida> Cool
19:48:02 <thebnq> is it bad that i want to replace every fmap i see with <$>, i don't see any advantage to fmap
19:48:39 <roboguy_> thebnq: precedence
19:49:11 <Iceland_jack> thebnq: When introducing it for the first time, I will use 'fmap'
19:49:15 <enthropy> fmap f . g  vs.  (f <$>) . g
19:49:24 <ezrios> thebnq: what about when creating new functions via composition
19:49:30 <ezrios> let allCaps = fmap toUpper
19:49:39 <ezrios> that's not even composition actually
19:49:46 <thebnq> enthropy: ah thats a nice situation for fmap
19:52:40 <escondida> Iceland_jack: But wait; if it's all in a do block (do $ np <- withMPD currentSong \n either (return Nothing) id np), shouldn't the io just sort of take care of itself?
19:54:21 <Iceland_jack> escondida: You still need to match up the types, for the previous example
19:54:21 <Iceland_jack>     do "hello" ++ getLine
19:54:21 <Iceland_jack> would still not type check
19:54:36 <Iceland_jack> You'd have to do
19:54:36 <Iceland_jack>     do line <- getLine
19:54:36 <Iceland_jack>        return ("hello" ++ line)
19:54:46 <Iceland_jack> (where 'line :: String')
19:55:31 <escondida> Ah, right.
19:55:50 <stolaruk> I have lots of functions stuck inside a monad transformer stack. Would it be possible to write QuickCheck properties for them?
19:56:06 <RustyShackleford> how do you wrap your head around functional programming?
19:56:14 <roboguy_> do notation kind of reminds me of a-normal form
19:56:15 <benzrf> hej da
19:56:18 <Iceland_jack> stolaruk: Sure, you just need to ‘run*’ them
19:56:22 <benzrf> i just wrote this as a joke in ##programming:
19:56:22 <benzrf> sequence_ $ repeat $ StateT (\v -> ((), (v + 1)) <$ countSheep)
19:56:27 <RustyShackleford> I tried learning some haskell a while back. I got the hang of some syntax, but I couldn't DO anything
19:56:33 <benzrf> but actually is there a better way of doing that
19:56:52 <Iceland_jack> RustyShackleford: For how long did you learn it? What would you consider doing something?
19:56:54 <roboguy_> RustyShackleford: well, try writing some programs and then see where you run into trouble
19:56:55 <ezrios> RustyShackleford: there is significantly more investment in learning Haskell before getting to the point where you can "do" something
19:57:08 <stolaruk> Iceland_jack: So in the property run it to yield the result outside the monad, then test my property against that?
19:57:16 <RustyShackleford> i was trying to do some project eulers
19:57:22 <ezrios> I've been dabbling for about 6 months now and am only just starting to write some sort of "useful" program
19:57:31 <Iceland_jack> stolaruk: Yes, if you have an IO property you can also use Test.QuickCheck.Monadic
19:57:43 <benzrf> i mostly use haskell to dick around with mathy stuff
19:57:44 <ezrios> RustyShackleford: try picking up a good book
19:57:44 <RustyShackleford> problem is, I think procedurally
19:57:50 <benzrf> RustyShackleford: so does everybody
19:57:53 <roboguy_> RustyShackleford: practice
19:57:58 <benzrf> it;s cuz youve been writing procedural cod3
19:57:59 <roboguy_> that's pretty much the answer
19:57:59 <stolaruk> Iceland_jack: That is AWESOME. Thanks
19:58:00 <benzrf> *code
19:58:16 <benzrf> RustyShackleford: you just need to write a buttload of haskell and it will start coming naturally
19:58:19 <benzrf> fp i mean
19:58:39 <Iceland_jack> stolaruk: ;) it has saved my ass plenty of times before, it's actually a very nice way to test other programs by piping them together and using QuickCheck to feed data into the pipe
19:58:55 <ezrios> I am writing a CSV parser. Say I come across an empty cell (e.g. ",,") - can I default this to something like, "0.00"
19:59:02 <ezrios> inside Parsec
19:59:03 <Iceland_jack> RustyShackleford: Could you write a program that counts the number of lines of a file?
19:59:13 <ezrios> or is this something that should really be done outside of Parsec
19:59:14 <Iceland_jack> If not, that might be a good place to start
19:59:16 <Roklobsta> RustyShackleford: hint, it's a one liner.
19:59:41 <RustyShackleford> Its been a while since I last attempted Haskell, so probably not
19:59:50 <roboguy_> Roklobsta: an efficient project euler solution is always one line?
19:59:52 <Iceland_jack> RustyShackleford: Do you know how to the the contents of a file?
20:00:03 <Iceland_jack> *how to get
20:00:12 <RustyShackleford> i didn't get into file manipulation before I gave up
20:00:16 <Iceland_jack> @type readFile
20:00:17 <lambdabot> FilePath -> IO String
20:00:23 <benzrf> RustyShackleford: do u know about monads?
20:00:27 <RustyShackleford> i'm not at all familiar with the standard library
20:00:32 <benzrf> ezrios: i dont see why not
20:00:44 <benzrf> ezrios: the point of parsec is that you interleave data-building with parsing
20:00:49 <benzrf> it's monadic!
20:00:54 <Iceland_jack> RustyShackleford: Would you like to see a possible solution?
20:01:17 <ezrios> benzrf: okay, how do I check that a cell is empty?
20:01:27 <benzrf> huh?
20:01:52 <benzrf> ...check if youve parsed an empty string?
20:01:58 <benzrf> *the value returned, i mean
20:02:06 <stolaruk> Iceland_jack: A quick glance at the Test.QuickCheck.Monadic API on Hackage makes it look a little intimidating
20:02:08 <benzrf> wait, is this a general-purpose csv parser?
20:02:10 <ezrios> say I have cells `sepBy` char ','
20:02:15 <benzrf> maybe it should be handled elsewhere ;p
20:02:17 <Iceland_jack> stolaruk: You can ask me if you need any help
20:02:18 <Iceland_jack> RustyShackleford:
20:02:19 <Iceland_jack>     fileLines :: FilePath -> IO Int
20:02:19 <Iceland_jack>     fileLines path = do
20:02:20 <Iceland_jack>       content <- readFile path
20:02:23 <Iceland_jack>       return (length (words content))
20:02:23 <ezrios> hum
20:02:37 <stolaruk> Iceland_jack: Awesome, thanks!
20:02:38 <ezrios> I mean, I guess I could repurpose it to this specific CSV
20:02:43 <johannes__> live coding :)
20:02:43 <ezrios> whose format is known
20:03:07 <Iceland_jack> A shorter version would be
20:03:07 <Iceland_jack>     fileLength path = length . words <$> readFile path
20:03:07 <Iceland_jack> (but you can ignore it for now)
20:03:46 <benzrf> :t modify
20:03:47 <lambdabot> MonadState s m => (s -> s) -> m ()
20:03:54 <joelteon> is there a typeclass like class DefaultM a where def :: forall m. Monad m => m a
20:04:07 <Iceland_jack> stolaruk: The basic format is something like
20:04:07 <Iceland_jack>     prop_io ... = monadicIO $ do
20:04:07 <Iceland_jack>       a <- run {- IO action -}
20:04:07 <Iceland_jack>       b <- run {- IO action -}
20:04:10 <Iceland_jack>       assert (a == b)
20:04:55 <benzrf> :i MonadState
20:05:10 <benzrf> joelteon: what would be the point of that o.O
20:05:45 <joelteon> good question
20:05:59 <benzrf> :t liftIO
20:06:00 <lambdabot> MonadIO m => IO a -> m a
20:06:15 <roboguy_> joelteon: isn't that just return def (from Data.Default)?
20:06:28 <stolaruk> Iceland_jack: Looks simple enough. My monad stack is of type "StateT WorldState IO a", so being that it ends in "IO a" would it be easy enough to make monadic properties for it?
20:06:30 <joelteon> yeah, guess so
20:06:36 <Twey> Who manages lambdabot these days?  How would we get her in ##programming?
20:06:51 <benzrf> @join ##programming
20:06:51 <lambdabot> Not enough privileges
20:06:53 <benzrf> dang
20:06:57 <ezrios> Twey: isn't it open sourced?
20:07:07 <Twey> Sure
20:07:11 <benzrf> 11:02 [Freenode] -!- lambdabot [~lambdabot@silicon.int-e.eu]
20:07:14 <Twey> But she's already in about fifty channels :þ
20:07:20 <Twey> int-e: Hi!
20:07:29 <joelteon> she's in 3
20:07:36 <joelteon> which is pretty close to 50 on a galactic scale
20:07:40 <Twey> Is that all?  She used to be in loads
20:07:51 <Iceland_jack> stolaruk: Yes, as long as you have an IO action you can run and test some property of its output
20:08:20 <roboguy_> what're the use cases for Data.Default?
20:08:30 <stolaruk> Iceland_jack: Well it that's the case then QC is pretty damn awesome, nice.
20:09:03 <Iceland_jack> Yes, you can also use the monadic QuickCheck to test ST properties
20:09:36 <Iceland_jack> Monadic QuickCheck is horribly under-documented (except for a paper) and under-appreciated imo
20:09:46 <Iceland_jack> stolaruk: http://stackoverflow.com/questions/2259926/testing-io-actions-with-monadic-quickcheck
20:10:31 <stolaruk> Thanks for the link
20:10:56 <Iceland_jack> You should be able to find the paper from the SO question as well
20:11:13 <stolaruk> ok cool I see there is a paper for which there is a link on the hackage
20:11:22 <stolaruk> This one: http://www.cse.chalmers.se/~rjmh/Papers/QuickCheckST.ps
20:11:44 <stolaruk> YEah same ppr
20:11:44 <Twey> roboguy_: It's just a typeclass of convenience, to save you having to think up a bunch of different names for your default values
20:12:05 <Iceland_jack> The paper focuses a lot on the ST part of it though
20:12:10 <roboguy_> Twey: it seems like it could lead to some confusion though, since there are no rules about how to make instances
20:12:13 <Twey> roboguy_: You'll probably never actually write code that's polymorphic in the Default instance, because the typeclass has no laws
20:13:16 <Twey> roboguy_: def is just ‘the normal thing to pass’, whatever ‘normal’ means for your type
20:13:35 <Twey> Usually it's used for configuration defaults
20:13:58 <roboguy_> Twey: why are there instances for Int, etc? that seems confusing
20:14:31 <Twey> Yeah, it's not a particularly well-behaved class
20:15:00 * hackagebot scottish 0.1.0.1 - scotty with batteries included  http://hackage.haskell.org/package/scottish-0.1.0.1 (echaozh)
20:15:47 <Twey> Also all its code is scattered about a bunch of packages, apparently
20:16:00 <roboguy_> I guess there are cases where there can only be one (reasonable) instance though, like [a]
20:16:17 <Twey> Dependencies: base (>=2 && <5), data-default-class, data-default-instances-base, data-default-instances-containers, data-default-instances-dlist, data-default-instances-old-locale
20:16:39 <Twey> roboguy_: I think it's more for big ‘configuration dictionary’ types, like in Pandoc
20:16:49 <roboguy_> ah
20:26:31 <escondida> Iceland_jack: By the way, thanks for the help. I seem to be on the right track now.
20:26:43 <escondida> (thanks to your advice)
20:28:21 <Iceland_jack> escondida: Glad to hear it, the whole ‘IO’ part of Haskell is a common source of confusion but once you get used to it it's quite natural
20:28:40 <escondida> Hopefully I'll get there one of these days (-:
20:28:53 <Iceland_jack> Since you can't do something like
20:28:53 <Iceland_jack>     getLine ++ getLine
20:28:53 <Iceland_jack> like you would in other languages because of the type mismatch
20:29:16 <escondida> Heh, right
20:29:32 <Iceland_jack> You can however do any of the following
20:29:32 <Iceland_jack>     do a <- getLine
20:29:32 <Iceland_jack>        b <- getLine
20:29:32 <Iceland_jack>        return (a ++ b)
20:29:35 <Iceland_jack> or
20:29:38 <Iceland_jack>     liftA2 (++) getLine getLine
20:29:42 <Iceland_jack> or
20:29:46 <Iceland_jack>     (++) <$> getLine <*> getLine
20:29:48 <Iceland_jack> depending on how terse and cryptic you want to be :)
20:30:03 <escondida> The more terse and cryptic, the better, right? Who needs maintainable code?
20:30:09 <Iceland_jack> Exactly!
20:30:22 <stolaruk> What confused me the most is that code in the IO monad is often called "impure", however Haskell code in the IO monad does not break referrential transparency.
20:30:40 <tikhon> the <$> and <*> idiom is really common; I don't think it's particularly cryptic
20:30:41 <stolaruk> The "impure" part of it is handled by the runtime
20:31:12 <tikhon> of course, with idiom brackets, you could write (|getLine ++ getLine|)
20:31:42 <Iceland_jack> stolaruk: Yes, because if you have
20:31:42 <Iceland_jack>     do putChar 'a'
20:31:42 <Iceland_jack>        putChar 'a'
20:31:42 <Iceland_jack> you know that
20:31:45 <Iceland_jack>     let foo = putChar 'a'
20:31:48 <Iceland_jack>     in do foo; foo
20:31:53 <Iceland_jack> is equivalent
20:32:07 <stolaruk> sure
20:32:12 <tikhon> people call it "impure" because it's convenient and there's no other obvious term for it
20:32:25 <tikhon> after all, there is certainly a practical distinction between IO code and non-IO code
20:32:41 <tikhon> a lot of terms get (ab)used this way
20:32:55 <stolaruk> It's monadic vs. non-monadic
20:32:59 <Iceland_jack> stolaruk: A nice way of looking at it is that a distinction is made between evaluating code and executing it
20:33:07 <stolaruk> right
20:33:10 <tikhon> stolaruk: that covers a lot more than just IO
20:33:18 <tikhon> I mean, you could call it IO code and non-IO code
20:33:26 <stolaruk> yes
20:33:29 <tikhon> which is what I would probably say, come to think of it
20:33:33 <Iceland_jack> If you have a function
20:33:33 <Iceland_jack>     doTwice :: IO () -> IO ()
20:33:33 <Iceland_jack>     doTwice action = do
20:33:33 <Iceland_jack>       action
20:33:36 <Iceland_jack>       action
20:33:48 <tikhon> or maybe code "in IO"
20:33:52 <Iceland_jack> You can easily evaluated
20:33:53 <Iceland_jack>     main = doTwice (print 1)
20:33:53 <Iceland_jack> to
20:33:53 <Iceland_jack>     main = do
20:33:56 <Iceland_jack>       print 1
20:34:01 <Iceland_jack>       print 1
20:34:04 <Iceland_jack> *evaluate
20:34:11 <tikhon> but I don't think calling it "impure" is so horrible, even if it isn't entirely correct
20:34:22 <benzrf> bbl
20:35:14 <tikhon> out of curiosity, does anyone else here use Hakyll?
20:35:21 <Iceland_jack> stolaruk: While if you see
20:35:21 <Iceland_jack>     raw_input() + raw_input()
20:35:21 <Iceland_jack> in Python you can't mindlessly do
20:35:23 <stolaruk> tikhon: Yeah, as long as one understands that "impure" monadic code does not break ref. trans. I was personally very confused by the fact that it is so-called "impure" even tho the code itself is pure in so much as it is ref. trans
20:35:24 <Iceland_jack>     foo = raw_input()
20:35:28 <Iceland_jack>     foo + foo
20:35:58 <Iceland_jack> stolaruk: A nice analogy is shell scripts
20:36:31 <Iceland_jack> You can ‘purely’ create shell scripts by string concatenation (evaluation), but of course they are effectful once you run them
20:36:38 <tikhon> stolaruk: overall, it feels like the underlying issue you brought up is one of the things that confuses people the most when they start learning Haskell and trying to deal with IO
20:37:02 <tikhon> it's difficult to explain exactly how things work and differentiate from the IO action and the result of running it
20:37:15 <stolaruk> tikhon: Yeah in fact I believe that I've seen a blog post somewhere that goes to great lengths to discuss this very issue
20:37:23 <tikhon> hah, I was just going to say the same thing
20:37:27 <Iceland_jack>     $ one=l
20:37:27 <Iceland_jack>     $ two=s
20:37:27 <Iceland_jack>     $ cmd=$one$two
20:37:27 <Iceland_jack>     $ echo $cmd     # pure
20:37:30 <Iceland_jack>     ls
20:37:31 <tikhon> don't remember the exact blog though
20:37:46 <tikhon> Maybe it was Tekmo's? I think he had a good IO tutorial.
20:37:48 <Iceland_jack>     $ $cmd      # impure
20:37:48 <Iceland_jack>     <directory listing>
20:38:06 <tikhon> and he's very, umm, enthusiastic about free monads, which lend themselves really well to this sort of understanding
20:38:12 <Iceland_jack> (of course running ‘echo’ is impure but hey) ;)
20:39:01 <stolaruk> Iceland_jack: I think I see your point
20:39:27 <stolaruk> The variable "$cmd" is mutable
20:39:48 <Iceland_jack> 'cmd' could just as well be immutable
20:40:17 <stolaruk> oh so your point is regarding the execution of the command inside the var?
20:40:32 <stolaruk> vs the purity of the code?
20:40:37 <Iceland_jack> My point is that the ‘construction’ of the shell script is pure: simple string concatenation
20:40:56 <Iceland_jack> Just like writing
20:40:56 <Iceland_jack>     do action1; action2
20:40:56 <Iceland_jack> is pure
20:41:11 <stolaruk> ok
20:48:33 <gwz> hey for data.sequence, do I just do a |> 2 to add it to the sequence
20:49:29 <joneshf-laptop> if i have a function:: a -> a -> Maybe a how can i use this with scanl?
20:49:38 <joneshf-laptop> can i use it with scanl?
20:49:51 <tikhon> :t scanl
20:49:52 <lambdabot> (a -> b -> a) -> a -> [b] -> [a]
20:50:09 <tikhon> so you can't use it directly
20:50:10 <stolaruk> :t scanM
20:50:10 <lambdabot>     Not in scope: `scanM'
20:50:11 <lambdabot>     Perhaps you meant one of these:
20:50:11 <lambdabot>       `scanl' (imported from Data.List),
20:50:21 <tikhon> @hoogle scanM
20:50:21 <lambdabot> No results found
20:50:31 <tikhon> how exactly do you want the Maybe part to work?
20:51:04 <pavonia> gwz: yes
20:52:01 <gwz> pavonia: how would I add multiple items
20:52:36 <joneshf-laptop> i just decided to change the function
20:52:42 <joneshf-laptop> easier that way
20:53:01 <tikhon> yeah, that's probably a reasonable solution
20:53:07 <pavonia> gwz: calling (|>) multiple times, I guess
20:53:09 <Iceland_jack> :t foldl (Data.Sequence.|>) ?foo [1,2,3]
20:53:09 <lambdabot> (Num b, ?foo::Seq.Seq b) => Seq.Seq b
20:53:14 <Iceland_jack> gwz: ↑
20:53:45 <roboguy_> @pl \f z xs -> sequence $ scanl (\m a -> m >>= f a) z xs
20:53:45 <lambdabot> ((sequence .) .) . scanl . flip ((.) . (>>=))
20:54:11 <Iceland_jack> > foldl (Seq.|>) (Seq.fromList [555]) [1,2,3] :: Seq.Seq Int
20:54:12 <lambdabot>  fromList [555,1,2,3]
20:54:38 <Iceland_jack> > foldr (Seq.<|) (Seq.fromList [555]) [1,2,3] :: Seq.Seq Int
20:54:39 <lambdabot>  fromList [1,2,3,555]
20:55:47 <joelteon> can this be made to compile? http://lpaste.net/101372
20:56:45 <roboguy_> joelteon: change Constrained to be type Constrained a = forall m. (MonadIO m, MonadState Int m) => m a
20:56:59 <joelteon> ok
20:57:34 <joelteon> roboguy_: that works, but if I define bar :: IdentityT Constrained String; bar = lift foo, then it will no longer compile
21:02:05 <joelteon> you see what I'm trying to do? basically I want a constraint synonym Constrained m, but instead of putting that at the start of every type signature in my program, I'd like it to sort of be implicitly inserted
21:02:06 <Galactic> if I have something like [23,45,67,10] how can I print that so that each number is on a single line?
21:02:28 <Galactic> like:
21:02:30 <Galactic> 0
21:02:30 <Galactic> 14
21:02:30 <Galactic> 24
21:02:30 <Galactic> 253
21:02:30 <Galactic> 5861
21:02:31 <Galactic> 2183837
21:02:40 <joelteon> Galactic: mapM_ print
21:03:00 <Iceland_jack> :t mapM_ print [1..1000000]
21:03:01 <lambdabot> IO ()
21:03:24 <Galactic> nice I will try that.
21:03:59 <roboguy_> joelteon: I don't think type synonyms work that way. I think there is an experimental constraint synonym feature, but I don't know if it's implemented yet
21:04:42 <joelteon> ConstraintKinds?
21:04:43 <Galactic> wow, yea that's what I need thank joelteon
21:05:16 <joelteon> that still makes Constrained a constraint
21:05:27 <joelteon> i'd like it to be a magically constrained polymorphic type
21:05:30 <joelteon> :(
21:05:42 <Iceland_jack> Galactic: Keep in mind that mapM_ accepts any function so if you (say) wanted to print each number twice you could do
21:05:42 <Iceland_jack>     mapM_ (\n -> print n >> print n) [1,2,3,4]
21:06:40 <Galactic> nice
21:11:58 <roboguy_> joelteon: I don't think constraint kinds is enough for that
21:12:07 <roboguy_> I'm not totally sure though
21:12:08 <joelteon> yeah, me neither
21:12:14 <joelteon> I don't think GHC knows how to do what I want to do
21:12:47 <roboguy_> I've heard it discussed and I think there are some kind of plans to implement it, but I don't think it's done yet
21:21:31 <haasn> what is this about?
21:21:56 <haasn> oh, http://lpaste.net/101372
21:23:26 <haasn> joelteon: what about lifting out the ‘m’? eg. data ConstrainedT m a = (MonadIO m, MonadState Int m) => Constrained (m a)
21:23:46 <haasn> That forbids a monadtrans instance, though
21:24:20 <joelteon> well then I can just do type ConstrainedT m = (MonadIO m, MonadState Int m)
21:24:23 <joelteon> doesn't solve my problem
21:24:50 <haasn> then I don't understand your problem
21:26:01 <joelteon> I want any type "t Constrained a" to implicitly be constrained, i.e. "(MonadIO m, MonadState Int m) => t m a"
21:26:23 <haasn> and what exactly is wrong with “Constrained m => t m a”?
21:27:52 <joelteon> it's loger
21:27:54 <joelteon> longer
21:34:44 <mjrosenb> anyone here involved with reactive-banana?
21:34:56 <mjrosenb> the examples page on the wiki is full of dead links.
21:35:09 * hackagebot lio-simple 0.0.0.3 - LIO support for the Simple web framework  http://hackage.haskell.org/package/lio-simple-0.0.0.3 (DeianStefan)
21:43:40 <Galactic> why if I run something like  [product [1..n] | n <- [34,67,12,5]]  in ghci it returns the correct answer but if I put the same code in a file then compile and run it ruturns zero for the big numbers.
21:44:21 <mjrosenb> Galactic: the compiler probably defaults to Int rather than Integer.
21:44:49 <Galactic> is there a way I can change that?
21:44:50 <mjrosenb> Galactic: you can try :: [Integer]
21:45:34 <Galactic> where should I put that... like this   [product [1..n] | n <- [34,67,12,5]] :: [Integer]
21:45:41 <mjrosenb> Galactic: that'll work.
21:46:23 <mjrosenb> > [product [1..n]::[Ineteger] | n <- [34,67,12,5]]
21:46:24 <lambdabot>  Not in scope: type constructor or class `Ineteger'
21:46:24 <lambdabot>  Perhaps you meant `Integer' (imported from Prelude)
21:46:32 <mjrosenb> > [product [1..n]::[Integer] | n <- [34,67,12,5]]
21:46:33 <lambdabot>  No instance for (GHC.Num.Num [GHC.Integer.Type.Integer])
21:46:33 <lambdabot>    arising from the literal `34'
21:46:33 <lambdabot>  Possible fix:
21:46:33 <lambdabot>    add an instance declaration for
21:46:33 <lambdabot>    (GHC.Num.Num [GHC.Integer.Type.Integer])No instance for (GHC.Enum.Enum [GH...
21:46:51 <mjrosenb> > [product ([1..n]::[Integer]) | n <- [34,67,12,5]]
21:46:52 <lambdabot>  [295232799039604140847618609643520000000,36471110918188685288249859096605464...
21:47:07 <mjrosenb> > [product [1..n] | n <- [34,67,12,5]::Integer]
21:47:08 <lambdabot>  Couldn't match expected type `GHC.Integer.Type.Integer'
21:47:08 <lambdabot>              with actual type `[t1]'Couldn't match expected type `[t0]'
21:47:08 <lambdabot>              with actual type `GHC.Integer.Type.Integer'
21:47:09 <enthropy> it should default to Integer
21:47:17 <Galactic> yea I get that error
21:47:33 * mjrosenb is still never sure about the precedence of '::'
21:47:46 <enthropy> mjrosenb: it goes as far as can make sense
21:48:03 <mjrosenb> > [product [1..n] | n <- [34,67,12,5]::[Integer]]
21:48:04 <lambdabot>  [295232799039604140847618609643520000000,36471110918188685288249859096605464...
21:48:19 <enthropy> > [product [1..n] | n <- [34,67,12,5 :: Integer]]
21:48:20 <lambdabot>  [295232799039604140847618609643520000000,36471110918188685288249859096605464...
21:48:22 <mjrosenb> .. like I said initially, :: [Integer]
21:48:28 * mjrosenb should listen to his own advice.
21:49:03 <mniip> I don't think <- binding is a valid expressing for ::
21:49:06 <mjrosenb> enthropy: so, over every infix operator, but not across infix keywords?
21:49:08 <mniip> er
21:49:41 <enthropy> yeah and not across ( unless there's a matching ) first
21:50:38 <mjrosenb> makes perfect sense
21:50:46 <mjrosenb> I'm still going to forget the next time I need it.
21:52:18 <Galactic> for some reason I am getting an error when I do this:
21:52:19 <Galactic> print [product ([1..n]::[Integer]) | n <- map (\x -> (readInt x)) content]
21:52:39 <Galactic> Couldn't match expected type `Integer' with actual type `Int'
21:52:39 <Galactic> In the expression: n
21:52:39 <Galactic> In the first argument of `product', namely
21:52:39 <Galactic>   `([1 .. n] :: [Integer])'
21:52:39 <Galactic> In the expression: product ([1 .. n] :: [Integer])
21:53:00 <haasn> You said [1..n] should be an [Integer]
21:53:07 <haasn> which means 1 and n are Integers
21:53:12 <MP2E> readInt is your problem, it returns type Int
21:53:14 <haasn> but n is of type Int
21:53:17 <MP2E> Integer is a bounded Int
21:53:21 <haasn> wrong
21:53:22 <MP2E> or is i the opposite
21:53:24 <haasn> yes
21:53:29 <MP2E> damn :P
21:53:34 <haasn> Integer is unbounded
21:54:10 <Galactic> ? so how can I fix this.
21:54:15 <MP2E> -.-
21:54:16 <haasn> Change Integer to Int, perhaps
21:54:34 <haasn> but note that the type signature is redundant
21:54:37 <haasn> You could have left it off
21:54:54 <mjrosenb> haasn: he wants integer because factorial exceeds the bounds of int handily.
21:55:07 <Galactic> yeap
21:55:08 <haasn> oh, fair point
21:55:26 <haasn> what is “readInt”?
21:55:37 <mjrosenb> > readInt "13"
21:55:38 <lambdabot>  No instance for (GHC.Num.Num [GHC.Types.Char])
21:55:38 <lambdabot>    arising from a use of `Numeric.readInt'
21:55:38 <lambdabot>  Possible fix:
21:55:38 <lambdabot>    add an instance declaration for (GHC.Num.Num [GHC.Types.Char])
21:55:41 <haasn> :t readInt
21:55:42 <lambdabot> Num a => a -> (Char -> Bool) -> (Char -> Int) -> ReadS a
21:55:45 <Galactic> readInt :: B.ByteString -> Int
21:55:46 <Galactic> readInt = fst . fromJust . B.readInt
21:55:49 <haasn> oh
21:56:01 <mjrosenb> oh, I'm used to 'read'
21:56:10 <mjrosenb> Galactic: try just read.
21:56:16 <haasn> well if you don't want to modify the definition of readInt to reurn an Integer instead; use fromIntegral
21:56:25 <haasn> :t fromIntegral -- Galactic
21:56:26 <lambdabot> (Integral a, Num b) => a -> b
21:56:30 <dmj`> use readMaybe... no dealing w/ maybe is easier than exception
21:56:31 <mjrosenb> > read "12345657123123123123123123123123123123123123123123" :: Integer
21:56:32 <lambdabot>  12345657123123123123123123123123123123123123123123
21:56:33 <haasn> :t fromIntegral :: Int -> Integer
21:56:34 <lambdabot> Int -> Integer
21:56:54 <haasn> dmj`: mjrosenb: his readInt is not related to “read”
21:57:02 <Galactic> yea but I thought that read is slower than doing ByteString
21:57:23 <no-n> :t readMaybe
21:57:24 <lambdabot> Not in scope: `readMaybe'
21:57:26 <dmj`> readMaybe :: Read a => String -> Maybe a
21:57:35 <no-n> thanks :P
21:58:30 <haasn> Galactic: that depends heavily
21:58:32 <dmj`> what is B.readInt? don't see it in Data.ByteString
21:58:41 <haasn> Galactic: they are not even remotely the same thing, also
21:58:57 <haasn> Galactic: ByteString and String should not be used interchangeably
21:59:25 <Galactic> I see
21:59:51 <Galactic> dmj`: it comes from here: import qualified Data.ByteString.Lazy.Char8 as B
22:00:03 <haasn> never import Data.ByteString.Lazy/Strict.Char8
22:00:06 <haasn> never
22:00:18 <Galactic> ?
22:00:25 <haasn> if you need to use .Char8, chances are you're doing something wrong
22:01:04 <Galactic> but then how you use ByteString  readInt
22:01:11 <haasn> you don't
22:01:39 <Galactic> k, then how would you solve this problem... http://www.codechef.com/problems/INTEST
22:01:41 <dmj`> haasn: Char8 assumes an ascii encoding
22:01:49 <haasn> dmj`: not really
22:02:23 <haasn> (ASCII is only 7 bits, and you can't encode a String using ASCII)
22:02:55 <haasn> it doesn't even use any encoding, because calling it that would imply you can decode it again. It just writes out worthless byte sequences
22:03:00 <dmj`> "More specifically these byte strings are taken to be in the subset of Unicode covered by code points 0-255"
22:03:33 <Galactic> haasn: solve this please http://www.codechef.com/problems/INTEST   I am interested to see what is your solution.
22:04:00 <dmj`> Galatic: I'm interested in seeing your solution
22:04:01 <haasn> Galactic: I'm looking at it, hang on
22:04:40 <Galactic> dmj`: I did it using ByteString but with what just haasn said is a bad idea.
22:06:02 <Galactic> here is my solution dmj` http://www.codechef.com/viewsolution/3613031
22:07:30 <haasn> I would probably just use Text
22:07:58 <haasn> reasoning being the fact that the problem doesn't specify a byte-based input but rather a character-based input; which assumes it runs in some system-locale (that could be anything)
22:08:55 <haasn> of course, if you need to reach a performance quota, it might be sane to go back on what I said earlier and just use .Char8, with a hefty disclaimer on it saying that this is a situation-specific performance hack and should not be generalized!
22:09:10 <haasn> It only works because the given input only consists of digits, spaces and newlines
22:09:50 <haasn> as for an actual solution, I would use this as a good opportunity to try out pipes. I wonder how its performance actually ranks with the other approachces
22:10:07 <Galactic> I see, thanks...I will keep that in mind
22:10:18 <haasn> (I am not a fan of lazy I/O either way)
22:11:23 <haasn> (is that actually a solution? why are you ignoring the first parameter, the number of lines?)
22:11:54 <Galactic> because I don't need it
22:13:24 <Galactic> yes that is an actuall solution check this... http://www.codechef.com/status/INTEST,galactic
22:13:25 <haasn> oh, I thought it contains multiple such problems
22:14:40 <haasn> let me try a few solutions
22:15:05 <Galactic> k
22:19:22 <Galactic> this is where I got that ByteString is faster http://www.haskell.org/haskellwiki/Wc
22:26:20 <haasn> Galactic: I wonder how much slower this version is http://bpaste.net/raw/190252/
22:26:38 <haasn> yeah, the Text docs mention that ByteString is slower if you don't care about the locale or unicode and just need to operate on values that you know you can directly convert
22:29:09 <Galactic> haasn: do you have an account in codechef?
22:30:22 <Galactic> did you tried the code or you want me to run it?
22:30:39 <haasn> I don't, and I haven't, also never mind about the code
22:30:47 <haasn> I just realized it's incredibly wasteful to have the error handler there
22:30:55 <linduxed> hey guys, i was wondering if someone here could explain when you'd use the two different test frameworks exitcode-stdio-1.0 and detailed-1.0?
22:30:55 <Galactic> k
22:30:57 <haasn> because that adds an extra handler for every single iteration
22:34:19 <dmj`> linduxed: http://www.haskell.org/cabal/users-guide/developing-packages.html#test-suites
22:34:44 <linduxed> dmj`: thx
22:39:48 <joelteon> huh, TIL that just typing ":" as the command in cabal will repeat the last command
22:48:46 <Kron> <Iceland_jack>     (++) <$> getLine <*> getLine
22:48:51 <Kron> this is just (++) `on` getLine
22:49:03 <Kron> :t on
22:49:05 <lambdabot> (b -> b -> c) -> (a -> b) -> a -> a -> c
22:49:45 <Kron> it's from Data.Function I think
22:50:23 <tikhon> Kron: that doesn't seem right
22:50:39 <tikhon> :t (++) `on` getLine
22:50:40 <lambdabot>     Couldn't match expected type `a0 -> [a1]'
22:50:40 <lambdabot>                 with actual type `IO String'
22:50:40 <lambdabot>     In the second argument of `on', namely `getLine'
22:50:48 <tikhon> :t (++) <$> getLine <*> getLine
22:50:49 <lambdabot> IO [Char]
22:51:07 <tikhon> it would be 'on' if getLine was a function, not an IO action
22:51:18 <Kron> hmm!
22:51:22 <tikhon> (++) `on` (:2)
22:51:23 <Kron> that's true
22:51:25 <tikhon> :t (++) `on` (:2)
22:51:26 <lambdabot> Num [a] => a -> a -> [a]
22:51:31 <Kron> I forgot getLine exists by itself
22:51:37 <Kron> I was assuming it was an a -> b thing
22:51:42 <Kron> lines?
22:51:47 <Kron> :t lines
22:51:48 <lambdabot> String -> [String]
22:51:51 <tikhon> :t (++) `on` lines
22:51:52 <lambdabot> String -> String -> [String]
22:51:55 <Kron> yeah I was confusing it with lines
22:52:00 <tikhon> easy mistake
22:52:03 <Kron> the one that gets lines out of a string
22:52:40 <Iceland_jack> :t join (liftA2 (++)) getLine
22:52:41 <lambdabot> IO [Char]
22:52:53 <Iceland_jack> is possible
22:52:57 <Iceland_jack> <$> getLine <*> getLine is perfecty valid
22:53:03 <Iceland_jack> *but otherwise (++)
22:53:04 <Kron> right
22:53:07 <mjrosenb> has anyone done X programming in haskell?
22:54:23 <tikhon> I remember thinking about it and then finding X too terrifying :P
22:54:29 <levi> I compiled xmonad
22:54:29 <MP2E> haha
22:54:48 <levi> I even reconfigured it!
22:54:48 <Kron> levi: you're a bravier person than I
22:54:51 * Kron gasps
22:54:57 <MP2E> levi: OH GOD THE HORROR
22:55:22 <MP2E> X.org is the Linux cthulu
22:55:24 <levi> Well, it's sort of X programming.
22:55:24 <Kron> <MP2E> Any tips on integrating haskell with emacs? :D
22:55:24 <Kron> <tac> Step 1) Download haskell-mode
22:55:24 <Kron> <tac> Step 2) Try not to cry.
22:55:24 <Kron> <tac> Step 3) Cry alot.
22:55:28 <Kron> xmonad is like that, but worse
22:55:40 <MP2E> :<
22:55:43 <levi> I got to really enjoy xmonad, actually.
22:55:45 <tikhon> For me, XMonad just worked
22:55:45 <MP2E> that's a shame, I considered usnig it
22:55:48 <MP2E> I really like dwm
22:55:50 <tikhon> but so did haskell-mode
22:55:54 <MP2E> and xmonad looks like a haskell version of that
22:55:55 <MP2E> soo
22:55:58 <tikhon> the new Emacs package manager is awesome
22:56:03 <MP2E> it is.
22:56:04 <Kron> i'm using xmonad right now
22:56:05 <MP2E> Though I still love el-get
22:56:06 <Kron> I love it
22:56:10 <tikhon> me too, actually
22:56:14 <tikhon> on both counts
22:56:19 <Kron> but seriously, it's a goddamn bitch sometimes
22:56:20 <Kron> but someday
22:56:25 <levi> I have xmonad running right now, but not on this machine.
22:56:27 <Kron> someday i'll have that perfect unixporn arch setup
22:56:37 <Kron> also I'll have a pony and a nice job
22:56:46 <tikhon> I've been meaning to try NixOS for a while
22:56:52 <tikhon> that's probably what I'll go for on my next laptop
22:56:53 <Kron> actually scrap the pony, I'd rather have a cat
22:57:28 <tikhon> I figure if I was willing to go for a more exciting distro, it may as well be one with a philosophy I agree with
22:57:31 <levi> Heh. My laptop runs Arch; I installed it on a whim. I alternate between liking it and hating it.
22:57:33 <Kron> I actually really like haskell-mode
22:57:39 <Kron> it was a super out of the box experience for me
22:57:42 <Kron> one of my favorite modes
22:57:45 * mjrosenb got far too annoyed fighting with xmonad
22:57:49 <Kron> I just love self deprecatory humor I guess
22:57:56 <tikhon> I've had a few problems with haskell-mode
22:57:58 <tikhon> but nothing terrible
22:58:19 <Kron> the worst problems i've had with the language ecosystem were with hackage / cabal
22:58:35 <mjrosenb> hakell-mode is nice
22:58:36 <tikhon> indentation breaks when I use certain *valid* Unicode characters in my variables names
22:58:38 <Kron> I was bouncing around between #haddock, #hackage and here trying to get things to build for a launch candidate
22:58:50 <tikhon> oh, and the last update broke mmm-mode
22:58:56 <mjrosenb> but I can't seem to get it to interact with a haskell-inferior process in a reasonable way.
22:58:57 <tikhon> which I actually really should fix
22:59:08 <levi> My haskell ecosystem experiences have been no worse than with any other language I've used, really.
22:59:13 <Kron> mjrosenb: I use C-c C-l
22:59:21 <tikhon> levi: it's so far better than OCaml...
22:59:22 <Kron> I C-x 3 to split my frame
22:59:28 <Kron> haskell source code on the left, repl on the right
22:59:31 <tikhon> yeah, C-c C-l is good
22:59:37 <Kron> C-c C-l will load my code into the repl
22:59:38 <Kron> compile it
22:59:41 <Kron> place point on it too
22:59:45 <Kron> so I can just give it a spin
22:59:53 <Kron> it's one of my favorite just-run-it commands
22:59:54 <tikhon> I wrote a custom little mode that figures out if I'm using a cabal sandbox and opens up a different ghci buffer per sandbox
22:59:59 <levi> tikhon: I tried OCaml out again a few months ago, and with the new opam stuff it didn't seem too bad.
23:00:06 <Kron> tuareg is nice
23:00:17 <tikhon> levi: yeah, that's a marked improvement; I started before opam really worked
23:00:18 <Kron> I wrote my boyfriend a C-c C-l equivalentin tuareg using F6
23:00:21 * hackagebot angel 0.5.0 - Process management and supervision daemon  http://hackage.haskell.org/package/angel-0.5.0 (MichaelXavier)
23:00:26 <Kron> old eclipse habits for him
23:00:41 <tikhon> I tried both Tuareg and typerex
23:00:53 <tikhon> but I never got a repl that worked exactly how I wanted it to
23:01:00 <tikhon> neither the normal toplevel nor utop
23:01:34 <tikhon> but yeah, Haskell mode has been entirely solid
23:01:38 <Kron> i wish haskell would just print functions, like in ocaml
23:01:42 <tikhon> except for the Unicode issues
23:01:44 <Kron> it's so much easier to work with
23:01:52 <tikhon> Kron: you can probably add something to a ghci config file to do that
23:01:59 <tikhon> just make an instance of show for (a -> b)
23:02:01 <Kron> if you know of any such config
23:02:03 <Kron> tell me
23:02:07 <Kron> because I don't know how to do it
23:02:10 <Kron> and I'd really really like it
23:02:28 <tikhon> have you looked at IHaskell?
23:02:35 <tikhon> that seems like an exciting alternative to ghci
23:02:40 <Kron> no, what is it?
23:02:40 <tikhon> and I think it prints functions out somehow
23:02:48 <tikhon> it's a Haskell frontend for IPython
23:02:56 <tikhon> or, I guess, an IPython frontend for Haskell?
23:03:10 <tikhon> it's just a far more feature-rich repl
23:03:16 <tikhon> in a slightly different style
23:03:25 <tikhon> I haven't actually used it, but their demo looks cool
23:03:30 <tikhon> http://gibiansky.github.io/IHaskell/demo.html
23:03:43 <levi> An IPython 'kernel' for Haskell is what they call it, I gather.
23:03:49 <tikhon> ah
23:03:51 <tikhon> fair enough
23:03:57 <tikhon> although "kernel" isn't really the word I'd use
23:04:14 <levi> Me either, but hey. Python isn't what I'd use for it either, but it's there. :)
23:04:18 <Kron> is it... python?
23:04:24 <Kron> I don't get it
23:04:29 <Kron> does it convert haskell to python?
23:04:32 <tikhon> no
23:04:51 <tikhon> IPython is a pretty nice repl for Python that supports images and html and stuff
23:05:03 <tikhon> IHaskell just uses the same backend but substitutes GHC for Python
23:05:03 <levi> No, Python just has some pre-built interactive tools with a swappable, language agnostic communication model to the language interpreter.
23:05:46 <tikhon> it seems especially nice for working with diagrams
23:05:47 <levi> It's like inferior-haskell-mode but implemented in Python instead of elisp.
23:06:15 <tikhon> levi: it has a bunch of other features, like supporting images, html and LaTeX outputs
23:06:31 <tikhon> and being able to take multi-line code in normal top-level Haskell syntax
23:06:46 <levi> OK, like inferior-haskell-mode on steroids. ;) I was just trying to describe the general model.
23:06:52 <tikhon> fair enough
23:07:13 <tikhon> also, it seems like extending inferior-haskell-mode with support for displaying images and svgs and stuff should not be difficult
23:07:28 <tikhon> well, let me temper that statement: it should not be completely impossible
23:07:32 <tikhon> maybe a bit tricky
23:07:41 <levi> Yeah, emacs is capable of such things, if you care to do that much elisp hacking.
23:08:09 <tikhon> in practice, I just have an extra buffer for the svg/png/whatever I'm working on
23:08:44 <levi> It would be cool to have a CLIM-like interface to GHCi, but since CL doesn't even have much of a CLIM anymore, it seems unlikely to appear.
23:09:04 <tikhon> hmm, I've never used CLIM—what is it like?
23:10:00 <levi> It's the 'Common Lisp Interface Manager', basically the interaction model of Lisp Machines in a standardized form. A modern usable work-alike would be the Factor interface, if you've ever tried it.
23:10:43 <tikhon> ooh, haven't tried Factor
23:10:48 <tikhon> I've been thinking about it
23:10:51 <levi> The central theme is that displayed forms are not just dead text, they're interactive and inspectable.
23:11:03 <tikhon> yeah, to me that seems very nice
23:11:18 <tikhon> I've always wanted a version of Chart where you can pan around and zoom and so on, for example
23:11:57 <levi> Oh, let me put in a plug for ghc-vis, if you haven't tried it out yet.
23:12:06 <tikhon> and maybe some nice nested way to view large algebraic data types—sort of like what you get in web tools to view the DOM
23:12:25 <tikhon> oh, I hadn't heard of that
23:12:37 <tikhon> that actually seems incredible
23:13:01 <levi> It's not really a general visualization tool, but it's nifty for examining the state of your Haskell programs.
23:13:04 <theguruofreason> Just out of curiosity, is anyone here familiar with the SDL2 bindings?
23:13:27 <levi> I think it would be a terrific tool for new Haskellers to help come to grips with lazy evaluation.
23:13:27 <tikhon> it also seems very useful for teaching people about Haskell
23:13:31 <levi> Heh.
23:13:41 <levi> theguruofreason: Sorry, haven't played with them.
23:13:42 <tikhon> better than :sprint
23:13:55 <tikhon> theguruofreason: I think they're relatively new, or maybe even still being worked on
23:14:00 <tikhon> but I've never used them
23:14:20 <theguruofreason> yeah, 1.0.2 is the latest
23:14:34 <theguruofreason> released Jan 8th
23:14:40 <theguruofreason> sry, Jan 2
23:15:03 <levi> tikhon: But yeah, you should play with Factor. It's still being maintained, though it's not really moving forward anywhere like it was before Slava went to Google.
23:15:23 * hackagebot anansi-pandoc 0.1.3 - Looms which use Pandoc to parse and produce a variety of formats.  http://hackage.haskell.org/package/anansi-pandoc-0.1.3 (JohnMillikin)
23:15:47 <tikhon> I've played around a bit with Forth
23:15:58 <tikhon> but it wasn't entirely convincing
23:17:17 <covi> WHat is the key insight in deriving the church encoding of integer predecessor function?
23:18:11 <tikhon> I remember figuring it out a while back, but not the particular insight involved
23:18:18 <levi> tikhon: I think Forth is a bit more convincing when working with a microcontroller.
23:18:42 <levi> I remember coming across it while going through the first bit of Software Foundations, but I don't remember either.
23:18:48 <tikhon> I also played around with arrayForth
23:18:49 <covi> tikhon: hi, 263 hw lol
23:18:55 <tikhon> that was even less convincing
23:18:59 <tikhon> covi: yep
23:20:03 <levi> I found Factor a lot more convincing than Forth, mostly because it's got enough higher-level combinators that you don't have to do a whole lot of stack-swizzling.
23:20:18 <tikhon> that certainly sounds like an improvement
23:21:23 <haasn> covi: if we note that the church encoding of a numeral is basically a fold over the construction data Nat = Z | S Nat; and we can write pred like this: pred Z = Z; pred (S Z) = Z; pred (S n) = S (pred n)
23:22:11 <levi> It's very much like writing point-free haskell, but in a language that was optimized to work that way.
23:22:12 <haasn> covi: we can lift out the two S cases like: pred Z = Z; pred (S n) = pred' n where pred' Z = Z; pred' (S m) = S (pred m)
23:22:25 <haasn> and rewrite using a fold
23:22:56 <haasn> err, make that last one = S (pred n)
23:23:00 <haasn> or S (S pred m), really
23:23:07 <haasn> actually S (pred n)
23:23:36 <haasn> anyway, rewriting using a fold: pred = fold Z (pred' n) where pred' n = fold Z (\_ -> S (pred n))
23:23:54 <haasn> or something like that, at any rate
23:25:24 * hackagebot HaRe 0.7.1.5 - the Haskell Refactorer.  http://hackage.haskell.org/package/HaRe-0.7.1.5 (AlanZimmerman)
23:25:30 <tikhon> covi: ooh, here's a hint: think about using a boolean as a "flag" to turn off once you hit 0
23:25:34 <tikhon> if that makes sense
23:25:47 <tikhon> hopefully that doesn't just give it away
23:28:43 <Zer000> very new to haskell, following a tutorial (more or less) and getting "Could not find module `Helpers'" even though it's there. Here's my folder structure http://dpaste.com/1742043/
23:28:45 <tikhon> levi: I think I'll take a closer look at stack-based languages and Factor at some point, but I have a few other languages before it on my list
23:30:11 <tikhon> Zer000: since it's in the Utils directory, the full name would be Utils.Helpers
23:30:24 * hackagebot llvm-general-pure 3.3.11.1 - Pure Haskell LLVM functionality (no FFI).  http://hackage.haskell.org/package/llvm-general-pure-3.3.11.1 (BenjaminScarlet)
23:30:26 * hackagebot llvm-general 3.3.11.1 - General purpose LLVM bindings  http://hackage.haskell.org/package/llvm-general-3.3.11.1 (BenjaminScarlet)
23:30:29 * hackagebot llvm-general-pure 3.4.2.1 - Pure Haskell LLVM functionality (no FFI).  http://hackage.haskell.org/package/llvm-general-pure-3.4.2.1 (BenjaminScarlet)
23:30:30 <tikhon> also, are you building with cabal?
23:30:31 * hackagebot llvm-general 3.4.2.1 - General purpose LLVM bindings  http://hackage.haskell.org/package/llvm-general-3.4.2.1 (BenjaminScarlet)
23:30:38 <Zer000> tikhon: yes I am
23:30:41 <levi> tikhon: Well, even if you don't intend to do anything serious with it, you should take a look at the interactive environment. It's a cross-platform, from-scratch GUI.
23:30:52 <tikhon> Zer000: you'll have to add the module to your .cabal file too
23:31:04 <tikhon> levi: sounds good
23:31:22 <tikhon> levi: I bet it's better than the colorForth/arrayForth IDE :P
23:31:44 <levi> Has a bunch of cool stuff, including integrated documentation, live/inspectable forms, and even a slide-authoring/displaying mode.
23:32:23 <tikhon> Heh, I like that idea. I can imagine a bunch of talks working pretty well just based on a REPL history.
23:32:53 <levi> Check out Racket for a cool interactive environment, too.
23:33:03 <tikhon> oh yeah, I've used Racket
23:33:12 <Zer000> tikhon: thanks both those solutions worked! I'm just gonna keep it Utils.Helpers
23:33:37 <tikhon> although admittedly I mostly wrote Racket code from Emacs because I *really* like Emacs :)
23:33:53 <tikhon> but some people I was working with used DrRacket to debug code and such
23:34:31 <levi> It's got a built-in slideshow DSL too, and you can get a REPL in your slides.
23:34:48 <tikhon> as far as interactivity goes, I can't wait for type holes
23:35:05 <tikhon> I can imagine the Haskell Emacs mode really taking advantage of them
23:35:14 <tikhon> largely because I'm very envious of Agda mode :)
23:35:30 <levi> I actually gave a presentation on lua that used an HTML-based slideshow kit and a REPL based on an emscripten-compiled lua interpreter.
23:35:52 <tikhon> I use HTML for my slides too, so I've considered trying that with Haste or something
23:35:54 <Zer000> hey how come modules can't start with lowercase letters?
23:36:05 <tikhon> Zer000: that's just how the language is designed
23:36:16 <Zer000> fair enough
23:36:17 <tikhon> it makes it easy to figure out what's a module and what isn't, I guess
23:36:17 <gamegoblin> hnnnggggg so many ways to parse HTTP header fields T_T orz
23:36:22 <Zekka> There's not really a theory-based reason AFAIK -- it's just so they have a consistent appearance
23:36:50 <tikhon> It's probably related to types needing capital letters
23:37:25 <Javran> Hi, I find some trouble with font in emacs' haskell-mode, hope some one can help: http://www.tomnod.com/nod/challenge/malaysiaairsar2014/map/654342 thanks!
23:37:39 <Javran> http://stackoverflow.com/questions/22470820/font-lock-mode-in-haskell-mode-seems-to-ruin-the-width-of-single-spaces-in-emacs ops wrong link...
23:38:51 <tikhon> Javran: woah, I've never seen that before
23:38:57 <tikhon> perhaps #emacs is a better place to ask?
23:39:51 <Javran> tikhon: I've asked there, haven't got any response :(
23:39:54 <levi> Did you turn on any of the unicode substitution options?
23:40:14 <tikhon> it looks like somebody's answered on SO
23:40:26 * hackagebot cryptohash-conduit 0.1.0 - cryptohash conduit  http://hackage.haskell.org/package/cryptohash-conduit-0.1.0 (VincentHanquez)
23:40:29 <tikhon> it's probably a problem with bold faces being a larger font size
23:41:11 <Javran> https://github.com/Javran/dotemacs/blob/master/my-elfs/jav-haskell.el these are all haskell-mode related settings
23:41:36 <Zer000> What is ghc doing that my hello world program becomes a 1.1 meg executable?
23:41:44 <levi> Zer000: static linking
23:42:27 <Zekka> If I remember right Haskell comes with a pretty bulky runtime support system that's linked statically with your program
23:42:29 <covi> haasn: thanks
23:42:33 <Zekka> er, GHC, rather
23:42:57 <MP2E> yes
23:43:01 <covi> tikhon: ok, let me think. i *glimsped* through the wiki entry on it and it seems pretty complicated
23:43:05 <MP2E> garbage collector and runtime library is linked in
23:43:18 <Zer000> ah.ah
23:43:21 <tikhon> covi: break your problem into sub-problems
23:43:21 <Zer000> i see
23:43:42 <tikhon> covi: think about what you *start* with: you have a number n, which lets you "iterate" a function n times
23:44:06 <tikhon> since you don't have much else, you're going to end up using that iteration
23:44:17 <tikhon> now think about what property you want from the function you're iterating
23:44:19 <levi> Zer000: There are ways to slim the size a bit, if it's really critical, but they are probably more trouble than they're worth unless you have real resource constraints.
23:44:47 <Javran> levi: I haven't heard of "unicode subsitution", if you meant something like "undefined -> _|_", then no.
23:45:09 <tikhon> ooh, I love haskell-font-lock-symbols
23:45:26 <tikhon> especially for ∀s in type signatures
23:45:36 <levi> Javran: Yeah, I meant that, which is really called what tikhon said, I guess.
23:45:55 <tikhon> that's the only thing that keeps me from switching to -XUnicodeSyntax :)
23:46:58 <tac> what's the difference between cabal install and cabal build if you're developing a cabal package locally
23:47:03 <tac> should you always just work with build?
23:47:25 <tikhon> I think install bundles together a bunch of commands like cabal configure and cabal build
23:47:33 <levi> Well, install installs it as well.
23:47:47 <tikhon> I always just use install when I'm developing a cabal package locally
23:47:54 <tikhon> but I'm basically a cabal philistine
23:48:00 <haasn> covi: hmm, actually my approach doesn't work the way I intended it to
23:48:02 <tac> good enough
23:48:07 <haasn> it gets more complicated than that
23:48:19 <tikhon> sometimes cabal install --only-dependencies is particularly useful
23:48:31 <tac> yeah
23:48:39 <tac> I'm slowly learning this crap
23:48:43 <Javran> levi: that "jav-haskell.el" is all I have about changes to haskell-mode. Almost copied from emacs wiki.
23:48:47 <tac> after clobbering my entire haskell install >__>
23:49:02 <tikhon> tac: ooh, learn about sandboxes ;)
23:49:11 <tac> yeah. I know enough to run sandbox init
23:49:14 <tikhon> that'
23:49:18 <levi> Javran: I'm sorry, you've exhausted my ideas for what it might be related to. I'm not really an emacs expert.
23:49:19 <tikhon> that's pretty much all you need
23:49:26 <tac> but things I didn't know, default installation is --global on Ubuntu
23:49:41 <tac> and when you cabal install cabal-install, the old version of cabal hangs out, waiting to screw you over
23:49:51 <levi> tac: Surely not when you're not running as root?
23:50:22 <tac> I somehow ended up with global packages, and I don't *think* I used sudo
23:50:24 <Javran> levi: thanks anyway! I know here is not the best channel about this question.
23:50:38 <tikhon> tac: taht sounds really annoying
23:50:59 <tac> but hopefully I have things fixed (or at least reset) so I can install yesod-websockets like I originally wanted
23:51:03 <tikhon> I think I ended up nuking all my package stuff when I switched over to 7.6, and everything has been happy after that
23:51:13 <tikhon> except for wxHaskell
23:51:25 <tikhon> curse you, wx
23:51:28 <levi> I sometimes use cabal in ubuntu, and I don't recall that happening to me.  Maybe you got some global ones pulled in via apt-installed packages?
23:52:05 <tac> it's possible
23:52:12 <tac> yeah, especially if it was yesod
23:52:33 <levi> Yesod depends on half of hackage, I think. :P
23:53:57 <levi> Last time I played with it, I couldn't even get cabal-install to resolve the dependencies except by telling it to install yesod-platform first before doing a --dependencies-only install.
23:55:09 <tac> levi: Yesod depends on half of hackage. Lens depends on the other three halves of it.
23:55:36 <tikhon> and obviously any new web development project will want to use lens internally :)
