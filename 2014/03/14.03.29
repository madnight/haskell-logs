00:00:04 <bitemyapp> athan: cellular automata / Game of Life is the canonical example of a comonad. Lenses are comonad coalgebras IIRC.
00:00:15 <athan> trillioneyes: iirc?
00:00:18 <athan> trillioneyes: :P
00:00:30 <jle`> athan: you probably know one already
00:00:37 <athan> trillioneyes: I'm reading on it now! I just heard of "prisms"
00:00:49 <jle`> the tuple (e, a)
00:00:53 <athan> trillioneyes: ahh!
00:00:59 <athan> er
00:01:00 <athan> sorry
00:01:02 <jle`> or well, (,) e
00:01:06 <trillioneyes> hehe, it's okay
00:01:06 <athan> jle`: aah!
00:01:14 <trillioneyes> I was kind of confused for a while though!
00:01:15 <athan> jle`: right
00:01:18 <jle`> extract is (e,a) -> a
00:01:28 <athan> jle`: the reader monad?
00:01:40 <jle`> duplicate is (e,a) -> (e,(e,a))
00:01:43 <johnw> have you read about monads in LYAH?
00:01:49 <athan> jle`: oh yeah
00:01:57 <johnw> (that was to athan)
00:02:15 <bitemyapp> athan: http://blog.tmorris.net/posts/20-intermediate-haskell-exercises/
00:02:16 <bitemyapp> athan: do that.
00:02:16 <athan> johnw: Oh yeah, yeah I have
00:02:25 <bitemyapp> athan: do the exercises.
00:02:26 <jle`> athan: is Reader a comonad?
00:02:30 <bitemyapp> they will help more than analogies or LYAH.
00:02:40 <bitemyapp> or throwing around nouns you don't have a concrete grasp on.
00:02:50 <athan> I agree
00:02:51 <edwardk> jle`: given a Monoid on the input to the function, yes
00:02:58 <bitemyapp> jle`: who cares? they probably don't even have a firm grasp of what a monad is. Leave it be.
00:03:05 <edwardk> f mempty gives you the extract
00:03:06 <bitemyapp> edwardk: wait wut
00:03:08 <bitemyapp> hahahaha
00:03:15 <bitemyapp> brill.
00:03:19 <athan> edwardk: ahhhhhhh
00:03:21 <jle`> bitemyapp, edwardk  --- he asked if it was, and i reversed him the question
00:03:33 <bitemyapp> edwardk: didya see my question earlier?
00:03:42 <jle`> he should be able to answer it himself :)
00:03:46 <edwardk> duplicate takes (e -> a) to (e -> e -> a), by using mappnd on the arguments
00:03:46 <athan> edwardk: that's amazing
00:03:57 <edwardk> jle`: just saw a question and answered =)
00:04:30 <jle`> =)
00:04:52 <athan> what's a ranked type?
00:05:00 <bitemyapp> athan: don't worry about it
00:05:04 <bitemyapp> athan: do the exercises. 4rlz.
00:05:04 <athan> versus a... normal one...?
00:05:13 <athan> I WILL WORRY
00:05:14 <athan> lol
00:05:28 <MP2E> hehe but ghc can answers your questions better than we ever can :P
00:05:38 <MP2E> answer*
00:05:59 <MP2E> you can figure out how something works *exactly* instead of throwing around a bunch of analogies, and essentially limited models
00:06:24 <bitemyapp> ^^ this.
00:06:35 <bitemyapp> don't kick the can around in IRC, hack code.
00:06:40 <bitemyapp> do exercise/koans.
00:06:47 <athan> koans?
00:06:57 <augur> bitemyapp: tell me how to start a startup :(
00:06:59 <bitemyapp> athan: doesn't matter. do the link I sent you. it'll teach you important stuff.
00:07:03 <bitemyapp> augur: gooby pls
00:07:12 * augur gives bitemyapp some gooby
00:07:12 <athan> but yeah, it's like doing vs. talking about doing
00:07:19 <bitemyapp> augur: do I know you?
00:07:51 <augur> bitemyapp: eh. you followed me on twitter briefly but thats about it!
00:08:12 <bitemyapp> augur: who are you on twitter?
00:08:17 <augur> im not serious (well i am but not really), just poking you
00:08:28 <augur> @psygnisfive
00:08:28 <lambdabot> Unknown command, try @list
00:08:43 * hackagebot purescript 0.4.10.1 - PureScript Programming Language Compiler  http://hackage.haskell.org/package/purescript-0.4.10.1 (PhilFreeman)
00:08:43 * hackagebot clifford 0.1.0.14 - A Clifford algebra library  http://hackage.haskell.org/package/clifford-0.1.0.14 (spacekitteh)
00:08:45 <augur> lambdabot, you're a shameful robot. shameful.
00:08:59 <bitemyapp> augur: oh yeah, I liked you, but I think you had a spurt of political trolling or something so I shut it off
00:09:06 <augur> @faq can haskell recognize twitter @tags?
00:09:06 <lambdabot> The answer is: Yes! Haskell can do that.
00:09:08 <augur> lies!
00:09:08 <bitemyapp> augur: if anybody I knew RT'd you, I would've refollowed. I'll do that now.
00:09:26 <augur> bitemyapp: i dont know why you'll do that but ok
00:09:26 <bitemyapp> normally when I temporarily unfollow people like that, it's because I expect another peer to RT you at some point
00:09:33 <augur> gosh the twitter iphone app responds quickly
00:09:40 <bitemyapp> I believe in second^H^H^H^Hthird^H^H^H^Hfourth chances
00:10:15 <augur> heh
00:12:07 <athan> bitemyapp: Am I supposed to make instances of all of those, or see why they're wrong?
00:12:15 <bitemyapp> athan: make 'em work yo.
00:12:31 <bitemyapp> athan: most of dibblego's work involves "fill in the blanks"
00:12:31 <athan> bitemyapp: righteous
00:12:48 <athan> bitemyapp: ahh okay, sweet, thanks man
00:12:58 <bitemyapp> athan: alternately: https://github.com/NICTA/course/blob/master/src/Course/Functor.hs and https://github.com/NICTA/course/blob/master/src/Course/Monad.hs
00:13:12 <bitemyapp> athan: here's my gist for learning Haskell: https://gist.github.com/bitemyapp/8739525
00:13:21 <bitemyapp> it's more or less a recounting of what's worked best for me.
00:14:04 <athan> bitemyapp: Awesome! I'll get started!
00:14:22 <athan> wait
00:14:28 <athan> see that's what I was trying to do earlier
00:14:33 <bitemyapp> athan: the whole NICTA course is pretty sweet.
00:14:36 <athan> :t (->)
00:14:36 <lambdabot> parse error on input `->'
00:14:42 <bitemyapp> huh.
00:14:48 <athan> nicta? I'm gonna have to get started on that
00:14:50 <athan> er
00:14:53 <athan> :k (->)
00:14:54 <lambdabot> * -> * -> *
00:14:58 <athan> ahhhhhhhh
00:14:59 <bitemyapp> :info (->)
00:15:00 <athan> there we go
00:15:14 <athan> :k ((->) e)
00:15:15 <lambdabot> Not in scope: type variable `e'
00:15:29 <bitemyapp> data (->) a b, for ((->) r) there's a Functor and a Monad instance.
00:15:34 <athan> :k (Num a) => ((->) a)
00:15:34 <lambdabot> *
00:15:36 <bitemyapp> from :info (->) ^^
00:16:05 <athan> ahh okay
00:16:15 <athan> i wish there was, like...
00:16:15 <bitemyapp> :k Either
00:16:15 <lambdabot> * -> * -> *
00:16:23 <bitemyapp> see how the kind-ness is the same as (->) ?
00:16:29 <athan> :t fmap ::: Maybe
00:16:30 <lambdabot> Not in scope: data constructor `:::'
00:16:30 <lambdabot> Not in scope: data constructor `Maybe'
00:16:31 <athan> or something
00:16:43 <bitemyapp> athan: why do you think Either and (->) have the same kind signature?
00:16:43 <athan> to grab the maybe instance
00:17:04 <athan> because they have the same number of parameters
00:17:06 <athan> type wise
00:17:12 <athan> I just see -> as application
00:17:21 <athan> when that's the _type_ of application
00:17:30 <athan> ie
00:17:34 <athan> ($) :: (->)
00:17:41 <athan> am I right?
00:17:48 <bitemyapp> every function takes an argument type and a return type.
00:18:00 <bitemyapp> :t ($)
00:18:00 <lambdabot> (a -> b) -> a -> b
00:19:43 <mm_freak> hi there
00:19:48 <ion> o hai
00:19:56 <mm_freak> what's the notation for an Int# literal?
00:20:00 <jle`> hi mm_freak
00:20:21 <ion> Does 42# work?
00:20:38 <bitemyapp> ion: hi
00:20:49 <ion> hi
00:20:55 <bitemyapp> mm_freak: hi
00:21:40 <mm_freak> ion: indeed, thanks
00:22:00 <jle`> augur: you followed me back, i am honored
00:22:21 <bitemyapp> jle`: he followed me back too.
00:22:26 <bitemyapp> jle`: honorable twitterer
00:22:30 <mm_freak> and yes, this is about outperforming C again…  i've already outperformed it, but i want to leave it further behind =)
00:22:34 <jle`> i am honored to be counted among your company
00:22:38 <jle`> mr. app
00:22:43 <augur> jle`: aha, you're that person! :)
00:22:47 <jle`> or is it myapp
00:22:54 <bitemyapp> HONOURABLE AND MOST AUGUST HASKELLERS
00:22:59 <jle`> or is it temyapp
00:23:04 <jle`> sir temyapp
00:23:06 <bitemyapp> jle`: I'm mostly just bite.
00:23:10 <Hafydd> HONOURABLE AND ALMOST APRIL HASKELLERS
00:23:13 <bitemyapp> Ask anybody.
00:23:14 <MP2E> haha
00:23:20 <jle`> do you mean augur haskellers
00:24:04 <jle`> bitemyapp: i didn't want to presume we were on that level of informality
00:24:11 <bitemyapp> jle`: I'm just kinda bitey.
00:24:21 <bitemyapp> jle`: observe: http://bitemyapp.com/
00:24:24 <bitemyapp> bitey.
00:24:38 <athan> :k (->)
00:24:39 <lambdabot> * -> * -> *
00:24:46 <athan> :k ((->) Int)
00:24:47 <lambdabot> * -> *
00:24:57 <athan> :k (((->) Int) Int
00:24:58 <lambdabot>     parse error (possibly incorrect indentation or mismatched brackets)
00:24:59 <athan> :k (((->) Int) Int)
00:25:00 <lambdabot> *
00:25:16 <athan> :k (->) $ Int
00:25:16 <lambdabot> Not in scope: type constructor or class `$'
00:25:18 <athan> lol
00:25:20 <bitemyapp> athan: you can query lambdabot in private btw
00:25:28 <bitemyapp> athan: or just use ghci
00:25:32 <athan> ow! That hurt!
00:25:36 <athan> kidding, sorry lol
00:27:04 <athan> woah
00:27:22 <athan> so (->) is a type constructor?
00:27:29 <jle`> yup
00:27:34 <athan> even though it's used to describe arguments in functions
00:27:39 <jle`> it is?
00:27:40 <athan> the arity of functions
00:27:49 <jle`> all types can describe arguments in functions
00:27:51 <athan> the need of an argument
00:27:51 <athan> er
00:27:56 <athan> the presense of function application
00:27:57 <athan> really
00:27:59 <athan> that operator
00:28:03 <athan> space
00:28:17 <jle`> functions don't really have different arities in haskell
00:28:23 <mm_freak> ok, Int# did not make my code faster…  i'm going back to the a lot less awkward Int =)
00:28:23 <athan> yeah
00:28:38 <athan> so (->) describes a level of curry-ness
00:28:39 <athan> lol
00:28:49 <bitemyapp> I don't know about that.
00:28:51 <athan> as a type constructor
00:28:59 <ion> mm_freak: What code are you working on?
00:29:00 <bitemyapp> there are hidden parentheses you're not seeing
00:29:07 <bitemyapp> (->) itself has nothing to do with currying
00:29:15 <bitemyapp> currying is how Haskell itself interprets the nested lambdas.
00:29:17 <athan> right
00:29:29 <AaronFriel> Suppose I have some IO function/monadic code that works like an event loop - reads from a channel, does some stuff, repeat. I want it to run an IO action that is sent to it through the channel (actually ResourceT IO ... but for the sake of argument). That function needs to run synchronously - it has to run to completion _before_ the loop circles around. BUT. I want to safeguard myself from any exceptions and have a failure mode.
00:29:31 <mm_freak> ion: i'm writing a faster-than-C sieve of eratosthenes…  i already got that by now, but i wanted more speed and more elegant code
00:29:33 <bitemyapp> I really think de-sugaring Haskell would help with intuition for stuff like this.
00:29:42 <bitemyapp> mm_freak: you want *more*? Greedy.
00:29:52 <ion> mm_freak: ok :-)
00:30:06 <bitemyapp> AaronFriel: you're gluing too many components together, sounds like.
00:30:09 <AaronFriel> How do I run "Some IO action" completely safely, discarding any exceptions thrown *during that code's execution*, without violating the rule folks have told me about not blocking async exceptions.
00:30:21 <mm_freak> bitemyapp: right now my haskell version is only /slightly/ faster, but i want it to be /way/ faster =)
00:30:31 <mm_freak> because the C version is pretty much at the edge =)
00:30:34 <johannesbodannes> how did you manage to achieve that?
00:30:37 <AaronFriel> bitemyapp: I am working with FFI code - I have to do it this way. If I don't run it synchronously, there's a problem. If I blow up in a Haskell exception, I have a problem, etc.
00:30:50 <johannesbodannes> mm_freak, I mean
00:30:51 <bitemyapp> AaronFriel: Marlow covers event processing and other things pretty nicely here: http://chimera.labs.oreilly.com/books/1230000000929
00:31:09 <mm_freak> johannesbodannes: originally by using Storable, but now i switched to the vector library, which makes my code slightly higher level
00:31:20 <johannesbodannes> oh ok
00:31:29 <bitemyapp> AaronFriel: so catch the exceptions?
00:31:29 <MP2E> unboxed vectors ftw heh
00:31:39 <mm_freak> MP2E: storable vectors actually =)
00:31:42 <AaronFriel> bitemyapp: But what exceptions? I'm running an IO action from someone else.
00:31:42 <MP2E> ah
00:31:46 <MP2E> interesting :P
00:32:10 <AaronFriel> bitemyapp: What I want to do is *not* block any async exceptions thrown to the event loop because I'm told this is bad
00:32:25 <AaronFriel> bitemyapp: But if the event loop has to run an IO action, it *must* fail gracefully and not blow up
00:32:45 <AaronFriel> bitemyapp: People keep telling me "No no, you can't catch SomeException, that's bad, you'll catch async exceptions"
00:32:46 <bitemyapp> AaronFriel: then it has to catch the exceptions.
00:32:54 <bitemyapp> okay.
00:32:58 <bitemyapp> AaronFriel: post the code on lpaste.
00:33:05 <bitemyapp> AaronFriel: mail the mailing list.
00:33:19 <AaronFriel> Which mailing list? I have the code on github
00:33:41 <mm_freak> johannesbodannes: this is the original version, if you're interested: http://lpaste.net/101507
00:33:50 <mm_freak> compilation instructions at the bottom
00:34:07 <AaronFriel> bitemyapp: I have the source here: https://github.com/AaronFriel/hyhac/blob/unified-backend/src/Database/HyperDex/Internal/Core.hs#L253-L256
00:34:15 <mm_freak> and i'll tweet the new version as soon as i'm happy with it =)
00:34:17 <athan> I definitely need to learn rankn types
00:34:17 <bitemyapp> oh lord.
00:34:26 <bitemyapp> AaronFriel: I had no idea you were the hyperdex client guy.
00:34:29 <AaronFriel> hahaha
00:34:36 <AaronFriel> Do I have a reputation?
00:34:39 <AaronFriel> Oh dear
00:34:48 <bitemyapp> AaronFriel: well. I talk to rescrv periodically and almost used HyperDex at a startup I was CTO at.
00:35:00 <bitemyapp> between that and being a Haskell user, yeah, you were on my radar.
00:35:13 <bitemyapp> (ended up using ElasticSearch instead, for which I am writing a client as we speak)
00:35:15 <AaronFriel> Sorry if my code wasn't up to snuff - I'm rewriting the backend (see branch) because I wanted to be totally safe
00:35:56 <bitemyapp> AaronFriel: Just...do whatever Marlow tells you to do: http://chimera.labs.oreilly.com/books/1230000000929/ch09.html
00:35:58 <AaronFriel> bitemyapp: I even wrote a sandbox emulator for HyperDex to test my implementation, and a "Chaos.Concurrent.STM" module that randomly throws exceptions inside the emulated HyperDex FFI layer.
00:36:25 <bitemyapp> AaronFriel: missed opportunity to call it the Chaos Orangutan
00:36:29 <AaronFriel> bitemyapp: I was pretty pleased with https://github.com/AaronFriel/hyhac/blob/unified-backend/sandbox/src/Chaos/Doomsday.hs
00:36:48 <AaronFriel> and https://github.com/AaronFriel/hyhac/blob/unified-backend/sandbox/src/Chaos/Concurrent/STM/TVar.hs
00:36:51 <bitemyapp> or Chaos HowlerMonkey
00:37:00 <johannesbodannes> btw has anyone ever really used haskell's various hs->js tools to work a phonegap application before? i've never really used phonegap before so i'm not sure but... on the surface though if say... GHCJS is injective on JS and phonegap is injective onto phone applications then haskell can compile into phone apps? <_<
00:37:02 <AaronFriel> I was definitely inspired by Netflix
00:37:09 <bitemyapp> withSTMChaos <--- lol
00:37:47 <AaronFriel> I figured if my code could hold up under bonkers exceptions from HyperDex, it could hold up in normal use
00:38:03 <bitemyapp> AaronFriel: but seriously, use the Marlow Concurrent/Parallel book
00:38:08 <AaronFriel> Okay
00:38:09 <johannesbodannes> maybe injective is an overstatement
00:38:17 <johannesbodannes> for GHCJS
00:38:18 <athan> So, in haskell, only concrete types are values
00:38:19 <athan> correct?
00:38:20 <bitemyapp> AaronFriel: his word is more or less where the buck stops on how to write good/safe/performant concurrent Haskell
00:38:27 <pharaun> I really need to acquire the Marlow book
00:38:29 <bitemyapp> athan: just read the report.
00:38:34 <athan> anything not concrete becomes a data type (or type constructor)?
00:38:39 <bitemyapp> athan: http://www.haskell.org/onlinereport/haskell2010/
00:38:44 <bitemyapp> athan: you'll waste less time if you just read the report.
00:38:57 <bitemyapp> pharaun: you can read it online in the meantime for free though.
00:39:02 <bitemyapp> makes for an eggscellent reference.
00:39:14 <pharaun> bitemyapp: the whole thing ?
00:39:17 <athan> bitemyapp: I remember far better through convorsation - you can have input on the resturn process
00:39:29 <athan> return*
00:39:30 <pharaun> sweet!
00:39:34 <bitemyapp> I don't like recitation of extant material :(
00:39:53 <bitemyapp> unless it's an obscure result like edwardk's monad, comonad, monoid comment earlier.
00:40:16 * bitemyapp goes back to smacking conduit around
00:41:17 <AaronFriel> bitemyapp: Thanks for the advice - I'll look into Marlow's text
00:41:58 <bitemyapp> AaronFriel: I don't think your use-case being FFI changes much. Most of the advice could be applied with an s/FFI/IO/g transform.
00:42:24 <bitemyapp> AaronFriel: in particular, try to stick with higher level APIs like Async. I don't like resolving MVar deadlocks.
00:42:50 <bitemyapp> AaronFriel: and consider Free Monads if you want to purify the DSL independent of the side-effecty loop/event crap.
00:43:01 <bitemyapp> if it's an actual AST that makes sense as a monad.
00:43:05 <bitemyapp> otherwise ignore me.
00:43:07 <pharaun> a bit random but when should i start considering listing haskell on my resume and maybe applying to haskell jobs? :)
00:43:16 <bitemyapp> pharaun: can you do Haskell in a production environment?
00:43:18 <pharaun> been using it for ~2y
00:43:25 <bitemyapp> pharaun: github?
00:43:38 <pharaun> https://github.com/pharaun
00:43:43 <bitemyapp> I'd just list that I'd done Haskell for 2 years and then name what I'd built
00:43:59 <pharaun> mostly learning projects - hComicFetcher, Karmator, firefox-bookmark
00:44:03 <pharaun> lots of them are really rough
00:44:05 * bitemyapp nods
00:44:19 <pharaun> like hComicFetcher is really really rough but i haven't had time to refine, been busy with karmator, doing an ircbot
00:44:27 <pharaun> to play with pipes and bunch of stuff like that
00:44:30 <bitemyapp> pharaun: make something impressive, in the meantime - be honest about the scope of projects you'd tackled.
00:44:40 <AaronFriel> bitemyapp: That may be the next step of writing code against HyperDex, particularly HyperDex Warp (the transactional variant)
00:44:43 <pharaun> bitemyapp: i never really have impressive ideas :)
00:44:54 <bitemyapp> pharaun: so, you'd make sense as a hire into an org that already has Haskell hackers, but probably not a good pick for a senior/lead that is introducing Haskell at a company, for example.
00:45:07 <bitemyapp> pharaun: eh careful, I have a long to-do list. I can just chuck you an item if you need help being kept busy.
00:45:13 <bitemyapp> a LOOOOOOOOONG to do list.
00:45:23 <bitemyapp> looooooooong cat is loooooooong to-do list.
00:45:43 <pharaun> bitemyapp: :) its more that i just tend to like silly stuff like irc bots, or comic fetcher, or eventually i was going to start porting a bunch of image duplication detection algo into haskell
00:45:49 <pharaun> to learn me some more ffi and high-performance code
00:46:11 <bitemyapp> pharaun: well if you want FFI/high-performance code, make a Haskell alternative to numpy.
00:46:27 <bitemyapp> or work on one of the existing matrix/vector math libraries such that they have an equivalent or better API to Numpy.
00:46:34 <bitemyapp> boom, impressive project. Have fun.
00:46:35 <AaronFriel> pharaun: it's interesting how much of the interesting code takes place at "interesting" intersections of features in Haskell
00:46:36 <pharaun> haven't put up any libraries yet but couple of the projects i've done has yielded up some library-like stuff
00:46:38 <bitemyapp> I can do this all night.
00:46:53 <bitemyapp> AaronFriel: I work on boring stuff. Like yanking JSON over HTTP.
00:46:56 <pharaun> bitemyapp: :p oh i know, i'm familiar with python and numpy, i code in python on my day job *shrugs*
00:46:58 <AaronFriel> pharaun: My code deals with an asynchronous FFI API where, if you don't do things in the right order, results **disappear**
00:47:10 <bitemyapp> pharaun: well? What are you waiting for? Replace the python crap.
00:47:20 <pharaun> bitemyapp: hm?
00:47:24 <bitemyapp> AaronFriel: I'm getting suspicious.
00:47:29 <pharaun> AaronFriel: :p
00:47:32 <bitemyapp> pharaun: numpy clone for Haskell go
00:47:34 <bitemyapp> go go go go.
00:47:34 <MP2E> rewrite all the python!
00:47:40 <bitemyapp> can't be hard.
00:47:41 <pharaun> bitemyapp: haha
00:47:49 <bitemyapp> I'm not really unserious.
00:47:57 <bitemyapp> it needs done, it involves FFI and high performance code
00:47:59 <pharaun> i was kinda leaning that way eventually if only to teach myself about more high perf stuff
00:48:01 <bitemyapp> it'd look hella good on a resume
00:48:05 <bitemyapp> sounds like a perfect project.
00:48:15 <jle`> bitemyapp: check out numeric haskell and carter 's work
00:48:26 <pharaun> i want to try to finish the silly irc bot and the comic but i'll probably do that next
00:48:33 <jle`> it's a similar kind of goal
00:48:35 <pharaun> because it would absolutely be up my alley
00:48:36 <bitemyapp> jle`: familiar with it, but I wanted to see if he was serious about making things before intro'ing.
00:48:39 <jle`> ah
00:48:43 <jle`> mk, popped in out of context
00:48:47 <bitemyapp> np
00:48:55 <pharaun> bitemyapp: http://amrutlar.com/articles/2011/12/python-duplicate-image-finder_part-2
00:48:57 <AaronFriel> bitemyapp: HyperDex is a cruel mistress when it comes to her asynchrony. All functions that return data actually return handles. You pass the FFI function a pointer to a null pointer. Every time your handle is returned by hyperdex_client_loop, the null pointer is overwritten with a pointer to fresh data.
00:48:59 <bitemyapp> jle`: I talk to carter about NH at regular intervals.
00:49:16 <bitemyapp> AaronFriel: derferk.
00:49:28 <pharaun> bitemyapp: dunno if my code is worth shit, but i spent a ton of time pouring through the asm manuals and got the primitive SAD algo to go pretty quickly
00:49:30 <AaronFriel> bitemyapp: Well the whole thing is totally async from the user perspective. very high concurrency
00:49:34 <bitemyapp> AaronFriel: sounds like it'd be less work to just write a fully native client mate.
00:49:41 <bitemyapp> AaronFriel: that's what we did with Revise.
00:49:43 <bitemyapp> Way easier.
00:49:47 <AaronFriel> bitemyapp: so you can run like, 1000 gets/puts/etc at a time
00:49:58 <AaronFriel> bitemyapp: treat every action as a future, which you can demand
00:50:04 <bitemyapp> AaronFriel: yeah, that's what we did with Revise too.
00:50:15 <bitemyapp> AaronFriel: fully asynchronous and pipelined connection management
00:50:17 <AaronFriel> bitemyapp: Well that's what I implemented against the HyperdexClient API
00:50:20 <bitemyapp> AaronFriel: took like a weekend.
00:50:23 <pharaun> its probably not great compared to what the x264 folks was able to pull off but *shrugs* i was happy with my results there and i was wanting to try to start porting some numpy like stuff over to haskell
00:50:28 <pharaun> so i could do that kind of stuff in haskell maybe
00:50:33 <bitemyapp> AaronFriel: yeah but it sounds like the FFI design is more pain than its worth.
00:50:42 <bitemyapp> AaronFriel: in Revise, we were talking Protocol Buffers over TCP.
00:50:47 <AaronFriel> ah
00:51:00 <AaronFriel> bitemyapp: I figure I'm not smart enough to compete with Cornell grad students in implementing an API that talks over the network to HyperDex, esp. when it's in flux
00:51:09 <bitemyapp> AaronFriel: results can appear out of order, responses are tagged with whatever unique id provided for the request.
00:51:11 <AaronFriel> bitemyapp: I'm an undergrad.
00:51:17 <bitemyapp> AaronFriel: I'm a no-grad.
00:51:28 <bitemyapp> AaronFriel: I dropped out my first semester, schooling has fuck-all to do with it.
00:51:47 <pharaun> bitemyapp: but anyway it sounds like i should keep working and eventually get together something really nice/interesting then go from there?
00:51:51 <pharaun> thanks for the advice :)
00:51:52 <bitemyapp> AaronFriel: just do the right thing. Don't let a notion of hierarchy make decisions for you. It's irrational as fuck.
00:52:01 <bitemyapp> pharaun: Iuno.
00:52:03 <bitemyapp> pharaun: make things.
00:52:15 <AaronFriel> bitemyapp: I actually came to my university because of a student group there that I wanted to get involved with.
00:52:45 <AaronFriel> bitemyapp: And I've told people that ever since and they don't believe me. No one goes to a university to be involved in student groups.
00:53:34 <bitemyapp> okay
00:54:19 <jle`> i believe you AaronFriel
00:54:41 <bitemyapp> AaronFriel: we all believe you.
00:54:51 <jle`> maybe one person doesn't believe you
00:54:54 <jle`> but don't mind them.
00:54:56 <AaronFriel> D'aww, you guys.
00:58:34 <athan> so a sum type is like having multiple data types in one constructor, while a product type has multiple constructors, correct? Or is it the opposite?
00:58:43 <athan> like
00:58:45 <athan> sum =
00:58:54 <athan> data Foo = Foo Int String Bar
00:58:56 <athan> vs
00:59:07 <athan> data Product = One | Two | Three
00:59:10 <AaronFriel> Sum is like "data Nat = Zero | Succ Nat"
00:59:16 <AaronFriel> well
00:59:18 <AaronFriel> that's not a good example
00:59:23 <AaronFriel> Sum is like Either
00:59:24 <bitemyapp> athan: the dual of a sum type is a product type
00:59:28 <bitemyapp> athan: the dual of a product type is a sum type
00:59:39 <athan> interesting
00:59:44 <AaronFriel> athan: Either is *either* an A or a B
00:59:47 <athan> bytemyapp: Thank you
00:59:52 <jle`> athan: your examples are opposite
00:59:55 <AaronFriel> athan: So if you counted the total number of possible values
00:59:58 <bitemyapp> with a sum type, many arrows lead to one thing. With a product type, one thing has many arrows going to many things.
01:00:13 <AaronFriel> athan: If there are 500 possible "A"s and 200 possible "B"s, how many "Either A B"s are there?
01:00:20 <AaronFriel> athan: Exactly 700.
01:00:20 <athan> AaronFriel: Ahh, I see. They're not mutually exclusive instances
01:00:42 <AaronFriel> athan: A product type is like "(A, B)"
01:00:46 <bitemyapp> athan: set cardinality comes up in type theory because type theory came from set theory.
01:00:59 <bitemyapp> it's all connected. because math or whatever.
01:01:07 <athan> hahaha
01:01:10 <jle`> say there are 500 A's, 200 B's, and 300 C's.  how many Foo's are possible: data Foo = Bar A | Baz B C
01:01:11 <athan> we're lucky it is
01:01:19 <athan> ahhhh
01:01:23 <bitemyapp> jle`: stop making my head hurt pls
01:01:35 <jle`> it is a curse :/
01:01:40 <athan> see that's where I'm lost atm
01:01:42 <jle`> i am destined to harm all around me
01:01:49 <jle`> athan: okay let's start smaller
01:01:53 <jle`> how many (Bool,Bool) tuples are there?
01:01:58 <jle`> you can list all of them if you want
01:01:59 <athan> so mutually exclusive instances, ie Foo = Bar | Baz
01:02:00 <bitemyapp> jle`: cash rules everything around me.
01:02:12 <athan> that's multiplication of the total possabilities, right?
01:02:17 <jle`> maybe.
01:02:19 <jle`> is it?
01:02:30 <jle`> i'm sure you can find an answer with more confidence than that :)
01:02:35 <jle`> list out all the possibilities.
01:02:46 <bitemyapp> jle`: 0..n?
01:02:50 <athan> jle`: ahhhhhhhhhhhhhhhhhhh
01:02:51 <bitemyapp> that's a big list of possibilities.
01:02:51 <jle`> (Bool,Bool)
01:02:55 <osa1> how do I know which handle reading functions are lazy?
01:03:06 <athan> jle`: which is equal to data Foo = Foo Bool Bool
01:03:06 <jle`> there's...(False,False) .... (False,True) .... and....
01:03:08 <jle`> um
01:03:10 <jle`> i forgot all of them.
01:03:22 <jle`> athan: no yeah, Foo in that case is just a fancy tuple
01:03:46 <athan> jle`: While an either makes a sum
01:03:52 <athan> awesome
01:03:55 <athan> thank you!!!
01:03:55 <bitemyapp> jle`: YOU'RE a fancy tuple.
01:03:59 <bitemyapp> jle`: you and your face.
01:04:01 <jle`> do you see why they are called product and sum
01:04:09 <bitemyapp> (set cardinality)
01:04:09 <athan> yes
01:04:15 <athan> why cardinal?
01:04:27 <bitemyapp> ask a mathematician
01:04:30 <athan> lol
01:04:30 <bitemyapp> I don't pick deez names.
01:04:52 <AaronFriel> athan: comes from the method they invented for counting universals
01:04:55 <jle`> if you had Either Bool Bool, you can have Left True, Left False, Right True, Right False
01:04:56 <AaronFriel> athan: I mean catholics
01:05:15 <jle`> so if there are 3 possible A's, 2 possible B's, and 5 possible C's
01:05:21 <jle`> data Foo = Bar A | Baz B C
01:05:29 <jle`> there are 3 + 2 * 5 possible Foo's
01:06:09 <AaronFriel> jle`: And many interesting ways to get bottom.
01:06:21 <jle`> :P
01:06:25 <athan> so with sum types
01:06:29 <athan> there must be at least one
01:06:38 <athan> ...and same with product types
01:06:54 <AaronFriel> athan: not necessarily, there are "uninhabited" types like Void which might be considered the additive identity
01:06:55 <athan> there must be one value besides _|_
01:07:03 <athan> ahh
01:07:04 <athan> okay
01:07:19 <athan> well, in... userspace at least then haha
01:07:36 <AaronFriel> athan: pretending bottom doesn't exist is also generally easiest, because when you start getting into proper strictness analysis and evaluating bottom cases, you are probably already having a bad day
01:08:14 <Hafydd> athan: http://www.etymonline.com/index.php?allowed_in_frame=0&search=cardinal+number&searchmode=none
01:08:23 <bitemyapp> let signsOfMadness = (fmap . fmap)
01:08:33 <bitemyapp> :t signsOfMadness
01:08:33 <lambdabot> Not in scope: `signsOfMadness'
01:08:36 <bitemyapp> sigh.
01:08:40 <bitemyapp> :t (fmap . fmap)
01:08:41 <lambdabot> (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
01:08:47 <athan> bitemyapp: http://www.ebaumsworld.com/video/watch/83952880/
01:08:50 <AaronFriel> Hafydd: that was my joke :) - catholic means "universal", cardinals = counting catholics
01:09:16 <Aetherspawn> > (fmap . fmap) (+1) (Just (Just 2))
01:09:17 <lambdabot>  Just (Just 3)
01:09:23 <Aetherspawn> laaame.
01:09:34 <bitemyapp> athan: not bad.
01:09:37 <bitemyapp> Aetherspawn: why is that lame?
01:09:43 <Aetherspawn> was expecting something crazy esoteric
01:09:47 <Aetherspawn> :P
01:09:56 <bitemyapp> Aetherspawn: you use Haskell and don't want predictable code? Who the fuck are you?
01:10:13 <jle`> the spawn of aether.
01:10:18 <jle`> no one but.
01:10:35 <bitemyapp> jle`: thanks for pattern-matching into that constructor. Couldn't have done it without you.
01:10:43 <bitemyapp> vijaykiran: hullo.
01:11:36 <Aetherspawn> people throw stuff at me using things like >>= and join
01:11:41 <spacekitteh> how can i make sure that ghc+llvm doesn't optimise out my compensated summation code?
01:11:46 <Aetherspawn> I find it hard to reason about what they actually do
01:11:55 <Aetherspawn> fmap is quite a bit easier
01:12:09 <vijaykiran> bitemyapp: .olluh
01:12:19 <bitemyapp> vijaykiran: I'm a fellow Clojure refugee.
01:12:24 <Hafydd> "Cardea or Carda was the ancient Roman goddess of the hinge (Latin cardo, cardinis), Roman doors being hung on pivot hinges. The Augustan poet Ovid conflates her with another archaic goddess named Carna ..."
01:12:39 <bitemyapp> vijaykiran: I remember reading your tutorials to learn Clojure libraries ages ago.
01:12:43 <bitemyapp> vijaykiran: https://github.com/bitemyapp/
01:12:51 <bitemyapp> vijaykiran: welcome to the dark side of the force.
01:13:08 <vijaykiran> bitemyapp: yup I your carpet-bombin-twitter stream :)
01:13:14 <bitemyapp> vijaykiran: <3
01:13:18 <bitemyapp> I carpetbomb with love.
01:13:32 <bitemyapp> so. Lenses and recursive functor containers.
01:13:34 <bitemyapp> Thoughts?
01:13:40 <vijaykiran> bitemyapp: that's fair then :)
01:13:44 <jle`> Aetherspawn: fmap lifts a function on values to a function inside the functor.  fmap again lifts that new function into a function inside another layer of functor
01:14:02 <vijaykiran> bitemyapp: I'm still new around here - getting hang of stuff fighting SHM in Emacs etc.
01:14:06 <bitemyapp> jle`: I feel like Aether knew what it was and what to expect, they just want Perl in their Haskell.
01:14:12 <AaronFriel> bitemyapp: much tweet. very words.
01:14:23 <bitemyapp> vijaykiran: I still don't use SHM yet. Too busy writing code and having fun to yak-shave that (yet)
01:14:31 <bitemyapp> I just use vanilla haskell-mode + Emacs.
01:14:56 <Hafydd> "The power to avert vampiric striges[1], which Ovid attributes to the conflated Cardea-Carna, probably belonged to Carna, while the charms fixed on doorposts are rightly Cardea's." [1] "Strix (pl. striges or strixes) was the Ancient Roman and Greek word for owl. In folklore it was considered a bird of ill omen that fed on human flesh and blood, a product of metamorphosis."
01:15:18 <bitemyapp> Hafydd: ...wut
01:15:28 <AaronFriel> bitemyapp: I think he took my cardinality etymology joke too far
01:15:36 <bitemyapp> AaronFriel: HAHAHAHAHA
01:15:39 <bitemyapp> AaronFriel: yeesh.
01:15:48 <bitemyapp> vijaykiran: if you need any help getting things rolling in Haskell please ping me.
01:16:15 <vijaykiran> bitemyapp: I finished LYAH and started on Haskell School of Expresion stuff - but the graphics are bit wonky for me
01:16:25 <bitemyapp> I need to figure out how to intermediate the type-dispatched decoding process of Aeson.
01:16:41 <bitemyapp> vijaykiran: This is what worked for me: https://gist.github.com/bitemyapp/8739525
01:16:43 <vijaykiran> bitemyapp: thanks, sure. I'll tweet at you :)
01:17:38 <pharaun> bitemyapp: oh you worked on korma? cool
01:17:40 <vijaykiran> bitemyapp: RWH was a bit "overwhelming", which I did start with
01:19:19 <Aetherspawn> jle`: I'm aware, actually a good thing to remember is fmap ~ map
01:19:25 <Aetherspawn> helped reason about it
01:19:30 <AaronFriel> bitemyapp: re: Lens can probably do it
01:19:44 <bitemyapp> AaronFriel: wut
01:19:51 <AaronFriel> bitemyapp: I'm fairly sure there is literally no type hackery that Kmett can't accomplish
01:19:55 <bitemyapp> vijaykiran: yeah, that's partly why I say RWH is more of a reference.
01:20:00 <bitemyapp> AaronFriel: I kno rite.
01:20:40 <AaronFriel> bitemyapp: I don't even think he sees code, or the world anymore. Just prisms, lenses, profunctors...
01:21:15 <bitemyapp> nuts. you saying that just nerd-sniped me.
01:21:59 <AaronFriel> bitemyapp: Don't look at the profunctors package
01:22:21 <AaronFriel> bitemyapp: You get language like this "class Profunctor p => Strong p where ... Generalizing upstar of a strong Functor"
01:22:33 <bitemyapp> AaronFriel: well, actually, I was thinking about coalgebras and vectors
01:22:45 <Aetherspawn> https://github.com/kvanberendonck/cmake-haskell :)
01:22:47 <bitemyapp> and relating it to comonads and lenses.
01:22:55 <AaronFriel> bitemyapp: I barely understand what a functor is, I don't know about generalizing them, or upstarring them, or what a strong Functor is.
01:23:01 <bitemyapp> Aetherspawn: why you show me this?
01:23:15 <bitemyapp> AaronFriel: just write Haskell. I wouldn't worry about it.
01:23:39 <Aetherspawn> experimenting with building different parts of ghc with cmake
01:23:45 <AaronFriel> bitemyapp: Kmett's libraries scare me. I avoid them because I am not strong enough.
01:24:02 <Aetherspawn> I noticed I needed something more powerful than cabal, maybe others need it too
01:24:19 <bitemyapp> AaronFriel: I use lens quite happily. I don't really worry about his infrastructure, that stuff is inside baseball. I might use Free too.
01:24:44 <Aetherspawn> every 5 minutes carter reminds me the ratio of my complaints versus my ghc patches
01:24:47 <Aetherspawn> -_-
01:25:10 <AaronFriel> bitemyapp: I mean, strong enough to avoid going down the rabbit hole of trying to use his more exotic code to "simplify" mine
01:25:56 <mariomystic> Does using Specialize pragma on members of a type class has any benefit for types which I am using most with that type class?
01:26:36 <mariomystic> For example If I Specialize (+) for Int, will that be any better if I am working mainly with Ints?
01:26:54 <cYmen_> bitemyapp: What's a free monad?
01:27:09 <bitemyapp> cYmen_: I'm glad you asked!
01:27:18 <Aetherspawn> mariomystic: it does if they use the default implementation
01:27:33 <mariomystic> Aetherspawn: Can you elaborate on that?
01:27:40 <Aetherspawn> say you have something like this
01:27:45 <Aetherspawn> class Foo a where
01:27:49 <Aetherspawn>   (+) :: a -> a -> a
01:27:51 <bitemyapp> cYmen_: first, my learning Haskell gist: https://gist.github.com/bitemyapp/8739525 now free monad material: http://www.haskellforall.com/2012/06/you-could-have-invented-free-monads.html http://ncatlab.org/nlab/show/free+monad http://stackoverflow.com/questions/13352205/what-are-free-monads
01:28:07 <Aetherspawn> if there was a default implementation of (+) in class Foo then you would benefit from specializing it for Int
01:28:21 <Aetherspawn> that would be the case if you did instance Foo Int { }
01:28:46 <Aetherspawn> if you did instance Foo Int { a + b = ... } though, I'm pretty sure specialize doesn't buy you anything.
01:28:48 <bitemyapp> cYmen_: the brief, practical answer is that it's a way to model a DSL and its transformations in a pure way before an interpreter gives it a specific set of actions/implementation to perform per the grammar described.
01:29:01 <mariomystic> Aetherspawn: What about instance Foo Int where (+) a b = some definition for nt addition here. ?
01:29:08 <bitemyapp> cYmen_: the usual way to do it is to have a nested AST of a sum type that strongly resembles a list.
01:29:23 <cYmen_> What's a transformation in this case?
01:29:24 <mariomystic> The if I specialize (+) for Int, is that beneficial?
01:29:35 <bitemyapp> cYmen_: in some respects, it's a type-safe alternative to the way Lispers will do DSLs with macros that helps to make more of your code pure and free of side-effects.
01:29:45 <bitemyapp> mariomystic: benchmark it, find out.
01:29:48 <Aetherspawn> No, because (+) has the solid type Int -> Int -> Int already
01:29:50 <AaronFriel> bitemyapp: The next step for HyperDex (probably this summer or fall) is to implement a free monad for transactionional HyperDex Warp
01:30:11 <AaronFriel> bitemyapp: Or something like it, something to make STM and HyperDex Warp work together.
01:30:18 <bitemyapp> cYmen_: well, silly example. Lets say you have a sequence of three actions described by your DSL. You want to reverse the order of them before they get executed. That's similar to a "Clojure macros 101" example I've seen before.
01:30:33 * bitemyapp salutes AaronFriel 
01:30:38 <bitemyapp> you who are about to die...we salute you.
01:30:48 <Aetherspawn> specialize only helps when the type still has some polymorphism left
01:31:04 <bitemyapp> Aetherspawn: otherwise you can trust GHC to monomorphize cantcha?
01:31:18 <cYmen_> bitemyapp: and why are they called free monads?
01:31:19 <mariomystic> Aetherspawn: Thanks.
01:31:21 <Aetherspawn> well, you don't need to trust GHC to do anything I don't think
01:31:43 <Aetherspawn> in that parciular example it's the same as if (+) were just some function in the module scope which was Int -> Int -> Int
01:31:47 <Aetherspawn> (minus the type dictionary)
01:31:53 <mariomystic> cYmen_: Because you are free to use them :)
01:32:06 <pharaun> ha
01:32:52 <mariomystic> Aetherspawn: One more question, If I define instance Bar a => Foo a where
01:32:53 <zRecursive> mariomystic: no any charge :)
01:33:03 <AaronFriel> bitemyapp: Appreciate the salute, with that I'm going to retire
01:33:15 <AaronFriel> bitemyapp: To sleep, not from life or work.
01:33:29 <bitemyapp> cYmen_: http://comonad.com/reader/2008/monads-for-free/
01:33:30 <mariomystic> And then use functions from Bar to define members of Foo. I think then the functions of Foo are still polymorphic?
01:33:31 <bitemyapp> AaronFriel: get sleep.
01:34:11 <Aetherspawn> Correct, there's some funnybugger going on there
01:34:15 <bitemyapp> cYmen_: almost none of this is going to make sense right now. If you're really curious, just start learning Haskell and see where it takes you.
01:34:31 <Aetherspawn> but remember that Foo Int and Bar a => Foo a are overlapping if Int implements Bar
01:35:16 <Aetherspawn> so you end up with the function
01:35:36 <Aetherspawn> (+) :: Bar a => a -> a -> a, I think (but im unsure) is how ghc might handle that
01:35:56 <Aetherspawn> ping bitemyapp bitemylogic
01:35:58 <cYmen_> bitemyapp: Learned haskell twice, forgot everything about it again.
01:36:31 <mariomystic> Aetherspawn: Yeah. I have to define instances for Foo(and ew others) for lots of types. I have two alternatives, one is to do that for each type. Other is to define a new class Bar which has 2 members and using that I can define instances for all the classes generically. Now I just wondered if second way will add any penalty over the first?
01:36:55 <bitemyapp> cYmen_: learn Kmettian Haskell this time.
01:37:02 <bitemyapp> it's tons-o-fun.
01:37:20 <Aetherspawn> as long as you inlinable everything, GHC is pretty good at optimizing away haskell-ey abstraction
01:37:24 <athan> edwardk: commutative group comonad?
01:37:25 <cYmen_> bitemyapp: What's that?
01:37:26 <Aetherspawn> I'd say implement is generically first and then benchmark
01:37:35 <Aetherspawn> core inspections etc
01:37:47 <mariomystic> Aetherspawn: Thanks
01:47:01 <bitemyapp> jle`: how handy are you with Aeson?
01:47:24 <jle`> bitemyapp: i used it
01:47:27 <jle`> um
01:47:35 <jle`> to serialize and unserialize some databases
01:47:43 <jle`> in json
01:47:45 <jle`> that's about it
01:47:58 <bitemyapp> jle`: so I've got these JSON responses with an inner document that only my user/caller will know the type of
01:48:27 <bitemyapp> jle`: I want to type/deserialize everything but the inner document and allow Aeson to do its dispatched deserialization against that inner document field. Ideas?
01:49:24 <bitemyapp> like {status = 200, myDocs = [UserType]}
01:49:46 <bitemyapp> the outer bit my client library can define, but the UserType needs to be provided by a user.
01:50:27 <jle`> maybe you can do a read-like typeclass based thing?
01:50:35 <jle`> actually
01:50:41 <jle`> no you can just use a parameterized data type
01:50:50 <bitemyapp> wut
01:50:51 <jle`> can you?
01:50:54 <bitemyapp> oh.
01:50:56 <bitemyapp> probably.
01:51:04 <bitemyapp> I feel dumb now. brb.
01:51:07 * bitemyapp testing
01:51:10 <jle`> data HasMyDoc a = HasMyDoc { status :: Int; docs :: [a] }
01:51:17 <jle`> er, myDocs :: [a]
01:51:27 <jle`> and then write the proper to/fromjson instances
01:51:29 <bitemyapp> ya ya
01:51:34 <bitemyapp> well, I don't write the instances
01:51:36 <bitemyapp> GHC.Generics does
01:51:38 <bitemyapp> bwahahaha
01:51:39 <identity> bitemyapp: If I understand your problem correctly, I did it with a parametrized data type
01:51:48 <bitemyapp> identity: yeah I think that's going to be it.
01:51:52 <bitemyapp> can you tell it's 0350 here?
01:52:11 <angerman> so I have something like this [[["A","1",...],...],[["B","2",...],...],[["A","3",...],...],...]. And I'd like to write a function that takes [[["A","",...],...],[["B","",...],...],[["A","",...],...],...] and returns the former. E.g. insert the sequence number in the second place of every first element in the list of lists.
01:53:33 <jle`> angerman: how comfortable are you with nested/multiple maps
01:53:46 <bitemyapp> frak.
01:53:52 <identity> bitemyapp: we are both up at ungodly hours, then. It's 10 am on a saturday here, and I was up at 8 am. I'm a friggin university student. I should be sleeping off a hangover past noon.
01:53:59 <jle`> angerman: see zipWith
01:54:07 <angerman> jle`: could you explain a little. It's my second day with Haskell :)
01:54:08 <bitemyapp> well I think this is the right way to go, but it's spewing a Nothing out.
01:54:34 <angerman> zipWith sounds good. so I take an infnite sequence and zip it with my structure. right?
01:54:45 <angerman> jus tneed to figure out how to put the sequence at the right place :D
01:55:05 <jle`> > zipWith ($) (id : map (show . const) [1..]) ["A","","","",""]
01:55:06 <lambdabot>  Couldn't match type `[GHC.Types.Char]'
01:55:06 <lambdabot>                with `[GHC.Types.Char] -> [GHC.Types.Char]'
01:55:06 <lambdabot>  Expected type: (b0 -> a0) -> [GHC.Types.Char] -> [GHC.Types.Char]
01:55:06 <lambdabot>    Actual type: (b0 -> a0) -> GHC.Base.String
01:55:17 <jle`> hm.
01:55:28 <jle`> oh i flipped it
01:55:37 <jle`> > zipWith ($) (id : map (const . show) [1..]) ["A","","","",""]
01:55:38 <lambdabot>  ["A","1","2","3","4"]
01:55:50 <jle`> do you understand that?
01:55:54 <identity> bitemyapp: didn't you need a FromJSON constraint on the type parameter or something? I had to use GADTs to be able to do that, anyway
01:56:28 <angerman> jle`: that : is new to me.
01:56:36 <mariomystic> Aetherspawn: Ran into undecidable instances while doing instance Bar a => Foo a where ...
01:56:38 <jle`> :t (:)
01:56:38 <lambdabot> a -> [a] -> [a]
01:56:41 <jle`> > 1 : [2,3,4]
01:56:42 <lambdabot>  [1,2,3,4]
01:56:50 <angerman> ahh! dang.
01:56:54 <jle`> it prepends an element to a list
01:57:08 <jle`> so in our case, we have a list of String -> String functions
01:57:10 <angerman> yea right. x:y i new. just never seen it in that place.
01:57:18 <jle`> the first String -> String is id, it leaves the string intact
01:57:20 <bitemyapp> identity: Can't make a derived instance of `Generic (Status a)':
01:57:22 <bitemyapp> sad-face.
01:57:37 <bitemyapp> data (FromJSON a, Generic a) => Status a
01:57:41 <jle`> the next String -> String is (const (show 1))
01:57:42 <bitemyapp> deriving (Show, Generic) on both.
01:58:06 <jle`> do you know what const and show are?
01:58:12 <angerman> yep.
01:58:20 <jle`> so you probably know what const (show 1) does?
01:58:33 <jle`> it's the same as const "1"
01:58:37 <angerman> gives me "1" ... textual representation of 1
01:58:50 <jle`> it gives you a function that ignores its input and always returns "1"
01:59:02 <jle`> > (const (show 1)) "hello"
01:59:02 <lambdabot>  "1"
01:59:26 <jle`> so you have a list of String -> Strings...the first one leave sthe string unchanged, the second one always returns "1", the third one always returns "2"...
01:59:55 <jle`> and then you zip that list of functions with a list of things to apply it to
02:00:00 <angerman> so I have list of functions returning incrementing numbers, while ignoring any input given.
02:00:18 <jle`> zipWith ($) [f,g,h] [x,y,z] ==== [f x, g y, h z]
02:00:23 <jle`> you know what ($) is, right?
02:00:30 <jle`> ($) f x = f x
02:01:01 <jle`> angerman: yup. only the first function in that list is `id`.
02:01:14 <shouya> @pl \a -> (f (g . a))
02:01:14 <lambdabot> f . (g .)
02:01:42 <angerman> jle`. alright. That just got me confused a little.
02:01:50 <jle`> try it out
02:01:54 <angerman> jle`: i was just trying to work out what id : was supposed to do :)
02:01:58 <jle`> ah, okay :)
02:02:10 <angerman> completely forgot that it was just prepending id to the list.
02:02:16 <jle`> yup
02:02:39 <jle`> you get used to it :)
02:03:05 <angerman> I guess so. $ and . throw me off rail from time to time.
02:03:19 <agreco> I’m currently reading through learnyouahaskell for great good
02:03:24 <jle`> yeah, it's just good to remember that they are normal functions. and then just look at the source
02:03:26 <jle`> @src ($)
02:03:26 <lambdabot> f $ x = f x
02:03:29 <jle`> @src (.)
02:03:29 <lambdabot> (f . g) x = f (g x)
02:03:29 <lambdabot> NB: In lambdabot,  (.) = fmap
02:03:34 <Aetherspawn> mariomystic: that's expected
02:03:39 <agreco> and have discovered the site has a free online version
02:03:56 <agreco> which seems to have different content
02:04:25 <agreco> which do I pursue, the paperback or the online version?
02:04:26 <Cale> agreco: Oh, is it different? I didn't know that
02:04:31 <agreco> yeah
02:04:32 <angerman> jle` could one call it application and composition?
02:04:34 <agreco> it is
02:04:41 <jle`> angerman: yeah
02:04:46 <narendraj9__> @src head
02:04:46 <lambdabot> head (x:_) = x
02:04:46 <lambdabot> head []    = undefined
02:04:53 <jle`> angerman: look at the types, too..those help
02:04:55 <jle`> :t ($)
02:04:56 <lambdabot> (a -> b) -> a -> b
02:04:57 <jle`> :t (.)
02:04:57 <agreco> esp. chapter 6
02:04:57 <lambdabot> (b -> c) -> (a -> b) -> a -> c
02:05:12 <narendraj9__> Can I do something like @src in ghci?
02:05:20 <peteretep> Calling . 'after' has helped me read it
02:05:21 <agreco> the online version has a whole section on Data.set
02:05:22 <jle`> agreco: i'd imagine that the online one would be the more up to date one?  but i do not have any evidence to support this
02:05:34 <Cale> narendraj9__: All that @src does is look things up in a hand-crafted text file
02:05:34 <jle`> narendraj9__: no :(  but
02:05:40 <agreco> this is what I’m thinking
02:05:42 <peteretep> As for $, the trick is to use it EVERYWHERE and get hlint to fix it ;-)
02:05:46 <Cale> narendraj9__: The haddock documentation has source links
02:06:25 <narendraj9__> Cale, okay. It would have been very handy with ghci had something similar.
02:06:31 <Cale> If you start from here, or the relevant package page on hackage, http://www.haskell.org/ghc/docs/latest/html/libraries/index.html
02:06:32 <narendraj9__> *if ghci
02:06:39 <jle`> it's just a plain text file; if you find it, you can grep it :)
02:06:59 <angerman> jle`: so to replace an elemnt on a certain position in a list, I would use (take n x) : new elem : (drop n x) ?
02:07:13 <narendraj9__> jle`, where's the file?
02:07:16 <agreco> I came on here as “bonus” is reportedly idling on here
02:07:34 <Cale> agreco: That was true back when he was writing the book
02:07:35 <jle`> narendraj9__: https://github.com/mokus0/lambdabot/blob/master/lambdabot/State/source
02:07:50 <Cale> agreco: But he disappeared and we've been wondering where he went ever since.
02:07:55 <narendraj9__> Cale, thanks for the link.
02:07:55 <jle`> angerman: well
02:08:05 <jle`> angerman: remember that lists aren't really the right data structure you want to use
02:08:08 <no-n> @src liftM
02:08:09 <lambdabot> liftM f m1 = do { x1 <- m1; return (f x1) }
02:08:09 <jle`> if you want to do things at indexes
02:08:15 <jle`> lists aren't meant to be indexed data structures
02:08:22 <jle`> arrays and vectors, etc. are
02:08:22 <agreco> ah damn it
02:08:28 <Cale> narendraj9__: You'll see grey source links along the right edge of each module's page for each entry
02:08:31 <jle`> they are mostly used as control flow
02:08:43 <jle`> however...you *can* do things manually
02:08:47 <Cale> if you click them, you'll be taken to syntax highlighted source for the relevant definition
02:08:48 <angerman> jle`: lisp heritage showing through?
02:09:02 <narendraj9__> Cale, yes I can see the source.
02:09:10 <jle`> angerman: perhaps :)
02:09:18 <jle`> angerman: but also your statement does not typecheck
02:09:28 <jle`> : takes a single element on one side
02:09:30 <jle`> and the lst on the other
02:09:49 <angerman> so I need a concat then.
02:09:49 <jle`> and it associates like a:(b:(c:d))
02:09:52 <jle`> angerman: yeah
02:09:55 <Cale> agreco: However, you ought to stick around anyhow, this is a good place to ask lots of questions :)
02:10:06 <jle`> but in real life you shouldn't be doing things like this with lists
02:10:12 <angerman> jle`: I'll try the list version first, and then move to vectors?
02:10:13 <agreco>  @Cale thanks
02:10:22 <agreco> will do
02:10:30 <jle`> angerman: yea, try it now as a learning exercise :)
02:10:37 <agreco> btw the book is pretty awesome
02:10:53 <jle`> angerman: just letting you know that if it looks kinda ugly, that's because it's intentional :)
02:11:02 <Cale> agreco: yeah, it's usually what we recommend to beginners :)
02:11:12 <agreco> gives me an excuse it reread the online version :p
02:11:20 <angerman> jle`: thanks. I'll try to get it done with lists. and then compare how it would looks with a vector.
02:11:39 <identity> WRT books -- what happened to the online version of rwh? Why doesn't it get any updates? Bunch of output that is full of errors like it was automated, etc..
02:12:27 <jle`> rwh's author is still active and about, too
02:12:39 <jle`> it might have something to do with the publisher maybe
02:13:12 <bitemyapp> yisssss
02:13:21 <bitemyapp> identity: got it working, but had to write manual instance.
02:13:41 <identity> bitemyapp: That's what I had to do as well, using GADTs.
02:14:10 <jle`> bitemyapp: :D
02:14:23 <bitemyapp> identity: I didn't use GADTs.
02:14:33 <bitemyapp> identity: what'd you need those for?
02:15:13 <identity> bitemyapp: In my specific use case, as far as I could see, the only way to add the FromJSON constraint on the type parameter was to use GADTs
02:15:26 <bitemyapp> identity: huh, I didn't need to.
02:15:33 <bitemyapp> data (FromJSON a, ToJSON a) => Status a =
02:15:38 <bitemyapp> instance (FromJSON a, ToJSON a) => FromJSON (Status a) where
02:15:52 <identity> hmm. well, it was a while ago, I don't quite remember why.
02:15:54 <angerman> jle`: not too shaby, no: replaceSnd (x:_:xs) e = x:e:xs
02:16:07 <jle`> angerman: pretty good :)
02:16:14 <jle`> the function is partial though
02:16:18 <bitemyapp> identity: I'm not using any extensions at the moment.
02:16:22 <jle`> so just treat it with much caution
02:16:25 <bitemyapp> neither typefamilies nor GADTs.
02:16:30 <angerman> jle`: pardon me?
02:16:40 <bitemyapp> identity: I added the typeclass constraints in an ad-hoc manner. I let the compiler whine and complain :)
02:16:56 <angerman> jle`: you mean it's not valid for lists with less then 2 elements?
02:17:16 <bitemyapp> identity: the typeclass constraint propagated to the function returning the parametric type dispatched data without any assistance from me.
02:17:33 <bitemyapp> identity: kicker, the inner parametric type is has a generic instance
02:17:41 <jle`> angerman: it means that some inputs will cause it to fail at runtime
02:17:48 <jle`> angerman: which defeats all compiler guaruntees
02:17:52 <bitemyapp> so I'm mixing a parametric outer type with a type that has a generically derived instance
02:17:55 <bitemyapp> fun fun fun
02:18:11 <identity> but in the end, it wasn't the right way of doing things. Similar to your example, I had something like data Foo a = Foo { something :: Something, custom :: a }. However, the 'something' indicated an error if the request was bad -- i.e. if 'something' actually had any content, then parsing 'custom' would fail because it didn't contain anything.
02:18:18 <jle`> angerman: it's the opposite of 'total'; it is defined for all inputs
02:18:20 <angerman> jle`: ok. so partial means that there is no implementation for [] and [x] in this case?
02:18:24 <jle`> angerman: yeah
02:18:30 <identity> (I was trying to write a haskell wrapper for the reddit API)
02:19:45 <bitemyapp> angerman: a total function has an answer for every input.
02:19:47 <jle`> if you -Wall i think it'll tell you what cases it will fail on
02:19:47 <jle`> or maybe only ocaml does that
02:19:55 <bitemyapp> identity: what did you end up doing?
02:19:56 <athan> @src foldl
02:19:56 <lambdabot> foldl f z []     = z
02:19:56 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
02:19:56 <bitemyapp> identity: that sounds like you need a Maybe wrapped around custom.
02:19:56 <bitemyapp> custom :: Maybe a
02:19:56 <angerman> so, how would one idomatically deal with a function for which the input makes no real sense? what would one return?
02:20:06 <bitemyapp> angerman: throw an exception, return Nothing because you're -> Maybe a, curse god and die.
02:20:07 <identity> bitemyapp: yeah, something like that. I didn't really go anywhere with it. Kind of got busy and forgot about it
02:20:09 <athan> @src foldr
02:20:09 <lambdabot> foldr f z []     = z
02:20:09 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
02:20:13 <bitemyapp> the last option I like to call the Job Special.
02:20:22 <bitemyapp> identity: I guess my point is, I think I'm at the right solution.
02:20:34 <jle`> angerman: in pure code, you would wrap it in Maybe
02:20:44 <angerman> jle`: ok, thanks :)
02:20:47 <jle`> there are cases where it is semantically desirable to throw an error
02:20:53 <jle`> and there are cases where you throw an error because of performance reasons
02:20:55 <athan> does haskell always evaluate rightwards?
02:21:05 <athan> when constructing thunks
02:21:06 <jle`> athan: maybe 'inside out' is a better word
02:21:08 <jle`> oh
02:21:10 <identity> angerman: In most cases, the type system would take care of that for you, in a way. If the input 'makes no sense' at all, then it is most likely of the wrong type
02:21:19 <identity> depending on what you're doing, of course
02:21:25 <athan> jle`: Awesome, thanks :)
02:21:41 <jle`> athan: i was talking about evaluating expressions, but i'm not totally sure about thunks
02:21:55 <bitemyapp> mixing a parametric inner type with an outer type with conduit (monadIO, failure, monadbaseControl, MonadIO) produces some ugly type signatures.
02:21:57 <athan> jle`: I think we're both on the same page
02:22:05 <jle`> angerman: in pure code, you should usually use a Maybe.  that way, whoever is calling will have to explicitly handle the possibility of an error
02:22:08 <angerman> identity: this: [a] -> a -> [a]; replaceSnd (x:_:xs) e = x:e:xs
02:22:15 <athan> jle`: It's weird, I was just imagining encapsulation as sequence the other day
02:22:16 <jle`> but like identity said, partial functions are rarer in haskell than in other languages
02:22:34 <athan> jle`: came up with a weird idea for multidimentional shapes
02:22:38 <jle`> angerman: that would be pretty easy to make total
02:22:42 <athan> both 2d and 3d at the same dime o.O
02:22:50 <bitemyapp> jle`: because we DO NOT accept failure!
02:22:50 <jle`> just have [] and [x] return the same list
02:22:51 <athan> time*
02:23:11 <bitemyapp> *cough Monad fail cough*
02:23:12 <angerman> jle`: yes. that's true. But if replaceSnd should fail, if there is no second :)
02:23:15 <pharaun> have we given up on improving records?
02:23:28 <jle`> angerman: if you insist :)
02:23:31 <bitemyapp> pharaun: have we?
02:23:35 <bitemyapp> pharaun: seen Vinyl?
02:23:42 <jle`> pharaun: there's that overloaded records thing that's going to go into ghc soon i think
02:23:47 <bitemyapp> pharaun: have fun: http://hackage.haskell.org/package/vinyl
02:24:05 <bitemyapp> pharaun: https://ghc.haskell.org/trac/ghc/wiki/Records/OverloadedRecordFields/Design
02:24:08 <identity> angerman: Perhaps the sane thing to do would be to simply return the input if it contains no second element
02:24:19 <identity> e.g. replaceSnd [x] _ = [x]
02:24:30 <jle`> angerman: remember that haskell's type system is amazing in that if you play by the rules, the compiler can guaruntee for you that there are no runtime errors.
02:24:37 <jle`> isn't that cray
02:24:42 <jle`> why would you want to throw that all away?
02:24:44 <pharaun> bitemyapp: oh sweet, i was digging around to see if there was work on it or not, i recall reading up on it a while ago but wasn't for sure if there was anything since
02:25:01 <jle`> i guess you could wrap it into a Maybe and do the unwrapping and handle the error
02:25:02 <angerman> jle`: true.. I need to get used to it, I assume :)
02:25:10 <jle`> angerman: it's something you learn to love :)
02:25:59 <identity> once you go strict static typing, you never go back
02:26:13 <bitemyapp> identity: er, with Haskell sure. Plenty of terrible languages that are statically typed though.
02:26:16 <jle`> i don't even know how i used to refactor
02:26:25 <jle`> in haskell i can confidently refactor a part of the code
02:26:26 <bitemyapp> jle`: me either. And I do Python and Clojure for a living.
02:26:29 <identity> yes, yes
02:26:35 <jle`> and ghc will guaruntee that the rest of the code will work without error
02:26:39 <pharaun> bitemyapp: and yeah i haven't seen vinyl, this seems cool i'll be digging into this
02:26:43 <pharaun> thanks
02:26:44 <bitemyapp> pharaun: <3
02:26:52 <bitemyapp> 0425, still hacking.
02:26:53 <jle`> and tell me exactly what to change to get rid of all possibilities of errors/changing
02:26:58 <jle`> it's invaluable in a larger codebase
02:26:59 <identity> I just remember staring at my terminal and my brain going 'wat' when I ran a python program that gave me a runtime type error halfway through the code
02:27:03 <bitemyapp> jle`: critical.
02:27:17 <bitemyapp> identity: "lets mutate a database and *then* tell you you fucked up"
02:27:31 <jle`> the dynamic solution is..."that's what unit tests are fo"
02:27:32 <MP2E> I'm a week and a half into haskell and frankly, I'm wondering how I ever did anything with side effects omnipresent
02:27:40 <MP2E> :<
02:27:45 <MP2E> seems silly in retrospect
02:27:54 <bitemyapp> jle`: the dynamic solution is: "we're smashing bricks together because we're fricking idiots"
02:27:57 <identity> bitemyapp: Let's launch the missiles and crash before we show you the prompt where you can cancel the launch
02:27:57 <jle`> haha
02:28:14 <jle`> haskell has as much side effects as any imperative language; it's just they are all explicit.
02:28:18 <identity> though you probably shouldn't be doing such preemptive stuff
02:28:37 <pharaun> running python in production scares the bejesus out of me
02:28:40 <MP2E> I'm getting into IO and Monads now :P
02:28:42 <pharaun> sadly i do this all the time
02:28:46 <jle`> MP2E: congrats :D
02:29:01 <bitemyapp> pharaun: you're telling me. I have tons of Python in production. I just assume all of it is disposable/buggy at all times and then I'm never disappointed.
02:29:11 <MP2E> Hahaha
02:29:22 <bitemyapp> thinking about writing a post about this Aeson parametric record thingy.
02:29:31 <bitemyapp> Explaining how to do it and how nice it can be.
02:29:43 <bitemyapp> maybe not a good idea at 0427 tho?
02:29:49 <jle`> nah
02:29:51 <jle`> go 4 it
02:29:53 <pharaun> bitemyapp: haha :) and then people want me to be on call for it and i'm like uuuuh >.> don'twant
02:30:04 <bitemyapp> pharaun: "i'll be on call if I can use the language I want"
02:30:10 <pharaun> indeed
02:30:11 <jle`> s/in production//
02:30:17 <pharaun> oh well
02:30:20 <bitemyapp> jle`: I work for a genetics company.
02:30:23 <bitemyapp> jle`: PONDER THAT
02:30:26 <bitemyapp> ;_;
02:30:28 <pharaun> i do what i can but its a goddamn pain at times
02:30:33 <jle`> and they use python ... ?
02:30:34 <jle`> :|
02:30:35 <bitemyapp> I do my best too, it's just...ugh.
02:30:40 <bitemyapp> jle`: python is popular with bio people
02:30:43 <pharaun> ^
02:30:47 <pharaun> scipy/numpy, etc
02:30:50 <jle`> yeah, in sci in general
02:30:56 <bitemyapp> jle`: especially bio people whose job is like, 85% code and 15% bio, but BOOHOO KEEP ME AWAY FROM LEARNING CODE
02:30:58 <jle`> good thing us physicists haven't succumbed yet
02:30:59 <pharaun> its what attracted me to python in the first place amusingly enough
02:31:01 <bitemyapp> even though it's most of their job.
02:31:05 <jle`> we still use noble fortran
02:31:08 <bitemyapp> but nah, lets pretend the code is beneath us
02:31:10 <pharaun> then i ran into haskell afterward and was like nooo
02:31:17 <bitemyapp> as if that isn't somehow insulting to the pure software people (me)
02:31:23 <pharaun> >_<
02:32:07 <bitemyapp> jle`: "noble Fortran"
02:32:09 <bitemyapp> "noble"
02:32:27 <pharaun> haha
02:32:36 <pharaun> you know lots of the blas/etc stuff are still using fortran :p
02:33:10 <bitemyapp> jle`: you know C and C++ have had -fstrict-aliasing for ages right?
02:33:19 <jle`> yes but it'll never replace fortran in my heart
02:33:25 <bitemyapp> there's no reason to do matrix/vector stuff in Fortran anymore
02:33:29 <bitemyapp> no...reason...
02:33:31 <jle`> um yes there is
02:33:32 <pharaun> it could be worse, it could be cobol
02:33:33 <jle`> because
02:33:35 <jle`> fortran
02:33:39 <bitemyapp> oh right, I forgot.
02:33:51 <jle`> fortran lends itself better to imperative code than C does i think
02:33:53 <bitemyapp> Fortran matches all pattern checks. Unifies all types. Satisfies all typeclass constraints.
02:34:00 <bitemyapp> jle`: haha, what?
02:34:00 <jle`> C doesn't really lends itself to anything
02:34:02 <jle`> oh snap.
02:34:04 <bitemyapp> LOL
02:34:04 <jle`> i went there.
02:34:18 <bitemyapp> jle`: you leave my typedef'd function pointers alone dammit.
02:34:30 <jle`> do you really typedef function pointers
02:34:34 <bitemyapp> (yes)
02:34:35 <jle`> that's a neat idea
02:34:39 <bitemyapp> (yes it is)
02:34:43 <pharaun> very
02:34:52 <jle`> #haskell goes trhough a language bashing phasae at 4 am every day
02:34:59 <bitemyapp> how the hell else do you do finite state automata in C?
02:35:09 <bitemyapp> seriously, how.
02:35:10 <pharaun> bitemyapp: five-star pointer
02:35:18 <identity> jle`: it's not 4 am in europe, you insensitive clod
02:35:19 <bitemyapp> pharaun: oh_god_why.jpg
02:35:27 <jle`> i always wrote out the types explicitly ._.
02:35:42 <bitemyapp> pharaun: cpp macro for generating the number of pointers deep required to traverse the DFA graph
02:35:58 <bitemyapp> *****************void
02:36:00 <pharaun> bitemyapp: heard stories, but thankfully i have not ran over such beast, the worst i've seen to date is four star
02:36:04 <bitemyapp> also known as, "fuck it"
02:36:04 <jle`> identity: it goes through one at 4 am for every time zone
02:36:14 <pharaun> bitemyapp: sounds like a great idea
02:36:19 <identity> jle`: so every single hour?
02:36:20 <pharaun> (not really)
02:36:25 <bitemyapp> void* eats all our sins (and soul)
02:36:25 <jle`> yea more or less
02:36:36 <identity> Perhaps. It's the burden of being so obviously superior
02:36:44 <jle`> how do we bear such a burden.
02:36:48 <jle`> tis a curse.
02:36:51 <bitemyapp> by writing more Haskell
02:36:59 <bitemyapp> and replacing the libraries we use at work so our work stuff can be less lame.
02:37:04 <identity> I get to take a 'programming languages' class next semester. They replaced haskell with scala
02:37:07 <identity> i wept
02:37:13 <bitemyapp> identity: tears of blood
02:37:17 <pharaun> one thing i found interesting
02:37:30 <jle`> i can't tell if those quotes are sarcasm quotes or just normal quotes for the course name
02:37:32 <pharaun> apparently quite a few coworker strongly disliked haskell because they had to take one plc course with haskell
02:37:35 <pharaun> and i was :(
02:37:43 <identity> jle`: both
02:37:43 <bitemyapp> jle`: I assume limeys are always sarcastic.
02:37:48 <bitemyapp> jle`: I'm never disappointed.
02:37:49 <pharaun> then again all we hire are newgrads
02:37:58 <pharaun> who have never maint legacy 2mloc codebase
02:38:21 <bitemyapp> data (Sarcastic a) => Brit a = ...
02:38:33 <identity> I already have a reputation as a wizard in my school because I use vim and write haskell
02:38:34 <pharaun> then the next day i find out that one of them have implemented a shinny new rpc inside the codebase and i'm like no... why!
02:38:43 <identity> one of two people that write haskell in my comp sci department, afaik
02:38:49 <pharaun> wow
02:38:54 <prophile> identity: do you know scala?
02:38:56 * hackagebot gtk2hs-hello 1.0.0.0 - Gtk2Hs Hello World, an example package  http://hackage.haskell.org/package/gtk2hs-hello-1.0.0.0 (HamishMackenzie)
02:38:58 <identity> prophile: no
02:39:04 <pharaun> identity: kidna jealous, wish i knew haskell back in univ :)
02:39:15 <prophile> then sounds like you got lucky
02:39:25 <prophile> a course teaching you something you already know is just burning money on your part :)
02:39:34 <pharaun> hah that's one way to look at it
02:39:44 <identity> prophile: yeah, I look at it that way as well. I don't mind trying it out. I would be more interested in trying clojure, however
02:40:00 <bitemyapp> prophile: what's paying money to learn Scala then? Donating the money to the local Neo-Nazi chapter?
02:40:13 <identity> bitemyapp: free education
02:40:16 <jle`> if you learn scala good enough you can join Tekmo at twitter
02:40:19 <identity> no, not even free
02:40:24 <identity> I get *paid* to study
02:40:25 <pharaun> clojure is interesting but i still feel like i prefer haskell by far :)
02:40:29 <identity> by my government.
02:40:34 <pharaun> identity: paid? how did you manage to achieve that feat?
02:40:36 <bitemyapp> pharaun: I've done a lot of Clojure, stick with the Haskell.
02:40:48 <bitemyapp> identity: damn you die. I had to drop out my first semester because I'm a US'ian and had no money at the time.
02:40:54 <no-n> @src ap
02:40:54 <lambdabot> ap = liftM2 id
02:40:56 <bitemyapp> never did end up getting a degree.
02:40:57 <identity> pharaun: by moving to denmark
02:40:58 <prophile> judging by the phrase "my government" I'm assuming identity is actually the king
02:41:07 <pharaun> identity: that explains lots :)
02:41:08 <bitemyapp> no-n: not what I would've guessed, but I'm impressed anyway.
02:41:28 <identity> prophile: I prefer the term 'High Wizard'
02:41:37 <bitemyapp> :t ap
02:41:38 <lambdabot> Monad m => m (a -> b) -> m a -> m b
02:41:47 <no-n> > let ap = liftM2 ($) in Just (*) `ap` Just 2 `ap` Just 10
02:41:48 <lambdabot>  Just 20
02:41:50 <jle`> liftM2 id is such a cop out definition gosh
02:41:57 <no-n> > let ap = liftM2 id in Just (*) `ap` Just 2 `ap` Just 10
02:41:58 <lambdabot>  Just 20
02:42:22 <prophile> ($) is id with a slightly more restrictive type signature
02:42:32 <no-n> :t ($)
02:42:32 <lambdabot> (a -> b) -> a -> b
02:42:35 <jle`> :t return (*) `ap` return 2 `ap` return 10 :: Maybe Int
02:42:35 <lambdabot> Maybe Int
02:42:38 <no-n> ah, that's right
02:42:42 <jle`> > return (*) `ap` return 2 `ap` return 10 :: Maybe Int
02:42:43 <lambdabot>  Just 20
02:42:45 <jle`> > return (*) `ap` return 2 `ap` return 10 :: [Int]
02:42:46 <lambdabot>  [20]
02:42:58 <no-n> yeah, I know how return works :P
02:43:18 <no-n> jle` why is it a copout
02:43:52 <jle`> i would have expected
02:44:08 <jle`> ap f x = do { f' <- f; x' <- x; return (f' x') }
02:44:32 <jle`> that is a definition that is not afraid to bear it all
02:44:38 <no-n> heh
02:44:50 <jle`> huh.
02:44:51 <no-n> :t (<*>)
02:44:52 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
02:44:54 <prophile> do-notation? what a cop-out
02:44:56 <no-n> oop
02:45:04 <no-n> @src (<*>)
02:45:04 <lambdabot> Source not found. Do you think like you type?
02:45:06 <angerman> how do I build a padded string?
02:45:10 <jle`> ($) :: (a -> b) -> (a -> b)
02:45:13 <no-n> lambdabot ;-;
02:45:15 <jle`> prophile: you are right :O
02:45:20 <angerman> 108 -> "000000000108" (length 9)
02:45:21 <no-n> why do you hate me lambdabot
02:45:28 <prophile> no-n: there will be a different implementation for each Applicative
02:45:28 <jle`> no-n: well...it's a part of the typeclass :P
02:45:34 <no-n> oh yes
02:45:41 <jle`> ($) f = f
02:45:46 <jle`> that's neat
02:45:55 <no-n> jle` yes
02:46:02 <no-n> very
02:46:08 <jle`> wait then why can't we just use id
02:46:11 <jle`> whenever we would use ($)
02:46:20 <prophile> you could
02:46:22 <johannesbodannes> mmmmm... i'm in the process of considering a linux installation to make life simpler during development, but i'm not completely sure what to install. haskell is a big priority, is ghc still rubbish and outdated on ubuntu?
02:46:22 <jle`> the prefix version of ($), that is
02:46:26 <jle`> not the operator version
02:46:28 <no-n> > (*10) `id` 5
02:46:30 <lambdabot>  50
02:46:33 <prophile> the only difference is the type
02:46:46 <peteretep> johannesbodannes: In a VM, or are you also going to try and use it as a desktop?
02:46:47 <prophile> ($) requires its lhs to be of the form (a -> b)
02:47:00 <prophile> so there might be type inference ramifications for switching it for id
02:47:07 <johannesbodannes> as a desktop OS. not much interested in a VM, I'm not sure that my computer is up for it
02:47:24 <jle`> > zipWith id [(*2),(+2),(/3)] [6..]
02:47:25 <lambdabot>  [12.0,9.0,2.6666666666666665]
02:47:27 <jle`> :O
02:47:39 <johannesbodannes> otherwise i'd happily just use Arch Linux
02:47:50 <johannesbodannes> which I've had lots of success with as a server OS
02:47:52 <peteretep> johannesbodannes: Even my old-ass MBA runs a VM just fine. I've had consistently poor experiences mixing up my desktop machine with my dev machine
02:47:52 <prophile> zipWith id is just <*> for the ziplist applicative, no?
02:48:00 <jle`> prophile: yeah, but the boilerplate is annoying
02:48:01 <prophile> :t zipWith id
02:48:02 <lambdabot> [b -> c] -> [b] -> [c]
02:48:02 <identity> johannesbodannes: the package is possibly outdated, I'm not sure
02:48:16 <identity> johannesbodannes: but I've been using ubuntu for a good while and i just build the haskell platform
02:48:21 <identity> it's rather simple
02:48:39 <johannesbodannes> oh, so you didn't face any major problems building the haskell platform yourself?
02:48:43 <identity> not at all
02:48:52 <no-n> jle` wait what
02:49:05 <bitemyapp> I use GHC natively on Mac OS X quite happily.
02:49:11 <johannesbodannes> did you just install the ubuntu package first and build using the canonical GHC binary?
02:49:12 <bitemyapp> GHC 7.6.3 + Cabal 1.18
02:49:19 <jle`> no-n: ?
02:49:26 <peteretep> johannesbodannes: What OS is on your parent machine?
02:49:26 <no-n> your zipWith
02:49:28 <Walther> hm, are there anybspecific reasons to install the haskell platform instead of installing packages like ghc and cabal from the repos?
02:49:32 <identity> johannesbodannes: nope. You download a ghc binary and use it to build
02:49:33 <identity> iirc
02:49:37 <peteretep> Walther: You want a newer version
02:49:51 <pharaun> Hmm i wonder if i should try out nixos
02:49:51 <johannesbodannes> well, currently I'm running windows 7 x64, can't recall which one
02:50:06 <Walther> Hmm. Pretty sure debian testing repos are quite close to the newest
02:50:20 <identity> johannesbodannes: www.haskell.org/platform/linux.html -- "Build from source"
02:50:27 <pharaun> could be nice for cleaning up my desktop a bit, i should do more stuff in virtual machines
02:50:34 <peteretep> do people still use gentoo?
02:50:38 <pharaun> i do
02:50:39 <johannesbodannes> ah thanks, identity
02:50:41 <Walther> Virtual machines are great.
02:50:42 <pharaun> my desktop is gentoo.
02:50:51 <pharaun> everything else is debian, fedora, or ubuntu
02:51:09 <pharaun> tho i do have a solaris box now -_- i should try to see if i can get ghc to run on that
02:51:29 <peteretep> I have found a Mac + VMs to be my dev environment zen
02:51:29 <Walther> hehe
02:51:40 <pharaun> Walther: yeah but often time i just find the switching in and out of a vm to be a bit of a pain
02:51:46 <bitemyapp> I don't like VMs either.
02:52:01 <pharaun> but i've recently gotten KVM up and running so i may try it as an ssh-target and see how that works out
02:52:03 <Walther> pharaun: it's better than dualbooting though imho
02:52:06 <peteretep> I should spend more time with docker
02:52:20 <peteretep> pharaun: What switching in and out?
02:52:26 <pharaun> Walther: it is, tho i've found having hibernate on my linux side helps
02:52:29 <Walther> Oh yes, kvm and ssh-ing in is nice, have that at work
02:52:31 <pharaun> peteretep: oh i'm used to vmware :)
02:52:33 <peteretep> pharaun: I SSH in to the VM, and have my code folder on the host, mounted
02:52:56 <pharaun> peteretep: but yeah i should just do that >_<
02:53:33 <pharaun> guess i should look into building a devel vm sooner or later so i can test that kind of workflow out, could be nice to clean up my desktop a bit
02:53:46 <peteretep> pharaun: I'd consider going straight for docker
02:53:56 <peteretep> pharaun: Will take you about the same amount of time, but it's also a hip new skill
02:54:03 <pharaun> peteretep: work has been experimenting with docker
02:54:05 * bitemyapp grumbles about Golang users
02:54:07 <pharaun> haven't ran it here yet
02:54:27 <peteretep> Some of my devs are experimenting with it, but the devops team have pretty much said no
02:54:29 <pharaun> i wonder if it works with kvm or only the lxc/cgroup stuff
02:54:32 <pharaun> peteretep: aw :(
02:54:34 <asymptote> :q
02:54:36 <pharaun> peteretep: our devops said yes
02:55:04 <peteretep> We put almost everything straight in to AWS these days
02:55:38 <pharaun> peteretep: probably won't hurt to learn me some docker n' stuff
02:55:54 <pharaun> gotta keep up with the rat race
02:56:07 <pharaun> tho it seems like it would be nice at work
02:56:13 <Walther> i'm very interested in the concept of docker, but have close to no idea if the implementation is actually stable enough
02:56:18 <pharaun> no more having to deal with ollld lts ubuntu
02:56:26 <peteretep> Walther: I was under the impression etsy had it in production
02:56:27 <bitemyapp> peteretep: why'd they say no?
02:56:30 <pharaun> Walther: iirc they're aiming for "prod ready" in 1.0
02:56:37 <pharaun> but there's shops using it in prod now
02:56:46 <peteretep> bitemyapp: Benefits seemed marginal compared to potential hassle
02:56:52 <Walther> Mmh, but "production ready" doesn't really mean much
02:56:54 <pharaun> peteretep: how so?
02:56:58 <pharaun> Walther: indeed
02:57:25 <peteretep> Benefits column: you could have a big VM with lots of services, rather than lots of little VMs
02:57:28 <no-n> > let ($) f = f in id $ 5
02:57:29 <lambdabot>  5
02:57:37 <peteretep> hassle column: it's a new system to be learned, supported, etc
02:57:41 <Walther> Indeed, no extra overhead from OSes
02:57:42 <pharaun> peteretep: our shops had no/minimal vms
02:57:52 <pharaun> so having docker was a step up for em
02:58:04 <Walther> pharaun: also: relatively new project, so ugly side effects can appear
02:58:09 <pharaun> Walther: that too
02:58:14 <bitemyapp> peteretep: I was under the impression the isolation/containerization with Docker was a little leaky anyway
02:58:21 <no-n> > let ($) = id in (*10) $ (*10) $ 5
02:58:22 <lambdabot>  No instance for (GHC.Show.Show a0)
02:58:22 <lambdabot>    arising from a use of `M626782979322764244718628.show_M6267829793227642447...
02:58:22 <lambdabot>  The type variable `a0' is ambiguous
02:58:22 <lambdabot>  Possible fix: add a type signature that fixes these type variable(s)
02:58:22 <lambdabot>  Note: there are several potential instances:
02:58:23 <peteretep> About 1/3 of our current estate is in AWS
02:58:28 <pharaun> we're not letting it any where near prod anytime soon but they're considering, testing, etc
02:58:31 <bitemyapp> peteretep: such that it's ideal use-case (SAAS isolation) is something it's not really up to snuff for.
02:58:31 <peteretep> We are moving a datacenter in the next quarter
02:58:36 <peteretep> and probably the final data center after that
02:58:38 <bitemyapp> peteretep: that's the main objection I'd personally have.
02:58:40 <pharaun> Walther: its crazy to dive face-first into new stuff like that
02:58:46 <no-n> hmn
02:58:55 <Walther> but yeah, i should definitely test out docker more, considering i *am* a jr sysadmin :p
02:59:00 <pharaun> hehe
02:59:12 <pharaun> i'm one of those software devs that you sysadmin love to hate ;p
02:59:12 <peteretep> hahah, yes
02:59:20 <Walther> also aws, have only been in touch with free tier instances
02:59:29 <pharaun> i don't mind aws
02:59:34 <Walther> Bleh, i don't hate people <3
02:59:36 <pharaun> prefer linodes more
02:59:40 <skypers> @hoogle Either a b -> Bool
02:59:41 <lambdabot> Data.Graph.Inductive.Basic hasLoop :: Graph gr => gr a b -> Bool
02:59:41 <lambdabot> Data.Graph.Inductive.Query.DFS isConnected :: Graph gr => gr a b -> Bool
02:59:41 <lambdabot> Data.Graph.Inductive.Graph isEmpty :: Graph gr => gr a b -> Bool
02:59:47 <skypers> weird
02:59:53 <no-n> > let ($) = id in (*10) $ ((*10) $ 5)
02:59:54 <lambdabot>  500
02:59:55 <peteretep> skypers: What are you expecting there?
03:00:25 <Walther> Oh well whatever, linode, aws, heroku, rackspace, upcloud, etc, essentially same kind of stuff that you need to know and do at the sysadmin end of things
03:00:26 <skypers> @let isLeft :: Either a b -> Bool; isLeft (Left _) = True; isLeft _ = False
03:00:27 <lambdabot>  Defined.
03:00:34 <skypers> > isLeft (Right "hi")
03:00:35 <lambdabot>  False
03:00:41 <skypers> > isLeft (Left 42)
03:00:43 <lambdabot>  True
03:00:48 <skypers> it’s curious it’s not in Data.Either
03:00:49 <pharaun> Walther: i'm familiar enough with solaris zones (been using it here) and vmware *shrugs*
03:00:53 <Walther> and i should get more than just my feet wet with those
03:00:58 <pharaun> should at least learn up a bit on docker for work at least
03:01:04 <skypers> Data.Maybe has that
03:01:06 <skypers> :t isJust
03:01:07 <lambdabot> Maybe a -> Bool
03:01:08 <pharaun> even if its not the perfect-est solution i guess
03:01:11 <skypers> :t isNothing
03:01:11 <lambdabot> Maybe a -> Bool
03:01:15 <no-n> > fmap isLeft (Right $ Left ">_>")
03:01:17 <lambdabot>  Right True
03:01:23 <pharaun> actually
03:01:28 <Walther> pharaun: most experience i have is with virtualization hosts running kvm, and centrally managing woth puppet
03:01:35 <pharaun> i should spin up a new zone and see how ghc/haskell works out in solaris
03:01:55 <bitemyapp> my main experience with Puppet is that it's the thing being used as an excuse to cock-block my scripts from running `sudo apt-get install`
03:02:07 <peteretep> skypers: When would you use that other than pattern matching?
03:02:08 <skypers> :t hush
03:02:08 <lambdabot> Not in scope: `hush'
03:02:12 <pharaun> Walther: most of mine are small scale few machine kind of setup for personal stuff, so i'm not doing much over scale there :)
03:02:13 <bitemyapp> which, given my scripts install packages idempotently, has led to a largely negative impression of Puppet.
03:02:20 <skypers> peteretep: just like with isJust
03:02:21 <Walther> definitely wouldn't mind expanding my skillset, hence looking around pulling strings for a potential new job :)
03:02:24 <skypers> in a MonadZero
03:02:27 <Walther> pharaun: nof
03:02:29 <Walther> nod*
03:02:29 <skypers> for instance
03:02:39 <peteretep> conceptually Maybe feels different to me
03:02:44 <peteretep> aybe I am imagining it
03:02:46 <skypers> unless (isLeft a) $ {- do something with no error -}
03:02:53 <skypers> when you don’t need the error
03:03:00 <peteretep> With an Either you want to handle both sides, with Maybe you would just short-circuit
03:03:06 <peteretep> If you don't need the error, use Maybe :)
03:03:17 <skypers> what if the lib forces you the Either? :)
03:03:23 <peteretep> fair enough
03:03:29 <skypers> but hm
03:03:35 <skypers> I’m pretty sure errors fixes that
03:03:42 <skypers> with hush, note, and so on
03:03:46 <prophile> Maybe = Either ()
03:03:51 <prophile> there's no real conceptual difference between the two
03:04:02 <bitemyapp> decodeEither ftw
03:04:07 <skypers> http://hackage.haskell.org/package/errors-1.2.1/docs/Control-Error-Util.html
03:04:10 <no-n> :t decodeEither
03:04:11 <skypers> it’s hush :)
03:04:11 <lambdabot> Not in scope: `decodeEither'
03:04:14 <bitemyapp> no-n: Aeson
03:04:20 <no-n> who what
03:04:27 <bitemyapp> no-n: decodeEither is from Aeson.
03:04:31 <no-n> ahh
03:04:36 <peteretep> prophile: One carries two pieces of data, one carries one piece
03:04:39 <skypers> @hoogle decodeEither
03:04:39 <lambdabot> No results found
03:04:55 <bitemyapp> :m + Data.Aeson
03:05:20 <bitemyapp> peteretep: well, technically Maybe carries two possible outcomes, same as Either
03:05:23 <no-n> > let infixr 0 $; ($) = id in (*10) $ (*10) $ 5
03:05:24 <lambdabot>  500
03:05:32 <bitemyapp> it's just that Either's "other" case isn't a nullary constructor
03:05:38 <bitemyapp> and can convey variable information
03:05:45 <bitemyapp> usually...a String.
03:05:52 <bitemyapp> sometimes [String] if you're super-duper cool.
03:05:54 <skypers> I don’t like that assumption
03:05:58 <bitemyapp> [T.Text] if you're 1337
03:06:00 <skypers> I never used Either with a String
03:06:13 <bitemyapp> skypers: ssshhh...everything is a text log.
03:06:20 <skypers> not at all :)
03:06:24 <bitemyapp> yis.
03:06:37 <peteretep> bitemyapp: Maybe carries a countably infinite set, the set for Either is twice that
03:06:38 <skypers> my log is a plain type I can log through stdout, or send to a database
03:06:47 <skypers> sending a String would be stupid
03:06:52 <no-n> why is there no Data.ByteString.Lazy.hGetLine
03:07:11 <bitemyapp> skypers: yis
03:07:22 <prophile> someone killed it by saying "I don't believe in hGetLine"
03:07:34 <no-n> :o
03:07:45 <bitemyapp> no-n: http://hackage.haskell.org/package/bytestring-0.10.4.0/docs/Data-ByteString.html ?
03:07:47 <peteretep> bitemyapp: The set of possible Either values is twice as big as the set of Maybe values
03:07:51 <bitemyapp> no-n: hGetLine :: Handle -> IO ByteString
03:08:04 <bitemyapp> peteretep: true, I was being a PITA>
03:08:07 <no-n> bitemyapp: that's strict
03:08:08 <peteretep> :)
03:08:11 <bitemyapp> ohhhhhhh
03:08:12 <bitemyapp> lazy
03:08:21 <bitemyapp> phew. 0506 is not doing me any favors.
03:08:44 <no-n> :p
03:08:56 <bitemyapp> no-n: really, you want lazy bytestring IO?
03:09:06 <no-n> uhh
03:09:07 <no-n> idk :/
03:09:16 <shouya> @pl \x -> f . (g x)
03:09:16 <lambdabot> (f .) . g
03:09:29 <no-n> would strict byte string IO be "safer"?
03:09:33 <no-n> memory safer I mean
03:10:09 <bitemyapp> no-n: I avoid lazy IO just as a general rule, but for hGetLine that would be really weird.
03:10:22 <no-n> why?
03:10:39 <bitemyapp> it wouldn't actually be lazy?
03:10:51 <no-n> hmm true
03:11:01 <prophile> unsafeInterleaveIO . hGetLine
03:11:11 <no-n> yes now it makes sense
03:11:14 <bitemyapp> prophile: real cute.
03:11:24 <no-n> hehe
03:11:27 <shouya> @pl \f (Just x) -> f x
03:11:28 <lambdabot> (line 1, column 10):
03:11:28 <lambdabot> unexpected "x"
03:11:28 <lambdabot> expecting operator or ")"
03:11:35 <bitemyapp> no-n: that exchange made me feel like I might actually be getting to understand this stuff.
03:12:01 <bitemyapp> shouya: fromJust $ fmap f
03:12:06 <bitemyapp> shouya: or just `fmap f`
03:12:24 <shouya> got that! thanks bitmyapp!
03:12:54 <bitemyapp> shouya: try to avoid partial functions like that lambda please :)
03:13:07 <no-n> yeah. I don't completely understand the implications of laziness in all situations myself.
03:13:25 <bitemyapp> no-n: I definitely can't say that about myself, but I'm chuffed for being able to get why it didn't make sense in that case.
03:13:42 <bitemyapp> I mean...you could technically do it, but it would be hella strange.
03:13:42 <no-n> :)
03:13:51 <no-n> yes you're right
03:13:55 <no-n> the bytes are coming anyway
03:16:53 <shouya> bitemyapp: partial functions.. do you mean notions like '(f .)'?
03:17:18 <bitemyapp> shouya: Maybe can be Just a or Nothing, matching Just alone means it's a partial function and will choke on a Nothing.
03:17:46 <bitemyapp> > (\f (Just x) -> f x) (+1) Nothing
03:17:47 <lambdabot>  *Exception: <interactive>:3:2-19: Non-exhaustive patterns in lambda
03:17:52 <bitemyapp> > (\f (Just x) -> f x) (+1) $ Just 1
03:17:53 <lambdabot>  2
03:18:03 <bitemyapp> shouya: exceptions are bad mkay.
03:18:13 <bitemyapp> > fmap (+1) $ Just 1
03:18:14 <lambdabot>  Just 2
03:18:20 <bitemyapp> > fmap (+1) Nothing
03:18:21 <lambdabot>  Nothing
03:18:28 <bitemyapp> shouya: fmap dat data.
03:19:07 <Walther> I've still not quite grasped what fmap is
03:19:31 <bitemyapp> Walther: fmap lifts a function to be able to work on any type that implements the Functor typeclass.
03:19:43 <bitemyapp> Walther: fmap (+1) $ Just 1
03:19:50 <Walther> Ooof. I know some of those words
03:19:57 <bitemyapp> Walther: Maybe has a Functor instance implemented. the Functor instance is just fmap.
03:20:00 <bitemyapp> :t fmap
03:20:01 <lambdabot> Functor f => (a -> b) -> f a -> f b
03:20:03 <bitemyapp> the f is Maybe.
03:20:08 <bitemyapp> the a -> b is (+1)
03:20:19 <bitemyapp> the f b is the Just 2 that comes out the other end
03:20:26 <bitemyapp> the f a is the Just 1 we passed to fmap (+1)
03:20:28 <Walther> Hmm. A simple usecase example?
03:20:33 <bitemyapp> I just gave one.
03:20:39 <bitemyapp> > fmap (+1) (Just 1)
03:20:40 <lambdabot>  Just 2
03:20:46 <bitemyapp> :t (+1)
03:20:47 <lambdabot> Num a => a -> a
03:20:53 <bitemyapp> our increment function knows nothing about Maybe
03:20:54 <bitemyapp> why did it work?
03:21:06 <Walther> Hm.
03:21:13 <bitemyapp> because Maybe's functor instance (fmap) lifted (through the use of fmap) the increment function to work on a higher type.
03:21:18 <Aetherspawn> hi nominolo
03:21:52 <Walther> I have much to learn about Maybes and all the other fancy stuff around, i'm only starting to get comfy with the essentials
03:22:01 <bitemyapp> Walther: fmap, liftA, and liftM are basically all the same thing, but for different typeclasses. They lift functions to be able to work on the types that implement the typeclass.
03:22:11 <bitemyapp> Walther: Maybe is pretty simple. You need to do the NICTA course.
03:22:23 <bitemyapp> Walther: my guide is here: https://gist.github.com/bitemyapp/8739525 link to the NICTA course within.
03:22:34 <bitemyapp> Walther: there is nothing particularly difficult about Maybe, you just need to write it yourself.
03:22:34 <Walther> (similarly no idea on liftA, liftM)
03:22:46 <Walther> Mmh.
03:22:48 <bitemyapp> Walther: liftA is fmap but for Applicative. liftM is fmap but for Monad.
03:22:56 <bitemyapp> Walther: they all (fmap, liftA, liftM) do the same thing
03:22:58 <bitemyapp> :t fmap
03:22:58 <lambdabot> Functor f => (a -> b) -> f a -> f b
03:22:59 <bitemyapp> :t liftA
03:23:00 <lambdabot> Applicative f => (a -> b) -> f a -> f b
03:23:01 <bitemyapp> :t liftM
03:23:01 <lambdabot> Monad m => (a1 -> r) -> m a1 -> m r
03:23:07 <bitemyapp> Walther: look at the symmetry.
03:23:25 <Walther> Nod. Still not quite confident on the concept of what lifting gains us
03:23:28 <no-n> why is it a1 r instead of just a b
03:23:30 <bitemyapp> > map (+1) [0, 1, 2]
03:23:31 <lambdabot>  [1,2,3]
03:23:34 <bitemyapp> > fmap (+1) [0, 1, 2]
03:23:35 <lambdabot>  [1,2,3]
03:23:38 <bitemyapp> > liftM (+1) [0, 1, 2]
03:23:39 <lambdabot>  [1,2,3]
03:23:43 <bitemyapp> Walther: reuse of functions.
03:23:54 <bitemyapp> Walther: without manually contending with one-off type instances
03:24:00 <ion> > liftA (+1) [0, 1, 2]
03:24:01 <lambdabot>  [1,2,3]
03:24:11 <bitemyapp> Walther: as long as the type implements Functor, I can use fmap to map my function over the type.
03:24:25 <bitemyapp> Walther: I don't have to care about the particulars. This is important for abstraction and code reuse.
03:24:36 <bitemyapp> Many many many patterns in Haskell code would be impossible without this kind of abstraction.
03:24:53 <bitemyapp> Walther: you know what map is right?
03:24:55 <Walther> nod, makes it easier to have an ecosystem of code snippets that are reusable
03:24:57 <bitemyapp> I showed it earlier.
03:25:09 <Walther> bitemyapp: Of course, i've used map quitr a bit
03:25:16 <bitemyapp> Walther: what does map do?
03:25:25 <Walther> it maps a function over an argument
03:25:30 <bitemyapp> hum.
03:25:31 <bitemyapp> :t map
03:25:32 <lambdabot> (a -> b) -> [a] -> [b]
03:25:37 <bitemyapp> it maps a function over a list
03:25:38 <Walther> well, a list of things
03:25:42 <bitemyapp> Walther: it lifts a function to being able to work on the List type.
03:25:42 <Walther> yep
03:25:55 <Walther> bitemyapp: Aah, there we go on the terminology side
03:25:57 <bitemyapp> :t map (+1)
03:25:58 <lambdabot> Num b => [b] -> [b]
03:26:08 <no-n> it lifts a function to operate on lists. think (a -> b) -> ([a] -> [b])
03:26:09 <bitemyapp> Walther: look at what happened when we partially applied map.
03:26:11 <angerman> how would I alias [[[String]]] to MyGreatType?
03:26:13 <Walther> thanks, now i finally got what people mean by lifting :p
03:26:19 <Walther> Nod.
03:26:21 <bitemyapp> Walther: Num b => [b] -> [b]
03:26:30 <ion> angerman: Or the other way around? type MyGreatType = [[[String]]]
03:26:31 <bitemyapp> now we have a function that increments the members of lists.
03:26:39 <Walther> yep
03:26:42 <bitemyapp> Walther: but, this is a generally useful concept not specific to lists. or even collections.
03:26:51 <bitemyapp> Walther: this generally useful and abstract concept...is a Functor.
03:27:11 <bitemyapp> Walther: a la the category theory. but it doesn't really matter what mathematician we stole it from, what matters is it's useful and kills boilerplate.
03:27:13 <angerman> ion: sais I need ScopedTypeVariables?
03:27:17 <bitemyapp> and dammit, we kill boilerplate dead.
03:27:23 <Walther> whee, getting more familiar with the higher level terminology. Thanks a lot!
03:27:32 <no-n> lol
03:27:32 <bitemyapp> :t (<*>)
03:27:33 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
03:27:35 <bitemyapp> :t fmap
03:27:36 <lambdabot> Functor f => (a -> b) -> f a -> f b
03:27:41 <bitemyapp> Walther: ^^ what's different?
03:28:50 <Walther> bitemyapp: hmm. there's the f missing, but not sure how that affects as there's already a->b implying a function
03:29:18 <bitemyapp> Walther: okay, lets talk about a specific applicative instance, the list.
03:29:20 <bitemyapp> :t liftA
03:29:21 <lambdabot> Applicative f => (a -> b) -> f a -> f b
03:29:25 <bitemyapp> liftA (+1) [1, 2, 3]
03:29:32 <bitemyapp> > liftA (+1) [1, 2, 3]
03:29:33 <lambdabot>  [2,3,4]
03:29:39 <bitemyapp> but <*> is the real point of applicatives.
03:29:53 <bitemyapp> :t (<*>)
03:29:53 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
03:29:57 <bitemyapp> Walther: okay. With lists, what's f?
03:30:20 <bitemyapp> which is a way of saying, "who implements applicative in this case?"
03:30:48 <Walther> is it the iterator?
03:30:59 <bitemyapp> Walther: don't get fancy. if I'm working with lists, who's f?
03:31:10 <bitemyapp> there is no iterator, I've not said a word about such a concept.
03:31:16 <bitemyapp> Don't use any words I don't use. Keep it simple.
03:31:20 <Walther> :p
03:31:27 <bitemyapp> Walther: when I used fmap, who was f?
03:31:29 <Walther> you're working with a list, you're f
03:31:35 <bitemyapp> Walther: okay, so f is [] right?
03:31:41 <Walther> ^.^
03:31:48 <Walther> Nod.
03:31:50 <bitemyapp> Walther: what does f (a -> b) look like then?
03:31:56 <bitemyapp> what changes about (+1)?
03:32:17 <bitemyapp> Walther: is (+1) a valid f (a -> b) when we're using the list applicative instance?
03:32:35 <bitemyapp> :t pure
03:32:36 <lambdabot> Applicative f => a -> f a
03:32:50 <Walther> uhm, yes - +1 works on single elements but you lift it to the list type
03:33:00 <bitemyapp> Walther: ehhhhh, <*> is asking for something different
03:33:09 <Walther> Hm.
03:33:09 <bitemyapp> it's asking for f (a -> b)
03:33:12 <bitemyapp> not (a -> b)
03:33:19 <bitemyapp> it does lifting, but it wants something upfront first.
03:33:28 <bitemyapp> what does f (a -> b) mean?
03:33:37 <bitemyapp> Walther: do you understand type constructors?
03:33:51 <Walther> A bit.
03:34:09 <bitemyapp> if I have MyType (a -> b), MyType constains a function that takes an 'a' and returns a 'b'
03:34:09 <Walther> eager to learn, and willing to put in effort
03:34:14 <bitemyapp> Walther: we said f was []
03:34:20 <bitemyapp> Walther: which is the constructor for lists.
03:34:25 <Walther> Mmh.
03:34:27 <bitemyapp> Walther: so what's f (a -> b)
03:34:32 <bitemyapp> just type it out.
03:34:37 <bitemyapp> make guesses, get messy, make mistakes.
03:34:42 <Walther> [] (a -> b)
03:34:59 <bitemyapp> okay, and reformatted for hoomans: [(a -> b)]
03:35:07 <bitemyapp> Walther: colloquially, it reads like, "a list of functions"
03:35:08 <Walther> essentially - yeah, that
03:35:23 <bitemyapp> the abstract version is, "type that implements applicative containing a function"
03:35:28 <bitemyapp> OKAY
03:35:34 <bitemyapp> so going back to (+1)
03:35:42 <bitemyapp> now we have [(+1)]
03:36:11 <bitemyapp> > [(+1)] <*> [0, 1, 2]
03:36:12 <lambdabot>  [1,2,3]
03:36:25 <Walther> so you could essentially zip that, yeah
03:36:25 <bitemyapp> > pure (+1) <*> [0, 1, 2]
03:36:26 <lambdabot>  [1,2,3]
03:36:30 <bitemyapp> :t pure
03:36:31 <lambdabot> Applicative f => a -> f a
03:36:45 <bitemyapp> Walther: I didn't have to specify lists. I can be abstract. see the type of pure?
03:36:50 <bitemyapp> :t return
03:36:51 <lambdabot> Monad m => a -> m a
03:36:56 <bitemyapp> same deal. but monads.
03:36:58 <bitemyapp> whatever. simple.
03:37:04 <Walther> Mm.
03:37:08 <bitemyapp> Walther: our semantics changed substantially though.
03:37:16 <bitemyapp> Walther: a list admits the introduction of multiple elements.
03:37:18 <bitemyapp> or no elements.
03:37:35 <Walther> nod
03:37:35 <bitemyapp> Walther: what do you think happens when there are multiple functions in our [(a -> b)] ?
03:37:57 <bitemyapp> Walther: what do you think happens when there are *no* functions in our [(a -> b)] ?
03:38:25 <bitemyapp> Walther: I'm waiting for you to make a guess, then I'll demonstrate :)
03:39:44 <Walther> well, for multiple functions, which ones do you apply - all of them in order, or in a zip-like fashion
03:39:51 <bitemyapp> > [(+1), (*2)] <*> [0, 1, 2]
03:39:52 <lambdabot>  [1,2,3,0,2,4]
03:39:55 <Walther> for none, do younreturn at all (hence a maybe)
03:40:03 <bitemyapp> > [] <*> [0, 1, 2]
03:40:04 <lambdabot>  []
03:40:06 <bitemyapp> no Maybe here.
03:40:10 <Walther> Hmm.
03:40:17 <bitemyapp> there's nowhere for a maybe to pop in
03:40:19 <bitemyapp> :t <*>
03:40:20 <lambdabot> parse error on input `<*>'
03:40:25 <bitemyapp> :t (<*>)
03:40:25 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
03:40:28 <bitemyapp> where's the Maybe?
03:40:34 <bitemyapp> return type has to be f b
03:40:40 <bitemyapp> in this case [Int]
03:40:46 <bitemyapp> [] is a valid [Int]
03:40:48 <Walther> nod
03:40:55 <bitemyapp> Maybe [Int] is not [Int]
03:41:14 <bitemyapp> Walther: the zip thing you mentioned isn't a bad guess, but it's closer to how Arrows work.
03:41:17 <bitemyapp> that's tuple stuff.
03:41:35 <Walther> haven't worked with arrows either :/
03:41:43 <bitemyapp> there's no tuples in f b, you'd have to be generating the tuples yourself (the b)
03:41:49 <bitemyapp> but it's possible.
03:42:11 <bitemyapp> > [(\x -> (x, x+1))] <*> [0, 1, 2]
03:42:12 <lambdabot>  [(0,1),(1,2),(2,3)]
03:42:18 <bitemyapp> Walther: walla. What's b?
03:42:34 <bitemyapp> :t (<*>)
03:42:34 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
03:42:43 <Walther> x+1
03:42:47 <bitemyapp> nope.
03:43:03 <bitemyapp> [] is f, that means everything inside [] is b.
03:43:04 <Walther> well, the function application of that, from the lambda
03:43:12 <bitemyapp> :t (\x -> (x, x+1))
03:43:12 <lambdabot> Num t => t -> (t, t)
03:43:13 <Walther> Hm.
03:43:23 <bitemyapp> (Int, Int) basically.
03:43:35 <Walther> yup
03:43:38 <bitemyapp> the tupling function thing I wrote there
03:44:09 <bitemyapp> it returns (Int, Int), and the function is a -> b, so b is that.
03:44:13 <bitemyapp> a is Int
03:44:17 <Walther> yup
03:44:38 <Walther> sorry, i thought you asked from the tuple side, hence the confusion
03:44:40 <bitemyapp> technically it's Num t => t -> (t, t), which is polymorphic but that's besides the point.
03:44:54 <bitemyapp> Walther: that's why I :t'd the <*> again, to be explicit.
03:44:56 <shou> bitemyapp: i'm suffering from terrible connection. i got what you mean :) thanks
03:45:00 <bitemyapp> bitemyapp: it's all good.
03:45:02 <bitemyapp> er
03:45:07 <bitemyapp> Walther: it's all good.
03:45:11 <myyc> hi, stupid question for any kind flycheck user (surely not flycheck's fault): syntax checks seem to fail wherever there's a preprocessor (#) directive
03:45:13 <bitemyapp> shou: cool. have fun.
03:45:50 <bitemyapp> Walther: try following my gist, let me know what does and doesn't work for you: https://gist.github.com/bitemyapp/8739525
03:45:57 <Walther> (also, again, huge thanks for this detailed explaining, will grab tea later and re-read the log a couple times more)
03:46:03 <Walther> nod, will do
03:46:06 <bitemyapp> I'm going to pass the fuck out now. It's 0544
03:46:17 <bitemyapp> ghastly tired.
03:46:54 <Walther> heh, g'night!
03:47:16 <myyc> i get the same sort of error i would get through ghci
03:47:18 <myyc> Prelude> #if
03:47:19 <myyc> <interactive>:2:2: lexical error at character 'i'
03:47:22 <myyc> stuff like this
03:48:47 <bitemyapp> Walther: g'night and good luck. Please give me feedback on the gist if you use anything from it!
03:50:46 <no-n> @src find
03:50:46 <lambdabot> find p          = listToMaybe . filter p
03:51:06 <no-n> > listToMaybe [1..]
03:51:07 <lambdabot>  Just 1
03:55:14 <no-n> > Just 1 >> guard False >> Just 2
03:55:14 <lambdabot>  Nothing
04:14:04 <identity> I hate how if expressions look in haskell. There's no real way to indent them properly so they look nice
04:14:21 <peteretep> That's on purpose to stop you using them
04:14:56 <identity> Haha. Sometimes there's almost no replacement.
04:16:11 <bitemyapp> identity: are you sure?
04:16:50 <identity> What I'm doing right now is looking up something in a set, and recursing if it's not in the set, or stopping if it is
04:17:08 <identity> I could just use a case expression that would look nicer, but then hlint will bug me
04:17:34 <lyxia> you mean guards ?
04:18:18 <identity> I would use guards, but this is happing inside another case expression
04:19:19 <peteretep> so you have a nested case statement, and it's 'if' that's in trouble for your inelegant layout ;-)
04:20:36 <identity> I'm not sure what you mean. I'm really doing some memoization using a map and a set. I first look it up in the map, and use the contents if they are there(thus the case expression). Then I use a set to determine if the current value computed by the function has already been completed
04:20:43 <identity> s/completed/computed/
04:20:47 <identity> in the current function call
04:22:20 <identity> For various reasons I need both the set and the map
04:25:06 <shouya> @pl \f g -> \x -> f (g x) x
04:25:06 <lambdabot> flip flip id . liftM2
04:28:03 <int-e> ap . flip?
04:29:59 <shouya> int-e: sure. 'ap' is more concise
04:30:46 <int-e> @pl \f g x -> f x (g x)
04:30:46 <lambdabot> ap
04:30:47 <awestroke> identity: case x of looks nicer than if x then foo else bar
04:30:53 <identity> awestroke: yep
04:30:58 <identity> but then hlint tells me to use if
04:31:12 <awestroke> identity: oh? what reason does it give?
04:31:22 <jtcwang> hey guys, need an extra pair of eyes on why pattern matching is failing here
04:31:23 <jtcwang> http://lpaste.net/101976
04:31:26 <identity> there's also MultiWayIf, but i don't like using an extension just for it to look nicer
04:31:35 <identity> awestroke: It just says "use if", basically
04:31:42 <identity> because you're using case on True / False.
04:31:56 <shouya> hi, i am working on the 20 intermediate haskell exercises and now struggled on the implementation of the equivalence of 'Monad (EitherLeft t)'
04:32:18 <shouya> what should be the type signature of 'return'?
04:32:41 <identity> jtcwang: because you eventually process all elements and have only an empty list left.
04:32:59 <jtcwang> rwarr
04:33:05 <jtcwang> ty sir haha
04:33:36 <shouya> EitherLeft is defined as 'type EitherLeft b a = EitherLeft (Either a b)'.
04:33:50 <nooodl> :t return
04:33:51 <lambdabot> Monad m => a -> m a
04:33:57 <nooodl> m is "EitherLeft t"
04:34:07 <nooodl> so return :: a -> EitherLeft t a
04:34:18 <shouya> nooodl: so it should be 'a -> EitherLeft t a' right?
04:34:23 <awestroke> shouya: return x = EitherLeft (Right x)
04:34:29 <awestroke> ?
04:34:49 <shouya> awestroke: hum. but i don't understand,
04:35:00 <shouya> shouldn't 'a' here be an 'Either' value?
04:35:18 <Axman6> awestroke: I believe that's the point of the exercise
04:35:18 <awestroke> shouya: 'a' ?
04:35:20 <nooodl> 'a' is a type
04:35:38 <identity> I'm having a brainfart and can't quite come up with a simple/elegant way to basically do takeWhile "inclusive".. E.g. takeWhile (/= 3) [1,2,3,4] = [1,2,3].. I feel like there's an obvious solution to this
04:35:43 <shouya> awestroke: 'a' for 'a -> EitherLeft t a'
04:35:49 <shouya> awestroke: okay
04:35:52 <identity> oh..
04:36:01 <shouya> awestroke: i think i get the point.
04:36:18 <awestroke> shouya: Ah, nice catch
04:36:19 <identity> no, that didn't pan out.
04:36:29 <myyc> identity: (3+1)?:P
04:36:50 <identity> myyc: it's not that simple, unfortunately
04:36:55 <shouya> awestroke: :)
04:37:02 <nooodl> oh it's Left though
04:37:03 <S3thc0n> Hello #haskell, I've been diving into currying today and got a few questions: It seems to me that currying is sequential, so if I want to partially apply the second argument for instance, what happens? Also it seems that in simplicity it is superior to Lisp-y lambdas, as there is no boilerplate (even if it's hidden in a macro, which still amounts to a >little< boilerplate) for creating a new
04:37:03 <S3thc0n> function  (of course currying is not only for partial application, but also has a specific mathematical elegance; and if there are other important uses, feel free to tell me), do I see that correctly?
04:37:46 <nooodl> (Left x) not (Right x)
04:38:30 <Axman6> @hoogle ap
04:38:31 <lambdabot> Control.Monad ap :: Monad m => m (a -> b) -> m a -> m b
04:38:31 <lambdabot> Data.Graph.Inductive.Query.ArtPoint ap :: Graph gr => gr a b -> [Node]
04:38:31 <lambdabot> Prelude appendFile :: FilePath -> String -> IO ()
04:38:35 <nooodl> :t span
04:38:36 <lambdabot> (a -> Bool) -> [a] -> ([a], [a])
04:38:38 <nooodl> identity: ^
04:39:23 <myyc> i'll try again: i'm using emacs with flycheck and things seem to break at #if's and so on (as does ghci); is this a common problem?
04:39:26 <nooodl> hm, if you implement it that way, though, you get a nasty xs++[x] sorta thing.
04:40:03 <identity> nooodl: yeah, but thank you for span. I can't believe i didn't know about that one. I've done the takeWhile/dropWhile thing so many times
04:41:08 <awestroke> identity: https://gist.github.com/awestroke/686741681a5a65aac68c
04:42:05 <identity> awestroke: yeah, thanks! I think I can make do with span and some pattern matching
04:45:34 <awestroke> S3thc0n: do you mean tuple argument currying or partial function application in general?
04:49:28 <S3thc0n> awestroke: More in general.
04:51:57 <identity> i don't see why it shouldn't be possible to curry any argument, thinking about it
04:52:08 <identity> I mean, you could use flip to curry the snd, really
04:52:09 <pordan30> if you apply a value x :: a to a curried function, say f :: a -> (b -> c), the result is a function g :: b -> c = f x :: b -> c. you can also construct g :: a -> b given a value y :: b from f by g = \x :: a -> f x y :: a -> c
04:55:30 <pordan30> g :: a -> c, i mean
04:55:52 <pordan30> is that what you're looking for? of course, in this example, you can also use flip and so forth
04:56:16 <angerman> how do I build a YYYYMMDD timestamp in haskell from 'now'?
04:56:30 <peteretep> as a string?
04:56:35 <angerman> yes
04:56:39 <S3thc0n> Give me a second, I'm currently looking at what you wrote first.
04:57:20 <peteretep> Where has 'now' come from?
04:57:39 <angerman> peteretep, well, I just theed the string as of now :)
04:57:48 <peteretep> ah!
04:58:25 <peteretep> http://stackoverflow.com/questions/15601100/converting-the-current-time-to-an-int-haskell -- that's a start
04:58:41 <peteretep> getCurrentTime :: IO DateTime
04:59:58 <peteretep> http://www.haskell.org/ghc/docs/7.0.4/html/libraries/time/Data-Time-Format.html
05:00:49 <Guest77325> http://www.marketglory.com/strategygame/galahad1st for all you online gamers out there, if you didn't already, use this link to register on MerkatGlory a free2play financial strategy game where virtual currency can be converted into real money. It starts out slow but in time you can turn a good profit
05:01:36 <angerman> peteretep, hmm ok. I'll see what I can work out.
05:04:31 <S3thc0n> Got to relog, brb.
05:07:17 <identity> angerman: Generally, I don't think dealing with time in haskell is very pleasing
05:07:31 <identity> but then again, dealing with time in general is a pain, imo
05:08:47 <angerman> identity: yea... too bad I need timestamps.
05:09:14 * hackagebot iso8601-time 0.1.2 - Convert to/from the ISO 8601 time format  http://hackage.haskell.org/package/iso8601-time-0.1.2 (NiklasHambuechen)
05:13:45 <PJBoy> I'm given a function that is only defined for a range of inputs, how can I generate the list of the outputs of the inputs that are defined?
05:14:13 <PJBoy> something like map (\x->if x<=4 then x else undefined) [1..]
05:14:36 <PJBoy> (which will give me [1,2,3,4,*** Exception: Prelude.undefined)
05:14:57 <PJBoy> [1,2,3,4] is what I ultimately want
05:15:17 <S3thc0n> pordan30: Okay, back. So wouldn't that result in the first argument still being applied first, and the second just being stored in the meantime?
05:15:48 <hc> PJBoy: do you know in advance for which inputs the function will fail?
05:15:57 <PJBoy> no
05:16:01 <hc> or do you want to catch the exception?
05:17:19 <PJBoy> if catching the exception works, that's fine
05:17:28 <awestroke> S3thc0n: what's the difference? if you apply both arguments, they are stored too, not computed
05:17:31 <awestroke> haskell is lazy, remember
05:17:59 <pordan30> no: if f :: a -> (b -> c) and y :: b, then g = \x -> f x y is a function from a to c. if you constructed a type derivation, say, then you would use the rule for function application when determining that f x y :: b; but that's different than applying an argument x :: a to f
05:18:10 <pordan30> as far as i know, and i may be wrong
05:18:19 <pordan30> f x y :: c, i mean
05:19:07 <hc> PJBoy: PJBoy i think Control.Exception's try function might help
05:21:28 <hc> PJBoy: so what worked for me was let b = try (return $ x 3) :: IO (Either ArithException String)
05:22:17 <PJBoy> alright, thanks
05:23:39 <jle`> PJBoy: you can also try Data.Spoon
05:24:48 <PJBoy> you mean Control.Spoon?
05:26:11 <identity> god damn it. When are the simons going to come up with something that automatically removes all semantic errors from my code?
05:26:36 <Axman6> identity: the thing I'm working on might be useful
05:26:53 <identity> Axman6: what is that?
05:28:42 <Axman6> well maybe not, it's a way to track exceptions thrown by a piece of code in the type. catching the exception removes it from the list of potential exceptions, throwing adds it to the type
05:32:37 <Axman6> sadly GHC doesn't do an awesome job of showing the results of using type families that well a lot of the time
05:34:21 <identity> Axman6: oh. so .. something akin to "throws" in various other languages?
05:34:26 <Axman6> yeah
05:34:37 <Axman6> the idea came from Java (for me)
05:35:00 <Axman6> it seemed odd that we have this great type system, and no idea which exceptions any given piece of code can throw
05:35:19 <identity> I can see your point, yes
05:36:03 <Axman6> planning to write a blog post about it sometime this week, it's been my first foray into type hackery
05:36:36 <identity> make sure to post it on reddit or some such, I would like to read it
05:36:45 <Axman6> will do
05:37:12 <Axman6> this has introduced me indexed monads which makes this work really well
05:39:55 <Axman6> so Throws es fs a is something that, in the context fs (some list of exceptions) and the list of exceptions es that can be thrown after the IO action in the code. then using (>>>=) :: IxMonad m => m i j a -> (a -> m j k b) -> m i k b you can bind them together.
05:41:26 <Axman6> throws :: Exception e => e -> Throws es (Insert e es) a and catch :: (Contains e es, Exception e) => Throws es fs a -> (e -> IO a) -> Throws es (Delete e fs) a
05:42:30 <Axman6> so things might have types like foo :: Throws '[ErrorCall] '[ErrorCall, ArithException] a
05:43:13 <Axman6> (well, that would more likely have type Throws es (Insert ArithException es) a)
05:47:16 <identity> Those types are abit over my head, but I think I get the gist of what you mean
05:49:35 <no-n> imagine if there were a rogue-like about learning haskell
05:49:58 <Axman6> identity: yeah they were above my head yesterday, now they're inside it!
05:50:08 <identity> Axman6: that sounds terrible
05:50:18 <no-n> (to escape from a huge dungeon, of course)
05:50:21 <identity> sounds like you have a case of the kmetts
05:50:29 <no-n> heh
05:52:14 <Axman6> identity: yeah, it's been enlightening, and a bit scary
05:52:45 <moofy> Hello everyone
05:53:24 <Axman6> hello!
05:54:29 <moofy> So I have a vague, possibly silly question. I've been playing around with this simple drawing environment called processing, and I was wondering if there was anything even slightly analagous in haskell so I could have a go at making something simple like a bouncing ball
05:54:48 <moofy> but, err, functionally, rather than in java
05:55:33 <identity> moofy: I'm not sure what processing is, but gloss is really not hard to use from my experience
05:55:40 <identity> it might work for you
05:55:51 <moofy> http://www.processing.org/
05:56:09 <moofy> it's a sort of quick way to write some code and see what it does
06:02:05 <moofy> hmm. gloss seems to be erroring on me
06:15:44 <teneen> What is foldl in terms of recursion schemes?
06:18:29 <teneen> What is foldl in terms of recursion schemes?
06:18:52 <oleo> a)  breadth first b) depth first .....
06:19:11 <Axman6> tail recursive?
06:19:27 <solrize> teneen foldl can be written in terms of foldr, or with direct recursion
06:19:51 <teneen> is foldl a catamorphism?
06:20:48 <solrize> i think so
06:22:04 <solrize> Folds are in a sense dual to unfolds, which take a "seed" value and apply a function corecursively to decide how to progressively construct a corecursive data structure, whereas a fold recursively breaks that structure down, replacing it with the results of applying a combining function at each node on its terminal values and the recursive results (catamorphism as opposed to anamorphism of unfolds).
06:22:12 <solrize> from http://en.wikipedia.org/wiki/Fold_%28higher-order_function%29
06:51:11 <monochrom> foldl is not a catamorphism. not for [] anyway. catamorphism does not just say "reduce", there are more requirements
06:59:09 <teneen> monochrom: then which recursion schem is foldl in?
06:59:27 <monochrom> I don't know.
07:04:37 <quchen> Impostormorphism. It's a fold, but only when looked at it from the right angle.
07:21:16 <awestroke> what is an(iso?)morphism in haskell?
07:25:09 <moofy> ahoy
07:25:19 <moofy> I'm having terrible trouble getting gloss-examples to work :/
07:30:34 <no-n> what's the difference between MonadPlus and Monoid?
07:30:52 <haasn> awestroke: an isomorphism ‘f’ is generally a function that has a (unique) inverse ‘g’ such that (f.g) = id = (g.f)
07:31:17 <haasn> even in Haskell
07:31:42 <Gothmog_> awestroke: haasn: and it's structure-preserving.
07:32:31 <haasn> Is generally a morphism* <- that should cover any notions of preserving structure for things other than sets
07:32:40 <Gothmog_> yeah.
07:34:30 <pordan30> i thought that monadplus instance aren't required to satisfy the monoid laws, and that some instances don't satisfy them.
07:34:48 <haasn> “morphism” means multiple things in different contexts but they're all sort of related; in CT, it's just an element of a category's morphism set, the interpretation of which changes based on the particular category you're looking at; in the category Hask it's just a function
07:35:12 <haasn> in other categories it generally means homomorphisms, or functions which preserve some sort of structure (law)
07:35:13 <pordan30> oh, nevermind - that was wrong
07:35:55 <haasn> eg. a monoid (homo)morphism is a function between monoids that preserves identity: f(id) = id  and composition:  f(a·b) = f(a)·f(b)
07:45:37 <awestroke> haasn: so (+3) is an isomorphism with inverse (-3)?
07:45:50 <haasn> with inverse (subtract 3)
07:46:01 <haasn> (-3) is a number
07:46:04 <awestroke> ah
07:46:05 <awestroke> yeah
07:47:08 <awestroke> what's a cool (intentional) application of isomorphisms?
07:50:11 <quchen> data Tool = Broom | Stick -- Isomorphic to Bool
07:51:30 <quchen> Lens allows you to access data as if it were something else using isomorphisms. SPJ mentions `data Temperature = Fahrenheit Double`, and using an `iso` lens you can adjust that as if it was K/°C.
07:52:19 <quchen> Isomorphisms just guarantee that you can convert to some other form and back without losing any information, so you can pick a suitable representation for your problem, solve it there, and then transform back.
07:54:28 <ClaudiusMaximus> awestroke: exp (a + b) = exp a * exp b ; log (a * b) = log a + log b ; i heard the logfloat package is useful in statistics/probability
07:54:32 * hackagebot cabal-db 0.1.6 - query tools for the local cabal database (revdeps, graph, info, search-by)  http://hackage.haskell.org/package/cabal-db-0.1.6 (VincentHanquez)
07:54:35 * hackagebot combinat 0.2.5.0 - Generation of various combinatorial objects.  http://hackage.haskell.org/package/combinat-0.2.5.0 (BalazsKomuves)
08:00:20 <Sculptor> o/
08:01:00 <klrr_> \o
08:06:01 <awestroke> pdPort :: !Int  <--- what does that bang mean?
08:06:14 <awestroke> nf?
08:07:33 <hpc> awestroke: assuming that's in the middle of a data declaration?
08:07:51 <hpc> it will be a strictness annotation
08:07:52 <awestroke> hpc: yes
08:08:08 <hpc> if the data structure is in whnf, so is pdPort
08:08:23 <awestroke> "no thunks allowed" ?
08:08:38 <hpc> (Int is also annotated with strictness in ghc, so when the data structure is in whnf, pdPort will be in normal form)
08:15:53 <jophish_> Yo yo yo
08:16:14 <jophish_> Is there a Haskell library similar in functionality to glm?
08:16:15 <jophish_> https://github.com/g-truc/glm
08:16:36 <jophish_> glm provides vectors and matrices up to 4x4, and a host of nice things to do to them
08:22:46 <quchen> @hackage linear -- jophish_
08:22:46 <lambdabot> http://hackage.haskell.org/package/linear -- jophish_
08:24:29 <scb> Anyone know how to specify Alex preprocess options with cabal? I googled and only found this https://github.com/haskell/cabal/issues/1223 which isn't of much help.
08:24:32 <jophish_> quchen: ah super, I thought I saw a nice one like that but couldn't find it, it's not listed here: http://www.haskell.org/haskellwiki/Applications_and_libraries/Mathematics#Linear_algebra
08:28:40 <oio_> a good to implement a self recursive concept map?l
08:28:53 <oio_> i maybe trees
08:29:37 <banister> oio_ first learn english THEN learn haskell
08:29:39 <banister> ;)
08:29:40 <banister> jk
08:30:06 <oio_> lol seriously
08:50:23 <c_wraith|N10> Has anyone written up a good description of categorical freeness, and what makes the free monad construction free?
08:51:00 <copumpkin> being the left adjoint of some adjunction
08:58:07 <yogert> Someone mind explaining the arrow notation to me? I'm looking at the example here: http://www.haskell.org/ghc/docs/7.6.3/html/users_guide/arrow-notation.html#idp49515792 and I'm a bit confused. I take it that f, g, and h are arrows defined elsewhere, and the result of this command would either be (x+1) >>> g or  y+2 >>> h.  But the translated version makes no sense to me, is it an error?
08:59:37 <johannesbodannes> AUGH! i wish haskell currently did mobile apps : ((((((
08:59:54 <johannesbodannes> scala is really really ugly
09:00:46 <yogert> what about f#?
09:00:59 <yogert> ive heard good things about it
09:02:09 <jophish_> johannesbodannes: can't ghc compile for iOS?
09:02:19 <johannesbodannes> !!!
09:02:20 <johannesbodannes> can it?!
09:02:27 <ArneL_> It can.. more or less
09:02:34 <jophish_> johannesbodannes: it may be in the works, I'm not sure
09:02:36 <johannesbodannes> oh my gosh! that's amazing! i must investigate immediately
09:02:48 <yogert> Anyone mind
09:02:56 <jophish_> johannesbodannes: Is it possible to write a wrapper in C to call into your Haskell?
09:03:03 <yogert> giving me a hand with the arrow notation? : )
09:03:20 <ArneL_> johannesbodannes : https://ghc.haskell.org/trac/ghc/wiki/Building/CrossCompiling/iOS
09:03:43 <johannesbodannes> thanks
09:04:10 <oio_> what the hell is this
09:04:12 <oio_> >[div 8 2..8]
09:05:41 <lyxia> > [div 8 2..8]
09:05:42 <lambdabot>  [4,5,6,7,8]
09:05:43 <lyxia> ?
09:05:47 <lyxia> oh
09:05:58 <lyxia> > div 8 2
09:05:59 <lambdabot>  4
09:06:03 <lyxia> [4..8\
09:06:08 <lyxia> > [4..8]
09:06:09 <lambdabot>  [4,5,6,7,8]
09:06:29 <catalyst> it's presumably a list comprehension
09:06:32 <catalyst> with no |
09:06:35 <geekosaur> no
09:06:36 <lyxia> The above should be parsed [(div 8 2)..8]
09:06:41 <geekosaur> just a range
09:06:52 <geekosaur> > enumFromTo (div 8 2) 8
09:06:54 <lambdabot>  [4,5,6,7,8]
09:07:01 <catalyst> ah, right
09:07:11 <eacameron> how come cabal complains that I have dangerous reinstalls when I'm using a fresh sandbox? How can anything break? there are no pkgs in my sandbox!
09:07:24 <geekosaur> it's trying to shadow global packages
09:07:45 <eacameron> geekosaur: can I disable that?
09:08:29 <geekosaur> if you can find the sandbox-local config file, you can add constraints to it. (I kinda wish cabal would do that by default. Also for non-sandboxed stuff)
09:08:51 <geekosaur> ghc-pkg list --global | sed -e '\,^/,d' -e '/(/d' -e '/./!d' -e 's/^  */constraint: /' -e 's/-[0-9.]*$/ installed/'
09:08:59 <yogert> Can someone explain to me how the two examples here are equivalent? Or is it an error in the documentation? http://www.haskell.org/ghc/docs/7.6.3/html/users_guide/arrow-notation.html#idp49515792
09:09:24 <geekosaur> output of that would be appended to the cabal config to protect global packages
09:10:12 <ArneL_> johannesbodannes: let us know what you find, I am also very interested in how feasible it is to write (parts of) an iOS app in haskell. And if targeting android is at all possible at the moment (I know that with Ajhc it is, but I could not find any up to date information of what works and what does not)
09:11:02 <eacameron> geekosaur: thanks! :( I thought cabal sandbox would make my life easier
09:11:52 <geekosaur> it does, but only for sandboxed / local stuff. global is harder. I think there's some work going on in that area; sandboxing is still new
09:13:08 <johannesbodannes> will do, ArneL_
09:14:42 * hackagebot pattern-arrows 0.0.2 - Arrows for Pretty Printing  http://hackage.haskell.org/package/pattern-arrows-0.0.2 (PhilFreeman)
09:19:43 * hackagebot purescript 0.4.10.2 - PureScript Programming Language Compiler  http://hackage.haskell.org/package/purescript-0.4.10.2 (PhilFreeman)
09:26:48 <copumpkin> so I have a large C project inside my cabal package and I'd like to make sure all the files I need in it get into the tarball
09:26:56 <copumpkin> I don't want to list them all out in the .cabal file
09:27:23 <copumpkin> I see that a preSDist hook can alter the extra C sources, but that's not the only kind of file I need added
09:27:49 <copumpkin> mzero >>= return
09:28:04 <mzero> indeed I have
09:28:16 <copumpkin> and we know from two separate laws that you are still mzero!
09:28:41 <mzero> I like my consistency
09:28:49 <mzero> (like a nice baked good...)
09:29:05 <heatsink> The low tech solution is to add c-sources and data-files to the cabal file.  It's easy to verify by trying to build the tarball created by cabal sdist.
09:29:19 <copumpkin> [12:25:28]  <copumpkin>	 I don't want to list them all out in the .cabal file
09:29:20 <copumpkin> :P
09:29:35 <copumpkin> there's craploads of them and I don't want to have to go adding more if I update my dependency
09:30:22 <myyc> has anybody used emacs+flycheck with a yesod project?
09:30:27 <heatsink> Can you list all the files with a `find` command?
09:30:31 <copumpkin> yeah
09:30:43 <copumpkin> I'd still rather not list them all out though :/
09:31:12 <copumpkin> 1609 files
09:31:49 <copumpkin> I guess I might just deal with it, for now
09:31:55 <heatsink> The cabal file format isn't intended to be programmable though, so I don't think there's much you can do.
09:32:12 <copumpkin> well, preSDist does let me change some files
09:32:33 <copumpkin> perhaps I should just work on stripping the unnecessary cruft from this
09:32:49 <nawal> test
09:33:30 <heatsink> I would anticipate the contents of the cabal file being examined by external tools, so if it's not in the cabal file, it may not behave consistently wrt those tools.
09:34:09 <Sara> you guys need to smile more! http://adf.ly/hy2dF
09:34:49 <heatsink> Spam detector
09:36:40 <int-e> Ah that's why a "URL shortener" wants JavaScript and Flash.
09:39:51 <eacameron> geekosaur: I think I'm messing things up right off the bat by installing Cabal 1.18 globally. But that's the only way to get sandboxes
09:40:20 <geekosaur> possibly. upgrading Cabal is known to break template haskell, at least
09:40:22 <geekosaur> it's a pain
09:40:43 <eacameron> geekosaur: so how can I get sandboxes so that I can stop the breakage?
09:40:57 <geekosaur> good question
09:40:58 <mzero> hmmm... I run the 7.6.3 from the last platform, and cabal 1.18 no problemo
09:43:38 <eacameron> geekosaur: I think I'll just install 1.18 gloabally, and use sandboxes from then on for everything
09:45:17 <monochrom> you can ghc-pkg unregister the new Cabal lib afterwards. you no longer need it.
09:45:40 <mzero> that's basically what I do --- though for some constellations of packages I have them share a sandbox --- and I have a few very commonly used packages installed "user" so that I can use them from ad hoc quickies
09:45:58 <monochrom> ideally, use a sandbox to build cabal-install, then just copy out the exe, and throw away the sandbox
09:46:27 <monochrom> for how to do sandboxing by hand, see my http://www.vex.net/~trebla/haskell/sicp.xhtml#sandbox
09:46:49 <mzero> huh? there shouldn't be a problem just "cabal install cabal-install" from the old, non-sandboxed cabal ---
09:47:03 <mzero> and there shouldn't be any problem ahving to Cabal libs registered in ghc-pkg
09:47:22 <mzero> "having two Cabal"
09:47:45 <monochrom> we have just agreed that having two Cabal libs confuse TH and GHC API
09:48:21 <mzero> It shouldn't
09:48:32 <mzero> (Sorry, missed that part)
09:48:37 <mzero> It certainly doesn't on my machine!
09:48:58 <monochrom> this is evidence: http://article.gmane.org/gmane.comp.lang.haskell.cafe/109231/
09:49:01 <mzero> I have both registered in ghc-pkg
09:50:32 <mzero> wait - this is because a) the package uses ghc api itself, and then they are loading that in a ghci session... without telling ghci how the package is configured?
09:51:44 <mzero> Indeed - I'd expect that to have troubles.
09:51:53 <mzero> but TH in general doesn't -
09:52:39 <eacameron> geekosaur: I am having trouble adding those contraints, it seems the format is wrong?
09:52:42 <mzero> in general, one can't expect ghci to run code the same as that compiled with cabal -- because cabal is very careful about picking package versions, and ghci operates without the benefit of the .cabal file
09:52:47 <geekosaur> mrrr
09:53:06 <geekosaur> possibly it shouldn't have the colon; I have never been quite certain
09:53:13 <geekosaur> docs seem  to suggest it should have a colon
09:54:04 <mzero> It does work most of the time.. as most of the time one is working on a package using the latest versions of other packages (which is what ghci will do) -- but in the presence of a constraint that pulls a package version back to an older one (like ghc-api requiring the older Cabal, as that is what it was compiled against), then ghci has no good way to get this right
09:54:14 <eacameron> is it contraint or constraints with a comma-separated list?
09:55:10 <benmachine> are we talking about .cabal/config settings?
09:55:22 <eacameron> benmachine: indeed we are
09:56:05 <benmachine> constraint: pkg >= 7.5
09:56:12 <benmachine> constraint: otherpkg < 6.5
09:56:33 * benmachine has "constraint: x installed" for each x that came with GHC
09:56:45 <geekosaur> that's what I thought
09:57:05 <geekosaur> (I gave them a one-liner that generated those from the global package db, they say it's producing errors from cabal)
09:57:11 <geekosaur> syntax errors
09:57:53 <eacameron> is the field supposed to be inside some other field? or just at the "root"?
09:58:20 <eacameron> "Unrecognized field constraint on line 55"
09:58:44 * mzero hates the .cabal format - so unforgiving
09:59:45 <geekosaur> top level
09:59:47 <benmachine> eacameron: sec, I will paste my entire config
10:00:29 <benmachine> as soon as I remember what the command to feed files into my X selection was
10:00:43 <geekosaur> xclip?
10:01:09 <benmachine> it is sometimes xclip and sometimes xsel depending on which computer I am using :(
10:02:17 <benmachine> eacameron: http://lpaste.net/101978
10:02:27 <indigo> Hm, cabal should really have a way to put the current sandbox bin in your path.
10:03:06 <eacameron> benmachine: is that in cabal.config for some project?
10:03:55 <eacameron> I have cabal.config, not .cabal/config
10:04:00 <benmachine> eacameron: that's ~/.cabal/config
10:04:01 <benmachine> ah
10:04:04 <benmachine> ok
10:04:11 <eacameron> perhaps that's it
10:04:14 <benmachine> perhaps
10:07:10 <monochrom> mzero, you're telling me what I already know, and you are misreading. ghc-imported-from is an executable, it uses the GHC API, and it runs into problems when the user has multiple Cabals. I explain the problem by relating GHC API to ghci, but no one is calling up ghci.
10:08:14 <eacameron> rejecting: template-haskell-2.8.0.0, 2.7.0.0, 2.6.0.0, 2.5.0.0, 2.4.0.1,
10:08:14 <eacameron> 2.4.0.0, 2.3.0.1, 2.3.0.0, 2.2.0.0 (global constraint requires installed
10:08:14 <eacameron> instance)
10:08:19 <eacameron> :(
10:09:33 <eacameron> thanks for all the help! I'll keep trying random things
10:09:36 <eacameron> ;)
10:10:24 <geekosaur> eacameron, what are you trying to install? it may require a newer ghc
10:10:33 <geekosaur> (TH can't be upgraded, it's tightly tied to the compiler)
10:10:39 <eacameron> geekosaur: snap
10:11:58 <eacameron> geekosaur: actually, i'm trying to install my snap app
10:12:21 <eacameron> so all of the dependencies that come with snap are attached to my app
10:12:28 <geekosaur> what version range is it looking for, and what version is installed?
10:14:47 <eacameron> can I have a sandbox for my entire computer? ;)
10:15:23 <geekosaur> hsenv?
10:16:02 <geekosaur> gives you an entire ghc install in a sandbox
10:16:09 <eacameron> wow
10:16:15 <eacameron> why am I not using that?
10:16:46 <eacameron> oh
10:16:48 <eacameron> that's why
10:16:50 <eacameron> I'm on Windows
10:16:50 <heatsink> What do you use to sandbox a development version of ghc?
10:17:11 <gdoteof> i am trying to use Data.Aeson to automatically derive FromJSON for a type;  i am able to do deriving Data, Typeable, Show ... but am still getting errors about it not being a FromJSON instance
10:17:12 <bennofs> nix
10:17:58 <gdoteof> http://lpaste.net/101979
10:19:33 <no-n> what do people use for formatting Text? would Text.concat be inefficient?
10:20:51 <no-n> :t asks
10:20:52 <lambdabot> MonadReader r m => (r -> a) -> m a
10:23:11 <eacameron> geekosaur: finally got it working!
10:23:32 <eacameron> I regenerated proj.cabal from snap and used the defaults
10:23:50 <eacameron> using a sandboxed installation of snap
10:25:17 <eacameron> geekosaur: thanks for all your help. I saved off that command you gave me for later if I ever need it
10:39:40 <Redz> i have an function that returns none, one or two results of the same type. should i use a list, a double Either or an extra data structure?
10:40:10 <heatsink> What does the result mean in each of the three cases?
10:40:45 <geekosaur> I wouldn't use an additional data type unless you need that more generally as well. if this is a one-off, it might be easiest to use (x, Maybe x)
10:41:02 <geekosaur> that is, a tuple where the second element is a Maybe
10:41:03 <Redz> just numbers describing the found intersections in an cartesian system.
10:41:34 <heatsink> When it returns two results, is the order important?
10:41:49 <Redz> not important.
10:41:52 <heatsink> So each result is one intersection of curves?
10:42:03 <Redz> yes.
10:42:17 <heatsink> Then it seems like the result is a set of 0-2 elements.
10:42:45 <Redz> yep.
10:42:46 <heatsink> You could just return a list, unless there's some important reason why returning >2 intersections would break the rest of your program
10:43:46 <Redz> well, its more save to have a structure that tells exactly how many results it has. this is why i think a list could be bad.
10:44:16 <Redz> but i cant decide. :/
10:44:29 <heatsink> If it's a set of 0-2 points, then you're probably going to be processing the data by folding over the set's elements
10:45:14 <Redz> hmmm. probably.
10:45:34 <c_wraith|N10> Just return the folding function. Err, don't mind me. I just spent last night Church encoding all the things.
10:45:48 <heatsink> You could use a newtyped list
10:46:08 <heatsink> That gives you the convenient represntation, and also a convenient abstraction boundary where you can verify that length <= 2
10:46:33 <quchen> How can I make "ghc -e" behave just like ordinary GHC, without GHCi's extended defaulting? I would expect ` ghc -ignore-dot-ghci -XNoExtendedDefaultRules -e "([]) == ([])"` to be an error (ambiguous Eq instance), but it prints "True".
10:46:34 <Redz> good idea. i'll try this. thanks.
10:53:34 <shouya> @src mapM
10:53:34 <lambdabot> mapM f as = sequence (map f as)
10:53:44 <shouya> @src sequence
10:53:45 <lambdabot> sequence []     = return []
10:53:45 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
10:53:45 <lambdabot> -- OR: sequence = foldr (liftM2 (:)) (return [])
11:00:05 <Eduard_Munteanu> Is there a '(<||>) :: (a -> Bool) -> (a -> Bool) -> a -> Bool; f (<||>) g = \x -> f x || g x' somewhere? Is there a generalization of it? I can only think of Monoid but that seems a bit arbitrary.
11:00:34 <joelteon> :t liftM2 (||)
11:00:35 <lambdabot> Monad m => m Bool -> m Bool -> m Bool
11:00:39 <Eduard_Munteanu> It appears a Functor (Op Bool) where newtype Op a b = Op (b -> a) is impossible.
11:00:56 <joelteon> > liftM2 (||) even odd $ 3
11:00:58 <lambdabot>  True
11:01:22 <shachaf> Eduard_Munteanu: Yes, it's Contravariant.
11:01:26 <Eduard_Munteanu> joelteon: I know, but it seems useful on its own.
11:02:19 <Eduard_Munteanu> It appears to me an Alternative (Op Bool) is possible aside from the Applicative / Functor aspects.
11:02:45 <bennofs> Eduard_Munteanu: Why not just monoid (Op Bool a) is also possible?
11:02:49 <Eduard_Munteanu> empty = const False; Op f <|> Op g = Op (\x -> f x || g x)
11:03:20 <skypers> do you think it’s possible to make an GADT an instance of Foldable?
11:03:28 <Eduard_Munteanu> bennofs: the problem with plain Monoid is the arbitrary choice between (||) and (&&).
11:03:30 <shachaf> There's already an instance Monoid b => Monoid (a -> b)
11:03:54 <shachaf> So (a -> Any) has the Monoid instance you want.
11:04:06 <bennofs> Eduard_Munteanu: that same problem applies to Alternative, doesn't it?
11:04:13 <heatsink> skypers: It should be possible if recursion is uniform
11:04:40 <skypers> hhm
11:04:50 <skypers> I’m gonna try then
11:05:20 <Eduard_Munteanu> bennofs: Alternative sort of makes the choice implicit because the underlying Applicative gives you the other monoidal structure.
11:05:40 <bennofs> Eduard_Munteanu: well, but you said without Applicative :p
11:05:47 <Eduard_Munteanu> Heh, fair.
11:06:22 <shachaf> Alternative could exist on its own without an Applicative superclass.
11:06:31 <shachaf> It's just a monoid in the category of endofunctors, after all.
11:06:50 <Eduard_Munteanu> It's pretty boring if you remove the Applicative structure, though.
11:07:14 <Eduard_Munteanu> It actually *is* "just a monoid", I guess. :)
11:07:52 <shachaf> Well, a monoid object in the monoidal category with (:*:) as the product.
11:07:53 <joelteon> is there a way to figure out which module a package is from
11:08:19 <Eduard_Munteanu> I wonder if this could be an exo-applicative Hask -> Hask^op.
11:08:25 <geekosaur> is that backwards?
11:08:31 <geekosaur> modules come from packages
11:08:39 <Luke> anyone know how to get shake to match *.js but not *.min.js ?
11:08:40 <geekosaur> (ghc-pkg find-module)
11:08:49 <joelteon> er
11:08:53 <joelteon> which package a module is from, yeah
11:08:54 <Luke> i'm not sure how to get the patterns not to overlap without a more expressive pattern language
11:08:54 <joelteon> my mistake
11:10:34 <hiji> Is there a way to convert a ByteString to String?
11:10:48 <heatsink> Luke: shake's patterns don't do that
11:10:59 <Luke> yeah i know
11:11:06 <hiji> I have tried BS.unpack, but it returns [Word8] not [Char]
11:11:06 <heatsink> Luke: The shake docs recommend you give your filenames unique extensions so that you can pattern match them
11:11:10 <Luke> is there a best practice or something for getting around it?
11:11:17 <Luke> hmm
11:11:18 <Luke> ok thanks
11:11:22 <Luke> where did you see that?
11:11:38 <heatsink> I mean, the extension uniquely determines how it's processed
11:11:55 <quchen> hiji: You most likely want to convert ByteString to Text, for which there's the Text.Encoding module in the `text` package.
11:11:58 <Luke> .min.js is more or less a standard
11:13:54 <heatsink> Luke: https://github.com/ndmitchell/shake/blob/master/docs/Manual.md#defining-rules
11:14:29 <heatsink> "Lots of compilers produce .o files, so if you are combining two different languages, say C and Haskell, use the extension .c.o and .hs.o to avoid overlapping rules."
11:14:30 <Luke> heatsink: ah thanks. I knew I read that somewhere but I was looking on hackage. couldn't remember where those docs were
11:15:40 <Luke> heatsink: it'd be great if I could do a match on the entire extension instead of just the last bit
11:16:56 <heatsink>  *.min.js is a valid pattern
11:17:29 <Luke> yeah but *.js matches min.js and .js
11:17:36 <Luke> its not an exact match
11:17:38 <hiji> quchen, That worked. Thank you!!
11:18:06 <aristid> does shake allow specifying filename matchers with something more sophisticated than glob patterns?
11:18:24 <aristid> if this was a perl regex for example, you could do negative lookbehind :>
11:18:26 <Luke> aristid: like regexp? that'd be nice
11:18:27 <Luke> yeah
11:19:05 <aristid> i'm sure you can also do something similar with parsec/attoparsec
11:19:58 <Luke> aristid: i don't want to lose the file/dependency tracking shake gives with it's pattern matching
11:26:11 <eacameron> is there some way to have multiple modules in one file? Want to somehow get the concept of a namespace...
11:26:33 <geekosaur> no
11:26:39 <dmwit> eacameron: Not with GHC. I think JHC offers a way to have a module manifest.
11:26:41 <Eduard_Munteanu> Unfortunately.
11:27:35 <Eduard_Munteanu> I sort of wonder why this attracted so little attention from people involved with GHC extensions, though.
11:28:05 <dmwit> If you're stuck with GHC, I suspect a well-done proposal would generate some discussion on the mailing list, after which well-done patches would be welcomed.
11:28:19 <dmwit> Eduard_Munteanu: It seems like a pretty low bang with a lot of buck to me.
11:28:35 <eacameron> yeah...seems easy enough... (waits for falling boulder)
11:28:35 <dmwit> Perhaps other extension-happy people feel similarly.
11:28:41 <geekosaur> I was under the impression that reworking how ghc maps modules to files was actually rather difficult
11:28:53 <geekosaur> or at least had its share of potential landmines
11:29:13 <Eduard_Munteanu> Ah... I was only thinking of the difficulty of fitting the concept into Haskell.
11:29:14 <geekosaur> it does come up on various lists every so often
11:29:22 <dmwit> (And it wouldn't even need an extension. This is perfectly well supported by the official spec.)
11:30:07 <dmwit> The Report says nothing about how to find a given module. It doesn't even have to come from a file system -- you could use a database or whatever you wanted.
11:30:35 <dmwit> (where "you" is "a conforming implementation")
11:31:02 <monochrom> conceptual Haskell does not rule out multiple modules in one file
11:40:58 <Peaker> Dealing a lot with the  Exception  class, it seems much like the infamous "existential anti-pattern"
11:41:40 <Peaker> I guess Typeable isn't, but Show is
11:41:41 <heatsink> yeah
11:41:48 <Peaker> And since exception prints are user-facing, it encourages a lot of abuse of Show to not be Haskell syntax
11:42:35 <heatsink> Exceptions happen dynamically, so they don't respect software boundaries
11:42:38 <Eduard_Munteanu> Show should be an opposite of Read.
11:43:27 <shachaf> If you pass it an exception with a parse error, it returns an string that's invalid at the specified point?
11:44:15 <heatsink> I can define foo x = case x of {1 -> print 0; _ -> print 1} and then get arbitrary exceptions thrown from inside 'foo', depending on what is passed for 'x'
11:59:41 <mm_freak_> http://lpaste.net/101980
11:59:43 <mm_freak_> =)
12:03:47 <Ayadew> mm_freak_ how does the sieve perform at extremely high numbers
12:06:24 <thebnq> mm_freak_: wow the funfolding made a huge difference
12:06:38 <shouya> @pl  \f ma mb -> apple mb $ furry' f ma
12:06:38 <lambdabot> (flip apple .) . furry'
12:07:23 <mm_freak_> Ayadew: as long as it fits in your memory it has the expected near-linear performance
12:07:54 <mm_freak_> Ayadew: well, near-square
12:08:28 <mm_freak_> thebnq: there are some features of the code that i don't understand yet
12:08:48 <mm_freak_> originally 'loop' was a mapM_ with an IORef…  replacing it by a recursive loop improved the performance slightly
12:09:04 <mm_freak_> but the inner mapM_, which is still there, performs /worse/ when replacing it by a loop
12:09:51 <mm_freak_> and i'm still unhappy that i need TH to calculate wlog at compile time =/
12:10:22 <thebnq> how come it can't be done at run time
12:10:51 <mm_freak_> it can, but that prevents some optimization opportunities and the runtime quickly jumps from 998ms to ~1600ms
12:11:23 <mm_freak_> and i can't accept that, since the goal was to be faster than C =)
12:11:25 <thebnq> not familiar with the funfolding flag at all, i got slower time with 100 than without the flag at all
12:11:55 <heatsink> It would be nice to have an annotation telling GHC to inline recursive functions
12:12:21 <heatsink> I guess popCount is recursive if GHC won't simplify it.
12:12:22 <mm_freak_> if you have a tight loop with a known number of steps, unfolding emits the loop code multiple times and thereby saves some branches
12:12:36 <mm_freak_> and since branches are expensive, that makes a huge difference for number crunching code =)
12:12:37 <scb> Anyone know of any examples of happy grammars that make use of the error token?
12:12:59 <mm_freak_> heatsink: yeah, it is, but it doesn't have to be…  i guess the default implementation is used
12:13:30 <mm_freak_> the TH requirement might go away simply by updating GHC =)
12:14:12 <heatsink> Does GHC generate proper tail recursion for the if-else in the loop?
12:14:20 <copumpkin> GHC is always proper
12:14:29 <mm_freak_> heatsink: it's not tail-recursive
12:14:33 <thebnq> don't think tailrecursion is a problem in ghc
12:14:44 <heatsink> I've had issues with GHC unnecessarily duplicating the code following an if-else in a tight loop
12:14:58 <mm_freak_> heatsink: but it does the right thing there
12:14:59 <copumpkin> heatsink: bug report?
12:15:05 * hackagebot wai-cors 0.1.1 - CORS for WAI  http://hackage.haskell.org/package/wai-cors-0.1.1 (larsk)
12:15:50 <heatsink> Does it count as a bug?  The code works and I don't know what effect it has on performance, aside from being 2x slower than C
12:16:03 <copumpkin> heatsink: duplicating code unnecessarily seems worth pointing out
12:16:04 <heatsink> Having 20 copies of the inner loop makes it hard to read the core though
12:16:06 <mm_freak_> heatsink: usually you don't have to worry about that, but you should keep in mind that IO actually relies on non-strict semantics
12:16:16 <mm_freak_> (>>) is non-strict in its second argument, which allows IO to be efficient
12:16:17 <copumpkin> heatsink: unless it's just an inline annotation gone wrong
12:16:36 <copumpkin> mm_freak_: wat
12:17:25 <mm_freak_> copumpkin: main = forever (putStrLn "blah") >> undefined
12:17:33 <copumpkin> oh, sure
12:17:45 <Peaker> I can't easily make a closure around my Exception display string, because I have to manually capture the free variables into an ADT and then instantiate Show on that, with abuse :(
12:17:54 <mm_freak_> and 'forever' itself wouldn't even be possible, if (>>) were strict =)
12:18:12 <Eduard_Munteanu> Is there a notion of contravariant monad, say e.g. M : C^op -> C, coming from F : C^op -> D and U : D -> C, M = U o F, given a sensible adjunction-ish relation between U and F?
12:18:22 <shachaf> > (>>) (undefined :: IO ()) `seq` () -- it's non-strict in its first argument too!!
12:18:22 <lambdabot>  ()
12:18:43 <heatsink> Well, I can try making a test case out of it.
12:19:18 <Peaker> > (>>) (undefined :: IO ()) undefined `seq` ()
12:19:19 <lambdabot>  ()
12:19:48 <mm_freak_> that's because internally it's a function =)
12:20:01 <shachaf> such non-strict
12:20:08 <Eduard_Munteanu> e.g. Hom_D(A, FB) ~ Hom_D(UA, B)
12:20:16 <Peaker> and because "seq" is evil
12:20:21 <jmcarthur> I've been reading about GRIN. It's a really cool intermediate language. Extremely simple and powerful.
12:20:34 <Eduard_Munteanu> Er.
12:20:47 <skypers> arf
12:20:57 <skypers> I can’t make my AST (GADT) an instance of Foldable
12:21:00 <Eduard_Munteanu> e.g. Hom_D(A, FB) ~ Hom_C(UA, B)
12:21:12 <mm_freak_> that's all for now…  have fun with the code, bye =)
12:21:23 <skypers> it fails to check type because ctor are existentially quantified
12:22:15 <Eduard_Munteanu> I suspect it's the same thing as an adjunction since Hom_C(A, B) ~ Hom_C^op(B, A), no?
12:22:27 <skypers> does it make a difference using data E a where instead of data E :: * -> * where?
12:23:01 <Eduard_Munteanu> skypers: it shouldn't... though your kind signature is more restrictive than what you get with PolyKinds.
12:23:28 <Eduard_Munteanu> (data E :: k -> * where)
12:23:53 <skypers> Eduard_Munteanu: what is that?
12:23:56 <skypers> PolyKinds?
12:24:02 <skypers> ah
12:24:06 <skypers> k could be whatever kind?
12:24:07 <Eduard_Munteanu> skypers: an extension, don't worry about it if you're not using it
12:24:10 <Eduard_Munteanu> Yes.
12:24:11 <skypers> like *, or (* -> *)
12:24:12 <skypers> ok
12:24:32 <skypers> well, yes I don’t need that
12:24:48 <skypers> the thing is, my GADT represents an AST
12:24:50 <skypers> like
12:24:59 <skypers> C :: (Num a) => a -> E a
12:25:08 <skypers> V2 :: E a -> E a -> E (a,a)
12:25:09 <skypers> and so on
12:25:16 <oio_> what is a good data estructure for a network of word? l
12:25:17 <skypers> I fail to foldMap the first parameter of V2
12:25:36 <Eduard_Munteanu> oio_: what is a "network of word"?
12:25:37 <heatsink> What is a network?
12:26:03 <skypers>     Expected type: E a1
12:26:03 <skypers>       Actual type: E a
12:26:06 <skypers> arf :(
12:26:18 <skypers> that’s why I think it’s existentially quantified
12:26:53 <skypers> data E where { C :: (Num a) -> a -> E a; V2 :: E a -> E a -> E (a,a) } -- the a in C is not the same as the a en V2, right?
12:27:00 <skypers> data E a where*
12:27:03 <Eduard_Munteanu> skypers: it is, sort of... V2 :: forall a b. (a ~ (b, b)) => E a -> E a -> E b
12:27:14 <Eduard_Munteanu> Er.
12:27:20 <heatsink> They're different variables.
12:27:24 <skypers> yeah
12:27:26 <oio_> Eduard_Munteanu:  something like this http://www.brainscanr.com/Search?term_a=depression
12:27:26 <Eduard_Munteanu> skypers: it is, sort of... V2 :: forall a b. (b ~ (a, a)) => E a -> E a -> E b
12:27:29 <skypers> so I can foldMap that
12:27:32 <skypers> cant*
12:27:52 <skypers> and GHC told me that:
12:27:52 <skypers>              V2 :: forall a. E a -> E a -> E (Vec2 a),
12:28:01 <heatsink> I don't think you can foldMap it
12:28:11 <skypers> Vec2 is like (a,a)
12:28:13 <Eduard_Munteanu> :t foldMap
12:28:14 <skypers> arf heatsink
12:28:14 <lambdabot> (Foldable t, Monoid m) => (a -> m) -> t a -> m
12:28:19 <skypers> yeah Eduard_Munteanu
12:28:36 <skypers> and because each ctors use different types
12:28:45 <skypers> I can’t provide a proper (a -> m) function
12:29:22 <skypers> I think I can still write a function to “dig in” the AST
12:29:34 <skypers> maybe by pattern matching
12:29:54 <heatsink> While it's possible to come up with a recursion scheme,
12:30:09 <heatsink> just writing recursive functions works okay
12:30:27 <skypers> what do you mean ?
12:30:31 <heatsink> since in almost all cases, you want to handle some constructors differently
12:30:38 <skypers> yeah
12:30:40 <skypers> something like
12:30:59 <skypers> (Monoid m) => (E a -> m) -> E a -> m
12:31:03 <Eduard_Munteanu> skypers: on the V2 branch, that 'a' in 'a -> m' becomes that b, b ~ (a1, a1) when you pattern-match V2, and you can only get a sensible result by looking at the inner 'E a1's
12:31:20 <skypers> Eduard_Munteanu: yep
12:31:22 <Eduard_Munteanu> However those 'E a1's might incur additional constraints.
12:31:30 <skypers> and I can’t use my (a -> m) on that
12:31:40 <skypers> the idea is that the AST is deep
12:31:44 <Eduard_Munteanu> Yeah.
12:31:57 <skypers> I think my signature just above is quite okay
12:32:07 <skypers> it can lead to misunderstanding though
12:32:12 <heatsink> Instead of writing foldMap, you can write a recursive function each time you want to fold.  Every function will have a case branch for each constructor.
12:32:43 <skypers> I don’t get it, “every function”?
12:33:09 <heatsink> sum (x:xs) = foldr (+) 0 xs
12:33:14 <shlevy> I'm consistently seeing haskell services not show any output when run as systemd services, even when exiting normally. Is it possible that buffer flushing is broken in some subtle way, especially if stdout and stderr are the same files and are not terminals?
12:33:17 <heatsink> sum (x:xs) = x + sum xs; sum [] = 0
12:33:23 <heatsink> That's a recursive function
12:33:29 <Eduard_Munteanu> skypers: is there a reason you don't parametrize E by those types?
12:33:41 <heatsink> It's defined without using a fold
12:33:48 <shlevy> The problem goes away when buffering is disabled, but it's not just a matter of delay, the output never comes.
12:34:04 <skypers> heatsink: :D
12:34:21 <skypers> do you think I know GADTs but not recursivity, heatsink ? :)
12:34:29 <skypers> Eduard_Munteanu: it is parameterized
12:34:32 <skypers> E a
12:34:34 <Eduard_Munteanu> skypers: e.g. data E n a = N n | V2 (E n a) (E n a)
12:34:58 <Eduard_Munteanu> skypers: then your fold only needs an outer Num constraint.
12:35:07 <quchen> shlevy: Maybe I'm answering this on a more basic level than you're asking, but by default stdout is line-buffered. You can flush buffers manually, or change the buffering behaviour of course.
12:35:20 <skypers> Eduard_Munteanu: I’m using GADTs
12:35:35 <skypers> it’s nicer to deal with types restrictions
12:35:45 <quchen> stderr is unbuffered by default though, I think.
12:35:51 <skypers> the Num instance, Floating instance and so on are trivial with GADTs
12:35:51 <shlevy> quchen: I'm seeing block buffering behavior, where stuff is only printed out after several bytes are written (regardless of number of lines)
12:36:20 <shlevy> quchen: But if part of a block is unflushed and the process exits, it does not get flushed even with a normal exit
12:36:45 <Eduard_Munteanu> skypers: your GADT seems more permissive to me, not more restrictive.
12:37:06 <skypers> I mean, you can’t sum E a and E b
12:38:14 <Eduard_Munteanu> skypers: you also can't sum 'E m a' and 'E n a'
12:38:31 <quchen> shlevy: Hmm, in that case I'm afraid I don't know. The "no flush on normal exit" sounds weird.
12:38:51 <shlevy> Yeah. I'm going to try to find a simple reproduction
12:38:59 <shlevy> Of course it will go away once I do :D
12:39:14 <skypers> Eduard_Munteanu: http://lpaste.net/101981
12:39:24 <skypers> it works, but I see a dangerous issue
12:39:24 <quchen> shlevy: Simple reproductions presumably use the terminal, which is not where the issue happens :-\
12:39:25 <heatsink> Eduard_Munteanu, your 'E n a' type doesn't contain any 'a's.  Aren't folds over it trivial?
12:39:32 <skypers> if f actually digs in
12:39:40 <skypers> it’ll duplicate all the way down
12:40:08 * hackagebot learn-physics 0.2 - Haskell code for learning physics  http://hackage.haskell.org/package/learn-physics-0.2 (ScottWalck)
12:40:08 <shlevy> I mean a simple app that works fine on the terminal but not when run as a service
12:40:17 <skypers> read <> instead of >>
12:40:21 <Eduard_Munteanu> heatsink: a more sensible E would contain an 'a', I was just demonstrating 'E n a' represents an AST for expressions containing numbers 'n' and some other thing 'a'.
12:40:34 <heatsink> oh ok
12:41:19 <skypers> I think it’s a DFS I implemted with f e <> f a <> f b
12:41:32 <skypers> implemented*
12:41:44 <heatsink> skypers: in the V2 case, you pass 'a' and 'b' directly to 'f', but you also pass them indirectly to 'f' through 'e'.
12:41:49 <heatsink> Is that what you mean by dig in?
12:42:01 <Eduard_Munteanu> skypers: you don't seem to recurse at all
12:42:31 <skypers> Eduard_Munteanu: oh yeah
12:42:37 <skypers> it should be
12:42:53 <Eduard_Munteanu> f e <> traverseE f a <> traverseE f b  ?
12:42:53 <skypers> e@(V2 a b) = f e <> traverseE f a <> traverseE f b
12:42:56 <skypers> .)
12:42:57 <skypers> yes
12:43:23 <skypers> but I guess it can result in errors and weird behaviors, can’t it?
12:43:40 <Eduard_Munteanu> Not really, why?
12:43:52 <skypers> Eduard_Munteanu: well, if f does recursion
12:43:59 <skypers> it will dig the AST itself
12:44:12 <skypers> and I re-dig it just after, at traverseE f a
12:44:13 <td123> I need to run code when a certain time matches in my database, does anyone have any solutions for this? I am thinking about just running a cron job every minute and querying where the time matches
12:44:46 <skypers> the idea of that function is to extract information from the AST
12:44:56 <skypers> like “what are V2 in my AST?”
12:45:11 <skypers> yeah
12:45:16 <skypers> I guess it will make it :)
12:45:35 <heatsink> skypers, Eduard_Munteanu: I've seen people deal with this situation by defining E as the fixed point of a type
12:45:40 <Eduard_Munteanu> skypers: you could write a mapM_ (Foldable) for it and use Writer
12:46:14 <skypers> how?
12:46:21 <skypers> I’d like to write traverse
12:46:25 <skypers> but I don’t see how
12:46:49 <Eduard_Munteanu> It's not Traversable as it is now.
12:47:11 <skypers> yeah
12:47:11 <Eduard_Munteanu> skypers: look at Foldable instead
12:47:21 <skypers> it’s not Foldable as well!
12:47:32 <skypers> I can’t write a proper foldMap implementation
12:48:58 <skypers> Eduard_Munteanu: not that the real E type is huge
12:49:04 <skypers> I may have something like 15 ctors
12:49:09 <skypers> I’m gonna count
12:49:20 <skypers> ahah
12:49:21 <skypers> 29
12:49:22 <skypers> :)
12:49:49 <skypers> I guess it could be lighter, I’ll see that later
12:51:06 <Peaker> Would it make sense for "IsString" to require "Eq" and "Monoid"?
12:51:13 <Eduard_Munteanu> skypers: hm, you want a   (t a -> b -> b) -> b -> t a -> b   I suspect.
12:51:15 <Peaker> that would make IsString useful for more than just literals
12:51:49 <Peaker> Or maybe refactor "IsString" into "FromString" for literals, and have IsString also have Eq, Show, Monoid, or such
12:52:01 <skypers> Eduard_Munteanu: what is that :D
12:52:04 <shachaf> Peaker: Eq is already added when you match on it.
12:52:33 <shachaf> I think IsString isn't a very good name for it given the class and how it's used.
12:52:36 <Eduard_Munteanu> skypers: or use your traverseE to write a conversion to list function, then mapM_ that.
12:52:50 <Peaker> shachaf, I mean I want to be able to say: IsString a => ..  in my signature, and use it as a string, whether it is ByteString, Text, or String
12:52:54 <skypers> or
12:53:18 <Eduard_Munteanu> Peaker: I think you need way more than that to make a common API for those.
12:53:22 <skypers> I can write a E a -> E' where E' is a type that represents the expression
12:53:24 <haasn> instance IsString ByteString <3
12:53:25 <shachaf> ByteString could have all sorts of encodings. :-(
12:53:25 <skypers> yeah sounds dirty
12:53:44 <haasn> shachaf: and despite this, didn't they manage to pick the one encoding that isn't actually one?
12:53:55 <Peaker> Well, 3.0 and 3 are treated differently as literals.  ASCII literal strings can be treated differently to unicode literals
12:54:07 <Peaker> and allowed for ByteString.Char8 via a different class
12:55:20 <Eduard_Munteanu> Does fromString even fuse away the string literal, I wonder?
12:56:20 <Eduard_Munteanu> It would be a bit annoying to have the buffer built at runtime.
12:56:34 <Peaker> Eduard_Munteanu, at the very least it should be floated into a lazy CAS?
12:58:12 <Eduard_Munteanu> I find it very annoying so many libraries use String.
12:58:51 <Peaker> Eduard_Munteanu, yeah :( I had to rewrite System.FilePath functions and a bunch of stuff so I could get rid of String in my build system where I care about performance
13:00:09 <Eduard_Munteanu> Peaker: also FilePath is quite unsafe IMO, there really should be a better way to handle paths without caring about crappy conventions like '.', '..' and such
13:00:10 * hackagebot purescript 0.4.11 - PureScript Programming Language Compiler  http://hackage.haskell.org/package/purescript-0.4.11 (PhilFreeman)
13:01:16 <Peaker> Eduard_Munteanu, I don't need portability in this project, at least not yet
13:01:24 <Eduard_Munteanu> I'm working on a side project that provides tagged paths and such, to get some compile-time safety of your 'rm -rf's. :)
13:01:57 <Eduard_Munteanu> Peaker: not compatibility, rather (type) safety.
13:03:17 <Eduard_Munteanu> For instance, I need some assurance I don't overwrite stuff in so-called "source" directories.
13:03:25 <shlevy> OK wow
13:03:47 <Eduard_Munteanu> So I want a   copyFile :: SourceDir -> TargetDir -> ...
13:04:13 <Eduard_Munteanu> But generalizing to all sorts of labels, really.
13:04:36 <heatsink> How do you generalize it?
13:06:00 <Sgeo_> Is Haskell the only language with return-type polymorphism?
13:06:12 <Sgeo_> Maybe Idris too, and other heavily Haskell-inspired languages, but any others?
13:06:43 <Eduard_Munteanu> heatsink: for one thing, subpaths should inherit parent tags. Also the path structure is inherently tree-ish so you have a generic notion of file and directory which could appear in types.
13:07:06 <heatsink> Sgeo_: The only way I know of to provide that is a unification-based type system
13:07:21 <Eduard_Munteanu> You also get a notion of absolute vs relative paths.
13:07:45 <heatsink> Sgeo_: Also, for it to be really useful, you need implicit parameters or type classes
13:07:48 <Eduard_Munteanu> I really don't like it that any FilePath can be an absolute path and ruin everything.
13:08:09 <Eduard_Munteanu> e.g. absolute </> possiblyAbsolute
13:08:49 <Eduard_Munteanu> You can pretty much deal away with relative paths in many cases, though.
13:09:12 <shlevy> So it turns out that the buffering issue shows up even with a trivial hello world
13:10:18 <shlevy> Downloading the ghc source now to dig around
13:15:01 <yogert1> Hey, anyone think they could help me out with Arrows / the Hxt library? I have a pretty trivial problem that I just haven't been able to figure out. I have pored through the docs and StackOverflow without much luck. http://lpaste.net/4944725745428594688 I tried to make it as descriptive as I could, because I've asked a couple times here, with no response.  Thanks a lot!
13:15:48 <heatsink> Eduard_Munteanu: Paths are split into disjoint subtrees?  That probably covers enough use cases to be useful.
13:16:01 <heatsink> s/split/classified
13:22:05 <colDrMcBeardman> is there a way to update dependencies in a .cabal file that doesn't involve trying cabal install and waiting for it to fail and adding to the build-depends manually?
13:24:02 <startling> colDrMcBeardman: you can move it, use cabal init, and copy the dependencies
13:24:29 <oio_> how can i visualize data.graphs?
13:25:51 <startling> oio_: I wish I knew.
13:26:21 <bergmark> colDrMcBeardman: maybe cabal-bounds can do it
13:26:28 <alpounet> oio_: i think you can write a small thing that produces something 'dot' or the other graphviz tools can eat
13:26:38 <identity> Guys, I think we need to curb our haskell enthusiasm. Some guy on /r/haskellquestions is expecting Haskell to solve the halting problem now.
13:26:44 <alpounet> or maybe that even exists already, you may want to check hackage for this
13:27:21 <oio_> mmm ok
13:27:43 <alpounet> i think that's as "quick" as it can get, yeah, for now
13:28:56 <himikof> Does anyone know about the current state of layout parsing in the trifecta package? I can only find some references about it being a work in progress, but it seems there is no publicly available code for this.
13:29:03 <startling> identity, they could use idris or agda instead
13:29:28 <edwardk> himikof: i'll probably be dusting it off soon and restoring it, as we're getting ready to need it for ermine soon
13:29:47 <identity> I don't know what either of those do that would solve his problem, but I recall there being something out there that could do what he wants, basically
13:30:17 <identity> e.g. denote some functions for evaluation at compile time
13:31:12 <startling> identity: yeah, that's a legal general-case optimization when you've got guarantees of termination
13:31:30 <startling> in Haskell it isn't since any given expression can diverge
13:31:43 <startling> sorry, "given" is the wrong word
13:32:08 <identity> yep -- but he seems to be using a simple example for his own use case, in which case his simple example is useless because it may be possible to solve his specific example but not the general problem
13:32:33 <startling> Someone could point him to template haskell.
13:32:47 <identity> I would rather he becomes so frustrated that he solves the halting problem
13:34:01 <identity> startling: Regarding the compile time evaluation thing -- do you knwo of anything that does this for Haskell? My brain is making me think I've seen something like that somewhere(for haskell)
13:34:11 <himikof> edwardk: that's good news to hear. I'm trying to implement a Go language parser using trifecta, and it is specified using the "the lexer inserts a virtual semicolon in the token stream" pattern. Is this going to be supported by trifecta, given it's lack of a distinguished lexer?
13:34:15 <startling> identity: you can do it with template haskell
13:35:02 <identity> startling: Yes, I guess you can do it like that, but I was thinking something like a fancy extension or something
13:35:22 <startling> identity, template haskell is a fancy extension. :)
13:35:42 <identity> haha, ah well
13:35:48 <identity> I'll tell him about that and send him here then
13:37:44 <edwardk> himikof: automatic semicolon insertion when you'd have a parse error probably won't pass the trifecta layout handler. that is more like javascript than like haskell. the trifecta form would give you `layout foo` which takes a foo parser for the individual statements and does indentation based separation.   now you could write an "automatic semicolon insertion on parse error" style parser like you'd use in javascript
13:38:12 <Bertrand_> hi :)
13:38:50 <identity> greetings.
13:39:07 <edwardk> in go the rule is to insert a semicolon automatically if the last token before a newline is break, continue, fallthrough, return, ++, --, ), or }    -- so you could write a custom lexer for those that just parsed like normal, did the lexeme parsing which grabs following whitespace, checks to see if that puts the current position on a newline, then sets a flag that a 'virtual semicolon' should successfully parse
13:39:15 <edwardk> you can do that with a bit of state in your parser
13:39:25 <edwardk> with no custom support from trifecta
13:40:14 * hackagebot logic-classes 1.5 - Framework for propositional and first order logic, theorem proving  http://hackage.haskell.org/package/logic-classes-1.5 (DavidFox)
13:40:44 <Bertrand_> I'm playing around with parallelism, and I have a problem I don't fully understand. It concerns NFData. Since I'm passing and returning sequence of int, I get the error : No instance for (NFData (Seq.Seq Int))
13:41:00 <Bertrand_> Someone with an idea? :)
13:43:41 <identity> Bertrand_: That means that Seq.Seq Int isn't an instance of NFData
13:45:07 <Bertrand_> identity_: Any ideas on how I should proceed?
13:45:15 * hackagebot purescript 0.4.11.1 - PureScript Programming Language Compiler  http://hackage.haskell.org/package/purescript-0.4.11.1 (PhilFreeman)
13:45:26 <artyomkazak> Bertrand_: what version of GHC are you using?
13:45:26 <Eduard_Munteanu> heatsink: yeah, though I'm hoping to generalize absolute vs relative and file vs directory as well, and it seems to me / I'm hoping that can be accomplished by indexing paths with a bunch of naturals.
13:46:26 <Bertrand_> artyomkazak: 7.4.1
13:47:27 <artyomkazak> Bertrand_: this instance was added in newer version of “containers” package which ships with GHC
13:47:54 <artyomkazak> um, I forgot. Is it safe to update containers?
13:50:03 <Eduard_Munteanu> More specifically, 'Path k n d' has length n, is absolute for k = 0 and relative for k = S k', and it's a file if d = 0 or a directory if d = S d', such that k + n + d <= s, for 's' a constant natural (but inferred).
13:50:18 <himikof> edwardk: but for it to work all other token parsers should check for such flag and error out like "unexpected semicolon" if it is set. this seems like a limited, non-composable subset of actually simulating parser input (like reparse function from polyparse). I don't know if such functionality makes sense in trifecta, though.
13:50:52 <Bertrand_> artyomkazak: Thanks for the info :)
13:50:53 <Eduard_Munteanu> It's a bit difficult to work with them though.
13:52:48 <eyebloom> In most literature about Haskell, does the word "value" just refer to terms that can't be reduced?
13:53:51 <dwcook> eyebloom, not really; a value could be a thunk as well
13:53:53 <Eduard_Munteanu> eyebloom: I'd rather say everything is a value, usually, as opposed to functions.
13:54:20 <Eduard_Munteanu> Functions being specific values which can be applied.
13:54:36 <c_wraith|N10> A value is something that exists at runtime. I wouldn't be any more specific than that.
13:55:40 <Cale> Occasionally it does refer to the normal forms of expressions, but it ought to be clear when that's the case
13:56:14 <Eduard_Munteanu> eyebloom: it might be helpful to quote some context
13:56:36 <eyebloom> On sec
13:57:12 <scb> Is there something in haskell like pass on python? Something like pass :: a, which just returns something that matches the type system?
13:57:29 <c_wraith|N10> Evaluation, though, is the process of reducing an expression.
13:57:32 <Eduard_Munteanu> scb: undefined? Not that you should use it.
13:57:37 <eyebloom> http://repository.upenn.edu/cgi/viewcontent.cgi?article=1598&context=cis_papers&sei-redir=1&referer=http%3A%2F%2Fwww.google.com%2Fsearch%3Fq%3Dtype%2Bgenerative%2Bcomputation%26ie%3DUTF-8%26oe%3DUTF-8%26hl%3Den%26client%3Dsafari#search=%22type%20generative%20computation%22
13:57:39 <Eduard_Munteanu> :t undefined
13:57:40 <lambdabot> a
13:57:44 <artyomkazak> Bertrand_: just in case, even if updating containers alone is possible (which I don't think it is), I wouldn't risk Cabal hell. Install a newer version of GHC instead.
13:57:52 <edwardk> himikof: yeah what you'd need to do is make a data type with a custom TokenParsing instance that did that
13:57:53 <Cale> Often it refers to the semantic things which expressions denote, under some denotational model of the language.
13:58:01 <dwcook> scb, Python's pass is most similar to Haskell's return (), but that requires that your return type is monadic
13:58:03 <Eduard_Munteanu> :t error
13:58:04 <lambdabot> [Char] -> a
13:58:14 <edwardk> himikof: the layout parsing combinators for haskell-like layout also have to work that way
13:58:14 <eyebloom> In this paper values are their own category of symantics
13:58:18 <dwcook> s/return type/codomain/ , so as to avoid ambiguity in the word "return"
13:58:31 <c_wraith|N10> Wait, when did lambdabot stop printing explicit foralls?
13:58:47 <edwardk> himikof: if you run into something where the token parser combinators can't be extended to cover what you need with a custom instance, i'm happy to patch or take a patch to parsers to fix it
13:58:57 <scb> dwcook: actually I am in a monad... I need to return SomeMonad a, but return () is not cutting it...
13:59:19 <Eduard_Munteanu> eyebloom: looking at the 'v' definition they seem to define terms (as opposed to types) generally
13:59:21 <dwcook> scb, in reality every Python function has a type something like [Value] -> Value, where None :: Value, so it's hard to compare to Haskell
13:59:22 <geekosaur> `SomeMonad a` sounds like you left the determination of a to the caller
13:59:28 <geekosaur> you don't get to pick ()
13:59:29 <c_wraith|N10> scb: in more limited contexts, there are more useful answers. So what context are you thinking of?
13:59:42 <eyebloom> I think a fully saturated term may not be a value in this sense
13:59:44 <himikof> edwardk: ok, thanks for the info, I'll try to implement it this way
14:00:03 <l8star> hi
14:00:37 <Eduard_Munteanu> eyebloom: and further they refer to values as inhabitants of types
14:00:37 <eyebloom> Ok very interesting
14:00:51 <scb> c_wraith|N10: I am trying to recover from happy parsing errors. I must define a function happyError :: [Token] -> SomeMonad a. By default it is defined as simply error "Parse error"
14:01:15 <scb> SomeMonad is a Writer, btw.
14:01:36 <Eduard_Munteanu> scb: a simple one would be 'Either String a'
14:01:57 <geekosaur> scb: note that, with a not specified there, the only thing you can do is throw an exception
14:02:02 <geekosaur> :t error
14:02:03 <lambdabot> [Char] -> a
14:02:31 <scb> Yeah but somehow I need to accumulate all the parse errors, and try to move forward
14:02:56 <Bertrand_> artyomkazak: Unfortunately I'm not gonna be able to update, have to work with the same version of ghc as the labs pc. :/ I'll modify my algo in consequence to avoid this problem.
14:03:11 <c_wraith|N10> scb: you can't do that with a monad.
14:03:31 <scb> There's a whole talk on the Happy docs about the error token but it always errors out instead of trying to parse it.
14:04:33 <scb> And of all the examples they used the most cryptic one. I have tried googling for better examples but no luck.
14:05:05 <Eduard_Munteanu> edwardk: hey... any idea if a 'contra' version of Applicative / Monad makes sense? I'm thinking of a contravariant F : C^op -> D and covariant U : D -> C, such that Hom(A, FB) ~ Hom(UA, B) giving you a UF : C^op -> C. Does it make any sense?
14:05:18 <scb> (this is the url to the docs, in case anyone can figure it out -> http://www.haskell.org/happy/doc/html/sec-error.html )
14:05:32 <edwardk> Eduard_Munteanu: it doesn'
14:05:49 <c_wraith|N10> scb: say the next part of the parser used the value returned? That's possible with a monadic interface. And it's why the calculation can't continue after an error when parsing in a monadic context like that.
14:06:27 <edwardk> Eduard_Munteanu: people have trotted out dozens of would-be 'contravariant applicative' notions in here over the last 8-9 years.
14:06:48 <Eduard_Munteanu> Ah, at least it's not just me. :)
14:07:24 <edwardk> do you have any instances of your 'twisted adjunction'?
14:08:56 <Eduard_Munteanu> edwardk: it came to mind trying to get an Alternative-like thing for things 'a -> Bool', as some notion of ContraAlternative (Op Bool).
14:09:51 <edwardk> Eduard_Munteanu: well if you can construct any interesting generally useful operations for contravariant functors i'm happy to listen. there is a notion of contravariant representability that i use
14:10:34 <edwardk> https://github.com/ekmett/adjunctions/blob/master/src/Data/Functor/Contravariant/Rep.hs
14:10:50 <Eduard_Munteanu> contraempty = Op (const False), Op f >|< Op g = Op (\x -> f x || f y)
14:10:53 <edwardk> that gives you access to contramapWithRep :: Representable f => (b -> Either a (Rep f)) -> f a -> f b
14:11:04 * Eduard_Munteanu looks
14:11:13 <edwardk> you can write that with tabulate and index
14:11:33 <Eduard_Munteanu> Interesting, thanks.
14:11:46 <bgamari> edwardk, re Data.Functor.Rep.TH, with what granularity should I allow customization of the generated representation type (that is the right terminology, right?)
14:11:55 <edwardk> there may be more functions we can write in there using a monoid on Rep.
14:12:24 <bgamari> edwardk, Perhaps the TH magic should simply do what it does and if you want control over the exact names you right it yourself
14:12:40 <edwardk> bgamari: i've taken to calling the x in in (x -> a) ~ f a   the representation of the representable functor f, yes.
14:12:51 <edwardk> well, there are a few options here
14:13:01 <edwardk> one is we can do this using GHC generics and just make a generic rep
14:13:12 <edwardk> replace product with sum, etc.
14:13:24 <Eduard_Munteanu> (Note a plain Monoid would require a rather arbitrary choice of (||), but you could also make a (&&) monoid for 'a -> Bool')
14:13:26 <bgamari> edwardk, well, https://github.com/bgamari/adjunctions/compare/th?expand=1
14:13:32 <edwardk> that can give you a class GRepresentable f
14:13:42 <bgamari> edwardk, I don't have support for sums yet
14:14:13 <edwardk> Eduard_Munteanu: in a similar module we provide extractRepBy and extendRepBy that let you pick the unit and associative operation
14:14:28 <edwardk> bgamari: because, well, you can't  =)
14:14:37 <l8star> is anyone familiar with quipper ? aka quantum programming in haskell
14:14:39 <l8star> ?
14:14:44 <bgamari> edwardk, alright, that was my intuition
14:15:17 <bgamari> edwardk, You couldn't generate a type-safe representation with generics, correct?
14:15:18 <edwardk> all representabl functors are isomrophic to a function that makes them like powers not sums
14:15:27 <edwardk> sure you could
14:15:33 <edwardk> GHC.Generics, not Data.ata
14:15:43 <edwardk> i've done it before for a test
14:15:54 <bgamari> edwardk, hmm
14:16:03 <edwardk> well, technically i derived a 1st derivative, but same idea
14:17:00 <edwardk> l8star: quantum programming, yes. quipper no
14:24:44 <irene-knapp> okay - so I have a coding problem :)
14:24:48 <irene-knapp> well, a packaging problem
14:26:04 <irene-knapp> I got frustrated with OpenGLRaw requiring nonstandard cpp, and I realized that installing “real gcc” on my Mac (which I was already not inclined to do because it has high potential to break non-Haskell stuff) would actually take longer than fixing it to use Template Haskell, so that’s what I’m doing
14:26:28 <irene-knapp> (the package maintainer has expressed opposition to this approach, but this is for my personal use only)
14:26:58 <xDie> hi all
14:27:03 <irene-knapp> anyway, the package uses a C source file defining one symbol
14:27:05 <xDie> @slap
14:27:05 * lambdabot hits  with a hammer, so they breaks into a thousand pieces
14:27:26 <irene-knapp> now that is it also using TH, which forces GHCi to run during the compilation, there is a bad interaction
14:27:30 <xDie> any can helpme to join lambdabeta to my channel
14:27:49 <xDie> my channel is #unix-uy
14:27:56 <irene-knapp> Cabal doesn’t tell GHCi about the .o file, so it doesn’t load it, so it gets an undefined symbol
14:28:26 <nooodl> xDie: i think you'd have to ask int-e
14:28:28 <irene-knapp> I’m not trying to call that symbol at splice-expansion time, but still, it’s needed for the link to succeed
14:28:36 <irene-knapp> any thoughts?
14:28:49 <heatsink> TH import dependences are hard to deal with
14:28:53 <irene-knapp> yes
14:29:04 <heatsink> I think Cabal's approach is to let GHC's recompilation analysis figure out what to import
14:29:08 <irene-knapp> hmm
14:29:10 <xDie> what is int-e nooodl
14:29:18 <xDie> who is OP
14:29:25 <irene-knapp> that would be consistent with what I’m seeing.  that’d be nice if it weren’t a foreign symbol...
14:29:54 <irene-knapp> GHC obviously is never going to be able to detect which file it should come from; I think this is essentially Cabal’s problem.  Cabal needs to pass down the information.
14:30:19 <heatsink> Hmm, I see
14:30:38 <enthropy> and this file gets listed in c-sources:?
14:30:40 <irene-knapp> hmm.  I am wondering whether it would cause any damage to patch Cabal to do C compilation before Haskell compilation (if it doesn’t already), and pass the resulting .o files in…
14:30:42 <irene-knapp> it does, yes
14:30:51 <xDie> enthropy, yes
14:31:13 <xDie> i need fuck your mother to ask this
14:31:29 --- mode: ChanServ set +o Heffalump
14:31:32 <xDie> jaja
14:31:38 <xDie> appear OP
14:31:48 <xDie> Heffalump, sorry
14:32:31 <xDie> Heffalump, have question for you
14:32:41 <xDie> i need lambdabeta to my channel
14:32:53 <xDie> you can join?
14:33:01 <heatsink> irene-knapp, I've seen other packages split their TH code out into a separate package.
14:33:03 <geekosaur> you were told the operator of lambdabot
14:33:05 <irene-knapp> hmmm
14:33:13 <irene-knapp> nasty, but it sounds like it would work
14:33:15 <heatsink> which suggests to me that there isn't a solution to the problem within Cabal
14:33:19 --- mode: ChanServ set +o Cale
14:33:20 <irene-knapp> yeah
14:33:34 <irene-knapp> I’m at least vaguely interested in testing the waters and seeing whether it’s possible to get patches into Cabal nowadays :)
14:34:04 <irene-knapp> this is small enough to be not a huge waste of effort if the answer turns out to be that it’s not ;)
14:34:12 <heatsink> idk, I've never tried hacking Cabal
14:34:24 <irene-knapp> I have :)
14:34:42 <irene-knapp> some of my patches even made it in, three years after I had written them and a year after I had despaired of this :)
14:34:57 <irene-knapp> er, two years after despair, lol
14:35:46 <heatsink> wow
14:35:57 <irene-knapp> yeah
14:37:41 <Peaker> is there a good solution to ANSI color codes being non-composable? :(
14:37:45 <Luke> johnw: hey who's the frontend guy at fpc?
14:37:55 <startling> Peaker: I tend to keep a stack of em
14:37:55 <irene-knapp> Peaker: in what sense?  but probably not :)
14:38:07 <Peaker> red $ "foo bar " ++ yellow "baz" ++ "boo"     -- no easy way to make "boo" red
14:38:16 <irene-knapp> oh yes, I see
14:38:23 <irene-knapp> clearly you can’t do string concatenation
14:38:28 <Peaker> startling, what do you do?
14:38:37 <irene-knapp> define an opaque type ColoredText, with instance IsString ColoredText
14:38:57 --- mode: ChanServ set +o shachaf
14:39:03 <Peaker> irene-knapp, exactly what I've done (ColorText is the name though) but translating the whole code base is painful and I'm worried the extra complexity *everywhere* is maybe not worth it
14:39:04 <irene-knapp> define a concatenation primitive on it which understands this :)
14:39:10 <irene-knapp> right, absolutely :(
14:39:18 <startling> Peaker, keep [Color] as state and when you remove one apply the top one
14:39:20 --- mode: shachaf set +b *!*xdie@190.193.33.*
14:39:20 --- kick: xDie was kicked by shachaf (Your behavior is not conducive to the desired environment.)
14:39:27 --- mode: shachaf set -o shachaf
14:39:33 <Peaker> irene-knapp, ColorText a = ColorText [([TextAttr], a)]  deriving (Monoid)
14:39:38 <irene-knapp> well, can you restrict your code that uses coloring to just a few files?
14:39:50 --- mode: Heffalump set -o Heffalump
14:39:55 <Peaker> irene-knapp, well, it is, but it's a lot of printing code
14:39:59 <irene-knapp> and have it convert from plain Text at the point where it enters that?
14:39:59 <irene-knapp> ah
14:39:59 <angerman> how do I update one filed in a record? Say data A { x :: String, y :: String } and I want to change x?
14:40:00 <irene-knapp> okay
14:40:10 <irene-knapp> yes, it’s going to be painful
14:40:16 <geekosaur> angerman: foo {x = newvalue}
14:40:23 <geekosaur> where foo is the starting record
14:40:28 <Peaker> startling, well, adding State around everywhere sounds more complex than the ColorText solution?
14:40:36 <irene-knapp> while you’re rewriting it all, you might look into switching to one of these libraries at the same time
14:40:37 <irene-knapp> http://hackage.haskell.org/packages/search?terms=pprint
14:40:40 <geekosaur> note that this creates a new record value; haskell does not, as a rule, do mutable data
14:40:43 <angerman> geekosaur: oh! let me give that a try.
14:40:44 <irene-knapp> actually, there already appears to be one for this purpose
14:40:50 <angerman> geekosaur: yep.
14:40:57 <startling> Peaker, I guess so. It's building strings vs representing them in a composable way, I think.
14:41:14 <Peaker> irene-knapp, I've been burnt by the canonical pprint library -- stack overflows and such :(
14:41:18 <irene-knapp> http://hackage.haskell.org/package/ansi-wl-pprint
14:41:19 <irene-knapp> oh :(
14:41:27 <irene-knapp> that’s wl-pprint?
14:41:38 <Peaker> I don't recall which one, I think "pretty"?
14:41:46 <irene-knapp> ah, k
14:41:54 <edwardk> daan leijen's version of wadler's pretty printer.
14:41:55 <irene-knapp> this is a different codebase entirely, fwtw
14:42:03 <Peaker> irene-knapp, also "pprint" means I've got a 2d document, whereas I do like to think of this as a 1d stream of text (that happens to have some newlines in it)
14:42:09 <irene-knapp> true, I agree
14:42:17 <irene-knapp> then, skip pprint and continue as you were :(
14:42:20 <irene-knapp> but that’s upsetting
14:42:25 <edwardk> i prefer the wadler-leijen formulation because it doesn't get tripped up trying to make something act as the unit of too many monoids.
14:42:31 * irene-knapp nods
14:42:40 <startling> ansi-wl-pprint is nice, but has kind of a gross API.
14:43:00 <startling> well, a big one.
14:43:16 <irene-knapp> hmm, okay.  haven’t tried it.  I do generally hate pprint libraries, for the same reason as Peaker gives - I think of it as a stream of one-dimensional text with wrapping annotations
14:43:17 <edwardk> i had wl-pprint-extras and wl-pprint-terminfo, but i switched to ansi-wl-pprint for most of what i do, because it was a dependency of many of my own dependencies
14:43:21 <edwardk> so it seemed silly
14:43:26 * irene-knapp nods
14:44:07 <edwardk> and max was willing to take patches to fix the biggest problems with ansi-wl-pprint
14:44:25 <irene-knapp> I also can’t but notice that ansi-wl-pprint prefers String over Text as its input type
14:44:29 <irene-knapp> which seems like a serious deficiency
14:44:55 <irene-knapp> I mean, one could write the translation combinator easily, but what is it doing internally?
14:45:02 <Cale> Well, it's been around since long before Text
14:45:06 <irene-knapp> fair, of course
14:45:50 <lrocksmashtime> what are peeps here using for haskell integration with postgres? A quick googling has led me to postgres-simple.
14:46:08 <Cale> I can't imagine it would take too much work to rewrite a version of wl-pprint to generate Text
14:46:48 <irene-knapp> lrocksmashtime: I haven’t tried integrating Haskell with Postgres, yet, sorry
14:47:02 <irene-knapp> Cale: yes, true I’m sure
14:47:09 <colDrMcBeardman> is there a config variable for the :{ :} prompt in ghci?
14:48:00 <irene-knapp> I am not aware of one
14:48:19 <davidsd> Question about contexts/instances: I have a database that requires some configuration (in a data structure called DBConfig), I’m trying to make a typeclass that slightly generalizes MonadReader DBConfig.
14:48:23 <davidsd> So far I have:
14:48:29 <davidsd> class (Monad m, MonadIO m) => HasDBConfig m where
14:48:29 <davidsd>     getDBConfig :: m DBConfig
14:48:30 <davidsd> instance (MonadReader DBConfig m) => HasDBConfig m where
14:48:31 <davidsd>     getDBConfig = ask
14:48:59 <davidsd> But ghci complains about these, saying I need FlexibleContexts, FlexibleInstances, UndecidableInstances, etc.
14:49:14 <davidsd> I’m not very familiar with these extensions, but they don’t sound very nice
14:49:15 <colDrMcBeardman> irene-knapp, ok, thanks. it's kind of annoying when you have a long line of modules :P
14:49:19 <davidsd> what’s the right design pattern here?
14:49:22 * irene-knapp nods
14:49:31 <byorgey> davidsd: that instance is probably not what you want.  In particular, it does not mean "every MonadReader DBConfig is an instance of HasDBConfig".
14:49:58 <byorgey> davidsd: instead, it means "*everything* is an instance of HasDBConfig, and oh, by the way, it had better also be an instance of MonadReader DBConfig"
14:50:07 <irene-knapp> davidsd: imo FlexibleContexts and FlexibleInstances are perfectly safe.  UndecidableInstances are not :)
14:50:23 <irene-knapp> you could write:
14:50:52 <irene-knapp> class (Monad m, MonadIO m) => HasDBConfig m where
14:51:04 <irene-knapp>   data DBConfig m
14:51:14 <irene-knapp>   getDBConfig :: m (DBConfig m)
14:51:32 <davidsd> Hmm
14:51:35 <irene-knapp> this uses TypeFamilies (you could do something equivalent with MultiParamTypeClasses and FunctionalDependencies)
14:51:37 <lrocksmashtime> Ok another question. I'd like to develop a robust back end outside of any http requests. One that I can eventually talk to via a REST api. Are there any frameworks / libraries built for this type of development? Or do people usually just start working with a web application framework like Yesod? Hopefully this question makes sense.
14:51:38 <byorgey> irene-knapp: how does that help?
14:51:55 <irene-knapp> doesn’t it?  it expresses the constraint that the specific configuration type depends on the monad
14:52:03 <davidsd> That seems weird, since DBConfig would then depend on m, but it just contains a bunch of strigns
14:52:08 <irene-knapp> oh
14:52:25 <byorgey> irene-knapp: I see no evidence that's what davidsd wanted
14:52:29 <athan> Anybody here part of Hackage 2.0 / up to date with it's development / want to talk about ideas for it :)?
14:52:30 <irene-knapp> hmm, what you really want is a typeclass not on the monad, then, but on the database connection object?
14:52:54 <irene-knapp> I hadn’t thought it through, but I guess your monad is not tied to a specific database backend
14:52:58 <davidsd> Well, I want a typeclass for any monad that can access a DBConfig object
14:53:14 <davidsd> So, for example, it should work for any m that satisfies MonadReader DBConfig m
14:53:16 <byorgey> davidsd: the class you have is perfectly fine
14:53:20 <irene-knapp> well, the class can be
14:53:24 <athan> davidsd: You've probably seen persistent, huh
14:53:26 <byorgey> it's the instance that's not
14:53:28 <davidsd> and I also want to be able to write instances that work for MonadReader Foo m
14:53:34 <davidsd> where Foo contains DBConfig
14:53:37 <irene-knapp> class HasDBConfig m config
14:53:52 <irene-knapp> then the return type fixes which config you’re asking for
14:54:16 <byorgey> irene-knapp: why are you trying to abstract over the config type?  davidsd has said there is a specific DBConfig type.
14:54:22 <irene-knapp> oh
14:54:26 <irene-knapp> sorry, I missed that
14:54:31 <davidsd> Np
14:54:44 <davidsd> byorgey is right, DBConfig is a fixed type that just contains a bunch of strings
14:54:49 <irene-knapp> I was trying to do that because it was similar to a problem that I faced recently, but when I did it, I had multiple config types :)
14:54:52 <irene-knapp> my mistake :)
14:56:23 <davidsd> So, byorgey, is there some way I can write the instance better?
14:56:24 <athan> is it possible to measure the implementation complexity of an arbitrary mathematical expression?
14:56:41 <athan> determinsitically, so you have a higher order function evaluate it's complexity?
14:56:47 <byorgey> davidsd: unfortunately, there's really no way to just have every instance of MonadReader DBConfig also be an instance of HasDBConfig
14:56:58 <athan> preferably in the context of normal CPU's + GPU's?
14:57:09 <byorgey> davidsd: you just have to write a separate instance for each actual monad
14:57:19 <irene-knapp> athan: not with present mathematical knowledge.  there are several concepts of complexity, ie. Kozmogorov (sp) complexity…  but you need a human to invent a novel proof for each thing that you want to know the complexity of
14:57:24 <davidsd> Ok
14:57:36 <davidsd> Is there an alternative design pattern that might be preferable here?
14:57:39 <irene-knapp> athan: now, if what you want is the complexity of the code that the compiler will generate, that’s different
14:57:53 <irene-knapp> athan: what you appear to be asking about, though, is the best possible complexity regardless of what the compiler actually does
14:58:46 <irene-knapp> davidsd: mm, if there is, I’d like to know it too.  I have done things more like what you’re actually doing (now that I understand what it is, haha), but I did them as byorgey suggests - lots and lots of instances.
14:58:46 <byorgey> davidsd: there might be, but I can't think of one
14:59:01 <Luke> anyone know neil mitchells IRC handle?
14:59:08 <byorgey> Luke: ndm
14:59:14 <Luke> brent thanks
14:59:15 <byorgey> Luke: but I haven't seen him around in a very long time
14:59:25 <Luke> damn =/
14:59:29 <irene-knapp> the problem is in the way instances are resolved.  you can’t easily say “make an instance whenever this context is satisfied, but only if an explicit one doesn’t already exist”
14:59:37 <athan> hmm no, I'm more interested in the computer's implementation of solving it. I feel like it would be possible by analyzing the AST in context of a normal machine with a simple mathematical arithmetic unit
14:59:47 <irene-knapp> that is, you *can* but it requires some extensions that are probably not a good idea, as you noted :)
15:00:12 <irene-knapp> athan: ah!  okay.  well, I mean, the compiler is going to perform optimizations on it…  such as common subexpression elimination
15:00:23 <athan> irene-knapp: So I guess it's not technically the complexity, it's how difficult it is to evaluate at run-time
15:00:24 <irene-knapp> but potentially also loop unrolling, and floating things into and out of loops
15:00:33 <irene-knapp> yes.
15:00:47 <irene-knapp> well, it’s the complexity, but not the abstract complexity :)
15:00:49 <athan> irene-knapp: Oooooh yeah, I want to make (*) instances of Monoid and Commutative Group, idk tohugh
15:00:59 <athan> yeah lol
15:01:04 <athan> i can't touch that stuff haha
15:01:08 * irene-knapp nods
15:01:09 <athan> but it's fairly basic
15:01:22 <athan> I want to keep alternative backends possible for rendering graphics
15:01:39 <irene-knapp> ah, and you want it to default to the one that’s most efficient?
15:01:47 <irene-knapp> but surely which is most efficient is going to be a static property of your code
15:01:53 <irene-knapp> at least, for any given compiler version
15:02:14 <athan> ie: vector, pixel, etc., and if I was able to gain some kind of statistic or sense of a) the precision, b) the space c) the complexity and d) it's features, then I'd be set
15:02:26 <irene-knapp> hmmm, right
15:02:35 <athan> yeah honestly I have no idea
15:02:37 <davidsd> Ok, byorgey & irene-knapp, thanks for your help!
15:02:38 <athan> I just have a basic one
15:02:39 <athan> like
15:02:41 <athan> for instace
15:02:42 <irene-knapp> davidsd: anytime
15:02:54 <athan> when doing intersections of two cubic splines
15:03:09 <athan> for doing boolean operations on svg vectors
15:03:21 <athan> you can't calculate the roots of the cubic equation easilly
15:03:28 <athan> the derivative looks like it's from hell
15:03:39 <athan> newton's guess+check is way too complex
15:03:55 <athan> but this one guy found a way to approximate it through iterations of a circle
15:04:13 <athan> and it became a really quick way of pixelizing the vector
15:04:15 <athan> er
15:04:20 <athan> rasterizng
15:04:32 <Peaker> @type intercalate
15:04:33 <lambdabot> [a] -> [[a]] -> [a]
15:04:39 <Peaker> intercalate should have been Monoid m => m -> [m] -> m
15:04:43 <athan> so really, I'm just wondering if there is a way to arbitrarilly measure how complex any mathematical expression is
15:04:51 <bennofs> @ty F.intercalate
15:04:51 <lambdabot> Couldn't find qualified module.
15:04:52 <athan> or really, maybe a subset of elementary operations
15:05:04 <irene-knapp> hmmm, oa=kay
15:05:05 <athan> Peaker: Ahh!!
15:05:13 <irene-knapp> *okay.  interesting approach.
15:05:16 <aranea> Can this be easily written without do notation? http://lpaste.net/8876735250848284672
15:05:28 <irene-knapp> and the short answer is, not arbitrarily, no.
15:05:36 <irene-knapp> I mean, if it’s an expression without flow-control
15:05:40 <bennofs> Peaker: probably (Monoid m, Foldable f) => m -> f m -> m
15:05:45 <athan> flow control?
15:05:48 <athan> oh
15:05:50 <irene-knapp> then its complexity is O(1), surely :)
15:05:51 <athan> you mean if-thens
15:05:58 <bitemyapp> athan: hello again.
15:05:59 <irene-knapp> if/then and also recursion, yes
15:06:06 <athan> bitemyapp: Wasssuuuuup?!?!
15:06:22 <athan> irene-knapp: Thanks!!
15:06:23 <bitemyapp> athan: exercises. Do them.
15:06:30 <athan> bitemyapp: THANKS MOM
15:06:36 <athan> bitemyapp: I have though haha
15:06:40 <irene-knapp> when analyzing complexity by hand, one generally starts by partially compiling the thing.  Donald Knuth’s _The Art of Computer Programming_, volume 1, is the book to learn this from :)
15:06:42 <Peaker> bennofs, yeah, though toList'ing first is less a big deal than rewriting intercalate itself
15:06:42 <athan> bitemyapp: I've got most of them down
15:06:51 <athan> bitemyapp: ... (feels the greif)
15:07:19 <irene-knapp> automatied complexity analysis would be a fascinating topic; there may have been research in it, but I’m not aware of any
15:08:28 <startling> irene-knapp: hey, I just bought that
15:08:29 <athan> irene-knapp: I'm sure there has been. If not, I can still totally use laws of algebra and categorical concepts to see redicable expressions and legitimately be able to "count" how many times the ALU get's used
15:08:38 <startling> glad to see a post-recommendation.
15:08:44 <irene-knapp> startling: :D yeah!  it’s a great book
15:08:52 <athan> I too will have to get it :)
15:09:16 <startling> Specifically because I wanted a more rigorous understanding of algorithmic complexity. 8)
15:09:20 <irene-knapp> athan: I will warn you that it’s very mathematically dense.  but he has a pleasant style and stuff :)
15:10:30 <Welkin> what is with LYAH?
15:10:31 * haasn .oO( irene-knapp on #haskell?! I think that's a first for me )
15:10:32 <Welkin> it is down!!
15:10:37 <Welkin> the world is ending!
15:10:48 <athan> hahaha
15:10:49 <irene-knapp> haasn: hi!  yeah, I used to come here years ago, and only returned like last month.
15:10:54 <Welkin> I'm forced to use a cached version
15:10:56 <irene-knapp> the amount of traffic had been the major reason I left
15:11:15 <irene-knapp> fascinatingly, google turns up http://dl.acm.org/citation.cfm?id=99381 (“Automatic Complexity Analysis”)
15:11:52 <Welkin> irene-knapp, but you DEAD: http://www.ashlandwi.com/obituaries/article_517c5376-780b-11e3-8e94-001a4bcf887a.html
15:11:56 <athan> irene-knapp: Do you know how well haskell programs can have their complexity measured? Or at least Core programs, post optimization by ghc?
15:12:09 <irene-knapp> Welkin: LOL yes I’m aware
15:12:32 <irene-knapp> Welkin: I was amused when I stopped being the top seven hits for myself because my namesake got an obituary :)
15:12:49 <athan> aranea: Still here? Yeah, you totally could
15:13:04 <irene-knapp> athan: no, sorry.  I have no idea.  I believe that Core is still lazy semantics, so that’s a new wrinkle.
15:13:15 <haasn> there are certainly things in Haskell which can have their complexity precisely measured
15:13:29 <haasn> it's just a matter of asking the right questions
15:13:30 <irene-knapp> you really want blocks of assembler code, with all the jump instructions identified and relating the blocks to each other,
15:13:36 <athan> aranea: so "sock <- ..." creates a parameter under the hood
15:13:39 <irene-knapp> then you have to write a proof about how many times each block is entered
15:13:44 <athan> haasn: right hahaha
15:14:02 <haasn> which also gets more complicated in the presence of laziness
15:14:02 <athan> haasn: What comes to mind when you say that?
15:14:19 <aranea> athan: yes, still here
15:14:30 <haasn> athan: say, the number of pattern matches needed to reduce (f x) to some canonical normal form; as ‘x’ grows in the number of constructors
15:14:32 <athan> haasn: Indeed. I can see how spatial analysis, or "# of hops" + static helps
15:14:48 <athan> haasn: aaaaah!
15:15:01 <athan> haasn: the units of haskell
15:15:06 <athan> haasn: (->)
15:15:16 <athan> aranea: so anyway
15:15:21 <athan> aranea: sorry about that haha
15:15:41 <athan> aranea: when you see "some term <- monadic statement"
15:15:47 <athan> aranea: that's the same as
15:15:52 <haasn> athan: yes, pattern matching and constructors is a good unit of haskell
15:16:00 <haasn> because that's what haskell's operational semantics are based on
15:16:02 <athan> aranea: "monadic statement >>= (\ term -> ...)"
15:16:21 <athan> haasn: I was just pondering this
15:16:23 <startling> Can laziness affect algorithmic complexity?
15:16:28 <athan> haasn: (->) is the type of function application
15:16:41 <athan> haasn: erm
15:16:52 <Hodapp> startling: I believe so but I'm trying to think of any reference I have on hand for this.
15:16:55 <athan> haasn: the "guide" haha
15:16:57 <shachaf> Yes.
15:17:06 <irene-knapp> startling: yes.
15:17:10 <aranea> athan: yes, sure. I know how to decompose do blocks. I was just wandering if there was way to express that code *elegantly* without a do block
15:17:18 <athan> haasn: it almost compounds as you go from kind to type, with the (->)
15:17:20 <haasn> startling: depends on what you mean; but say head (sort xs) could be O(n) for suitable implementations of ‘sort’, even though sort may be O(n²)
15:17:31 <irene-knapp> for example, the complexity of summing an infinite list is infinite, but with laziness, …
15:17:34 <Hodapp> startling: The paper "Total Functional Programming", I believe, answers in the affirmative, but mostly just to lead to the point that it does not change corectness.
15:17:38 <startling> oh, right.
15:17:56 <athan> aranea: Oh my bad.
15:18:17 * irene-knapp nods
15:18:31 <startling> hrm, I'm out of coffee.
15:19:05 <Jitendra> hi all
15:19:13 <acowley> I think I wish cabal test had --show-details=always on by default
15:19:28 <Hodapp> startling: like, out of even the components to make coffee?
15:19:30 <aranea> athan: I guess my question wasn't clear enough...
15:19:33 <athan> aranea: (socket AF_UNIX Datagram defaultProtocol) >=> ((flip bind) addr)
15:19:33 <Hodapp> startling: or your coffee cup is just empty?
15:19:42 <athan> aranea: or something like that
15:19:43 <acowley> It's anticlimactic when a lot of tests pass and you just get one OK
15:19:49 <Jitendra> can anyone give me a sample code to generate random numbers from a list?
15:19:51 <acowley> The more OKs, the better my self-esteem
15:20:00 <Hodapp> Jitendra: what do you mean from a list?
15:20:02 <aranea> hey, that looks nice ;)
15:20:06 <startling> Hodapp: the former. :<
15:20:13 <Hodapp> startling: go get that problem solved!
15:20:17 <Hodapp> or just make tea
15:20:30 <Jitendra> @hodapp: an integer list
15:20:30 <lambdabot> Unknown command, try @list
15:21:23 <athan> aranea: could be WAY better
15:22:13 <Jitendra> suppose if i give the command genRandom 3 [1,4,6,2,3] then i have to get any 3 random numbers from the list
15:24:19 <athan> aranea: ((flip bind) addr) <=< sock where sock = socket AF_UNIX Datagram defaultProtocol
15:24:46 <athan> aranea: hmm
15:24:46 <startling> Jitendra: there's a package that makes this nice, one sec
15:25:30 <haasn> Jitendra: I would probably use something like take 3 (shuffle [1,4,6,2,3]) where ‘shuffle’ is some suitable shuffling function, perhaps based on http://hackage.haskell.org/package/random-shuffle-0.0.4/docs/System-Random-Shuffle.html
15:26:02 <startling> aha, http://hackage.haskell.org/package/random-fu
15:26:19 <athan> aranea: wait, yeah, that resolves to the same thing as `return sock`
15:26:31 <haasn> startling: heh, also just came across it; http://hackage.haskell.org/package/random-fu-0.2.4.0/docs/Data-Random-List.html#v:shuffleNofM
15:26:53 <startling> heh
15:26:57 <athan> aranea: because do { foo <- monad; return foo } cancels
15:27:17 <Eduard_Munteanu> Any idea if Happy's attribute grammars can be used to derive an unparser / printer for free, more or less?
15:27:34 <haasn> acowley: “OK... for now”
15:27:52 <haasn> that should be the net output of the entire test suite
15:27:55 <athan> Eduard_Munteanu: Oh I believe it
15:28:13 <athan> Eduard_Munteanu: like a pretty printer?
15:28:17 <acowley> haasn: I'm having a hard time perceiving the pat on the back I'm usually hoping for when I run tests
15:28:19 <Jitendra> @haasn: thank you...i will give it a try
15:28:19 <lambdabot> Unknown command, try @list
15:28:22 <haasn> athan: (flip bind addr) = (`bind` addr)
15:28:35 <athan> haasn: Doh!!!
15:28:39 <athan> haasn: Thank you :)
15:28:45 <haasn> acowley: if you want a pat on the back when tests pass, do you want a kick to the groin when they don't?
15:28:54 <aranea> haasn: yes, that's what I've done now
15:29:01 <Eduard_Munteanu> athan: not sure about "pretty" but given a parse of the data I want to get the original text back.
15:29:13 <johannesbodannes> wow, ubuntu's official repository has an up-to-date GHC for once
15:29:25 <johannesbodannes> life is good
15:29:25 <startling> johannesbodannes: you know what they say about stopped clocks ...
15:29:28 <aranea> Thanks athan, it works. I didn't remember <=<
15:29:33 <athan> Eduard_Munteanu: well, most of the time, whitespaces get truncated
15:30:08 <acowley> haasn: No, I still want a pat on the back. Except it should be conciliatory instead of congratulatory. I ask for a lot of nuance from my printfs.
15:30:10 <athan> Eduard_Munteanu: There's a javascript parser / printer that I toyed with (written in haskell) that retained all that info. I'd imagine happy to do the same
15:30:18 <Eduard_Munteanu> athan: oh sure, I don't need an exact original, just an equivalent... basically 'unparse . arbitraryTransform . parse' that can be reparsed again.
15:30:28 <startling> acowley: is there a .cabal/config for that?
15:30:34 <athan> johannesbodannes: hahaha
15:30:52 * BMeph prefers a kick in the arse from failed tests. Well, a kick to someone else's arse, anyway. ;þ
15:30:53 <acowley> startling: subtle printfs? I doubt it. Then again, there are lot of flags...
15:31:01 <athan> aranea: no prob! Glad I could help!
15:31:08 <athan> Eduard_Munteanu: Totally possible
15:31:26 <aranea> hmm
15:31:30 <athan> Eduard_Munteanu: http://www.aosabook.org/en/ghc.html
15:31:37 <acowley> Compromise: haasn gets kicked whenever a test fails
15:31:45 <Eduard_Munteanu> athan: I suspect that too, just unsure how. Happy's stuff seems to only deal with defining the datatypes from the grammar.
15:32:00 <haasn> acowley: maybe you should write your test suite in Cfluviurrh and have the interpreter feel happy whenever they pass, for you
15:32:23 <athan> Eduard_Munteanu: :/ You could easilly add it
15:32:27 <athan> Eduard_Munteanu: as a monad!
15:32:49 <athan> Eduard_Munteanu: (easilly)
15:32:57 <Eduard_Munteanu> athan: mm, how so?
15:33:02 <Eduard_Munteanu> Heh.
15:33:14 <athan> Eduard_Munteanu: the monad could store the context of the parse, much like the javascript version
15:33:28 <athan> that way the monad contains all the information to recreate the origional file
15:33:32 <athan> the difficult part
15:33:53 <athan> is gonna be in recreating the semantics out of the grammar
15:33:55 <Eduard_Munteanu> athan: that sounds problematic if I want to transform the AST before unparsing
15:34:21 <athan> Eduard_Munteanu: I'm just not sure if haskell-whitespace is deterministic from the AST
15:34:25 <athan> Eduard_Munteanu: yeah
15:34:32 <athan> Eduard_Munteanu: I know it shouldn't be from Core
15:34:51 <Eduard_Munteanu> athan: I'm not parsing Haskell code.
15:34:54 <athan> Eduard_Munteanu: but just a simple parse should be fine... I just think that you'll have to recreate the syntax rules within a monad
15:35:04 <athan> Eduard_Munteanu: oooohhhhhh.... what code?
15:35:14 <athan> Eduard_Munteanu: that's all arbitrary to your syntax, then
15:35:46 <Eduard_Munteanu> athan: not code, right now parsing URIs and HTTP.
15:35:50 <Jitendra> @haasn: i see that shuffle doesnt satisfy my need... i want in general to take an integer (for number of integers) and integer list from command line argument and then produce the specified number of random numbers given in command line argument
15:35:50 <lambdabot> Unknown command, try @list
15:36:13 <athan> Eduard_Munteanu: You should totally be able to. Are you using parsec?
15:36:23 <Eduard_Munteanu> athan: attoparsec, but yeah
15:36:43 <Eduard_Munteanu> athan: I can't see how attoparsec could handle that nicely.
15:36:55 <athan> Eduard_Munteanu: You'll have to have the resulting AST have within each element, a wrapper (functor really) that holds whitespace information
15:36:57 <haasn> Jitendra: I don't see the difference between that and your first question, and my answer is still the same
15:36:58 <athan> I'd start with that
15:37:17 <athan> or whatever would normally get garbled
15:37:23 <haasn> Jitendra: unless I misunderstood you a second time. Do you want to allow repeat elements?
15:37:25 <athan> you just need to find the pivot points
15:37:25 <Eduard_Munteanu> I don't need an exact original, just syntactically correct.
15:37:42 <athan> according to URL strings?
15:37:48 <Eduard_Munteanu> athan: yes.
15:37:50 <athan> like ?= ;
15:38:03 <athan> use a json serializer
15:38:04 <Eduard_Munteanu> athan: the entire URL / URI.
15:38:13 <athan> is it just the params?
15:38:14 <athan> like
15:38:19 <athan> you've got URL parameters
15:38:19 <Eduard_Munteanu> No.
15:38:21 <Jitendra> :haasn: no i dont want the numbers to be repeated
15:38:35 <athan> or is it a heirarchical folder system you want to retain
15:38:36 <athan> ?
15:38:48 <Eduard_Munteanu> athan: to clarify, I want to avoid writing the printer all over after the parser, I feel like they should / could share the same code.
15:38:52 <haasn> Jitendra: then I don't understand why take n . shuffle doesn't help
15:38:52 <athan> what parts of the url are you trying to "keep" in your AST?
15:39:04 <athan> they should
15:39:07 <athan> and they could
15:39:10 <Eduard_Munteanu> athan: just enough to reconstitute an equivalent URI
15:39:13 <athan> you just have to write an isomorphism
15:39:32 <athan> Eduard_Munteanu: Then that directly depends on what you're trying to take out :)
15:39:41 <Eduard_Munteanu> All of it. :)
15:39:59 <Eduard_Munteanu> I'm implementing the entire spec.
15:40:04 <athan> Eduard_Munteanu: Then you should have no problem! haha
15:40:09 <athan> Eduard_Munteanu: as an ADT?
15:40:15 <Eduard_Munteanu> Yes.
15:40:19 <athan> Eduard_Munteanu: because that would be the common ground
15:40:24 <athan> Eduard_Munteanu: then you're all set
15:40:27 <Eduard_Munteanu> Well, a bunch of ADTS.
15:40:33 <Eduard_Munteanu> *ADTs.
15:40:36 <athan> Eduard_Munteanu: just get down the elements, then they're relative placement to eachother
15:40:53 <athan> Eduard_Munteanu: and ambiguate their delimiters (/) and terms
15:41:17 <athan> Eduard_Munteanu: exactly :)
15:41:28 <athan> Eduard_Munteanu: it just depends on the standard that the website uses
15:41:29 <Eduard_Munteanu> athan: I think I haven't made myself clear, I know I can print an original URL, I just want to avoid writing a printer altogether.
15:41:43 <athan> Eduard_Munteanu: You're gonna have to lol
15:41:56 <athan> Eduard_Munteanu: I don't know of a printer immediately, however you should look into yesod
15:42:08 <Eduard_Munteanu> It seems to me it could be produced from the grammar.
15:42:14 <athan> Eduard_Munteanu: they're bound to have some mastery of the URI in there somewhere
15:42:28 <athan> Eduard_Munteanu: IF the grammar is standard over all use cases
15:42:48 <athan> Eduard_Munteanu: and non-corruptive to itself (crpyto :P)
15:43:08 <athan> Eduard_Munteanu: then you should be able to pull them all out, and have an AST
15:43:21 <athan> then just make a show instance of your ADT
15:43:30 <Eduard_Munteanu> That's what I want to avoid.
15:43:34 <athan> recursively
15:43:38 <athan> it would be trivial
15:43:51 <athan> you just have to allow for userspace data (terms)
15:44:09 <Eduard_Munteanu> I know, but it's besides the point. The grammar could and should be enough, especially with an attribute grammar.
15:44:10 <athan> and then use that within the system space (backslashes, protocols, delimiters, etc)
15:44:58 <athan> Eduard_Munteanu: There might be a boilerplate library that creates the reader and show from generics
15:45:06 <athan> Eduard_Munteanu: But I'm not sure about that
15:45:59 <athan> Eduard_Munteanu: That are able to just look at a grammar, create it's parser, ast/adt, and it's show instance
15:46:07 <athan> Eduard_Munteanu: There's gotta be...
15:46:57 <Eduard_Munteanu> I wonder if yacc or other parser generators do it.
15:47:30 <athan> Eduard_Munteanu: It would be difficult do construct a DSL that would express all those requirements
15:47:52 <athan> Eduard_Munteanu: I don't know if the grammar language is enough
15:48:00 <athan> Eduard_Munteanu: If it is, you should totally do it!!!
15:51:48 <athan> Eduard_Munteanu: You'd just have to make a spec. of expressing system-space characters (/, ?, ;, etc) and user-space, their delimitability, and how the list interpretation is fully comprehensive and refactorable (really, it should be equatable for simple grammars, not often with complex ones) upon itself
15:52:42 <Eduard_Munteanu> I know how to parse it, just not how to get a printer without writing it. :)
15:53:56 <athan> Eduard_Munteanu: You've first gotta write the writer that can take what you write to write the writer
15:54:08 <acowley> When I load a module in cabal repl, why can't I import another module from the package I'm working on?
15:54:24 <athan> cabal repl?
15:54:30 <athan> import Module
15:54:31 <acowley> Yes
15:54:47 <athan> wait is this wizardry... you mean ghci, right?
15:54:48 <acowley> Right, my question is why that doesn't tend to work
15:54:53 <acowley> No, I mean cabal repl
15:54:59 <athan> it always works in ghci when I do it...
15:55:10 <MedDev> cabal repl = sandboxed ghci
15:55:10 <athan> no idea man, you're ahead of me
15:55:10 <acowley> Right, but I'm asking about cabal repl
15:55:15 <athan> ahhhhhhhh
15:55:27 <athan> i couldn't tell ya
15:55:31 <acowley> Hrmph
15:55:45 <MedDev> acowley, what error do you get? or does it fail silently?
15:55:46 <athan> check out ze sorece!
15:56:08 <acowley> <no location info>:
15:56:08 <acowley>     Could not find module `MyPackage.MyModule'
15:56:10 <acowley>     It is not a module in the current program, or in any known package.
15:56:28 <MedDev> is your .cabal file exporting that module?
15:56:44 <Eduard_Munteanu> This looks interesting: http://hackage.haskell.org/package/BNFC-meta
15:56:46 <acowley> MedDev: Yes
15:56:59 <yitz> acowley: are you using a sandbox?
15:57:27 <yitz> acowley: and what version of cabal are you using?
15:57:38 <acowley> 1.19.2
15:57:42 <MedDev> acowley, have you tried running 'cabal repl -v' and seeing it it expounds upon exactly where it's searching for the package?
15:57:50 <MedDev> err module
15:58:47 <athan> Does anyone know where I could get a job? lol
15:58:56 <athan> this industry that I'm in is sketch
15:59:05 <yitz> acowley: we're still on cabal 1.18.*. there, if you are in a sandbox, cabal repl doesn't work. instead you use: ghci -package-db .cabal-sandbox/blah-blah-conf.d
15:59:26 <athan> or really, the company I'm working for
15:59:30 <acowley> Okay, I see what I'm doing
15:59:38 <yitz> where blah blah depends on your platform, etc. usually you just type x or i and hit tab.
15:59:44 <acowley> The problem is I would start cabal repl
15:59:47 <yitz> that may be fixed in 1.19 though.
15:59:51 <acowley> It would load all the modules exposed by my package
15:59:56 <acowley> then I would :load a module in development
16:00:02 <acowley> at which point my package's modules are dumped
16:00:13 <acowley> And at that point, I can't import
16:00:32 <dcoutts_> acowley: this isn't a repl issue, just how ghci works.
16:00:39 <MedDev> ah does simply using 'import DevModule' work then?
16:00:46 <acowley> dcoutts_: How should I be using things better?
16:00:48 <acowley> MedDev: no
16:00:51 <dcoutts_> acowley: when you load a file, that file and its deps are loaded, only.
16:01:12 <dcoutts_> acowley: the "loaded" modules and the "in scope" modules are distinct things
16:01:14 <yitz> acowley: use :add
16:01:19 <acowley> Ah!
16:01:47 <acowley> yitz: Thank you!
16:01:47 <dcoutts_> acowley: so you want them all loaded, like at the beginning, you just want to adjust the ones that are in scope / exposed
16:02:00 <acowley> dcoutts_: right
16:02:10 <dcoutts_> acowley: :add is like load, but adds more. You may want to be using :m rather than :l
16:02:20 <MedDev> :m +MyModule
16:02:24 <acowley> Okay, I'll give them all a shot
16:02:30 <acowley> I still use :m out of old habit sometimes
16:02:41 <dcoutts_> :m / :module (or import) adjusts the modules that are in scope
16:02:52 <dcoutts_> which is always a subset of the loaded ones
16:03:01 <acowley> But import doesn't work with my in-development module
16:03:13 <acowley> Nor does :m
16:03:23 <yitz> so if your devel module was loaded together with everything at the beginning, use :m or import to get to it. otherwise, use :add.
16:03:31 <acowley> Okay, got it
16:03:35 <dcoutts_> acowley: it's a tad confusing since ghci considers package modules (ie ones from other pre-existing packages, not source files) to always be loaded.
16:03:57 <acowley> Doesn't :load also expose non-exported things?
16:03:57 <dcoutts_> so one can import / :m  them at any time without first :load ing
16:04:05 <dcoutts_> acowley: it does both
16:04:20 <acowley> Is there any way of recovering that behavior with :add?
16:04:21 <dcoutts_> it both loads and adds those modules to the exposed / in scope set
16:04:33 <dcoutts_> as that'd usually be what you want
16:05:05 <yitz> dcoutts_: the :l/:m distinction used to be more clear before sandboxes. now it's more confusing.
16:05:06 <dcoutts_> acowley: I think to get what you want, to :load <modulesA>  and then :module <modulesB>  where B <= A
16:05:35 <dcoutts_> yitz: you mean because cabal repl defaults to :load ing all the modules?
16:06:08 <dcoutts_> yitz: though I think that's probably still the best default behaviour. Though we're open to suggestions.
16:06:16 <acowley> dcoutts_: In that example, is modulesA my in-development code?
16:06:30 <yitz> dcoutts_: i guess that's why. but what is "all"? e.g., if i locally install some packages to the sandbox, those are *not* loaded.
16:06:32 <acowley> I guess not
16:06:59 <dcoutts_> acowley: yes, you :load everything you want (well, it does transitive deps automagcally)
16:07:11 <dcoutts_> acowley: and cabal repl defaults to loading everything
16:07:17 <acowley> dcoutts_: If I load my in-dev code, then I can't use :module to load my other modules
16:07:21 <dcoutts_> (in the component)
16:07:38 <dcoutts_> acowley: is this all within one component? (ie lib/exe)
16:07:43 <acowley> And if I :add my in-dev module, I don't get non-exported things
16:07:50 <acowley> dcoutts_: The in-dev module isn't in the .cabal file
16:08:00 <dcoutts_> acowley: oh then you want to :add it
16:08:11 <acowley> Yeah, and that gets me most of the way there
16:08:14 <dcoutts_> so that it gets lodaded too
16:08:25 <acowley> but the one last wrinkle is that that doesn't expose unexported things
16:08:26 <yitz> acowley: after that you can :m it
16:08:35 <dcoutts_> acowley: note also that ghci treats compiled vs interpreted modules differently
16:08:52 <dcoutts_> acowley: you can import a compile module, but you can't get "inside" it
16:09:16 <acowley> yitz: I ran "cabal repl", then I ran ":add MyModule". At that point, I don't have unexported things from MyModule, and :m MyModule doesn't work
16:09:26 <dcoutts_> acowley: so if you want to get inside it then you need to clean the compiled .o files first
16:09:46 <yitz> acowley: what dcoutts_ just said
16:09:52 <dcoutts_> acowley: again, this is the way ghci has always worked, though it's not clear how we should expose that nicely with cabal repl
16:10:00 <acowley> dcoutts_: There is no .o for my in-dev module, though
16:10:08 <dcoutts_> acowley: though you get the effect (as usual) by cleaning the .o
16:10:24 <dcoutts_> acowley: ghci tells you when you :load / :add if it's compiled or interpreted
16:11:07 <dcoutts_> acowley: so I *think* :add really does just load, without affecting the modules in scope
16:11:17 <acowley> πErk
16:11:21 <acowley> Okay, oops, sorry
16:11:21 <dcoutts_> :show modules
16:11:26 <acowley> Yes, I think :add is doing what I wanted
16:11:37 <acowley> I borked my export list test
16:11:48 <acowley> Okay, this is great
16:12:06 <acowley> Maybe confusing, but I think it does just what I want
16:12:13 <acowley> Thank you dcoutts_  and yitz!!
16:12:27 <dcoutts_> so really the only thing cabal repl is doing differently is that it's starting by loading all the modules from the component (ie listed in the .cabal file)
16:12:38 <dcoutts_> otherwise it's just "normal" (slightly confusing) ghci behaviour
16:12:46 <acowley> Right, I think my confusion probably came from being unsure about :m, import, :add, and :load
16:12:47 <dcoutts_> which is fairly well explained in the ghc user guide
16:12:58 <acowley> With the usual issues of .o files existing, too.
16:13:02 <dcoutts_> right
16:28:44 <athan> ahhh I think I know what I'm gonna add to my algorithmic analyzer!
16:28:53 <athan> it will use the ast as units of difficulty
16:29:15 <athan> but give replacements of operations depending on if the underlying hardware implements it
16:29:55 <athan> so like if there was some CPU that had like, 3ary multiplication (* . *) built into the ALU, that would count as 1 unit if I replaced it in the AST of the expression
16:30:15 <athan> I'm gonna have to make it arity agnostic, though
16:31:37 <athan> ...multidimential ASTs :P
16:31:48 <athan> with n-ary operators xD
16:32:23 <athan> spinally equating associatively or messy-like commutatively
16:32:52 <athan> And then, if the operators / elements are invertable, entire elements can be removed!
16:33:02 <athan> I just need to retain direction of application within the AST
16:33:29 <athan> or really... have an AST that represents "equating" as an operation (a vital one)
16:33:34 <athan> phew
16:33:55 <athan> isn't that n-ary? :)
16:38:01 <athan> can it be a sub expression :o
16:38:14 <athan> expression placement laws...? O.o
16:40:14 <P4Titan> Hello all, I am doing 99 problems of Haskell to learn the language and I am on question 24: I litterally have the same function, diff_select is the solution, and rnd_select is my implementation, their solution works mine does not: http://pastebin.com/sM8wbGvV   Any ideas why? They are literally the same, Thanks!
16:42:26 <ion> Please define “does not work”.
16:45:39 <P4Titan> ok
16:46:09 <scb> is there any reason not to use RWS? I mean should I use that or should I build my own reader/writer/state with transformers?
16:46:11 <P4Titan> the functions have to generate a list of 6 Ints from [1..49]
16:46:22 <P4Titan> here is the output
16:46:23 <P4Titan> [7,6,5,4,4,3]
16:46:23 <P4Titan> [45,9,18,34,23,7]
16:46:23 <P4Titan>  
16:46:39 <P4Titan> The top is mine and it does not look random, the bottom is theirs and it works
16:47:31 <hiptobecubic> P4Titan, looks random to me
16:50:05 <ion> “xs !! num”
16:53:26 <P4Titan> ion: what about that?
16:54:27 <triliyn> Is there a good way to convert string names to time zones?
16:54:41 <triliyn> Data.Time's parseTime doesn't seem to do what I want
16:56:07 <scb> is it at all possible to remove from a writer accumulator?
16:56:28 <scb> Say my accumulator is [Int], can I modify what I have been accumulatin?g?
16:57:37 <Cale> scb: Not as such
16:57:58 <scb> So probably I would be better off with a State, right?
16:58:02 <Cale> scb: You probably want State instead, yes
16:58:32 <Cale> But your entries will naturally be reversed then
16:58:47 <scb> It's ok, I'm basically building a zipper to keep track of where I am
16:58:52 <Cale> (but perhaps this will be more convenient anyway, if what you're doing is representing a stack)
17:00:10 <jesyspa> scb: You can if your monoid has an element C such that for all x, x*C = e and C*x = x.  (where e is your identity)
17:00:26 <jesyspa> Err, I think that should work, at least.
17:00:34 <jesyspa> Hang on, nope, breaks associativity.
17:05:01 <ezrios> I am reading "Monad Transformers Step by Step" and came across the following example: http://bpaste.net/show/195444/
17:05:29 <ezrios> why is it that we use runErrorT to "unwrap" the inner monad on line 7, only to wrap it back up into an ErrorT on line 3?
17:05:53 <ezrios> similarly with return and ErrorT
17:07:05 <Welkin> how do you deal with long lines?
17:07:18 <Welkin> without adding a lot of parens
17:08:02 <chrisdotcode> let's say I have a record: `data Foo = Foo { list :: [a] }`. how do I append something to the list inside? I have this so far, is there a better way?:
17:08:02 <chrisdotcode> addItem :: a -> Foo -> Foo
17:08:02 <chrisdotcode> addItem item foo = foo { list = list'} where list' = item : (list foo)
17:08:19 <Welkin> for example: zipWith (long anonymous function) [list] [list]
17:08:56 <ezrios> Welkin: don't use an anonymous function?
17:09:01 <ezrios> raise it to top level
17:09:21 <ezrios> or use a where
17:09:37 <Welkin> where should do it
17:09:39 <Welkin> thanks
17:38:03 <stolaruk> In parsec, is there a "oneOf" and "noneOf" that works with Data.Text instead of Char?
17:39:39 <geekosaur> it should just work, with Text.Parsec.Text?
17:39:46 <geekosaur> the token type is still Char
17:40:31 <geekosaur> the stream type differs but Text.Parsec.Char doesn't constrain that
17:40:55 <stolaruk> hmm ok
17:41:00 <athan> GAAA - you should never queue user input unless I telepathically tell you to, computer!
17:42:17 <geekosaur> glwt
17:48:06 <stolaruk> geekosaur: If you have a moment could you please look at http://lpaste.net/101988
17:48:09 <geekosaur> oh, if your question was actually whether it *takes* a Text, doesn't seem to
17:48:26 <geekosaur> I suspect that is difficult to do with any reasonable performance
17:48:42 <geekosaur> it will *operate* on a Text parser, but takes [Char]
17:48:55 <ezrios> I am reading "Monad Transformers Step by Step" and came across the following example: http://bpaste.net/show/195444/
17:49:13 <ezrios> why is it that we use runErrorT to "unwrap" the inner monad on line 7, only to wrap it back up into an ErrorT on line 3?
17:49:32 <geekosaur> (if you think about it, it's really neither a string nor a list but a set; I suspect using Set Char would be painful though)
17:50:00 <stolaruk> I'm a total beginner with Parsec
17:50:08 <stolaruk> Just in my app I'm using Text sintead of String
17:50:37 <geekosaur> right, it looks like it's treating the literal string as Text, but it needs to be [Char]
17:50:57 <geekosaur> try passing [',', '\n']
17:51:09 <stolaruk> ok
17:51:10 <geekosaur> that's also closer to what it actually means
17:51:20 <heatsink> ezrios: It's unwrapping (k r) and wrapping (m >>= k r)
17:51:28 <geekosaur> (again, it *really* should be a Set Char)
17:51:52 <geekosaur> (but for backward compatibility it uses [Char])
17:52:05 <stolaruk> Wow, it's still upset
17:52:10 <geekosaur> (and the lack of Set literals makes that a painful representation to work with)
17:52:15 <heatsink> ezrios: Since the code is implememting (ErrorT e m) on top of m, its interface is based on (ErrorT e m) but its internals are based on m
17:52:19 <geekosaur> wonder if it translates that too early then
17:52:51 <geekosaur> you may need an explicit type on it, or maybe I missed something else going on in there
17:52:53 <Cale> I don't think I've ever been too broken up about the lack of set literals, but I missed a little chunk of this conversation...
17:53:16 <heatsink> ezrios: It unwraps (m) and (k r) so that it can decide what to do with the error condition
17:53:30 <geekosaur> hm
17:53:32 <heatsink> ezrios: and it wraps the entire thing in an ErrorT to hide the error condition handling
17:53:37 <geekosaur> I also don't see why it mentions Identity there
17:53:58 <stolaruk> Cale: Trying to figure out a good way to fix the type error in this code http://lpaste.net/101988
17:54:20 <geekosaur> oh, I get it I think. many produces a list
17:54:29 <ezrios> heatsink: hm, I see
17:54:32 <geekosaur> so it's returning a list of tokens
17:54:35 <ezrios> not sure I fully grok it yet but ok
17:54:39 <geekosaur> which is not, actually, a string
17:54:50 <geekosaur> you'll need to pack it if you want a Text out of it
17:55:03 <geekosaur> (and it's not oneOf that's breaking you, it's many)
17:55:11 <stolaruk> oh
17:55:20 <geekosaur> many produces a list of tokens
17:55:27 <geekosaur> you need to force that back to being a Text
17:55:33 <stolaruk> ok
17:56:13 <geekosaur> this Just Works when using String because it's a list of Char, but for other string representations you need to turn the list of Char tokens back into a string
17:56:28 <stolaruk> right
17:56:29 <geekosaur> (perhaps this means `many` is not the most appropriate way to do this)
17:56:31 <stolaruk> That was very hard
17:58:11 <stolaruk> This may have fixed it: cell = T.pack `liftA` (many . noneOf $ ",\n")
17:58:28 <geekosaur> seems likely
17:59:00 <stolaruk> thanks!
18:44:09 <jwingfi> started a disucssion over on ##programming and I wanted to give it a shot here too
18:44:26 <jwingfi> I've been thinking about Turing machines vs. the Lambda Calculus, and I wonder... does the fact that modern computer architecture is based on Turing's concept of computability instead of Church's (lambda calculus) play a part in the general success (ease of use) of procedural languages vs. function?
18:44:45 <Cale> Not really. That's what compilers are for.
18:45:06 <Cale> The computers we use aren't really anything like Turing machines either
18:45:39 <sipa> they are like ram machines, more than turing machines
18:45:47 <jwingfi> I think they're more like turing machines than the lambda calculus right?
18:46:12 <jwingfi> I'm mainly focusing on how turing machines seem to have a fundamental concept of mutation
18:46:22 <vermeille> Hi all
18:46:29 <jwingfi> which is completely absent from the functional languages, the lamda calculus,e tc
18:46:38 <Eduard_Munteanu> vermeille: hi
18:46:39 <ion> cale: How do you know my computer doesn’t take O(difference from the previously accessed location) time to access memory?
18:46:49 <Cale> ion: :D
18:46:59 <Cale> ion: It actually does
18:47:04 <ion> hehe
18:47:11 <vermeille> is there a way to abstract { var <- action; case var of ... } into something like { case action of ... } ?
18:47:25 <heatsink> There's a GHC extension for that
18:47:58 <ziman> do you mean LambdaCase or is there anything more specialised?
18:48:03 <heatsink> LambdaCase
18:48:10 <heatsink> action >>= \case of ...
18:48:17 <vermeille> something that would be like  `m a -> a`
18:48:24 <vermeille> Ah, never thought about that
18:48:29 <heatsink> Hmm, no "of"
18:48:45 <Cale> jwingfi: Well, every real functional language also has ways to manage mutation, but sure.
18:48:46 <heatsink> action >>= \case {True -> ... ; False -> ... }
18:49:01 <vermeille> Not really sexy, implies to explicitely use bind and a lambda
18:49:06 <dwcook> vermeille, if you mean that as a type, m a -> a is not possible in general
18:49:10 <vermeille> but that's better, true
18:49:33 <Eduard_Munteanu> vermeille: what's your actual usecase?
18:49:40 <vermeille> I know dwcook, but I assume that something like that is possible because that's more or less what '<-' does
18:49:46 <Cale> vermeille: I wanted the syntax to just be like a section of case
18:49:57 <dwcook> vermeille, <- is just syntactic sugar for (>>=)
18:49:59 <Cale> where you leave the scrutinee out and that's the only difference
18:50:00 <dwcook> @type (>>=)
18:50:00 <lambdabot> Monad m => m a -> (a -> m b) -> m b
18:50:16 <Cale> i.e. like  action >>= case of ...
18:50:34 <dwcook> vermeille, specifically, do { x' <- x ; rest } is sugar for x >>= \x' -> do rest
18:51:07 <vermeille> Eduard_Munteanu: https://github.com/Vermeille/HaskellExpr/blob/master/src/Parser.hs I'm very often acquiring a value just to match it in my Parser monad
18:51:43 <vermeille> That's completely pointless to make an lvalue of that and to use one more line
18:52:25 <Eduard_Munteanu> vermeille: is that a Parsec style parser? You should be doing it differently.
18:52:41 <dwcook> vermeille, do { toks <- get ; return $ head toks } can, if you prefer, be rewritten as get >>= return . head
18:52:50 <vermeille> Eduard_Munteanu: if that's your question, that's not a parser combinator, that's a simple LL parser
18:53:06 <dwcook> vermeille, however, in this case you can do even better to write it as fmap head get
18:53:24 <vermeille> dwcook: what is considered "best practice"?
18:53:33 <dwcook> vermeille, whatever reads clearest
18:53:52 <dwcook> (That's my take anyhow)
18:54:09 <dwcook> "Clear" is of course subjective
18:55:06 <vermeille> dwcook: wouldn't it be `lift head . get`?
18:55:06 <jwingfi> cale: so perhaps we need the "tape" concept for persistence, IO, etc.  But what about pure computation?
18:55:34 <GoshaZa> I'm getting linker errors when I try to compile hello world. I'm not sure where to start looking for help.
18:55:35 <dwcook> vermeille, for what value of lift?
18:56:20 <Cale> jwingfi: You can take any imperative algorithm for computing something and turn each line (point of control flow) into a function, and turn all the mutable variables in scope into function parameters
18:56:36 <vermeille> dwcook: nevermind, I'm still a beginner
18:56:42 <dwcook> vermeille, here is a transformation you can apply generally: do { x' <- x ; return (f x') } becomes liftM f x
18:57:03 <Cale> jwingfi: and then have each function apply the appropriate function for the next line to whatever the updated values for the variables are
18:57:05 <vermeille> Anyway, line 45, there's no point in making `op` a variable
18:57:12 <dwcook> vermeille, (liftM ought to be the same as fmap when both are defined but fmap incurs a Functor dependency rather than Monad)
18:57:18 <jwingfi> cale: yeah... all that's really needed is just some type of stack to store intermediate results
18:57:21 <vermeille> but I have to do that in order to match against it
18:58:05 <vermeille> dwcook: yeah, I used liftM2 later in the file just to be more familiar with that pattern :)
18:58:17 <Cale> jwingfi: I've done this transformation by hand in order to understand screwy C programs'
18:58:22 <vermeille> (my bad, it's in the evaluator)
18:58:47 <Cale> The advantage being that while you end up with a horrible functional program at first, you can then algebraically simplify it using equational reasoning
18:59:01 <Cale> and eventually end up with something that hopefully you can understand what it does
18:59:18 <athan> is an exception like a maybe, but for any evaluation?
18:59:31 <Cale> athan: exceptions are mainly for IO
18:59:35 <vermeille> Eduard_Munteanu: is that kind of parsers considered bad style in Haskell?
18:59:36 <athan> what kind of vodoo is behind exceptions... (if any)?
18:59:42 <Cale> (you can only catch them from IO)
18:59:46 <jwingfi> cale: heh. procedural code with lots of mutation gets hairy quick
18:59:47 <athan> ahhhh
18:59:47 <athan> okay
18:59:49 <athan> awesome
19:00:31 <athan> Cale: What about `head []`?
19:00:33 <Cale> athan: Look in Control.Exception. The exception system is actually rather nice in terms of extensibility
19:00:34 <athan> > head []
19:00:35 <lambdabot>  *Exception: Prelude.head: empty list
19:00:39 <Eduard_Munteanu> vermeille: I'd say there are better ways to do it
19:00:52 <athan> Cale: Yeah I'll have to
19:00:54 <Cale> Yeah, if an exception is thrown by evaluating an expression, you shouldn't even try to catch it.
19:01:00 <Cale> It's theoretically possible, but it's fiddly
19:01:15 <athan> it's like accounting for _|_
19:01:21 <Cale> right
19:01:22 <athan> which should never exist
19:01:24 <athan> awesome
19:01:37 <dwcook> Cale, I'm aware of it being possible with threads, is there another way?
19:01:49 <athan> i still feel like it's important to recognize
19:01:53 <dwcook> Well, feel free to ignore my question if you think it would confuse someone :)
19:01:54 <Cale> dwcook: Catching exceptions from pure computations?
19:01:55 <athan> due to errors liek those
19:01:58 <athan> within large projects
19:02:03 <athan> of many sources of input
19:02:17 <dwcook> Cale, well, if undefined is evaluated on a particular thread, that thread will crash, no?
19:02:33 <Cale> dwcook: You typically use Control.Exception.evaluate to try to force the evaluation to occur within the execution of a given IO action, and use catch
19:02:37 <haasn> But uh
19:02:47 <athan> ahhhhhh
19:02:53 <haasn> λ trying id (return $! undefined)
19:02:55 <haasn> Left Prelude.undefined
19:03:04 <dwcook> Got it. I've never tried anything of the sort, thus why I didn't know the "proper" way :P
19:03:06 <Cale> (but if you have to do that, it's horrible, and something has already gone wrong in the design of your libraries)
19:03:09 <Eduard_Munteanu> vermeille: why not do it in two passes of Parsec?
19:03:29 <athan> :t trying
19:03:30 <lambdabot>     Ambiguous occurrence `trying'
19:03:30 <lambdabot>     It could refer to either `Control.Exception.Lens.trying',
19:03:30 <lambdabot>                              imported from `Control.Exception.Lens' at /home/lambda/.lambdabot/State/L.hs:39:1-29
19:04:00 <athan> that's beautiful
19:04:06 <athan> that's a prism, no, haasn?
19:04:17 <vermeille> Eduard_Munteanu: 'cuz I have not learnt about Parsec yet
19:04:20 <Zekka> Greetings, folks -- I wanted to sequence actions which have multiple possible random outcomes when I'm already in StateT SomeType Identity -- is there a particular monad transformer I should use for this? I was thinking FreeT []
19:04:31 <haasn> :t Control.Exception.Lens.trying -- athan
19:04:32 <lambdabot> MonadCatchIO-transformers-0.3.0.0:Control.Monad.CatchIO.MonadCatchIO m => Getting (First a) SomeException a -> m r -> m (Either a r)
19:04:34 <haasn> also
19:04:40 <haasn> λ trying _ErrorCall (return $! undefined)
19:04:40 <Cale> Zekka: Perhaps RandT
19:04:42 <haasn> Left "Prelude.undefined"
19:04:44 <haasn> interesting!
19:04:45 <Zekka> I have a feeling that someone else has already come up with something way more speciic to what I want, though
19:04:59 <haasn> RVarT ?
19:05:09 <Zekka> Cale - I should clarify, I don't actually want to generate random  values
19:05:12 <athan> wow
19:05:43 <Zekka> I want to analyze the resulting group of random values after sequencing a bunch of operations that work with random values
19:05:51 <Zekka> er, not random values, really
19:05:59 <vermeille> Hum, what kind of parser is used internally in GHC?
19:06:01 <Cale> hmm
19:06:13 <Zekka> I can write a description if you'd like, although I have a feeling it looks a lot like nondeterminism with lists except I might be using a homemade functor that describes weighted randomization
19:06:25 <Cale> vermeille: I believe it's one that gets generated by happy
19:06:33 <geekosaur> ghc uses happy for parsing
19:07:05 <Cale> Zekka: Maybe WriterT (Product Rational) []  is something like what you want
19:07:15 <vermeille> happy is so much better to use than yacc/bison...
19:07:24 <Zekka> Cale - That might be right, let me do a little googling
19:07:30 <Cale> er, heh, "Maybe" was just part of my sentence there of course, not part of the type :)
19:07:35 <Zekka> Yeah, I got that.
19:07:37 <Eduard_Munteanu> vermeille: Parsec can easily make an expression parser for you
19:08:14 <Cale> Zekka: If you want to use that to compute probabilities, you'll need to define some operation to "collect like terms"
19:08:31 <vermeille> Eduard_Munteanu: is there a good tutorial for it? I was not amazed by what Real World Haskell explained to me
19:08:38 <Cale> Zekka: which I usually end up writing via Map.fromListWith
19:08:49 <haasn> I wonder how the various parsers would compare in terms of performance, parsing haskell source code
19:09:03 <Zekka> Cale - I haven't, but I might write out a list of operations I'd like whatever I'm working under to support.
19:09:07 <Zekka> Do you think that would help?
19:09:10 <haasn> has anybody done this kind of evaluation and posted the results somewhere?
19:09:32 <Zekka> Obviously I wouldn't mean that I want exactly those specific operations but I'd want an environment where they'd be natural to define
19:09:50 <Cale> yes, that always helps
19:11:00 <Cale> Zekka: a lot of functional programming comes down to writing such lists of operations and then seeing if you can think of ways to define them all from some simpler list of operations :)
19:11:39 <Zekka> Just now I'm actually rewriting a program that turned into hell because I decided I'd be clever and just define everything so discretely I wouldn't need any intermediate layers of abstraction
19:11:45 <Cale> (until you ideally eventually end up with a handful of operations all of which are pretty trivial, but with which you can express everything you're interested in)
19:11:50 <Zekka> which worked fine until something that should have been trivial took 20 lines of ugly code to explain
19:13:56 <vermeille> What do you guys think about FPcomplete?
19:14:42 <Cale> vermeille: The stuff they do is generally pretty good, but I find their marketing really grating at times.
19:14:44 <Eduard_Munteanu> vermeille: hm, dunno of a good Parsec resource
19:14:46 <Welkin> they have some videos on youtube
19:14:54 <Welkin> I found them pretty boring
19:15:04 <Welkin> the person talking seemed disengaged
19:15:49 <Welkin> vermeille, I'd recommend LYAH
19:17:04 <Eduard_Munteanu> vermeille: this looks good, but it's for Attoparsec (which in some ways is easier to use): http://michaelxavier.net/posts/2012-01-20-Writing-a-Small-Parser-with-Attoparsec.html
19:17:17 <vermeille> IMHO the IDE is really awesome to use, but yeah, disabling git in the free offer just sucks (the tool which just suggest you how to improve your code is SO AMAZING, "hey dude, don't write `concat . intersperse " "`, use `unwords` instead O_O)
19:17:45 <Cale> vermeille: That's just hlint I believe
19:17:55 <Cale> (it's freely available from hackage too)
19:18:32 <Zekka> Cale - This untested code seems pretty close to what I wanted
19:18:36 <Zekka> http://pastebin.com/jpm587Y4
19:18:46 <vermeille> Oh goddam :D I assumed it was some proprietary stuff :D someone should integrate that in Leksah :D !
19:18:46 <bodie_> anyone played with Rust and/or have any thoughts on it other than "its definition is unstable"?
19:19:00 <vermeille> bodie_: I did in the past few weeks
19:19:00 <Zekka> hold up, actually
19:19:06 <Zekka> it passed the linter but it passes with a parse error
19:19:15 <Zekka> let me check if I did anthing fundamentally wrong
19:19:28 <geekosaur> hlint doesn't check syntax
19:19:29 <Zekka> I thought I had gotten arrows right on the first try een though I don't know very much about them
19:19:31 <geekosaur> much
19:19:39 <bodie_> vermeille, thoughts off the top of your head vs your experiences with haskell?  i'm considering taking some time to learn one or the other
19:19:47 <Zekka> Let me clarify, my editor plugin didn't complain at me, but when I try to load my module in GHCi it fails with a parse error
19:20:23 <startling> bodie_: they are very different languages.
19:21:00 <startling> They have a common goal ("safety", I guess) but they're approaching it from different places entirely.
19:21:23 <bodie_> hmm
19:21:37 <startling> If you know an imperative language already, Rust won't be very hard to learn. Haskell's learning curve otoh can be very steep.
19:22:19 <bodie_> I have enough imperative languages under my belt, that's kinda the idea here
19:22:35 <Cale> bodie_: In my entirely biased opinion, pick Haskell, I don't think you'll regret it :)
19:22:38 <bodie_> I was actually leaning toward clojure, but my ramblings have led me in this direction :)
19:22:54 <vermeille> bodie_: I'm mainly a C++ guy, so, from a C++ point of view, it's really really amazing: safety, efficiency, really good design, algebraic datatypes and pattern matchig <3 \o/. From a Haskellish point of view, well, it's less fun, looks like a C++-oriented OCaml: no purity, no monad (*you can't chain operations on Options like a Maybe would* :( ) but yeah, it's worth it since I think it's the future :D
19:22:57 <bodie_> I definitely see the utility of Haskell
19:23:20 <bodie_> I see :) yeah I have very very high hopes for Rust as well
19:23:24 <Cale> If you know Haskell, those other languages will be easy. I'm not sure about the other way around.
19:23:42 <startling> Clojure was pretty easy to learn already having learned Haskell.
19:23:48 <vermeille> bodie_: me too. I even would like to do my upcoming internship at Moz to work on it!
19:23:49 <startling> (And Scheme, admittedly).
19:23:51 <bodie_> I really hope they can stabilize it and get some community rolling.  that seems to be the primary hurdle in approaching it, since it's hard to learn by example when the examples don't work.
19:24:07 <startling> bodie_, I think it's the last thing on their list.
19:24:26 <startling> Having a big community means that more people will be annoyed when you changed things.
19:24:28 <vermeille> bodie_: go talk with them on IRC, they will give you some information about their milestones
19:24:31 <bodie_> well, that could make it or break it.  I guess perfect is the enemy of good.
19:24:46 <startling> I'm not sure that's true, for programming languages.
19:24:50 <bodie_> I have had a few chats with them.  I'm probably going to take interest in a year or two if they don't die out.
19:24:56 <bodie_> hm
19:25:00 <Cale> Haskell is approaching the point where it's too stable for me to continue being interested in it actually
19:25:11 <startling> Yeah, I can see that.
19:25:16 <bodie_> that seems a little silly considering that C is still one of the most interesting languages ;)
19:25:22 <bodie_> (in my eyes)
19:25:23 <Cale> C is not interesting at all
19:25:26 <Cale> (to me)
19:25:47 <Cale> It's old and suboptimal for almost everything
19:25:57 <zRecursive> But C support the whole IT world :)
19:26:04 <startling> C is interesting in the same way that Latin is interesting.
19:26:09 <Cale> LLVM beats it at a lot of the things it would otherwise be good for
19:26:21 <bodie_> vermeille, enjoy that internship.  I think that will be awesome!  I hope you get to really get your hands Rusty.  :P
19:26:43 <startling> Maybe that's optimistic of me. C is interesting in the same way that English is interesting. :)
19:26:45 <Cale> (and if you're writing it by hand, well, have fun :)
19:27:02 <bodie_> haha ^ yeah, I don't do that any more.  I haven't even touched it for ages.  but it's still interesting
19:27:08 <Cale> *Perl* is interesting in the same way that English is interesting.
19:27:23 <bodie_> Perl is dirty... lol
19:27:27 <Cale> Exactly
19:27:37 <zRecursive> No any other language can beat C, because it is a middle level language(even low level)
19:27:38 <bodie_> :D
19:28:27 <Cale> Yeah, C is too high level to be a really great compiler target, and lacks most of the features you'd expect for something that you'd write by hand.
19:28:49 <heatsink> C-- never took off, and I haven't heard anything about Pillar since that one paper
19:29:22 <GoshaZa> So apparently using -fPIC and -dynamic worked... No idea why http://pastebin.com/aBPLJyKc I'd love some feedback on this..
19:29:47 <GoshaZa> Test.hs is just main = putStrLn "hello"
19:29:47 <bodie_> welp, thanks for the chit chat all
19:29:51 <Welkin> zRecursive, asm beats C
19:30:16 <Welkin> C compilers have been heavily optimised for decades
19:30:21 <zRecursive> Welkin: C is indeed asm itself
19:30:22 <Welkin> it has nothing to do with the language itself
19:30:22 <startling> bodie_: anyway, I think most of us here would recommend Haskell. We could point you to some learning resources, if you're interested.
19:30:45 <Welkin> haskell's ghc has been heavily optimised as well and it comes very close to matching C
19:31:09 <haasn> [citation needed]
19:31:15 <bodie_> if there's one thing I'm good at, it's learning.  that's kind of the problem.  I want to pick something and really stick with it long enough to get ridiculously fluent.
19:31:16 <Sculptor> well, unless you shoot yourself in the foot
19:31:28 <bodie_> so, naturally I want that thing to be the right thing ;)
19:31:39 <stolaruk> bodie_: Haskell will take time and dedication to get really "fluent." There is a lot to learn
19:31:41 <bodie_> I've been playing with Go but it's pretty clumsy in some ways.
19:31:45 <no-n> http://lpaste.net/1877417753694961664 <- will fromServer (line 14) be re-constructed on each call to eval? what if I define it at top level?
19:31:52 <haasn> stolaruk: depends on how many language extensions you want to include
19:32:03 <bodie_> nice language but I think I am looking for a good fp brain bender.
19:32:17 <Cale> It's 2014, we've known how to implement first class functions on stock hardware *well* for at least, what? 20 years now? Perhaps longer depending who you ask. We've known about their importance to abstraction in computation for longer than digital computers have existed. There's not really any excuse to be using a language without them.
19:32:18 <stolaruk> Well if you want to learn how to use all the nifty libraries, gosh it will take time
19:32:19 <haasn> go is not a language I'd consider mature
19:32:48 <Zekka> Cale - This is the monad I was hoping for: now that I've defined it, do you have any idea who's defined a better version already that's linked to theory? http://pastebin.com/P0y7jzD1
19:33:03 <Zekka> also, forgot to use lpaste, sorry about that
19:33:08 <Welkin> the old C vs Lisp debate
19:33:10 <stolaruk> Lately I've been feeling a bit overwhelmed at how many libraries there are to learn
19:33:24 <Cale> Here's my experience with go:  Step 1) Check whether a standard polymorphic 'map' function is writable. Step 2) Realise that it's not and ditch the language.
19:34:06 <zRecursive> Go syntax is ugly :)
19:34:10 <Welkin> true
19:34:12 <heatsink> It's weird how many languages you can't write a generic map in
19:34:17 <haasn> I think it was ‘sort’ for me, but the procedure was similar.
19:34:25 <stolaruk> bodie_: If you want a fp mind bender then look no further than Haskell
19:34:27 <Cale> Whether or not you can write a polymorphic 'map' is a really good razor for determining if a language is worth looking at.
19:34:33 <Zekka> This is excluding an operation that converts a [Result a] into a RandomResults, which is trivial, and probably a few others I'm forgetting
19:34:41 <Cale> If you can't write one, it has a horrible type system which will get in your way.
19:34:46 <Zekka> By the way, I'm a little bit of a novice but let me throw my recommendation for Haskell in too
19:34:46 <haasn> My language razor is “whether or not you can implement lens”
19:34:53 <Cale> haasn: :)
19:34:59 <haasn> no, seriously
19:34:59 <Zekka> it's a lot of fun and it's not as hard as everyone says
19:35:01 <orzo> I have an annoyance with an algebriac data structure that takes 3 type parameters.  I want to declare an instance of Functor that uses the middle parameter, rather than the last.  Is there an idiom for this?  I cannot do a partial type application
19:35:25 <Cale> haasn: I don't doubt it, though that's a much larger undertaking to use as a test.
19:35:25 <edwardk> Cale++
19:35:26 <haasn> orzo: newtype Flip f a b = Flip { flop :: f b a }
19:35:31 <heatsink> ^
19:35:35 <startling> orzo, you can do newtype Reordered a b c = Reordered (MyType a c b)
19:35:37 <edwardk> your reasoning about go is pretty much what happened with me
19:35:38 <startling> yeah
19:35:38 <haasn> orzo: that's pretty much the only thing that really comes to mind
19:35:52 <edwardk> i realized i couldn't write any function i wanted to write in go and tossed it in the rubbish bin
19:36:04 <haasn> Cale: unless it's an esolang, in which case it's probably interesting for other reasons
19:36:05 <startling> orzo: if it's a functor on the last parameter, too, you might look at bifunctors
19:36:11 <orzo> haasn: unfortunatley, that means changing a lot of code t use a different type.  It's really lame to have to change the name simply because the type paramter wasn't last
19:36:12 <stolaruk> I haven't heard anyone say anything good about go, other than it has a cute logo
19:36:14 <startling> orzo: you also might want to reorder your parameters
19:36:24 <Zekka> I might just use the monad I defined in the pastebin, but my gut is that there's a theoretical one that's way closer to what I actually want
19:36:24 <haasn> orzo: you could use a Setter.
19:36:39 <hiptobecubic> edwardk, I believe their answer to "Where are the generics?" is "No one needs them anyway."
19:36:46 <haasn> unless you're working with library code that needs a Functor instance
19:37:03 <haasn> “we have coercion and type branching, who needs generics??”
19:37:15 <tapuu> I need a good way of updating a value in a havily nested record type without modifying the datatype definitions
19:37:24 <startling> tapuu, lenses
19:37:25 <edwardk> hiptobecubic: dunning-kruger FTW
19:37:27 <roboguy_> is there any type of kind * -> * that doesn't have a Functor instance *and* doesn't have a Contravariant instance?
19:37:27 <orzo> startling: my situation is this, i used to have a recursive data structure that represents a tree.  it implemented Functor on the last argument.  But I had reasons to switch to use Data.Fix to transform a non-recursive type, now I can't declare Functor.
19:37:38 <edwardk> roboguy_: yes
19:37:45 <hiptobecubic> edwardk, it strikes in the most frustrating places.
19:37:47 <roboguy_> other than because of constraints?
19:37:57 <edwardk> newtype Endo a = Endo (a -> a)
19:38:00 <edwardk> start there
19:38:23 <edwardk> roboguy_: you can also get stuck there because of GADTs
19:38:29 <orzo> haasn: see my note to startling for my specific context
19:38:44 <roboguy_> edwardk: hmm, I didn't think of that
19:38:55 <edwardk> go would be a perfectly good language if this was 1968 =)
19:39:02 <hiptobecubic> ouch
19:39:04 <startling> orzo, can you paste it?
19:39:46 <Zekka> Anyone look at the code I pasted earlier? Sorry to be pushy, I just don't want to get stuck with a definition that's less useful than some conventional one
19:40:23 <roboguy_> so many languages have weak and ugly generics (if they have them at all). I remember a few years ago talking to java programmers who thought that they were totally unnecessary (this was before java got them)
19:40:25 <startling> Zekka: I missed it
19:40:35 <haasn> I think I've heard tapuu's exact question before in some lens talk, except instead of “I need a” it started with “lens is”
19:40:51 <c_wraith|N10> Zekka: looks like a standard probability monad.
19:40:51 <vermeille> bodie_: so yeah, try Rust, and... there are a lot of things to do for the community! (Like a good Http library :D)
19:40:56 <edwardk> haasn: hah
19:41:02 <Zekka> c_wraith - I figured it was such a common problem
19:41:03 <heatsink> Zekka: It looks like a composition of [] and Writer
19:41:06 <Zekka> startling - http://lpaste.net/101989
19:41:12 <stolaruk> Has attoparsec made parsec somewhat obsolete?
19:41:19 <tapuu> defining lenses is tiresome, I was really hoping there would be some kind of syntactic extension by now
19:41:32 <Zekka> heatsink - Someone suggested Writer (Product Rational) [] earlier, but I haven't tried it
19:41:35 <hiptobecubic> tapuu, programming is tiresome
19:41:40 <haasn> orzo: again, you might be able to get a nice API using lens' Setter, which is like a generalized Functor that can work on monomorphic or unusually ordered types
19:41:40 <heatsink> ok
19:41:42 <edwardk> tapuu: there is template haskell for it, an support going in ghc 7.10 for something more
19:41:43 <c_wraith|N10> Zekka: there are others on hackage. I don't remember package names, though.
19:41:50 <bodie_> the problem there, vermeille -- and I might get involved with Rust, time permitting -- I'm looking for something I can actually be productive with and rely on
19:41:57 <haasn> orzo: Setter (Foo a s) (Foo b s) a b
19:42:00 <Zekka> I got sidetracked while looking up some of the details of the types and decided to quickly hack out a description of my own
19:42:04 <startling> tapuu, you can use TemplateHaskell?
19:42:26 <bodie_> so, things like Haskell and Clojure beat things like Scheme, for example
19:42:42 <no-n> http://lpaste.net/1877417753694961664 <- will fromServer (line 14) be re-constructed on each call to eval? what if I define it at top level?
19:42:45 <tapuu> startling, edwardk: I might be wrong but it seems like templatehaskell for lesnes requires field names to begin with udnersores, which I don't have...
19:42:46 <haasn> > 37 + 25
19:42:46 <bodie_> since the tooling and community are there
19:42:47 <lambdabot>  62
19:43:05 <edwardk> tapuu: you can use makeLensesWith to change the convention
19:43:08 <tapuu> Wow my typing is bad
19:43:11 <no-n> brb
19:43:19 <tapuu> edwardk: Thanks, I'll try that
19:43:20 <startling> @unmtl WriterT [] a
19:43:20 <lambdabot> Plugin `unmtl' failed with: `WriterT [] a' is not applied to enough arguments, giving `/\A. a (A, [])'
19:43:29 <startling> @unmtl WriterT [] Rational a
19:43:29 <lambdabot> Rational (a, [])
19:43:36 <edwardk> https://github.com/ekmett/tables/blob/master/examples/Foo.hs#L35 uses it to put _'s on the end for the lenses it makes
19:43:43 <startling> @unmtl ListT (Writer Rational) a
19:43:43 <lambdabot> (Writer Rational) ([] a)
19:43:47 <edwardk> makeLensesWith ?? ''Foo $ defaultRules & lensField .~ \x -> Just (x ++ "_")
19:44:00 <edwardk> lensField lets you supply whatever convention you want
19:44:02 <startling> er
19:44:19 <vermeille> bodie_: I chose to learn Rust exactly for that. I'm really bored with C++ (which sucks more and more), and I had to choose a new daily language. I just picked Rust (because it's closer to C++ and my Haskell skills sucks), and I think it's worth it. If you find a bug of something disturbing, just say it on IRC, it will be corrected quickly, etc.
19:44:25 <haasn> now I know why (??) is in lens
19:44:31 <startling> @unmtl WriterT Rational [] a -- Zekka
19:44:31 <lambdabot> [] (a, Rational)
19:44:33 <edwardk> haasn: =P
19:44:44 <orzo> startling: http://lpaste.net/101990
19:44:56 <startling> Zekka: WriterT (Product Rational) [] a is that, I think
19:45:02 <vermeille> bodie_: if you don't have anything to blame Haskell for, no language will be appealing enough for you to learn
19:45:12 <bodie_> Well, I think Rust will really kick C++ ass when it stabilizes, but you have to admit C++ has a vast ocean of resources already in existence, while Rust is very much a new frontier
19:45:15 <edwardk> @quote Fuuzetsu lens
19:45:15 <lambdabot> Fuuzetsu says: I know someone who pulls in Lens just for & and ??
19:45:32 <haasn> :)
19:45:33 <bodie_> which is awesome, but not everyone wants to die of dysentery
19:45:36 <Zekka> startling - Going to implement a test program with it.
19:45:43 <hiptobecubic> bodie_, that is one of many reasons why Rust will *not* kick C++'s ass, unfortunately.
19:46:09 <bodie_> well, right, it's facing the bootstrap problem
19:46:15 <startling> orzo: ah, yes, use Bifunctor
19:46:21 <vermeille> bodie_: you could have said that some years ago, when C++ was a newcomer and everybody was programming in Fortran and Cobol :)
19:46:22 <bodie_> if they successfully boot the community, then it'll be great
19:46:56 <startling> orzo: I think you could write it with Free and get some nice instances
19:47:01 <bodie_> well...and at that time, the argument to use fortran and cobol would be a strong one
19:47:04 <edwardk> rust is something close to what i want in a systems language, but it is just subtly off kilter from what i'd really want to be able to use it. no real parametric polymorphism means you can't do polymorphic recursion, and since everything can template specialize you always have to worry that it might.
19:47:09 <haasn> what happens when Haskell stops avoiding success at all costs?
19:47:28 <edwardk> haasn: well, we're slowly finding out =P
19:47:36 <stolaruk> ^^ true
19:47:47 <bodie_> I don't think Mozilla will succeed with Rust, sadly.
19:47:50 <Cale> haasn: It becomes more inflexible to change
19:48:01 <bodie_> but I really want them to.
19:48:04 <haasn> and hackage becomes flooded with low quality libraries?
19:48:15 <Cale> Possibly
19:48:27 <hiptobecubic> haasn, hopefully. That's a good sign.
19:48:38 <startling> haasn, "the python paradox" is a similar idea
19:48:40 <vermeille> bodie_: why that?
19:49:12 <bodie_> mostly the things I've mentioned -- it can't really compete for the attention of the community it'll need to succeed on the open-source market of tools, imo
19:49:15 <orzo> startling: Free?
19:49:29 <startling> orzo, http://hackage.haskell.org/package/free-4.6.1/docs/Control-Monad-Free.html
19:49:41 <bodie_> we'll see once it stabilizes
19:49:49 <Cale> The language I really want to be programming in right now doesn't yet exist
19:49:58 <startling> orzo, data Free f a = Pure a | Free (f (Free f a))
19:50:03 <bodie_> and what language is that :)
19:50:14 <Cale> bodie_: A practical extension of homotopy type theory
19:50:16 <hiptobecubic> Choosing a "Project category" from the list is hopelessly difficult.
19:50:18 <startling> orzo, (i.e. it takes care of your Value already)
19:50:28 <haasn> Cale: the language I want to be programming in right now does exist, but no compiler is smart enough to interpret it
19:50:49 <vermeille> bodie_: I think you're wrong. C# have done it, go will maybe make it too, and Hack will certainly. They just need some major actors to support them (in terms of proof, "advertisement" etc) MS for C#, Google for Go, FB for Hack, what can go wrong with Moz :)?
19:51:16 <Cale> with higher inductive types and computational univalence :)
19:51:16 <startling> I'm not sure about Hack.
19:51:31 <Cale> (along with all the usual things that we take for granted in Haskell)
19:51:48 <vermeille> startling: why?
19:52:10 <startling> vermeille, it has almost all the downsides of PHP with almost none of the benefits.
19:52:17 <bodie_> I don't think Rust is at all a good comparison to those other languages
19:52:25 <orzo> startling: interesting, thanks
19:52:41 <bodie_> Go is slightly comparable in that it has a similar mission, but if anything Go's existence is another nail in Rust's coffin
19:53:15 <MP2E> Eh, I don't see how Go can really compete with Rust. All of its ideas were dated in 1980
19:53:17 <startling> bodie_: I don't think Go's and Rust's "target demographics" are very similar.
19:53:19 <orzo> startling: I do implement Monad though, and it does more work than i suspect Free does...
19:53:22 <MP2E> it doesn't really *push the bar* anywhere
19:53:31 <startling> orzo, no, Free gives you a Monad instance for free. :)
19:53:33 <bodie_> MP2E, you're thinking like a haskeller :P
19:53:49 <MP2E> True :P
19:53:59 <MP2E> FP is taking over my brain, it is a wonderful process
19:54:02 <bodie_> the objective quality of the language doesn't have as much bearing on its market potency as its ... well. marketability
19:54:05 <vermeille> startling: who cares? Fb just needs to make it trendy (and, well, I worked at Facebook, I talked with people using Hack (I was using C++), and they didn't build it just for fun). The static type checking feature is a *great* add to php
19:54:22 <bodie_> startling, obviously :) I just hope people see the utility in switching to Rust from C++.
19:54:33 <startling> bodie_: yeah, I guess so.
19:54:38 <Cale> I honestly don't care what language everyone else programs in
19:54:39 <orzo> startling: Yes, but I have my own Monad instance... my tree represent a polyhedron as a bsp tree and my bind does a set-and operation on the polyhedron and trims the tree using linear programming.  Is Free still appropriate?
19:55:03 <Cale> So long as there are sufficiently good languages which I can insist on.
19:55:18 <haasn> are Monad instances unique?
19:55:18 <startling> orzo: I think your Monad instance probably breaks a law, then
19:55:25 <haasn> I feel like I've asked this before.
19:55:25 <bodie_> that's kind of an interesting point (startling) though since Go's actual market downside is that C++ programmers aren't hopping on.
19:55:29 <startling> I may be wrong, though
19:55:31 <haasn> I think the answer may have been “yes”
19:55:34 <orzo> startling: i dont know why you say that, i assure you that it does not
19:55:36 <Cale> haasn: no, but they're kind of sparse
19:55:44 <Cale> haasn: It's hard to screw them up, usually.
19:55:58 <bodie_> Cale -- so you always work on projects which can be accomplished by a single individual on whatever platform he chooses?
19:56:07 <startling> orzo: ok! I can't tell you without seeing your instance.
19:56:20 <startling> orzo: in general things that look like trees can be written nicely with Free.
19:56:21 <Cale> bodie_: Or a small group of like minded ones
19:56:23 <vermeille> bodie_: the process will be faster now that C++ "evolves" very quickly, everybody will see it becoming more and more error prone, complicated, etc (that's the main thing which makes me abandon C++)
19:56:27 <athan> we should use the haskell type system to somehow make a robot that can polymorphically pick up and sort any kind of trash
19:56:47 <haasn> Cale: my main issue with “what the rest of the world works” is that I often want to contribute to software I use which is not written by me
19:56:54 <bodie_> yes, I am shocked that they are already talking C++14 since I don't think anyone has even implemented c++11 yet.
19:57:05 <Cale> bodie_: I still don't 100% consider myself a programmer, so much as a mathematician who has taken programming jobs to make money.
19:57:17 <hiptobecubic> athan, i love when people do that.
19:57:19 <bodie_> haasn, and I am the flip side of that -- I like using software which already exists since reinventing the wheel is for chumps ;)
19:57:19 <Cale> bodie_: I could probably do other things if it really came down to it.
19:57:21 <vermeille> bodie_: wrong, g++ and clang fully support C++11 and clang already supports C++14
19:57:25 <startling> orzo: anyhow, Free "derives" a Monad instance from the original types Functor instance; I think your Functor instance can do the trimming
19:57:26 <haasn> and my ability to contribute is limited primarily by how comfortable I am using that language, and modulated by how enjoyable it is to use that language
19:57:30 <startling> orzo: (and if it doesn't it breaks a law)
19:57:45 <Cale> bodie_: So, I only take jobs which are favourable to me (mostly in Haskell)
19:57:55 <bodie_> vermeille, really.  interesting -- I thought it wasn't quite there yet.  that's great!  But I agree, they shouldn't be adding more and more features when it's already a ridiculously complex platform.
19:57:59 <haasn> bodie_: I'm not sure how that disagrees with what I said
19:58:02 <Cale> I haven't found that there's much shortage of them
19:58:07 <athan> hiptobecubic: I'm trying to write an optimal reforestation seed / plant placement algorthm, ideal for each ecological rejion, soil type, climate, and other stuff :)
19:58:19 <athan> region*
19:58:19 <bodie_> it doesn't disagree, I'm just saying -- contributors feed people like me useful things to use :)
19:58:24 <nooodl> @hoogle Ix i => Array i e -> i -> Maybe e
19:58:25 <lambdabot> Data.Array (!) :: Ix i => Array i e -> i -> e
19:58:25 <lambdabot> Data.Array.IArray (!) :: (IArray a e, Ix i) => a i e -> i -> e
19:58:25 <lambdabot> Data.Array.MArray readArray :: (MArray a e m, Ix i) => a i e -> i -> m e
19:58:28 <hiptobecubic> People that say one crazy thing that barely makes sense and has no context at all, then disappear back into the darkness. :) Keeps life interesting
19:58:29 <nooodl> where's this :<
19:58:33 <bodie_> Cale, that's great
19:58:42 <athan> hahahahaha
19:58:46 <athan> YAYUH
19:59:00 <bodie_> one reason I've been shying away from Haskell is that I don't see it as a personally useful thing to have in my kit, beyond the mind expanding factor.
19:59:20 <startling> orzo: but I'm suspicious of how your Monad instance does trimming without Eq -- do you just mean that you trim branches that only contain Nil into Nil?
19:59:22 <hiptobecubic> bodie_, you might be underestimating the mind expansion a little, there.
19:59:22 <bodie_> now I'm looking at picking up Clojure because I think it'll be an extremely productive tool for a few personal projects.
19:59:23 <orzo> startling: you're assuming that Eq just does a plain comparison.  My trees are equivelent if they represent the same polyhedron, not that they are the same tree in memory
19:59:40 <startling> orzo, sure. I'd like to see your real code.
19:59:41 <bodie_> eh, mind expansion is probably my primary motivation for doing anything. at all.
19:59:54 <Cale> bodie_: The thing is, while there might not be as many Haskell jobs as Java jobs, the pool of programmers is also comparably smaller.
20:00:05 * dwcook sees C-style for loops in Go's documentation, closes it
20:00:21 <bodie_> right -- another downside for me, since I'm a newcomer to what's already a somewhat established community.
20:00:23 <ion> dwcook: Rust is decent.
20:00:27 <Welkin> I used to think haskell was good as an academic exercise, but I have realized that it is more than that and I have decided to make it one of my primary languages
20:00:34 <bodie_> interesting
20:00:34 <vermeille> bodie_: the major thing with Haskell is not haskell. It just makes you think another unusual way, which will be useful in your job, whatever the language is. Linq is a monad under the hoods, Linq is awesome
20:00:44 <orzo> startling: to avoid Eq, i used makeStableName
20:00:46 <hiptobecubic> Cale, who cares about numbers? Find me a haskell job that people think "sucks", then find me a java one that people don't.
20:00:50 <ezrios> vermeille: I second that
20:01:00 <orzo> on the values in the monad
20:01:00 <dwcook> Oh heh, I was paged up a ways
20:01:02 <athan> linq?
20:01:05 <Cale> hiptobecubic: Indeed!
20:01:12 <ezrios> I was learning how promises worked in JavaScript when someone came up to me and said, "they're almost like monads, read this"
20:01:16 <ezrios> and it instantly made them click for me
20:01:21 <bodie_> I expect there are a very great many fewer sucky Haskell jobs than sucky Java jobs.  proportionally speaking
20:01:31 <athan> woah
20:01:33 <startling> orzo, hm, I'm not sure I follow.
20:01:41 <heatsink> athan: http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.118.2025
20:01:44 <Welkin> haskell is used heavily in financial companies
20:01:47 <copumpkin> Cale: when are you coming to the US, anyway?
20:01:51 <hiptobecubic> bodie_, honestly I haven't actually seen any yet. I'm sure they're out there somewhere.
20:02:03 <startling> orzo: oh, I think I see.
20:02:09 <orzo> startling: if stables names are ==, then the original objects are.  So I do an often-right comparison to trim the tree
20:02:09 <startling> Well, maybe.
20:02:18 <bodie_> heh heh.  you mean companies don't hire people to debug and rebuild and support their crappy broken haskell?
20:02:22 <Cale> copumpkin: I dunno. Right now I'm on a train to Ottawa to help out an old friend of mine.
20:02:26 <vermeille> bodie_: well, who would make a sucky project with a technology with few developpers? They're more expensive to hire... nobody wants to pay a lot if it's not worth it
20:02:27 <bodie_> oh right, you CAN'T WRITE broken haskell
20:02:30 <copumpkin> Cale: ZOMG
20:02:31 <startling> orzo, right, but you can't write a Monad instance that requires Eq on the paramteter typw
20:02:55 <orzo> makeStableName works on any haskell type
20:03:11 <orzo> i compare stable names during tree trimming, i dont use Eq
20:03:16 <startling> orzo, oh, your (>>=) does makeStableName directly?
20:03:26 <orzo> yes
20:03:27 <Cale> WHEN ARE ALL THE HASKELL PEOPLE COMING TO CANADA?
20:03:33 <Cale> :)
20:03:36 <startling> orzo, your (>>=) does IO?
20:03:40 <orzo> yes
20:03:43 <dwcook> bodie_, depends on how you define "broken". It's definitely possible to write rambling monolithic do blocks that don't leave the intent clear, for example
20:03:50 <bodie_> heh
20:03:51 <vermeille> Guys, is there any good cheat sheet with all typeclasses and their laws? Didn't manage to find any
20:04:04 <bodie_> don't you have a magic wand that resolves that issue? ;)
20:04:05 <startling> vermeille, the typeclassopedia is kinda like that
20:04:05 <Cale> vermeille: Closest thing would be the typeclassopedia
20:04:20 <dwcook> bodie_, sure, it's called becoming a better Haskell programmer :)
20:04:32 <orzo> startling: actually, currently i have unsafePerformIO in there, but i figure i'l eventually fix it to be some kind of monad transformer
20:04:35 <vermeille> Hum okay, it's not strictly speaking a cheat sheet, but okay, I'll make my own
20:05:19 <bodie_> can't you just...  /wave hands mumble about monads and currying/
20:05:22 <startling> orzo, a better solution might be to have newtype Stabled a = Tree (StableName a) and then write your trimming (>>=) for that.
20:05:57 <vermeille> do you think that FP complete will manage to make industrial think a little more about Haskell?
20:06:04 <startling> orzo, then you can "(liftM Stabled $ traverse makeStableName myTree) >>= ..."
20:06:24 <startling> but again, I can't tell from your code.
20:06:34 <Cale> vermeille: Maybe, but some of the things which their CEO posts are pretty cringeworthy at times :)
20:06:37 <startling> orzo, and if you want Functor on the "middle", use Bifunctor
20:07:41 <orzo> i need the values
20:07:51 <Cale> (But the stuff they've been doing is in general pretty good in terms of providing support for the kinds of things people want to do with Haskell in industry.)
20:07:56 <orzo> maybe Tree (STableName a,a)
20:08:03 <orzo> so i can have the vlaues in the tree stil
20:08:04 <startling> orzo: yeah, that's doable
20:08:16 <stolaruk> vermeille: Check out here http://fundeps.com/posts/cheatsheets/2014-03-04-cheat-sheets/
20:08:57 <orzo> startling: but if i make my monad do IO, then i can fetch new stablenames and maybe notice when stablenames change and make identifications
20:09:06 <Cale> I believe their next thing is aimed at making Haskell even more attractive in finance, which I think is good. There are a lot of people in finance writing horrible C++ programs to handle one special case after another, and there are really good functional solutions to their problems.
20:09:24 <orzo> hm
20:09:47 <vermeille> stolaruk: really good. That's not what I was looking for (it does not show what are the *rules* of those typeclasses), but I printed it :D
20:10:01 <stolaruk> cool
20:10:09 <orzo> anyway, i have a version of >>= (under a differnet name) that does the trimming using Eq
20:10:18 <startling> orzo: makes sense
20:10:34 <stolaruk> vermeille: In that case making your own would be a good learning exercise, I did something like that a while back for personal use
20:11:39 <vermeille> I will make a talk about Haskell in my school, do you have any good talk / resource on which I could base my talk on?
20:11:57 <startling> orzo: anyway I'm not convinced StableName will do anything for you
20:12:06 <stolaruk> vermeille: Will it be an introductory talk?
20:12:10 <orzo> it lets me make a Monad instancde
20:12:21 <orzo> with trimming
20:12:27 <orzo> and the trimming is very important for my use
20:12:33 <vermeille> stolaruk: yep. They already know a little of OCaml, but never heard of Haskell
20:13:18 <startling> orzo, sure, I just mean that makeStableName on equal values doesn't necessarily make equal StableNames
20:13:28 <vermeille> I mean, they merely have understood what functional programming is, so this paradigm is not to explain
20:13:41 <stolaruk> vermeille: Here are the slides to a talk I recently gave at a hacker group. https://speakerdeck.com/lambdajam/yes-we-can-haskell
20:13:46 <stolaruk> Might be a useful reference
20:13:59 <stolaruk> The notes to my presentation are up there too
20:14:05 <Welkin> lambdajam sounds fun
20:14:44 <haasn> If I had to sell Haskell I might use ‘diagrams’ as an example
20:14:50 <orzo> startling: well i know, but often my my tree is built by operations on other trees that start off with simple ones, like "return a" so the exact same expression will likely end up at a lot of leafs, stablename should do a decent job
20:15:02 <athan> holy crap
20:15:17 <athan> do you think haskell could be described by a manifold?
20:15:19 <startling> orzo, hmmm
20:15:52 <startling> orzo: something like http://hackage.haskell.org/package/intern might be more reliable
20:16:06 <bodie_> "(in Kantian philosophy) the sum of the particulars furnished by sense before they have been unified by the synthesis of the understanding."
20:16:09 <bodie_> yes :P
20:18:07 <vermeille> stolaruk: haha, you are not totaly honest :D Your Java implem of qsort is in place, which is not the case with your Haskell version
20:18:50 <vermeille> (Did you show live Haskell programming during your talk? There is really few code on your slides, but a lot in your notes)
20:18:58 <stolaruk> vermeille: oh, yeah I just grabbed that Java code from the wikipedia article on quick sort. Didn't think much about it
20:19:19 <stolaruk> vermeille: Yeah I wrote a lot of code in SublimeText and in the REPL
20:19:27 <Welkin> java quicksort
20:19:29 <stolaruk> You will need the notes to follow along with the slides
20:20:28 <stolaruk> Originally when I gave the talk in front of some colleagues for practice they said first seeing a Java implementation of quick sort would have been helpful so I threw it in
20:20:34 <Welkin> did anyone complain that in haskell it is not in-place?
20:20:46 <stolaruk> no one said anything
20:20:59 <stolaruk> well actually at the talk someone asked if it was in place and I said no
20:21:02 <Welkin> that's a bad sign
20:21:10 <stolaruk> but that was the end of it
20:21:16 <Welkin> "any questions?" *blank stare*
20:21:24 * haasn wonders what the target age group for that presentation was
20:21:32 <bodie_> "did that make sense to everyone?"  *head nods with blank stares*
20:21:46 <stolaruk> haasn: Why bcus of the profanity? Just my sense of humor
20:21:47 <haasn> Welkin: I can't actually find the haskell version. is it the usual qsort lt ++ [x] ++ qsort gt ?
20:21:51 <Welkin> a lot of time when I have *too many* questions I don't ask any
20:22:08 <Welkin> yes haasn
20:22:09 <orzo> startling: i'm not sure i see how to use that intern package for this.  It wouldn't allow me to instantiate Monad because values you return into the monad would need to imlmeent Interned, right?
20:22:23 <vermeille> Actually you could have told them that you can make an inplace qsort with ST :D
20:22:28 <haasn> Welkin: then it's not qsort and I don't know why anybody ever decided to call it that
20:22:45 <vermeille> stolaruk: your talk is more about FP than Haskell in particular, at a first glance
20:22:47 <haasn> it's treesort.
20:22:54 <stolaruk> vermeille: Well I mentioned there are more efficient ways to sort.
20:23:10 <hiptobecubic> There some discussion in here about it. Deforested tree-sort I think was declared the best description
20:23:17 <stolaruk> vermeille: Yes I talked a lot about what FP is
20:24:01 <stolaruk> I had 2 hours
20:24:03 <stolaruk> hehe
20:24:26 <tapuu> These lens error messages are incomprehensible...
20:24:28 <haasn> I think if I saw that presentation I'd probably stay as far away from Haskell as I possibly could. Then again, that might be a good thing
20:24:32 <haasn> tapuu: which ones?
20:24:42 <tapuu> haasn: all of them :P
20:24:56 <edwardk> tapuu: ask for help as you go, eventually it becomes less inscrutable
20:25:02 <stolaruk> haasn: Well I got a lot of good feedback.
20:25:04 <edwardk> #haskell-lens is a good resource
20:25:08 <tapuu> I'm not asking for help, I just like to complain
20:26:24 <edwardk> fair enough. if you want constructive feedback, i'll listen. if not i'll go away ;)
20:26:24 <bodie_> tapuu++
20:26:24 <bodie_> oops, imperative style
20:26:24 * bodie_ runs away
20:26:24 <tapuu> bodie: not if you were using lenses
20:26:24 <haasn> tapuu += 1 -- Haskell style
20:26:24 <edwardk> haasn: =)
20:26:31 <tapuu> Oh wait, we dont have postfix functions do we
20:26:38 <Welkin> stolaruk, that slide deck is overloaded with memes
20:26:43 <haasn> there's -XPostfixOperators
20:26:45 <haasn> but you still have to section them
20:26:47 <stolaruk> Welkin: Yes it is
20:26:58 <vermeille> (what's the point with lenses? I can't understand what are they useful for)
20:27:07 <haasn> let (x++) = x += 1 in (foo++)
20:27:13 * hiptobecubic braces himself
20:27:31 <haasn> vermeille: every traversal you've ever written, buffed up
20:27:53 <ion> vermeille: Ever have a nested data structure and want to modify a value deep inside it?
20:28:15 <vermeille> ion: isn't what zippers stands for?
20:28:21 <Zekka> Anyone know how I can complete function 'uniform' here? http://lpaste.net/101993
20:28:39 <edwardk> vermeille: there is some overlap between the two concepts
20:28:42 <vermeille> (no, I never wrote some serious program in Haskell, I read more about it than I code)
20:28:49 <Zekka> It's basically 'show me how to do algebra with monad transformers'
20:29:22 <edwardk> vermeille: a lens lets you separate 'how to target parts of a structure' from 'what you want to do to them' in a way that lets you compose those references to parts of the structure.
20:29:25 <hiptobecubic> vermeille, zippers are more like having a 'cursor' that you move around
20:29:27 <tapuu> I'm going to bite the bullet and ask for help, this is too difficult
20:29:45 <vermeille> (Holy sh*t, last update for leksah was more than two years ago...)
20:29:50 <haasn> ever written a length, fold, map, sum, elem, head, tail, find, or toList function for any data structure ever?
20:29:56 <edwardk> tapuu: what are you trying to do?
20:30:01 <tapuu> Can anyone see anything wrong with this http://lpaste.net/101994
20:30:08 <hiptobecubic> vermeille, are you sure? I thought they were porting to gtk3 or something?
20:30:09 <haasn> tapuu: please post the error
20:30:30 <haasn> tapuu: maybe you meant pkgd & (foo.bar.bat.baz) %~ (+1)
20:30:34 <haasn> which incidentally is +~ 1
20:30:36 <edwardk> tapuu: let npkgd = pkgd & packageDescription_.package_.pkgVersion_.versionBranch_.element 4 +~ 1
20:30:39 <tapuu> The error is here http://lpaste.net/101995
20:30:52 <tapuu> What does & do?
20:30:58 <vermeille> edwardk: like `accessData = theField . goLeftSon . goLeftSon . goRightSon` (supposedly on a tree of records)
20:31:01 <ion> flip ($)
20:31:01 <haasn> (&) = flip ($)
20:31:02 <Zekka> tapuu - flip ($)
20:31:10 <tapuu> interesting...
20:31:35 <vermeille> hiptobecubic: on leksah.org the last update is in 2012, and on github... well... 5 years ago
20:31:35 <edwardk> tapuu: (foo +~ 1) becomes a function that takes a structure and modifes (all) foo fields to be 1.
20:31:38 <haasn> tapuu: (l %~ f) is itself a function
20:31:42 <edwardk> er by adding 1
20:32:04 <edwardk> so using & flips that around in a more readable style
20:32:15 <tapuu> That makes sense, ty
20:32:26 <edwardk> > ("hello","world") & _1 .~ 42 & _2 %~ length
20:32:28 <lambdabot>  (42,5)
20:32:29 <haasn> have you looked at http://lens.github.io/tutorial.html ?
20:32:38 <stolaruk> edwardk: Ever consider writing a book on Haskell
20:32:41 <edwardk> you can write several updates in a row that way
20:33:01 <tapuu> haasn: I seem to have looked at every lens tutorial except that one
20:33:21 <edwardk> stolaruk: it has come up a few times. then i watched all my friends who have written books and the misery it has brought them. ;) maybe some time when i'm less busy =)
20:33:31 <haasn> please don't write a book
20:33:35 <haasn> we don't want you to disappear from #haskell
20:33:43 <edwardk> yeah, we lost BONUS that way
20:33:46 <edwardk> and dons
20:34:03 <stolaruk> Is BONUS the author of LYAH?
20:34:07 <edwardk> bos comes around every once in while at least
20:34:13 <ion> Is BONUS active elsewhere?
20:34:28 <Zekka> Anyone see the question I asked previously? Gist is that I have a list that I need to somehow hoist into a ListT and then put that into a WriterT -- I have a feeling there are a few standard operations I should know that would make this straightforward
20:34:44 <haasn> (ListT?)
20:34:51 <Zekka> but since I don't know them it doesn't seem straightforward
20:34:53 <Zekka> haasn - Transformer for lists.
20:35:02 <haasn> where are you getting that from?
20:35:12 <edwardk> ion: well, he just got buried in his degree program after writing the book and as I understand it he didn't have much fun answering everyone's haskell questions after writing the book.
20:35:28 <ion> edwardk: ok :-\
20:35:38 <Zekka> haasn - I defined my monad as a transformer: type ProbabilityT m a = WriterT (Product Rational) (ListT m) a
20:35:43 <Zekka> and then defined an alias for that over identity
20:36:09 <Zekka> This was based on an attempt by the channel to approximate a type I wrote up manually without using transformers which I can pastebin again if you'd like
20:36:14 <haasn> I'm not up to speed on the details but I've heard a lot about a ListT and that it's horribly broken
20:36:18 <haasn> and that pipes apparently provides a lawful alternative
20:36:35 <Zekka> I'll check it out. The first thing I noticed with ListT is that it provided pretty much nothing in the way of useful operations
20:36:39 <Zekka> which made me think I was missing something
20:36:59 <haasn> anyway, as for your actual question - that is, hosting; you probably want something like ‘lift’
20:37:12 <tapuu> My program just destroyed an important cabal file :D
20:37:14 <haasn> if you can construct a ListT, you can use ‘lift’ to lift that into a WriterT
20:37:57 <haasn> Zekka: http://hackage.haskell.org/package/pipes-4.1.0/docs/Pipes.html#t:ListT this is the “ListT done right” I've been reading about
20:38:05 <Zekka> Will the WriterT use the identity element of my monoid?
20:38:15 <haasn> Zekka: for ‘lift’ and ‘return’, yes
20:38:33 <Zekka> If so, is there a standard way to not use the identity element or should I look into WriterT's provided functions?
20:38:59 <haasn> Zekka: simply  lift x >> tell m -- would achieve the correct result
20:39:03 <Zekka> I've actually got a table of weights and values I'd like to use (a list of associations as tuples)
20:39:14 <haasn> but you can of course use the “WriterT” constructor
20:39:16 <haasn> :t WriterT
20:39:17 <lambdabot> m (a, w) -> WriterT w m a
20:39:42 <vermeille> Haha, lenses makes Haskell look like a lot like imperative programming. The more I learn about Haskell, the more it seems that we try to make it look like that :D
20:40:01 <tapuu> Can a badly written lens somehow delete parts of a data structure?
20:40:03 <Zekka> vermeille - Lenses under State are pretty imperative
20:40:07 <haasn> vermeille: it can be fun at times but I think it leads to the same sort of code spaghetti unless you localize your algorithms well
20:40:14 <haasn> vermeille: I try to avoid it in serious code.
20:40:32 <haasn> as much unwanted attention as https://github.com/ekmett/lens/blob/master/examples/Pong.hs has generated :)
20:40:42 <edwardk> haasn: ahahhaa
20:41:42 <vermeille> haasn: wtttttttffffffffffff. I think 'import Java' is missing, it does everything under State ._.
20:41:44 <haasn> vermeille: of course, no imperative language will let you do “myFields.each += 1” to increment an entire list of values at once.
20:41:58 <haasn> okay, maybe some do :)
20:42:12 <haasn> as usual, haskell is better at imperative programming than imperative languages
20:42:24 <haasn> https://raw.github.com/mmirman/ImperativeHaskell/master/Main.hs
20:42:45 <stolaruk> vermeille: Hasn't SPJ said something to the effect of Haskell being a wonderful imperative langauge
20:43:22 <vermeille> haasn : std::foreach(std::begin(list), std::end(list), [](auto& i) { i++; });
20:43:40 <haasn> vermeille: myFields.each.each.both.each._1 += 1
20:43:44 <haasn> C++'s turn.
20:43:52 <ion> Not many languages let you just throw a dozen ‘print "hello"’s into a list, work on the list as with any list and choose to have zero or more of the actions executed.
20:43:53 <vermeille> =')
20:43:53 <Zekka> haasn -- Found a correct definition nd it was simpler than what I'd tried, thanks
20:45:46 <vermeille> haasn: is myFields a collection, or some separate values of different datastructures targetted all at once?
20:46:04 <haasn> vermeille: opts.each._Just.text._Enum +~ 1 -- for a less contrived but still hypothetical example!
20:46:44 <haasn> vermeille: in this example, ‘myFields’ would be a lens (from whatever the State monad parametrizes over) into some collection (that is an instance of Each)
20:47:45 <tapuu> writePackageDescription in Distribution.PackageDescription.Parse seems to be deleting half the description
20:47:51 <haasn> The code I most recently gave could represent a hypothetical scenario in which opts :: Lens' Structure [Maybe Text]
20:48:03 <vermeille> hmmmmmmmm ok. Doesn't it make it loose a lot the functional style that almost ensures you correctness?
20:48:10 <Zekka> the code that ended up working, for whoever's curious: http://lpaste.net/101996
20:48:11 <haasn> and we want to increment the numeric value of each character of each option that has a value associated
20:48:44 <haasn> vermeille: adding imperative flow certainly leads to the possibility of spaghetti code, yes
20:48:58 <haasn> vermeille: but lens single-liners tend to be highly compositional, in the usual FP style
20:49:46 <haasn> I just hope that lens will one day be integrated into GHC so I can use it in Haddock's code
20:49:51 <haasn> Maybe that should be a GSoC project.
20:49:54 <haasn> Lensifying GHC
20:50:11 <haasn> Something tells me the API could be reduced to about one third
20:50:17 <haasn> even including lens
20:50:18 <edwardk> heh, well, ermine is basically a compiler written in full on lens-style
20:50:24 <vermeille> Goddam, I would apply if I didn't have to go to shool >_<
20:50:41 <haasn> the trick is to work on GSoC at school
20:50:51 <tapuu> Does anyone here have any experience with the functions in Distribution.PackageDescription.Parse?
20:51:00 <vermeille> I can't, they overlap way too much
20:52:34 <haasn> vermeille: then your only option is to pull an edwardk and give up sleep
20:52:47 <bodie_> so uh, one last honest question requiring honest answers: do you really --feel-- that at the end of the day, haskell has taught you to be more intelligent about designing programs?  not just more knowledgeable, but pithier, cleverer, and more effective?
20:52:55 <vermeille> haasn: It's already 6am :D
20:52:59 <haasn> bodie_: yes
20:53:08 <heatsink> Yes, bodie_
20:53:13 <vermeille> bodie_: yeah, definitely
20:53:23 <haasn> Haskell has taught me that correctness goes much deeper than it seems at first
20:53:41 <haasn> Haskell has also taught me about what “handling every input” means
20:53:46 <stolaruk> bodie_: of course
20:53:46 <bodie_> heh
20:54:10 <vermeille> my C++ looks more functional, I use more high order functions, I use std::bind() to do partial application, etc etc
20:54:34 <bodie_> it's not necessarily an of course, while it may seem obvious.  I think effectiveness is often about solving only the problems you actually need to
20:55:09 <ion> Haskell taught me how to separate IO stuff from pure stuff in practice. I knew it would be the right thing to do but it was difficult to get practice in it in other languages.
20:55:12 <bodie_> for example, using Go has forced me to be wayyyyyy more simplistic and minimal, and it's really good
20:55:12 <heatsink> It teaches how to specify problems in a way that straightforwardly translates to working code.
20:55:20 <bodie_> I see
20:55:33 <haasn> bodie_: maybe you should spend some time programming in lazy k :)
20:55:34 <stolaruk> bodie_: I don't feel that it's changed the way I write Java, maybe it has for other ppl more intelligent than me, but in general it's changed the way I see programming
20:55:43 <haasn> I bet that would teach you to be simplistic and minimal like nothing else
20:55:58 <bodie_> hah
20:56:06 <bodie_> I prefer malebolge ;P
20:56:36 <bodie_> but obviously this isn't simplistic or minimal at all, it's a simplistic and minimal syntax, which is quite a different idea
20:57:08 <bodie_> I guess it depends on the problem
20:57:39 <vermeille> bodie_: it also taught me to use way more what's in <algorithm>, to separate the actual action and the traversal of the data structure, etc
20:57:57 <haasn> Haskell has also taught me what scaleable, composable and reusable code looks like.
20:58:04 <vermeille> +1
20:58:22 <vermeille> Even if I'm way too lazy to write very little composable functions in C++
20:58:44 <vermeille> at least I know what I should have done =')
21:00:20 <scb> anyone know why this could be happening? https://gist.github.com/scast/dbf4f6b2b3073e99a739 --- i can give as much context as needed
21:01:28 <tapuu> I've found something that looks like a cabal bug, but I'm unsure
21:01:58 <tapuu> http://lpaste.net/101997 This program seems to remove half the fields in a cabal package description...
21:02:03 <startling> scb: you might want forM_
21:02:09 <vermeille> (the most important : it taught me to wine A LOT about non-existence of algebraic data types)
21:02:17 <startling> :t forM)
21:02:17 <lambdabot> parse error on input `)'
21:02:19 <startling> :t forM_
21:02:20 <lambdabot> Monad m => [a] -> (a -> m b) -> m ()
21:02:24 <startling> :t forM
21:02:25 <lambdabot> Monad m => [a] -> (a -> m b) -> m [b]
21:02:52 <scb> yeah just noticed that, but the error is actually on the second case, the parser.Assign one
21:02:56 <haasn> scb: if I had to guess, maybe the types of your “case” right hand sides don't line up with eachother
21:03:19 <haasn> what are the types of addVariable, and checkExpr?
21:03:21 <startling> scb, right; the first type is [()] and the second type is ().
21:03:33 <scb> any way to coerce one into the other?
21:03:43 <scb> Doesn't mapM do that?
21:03:48 <startling> scb: sure, but use forM_ instead.
21:03:59 <startling> "coerce" is the wrong word
21:04:00 <scb> Just changed it.
21:04:02 <haasn> oh
21:04:05 <haasn> I missed the forM
21:04:08 <haasn> yeah, that'll be the reason
21:04:15 <haasn> scb: but re: coercing, yes; with void
21:04:17 <haasn> :t void
21:04:18 <lambdabot> Functor f => f a -> f ()
21:04:24 <haasn> @src void
21:04:24 <lambdabot> Source not found. Abort, Retry, Panic?
21:04:27 <startling> sure, but don't do that. :)
21:04:29 <haasn> void x = x >> return ()
21:04:35 <haasn> just mentioning it
21:04:36 <startling> :t fmap (const ())
21:04:37 <lambdabot> Functor f => f a -> f ()
21:04:44 <haasn> err, yes
21:04:46 <haasn> that :)
21:04:55 <haasn> I need to sleep, now
21:04:56 <scb> Got it.
21:04:59 <scb> Thanks
21:08:34 <vermeille> what are some useful uses of QuasiQuotation you've seen?
21:08:56 <haasn> vermeille: type safe printf
21:09:38 <vermeille> I can't see the QQ in it
21:10:03 <haasn> [printf|foo %d%d bar %s bat] 3 4 "hello"
21:10:24 <haasn> sure, you could just do $(printf "foo %d%d bar %s bat"), but that goes for every QQ out there
21:10:36 <vermeille> Oh. I believed it was written printf "format %d" 3
21:11:41 <vermeille> Just to make sure ; QQ is nothing more that a nicer syntax for `aParserFunction "my string"` which is evaluated compile-time, right?
21:13:20 <startling> vermeille: I think you and haasn are talking about different printfs
21:13:31 <startling> vermeille: something like that, yeah.
21:16:17 <tapuu> I'm at my wit's end with this problem
21:18:07 <haasn> vermeille: for some meaning of “evaluated compile-time”
21:18:15 <haasn> it isn't “evaluated compile time” as in “the same as if it was evaluated at runtime”
21:18:45 <haasn> it's evaluated compile time as in “this function returns an arbitrary haskell source fragment that gets inlined into the actual program as part of the compilation process”
21:19:19 <enthropy> that order can matter, say if you are reading in files that exist when you compile the executable
21:19:20 <haasn> in this example, a printing function specialized to that format string with those parameters and that specific type
21:20:20 <augur> goodness dibblego is an ideological knobhead
21:22:19 <augur> ive never met anyone who had such ideological stances on mathematics/semantics as he does
21:24:05 <vermeille> haasn: yeah, I know, this is crazy, you can return generated chunks of AST, that's insane
21:24:13 <laetiporous> exit
21:24:17 <laetiporous> haha
21:24:38 <vermeille> But if I'm not wrong, you can do something else. IIRC, Yesod uses QQ for html
21:29:25 <copumpkin> how do I ask cabal to link to additional object files in my build?
21:31:16 <copumpkin> phischu: ahem
21:31:59 --- mode: ChanServ set +o copumpkin
21:32:17 --- mode: copumpkin set +b phischu*!*@*$##fix_your_connection
21:33:27 --- mode: copumpkin set -b phischu*!*@*$##fix_your_connection
21:33:32 <Welkin> what was that?
21:33:36 <Welkin> oh
21:33:43 <copumpkin> sometimes people's clients get caught in weird loops
21:33:53 <copumpkin> and join/part repeatedly
21:34:32 <Welkin> has anyone written an irc bot in haskell?
21:35:28 <techtangents> Hi, all. What's the best library for vectors?
21:36:09 <copumpkin> what do you mean by vectors?
21:36:15 --- mode: copumpkin set -o copumpkin
21:36:18 <JDlugosz> Hello all.
21:36:22 <techtangents> Fixed-size vectors. Like Vect in Idris.
21:36:29 <vermeille> UArray?
21:37:19 <techtangents> I want the size statically known.
21:37:50 <techtangents> So, like Vect3 a = Vect3 a a a
21:37:55 <copumpkin> small ones?
21:37:58 <Ralith> Idris Vect is not fixed-size
21:37:58 <copumpkin> or arbitrary ones?
21:38:07 <copumpkin> Ralith: it is for any instantiation of N
21:38:21 <Ralith> copumpkin: n is not required to be static
21:38:24 <techtangents> Small ones, yeah. Sizes 3 and 4.
21:38:41 <copumpkin> Ralith: the type Vect n a has a fixed size
21:38:51 <techtangents> It's size n.
21:38:51 <copumpkin> techtangents: I think edwardk has one of those
21:39:07 <shachaf> copumpkin plays it safe.
21:39:12 <copumpkin> lol
21:39:41 <copumpkin> http://hackage.haskell.org/package/linear
21:40:07 <kadoban> is there a common way to go from... (a -> b -> c) -> (c -> d) -> a -> b -> d ?  Kinda like (.), but with an extra argument :/  Hoogle is failing me, or I'm failing at it.
21:41:19 <techtangents> kadoban: I think I wrote a library for that once…
21:44:39 <kadoban> techtangents: darn :/  guess i'll throw one in a utility file or something, heh...
21:44:50 <techtangents> I can't find it, sorry.
21:44:57 <kadoban> no worries, thanks anyway
21:45:46 <JDlugosz> So, why am I seeing some names marked with a * and including some kind of address/id in parens afterward, and other names are in angles with no further elaborations?
21:47:12 <copumpkin> JDlugosz: without further details, that question makes no sense to me :P
21:47:30 <vermeille> is there a way to add some colors to hlint :D?
21:47:36 <JDlugosz> e.g. "* andromeduck (~james@host105-188.resnet.ubc.ca) has joined #haskell"
21:47:48 <JDlugosz> or <vermeille> is there a way to add some colors to hlint
21:48:07 <copumpkin> you get host information when people come and go from the channel
21:48:18 <copumpkin> not during regular conversation, which is what you showed in second half
21:48:31 <copumpkin> there are many guides to IRC all over the internet :) I'd look for one of those
21:49:04 <JDlugosz> So lots of traffic for people coming and going.  Overwhelms the real conversation.
21:49:35 <Welkin> in many clients you can choose not to show join/part messages
21:50:01 <copumpkin> most clients can turn it off. But I urge you to look up details of that online for your specific client :) the 1200 people in here really aren't too interested in meta-conversation about IRC clients
21:51:25 * shachaf prefers meta-meta-conversation.
21:51:28 <JDlugosz> I was wondering, does Haskell have anything like Perl's -p -e (or -n -e) options?
21:51:28 <dwcook> Where can I find mod :: (Integral n) => n -> n -> Maybe n
21:52:19 <copumpkin> JDlugosz: if you tell us what those are, perhaps :)
21:53:36 <JDlugosz> Like, to do some trivial job like rendering my PATH environment variable in a readable form (turning all the separators into newlines) I don't even need to write a script file.  -e is followed by the string that is the (short!) program.  -p or -n is a stock main loop that my lines will go into.
21:54:55 <dwcook> JDlugosz, echo program_text | runhaskell
21:55:46 <dwcook> e.g: echo 'main = putStrLn "Hello, world"' | runhaskell
21:56:40 <MP2E> quite elegant :) who needs command line parameters when you have pipes
21:56:59 <MP2E> didn't even think of using runhaskell for that purpose heh
21:57:14 <kadoban> JDlugosz: ghci is likely to be more useful in practice than trying to do that exact thing, imo
21:57:16 <dwcook> Alternatively, to evaluate a single expression: ghc -e some_expression
21:57:26 <MP2E> ghci is usually what you want yeah
21:57:44 <JDlugosz> Given a single line of input on standard-input, how would you (simply/easily) split that line at each ';' and output one item per line?  (the ';' are between interesting items and not kept in the output)
21:58:08 <prsteele> JDlugosz: http://www.haskell.org/hoogle/ often can answer questions like this
22:00:09 <prsteele> JDlugosz: split (== ';') $ pack thestring
22:02:09 <vermeille> JDlugosz: something like `mapM_ print . split (== ';')` if what you mean by "output" is "print"
22:03:06 <JDlugosz> So how does standard input get to the argument of that function?
22:03:54 <vermeille> what's your goal.
22:03:58 <vermeille> ?*
22:03:58 <lambdabot> Maybe you meant: v @ ? .
22:04:03 <kadoban> 'interact' is a good start, if you're trying to golf this or something
22:04:35 <JDlugosz> My goal:  to use Haskell for this (and other such things) instead of Perl.
22:04:55 <prsteele> JDlugosz: http://hackage.haskell.org/package/base-4.6.0.1/docs/Prelude.html#v:getContents
22:05:07 <kadoban> JDlugosz: imo that's a bad goal, if you're trying to do it on the command line in a cute way. perl is really really good at golfing string manipulation/processing
22:05:47 <kadoban> You can do it in Haskell I'm sure, but if your goal is to just write shell one-liners, it's not a good choice.
22:05:47 <JDlugosz> Not golf, but one line, and easy to put common pieces together.  Remembering how things work is better than typing fewer letters.
22:06:28 <vermeille> "I want to do exactly what I do in Perl, exactly the same way, but in Haskell" :)
22:07:07 <StoneCypher> be sure to cute argue with him until his motivation disappears
22:07:11 <JDlugosz> Since (some) of you folks didn't know what perl -p -e were, I assume present company is using something else?
22:07:55 <vermeille> I never wrote a single line of perl in my life, and I live well, yanno
22:08:17 <kadoban> JDlugosz: Haskell isn't typically used in that way.  ghci is about the closest, but that's typically just for playing/figuring things out, after which you write out an actual .hs file and run it.
22:08:20 <JDlugosz> I thought it would be good practice (most everything that isn't my main job are tiny throw-away commands) and using perl again was shifting mental gears after filling my head with other stuff.
22:09:11 <tapuu> Is it normal for the cabal description parsing functions to ignore everything in an executable section?
22:09:38 <JDlugosz> Interesting to note that the haskell platform installation on Windows includes a full Perl installation in a subdirectory.
22:10:21 <vermeille> JDlugosz: "the right tool for the right task". If you want a one-liner, you won't even think about, say, C++, and more think about sed / awk, whatever. Even if Haskell is not as verbose as C++, that's not the right tool for one-liners.
22:10:33 <tapuu> I've been trying to figure this out for a full 2 hours now...
22:10:54 <StoneCypher> JDlugosz: what they are trying to say, and failing to say, is "haskell is for larger things, not throwaway scripts, so it doesn't actually have eval from console argument."
22:11:08 <JDlugosz> vermeille, that's why I learned Perl in the first place.  :)
22:11:20 <Welkin> to code golf?
22:12:04 <kadoban> JDlugosz: well, perl seems like a very good choice for that...i mean i'm here because I <3 haskell, but that doesn't mean it will replace everything for every purpose.
22:12:06 <augur> takeoutweight: oh hello
22:12:11 <apples> ghc -e '1+1'
22:12:39 <Welkin> of course you need different tools for different problems
22:12:48 <Welkin> someting C++ doesn't adhere to
22:12:48 <JDlugosz> But why try and think of fake problems to solve in Haskell to learn from, when I naturally come up with a few tiny problems in the course of a day?  So, I suppose I won't actually do that in Haskell at the moment (I'd get bogged down), but I'll make a note of that being something to try playing with (in GHCi) later.
22:12:57 <augur> takeoutweight: the l-var r-var distinction is one that doesn't exist in quite the same way in haskell as it does in stateful languages
22:14:02 <vermeille> JDlugosz: Great, so, first, try to understand what Haskell is good for, then pick a task for that, fckn code it, do it agin until you feel proficient in Haskell-targetted tasks, then chose a task which is a little more "unusual" for Haskell (ie involving some stateful things), try to solve it, etc etc
22:14:22 <JDlugosz> I was a world-class authority in C++, and I became a Perl Monk, so now I'll get adept as haskell (in about ten years of study).
22:15:34 <tapuu> Is there a way to write a GenericPackageDescription to a file?
22:15:56 <Welkin> JDlugosz, does that mean you could write "hello world!" in C++?
22:16:06 <vermeille> JDlugosz: let me re-phrase what you said: "But why try and think of fake problems to solve with a hammer to learn from, when I naturally come up with a few tiny problems in the course of a day? So, I suppose I won't actually do that with a hammer"
22:17:22 <JDlugosz> Now, I'm going to try coding the Towers of Hanoi problem in several different ways.  First, just used putStrLn in base case of the recursion.  Next, I want to build up a string to return.  I understand there is some kind of Monad meant for that?  What am I looking for?
22:18:02 <vermeille> JDlugosz: "I was a world-class authority in hammers, and I became a Screwdriver Monk, so now I'll get adept as knifes"
22:18:21 <MP2E> haha
22:18:33 <kadoban> JDlugosz: have you done any of the haskell tutorials?  Real World Haskell and Learn You a Haskell are both good starts.
22:19:02 <kadoban> I'd recommend alternating between the two when stuff stops making sense, or at least that's what I did and it seemed to eventually come together
22:19:48 <JDlugosz> Welkin, hello world?  More like I could write hundreds of magazine articles and a few book chapters, and help other book authors.
22:19:49 <tapuu> finally ive fixd it
22:20:20 <Welkin> JDlugosz, it was a joke about how overly complex and poorly designed C++ is
22:21:00 <vermeille> IMHO you can't really avoid solving artificial problems that are simple to deal with in Haskell (ie almost stateless), like maths computations or parsing etc
22:21:28 <vermeille> you have to get your hands dirty on something simple at first
22:21:30 <Welkin> write a brainfuck compiler
22:21:33 <Welkin> write a game AI
22:21:40 <Welkin> or a symbolic integrator
22:21:52 <scb> is there any way to make haskell pretty print its show output?
22:21:56 <Welkin> towers of hanoi and other toy exampes are too boring
22:22:00 <JDlugosz> Learn You a Haskell didn't do it for me.  Real World was OK at first, especially with the reader comments, but it got worse.  Poorly written, confusing
22:22:05 <MP2E> Write a full emulator in haskell, I'd like to see a gameboy emulator or something :P
22:22:37 <vermeille> MP2E: I have a friend doing that. I'm still wondering if that's genius or folly.
22:22:59 <MP2E> I honestly don't know either
22:23:18 <MP2E> I'd love to see one, nonetheless
22:23:19 <JDlugosz> Well, I still want to get up to speed on the basics.  Like, I know there is a kind of Monad or something that can collect results piecemeal, and I'm not sure what it was so I can't look it up by name.
22:23:19 <MP2E> hehehe
22:23:30 <JDlugosz> Someone help me out there?
22:23:31 <vermeille> I have problems even in C++... I wouldn't think doing in Haskell would make it easier.
22:23:55 <vermeille> MP2E: it does exist. I saw something about that on HN some time ago
22:23:55 <dwcook> Haskell is easier than C++
22:24:11 <Welkin> there is a gameboy emulator written in asm and C that is meant for teaching others how to write emulators
22:24:14 <prsteele> JDlugosz: http://en.wikibooks.org/wiki/Write_Yourself_a_Scheme_in_48_Hours/
22:24:24 <JDlugosz> Welkin:  Back when PCs ran DOS, I wrote a multi-threading system in C++ for C++ programs.  Made the cover of Computer Language Magazine.
22:24:29 <MP2E> Is there now? *googles*
22:24:46 <JDlugosz> Don't slam C++.
22:25:01 <MP2E> ah damn omegagb hasn't been updated in 7 years(the haskell gb emu)
22:25:05 <MP2E> eww 10% realtime speed o.O
22:25:11 <vermeille> dwcook: it's definitely harder to think in Haskell when you're a beginner
22:25:38 <dwcook> vermeille, it's a matter of familiarity. If you were familiar with both Haskell and C++, you would find yourself doing less grunt work in the former
22:25:47 <Welkin> MP2E, http://realboyemulator.wordpress.com/
22:26:07 <MP2E> wow neat
22:26:08 <MP2E> thanks
22:26:28 <vermeille> dwcook: I know, I'm hardly trying to get familiar with Haskell, I can't stand C++ anymore
22:26:42 <dwcook> vermeille, do you mean "trying hard"?
22:26:50 <JDlugosz> I gotta get back to my day (?) job.  Can someone tell me the module or type name to look up, please?
22:27:15 <vermeille> dwcook: certainly, excuse my french
22:27:41 <dwcook> vermeille, one negative side effect of learning Haskell may be that you can no longer stand certain other languages :)
22:28:20 <vermeille> I hope I'll reach that level.
22:28:39 <JDlugosz> If you think C++ is difficult, try C++ Template Metaprogramming.  It's functional!
22:28:50 <Platz> C++ to haskell is interesting.  One of C++'s strengths is explicit control of memory management; I haven't seen how to do that in haskell yet
22:29:05 <vermeille> C++ Metaprogramming is so <3
22:29:14 <dwcook> Platz, usually you don't need to. However, Haskell does let you shuffle around Ptr values if you really need to
22:29:21 <dwcook> @hoogle Ptr
22:29:22 <lambdabot> Foreign.Ptr module Foreign.Ptr
22:29:22 <lambdabot> Foreign.Ptr data Ptr a
22:29:22 <lambdabot> GHC.Exts data Ptr a
22:30:03 <Platz> dwcook: ah nice.  Yeah I wouldn't default to doing that stuff, but some domains require more careful control
22:30:22 <Welkin> why not just write the low-level portions in C then?
22:30:33 <vermeille> Platz: JDlugosz, take a look, instructions are generated at compile-time with metaprogramming :D Certainly the piece of code I'm the most proud of
22:30:46 <vermeille> https://bitbucket.org/Vermeille/gaymulator/src/3fabc25d16e2a56d065583875f9984df74462722/z80.cpp?at=master
22:30:54 <Welkin> gaymulator??
22:31:07 <Welkin> is that a pun?
22:31:51 <vermeille> the kind of pun you make when you're awake for 50h
22:32:35 <Platz> please don't end up like those korean starcraft players
22:32:39 <JDlugosz> C++ has well-defined destructor semantics:  you know exactly when they are placed in execution, and a big deal is "Resource Acquisition is Initialization".  That's totally opposite from not caring what the order of evaluation is at all.  So if porting something, memory management is the least of the problems, and "lifetime" is a much broader topic than for memory.
22:32:53 <JDlugosz> vermeille:  I'll look that up.
22:33:19 <vermeille> JDlugosz: I wrote an article about that http://vermeille.fr/dotclear2/index.php/post/23-Metaprogramming-a-full-Virtual-Machine
22:35:00 <mskoud> Anyone coming from Clojure to Haskell, primary for web development? Any thoughts on the tradeoffs?
22:36:10 <JDlugosz> I think a layer of syntactic sugar could be a "nice" pure functional language for template metaprogramming, that generates the C++ code.
22:37:02 <Platz> uncle bob martion gave a talk recently about how he grew up on assembly and c, and c++ had too much magic (because ctors and destructors);  didn't have nice things to say about haskell and apparently he's raving about clojure.  As if that doesn't have any magic..
22:38:22 <vermeille> JDlugosz: my school tried something like that, they give up https://www.lrde.epita.fr/dload/20030521-Seminar/maes0503_metagene_slides.pdf
22:54:21 <no-n> http://lpaste.net/1877417753694961664 <-- will fromServer (line 14) be re-constructed on every call to eval here? what if I define fromServer at top level?
22:59:38 <pavonia> no-n: It should be shared if you define it at the top-level
23:00:01 <no-n> shared?
23:00:25 <pavonia> I mean only evaluated once
23:00:30 <no-n> okay cool
23:00:53 <pavonia> Are you aware that the pattern "fromServer" will hide your local function definition "fromServer"
23:01:06 <pavonia> ?
23:01:22 <no-n> I don't think it does
23:01:33 <no-n> hmm
23:01:59 <no-n> pretty sure it doesn't as it acts as I expected it to
23:02:43 <pavonia> Your local definition of fromServer is never used in that code
23:03:07 <no-n> pavonia: well I know that respondToServer gets called
23:03:23 <no-n> pavonia: and this is the only place it's called from
23:03:36 <pavonia> Yes, because "fromServer:code:_" matches any list with at least two elements
23:03:46 <no-n> o
23:07:25 <copumpkin> say I have a DataKinds type-level list of types, and another one, and want to ensure they contain the same types, but not necessarily in the same order
23:07:27 <no-n> pavonia: thanks for pointing that out. would have totally missed it otherwise :/
23:07:29 <copumpkin> is there a clean way to do that?
23:07:40 <copumpkin> I can't really sort the types in a meaningful way
23:07:40 <pavonia> np
23:12:48 <arrdem> mskoud: brace yourself for a lot of "oh no you'
23:12:53 <arrdem> re doing it wrong"
23:19:18 <mskoud> Which framework?
23:20:24 <bitemyapp> mskoud: Yesod has a nice book for learning.
23:20:36 <bitemyapp> mskoud: Snap is reasonable choice as well. Scotty is relatively simple but spare.
23:21:25 * hackagebot hamlet 1.2.0 - Haml-like template files that are compile-time checked (deprecated)  http://hackage.haskell.org/package/hamlet-1.2.0 (MichaelSnoyman)
23:21:28 * hackagebot shakespeare 2.0.0 - A toolkit for making compile-time interpolated templates  http://hackage.haskell.org/package/shakespeare-2.0.0 (MichaelSnoyman)
23:21:29 * hackagebot shakespeare-css 1.1.0 - Stick your haskell variables into css at compile time. (deprecated)  http://hackage.haskell.org/package/shakespeare-css-1.1.0 (MichaelSnoyman)
23:21:31 * hackagebot shakespeare-i18n 1.1.0 - A type-based approach to internationalization. (deprecated)  http://hackage.haskell.org/package/shakespeare-i18n-1.1.0 (MichaelSnoyman)
23:21:33 <no-n> > (\x -> let y = 2 in case x of {1 -> 1; y -> y; _ -> 3}) 7
23:21:33 * hackagebot shakespeare-js 1.3.0 - Stick your haskell variables into javascript/coffeescript at compile time. (deprecated)  http://hackage.haskell.org/package/shakespeare-js-1.3.0 (MichaelSnoyman)
23:21:35 <lambdabot>  7
23:22:14 <bitemyapp> mskoud: closest equivalent to Clojure Ring style web stacks in Haskell is raw WAI or Scotty, but you'll be missing out on a lot of functionality and code reuse relative to Yesod or Snap
23:22:37 <no-n> > (\x -> let y = 2 in case x of {1 -> 1; y -> 2; _ -> 3}) 7
23:22:38 <lambdabot>  2
23:23:08 <mskoud> Thx, looking into Snap, nice docs :-)
23:24:53 <johannesbodannes> I honestly appreciate how Yesod goes out of your way to give you the benefits of type safety in absolutely everything as well
23:24:56 <no-n> how do you pattern match against a variable without creating a catch-all? I suppose I need to use if
23:25:19 <johannesbodannes> I think if you're used to full-featured frameworks from other languages Yesod will be most comfortable and interesting to you
23:26:05 <thebnq> no-n: you could use a guard
23:26:27 <johannesbodannes> ...although if you want to learn Haskell then I think that Snap does things more the "Haskell way"
23:26:29 <thebnq> i guess its not the same still
23:26:35 * hackagebot shakespeare-text 1.1.0 - Interpolation with quasi-quotation: put variables strings (deprecated)  http://hackage.haskell.org/package/shakespeare-text-1.1.0 (MichaelSnoyman)
23:26:37 * hackagebot cryptohash-conduit 0.1.1 - cryptohash conduit  http://hackage.haskell.org/package/cryptohash-conduit-0.1.1 (VincentHanquez)
23:26:39 * hackagebot yesod-auth 1.2.7.1 - Authentication for Yesod.  http://hackage.haskell.org/package/yesod-auth-1.2.7.1 (MichaelSnoyman)
23:28:33 <no-n> thebnq I might have to
23:28:56 <thebnq> no-n: PatternGuards might be relevant too, but i don't know too much about it yet
23:29:08 <no-n> don't know anything about them
23:31:11 <no-n> is there some way to use guards in a case expression?
23:31:58 <no-n> well ghci didn't complain about (x:arg) | x == fromServer -> undefined
23:32:15 <no-n> so I guess that's it lol
23:32:19 <thebnq> oh and viewpatterns too
23:32:22 <thebnq> > let x=3; foo ((subtract x) -> 0) = "win" in foo 3
23:32:23 <lambdabot>  "win"
23:32:26 <mskoud> is it the .cabal file which defines dependencies and versions used? So it's possible to have multiple versions of the same library installed?
23:32:59 <no-n> thebnq wow nice
23:33:52 <no-n> > let y = 7; f ((id x) -> y) = "win" in f 7
23:33:52 <lambdabot>  Couldn't match expected type `t0 -> t1'
23:33:53 <lambdabot>              with actual type `Debug.SimpleReflect.Expr.Expr'
23:34:52 <no-n> > let y = 7; f (id -> y) = "win" in f 7
23:34:53 <lambdabot>  "win"
23:35:11 <no-n> oh man
23:35:15 <no-n> :D
23:35:28 <thebnq> thats weird o.o! you can match a variable on the right side
23:35:45 <kadoban> Say I'm in a State Int monad, and i do: x <- get; let x' = x + 1.  Is there a way to combine those two?  Combine <- with a simple modification?
23:35:46 <thebnq> oh wait, no it just rebinds y
23:36:00 <no-n> > let y = 7; f (id -> y) = "win" in f 10
23:36:01 <lambdabot>  "win"
23:36:05 <no-n> doh
23:36:31 <thebnq> i guess you need ((==y) -> x)
23:36:39 <thebnq> x is the new inner bind
23:36:54 <thebnq> but i guess _ would work since y is in scope
23:37:00 <no-n> hmm
23:37:13 <apples> kadoban, do you mean something like x <- (+ 1) <$> get ?
23:37:14 <no-n> > let y = 7; f ((==y) -> x) = "win" in f 10
23:37:15 <lambdabot>  "win"
23:37:25 <no-n> strange
23:37:40 <kadoban> apples: looks like it, thanks :)
23:37:58 <thebnq> i can only imagine this being nice in a huge list of other pattern matches, guards would be prettier for a small case :b
23:38:15 <no-n> I don't get how it works
23:38:38 <no-n> > let x=3; foo ((subtract x) -> 0) = "win" in foo 30
23:38:39 <lambdabot>  "*Exception: <interactive>:3:10-40: Non-exhaustive patterns in function foo
23:39:03 <thebnq> its applying the left side and then pattern matching the result on the pattern on the right side
23:39:27 <thebnq> inside thee ( foo -> _) part
23:39:36 <no-n> yea
23:40:11 <no-n> > let x = 3; y = 0; foo ((subtract x) -> y) = "win" in foo 3
23:40:12 <lambdabot>  "win"
23:40:14 <no-n> > let x = 3; y = 0; foo ((subtract x) -> y) = "win" in foo 4
23:40:15 <lambdabot>  "win"
23:40:25 <no-n> okay, but you still get the catch-all problem
23:40:36 <no-n> if you use a variable
23:41:01 <thebnq> oh yea of course
23:41:10 <no-n> > let x = 3; y = 0; foo ((==y) . (subtract x) -> True) = "win" in foo 4
23:41:11 <lambdabot>  "*Exception: <interactive>:3:19-60: Non-exhaustive patterns in function foo
23:41:14 <no-n> > let x = 3; y = 0; foo ((==y) . (subtract x) -> True) = "win" in foo 3
23:41:15 <lambdabot>  "win"
23:41:35 <no-n> well there ya go :P
23:43:53 <no-n> I guess a guard would look better in this case but at least I learned something that will be useful/elegant in some situations :)
23:44:49 <thebnq> yea :b pretty code is pretty important
23:56:38 <no-n> @hoogle ExitFailure
23:56:39 <lambdabot> System.Exit ExitFailure :: Int -> ExitCode
23:56:39 <lambdabot> System.Exit exitFailure :: IO a
