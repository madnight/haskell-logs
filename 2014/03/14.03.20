00:06:43 <AshyIsMe> looks like there's activity going on in their bug tracker too: https://cloud-haskell.atlassian.net/secure/Dashboard.jspa
00:12:23 <pyon> In this snippet, http://lpaste.net/101489 , could anyone please explain to me why line 55 does not work, but lines 57-59 do work?
00:13:03 <jle`> is there a concept for a Monad without return?
00:13:07 <jle`> something with just join?
00:13:31 <pyon> jle`: Semigroupoidad? :-P
00:13:37 <bergmark> pyon: if you enable ScopedTypeVariables and remove the class constraint from the inner bindings i think it will work
00:13:38 <pyon> Semigroupad*
00:14:07 <pyon> bergmark: What does ScopedTypeVariables do? :-O
00:14:23 <johannesbodannes> the "linear" library seems kind of impoverished...
00:14:28 <bergmark> the ghc manual can probably describe this more accurately than me :)
00:14:37 <bergmark> @google ScopedTypeVariables
00:14:38 <johannesbodannes> does anyone know of a better linear algebra out there?
00:14:39 <lambdabot> http://www.haskell.org/haskellwiki/Scoped_type_variables
00:14:39 <lambdabot> Title: Scoped type variables - HaskellWiki
00:14:44 <johannesbodannes> library*
00:14:49 <johannesbodannes> linear algebra library*
00:14:51 <jle`> ScopedTypeVariables tells you that the 'a' in your function type signature applies to everything inside the function
00:14:57 <johannesbodannes> for haskell
00:15:02 <supki> jle`: Data.Functor.Bind in semigroupoids
00:15:42 <jle`> supki: ah thanks
00:16:30 <johannesbodannes> also, is there any mechanism in haskell for parameterizing a type class with an integer? say, to determine the dimension of the type
00:16:42 <johannesbodannes> as opposed to just types alone
00:17:24 <bergmark> johannesbodannes: you'd really want dependent types for this, but haskell is moving in this direction, see the type level naturals for example
00:17:26 <Cale> johannesbodannes: There's sort of a start on that. DataKinds
00:17:32 <Cale> and yeah, type level naturals
00:17:50 <johannesbodannes> i'll google those now, thanks!
00:18:03 <Cale> I'm sort of itching for a complete shift to dependent types now
00:18:18 <bergmark> yes :-)
00:18:52 <bergmark> johannesbodannes: idris seems to be the most accessible dependently typed language
00:20:59 <Twey> Agda is a lot simpler than Idris
00:21:10 <Cale> Twey: Do you think so?
00:21:14 <Twey> I do
00:21:26 <Cale> I think Agda has better tooling than Idris right now, which might make it easier
00:21:48 <Cale> But actually simpler? I dunno, maybe!
00:21:54 <Twey> Idris has a bunch of features like typeclasses and effects to make it convenient for programming
00:22:15 <Twey> Agda's a much simpler language, at its heart
00:22:25 <bergmark> i think "convenient" was what i meant :)
00:22:27 <Cale> Oh, yeah, there's the whole effect system which I've been ignoring, but I thought that was just a library :)
00:22:58 <Twey> It's mostly a library, but it has some sugar and stuff too, I think
00:23:22 <Cale> Idris has some interesting capacity for user-defined syntax sugar which I think they're using there
00:23:22 <jle`> is the cool thing today to just use everything from transformers and not directly from mtl when possible?
00:23:30 <Twey> bergmark: ‘Convenient’ is often the opposite of ‘accessible’
00:23:43 <Twey> Though it's great when they come together ☺
00:24:02 <Twey> Cale: That could be it
00:25:01 <bergmark> :-)
00:25:12 <Cale> I think if you're going to learn any of {Coq, Agda, Idris}, you should probably just learn all three at once.
00:25:19 <johannesbodannes> wow, really?
00:25:30 <johannesbodannes> which of those have monads? all of them?
00:25:32 <Twey> I don't think I would go that far
00:25:51 <Twey> Agda's the simplest of the three by far, so I'd advise a newbie to start there
00:26:05 <bergmark> or to make it simple: emacs? agda, vim? idris
00:26:07 <Twey> Maybe move onto Idris later
00:26:23 <Twey> johannesbodannes: All of them, yes
00:26:29 <flux> but coq has books. how do adga/idris documentation compete?
00:26:34 <johannesbodannes> great
00:26:47 <Twey> johannesbodannes: It would be peculiar to have a full dependently-typed language without the ability to use monads.
00:26:57 <Cale> flux: Yeah, that's kind of getting at the reason why I say just learn all three
00:27:25 <johannesbodannes> anyway i have to go right now, thanks for the help guys
00:27:28 <flux> coq'art has been waiting for me for probably four years now on the shelve :)
00:27:31 <Cale> The number of resources for learning dependently typed programming is kind of small, so you can benefit from the full set of resources available
00:27:36 <Twey> flux: Coq needs books.  :þ  If you know Haskell syntax, you can just read an Agda tutorial to get a handle on the differences and a lot of the skills transfer
00:27:46 <Cale> Twey: I dunno
00:27:53 <Cale> I didn't really need any books to learn to use Coq
00:28:09 <Cale> Apart from the documentation, and a bunch of flailing around in coqide
00:28:14 <bergmark> aren't there course materials available for agda?
00:28:23 <Twey> Fair enough.  I guess not everyone needs books.
00:28:27 <Twey> bergmark: There are tutorials and stuff
00:28:32 <Twey> No books as far as I know
00:28:59 <Cale> If you know Haskell well enough, it will mostly just seem like Haskell with worse syntax and a much nicer type system.
00:29:14 <Cale> There are some things to get used to, like matching with a motive
00:29:43 <bergmark> yeah perhaps no books, but i'd imagine chalmers/utrecht publishing some Things related to their courses
00:29:53 <Twey> Coq programs don't look much like Haskell programs to me
00:30:12 <Cale> The tactic-based stuff is different, I'll admit
00:30:16 <Twey> All the tactics… it reads more like an imperative program for building a functional program
00:30:45 <Twey> Whereas Agda is the usual ‘write terms to fit the types’ that every Haskell programmer is familiar with
00:31:08 <Twey> Just with slightly more powerful types
00:31:17 <Twey> And decent holes ;)
00:31:42 <Cale> I don't know why I never really found the tactics any kind of problem. I guess you can really start with very little and work your way up there, and most people use a very limited form of the tactic language anyway.
00:31:49 <bergmark> i think all of my colleagues have taken agda courses, i feel so left out :-(
00:31:57 <Cale> To the extent that it's like a baroque notation for the lambda calculus
00:32:23 <Cale> intro x.  is effectively  \x -> ...
00:32:35 <Twey> Very baroque
00:33:06 <Twey> The correspondence is there if you know what to look for.  But as a newbie you probably don't.
00:33:32 <Cale> It's *impossible* to read if you don't have an IDE or something.
00:34:03 <Cale> (Some of the documentation generators let you hover over the lines in a tactic-based proof and see the goal and context at each step)
00:34:35 <Cale> But if you can see the goal and context, then it's not so bad
00:36:24 <Twey> I'm not saying it's bad, just that it's a lot more stuff in the way of learning to program with dependent types
00:36:54 <Twey> I'd certainly like more tactics/CoqIDE in Agda, sometimes
00:37:59 <carter> and the upside to tactics === you can have proofs still "work"
00:38:04 <carter> when oyu change defsn
00:38:13 <carter> doesn't work with the agda/ haskell style :)
00:38:29 <carter> even though you can make elegant proofs in the agda / haskell style
00:39:19 <carter> anyone have opinions on hspec vs tasty vs ?
01:02:26 <bergmark> i wish you could combine qualified and unqualified imports into one declaration
01:03:07 * hackagebot llvm-tf 3.0.2 - Bindings to the LLVM compiler toolkit using type families.  http://hackage.haskell.org/package/llvm-tf-3.0.2 (HenningThielemann)
01:03:09 * hackagebot parcom-lib 0.8.0.2 - A simple parser-combinator library, a bit like Parsec but without the frills  http://hackage.haskell.org/package/parcom-lib-0.8.0.2 (TobiasDammers)
01:03:33 <bergmark> i very often end up with import User (User); import qualified User
01:04:02 <pyon> bergmark: Like, "import everything unqualified, except foo, bar and baz, which must be qualified by T"?
01:04:42 <pyon> Or, conversely, "import everything qualified by T, except foo, bar and baz, which may be unqualified"?
01:04:48 <bergmark> usually i want the other way around "import everything qualified, and X unqualified"
01:05:02 <pyon> Ah.
01:05:40 <bergmark> code looks nicer (no User.User type signatures), easier to see where identifiers are coming from, and you follow the pvp
01:06:13 <tikhon> Yeah, that
01:06:17 <tikhon> that's my usual approach too
01:06:23 <tikhon> ie, I often want operators unqualified
01:06:35 <tikhon> and types, especially if they're redundant (Map.Map)
01:07:54 <bergmark> oh right, yes, qualified operators are pretty terrible to look at :-)
01:08:53 <tikhon> Racket's pretty clever about it's import system
01:09:00 <Twey> Really, ‘import User as User (User)’ should do the trick
01:09:03 <tikhon> it also allows you to rename stuff as you import it, if I remember correctly
01:09:30 <tikhon> Twey: doesn't that just import User as both User and User.User, but not the rest of the module?
01:09:38 <tikhon> I don't think I've ever written exactly that, so I'm not sure.
01:09:53 <Twey> Yep
01:09:57 <Twey> Which is useless :þ
01:10:57 <bergmark> yeah, it's pretty bad
01:11:06 <pyon> Serves you guys well for not using Deep.Module.Namespacing. :-P
01:11:06 <Twey> It would make much more sense if the bracketed list were used to import things unqualified
01:11:24 <tikhon> pyon: how does that change anything?
01:11:27 <Twey> After all, there's no point in selectively importing qualified names
01:11:35 <tikhon> Twey: yeah
01:11:46 <tikhon> although I think it does make the system a bit simpler, which is nice
01:11:58 <pyon> tikhon: import Control.Whatever.User as User
01:12:17 <tikhon> pyon: that doesn't change the problem we're talking about though
01:12:18 <Twey> It would be equally simple if the brackets always imported things unqualified
01:12:23 <tikhon> or am I misunderstanding something?
01:12:26 <bergmark> hmm and you need a minor dependency if you import two modules from the same package under the same qualified name, right?
01:12:44 <pyon> tikhon: Doesn't that make User stand for for Control.Whatever.User (the module) and Control.Whatever.User.User (the type)?
01:12:53 <pyon> s/for for/for both/
01:12:57 <bergmark> since adding a (possibly conflicting) function is a minor bump
01:12:59 <Twey> bergmark: Yeah, but… you can just not do that
01:13:19 <tikhon> pyon: the problem is that we want to import *everything* qualified as User.* *and* import selected things unqualified (like the User type)
01:13:30 <Twey> I think adding an identifier is, er, the third version component
01:13:47 <bergmark> Twey: right, that's what i mean by "minor"
01:13:49 <tikhon> PVP is basically like semantic versioning, isn't it?
01:13:54 <Twey> Ah, okay
01:13:57 <bergmark> tikhon: yeah, with some haskell specific things
01:14:00 <tikhon> except with two major version numbers
01:14:07 <bergmark> and that
01:14:08 <tikhon> because
01:14:13 <Twey> I don't understand what the extra version number is for
01:14:16 <bergmark> yes, because. :)
01:14:23 <Twey> Cabal just says ‘bump these together’ :þ
01:14:42 <tikhon> I like semantic versioning
01:14:51 <tikhon> nice and simple and happy
01:14:54 <Twey> Semantic versioning is nice
01:15:00 <tikhon> the extra number just adds tension
01:15:08 <bergmark> some people use it to indicate stability (see text), but since it's not defined to mean that it isn't that useful
01:15:15 <Twey> I wouldn't mind if it had a dedicated purpose
01:15:31 <Twey> We could use one number for strictness changes, for example
01:16:01 <tikhon> I think of it as a sort of "really big version number": not just breaking backwards compatibility, but changing things at a pretty fundamental level
01:16:03 <Twey> Removal . Addition . Strictness . Bugfix
01:16:04 <bergmark> also stability is a pretty bad thing to mark in the first component since 1.0 might be stable but 1.1 experimental
01:16:07 <tikhon> Parsec 2 vs Parsec 3
01:16:25 <tikhon> whereas the second number is for anything that breaks backwards compatibility even a little bit
01:17:02 <tikhon> then again, you could argue that for changes in the scope of parsec 2/3, you should just create a new package
01:18:09 * hackagebot cabal-nirvana 0.2.2.1 - Avoid Cabal dependency hell by constraining to known good versions. (deprecated)  http://hackage.haskell.org/package/cabal-nirvana-0.2.2.1 (MichaelSnoyman)
01:18:11 * hackagebot hackage-proxy 0.3.0.1 - Provide a proxy for Hackage which modifies responses in some way. (deprecated)  http://hackage.haskell.org/package/hackage-proxy-0.3.0.1 (MichaelSnoyman)
01:18:14 <bergmark> using it for  fundamental changes sounds good, though it's hard to formalize what it means i suppose
01:19:01 <bergmark> do-you-maybe-have-to-change-every-use-site
01:19:34 <tikhon> yeah
01:19:47 <tikhon> I'm thinking of things like changes in philosophy beyond just API changes
01:19:59 <tikhon> apart from Parsec 2/3, Hakyll 3/4 is another good example
01:20:14 <tikhon> that's why I said that perhaps making a new package could make sense in those cases
01:20:54 <bergmark> i'm fine with having it the same package though, it's the same maintainer, and it implies that the old version will be phased out
01:21:08 <bergmark> but if you pick a technology specific name you're screwed :-)
01:22:31 <bergmark> take some arbritrary package like pipes-csv, why is it so important that it's using pipes :)
01:23:24 <tikhon> hmm, I think the idea is to create a "pipes ecosystem"
01:24:17 <bergmark> hmm good point, i suppose it's easier to work with just one streaming library
01:24:53 <Twey> You probably don't want to mix pipes and conduit in the same application
01:25:34 <Twey> It's important because the pipes are part of the API.  It's not like they're an internal implementation detail.
01:25:48 <yitz> Twey there *is* a use for limiting the symbols that are imported qualified, and i've actually seen it fairly often
01:26:10 <yitz> Twey: the use is this: you want to re-export the qualified namespace, but not all of the symbols in it.
01:27:31 <Twey> Ehhh.  Re-exporting at package boundaries doesn't warrant the same convenience; we can live with having to spell out the namespace members
01:27:34 <bergmark> that can be inconvenient though, if it's from another package your version is now tied to theirs, whereas it's not if you use explicit exports
01:27:37 <yitz> Twey: i really don't see the problem with import Foo (symbol); import qualified Foo as Foo. it works and it's clear. are you working on code golf?
01:28:43 <yitz> yes re-exports are important
01:29:06 <bergmark> in what sense do you mean?
01:29:43 <yitz> there are indeed serious limitations with haskell's module system. people coming from ML always complain about it. but i don't think this particular point is the problem.
01:30:37 <bergmark> no i'm not saying this is a big issue, it's just a convenience thing
01:30:37 <companion_cube> looks like haskell and ML could both learn from each other
01:30:39 <tikhon> it's not a serious limitation, but it seems a bit inconvenient
01:30:46 <bergmark> tikhon: ;)
01:31:01 <tikhon> but yes, Haskell could definitely learn from ML
01:31:38 <tikhon> although I doubt some of the big design problems (in my mind) are going to get handled any time soon
01:31:45 <yitz> bergmark: well if you want your external API to include those symbols, and internally you currently implement that by intentionally tying it to a different module.
01:33:07 <uiop> one problem with the module system is that you have no way to wrap up a bunch of import declarations (with tenuous "hiding", "qualified as X", etc).
01:33:21 <yitz> tikhon: yeah. with first class modules implemented in an elegant way, all of these kinds of discussions would become moot.
01:33:45 <tikhon> and it seems like first-class modules could address some of the problems with typeclasses too
01:33:49 <tikhon> although I'm not sure exactly how
01:33:52 <uiop> you import list is O(number-of-imported-modules-that-werent-in-cahoots-wrt-symbol-non-clashingness)
01:33:57 <tikhon> I think OCaml is moving in that direction
01:34:23 <tikhon> of course, import syntax is actually pretty orthogonal to the actual design of modules :P
01:34:54 <tikhon> OCaml, for example, has lots of nice module features but pretty limited syntax for importing from them (ie opening)
01:35:22 <tikhon> for example, they basically have to put infix operators in another module to have those unqualified but everything else qualified
01:35:43 <uiop> syntax yes, the necessity to repeat complicated import raindances in all of your 100 modules is one of the "killer-apps" of a module system worth aspiring to
01:36:12 <uiop> *AVOIDING the necessity to...
01:36:40 * uiop just used {-# LANGUAGE CPP #-} :)
01:36:42 <uiop> *uses
01:38:11 * hackagebot yaml 0.8.8 - Support for parsing and rendering YAML documents.  http://hackage.haskell.org/package/yaml-0.8.8 (MichaelSnoyman)
01:38:46 <uiop> tikhon: if you have a well-designed signature that provides, say "data structures", you'll have arranged that you need only a single "using/open/whatever MyDataStructures" decl
01:39:28 <uiop> so it's really the ability to provide an importable unit that can alias other of the same to names
01:39:52 <uiop> (for this use case)
01:40:05 <tikhon> as I said earlier, I think Racket has a good system for importing stuff that's pretty flexible
01:41:27 <tikhon> but yeah, for me, it's really not a big deal
01:41:29 * uiop pines for standard ML modules on haskell
01:42:06 <uiop> it will have to wait until haskell's successor though
01:42:24 <uiop> (which will also be strict! /me ducks)
01:42:40 <tikhon> another possibility: we will jump into dependent types and just use dependent records and be happy
01:43:11 * hackagebot tasty-quickcheck 0.8.0.3 - QuickCheck support for the Tasty test framework.  http://hackage.haskell.org/package/tasty-quickcheck-0.8.0.3 (RomanCheplyaka)
01:43:13 * hackagebot yackage 0.7.0.2 - Personal Hackage replacement for testing new packages. (deprecated)  http://hackage.haskell.org/package/yackage-0.7.0.2 (MichaelSnoyman)
01:43:24 <tikhon> come to think of it, practical dependent types is the main thing I'd expect of a hypothetical future Haskell successor
01:51:32 <quchen> i.e. idris
01:51:37 <tikhon> yes
01:51:49 <tikhon> or something not unlike Idris
01:52:20 <tikhon> although I'm personally not too convinced by eager evaluation
01:52:23 <eatman> Hello
01:53:09 <nOObbbb> i dont have background in compilers. but i am good at DS, and low level stuff being an EE. is there anything i can help haskell with?
01:53:32 <tikhon> DS?
01:53:48 <tikhon> digital systems?
01:54:12 <quchen> You can help Haskell by using it and improving its ecosystem.
01:54:19 <nOObbbb> Data Structures.
01:54:22 <tikhon> oh
01:54:24 <tikhon> umm
01:55:19 <tikhon> yeah, using Haskell and working on Haskell libraries is a good place to start
01:55:51 <tikhon> depending on what you're particularly interested in, perhaps you could work on a DSL for low-level code embedded in Haskell
01:56:00 <tikhon> there are a bunch like that floating around already, actually
01:56:10 <haasn> improving the state of haskell libraries in general will indirectly help; you don't have to work on the actual compiler or language specification to be of importance
01:56:20 <tikhon> everything from HDLs to systems programming languages
01:58:12 * hackagebot mega-sdist 0.2.10.4 - Handles uploading to Hackage from mega repos (deprecated)  http://hackage.haskell.org/package/mega-sdist-0.2.10.4 (MichaelSnoyman)
01:59:31 <nOObbbb> >> perhaps you could work on a DSL for low-level code embedded in Haskell
01:59:40 <nOObbbb> tikhon: any pointers for that?
02:00:18 <tikhon> Ivory from Galois seems very cool
02:00:24 <tikhon> https://github.com/GaloisInc/ivory
02:00:33 <tikhon> but I haven't actually done much low-level stuff like that
02:00:40 <notdan> more like Ivory Tower am I right
02:00:44 <notdan> (/joking)
02:00:51 <notdan> it looks cool really
02:01:10 <tikhon> maybe the best place for you to start would actually be with a particular low-level project that could use a DSL like Ivory; you would be able to evaluate what it's good for and what it isn't, and you'd have a cool demo at the end
02:01:16 <notdan> i wish i could work on embedded systems and dsls
02:01:57 <tikhon> Galois is probably hiring :)
02:02:08 <nOObbbb> ok this sounds interesting. lemme have a look.
02:02:37 <tikhon> nOObbbb: they're currently using it for making an autopilot for little UAVs (ie quadcopters)
02:02:48 <tikhon> so it's probably good for robotics stuff, at the very least
02:02:56 <nOObbbb> woah. thats cool.
02:02:59 <tikhon> if you've ever had a robotics project you wanted to try, here's the perfect excuse!
02:03:08 <tikhon> I assume you're not afraid of hardware unlike, say, me :P
02:04:08 <johannesbodannes> http://hackage.haskell.org/package/haste-compiler
02:04:10 <johannesbodannes> I'm really excited by this
02:04:26 <nOObbbb> haha. me not, but my mum thinks i will do something terrible one day with all the wires around. :p
02:04:37 <tikhon> johannesbodannes: have you tried it at all?
02:04:46 <johannesbodannes> Yes, I've put together some really simple stuff
02:05:11 <tikhon> I should try it one of these days
02:05:15 <johannesbodannes> but javascript, insofar as I've used it, has always been awful for making really large applications
02:05:38 <tikhon> yeah, it's annoying at any sort of scale
02:05:55 <tikhon> I've used OCaml compiled to JavaScript, and that was pretty good
02:06:08 <tikhon> but, until recently, the Haskell → JavaScript situation looked poor
02:06:32 <tikhon> now though, Haste and GHCJS both look promising
02:06:56 <tikhon> I wonder how performance works out though
02:07:01 <tikhon> I'll have to experiment
02:07:22 <johannesbodannes> the dissertation accompanying haste would have you believe that it's quite performant relative to competing libraries
02:07:36 <tikhon> well, same for js_of_ocaml
02:07:38 <tikhon> and it's pretty good
02:08:07 <tikhon> except the performance *profile* is different: things that are normally fast are slow in JavaScript, like most list code
02:08:15 <tikhon> I don't know if there's something similar with Haskell
02:08:34 <tikhon> what I really want is a nice implementation of classical FRP that works with JavaScript
02:09:01 <haasn> tikhon: like elm?
02:09:06 <tikhon> no, not like Elm
02:09:26 <haasn> what's the difference between elm and “classical FRP”?
02:10:09 <luite> tikhon: sodium works with ghcjs, i fixed at least all the known bugs with memory management last week
02:10:34 <tikhon> at the very least, my understanding is that Elm does not have nice continuous time semantics
02:10:40 <tikhon> although perhaps that has changed recently?
02:10:53 <luite> yeah elm only has events basically
02:10:54 <tikhon> also, I think its core abstraction is a bit different from the events/behaviors I like
02:10:58 <luite> unless they did change something
02:11:03 <luite> no behaviours
02:11:05 <tikhon> right
02:11:13 <tikhon> so what I want is (a) behaviors and (b) continuous time semantics
02:11:33 <tikhon> of course, that's actually hard to implement well
02:11:55 <tikhon> and being able to just use Haskell is also a big plus
02:12:08 <tikhon> I mean, I'm not sure why I would go with Elm over OCaml, for example
02:12:15 <tikhon> Elm is strict, right?
02:14:14 <tikhon> I should be clear: I think Elm is an awesome project, it just isn't what I'm looking for
02:14:34 <tikhon> more generally, I think there's just a deep difference in philosophies between me and Elm
02:14:59 <luite> yeah elm is strict
02:15:20 <tikhon> right
02:15:28 <tikhon> so that's another thing I'd like: laziness
02:16:17 <tikhon> basically, I'm just less willing to sacrifice the nice semantics I want for ease of implementation
02:16:28 <tikhon> maybe I'm just a hopeless idealist
02:17:09 <luite> :)
02:19:54 <luite> tikhon: getting lazy IO working correctly is actually fairly tricky to implement (yeah there are some disadvantages of lazy IO, but ofen it's just so convenient)
02:20:46 <tikhon> lazy IO and laziness are somewhat orthogonal
02:21:04 <tikhon> and just because you're doing FRP in a lazy language does not mean the implementation has to use lazy IO
02:21:55 <luite> hm, i wouldn't say orthogonal
02:23:09 <tikhon> well, I suppose lazy IO depends on being in a lazy langauge but not vice-versa
02:23:17 <tikhon> just because your language is lazy does not mean you have to include lazy IO
02:24:23 <tdammers> lazy IO is sort of possible in a generally non-lazy language, as long as it supports *some* sort of laziness, somehow
02:24:32 <tdammers> somewhat
02:25:10 <tikhon> right
02:26:07 <pyon> tdammers: Doing it the hard way, as in ML's "'a thunk ref" ?
02:26:24 <tikhon> pyon: I'd imagine something more like a lazy Stream data type or something
02:26:56 <pyon> tikhon: That can be built on top of thunks and refcells (and impurity).c
02:27:05 <tikhon> fair enough
02:27:16 <tikhon> I was thinking more about what the interface would look like
02:27:57 <luite> tdammers: hmm, got an example of something like that? i wrote some code that lets you do something like $ mapM_ putStrLn . take 20 . TL.lines =<< lazyXMLHttpRequest "myurl", where it'd automatically close the connection after consuming the 20 lines, connection errors show up as exceptions
02:28:34 <luite> and i was looking on how you'd do tht with js reasonably nicely for example
02:28:49 <luite> oops that should b TL.putStrLn or something like that :)
02:29:09 <luite> but it'd also work with plain String instead of lazy text
02:29:30 <pyon> tikhon: "datatype 'a thunk = UNFORCED of (unit -> 'a) | FORCED 'a ; type 'a lazy = 'a thunk refcell ; datatype 'a stream_cell = NIL | CONS of ('a * 'a stream) withtype 'a stream = 'a stream_cell lazy" -- or something like that
02:30:50 <pyon> errr... FORCED of 'a
02:32:40 <tdammers> I was thinking of things like yield return in C# or python, really
02:32:53 <tdammers> I think JS has yield now, too
02:32:54 <tikhon> which is basically a lazy stream, isn't it?
02:32:56 <tdammers> yes
02:33:22 <pyon> Oh, C#'s IEnumerator.
02:33:28 <tdammers> yeah
02:33:46 <tdammers> all the OO languages are jumping on the iterator bandwagon lately
02:34:08 <tikhon> I hate iterators
02:34:15 <tikhon> they make *reading* a collection have side-effects
02:34:21 <pyon> Too bad most do not make a distinction between what C++ calls InputIterator (only traversable once) and ForwardIterator.
02:34:26 <tikhon> so much fun and excitement
02:34:39 <pyon> tikhon: It is possible to have iterators in a pure language.
02:34:50 <luite> hmm, does python have something like pipes that lets you stich together generators with transformers?
02:35:00 <pyon> luite: hahahahahahaha no
02:35:06 <tikhon> not in the same sense as what Python et al expose
02:36:25 <pyon> tikhon: Of course, doing iterators right requires the "next" function to have type "Iterator -> Maybe (Element, Iterator)". Now, if the Iterator type is linear, the iterator is traversable only once (what C++ calls InputIterator, because the function consumes the iterator), and, if the Iterator type is not linear, the iterator can be retraversed (what C++ calls ForwardIterator).
02:37:03 <pyon> (Which of course none of the OO languages does.)
02:37:08 <akegalj_> traverse is kind of <$>. Is there anything traversable kind of <*> ?
02:37:47 <tdammers> btw, python iterators are really fucked up, they can bite you badly
02:38:02 <tdammers> l = zip([1,2,3], [4,5,6])
02:38:08 <pyon> Yeah, stopping iterators via an exception is an abomination.
02:38:09 <tdammers> for x in l: print(l)
02:38:11 <tdammers> for x in l: print(l)
02:38:27 <tdammers> you'd think that this would iterate twice
02:38:29 <Lethalman> tdammers, mutability :)
02:38:32 <tdammers> and in python 2, it does
02:38:40 <tikhon> akegalj_: what would the type for that look like?
02:38:44 <Lethalman> tdammers, oh, really it does in py 2? interesting
02:38:47 <tdammers> yes
02:38:54 <tdammers> in p2, zip() is a function that returns a list
02:38:55 <pyon> In Python 2, I think zip returns a list.
02:39:05 <tdammers> in p3, however, zip is a class that acts as an iterator
02:39:08 <pyon> In Python 3, it returns a only-once-traversable object.
02:39:46 <tdammers> I wasted an entire night of processing on this stupid gotcha once
02:40:15 <tdammers> you can't even see the difference in the code
02:41:07 <Lethalman> tdammers, ah yes zip returns a list of course..
02:41:07 <pyon> The problem is that OO languages mutate the iterator instead of returning a new one. Even Rust gets this wrong. :-(
02:41:31 <Lethalman> unexpected for me as well that py3 zip is a generator :S
02:41:34 <tikhon> at that point, it seems confusing to call both concepts "iterator"
02:41:44 <tikhon> I've only ever used the mutable sort of iterator, which I think is just terrible
02:41:54 <Lethalman> the concept in this case is correct
02:41:55 <tdammers> Lethalman: someone probably thought, let's make this more efficient
02:42:01 <tdammers> and all the tests went green
02:42:02 <Lethalman> it's you that think the "for" would start it over
02:42:07 <Rembane> Everything in py3 is a generator.
02:42:41 <merijn> Rembane: Same can be said for Haskell :p
02:42:49 <companion_cube> I think it's because some iterators are really linear
02:42:58 <companion_cube> e.g. if you iterate on lines from a socket
02:43:00 <pyon> tdammers: It is not even a matter of efficiency, it is a matter of getting the types right. With linear types, if the old iterator is consumed, the new one can be stored exactly in the same place in memory.
02:43:02 <companion_cube> you can't "rewing"
02:43:06 <companion_cube> rewind*
02:43:42 <merijn> companion_cube: Sure you can, just add infinite storage to safe all information :p
02:44:09 <Rembane> merijn: Indeed. :) The interesting thing is that I was going to say: Everything in py3 is an iterator, but my brain replaced some words.
02:44:15 <companion_cube> that's exactly my point:p
02:44:26 <companion_cube> if you want that, you should use a list, not an iterator
02:44:37 <tdammers> pyon: no, I mean the reasoning behind going from a function that returns a list to a generator was probably memory efficiency
02:44:44 <tdammers> i.e., going from strict zipping to lazy
02:46:10 <akegalj_> tikhon: f (a -> b) -> a -> f b
02:46:19 <companion_cube> also, some iterators may be infinite
02:46:29 <akegalj_> tikhon: i realized i dont need any traversable
02:46:40 <tikhon> akegalj_: right, you don't have a t type variable in there ;)
02:48:39 <akegalj_> tikhon: yes, thnks for that :)
02:51:05 <xpikab> how do i output hello world to the standard output in haskell?
02:51:12 <Dethkat> Hello everybody, just a simple question for you in whats my 4th day learning Haskell. Im trying to work out the type signature for this. pair x y = (x,y)
02:52:31 <lieven_> > :t (,)
02:52:33 <lambdabot>  <hint>:1:1: parse error on input `:'
02:52:39 <lieven_> :t (,)
02:52:40 <lambdabot> a -> b -> (a, b)
02:53:06 <Iceland_jack> xpikab: putStrLn "Hello, World!"?
02:53:09 <merijn> xpikab: "main = putStrLn "Hello World!""?
02:53:22 <Dethkat> are you talking to me lieven_ ?
02:53:24 <Iceland_jack> You can do
02:53:24 <Iceland_jack>     main = putStrLn "Hello, World!"
02:53:33 <merijn> Iceland_jack: Too slow ;)
02:53:39 <lieven_> Dethkat: yeah. your pair is the same as (,)
02:53:40 <Iceland_jack> heh
02:54:55 <Dethkat> thanks
02:56:39 <Dethkat> is their a simple way for me to work out types.. I know about the :t command but sometimes it doesnt seem to help
02:57:10 <peteretep> Dethkat: can you give it an example of not helping?
02:57:14 <Dethkat> I understand whats a list and a tuple and things like thats
02:57:24 <Dethkat> sure
02:57:35 <Dethkat> one minute
02:58:18 * hackagebot mime-mail-ses 0.2.2.1 - Send mime-mail messages via Amazon SES  http://hackage.haskell.org/package/mime-mail-ses-0.2.2.1 (MichaelSnoyman)
02:59:24 <benmos> Anyone know if there's a GHC call to get the current number of Haskell threads? (couldn't see anything)
02:59:57 <quchen> benmos: Somewhat related: http://hackage.haskell.org/package/base-4.6.0.1/docs/GHC-Conc-Sync.html#v:numSparks
03:00:38 <benmos> Good point. Thanks. Let me see if that will suit my needs.
03:01:20 <Dethkat> Prelude> let pair x y = (x,y) in pair
03:01:20 <Dethkat> <interactive>:26:1:
03:01:20 <Dethkat>     No instance for (Show (t0 -> t1 -> (t0, t1)))
03:01:20 <Dethkat>       arising from a use of `print'
03:01:20 <Dethkat>     Possible fix:
03:01:21 <Dethkat>       add an instance declaration for (Show (t0 -> t1 -> (t0, t1)))
03:01:23 <Dethkat>     In a stmt of an interactive GHCi command: print it
03:01:41 <Dethkat> Sometimes I have this error
03:01:51 <Iceland_jack> Dethkat: Please don't paste entire error messages, use lpaste instead
03:01:52 <Iceland_jack> @lpaste
03:01:53 <lambdabot> Haskell pastebin: http://lpaste.net/
03:02:00 <bahamas> Dethkat: it's preferable that you use http://lpaste.net/ if you want to paste more lines of code
03:02:06 <Iceland_jack> Dethkat: Otherwise, you're trying to show a function (‘pair’) which won't work
03:02:06 <bahamas> heh
03:02:08 <Dethkat> sorry next time :)
03:02:13 <Iceland_jack> > let pair = (,) in pair 'a' False
03:02:16 <lambdabot>  ('a',False)
03:02:17 <Iceland_jack> That works
03:02:31 <Okasu> Dethkat: http://www.haskell.org/haskellwiki/Show_instance_for_functions
03:03:19 * hackagebot filesystem-conduit 1.0.0.2 - Use system-filepath data types with conduits. (deprecated)  http://hackage.haskell.org/package/filesystem-conduit-1.0.0.2 (MichaelSnoyman)
03:03:59 <Okasu> > foldl (+) a [b,c,d]
03:04:01 <lambdabot>  a + b + c + d
03:04:17 <Dethkat> Thanks
03:05:09 <bahamas> Okasu: how come that doesn't complain about a,b,c,d not being in scope?
03:05:48 <supki> :t a
03:05:51 <lambdabot> Expr
03:05:52 <Okasu> benmos: See link i posted earlier.
03:05:53 <shiona> > fix (+1) -- hmm
03:05:57 <lambdabot>  mueval-core: Time limit exceeded
03:06:17 <peteretep> > show a
03:06:19 <lambdabot>  "a"
03:06:29 <peteretep> > show [a..z]
03:06:30 <lambdabot>  "*Exception: not a number
03:06:37 <benmos> @Okasu - thx - earlier today?
03:06:37 <lambdabot> Unknown command, try @list
03:07:22 <Okasu> benmos: http://hackage.haskell.org/package/simple-reflect
03:08:31 <pyon> Is there any way to use the :i command from ghci to check the definition of a *member* from an associated data family?
03:08:32 <benmos> Thx - but I'm not sure I understand the connection to number of outstanding GHC threads ..
03:09:51 <Okasu> Simple reflect along with ShowFunctions probably will help Dethkat to understand some of the basic concepts, that's why I mentioned it.
03:10:51 <benmos> Ok - thought you were referring to the question I'd asked. np. (Am trying 'numSparks' anyway).
03:13:11 <bahamas> benmos: he was talking to me
03:13:21 * hackagebot html-conduit 1.1.0.2 - Parse HTML documents using xml-conduit datatypes.  http://hackage.haskell.org/package/html-conduit-1.1.0.2 (MichaelSnoyman)
03:13:23 * hackagebot conduit-combinators 0.2.2 - Commonly used conduit functions, for both chunked and unchunked data  http://hackage.haskell.org/package/conduit-combinators-0.2.2 (MichaelSnoyman)
03:13:25 * hackagebot wai-test 2.0.1 - Unit test framework (built on HUnit) for WAI applications.  http://hackage.haskell.org/package/wai-test-2.0.1 (MichaelSnoyman)
03:14:28 <peteretep> I have a function: [a] -> b
03:14:41 <peteretep> It doesn't matter what order [a] is in
03:14:52 <peteretep> I want to make that an assertion for QuickCheck
03:14:59 <peteretep> That yo'll get the same b, regardless of the order of a
03:15:14 <peteretep> At the moment I'm doing a god-awful combination of permutations before passing that to hunit
03:15:36 <Aetherspawn> maybe convert it to a set
03:15:54 <Aetherspawn> actually, misunderstood.
03:15:55 <peteretep> http://lpaste.net/6085784494529314816
03:16:01 <peteretep> That's what I have at the moment
03:16:06 <peteretep> works, but it's ugly
03:17:04 <Iceland_jack> peteretep: for the record a nicer way of doing the “filter (\x -> length x == 2)” might be to do
03:17:04 <Iceland_jack>     [ … | [x, y] ← subsequences ... ]
03:17:18 <peteretep> Iceland_jack: Yes, that's a good idea
03:17:26 <Iceland_jack> > [ xs | xs@[_,_] <- subsequences "test" ]
03:17:27 <lambdabot>  can't find file: L.hs
03:17:30 <Iceland_jack> > [ xs | xs@[_,_] <- subsequences "test" ]
03:17:31 <lambdabot>  ["te","ts","es","tt","et","st"]
03:17:38 <peteretep> Eventually I want to bribe someone some cash-money to code review this for me
03:18:28 <Iceland_jack> peteretep: a nicer way would be to create generator that, given a list, gives you a permutation of it
03:18:29 <Aetherspawn> money, for haskell, in 2014? heresy
03:18:45 <Iceland_jack>     arbitraryPermute :: [a] -> Gen [a]
03:18:45 <Iceland_jack>     arbitraryPermute = ...
03:18:57 <peteretep> Iceland_jack: I know that Generators will be part of the solution here
03:19:00 <peteretep> Maybe I should start with that
03:23:51 <ion> λ> let permute :: [a] -> Gen [a]; permute xs = map fst . sortBy (comparing snd) . zip xs <$> vectorOf (length xs) (arbitrary :: Gen Double) in sample' (permute ['a'..'j'])
03:23:54 <ion> ["abcdefghij","adeghjibcf","cdhgibfeja","bfjcegihad","hjgecadbif","fbgacidjhe","djfbiahegc","fagbheijcd","fchaejdgib","eiajhbgdfc","jbeacdghif"]
03:26:18 <ion> or: λ> let permute :: [a] -> Gen [a]; permute xs = do { ys <- mapM (\x -> (,x) <$> (arbitrary :: Gen Double)) xs; return (map snd (sortBy (comparing fst) ys)) } in sample' (permute ['a'..'j'])
03:27:31 <Iceland_jack> Or
03:27:31 <Iceland_jack>     permute xs = do idx ← chose (0, (length xs!)-1); return (premutations xs !! idx)
03:27:31 <Iceland_jack> ;)
03:27:42 <ion> heh
03:27:45 <Okasu> benmos: Sorry, erroneous tab completion, I was indeed talked to bahamas.
03:28:13 <benmos> no problem!
03:32:37 <Iceland_jack> ion: Maybe there should be a sortByM where you can sort by a monadic value, thereby allowing you to do away with the whole tuple/sortBy (comparing snd)
03:33:23 * hackagebot classy-prelude 0.8.1 - A typeclass-based Prelude.  http://hackage.haskell.org/package/classy-prelude-0.8.1 (MichaelSnoyman)
03:34:19 <ion> iceland_jack: factLength xss@(_:xs) = length xss * factLength xs; factLength [] = 1
03:35:19 <Iceland_jack> ion: the cases are in the wrong order no?
03:35:41 <ion> They are?
03:35:43 <Iceland_jack> no never mind
03:36:06 <Iceland_jack> but it returns 0 for every non-empty case, I'm not sure how that's related to the previous discussions :)
03:36:14 <ion> It does?
03:36:37 <Iceland_jack> eh no ion, I wrote it with ‘length xs’ :) never mind
03:37:17 <ion> I’m proud of this function. Not only is it horribly inefficient, it’s also prone to hard-to-notice bugs.
03:37:59 <Iceland_jack> heh
03:38:21 <medfly> sup haskellers
03:40:29 <ion> srelleksah pus
03:40:52 <tdammers> ewww
03:43:48 <Fuuzetsu> wouldn't GHC now the length of xs after we take length of xss making us check the length only once and look up everything else or is it not that clever in this case?
03:45:11 <ion> fuuzetsu: GHC does not memoize the results of function calls.
03:45:45 <peteretep> ion: I don't think that's the same as memoizing
03:45:51 <peteretep> memoization implies state
03:45:54 <Fuuzetsu> that seems inconsistent with what I know
03:46:17 <peteretep> I also would have thought GHC would optimize identical expressions
03:46:37 <peteretep> That's one of the reasons you need IO monads
03:47:40 <Peaker> Why is my Control.Exception.finally clause not executing upon Ctrl-C ?
03:47:50 <Peaker> I thought Ctrl-C was translated to an async exception of UserInterrupted?
03:47:59 <Peaker> (GHC 7.6.3)
03:50:10 <Iceland_jack> ion: Apparently that functions exists in Control.Monad.ListM and you can write
03:50:11 <Iceland_jack>     permute = sortByM (\_ _ → elements [LT, GT])
03:50:11 <Iceland_jack> :)
03:50:14 <Peaker> I have code like:   (putStrLn "A" >> body) `finally` (putStrLn "B" >> more)  and "A" is printed but not "B" !
03:50:16 <Iceland_jack> *that function
03:50:25 <Peaker> (and the program exits)
03:51:26 <Iceland_jack> Peaker: Does it work it you omit the ‘body’ and ‘more’?
03:51:54 <Peaker> Iceland_jack: If I omit them the process will exit too quickly :)  It does run "B" if I wait instead of Ctrl-C
03:53:24 * hackagebot derive 2.5.14 - A program and library to derive instances for data types  http://hackage.haskell.org/package/derive-2.5.14 (NeilMitchell)
03:57:06 <supki> Peaker: does it exit silently on the first ^C?
03:58:30 <Peaker> supki: yeah
04:00:55 <ion> iceland_jack: nice
04:16:27 <Peaker> interestingly, if I install my own SIGINT handler that prints stuff to stderr, in an emacs shell it doesn't seem to print anything, and in a different terminal emulator it does
04:17:02 <Peaker> in an emacs terminal emulator it does.. probably some artifact of an emacs shell
04:18:28 <Peaker> perhaps my finally clause ran all along, and this same artifact in emacs shell caused my print not to appear after the Ctrl-c (which is sent in a special way in an emacs shell)
04:27:25 <bahamas> >fmap (*2) Left 4
04:27:29 <bahamas> > fmap (*2) Left 4
04:27:33 <lambdabot>  No instance for (GHC.Show.Show b0)
04:27:33 <lambdabot>    arising from a use of `M811906684210292629215743.show_M8119066842102926292...
04:27:33 <lambdabot>  The type variable `b0' is ambiguous
04:27:33 <lambdabot>  Possible fix: add a type signature that fixes these type variable(s)
04:27:33 <lambdabot>  Note: there are several potential instances:
04:27:49 <bahamas> hm, this is a different error from what I'm getting in ghci
04:28:16 <bahamas> there, it says that there is no instance of (Num (Either a0 b0))
04:29:03 <Iceland_jack> ion: (was walking the dog), it probably has a different distribution than what you did
04:29:09 <bartavelle> > fmap (*2) (Left 4)
04:29:12 <lambdabot>  Left 4
04:29:45 <bahamas> hmm
04:29:51 <bartavelle> stuff like "(Num (Either a0 b0))" mean you wrote a number where it expected a more complex type, which usually mean you did some typo
04:31:08 <bahamas> what is the computation? (Left 4) * 2?
04:32:06 <bahamas> :t fmap (*2) (Left 4)
04:32:08 <lambdabot> (Num b, Num a) => Either a b
04:33:45 <ion> iceland_jack: Yeah, but for what peteretep asked, it wouldn’t really matter.
04:33:57 <Iceland_jack> true
04:34:49 <bahamas> is there a way to see the definition of a type class method? for example, to see fmap for Either?
04:35:20 <Reite> Can I specify a cabal sandbox "add-source" somewhere so I dont have to add it when I create the sandbox? In my cabal file or a sandbox file for example?
04:37:00 <pyon> bahamas: I do not think so, but I think replacing the type constructor variable "f" with "Either e" in fmap's type signature should tell you what is going on.
04:44:36 <fizruk> @src Either fmap
04:44:40 <lambdabot> fmap _ (Left x) = Left x
04:44:44 <lambdabot> fmap f (Right y) = Right (f y)
04:45:33 <fizruk> bahamas: ^
04:49:01 <ion> bahamas: Unfortunately Haddock doesn’t provide links from instances to the source, but instances are usually defined in the same file as either the data type or the class. Hoogle for Either and look at the source, the Functor instance happens to follow the data type definition immediately.
04:52:29 <bahamas> fizruk, ion: thank you both
04:52:35 <quchen> bahamas: There is no general and easy way. Lambdabot has a static handwritten source database with easily readable (i.e. not necessarily the actual) definitions. Other than that there's the source directly on Hackage, or the source links in the Haddock documentation.
04:52:38 <quchen> Lambdabot @src database: https://github.com/mokus0/lambdabot/blob/master/lambdabot/State/source
04:53:45 <bahamas> quchen: I was asking about ghci :)
04:54:05 <bahamas> ah, I saw that I didn't mention that
05:00:27 <tanmaig> Hi! How should I go about generating TH code with TH? I need to automatically generate some Yesod-persistent stuff, which itself is TH.
05:00:39 <tanmaig> Does that make sense?
05:02:43 <quchen> Isn't TH just Haskell code?
05:03:36 <quchen> Ah, you also need a $() generator in TH. Hmm.
05:05:21 <bergmark> yowsa
05:05:41 <bergmark> tanmaig: if only this was lisp :-)
05:07:03 <bahamas> can anyone remind me why fmap applies f to Right y but not to Left x? I understand that it can't apply it to both, because the types of x and y might be different
05:07:33 <kuribas> I've been thinking about how record update could be made easier.  Wouldn't this syntax be nice: struct field {\f -> do_something f}
05:07:35 <peteretep> Isn't the left-hand-side meant to be for errors?
05:07:36 <quchen> You can't even write a Functor instance that maps over Left.
05:07:39 <bergmark> bahamas: because the functor instance is for Either a
05:08:16 <tanmaig> bergmark: Sigh. So it's not possible then? Generating quasi-quoted TH with TH?
05:08:34 <mr-> quchen: no type level flip? ;-)
05:08:51 <bergmark> tanmaig: i don't know, and i don't like th to start with ;)
05:09:08 <kuribas> Meaning the same as "struct {field = f (field struct)}
05:09:42 <kuribas> Meaning the same as "struct {field = (\f -> do_something f) (field struct)}" actually.
05:09:58 <quchen> mr-: Nope :-( You can write a type-level flip, but then that needs to be fully applied so you can again not write the instance. Plus you need a couple of extensions to even get here.
05:10:15 <kuribas> And extendable to nested structures...
05:10:18 <bahamas> bergmark: I thought it would be something about that. I'm trying to get my head around it
05:10:54 <tanmaig> bergmark: Aw man. :(  Maybe I can generate those TH snippets as strings and print them to a file and then call the Haskell compiler. Ugly, but oh well.
05:11:22 <quchen> kuribas: Lens.  struct & field %~ f
05:14:19 <bahamas> I think I get it
05:14:48 <kuribas> quchen: Isn't lens very complicated?
05:15:07 <kuribas> quchen: Does it work automatically with records, or do I need to lensify records?
05:15:44 <quchen> kuribas: There are TH functions to generate lenses for you. "makeLenses ''Foo" is all you need.
05:16:24 <quchen> Lens is internally very complicated, and superficially it alternates between incomprehensible (type errors) and very easy (to use otherwise).
05:16:54 <kuribas> quchen: Hm, while lens maybe great, I feel it is to patch up weaknesses in haskell...
05:17:21 <quchen> Lens started out to make record updates a little less awkward.
05:17:35 <quchen> Then edwardk happened.
05:17:49 <quchen> Now it's more powerful than anyone ever imagined.
05:18:00 <quchen> (There are other devs of course.)
05:18:24 <kuribas> So something I'll have to learn then :)
05:18:31 * hackagebot yesod-bin 1.2.7.3 - The yesod helper executable.  http://hackage.haskell.org/package/yesod-bin-1.2.7.3 (MichaelSnoyman)
05:18:33 * hackagebot yesod-core 1.2.9 - Creation of type-safe, RESTful web applications.  http://hackage.haskell.org/package/yesod-core-1.2.9 (MichaelSnoyman)
05:18:35 * hackagebot unix-process-conduit 0.2.2.3 - Run processes on Unix systems, with a conduit interface (deprecated)  http://hackage.haskell.org/package/unix-process-conduit-0.2.2.3 (MichaelSnoyman)
05:18:36 <quchen> So it patched up a small weakness with a giant niceness ;-)
05:18:50 <quchen> There are other "lensy" libraries, fclabels is a lot simpler for example.
05:20:12 <quchen> 'lens' got carried away in many places, so maybe you're looking for something more basic. But even then, you should have used it a little bit. It's not actually that complicated to use after a short while, the major problem is that you can't really let the types (compilation errors) guide you.
05:21:05 <quchen> Also see my fancy lens operator cheat sheet :-) https://github.com/quchen/articles/blob/master/lens-infix-operators.md
05:22:01 <kuribas> Ok, I'll check it out.
05:22:29 <RichyB> quaestor, "you can't really let the types (compilation errors) guide you" ← because they're too polymorphic?
05:23:22 <quchen> Type errors typically include either very long expanded type synonyms or very abstract unexpanded type synonyms.
05:23:41 <quchen> :t (<%@~) -- Conceptually not a difficult operator to understand and use
05:23:44 <lambdabot> Overloading (Indexed i) q ((,) b) s t a b -> (i -> a -> b) -> q s (b, t)
05:25:24 <pyon> Haddock doesn't support type families yet? :-(
05:26:32 <mvr_> Cale: thanks for the help a day or two ago
05:26:36 <Guest36766> What's a use case of a comonad?
05:27:04 <Cale> mvr_: no problem :)
05:27:44 <mvr_> I have another basic question, I'm trying to get a handle on using the state monad
05:28:05 <mvr_> is there a nicer way of doing this: http://lpaste.net/101500 ?
05:29:39 <kuribas> maybe "modify (flip f)"
05:29:57 <kuribas> hm wait, no...
05:30:05 <exlevan> but the code doesn't modify state, does it?
05:30:10 <Iceland_jack> gets probably
05:30:37 <mvr_> it doesn't, but I was hoping to use statef in a do block so I don't have to s <- get earlier
05:30:58 <mvr_> is this a silly thing to try and do?
05:31:01 <kuribas> statef a = liftM (flip f a) get
05:32:19 <osa1> I have a C library installed somewhere in my $HOME, how can I point it's pkgconfig that to cabal?
05:32:44 <exlevan> kuribas: could you provide an example of how you would use statef, and what you don't like about it? The snippet you posted looks fine to me
05:32:49 <khyperia> mvr_, whenever you have "x >>= \y -> return z", you should probably use fmap (aka liftM)
05:33:17 <RichyB> osa1, does setting PKG_CONFIG_PATH=$HOME/my_lib/lib/pkgconfig work for you?
05:33:22 <khyperia> which "x >>= \y -> return z" == "liftM (\y -> z) x", I think
05:33:29 <osa1> RichyB: let me try
05:33:41 <khyperia> but then kuribas decided to pointfree-i-fy the middle function with flip
05:34:04 <osa1> RichyB: yup, that worked.,
05:34:16 <osa1> RichyB: I'd still like to know if there's a way to pass pkgconig file to cabal ...
05:34:38 <kuribas> exlevan: It's not my code, but from mvt_, I don't know what he wants it for...
05:36:40 <kuribas> khyperia: I would normally just reverse the argument of f in my code if I could.
05:37:01 <kuribas> I try to arrange my arguments so they make composition easier.
05:38:25 <khyperia> @pl \a -> liftM (f a) get -- just for testing purposes, this is probably going to blow up and shouldn't be used
05:38:26 <lambdabot> flip fmap get . f
05:38:58 <khyperia> yeah that's confusing, I think that's the function functor (maybe)
05:39:54 <exlevan> it's still state functor, because of get
05:40:11 <RichyB> osa1, pass. I use https://gist.github.com/RichardBarrell/9662785 for adding C libraries to my linker, include, etc, paths.
05:40:18 <khyperia> wait, then how does it know to use fmap instead of liftM? It's generic code...
05:40:46 <osa1> RichyB: heh, okay. I also have similar things in my .zshrc
05:41:21 <allspark> what's the difference between ghc v7 and v6 that enables me to fold (+) 0 [1..10000000] without a SO?
05:42:19 <khyperia> ah, I think @pl automatically assumes liftM = fmap, ignoring the fact that it might not actually have a functor instance
05:42:23 <exlevan> maybe it's smart enougn? flip fmap get . f === (\a -> fmap a get) . f
05:42:40 * khyperia wishes for the AMP
05:43:22 <exlevan> what is AMP?
05:43:37 <khyperia> http://www.haskell.org/haskellwiki/Functor-Applicative-Monad_Proposal
05:43:50 <exlevan> ah, that one
05:53:34 * hackagebot QuickCheck 2.7.1 - Automatic testing of Haskell programs  http://hackage.haskell.org/package/QuickCheck-2.7.1 (NickSmallbone)
05:59:50 <osa1> ghc --make links my program against wrong version of so file. is there a way to point it right version of .so file?
06:00:13 <luite> a non-haskell lib?
06:00:48 <osa1> yeah
06:01:02 <osa1> I'm trying to link my app against a C shared lib but I have several different versions of it installed
06:02:22 <b0bbi10> hello, is this definition right declarative? "tellCar (Car {company = c, model = m, year = y}) = "This " ++ c ++ " " ++ m ++ " was made in " ++ show y" looks like the attributes are assigned to the letters
06:03:00 <osa1> luite: any ideas?
06:03:41 <luite> osa1: hmm, it will be ld picking the wrong one when used with -lxyz
06:03:54 <luite> you can try to pass ld options perhaps?
06:04:02 <osa1> luite: does GHC provide a way for that?
06:04:03 <osa1> let me check
06:05:08 <osa1> luite: passing -L didn't work
06:06:15 <osa1> luite: I don't understand how can it link it against wrong version though, .so file has version number as suffix, like libsomething.so.3 but Haskell bindings requires version 4 of it
06:07:03 <osa1> ldd shows that it definitely links wrong version
06:07:37 <luite> osa1: hmm, i wonder if it's possible to specify the version in the cabal file
06:07:44 <luite> with c-libraries
06:08:14 <osa1> luite: cabal file says "pkgconfig-depends: libsomething >= 4
06:08:30 <osa1> luite: it doesn't have "c-libraries" field
06:08:56 <osa1> luite: oooh wait
06:09:08 <osa1> .so generated by cabal build also linked with wrong version
06:09:26 <no-n> print is basically putStrLn . show, right?
06:09:31 <osa1> no-n: yes
06:09:38 <no-n> ta
06:10:10 <osa1> luite: pfff..... whatever, I think I'll just remove old version and just install latest one.
06:12:59 <luite> osa1: okay :)
06:13:09 <osa1> luite: now it went even worse
06:13:15 <luite> lol
06:13:24 <osa1> luite: ldd <cabal generated so file> prints libzmq.so.3 => not found
06:13:34 <osa1> and compiling my app fails with "error while loading shared files"
06:16:05 <Fuuzetsu> mgsloan: I have a link here to http://mgsloan.nfshost.com/haskroom.png but it 404s, do you still have the image?
06:18:55 <luite> osa1: perhaps run ldconfig again before reinstalling the package?
06:19:01 <luite> if you removed a shared lib
06:19:49 <osa1> luite: what's more interesting is that version 4 of this library actually compiles a file named *.so.3. isn't that 3 supposed to be 4 ?
06:21:02 <osa1> luite: hm something worked.
06:21:09 <osa1> I don't know what but probably calling ldconfig
06:22:46 <eacameron> is it possible to "connect" a Writer monad to putStrLn or something so that you can have pure logging code that happens to write to a file?
06:23:18 <eacameron> as a stream, of course
06:43:38 * hackagebot hweblib 0.6.2 - Haskell Web Library  http://hackage.haskell.org/package/hweblib-0.6.2 (AycanIrican)
06:43:40 * hackagebot diagrams-builder 0.5.0.6 - hint-based build service for the diagrams graphics EDSL.  http://hackage.haskell.org/package/diagrams-builder-0.5.0.6 (bergey)
06:45:01 <Cale> eacameron: Just take the appropriate part of the result from runWriter and write it to a file?
06:45:30 <eacameron> Cale: would that behave as a stream?
06:45:47 <Cale> yes, if you're using something like the list monoid
06:46:17 <eacameron> Cale: awesome!
06:48:02 <quicksilver> eacameron: Cale: it wouldn't print incremenetally though.
06:48:06 <quicksilver> it would print all at the end.
06:48:17 <Cale> Won't it?
06:48:23 <Cale> I suppose it depends on what you do.
06:48:37 <quicksilver> I think you could probably write a MonadWriter instance for IO (or a custom monad which incorporates IO)
06:48:38 * hackagebot diagrams-haddock 0.2.2.4 - Preprocessor for embedding diagrams in Haddock documentation  http://hackage.haskell.org/package/diagrams-haddock-0.2.2.4 (bergey)
06:48:41 <eacameron> I guess that would be lazy IO...and...well...we know where that ends up
06:48:43 <quicksilver> which putStrLns immediately.
06:48:53 <Cale> You don't even need lazy IO for this
06:48:58 <quicksilver> then you could have your function signatures just using MonadWriter m =>
06:49:12 <quicksilver> and you could run them in pure monads if you wanted to, or in your PutStrLn monad when you didn't want to.
06:49:44 <quicksilver> it might be a pain to implement 'listen' and 'pass' but you don't need to implement them if you know you're not going to use them ;)
06:49:44 <Cale> If you do something like mapM_ putStrLn the monoidal part of the result from a runWriter, then things will be printed as soon as the tells are executed.
06:50:20 <Cale> (and the execution of the whole Writer computation will be forced)
06:50:40 <Cale> (even if it runs forever)
06:50:45 <quicksilver> are you sure, cale?
06:50:50 <Cale> pretty sure
06:51:05 <quicksilver> surely the monoidal part is of the form ((((s1 ++ s2) ++ s3) ++ s4)
06:51:17 <Cale> no, it's associated the other way
06:51:35 <Cale> (It's associated the same way as the binds, which is typically right-leaning)
06:52:10 <Cale> mapM_ putStrLn . execWriter $ forever (tell ["hello"])
06:52:13 <Cale> try that
06:52:35 <quicksilver> yes I see now
06:54:01 <quicksilver> hmm well that's good :) eacameron apologies for the incorrect information ;)
06:54:50 <eacameron> quicksilver: no worries, this is good news
06:57:41 <fizruk> is there a Reverse applicative? e.g. Applicative f => Applicative (Reverse f) such that effects are carried in a reverse order
06:58:29 <Iceland_jack> fizruk: https://hackage.haskell.org/package/transformers-0.3.0.0/docs/Data-Functor-Reverse.html ?
06:58:43 <Iceland_jack> @hoogle Reverse
06:58:43 <lambdabot> Data.Functor.Reverse module Data.Functor.Reverse
06:58:44 <lambdabot> Data.Functor.Reverse Reverse :: f a -> Reverse f a
06:58:46 <lambdabot> Data.Functor.Reverse newtype Reverse f a
06:59:36 <fizruk> Iceland_jack: no, here Applicative instance provides the same order of effects
07:00:18 <fizruk> Reverse f <*> Reverse x   should be  Reverse (flip ($) <$> x <*> f)
07:00:27 <Iceland_jack> hm
07:00:58 <fizruk> just curious, have no real issue/case
07:01:51 <fizruk> (except those where I could use Reverse traversable)
07:08:17 <supki> fizruk: Control.Applicative.Backwards
07:09:09 <Iceland_jack> supki: ah!
07:09:12 <supki> :t backwards
07:09:13 <lambdabot> (Profunctor p, Profunctor q) => Overloading p q (Control.Applicative.Backwards.Backwards f) s t a b -> Overloading p q f s t a b
07:10:18 <quicksilver> stabbed by an edwardk type signature
07:10:35 <kwstas> hello guys! Is there any way to install a package with all its dependencies using cabal? I thought that if i try to run 'cabal install <package-name>' it would install its dependencies automatically, but as i can see, this in not the case. Is there any flag that i need to provide?
07:10:48 <fizruk> supki: thanks!
07:10:51 <quicksilver> it will automatically install all the *haskell* dependencies, kwstas
07:10:55 <edwardk> > (1,2) ^.. backwards both
07:10:57 <lambdabot>  [2,1]
07:10:59 <tdammers> quicksilver: that moment when you enable unicode syntax because you're running out of one-letter type variables...
07:11:02 <quicksilver> maybe you're missing a native library or something.
07:11:57 <edwardk> backwards will take any lens-lke thing and give you another one that traverses its targets in the opposite order.
07:12:22 <kwstas> quicksilver: I tried 'cabal install stylish-haskell' and i get "...There are files missing in the `yaml-0.8.5.1' package.."
07:12:50 <peteretep> Are there any good HAskell style guides?
07:16:00 <quicksilver> that's very odd, kwstas
07:17:18 <kwstas> quicksilver: yes, because some times ago i has installed the specific package without any problem. Is there any way to reset my cabal libraries? Can i just delete the .cabal folder?
07:17:37 <eacameron> I'm trying to use Control.Monad.Writer and I'm getting ambiguous lib: monads-tf-0.1.0.1   or  mtl-2.1.2
07:17:40 <eacameron> which should I use?
07:22:27 <napping> why does ghc-mod flymake show unused-do-bind warnings in other files, but not the current file?
07:26:31 <quicksilver> kwstas: I think it's a bug in stylish-haskell or a bug in your version of yaml
07:26:37 <quicksilver> rather than a problem with your databases.
07:26:57 <fizbin> Is anyone else using a local install of the professional version of the fp complete IDE?
07:27:23 <fizbin> If so, does the IDE backend crash on you regularly and need to rebuild everything from scratch?
07:32:05 <jle`> fizbin: did you talk to fpc people?
07:32:19 <jle`> johnw ^
07:33:03 <kwstas> quicksilver: ok , thanks
07:33:11 <fizbin> jle`: Not yet. We've got an open trouble ticket for other things (slow disk usage expansion on the machine); I basically wanted to know if this was normal behavior first.
07:34:09 <pyon> If I am defining more classes and instances than types and combinators, could it be taken as a sign that I am engaging in architecture astronautry?
07:35:50 <fizbin> :t let f1 :: a' -> a; f1 = undefined; f2 :: b -> a -> c -> q; f2 = undefined in flip (f1 . flip f2)
07:35:51 <lambdabot> b -> a -> c
07:35:54 <fizbin> wtf?
07:37:37 <Fuuzetsu> > "\229"
07:37:39 <lambdabot>  "\229"
07:37:46 <Fuuzetsu> > "\65"
07:37:48 <lambdabot>  "A"
07:38:57 <Fuuzetsu> how can I get the codepoint of a character?
07:39:08 <Fuuzetsu> i.e. go from A to \65
07:39:14 <peteretep> > ord "A"
07:39:16 <lambdabot>  Couldn't match expected type `GHC.Types.Char'
07:39:16 <lambdabot>              with actual type `[GHC.Types.Char]'
07:39:24 <peteretep> > ord 'A'
07:39:25 <lambdabot>  65
07:39:29 <Fuuzetsu> > ord '°'
07:39:30 <lambdabot>  176
07:40:46 <peteretep> myOrd \0 = '0'; myOrd x = 1 + myOrd (pred x)
07:41:09 <Fuuzetsu> > ord '∷'
07:41:10 <lambdabot>  8759
07:41:24 <peteretep> > :t '∷'
07:41:25 <lambdabot>  <hint>:1:1: parse error on input `:'
07:41:44 <peteretep> > :t '☃'
07:41:45 <lambdabot>  <hint>:1:1: parse error on input `:'
07:41:50 <peteretep> srsly.
07:41:51 <Iceland_jack> peteretep: Omit the '> '
07:42:01 <peteretep> :t '☃'
07:42:03 <lambdabot> lexical error at character '\152'
07:42:09 <peteretep> heh
07:42:11 * peteretep gives up
07:42:35 <Iceland_jack> peteretep: Hint, it's Char :)
07:42:59 <peteretep> Is Haskell Unicode internally then?
07:43:05 <napping> I think that's just lambdabot pasting '☃' into my ghci prints '\9731'
07:43:29 <Iceland_jack> lambdabot is not Haskell
07:43:48 <napping> I mean the lexical warning
07:43:49 <peteretep> For the snowman to be ord 9731, Haskell thinks in Unicode
07:43:50 <Iceland_jack> > '☃'
07:43:51 <lambdabot>  '\9731'
07:44:23 <napping> Char is unicode, yes
07:46:34 <Fuuzetsu> how do I go from integer -> char?
07:46:51 <peteretep> char
07:47:04 <Iceland_jack> chr or fromEnum
07:47:04 <peteretep> hrm, that's not true
07:47:09 <Fuuzetsu> chr did it
07:47:31 <Iceland_jack> It's not from Integer but you can use fromInteger
07:47:59 <peteretep> let chr 0 = '\0'; chr x = succ (chr (x-1)) in chr 65
07:48:04 <yogert> Hey all, I have a question regarding STM and best practices using it. Just as a way to learn the basics I'm writing a threaded web crawler, and I wasn't sure how to best store state between the threads. For instance, I'd like to keep a set holding all previously visited urls. I suppose i could provide each thread with a TVar Set, but that doesn't seem "proper"
07:48:25 <napping> one shared TVar Set should be pretty reasonable
07:48:38 <bergmark> yogert: why not?
07:48:59 <mm_freak> i have to share this…  optimized haskell outperforming optimized C on a huge array operation =)
07:49:00 <yogert> Oh, okay. I was looking at the section in Real World Haskell and they are using StateT etc etc etc
07:49:01 <yogert> : )
07:49:16 <mm_freak> no BangPatterns, no primops, just regular Foreign.Storable and Foreign.Marshal =)
07:49:27 <yogert> But I found that what they are doing doesn't make sense in my case
07:49:33 <yogert> okay well thanks for the guidance
07:49:41 <_sebastian_> hey all, looks like http://www.haskell.org/haskellwiki/Failure is out-of-date
07:49:50 <napping> StateT would be for passing around stuff inside the thread, like if for some reason you need to make a monad so you have easy access to the TVar everywhere
07:50:44 <yogert> You mean, using StateT for operations being done by a thread in isolation?
07:50:52 <napping> well, that's all StateT does
07:50:54 <mm_freak> haskell version:  http://lpaste.net/101507
07:50:54 <yogert> Not by all the threads together
07:50:58 <yogert> yeah
07:50:59 <yogert> ok
07:51:08 <napping> and probably you just need to check the set at the top of the thread to see if you should even enter a URL
07:51:53 <mm_freak> haskell version annotated
07:51:55 <mm_freak> uhm
07:51:58 <mm_freak> C version annotated
07:52:58 <yogert> ? I was thinking that it would read a url from a TQueue, find other URLs from the fetched page, add those to my Set, and add the unique URLs to my queue
07:54:07 <troydm> is ++ O(1) operation?
07:54:17 <troydm> no wait
07:54:24 <troydm> i meant :
07:54:26 <Iceland_jack> yes
07:54:29 <Iceland_jack> (:) is O(1)
07:54:34 <Iceland_jack> Since (:) is just a constructor
07:54:36 <troydm> thx
07:59:35 <mm_freak> i've also attached compilation instructions…  the magic is done mainly by -fllvm and -funfolding-use-threshold1000
07:59:57 <mm_freak> so haskell will outperform C for these kinds of applications now =)
08:00:15 <jl> @pl (\x -> (x, f x))
08:00:16 <lambdabot> ap (,) f
08:00:23 <mm_freak> interestingly the 'primitive' library produced far slower code
08:00:33 <mm_freak> but i'm sure this was because of bad specialization behavior
08:01:43 <napping> yogert: sure, anything like that. I'm just saying you only need the set to decide which URLs to crawl, and not like inside HTML parsing
08:04:02 <robstewartuk> Simple question about constructor arguments. See https://gist.github.com/robstewart57/9665694 . Is there a way to omit the `s` and `i` arguments in the A and B constructors, just as you would with normal functions e.g. `g` ?
08:04:28 <kuribas> How does a Parsec parser do in comparison to C parsers?
08:05:15 <mm_freak> kuribas: in terms of …?
08:05:21 <Iceland_jack> robstewartuk: No, but you could skipt the lambda case and use a destructor
08:05:42 <Iceland_jack> :t either length id -- robstewartuk
08:05:43 <lambdabot> Either [a] Int -> Int
08:05:57 <kuribas> mm_freak: speed, not ease of use :)
08:06:22 <mm_freak> kuribas: slower in general, much slower if a lot of backtracking is involved
08:06:26 <yogert> napping: Gotcha, thanks!
08:06:50 <mm_freak> kuribas: equally fast in some mostly uninteresting trivial cases and only with a lot of annotations
08:07:12 <mm_freak> kuribas: attoparsec will perform closer to C performance, but still slower
08:07:29 <mm_freak> however, the speed difference will be much closer to linear
08:07:52 <kuribas> mm_freak: That doesn't seem a problem, since backtracking is controlled in parsec (using try).
08:08:07 <mm_freak> kuribas: yes, but some grammers still require a lot of backtracking
08:08:24 <mm_freak> it's not really your choice whether you do backtracking or not…  it's the grammar's and input string's choice =)
08:08:30 <kuribas> I need realtime parsing, but only for relative little text, and not much backtracking.
08:08:40 <kuribas> mm_freak: yeah, true.
08:09:13 <mm_freak> kuribas: if this is mainly about splitting, you can get C-like performance by taking apart the bytestrings yourself, but it requires a lot more code
08:09:33 <mm_freak> at least if you want to do it in a streaming fashion
08:09:46 <tdammers> hmm, I really should polish my parser library some more... it sits somewhat in between parsec and attoparsec
08:10:42 <thebnq> microparsec?
08:11:38 <tdammers> that would have been a good name
08:11:40 <tdammers> but no
08:11:52 <mm_freak> tdammers: any advantage over attoparsec?
08:12:01 <tdammers> mm_freak: yeah. Easier string parsing.
08:12:24 <mm_freak> tdammers: huh?
08:12:26 <tdammers> mm_freak: the idea is that it allows mixing heavier Parsec-style parsers with speedy attoparsec-style bytestring parsers
08:12:53 <tdammers> it's functional, but not feature complete yet
08:12:55 <mm_freak> tdammers: what is a "string"?
08:13:02 <tdammers> [Char] or Text
08:13:10 <tdammers> utf8
08:13:27 <mm_freak> tdammers: note that attoparsec handles Text
08:14:02 <yitz> i'm having trouble installing text-icu on mac os x. hsc2hs seems to be getting lost with paths. never had this before. any ideas?
08:15:04 <tdammers> it's actually been a while, but I remember writing this thing because I wanted to parse things from bytestrings, and I wanted backtracking and all that like in parsec, and an easy way to parse utf-8 strings directly out of a bytestring
08:15:18 <yitz> tdammers: attoparsec backtracks now
08:15:41 <tdammers> as I said, it's been a while :)
08:15:52 <tdammers> (also, learning experience and all that :)
08:16:24 <yitz> tdammers: the main use of attoparsec is for text. you can also use it for bytestrings, but that's rare. bytestrings are usually binary goo nowadays.
08:17:16 <tdammers> 'nowadays'?
08:17:21 <tdammers> heh
08:17:25 <tdammers> they've always been, really
08:17:49 <tdammers> but sometimes, you have a "binary" protocol that contains bits of utf-8
08:17:49 <mm_freak> attoparsec has been backtracking for a long time (at least four years, the time i've been using it)
08:18:00 <Saizan> tdammers: they've been used for text a lot, is probably what yitz meant
08:18:16 <tdammers> yes. "Unix: the bad parts"
08:18:51 <mm_freak> attoparsec works just fine for text…  as said it nowdays parses Text
08:19:08 <mm_freak> attoparsec trades something else:  diagnostics and flexibility
08:19:16 <mm_freak> oops
08:19:20 <tdammers> ah, yes... diagnostics...
08:19:27 <tdammers> I remember shitty error messages
08:19:31 <mm_freak> for example parsec has a transformer variant
08:19:38 <mm_freak> i remember no error messages at all ;)
08:19:39 <mm_freak> well
08:19:41 <joeyh> weird.. yesterday's release of quickcheck broke this: instance Arbitrary POSIXTime where arbitrary = arbitrarySizedIntegral `suchThat` (>= 0)
08:19:43 <mm_freak> "parse failed"
08:19:47 <tdammers> yeah
08:19:59 <joeyh> but, POSIXTime is NominalDiffTime, which is a newtype. How did that ever work?
08:20:03 <yitz> tdammers, Saizan: yeah. for a while we used bytestrings for text as an alternative to String, until the text library was written. bryan himself is one of the authors of text, as well as of attoparsec.
08:20:35 <tdammers> anyway, mine works on Text, ByteString, String, and anything else you hook it up with
08:20:51 <tdammers> I've used it for argument parsing, using [String] as the input type
08:20:53 <mm_freak> mine would work only with Text
08:20:59 <mm_freak> everything else should be stream-converted to Text
08:21:20 <tdammers> the interesting part about allowing *anything* is that you can use a separate lexer if you like
08:21:28 <tdammers> not that I really subscribe to that idea in general
08:21:38 <mm_freak> tdammers: what do you mean?
08:22:01 <tdammers> you could first write a lexer that does Text -> [Token]
08:22:13 <tdammers> then feed that to a Parcom [Token] Token Result
08:22:18 <tdammers> something like that
08:22:26 <yitz> joeyh: data UTCTime = UTCTime {utctDay :: Day, utctDayTime :: DiffTime}
08:22:29 <mm_freak> ah
08:22:41 <joeyh> wait, it's a UTCTime?
08:22:53 <yitz> oh POSIXTime
08:22:59 <joeyh> yeah
08:23:01 <tdammers> or, like in the args example, you can feed a list of strings to the parser
08:23:16 <tdammers> which is actually a very convenient way of parsing command-line args, I have found
08:23:37 <joeyh> either way, an arbitrary Integer shouldn't cast to it, but my code used to compile before the new quickcheck
08:24:56 <yitz> joeyh: so NominalDiffTime has instances for Num, Fractional, Real, and RealFrac
08:25:14 <yitz> (but not Integral)
08:25:56 <mm_freak> tdammers: i'm using optparse-applicative for that right now
08:26:03 <yitz> so fromIntegral would work. perhaps that happened in the previous version of QC but not anymore?
08:26:04 <mm_freak> (not that i'm very happy with it)
08:26:13 <NikolajK> Simple questioN: Given f :: a => b -> c -> d. Do you actually pass f an argument of type a? The type inference of e.g. (+) tells me about (Num a), but when using +, I never need to specify that. At the same time, in System F you do have big \Lambda which want to be fed a type.
08:26:26 <joeyh> yes, and I fixed the code to use fromInteger .. but am puzzled how my old code worked
08:26:28 <tdammers> well, since this is code I control, my feature requests are honored promptly and accurately, which is nice
08:26:29 <joeyh> or what broke it
08:26:43 <yitz> mm_freak: no? i really like optparse-applicative. it's the right concept imo. it's not feature complete though.
08:27:44 <yitz> NikolajK: no. it is a constraint. (you didn't type that exactly right though.)
08:28:04 <merijn> NikolajK: In haskell you don't need to do that, the value of 'a' will be inferred by the compiler
08:28:19 <yitz> NikolajK: so e.g. f :: Num a => a -> b means that a can be any time that has a Num instance.
08:28:23 <yitz> *type
08:28:23 <mm_freak> yitz: it makes certain things too difficult, and i'm planning to write a replacement for it
08:28:30 <mm_freak> yitz: the idea is great
08:28:47 <merijn> NikolajK: It may be interesting to see that GHC uses "core" as an intermediate language, Core is very similar to System F and *will* have an explicit dictionary being passed in, as well as explicit type arguments to polymorphic functions like id
08:29:01 <yitz> mm_freak: why not just add what's missing to optparse-applicative?
08:29:15 <mm_freak> yitz: because i'm making a few conceptual changes
08:29:36 <merijn> NikolajK: Although these are implementation details of how GHC implements haskell, these things are not necessarily required by the haskell standard
08:29:40 <yitz> mm_freak: there are now zillions of opt parsing libraries out there. i ignore any new ones. i would appreciate improvements to optparse-applicative, though, and it does need some.
08:30:08 <Feuerbach> mm_freak: so, do you plan to design the api from scratch?
08:30:29 <NikolajK> so the expression before the => in the type declaration always has to do with some sort of subtyping restriction?
08:30:40 <merijn> NikolajK: In other words, if you apply "(+) :: Num a => a -> a -> a", to "1 :: Int" then the compiler will infer that it uses the Num Int instance
08:30:57 <mm_freak> yitz: the problem with the concept or optparse-applicative is that i can't do this easily:  pick value from command line, fall back to environment, fall back to configuration file…  generate a configuration file and shell script with a set of options optionally
08:30:59 <merijn> NikolajK: It's not really subtyping
08:31:03 <c_wraith> NikolajK: there's no subtyping. It's just a predicate on the types.
08:31:09 <merijn> NikolajK: Actually, it's really not subtyping
08:31:15 <yitz> mm_freak: the main thing it needs is an interface that allows "leftovers" - rather than throwing an error if something isn't parsed, give me the result plus what's left unparsed.
08:31:15 <c_wraith> NikolajK: "the type satisfies this restriction"
08:31:48 <mm_freak> Feuerbach: the API is going to be applicative, just like optparse-applicative
08:31:55 <c_wraith> NikolajK: In the case of a constraint like (Num a), the restriction is that there must be a Num instance declared for the type a.
08:32:10 <mm_freak> yitz: it needs a few more things…  for example optparse-applicative is too much bound to order of arguments
08:32:12 <merijn> NikolajK: I always read "foo :: Num a => a -> a" as "foo has type 'a -> a' IFF 'a' is an instance of Num"
08:32:17 <yitz> mm_freak: basically, a way to be able to build my own app-specific limited monadic behavior. without cheating and making the whole thing monadic instead of applicative
08:32:56 <skypers> hey
08:32:57 <yitz> mm_freak: ? i've never run into that. oh you mean arguments, as opposed to options?
08:33:03 <skypers> I’m definining an EDSL with GADTs
08:33:24 <Feuerbach> mm_freak: applicative is how pieces are combined together. I was referring to how individual applicative values are build (i.e. all the Mod things in optparse-applicative)
08:33:58 <yitz> mm_freak: there are also a lot of missing parsers and mods that i use all the time that i think should be added.
08:34:04 <Feuerbach> mm_freak: I don't find that especially intuitive or well designed
08:34:19 <skypers> and I have a question about ctors type: if I want to handle binary operations, would ctors sig should I take? Add :: a -> a -> E a, Add :: E a -> E a -> E (a,a), Add :: E a -> E a -> E a, and son…?
08:34:22 <mm_freak> yitz: no, options
08:34:31 <yitz> Feuerbach: the whole idea of the Mod things?
08:34:40 <mm_freak> yitz: ./prog -x blah ≠ ./prog blah -x
08:34:47 <mm_freak> and you need a lot of effort to make them equal
08:34:58 <mm_freak> where 'blah' is not an argument, but a command
08:35:11 <mm_freak> Feuerbach: well, i like the idea of the property monoid
08:35:20 <Feuerbach> yitz: not the idea but that particular interface. The types are not intuitive.
08:35:38 <c_wraith> skypers: is the goal to make a monadic DSL?
08:35:39 <yitz> Feuerbach: there are some rough edges, i agree.
08:35:48 <mm_freak> Feuerbach: in general, not the way it's done in optparse-applicative
08:35:49 <skypers> c_wraith: not monadic, no
08:35:53 <skypers> a simple DSL
08:35:59 <skypers> an AST
08:36:24 <NikolajK> c_wraith: how is subtyping specified then, if not imperative by loading more restrictions on the less special type
08:36:30 <mm_freak> yitz: anyway, changing optparse-applicative would be too much work and would result in a completely new API anyway
08:36:31 <c_wraith> Ah, if you want an AST, you don't want the first.  You want the children to be more AST nodes.
08:36:36 <yitz> mm_freak: i'm not sure i agree with that. standard practice is options followed by arguments, and option-like things are treated as arguments.
08:36:44 <mm_freak> yitz: if what you're doing is sufficiently different, i see no point in changing an existing library
08:36:50 <c_wraith> NikolajK: subtyping is when you can say everything of type Foo is also of type Bar
08:36:58 <skypers> I think Add :: E a -> E a -> E a is wrong, because if E can be (a,a,a) or (a,a), I could add (a,a,a) and (a,a) wich doesn’t make sense
08:37:12 <c_wraith> NikolajK: classes aren't types.  They're sets of behaviors types can have
08:37:19 <mm_freak> yitz: "./prog --verbose blah" vs. "./prog blah --verbose"
08:37:36 <skypers> c_wraith: what do you think?
08:37:42 <mm_freak> i see no reason not to allow --verbose in both spots
08:37:47 <yitz> mm_freak: various programs bend that rule in different ways. i'm not sure i'd want to hard code that into the basic design.
08:37:48 <c_wraith> NikolajK: and in Haskell, no concrete types can be used as values of other concrete types.
08:37:55 <skypers> hm
08:38:11 <yitz> mm_freak: have you every used imagemagick? or sox?
08:38:26 <mm_freak> yitz: yes, and sox is a horrible experience
08:38:28 <c_wraith> skypers: Both of the latter two are fine.  The question is what you want Add to do.  If you want it to be arithmetic addition, E a -> Ea -> E a is fine
08:38:35 <skypers> maybe I could simply say that to construct a (a,a,a) and a (a,a) under E, I have to use E2 :: ? -> E (a,a) and E3 :: ? -> E (a,a,a)
08:38:53 <yitz> mm_freak: you probably used the wrong filter and it went off key :)
08:38:55 <skypers> c_wraith: yeah ok
08:39:00 <skypers> thank you
08:39:24 <mm_freak> yitz: the interface was horrible in general…  i understand that it was easier from the programming side, but this is not how we should design user interfaces!
08:39:33 <mm_freak> yitz: the people using your program are humans, not machines
08:39:41 <mm_freak> and i design for humans
08:39:48 <skypers> c_wraith: and now
08:39:58 <skypers> how could I make that E in Show?
08:40:09 <skypers> instance (Show a) => E (a,a) where… is ok
08:40:15 <skypers> it’s ok for E (a,a,a) as well
08:40:18 <c_wraith> skypers: I think for GADTs, you have to write Show yourself
08:40:25 <skypers> but for my lowest type
08:40:28 <skypers> which is something like
08:40:30 <yitz> mm_freak: anyway, they use option-like things in a processing pipeline. so no, you wouldn't always want --verbose in the wrong position to mean the same thing as in the normal position.
08:40:32 <skypers> Cons :: a -> E a
08:40:34 <skypers> it won’t do it
08:40:43 <ystael> @pl \f g x y -> f (g x) y
08:40:44 <lambdabot> (.)
08:40:49 <skypers> so I tricked with Cons :: a -> E (C a) with newtype C a = C a
08:40:50 <ystael> ha
08:41:03 <skypers> I don’t know whether it’s the correct way to deal with that issue
08:41:10 <c_wraith> skypers: Eh?  Why not?  show (Cons a) = "Cons (" ++ show a ++ ")"
08:41:11 <yitz> mm_freak: i suppose it could be an option though. no reason why op-a couldn't support that.
08:41:26 <joneshf-laptop> why is functor in data, and not control?
08:41:36 <skypers> c_wraith: because Cons a is a ctor of E a
08:41:38 <skypers> and
08:41:39 <mm_freak> yitz: so my goal is to make it easy both for the programmer (application configuration code should not get in your way, for which an applicative interface is just the right thing) and the interactor (the UI should be natural, easy and fast)
08:41:52 <joneshf-laptop> rather
08:41:55 <skypers> instance (Show a) => Show (E a) overlaps everything
08:41:56 <skypers> c_wraith: ^
08:41:57 <joneshf-laptop> what is the meaning of Data
08:41:59 <joneshf-laptop> and Control
08:42:06 <mm_freak> yitz: there are a lot of things optparse-applicative does not support…  for example:  -vvvx blah
08:42:13 <skypers> that’s why I’ve added the C little guy
08:42:13 <mm_freak> yitz: where 'blah' is an argument to '-x'
08:42:21 <c_wraith> skypers: it really shouldn't.  put your GADT and your attempted Show instance on lpaste, or something.
08:42:29 <skypers> ok
08:42:33 <mm_freak> yitz: but those can be fixed without conceptual changes, so feel free to submit a patch =)
08:43:21 <mm_freak> yitz: you know, i could have submitted patches to the yampa team instead of making netwire, but then the development cycle would be much longer and i couldn't implement some of the ideas that i did…  it would hold me back from being really innovative
08:43:31 <yitz> mm_freak: one thing that makes interfaces usable is standardization. there are written standards about how command line interfaces are expected to work. i take it you're planning on just dumping those.
08:43:33 <mm_freak> yitz: so i don't subscribe to the idea of "don't reinvent the wheel" in general
08:43:44 <mm_freak> yitz: not at all
08:43:59 <c_wraith> NikolajK: A very important difference between subtyping and type classes is that if you have a value with the type Num a => [a], you can't have an Int and a Double in the list together.  There's only one type a.  You can choose for it to be Double or Int, but when you do, *every* element of this list must be the same type, because there is no subtyping.
08:44:00 <mm_freak> yitz: in fact i'm planning to follow the unix standard (which optparse-applicative does not follow as closely)
08:44:40 <ystael> @pl \x g -> g . (flip f x)
08:44:40 <lambdabot> flip (.) . flip f
08:44:40 <yitz> mm_freak: no go right ahead. i'm just saying that at this point you'll have to shout quite loudly to be heard in the crowd if you go that route.
08:45:25 <mm_freak> yitz: why would i?  i'm writing the library for myself, then releasing it, so that others can benefit from it, if they want to
08:45:42 <mm_freak> yitz: if i'm the only one using it, i still have made profit =)
08:45:56 <skypers> ah
08:46:01 <yitz> mm_freak: ok fair enough
08:46:04 <skypers> c_wraith: ghc advises to use -XIncoherentInstances
08:46:15 <c_wraith> skypers: that's probably very poor advice
08:46:26 <c_wraith> skypers: when GHC starts advising that, it's time to reconsider. :)
08:46:32 <skypers> well, it works now
08:46:38 <c_wraith> "works" is a relative term
08:46:45 <skypers> ok
08:46:46 <skypers> wait
08:46:49 <c_wraith> IncoherentInstances will make lots of things compile...
08:46:56 <c_wraith> But not work so well when you try to use them
08:47:11 <skypers> I cropped the commented part
08:47:18 <mm_freak> yitz: all the libraries i have on hackage were originally things i needed myself (except acme-schoenfinkel)…  i am happy though that they help others in the community =)
08:47:32 <no-n> i think before bed i'll watch this "don't fear the monad" video on youtube
08:47:32 <mm_freak> in fact at least one person even found acme-schoenfinkel useful =P
08:47:40 <no-n> with brian beckman
08:47:52 <c_wraith> no-n: suddenly, I feel a need to create a Reaper monad.
08:47:55 <yitz> skypers: ghc is assuming you are trying to do something really complex with the type system. the other possibility is that you are trying to emulate OOP in haskell, to which ghc should have said "just don't do that, you'll be sorry."
08:47:59 <NikolajK> c_wraith: okay, so then Haskell doesn't really has polymorphism in the System F sense, where the functions first take type aruments, right? The "forall" doesn't corresponnd to lambda abstractions, it's only used by the type system.
08:48:07 <no-n> c_wraith :)
08:48:14 <mm_freak> no-n: that video is not really that useful in explaining monads, but it's nice nonetheless =)
08:48:17 <NikolajK> Is there also a reason why it's called "class"?
08:48:18 <c_wraith> no-n: it will have more cowbell.
08:48:26 <no-n> mm_freak o
08:48:35 <no-n> mm_freak: nice for what?
08:48:42 <skypers> c_wraith: http://lpaste.net/6605951505621057536
08:48:43 <mm_freak> no-n: entertainment mainly =)
08:48:48 <no-n> heh. ahh.
08:48:56 <no-n> they do seem like a jolly pair.
08:49:38 <no-n> I remember he called "bind" "shove"
08:49:38 <c_wraith> NikolajK: Actually, it does do that, but it's implicit most of the time.  You need to enable GHC extensions to make type application more explicit, and it's still not 100% explicit.
08:49:45 <skypers> if I introduce the type newtype C a = C a
08:49:59 <napping> NikolajK: It's somewhere in between. The Core language is like System F with explicit type application, but at the surface level the type arguments are always inferred
08:50:02 <skypers> and replace Cons :: a -> GPU a by Cons :: a -> GPU (C a)
08:50:11 <skypers> I won’t get the overlapping instance stuff
08:50:23 <yitz> mm_freak: oh i see what acme-schoenfinkel. i'm a little dissappointed - i thought it would provide wrappers to translate things like S, K, I, ap, <*> to their real names.
08:50:42 <c_wraith> NikolajK: as for class, it's called that because it fits the mathematical definition of a class.  It's a class of types.
08:51:03 <napping> NikolajK: in other words, anything with a type with a forall (explicit or implicit) is as polymorphic as it should be in System F, but you can't explicitly pass parameters when you use it
08:51:36 <NikolajK> thanks c_wraith
08:51:41 <napping> You can almost certainly force them to be instantiated the way you want with a type annotation, though
08:51:48 <skypers> any idea c_wraith?
08:51:48 <NikolajK> yeah, it's a class of types, but not a proper class
08:51:54 <NikolajK> it's countable
08:52:15 <NikolajK> I'm also confused about the statement "Data constructors are first class values in Haskell" from the Haskell wiki pages "Constructor". "data" isn't a function right? In data "Tree a = Tip | Node a (Tree a) (Tree a)", what is first clas?
08:52:30 <c_wraith> NikolajK: Tip and Node are first-class
08:52:57 <c_wraith> NikolajK: Tip is a value with type Tree a.  Node is a value with type a -> Tree a -> Tree a -> Tree a
08:52:57 <skypers> dammit
08:53:05 <skypers> if I put GPU (C a)
08:53:10 <c_wraith> NikolajK: they can both be used everywhere you can use any other value with those types.
08:53:15 <skypers> I can’t write the Show instance for Vec2 :: GPU a -> GPU a
08:53:16 <skypers> …
08:53:17 <eacameron> I'm trying to use Control.Monad.Writer and I'm getting ambiguous lib: monads-tf-0.1.0.1   or  mtl-2.1.2; I don't know enough to know which one is the right/latest thing to use?
08:53:22 <c_wraith> skypers: I need to test stuff in GHC.  give me a second
08:53:36 <joe9> need some advice, please. I have a data structure at the core of the functionality. I would like to add a feature as a module. This module needs to add a field to the main data structure. Instead of changing the data structure. is it possible to have an "extensible record/data structure" like functionality?
08:53:49 <yitz> eacameron: use mtl
08:53:54 <mm_freak> yitz: hehe no, it's schönfinkelization =)
08:53:54 <skypers> thank you c_wraith
08:53:57 <napping> eacameron: and probably a cabal sandbox
08:54:27 <eacameron> napping: I'm just messing around in GHCi; but yeah, in general good idea
08:54:34 <mm_freak> yitz: originally i just wanted to put "schoen" and "unschoen" as aliases in there, but generalizing to Category did in fact make this a bit useful =)
08:54:46 <yitz> eacameron: i second napping about the sandbox
08:55:08 <yitz> mm_freak: yes it's a delightful library
08:55:08 <NikolajK> okay, yeah I get it I think. if you construct something of type Tree, that term will be full with instances of the expressions Node and Tip. But I think the notation "Bool = True | False" is pretty bad, it mixes up type and term level
08:55:15 <eacameron> why are there two that provide that?
08:55:23 <dwcook> joe9, not directly – datatypes cannot be given new cases once defined. You could add fields to the datatype and make it "extensible" that way, or perhaps use a typeclass.
08:55:26 <NikolajK> data "Bool = True | False"
08:55:37 <skypers> @src Bool
08:55:38 <lambdabot> data Bool = False | True deriving (Eq, Ord)
08:55:58 <napping> eacameron: I suggest unregistering monads-tf, and building anything that wants it in a sandbox
08:56:29 <eacameron> napping: ahh ok; CatchMonadIO wants it
08:56:30 <yitz> i actually starting using transformers instead of mtl lately
08:56:53 <eacameron> MonadCatchIO
08:57:03 <napping> where's that from?
08:57:13 <skypers> c_wraith: I solution could be to force types of a?
08:57:16 <skypers> damned it’s ugly
08:57:33 <napping> yitz: that's compatible with mtl, isn't it?
08:57:39 <c_wraith> skypers: interesting.  This is perfectly safe, but GHC's instance resolution doesn't find it.  And probably for good reasons.
08:57:41 <skypers> replacing Cons :: a -> GPU a by a set of ConsI :: Int -> GPU Int, Cons …
08:57:41 <eacameron> looks like snap wants it
08:58:04 <napping> eacameron: MonadCatchIO-transformers says it's deprecated in favor of exceptions
08:58:09 <skypers> c_wraith: arf
08:58:24 <skypers> I’ll try something with explicit types then
08:58:36 <skypers> it might not like polymorphic returned types
08:58:49 * hackagebot strict-base-types 0.3.0 - Strict variants of the types provided in base.  http://hackage.haskell.org/package/strict-base-types-0.3.0 (SimonMeier)
08:59:26 <c_wraith> skypers: the underlying problem is that GHC can't derive (Show a1) from (Show a, a ~ (a1, a1)) and (Show b, Show c) => Show (b, c)
08:59:26 <mm_freak> yitz: =P
08:59:53 <c_wraith> skypers: it's clearly logically consistent for it to do so..  But it's probably not sane to try to code it up.
09:00:04 <benzrf> sohum:
09:00:05 <benzrf> *so
09:00:06 <skypers> so what do you suggest?
09:00:09 <benzrf> why are arrows useful...
09:00:57 <skypers> benzrf: I used arrows on a limited machine that couldn’t have bifunctors
09:01:03 <skypers> I used first, second and (***) :)
09:01:08 <c_wraith> skypers: Not writing Show instances for GADTs that depend on Show instances from their type variables is really the only sane thing to do.
09:01:08 <mm_freak> benzrf: they are almost as expressive as monads, but cover things that aren't monads
09:01:22 <skypers> c_wraith: hm
09:01:24 <skypers> wait
09:01:57 <mm_freak> benzrf: and sometimes things are monads, but (>>=) would be highly inefficient, so you go with the arrow interface anyway
09:02:16 <skypers> nope
09:02:21 <c_wraith> skypers: because GADTs introduce extra type variables when you pattern-match their constructors, and you can't refer to those type variables in the instance head.
09:02:27 <skypers> doesn’t work even without the constraint
09:02:52 <c_wraith> skypers: or, more relevantly to this case, in the constraint on the instance head.
09:03:22 <yitz> napping: mtl uses transformers under the hood. it just renames some things. and it doesn't have all of the transformers.
09:04:47 <knz> hi guys
09:06:06 <knz> I have two different ways to instantiate Eq for my custom type T, which I want to use separately in different contexts
09:06:21 <knz> is there a way to specify in the context of an expression/function which instance I am using?
09:06:25 <knz> (for the overloads)
09:06:28 <mm_freak> knz: no, but you can use a newtype
09:06:40 <mm_freak> knz: instances are conceptually global
09:06:45 <knz> aha
09:07:09 <knz> but with newtype I lose the equivalence between individual values of my type across instances
09:07:22 <mm_freak> knz: not sure what you mean
09:07:41 <knz> well if I have newtype T2 = T2 T1
09:07:57 <knz> a value of type T1 is not any more substitutable for one of type T2
09:08:00 <knz> (or the other way around)
09:08:08 <knz> because they now belong to different types
09:08:22 <byorgey> knz: right. There is no way to use two different Eq instances for the same type.
09:08:26 <knz> yay
09:08:31 <mm_freak> knz: newtype T2 = T2 { t1 :: T1 }
09:08:38 <mm_freak> T2 x, t1 y
09:08:44 <mm_freak> where x :: T1, y :: T2
09:09:02 <benzrf> but what are arrows USEFUL for
09:09:05 <mm_freak> it's a straightforward wrapping/unwrapping and not more writing work that you would have with specifying the instance to use =)
09:09:09 <joe9> What is the haskell mechanism when the functionality needs "extensible record"? Add another record including that record? I am guessing that there has to be something better than that.
09:09:13 <benzrf> :\
09:09:20 <benzrf> composing things in certain ways?
09:09:45 <NikolajK> c_wraith: http://i.imgur.com/q6qV4zw.jpg
09:09:50 <mm_freak> benzrf: static information (not used a lot in practice), for example:  data State s a = State { usesPut :: Bool, runState :: s -> (s, a) }
09:10:01 <mm_freak> benzrf: also FRP (netwire and yampa)
09:10:33 <mm_freak> benzrf: proper arrows are strictly less expressive than monads
09:11:01 <mm_freak> you don't buy new combinators, in fact you give up some of them…  what you buy is sometimes speed, and sometimes the whole ability to do what you want to do
09:11:10 <merijn> benzrf: The arrows paper has some example use cases
09:11:35 <benzrf> hmmmm
09:11:50 <benzrf> so for any value-in value-out type of thing, there may be ways you want to compose iteratee_
09:11:53 <benzrf> *it
09:11:55 <benzrf> and that is what arrows are for?
09:12:23 <mm_freak> benzrf: if you have a monad for your purpose, arrows are useless
09:12:38 <mm_freak> arrows are only useful if a monad does not exist or if it's too inefficient
09:13:00 <dwcook> joe9, I basically told you. Here, let me try to find some examples
09:13:07 <mm_freak> to see a horrible counterexample see the hxt, where arrows are only used for coolness =)
09:13:28 <mm_freak> it's a monadic library and i never understood why it uses arrows at all
09:13:51 <dwcook> joe9, this post has some examples: http://stackoverflow.com/questions/6889715/extending-a-datatype-in-haskell
09:14:00 <joe9> dwcook: I could not understand what you said. Sorry about that. How can a typeclass hold data?
09:14:16 <joe9> dwcook: thanks, let me check the examples. Thanks again.
09:14:30 <c_wraith> NikolajK: you should see Napping's response to your question above.
09:14:52 <uiop> joe9: you can't do the equivalent of (C++) "struct bar : foo {..}" in any transparent way, no
09:14:55 <dwcook> joe9, the data lies in each instance of the typeclass. So, essentially the cases would be types.
09:16:06 <joe9> uiop, I see the same situation in xmonad and I see that they used something called Extensible State. I am not sure if it is relevant though.
09:17:12 <uiop> joe9: there are all kinds of "tricks" to achieve something approximating it
09:17:29 <uiop> but nothing that is supported cleanly by the language
09:17:35 <dwcook> joe9, I'm having a hard time coming up with a convincing example of adding a new field to a type, though if you presented your specific problem I might be able to show you what I mean
09:18:19 <NikolajK> Yeah, thanks napping: and c__wraith for your elaborations, got a much clearer picture now
09:19:45 <mm_freak> benzrf: the general rule of thumb is:  1. find an applicative functor for your application, 2. find a monad…  in order of preference…  only if both of these fail (applicative is insufficient, monad does not exist), go with an arrow
09:19:49 <NikolajK> ah, another thing. if System F doesn't have decidable type inference, why exactly does it work with Hidley-Milner? What does it drop over the logical system for the sake of having type inference?
09:20:25 <benzrf> arrows schmarrowd
09:20:27 <benzrf> s
09:21:08 <c_wraith> NikolajK: Hindley-Milner works because it assumes all type applications are prenex, and there's no polymorphic recursion.
09:21:14 <joe9> dwcook: ok, thanks.
09:21:59 <NikolajK> c_wraith: you mean it assumes the type variables have already been passed?
09:22:00 <c_wraith> NikolajK: the Haskell standard allows polymorphic recursion, but only with explicit type annotations.  GHC has extensions that allow non-prenex type application, but only with explicit annotations.
09:22:32 <c_wraith> NikolajK: no, prenex means that all type variables stand for a concrete type, not something polymorphic
09:23:02 <Nafai> Interesting, Facebook's new language is implemented in OCaml.
09:23:40 <c_wraith> Nafai: well, facebook does have Haxl now, too, which is a haskell library for doing concurrent data aquisition from heterogenous sources.
09:23:44 <NikolajK> c-wraith: so the forall only ranges over a domain without types starting with forall?
09:23:51 <c_wraith> NikolajK: correct
09:23:53 <Nafai> c_wraith: Oh, nice.
09:24:32 <c_wraith> Nafai: Haxl is what Simon Marlow and Brian O'Sullivan have been working on at facebook.  (and others, but they're the big names)
09:25:01 <skypers> c_wraith: hey
09:25:06 <Nafai> c_wraith: It looks like bos has been working on Hack, too.
09:25:31 <skypers> how should I proceed if I want to enable users to mix expression type in the Add ctor?
09:25:44 <skypers> Add :: GPU a -> GPU b -> GPU c?
09:25:49 <skypers> it’s a bit too much
09:25:50 <skypers> I guess
09:26:21 <c_wraith> skypers: you can write that, but the types a and b are existentially quantified there
09:26:31 <skypers> yes
09:27:06 <skypers> huh
09:27:10 <skypers> you mean b and c right?
09:27:14 <c_wraith> No
09:27:23 <c_wraith> c is in the type of the final expression
09:27:23 <skypers> oh right
09:27:33 <skypers> the type of the GPU a
09:27:34 <skypers> ok
09:28:03 <c_wraith> Interestingly, with GADTs, existential quantification doesn't mean you're stuck.  You can still recover some type information by pattern-matching on constructors, in theory.  But I don't think you're set up that way.
09:28:33 <skypers> the idea is that for now, it’s Add :: GPU a -> GPU a -> GPU a
09:28:44 <skypers> if I have GPU (Int,Int) and GPU (Int,Int), that’s quite ok
09:28:59 <skypers> but I’d like it ok as well for GPU (Int,Int) and Int
09:29:32 <skypers> well I guess for that special kind of operation, I’ll use a fmap
09:30:03 <skypers> fmap (*2) (Vec2 (I 2) (I 8))
09:30:06 <skypers> something like that
09:30:28 <skypers> Vec2 2 8 should make it as well since I is in Num
09:30:34 <skypers> ok, thank you c_wraith
09:30:35 <c_wraith> You won't be able to write a legal Functor instance for your GADT
09:30:40 <skypers> ah
09:30:47 <c_wraith> assuming that constructor is I :: Int -> E Int
09:30:55 <skypers> dammit, GADTs actually sucks
09:30:57 <skypers> yes c_wraith
09:31:27 <skypers> well, I could write instance Functor GPU where fmap f =
09:31:29 <skypers> huh
09:31:33 <skypers> .
09:32:02 <skypers> I’m not sure whether GADTs extension is a tool or a nightmare.
09:32:20 <c_wraith> It's a tool, but you have to be aware that all it does is add *restrictions*
09:32:32 <c_wraith> You can use GADTs to eliminate a lot of incorrect constructions
09:32:48 <c_wraith> But in doing so, you also eliminate a lot of tools for working on values
09:33:03 <skypers> yeah, Functor is quite an important tool to me
09:33:31 <c_wraith> The thing is...  What should the result be when you do  fmap show (I 3)
09:33:51 <c_wraith> The types indicate the result needs to be E String
09:33:59 <c_wraith> But that means it can't be the I constructor anymore
09:34:06 <c_wraith> Which violates the functor laws
09:34:42 <skypers> indeed
09:34:57 <c_wraith> like I said.  GADTs are a tool for adding restrictions.
09:34:59 <skypers> I can’t change the structure
09:35:09 <skypers> yeah, ok
09:35:16 <skypers> I think I can work around
09:35:20 <skypers> like adding new ctors
09:39:26 <quicksilver> c_wraith: it doesn't *just* add restrictions; it also gives you those restrictions back as theorems when you unpack a value
09:39:31 <quicksilver> c_wraith: so you can count on them.
09:39:36 <quicksilver> that's the bit which makes it neat :)
09:39:37 <quicksilver> but, yes.
09:43:38 <aristid> let's say i have a typeclass, let's call it "Grammar". now using GHC.Generics i can automatically create instances for some types, i think i know how to do that. but there's one thing puzzling me: if the type has a record member or so with an instance of Generic itself, it seems there is no way to "opt out" of the Generic there and just use a user-written instance of Grammar. right?
09:48:26 <peteretep> Anyone know of an Edit distance package for Data.Text?
09:48:41 <peteretep> Maybe I should be converting back in to String
09:48:42 <bergmark> aristid: hmmm
09:49:06 <no-n> what does Beckman mean by function application is multiplication? :S
09:49:56 <Iceland_jack> no-n: He probably means multiplication as the term for a operation of a monoid or group
09:50:10 <napping> are they talking about church numerals?
09:50:30 <no-n> hmm
09:50:40 <Iceland_jack> Not actually multiplying numbers
09:51:18 <napping> that's power, never mind
09:52:39 <bergmark> aristid: you just pick how you define the instance so the inner members will just have the non-generic constraint
09:53:19 <bergmark> aristid: for example: instance (ToJSON c) => GtoJson (K1 a c) where gtoJSONf _ _ (K1 a) = Left [toJSON a]
09:54:04 <aristid> bergmark: oh i think my question was invalid
09:54:23 <aristid> GHC.Generics seems to only peel up one type at a time
09:54:26 <bergmark> aristid: i think so too :-) but i had to think about it for a bit
09:54:50 <aristid> bergmark: please excuse me:D i find GHC.Generics to be confusing still
09:55:11 <aristid> but the way it looks now, it seems like it perfectly solves what i want. yay
09:55:22 <bergmark> aristid: no worries! i just jumped into it a couple of months ago
09:55:44 <aristid> yea i wish i had something like that in c++
09:56:30 <bergmark> i rewrote our json deriving library from regular+json to generics+aeson
09:56:54 <aristid> i thought aeson only supports syb?
09:57:41 <bergmark> they have a generics module, but it's deprecated in favor of TH, but either way it didn't let us specify the format we wanted so we use our own implementation
09:58:14 <aristid> fair enough
09:58:55 * hackagebot snap 0.13.2.4 - Top-level package for the Snap Web Framework  http://hackage.haskell.org/package/snap-0.13.2.4 (DougBeardsley)
09:59:37 <no-n> @hoogle (a -> b)
09:59:38 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
09:59:38 <lambdabot> Prelude ($) :: (a -> b) -> a -> b
09:59:38 <lambdabot> Data.Function ($) :: (a -> b) -> a -> b
10:03:55 * hackagebot som 7.2.2 - Self-Organising Maps  http://hackage.haskell.org/package/som-7.2.2 (AmyDeBuitleir)
10:06:03 <jfischoff> aristid, bergmark: the new aeson uses the same options for TH and GHC.Generics
10:06:36 <aristid> jfischoff: "same options"?
10:06:44 <jfischoff> yes
10:07:10 <jfischoff> http://hackage.haskell.org/package/aeson-0.7.0.2/docs/Data-Aeson.html#v:gParseJSON
10:07:18 <jfischoff> http://hackage.haskell.org/package/aeson-0.7.0.2/docs/Data-Aeson-Types.html#t:Options
10:09:59 <aristid> jfischoff: oh you mean that it is configurable?
10:11:08 <jfischoff> yeah
10:17:06 <czro_> Hello. How do i run cabal test with the equivalent of "+RTS -N"?
10:18:57 * hackagebot antisplice 0.13.1.0 - An engine for text-based dungeons.  http://hackage.haskell.org/package/antisplice-0.13.1.0 (implementation)
10:18:59 * hackagebot ironforge 0.1.0.20 - A technical demo for Antisplice.  http://hackage.haskell.org/package/ironforge-0.1.0.20 (implementation)
10:19:01 * hackagebot antagonist 0.1.0.11 - A web interface to Antisplice dungeons.  http://hackage.haskell.org/package/antagonist-0.1.0.11 (implementation)
10:20:42 <bergmark> jfischoff: it's not configurable enough for us, exposing all the possible cases would essentially be "write your own generics" anyway i guess :-)
10:28:57 * hackagebot cabal-cargs 0.2 - A command line program for extracting compiler arguments from a cabal file.  http://hackage.haskell.org/package/cabal-cargs-0.2 (DanielTrstenjak)
10:28:59 * hackagebot yesod-test 1.2.1.1 - integration testing for WAI/Yesod Applications  http://hackage.haskell.org/package/yesod-test-1.2.1.1 (MichaelSnoyman)
10:32:59 <Denommus> I'm struggling a bit with the "do" syntax
10:33:41 <Denommus> I want to convert the following to simply use >>=: content <- readFile file; let line : _ = lines content
10:33:47 <Denommus> but I'm kinda lost on that
10:34:08 <dwcook> do { x' <- x ; f x' } translates to x >>= \x' -> f x'
10:35:18 <dwcook> Woops, missed a do in there
10:35:37 <dwcook> do { x' <- x ; … }, let's say, becomes x >>= \x' -> do { … }
10:35:42 <dwcook> So that's your first step
10:36:07 <dwcook> Are you more interested in knowing how to do the conversion or just the result? Because lambdabot has @undo
10:36:35 <dwcook> @undo do { content <- readFile file; let line = lines content }
10:36:36 <lambdabot> <unknown>.hs: 1: 58:Parse error: Last statement in a do-block must be an expression
10:36:41 <dwcook> Oh of course
10:36:55 <dwcook> @undo do { content <- readFile file; let line = lines content; return line } -- let's just try this for example
10:36:55 <lambdabot> <unknown>.hs: 1: 70:Parse error: }
10:37:39 <dwcook> I'm not sure what the problem is :P
10:37:45 <geekosaur> braces for let
10:37:58 <dwcook> @undo do { content <- readFile file; let { line = lines content }; return line } -- let's just try this for example
10:37:58 <lambdabot> readFile file >>= \ content -> let { line = lines content} in return line
10:38:01 <dwcook> There we go
10:38:05 <Denommus> the complete expression is do { file : _ <- getArgs; content <- readFile file; let line : _ = lines content; putStrLn line }
10:38:24 <dwcook> @undo do { file : _ <- getArgs; content <- readFile file; let line : _ = lines content; putStrLn line }
10:38:24 <lambdabot> <unknown>.hs: 1: 97:Parse error: }
10:38:26 <Denommus> oh
10:38:29 <dwcook> What is even the : there?
10:38:43 <dwcook> That didn't look like correct syntax to me but I thought I might have been crazy
10:38:59 * hackagebot creatur 5.2.4 - Framework for artificial life experiments.  http://hackage.haskell.org/package/creatur-5.2.4 (AmyDeBuitleir)
10:39:06 <Denommus> it's a cons. I just want the first value of getArgs and from lines content (for now)
10:39:08 <geekosaur> @undo do { file : _ <- getArgs; content <- readFile file; let { line : _ = lines content}; putStrLn line }
10:39:09 <lambdabot> getArgs >>= \ a -> case a of { file : _ -> readFile file >>= \ content -> let { line : _ = lines content} in putStrLn line; _ -> fail ""}
10:39:27 <dwcook> Denommus, you might also be interested in the section in the report about do blocks. It provides translations
10:39:33 <Denommus> @undo do { file : _ <- getArgs; content <- readFile file; let line : _ = lines content; putStrLn line }
10:39:33 <lambdabot> <unknown>.hs: 1: 97:Parse error: }
10:39:34 <geekosaur> I amnot sure about precedence but most people write it with parens
10:39:42 <geekosaur> oy
10:39:48 <dwcook> Oh of course, the spaces threw me off
10:40:54 <dwcook> Denommus, this should be of interest http://www.haskell.org/onlinereport/haskell2010/haskellch3.html#x8-470003.14
10:41:45 <robstewartuk> Given a type: `data Foo = Bar String Int`, is there a way to refer to the two arguments of type String and Int with a label, despite the fact that record syntax has not been used by the author of Foo? E.g. in a case pattern match, I know I can say `Foo s i` and use s and i. But can I say Foo{..} and refer to the arguments e.g. by their position?
10:42:16 <dwcook> robstewartuk, I don't believe so
10:42:39 <dwcook> You might be able to achieve something with Template Haskell? I'm not that familiar with TH but it seems conceivable
10:42:56 <Denommus> dwcook: I'm mostly confused because if I have foo <- bar; the type of "foo" won't be IO a, just a
10:43:09 * geekosaur wonders if 7.8 pattern aliases can do that
10:43:10 <bitemyapp> zerokarmaleft: I didn't know people used that damn library.
10:43:29 <dwcook> Denommus, that's because foo is really just the parameter of the function you're binding with
10:43:32 <dwcook> @type (>>=)
10:43:34 <lambdabot> Monad m => m a -> (a -> m b) -> m b
10:43:41 <dwcook> Denommus, foo is the a in the (a -> m b)
10:44:11 <dwcook> Denommus, this is more easily seen if you apply that particular transformation
10:44:36 <Denommus> dwcook: ah
10:44:44 <no-n> how do you use the (a -> b) instance of Monoid?
10:47:08 <pavonia> > mempty 0
10:47:10 <lambdabot>  Could not deduce (Data.Monoid.Monoid t)
10:47:10 <lambdabot>    arising from the ambiguity check for `e_10'
10:47:10 <lambdabot>  from the context (GHC.Num.Num a, Data.Monoid.Monoid (a -> t))
10:47:10 <lambdabot>    bound by the inferred type for `e_10':
10:47:10 <lambdabot>               (GHC.Num.Num a, Data.Monoid.Monoid (a -> t)) => t
10:48:12 <Iceland_jack> > mempty (Sum 0) :: Sum Integer
10:48:12 <Iceland_jack>      
10:48:13 <lambdabot>  Sum {getSum = 0}
10:48:30 <pavonia> b has to be a Monoid too, no?
10:48:48 <no-n> ;-;
10:49:18 <dwcook> no-n, are you asking for an actual reason you might use that?
10:49:24 * dwcook has no idea
10:49:34 <no-n> yes, and how you would do so
10:49:39 <no-n> the instance definition is weird
10:49:57 <no-n> mempty _ = mempty ; mappend f g x = f x `mappend` g x
10:50:04 <dwcook> Oh well "how" is the easy part
10:50:21 <dwcook> It's just const where the return value is another monoidal value, so
10:50:38 <dwcook> > mempty [1, 2, 3]
10:50:40 <lambdabot>  Could not deduce (Data.Monoid.Monoid t)
10:50:40 <lambdabot>    arising from the ambiguity check for `e_1123'
10:50:40 <lambdabot>  from the context (GHC.Num.Num t1, Data.Monoid.Monoid ([t1] -> t))
10:50:40 <lambdabot>    bound by the inferred type for `e_1123':
10:50:40 <lambdabot>               (GHC.Num.Num t1, Data.Monoid.Monoid ([t1] -> t)) => t
10:50:43 <dwcook> Woop
10:51:08 <dwcook> Better idea
10:51:11 <dwcook> > mempty "hello"
10:51:12 <lambdabot>  ()
10:51:20 <dwcook> o_0 Well, I'm just confused now
10:51:38 <dwcook> Oh duh -_-
10:51:43 <supki> > sortBy (comparing length `mappend` compare) (words "The quick brown fox jumps over the lazy dog")
10:51:44 <lambdabot>  ["The","dog","fox","the","lazy","over","brown","jumps","quick"]
10:52:17 <dwcook> I was trying to give an example where the context gave the type but forgot that the types are not necessarily equal
10:52:40 <dwcook> > mempty () :: String
10:52:41 <lambdabot>  ""
10:52:57 <Denommus> ok, I decided to use the "do" syntax. It honestly looks cleaner
10:53:07 <dwcook> Denommus, yeah, often a good choice
10:53:48 <dwcook> Though, be careful with the pattern matching. What if getArgs gives you []?
10:56:04 <yitz> > ("Why did the multi-threaded chicken cross the road?",sortBy (comparing length `mappend` compare) (words "To get to the other side."))
10:56:06 <lambdabot>  ("Why did the multi-threaded chicken cross the road?",["To","to","get","the"...
10:56:06 <Denommus> dwcook: in this specific case, it won't
10:56:30 <yitz> > (sortBy (comparing length `mappend` compare) (words "To get to the other side."))
10:56:31 <Denommus> dwcook: it's for CodeEval challenges, so I no beforehand what to expect from the input
10:56:32 <lambdabot>  ["To","to","get","the","other","side."]
10:57:05 <hhhhhhhh> is http://lpaste.net/101516 a sensible way of doing what i want
10:57:16 <hhhhhhhh> it seems like it is not :d
11:08:37 <yitz> hhhhhhhh: it works. but you don't need the nested ifs - use when or unless instead (from Control.Monad)
11:18:46 <k0ral> can somebody please tell me how I am supposed to catch an exception from a MonadThrow instance, since this typeclass only exposes a 'throw' function and no 'catch' ?! (makes no sense to me...)
11:19:24 <k0ral> I'm talking about MonadThrow from 'conduit' package
11:19:36 <k0ral> http://hackage.haskell.org/package/conduit-1.0.15.1/docs/Data-Conduit.html#t:MonadThrow
11:19:58 <xunplini> Hello. I want to learn Haskell from a C++ perspective to broaden my programming horizons.
11:20:03 <xunplini> Learn you a haskell is a good tutorial for that?
11:20:20 <DMcGill> yes
11:20:35 <Redz> yes²
11:20:36 <k0ral> xunplini: sure is, so is Real World Haskell
11:20:44 <kadoban> xunplini: i had the best luck alternating between tutorials when i stopped understanding what was going on, that one and Real World Haskell
11:20:48 <Redz> or haskell wikibooks.
11:21:41 <mniip> So I made a regex-like pattern matcher which works on arbitrary data types, is that of any use? :P
11:21:55 <Redz> isn't this a lack of marketing or why is nobody looking in the great haskell wikibook?
11:23:06 <xunplini> Redz: I've not had good experiences with wikibooks.
11:23:52 <k0ral> my feeling is that haskell wikibook is useful for those who are already a little familiar with haskell, to complete their knowledge
11:24:54 <yitz> k0ral: the conduit docs say that if you are not in IO, you should wrap your monad in ExceptionT so that you can catch exceptions.
11:25:09 <Redz> xunplini: this wikibook is well written and complete. you should take a look. or maybe use both sources. LYAH miss some important points.
11:25:46 <yitz> k0ral: MonadThrow is for use by ResourceT - it needs to know how to throw an exception while cleaning up resources. it never needs to catch them.
11:26:02 <Denommus> is there any shorthand for "\_ -> foo bar"?
11:26:14 <yitz> Denommus: const
11:26:43 <Iceland_jack> > (\_ -> 5) 'a'
11:26:43 <k0ral> yitz: I see which paragraph you're referring to, and it tells "in a vanilla ST or Identity monad"
11:26:45 <lambdabot>  5
11:26:47 <Iceland_jack> > (const 5) 'a'
11:26:48 <quchen> yitz: That's not shorter though :-þ
11:26:48 <dawik> is this true about monads: that they are a mathematical construct to compensate for haskells lack of mutable state?
11:26:49 <lambdabot>  5
11:27:10 <quchen> dawik: No, that's completely wrong.
11:27:12 <troydm> dawik: yes partially
11:27:17 <yitz> quchen: ah, well i would include a space between \ and _ ;)
11:27:19 <kadoban> XD
11:27:23 <k0ral> yitz: I'm in a stack of monads based on IO
11:27:30 <troydm> dawik: well it's not true in a certain sense
11:27:38 <yitz> quchen: also, it's shorter in phonemes when pronounced in english.
11:27:42 <Denommus> well, but in my case "foo" is a function
11:27:42 <troydm> dawik: monad is very powerful construct
11:28:01 <troydm> dawik: it can express many things  not only mutable state
11:28:17 <yitz> k0ral: so then you can throw and catch IO exceptions as usual. ResourceT will do the right thing.
11:28:18 <quchen> Monads are a mathematical construct that is useful to abstract things. State is one of these things. Monads are not a workaround, the State monad doesn't create mutable state, there is mutable state in GHC but it's not the State monad.
11:28:43 <k0ral> yitz: also, I'm in a MonadResource m, not directly in a ResourceT; the latter is MonadBaseControl, so is not the former
11:28:48 <Redz> dawik: well, its less a lack than missed safety.
11:28:54 <troydm>  you can use IORef if u rly want an mutable state
11:29:11 <Denommus> monads are useful for any kind of sequential operation, because they abstract them so well
11:29:12 <troydm> but that is not recommended way
11:29:32 <peteretep> Honestly
11:29:34 <dawik> thank you very much for the replies. i have tried LYSH but only got as far as monad
11:29:35 <peteretep> the best way to learn about monads
11:29:37 <dawik> s
11:29:37 <k0ral> yitz: I'm using the 'http' function which lives in a MonadResource
11:29:38 <peteretep> is to try and use them
11:29:44 <peteretep> or better yet
11:29:45 <dawik> it is so abstract
11:29:47 <peteretep> write a tutorial
11:29:51 <peteretep> to teach other people about them
11:29:57 <JoaoPortela> Hay! I can't install yesod on my virtual machine. «xss-sanitize-0.3.5 failed while downloading the package. The exception was:
11:29:57 <JoaoPortela> <socket: 8>: hGetBufSome: resource vanished (Connection reset by peer)
11:29:57 <JoaoPortela> » Is the server down?
11:30:05 <dwcook> @google chris done io is pure
11:30:06 <lambdabot> http://chrisdone.com/posts/pure-io-tryhaskell
11:30:07 <lambdabot> Title: Pure IO monad and Try Haskell
11:30:07 <peteretep> "Monads are like bladers, because"
11:30:08 <dawik> it seems everyone has their own idea of what it is, yet lack the ability to explain it :)
11:30:44 <dwcook> Hmm, I was thinking of something else
11:30:46 <peteretep> dawik: The best explanation is probably "You could have invented monads"
11:31:08 <Denommus> dawik: a monad is just a type associated with a bind and a return function. Those functions must follow some rules
11:31:25 <dwcook> Heh, wrong Chris
11:31:28 <Denommus> dawik: there's nothing inherently difficult about them, people just overcomplicate because they're so useful
11:31:28 <hiptobecubic> it's really not that crazy, but you don't realize that until *after* you get past believing that it's crazy
11:31:29 <dwcook> http://chris-taylor.github.io/blog/2013/02/09/io-is-not-a-side-effect/
11:31:52 <peteretep> They're just monoids in the category of endofunctors
11:32:01 <dwcook> peteretep, yeah, what's the problem?
11:32:03 <dwcook> :P
11:32:16 <Redz> dawik: a monad is just a type that has some rules. nothing more. ;)
11:32:17 <Denommus> peteretep: once you understand what monoids and endofunctors are, that is a really nice synthesis
11:32:36 <dawik> Denommus: Redz: ok noted :)
11:32:38 <peteretep> Maybe I should learn about endofunctors
11:32:51 <dwcook> peteretep, you know what a functor is?
11:32:51 <geekosaur> worse, they're not monoids like Haskell's Monoids
11:32:55 <peteretep> dwcook: yes
11:33:08 <dwcook> peteretep, an endofunctor has the same source and target categories. That's it
11:33:20 <prophile> eg haskell's Functor
11:33:27 <quchen> Yes, let's start recommending category theory to beginners again, that's always helpful.
11:33:52 <prophile> but it's so beautiful and simple
11:33:58 <yitz> quchen: i think it was supposed to be funny
11:34:01 <peteretep> I don't think I appreciate the relationship between "Functor" and "category" well enough
11:34:02 <dwcook> quchen, careful, there were no sarcasm marks in that sentence
11:34:15 <Redz> category theory describes just a bunch of rules a type can have. there is an easy way to teach category theory.
11:34:44 <hiptobecubic> dawik, you are familiar with interfaces in other languages? For me, it's like that but one level higher. You have many different kinds of functionality that all conform to a single interface with the stipulation that you can't mix and match implementations. The end.
11:35:26 <k0ral> dawik: monads are just a way to enrich the composition operator
11:35:44 <Denommus> unfortunately, Haskell can't enforce that a given instance of the Monad typeclass will follow monad's rules
11:35:47 <hiptobecubic> Sure there's a lot of great things you can talk about around it. But at the end of the day you have return and >>= and they are implemented in such a way that it lets you do whatever it is you were trying to do.
11:36:08 <k0ral> dawik: as functional programming is about composing functions, this is a very useful tool
11:36:33 <hiptobecubic> k0ral, to me, that's another one of the explanations that makes no goddamn sense until after you no longer need it. :)
11:36:55 * dawik is taking it all in
11:36:58 <k0ral> hiptobecubic: bear with me, I'm not done :) examples coming
11:37:30 <dawik> maybe after some usage the penny will drop. thanks for the input :)
11:37:56 <hiptobecubic> dawik, no you aren't. The real answer is just to pretend like you get it and use them when people tell you to, then one day you'll wake up and be on the other side of the fence, shouting at the uninitiated with the rest of the channel.
11:38:05 <k0ral> dawik: for example, when you want to execute several functions and each of them can return an error, in an imperative language, you would either have to add a check after each function, or use exceptions
11:39:02 <yitz> dawik: i don't think you should worry about taking it all in. just look at the types of >>= and return, learn how do is just a fancy syntax for using >>=, and then read code and try using them yourself. come back here and ask us specific questions.
11:39:09 <k0ral> dawik: another way of looking into that situation is to define a composition function that behaves as the following: f . g = "execute f, if f fails stop, otherwise execute g"
11:39:13 <yitz> i think that's the fastest way to "get" monads.
11:39:57 <k0ral> dawik: people wrote such "." operator, and instead of using exceptions or adding several checks, they would just have to write "f . g "
11:40:13 <yitz> dawik: look at (and write) examples of the State monad, Maybe monad and list monad. if you get those - you've got monads.
11:40:41 <Denommus> is there a IO () function that does nothing?
11:40:43 <dawik> great :)
11:40:45 <k0ral> dawik: this is the "error-prone composition" monad, also known as Maybe monad
11:40:55 <yitz> Denommus: return ()
11:40:56 <hiptobecubic> Denommus, return ()
11:41:01 <Denommus> ah, thanks
11:41:15 <peteretep> Maybe is a great monad to get started with
11:41:25 <peteretep> dawik: Do you know any Haskell?
11:41:30 <bsdbeard> Hey, there's something I don't understand why can't I do "let foo = Just (*3)" followed by "foo 5"? The type of foo is Integer -> Integer, so this should work?
11:41:37 <Denommus> Maybe is beautiful
11:41:46 <yitz> Denommus: threadWait does nothing for a long time. :)
11:41:59 <k0ral> dawik: then, people had many other ideas to define composition operators with added effects, and as many monads were implemented
11:42:07 <hiptobecubic> if foo = Just (*3) then foo :: Maybe (Integer -> Integer)
11:42:18 <hiptobecubic> or rather, Num a => a -> a   or something
11:42:58 <bsdbeard> right... so it's a (Integer -> Integer) in a functor
11:43:01 <dawik> peteretep: only some, i have yet to write anything resembling a complete application though.
11:43:03 <hiptobecubic> bsdbeard, (Integer -> Integer)  is not the same as Maybe (Integer -> Integer)
11:43:05 <bsdbeard> which means it foo 5 should work?
11:43:11 <bsdbeard> argh
11:43:16 <peteretep> dawik: I have some exercises for learning about Monads
11:43:16 <hiptobecubic> fmap foo 5 should work
11:43:22 <bsdbeard> I thought the functor is supposed to "unpack" the function out of it
11:43:32 <bsdbeard> I guess I didn't understand it properly
11:43:43 <hiptobecubic> bsdbeard, describe what you think a functor is
11:43:48 <hiptobecubic> bsdbeard, so that someone can correct it
11:43:51 <bsdbeard> fmap foo 5 doesn't work btw
11:43:55 <dawik> peteretep: care to share?
11:44:17 <peteretep> dawik: http://pastebin.com/gY1ih91M
11:44:24 <dawik> will try yitz advice with the state monad
11:44:25 <peteretep> dawik: I have some sample answers too, but you shouldn't need them
11:44:32 <JoaoPortela> I shouldn't ask for help in the middle of people explaining monads ;)
11:44:33 <peteretep> dawik: After that, there are two more sets
11:44:42 <peteretep> dawik: At the end of that, you will understand monads, a bit
11:44:43 <dawik> JoaoPortela: go ahead :)
11:44:44 <bsdbeard> hiptobecubic, the way I understood it is a functor is an evaluation context, sort of like operator(T) in c++
11:44:52 <dawik> peteretep: let me see!
11:45:00 <peteretep> dawik: http://pastebin.com/gY1ih91M
11:45:09 <dawik> ah looks good
11:45:11 <k0ral> yitz: any thoughts about what I said last on MonadResource ? :)
11:45:27 <JoaoPortela> I already did. People were too focused. I'll try again: installing yesod on a VM: «xss-sanitize-0.3.5 failed while downloading the package»
11:45:33 <yitz> k0ral: well isn't that inside IO?
11:45:45 <hiptobecubic> bsdbeard, sorry, need to apply. fmap ($ 5) foo
11:45:45 <JoaoPortela> «<socket: 8>: hGetBufSome: resource vanished (Connection reset by peer)»
11:46:27 <k0ral> yitz: what do you mean ?
11:46:39 <Redz> well. you should show dawik some examples. sometimes its easier to learn, when you know what type of issues it can solve.
11:46:43 <k0ral> yitz: what does X is inside Y for monads ?
11:46:49 <k0ral> +mean
11:46:54 <bsdbeard> hiptobecubic, Thanks that works, time to think about functors some more
11:46:57 <hiptobecubic> bsdbeard, I'm not the person to fix your understanding. But perhaps someone here is. At any rate, do you understand what fmap is? Why it's needed there?
11:47:18 <bsdbeard> hiptobecubic, I thought I understood fmap, now I'm not so sure :)
11:48:08 <hiptobecubic> you have a (Maybe x). fmap applies a function to that x.
11:48:32 <yitz> k0ral: these are monad transformers. you compose the types to get a "stack" of various services that the monad provides.
11:48:35 <hiptobecubic> without taking it out of the (Maybe)
11:48:52 <hiptobecubic> @type maybe
11:48:54 <lambdabot> b -> (a -> b) -> Maybe a -> b
11:49:05 * hackagebot snowflake 0.1.0.0 - A loose port of Twitter Snowflake to Haskell. Generates arbitrary precision, unique, time-sortable identifiers.  http://hackage.haskell.org/package/snowflake-0.1.0.0 (edofic)
11:49:14 <bsdbeard> hiptobecubic, see, the thing is I thought this should happen automagically
11:49:19 <yitz> k0ral: the MonadResource class, among other things, requires your monad stack to be based on IO at the bottom, and you always have the liftIO function which allows you to do any IO action.
11:49:32 <bsdbeard> I thought the fmap is inferred
11:49:42 <hiptobecubic> bsdbeard, why should it? How would (Maybe (a -> b)) be any different than (a -> b) if it were all automatic?
11:49:54 <k0ral> yitz: so ?
11:50:10 <hiptobecubic> Half of the point of Maybe is that it's not automatic :)
11:50:23 <hiptobecubic> More importantly, what would the behavior be if it were Nothing instead of (Just a)
11:50:28 <bsdbeard> hiptobecubic, Well a simple example, let foo = Just 5, I thought it should be possible to do foo + 6, but I have to do fmap (+6) foo
11:50:45 <yitz> k0ral: so you can at least do: liftIO $ catch .... (but then your action when you catch an exception lives only in IO, not in your full monad)
11:51:04 <hiptobecubic> bsdbeard, correct. and in doing so, you ensure that your program will not explode if foo = Nothing
11:51:12 <yitz> k0ral: i have a feeling that you will use http inside a monad that already provides a way of catching exceptions. maybe even just IO.
11:51:14 <bsdbeard> hiptobecubic, the behavior when Nothing would default to what fmap says to do when its nothing, that is return Nothing
11:52:19 <k0ral> yitz: catch expects and IO as "exception-prone" function to run
11:52:32 <hiptobecubic> bsdbeard, i don't quite understand what you want here. It sounds like you want types but don't want types?
11:52:33 <k0ral> yitz: 'http' is in MonadResource m, not IO
11:52:41 <yitz> hiptobecubic: unless you write: maybe launchMissiles pickFlowers yourProgram
11:52:52 <yitz> k0ral: MonadResource is a class, not a type
11:52:53 <k0ral> and I can't use lifted exceptions since I have no MonadBaseControl instance
11:53:01 <bsdbeard> hiptobecubic, you can do this in C++ using Operator(T), it figures out what should happen with the type automagically, sort of like using fmap without manually telling it to use fmap
11:53:02 <hiptobecubic> bsdbeard, do you see a difference between (Just 3) and 3? Not the obvious syntactical one of course
11:53:10 <yitz> k0ral: you will be in some monad which is an instance of MonadResource.
11:53:12 <bsdbeard> hiptobecubic, yes I do
11:53:41 <k0ral> yitz: yes, that's what I meant
11:54:04 <JoaoPortela> dawik, see? ;)
11:54:16 <yitz> k0ral: for real applications that is. if you are writing a general library function that must be polymorphic and work for all MonadResource instances, perhaps you can't catch exception and must leave that for the program using your library.
11:54:18 <geekosaur> bsdbeard, very little is "automagic" like that in Haskell
11:54:21 <joe9> How can I remove a module that I installed with cabal?
11:54:33 <hiptobecubic> bsdbeard, ah ok. I'd need to read more about Operator(T), but what do you do when the type is not a function?
11:54:45 <hiptobecubic> What should the behavior of (Just 4) 4  be?
11:54:50 <geekosaur> and the exceptions are common sources of confusing problems (defaulting for numbers, for example)
11:54:50 <jrmithdobbs> geekosaur: furthermore once you understand it you rarely want it to be anyways =/
11:54:52 <bsdbeard> hiptobecubic, I'm writing an example right now, I hope it will make it clear :-)
11:54:54 <yitz> k0ral: so in the actual application, the actual monad type will be one that supports catching exceptions.
11:54:59 <hiptobecubic> (keep in mind that exploding is not supposed to be an option)
11:56:18 <yitz> > (Just 4) 4
11:56:20 <lambdabot>  Couldn't match expected type `a1 -> t0'
11:56:20 <lambdabot>              with actual type `Data.Maybe.Maybe a0'
11:56:41 <k0ral> yitz: I'm in a real application, but most of it is written in a generic way
11:57:12 <k0ral> yitz: are you telling me there is no way to catch such exception in a generic code ?
11:58:07 <quchen> joe9: You can use `ghc-pkg unregister <package>` to rip a package out of your repositories if I recall correctly. You should only ever do this when no other installed library depends on it though, otherwise your package DB might become inconsistent.
11:58:07 <hiptobecubic> yitz, Is it possible to write an instance for Maybe (a -> b) that does what bsdbeard is imagining?
11:58:08 <yitz> k0ral: well you can, but you can only do an IO action when you catch an exception, not an action in the generically unspecified monad.
11:58:29 <k0ral> yitz: that's a shame
11:58:42 <jrmithdobbs> k0ral: actually it's a blessing in disguise
11:58:44 <joe9> quchen: ok, thanks.
11:58:50 <k0ral> jrmithdobbs: is that so ?
11:59:29 <yitz> k0ral: which makes sense. how can you know what capabilities are available to you in the monad if you don't know what monad it is?
11:59:55 <jrmithdobbs> k0ral: yes because what your code *can* do is well defined during that block, so for example, your code isn't expecting a string to run a Parser monadic action at that point in the code
12:00:06 <k0ral> yitz: well, for one thing, I live in a MonadError, and I wish I could tie it to the MonadThrow
12:00:13 <k0ral> bbut I can't...
12:00:33 <yitz> k0ral: oh if you know it's a MonadError than you can use catch from there.
12:01:33 <yitz> *then
12:01:37 <k0ral> jrmithdobbs: sorry but I don't get your point
12:02:47 <k0ral> yitz: no, http won't use the MonadError facility, it will throw in MonadThrow, so my MonadError is useless
12:03:18 <k0ral> yitz: basically, I did this: http://chromaticleaves.com/posts/guard-io-with-errort.html
12:03:27 <k0ral> yitz: this works for any MonadBaseControl
12:03:35 <k0ral> which MonadResource isn't
12:03:53 <k0ral> this is where I'm screwed
12:05:02 <k0ral> ironically, the last line of the article is "some monads may not be able to provide an instance of MonadBaseControl IO, such as those in the popular conduit library."
12:05:33 <pyon> @hoogle Void
12:05:34 <lambdabot> Foreign.Marshal.Error void :: IO a -> IO ()
12:05:34 <lambdabot> Control.Monad void :: Functor f => f a -> f ()
12:05:34 <lambdabot> package void
12:05:57 <haskell_newb> hi
12:06:22 <pyon> If I want a void data type, it is best to use the void package rather than make my own, right?
12:06:32 <haskell_newb> are there any library function which will do m a -> m [a] like in (sequence . repeat) ?
12:07:02 <k0ral> @hoogle m a -> m [a]
12:07:05 <lambdabot> Control.Applicative many :: Alternative f => f a -> f [a]
12:07:05 <lambdabot> Control.Applicative some :: Alternative f => f a -> f [a]
12:07:05 <lambdabot> Test.QuickCheck.Gen listOf :: Gen a -> Gen [a]
12:07:22 <haskell_newb> i just want to check if i need to create my own utililities module or i can just import someithng ready to use
12:07:29 <hiptobecubic> fmap repeat?
12:07:35 <Iceland_jack> @ty replicateM 4
12:07:36 <lambdabot> Monad m => m a -> m [a]
12:07:39 <Iceland_jack> k0ral: ↑
12:07:42 <hiptobecubic> or that
12:07:48 <haskell_newb> Iceland_jack: great, thanks!
12:08:05 <haskell_newb> Iceland_jack: wait, no
12:08:08 <hiptobecubic> @src replicateM
12:08:08 <lambdabot> replicateM n x = sequence (replicate n x)
12:08:11 <yitz> k0ral: ok well i didn't read the whole post, but i guess just don't use that technique then.
12:08:41 <hiptobecubic> @ty fmap repeat
12:08:42 <lambdabot> Functor f => f a -> f [a]
12:08:45 <yitz> k0ral:  you can definitely throw and catch exceptions in a convenient way with conduit - that was one of the main motivations for the library right from the beginning.
12:08:49 <haskell_newb> Iceland_jack: i need to tell replicate how many elements in list i want but with (sequence . repeat) i don't need to do that
12:09:07 * hackagebot list-tries 0.5.2 - Tries and Patricia tries: finite sets and maps for list keys  http://hackage.haskell.org/package/list-tries-0.5.2 (MattiNiemenmaa)
12:09:19 <Iceland_jack> haskell_newb: Why do you want 'sequence . repeat'?
12:09:39 <hiptobecubic> haskell_newb, i think it depends on the semantics you want. For example if it's (IO a), then do you want to recompute new a's or replicate the first one?
12:09:41 <haskell_newb> ah, nevermind, i need to (take 4) afterall on sequenced repeat so it's esentialle the same
12:10:06 <Iceland_jack> haskell_newb: you might also be interested in forever
12:10:08 <Iceland_jack> @ty forever
12:10:09 <lambdabot> Monad m => m a -> m b
12:10:20 <haskell_newb> hiptobecubic: will replicateM copy first one?
12:10:38 <hiptobecubic> replicate will "rerun" the monad i think? Someone correct me
12:10:48 <hiptobecubic> I haven't haskell'd in awhile :(
12:11:14 <yitz> > (sequence . repeat) [42]
12:11:15 <lambdabot>  *Exception: stack overflow
12:11:16 <NikolajK> I write a function which drops the first instance of a query int, where is my wronging: http://lpaste.net/101518
12:11:28 <k0ral> yitz: well, good to know a solution exists somewhere, but I'm kind of a constructivism zealot
12:11:31 <Iceland_jack> If you run
12:11:31 <Iceland_jack>     ghci> replicateM 4 (print 1)
12:11:31 <Iceland_jack> it will print 1 four times and return [(), (), (), ()]
12:11:38 <hiptobecubic> right
12:11:43 <yitz> k0ral: heh
12:12:00 <hiptobecubic> which is different than "fmap repeat (print 1)"
12:12:11 <hiptobecubic> which will print 1 time and return [(), (), (), ()] i think
12:12:12 <Iceland_jack> the other behaviour would be something like 'replicate 4 <$> print 1'
12:12:17 <hiptobecubic> well...
12:12:18 <hiptobecubic> infinite
12:12:30 <Iceland_jack> hiptobecubic: 'replicate 4' would do what you said
12:12:54 <hiptobecubic> yes
12:14:25 <hiptobecubic> for some monads, like (Maybe a), i don't think there's a difference in the two, fmap or replicateM.
12:14:50 <hiptobecubic> fmap (replicate 4)  vs replicateM 4 i mean
12:14:58 <hiptobecubic> but for monads that *do* stuff. It will matter.
12:15:00 <fizbin> :t fromLeft
12:15:01 <lambdabot>     Not in scope: `fromLeft'
12:15:02 <lambdabot>     Perhaps you meant one of these:
12:15:02 <lambdabot>       `IM.fromList' (imported from Data.IntMap),
12:15:16 <aristid> :t either id undefined
12:15:17 <lambdabot> Either c b -> c
12:15:21 <supki> :t preview _Left
12:15:22 <lambdabot> MonadReader (Either b c) m => m (Maybe b)
12:15:47 <haskell_newb> another question, i have an application which interacts with external APIs a lot, and i want to "stub" every function which makes HTTP request which function wich just returns some fixture
12:15:48 * aristid is tempted to bring another example but that would make shachaf angry
12:15:52 <haskell_newb> how to do it in haskell?
12:16:41 <dmj`> haskell_newb: are you asking how to craft an http request or saying you have a function that makes http requests, but you're asking how to generalize it
12:17:23 <hiptobecubic> He wants his http requests to not make requests, but rather to just grab some local known data, presumably for testing or something?
12:17:46 <shachaf> aristid: help
12:18:40 <haskell_newb> hiptobecubic: correct
12:19:14 <dmj`> haskell_newb: you want to make a mock object basically?
12:19:26 <haskell_newb> dmj`: right
12:21:25 <dmj`> haskell_newb: you could, at the start of your application add a flag to an IORef to turn mocks on or off, then make a general http request function that checks the flag in the IORef before deciding wether or not to execute the request or return a mock object
12:21:26 <dmj`> haskell_newb: if you have a database you could add a flag there
12:22:49 <haskell_newb> dmj`: okay, got it
12:22:50 <davidthomas> haskell_newb: The other option is pass around the function that makes the request
12:23:27 <davidthomas> either explicitly or in a Reader or something
12:23:38 <bsdbeard> hiptobecubic, hey, sorry for the delay, here's how I *thought* it works, http://ideone.com/9ihMD9, but I can see how the type safety (ensuring that fmap returns a functor) is much better in most cases
12:24:23 <dmj`> haskell_newb: in my app I have a data Env = PROD | BETA | DEV | STAGING and check that env from a local state before performing certain operations. Like DEV should upload files to a different location
12:24:36 <davidthomas> that doesn't allow for turning mocking on/off while running (without some additional work), but doesn't rely so much on hidden state
12:25:18 <hiptobecubic> bsdbeard, oh. yes this is totally different.
12:25:18 <haskell_newb> dmj`: thanks!
12:25:31 <hiptobecubic> bsdbeard, (Maybe a) is basically so you *don't* have to do this.
12:26:05 <bsdbeard> hiptobecubic, yep, it makes more sense now, since you know that your type can have several states (i.e. just / nothing, left / right, list / empty list, etc)
12:26:43 <hiptobecubic> bsdbeard, not throwing exceptions in the middle of boring looking code is good :)
12:27:00 <hiptobecubic> it's why many people prefer to use safeHead instead of head, for example
12:27:04 <hiptobecubic> > head []
12:27:06 <lambdabot>  *Exception: Prelude.head: empty list
12:27:17 <hiptobecubic> > safeHead []  -- not sure if lambdy has this....
12:27:19 <lambdabot>  Not in scope: `safeHead'
12:27:25 <bsdbeard> hiptobecubic, it's why people prefer to use statically typed languages instead of dynamic ones :P
12:27:43 <hiptobecubic> @let safeHead [] = Nothing; safeHead (x:xs) = Just x
12:27:46 <lambdabot>  Defined.
12:27:54 <hiptobecubic> > safeHead []
12:27:56 <lambdabot>  Nothing
12:28:01 <hiptobecubic> :t safeHead
12:28:02 <lambdabot> [a] -> Maybe a
12:30:14 <bsdbeard> right... I'm going to implement some graph types/functions to see if I understand haskell well enough
12:30:27 * bsdbeard thanks hiptobecubic 
12:39:44 <zerokarmaleft> bitemyapp: blackwater?
12:40:53 <bitemyapp> zerokarmaleft: da.
12:41:11 <bitemyapp> zerokarmaleft: if it can be made to work with JDBC and Korma I'd be fine merging it.
12:41:26 <bitemyapp> I simply didn't know people were actually using it.
12:41:43 <bitemyapp> "Downloads: 1120" oh. well then.
12:42:39 <bitemyapp> kinda cool to see a blog post about using two different libraries together and I worked on both of them.
12:43:23 <Redz> Int -> Fractional  ?
12:44:17 <bitemyapp> Redz: division, I think.
12:44:26 <bitemyapp> :t (1 / 2)
12:44:28 <lambdabot> Fractional a => a
12:44:31 <bitemyapp> see, fractional!
12:44:42 <Redz> xD
12:45:27 <Redz> i'm searching for the conversion function because of division. ;)
12:45:31 <supki> :t realToFrac
12:45:32 <lambdabot> (Fractional b, Real a) => a -> b
12:45:45 <bitemyapp> :t (realToFrac 1)
12:45:46 <lambdabot> Fractional b => b
12:46:06 <Redz> supki: thanks. ;)
12:46:11 <bitemyapp> correction, 3 different libraries.
12:46:14 <geekosaur> @hoogle Fractional a => Int -> a
12:46:15 <lambdabot> Data.Set elemAt :: Int -> Set a -> a
12:46:15 <lambdabot> Prelude (!!) :: [a] -> Int -> a
12:46:15 <lambdabot> Data.List (!!) :: [a] -> Int -> a
12:46:18 <geekosaur> meh
12:46:27 <geekosaur> :t fromIntegral
12:46:28 <lambdabot> (Integral a, Num b) => a -> b
12:46:44 <geekosaur> so much for hooglebeing good at types :p
12:46:50 <zerokarmaleft> bitemyapp: ok, I'll dig into it again and send a fully-formed PR
12:47:00 <bitemyapp> zerokarmaleft: danke.
12:47:33 <bitemyapp> zerokarmaleft: I think as long as it works with 0.3.x and higher JDBC and Korma it should be fine.
12:47:41 <bitemyapp> hum, sorta.
12:47:52 <bitemyapp> zerokarmaleft: only catch is Korma itself uses an antediluvian c.j.j :)
12:48:44 <zerokarmaleft> bitemyapp: I recall that possibly being a problem
12:48:49 <zerokarmaleft> bitemyapp: I've slept since then :D
12:49:32 <bitemyapp> zerokarmaleft: sleep is good.
12:49:48 <bitemyapp> zerokarmaleft: I accidentally went on a quixotic crusade with a deprecated library last night because I was short on sleep. bad.
12:57:19 <Fuuzetsu> I feel like randomIO should be in base…
12:57:27 <bitemyapp> zerokarmaleft: if you don't use the library anymore, please don't put any effort into it. Just saying that I'd be open to a PR that worked for both backends.
12:58:19 <zerokarmaleft> bitemyapp: no worries, if it turns into a yak-shaving event, I don't think I'll bother
12:58:53 <bitemyapp> zerokarmaleft: that's fine. We should all be writing Haskell anyway.
12:58:55 <zerokarmaleft> bitemyapp: I'm sort of transitioning my focus to the Haskell ecosystem anyway
12:59:05 <bitemyapp> zerokarmaleft: me too. I'm tinkering with some ElasticSearch stuff right now.
13:03:21 <Andre___> hey guys ! i have small problem, i put {-# ANN module "HLint: ignore Use camelCase" #-} but i got  The type variable `a0' is ambiguous, because i have OverloadedStrings and i import Text and ByteString
13:04:51 <merijn> Andre___: Add a type signature :p
13:04:58 <geekosaur> that sounds unrelated
13:05:07 <geekosaur> (that an ANN caused that error
13:05:09 <geekosaur> )
13:05:15 <merijn> Andre___: That's the correct solution to any ambiguous type error
13:05:52 <bitemyapp> so decode is -> Maybe a, but could I get it to do Either or something instead so I know what was missing or incorrect?
13:05:56 <bitemyapp> er, in Aeson.
13:05:58 <Andre___> add a type signature to ANN ? how ?
13:06:18 <geekosaur> Andre___, I have to believe something else is the real cause
13:06:24 <tdammers> Andre___: not to ANN. To the line that triggers the error.
13:06:26 <geekosaur> because that annotation cannot affect compilation
13:07:13 <Andre___> the line with the error is the ANN
13:08:20 <geekosaur> @paste actual code
13:08:20 <lambdabot> Haskell pastebin: http://lpaste.net/
13:08:22 <merijn> I'll believe that when I see an lpaste of the full code + error
13:08:29 <Andre___> i put my code here http://lpaste.net/101519
13:08:48 <merijn> Andre___: Please paste the full error too :)
13:09:03 <bitemyapp> oh, eitherDecode. Sweet.
13:09:05 <BeardedCoder> bitemyapp: Just to make sure we are on the same page. decode would only return None for invalid JSON. With that being said, check eitherDecode
13:09:21 <Andre___> just pasted the error :)
13:10:16 <geekosaur> I bet the preprocessor is mucking with line numbers
13:10:32 <geekosaur> wait, that makes no sense
13:10:51 <geekosaur> an ANN for hlint should not create any code but the error message is definitely talking about it :/
13:11:07 <pyon> What is the default fixity in Haskell?
13:11:11 <merijn> pyon: infixl 9
13:11:16 <pyon> Thanks!
13:11:45 <supki> Andre___: {-# ANN module ("Hlint: ignore Use camelCase" :: String) #-}
13:11:45 <merijn> Andre___, geekosaur: According to the docs ANN expects a top level binding name + Typeable/Data value
13:11:46 <Andre___> geekosaur: yeah, i'm not sure if is  bacause the OverloadedStrings
13:12:16 <geekosaur> hm, I just pulled up the Pragmas section of ghc "latest" manual and ANN isn't even there :(
13:12:17 <merijn> Oh, no, you're right module should work
13:12:21 <Andre___> supki, yeah that's works, thanks very much :)
13:12:23 <merijn> geekosaur: Yes it is
13:12:33 <merijn> geekosaur: At least in the 6.12 docs
13:12:43 <merijn> geekosaur: So I can't imagine later not having that section :)
13:12:54 <geekosaur> http://www.haskell.org/ghc/docs/latest/html/users_guide/pragmas.html
13:13:01 <Andre___> Haskell have an excelent community :)
13:13:22 <bitemyapp> BeardedCoder: nah, it'll chuck a nothing out if it doesn't match a record.
13:13:30 <geekosaur> oh, it's not in the Pragmas section, it's under GHC as a Library
13:13:48 <bitemyapp> BeardedCoder: but eitherDecode does what I want :)     >> Left "The key \"status\" was not found"
13:13:58 <geekosaur> thar's kinda dumb
13:14:12 * hackagebot git-annex 5.20140320 - manage files with git, without checking their contents into git  http://hackage.haskell.org/package/git-annex-5.20140320 (JoeyHess)
13:15:03 <geekosaur> but, ok, I see the problem
13:15:12 <geekosaur> since it's a string literal, it can't determine the type
13:15:32 <geekosaur> so you need to do {-# ANN module "HLint: ..." :: String #-}
13:15:48 <geekosaur> (and hope that doesn't break hlint's detection)
13:16:20 <geekosaur> because with OverloadedStrings, the type of a string literal is polymorphic and there's nothing to tell ghc what type it is
13:18:16 <solrize> any idea how to tell fedora 19 on my laptop that i don't have headphones plugged in?  it thinks they are plugged in so it shuts off the speaker
13:18:55 <geekosaur> channel?
13:20:53 <solrize> oh oops sorry ;)
13:24:13 * hackagebot classy-prelude 0.8.1.1 - A typeclass-based Prelude.  http://hackage.haskell.org/package/classy-prelude-0.8.1.1 (MichaelSnoyman)
13:31:09 <b0bbi10> hi, is this statement right associative? "tellCar (Car {company = c, model = m, year = y}) = "This " ++ c ++ " " ++ m ++ " was made in " ++ show y" it seems that the attributes are assigned to the letters
13:32:48 <pavonia> It's a pattern match where "foo = f" meant foo is a record field and f a variable
13:36:10 <b0bbi10> pavonia, ah, 'f' would be the parameter then, right?
13:36:29 <b0bbi10> or one of the three parameters
13:36:47 <b0bbi10> which is then used in the following function definition
13:38:24 <geekosaur> the parameter is a record whose constructor is Car; the fields are extracted into c, m, and y by their labels
13:39:35 <quchen> That has nothing to do with associativity though.
13:39:51 <quchen> Associativity is  a*(b*c) == (a*b)*c.
13:42:01 <akegalj> using cabal sandbox... how can i change directory and use same setup as in parent directory ?
13:42:01 <b0bbi10> geekosaur, quchen: "the fields are extracted into c, m, and y by their labels" since the expression is "foo = f", where f is the variable, is it in a sense right associative (because I've seen it only the other way around when assigning a value to a variable, "var = val")
13:42:40 <geekosaur> that's not associativity
13:43:04 <dwcook> b0bbi10, right associativity is a property of an operator, call it *, wherein multiple applications of that operator a * b * c will be parsed as a * (b * c).
13:43:11 <geekosaur> it's just mimicking the syntax to update a record: recval { field = value }
13:43:55 <geekosaur> but in this case we're *de*constructing it; just as a pattern looks like creating a value but instead pulls things out of it, this looks like building a record but instead pulls things out of it
13:44:18 <quchen> akegalj: You want multiple packages to use the same sandbox?
13:44:52 <b0bbi10> ah ok, understood
13:44:53 <b0bbi10> thanks
13:45:42 <geekosaur> so you could create a value of Car as: Car { company = x, model = y, year = z } --- so your pattern to extract values from it looks the same
13:46:03 <geekosaur> it's not actually an assignment
13:46:38 <geekosaur> it's just that a pattern looks like creating a value, but is in some sense "run backwards" (so they're sometimes called deconstructors)
13:47:22 <akegalj> quchen: hm, yes i think
13:47:45 <skypers> h
13:47:47 <skypers> hm*
13:48:00 <skypers> I think I need some hindsight
13:48:02 <akegalj> i would realy want to go into dir A and compile everything from them
13:48:13 <akegalj> quchen: that works with hsenv tool
13:48:16 <quchen> akegalj: In that case, you can initialize a sandbox with the "--sandbox" parameter, `cabal sandbox init --sandbox /path/to/shared-sandbox`
13:48:46 <quchen> See also the example in the "Advanced usage" section here, http://coldwa.st/e/blog/2013-08-20-Cabal-sandbox.html
13:49:15 <akegalj> quchen: yes, i tryed that... maybe i messed something up.. will try again
13:49:16 <skypers> how would you represent an EDSL that enables you to construct AST for a language? the issue I face is quite simple: in Haskell, if you put an expression in a let statement, it’ll be shared ; in the EDSL, how should I do that for the targeted language?
13:49:54 <yogert> Hey all, I'm learning a bit about using threads and I have a quick question. Is there risk of having "orphan threads" using forkIO?
13:49:57 <benzrf> hej da
13:52:03 <dwcook> yogert, as far as I recall, the main thread terminating causes all others to do so as well.
13:53:42 <skypers> arf, no one for my EDSL issue?
13:54:24 <yogert> dwcook: Oh good, thanks. Also, am i correct in thinking that forkIO doesn't create a "true" thread?
13:54:32 <yogert> Whereas forkOS does?
13:54:34 <dwcook> skypers, I don't think I understood your issue well enough, but perhaps use some sort of environment, such as a Map?
13:54:48 <dwcook> yogert, that's correct, if "true thread" means "OS thread".
13:54:52 <yogert> yeah
13:55:01 <shachaf> forkOS doesn't do what you think it does.
13:55:10 <yogert> i actually found a note about that in the docs after i asked you...
13:55:13 <yogert> What does it do?
13:55:16 <shachaf> Read the documentation (and then read it again).
13:55:20 <shachaf> It could have been better-named.
13:55:22 <skypers> dwcook: I mean
13:55:33 <skypers> if I want to represent the full instructions
13:55:42 <skypers> can I do that in a non-monadic EDSL?
13:56:15 <dwcook> Oh, I missed the second part of the question
13:56:37 <dwcook> I was responding to the part about forkIO not creating an OS thread
13:57:14 <shachaf> The relationship between Haskell threads and OS threads isn't always obvious.
13:58:24 <monochrom> see my http://www.vex.net/~trebla/haskell/ghc-conc-ffi.xhtml for what's going on with forkIO and forkOS
13:58:59 <shachaf> I concur.
14:02:43 <c_wraith> monochrom: you really should point out that unsafe ffi calls prevent GC until they terminate.  That's a huge deal.
14:03:30 <c_wraith> monochrom: and if more people knew that, maybe they'd stop insisting that it's ok for their FFI calls to be unsafe when they take several hundred ms
14:04:23 <monochrom> ok, I'll add that, but that's only because it fits some place in my article
14:04:46 <monochrom> in fact it fits precisely in an existing fine print
14:06:21 <monochrom> in both writing programs and writing articles, I guard against feature bloat that is adding everything important under the sun just because they are important
14:08:04 <[1]grant> any advice on debugging an attoparsec parser? the error messages are not quite as helpful as parsec
14:17:07 <skypers> is it possible to traverse a GADT?
14:17:17 <skypers> not the Traversable typeclass
14:17:19 <skypers> the concept
14:18:13 <d3lxa> I'm searching a (master) internship for the next semester during 4-6 months in haskell, does anyone has something to propose/links/anything please? thanks :)
14:18:20 <skypers> if I understand correctly, definining a type with GADT is like making in a type family, right?
14:18:36 <skypers> because constructors aren’t have the same type
14:18:44 <skypers> so they kinda construct different types
14:18:55 <skypers> then I can’t write a fold E a -> b
14:18:58 <skypers> :(
14:19:09 <nisstyre> skypers: they all return the same type though...
14:19:20 <skypers> nisstyre: ?
14:19:23 <skypers> not really
14:19:32 <skypers> I :: Int -> E Int
14:19:41 <skypers> and Vec2 :: E a -> E a -> E (a,a)
14:19:45 <skypers> they don’t return the same type
14:19:58 <nisstyre> yes they do
14:20:00 <nisstyre> they return E a
14:20:14 <skypers> huh?
14:20:15 <nisstyre> I should say instantiations of the same type
14:20:45 <skypers> so imagine I have this:
14:20:57 <skypers> let a = Vec2 (I 2) (I 10)
14:21:12 <skypers> how could I traverse a?
14:21:40 <skypers> I think it’s not possible since I can’t write a function E a -> b
14:21:56 <skypers> or there’s something I don’t understand
14:22:01 <nisstyre> what do you want to do with it when you traverse it?
14:22:08 <nisstyre> reduce it to a value?
14:22:10 <skypers> E a is of type a, I can’t pattern match I since it expects E Int, not E a
14:22:15 <skypers> yes
14:22:18 <skypers> just fold it
14:22:29 <skypers> or
14:22:36 <skypers> (Monad m) => E a -> m ()
14:22:41 <skypers> (for instance debug print it)
14:24:33 <quicksilver> in general, you can write functions on E a by using 'case', skypers
14:24:44 <skypers> quicksilver: pattern matching
14:24:52 <skypers> this is quite new to me
14:24:53 <skypers> because hm
14:24:57 <quicksilver> case E a of I i -> {- Int case here -} , OtherCons o -> {- other case here -}
14:25:07 <skypers> :o
14:25:09 <skypers> seriously?
14:25:17 <quicksilver> that should start 'case e of ' not 'case E a of'
14:25:18 <skypers> how is it possible?
14:25:18 <quicksilver> sorry
14:25:21 <quicksilver> it's a value not a type
14:25:27 <skypers> wait wait
14:25:29 <quicksilver> they're still ADTs
14:25:34 <quicksilver> you can still case on their constructors
14:25:34 <asmyers> Is anyone here familiar with diagrams?
14:25:37 <quicksilver> that's rather the point
14:25:41 <skypers> quicksilver: wait
14:25:46 * quicksilver isn't going anywhere
14:26:00 <skypers> I :: Int -> E Int; Vec2 :: E a -> E a -> E (a,a)
14:26:10 <skypers> to me, if I have a function E Int -> b
14:26:21 <skypers> I can pattern match all constructors that build a E Int
14:26:23 <skypers> here, I
14:26:29 <skypers> if I have E (a,a) -> b
14:26:41 <skypers> I can pattern match all ctors that build E (a,a), here Vec2
14:26:46 <skypers> I am wrong about that?
14:26:49 <skypers> because to me
14:26:52 <monochrom> do you have your GADT declaration somewhere we can read?
14:27:01 <skypers> huh, sure, wait
14:27:30 <skypers> monochrom: http://lpaste.net/101523
14:27:36 <skypers> if I had that:
14:28:15 <magicman> Once again, Haskell's type system saves the day. "Hrm. These concepts are really close, but not quite, and getting them mixed up will cause hell later." And then there was the newtype wrapper.
14:28:16 <skypers> an algebraic data type, which all ctors build a value of the same type
14:28:33 <skypers> it’s ok then to pattern match
14:28:37 <skypers> but I don’t get it for GADTs
14:28:59 <skypers> the Num a part is wrong, monochrom
14:29:04 <skypers> I’ll remove that asap
14:29:20 <monochrom> no worries
14:29:26 <skypers> so hm
14:29:30 <skypers> if I understand the idea
14:29:34 <skypers> I can pattern match on E a?
14:29:39 <skypers> that so weird
14:29:41 <skypers> +s
14:30:10 <monochrom> I think "pattern match on E a" is poor wording, and I can't even guess what it means
14:30:56 <skypers> well
14:31:01 <skypers> folding E a
14:31:19 <skypers> I think I don’t really understand how GADTs work
14:31:26 <skypers> for me, they’re data family
14:31:46 <skypers> I tested, I can fold such a type
14:31:54 <skypers> that’s awesome
14:32:33 <monochrom> I don't want to talk about "E a -> b" or "E (a,a) -> b". they are too abstract. especially the "b". do you have a concrete objective?
14:32:52 <skypers> sure
14:33:19 <skypers> I want to be able to traverse the AST, reducing it to String for debug purpose
14:33:36 <tdammers> hmm, wonder why haskell-chart needs to run its renderers in IO...
14:33:50 <skypers> in the end
14:34:01 <skypers> I want to be able to find some special expression
14:34:05 <tdammers> you'd think taking some data and turning that into an SVG string should be a pure thing
14:34:07 <skypers> for instance find all Exp in the ast
14:34:10 <skypers> find all CosH
14:34:11 <skypers> and so on
14:35:05 <monochrom> "E a -> String" is still not quite doable because of the Exp case which allows arbitrary "a". unless you want a boring string for it.
14:35:47 <skypers> oh
14:35:52 <skypers> they’re wrong
14:35:54 <skypers> it should be
14:35:58 <skypers> Exp :: E a -> E a
14:36:04 <monochrom> ok that's better
14:36:06 <skypers> and the same thing for Sqrt
14:36:07 <skypers> and so on
14:36:26 <skypers> I think I got it
14:36:48 <skypers> I can pattern match all constructors because they all construct a (E a)
14:37:04 <skypers> F constructs a E Float, but it’s still a E a
14:37:14 <skypers> it’s like wrapped I guess
14:37:28 <skypers> GADTs are still like magic to me :)
14:39:21 * hackagebot chatter 0.1.0.5 - A library of simple NLP algorithms.  http://hackage.haskell.org/package/chatter-0.1.0.5 (RoganCreswick)
14:40:35 <skypers> monochrom: something I don’t get
14:40:39 <skypers> imagine Maybe
14:40:46 <skypers> data Maybe a = Just a | Nothing
14:40:58 <skypers> here, both the ctor returns the _same_ type
14:41:16 <NikolajK> Nikolaj
14:41:39 <skypers> data E a :: * -> * where I :: Int -> E Int; F :: Float -> E Float
14:41:41 <monochrom> right, GADT can have different ctors returning different types
14:41:50 <skypers> here, they don’t return the same type
14:41:55 <skypers> do they?
14:42:01 <NikolajK> can someone tell me what's failing here: http://lpaste.net/101518
14:42:06 <monochrom> they don't return the same type. that's correct.
14:42:25 <NikolajK> supposed to drop the first instance of m of a list and return the rest
14:43:35 <skypers> monochrom: so why can I still pattern match I and F?
14:44:01 * geekosaur sees several potential issues
14:44:19 <skypers> data E :: * -> * where I :: Int -> E Int; I2 :: Int -> Int -> E Int; F :: Float -> E Float
14:44:22 <skypers> here
14:44:37 <skypers> it’d be normal to me to think that I can pattern match I and I2 when considering a E Int
14:44:47 <skypers> and only F when considering E Float
14:44:51 <geekosaur> NikolajK, did you mean Int instead of int?
14:44:53 <skypers> I’m confused
14:44:58 <geekosaur> the latter is an unbound type variable
14:45:09 <merijn> skypers: Correct
14:45:15 <geekosaur> and therefore there won't be an Eq instance in scope for (==)
14:45:34 <merijn> skypers: If you write "E Int -> Bool" you won't have to (in fact, can't) pattern match the E Float constructor(s)
14:45:55 <xico> hi. i have a code which i load through ghc. except it runs as slow as called that way as in runghc. so i suspect the code it generates is clearly not optimized (though two .o and .hi are generated). what is the proper way to allow optimization? something in the session flags?
14:45:59 <merijn> skypers: However, "E a -> Bool" *can* and *should* match all constructors
14:46:07 <monochrom> I don't know. but I suppose a way to answer it is: write down its type system (it must be different from vanilla Hindley-Milner) and prove that it is sound.
14:46:09 <merijn> skypers: Or, for example "E a -> a"
14:46:25 <merijn> xico: Did you specify -O2 ?
14:46:45 <monochrom> but yeah, it hinges on "E a -> String" for example being a non-issue, but "E a -> a" is going to be an issue
14:46:46 <merijn> xico: Also, are you using manipulating text and using String?
14:48:40 <skypers> merijn: hm
14:48:43 <skypers> so hm
14:49:03 <skypers> the constructors returned values are like… wrapped?
14:49:37 <xico> merijn: do you mean setSessionDynFlags … { …, optLevel = 2 }
14:50:04 <merijn> skypers: Normallyl, this wouldn't type check: "foo :: E a -> a; foo (I i) = i; foo (F f) = f"
14:50:07 <skypers> if I try to pattern match Just x with x :: Int in a function that takes Maybe a, it won’t typecheck
14:50:10 <monochrom> hmm, "E a -> a" is not an issue
14:50:17 <merijn> skypers: As the first clause returns Int and the second returns Float
14:50:24 <skypers> merijn: yes
14:50:27 <skypers> I understand that
14:50:43 <skypers> the thing I don’t is that E a is like holding different types as one
14:50:45 <merijn> skypers: However, with GADTs GHC can "see" that any clause using "F f" *must* be 'E Float'
14:50:52 <merijn> skypers: It's not
14:51:00 <skypers> see my Maybe a example just above
14:51:21 <NikolajK> geekosaur: thank you
14:51:25 <nisstyre> skypers: this explains it fairly well http://www.haskell.org/ghc/docs/latest/html/users_guide/data-type-extensions.html#gadt
14:51:26 <k00mi> skypers: I think you're confused
14:51:32 <skypers> k00mi: totally :D
14:51:33 <merijn> skypers: That's because "Just (1 :: Int)" returns "Maybe Int"
14:51:44 <skypers> merijn: well
14:51:49 <skypers> F 1 returns…
14:51:51 <skypers> E Int
14:51:53 <skypers> not E a
14:51:56 <merijn> skypers: No
14:51:58 <skypers> what
14:52:04 <merijn> "F 1 :: E Float"
14:52:13 <skypers> yeah
14:52:16 <skypers> Float
14:52:16 <skypers> sorry
14:52:28 <merijn> skypers: You're thinking on the wrong side of the equation
14:52:37 <skypers> then it’s the same thing as the Maybe a issue
14:52:39 <skypers> arf
14:52:45 <merijn> skypers: If I have "Maybe a -> Bool" I can give it an "Maybe Int", no?
14:52:59 <skypers> sure
14:53:17 <skypers> because the function is polymorphic in its first argument
14:53:20 <merijn> skypers: So if I have "E a -> Bool" I can give it anything, E Float or E Int, no?
14:53:33 <merijn> What's the problem?
14:53:36 <k00mi> skypers: pattern matching on GADTs is no different to pattern matching on normal ADTs
14:53:46 <skypers> merijn: hm
14:54:00 <k00mi> except the compiler can infer something about the type variable from the value
14:54:21 <merijn> skypers: If you're confused that I and F have different types as values, consider this
14:54:35 <skypers> no no
14:54:38 <skypers> I know that
14:54:41 <xico> also, despite setting setSessionDynFlags (foldl dopt_set dflags [Opt_NoHsMain]
14:54:44 <k00mi> skypers: data Foo = I Int | F Float
14:54:48 <merijn> skypers: "foo :: Either Int Char -> Bool; foo (Left i) = ...; foo (Right f) = ..." <- this is fine too
14:54:53 <xico> ghc still complains about not having a main function
14:55:00 <skypers> merijn: well
14:55:06 <xico> (even with ghcLink=NoLink)
14:55:11 <skypers> Left i and Right f return the same Either Int Char
14:55:11 <monochrom> if you give it "x :: E Float", then x is bottom or x is an "F something", there is no other choice, so you don't worry about wrongly looking at "f (I n) = ..."
14:55:22 <merijn> xico: Use -no-hs-main
14:55:39 <geekosaur> [20 21:52] <xico> also, despite setting setSessionDynFlags (foldl dopt_set dflags [Opt_NoHsMain]
14:55:55 <merijn> skypers: Pattern matches don't return anything
14:56:01 <skypers> 22:52 < k00mi> skypers: data Foo = I Int | F Float
14:56:02 <merijn> skypers: They take things apart
14:56:08 <skypers> yes k00mi
14:56:14 <skypers> this is quite okay to me
14:56:20 <skypers> because the type is the same for both the ctors
14:56:43 <skypers> data Foo a = I a | F a
14:56:47 <skypers> still the same thing
14:57:07 <k00mi> skypers: that's exactly the same thing as pattern matching on your GADT
14:57:17 <skypers> data Foo :: * -> *; I :: Int -> F Int; F :: Float -> F Float
14:57:37 <k00mi> skypers: if your function takes a "Foo a", it doesn't matter what that "a" is
14:57:38 <skypers> in that case, I builds a F Int whereas F builds a F Float, which are two different types
14:57:43 <merijn> skypers: I'm not entirely sure what has you so confused
14:57:47 <k00mi> that only gets decided once you pattern match
14:58:23 <skypers> merijn: well, the thing that to me, F a is more a data family than a type
14:58:28 <merijn> skypers: "Just 1" and "Just 'c'" build different types despite having the *same* constructor, I would argue that's even weirder
14:58:30 <xico> merijn: isn't it exactly the same as Opt_NoHsMain ??
14:58:33 <skypers> but now it’s clearer it’s a polymorphic type
14:58:43 <k00mi> there is really zero difference in that regard to pattern matching on any polymorphic type
14:58:50 <merijn> xico: I wasn't paying attention, I have no clue where setSessionDynFlags is from, so ignore me :0
14:59:04 <skypers> ok
14:59:08 <skypers> I think I got it now
14:59:20 <geekosaur> ghc as a library
14:59:29 <skypers> thank you
14:59:37 <skypers> so I can write something like
14:59:47 <skypers> instance (Show a) => Show (E a) where …
14:59:52 <skypers> and pattern match all constructors
14:59:53 <merijn> skypers: Did you read the GADTs wikibook, btw?
15:00:00 <skypers> yes merijn
15:00:11 <nisstyre> merijn: I actually think the ghc manual does a better job explaining it
15:00:19 <nisstyre> at least without the burden of reading a huge explanation
15:00:43 <merijn> skypers: Right, because it only gets one constructor at a time, so while pattern matching the irrelevant ones are ignored
15:00:57 <nisstyre> " The key point about GADTs is that pattern matching causes type refinement."
15:01:04 <merijn> (when you call it, I mean)
15:02:17 <kuribas> So ghc cannot infer al types for GADTs, can it?  I had a type error, but it was fine when I gave a type annotation.
15:02:36 <nisstyre> kuribas: you're supposed to give annotations yeah
15:02:44 <nisstyre> see: http://www.haskell.org/ghc/docs/latest/html/users_guide/data-type-extensions.html#gadt
15:03:37 <xico> (ok, i needed updOptLevel, and not ghcOptLevel)
15:03:52 <kuribas> nisstyre: ah yes, I see.
15:04:01 <Zekka> Anyone know if there's shorthand for the series of definitions made at the end of the example here? http://hackage.haskell.org/package/parsec-3.1.5/docs/Text-Parsec-Token.html#v:makeTokenParser
15:04:19 <Zekka> I vaguely remember using shorthand that just copied out every field but I can't remember what it was
15:05:20 <merijn> Zekka: One of the RecordPuns or whatever extensions?
15:05:41 <Zekka> merijn - I'll check, although  I don't think it was an extension (if it's not just my overactive imagination)
15:06:48 <Zekka> It looks like record puns are a separate pattern
15:08:55 <benmachine> Zekka: RecordWildCards
15:09:24 <benmachine> wait maybe that's not what you want
15:09:26 * benmachine shrug
15:09:36 <Zekka> benmachine - I'll check
15:09:47 <benmachine> Zekka: it means you can do RecordCon{..}
15:10:12 <Zekka> Googling, it looks like it's something separate
15:10:12 <benmachine> as an alias for RecordCon{ field1 = field1, field2 = field2, etc. }
15:10:32 <benmachine> if it's not that then I think it's your imagination :P
15:10:36 <benmachine> but I could be wrong
15:12:12 <benzrf> hej da
15:12:26 <benzrf> i am trying to learn reactive-banana but i do not understand newAddHandler
15:12:33 <benzrf> or, for that matter, what an AddHandler does...
15:12:38 <benzrf> what should i be reading?
15:12:45 <benzrf> right now i am looking at the slot machine source
15:15:42 <Feuerbach> benzrf: looking carefully at its type might help
15:16:19 <benzrf> :[
15:16:25 <benzrf> i see the type
15:16:29 <benzrf> but i dont get what it is useful for
15:17:23 <benzrf> an AddHandler is a supplier of IO a's?
15:18:34 <dethkats> Is there anyone who's going to the London Haskell user group this month?
15:18:39 <MagneticDuck> who here uses vim and folding and haskell?
15:18:47 <benzrf> MagneticDuck: i use vim and haskell
15:18:50 <benzrf> i dont use folding =o
15:18:58 <MagneticDuck> folding is cool
15:19:16 <MagneticDuck> do you use any other sort of system to help navigate around modules?
15:19:36 <colDrMcBeardman> I have three gimongous, immutable (once generated) data structures I will be abusing like global variables. How can I minimize ugliness and get away from passing them around everywhere?
15:19:39 <MagneticDuck> or gg, look at module contents, find thing you want, * multiple times xD
15:19:44 <MagneticDuck> colDrMcBeardman: monads!
15:19:48 <MagneticDuck> they solve everything.
15:19:56 <colDrMcBeardman> right, is this where I need to use the state monad?
15:19:57 <MagneticDuck> reader monad in this case
15:20:01 <colDrMcBeardman> ok reader.
15:20:14 <steamboat> random question is there a cons-equals operator for use in lenses and such?
15:20:15 <steamboat> as in  (a  :~ b) ==  ( a .~ b:a)
15:20:16 <colDrMcBeardman> thx, let me go RTFM
15:20:21 <davidthomas> MagneticDuck: I have things set up to drop various kinds of searches into my quickfix buffer...
15:20:33 <MagneticDuck> quickfix?
15:20:37 <colDrMcBeardman> expect dumb reader questions coming soon to an irc channel near you.
15:20:56 <davidthomas> MagneticDuck: The same place make output goes
15:21:08 <MagneticDuck> make output?
15:21:11 <MagneticDuck> oh
15:21:13 <davidthomas> if you say :make
15:21:29 <MagneticDuck> davidthomas: you're.. using make with haskell?
15:21:32 <benzrf> colDrMcBeardman: reader monad is for unchanging state
15:21:36 <MagneticDuck> I have GhcMod for stuff
15:21:48 <davidthomas> not actual make :-P
15:21:50 <MagneticDuck> oops I might have misread your question colDrMcBeardman
15:21:55 <davidthomas> I'm saying :make w/ Haskell
15:22:00 <benzrf> colDrMcBeardman: a monadic value in the reader monad is a wrapped 'r -> a'
15:22:07 <davidthomas> with my makecmd set different
15:22:13 <MagneticDuck> I see
15:22:30 <MagneticDuck> a while ago I took a few leaps forward and started using more advanced dev tools and syntastic and GhcMod and stuff
15:22:48 <benzrf> colDrMcBeardman: making a kleisli arrow look like 'a -> r -> b'
15:22:49 <davidthomas> 'k
15:23:04 <MagneticDuck> but now I have to decide between learning more about that kind of stuff and arriving at new heights of workflow enlightenment and working on my actual project to do stuff
15:23:44 <benzrf> colDrMcBeardman: essentially, bind is similar to function composition, except that each function also independently receives the same argument
15:24:19 <benzrf> :t (>>=) `asAppliedTo` undefined :: Reader a
15:24:20 <lambdabot>     Expecting one more argument to `Reader a'
15:24:20 <lambdabot>     In an expression type signature: Reader a
15:24:20 <lambdabot>     In the expression: (>>=) `asAppliedTo` undefined :: Reader a
15:24:23 <colDrMcBeardman> yeah, they will be unchanging once they are generated. basically just three structures that I will be searching.
15:24:24 <benzrf> oops
15:24:35 <benzrf> :t (>>=) `asAppliedTo` undefined :: Reader r a
15:24:36 <lambdabot>     Couldn't match type `m0 a0 -> (a0 -> m0 b0) -> m0 b0'
15:24:37 <lambdabot>                   with `ReaderT r Identity a'
15:24:37 <lambdabot>     Expected type: Reader r a
15:24:39 <benzrf> :[
15:24:46 <benzrf> :t (>>=) `asAppliedTo` (undefined :: Reader r a)
15:24:47 <lambdabot> ReaderT r Identity a -> (a -> ReaderT r Identity b) -> ReaderT r Identity b
15:24:52 <colDrMcBeardman> first structure is just a bloom filter for performance. If it passes the bloom filter, it will look in the first structure, then the second for what it gets from the first.
15:24:54 <benzrf> colDrMcBeardman: ^
15:25:21 <k00mi> steamboat: I don't quite understand what you want to do. You wan't to check if the tail of a list is equal?
15:25:23 <colDrMcBeardman> I think I meant second and third.
15:25:39 <benzrf> colDrMcBeardman: if you ignore the newtype wrappers and imagine that you are using a non-transformer version
15:25:42 <benzrf> colDrMcBeardman: then:
15:26:01 <benzrf> (>>=) :: (r -> a) -> (a -> r -> b) -> (r -> b)
15:26:19 <benzrf> :t runReader
15:26:20 <lambdabot> Reader r a -> r -> a
15:26:45 <skypers> dammit
15:26:58 <steamboat> k00mi: I mean with a lens into list a, and an element b, return the new thing with b cons'd to the front  of a
15:27:06 <skypers> merijn: when defining the Show instance
15:27:23 <skypers> I can’t write Vec2 x y -> "Vec2 (" ++ show x ++ ") (" ++ show y ++ ")"
15:27:35 <steamboat> k00mi: just said cons= since I'd say += in other languages, even though not changing state, etc.
15:27:42 <skypers> even with the (Show a) => Show (E a) in the instance declation
15:27:57 <skypers> I guess it’s because the a is not the same for each constructor
15:28:15 <skypers> is there a way to bypass that?
15:28:42 <benzrf> colDrMcBeardman: and that makes foldl (>>=) have type
15:28:43 <benzrf> (r -> a) -> [a -> r -> a] -> r -> a
15:29:08 <benzrf> compare to:
15:29:11 <benzrf> :t foldl (.)
15:29:13 <lambdabot> (b -> c) -> [b -> b] -> b -> c
15:29:25 <k00mi> steamboat: there is no operator specifically for that as far as I know (you never know with lens :P), but that would be quite easy with %~
15:29:45 <dmj`> skypers: you want to use lenses to append values from a record?
15:29:47 <benzrf> paging edk
15:29:59 <steamboat> k00mi: I think my current work around is using <>~ [b]
15:30:55 <k00mi> steamboat: lens :~ b = lens %~ (b:)
15:31:20 <steamboat> k00mi: I don't know which one looks nicer
15:31:24 <k00mi> steamboat: also see Control.Lens.Cons if you haven't yet
15:32:53 <steamboat> k00mi: that looks promising, thanks!
15:34:35 <benzrf> are there any fp or haskell related conventions or conferences i could attend as a minor
15:34:42 <benzrf> in the us, preferably?
15:34:57 <skypers> dmj`: what?
15:34:57 <skypers> no
15:35:23 <hpc> physically getting to them would be a challenge
15:35:24 <georgeee> @pl "\a->\b->\c -> f a b c"
15:35:25 <lambdabot> (line 1, column 11):
15:35:25 <lambdabot> unexpected "c"
15:35:25 <lambdabot> expecting expression
15:35:34 <benzrf> hpc: :|
15:35:50 <hpc> unless you live in boston or something
15:35:51 <benzrf> 06:26 < tjb|away> http://gyazo.com/ebeda767fb7c557e6d1409401aa666c8
15:35:53 <benzrf> oops
15:35:55 <benzrf> wrong paste
15:35:59 <benzrf> hpc: maine
15:36:03 <benzrf> pretty close to boston
15:36:11 <benzrf> @pl \a->\b->\c -> f a b c
15:36:11 <lambdabot> f
15:36:12 <hpc> you might be able to drive in
15:36:23 <benzrf> whats happening in boston?
15:36:24 <skypers> I just want a way to define GADT like data E a where … a is the same for all constructors that use a
15:36:29 <SwashBuckla> meetup.com!
15:36:33 <georgeee> @help pl
15:36:33 <lambdabot> pointless <expr>. Play with pointfree code.
15:36:46 <georgeee> @pl "\a->\b->\c -> f a b c"
15:36:46 <lambdabot> (line 1, column 11):
15:36:46 <lambdabot> unexpected "c"
15:36:46 <lambdabot> expecting expression
15:36:47 <hpc> benzrf: it's just where most things happen ;)
15:36:48 <flebron> Is there actual uses for pointed functors? I can only find them in the nLab.
15:36:52 <skypers> so that when I try to instante Show, I don’t have fucked up a
15:36:55 <benzrf> georgeee: you dont use quotes >_<
15:36:57 <georgeee> @pl "g = \a->\b->\c -> f a b c"
15:36:57 <lambdabot> (line 1, column 15):
15:36:57 <lambdabot> unexpected "c"
15:36:57 <lambdabot> expecting expression
15:36:58 <hpc> i think seattle is another big one
15:36:58 <benzrf> hpc: hah
15:38:15 <davidthomas> MagneticDuck: For sure, process improvements can be valuable but at some point one needs to stop yak-shaving
15:39:23 <MagneticDuck> hm
15:39:26 * hackagebot clash-prelude 0.4 - CAES Language for Synchronous Hardware - Prelude library  http://hackage.haskell.org/package/clash-prelude-0.4 (ChristiaanBaaij)
15:39:34 <caseof> I'm often writing something like: join ((fmap f) x)    Any simpler form?
15:39:52 <flebron> Also, what's a decently used type ctor which is not a functor (and not because it needs another typeclass like Set)?
15:39:54 <MagneticDuck> that xkcd comic talking about automation improvements payoff vs. time spent comes to mind
15:40:00 <georgeee> @pl \a->\b->\c -> f a b c
15:40:00 <lambdabot> f
15:40:05 <bitemyapp> caseof: >>= ?
15:40:18 <caseof> :t >>=
15:40:20 <lambdabot> parse error on input `>>='
15:40:20 <georgeee> @pl g (\a->\b->\c -> f a b c)
15:40:20 <lambdabot> g f
15:40:25 <benzrf> caseof: ahaha
15:40:25 <bitemyapp> :t (>>=)
15:40:25 <caseof> :t (>>=)
15:40:26 <lambdabot> Monad m => m a -> (a -> m b) -> m b
15:40:26 <lambdabot> Monad m => m a -> (a -> m b) -> m b
15:40:34 <MagneticDuck> @pl \a-> \b -> \c -> f c b a -- georgeee, this is more interesting =P
15:40:34 <lambdabot> flip (flip . flip f)
15:40:36 <benzrf> caseof: do you really know join but not bind
15:40:44 <MagneticDuck> flips galore!
15:40:51 <georgeee> @pl \a->\b->\c -> g $ f a b c
15:40:51 <lambdabot> ((g .) .) . f
15:40:52 <benzrf> MagneticDuck: cant be arsed
15:40:58 <flebron> :t flip ((join .) . fmap)
15:40:59 <lambdabot> (Monad m, Functor m) => m a1 -> (a1 -> m a) -> m a
15:41:02 <bitemyapp> benzrf: I'm actually surprised and terrified that they managed to figure out join and fmap but not encounter bind.
15:41:03 <benzrf> georgeee: why not just curry =]
15:41:09 <benzrf> bitemyapp: yeah D=
15:41:19 <benzrf> 9+
15:41:19 <caseof> benzrf: Yes, for some reason I get join, but not bind. Anyway, I'll look at it
15:41:20 <MagneticDuck> benzrf: ?
15:41:23 <bitemyapp> benzrf: says a lot for the intuitiveness of join + fmap + return though.
15:41:33 <benzrf> MagneticDuck: 'cba' == cant be arsed
15:41:39 <MagneticDuck> ah
15:41:46 <MagneticDuck> are you sure it can't be arsed?
15:41:52 <benzrf> can it be?
15:41:57 <MagneticDuck> it can be!
15:41:57 <benzrf> > can you be arsed
15:41:59 <lambdabot>  Not in scope: `can'
15:41:59 <lambdabot>  Perhaps you meant one of these:
15:41:59 <lambdabot>    `tan' (imported from Prelude),
15:41:59 <lambdabot>    `cat' (imported from Text.PrettyPrint.HughesPJ),
15:41:59 <lambdabot>    `con' (imported from Data.Number.Symbolic)Not in scope: `you'Not in scope:...
15:41:59 <MagneticDuck> ?
15:42:01 <benzrf> error
15:42:01 <flebron> In explaining monads, I find bind to be somewhat contrived. The mathematical (mu, eta) definition seems cleaner.
15:42:03 <benzrf> clearly it cant
15:42:12 <MagneticDuck> @faq can be arsed?
15:42:12 <lambdabot> The answer is: Yes! Haskell can do that.
15:42:14 <benzrf> flebron: yeah, but bind is the most common use caseof
15:42:15 <MagneticDuck> okay!
15:42:16 <benzrf> *case
15:42:27 <MagneticDuck> benzrf: lol let's go to -blah
15:42:29 <georgeee> @pl \a->\b->\c -> g $ f d a b c
15:42:29 <lambdabot> ((g .) .) . f d
15:42:45 <georgeee> @pl \a->\b->\c -> (j.g) $ f d a b c
15:42:45 <lambdabot> (((j . g) .) .) . f d
15:42:49 <flebron> Well, the most common used thing is "<-", not (>>=) :p Haskell could well desugar to join.
15:43:07 <benzrf> fft
15:43:23 <benzrf> it maps more directly to bind sry2saynotsry
15:44:27 * hackagebot clash-lib 0.2.2.1 - CAES Language for Synchronous Hardware - As a Library  http://hackage.haskell.org/package/clash-lib-0.2.2.1 (ChristiaanBaaij)
15:44:29 * hackagebot clash-ghc 0.2.2.2 - CAES Language for Synchronous Hardware  http://hackage.haskell.org/package/clash-ghc-0.2.2.2 (ChristiaanBaaij)
15:44:41 <skypers> merijn: monochrom http://lpaste.net/101526
15:44:43 <skypers> :(
15:44:48 <skypers> I don’t understand
15:44:58 <skypers> why does GHC try to use a1 instead of a?
15:45:10 <skypers> Vec2 uses the same a as I, U F and all other ctors!
15:45:40 <georgeee> @pl \a->\b->\c -> (\r -> (pid, Constructor pid, r)) $ f d a b c
15:45:41 <lambdabot> (((,,) pid (Constructor pid) .) .) . f d
15:45:55 <georgeee> @pl \a->\b->\c -> (\r -> (pid, Constructor pid r)) $ f d a b c
15:45:55 <lambdabot> ((((,) pid . Constructor pid) .) .) . f d
15:46:55 <georgeee> @pl \d -> (\a->\b->\c -> (\r -> (d, Constructor d r)) $ f d a b c)
15:46:55 <lambdabot> ap ((.) . (.) . (.) . liftM2 (.) (,) Constructor) f
15:47:32 <georgeee> @pl (\d -> (\a->\b->\c -> (\r -> (d, Constructor d r)) $ f d a b c)) pid
15:47:32 <lambdabot> ((((,) pid . Constructor pid) .) .) . f pid
15:49:21 <skypers> ok, got to go…
15:51:33 <georgeee> @pl (\pid storage -> (((\info -> (pid, setProcInfo storage{ nextPid = pid + 1 } pid info))  . ) . ) . ProcInfo pid) $ nextPid storage
15:51:34 <lambdabot> (line 1, column 34):
15:51:34 <lambdabot> unexpected ","
15:51:34 <lambdabot> expecting letter or digit, variable, "(", operator or ")"
15:51:45 <MagneticDuck> georgeee: alright that's it, get your own copy of lambdabot :D
15:51:47 <quchen> georgeee: You can also /msg lambdabot
15:51:49 <MagneticDuck> (or use /msg)
15:52:32 <georgeee> oh, I didn't know it prints messages to everybody
15:52:33 <MagneticDuck> guys, is there any cool way of defining a bunch of values to have the same type?
15:52:47 <MagneticDuck> georgeee: x|
15:52:50 <kadoban> for using Parsec on binary data...I think I want a new Stream instance, with Word8 as the token type...does that sound possible, or am I doing something wrong?
15:53:08 <kadoban> I don't totally understand why Text.Parsec.ByteString has Char as the token type?
15:53:16 <MagneticDuck> new to IRC? Use /msg (default client command) with parameters <nick> <msg> to initiate a private session with a user
15:54:41 <georgeee> Thanks, MagneticDuck =)
15:55:11 <jmcarthur> MagneticDuck: do you mean to give multiple values the same type annotation or just to define multiple values that have the same type?
15:55:38 <MagneticDuck> a, b, c :: Type -- works for me
15:55:53 <MagneticDuck> but now, does Haddock play friendly with things like that?
15:55:59 <MagneticDuck> defining a bunch of constants
15:56:07 <jmcarthur> > let [these, have, the, same, type] = [1,2,3,4,5] in (these, have, the, same, type)
15:56:09 <lambdabot>  <hint>:1:30: parse error on input `type'
15:56:12 <jmcarthur> ah
15:56:17 <jmcarthur> > let [these, have, the, same, type_] = [1,2,3,4,5] in (these, have, the, same, type_)
15:56:18 <lambdabot>  (1,2,3,4,5)
15:56:30 <jmcarthur> yeah, the comma thing is all you need
15:56:47 <jmcarthur> should be fine with haddock, except if you want to document each separately
15:56:56 <jmcarthur> not sure how to go about that, in this case
15:57:24 <MagneticDuck> http://ix.io/bbT
15:57:27 <MagneticDuck> just something simple
16:03:30 <dgpratt> messing around with HDBC (ODBC) for the first time and I'm getting an error: DatabaseHDBCODBCStatement.hsc:347:8-47: Irrefutable pattern failed for pattern (Database.HDBC.ODBC.Statement.BindColString buf bufLen col)
16:03:57 <dgpratt> http://lpaste.net/101527
16:04:08 <dgpratt> am I doing anything obviously wrong?
16:05:54 <cdk_> I have a program I'm trying to parallelize, but GHC is GC'ing all my sparks. I can't see why, the result of the parallel computation is used immediately after so I don't see why GHC thinks the sparks aren't being evaluated. Code and comments here, the relevant function is `parFindNearest`: http://lpaste.net/101528 Can anyone help me get this working properly?
16:09:29 * hackagebot shake 0.11.4 - Build system library, like Make, but more accurate dependencies.  http://hackage.haskell.org/package/shake-0.11.4 (NeilMitchell)
16:10:01 <cdk_> i'm compiling with "ghc -O2 -fllvm -threaded" and running with "./RGB +RTS -N2 -s"
16:13:18 <jmcarthur> cdk_: i'm guessing: you're using a right fold in findNearest, so the result will be evaluated lazily. it returns a tuple. i'm guessing that parMap is only evaluating up to the tuple constructor
16:13:32 <jmcarthur> but hmm that isn't consistent with your results
16:13:44 <jmcarthur> should be that they were converted, if that was the case
16:13:49 <jmcarthur> so my guess was wrong
16:14:54 <jmcarthur> cdk_: i'll guess instead that since you're demanding the results so soon after sparking that the main thread is grabbing the thunks before they are evaluated and just evaluating them itself.
16:15:34 <cdk_> yes, its confusing. The sparks aren't being converted at all! I had at first thought foldr or laziness from (,) was the problem, but replacing (,) with data SP a b = SP !a !b didnt help either
16:15:44 <jmcarthur> i'm trying to remember the difference between GC and fizzle. the latter is sparks that had begun evaluating but were GCed before completion?
16:16:01 <jmcarthur> and the former is sparks that never started before being GCed?
16:16:25 <jmcarthur> if so this seems consistent with my second theory
16:16:28 <cdk_> hmm, that could be it, seeing as I'm getting some GC'd, some fizzling
16:17:54 <cdk_> I don't see how I can "wait" to give the sparks a chance to resolve, I'm using a simple application of parMap.
16:18:28 <monochrom> @tell skypers it seems to me you do not need "Show a" at all. just begin with "instance Show (E a) where ..."
16:18:28 <lambdabot> Consider it noted.
16:19:30 * hackagebot yaml-light-lens 0.3.1 - Lens interface to yaml-light.  http://hackage.haskell.org/package/yaml-light-lens-0.3.1 (AnthonyCowley)
16:24:31 * hackagebot singletons 0.10.0 - A framework for generating singleton types  http://hackage.haskell.org/package/singletons-0.10.0 (RichardEisenberg)
16:27:44 <SwashBuckla> I am using Precise 12.04. What is the best way to get up and running with a Haskell environment?
16:32:17 <MagneticDuck> http://ix.io/bbW
16:32:23 <MagneticDuck> how would I document that with haddock?
16:32:28 <MagneticDuck> trying to haddockify my code
16:32:35 <MagneticDuck> SwashBuckla: sudo apt-get ghc
16:32:41 <MagneticDuck> ^^
16:32:48 <cwvh> My opinion would be to get a GHC binary from http://www.haskell.org/ghc/download_ghc_7_6_3#x86_64linux and install it to /usr/local/ghc. Then add /usr/local/ghc/bin to your $PATH and run 'cabal update && cabal install cabal-install'
16:33:18 <cwvh> SwashBuckla: but you can also use your package manager if you don't mind having a slightly older version of GHC: sudo apt-get install haskell-platform
16:34:03 <SwashBuckla> mm
16:34:07 <MagneticDuck> (I'm looking to keep those nice sections)
16:34:23 <SwashBuckla> I am running into 'dependency hell' with the sudo apt-get install ghc method
16:34:46 <SwashBuckla> needing to constrain template-haskell to 2.7 and other things in cabal due to Hackage offering a newer version
16:35:03 <MagneticDuck> interesting
16:36:28 <cwvh> SwashBuckla: sounds like a disaster. I'd go with the GHC binary install and side-step the system package manager. Always been easier in my opinion.
16:37:28 <MagneticDuck> anybody have any ideas on my haddock problem? :<
16:37:53 <acowley> SwashBuckla: I do the same as cwvh
16:37:59 <xico> cabal is the worst hell since the invention of computer imho
16:38:24 <alang> @pl \(a, b) -> (a, (a, b))
16:38:24 <lambdabot> uncurry (liftM2 (.) (,) (,))
16:38:34 <hpc> hell is other libraries
16:38:46 <xico> hell is the world in cabal eye
16:38:49 <MP2E> hell is tetris with a round bottom
16:38:54 <acowley> I don't even know how people have problems with cabal since sandboxes
16:38:57 <cwvh> I don't find cabal to be any problem these days with hsenv and cabal sandboxes.
16:39:00 <hpc> MP2E: you can actually get lines in that
16:39:17 <xico> acowley: yeah, we should sanbox everything just so it works
16:39:24 <xico> actually lets use only static libs
16:39:27 <xico> wait...
16:39:29 <MagneticDuck> xico: it's also as necessary as the computer =P
16:39:41 <acowley> Worst case scenario, you blow away a sandbox. Even if that's a pain, your other projects are untouched.
16:40:01 <acowley> Who doesn't sandbox everything, and why not?
16:40:31 <cwvh> I still hsenv things that I really don't care about. For example, testing a package that I read on a blog or similar.
16:40:35 <xico> acowley: just to be sure we should put every project in its own vmware
16:40:36 <acowley> I'm not being rhetorical. Is there a good reason to not use them?
16:41:14 <acowley> xico: If your portability requirements aren't meant by other mechanisms, then sure
16:41:28 <MagneticDuck> worst case scenario, dangerous IO side effects evolve into an intelligent form of "life" and, motivated by a mysterious drive for evil, figures out a way to launch nuclear missiles by hacking into a US military base's network
16:41:49 <acowley> MagneticDuck: You're right, that phrase is terrible and I feel bad for using it :(
16:41:54 <MagneticDuck> good.
16:42:00 <acowley> Your work here is done
16:42:03 <acowley> mission accomplished
16:42:35 <MagneticDuck> acowley: DO YOU HEARD ABOUT MY CABAL PROBLEM?
16:42:42 <acowley> MagneticDuck: No
16:42:44 <xico> (actually i was just checking if i was online, sanboxes are great)
16:43:07 <MagneticDuck> I'm trying to figure out a way to make sections in the documentation of a large record syntax data constructor
16:43:14 <MagneticDuck> hopefully I"m making sense
16:43:17 <MagneticDuck> backlog has it all
16:43:30 <acowley> Huh
16:44:02 <Fuuzetsu> MagneticDuck: use the -- ^ syntax to document the fields
16:44:36 <MagneticDuck> Fuuzetsu: but this works too and I'm working on a small monitor and sometimes like to work splitscreen
16:44:40 <hpc> that's not specifically for fields
16:44:54 <Fuuzetsu> MagneticDuck: http://www.haskell.org/haddock/doc/html/ch03s04.html
16:45:01 <hpc> | is for "comments above the thing" and ^ is for below; you can put it wherever
16:45:24 <Fuuzetsu> sorry wrong link, http://www.haskell.org/haddock/doc/html/ch03s02.html
16:45:31 <merijn> Where "after on the same line" qualifies as "below"
16:45:41 <MagneticDuck> the thing I pasted isn't even an attemp at haddocking it, it's just how it is now
16:46:29 <Fuuzetsu> so what's your problem?
16:46:55 <MagneticDuck> I want to add sections!
16:47:01 <MagneticDuck> like, how I have it organised there
16:47:10 <MagneticDuck> I want it to have sections in the haddock documentation
16:48:31 <Fuuzetsu> I don't know what you mean by sections. You can use the new header syntax if you have recent Haddock if that's what you need.
16:48:48 <acowley> MagneticDuck: Just put the fields and section headings in the export list?
16:48:53 <acowley> (trying it now)
16:49:20 <SwashBuckla> cwvh, acowley: ok, thanks :)
16:49:42 <acowley> Hm, it doesn't work very well
16:50:02 <Fuuzetsu> acowley: I don't imagine it would, we have a bunch of tickets open about export list shenanighans
16:50:34 <acowley> I just have empty sections in the haddock, but the record fields are all tightly attached to the data constructor
16:50:54 <acowley> I guess that means it's impossible
16:51:01 <Fuuzetsu> AFAIK the only thing to detach the fields is to hide the constructor itself, acowley
16:51:02 <MagneticDuck> darn
16:51:05 <Fuuzetsu> the only way*
16:51:10 <acowley> Fuuzetsu: yep
16:52:03 <acowley> Haddock has seen a recent rewrite, so maybe adding this kind of flexibility is easier now
16:52:15 <Fuuzetsu> I think it's a fair behaviour, it doesn't make much sense to split up fields into separate sections. You could just have a single large section using headers and linking the fields from there (which would be more presentable and would keep your record in a single place)
16:52:18 <acowley> But I have no first-hand knowledge of how it all works
16:52:51 <Fuuzetsu> acowley: Well, it wasn't exactly a rewrite but I was the one who did a lot of stuff ;P
16:53:09 <acowley> I think it makes some sense if you've already crossed the bridge of having an enormous record
16:53:23 <acowley> Writing your own projection functions from a really massive record is painful
16:53:24 <copumpkin> bos: congratulations on all the coverage :)
16:53:48 <Fuuzetsu> oh, bos is here. bos, any chance for a new aeson version upload?
16:53:49 <acowley> Fuuzetsu: Ah! Well then, thank you for working on it!
16:54:31 <Fuuzetsu> acowley: I recruited some help recently. We now have things like type families, minimal pragmas and fixity information (none of which I implemented!)
16:55:51 <contrapumpkin> argh
16:56:41 <Fuuzetsu> http://fuuzetsu.co.uk/images/1395359648.png isn't it nice~
16:57:18 <acowley> Ooh, that is nice!
16:57:50 <acowley> Unfortunately I need to check which way binding precedence goes every time I think about it.
17:00:42 <MagneticDuck> http://ix.io/bbX
17:00:54 <MagneticDuck> apparently this is not well formed
17:00:56 <MagneticDuck> ??!?
17:01:22 <MagneticDuck> sorry about these -- {{{, they're my beloved fold markers <3
17:02:47 <Fuuzetsu> MagneticDuck: If you read the documentation then you'd know that you can't document each parameter to a constructor like that and can only put the doc on the constructor itself (i.e. you can only document GameEventKey data constructor, GameEventKey type constructor, and GameMotionEvent). If you want to document each parameter, use a record and document the fields. Please read the docs
17:03:03 <MagneticDuck> well I could read the docs
17:03:10 <MagneticDuck> or I could get you guys to magically solve my problems
17:03:15 <MagneticDuck> =P
17:03:17 <MagneticDuck> whatever, brb
17:03:38 <jrmithdobbs> i'm sorry but "read the docs" re: haddock is just being an asshole
17:03:40 <Fuuzetsu> the docs are written for a reason, you just make we want to not help you with that attitude
17:03:43 <jrmithdobbs> there's not even a summary list of the meta chars
17:03:45 <jrmithdobbs> stop being a dick
17:04:12 <Fuuzetsu> jrmithdobbs: I'm not being a dick, I already pointed him exactly to what he needed for his previous question.
17:04:23 <jrmithdobbs> you kinda being a dick
17:04:29 <jrmithdobbs> s/you/you're/
17:04:42 <Fuuzetsu> if you have a problem with the docs themselves then say so rather than calling me a dick for answering the guy's questions
17:07:36 <MagneticDuck> darn, haddock doesn't like  my cute little fold markers!
17:07:37 <MagneticDuck> >:0
17:08:23 <Fuuzetsu> if they are in the comment then they'll show up, I'm unsure what you'd expect otherwise
17:09:15 <MagneticDuck> maybe {- will help?
17:10:29 <MagneticDuck> but this is just ugly: http://ix.io/bbY
17:10:48 <MagneticDuck> xD
17:18:35 <markus___> i have the following error in hxt: "xpCheckEmptyContents: unprocessed XML content detected"
17:19:06 <markus___> does anyone know, how to avoid this error?
17:19:33 <markus___> i want to unpickle an XML file whereby i do not want to consider the whole document
17:21:38 <SwashBuckla> cwvh: hi. I am trying to install the ghc binary as you suggested, but I am running into the following error when I run ./configure: checking for path to top of build tree... utils/ghc-pwd/dist-install/build/tmp/ghc-pwd: error while loading shared libraries: libgmp.so.3: cannot open shared object file: No such file or directory
17:21:55 <SwashBuckla> do I make a symlink in that path?
17:22:07 <Fuuzetsu> markus___: I seem to recall stumbling upon this…
17:22:28 <SwashBuckla> I do have libgmp.so.3 at /usr/lib/libgmp.so.3
17:23:21 <cwvh> SwashBuckla: hrmm..
17:23:51 <Fuuzetsu> markus___: http://stackoverflow.com/questions/12080512/ignoring-xml-attributes-with-hxt-unpickler
17:24:32 <Fuuzetsu> oh damn, I just looked at the person who created that question and it was myself! I knew it sounded familiar
17:24:48 <MP2E> hehee
17:24:54 <MP2E> that's interesting
17:24:59 <cwvh> SwashBuckla: ls -l /usr/lib/libgmp.so*
17:25:11 <markus___> thx
17:26:58 <SwashBuckla> cwvh: lrwxrwxrwx 1 root root 42 Mar 21 00:10 /usr/lib/libgmp.so.3 -> /usr/lib/x86_64-linux-gnu/libgmp.so.10.0.5
17:27:16 <cwvh> SwashBuckla: dpkg --get-selections | grep '*gmp*'
17:27:35 <SwashBuckla> cwvh: (Nothing returned)
17:27:55 <cwvh> SwashBuckla: sudo apt-get install libgmp3c2
17:30:01 <cwvh> That package might not even exist anymore now that I think about it.
17:30:12 <SwashBuckla> cwvh: great. It's compiling now
17:30:17 <SwashBuckla> cwvh: (ghc)
17:30:34 <cwvh> cool, did you set --prefix?
17:30:47 <cwvh> ./configure --prefix=/usr/local/ghc
17:31:01 <SwashBuckla> erm
17:31:03 <SwashBuckla> no
17:31:06 <cwvh> it's not a requirement, but I like to keep my ghc installations localized and not scattered all over /usr/local/{bin,lib}
17:31:35 <cwvh> that way if you want to upgrade to a newer version, you just point your PATH and say, /usr/local/ghc-new
17:31:45 <cwvh> I hope that makes sense.
17:31:55 <SwashBuckla> yeah that makes sense
17:32:07 <SwashBuckla> it's quite a nice self-contained package, that way
17:32:15 <cwvh> Exactly. You should be able to just re-run configure with the arguments above.
17:34:37 * hackagebot snap-testing 0.4.0.0 - A library for BDD-style testing with the Snap Web Framework  http://hackage.haskell.org/package/snap-testing-0.4.0.0 (DanielPatterson)
17:36:51 <kgadek> hi. I'm not having much experience with Haskell and "research" was inconclusive. I'm about to write some genetic algorithms for my master thesis. I was about to use C++ ("speed"), but now I'm thinking about… what's the expected behaviour of haskell here? shall I expect roughly the same runtime or much slower? GC shall be the problem or GHC could inline memory deallocations?
17:40:28 <cwvh> kgadek: I usually expect my tuned Haskell to be 20-80% of the performance I get out of my tuned C++. If I have an I/O-bound problem, it's a wash.
17:41:36 <kadoban> kgadek: that's about what i was going to say as well.  http://benchmarksgame.alioth.debian.org/u64/benchmark.php?test=all&lang=ghc&lang2=gpp&data=u64  this site throws some numbers into it, if you're curious, for a few toy problems
17:41:57 <acowley> It's a very nebulous comparison, though
17:42:19 <acowley> The cliche that Haskell makes it easier to tune your algorithm is a cliche because it's true
17:42:35 <acowley> The cliche that Haskell has its own performance pitfalls is also true
17:42:49 <kgadek> I don't like alioth too much. But I see the pattern
17:43:44 <acowley> I write a huge volume of code. If I had to do it in C, I just couldn't do as much. That makes it hard to compare performance.
17:44:00 <kgadek> C++11 is quite nice though
17:44:10 <acowley> It is
17:44:17 <kgadek> especially if I have Python prototype :)
17:44:18 <cwvh> it's not _that_ nice, though
17:44:33 <kgadek> cwvh: that's why I'm asking ;)
17:45:15 <acowley> It does help if you can predict your performance bottlenecks
17:45:39 <acowley> If you're pointer chasing and mutating, an immutable Haskell version might be significantly slower
17:45:56 <cwvh> kgadek: If you do end up wanting to tune performance, Haskell is _amazing_ in its simplicity to profile and drop to basically pointer arithmetic.
17:46:24 <kgadek> cwvh: ok, that's a good news. Beside RWH, are there any good reads on optimizing haskell?
17:46:27 <acowley> But if you're doing pointer arithmetic, doing it in C++ is fine
17:46:34 <thaicares> Is anyone familiar with gitit? A wiki using HAppS, pandoc, and git
17:47:06 <ezrios> @hoogle (.~)
17:47:07 <lambdabot> No results found
17:47:11 <ezrios> what the hell is this
17:47:32 <acowley> It's from lens
17:47:43 <cwvh> kgadek: RWH was where I learned all my profiling.. that chapter one doing the average over a list walks you through my current routine. I'd also suggest reading Data.ByteString's source.
17:47:43 <acowley> It's how you set the target of a lens
17:47:46 <kgadek> acowley: that shall be rather calling some nasty functions on many objects, than firing some stats-calculations that are quite heavy (O(n^3) if i recall well), etc
17:48:02 <kgadek> so mutable array is a must as far as I'm aware
17:48:20 <ezrios> acowley: oh, it's set
17:48:27 <ezrios> strange how hoogle does not find it ._.
17:49:14 <kgadek> cwvh: ok, so starting digging into bytestrings now. thanks.
17:50:07 <cwvh> kgadek: well, I'd personally start coding some known GA stuff in Haskell to figure out if it's a good match. Profiling and tuning can come later.
17:50:49 <kgadek> cwvh: I can tell you python is *not* a good match already :)
17:51:14 * cwvh shrugs
17:51:38 <cwvh> I've seen some amazing things done with well thought out numpy usage, but sure, there's a lot of interpreter overhead if you're sitting in for-loops
17:52:36 <cwvh> my gripe with writing python sits more in the fact that I don't like writing unit tests that approximate a type system... type checking at crash time
17:52:46 <kgadek> yes, numpy is awesome. Cython is even more awesome
17:52:52 <caseof> A have a module (Control.Monad.Error) that is found in multiple packages. I'm using cabal so build ok. But how can I start ghci?
17:53:06 <ezrios> caseof: cabal repl
17:53:25 <geekosaur> cabal repl, or use -package to specify the package to get it from
17:53:39 <caseof> Thx. Is it new? Not working on cabal 1.16
17:54:00 <ezrios> caseof: I think it's >=1.18
17:54:01 <geekosaur> cabal repl is from 1.18, yes
17:54:06 <geekosaur> so you need to use -package
17:54:09 <geekosaur> or upgrade
17:54:24 <caseof> Awesome, thx.
17:54:46 <seanparsons> I suspect my Google-Fu is failing me here, but is there a way to pattern match on a field/reference without a guard?
17:55:05 <seanparsons> Scala supports such a syntax by the use of backticks for example.
18:01:25 <hunt> hey guys
18:01:32 <hunt> if i have a list of elements
18:01:35 <hunt> and for each element
18:01:39 <hunt> i want to replace the elemnt
18:01:45 <hunt> with 12 separate iterations of a function
18:01:51 <hunt> what would be th best method
18:03:14 <hunt> take 12 . iterate $?
18:03:22 <hunt> im really not certain how to go about this
18:04:21 <thebnq> sounds like it would work
18:04:31 <thebnq> > map (take 12 . iterate (+1)) [1..5]
18:04:32 <lambdabot>  [[1,2,3,4,5,6,7,8,9,10,11,12],[2,3,4,5,6,7,8,9,10,11,12,13],[3,4,5,6,7,8,9,1...
18:13:20 <k00mi> seanparsons: what do you mean by "field/reference"
18:13:48 <george2> Is there a typeclass for positive integers?
18:14:32 <k00mi> george2: no
18:14:40 <george2> ok
18:14:41 <k00mi> at least not in base
18:14:42 <seanparsons> k00mi: The way these backticks are used here: http://seanparsons.github.io/scalawat/Pattern+Matching+Fields.html
18:15:59 <k00mi> so that checks if value == expected?
18:16:09 <seanparsons> Yeah.
18:16:29 <k00mi> no, that doesn't exist in haskell
18:16:33 <k00mi> it wouldn't even typecheck
18:17:36 <seanparsons> k00mi: Well I was expecting them to be the same type in the use I've got, obviously that example is with the ever present equality of languages on the JVM.
18:19:26 <k00mi> still you need a guard for that
18:19:33 <k00mi> something like:
18:19:47 <k00mi> foo value expected | value == expected = "It worked"
18:20:02 <k00mi> foo value expected = other stuff
18:20:13 <k00mi> or another guard instead of pattern match
18:21:07 <k00mi> but note that if the guard is false, the next pattern is tried, it's not yet commited to that branch
18:22:02 <george2> I can use || in a guard expression, right? It looks strange.
18:23:31 <geekosaur> you can, yes
18:28:19 <dwcook> I once wrote a function that alternated | and || for several lines. It wasn't the most pleasant to read :P
18:28:54 <hunt> how do i zip list a and list b into [a.b]
18:29:18 <dwcook> hunt, I don't understand your syntax, but you don't just mean zip, do you?
18:29:19 <dwcook> @type zip
18:29:20 <lambdabot> [a] -> [b] -> [(a, b)]
18:29:27 <hunt> i dont want a tuple
18:29:29 <dwcook> > zip [1..] [5..]
18:29:30 <lambdabot>  [(1,5),(2,6),(3,7),(4,8),(5,9),(6,10),(7,11),(8,12),(9,13),(10,14),(11,15),(...
18:29:36 <dwcook> hunt, what do you want?
18:29:49 <k00mi> > zipWith (.) [a] [b]
18:29:51 <lambdabot>  Couldn't match expected type `b0 -> c0'
18:29:51 <lambdabot>              with actual type `Debug.SimpleReflect.Expr.Expr'Couldn't match e...
18:29:51 <lambdabot>              with actual type `Debug.SimpleReflect.Expr.Expr'
18:29:51 <hunt> i have [a,a1...] and [b,b1...] and i want [[a,b],[a1,b1]...]
18:30:02 <hunt> sorry theperiod was a typo
18:30:21 <dwcook> > zipWith (\a b -> [a, b]) [1..] [5..]
18:30:23 <lambdabot>  [[1,5],[2,6],[3,7],[4,8],[5,9],[6,10],[7,11],[8,12],[9,13],[10,14],[11,15],[...
18:30:32 <hunt> is the best way to use lambda?
18:30:45 <dwcook> In this case, probably
18:30:50 <hunt> alright, thanks
18:31:49 <k00mi> > zipWith (flip (:) . (:[])) [1..] [5..]
18:31:50 <lambdabot>  [[5,1],[6,2],[7,3],[8,4],[9,5],[10,6],[11,7],[12,8],[13,9],[14,10],[15,11],[...
18:32:11 <k00mi> almost..
18:32:40 <dwcook> Putting the "pointless" in "pointfree" :D
18:33:16 <hunt> ok so lets say i have this list [[a,a1...],[b,b1...],[c,c1...]]
18:33:20 <hunt> and i want to traverse over it
18:33:21 <hunt> in such a way
18:33:28 <hunt> that i can call a function on the first two elements
18:33:33 <hunt> and replace the first element with its result
18:33:39 <k00mi> dwcook: that's totally more readable :P
18:33:40 <hunt> and then call that function on the second two
18:33:47 <hunt> and replace elment 2 with the result
18:33:50 <hunt> inotherwords
18:33:58 <hunt> a scanl with more argumenst
18:34:19 <hunt> is there a good method?
18:34:22 <dwcook> hunt, not quite sure I follow. Example?
18:34:30 <hunt> hmm ok
18:34:32 <dwcook> Giving a type might also help
18:34:33 <hunt> i have [1,2,3,4,5]
18:34:41 <dwcook> (Maybe)
18:35:02 <hunt> i want to say magicFunc (+) [1,2,3,4,5] nad get back [3,5,7,9]
18:35:24 <dwcook> Oh okay, so the list of applying the function between adjacent pairs in the list
18:35:29 <hunt> such that 3 = 1 +2 5 = 2 + 3 etc.
18:35:29 <hunt> yea
18:35:50 <hunt> i could write my own function to do this
18:35:59 <hunt> but im trying to get away from doing that
18:36:10 <dwcook> Frankly you might be better off doing so
18:36:16 <ion> Start with zipping a list with “drop 1”’d version of the list.
18:37:02 <k00mi> let magic f xs = zipWith f xs (tail xs) in magic (+) [1..5]
18:37:06 <k00mi> > let magic f xs = zipWith f xs (tail xs) in magic (+) [1..5]
18:37:07 <lambdabot>  [3,5,7,9]
18:37:22 <dwcook> k00mi, but what if it has no tail? :(
18:37:57 <dwcook> Oh never mind
18:38:05 <k00mi> > let magic f xs = zipWith f xs (drop 1 xs) in magic (+) []
18:38:06 <lambdabot>  []
18:38:10 <k00mi> there you go
18:38:21 <dwcook> No you were fine, since zipWith needn't have evaluated the second argument
18:38:44 <dwcook> I should probably have tried it before complaining :P
18:38:47 <ion> I’d use drop 1 anyway.
18:38:53 <hunt> whsy that ion?
18:39:19 <k00mi> yep, imagine you or someone else changes that code a month later
18:39:22 <hunt> thanks k00mi that makes a lot of sense
18:39:30 <dwcook> In case someone insidiously replaces tail with a strict function</facetious>
18:39:35 <k00mi> you probably won't rember that the tail is fine in this case
18:39:37 <dwcook> Errr, no
18:39:42 <dwcook> Replaces zipWith? Beh
18:40:07 <ion> Partial functions are to be avoided whenever possible.
18:40:55 <k00mi> hunt: tail is bad because it fails for [], while drop 1 works just fine
18:49:30 <carlosgaldino> is `undefined` the haskell's equivalent of `nil`?
18:50:32 <prooftechnique> carlosgaldino: Not really.
18:51:25 <k00mi> nil is a value, undefined is more like a failed computation
18:51:53 <prooftechnique> carlosgaldino: Many types have values that are like nil, though
18:52:19 <prooftechnique> [], Nothing, and things like that are kind of like nil
18:52:51 <carlosgaldino> prooftechnique: I'm aware of that. you can represent something that doesn't have a value but which still is a value
18:53:07 <dwcook> carlosgaldino, undefined basically means "please fail catastrophically"
18:53:18 <carlosgaldino> ok
18:53:20 <dwcook> As opposed to "there was no reasonable other value for this"
18:53:46 <prooftechnique> Or even "Pretend I know what I'm doing, but fail catastrophically if I actually get to you"
18:53:57 <prooftechnique> Though typed holes will hopefully usurp that role
18:53:57 <carlosgaldino> I think that's what I wanted to know. like `nil` in OOP you usually get an error when trying to call a method on it
18:54:26 <k00mi> carlosgaldino: but you can check if a value is nil and then do something else
18:54:28 <dwcook> carlosgaldino, you can guard for nil, but cannot guard for undefined. You just (almost) never want to evaluate it at all
18:54:33 <k00mi> you can't do that with undefined
18:54:40 <k00mi> it blows up once you look at it
18:55:53 <carlosgaldino> you can't get away then?
18:56:29 <dwcook> carlosgaldino, right. If you want a computation to actually possibly return "no useful data", then perhaps what you want is Maybe or something of the sort
18:56:44 <dwcook> For example, a reasonable function for reading an Integer from a string might have this type: String -> Maybe Integer
18:57:00 <carlosgaldino> ok, then I can assume that `undefined` is never or close to never being used, right?
18:57:24 <dwcook> It's often used as a placeholder or in a place where it ought not ever actually be evaluated
18:57:27 <prooftechnique> It's only really useful during development, when you have the types worked out but haven't implemented stuff yet
18:57:42 <prooftechnique> Though I imagine there are some other crazy uses outside that scope
18:58:05 <prooftechnique> :t undefined :: String -> Maybe Integer
18:58:06 <lambdabot> String -> Maybe Integer
18:58:19 <prooftechnique> :t undefined :: Int -> [a] -> a
18:58:20 <lambdabot> Int -> [a] -> a
18:58:38 <dwcook> I've seen a certain typeclass used with undefined to get the size of the representation of that type, when no specific value was needed
18:58:45 <dwcook> I forget what it was called
18:58:55 <RchrdB> carlosgaldino, yeah, pretty much every single use of `undefined` is a bug because it always type-checks but never works.
18:59:07 <dwcook> Aha, Storable's sizeOf
18:59:18 <RchrdB> Using it as a placeholder for "I haven't written this bit yet" is the sanest use of it.
18:59:45 <dwcook> So one might write sizeOf (undefined :: Float), for example, which is safe only because you know sizeOf ignores its parameter
18:59:49 <prooftechnique> I wonder if Hack has something like undefined :D
19:00:23 <Welkin> Hack, the new facebook language?
19:00:28 <prooftechnique> Yeah
19:00:33 <zipper> Uh how do I add `-XFlexibleContexts' to a file?
19:00:45 <RchrdB> dwcook, yes. I remember someone mentioning that, if Storable were re-designed now, it'd be changed from sizeOf :: (Storable a) => a -> Int, to sizeOf :: (Storable a) => w a -> Int.
19:00:47 <prooftechnique> I'm getting a couple of PRs together for HHVM, then I'm gonna play with Hack
19:00:49 <dwcook> zipper, one way is {-# LANGUAGE FlexibleContexts #-}
19:00:52 <dwcook> Before the module header
19:00:56 <k00mi> prooftechnique: well, you can just use any failing computation, anything like error "undefined"
19:01:14 <dwcook> RchrdB, what is w for?
19:01:21 <prooftechnique> Hmm
19:01:24 <k00mi> but that doesn't make as much sense in a strict language
19:01:29 <RchrdB> dwcook, since that wrapper w, with kind (* -> *), is allowed to be absolutely anything, it'd properly *enforce* the fact that sizeOf isn't allowed to read the argument.
19:01:30 <fly2web> (Show a) => Car String String a   <----- i don't know this meaning about '(Show a) => '
19:01:52 <dwcook> RchrdB, oh neat
19:01:58 <RchrdB> dwcook, that w could match List or Maybe or any other type term with kind (* -> *)
19:02:16 <dwcook> fly2web, a must have a Show instance in scope
19:02:16 <prooftechnique> fly2web: It's a type class constraint. `a` must be an instance of the Show type class
19:02:31 <RchrdB> I think it was quicksilver or someone who pointed that out as a way of passing a type parameter in a function parameter but enforcing that it can't be used.
19:02:57 <fly2web> thanks dwcook and prooftechnique
19:03:35 <RchrdB> dwcook, a conceptually simpler thing, I guess, is `data No a = No` :)
19:03:54 <RchrdB> dwcook, or a good example, even. :)
19:03:55 <dwcook> RchrdB, or even without the constructor ;)
19:04:11 <RchrdB> Oh, I forgot you can do that.
19:04:15 <dwcook> data AintNobodyGonnaConstructMe a
19:04:45 <dwcook> I think it's non-Haskell-98 though
19:05:13 <dwcook> Buuut I believe is in Haskell 2010?
19:05:56 <zipper> Ok can I get an equivalent of floor that works on ints?
19:06:00 <zipper> Just plain Ints
19:06:04 <geekosaur> yes, the constructors are optional in h2010
19:06:07 <dwcook> zipper, so, id?
19:07:05 <zipper> dwcook: id :: a -> a but I want (Num a, Integral b) => a -> b
19:07:27 <dwcook> Ah, so you want a floor that can return an Int
19:07:48 <zipper> :t Yes
19:07:49 <dwcook> Or rather that works on non RealFrac Nums
19:07:49 <lambdabot> Not in scope: data constructor `Yes'
19:07:57 <zipper> dwcook: yes
19:08:37 <dwcook> Wait now I'm confused. You actually do want to apply floor to an Int?
19:09:19 <zipper> dwcook: Look at this --> https://gist.github.com/urbanslug/9678091
19:09:51 <zipper> :T truncate
19:09:54 <dwcook> Ah, so what you really want is to get a non Int out of n/2
19:10:00 <dwcook> In that case, fromIntegral n / 2
19:10:55 <dwcook> > floor $ fromIntegral (11 :: Int) / 2
19:10:57 <lambdabot>  5
19:11:04 <k00mi> > 11 `div` 2
19:11:05 <lambdabot>  5
19:11:17 <k00mi> you want integer division
19:12:01 <dwcook> Yeah, integer division gives you an integer and discards any remainder
19:12:10 <dwcook> which is effectively the same as the above
19:12:25 <dwcook> (I think?)
19:12:42 <dwcook> > (floor $ fromIntegral (-11 :: Int) / 2, -11 `div` 2)
19:12:44 <lambdabot>  (-6,-5)
19:12:48 <dwcook> That is different
19:12:49 <k00mi> and having a typeclass constraint for a concrete type is pointless
19:13:42 <dwcook> I suggest considering which one you actually want: the floor of the fractional division, or integer division
19:14:06 <zipper> If I was rich I'd throw this laptop out of the window right now
19:14:11 <monochrom> > (-5) `div` 2
19:14:12 <lambdabot>  -3
19:14:28 <monochrom> > (-5) `quot` 2
19:14:30 <lambdabot>  -2
19:14:31 <dwcook> Or if they could somehow really cheaply produce laptops
19:14:42 <dwcook> (and windows)
19:14:43 <zipper> dwcook: It still fails.
19:14:58 <monochrom> make a paper model of the laptop. throw the paper model. :)
19:15:01 <dwcook> zipper, what's the new code? What's the error message say?
19:15:13 <dwcook> And a paper model of your house!
19:15:23 <dwcook> I used to make little paper houses for my Pokémon plushes when I was little
19:16:25 <k00mi> zipper: also see divMod/quotRem
19:16:55 <dwcook> Now now, let's not bludgeon the poor person
19:17:00 <dwcook> </facetious>
19:17:12 <monochrom> after all, Chinese tradition worships ancestors by burning paper models of things that we think the ancestors could use in the afterworld. for example paper money. and then paper model houses and cars. and then paper model dolls (supposed to be housekeepers.) and lately paper model computers too, you wouldn't believe how the afterworld is technologically advanced
19:18:04 <zipper> dwcook: I hae updaed https://gist.github.com/urbanslug/9678091
19:18:08 <zipper> *have
19:18:21 <dwcook> monochrom, I'm guessing the paper computers don't have to be actually functional in the physical realm, which implies the computers somehow… take new form in the spirit realm? Is it based on what the burner thinks it should be? Based on what the recipient thinks? Neither of the above? Mysteries!
19:18:49 <geekosaur> well, a paper doll isn't a very good housekeeper
19:18:59 <zipper> I want to punch the type system in the face because we can't understand each other
19:19:01 <monochrom> I don't know. the paper money aren't functional in the physical realm either. I mean, even monopoly money has higher value here...
19:19:11 <dwcook> not fromIntegral (n/2), (fromIntegral n)/2. Plus, there's another spot you missed
19:19:14 <dwcook> zipper, ^
19:19:49 <dwcook> @type (/)
19:19:50 <lambdabot> Fractional a => a -> a -> a
19:19:59 <dwcook> > (1 :: Int) / 2
19:19:59 <pavonia> Is "ghci +RTS -M128M" the correct way to limit ghci's overall memory usage to 128MB?
19:20:00 <lambdabot>  No instance for (GHC.Real.Fractional GHC.Types.Int)
19:20:01 <lambdabot>    arising from a use of `GHC.Real./'
19:20:01 <lambdabot>  Possible fix:
19:20:01 <lambdabot>    add an instance declaration for (GHC.Real.Fractional GHC.Types.Int)
19:20:04 <dwcook> Notice how (/) cannot take Int
19:20:09 <dwcook> So you must convert it to something it can take first
19:20:28 <jle`> you mean haskell doesn't convert my strings into floats
19:20:35 <jle`> automatically?
19:20:45 <monochrom> yes pavonia
19:20:45 <jle`> what an unintelligent compiler!
19:20:54 <dwcook> jle`, yeah, Haskell should automatically insert calls to coerce everywhere
19:21:06 <jle`> i hope ghc takes pull requests!
19:21:20 <pavonia> monochrom: It doesn't respect that limitation :(
19:21:48 <monochrom> it has worked for me before
19:21:55 <jle`> coerce might not be powerful enough, i think we need unsafeCoerce
19:21:58 <jle`> whenever there is a type error
19:22:01 <jle`> in order to resolve it
19:22:03 <pavonia> it's at 170 MB right now
19:22:23 <jle`> the type inference algorithm should know exactly where to put the minimal amount of unsafeCoerce to get the types to work
19:22:24 <derekv> I have this story that I tell myself while I work on java code.  That all the troubles I have as a developer would go away if I was using Haskel, cause those guys really have it together.  But in the story, I won't switch because I don't do things the easy way.  I'm a hard and determined worker.
19:23:00 <jle`> and a strong independent black woman?
19:23:10 <dwcook> derekv, hard work? Sounds like the compiler's (and by proxy compiler writers') job!
19:23:20 <derekv> jle`: working on it.
19:23:38 <jle`> i heard a half-decent convincing argument for using java vs haskell at work
19:23:48 <monochrom> I think you can simply the whole story to just: I'm a hard and determined worker.
19:23:55 <monochrom> s/simply/simplify/
19:24:00 <jle`> it was on reddit a couple months ago
19:24:03 <jle`> i think
19:24:04 <dwcook> jle`, oh yay, let's hear it
19:24:11 <jle`> in java, you don't have to worry about finding the most clever solution
19:24:17 <jle`> there's always a solution that just works
19:24:26 <jle`> and you pound out so many lines of code
19:24:34 <jle`> but it's just what you are expected to do
19:24:37 <jle`> nobody is going to say you wrote too much
19:24:41 <jle`> nobody is going to say you wrote too little
19:24:45 <monochrom> I think some java users look for the most clever solutions too
19:24:51 <jle`> it's safe, easy, and everything makes sense
19:25:00 <jle`> they do, but they won't get in trouble for not writing the most clever solution
19:25:01 <monochrom> it really comes down to whom you work with rather than what language
19:25:20 <jmcarthur> i disagree with that argument. just because people make a lot of "clever" code in haskell doesn't mean haskell requires you to be clever.
19:25:31 <jle`> in haskell, becuase your code can be so concise and clear and beautiful, people will begin nagging
19:25:33 <dwcook> "Clever" is a dirty word to me
19:25:40 <jle`> and you will always feel
19:25:44 <jle`> 'i can probably make this better'
19:25:56 <jle`> with java, you can't ever, so you won't ever worry
19:25:58 <jle`> management will never worry
19:25:59 <aspidites> how do you pass flags to dependencies in a cabal file
19:26:03 <jmcarthur> i for one write plenty of "clever" code in most languages, haskell or not, for better or for worse...
19:26:04 <monochrom> ok, I have not heard of a haskell place where people do get into trouble for not writing the most clever solution. so maybe you have opposing evidence?
19:26:18 <aspidites> or more importantly, where is the manpage/helpfile that explains all possible cabal file fields?
19:26:25 <monochrom> like, I'm calling you bluff, you're making things up.
19:26:35 <jmcarthur> usually when i learn a new language, i end up hitting unusual corner cases of the language in the first day before i've even learned how to use it for "normal" code
19:26:38 <jle`> it was an argument i read on reddit :'(
19:26:57 <k00mi> "java can't be as pretty as haskell" isn't exactly a good agrument :P
19:26:58 <monochrom> well you believe it to be true.
19:27:01 <jle`> the idea was that java is safe, no stress, no thinking, just pound out thousands of lines
19:27:07 <jle`> and it just works
19:27:10 <jle`> to management
19:27:21 <jmcarthur> yeah java doesn't "just work" ever
19:27:32 <dwcook> I often find myself thinking less in Haskell. "Okay I'll just filter that" versus "Did I get the variables right in my for loop?"
19:27:36 <jmcarthur> especially if you just pounded out thousands of lines
19:27:38 <jle`> but so many java shops?
19:27:45 <k00mi> that was the goal of java but I don't think it is even good at achieving that
19:27:50 <k00mi> something like python is much better
19:28:08 <jmcarthur> to me the main benefit of java is the tools
19:28:16 <derekv> java just works great. try to write an equals and hashCode for ORM managed object imlementing an interface shared with other objects
19:28:22 <dwcook> (That said, for loops are lame even in languages that have them. Iteration functions ftw)
19:29:01 <zipper> dwcook: Well one issue is that I don't know what you are talking about.
19:29:24 <jle`> i like my assembly loops :/
19:29:26 <zipper> dwcook: This Fractional type
19:29:35 <k00mi> zipper: the first problem with your code is that there is no instance for Fractional Int
19:29:41 <rabipelais> hello, how can I have polymorphism on the result type of a function using GADTs? What I mean, I have `data Type a where A :: Type Int, B :: Type String`, and a function `fun :: Type a`, but I get "couldn't match type 'a' with 'Int'"
19:29:42 <k00mi> or RealFrac
19:29:49 <zipper> dwcook: Tried div instead of (/)
19:29:51 <dwcook> zipper, where you previously had (floor $ n/2), I suggest you write (floor $ fromIntegral n/2) instead
19:29:52 <zipper> fail
19:30:00 <dwcook> zipper, failed how? How did you use it?
19:30:11 <k00mi> zipper: because the constaint itself is not solveable
19:30:21 <zipper> dwcook: It typechecks but fails in execution
19:30:34 <dwcook> zipper, what's the error message say?
19:30:45 <zipper> k00mi: There totally is Fractional Int
19:30:46 <dwcook> rabipelais, that doesn't look like a function.
19:31:12 <dwcook> rabipelais, but the short of it is that a gets instantiated to whatever the constructor's type would be
19:31:29 <rabipelais> Well actually it's using parsec and has type `Parser (Type a)`
19:31:50 <dwcook> rabipelais, I'd suggest showing an actual (minimal) test case
19:31:54 <k00mi> zipper: no
19:32:32 <rabipelais> do I post the code here, or use a pastebin?
19:32:40 <geekosaur> @paste
19:32:41 <lambdabot> Haskell pastebin: http://lpaste.net/
19:32:50 <dwcook> rabipelais, so, say you had a function that accepted a Type a and you passed it an A. Then a ~ Int
19:33:00 <geekosaur> never paste into IRC, either the server will kick you or everyone including you will be misersbl;e while the buffer drains
19:33:10 <aspidites> djnvm, think i found it
19:33:11 <geekosaur> *miserable
19:33:18 <aspidites> http://www.haskell.org/cabal/users-guide/developing-packages.html#editing-the-.cabal-file
19:33:21 <ezrios> anyone familiar with Graphics.Rendering.Chart?
19:33:26 <ezrios> what is the meaning of this type? _plot_lines_values :: [[(x, y)]]
19:33:42 <dwcook> ezrios, it's a list of list of pairs of anything and anything
19:33:43 <ezrios> is each sublist a list of points to be joined together by lines?
19:33:51 <dwcook> ezrios, (which doesn't make much sense really)
19:33:55 <ezrios> dwcook: right, I understand that
19:33:57 <zipper> dwcook: k00mi here https://gist.github.com/urbanslug/9678091
19:34:00 <ezrios> how does this translate into a 2D plot
19:34:12 <dwcook> ¯\_(o_0)_/¯
19:34:19 <ezrios> dwcook: my reaction exactly ._.
19:34:35 <kadoban> ezrios: seems like a decent guess...there's no documentation that says?
19:34:39 <k00mi> > (3 :: Int) / 2 -- zipper
19:34:40 <lambdabot>  No instance for (GHC.Real.Fractional GHC.Types.Int)
19:34:41 <lambdabot>    arising from a use of `GHC.Real./'
19:34:41 <lambdabot>  Possible fix:
19:34:41 <lambdabot>    add an instance declaration for (GHC.Real.Fractional GHC.Types.Int)
19:34:43 <dwcook> zipper, line 11, at (floor $ n/2)
19:35:07 <dwcook> zipper, ah, but the error itself is about the typeclass constraint
19:35:19 <dwcook> For one thing, you don't need RealFrac for Int. For another, concrete typeclass constraints are unnecessary
19:35:43 <zipper> dwcook: I added those because they came up as possible fixes
19:36:16 <pavonia> ezrios: I think each sublist defines one line by a series of point
19:36:18 <dwcook> zipper, you can usually ignore messages that suggest new instances, but that's also not what they mean
19:36:34 <zipper> dwcook: It was failing to typecheck
19:36:43 <dwcook> zipper, they mean to actually write a typeclass instance for those types, e.g., instance RealFrac Int where … But in this case doing so is silly.
19:36:54 <pavonia> ezrios: or rather one set of connected lines
19:36:56 <dwcook> zipper, yes, but not because you lacked those constraints. Get rid of them and let's see the real errors.
19:38:23 <ezrios> pavonia: hm, that is what I think as well
19:38:41 <dwcook> zipper, those things are called typeclass constraints, not (typeclass) instance declarations, by the way.
19:38:42 <ezrios> the documentation is a bit sparse
19:39:41 <zipper> dwcook: https://gist.github.com/urbanslug/9678091
19:40:00 <zipper> Where it all started http://videlalvaro.github.io/2014/03/the-power-algorithm.html
19:40:08 <monochrom> @type pwoers
19:40:11 <lambdabot> Not in scope: `pwoers'
19:40:13 <monochrom> @type powers
19:40:14 <lambdabot> Not in scope: `powers'
19:40:14 <zipper> I regret clicking on that link.
19:40:23 <monochrom> what is "powers"? what is its type?
19:40:35 <zipper> monochrom: You don't want to know :(
19:40:45 <monochrom> eh? Monoid? why? why on Earth?
19:40:49 <zipper> monochrom: For your own good don't click.
19:41:00 <zipper> monochrom: You're dead
19:41:27 <dwcook> Don't link. Don't even link. Link and you're dead.
19:42:02 <rabipelais> ok, here is a minimal test case: http://lpaste.net/101532
19:42:06 <monochrom> and why the hell, after half an hour of being told to just use "div n 2", is it still stuck with bloody hell "floor $ fromIntegral n/2"?!
19:42:18 <rabipelais> the error I get is "Couldn't match type `Int' with `[Char]'"
19:42:18 <zipper> I am trying to write that in haskell apparently Donald Knuth did it and it can work as a monoid but it's like impossible for me to do it
19:42:29 <dwcook> monochrom, well, it is better than floor $ n/2
19:42:42 <zipper> monochrom: div didn't help much
19:42:43 <hunt> hey guys
19:42:43 <dwcook> rabipelais, at which line?
19:42:54 <hunt> i just spent about an hour trying to bash out these 5 lines of code
19:43:00 <hunt> anyone feel like looking it over
19:43:00 <monochrom> to be fair, Monoid makes sense. but what the hell is with "Fractional Int"?
19:43:04 <hunt> and telling me how shitty it is?
19:43:07 <rabipelais> the last one, `parseAll = ...`
19:43:08 <ezrios> hunt: paste
19:43:16 <zipper> monochrom: I told you not to.
19:43:27 <monochrom> I mean, maybe tomorrow I could assert "Ord (a -> a)" and it would just work?
19:43:40 <dwcook> rabipelais, oh that's easy, you're trying to throw different types of parsers into the same list
19:43:44 <hunt> http://lpaste.net/101533
19:43:47 <hunt> ezrios ^
19:43:49 <zipper> monochrom: I don't know man. Now I wish Knuth wrote the Monoid using algo for me.
19:44:21 <zipper> *monoid using
19:44:26 <monochrom> I'm sure Knuth wrote something that makes sense, but the translator, oh God the translator needs surgery
19:44:47 <rabipelais> dwcook, ok, but even if a substitute `a` instead of `Int` or `String` in the declarations of the other functions, I get a type error
19:44:49 <dwcook> rabipelais, you might consider making them your Type type, though I'm not convinced that type is designed adequately. But I don't know what you're after
19:44:50 * hackagebot snap-testing 0.4.1.0 - A library for BDD-style testing with the Snap Web Framework  http://hackage.haskell.org/package/snap-testing-0.4.1.0 (DanielPatterson)
19:45:03 <dwcook> rabipelais, that is, wrap the Int or String inside your Type
19:45:17 <dwcook> rabipelais, zoom out: What is the larger goal?
19:45:37 <zipper> monochrom: Man have you seen my gist? Any ideas? https://gist.github.com/urbanslug/9678091
19:45:56 <monochrom> well I have been commenting on that very gist all along
19:46:14 <rabipelais> dwcook, Im playing arround trying to make a compiler, I figured if I used GADTs I could get some kind of type checking "for free" while parsing and building the AST
19:46:17 <zipper> monochrom: You have? I didn't notice. You must've failed to use mu nick.
19:46:18 <monochrom> every thing including "needs surgery" is about the author of that gist, yes
19:46:44 <rabipelais> dwcook, what do you mean wrapping them inside the Type?
19:46:46 <zipper> monochrom: I am the author come at me ;)
19:47:33 <dwcook> rabipelais, I'm not convinced a GADT is your answer here
19:48:12 <dwcook> rabipelais, you cannot use choice with parsers of different types, and the way you're using the GADT here, parsers you want to alternate between will have different types
19:48:12 <rabipelais> dwcook, yeah, me neither, the version without GADT worked, but I wanted to try it out
19:48:48 <dwcook> rabipelais, my suggestion: go back to the way you were doing it before
19:49:06 <rabipelais> dwcook, and there is no way to return a polymorphic `Parser (Type a)` on the other functions?
19:49:26 <dwcook> There is a way but it's no better than the non-GADT solution
19:49:33 <rabipelais> dwcook, yeah, thanks :( it was worth a try. Good thing there is version control :P
19:49:40 <rabipelais> dwcook, how?
19:49:59 <dwcook> Well, you can wrap it in another type. But then you only end up adding more indirection!
19:50:30 <rabipelais> hmmmm I think I better leave it simple and plain
19:50:41 <dwcook> Sounds good
19:50:57 <rabipelais> dwcook, thanks a lot for the help
19:51:01 <dwcook> No problem
19:51:44 <thaicares> could gitit the wiki engine help me learn Haskell? I have nothing but web dev experience thus far...
19:52:38 <thaicares> rather would gitit be easy enough to develop on and challenging enough to teach me? Assuming I have almost no skill when it comes to any programming
19:53:02 <zipper> How can one run a function on the contents of a monoid. Imaginary broken code --> (+4) <*> Product 3
19:53:06 <ezrios> thaicares: pick up a good book
19:53:24 <ezrios> thaicares: if you have used javascript you may have already had some experience manipulating first class functions
19:54:00 <dwcook> zipper, is it also a Functor instance? Then fmap (+4)
19:54:18 <dwcook> Looks like in this case no
19:54:25 <dwcook> So then unwrap it and then apply the function
19:54:51 * hackagebot snap-testing 0.4.1.1 - A library for BDD-style testing with the Snap Web Framework  http://hackage.haskell.org/package/snap-testing-0.4.1.1 (DanielPatterson)
19:54:59 <dwcook> zipper, wait, there's a Num instance for Product.
19:55:05 <zipper> dwcook: I don't think functor is a superclass of monoid. or does that now matter?
19:55:05 <dwcook> > Product 3 + 3
19:55:07 <lambdabot>  No instance for (GHC.Show.Show a0)
19:55:07 <lambdabot>    arising from a use of `M597906184950463695217863.show_M5979061849504636952...
19:55:07 <lambdabot>  The type variable `a0' is ambiguous
19:55:07 <lambdabot>  Possible fix: add a type signature that fixes these type variable(s)
19:55:07 <lambdabot>  Note: there are several potential instances:
19:55:13 <dwcook> > getProduct $ Product 3 + 3
19:55:14 <lambdabot>  No instance for (GHC.Show.Show a0)
19:55:14 <lambdabot>    arising from a use of `M364071654815416948517872.show_M3640716548154169485...
19:55:14 <lambdabot>  The type variable `a0' is ambiguous
19:55:15 <lambdabot>  Possible fix: add a type signature that fixes these type variable(s)
19:55:17 <lambdabot>  Note: there are several potential instances:
19:55:24 <dwcook> > getProduct $ Product 3 + (3 :: Int)
19:55:25 <lambdabot>  Couldn't match expected type `Data.Monoid.Product a0'
19:55:26 <lambdabot>              with actual type `GHC.Types.Int'
19:55:28 <dwcook> -_-
19:55:38 <dwcook> > getProduct $ Product (3 :: Int) + 3
19:55:39 <zipper> dwcook: Monoids suck
19:55:39 <lambdabot>  No instance for (GHC.Num.Num (Data.Monoid.Product GHC.Types.Int))
19:55:40 <lambdabot>    arising from a use of `GHC.Num.+'
19:55:40 <lambdabot>  Possible fix:
19:55:40 <lambdabot>    add an instance declaration for
19:55:40 <lambdabot>    (GHC.Num.Num (Data.Monoid.Product GHC.Types.Int))
19:55:45 <dwcook> I give up
19:55:45 <zipper> I hate monoids
19:55:51 <zipper> Monoids are crap
19:55:58 <dwcook> Oh I'm silly, there is no Num instance
19:56:03 <zipper> I don't even know why they exist
19:56:03 <dwcook> zipper, just unwrap the product with getProduct
19:56:27 <zipper> dwcook: but I don't know which monoid it will be
19:56:38 <dwcook> zipper, so pick one if you must
19:57:04 <thaicares> ezrios I am running through tutorials thanks to a number of Haskell books but I want to start doing some development as well
19:57:05 <zipper> dwcook: I am trying to rewrite the powers from that blog using haskell and monoids as the args
19:57:21 <monochrom> zipper: http://lpaste.net/101534
19:57:25 <thaicares> I'm thinking gitit might be useful and was just wondering how good of a teaching tool it can be?
19:57:54 <dwcook> zipper, I'm not sure where Monoid enters into it
19:57:54 <Platz> went to a scala meetup tonight on attoparsec.. scalaz is confusing; wasn't used to seeing args reversed on things like applicative
19:59:03 <ezrios> thaicares: consider reading Real World haskell
19:59:09 <ezrios> s/h/H
19:59:35 <ezrios> I find it a bit lacking in theory (LYAH has a much better overview of common typeclasses), but makes up for that in practicality
19:59:42 <thaicares> ezrios ok I'll look at it :D
19:59:54 <zipper> monochrom: For some reason it is taking me forever to load that page
19:59:56 <ezrios> the fourth chapter is actually a JSON parser
20:00:10 <monochrom> yes, lpaste took forever for me a minute ago too
20:00:24 <ezrios> well, I lied, actually just a serializer
20:00:27 <ezrios> and it's chapter 5
20:00:35 <thaicares> ezrios the forth chapter of real worl is a json parser?
20:00:39 <ezrios> thaicares: yes
20:00:41 <thaicares> OK
20:00:52 <monochrom> keep trying, you'll get your ration :)
20:01:09 <thaicares> I think gitit works with atom but maybe there are transferable skills there :)
20:01:11 <zipper> monochrom: and hoogle totally failed on me a while ago
20:01:15 <zipper> Weird
20:01:37 <zipper> but I have crappy speeds
20:01:37 <thaicares> I'm actually hoping to use gitit, a wiki engine, to maintain a personal site :)
20:02:14 <ezrios> @hoogle ([[)
20:02:22 <lambdabot> Parse error:
20:02:22 <lambdabot>   ([[)
20:02:22 <lambdabot>     ^
20:02:30 <ezrios> the examples for this library suck
20:03:04 <huh> @hoogle a -> b -> a
20:03:05 <lambdabot> Prelude const :: a -> b -> a
20:03:06 <lambdabot> Data.Function const :: a -> b -> a
20:03:06 <lambdabot> Prelude seq :: a -> b -> b
20:11:08 <jowens> I'm trying to use ByteStrings. I import them with "import qualified Data.ByteString". Should I be using "import qualified Data.ByteString as B" and/or putting the functions that I specifically import in parens? What I'm trying to do is a) use a ByteString type without having to call it B.ByteString and b) trying to use calls like "length" without having to call B.length instead.
20:16:37 <dwcook> jowens, in that case, yeah, specify what to import and hide any conflicts from the Prelude
20:16:46 <zipper> monochrom: Uh could you gist that. I am totally unable to load that lpaste page.
20:17:00 <dwcook> jowens, but if you need to use any two bindings that conflict, then your best option is likely to do the prefixingf
20:17:03 <dwcook> prefixing*
20:17:19 <jowens> dwcook: so that means every time I use a function on ByteStrings, I need to use the B. prefix on it?
20:17:39 <dwcook> jowens, in the latter case I suggested, yes. But if that's not the case, then no
20:18:35 <jowens> my understanding is the right thing to do is either i) use "qualified" and don't specify specific functions (and then have to use B. everywhere) or ii) don't use "qualified" and specify the specific functions
20:18:50 <dwcook> jowens, yes, I agree.
20:18:56 <monochrom> I don't like to use gist.
20:19:26 <jowens> dwcook: ok, given my use scenario, you have any advice about which might be better for me? I'm a n00b.
20:19:29 <erisco> are there html templating libraries which provide data binding? preferably one suitable to tie into reactive-banana
20:20:16 <dwcook> jowens, personally, I dislike the prefixing. So any and all bindings I need I import explicitly, unless it's infeasible to do so. For example, say I need to use both Map and Set in the same module, both of which have fromList. Then, I will import those qualified as M or S respectively.
20:20:24 <Welkin> reactive-banana? haha
20:20:30 <Welkin> I have heard of elm
20:20:38 <Welkin> wonder how they came up with that name
20:20:42 <jowens> dwcook: sensible. And if I really need one of those, I use "Prelude.foo"?
20:20:56 <Welkin> the developer was eating a banana?
20:21:11 <dwcook> jowens, your judgment is as good as mine there. I've never had to do that.
20:21:22 <zipper> monochrom: Never mind
20:21:32 <jowens> dwcook: Appreciate your perspective! Thanks mucho.
20:21:34 <dwcook> i.e., use something from the Prelude that shares a name with something else I needed
20:38:42 <zipper> monochrom: PM
21:09:42 <no-n> > unlines $ lines "hello\nworld"
21:09:43 <lambdabot>  "hello\nworld\n"
21:09:56 * hackagebot foldl 1.0.3 - Composable, streaming, and efficient left folds  http://hackage.haskell.org/package/foldl-1.0.3 (GabrielGonzalez)
21:10:15 <no-n> > intercalate "\n" $ lines "hello\nworld"
21:10:16 <lambdabot>  "hello\nworld"
21:11:18 <Welkin> is lambdabot just an interface to ghci?
21:11:40 <roboguy_> Welkin: it can do some things that ghci can't
21:11:51 <no-n> it only does pure stuff
21:12:18 <roboguy_> @pl \f g -> fmap f . fmap g
21:12:19 <lambdabot> (. fmap) . (.) . fmap
21:12:39 <no-n> that rarely works out :p
21:12:42 <no-n> but sometimes it's great
21:13:29 <no-n> @pl \xs -> length xs = length (nub xs)
21:13:30 <lambdabot> (line 1, column 19):
21:13:30 <lambdabot> unexpected " "
21:13:30 <lambdabot> expecting operator
21:13:39 <no-n> @pl \xs -> length xs == length (nub xs)
21:13:39 <lambdabot> liftM2 (==) length (length . nub)
21:14:05 <roboguy_> well, it could be worse: (`fmap` fmap) `fmap` fmap `fmap` fmap
21:14:12 <no-n> ;-;
21:14:50 <mikeplus64> :t flip fmap `fmap` fmap
21:14:52 <lambdabot> Functor f => (a -> b1) -> (f b1 -> b) -> f a -> b
21:14:57 * hackagebot errors 1.4.6 - Simplified error-handling  http://hackage.haskell.org/package/errors-1.4.6 (GabrielGonzalez)
21:15:09 <mikeplus64> :t (`fmap` fmap) `fmap` fmap `fmap` fmap
21:15:10 <lambdabot> Functor f => (b -> b1) -> (a -> b) -> f a -> f b1
21:15:22 <mikeplus64> :t flip fmap `fmap` fmap `fmap` fmap
21:15:23 <lambdabot> (Functor f, Functor f1) => (a -> b1) -> (f (f1 b1) -> b) -> f (f1 a) -> b
21:15:55 <no-n> lol
21:16:50 <Welkin> haskell.org is really slow
21:21:00 <roboguy_> Welkin: it doesn't seem too slow to me
21:21:48 <dmj`> does ghc-pkg latest actually work for anyone
21:22:04 <dmj`> ghc-pkg latest scotty ==> ghc-pkg: cannot find package scotty
21:23:29 <roboguy_> dmj`: maybe the package needs to be installed?
21:24:01 <roboguy_> that's the pattern I seem to be seeing
21:25:47 <pyon> dmj`: it seems that "ghc-pkg latest" reports the latest *INSTALLED* version of a package.
21:27:27 <pyon> dmj`: Here, "ghc-pkg latest bytestring" returned "bytestring-0.10.0.2", but "ghc-pkg list | highlight-versions | grep bytestring" returned "bytestring-0.10.0.2 (0.10.4.0)".
21:29:50 <pavonia> What is the version number in parentheses?
21:32:16 <hunt> so guys
21:32:30 <hunt> im working on generating a series of vertices
21:32:39 <hunt> corresponding to a sphere
21:32:44 <hunt> and its proving to be extremely difficult
21:32:57 <hunt> particularly to get latitude AND longitude lines
21:33:16 <hunt> anyone have any experience here?
21:34:15 <anna_> i guess yes ...
21:36:28 <roboguy_> hunt: in a cartesian coordinate system/
21:36:39 <hunt> yea
21:38:20 <roboguy_> I'd probably look up how to convert from a spherical coordinate system to a cartesian coordinate system. in a spherical coordinate system, a sphere is just "r = <radius>"
21:43:45 <enthropy> hunt: have you figured out the 2-D case first?
21:44:45 <ArchPy> Is Haskell fun?
21:45:05 <roboguy_> ArchPy: definitely
21:47:27 <roboguy_> I get to do things I can't do in any other language I know
21:49:27 <ArchPy> roboguy_: Would you elaborate on that point?
21:51:29 <hunt> enthropy: im working my way through this situation, but this code is not coming out too nicely, or at least it doesnt feel nice
21:51:46 <hunt> hopefully there will be people interested in looking it over when ive got it working
21:52:56 <enthropy> > [ (sin th, cos th) | th <- [0, 0.5 .. 2*pi] ]
21:52:57 <lambdabot>  [(0.0,1.0),(0.479425538604203,0.8775825618903728),(0.8414709848078965,0.5403...
21:53:17 <roboguy_> ArchPy: well, for example free theorems and parametricity tells me that I can safely make certain assumptions about polymorphic functions. type classes (like Functor and Applicative) all me to generalize concepts and reduce code duplication in a nice way.
21:53:46 <roboguy_> algebraic data types along with some type classes (like Applicative and Monad) make it easy to make domain specific languages
21:54:14 <enthropy> somehow there is no automated way to make quickcheck tests that take advantage of parametricity
21:55:52 <roboguy_> hunt: in the 2D case, cos corresponds exactly to the x component and sin corresponds exactly to the y component of a unit circle at a given angle
21:55:55 <kadoban> uhmm.  okay, I have a [b -> b], how do I mash them all together into one (b -> b) ?
21:56:05 <kadoban> i feel like i should know this, but it's not working out for me
21:56:59 <jle`> kadoban: how would they be sequenced?
21:57:07 <prooftechnique> fold with ($)?
21:57:08 <jle`> ydo you want to perform them one after another?
21:57:17 <jle`> you can fold with (.) i think
21:57:27 <kadoban> jle`: yes, performed one after the other...
21:57:28 <roboguy_> ArchPy: also, I can use types to direct my programming in a way that I've never seen in any other language
21:57:38 <jle`> > foldr (.) id [(+1),(*2)] $ 5
21:57:40 <lambdabot>  11
21:57:41 <roboguy_> (other than Agda and some other dependently typed languages like that)
21:57:44 <jle`> > foldl (.) id [(+1),(*2)] $ 5
21:57:45 <lambdabot>  11
21:58:03 <jle`> > foldl (flip (.)) id [(+1),(*2)] $ 5
21:58:04 <lambdabot>  12
21:58:15 <jle`> silly category laws
21:58:48 <no-n> > foldr1 (.) (replicate 10000 id) $ 5
21:58:49 <lambdabot>  5
21:58:55 <kadoban> ohh, thanks...i missed 'id'...i wonder what the hell my function was doing...it actually compiled, but the type made no goddamn sense to me
21:59:18 <jle`> you can use foldl1/foldr2
21:59:22 <jle`> foldr1
21:59:24 <kadoban> i'm not entirely sure which fold i want...hmm
21:59:24 <roboguy_> > (`appEndo` 5) $ foldMap Endo [(+1),(*2)]
21:59:25 <lambdabot>  11
21:59:35 <jle`> technically it shouldn't matter because of category laws
22:00:12 <jle`> (f.(g.(h.i))) == (f.(g.(h.i)))
22:00:18 <jle`> um
22:00:22 <jle`> i definitetly wrot ethe same thing twice
22:00:25 <jle`> but you get my point
22:00:43 <kadoban> ahh, right
22:00:59 <jle`> you need id if you foldr/foldl because you need a mempty/starting function
22:01:10 <jle`> but if you use foldl1 you can leave off id sacrificing totality
22:01:26 <jle`> > foldl1 (.) [(+1),(*2)] $ 5
22:01:27 <lambdabot>  11
22:01:54 <kadoban> yeah, it makes sense once you said it, i think...let's see if my code "works" now
22:02:12 <kadoban> probably going to throw my code somewhere and ask about it...i have a strong feeling i'm doing several things really wrong
22:02:23 <hunt> kadoban me ttoo
22:02:44 <roboguy_> I kind of like foldMap Endo since the associativity explicit
22:02:48 <jle`> kadoban: as roboguy_ mentions, Endo is a newtype wrapper that supplies a monoid instance for (a -> a)
22:02:51 <roboguy_> *since it makes
22:03:06 <jle`> so you can use mempty/<>/mappend/fold and stuff like that
22:03:19 <jle`> and foldMap
22:03:24 <jle`> you just need to unwrap it at the end though
22:03:34 <kadoban> hmm, i'll look that up
22:03:44 <jle`> you're familiar with monoid wrappers, right?
22:03:58 <jle`> like Sum, Product, Any, First...
22:04:11 <kadoban> i think i get what a monoid is? no, i'm not all that familiar with any of those
22:04:28 <jle`> ah
22:05:05 <jle`> you know that a monoid is something with an associative (a -> a -> a) operator mappend/<>, and an identity mempty
22:05:27 <jle`> the integers, say, form a monoid under addition/+, and with 0 as its mempty/identity
22:05:32 <kadoban> right, got that part so far
22:05:39 <jle`> but they also form a monoid under multiplication/*, with 1 as its mempty/identity
22:05:46 <kadoban> but that's about as far as my monoid knowledge runs, hehe
22:05:47 <jle`> so which one do we pick to make the Int monoid as?
22:05:58 <jle`> we can have it both ways
22:06:08 <jle`> if we write a newtype wrapper
22:06:12 <kadoban> ahh
22:06:13 <jle`> and define a monoid instance for that newtype
22:06:20 <jle`> @src Sum
22:06:20 <lambdabot> Source not found.
22:06:39 <jle`> Sum is a newtype wrapper ove ra number, where <>/mappend is (+) and mempty is (Sum 0)
22:06:51 <jle`> Product is a newtype wrapper over a number where <>/mappend is (*), mempty is 1
22:07:02 <jle`> > mconcat $ map Sum [1,2,3,4,5]
22:07:03 <lambdabot>  Sum {getSum = 15}
22:07:09 <kadoban> ahh, okay. with you so far
22:07:26 <jle`> Bools also form a monoid
22:07:37 <jle`> over &&, with True as its identity
22:07:43 <jle`> and over ||, with False as its identity
22:07:47 <jle`> so we have newtype wrappers for Bools too
22:07:53 <jle`> Any, and All
22:08:08 <jle`> Any is for || and False, All is for && and True
22:08:16 <kadoban> seems reasonable enough
22:08:18 <jle`> > mconcat $ map Any [True,False,False,True]
22:08:19 <lambdabot>  Any {getAny = True}
22:08:33 <jle`> so you might have noticed that functions (a -> a) form a monoid under composition/(.)
22:09:02 <kadoban> only when you mentioned it, but it does make sense, heh
22:09:11 <jle`> functions have other possible monoid instances
22:09:25 <jle`> and there actually is a default/unwrapped monoid instance
22:09:32 <jle`> but it isn't the (.)/id instance
22:09:48 <kadoban> huh, really? trying to think what other instances they could have...hmm
22:09:48 <jle`> and so to give it a (.)/id instance, we wrap it in a newtype wrapper
22:09:51 <jle`> Endo
22:10:39 <jle`> the default instance is actually for Monoid b => a -> b
22:10:44 <jle`> if that helps you think about what it is
22:10:46 <no-n> what does safe mean in hsakell
22:10:57 <kadoban> ohh, i think i see now, at least to my original thing, how Endo would help
22:10:58 <kadoban> hmm
22:11:21 <roboguy_> > (\x -> [1..x]) <> (\y -> [10..10+y]) $ 5
22:11:22 <lambdabot>  [1,2,3,4,5,10,11,12,13,14,15]
22:11:28 <jle`> so map Endo [f,g,h,j,k] turns your list into a monoid over composition, and fold will mconcat everything with (<>)
22:11:29 <roboguy_> ^ there's another one
22:11:48 <jle`> and <> for Endo is (.)
22:11:55 <jle`> and mempty for Endo is id
22:12:00 <roboguy_> no-n: in what context? {-# LANGUAGE Safe #-}?
22:12:06 <no-n> idk :p
22:12:24 <roboguy_> no-n: well, why do you ask?
22:12:28 <no-n> I've seen "unsafe"
22:12:37 <no-n> just curious i guess
22:12:49 <kadoban> no-n: you mean things like unsafePerformIO or whatever?
22:12:53 <no-n> yeah
22:13:13 <roboguy_> no-n: ahh. by convention, a function that begins with the word unsafe "breaks the contract" implied by it's type signature
22:13:34 <no-n> is that about purity?
22:13:36 <roboguy_> functions don't have side effects in Haskell, but "unsafe" functions might
22:13:38 <jle`> i usually take it to mean that you throw away all the nice guaruntees you have with equational reasoning and stuff
22:13:55 <no-n> ok
22:13:57 <jle`> basically that you can't reason about it with normal haskell reasoning tools
22:14:10 <no-n> so, impure functions?
22:14:30 <jle`> there's unsafeCoerce
22:14:37 <jle`> which is pure, i think
22:14:43 <no-n> :S
22:14:57 <jle`> but i think unsafe in that context means that it might break everything if you use it and don't know what you are doing
22:15:18 <jle`> and you throw away compiler guaruntees etc.
22:15:34 <jle`> also non-total/partial functions are often called unsafe
22:15:48 <jle`> but that might be unsafe in a different manner
22:16:12 <jle`> for example, (!!) or fromJust
22:16:28 <jle`> but i think partial is a better word
22:16:38 <jle`> no need to be ambiguous/vague
22:18:21 <no-n> hmm, ok
22:19:07 <jle`> unsafe in that manner also means that you are throwing away compiler guaruntees and the compiler can't help you make sure your program doesn't crash
22:19:32 <jle`> maybe unsafe just means that you are breaking compiler contracts
22:19:36 <ThatOtherPerson> In Haskell's layout rules, under what conditions would "L (t : ts) (m : ms) = }  :  (L (t : ts) ms) if m∕ = 0 and parse-error(t)" be triggered?
22:20:07 <roboguy_> also, sometimes ghc's optimizations can break things if those guarantees don't hold so you have to be careful with things like unsafePerformIO (as the names imply)
22:20:25 <jle`> ah yeah that's important
22:20:39 <ThatOtherPerson> Is it just in cases like "(x, case s of r -> i r where i x = x)", where "(x, case s of r -> i r where {i x = x)}" is an error, so "(x, case s of r -> i r where {i x = x})" is done instead?
22:21:15 <jle`> ghc takes advantage of all that equational reasoning stuff to optimize, so if you throw away the ability to do equational reasoning, it's going to most likely ruin stuff
22:21:49 <roboguy_> ThatOtherPerson: I really don't understand the question...
22:22:12 <ThatOtherPerson> roboguy_: Well, I'm reading through the layout rules here: http://www.haskell.org/onlinereport/haskell2010/haskellch10.html#TBL-104
22:22:25 <ThatOtherPerson> I've implemented all the rules except for that one
22:29:15 <kadoban> would anyone be willing to look at my code? http://lpaste.net/101537  I have a short comment at the top, basically it "works", but it feels really bad and I'm not sure how to improve what I'm doing to make it much more extendable
22:29:39 <kadoban> It's like a basic assembly-language script runner, where the machine the assembly works on is stack-based
22:30:43 <kadoban> I want to eventually turn it into kind a debugger for the script language, which basically would just mean logging exactly what each step does and what the stack looks like at that point, but i'm unsure how to do that.
22:30:51 <nisstyre> kadoban: well nested case expressions are usually not a great idea...
22:31:11 <kadoban> nisstyre: yeah...but how do i avoid that? i'm sure there's a way, but...
22:31:14 <nisstyre> kadoban: might have a look here http://hackage.haskell.org/package/monad-logger-0.2.0/docs/Control-Monad-Logger.html
22:31:22 <nisstyre> kadoban: you can factor it out into a separate function for the inner case
22:31:29 <nisstyre> or use the left function
22:31:33 <nisstyre> er, either function
22:31:34 <jle`> also liftM isn't too trendy these days
22:31:42 <jle`> fmap is where it's at, if you know what monad you are using
22:31:49 <jle`> ie, not Monad m =>
22:32:11 <kadoban> hmm, i'll look that up. fmap is like...the same thing but in Applicative or something?
22:32:28 <jle`> for functors
22:32:30 <nisstyre> :t fmap
22:32:31 <lambdabot> Functor f => (a -> b) -> f a -> f b
22:32:38 <jle`> it's like map, but for all functors
22:32:46 <jle`> :t map
22:32:47 <lambdabot> (a -> b) -> [a] -> [b]
22:32:48 <kadoban> nisstyre: hmm, fair enough. i kind of figured there was a much better way to write that though, or change the rest so it'd be easy to write...maybe not?
22:32:51 <kadoban> ahh
22:33:02 <jle`> i like (a -> b) -> (f a -> f b) better
22:33:15 <jle`> it turns a normal function into a function that works inside containers
22:33:36 <jle`> hm also line 53
22:33:38 <jle`> that's an easy guard
22:33:44 <nisstyre> :t fmap undefined (undefined :: [a])
22:33:45 <lambdabot> [b]
22:34:16 <hunt> do you guys see a simplification im missing? i feellike this line could be shorter: 		connectArcs arcs = let arc = map rows arcs in (concat $ map traceMatrix arcs) ++ (concat $ zipWith (zipWith (\a b -> Matrix.fromList . transpose' $ [a,b])) arc (drop 1 arc))
22:34:24 <hunt> 		traceMatrix m = let mr = rows m in zipWith (\a b -> Matrix.fromList . Matrix.transpose' $ [a,b]) mr (drop 1 mr)
22:35:08 <kadoban> jle`: hmm, really? i'm not sure how to use a guard for that...or..hmmm
22:35:16 <jle`> you can use guards in case statements
22:35:26 <jle`> oh that's not even a case statement, that's a lambda
22:35:33 <jle`> you can use guards for lambdas right? (??)
22:35:48 <kadoban> yeah, it's a really gross construct because i couldn't find a way to write that that wasn't awful :/
22:35:51 <nisstyre> I find most people don't know you can use guards in let expressions either
22:36:00 <jle`> > let f = \x | True -> 0 | otherwise -> 1 in f undefined
22:36:01 <lambdabot>  <hint>:1:12: parse error on input `|'
22:36:05 <jle`> aw
22:36:05 <roboguy_> kadoban: I might write a function "toB :: Bool -> B" then you can rewrite 53-55 as push (toBool (a == b)) s
22:36:24 <roboguy_> I mean, push (toB (a == b)) s
22:36:26 <jle`> i guess i was wrong
22:36:27 <nisstyre> > let f | a > 2 = 0 | otherwise = 1 in f 2
22:36:28 <lambdabot>  Ambiguous occurrence `a'
22:36:28 <lambdabot>  It could refer to either `L.a', defined at L.hs:156:1
22:36:28 <lambdabot>                        or `Debug.SimpleReflect.Vars.a',
22:36:28 <lambdabot>                           imported from `Debug.SimpleReflect' at L.hs:110:1-26
22:36:28 <lambdabot>                           (and originally defined in `simple-reflect-0.3.1:De...
22:36:34 <nisstyre> ah lol
22:36:42 <jle`> haha
22:36:48 <nisstyre> > let f a | a > 2 = 0 | otherwise = 1 in f 2
22:36:50 <lambdabot>  1
22:36:52 <kadoban> ahh, the toB thing is a good idea
22:37:02 <nisstyre> wow that error message is hilarious
22:37:09 <jle`> wondering if you could do it for lambdas
22:37:21 <nisstyre> > L.a
22:37:23 <lambdabot>  1
22:37:29 <jle`> haha
22:37:34 <jle`> who did that
22:37:35 <jle`> >.>
22:37:39 <nisstyre> no idea
22:37:40 <jle`> someone fess up
22:37:51 <jle`> @let b = undefined
22:37:52 <roboguy_> @pl \((a, b), s) -> push (toBool (a == b)) s
22:37:52 <lambdabot>  .L.hs:158:1:
22:37:52 <lambdabot>      Multiple declarations of `b'
22:37:52 <lambdabot>      Declared at: .L.hs:157:2
22:37:52 <lambdabot>                   .L.hs:158:1
22:37:52 <lambdabot> uncurry (uncurry (((push . toBool) .) . (==)))
22:38:03 <hunt> guys lets say i have an array of matrices
22:38:06 <hunt> and sequentially
22:38:18 <hunt> i want to connect the corresponding rows of each matrix
22:38:20 <roboguy_> I wouldn't suggest that pl version though, haha
22:38:25 <hunt> is there a clean way to do that
22:38:26 <kadoban> haha, ya :/
22:38:27 <jle`> haha
22:38:34 <jle`> hunt: connect?
22:38:41 <jle`> kadoban: what is your code trying to do?
22:39:00 <jle`> i guess there is a paragraph at the top
22:39:04 <hunt> jle` create a new matrix with the corresponding points, zipWith maketrix
22:39:05 <roboguy_> hunt: what is a matrix and what do you mean connect?
22:39:16 <kadoban> jle`: ya, i hope the para at the top explains it vaguely well
22:39:20 <jle`> kadoban: can you put up some sample output?
22:39:29 <hunt> lets say a matrix is a 2d list roboguy_, connecting is generating a new matrix with those two rows
22:39:52 <hunt> here let me give a sample
22:39:56 <jle`> hunt: can you give example inputs/outputs
22:39:58 <jle`> ah yeah
22:40:02 <jle`> that's the stuff.
22:40:04 <roboguy_> hunt: so you want something like Vector Matrix -> Matrix?
22:40:10 <kadoban> jle`: like what scripts should result in what you mean?
22:40:17 <jle`> kadoban: yes
22:40:21 <hunt> this is a matrix m1 [[1,2,3],[4,5,6]]
22:40:28 <hunt> so if we have [m1,m2,m3]
22:40:35 <hunt> i want to create a new situation
22:40:42 <jle`> hm
22:40:50 <jle`> oh, you are totally carrying the entire state of the stack
22:40:52 <jle`> in an Either
22:40:57 <jle`> and at every step
22:41:06 <jle`> modifying it based on the OpCode
22:41:12 <jle`> or turning it into a Left
22:41:15 <jle`> if it errors
22:41:18 <kadoban> yeah, hehe
22:41:20 <jle`> interesting
22:41:23 <hunt> with [m1m2',m2m3'...] such that m1m2' is [[1,2,3],m2 row 1]
22:41:40 <hunt> ([1,2,3] is m1 row 1)
22:42:16 <jle`> kadoban: wouild you ever consider generalizing to have every OpCode both affect the stack *and* output a result?
22:42:27 <jle`> oh, you do
22:42:29 <hunt> i have a solution but i wish it were neater
22:42:29 <jle`> for pop
22:42:49 <jle`> so pop outputs (B, Stack)
22:42:50 <hunt> this is what im using atm: (concat $ zipWith (zipWith (\a b -> Matrix.fromList . transpose' $ [a,b])) arc (drop 1 arc))
22:42:58 <hunt> fromList takes a list and gives me a matrix type
22:43:02 <jle`> kadoban: so your pop function
22:43:07 <jle`> is Stack -> (B, Stack)
22:43:09 <jle`> right?
22:43:12 <kadoban> right
22:43:13 <hunt> transpose' is the same as Data.List transpose
22:43:16 <jle`> okay
22:43:22 <jle`> let's imagine sequencing two pops in a row
22:43:30 <hunt> arc is my source list of matrices
22:43:39 <jle`> actually let's generalize it to any Stack -> (B, Stack) function
22:43:51 <jle`> and let's call your push a B -> (Stack -> ((), Stack))
22:43:53 <jle`> follow?
22:44:18 <jle`> basically every state-affecting function takes in Stack and returns (result, Stack)
22:44:24 <hcaulfield57> If you normally wanted to use listen (or censor) within the Writer monad, would you probably have to pass the Writer monad your concerned with as an argument? Doing something like (a,w) <- listen (tell mempty) seems a little awkard.
22:44:24 <kadoban> oh, i think so. so it pushes something to the stack, and yields a value that doesn't matter?
22:44:26 <jle`> push is now a function that takes a B and returns a state-affecting function
22:44:29 <jle`> kadoban: yes, exactly
22:44:44 <jle`> the state-affecting function that push returns is the funcion that pushes B into the stack
22:44:45 <jle`> okay
22:45:03 <jle`> now...so give (Stack -> (res, Stack)) a name, because it's a mouthful
22:45:14 <jle`> type StackFunction res = Stack -> (res, Stack)
22:45:26 <jle`> pop :: StackFunction B
22:45:31 <jle`> push :: B -> StackFunction ()
22:45:48 <kadoban> okay, thanks for that last part, that makes sense so far
22:45:58 <jle`> (we're going to temporarily ignore error handling)
22:46:00 <jle`> now, write a funciton
22:46:15 <jle`> andThen :: StackFunction a -> StackFunction b -> StackFunction b
22:46:31 <jle`> where f1 `andThen` f2 = perform f1, and then perform f2
22:46:54 <jle`> and at the end, return a new StackFunction that takes an input Stack and runs it through *both* f1 and f2, one after the other
22:47:29 <jle`> it feeds the modified stack that f1 returns as the input of f2
22:47:37 <jle`> (it ignores the reuslt of f1, sadly)
22:47:59 <kadoban> okay, that makes sense so far, i think i can write that...i'm pretty sure i've seen it written before, haha
22:48:12 <kadoban> or at least something similar to that, heh
22:48:30 <jle`> let me know if you run into problems
22:48:34 <jle`> it should be a two-liner
22:48:57 <jle`> one if want, but that's a little cramped
22:50:09 <roboguy_> hunt: what about map transpose . transpose?
22:50:12 <jle`> hcaulfield57: how else would you have it?
22:50:20 <roboguy_> >  map transpose $ transpose [[[1,2,3],[4,5,6]], [[7,8,9],[10,11,12]]]
22:50:22 <lambdabot>  [[[1,7],[2,8],[3,9]],[[4,10],[5,11],[6,12]]]
22:50:35 <hcaulfield57> jle`: I have no idea, I just didn't know if there was something better someone knew of
22:50:43 <jle`> hcaulfield57: it might look a little less sily if you consider (a,w) <- listen $ do ...;...;...
22:50:55 <jle`> (or maybe not)
22:51:05 <hcaulfield57> jle`: Yea, that's less awkward
22:51:16 <hunt> roboguy_ very interesting i was just looking at doing that
22:51:17 <jle`> it's like a writer in a writer
22:51:31 <hunt> iroboguy_ i didnt realize it boiled down to transposes until like 10 minutes ago
22:51:42 <hcaulfield57> jle`: I always forget how easy it is to do things like that with monads.
22:52:24 <Platz> jle`: would operational work here, or do you tend to avoid that lib?
22:52:45 <jle`> Platz: ?
22:53:25 <Platz> Control.Monad.Operational
22:53:39 <Platz> i.e. http://apfelmus.nfshost.com/articles/operational-monad.html
22:53:39 <jle`> what about it?
22:53:42 <kadoban> jle`: is it just: andThen f g s = let (_, s') = f s in g s'   ?
22:53:56 <jle`> kadoban: yeah :)
22:53:59 <kadoban> yay, haha
22:54:06 <jle`> okay
22:54:25 <hcaulfield57> jle`: Thanks!
22:54:30 <jle`> so now you can sequence a bunch of StackFunctions in a row, ignoring their outputs, and only outputting the output at the end
22:54:40 <jle`> what about if you did not want to ignore?
22:54:46 <jle`> what if you wanted to use the output of a pop later?
22:55:01 <kadoban> yeah...that seems tougher
22:55:06 <jle`> consider andThenWith :: StackFunction a -> (a -> StackFunction b) -> StackFunction b
22:55:14 <jle`> do you understand that type signature?
22:55:36 <jle`> compare with andThen :: StackFunction a -> StackFunction b -> StackFunction b
22:56:41 <kadoban> jle`: yes, i think that makes sense.  the middle part uses the 'a' result, kinda?
22:56:50 <jle`> Platz: ah you are taking about kadoban's thing?
22:57:18 <jle`> kadoban: yeah, instead of the second argument being a StackFunction, it's actually a function that returns a different StackFunction depending on the result of the first one
22:57:28 <jle`> so now you can 'react' to the first one's result
22:57:34 <Platz> yeah but really I'm just rambling, feel free to ignore
22:57:42 <jle`> Platz: no problem, the block post is interesting
22:57:47 <kadoban> jle`: okay, that seems to make good sense
22:57:59 <jle`> kadoban: it actually isn't too hard to write it
22:58:04 <jle`> once you already wrote andThen
22:58:12 <jle`> you just need to change like three characters
22:58:22 <jle`> *blog post
22:58:32 <jle`> and then note that andThen f g = andThenWith f (const g)
22:58:38 <kadoban> okay, let me try that
22:58:51 <jle`> andThen is just a little conceptually easier, so i usually open with that first
22:59:36 <hunt> iroboguy_ i didnt realize it boiled down to transposes until like 10 minutes ago
22:59:37 <Platz> jle`: I don't have good intuition for haskell yet.  But it seems there's a bunch of ways to do interpreters in haskell
22:59:38 <hunt> woops
23:00:08 <jle`> Platz: yeah, there are :)
23:00:28 <jle`> i'm using this specific example because he had already written a function Stack -> (B, Stack), and it seemed like he wanted to sequence them
23:00:30 <kadoban> jle`: okay, got that.  changed _ to x, and then passed it into g as well, seems like that makes totaly sense
23:00:38 <jle`> so this is a direct extension of that idea
23:00:43 <jle`> kadoban: nice
23:00:45 <jle`> okay, now
23:00:49 <jle`> stare very hard at the type signature of andThen
23:01:01 <jle`> we're going to do some magic :)
23:01:12 <kadoban> haha, oh boy :)
23:01:12 <jle`> andThen :: StackFunction a -> StackFunction b -> StackFunction b
23:01:15 <jle`> :t (>>)
23:01:16 <lambdabot> Monad m => m a -> m b -> m b
23:01:25 <Platz> such as the F-algebra way.. initial algebras, phantom types, Fix.. will be a long time before I get a good sense for that stuff
23:01:30 <jle`> andThenWith :: StackFunction a -> (a -> StackFunction b) -> StackFunction b
23:01:34 <jle`> :t (>>=)
23:01:34 <lambdabot> Monad m => m a -> (a -> m b) -> m b
23:01:45 <jle`> you just implemented a monad :)
23:01:51 <jle`> well, you need to implement return first
23:01:54 <jle`> but yeah
23:02:05 <kadoban> huzzah, lol.  okay i thought they looked pretty familiar, but...my monad knowledge is pretty crap
23:02:10 <jle`> don't worry
23:02:12 <kadoban> obviously XD
23:02:30 <jle`> 'monad knowledge' is a thing of questionable importance
23:02:45 <jle`> knowing that it's a monad doesn't actually give you *too* much, immediately and practically
23:02:47 <jle`> but
23:02:50 <jle`> implementing it as a monad
23:02:54 <kadoban> well, my ability to use the pattern is pretty limited i suppose i should say
23:02:55 <jle`> gives you access to all the neat monad combinators
23:02:57 <jle`> :)
23:03:03 <jle`> in Control.Monad
23:03:18 <jle`> okay, so first thing now is that you actually can't define typeclass instances on type aliases
23:03:25 <jle`> so you have to do what we discussed earlier
23:03:39 <jle`> which is write a newtype wrapper
23:03:48 <kadoban> ah, right so i'd have to make them newtypes at least and just add a wrap and unwrap a bit? okay that's fair enough
23:04:04 <jle`> newtype StackFunction res = StackFunction (Stack -> (res, Stack))
23:04:06 <jle`> yeah
23:04:16 <jle`> and then write the monad instance
23:04:21 <jle`> i'll let you figure out what return is
23:04:24 <jle`> :t return
23:04:25 <lambdabot> Monad m => a -> m a
23:04:29 <jle`> and then
23:04:38 <jle`> now, to do all of your functions one after another
23:04:43 <jle`> ignoring all the results
23:04:48 <jle`> :t sequence
23:04:49 <lambdabot> Monad m => [m a] -> m [a]
23:05:18 <kadoban> oh, huh...wow
23:05:23 <jle`> sequence will execute all of your StackFunctions one after the other, with each one using the modified state outputted by the last, and return a list of the result of each one
23:05:35 <jle`> there's also sequence_
23:05:38 <jle`> :t sequence_
23:05:39 <lambdabot> Monad m => [m a] -> m ()
23:05:52 <jle`> which will ignore the results of each action, but you get the final modified state at the end
23:06:14 <jle`> sequence [] = return []
23:06:24 <jle`> sequence (f:fs) = f `andThen` sequence fs
23:06:44 <kadoban> oic, nice
23:06:48 <jle`> i should be careful with my words
23:07:04 <jle`> sequence will take a list of a bunch of StackFunctions and return a new 'giant' StackFunction that returns a list of their results
23:07:13 <jle`> but remember that StackFunction is just Stack -> (a,Stack)
23:07:21 <jle`> so sequence will return a new Stack -> ([a], Stack)
23:07:34 <jle`> sequence_ will return a new Stack -> ((), Stack)
23:07:47 <jle`> so in sequence_, you need to still "run" it with a Stack...but you get the final modified stack at the end
23:08:07 <kadoban> oh, okay, yeah that makes total sense
23:08:38 <kadoban> wow, thanks so much for explaining that all, i think that made a bunch of stuff click, i hope, haha
23:08:46 <jle`> so um
23:08:52 <jle`> all of this is actually already implemented for you
23:09:02 <jle`> in the transformers package
23:09:05 <jle`> your andThen, at least
23:09:20 <jle`> http://hackage.haskell.org/package/transformers-0.3.0.0/docs/Control-Monad-Trans-State.html
23:09:32 <jle`> although instead of StackFunction, you have State Stack
23:09:35 <jle`> but
23:09:48 <jle`> i recommend, as a learning experience, to just use your custom state monad
23:10:22 <kadoban> nice...yeah it seems like i could learn from doing that
23:10:53 <jle`> notice that we sort of lost the ability to throw errors
23:10:58 <kadoban> so if i want to get back the behavior of error handling...i, hmm...i have to like layer another monad on top of this, right?
23:11:00 <kadoban> ah, yeah
23:11:16 <jle`> yeah, OR
23:11:20 <jle`> you can actually implement your own :)
23:11:33 <jle`> you don't need to layer any monads, you can have one giant super monad that does handling *and* state
23:11:35 <jle`> consider
23:12:14 <jle`> type StackErrorFunction res = Stack -> (Either String res, Stack)
23:12:32 <jle`> and this works just the same as your previous StackFunction, actually
23:12:48 <kadoban> hmm
23:12:52 <jle`> only you need to do some more careful plumbing for your andThen/andThenWith
23:13:36 <kadoban> shouldn't it end up something like Stack -> Either String (res, Stack) after the = sign? or am i confused?
23:13:49 <jle`> oh
23:13:51 <jle`> yeah you're right
23:13:54 <jle`> haha
23:14:02 <jle`> sorry
23:14:14 <kadoban> i think i see why you wrote it that way though, so that it would follow the pattern, pretty much?
23:14:23 <jle`> yeah, but your way is the correct way :P
23:14:27 <kadoban> hehe
23:14:34 <jle`> try writing andThen/andThenWith with that
23:14:39 <jle`> hm.
23:14:41 <jle`> er
23:14:43 <jle`> wait
23:14:52 <jle`> try it with both
23:14:55 <jle`> and see which one is more useful :)
23:15:15 <jle`> they are both correct but they have different semantics when you eventually run them
23:15:47 <kadoban> haha, sounds like a decent learning experience.  yeah the first...i'm not sure it makes "physical" sense in my domain, but writing it seems easier
23:16:06 <kadoban> oh actually yeah it would, right just the semantics are different
23:17:04 <jle`> for the first one, when you eventually run the whole thing, you get the value of the stack at the time of the crash
23:17:23 <jle`> for the second one, if you crash, the stack is lost forever.
23:17:26 <jle`> :'(
23:17:39 <kadoban> hehe, right
23:18:14 <jle`> but yes try, and i *think* this is exactly the monad that could replace all of your plumbing
23:19:24 <jle`> actually you don't even need Monad for this becuase you never actually need to use (>>=) if all you ever do is sequence a list
23:19:38 <jle`> you can just use (>>), which is (*>)
23:19:43 <jle`> so you actually only need Applicative
23:19:50 <jle`> :)
23:20:04 <kadoban> hehe
23:20:09 <jle`> if none of your instructions ever depend on the result of the last instruction (your instruction list is assembled before it is ran) then you can use Applicative
23:20:26 <jle`> and in this case it looks like it is
23:20:50 <kadoban> yeah, you can only look at the stack in my language, which is a bit nice
23:21:15 <jle`> if your instruction set is known in advance, yeah, you can only define (<*>) and pure
23:21:19 <jle`> :t (<*>)
23:21:20 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
23:21:21 <jle`> :t pure
23:21:22 <lambdabot> Applicative f => a -> f a
23:21:34 <jle`> and you can use sequenceA from Data.Traversable
23:21:58 <jle`> and i'm not sure, but it might be more efficient?
23:22:31 <kadoban> will any of these choices affect my ability to extend this after?  the real goal here is to either be able to do just what i'm doing here, or end up with a "log" of what every instruction does, so like the stack at every point or something like that
23:23:03 <jle`> right now you already can log if you use sequence and have every instruction output what you want logged
23:23:14 <jle`> but that is a little hacky yeah
23:23:33 <kadoban> oh, right yeah that would work in a pinch, i see
23:23:41 <jle`> what you can also do is now define a new super monad with both state, error, and 'logging' ability
23:23:45 <jle`> (res, Stack, log)
23:23:51 <jle`> (res, Stack, [Stack])
23:23:58 <jle`> and at every step, add the current stack to your log
23:24:06 <jle`> but adding all this functionality gets a bit cludgy
23:24:30 <jle`> and at "three monads-worth", you are probably better off turning this into an excersize on learning monad transformers :)
23:25:28 <kadoban> haha, i see :) thanks very much again, i think my brain might melt if i try to tackle all of that at once so maybe i'll stop bugging you here and try to implement the parts above XD
23:26:14 <jle`> no problem. there is actually a bit of perverse joy in making your own monads
23:26:22 <jle`> and once you make them they start seeming less scary
23:26:59 <jle`> just remember that any monads you make have to adhere to the monad laws
23:27:47 <kadoban> ah right
23:28:15 <dmj`> kadoban: monad transformers aint' so bad
23:28:20 <dmj`> ain't
23:29:13 <kadoban> i remember reading about them in RWH, and they seemed to kinda make sense, but i have a feeling it'll take a bit of work to actually figure them out in practice
23:29:54 <dmj`> > flip execStateT 4 $ { modify (+1) }
23:29:56 <lambdabot>  <hint>:1:21: parse error on input `{'
23:30:05 <dmj`> > flip execStateT 4 $ do { modify (+1) }
23:30:06 <lambdabot>  No instance for (GHC.Show.Show (m0 b0))
23:30:06 <lambdabot>    arising from a use of `M532798038796335284018518.show_M5327980387963352840...
23:30:06 <lambdabot>  The type variables `b0', `m0' are ambiguous
23:30:06 <lambdabot>  Possible fix: add a type signature that fixes these type variable(s)
23:30:06 <lambdabot>  Note: there are several potential instances:
23:30:08 <jle`> they aren't that scary, but there's also nothing wrong with one step at a time :)
23:30:24 <jle`> dmj`: you have to say what monad it's transforming i guess :/
23:30:54 <dmj`> > flip execState 4 $ modify (+1)
23:30:56 <lambdabot>  5
23:32:02 <dmj`> > flip runReader 4 $ do { b <- ask; return b }
23:32:03 <lambdabot>  4
23:32:16 <haasn> I would be interested in a good set of bindings to libotr or another OTR implementation that make it easy for me to integrate it in an application without much knowledge of cryptography. Has anybody heard of plans or more interest in such of a thing?
23:34:15 <f-a> overheard in another channel:
23:34:20 <f-a>          FSi the more i code javascript
23:34:25 <f-a>          FSi the more i like strong-static typing :/
23:35:18 <MP2E> FSi sounds like they need Haskell in their life
23:36:05 <f-a> indeed, indeed
23:36:33 <dmj`> f-a: have you looked at typescript?
23:37:44 <f-a> I will relay the suggestion dmj` , thanks
23:38:07 <MP2E> huh, never heard of typescript before
23:38:10 <jle`> i had a lot of fun writing a raytracer in typescript
23:38:15 <jle`> microsft does pretty nice things
23:38:33 <dmj`> esp. microsoft research :P
23:39:33 <erisco> two problem with type script after using it to implement haskell-like things
23:39:55 <erisco> 1) no higher order types. 2) weak type inference
23:42:40 <jle`> the fun i had with it was incidentally before i learned haskell, so that explains a lot
23:49:19 <dmj`> if you run ghc-pkg check on osx, do you get a ton of "Warning: haddock-html:... Warning: haddock-interfaces:" messages?
