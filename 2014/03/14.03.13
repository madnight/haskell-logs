00:02:06 <Redz> @hoogle eps
00:02:06 <lambdabot> package cabal-progdeps
00:02:07 <lambdabot> package cabalrpmdeps
00:02:07 <lambdabot> package containers-deepseq
00:02:15 <Redz> hmm. :/
00:10:43 * hackagebot smtp-mail 0.1.4.5 - Simple email sending via SMTP  http://hackage.haskell.org/package/smtp-mail-0.1.4.5 (JasonHickner)
00:10:43 * hackagebot hen 0.1.3 - Haskell bindings to Xen hypervisor interface  http://hackage.haskell.org/package/hen-0.1.3 (FedorGogolev)
00:30:40 * hackagebot linear 1.9.0.1 - Linear Algebra  http://hackage.haskell.org/package/linear-1.9.0.1 (EdwardKmett)
00:40:47 <tdammers> hmm, is there a driver-agnostic way of getting the last inserted row ID with HDBC?
00:43:13 <davidfetter> tdammers, is this so you can use it in a new insert, or...?
00:46:00 <tdammers> davidfetter: not really, no. Standard CRUD abstraction really; I want to insert a row, let the database assign a row ID, and read that ID back for future reference
00:46:26 <davidfetter> tdammers, some DBs have RETURNING
00:46:39 <tdammers> some DBs, yes. that is kind of the problem
00:46:48 <tdammers> I was hoping HDBC had an abstraction for this
00:47:09 <tdammers> AFAIK some DBs have nonstandard syntax to return the last inserted rowid, others expose it through their libraries
00:48:13 <davidfetter> might i humbly suggest that you restrict your DBs to those that have RETURNING
00:50:04 <tdammers> you might, but I won't
00:50:23 <davidfetter> best of luck, then :)
00:50:45 <tdammers> I could drop mysql, but I really want sqlite support
00:51:09 <tdammers> and postgres, obviously
00:51:56 <tdammers> well, I'll be writing a little SQL syntax abstraction thing anyway, might as well include the rowid thing
00:52:15 <davidfetter> <-- postgres contributor
00:52:59 <tdammers> :D
00:53:09 <tdammers> postgres is my go-to db for anything nontrivial
00:53:31 <davidfetter> we're here for anyone who wants top quality :)
00:53:47 <tdammers> oh, believe me, I am so done with mysql and shit like that
00:53:57 <tdammers> excuse my french, but that's what it is
00:54:15 <fly2web> functions are curried <----- what mean? i don't know the mean of 'curried'?
00:54:57 <tdammers> fly2web: curried means that instead of taking multiple parameters, a function takes one parameter and returns another function which takes the rest of the parameters
00:55:28 <fly2web> thanks tdammers
00:55:30 * davidfetter wonders whether there's some relation to tim currie
00:55:38 <tdammers> e.g. instead of f(x,y) you have f'(x), which returns a function g such that f'(x)(y) == f(x, y)
00:56:18 <fly2web> i understand it perfectly thanks tdammers
00:56:24 <tdammers> fly2web: cool
00:56:41 <tdammers> fly2web: was typing too fast without looking
00:57:21 <fly2web>  you have f'(x), which returns a function g  <----- what is g?
00:57:26 <fly2web> tdammers:
00:57:51 <tdammers> a function?
00:58:02 <milfjord> g = \y -> f(x, y)
00:58:15 <tdammers> g = f'(x)
00:58:24 <tdammers> so g(y) == f(x, y)
00:58:36 <tdammers> == f'(x)(y)
00:58:38 <fly2web> you mean is that f'(x) return function that takes y?
00:58:43 <tdammers> yes
00:58:48 <fly2web> ok thanks
00:58:58 <no-n> a -> a -> a is a -> (a -> a)
00:59:17 <tdammers> part of the beauty of Haskell is that it's actually easier to write fully-curried functions than uncurried ones
01:00:14 <fly2web> tdammers: if i use haskell in the real coding, i need to many exercise?
01:01:36 <Cale> fly2web: It can take quite a bit of practice before you get to the point where you're really comfortable doing real-world work with Haskell, but some people seem to have success jumping straight in.
01:01:46 <Cale> (Hopefully I'm not misinterpreting your question :)
01:02:17 <fly2web> ok i see. Cale
01:02:38 <Cale> fly2web: When I learned Haskell back around 2001 or so, it took me about 2 months before I felt like I could really use it to do useful stuff, and about a year to be totally comfortable.
01:03:10 <fly2web> ok thanks
01:03:25 <Cale> fly2web: But I was in university at the time, so I had lots of other stuff to work on, and there weren't as many good resources as there are now.
01:04:13 <fly2web> haskell is powful now?
01:04:21 <shiona> Cale: wow. I've been learning haskell for 2-3 years and best I can do is some simple tools to help me in my work
01:04:47 <shiona> and I've been slacking my way through uni
01:04:59 <tdammers> fly2web: haskell is very powerful
01:05:12 <fly2web> ok i see.
01:05:29 <tdammers> fly2web: the thing is, unlike the more 'pragmatic' languages, you spend a lot of time up front, designing your types and really thinking through the design and abstractions
01:05:34 <tdammers> fly2web: but it pays off
01:05:55 <fly2web> ok i see
01:06:01 <tdammers> fly2web: there is the half-serious saying that once a haskell program compiles without errors, it is also bug-free
01:06:19 <jle`> what are the more common ways to deadlock/race while using mvars?
01:06:34 <fly2web> ok
01:07:40 <Cale> shiona: At around the end of my first year, I got hired for a few months to help with a research project that involved a special-purpose compiler for a signal processing language written in Haskell. I ended up doing a pipeline scheduler and register allocator which cemented things fairly well for me (and we compiled some code for computing sine-cosine pairs to such good code that it took ~2.6 clocks/float, where (by un
01:07:40 <Cale> fair comparison) GNU libm takes ~200 clocks/float :)
01:10:53 <shiona> Cale: nice, I wish we had some real research
01:14:35 <johnw> jle`: blocking on takeMVar, while the thread that was supposed to put gets an exception and dies without you knowing it
01:14:50 <johnw> that should always result in an exception from the take
01:14:52 <jle`> is it mostly exceptions then that make things tricky?
01:15:40 <jle`> if i just use read and modifying with pure functions, and i can guaruntee that they won't error, would things be fine?
01:15:52 <johnw> if you always use just modifyMVar, you cannot go wrong :)
01:16:04 <johnw> also, only use a single MVar :)
01:16:48 <jle`> ah okay :)
01:17:14 <johnw> the more MVars, threads, and exceptions you run into, the worse your life will get
01:17:35 <johnw> at that point, you pretty much need STM to stay sane
01:19:18 <jle`> just one MVar for me
01:19:44 <jle`> basically a queue that multiple threads can pull and push from
01:20:04 <jle`> but not quite a naked queue
01:20:10 <jle`> it's Map k Queue
01:20:21 <jle`> so i need to be able to add new queues when a new key shows up
01:25:25 <adas> inside a monad transformer if i am doing IO .. how do i make the IO execute?
01:26:20 <jle`> adas: hm?
01:26:22 <johnw> liftIO
01:26:23 <adas> nevermind.. runMaybeT
01:26:34 <adas> sory for the question. i must have confused you all
01:26:40 <jle`> technically that just makes an IO a
01:26:55 <jle`> runMaybeT :: MaybeT IO a -> IO (Maybe a), i think
01:26:58 <johnw> :t liftIO
01:26:59 <lambdabot> MonadIO m => IO a -> m a
01:27:10 <jle`> and then you can do whatever you want with the IO (Maybe a)
01:27:24 <jle`> for example...throwing it into main
01:27:31 <jle`> as a part of your main computation
01:27:43 <jle`> just doing runMaybeT won't execute any IO
01:27:46 <adas> i was in the MaybeT monad and within it I had a few expressions in the IO monad.. i didn't know how to execute the IO
01:27:51 <johnw> liftIO
01:28:03 <jle`> runMaybeT won't execute IO, it'll give you an IO (Maybe a)
01:28:06 <adas> but liftIO is for when the outer monad is IO
01:28:21 <johnw> oh, you're using MaybeT over Identity or ST?
01:28:30 <adas> MaybeT outer
01:28:32 <jle`> adas: liftIO is for when IO is in the stack at all
01:28:32 <adas> IO innter
01:28:36 <johnw> then liftIO
01:28:42 <jle`> but IO is always at the bottom/innermost
01:28:44 <jle`> so yeah.
01:28:49 <jle`> liftIO does not care about the structure of the stack
01:29:01 <adas> the type of my functoin is 'MaybeT IO ()'
01:29:11 <adas> so maybe is outer and IO is inner
01:29:21 <jle`> adas: runMaybeT :: MaybeT IO () -> IO (Maybe ())
01:29:36 <adas> jle`: yup thats what i tried. it worked. thanks
01:29:40 <jle`> so you can use liftIO inside your MaybeT to add IO actions to it
01:29:44 <johnw> runMaybeT is not what you want
01:29:49 <jle`> but remember that runMaybeT doesn't acctually execute any IO!
01:30:36 <adas> hmm. i think i got output only cos i was running it inside ghci which wraps expressions within the IO monad
01:30:51 <jle`> well if you give an IO object to ghci
01:30:53 <jle`> it'll execute it
01:30:59 <jle`> sow hat you did was use runMaybeT to get an IO (Maybe ())
01:31:09 <jle`> that process is pure
01:31:12 <jle`> and does not execute anything
01:31:16 <jle`> and tehn you gave that IO (Maybe ()) to ghci
01:31:22 <jle`> which executs any IO a it is given
01:31:29 <jle`> so it executes the IO object that runMaybeT created
01:31:40 <adas> usually what is the convention while using transformers? IO is outermost monad?
01:31:52 <jle`> adas: there is no IOT, so...it's always the innermost
01:32:27 <lieven_> I've always wondered. Are there any particular difficulties for an implementation to provide an IOT?
01:32:27 <jle`> but the 'convention' is that you use MonadIO m => m, instead of explicitly stating your actual stack, until as late as possible
01:32:52 <fly2web> what mean binary function ?
01:33:01 <johnw> IO is one possible innermost monad
01:33:01 <jle`> fly2web: a function that has two inputs
01:33:10 <fly2web> oh jle` thanks
01:33:12 <jle`> yea,h i mean that if IO is there, it's the innermost
01:33:20 <jle`> Identity is another common innermost
01:33:26 <johnw> and ST and STM
01:33:42 <jle`> lieven_: imagine IOT [] a?  it would involve running multiple universes :)
01:34:08 <shiona> jle`: I hope we get that as an extension in the future
01:34:18 <jle`> 7.10 i think
01:34:25 <shiona> nice
01:35:28 <spacekitteh> i'm trying to get this work with GHC.TypeLits.fromSing: bladeNormalForm :: forall (n::Nat) f. (n ~ Nat, Algebra.Additive.C f) =>  Blade n f -> Blade n f
01:35:41 <spacekitteh> but i can't figure out how to specify that n is a nat properly in the type signature
01:42:42 <pavonia> spacekitteh: Is Nat also a type?
01:42:53 <spacekitteh> pavonia: it is GHC.TypeLits.Nat
01:43:21 <pavonia> So it's a kind, I think
01:43:24 <spacekitteh> yeah
01:43:33 <pavonia> which means n ~ Nat doesn't work
01:44:25 <spacekitteh> what would, then?
01:45:20 <pavonia> n :: Nat already says it's of kind Nat, so n ~ Nat shouldn't be necessary
01:45:56 <spacekitteh> if i remove it then i get this error:
01:45:57 <spacekitteh> Could not deduce (SingI Nat n) arising from a use of `sing'
01:45:57 <spacekitteh>     from the context (Algebra.Additive.C f)
01:45:57 <spacekitteh>       bound by the type signature for
01:45:57 <spacekitteh>                  bladeNormalForm :: Algebra.Additive.C f => Blade n f -> Blade n f
01:46:18 <pavonia> What is you complete definition?
01:46:27 <pavonia> *your
01:46:29 <spacekitteh> of Blade or bladeNormalForm?
01:46:40 <pavonia> of the function
01:47:05 <spacekitteh> http://lpaste.net/7407070933342486528
01:47:44 <mdko> quit
01:47:47 <mdko> \leave
01:48:25 <mniip> It's /quit
01:48:35 <mniip> Or /part #channel
01:49:25 <spacekitteh> pavonia: i haven't actually gotten around to using n' yet, though
01:51:08 <pavonia> spacekitteh: Hhm, not sure how to solve that, I think you need something like "SingI n" in the context
01:51:46 <xintron> Is there any scotty (Web.Scotty) specific channel available?
01:52:33 <spacekitteh> pavonia: then i have to add SingI n to every function which depends on that, don't i?
01:52:58 <pavonia> probably, yes
01:53:12 <spacekitteh> hmm
01:53:20 <spacekitteh> can i use gadts to solve that
01:53:31 <pavonia> Does that even make it work?
01:53:45 <adas> what is a typical scenario where you would want to use the MaybeT monad?
01:53:46 <spacekitteh> i read a tutorial saying it does but i've never been able to make it work myself
01:54:08 <adas> like when some part of an expressions returns Nothing, MaybeT must terminate right?
01:54:17 <pavonia> spacekitteh: No, I mean the SingI n constraint
01:55:04 <spacekitteh> oh, it solves the error with the actual funciton but now i'm just adding the constraints to every other funciton in the module to see if it does
01:55:18 <pavonia> okay
01:56:30 <pavonia> adas: Yes, it's for computations that may return a result or terminate prematurely
01:57:36 <pavonia> (where EitherT/ErrorT does the same but with an additional error result on termination)
02:02:09 <b0bbi10> morning, so Haskell uses indentation/ alignment too (like Python) in order to define a block?
02:03:03 <lieven_> b0bbi10: optionally, yes. You can also use braces and semicolons
02:03:07 <adas> pavonia: http://lpaste.net/101119 The computation do not terminate prematurely
02:04:12 <adas> pavonia: all the four putStrLn lines end up printing even though in ghci
02:04:35 <spacekitteh> pavonia: yeah, it works. Now to figure out how to get rid of the SingI constraints in every function
02:05:50 <pavonia> adas: "return Nothing" is the opposite of failing, i.e. it successfully returns with a value Nothing
02:06:16 <pavonia> you have to use fail, I think
02:07:39 <peteretep> How do you guys make decisions about Haskell modules? For example, choosing between Data.CSV and Text.CSV? With CPAN, which I'm used to, there are all kinds of obvious and less obvious hints I use
02:08:01 <fly2web> []:'undefined' == []?
02:08:03 <fly2web> right?
02:08:32 <pavonia> fly2web: No, that is a syntax error
02:08:41 <fly2web> pavonia: wait
02:08:59 <fly2web> map' :: (a -> b) -> [a] -> [b]
02:08:59 <fly2web> map' f xs = foldr (\x acc -> f x : acc) [] xs
02:09:12 <fly2web> first try acc is undefined?
02:09:32 <fly2web> first trying 'acc' is undefined?
02:09:32 <peteretep> no, it's []
02:09:34 <pavonia> acc is []
02:09:37 <peteretep> Which is an empty list
02:09:54 <fly2web> oh. then []:[] = []  <---- right?
02:10:13 <peteretep> No. What's the type of (:)?
02:10:23 <fly2web> []:[] == []
02:10:24 <peteretep> (also: try typing that in to ghci)
02:10:27 <fly2web> this is right?
02:10:30 <peteretep> Not right
02:10:31 <fly2web> oh i see
02:10:41 <peteretep> []++[] is something else you could try
02:10:57 <peteretep> And might give you an idea of the difference between (++) and (:)
02:11:13 <pavonia> []:[] == [[]]
02:12:11 <peteretep> It is a great shame most Hackage packages don't come with a "Synopsis" section
02:13:33 <jle`> woo hoo my first use of existentials
02:13:38 <jle`> in production
02:13:42 <jle`> i'm not sure if this is a good thing or a bad thing
02:13:49 <johnw> forall jle. jle -> IO Hooray
02:13:57 <jle`> johnw:  :)
02:14:33 <jle`> i have a free monad(io) that has a 'fork' command
02:14:44 <johnw> ooh, cool
02:14:59 <fly2web> map' f xs = foldr (\x acc -> f x : acc) [] xs  <---- frist trying,  f [] : []  second trying f first element : []     <------- something strange. why [] start ?
02:15:11 <jle`> so data Process a = ProcessPure a | forall b. Process (Process b) (ThreadId -> Process a)
02:15:20 <jle`> that is a safe usage, right?
02:15:25 <jle`> or a proper usage
02:15:37 <johnw> sure
02:15:47 <peteretep> fly2web: I couldn't understand your sentence
02:15:49 <jle`> fly2web: try manually expanding out an application on pen/paper and you will see
02:16:04 <fly2web> ok
02:22:23 <fly2web> http://lpaste.net/101121 ----> i don't know this.
02:24:27 <pavonia> fly2web: the first value of x isn't [] but 1, [] would be a type mismatch
02:26:05 <b0bbi10> when LYAH says "The names defined in a let inside a list comprehension are visible to the output function (the part before the |) and all predicates and sections that come after of the binding" what is an example for such a section that comes after the predicate? where clauses?
02:29:17 <bahamas> b0bbi10: I interpret it as a name defined in one predicate is accessible in the next predicate that you define in the list comp
02:29:23 <bahamas> because you can have more than one predicate
02:29:59 <b0bbi10> I see
02:30:02 <bahamas> actually, this example in the book shows that calcBmis xs = [bmi | (w, h) <- xs, let bmi = w / h ^ 2, bmi >= 25.0]
02:30:22 <bahamas> b0bbi10: bmi >= 25.0 is the second predicate
02:30:32 <johnw> you'd need a , to continue the let
02:30:33 <bahamas> I don't know if "where" can be used in list comps
02:30:35 <johnw> a ;
02:31:18 <peteretep> I am using Test-CSV. I am trying to match some of the return values in pattern matching, namely CSV and ParseError. It looks like I will need to explicitly import these in my `import` statement, even though I don't want to use them as constructors
02:31:23 <peteretep> is that accurate?
02:31:34 <johnw> yes
02:31:40 <johnw> Haskell uses constructors for pattern matching
02:31:43 <bahamas> yes, like let bmi = w / h ^ 2; maxValue = 25, bmi >= maxValue
02:34:21 <peteretep> http://lpaste.net/101123 -- I'm sure I'm doing something obviously stupid here
02:34:23 <peteretep> but I don't see what
02:36:09 <bahamas> peteretep: does the module export those constructors?
02:36:49 <peteretep> I assume so, as I got a complaint when I put ParseError in the wrong import
02:37:32 <Hafydd> peteretep: parseCSVFromFile :: FilePath -> IO (Either ParseError CSV), meaning that its result will either be Left (p :: ParseError) or Right (c :: CSV).
02:37:59 <peteretep> Hafydd: You're right, and I'm stupid
02:38:00 <peteretep> Thanks
02:38:05 <Hafydd> But that's not all, I think.
02:38:12 <peteretep> Well, let me start with that
02:39:37 <Hafydd> Your function should also be locationList :: IO CSV, I think, and you need to bind the result of parseCSVFromFile using do-notation, or >>=.
02:40:02 <peteretep> Hafydd: You are right, and that's what I'm doing now
02:40:34 <Hafydd> Finally, error :: String -> a, so you'll want to use: error (show e).
02:40:54 <peteretep> compiles now, thanks
02:44:03 <bahamas> I thought I understood how to define a function, but apparently I don't
02:44:36 <johnw> what do you mean, bahamas?
02:44:43 <audax333> Does someone here know of a port of "readability.js"? It is a tool that given an html document, pulls out the main body text and cleans it up.
02:46:00 <bahamas> johnw: I mean I'm still used to put one assignment after the other, like in an imperative language. I tried doing let x = val / 2 \n result = if x > 10 then "foo" else "blah"
02:47:10 <johnw> well, that works in do notation
02:47:20 <johnw> you're missing an "in" otherwise
02:47:36 <bahamas> johnw: right, that's what I thought
02:47:43 <johnw> let x = val / 2 in if x > 10 then "foo" else "blah"
02:47:51 <bahamas> johnw: but do notation is used only when working with IO, no?
02:48:03 <johnw> you can use do notation in the Identity monad
02:48:08 <johnw> in any monad
02:48:22 <johnw> runIdentity $ do
02:48:23 <johnw>   let x = val / 2
02:48:26 <bahamas> ok, in a monad then
02:48:33 <johnw>   return $ if x > 10 then "foo" else "blah"
02:48:55 <johnw> Identity is just as pure as pure code
02:49:09 <johnw> s/pure code/non-monadic code
02:49:22 <bahamas> I haven't reached that level. I mean, I've barely reached monads
02:49:35 <johnw> ah, it'll come soon enough
02:50:35 <bahamas> johnw: also, another rule that I assume, if I'm using guards, I don't put "=" after the pattern match, right?
02:50:36 <merijn> johnw: This is why I dislike people calling monadic code "impure", it confuses people into silly ideas
02:50:58 * hackagebot tf-random 0.3 - High-quality splittable pseudorandom number generator  http://hackage.haskell.org/package/tf-random-0.3 (MichalPalka)
02:51:01 <johnw> right, in fact I object to the word "pure", it leads to the same silly ideas
02:51:04 * Kinnison hugs monads
02:51:24 <merijn> bahamas: I recommend this syntax cheat sheet: http://blog.codeslower.com/static/CheatSheet.pdf
02:51:28 <johnw> all evaluation is pure, all execution is impure
02:51:36 <bahamas> actually the way A Gentle Introduction to Haskell uses guards makes it more obvious
02:51:43 <bahamas> it looks more like an equation
02:51:46 <bahamas> merijn: thanks
02:54:08 <bahamas> it's not clear from the document, but can you have a new line on the right of "->" in a case expression?
02:54:29 <merijn> bahamas: Yes, as long as the next line is indented more than the start of the case pattern
02:55:14 <merijn> bahamas: You can have new lines almost anywhere, I recommend just quickly learning the layout rules completely (they're not very complex) to avoid guessing
02:55:17 <merijn> bahamas: See https://en.wikibooks.org/wiki/Haskell/Indentation
02:57:54 <bahamas> merijn: great. that's what I was looking for. thanks
03:02:35 <fly2web> map' f xs = foldr (\x acc -> f x : acc) [] xs <--------    f ------> foldr (\x acc -> f x : acc) []  and xs ----> xs    <---- right?
03:02:46 <bahamas> my impression is that a function outside of a monad has the body made up of chained expression. does it make sense what I'm saying and is it correct?
03:04:27 <bahamas> fly2web: what are you asking? I don't understand
03:04:41 <merijn> bahamas: Any function, this applies even to functions involving monads, consist of one single expression
03:04:55 <fly2web> map' f xs = foldr (\x acc -> f x : acc) [] xs
03:04:55 <merijn> bahamas: A do-block is just a single big expression too
03:04:55 <fly2web> f ------> foldr (\x acc -> f x : acc) []
03:05:02 <fly2web> xs ----> xs
03:05:06 <bahamas> merijn: ok, but I what I mean is that that expression can be made of other expressions, right?
03:05:15 <merijn> bahamas: Sure
03:05:17 <fly2web> you can see now bahamas
03:05:17 <spacekitteh>  /window 6
03:05:26 <merijn> bahamas: In fact, that's the only way to make expressions :)
03:05:37 <merijn> bahamas: Since values are expressions too
03:06:08 <merijn> bahamas: btw, now that you're reading up on syntax details, you might want to learn the way do-notation's syntactic sugar works too: https://en.wikibooks.org/wiki/Haskell/do_Notation
03:06:09 <no-n> @src sequence
03:06:09 <lambdabot> sequence []     = return []
03:06:09 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
03:06:09 <lambdabot> -- OR: sequence = foldr (liftM2 (:)) (return [])
03:06:26 <bahamas> merijn: yeah, I need to grok that on a deeper level. it feels that with an imperative language you can do an assignment and catch your breath, while with haskell you're running until you evaluate everything, so to speak
03:06:45 <bahamas> merijn: ok, I'll look at that as well
03:07:05 <merijn> bahamas: It's rather easy to understand, I usually recommend people not use do-notation until they're somewhat comfortable writing code using >>= and >> as that makes it much simpler to understand what's going on in do notation
03:07:54 <bahamas> merijn: above I was referring to the part about expressions, not do-notation :)
03:08:09 <t4nk727> @pl g n=1+(g$n-g(g$n-1))
03:08:09 <lambdabot> g = fix (((1 +) .) . ap (.) (ap (-) . ap (.) (. subtract 1)))
03:08:25 <bahamas> when I said I needed to grok on a deeper level. I need to get used to working with expressions only
03:09:01 <merijn> bahamas: The other way to look at it is that imperative languages constantly make you worry about "where" to store things, whereas in functional language you don't have to worry about location :)
03:09:07 <no-n> would foldl (>>) (return ()) be the same as sequence
03:09:21 <merijn> no-n: It'd be the same as sequence_, but yes
03:09:25 <bahamas> fly2web: can you use words instead of arrows to express what you mean?
03:09:26 <no-n> ahh, yeah
03:09:27 <merijn> :t sequence_
03:09:27 <lambdabot> Monad m => [m a] -> m ()
03:09:52 <t4nk727> @pl g n= (1+).f.(n-).f.f.(-1)$n
03:09:53 <lambdabot> g = (((1 +) . f) .) =<< (. (f . f . -1)) . (-)
03:09:58 <fly2web> i m not good at english. so i can't express it.
03:09:59 <bahamas> merijn: I think it's more intuitive to store things somewhere, but maybe that's just me :)
03:10:09 <fly2web> bahamas:
03:10:16 <merijn> bahamas: You get used to it :)
03:10:34 <bahamas> merijn: sure. that's what I'm planning on doing :)
03:10:56 <bahamas> fly2web: so you're defining a function map' which takes a functio f and xs which is a list
03:11:07 <bahamas> fly2web: then you are using foldr to implement that function
03:11:12 <fly2web> yes
03:11:15 <fly2web> right.
03:11:38 <bahamas> fly2web: ok, so what is unclear?
03:12:18 <fly2web> f express 'foldr (\x acc -> f x : acc) []' and xs express 'xs' in the 'map' f xs = foldr (\x acc -> f x : acc) [] xs'
03:13:09 <fly2web> i don't know why starter is []?
03:13:38 <fly2web> i think that starter will be xs's first element?
03:13:46 <bahamas> fly2web: [] is the accumulator.
03:14:08 <bahamas> fly2web: that's where you store the values returned by the lambda
03:15:06 <fly2web> sum' xs = foldl (\acc x -> acc + x) 0 xs   ---> 0 is starter, and map' f xs = foldr (\x acc -> f x : acc) [] xs  ----> [] is starter.
03:15:16 <fly2web> arent you?
03:15:20 <fly2web> bahamas:
03:15:31 <peteretep> fly2web: What would that do if xs was only one value long?
03:15:33 <bahamas> fly2web: the workflow is like this: take the first value of xs. apply the (\x acc -> ...) lambda to it and to the accumulator and return a list with one element
03:15:51 <peteretep> fly2web: Because your list might be one item long, you need a base element
03:15:52 <bahamas> fly2web: yes, for sum' the accumulator is 0, because sum' returns an Int
03:16:23 <peteretep> unhelpful: and (0, (+), Int) is a monoid!
03:16:52 <fly2web> oh i will be understandable perhaps.
03:16:55 <bahamas> fly2web: think of the accumulator as a container to store the values that you process
03:17:18 <peteretep> fly2web: Think about how you would write a folding function that handled lists of one item, and of many items
03:17:31 <peteretep> fly2web: You'd need a base element for handling lists of one item
03:17:52 <fly2web> sum' xs = foldl (\acc x -> acc + x) 0 xs  <--------- 0 is the starting value and xs
03:18:28 <fly2web> xs is the list to be folded up
03:18:29 <shiona> is there some TH-magic so one could write monoids etc. just like peter just wrote?
03:18:51 <bahamas> fly2web: correct
03:19:19 <peteretep> What is TH-magic?
03:19:25 <fly2web> ok i will study more thanks bahamas
03:19:59 <bahamas> fly2web: basically, you are traversing xs and doing something with each value.
03:20:03 <bahamas> fly2web: you're welcome
03:21:15 <tdammers> hmm... I'm having a bit of a problem her
03:21:37 <tdammers> class Foo a where foo :: a -> String; bar :: String -> a
03:21:43 <tdammers> and then
03:21:56 <tdammers> baz :: String -> a
03:22:10 <tdammers> now inside baz, I want to call foo
03:22:17 <tdammers> oh wait
03:22:19 <tdammers> nm
03:22:20 <tdammers> I know
03:22:27 <tdammers> rubber duck, ignore me
03:25:15 <b0bbi10> damn it, do you have some tips for me while learning Haskell? I am using LYAH and after reading every chapter (or even section) the first time I am like "how weird is that?". have to reread it a couple of times before really understanding what's going on.
03:25:42 <shiona> that's just how it goes
03:25:47 <b0bbi10> but have to admit, I enjoy learning that strange new thing ;)
03:26:05 <shiona> or that's how it was for me, I cannot speak for other, smarter people
03:26:19 <peteretep> I found LYAH to be too dense
03:26:24 <peteretep> I like solving problems to learn
03:26:32 <peteretep> So I've written a bunch of exercises to solve as I go
03:26:35 <peteretep> to cover things like Monads
03:32:32 <no-n> @src words
03:32:32 <lambdabot> words s = case dropWhile isSpace s of
03:32:32 <lambdabot>     "" -> []
03:32:32 <lambdabot>     s' -> w : words s'' where (w, s'') = break isSpace s'
03:34:09 <bahamas> b0bbi10: I'm in the same position as you are. I like to write down my thoughts for example
03:34:25 <bahamas> but yeah, I have to go back and reread to make sure I understand
03:35:42 <bahamas> I agree with using exercises as well, but I tend to absorb the theory first. that's one downside of LYAH, that it doesn't have exercises
03:36:03 * hackagebot jwt 0.2.1 - JSON Web Token (JWT) decoding and encoding  http://hackage.haskell.org/package/jwt-0.2.1 (StefanSaasen)
03:41:26 <fly2web> map' f xs = foldr (\x acc -> f x : acc) [] xs  --> x and xs is same type?
03:41:29 <bahamas> now I'm curious how the other languages from the functional family differ from haskell besides the type system
03:41:54 <fly2web> map' f xs = foldr (\x acc -> f x : acc) [] xs  --> x and acc is same type?
03:41:55 <bahamas> fly2web: no, x is type "a" and xs is type "[a]"
03:42:26 <fly2web> map' f xs = foldr (\x acc -> f x : acc) [] xs  --> x and acc is same type?
03:42:44 <tdammers> bahamas: depends on the language
03:43:03 <bahamas> fly2web: no, it's the same thing. x has type "a" and acc has type "[a]"
03:43:08 <tdammers> bahamas: but most of them default to strict evaluation, and most allow impure functions somehow
03:43:41 <bahamas> tdammers: oh, right. I was just reading about that in the gentle introduction, that evaluation is non strict in haskell
03:44:09 <tdammers> it doesn't have to be
03:44:16 <tdammers> it's just the default
03:44:52 <bahamas> tdammers: it can be changed on function by function basis?
03:45:18 <tdammers> not quite
03:45:29 <tdammers> you can enforce evaluation using the `seq` operator
03:45:59 <tdammers> also, many functions come with strict versions
03:46:05 * hackagebot core-haskell 0.6.2 - A subset of Haskell using in UCC for teaching purpose  http://hackage.haskell.org/package/core-haskell-0.6.2 (happlebao)
03:46:35 <tdammers> generally speaking, the mechanism is that you can say "when this thing here is evaluated, also evaluate that other thing there"
03:46:45 <tdammers> it's still relative
03:47:37 <bahamas> ah, ok
03:48:17 <bahamas> tdammers: that makes me assume that once you know haskell well, you can learn the others relatively easily
03:48:40 <tdammers> idk, probably
03:48:44 <yesthisisuser> apart from functions, laziness/strictness is also relevant to data structures
03:49:11 <tdammers> yesthisisuser: true, although the line is somewhat blurry
03:49:27 <tdammers> data constructors doubling as functions and all that
03:50:10 <yesthisisuser> yes.. i was just thinking since a lot of people follow the convention "make data strict, functions lazy" by default
03:50:33 <merijn> Which isn't necessarily a good convention
03:50:40 <tdammers> I was about to say that
03:51:05 * hackagebot profiteur 0.1.2.1 - Treemap visualiser for GHC prof files  http://hackage.haskell.org/package/profiteur-0.1.2.1 (JasperVanDerJeugt)
03:51:13 <tdammers> e.g. lazy Text is probably a better choice for linear parsing than strict Text
03:51:25 <merijn> See bos' remarks at haskell conference noting that he had problems with a lot of people having made their haskell code to strict
03:52:19 <yesthisisuser> that's a good point.
03:52:33 <fly2web> ok i know it bahamas ,    map' f xs = foldr (\x acc -> f x : acc) [] xs   [] is just acc's starter. and x is xs's content of procedual.
03:53:04 <fly2web> right? bahamas
03:58:22 <spacekitteh> what is the correct syntax for GADTs with typeclass constraints to enable you to not have to write the typeclass in every function that uses it?
03:59:50 <spacekitteh> this is what i have but it doesn't seem to work: data Blade (n :: Nat) f where Blade :: forall n f . (SingI n, Algebra.Ring.C f) => {_scale :: f, _indices :: [Natural]} -> Blade n f
04:00:50 <spacekitteh> whenever i define a function which uses a blade it still wants constraints for the SingI and Algebra.Ring.C
04:01:03 <bahamas> fly2web: [] is the initial value of acc, yes
04:01:28 <fly2web> ok i think it as x's starter. oh my god
04:01:29 <bahamas> fly2web: and x is from xs, yes. in python it would be something like for x in xs: ...
04:01:47 <fly2web> ok i understand it. perfectly. thanks
04:03:01 <bahamas> you're welcome
04:11:07 * hackagebot core-haskell 0.6.3 - A subset of Haskell using in UCC for teaching purpose  http://hackage.haskell.org/package/core-haskell-0.6.3 (happlebao)
04:26:34 <Left_Turn> guys please be weary of fly2web.. he poses as a nice person. I spent hours helping him but now im a lot more busy he's turned to a very nasty person
04:26:36 <Left_Turn> <fly2web> england bastard Left_Turn
04:26:37 <Left_Turn> <Left_Turn> ...
04:26:37 <Left_Turn> <fly2web> show me your mother photo?
04:26:37 <Left_Turn> <Left_Turn> lol
04:26:37 <Left_Turn> <fly2web> very fat like pig. i think so.
04:26:37 <Left_Turn> <fly2web> i will study haskell then i will hack you.
04:26:39 <Left_Turn> <fly2web> haha
04:26:43 <Left_Turn> <fly2web> england bastard.
04:26:45 <Left_Turn> <Left_Turn> awesome
04:27:50 <peteretep> http://lpaste.net/101128
04:27:59 <peteretep> Something identical works in examples I can find
04:28:06 <peteretep> But for some reason, I can't define ToMessage
04:29:23 <peteretep> huh, looks like it was because I did a qualified import of Happstack server
04:29:26 <peteretep> removing that fixes it
04:31:10 * hackagebot HMap 1.1.3 - Fast heterogeneous maps and unconstrained typeable like functionality.  http://hackage.haskell.org/package/HMap-1.1.3 (AtzeVanDerPloeg)
04:36:10 * hackagebot HMap 1.1.4 - Fast heterogeneous maps and unconstrained typeable like functionality.  http://hackage.haskell.org/package/HMap-1.1.4 (AtzeVanDerPloeg)
04:41:11 * hackagebot core-haskell 0.6.4 - A subset of Haskell using in UCC for teaching purpose  http://hackage.haskell.org/package/core-haskell-0.6.4 (happlebao)
04:46:11 * hackagebot alfred 0.1 - utility library for Alfred version 2  http://hackage.haskell.org/package/alfred-0.1 (PatrickBahr)
04:49:04 <hunt> can i get a working cabal install on my school computer without root?
04:49:29 <hunt> i my project has dependencies
04:53:47 <merijn> hunt: Cabal installs local user by default
04:54:13 <merijn> hunt: So if you can compile cabal or it's already installed, then it should Just Work(TM)
04:54:22 <spacekitteh> >cabal
04:54:24 <hunt> merijn, i cant apt-get install it though
04:54:24 <spacekitteh> >just work
04:54:31 <spacekitteh> nice joke merijn
04:54:44 <hunt> merijn, and i cant get source because theres no dpkg-src
04:54:48 <merijn> hunt: You can download the cabal source and compile and install that in your user dir
04:55:42 <merijn> hunt: See the download page here: http://www.haskell.org/cabal/download.html
04:55:53 <merijn> Of course installing cabal requires ghc, but you can install ghc as user too
04:56:37 <hunt> merijn, cool, theres already ghc i just need cabal for some dependencies
04:57:18 <merijn> hunt: Right, then you can just follow the install instructions in the source and install them in your user directory
04:57:27 <merijn> After which it will just install all packages there too
04:58:56 <zlatan> hunt, you can probably use apt-get install cabal-install and for source you need to enable deb-src in sources.list
04:59:53 <merijn> zlatan: He just said he can't use apt-get since it's a student machine
05:00:03 <hunt> zlatan, i wish i could but pretty much anything involving folders outside of home is locked from students
05:00:15 <hunt> merijn, im going to try that
05:00:25 <zlatan> merijn, ah, okay didn't read that
05:00:49 <merijn> hunt: I just set it up this way last week on some of the cluster machines here (same problem, no root, etc.) and works just fine here
05:03:47 <kgadek> hi. have anybody got the _hsnet_freeaddrinfo error for network on GHC 7.6.3. What is "funny", it worked when installing from brew. http://lpaste.net/101130
05:03:49 <zlatan> hunt, if the source line is enabled you don't need root to get source (but I guess it isn't?)
05:04:00 <kgadek> (OS X 10.9)
05:04:49 <merijn> kgadek: "--global --force-reinstalls" ಠ_ಠ ಠ_ಠ ಠ_ಠ ಠ_ಠ
05:05:12 <hunt> zlatan, yea i dont think it is
05:05:17 <kgadek> that's a part of a script to setup a confined haskell, don't mind that. really ;)
05:05:45 <zlatan> hunt, you can try apt-get source cabal-install and if it gets anything
05:06:16 <hunt> zlatan it got deb files and some files  i dont recognize
05:06:28 <hunt> zlatan its ok though i wgot it from the install page and built myself
05:06:38 <zlatan> hunt, oh, okay then :)
05:10:10 <hunt> merijn, after ghcing setup, Setup configure, Setup install tells me that/usr/local/shared/doc is denied permission
05:10:14 <hunt> merijn, tips?
05:33:00 <b0bbi10> is there a difference in listing the predicates in the list and joining them with &&?
05:34:35 <quchen> What's "listing the predicates in the list"?
05:34:36 <quchen> "joining them" is `and`, I assume
05:35:56 <b0bbi10> quchen: listing is predicate1, predicate2, predicate 3 and joining is `and` (or &&)
05:41:13 <quchen> b0bbi10: I don't understand the problem. Do you have a code example?
05:41:22 <quchen> (Sorry, got connection problems)
05:43:11 <b0bbi10> quchen: like [x | x <- xs, x<1, x `mod` 2 == 0] == [x | x <- xs, x<1 && x `mod` 2 == 0]
05:43:29 <b0bbi10> but I figured, I could have just typed that in the console and see for myself
05:44:34 <quchen> Oh, in list comprehensions. The "comprehension" part is important, because a list is anything of type [a].
05:57:18 <magicman>       say("`3The Tree is Life!",&cultist1);
05:57:18 <magicman>       say_stop("`8The Tree is Life!",&cultist2);
05:57:24 <magicman> ... No. Not that.
05:57:29 <magicman> Mispaste, sorry -_-
06:00:00 <no-n> is there a list-like data-structure that supports quick appends/extends to both left and right?
06:00:34 <ClaudiusMaximus> Data.Sequence maybe
06:01:02 <xintron> Any library to recommend for reading process statistics of the system?
06:01:20 * hackagebot HMap 1.1.5 - Fast heterogeneous maps and unconstrained typeable like functionality.  http://hackage.haskell.org/package/HMap-1.1.5 (AtzeVanDerPloeg)
06:01:20 <no-n> looks Maybe promising :}
06:01:24 <fizruk> no-n: see also http://hackage.haskell.org/package/dlist-0.6.0.1/docs/Data-DList.html
06:01:30 <no-n> cheers
06:13:24 <xintron> To list all processes (linux), how would one check if the directory is a PID? `filter (all isNumber) procDirs` or is there a more efficient way?
06:13:46 <StevenNL> hi Guys
06:14:07 <StevenNL> I want to write something like  [1,2,3,4] `intersect` [2,4,6,8] == [2,4]
06:14:23 <StevenNL> but I want to use String and int
06:14:32 <Kron> well, using String is the same thing
06:14:36 <StevenNL> is that even possible?
06:14:40 <Kron> Strings in haskell are just character lists
06:14:58 <Kron> let's see...
06:15:08 <Kron> would you like to know how to do it as quickly as possible using pre built functions
06:15:18 <Kron> or would you like to learn how to do it yourself?
06:16:13 <StevenNL> I can use intersect  but I want to lear to build it myself
06:16:28 <StevenNL> I want to write a program for my website using Haskell
06:16:38 <Kron> alright
06:16:51 <Kron> do you know about Maybe?
06:17:31 <StevenNL> No but I'm googling right know
06:17:42 <Kron> it's a simple data type that can either hold another data type inside it, or a failure value
06:17:47 <Kron> it looks like this:
06:17:54 <Kron> data Maybe a = Nothing | Just a
06:18:08 <Kron> what this means is that the type "Maybe a" (for any value of a) can either be Nothing or Just a
06:18:16 <Kron> so a Maybe Int can be Nothing or Just 4, etc.
06:18:26 <Kron> it lets you basically add in a failure condition to the type of your function
06:18:58 <Kron> so, there's already a simple haskell function that does something similar called find
06:19:48 <Kron> > find (== 3) [1,2,3,4,5]
06:19:49 <lambdabot>  Just 3
06:19:56 <Kron> > find (> 7) [1,2,3,4,5]
06:19:57 <lambdabot>  Nothing
06:20:15 <Kron> A simple sub problem I think you should ask yourself is how would you implement a function like find
06:20:28 <StevenNL> I want this
06:20:28 <StevenNL> intersection “programming” “software” => “roa”
06:20:32 <Kron> how can you check if a single value is in a given list or not
06:20:41 <Kron> right
06:20:51 <StevenNL> but I want to write it myself and not using intersect
06:21:11 <StevenNL> so I can use Maybe ?
06:21:43 <Kron> > map (\x -> find (== x) "programming") "software"
06:21:44 <lambdabot>  [Nothing,Just 'o',Nothing,Nothing,Nothing,Just 'a',Just 'r',Nothing]
06:23:03 <Kron> > filter isJust [Nothing, Just 'o', Nothing, Nothing, Nothing, Just 'a', Just 'r', Nothing]
06:23:04 <lambdabot>  [Just 'o',Just 'a',Just 'r']
06:23:08 <StevenNL> let me play with it ..
06:23:20 <Kron> I think you can see the basics of what I'm doing up there
06:23:20 <StevenNL> Thnx I'll try it
06:23:31 <Kron> first I use a map to map a find function over the target list
06:23:36 <Kron> then i extract all the found elements
06:23:40 <Kron> and collapse it into a list myself
06:26:21 <ion> map (… find …) is O(n²)
06:27:00 <Kron> ion: I know, but I do feel it's helpful to start with basic composable functionality when you're a beginner
06:27:36 <Kron> constructing a giant recursive function would be faster, but even then when I was new to haskell I mucked it up because I didn't understand lazy evaluation semantics
06:27:45 <Kron> (thought foldl was more efficient than foldr since it was tail recursive)
06:28:05 <ion> Sure, nothing wrong with starting with that implementation, it’s just worth noting.
06:28:11 * Kron nods
06:28:38 <Kron> hmmm
06:28:42 <Kron> how would I do it...
06:29:30 <Kron> > foldr fn z [a,b,c]
06:29:31 <lambdabot>  Not in scope: `fn'
06:29:31 <lambdabot>  Perhaps you meant one of these:
06:29:31 <lambdabot>    `f' (imported from Debug.SimpleReflect),
06:29:31 <lambdabot>    `n' (imported from Debug.SimpleReflect),
06:29:31 <lambdabot>    f' (imported from Debug.SimpleReflect)
06:29:39 <Kron> > foldr f z [a,b,c]
06:29:40 <lambdabot>  f a (f b (f c z))
06:32:25 <Kron> > foldr (\x acc -> maybe acc (:acc) $ find (== x) "programming") "software"
06:32:26 <lambdabot>  <[Char] -> [Char]>
06:32:35 <Kron> > foldr (\x acc -> maybe acc (:acc) $ find (== x) "programming") [] "software"
06:32:36 <lambdabot>  "oar"
06:32:40 <Kron> heh
06:32:43 <Kron> got it in one
06:32:55 <Kron> that's sadly O(n^2) still
06:33:00 <Kron> I wonder if I can actually make it more efficient
06:33:36 <Kron> I guess, if they're Orderable then we sort them first and do a modified merge via intersection instead of union?
06:33:59 <Kron> in that case it's smarter to just dump them into Sets and intersect them and extract them out again
06:35:29 <ion> If intersection is the use case, using lists is probably not the right choice.
06:35:40 <Kron> > foldr insert (empty :: Set Char) "programming"
06:35:41 <lambdabot>  Not in scope: type constructor or class `Set'
06:35:42 <lambdabot>  Perhaps you meant one of these:
06:35:42 <lambdabot>    `S.Set' (imported from Data.Set),
06:35:42 <lambdabot>    `Seq.Seq' (imported from Data.Sequence)
06:35:49 <Kron> > foldr insert (empty :: S.Set Char) "programming"
06:35:50 <lambdabot>  Couldn't match expected type `[GHC.Types.Char]'
06:35:51 <lambdabot>              with actual type `Data.Set.Base.Set GHC.Types.Char'
06:36:01 <ion> S.fromList
06:36:14 <Kron> ah
06:36:27 <Kron> this is the first time I've ever looked up the Set docs
06:36:50 <Kron> and yeah if intersection is the use case it's probably best to pre cast them into sets and store those I guess
06:43:44 <danilo2> Hello! :) What a beautifull day we've got today :D But we are facing an strange error on ugly osx system while installing the network package: "GHCi runtime linker: fatal error: I found a duplicate definition for symbol _hsnet_freeaddrinfo". Does anybody know what causes it and how could we fix it to save the day? :)
06:44:29 <Kron> hmm, perhaps duplicate files or something? I've never run into an error like that before
06:44:44 <geekosaur> multiple versions of network?
06:44:53 <Kron> to be honest i'm not very experienced with large haskell compilations
06:45:02 <geekosaur> otherwise, you could be looking a yet another ghci linker bug if this is not 7.8
06:45:24 <geekosaur> (or even if it is, given that it just got rewritten to use the system linker and may still have lingering bugs in the corner cases)
06:45:24 <danilo2> Kron: hmm, this happens when we try to install it on clean system. It is 7.6.3, brb I will check something
06:52:07 <danilo2> Kron, geekosaur: Ok, we will try to use 7.8 then, maybe it will help. I will write back what is the status :) Or should I check something else also? :)
06:52:27 <Kron> I'm not the right person to ask, if geekosaur thinks you should upgrade then you should
06:52:36 <geekosaur> 7.8 currently has other issues sadly. (like, not all HP packages ported to it yet)
06:53:27 <geekosaur> but dup symbols in ghci is a known problem with older ghcs, due to its special built-in linker not being very smart. you may end up having to wait
06:54:02 <danilo2> geekosaur: hmm, thanks for the info :) I'll try though ad see if the packages we are using are working now
06:57:33 <exicer> So I want to construct a large matrix (approx 5k x 5k). Mostly it is just 0, but at certain positions I wish to inster a value. I have a list of such values [(Row, Column, Value)]. What is the easiest way for me to construct my matrix ?
06:57:53 <exicer> Doing this in numpy or something is really easy.. but I don't know how to go about doing it in Haskell
06:58:34 <shiona> exicer: how is it constructed and does it need to be mutable?
06:59:20 <exicer> It doesn't need to be mutable, construction is .. well I have a list of tuples :p
07:00:26 <shiona> how are you going to use the data? (why do you want to represent the data in matrix form)
07:00:40 <shiona> for most cases I think the list of tuples is a reasonable representation
07:01:09 <Sonderblade> exicer: most often you implement sparse matrices using dictionaries
07:01:26 <exicer> Hm, that could be true
07:01:38 <exicer> I was thinking about it as a matrix, so that is how I wanted to represent it
07:01:45 <exicer> But I guess you are right
07:02:30 <exicer> So if I, for instance, wanted to take the dot product between rows.. I guess you just have to sort it ?
07:03:59 <Sonderblade> there are some hackage packages which implement sparce matrices too
07:04:18 <exicer> Sonderblade: I'm just having a look. I see Sparse.Matrix, could you suggest anything else ?
07:04:50 <Sonderblade> sorry no
07:07:05 <Kron> REPA?
07:07:17 <Kron> http://www.haskell.org/haskellwiki/Numeric_Haskell:_A_Repa_Tutorial
07:07:34 <Kron> as far as i know REPA is The Thing You Get when you want numeric array computations
07:08:00 <exicer> Hm, okay. Looks like I have a fair amount of reading to do :p
07:08:48 <Kron> most of the time I don't use REPA since I like to use simpler data structure that are more understandable and more composable
07:08:55 * Kron says, while endlessly tinkering with quadtree code
07:09:18 <Kron> but as far as I know, if you want to take your gloves off and do serious J-style massive array math at really high speeds, you use REPA
07:09:21 <Kron> so good luck I guess
07:10:39 <StevenNL> @ kron : is it possible to only get the letter from filter isJust [Nothing, Just 'o', Nothing, Nothing, Nothing, Just 'a', Just 'r', Nothing]  and not just r .. but only r?
07:10:55 <Kron> yeah
07:11:16 <StevenNL> can I do it with break ?
07:11:19 <Kron> you can use fromJust
07:11:21 <Kron> what's break?
07:11:40 <exicer> Kron: What would you typically use, if you didn't want to use REPA ?
07:12:00 <Kron> exicer: for a 5k x 5k matrix, probably repa to be honest
07:12:07 <Kron> I don't deal with anything that large
07:12:20 <StevenNL> I thought using break and showing snd
07:13:01 <Kron> you could do something like this:
07:13:07 <Jaak> > catMaybes [Nothing, Just 'o', Nothing]
07:13:08 <lambdabot>  "o"
07:13:27 <Kron> stevenFilter _ [] = []
07:13:50 <Kron> or hold up
07:13:57 <Kron> don't even need the first argument
07:14:00 <Kron> filter' [] = []
07:14:13 <Kron> filter' ((Just x):xs) = x : filter' xs
07:14:22 <Kron> filter (Nothing:xs) =    filter' xs
07:14:27 <Kron> basically you can roll your own filter function
07:14:31 <Kron> that ignores Nothings
07:14:33 <Jaak> Kron: that's called catMaybes anyways
07:14:36 <Kron> and sucks out the values of Just
07:14:48 <StevenNL> oky I see
07:14:50 <StevenNL> Thnx
07:14:51 <Kron> Jaak: StevenNL is a newbie and wants to avoid using library functions as much as possible
07:14:59 <Kron> so I'm trying to spool out the logic I guess
07:15:17 <exicer> Kron: What if it were more like 500 x 500 ?
07:15:21 <Jaak> oh i see, yeah, that's useful exercise
07:15:23 <Kron> anyway, StevenNL: the point I was trying to make is that you can pattern match on "Just x" and Nothing and stuff
07:15:29 <joaoportela> :t const
07:15:30 <lambdabot> a -> b -> a
07:15:39 <StevenNL> thnx
07:15:54 <Kron> exicer: hmmm.... I'm not sure. Probably the ST Monad on a large normal array, or an ArrayRef or whatever they're called
07:15:57 <Kron> the mutable ones
07:17:04 <Kron> basically boring normal imperative language mutable arrays I guess
07:17:12 <fizbin> Is there any way in haskell to get type constructors that take a parameter in the type constructor that isn't a type?
07:17:14 <exicer> Fair enough
07:17:27 <fizbin> I may not have a good way to ask this question.
07:17:29 <Kron> fizbin: you'll need dependent typing or something
07:17:38 <Kron> this feature exists in languages like Idris
07:17:47 <Kron> but Haskell can't do it
07:18:00 <Kron> the type level and the value level are separate, they don't merge unless you get into a dependently typed language
07:18:15 <Kron> so type variables can only have types, normal variables can only have normal values
07:18:22 <Kron> in Idris both rules are regularly bent
07:18:54 <fizbin> I have an example here that works, and was kind of fun to work out: http://lpaste.net/101134 - but in that example I'd like it if I could do those "Marked" types not as separate types, but as enums.
07:19:06 <fizbin> @src Void
07:19:06 <lambdabot> Source not found. :(
07:19:41 <Kron> you can do some interesting value faking in types, like peano arithmetic and stuff
07:19:44 <Kron> anyway, gtg
07:19:44 <fizruk> fizbin: I think with data and some extension you can define types
07:19:55 <Kron> good luck StevenNL
07:20:50 <fizruk> fizbin: see DataKinds extension: http://www.haskell.org/ghc/docs/7.4.1/html/users_guide/kind-polymorphism-and-promotion.html
07:21:12 <fizbin> Hrm. I guess I could go somewhere faking peano arithmetic...
07:26:23 <fizbin> fizruk: Huh. DataKinds seems almost there. But what I really want to be able to do is then define a function on my type and call it in the course of restrictions.
07:26:30 * hackagebot fay-base 0.19.1 - The base package for Fay.  http://hackage.haskell.org/package/fay-base-0.19.1 (AdamBergmark)
07:26:32 * hackagebot fay 0.19.1 - A compiler for Fay, a Haskell subset that compiles to JavaScript.  http://hackage.haskell.org/package/fay-0.19.1 (AdamBergmark)
07:27:14 <fizbin> Although, for the actual use case I was considering that caused me to think hard about how to abuse GADTs, this may be sufficient.
07:27:16 <fizruk> fizbin: you want type functions? I guess you have type families for that
07:27:31 <fizruk> fizbin: anyway, I'm not an expert here :)
07:28:24 <merijn> fizbin: So you want to place restrictions on what types can be used for a function?
07:30:11 <fizbin> Well, look at my example (http://lpaste.net/101134) - I'd like to replace the *Marked types with an enum (which DataKinds might let me do, I think) and I'd like to replace the AddOneMarking class with the function "succ" or similar.
07:30:25 <fizbin> I don't think DataKinds gets me that second case.
07:30:44 <merijn> fizbin: You probably want to add type families to get type level functions
07:30:45 <fizbin> But as I said, it gets me far enough that for my real use case, that may be sufficient.
07:31:02 <merijn> fizbin: I find type families much simpler to use than functional dependencies
07:31:29 <merijn> fizbin: The "Fun with Type Functions" papers is a good introduction and they will let you write neat constraints like: https://gist.github.com/merijn/6130082
07:32:30 <merijn> fizbin: With GHC 7.8's closed type families you can write quite a lot of type level functions and use them in constraints to guarantee properties
07:33:37 <merijn> fizbin: And why not replace the three differnt "OneMarked" types with "data Nat = Zero | Succ Nat" and then define a function that let's you write a "x < 3" constraint at the type level
07:33:41 <merijn> ?
07:33:46 <merijn> But I have to run now, good luck!
07:34:12 <fizbin> Basically, because I couldn't figure out how to do x < 3 at the type level.
07:34:27 <fizbin> Only... huh. Maybe I can see how.
07:34:35 <fizbin> I'll try that then...
07:36:34 <fizbin> No, crud, that doesn't work. I can easily restrict (x > 3), but the proof that x is at most some value is not something I see how to do.
07:39:05 <fizbin> Oh! ha. Yeah, okay. I start from the other end and have Root start at 3 then count down...
08:06:35 * hackagebot creatur 5.2.3 - Framework for artificial life experiments.  http://hackage.haskell.org/package/creatur-5.2.3 (AmyDeBuitleir)
08:10:44 <fizbin> Updated http://lpaste.net/101134 to show the solution using DataKinds. That's much, much nicer.
08:11:35 * hackagebot lgtk 0.5.4 - lens-based API for Gtk  http://hackage.haskell.org/package/lgtk-0.5.4 (PeterDivianszky)
08:11:37 * hackagebot lgtk 0.5.4.1 - lens-based API for Gtk  http://hackage.haskell.org/package/lgtk-0.5.4.1 (PeterDivianszky)
08:33:34 <merijn> fizbin: I've got a more hardcore example for you :)
08:33:50 <fizbin> Hrm?
08:35:00 <merijn> 1 sec, cleaning it up a little bit
08:35:18 <kuribas> Is parsec the best parser library?
08:36:31 <augur> anyone have a good overview of the motivations for (functional) reactive programming?
08:36:52 <augur> like, what sort of programs become elegant when viewed as a reactive problem?
08:37:11 <merijn> fizbin: https://gist.github.com/merijn/9530680
08:37:12 <byorgey> kuribas: depends on what sort of parsing you want it for.
08:37:32 <merijn> augur: Read conal's FRAN (functional reactive animation) paper
08:37:33 <kuribas> byorgey: A language...
08:37:54 <merijn> fizbin: If you have questions about that, lemme know
08:38:38 <augur> merijn: ill give it a look
08:38:55 <kuribas> byorgey: A computer language, like metafont, but not metafont.
08:39:04 <byorgey> kuribas: parsec is a good choice then.  For something more industrial-strength you might also want to take a look at trifecta, though I don't think it has a lot of documentation
08:39:16 <Mopman> hi - sorry if this isn't a good location for this question, i'm not usually part of the haskell community. im trying to install a cabal package, and it's passing an option to ld that my ld doesnt support (old binutils, cant fix that atm) - is there any way to tell cabal not to pass that option? (/usr/bin/ld: unrecognized option '--build-id=none')
08:39:34 <kuribas> byorgey: thanks, I have heard of that before.
08:39:39 <merijn> fizbin: Basically "Empty 'c'" will type check, so will "Node (Empty 'a') (Empty 'b')" and "Node (Node (Empty 'a') (Empty 'b')) (Empty 'c')", but the following will be a type error: "Node (Node (Empty 'a') (Empty 'b')) (Node (Empty 'c') (Empty 'd'))" because the index argument will be bigger than three :)
08:39:52 <joelteon> I would say parsec is more "industrial-strength" than trifecta
08:39:58 <joelteon> trifecta only works on stringlike inputs
08:40:05 <dcoutts> Mopman: hmm, I'm not sure where that'd be coming from. It's not something that Cabal itself does.
08:40:11 <joelteon> parsec can handle any type of stream.
08:40:15 <merijn> Mopman: You can run "cabal unpack" to fetch the source, edit the cabal file to not pass the flag and then run "cabal install" inside the package directory
08:40:17 <fizbin> merijn: Right. What's the "~" operator in the Constraint do?
08:40:26 <merijn> Mopman: Assuming it comes from the package config
08:40:44 <Mopman> merijn / dcoutts: i was afraid of that, since other packages install fine. i tried grepping for it in the packages source dir after runhaskell Setup configure, but couldnt find anyhting that would be doing it :(
08:40:48 <dcoutts> Mopman: right as merijn says it might be in the package description (though that'd be unusual)
08:40:54 <merijn> fizbin: ~ is unification, i.e. "a ~ b" means "a unifies with b", which you can think of as type equality
08:41:14 <merijn> fizbin: So "Maybe a ~ Maybe Int" holds, IFF 'a' == 'Int'
08:41:15 <edwardk> parsec handles more input types, trifecta handles nicer diagnostics, gives you a syntax highlighter, doesn't move your error messages around on you, and lets you give back muliple error annotations
08:41:18 <dcoutts> Mopman: hmm, odd
08:41:37 <joelteon> yeah, I'm not debating trifecta's user-friendliness
08:41:42 <dcoutts> Mopman: try: ghc-pkg dump | grep build-id
08:41:48 <fizbin> Okay, but I don't understand the concept "unify the string "Error!" with the string "Inequality does not hold." "
08:41:48 <joelteon> parsec isn't so nice to use
08:41:52 <merijn> fizbin: Basically, the last line with ~ is never true, it's there to produce a nicer error
08:42:00 <fizbin> Ah.
08:42:01 <Mopman> dcoutts: nada
08:42:07 <merijn> fizbin: It's like "(Int ~ Char)", that constraint never holds
08:42:17 <edwardk> i rather deliberately left alternative input types out of lens, is it would have made an already complex type even more complex.
08:42:47 <merijn> fizbin: Those aren't strings though, they are Symbol (type level string from datakind), so they're an intentionally failing constraint
08:42:57 <edwardk> if you just need Char-base parsing, then writing to 'parsers' lets you abstract over trifecta, parsers, attoparsec, readp, in a way that you can run the same parser on all 4.
08:43:02 <edwardk> er based
08:43:23 <merijn> fizbin: So basically if "Zero :<= Zero" produces () (the empty constraint, which always holds)
08:43:25 <edwardk> i tend to just write my code with that API in mind
08:43:26 <kuribas> edwardk: can I use trifecta to parse a list of tokens?
08:44:01 <edwardk> kuribas: well, you can write a parser that spits out the token stream of course. ;) but trifecta is deliberately not designed around a separate lexer
08:44:02 <merijn> fizbin: Whereas "Succ Zero :<= Zero" produces the constraint "("Error!" ~ "Inequality does not hold.")", which is a constraint that can never be true and therefore causes a type error
08:44:25 <edwardk> kuribas: as it needs access to the raw lines to show you diagnostics
08:44:30 <fizbin> And the error message has those strings in it somewhere.
08:44:39 <kuribas> edwardk: Ah, I see.
08:44:52 <merijn> fizbin: As a result "Node (Node (Empty 'a') (Empty 'b')) (Node (Empty 'c') (Empty 'd'))" will produce a type error that "Succ (Succ (Succ (Succ Zero)))" is not smaller than Succ (Succ (Succ Zero))
08:44:53 <edwardk> typically you'd just write the lexer in trifecta as a set of combinators and use them as a substrate
08:44:57 <merijn> fizbin: Right
08:45:06 <edwardk> which is the most common habit in parsec anyways
08:45:15 <merijn> fizbin: You could just as easily write "(Int ~ Char)" instead, but the error would be much harder to understand ;)
08:45:45 <merijn> Note that this code only works in 7.8 and later
08:46:13 <merijn> fizbin: And you may want to read "Fun with Type Functions" to understand how to use type families, but it's really cool stuff :)
08:46:39 * hackagebot hlint 1.8.59 - Source code suggestions  http://hackage.haskell.org/package/hlint-1.8.59 (NeilMitchell)
08:46:50 <merijn> (And quite powerful, as you can see)
08:46:56 <fizbin> Yeah. I'm working in 7.4 at the moment, but may be able to talk my team into 7.8 within the next few months.
08:46:58 <michaelt> dcoutts: how dangerous is the Put a type in Data.ByteString.Builder.Internal ? I wanted to use hPut and the commented out putLiftIO
08:47:00 <augur> merijn: mm... i need something with more clear examples
08:47:49 <merijn> augur: More clear examples of WHY you want it, of examples how to reason about it?
08:48:12 <augur> examples of what you want to use it to describe, because of the descriptive elegance it affords
08:48:19 <supki> edwardk: did you mean s/lens/trifecta/?
08:50:07 <merijn> augur: Well, conceptually, most games and videos are real time processes, right? Rendering a frame is just taking a sample of the real time process, the sample rate is determined by the time it takes you to render a frame (higher FPS == higher sample rate)
08:50:13 <edwardk> supki: yes
08:50:21 <merijn> augur: But you don't want game logic to depend on sample rate, you want it to follow real time
08:50:46 <merijn> augur: Right now people hard code logic to account for this
08:51:02 <merijn> augur: i.e. check the time difference between this frame and last frame and update based on that
08:51:10 <augur> having written game logic, i can say i've never had to do that
08:51:24 <merijn> augur: You've never had to compute time offset between frames?
08:51:29 <augur> no
08:51:32 <Mopman> http://hackage.haskell.org/package/hslua <- this is the package im trying to build, is it possible the ld is being called by something building the lua c stuff? i dont really understand how cabal works
08:51:39 <c_wraith> merijn: many games I play have game logic intentionally functioning in discrete intervals.  It may skip displaying some of them if rendering is too slow, but they have nothing to interpolate.
08:51:39 <merijn> augur: How did you stop render speed from affecting your games behaviour?
08:51:49 <merijn> c_wraith: Sure, but that's just a workaround
08:52:00 <c_wraith> merijn: it's not a workaround if it's fundamental to the game design.
08:52:06 <augur> that was handled by the framework, tho maybe i never ran into the relevant problems?
08:52:18 <merijn> augur: Right, this is something you do in the engine
08:52:21 <augur> i cant see a situation where its relevant, which is why i ask, i guess
08:52:39 <merijn> augur: So if you're using some high level framework and don't have to do the hard work you never see it I guess
08:52:51 <supki> edwardk: ok, couldn't make sense of making type signatures more complex
08:52:59 <augur> merijn: whats a situation where this issue arises?
08:53:12 <merijn> augur: I had to write a simple 3D engine for a graphics course, if you don't account for time between frames then your game will run faster on faster machines
08:53:29 <merijn> augur: And I don't mean faster in the sense of FPS, but like every object in the world moves/reacts/etc faster
08:53:34 <augur> sure
08:53:45 <merijn> augur: It's one of the reasons many of these old DOS games run superfast on modern machines
08:54:01 <augur> i guess i wouldntve thought to write a game engine where that would even be a possible problem
08:54:01 <edwardk> supki: i can't make sense of making the lens type signatures more complex either, or they'd already be complexified ;)
08:54:02 <merijn> Because the developers didn't properly adjust for sample rate
08:54:12 <augur> at least not for a physical modelling scenario
08:54:12 <c_wraith> merijn: to be precise..  Many 2d games with hand-drawn animations intentionally use discrete increments, because interpolating doesn't give you any benefit anyway.
08:54:32 <merijn> c_wraith: Obviously, but that's completely irrelevant to the point I'm trying to explain here
08:54:49 <merijn> c_wraith: Then you're just designing your game to avoid the situation that conal tries to tackle
08:55:24 <augur> merijn: i think i sort of see the problem tho
08:55:28 <c_wraith> merijn: it's just a totally different kind of game.  Sometimes you want continuous time, sometimes you want discrete time.  They do different things.
08:55:42 <merijn> augur: conal's point is, why not describe a process (game, video, whatever) as a continuous process over time, which evolves regardless of sample rate and then automagically scale to the sample rate
08:56:16 <augur> merijn: tell me if this is about right: modeling ballistic motion is boringly trivial, since you can write up some equations and calculate position at any moment of time, so sample rate is irrelevant, you just defer to the external world time
08:56:31 <merijn> c_wraith: Right, which is why I don't understand why you bring this up in an explanation of why you'd want FRP as the entire point of having FRP is moot if you're doing a discrete step game like chess or whatever
08:56:39 <merijn> augur: Right
08:57:02 <augur> merijn: but as soon as there are events, such as collisions, you cant do this, because the next frame might be after a collision, so something happened between frames
08:57:22 <merijn> augur: Right, FRP is an attempt to combine those two things in a composable framework
08:57:35 <augur> but if you only ever calculate on frame updates, you have to figure out how to handle the inter-frame events
08:57:36 <augur> hmm. ok.
08:57:40 <merijn> augur: Note that many libraries advertised as FRP do not meet conal's definition of FRP
08:58:10 <augur> yeah no thats fine. i wanted to get a precise picture of the problem, not the solution
08:58:27 <merijn> augur: So the basic components of FRP are behaviours and events
08:58:48 <merijn> augur: A behaviour is a time varying value, i.e. like your ballistic motion example
08:59:12 <merijn> It makes sense to say the value of a behaviour at time X is Y
09:00:03 <gorby> Is it necessary for the Haskell RTS to be written in C?  Could it be written in Haskell?
09:00:12 <merijn> Events are things why happen at some time X, they have a value and a time after which they will have happened
09:00:42 <merijn> gorby: Most of the haskell RTS is written in haskell, there are some parts written in Cmm (which is not C, but a very minimalist somewhat C like language)
09:00:50 <b___> Why is Void defined data Void = Void Void, and not data Void?
09:01:03 <merijn> b___: Empty data declarations are fairly new
09:01:17 <merijn> They weren't standard until Haskell2010
09:01:29 <b___> I see
09:01:30 <geekosaur> gorby: there is a bit of a bootstrapping issue in writing a runtime in code that requires that runtime
09:01:41 <fizruk> is there anywhere a list of known applicative applications?
09:01:54 <merijn> augur: You may way to check out the Push-Pull FRP paper, he described a semantic model for events and behaviours there which I found very useful
09:02:04 <merijn> augur: http://conal.net/papers/push-pull-frp/
09:02:19 <macron> gorby: actually there is an ICFP paper IIRC about modelling what the GHC RTS does in Haskell.
09:02:34 <gorby> geekosaur: Has Haskell's RTS been proven "safe"?
09:02:45 <c_wraith> b___: a proper definition should be newtype, not data.  data creates constructors, which mean there are actually values.
09:02:50 <augur> merijn: i dont need semantics, i just need a clean model of the problem domain, but i think i have that now, thank you
09:02:58 <geekosaur> also note that since we call into C libraries (directly invoking syscalls is very problematic especially on Linux where kernel changes happen relatively often and are hidden by glibc interfaces) we need a C "glue" layer anyway
09:03:02 <macron> merijn: I'm not sure it's fair to say most of RTS is written in Haskell. There's 30k lines of C in there...
09:03:05 <geekosaur> define "safe"
09:04:47 <merijn> macron: hmm, I think I was thinking of quite a bit of base too
09:05:14 <macron> merijn: that isn't what I'd call the RTS.
09:05:28 <gorby> geekosaur: How about, has Haskell's RTS been proven correct?
09:05:28 <macron> wc -l ~/src/ghc/rts/*.c
09:05:35 <macron>   36377 total
09:05:49 <macron> no .hs file in there.
09:05:58 <c_wraith> macron: it's a little more complicated than that, because there are multiple different runtimes
09:06:13 <merijn> macron: Well, all the threading/timeout stuff is in base, for example
09:06:40 <merijn> So is IO
09:07:13 <geekosaur> macron, they wouldn't be there, they
09:07:24 <geekosaur> d be in the Haskell modules part of the source code
09:08:43 <macron> merijn: sure, but the thread stuff in base would basically be defining the "standard library", on top of primitives, which themselves use facilities from the RTS.
09:09:19 <macron> IO is defined in the standard library (i.e. base) under this view.
09:09:49 <gorby> Doesn't it seem weird that Haskell's RTS is written in a procedural language instead of a functional one?  It gives me the jeebies when I put so much emphasis on functional programming to know that the code that's running my golden functions is procedural.
09:10:16 <macron> gorby: part of it, yes, but then so is your OS...
09:10:38 <geekosaur> ^ and this is exactly the problem
09:10:51 <mm42_> gorby: if the computer hardware and the OS would function on the lambda calculus and not on the turing machine model then yes, we would have a pure functional thing all the way down
09:10:52 <SaBer> gorby: computers (hardware) are procedural, so at some stage it just needs to go to that...
09:10:57 <geekosaur> you're fitting it into a different environment, you need an adaptor layer
09:11:38 <gorby> SaBer: Is it necessary for hardware to be procedural?
09:11:49 <merijn> SaBer: Says you
09:11:59 <merijn> SaBer: I have friends working on functional CPUs
09:12:12 <gorby> I actually don't know what that means, what is "functional hardware"?
09:12:27 <merijn> gorby: Optimised for functional languages, instead of for imperative languages
09:12:51 <macron> gorby: one of the great features of Haskell is that you can write so much in the standard library, in the language itself, rather than as primitives. e.g. Bool need not a primitive datatype, but can be defined within Haskell itself. So the RTS being comparatively small after all.
09:13:23 <merijn> gorby: Basically, imperative languages have a certain evaluation model and most hardware is optimised for that. So we write an imperative program for an imperative CPU that fakes behaving like hardware for a functional language
09:13:42 <merijn> gorby: Where as these guys are work on designing a CPU optimised for the optimisation model of functional languages
09:14:00 <gorby> So, theoretically, you could have hardware optimized for functional languages, and an OS written in a functional language, and in this case the translation layer for a functional lanugage to run on the computer wouldn't be necessary?
09:14:29 <geekosaur> in theory at least
09:15:13 <`^_^v> lisp machines already tried to do this
09:15:31 <`^_^v> i dont think anyone is still using them
09:15:43 <gorby> `^_^v: Did they not work?
09:16:03 <merijn> gorby: There are already haskell implementations running on bare metal
09:16:23 <`^_^v> they worked, they were just slower than general purpose hardware at running lisp
09:16:24 <merijn> gorby: Take a look at House (haskell bare metal on i386 for writing operating systems) and HaLVM (for running haskell programs in Xen)
09:17:32 <kuribas> merijn: How would a functional CPU work?  A chip is essentially a state machine...
09:17:55 <macron> gorby: there is also the Reduceron, mapping any Haskell program to a purpose-built circuit.
09:18:24 <macron> FPGA circuit I mean.
09:18:26 <geekosaur> there was also the attempt by Sun at running JVM bytecode in hardware
09:18:41 <merijn> kuribas: Lots of cache, since thunks require quite a bit of space, instruction set optimised for pattern matching dispatch and lazy evaluation
09:18:47 <geekosaur> I think someone actually got that working... 2 years ago. and it turned out to not have been worth the effort
09:18:57 <merijn> kuribas: Mind you, this is research in progress
09:19:11 <merijn> kuribas: "A chip is essentially a state machine" <- why?
09:19:35 <kuribas> merijn: because when you go to the metal, you have just transistors?
09:19:53 <merijn> How are transistors state machines?
09:19:58 <macron> geekosaur: there were a number of them. See eg http://en.wikipedia.org/wiki/Java_processor
09:20:02 <merijn> Transistors look like pure functions to me
09:20:06 <merijn> Inputs go in, outputs come out
09:20:49 <kuribas> good point...
09:21:09 <macron> cpus are already pretty functional actually. The only thing non-functional about them is registers.
09:22:38 <merijn> kuribas: That's actually why they're working on this, many people basically assume that the current CPU model we have is the one true model. They're experimenting with what kind of designs would be good (lazy) functional languages
09:23:34 <kuribas> It's hard to compete with modern cpu's, since they can produce in large quantities, and have a lot of research accumulated.
09:24:01 <c_wraith> Ok.  Since cabal sandboxes were introduced, I no longer prefer to have cabal always build profiling libraries.
09:24:01 <kuribas> merijn: Is there any documentation about their research?
09:25:36 <kuribas> Isn't converting from a c to a haskell string slow (for example withCWString), since it has to turn a c string into a list?
09:25:45 <merijn> kuribas: I'll have to check, it's been a while since I talked to these guys. They're at Twente
09:25:48 <merijn> kuribas: Yes
09:25:58 <merijn> You don't wanna do that :)
09:26:26 <kuribas> merijn: I have no choice, since I need to interface with wxwidgets.
09:26:50 <kuribas> Say reading the contents of a text control, parsing it, and then doing syntax highlighting.
09:27:19 <ski> perhaps it would be nicer to not do it strictly
09:27:49 <kuribas> It would have to be done for every change in the text control.
09:28:51 <merijn> kuribas: Why do you to do that? Can't you convert to/from Text or something instead?
09:30:20 <kuribas> merijn: wtextCtrlGetValue from wxHaskell returns a string, and uses withCWString internally.
09:31:27 <merijn> Ah, that's unfortunate
09:33:18 <kuribas> Or I could write my own version using the haskell FFI.
09:33:49 <kuribas> Most of the API in wxhaskell is generated automatically.
09:36:45 * hackagebot ixmonad 0.15 - Indexed monads library  http://hackage.haskell.org/package/ixmonad-0.15 (DominicOrchard)
09:37:12 <kuribas> Well, I shouldn't do premature optimization.
09:37:19 <kuribas> Maybe it turns out fine.
09:37:59 <mm42_> usually the gui functions don't need optimization
09:38:08 <mm42_> i mean those that display/get a string from the user
09:41:51 <c_wraith> edwardk: Should mtl have all the RWS/RWST subpairs as types?  It's a ton of boilerplate to write out individual ones when you want one.
09:42:31 <klrr__> anyone know what ExitFailure 1 means when installing haskell-src-exts? is there some non-haskell dependecy i need?
09:42:35 <edwardk> c_wraith: frankly that is a sale you'd need to make to ross paterson, as transformers would need to add them before mtl can do anything
09:42:42 <merijn> klrr__: Did you run with -v 3?
09:42:54 <edwardk> c_wraith: i think the current point in the design space is pretty good
09:43:07 <merijn> c_wraith: I personally just use RWS with () as the unused parameter
09:43:17 <edwardk> but if transformers added them i'd have to follow
09:43:19 <klrr__> merijn: dont think so, i just did "cabal install ghc-mod" and haskell-src-exts was one of its dependency
09:43:20 <c_wraith> merijn: that's very bad when the W parameter is unused
09:43:31 <c_wraith> merijn: you end up with an instant space leak
09:43:32 <geekosaur> klrr__, "ExitFailure n" means exactly "something went wromng", it doesn't say what, that information is somewhere before the ExitFailure
09:43:43 <klrr__> okey
09:43:49 <klrr__> gonna look at the output again
09:43:57 <merijn> klrr__: Right, try doing "cabal install haskell-src-exts -v3"
09:44:23 <c_wraith> edwardk: this is the second time in two weeks I've found myself working on code for one of the subpairs, so I figured it was time to ask. :)
09:44:30 * geekosaur wishes cabal would only print that if it's something other than 1; in fact possibly 127 is the only interesting value
09:45:16 <augur> merijn: hm. collision detection is an especially tricky problem that seems like it has very custom solutions
09:45:19 <bergey> klrr__: ghc 7.8.1?
09:45:33 <klrr__> 7.6.3
09:45:45 <klrr__> merijn: okey, gonna try that
09:46:26 <edwardk> c_wraith: i usually advocate just writing your monad directly and adding instances for the mtl classes, the existing transformers definitions aren't INLINE'd, so what you get is code that is needessly non-performant.
09:47:48 <klrr__> hmm, it seems like its hlint that fails
09:48:08 <edwardk> klrr__: color me unsurprised ;)
09:48:16 <absence> will 7.8 have an option to use the applicative-monad-proposal, or just warnings about missing instances?
09:48:32 <edwardk> absence: 7.8 just warns, 7.10 will enforce
09:49:18 <absence> aw
09:50:22 <um1b0zu> is this a decent place to discuss lambda calculus?
09:50:27 <klrr__> eh, thanks for help the reason was a stupid mistake by me: i hadent installed happy, it probably was shown in original error but i missed it
09:50:56 <um1b0zu> I'm having trouble understanding normal, weak head, and head forms
09:52:01 <nolrai66> So why is "(:+:) :: a :<~> b -> c :<~> d -> (a :+ c) :<~> (b :+ d)" a valid line of GADT, but it complains about "LNeg :: a :<~> b -> Neg b <~> Neg a"?
09:52:16 <Saizan> um1b0zu: normal form is when there are no redexes anymore, weak head when there can only be redexes under lambdas, and head is a bit strange
09:52:27 <pranz> um1b0zu: weak-head normal form is just the constructor
09:52:30 <nolrai66> s/of GADT/of a GADT declaration/
09:52:38 <pranz> for Bool, the constructors are True and False
09:52:55 <pranz> for [], the constructor is (:) and the empty list
09:52:58 <nolrai66> Never mind.
09:53:03 <Saizan> oh, yeah, if you have datatypes it's not just lambdas, sorry :)
09:53:09 <nolrai66> I was missing a ":" :P
09:53:15 <edwardk> nolrai66: what is the construct rbeing efined in the latter?
09:53:16 <pranz> so [1+1,2+2] computed to WHNF is _:_
09:53:24 <um1b0zu> Saizan its for untyped right now
09:53:27 <pranz> because it sees that there is at least one element
09:53:51 <edwardk> er type being constructed. ah yeah the missing : in <~>
09:53:53 <um1b0zu> first can an expression be neither normal, weak, or head?
09:54:13 <Saizan> um1b0zu: sure, (\x -> x) (\x -> x) is none of those
09:54:30 <nolrai66> Hmm. I guess <~> was getting parsed as a type variable, and just being auto-intruduced? and thats why it didn't complain about it not being in scope?
09:55:15 <um1b0zu> Saizan thats exactly the type of example I was looking at that was confusing me.
09:55:16 <Saizan> um1b0zu: (\y -> (\x -> x) (\x -> x)) is weak head, but not head
09:55:57 <triliyn> nolrai66: type variables that aren't in scope are automatically universally quantified
09:55:59 <mniip> So, if in context of domain theory, lowest fixpoint of id is ⊥
09:56:08 <mniip> then what would be the lowest fixpoint of join(.)
09:56:25 <Saizan> um1b0zu: what's confusing about it?
09:56:29 <um1b0zu> my book was saying (\x -> xx)(\x->xx) was neither normal nor weak, but because of inclusion I thought... well then it can't be head then, but it didn't explicitly say there can be expressions that aren't head, weak or normal
09:57:29 <Saizan> um1b0zu: ah, i see
09:57:34 <um1b0zu> wait Saizan for that example why is \y -> e e weak head but not head?
09:57:37 <mniip> fixing that function produces something else besides the infinite loop
09:57:54 <nolrai66> triliyn: for some reason I didn't expect that for operators, not sure why.
09:57:55 <um1b0zu> oh nvm
09:58:01 <Saizan> um1b0zu: because it has a redex just under the lambda
09:58:02 <um1b0zu> cause its a straight abstraction
09:58:12 <um1b0zu> huh?
09:59:32 <Saizan> t is head iff (t is a stuck application) or (t = \x -> e and e is head)
09:59:34 <um1b0zu> yeah this book is really bad lol it says a normal is one with no redexes, then a head is one with \x_1 -> ... \x_n -> ye_1...e_m
10:00:03 <um1b0zu> but that expression is a lambda abstraction unless I'm not understanding parsing rules correctly
10:00:07 <[1]grant> I have a handle that is getting data from a socket. What's the best way to get N chars from the handle?
10:00:24 <Saizan> um1b0zu: you need to pay attention to the ye_1...e_m part
10:00:39 <Saizan> um1b0zu: that's an application of a variable to some expressions
10:00:59 <um1b0zu> or... expressions to a variable?
10:01:04 <Saizan> um1b0zu: but (\x -> x) (\x -> x) is not
10:01:25 <Saizan> um1b0zu: well, yeah, the expressions are the arguments, the variable is the function
10:02:02 <klrr__> pranz: is a WHNF basically a partial expression? or am i missing something
10:02:22 <Saizan> um1b0zu: so, e.g., \y -> y (\x -> x) would be head
10:02:51 <um1b0zu> that's fine but how can a form of \x_1 -> y e_1... e_m not be weak when it explicitly says weak head is all expressions which are lambda abstractions?
10:03:24 <pranz> klrr__: it's an evaluation form, any expression in haskell is lazy by default as you know
10:03:40 <Saizan> um1b0zu: sure, that's weak head too
10:03:52 <Saizan> um1b0zu: anything head is also weak head
10:03:56 <pranz> klrr__: and depending on what you want to do with the value, you may want to evaluate it to a simpler form than the full form
10:04:17 <Saizan> um1b0zu: you have a chain of implications: t is normal -> t is head -> t is weak head
10:04:18 <mm_freak> hi there =)
10:04:26 <pranz> klrr__: if you just want to know if a list is empty or not, you don't need to see what the first value is, but you want to know if there _is_ a first value
10:04:34 <JagaJaga> Hello! Can you tell me how to parse json with arrays using aeson? Can't find examples or smth like that
10:04:53 <mm_freak> emacs question:  is there any consistency in what directory inferior-haskell spawns the interpreter process in?
10:05:53 <pranz> klrr__: this is great, if you haven't already read it: http://chimera.labs.oreilly.com/books/1230000000929/ch02.html
10:06:21 <um1b0zu> I just have to read it more Saizan
10:06:22 <pranz> tells you all you need to know how haskell evaluation works
10:06:26 <klrr__> pranz: okey, thanks for the link
10:08:00 <MarioPastorelli> hi guys
10:08:35 <nolrai66> Wait can I now not use operators as type variables in class declarations?
10:08:59 <awestroke> nolrai66: you mean infix functions?
10:09:17 <bergmark> nolrai66: it was removed in 7.6 iirc
10:09:18 <augur> merijn: what are other canonical examples of this issue, but that don't involve physical simulation?
10:09:26 <nolrai66> Yeah. Like "Class Cat (~>) "
10:09:29 <nolrai66> errr.
10:09:51 <bergmark> so now we have `arr` everywhere in our code :-(
10:10:20 <nolrai66> That sucks. Do you have a link to the ticket/something about it?
10:10:35 <MarioPastorelli> I'm having a problem with ghci and I really don't know where to start to debug it
10:11:18 <klrr__> what does "boxed" mean?
10:11:32 <um1b0zu> Saizan I mean it seems like a bad example, but there's an example saying \x -> (    x (   (\x->xx)(\x->xx)   )     ) is in head normal but not normal. But clearly its by definition a weak since it is a lambda abstraction
10:11:35 <MarioPastorelli> to put it simple, when I run a certain expression in ghci I get a "GHCi runtime linker: fatal error: I found a duplicate definition for symbol" error
10:11:49 * hackagebot ixmonad 0.2 - Indexed monads library  http://hackage.haskell.org/package/ixmonad-0.2 (DominicOrchard)
10:11:59 <bergmark> nolrai66: it's in the changelog http://www.haskell.org/ghc/docs/7.6.1/html/users_guide/release-7-6-1.html
10:12:03 <um1b0zu> so my issue is how can it follow the inclusion when weaks are clearly head?
10:12:18 <Saizan> um1b0zu: not every weak head is head
10:12:18 <mm_freak> i prefer `cat` over `arr`
10:12:59 <Saizan> um1b0zu: \y -> (\x -> x) (\x -> x) is weak head, but not head
10:13:04 <mm_freak> something with more than 5 laws scares me…  and arrows have like more than 20 laws =)
10:13:09 <Saizan> (and so it's not normal either)
10:13:35 <um1b0zu> oh ok. I think I'm just not understanding the direction of the inclusion
10:13:46 <klrr__> @src seq
10:13:46 <lambdabot> Source not found. Listen, broccoli brains, I don't have time to listen to this trash.
10:14:05 <bergmark> nolrai66: it was a proposed at some point but i didn't see it until it was too late
10:14:12 <geekosaur> seq can't be defined in haskell (sadly)
10:14:14 <napping> Is there any way to override lexme in a Parsec token parser?
10:14:17 <Saizan> um1b0zu: normal _subset_ head;  head _subset_ weak head
10:15:28 <nolrai66> bergmark: what do I have to do to registrar that it is a terrible.  I mean I can understand not wanting to change back..but ugh. Makes a number of things way more ugly.
10:15:39 <um1b0zu> I think I got it. I'll stare at some examples some more Saizan.
10:16:55 <Saizan> um1b0zu: cheers
10:17:50 <um1b0zu> thanks Saizan
10:18:24 <napping> The language needs to keep Java-doc style /** ... */ documentation comments, but I'd like other /* ... */ comments to be whitespace
10:18:58 <bergmark> nolrai66: i'm not sure what the best way to do it is, maybe ask in haskell-cafe and see if more people would like to revert it
10:19:07 <napping> unfortunately makeTokenParser doesn't use any kind of open recursion
10:21:13 <absence> is there something like the either function for bifunctors?
10:22:57 <ski> @type (|||)
10:22:58 <lambdabot> ArrowChoice a => a b d -> a c d -> a (Either b c) d
10:23:05 <ski> hm
10:23:47 <klrr__> could someone explain the statement written here under the figure http://chimera.labs.oreilly.com/books/1230000000929/ch02.html#fig_rpar_rpar , " The rest of the program will continue to execute while f x and f y are being evaluated in parallel." what happens when eventually the value is needed, then it will wait till the evaluation in parrallel is done right?
10:24:07 <bennofs> absence: Bifunctors give you no way to "eliminate" the functor, you can only map (just like Functor doesn't allow you to write f a -> a)
10:24:42 <ski> coproducts would give you ways to eliminate
10:24:57 <mm_freak> absence: Bifoldable
10:24:57 <edwardk> For anyone who wants to register to mentor for gsoc for haskell.org, here's the URL to register: http://www.google-melange.com/gsoc/connection/start/user/google/gsoc2014/haskell
10:25:17 <kuribas> klrr__: yes
10:25:25 <klrr__> kuribas: okey, thanks for confirming
10:25:48 <absence> thanks! i'll investigate those
10:28:13 <edwardk> registering mostly brings you into the loop for voting on proposals, and is an offer to mentor / backup mentor if there is an appropriate topic, not an firm commitment
10:51:55 * hackagebot happstack-authenticate 0.10.12 - Happstack Authentication Library  http://hackage.haskell.org/package/happstack-authenticate-0.10.12 (JeremyShaw)
10:51:57 * hackagebot clckwrks 0.22.1 - A secure, reliable content management system (CMS) and blogging platform  http://hackage.haskell.org/package/clckwrks-0.22.1 (JeremyShaw)
10:56:55 * hackagebot snap-core 0.9.6.1 - Snap: A Haskell Web Framework (core interfaces and types)  http://hackage.haskell.org/package/snap-core-0.9.6.1 (GregoryCollins)
10:56:57 * hackagebot clckwrks-plugin-bugs 0.7.2 - bug tracking plugin for clckwrks  http://hackage.haskell.org/package/clckwrks-plugin-bugs-0.7.2 (JeremyShaw)
10:56:59 * hackagebot clckwrks-plugin-media 0.6.7 - media plugin for clckwrks  http://hackage.haskell.org/package/clckwrks-plugin-media-0.6.7 (JeremyShaw)
11:02:30 <erisco> how does one create a synonym for a long list of constraints?
11:03:43 <mwc> With CApiFFI, foreign functions returning a const char * are wrapped as IO CString (= IO (Ptr CChar)), when compiling with -Wall this leads to warnings about the conversion in the generated code discarding the const qualifier
11:04:21 <mwc> Since I want to keep the code -Wall clean, I worked around it by creating cbits wrappers that do the cast in C and return char *, is there a simpler way?
11:06:19 <pavonia> erisco: type Foo a = (Bar a, Baz a, ...)
11:06:27 <erisco> ah thanks
11:07:34 <amalloy> pavonia: isn't there some language option you have to enable for that?
11:07:53 <pavonia> Yes, ConstaintKinds I think
11:08:17 <thoughtpolice> ConstraintKinds or you can use UndecideableInstances to achieve the same
11:27:22 <Philippa> evenin'
11:27:34 * Philippa apologises to Twey for infodumping too much about Street Fighter after that mind-reading talk!
11:27:49 <Philippa> (also, uh, maybe that corner of us the table last night)
11:43:22 <Noldorin> can someone explain the applicative functor axioms to me please?
11:43:29 <d3lxa> anyone has an idea about this: 2:[i | i <- [3,5..], not $ any ((==) 0 . (mod i)) $ takeWhile (i<) primes] ??? why isnt it working, thx
11:45:08 <Noldorin> d3lxa, do you have a definition (or at least type signature) of primes function?
11:45:30 <d3lxa> Noldorin: it's a list, why a function?
11:45:46 <Noldorin> d3lxa, eh sorry, it is yes...
11:45:49 <bennofs> > let primes = 2:[i | i <- [3,5..], not $ any ((==) 0 . (mod i)) $ takeWhile (i<) primes] in primes
11:45:51 <lambdabot>  [2,3,5,7,9,11,13,15,17,19,21,23,25,27,29,31,33,35,37,39,41,43,45,47,49,51,53...
11:46:16 <asterblaster> hello, where can I find accelerate-cuda devs?
11:46:18 <bennofs> > let primes = 2:[i | i <- [3,5..], not $ any ((==) 0 . (flip mod i)) $ takeWhile (i<) primes] in primes
11:46:19 <lambdabot>  [2,3,5,7,9,11,13,15,17,19,21,23,25,27,29,31,33,35,37,39,41,43,45,47,49,51,53...
11:46:32 <asterblaster> I'm having weird issue and I don't even know how to debug it
11:47:07 <Noldorin> d3lxa, there you go, works just fine :P
11:47:21 <bennofs> Noldorin: except that those are not all primes
11:47:32 <Noldorin> bennofs, oops, I din't look closely heh
11:47:35 <amalloy> well, there are no false negatives
11:47:36 <gamegoblin> What's the best way to read N chars from a handle? Not (take n) (hGetContents ) because that partially closes the handle.
11:50:12 <joelteon> replicateM n hGetChar
11:51:00 <gamegoblin> joelteon: how will that behave if the handle is closed or eof before reading n?
11:51:11 <joelteon> it'll throw an exception
11:51:47 <gamegoblin> Any way to just get the contents it does have? Similar to take n.
11:51:59 <geekosaur> not from System.IO
11:52:06 <geekosaur> ByteString has hGetSome
11:53:13 <gamegoblin> I was doing it by pulling off one char at a time and using special cases of hClose and hIsEOF but that's ludicrously slow
11:53:24 <joelteon> it sure is
11:53:33 <byorgey> Noldorin: (re: applicative laws) explain them in what sense?
11:54:20 <schell> does anyone know of a haskell implementation of server-side oauth2?
11:54:29 <mm42_> yesod had it afaik
11:54:30 <gamegoblin> I'll look in to byte stringing everything
11:54:45 <schell> mm42_: cool - thanks for the starting point
11:55:14 <mm42_> I seem to remember reading about it two years ago, cannot remember if it is server-side or not
11:55:21 <mm42_> I'm on mobile otherwise I'd check first
11:56:00 <Noldorin> byorgey, well what they mean in a more intuitive way, I guess
11:57:19 <Noldorin> d3lxa, well first thing that's wrong is your (i <)
11:57:44 <asterblaster> eh this is what you get when you use gentoo..
11:57:57 <schell> mm42_: it looks like it uses a third party provider
11:57:58 <byorgey> Noldorin: have you read the corresponding section of the Typeclassopedia?  http://www.haskell.org/haskellwiki/Typeclassopedia#Laws_2
11:57:59 <Noldorin> d3lxa, the takeWhiel immediately terminates, since that condition is false from the start
11:58:06 <asterblaster> apparently there is a bug in newest nvidia/nvidia-cuda package
11:58:11 <byorgey> Noldorin: see also http://www.haskell.org/haskellwiki/Typeclassopedia#Alternative_formulation
11:58:15 <Noldorin> byorgey, ah no. was reading LYAH. will have a look at that now thanks
11:58:23 <schell> possibly because it's based on hoauth2, which is client-only afaik
11:58:27 <byorgey> it explicitly gives some intuition
11:59:03 <Noldorin> byorgey, yeah, looks decent, thanks
12:00:36 <d3lxa> Noldorin: yeah you are right, then I need to counter the evaluation of the list with takeWhile, is there a similar but better way?
12:02:31 <Twey> Philippa: Haha, no problem
12:03:59 <Twey> Philippa: I have trouble filtering out background noise, so I didn't hear most of the corner anyway… but I'm sure (I hope?) it was nothing you need to apologize for :þ
12:05:26 <Noldorin> d3lxa, I think that to stop the infinite recursion you need to make primes a function that takes an upper bound...
12:05:26 <Noldorin> hmm
12:05:36 <Philippa> Twey: *nod* yeah, I have similar - was more the fact we'd turned into one like that than anything else
12:05:59 <Twey> Ah, it's fine
12:06:50 <djahandarie> I failed to understand the difference between nominal, representational, and phantom from Richard's email. Does anyone have another way of explaining it?
12:08:07 <Noldorin> d3lxa, something like let primes ub = 2 : [i | i <- [3, 5 .. ub], not $ any ((0==) . (mod i)) $ primes (i - 1)] in primes 100
12:08:18 <Noldorin> d3lxa, though it's very inefficient because there's no memoisation...
12:08:25 <Twey> djahandarie: What email is that?
12:11:00 <djahandarie> Twey, http://www.haskell.org/pipermail/libraries/2013-November/021707.html
12:12:02 <d3lxa> Noldorin: hey thx!
12:12:25 <Noldorin> sure :)
12:16:35 <Twey> djahandarie: So, a nominal equality means that the two types are written the same way — Foo Bar ≡_nom Foo Bar
12:17:30 <Twey> djahandarie: This is stronger than any of the other equalities because of determinism/referential transparency — the expression ‘Foo Bar’ is always going to produce the same result as another ‘Foo Bar’
12:18:37 <Twey> djahandarie: Referential equality is about how the value is represented at runtime.  If you have a newtype Foo = Foo Bar, then the runtime representation of a Foo is always equal to the runtime representation of a Bar — you can safely convert between them using unsafeCoerce
12:19:33 <Twey> djahandarie: Representation equality** sorry
12:19:52 <artyomkazak> Is there any solution for imprecise matching of Unicode? Say, I want ‘9’ to match any variant of 9 (circled nine, superscript nine, etc.), ‘a’ should match any a's (uppercase, lowercase, with diacritics), but ‘ä’ should only match ‘ä’ and ‘Ä’. (I hope I at least made myself understandable...)
12:20:50 <Twey> djahandarie: Phantom equality is a different way of getting representational equality.  If you have a value of type Foo Bar and a value of type Foo Baz, they aren't nominally equal; *but*, if the parameter to Foo is a phantom type parameter, you know that it can't possibly make a difference to the representation of the type at runtime, so they still have the same runtime representation (so you can safely
12:20:52 <Twey> convert between them with unsafeCoerce)
12:22:56 <ski> Twey : i suppose no covariance/contravariance is considered here ..
12:23:44 <Twey> Doesn't seem to be
12:24:00 <S3thc0n> Hello, I've been diving into FP lately and have stumbled over continuations today. I know closures since quite a while but have been wondering what they are good for in purely functional code. Now I've read the wiki (both -pedia and Haskell) about CPS, but I cannot see where the big advantage of (first arg second) over (second (first arg)) is. Anyone willing to enlighten me?
12:24:35 <Twey> S3thc0n: The advantage is that first doesn't necessarily have to call second
12:24:57 <Twey> S3thc0n: For example, (first arg normalReturn exceptionHandler) is one way to implement exceptions
12:25:39 <byorgey> artyomkazak: I don't think Unicode has any notion of 'these things are all 9s'
12:25:39 <Twey> S3thc0n: If first succeeds at its task, it calls normalReturn with its return value; if it fails, it calls exceptionHandler with some exception value indicating what went wrong
12:26:25 <djahandarie> Twey, I guess I just don't really understand what it means for the 'k' in Map k v to be nominal, and the 'v' in it to representational.
12:26:32 <S3thc0n> So it is a way to contain the logic, kind of? So I do not have to write another function checking for occurance of an exception and calling that exceptionHandler, which uses first's return as argument?
12:27:04 <Twey> S3thc0n: Secondly, first doesn't have to call second *now*.  So it gives you things like callbacks, where the continuation isn't necessarily called directly, but at some unspecified time in the future.  That gives you control over the evaluation ordering where the language doesn't guarantee it, too.
12:27:24 * mwc finally checks cabal clean --help, learns about -s, and eliminates half my Ctrl-R usage
12:27:51 <Twey> S3thc0n: And thirdly, since the continuation represents the whole of the rest of the program and will ‘never return’, you can use it inside ‘first’ to short-circuit evaluation and jump ‘out’ of the function (like C's ‘return’).
12:28:13 <ski> S3thc0n : .. or like `longjmp' in C
12:28:19 <Twey> Right
12:28:33 <S3thc0n> Twey: I see what you mean.
12:29:08 <ski> S3thc0n : you can also do even more fun/bizarre things using continuations. such as making what appears to be a function call return twice, even though it was only called once
12:29:31 <Twey> Oh yes, fourthly: you can call the continuation more than once
12:29:46 <Twey> Basically, it gives you a more generalized notion of ‘returning a value’
12:30:18 * ski . o O ( "You can enter a room once, and yet leave it twice" -- Peter Landin )
12:30:24 <S3thc0n> Sounds weird. Why exactly would I call it more than once? And more importantly, hwo would that be organized?
12:30:37 <geekosaur> djahandarie, as I understand it: Map requires that the exact same instances be used on its key or parts of the map become inaccessible or broken, hence k requires nominal. v, Map does not care about, representational is fine
12:31:25 <geekosaur> ("nominal" can ba taken as "has the same instance definitions", "representational" as "has the same internal representation")
12:31:48 <S3thc0n> Twey: So I understand quite well what they are I think, but they seem a lot more useful in languages which are not purely functional and might not have types (more exceptions / error handling).
12:31:53 <geekosaur> And Map breaks very badly if you swap instance definitions on it (this is why there are no local instances)
12:32:02 <S3thc0n> Oh, and which are not lazy.
12:32:06 <Twey> djahandarie: The interesting question this post addresses is whether we can safely no-op coerce (unsafeCoerce) a value of one type to the other.  If Bar has the same representation (is representationally equal) to Baz, then it's safe to treat a Map Foo Bar as if it were a Map Foo Baz (Map Foo Bar and Map Foo Baz are representationally equal).  But for a Map, the Ord instance of the Foo type matters (it
12:32:08 <Twey> determines the order in which the elements will appear inside the map), so unless Foo and Quux have the same Ord instance, a valid Map Foo Bar is *not* necessarily convertible to a valid Map Quux Bar
12:32:14 <Fuuzetsu> Is there a CPP symbol for the base package version? I need to patch something that still imports unsafePerformIO and I'd rather do it using base version rather than GHC version
12:32:32 <ski> S3thc0n : consider something like `collect (let val z = pick [0 .. 9]; val y = pick [0 .. z]; val x = pick [0 .. x] in ensure (x^2 + y^2 == z^2); (x,y,z) end)'
12:32:44 <ski> S3thc0n : which would return a list of pythagorean triples
12:32:47 <geekosaur> Fuuzetsu: MIN_VERSION_base etc. should work?
12:33:27 <ski> S3thc0n : here, `pick [0 .. 9]' first returns `0' -- later, the code will implicitly jump back inside the same `pick' call, but this time return `1', and so on
12:33:58 <ski> S3thc0n : btw, this is using some bastarzied cross syntax between Haskell and SML
12:34:03 <Twey> S3thc0n: Having more exception types doesn't require an untyped language.  Haskell has a typeclass for exception types, so you can add your own; ML has an open sum type
12:34:36 <Fuuzetsu> geekosaur: and what is it I'm comparing to? What's the number? Say I want to check whether I'm using 4.7 or newer.
12:35:09 <ski> S3thc0n : anyway, both Scheme and SML/NJ has support for first-class continuations. Scheme is dynamically typed, while SML is statically typed
12:35:27 <geekosaur> lemme dig it up, I think it's something like #if MIN_VERSION_base(4, 7, 0) or something like that
12:35:44 <Twey> S3thc0n: I don't think there are any benefits to continuations in an impure, strict, or untyped language that you don't get in a pure, non-strict, or typed language.  But there are several things you can do with continuations in pure or non-strict languages that you would otherwise require impurity or strictness to do.
12:35:50 <ski> S3thc0n : you might be interested in papers by Hayo Thielecke, Andrzej Filinski, Olivier Danvy and more, about contiuations
12:35:59 <Twey> S3thc0n: Plus some benefits that are shared between impure and pure languages equally
12:36:24 <geekosaur> yes, that's it
12:37:03 <Twey> S3thc0n: There are also some things, like ski's Pythagorean triples example, that are possible in both but only really make good sense in a pure language (where order of execution would otherwise potentially matter).
12:37:11 <Fuuzetsu> geekosaur: thanks
12:37:12 <geekosaur> Fuuzetsu, http://www.haskell.org/cabal/users-guide/developing-packages.html#conditional-compilation
12:37:38 <S3thc0n> Okay, I'll read up more on them. But I am tempted to say that using CPS EVERYWHERE is not totally necessary, but very useful for alternate control flow.
12:37:42 <ski> Twey : heh, i'd say that monadic-reflection based example *doesn't* make sense in a pure language ;)
12:37:56 <Fuuzetsu> I hope Hugs supports the CPP pragrma
12:37:57 <Fuuzetsu> pragma*
12:38:05 <ski> @google FunWithLinearImplicitParameters
12:38:05 <lambdabot> http://www.haskell.org/haskellwiki/The_Monad.Reader/Issue2/FunWithLinearImplicitParameters
12:38:06 <lambdabot> Title: The Monad.Reader/Issue2/FunWithLinearImplicitParameters - HaskellWiki
12:38:09 <S3thc0n> Thank you two for the help, I'll return later if questions persist ;)
12:38:19 <ski> describes TheHunter having fun with monadic reflection in Haskell
12:38:21 <Twey> S3thc0n: Also, if you're not set on having a single exceptionHandler continuation, you can get ‘more exception types’ just by passing more handlers, and effectively switch on the type of the exception.
12:38:33 <ski> S3thc0n : do you know any Scheme or SML ?
12:38:50 <Twey> S3thc0n: Yes, nobody really recommends you use CPS everywhere.  Except Node.js.
12:39:13 <ski> .. at least not explicit CPS
12:39:30 <ski> some Scheme compilers (and i think also SML/NJ) use CPS internally
12:39:44 <ski> (there are also other approaches to implementing first-class continuations)
12:39:50 <S3thc0n> Twey: :D True. ski: No sorry, I'm really new to all of FP, entered via Clojure (so I can read LISP a bit) and only dipped into Haskell a toe.
12:40:33 <Twey> ski: This is *weird*.  :þ
12:40:50 <xintron> I'm playing around with reading procfs, is there any reason to why one should use ByteString instead of Text for the data values?
12:40:51 <ski> S3thc0n : you might be interested in looking at "Continuations and Continuation Passing Style" <http://library.readscheme.org/page6.html>
12:41:02 <ski> Twey : TheHunter's trick is weird, yes ;)
12:41:05 <Twey> xintron: Because they might not be text
12:41:37 <xintron> Twey, I mean for stuff like comm etc (strings basically)
12:41:44 <S3thc0n> That is certainly enough to read. However, I have to go now, being called for dinner. I'll look at it in more detail later, thank you two for now! :D
12:42:11 <ski> S3thc0n : i can also dig up some more specific papers you might be interested in looking at
12:42:16 <merijn_> xintron: Text assumes it's unicode
12:42:29 <ski> S3thc0n : perhaps ask me about it later
12:42:30 <merijn_> xintron: linux filesystems generally just use bytes, not unicode
12:42:44 <S3thc0n> ski: That'd be very kind, I'll do that.
12:42:45 <merijn_> xintron: Therefore using Text for interacting with a filesystem like procfs makes no sense
12:42:53 <S3thc0n> See you later.
12:43:01 <xintron> merijn_, Great, thanks
12:44:03 <Twey> xintron: Text is supposed to be for *text*, i.e. strings of words in a human language, represented as Unicode.  If your data fits that profile, by all means go ahead and use Text.  But something from procfs is probably not text.
12:44:07 <skypers> hurh
12:44:18 <skypers> I have a qualified imported module
12:44:24 <skypers> (with typclasses)
12:44:39 <skypers> I wont to instantiate then, but I got the error     Qualified name in binding position:
12:44:43 <skypers> any idea how to solve that?
12:44:44 <Twey> (Mind you, it *could* be, depending on what you're reading.  The file path definitely isn't, though.)
12:45:10 <merijn> Twey: procfs returns kernel info, no? Pretty sure they don't output unicode in the kernel :p
12:45:13 <Twey> skypers: What do you mean by ‘instantiate then’?
12:45:21 <ski> skypers : i don't think you have to qualify the methods in the definiendums in instances ?
12:45:22 <Twey> merijn: Well, they *could*.
12:45:30 <skypers> them* Twey
12:45:38 <joelteon> Anybody know how to get LoggingT not to output two newlines after every message?
12:45:43 <skypers> ski: if I don’t, I get that:
12:45:51 <skypers>     Not in scope: `$='
12:45:51 <skypers>     Perhaps you meant one of these:
12:45:51 <skypers>       `GL.$=' (imported from Graphics.Rendering.Sky.GL.Shader),
12:45:54 <skypers> :(
12:46:11 <Twey> merijn: Particularly, if someone's fed in some UTF-8 data, it might come out via procfs
12:46:39 * Twey . o O ( … definiendums? … )
12:46:43 <merijn> Twey: Right, but then they fed it in as bytes and the only sane way to get it out is bytes
12:46:45 <ski> hm, maybe you need to import (unqualified ?) the operations of a class, to be able to provide definitions for them in instances
12:47:05 <Twey> merijn: Maybe you're the one who fed it in
12:47:06 <merijn> ski: Unless you imported the class operations somewhere, they are imported qualified too
12:47:10 <Twey> … though I guess that's a bit pointless
12:47:12 <merijn> eh
12:47:17 <merijn> s/ski/skypers
12:47:22 <ski> Twey : you know, `<definiendum> = <definiens>', "definiendum" is the thing to be defined, and "definiens" is what it is defined to be
12:47:52 <Twey> ski: It just seemed strange that you'd go to the extent of using ‘definiendum’ and then give it an English plural :þ
12:48:14 <ski> hm, i didn't think about it
12:48:26 <Twey> Definienda?
12:48:47 <skypers> ski: yeah I import them unqualified and change the other stuff around
12:48:50 <skypers> it should make it
12:49:15 <ski> Twey : looks like so, yes
12:49:34 <ski> (i was guessing so, but checked to make sure)
12:50:08 <ski> skypers : i suppose this is another argument to allowing local `import's
12:50:25 <skypers> local?
12:50:31 <skypers> what do you mean?
12:50:51 <ski>  like inside the `instance' declaration, e.g.
12:50:56 <ski> or in a `where' or `let'
12:51:09 <ski> or in a `local'-`in' construct, like in SML
12:53:29 <mildfate> Can anyone comment on current research being done on fpus?  functional processing units?
12:53:59 <Twey> mildfate: AFAIK the Reduceron was the last such project
12:54:13 <Philippa> mildfate: they float :p
12:54:22 <Zag> Yes... they float..
12:54:27 <mildfate> they all float
12:54:43 <Philippa> there was a Reduceron Mk2 project of some form that looked reasonable, I think Intel may've mined a trick or two from it
12:55:32 <Philippa> but I think I heard about that the last time Fun in the Afternoon did MSR@Cambridge
12:55:49 <Philippa> they'd got impressive results compared to the original Reduceron, though
12:57:02 <Twey> The Reduceron was already nothing to sneeze at, as I recall
12:57:27 <Twey> But the Reduceron project ended in 2010; wouldn't it have still been going then?
12:57:56 <Philippa> ah, I think they produced two major designs during that run: 2010'd be plausible for that FitA talk
12:58:07 <Twey> Ah
12:58:17 <mildfate> Philippa: I found this, is it what you're referring to? http://www.cs.york.ac.uk/fp/jason-docs/ReichPR2011.pdf
12:59:01 <Philippa> I didn't see that particular piece of work: I think that was later
12:59:19 <Philippa> you can look up old Fun in the Afternoon talks on the Fun website though
12:59:31 <Philippa> (if you get a google hit on sneezy.nott.ac.uk, that's the right place)
12:59:32 <Twey> I would imagine a highly vector-oriented architecture like the Mill would give a boost to graph reduction, even though it's not specifically designed for functional languages
13:00:20 <mildfate> Philippa: :( http://www.downforeveryoneorjustme.com/http://sneezy.cs.nott.ac.uk/
13:00:51 <Philippa> urgh, not again
13:01:00 <Philippa> it did it yesterday too, and the last one /was/ yesterday
13:01:14 <mildfate> Philippa: I'm not familiar with processing units, but is the main problem in computing functional programs graph reduction?
13:01:27 <mildfate>  / the only problem?
13:01:27 <Twey> mildfate: As we currently do it, yes
13:01:45 <Philippa> lazy evaluation is equivalent to it, yeah
13:02:08 <merijn> Twey: Some friends in Twente were experimenting with alternative CPU designs for (lazy) functional language, the did things like having more cache and shorter pipeline and build in pattern matching style operationrs. But I think they only just started evaluating
13:02:10 <Philippa> I'm sat next to someone who's working on optimisation models for lazy evaluation, too
13:02:29 <merijn> mildfate: The main problem in most functional languages in graph reduction, not just the lazy ones ;)
13:04:32 <Philippa> merijn: technically true, but I hear the eager ones don't know how to share :p
13:04:42 <merijn> Philippa: :D
13:04:51 <Twey> Heh.
13:05:14 <mildfate> Can anyone comment on how far away a commercial asic for functional programming we are?  Or is there still a lot of necessary research?
13:05:42 <merijn> mildfate: My old supervisor is looking into compiling (his) functional language to FPGA/ASIC
13:06:00 <Philippa> I don't expect good commercial ones in the next 5 years. I'd be happy to be wrong.
13:06:14 <Philippa> definitely more effort on making various existing hardware behave well instead
13:06:25 <bitemyapp> isn't something like DPH hypothetically compilable to a hardware spec?
13:06:34 <bitemyapp> in an EDSL or something
13:06:47 <Philippa> it'd probably help if more problems were recognised as 'fundamentally symbolic' s.t. it made more sense
13:07:07 <Philippa> Reduceron definitely had some nice tricks though, and I'd wonder what can be done with power consumption on it too
13:07:15 <Philippa> (I don't think they were really investigating that at the time)
13:07:16 <merijn> bitemyapp: Everything is *hypothetically* compilable to a hardware spec :)
13:07:29 <merijn> bitemyapp: The question is one of efficiency and feasibility :p
13:07:43 <haasn> mildfate: you may be interested in http://www.cs.york.ac.uk/fp/reduceron/
13:08:21 <mildfate> haasn: I was reading the paper, but the research is 4 years old, I was curious if there had been any recent development
13:08:36 <bitemyapp> merijn: seems to be that a lot of FPGA coding is already designed around dataflow programming anyway.
13:08:54 <Twey> bitemyapp: Any Cartesian-closed category: http://conal.net/blog/posts/haskell-to-hardware-via-cccs
13:08:59 <bitemyapp> codata maybe for signals stuff?
13:09:00 <Philippa> there's a reasonably obvious reason for that, yeah
13:09:14 <merijn> bitemyapp: Also, since I'm apparently chief PR guy even though I don't work on it, if stuff like DPH interests you, take a look at SAC :p (I should check if they updated their webpage/mailing list, finally)
13:09:35 <Philippa> merijn: you poor bastard :-)
13:09:37 <Eduard_Munteanu> I want to cache (serialize and save on disk) replies to some HTTP requests I make. What's a nice, key-value store for that purpose? Relational DBs seem rather heavyweight for this.
13:09:52 <bitemyapp> merijn: I do more ops/concurrency/backend/API stuff than anything lately.
13:09:56 <merijn> Philippa: I *don't* work for them, so I'm safe :p
13:10:09 <bitemyapp> merijn: my more immediate concerns are good libraries for common bits of infrastructure and a good story for exceptions, stack traces, and logging.
13:10:13 <bitemyapp> so, boring stuff, basically.
13:10:28 <bitemyapp> I'd probably use Repa or Accelerate if I needed fast+parallel for the numerics work we do at my company.
13:10:30 <merijn> Philippa: I'm doing GPU graph processing now, which is the roundabout way to saying, I'm trying to smuggle FP programming into HPC graph processing ;)
13:10:46 <bitemyapp> merijn: nice. What's the perf diff between the graph work on GPU vs. CPU backend?
13:10:50 <merijn> s/to/of
13:11:06 <merijn> bitemyapp: "It depends."
13:11:06 <bitemyapp> I know the raw differences for something trivial like, "smash this hash", curious to see how much of it bears out for graph work.
13:11:15 <bitemyapp> merijn: aw. can you toss me an order of magnitude? please ^_^
13:11:25 <merijn> bitemyapp: Actually, CPU beats GPU in some cases
13:11:39 <Philippa> yeah, I'd expect that
13:11:44 <bitemyapp> merijn: so where does GPU win out? short-run traversals, long-run traversals?
13:12:04 <merijn> bitemyapp: It depends on the combination of algorithm, data representation, actual graph structure and platofmr
13:12:19 <merijn> bitemyapp: Magic 8-ball says: Ask again later. :p
13:12:30 <Philippa> mmm. Have you got some suitably fun compilation schemes for GPU pattern-matching?
13:12:49 <merijn> bitemyapp: I was trying to classify metrics for "where GPU wins", but I need to investigate more
13:13:44 <merijn> Too many confounding factors, so I'm working to do a more systematic rerun of stuff to see if I can isolate that
13:13:45 <Philippa> I imagine GPU wins whenever you can avoid having to 'reconfigure' the pipeline too often
13:14:18 <merijn> Philippa: So far this was even only using simple "here's a static graph, compute some metric on it" things
13:14:21 <bitemyapp> merijn: cool, fair enough.
13:14:24 <Philippa> oh, and have /just enough/ parallelism. But, well, feedback loops're fine so long as you're not stalling each time round it?
13:14:32 <merijn> Like BFS, all-pairs shortest paths and betweenness centrality
13:14:33 <Philippa> merijn: ah
13:14:41 <merijn> Even there it's already unclear
13:14:45 <Eduard_Munteanu> Or perhaps when you don't need to transfer a lot of data in and out of the memory?
13:15:12 <merijn> Eduard_Munteanu: This is for the simple case were the entire thing fits in GPU memory and load times don't count
13:15:43 <Philippa> Eduard_Munteanu: L1 cache on a CPU is pretty damn fast too
13:15:43 <merijn> "Isn't that a really trivial scenario?" 'Yes, and even there we don't understand when/why the CPU or GPU wins'
13:16:18 <Philippa> like, I remember testing the cooling on a new box over a decade back with an all-in-cache RT raytracer a friend'd written
13:16:21 <Philippa> (the cooling was inadequate)
13:16:22 <merijn> Also, the CPU itself is pretty damn fast
13:16:25 <Eduard_Munteanu> Philippa: yeah, I was betting on the CPU side in those cases
13:16:41 <merijn> Like, WAAAAY faster than a gpu core
13:17:21 <Eduard_Munteanu> For most applications, VRAM speed and quantity isn't much of an issue.
13:17:31 <Philippa> yeah, GPU cores mostly exist to multiply, add and shunt data in and out
13:17:41 <Philippa> predicting branches, who the hell wants to do that?
13:18:40 <Eduard_Munteanu> (although consumers do (wrongly) compare graphics cards by RAM size)
13:19:00 <Philippa> eh, that has value
13:19:27 <Philippa> you really don't want to have to upload all the textures each frame
13:20:16 <Philippa> (and PC titles often get a better max texture resolution than the 360/PS3 generation of console titles did/do)
13:20:21 <bitemyapp> Philippa: which is why it's weird to me when people complain about OpenGL retained mode.
13:20:30 <merijn> Quick poll: If you didn't have to pay for it (within a reasonable budget) which GPU would you get for GPGPU processing?
13:20:36 <bitemyapp> Philippa: since you can't keep shuffling the data into the GPU efficiently for immediate-mode style rendering.
13:20:55 <napping> bitemyapp: what do you mean by "retained mode"?
13:21:00 <bitemyapp> I bet gane programmers would love it if there was a game engine that had an immediate-mode facade but could "diff" the scene and commit only retained-mode updates.
13:21:19 <bitemyapp> napping: you're manipulating persistent objects, not pushing a scene in over and over.
13:21:27 <napping> what in OpenGL works like that?
13:21:35 <Philippa> bitemyapp: honestly? A lot'd freak over that for a long time
13:21:36 <Eduard_Munteanu> Philippa: it's largely irrelevant cost vs performance-wise, and if things work reasonably already it likely won't improve the experience at all.
13:21:42 <bitemyapp> napping: what version of OpenGL are you accustomed to?
13:21:55 <bitemyapp> napping: https://www.google.com/search?client=safari&rls=en&q=OpenGL+retained+mode&ie=UTF-8&oe=UTF-8
13:22:05 <Philippa> (also, geometry shaders change a lot)
13:22:35 <mindleyhilner> omg
13:22:38 <bitemyapp> Philippa: efficient diffing would be really hard but it would make for a fun game engine.
13:22:42 <mindleyhilner> phantom types are the way of the future
13:22:51 <bitemyapp> mindleyhilner: what makes you say that?
13:23:04 <bitemyapp> mindleyhilner: have some URL or code that causes your enthusiasm? :)
13:23:13 <mindleyhilner> bitemyapp: the non-dependent typing guarantee of array bounds thingie
13:23:14 <mindleyhilner> by oleg
13:23:32 <mindleyhilner> bitemyapp: http://okmij.org/ftp/Haskell/eliminating-array-bound-check.lhs
13:23:46 <bitemyapp> I think Oleg would say dependent typing is the future, but phantom types are a nice way to have your cake now rather than later.
13:23:57 <napping> working with buffers like that isn't diffing anything
13:24:05 <bitemyapp> napping: you misunderstood me.
13:24:13 <napping> I was thinking of the really old DirectX stuff that works like you said, and was dropped
13:24:27 <mindleyhilner> bitemyapp: within th constraints of haskell, obviosuly
13:24:36 <bitemyapp> napping: there was a long history of complaining about retained mode. I was talking about a hypothetical game engine, not a rendering pipeline, that did scene diffing to expose an efficient immediate-mode-esque API that renders against OpenGL retained-mode.
13:24:38 <mindleyhilner> my original exclamation
13:24:58 <merijn> mindleyhilner: Even within haskell you can do pretty cool stuff with pseudo-dependent types and phantoms
13:25:08 <mindleyhilner> you could use this branding technique everywhere actually
13:25:12 <bitemyapp> napping: with persistent data structures, efficient diffing isn't totally out of the question, but I don't think what I'm talking about will work for AAA games for another decade.
13:25:18 <mindleyhilner> it's like Maybe without that extra union tag
13:25:26 <Eduard_Munteanu> To be more specific, I mean mid and high-end GPUs likely spend a lot more on core stuff rather than memory, which is a lot cheaper to size to a comfortable level. (And in cases where it does make a diffference it's probably an all-or-nothing thing.)
13:25:35 <napping> I still don't see what you meant by "OpenGL retained mode"
13:25:38 <mindleyhilner> merijn: are you referring to gadts?
13:25:52 <bitemyapp> napping: modern OpenGL with persistent objects being manipulated.
13:26:37 <bitemyapp> display lists, VBO, etc.
13:27:00 <Philippa> bitemyapp: it's mostly not a big enough saving if it's not letting you reuse pixels. And that doesn't happen so much in games
13:27:01 <napping> Are those often modified? I thought that was pretty expensive
13:27:07 <Eduard_Munteanu> There was Direct3D Retained Mode, vs Immediate Mode which survived until today.
13:27:15 <napping> reused, certainly, but not modified
13:27:36 <bitemyapp> you're picking up on a particular meaning of what I said that isn't what was intended
13:27:48 <Eduard_Munteanu> Well, D3D10/11 are much better though.
13:27:49 <bitemyapp> jiggle it around until it makes sense (giving me the benefit of the doubt) and then go with that.
13:28:58 <napping> Well, I think "retained mode" has a standard meaning that is actually what you're talking about, but not what's actually in OpenGL
13:29:06 <Eduard_Munteanu> IIRC, OpenGL 4 introduced a similar thing that does away with the state machine.
13:29:46 <bitemyapp> Eduard_Munteanu: draw_indirect?
13:29:49 <napping> Ooh, that's nice. Haven't bothered to get drivers that can do OpenGL 4. I always thought the docs were too vague about how the states work anyway
13:30:22 <Eduard_Munteanu> bitemyapp: not sure... I don't know much about it, but that sounds like something older
13:30:44 <napping> Anyway, how about applicative parsing - is there any common way to handle the case where a few fields should go inside a "parens" wrapper?
13:31:04 <Eduard_Munteanu> bitemyapp: isn't that just about drawing from VBOs rather than display lists?
13:31:12 <Philippa> napping: return a record/tuple?
13:31:17 <napping> I've got a partial solution going to a kind of CPS style and defining (<.>) = liftA2 (flip (.))
13:31:32 <napping> so p1 <.> p2 <.> p3 has the same type as parens (p1 <.> p2) <.> p3
13:32:04 <niteria> what does ->* mean on the heap profile?
13:32:28 <Philippa> otherwise I might just manually consume the parens
13:32:40 <bitemyapp> Eduard_Munteanu: I dunno, I was trying to track down what you mentioned.
13:32:41 <Philippa> I mean, it's less useful if you're not 'really' pulling one value from inside them
13:33:05 * Eduard_Munteanu looks it up
13:33:12 <napping> yeah, I've done that. I'm wondering about something closer to Prolog-style DCG
13:33:19 <bitemyapp> Eduard_Munteanu: don't go to any trouble, I was idly curious.
13:33:28 <ski> @type liftA2 (flip (.))
13:33:29 <lambdabot> Applicative f => f (a -> b) -> f (b -> c) -> f (a -> c)
13:33:51 <merijn> mindleyhilner: GADTs + DataKinds + ConstraintKinds + TypeFamilies type dealios
13:35:49 <tdammers> hmm, weird
13:35:53 <tdammers> scotty fails to install
13:36:14 <Eduard_Munteanu> @google stateless opengl
13:36:15 <lambdabot> http://yosoygames.com.ar/wp/2013/09/what-i-hate-from-opengl-api/
13:36:16 <lambdabot> Title: What I hate from OpenGL API | Yosoygames
13:36:20 <Eduard_Munteanu> @google stateless direct3d
13:36:22 <lambdabot> http://www.gamedev.net/topic/596650-gdc-directx-tutorialstateless-renderer/
13:36:22 <lambdabot> Title: GDC DirectX tutorial...Stateless Renderer - DirectX and XNA - GameDev.net
13:36:39 <Eduard_Munteanu> bitemyapp: I suppose that should be a starting point
13:39:32 <Eduard_Munteanu> I want to cache (serialize and save on disk) replies to some HTTP requests I make. What's a nice, key-value store for that purpose? Relational DBs seem rather heavyweight for this.
13:39:47 <bitemyapp> Eduard_Munteanu: Redis.
13:39:57 <bitemyapp> Eduard_Munteanu: just don't trust Redis's persistence *too* much.
13:40:21 <bitemyapp> Eduard_Munteanu: pretend it's memcached that saves to disk with nice data structures and you won't be wrong.
13:40:34 <Eduard_Munteanu> Isn't Redis all in-memory?
13:40:40 <bitemyapp> Eduard_Munteanu: yes.
13:40:55 <bitemyapp> Eduard_Munteanu: most relatively simple KV stores that are well suited to caching are in-memory.
13:41:19 <bitemyapp> Eduard_Munteanu: if you're addressing/caching a larger amount of data than your memory can handle, you probably just want to use a SQL database.
13:41:20 <Eduard_Munteanu> It's not that sort of caching... more like saved data I'm working with, and it might become large.
13:41:36 <bitemyapp> Eduard_Munteanu: how large is large? in total? per row?
13:42:02 <Eduard_Munteanu> Could become hundreds of MiB soon.
13:42:14 <Eduard_Munteanu> In total.
13:42:22 <bitemyapp> Eduard_Munteanu: per row?
13:42:26 <bitemyapp>  / key
13:42:30 <Eduard_Munteanu> Per row a few hundred KiBs.
13:43:00 <bitemyapp> that data-size isn't prohibitive for hbase, redis, or postgres.
13:43:19 <bitemyapp> I'd say postgres if you actually give a damn about the data.
13:43:33 <Eduard_Munteanu> It's not really critical.
13:43:56 <bitemyapp> Eduard_Munteanu: redis or postgres. Try both, see how you feel.
13:44:27 <Eduard_Munteanu> Isn't Postgres a little bit heavyweight for non-relational, dumb storage?
13:44:45 <_2_chloe1234> hi
13:44:57 <Eduard_Munteanu> I expect to store (URL, ByteString) pairs.
13:45:12 <_2_chloe1234>  heyy
13:45:18 <Eduard_Munteanu> _2_chloe1234: hi
13:45:28 <ixmatus> I've been using AcidState for great success - not in a cluster obviously but AcidState's in memory store has been working well for me
13:46:13 <_2_chloe1234> 2 Eduardo_mainframe:Hey are y single
13:46:23 <quchen> @where ops
13:46:23 <lambdabot> arjanb bos byorgey Cale conal copumpkin dcoutts dibblego dmhouse dolio dons edwardk elliott geekosaur glguy Heffalump Igloo jmcarthur johnw kosmikus Lemmih monochrom nyc Philippa Pseudonym quicksilver roconnor Saizan shachaf shapr sjanssen ski sorear SyntaxPolice xerox
13:46:39 --- mode: ChanServ set +o byorgey
13:46:49 --- mode: ChanServ set +o Cale
13:47:01 <bitemyapp> Eduard_Munteanu: mainframe?
13:47:06 --- mode: byorgey set +b *!*6010016@2.121.55.*
13:47:06 --- kick: _2_chloe1234 was kicked by byorgey (_2_chloe1234)
13:47:16 * hackagebot linear 1.9.1 - Linear Algebra  http://hackage.haskell.org/package/linear-1.9.1 (EdwardKmett)
13:47:29 <bitemyapp> bytbox: _2_karicari
13:47:39 <tdammers> oh god, this is taking forever
13:47:42 <bitemyapp> byorgey: _2_karicari
13:47:48 <tdammers> I threw away my sandbox and started from scratch
13:48:02 <Eduard_Munteanu> bitemyapp: you're asking the wrong person :)
13:48:03 <tdammers> compiling scotty, aeson, hdbc, and a bunch of other dependencies
13:48:19 <tdammers> oh, and lens obviously
13:48:39 <quchen> tdammers: Chances are you have most of the Platform and Lens in the dependencies somewhere.
13:48:56 <tdammers> yeah
13:48:58 <tdammers> probably
13:49:08 <tdammers> I have lens listed explicitly
13:49:16 <Kron_> getting lens takes a million years, yes
13:49:32 <xintron> Are there any restrictions in reading from "/proc/<pid>" with ByteString.readFile?
13:49:35 <quchen> It's not so bad when you use parallel builds though, thanks 1.18
13:49:41 <tdammers> lens is done now, phew
13:49:42 --- kick: _2_karicari was kicked by byorgey (_2_karicari)
13:49:43 <xintron> I can read files around the fs just fine but NOT from /proc
13:50:05 <CatMtKing> is there a good resource for me to read on how to manage/install haskell packages?
13:50:25 <tdammers> almost done...
13:50:38 <tdammers> whee, it seems to have worked
13:50:43 <tdammers> only errors are in my own code
13:50:45 <tdammers> \o/
13:50:56 <Eduard_Munteanu> xintron: does said PID belong to your user?
13:51:09 --- mode: ChanServ set -o byorgey
13:51:20 <Kron> CatMtKing: do you know of cabal?
13:51:20 <matheus23> xintron: I actually have never used /proc/<pid>, but maybe you need access rights
13:51:24 <xintron> Eduard_Munteanu, Yes. It works just fine using readFile from prelude, but everything with ByteString (strict) under /proc doesn't work
13:51:30 <Eduard_Munteanu> xintron: btw, /proc/<pid> is a directory
13:51:40 <xintron> yeah, reading /proc/<pid>/stat
13:51:52 <xintron> But even /proc/cpuinfo etc doesn't work
13:51:53 <Kron> CatMtKing: http://www.haskell.org/haskellwiki/Cabal-Install
13:51:55 <Eduard_Munteanu> Hm.
13:52:05 <xintron> prelude readFile does work, ByteString, not at all :/
13:52:17 * hackagebot containers 0.5.5.0 - Assorted concrete container types  http://hackage.haskell.org/package/containers-0.5.5.0 (JohanTibell)
13:52:21 <Eduard_Munteanu> xintron: can you try stracing it for file calls?
13:52:46 <xintron> heh, it works with lazy bytestring.
13:53:07 <Eduard_Munteanu> xintron: what is the symptom of not working?
13:53:13 <tdammers> seems like cabal prefers already-installed packages over other candidates
13:53:21 <tdammers> and in my case, that threw it into a loop
13:53:25 <xintron> Eduard_Munteanu, Just get empty string as response when using strict bytestring
13:55:46 <Eduard_Munteanu> xintron: lol, I think I know what's going on...
13:55:57 <Eduard_Munteanu> # du -sb /proc/cpuinfo
13:55:57 <Eduard_Munteanu> 0       /proc/cpuinfo
13:56:00 <xintron> Eduard_Munteanu, oh, do tell.
13:56:15 <Eduard_Munteanu> readFile f = bracket (openBinaryFile f ReadMode) hClose (\h -> hFileSize h >>= hGet h . fromIntegral)
13:56:42 <xintron> haha, ah.
13:56:44 <xintron> That makes sense
13:57:01 <xintron> (but is truly frustrating :P )
13:57:25 <Eduard_Munteanu> xintron: try hGetContents instead
13:57:57 <xintron> Eduard_Munteanu, or read lazy and convert to strict?
13:58:24 <Eduard_Munteanu> xintron: yeah, the lazy readFile is different
14:00:01 <xintron> great, now it works accordingly. Thanks for the help Eduard_Munteanu
14:00:31 <Eduard_Munteanu> xintron: maybe you should report it as a bug, I'm not sure whether it is a bug or intended behavior, though.
14:01:05 <Eduard_Munteanu> I suspect this would also not work for named pipes and such.
14:01:19 <xintron> Eduard_Munteanu, Well, it is correct though. One should only read the size of the file.
14:01:43 <xintron> And it makes sense to use the lazy variant of ByteString for reading things like pipes etc
14:02:18 <xintron> This means that if one were to use readFile on the process file descriptor for stdin it wouldn't work I take it
14:02:18 * hackagebot sodium 0.10.0.1 - Sodium Reactive Programming (FRP) System  http://hackage.haskell.org/package/sodium-0.10.0.1 (StephenBlackheath)
14:04:09 <Nick__> hi, how can I find out what demux library should I use for demuxing mpg video stream?
14:06:06 <Eduard_Munteanu> Nick__: are you asking for a Haskell library?
14:06:36 <Fuuzetsu> Nick__: I can't think of any such libraries in Haskell. I see there are some FFMPEG bindings but I don't know whether they work considering last update was in 2009
14:06:41 <Nick__> Eduard_Munteanu ,sorry, wrong chat
14:06:50 <Eduard_Munteanu> There's a gstreamer package.
14:07:07 <Fuuzetsu> Ah, so there is.
14:08:53 <matheus23> IT'S SHOW TIME! putStrLn $ "Current time: " ++ (show time)
14:09:10 <Fuuzetsu> There is a saddening lack of packages that let you work with video.
14:12:19 * hackagebot HSmarty 0.2.0.0 - Haskell implementation of a subset of the PHP-Smarty template language  http://hackage.haskell.org/package/HSmarty-0.2.0.0 (AlexanderThiemann)
14:14:30 <zomg> Scary, Smarty is almost universally hated in the PHP world..
14:14:31 <zomg> :P
14:14:59 <zoku> are there guidelines for haskell namespaces?
14:15:02 <zoku> I dunno where to put my libraries
14:15:07 <zoku> er, where to write my libraries into
14:15:48 <jfischoff> I think there are, because occasionally I get warnings from Hackage about unknown top level module names
14:15:58 <zoku> yeah..I think I'm inventing a top level name
14:16:10 <jfischoff> The first rule is do not use an existing module path
14:16:19 <jfischoff> besides that I think it is pretty loose
14:16:41 <jfischoff> I see people invent top level names occassionally
14:16:51 <jfischoff> follow your heart
14:17:06 <matheus23> Is there a function :: IO Integer that gives me the current time in milliseconds?
14:17:17 <Eduard_Munteanu> If it's an application-like library, perhaps you want Main.Something
14:17:28 <zoku> ok well Mach.Nets is gonna contain my neural net libraries then :]
14:17:37 <jfischoff> getCurrentTime is in microseconds
14:17:38 <zoku> Eduard_Munteanu: no, this isn't an application
14:17:41 <Eduard_Munteanu> matheus23: Data.Time has something like that
14:17:50 <jfischoff> Data.Time.Clock.getCurrentTime
14:17:54 <bitemyapp> matheus23: divide by a thousand?
14:18:14 <matheus23> I've seen Data.Time.Clock.POSIX, but it gives me seconds
14:18:34 <jfischoff> http://hackage.haskell.org/package/time-1.4.2/docs/Data-Time-Clock.html#v:getCurrentTime
14:18:47 <jfischoff> oh wait that utctime
14:18:50 <bitemyapp> matheus23: multiply by a thousand?
14:19:01 <matheus23> bitemyapp: what a good idea! :P (not)
14:19:17 <jfischoff> but you can convert it ... somehow.
14:19:20 <matheus23> jfischoff: yes. That's the point :)
14:19:21 <matheus23> okay...
14:19:22 <Eduard_Munteanu> matheus23: that's not an integer number of seconds
14:19:23 <bitemyapp> I'm just going to keep saying things like this.
14:19:31 <jfischoff> matheus23: one sec
14:20:47 <matheus23> bitemyapp: Okay. To specialize: Which is actually millisecond-accurate :)
14:20:52 <jfischoff> utcTimeToPOSIXSeconds and divide by 10^9 I guess
14:21:04 <jfischoff> I might be off by one there
14:21:22 <bitemyapp> matheus23: millisecond-accurate? the microsecond one is.
14:21:33 <Eduard_Munteanu> Multiply?
14:21:51 <matheus23> bitemyapp: which one is the microsecond one?
14:21:53 <jfischoff> oh wait
14:21:59 <jfischoff> no what am I saying
14:22:04 <bitemyapp> matheus23: getCurrentTime
14:22:06 <jfischoff> I need sleep :p
14:22:14 <bitemyapp> jfischoff: possibly. How are you doing by the way?
14:22:16 <jfischoff> just take the 3 decimals you need
14:22:31 <bitemyapp> there was this neat library posted to the mailing list for tracking units. Could be useful for this.
14:22:34 <bitemyapp> ala frink.
14:22:38 <Eduard_Munteanu> You could divide by fromRational (1 % 10^9).
14:23:15 <matheus23> bitemyapp: Type Error. getCurrentTime doesn't meed the requirement :: IO Integer :P
14:23:23 <Eduard_Munteanu> bitemyapp: Data.Fixed?
14:24:01 <bitemyapp> matheus23: I figured function composition was on the table. my mistake.
14:27:21 * hackagebot wai-predicates 0.3.1 - WAI request predicates  http://hackage.haskell.org/package/wai-predicates-0.3.1 (ToralfWittner)
14:30:34 <quchen> Are "roles" anything to be concerned about in non-GHC code?
14:31:08 <quchen> I don't quite understand the sources enough to judge whether this is an implementation detail or something to pay close attention to.
14:32:22 * hackagebot wai-routing 0.5.1 - Declarative routing for WAI.  http://hackage.haskell.org/package/wai-routing-0.5.1 (ToralfWittner)
14:33:03 <amosr> quchen: I thought it was only really important if you were using generalised newtype deriving
14:33:23 <quchen> Sure, but that's a useful extension.
14:33:40 <zenkeku> Is it unusual for cabal to install itself and then not update?
14:33:43 <amosr> quchen: yeah, but do non-GHC support it? I honestly don't know
14:34:12 <MagneticDuck> zenkeku: what do you mean, not update? do you get some error from "cabal update"?
14:34:22 <matheus23> jfischoff: The problem with utcTimeToPOSIXSeconds is that (POSIXTime = NominalDiffTime) NominalDiffTime is converted to seconds upon conversion... (see docs: http://hackage.haskell.org/package/time-1.1.4/docs/Data-Time-Clock.html#t:NominalDiffTime)
14:34:28 <quchen> By "non-GHC" I meant "not in GHC's own source code", sorry
14:34:37 <zenkeku> MagneticDuck: Nope. It states a new version is available. I install it and the version stays the same.
14:34:45 <MagneticDuck> ahk.
14:34:59 <MagneticDuck> well uhm, do ghc-pkg stuff?
14:35:22 * MagneticDuck isn't going to give a good answer because he doesn't really understand all of cabal very well
14:35:30 <MagneticDuck> I'll try to replicate your error though
14:35:34 * zenkeku neither does he.
14:35:37 <zenkeku> ghc-pkg?
14:35:53 <MagneticDuck> uhm, maybe not
14:36:26 <amosr> quchen: oh, right. I get the impression it's a subtlety that can be ignored most of the time
14:36:28 <zenkeku> Running "ghc-check" gives a ton of warnings.
14:36:31 <zenkeku> @paste
14:36:31 <lambdabot> Haskell pastebin: http://lpaste.net/
14:36:56 <MagneticDuck> zenkeku: well I can't replicate your error
14:37:14 <zenkeku> Might be due to all the warnings ghc-pkg check is gving me.
14:37:17 <MagneticDuck> just installed latest version of cabal-install via cabal install, cabal --version gives me what it's supposed to
14:37:35 <bennofs> quchen: there are role annotations, so i doubt that it's only in GHC's source code :)
14:38:02 <zenkeku> MagneticDuck: All the various warnings.
14:38:15 <MagneticDuck> zenkeku: I get lots of warnings too
14:38:17 <MagneticDuck> =P
14:38:28 <MagneticDuck> uh let me check the warnings in question though
14:38:41 <MagneticDuck> zenkeku: paste?
14:38:52 <zenkeku> http://lpaste.net/101158
14:38:57 <zenkeku> Sorry, thought I had posted it.
14:39:12 <bennofs> quchen: I think roles about whether it's safe to coerce between values that are represented equal. For example, if I have newtype Foo = Foo Int, then Map Int Foo -> Map Int Int is safe
14:39:25 <MagneticDuck> zenkeku: yeah I get all of that stuff too
14:39:29 <MagneticDuck> from the exact same package actually
14:39:34 <MagneticDuck> freakin' haddock!
14:39:35 <zenkeku> Huh, odd.
14:39:43 <bennofs> quchen: but I cannot safely convert Map Foo Int -> Map Int Int, because the Ord instance for Foo might be different from the Ord instance for Int
14:39:51 <zenkeku> However, to my main issue with this: I want to install xmonad-extras.
14:39:58 <MagneticDuck> wonderful
14:40:06 <MagneticDuck> so, what's the problem =P
14:40:36 <zenkeku> Yup. It allows volume control.
14:40:40 <quchen> bennofs: Ah, that's a very good example. I found the one on the wiki a bit artificial and didn't understand the problem.
14:40:41 <letrec> I'm looking for an equivalent to mapM but for HashMap.. Easy way is to convert to / from List and use mapM. Any advice?
14:40:45 <MagneticDuck> sounds cool
14:40:54 <zenkeku> My headphones are extremely sensitive, so I need a quick way of lowering my sound.
14:41:39 <MagneticDuck> lols, I just open a terminal with alsamixer when I need to adjust my volume =P
14:41:50 <MagneticDuck> I have a kind of strange setup
14:42:01 <troydm> so let's say i want to fold over a list using a function that has IO
14:42:02 <zenkeku> By the way, here are the errors from xmonad-extras http://lpaste.net/101159
14:42:05 <troydm> how do i do that?
14:42:17 <MagneticDuck> zenkeku: wonderful
14:42:22 <zenkeku> Yup, tons.
14:42:22 <peddie> :t mapM
14:42:23 <lambdabot> Monad m => (a -> m b) -> [a] -> m [b]
14:42:28 <peddie> troydm: ^
14:42:33 <MagneticDuck> 'tis becauase you're reinstalling a package that things depend on
14:42:39 <byorgey> troydm: mapM or foldM, perhaps
14:42:41 <MagneticDuck> --force-reinstalls and then reinstall the broken packages
14:43:18 <zenkeku> MagneticDuck: Will do.
14:43:22 <zenkeku> Let's hope I don't kill my system.
14:43:23 <troydm> byorgey: oic
14:43:39 <byorgey> zenkeku: noooooo
14:43:39 <troydm> peddie: i guess i'll try using foldM
14:43:41 <byorgey> don't do it!
14:43:43 <Twey> letrec: HashMap has a Traversable instance; use that
14:43:48 <peddie> sorry, I misread
14:43:53 <zenkeku> byorgey: Are you being serious?
14:44:04 <byorgey> I am, actually.
14:44:08 <zenkeku> Explain.
14:44:23 <MagneticDuck> btw guys, is there a good way of reinstalling a depended package and then automatically reinstalling everything that depended on it?
14:44:31 <MagneticDuck> or a way of updating all packages?
14:44:44 <troydm> MagneticDuck: that's wen cabal hell happens
14:44:53 <MagneticDuck> yeah.
14:45:00 <byorgey> the problem seems to be caused solely by something requiring an older version of text.  if you reinstall with an older version of text it may cause problems down the line.
14:45:23 <byorgey> zenkeku: in any case the first thing to do is paste the output of  cabal install --dry-run -v3 xmonad-extras, so we can see what's causing the problem
14:45:46 <zenkeku> byorgey: What does --dry-run -v3 do ?
14:45:47 <MagneticDuck> ahah competent haskellers
14:45:57 <MagneticDuck> <-- not a competent haskeller
14:46:12 <zenkeku> <- As noob as it comes.
14:46:21 <byorgey> zenkeku: --dry-run says "tell me what packages you would install but don't do anything"; -v3 makes it verbose so we can actually see what the dependency solver was thinking
14:46:24 * zenkeku can write programs to ask your name. Super secret spyware.
14:46:41 <zenkeku> byorgey: Roger.
14:46:41 <byorgey> =
14:46:54 <Platz> This works for me but seems like an odd cross between zipWith and mapM  http://lpaste.net/101160
14:46:58 <byorgey> whoops, my smiley seems to be missing a mouth
14:47:10 <MagneticDuck> )
14:47:13 <MagneticDuck> there's the mouth
14:47:16 <byorgey> thanks =
14:47:16 <MagneticDuck> now we have to reconstruct it
14:47:18 <MagneticDuck> =)
14:47:19 <Platz> is it terrible?
14:47:28 * hackagebot lens 4.0.6 - Lenses, Folds and Traversals  http://hackage.haskell.org/package/lens-4.0.6 (EdwardKmett)
14:47:31 * hackagebot binarydefer 1.2.2 - Binary serialization with deferred loading  http://hackage.haskell.org/package/binarydefer-1.2.2 (NeilMitchell)
14:47:48 <zenkeku> byorgey: http://lpaste.net/101161
14:47:51 <byorgey> Platz: what does it do? can you give a simple example?
14:48:39 <byorgey> aha, the culprit is libmpd, which hasn't been updated since January 2013
14:48:55 <zenkeku> On mine?
14:49:42 <byorgey> no, I mean that was the last time a new version of the package was uploaded to Hackage
14:49:50 <byorgey> in particular it hasn't been updated at all since text 1.0 was released
14:50:04 <zenkeku> So I should grab xmonad-extras from a different source?
14:50:28 <byorgey> no, there's nothing wrong with xmonad-extras
14:50:53 * zenkeku is retarded; clearly.
14:50:59 <quchen> Platz: mapIndex = zip [0..]
14:50:59 <byorgey> xmonad-extras depends on a package (libmpd) which says it requires an old version of the text package, which is what's causing the problem
14:51:05 <Platz> byorgey: generateReplacements (\x -> [x, toUpper x])  "aqz" = "aqz","Aqz","aqz","aQz","aqz","aqZ"]
14:51:42 <zenkeku> byorgey: So.. libmpd requires an older version of a package that I have?
14:51:46 <byorgey> > mapM (\x -> [x, toUpper x]) "aqz"
14:51:47 <lambdabot>  ["aqz","aqZ","aQz","aQZ","Aqz","AqZ","AQz","AQZ"]
14:51:59 <byorgey> ah, I see, hmm
14:52:06 <Twey> letrec: Or rather, its Foldable superclass
14:52:10 <quchen> Platz: Wait nevermind, it's not just a zip. But it could be written in simpler terms (and more lazily).
14:52:21 <Twey> :t foldrM :: Monad m => (a -> b -> m b) -> b -> HashMap k a -> m b -- letrec
14:52:22 <lambdabot>     Not in scope: `foldrM'
14:52:22 <lambdabot>     Perhaps you meant one of these:
14:52:22 <lambdabot>       `F.foldrM' (imported from Data.Foldable),
14:52:25 <Twey> Damn
14:52:26 <byorgey> > concatMap (\x -> [x, toUpper x]) "aqz"
14:52:27 <lambdabot>  "aAqQzZ"
14:52:29 <Twey> :t F.foldrM :: Monad m => (a -> b -> m b) -> b -> HashMap k a -> m b -- letrec
14:52:29 * hackagebot eq 4.0.1 - Leibnizian equality  http://hackage.haskell.org/package/eq-4.0.1 (EdwardKmett)
14:52:29 <lambdabot>     Not in scope: type constructor or class `HashMap'
14:52:37 <Twey> Well.  You get the idea.
14:52:44 <letrec> Twey: Great thanks
14:53:42 <byorgey> zenkeku: right, you already have a bunch of packages that depend on the new version of the text package.  So installing an older version of text is going to break them.
14:54:11 <zenkeku> Hm..
14:54:17 <zenkeku> How do I rectify this?
14:54:46 <byorgey> the solutions are (1) don't use xmonad-extras (2) bug the maintainers of libmpd to update their package (3) download libmpd and make a slight modification to see if it will build with the newer text
14:55:00 <letrec> Twey: actually Data.Traversable sounds nice, why should I use Foldable?
14:55:08 <zenkeku> I'm going to go with #1, I've broken my system more times than I can count.
14:55:16 <zenkeku> Thanks for the huge amount of help (seriously), byorgey.
14:55:19 <byorgey> hehe, ok
14:55:20 <zenkeku> I envy your insight.
14:55:22 <byorgey> no problem
14:55:56 <byorgey> just keep at it.  my insight has been won with much blood, sweat and tears over many years.
14:56:36 <Twey> letrec: Because Foldable gives you the foldrM function you need :þ
14:57:18 <zenkeku> byorgey: You're a god among men. I aspire to have as much experience as you some day.
14:57:29 * hackagebot constraints 0.3.5 - Constraint manipulation  http://hackage.haskell.org/package/constraints-0.3.5 (EdwardKmett)
14:58:01 <letrec> Twey: I need more something like mapM on the values of a HashMap. But thnaks, I'll look into it :)
14:59:10 <Twey> letrec: Oh, well, if you want to use mapM then use mapM.  There's one of those in Data.Traversable.
14:59:39 <Twey> letrec: I suggested the Foldable because you said you wanted a fold.
14:59:55 <letrec> Ok, thx :)
15:00:00 <letrec> Twey: :)
15:00:36 <MagneticDuck> >:)
15:02:30 * hackagebot lens 4.0.7 - Lenses, Folds and Traversals  http://hackage.haskell.org/package/lens-4.0.7 (EdwardKmett)
15:04:56 <josiah_> does anyone here know about acidstate?
15:05:39 <josiah_> I want to create a restapi for document storage, and would prefer using haskell if possible
15:05:42 <Fuuzetsu> edwardk: I don't imagine that fixes #410 ;(
15:06:23 <josiah_> there isn't much about acid state, but I was thinking of using acidstate to store the locations of images on the servers
15:06:43 <edwardk> Fuuzetsu: nope
15:06:56 <edwardk> don't have 7.9 installed. if you want to write a patch i'll take it
15:07:27 <josiah_> but also wanted to know, if I needed to use something like mongodb could be added down the road and acidstate could still be used to store the keys to get the images out of mongo
15:07:30 * hackagebot heaps 0.3.1 - Asymptotically optimal Brodal/Okasaki heaps.  http://hackage.haskell.org/package/heaps-0.3.1 (EdwardKmett)
15:07:35 <Fuuzetsu> edwardk: I tried writing a patch but I got a bit confused. I'll try again later tonight I think.
15:07:47 <edwardk> k
15:22:32 * hackagebot approximate 0.2.1.1 - Approximate discrete values and numbers  http://hackage.haskell.org/package/approximate-0.2.1.1 (EdwardKmett)
15:27:33 * hackagebot hyperloglog 0.2.3 - An approximate streaming (constant space) unique object counter  http://hackage.haskell.org/package/hyperloglog-0.2.3 (EdwardKmett)
15:29:53 <Twey> ‘This is a remarkably bad approximate logarithm’ — harsh :þ
15:30:28 <quicksilver> edwardk: why doesn't Data.Heap have a newtype PrioHeap p a = Heap (Entry p a) with appropriate instances and convenience functions?
15:35:36 <edwardk> quicksilver: because it is an old library =P
15:35:40 <bitemyapp> for those that want fmap for their Data.Set, why don't they use unordered-containers?
15:35:59 <edwardk> quicksilver: i started a branch that would fix it to have separate parameters rather than require illegal Ord instances, but it was uglier
15:36:20 <edwardk> quicksilver: so i've had little desire to update it beyond the minimum to keep it going
15:36:48 * quicksilver nods
15:36:54 <edwardk> Twey: um, the ones in the package execute many times faster and give orders of magnitude better accuracy
15:37:21 <edwardk> it is useful for a human, not a computer
15:37:34 * hackagebot HSmarty 0.2.0.1 - Haskell implementation of a subset of the PHP-Smarty template language  http://hackage.haskell.org/package/HSmarty-0.2.0.1 (AlexanderThiemann)
15:37:36 * hackagebot Spock 0.4.3.0 - Another Haskell web toolkit based on scotty  http://hackage.haskell.org/package/Spock-0.4.3.0 (AlexanderThiemann)
15:37:38 * hackagebot Spock-auth 0.1.0.0 - Provides authentification helpers for Spock  http://hackage.haskell.org/package/Spock-auth-0.1.0.0 (AlexanderThiemann)
15:37:41 <edwardk> @let badlog x = 6 * (x - 1) / (x + 1 + 4 * sqrt x)
15:37:42 <lambdabot>  Defined.
15:37:52 <edwardk> > badlog 10
15:37:55 <lambdabot>  2.2833839640094853
15:37:57 <edwardk> > log 10
15:37:59 <lambdabot>  2.302585092994046
15:38:28 <edwardk> > log 10000
15:38:29 <lambdabot>  9.210340371976184
15:38:33 <edwardk> > badlog 10000
15:38:34 <lambdabot>  5.768099221228728
15:38:41 <edwardk> notice how far it starts to diverge?
15:40:45 <edwardk> My flog variants remain within 20% of true are strictly monotone piecewise linear/rational functions useful for machine learning and can be computed as conservative upper or lower bounds of the real function.
15:41:11 <edwardk> borchardt's log is useful for dead reckoning, but isn't much faster than the base log.
15:43:51 <edwardk> anyways https://github.com/ekmett/approximate/blob/master/cbits/fast.c has the code for my variants on schraudolph's and ankerl's algorithms
15:44:48 <edwardk> they are also _much_ better for doubles being piecewise linear rather than piecewise step for no extra cost on modern hardware
15:45:56 <Twey> edwardk: Ah, it's a human-optimized algorithm.
15:46:18 <edwardk> Twey: yeah. i offered it as a comparison
15:46:26 * Twey nods.
15:46:54 <edwardk> the algorithms i do use abuse floating point reps to get piecewise approximations
15:47:07 <edwardk> similar to the old oosqrt trick of carmack
15:47:31 <Twey> Aye
15:49:01 <edwardk> but there is something satisfying with approximating log with (x - 4606921278410026770) * 1.539095918623324e-16;
15:49:17 <MagneticDuck> :D
15:49:19 <edwardk> and a double/long round trip
15:50:13 <edwardk> er double / long long
15:52:12 <quchen> edwardk: (It's by Quake 3, but not Carmack)
15:52:50 <edwardk> quchen: and yes, i know it isn't his
15:54:16 <edwardk> the algorithms i'm using derive from the same idea, just different exponent/direction
16:02:36 <b0bbi10> evening, how do I get a construct like '[(0*),(1*),(2*),(3*),(4*),(5*)..' from 'map (*) [0..]' but the given operand applied to the right hand side?
16:03:16 <heatsink> You can use flip
16:03:23 <heatsink> map (flip (*))
16:03:32 <heatsink> it swaps the function arguments.
16:04:06 <jle`> networks are stupid
16:04:12 <b0bbi10> right, just learned that function some hours ago and already forgot it :/
16:04:15 <b0bbi10> thanks heatsink
16:05:33 <heatsink> If we just ran all software on the same computer, we wouldn't need networks.
16:07:30 <MagneticDuck> jle`: huh.
16:07:39 <MagneticDuck> heatsink: yeah!
16:07:42 <MagneticDuck> down with networks!
16:07:57 * MagneticDuck disconnects
16:10:08 <Platz> Anyone care to comment on the style of my ~100 line haskell exercise?  I can send bitcoin for your efforts
16:10:42 <Platz> http://lpaste.net/101165
16:10:44 <Eduard_Munteanu> Platz: not unless you post it first :)
16:11:25 <MagneticDuck> Platz: bitcoin?!?
16:11:25 <MagneticDuck> magic internet monies?
16:11:28 <MagneticDuck> can I buy ducks with it?
16:11:40 <Eduard_Munteanu> Platz: I wouldn't indent do-blocks like that
16:12:03 <jle`> i've actually seen it done, it's so weird :|
16:12:19 <Platz> MagneticDuck: I'm not sure silk road is still open
16:12:33 <jle`> i've been to a haskell class where the professor indented them like that
16:12:38 * jle` shrugs
16:13:00 <jle`> but i've never seen ifthens indented like that
16:13:16 <Eduard_Munteanu> Platz: also consider not using all-capital names like OK and ERR
16:13:42 <Eduard_Munteanu> I personally prefer camel-casing even acronyms, e.g. Url vs URL
16:14:02 <Platz> Eduard_Munteanu: sounds good
16:14:32 <Eduard_Munteanu> Since things like URLType and HTTPURL gets difficult to read, vs UrlType and HttpUrl respectively
16:15:19 <Eduard_Munteanu> It also avoids weird conventions like CONSTRUCTOR and cONSTRUCTOR.
16:15:39 <MagneticDuck> ick
16:15:42 <MagneticDuck> reverse camel case
16:15:50 <MagneticDuck> the naming scheme of satan himself
16:17:22 <Platz> Eduard_Munteanu: regarding do indentation, you mean to put args on it's own line, right?
16:17:23 * quchen thinks camel case is good for abbreviations >2 characters, but "OK" is better left in caps.
16:17:45 <bitemyapp> quchen: UtC
16:18:06 <quchen> ?
16:19:17 <bitemyapp> quchen: UtC or UTC?
16:19:19 <Platz> I also realized list comprehensions aren't natural for me yet and I tend to do everything in terms of map, filter, etc..
16:19:29 <quchen> bitemyapp: Utc.
16:19:30 <bitemyapp> quchen: I'm saying, "I think you mean >3 not >2"
16:19:34 <bitemyapp> really?
16:19:40 <bitemyapp> you wouldn't capitalize UTC?
16:19:48 <bitemyapp> huh.
16:19:56 <Eduard_Munteanu> I'd prefer Utc too.
16:20:01 <bitemyapp> fair enough.
16:20:36 <t4nk196> what does it mean if I have aeson installed but ghc complains "Could not find module `Data.Aeson.Generic'"?
16:20:39 <Eduard_Munteanu> The problem is you end up writing stuff like UTCTime later on, or possibly even worse like UTCToGMT
16:20:48 <isaacbw> but... UTC is correct
16:21:04 <quchen> So is Utc, for some value of 'correct'.
16:21:34 <Eduard_Munteanu> The problem isn't UTC but making it awkward for your users to extend it based on your naming scheme.
16:21:47 <MagneticDuck> t4nk196: it means that ghc can't find the module Data.Aeson.Generic
16:21:47 <MagneticDuck> working in a cabal project?
16:21:47 <MagneticDuck> add the responsible package to the build-depends
16:22:02 <isaacbw> http://www.nist.gov/pml/div688/utcnist.cfm#cut
16:22:35 <quchen> Platz: The code includes no documentation.
16:22:40 * hackagebot xmobar 0.20.1 - A Minimalistic Text Based Status Bar  http://hackage.haskell.org/package/xmobar-0.20.1 (JoseAntonioOrtegaRuiz)
16:22:42 <t4nk196> MagneticDuck: thanks, is it because I did it with cabal sandbox?
16:23:41 <Platz> quchen: yeah, that's a good idea
16:23:58 <MagneticDuck> it's just how cabal works
16:24:10 <MagneticDuck> t4nk196: it's handy and makes things safe
16:24:22 <MagneticDuck> (for instance, when a module is exported by multiple packages)
16:24:35 <t4nk196> MagneticDuck: ok, then how do I add to build-depends?
16:24:51 <quchen> Platz: You may want to get familiar with basic Haddock syntax for this
16:24:59 <quchen> (Which is very easy)
16:25:14 <quchen> See file:///home/main/Documents/manuals/haskell/haddock%20user%20guide/markup.html
16:25:14 <MagneticDuck> t4nk196: ?
16:25:20 <quchen> Waaait hold on sorry nevermind
16:25:27 <quchen> I did not just link to file:/// did I
16:25:43 <Platz> i clicked it
16:25:47 <quchen> http://www.haskell.org/haddock/doc/html/markup.html
16:25:48 <quchen> ಠ_ಠ
16:25:49 <t4nk196> MagneticDuck: "add the responsible package to the build-depends"
16:25:52 <Eduard_Munteanu> No, it was all just a dream... a nightmare.
16:26:02 <MagneticDuck> t4nk196: in the .cabal file for your project
16:26:29 <MagneticDuck> top directory, there is a file called <package>.cabal for <package> name of your package
16:26:34 <t4nk196> MagneticDuck: There is no cabal file...I'm probs doing it all wrong :-)
16:26:47 <MagneticDuck> t4nk196: I asked, are you using cabal?
16:26:51 <MagneticDuck> are you making a package?
16:27:32 <t4nk196> MagneticDuck: I'm trying to play with threepenny-gui examples
16:27:41 * hackagebot heroku 0.1.1 - helpers for deploying to Heroku  http://hackage.haskell.org/package/heroku-0.1.1 (GregWeber)
16:28:41 <MagneticDuck> t4nk196: what do you run to install / run your ... thing?
16:28:50 <MagneticDuck> describe the setup
16:30:29 <isaacbw> how do libraries become contrib?
16:31:11 <isaacbw> just make a library and see of rich hickey likes it enough?
16:31:11 <t4nk196> MagneticDuck: I downloaded a clone of the github repository for threepenny-gui. Then I did "cabal sandbox init". Then I did "cabal install aeson" and "cabal install threepenny-gui". Then I did "./runhaskell Chat.hs".
16:31:48 <Eduard_Munteanu> isaacbw: what do you mean "contrib"
16:31:50 <Eduard_Munteanu> ?
16:32:13 <isaacbw> wrong channel
16:32:23 <Eduard_Munteanu> Debian / Ubuntu I presume?
16:32:29 <isaacbw> no, clojure
16:33:14 <MagneticDuck> t4nk196: and full error message reported by runhaskell?
16:34:14 <t4nk196> MagneticDuck: http://lpaste.net/2885372189232594944
16:35:07 <schell> does anyone have any strong opinions on the best sqlite3 wrapper to use?
16:35:42 <mietek> Is there a usable Haskell HTTP client library which is not based on conduit?
16:36:39 <MagneticDuck> t4nk196: sorry, back now
16:36:39 <MagneticDuck> uhm
16:36:54 <MagneticDuck> one sec, I have around 5 bits per second with this wonderful wifi
16:36:58 <t4nk196> mietek: wasn't http-client recently factored out of conduit?
16:37:15 <meretrix> mietek: FYI, you don't need to use the rest of the conduit framework to use http-conduit.  I use it to just stream in bytestrings.
16:37:17 <t4nk196> MagneticDuck: no worries, thanks so much for helping me out...
16:37:42 <mietek> t4nk196: right.  What I actually means is, any other library than this one.
16:38:16 <MagneticDuck> t4nk196: hmmm...
16:38:28 <MagneticDuck> ghc-pkg list | grep aeson ? xD
16:38:51 <meretrix> mietek: http-4000 is my 2nd choice.
16:39:15 <t4nk196> MagneticDuck: WARNING: there are broken packages.  Run 'ghc-pkg check' for more details.     {aeson-0.7.0.1}
16:39:18 <meretrix> I would consider it plenty usable.
16:39:31 <quchen> Platz: I annotated your paste with some remarks, search for "QUCHEN" to find them.
16:39:39 <mietek> meretrix: only supports HTTP?
16:40:02 <mietek> Oh dear.
16:40:30 <Platz> quchen: awesome, thanks
16:40:46 <meretrix> mietek: Yeah, I think that might be right.
16:41:08 <quchen> Platz: I always feel nostalgia doing this :>
16:42:42 * hackagebot stable-maps 0.0.5 - Heterogeneous maps keyed by StableNames  http://hackage.haskell.org/package/stable-maps-0.0.5 (EdwardKmett)
16:42:55 <quchen> Platz: Oh, and in line 72 that should be  `zipWith (\i _ -> (i,xs)) [0..] xs`,  the "3" part is redundant. Should've run the function before pasting it :-)
16:43:44 <mietek> I'm a bit stumped by the Popper/NeedsPopper/GivesPopper "seemingly convoluted structure" in Network.HTTP.Client
16:44:00 <mietek> Does anyone have an example of doing a POST request with an actual request body using this?
16:44:23 <mietek> The http-conduit chapter in the Yesod book only does a POST request with no body
16:44:56 <t4nk196> MightyDuck: There are problems in package aeson-0.7.0.1:   Warning: haddock-interfaces: /Users/echatav/.cabal/share/doc/x86_64-osx-ghc-7.6.3/aeson-0.7.0.1/html/aeson.haddock doesn't exist or isn't a file   Warning: haddock-html: /Users/echatav/.cabal/share/doc/x86_64-osx-ghc-7.6.3/aeson-0.7.0.1/html doesn't exist or isn't a directory
16:45:19 <Platz> quchen: the reason Digit is a string is because it represents an ASCII "digit" made out out pipes and underscores
16:45:32 <MagneticDuck> I dunno, might as well check .... that.......
16:45:32 * MagneticDuck is bad at cabal
16:45:32 <MagneticDuck> why am I here answering questions anyway?!?!
16:45:32 <MagneticDuck> :D
16:45:42 <Platz> i.e. see ocrMap
16:46:07 <t4nk196> MagneticDuck: heheh, because you're such a nice duck! :-D
16:46:15 <Platz> but the other comments are great, making updates now
16:47:04 <quchen> Platz: That's a way of displaying numbers, not one to store them internally. Your code should never have to handle ASCII art outside the parsing and printing steps.
16:47:22 <quchen> Similarly, Photoshop doesn't use pictures of "6" internally to store the number 6.
16:47:29 <meretrix> mietek: I have something like this in my code "requestBody = RequestBodyLBS $ encode body".
16:48:30 <mietek> meretrix: with encode from Aeson?
16:48:47 <Platz> quchen: I agree with that.  I probably would have had to made AccountNum a list of Maybe Int also, but got lazy
16:49:11 <MagneticDuck> t4nk196: nobody seems to want to help you besides me atm but my connection is blipping out and I'm not well-versed in cabal :<
16:49:12 <MagneticDuck> lols
16:49:13 <MagneticDuck> t4nk196: yeah I think it must be because of the sandbox
16:49:14 <MagneticDuck> well ofc, don't you have to reveal selected packages to a sandbox?
16:49:14 <Platz> in case parsing a digit fails, and it has a "?" in there instead of the parsed digit
16:49:22 <mietek> meretrix: thanks, that looks workable
16:50:21 <t4nk196> MagneticDuck: trust me, I'm worse at cabal ;-)
16:50:29 <MagneticDuck> t4nk196: x|
16:50:38 <quchen> Platz: I don't know what an "AccountNum" does in your program, but if it's an account number I don't think it should be anything than an integer type
16:50:47 <quchen> +other
16:51:04 <Kron> quchen: I love your articles
16:51:08 <Kron> I hadn't spotted them before
16:51:11 <Kron> gonna read them all
16:51:20 <heatsink> I presume that it is meaningful to add integers, but not meaningful to add AccountNums
16:52:52 <quchen> heatsink: Then don't add AccountNums.
16:53:03 <quchen> If you really want to make sure this doesn't happen you can newtype them.
16:53:04 <MagneticDuck> t4nk196: you need to run "cabal sandbox hc-pkg expose <package>"
16:53:05 <MagneticDuck> ... I think!
16:53:05 <MagneticDuck> information got from speedreading all of the --help output I could find from cabal sandbox =P
16:53:39 <heatsink> quchen: newtypes are what I had in mind.  I don't have Platz's code to see what he did
16:53:56 <t4nk196> i'll try it
16:55:03 <t4nk196> MagneticDuck: what do I put in for <package>?
16:55:08 <MagneticDuck> t4nk196: uhm
16:55:18 <Platz> so the problem is there can be a "hole" in the account number parse, such as "12346?535"
16:55:23 <MagneticDuck> ....
16:55:33 <Platz> where the ? chars are the ones that were illegible
16:56:13 <mietek> http-streams look nice
16:56:16 <mietek> But buggy?
16:56:20 <quchen> Platz: Ah, I see.
16:56:39 <MagneticDuck> t4nk196: http://coldwa.st/e/blog/2013-08-20-Cabal-sandbox.html
16:56:41 <MagneticDuck> informative article
16:56:45 <quchen> Platz: In that case [Maybe Int] might actually be a suitable type.
16:56:45 <MagneticDuck> should help us
16:57:32 <quchen> You could also consider account numbers in base 11, but that would result in very awkward code :-)
16:57:33 <t4nk196> MagneticDuck: yup, already had it in one tab
16:57:49 <Platz> quchen: lol
16:57:59 <MagneticDuck> okay
16:58:02 <t4nk196> MagneticDuck: btw, feel free to give up on me when you like, i'll take no offense
16:58:22 <MagneticDuck> t4nk196: I prefer to slowly forget about your problems
16:58:30 <MagneticDuck> while reading articles like this one: http://web.mit.edu/newsoffice/2011/trillion-fps-camera-1213.html
16:58:34 <MagneticDuck> WOW OMG WHAT
17:00:15 <Fuuzetsu> pretty old news, I wonder where they went with it from there
17:01:12 <mietek> meretrix: http-client raises TlsNotSupported...
17:01:32 <t4nk196> MagneticDuck: awesome!
17:01:32 <mietek> Oh, there's http-client-tls
17:03:12 <meretrix> Yeah, you need that.
17:26:14 <prinsen> Im trying to read the request body in a Yesod handler, and have a conduit source. How do I run this to get a ByteString?
17:31:18 <pavonia> I'm trying to create a new container widget in gtk2hs. As far as I understand you cannot create a new widget type directly, but have to use an existing one and provide functions for manipulating them. My problem is in understanding how to hook into things like widgetSizeAllocate. Any hints or examples where to start here?
17:40:29 <prinsen> What is the identity of && in Conduit?
17:42:02 <heatsink> Do you think it's reasonable to use view patterns to write unzip-and-folds?
17:42:15 <heatsink> let (sum -> t1, sum -> t2, sum -> t3) = unzip3 $ map f xs
17:42:36 <jle`> quchen: is your main publication platform github gists?
17:42:42 <jle`> or do you have a blog somewhere that i don't know about
17:47:15 <quchen> jle`: It's only Github I'm afraid
17:47:59 <quchen> Most of it is written for myself anyway, with an occasional Reddit submission. Except fbut.md, which I like to use in here :-)
17:50:34 <ReinH> heatsink: you could use a monoid?
17:50:48 <nkpart> Is it possible to suppress the "Loading package" logging from cabal build?
17:51:28 <ReinH> > fold [(Sum 1, Sum 1, Sum 1), (Sum 2, Sum 2, Sum 2)] -- heatsink
17:51:29 <lambdabot>  (Sum {getSum = 3},Sum {getSum = 3},Sum {getSum = 3})
17:51:49 <pyon> @hoogle Sum
17:51:49 <lambdabot> Data.Monoid Sum :: a -> Sum a
17:51:49 <lambdabot> Data.Monoid newtype Sum a
17:51:49 <lambdabot> Prelude sum :: Num a => [a] -> a
17:51:52 <heatsink> oh, someone's already defined a sum monoid
17:52:02 <pyon> @hoogle Prod
17:52:02 <lambdabot> Data.Monoid Product :: a -> Product a
17:52:02 <lambdabot> Data.Monoid newtype Product a
17:52:02 <lambdabot> Data.Functor.Product module Data.Functor.Product
17:52:05 <pyon> Oh, nice.
17:52:18 <ReinH> heatsink: and also tuples of monoids form a (cartesian) product monoid
17:54:09 <heatsink> That works nicely, ReinH
18:01:29 <Twey> ski: Oh, re. rôles from earlier: I think contravariance (and all other type families) are handled by just inferring nominal equality, so it's a non-issue
18:05:36 <ReinH> heatsink: :)
18:06:42 <ReinH> heatsink: you might want to look at http://hackage.haskell.org/package/foldl
18:46:19 <magicman> Oooh, it typechecks and works. Catamorphisms are applicative as well. http://lpaste.net/101171
18:46:41 <heatsink> Is there a hierarchical module name for Numeric?
18:46:43 <magicman> Or... I think those things are actually called Algebras. Oh, well.
18:47:13 <shachaf> exists x. (f x -> x, x -> a)?
18:47:22 <magicman> Yes.
18:47:31 <shachaf> I'm not sure I've seen that type.
18:48:11 <heatsink> Does exists x. (f x -> x) mean a fixed point of f?
18:48:52 <heatsink> No, I'm thinking of dependent sums
18:48:59 <shachaf> I don't think it's either one.
18:49:09 <magicman> No, just a function from f x -> x for an definer-chosen x.
18:49:27 <shachaf> If you had some sort of equality rather than -> then it might mean that f has a fixed point.
18:51:18 <heatsink> So the only way of introducing an x is if f x has "empty container" values
18:57:12 <magicman> The person who creates a value of type exists x. (f x -> x) gets to choose the x. If f = [], both sum and concat work for that type.
18:58:26 <magicman> (Cata []) doesn't make much sense, in the context of that lpaste, though. Fix [] isn't really interesting.
19:05:36 <ezrios> http://www.haskell.org/haskellwiki/Memoization
19:05:42 <ezrios> How does the memoized_fib example work
19:05:44 <ezrios> ?
19:05:52 <carter> SCIENCE
19:06:00 <carter> which memo lib?
19:06:31 <ezrios> memoized_fib = (map fib [0 ..] !!)
19:06:34 <ezrios>    where fib 0 = 0
19:06:36 <ezrios>          fib 1 = 1
19:06:38 <ezrios>          fib n = memoized_fib (n-2) + memoized_fib (n-1)
19:07:05 <Cale> That example bothers me slightly. It relies on GHC lifting cafs
19:07:47 <Cale> Actually, no it doesn't.
19:07:59 <Cale> The idea with this one is that map fib [0..] is a constant parameter to (!!)
19:08:10 <carter> ewww
19:08:22 <Cale> and under lazy evaluation, parameters to functions are evaluated at most once
19:08:42 <Cale> (all bound variables behave that way)
19:08:54 <carter> so its abusing a guaranteed space leak
19:09:01 <Cale> That's what memoisation is.
19:09:07 <carter> true :)
19:09:58 <ezrios> Cale: so the nth element of (map fib [0..]) is evaluated at most once?
19:10:03 <Cale> Right.
19:10:06 <ezrios> hm
19:10:23 <ezrios> I don't think I grok laziness yet
19:10:30 <carter> soke
19:10:34 <ezrios> but that makes sense, sort of
19:10:35 <carter> you can still survive
19:10:36 <ezrios> thanks
19:10:37 <carter> :)
19:10:38 --- mode: Cale set -o Cale
19:18:47 <Twey> carter: Technically it's not a space leak, because the memory is always accessible
19:18:53 <carter> even people wh:)
19:18:55 <carter> :)
19:33:52 <Kron> What does it take to get on hackage?
19:34:18 <Kron> I'd love to eventually post some of my libraries in a public listing
19:34:36 <Kron> and I'm not sure how... good I am, I guess. Or what exactly the standards are for hackage and the cabal list
19:35:25 <Redz> some packages imply that there is no standard. ;)
19:35:41 <Kron> well at the very least you need to ask for upload priveleges
19:35:45 <Kron> so it's clearly not an open system
19:36:10 <ParahSailin> Kron: you just ask and theyll give it to you
19:36:14 <Redz> its just to keep bots outside.
19:36:22 <Kron> alright
19:36:37 <Kron> I guess I'd also need to learn how to use haddock. I'd certainly like to
19:37:43 <pavonia> Talking of standards, there's a version number policy you should satisfy
19:38:00 <Kron> oh? what's the standard?
19:38:13 <pavonia> http://www.haskell.org/haskellwiki/Package_versioning_policy
19:39:04 <Kron> ooh thanks
19:39:42 <Redz> you just need a nice cabal package. using cabal implies that you know about the version policy.
19:39:53 <Kron> gotcha
19:40:05 <Kron> I guess 'entity' extends to functions?
19:41:13 <Duta> @pl isCollProb n m p = 1 - noCollsProb n m >= p
19:41:13 <lambdabot> isCollProb = (((>=) . (-) 1) .) . noCollsProb
19:43:30 <Duta> @pl minItemsForCollProb m p = head $ filter (\n -> isCollProb n m p) [0..m]
19:43:31 <lambdabot> minItemsForCollProb = (head .) . ap (flip . (filter .) . flip . flip isCollProb) (enumFromTo 0)
19:43:47 <Duta> @hoogle enumFromTo
19:43:47 <lambdabot> Prelude enumFromTo :: Enum a => a -> a -> [a]
19:43:47 <lambdabot> Language.Haskell.Syntax HsEnumFromTo :: HsExp -> HsExp -> HsExp
19:44:58 <Duta> @pl charmap = zip ['a'..'z'] [0..] ++ zip ['A'..'Z'] [0..]
19:44:58 <lambdabot> charmap = zip ['a'..'z'] [0..] ++ zip ['A'..'Z'] [0..]
19:47:02 <Duta> @pl isCollProb p n m = 1 - noCollsProb n m >= p
19:47:02 <lambdabot> isCollProb = flip (flip . (((>=) . (-) 1) .) . noCollsProb)
19:47:17 <Duta> @pl isCollProb n m p = 1 - noCollsProb n m >= p
19:47:17 <lambdabot> isCollProb = (((>=) . (-) 1) .) . noCollsProb
19:49:36 <Kron> alright, mailed
19:49:41 <Kron> hope they like me D:
19:50:27 <ezrios> @pl (\x -> even x && (x < 1000))
19:50:27 <lambdabot> liftM2 (&&) even (< 1000)
19:50:40 <ezrios> hm, close
19:50:50 <Kron> hmm, what're you looking for?
19:51:02 <ezrios> I mean, that was close to what I had
19:51:12 <Kron> what does @pl do?
19:51:31 <ezrios> Kron: converts a function into point-free
19:51:34 <Kron> @pl (&&) <$> even <*> (< 1000)
19:51:34 <lambdabot> (&&) <$> even <*> (< 1000)
19:51:38 <Kron> isnt' that point free?
19:51:40 <Kron> it's how I'd do it
19:51:43 <Kron> applicative functors
19:52:10 <Kron> though i'll admit I have no idea what && does
19:52:14 <ezrios> logical and
19:52:18 <Kron> ahh
19:52:28 <ezrios> hm, I ought to brush up on applicative
19:52:36 <Kron> the <$> / <*> pattern is really growing on me
19:52:52 <Kron> generally, if you ever see this: "f (g x) (h x) (j x) ..."
19:53:03 <Kron> it's just "f <$> g <*> h <*> j ..."
19:53:07 <Kron> can make it a lot more readable
19:53:25 <Kron> at the very least it means I don't have to keep repeating some verbose argument name or the other
19:53:34 <Kron> liked wrappedTree or something
19:53:43 <ezrios> Kron: this is something I have been looking for for a while now
19:53:50 <Kron> oh! I'm glad you like it :)
19:53:55 <Kron> I actually found it in LYAH, of all places
19:54:05 <ezrios> yeah, I skipped over most of LYAH and went to RWH
19:54:11 <Kron> gotcha
19:54:25 <ezrios> I'm not sure if applicatives are covered in RWH
19:54:31 <Kron> another helpful function I like a lot is "on"
19:54:33 <ezrios> at least, not at the point I'm at
19:54:46 <Kron> f `on` g x y = f (g x) (g y)
19:55:03 <ezrios> ooh
19:55:04 <Redz> i recommend the wikibook.
19:55:10 <Kron> which is kind of the opposite of the applicative thing (replicate a function over several arguments instead of replicating an argument over functions0
19:55:14 <Kron> you'll find on in Data.Composition
19:55:20 <Kron> so you can do stuff like
19:55:37 <Kron> sortBy (compare `on` length) list
19:55:39 <Kron> etc.
19:55:58 <ezrios> neato
19:56:01 <Kron> (though I should note that "compare `on` " = "comparing" so this particular example isn't that great)
19:56:13 <Kron> but yeah, I use it a lot
19:58:30 <magicman> :t liftA2 (&&) `on` (<)
19:58:31 <lambdabot> Ord a => a -> a -> a -> Bool
20:16:50 <Kron> hah
20:17:00 <Kron> for the first time ever, I think i've found a use for the monkey operator
20:17:04 <Kron> http://codepad.org/gXEcCgBI
20:17:23 <Kron> pairToList = (:) <$> fst <*> (:[]) . snd
20:19:16 <ParahSailin> > length "return" -length "(:[])"
20:19:17 <lambdabot>  1
20:20:39 <magicman> Do imports count? "pure" :p
20:20:49 <Kron> yeah
20:20:52 <Kron> I was thinking that :P
20:20:54 <Kron> pure's even smaller
20:20:57 <Kron> but I like my monkey
20:21:01 <Kron> leave it alone ;_;
20:23:09 <ParahSailin> and you can always count on @pl to golf it uncurry ((. return) . (:))
20:23:43 <Kron> geeze
20:23:58 <magicman> That's actually one character longer, if you take spaces out of both of them.
20:24:09 <Kron> yeah, take that lambdabot!
20:24:46 <magicman> Though... that could become uncurry$... which saves one character ( "()" versus "$" ) <_<
20:25:11 <sinelaw> because bytes are so scarce nowadays
20:25:12 <Kron> hmmm
20:25:14 <magicman> And bring the monkey and/or pure back in. Okay, I'm thinking too much about this.
20:25:14 <Kron> and use pure
20:25:30 <Kron> uncurry ((. pure) .(:))
20:25:46 <Kron> i prefer the monkey version cause it looks incredible
20:25:56 <Kron> uncurry ((. (:[])).(:))
20:26:01 <Kron> it's like a bash forkbomb
20:26:11 <Kron> line noise
20:26:15 <Kron> syntactically valid perl
20:26:17 <jrmithdobbs> only happier and more shocked
20:26:18 <Kron> it's glorious
20:26:36 <Redz> patience is scarce.
20:26:58 <Kron> who needs patience when you have purity?
20:27:01 <Kron> #haskellmasterrace
20:28:52 <Kron> :t ap
20:28:53 <lambdabot> Monad m => m (a -> b) -> m a -> m b
20:29:05 <Redz> how about a sufficiently smart compiler? because purity isn't that compatible with real world.
20:29:18 <Kron> nonsense
20:29:29 <Kron> all the PHP programmers of the world will look up at us and shout "Save us!"
20:29:36 <Kron> and we'll look down and whisper "... no."
20:29:55 <Kron> for saving would involve a state modification anyway
20:30:29 <Redz> well, we invented monads ... :o
20:30:59 <sinelaw> not me
20:31:13 <Kron> it was probably edwardk
20:31:21 <Kron> he invented everything
20:37:11 <ezrios> (&&) <$> even <*> (< 4000000) -- what is the Functor here?
20:37:23 <Kron> the functor is "functions"
20:37:24 <tikhon> probably (->) r
20:37:27 <Kron> (->) is a function itself
20:37:42 <tikhon> if we could have sections at the type level, it would look like (-> r)
20:37:46 <Kron> (a -> b) is the type signature of all functions
20:37:57 <Kron> even longer functions like (a -> b -> c) are simply curried (a -> (b -> c))
20:38:06 <Kron> functions that take an input and give a new function
20:38:08 <ezrios> hum
20:38:15 <Kron> the 'box' that the function is holding is the first bit
20:38:17 <tikhon> it's often called the "reader monad"
20:38:18 <Kron> (??? -> r)
20:38:25 <Kron> so it's often called (->) r
20:38:40 <Kron> and yeah, applicative functors are crazy >_>
20:38:44 <Kron> I barely grok them
20:38:52 <tikhon> ezrios: can you figure out what <$> does for this functor? That's a good exercise.
20:40:41 <Twey> Kron: Applicative functors are functors that you can apply to other functors.
20:41:39 <Kron> Twey: this only seeks to amplify my confusion!
20:41:42 <edwardk> Kron: (->) r        is the other way around  (->) a b  = a -> b
20:41:42 <Twey> Although I feel the monoidal functor presentation is a bit nicer
20:42:03 <edwardk> Kron: so its not (??? -> r)  for (->) r ??? but rather (r -> ???)
20:42:11 <Kron> ah
20:42:15 <Kron> my bad
20:42:22 <edwardk> Kron: now lets look at what that means for  functor
20:42:23 <tikhon> oops
20:42:23 <Kron> and in retrospect that makes a lot more sense
20:42:29 <edwardk> :t fmap
20:42:29 <lambdabot> Functor f => (a -> b) -> f a -> f b
20:42:37 <Kron> I was confused by tikhon's section comment
20:42:38 <edwardk> when f = (->) e   that is
20:42:42 <tikhon> thinking in prefix notation always confuses me
20:42:52 <edwardk> Functor f => (a -> b) -> (->) e a -> (->) e b
20:42:58 <Twey> Kron: ‘If you have an f (a → b) and an f a, can you get an f b?’  If yes, you probably have an applicative functor (assuming you can define pure to match it, which is usually not hard).
20:43:06 <edwardk> (a -> b) -> (e -> a) -> (e -> b)
20:43:10 <edwardk> that is (.)
20:43:12 <edwardk> :t (.)
20:43:12 <lambdabot> (b -> c) -> (a -> b) -> a -> c
20:43:19 <edwardk> after you swap all the names
20:43:41 <edwardk> > (+1) . (*2) $ 5
20:43:42 <lambdabot>  11
20:43:49 <edwardk> > fmap (+1) (*2) $ 5
20:43:50 <lambdabot>  11
20:44:26 <edwardk> so then the two applicaqtive operations are pure :: a -> e -> a      hrmm, that looks like const!
20:44:56 <Twey> Kron: Obviously if you have an (r → a → b) and an (r → a) you can get an (r → b): it's \f a → \r → (f r) (a r)
20:45:00 <edwardk> and (<*>) :: (e -> a -> b) -> (e -> a) -> e -> b
20:45:15 <Twey> :t \f a r -> f r (a r)
20:45:15 <edwardk> which we can get the computer to write for us
20:45:15 <lambdabot> (t2 -> t1 -> t) -> (t2 -> t1) -> t2 -> t
20:45:25 <edwardk> @djinn (e -> a -> b) -> (e -> a) -> e -> b
20:45:25 <lambdabot> f a b c = a c (b c)
20:45:57 <Twey> :t \(f :: r -> a -> b) a r -> f r (a r)
20:45:58 <lambdabot> (r -> a -> b) -> (r -> a) -> r -> b
20:46:02 <nwf> Hey edwardk, just the person I hoped to find.  Has anyone looked at generic fold operators for (cyclic) graphs or (better) pairs of cyclic graphs?  I find myself flailing about in the space...
20:46:17 <Twey> Even @djinn can figure it out!
20:46:17 <edwardk> nwf: yes, they all suck
20:46:28 <nwf> edwardk: That's what I feared. :(
20:47:22 <thyrgle> Hi. I have a question.
20:47:56 <thyrgle> I am currently following this tutorial to install gtk https://github.com/gtk2hs/gtk2hs
20:48:12 <thyrgle> And I believe that I have the required packages.
20:48:28 <thyrgle> but when I run a simple hello world program: runhaskell main.hs
20:48:45 <thyrgle> I get: Could not find module `Graphics.UI.Gtk'
20:48:53 <thyrgle> Is there like some sort of flag I am missing?
20:50:39 <tikhon> try running `cabal info gtk' to see if the package is actually installed
20:50:53 <tikhon> check what it says after Versions installed:
20:51:25 <thyrgle> it says "Versions installed: 0.12.4"
20:51:48 <tikhon> hmm
20:51:51 <thyrgle> although, that's interesting I want 0.12.5.6...
20:52:36 <tikhon> even so, the module should still exist
20:52:38 <tikhon> hmm
20:53:07 <hunt> do you guys get nervous when writing in other non-functional languages that youre going to get worse at haskell?
20:53:40 <thebnq> if anything its the other way around
20:54:06 <tikhon> thyrgle: what if you try loading your file into GHCi? You should still get the same error, but it can't hurt to try.
20:54:14 <hunt> thebnq: really? i find the other languages so much easier to write in then haskell, like i have no doubt that ill still be able to write fast c after spending a weekend in haskell
20:54:32 <thyrgle> tried. Same error
20:54:33 <hunt> thebnq: imperative code is hardwired into my brain for live
20:54:33 <hunt> life
20:55:10 <tikhon> thyrgle: are you using any sort of sandboxing (ie, did you do something like `cabal sandbox init')?
20:55:15 <thebnq> hunt: well i guess its different for everyone, but haskell teaches a lot of useful things that can be applied elsewhere :]
20:55:30 <thyrgle> I don't believe I ever did a sandboxing thing
20:55:39 <tikhon> hunt: I've been using functional programming primarily for a few years, and that's all it took to make it more natural than imperative programming.
20:55:39 <thyrgle> although I've been having lots of problems with cabal
20:55:43 <Kron> hmmm
20:55:46 <Kron> trying to do http://codepad.org/PL9JcBz5 point free
20:55:54 <Twey> hunt: No; why would I?  There are relatively few arbitrary tricks to learn in order to be good at Haskell; most of it is general concepts that you won't forget so easily.
20:55:56 <tikhon> thyrgle: yeah, not sure what else to try, honestly
20:55:57 <hunt> thebnq: i think its because im still very much learning haskell so im worried my knowledge might be tainted
20:56:11 <pawprint> i just did a "cabal install pandoc", which seems to have worked..  "cabal info pandoc" shows that it's installed.. but when i type "pandoc" i get an error:  "zsh: command not found: pandoc" .. how do i find out where the pandoc executable has been installed to ?
20:56:21 <hunt> twey: yea i guess its just because im really far from having a thorough understanding of haskell/functional programming
20:56:22 <Twey> hunt: And indeed, many of them are also applicable to other languages.
20:56:30 <thyrgle> ok thanks for the help nonetheless
20:56:40 <tikhon> pawprint: look in your ~/.cabal/config file
20:57:06 <tikhon> in particular, chances are it was installed to ~/.cabal/bin unless something changed the setting
20:57:09 <hunt> tikhon: what do you make with it
20:57:20 <pawprint> tikhon: thanks.. looks like it was installed to ~/.cabal/bin/pandoc
20:57:23 <tikhon> I just have ~/.cabal/bin in my PATH and everything is happy
20:57:33 <thebnq> hunt: hopefully not taint, just expand :D
20:57:45 <tikhon> hunt: umm, researchy stuff with Haskell—mostly program synthesis
20:57:58 <tikhon> I also did a bunch of OCaml for a couple of summers
20:58:01 <tikhon> which was pretty similar
20:58:08 <tikhon> just worse
20:58:14 <hunt> tikhon: also it took a few years for it to be natural? what do you mean by natural exactly because i have a pretty sufficient grasp on how to do most things in haskell without having to look things up but im not sure if that counts as natural
20:58:29 <thyrgle> I also have another question, so I've been trying to install gtk3 and tried reinstalling stuff
20:58:34 <tikhon> by natural I mean it's now my primary way to think about computation and programming
20:58:58 <Kron> hunt: after a while you start to think in terms of composing, I guess
20:58:59 <tikhon> Even when I'm using another language, I usually think of the functional solution first
20:59:00 <Kron> that's how I'd put it
20:59:01 <thyrgle> and when ever I run sudo cabal install gtk2hs-buildtools I get:
20:59:06 <thyrgle> Warning: The directory /home/christopher/.cabal/bin is not in the system
20:59:07 <thyrgle> search path.
20:59:16 <tikhon> thyrgle: why do you do sudo?
20:59:19 <Kron> you start thinking in terms of separate little steps to process data and you compose them together and you let laziness sort it out for you
20:59:23 <thyrgle> sudo gives permission denied
20:59:24 <hunt> ah i totally understand what you mean, yea ive been trying to imagine what a genius ill be when i finally achieve that state
20:59:29 <Kron> that's how I'm starting to 'feel' like a haskeller anyway
20:59:31 <thyrgle> i mean w/o sudo gives permission denied
20:59:46 <tikhon> huh, I've never had permission issues like that, I don't think
20:59:54 <hunt> Kron: sure i think the analagous option for imperative programming is sorting out computationally/structurally optimal designs
20:59:58 <tikhon> do you install everything with sudo?
21:00:10 <thyrgle> i haven't been having problems till recently
21:00:22 <Kron> it's like... if I wanted to print every number in an array, i'd normally have built a for loop for it
21:00:26 <thyrgle> but i've needed to use sudo
21:00:30 <Kron> iterator variables, increment, etc.
21:00:35 <Kron> now I'd just do
21:00:41 <tikhon> the sudo seems odd: I have everything installed locally to my user directory
21:00:45 <Kron> printArray = fmap print
21:00:45 <hunt> map print arr
21:00:46 <Kron> and I'm done
21:00:51 <tikhon> don't see where permission issues wout come up
21:00:56 <tikhon> would**
21:00:56 <Kron> it's just... applying the print function, on the array. That's all there is to it
21:00:57 <Kron> right
21:00:59 <hunt> why fmap and not map? kron
21:01:01 <hunt> oh array as in not list
21:01:07 <thyrgle> well, sine ive tried upgrading from 1.16 to 1.18 ive had to do it for some reason
21:01:08 <Kron> yeah, fmap is more general
21:01:10 <Kron> but you get the idea
21:01:11 <thyrgle> since*
21:01:15 <Kron> nowadays I don't even say arr
21:01:21 <Kron> I just kind of . compose . them . together
21:01:25 <tikhon> thyrgle: hmm, maybe there's something odd in your config?
21:01:28 <Kron> don't really think about the data, just the procedures
21:01:40 <tikhon> do you happen to know where your packages get installed to?
21:01:44 <hunt> Kron: how long have you been haskelling
21:01:53 <Kron> about 5 months
21:02:00 <hunt> Kron: ah nice im 1 month in
21:02:02 <Kron> started in late september
21:02:11 <hunt> Kron: getting similar vibes
21:02:24 <hunt> Kron: did you read lyah?
21:02:40 <hunt> Kron: it mentions a lot of the point-free style and composition without data
21:02:43 <tikhon> thyrgle: ie, are they in ~/.cabal/package/hackage.haskell.org?
21:02:43 <Kron> yeah
21:02:46 <tikhon> or something like that
21:02:47 <Kron> I started with LYAH myself :)
21:03:07 <thyrgle> no
21:03:12 <tikhon> where then?
21:03:14 <thyrgle> I see ~/.cabal/config
21:03:18 <hunt> jesus im so tired
21:03:24 <hunt> i dont think ive had a full nights sleep all week
21:03:34 <tikhon> but not ~/.cabal/bin or ~/.cabal/packages?
21:03:48 <thyrgle> nope
21:03:51 <tikhon> hmm
21:03:57 <tikhon> for me, that's where everything is installed
21:04:05 <tikhon> at the very least, that's probably why you have to do sudo
21:04:33 <hunt> why is so much of haskell research
21:04:46 <thyrgle> wait why do I have to do sudo?
21:04:55 <Twey> hunt: The question is more ‘why is so much of research Haskell?’
21:05:00 <osnr> hey, does anyone have a good name for "flip bind" :: (a -> m b) -> a -> m b
21:05:06 <osnr> er, m a -> m b
21:05:06 <tikhon> thyrgle: I'm guessing because stuff gets installed in some system directory
21:05:14 <osnr> in the second part
21:05:19 <Kron> hunt: I remember this exercise I was doing a while ago
21:05:20 <hunt> Twey: is so much of research haskell though? im sure theres loads of research groups dedicated to imperative prog
21:05:23 <Kron> https://github.com/1HaskellADay/1HAD/blob/master/exercises/HAD/Y2014/M02/D25/Exercise.hs this one
21:05:24 <tikhon> hunt: I just use Haskell for research incidentally: the actual research isn't about Haskell at all
21:05:38 <Twey> Kron: You can't do this truly point-free.  You'll need to either match on the input or define a helper function that does so.
21:05:53 <Twey> (well, not in any way that approximates readability, anyway)
21:06:03 <Kron> and the expand function was to take a list of pairs, each pair an element and a number of times to replicate the element
21:06:10 <thyrgle> tikhon: So, does running: sudo apt-get install libgtk2.0-dev libgtk-3-dev actually install anything to cabal?
21:06:12 <Twey> There's no list eliminator function :-\
21:06:23 <Twey> Hm, I guess you could fold
21:06:32 <tikhon> thyrgle: I don't think so—I assume the system package manager and cabal do not play well together
21:06:40 <Kron> I remember thinking "Okay, we just repeat the first element and take a number of them equal to the second element", and I just wrote that
21:06:41 <tikhon> I've personally resorted to just always using cabal for everything
21:06:45 <Kron> expand :: [(a, Int)] -> [a]
21:06:45 <Kron> expand = join . map ((take . snd) <*> (repeat . fst))
21:06:47 <Kron> and it works
21:06:54 <Kron> it's just a single line, it's kidna readable too
21:06:58 <tikhon> that said, I'm also not on Debian/Ubuntu, so I don't know how it works there
21:06:59 <thyrgle> tikhon: according to the site I'm using, it says I should use the method I just mentioned
21:07:03 <Kron> Twey: I'm pretty sure I can do it point free
21:07:07 <Kron> it'll be horribly unreadable
21:07:18 <tikhon> apt-get?
21:07:19 <tikhon> hmm
21:07:21 <hunt> :t (<*>)
21:07:21 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
21:07:32 <thyrgle> would that mean there needs to be some sort of flag I need to pass while compiling the gtk?
21:07:40 <tikhon> oh, those aren't Haskell packages, are they?
21:07:44 <tikhon> they're GTK itself
21:07:55 <tikhon> then it's not as much of an issue
21:08:12 <tikhon> but that's also not the problem you're having
21:08:14 <hunt> Kron: thats good
21:08:23 <hunt> Kron: i was going to write it recursively with pattern matching
21:08:28 <tikhon> your problem (at least right now) is with the Haskell module not the C library
21:08:37 <hunt> Kron: i think i have loads of code that could be simplified like that
21:08:44 <Kron> right
21:08:49 <Kron> I used to it explicitly recursively too
21:08:55 <Kron> and then after a while you just... stop
21:09:01 <tikhon> thyrgle: and I think it's because you have a setting somewhere that moves the directory cabal uses to install stuff somewhere else
21:09:11 <Kron> and your code starts to compress and it just starts to read like raw "this is what I want to do to this data"ness
21:09:14 <hunt> Kron: haha yea, im slowly working my way there, my recursion is a lot less explicit now
21:09:16 <tikhon> look in your config file for a setting like prefix : <path>
21:09:27 <hunt> Kron: although clearly not enough
21:09:40 <Kron> I'm nowhere near done learning myself
21:09:48 <hunt> Kron; i think this whole experience is mostly a journey in "what do people love about haskell so much"
21:09:55 <Kron> it is about learning, yeah
21:10:00 <Kron> I remember actually using haskell earlier in C
21:10:15 <tikhon> thyrgle: in particular, under `install-dirs user' and `install-dirs global'
21:10:23 <Kron> I had to sort an array of words by their counts, which was a second array
21:10:31 <Kron> so rather than do it manually, I defined a tuple struct
21:10:37 <thyrgle> /home/christopher/.cabal
21:10:38 <Kron> that had each word and each count
21:10:46 <Kron> and then created my own simple custom comparison function
21:10:57 <Kron> return tuple1.count > tuple2.count;
21:11:03 <Kron> and then used qsort on it
21:11:03 <thyrgle> -and under global
21:11:08 <thyrgle> /usr/local
21:11:10 <Kron> with a function pointer to my new comparison function
21:11:10 <tikhon> thyrgle: hmm, maybe you have cabal set up to install globally by default?
21:11:25 <Kron> so I basically used a higher order function to sort an array of tuples
21:11:29 <Kron> made my code like ten times smaller
21:11:29 <thyrgle> should I pass global as a flag then?
21:11:32 <Kron> trivial to debug too
21:11:44 <hunt> Kron: lol thats excellent, someone should release a C$ or something thats totally functional
21:11:53 <hunt> Kron: and not F#
21:11:55 <tikhon> thyrgle: I think installing locally is better by default
21:11:57 <tikhon> and that's what it should normally do
21:12:10 <tikhon> but if it requires sudo, it's probably doing things globally instead
21:12:14 <tikhon> I'm not sure why though
21:12:56 <hunt> tikhon: what sort of degreedo you get to end up doing research with haskell
21:13:18 <tikhon> I'm actually an undergrad, and I just got to choose my own language for my part of the project
21:14:03 <hunt> tikhon: thats cool, if i may what is the project?
21:14:30 <tikhon> It's a compiler for a weird stack-based low-power architecture (GreenArrays)
21:14:42 <Kron> hmmm
21:14:43 <solrize> http://stackoverflow.com/questions/6964392/speed-comparison-with-project-euler-c-vs-python-vs-erlang-vs-haskell   <-- has anyone done euler problem #12?  that solution looks wrong to me.
21:14:45 <Kron> I'm... close...
21:14:48 <Kron> localMax = map fst . filter ((>) <$> (2*) . fst <*> snd) . (zip <$> drop 1 <*> (zipWith (+) <*> drop 2))
21:14:48 <tikhon> the main point is to show that it's easy to write a compiler like that using synthesis for optimization
21:15:07 <Kron> but while it doesn't quite generate the correct kind of local maxima
21:15:10 <solrize> tikhon you're writing a compiler for the greenarrays processor?  man that thing is weird
21:15:20 <tikhon> Yes. Yes it is.
21:15:21 <Kron> it also signals local maxima if a given number is 'big enough' compared to the other two
21:15:37 <solrize> oh i think i heard your talk about it
21:15:43 <tikhon> maybe
21:15:49 <tikhon> at Bay Hac?
21:15:52 <solrize> yeah
21:15:55 <tikhon> yeah
21:16:15 <Kron> wait, I know...
21:16:42 <solrize> is the chip itself actually interesting/useful?  it sounded really cool at first but it has so many limitations i had a hard time thinking of any plausible applications for it
21:16:58 <tikhon> thyrgle: if you sudo cabal install some other random package, does that work with runhaskell?
21:16:58 <hunt> solrize: the updated solution?
21:17:11 <tikhon> solrize: moderately
21:17:16 <tikhon> it's very energy efficient
21:17:19 <solrize> hunt i don't see an updated solution
21:17:20 <thyrgle> umm. i haven't tried...
21:17:23 <hunt> tikhon: is there a video of the talk? im curious about this whole topic
21:17:30 <thyrgle> give me a sec let me find a package
21:17:31 <tikhon> and could conceivably replace a bunch of embedded chips
21:17:34 <hunt> solrize: the one given as an answer to the 2m34sec solution'
21:17:36 <tikhon> hunt: afraid not
21:17:43 <tikhon> there's going to be a paper at PLDI
21:17:45 <hunt> solrize: how was his talk
21:17:48 <tikhon> soonish
21:17:57 <tikhon> besides, that was a five minute lightning talk
21:17:58 <solrize> hunt the talk was nice but i don't remember anything about it ;)
21:18:02 <tikhon> not much detail
21:18:07 <solrize> tikhon there is a video of your forth day talk
21:18:11 <solrize> i didnt go to that though
21:18:13 <hunt> tikhon: ahhh alright
21:18:26 <hunt> i just find it crazy that im talking to people who have given real talks
21:18:30 <solrize> what do you mean about synthesis?
21:18:33 <hunt> the comp sci community is loveably small
21:18:40 <tikhon> that was really somebody else's talk, mostly about the Forth side of things
21:18:48 <solrize> oh ok
21:19:06 <solrize> hunt giving a talk is a pretty low rung on the cs achievement ladder ;)
21:19:11 <hunt> solrize: http://stackoverflow.com/a/6964760/3217917
21:19:22 <tikhon> synthesis as in automatic programming: automatically generating code to a specification
21:19:27 <tikhon> in this case, we just use that for optimization
21:19:28 <solrize> right it says 842161320 is the answer
21:19:33 <hunt> solrize: from my small seat in high school its pretty impressive
21:19:40 <solrize> but i tihnk it should be 76576500
21:20:06 <solrize> and my program runs in 0.133 seconds
21:21:21 <hunt> solrize: im going to write one up and see how mine runs and well figure this thing out
21:21:48 <solrize> ok
21:23:21 <hunt> should i register my copy of ST3
21:23:23 <haasn> I love questions that go “why is C so much faster than all of these languages” and are basically one answer after the other “look, with some optimizations language X's version is as fast or faster than C”
21:24:11 <tikhon> it works the other way too: any time somebody writes a post like "Haskell is almost as fast as C" somebody else comes along and writes a *more* optimized C version
21:24:27 <xuser> I don't know haskell but can I idle here to look cool?
21:24:39 <tikhon> xuser: you might end up learning Haskell by accident
21:24:57 <xuser> tikhon: ;)
21:25:01 <thyrgle> tikhon: yeah, my internet is really slow, downloading might take a while but thanks for hanging in there with me
21:25:04 <haasn> tikhon: language wars drive innovation
21:25:24 <hunt> solrize: whats your solution?
21:25:27 <xuser> bitemyapp: ping
21:25:44 <Kron> Twey: I have a point free implementation
21:25:46 <Kron> you're going to hate it :P
21:25:49 <solrize> hunt 76576500
21:25:53 <xico> i want to call multiple preprocessors and generators to build a c++ program in which i call some haskell code, can i use cabal for that? should i then try the distribution.simple stuff in a setup.hs?
21:25:54 <solrize> you mean you want to see the code?
21:25:56 <tikhon> haasn: I agree, which is why I find the "all languages are basically equal and we shouldn't argue about them" attitude really annoying
21:26:07 <Kron> localMax = map fst . filter snd . (zip <$> drop 1 <*> (zipWith (&&) <$> (zipWith (>) <$> drop 1 <*> drop 2) <*> (zipWith (<) <*> drop 1)))
21:26:19 <xuser> why did you guys did to bitemyapp? he completely left clojure for haskell
21:26:30 <Kron> that was funny and entirely not how one should actually program in haskell :P
21:26:35 <haasn> tikhon: I wonder if you hold that attitude about religious or political wars, too ;)
21:26:54 <haasn> although I'd prefer an answer in #haskell-blah, not here
21:27:58 <hunt> solrize: thats not dramatically far from the posted one, is it?
21:28:23 <solrize> hunt, if they're different, at least one of them is wrong ;)
21:28:40 <hunt> solrize: wrong or not optimal?
21:28:51 <haasn> xuser: collected by a team of hired thugs and brainwashed
21:28:56 <solrize> hunt it's a math problem.  find the smallest N such that blabla.
21:29:18 <hunt> solrize: but they could both return the correct answer with different implementations
21:29:27 <hunt> solrize: oh thats the number
21:29:32 <solrize> their implementation gives one answer and mine gives another answer
21:29:34 <hunt> solrize: im so stupid, i was looking at the times
21:29:43 <tikhon> solrize: isn't it a Project Euler problem?
21:29:44 <solrize> oh no that's not a time measurement
21:29:49 <solrize> tikhon yes it's euler 12
21:29:49 <hunt> solrize: i thought you were telling me nanoseconds
21:29:53 <solrize> no
21:29:58 <tikhon> solrize: so can't you just use that to check your answer?
21:30:20 <solrize> well i did that problem a while back so i wanted to compare my timing, and found that my answer was different
21:30:24 <solrize> so i dunno which one is right
21:30:27 <solrize> but mine looks right to me ;)
21:30:34 <thyrgle> tikhon: I installed the flamethrower package, and importing flamethrower works fine...
21:31:06 <tikhon> thyrgle: well, now we know it's a Gtk-specific issue and not the fault of your cabal setup
21:31:11 <tikhon> which is broadly a good thing
21:31:13 <Twey> Kron: http://lpaste.net/101175 — actually it wasn't so bad
21:31:14 <solrize> observe:
21:31:16 <solrize> > product [2,2,3,3,5,5,5,7,11,13,17]
21:31:17 <lambdabot>  76576500
21:31:40 <solrize> > let n = 76576500 in length [d | d <- [1..n], n`rem`d == 0]
21:31:43 <haasn> “import flamethrower” <- has haskell become python already?
21:31:44 <lambdabot>  mueval-core: Time limit exceeded
21:31:49 <Twey> Kron: Only one ‘flip id’, so that's good I guess :þ
21:31:49 <solrize> hmm
21:31:55 <Kron> hahah, nice
21:31:55 <solrize> well that says 576 which i run it on my machine
21:31:59 <Kron> I baked my logic into 4 zips
21:32:08 <Kron> and then just pulled the zip apart for the answer
21:32:37 <haasn> Twey: what exactly does this function do?
21:32:58 <Kron> also I particularly love "flip id"
21:33:02 <Kron> any function that uses flip id
21:33:03 <hunt> solrize: how did you get the count of factors?
21:33:04 <solrize> :t (flip id)
21:33:05 <lambdabot> b -> (b -> c) -> c
21:33:05 <Kron> is absolutely hilarious
21:33:20 <Twey> haasn: Calculates the local maxima of a list
21:33:28 <Kron> yess
21:33:28 <solrize> hunt, http://lpaste.net/4733435074115010560
21:33:30 <haasn> what's the local maxima of a list?
21:33:36 <Kron> localMax = map fst . filter snd . (zip <$> drop 1 <*> (zipWith (&&) <$> (zipWith (>) <$> drop 1 <*> drop 2) <*> (zipWith (<) <*> drop 1)))
21:33:46 <Kron> basically, any element bigger than the element before and after
21:33:46 <no-n> what
21:33:50 <no-n> but id just takes one parameter
21:33:53 <Kron> [5,5,6,2] -> [2]
21:33:54 <Kron> err
21:33:56 <Kron> *[6]
21:33:57 <Kron> right.
21:34:04 <Twey> haasn: E.G. [1, 2, 3, 4, 3, 4, 5, 6, 5] → [4, 6]
21:34:13 <haasn> Oh, I came up with something similar to that the other day
21:34:24 <tikhon> no-n: it's type is a -> a
21:34:24 <tikhon> which means you can substitute whatever you want for a
21:34:31 <tikhon> consider (a -> b) -> (a -> b)
21:34:49 <no-n> hmm
21:35:05 <haasn> Kron: I wonder if you could use this http://lpaste.net/101042
21:35:23 <Kron> what on earth is that
21:35:29 <tikhon> you can drop the second set of parentheses
21:35:33 <tikhon> so (a -> b) -> a -> b
21:35:36 <Kron> a tardis?
21:35:41 <haasn> λ evalTardis ?? (10,0) $ traverse (\a -> tardis $ \(next,prev) -> (unwords [if a>prev then ">prev" else "<=prev", if a>next then ">next" else "<=next"], (a,a))) [1,2,3,2,1]
21:35:43 <haasn> [">prev <=next",">prev <=next",">prev >next","<=prev >next","<=prev <=next"]
21:35:49 <Kron> Trans.Class?
21:35:52 <tikhon> and voilà, two arguments
21:35:56 <no-n> tikhon: ahh. weird.
21:36:02 <Kron> our functions are growing strange gender identities
21:36:03 <haasn> but that's probably very overengineered :P
21:36:14 <haasn> Kron: Trans is short for Transformer
21:36:14 <Kron> overengineering is half the fun with these tiny exercises
21:36:16 <Kron> ahhh
21:36:38 <Kron> implement the factorial function!
21:36:46 <Kron> smart way: factorial n = product [1..n]
21:37:10 <Twey> Why is there a ‘Control.Monad.Tardis’
21:37:15 <Twey> Where did you even get this, haasn :þ
21:37:23 <Kron> hilarious way: factorials = zipWith (*) [1..] factorials
21:37:24 <haasn> Twey: http://hackage.haskell.org/package/tardis :)
21:37:28 <Twey> Of course
21:37:29 <tikhon> Twey: it's the combination of the forwards state monad with the reverse state monad
21:37:36 <Kron> factorial = (factorials !!)
21:37:41 <Twey> tikhon: Ah
21:37:42 <haasn> “Where do you get a tardis? On hackage” clearly
21:37:44 <tikhon> it's pretty neat
21:37:54 <thyrgle> so if i did something like sudo apt-get install libghc-gtk-dev would ghc be able to find it?
21:37:56 <Twey> I looked at the reverse state monad once.  It scared me.  Maybe I should try again.
21:38:09 <haasn> Twey: it's the same as the normal state monad
21:38:12 <haasn> Twey: except in reverse
21:38:25 <haasn> I guess that didn't help
21:38:35 <Twey> Not in the slightest :þ
21:38:40 <tikhon> thyrgle: I don't know—try it and see? Worst case, you can apt-get remove it (or whatever the apppropriate command is).
21:38:42 <haasn> Kron: http://www.willamette.edu/~fruehr/haskell/evolution.html
21:38:43 <startling> (>>=) does the opposite thing
21:38:53 <Kron> oh god i've seen that page, I love it
21:39:17 <Kron> prjFun (Fun f) = f
21:39:17 <Kron> prjFun  _      = error "bad function value" hahahah
21:39:49 <thyrgle_> ugh, internet died.
21:40:44 <Twey> Oh, I see… it's just the State monad with a backwards (>>=)
21:40:45 <solrize> kron,
21:40:47 <solrize> localmax [] = []
21:40:47 <solrize> localmax (a:rest@(b:c:cs)) | a<b && c<b = b:localmax rest
21:40:47 <solrize> localmax (x:xs) = localmax xs
21:40:47 <tikhon> thyrgle_: I just said that I don't know if apt-getting the package will work properly, but that it probably can't hurt to try.
21:41:01 <haasn> Twey: basically (m >>= f) = \s -> let (a,s'') = m s'; (b,s') = f a s in (b,s'')
21:41:08 <tikhon> Twey: it's the state monad where the state flows backwards through the computation
21:41:13 <Twey> Right
21:41:22 <tikhon> but the actual values still propagate forwards
21:41:22 <haasn> Twey: the s' flows into the “latter” action first and the result of that flows into the former
21:41:25 <Twey> Cool, I guess.
21:41:27 <haasn> yeah
21:41:29 <Kron> solrize: I like your use of the rest@ binding
21:41:32 <thyrgle_> ok. well, thanks for the help, it doesn't work yet, but i'll work on it some other time then
21:41:34 <haasn> It can be useful but you need to be a bit nonstrict about it :)
21:41:43 <Kron> I'd have changed the last one
21:41:53 <Kron> to localmax (_:xs) = localmax xs
21:42:06 <solrize> k
21:42:12 <haasn> it's great to eg. monadically build up a lazy structure that at some points depends on information only known later on during parsing (eg. the length or size of something)
21:42:43 <Twey> solrize: localMax = concatMap (\case → a : b : c : _ | a < b && b > c → [b]; _ → []) . tails
21:42:55 <Twey> solrize: But the question was to make it point-free
21:43:00 <solrize> oh i didn't see that part
21:43:17 <Twey> solrize: Learn to love LambdaCase ;)
21:43:23 <haasn> Kron: you can also avoid binding _ if you're using rest@
21:43:26 <solrize> @pl (\x -> x*x)
21:43:26 <lambdabot> join (*)
21:43:42 <Twey> solrize: That's not strictly true
21:43:50 <Twey> Well, it is in this case because of the type of (*)
21:43:56 <startling> is it lazily true?
21:44:01 <Kron> right
21:44:03 <Kron> you could just go
21:44:12 <Kron> localmax list = tail list
21:44:23 <Twey> solrize: But join monomorphizes the type of the argument so that it has to be the same for both parameters, which isn't necessarily the case with the lambda
21:44:36 <Twey> startling: If I were being lazy, I might say it's true :þ
21:45:16 <solrize> @pl (let lm xs = \xs -> case xs of { (a:b:c:cs) | a<b && c<b -> b : lm (b:c:cs); [] -> []; (_:xs) -> lm xs }
21:45:16 <lambdabot> (line 1, column 32):
21:45:16 <lambdabot> unexpected "{"
21:45:16 <lambdabot> expecting variable, "(", operator, ";" or "in"
21:45:36 <Twey> Kron: Oh, our functions don't work for infinite lists unlike the pointful versions
21:45:48 <Kron> mine does I think
21:45:49 <Twey> Kron: That can be fixed by using genericLength with lazy numbers
21:45:49 <solrize> @pl (let lm xs = (\xs -> case xs of { (a:b:c:cs) | a<b && c<b -> b : lm (b:c:cs); [] -> []; (_:xs) -> lm xs }))
21:45:50 <lambdabot> (line 1, column 33):
21:45:50 <lambdabot> unexpected "{"
21:45:50 <lambdabot> expecting variable, "(", operator or ")"
21:45:53 <solrize> meh
21:45:53 <Kron> zips work on infinite lists
21:45:58 <Twey> Oh, sorry
21:45:59 <Kron> my zippers will keep on going
21:46:03 <Kron> mwahahahaha
21:46:03 <Twey> my function** :þ
21:46:07 <Kron> I am unstoppable
21:46:09 <Kron> fear my tacit power
21:46:13 <Twey> Heh
21:46:29 <Kron> also mine works on [], [x] and [x,y] and neatly returns []
21:46:30 <haasn> Kron: but can you zip together lenses?
21:46:35 <Kron> basically, zips are overpowered and everyone should use them
21:46:37 <Kron> I have no idea
21:46:39 <Twey> Kron: Mine too
21:46:42 <Kron> probably, if you're edwardk
21:46:55 <startling> haasn: what would "zipping together lenses" mean?
21:47:23 <hunt> solrize: did you figure out the problem yet?
21:48:02 <solrize> i pasted the number 76576500 into a web search and i think it's right
21:48:19 * hackagebot dbus 0.10.7 - A client library for the D-Bus IPC system.  http://hackage.haskell.org/package/dbus-0.10.7 (JohnMillikin)
21:48:34 <solrize> oh wait
21:48:35 <solrize> doh
21:48:37 <solrize> " I search for the first triangle number with more than 1000 divisors instead of 500 as stated in the original problem."
21:49:12 <haasn> startling: Hmm, I forgot the exact use case I was remembering. But I think it has something to do with zipping together structures given traversals or similar, without degrading to []
21:49:35 <solrize> ok, now i get their answer in 0.7 seconds
21:51:09 <Kron> https://github.com/1HaskellADay/1HAD/blob/master/exercises/HAD/Y2014/M03/D11/Exercise.hs
21:51:12 <Kron> this looks... trivial o_o
21:52:12 <tikhon> it's just a trick to get people addicted to Haskell
21:52:23 <MP2E> haha
21:52:41 <tikhon> the first hit's (metaphorically) (and literally) free
21:53:19 <hunt> solrize: lol & that is very fast
21:53:19 * hackagebot CBOR 0.1.0.0 - Encode/Decode values to/from CBOR  http://hackage.haskell.org/package/CBOR-0.1.0.0 (KyleMurphy)
21:53:21 * hackagebot tempodb 0.2.2.1 - A small Haskell wrapper around the TempoDB api.  http://hackage.haskell.org/package/tempodb-0.2.2.1 (ParnellSpringmeyer)
21:53:47 <haasn> Kron: what happens if you pass it ä?
21:53:57 <haasn> empty string? :)
21:53:59 <Kron> that's cheating D:
21:54:02 <solrize> hunt their algorithm is crazy
21:54:39 <haasn> Kron: I personally think that account does more harm than good
21:54:45 <haasn> the solutions posted are almost universally terrible
21:55:09 <Kron> I knowwwww
21:55:13 <Kron> I'm just boooored
21:55:18 <hunt> solrize: seems pretty silly, i dont understand how you count the factors though with product succ length
21:55:40 <Kron> obviously, writing a three line point-free function that uses fifteen zips is entirely the wrong way to go about things
21:55:57 <haasn> https://github.com/1HaskellADay/1HAD/blob/f990eaebff658643045f4cd3f25f32ed3106cd26/exercises/HAD/Y2014/M03/D07/Solution.hs
21:55:58 <haasn> this is just.. no
21:56:19 <haasn> trueIndexes = map (`elem` i) [0..]
21:56:30 <haasn> trueIndexes i = *
21:56:35 <Kron> ahahaha
21:57:11 <Kron> hmmm
21:57:39 <Kron> isn't your version really slow though?
21:57:42 <Kron> the more I think about it
21:57:46 <solrize> hunt, say n = p * p * p * k where p is a prime.  then k, p*k, p*p*k, and p*p*p*k are all factors of n
21:57:49 <Kron> it'll get quadratically slower as you go along
21:57:52 <Kron> especially for infinite lists
21:58:06 <solrize> i.e. the p**3 contributes 4 factors
21:58:13 <haasn> Kron: there's no way to solve the problem for infinite lists
21:58:15 <solrize> similarly p**d contrubutes d+1 factors
21:58:22 <solrize> do that for all the prime factors of n
21:58:23 <Kron> isn't there?
21:58:26 <solrize> and multiply together
21:58:31 <Kron> trueIndexes :: [Int] -> [Bool]
21:58:31 <Kron> trueIndexes = go 0
21:58:31 <Kron>   where go :: Int -> [Int] -> [Bool]
21:58:31 <Kron>         go x (y:ys)
21:58:31 <Kron>           | (x == y)  = True  : go (x + 1) ys
21:58:32 <Kron>           | otherwise = False : go (x + 1) (y:ys)
21:58:34 <Kron>         go _ []       = repeat False
21:58:36 <Kron> gah, sorry
21:58:40 <Kron> should've lpasted
21:58:41 <hunt> solrize: ahhhh thats very cool
21:58:43 <haasn> Kron:  head $ trueIndexes (repeat 2 ++ [0])
21:58:46 <haasn> Kron: True or False?
21:59:19 <Kron> False I think
21:59:37 <haasn> Kron: it doesn't get quadratically slower as it goes along, but it does scale in complexity with the size of the parameter
21:59:37 <Kron> "-- The parameter list is supposed to be sorted and nubbed"
21:59:39 <Kron> that was in the spec
21:59:40 <haasn> ah!
21:59:43 <Kron> it has to be sorted
21:59:45 <Kron> it has to be nubbed
21:59:49 <Kron> you can just walk along it
21:59:53 <Kron> it's not a huge infinite set
21:59:57 <Kron> I mean
21:59:58 <haasn> you are right, I missed that; then you can just use a custom `elem` :)
22:00:03 <Kron> it literally is an infinite set I guess
22:00:09 <Kron> since sets have no duplicates and are ordered
22:00:21 <Kron> I'd love to see your implementation
22:00:39 <Kron> because mine was apparently me giving up and just explicitly writing out the recursion with a helper function
22:00:40 <solrize> tikhon do you have any pages up about your GA compiler ?
22:00:50 <tikhon> umm, not really
22:00:56 <tikhon> there's a paper draft floating around
22:01:07 <haasn> elem _ [] = False; elem i (x:xs) = case compare i x of LT -> elem i xs; EQ -> True; GT -> False
22:01:11 <haasn> Kron: ^
22:01:12 <hunt> solrize: how long does yours run for 1000?
22:01:15 <Kron> hmmm
22:01:19 <solrize> hunt 0.7 sec
22:01:25 <haasn> Kron: oops, flip LT and GT
22:01:27 <Kron> ooh
22:01:28 <tikhon> http://www.eecs.berkeley.edu/~nishant/papers/Chlorophyll.pdf
22:01:34 <Kron> I didn't think about pattern matching on comparisons :D
22:01:34 <hunt> solrize: strange, mine is in 3 seconds and im fairly certain theyre the same
22:01:35 <tikhon> but it's, umm, very drafty
22:01:36 <Kron> that's really neat!
22:01:41 <solrize> hunt use ghc -O2
22:01:50 <haasn> Kron: could just use guards; | x > i = ...
22:02:04 <haasn> But I prefer pattern matching on the result of compare. It's a nice idiom for replacing lots of comparison guards :)
22:02:15 <hunt> solrize: oh wow
22:02:23 <Kron> I kind of prefer the >, < guards
22:02:26 <Kron> they read easier to me
22:02:26 <solrize> i'm on a 2.5 ghz core i5, if you're on an atom or something it might be 3x slower
22:02:35 <Kron> translating to LT and EQ and stuff just reads slower
22:02:41 <hunt> solrize: i get it in ~.4 now
22:02:47 <hunt> solrize: O2 is crazy
22:02:48 <haasn> Kron: fair point. You do get coverage checks though ;)
22:02:50 <jle`> haasn: that's interesting
22:02:50 <solrize> nice
22:02:52 <solrize> yea -O2 helps
22:02:55 <Kron> true that
22:03:11 <jle`> i mean, anyone who sees it would understand
22:03:20 * hackagebot cabal-graphdeps 0.1.2 - Generate graphs of install-time Cabal dependencies  http://hackage.haskell.org/package/cabal-graphdeps-0.1.2 (JohnMillikin)
22:03:23 <jle`> and i might be able to get my eyes used to it
22:04:02 <solrize> tikhon i'd be interested in seeing that paper
22:04:13 <hunt> solrize: you should edit the stackoverflow, thisll blow random browsers minds
22:04:17 <tikhon> http://www.eecs.berkeley.edu/~nishant/papers/Chlorophyll.pdf
22:04:36 <solrize> hunt i think the point of that benchmark was to test the same algorithm across different languages
22:04:37 <tikhon> I don't know of a more current version, although I do think it got edited a bit
22:04:53 <hunt> solrize: right, nevermind
22:04:54 <solrize> i just happened to have my solution kicking around from when i was messing with euler problems
22:05:03 <jle`> what are the semantics of the Monad instance of Data.Sequence ?
22:05:05 <jle`> from containers
22:05:06 <no-n> > (1,) 2
22:05:07 <lambdabot>  (1,2)
22:05:08 <solrize> tikhon thanks
22:05:08 <jle`> is it the same as for List?
22:05:38 <jle`> huh, looks like it is
22:05:39 <Platz> well I think I can finally call my kata complete.. back to studying comonads
22:05:41 <jle`> interesting.
22:05:50 <jle`> what about cocomonads
22:05:57 <Platz> sounds tasty
22:06:13 <jle`> beach boys has a song abaout it
22:06:50 <no-n> :t (,)
22:06:51 <lambdabot> a -> b -> (a, b)
22:07:38 <startling> jle`: I'd guess so
22:07:57 <jle`> why do we even use lists? :P
22:08:27 <tikhon> jle`: at all, you mean?
22:08:28 <startling> they're nice to think about. :)
22:09:27 <jle`> Seq is implemented as a finger tree?
22:09:28 <jle`> that's interesting
22:10:13 <Kron> I just like saying the word 'finger tree'
22:10:16 <Kron> also scapegoat trees
22:11:41 <startling> jle`: lists let you have infinite lists, perform lazily in understandable ways, and let you pattern-match
22:11:45 <mzero> uvula tree
22:11:49 <mzero> just sayin'
22:13:08 <Kron> mzero: lol do those exist?
22:13:23 <Kron> I can't believe you made me google that
22:13:24 <Kron> I hate you
22:13:27 <Kron> :P
22:13:35 <mzero> \o/
22:13:59 <tikhon> now you have an interesting search history
22:14:08 <tikhon> especially without context
22:14:09 <Kron> hun, I always had an interesting search history
22:14:16 <Kron> \o/
22:15:19 <mzero> er, honest... I didn't know it existed! (and now my search history is poluted too)
22:15:37 <mzero> wow - there is just nothin' that can't be found on the internet
22:15:57 <Kron> I want someone to make a Haskell-tan
22:15:59 <Kron> like the OS-tans
22:16:47 <hunt> mzero: a profitable haskell company
22:17:04 <Kron> hunt: buuuuuuurn
22:17:06 <mzero> ba-da-doom!
22:17:07 <Kron> hahahahaaaha
22:17:17 <hunt> haaha
22:17:35 <solrize> tikhon i'm hoping that paper somewhere says in a sentence or two what a synthesizer is
22:17:43 <tikhon> umm
22:17:49 <tikhon> that might be in a referenced paper instead
22:18:07 <tikhon> it's basically a system that automatically writes a program to some specification by searching through the set of possible programs
22:18:22 * hackagebot tempodb 0.2.2.2 - A small Haskell wrapper around the TempoDB api.  http://hackage.haskell.org/package/tempodb-0.2.2.2 (ParnellSpringmeyer)
22:18:29 <tikhon> "Program Synthesis by Sketching" has a good overview, I believe
22:18:57 <tikhon> http://people.csail.mit.edu/asolar/papers/thesis.pdf
22:18:59 <tikhon> it's a bit long though
22:24:28 <hunt> tikhon: have you read that whole thign?
22:24:49 <tikhon> hah, nope
22:25:08 <tikhon> I took a seminar on the subject where we ended up covering the important bits
22:25:44 <tikhon> I did read the parts relevant to the GreenArray stuff
22:28:43 <hunt> is haskell good at writing compilers
22:29:05 <tikhon> well, it's good *for* writing compilers, anyhow
22:29:19 <jle`> hunt: i've heard that it's one of haskell's main uses in industry
22:29:24 <jle`> i could imagine why
22:29:40 <hunt> jle` what are you imagining
22:29:58 <hunt> tikhon: ah thats the word i was looking for
22:29:59 * mzero tries to think what would make a language *bad* for writing compilers...
22:30:16 <haasn> hunt: I'd almost say Haskell is among the best languages to write compilers in
22:30:37 <hunt> haasn: why is that though
22:30:41 <MP2E> Haskell seems to be one of the best languages period, but of course, that is in my opinion
22:30:42 <Twey> mzero: Would you write a compiler in PHP?
22:30:44 <tikhon> mzero: mostly it's things that make it bad for writing other software too
22:30:56 <mzero> Twey - no more or less than I'd write ANYTHING in PHP
22:31:02 <haasn> mzero: an unpredictable language with no abstraction or code reuse, poor ability for code maintenance and lack of proper data structures
22:31:09 <Kron> hiss
22:31:13 <Kron> do not speak the Dread Language's name
22:31:16 <MP2E> haha
22:31:18 <mzero> but haasn, that makes the langauge unfit for writing anything
22:31:29 <Kron> PHP is the black tongue
22:31:32 <Twey> I think having appropriate parsing abstractions (Applicative, Monad) is nice
22:31:41 <haasn> mzero: indeed, which makes me wonder why so many languages today fit that model ;)
22:31:50 <Twey> Resource management doesn't matter so much, I suppose
22:31:53 <mzero> from now on I shall say "the langage that shan't be named"... or TLTSBN for short
22:31:56 <tikhon> some languages are unnecessarily low-level for writing compilers
22:31:59 <Twey> Unless you include the runtime
22:32:00 <tikhon> but they're still used, so eh
22:32:01 <Redz> i heard there a monads in c# now ...
22:32:16 <hunt> yea and c++16
22:32:17 <hunt> or 17
22:32:17 <Redz> *Are
22:32:35 <hunt> were losing our edge
22:32:40 <tikhon> having nice ways to represent ASTs and traverse them generically helps, I suppose
22:32:55 <haasn> mzero: anyway, for compilers in particular I'd want a high isolation of stages/functionality (which pure functions lend itself very nicely to); I'd expect determinism (which purity guarantees); I'd expect resilience and correctness (which pattern matching / coverage checks / type systems etc. help with)
22:32:58 <mzero> hunt: I'd say that write a compiler one needs to be able to do relatively compilcated operations on very tree structures with many compilcated types
22:32:58 <Kron> don't worry hunt
22:33:06 <Kron> we can always maintain that we liked monads before they were cool
22:33:16 <MP2E> #hipsterhaskell
22:33:16 <Kron> while we adjust our hipster glasses on our faces and drive away in teslas
22:33:18 <tikhon> and personally I'm not convinced that OOP presents nearly as good a base for working with ASTs as algebraic data types do
22:33:29 <haasn> mzero: you'd also want lots of sum types. Then again, you'd want lots of sum types for programming in general
22:33:31 <MP2E> agreed
22:34:00 <tikhon> so maybe generics and bananas are what we really need
22:34:01 <mzero> two do so, one needs a language where you can be certain that you don't accidentally mix things up.... and a strong and rich type system is going to help significantly here
22:34:04 <Twey> I guess Haskell's sum type syntax looking like BNF doesn't hurt :þ
22:34:30 <jle`> hunt: yeah, the main advantage is just the easy way to write composable parsers, and their close alignment with BNF
22:34:50 <mzero> so in the end I'd say
22:34:53 <hunt> do most haskellers at some point read the ghc source
22:35:14 <tikhon> umm, my understanding is that it isn't worth reading GHC unless you want to work on it
22:35:16 <jle`> also it's compiled too, so that puts it a bit above interpreted ones in a way; stronger performance and stronger abstractions yay.
22:35:52 <jle`> hunt: do you mean base, or ghc?
22:36:11 <haasn> mzero: oh yes, Haskell is really good at parsing due to its abstractions (applicative, monad) and libraries (parsec, binary, lens, etc.)
22:36:14 <hunt> jle` actually i think i retract my question, im too tired to continue
22:36:21 <mzero> to write compilers one needs to be able to write complex software over a large variety of data.... and to write such complex software, you need a rich and strong type system.... and Haskell has that
22:36:25 <Kron> I myself am going to go to bed
22:36:39 <Kron> had lots of fun, 7/7, would do it again
22:36:42 <jle`> almost everyone has read base at one point or another
22:36:53 <hunt> whats the next step after lyah for learning me a haskell
22:36:54 <haasn> I guess my statements tagged with mzero were directed at hunt, too
22:36:57 <jle`> i was...just doing it now
22:37:07 <Kron> hunt: there is Real World Haskell
22:37:13 <hunt> haasn yea sorry if im not responding to stuff im only barely concscious
22:37:16 <Kron> but I went from LYAH straight to fiddling with pet projects I guess
22:37:19 <Kron> so I'm not really sure
22:37:25 <jle`> are we recommending books
22:37:25 <mzero> Well, haasn, I'd say that it isn't Haskell's abstractions (applicative, monad) ... you can build those in Python too (or even TLTSBN)
22:37:32 <Kron> oh!
22:37:34 <Kron> the haskellwiki
22:37:39 <Kron> has all sorts of assorted nicenesses
22:37:43 <Kron> especially in the tutorials section
22:37:45 <Kron> I love it
22:37:52 <mzero> it's just that Haskell makes it attractive and easy to build and (more importantly) use those abstractions easily and safely
22:38:00 <jle`> yeah, the type safety helps too
22:38:12 <mzero> whcih just brings it back to --- Haskell lets you build powerfull software more easily
22:38:21 <jle`> it's neat when the typechecker basically starts typechecking your parser against the language you are parsing
22:38:23 <mzero> compilers are powerful software.... hence, Haskell is good for compilers
22:38:35 <hunt> why are data types called algebraic types
22:38:37 <Twey> mzero: ‘You can build those in Python too’ — nope
22:38:56 <mzero> BUT, hunt, the real honest / amazing / brain blowing thing about Haskell is.....   .... is it lovely and great for the easy software too!
22:39:08 <tikhon> eh, I think there are some features that are both fairly specific to Haskell *and* would help with a compiler, like generics for traversing different kinds of typed trees uniformly
22:39:15 <hunt> mzero once you get over pressing the space bar
22:39:16 <jle`> hunt: i think it is becuase tehy consist of sums and products of types
22:39:40 <Twey> mzero: Monads require *at least* higher-kinded polymorphism, and preferably some kind of dependent types (or other proof mechanism) to state the laws
22:39:46 <hunt> jle` products of types?
22:39:53 <solrize> tikhon have you actually that output code on GA hardware ?
22:39:55 <tikhon> here's a great series of articles on why algebraic data types are "algebraic": http://chris-taylor.github.io/blog/2013/02/10/the-algebra-of-algebraic-data-types/
22:40:02 <mzero> Twey: there are several monadic parsing frameworks in Python
22:40:11 <tikhon> solrize: a bit, but not for anything practical
22:40:16 <tikhon> they're a *real* pain to use
22:40:17 <Twey> mzero: And yet none of them are monads
22:40:26 <solrize> have you measured the power consumption?
22:40:28 <mzero> you're quibbling
22:40:28 <tikhon> the software that comes with them...
22:40:46 <Platz> I think F# has computation expressions (do notation) but I'm not sure about higher-kinded types
22:40:47 <Twey> mzero: If you're feeling charitable, you can say they're ‘inspired by monads’ or something… but a monad is a type
22:40:47 <jle`> hunt: you product types when you combine two of them at a time.  For example, (Int,String) is a product of the Int type and String type.  i like to think of the term as familiar with the cartesian product
22:40:58 <jle`> hunt: products are "and"
22:41:03 <mzero> from the point of view "can I build parser combintors" ... you can - in Python (or TLTSBN)... they're just ugly as sin to use, and you have absolutely no guard rails
22:41:15 <tikhon> I think somebody else on the team tried to measure the energy usage, but our tools weren't very good. The GreenArrays people—with whom we met a few times—do have their own measurements.
22:41:24 <jle`> hunt: sum types are types that can be one of myna different options.  Like data Bool = True | False
22:41:44 <jle`> or but read chris taylor's article
22:41:45 <Twey> mzero: You have no guard rails because they're not a monad.  That's the bit that being a monad gets you (that and parametricity, which is also conspicuously missing).
22:41:51 <hunt> jle` (Int,String) is a tuple?
22:41:53 <tikhon> "our tools" being the multimeter our CS professor had lying around: not a very high standard!
22:42:00 <hunt> jle` in your example for product
22:42:06 <jle`> um, i'm wrong about sum types
22:42:08 <solrize> hehe
22:42:10 <jle`> stop listening to me :)
22:42:19 <jle`> but yes (Int,String) is the type of a tuple
22:42:32 <jle`> data Either a b = Left a | Right b
22:42:34 <Twey> mzero: Of course you can do *things that you could do with* a monad.  But that doesn't mean it's a monad, any more than C is a monad because it has imperative programs.
22:42:37 <jle`> is a sum of a and b
22:42:55 <tikhon> That said, I think it would be practical to run a chip (but not at full utilization) on a "science fair battery": a bunch of potatoes or something like that
22:42:55 <solrize> i remember being skeptical of their power claims... they are using a .18 micron fab process which has low leakage (so low idle current) but probably more active power than a smaller process
22:43:02 <mzero> Twey - sure, whatever on this - I'm not sure it has anything to do with my point
22:43:08 <hunt> jle` ah
22:43:13 <jle`> Maybe a can be a thought of as a sum between a and ()
22:43:17 <solrize> when you have all cores going full speed it uses 0.5W or so iirc
22:43:18 <tikhon> solrize: part of the trick is that they can trivially turn off unused cores
22:43:26 <tikhon> which is a large win in practice
22:43:28 <jle`> but chris taylor's post explains why it is related to algebra
22:43:37 <solrize> yeah true
22:43:49 <solrize> they said something about doing a 32 bit chip
22:43:55 <Twey> mzero: Well, that means it *is* the ability to abstract over such things that makes it nicer.  Which I think was your point.
22:43:58 <tikhon> umm, I'm not sure what's going on with that
22:44:13 <tikhon> happily, it shouldn't be too difficult to update *our* tools to work with that :)
22:44:18 <tikhon> honestly, I don't care much beyond that
22:45:02 <tikhon> this is actually one of the places Haskell really shines, in my mind: you can "grow" Haskell by adding new number types very easily
22:45:19 <hunt> jle` ah ok thats pretty simple stuff
22:45:24 <tikhon> right now, for example, I some code that uses 18-bit words; switching that out for 32 would take changing a single type synonym
22:45:26 <solrize> yeah, i just remember finding it very difficult to code anything for the processor, and that even if the microbenchmark of picojoules per addition vs. the msp430 is accurate, you end up needing lots more code to make anything happen
22:45:26 <hunt> jle` the algebraity
22:45:46 <mzero> yes yes - monads, parametricity, abstraction --- these are things one needs and Haskell does well.... and Python does poorly. You may wish to argue that Python doesn't do them at all (one definition of poorly)... but there are others here that will take Haskell's monad defintion to task as well....   So, I'll stick to my less absolutist characterization
22:45:50 <tikhon> yeah, writing anything by hand is difficult, which is why we're doing this thing in the first place
22:45:57 <solrize> well the 32-bit numbers should be easy to deal with... i wonder if the programming constraints will be different
22:46:12 <tikhon> they'd probably add new instructions
22:46:31 <hunt> tikhon adding new number types as in new instances of Num
22:46:33 <hunt> ?
22:46:33 <tikhon> we were actually talking about using synthesis techniques to programmatically generate new instructions at one point
22:46:37 <tikhon> that would be pretty neat
22:46:39 <tikhon> hunt: exactly
22:46:48 <tikhon> hunt: they work just like built-in numbers, which is very important
22:47:05 <hunt> tikhon: why is that important outside of the convenience of using * + etc...?
22:47:24 <haasn> Twey: re: monads require higher-order types -> only if you have a type system . . .
22:47:29 <tikhon> it makes it very easy to write code that looks completely normal but is parameterized over the type of number you use
22:47:35 <tikhon> which later on makes it very easy to switch between numbers
22:47:46 <tikhon> it also makes it easy to use "weird" numbers, like my 18-bit words
22:47:48 <mzero> hunt - because then every function that has be written that only relies on those functions will now work for your new type
22:47:57 <Twey> mzero: I already took Haskell's monads to task ;)  But they give you most of the important parts (for a user).  Only the author has to care about whether they obey the laws or not, and that can be checked manually.
22:47:59 <mzero> you get massive reuse this way
22:48:01 <tikhon> (seriously, who else uses 18 bits?)
22:48:14 <Twey> haasn: But if you don't have a type system, you can't have monads.
22:48:31 <haasn> Twey: (maybe you can, just not in a category of types)
22:48:36 <Twey> Right
22:48:43 <mzero> tikhon - I believe several of the early PDP line used 18bit numbers as well as 36 bit numbers
22:48:44 <haasn> but yes
22:48:50 <haasn> without parametricity you lose a lot of useful properties
22:48:55 <hunt> do many people instance Num String?
22:49:00 <Twey> hunt: No
22:49:01 <mzero> no -
22:49:02 <haasn> sure they're equivalent in expressive power, but they're not equivalent in safety and theorems
22:49:02 <tikhon> hunt: I don't think so
22:49:14 <kadoban> hunt: probably not, that sounds pretty gross
22:49:18 <tikhon> mzero: huh, did not know that
22:49:19 <hunt> tikhon: but you do with your 18 byte string?
22:49:22 <Twey> haasn: I'm not sure I'd say they're equivalent in expressive power
22:49:23 <mzero> actually, it isn't common to make instances of Num at all
22:49:30 <tikhon> hunt: not 18 byte string—18 bit number
22:49:45 <hunt> tikhon: oh right.  i need to sleep
22:49:47 <Twey> haasn: You lose parametricity (or possibly just instance inference, depending on how you define that)
22:49:48 <haasn> Twey: computational power, perhaps
22:49:50 <hunt> but this irc is so addicting
22:49:53 <Twey> Computational power, yes
22:49:59 <Twey> Expressive power, not so much
22:50:06 <startling> hunt: I know of exactly one library that has an instance Num String, and it's a joke library.
22:50:14 <hunt> startling: what is it?
22:50:20 <haasn> good ol' acme-php
22:50:34 <mzero> hunt, but if, for example, you make a new data structure, and make it instances of Foldable and Traversable.... well, now you've got a huge treasure trove of code you can just go and use on your data
22:50:36 <hunt> haha thats an actual library
22:50:51 <jle`> foldl' f a xs = xs `seq` foldl f a xs
22:51:18 <haasn> mzero: or write a single lens ;)
22:51:39 <hunt> mzero: so this is why type classes in general are awesome
22:51:40 <solrize> jle` i don't think that foldl' is right
22:51:44 <haasn> (you even get Foldable/Traversable for free)
22:51:54 <hunt> mzero: theyre sort of a more easily extensible oop class
22:52:03 <haasn> except without oop
22:52:07 <jle`> solrize: it's from acme-php
22:52:11 <solrize> oh haha
22:52:20 <mzero> hunt - and really, usually, you have much more assurance that stuff will work then when, say, you make a subclass and hope all the superclass methods will work
22:52:59 <hunt> mzero see i wouldnt know about any of this because ive never had to make anything serious and large
22:53:32 <Twey> haasn: Hm, even computational power doesn't quite cut it.  A typed program is basically *two* programs, one that performs the task and one that reasons about the runtime program.  Python lacks the power to write the latter program.
22:53:57 <mzero> of course... then there is this instance of Num I wrote... http://goo.gl/Sia7R7
22:54:30 <haasn> Twey: an interesting way of seeing things, for sure
22:54:36 <haasn> Twey: I think I agree
22:55:07 <mzero> (far warning, that link has very non-serious Haskell code)
22:56:11 <tikhon> you can also make functions into numbers, which is fun: http://stackoverflow.com/questions/12133932/numbers-as-multiplicative-functions-weird-but-entertaining/12134169
22:56:28 <mzero> tikhon: PDP-1, PDP-4, PDP-7, PDP-9, and PDP-15 were all 18 bit
22:56:32 <Twey> Functions as numbers is nice
22:56:38 <haasn> Num abstracts perfectly well over any Applicative
22:56:39 <tikhon> or, in fact, Applicative Functors in general
22:57:10 <hunt> mzero: can you make C bindings for that?
22:57:16 <mzero> I actually wrote code for the PDP-15 (N.B.: not a PDP-11/15, a PDP-15).   And yes, I have the requisite grey beard
22:58:39 <mzero> hunt - wouldn't it be better to translate the Testament of One into other languages so those programmers can know it directly, rather than make them use it the vulgate indirectly?
22:58:44 <Twey> @let instance (Applicative f, Num a) => Num (f a) where (+) = liftA2 (+); (*) = liftA2 (*); (-) = liftA2 (-); negate = liftA negate; abs = liftA abs; signum = liftA signum; fromInteger = pure . fromInteger
22:58:45 <lambdabot>  .L.hs:145:15:
22:58:45 <lambdabot>      Overlapping instances for Num (a -> a) arising from a use of `+'
22:58:45 <lambdabot>      Matching instances:
22:58:45 <lambdabot>        instance [safe] Num a => Num (a -> a) -- Defined at .L.hs:143:10
22:58:45 <lambdabot>        instance [safe] (Applicative f, Num a) => Num (f a)
22:58:55 <Twey> Oh, we already have one
22:59:12 <triliyn> :t (+) + (+)
22:59:13 <lambdabot> (Num (a -> a -> a), Num a) => a -> a -> a
22:59:20 <Twey> I thought that was removed
22:59:23 <haasn> mzero: I would start with “data Zero -- At first, there was nothing” or something ;)
22:59:25 <Twey> :t (.)
22:59:25 <lambdabot> (b -> c) -> (a -> b) -> a -> c
22:59:30 <Twey> Along with (.) = fmap
23:00:27 <jle`> > ((+) + (+)) 1 2
23:00:28 <lambdabot>  No instance for (GHC.Show.Show a0)
23:00:28 <lambdabot>    arising from a use of `M294049195110290636924944.show_M2940491951102906369...
23:00:28 <lambdabot>  The type variable `a0' is ambiguous
23:00:28 <lambdabot>  Possible fix: add a type signature that fixes these type variable(s)
23:00:28 <lambdabot>  Note: there are several potential instances:
23:00:40 <tikhon> wonderful error message
23:00:41 <jle`> > ((+) + (+)) 1 (2 :: Int)
23:00:42 <lambdabot>  No instance for (GHC.Num.Num
23:00:43 <lambdabot>                     (GHC.Types.Int -> GHC.Types.Int -> GHC.Types.Int))
23:00:43 <lambdabot>    arising from a use of `GHC.Num.+'
23:00:43 <lambdabot>  Possible fix:
23:00:43 <lambdabot>    add an instance declaration for
23:01:08 <jle`> ah we need that instance Num (a -> a -> a)
23:01:22 <jle`> i always thought it was in prelude? :P
23:01:30 <Twey> > ((+) + (+)) (1 :: Int) 2 3 4
23:01:32 <lambdabot>  Couldn't match expected type `a0 -> a1 -> t0'
23:01:32 <lambdabot>              with actual type `GHC.Types.Int'
23:01:34 <hunt> mzero: there can only be One language carrying the power of One
23:01:59 <mzero> hunt: I knew you'd be a true disciple!
23:02:15 <hunt> SHIT
23:02:16 <hunt> i meant to say
23:02:25 <hunt> there can only be One language currying the power of One
23:02:55 <mzero> heh
23:03:13 <Twey> I'm confused
23:03:42 <Twey> I wrote the same Applicative ⇒ Num instance in my local GHCi, and it gave ((+) + (+)) :: Num a => a -> a -> a
23:03:48 <__jim__> is anyone familiar with hgamer3d?
23:04:25 <triliyn> I think the existing instance isn't applicative, just Num a => Num (a -> a)
23:04:35 <triliyn> Not even Num (b -> a)
23:04:38 <Twey> Oh, that was my instance it was talking about
23:04:44 <Twey> Aw.  Okay.
23:04:58 <haasn> triliyn: there's no “existing instance” in base afaik
23:05:09 <triliyn> haasn: but there is in lambdabot
23:05:15 <haasn> triliyn: there's one in http://hackage.haskell.org/package/NumInstances-1.3/docs/Data-NumInstances-Function.html but it's the usual (r -> a)
23:05:25 <haasn> triliyn: Lambdabot imports that one iirc
23:05:33 <__jim__> Or does anyone know of a decent/interesting haskell ame engine?
23:05:38 <__jim__> *game
23:05:40 <haasn> triliyn: and instance Num (a -> a) -- would result in all sorts of ambiguity errors
23:06:00 <haasn> __jim__: gloss is really nice for simple things
23:06:27 <__jim__> simple sounds good, I will check it out. Thanks!
23:07:38 <hunt> with so many people coming in here looking for haskell games how is it that there are still barely any
23:08:04 <jle`> hunt: it starts with you :)
23:08:20 <jle`> you are going to change the world.
23:08:21 <hunt> jle` im actually trying to make a game, but slowly
23:08:27 <jle`> :D
23:08:29 <jle`> great :)
23:08:30 <hunt> jle` i still have to learn haskell
23:08:31 <haasn> hunt: https://github.com/ocharles/netwire-classics
23:08:32 <jle`> blog about it :)
23:08:35 <jle`> haha
23:08:38 <guymann> h
23:08:39 <jle`> that's good too :)
23:09:01 <haasn> hunt: http://hdiff.luite.com/gloss/pong/ :)
23:09:20 <hunt> i dont blog
23:09:24 <hunt> i dont think i will ever blog
23:11:35 <pavonia> Blog about why you don't want to blog
23:12:20 <hunt> haasn: is that pong yours?
23:12:31 <haasn> hunt: originally, yeah
23:12:35 <hunt> that would make me a hypocrite
23:12:43 <hunt> haasn: all of those ghcjs games?
23:12:50 <hunt> haasn: or widgets, rather
23:12:53 <haasn> hunt: no, just the pong example. I did not write it with ghcjs in mind
23:13:04 <haasn> hunt: it's thanks to the awesome work of luite that it was able to just magically run in the browser ;)
23:13:25 <hunt> haasn: what did luuite do? write some way to convert gloss to canvas/js?
23:13:43 <haasn> hunt: yes, plus compiling haskell to javascript in the first place
23:14:06 <hunt> haasn: oh he wrote ghcjs? thats pretty cool.
23:14:49 <jle`> hunt: blogging is a part of haskell culture, it's a rite of passage :)
23:14:51 <jle`> idk why
23:14:54 <jle`> i didn't invent the rules
23:15:00 <jle`> just don't write a monad tutorial
23:15:04 <haasn> jle`: I thought writing-- yep
23:15:21 <jle`> :P
23:15:52 <jle`> a professor i met called an article of mine a monad tutorial and i was mortified
23:15:56 <shachaf> writing++
23:16:01 <hunt> jle` what exactly does the whole passage look like, i know pushing to hackage and giving a talk are in there somewhere
23:16:11 <jle`> nah
23:16:12 <jle`> just blog
23:16:15 <jle`> that's it
23:16:24 <jle`> maybe invent an abstraction or two
23:16:28 <hunt> why dont we all quit haskell and just become bloggers
23:16:33 <jle`> everyone's doing it
23:16:45 <jle`> it's not hard at all in haskell to invent a new abstraction, it's kinda a fun sport
23:16:50 <haasn> how does one “blog”?
23:16:55 <hunt> a new abstraction as in what
23:17:05 <hunt> for the haskell language?
23:17:20 <haasn> using hakyll, I guess ;)
23:17:28 <tikhon> hah, that's exactly what I'm setting up right now
23:17:30 <jle`> haasn: gists is cool too
23:17:32 <jle`> :)
23:17:40 <tikhon> it's a bit of a pain, honestly
23:17:43 <jle`> hunt: a new abstraction like...say...pipes
23:18:16 <hunt> jle` how is this different from just coding anything
23:18:18 <jle`> a new way to look at a problem by wrapping it in an elegant interface and giving it mathy rules you can reason about it with
23:18:26 <jle`> a new way to program
23:18:29 <jle`> :)
23:18:35 <jle`> code new ways to approach coding
23:18:37 <hunt> jle` a new world to live in
23:18:42 <jle`> change the world
23:18:45 <jle`> :)
23:18:53 <jle`> don't be evil
23:18:58 <hunt> be the change you want to see in evil
23:19:07 <assia_t> I'm trying to learn to use quickCheck, while implementing the 99-questions
23:19:17 <assia_t> in problem 15
23:19:32 <assia_t> I'm trying to test a maintainsElements property
23:19:37 <assia_t> defined as:
23:19:37 <haasn> avoid success at all costs
23:19:41 <haasn> that motto works wonderfully
23:19:52 <hunt> haasn thats my life plan
23:19:57 <haasn> mine too
23:20:13 <hunt> haasn haskell makes it easy
23:20:13 <hunt> :)
23:20:16 <assia_t> all (`elem` xs) $ fn xs n
23:20:23 <hunt> burn #2
23:20:25 <assia_t> but
23:20:30 <Aetherspawn> wait
23:20:30 <Aetherspawn> is
23:20:38 <Aetherspawn> (`elem` xs) == flip elem xs ?
23:20:43 <haasn> Aetherspawn: yes
23:20:46 <assia_t> I need to use arbitraryBoundedIntegral (I guess)
23:20:48 <haasn> Aetherspawn: in spirit, at least
23:20:52 <Aetherspawn> holy moly
23:20:58 <Aetherspawn> thats so useful
23:21:06 <Aetherspawn> can you do that for something with 3 or 4 arguments?
23:21:12 <assia_t> and I have no idea how to do this
23:21:13 <haasn> Aetherspawn: not really
23:21:14 <kadoban> yeah, slices are pretty handy stuff. no, only two
23:21:18 <haasn> Aetherspawn: operators in haskell only have two arguments
23:21:23 <haasn> parameters*
23:21:32 <assia_t> Aetherspawn: infix operators are generally just for two parameters
23:21:39 <assia_t> Aetherspawn: unless its (-)
23:21:47 <Aetherspawn> I knew about all that, I just wasnt aware that (`foo` ... ) was legal
23:21:48 <assia_t> Aetherspawn: at least from what I got...
23:21:50 <Aetherspawn> because it looks funny
23:21:51 <haasn> I retract my “in spirit, at least” - they should be precisely equal
23:22:04 <hunt> so wait
23:22:07 <haasn> assia_t: prefix negation is not an operator, I think
23:22:11 <hunt> flip f a = f _ a
23:22:17 <assia_t> haasn: no?
23:22:25 <Iceland_jack> @src flip
23:22:25 <lambdabot> flip f x y = f y x
23:22:47 <kadoban> haasn: i think it is called one at least, even though it doesn't act like the rest in that way
23:22:49 <Aetherspawn> @src (.)
23:22:49 <lambdabot> (f . g) x = f (g x)
23:22:49 <lambdabot> NB: In lambdabot,  (.) = fmap
23:22:50 <shiona> hunt: that would be then scala syntax IIRC, yes
23:22:55 <mzero> assia_t: look at Test.QuickCheck.Modifiers - you shouldn't need to use arbitraryBoundedIntegral directly
23:23:09 <assia_t> mzero: ok...
23:23:11 <mzero> use Positive
23:23:26 <haasn> assia_t: kadoban: you are right, it's called a prefix operator in the report
23:23:30 <haasn> (the only example of such)
23:23:53 <assia_t> yeah.. there's something on that on realworld or learnyou
23:24:06 <mzero> prop_allInOriginal (Positive n) xs = all (`elem` xs) $ fn xs n
23:24:13 <assia_t> like a single line note on that... haha
23:24:14 <hunt> :t flip
23:24:15 <lambdabot> (a -> b -> c) -> b -> a -> c
23:24:25 <kadoban> assia_t: yeah, that's probably where i remember it from, heh
23:24:50 <assia_t> ok...
23:24:53 <mzero> or perhaps, in your case, NonNegative   (isn't 0 a reasonable value for n????)
23:25:03 <assia_t> my battery is going to die
23:25:06 <Aetherspawn> there needs to be more super noob tuts for haskell
23:25:25 <assia_t> I'll find a power source and keep trying, then I'll come back here
23:25:28 <assia_t> btw
23:25:29 <mzero> Aetherspawn: ressurect Barley!
23:25:37 <Aetherspawn> i know people who failed to learn haskell and got mad and now they troll the shit out of it ;(
23:25:49 <mzero> a full interactive development environment and set of tutorial lessons.... all in a web page
23:25:50 <haasn> Aetherspawn: leave them be, I'd say
23:25:53 <assia_t> I'm actually really unsure of my style for writing properties
23:26:09 <assia_t> since I'm usually writing 2-3 solutions for each question
23:26:33 <Aetherspawn> theres this attitude that haskell is too hard or esoteric to do anything with
23:26:39 <mzero> assia_t:  you can parameterize your properties by function, then build a parameterized test case ...
23:26:39 <assia_t> I made "property generators" which take functions as their first parameters
23:26:43 <tikhon> hmm, most people complain that there aren't enough intermediate tutorials for Haskell
23:26:44 <assia_t> yeah
23:26:47 <MP2E> That's a silly attitude
23:26:48 <Aetherspawn> and I think thats just because there aren't very many imperative ==> fp transition tutorials
23:26:50 <assia_t> mzero: that's what I'm doing
23:26:51 <tikhon> well, maybe not "most" but at least "many"
23:26:53 <mzero> assia_t: that is exactly the right thing to do!
23:26:54 <assia_t> mzero: is that ok?
23:26:58 <mzero> \o/
23:27:19 <assia_t> mzero: like: prop_minorEqLength fn xs = (length . fn) xs <= length xs
23:27:22 <Aetherspawn> actually, that's right too
23:27:26 <Aetherspawn> once you finish LYAH and RWH
23:27:28 <mzero> perfect
23:27:29 <Aetherspawn> theres like nowhere to go ...
23:27:41 <Aetherspawn> nothing really explains transformers
23:27:43 <assia_t> Aetherspawn: I finished LYAH yesterday
23:27:51 <mzero> they come here, Aetherspawn, they come here!
23:27:52 <assia_t> Aetherspawn: RWH is next
23:28:07 <Iceland_jack> Aetherspawn: RWH does explains them
23:28:11 <Iceland_jack> *explain
23:28:13 <dmj`> Aetherspawn: people should build websites and do a real project
23:28:20 <assia_t> Aetherspawn: but yesterday someone sent me http://www.haskell.org/haskellwiki/Typeclassopedia
23:28:25 <Iceland_jack> There is also Marlow's book quite is very good and papers
23:28:27 <jle`> assia_t: i like simon marlow's book
23:28:28 <Aetherspawn> the typeclassopedia is awesome
23:28:31 <assia_t> Aetherspawn: which was pretty useful
23:28:36 <mzero> assia_t: that is an excellent thing to read, and return to
23:28:42 <dmj`> Aetherspwan: the aws libs for haskell are great
23:28:46 <assia_t> jle`: I'll take a look
23:28:53 <jle`> i think it teaches you a modern approach to approaching problems in haskell
23:29:00 <jle`> even if you aren't directly working with parallelism/concurrency
23:29:02 <Aetherspawn> some tutorials explain what things are in terms of mathematical rules
23:29:03 <Aetherspawn> criiiinge
23:29:04 <jle`> *modern style
23:29:09 <Iceland_jack> Once you've completed RWH and LYAH you're advanced enough to be able to explore Haskell yourself through papers and such
23:29:17 <mzero> actually - I think after LYAH and RWH.... the next thing to do is read code....
23:29:24 <mzero> read the source to libs....
23:29:25 <jle`> actually after LYAH i just recommend trying to port your old code into haskell
23:29:34 <jle`> presumably you have written at least a few programs in your past
23:29:47 <dmj`> iteratees aren't covered in either lyah not rwh
23:29:53 <jle`> just don't do project euler or anyhting silly like that
23:29:53 <dmj`> nor*
23:29:58 <assia_t> jle`: yes...
23:30:17 <Aetherspawn> is a list as a whole a functor
23:30:26 <jle`> Aetherspawn: ?
23:30:30 <mzero> read code! read Parsec source... read the source to the Prelude. Read the source of Data.Map
23:30:36 <assia_t> jle`: I'm one of those schizophrenic js developers which read Fogus' book and struggle with the most unsafe language out there
23:30:38 <Aetherspawn> > fmap (+1) [1..4]
23:30:39 <lambdabot>  [2,3,4,5]
23:30:39 <dmj`> mzero: agreed
23:30:51 <assia_t> mzero: that's surely on my TODO list
23:30:52 <jle`> understanding how to write parsec is neat and pretty easy.
23:30:53 <Aetherspawn> so is it very idiomatic when you have a huge container or something
23:31:02 <Aetherspawn> to write a functor instance where fmap is map
23:31:06 <assia_t> mzero: and Xmonad, which seems pretty interesting
23:31:14 <jle`> what is yalls favorite functor
23:31:24 <Aetherspawn> my favorite monoid is Ord
23:31:26 <assia_t> yesterday people sent me Lens
23:31:28 <jle`> sory, favorite Functor
23:31:32 <assia_t> which seems pretty nice too
23:31:37 <mcbears> Const a ;)
23:31:47 <Aetherspawn> the monoid instance for ord is incredibly useful
23:31:47 <mzero> Maybe
23:32:00 <jle`> why does maybe even exist
23:32:04 <jle`> it's just a list with 0 or 1 element
23:32:06 <dmj`> Identity
23:32:08 <jle`> :)
23:32:09 <Aetherspawn> comparing x `mappend` comparing y
23:32:10 <Aetherspawn> ;)
23:32:31 <Aetherspawn> :t sortBy
23:32:31 <mcbears> Ordering's Monoid is something specifically miss when writing java or something
23:32:32 <lambdabot> (a -> a -> Ordering) -> [a] -> [a]
23:32:39 <mcbears> I specifically miss*
23:32:42 <assia_t> I'm opening a ghci repl to keep up with this talk
23:32:45 <assia_t> haha
23:32:52 <jle`> assia_t: you can also /q lambdabot :)
23:33:20 <Aetherspawn> when I found out about the Ord monoid
23:33:31 <Aetherspawn> it blew my mind how I could do anything without it
23:33:37 <jle`> what is life
23:33:37 <assia_t> jle`: that's the coolest think ever
23:33:42 <Aetherspawn> :P
23:33:45 <assia_t> ok... you're awesome
23:33:47 <jle`> > 1 + 3
23:33:48 <lambdabot>  4
23:33:50 <assia_t> but I need power
23:34:21 <assia_t> so.... see you soon
23:34:32 <jle`> > do { x <- [1,2,3]; y <- [3,4,5]; guard (x + y == 6); return (x,y) }
23:34:32 <lambdabot>  [(1,5),(2,4),(3,3)]
23:34:36 <assia_t> (power source - not abstract power)
23:34:53 <assia_t> > :t Ordering
23:34:54 <lambdabot>  <hint>:1:1: parse error on input `:'
23:34:59 <assia_t> :P
23:34:59 <jle`> :t Ordering
23:35:00 <lambdabot> Not in scope: data constructor `Ordering'
23:35:11 <Iceland_jack> :t EQ
23:35:12 <mcbears> :t GT
23:35:12 <lambdabot> Ordering
23:35:12 <lambdabot> Ordering
23:35:19 <jle`> looks like he/she's mind was blown too much, they left :/
23:35:39 <Aetherspawn> :P
23:35:55 <Aetherspawn> :t guard
23:35:56 <lambdabot> MonadPlus m => Bool -> m ()
23:35:57 <jle`> heshewe
23:35:59 <jle`> they
23:36:01 <jle`> english
23:36:02 <Aetherspawn> is guard part of MonadPlus ?
23:36:04 <jle`> :/
23:36:08 <jle`> Aetherspawn: no
23:36:17 <jle`> it's just a normal function
23:36:24 <jle`> @src guard
23:36:24 <lambdabot> guard True  =  return ()
23:36:24 <lambdabot> guard False =  mzero
23:36:25 <Aetherspawn> how does it even work
23:36:45 <Iceland_jack> > guard True :: [()]
23:36:46 <lambdabot>  [()]
23:36:47 <Iceland_jack> > guard False :: [()]
23:36:48 <lambdabot>  []
23:36:50 <Apocalisp> fucking monads, how do they work?
23:36:55 <Iceland_jack> > guard True :: Maybe ()
23:36:56 <lambdabot>  Just ()
23:36:57 <Iceland_jack> > guard False :: Maybe ()
23:36:57 <jle`> well the MonadPlus semantics are like
23:36:58 <lambdabot>  Nothing
23:37:03 <jle`> mzero >>= x = x
23:37:06 <jle`> er
23:37:08 <Iceland_jack> Aetherspawn: ↑ does that make sense
23:37:11 <jle`> mzero >>= x = mzero
23:37:16 <Aetherspawn> none at all
23:37:18 <jle`> mzero represents failure, so anything continuing from a failure is a failure
23:37:19 <Aetherspawn> does it map over the whole list?
23:37:28 <Iceland_jack> What?
23:37:32 <Aetherspawn> > do { x <- [1,2,3]; y <- [3,4,5]; guard (x + y == 6); return (x,y) }
23:37:33 <lambdabot>  [(1,5),(2,4),(3,3)]
23:37:36 <Aetherspawn> that's doing it for each element
23:37:38 <Aetherspawn> how does that work
23:37:48 <Iceland_jack> Aetherspawn: Do you know how the [] monad works?
23:38:09 <Iceland_jack> Where
23:38:10 <Iceland_jack>     return x = [x]
23:38:10 <Iceland_jack> and
23:38:10 <Iceland_jack>     (>>=) = flip concatMap
23:38:10 <Aetherspawn> well, sometimes.
23:38:21 <Iceland_jack> @undo do { x <- [1,2,3]; y <- [3,4,5]; guard (x + y == 6); return (x,y) }
23:38:21 <lambdabot> [1, 2, 3] >>= \ x -> [3, 4, 5] >>= \ y -> guard (x + y == 6) >> return (x, y)
23:38:32 <jle`> Aetherspawn: no mean to be shamelessly self promoting, but i wrote a series on monadplus/list monad http://blog.jle.im/entry/practical-fun-with-monads-introducing-monadplus
23:38:46 <Aetherspawn> ta :D
23:38:57 <jle`> er i mean.  someone did
23:38:59 <jle`> i wonder who
23:39:26 <mzero> well I'll be, Ordering is a Monoid
23:39:39 <jle`> > do { x <- return 1; mzero; return x } :: Maybe Int
23:39:40 <lambdabot>  Nothing
23:39:49 <Iceland_jack> > isInfixOf "jle" "http://blog.jle.im/entry/practical-fun-with-monads-introducing-monadplus"
23:39:50 <jle`> > do { x <- return 1; return (x+1) } :: Maybe Int
23:39:50 <lambdabot>  True
23:39:51 <lambdabot>  Just 2
23:40:01 <jle`> Iceland_jack: :P
23:40:11 <jle`> mzero says 'stop right there. you shall not pass.'
23:40:34 <no-n> :t mzero
23:40:35 <lambdabot> MonadPlus m => m a
23:40:40 <mzero> you do realize that every one of those examples beeps my friggin IRC client, right?
23:40:44 <jle`> > do { x <- return 1; mzero; return (x+1) } :: [Int] }
23:40:45 <lambdabot>  <hint>:1:52: parse error on input `}'
23:40:47 <jle`> > do { x <- return 1; mzero; return (x+1) } :: [Int]
23:40:48 <lambdabot>  []
23:40:52 <jle`> mzero: lmao
23:41:09 <no-n> mzero: I have coloured nicks, so yes :P
23:41:23 <jle`> > do { x <- return 1; return (x+1) } :: [Int]
23:41:24 <lambdabot>  [2]
23:41:40 <shachaf> mzero: You know the trick with the (a ->) and Ordering Monoid instances?
23:41:55 <jle`> > do { x <- [1,2,3]; return [x*2,x*3] }
23:41:56 <lambdabot>  [[2,3],[4,6],[6,9]]
23:42:11 <jle`> > do { x <- [1,2,3]; guard (even x); return [x*2,x*3] }
23:42:12 <lambdabot>  [[4,6]]
23:42:31 <jle`> that wasn't quit ea good example, oops.
23:42:36 <mzero> no, shachaf, show us!
23:42:39 <shachaf> > sortBy (comparing length <> compare) ["blah", "word", "z", "some", "words"]
23:42:40 <lambdabot>  ["z","blah","some","word","words"]
23:42:41 <jle`> > do { x <- [1,2,3]; [x*2,x*3] }
23:42:41 <lambdabot>  [2,3,4,6,6,9]
23:42:50 <jle`> > do { x <- [1,2,3]; guard (even x); [x*2,x*3] }
23:42:51 <lambdabot>  [4,6]
23:43:03 <shachaf> Sorts by length and then lexicographically, for instance.
23:43:23 <mzero> lovely
23:43:24 <jle`> all of 1, 2, and 3 contribute to [2,3, 4,6, 6,9].  but if you guard even, then only 2 will contribute to the end result
23:43:34 * hackagebot cipher-aes 0.2.7 - Fast AES cipher implementation with advanced mode of operations  http://hackage.haskell.org/package/cipher-aes-0.2.7 (VincentHanquez)
23:43:42 <Aetherspawn> baha
23:44:04 <Aetherspawn> I just realized I think I actually can solve the wolf cabbage sheep problem using guard and the list monad in like 3 lines
23:44:31 <mzero> mzero >>= bed
23:44:34 <mzero> night all
23:44:37 <no-n> :o
23:44:39 <Aetherspawn> night
23:44:42 <jle`> mzero >>= bed = mzero
23:44:46 <jle`> so...he should still be here
23:44:47 <Aetherspawn> if bed is lazy you just thunked.
23:44:51 <Aetherspawn> ^
23:44:53 <no-n> lol jle`
23:45:03 <jle`> @tell mzero mzero >>= bed = mzero, so you should still be here.
23:45:03 <lambdabot> Consider it noted.
23:46:33 <assia_t> I'm back
23:47:20 <jle`> sup
23:48:10 <assia_t> battery percentages, thankfully
23:48:34 * hackagebot egison 3.3.2 - Programming language with non-linear pattern-matching with backtracking  http://hackage.haskell.org/package/egison-3.3.2 (SatoshiEgi)
23:48:48 <assia_t> mm... I'm not sure these QuickCheck.Modifiers are what I was looking for
23:50:11 <Aetherspawn> non linear pattern matching with backtracking
23:50:14 <Aetherspawn> that sounds ... awesome
23:50:34 <assia_t> I need to be able to write a property which constrains itself to small-ish numbers, so the tests don't take forever checking every element of the output list existed in the input list... Maybe it's a stupid property though.
23:55:17 <hunt> whose whera
23:55:22 <guymann> h
23:55:25 <hunt> why am i awake
23:55:29 <guymann> [✔] Same
23:55:31 <guymann> Fri Mar 14 02:52:00 EDT 2014
23:55:38 <hunt> how did you successfully read that
23:56:06 <hunt> it was not english
23:56:33 <hunt> confession:
23:56:36 <hunt> i dont know what haskell is
23:56:52 <hunt> i only pretend
23:57:11 <hunt> goodnight
23:58:44 <assia_t> good night
